<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux：/proc/kmsg 与 /proc/sys/kernel/printk_xxx - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux：/proc/kmsg 与 /proc/sys/kernel/printk_xxx" />
<meta property="og:description" content="目录 前言一、/proc/kmsg1、简介2、如何修改内核日志缓冲区3、dmesgklogctl 函数（来源于 man 手册） 4、扩展阅读 二、 /proc/sys/kernel/printk_xxx三、/dev/kmsg 前言 本篇文章将为大家介绍与 Linux 内核日志相关的一些控制文件，共同学习！
一、/proc/kmsg 1、简介 /proc/kmsg 是一个特殊的文件，它提供了内核消息缓冲区的访问，这个缓冲区包含了内核产生的所有消息，包括各种调试和错误信息，如内核的启动打印。/proc/kmsg 文件通常只能被 root 用户或具有相应权限的用户读取。这个文件通常被用于调试和故障排除，因为它可以提供关于内核发生事件的详细信息。
注意：这是一个缓冲区，所以其内的数据是会被刷新覆盖的！！！
一般情况下，你可以使用以下方式来使用 /proc/kmsg 文件：
1、读取内核消息：你可以使用命令行工具如 `cat` 或 `dmesg` 来查看和读取`/proc/kmsg`文件 中的内核消息。例如，使用以下命令可以显示最近的内核消息： cat /proc/kmsg 这样做可以帮助你查看内核启动时的各种信息、硬件错误、系统调试等。 需要注意的是，`/proc/kmsg` 文件一般只能被 root 用户或具有相应权限的用户访问，因此在使用 时请确保你有足够的权限。此外，了解内核消息的解释和上下文对正确理解和利用 `/proc/kmsg` 中 的信息非常重要。 2、如何修改内核日志缓冲区 有时候我们发现，dmesg看到的日志信息缺少了很多，或者存储的很少，这个是因为内核日志缓冲区设置的较小，无法存储更多的内容，可以适当调整该缓冲区的大小。
建议不要调整的过大，正常的产品使用128KB即可，若是自己调试排查问题可以设置的大一点，比如2MB，根据自己的物理内存资源合理设置。
3、dmesg /proc/kmsg 文件和 dmesg 命令之间有着紧密的关系。
/proc/kmsg 文件提供了对内核消息缓冲区的直接访问，通过读取该文件可以查看最近的内核消息。dmesg 命令是一个通用命令行工具，主要用于显示和控制内核环缓冲区。使用 dmesg 命令可以更方便地查看内核日志消息，包括从开机到当前时间内的所有内核日志消息。
实际上，dmesg 命令背后的实现原理也是通过读取 /proc/kmsg 文件来获取内核消息的。当我们在终端中执行 dmesg 命令时，它会读取 /proc/kmsg 文件的内容并将其显示在终端上。
因此，可以说 /proc/kmsg 文件是 dmesg 命令的底层实现之一。在使用 dmesg 命令的时候，实际上是在调用 /proc/kmsg 文件提供的接口来获取内核日志。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a413d12c769cf2383fd2f70c865f789e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T19:48:58+08:00" />
<meta property="article:modified_time" content="2024-01-14T19:48:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux：/proc/kmsg 与 /proc/sys/kernel/printk_xxx</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#prockmsg_3" rel="nofollow">一、/proc/kmsg</a></li><li><ul><li><a href="#1_4" rel="nofollow">1、简介</a></li><li><a href="#2_21" rel="nofollow">2、如何修改内核日志缓冲区</a></li><li><a href="#3dmesg_26" rel="nofollow">3、dmesg</a></li><li><ul><li><a href="#klogctl__man__205" rel="nofollow">klogctl 函数（来源于 man 手册）</a></li></ul> 
   </li><li><a href="#4_332" rel="nofollow">4、扩展阅读</a></li></ul> 
  </li><li><a href="#_procsyskernelprintk_xxx_334" rel="nofollow">二、 /proc/sys/kernel/printk_xxx</a></li><li><a href="#devkmsg_358" rel="nofollow">三、/dev/kmsg</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>  <code>本篇文章将为大家介绍与 Linux 内核日志相关的一些控制文件，共同学习！</code></p> 
<h2><a id="prockmsg_3"></a>一、/proc/kmsg</h2> 
<h3><a id="1_4"></a>1、简介</h3> 
<p>  <code>/proc/kmsg</code> 是一个特殊的文件，它提供了内核消息缓冲区的访问，这个缓冲区包含了内核产生的所有消息，包括各种调试和错误信息，如内核的启动打印。<code>/proc/kmsg</code> 文件通常只能被 root 用户或具有相应权限的用户读取。这个文件通常被用于调试和故障排除，因为它可以提供关于内核发生事件的详细信息。<br> <img src="https://images2.imgbox.com/4d/33/YvwNLUmd_o.png" alt="在这里插入图片描述"><br>   <mark>注意：这是一个缓冲区，所以其内的数据是会被刷新覆盖的！！！</mark></p> 
<p>  一般情况下，你可以使用以下方式来使用 <code>/proc/kmsg</code> 文件：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、读取内核消息：你可以使用命令行工具如 <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span><span class="token variable">`</span></span> 或 <span class="token variable"><span class="token variable">`</span><span class="token function">dmesg</span><span class="token variable">`</span></span> 来查看和读取<span class="token variable"><span class="token variable">`</span>/proc/kmsg<span class="token variable">`</span></span>文件
中的内核消息。例如，使用以下命令可以显示最近的内核消息：
   <span class="token function">cat</span> /proc/kmsg
这样做可以帮助你查看内核启动时的各种信息、硬件错误、系统调试等。

需要注意的是，<span class="token variable"><span class="token variable">`</span>/proc/kmsg<span class="token variable">`</span></span> 文件一般只能被 root 用户或具有相应权限的用户访问，因此在使用
时请确保你有足够的权限。此外，了解内核消息的解释和上下文对正确理解和利用 <span class="token variable"><span class="token variable">`</span>/proc/kmsg<span class="token variable">`</span></span> 中
的信息非常重要。
</code></pre> 
<h3><a id="2_21"></a>2、如何修改内核日志缓冲区</h3> 
<p>  有时候我们发现，dmesg看到的日志信息缺少了很多，或者存储的很少，这个是因为内核日志缓冲区设置的较小，无法存储更多的内容，可以适当调整该缓冲区的大小。</p> 
<p>  建议不要调整的过大，正常的产品使用128KB即可，若是自己调试排查问题可以设置的大一点，比如2MB，根据自己的物理内存资源合理设置。<br> <img src="https://images2.imgbox.com/7d/2b/L82mWJ4R_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3dmesg_26"></a>3、dmesg</h3> 
<p>  <code>/proc/kmsg</code> 文件和 <code>dmesg</code> 命令之间有着紧密的关系。</p> 
<p>  <code>/proc/kmsg</code> 文件提供了对内核消息缓冲区的直接访问，通过读取该文件可以查看最近的内核消息。<code>dmesg</code> 命令是一个通用命令行工具，主要用于显示和控制内核环缓冲区。使用 <code>dmesg</code> 命令可以更方便地查看内核日志消息，包括从开机到当前时间内的所有内核日志消息。</p> 
<p>  实际上，<code>dmesg</code> 命令背后的实现原理也是通过读取 <code>/proc/kmsg</code> 文件来获取内核消息的。当我们在终端中执行 <code>dmesg</code> 命令时，它会读取 <code>/proc/kmsg</code> 文件的内容并将其显示在终端上。</p> 
<p>  因此，可以说 <code>/proc/kmsg</code> 文件是 <code>dmesg</code> 命令的底层实现之一。在使用 <code>dmesg</code> 命令的时候，实际上是在调用 <code>/proc/kmsg</code> 文件提供的接口来获取内核日志。<br> <img src="https://images2.imgbox.com/98/1f/uw5DZC2q_o.png" alt="在这里插入图片描述"></p> 
<p><strong>以下文件来自busybox源码：busybox\util-linux\dmesg.c</strong></p> 
<pre><code class="prism language-c"><span class="token comment">/* vi: set sw=4 ts=4: */</span>
<span class="token comment">/*
 *
 * dmesg - display/control kernel ring buffer.
 *
 * Copyright 2006 Rob Landley &lt;rob@landley.net&gt;
 * Copyright 2006 Bernhard Reutner-Fischer &lt;rep.nop@aon.at&gt;
 *
 * Licensed under GPLv2, see file LICENSE in this source tree.
 */</span>
<span class="token comment">//config:config DMESG</span>
<span class="token comment">//config:	bool "dmesg (3.7 kb)"</span>
<span class="token comment">//config:	default y</span>
<span class="token comment">//config:	select PLATFORM_LINUX</span>
<span class="token comment">//config:	help</span>
<span class="token comment">//config:	dmesg is used to examine or control the kernel ring buffer. When the</span>
<span class="token comment">//config:	Linux kernel prints messages to the system log, they are stored in</span>
<span class="token comment">//config:	the kernel ring buffer. You can use dmesg to print the kernel's ring</span>
<span class="token comment">//config:	buffer, clear the kernel ring buffer, change the size of the kernel</span>
<span class="token comment">//config:	ring buffer, and change the priority level at which kernel messages</span>
<span class="token comment">//config:	are also logged to the system console. Enable this option if you</span>
<span class="token comment">//config:	wish to enable the 'dmesg' utility.</span>
<span class="token comment">//config:</span>
<span class="token comment">//config:config FEATURE_DMESG_PRETTY</span>
<span class="token comment">//config:	bool "Pretty output"</span>
<span class="token comment">//config:	default y</span>
<span class="token comment">//config:	depends on DMESG</span>
<span class="token comment">//config:	help</span>
<span class="token comment">//config:	If you wish to scrub the syslog level from the output, say 'Y' here.</span>
<span class="token comment">//config:	The syslog level is a string prefixed to every line with the form</span>
<span class="token comment">//config:	"&lt;#&gt;".</span>
<span class="token comment">//config:</span>
<span class="token comment">//config:	With this option you will see:</span>
<span class="token comment">//config:		# dmesg</span>
<span class="token comment">//config:		Linux version 2.6.17.4 .....</span>
<span class="token comment">//config:		BIOS-provided physical RAM map:</span>
<span class="token comment">//config:		 BIOS-e820: 0000000000000000 - 000000000009f000 (usable)</span>
<span class="token comment">//config:</span>
<span class="token comment">//config:	Without this option you will see:</span>
<span class="token comment">//config:		# dmesg</span>
<span class="token comment">//config:		&lt;5&gt;Linux version 2.6.17.4 .....</span>
<span class="token comment">//config:		&lt;6&gt;BIOS-provided physical RAM map:</span>
<span class="token comment">//config:		&lt;6&gt; BIOS-e820: 0000000000000000 - 000000000009f000 (usable)</span>

<span class="token comment">//applet:IF_DMESG(APPLET(dmesg, BB_DIR_BIN, BB_SUID_DROP))</span>

<span class="token comment">//kbuild:lib-$(CONFIG_DMESG) += dmesg.o</span>

<span class="token comment">//usage:#define dmesg_trivial_usage</span>
<span class="token comment">//usage:       "[-c] [-n LEVEL] [-s SIZE]"</span>
<span class="token comment">//usage:#define dmesg_full_usage "\n\n"</span>
<span class="token comment">//usage:       "Print or control the kernel ring buffer\n"</span>
<span class="token comment">//usage:     "\n	-c		Clear ring buffer after printing"</span>
<span class="token comment">//usage:     "\n	-n LEVEL	Set console logging level"</span>
<span class="token comment">//usage:     "\n	-s SIZE		Buffer size"</span>
<span class="token comment">//usage:     "\n	-r		Print raw message buffer"</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/klog.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"libbb.h"</span></span>

<span class="token keyword">int</span> <span class="token function">dmesg_main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> MAIN_EXTERNALLY_VISIBLE<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">dmesg_main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc UNUSED_PARAM<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> len<span class="token punctuation">,</span> level<span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> opts<span class="token punctuation">;</span>
	<span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
		OPT_c <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
		OPT_s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
		OPT_n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
		OPT_r <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	opts <span class="token operator">=</span> <span class="token function">getopt32</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> <span class="token string">"cs:+n:+r"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>opts <span class="token operator">&amp;</span> OPT_n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">klogctl</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> level<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token function">bb_simple_perror_msg_and_die</span><span class="token punctuation">(</span><span class="token string">"klogctl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>opts <span class="token operator">&amp;</span> OPT_s<span class="token punctuation">)</span><span class="token punctuation">)</span>
		len <span class="token operator">=</span> <span class="token function">klogctl</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* read ring buffer size */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span>
		len <span class="token operator">=</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span>
		len <span class="token operator">=</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>

	buf <span class="token operator">=</span> <span class="token function">xmalloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	len <span class="token operator">=</span> <span class="token function">klogctl</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">(</span>opts <span class="token operator">&amp;</span> OPT_c<span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* read ring buffer */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">bb_simple_perror_msg_and_die</span><span class="token punctuation">(</span><span class="token string">"klogctl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>


	<span class="token keyword">if</span> <span class="token punctuation">(</span>ENABLE_FEATURE_DMESG_PRETTY <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>opts <span class="token operator">&amp;</span> OPT_r<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

		<span class="token comment">/* Skip &lt;[0-9]+&gt; at the start of lines */</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> buf<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span>in<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'&gt;'</span> <span class="token operator">&amp;&amp;</span> in <span class="token operator">&lt;</span> len<span class="token punctuation">)</span>
					<span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				last <span class="token operator">=</span> buf<span class="token punctuation">[</span>in<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token function">putchar</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>in <span class="token operator">&gt;=</span> len<span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/* Make sure we end with a newline */</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
			<span class="token function">bb_putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">full_write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
			<span class="token function">bb_putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>ENABLE_FEATURE_CLEAN_UP<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXTERNALLY_VISIBLE</span> <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token function">visibility</span><span class="token punctuation">(</span></span><span class="token string">"default"</span><span class="token expression"><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAIN_EXTERNALLY_VISIBLE</span> <span class="token expression">EXTERNALLY_VISIBLE</span></span>

`EXTERNALLY_VISIBLE` 是一个宏定义，用于通过 `<span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`
属性将声明的符号设置为外部可见。

`<span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>` 是 GNU C 编译器的语法扩展，可以用于指定符号
的可见性。可见性标记是用于控制符号在链接阶段的可见性，即决定符号是否能够被其他目标文件或
动态链接库访问。

通常情况下，默认可见性会被应用于所有的符号。然而，如果我们想将符号标记为外部可见（即在其他
目标文件或动态链接库中可用），就需要使用 `<span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>` 属性
来指定这一可见性。

在这个宏定义中，`EXTERNALLY_VISIBLE` 用于将一个声明设置为外部可见，这意味着其他源文件或
程序可以访问该声明。这样做的一个常见原因是要提供一个公共的接口，使得其他模块或库可以使用它
。在使用这个宏定义时，通常会将它与函数、变量或类型声明一起使用，如下所示：

EXTERNALLY_VISIBLE <span class="token keyword">int</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
EXTERNALLY_VISIBLE <span class="token keyword">extern</span> <span class="token keyword">int</span> my_variable<span class="token punctuation">;</span>


这样一来，通过 `EXTERNALLY_VISIBLE` 宏定义，这些声明就会被设置为外部可见，可以在其他源文
件或程序中使用和访问。

对于符号的可见性，有几个不同的级别，其中包括 <span class="token keyword">default</span>（默认），hidden（隐藏），protected
（受保护）和 internal（内部）等。

<span class="token keyword">default</span>（默认）可见性是指符号在链接过程中会被默认导出，可以被其他目标文件或动态链接库访问
。这是最常见的可见性级别。

hidden（隐藏）可见性是指符号在链接过程中不会被导出，只能在定义它的目标文件内部使用。其他
目标文件或动态链接库无法直接访问该符号。

protected（受保护）可见性介于 <span class="token keyword">default</span> 和 hidden 之间，在某些情况下限制了符号的可见性，
但又允许共享库之间的访问。

internal（内部）可见性是 GNU C 扩展中的一个特殊级别，用于指定符号只能在同一编译单元内
可见。这意味着该符号只能在定义它的源文件内部使用。
</code></pre> 
<h4><a id="klogctl__man__205"></a>klogctl 函数（来源于 man 手册）</h4> 
<p><code>klogctl</code> 函数用于控制内核消息日志，头文件为 <code>#include &lt;sys/klog.h&gt;</code>。它有以下原型：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">syslog</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>bufp<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* No wrapper provided in glibc */</span>
<span class="token keyword">int</span> <span class="token function">klogctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><code>type</code>：指定要执行的操作类型。它可以是以下值之一：</li></ul> 
<pre><code class="prism language-bash">类型参数确定此函数所执行的操作。下面的列表指定了类型的值。符号名称在内核源代码中定义，但不
导出到用户空间；您要么使用数字，或者自己实现宏定义。

SYSLOG_ACTION_CLOSE <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	Close the log.  Currently a NOP.

SYSLOG_ACTION_OPEN <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	Open the log.  Currently a NOP.

SYSLOG_ACTION_READ <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
	从日志中读取。该调用等待，直到内核日志缓冲区为非空，然后将最多len字节读取到bufp指向的
缓冲区中。该调用返回读取的字节数。从日志中读取的字节从日志缓冲区中消失：信息只能读取一次。
这是当用户程序读取/proc/kmsg时内核执行的函数。
	
SYSLOG_ACTION_READ_ALL <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
	读取环形缓冲区中剩余的所有消息，将它们放在bufp指向的缓冲区中。该调用从日志缓冲区读取
最后一个len字节（非破坏性），但读取的字节数不会超过自上次“清除环形缓冲区”命令以来写入缓冲
区的字节数（请参阅下面的命令5）。该调用返回读取的字节数
		
SYSLOG_ACTION_READ_CLEAR <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
	读取并清除环形缓冲区中剩余的所有消息。该调用与类型为3的调用完全相同，但也执行“清除环
形缓冲区”命令。

SYSLOG_ACTION_CLEAR <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
	该调用仅执行“清除环形缓冲区”命令。bufp和len参数将被忽略。此命令并不能真正清除环形
缓冲区。相反，它设置了一个内核记账变量，用于确定命令3（SYSLOG_ACTION_READ_ALL）和 <span class="token number">4</span>
（SYSLOG_ACTION_READ _CLEAR）返回的结果。此命令对命令2（SYSLOG_ACTION_READ）和 <span class="token number">9</span>
（SYSLOG_ACTION_SIZE_UNREAD）没有影响。

SYSLOG_ACTION_CONSOLE_OFF <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
	该命令保存console_loglevel的当前值，然后将console_log级别设置为
minimum_console_lowlevel，这样就不会向控制台打印任何消息。在Linux <span class="token number">2.6</span>.32之前，该命令
只需将console_loglevel设置为minimum_console_longlevel。请参阅下面
对/proc/sys/kernel/printk的讨论。bufp和len参数将被忽略。

SYSLOG_ACTION_CONSOLE_ON <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
	如果执行了以前的SYSLOG_ACTION_CONSOLE_OFF命令，则此命令会将CONSOLE_loglevel恢复
为该命令保存的值。在Linux <span class="token number">2.6</span>.32之前，此命令只需将console_loglevel设置为
default_console_loglevel。请参阅下面对/proc/sys/kernel/printk的讨论。bufp和len参数
将被忽略。

SYSLOG_ACTION_CONSOLE_LEVEL <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
	该调用将console_loglevel设置为len中给定的值，该值必须是介于1和8之间（包括1和8）的
整数。内核静默地强制len的最小值minimum_console_loglevel。有关详细信息，请参阅日志级别
部分。bufp参数被忽略。

SYSLOG_ACTION_SIZE_UNREAD <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>since Linux <span class="token number">2.4</span>.10<span class="token punctuation">)</span>
	该调用返回当前可通过命令2（SYSLOG_ACTION_READ）从内核日志缓冲区读取的字节数。bufp
和len参数将被忽略。

SYSLOG_ACTION_SIZE_BUFFER <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>since Linux <span class="token number">2.6</span>.6<span class="token punctuation">)</span>
	此命令返回内核日志缓冲区的总大小。bufp和len参数将被忽略。

	除3和10之外的所有命令都需要特权。在2.6.37之前的Linux内核中，命令类型3和10被允许用于
非特权进程；自Linux以来2.6.37，只有当/proc/sys/kernel/dmesg_restrict的值为0时，才允许
无特权进程使用这些命令。在Linux <span class="token number">2.6</span>.37之前，“特权”意味着呼叫者具有CAP_SYS_ADMIN能力。
从Linux <span class="token number">2.6</span>.37开始，“privileged”表示调用者具有CAP_SYS_ADMIN功能（现在已弃用）或（新的）
CAP_SYSLOG功能。
</code></pre> 
<ul><li><code>buf</code>：用于读取或写入内核日志的缓冲区。</li><li><code>len</code>：长度。</li></ul> 
<p>  <code>klogctl</code> 函数允许您控制内核消息日志的操作，例如打开或关闭日志记录，读取最近的日志消息或将消息写入日志中。您可以使用相关的 <code>type</code> 值执行不同的操作，并通过 <code>buf</code> 参数进行数据的读取或写入。<mark>需要注意的是，<code>klogctl</code> 函数仅在 Linux 系统中可用，且需要以管理员权限运行。</mark></p> 
<p>  <strong><mark>/proc/sys/kernel/printk：</mark></strong></p> 
<pre><code class="prism language-bash">	/proc/sys/kernel/printk是一个可写文件，包含四个整数值，这些整数值在打印或记录错误
消息时会影响内核printk（）的行为。这四个值是：

console_loglevel
	只有日志级别低于此值的消息才会打印到控制台。该字段的默认值为default_CONSOLE_LOGLEVEL
（7），但如果内核命令行包含单词“quiet”，则将其设置为4；如果内核命令行将包含单词“debug”，
则设置为10；如果出现内核故障，则设置至15（10和15只是愚蠢的，相当于8）。console_loglevel
的值可以通过类型为8的syslog（）调用设置（设置为1–8范围内的值）。

default_message_loglevel
	此值将用作没有显式级别的printk（）消息的日志级别。在Linux <span class="token number">2.6</span>.38之前（包括该版本），
该字段的硬编码默认值为4（KERN_WARNING）；自Linux <span class="token number">2.6</span>.39以来，默认值是由内核配置选项
CON-FIG_default_MESSAGE_LOGLEVEL定义的，默认值为4。

minimum_console_loglevel
	此字段中的值是可以设置console_loglevel的最小值。

default_console_loglevel
	这是console_loglevel的默认值。

内核日志的打印级别：
       Kernel constant   Level value   Meaning
       KERN_EMERG             <span class="token number">0</span>        System is unusable
       KERN_ALERT             <span class="token number">1</span>        Action must be taken immediately
       KERN_CRIT              <span class="token number">2</span>        Critical conditions，关键/临界条件
       KERN_ERR               <span class="token number">3</span>        Error conditions
       KERN_WARNING           <span class="token number">4</span>        Warning conditions
       KERN_NOTICE            <span class="token number">5</span>        Normal but significant condition
       KERN_INFO              <span class="token number">6</span>        Informational
       KERN_DEBUG             <span class="token number">7</span>        Debug-level messages
</code></pre> 
<pre><code class="prism language-bash">返回值
	对于调用为2、3或4的类型，成功调用syslog（）将返回读取的字节数。对于类型9，syslog<span class="token punctuation">(</span><span class="token punctuation">)</span>
返回当前可在内核日志缓冲区上读取的字节数。对于类型10，syslog（）返回内核日志缓冲区的总大
小。对于其他类型的值，成功时返回0。
	如果出现错误，则返回-1，并设置errno以指示错误。

错误码
	EINVAL：错误的参数（例如，错误的类型；或对于类型2、3或4，buf为NULL，或len小于零；
或者对于类型8，级别在1到8<span class="token punctuation">)</span>.

	ENOSYS：此syslog（）系统调用不可用，因为编译内核时禁用了CONFIG_PRINTK内核配置选项。

	EPERM：没有足够权限的进程试图更改console_loglevel或清除内核消息环形缓冲区（更准确地
说：没有CAP_SYS_ADMIN或CAP_SYSLOG能力）。

	ERESTARTSYS：系统调用被信号中断；什么也没读。（这只能在跟踪过程中看到）
</code></pre> 
<h3><a id="4_332"></a>4、扩展阅读</h3> 
<p>  <a href="https://www.cnblogs.com/embedded-linux/p/5201158.html" rel="nofollow">linux日志：syslogd和klogd及syslog</a></p> 
<h2><a id="_procsyskernelprintk_xxx_334"></a>二、 /proc/sys/kernel/printk_xxx</h2> 
<p>  这些是 Linux 内核的一些控制文件，用于配置内核日志和打印设置。下面是对这些文件的详细解释：</p> 
<ol><li> <p><code>/proc/sys/kernel/printk</code></p> 
  <ul><li>该文件用于控制内核日志的打印级别。它包含四个整数值（以空格分隔），分别表示控制台日志级别、默认控制台日志级别、启动日志级别和当前日志级别。</li></ul> </li><li> <p><code>/proc/sys/kernel/printk_devkmsg</code></p> 
  <ul><li>如果该文件的值为非零，则内核日志将通过<code>/dev/kmsg</code>设备输出。如果为零，则内核日志将不会输出到该设备。默认情况下，它的值为非零。</li></ul> </li><li> <p><code>/proc/sys/kernel/printk_delay</code></p> 
  <ul><li>该文件用于设置内核日志的打印延迟时间（以毫秒为单位）。这个延迟时间用于合并相邻的日志消息，以减少日志输出的开销。</li></ul> </li><li> <p><code>/proc/sys/kernel/printk_ratelimit</code></p> 
  <ul><li>该文件用于设置内核日志输出的限速，即每秒打印的消息数量限制。默认情况下，它的值为 <code>5</code>。</li></ul> </li><li> <p><code>/proc/sys/kernel/printk_ratelimit_burst</code></p> 
  <ul><li>该文件用于设置内核日志限速突发打印的数量。当达到限速后，内核可以突发打印多少条日志消息。默认情况下，它的值等于 <code>10 * printk_ratelimit</code>。</li></ul> </li></ol> 
<p>  这些文件的值可以通过读取和写入这些文件来进行配置。例如，要更改内核日志的打印级别，可以使用以下命令：</p> 
<pre><code class="prism language-shell"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;console_loglevel&gt; &lt;default_console_loglevel&gt; &lt;boot_loglevel&gt; &lt;current_loglevel&gt;"</span> <span class="token operator">&gt;</span> /proc/sys/kernel/printk
</code></pre> 
<p>  其中，每个<code>&lt;loglevel&gt;</code>代表一个整数，表示对应的日志级别。需要注意的是，对这些控制文件的更改只对当前会话有效，重新启动系统后会恢复为默认值。如果您希望在系统启动时保持更改的值，可以在启动脚本中设置这些文件的值。</p> 
<h2><a id="devkmsg_358"></a>三、/dev/kmsg</h2> 
<p>  <code>/dev/kmsg</code> 是 Linux 操作系统中的一个特殊设备文件，用于读取内核日志。它在内核中用于与用户空间的程序进行通信，并提供了对内核消息缓冲区的访问。</p> 
<p>  通过读取 <code>/dev/kmsg</code>，您可以获取内核在运行时生成的各种日志消息，包括内核启动消息、驱动程序消息、错误消息等。这对于诊断系统问题、调试内核模块或了解系统运行状况非常有用。</p> 
<p>  为了访问 <code>/dev/kmsg</code>，您可以使用标准的读取文件的方法，例如使用 <code>open</code> 函数打开设备文件，然后使用 <code>read</code> 函数读取其中的数据。示例代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUF_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/kmsg"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to open /dev/kmsg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">ssize_t</span> bytesRead<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesRead <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> BUF_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        buffer<span class="token punctuation">[</span>bytesRead<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  上述代码将打开 <code>/dev/kmsg</code>，然后使用一个循环不断读取内核日志信息，将其打印到标准输出上直至读取完毕。请注意，读取 <code>/dev/kmsg</code> 通常需要 root 权限或者使用 <code>sudo</code> 运行程序。</p> 
<p>  需要注意的是，读取 <code>/dev/kmsg</code> 的方式是阻塞的，也就是说，如果没有新的消息，读取操作将会一直阻塞，直到有新的消息到达。因此，该方式通常用于长期运行或守护进程，以便可以实时监控内核日志。</p> 
<p>  <mark><strong>summary</strong></mark>：<code>/proc/kmsg 是一个虚拟文件，/dev/kmsg 是一个设备文件，也用于读取内核日志消息。/proc 下的虚拟文件主要用于提供内核状态和动态信息，而 /dev 下的设备文件主要用于与硬件设备进行交互。</code></p> 
<p>  <mark>欢迎大家指导和交流！如果我有任何错误或遗漏，请立即指正，我愿意学习改进。期待与大家一起进步！</mark></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0927371059541a34f46062358e93b0a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI的未来 - AI Agent系列】【MetaGPT】2. 实现自己的第一个Agent</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d95c74369883b5bc9316f605653b987/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java SPI机制总结系列之开发入门实例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>