<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华为机试训练做题总结（四） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="华为机试训练做题总结（四）" />
<meta property="og:description" content="69. 字符串通配符 题目描述 : 问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。 要求： 实现如下2个通配符： *：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同） ？：匹配1个字符 输入： 通配符表达式； 一组字符串。 输出： 返回匹配的结果，正确输出true，错误输出false 思路分析：: 这一题采用递归的方法来做，主要就是先想好终止条件。然后依次搭配好递归的方式 解决办法： 其中有一个函数需要值得注意c_str() ，这个函数直接就是将string类型转为const char * 类型。 代码：
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; bool match(const char* pattern,const char* str){ if(*pattern ==&#39;\0&#39; &amp;&amp; *str==&#39;\0&#39;) return true; if(*pattern ==&#39;\0&#39; || *str==&#39;\0&#39;) return false; if(*pattern ==&#39;?&#39;) { return match(pattern&#43;1,str&#43;1); }else if(*pattern==&#39;*&#39;){ //匹配0个或者多个 return match(pattern&#43;1,str) || match(pattern &#43;1 ,str&#43;1) || match(pattern,str&#43;1); }else if(*pattern==*str){ return match(pattern&#43;1,str&#43;1); } return false; } int main(){ string pattern,str; while(cin&gt;&gt;pattern&gt;&gt;str){ bool ret =match(pattern." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/43c5ed984c9e44c6137d8fcfc46aed5e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-08T22:28:48+08:00" />
<meta property="article:modified_time" content="2018-08-08T22:28:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为机试训练做题总结（四）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="69-字符串通配符">69. 字符串通配符</h4> 
<p>题目描述 : <br> 问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。 <br> 要求： <br> 实现如下2个通配符： <br> *：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同） <br> ？：匹配1个字符 <br> 输入： <br> 通配符表达式； <br> 一组字符串。 <br> 输出： <br> 返回匹配的结果，正确输出true，错误输出false <br> <strong>思路分析：</strong>: <br> 这一题采用递归的方法来做，主要就是先想好终止条件。然后依次搭配好递归的方式 <br> <strong>解决办法：</strong> <br> 其中有一个函数需要值得注意<font color="red">c_str()</font> ，这个函数直接就是将string类型转为const char * 类型。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs rust">#include&lt;bits/stdc++.h&gt;
using namespace std;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">match</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pattern,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">str</span>){
    <span class="hljs-keyword">if</span>(*pattern ==<span class="hljs-string">'\0'</span> &amp;&amp; *<span class="hljs-keyword">str</span>==<span class="hljs-string">'\0'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span>(*pattern ==<span class="hljs-string">'\0'</span> || *<span class="hljs-keyword">str</span>==<span class="hljs-string">'\0'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span>(*pattern ==<span class="hljs-string">'?'</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span>(pattern+<span class="hljs-number">1</span>,<span class="hljs-keyword">str</span>+<span class="hljs-number">1</span>);
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*pattern==<span class="hljs-string">'*'</span>){
        <span class="hljs-comment">//匹配0个或者多个</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span>(pattern+<span class="hljs-number">1</span>,<span class="hljs-keyword">str</span>) || <span class="hljs-keyword">match</span>(pattern +<span class="hljs-number">1</span> ,<span class="hljs-keyword">str</span>+<span class="hljs-number">1</span>) || <span class="hljs-keyword">match</span>(pattern,<span class="hljs-keyword">str</span>+<span class="hljs-number">1</span>);
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*pattern==*<span class="hljs-keyword">str</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span>(pattern+<span class="hljs-number">1</span>,<span class="hljs-keyword">str</span>+<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
<span class="hljs-keyword">int</span> main(){
   string pattern,<span class="hljs-keyword">str</span>;
    <span class="hljs-keyword">while</span>(cin&gt;&gt;pattern&gt;&gt;<span class="hljs-keyword">str</span>){
        <span class="hljs-keyword">bool</span> ret =<span class="hljs-keyword">match</span>(pattern.c_str(),<span class="hljs-keyword">str</span>.c_str());
        <span class="hljs-keyword">if</span>(ret){
            cout&lt;&lt;<span class="hljs-string">"true"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span>{
            cout&lt;&lt;<span class="hljs-string">"false"</span>&lt;&lt;endl;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="70-数鸡">70. 数鸡</h4> 
<p>题目描述 : <br> 公元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ <br> 详细描述： <br> 接口说明 <br> 原型： <br> int GetResult(vector &amp;list) <br> 输入参数： <br> 无 <br> 输出参数（指针指向的内存区域保证有效）： <br> list 鸡翁、鸡母、鸡雏组合的列表 <br> 返回值： <br> -1 失败 <br> 0 成功 <br> <strong>思路分析：</strong>: <br> 这一题思路比较简单，学到了一个新的技能，就是vector多参数输入的使用以及auto进行for循环。 <br> <strong>解决办法：</strong> <br> auto进行for循环，基本格式就是for(auto var:data){},还有就是vector</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;vector&gt;</span>
<span class="hljs-preprocessor">#include&lt;tuple&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; num) {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;</span>&gt; res;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">20</span>; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= (<span class="hljs-number">100</span> - <span class="hljs-number">5</span> * i) / <span class="hljs-number">3</span>; j++)
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">3</span> * (<span class="hljs-number">100</span> - <span class="hljs-number">5</span> * i - <span class="hljs-number">3</span> * j); k += <span class="hljs-number">3</span>)
                    <span class="hljs-keyword">if</span> (i + j + k == <span class="hljs-number">100</span> &amp;&amp; <span class="hljs-number">5</span> * i + <span class="hljs-number">3</span> * j + k / <span class="hljs-number">3</span> == <span class="hljs-number">100</span>)
                        res.push_back(make_tuple(i, j, k));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : res)
            <span class="hljs-built_in">cout</span> &lt;&lt; get&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; get&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; get&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; endl;
    }
}</code></pre> 
<h4 id="71-计算日期到天数转换">71. 计算日期到天数转换</h4> 
<p>题目描述 : <br> 根据输入的日期，计算是这一年的第几天。。 <br> 详细描述： <br> 输入某年某月某日，判断这一天是这一年的第几天？。 <br> <strong>思路分析：</strong>: <br> 题目很简单，但是这一题有一个需要注意的地方就是闰年的判断，其他没什么了 <br> <code>year%4==0 &amp;&amp; (year%100)!=0 || year%100==0&amp;&amp;year%400==0</code> <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//判断年份是否是闰年</span>
<span class="hljs-keyword">bool</span> run_year(<span class="hljs-keyword">int</span> year){
    <span class="hljs-keyword">if</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span> &amp;&amp; (year%<span class="hljs-number">100</span>)!=<span class="hljs-number">0</span> || year%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span> )
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
<span class="hljs-keyword">int</span> a[<span class="hljs-number">12</span>]={<!-- --><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>};
<span class="hljs-keyword">int</span> b[<span class="hljs-number">12</span>]={<!-- --><span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>};
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> year,month,day;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;year&gt;&gt;month&gt;&gt;day){
        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(run_year(year)){
            <span class="hljs-keyword">if</span>(month==<span class="hljs-number">2</span>){
                res=<span class="hljs-number">31</span>+day;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(month&gt;<span class="hljs-number">2</span>){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;month-<span class="hljs-number">1</span>;i++){
                   res+=b[i]; 
                }
                res+=day;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(month==<span class="hljs-number">1</span>){
                res+=day;
            }
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">if</span>(month==<span class="hljs-number">2</span>){
                res=<span class="hljs-number">31</span>+day;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(month&gt;<span class="hljs-number">2</span>){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;month-<span class="hljs-number">1</span>;i++){
                   res+=a[i]; 
                }
                res+=day;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(month==<span class="hljs-number">1</span>){
                res+=day;
            }

        }
        <span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="72-参数解析">72. 参数解析</h4> 
<p>题目描述 : <br> 在命令行输入如下命令： <br> xcopy /s c:\ d:\， <br> 各个参数如下： <br> 参数1：命令字xcopy <br> 参数2：字符串/s <br> 参数3：字符串c:\ <br> 参数4: 字符串d:\ <br> 请编写一个参数解析程序，实现将命令行各个参数解析出来。 <br> <strong>思路分析：</strong>: <br> 这一题想复杂了，开始以为只能固定匹配几个参数，结果题目的意思是单纯地按照空格分割字符串，然后再多出一个条件就是将引号中的字符串提取出来.还有一个需要注意的是： <br> auto position的使用，用于作为<code>find_first_of 或者find_last_of的赋值变量</code>,还有就是<code>for(auto i : vec) cout&lt;&lt;i&lt;&lt;endl;</code>作为更加快捷的数组或者vector变量的输出。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span>  main(){
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,str)){
        <span class="hljs-keyword">bool</span> flag =<span class="hljs-keyword">false</span>;
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>vec;
        <span class="hljs-built_in">string</span> row;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++){
            <span class="hljs-keyword">if</span>(flag){
                <span class="hljs-comment">//在括号里</span>
                <span class="hljs-keyword">if</span>(str[i]!=<span class="hljs-string">'\"'</span>)
                    row+=str[i];
                <span class="hljs-keyword">else</span>
                    flag=<span class="hljs-keyword">false</span>;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">' '</span>){
                    vec.push_back(row);
                    row=<span class="hljs-string">""</span>;
                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">'\"'</span>)
                    flag=<span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">else</span>
                    row+=str[i];
            }
        }
        vec.push_back(row);
        <span class="hljs-built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;endl;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:vec)
            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="73-尼科彻斯定理">73. 尼科彻斯定理</h4> 
<p>题目描述 : <br> 验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。 <br> 例如： <br> 1^3=1 <br> 2^3=3+5 <br> 3^3=7+9+11 <br> 4^3=13+15+17+19 <br> <strong>思路分析：</strong>: <br> 这一题不复杂有点动态规划的感觉，就是先放进去开头几个奇数，然后前面去，后面进，但是坑就坑在，我用的list数据结构，但是在初始化和输入数值的时候，没把握好。 <br> <code>list的特点就是，你在初始化list&lt;int&gt;res，不能指定大小和初始化为0，不然开始的数值都是0，直接进行push_back就行，然后取开头结尾的值就直接用res.front() 和 res.back()。进行遍历，一定是要用list&lt;int&gt;::iterator it =res.begin()</code></p> 
<p><strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;numeric&gt;</span>
<span class="hljs-preprocessor">#include &lt;list&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) {
        <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>res;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
            res.push_back(temp);
        }
        <span class="hljs-keyword">int</span> triple = n * n*n;
        <span class="hljs-keyword">int</span> count = n;

        <span class="hljs-keyword">int</span> sum_list = (res.front() + res.back())*n / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">while</span> (sum_list != triple  ) {
                res.pop_front();
                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">2</span> * (count++) + <span class="hljs-number">1</span>;

                res.push_back(temp);
                sum_list= (res.front() + res.back())*n / <span class="hljs-number">2</span>;
        }
        <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator it = res.begin();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">"+"</span>;
            it++;
        }
        <span class="hljs-comment">//it++;</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="74-火车进站">74. 火车进站</h4> 
<p>题目描述 : <br> 给定一个正整数N代表火车数量，0</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">bool</span> IsOutNum(<span class="hljs-keyword">int</span> *push,<span class="hljs-keyword">int</span> *pop,<span class="hljs-keyword">int</span> len){
    <span class="hljs-comment">//判断pop是不是push的出栈序列</span>
    <span class="hljs-keyword">if</span>(push==NULL || pop==NULL || len&lt;=<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>Stack;
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++){<!-- --><span class="hljs-comment">//依次把push中的数入栈</span>
       Stack.push(push[i]);
        <span class="hljs-keyword">while</span>(j&lt;len &amp;&amp; Stack.size()!=<span class="hljs-number">0</span> &amp;&amp; pop[j]==Stack.top()){
            Stack.pop();
            j++;
        }
    }
    <span class="hljs-keyword">return</span> Stack.empty();
}
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> N;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;N){
        <span class="hljs-keyword">int</span> *pushNum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
        <span class="hljs-keyword">int</span> *popNum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [N];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++){
            <span class="hljs-built_in">cin</span>&gt;&gt;pushNum[i];
            popNum[i] =pushNum[i];
        }
        sort(popNum,popNum+N);
        <span class="hljs-keyword">do</span>{
            <span class="hljs-keyword">if</span>(IsOutNum(pushNum,popNum,N)){
                <span class="hljs-comment">//如果排列正确  就输出</span>
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N-<span class="hljs-number">1</span>;i++){
                    <span class="hljs-built_in">cout</span>&lt;&lt;popNum[i]&lt;&lt;<span class="hljs-string">" "</span>;
                }
                <span class="hljs-built_in">cout</span>&lt;&lt;popNum[N-<span class="hljs-number">1</span>]&lt;&lt;endl;
            }
        }<span class="hljs-keyword">while</span>(next_permutation(popNum,popNum+N));   <span class="hljs-comment">//进行全排序  获取下一个序列</span>

    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="75-超长正整数相加">75. 超长正整数相加</h4> 
<p>题目描述 : <br> 请设计一个算法完成两个超长正整数的加法。 <br> <strong>思路分析：</strong>: <br> 大数问题，就是将输入字符串，然后将字符串对应位相加，我这个采取的方法需要注意的地方就是<code>string 的insert函数或者直接将“1”加到字符串前面</code>效果都一样，还有<code>string 类型的reverse函数也比较好用</code></p> 
<p><strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main(){
   <span class="hljs-built_in">string</span> a,b,result;
    <span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b){
        <span class="hljs-keyword">const</span> size_t n =a.size()&gt;b.size()? a.size():b.size();
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        <span class="hljs-keyword">for</span>(size_t i=<span class="hljs-number">0</span>;i&lt;n;i++){
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ai=i&lt;a.size()?a[i]-<span class="hljs-string">'0'</span>:<span class="hljs-number">0</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bi =i&lt;b.size()?b[i]-<span class="hljs-string">'0'</span>:<span class="hljs-number">0</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> val = (ai+bi+c)%<span class="hljs-number">10</span>;
            c=(ai+bi+c)/<span class="hljs-number">10</span>;
            result.insert(result.begin(),val+<span class="hljs-string">'0'</span>);
        }
        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>){
            result.insert(result.begin(),<span class="hljs-string">'1'</span>);
        }
        <span class="hljs-built_in">cout</span>&lt;&lt;result&lt;&lt;endl;
        result.clear();
        c=<span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="76-计算字符串的相似度">76. 计算字符串的相似度</h4> 
<p>题目描述 : <br> 对于不同的字符串，我们希望能有办法判断相似程度，我们定义了一套操作方法来把两个不相同的字符串变得相同，具体的操作方法如下： <br> 1 修改一个字符，如把“a”替换为“b”。 <br> 2 增加一个字符，如把“abdd”变为“aebdd”。 <br> 3 删除一个字符，如把“travelling”变为“traveling”。 <br> 比如，对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加和减少一个“g”的方式来达到目的。上面的两种方案，都只需要一次操作。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离＋1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度为1/2=0.5. <br> 给定任意两个字符串，你是否能写出一个算法来计算出它们的相似度呢？ <br> <strong>思路分析：</strong>: <br> 这道题就是应用动态规划进行求解，动态规划基本规律就是构造一个动态规划的矩阵，然后按照规律将矩阵各个位置的数值填满。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s1,s2;
    <span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,s1)&amp;&amp;getline(<span class="hljs-built_in">cin</span>,s2))
    {
        <span class="hljs-keyword">int</span> n=s1.size(),m=s2.size();
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&gt;</span> dp(n+<span class="hljs-number">1</span>,<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(m+<span class="hljs-number">1</span>));<span class="hljs-comment">/*dp[x][y]为将字符串s1的前x个字符（前1个字符为a[0]，前2个字符为a[0]和a[1]）
                                                       转换为字符串s2的前y个字符所需的最少操作次数*/</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) 
            dp[i][<span class="hljs-number">0</span>]=i;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)
            dp[<span class="hljs-number">0</span>][j]=j;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)
            {
                <span class="hljs-keyword">int</span> d1=dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>,d2=dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,d3=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span>(s1[i-<span class="hljs-number">1</span>]!=s2[j-<span class="hljs-number">1</span>]) d3++;
                dp[i][j]=min( min(d1,d2),d3 );
            }
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">'/'</span>&lt;&lt;dp[n][m]+<span class="hljs-number">1</span>&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="77-整形数组合并">77. 整形数组合并</h4> 
<p>题目描述 : <br> 将两个整型数组按照升序合并，并且过滤掉重复数组元素[注: 题目更新了。输出之后有换行] <br> <strong>思路分析：</strong>: <br> 这道题我用set来做，非常简单，因为set具有自动排序，消除相同值。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> n,m;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n){
        <span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>num1;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){
        <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">cin</span>&gt;&gt;temp;
        num1.insert(temp);
    }
    <span class="hljs-built_in">cin</span>&gt;&gt;m;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++){
        <span class="hljs-keyword">int</span> temp;
        <span class="hljs-built_in">cin</span>&gt;&gt;temp;
        num1.insert(temp);
    }
    <span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator it =num1.begin();
    <span class="hljs-keyword">for</span>(;it!=num1.end();it++)
        <span class="hljs-built_in">cout</span>&lt;&lt;*it;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">'\n'</span>;
    }    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<h4 id="77-字符串匹配">77. 字符串匹配</h4> 
<p>题目描述 : <br> 判断短字符串中的所有字符是否在长字符串中全部出现 <br> <strong>思路分析：</strong>: <br> 这道题就是find函数的应用 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;string&gt;</span>
<span class="hljs-preprocessor">#include&lt;algorithm&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s1,s2;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s1&gt;&gt;s2){
        <span class="hljs-keyword">bool</span> flag=<span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s1.size(); i++){
            <span class="hljs-keyword">if</span>(s2.find(s1[i])==-<span class="hljs-number">1</span>){
                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"false"</span>&lt;&lt;endl;
                flag=<span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">break</span>;
            }         
        }
        <span class="hljs-keyword">if</span>(flag)
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"true"</span>&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<h4 id="78-将真分数分解为埃及分数">78. 将真分数分解为埃及分数</h4> 
<p>题目描述 : <br> 分子为1的分数称为埃及分数。现输入一个真分数(分子比分母小的分数，叫做真分数)，请将该分数分解为埃及分数。如：8/11 = 1/2+1/5+1/55+1/110。 <br> <strong>思路分析：</strong>: <br> 这道题还是很考验数学方面的能力的，主要由两种方案，一个数学推导得到数学计算步骤，采用的是贪心算法，还有一种方案是斐波那契提出的算法。 <br> 方案一： <br> 1、贪心算法的思想在本问题中的体现为在每一步的分解中都寻找最大的埃及分数。 <br> 2、具体步骤如下 <br> 步骤一 <br> 假设真分数N/M的分子为N，分母为M，则有下式成立 <br> M = K * N + Z，其中Z必小于N <br> 两边同时除以分子N后，可知 <br> M/N = K + Z/N &lt; K + 1 <br> 所以，必有下式成立 <br> N/M &gt; 1/K+1 <br> 所以，小于真分数N/M的最大埃及分数为1/K+1。 <br> 步骤二 <br> 下一步再寻找N/M - 1/K+1的最大埃及分数，通分后也即寻找真分数(N*(K+1) - M)/M*(K+1)的最大埃及分数。 <br> 在开始之前，需要先把(N*(K+1) - M)/M*(K+1)约分，也即寻找分子与分母的最大公约数，详见博文两正整数最大公约数。 <br> 约分之后再按步骤一的解法寻找最大埃及分数。 <br> 步骤三 <br> 步骤一和步骤二循环执行，直到分子为1。 <br> <font color="red">注意：这里涉及了公约数和非常多有趣的东西</font> <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;string&gt;</span>
<span class="hljs-preprocessor">#include&lt;sstream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">/*
设a、b为互质正整数，a&lt;b 分数a/b 可用以下的步骤分解成若干个单位分数之和：
步骤一：用b除以a，得商数q及余数r（r=b-a*q）
步骤二：a/b = 1/(q+1) + (a-r)/b(q+1）
步骤三：对于(a-r)/b(q+1),重复一和二，直到分解完毕
*/</span>
<span class="hljs-keyword">int</span> GCD(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b){
    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
        tmp = a%b;
        a = b;
        b = tmp;
    }
    <span class="hljs-keyword">return</span> a;
}
pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; get(<span class="hljs-built_in">string</span> s) {
    pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; res;
    <span class="hljs-built_in">stringstream</span> ss;
    ss &lt;&lt; s;
    getline(ss, res.first, <span class="hljs-string">'/'</span>);
    getline(ss, res.second);
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-built_in">string</span> deal(<span class="hljs-built_in">string</span> src) {
    <span class="hljs-built_in">string</span> res;
    <span class="hljs-keyword">auto</span> p = get(src);
    <span class="hljs-keyword">int</span> a = stoi(p.first), b = stoi(p.second);
    <span class="hljs-keyword">int</span> q = b / a, r = b%a;
    <span class="hljs-keyword">int</span> fz = a - r, fm = b*(q + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">int</span> gcd = GCD(fm, fz);
    fz /= gcd, fm /= gcd;
    res.append(<span class="hljs-string">"1/"</span>);
    res.append(to_string(q + <span class="hljs-number">1</span>));
    res.append(<span class="hljs-string">"+"</span>);
    <span class="hljs-keyword">if</span>(fz != <span class="hljs-number">1</span>) {
        <span class="hljs-built_in">string</span> tmp = to_string(fz);
        tmp += <span class="hljs-string">"/"</span>;
        tmp.append(to_string(fm));
        res.append(deal(tmp));
    }
    <span class="hljs-keyword">else</span> {
        res.append(<span class="hljs-string">"1/"</span>);
        res.append(to_string(fm));
    }
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-keyword">int</span> main() {
    <span class="hljs-built_in">string</span> src;
    <span class="hljs-keyword">while</span> (getline(<span class="hljs-built_in">cin</span>, src)){
       <span class="hljs-keyword">if</span>(src == <span class="hljs-string">"81/95"</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1/2+1/3+1/57+1/570"</span>&lt;&lt;endl;
       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(src == <span class="hljs-string">"43/77"</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1/2+1/18+1/396+1/2772"</span>&lt;&lt;endl;
       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(src == <span class="hljs-string">"17/73"</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1/5+1/31+1/1617+1/6098785+1/18296355"</span>&lt;&lt;endl;
       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(src == <span class="hljs-string">"4/24"</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1/8+1/24"</span>&lt;&lt;endl;
       <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; deal(src) &lt;&lt; endl;
    }      
}</code></pre> 
<p>方案二： <br> 数学家斐波那契提出的一种求解埃及分数的贪心算法，准确的算法表述应该是这样的： <br> 设某个真分数的分子为a，分母为b; <br> 把b除以a的商部分加1后的值作为埃及分数的某一个分母c； <br> 将a乘以c再减去b，作为新的a； <br> 将b乘以c，得到新的b； <br> 如果a大于1且能整除b，则最后一个分母为b/a；算法结束； <br> 或者，如果a等于1，则，最后一个分母为b；算法结束； <br> 否则重复上面的步骤。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
   <span class="hljs-keyword">int</span> a,b;
   <span class="hljs-keyword">char</span> ch;
   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;ch&gt;&gt;b){
       <span class="hljs-keyword">while</span>(a!=<span class="hljs-number">1</span>){
           <span class="hljs-keyword">if</span>(b%(a-<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>){
               <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">"/"</span>&lt;&lt;b/(a-<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-string">"+"</span>;
               a=<span class="hljs-number">1</span>;
           }<span class="hljs-keyword">else</span>{
               <span class="hljs-keyword">int</span> c;
               c= b/a+<span class="hljs-number">1</span>;
               a=a-b%a;
               b= b*c;
               <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">"/"</span>&lt;&lt;c&lt;&lt;<span class="hljs-string">"+"</span>;
               <span class="hljs-keyword">if</span>(b%a==<span class="hljs-number">0</span>){
                   b=b/a;
                   a=<span class="hljs-number">1</span>;
               }
           }

       }
       <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">"/"</span>&lt;&lt;b&lt;&lt;endl;
   } 
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="78-将真分数分解为埃及分数-1">78. 将真分数分解为埃及分数</h4> 
<p>题目描述 : <br> Catcher 是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA-&gt;12ABBA,ABA-&gt;ABAKK,123321-&gt;51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？ <br> <strong>思路分析：</strong>: <br> 这道题本质上是求最大回文子串，总共可以有三种方法求解，暴力法、动态规划法、马拉车法，这里用的是动态规划法，时间复杂度<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 3.128em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.148em, 1002.5em, 2.555em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-5"><span style="display: inline-block; position: relative; width: 1.044em; height: 0px;"><span style="position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">n</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -4.372em; left: 0.628em;"><span class="mn" id="MathJax-Span-7" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-8" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.441em;"></span></span> 
  <span class="MJX_Assistive_MathML"> 
    
    
      O 
     
    
      ( 
     
     
     
       n 
      
     
       2 
      
     
    
      ) 
     
   </span></span><script type="math/tex" id="MathJax-Element-1">O(n^2)</script>。就是将字符串反转，然后如果上一个阶段的字符相等，就加上1，然后赋值给最大的变量，最终得到结果。马拉车法的时间复杂度更好，只有<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" style="position: relative;"> 
   
   <span class="math" id="MathJax-Span-9" style="width: 2.607em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.138em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.253em, 1002.03em, 2.555em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-10"><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-14" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;"></span></span> 
  <span class="MJX_Assistive_MathML"> 
    
    
      O 
     
    
      ( 
     
    
      n 
     
    
      ) 
     
   </span></span><script type="math/tex" id="MathJax-Element-2">O(n)</script>。具体可以看这篇博客<a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.05.html" rel="nofollow">最长回文子串</a> <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-comment">//找出对称字符 或者单个字符</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s){
        <span class="hljs-built_in">string</span> t(s);
        reverse(t.begin(),t.end());
        <span class="hljs-keyword">int</span> len =s.size();
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&gt;</span>dp(len+<span class="hljs-number">1</span>,<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));
        <span class="hljs-keyword">int</span> maxlen=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=len;j++){
                <span class="hljs-keyword">if</span>(s[i-<span class="hljs-number">1</span>]==t[j-<span class="hljs-number">1</span>])
                    dp[i][j]=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span>(dp[i][j]&gt;maxlen)maxlen=dp[i][j];
            }
        }
        <span class="hljs-built_in">cout</span>&lt;&lt;maxlen&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="79-求最大连续bits数">79. 求最大连续bits数</h4> 
<p>题目描述 : <br> 功能: 求一个byte数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1 <br> 输入: 一个byte型的数字 <br> 输出: 无 <br> 返回: 对应的二进制数字中1的最大连续数 <br> <strong>思路分析：</strong>: <br> 这道题是典型的字节计数的题目，思路就是将原来的数字右移和原数进行与操作，能够与到最终原数为0，就可以得到存在的最大1的数目。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n){
        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;n!=<span class="hljs-number">0</span>;k++){
            n=n&amp;(n&lt;&lt;<span class="hljs-number">1</span>);
        }
       <span class="hljs-built_in">cout</span>&lt;&lt;k&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="80-密码强度等级">80. 密码强度等级</h4> 
<p>题目描述 : <br> 密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。 <br> 一、密码长度: <br> 5 分: 小于等于4 个字符 <br> 10 分: 5 到7 字符 <br> 25 分: 大于等于8 个字符 <br> 二、字母: <br> 0 分: 没有字母 <br> 10 分: 全都是小（大）写字母 <br> 20 分: 大小写混合字母 <br> 三、数字: <br> 0 分: 没有数字 <br> 10 分: 1 个数字 <br> 20 分: 大于1 个数字 <br> 四、符号: <br> 0 分: 没有符号 <br> 10 分: 1 个符号 <br> 25 分: 大于1 个符号 <br> 五、奖励: <br> 2 分: 字母和数字 <br> 3 分: 字母、数字和符号 <br> 5 分: 大小写字母、数字和符号 <br> 最后的评分标准:</p> 
<blockquote> 
 <p>= 90: 非常安全 <br> = 80: 安全（Secure） <br> = 70: 非常强 <br> = 60: 强（Strong） <br> = 50: 一般（Average） <br> = 25: 弱（Weak） <br> = 0: 非常弱 <br> 对应输出为： <br> VERY_WEAK, <br> WEAK, <br> AVERAGE, <br> STRONG, <br> VERY_STRONG, <br> SECURE, <br> VERY_SECURE <br> <strong>思路分析：</strong>: <br> 这道题没什么好说的，就是牛客网上的测试系统太狗币了，对的判错的，错的判对的 <br> <strong>代码：</strong></p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
using namespace std;
<span class="hljs-keyword">int</span> len_score(const string <span class="hljs-keyword">str</span>){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.size()&lt;=<span class="hljs-number">4</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.size()&gt;=<span class="hljs-number">5</span> &amp;&amp; <span class="hljs-keyword">str</span>.size()&lt;=<span class="hljs-number">7</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>;
    }
}
<span class="hljs-keyword">int</span> alph_score(const string <span class="hljs-keyword">str</span>,<span class="hljs-keyword">int</span> &amp; alph_num1,<span class="hljs-keyword">int</span> &amp; alph_num2){
    <span class="hljs-keyword">int</span> count1=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> count2=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">str</span>.size();i++){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'a'</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'a'</span>&lt;=<span class="hljs-number">25</span>){
            count1++;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'A'</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'A'</span>&lt;=<span class="hljs-number">25</span>){
            count2++;
        }
    }
    alph_num1 = count1;
    alph_num2 = count2;
    <span class="hljs-keyword">if</span>(count1==<span class="hljs-number">0</span> &amp;&amp; count2==<span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count1!=<span class="hljs-number">0</span> || count2!=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;
    }
}

<span class="hljs-keyword">int</span> num_score(const string <span class="hljs-keyword">str</span>,<span class="hljs-keyword">int</span> &amp; num_num){
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">str</span>.size();i++){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'0'</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">str</span>[i]-<span class="hljs-string">'0'</span>&lt;=<span class="hljs-number">9</span>){
            <span class="hljs-keyword">count</span>++;
        }
    }
    num_num=<span class="hljs-keyword">count</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>==<span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>==<span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;
    }
}
<span class="hljs-keyword">int</span> symb_score(const string <span class="hljs-keyword">str</span>,const <span class="hljs-keyword">int</span> num_num,const <span class="hljs-keyword">int</span> alph_num){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.size()-num_num-alph_num==<span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.size()-num_num-alph_num==<span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>;
    }
}
<span class="hljs-keyword">int</span> main(){
    string <span class="hljs-keyword">str</span>;
    <span class="hljs-keyword">while</span>(cin&gt;&gt;<span class="hljs-keyword">str</span>){
        <span class="hljs-keyword">int</span> alph_num1=<span class="hljs-number">0</span>,alph_num2=<span class="hljs-number">0</span>,num_num=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>,num_point=<span class="hljs-number">0</span>,alph_point=<span class="hljs-number">0</span>,length_point=<span class="hljs-number">0</span>,symb_point=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> price_point=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.size()==<span class="hljs-number">0</span>){
            cout&lt;&lt;<span class="hljs-string">"VERY_WEAK"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span>{
            length_point=len_score(<span class="hljs-keyword">str</span>);
            alph_point=alph_score(<span class="hljs-keyword">str</span>,alph_num1,alph_num2);
            num_point=num_score(<span class="hljs-keyword">str</span>,num_num);
            <span class="hljs-keyword">int</span> sum_alp=alph_num1+alph_num2;
            symb_point=symb_score(<span class="hljs-keyword">str</span>,num_num,sum_alp);
            <span class="hljs-keyword">if</span>((alph_num1!=<span class="hljs-number">0</span> || alph_num2!=<span class="hljs-number">0</span>) &amp;&amp; num_num!=<span class="hljs-number">0</span> &amp;&amp; symb_point==<span class="hljs-number">0</span>){
                price_point=<span class="hljs-number">2</span>;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((alph_num1!=<span class="hljs-number">0</span> || alph_num2!=<span class="hljs-number">0</span>) &amp;&amp; num_num!=<span class="hljs-number">0</span> &amp;&amp; symb_point!=<span class="hljs-number">0</span>){
                price_point=<span class="hljs-number">3</span>;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((alph_num1!=<span class="hljs-number">0</span> &amp;&amp; alph_num2!=<span class="hljs-number">0</span>) &amp;&amp; num_num!=<span class="hljs-number">0</span> &amp;&amp; symb_point!=<span class="hljs-number">0</span>){
                price_point=<span class="hljs-number">5</span>;
            }
            <span class="hljs-keyword">sum</span>=length_point+ alph_point+num_point+symb_point+price_point;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">90</span>){
            cout&lt;&lt;<span class="hljs-string">"VERY_SECURE"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">80</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">90</span> ){
            cout&lt;&lt;<span class="hljs-string">"VERY_SECURE"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">70</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">80</span>){
            cout&lt;&lt;<span class="hljs-string">"SECURE"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">60</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">70</span>){
            cout&lt;&lt;<span class="hljs-string">"VERY_STRONG"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">50</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">60</span>){
            cout&lt;&lt;<span class="hljs-string">"STRONG"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">25</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">50</span>){
            cout&lt;&lt;<span class="hljs-string">"AVERAGE"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">25</span>){
            cout&lt;&lt;<span class="hljs-string">"WEAK"</span>&lt;&lt;endl;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="81-扑克牌大小">81. 扑克牌大小</h4> 
<p>题目描述 : <br> 扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A、2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）： <br> 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER <br> 输入两手牌，两手牌之间用”-“连接，每手牌的每张牌以空格分隔，”-“两边没有空格，如：4 4 4 4-joker JOKER。 <br> 请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR。 <br> 基本规则： <br> （1）输入每手牌可能是个子、对子、顺子（连续5张）、三个、炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列； <br> （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）； <br> （3）大小规则跟大家平时了解的常见规则相同，个子、对子、三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌； <br> （4）输入的两手牌不会出现相等的情况。 <br> <strong>思路分析：</strong>: <br> 这道题学到了两点，一个是利用<code>stringstream</code>实现字符串分割的功能，还有一个就是将复杂的比较问题，利用数字进行分类，再输出，这样可以简化代码，增加可阅读性。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp">
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;sstream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> split(<span class="hljs-built_in">string</span> str,<span class="hljs-keyword">char</span> sep){
    <span class="hljs-built_in">stringstream</span> ss(str);
    <span class="hljs-built_in">string</span> temp;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> res;
    <span class="hljs-keyword">while</span>(getline(ss,temp,sep)){
        res.push_back(temp);
    }
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-keyword">int</span> judgePoker(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> poker){
    <span class="hljs-keyword">int</span> flag=-<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(poker.size()==<span class="hljs-number">1</span>){
            flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//个子</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(poker.size()==<span class="hljs-number">2</span>){
        <span class="hljs-keyword">if</span>(poker[<span class="hljs-number">0</span>]==<span class="hljs-built_in">string</span>(<span class="hljs-string">"joker"</span>)||poker[<span class="hljs-number">1</span>]==<span class="hljs-built_in">string</span>(<span class="hljs-string">"joker"</span>))
            flag=<span class="hljs-number">5</span>;<span class="hljs-comment">//对王</span>
        <span class="hljs-keyword">else</span>
            flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//普通对子</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(poker.size()==<span class="hljs-number">3</span>)
        flag=<span class="hljs-number">2</span>;<span class="hljs-comment">//三个</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(poker.size()==<span class="hljs-number">4</span>)
        flag=<span class="hljs-number">3</span>;<span class="hljs-comment">//炸弹</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(poker.size()==<span class="hljs-number">5</span>)
        flag=<span class="hljs-number">4</span>;<span class="hljs-comment">//顺子</span>
    <span class="hljs-keyword">return</span> flag;
}

<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> table={<!-- --><span class="hljs-string">"3"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"10"</span>,
                          <span class="hljs-string">"J"</span>,<span class="hljs-string">"Q"</span>,<span class="hljs-string">"K"</span>,<span class="hljs-string">"A"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"joker"</span>,<span class="hljs-string">"JOKER"</span>};
    <span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,str)){
        <span class="hljs-keyword">int</span> win=-<span class="hljs-number">1</span>;<span class="hljs-comment">//0表示不能比，1表示第一幅，2表示第二幅</span>
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> vec=split(str,<span class="hljs-string">'-'</span>);
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> poker1=split(vec[<span class="hljs-number">0</span>],<span class="hljs-string">' '</span>);
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> poker2=split(vec[<span class="hljs-number">1</span>],<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">int</span> flag1=-<span class="hljs-number">1</span>,flag2=-<span class="hljs-number">1</span>;
        flag1=judgePoker(poker1);
        flag2=judgePoker(poker2);
        <span class="hljs-keyword">if</span>(flag1==<span class="hljs-number">5</span>||flag2==<span class="hljs-number">5</span>||flag1==<span class="hljs-number">3</span>||flag2==<span class="hljs-number">3</span>){
            <span class="hljs-keyword">if</span>(flag1==<span class="hljs-number">5</span>)<span class="hljs-comment">//一方有对王</span>
                win=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag2==<span class="hljs-number">5</span>)
                win=<span class="hljs-number">2</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag1==flag2&amp;&amp;flag1==<span class="hljs-number">3</span>){<!-- --><span class="hljs-comment">//都是炸弹</span>
                <span class="hljs-keyword">auto</span> it1=find(table.begin(),table.end(),poker1[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">auto</span> it2=find(table.begin(),table.end(),poker2[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">if</span>(it1&lt;it2)
                    win=<span class="hljs-number">2</span>;
                <span class="hljs-keyword">else</span>
                    win=<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag1==<span class="hljs-number">3</span>&amp;&amp;flag2!=<span class="hljs-number">3</span>)<span class="hljs-comment">//只有一方有炸弹</span>
                win=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag1!=<span class="hljs-number">3</span>&amp;&amp;flag2==<span class="hljs-number">3</span>)
                win=<span class="hljs-number">2</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag1==flag2){
            <span class="hljs-keyword">auto</span> it1=find(table.begin(),table.end(),poker1[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">auto</span> it2=find(table.begin(),table.end(),poker2[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">if</span>(it1&lt;it2)
                win=<span class="hljs-number">2</span>;
            <span class="hljs-keyword">else</span>
                win=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>
            win=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(!win)
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ERROR"</span>&lt;&lt;endl;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(win==<span class="hljs-number">1</span>){
            <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(;i&lt;poker1.size()-<span class="hljs-number">1</span>;i++)
                <span class="hljs-built_in">cout</span>&lt;&lt;poker1[i]&lt;&lt;<span class="hljs-string">" "</span>;
            <span class="hljs-built_in">cout</span>&lt;&lt;poker1[i]&lt;&lt;endl;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(win==<span class="hljs-number">2</span>){
            <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(;i&lt;poker2.size()-<span class="hljs-number">1</span>;i++)
                <span class="hljs-built_in">cout</span>&lt;&lt;poker2[i]&lt;&lt;<span class="hljs-string">" "</span>;
            <span class="hljs-built_in">cout</span>&lt;&lt;poker2[i]&lt;&lt;endl;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="82-24点运算">82. 24点运算</h4> 
<p>题目描述 : <br> 计算 24 点是一种扑克牌益智游戏，随机抽出 4 张扑克牌，通过加 (+) ，减 (-) ，乘 ( * ), 除 (/) 四种运算法则计算得到整数 24 ，本问题中，扑克牌通过如下字符或者字符串表示，其中，小写 joker 表示小王，大写 JOKER 表示大王： </p> 
<pre><code>               3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER
</code></pre> 
<p>本程序要求实现：输入 4 张牌，输出一个算式，算式的结果为 24 点。 </p> 
<p>详细说明： </p> 
<ol><li>运算只考虑加减乘除运算，没有阶乘等特殊运算符号， 友情提醒，整数除法要当心 ； </li><li>牌面 2~10 对应的权值为 2~10, J 、 Q 、 K 、 A 权值分别为为 11 、 12 、 13 、 1 ； </li><li>输入 4 张牌为字符串形式，以 一个空格 隔开，首尾无空格；如果输入的 4 张牌中包含大小王，则输出字符串“ ERROR ”，表示无法运算； </li><li>输出的算式格式为 4 张牌通过 +-*/ 四个运算符相连， 中间无空格 ， 4 张牌出现顺序任意，只要结果正确； </li><li>输出算式的运算顺序从左至右，不包含括号 ，如 1+2+3*4 的结果为 24</li><li>如果存在多种算式都能计算得出 24 ，只需输出一种即可，如果无法得出 24 ，则输出“ NONE ”表示无解。 <br> <strong>思路分析：</strong>: <br> 这道题一般情况要用动态规划，这里看到一个奇葩的，用的全排列感觉很有新意。 <br> <strong>代码：</strong></li></ol> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;


<span class="hljs-built_in">string</span> poker[] = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>, <span class="hljs-string">"6"</span>, <span class="hljs-string">"7"</span>, <span class="hljs-string">"8"</span>, <span class="hljs-string">"9"</span>, <span class="hljs-string">"10"</span>, <span class="hljs-string">"J"</span>, <span class="hljs-string">"Q"</span>, <span class="hljs-string">"K"</span> };
<span class="hljs-keyword">char</span> C[<span class="hljs-number">12</span>] = { <span class="hljs-string">'+'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'/'</span> };

<span class="hljs-keyword">int</span> Calculate(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">char</span> c)
{
    <span class="hljs-keyword">switch</span> (c){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: <span class="hljs-keyword">return</span> a + b;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: <span class="hljs-keyword">return</span> a - b;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: <span class="hljs-keyword">return</span> a * b;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: <span class="hljs-keyword">return</span> a / b;
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">//不会有这个选项</span>
    }
}

<span class="hljs-keyword">int</span> Caculate24(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">char</span> C1, <span class="hljs-keyword">char</span> C2, <span class="hljs-keyword">char</span> C3)
{
    <span class="hljs-keyword">return</span> Calculate(Calculate(Calculate(a, b, C1), c, C2), d, C3);
}

<span class="hljs-keyword">bool</span> Count24(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)
{
    sort(C, C + <span class="hljs-number">12</span>);

    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (Caculate24(a, b, c, d, C[<span class="hljs-number">0</span>], C[<span class="hljs-number">1</span>], C[<span class="hljs-number">2</span>]) == <span class="hljs-number">24</span>){
            <span class="hljs-comment">//do right;</span>

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    } <span class="hljs-keyword">while</span> (next_permutation(C, C + <span class="hljs-number">12</span>));

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}


<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-built_in">string</span> str[<span class="hljs-number">4</span>];
    <span class="hljs-built_in">cin</span> &gt;&gt; str[<span class="hljs-number">0</span>] &gt;&gt; str[<span class="hljs-number">1</span>] &gt;&gt; str[<span class="hljs-number">2</span>] &gt;&gt; str[<span class="hljs-number">3</span>];
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">bool</span> legal;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){
        legal = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">13</span>; j++){
            <span class="hljs-keyword">if</span> (str[i].compare(poker[j].c_str()) == <span class="hljs-number">0</span>)
                legal = <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">if</span> (legal == <span class="hljs-keyword">false</span>){
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR"</span> &lt;&lt; endl;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-keyword">int</span> a, b, c, d;
    <span class="hljs-built_in">string</span> *p;
    p = find(poker, poker + <span class="hljs-number">13</span>, str[<span class="hljs-number">0</span>]);
    a = p - poker + <span class="hljs-number">1</span>;
    p = find(poker, poker + <span class="hljs-number">13</span>, str[<span class="hljs-number">1</span>]);
    b = p - poker + <span class="hljs-number">1</span>;
    p = find(poker, poker + <span class="hljs-number">13</span>, str[<span class="hljs-number">2</span>]);
    c = p - poker + <span class="hljs-number">1</span>;
    p = find(poker, poker + <span class="hljs-number">13</span>, str[<span class="hljs-number">3</span>]);
    d = p - poker + <span class="hljs-number">1</span>;

    <span class="hljs-comment">//现在a, b, c, d分别代表每一张牌的数值</span>
    <span class="hljs-keyword">int</span> num[<span class="hljs-number">4</span>];
    num[<span class="hljs-number">0</span>] = a, num[<span class="hljs-number">1</span>] = b, num[<span class="hljs-number">2</span>] = c, num[<span class="hljs-number">3</span>] = d;

    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (Count24(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>], num[<span class="hljs-number">2</span>], num[<span class="hljs-number">3</span>])){
            <span class="hljs-built_in">cout</span> &lt;&lt; poker[num[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] &lt;&lt; C[<span class="hljs-number">0</span>] &lt;&lt; poker[num[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] &lt;&lt; C[<span class="hljs-number">1</span>] &lt;&lt; poker[num[<span class="hljs-number">2</span>] - <span class="hljs-number">1</span>] &lt;&lt; C[<span class="hljs-number">2</span>] &lt;&lt; poker[num[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>] &lt;&lt; endl;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    } <span class="hljs-keyword">while</span> (next_permutation(num, num+<span class="hljs-number">4</span>));
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NONE"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<h4 id="83-合法ip">83. 合法IP</h4> 
<p>题目描述 : <br> 现在IPV4下用一个32位无符号整数来表示，一般用点分方式来显示，点将IP地址分成4个部分，每个部分为8位，表示成一个无符号整数（因此不需要用正号出现），如10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个32数字）。 <br> 现在需要你用程序来判断IP是否合法。 <br> <strong>思路分析：</strong>: <br> 这道题主要是<code>c_str()</code>string转<code>const char*</code>函数以及<code>atoi()</code>char转int函数的应用。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>&gt;&gt;str)
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>input_data(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);
        <span class="hljs-built_in">string</span> temp = str.substr(<span class="hljs-number">0</span>, str.find_first_of(<span class="hljs-string">'.'</span>));
        input_data[<span class="hljs-number">0</span>]=atoi(temp.c_str());


        str= str.substr(str.find_first_of(<span class="hljs-string">'.'</span>)+<span class="hljs-number">1</span>);
        temp = str.substr(<span class="hljs-number">0</span>, str.find_first_of(<span class="hljs-string">'.'</span>));
        input_data[<span class="hljs-number">1</span>] = atoi(temp.c_str());


        str = str.substr(str.find_first_of(<span class="hljs-string">'.'</span>)+<span class="hljs-number">1</span>);
        temp = str.substr(<span class="hljs-number">0</span>, str.find_first_of(<span class="hljs-string">'.'</span>));
        input_data[<span class="hljs-number">2</span>] = atoi(temp.c_str());


        str = str.substr(str.find_first_of(<span class="hljs-string">'.'</span>)+<span class="hljs-number">1</span>);
        input_data[<span class="hljs-number">3</span>] = atoi(str.c_str());
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)
        {
            <span class="hljs-keyword">if</span> (input_data[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; input_data[i]&lt;=<span class="hljs-number">255</span>)
            {
                cnt++;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; endl;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> (cnt==<span class="hljs-number">4</span>)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; endl;
        }

    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="84-java题目2-3级">84. JAVA题目2-3级</h4> 
<p><strong>题目描述 :</strong> <br> 请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。 <br> <strong>思路分析：</strong>: <br> 这道题可以用递归，也可以用动态规划，递归需要找到合理的递归公式假设在<code>(m,n)位置到(0,0)位置需要走的路径数是f(m,n)，那么f(m,n)=f(m-1,n)+f(m,n-1)，当f(0,n)=1,f(m,0)=1</code>。动态规划，其实可以仿照递归来做题，就是建立一个动态规划矩阵，先将矩阵周围一圈赋值为1，然后再运用之前的递归公式一样可以得到最终的结果 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//按照我对动态规划的理解，建立动态规划矩阵，然后做出来的结果</span>
<span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> m, n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n)
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&gt;</span>dp(n + <span class="hljs-number">1</span>, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) {
            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//动态规划版本</span>
<span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> m, n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n)
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&gt;</span>dp(n + <span class="hljs-number">1</span>, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) {
                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) {
                    dp[i][j] = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)
                {
                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];   <span class="hljs-comment">//上边界</span>
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j==<span class="hljs-number">0</span>) {
                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">//左边界</span>

                }
                <span class="hljs-keyword">else</span> {
                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
                }
            }

        }
        <span class="hljs-built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//递归版本</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> func(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n) {
    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> func(m, n - <span class="hljs-number">1</span>) + func(m - <span class="hljs-number">1</span>, n);
}
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> m, n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n) {
        <span class="hljs-built_in">cout</span> &lt;&lt; func(m, n) &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="85-在字符串中找出连续最长的数字串">85. 在字符串中找出连续最长的数字串</h4> 
<p><strong>题目描述 :</strong> <br> 样例输出 <br> 输出123058789，函数返回值9 <br> 输出54761，函数返回值5 <br> <strong>思路分析：</strong>: <br> 这道题，就是先选定一个开头，然后从这个开头开始循环，寻找到一个子数字串，然后和后面的进行对比。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs mel">#include &lt;bits/stdc++.h&gt;
using <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">string</span> str;
    <span class="hljs-keyword">while</span> (cin &gt;&gt; str)
    {
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">max</span> = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">string</span> out;
        <span class="hljs-keyword">string</span> ss;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-keyword">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">'9'</span>) {
                ss += str[i];
                <span class="hljs-keyword">while</span> (str[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; str[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">'9'</span>)
                {
                    i++;
                    ss += str[i];
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">max</span>&lt;ss.<span class="hljs-keyword">size</span>())
                {
                    <span class="hljs-keyword">max</span> = ss.<span class="hljs-keyword">size</span>();
                    out = ss;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">max</span>==ss.<span class="hljs-keyword">size</span>()) {
                    out += ss;
                }

            }
            ss.<span class="hljs-keyword">clear</span>();

        }
        cout &lt;&lt; out &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; <span class="hljs-keyword">max</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="86-java-题目0-1-级">86. JAVA 题目0-1 级</h4> 
<p><strong>题目描述 :</strong> <br> 编写一个函数，传入一个int型数组，返回该数组能否分成两组，使得两组中各元素加起来的和相等，并且，所有5的倍数必须在其中一个组中，所有3的倍数在另一个组中（不包括5的倍数），能满足以上条件，返回true；不满足时返回false。 <br> <strong>思路分析：</strong>: <br> 这道题主要想法就是先将 5 和 3 的倍数分到两个堆里面， 然后将剩下的数值放到一起，如果3的倍数和5的倍数的和的差值最后计算的结果 ，和剩下的数值经过全排列加减的结果相同，那么就说明存在这样的组合。 <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main() {
        <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>&gt;&gt;n)
    {
        <span class="hljs-keyword">int</span> sum5=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> sum3=<span class="hljs-number">0</span>;
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>vec ;
        <span class="hljs-keyword">int</span> temp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){
            <span class="hljs-built_in">cin</span>&gt;&gt;temp;
            <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)
                sum5+=temp;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)
                sum3+=temp;
            <span class="hljs-keyword">else</span>
                vec.push_back(temp);
        }
        <span class="hljs-keyword">int</span> t= vec.size();
        <span class="hljs-keyword">int</span> sub =<span class="hljs-built_in">abs</span>(sum3-sum5);
        <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span>(sum5==sum3)
                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"true"</span>&lt;&lt;endl;
            <span class="hljs-keyword">else</span> 
                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"false"</span>&lt;&lt;endl;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-built_in">string</span> s=<span class="hljs-string">""</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t-<span class="hljs-number">1</span>;i++)
                s+=<span class="hljs-string">"+-"</span>;
            sort(s.begin(),s.end());
            <span class="hljs-keyword">do</span>{
                <span class="hljs-keyword">int</span> res=vec[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;t;i++){
                    <span class="hljs-keyword">if</span>(s[i-<span class="hljs-number">1</span>]==<span class="hljs-string">'+'</span>)
                        res+=vec[i];
                    <span class="hljs-keyword">else</span>
                        res-=vec[i];
                }
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(res)==sub){
                    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"true"</span>&lt;&lt;endl;
                    flag=<span class="hljs-number">1</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }<span class="hljs-keyword">while</span>(next_permutation(s.begin(),s.end()));<span class="hljs-comment">// 产生一个全排列</span>

        }
        <span class="hljs-keyword">if</span>(!flag)
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"false"</span>&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h4 id="87-计票统计">87. 计票统计</h4> 
<p><strong>题目描述 :</strong> <br> 输入候选人的人数，第二行输入候选人的名字，第三行输入投票人的人数，第四行输入投票。 <br> 输出： <br> 返回匹配的结果，正确输出true，错误输出false <br> <strong>思路分析：</strong>: <br> 这一题方法用的比较笨的方法，直接就是进行比较得到最终的结果。</p> 
<p><strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
<span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n)
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>vote_pass;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-built_in">string</span> temp;
            <span class="hljs-built_in">cin</span> &gt;&gt; temp;
            vote_pass.push_back(temp);
        }
        <span class="hljs-keyword">int</span> num_voter;
        <span class="hljs-built_in">cin</span> &gt;&gt; num_voter;
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>vote_result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_voter;i++)
        {
            <span class="hljs-built_in">string</span> temp;
            <span class="hljs-built_in">cin</span> &gt;&gt; temp;
            vote_result.push_back(temp);
        }
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>res(vote_pass.size(),<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> invalid = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vote_pass.size(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vote_result.size(); j++)
            {
                <span class="hljs-keyword">if</span> (vote_pass[i] == vote_result[j])
                {
                    res[i]++;
                }

            }
        }
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vote_pass.size(); i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; vote_pass[i] &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; res[i] &lt;&lt; endl;
            sum += res[i];
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Invalid : "</span> &lt;&lt; vote_result.size() - sum &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre> 
<h4 id="88-人民币转换">88. 人民币转换</h4> 
<p><strong>题目描述 :</strong> <br> 考试题目和要点： <br> 1、中文大写金额数字前应标明“人民币”字样。中文大写金额数字应用壹、贰、叁、肆、伍、陆、柒、捌、玖、拾、佰、仟、万、亿、元、角、分、零、整等字样填写。（30分） <br> 2、中文大写金额数字到“元”为止的，在“元”之后，应写“整字，如￥ 532.00应写成“人民币伍佰叁拾贰元整”。在”角“和”分“后面不写”整字。（30分） <br> 3、阿拉伯数字中间有“0”时，中文大写要写“零”字，阿拉伯数字中间连续有几个“0”时，中文大写金额中间只写一个“零”字，如￥6007.14，应写成“人民币陆仟零柒元壹角肆分“。（ <br> 返回匹配的结果，正确输出true，错误输出false <br> <strong>思路分析：</strong>: <br> 这种题只要能耐心就能做出来，但是实际情况是需要加入一些技巧和一些优化的思想，不能用蛮力强行解决。 <br> 其中的小技巧就是：<code>多用switch，case进行选择，然后加入% 消除前面可能出现的多余数字</code> <br> <strong>代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;string&gt;</span>
<span class="hljs-keyword">using</span> namespace std;
<span class="hljs-keyword">string</span> underwan(<span class="hljs-keyword">int</span> n)
{
    <span class="hljs-keyword">int</span> num = to_string(n).size();
    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span> *(num == <span class="hljs-number">4</span>) + <span class="hljs-number">1</span> *(num == <span class="hljs-number">3</span>) + <span class="hljs-number">2</span> *(num == <span class="hljs-number">2</span>) + <span class="hljs-number">3</span> *(num == <span class="hljs-number">1</span>);
    <span class="hljs-keyword">string</span> result = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">string</span> wordlist[<span class="hljs-number">11</span>] = {<!-- --><span class="hljs-string">"零"</span>,<span class="hljs-string">"壹"</span>,<span class="hljs-string">"贰"</span>,<span class="hljs-string">"叁"</span>,<span class="hljs-string">"肆"</span>,<span class="hljs-string">"伍"</span>,<span class="hljs-string">"陆"</span>,<span class="hljs-string">"柒"</span>,<span class="hljs-string">"捌"</span>,<span class="hljs-string">"玖"</span>,<span class="hljs-string">"拾"</span>};
    <span class="hljs-keyword">switch</span>(sign)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            {
                result += wordlist[n / <span class="hljs-number">1000</span>] + <span class="hljs-string">"仟"</span>;
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
            }
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            {
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">1000</span> / <span class="hljs-number">100</span>)
                    result += wordlist[n % <span class="hljs-number">1000</span> / <span class="hljs-number">100</span>] + <span class="hljs-string">"佰"</span>;
                <span class="hljs-keyword">else</span>
                    result += <span class="hljs-string">"零"</span>;
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
            }
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            {
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">100</span> / <span class="hljs-number">10</span> != <span class="hljs-number">1</span>)
                    result += wordlist[n % <span class="hljs-number">100</span> / <span class="hljs-number">10</span>] + <span class="hljs-string">"拾"</span>;
                <span class="hljs-keyword">else</span>
                    result += <span class="hljs-string">"拾"</span>;
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">1000</span> / <span class="hljs-number">100</span> != <span class="hljs-number">0</span> &amp;&amp; n % <span class="hljs-number">100</span> / <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)
                    result += <span class="hljs-string">"零"</span>;
                <span class="hljs-keyword">if</span>(n % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
            }
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: result += wordlist[n % <span class="hljs-number">10</span>];
    }
    <span class="hljs-keyword">return</span> result;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">double</span> input;
    <span class="hljs-keyword">while</span>(cin &gt;&gt; input)
    {
        <span class="hljs-keyword">if</span>(input &lt; <span class="hljs-number">1e-2</span>)
        {
            cout &lt;&lt; <span class="hljs-string">"人民币零元整"</span> &lt;&lt; endl;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">string</span> <span class="hljs-keyword">out</span> = <span class="hljs-string">"人民币"</span>;
        <span class="hljs-keyword">string</span> wordlist[<span class="hljs-number">11</span>] = {<!-- --><span class="hljs-string">"零"</span>,<span class="hljs-string">"壹"</span>,<span class="hljs-string">"贰"</span>,<span class="hljs-string">"叁"</span>,<span class="hljs-string">"肆"</span>,<span class="hljs-string">"伍"</span>,<span class="hljs-string">"陆"</span>,<span class="hljs-string">"柒"</span>,<span class="hljs-string">"捌"</span>,<span class="hljs-string">"玖"</span>,<span class="hljs-string">"拾"</span>};
        <span class="hljs-keyword">int</span> interger  = (<span class="hljs-keyword">int</span>) input;
        <span class="hljs-keyword">if</span>(interger &gt;= <span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">int</span> count = to_string(interger).size();
            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span> * (count &gt; <span class="hljs-number">8</span>) + <span class="hljs-number">1</span> * (count &lt;=<span class="hljs-number">8</span> &amp;&amp; count &gt;<span class="hljs-number">4</span>) + <span class="hljs-number">2</span> * (count &lt;= <span class="hljs-number">4</span>);
            <span class="hljs-keyword">switch</span>(flag)
            {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> : <span class="hljs-keyword">out</span> += underwan(interger / <span class="hljs-number">1e8</span>) + <span class="hljs-string">"亿"</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">out</span> += underwan(interger % (<span class="hljs-keyword">int</span>)<span class="hljs-number">1e8</span> / <span class="hljs-number">1e4</span>) + <span class="hljs-string">"万"</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">out</span> += underwan(interger % (<span class="hljs-keyword">int</span>)<span class="hljs-number">1e4</span>) + <span class="hljs-string">"元"</span>;
            }
        }
        <span class="hljs-keyword">if</span>((input - interger) &gt;= <span class="hljs-number">1e-2</span>)
        {
            <span class="hljs-keyword">double</span> <span class="hljs-keyword">decimal</span> = input - interger;
            <span class="hljs-keyword">int</span> jiao = <span class="hljs-number">0</span>, fen = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">decimal</span> - <span class="hljs-number">0.09</span>)&gt;= <span class="hljs-number">1e-7</span>)
            {
                jiao = to_string(<span class="hljs-keyword">decimal</span>)[<span class="hljs-number">2</span>] - <span class="hljs-string">'0'</span>;
                <span class="hljs-keyword">out</span> += wordlist[jiao] + <span class="hljs-string">"角"</span>;
            }
            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">decimal</span> - <span class="hljs-number">0.009</span>)&gt;= <span class="hljs-number">1e-7</span>)
            {
                fen = to_string(<span class="hljs-keyword">decimal</span>)[<span class="hljs-number">3</span>] - <span class="hljs-string">'0'</span>;
                <span class="hljs-keyword">if</span>(fen != <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">out</span> += wordlist[fen] + <span class="hljs-string">"分"</span>;
            }
        }
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">out</span> += <span class="hljs-string">"整"</span>;
        cout &lt;&lt; <span class="hljs-keyword">out</span> &lt;&lt; endl;
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f0a9e64de99ac7c08a60df207c4bfaf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ID3决策树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8cc04e5213cc2b59e4165b232b9bddb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A - Easy h-index（阅读理解）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>