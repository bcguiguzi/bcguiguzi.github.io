<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>强推Linux高性能服务器编程, 真的是后端开发技术提升, 沉淀自身不容错过的一本经典书籍 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="强推Linux高性能服务器编程, 真的是后端开发技术提升, 沉淀自身不容错过的一本经典书籍" />
<meta property="og:description" content="目录
第1章 TCP/IP协议
1.1 TCP/IP协议族体系结构以及主要协议
1.1.1 数据链路层
1.1.2 网络层
1.1.3 传输层
1.1.4 应用层
1.2 封装
1.3 分用
1.5 ARP协议工作原理
1.5.1 以太网ARP请求/应答报文详解
1.5.2 ARP高速缓存的查看和修改
1.5.3 使用tcpdump观察ARP通信过程所得结果如下
本篇核心关键所在不在于是跟大家分享多少知识点, 而在于推荐大家阅读这本书籍。小杰不是打广告，这本书小杰研读部分之后发现真实的是一本经典数据，文章不仅仅只是枯燥乏味的介绍网络基础知识和僵硬的介绍网络编程而是把很多的系统调用细节知识点通过代码实际案例来解释，前后连贯，先打基础后通过代码前后呼应, 将学到的基础知识落到实处上去. 真的是一本特别经典的书籍，不是虚吹，说再多都没啥用，小杰附上百度云盘链接一份，感兴趣的兄弟可以获取哈.链接：https://pan.baidu.com/s/1FFveRbZDoVXr8ZSwhVPWNw?pwd=kczf 提取码：kczf 第1章 TCP/IP协议 1.1 TCP/IP协议族体系结构以及主要协议 TCP/IP协议栈是一个四层协议, 由下而上分别是数据链路层, 网络层, 传输层, 应用层, 上层协议使用下层协议提供的服务. 下三层处在内核态中, 应用层处在用户空间中.
1.1.1 数据链路层 链路层功能： 屏蔽物理层的电气差异, 为上层提供统一服务接口
数据链路层实现了网卡接口的网络驱动程序, 处理数据在不同的物理媒介上的传输
不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。 下层协议为上层提供统一的接口服务, 隐藏屏蔽掉物理层的不同电气差别.
链路层常用协议: ARP协议 (地址解析协议), RARP协议（逆地址解析协议）
功能: ARP 将IP地址转换为物理MAC地址. RARP将MAC地址转换为IP地址 在网络层使用IP地址唯一标识一台主机, 在链路层使用MAC地址唯一标识一台主机
因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务
1.1.2 网络层 网络层功能：网络层实现数据包的选路和转发
通常使用众多分级的路由器来连接分散的主机或LAN (局域网), 往往路由器就作为局域网的网关. (借助海关来理解)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4dbf104cbc325e35390985c97af81aab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-22T09:42:15+08:00" />
<meta property="article:modified_time" content="2022-06-22T09:42:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">强推Linux高性能服务器编程, 真的是后端开发技术提升, 沉淀自身不容错过的一本经典书籍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC1%E7%AB%A0%20TCP%2FIP%E5%8D%8F%E8%AE%AE-toc" style="margin-left:0px;"><a href="#%E7%AC%AC1%E7%AB%A0%20TCP%2FIP%E5%8D%8F%E8%AE%AE" rel="nofollow">第1章 TCP/IP协议</a></p> 
<p id="1.1%20TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#1.1%20TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE" rel="nofollow">1.1 TCP/IP协议族体系结构以及主要协议</a></p> 
<p id="1.1.1%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-toc" style="margin-left:80px;"><a href="#1.1.1%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" rel="nofollow">1.1.1 数据链路层</a></p> 
<p id="1.1.2%20%E7%BD%91%E7%BB%9C%E5%B1%82-toc" style="margin-left:80px;"><a href="#1.1.2%20%E7%BD%91%E7%BB%9C%E5%B1%82" rel="nofollow">1.1.2 网络层</a></p> 
<p id="1.1.3%20%E4%BC%A0%E8%BE%93%E5%B1%82-toc" style="margin-left:80px;"><a href="#1.1.3%20%E4%BC%A0%E8%BE%93%E5%B1%82" rel="nofollow">1.1.3 传输层</a></p> 
<p id="1.1.4%20%E5%BA%94%E7%94%A8%E5%B1%82-toc" style="margin-left:80px;"><a href="#1.1.4%20%E5%BA%94%E7%94%A8%E5%B1%82" rel="nofollow">1.1.4 应用层</a></p> 
<p id="1.2%20%E5%B0%81%E8%A3%85-toc" style="margin-left:40px;"><a href="#1.2%20%E5%B0%81%E8%A3%85" rel="nofollow">1.2 封装</a></p> 
<p id="1.3%20%E5%88%86%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.3%20%E5%88%86%E7%94%A8" rel="nofollow">1.3 分用</a></p> 
<p id="1.5%20ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.5%20ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">1.5 ARP协议工作原理</a></p> 
<p id="1.5.1%20%E4%BB%A5%E5%A4%AA%E7%BD%91ARP%E8%AF%B7%E6%B1%82%2F%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#1.5.1%20%E4%BB%A5%E5%A4%AA%E7%BD%91ARP%E8%AF%B7%E6%B1%82%2F%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3" rel="nofollow">1.5.1 以太网ARP请求/应答报文详解</a></p> 
<p id="1.5.2%20ARP%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9-toc" style="margin-left:80px;"><a href="#1.5.2%20ARP%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9" rel="nofollow">1.5.2 ARP高速缓存的查看和修改</a></p> 
<p id="1.5.3%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FARP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E6%89%80%E5%BE%97%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B-toc" style="margin-left:80px;"><a href="#1.5.3%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FARP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E6%89%80%E5%BE%97%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B" rel="nofollow">1.5.3 使用tcpdump观察ARP通信过程所得结果如下</a></p> 
<hr id="hr-toc"> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><strong>本篇核心关键所在不在于是跟大家分享多少知识点,  而在于推荐大家阅读这本书籍。</strong></span></li><li><span style="color:#0d0016;"><strong>小杰不是打广告，这本书小杰研读部分之后发现真实的是一本经典数据，文章不仅仅只是枯燥乏味的介绍网络基础知识和僵硬的介绍网络编程</strong></span></li><li><span style="color:#0d0016;"><strong>而是把很多的系统调用细节知识点通过代码实际案例来解释，前后连贯，先打基础后通过代码前后呼应, 将学到的基础知识落到实处上去.  </strong></span></li><li><span style="color:#0d0016;"><strong>真的是一本特别经典的书籍，不是虚吹，说再多都没啥用，小杰附上百度云盘链接一份，感兴趣的兄弟可以获取哈.</strong></span></li><li><span style="color:#0d0016;"><strong>链接：https://pan.baidu.com/s/1FFveRbZDoVXr8ZSwhVPWNw?pwd=kczf <br> 提取码：kczf</strong></span></li></ul> 
</blockquote> 
<h2 id="%E7%AC%AC1%E7%AB%A0%20TCP%2FIP%E5%8D%8F%E8%AE%AE"><span style="color:#0d0016;"><strong>第1章 TCP/IP协议</strong></span></h2> 
<h3 id="1.1%20TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span style="color:#0d0016;"><strong>1.1 TCP/IP协议族体系结构以及主要协议</strong></span></h3> 
<p><span style="color:#0d0016;"><strong><img alt="" height="545" src="https://images2.imgbox.com/d2/a4/sjhDfv5t_o.png" width="1171"></strong></span></p> 
<p><span style="color:#0d0016;"><strong>TCP/IP协议栈是一个四层协议, 由下而上分别是数据链路层, 网络层, 传输层, 应用层, 上层协议使用下层协议提供的服务.  下三层处在内核态中, 应用层处在用户空间中.</strong></span></p> 
<h4 id="1.1.1%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span style="color:#0d0016;"><strong>1.1.1 数据链路层</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>链路层功能： 屏蔽物理层的电气差异, 为上层提供统一服务接口</strong></span></p> 
<p><span style="color:#0d0016;"><strong>数据链路层实现了网卡接口的网络驱动程序, 处理数据在不同的物理媒介上的传输</strong></span></p> 
<p><span style="color:#0d0016;"><strong>不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。    下层协议为上层提供统一的接口服务, 隐藏屏蔽掉物理层的不同电气差别.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>链路层常用协议: ARP协议 (地址解析协议), RARP协议（逆地址解析协议）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>功能: ARP 将IP地址转换为物理MAC地址.    RARP将MAC地址转换为IP地址 </strong></span></p> 
<p><span style="color:#0d0016;"><strong><img alt="" height="217" src="https://images2.imgbox.com/d2/b1/HP5iUb1H_o.png" width="494"></strong></span></p> 
<p><span style="color:#0d0016;"><strong>在网络层使用IP地址唯一标识一台主机, 在链路层使用MAC地址唯一标识一台主机</strong></span></p> 
<p><span style="color:#0d0016;"><strong>因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务</strong></span></p> 
<h4 id="1.1.2%20%E7%BD%91%E7%BB%9C%E5%B1%82"><span style="color:#0d0016;"><strong>1.1.2 网络层</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>网络层功能：网络层实现数据包的选路和转发</strong></span></p> 
<p><span style="color:#0d0016;"><strong>通常使用众多分级的路由器来连接分散的主机或LAN (局域网), 往往路由器就作为局域网的网关. (借助海关来理解).   每一个路由器都相当于是一个中间结点.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>网络层的任务就是选择这些中间节点（路由），以确定两台主机之间的通信路径. </strong></span></p> 
<p><span style="color:#0d0016;"><strong>网络层对 上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。     （</strong></span><span style="color:#fe2c24;"><strong>为何要分层, 优势出来了, 不同层处理不同的通信细节问题, 分化分工, 使得问题简化, 下层协议为上层协议提供简单易用的接口, 隐藏下层处理的细节问题</strong></span><span style="color:#0d0016;"><strong>）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>网络层重要协议：IP协议,  ICMP协议  (探路小兵, 主要用来检测连接的)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>IP协议根据数据包的目的IP地址来决定如何投递它，如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（next hop）路由器，并将数据包交付给该路由器来转发</strong></span></p> 
<p><strong><span style="color:#0d0016;">数据包是在网络环境中, 一跳一跳的传输. TTL数据包的最长生存时间, 单位也是hop, 跳过TTL还未到达目标主机, 就默认发送失败, 丢弃数据包了, 并且发送ICMP差错报文给源端.</span></strong></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/aa/ce/HiottY6f_o.png" width="1139"></p> 
<p><span style="color:#0d0016;"><strong>ICMP报文分为差错报文 (回应网络错误) eg: 上述的数据包不可达(3), 重定向(5)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>查询报文(ping查询目标是否可达, 网络是否连接)(8)，  所以存在类型来区分他们.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>ICMP报文还使用8位代码字段来进一步细分不同的条件</strong></span></p> 
<p><span style="color:#0d0016;"><strong>比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向</strong></span></p> 
<p><span style="color:#0d0016;"><strong>ICMP报文使用16位校验和字段 对整个报文（包括头部和内容部分）进行循环冗余校验（Cyclic Redundancy Check，CRC），以检验报文在传输过程中是否损坏</strong></span></p> 
<h4 id="1.1.3%20%E4%BC%A0%E8%BE%93%E5%B1%82"><span style="color:#0d0016;"><strong>1.1.3 传输层</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>传输层只管端到端的传输, 传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>在传输层看来, 两端好似是直接通信的, 实际上中间的中转细节是由网络层处理的   (下层对上层隐藏细节，让上层协议变得尽可能看起来很简单.)</strong></span></p> 
<p><img alt="" height="689" src="https://images2.imgbox.com/e7/90/NV3rYTbU_o.png" width="1153"></p> 
<p><span style="color:#0d0016;"><strong>实线箭头表示TCP/IP协议族各层之间的实体通信 （数据包确实是沿着这些线路传递的），而水平的虚线箭头表示逻辑通信线路.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>该图中还附带描述了不同物理网络的连接方法。可见，数据链路层（驱动程序）封装了物理网络的电气细节</strong></span></p> 
<p><span style="color:#0d0016;"><strong>传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等</strong></span></p> 
<p><span style="color:#0d0016;"><strong>下层都是在为上层提供服务, 提供便捷, 隐藏细节. </strong></span></p> 
<p><span style="color:#0d0016;"><strong>传输层重点协议： TCP, UDP.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>TCP是可靠传输协议, 面向连接, 基于流.</strong></span></p> 
<p><span style="color:#0d0016;"><strong>可靠来源: 超时重传, 排序号, 确认应答等可靠机制</strong></span></p> 
<p><span style="color:#0d0016;"><strong>使用TCP协议通信的双方必须先建立TCP连接， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等.    (超时重传, 确认应答这些机制的实现必然携带着一些内核数据结构. )</strong></span></p> 
<p><span style="color:#0d0016;"><strong>当通信结束时，双方必须关闭连接以释放这些内核数据。 ( 连接关闭细节,内核数据结构的释放, 避免内存泄漏 )</strong></span></p> 
<p><span style="color:#0d0016;"><strong>UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务</strong></span></p> 
<p><span style="color:#0d0016;"><strong>不可靠是因为什么?   因为如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败     （不会重传, 不会确认应答. 所以不可靠）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>所以UDP传输的使用往往需要自己处理数据确认、超时重传等逻辑  （自定义UDP可靠传输协议.在应用层书写）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>UDP是无连接的, 所以每一次传输数据都需要指定对端的地址 ip + port</strong></span></p> 
<p><span style="color:#0d0016;"><strong>基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断     </strong></span></p> 
<p><span style="color:#0d0016;"><strong>（</strong></span><span style="color:#fe2c24;"><strong>数据报传输，每次都按照一个包裹传输, 包裹为最小传输单位, 大于包裹数据截断</strong></span><span style="color:#0d0016;"><strong>）</strong></span></p> 
<h4 id="1.1.4%20%E5%BA%94%E7%94%A8%E5%B1%82"><span style="color:#0d0016;">1.1.4 应用层</span></h4> 
<p><span style="color:#0d0016;"><strong>应用层负责处理应用程序的逻辑                                       (用户空间应用程序)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>数据链路层、网络层和传输层负责处理网络通信细节       (内核数据结构, 稳定, 安全, 高效)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>?为啥不把应用层服务也全部放入到内核态中                  （逻辑众多,会使内核变得非常庞大）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>少数服务器程序是在内核中实现的?                                 （省去拷贝的代价, 提高效率，但是代码逻辑复杂, 不便于移植，书写应用）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>应用层重点协议，应用程序列举</strong></span></p> 
<ol><li><span style="color:#0d0016;"><strong>ping是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具</strong></span></li><li><span style="color:#0d0016;"><strong>DNS（Domain Name Service，域名服务）协议提供机器域名到IP 地址的转换，我们将在后面简要介绍DNS协议</strong></span></li></ol> 
<p><span style="color:#0d0016;"><strong>应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如ping程序</strong></span></p> 
<p><span style="color:#0d0016;"><strong>应用层协议（或程序）通常既可以使 用TCP服务，又可以使用UDP服务，比如DNS协议。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>我们可以通 过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务</strong></span></p> 
<h3 id="1.2%20%E5%B0%81%E8%A3%85"><span style="color:#0d0016;">1.2 封装</span></h3> 
<p><span style="color:#0d0016;"><strong>前文一直都在说上层协议使用下层协议提供的服务, 但是究竟是如何使用上的呢?  封装</strong></span></p> 
<p><span style="color:#0d0016;"><strong>应用程序数据在发送到物理网络上之前， 将沿着内核协议栈从上往下依次传递  （封装, 封包）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能， 这个过程就称为封装</strong></span></p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/16/8e/etCLKx8A_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"><strong> 每一层都可以进行DDOS攻击.  洪水猛兽.  网络层（可以不断发送连接请求, 或者不断发送fin包.）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>DDOS很有意思, 而且暂时没有完全的解决方案, 大致做法就是， 不断地发送无效请求, 占据服务器, 让真正需要使用服务器地人无法建立连接, 或者无法使用.      </strong></span></p> 
<p><span style="color:#0d0016;"><strong>解决方法：前面放一台大型地壁垒机器, 过滤无效请求.        (扯多了, 插曲)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>经过TCP封装后的数据称为TCP报文段（TCP message segment）， 或者简称TCP段。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>TCP协议为通信双方维持一个连接，并且在内核中存储相关数据          （内核数据结构：属于内核协议栈）</strong></span></p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/8e/6b/jcEFZWge_o.png" width="1166"><span style="color:#0d0016;"><strong>深入内核协议栈数据结构去看这个封装过程.    </strong></span></p> 
<p><span style="color:#0d0016;"><strong>发送地时候是 tcp header + tcp 内核sendbuffer   接收地时候是   tcp header + tcp 内核recvbuffer</strong></span></p> 
<p><span style="color:#0d0016;"><strong>send + write数据, 是先写到内核协议栈的传输层的tcp sendbuffer中, 然后经有内核协议栈层层向下封装, 经由网卡接口驱动程序将其放到物理网络传输层 (网线, 电气传输)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP 对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的.     （不保存副本在内核态意味着不可靠, 不考虑重传的问题）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>经过IP封装后的数据称为IP数据报（IP datagram）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>经过数据链路层封装的数据称为帧（frame）。传输媒介不同，帧 的类型也不同</strong></span></p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/8d/6b/h2SEvuyn_o.png" width="1200"><span style="color:#0d0016;"><strong>帧才是最终在物理网络上传送的字节序列 </strong></span></p> 
<h3 id="1.3%20%E5%88%86%E7%94%A8"><span style="color:#0d0016;">1.3 分用</span></h3> 
<p><span style="color:#0d0016;"><strong>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将 处理后的帧交给目标应用程序。这个过程称为分用</strong></span></p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/e7/b3/T4ksRlMS_o.png" width="1148"></p> 
<p><span style="color:#0d0016;"><strong>上层协议那么多, 所以分用的一个核心问题在于如何知道分用后应该交付给哪个上层协议. </strong></span></p> 
<p><span style="color:#0d0016;"><strong>掐去头部之后的身子应该交付给谁? </strong></span></p> 
<p><span style="color:#0d0016;"><strong>每一层的头部中都会存在这样一个字段可以标识上层协议进行交付</strong></span></p> 
<p><span style="color:#0d0016;"><strong>eg : IP协议, ARP协议, RAPR协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们，帧给出的是帧头部的类型字段进行区分</strong></span></p> 
<p><span style="color:#0d0016;"><strong>eg : 以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报</strong></span></p> 
<p><span style="color:#0d0016;"><strong>同样，因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以 IP数据报的头部采用16位的协议（protocol）字段来区分它们。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>TCP报文段和UDP数据报则通过其头部中的16位的端口号（port number）字段来区分上层应用程序。所有知名应用层协议使用的端口号都可在 /etc/services 文件中找到。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务</strong></span></p> 
<h3 id="1.5%20ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span style="color:#0d0016;">1.5 ARP协议工作原理</span></h3> 
<p><span style="color:#0d0016;"><strong>主机向自己所在的网络广播一个ARP请求，该请求包含目标机器 的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求 的目标机器会回应一个ARP应答，其中包含自己的物理地址</strong></span></p> 
<p><span style="color:#0d0016;"><strong>核心原理: 广播, 目标MAC ff:ff:ff:ff:ff:ff       同网段的所有主机广播, 对比发现ip等于目标ip的机器，填写自己的MAC物理地址并且发送ack应答包</strong></span></p> 
<h4 id="1.5.1%20%E4%BB%A5%E5%A4%AA%E7%BD%91ARP%E8%AF%B7%E6%B1%82%2F%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3"><span style="color:#0d0016;">1.5.1 以太网ARP请求/应答报文详解</span></h4> 
<p><img alt="" height="578" src="https://images2.imgbox.com/1f/3c/CTF2P0AQ_o.png" width="1174"></p> 
<p><span style="color:#0d0016;"><strong>硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为 4。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值 为2）、RARP请求（值为3）和RARP应答（值为4）。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>最后4个字段指定通信双方的以太网地址和IP地址。发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。接 收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进 去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之（当然，如前所述，操作字段需要设置为2）。</strong></span></p> 
<h4 id="1.5.2%20ARP%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9"><span style="color:#0d0016;">1.5.2 ARP高速缓存的查看和修改</span></h4> 
<p><span style="color:#0d0016;"><strong>通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>Linux下可以使用arp命令来查看和修改ARP高速缓存。</strong></span></p> 
<ol><li><span style="color:#0d0016;"><strong>arp  -a 是查看ARP 缓存内容   </strong></span></li><li><span style="color:#0d0016;"><strong>arp  -d  ip   是删除ARP缓存内容</strong></span></li><li><span style="color:#0d0016;"><strong>arp  -s  ip  MAC  是添加  ARP缓存内容</strong></span></li></ol> 
<h4 id="1.5.3%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FARP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E6%89%80%E5%BE%97%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B"><span style="color:#0d0016;">1.5.3 使用tcpdump观察ARP通信过程所得结果如下</span></h4> 
<p><img alt="" height="776" src="https://images2.imgbox.com/6b/0a/rKhoQMxk_o.png" width="1197"><span style="color:#0d0016;"><strong> 注意点:</strong></span></p> 
<ol><li><span style="color:#0d0016;"><strong>ARP请求和应答是从以太网驱动程序发出的，而并非像图 中描述的那样从ARP模块直接发送到以太网上，所以我们将它们用虚 线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 （比如携带IP数据报的以太网帧）的区别。</strong></span></li><li><span style="color:#0d0016;"><strong>路由器也将接收到以太网帧1，因为该帧是一个广播帧。不 过很显然，路由器并没有回应其中的ARP请求，正如前文讨论的那样</strong></span></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4acd7256e6ad6f7d07ccffd8dc850048/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人工智能数据挖掘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efaac61fa1e474107efd1925570cd3dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑开机后，显示屏无信号怎么处理？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>