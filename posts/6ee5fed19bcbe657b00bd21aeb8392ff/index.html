<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>方格游戏 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="方格游戏" />
<meta property="og:description" content="目录
〇，前言
一，数据建模
1，名词澄清
2，块的表示
3，块的初始化
4，玩家数据
5，玩家初始化
二，界面
1，方格输出
2，游戏界面
三，游戏规则
1，翻转和旋转
2，核心逻辑、结束控制
3，主控程序
4，玩家操作
四，完整代码
五，规则对比
〇，前言 因为是一边设计一边写代码一边写博客，所以本文的中间代码很多都不是最新版本，
代码以最终完整版为准。
一，数据建模 1，名词澄清 一个玩家有21个块，每个块由1-5个格子组成。
2，块的表示 对每个块，用最多5个点把每个格子的坐标存起来
typedef struct Point { int x,y; }Point; typedef struct Node { int num; Point p[5]; }Node; 那么，如何建立坐标系呢？
对每个块拓展为它的凸包，并把最左上角的快设为（0,0）那么所有格子的坐标都是2个非负整数组成。
实际上，除了十字交叉的块之外，其他20个块都可以适当的旋转和翻转，使得它的凸包的最左上角的点上有一个格子。
int num[]={5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,3,5,4,3,2,1}; int matrix[]={ 0,0,0,1,0,2,1,1,2,1, 0,0,1,0,1,1,1,2,2,1, 0,0,1,0,1,1,1,2,2,2, 0,1,1,0,1,1,1,2,2,1, 0,0,0,1,1,1,1,2,2,2, 0,0,0,1,0,2,1,2,2,2, 0,0,0,1,0,2,1,2,1,3, 0,0,0,1,0,2,0,3,1,2, 0,0,0,1,0,2,0,3,1,3, 0,0,0,1,0,2,1,0,1,2, 0,0,0,1,0,2,1,0,1,1, 0,0,0,1,1,0,1,1, 0,0,0,1,0,2,1,0, 0,0,0,1,1,1,1,2, 0,0,0,1,0,2,1,1, 0,0,0,1,1,0, 0,0,0,1,0,2,0,3,0,4, 0,0,0,1,0,2,0,3, 0,0,0,1,0,2, 0,0,0,1, 0,0, }; 对应代码，有20行都是0,0开头，只有一行不是。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6ee5fed19bcbe657b00bd21aeb8392ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-27T00:59:23+08:00" />
<meta property="article:modified_time" content="2023-02-27T00:59:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">方格游戏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E3%80%87%EF%BC%8C%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E3%80%87%EF%BC%8C%E5%89%8D%E8%A8%80" rel="nofollow">〇，前言</a></p> 
<p id="%E4%B8%80%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1" rel="nofollow">一，数据建模</a></p> 
<p id="1%EF%BC%8C%E5%90%8D%E8%AF%8D%E6%BE%84%E6%B8%85-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E5%90%8D%E8%AF%8D%E6%BE%84%E6%B8%85" rel="nofollow">1，名词澄清</a></p> 
<p id="2%EF%BC%8C%E5%9D%97%E7%9A%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E5%9D%97%E7%9A%84%E8%A1%A8%E7%A4%BA" rel="nofollow">2，块的表示</a></p> 
<p id="3%EF%BC%8C%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#3%EF%BC%8C%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3，块的初始化</a></p> 
<p id="4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%95%B0%E6%8D%AE" rel="nofollow">4，玩家数据</a></p> 
<p id="5%EF%BC%8C%E7%8E%A9%E5%AE%B6%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#5%EF%BC%8C%E7%8E%A9%E5%AE%B6%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">5，玩家初始化</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E7%95%8C%E9%9D%A2-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E7%95%8C%E9%9D%A2" rel="nofollow">二，界面</a></p> 
<p id="1%EF%BC%8C%E6%96%B9%E6%A0%BC%E8%BE%93%E5%87%BA-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E6%96%B9%E6%A0%BC%E8%BE%93%E5%87%BA" rel="nofollow">1，方格输出</a></p> 
<p id="2%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2" rel="nofollow">2，游戏界面</a></p> 
<p id="%E4%B8%89%EF%BC%8C%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%8C%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99" rel="nofollow">三，游戏规则</a></p> 
<p id="1%EF%BC%8C%E7%BF%BB%E8%BD%AC%E5%92%8C%E6%97%8B%E8%BD%AC-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E7%BF%BB%E8%BD%AC%E5%92%8C%E6%97%8B%E8%BD%AC" rel="nofollow">1，翻转和旋转</a></p> 
<p id="2%EF%BC%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E3%80%81%E7%BB%93%E6%9D%9F%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E3%80%81%E7%BB%93%E6%9D%9F%E6%8E%A7%E5%88%B6" rel="nofollow">2，核心逻辑、结束控制</a></p> 
<p id="3%EF%BC%8C%E4%B8%BB%E6%8E%A7%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3%EF%BC%8C%E4%B8%BB%E6%8E%A7%E7%A8%8B%E5%BA%8F" rel="nofollow">3，主控程序</a></p> 
<p id="4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%93%8D%E4%BD%9C" rel="nofollow">4，玩家操作</a></p> 
<p id="%E5%9B%9B%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">四，完整代码</a></p> 
<p id="%E4%BA%94%EF%BC%8C%E8%A7%84%E5%88%99%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px;"><a href="#%E4%BA%94%EF%BC%8C%E8%A7%84%E5%88%99%E5%AF%B9%E6%AF%94" rel="nofollow">五，规则对比</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E3%80%87%EF%BC%8C%E5%89%8D%E8%A8%80">〇，前言</h2> 
<p>因为是一边设计一边写代码一边写博客，所以本文的中间代码很多都不是最新版本，</p> 
<p>代码以最终完整版为准。</p> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1">一，数据建模</h2> 
<h3 id="1%EF%BC%8C%E5%90%8D%E8%AF%8D%E6%BE%84%E6%B8%85">1，名词澄清</h3> 
<p>一个玩家有21个块，每个块由1-5个格子组成。</p> 
<h3 id="2%EF%BC%8C%E5%9D%97%E7%9A%84%E8%A1%A8%E7%A4%BA">2，块的表示</h3> 
<p>对每个块，用最多5个点把每个格子的坐标存起来</p> 
<pre><code class="language-cpp">typedef struct Point
{
    int x,y;
}Point;

typedef struct Node
{
    int num;
    Point p[5];
}Node;</code></pre> 
<p>那么，如何建立坐标系呢？</p> 
<p>对每个块拓展为它的凸包，并把最左上角的快设为（0,0）那么所有格子的坐标都是2个非负整数组成。</p> 
<p>实际上，除了十字交叉的块之外，其他20个块都可以适当的旋转和翻转，使得它的凸包的最左上角的点上有一个格子。</p> 
<pre><code class="language-cpp">int num[]={5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,3,5,4,3,2,1};
int matrix[]={
        0,0,0,1,0,2,1,1,2,1,
        0,0,1,0,1,1,1,2,2,1,
        0,0,1,0,1,1,1,2,2,2,
        0,1,1,0,1,1,1,2,2,1,
        0,0,0,1,1,1,1,2,2,2,
        0,0,0,1,0,2,1,2,2,2,
        0,0,0,1,0,2,1,2,1,3,
        0,0,0,1,0,2,0,3,1,2,
        0,0,0,1,0,2,0,3,1,3,
        0,0,0,1,0,2,1,0,1,2,
        0,0,0,1,0,2,1,0,1,1,
        0,0,0,1,1,0,1,1,
        0,0,0,1,0,2,1,0,
        0,0,0,1,1,1,1,2,
        0,0,0,1,0,2,1,1,
        0,0,0,1,1,0,
        0,0,0,1,0,2,0,3,0,4,
        0,0,0,1,0,2,0,3,
        0,0,0,1,0,2,
        0,0,0,1,
        0,0,
};</code></pre> 
<p>对应代码，有20行都是0,0开头，只有一行不是。</p> 
<h3 id="3%EF%BC%8C%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3，块的初始化</h3> 
<pre><code class="language-cpp">void init()
{
    int p=0;
    for(int i=0;i&lt;21;i++){
        node[i].num=num[i];
        for(int j=0;j&lt;num[i];j++)node[i].p[j]={matrix[p],matrix[p+1]},p+=2;
    }
}</code></pre> 
<h3 id="4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%95%B0%E6%8D%AE">4，玩家数据</h3> 
<pre><code class="language-cpp">typedef struct Node
{
    int id;
    int num;
    Point p[5];
    bool flag; //=1表示手里还有，=0表示已经用掉了
}Node;

Node node[4][21]; //四个玩家
</code></pre> 
<h3 id="5%EF%BC%8C%E7%8E%A9%E5%AE%B6%E5%88%9D%E5%A7%8B%E5%8C%96">5，玩家初始化</h3> 
<pre><code class="language-cpp">void initNode(Node* node)
{
    int p=0;
    for(int i=0;i&lt;21;i++){
        node[i].id=i,node[i].num=num[i],node[i].flag=1;
        for(int j=0;j&lt;num[i];j++)node[i].p[j]={matrix[p],matrix[p+1]},p+=2;
    }
}

void init()
{
    for(int i=0;i&lt;4;i++)initNode(node[i]);
}</code></pre> 
<p></p> 
<h2 id="%E4%BA%8C%EF%BC%8C%E7%95%8C%E9%9D%A2">二，界面</h2> 
<h3 id="1%EF%BC%8C%E6%96%B9%E6%A0%BC%E8%BE%93%E5%87%BA">1，方格输出</h3> 
<p>只输出当前玩家的所有块，每5个一行</p> 
<pre><code class="language-cpp">void outNode(int num,Node node[])
{
    int x[3][30];
    for(int j=0;j&lt;3;j++)for(int k=0;k&lt;30;k++)x[j][k]=0;
    for(int i=0;i&lt;num;i++){
        for(int j=0;j&lt;node[i].num;j++)x[node[i].p[j].x][node[i].p[j].y+i*6]=1;
    }
    for(int i=0;i&lt;num;i++)cout&lt;&lt;setw(2)&lt;&lt;node[i].id&lt;&lt;"    ";
    cout&lt;&lt;endl;
    for(int j=0;j&lt;3;j++) {
        for (int k = 0; k &lt; 30; k++) {
            if (x[j][k])cout &lt;&lt; "Y";
            else cout &lt;&lt; " ";
        }
        cout&lt;&lt;endl;
    }
    cout&lt;&lt;endl;
}

void outNode(Node* node)
{
    int s=0;
    Node nod[5];
    for(int i=0;i&lt;21;i++){
        if(node[i].flag==0)continue;
        nod[s++]=node[i];
        if(s==5){
            s=0;
            outNode(5,nod);
        }
    }
    if(s)outNode(s,nod);
}</code></pre> 
<p>运行：</p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/11/2e/sR7kXvth_o.png" width="273"></p> 
<h3 id="2%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2">2，游戏界面</h3> 
<p>复用我五子棋的界面程序 <a href="https://blog.csdn.net/nameofcsdn/article/details/78640511" title="五子棋人机对战完整代码_nameofcsdn的博客-CSDN博客_五子棋代码">五子棋人机对战完整代码_nameofcsdn的博客-CSDN博客_五子棋代码</a></p> 
<pre><code class="language-cpp">void out(int i, int j)
{
    if (p[i][j])cout&lt;&lt; col[p[i][j]];
    else if (i == 1)
    {
        if (j == 1)printf("┏");
        else if (j == N)printf("┓");
        else printf("┯");
    }
    else if (i == N)
    {
        if (j == 1)printf("┗");
        else if (j == N)printf("┛");
        else printf("┷");
    }
    else if (j == 1)printf("┠");
    else if (j == N)printf("┨");
    else printf("┼");
}

void DrawBoard(int turn)//画棋盘
{
    system("cls");
    int row = 0, col = 0;
    char alpha = 'A';
    printf("\n\n\n     ");
    for (col = 1; col &lt;= N; col++)printf("%c ", alpha++);
    for (row = 1; row &lt;= N; row++) {
        printf("\n   %2d", row);
        for (col = 1; col &lt;= N; col++) {
            out(row, col);
        }
        printf("%d", row);
    }
    cout &lt;&lt; endl;
    outNode(node[turn]);
}</code></pre> 
<p></p> 
<h2 id="%E4%B8%89%EF%BC%8C%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99">三，游戏规则</h2> 
<h3 id="1%EF%BC%8C%E7%BF%BB%E8%BD%AC%E5%92%8C%E6%97%8B%E8%BD%AC">1，翻转和旋转</h3> 
<p>每个块都可以翻转、旋转</p> 
<pre><code class="language-cpp">void reverse(Node &amp;node)//翻转块
{
    for(int i=0;i&lt;node.num;i++){
        int tmp=node.p[i].x;
        node.p[i].x=node.p[i].y,node.p[i].y=tmp;
    }
}
void rotate(Node &amp;node)//旋转块
{
    for(int i=0;i&lt;node.num;i++){
        int tmp=4-node.p[i].x;
        node.p[i].x=node.p[i].y,node.p[i].y=tmp;
    }
}
void rotate(Node &amp;node,int n)//旋转块
{
    if(n&lt;=0||n&gt;3)return;
    while(n--)rotate(node);
}</code></pre> 
<p>考虑到旋转之后的样子，把输出块的代码改了</p> 
<pre><code class="language-cpp">void outNode(int num,Node node[])
{
    int x[5][30];
    for(int j=0;j&lt;5;j++)for(int k=0;k&lt;30;k++)x[j][k]=0;
    for(int i=0;i&lt;num;i++){
        for(int j=0;j&lt;node[i].num;j++)x[node[i].p[j].x][node[i].p[j].y+i*6]=1;
    }
    for(int i=0;i&lt;num;i++)cout&lt;&lt;setw(2)&lt;&lt;node[i].id&lt;&lt;"    ";
    cout&lt;&lt;endl;
    for(int j=0;j&lt;5;j++) {
        for (int k = 0; k &lt; 30; k++) {
            if (x[j][k])cout &lt;&lt; "Y";
            else if(k%6==5)cout&lt;&lt;" ";
            else cout&lt;&lt;".";
        }
        cout&lt;&lt;endl;
    }
    cout&lt;&lt;endl;
}</code></pre> 
<p><img alt="" height="657" src="https://images2.imgbox.com/fd/a0/7MoOoX3E_o.png" width="271"></p> 
<h3 id="2%EF%BC%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E3%80%81%E7%BB%93%E6%9D%9F%E6%8E%A7%E5%88%B6">2，核心逻辑、结束控制</h3> 
<pre><code class="language-cpp">int isEnd[4];//=0表示还在继续，=1表示玩家已经不能再放了

bool end()
{
    return isEnd[0]+isEnd[1]+isEnd[2]+isEnd[3]==4;
}</code></pre> 
<p>采用简单粗暴的方式，让玩家自己上报已经不能放了这个信号。</p> 
<pre><code class="language-cpp">bool play(int turn)
{
    DrawBoard();
    cout&lt;&lt;"输入操作类型：0结束，1翻转，2旋转，3放方格";
    int op;
    CIN(op);
    if(op&lt;0||op&gt;3)return false;
    //
}</code></pre> 
<h3 id="3%EF%BC%8C%E4%B8%BB%E6%8E%A7%E7%A8%8B%E5%BA%8F">3，主控程序</h3> 
<pre><code class="language-cpp">int main() {
    init();
    turn=-1;
    while(!end()){
        turn=(turn+1)%4;
        if(isEnd[turn])continue;
        while(!play(turn));
    }
    return 0;
}</code></pre> 
<h3 id="4%EF%BC%8C%E7%8E%A9%E5%AE%B6%E6%93%8D%E4%BD%9C">4，玩家操作</h3> 
<pre><code class="language-cpp">bool op0(int turn)
{
    isEnd[turn]=0;
    return true;
}

bool op1(int turn,int id)
{
    reverse(node[turn][id]);
    return false;
}

bool op2(int turn,int id)
{
    cout&lt;&lt;"输入顺时针旋转次数1-3";
    int num;
    CIN(num);
    rotate(node[turn][id],num);
    return false;
}

bool check(int turn,int id,int r,int c)
{
    return true; // 待更新，不更新也能玩
}
bool op3(int turn,int id)
{
    cout&lt;&lt;"输入最左上角的格子放入棋盘的坐标\n";
    int r,c;
    CIN2(r,c);
    if(!check(turn,id,r,c))return false;
    Node *pn=&amp;node[turn][id];
    for(int i=0;i&lt;pn-&gt;num;i++){
        p[r+pn-&gt;p[i].x][c+pn-&gt;p[i].y]=turn;
    }
    return true;
}</code></pre> 
<p>更新play函数：</p> 
<pre><code class="language-cpp">bool play(int turn)
{
    DrawBoard();
    cout &lt;&lt; "输入操作类型：0结束，1翻转方格，2旋转方格，3放方格";
    int op, id;
    CIN(op);
    if (op &lt; 0 || op&gt;3)return false;
    if (op == 0)return op0(turn);
    cout &lt;&lt; "输入要操作的方格编号";
    CIN(id);
    if (id &lt; 0 || id &gt;= 21)return false;
    if (op == 1)return op1(turn, id);
    if (op == 2)return op2(turn, id);
    if (op == 3)return op3(turn, id);
    return false;
}</code></pre> 
<p></p> 
<h2 id="%E5%9B%9B%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">四，完整代码</h2> 
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;windows.h&gt;
using namespace std;

typedef struct Point
{
    int x, y;
}Point;

typedef struct Node
{
    int id;
    int num;
    Point p[5];
    bool flag; //=1表示手里还有，=0表示已经用掉了
}Node;

Node node[4][21]; //四个玩家
int turn; //0-3,对应蓝黄红绿
string col[4] = { " B"," Y"," R"," G" }; //蓝黄红绿
char ccol[4] = { 'B','Y','R','G' };
const int N = 20;
int p[22][22];//棋盘是20*20
int isEnd[4];//=0表示还在继续，=1表示玩家已经不能再放了

int num[] = { 5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,3,5,4,3,2,1 };
int matrix[] = {
        0,0,0,1,0,2,1,1,2,1,
        0,0,1,0,1,1,1,2,2,1,
        0,0,1,0,1,1,1,2,2,2,
        0,1,1,0,1,1,1,2,2,1,
        0,0,0,1,1,1,1,2,2,2,
        0,0,0,1,0,2,1,2,2,2,
        0,0,0,1,0,2,1,2,1,3,
        0,0,0,1,0,2,0,3,1,2,
        0,0,0,1,0,2,0,3,1,3,
        0,0,0,1,0,2,1,0,1,2,
        0,0,0,1,0,2,1,0,1,1,
        0,0,0,1,1,0,1,1,
        0,0,0,1,0,2,1,0,
        0,0,0,1,1,1,1,2,
        0,0,0,1,0,2,1,1,
        0,0,0,1,1,0,
        0,0,0,1,0,2,0,3,0,4,
        0,0,0,1,0,2,0,3,
        0,0,0,1,0,2,
        0,0,0,1,
        0,0,
};

void initNode(Node* node)
{
    int p = 0;
    for (int i = 0; i &lt; 21; i++) {
        node[i].id = i, node[i].num = num[i], node[i].flag = 1;
        for (int j = 0; j &lt; num[i]; j++)node[i].p[j] = { matrix[p],matrix[p + 1] }, p += 2;
    }
}

void init()
{
    for (int i = 0; i &lt; 4; i++) {
        initNode(node[i]);
        isEnd[i] = 0;
    }
}

void outNode(int num, Node node[])
{
    int x[5][66];
    for (int j = 0; j &lt; 5; j++)for (int k = 0; k &lt; 66; k++)x[j][k] = 0;
    for (int i = 0; i &lt; num; i++) {
        for (int j = 0; j &lt; node[i].num; j++)x[node[i].p[j].x][node[i].p[j].y + i * 6] = 1;
    }
    for (int i = 0; i &lt; num; i++)cout &lt;&lt; setw(2) &lt;&lt; node[i].id &lt;&lt; "    ";
    cout &lt;&lt; endl;
    for (int j = 0; j &lt; 5; j++) {
        for (int k = 0; k &lt; 66; k++) {
            if (x[j][k])cout &lt;&lt; ccol[turn];
            else if (k % 6 == 5)cout &lt;&lt; " ";
            else cout &lt;&lt; ".";
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}

void outNode(Node* node)
{
    int s = 0;
    Node nod[11];
    for (int i = 0; i &lt; 21; i++) {
        if (node[i].flag == 0)continue;
        nod[s++] = node[i];
        if (s == 11) {
            outNode(s, nod);
            s = 0;
        }
    }
    if (s)outNode(s, nod);
}

void out(int i, int j)
{
    if (p[i][j])cout&lt;&lt;col[p[i][j]-1];
    else if (i == 1)
    {
        if (j == 1)printf("┏");
        else if (j == N)printf("┓");
        else printf("┯");
    }
    else if (i == N)
    {
        if (j == 1)printf("┗");
        else if (j == N)printf("┛");
        else printf("┷");
    }
    else if (j == 1)printf("┠");
    else if (j == N)printf("┨");
    else printf("┼");
}

void DrawBoard()//画棋盘
{
    system("cls");
    int row = 0, col = 0;
    char alpha = 'A';
    printf("     ");
    for (col = 1; col &lt;= N; col++)printf("%2d", col);
    for (row = 1; row &lt;= N; row++) {
        printf("\n   %2d", row);
        for (col = 1; col &lt;= N; col++) {
            out(row, col);
        }
        printf("%d", row);
    }
    printf("\n     ");
    for (col = 1; col &lt;= N; col++)printf("%2d", col);
    cout &lt;&lt; endl;
    outNode(node[turn]);
}

void reverse(Node&amp; node)//翻转块
{
    for (int i = 0; i &lt; node.num; i++) {
        int tmp = node.p[i].x;
        node.p[i].x = node.p[i].y, node.p[i].y = tmp;
    }
}
void rotate(Node&amp; node)//旋转块
{
    for (int i = 0; i &lt; node.num; i++) {
        int tmp = 4 - node.p[i].x;
        node.p[i].x = node.p[i].y, node.p[i].y = tmp;
    }
}
void rotate(Node&amp; node, int n)//旋转块
{
    if (n &lt;= 0 || n &gt; 3)return;
    while (n--)rotate(node);
}


#define CIN(x) while (!(cin &gt;&gt; x)) { \
        cin.clear();      \
        cin.ignore();     \
    }
#define CIN2(x, y) CIN(x)CIN(y)
#define CIN3(x, y, z) CIN(x)CIN(y)CIN(z)

bool op0()
{
    isEnd[turn] = 0;
    return true;
}

bool op1(int id)
{
    reverse(node[turn][id]);
    return false;
}

bool op2(int id)
{
    cout &lt;&lt; "输入顺时针旋转次数1-3\n";
    int num;
    CIN(num);
    rotate(node[turn][id], num);
    return false;
}

bool check(int id, int r, int c, Node* pn)
{
    //if (r &lt; 1 || r&gt;20 || c &lt; 1 || c&gt;20)return false;
    for (int i = 0; i &lt; pn-&gt;num; i++) {
        int tr = r + pn-&gt;p[i].x,tc= c + pn-&gt;p[i].y;
        if (tr &lt; 1 || tr&gt;20 || tc &lt; 1 || tc&gt;20 || p[tr][tc])return false;
    }
    return true;
}

bool op3(int id)
{
    cout &lt;&lt; "输入最左上角的格子放入棋盘的坐标(行，列)\n";
    int r, c;
    CIN2(r, c);
    Node* pn = &amp;node[turn][id];
    if (!check(id, r, c, pn))return false;
    for (int i = 0; i &lt; pn-&gt;num; i++) {
        p[r + pn-&gt;p[i].x][c + pn-&gt;p[i].y] = turn + 1;
    }
    pn-&gt;flag = 0;
    return true;
}

bool play()
{
    DrawBoard();
    cout &lt;&lt; "输入操作类型：0结束，1翻转方格，2旋转方格，3放方格\n";
    int op, id;
    CIN(op);
    if (op &lt; 0 || op&gt;3)return false;
    if (op == 0)return op0();
    cout &lt;&lt; "输入要操作的方格编号\n";
    CIN(id);
    if (id &lt; 0 || id &gt;= 21)return false;
    if (op == 1)return op1(id);
    if (op == 2)return op2(id);
    if (op == 3)return op3(id);
    return false;
}

bool end()
{
    return isEnd[0] + isEnd[1] + isEnd[2] + isEnd[3] == 4;
}

void p415()
{
    cout &lt;&lt; endl;
    cout &lt;&lt; "  .....      ..  \n"
            "    .       .  .\n"
            "    .       .  . \n"
            "    .        ..  \n";
    cout &lt;&lt; "\n\n\n";
    cout &lt;&lt; "    |        /  | \n"
            "  / | \\     / —|——\n"
            " /  |  \\   /——|———\n"
            "   \\|           | \n";
    Sleep(5000);
}

int main() {
    p415();
    init();
    turn = -1;
    while (!end()) {
        turn = (turn + 1) % 4;
        if (isEnd[turn])continue;
        while (!play());
    }
    return 0;
}
</code></pre> 
<p><img alt="" height="708" src="https://images2.imgbox.com/36/59/un177A3P_o.png" width="550"></p> 
<h2 id="%E4%BA%94%EF%BC%8C%E8%A7%84%E5%88%99%E5%AF%B9%E6%AF%94">五，规则对比</h2> 
<p>这个程序比较简陋，对于用户输入的放方格的位置，我做的校验是保证放的格子都没有超出棋盘位置，也不会发生覆盖。</p> 
<p>但是没有校验放的位置必须和同色格子点邻，不能边邻，第一个放的必须包含最角落的那个格子。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f905c13835cea735bc4dc7fb6bc856f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【云原生】k8s的pod基本概念</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6eea291e4783c44c1476b1c0e8adc9cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">css 修改浏览器滚动条样式（火狐Firefox，谷歌google）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>