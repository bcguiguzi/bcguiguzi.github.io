<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c#委托、lambda、事件 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c#委托、lambda、事件" />
<meta property="og:description" content="Lambda Lambda表达式是一种匿名函数，Lambda表达式通常以箭头“=&gt;”分隔左侧的输入和右侧的输出。
(parameter_list) =&gt; { statement_block } parameter_list 是由一个或多个参数组成的逗号分隔列表，每个参数都包括类型和名称，可以为空。
如果只有一个参数，只写参数名即可，不用圆括号。
Func&lt;int, int&gt; add = y =&gt; 1 &#43; y;
如果是多个参数，把参数放在圆括号内。
Func&lt;int, int,int&gt; add = (x,y) =&gt; x &#43; y;
statement_block 是Lambda表达式的主体。statement_block表示一段代码块，它可以包含多个语句，多个语句使用大括号包裹。
如果Lambda表达式只有一句语句，statement_block不需要花括号和return语句。
Func&lt;int, int,int&gt; add = (x,y) =&gt; x &#43; y;
如果是含有多条语句，必须加上花括号和return语句。
Func&lt;int, int,int&gt; add = (x,y) =&gt;
{
X = x&#43;1;
Y= y&#43;1;
Return x&#43;y;
} 常用的方法
Where Where方法是IEnumerable&lt;T&gt;接口的扩展方法，它筛选序列中满足指定条件的元素，返回满足条件的元素序列.
List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/00c5f1e8476203f55a69e97763390595/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-06T10:28:13+08:00" />
<meta property="article:modified_time" content="2024-03-06T10:28:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c#委托、lambda、事件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <h6 style="text-align:justify;"><strong>Lambda</strong></h6> 
 <p style="margin-left:0;text-align:left;">Lambda表达式是一种<strong><span style="color:#ff0000;"><strong>匿名函数</strong></span></strong>，Lambda表达式通常以箭头<strong><span style="color:#ff0000;"><strong>“=&gt;</strong></span></strong>”分隔左侧的输入和右侧的输出。</p> 
 <p style="margin-left:0;text-align:left;"><strong><strong>(parameter_list) =&gt; { statement_block } </strong></strong></p> 
 <p style="text-align:justify;"><strong>parameter_list </strong></p> 
 <p style="margin-left:0;text-align:left;">是由一个或多个参数组成的逗号分隔列表，每个参数都包括类型和名称，可以为空。</p> 
 <p style="margin-left:0;text-align:left;">如果只有一个参数，只写参数名即可，不用圆括号。</p> 
 <p style="margin-left:0;text-align:left;">Func&lt;int, int&gt; add = y =&gt; 1 + y;</p> 
 <p style="margin-left:0;text-align:left;">如果是多个参数，把参数放在圆括号内。</p> 
 <p style="margin-left:0;text-align:left;">Func&lt;int, int,int&gt; add = (x,y) =&gt; x + y;</p> 
 <p style="text-align:justify;"><strong>statement_block </strong></p> 
 <p style="margin-left:0;text-align:left;">是Lambda表达式的主体。statement_block表示一段代码块，它可以包含多个语句，多个语句使用大括号包裹。</p> 
 <p style="margin-left:0;text-align:left;">如果Lambda表达式只有一句语句，statement_block不需要花括号和return语句。</p> 
 <p style="margin-left:0;text-align:left;">Func&lt;int, int,int&gt; add = (x,y) =&gt; x + y;</p> 
 <p style="margin-left:0;text-align:left;">如果是含有多条语句，必须加上花括号和return语句。</p> 
 <p style="margin-left:0;text-align:left;">Func&lt;int, int,int&gt; add = (x,y) =&gt;</p> 
 <p style="margin-left:0;text-align:left;">{<!-- --></p> 
 <p style="margin-left:0;text-align:left;">   X = x+1;</p> 
 <p style="margin-left:0;text-align:left;">   Y= y+1;</p> 
 <p style="margin-left:0;text-align:left;">   Return x+y;</p> 
 <p style="margin-left:0;text-align:left;">} </p> 
 <p style="margin-left:0;text-align:left;"></p> 
 <p style="margin-left:0;text-align:left;"><strong><strong>常用的方法</strong></strong></p> 
 <ol><li style="text-align:left;">Where</li></ol> 
 <p style="margin-left:0;text-align:left;">Where方法是IEnumerable&lt;T&gt;接口的扩展方法，它筛选序列中满足指定条件的元素，返回满足条件的元素序列.</p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">int</span><span style="color:#000000;">&gt; numbers = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">int</span><span style="color:#000000;">&gt; { 1, 2, 3, 4, 5 };</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;">var</span><span style="color:#000000;"> oddNumbers = numbers.Where(x =&gt; x % 2 != 0);</span></p> 
 <ol><li style="text-align:left;">Select</li></ol> 
 <p style="margin-left:0;text-align:left;">它将序列中的每个元素投影到新的形式，返回投影后的元素序列.</p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">List&lt;</span><span style="color:#0000ff;">int</span><span style="color:#000000;">&gt; numbers = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">int</span><span style="color:#000000;">&gt; { 1, 2, 3, 4, 5 };</span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#0000ff;">var</span><span style="color:#000000;"> squaredNumbers = numbers.Select(x =&gt; x * x);</span></p> 
 <ol><li style="text-align:left;">Orderby</li></ol> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">按照指定的键对序列中的元素进行排序</span><span style="color:#000000;">.</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">List&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; words = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; { </span><span style="color:#a31515;">"apple"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"banana"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"cherry"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"date"</span><span style="color:#000000;"> };</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;">var</span><span style="color:#000000;"> sortedWords = words.OrderBy(x =&gt; x.Length);</span></p> 
 <ol><li style="text-align:left;">GroupBy</li></ol> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">根据指定的键对序列中的元素进行分组</span><span style="color:#000000;">.</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; words = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> List&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; { </span><span style="color:#a31515;">"apple"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"banana"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"cherry"</span><span style="color:#000000;">, </span><span style="color:#a31515;">"date"</span><span style="color:#000000;"> };</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;">var</span><span style="color:#000000;"> groupedWords = words.GroupBy(x =&gt; x[0]);</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:left;"><strong><strong>Lambda表达式中的闭包</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">闭包是指一个函数能够访问并操作在它的外部作用域中定义的变量。在Lambda表达式中，可以使用闭包来访问外部作用域中的变量.</p> 
 <p style="margin-left:0;text-align:left;">int x = 5;</p> 
 <p style="margin-left:0;text-align:left;">Func&lt;int, int&gt; add = y =&gt; x + y;</p> 
 <p style="margin-left:0;text-align:left;">Console.WriteLine(add(3));</p> 
</div> 
<p></p> 
<div> 
 <h6 style="text-align:justify;"><strong>委托</strong></h6> 
 <ol><li style="text-align:justify;">委托是一种<span style="color:#ff0000;">引用</span>类型，表示对具有特定参数列表和返回类型的方法的引用。</li><li style="text-align:justify;">在实例化委托时，你可以将其实例与任何具有兼容签名和返回类型的方法相关联。 委托可以链接在一起，一次性调用多个方法</li><li style="text-align:justify;">你可以通过委托实例调用方法。</li><li style="text-align:justify;">委托用于将方法作为参数传递给其他方法，可用于定义回调方法</li><li style="text-align:justify;">可将任何可访问类或结构中与委托类型匹配的任何方法分配给委托。该方法可以是静态方法，也可以是实例方法。 此灵活性意味着你可以通过编程方式来更改方法调用，还可以向现有类中插入新代码。</li><li style="text-align:justify;"> 委托类型派生自 .NET 中的 Delegate 类。 委托类型是密封的，它们不能派生自 Delegate，也不能从其派生出自定义类</li></ol> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;">简单地说：委托类似<strong><span style="color:#ff0000;"><strong>c++的函数指针。</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="background-color:transparent;text-align:justify;"><strong>如何使用委托</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;">委托是一种引用类型，虽然在定义委托时与方法有些相似，但不能将其称为方法。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">委托在使用时遵循三步走的原则，即<strong><span style="color:#ff0000;"><strong>定义声明委托、实例化委托以及调用委托</strong></span></strong>。</p> 
 <p style="margin-left:.0001pt;text-align:left;">     <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> <span style="color:#2b91af;">ShowTest</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">delegate</span> <span style="color:#0000ff;">void</span> <span style="color:#2b91af;">ShowDelegate</span><span style="color:#000000;">(</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span><span style="color:#000000;"> Action&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; action;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> Show(</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Console.WriteLine(strText);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">         <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> test() </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            ShowDelegate showDelegate1 = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> ShowDelegate(Show);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            ShowDelegate showDelegate2 = Show;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            ShowDelegate showDelegate3 = </span><span style="color:#0000ff;">delegate</span><span style="color:#000000;"> (</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                Console.WriteLine(strText);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            };</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">             ShowDelegate showDelegate4 = (</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText) =&gt; { Console.WriteLine(strText); };</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#0000ff;">string</span><span style="color:#000000;"> Text = </span><span style="color:#a31515;">"hello"</span><span style="color:#000000;">;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            showDelegate1(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            showDelegate2.Invoke(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action = Show;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">    }</span></p> 
 <p style="text-align:justify;"><strong>声明委托</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>修饰符  delegate  返回值类型  委托名 ( 参数列表 );</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">如：public delegate void ShowDelegate ();</p> 
 <p style="margin-left:.0001pt;text-align:justify;">在命名空间内，但不在类内</p> 
 <p style="text-align:justify;"><strong>实例化委托</strong></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#ff0000;">方式1：</span><span style="color:#ff0000;">通过new 创建委托实例</span></p> 
 <p style="margin-left:0;text-align:left;">必须<span style="color:#ff0000;">传入一个方法作为参数</span>，否则会报错因为委托内部的构造函数，需求传递一个方法作为参数。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>委托名  委托对象名 = new 委托名 ( 方法名 );</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">委托中传递的方法名既可以是<strong><strong>静态方法</strong></strong>的名称，也可以是<strong><strong>实例方法</strong></strong>的名称。需要注意的是，在委托中所写的方法名必须与委托定义时的返回值类型和参数列表相同。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">ShowDelegate showDelegate1 = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> ShowDelegate(Show);</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>方式2：使用赋值的方式</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">ShowDelegate showDelegate2 = Show;</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>方式3：匿名委托</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">ShowDelegate showDelegate3 = </span><span style="color:#0000ff;">delegate</span><span style="color:#000000;"> (</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">{<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">     Console.WriteLine(strText);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">};</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;"><strong>方式4：Lambda</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">ShowDelegate showDelegate4 = (</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText) =&gt; { Console.WriteLine(strText); };</span></p> 
 <p style="text-align:justify;"><strong>调用委托</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>方式1：直接调用委托的变量 </strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;"> showDelegate1(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>方式2：invoke()</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;"> showDelegate2.Invoke(Text)</span><span style="color:#000000;">;</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="text-align:justify;"><strong>匿名委托</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">匿名方法的意义在于：快速方便的实例化委托，不用定义具体的方法来关联委托，就是临时定义个方法（处理逻辑）与委托相关联</span><span style="color:#000000;">。</span>只是在<span style="color:#ff0000;">实例化委托按照</span>下面的格式处理。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">委托类型 变量名 = delegate( 形参 ) { 逻辑处理语句 };</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">           Func&lt;string, string&gt; dele = delegate (string strpa)</p> 
 <p style="margin-left:.0001pt;text-align:justify;">             {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">                 string strq = "sa";</p> 
 <p style="margin-left:.0001pt;text-align:justify;">                 return strq;</p> 
 <p style="margin-left:.0001pt;text-align:justify;">             };</p> 
 <p style="margin-left:.0001pt;text-align:justify;">            dele(str);</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">缺点：</span><span style="color:#000000;">不能在其他地方被调用，即不具有复用性。 而且，匿名方法会将自动形成闭包。当一个函数（这里称为外部函数）包含对另一个函数（内部函数）的调用时，或内部函数使用了外部函数的变量时都会形成闭包</span><span style="color:#000000;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="text-align:justify;"><strong>闭包</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;"> 在C#中我们可以使用Lambda来实现闭包</span><span style="color:#000000;">，</span><span style="color:#000000;">闭包本质是一个对象(编译后）,但使用上它和方法一致。使用闭包我们就可以实现拥有私有状态的函数!</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">定义</span><span style="color:#000000;">：</span><span style="color:#000000;">我们把在Lambda表达式(或匿名方法)中所引用的外部变量称为</span><span style="color:#ff0000;">捕获变量</span><span style="color:#000000;">。而捕获变量的表达式就称为</span><span style="color:#ff0000;">闭包</span><span style="color:#000000;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">捕获变量</span><span style="color:#000000;">：</span><span style="color:#000000;">捕获的变量会</span><span style="color:#ff0000;">在真正调用委托时“赋值”</span><span style="color:#000000;">，而</span><span style="color:#ff0000;">不是在捕获时“赋值”</span><span style="color:#000000;">，即总是使用捕获变量的最新的值。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">作用：</span><span style="color:#000000;">内层的函数可以引用包含在它外层的函数的变量</span><span style="color:#000000;">，即使外层函数的执行已经终止。</span><em> </em></p> 
 <p style="margin-left:.0001pt;text-align:left;">    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> <span style="color:#2b91af;">ShowTest</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span><span style="color:#000000;"> Action&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; action1;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#2b91af;">ShowTest</span><span style="color:#000000;">()</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#0000ff;">string</span><span style="color:#000000;"> tt = </span><span style="color:#a31515;">"qq"</span><span style="color:#000000;">;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action1 = (</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> str) =&gt; { Console.WriteLine(tt + str); };</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> test() </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#0000ff;">string</span><span style="color:#000000;"> Text = </span><span style="color:#a31515;">"hello"</span><span style="color:#000000;">;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action1(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="text-align:justify;"><strong>泛型委托</strong></h6> 
 <p style="margin-left:0;text-align:left;">由于单独定义委托和事件，比较繁琐，而且比较冗余，因此C#2.0提供了<strong><strong>Action</strong></strong> 和<strong><strong>Func</strong></strong>两个泛型委托，不用单独申明，拿来就可以用。</p> 
 <p style="margin-left:0;text-align:left;"></p> 
 <p style="text-align:justify;"><strong>Action&lt;T&gt;</strong></p> 
 <p style="margin-left:0;text-align:left;">（1）Action 表示<span style="color:#ff0000;">无参</span>，<span style="color:#ff0000;">无返回值</span>的委托</p> 
 <p style="margin-left:0;text-align:left;">（2）Action&lt;int,string&gt; 表示<span style="color:#ff0000;">有参，无返回值</span>的泛型委托，最多可入参16个</p> 
 <p style="margin-left:0;text-align:left;">（3）使用Action 就可以囊括所有无返回值委托，可以说Action事对无返回值委托的进一步包装</p> 
 <p style="margin-left:.0001pt;text-align:left;">     <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> <span style="color:#2b91af;">ShowTest</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span><span style="color:#000000;"> Action&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt; action;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> Show(</span><span style="color:#0000ff;">string</span><span style="color:#000000;"> strText)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Console.WriteLine(strText);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> test() </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action = Show;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">//或者 通过new 创建委托实例 委托名  委托对象名 = new 委托名 ( 方法名 );</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">action </span><span style="color:#000000;">= </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> Action&lt;</span><span style="color:#0000ff;">string</span><span style="color:#000000;">&gt;(Show)</span><span style="color:#000000;">;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            action(Text);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">}</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="text-align:justify;"><a name="t28"></a><strong>Func&lt;T&gt;</strong></p> 
 <p style="margin-left:0;text-align:left;">（1）Func 表示<span style="color:#ff0000;">有返回值</span>的委托（必须有返回值）</p> 
 <p style="margin-left:0;text-align:left;">（2）Func可以无参数，也可以有参数，最多16个参数，<strong><span style="color:#ff0000;"><strong>最后一个表示返回值且只有一个</strong></span></strong></p> 
 <p style="margin-left:0;text-align:left;">（3）使用方法同delegate,Func不过是对所有的有返回值的数据进行了一个包装</p> 
 <p style="margin-left:.0001pt;text-align:left;">    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> <span style="color:#2b91af;">ShowTest</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span><span style="color:#000000;"> Func&lt;</span><span style="color:#0000ff;">int</span><span style="color:#000000;">, </span><span style="color:#0000ff;">int</span><span style="color:#000000;">,</span><span style="color:#0000ff;">int</span><span style="color:#000000;">&gt; addfunc;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">int</span><span style="color:#000000;"> add(</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> a,</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> b)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#0000ff;">return</span><span style="color:#000000;"> a + b;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> test() </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            addfunc = add;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#0000ff;">int</span><span style="color:#000000;"> nRet = addfunc(1, 2);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;">    }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="text-align:justify;"><strong>多播委托</strong></h6> 
 <p style="margin-left:0;text-align:left;">通过<strong><span style="color:#ff0000;"><strong>+=</strong></span></strong>绑定<strong><span style="color:#ff0000;"><strong>多个方法</strong></span></strong>到这个委托，从而形成委托链。执行委托的时候，按照添加方法的顺序，依次去执行方法</p> 
 <p style="margin-left:0;text-align:left;">注意：</p> 
 <p style="margin-left:0;text-align:left;">1.action.BeginInvoke();会开启一个新的线程去执行委托，注册有多个方法的委托，不能使用BeginInvoke。</p> 
 <p style="margin-left:0;text-align:left;">2.注册有多个方法的委托想要开启新线程去执行委托，可以通过action.GetInvocationList()获取到所有的委托，然后循环，每个方法执行的时候可以BeginInvoke</p> 
 <p style="margin-left:0;text-align:left;">3.使用多播委托的时候可能会遇到一个问题，就是委托链的第一个方法报错了，导致后面的注册的方法都无法调用。解决办法：使用<span style="color:#ff0000;">GetInvocationList </span>按照调用顺序返回此多播委托的调用列表。</p> 
 <p style="margin-left:.0001pt;text-align:left;">   <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> <span style="color:#2b91af;">ShowTest</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">    {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">delegate</span> <span style="color:#0000ff;">void</span> <span style="color:#2b91af;">BuySomethingDelegate</span><span style="color:#000000;">();</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> BuyWater()</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Console.WriteLine(</span><span style="color:#a31515;">"买水！"</span><span style="color:#000000;">);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> BuyKFC()</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Console.WriteLine(</span><span style="color:#a31515;">"买肯德基"</span><span style="color:#000000;">);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> BuyHotDog()</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Console.WriteLine(</span><span style="color:#a31515;">"买热狗"</span><span style="color:#000000;">);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> test() </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">        {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            BuySomethingDelegate bsd = </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> BuySomethingDelegate(BuyWater);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            bsd += BuyHotDog;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            bsd += BuyKFC;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            bsd -= BuyHotDog;</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            Delegate[] delegateArr = bsd.GetInvocationList();</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#0000ff;">foreach</span><span style="color:#000000;"> (BuySomethingDelegate item </span><span style="color:#0000ff;">in</span><span style="color:#000000;"> delegateArr)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">            {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;">                <span style="color:#0000ff;">try</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                    item.Invoke();</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">                <span style="color:#0000ff;">catch</span><span style="color:#000000;"> (Exception)</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                    Console.WriteLine(</span><span style="color:#a31515;">$"</span><span style="color:#000000;">{item.Method.Name}</span><span style="color:#a31515;">方法报错了！"</span><span style="color:#000000;">);</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">                }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">            <span style="color:#000000;"> }</span></p> 
 <p style="margin-left:.0001pt;text-align:left;">        <span style="color:#000000;"> }</span></p> 
 <p style="margin-left:0;text-align:left;">     <span style="color:#000000;">}</span></p> 
 <p style="margin-left:0;text-align:left;"></p> 
 <p style="margin-left:0;text-align:left;"></p> 
 <p style="margin-left:0;text-align:left;">延伸：</p> 
 <h6 style="text-align:justify;"><strong>Invoke</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;">Invoke的本质只是一个方法，方法一定是要通过对象来调用的。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">Control的Invoke、Delegate的Invoke</p> 
 <p style="margin-left:.0001pt;text-align:justify;">也就是说Invoke前面要么是一个控件，要么是一个委托对象。</p> 
 <h6 style="text-align:justify;"><strong>Control的Invoke</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;">public object Invoke(Delegate method);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">public object Invoke(Delegate method, params object[] args);</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">Control的Invoke一般用于解决</span><strong><span style="background-color:#ffffff;"><strong>跨线程</strong></span></strong><span style="background-color:#ffffff;">访问的问题。</span><span style="background-color:#ffffff;">即在子线程中让主线程的控件调用</span><span style="background-color:#ffffff;">Invoke</span><span style="background-color:#ffffff;">函数，从而操作主线程的UI空间。</span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;">使用Invoke完成一个委托方法的封送，就类似于使用</span><strong><span style="background-color:#ffffff;"><strong>SendMessage</strong></span></strong><strong><span style="background-color:#ffffff;"><strong>，</strong></span></strong><strong><span style="background-color:#ffffff;"><strong>会</strong></span></strong><strong><span style="background-color:#ffffff;"><strong>阻塞</strong></span></strong><strong><span style="background-color:#ffffff;"><strong>。</strong></span></strong></p> 
 <p style="text-align:justify;"><a href="https://so.csdn.net/so/search?q=Delegate&amp;spm=1001.2101.3001.7020" title="Delegate">Delegate</a><strong>的Invoke</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">目的作用就是<strong><strong>执行委托。</strong></strong>Delegate的Invoke其实就是从线程池中<strong><strong>调用委托方法执行</strong></strong>，<strong><strong>Invoke是同步</strong></strong>的方式，会卡住调用它的UI线程。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="background-color:transparent;text-align:justify;"><strong>BeginInvoke</strong></h6> 
 <p style="margin-left:0;text-align:left;">使用BeginInvoke方法封送一个委托方法，类似于使用<strong><strong>PostMessage</strong></strong>进行通信，这是一个<strong><strong>异步</strong></strong>方法。</p> 
 <h6 style="background-color:transparent;text-align:justify;"><strong>Control的BeginInvoke</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;">Control类上的异步调用BeginInvoke并没有开辟新的线程完成委托任务，而是让界面控件的所属线程完成委托任务的。（还是在同一线程执行）</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <h6 style="background-color:transparent;text-align:justify;"><strong>Delegate的BeginInvoke</strong></h6> 
 <p style="margin-left:.0001pt;text-align:justify;">Delegate.BeginInvoke方法是从ThreadPool中取出的一个线程来执行这个方法，以获得异步的执行效果。（不同的线程执行）.</p> 
 <p>BeginInvoke的参数包含如下两个部分</p> 
 <ul><li>引用方法的参数</li><li>CallBack参数和State参数</li></ul> 
 <p style="margin-left:0;text-align:left;">BeginInvoke 返回给调用线程一个实现IAsyncResult接口的对象的引用.这个接口引用包含了在线程池线程中运行的异步方法的状态。可以判断这个状态来确定异步方法是否结束。</p> 
 <p><code>        public int method3(int a,int b)<br>         {<!-- --><br>             int r = a + b;<br>             Thread.Sleep(1000);<br>             return r;<br>         }</code></p> 
 <p><code>        private delegate int NewTaskDelegate(int a,int b);</code></p> 
 <p><code>        NewTaskDelegate task = method3;<br>         IAsyncResult asyncResult = task.BeginInvoke(2,3,null,null);</code></p> 
 <p><code>        int re = task.EndInvoke(asyncResult);</code></p> 
 <p style="text-align:justify;">结束Delegate的BeginInvoke方法：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">因为BeginInvoke异步执行，需要通过某种手段等待异步执行完成。</p> 
 <p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">EndInvoke</span></span> 等待-直到完成</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">调用EndInvoke来处理结果，这种方式就是等待-直到完成的模式。</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">EndInvoke</span></span><span style="background-color:#ffffff;"><span style="color:#222222;"> 会阻塞后面的代码。</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        public int method3(int a,int b)</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        {<!-- --></span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            int r = a + b;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            Thread.Sleep(1000);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            return r;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        }</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        private delegate int NewTaskDelegate(int a,int b);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        NewTaskDelegate task = method3;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        IAsyncResult asyncResult = task.BeginInvoke(2,3, null, null);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">int re = task.EndInvoke(asyncResult);</span></span></p> 
 <p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">轮询模式</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">使用IAsyncResult中的IsComplete熟悉来定期检查开启的线程是否完成。如果未完成就在去做一些其他事情。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        public int method3(int a,int b)</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        {<!-- --></span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            int r = a + b;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            Thread.Sleep(1000);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            return r;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        }</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        private delegate int NewTaskDelegate(int a,int b);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        NewTaskDelegate task = method3;</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">        IAsyncResult asyncResult = task.BeginInvoke(2,3, null, null);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            while (!asyncResult.IsCompleted)</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            {<!-- --></span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">                Console.Write("*");</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">                Thread.Sleep(100);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">            }</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">int re = task.EndInvoke(asyncResult);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">或者通过</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">WaitOne</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">函数进行轮询</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">while (!asyncResult.AsyncWaitHandle.WaitOne(1000, false))</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">{<!-- --></span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">      Console.Write("*");</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">  }</span></span>​​​​​​​</p> 
 <p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">回调模式（在回调方法中调用EndInvoke）</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">前两种都是主动方式的，原始线程一直在监控这新开启的线程。但是回调是被动的，一旦原始线程发起了异步方法，它就自己管自己了，不在考虑同步。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">当异步方法调用结束之后，系统调用一个用户自定义的方法来处理结果，并且调用委托的EndInvoke方法。这个用户自定义的方法就是回调方法。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">上面的BegionInvoke中写过，他会有两个参数一个Callback参数和一个State参数.</p> 
 <p style="margin-left:.0001pt;text-align:justify;">CallBack参数：是回调方法的名称。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">State参数：可以是null，或者传入回调方法的一个对象的引用。我们可以用IAsyncResult参数的AsyncState属性来获取这个对象，参数的类型是object</p> 
 <p style="margin-left:.0001pt;text-align:justify;">回调方法的签名和返回类型必须和 AsyncCallback委托类型所描述的形式一致。然后在回调方法中调用EndInvoke。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        public int method3(int a,int b)</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">            int r = a + b;</p> 
 <p style="margin-left:.0001pt;text-align:justify;">            Thread.Sleep(1000);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">            return r;</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        private delegate int NewTaskDelegate(int a,int b);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        private static void MethodCompleted(IAsyncResult asyncResult)</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">            (asyncResult.AsyncState as NewTaskDelegate).EndInvoke(asyncResult);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">            NewTaskDelegate task = method3;</p> 
 <p style="margin-left:.0001pt;text-align:justify;">            IAsyncResult asyncResult = task.BeginInvoke(2,3, MethodCompleted, task);</p> 
</div> 
<p></p> 
<h6 style="text-align:justify;"><strong>事件</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">事件本质上来讲是一种特殊的<strong><span style="color:#ff0000;"><strong>多播委托</strong></span></strong><strong><span style="color:#ff0000;"><strong>。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">作用：C# 中常常会使用<strong><span style="color:#0000ff;"><strong>事件</strong></span></strong>来实现<span style="color:#ff0000;">线程之间的通信</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在 C# 中，类或对象可以通过事件向其他类或对象通知发生的相关事情。这种模式通常称为<span style="color:#ff0000;">发布订阅模型</span>，发送（或引发）事件的类称为“发布者”，接收（或处理）事件的类称为“订阅者”。所以<span style="color:#ff0000;">事件主要用于发布订阅者模式（即设计模式中的观察者模式）</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">好处：就是解耦</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>发布者</strong></strong>： 一个创建了<span style="color:#ff0000;">事件</span>和<span style="color:#ff0000;">委托定义</span>的对象，同时也包含了<span style="color:#ff0000;">事件和委托之间的联系与具体行为</span>。发布者的任务就是执行这些事件，并通知程序中的其它对象。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>订阅者</strong></strong>： 一个接收事件并<span style="color:#ff0000;">提供事件处理程序</span>的对象。订阅者中的方法（事件处理程序）用于分配给发布者中的委托。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 简单的来说，发布者确定何时引发事件，而订阅者确定对事件作出何种响应。</p> 
<p style="margin-left:.0001pt;text-align:justify;">using System;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 style="text-align:justify;"><strong>事件的声明</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">事件的本质还是委托，所以要声明一个事件之前必须先声明一个相对应的委托。</p> 
<p style="margin-left:.0001pt;text-align:justify;">public delegate void PubDelegate();</p> 
<p style="margin-left:.0001pt;text-align:justify;">在 C# 中，事件需要使用关键字 <strong><span style="color:#ff0000;"><strong>event</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#eef0f4;"><span style="color:#555666;">&lt;Access Specifier &gt; event &lt;Delegate&gt; &lt;Event Name&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">public event PubDelegate PubEvent;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 style="text-align:justify;"><strong>事件的使用范围：</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">仅可以从声明事件的类（或派生类）或结构（发布服务器类）中对其进行调用</span><span style="background-color:#ffffff;">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>// 发布者类 </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">public class PublisherClass</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    // 和事件搭配的委托</p> 
<p style="margin-left:.0001pt;text-align:justify;">    public delegate void PubDelegate();</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">    // 定义事件</p> 
<p style="margin-left:.0001pt;text-align:justify;">    public event PubDelegate PubEvent;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">    // 编写处理事件的具体逻辑</p> 
<p style="margin-left:.0001pt;text-align:justify;">    public void EventHandling()</p> 
<p style="margin-left:.0001pt;text-align:justify;">    {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">        if (PubEvent == null)</p> 
<p style="margin-left:.0001pt;text-align:justify;">        {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            Console.WriteLine("需要注册事件的啊");</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }</p> 
<p style="margin-left:.0001pt;text-align:justify;">        else</p> 
<p style="margin-left:.0001pt;text-align:justify;">        {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">            // 执行注册的事件</p> 
<p style="margin-left:.0001pt;text-align:justify;">            PubEvent();</p> 
<p style="margin-left:.0001pt;text-align:justify;">        }</p> 
<p style="margin-left:.0001pt;text-align:justify;">    }</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>// 订阅者类 </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">public class SubscriberClass</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    public void printout()</p> 
<p style="margin-left:.0001pt;text-align:justify;">    {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">        Console.WriteLine("执行了订阅者类中的事件。");</p> 
<p style="margin-left:.0001pt;text-align:justify;">        Console.ReadLine();</p> 
<p style="margin-left:.0001pt;text-align:justify;">    }</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">public class Program</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    static void Main()</p> 
<p style="margin-left:.0001pt;text-align:justify;">    {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">        // 实例化对象</p> 
<p style="margin-left:.0001pt;text-align:justify;">        PublisherClass p = new PublisherClass();</p> 
<p style="margin-left:.0001pt;text-align:justify;">        SubscriberClass s = new SubscriberClass();</p> 
<p style="margin-left:.0001pt;text-align:justify;">        // 执行事件</p> 
<p style="margin-left:.0001pt;text-align:justify;">        p.EventHandling();</p> 
<p style="margin-left:.0001pt;text-align:justify;">        // 注册事件</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <strong><span style="color:#ff0000;"><strong>    p.PubEvent += new PublisherClass.PubDelegate(s.printout); </strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">        // 执行事件</p> 
<p style="margin-left:.0001pt;text-align:justify;">        p.EventHandling();  </p> 
<p style="margin-left:.0001pt;text-align:justify;">    }</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 style="background-color:transparent;text-align:justify;"><strong>事件委托之EventHandler</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">想直接用事件且懒得去声明委托,这时候微软给我提供了一个委托叫EventHandler,主要是给事件服务的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">事件的声明就是：</p> 
<p style="margin-left:.0001pt;text-align:justify;">public event EventHandler 事件名;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">public delegate void EventHandler(object sender, EventArgs e);</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">object sender</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">：</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一般写this</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">EventArgs e:事件参数,如果无参数就写成EventArgs.Empty</p> 
<p style="margin-left:.0001pt;text-align:justify;">using System;</p> 
<p style="margin-left:.0001pt;text-align:justify;">namespace CSharplearn</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">class Program</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">static void Main(string[] args)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">Trigger trigger = new Trigger();</p> 
<p style="margin-left:.0001pt;text-align:justify;">trigger.TrigMethod();</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">class Trigger</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">public event EventHandler TrigEvent;</p> 
<p style="margin-left:.0001pt;text-align:justify;">public void TrigMethod()</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">TrigEvent += Logic.Printer;</p> 
<p style="margin-left:.0001pt;text-align:justify;">TrigEvent(this,EventArgs.Empty);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">class Logic</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">public static void Printer(object sender,EventArgs e)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">Console.WriteLine("Hello World");</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">泛型兄弟长这样：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#f8f8fa;"><span style="color:#191b1f;">public delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">using System;</p> 
<p style="margin-left:.0001pt;text-align:justify;">namespace CSharplearn</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">class Program</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">static void Main(string[] args)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">Trigger trigger = new Trigger();</p> 
<p style="margin-left:.0001pt;text-align:justify;">trigger.TrigMethod();</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">class Trigger</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">public event EventHandler&lt;MyEventArgs&gt; TrigEvent;</p> 
<p style="margin-left:.0001pt;text-align:justify;">public void TrigMethod()</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">MyEventArgs myArgs = new MyEventArgs();</p> 
<p style="margin-left:.0001pt;text-align:justify;">myArgs.String = "Hello Space";</p> 
<p style="margin-left:.0001pt;text-align:justify;">TrigEvent += Logic.Printer;</p> 
<p style="margin-left:.0001pt;text-align:justify;">TrigEvent(this, myArgs);</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#008000;">//或者是 TrigEvent?.Invoke(this, myArgs);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">class Logic</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">public static void Printer(object sender,MyEventArgs e)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">Console.WriteLine(e.String);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">public class MyEventArgs : EventArgs</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">public string String;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 style="text-align:justify;"><strong>事件与委托的异同：</strong></h6> 
<p style="text-align:justify;"><strong>相同点：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">事件其实是一个多播<span style="color:#ff0000;">委托</span>，本质上是一样的。</p> 
<p style="text-align:justify;"><strong>不同点：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">可调用位置不同：事件只能在声明事件的类中才能调用，而委托无论是在类的内部还是外部都可以调用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">可使用符号不同：事件只能使用 += 和 -= 符号来订阅和取消订阅，但是委托不仅可以使用 += 和 -= 符号还可以使用 = 符号进行方法分配。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2276808dcf05f066735c896bc128eefd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea：springboot项目搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f32fd51bee299766bfeac886499ac1f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7.1 可视化图表 (5%)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>