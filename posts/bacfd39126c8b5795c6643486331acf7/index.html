<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Primer知识点整理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; Primer知识点整理" />
<meta property="og:description" content="C&#43;&#43; Primer知识点整理
C&#43;&#43;必须有一个main函数，return0 返回0表示程序执行完毕。定义函数必须指定4个元素：返回类型、函数名、圆括号内形参表和函数体。cin（读see-in）输入，cout（读see-out）输出，预处理命令会告诉编译器要做一些事情。endl称为操纵符，具有输出换行的效果。C&#43;&#43;中通过定义类来定义自己的数据结构。
第一部分 基本语言
类型是所有程序的基础。C&#43;&#43;的几种基本类型：整形、浮点型、字符型等。void没有对应的值，以0开头，八进制，以0x开头，16进制。变量提供了程序可以操作的有名字的存储区。变量是左值（可在等号左边或右边），数字是右值（只能在右边）。C&#43;&#43;大多数作用域用花括号来界定。定义const对象，它把一个对象转换成一个常量，因为常量的值在定义后不能修改，所以定义的时候必须初始化。const对象默认为文件的局部变量，只存在那个文件中，不能被其他文件访问。引用，就是对象的另一个名字，const引用是指向const对象的引用。typedef名字，可以用来定义类型的同义词。枚举，不但定义了整数常量集，而且把他们汇聚成组。关键字是enum，枚举成员是常量，每个枚举都定义一种唯一的类型。类类型，每个类都定义了一个接口和一个实现。类以关键字class开始，其后是该类的名字标识符。类体位于花括号里面，花括号后面必须跟个分号。 类的数据成员、访问标号等。struct关键字，它也可以定义类类型，但成员都是public的。
标准库类型一旦用了using声明，我们就可以直接引用名字，而不需要再引用该名字的命名空间。string类型支持长度可变的字符串。Vector是一个类模板，用于管理同一类型的对象集合，迭代器实现了对存储与容器中对象的间接访问。迭代器可用于访问和遍历string类型和vector类型的元素。
数组和指针与vector类似，数组也能保存某种类型的一组对象；而他们的区别在与数组的长度是固定的。数组一经创建，就不能添加新的元素。指针像迭代器一样，用于遍历和检查数组中的元素。指针用于指向对象，具体来说指针保存着另一对象的地址。多维数组，如果数组的元素又是数组称为多维数组。
表达式
语句C&#43;&#43;提供了一组控制流，允许有条件的或者重复执行某部分功能。if和switch提供条件分支结构。for、while、do while则支持重复执行的功能。continue终止当次循环，break退出一个循环或switch语句；goto将控制跳到某个标号语句；default标号，相当于else字句的功能。while语句，每次循环都将该变量的初始值转换为bool类型。
函数函数由函数名以及一组操作数类型唯一的表示。函数的操作数也叫形参。return语句用于结束当前正在执行的函数。递归函数，直接或间接的调用自己的函数，举例：数n的阶乘，递归必须要有一个终止条件。内联函数，（编译器在调用点直接把函数代码展开）避免函数调用的开销，把内联函数放入头文件。类的成员函数，每个成员函数都有一个额外的、隐含的形参this。this指针的作用，当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this是一个指针，它时时刻刻指向你这个实例本身。构造函数，通过构造函数来初始化类的数据成员，构造函数是特殊的成员函，它和类同名没有返回类型。
标准IO库 istream，提供输入操作；ostream，提供输出操作；cin，读入标准输入的istream对象；cout，写到标准输出的ostream对象。cerr，输出标准错误的ostream对象。
第二部分 容器和算法
顺序容器，顺序容器的元素按其位置存储和访问。vector、list（高效的插入和删除不支持随机访问）、和deque（双端队列），还提供了三种容器适配器，动过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack、queue、priority-queue（有优先级管理的队列）。选择容器的提示，若程序要求随机访问，则应使用vector和deque容器。 如果程序必须在容器中间位置插入或删除元素，应采用list。 如果程序不是在元素中间位置插入或删除，而是在容器首部或尾部插入和删除则用deque。string类型；容器适配器，优先级队列允许用户为队列中存储的元素设置优先级。
关联容器关联容器和顺序容器的本质差别，关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。两个基本的关联容器map和set map是键-值对的集合，可以理解为关联数组：可使用键作为下标来获取一个值。 map 是键-值对的集合，好比以人名为键的地址和电话号码。相反的，set容器是单纯的键的集合。multimap和multiset允许一个键对应多个实例。
泛型算法
第三部分 类和数据抽象
类定义了数据成员和函数成员。数据成员用于存储与该类类型 的对象相关联的状态，而函数成员则负责执行赋予数据意义的操作。简单来说类就是定义了一个新的类型和一个新的作用域。构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。
复制控制 重载操作符与转换
第四部分 面向对象编程和泛函编程
继承，子类继承父类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bacfd39126c8b5795c6643486331acf7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-23T11:29:40+08:00" />
<meta property="article:modified_time" content="2019-08-23T11:29:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Primer知识点整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>C++ Primer知识点整理</strong></p> 
<p>C++必须有一个main函数，return0 返回0表示程序执行完毕。定义函数必须指定4个元素：返回类型、函数名、圆括号内形参表和函数体。cin（读see-in）输入，cout（读see-out）输出，预处理命令会告诉编译器要做一些事情。endl称为操纵符，具有输出换行的效果。C++中通过定义类来定义自己的数据结构。</p> 
<p><strong>第一部分 基本语言</strong><br> 类型是所有程序的基础。C++的几种基本类型：整形、浮点型、字符型等。void没有对应的值，以0开头，八进制，以0x开头，16进制。变量提供了程序可以操作的有名字的存储区。变量是左值（可在等号左边或右边），数字是右值（只能在右边）。C++大多数作用域用花括号来界定。<strong>定义const对象</strong>，它把一个对象转换成一个常量，因为常量的值在定义后不能修改，所以定义的时候必须初始化。const对象默认为文件的局部变量，只存在那个文件中，不能被其他文件访问。<strong>引用</strong>，就是对象的另一个名字，const引用是指向const对象的引用。<strong>typedef名字</strong>，可以用来定义类型的同义词。<strong>枚举</strong>，不但定义了整数常量集，而且把他们汇聚成组。关键字是<strong>enum</strong>，枚举成员是常量，每个枚举都定义一种唯一的类型。<strong>类类型，<strong>每个类都定义了一个接口和一个实现。类以关键字class开始，其后是该类的</strong>名字标识符</strong>。类体位于花括号里面，花括号后面必须跟个分号。 类的数据成员、访问标号等。<strong>struct关键字</strong>，它也可以定义类类型，但成员都是public的。<br> <strong>标准库类型</strong>一旦用了using声明，我们就可以直接引用名字，而不需要再引用该名字的命名空间。<strong>string类型</strong>支持长度可变的字符串。<strong>Vector</strong>是一个类模板，用于管理同一类型的对象集合，迭代器实现了对存储与容器中对象的间接访问。<strong>迭代器</strong>可用于访问和遍历string类型和vector类型的元素。<br> <strong>数组和指针</strong>与vector类似，<strong>数组</strong>也能保存某种类型的一组对象；而他们的区别在与数组的长度是固定的。数组一经创建，就不能添加新的元素。指针像迭代器一样，用于遍历和检查数组中的元素。<strong>指针</strong>用于指向对象，具体来说指针保存着另一对象的地址。<strong>多维数组</strong>，如果数组的元素又是数组称为多维数组。<br> <strong>表达式</strong><br> <strong>语句</strong>C++提供了一组控制流，允许有条件的或者重复执行某部分功能。if和switch提供条件分支结构。for、while、do while则支持重复执行的功能。continue终止当次循环，break退出一个循环或switch语句；goto将控制跳到某个标号语句；<strong>default标号</strong>，相当于else字句的功能。<strong>while语句</strong>，每次循环都将该变量的初始值转换为bool类型。<br> <strong>函数</strong>函数由函数名以及一组操作数类型唯一的表示。函数的操作数也叫形参。<strong>return</strong>语句用于结束当前正在执行的函数。<strong>递归函数</strong>，直接或间接的调用自己的函数，举例：数n的阶乘，递归必须要有一个终止条件。<strong>内联函数</strong>，（编译器在调用点直接把函数代码展开）避免函数调用的开销，把内联函数放入头文件。<strong>类的成员函数</strong>，每个成员函数都有一个额外的、隐含的形参this。<strong>this指针</strong>的作用，当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this是一个指针，它时时刻刻指向你这个实例本身。<strong>构造函数</strong>，通过构造函数来初始化类的数据成员，构造函数是特殊的成员函，它和类同名没有返回类型。<br> <strong>标准IO库</strong> istream，提供输入操作；ostream，提供输出操作；cin，读入标准输入的istream对象；cout，写到标准输出的ostream对象。cerr，输出标准错误的ostream对象。</p> 
<p><strong>第二部分 容器和算法</strong><br> <strong>顺序容器</strong>，顺序容器的元素按其位置存储和访问。vector、list（高效的插入和删除不支持随机访问）、和deque（双端队列），还提供了三种容器适配器，动过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack、queue、priority-queue（有优先级管理的队列）。<strong>选择容器的提示</strong>，若程序要求随机访问，则应使用vector和deque容器。 如果程序必须在容器中间位置插入或删除元素，应采用list。 如果程序不是在元素中间位置插入或删除，而是在容器首部或尾部插入和删除则用deque。<strong>string类型</strong>；<strong>容器适配器</strong>，优先级队列允许用户为队列中存储的元素设置优先级。<br> <strong>关联容器</strong>关联容器和顺序容器的本质差别，关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。两个基本的关联容器<strong>map</strong>和<strong>set</strong> map是键-值对的集合，可以理解为关联数组：可使用键作为下标来获取一个值。 map 是键-值对的集合，好比以人名为键的地址和电话号码。相反的，set容器是单纯的键的集合。multimap和multiset允许一个键对应多个实例。<br> <strong>泛型算法</strong></p> 
<p><strong>第三部分 类和数据抽象</strong><br> <strong>类</strong>定义了数据成员和函数成员。数据成员用于存储与该类类型 的对象相关联的状态，而函数成员则负责执行赋予数据意义的操作。简单来说类就是定义了一个新的类型和一个新的作用域。<strong>构造函数</strong>是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。<br> <strong>复制控制</strong> <strong>重载操作符与转换</strong></p> 
<p><strong>第四部分 面向对象编程和泛函编程</strong><br> <strong>继承</strong>，子类继承父类。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/660c0c978cd6cc628dd73fa679e6ecec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">drop_duplicates去重详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0d6bebd92da35d4ff893e6f4223a9ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Kernel_exception6] BUG: scheduling while atomic</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>