<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023华为机试真题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023华为机试真题" />
<meta property="og:description" content="1. 字符串比较
给定字符串A、B和正整数V，A的长度与B的长度相等，请计算A中满足如下条件的最大连续子串的长度：
1、该连续子串在A和B中的位置和长度均相等。
2、该连续子串|A[i]-B[i]|之和小于等于V。其中|A[i]-B[i]|表示两个字母ASCII码之差的绝对值。
输入描述：
第一行为字符串A，仅包含小写字母，长度是1到1000
第二行为字符串B，仅包含小写字母，长度是1到1000
第三行为正整数V，V取值在0到10000之间，包括10000。
输出描述：
字符串最大连续子串的长度，要求该子串|A[i]-B[i]|之和小于等于V
示例1
输入
xxcdefg
cdefghi
5
输出
2
说明
字符串A为xxcdefg，字符串B为cdefghi，V=5.它的最大连续子串可以是cd-&gt;ef,de-&gt;fg,ef-&gt;gh,fg-&gt;hi，所以最大连续子串是2.
21
2. 字符匹配
给你一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母和 . 和 * 组成），识别数组中哪些字符串可以匹配到字符规律上。
‘.’匹配任意单个字符，‘*’匹配零个或多个前面的那一个元素，所谓匹配，是要涵盖整个字符串的，而不是部分字符串。
输入描述
第一行为空格分隔的多个字符串，单个字符串长度从1到100，字符串个数从1到100
第二行为字符规律，1&lt;=字符规律长度&lt;=50
不需要考虑异常场景
输出描述：
匹配的字符串在数组中的下标(从0开始)，多个匹配时下标升序并用英文逗号分隔，若均不匹配输出-1.
示例1
输入
ab aab
.*
输出
0,1
说明
ab中a匹配. b匹配* 可以完全匹配；aab中a匹配. ab匹配* 可以完全匹配；输出对应字符串数组下标0,1
示例2
输入
ab aab
a.b
输出
1
说明
aab中第一个a匹配a，第二个a匹配. b匹配b可以全匹配；输出对应的字符串数组下标1
3. 找到它
找到它是个小游戏，你需要在一个矩阵中找到给定的单词，假设给定单词HELLOWORLD，在矩阵中只要能找到H-&gt;E-&gt;L-&gt;L-&gt;O-&gt;W-&gt;O-&gt;R-&gt;L-&gt;D连成的单词，就算通过。
注意区分英文字母大小写，并且你只能上下左右行走，不能走回头路。
输入描述：
输入第一行包含两个整数n、m(0&lt;n,m&lt;21),分别表示n行m列的矩阵，第二行时长度不超过100的单词W（在整个矩阵中给定单词只会出现一次），从第三行到到第n&#43;2行时只包含大小写英文字母的长度为m的字符串矩阵。
输出描述：
如果能在矩阵中连成给定的单词，则输出给定单词首字母在矩阵中的位置（第几行 第几列），否则输出“NO”
示例1
输入" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/778cf5e62f557fb646fa6aa0ef93555a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-25T20:49:37+08:00" />
<meta property="article:modified_time" content="2023-06-25T20:49:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023华为机试真题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 字符串比较<br> 给定字符串A、B和正整数V，A的长度与B的长度相等，请计算A中满足如下条件的最大连续子串的长度：<br> 1、该连续子串在A和B中的位置和长度均相等。<br> 2、该连续子串|A[i]-B[i]|之和小于等于V。其中|A[i]-B[i]|表示两个字母ASCII码之差的绝对值。</p> 
<p>输入描述：<br> 第一行为字符串A，仅包含小写字母，长度是1到1000<br> 第二行为字符串B，仅包含小写字母，长度是1到1000<br> 第三行为正整数V，V取值在0到10000之间，包括10000。</p> 
<p>输出描述：<br> 字符串最大连续子串的长度，要求该子串|A[i]-B[i]|之和小于等于V</p> 
<p>示例1<br> 输入<br> xxcdefg<br> cdefghi<br> 5<br> 输出<br> 2<br> 说明<br> 字符串A为xxcdefg，字符串B为cdefghi，V=5.它的最大连续子串可以是cd-&gt;ef,de-&gt;fg,ef-&gt;gh,fg-&gt;hi，所以最大连续子串是2.<br> 21<br> 2. 字符匹配<br> 给你一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母和 . 和 * 组成），识别数组中哪些字符串可以匹配到字符规律上。<br> ‘.’匹配任意单个字符，‘*’匹配零个或多个前面的那一个元素，所谓匹配，是要涵盖整个字符串的，而不是部分字符串。</p> 
<p>输入描述<br> 第一行为空格分隔的多个字符串，单个字符串长度从1到100，字符串个数从1到100<br> 第二行为字符规律，1&lt;=字符规律长度&lt;=50<br> 不需要考虑异常场景</p> 
<p>输出描述：<br> 匹配的字符串在数组中的下标(从0开始)，多个匹配时下标升序并用英文逗号分隔，若均不匹配输出-1.</p> 
<p>示例1<br> 输入<br> ab aab<br> .*<br> 输出<br> 0,1<br> 说明<br> ab中a匹配. b匹配* 可以完全匹配；aab中a匹配. ab匹配* 可以完全匹配；输出对应字符串数组下标0,1</p> 
<p>示例2<br> 输入<br> ab aab<br> a.b<br> 输出<br> 1<br> 说明<br> aab中第一个a匹配a，第二个a匹配. b匹配b可以全匹配；输出对应的字符串数组下标1<br> 3. 找到它<br> 找到它是个小游戏，你需要在一个矩阵中找到给定的单词，假设给定单词HELLOWORLD，在矩阵中只要能找到H-&gt;E-&gt;L-&gt;L-&gt;O-&gt;W-&gt;O-&gt;R-&gt;L-&gt;D连成的单词，就算通过。</p> 
<p>注意区分英文字母大小写，并且你只能上下左右行走，不能走回头路。</p> 
<p>输入描述：<br> 输入第一行包含两个整数n、m(0&lt;n,m&lt;21),分别表示n行m列的矩阵，第二行时长度不超过100的单词W（在整个矩阵中给定单词只会出现一次），从第三行到到第n+2行时只包含大小写英文字母的长度为m的字符串矩阵。</p> 
<p>输出描述：<br> 如果能在矩阵中连成给定的单词，则输出给定单词首字母在矩阵中的位置（第几行 第几列），否则输出“NO”</p> 
<p>示例1<br> 输入<br> 5 5<br> HELLOWORLD<br> CPUCY<br> EKLQH<br> CHELL<br> LROWO<br> DGRBC<br> 输出<br> 3 2</p> 
<p>示例2<br> 输入</p> 
<p>Helloworld<br> CPUCh<br> wolle<br> orldO<br> EKLQo<br> PGRBC<br> 输出<br> NO<br> 说明<br> 区分大小写<br> 35<br> 4. 停车场车辆统计<br> 标题：停车场车辆统计|时间限制：1s|内存限制：262144k|语言限制：不限<br> 特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占3个车位（长度3），统计停车场最少可以停多少辆车，返回具体的数目。<br> 输入描述<br> 整形字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000.<br> 输出描述<br> 整型数字字符串，表示最少停车数目。<br> 示例1<br> 输入<br> 1 0 1<br> 输出<br> 2<br> 说明<br> 第一个位置放小车，第三位置放小车<br> 示例2<br> 输入<br> 1,1,0,0,1,1,1,0,1<br> 输出<br> 3<br> 说明<br> 第1，2个位置停货车，第5，6，7个位置停卡车，最后个位置停小车<br> 5. 字符串分隔<br> 给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。<br> 输入描述:<br> 输入为两行，第一行为参数K，第二行为字符串S。<br> 输出描述:<br> 输出转换后的字符串。<br> 示例1<br> 输入<br> 3<br> 12abc-abCABc-4aB@<br> 输出<br> 12abc-abc-ABC-4aB-@<br> 说明<br> 子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每3个字符一组为abC、ABc、4aB、@，abC中小写字母较多，转换为abc，ABc中大写字母较多，转换为ABC，4aB中大小写字母都为1个，不做转换，@中没有字母，连起来即12abc-abc-ABC-4aB-@<br> 示例2<br> 输入<br> 12<br> 12abc-abCABc-4aB@<br> 输出<br> 12abc-abCABc4aB@<br> 说明<br> 子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每12个字符一组为abCABc4aB@，这个子串中大小写字母都为4个，不做转换，连起来即12abc-abCABc4aB@<br> 21<br> 6. 字符串加密<br> 给你一串未加密的字符串str，通过对字符串的每一个字母进行改变来实现加密，加密方式是在每一个字母str[i]偏移特定数组元素a[i]的量，数组a前三位已经赋值：a[0]=1,a[1]=2,a[2]=4。当i&gt;=3时，数组元素a[i]=a[i-1]+a[i-2]+a[i-3]，<br> 例如：原文 abcde 加密后 bdgkr，其中偏移量分别是1,2,4,7,13。<br> 输入描述:<br> 第一行为一个整数n（1&lt;=n&lt;=1000），表示有n组测试数据，每组数据包含一行，原文str（只含有小写字母，0&lt;长度&lt;=50）。<br> 输出描述:<br> 每组测试数据输出一行，表示字符串的密文<br> 示例1<br> 输入<br> 1<br> xy<br> 输出<br> ya<br> 说明<br> 第一个字符x偏移量是1，即为y，第二个字符y偏移量是2，即为a<br> 示例2<br> 输入<br> 2<br> Xy<br> abcde<br> 输出<br> ya<br> bdgkr<br> 说明<br> 第二行输出字符偏移量分别是1，2，4，7，13<br> 备注<br> 解答要求<br> 时间限制：2000ms，内存限制：64MB<br> 27<br> 7. 字符串序列判定<br> 输入两个字符串S和L，都只包含英文小写字母，S长度&lt;=100,L长度&lt;500,000。判定S是否是L的有效子串。<br> 字符串的一个有效子串是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。<br> 输入描述<br> 输入两个字符串S和L ,S长度&lt;100,L长度&lt;=500,000<br> 输出描述<br> S串最后一个有效字符在L中的位置（首位从0开始计算，无有效字符返回-1）<br> 示例：<br> 输入<br> ace<br> abcde<br> 输出<br> 4<br> 示例2<br> 输入<br> fgh<br> abcde<br> 输出<br> -1<br> 8. TLV解码<br> TLV编码是按照[Tag  Length  Value]格式进行编码的，一段码流中的信元用Tag标识，Tag在码流中唯一不重复，Length表示信元Value的长度，Value标识信元的值。码流以某信元的Tag开头，Tag固定占一个字节，Length固定占两个字节，字节序为小端序。<br> 现在给定TLV格式编码的码流，以及需要解码的信元Tag，请输出该信元的Value。<br> 输入码流的16进制字符中，不包括小写字母，且要求输出的16进制字符串中也不需要包含小写字母；码流字符串的最大长度不超过50000个字节。</p> 
<p>输入描述：<br> 输入的第一行为一个字符串，表示待解码信元的Tag<br> 输入的第二行为一个字符串，表示待解码的16进制码流，字节之间用空格分割。</p> 
<p>输出描述：<br> 输出一个字符串，表示待解码信元以16进制表示的Value</p> 
<p>示例1：<br> 输入<br> 31<br> 32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC<br> 输出<br> 32 33</p> 
<p>说明<br> 需要解析的信元Tag是31， 从码流的起始处开始匹配，Tag为32的信元长度为1 (01 00, 小端序表示为1) ；第二个信元的Tag是90， 其长度为2； 第三个信元的Tag是30， 其长度为3； 第四个信元的Tag为31， 其长度为2（02 00）， 所以返回长度后面的两个字节即可，即：32 33<br> 9. 按照身高体重排队<br> 输入描述：<br> 两个序列，每个序列由n个正整数组成（0 &lt; n &lt;= 100）。第一个序列中的数值代表身高，第二个序列中的数值表示体重。</p> 
<p>输出描述：<br> 排列结果，每个数值都是原始序列中的学生编号，编号从1开始</p> 
<p>示例1：<br> 输入<br> 4 <br> 100 100 120 130<br> 40 30 60 50 </p> 
<p>输出<br> 2 1 3 4</p> 
<p>说明<br> 输出的第一个数字2表示此人原始编号为2，即身高为100， 体重为30这个人。由于他何编号为1的人身高一样，但体重更轻，因此排在1号的前面。</p> 
<p>示例2：<br> 输入<br> 3<br> 90 110 90<br> 45 60 45</p> 
<p>输出<br> 1 3 2 </p> 
<p>说明<br> 1和3的身高体重都相同，需要按照原有位置关系让1排在3前面，而不是3 1 2<br> 29<br> 10. 按索引范围翻转文章片段<br> 输入一个英文文章片段，翻转指定区间的单词顺序，标点符号和普通字母一样处理。例如输入字符串“I am a developer. ”，区间 [0，3]， 则输出“developer. a am I”。</p> 
<p>String reverseWords(String s, int start, int end)</p> 
<p>输入描述：<br> 使用换行隔开三个参数，第一个参数为英文文章内容，即英文字符串；第二个参数为翻转起始单词下标(下标从0开始)；第三个参数为结束单词下标。</p> 
<p>输出描述：<br> 翻转后的英文文章片段所有单词之间以一个半角空格分隔进行输出</p> 
<p>示例1：<br> 输入<br> I am a developer.<br> 1<br> 2<br> 输出<br> I a am developer.</p> 
<p>示例2：<br> 输入<br>   hello world!<br> 0 <br> 1<br> 输出<br> world! hello</p> 
<p>说明<br> 输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括多余的空格</p> 
<p>示例3：<br> 输入<br> I am a     developer.<br> 0<br> 3<br> 输出<br> developer. a am I</p> 
<p>说明<br> 如果两个单词间有多余的空格，将翻转后单词间的空格减少到只有一个。</p> 
<p>示例4：<br> 输入<br> Hello!<br> 0<br> 3<br> 输出<br> EMPTY</p> 
<p>说明<br> 指定翻转区间只有一个单词或有无有效单词，则统一输出“EMPTY”</p> 
<p>11. 磁盘容量排序<br> 磁盘的容量单位常用的有M、G、T三个等级，它们之间的换算关系为1T=1024G，1G=1024M。<br> 现在给定n块磁盘的容量，请对它们按容量从小到大的顺序进行稳定排序，例如给定5块盘的容量，1T，20M，3G，10G6T，3M12G9M，排序后的结果为20M，3G，3M12G9M，1T，10G6T。请注意单位可以重复出现，上述3M12G9M表示的容量即为 3M + 12G + 9M，和12M12G相等。</p> 
<p>输入描述：<br> 输入第一行包含一个整数n (2 &lt;= n &lt;= 100)， 表示磁盘的个数，接下来的n行，每行一个字符串（长度大于2，小于30），表示磁盘的容量，由一个或多个格式为mv的子串组成，其中m表示容量大小，v表示容量单位，例如：2M，1T，30G，10G6T，3M12G9M。</p> 
<p>磁盘容量m的范围为1到1024的正整数，容量单位v的范围只包含题目中提到的M、G、T三种，换算关系如题目描述。</p> 
<p>输出描述：<br> 输出n行，表示n块磁盘按容量排序后的结果。</p> 
<p>示例1：<br> 输入<br> 3<br> 1G<br> 2G<br> 1024M</p> 
<p>输出<br> 1G<br> 1024M<br> 2G</p> 
<p>说明<br> 1G和1024M相等，稳定排序要求保留它们原来的相对位置，故1G在1024M之前</p> 
<p>示例2：<br> 输入<br> 3<br> 2G4M<br> 3M2G<br> 1T</p> 
<p>输出<br> 3M2G<br> 2G4M<br> 1T</p> 
<p>说明<br> 1T的容量大于2G4M，2G4M的容量大于3M2G<br> 12. 打印任务排序<br> 某个打印机根据打印队列执行打印任务，打印任务分为9个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A，然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A更高优先级的任务，则将任务A放到队列尾部，否则就执行任务A的打印。请编写一个程序，根据输入的打印队列，输出实际的打印顺序。</p> 
<p>输入描述：<br> 输入一行，为每个任务的优先级，优先级之间用逗号隔开，优先级取值范围为1-9<br> 输出描述：<br> 输出一行，为每个任务的打印顺序，打印顺序从0开始，用逗号隔开</p> 
<p>示例1：<br> 输入<br> 9，3，5<br> 输出<br> 0，2，1</p> 
<p>说明<br> 队列头部任务的优先级为9，最先打印，故序号为0；接着队列头部任务优先级为3，队列中还有优先级为5的任务，优先级3任务被移动到队列的尾部；接着打印优先级为5的任务，故其序号为1；最后优先级为3的任务序号为2</p> 
<p>示例2：<br> 输入<br> 1，2，2<br> 输出<br> 2，0，1</p> 
<p>说明<br> 队列头部任务的优先级为1，被移动到队列尾部，接着顺序打印两个优先级为2的任务，故其序号分别为0和1；最后打印剩下的优先级为1的任务，其序号为2</p> 
<p>注意：这道题对顺序的理解容易出现偏差<br> 13. 斗地主之顺子<br> 在斗地主扑克牌游戏中，扑克牌由小到大的顺序为：3、4、5、6、7、8、9、10、J、Q、K、A、2。玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。<br> 其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不包括2.<br> 例如：{3，4，5，6，7 }、{3、4、5、6、7、8、9、10、J、Q、K、A}都是有效的顺子；<br> 而{J、Q、K、A、2}、{2、3、4、5、6}、{3、4、5、6}、{3、4、5、6、8}等都不是顺子。<br> 给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。<br> 如果存在多个顺子，请每行输出一个顺子，且需要按顺子第一张牌的大小(从小到大)依次输出。<br> 如果没有满足出牌规则的顺子，请输出NO</p> 
<p>输入描述：<br> 13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王。<br> 2 9 J 2 3 4 K A 7 9 A 5 6<br> 不需要考虑输入为异常字符的情况</p> 
<p>输出描述：<br> 组成的顺子，每张扑克牌数字用空格隔开<br> 3 4 5 6 7</p> 
<p>示例1：<br> 输入<br> 2 9 J 2 3 4 K A 7 9 A 5 6<br> 输出<br> 3 4 5 6 7</p> 
<p>说明<br> 13张牌中，可以组成的顺子只有1组：3 4 5 6 7</p> 
<p>示例2：<br> 输入<br> 2 9 J 10 3 4 K A 7 Q A 5 6<br> 输出<br> 3 4 5 6 7<br> 9 10 J Q K A</p> 
<p>说明<br> 13张牌中，可以组2组顺子，从小到大分别为：3 4 5 6 7 和 9 10 J Q K A</p> 
<p>示例3：<br> 输入<br> 2 9 9 9 3 4 K A 10 Q A 5 6<br> 输出<br> NO</p> 
<p>说明<br> 13张牌中，无法组成顺子<br> 14. 分班<br> 幼儿园两个班的小朋友在排队时混在了一起，每位小朋友都知道自己是否与前面一位小朋友是否同班，请你帮忙把同班的小朋友找出来。<br> 小朋友编号为整数，与前一位小朋友同班用Y表示，不同班用N表示。</p> 
<p>输入描述：<br> 输入为空格分开的小朋友编号和是否同班的标志。比如：<br> 6/N 2/Y 3/N 4/Y <br> 表示共4位小朋友，2和6同班，3和2不同班，4和3同班。<br> 其中，小朋友总数不超过999，每个小朋友编号都大于0，小于等于999.<br> 不考虑输入格式错误的问题</p> 
<p>输出描述：<br> 输出为两行，每一行记录一个小朋友班的编号，编号用空格分开，且：<br> 编号需要按照大小顺序排列，分班记录中第一个编号小的排在第一行<br> 若只有一个班的小朋友，第二行为空行<br> 若输入不符合要求，则直接输出字符串ERROR</p> 
<p>示例1：<br> 输入<br> 1/N 2/Y 3/N 4/Y<br> 输出<br> 1 2<br> 3 4<br> 说明<br> 2的同班标记为Y，因此和1同班<br> 3的同班标记为N，因此和1、2不同班<br> 4的同班标记为Y，因此和3同班<br> 所以1、2同班，3、4同班，输出为：<br> 1 2<br> 3 4</p> 
<p>注意：<br> 异常场景的识别，某人同时属于两个班，某个不在任何一个班内<br> 14. 工号不够用咋办<br> 集团员工人数突破20亿人，即将遇到工号不够用的情况。现在设计新的工号系统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分组成。新工号由一段英文字母开头，之后跟随一段数字，比如：“aaahw0001”,“a12345”，“abcd1”，“a00”。注意，新工号不能全部为字母或者数字，允许数字部分有前导0或者全为0。现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。</p> 
<p>输入描述：<br> 一行包含两个非负整数 X  Y， 它们用单个空格分割。其中：<br> 0 &lt; X &lt;= 2^50 - 1<br> 0 &lt; Y &lt;= 5</p> 
<p>输出描述：<br> 输出新工号中数字的最短长度Z</p> 
<p>示例1：<br> 输入<br> 260 1<br> 输出<br> 1</p> 
<p>说明<br> 由于字母长度为1，从26个字母中选择一个字母的组合数为26。<br> 0-9这10个数字中，任选一个数字的组合数量为10<br> 26 * 10 == 260，因此最短数字长度为1</p> 
<p>示例2：<br> 输入<br> 26 1<br> 输出<br> 1</p> 
<p>说明<br> 其实26个人只需要26个字母就够了，但是由于数字是必须的，所以至少需要1个数字</p> 
<p>示例3：<br> 输入<br> 2600 1<br> 输出<br> 2</p> 
<p>说明，同上。<br> 37<br> 15. 猴子爬山<br> 猴子爬山，经过一个有N阶台阶的阶梯，猴子有个习惯，每次只能跳1阶台阶或者3阶台阶，求猴子通过N个台阶有多少种不同的跳跃方式？</p> 
<p>输入描述：<br> 输入只有一个整数N (0 &lt; N &lt; 50)，表示台阶的数量<br> 输出描述：<br> 输出一个数字，表示多少种跳跃方式</p> 
<p>示例1：<br> 输入<br> 50<br> 输出<br> 122106097</p> 
<p>示例2：<br> 输入<br> 3<br> 输出<br> 2</p> 
<p>提示：斐波拉契数量的非递归解法，否则会爆掉<br> 16. 连续字母长度<br> 给定一个字符串，只包含大写字母，求在包含同一个字母的子串中，长度第k长的子串的长度，相同字母只取最长的那个子串。若子串中只包含同一个字母的子串数小于k，则输出-1.</p> 
<p>输入描述：<br> 第一行有一个字符串（1 &lt; 长度 &lt; 100），只包含大写字母<br> 第二行有一个数字，表示k的值</p> 
<p>输出描述：<br> 输出连续出现次数第k多的字母的次数</p> 
<p>示例1：<br> 输入<br> AAAAHHHBBCDHHHH<br> 3<br> 输出<br> 2</p> 
<p>说明<br> 同一字母连续出现的最多的是A和H，4次；第二多的是H，3次，但是H已经存在4个连续的了，故不再考虑；下个最长的子串是BB，其长度为2，所以最终答案应该输出2</p> 
<p>示例2：<br> 输入<br> AABAAA<br> 2<br> 输出<br> 1</p> 
<p>说明<br> 同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故不考虑；第二个最长子串是B，它的长度是1，所以输出1</p> 
<p>示例3：<br> 输入<br> ABC<br> 4<br> 输出<br> -1</p> 
<p>说明<br> 只含有3个包含同一个字母的子串，小于k，输出-1</p> 
<p>示例4：<br> 输入<br> ABC<br> 2<br> 输出<br> 1</p> 
<p>说明<br> 三个子串长度均为1，所以此时k=1、k=2、k=3这三种情况均输出1<br> 17. 流水线<br> 工厂有m条流水线，用于并行完成n个独立的作业，工厂设置了一个调度系统，在安排作业时，总是优先执行处理时间最短的作业。<br> 现给定流水线个数m，和需要完成的作业数n，每个作业的处理时间分别为t1、t2、...、tn。请编程计算处理完成所有作业的耗时为多少？<br> 当n&gt;m时，首先处理时间短的m个作业进入流水线，其他的等待，当某个作业完成时，依次从剩余作业中取处理时间最短的进入处理。</p> 
<p>输入描述：<br> 第一行为2个整数（采用空格分隔），分别表示流水线个数m和作业数n<br> 第二行输入n个整数（采用空格分隔），表示每个作业的处理时长t1、t2、...、tn。<br> 其中，0 &lt; m,n &lt; 100, 0 &lt; t1,t2,...,tn &lt; 100。<br> 注：输入都是合法的。</p> 
<p>输出描述：<br> 输出处理完所有作业的总时长</p> 
<p>示例1<br> 输入<br> 3 5<br> 8 4 3 2 10<br> 输出<br> 13</p> 
<p>说明<br> 先安排时间为2、3、4的三个作业。<br> 第一条流水线先完成作业，然后调度剩余时间最短的作业8<br> 第二条流水线完成作业，然后调度剩余时间最短的作业10<br> 总耗时就是第二条流水线完成作业的时间13（3+10）</p> 
<p>提示：每次将时间最短的那个任务，扔进当前有空的流水线里面处理。注意这个不是最有的调度方案。<br> 27<br> 18. 判断一组不等式是否满足约束，并输出最大差<br> 给定一组不等式，判断不等式是否成立，并输出不等式中的最大差（输出浮点数的整数部分），要求：<br> 不等式系数为double类型，是一个二维数组<br> 不等式的变量为int类型，是一个一维数组<br> 不等式的目标值为double类型，是一个一维数组<br> 不等式约束为字符串数组，只能是：“&gt;, &gt;=, &lt;, &lt;=, =”,例如，不等式组：<br> a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 &lt;= b1;<br> a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 &lt;= b2;<br> a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 &lt;= b3;</p> 
<p>最大差=max{ <br> (a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 - b1), <br> (a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 - b2), <br> (a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 - b3) }<br> 最大差类型为整数，浮点数需要取整数部分</p> 
<p>输入描述：<br> 输入只有一行，包含下面四部分：<br> 不等式组系数（double类型）：<br> a11, a12, a13, a14, a15<br> a21, a22, a23, a24, a25<br> a31, a32, a33, a34, a35<br> 不等式变量（int类型）：<br> x1, x2, x3, x4, x5<br> 不等式的目标值（double类型）: b1, b2, b3<br> 不等式的约束（字符串类型）：&lt;=, &lt;=, &lt;=</p> 
<p>输入示例：a11, a12, a13, a14, a15;a21, a22, a23, a24, a25;a31, a32, a33, a34, a35;x1, x2, x3, x4, x5;b1, b2, b3;&lt;=, &lt;=, &lt;=</p> 
<p>输出描述：<br> true 或者 false, 最大差</p> 
<p>示例1：<br> 输入<br> 2.3, 3, 5.6, 7, 6; 11, 3, 8.6, 25, 1; 0.3, 9, 5.3, 66, 7.8; 1, 3, 2, 7, 5; 340, 670, 80.6; &lt;=, &lt;=, &lt;=<br> 输出<br> false 458</p> 
<p>示例2：<br> 输入<br> 2.36, 3, 6, 7.1, 6; 1, 30, 8.6, 2.5, 21, 0.3, 69, 5.3, 6.6, 7.8; 1, 13, 2, 17, 5; 340, 67, 300, &lt;=, &gt;=, &lt;=<br> 输出<br> false 758</p> 
<p>提示：<br> 注意输入的处理，分号隔离，浮点数的取整<br> 45<br> 19. 拼接URL<br> 给定一个URL前缀和URL后缀，通过 ”,” 分隔， 需要将其连接成一个完整的URL，如果前缀结尾和后缀开头都没有“/”, 需要自动补上“/”连接符，如果前缀结尾和后缀开头都为“/”, 需要自动去掉重复的“/”。<br> 约束：不用考虑前后缀URL不合法的情况。</p> 
<p>输入描述：<br> URL前缀（长度小于100个字符），URL后缀（长度小于100个字符）<br> 输出描述：<br> 拼接之后的URL</p> 
<p>示例1：<br> 输入<br> /acm, /bb<br> 输出<br> /acm/bb</p> 
<p>示例2：<br> 输入<br> /abc/, /bcd<br> 输出<br> /abc/bcd</p> 
<p>示例3：<br> 输入<br> /acd, bef<br> 输出<br> /acd/bef</p> 
<p>示例4：<br> 输入<br> ,<br> 输出<br> /<br> 31<br> 20. 求解连续数列<br> 已知连续正整数数列{K} = K1, K2, K3, ..., Ki的各个数相加之和为S, i=N(0&lt;S&lt;100000, 0&lt;N&lt;100000), 求此数列K。<br> 输入描述：<br> 输入包含两个参数：1）连续正整数数列和S； 2）数列列数的个数N<br> 输出描述：<br> 如果有解，输出数列K；如果无解，输出-1</p> 
<p>示例1：<br> 输入<br> 525 6<br> 输出<br> 85 86 87 88 89 90</p> 
<p>示例2：<br> 输入<br> 3 5<br> 输出<br> -1<br> 17<br> 区间交集<br> 给定一组闭区间，其中部分区间存在交集。任意两个给定区间的交集，称为公共区间（如：[1,2], [2,3]的公共区间为[2,2]， [3,5],[3,6]的公共区间为[3,5]）。公共区间之间若存在交集，则需要合并（如：[1,3],[3,5]区间存在交集[3,3]，需要合并为[1,5]）。按升序排列输出合并后的区间列表。</p> 
<p>输入描述：<br> 一组区间列表， 区间数为N，0&lt;=N&lt;=10000<br> 输出描述：<br> 升序排列的合并后的区间列表</p> 
<p>示例1：<br> 输入<br> 0 3<br> 1 3<br> 3 5<br> 3 6<br> 输出<br> 1 5<br> 说明<br> [0,3]和[1,3]的公共区间为[1,3]，[0,3]和[3,5]的公共区间为[3,3]，[0,3]和[3,6]的公共区间为[3,3]， [1,3]和[3,5]的共区间为[3,3]，[1,3]和[3,6]的共区间为[3,3]， [3,5]和[3,6]的公共区间为[3,5]， 公共区间列表为[[1,3], [3,3], [3,5]]，他们合并后的区间为[1,5]。</p> 
<p>示例2：<br> 输入<br> 0 3<br> 1 4<br> 4 7<br> 5 8<br> 输出<br> 1 3<br> 4 4<br> 5 7</p> 
<p>示例3：<br> 输入<br> 1 2<br> 3 4<br> 输出<br> None<br> 说明<br> [1,2]和[3,4]没有交集</p> 
<p>备注：区间元素均为数字，不考虑字母、符号等异常输入；单个区间认定为无公共区间<br> 39<br> 22. 事件推送<br> 同一个数轴X上有两个点的集合A={A1, A2, ..., Am}和B={B1, B2, ..., Bn}。Ai和Bj均为正整数， A、B已经按照从小到大排好序，A、B均不为空。给定一个距离R（正整数），列出同时满足如下条件的所有（Ai, Bj）数对：<br> Ai &lt;= Bj<br> Ai, Bj之间的距离小于R<br> 在满足1）2）的情况下，每个Ai只需输出距离最近的Bj<br> 输出结果按Ai从小到大顺序排序</p> 
<p>输入描述：<br> 第一行三个正整数m, n, R<br> 第二行m个正整数， 表示集合A<br> 第三行n个正整数，表示集合B<br> 输入限制：<br> 1 &lt;= R &lt;= 100000, 1 &lt;= n, m &lt;= 100000, 1 &lt;= Ai, Bj &lt;= 1000000000</p> 
<p>输出描述：<br> 每组数对输出一行Ai 和Bj，以空格隔开</p> 
<p>示例1：<br> 输入<br> 4 5 5<br> 1 5 5 10<br> 1 3 8 8 20<br> 输出<br> 1 1<br> 5 8<br> 5 8<br> 25<br> 23. 数组拼接<br> 有多组整数数组，把他们按如下规则拼接成一个新的数组：<br> 从每个数组中按顺序取出固定数列的内容，合并到新数组中(已取出的内容将从原始数组中去除)，如果该行不足固定长度或者已经为空，则直接取出剩余部分放到新数组中。继续下一行。</p> 
<p>输入描述：<br> 第一行是每次读取的固定长度， 0 &lt; 长度 &lt; 10<br> 第二行是整数数组的个数，0 &lt; 个数 &lt; 1000<br> n行是需要合并的数组，不同的数组用回车换行分隔，数组内部用逗号分隔，最大不超过100个元素。</p> 
<p>输出描述：<br> 输出一个新的数组，用逗号分隔每项</p> 
<p>示例1：<br> 输入<br> 2, 5, 6, 7, 9 , 5, 7<br> 1, 7, 4, 3, 4<br> 输出<br> 2, 5, 6, 1, 7, 4, 7, 9, 5, 3, 4, 7</p> 
<p>说明<br> 获得长度为3和数组数目为2<br> 先遍历第一行，获得3个数，分别为2, 5, 6，放入目标数组中<br> 再遍历第二行，获得3个数，分别为1, 7, 4， 放入目标数组中<br> 再循环回第一行，获得7, 9, 5，放入目标数组中<br> 再遍历第二行，获得3,4， 放入目标数组中<br> 再回到第一行，获得7， 放入目标数组中</p> 
<p>示例2：<br> 输入<br> 1, 2, 3, 4, 5, 6<br> 1, 2, 3<br> 1, 2, 3, 4<br> 输出<br> 1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 4, 5, 6<br> 37<br> 24. 数组去重和排序<br> 给定一个乱序的数组，删除所有的重复元素，使得每个元素只出现一次，并且按照出现的次数从高到低进行排序，相同出现次数按照第一次出现顺序进行先后排序。</p> 
<p>输入描述：<br> 一个数组<br> 输出描述：<br> 去重排序后的数组</p> 
<p>示例1：<br> 输入<br> 1, 3, 3, 3, 2, 4, 4, 4, 5<br> 输出<br> 3, 4, 1, 2, 5</p> 
<p>备注：<br> 数组大小不超过100， 数组元素值不超过100<br> 15<br> 25. 数组组成的最小数字<br> 给定一个数组，请从该数组中选择3个元素组成最小数字并输出(如果数组长度小于3，则选择数组中所有元素组成最小数字)。0 &lt;数组长度&lt;100， 0&lt;整数取值范围&lt;=10000。</p> 
<p>输入描述：<br> 一行用半角逗号分隔的字符串记录的整型数组<br> 输出描述：<br> 由3个元素组成的最小数字，如果数组长度小于3，则选择数组中所有元素来组成最小数字</p> 
<p>示例1：<br> 输入<br> 21,30,62,5,31<br> 输出<br> 21305<br> 说明<br> 数组长度超过3，需要选择3个元素来组成最小的数字，21305由21,30,5三个元素组成，为所有组合中的最小数字</p> 
<p>示例2：<br> 输入<br> 5,21<br> 输出<br> 215<br> 说明<br> 数组长度小于3，选择所有元素来组成最小值，215为最小值。<br> 26. 太阳能板的最大面积<br> 给航天器一侧加装长方形或正方形的太阳能板，需要先安装两个支柱，再在支柱上安装太阳能板。但是航天器不同位置的支柱长度不同，太阳能板的安装面积受限于最短一侧的那根支柱长度。<br> 现在提供一组整型数组作为支柱的高度数据，假设每根支柱间距离相等为1个单位长度，计算如何选择两根支柱可以使太阳能板的面积最大。</p> 
<p>输入描述：<br> 10,9,8,7,6,5,4,3,2,1<br> 注意：支柱至少有2根，最多10000根，能支持的高度范围1~10^9的整数。柱子的高度是无序的，例子中的递减只是巧合。<br> 输出描述：<br> 25<br> 说明<br> 在10米高的支柱和5米高的支柱上安装，这两根支柱间宽度为5，高度取最小的支柱高5，面积即为25。任取其他两根支柱所能获得的面积都小于25。所以面积最大为25。<br> 27. 完全二叉树非叶子节点后序遍历<br> 给定一个以顺序存储结构（按每一层从左到右顺序）存储整数值的完全二叉树序列(最多1000个整数)，请找出此完全二叉树的所有非叶子节点部分，然后采用后序遍历的方式将该树的非叶子节点输出。<br> 只有一个节点的树，此节点是根节点，应该被认为是非叶子节点<br> 此完全二叉树并非满二叉树，可能存在倒数第二层出现叶子节点，或者无右叶子的情况<br> 后序遍历的顺序：左-右-根<br> 输入描述：<br> 一个通过空格分隔的整数序列字符串<br> 输出描述：<br> 非叶子部分树结构的后序遍历结果</p> 
<p>示例1：<br> 输入<br> 1 2 3 4 5 6 7<br> 输出<br> 2 3 1<br> 说明<br> 找到非叶子部分树结构，然后采用后序遍历输出<br> 备注：输出数字以空格分隔<br> 17<br> 28. 玩牌高手<br> 给定一个长度为n的整型数组，表示一个选手在n轮内可选择的牌面分数。选手基于规则选牌，请计算所有轮结束后其可以获得的最高总分数。选择规则如下：<br> 在每轮里选手可以选择获取该轮牌面，则就在其总分数加上该轮牌面分数，作为新的总分数。<br> 选手也可以不选择本轮牌面直接跳到下一轮，但此时需要将当前总分数还原为3轮前的总分数，若当前轮次小于等于3(即在第1、2、3轮选择跳过)，则总分数置为0.<br> 选手的初始总分数为0，且必须依次参加每一轮。</p> 
<p>输入描述：<br> 第一行为一个小写逗号分隔的分值字符串，表示这n轮的牌面分数， 1 &lt;= n &lt;= 20<br> 分数值为整数，范围是-100到100<br> 不考虑格式问题</p> 
<p>输出描述：<br> 所有轮结束后选手能够获得的最高总分数</p> 
<p>示例1：<br> 输入<br> 1,-5,-6,4,3,6,-2<br> 输出<br> 11<br> 说明<br> 这里总共7轮牌面。<br> 第一轮选择该轮牌面，总分数为1.<br> 第二轮不选择该轮牌面，总分数还原为0<br> 第三轮不选择该轮牌面，总分数还原为0<br> 第四轮选择该轮牌面，总分数为4<br> 第五轮选择该轮牌面，总分数为7<br> 第六轮选择该轮牌面，总分数为13.<br> 第七轮如果不选择该轮牌面，则总分还原到3轮前的分数，即第四轮的总分数4；如果选择牌面，总分数为11。所以选择该轮牌面。<br> 因此，最终的最高总分数为11<br> 29. 相对开音节<br> 相对开音节构成的结构是: 辅音+元音(aeiou)+辅音(r除外)+e，常见的单词有bike、cake等。<br> 给定一个字符串，以空格为分隔符，反转每个单词中的字母（若单词中包含如数字等其他非字母时不进行反转）。反转后计算其中含有相对开音节结构的子串个数（连续的子串中部分字符可以重复）。</p> 
<p>输入描述：<br> 一行空格分隔单词的字符串，字符串长度&lt;10000，字母都是小写字母<br> 输出描述：<br> 含有相对开音节结构的子串个数。注：个数&lt;10000</p> 
<p>示例1：<br> 输入<br> ekam a ekac<br> 输出<br> 2<br> 说明<br> 字符串反转后为make a cake 其中make、cake为相对开音节子串，总是为2个，返回2.</p> 
<p>示例2：<br> 输入<br> !ekam a ekekac<br> 输出<br> 2<br> 说明<br> 反转后为!ekam a cakeke 因为!ekam含有非英文字符所有不能反转，反转后的cake、keke都是相对开音节子串，所以返回2.<br> 23<br> 30. 消消乐游戏<br> 游戏规则：输入一个只包含英文字母的字符串，字符串中的两个字母如果相邻且相同，就可以消除。</p> 
<p>在字符串上反复执行消除的动作，直到无法继续消除为止，此时游戏结束。<br> 请输出最终得到的字符串长度</p> 
<p>输入描述：<br> 输入原始字符串str，只能包含大小写因为字母，字母大小写敏感，str长度不超过100。</p> 
<p>输出描述：<br> 输出游戏结束后，最终得到的字符串长度</p> 
<p>示例1：<br> 输入<br> gg<br> 输出<br> 0<br> 说明<br> gg可以直接消除，得到空串，长度为0</p> 
<p>示例2：<br> 输入<br> mMbccbc<br> 输出<br> 3<br> 说明<br> 在mMbccbc中，可以先说出cc，得到mMbbc；再消除bb，得到mMc。此时无法再消除，最终长度为3</p> 
<p>备注：<br> 输入中包含 非大小写英文字母时，均为异常输入，直接返回0<br> 29<br> 31. 寻找身高相近的小朋友<br> 小明升学到小学一年级，来到新班级后发现其他小朋友们的身高参差不齐，然后就想基于各个小朋友和自己的身高差对他们进行排序，请帮忙实现这个排序算法。<br> 输入描述：<br> 第一行为正整数H和N，0 &lt; H &lt; 200, 为小明的身高；0 &lt; N &lt; 50，为新班级其他小朋友个数<br> 第二行为N个正整数，分别是其他小朋友的身高，身高取值为0~200，且N个正整数各不相同。</p> 
<p>输出描述：<br> 输出排序结果，各正整数以空格分隔。和小明身高差绝对值最小的小朋友排在前面，和小明身高差绝对值最大的小朋友排在最后，如果两个小朋友和小明身高差一样，则个子较小的小朋友排在前面。</p> 
<p>示例1：<br> 输入<br> 100 10<br> 95 96 97 98 99 101 102 103 104 105<br> 输出<br> 99 101 98 102 97 103 96 104 95 105<br> 32. 寻找相同子串<br> 给你两个字符串t 和 p，要求从t中找到一个和p相同的连续子串，并输出该子串的第一个字符的下标</p> 
<p>输入描述：<br> 输入包括两行，分别表示t和p，保证t的长度不小于p，而且t的长度不超过1000000， p的长度不超过10000.</p> 
<p>输出描述：<br> 如果能从t中找到一个和p相等的连续子串，则输出该子串第一个字符在t中的下标（下标以1开始）；如果不能则输出“NO”；如果包含多个这样的子串，则输出第一个字符下标最小的那个。</p> 
<p>示例1：<br> 输入<br> AVERDXIVYERDIAN<br> RDXI<br> 输出<br> 14<br> 33. 一种字符串压缩表示的解压<br> 有一种简易的压缩算法，针对全部由小写英文字母组成的字符串，将其中连续超过2个相同的部分压缩为连续个数加该字母，其他部分保持原样不变。例如：字符串“aaabbccccd”经过压缩成为字符串“3abb4cd”。请编写解压函数，根据输入的字符串，判断其是否为合法压缩过的字符串，若输入合法则输出解压缩后的字符串，否则输出字符串“!error”来报告错误。</p> 
<p>输入描述：<br> 输入一行，为一个ASCII字符串，长度不会超过100字符，用例保证输出的字符串长度也不会超过100字符。</p> 
<p>输出描述：<br> 若判断输入为合法的经过压缩后的字符串，则输出压缩前的字符串，若输入不合法，则输出!error</p> 
<p>示例1：<br> 输入<br> 4dff<br> 输出<br> Ddddff</p> 
<p>示例2：<br> 输入<br> 2dff<br> 输出<br> !error<br> 说明<br> 两个d不需要压缩，输入不合法</p> 
<p>示例3：<br> 输入<br> 4d@A<br> 输出<br> !error<br> 说明<br> 出现特殊字符和大写字母，输入不合法<br> 29<br> 34. 用连续自然数之和来表达整数<br> 一个整数可以有连续的自然数之和来表示。给定一个整数，计算该整数有集中连续自然数之和的表达式，且打印出每种表达式。</p> 
<p>输入描述：<br> 一个目标整数T（1 &lt;= T &lt;= 1000）<br> 输出描述：<br> 该整数所有表达式个数。如果有多种表达式，输出要求为：<br> 自然数个数最少的优先输出<br> 每个表达式中按自然数递增的顺序输出，具体的格式参考阳历，在每个测试数据结束时，输出一行“Result:X”，其中X时最终的表达式个数。注意：数字和符号之间没有空格。</p> 
<p>示例1：<br> 输入<br> 9<br> 输出<br> 9=9<br> 9=4+5<br> 9=3+4+5<br> Result:3</p> 
<p>示例2：<br> 输入<br> 10<br> 输出<br> 10=10<br> 10=1+2+3+4<br> Result:2<br> 25<br> 35. 找车位<br> 停车场有一横排车位，0代表没有停车，1代表有车。输入数据中，至少停了一辆车在车位上，也至少有一个空位没有停车。<br> 为了防止剐蹭，需要为停车人找到一个车位，使得距离停车人的车最近的车辆距离是最大的，返回此时的最大距离。</p> 
<p>输入描述：<br> 一个用半角逗号分隔的停车标识字符串，停车标识为0或1，0标识空位，1标识已停车。<br> 停车位最多100个<br> 输出描述：<br> 输出一个整数记录最大距离</p> 
<p>示例1：<br> 输入<br> 1,0,0,0,0,1,0,0,1,0,1<br> 输出<br> 2<br> 说明<br> 当车停在第3个位置上时，离其最近的车距为2（1到3）<br> 当车停在第4个位置上时，离其最近的车间为2（4到6）<br> 其他位置距离为1.<br> 因此最大距离为2<br> 19<br> 36. 找朋友<br> 在学校中，N个小朋友站成一队，第i个小朋友的身高为height[i]<br> 第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友（要求j&gt;i）。<br> 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。<br> 小朋友人数范围是[0， 40000]</p> 
<p>输入描述：<br> 第一行输入N，N表示有N个小朋友<br> 第二行输入N个小朋友的身高height[i]，都是整数</p> 
<p>输出描述：<br> 输出N个小朋友的好朋友位置</p> 
<p>示例1：<br> 输入<br> 2<br> 100 95<br> 输出<br> 0 0</p> 
<p>说明<br> 第一个小朋友身高100， 站在队尾位置，向队首看，没有比他身高高的小朋友，所以输出第一个值为0。<br> 第二个小朋友站在队首，前面也没有比他身高跟高的小朋友，所以输出的第二个值为0</p> 
<p>示例2：<br> 输入<br> 8<br> 123 124 125 121 119 122 126 123<br> 输出<br> 1 2 6 5 5 6 0 0 </p> 
<p>说明<br> 123的好朋友是1位置上的124<br> 124的好朋友是2位置上的125<br> 125的好朋友是6位置上的126<br> 其他类推</p> 
<p>提示：这是个典型的单调栈题目<br> 37<br> 37. 整数编码<br> 实现一种整数编码的方法，使得待编码的数字越小，编码后所占用的字节数越小，编码后所占用的字节数越小。<br> 编码规则如下：<br> 编码时7位一组，每个字节的低7位用于存储待编码数字的补码。<br> 字节的最高位表示后序是否还有字节，置1表示后面还有更多的字节，置0表示当前字节为最后一个字节。<br> 采用小端字节序编码，低位和低字节放在低地址上。<br> 编码结果按照16进制数的字符格式输出，小写字母需要转换成大写字母。</p> 
<p>输入描述：<br> 输入为一个字符串表示的非负整数</p> 
<p>输出描述：<br> 输出一个字符串，表示整数编码的16进制码流</p> 
<p>示例1：<br> 输入<br> 0<br> 输出<br> 00<br> 说明<br> 输出的16进制字符，不足两位的前面补0，如：00、01、02等。</p> 
<p>示例2：<br> 输入<br> 100<br> 输出<br> 64<br> 说明<br> 100的二进制表示为0110 0100， 只需要一个字节进行编码，字节的最高位置0，剩余7位存储数字100的低7位(110 0100)，再转换成16进制输出为64.</p> 
<p>示例3：<br> 输入<br> 1000<br> 输出<br> E807<br> 说明<br> 1000的二进制表示为0011 1110 1000，至少需要两个字节进行编码<br> 第一个字节最高位置1，剩余的7位存储数字1000的第一个低7位（110 1000），所以第一个字节的二进制数为 1110 1000， 即16进制的E8<br> 第二个字节最高位置0，剩余的7位存储数字1000的第二个低7位（000 0111），所以第二个字节的二进制数为 0000 0111， 即16进制的07<br> 结果需要采用小端序编码，所以低字节E8输出在前，高字节07输出在后。</p> 
<p>备注：待编码的数字取值范围为[0，1 &lt;&lt; 64 - 1]<br> 41<br> 38. 整数对最小和<br> 给定两个整数数组array1、array2，数组元素按升序排列。假设从array1、array2中分别取出一个元素可构成一个元素对，现在需要取出k对元素，并对取出的所有元素求和，计算总和的最小值。<br> 注意：两对元素如果对应于array1、array2中两个下标均相同，则视为同一对元素。</p> 
<p>输入描述：<br> 输入两行数组array1、array2，每行首个数字为数组大小size ( 0 &lt; size &lt;= 100)，元素值小于1000.<br> 第三行为一个正整数k。0 &lt; k &lt;= array1.size() * array2.size()</p> 
<p>输出描述：<br> 满足要求的最小和</p> 
<p>示例1：<br> 输入<br> 3 1 1 2<br> 3 1 2 3<br> 2<br> 输出<br> 4<br> 说明<br> 用例中，需要取2对元素<br> 取array1中第0个元素和array2中第0个元素组成1对元素[1,1]；<br> 取array1中第1个元素和array2中第0个元素组成1个元素[1,1];<br> 对这两个元素对求和：1+1+1+1=4，为满足要求的最小和。<br> 39. 字符串变换最小字符串<br> 给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串(按字典序方式比较)<br> 变换规则：交换字符串中任意两个不同位置的字符</p> 
<p>输入描述：<br> 一串小写字母组成的字符串s<br> 输出描述：<br> 按照要求变换得到的最小字符串</p> 
<p>示例1：<br> 输入<br> abcdef<br> 输出<br> abcdef<br> 说明<br> abcdef已经是字典序中的最小字符串了，直接输出即可。</p> 
<p>示例2：<br> 输入<br> bcdefa<br> 输出<br> acdefb<br> 说明<br> a和b互换位置，可得到最小字符串</p> 
<p>备注：s都是小写字符组成的，长度小于1000<br> 25<br> 40. 字符串筛选排序<br> 输入一个由n个大小写字母组成的字符串，按照ASCII码值从小到大排序规则，查找字符串中第k个最小ASCII码值的字母(其中，k&gt;=1)，输出该字母所在字符串的位置索引（字符串索引以0开始）。<br> k如果大于字符串长度，则输出最大ASCII值的字母所在字符串的位置索引，如果由重复字母，则输出字母的最小位置索引。</p> 
<p>输入描述：<br> 第一行输入一个由大小写字母组成的字符串<br> 第二行输入k，k必须要大于0，k可以大于字符串的长度<br> 输出描述：<br> 输出字符串中第k个最小ASCII码值的字母所在字符串的位置索引，</p> 
<p>示例1：<br> 输入<br> AbCdeFG<br> 3<br> 输出<br> 5<br> 说明<br> 根据ASCII码值排序，第三个最小ASCII码值的字母为F，F在字符串中的位置索引为5（以0开始）</p> 
<p>示例2：<br> 输入<br> fAdDAkBbBq<br> 4<br> 输出<br> 6<br> 说明<br> 根据ASCII码值排序，前4个字母为AABB，由于B重复，则只取B的(第一个)最小位置索引6，而不是第二个位置索引8<br> 41. 字符串统计<br> 给定两个字符集合，一个为全量字符集，一个为已占用字符集。已占用的字符集中的字符不能再使用，要求输出剩余可用的字符集。</p> 
<p>输入描述：<br> 输入为一个字符串，一定包含@字符。@前的为全量字符集，@后为已占用的字符集<br> 已占用字符集中的字符一定是全量字符集中的字符。字符集中的字符跟字符之间使用英文逗号分隔。<br> 每个字符都表示为字符加数字的形式，用英文冒号分隔，比如a:1，表示有一个a字符。<br> 字符只考虑英文字母，区分大小写，数字只考虑正整数，数量不超过100<br> 如果一个字符都没被占用，@标识仍然会存在，例如a:3,b:5,c:2@</p> 
<p>输出描述：<br> 请输出可用字符集，不同的输入字符集之间用回车换行。<br> 注意，输出的字符顺序要跟输入已知，不能输出b:3,a:2,c:2<br> 如果某个字符已全部被占用，则不需要再输出。</p> 
<p>示例1：<br> 输入<br> a:3,b:5:c:2@a:1,b:2<br> 输出<br> a:2,b:3,c:2<br> 说明<br> 全量字符集为3个a，5个b，2个c<br> 已占用字符集为1个a，2个b<br> 由于已占用字符不能再使用，因此剩余可用字符为2个a，3个b，2个c<br> 因此输出a:2,b:3,c:2<br> 42. 组成最大数<br> 小组中每位都有一张卡片，卡片上是6位数以内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。</p> 
<p>输入描述：<br> “,”号分隔的多个正整数字符串，不需要考虑非数字的异常情况，小组最多25个人<br> 输出描述：<br> 最大的数字字符串</p> 
<p>示例1：<br> 输入<br> 22，221<br> 输出<br> 22221</p> 
<p>示例2：<br> 输入<br> 4589,101,41425,9999<br> 输出<br> 18<br> 43. 最长连续方波信号<br> 输入一串方波信号，求取最长的完全连续交替的方波信号，并将其输出。如果有长度相同的交替方波信号，输出任一即可。方波信号的高位用1标识，低位用0标识。如：<br> 001010101010000101000<br> 说明<br> 一个完整的信号一定以0开始，最后以0结尾。如：010是一个完整信号，但101、1010、0101则不是一个完整信号。<br> 输入的一串方波信号是由一个或多个完整信号组成<br> 两个相邻信号之间可能由0个或者多个低位（注意低位使用0标识），如：0110010包含了两个信号，中间没有低位。011000010两个信号间有两个低位0<br> 同一个信号中可以有连续的高位，如01110101011110001010，前14为是一个具有连续高位的信号<br> 完全连续交替方波是指10交替，如01010是完全连续交替方波，而0110则不是</p> 
<p>输入描述：<br> 输入一个信号字符串，长度范围[3,1024]，如：0010101010110000101000010<br> 注：输入总是合法的，不用考虑非法场景</p> 
<p>输出描述：<br> 输出最长的完全连续交替方波信号串，如：01010<br> 如果不存在完全连续交替方波信号串，则输出-1</p> 
<p>示例说明<br> 上面例子中，有三个信号，已经用红色标记出来，第一个虽然有交替的方波信号段，但是出现了11这种连续高位，不能算作是完全连续交替方波，剩下的最长完全连续交替方波只能是01010<br> 19<br> 44. 最长子字符串的长度<br> 给你一个字符串s，字符串s首尾相连形成一个环形，请你在环中找出‘o’字符出现了偶数次最长子字符串的长度。</p> 
<p>输入描述：<br> 输入是一串小写字母组成的字符串<br> 输出描述：<br> 输出是一个整数</p> 
<p>示例1：<br> 输入<br> alolobo<br> 输出<br> 6<br> 说明<br> 最长子字符串之一是“alolob”，它包含‘o’2个</p> 
<p>示例2：<br> 输入<br> looxdolx<br> 输出<br> 7<br> 说明<br> 最长子字符串是“oxdolxl”,由于是首尾连接在一起的，所以最后一个‘x’和开头的‘l’是连接在一起的，此字符串包含2个‘o’。</p> 
<p>示例3：<br> 输入<br> bcbcbc<br> 输出<br> 6<br> 说明<br> 这个示例中，字符串“bcbcbc”本身就是最长的，因为‘o’出现了0次。</p> 
<p>备注：1 &lt;= s.length &lt;= 5 * 10^5<br> 45. 素数之积<br> RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高，给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。</p> 
<p>输入描述：<br> 一个正整数num（0 &lt; num &lt;= 2147483647）<br> 输出描述：<br> 如果成功找到，以单个空格分隔，从小到大输出两个素数，分解失败，请输出-1 -1</p> 
<p>示例1：<br> 输入<br> 15<br> 输出<br> 3 5<br> 说明<br> 因数分解后，找到了两个素数3和5，使得3 * 5 = 15， 按从小到大排列后，输出3 5</p> 
<p>示例2<br> 输入<br> 27<br> 输出<br> -1 -1<br> 说明<br> 通过因数分解，无法找到任何素数乘积为27，输出-1 -1<br> 46. 5键键盘的输出<br> 有个特殊的键盘，它只有a、ctrl-c、ctrl-x、ctrl-v，ctrl-a五个键。a键可以在屏幕上输出一个字母a；ctrl-c可以将当前选择的字母复制到剪贴板；ctrl-x可以将选择的字母剪切到剪贴板；ctrl-v可以将剪切板中的字母输出到屏幕上；ctrl-a选择当前屏幕上的所有字母。注意：<br> 剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容<br> 当屏幕上没有字母时，ctrl-a无效<br> 当没有选择字母时，ctrl-c和ctrl-x无效<br> 当有字母被选择时，a和ctrl-v这两个输出功能的键会先清空选择的字母，再进行输出<br> 给定一个键盘输入序列，请输出最终输出到屏幕上的字母的数量</p> 
<p>输入描述：<br> 输入为一行，用数字1 2 3 4 5代表a、ctrl-c、ctrl-x、ctrl-v、ctrl-a五个键的输入<br> 输出描述：<br> 输出一个数字，为最终屏幕上字母的数量</p> 
<p>示例1：<br> 输入<br> 1 1 1<br> 输出<br> 3<br> 说明<br> 屏幕上有三个a</p> 
<p>示例2：<br> 输入<br> 1 1 5 1 5 2 4 4<br> 输出<br> 47. N进制减法<br> 实现个基于字符串的N进制的减法<br> 需要对输入的两个字符串按照给定的N进制进行减法操作，输出正负符号和表示结果的字符串</p> 
<p>输入描述：<br> 输入包括三个参数。<br> 第一个参数时整数形式的N进制，N的范围大于等于2，小于等于35（26个字母加上0-9）<br> 第二个参数为被减数的字符串<br> 第三个参数为减数字符串，有效的字符包括0-9以及小写字母a-z，字符串有效字符个数最多100个字符，另外还有结尾的\0</p> 
<p>限制：<br> 输入的被减数和减数，除了单独的0以外，不能是以0开头的字符串<br> 如果输入有异常或者计算过程中有异常，此时应该输出-1表示错误</p> 
<p>输出描述：<br> 输出两个数<br> 第一个为减法计算的结果，-1表示出错，0表示结果为正数，1表示结果为负数<br> 第二个数表示结果的字符串</p> 
<p>示例1：<br> 输入<br> 2 11 1<br> 输出<br> 0 10<br> 说明<br> 按二进制计算 11 - 1， 计算正常，0表示符号为正数，结果为10</p> 
<p>示例2：<br> 输入<br> 8 07 1<br> 输出<br> -1<br> 说明<br> 按8进制，检查到减数不符合非前导0的要求，返回结果为-1，没有其他结果内容<br> 33<br> 48. VLAN资源池<br> VLAN是一种对局域网设备进行逻辑划分的技术，为了标识不同的VLAN，引入VLAN ID(1~4094之间的整数)的概念。定义一个VLAN ID资源池(下称VLAN资源池)，资源池中连续的VLAN用“开始VLAN-结束VLAN”来表示，不连续的用单个整数来表示，所有的VLAN用英文逗号连接起来。现在有个VLAN资源池，业务需要从资源池中申请一个VLAN，需要你输出从VLAN资源池中移除申请的VLAN后的资源池。</p> 
<p>输入描述：<br> 第一行字符串格式的VLAN资源池<br> 第二行为业务要申请的VLAN，VLAN取值范围为[1,4094]之间的整数。<br> 输出描述：<br> 从输入VLAN资源池中移除申请的VLAN后的以字符串格式表示VLAN资源池，输出要满足题目描述中的格式，并且按照VLAN从小到大升序输出。</p> 
<p>示例1：<br> 输入<br> 1-5<br> 2<br> 输出<br> 1,3-5<br> 说明<br> 原VLAN资源池中有VLAN 1、2、3、4、5，从资源池中移除2之后，剩下VLAN  1、3、4、5，按照题目描述的格式结果为：1,3-5</p> 
<p>示例2：<br> 输入<br> 20-21,15,18,30,5-10<br> 15<br> 输出<br> 5-10,18,20-21,30<br> 说明<br> 原VLAN资源池中有VLAN 5、6、7、8、9、10、15、18、20、21、30，从资源池中移除15后，还剩下5、6、7、8、9、10、18、20、21、30，按照升序格式输出为：5-10,18,20-21,30</p> 
<p>示例3：<br> 输入<br> 5,1-3<br> 10<br> 输出<br> 1-3,5<br> 说明<br> 原VLAN资源池中有VLAN 1、2、3、5，申请VLAN 10 不在资源池中，所以最终资源池按升序表示为：1-3,5</p> 
<p>备注：<br> 资源池中VLAN不重复且合法([1,4094]间的整数)，输入是乱序的<br> 37<br> 49. 报数游戏<br> 100个人围成一圈，每个人有一个编码，编号从1开始到100.他们从1开始依次报数，报到M的人自动退出圆圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。请问最后剩余的人在原先的编号是多少？</p> 
<p>输入描述：<br> 输入一个整数参数M<br> 输出描述：<br> 如果输入参数M小于等于1或者大于等于100，输出”ERROR!”；否则按照原来的编号从小到大的顺序，以英文逗号分隔输出编号字符串</p> 
<p>示例1：<br> 输入<br> 3<br> 输出<br> 58,91<br> 说明<br> 输入M为3，最终剩下两个人</p> 
<p>示例2：<br> 输入<br> 4<br> 输出<br> 34,45,97<br> 说明<br> 输入M为4，最终剩下3个人</p> 
<p>注意审题，跟约瑟夫环有点像，但是人数小于M就会停下来<br> 50. 查找众数及中位数<br> 众数是指一组数据中出现次数最多的那个数，众数可以是多个<br> 中位数是指把一组数据从小到大排序后，如果这组数据的总数是奇数，那最中间的那个数就是中位数；如果这组数据总数是偶数，那么就把中间两个数求和再除以2，作为中位数。<br> 查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数。</p> 
<p>输入描述：<br> 输入一个一维整型数组，数组大小为0-1000，数组中每个元素取值范围是0-1000<br> 输出描述：<br> 输出众数组成的新数组的中位数</p> 
<p>示例1：<br> 输入<br> 10 11 21 19 21 17 21 16 21 18 15<br> 输出<br> 21</p> 
<p>示例2：<br> 输入<br> 2 1 5 4 3 3 9 2 7 4 6 2 15 4 2 4<br> 输出<br> 3</p> 
<p>示例3：<br> 输入<br> 5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39<br> 输出<br> 26<br> 51. 单词接龙<br> 现在给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙，请输出最长的单词串，单词串是单词拼接而成，中间没有空格。</p> 
<p>输入描述：<br> 输入的第一行为一个非负整数，表示其实单词再数组中的索引K，0 &lt;=K &lt; N，索引从0开始。<br> 输入的第二行为一个非负整数，表示单词的个数N<br> 接下来的N行，分别表示单词数组中的单词。<br> 输出描述：<br> 输出一个字符串，表示最终拼接的最长单词串</p> 
<p>示例1：<br> 输入<br> 0<br> 6<br> word<br> dd<br> da<br> dc<br> dword<br> d<br> 输出<br> worddwordda<br> 说明<br> 先确定起始单词word，再接以d开头的且长度最长的单词dword，剩余以d开头且长度最长的由dd、da、dc，则取字典序最小的da，最后输出worddwordda</p> 
<p>示例2：<br> 输入<br> 4<br> 6<br> word<br> dd<br> da<br> dc<br> dword<br> d<br> 输出<br> dwordda<br> 说明<br> 先确定起始单词dword，剩余以d开头且长度最长的由dd、da、dc，则取字典序最小的da，所以最后输出dwordda</p> 
<p><br> 第K个排列<br> 给定参数n，从1到n会有n个整数：1、2、3、...、n，这n个数字共有n!种排列。<br> 按大小顺序升序列出所有排列的情况，并一一标记，当n=3时，所有排列如下：<br> “123” “132” “213” “231” “312” “321”<br> 给定n和k，返回第k个排列。</p> 
<p>输入描述：<br> 第一行为数字n，给定n的范围是[1,9]<br> 第二行为数字k，给定k的范围是[1,n!]<br> 输出描述：<br> 输出排在第k个位置的数字</p> 
<p>示例1：<br> 输入<br> 3<br> 3<br> 输出<br> 213</p> 
<p>示例2：<br> 输入<br> 2<br> 2<br> 输出<br> 21</p> 
<p>52. 非严格递增连续数字序列<br> 输入一个字符串仅包含大小写字母和数字，求字符串钟包含的最长的非严格递增连续数字序列的长度(比如：12234属于非严格递增连续数字序列)</p> 
<p>输入描述：<br> 输入一个字符串仅包含大小写字母和数字，输入的字符串最大不超过255个字符。<br> 输出描述：<br> 最长的非严格递增连续数字序列的长度</p> 
<p>示例1：<br> 输入<br> abc2234019A334bc<br> 输出<br> 4<br> 说明<br> 2234为最长的非严格递增连续数字序列，所以长度为4<br> 53. 分糖果<br> 小明从糖果盒中随意抓一把糖果，每次小明会取出一半的糖果分给同学们<br> 当糖果不能平均分配时，小明可以选择从糖果盒中(假设盒中糖果足够)取出一个糖果或放回一个糖果。<br> 小明最少需要多少次(取出、放回和平均分配均记一次)，能将手里的糖果分配到只剩下一颗。</p> 
<p>输入描述：<br> 抓取的糖果数<br> 输出描述：<br> 最少分配次数</p> 
<p>示例1：<br> 输入<br> 15<br> 输出<br> 5<br> 说明<br> 第一步、15+1=16<br> 第二步、16/2=8<br> 第三步、8/2=4<br> 第四步、4/2=2<br> 第五步、2/2=1<br> 54. 服务失效判断<br> 某个系统由多个服务，每个服务用字符串(字母和数字组成，长度小于等于10)来唯一标识，服务间可能有依赖关系，如A依赖B，则当B故障时将导致A也故障。<br> 依赖同时也具有传递性，如果A依赖B、B依赖C，如果C出现了故障，那也导致A故障。<br> 给出所有的依赖关系，以及当前已知的故障服务，要求输出所有正常的服务。<br> 依赖关系描述：服务1-服务2， 表示”服务1”依赖”服务2”<br> 不必考虑异常输入的场景</p> 
<p>输入描述：<br> 第一行输入以半角逗号分隔的依赖关系列表<br> 第二行输入以半角逗号分隔的故障服务列表<br> 输出描述：<br> 依赖关系列表中提及的所有服务中可以正常工作的服务列表，用半角逗号分隔，并按依赖关系列表中出现的次序排序。如果没有正常工作的服务，请输出一个单独的半角逗号。</p> 
<p>示例1：<br> 输入<br> a1-a2,a5-a6,a2-a3<br> a5,a2<br> 输出<br> a6,a3<br> 说明<br> a1依赖a2，a2依赖a3，所以a2故障后，导致a1不可用，但不影响a3；<br> a5故障不影响a6.所以最终可用的是a3和a6。依赖关系中a6先出现，所以输出a6,a3</p> 
<p>示例2：<br> 输入<br> a1-a2<br> a2<br> 输出<br> ,<br> 说明<br> a2故障导致a1也故障，没有可用服务，直接输出半角逗号<br> 55. 高矮个子排队<br> 现在有一队小朋友，他们高矮不同，我们以正整数数组表示这一队小朋友的身高，如数组{5,3,1,2,3}。我们现在希望小朋友排队，以”高””矮””高””矮”的顺序排列，每个”高”位置的小朋友要不相邻位置高或者相等；每个”矮”位置的小朋友要比相邻的位置矮或者相等。排列过程中要求小朋友们移动的距离之和最小，第一个位置从”高”开始排，输出最小的移动距离。例如，在示范小队{5,3,1,2,3}中，{5,1,3,2,3}是排序结果。虽然{5,2,3,1,3}也是满足”高””矮””高””矮”的顺序排列，但是小朋友们的移动距离大，所以不是最优解。<br> 移动距离的定义：第二个小朋友移到第三位小朋友的后面，移动距离为1；若移动到第四位小朋友后面，移动距离为2；</p> 
<p>输入描述：<br> 排序前的小朋友（数量小于100个），以英文空格分隔的正整数，比如：4 3 5 7 8<br> 输出描述：<br> 排序后的小朋友，以英文空格分隔的正整数，比如：4 3 7 5 8。<br> 4(高) 3(矮) 7(高) 5(矮) 8(高) 只有5和7交换了位置，移动距离总和为1.</p> 
<p>示例1：<br> 输入<br> 4 1 3 5 2<br> 输出<br> 4 1 5 2 3</p> 
<p>示例2：<br> 输入<br> 1 1 1 1 1<br> 输出<br> 1 1 1 1 1</p> 
<p>示例3：<br> 输入<br> xxx<br> 输出<br> []<br> 说明<br> 如果出现非法参数的情况，直接返回空数组<br> 56. 勾股数元组<br> 如果3个正整数(a,b,c)满足 a^2 + b^2 = c^2, 则称a,b,c为勾股数，为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间都互质，没有公约数），则其为勾股数元组（例如：3、4、5是勾股数元组， 6、8、10则不是）。请求除给定范围[N,M]内，所有的勾股数元组。</p> 
<p>输入描述：<br> 第一行，起始范围N， 1 &lt;= N &lt;= 10000<br> 第二行，结束范围M， 1 &lt;= M &lt;= 10000<br> 输出描述：<br> a，b，c请保证 a &lt; b &lt; c，输出以空格分隔，如：a b c<br> 多组勾股数元组请按照a升序、b升序、最后c升序的方式排列输出<br> 给定范围中如果找不到勾股数元组时，输出”NA”。</p> 
<p>示例1<br> 输入<br> 输出<br> 3 4 5<br> 5 12 13<br> 8 15 17</p> 
<p>示例2：<br> 输入<br> 输出<br> NA<br> 25<br> 57. 喊7的次数重排<br> 喊7是一个传统游戏，N个人围成一圈，按顺时针从1到N编号。编号为1的人从1开始喊数，下一个人喊的数字为上一个人的数字加1，但是如果将要喊出的数字是7或者是7的倍数或者数字本身包含7的话，不能把这个数字直接喊出来，而是要喊“过”。假定玩这个游戏的N个人都没有失误在正确的时机喊了“过”，当喊到数字K时，可以统计每个人喊“过”的次数。</p> 
<p>现在给定一个长度为N的数组，存储了打乱顺序的每个人喊“过”的次数，请把它还原成为正确的顺序，即数组的第i个人存储编号i的人喊“过”的次数。</p> 
<p>输入描述：<br> 输入为一行数字，代表以空格分隔的喊“过”的次数。注意K的具体值不会作为输入提供，但K肯定不超过200，而数字的个数即为题目中的N的大小。<br> 输出描述：<br> 输出为一行，为顺序正确的喊“过”的次数，也由空格分隔。</p> 
<p>示例1：<br> 输入<br> 0 1 0<br> 输出<br> 1 0 0<br> 说明<br> 一共只有一次喊“过”，那只会发生在第一次喊7的时候，按照顺序，编号为1的人会遇到7，所以输出应该为 1 0 0。注意,结束的时候不一定7，也可以是8、9等，这样喊“过”的次数也是1 0 0</p> 
<p>示例2：<br> 输入<br> 0 0 0 2 1<br> 输出<br> 0 2 0 1 0<br> 说明<br> 一共三次喊“过”，发生在数字7、14、17上，按顺序，编号为2的人会遇到7、17.编号为4的人会遇到14。所以输出为 0 2 0 1 0<br> 58. 滑动窗口最大和<br> 有一个N个整数的数组，和一个个长度为M的窗口，窗口从数组内的第一个数开始滑动直到窗口不能滑动为止，每次窗口滑动产生一个窗口和(窗口内所有数的和)，求窗口滑动产生的所有窗口和的最大值。</p> 
<p>输入描述：<br> 第一行输入一个正整数N，表示整数个数<br> 第二行输入N个整数<br> 第三行输入一个正整数M，代表窗口的大小<br> 输出描述：<br> 窗口滑动产生的所有窗口和的最大值</p> 
<p>示例1：<br> 输入<br> 6<br> 10 20 30 15 23 12<br> 3<br> 输出<br> 68</p> 
<p>说明<br> 窗口长度为3，窗口滑动产生的窗口和分别为10+20+30=60,20+30+15=65,30+15+23=68,15+23+12=50。<br> 19<br> 59. 火星文计算<br> 已知火星人使用的运算符为#、$，其与地球人的等价公式如下：<br> x#y = 2*x + 3*y + 4<br> x$y = 3*x + y + 2<br> 其中x、y是无符号整数<br> 地球人公式按C语言规则计算<br> 火星人公式中，$的优先级高于#，相同的运算符，按从左到右的顺序计算<br> 现在有一段火星人的字符串报文，请你来翻译并计算结果。</p> 
<p>输入描述：<br> 火星人字符串表达式(结尾不带回车换行)<br> 输入的字符串说明：<br> 字符串仅为由无符号整数和操作符(#、$)组成的计算表达式，例如：123#4$5#67$78<br> 用例保证字符串中，操作数和操作符之间没有任何分隔符<br> 用例保证操作数取值范围为32位无符号整数<br> 保证输入以及计算结果不会出现整数溢出。<br> 保证输入的字符串为合法的求值报文<br> 保证不会出现非法的求值报文</p> 
<p>输出描述：<br> 根据输入的火星文字符串输出计算结果（结尾不带回车换行）</p> 
<p>示例1：<br> 输入<br> 7#6$5#12<br> 输出<br> 226<br> 说明<br> 7#6$5#12<br> =7#(3*6+5+2)#12<br> =7#25#12<br> =(2*7+3*25+4)#12<br> =93#12<br> =2*93+3*12+4<br> =226<br> 60. We are a team<br> 总共有n个人在机房，每个人有一个标号，他们分成了多个团队，需要你根据收到的m条消息判定指定的两个人是否在一个团队中，具体的描述如下：<br> 消息构成为：a b c，整数a、b分别代表了两个人的标号，整数c代表指令。<br> c==0代表a和b在同一个团队内。<br> c==1代表需要判定a和b的关系，如果a和b是一个团队，输出一行“we are a team”，如果不是，输出一行“we are not a team”<br> c为其他值，或当前行a或b超出1~n的范围，输出“da pian zi”</p> 
<p>输入描述：<br> 第一行包含两个整数n,m；分别表示有n个人和m条消息。（1 &lt;= n,m &lt;= 100000）<br> 随后的m行，每行一条消息，消息格式为：a b c（1 &lt;= a, b &lt;= n，0 &lt;= c &lt;= 1）。<br> 输出描述：<br> c==1时，根据a和b是否在一个团队中输出一行字符串，在一个团队中输出“we are a team”.不在同一个团队中输出“we are not a team”<br> c为其他值，或当前行a或b的标号小于1或者大于n时，输出字符串“da pian zi”<br> 如果第一行n和m的值超出了约定的范围时，输出字符串“NULL”</p> 
<p>示例1：<br> 输入<br> 5 6<br> 1 2 0<br> 1 2 1<br> 1 5 0<br> 2 3 1<br> 2 5 1<br> 1 3 2<br> 输出<br> we are a team<br> we are not a team<br> we are a team<br> da pian zi</p> 
<p>说明<br> 第2行定义了1和2属同一个团队<br> 第3行要求进行判断，输出“we are a team”<br> 第4行定义了1和5是一个团队，自然2和5也就是同一个团队了。<br> 第5行要求进行判定，输出“we are not a team”<br> 第6行要求进行判定，输出“we are a team”<br> 第7行c为其他值，输出“da pian zi”<br> 61. 猜密码<br> 小杨申请了一个保密柜，但是她忘记了密码。只记得密码都是数字，而且所有数字都不重复的。请你根据她记住的数字范围和密码的最小数字数量，帮她算下有哪些可能的组合，规则如下：<br> 输出的组合都是从可选的数字范围中选取的，且不能重复<br> 输出的密码数字要按照从小到大的顺序排列，密码组合需要按照字母顺序，从小到大排序<br> 输出的每一个组合的数字的数量要大于等于密码最小数字的数量<br> 如果可能的组合为空，则返回“None”</p> 
<p>输入描述：<br> 输入的第一行时可能的密码数字列表，数字间以半角逗号分隔<br> 输入的第二行时密码最小数字数量<br> 输出描述：<br> 可能的密码组合，每种组合显示成一行，每个组合内部的数字以半角逗号分隔，从小到大排序。输出的组合间需要按照字典序排序。比如：2,3,4放到2,4的前面。</p> 
<p>示例1：<br> 输入<br> 2,3,4<br> 2<br> 输出<br> 2,3<br> 2,3,4<br> 2,4<br> 3,4<br> 说明<br> 最小密码数量是两个，可能有三种组合：<br> 2,3<br> 2,4<br> 3,4<br> 三个数字的组合有一种：<br> 2,3,4</p> 
<p>示例2：<br> 输入<br> 2,0<br> 1<br> 输出<br> 0<br> 0,2<br> 2<br> 说明<br> 可能的密码组合，一个的有两种：<br> 两个的有一种：<br> 0,2<br> 43<br> 62. 出错的或电路<br> 某生产门电路的厂商发现某一批次的或门电路不稳地，具体现象为计算两个二进制数的或操作时，第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。很明显，这个交换可能会影响最终的或结果，也可能不会有影响。为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。</p> 
<p>输入描述：<br> 第一行有一个正整数N，其中，<br> 第二行有一个长度为N的二进制数，表示或电路的第一个输入数，即会发生比特交换的输入数。<br> 第三行有一个长度为N的二进制数，表示或电路的第二个输入数，注意第二个输入数不会发生比特交换。</p> 
<p>输出描述：<br> 输出是有一个整数，表示会影响或结果的交换方案的个数。</p> 
<p>示例1：<br> 输入<br> 110<br> 输出<br> 1<br> 说明<br> 原本010和110的或结果为110，但是第一个输入数可能会发生如下3种交换：<br> 交换第1和第2个比特位，第一个输入数变成了100，计算结果为110，不影响结果<br> 交换第1和第3个比特位，第一个输入数变成了010，计算结果为110，不影响结果<br> 交换第2和第3个比特位，第一个输入数变成了001，计算结果为111，结果改变<br> 故，只有一种情况会改变结果</p> 
<p>示例2：<br> 输入<br> 110110<br> 输出<br> 4</p> 
<p>说明<br> 原本011011和110110的或结果是111111，但第一个输入数可能会发生如下的交换：<br> 交换第1、3比特，第一个输入数变成了110011，结果变成了110111<br> 交换第1、6比特，第一个输入数变成了111010，结果变成了111110<br> 交换第3、4比特，第一个输入数变成了010111，结果变成了110111<br> 交换第4、6比特，第一个输入数变成了011110，结果变成了111110<br> 其他的交换都不会影响结果，故输出4<br> 39<br> 63. 德州扑克<br> 五张牌，每张牌由牌大小和花色组成，牌大小2~10、J、Q、K、A，牌的花色为红桃、黑桃、梅花、方块四种之一。判断牌型：<br> 牌型1，同花顺：同一花色的顺子，如：红桃2、红桃3、红桃4、红桃5、红桃6<br> 牌型2，四条：四张相同的数字 + 单张，如：红桃A黑桃A梅花A方块A + 黑桃K<br> 牌型3，葫芦：三张相同数字 + 一对，如：红桃5黑桃5梅花5 + 方块9梅花9<br> 牌型4，同花：同一花色，如：方块3方块7方块10方块J方块Q<br> 牌型5，顺子：花色不一样的顺子，如：红桃2黑桃3红桃4红桃5红桃6<br> 牌型6，三条：三张相同 + 两张单<br> 牌型7，其他</p> 
<p>说明：<br> 五张牌里不会出现牌大小和花色完全相同的牌<br> 编号小的牌型较大，如果同花顺比四条大，依次类推<br> 包含A的合法顺子只有10、J、Q、K、A和A、2、3、4、5，类似K、A、2、3、4的序列不认为是顺子</p> 
<p>输入描述：<br> 输入由5行组成，每行为一张牌的大小和花色，花色用字符H、S、C、D分别表示红桃、黑桃、梅花、方块<br> 输出描述：<br> 输出牌型的序号，5张牌符合多种牌型时，取最大的牌型序号输出。</p> 
<p>示例1：<br> 输入<br> 4 H<br> 5 S<br> 6 C<br> 7 D<br> 8 D<br> 输出<br> 5<br> 说明<br> 这可以构成一个顺子，故输出牌型5</p> 
<p>示例2：<br> 输入<br> 9 S<br> 5 S<br> 6 S<br> 7 S<br> 8 S<br> 输出<br> 1<br> 说明<br> 既是顺子也是同花，输出1，同花顺<br> 64. 叠积木<br> 有一堆长方体积木，它们的宽度和高度都相同，但长度不一。小橙想把这堆积木叠成一面墙，墙的每层可以放一个积木，也可以将两个积木拼接起来，要求每层的长度相同。若必须用完这些积木，叠成的墙最多为多少层？</p> 
<p>输入描述：<br> 输入为一行由空格分隔的数，代表各个积木的长度，数字为正整数。数量和大小不超过5000<br> 输出描述：<br> 输出为一个数字，表示墙的最大层数，如果无法按照要求叠成每层长度一致的墙，输出-1</p> 
<p>示例1：<br> 输入<br> 3 6 6 3<br> 输出<br> 3<br> 说明<br> 可以每层都是长度3和长度6的积木拼接起来，这样每层长度为9，可以叠2层。也可以每层长度为6，将两个长度为3的积木拼接，这样可以叠三层。故输出3</p> 
<p>示例2：<br> 输入<br> 1 4 2 3 6 <br> 输出<br> -1<br> 无法完成每层长度一样的叠法。注意不要认为全部拼在一起，只叠一层。这种不满足题意。<br> 21<br> 65. 二叉树遍历<br> 根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为：左子树、根结点、右子树。</p> 
<p>输入描述：<br> 由大小写字母，左右大括号、逗号组成的字符串<br> 字母代表一个节点值，左右括号包含该节点的子节点。<br> 左右子节点使用逗号分隔，逗号前为空则表示左子节点为空，没有逗号则表示右子节点为空。<br> 二叉树节点的数量最大为100<br> 注意：输入的字符串保证正确，无需考虑异常输入的情况</p> 
<p>输出描述：<br> 输出一个字符串，为二叉树中序遍历个节点值的拼接结果</p> 
<p>示例1：<br> 输入<br> a{b{d,e{g,h{,i}}},c{f}}<br> 输出<br> dbgehiafc<br> 17<br> 66. 二叉树的广度优先遍历<br> 二叉树每个节点由一个大写字母标识(最多26个节点)。现在有两组字母，分别表示后序遍历(左孩子-&gt;右孩子-&gt;父节点)和中序遍历(左孩子-&gt;父节点-&gt;右孩子)的结果，请输出层次遍历(逐层遍历)的结果。</p> 
<p>输入描述：<br> 输入为两个字符串，分别是二叉树后序和中序遍历的结果<br> 输出描述：<br> 输出二叉树的层次遍历结果</p> 
<p>示例1：<br> 输入<br> CBEFDA CBAEDF<br> 输出<br> ABDCEF<br> 67. 仿LISP运算<br> LISP语言唯一的语法就是括号要配对。<br> 形如（OP P1 P2 ...），括号内元素由单个空格分隔。<br> 其中第一个元素OP为操作符，后序元素均为其参数，参数个数取决于操作的类型。<br> 注意：参数P1、P2也有可能是另外一个嵌套的（OP P1 P2 ...）<br> 当前OP的类型分为：add / sub / mul / div（全小写），分别代表整数的加减乘除法<br> 简单起见，所有OP参数均为2个<br> 举例：<br> - 输入：（mul 3 -7） 输出：-21<br> - 输入：（add 1 2） 输出：3<br> - 输入：（sub（mul 2 4） （div 9 3）） 输出：5<br> - 输入：（div 1 0）输出：error<br> 题目涉及数字均为整数，可能为负数，不考虑32位溢出翻转问题<br> 除零错误时，输出“error”，除法除不尽的情况，向下取整，即 3/2 = 1</p> 
<p>输入描述：<br> 输入为长度不超过512的字符串，用例保证里无语法错误<br> 输出描述：<br> 输出计算结果或者“error”</p> 
<p>示例1：<br> 输入<br> (div 12 (sub 45 45))<br> 输出<br> error<br> 45-45=0，12/0出现除零错误，输出error</p> 
<p>示例2：<br> 输入<br> (add 1 (div -7 3))<br> 输出<br> -2<br> 说明<br> -7/3向下取整为-3，1加-3等于-2<br> 33<br> 68. 分积木<br> Solo和Koko是两兄弟，妈妈给了他们一大堆积木，每块积木上都有自己的重量，现在他们想要将这些积木分成两堆。哥哥solo负责分配，弟弟koko要求两个人获得的积木总重量“相等”（需要根据koko的逻辑来判断是否相等），个数可以不同，不然就会哭，看koko只会先将两个数转成二进制再进行加法，而且总会忘记进位（每个进位都忘记）。如：当25(11101)加11(1011)时，koko得到的计算结果是18(10010)。Solo想要尽可能使自己的积木总重量最大，且不让koko哭。</p> 
<p>输入描述：<br> 3<br> 3 5 6<br> 第一行是一个整数，表示有多少块积木<br> 第二行是空格分开的N个整数，表示第i块积木的重量</p> 
<p>输出描述：<br> 11<br> 让koko不哭，输出solo所能获得积木的最大总重量，否则输出“NO”</p> 
<p>示例1：<br> 输入<br> 3<br> 3 5 6<br> 输出<br> 11<br> 说明<br> Solo能获得重量为5和6的两块积木，5(101)，6(110)，按照koko的计算方法，结果为11(二进制)。Koko看到自己获得了重量为3(11)的那块积木。这样他们两人都获得了重量为11(二进制)的积木。而实际solo获得的积木总重量为11.故输出11<br> 69. 分月饼<br> 公司分月饼，m个员工，买了n个月饼，m &lt;= n，每个员工至少分一个月饼，但是也可以分到多个，单人分到最多月饼的个数是Max1，单人分到第二多月饼个数是Max2。<br> 但需要满足Max1-Max2 &lt;= 3，单人分到第n-1多月饼个数是Max(n-1)，单人分到第n多月饼个数是Max(n), 想要满足Max(n-1) - Max(n) &lt;= 3，问有多少种分月饼的方法？</p> 
<p>输入描述：<br> 每一行输入m，n，表示m个员工，n个月饼，m &lt;=n</p> 
<p>输出描述：<br> 输出有多少种分法</p> 
<p>示例1：<br> 输入<br> 2 4<br> 输出<br> 2<br> 说明<br> 4=1+3<br> 4=2+2<br> 注意：1+3和3+1要算成同一种分法</p> 
<p>示例2：<br> 输入<br> 3 5<br> 输出<br> 2<br> 说明<br> 5=1+1+3<br> 5=1+2+3</p> 
<p>示例3：<br> 输入<br> 3 12<br> 输出<br> 6<br> 说明<br> 满足要求的6种分法：<br> 1、12 = 1 + 1 + 10 （Max1=10， Max2=1，不满足Max1-Max2 &lt;= 3的约束）<br> 2、12 = 1 + 2 + 9  （Max1=9，Max2=2，不满足Max1-Max2 &lt;= 3的约束）<br> 3、12 = 1 + 3 + 8  （Max1=8，Max2=3，不满足Max1-Max2 &lt;= 3的约束）<br> 4、12 = 1 + 4 + 7  （Max1=7，Max2=4，Max3=1， 满足要求）<br> 5、12 = 1 + 5 + 6  （Max1=6，Max2=5，Max3=1， 不满足要求）<br> 6、12 = 2 + 2 + 8  （Max1=8，Max2=2，不满足要求）<br> 7、12 = 2 + 3 + 7  （Max1=7，Max2=3，不满足要求）<br> 8、12 = 2 + 4 + 6  （Max1=6，Max2=4，Max3=2， 满足要求）<br> 9、12 = 2 + 5 + 5  （Max1=5，Max2=2 满足要求）<br> 10、12 = 3 + 3 + 6 （Max1=6，Max2=3 满足要求）<br> 11、12 = 3 + 4 + 5 （Max1=5，Max2=4，Max3=3 满足要求）<br> 12 = 4 + 4 + 4 （Max1=4，满足要求）<br> 47<br> 70. 服务器广播<br> 服务器连接方式包括直接相连、间接相连。A和B直接连接、B和C直接连接，则A和C间接相连。直接和间接连接的都可以发送广播。<br> 给出一个N*N的数组，代表N个服务器，matrix[i][j] == 1，则代表i和j直接相连；不等于1时，代表i和j不直接相连。matrix[i][i] == 1，即自己和自己直接连接。matrix[i][j] == matrix[j][i]。<br> 计算初始需要给几台服务器广播，才可以使每个服务器都收到广播。</p> 
<p>输入描述:<br> 输入为N行，每行有N个数字，为0或1，由空格分隔，构成N*N的数组，N的范围为1&lt;=N&lt;=40<br> 输出描述：<br> 输出一个数字，为需要广播的服务器数量</p> 
<p>示例1：<br> 输入<br> 1 0 0 <br> 0 1 0<br> 0 0 1<br> 输出<br> 3<br> 说明<br> 3台服务器互不相连，所以需要分别广播这三台服务器</p> 
<p>示例2：<br> 输入<br> 1 1<br> 1 1<br> 输出<br> 1<br> 说明<br> 2台服务器相互连接，只需要广播其中一台即可。</p> 
<p>71. 高效的任务规划<br> n台机器编号为1~n，每台都需要完成一项工作，机器经过配置后都能独立完成一项工作。假设第i台机器你需要话Bi分钟时间进行设置，然后开始运行，Ji分钟后完成任务。现在，你需要选择布置工作的顺序，使得能够用最短的时间完成所有工作。注意，不能同时对两台机器进行配置，但配置完成的机器们可以同时执行他们各自的工作。</p> 
<p>输入描述：<br> 第一行输入代表总共的M组任务数据（1 &lt;= M &lt;=10）<br> 每组数第一行为一个整数，用于指定机器的数量N（1 &lt;= N &lt;= 1000）。随后的N行每行有两个整数，第一个表示B（配置需要的时间），第二个表示J（运行任务的时间）<br> 每组数据连续输入，不会用空行分隔。各组任务单独计时。</p> 
<p>输出描述：<br> 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。</p> 
<p>示例1：<br> 输入<br> 1<br> 1<br> 2 2<br> 输出<br> 4<br> 说明<br> 输入共3行数据，第一行代表了只有一组任务；第二行代表本组任务只有一台机器；第三行代表本机器配置时间需要2分钟，执行任务需要2分钟。所以总共需要花4分钟完成任务。</p> 
<p>示例2：<br> 输入<br> 2<br> 2<br> 1 1<br> 2 2<br> 3<br> 1 1<br> 2 2<br> 3 3<br> 输出<br> 4<br> 7<br> 说明<br> 第一行2代表输入共2组数据，第2-4行代表第一组数据（包含2台机器的配置和执行时间）。第5-8行代表第二组数据（包含3台机器的配置和执行时间）。<br> 输出需要包含两行，分别是两组任务需要花费的最短时间（第一组需要4分钟，第二组需要7分钟）</p> 
<p>72. 欢乐的周末<br> 小华和小为是很好的朋友，他们约定周末一起吃饭。通过手机交流，他们在地图上选择了多个聚餐地点(由于自然地形等原因，部分聚餐地点不可达)，求小花和小为都能达到的聚餐地点有多少个？</p> 
<p>输入描述：<br> 第一行输入m和n，m代表地图的长度，n代表地图的宽度<br> 第二行开始具体输入的地图信息，地图信息包含：<br> 0 为通畅的道路<br> 1 为障碍物(且仅1为障碍物)<br> 2 为小华或者小为，地图中必定有且仅有2个（非障碍物）<br> 3 为被选中的聚餐地点（非障碍物）</p> 
<p>输出描述：<br> 可以被两方都能到达的聚餐地点数量，行末无空格</p> 
<p>示例1：<br> 输入<br> 4 4<br> 2 1 0 3<br> 0 1 2 1<br> 0 3 0 0 <br> 0 0 0 0<br> 输出<br> 2<br> 说明<br> 第一行输入地图的长和宽均为4<br> 第二行开始为具体的地图数据，其中：3代表被选中的聚餐地点；2代表小华和小为；0代表可以通行的位置；1代表无法通行的位置。<br> 地图中两人都能达到的聚餐位置有2个</p> 
<p>示例2：<br> 4 4 <br> 2 1 2 3<br> 0 1 0 0<br> 0 1 0 0<br> 0 1 0 0<br> 输出<br> 0<br> 说明<br> 第一行输入的地图长宽均为4<br> 第二行开始为具体的地图数据，其中：3代表被选中的聚餐地点；2代表小华和小为；0代表可以通行的位置；1代表无法通行的位置。<br> 由于途中小华和小为之间有个障碍，此时，没有两人都能达到的聚餐地点，故返回0<br> 39<br> 73. 机器人走迷宫<br> 房间由X * Y的放个组成，例如6 * 4大小的房间，每个方格以坐标(x,y)描述。<br> 机器人固定从方格(0,0)出发，只能向东或者向北前进。出口固定在房间的最东北角，如6 * 4 大小房间的[5,3]方格。用例保证机器人可以从入口走到出口。<br> 房间有些方格是墙壁，机器人不能经过那里。<br> 有些地方机器人一旦达到就无法走到出口的，因为一旦进去后，就无法回头了，这种叫做陷阱方格。<br> 有些地方是机器人永远无法到达的，因为机器人只能朝两个方向走，坐落在相反的一些空格就永远不会被访问到，这种方格叫做不可达方格。不可达方格不包括墙壁所在的位置。<br> 请问，在给定房间大小、墙壁位置的情况下，请计算出地图种陷阱方格与不可达方格分别有多少个。</p> 
<p>输入描述：<br> 第一行为房间的X和Y ( 0 &lt; X,Y &lt;= 1000)<br> 第二行为房间种墙壁的个数N (0 &lt;= N &lt; X*Y)<br> 接着下面会有N行数据，表示墙壁的坐标信息，坐标间以空格分隔（结尾不带回车换行）<br> 用例保证所有输入都是合法的<br> 输出描述：<br> 输出陷阱方格和不可达方格的数量，两个信息在同一行种输出，以空格分隔（结尾不带回车换行）</p> 
<p>示例1：<br> 6 4<br> 5<br> 0 2<br> 1 2<br> 2 2<br> 4 1<br> 5 1<br> 2 3<br> 输出<br> 2 3<br> 说明<br> 该地图上陷阱方格有2个（[4,0]和[5,0]两个方格），不可达方格有3个（[0,3]、[1,3]、[2,3]）</p> 
<p>示例2：<br> 6 4<br> 4<br> 2 0<br> 2 1<br> 3 0<br> 3 1<br> 输出<br> 0 4<br> 说明<br> 该地图上陷阱方格数量为0，不可达方格数量有4个（[4,0]、[4,1]、[5,0]、[5,1]）<br> 74. 计算堆栈种的剩余数字<br> 向一个空栈中依次存入了正整数，假设入栈元素n (1 &lt;- n &lt;= 2 ^ 31 - 1) 按顺序依次为nx ... n4,n3,n2,n1。每当元素入栈时，如果n1 = n2 + ... + ny（y的范围为[2,x], 1 &lt;= x &lt;= 1000）,则n1~ny全部元素出栈，重新入栈新元素m(m=2*n1)。如：依次向站存入6、1、2、3。当存储6、1、2时，栈底至栈顶依次为[6、1、2]; 当存入3时，3=2+1，所以3、2、1需要全部出栈，重新入栈一个新元素6 (6=2*3)，由于此时栈中有元素6，因为6=6，所以两个6全部要出栈，再存储12（12=2*6），最终栈中只剩下了一个元素12.</p> 
<p>输入描述：<br> 使用单个空格隔开的正整数的字符串，如“5 6 7 8”，左边的数字先入栈，输入的正整数个数为X。</p> 
<p>输出描述：<br> 最终栈中存留的元素值，元素值使用空格隔开，如“8 7 6 5”，栈顶数字在左边</p> 
<p>示例1：<br> 输入<br> 5 10 20 50 85 1<br> 输出<br> 1 170<br> 说明<br> 由于5 + 10 + 20 + 50 = 85，入栈85后，5、10、20、50、85全部出栈，入栈170，最终依次出栈的数字为1 和 170</p> 
<p>示例2：<br> 输入<br> 6 7 8 13 9<br> 输出<br> 9 13 8 7 6</p> 
<p>示例3：<br> 输入<br> 1 2 5 7 9 1 2 2<br> 输出<br> 4 1 9 14 1<br> 27<br> 75. 计算疫情的扩散时间<br> 在一个地图中(地图由n*n个区域组成)，有部分区域被感染病。感染区域每天都会把周围(上下左右)的4个区域感染。请根据给定的地图计算，多少天后，全部区域都会被感染。<br> 如果初始地图上所有区域全部都被感染，或者没有被感染区域，返回-1</p> 
<p>输入描述：<br> 一行N*N个数字(只包含0和1，不会有其他数字)，表示一个地图，数字间用英文逗号分隔，0表示未感染区域，1表示已被感染区域。每N个数字表示地图中一行，输入数据共表示N行N列的区域地图。例如，输入1,0,1,0,0,0,1,0,1 表示地图：<br> 1,0,1<br> 0,0,0<br> 1,0,1</p> 
<p>输出描述：<br> 一个整数，表示经过多少天后，全部区域被感染</p> 
<p>示例1：<br> 输入<br> 1,0,1,0,0,0,1,0,1<br> 输出<br> 2<br> 说明<br> 1天以后，地图中仅剩余中心点未被感染，2天以后，全部感染</p> 
<p>示例2：<br> 输入<br> 0,0,0,0<br> 输出<br> -1<br> 说明<br> 无感染区域，输出-1</p> 
<p>示例3：<br> 输入<br> 1,1,1,1,1,1,1,1,1<br> 输出<br> -1<br> 说明<br> 全部都感染了<br> 35<br> 76. 解密犯罪时间<br> 警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如“HH:MM”表示的时刻。<br> 根据警察和线人的约定，为了隐蔽，该时间是修改过的，解密规则是：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。每个出现数字都可以被无限次使用。</p> 
<p>输入描述：<br> 形如HH:MM的字符串，表示原始输入<br> 输出描述：<br> 形如HH:SS的字符串，表示推理出来的犯罪时间</p> 
<p>示例1：<br> 输入<br> 18:52<br> 输出<br> 18:55<br> 说明<br> 利用数字1、8、5、2构造出来的最近时刻是18:55，是三分钟之后。<br> 肯定不是18:53或者18:54，因为3和4这两个数字没有出现过。<br> 下一个是18:55，经过了3分钟，目前最短。<br> 再往后，可能是18:58，经过了6分钟，时间比较长。<br> 结果不是18:51，因为这个时刻是23小时59分钟之后，时间太长了。</p> 
<p>示例2：<br> 输入<br> 23:59<br> 输出<br> 22:22<br> 说明<br> 利用数字2、3、5、9构造出来的最近时刻是22:22。<br> 答案一定是第二天的某个时刻了，所以选择了22:22这个最小犯罪时间。</p> 
<p>备注：<br> 输入的字符串一定是合法的，例如：“01：35”、“11：08”是合法的，“1:35”“11:8”是不合法的。<br> 最近的时刻有可能在第二天。<br> 77. 解压报文<br> 为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。压缩规则：<br> n[str]，表示方括号内部的str正好重复n次。注意n为正整数（0 &lt; n &lt;= 100），str只包含小写字母，不考虑异常情况。</p> 
<p>输入描述：<br> 输入压缩后的报文：<br> 不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的。<br> 原始报文不包含数字，所有的数字只表示重复的次数n，例如不会出现像5b或者3[8]这种输入。</p> 
<p>输出描述：<br> 解压后的原始报文</p> 
<p>示例1：<br> 输入<br> 3[k]2[mn]<br> 输出<br> kkkmnmn</p> 
<p>示例2：<br> 输入<br> 3[m2[c]]<br> 输出<br> mccmccmcc<br> 说明<br> m2[c]解压缩后为mcc，重复三次为mccmccmcc<br> 78. 九宫格按键输入<br> 九宫格按键输入，有英文和数字两个模式，默认是数字模式，数字模式直接输出数字，英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断，输出此时停留的字母。数字和字母的对应关系如下，注意0只对应空格：<br> 1 对应 [ ,. ]<br> 2 对应 [ abc ]<br> 3 对应 [ def ]<br> 4 对应 [ ghi ]<br> 5 对应 [ jkl ]<br> 6 对应 [ mno ]<br> 7 对应 [ pqrs ] <br> 8 对应 [ tuv ]<br> 9对应 [ wxyz ]<br> 0 对应 [空格]<br> # 功能键，用于切换模式，默认是数字模式，执行#后会切换成英文模式<br> / 功能键，表示延迟，只在英文模式下生效，如：在英文模式下，输入22/222，显示为bc<br> 英文模式下，如果没有/键的中断，将持续进行循环，如：输入22222，将输出b</p> 
<p>输入描述：<br> 输入范围为数字0-9和字符“#”、“/”，例如：<br> 在数字模式下，输入1234，屏幕应该显示成：1234<br> 在英文模式下，输入1234，屏幕应该显示成：,adg</p> 
<p>输出描述：<br> 输出最终在屏幕上显示的字符</p> 
<p>示例1：<br> 输入<br> 2222/22<br> 输出<br> 222222<br> 说明<br> 默认是数字模式，字符直接显示成数字，数字模式下“/”字符不生效</p> 
<p>示例2：<br> 输入<br> #2222/22<br> 输出<br> ab<br> 说明<br> #功能键，进入英文模式，接着连续的2222输入会循环从[abc]中选择字母，直到遇到“/”，故第一段2222的输入将显示a，第二段输入显示b</p> 
<p>示例3：<br> 输入<br> #222233<br> 输出<br> ae<br> 说明<br> #进入英文模式，连续的数字输入会进入循环选择字母，直到输入其他数字，故第一段2222输入显示a，第二段输入显示e。<br> 79. 绘制矩形<br> 实现一个简单的绘图模块，绘图模块仅支持矩形的绘制和擦除，当新绘制的矩形和之前的图形重叠时，对图形取并集；当新擦除的矩形与之前的图形重叠时，对图形取差集。给定一系列矩形的绘制和擦除操作，计算最终图形的面积。<br> 输入描述：<br> 绘图模块采用二维坐标系，输入第一行为操作的数量N，接下来N行格式为：<br> d x1 y1 x2 y2   其中d表示进行绘制操作，(x1,y1)为矩形左上角坐标，(x2,y2)为矩形的右下角坐标。<br> e x1 y1 x2 y2   其中e表示进行擦除操作，(x1,y1)为矩形左上角坐标，(x2,y2)为矩形的右下角坐标。<br> 坐标为整数，取值范围是[-100,100]，用例保证坐标有效</p> 
<p>请输出最终图形的面积</p> 
<p>示例1：<br> 输入<br> 2<br> d 0 2 2 0<br> d -1 1 1 -1<br> 输出<br> 7<br> 说明<br> 第一步绘制的矩形面积为4，第二步绘制的矩形面积为4，但它们重叠部分面积为1，所以最终合并后的图形面积为7</p> 
<p>示例2：<br> 输入<br> 2<br> d 0 2 2 0<br> e -1 1 1 -1<br> 输出<br> 3<br> 第一步绘制的图形面积是4，第二步擦除了矩形左下角面积为1的一部分，最终图形的面积为3<br> 27<br> 80. 考古学家<br> 考古学家发现了一个石碑，可惜其已经断成了多段，原地发现n个断口整齐的石碑碎片，为了破解石碑的内容，考古学家希望有程序可以帮忙计算复原后的石碑文字的组合数。</p> 
<p>输入描述：<br> 第一行输入n，表示石碑碎片的个数<br> 第二行依次输入石碑碎片上的文字内容s，共有n组</p> 
<p>输出描述：<br> 输出石碑文字的组合(按升序排列)，行末无多余空格</p> 
<p>示例1：<br> 输入<br> 3<br> a b c<br> 输出<br> abc<br> acb<br> bac<br> bca<br> cab<br> cba<br> 说明<br> abc三个字母的所有组合，按照字典序升序排列输出</p> 
<p>示例2：<br> 输入<br> 3<br> a b a<br> 输出<br> aab<br> aba<br> baa<br> 说明<br> 可能组合有“aab”“aba”“baa”</p> 
<p>示例3：<br> 输入<br> 3<br> a b ab<br> 输出<br> aabb<br> abab<br> abba<br> baab<br> baba</p> 
<p>备注：<br> 如果存在石碑碎片完全相同，相同碎片间的顺序变换不影响复原后的碑文内容。<br> 47<br> 81. 可以组成网络的服务器<br> 在一个机房中，服务器位置标识在n*m的整数矩阵网格中，1表示单元格上有服务器，0表示没有。如果两台服务器唯一同一行或者同一列中紧邻的位置，则认为它们之间可以组成一个局域网。请你统计机房中最大的局域网包含的服务器个数。</p> 
<p>输入描述：<br> 第一行输入两个正整数，n和m，代表网格信息<br> 之后的n*m的二维数组，代表服务器信息</p> 
<p>输出描述：<br> 最大局域网包含的服务器个数</p> 
<p>示例1：<br> 输入<br> 2 2 <br> 0 1<br> 1 1<br> 输出<br> 3<br> 说明<br> 三台服务器相连，可以组成局域网</p> 
<p>备注：典型的广度优先搜索<br> 82. 篮球比赛<br> 篮球（5V5）比赛中，每个球员拥有一个战斗力，每个队伍的所有球员战斗力之和是该队伍的总体战斗力。现有10格球员准备分为两队进行训练赛，教练希望2队伍的战斗力差值尽可能小，以达到最佳训练效果。给出10个球员的战斗力值，帮忙分下队伍。</p> 
<p>输入描述：<br> 10个球员的战斗力值，空格分隔 ，不考虑异常输入场景<br> 输出描述：<br> 最小的战斗力差值：如：1</p> 
<p>示例1：<br> 输入<br> 10 9 8 7 6 5 4 3 2 1<br> 输出<br> 1<br> 说明<br> 1 2 5 9 10 组一队<br> 3 4 6 7 8  组一队<br> 分配方案可能不一，但是最小值肯定是确定的。<br> 83. 连续出牌数量<br> 一款单人卡牌游戏，牌面由颜色和数字组成，颜色分为红、黄、蓝、绿；数字为0-9。游戏开始时玩家从手牌中选取一种卡牌打出，接下来如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌，它可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌为止。现在给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。</p> 
<p>输入描述：<br> 第一行使每张手牌的数字，由空格分隔<br> 第二行为对应手牌的颜色，用r y b g这四个字母分别代表四种颜色，也是空格分隔</p> 
<p>输出描述：<br> 输出一个数字，即最多能打出的手牌的数量</p> 
<p>示例1：<br> 输入<br> 1 4 3 4 5<br> r y b b r<br> 输出<br> 3<br> 说明<br> 如果打出1r，那么下次只能再打出5r，只能打出两张牌。<br> 如果按照4y-4b-3b的顺序，可以打出三张牌。</p> 
<p>示例2：<br> 输入<br> 1 2 3 4<br> r y b g<br> 输出<br> 1<br> 说明<br> 没有连续的牌，没有花色相同的牌，最多只能打出一张<br> 27<br> 84. 没有回文串<br> 回文串的定义：正读和反读都一样的字符串<br> 现在已经存在一个不包含回文串的字符串，字符串的字符都是英语字母的前N个，且字符串不包含任何长度大于等于2的回文串；请找出下一个字典序的不包含回文串的、字符都是再英文字母的前N个、且长度相同的字符串。如果不存在，输出NO</p> 
<p>输入描述：<br> 第一行有一个整数N，表示字符串的每个字符范围都只再前N个英文字母中<br> 第二行输入一个字符串，输入保证这个字符串使合法的且没有包含回文串</p> 
<p>输出描述：<br> 输出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串，如不存在，请输出NO</p> 
<p>示例1：<br> 输入<br> 3<br> cba<br> 输出<br> NO<br> 说明<br> 字符串cba，当N=3时，后面长度相同的字符串cbb和cbc，都存在回文串，所有输出NO</p> 
<p>示例2：<br> 输入<br> 5<br> cba<br> 输出<br> cbd<br> 说明<br> 字符串cba，当N=5时，后面长度为3的cbb和cbc都不满足，下一个长度为3的cbd满足。<br> 27<br> 85. 目录删除<br> 某文件系统中有N个目录，每个目录都有一个独一无二的ID。每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构成树状结构。假设，根目录的ID为0，且根目录没有父目录，其他所有目录的ID用唯一的正整数表示，并统一编号。<br> 现给定目录ID和其父目录ID对应的父子关系表[子目录ID，父目录ID]，以及一个待删除的目录ID，请计算并返回一个ID序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。<br> 注意：<br> 被删除的目录或文件编号，一定在输入的ID序列中<br> 当一个目录删除时，它所有的子目录都会被删除<br> 输入描述：<br> 第一行为父子关系表的长度M，接下来的M行表示了M个父子关系对<br> 最后一行为待删除的目录ID。<br> 序列中的元素以空格分隔，可参考样例。</p> 
<p>输出描述：<br> 输出一个序列，表示因删除指定目录后，剩余的目录ID</p> 
<p>示例1：<br> 输入<br> 5 <br> 8 6<br> 10 8<br> 6 0<br> 20 8<br> 2 6<br> 8<br> 输出<br> 2 6<br> 说明<br> 目录结构如下所示：<br> 6<br> /   \<br> 2      8<br>      /   \<br>    10    20<br> 删除了目录8，同时它的子目录10、20也被删除了，只剩下2和6两个目录。<br> 86. 亲子游戏<br> 宝宝和妈妈参加亲子游戏，在一个二维矩阵(N*N)的格子地图上，宝宝和妈妈抽签决定各自的位置，地图上每个格子有不同的糖果数量，部分格子有障碍物。游戏规则时妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上所有的糖果都可以拿走，不能走有障碍物的格子，且只能上下左右走。请问妈妈在最短到达宝宝位置的时间内最多能拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。</p> 
<p>输入描述：<br> 第一行输入整数N，表示二维矩阵的长和宽<br> 之后N行，每行有N个数，表示矩阵每个位置的取值，取值包括：<br> -3 ：妈妈<br> -2 ：宝宝<br> -1 ：障碍物<br> &gt;=0: 糖果数量（0表示没有糖果，但可以通行）</p> 
<p>输出描述：<br> 输出妈妈在最短到达宝宝位置的时间内，能拿到的最大的糖果数量，行末无多余空格</p> 
<p>示例1：<br> 输入<br> 4<br> 3 2 1 -3<br> 1 -1 1 1<br> 1 1 -1 2<br> -2 1 2 3<br> 输出<br> 22<br> 87. 求满足条件的最长子串的长度<br> 给定一个字符串，只包含字母和数字，按要求找出字符串中的最长(连续)子串的长度，字符串本身算是其最长的子串，但子串还必须满足：<br> 只包含一个字母(a-z,A-Z)，其余必须是数字<br> 字母可以在子串中的任何位置<br> 如果找不到满足要求的子串，如果全是字母或者全是数字，返回-1</p> 
<p>输入描述：<br> 字符串（只包含字母和数字）<br> 输出描述：<br> 子串的长度</p> 
<p>示例1：<br> 输入<br> abC124ACb<br> 输出<br> 4<br> 说明<br> 满足条件的子串是C124和123A，长度都是4</p> 
<p>示例2：<br> 输入<br> A5<br> 输出<br> 2<br> 其本身就是最长子串</p> 
<p>示例3：<br> 输入<br> aBB9<br> 输出<br> 2<br> 说明<br> B9满足条件，长度为2</p> 
<p>示例4：<br> 输入<br> abcdef<br> 输出<br> -1<br> 说明<br> 没有满足的子串，输出-1<br> 88. 书籍叠放<br> 标题：书籍叠放|时间限制1s|内存限制：65536K|语言限制：不限<br> 书籍的长，宽都是整数对应（l,w）。如果书A的长宽度都比B长宽大时，则允许将B排列放在A上面。<br> 现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多能有多少个规格书籍能叠放在一起。<br> 输入描述：<br> 输入：books=[[20,16],[15,11],[10,10],[9,10]]<br> 说明：总共4本书籍，第一本长度为20宽度为16；第二本书长度为15宽度为11，依次类推，最后一本书长度为9宽度为10.<br> 输出描述：<br> 输出：3<br> 说明：最多3个规格的书籍可以叠放在一起，从上到下依次为：[20,16],[15,11],[10,10]<br> 9<br> 89. 人气最高的店铺<br> 某购物城有m个商铺，现决定举办一场活动选出人气最高店铺。活动共有n位市民参与，每位市民只能投一票，但一号店铺如果给该市民发放q元的购物补贴，该市民会改为投1号店。<br> 请计算1号店铺需要最少发放多少元购物补贴才能成为人气最高商铺（即获得的票数要大于其他店铺），如果1号店铺本身就是票数最高店铺，返回0.<br> 输入描述：<br> 第一行为小写逗号分隔的两个整数n,m,其中第一个整数n表示参与的市民总数，第二个整数m代表店铺总数，1&lt;=n,m&lt;=3000。<br> 第2到n+1行，每行为小写逗号分割的两个整数p,q，表示市民的意向投票情况，其中每一行的第一个整数p表示该市民意向投票给p号店铺，第二个整数q代表其改投1号店铺所需给予的q元购物补贴，1&lt;=p&lt;=m,1&lt;=q&lt;=10^9。<br> 不考虑输入的格式问题。<br> 输出描述：<br> 1号店铺需要最少发放购物补贴金额。<br> 实例1<br> 输入<br> 5,5<br> 2,10<br> 3,20<br> 4,30<br> 5,40<br> 5,90<br> 输出<br> 50<br> 说明：<br> 有5个人参与，共5个商铺。<br> 如果选择发放10元+20元+30元=60元的补贴来抢2，3，4号店铺的票，总共发放了60元补贴（5号店铺有两票，1号店铺要3票才能胜出）<br> 如果选择发放10元+40元=50元的补贴来抢2，5号店铺的票，总共发放了50元补贴（抢了5号店铺的票后，现在1号店铺只要2票就能胜出）<br> 所以最少发放50元补贴<br> 实例2<br> 输入<br> 5,5<br> 2,10<br> 3,20<br> 4,30<br> 5,80<br> 5,90<br> 输出<br> 60<br> 说明<br> 有5个人参与，共5个商铺。<br> 如果选择发放10元+20元+30元=60元的补贴来抢2，3，4号店铺的票，总共发放了60元补贴（5号店铺有2票，1号店铺要3票才能胜出）<br> 如果选择发放10元+80元=90元 的补贴来抢2，5号店铺的票，总共发放了90元补贴（抢了5号店铺的票后，现在1号店铺只要2票就能胜出）<br> 所以最少发放60元补贴。</p> 
<p>90. 任务最优调度<br>     标题：任务最优调度 | 时间限制：1s | 内存限制：65536k|语言限制：不限<br>     给定一个正整数数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。请计算执行完所有任务所需的最短时间。任务执行规则如下：<br>     1. 任务可以按任意顺序执行，且每个任务执行耗时间为1个时间单位；<br> 2. 两个同类型的任务之间必须有长度为N个单位的冷却时间，比如：N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务；<br> 3. 系统在任何一个单位时间内都可以执行一个任务，或者等待状态。<br> 说明：数组最大长度为1000，数组最大值1000。<br> 输入描述:<br> 第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000<br> 第二行记录任务冷却时间，N为正整数，N&lt;=100。<br> 输出描述：<br> 输出为执行完所有任务所需的最短时间。<br> 示例1<br> 输入<br> 2，2，2，3<br> 2<br> 输出<br> 7<br> 说明<br> 时间1：执行类型2的任务<br> 时间2：执行类型3的任务（因为冷却时间为2，所以时间2不能执行类型2的任务）。<br> 时间3：系统等待（仍然在类型2的冷却时间）。<br> 时间4：执行类型2任务<br> 时间5：系统等待<br> 时间6：系统等待<br> 时间7：执行类型2任务<br> 因此总共耗时7.<br> 91. 信道分配<br> 标题：信道分配|时间限制：1s|内存限制：262144k|语言限制：不限<br> 算法工程师小明面对着这样的一个问题，需要将通信用的信道分配给尽量多的用户：<br> 信道的条件及分配规则如下：<br> 1）所有信道都有属性：“阶”。阶为r的信道的容量为2^r比特；<br> 2）所有用户需要传输的数据量都一样：D比特；<br> 3）一个用户可以分配多个信道，但每个信道只能分配给一个用户；<br> 4）只有当分配给一个用户的所有信道的容量和&gt;=D，用户才能传输数据；<br> 给出一组信道资源，最多可以为多少用户传输数据？<br> 输入描述：<br> 第一行，一个数据R，R为最大阶数；<br> 0&lt;=R&lt;20<br> 第二行，R+1个数字，用空格隔开<br> 代表每种信道的数量Ni。按照阶的值从小到大排列。<br> 0&lt;=i&lt;=R,0&lt;=Ni&lt;1000<br> 第三行，一个数字D<br> D为单个用户需要传输的数据量<br> 0&lt;D&lt;1000000<br> 输出描述<br> 一个数字，代表最多可以供多少个用户传输数据<br> 示例1<br> 输入<br> 5 <br> 10 5 0 1 3 2<br> 30<br> 输出<br> 4<br> 说明<br> 最大阶数为5</p> 
<p>信道阶数：<br> 0<br> 1 </p> 
<p>信道容量：</p> 
<p>信道个数</p> 
<p>单个用户需要传输的数据量为30    <br> 可能存在很多分配方式，举例说明：<br> 分配方式1：<br> 1） 32*1=32<br> 2） 32*1=32<br> 3） 16*2=32<br> 4） 16*1+8*1+2*3=30<br> 剩下2*2+1*10=14不足以再分一个用户了。<br> 分配方式2：<br> 1）16*1+8*1+2*2=30<br> 2）16*1+2*2+1*10=30<br> 3）32*1=32<br> 4）32*1=32<br> 剩下16*1=16不足以再分一个用户了。<br> 分配方式3：<br> 1）16*1+8*1+2*3=30<br> 2）16*1+2*2+1*10=30<br> 3）16*1+32*1=48<br> 4）32*1=32<br> 恰好用完。<br>     虽然每种分配方式剩下的容量不同，但服务的用户数量是一致的。因为这个问题中我们只关心服务的用户数，所以我们认为这些分配方式等效。<br> 92. 图像物体的边界<br> 标题：图像物体的边界|时间限制：1s|内存限制：262144k|语言限制:不限<br>     给定一个二维数组M行N列，二维数组里的数组代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻为边界，求像素1代表的物体的边界个数。<br>     像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）<br> 其他约束：<br> 地图规格约束为：<br> 0&lt;M&lt;100<br> 0&lt;N&lt;100<br>     输入描述<br>     第一行，行数M，列数N<br>     第二行开始，是M行N列的像素的二维数组，仅包含像素1和5<br>     输出描述<br>     像素1代表的物体的边界个数，如果没有边界输出0（比如只存像素1，或者只存在像素5）<br> 示例1：<br> 输入<br> 6 6<br> 1 1 1 1 1 1 <br> 1 5 1 1 1 1 <br> 1 1 1 1 1 1 <br> 1 1 1 1 1 1<br> 1 1 1 1 1 1 <br> 1 1 1 1 1 5 <br> 输出：2<br> 解析：与像素5的格子相邻的像素1的格子(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2),(4,4),(4,5),(5,4)为边界，另（0，0），(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)相邻，为一个边界，(4,4),(4,5),(5,4)相邻，为一个边界，所以边界个数为2.<br> 示例2<br> 输入<br> 6 6<br> 1 1 1 1 1 1 <br> 1 5 1 1 1 1 <br> 1 1 1 1 1 1 <br> 1 1 1 1 1 1<br> 1 1 1 1 5 1 <br> 1 1 1 1 1 1 <br> 输出：1<br> 解析：与像素5的格子相邻的像素1的格子(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2),（3，3），（3，4），（3，5）(4,3),(4,5),（5，3）(5,4)（5，5）为边界，另这些边界相邻，所以边界个数为1。注：（2，2），（3，3）相邻。<br> 93. 学生方针<br>     标题：学生方针|时间限制：1s|内存限制：262144k|语言限制：不限<br>     学校组织活动，将学生排成一个矩形方阵。请在矩形方阵中找到最大的位置相连的男生数量。这个相连位置在一个直线上，方向可以水平的，垂直的，呈对角线的或者反对角线的。<br>     注：学生个数不会超过10000.<br>     输入描述<br>     输入的第一行为矩阵的行数和列数，接下来的n行为矩阵元素，元素用“，”分隔。<br>     输出描述<br>     输出一个整数，表示矩阵中最长的位置相连的男生个数。<br>     示例1<br>     输入<br>     3，4<br>     F,M,M,F<br>     F,M,M,F<br>     F, F, F, M<br> 输出：3<br> 94. 数字排序<br> 小明负责公司年会，想出一个趣味游戏：屏幕给出1~9中任意3个不重复的数字，大家以最快时间给出这几个数字可拼成的数字从小到大排列位于第N位置的数字，其中N为给出的数字中最大的（如果不到这么多个数字则给出最后一个即可），谁最快给出谁得奖。<br> 注意：<br> （1）屏幕如果给出的是“2”，大家可把它当作“2”，也可把它当作“5”来拼接数字；同理，如果屏幕给的是“5”，大家可把它当作“5”，也可以把它当作“2”来拼接数字，但屏幕不能同时给出“2”和“5”。<br> （2）屏幕如果给出的是“6”，大家可把它当作“6”，也可把它当作“9”来拼接数字；同理，如果屏幕给的是“9”，大家可把它当作“9”，也可以把它当作“6”来拼接数字，但屏幕不能同时给出“6”和“9”。<br> 现在需要编写一个小程序，根据给出的数字计算出能组合的所有2数字以及最终的正确答案。<br> 如：给出：1，4，8，则可以拼成的数字为：<br> 1，4，8，14，18，41，48，81，84，148，184，418，481，814，841<br> 那么最第N（即8）个的数字为81.<br> 输入描述：以逗号为分隔，描述3个int类型整数的字符串。<br> 输出描述：这几个数字可拼成的数字从小到大排列位于第N（N为输入数字中最大的数字）位置的数字，如果输入的数字为负数或者不是合法的字符串或者有重复，返回-1。<br> 输入例子：1，4，8<br> 输出例子：81<br> 95. 数据单元的变量替换<br> 标题：数据单元的变量替换 | 时间限制 ：1s | 内存限制：262144k|语言限制：不限<br> 将一个csv格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。<br> Comma seprated values（CSV）逗号分隔值，csv格式的数据文件使用逗号作为分隔符将各单位的内容进行分隔。<br> 输入描述<br> 1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A-Z。<br> 2. 每个单元格的内容包含字母和数字，以及使用&lt;&gt;分隔的单元格引用，例如：&lt;A&gt;表示引用第一个单元的值。<br> 3. 每个单元格的内容，在替换前和替换后均不超过100个字符。<br> 5. 引用单元格的位置不受限制，运行排在后面的单元格被排在前面的单元格引用。<br> 6. 不存在循环引用的情况，比如下面这种场景是不存在的：<br>     A单元格：aCd&lt;B&gt;8u<br>     B单元格：kAy&lt;A&gt;dzqo<br> 7. 不存在多重&lt;&gt;的情况，一个单元格只能引用一个其他单元格。比如下面这种场景是不存在的：<br>     A单元格：aCd8u<br>     B单元格：kAydzqo<br>     C单元格：y&lt;&lt;A&gt;&lt;B&gt;&gt;d<br> 输出描述：<br> 输出所有单元格展开的内容，单元格之间用逗号分隔。处理过程中出现错误时，输出字符串“-1”表示出错。<br> 示例1<br> 输入1,2&lt;A&gt;00<br> 输出1，2100<br> 说明<br> 第二个单元中有对A单元的引用，A单元格的值为1，替换时，将A单元的内容替代&lt;A&gt;的位置，并和其他内容合并。<br> 示例2<br> 输入&lt;B&gt;12,1<br> 输出<br> 112，1<br> 说明<br> 第一个单元中有对B单元的引用，B单元格的值为1，替换时，将第二个数据单元的内容替代&lt;B&gt;的位置，并和其他内容合并。<br> 示例3<br> 输入<br> &lt;B&lt;12,1<br> 输出<br> -1<br> 说明<br> 第一个单元中有错误的单元格引用方式，输出-1<br> 35<br> 96. 数组连续和<br> 标题：数组连续和|时间限制：1s|内存限制：65536k|语言限制：不限<br> 给定一个含有N个正整数的数组，求出有多少个连续区间（包括单个正整数），他们的和大于等于x。<br> 输入描述<br> 第一行两个整数N x （0&lt;N&lt;=100000,0&lt;=x&lt;=10000000）<br> 第二行有N个正整数（每个正整数小于等于100）。<br> 输出描述<br> 输出一个整数，表示所求的个数<br> 示例1<br> 输入<br> 3 7<br> 3 4 7<br> 输出<br> 4<br> 说明<br> 3+4 4+7 3+4+7 7 这四组数据都是大于等于7 的，所以答案为4<br> 示例2<br> 输入<br> 10 10000000<br> 1 2 3 4 5 6 7 8 9 10 <br> 输出<br> 97. 社交距离<br> 疫情期间，需要大家保证一定的社交距离，公司组织开交流会议，座位有一排共N个座位，编号分别为[0…N-1],要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室<br> 。<br>     满足：每当一个员工进入时，需要做到最大社交距离（最大化自己和最近其他人的距离）的座位；如果有多个这样的座位，则坐到索引最小的那个座位。<br>     输入描述<br>     会议室座位总数seatNum，（1&lt;=seatNum&lt;=500）<br>     员工的进出顺序seatOrLeave数组，元素值为1：表示进场；元素值为负数表示出场（特殊：位置为0的员工不能离开），例如-4表示坐在位置4的员工离开（保证有员工坐在该位置上）<br>     输出描述<br>     最后进来员工，他会坐在第几个位置，如果位置满了则输出-1<br>     示例1<br>     输入<br>     10<br>     [1,1,1,1,-4,1]<br>     输出<br>     5<br>     说明<br>     seat-&gt;0,坐在任何位置都行，但是要给他安排索引最小的位置，也就是座位0；<br>     seat-&gt;9,要和旁边的人距离最远，也就是座位9；<br>     seat-&gt;4,要和旁边的人距离最远，也就是座位4；<br>     seat-&gt;2,员工最后坐在2号座位上；<br>     leave(4),4号座位的员工离开；<br>     seat-&gt;5,员工最后坐在5号座位上<br> 21<br> 98. 贪吃蛇<br> 略</p> 
<p>99. 射击比赛<br> 给定一个射击比赛成绩单<br>   包含多个选手若干次射击的成绩分数<br>   请对每个选手按其最高三个分数之和进行降序排名<br>   输出降序排名后的选手id序列<br>   条件如下<br>     1. 一个选手可以有多个射击成绩的分数，且次序不固定<br>     2. 如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手<br>     3. 如果选手的成绩之和相等，则相等的选手按照其id降序排列</p> 
<p>   输入描述:<br>      输入第一行<br>          一个整数N<br>          表示该场比赛总共进行了N次射击<br>          产生N个成绩分数<br>          2&lt;=N&lt;=100</p> 
<p>     输入第二行<br>        一个长度为N整数序列<br>        表示参与每次射击的选手id<br>        0&lt;=id&lt;=99</p> 
<p>     输入第三行<br>         一个长度为N整数序列<br>         表示参与每次射击选手对应的成绩<br>         0&lt;=成绩&lt;=100</p> 
<p>   输出描述:<br>       符合题设条件的降序排名后的选手ID序列</p> 
<p>   示例一<br>       输入:<br>         13<br>         3,3,7,4,4,4,4,7,7,3,5,5,5<br>         53,80,68,24,39,76,66,16,100,55,53,80,55<br>       输出:<br>         5,3,7,4<br>       说明:<br>         该场射击比赛进行了13次<br>         参赛的选手为{3,4,5,7}<br>         3号选手成绩53,80,55 最高三个成绩的和为188<br>         4号选手成绩24,39,76,66  最高三个成绩的和为181<br>         5号选手成绩53,80,55  最高三个成绩的和为188<br>         7号选手成绩68,16,100  最高三个成绩的和为184<br>         比较各个选手最高3个成绩的和<br>         有3号=5号&gt;7号&gt;4号<br>         由于3号和5号成绩相等  且id 5&gt;3<br>         所以输出5,3,7,4<br> 47<br> 100. 特殊键盘<br> 有一个特殊的五键键盘<br>     上面有A、Ctrl-C、Ctrl-X、Ctrl-V、Ctrl-A<br>     A键在屏幕上输出一个字母A<br>     Ctrl-C将当前所选的字母复制到剪贴板<br>     Ctrl-X将当前选择的字母复制到剪贴板并清空所选择的字母<br>     Ctrl-V将当前剪贴板的字母输出到屏幕<br>     Ctrl-A选择当前屏幕中所有字母<br>     注意：<br>       1. 剪贴板初始为空<br>       2. 新的内容复制到剪贴板会覆盖原有内容<br>       3. 当屏幕中没有字母时,Ctrl-A无效<br>       4. 当没有选择字母时Ctrl-C、Ctrl-X无效<br>       5. 当有字母被选择时A和Ctrl-V这两个输出功能的键,<br>          会先清空所选的字母再进行输出</p> 
<p>    给定一系列键盘输入,<br>     输出最终屏幕上字母的数量</p> 
<p>    输入描述:<br>        输入为一行<br>        为简化解析用数字12345分别代替A、Ctrl-C、Ctrl-X、Ctrl-V、Ctrl-A的输入<br>        数字用空格分割</p> 
<p>    输出描述:<br>         输出一个数字为屏幕上字母的总数量</p> 
<p>    示例一:<br>         输入:<br>           1 1 1<br>         输出:<br>           3</p> 
<p>   示例二:<br>         输入:<br>           1 1 5 1 5 2 4 4<br>         输出:<br>           2 <br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daeaad1c1d47a5a88f6f3c9022dd9b1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">aes加密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1d4be9dea8133d350ed0a21f3c95ada/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第一个Flask程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>