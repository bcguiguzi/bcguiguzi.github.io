<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库基本知识 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库基本知识" />
<meta property="og:description" content="主键 主键是数据表中对数据对象能够唯一和完整标识的数据列或数据列的组合 但能唯一和完整标识的列不一定是主键 主键要满足的条件： 一个表只能有一个主键 但该主键可以由多个列组成 任意两行主键的值（或组合）都不相同不能有空值（NULL）值不允许修改或更新值不能被重用 如果某行从表中删除，它的主键不能赋给以后的新行 使用innodb作为存储引擎的数据库，表必须有主键 因为表数据文件本身就是按B&#43;Tree组织的一个索引结构，主键索引存放的顺序就是数据存放的顺序如果没有定义主键，数据库会会自动选择一个可以唯一标识数据记录的列作为主键如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形 主键建议使用自增ID 否则会不得不为了将新记录插到合适位置而移动数据，可能造成page分裂，这降低了写入的性能同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，增大了空间占用 主键尽量选择较短的数据类型 因为普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间 索引 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能索引数据可能要占用大量的存储空间索引的效率随表数据的增加或改变而变化 最好定期检查索引，并根据需要对索引进行调整 聚簇（主键）索引 聚簇索引叶子节点的值存储的就是要查找的数据，只需要一次查询主键一定是聚簇索引，修改聚簇索引其实就是修改主键 主键索引的叶子节点就是数据行，包括了所有数据字段 聚簇索引的顺序就是数据存放的顺序一个表只能创建一个聚簇索引，但可以创建多个辅助索引
辅助（二级）索引的存储和数据的存储是分离的 一般将索引存在内存中，而数据存在磁盘上辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录（回表） 覆盖索引 当查询的列就是索引字段本身（或者主键）时，这种场景下该普通索引也可以实现一次查询，无需回表一般通过新增联合索引实现对相应字段的覆盖索引 MySQL中一张表最多可以创建 64 个非聚簇索引；而且创建非聚簇索引时，列的数量不能超过16个 联合索引 联合索引采取最左匹配原则 针对的是创建的联合索引中的顺序, 这个索引的使用顺序就很重要 如果创建了联合索引（x,y,z），如果在条件语句中只有 y 和 z，那么就用不上联合索引 MySQL 在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如 &lt;, &gt; 和 between 等，就会停止继续匹配，后面的索引列就无法使用到索引 在多条件联合查询的时候最好创建联合索引，因为多个单列索引在多条件查询时只会生效一个索引采用 = 查询或者是 IN 查询时，MySQL 的优化器会自动帮我们调整为可以使用联合索引的形式为什么不创建一个由所有的字段组成的联合索引？ 用所有的字段创建组合索引的存储成本比较高利用率比较低，完全用上的可能性几乎不存在一旦更改任何一个字段的数据，就必须要改索引，这样操作成本也比较高 自适应哈希索引 哈希索引的优点 数据检索的时候效率非常高，通常只需要 O(1) 的复杂度，也就是一次就可以完成数据的检索 哈希索引的缺点
自适应 Hash 索引 自适应指的是不需要人工来制定，系统会根据情况自动完成 如果某个索引值被使用的非常频繁时，就会将这个数据页的地址存放到 Hash 表中 自适应 Hash 索引只保存热数据，数据量并不会很大 因此自适应 Hash 也是存放到缓冲池中，这样也进一步提升了查找效率 采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点 特别是当 B&#43; 树比较深的时候 索引友好的SQL语句 什么时候需要创建索引： 字段的数值有唯一性的限制，比如用户名频繁作为 WHERE 查询条件的字段 包括UPDATE和DELETE操作，因为需要先检索出来这条记录，然后再对它进行更新或删除 需要经常 GROUP BY 和 ORDER BY 的列DISTINCT 字段需要创建索引 什么时候不需要索引： 起不到定位的字段通常是不需要创建索引 即WHERE 或 GROUP BY、ORDER BY 里用不到的字段 频繁更新的字段不一定要创建索引 因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担 表记录太少时不需要创建索引字段中如果有大量重复数据，也不用创建索引 索引失效场景： 对索引进行了表达式计算对索引使用函数WHERE 子句中，在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引使用 LIKE 进行模糊查询的时候，以_或%开头索引列与 NULL 或者NOT NULL 进行判断NOT 等负向查询条件字符串当整型使用等隐式类型转换复合索引最左匹配失败数据少时mysql觉得全表扫描更快" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/385be5f346468d92aac9665e154fd0d5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-25T15:08:54+08:00" />
<meta property="article:modified_time" content="2022-08-25T15:08:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库基本知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_3"></a>主键</h2> 
<ul><li>主键是数据表中对数据对象能够<strong>唯一和完整标识</strong>的数据列或数据列的组合 
  <ul><li>但能唯一和完整标识的列不一定是主键</li></ul> </li><li><strong>主键要满足的条件：</strong> 
  <ul><li>一个表只能有一个主键 
    <ul><li>但该主键可以由多个列组成</li></ul> </li><li>任意两行主键的值（或组合）都不相同</li><li>不能有空值（<code>NULL</code>）</li><li>值不允许修改或更新</li><li>值不能被重用 
    <ul><li>如果某行从表中删除，它的主键不能赋给以后的新行</li></ul> </li></ul> </li><li>使用<strong>innodb</strong>作为存储引擎的数据库，表<strong>必须有主键</strong> 
  <ul><li>因为表数据文件本身就是按B+Tree组织的一个索引结构，主键索引存放的顺序就是数据存放的顺序</li><li>如果没有定义主键，数据库会会自动选择一个可以唯一标识数据记录的列作为主键</li><li>如果不存在这种列，则MySQL自动为InnoDB表生成一个<strong>隐含字段</strong>作为主键，这个字段长度为6个字节，类型为长整形</li></ul> </li><li><strong>主键建议使用自增ID</strong> 
  <ul><li>否则会不得不为了将新记录插到合适位置而<strong>移动数据</strong>，可能造成<strong>page分裂</strong>，这降低了写入的性能</li><li>同时频繁的移动、分页操作造成了大量的<strong>碎片</strong>，得到了不够紧凑的索引结构，<strong>增大了空间占用</strong></li></ul> </li><li><strong>主键尽量选择较短的数据类型</strong> 
  <ul><li>因为普通索引都会保存主键的值，较短的数据类型可以有效的<strong>减少索引的磁盘空间</strong></li></ul> </li></ul> 
<h2><a id="_24"></a>索引</h2> 
<ul><li>索引改善检索操作的性能，<strong>但降低了数据插入、修改和删除的性能</strong></li><li>索引数据可能要<strong>占用大量的存储空间</strong></li><li>索引的<strong>效率随表数据的增加或改变而变化</strong> 
  <ul><li>最好定期检查索引，并根据需要对索引进行调整</li></ul> </li><li><strong>聚簇（主键）索引</strong> 
  <ul><li>聚簇索引叶子节点的值存储的就是要查找的数据，只需要<strong>一次</strong>查询</li><li>主键一定是聚簇索引，修改聚簇索引其实就是修改主键 
    <ul><li>主键索引的叶子节点就是数据行，包括了<strong>所有数据字段</strong></li></ul> </li><li>聚簇索引的顺序就是数据存放的顺序</li><li>一个表只能创建一个聚簇索引，但可以创建多个辅助索引<br> <img src="https://images2.imgbox.com/d7/97/BrpbA2wo_o.png" alt="在这里插入图片描述"></li></ul> </li><li><strong>辅助（二级）索引的存储和数据的存储是分离的</strong> 
  <ul><li>一般将索引存在内存中，而数据存在磁盘上</li><li>辅助索引搜索需要检索<strong>两遍</strong>索引：首先检索辅助索引获得<strong>主键</strong>，然后用主键到主索引中检索获得记录（<strong>回表</strong>）</li></ul> </li><li><strong>覆盖索引</strong> 
  <ul><li>当查询的列就是索引字段本身（或者主键）时，这种场景下该普通索引也可以<strong>实现一次查询，无需回表</strong></li><li>一般通过<strong>新增联合索引</strong>实现对相应字段的覆盖索引</li></ul> </li><li>MySQL中一张表<strong>最多可以创建 64 个非聚簇索引</strong>；而且创建非聚簇索引时，<strong>列的数量不能超过16个</strong></li></ul> 
<h3><a id="_44"></a>联合索引</h3> 
<ul><li>联合索引采取<strong>最左匹配原则</strong> 
  <ul><li>针对的是创建的联合索引中的顺序, 这个索引的使用顺序就很重要 
    <ul><li>如果创建了联合索引（x,y,z），如果在条件语句中只有 y 和 z，那么就用不上联合索引</li></ul> </li><li>MySQL 在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如 <code>&lt;, &gt;</code> 和 <code>between</code> 等，就会停止继续匹配，后面的索引列就无法使用到索引</li></ul> </li><li>在<strong>多条件联合查询</strong>的时候最好创建联合索引，因为<strong>多个单列索引在多条件查询时只会生效一个索引</strong></li><li>采用 <code>=</code> 查询或者是 <code>IN</code> 查询时，MySQL 的优化器会自动帮我们调整为可以使用联合索引的形式</li><li>为什么不创建一个<strong>由所有的字段组成的联合索引</strong>？ 
  <ul><li>用所有的字段创建组合索引的存储成本比较高</li><li>利用率比较低，完全用上的可能性几乎不存在</li><li>一旦更改任何一个字段的数据，就必须要改索引，这样操作成本也比较高</li></ul> </li></ul> 
<h3><a id="_57"></a>自适应哈希索引</h3> 
<ul><li><strong>哈希索引的优点</strong> 
  <ul><li>数据检索的时候效率非常高，通常只需要 O(1) 的复杂度，也就是一次就可以完成数据的检索</li></ul> </li><li><strong>哈希索引的缺点</strong><br> <img src="https://images2.imgbox.com/7e/7f/JNkUiz2D_o.png" alt="在这里插入图片描述"></li><li><strong>自适应 Hash 索引</strong> 
  <ul><li>自适应指的是不需要人工来制定，系统会根据情况自动完成 
    <ul><li>如果某个<strong>索引值被使用的非常频繁时</strong>，就会将这个数据页的地址存放到 Hash 表中</li></ul> </li><li>自适应 Hash 索引只保存热数据，数据量并不会很大 
    <ul><li>因此自适应 Hash 也是存放到缓冲池中，这样也进一步提升了查找效率</li></ul> </li><li>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件<strong>加速定位到叶子节点</strong> 
    <ul><li>特别是当 B+ 树比较深的时候</li></ul> </li></ul> </li></ul> 
<h3><a id="SQL_71"></a>索引友好的SQL语句</h3> 
<ul><li><strong>什么时候需要创建索引：</strong> 
  <ul><li>字段的数值有唯一性的限制，比如用户名</li><li>频繁作为 WHERE 查询条件的字段 
    <ul><li>包括UPDATE和DELETE操作，因为需要先检索出来这条记录，然后再对它进行更新或删除</li></ul> </li><li>需要经常 GROUP BY 和 ORDER BY 的列</li><li>DISTINCT 字段需要创建索引</li></ul> </li><li><strong>什么时候不需要索引：</strong> 
  <ul><li>起不到定位的字段通常是不需要创建索引 
    <ul><li>即WHERE 或 GROUP BY、ORDER BY 里用不到的字段</li></ul> </li><li>频繁更新的字段不一定要创建索引 
    <ul><li>因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担</li></ul> </li><li>表记录太少时不需要创建索引</li><li>字段中如果有大量重复数据，也不用创建索引</li></ul> </li><li><strong>索引失效场景：</strong> 
  <ul><li>对索引进行了表达式计算</li><li>对索引使用函数</li><li>WHERE 子句中，在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引</li><li>使用 <code>LIKE</code> 进行模糊查询的时候，以<code>_</code>或<code>%</code>开头</li><li>索引列与 <code>NULL</code> 或者<code>NOT NULL </code>进行判断</li><li>NOT 等负向查询条件</li><li>字符串当整型使用等隐式类型转换</li><li>复合索引最左匹配失败</li><li>数据少时mysql觉得全表扫描更快<br> <img src="https://images2.imgbox.com/89/ed/VlXTbECf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/b1/8R4kTfDK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/59/G8PlOaFB_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h3><a id="_98"></a>索引原理</h3> 
<ul><li><strong>B树</strong><br> <img src="https://images2.imgbox.com/58/95/4xsw8dju_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0f/59/IUsKyOyX_o.png" alt="在这里插入图片描述"></li><li><strong>B+树</strong><br> <img src="https://images2.imgbox.com/c6/40/L90UN38S_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/85/ilB49kDs_o.png" alt="在这里插入图片描述"></li><li><strong>哈希</strong><br> <img src="https://images2.imgbox.com/68/13/QDS5TSwU_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="_115"></a>事务</h2> 
<ul><li>当开启了第一个事务，还没有进行 COMMIT 提交时直接进行第二个事务的 BEGIN，这时数据库会<strong>隐式地 COMMIT 第一个事务</strong>，然后再进入到第二个事务</li></ul> 
<h3><a id="_119"></a>隔离级别</h3> 
<ul><li>数据库高并发访问时，可以<strong>通过降低数据库的隔离标准，来换取事务之间的并发能力</strong> 
  <ul><li>隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大</li><li>需要在性能和正确性上进行权衡和取舍<br> <img src="https://images2.imgbox.com/e0/5a/Tscb0Mp8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/65/59/ljG7yNTG_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/62/f6/Yf0tq8zA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1a/ce/ebknM0Bo_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在 MySQL 中，<strong>默认的隔离级别是可重复读</strong></li><li>隔离的<strong>实现机制是锁</strong>，隔离级别越高锁的代价越大</li></ul> 
<h3><a id="MVCCMultiversion_Concurrency_Control_133"></a>MVCC（Multiversion Concurrency Control）</h3> 
<ul><li>MVCC<strong>机制</strong>可以<strong>解决不可重复读和幻读问题</strong> 
  <ul><li>在可重复读的情况下，InnoDB 可以通过 <strong>Next-Key 锁 +MVCC</strong> 来解决幻读问题</li><li>在读已提交的情况下，即使采用了 MVCC 方式也会出现幻读</li></ul> </li><li>MVCC 采用了<strong>乐观锁</strong>的方式，读取数据时<strong>并不需要加锁</strong>，对于写操作，也只锁定必要的行 
  <ul><li>这样可以让<strong>读写互相不阻塞</strong>，以提升事务并发处理能</li></ul> </li><li>MVCC 的<strong>核心就是 Undo Log+ Read View</strong> 
  <ul><li>“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理</li><li>“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示 
    <ul><li>针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别</li></ul> </li></ul> </li></ul> 
<h4><a id="Undo_Log_143"></a>Undo Log</h4> 
<ul><li>MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的<strong>思想就是保存数据的历史版本</strong></li><li>每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号） 
  <ul><li>这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序</li><li>这个ID记录在数据行中的隐藏列<code>db_trx_id</code>中</li></ul> </li><li>快照被保存在了位于<strong>回滚段</strong>的 Undo Log 里 
  <ul><li>通过隐藏列<code>db_roll_ptr</code>记录了回滚指针，指向了改行的 Undo Log</li><li>回滚指针将数据行的所有快照记录都通过<strong>链表</strong>的结构串联了起来</li><li>每个快照的记录都保存了当时的事务号，这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找<br> <img src="https://images2.imgbox.com/0c/1a/Ad59eBDl_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="Read_View_154"></a>Read View</h4> 
<ul><li><strong>快照读：</strong> 读取的是历史快照数据 
  <ul><li>不加锁的简单的 SELECT 都属于快照读</li></ul> </li><li><strong>当前读：</strong> 读取最新数据，而不是历史版本的数据 
  <ul><li>加锁的 SELECT，或者对数据进行增删改都会进行当前读</li></ul> </li><li>Read View 用于解决<strong>行的可见性问题</strong>，其保存了当前<strong>事务开启时所有活跃（还没有提交）的事务列表</strong> 
  <ul><li>也就是保存了不应该让这个事务看到的其他的事务 ID 列表<br> <img src="https://images2.imgbox.com/0b/20/WyIYvhmT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e6/ec/rfdloNns_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="InnoDB__163"></a>InnoDB 是如何解决幻读的</h4> 
<p><img src="https://images2.imgbox.com/24/4e/0DPw0ENV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/10/ec/ARQAWdEU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_168"></a>锁</h2> 
<p><img src="https://images2.imgbox.com/2f/3d/6Hcu6l62_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>共享锁</strong> 
  <ul><li>共享锁也叫读锁或 <strong>S 锁</strong></li><li>共享锁锁定的资源可以被其他用户读取，但不能修改 
    <ul><li>在进行SELECT的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改</li><li>当对数据表加上共享锁的时候，该数据表就变成了只读模式</li></ul> </li></ul> </li><li><strong>排它锁</strong> 
  <ul><li>排它锁也叫独占锁、写锁或 <strong>X 锁</strong></li><li>排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改 
    <ul><li>在进行INSERT、DELETE或者UPDATE的时候，数据库会自动使用排它锁，防止其他事务对该数据行进行操作</li></ul> </li></ul> </li><li><strong>意向锁</strong> 
  <ul><li>给更大一级别的空间示意里面是否已经上过锁 
    <ul><li>打算锁表的事务就能迅速获得足够的锁信息并决定下一步行动</li></ul> </li><li>例如给某一行数据加上了排它锁，数据库会自动给更大一级的空间（数据页或数据表）加上意向锁 
    <ul><li>因为如果表中的某个数据行被上了行锁，我们就无法获取<strong>该表的排它锁</strong></li><li>其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可</li><li>否则每次给表加锁时，需要首先遍历所有行，检查是否已经加锁了</li></ul> </li></ul> </li><li><strong>乐观锁</strong> 
  <ul><li>认为对同一数据的并发操作属于小概率事件，<strong>不采用数据库自身的锁机制</strong>，而是通过程序来实现</li><li>采用版本号机制或者时间戳机制实现，更新前判断当前拿到的数据是否最新</li></ul> </li><li><strong>悲观锁</strong> 
  <ul><li>对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性</li><li><strong>乐观锁和悲观锁并不是锁，而是锁的设计思想</strong><br> <img src="https://images2.imgbox.com/9c/06/QkDQjeIt_o.png" alt="在这里插入图片描述"></li></ul> </li><li><strong>死锁</strong>就是多个事务（如果是在程序层面就是多个进程）在执行过程中，因为竞争某个相同的资源而造成阻塞的现象 
  <ul><li>发生死锁，往往是因为在事务中，锁的获取是逐步进行的</li><li>当死锁发生的时候，就需要一个事务进行回滚，另一个事务获取锁完成事务，然后将锁释放掉</li></ul> </li><li><strong>死锁避免：</strong> 
  <ul><li>如果事务涉及多个表，则尽量一次锁定所有的资源，而不是逐步来获取</li><li>如果事务需要更新数据表中的大部分数据，则采用锁升级的方式，比如将行级锁升级为表级锁</li><li>不同事务并发读写多张数据表，可以约定访问表的顺序</li><li>采用乐观锁时不会发生死锁</li></ul> </li></ul> 
<h2><a id="_203"></a>存储引擎</h2> 
<h3><a id="_204"></a>表空间</h3> 
<ul><li>每张表都会单独保存为一个<code>.ibd</code> 文件<br> <img src="https://images2.imgbox.com/f9/1b/t2eBiDhu_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3c/ca/zDigJPWh_o.png" alt="在这里插入图片描述"></li><li>数据库 I/O 操作的<strong>最小单位是页</strong> 
  <ul><li>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载</li><li>按类型划分的话，常见的有数据页（保存 B+ 树节点）、系统页、Undo 页和事务数据页等<br> <img src="https://images2.imgbox.com/fc/0b/Ra5Fnw2G_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f5/11/XodhoXWC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/99/96/0B1qmaY7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/ca/HHFDsEfA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/c0/2dxfZ4yF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f1/63/U4I8vabr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8c/cf/akvf4wi2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/7e/ta9anUme_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h3><a id="_221"></a>内存缓冲池</h3> 
<p><img src="https://images2.imgbox.com/b1/9c/mS4KnByd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/db/92/W3JJd0Ve_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="SQL_226"></a>SQL语句执行流程</h2> 
<p><img src="https://images2.imgbox.com/6d/38/nFF4xXOp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fb/42/0vY8yTjD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a8/c6/6DhPLAbk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="SELECT_231"></a>SELECT查询顺序</h3> 
<p><img src="https://images2.imgbox.com/bf/ee/CBliRB0U_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/44/c3/6kLH880p_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d3/6f/zrNOtaGw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_236"></a>优化器</h3> 
<ul><li><strong>生成最佳执行计划</strong>的策略通常有以下两种方式 
  <ul><li>基于<strong>规则</strong>的<strong>逻辑优化</strong>（RBO） 
    <ul><li>规则就是人们以往的经验，或者是采用已经被证明是有效的方式</li><li>一般是基<strong>于关系代数等价性进行逻辑变换</strong>，减少无用开销 
      <ul><li>例如尽可能早地进行过滤，复杂条件分解和合并，子查询转JOIN等</li></ul> </li><li>每条sql经过RBO优化出来的结果都是<strong>固定的</strong></li></ul> </li><li>基于<strong>代价</strong>的<strong>物理优化</strong> （CBO） 
    <ul><li>根据<strong>代价评估模型</strong>，计算每条可能的执行计划的代价，从中选择代价最小的作为执行计划 
      <ul><li>例如读写IO、网络带宽，基数，数据分布等</li></ul> </li><li>会利用数据表中的<strong>统计信息</strong>来做判断，针对不同的数据表，查询得到的执行计划可能是不同的</li></ul> </li></ul> </li><li><strong>代价计算</strong><br> <img src="https://images2.imgbox.com/de/96/1BchOrYr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/9a/LG9vrYHq_o.png" alt="在这里插入图片描述"></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e73cf068f59c3d0cb3541ebe1c6ba0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux ubuntu 1804 版 安装过程图解说明--详细</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/248545427421206b9ad198bbcdca9875/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2022“杭电杯”中国大学生算法设计超级联赛（9）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>