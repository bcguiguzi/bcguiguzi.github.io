<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Day52    树状数组   线段树（lazy标记） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Day52    树状数组   线段树（lazy标记）" />
<meta property="og:description" content="动态求连续区间和
树状数组是利用lowbit的性质求前缀和
lowbit(x)= 2 k 2^{k} 2k,k的意思是x的二进制表达最后面有几位0
然后c[x]是对 [ x − 2 k , x ] [x-2^{k},x] [x−2k,x]范围内的q求和
然后修改，询问区间和都用到这个性质
#include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; #define lson (o&lt;&lt;1) #define rson (o&lt;&lt;1|1) #define fi first #define sc second #define dbg(x) cout&lt;&lt;#x&lt;&lt;&#34; = &#34;&lt;&lt;(x)&lt;&lt;endl; #define rg register typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; using namespace std; const double pi=acos(-1); const double eps=1e-6; inline int lowbit(int x){return x&amp;(-x);} template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){ A ans=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql; return ans; } inline int read() { int X=0,w=1; char c=getchar(); while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;) { if (c==&#39;-&#39;) { w=-1; } c=getchar(); } while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) { X=(X&lt;&lt;3)&#43;(X&lt;&lt;1)&#43;(c^48); c=getchar(); } return X*w; } //inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10&#43;&#39;0&#39;); } const int N=1e5&#43;10; ll T; int q[N],c[N],n,m; #define lowbit(x) (x&amp;-x) void add(int a,int b){ for(int i=a;i&lt;=n;i&#43;=lowbit(i)){ c[i]&#43;=b; } } int getsum(int a){ int res=0; for(int i=a;i;i-=lowbit(i)){ res&#43;=c[i]; } return res; } void solve(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i&#43;&#43;){ cin&gt;&gt;q[i]; add(i,q[i]); } int op,a,b; for(int i=0;i&lt;m;i&#43;&#43;){ cin&gt;&gt;op&gt;&gt;a&gt;&gt;b; if(op==0){ cout&lt;&lt;getsum(b)-getsum(a-1)&lt;&lt;endl; }else { add(a,b); } } } int main(){ std::ios::sync_with_stdio(0); std::cin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/53c264503b521cfa6c6452361d5e2eef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-03T22:12:08+08:00" />
<meta property="article:modified_time" content="2020-07-03T22:12:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Day52    树状数组   线段树（lazy标记）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://www.acwing.com/problem/content/1266/" rel="nofollow">动态求连续区间和</a><br> 树状数组是利用lowbit的性质求前缀和</p> 
<p>lowbit(x)=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          k 
         
        
       
      
        2^{k} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></span>,k的意思是x的二进制表达最后面有几位0<br> 然后c[x]是对<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         [ 
        
       
         x 
        
       
         − 
        
        
        
          2 
         
        
          k 
         
        
       
         , 
        
       
         x 
        
       
         ] 
        
       
      
        [x-2^{k},x] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span></span>范围内的q求和<br> 然后修改，询问区间和都用到这个性质</p> 
<pre><code>#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#define lson (o&lt;&lt;1)
#define rson (o&lt;&lt;1|1)
#define fi first
#define sc second
#define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl;
#define rg register
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&amp;(-x);}

template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){
	A ans=1;
	for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql;
	return ans;
}


inline int read()
{
    int X=0,w=1;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')
    {
        if (c=='-')
        {
            w=-1;
        }
        c=getchar();
    }
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48);
        c=getchar();
    }
    return X*w;
}
//inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); }
const int N=1e5+10; 
ll T;
int q[N],c[N],n,m;
#define lowbit(x) (x&amp;-x)

void add(int a,int b){
	for(int i=a;i&lt;=n;i+=lowbit(i)){
		c[i]+=b;
	}
}
int getsum(int a){
	int res=0;
	for(int i=a;i;i-=lowbit(i)){
		res+=c[i];
	}
	return res;
}
void solve(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;q[i];
		add(i,q[i]);
	}
	int op,a,b;
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;
		if(op==0){
			cout&lt;&lt;getsum(b)-getsum(a-1)&lt;&lt;endl;
		}else {
			add(a,b);
		}
	}
}


int main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	T=1;
	//cin&gt;&gt;T;
	while(T--){
		solve();
	}
	return 0;
}







</code></pre> 
<p><a href="https://www.acwing.com/problem/content/1267/" rel="nofollow">数星星</a><br> 注意增加星星的时候是增加在32000范围内的星星<br> 所以add的范围扩大到32000</p> 
<p>然后要注意y是递增输入的<br> 所以可以直接一行一行的增加我们的树状数组</p> 
<pre><code>#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#define lson (o&lt;&lt;1)
#define rson (o&lt;&lt;1|1)
#define fi first
#define sc second
#define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl;
#define rg register
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&amp;(-x);}

template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){
	A ans=1;
	for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql;
	return ans;
}


inline int read()
{
    int X=0,w=1;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')
    {
        if (c=='-')
        {
            w=-1;
        }
        c=getchar();
    }
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48);
        c=getchar();
    }
    return X*w;
}
//inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); }
const int N=32010;
ll T;
int q[N],level[N],n,ans[N];


void add(int a){
	for(int i=a;i&lt;=N;i+=lowbit(i)){
		level[i]++;
	}
}

int getsum(int a){
	int res=0;
	for(int i=a;i;i-=lowbit(i)){
		res+=level[i];
	}
	return res;
}

void solve(){
	cin&gt;&gt;n;
	int x,y;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;x&gt;&gt;y;
		x++;
		ans[getsum(x)]++;
		add(x);

	} 
	
	for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;
}
//01122

int main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	T=1;
	//cin&gt;&gt;T;
	while(T--){
		solve();
	}
	return 0;
}

</code></pre> 
<hr> 
<p>线段树<br> 下面是query中l和r不修改的原因<br> 因为tr[u].l+tr[u].r&gt;&gt;1和区间毫无关系<br> 甚至可能扩大查询区间<br> 比如下面查询[1，3]<br> 就会把3扩大成5<br> 从而查询到45的结果<br> <img src="https://images2.imgbox.com/5c/20/bjuuxxVZ_o.jpg" alt="在这里插入图片描述"><br> <a href="https://www.acwing.com/solution/content/8082/" rel="nofollow">线段树</a></p> 
<pre><code>#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#define lson (o&lt;&lt;1)
#define rson (o&lt;&lt;1|1)
#define fi first
#define sc second
#define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl;
#define rg register
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&amp;(-x);}

template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){
	A ans=1;
	for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql;
	return ans;
}


inline int read()
{
    int X=0,w=1;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')
    {
        if (c=='-')
        {
            w=-1;
        }
        c=getchar();
    }
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48);
        c=getchar();
    }
    return X*w;
}
//inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); }
const int N=1e5+10;
ll T;
struct node{
	int l,r,sum;
}tr[N*4];
int q[N];

void pushup(int u){
	tr[u].sum=tr[u&lt;&lt;1].sum+tr[u&lt;&lt;1|1].sum;
}

void build(int u,int l,int r){
	if(l==r){
		tr[u]={l,r,q[l]};
		return;
	}
	tr[u]={l,r};
	int mid=l+r&gt;&gt;1;
	build(u&lt;&lt;1,l,mid);
	build(u&lt;&lt;1|1,mid+1,r);
	pushup(u);
}

int query(int u,int l,int r){
	if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r){
		return tr[u].sum;
	}
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	int sum=0;
	if(l&lt;=mid)sum=query(u&lt;&lt;1,l,r);
	if(r&gt;mid)sum+=query(u&lt;&lt;1|1,l,r);
	return sum;
}

void add(int u,int x,int v){
	if(tr[u].l==tr[u].r){
		tr[u].sum+=v;
		return;
	}
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	if(x&lt;=mid)add(u&lt;&lt;1,x,v);
	else add(u&lt;&lt;1|1,x,v);
	pushup(u);
	
}

void solve(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;q[i];
	}
	build(1,1,n);
	int op,a,b;
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;
		if(op){
			add(1,a,b);
		}else{
			cout&lt;&lt;query(1,a,b)&lt;&lt;endl;
		}
	}
}


int main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	T=1;
	//cin&gt;&gt;T;
	while(T--){
		solve();
	}
	return 0;
}








</code></pre> 
<p>lazy标记的线段树</p> 
<pre><code>#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#define lson (o&lt;&lt;1)
#define rson (o&lt;&lt;1|1)
#define fi first
#define sc second
#define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl;
#define rg register
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&amp;(-x);}

template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){
	A ans=1;
	for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql;
	return ans;
}


inline int read()
{
    int X=0,w=1;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')
    {
        if (c=='-')
        {
            w=-1;
        }
        c=getchar();
    }
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48);
        c=getchar();
    }
    return X*w;
}
//inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); }
const int N=1e5+10;
ll T;
struct node{
	int l,r;
	ll sum,add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define add(x) tree[x].add
}tree[4*N];
ll q[N];

void build(int u,int l,int r){
	l(u)=l,r(u)=r;
	if(l==r){
		sum(u)=q[l];
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(u&lt;&lt;1,l,mid);
	build(u&lt;&lt;1|1,mid+1,r);
	sum(u)=sum(u&lt;&lt;1)+sum(u&lt;&lt;1|1);
}

void spread(int u){
	if(add(u)){
		sum(u&lt;&lt;1)+=add(u)*(r(u&lt;&lt;1)-l(u&lt;&lt;1)+1);
		sum(u&lt;&lt;1|1)+=add(u)*(r(u&lt;&lt;1|1)-l(u&lt;&lt;1|1)+1);
		add(u&lt;&lt;1)+=add(u);
		add(u&lt;&lt;1|1)+=add(u);
		add(u)=0;
	}
}

void change(int u,int l,int r,int v){
	if(l(u)&gt;=l&amp;&amp;r(u)&lt;=r){
		sum(u)+=(ll)v*(r(u)-l(u)+1);
		add(u)+=v;
		return;
	}
	spread(u); 
	int mid=l(u)+r(u)&gt;&gt;1;
	if(l&lt;=mid)change(u&lt;&lt;1,l,r,v);
	if(r&gt;mid)change(u&lt;&lt;1|1,l,r,v);
	sum(u)=sum(u&lt;&lt;1)+sum(u&lt;&lt;1|1);
}

ll query(int u,int l,int r){
	if(l(u)&gt;=l&amp;&amp;r(u)&lt;=r){
		return sum(u);
	}
	spread(u);
	int mid=l(u)+r(u)&gt;&gt;1;
	ll sum=0;
	if(l&lt;=mid)sum+=query(u&lt;&lt;1,l,r);
	if(r&gt;mid) sum+=query(u&lt;&lt;1|1,l,r);
	return sum;
}

void solve(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;q[i];
	build(1,1,n);
	int op,x,y;
	while(m--){
		cin&gt;&gt;op;
		if(op==1){
			cin&gt;&gt;x&gt;&gt;y;
			change(1,x,x,y);
		}else {
			cin&gt;&gt;x&gt;&gt;y;
			cout&lt;&lt;query(1,x,y)&lt;&lt;endl;
		//	query(1,x,y);
		}
	}
}


int main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	T=1;
	//cin&gt;&gt;T;
	while(T--){
		solve();
	}
	return 0;
}







</code></pre> 
<p>最好把lson和rson封装</p> 
<p>真的会写错。。。。</p> 
<p>然后注意mid缩小范围只在build中出现<br> spread要在判断完边界后立刻执行</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93a1cb11b3a8f454498a3d546ffb274f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络（三十二）：习题解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c25973b12a69f28b79759847b4f482b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter Dialog 之 ：CupertinoAlertDialog</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>