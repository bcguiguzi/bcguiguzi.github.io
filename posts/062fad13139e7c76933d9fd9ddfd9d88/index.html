<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S - Pod 的概念和简介 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S - Pod 的概念和简介" />
<meta property="og:description" content="1. POD的基本概念 Pod 是K8s 系统中可以创建（部署）和管理的最小单元。
Pod 里面可以包含多个容器(多实例），是一组容器的集合。
也就是讲K8S 不会直接管理容器
1个POD中的容器共享网络命名空间（共享ip）
POD 是短暂的（可以被创建 迁移）
来自google的解析， POD的存在是为了覆盖container的细节
2. POD 存在的意义 创建容器使用docker， 1个docker 对应1个container， 一个container对应1个进程， 一个container运行1个程序， 是1个单进程的设计。Pod 是1个多进程的设计， 可以运行多个应用程序。 1 个POD可以有多个容器， 1个容器运行1个应用程序Pod 存在为了亲密性应用，
** 两个应用之间进行交互 （直接调用）
** 网络之间调用 （API）， 如果不在同1个POD， 通常应用之间只能用ip调用， 如果在同1个POD， 可以用过127.0.0.1 和 socket直接调用
** 两个应用需要频繁调用（例如普通App 和 数据库） 上图的Pause 表示POD里面必须存在的根容器
3 POD 的实现机制 通常POD的实现基于两种机制
分别是
共享网络共享存储 3.1 共享网络机制 我们知道， 在docker中各个容器之间是相互隔离的。
在K8S 中， 容器也可以用namespace 和 group进行隔离。
但是如果两个容器在同1个POD 或namespace 中， 它们是可以做到网络共享的。（在同1个Namespace中是网络共享的大前提）
下面介绍的是在POD中网络共享机制的实现:
3.1.1 POD中多个容器的网络共享 如下图, 在POD的初始化中， 会首先建立1个根容器， 这个根容器通常被称为 Pause, 也可以叫做info容器。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/062fad13139e7c76933d9fd9ddfd9d88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-04T23:54:03+08:00" />
<meta property="article:modified_time" content="2022-12-04T23:54:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S - Pod 的概念和简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_POD_0"></a>1. POD的基本概念</h3> 
<ul><li> <p>Pod 是K8s 系统中可以创建（部署）和管理的最小单元。</p> </li><li> <p>Pod 里面可以包含多个容器(多实例），是一组容器的集合。</p> <p>也就是讲K8S 不会直接管理容器</p> </li><li> <p>1个POD中的容器共享网络命名空间（共享ip）</p> </li><li> <p>POD 是短暂的（可以被创建 迁移）</p> </li></ul> 
<p>来自google的解析， POD的存在是为了覆盖container的细节</p> 
<p><br><br></p> 
<h3><a id="2_POD__11"></a>2. POD 存在的意义</h3> 
<ul><li>创建容器使用docker， 1个docker 对应1个container， 一个container对应1个进程， 一个container运行1个程序， 是1个单进程的设计。</li><li>Pod 是1个多进程的设计， 可以运行多个应用程序。 1 个POD可以有多个容器， 1个容器运行1个应用程序</li><li>Pod 存在为了亲密性应用，<br> ** 两个应用之间进行交互 （直接调用）<br> ** 网络之间调用 （API）， 如果不在同1个POD， 通常应用之间只能用ip调用， 如果在同1个POD， 可以用过127.0.0.1 和 socket直接调用<br> ** 两个应用需要频繁调用（例如普通App 和 数据库）</li></ul> 
<p><img src="https://images2.imgbox.com/00/63/YsKG43AR_o.png" alt="在这里插入图片描述"></p> 
<p>上图的Pause 表示POD里面必须存在的根容器</p> 
<p><br><br></p> 
<h3><a id="3_POD__24"></a>3 POD 的实现机制</h3> 
<p>通常POD的实现基于两种机制<br> 分别是</p> 
<ul><li>共享网络</li><li>共享存储</li></ul> 
<p><br><br></p> 
<h5><a id="31__31"></a>3.1 共享网络机制</h5> 
<p>我们知道， 在docker中各个容器之间是相互隔离的。<br> 在K8S 中， 容器也可以用namespace 和 group进行隔离。<br> 但是如果两个容器在同1个POD 或namespace 中， 它们是可以做到网络共享的。（在同1个Namespace中是网络共享的大前提）</p> 
<p>下面介绍的是在POD中网络共享机制的实现:</p> 
<p><br><br></p> 
<h6><a id="311_POD_40"></a>3.1.1 POD中多个容器的网络共享</h6> 
<p>如下图, 在POD的初始化中， 会首先建立1个根容器， 这个根容器通常被称为 Pause, 也可以叫做info容器。<br> 在这个根容器中， 会被分配1个ip地址， mac地址和 ports端口。</p> 
<p>然后POD会继续根据用户要求创造若干个业务容器， 每个业务容器都会作为子容器加入到根容器中， 那么这些子容器就可以共享根容器的网络(ip mac port等）资源。</p> 
<p><img src="https://images2.imgbox.com/7f/b7/WH36loGi_o.png" alt="在这里插入图片描述"><br> yaml 例子：<br> 下面的yaml， 在同1个POD testPod1 中创建了两个容器， write-cont 和 read-cont, 至于根容器会被默认创建， 不用写在yaml中。<br> 这两个容器都被加入到根容器的网络资源使用者列表中， 所以 这两个容器是可以共享网络的。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> testPod1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> write<span class="token punctuation">-</span>cont
      <span class="token key atrule">image</span><span class="token punctuation">:</span> centos
      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bash"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"for i in {1..100}; do echo $i &gt;&gt; /data/hello; sleep 1; done"</span><span class="token punctuation">]</span>
      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data
          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data

    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>cont
      <span class="token key atrule">image</span><span class="token punctuation">:</span> centos
      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bash"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"tail -f /data/hello"</span><span class="token punctuation">]</span>
      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data
        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data

  <span class="token key atrule">volumns</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data
      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><br><br></p> 
<h5><a id="32__78"></a>3.2 共享存储机制</h5> 
<p>Pod的容器在运行中 ， 通常会不断产生数据， 为了持续使用， 必须对数据进行持久化。</p> 
<ul><li> <p>共享存储： 跟docker机制类似， K8S 引入数据卷概念， 使用数据卷进行持久化存储<br> 参考上面的yaml例子， 1个 write 容器会对1个公共的卷 data写数据， 而另1个容器 read可以从数据卷去读取数据。 因为他们都把数据卷挂在到容器中.</p> </li><li> <p>共享存储不只在POD的容器level， 实际上可以在Node之间， 让多个Node里面的POD 共享数据</p> </li></ul> 
<p><img src="https://images2.imgbox.com/5d/74/JiPbswSg_o.png" alt="在这里插入图片描述"></p> 
<p><br><br></p> 
<h3><a id="4_POD__90"></a>4 POD 的镜像拉取</h3> 
<p><br><br></p> 
<h5><a id="41__92"></a>4.1 镜像拉取策略</h5> 
<p>我们看下面的yaml例子</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">container</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
      <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token key atrule">nginx</span><span class="token punctuation">:</span> <span class="token number">1.14</span>
      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always   <span class="token comment"># 镜像拉取策略</span>
</code></pre> 
<p>上面的 imagePullPolicy 就是 镜像拉取策略<br> 有3个选项</p> 
<ul><li>IfNotPresent: 默认值， 镜像在宿主机不存在才拉取</li><li>Alway: 每次创建Pod时都会拉取</li><li>Never： Pod 永不会主动拉取镜像</li></ul> 
<p><br><br></p> 
<h3><a id="5_POD____114"></a>5 POD 的资源需求 和 资源限制</h3> 
<p>我们看1个例子<br> 假如我们要构建运行1个POD1， 在k8s 集群中， 系统会把这个POD 分配到其中1个 k8s node上运行。</p> 
<p>如果当前k8s 有如下面3个节点</p> 
<p>其中node1 的规格是4 core 8G<br> node2 的规格是1 core 2G<br> node3 的规格是2 core 4G</p> 
<p>而我们会觉得我们所建立的POD1正常运行至少需要2 core 4G, 如果被分配到POD2 运行则很有可能出问题</p> 
<p>这时我们可以设置POD1 的最少资源需求 为 2 core 4G.<br> 则k8s 就不会把这个POD 放到node2 去执行了。</p> 
<p>至于把POD1 放到node3 可行吗？， 则要看node3有没有其他POD在运行， 空闲资源怎么样。</p> 
<p>所以引申出另1个东西： 资源限制<br> 当POD1 在node1运行时， 如果我们不想它占用过多的node资源， 则可以作出限制。</p> 
<p>资源限制在yaml的关键字是</p> 
<pre><code class="prism language-yaml">spec.containers<span class="token punctuation">[</span>x<span class="token punctuation">]</span>.resources.requests.cpu   <span class="token comment"># 最低需求cpu数  1 代表 1 core, 1000m 代表 1 core,  500m 和 0.5 都代表 0.5 core</span>
spec.containers<span class="token punctuation">[</span>x<span class="token punctuation">]</span>.resources.requests.memory <span class="token comment"># 最低需要内存 单位是Mi, 1 Mi = 1 MB  	</span>
spec.containers<span class="token punctuation">[</span>x<span class="token punctuation">]</span>.resources.limits.cpu   <span class="token comment"># 最高能用到的cpu 数</span>
spec.containers<span class="token punctuation">[</span>x<span class="token punctuation">]</span>.resources.limits.memory <span class="token comment"># 能用到的最大内存限制</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/6e/91/Co0cihGK_o.png" alt="在这里插入图片描述"></p> 
<p>1个 yaml例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> Pod1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db
      <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql
      <span class="token key atrule">env</span><span class="token punctuation">:</span>
       <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MYSQL_ROOT_PASSWORD
         <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"password"</span>
       
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token comment"># 资源需求</span>
      	<span class="token key atrule">requests</span><span class="token punctuation">:</span>
      	  <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"120Mi"</span>
      	  <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span>
      	<span class="token key atrule">limits</span><span class="token punctuation">:</span>  <span class="token comment"># 资源限制</span>
      	  <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"500Mi"</span>
      	  <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"1000m"</span>
</code></pre> 
<p><br><br></p> 
<h3><a id="6_POD__171"></a>6 POD 的重启机制</h3> 
<p>当POD里面的容器非正常退出， POD会对容器作一些处理，这就是POD对容器的重启机制</p> 
<p>如下面的yaml例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> Pod1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> busybox
      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span>1.28.4
      <span class="token key atrule">args</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> /bin/sh
        <span class="token punctuation">-</span> <span class="token punctuation">-</span>c
        <span class="token punctuation">-</span> sleep 36000
    <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never <span class="token comment"># 重启机制</span>
</code></pre> 
<p>restartPolicy 的选项有3种：</p> 
<ul><li>Always: 当容器终止退出时， 总是会重启容器， 这个是默认策略</li><li>OnFailture: 当容器异常退出 (退出码非0）时才会重启</li><li>Never： 容器退出时不会重启， 多用于执行批量任务（批处理）</li></ul> 
<p><br><br></p> 
<h3><a id="7_POD__197"></a>7 POD 的健康检查</h3> 
<p>如果我们想查看 POD的运行状态， 可以用下面的命令</p> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6799fc88d8-scjht   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          7d
</code></pre> 
<p>但是这个Running status 并不能保证这个pod是健康的， 它并不能检查pod里面是否有oom or 程序已经崩溃的问题.<br> 通常靠谱的方法是调用POD里面程序的health checking 接口</p> 
<p>例如：</p> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ <span class="token function">curl</span> <span class="token parameter variable">-I</span> <span class="token number">127.0</span>.0.1:31407 
HTTP/1.1 <span class="token number">200</span> OK
Server: nginx/1.21.5
Date: Sun, <span class="token number">27</span> Nov <span class="token number">2022</span> <span class="token number">11</span>:59:18 GMT
Content-Type: text/html
Content-Length: <span class="token number">615</span>
Last-Modified: Tue, <span class="token number">28</span> Dec <span class="token number">2021</span> <span class="token number">15</span>:28:38 GMT
Connection: keep-alive
ETag: <span class="token string">"61cb2d26-267"</span>
Accept-Ranges: bytes
</code></pre> 
<p>但是K8S 允许我们在POD 的yaml文件中自定义 health checking 的规则</p> 
<p>其中</p> 
<h6><a id="1_livenessProbe__225"></a>1. livenessProbe （存活检查）</h6> 
<p>这个规则 如果health checking不通过， 则K8s 会kill掉 POD， 然后根据Pod 的restartPolily(上面的章节6) 的规则来操作</p> 
<h6><a id="2_readnessProbe__228"></a>2. readnessProbe （就绪检查）</h6> 
<p>这个规则下， 如果health checking 不通过， K8s 会直接将这个pod 从service endpoint 中移除。</p> 
<p><br><br><br> 而上面两个Probe 支持一下三种检查方法：</p> 
<h6><a id="1_httpGet_235"></a>1. httpGet</h6> 
<p>发送http 请求， 返回200 - 399 认为成功</p> 
<h6><a id="2_exec_238"></a>2. exec</h6> 
<p>执行shell 命令，如果返回的退出码是0， 则认为成功</p> 
<h6><a id="3_tcpSocket_241"></a>3. tcpSocket</h6> 
<p>发起TCP socket 连接， 如果连接建立， 则认为成功</p> 
<p>例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">test</span><span class="token punctuation">:</span> liveness
    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>liveness
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness
      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
      <span class="token key atrule">args</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> /bin/sh
        <span class="token punctuation">-</span> c
        <span class="token punctuation">-</span> mkdir <span class="token punctuation">-</span>p /tmp/healthy;
        <span class="token punctuation">-</span> sleep 30;
        <span class="token punctuation">-</span> rm <span class="token punctuation">-</span>rf /tmp/healthy
      <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
        <span class="token key atrule">exec</span><span class="token punctuation">:</span>
          <span class="token key atrule">command</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> ls /tmp/healthy
          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">perodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>

</code></pre> 
<p>上面的例子中， health checking的探针 在POD创建后5秒后就不断尝试隔5秒去检查 /tmp/healthy 文件夹， 当这个文件夹被删除后， 则会认为检查失败</p> 
<p><br><br></p> 
<h3><a id="8_POD__274"></a>8 POD 的调度策略</h3> 
<p>上面提到了， 我们用 kubectl get pods 命令可以查看pod的运行状态。<br> 但是如果想知道pod 是在哪个node去运行的，必须加多1个参数</p> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                     READY   STATUS    RESTARTS   AGE    IP           NODE       NOMINATED NODE   READINESS GATES
nginx-6799fc88d8-scjht   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          7d7h   <span class="token number">10.244</span>.1.5   k8snode0   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
gateman@k8smaster:~$ 
</code></pre> 
<p>可以看出， nigix 这个pod 跑在 k8snode0上。</p> 
<p>但是我们创建pod其实并不需要指定pod在哪个node上跑到的， 而是k8s会根据规则去自动分配。 这个规则就是所谓的POD 调度策略</p> 
<p><br><br></p> 
<h4><a id="81_POD_node_291"></a>8.1 POD 从建立到被分配（调度）到某个node的流程</h4> 
<h6><a id="811_POD_create__API_server_293"></a>8.1.1 用户发起POD create 指令 到API server处理</h6> 
<p>这一步在master node内完成， 毕竟api server是存在master node的</p> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> api
e2dc342dd4f8   bd16c7ea581a                                        <span class="token string">"kube-apiserver --ad…"</span>   <span class="token number">5</span> days ago   Up <span class="token number">5</span> days             k8s_kube-apiserver_kube-apiserver-k8smaster_kube-system_e12ac92bf1f55f7391d09a0523658312_2
906ba92f4bdf   registry.aliyuncs.com/google_containers/pause:3.5   <span class="token string">"/pause"</span>                 <span class="token number">5</span> days ago   Up <span class="token number">5</span> days             k8s_POD_kube-apiserver-k8smaster_kube-system_e12ac92bf1f55f7391d09a0523658312_2
</code></pre> 
<p>当API server接收到用户create POD指令后， 会把对应的POD创建信息写入 ectd<br> <img src="https://images2.imgbox.com/1c/ef/Pafwle7A_o.png" alt="在这里插入图片描述"><br> 其实到第一步， 指令会马上返回给用户， 用户一般需要等待一会才去查询POD状态， 所以后面的动作是异步的</p> 
<h6><a id="812_schedule___POD_node_307"></a>8.1.2 schedule 根据调度策略 分配 POD 到某个node</h6> 
<p>这一步也在master node内完成<br> 所谓Schedlue 就是会定时与API server沟通， 一旦发现有新的pod create指令， 则会从ectd 获得pod信息， 然后根据调度策略去分配node， 然后将结果写入ectd<br> <img src="https://images2.imgbox.com/69/10/OzOuclqL_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="813_Node__kubelet_poddockerpod_s_312"></a>8.1.3 Node 的 kubelet 会根据pod信息在自己的docker容器内创建pod 的容器(s)</h6> 
<p>这一步当然在node内完成啦。<br> <img src="https://images2.imgbox.com/f8/0d/LQLEUk1m_o.png" alt="在这里插入图片描述"></p> 
<p><br><br></p> 
<h4><a id="82_POD_317"></a>8.2 影响POD调度的一些因素</h4> 
<h6><a id="81__318"></a>8.1 资源限制</h6> 
<p>这个很容易理解， 如本文的第5 章</p> 
<pre><code class="prism language-yaml">  <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token comment"># 资源需求</span>
      	<span class="token key atrule">requests</span><span class="token punctuation">:</span>
      	  <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"120Mi"</span>
      	  <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span>
</code></pre> 
<p>如果1个POD 需要120M 内存， 而某个node 剩余内存不足120M, 则这个node不会被选择</p> 
<p><br><br></p> 
<h6><a id="82__329"></a>8.2 节点选择器标签</h6> 
<p>在Pod 的yaml 定义文件中， 我们还可以用标签选择器去选择被部署的node</p> 
<p>例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>env<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">nodeSeletor</span><span class="token punctuation">:</span>
    <span class="token key atrule">env_role</span><span class="token punctuation">:</span> dev
  <span class="token key atrule">contianers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ngnix
      <span class="token key atrule">images</span><span class="token punctuation">:</span> <span class="token key atrule">ngnix</span><span class="token punctuation">:</span> <span class="token number">1.15</span>
</code></pre> 
<p>上面的nodeSelector 中的env_role 就是所谓的标签选择器， 看名字也知道这个选择器跟不同的运行环境有关</p> 
<p>原理如图：<br> <img src="https://images2.imgbox.com/15/8c/BW5hFUnQ_o.png" alt="在这里插入图片描述"><br> 我们可以为每个node分别打上env_role 标签， 去定义这个node是输入 开发 or 测试 or 生产环境.</p> 
<p>当我们的某个pod的yaml文件中制定了 标签， 则master 只会把这个pod 部署去对应的nodes， 这个优先级是最高的。</p> 
<p><br><br></p> 
<h6><a id="node__357"></a>如何为某个node 打标签：</h6> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ kubectl label <span class="token function">node</span> k8snode0 <span class="token assign-left variable">env_role</span><span class="token operator">=</span>dev
node/k8snode0 labeled
</code></pre> 
<p><br><br></p> 
<h6><a id="nodelabels_364"></a>如何查看node的labels</h6> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ kubectl get nodes --show-labels
NAME         STATUS   ROLES                  AGE     VERSION    LABELS
admeuc-vm1   Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>                 7d22h   v1.22.15   beta.kubernetes.io/arch<span class="token operator">=</span>amd64,beta.kubernetes.io/os<span class="token operator">=</span>linux,env_role<span class="token operator">=</span>uat,kubernetes.io/arch<span class="token operator">=</span>amd64,kubernetes.io/hostname<span class="token operator">=</span>admeuc-vm1,kubernetes.io/os<span class="token operator">=</span>linux
amdeuc-vm2   Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>                 55m     v1.22.15   beta.kubernetes.io/arch<span class="token operator">=</span>amd64,beta.kubernetes.io/os<span class="token operator">=</span>linux,env_role<span class="token operator">=</span>uat,kubernetes.io/arch<span class="token operator">=</span>amd64,kubernetes.io/hostname<span class="token operator">=</span>amdeuc-vm2,kubernetes.io/os<span class="token operator">=</span>linux
amdeuc-vm3   Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>                 55m     v1.22.15   beta.kubernetes.io/arch<span class="token operator">=</span>amd64,beta.kubernetes.io/os<span class="token operator">=</span>linux,env_role<span class="token operator">=</span>dev,kubernetes.io/arch<span class="token operator">=</span>amd64,kubernetes.io/hostname<span class="token operator">=</span>amdeuc-vm3,kubernetes.io/os<span class="token operator">=</span>linux
k8smaster    Ready    control-plane,master   43d     v1.22.15   beta.kubernetes.io/arch<span class="token operator">=</span>amd64,beta.kubernetes.io/os<span class="token operator">=</span>linux,kubernetes.io/arch<span class="token operator">=</span>amd64,kubernetes.io/hostname<span class="token operator">=</span>k8smaster,kubernetes.io/os<span class="token operator">=</span>linux,node-role.kubernetes.io/control-plane<span class="token operator">=</span>,node-role.kubernetes.io/master<span class="token operator">=</span>,node.kubernetes.io/exclude-from-external-load-balancers<span class="token operator">=</span>
k8snode0     Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>                 43d     v1.22.15   beta.kubernetes.io/arch<span class="token operator">=</span>amd64,beta.kubernetes.io/os<span class="token operator">=</span>linux,env_role<span class="token operator">=</span>dev,kubernetes.io/arch<span class="token operator">=</span>amd64,kubernetes.io/hostname<span class="token operator">=</span>k8snode0,kubernetes.io/os<span class="token operator">=</span>linux

</code></pre> 
<p><br><br></p> 
<h6><a id="83__nodeAffinity_378"></a>8.3 节点亲和性 nodeAffinity</h6> 
<p>用法基本上与8.2 标签选择器一样， 但功能更加强大</p> 
<p>包括</p> 
<p><strong>8.3.1 硬亲和性，requireDuringSchedulingIgnoreDuringExecution</strong></p> 
<p>Node必须要满足亲和性的条件才会被选择， 如果没有任何node满足， 则POD的部署会一直等待</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
   <span class="token key atrule">requireDuringSchedulingIgnoreDuringExecution</span><span class="token punctuation">:</span>
     <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
       <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
         <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> env_role
           <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
           <span class="token key atrule">values</span><span class="token punctuation">:</span>
             <span class="token punctuation">-</span> dev
             <span class="token punctuation">-</span> test
<span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token key atrule">ngnix</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token key atrule">ngnix</span><span class="token punctuation">:</span> <span class="token number">1.15</span>
  
</code></pre> 
<p><strong>8.3.2 软亲和性，preferredDuringSchedulingIgnoreDuringExecution</strong></p> 
<p>就是require和prefer的区别<br> Node调度会尝试满足亲和性的条件， 但不保证一定满足。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
   <span class="token key atrule">preferredDuringSchedulingIgnoreDuringExecution</span><span class="token punctuation">:</span>
   <span class="token punctuation">-</span> weight： 1 <span class="token comment"># 权重</span>
     <span class="token key atrule">preference</span><span class="token punctuation">:</span>
       <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
         <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> env_role
           <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
           <span class="token key atrule">values</span><span class="token punctuation">:</span>
             <span class="token punctuation">-</span> dev
             <span class="token punctuation">-</span> test
<span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token key atrule">ngnix</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token key atrule">ngnix</span><span class="token punctuation">:</span> <span class="token number">1.15</span>
  
</code></pre> 
<p>Opertor - 常用的操作符</p> 
<pre><code class="prism language-bash">In
NotIn  <span class="token comment"># 所谓的反亲和性</span>
Exists
Gt
Lt
DoesNotExists <span class="token comment"># 所谓的反亲和性</span>
</code></pre> 
<p><br><br></p> 
<h6><a id="84__Taint_445"></a>8.4 污点和污点容忍 Taint</h6> 
<p>其实上面8.1 到 8.3 影响pod调度的属性都是在pod定义本身的。<br> 但是污点 Taint是跟POD定义无关的， 它是Node的属性… 用于作一些特别分配处理</p> 
<p><br><br><br> <strong>8.4.1 场景</strong></p> 
<p>a. 专用节点<br> 例如某些node的有外网网络， 会部署一些专用应用</p> 
<p>b. 配置特点硬件节点<br> 例如某写node具有ssd硬盘， 会部署大量IO的应用</p> 
<p>c. 基于Taint驱逐<br> 用于排除某些node</p> 
<p><br><br><br> <strong>8.4.2 查看node 的 污点信息</strong><br> kubectl describe node xxxxx | grep -i taint</p> 
<pre><code class="prism language-bash">gateman@k8smaster:~$ kubectl describe <span class="token function">node</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> taint
Taints:             <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
Taints:             <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
Taints:             <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
Taints:             node-role.kubernetes.io/master:NoSchedule
Taints:             <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
</code></pre> 
<p>只有master node 有1个污点， 表示 master node 有NoSchedule的污点</p> 
<p><br><br><br> <strong>8.4.3 3个污点的值</strong></p> 
<p>** NoSchedule 表示一定不会被调度<br> ** PreferNoSchedule 尽量不会被调度<br> ** NoExecute: 不会被调度， 并且还会驱逐Node的已有pods 这个 吊</p> 
<p><br><br><br> <strong>8.4.4 为Node打上污点</strong></p> 
<p>kubectl taint node [nodename] key=value #污点的3个值</p> 
<p>例如：</p> 
<pre><code class="prism language-bash">Kubectl taint <span class="token function">node</span> k8snode0 <span class="token assign-left variable">env_role</span><span class="token operator">=</span>dev:NoSchedule
</code></pre> 
<p>这样就代表， 如果POd选择了dev env_role 标签， pod也不会调度到这个k8snode0上， 会选择另个存在 dev标签的节点。</p> 
<p><br><br><br> <strong>8.4.4 为Node删除污点</strong><br> kubectl taint node [nodename] key：[污点值] -</p> 
<p><br><br><br> <strong>8.4.5 污点容忍</strong><br> 例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
 <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
   <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key"</span>
     <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>
     <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value"</span>
     <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span>
</code></pre> 
<p>一旦在pod 配置文件中 写上上面的污点容忍信息</p> 
<p>则代表即使打上对应污点的node也可能会被调度到…</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/047d68a6a6c03f4233f5093626dde816/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">制作composer包提供sdk扩展</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b3f789ac9eb703c79c285a9cda6ede2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win7下装anaconda3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>