<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>int128的实现（基本完成） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="int128的实现（基本完成）" />
<meta property="og:description" content="虽然有一个声明叫_int128但是这并不是C&#43;&#43;标准：
long long 不够用？详解 __int128 - FReQuenter - 博客园 (cnblogs.com)
网络上去找int128的另类实现方法，发现几乎都是在介绍_int128的
然后我就自己想了个办法，当时还没学C&#43;&#43;，用C草草写了下了事，也没有验证行不行
在这周一（2024/2/19）看了C&#43;&#43;的类以及运算符重载之后，我打算拿int128来练练手
重载倒是很快练好了，但是代码有大问题：
int128的实现（未完成）-CSDN博客
int128的实现_实现一个int128的数-CSDN博客
可以看看我之前的愚蠢的代码
主要是完全没注意到数爆出2^64的问题（主要体
#ifndef CSTDIO_ #define CSTDIO_ #include&lt;cstdio&gt; #endif #ifndef CCTYPE_ #define CCTYPE_ #include&lt;cctype&gt; #endif #ifndef VECTOR_ #define VECTOR_ #include&lt;vector&gt; #endif #ifndef INT128_H_ #define INT128_H_ typedef unsigned long long LLU;//64位 typedef unsigned int U;//32位 const U MAX32 = 0xFFFFFFFF; const LLU MAX64_U = 0xFFFFFFFF00000000; const LLU _2POW32 = (LLU)MAX32 &#43; 1; class INT128{ LLU A, B, C, D; public: INT128(LLU tmp = 0){A = B = 0, C = (tmp &amp; MAX64_U) &gt;&gt; 32, D = tmp &amp; MAX32;}; void getnum(void); INT128 operator-(const U &amp; tmp) const; INT128 operator&#43;(const LLU &amp; tmp) const; INT128 operator&#43;(const INT128 &amp; tmp) const; INT128 operator*(const U &amp; tmp) const; INT128 operator/(const U &amp; tmp) const; INT128 operator%(const U &amp; tmp) const; void operator=(const LLU &amp; tmp); void show(void); inline void function1(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data); inline void function2(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data); }; void INT128::getnum(void) { A = B = C = D = 0; std::vector&lt;int&gt; tmp; char c; while(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4a9a5aadb4804fd6960a2314aa6e3bbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-25T11:32:01+08:00" />
<meta property="article:modified_time" content="2024-02-25T11:32:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">int128的实现（基本完成）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>虽然有一个声明叫_int128但是这并不是C++标准：</p> 
<p><a href="https://www.cnblogs.com/FReQuenter5156/p/int128-post.html" rel="nofollow" title="long long 不够用？详解 __int128 - FReQuenter - 博客园 (cnblogs.com)">long long 不够用？详解 __int128 - FReQuenter - 博客园 (cnblogs.com)</a></p> 
<p></p> 
<p>网络上去找int128的另类实现方法，发现几乎都是在介绍_int128的</p> 
<p>然后我就自己想了个办法，当时还没学C++，用C草草写了下了事，也没有验证行不行</p> 
<p>在这周一（2024/2/19）看了C++的类以及运算符重载之后，我打算拿int128来练练手</p> 
<p>重载倒是很快练好了，但是代码有大问题：</p> 
<p><a href="https://blog.csdn.net/Fool256353/article/details/136199116" title="int128的实现（未完成）-CSDN博客">int128的实现（未完成）-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/Fool256353/article/details/134857128" title="int128的实现_实现一个int128的数-CSDN博客">int128的实现_实现一个int128的数-CSDN博客</a></p> 
<p>可以看看我之前的愚蠢的代码</p> 
<p></p> 
<p>主要是完全没注意到数爆出2^64的问题（主要体</p> 
<pre><code class="language-cpp">#ifndef CSTDIO_
#define CSTDIO_
#include&lt;cstdio&gt;
#endif

#ifndef CCTYPE_
#define CCTYPE_
#include&lt;cctype&gt;
#endif

#ifndef VECTOR_
#define VECTOR_
#include&lt;vector&gt;
#endif

#ifndef INT128_H_
#define INT128_H_

typedef unsigned long long LLU;//64位
typedef unsigned int U;//32位
const U MAX32 = 0xFFFFFFFF;
const LLU MAX64_U = 0xFFFFFFFF00000000;
const LLU _2POW32 = (LLU)MAX32 + 1;

class INT128{
    LLU A, B, C, D;
public:
    INT128(LLU tmp = 0){A = B = 0, C = (tmp &amp; MAX64_U) &gt;&gt; 32, D = tmp &amp; MAX32;};
    void getnum(void);
    INT128 operator-(const U &amp; tmp) const;
    INT128 operator+(const LLU &amp; tmp) const;
    INT128 operator+(const INT128 &amp; tmp) const;
    INT128 operator*(const U &amp; tmp) const;
    INT128 operator/(const U &amp; tmp) const;
    INT128 operator%(const U &amp; tmp) const;
    void operator=(const LLU &amp; tmp);
    void show(void);

    inline void function1(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data);
    inline void function2(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data);
};

void INT128::getnum(void)
{
    A = B = C = D = 0;
    std::vector&lt;int&gt; tmp;
    char c;
    while(!isdigit(c = getchar()))
        ;//清空数字前面的东西
    do
    {
        tmp.insert(tmp.begin(), c - '0');
    }while(isdigit(c = getchar()));
    ungetc(c, stdin);
    //开始赋值
    function1(tmp, D), function1(tmp, C), function1(tmp, B);
    for(int i = tmp.size() - 1; i &gt;= 0; i--)
        A = A * 10 + tmp[i];
}
INT128 INT128::operator-(const U &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A, A2 = B, A3 = 0, A4 = (C &lt;&lt; 32) + D - tmp;
    result.D = A4 &amp; MAX32, A3 += (A4 &amp; MAX64_U) &gt;&gt; 32;
    result.C = A3 &amp; MAX32, A2 += (A3 &amp; MAX64_U) &gt;&gt; 32;
    result.B = A2 &amp; MAX32, A1 += (A2 &amp; MAX64_U) &gt;&gt; 32;
    result.A = A1 &amp; MAX32;
    return result;
}
INT128 INT128::operator+(const LLU &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A, A2 = B, A3 = C, A4 = D + tmp;
    result.D = A4 &amp; MAX32, A3 += (A4 &amp; MAX64_U) &gt;&gt; 32;
    result.C = A3 &amp; MAX32, A2 += (A3 &amp; MAX64_U) &gt;&gt; 32;
    result.B = A2 &amp; MAX32, A1 += (A2 &amp; MAX64_U) &gt;&gt; 32;
    result.A = A1 &amp; MAX32;
    return result;
}
INT128 INT128::operator*(const U &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A, A2 = B, A3 = C, A4 = D;
    A1 *= tmp, A2 *= tmp, A3 *= tmp, A4 *= tmp;
    result.D = A4 &amp; MAX32, A3 += (A4 &amp; MAX64_U) &gt;&gt; 32;
    result.C = A3 &amp; MAX32, A2 += (A3 &amp; MAX64_U) &gt;&gt; 32;
    result.B = A2 &amp; MAX32, A1 += (A2 &amp; MAX64_U) &gt;&gt; 32;
    result.A = A1 &amp; MAX32;
    return result;
}
INT128 INT128::operator/(const U &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A, A2 = B, A3 = C, A4 = D;
    A2 += (A1 % tmp) &lt;&lt; 32, A1 /= tmp;
    A3 += (A2 % tmp) &lt;&lt; 32, A2 /= tmp;
    A4 += (A3 % tmp) &lt;&lt; 32, A3 /= tmp;
    A4 /= tmp;
    result.D = A4 &amp; MAX32, A3 += (A4 &amp; MAX64_U) &gt;&gt; 32;
    result.C = A3 &amp; MAX32, A2 += (A3 &amp; MAX64_U) &gt;&gt; 32;
    result.B = A2 &amp; MAX32, A1 += (A2 &amp; MAX64_U) &gt;&gt; 32;
    result.A = A1 &amp; MAX32;
    return result;
}
INT128 INT128::operator%(const U &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A, A2 = B, A3 = C, A4 = D;
    A2 += (A1 % tmp) &lt;&lt; 32;
    A3 += (A2 % tmp) &lt;&lt; 32;
    A4 += (A2 % tmp) &lt;&lt; 32;
    result.D = A4 % tmp;
    
    return result;
}
INT128 INT128::operator+(const INT128 &amp; tmp) const
{
    LLU A1, A2, A3, A4;
    INT128 result(0);
    A1 = A + tmp.A, A2 = B + tmp.B, A3 = C + tmp.C, A4 = D + tmp.D;
    result.D = A4 &amp; MAX32, A3 += (A4 &amp; MAX64_U) &gt;&gt; 32;
    result.C = A3 &amp; MAX32, A2 += (A3 &amp; MAX64_U) &gt;&gt; 32;
    result.B = A2 &amp; MAX32, A1 += (A2 &amp; MAX64_U) &gt;&gt; 32;
    result.A = A1 &amp; MAX32;
    return result;
}
void INT128::operator=(const LLU &amp; tmp)
{
    A = B = 0, C = (tmp &amp; MAX64_U) &gt;&gt; 32, D = tmp &amp; MAX32;
}
void INT128::show(void)
{
    std::vector&lt;int&gt; tmp;
    //A放进数组
    LLU n_tmp = A;
    int ext = 0;
    while(n_tmp)
    {
        tmp.push_back(n_tmp % 10);
        n_tmp /= 10;
    }
    //B，C，D放进数组
    function2(tmp, B), function2(tmp, C), function2(tmp, D);
    
    //输出
    if(!tmp.size())  tmp.push_back(0);
    for(int i = tmp.size() - 1; i &gt;= 0; i--)
        printf("%d", tmp[i]);
}
inline void INT128::function1(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data)
{
    LLU ext = 0;
    bool jud = false;
    for(int i = tmp.size() - 1; i &gt;= 0; i--)
    {
        ext = ext * 10 + tmp[i];
        tmp[i] = ext / _2POW32;
        jud = (jud || tmp[i]) ? true : false;
        if(!jud)  tmp.pop_back();
        ext %= _2POW32;
    }
    data = ext;
}
inline void INT128::function2(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data)
{
    LLU n_tmp = 0;
    int ext = 0;
    for(int i = 0; i &lt; tmp.size(); i++)
        n_tmp += _2POW32 * (LLU)tmp[i], tmp[i] = n_tmp % 10, n_tmp /= 10;
    while(n_tmp)
    {
        tmp.push_back(n_tmp % 10);
        n_tmp /= 10;
    }
    n_tmp = data, ext = 0;
    for(int i = 0; i &lt; tmp.size(); i++)
    {
        ext += n_tmp % 10 + tmp[i];
        tmp[i] = ext % 10, ext /= 10, n_tmp /= 10;
    }
    n_tmp += ext;
    while(n_tmp)
    {
        tmp.push_back(n_tmp % 10);
        n_tmp /= 10;
    }
}

#endif</code></pre> 
<p>现在上面的第一篇博客，第二篇博客因为没专门写输入输出，所以没爆掉）</p> 
<p>还有一个非常吃屎的东西：0xFFFFFFFF这个数，是2^32-1，不是2^32</p> 
<p></p> 
<p>顺便把输入吞掉一个字符的问题解决了（用了ungetc函数）</p> 
<p></p> 
<p>说说原理吧：</p> 
<p>总所周知，我们这里的最高位的int的位数是64位（long long），最高表示的数是2^64-1（无符号），只有18,446,744,073,709,551,615大概10的20次方，有的时候是不够用的，用高精度数组的速度的效率又相对较慢，这时候就想到了int128了</p> 
<p>但是只能你自己来实现（或者用上面的_int128啦，但是有的时候用不了），所以我就想了一种实现方法</p> 
<p>用4个unsignedlonglongint值来记录4个数，分别代表x1 * 2^96, x2 * 2 ^ 64, x3 * 2^32, x4。这样加起来，就是一个int128的数了，而且不会爆掉（之前是用两个数记录高低位的，输入输出爆了，运算倒是没有）</p> 
<p>然后按照数学的计算，就可以设计出加减乘除了</p> 
<p></p> 
<p>代码如下：</p> 
<p></p> 
<p>注：只有加法和赋值支持int128数，然后每种计算都支持常数，但是只有加法和赋值达到2^64-1，其他是2^32-1</p> 
<p>至于为什么不让每种计算都支持int128嘛，因为懒得写了，还有乘法会爆int128、没必要，而且蓝桥杯要到了，我得加紧算法的学习了（这个东西花了我4天去改，虽然不是每一刻都在想，但是也挺搞事的）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/280fa8b4d32c6615de390c98bb1bf801/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">104. lower()函数-将大写字母转换为小写</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a469a0950950cefdecc94098c862d40e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(None, 0, 5) 用keras.layers.MaxPool1D 出错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>