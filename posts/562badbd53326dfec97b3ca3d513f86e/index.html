<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分享几个ES6常用的方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分享几个ES6常用的方法" />
<meta property="og:description" content="1.什么是ES6 ？
ESMAScript 6.0(以下简称ES6)是 JavaScript 语言的下一代标准，已在2015年6月正式发布。它的目标：是使JavaScript语言可以编写复杂且大型应用，成为企业级开发语言。ES6既是一个历史名词，也是一个泛指，泛指涵盖了ES2015、ES2016、ES2017等的下一代JavaScript语言标准。 标准委员会规定每年6月正式发布一次标准，作为当年的正式版本。
2.了解Babel转码器
Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5，从而在老版本的浏览器中执行。不过现在的开发当中几乎不会用到了；所以说：你可以使用ES6的方式编写程序，也不用担心现有的环境是否支持。
// 转码前 input.map(item =&gt; item &#43; 1); // 转码后 input.map(function(item){ return item &#43; 1; }) 上面的原始代码用了箭头函数，Babel将其转为普通函数，就能在不支持箭头函数的 JavaScript环境执行了。目前各大技术栈（React/Vue/Angular）的脚手架项目都在使用babel作为默认的语言标准转码工具，可以在.babelrc文件中进行更多的自定义配置。
我们也可以通过官方提供的REPL在线编译器来体验Babel转码。
3.变量的解构赋值
ES6允许按照一定模式，从不同类型数据中提取值，然后对变量进行赋值，并且快读从对象或者数组里面获取一些数据，这杯称为：解构赋值
3.1 数组的解构赋值
在之前；我们给变量赋值只能直接指定一个变量值
let a = 12; let b = 11; let c = 10; 在ES6之后，就可以写成这样的
let [a, b, c] = [1, 2, 3]; 上面的代码表示，可以从数组中提取数值，按照对应的位置，对变量赋值。本质上，这种写法属于&#34;匹配模式&#34;，只要等号两边的模式相同，左边的变量就会被赋予对应的值，而解构赋值允许指定的默认值。
3.2 对象的解构赋值
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值：
语法：let {key1, key2, ...} = {键值对1, 键值对2, ...}
const JsonData = { name: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/562badbd53326dfec97b3ca3d513f86e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-17T10:33:43+08:00" />
<meta property="article:modified_time" content="2024-03-17T10:33:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分享几个ES6常用的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.什么是ES6 ？</p> 
<p><a href="https://www.w3cschool.cn/ecmascript/8j1d1q68.html" rel="nofollow" title="ESMAScript 6.0">ESMAScript 6.0</a>(以下简称<code>ES6</code>)是 <code>JavaScript</code> 语言的下一代标准，已在2015年6月正式发布。它的目标：是使<code>JavaScript</code>语言可以编写复杂且大型应用，成为企业级开发语言。<code>ES6</code>既是一个历史名词，也是一个泛指，<strong>泛指涵盖了ES2015、ES2016、ES2017等的下一代JavaScript语言标准。</strong> 标准委员会规定每年6月正式发布一次标准，作为当年的正式版本。</p> 
<p>2.了解Babel转码器</p> 
<p><a href="https://www.babeljs.cn/" rel="nofollow" title="Babel">Babel</a>是一个广泛使用的<code>ES6</code>转码器，可以将<code>ES6</code>代码转为<code>ES5</code>，从而在老版本的浏览器中执行。不过现在的开发当中几乎不会用到了；所以说：你可以使用<code>ES6</code>的方式编写程序，也不用担心现有的环境是否支持。</p> 
<pre><code>// 转码前
input.map(item =&gt; item + 1);

// 转码后
input.map(function(item){
	return item + 1;
})
</code></pre> 
<p>上面的原始代码用了箭头函数，<code>Babel</code>将其转为普通函数，就能在不支持箭头函数的 <code>JavaScript</code>环境执行了。目前各大技术栈（<code>React/Vue/Angular</code>）的脚手架项目都在使用<code>babel</code>作为默认的语言标准转码工具，可以在<code>.babelrc</code>文件中进行更多的自定义配置。</p> 
<p>我们也可以通过官方提供的<a href="https://babeljs.io/repl" rel="nofollow" title="REPL在线编译器">REPL在线编译器</a>来体验<code>Babel</code>转码。</p> 
<p>3.变量的解构赋值</p> 
<p><code>ES6</code>允许按照一定模式，从不同类型数据中提取值，然后对变量进行赋值，并且快读从对象或者数组里面获取一些数据，这杯称为：<strong>解构赋值</strong></p> 
<p>3.1 数组的解构赋值</p> 
<p>在之前；我们给变量赋值只能直接指定一个变量值</p> 
<pre><code>let a = 12;
let b = 11;
let c = 10;
</code></pre> 
<p>在<code>ES6</code>之后，就可以写成这样的</p> 
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre> 
<p>上面的代码表示，可以从数组中提取数值，按照对应的位置，对变量赋值。本质上，这种写法属于"匹配模式"，只要等号两边的模式相同，左边的变量就会被赋予对应的值，而解构赋值允许指定的默认值。</p> 
<p>3.2 对象的解构赋值</p> 
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值：</p> 
<p><strong>语法</strong>：<code>let {key1, key2, ...} = {键值对1, 键值对2, ...}</code></p> 
<pre><code> const JsonData = {
      name: "小彭",
      id: 727,
      status: "OK",
      data: [867, 5309],
      otherData1: 18,
      otherData2: ['www', 'itsource', 'cn'],
      otherData3: {
        a: 1
  }
}
console.log(JsonData.name,JsonData.id);
</code></pre> 
<p>3.3 函数参数的解构赋值</p> 
<p>函数的参数也可以使用解构赋值；并且也一样可以使用默认值。函数<code>sum()</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>a</code>和<code>b</code>。</p> 
<pre><code>function sum([a,b]){
  return a + b;
}
sum([1,7]);
</code></pre> 
<p>4.展开运算符</p> 
<p>展开运算符也叫扩展运算符。</p> 
<p><strong>语法</strong>： <strong>(...);</strong></p> 
<p></p> 
<p><img src="https://images2.imgbox.com/df/e2/GbXFPRsL_o.png" alt="b010401470cb43cfb876264f1d9fd3b4~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1432&amp;h=297&amp;s=63878&amp;e=png&amp;b=252930"></p> 
<p>除此之外，扩展运算符也可以展开数组和对象；并且可以对数组和对象进行浅拷贝、合并的功能；也可以将伪数组转换为真数组。</p> 
<p>5.模板字符串</p> 
<p>对于传统的<code>JavaScript</code>语言，输出一个模板字符串通常是这样写的。（此次用了<code>jQuery</code>的方法）</p> 
<pre><code>$('#result').append(
'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +
'items in your basket, ' +
'&lt;em&gt;' + basket.onSale +
'&lt;/em&gt; are on sale!'
);
</code></pre> 
<p>这种写法相当的繁琐，所以在ES6引入了模板字符串来解决繁琐等的诸多问题。</p> 
<pre><code>$('#result').append(`
There are &lt;b&gt;${basket.count}&lt;/b&gt; items
in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
are on sale!
`);
</code></pre> 
<p>模板字符串是增强版的字符串，用反引号<code>(``)</code>标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串，可以换行，也可以在字符串中直接输出变量。</p> 
<p>6.对象的简洁写法</p> 
<p>ES6中<strong>对象的属性和方法都有简写形式。</strong> 它的写法就是如果键名和键值的属性名是一样时，可以只写一个。对于函数来说；可以省略<code>冒号（:）</code>和<code>function</code>。</p> 
<pre><code>let name = "小彭";
let age = 22;
let gender = "male";

let person = {
    name,
    age,
    gender,
    // 省略 冒号(:)和function
    hobby () {
          console.log("爱好和平");
   },
    color () {
          console.log("蓝色");
    }
}
console.log(person);
</code></pre> 
<p>7.class</p> 
<p>7.1 class的由来</p> 
<p>在<code>ES5</code>中如果想要写一个类，传统的写法就是使用构造函数。另外可以定义静态方法。但是这种写法跟传统的面向对象语言的差异很大，很容易让初学者感到困惑；由此<code>ES6</code>提供更接近传统语言的写法，引入了<code>class</code>（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p> 
<pre><code>// 类(构造函数)
function Person(name, age){
// 定义实例属性
   this.name = name;
   this.age = age;
}
// 添加原型方法
Person.prototype.show = function () {
       console.log("我是原型方法");
 }
// 创建实例对象
let per = new Person("花开富贵", 22);
// 添加静态方法。静态方法是属于类自己的，实例对象调用不了。
 Person.say = function (){
     console.log("我是静态方法");
 }
</code></pre> 
<p>7.2 class的写法</p> 
<p><code>ES6</code>的<code>class</code>可以看作是一个语法糖，它的绝大部分功能，<code>ES5</code>都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p> 
<p><code>class</code>类的命名规则是大驼峰，并且<code>class</code>类里面有一个构造器，等价于构造函数；如果没有构造器，在实例化的时候会自动创建一个空的构造器。</p> 
<pre><code>class Test{
// 一般固定的属性会放在外层
  eye = 2;
  leg = 2;

constructor(name, age, gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
}

    show () {
        console.log("原型方法");
}
// 静态方法
    static () {
        console.log("静态方法");
}
}
// 实例化对象
let obj = new Test("小彭", 22, "male");
console.log(obj);
</code></pre> 
<p>7.3 class 继承</p> 
<p>使用<code>ES6</code> ，<code>class</code> 语法来改写之前寄生组合式继承的代码（使用<code>extends</code>关键字）；其中，<code>super</code>是父类构造函数，<code>ES6</code>规定，子类构造函数中必须执行一次<code>super</code>函数。</p> 
<p>继承中的属性或者方法查找原则：就近原则；先看自身有没有这个属性或者方法，有则用；如果没有，则查找父类，若有，则用。</p> 
<pre><code>// 狗狗继承动物
class Animal {
//构造器
eye = 2;
constructor(name, age){
     this.name = name;
     this.age = age;
}
        
color () {
     console.log("毛发细润呈白");
}

static hobby() {
     console.log("躺平");
  }
}
        
class Dog extends Animal {
    // 构造器
    // ES6 要求，子类的构造函数必须执行一次super函数。
    constructor(name,age) {
        super(name,age);
   }
 }

let dogs = new Dog("富贵", 2);
console.log(dogs);
</code></pre> 
<p>8.ES6 模块化</p> 
<p>什么是模块化 ？ 一个 <code>JS</code> 文件就是一个模块。</p> 
<p>模块功能主要由两个命令构成：<code>import</code>和<code>export</code></p> 
<ol><li><code>import</code>命令用于导入其他模块提供的功能</li><li><code>export</code>命令用于规定模块的对外接口</li></ol> 
<p>8.1 语法一</p> 
<p>导出/暴露：</p> 
<p><code>export</code> 要导出的内容1</p> 
<p><code>export</code> 要导出的内容2</p> 
<p><code>export</code> 要导出的内容3</p> 
<p>导入：</p> 
<p><code>import{导入的内容1, 导入的内容2, 导入的内容3，....} from '文件模块路径'</code></p> 
<p>步骤 ：</p> 
<ol><li>先建立文件，两个为<code>js</code>，一个为<code>HTML</code></li></ol> 
<p></p> 
<p><img src="https://images2.imgbox.com/37/17/ZZ2T2uXL_o.png" alt="9f2be14e06504cf1a6f83ccfe0b676b2~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1184&amp;h=121&amp;s=6669&amp;e=png&amp;b=23272e"></p> 
<ol><li>将要写或者要用的<code>js</code>代码放在其中一个文件中，我是放在了<code>index.js</code>中。并且要在导出的代码块前面加上<code>export</code></li></ol> 
<p></p> 
<p><img src="https://images2.imgbox.com/cd/ca/91tbgYyL_o.png" alt="f1a8f5352e1343369b1c9c522a863e6d~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1307&amp;h=560&amp;s=95705&amp;e=png&amp;b=22262d"></p> 
<ol><li>将<code>index.js</code>文件引入到另外一个<code>js</code>文件中，导入的时候路径和文件后缀名不能省略，更不能本地打开，要通过<code>live Serve</code>打开。</li></ol> 
<p></p> 
<p><img src="https://images2.imgbox.com/36/e4/LWyvikof_o.png" alt="fa9695eec3b54f798863773b90a6078c~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1219&amp;h=259&amp;s=34994&amp;e=png&amp;b=23272e"></p> 
<ol><li>最后再把这个<code>b.js</code>文件引入到<code>html</code>中，但是在<code>script</code>标签类型必须是<code>module</code>，否则会报错。</li></ol> 
<p></p> 
<p><img src="https://images2.imgbox.com/c0/8a/2TXeUQ9D_o.png" alt="7dc7ba7e79ea48a6871e3a1478f5dd45~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1035&amp;h=109&amp;s=16595&amp;e=png&amp;b=242930"></p> 
<p>8.2 语法二</p> 
<p>语法二的引用过程和语法是一模一样的。</p> 
<p>导出：<code>export default{ 要导出的内容 }</code></p> 
<p>导入：<code>import 变量 from '文件模块路径'</code></p> 
<p>使用<code>export default</code>命令是为了给模块指定默认的导出，<code>import</code>时可以为其任意命名（一般导出和导入的命名保持相同）。显然，一个模块只能有一个默认导出，因此<code>export default</code>命令只能使用一次。所以，<code>import</code>命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p> 
<p></p> 
<p><img src="https://images2.imgbox.com/2e/9c/46fdcx3l_o.png" alt="b654b3be2574477c9796687981f864e2~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1304&amp;h=871&amp;s=75430&amp;e=png&amp;b=24282f"></p> 
<p></p> 
<p><img src="https://images2.imgbox.com/35/06/h8XWoqFL_o.png" alt="0e6d1e6eb02044e792b07d2449f3405c~tplv-k3u1fbpfcp-jj-mark:1100:0:0:0:q75.image#?w=1118&amp;h=260&amp;s=27132&amp;e=png&amp;b=24282f"></p> 
<p>8.3 ES6 模块化的优势</p> 
<p>写法之外，相较于<code>ES5</code>时代的模块化方案，<code>ES6</code>模块化有着诸多优势。其中最主要的优势是「静态加载」。<code>ES6</code>模块的设计思想是尽量的静态化，使得<strong>编译时</strong> <strong>就能确定模块的依赖关系，以及输入和输出的变量</strong>。<code>CommonJS</code>和<code>AMD</code>模块，都只能在运行时确定这些东西。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性。</p> 
<p>静态加载，也叫编译时加载，它的好处是：</p> 
<p>（1）编译时就能完成模块加载，加载效率要比运行时高得多；</p> 
<p>（2）使得「静态分析」成为可能。有了它，就能进一步拓宽 <code>JavaScript</code> 的语法，比如引入「宏」和「类型检验」这些只能靠静态分析实现的功能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3e215f44bc2d4001aacbc4e3d31d95d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文阅读：Face Deblurring using Dual Camera Fusion on Mobile Phones</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b127055ab322923df040f6e953298678/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无线安全：WEP、WPA、WPA2 和 WPA3 说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>