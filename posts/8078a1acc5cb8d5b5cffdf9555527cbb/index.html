<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AI - 决策树模型 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AI - 决策树模型" />
<meta property="og:description" content="🤔决策树算法 决策树的思想来源可以追溯到古希腊时期，当时的哲学家们就已经开始使用类似于决策树的图形来表示逻辑推理过程。然而，决策树作为一种科学的决策分析工具，其发展主要发生在20世纪。
在20世纪50年代，美国兰德公司的研究人员在研究军事策略时首次提出了决策树的概念。他们使用决策树来分析和比较不同的军事策略，以帮助决策者做出最佳选择。
决策树的基本思想是，通过构建一个树状的图形模型，将决策过程中的各种可能情况和结果以直观的方式展现出来。每一个节点代表一个决策或事件，每一个分支代表一个可能的结果，而树的每一个路径则代表一种可能的决策序列。这种思想的朴素之处在于，它直接模仿了人类在日常生活中做决策的过程。人们在面对一个复杂的问题时，往往会将其分解为一系列的小问题，然后逐个解决。当选择一个餐厅时，可能会考虑菜品的口味、价格区间、餐厅的位置等因素。这些因素可以构成一个决策树，其中每个因素是决策节点，每个选择是方案枝，最终到达叶子节点，即做出决策。
决策树的思想虽然朴素，但它却能够处理非常复杂的决策问题，因此被广泛应用于经济学、管理学、计算机科学等多个领域。
🔎sklearn实现决策树分类 鸢尾花数据绘制图像
from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score from sklearn import tree import matplotlib.pyplot as plt # 加载鸢尾花数据集 iris = datasets.load_iris() X = iris.data y = iris.target # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # 创建决策树分类器 clf = DecisionTreeClassifier() # 训练模型 clf.fit(X_train, y_train) # 预测测试集 y_pred = clf.predict(X_test) # 计算准确率 accuracy = accuracy_score(y_test, y_pred) print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8078a1acc5cb8d5b5cffdf9555527cbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T15:13:26+08:00" />
<meta property="article:modified_time" content="2024-03-16T15:13:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AI - 决策树模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">🤔决策树算法</h4> 
<p>决策树的思想来源可以追溯到古希腊时期，当时的哲学家们就已经开始使用类似于决策树的图形来表示逻辑推理过程。然而，决策树作为一种科学的决策分析工具，其发展主要发生在20世纪。</p> 
<p>在20世纪50年代，美国兰德公司的研究人员在研究军事策略时首次提出了决策树的概念。他们使用决策树来分析和比较不同的军事策略，以帮助决策者做出最佳选择。</p> 
<p>决策树的基本思想是，通过构建一个树状的图形模型，将决策过程中的各种可能情况和结果以直观的方式展现出来。每一个节点代表一个决策或事件，每一个分支代表一个可能的结果，而树的每一个路径则代表一种可能的决策序列。这种思想的朴素之处在于，它直接模仿了人类在日常生活中做决策的过程。人们在面对一个复杂的问题时，往往会将其分解为一系列的小问题，然后逐个解决。当选择一个餐厅时，可能会考虑菜品的口味、价格区间、餐厅的位置等因素。这些因素可以构成一个决策树，其中每个因素是决策节点，每个选择是方案枝，最终到达叶子节点，即做出决策。</p> 
<p>决策树的思想虽然朴素，但它却能够处理非常复杂的决策问题，因此被广泛应用于经济学、管理学、计算机科学等多个领域。</p> 
<h4><strong>🔎sklearn实现决策树分类</strong></h4> 
<p>鸢尾花数据绘制图像</p> 
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn import tree
import matplotlib.pyplot as plt

# 加载鸢尾花数据集
iris = datasets.load_iris()
X = iris.data
y = iris.target

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 创建决策树分类器
clf = DecisionTreeClassifier()

# 训练模型
clf.fit(X_train, y_train)

# 预测测试集
y_pred = clf.predict(X_test)

# 计算准确率
accuracy = accuracy_score(y_test, y_pred)
print("准确率：", accuracy)

# 绘制决策树图像
fig, ax = plt.subplots(figsize=(12, 12))
tree.plot_tree(clf, filled=True, feature_names=iris.feature_names, class_names=iris.target_names, ax=ax)
plt.show()
</code></pre> 
<p>构建决策树包括三个：</p> 
<ul><li> <p>特征选择：选取有较强分类能力的特征</p> </li><li> <p>决策树生成</p> </li><li> <p>决策树剪枝</p> </li></ul> 
<h4> 🔎ID3 决策树</h4> 
<p> ID3 树是基于信息增益构建的决策树，算法的核心在于使用信息增益作为属性选择的标准，即在每个节点选择尚未被用来划分的、具有最高信息增益的属性作为划分标准。通过这种方式，算法递归地构建决策树，直到所有的训练样本都能被完美分类。</p> 
<ul><li><strong>计算信息熵</strong>：首先需要了解信息熵的概念，它衡量的是数据集中的不确定性或混乱程度。信息熵的计算公式为 Entropy = -∑(p(xi) * log2(p(xi)))，其中 p(xi) 是第 i 类样本出现的概率。</li></ul> 
<ul><li>熵越大，数据的不确定性度越高</li><li>熵越小，数据的不确定性越低</li></ul> 
<p>假如有三个类别，分别占比为：{⅓,⅓,⅓}，信息熵计算结果 1.0986；</p> 
<p>若分别占比为：{1/10,2/10,7/10}，信息熵计算结果为 0.8018。</p> 
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def entropy(p):
    return -p*np.log(p)-(1-p)*np.log(1-p)

x = np.linspace(0.01,0.99,200)
plt.plot(x,entropy(x))
plt.show()
</code></pre> 
<p> <img alt="" src="https://images2.imgbox.com/17/15/EjcmnLS4_o.png"></p> 
<p>当我们的系统每一个类别是等概率的时候，系统的信息熵最高，直到系统整体百分之百的都到某一类中，此时信息熵就达到了最低值。</p> 
<p><strong>条件熵用于衡量以某个特征作为条件，对目标值纯度的提升程度。</strong></p> 
<p>💡信息增益</p> 
<p>信息增益反映了在一个条件下，信息的不确定性减少了多少。它是通过计算信息熵和条件熵的差值得出的。条件熵是在已知某个条件或属性的情况下，数据集的不确定性。它通常用于衡量在给定某个属性的条件下，目标变量的不确定性。信息增益差值越大，说明该属性对于分类的贡献越大，因此在构建决策树时，我们倾向于选择信息增益大的属性作为节点的划分依据。</p> 
<h4 id="c45">🔎C4.5 决策树</h4> 
<p><strong>C4.5决策树算法是ID3算法的改进版本，它使用信息增益率来选择划分特征</strong>。</p> 
<p>C4.5算法在构建决策树时采用了与ID3算法相似的自顶向下的贪婪搜索策略，但它在以下几个方面进行了重要的改进和优化：</p> 
<ul><li><strong>信息增益率</strong>：C4.5算法使用信息增益率而非信息增益来选择划分特征。信息增益率是信息增益与分裂信息（split information）的比值，这种方法克服了ID3算法中信息增益倾向于选择取值较多的属性的不足。</li><li><strong>处理连续属性</strong>：C4.5算法能够处理离散型和连续型的属性。对于连续型属性，算法会进行离散化处理，将其转换为可以用于决策树的离散值。</li><li><strong>剪枝操作</strong>：在构造决策树之后，C4.5算法会进行剪枝操作，以减少模型的过拟合风险，提高模型的泛化能力。</li><li><strong>处理缺失值</strong>：C4.5算法能够处理具有缺失属性值的训练数据，这使得算法更加健壮和适用于现实世界的数据。</li><li><strong>数据：</strong>C4.5算法可以处理离散型描述属性，也可以处理连续数值型属性</li></ul> 
<h4>🔎CART 分类决策树 </h4> 
<p>CART，全称为Classification and Regression Tree，即分类回归树，是一种非常灵活且功能强大的机器学习算法。它与之前的ID3和C4.5算法不同，CART能够处理连续型数据的分类以及回归任务。CART生成的是二叉树，这意味着在每个非叶节点上只会有两个分支。这样的结构有助于简化模型，提高解释性。CART使用基尼系数作为特征选择的标准。基尼系数衡量的是数据集的不纯度，基尼系数越小，表示数据越纯，即分类越明确。这与信息增益（率）的概念相反，后者是在ID3和C4.5中使用的。</p> 
<p>基尼指数值越小（cart），则说明优先选择该特征。假设有一个包含两个类别的数据集，其中类别A有10个样本，类别B有20个样本。我们可以使用以下公式计算基尼指数：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/33/fb/e8OTt3Fw_o.png"></p> 
<p>其中，pi​是第i个类别在数据集中出现的概率，m是类别的数量。在这个例子中，m=2 ，因此：Gini=1−(10/30)2−(20/30)2=0.475</p> 
<p>这意味着这个数据集的基尼指数为0.475，表示数据集的不纯度较高，基尼指数只适用于二分类问题，对于多分类问题需要使用其他指标，如信息增益、信息增益率等。</p> 
<h4>🔎Cart分类树原理 </h4> 
<p>如果目标变量是离散变量，则是classfication Tree分类树。决策树算法对训练集很容易过拟合，导致泛化能力很差，为解决此问题，需要对CART树进行剪枝。CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小，从而能够对未知数据有更准确的预测，也就是说CART使用的是后剪枝法。一般分为两步：先生成决策树，产生所有可能的剪枝后的CART树，然后使用交叉验证来检验各种剪枝的效果，最后选择泛化能力好的剪枝策略。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3b/e1/Iu2c2uXi_o.png"></p> 
<p style="text-align:center;"> </p> 
<p>💎 决策树算法sklearn总结</p> 
<p> 在<code>sklearn</code>中，决策树算法主要通过<code>DecisionTreeClassifier</code>类实现。<code>DecisionTreeClassifier</code>类的构造方法接受多个参数，用于控制决策树的构建过程和行为。</p> 
<ul><li><code>criterion</code>：用于特征选择的准则，可选"gini"（基尼系数）或"entropy"（信息增益）。</li><li><code>splitter</code>：用于节点划分的策略，可选"best"（最优划分）或"random"（随机划分）。</li><li><code>max_depth</code>：决策树的最大深度，用于防止过拟合。</li><li><code>min_samples_split</code>：内部节点再划分所需最小样本数。</li><li><code>min_samples_leaf</code>：叶节点所需的最小样本数。</li><li><code>class_weight</code>：类别权重，用于处理不平衡数据集。</li></ul> 
<p><strong>训练方法</strong>：使用<code>fit</code>方法来训练决策树模型，传入训练数据和对应的标签。</p> 
<pre><code class="language-python">from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier

# 加载数据集
iris = load_iris()
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.3, random_state=42)

# 创建决策树分类器实例
clf = DecisionTreeClassifier(criterion="gini", max_depth=4)

# 训练模型
clf.fit(X_train, y_train)</code></pre> 
<p><strong>预测方法</strong>：使用<code>predict</code>方法进行预测，输入待预测的数据，输出预测结果。</p> 
<pre><code class="language-python">y_pred = clf.predict(X_test)</code></pre> 
<p><strong>评估方法</strong>：可以使用<code>score</code>方法来评估模型的准确性。</p> 
<pre><code class="language-python"># 计算准确率
accuracy = clf.score(X_test, y_test)</code></pre> 
<p><code>sklearn</code>中的决策树算法提供了一个灵活且易于使用的机器学习模型，适用于各种分类问题。通过调整不同的参数和选择合适的特征选择准则，可以有效地控制决策树的行为和性能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c0f6be1ab30ef7badc735ed2c9069f73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于springboot的博物馆管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b73893d63a3e158a983e4d955388a139/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Python&#43;Django&#43;协同过滤算法的招聘信息推荐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>