<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（济南）C Stone Game【题解】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（济南）C Stone Game【题解】" />
<meta property="og:description" content="牛客竞赛传送门：
本题链接：https://ac.nowcoder.com/acm/problem/216161?&amp;headNav=acm
比赛完整题单：https://ac.nowcoder.com/acm/contest/10662
通过率：531/931
题目大意：
有n堆石头，每堆石头由1~3个石头组成，现在要把这n堆石头合并成1堆，每次操作只能两两合并，且会产生费用，求最小费用。费用计算方法：这两堆各含石头x个和y个，合并的费用为(x mod 3) * (y mod 3)。题目第一行给出三个数，第i个数表示由i个石头所组成的堆的堆数是多少。
知识点：贪心、思维题
思路：
因为合并只能两两合并，我们先看看两两合并会发生什么（本文 ~ 表示合并的意思）
1~1 费用为11~2 费用为22~2 费用为41~3 费用为02~3 费用为03~3费用为0（4等价为1，不需要继续枚举了）1~4（等价于1~1） 整理上面表格得：
1~1费用为1生成一个新堆，大小为2新堆等价大小为21~2费用为2生成一个新堆，大小为3新堆等价大小为32~2费用为4生成一个新堆，大小为4新堆等价大小为13~x费用为0生成一个新堆，大小为3&#43;x新堆等价大小为x 因为我们要计算最后全部合并完的费用，如果剩下的堆的大小都等价为3，那么他们继续合并，就不会增加额外的费用，也就得到了最终答案。所以我们要以生成新堆的大小为3为短期目标，列表观察最小费用的合并方式。
1~1等价大小为2，要再于1合并（1~1）~1费用为1&#43;2=3生成一个新堆，大小为31~2等价大小为3，无需继续合并 1~2费用为2生成一个新堆，大小为32~2等价大小为1，要再与2合并（2~2）~2费用为4&#43;2=6生成一个新堆，大小为33~x等价大小为x 3~x费用为0生成一个新堆，大小为x 于是发现，我们以多次合并生成等价大小为3的堆作为循环节，费用最小的合并方式是1~2。
由此得到贪心策略：
1、先把所有的1与2合并了先；
2、之后就只剩下两种情况，
①d堆个数为1的堆和个数为3的堆。
②d堆个数为2的堆和个数为3的堆。
那么就只能用（1~1）~1和（2~2）~2这两种策略分别处理；
3、处理后会分别得到三种情况（以剩下的堆是个数为1的 举例）：
①d%3==0（即d==0），皆大欢喜，1与2合并后没有剩余。
②d%3==1，也很欢喜，此时情况为：1个个数为1的堆，和很多个个数为3的堆
用3~x的策略，也不会产生新的费用。
③d%3==2，此时情况为：2个个数为1的堆，和很多个个数为3的堆
这两个1合并会产生新的费用，要额外加上。
4、最后再用3~x的策略合并成1堆。这一步不会产生任何费用。这里的x可能为1，2，3。
样例图解：
AC代码：
#include &lt;bits/stdc&#43;&#43;.h&gt; #define int long long using namespace std; signed main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int ans = 0; if (a == b){ ans = a * 2; } else if (a &gt; b){ int d = a - b;//剩下d堆个数为1的堆和个数为3的堆 if (d % 3 == 2)//1 1 3的情况 ans&#43;&#43;; ans &#43;= b * 2 &#43; (d - d % 3); } else{ // a&lt;b int d = b - a;//剩下d堆个数为2的堆和个数为3的堆 if (d % 3 == 2)//2 2 3的情况 ans &#43;= 4; ans &#43;= a * 2 &#43; (d - d % 3) * 2; } cout &lt;&lt; ans &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c4322e0d2e0d157109bd96aa5fde6131/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-04T11:51:27+08:00" />
<meta property="article:modified_time" content="2022-12-04T11:51:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（济南）C Stone Game【题解】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>牛客竞赛传送门：</p> 
<p>        本题链接：<a href="https://ac.nowcoder.com/acm/problem/216161?&amp;headNav=acm" rel="nofollow" title="https://ac.nowcoder.com/acm/problem/216161?&amp;headNav=acm">https://ac.nowcoder.com/acm/problem/216161?&amp;headNav=acm</a></p> 
<p>        比赛完整题单：<a href="https://ac.nowcoder.com/acm/contest/10662" rel="nofollow" title="https://ac.nowcoder.com/acm/contest/10662">https://ac.nowcoder.com/acm/contest/10662</a></p> 
<p></p> 
<p>通过率：531/931</p> 
<p></p> 
<p>题目大意：</p> 
<p>        有n堆石头，每堆石头由1~3个石头组成，现在要把这n堆石头合并成1堆，每次操作只能两两合并，且会产生费用，求最小费用。费用计算方法：这两堆各含石头x个和y个，合并的费用为(x mod 3) * (y mod 3)。题目第一行给出三个数，第i个数表示由i个石头所组成的堆的堆数是多少。</p> 
<p></p> 
<p>知识点：贪心、思维题</p> 
<p></p> 
<p>思路：</p> 
<p>        因为合并只能两两合并，我们先看看两两合并会发生什么<strong>（本文 ~ 表示合并的意思）</strong></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:138px;">1~1 费用为1</td><td style="width:123px;"></td><td style="width:101px;"></td><td style="width:237px;"></td></tr><tr><td style="width:138px;">1~2 费用为2</td><td style="width:123px;">2~2 费用为4</td><td style="width:101px;"></td><td style="width:237px;"></td></tr><tr><td style="width:138px;">1~3 费用为0</td><td style="width:123px;">2~3 费用为0</td><td style="width:101px;">3~3费用为0</td><td style="width:237px;">（4等价为1，不需要继续枚举了）</td></tr><tr><td style="width:138px;">1~4（等价于1~1）</td><td style="width:123px;"></td><td style="width:101px;"></td><td style="width:237px;"></td></tr></tbody></table> 
<p>        整理上面表格得：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:139px;">1~1</td><td style="width:99px;">费用为1</td><td style="width:187px;">生成一个新堆，大小为2</td><td style="width:174px;">新堆等价大小为2</td></tr><tr><td style="width:139px;">1~2</td><td style="width:99px;">费用为2</td><td style="width:187px;">生成一个新堆，大小为3</td><td style="width:174px;">新堆等价大小为3</td></tr><tr><td style="width:139px;">2~2</td><td style="width:99px;">费用为4</td><td style="width:187px;">生成一个新堆，大小为4</td><td style="width:174px;">新堆等价大小为1</td></tr><tr><td style="width:139px;">3~x</td><td style="width:99px;">费用为0</td><td style="width:187px;">生成一个新堆，大小为3+x</td><td style="width:174px;">新堆等价大小为x</td></tr></tbody></table> 
<p>        因为我们要计算最后全部合并完的费用，如果剩下的堆的大小都等价为3，那么他们继续合并，就不会增加额外的费用，也就得到了最终答案。所以我们要以<strong>生成新堆的大小为3</strong>为短期目标，列表观察最小费用的合并方式。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:220px;">1~1等价大小为2，要再于1合并</td><td style="width:97px;">（1~1）~1</td><td style="width:114px;">费用为1+2=3</td><td style="width:168px;">生成一个新堆，大小为3</td></tr><tr><td style="width:220px;">1~2等价大小为3，无需继续合并</td><td style="width:97px;">  1~2</td><td style="width:114px;">费用为2</td><td style="width:168px;">生成一个新堆，大小为3</td></tr><tr><td style="width:220px;">2~2等价大小为1，要再与2合并</td><td style="width:97px;">（2~2）~2</td><td style="width:114px;">费用为4+2=6</td><td style="width:168px;">生成一个新堆，大小为3</td></tr><tr><td style="width:220px;">3~x等价大小为x</td><td style="width:97px;">  3~x</td><td style="width:114px;">费用为0</td><td style="width:168px;">生成一个新堆，大小为x</td></tr></tbody></table> 
<p>        于是发现，我们以<strong>多次合并生成等价大小为3的堆</strong>作为循环节，费用最小的合并方式是1~2。</p> 
<p></p> 
<p>由此得到贪心策略：</p> 
<p>        1、先把所有的1与2合并了先；</p> 
<p>        2、之后就只剩下两种情况，</p> 
<p>                ①d堆个数为1的堆和个数为3的堆。</p> 
<p>                ②d堆个数为2的堆和个数为3的堆。</p> 
<p>                那么就只能用（1~1）~1和（2~2）~2这两种策略分别处理；</p> 
<p>        3、处理后会分别得到三种情况（以剩下的堆是个数为1的 举例）：</p> 
<p>                ①d%3==0（即d==0），皆大欢喜，1与2合并后没有剩余。</p> 
<p>                ②d%3==1，也很欢喜，此时情况为：1个个数为1的堆，和很多个个数为3的堆</p> 
<p>                        用3~x的策略，也不会产生新的费用。</p> 
<p>                ③d%3==2，此时情况为：2个个数为1的堆，和很多个个数为3的堆</p> 
<p>                        这两个1合并会产生新的费用，要额外加上。</p> 
<p>        4、最后再用3~x的策略合并成1堆。这一步不会产生任何费用。这里的x可能为1，2，3。</p> 
<p></p> 
<p>样例图解：</p> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/b4/87/n6aGqqfK_o.png" width="300"></p> 
  </div> 
 </div> 
</div> 
<p> AC代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

signed main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    int ans = 0;
    if (a == b){
        ans = a * 2;
    }
    else if (a &gt; b){
        int d = a - b;//剩下d堆个数为1的堆和个数为3的堆
        if (d % 3 == 2)//1 1 3的情况
            ans++;
        ans += b * 2 + (d - d % 3);
    }
    else{  // a&lt;b
        int d = b - a;//剩下d堆个数为2的堆和个数为3的堆
        if (d % 3 == 2)//2 2 3的情况
            ans += 4;
        ans += a * 2 + (d - d % 3) * 2;
    }
    cout &lt;&lt; ans &lt;&lt; "\n";
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d98f26e2e6f0808ca79a48d9c37d8fe0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">几何平均详解，及其与算术平均、调和平均、均方根的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f79dbee542990cdb81d2bbeca3721e34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">coreutils 编译</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>