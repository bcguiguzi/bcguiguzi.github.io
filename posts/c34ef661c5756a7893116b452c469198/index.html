<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高并发网络通信架构】1.Linux下实现单客户连接的tcp服务端 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【高并发网络通信架构】1.Linux下实现单客户连接的tcp服务端" />
<meta property="og:description" content="目录
一，函数清单
1.socket 方法
2.bind 方法
3.listen 方法
4.accept 方法（阻塞函数）
5.recv 方法（阻塞函数）
6.send 方法
7.close 方法
8.htonl 方法
9.htons 方法
10.fcntl 方法
二，代码实现
1.阻塞型服务端
TCP服务端程序的一般流程
TCP客户端程序的一般流程
完整代码
2.非阻塞型服务端
非阻塞型TCP服务端的一般流程
完整代码
一，函数清单 1.socket 方法 #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 功能
创建用于通信的套接字，并返回一个指向该套接字的文件描述符。 参数
domain：指定套接字的协议族。常见的值有AF_INET（IPv4）和AF_INET6（IPv6）。type：指定套接字的类型。常见的值有SOCK_STREAM（面向连接的可靠字节流）和SOCK_DGRAM（无连接的数据报文）。protocol：指定协议。通常使用0，表示默认选择。 返回值
如果成功，则返回新套接字的文件描述符。如果出现错误，则返回-1，并设置errno。 2.bind 方法 #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 功能" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c34ef661c5756a7893116b452c469198/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-08T23:39:58+08:00" />
<meta property="article:modified_time" content="2023-07-08T23:39:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高并发网络通信架构】1.Linux下实现单客户连接的tcp服务端</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E5%87%BD%E6%95%B0%E6%B8%85%E5%8D%95-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E5%87%BD%E6%95%B0%E6%B8%85%E5%8D%95" rel="nofollow">一，函数清单</a></p> 
<p id="1.socket%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.socket%20%E6%96%B9%E6%B3%95" rel="nofollow">1.socket 方法</a></p> 
<p id="2.bind%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.bind%20%E6%96%B9%E6%B3%95" rel="nofollow">2.bind 方法</a></p> 
<p id="3.listen%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.listen%20%E6%96%B9%E6%B3%95" rel="nofollow">3.listen 方法</a></p> 
<p id="4.accept%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.accept%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">4.accept 方法（阻塞函数）</a></p> 
<p id="5.recv%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.recv%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">5.recv 方法（阻塞函数）</a></p> 
<p id="6.send%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.send%20%E6%96%B9%E6%B3%95" rel="nofollow">6.send 方法</a></p> 
<p id="7.close%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#7.close%20%E6%96%B9%E6%B3%95" rel="nofollow">7.close 方法</a></p> 
<p id="8.htonl%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.htonl%20%E6%96%B9%E6%B3%95" rel="nofollow">8.htonl 方法</a></p> 
<p id="9.htons%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#9.htons%20%E6%96%B9%E6%B3%95" rel="nofollow">9.htons 方法</a></p> 
<p id="10.fcntl%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#10.fcntl%20%E6%96%B9%E6%B3%95" rel="nofollow">10.fcntl 方法</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">二，代码实现</a></p> 
<p id="1.%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF-toc" style="margin-left:40px;"><a href="#1.%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF" rel="nofollow">1.阻塞型服务端</a></p> 
<p id="TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B" rel="nofollow">TCP服务端程序的一般流程</a></p> 
<p id="TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B" rel="nofollow">TCP客户端程序的一般流程</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<p id="2.%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF-toc" style="margin-left:40px;"><a href="#2.%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF" rel="nofollow">2.非阻塞型服务端</a></p> 
<p id="%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8BTCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8BTCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B" rel="nofollow">非阻塞型TCP服务端的一般流程</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E5%87%BD%E6%95%B0%E6%B8%85%E5%8D%95">一，函数清单</h2> 
<h3 id="1.socket%20%E6%96%B9%E6%B3%95">1.socket 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>创建用于通信的套接字，并返回一个指向该套接字的文件描述符。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>domain：指定套接字的协议族。常见的值有AF_INET（IPv4）和AF_INET6（IPv6）。</li><li>type：指定套接字的类型。常见的值有SOCK_STREAM（面向连接的可靠字节流）和SOCK_DGRAM（无连接的数据报文）。</li><li>protocol：指定协议。通常使用0，表示默认选择。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>如果成功，则返回新套接字的文件描述符。如果出现错误，则返回-1，并设置errno。</li></ul> 
</blockquote> 
<h3 id="2.bind%20%E6%96%B9%E6%B3%95">2.bind 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>将套接字与特定的IP地址和端口绑定。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>sockfd：socket返回的套接字描述符。</li><li>addr：指向要绑定的本地地址的结构体（通常是一个sockaddr_in或sockaddr_in6结构体）。</li><li>addrlen：本地地址的长度（通常是sizeof(struct sockaddr_in)或sizeof(struct sockaddr_in6)）。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>如果成功，则返回0。如果出现错误，则返回-1，并设置errno。</li></ul> 
</blockquote> 
<h3 id="3.listen%20%E6%96%B9%E6%B3%95">3.listen 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>开始监听指定套接字上的连接请求。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>sockfd：socket返回的套接字描述符。</li><li>backlog：等待连接队列的最大长度。如果连接请求到达时如果队列已满，则客户端可能会收到ECONNREFUSED指示的错误，如果底层协议支持重传，则请求可能已满忽略，以便稍后重试连接成功。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>如果成功，则返回0。如果出现错误，则返回-1，并设置errno。</li></ul> 
</blockquote> 
<h3 id="4.accept%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89">4.accept 方法（阻塞函数）</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>接受一个连接请求，返回一个新的套接字描述符与客户端通信。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>sockfd：socket返回的套接字描述符。</li><li>addr：指向用于存放客户端地址的结构体的指针。通常指定为 struct  sockaddr_in 结构体。</li><li>addrlen：用于传递addr结构体的长度。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>如果成功，这些系统调用将返回被接受套接字的文件描述符(一个非负整数)。如果出现错误，则返回-1，适设置errno，并且保持addrlen不变。</li></ul> 
</blockquote> 
<h3 id="5.recv%20%E6%96%B9%E6%B3%95%EF%BC%88%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0%EF%BC%89">5.recv 方法（阻塞函数）</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>从已连接的套接字接收数据。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>sockfd：accept返回的套接字描述符。</li><li>buf：接收数据的缓冲区。</li><li>len：缓冲区的长度。</li><li>flags：接收操作的标志，一般设置为0。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>返回接收到的字节数，如果发生错误则返回-1。如果发生错误，则设置errno来指示错误。当客户端连接关闭时，返回值将为0。</li></ul> 
</blockquote> 
<h3 id="6.send%20%E6%96%B9%E6%B3%95">6.send 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>向已连接的套接字发送数据。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>sockfd：accept返回的套接字描述符。</li><li>buf：包含要发送数据的缓冲区。</li><li>len：要发送的数据长度。</li><li>flags：发送操作的标志，一般设置为0。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>如果成功，这些调用将返回发送的字节数。如果出现错误，则返回-1，并设置errno。</li></ul> 
</blockquote> 
<h3 id="7.close%20%E6%96%B9%E6%B3%95">7.close 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;unistd.h&gt;

int close(int fd);
</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>关闭文件描述符，释放相关资源</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>fd：要关闭的文件描述符。</li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>成功返回零。如果出现错误，则返回-1，并设置errno。</li></ul> 
</blockquote> 
<h3 id="8.htonl%20%E6%96%B9%E6%B3%95">8.htonl 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;

uint32_t htonl(uint32_t hostlong);
</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>将一个32位（4字节）的主机字节序的无符号整数转换为网络字节序的整数。</li></ul> 
</blockquote> 
<h3 id="9.htons%20%E6%96%B9%E6%B3%95">9.htons 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;

uint16_t htons(uint16_t hostshort);</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>将一个16位（2字节）的主机字节序的符号短整数转换为网络字节序的整数。</li></ul> 
</blockquote> 
<h3 id="10.fcntl%20%E6%96%B9%E6%B3%95">10.fcntl 方法</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd, ... /* arg */ );
</code></pre> 
 <p><span style="color:#ff9900;">功能</span></p> 
 <ul><li>操作文件描述符的行为和属性，可设置成非阻塞IO。</li></ul> 
 <p><span style="color:#ffd900;">参数</span></p> 
 <ol><li>fd：要设置的文件描述符。</li><li>cmd：对fd要执行操作的命令，常见命令如下，通常使用F_GETFL，F_SETFL。 
   <ol><li><code>F_DUPFD</code>：复制文件描述符。</li><li><code>F_GETFD</code>：获取文件描述符标志。</li><li><code>F_SETFD</code>：设置文件描述符标志。</li><li><code>F_GETFL</code>：获取文件状态标志。</li><li><code>F_SETFL</code>：设置文件状态标志。</li><li><code>F_GETLK</code>：获取文件锁。</li><li><code>F_SETLK</code>：设置文件锁。</li><li><code>F_SETLKW</code>：设置文件锁，如果锁不可用则等待。</li></ol></li></ol> 
 <p><span style="color:#a2e043;">返回值</span></p> 
 <ul><li>对于成功的调用，返回值取决于操作命令，如果出现错误，则返回-1，并适当地设置errno。</li></ul> 
</blockquote> 
<h2 id="%E4%BA%8C%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">二，代码实现</h2> 
<h3 id="1.%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF">1.阻塞型服务端</h3> 
<blockquote> 
 <h4 id="TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><strong>TCP服务端程序的一般流程</strong></h4> 
 <ol><li> <p>创建套接字（Socket）：使用<code>socket</code>系统调用创建一个TCP套接字。套接字是网络通信的端点。</p> </li><li> <p>绑定地址和端口（Bind）：将服务器的IP地址和端口号与套接字绑定，使用<code>bind</code>系统调用来完成绑定操作。</p> </li><li> <p>监听连接请求（Listen）：将套接字置于监听状态，等待客户端的连接请求。使用<code>listen</code>系统调用设置套接字的监听队列长度。</p> </li><li> <p>接受连接请求（Accept）：当有客户端请求连接时，使用<code>accept</code>系统调用接受连接请求。这将创建一个新的套接字，用于和客户端进行通信，而原始的监听套接字继续监听新的连接请求。</p> </li><li> <p>进行通信（Communicate）：使用接受到的套接字进行数据通信。可以使用<code>read/recv</code>和<code>write/send</code>系统调用或其它高级的I/O函数来收发数据。</p> </li><li> <p>关闭套接字（Close）：当通信结束后，使用<code>close</code>系统调用关闭套接字，释放相关资源。</p> </li></ol> 
 <p><strong>示例代码</strong></p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main() {
    // 创建套接字
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);

    // 绑定地址和端口
    struct sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;    //ipv4
    serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddress.sin_port = htons(8888);
    bind(serverSocket, (struct sockaddr *)&amp;serverAddress, sizeof(serverAddress));

    // 监听连接请求
    listen(serverSocket, 5);

    // 接受连接请求
    int clientSocket = accept(serverSocket, NULL, NULL);

    // 进行通信
    char buffer[1024];
    read(clientSocket, buffer, sizeof(buffer));
    printf("Received message: %s\n", buffer);

    // 关闭套接字
    close(clientSocket);
    close(serverSocket);

    return 0;
}
</code></pre> 
 <hr> 
 <h4 id="TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><strong>TCP客户端程序的一般流程</strong></h4> 
 <ol><li> <p>创建套接字（Socket）：使用<code>socket</code>系统调用创建一个TCP套接字。</p> </li><li> <p>设置服务器地址和端口号：使用<code>struct sockaddr_in</code>结构体来表示服务器的地址和端口号。根据服务器的IP地址和端口号来填充该结构体。</p> </li><li> <p>连接服务器（Connect）：使用<code>connect</code>系统调用将套接字连接到服务器。将服务器的地址和端口号作为参数传递给<code>connect</code>函数。</p> </li><li> <p>进行数据通信（Communicate）：使用已连接的套接字进行数据的读取和写入。可以使用<code>read</code>和<code>write</code>系统调用读取和发送数据。</p> </li><li> <p>关闭套接字（Close）：当通信完成后，使用<code>close</code>系统调用关闭套接字，释放相关资源。</p> </li></ol> 
 <p><strong>示例代码</strong></p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main() {
    // 创建套接字
    int clientSocket = socket(AF_INET, SOCK_STREAM, 0);

    // 设置服务器地址和端口号
    struct sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(8888);
    serverAddress.sin_addr.s_addr = inet_addr("服务器IP地址");

    // 连接服务器
    connect(clientSocket, (struct sockaddr *)&amp;serverAddress, sizeof(serverAddress));

    // 进行数据通信
    char *message = "Hello, server!";
    send(clientSocket, message, strlen(message),0);

    // 关闭套接字
    close(clientSocket);

    return 0;
}
</code></pre> 
</blockquote> 
<blockquote> 
 <h4 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><strong>完整代码</strong></h4> 
 <ul><li>accept和recv都是阻塞型的函数，在accept上是阻塞客户端的连接，在recv上是阻塞读取已连接客户端的数据。</li><li>为实现连续和客户端进行通信，必须将recv放在一个master循环里，用于一直读取客户端发来的数据。</li></ul> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;


#define BUFFER_LENGTH   1024

//初始化服务端，返回其文件描述符
int init_server(int port){
    //返回服务端fd,通常为3,前面0,1,2用于表示标准输入,输出,错误值
    int sfd = socket(AF_INET,SOCK_STREAM,0);

    if(-1 == sfd){
        printf("socket error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    struct sockaddr_in servAddr;
    memset(&amp;servAddr,0,sizeof(struct sockaddr_in));
    servAddr.sin_family = AF_INET;  //ipv4
    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);   //0.0.0.0
    servAddr.sin_port = htons(port);    //端口号
    
    //绑定IP和端口号
    if(-1 == bind(sfd,(struct sockaddr*)&amp;servAddr,sizeof(struct sockaddr_in)))
    {
        printf("bind error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    //监听该套接字上的连接
    if(-1 == listen(sfd,SOMAXCONN))
    {
        printf("listen error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    return sfd;
}

int main(int argc,char *argv[]){

    if(argc &lt; 2)return -1;

    int port = atoi(argv[1]);   //atoi：将字符串转换为整数
    int sfd = init_server(port);
    printf("server fd: %d\n",sfd);

    struct sockaddr_in clientAddr;
    socklen_t len = sizeof(struct sockaddr_in);
    int cfd = accept(sfd,(struct sockaddr*)&amp;clientAddr,&amp;len);   //阻塞函数
    printf("client fd: %d\n",cfd);
    while (1)
    {
        char data[BUFFER_LENGTH]={0};
        int recvLen = recv(cfd,data,BUFFER_LENGTH,0);    //阻塞函数
        if(recvLen &lt; 0){
            printf("recv client fd %d errno: %d\n",cfd,errno);
        }else if(recvLen == 0){
            printf("client fd %d close\n",cfd);
            close(cfd);     //关闭客户端文件描述符，释放资源
            break;
        }else{
            printf("recv client fd %d data: %s\n",cfd,data);
            send(cfd,data,recvLen,0);
        }
    }

    close(sfd);     //关闭服务端文件描述符，释放资源
    printf("server fd %d close\n",sfd);
    
    return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>运行效果</strong></p> 
 <ul><li>测试工具：<a class="link-info" href="http://free.cmsoft.cn/download/cmsoft/assistant/netassist5.0.2.zip" rel="nofollow" title="NetAssist">NetAssist</a> 模拟客户端工具，测试服务端代码。<img alt="" src="https://images2.imgbox.com/9e/0d/pLoB6IVi_o.png"></li></ul> 
</blockquote> 
<h3 id="2.%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF">2.非阻塞型服务端</h3> 
<blockquote> 
 <h4 id="%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8BTCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><strong>非阻塞型TCP服务端的一般流程</strong></h4> 
 <ol><li> <p>创建套接字（Socket）：使用<code>socket</code>系统调用创建一个TCP套接字。</p> </li><li> <p>设置套接字为非阻塞模式：使用<code>fcntl</code>函数，通过<code>F_SETFL</code>命令将套接字的文件状态标志设置为非阻塞模式，即使用<code>O_NONBLOCK</code>标志。</p> </li><li> <p>绑定地址和端口（Bind）：将服务器的IP地址和端口号与套接字绑定，使用<code>bind</code>系统调用来完成绑定操作。</p> </li><li> <p>监听连接请求（Listen）：将套接字置于监听状态，等待客户端的连接请求，使用<code>listen</code>系统调用设置套接字的监听队列长度。</p> </li><li> <p>接受连接请求（Accept）：使用<code>accept</code>系统调用接受连接请求。这将创建一个新的套接字，用于和客户端进行通信，而原始的监听套接字继续监听新的连接请求。</p> </li><li> <p>设置新的套接字为非阻塞模式：同样，使用<code>fcntl</code>函数设置新的套接字为非阻塞模式。</p> </li><li> <p>进行数据通信（Communicate）：使用非阻塞的套接字进行数据的读取和写入。可以使用<code>read/recv</code>和<code>write/send</code>系统调用或其他非阻塞的I/O函数进行数据交换。</p> </li><li> <p>关闭套接字（Close）：当通信结束后，使用<code>close</code>系统调用关闭套接字，释放相关资源。</p> </li></ol> 
 <p><strong>示例代码</strong></p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    // 创建套接字
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);

    // 设置套接字为非阻塞模式
    int flags = fcntl(serverSocket, F_GETFL, 0);
    fcntl(serverSocket, F_SETFL, flags | O_NONBLOCK);

    // 绑定地址和端口
    struct sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddress.sin_port = htons(8888);
    bind(serverSocket, (struct sockaddr *)&amp;serverAddress, sizeof(serverAddress));

    // 监听连接请求
    listen(serverSocket, 5);

    while (1) {
        // 接受连接请求
        struct sockaddr_in clientAddress;
        socklen_t clientAddressLength = sizeof(clientAddress);
        int clientSocket = accept(serverSocket, (struct sockaddr *)&amp;clientAddress, &amp;clientAddressLength);

        if (clientSocket &gt; 0) {
            // 设置新的套接字为非阻塞模式
            flags = fcntl(clientSocket, F_GETFL, 0);
            fcntl(clientSocket, F_SETFL, flags | O_NONBLOCK);

            // 进行数据通信
            char buffer[1024];
            ssize_t bytesRead = read(clientSocket, buffer, sizeof(buffer));
            if (bytesRead &gt; 0) {
                // 读取到数据
                printf("Received message from client: %s\n", buffer);
            }

            // 关闭客户端套接字
            close(clientSocket);
        }
    }

    // 关闭服务端套接字
    close(serverSocket);

    return 0;
}
</code></pre> 
</blockquote> 
<blockquote> 
 <h4><strong>完整代码</strong></h4> 
 <ul><li>设置套接字为非阻塞模式。<img alt="" src="https://images2.imgbox.com/e3/f1/VpaEDRrR_o.png"></li><li>以下是用于测试上面这一段代码是否将服务端设置成非阻塞型。</li></ul> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#include &lt;fcntl.h&gt;


#define BUFFER_LENGTH   1024

int init_server(int port){
    //获取服务端fd,通常为3,前面0,1,2用于指定输入,输出,错误值
    int sfd = socket(AF_INET,SOCK_STREAM,0);

    if(-1 == sfd){
        printf("socket error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    //设置服务端套接字为非阻塞模式
    int flags = fcntl(sfd,F_GETFL,0);
    fcntl(sfd,F_SETFL,flags | O_NONBLOCK);

    struct sockaddr_in servAddr;
    memset(&amp;servAddr,0,sizeof(struct sockaddr_in));
    servAddr.sin_family = AF_INET;  //ipv4
    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);   //0.0.0.0
    servAddr.sin_port = htons(port);
    //服务端绑定ip地址和端口号
    if(-1 == bind(sfd,(struct sockaddr*)&amp;servAddr,sizeof(struct sockaddr_in)))
    {
        printf("bind error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    //监听该套接字上的连接请求
    if(-1 == listen(sfd,SOMAXCONN))
    {
        printf("listen error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }

    return sfd;
}

int main(int argc,char *argv[]){

    if(argc &lt; 2)return -1;

    int port = atoi(argv[1]);
    int sfd = init_server(port);
    printf("server fd: %d\n",sfd);

    //接受连接请求
    struct sockaddr_in clientAddr;
    socklen_t len = sizeof(struct sockaddr_in);
    int cfd = accept(sfd,(struct sockaddr*)&amp;clientAddr,&amp;len);
    if(cfd == -1){
        printf("accept error code: %d codeInfo: %s\n",errno,strerror(errno));
        return -1;
    }
    printf("client fd: %d\n",cfd);
    //设置新的套接字为非阻塞模式
    int flags = fcntl(cfd,F_GETFL,0);
    fcntl(cfd,F_SETFL,flags | O_NONBLOCK);

    while (1)
    {
        char data[BUFFER_LENGTH]={0};
        int recvLen = recv(cfd,data,BUFFER_LENGTH,0);
        if(recvLen &lt; 0){
            printf("recv client fd %d errno: %d\n",cfd,errno);
        }else if(recvLen == 0){
            //客户端断开连接
            printf("client fd %d close\n",cfd);
            close(cfd);     //关闭客户端文件描述符，释放资源
            break;
        }else{
            printf("recv client fd %d data: %s\n",cfd,data);
            send(cfd,data,recvLen,0);
        }
    }

    close(sfd);     //关闭服务端文件描述符，释放资源
    printf("server fd %d close\n",sfd);
    
    return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>运行</strong><strong>效果</strong></p> 
 <ul><li>编译成功并运行后，报了如下错误，导致服务端不能正常运行。<img alt="" src="https://images2.imgbox.com/9b/4e/MRPxunlV_o.png"></li></ul> 
 <hr> 
 <p><strong>问题分析</strong></p> 
 <ul><li>错误码"Resource temporarily unavailable"（资源暂时不可用）在Linux中对应的错误码为EAGAIN（错误值11）或EWOULDBLOCK。这个错误码通常在非阻塞I/O操作中出现，表示当前没有可用的资源或操作正在进行中。</li><li>在网络编程中，当使用非阻塞模式的套接字进行读取或写入操作时，如果没有可用的数据或无法立即完成写入操作，就可能会返回这个错误码。这是因为非阻塞模式下的I/O操作是非阻塞的，即它们要么立即完成，要么返回错误码而不等待。</li></ul> 
 <p><strong>解决方法</strong></p> 
 <ul><li> <p>异步I/O（Asynchronous I/O）：通过使用异步I/O操作，可以在所有I/O操作之后返回，而不会阻塞当前线程。Linux提供了aio_read和aio_write等异步I/O函数。使用异步I/O操作，你可以注册回调函数，在操作完成时接收通知。</p> </li></ul> 
 <p>后续学习再来处理。。。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2a7f5a49bc262973ea1e5f0e716bce9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Debian 11 x64 安装 MySQL 8.0.33</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db1c2106e49cfab831fbfd7e70190182/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于C&#43;&#43;版本z3库的使用心得</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>