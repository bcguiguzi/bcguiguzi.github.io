<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cJSON函数用法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cJSON函数用法" />
<meta property="og:description" content="/* 以字符串形式返回cJSON的版本 /
CJSON_PUBLIC(const char) cJSON_Version(void);/* 向cJSON提供malloc, realloc和free函数 /
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks hooks);/* 提供一个JSON块，这将返回一个您可以查询的cJSON对象。*/
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value,
size_t buffer_length); cJSON_Print()函数 和 CJSON_Parse()函数的作用：
前者是 JSON 的数据格式转换为 JSON 字符串，用于 JSON 组装，
后者是 JSON 字符串转换为 JSON 的数据格式，用于 JSON 解析
/* 内存管理:调用者总是负责从所有变量的cJSON_Parse(使用cJSON_Delete)和
cJSON_Print(使用stdlib freallocated)中释放结果，调用者对缓冲区有完全的责任。*/
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
/* 将cJSON实体呈现为用于传输/存储的文本。 */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
/* 将cJSON实体呈现为文本，用于传输/存储，不需要任何格式化。*/
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
/* 使用缓冲策略将cJSON实体渲染为文本。预缓冲是对最终大小的猜测。
猜中会减少再分配。Fmt =0表示未格式化，=1表示已格式化 */
CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0f1fb19643d9860704ac8dbbd0d276e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T19:10:01+08:00" />
<meta property="article:modified_time" content="2022-12-02T19:10:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cJSON函数用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>/* 以字符串形式返回cJSON的版本 <em>/<br> CJSON_PUBLIC(const char</em>) cJSON_Version(void);</li><li>/* 向cJSON提供malloc, realloc和free函数 <em>/<br> CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks</em> hooks);</li><li>/* 提供一个JSON块，这将返回一个您可以查询的cJSON对象。*/<br> CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value,<br> size_t buffer_length);</li></ol> 
<p><em><strong>cJSON_Print()函数 和 CJSON_Parse()函数的作用：<br> 前者是 JSON 的数据格式转换为 JSON 字符串，用于 JSON 组装，<br> 后者是 JSON 字符串转换为 JSON 的数据格式，用于 JSON 解析</strong></em></p> 
<ol start="4"><li> <p>/* 内存管理:调用者总是负责从所有变量的cJSON_Parse(使用cJSON_Delete)和<br> cJSON_Print(使用stdlib freallocated)中释放结果，调用者对缓冲区有完全的责任。*/<br> CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);</p> </li><li> <p>/* 将cJSON实体呈现为用于传输/存储的文本。 */<br> CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);</p> </li><li> <p>/* 将cJSON实体呈现为文本，用于传输/存储，不需要任何格式化。*/<br> CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);</p> </li><li> <p>/* 使用缓冲策略将cJSON实体渲染为文本。预缓冲是对最终大小的猜测。<br> 猜中会减少再分配。Fmt =0表示未格式化，=1表示已格式化 */<br> CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item,<br> int prebuffer,<br> cJSON_bool fmt);</p> </li><li> <p>/* 使用内存中已分配的具有给定长度的缓冲区将cJSON实体渲染为文本。<br> 成功时返回1，失败时返回0。<em>/<br> /</em> 注意:cJSON在估计它将使用多少内存时并不总是100%准确，<br> 所以为了安全，要比实际需要多分配5个字节 */<br> CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item,<br> char *buffer,<br> const int length,<br> const cJSON_bool format);</p> </li><li> <p>/* 删除一个cJSON实体和所有子实体。 */<br> CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);</p> </li><li> <p>/* 返回数组(或对象)中的项数。*/<br> CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);</p> </li><li> <p>/* 从数组"array"中检索项目号"index"。如果不成功，返回NULL。*/<br> CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);</p> </li><li> <p>/* 检查项目类型并返回其值 */<br> CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);<br> CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);</p> </li><li> <p>/* 这些函数检查项的类型 */<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);</p> </li><li> <p>/* 这些调用创建适当类型的cJSON项 */<br> CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char <em>raw); /</em> raw json */<br> CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);</p> </li><li> <p>/* 在valuestring引用字符串的地方创建一个字符串，这样它就不会被cJSON_Delete释放 */<br> CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);</p> </li><li> <p>/* 创建一个对象/数组，只引用它的元素，这样它们就不会被cJSON_Delete释放 */<br> CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);</p> </li><li> <p>/* 这些实用程序创建计数项的数组。参数计数不能大于数字数组中的元素数量，否则数组访问将超出限制。 */<br> CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);<br> CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);</p> </li><li> <p>/* 将项附加到指定的数组/对象。 */<br> CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);<br> CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object,<br> const char *string,<br> cJSON *item);</p> </li><li> <p>/* 从数组/对象中删除/分离项。 */<br> CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item); //via:通过<br> CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);<br> CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);<br> CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);<br> CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);<br> CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);<br> CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);</p> </li><li> <p>/* 更新数组项。 */<br> CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON <em>newitem); /</em> Shifts pre-existing items to the right. */<br> CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);<br> CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);<br> CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);<br> CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);</p> </li><li> <p>/* 复制一个cJSON项 */<br> CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);</p> </li><li> <p>/* 缩小字符串，从字符串中删除空白字符(如’ ‘，’\t’， ‘\r’， ‘\n’)。输入指针json不能指向只读地址区，比如字符串常量，但应该指向可读可写的地址区 */<br> CJSON_PUBLIC(void) cJSON_Minify(char *json);</p> </li><li> <p>/* 同时向对象中创建和添加项的帮助函数。成功时返回添加的项，失败时返回NULL <em>/<br> CJSON_PUBLIC(cJSON</em>) cJSON_AddNullToObject(cJSON * const object, const char * const name);<br> CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);<br> CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);<br> CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);<br> CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);<br> CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);<br> CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);<br> CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);<br> CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);</p> </li><li> <p>编译命令<br> gcc *.c cJSON.c -lm</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/611e1049a4a33f6a5f28a3731059cbb2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WSDM&#39;23 | 基于实体对齐的文图检索优化算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3714adbc26b11309578daff88a84bdfb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">compression-webpack-plugin压缩前端代码&amp;服务器nginx代理相关配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>