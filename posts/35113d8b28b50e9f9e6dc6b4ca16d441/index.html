<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>质因子的分解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="质因子的分解" />
<meta property="og:description" content="1：所谓的质因子分解是指将一个正整数n写成一个或多个质数的乘积的形式，例如：6=2*3,8=2*2*2.或者将其写为指数形式，如：6=2^1*3^1,180=
2^2 * 3^2 * 5^1;由于最后要归结到若干不同指数的乘积，因此需要先将素数表打印出来。
注意：1本身不是素数，因此他没有质因子，一般就是讨论大于1 的数。如果有的题目需要对1进行讨论，那么就要视为特判。
由于每个质因子都可以不只出现一次，因此不妨定义结构体factor，用来存放质因子及其个数。
struct factor{
int x,cnt;//x为质因子，cnt为质因子的个数 }fac[10];
这里的质因子存放到fac[]数组里。如：180来说；
fac[0].x = 2;
fac[0].cnt = 2;
fac[1].x = 3;
fac[1].cnt = 2;
fac[2].x = 5;
fac[2].cnt = 1; fac[10]开到10的原因是：2*3*5*7*11*13*17*19*23*29就已经超出了int范围所以就只用到开到10；
对一个正整数n来说，如果他存在1和本身之外的因子，那么一定是在sqrt（n）左右成对出现。而这里也可以用在“质因子”上面，会得到一个强化结论：对一个正整数n来说，如果它存在【2，n】范围的质因子，要么这些质因子全部小于等于sqrt（n），要么这些质因子只存在一个大于sqrt（n）的质因子，而其余质因子全部小于等于sqrt（n）。这就有了一个思路：
1：枚举1~sqrt（n）范围内的所有质因子p，判断p是否是n的因子。
如果p是n的因子，那么给fac数组中增加质因子p，并初始化为0.然后只要p还是n的因子，就让n不断的除以p，每次操作使p的个数加1，直到p不是n的因子为止。
if(n % prime[i] == 0){
fac[num].x = prime[i];
fac[num].cnt = 0;
while(n % prime[i] == 0){
fac[num].cnt &#43;&#43;;
n /= prime[i];
}
num&#43;&#43;;
}
如果p不是n的因子，就直接跳过。
2：如果上面的步骤结束后n仍然大于1，说明有且仅有一个大于sqrt（n）的质因子（有可能是n本身），这时需要把这个质因子加入fac数组中，并令其个数等于1.
if(n!=1){//如果无法被根号n以内的质因子除尽 fac[num].x = n;
fac[num&#43;&#43;].cnt = 1; }" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/35113d8b28b50e9f9e6dc6b4ca16d441/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-29T15:25:05+08:00" />
<meta property="article:modified_time" content="2017-10-29T15:25:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">质因子的分解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1：所谓的质因子分解是指将一个正整数n写成一个或多个质数的乘积的形式，例如：6=2*3,8=2*2*2.或者将其写为指数形式，如：6=2^1*3^1,180=</p> 
<p>2^2  * 3^2 * 5^1;由于最后要归结到若干不同指数的乘积，因此需要先将素数表打印出来。</p> 
<p>注意：1本身不是素数，因此他没有质因子，一般就是讨论大于1 的数。如果有的题目需要对1进行讨论，那么就要视为特判。</p> 
<p>由于每个质因子都可以不只出现一次，因此不妨定义结构体factor，用来存放质因子及其个数。</p> 
<p><span style="font-size:24px">struct factor{<!-- --><br> <span style="white-space:pre"></span>int x,cnt;//x为质因子，cnt为质因子的个数 <br> }fac[10];<br> 这里的质因子存放到fac[]数组里。如：180来说；<br> fac[0].x = 2;<br> fac[0].cnt  = 2;<br> fac[1].x = 3;<br> fac[1].cnt = 2;<br> fac[2].x = 5;<br> fac[2].cnt = 1; </span></p> 
<p><span style="font-size:24px"><span style="white-space:pre"></span>fac[10]开到10的原因是：2*3*5*7*11*13*17*19*23*29就已经超出了int范围所以就只用到开到10；</span></p> 
<p><span style="font-size:24px"><span style="white-space:pre"></span>对一个正整数n来说，如果他存在1和本身之外的因子，那么一定是在sqrt（n）左右成对出现。而这里也可以用在“质因子”上面，会得到一个强化结论：对一个正整数n来说，如果它存在【2，n】范围的质因子，要么这些质因子全部小于等于sqrt（n），<span style="font-size:24px">要么这些质因子<span style="color:#ff0000; font-style:italic; font-weight:bold">只存在</span><span style="color:#333333"><strong>一个大于sqrt（n）的质因子，而其余质因子全部小于等于sqrt（n）。这就有了一个思路：</strong></span></span></span></p> 
<p><span style="font-size:24px"><span style="font-size:24px"><span style="color:#333333"><strong>1：枚举1~sqrt（n）范围内的所有质因子p，判断p是否是n的因子。</strong></span></span></span></p> 
<p><span style="font-size:24px"><span style="font-size:24px"><span style="color:#333333"><strong><span style="white-space:pre"></span>如果p是n的因子，那么给fac数组中增加质因子p，并初始化为0.然后只要p还是n的因子，就让n不断的除以p，每次操作使p的个数加1，直到p不是n的因子为止。</strong></span></span></span></p> 
<p><span style="font-size:24px"><strong><span style="color:#333333; font-size:24px">if(n % prime[i] == 0){<!-- --></span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">fac[num].x = prime[i];</span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">fac[num].cnt = 0;</span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">while(n % prime[i] == 0){<!-- --></span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">fac[num].cnt ++;</span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">n /= prime[i];</span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">}</span><br> <span style="font-size:24px; color:rgb(51,51,51); white-space:pre"></span><span style="color:#333333; font-size:24px">num++;</span><br> <span style="color:#333333; font-size:24px">}</span><em><span style="color:#c0c0c0"><br> </span></em></strong></span></p> 
<p><span style="font-size:24px"><span style="font-style:italic; font-weight:bold; color:rgb(192,192,192); white-space:pre"></span><strong><span style="font-family:KaiTi_GB2312; background-color:rgb(255,255,255)">如果p不是n的因子，就直接跳过。</span></strong></span></p> 
<p><br> </p> 
<p><span style="font-size:24px">2：如果上面的步骤结束后n仍然大于1，说明有且仅有一个大于sqrt（n）的质因子（有可能是n本身），这时需要把这个质因子加入fac数组中，并令其个数等于1.</span></p> 
<p><span style="font-size:24px">if(n!=1){//如果无法被根号n以内的质因子除尽 <br> <span style="white-space:pre"></span>fac[num].x = n;<br> <span style="white-space:pre"></span>fac[num++].cnt = 1; <br> }<br> </span></p> 
<p><span style="font-size:24px">至此，fac数组中存放的就是质因子分解的结果，时间复杂度就是O(sqrt(n))。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c84d27faa9bbf782355c9408b3def9f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UDP广播遇到的坑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c19c5d0adad651462a155f74b4eb3f59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">int *a[n]和int (*b)[n]的区别（易混淆）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>