<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【论文阅读|基于 YOLO 的红外小目标检测的逆向范例】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【论文阅读|基于 YOLO 的红外小目标检测的逆向范例】" />
<meta property="og:description" content="基于 YOLO 的红外小目标检测的逆向范例 摘要1 引言2 相关工作2.1 逆向推理2.2 物体检测方法 3 方法3.1 总体架构3.2 逆向标准的可微分积分 4 实验4.1 数据集和指标4.2 实验环境4.4 OL-NFA 为少样本环境带来稳健性 5 结论 论文题目： A Contrario Paradigm for YOLO-based Infrared Small Target Detection（基于 YOLO 的红外小目标检测的逆向范例） 论文下载链接： https://arxiv.org/pdf/2402.02288.pdf
摘要 检测红外图像中的微小目标是计算机视觉领域的一项具有挑战性的任务，尤其是在将这些目标从嘈杂或纹理背景中区分出来时。与分割神经网络相比，传统的物体检测方法（如 YOLO）在检测微小物体时非常吃力，因此在检测小目标时性能较弱。为了在保持高检测率的同时减少误报，在 YOLO 检测器的训练中引入了反向决策标准。后者利用小目标的不可预测性，将它们与复杂背景区分开来。在 YOLOv7-tiny 中加入这一统计标准，缩小了红外小目标检测和物体检测网络中最先进的分割方法之间的性能差距。它还大大提高了 YOLO 对少样本环境的鲁棒性。
关键词： 小目标检测、逆向推理、YOLO、少样本检测
1 引言 在包括医疗或安全领域在内的各种应用中，准确检测红外（infrared, IR）图像中的小目标至关重要。红外小目标检测（Infrared small target detection, IRSTD）是计算机视觉领域的一项巨大挑战，其困难主要在于：(1) 目标的大小（面积低于 20 像素）；(2) 复杂且纹理丰富的背景，从而导致许多误报；(3) 学习条件，即从小型、多样化程度低且高度类不平衡的数据集中学习，因为与背景类像素相比，目标类像素的数量非常少。过去几十年来，深度学习方法的兴起在物体检测领域取得了令人瞩目的进步，这主要归功于它们能够从大量标注数据中学习，提取出非常适合最终任务的非线性特征。在 IRSTD 中，语义分割神经网络的应用最为广泛[1]。其中包括 ACM[2]、LSPM[3]和最近最先进的（SOTA）方法之一，即 DNANet[4]，它由多个嵌套的 UNets 和一个多尺度融合模块组成，能够分割不同大小的小物体。然而，依靠分割神经网络进行物体检测的一个主要问题是，在调整用于二值化分割图的阈值时，可能会出现物体破碎的情况。这会导致许多不希望出现的误报，并扭曲计数指标。Faster-RCNN [5] 或 YOLO [6] 等物体检测算法通过边界框回归明确定位物体，从而降低了这种风险。然而，这些算法往往难以检测到微小物体。很少有研究关注将此类检测器用于 IRSTD [7]，也没有与 SOTA IRSTD 方法进行严格比较。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/fc2dd6597ff0febd9195f3cf706a6b53/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-20T17:30:08+08:00" />
<meta property="article:modified_time" content="2024-02-20T17:30:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【论文阅读|基于 YOLO 的红外小目标检测的逆向范例】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/90/b7/i6SSWyo7_o.png" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>基于 YOLO 的红外小目标检测的逆向范例</h4> 
 <ul><li><a href="#_8" rel="nofollow">摘要</a></li><li><a href="#1__14" rel="nofollow">1 引言</a></li><li><a href="#2__26" rel="nofollow">2 相关工作</a></li><li><ul><li><a href="#21__28" rel="nofollow">2.1 逆向推理</a></li><li><a href="#22__36" rel="nofollow">2.2 物体检测方法</a></li></ul> 
  </li><li><a href="#3__40" rel="nofollow">3 方法</a></li><li><ul><li><a href="#31__42" rel="nofollow">3.1 总体架构</a></li><li><a href="#32__51" rel="nofollow">3.2 逆向标准的可微分积分</a></li></ul> 
  </li><li><a href="#4__59" rel="nofollow">4 实验</a></li><li><ul><li><a href="#41__61" rel="nofollow">4.1 数据集和指标</a></li><li><a href="#42__68" rel="nofollow">4.2 实验环境</a></li><li><a href="#44_OLNFA__76" rel="nofollow">4.4 OL-NFA 为少样本环境带来稳健性</a></li></ul> 
  </li><li><a href="#5__82" rel="nofollow">5 结论</a></li></ul> 
</div> 
<br> 
<strong>论文题目：</strong> A Contrario Paradigm for YOLO-based Infrared Small Target Detection（基于 YOLO 的红外小目标检测的逆向范例） 
<p></p> 
<p><strong>论文下载链接：</strong> <a href="https://arxiv.org/pdf/2402.02288.pdf" rel="nofollow">https://arxiv.org/pdf/2402.02288.pdf</a></p> 
<h2><a id="_8"></a>摘要</h2> 
<p>检测红外图像中的微小目标是计算机视觉领域的一项具有挑战性的任务，尤其是在将这些目标从嘈杂或纹理背景中区分出来时。与分割神经网络相比，传统的物体检测方法（如 YOLO）在检测微小物体时非常吃力，因此在检测小目标时性能较弱。为了在保持高检测率的同时减少误报，在 YOLO 检测器的训练中引入了反向决策标准。后者利用小目标的不可预测性，将它们与复杂背景区分开来。在 YOLOv7-tiny 中加入这一统计标准，缩小了红外小目标检测和物体检测网络中最先进的分割方法之间的性能差距。它还大大提高了 YOLO 对少样本环境的鲁棒性。</p> 
<p><strong>关键词：</strong> 小目标检测、逆向推理、YOLO、少样本检测</p> 
<h2><a id="1__14"></a>1 引言</h2> 
<p>在包括医疗或安全领域在内的各种应用中，准确检测红外（infrared, IR）图像中的小目标至关重要。红外小目标检测（Infrared small target detection, IRSTD）是计算机视觉领域的一项巨大挑战，其困难主要在于：(1) 目标的大小（面积低于 20 像素）；(2) 复杂且纹理丰富的背景，从而导致许多误报；(3) 学习条件，即从小型、多样化程度低且高度类不平衡的数据集中学习，因为与背景类像素相比，目标类像素的数量非常少。过去几十年来，深度学习方法的兴起在物体检测领域取得了令人瞩目的进步，这主要归功于它们能够从大量标注数据中学习，提取出非常适合最终任务的非线性特征。在 IRSTD 中，语义分割神经网络的应用最为广泛[1]。其中包括 ACM[2]、LSPM[3]和最近最先进的（SOTA）方法之一，即 DNANet[4]，它由多个嵌套的 UNets 和一个多尺度融合模块组成，能够分割不同大小的小物体。然而，依靠分割神经网络进行物体检测的一个主要问题是，在调整用于二值化分割图的阈值时，可能会出现物体破碎的情况。这会导致许多不希望出现的误报，并扭曲计数指标。Faster-RCNN [5] 或 YOLO [6] 等物体检测算法通过边界框回归明确定位物体，从而降低了这种风险。然而，这些算法往往难以检测到微小物体。很少有研究关注将此类检测器用于 IRSTD [7]，也没有与 SOTA IRSTD 方法进行严格比较。</p> 
<p>在本文中，提出了一种新颖的 YOLO 检测头，称为 OL-NFA（for Object-Level Number of False Alarms, OL-NFA对象级误报数量），专门用于小物体检测。该模块集成了一个逆向决策标准，用于引导特征提取，从而使不可预测的物体在背景中脱颖而出并被检测到。它用于重新估算由 YOLO 骨干计算出的对象性分数，并经过精心实施，以便在训练过程中进行反向传播。使用逆向范式的一个好处是，因为有大量的背景样本，它侧重于对背景建模，而不是对物体本身建模。这样，通过拒绝背景分布的假设来进行检测，就可以绕过类不平衡和训练数据少的问题。主要贡献如下：</p> 
<p>1.设计了一种新颖的 YOLO 检测头，它整合了一种用于估算对象性分数的逆向标准。通过重点对背景而非物体本身进行建模，放宽了对大量训练样本的限制。</p> 
<p>2.在著名的 IRSTD 基准上比较了 SOTA 分割神经网络和物体检测方法，结果表明在 YOLOv7-tiny 骨干中添加 OL-NFA 可以缩小 IRSTD 中物体检测器和 SOTA 分割神经网络 之间的性能差距。</p> 
<p>3.此外，还在少样本环境中大幅提高了 YOLOv7-tiny 的性能（15-shot 的 AP 为 39.2%），证明了逆向范式在弱训练条件下的鲁棒性。</p> 
<h2><a id="2__26"></a>2 相关工作</h2> 
<h3><a id="21__28"></a>2.1 逆向推理</h3> 
<p>逆向决策方法可以自动推导出与假设检验相关的决策标准。这些方法从感知理论，尤其是Gestalt理论中汲取灵感[8]。这些方法包括通过使用可解释的检测阈值来拒绝表征非结构化背景的原始模型。后者允许控制误报数量（NFA），通常定义为被测物体总数与所选原始的模型所遵循的规律的尾部分布之间的乘积。由于计算出的尾值取决于对象的特征，因此 NFA 值可以与任何给定对象相关联。文献中提出了几种逆向的公式。它们取决于考虑的是灰度图像还是二值图像。在第一种情况下，最常用的原始模型是像素灰度值的高斯分布 [9、10、11]。后者已被 [12] 整合到深度学习框架中，并在小目标分割中表现出了很好的性能。在第二种情况下，最广泛使用的原始模型是图像网格中 "真实 "像素的均匀空间分布。这就导致了参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 的二项分布，即 "真实 "像素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         κ 
        
       
      
        κ 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span></span>在任何给定参数形状的区域<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ν 
        
       
      
        ν 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span></span></span></span></span>内的数量[13, 14]：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          NFA 
         
         
         
           ( 
          
         
           κ 
          
         
           , 
          
         
           ν 
          
         
           , 
          
         
           p 
          
         
           ) 
          
         
        
          = 
         
        
          η 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            κ 
           
          
         
           ν 
          
         
         
         
           ( 
          
          
           
            
             
             
               ν 
              
             
            
           
           
            
             
             
               i 
              
             
            
           
          
         
           ) 
          
         
         
         
           p 
          
         
           i 
          
         
         
          
          
            ( 
           
          
            1 
           
          
            − 
           
          
            p 
           
          
            ) 
           
          
          
          
            ν 
           
          
            − 
           
          
            i 
           
          
         
        
          , 
         
        
       
         \text{NFA}\left(\kappa,\nu,p\right)=\eta\sum_{i=\kappa}^{\nu}\begin{pmatrix}\nu\\i\end{pmatrix}p^{i}\left(1-p\right)^{\nu-i}, 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">NFA</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.9291em; vertical-align: -1.2777em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">κ</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0637em;">ν</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8747em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.9646em;"><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0637em;">ν</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         η 
        
       
      
        η 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span></span></span></span></span> 是测试对象的数量。根据公式 (1)，可能代表物体的像素子集更加重要，因为与图像整体密度相比，它包含许多空间上接近的点。工作重点是将这一原始的模型整合到物体检测器的训练循环中，以引导特征提取，而这在之前的研究中并没有考虑到。与 [12] 不同的是，[12] 的原始模型适用于像素级分类（即分割），而作者考虑的是另一种直接适用于对象级的模型，因此更适用于有边界框建议的神经网络。</p> 
<h3><a id="22__36"></a>2.2 物体检测方法</h3> 
<p>物体检测是在图像中检测感兴趣的物体，并通过边界框确定其位置的任务。针对此类任务，已经提出了几种深度学习方法 [15, 6]。YOLO 框架是应用最广泛的一种，因为它在各种应用中都有很好的性能，而且执行时间短。它是一种单阶段算法，使用单个卷积神经网络来预测边界框坐标、对象性和分类分数。具体来说，它将图像划分为一个个网格，并预测任何给定网格单元包含物体的概率（表示为物体度分数），如果存在物体，则预测物体的边界框坐标。YOLO 早期版本的一个问题是，它们在检测小物体时很吃力。事实上，如果要检测的物体太小，它可能只占据网格单元的一小部分，这使得 YOLO 难以准确地检测到它。为了解决这个问题，YOLOv3 [16] 引入了一个特征金字塔网络（feature pyramid network，FPN），将在多个尺度上检测到的特征结合起来。YOLO 的一些最新版本，如 YOLOR [17] 或 YOLOv7 [18]，在一些著名的计算机视觉基准测试中取得了具有竞争力的检测性能，同时还提高了执行速度。还有人提出了卷积层数更少的 YOLO 微型版本。</p> 
<h2><a id="3__40"></a>3 方法</h2> 
<h3><a id="31__42"></a>3.1 总体架构</h3> 
<p><img src="https://images2.imgbox.com/38/24/Qpo1WeWj_o.png" alt="在这里插入图片描述"></p> 
<p>作者提出了一种新颖的 YOLO 检测头，称为 OL-NFA（对象级 NFA 检测头），它集成了一种逆向标准，用于检测具有意外偏离背景分布特征的物体。OL-NFA 将根据 NFA 标准（式 (1)）计算对象性得分，并应用于网络生成的特征图。</p> 
<p>图 1 展示了方法的整体架构。红外输入图像首先经过 YOLO 主干网络，提取不同尺度的特征图。然后，通过颈部将三个较低层次的特征组合在一起，从而得到最终的特征图 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          i 
         
        
       
      
        F_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，用于执行三个层次的检测：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         ∈ 
        
        
        
          1 
         
        
          , 
         
        
          2 
         
        
          , 
         
        
          3 
         
        
       
      
        i∈{1, 2, 3} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6986em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span></span></span></span></span></span>。为了实现检测，首先要通过密集层预测边界框坐标。然后，引入 OL-NFA 模块，利用 NFA 准则重新估算每个边界框的对象度得分。为此，使用 Faster R-CNN [15] 中的 ROI Align 提取出 η 个感兴趣区域（ROI），用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           r 
          
         
           o 
          
         
           i 
          
         
        
       
      
        f_{roi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示，并通过第 3.2 节所述的重要性层计算出每个 ROI 的重要性得分。最后，通过第 3.2 节中定义的函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           a 
          
         
           c 
          
         
           t 
          
         
        
       
      
        f_{act} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，这些分数的范围为 [0，1]，这样就可以应用 YOLO 中使用的二元交叉熵损失。</p> 
<h3><a id="32__51"></a>3.2 逆向标准的可微分积分</h3> 
<p>图 1 中的重要性层整合了公式 (1) 中给出的逆向标准。然而，由于该公式 (i) 是为二值图像而非灰度特征图而设计的，而且 (ii) 不可微，因此需要进行一些近似处理，以便将其整合到 YOLO 训练循环中。公式 (1) 带来的第一个困难是计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           r 
          
         
           o 
          
         
           i 
          
         
        
       
         ∈ 
        
        
        
          R 
         
        
          2 
         
        
       
      
        f_{roi}∈\mathbb{R}^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 中 "True "像素 κ 的数量。如果要对 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           r 
          
         
           o 
          
         
           i 
          
         
        
       
      
        f_{roi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>进行二值化处理，就会破坏反向传播循环。因此，建议考虑实数成员系数（以模糊聚类或分类的精神为指导），即对每个像素处理一个系数，表示它属于包含二进制情况下的值为 1像素的集合的程度。为此，在像素值上使用了 sigmoid 函数 σ，这样就可以通过这些模糊归属系数的总和，近似地计算出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           r 
          
         
           o 
          
         
           i 
          
         
        
       
      
        f_{roi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 中包含的像素数量，从而估算出局部密度。在计算<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          i 
         
        
       
      
        F_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>中的总点数时，也采用了同样的近似方法，以估算公式 (1) 中二项式定律的参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span>（代表<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          i 
         
        
       
      
        F_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 的全局密度）。第二个问题是，NFA 函数是不连续的、不可微的，而且由于处理的是面积很小的物体 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ν 
        
       
      
        ν 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span></span></span></span></span>，它只取极少数不同的值。这些因素使得很难将公式 (1) "原封不动 "地集成到训练环路中，并进行有效的反向传播。因此，定义了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         ( 
        
       
         κ 
        
       
         , 
        
       
         ν 
        
       
         , 
        
       
         p 
        
       
         ) 
        
       
         = 
        
       
         − 
        
       
         l 
        
       
         n 
        
       
         ( 
        
       
         N 
        
       
         F 
        
       
         A 
        
       
         ( 
        
       
         κ 
        
       
         , 
        
       
         ν 
        
       
         , 
        
       
         p 
        
       
         ) 
        
       
         ) 
        
       
      
        S (κ, ν, p) = - ln(NFA(κ, ν, p)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mopen">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em;">NF</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">))</span></span></span></span></span> 的意义，并在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          v 
         
        
       
         &gt; 
        
       
         p 
        
       
      
        \frac{k}{v} &gt; p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2251em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">v</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 时使用霍夫丁近似，从而得出<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
         
         
           ( 
          
         
           κ 
          
         
           , 
          
         
           ν 
          
         
           , 
          
         
           p 
          
         
           ) 
          
         
        
          ≈ 
         
        
          ν 
         
         
         
           [ 
          
          
          
            κ 
           
          
            ν 
           
          
         
           ln 
          
         
           ⁡ 
          
          
          
            ( 
           
           
            
            
              κ 
             
            
              ν 
             
            
           
             p 
            
           
          
            ) 
           
          
         
           + 
          
          
          
            ( 
           
          
            1 
           
          
            − 
           
           
           
             κ 
            
           
             ν 
            
           
          
            ) 
           
          
         
           ln 
          
         
           ⁡ 
          
          
          
            ( 
           
           
            
            
              1 
             
            
              − 
             
             
             
               κ 
              
             
               ν 
              
             
            
            
            
              1 
             
            
              − 
             
            
              p 
             
            
           
          
            ) 
           
          
         
           ] 
          
         
        
          − 
         
        
          ln 
         
        
          ⁡ 
         
        
          η 
         
        
          . 
         
        
       
         S\left(\kappa,\nu,p\right)\approx\nu\left[\frac{\kappa}{\nu}\ln\left(\frac{\frac{\kappa}{\nu}}{p}\right)+\left(1-\frac{\kappa}{\nu}\right)\ln\left(\frac{1-\frac{\kappa}{\nu}}{1-p}\right)\right]-\ln\eta. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.4em; vertical-align: -0.95em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.1076em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.4304em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal">p</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.735em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6954em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0637em;">ν</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">κ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.8804em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size2">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.1076em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.4304em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal">p</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.735em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6954em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0637em;">ν</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">κ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.8804em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span><span class="mord">.</span></span></span></span></span></span><br> 这样，就可以将函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         ( 
        
       
         κ 
        
       
         , 
        
       
         ν 
        
       
         , 
        
       
         p 
        
       
         ) 
        
       
      
        S (κ, ν, p) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mopen">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span> 的域扩展到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          R 
         
        
          3 
         
        
       
      
        \mathbb{R}^3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>，并输出更多的中间值。在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          κ 
         
        
          ν 
         
        
       
         ≤ 
        
       
         p 
        
       
      
        \frac{\kappa}{\nu}≤ p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0404em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6954em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0637em;">ν</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">κ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 的情况下，只需指定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         κ 
        
       
         , 
        
       
         ν 
        
       
         , 
        
       
         p 
        
       
         ) 
        
       
         = 
        
       
         − 
        
       
         l 
        
       
         n 
        
       
           
        
       
         η 
        
       
      
        (κ, ν, p) = - ln~η 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">κ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0637em;">ν</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">n</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span></span></span></span></span>，因为它对应于明显的背景值。最后，由于显著性值的范围为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         [ 
        
       
         − 
        
       
         l 
        
       
         n 
        
       
         ( 
        
        
        
          N 
         
         
         
           t 
          
         
           e 
          
         
           s 
          
         
           t 
          
         
        
       
         ) 
        
       
         , 
        
       
         + 
        
       
         ∞ 
        
       
         ] 
        
       
      
        [- ln(N_{test}), +∞] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span></span></span></span>，其中大值对应于可能的目标，为了获得范围为[0, 1]的对象性得分，应用了非对称激活函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           a 
          
         
           c 
          
         
           t 
          
         
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         η 
        
       
         ) 
        
       
         = 
        
       
         2 
        
       
         σ 
        
       
         ( 
        
       
         x 
        
       
         + 
        
       
         l 
        
       
         n 
        
       
         η 
        
       
         ) 
        
       
         − 
        
       
         1 
        
       
      
        f_{act}(x, η) = 2σ(x + ln η) - 1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         ∈ 
        
       
         R 
        
       
      
        x∈ \mathbb{R} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         η 
        
       
         ∈ 
        
        
        
          N 
         
        
          ∗ 
         
        
       
      
        η∈ \mathbb{N}^∗ 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">η</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6889em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6887em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>。</p> 
<h2><a id="4__59"></a>4 实验</h2> 
<h3><a id="41__61"></a>4.1 数据集和指标</h3> 
<p>在 NUAA-SIRST 数据集[2]上对提出的方法进行了评估，该数据集是为数不多的可公开获取并在文献中广泛使用的红外小目标数据集之一。该数据集由 427 幅红外图像组成，波长范围为 950 到 1200 nm。来自 NUAA-SIRST 的目标的空间范围从 2 - 3 像素到最大目标的 100 像素以上不等，这使得该数据集适合在各种目标尺寸上评估提出的方法。如图 2 第一行所示，目标被淹没在纹理云等具有挑战性的场景中。按照 60 : 20 : 20 的比例将数据集分为训练集、验证集和测试集。还通过仅在 15 幅和 25 幅图像上训练 神经网络 来评估提出的方法在少样本环境中的优势。在定量评估方面，侧重于传统的检测指标：F1 分数（F1）和平均精度（AP，精度-召回曲线下的面积）。还依赖精度（Prec.）和召回率（Rec.）来了解 F1 分数的实现值。表格中的结果是三次不同训练的平均值，上标为 F1 和 AP 的标准偏差。<br> <img src="https://images2.imgbox.com/45/0b/xBfYg4V9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42__68"></a>4.2 实验环境</h3> 
<p>在 YOLOv7tiny 的基础上添加了 OL-NFA 检测头，因为与其他 YOLO 主干线相比，该基线在 NUAA-SIRST 数据集上表现出色。将其与几种基线进行比较：1) 专门为 IRSTD 设计的分割网络，即 ACM [2]、LSPM [3] 和 DNANet [4]；2) YOLO 基线，如 YOLOv3 [16]、YOLOR [17]、YOLOv7 和 YOLOv7-tiny [18]。对于 IRSTD 分割神经网络，使用原始论文中推荐的训练设置。所有物体检测神经网络都在 Nvidia RTX6000 GPU 上进行了 600 epochs从头开始的训练，使用 Adam 优化器 [19]，批量大小等于 16，学习率等于 0.001。少量训练也采用了相同的设置。</p> 
<p>表 1 显示了每种比较方法在 NUAA-SIRST 上取得的性能。可以看到，用OLNFA 代替传统的 YOLO 检测头不仅提高了微小物体检测的 YOLO 性能，还缩小了 SOTA IRSTD 分割神经网络与传统物体检测神经网络之间的性能差距。具体来说，提出的方法比最佳 YOLO 基线的 F1 分数高出 0.7%。AP 标准也提高了 0.4%。此外，提出的方法在 F1 和 AP 方面的表现略好于 DNANet，后者是 IRSTD 的 SOTA 方法。提出的方法的推理时间也比 DNANet 的推理时间短得多，因此可以进行实时目标检测。提出的 OL-NFA 模块之所以性能卓越，主要是因为精度更高，但召回率损失有限，这可以用 NFA 控制误报数量的特性来解释。事实上，增加一个逆向的判定标准有助于增强小物体的特征，从而将它们与复杂背景区分开来。这一点可以从图 2 中看出，最佳 YOLO 基线会导致输入 3 和输入 4 出现多个误报，而提出的方法则能提供正确的检测，没有任何误报。</p> 
<p><img src="https://images2.imgbox.com/a9/93/XmXPaaYS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="44_OLNFA__76"></a>4.4 OL-NFA 为少样本环境带来稳健性</h3> 
<p>将逆向推理纳入神经网络的一个重要动机是网络能够通过学习背景元素的表示而不是目标本身学习判别小目标。因此，它应该能使神经网络对薄弱的训练条件具有鲁棒性。为了证实猜想，在 NUAASIRST 数据集上定量评估了所提出的方法在少样本环境中的优势。为此，分别在 15 幅和 25 幅图像上对网络进行了训练。对于每种少样本设置，都在三个明显的褶皱上训练检测器，它们之间没有重叠。在第 4.1 节定义的测试集上获得的结果是这三个褶皱的平均值，计算出的平均值见表 2。可以看出，提出的方法在节俭设置中的表现明显优于基线方法。事实上，在这些情况下，F1 分数和平均精度都至少提高了 20%。因此，得出结论，在基线方法中添加对象级 NFA 能显著提高其在节俭环境下的鲁棒性：当训练样本数量除以 10 以上时，F1 分数仅降低 15%，而平均精度则保持在 90% 以上。<br> <img src="https://images2.imgbox.com/b4/0d/mz3ZNa9W_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5__82"></a>5 结论</h2> 
<p>在本文中，提出了一种名为 OL-NFA 的新型 YOLO 检测头，它在 YOLO 网络的训练循环中集成了一个逆向的决策标准。它迫使网络对背景分布而不是要检测的物体进行建模。广泛的实验表明，提出的方法不仅显著提高了 YOLO 网络在节俭型和少样本环境下的小目标检测性能，而且在小目标检测方面与 SOTA 分割网络的性能相当。这一令人鼓舞的性能促使考虑进一步研究如何使用逆向范式来检测微小目标。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47fdb5a4196d5b7a135da4637b3fc148/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp 实现微信小程序右上角气泡分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54d7f15d305394700c543fcc4d485830/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【2024软件测试面试必会技能】Appium自动化(4)：Appium工作原理及Desired Capabilities配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>