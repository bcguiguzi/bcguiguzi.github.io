<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在复杂环境下，用Opencv手势和脸部区域提取 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在复杂环境下，用Opencv手势和脸部区域提取" />
<meta property="og:description" content="刚刚看完相关的opencv编程的书籍，于是自己想做点东西练练手
要求是：对给定的图片中人体的脸部和手势进行提取
现在先是对一张图片进行训练，再过度到小包（含有多张图片的文件夹），这是用摄像机对我同学进行拍摄的图片（希望他不会打我。。）
先读出一张图片，对图片进行简单的噪声和滤波处理，然后转换成灰度图进行处理。
这里我用的是高斯滤波，也可以用其他的方法，个人感觉高斯滤波效果好点
肤色模型提取
在这里我提供两种方法给大家，一个是改进的YCbCrd的肤色检测和HSV模型检测。
此处参考的链接https://blog.csdn.net/jacke121/article/details/77861696
改进的YCbCrd的肤色检测
具体是Hsu等人提出在YCbCr空间建立肤色模型。算法步骤如下：
（1）亮度补偿：R、G、B三通道5%非线性Gamma校正
（2）颜色空间转换：RGB颜色空间转换到YCbCr颜色空间；
（3）使用规则作肤色分割。
Image2.create(srcImage.rows, srcImage.cols, CV_8UC3); float gamma = 0.95; for (int r = 0;r &lt; Image2.rows;r&#43;&#43;) { for (int c = 0;c &lt; Image2.cols;c&#43;&#43;) { Image2.at&lt;Vec3b&gt;(r, c)[0] =(int) pow(srcImage.at&lt;Vec3b&gt;(r, c)[0], gamma); Image2.at&lt;Vec3b&gt;(r, c)[1] = (int)pow(srcImage.at&lt;Vec3b&gt;(r, c)[1], gamma); Image2.at&lt;Vec3b&gt;(r, c)[2] = (int)pow(srcImage.at&lt;Vec3b&gt;(r, c)[2], gamma); } } Mat imgYcc; cvtColor(Image2, imgYcc,COLOR_BGR2YCrCb); cvtColor(srcImage, srcImage, COLOR_BGR2RGB); Mat imgSkin; imgSkin.create(srcImage.rows, srcImage.cols, CV_8UC3); float Wcb = 46." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c88cbb8dbac83a7b8e80ef8a7308a7b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-10T21:30:56+08:00" />
<meta property="article:modified_time" content="2018-07-10T21:30:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在复杂环境下，用Opencv手势和脸部区域提取</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>刚刚看完相关的opencv编程的书籍，于是自己想做点东西练练手</p> 
<p>要求是：对给定的图片中人体的脸部和手势进行提取</p> 
<p>现在先是对一张图片进行训练，再过度到小包（含有多张图片的文件夹），这是用摄像机对我同学进行拍摄的图片（希望他不会打我。。）</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/91/9a/eG6AQ3Bg_o.jpg"></p> 
<p>先读出一张图片，对图片进行简单的噪声和滤波处理，然后转换成灰度图进行处理。</p> 
<p>这里我用的是高斯滤波，也可以用其他的方法，个人感觉高斯滤波效果好点</p> 
<p><strong>肤色模型提取</strong></p> 
<p>在这里我提供两种方法给大家，一个是<strong>改进的YCbCrd的肤色检测和HSV模型检测。</strong></p> 
<p><span style="color:#999999;"><strong>此处参考的链接https://blog.csdn.net/jacke121/article/details/77861696</strong></span></p> 
<p><strong>改进的YCbCrd的肤色检测</strong></p> 
<p> </p> 
<p>具体是<span style="color:#333333;">Hsu等人提出在YCbCr空间建立肤色模型。算法步骤如下：</span></p> 
<p><span style="color:#333333;">（1）</span><span style="color:#333333;">亮度补偿</span><span style="color:#333333;">：R、G、B三通道5%非线性Gamma校正</span></p> 
<p style="text-indent:0px;"><span style="color:#333333;">（2）</span><span style="color:#333333;">颜色空间转换</span><span style="color:#333333;">：RGB颜色空间转换到YCbCr颜色空间；</span></p> 
<p style="text-indent:0px;"><span style="color:#333333;">（3）使用</span><span style="color:#333333;">规则</span><span style="color:#333333;">作肤色分割。</span></p> 
<pre class="has"><code class="language-cpp">Image2.create(srcImage.rows, srcImage.cols, CV_8UC3);
float gamma = 0.95;
for (int r = 0;r &lt; Image2.rows;r++)
{
for (int c = 0;c &lt; Image2.cols;c++)
{
Image2.at&lt;Vec3b&gt;(r, c)[0] =(int) pow(srcImage.at&lt;Vec3b&gt;(r, c)[0], gamma);
Image2.at&lt;Vec3b&gt;(r, c)[1] = (int)pow(srcImage.at&lt;Vec3b&gt;(r, c)[1], gamma);
Image2.at&lt;Vec3b&gt;(r, c)[2] = (int)pow(srcImage.at&lt;Vec3b&gt;(r, c)[2], gamma);
}
}
Mat imgYcc;
cvtColor(Image2, imgYcc,COLOR_BGR2YCrCb);


cvtColor(srcImage, srcImage, COLOR_BGR2RGB);
Mat imgSkin;
imgSkin.create(srcImage.rows, srcImage.cols, CV_8UC3);
float Wcb = 46.97, Wcr = 38.76;
int WHCb = 14, WHCr = 10, WLCb = 23, WLCr = 20;
int Ymin = 16, Ymax = 235;
int Kl = 125, Kh = 188, WCb = 0, WCr = 0;
int CbCenter = 0, CrCenter = 0;
int skin;
for (int r = 0;r &lt; srcImage.rows;r++)
{
for (int c = 0;c &lt; srcImage.cols;c++)
{
skin = 0;
double  Y = imgYcc. at&lt;Vec3b&gt;(r, c)[0];
double  Cr = imgYcc.at&lt;Vec3b&gt;(r, c)[1];
double  Cb = imgYcc.at&lt;Vec3b&gt;(r, c)[2];
if (Y &lt; Kl)
{
WCr = WLCr + (Y - Ymin)*(Wcr - WLCr) / (Kl - Ymin);
WCb = WLCb + (Y - Ymin)*(Wcb - WLCb) / (Kl - Ymin);
}
else if (Y &gt; Kh)
{
WCr = WHCr + (Y - Ymax)*(Wcr - WHCr) / (Ymax - Kh);
WCb = WHCb + (Y - Ymax)*(Wcb - WHCb) / (Ymax - Kh);
CrCenter= 154 + (Y - Kh)*(154 - 132) / (Ymax - Kh);
CbCenter = 108 + (Y - Kh)*(118 - 108) / (Ymax - Kh);
}
if (Y&lt;Kl || Y&gt;Kh)
{
Cr = (Cr - CrCenter)*Wcr / WCr + 154;
Cb = (Cb - CbCenter)*Wcb / WCb + 108;
}
if (Cb &gt; 77 &amp;&amp; Cb &lt; 127 &amp;&amp; Cr&gt;133 &amp;&amp; Cr &lt; 173)
skin = 1;
if (skin == 0)
{
imgSkin.at&lt;Vec3b&gt;(r, c)[0] = 0;
imgSkin. at&lt;Vec3b&gt;(r, c)[1] = 0;
imgSkin.at&lt;Vec3b&gt;(r, c)[2] = 0;
}
}

}</code></pre> 
<p>我开始用的该算法，不能说效果不好。只能说是我大意了，该算法运用在背景不是很复杂的情况下用有很好的效果，但是我给的图中，草地的颜色在此算法中产生了极大的干扰，话不多说我直接上效果图，你们自己感受一下。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/cb/cd/z0LCth0z_o.png"></p> 
<p> </p> 
<p><strong>HSV模型检测</strong></p> 
<p>这个原理我就不说了，在网上挺多的，大家可以自己在网上找找。</p> 
<pre class="has"><code class="language-cpp">//HSV颜色空间的肤色模型检测
double H, S, V;
int skin;
cvtColor(srcImage, srcImage, COLOR_BGR2RGB);
Mat imgSkin2,imgHsv;
imgSkin2.create(srcImage.rows, srcImage.cols, CV_8UC3);
imgHsv.create(srcImage.rows, srcImage.cols, CV_8UC3);
cvtColor(srcImage, imgHsv, COLOR_RGB2HSV);
for (int r=0;r &lt; imgHsv.rows;r++)
{
for (int c = 0;c &lt; imgHsv.cols;c++)
{
skin = 0;
H = imgHsv.at&lt;Vec3b&gt;(r, c)[0];
S = imgHsv.at&lt;Vec3b&gt;(r, c)[1];
V = imgHsv.at&lt;Vec3b&gt;(r, c)[2];


if (((H &gt;= 0) &amp;&amp; (H &lt;= 25/2 )) || ((H &gt;= 335 / 2) &amp;&amp; (H &lt;= 360 / 2)))
if ((S &gt; 0.2 * 255) &amp;&amp; (S &lt;= 0.6 * 255) &amp;&amp; (V &gt;= 0.4 * 255))
skin = 1;
if (skin == 0)
{
imgSkin2.at&lt;Vec3b&gt;(r, c)[0] = 0;
imgSkin2.at&lt;Vec3b&gt;(r, c)[1] = 0;
imgSkin2.at&lt;Vec3b&gt;(r, c)[2] = 0;
}
}
}</code></pre> 
<p>这个里面的参数H,S,V是判断肤色的重要依据。</p> 
<p>效果图如下：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/e4/10/LxCAyEJ2_o.png"></p> 
<p>从效果上，明显比上面的算法要好很多，两种算法的运用是根据人所处的环境带来的影响运用的，如果环境与人体肤色相差较大，那么改进的YCbCrd的肤色检测要好很多。</p> 
<p><strong>膨胀</strong></p> 
<p>因为效果图里面的亮点太多，所以我们需要将它们去掉，除了膨胀，也可以用开运算，其目的是使分散的亮点集中，然后进行去杂处理。</p> 
<p><strong>绘制轮廓</strong></p> 
<p>将所有亮点的区域用轮廓的方式收集起来。</p> 
<pre class="has"><code class="language-cpp">Mat threshold_output=Mat::zeros(g_dstImage.rows,g_dstImage.cols,CV_8UC1);
vector&lt;vector&lt;Point&gt;&gt; contours;
vector&lt;Vec4i&gt; hierachy;
//边缘检测
threshold(g_dstImage, threshold_output, 150, 255, THRESH_BINARY);
findContours(threshold_output, contours, hierachy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0));
vector&lt;vector&lt;Point&gt;&gt; contours_poly(contours.size());
for (unsigned int i = 0;i &lt; contours.size();i++)
approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
Mat drawing = Mat::zeros(threshold_output.size(), CV_8UC3);
for (int unsigned i = 0;i &lt; contours.size();i++)

drawContours(drawing, contours_poly, i, Scalar(255, 0, 0), 1, 8, hierachy, 0, Point());</code></pre> 
<p>效果图：</p> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/35/66/qRYS5P7m_o.png"></p> 
<p> </p> 
<p>然后得到轮廓面积和长度，去掉小的轮廓和面积，剩下的就只有手和脸了，只要再将手和脸外围轮廓的点集收集起来，就可以得到我们想要的区域了。</p> 
<pre class="has"><code class="language-cpp">for (unsigned int i = 0;i &lt; contours_poly.size();i++)
mu[i] = moments(contours_poly[i], false);

for (unsigned int i = 0;i &lt; contours_poly.size();i++)
{
//printf("&gt;通过m00计算出轮廓的面积和长度分别为：%.2f,%.2f\n", contourArea(contours_poly[i]), arcLength(contours_poly[i], true));
double area = contourArea(contours_poly[i]);
double length = arcLength(contours_poly[i], true);
if(area&gt;2000.0&amp;&amp;length&gt;314)
contours1.push_back(contours_poly[i]);



}</code></pre> 
<p>这里的2000和314，是通过我抽象计算得出来，具体看镜头的远近。</p> 
<p><strong>获取ROI区域及提取轮廓里面的像素</strong></p> 
<p>最后这一步比较简单，做一个mask，将刚刚收集的手和脸的点集放进去，然后CopyTo进去就行了</p> 
<pre class="has"><code class="language-cpp">Mat masking(drawing.size(), CV_8U, Scalar::all(0));
Mat endimage(srcImage.rows, srcImage.cols, CV_8UC3);
drawContours(masking, contours1, -1, Scalar(255), CV_FILLED);

g_srcImage.copyTo(endimage, masking);

imshow("最终图", endimage);</code></pre> 
<p>最后的效果图为：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/da/6d/CmeUrRrg_o.png"></p> 
<p>还是有缺陷比如手的损失，皮肤为啥是蓝色等，但是我不想改了，哈哈哈，能达到我预期的要求。</p> 
<p>我多给几个例子感受一下：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0b/e2/TDBq1Q2n_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/28/07/ckmDPtwD_o.png"></p> 
<p>因为刚开始做项目，所以很粗糙，希望大家可以谅解一下，比心~</p> 
<p>源代码地址：https://download.csdn.net/download/qq_39027890/10533536</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e1869451ead4f41c80faf829d83369f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一、Linux目录介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f46eca1f0f78c8c65a7048385935c34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTTP post 请求携带xml格式报文请求接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>