<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小程序学习2 自定义组件 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小程序学习2 自定义组件" />
<meta property="og:description" content="组件 | 微信开放文档 miniprogram_npm/tdesign-miniprogram/swiper/swiper 小程序中miniprogram_npm是什么 在小程序中，miniprogram_npm是一个用于管理和引用npm包的机制。它允许开发者在小程序中直接使用npm包，而无需手动下载和引入。通过miniprogram_npm，开发者可以方便地使用第三方库和工具来增强小程序的功能。
使用miniprogram_npm的步骤如下：
在小程序项目的根目录下执行npm init命令，生成package.json文件，用于管理项目的依赖。使用npm install命令安装需要的npm包，安装后的包会被保存在项目的miniprogram_npm目录下。在小程序代码中使用require()函数引入需要的npm包，然后就可以使用该包提供的功能了。 需要注意的是，引入的npm包需要进行适配，以使其能够在小程序环境中正常运行。有些npm包可能需要进行一些额外的配置或修改才能在小程序中使用。
快速开始 | Lin UI
....
微信开发者工具中安装TDesign组件库_tdesign-miniprogram-CSDN博客 TDesign 出现上图所示的结果后，可以看到小程序IDE工具的目录结构里多出了一个文件夹 miniprogram_npm（之后所有通过 npm 引入的组件和 js 库都会出现在这里），打开后可以看到 lin-ui 文件夹，也就是我们所需要的组件。
【微信小程序】组件的生命周期及自定义组件_小程序组件的生命周期-CSDN博客
ESLint ESLint是一个用于静态代码分析的工具，它可以帮助开发者在编写JavaScript代码时发现并修复常见的错误和潜在的问题。ESLint可以根据预定义的规则或自定义的规则对代码进行检查，并提供了丰富的插件和配置选项，以满足不同项目的需求。
ESLint的主要功能包括：
语法检查：ESLint可以检查代码是否符合JavaScript语法规范，例如缺少分号、括号不匹配等。代码风格检查：ESLint可以根据预定义的代码风格规则（如Airbnb、Google等）或自定义的规则检查代码的风格是否一致，例如缩进、命名规范等。潜在问题检查：ESLint可以检查代码中可能存在的潜在问题，例如未使用的变量、未定义的变量等。提示和建议：ESLint可以提供一些提示和建议，帮助开发者编写更好的代码，例如优化建议、最佳实践等。 使用ESLint可以提高代码质量和可维护性，减少潜在的bug和错误。它可以与各种编辑器、构建工具和持续集成工具集成，方便开发者在开发过程中实时检查代码。
mock Mock是一种在软件开发中常用的测试技术，它用于模拟或替代真实的对象，以便进行单元测试。通过使用Mock对象，我们可以模拟外部依赖或者不可控的环境，使得测试更加可控和可靠。
Mock对象通常是通过使用特定的框架或库来创建和管理的。在创建Mock对象时，我们可以定义它的行为和返回值，以模拟真实对象的行为。通过这种方式，我们可以在测试中隔离被测对象与外部依赖的交互，使得测试更加独立和可重复。
Mock对象可以用于各种测试场景，例如：
模拟网络请求或数据库操作，以避免对真实资源的依赖和影响。模拟外部服务或组件，以确保被测系统在与其交互时的正确性。模拟异常情况或边界条件，以验证被测系统的健壮性和容错性。 使用Mock的好处包括：
提高测试效率：通过模拟外部依赖，可以减少测试所需的时间和资源。提高测试覆盖率：可以更容易地模拟各种场景和边界条件，从而增加测试覆盖率。提高测试可靠性：通过隔离外部依赖，可以更好地控制测试环境，减少测试结果的不确定性。 swiper.wxml &lt;wxs src=&#34;./index.wxs&#34; module=&#34;this&#34; /&gt; &lt;wxs src=&#34;../common/utils.wxs&#34; module=&#34;_&#34; /&gt; &lt;import src=&#34;../common/template/image.wxml&#34; /&gt; &lt;view class=&#34;class {{prefix}}-class {{classPrefix}}&#34; style=&#34;{{_._style([style, customStyle])}}&#34;&gt; &lt;swiper class=&#34;{{classPrefix}}-host&#34; autoplay=&#34;{{autoplay}}&#34; current=&#34;{{current}}&#34; interval=&#34;{{interval}}&#34; duration=&#34;{{duration}}&#34; circular=&#34;{{loop}}&#34; vertical=&#34;{{direction == &#39;vertical&#39;}}&#34; easing-function=&#34;{{easingFunction}}&#34; previous-margin=&#34;{{previousMargin}}&#34; next-margin=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/badc7ad5b2ac1e49c480e6558d74e236/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T13:20:04+08:00" />
<meta property="article:modified_time" content="2024-03-15T13:20:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小程序学习2 自定义组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;"><a href="https://developers.weixin.qq.com/miniprogram/dev/component/xr-frame/core/component.html" rel="nofollow" title="组件 | 微信开放文档">组件 | 微信开放文档</a></h2> 
<h2>miniprogram_npm/tdesign-miniprogram/swiper/swiper</h2> 
<h5><span style="background-color:#6eaad7;">小程序中miniprogram_npm是什么</span></h5> 
<p>在小程序中，miniprogram_npm是一个用于管理和引用npm包的机制。它允许开发者在小程序中直接使用npm包，而无需手动下载和引入。通过miniprogram_npm，开发者可以方便地使用第三方库和工具来增强小程序的功能。</p> 
<p>使用miniprogram_npm的步骤如下：</p> 
<ol><li>在小程序项目的根目录下执行<code>npm init</code>命令，生成<code>package.json</code>文件，用于管理项目的依赖。</li><li>使用<code>npm install</code>命令安装需要的npm包，安装后的包会被保存在项目的<code>miniprogram_npm</code>目录下。</li><li>在小程序代码中使用<code>require()</code>函数引入需要的npm包，然后就可以使用该包提供的功能了。</li></ol> 
<p>需要注意的是，引入的npm包需要进行适配，以使其能够在小程序环境中正常运行。有些npm包可能需要进行一些额外的配置或修改才能在小程序中使用。</p> 
<p><a href="https://doc.mini.talelin.com/start/" rel="nofollow" title="快速开始 | Lin UI">快速开始 | Lin UI</a></p> 
<p>....</p> 
<p><a href="https://blog.csdn.net/cym2217348/article/details/128909960?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128909960-blog-124701095.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128909960-blog-124701095.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;utm_relevant_index=3" title="微信开发者工具中安装TDesign组件库_tdesign-miniprogram-CSDN博客">微信开发者工具中安装TDesign组件库_tdesign-miniprogram-CSDN博客</a>  </p> 
<p></p> 
<p><a href="https://tdesign.tencent.com/miniprogram/" rel="nofollow" title="TDesign">TDesign</a>     </p> 
<p>出现上图所示的结果后，可以看到小程序IDE工具的目录结构里多出了一个文件夹 <code>miniprogram_npm</code>（之后所有通过 <code>npm</code> 引入的组件和 <code>js</code> 库都会出现在这里），打开后可以看到 <code>lin-ui</code> 文件夹，也就是我们所需要的组件。</p> 
<p><a href="https://blog.csdn.net/weixin_46277553/article/details/126804471?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171046148816800192274348%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=171046148816800192274348&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-126804471-null-null.142%5Ev99%5Epc_search_result_base3&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB&amp;spm=1018.2226.3001.4187" title="【微信小程序】组件的生命周期及自定义组件_小程序组件的生命周期-CSDN博客">【微信小程序】组件的生命周期及自定义组件_小程序组件的生命周期-CSDN博客</a></p> 
<h5><span style="background-color:#6eaad7;">ESLint</span></h5> 
<p>ESLint是一个用于静态代码分析的工具，它可以帮助开发者在编写JavaScript代码时发现并修复常见的错误和潜在的问题。ESLint可以根据预定义的规则或自定义的规则对代码进行检查，并提供了丰富的插件和配置选项，以满足不同项目的需求。</p> 
<p>ESLint的主要功能包括：</p> 
<ol><li>语法检查：ESLint可以检查代码是否符合JavaScript语法规范，例如缺少分号、括号不匹配等。</li><li>代码风格检查：ESLint可以根据预定义的代码风格规则（如Airbnb、Google等）或自定义的规则检查代码的风格是否一致，例如缩进、命名规范等。</li><li>潜在问题检查：ESLint可以检查代码中可能存在的潜在问题，例如未使用的变量、未定义的变量等。</li><li>提示和建议：ESLint可以提供一些提示和建议，帮助开发者编写更好的代码，例如优化建议、最佳实践等。</li></ol> 
<p>使用ESLint可以提高代码质量和可维护性，减少潜在的bug和错误。它可以与各种编辑器、构建工具和持续集成工具集成，方便开发者在开发过程中实时检查代码。</p> 
<h5><span style="background-color:#6eaad7;">mock</span></h5> 
<p>Mock是一种在软件开发中常用的测试技术，它用于模拟或替代真实的对象，以便进行单元测试。通过使用Mock对象，我们可以模拟外部依赖或者不可控的环境，使得测试更加可控和可靠。</p> 
<p>Mock对象通常是通过使用特定的框架或库来创建和管理的。在创建Mock对象时，我们可以定义它的行为和返回值，以模拟真实对象的行为。通过这种方式，我们可以在测试中隔离被测对象与外部依赖的交互，使得测试更加独立和可重复。</p> 
<p>Mock对象可以用于各种测试场景，例如：</p> 
<ol><li>模拟网络请求或数据库操作，以避免对真实资源的依赖和影响。</li><li>模拟外部服务或组件，以确保被测系统在与其交互时的正确性。</li><li>模拟异常情况或边界条件，以验证被测系统的健壮性和容错性。</li></ol> 
<p>使用Mock的好处包括：</p> 
<ol><li>提高测试效率：通过模拟外部依赖，可以减少测试所需的时间和资源。</li><li>提高测试覆盖率：可以更容易地模拟各种场景和边界条件，从而增加测试覆盖率。</li><li>提高测试可靠性：通过隔离外部依赖，可以更好地控制测试环境，减少测试结果的不确定性。</li></ol> 
<p></p> 
<h3><span style="background-color:#a2e043;">swiper.wxml</span></h3> 
<pre><code class="language-XML">&lt;wxs src="./index.wxs" module="this" /&gt;
&lt;wxs src="../common/utils.wxs" module="_" /&gt;

&lt;import src="../common/template/image.wxml" /&gt;

&lt;view class="class {<!-- -->{prefix}}-class {<!-- -->{classPrefix}}" style="{<!-- -->{_._style([style, customStyle])}}"&gt;
  &lt;swiper
    class="{<!-- -->{classPrefix}}-host"
    autoplay="{<!-- -->{autoplay}}"
    current="{<!-- -->{current}}"
    interval="{<!-- -->{interval}}"
    duration="{<!-- -->{duration}}"
    circular="{<!-- -->{loop}}"
    vertical="{<!-- -->{direction == 'vertical'}}"
    easing-function="{<!-- -->{easingFunction}}"
    previous-margin="{<!-- -->{previousMargin}}"
    next-margin="{<!-- -->{nextMargin}}"
    snap-to-edge="{<!-- -->{snapToEdge}}"
    display-multiple-items="{<!-- -->{displayMultipleItems}}"
    style="height: {<!-- -->{_.addUnit(height)}}"
    bindchange="onChange"
  &gt;
    &lt;swiper-item
      wx:for="{<!-- -->{list}}"
      wx:key="index"
      class="{<!-- -->{_.cls(classPrefix + '__item', [['preview', this.isPrev(current, index, list)], ['next', this.isNext(current, index, list)]])}}"
      data-index="{<!-- -->{index}}"
      bind:tap="onTap"
      aria-hidden="{<!-- -->{navCurrent !== index}}"
      aria-role="image"
      aria-label="{<!-- -->{_.isObject(item) ? item.ariaLabel : ''}}"
    &gt;
      &lt;template
        is="image"
        data="{<!-- -->{ class: classPrefix + '__image-host', tClass: this.getImageClass(prefix, current, index, list), style: 'height: ' + _.addUnit(height), src: _.isObject(item) ? item.value : item, mode: 'aspectFill', dataset: index, ...imageProps, bindload: 'onImageLoad' }}"
      /&gt;
    &lt;/swiper-item&gt;
  &lt;/swiper&gt;
  &lt;t-swiper-nav
    wx:if="{<!-- -->{navigation}}"
    t-class="{<!-- -->{prefix}}-class-nav"
    type="{<!-- -->{navigation.type || 'dots'}}"
    current="{<!-- -->{navCurrent || 0}}"
    total="{<!-- -->{list.length || 0}}"
    direction="{<!-- -->{direction || 'horizontal'}}"
    pagination-position="{<!-- -->{paginationPosition || 'bottom'}}"
    min-show-num="{<!-- -->{navigation.minShowNum || 2}}"
    show-controls="{<!-- -->{navigation.showControls || false}}"
    bind:nav-btn-change="onNavBtnChange"
  /&gt;
  &lt;slot name="nav" /&gt;
&lt;/view&gt;
</code></pre> 
<p>这段代码是一个小程序中的swiper组件的使用示例。swiper组件是用来实现轮播图效果的，可以在其中放置多个swiper-item来展示不同的内容。以下是对代码中一些重要部分的介绍：</p> 
<ol><li><code>&lt;wxs&gt;</code>标签：用于引入外部的wxs文件，可以在小程序中使用wxs模块中定义的函数和变量。</li><li><code>&lt;import&gt;</code>标签：用于引入外部的wxml文件，可以在小程序中使用引入文件中定义的模板。</li><li><code>&lt;view&gt;</code>标签：视图容器，用于包裹swiper组件和其他内容。</li><li><code>&lt;swiper&gt;</code>标签：swiper组件，用于实现轮播图效果。</li><li><code>class</code>属性：用于设置视图容器的样式类。</li><li><code>autoplay</code>属性：是否自动切换轮播图。</li><li><code>current</code>属性：当前所在的轮播图索引。</li><li><code>interval</code>属性：自动切换的时间间隔。</li><li><code>duration</code>属性：切换动画的时长。</li><li><code>circular</code>属性：是否采用衔接滑动。</li><li><code>vertical</code>属性：是否垂直滚动。</li><li><code>easing-function</code>属性：切换动画的缓动函数。</li><li><code>previous-margin</code>和<code>next-margin</code>属性：前后两个轮播图之间的边距。</li><li><code>snap-to-edge</code>属性：是否将滑动距离对齐到边界。</li><li><code>display-multiple-items</code>属性：同时显示的轮播图数量。</li><li><code>style</code>属性：设置swiper组件的样式，这里设置了高度。</li><li><code>bindchange</code>属性：绑定切换事件的回调函数。</li><li><code>&lt;swiper-item&gt;</code>标签：swiper组件中的每个轮播项，可以在其中放置需要展示的内容。</li><li><code>wx:for</code>属性：用于遍历list数组，生成多个swiper-item。</li><li><code>wx:key</code>属性：指定遍历时的唯一标识。</li><li><code>class</code>属性：设置每个swiper-item的样式类。</li><li><code>data-index</code>属性：设置每个swiper-item的索引值。</li><li><code>bind:tap</code>属性：绑定点击事件的回调函数。</li></ol> 
<p><a href="https://blog.csdn.net/fsadagds/article/details/126868845?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8Fswiper%E5%92%8Cswiper-item&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-126868845.142%5Ev99%5Epc_search_result_base3&amp;spm=1018.2226.3001.4187" title="【微信小程序入门到精通】— 轮播图你会了么？快速拿下 swiper 和 swiper-item-CSDN博客">【微信小程序入门到精通】— 轮播图你会了么？快速拿下 swiper 和 swiper-item-CSDN博客</a></p> 
<h5><span style="background-color:#6eaad7;">小程序中swiper 和swiper-nav有什么区别</span></h5> 
<p>在小程序中，swiper和swiper-nav都是用于实现轮播图的组件，但它们有一些区别。</p> 
<ol><li>Swiper（轮播图）： Swiper是小程序中常用的轮播图组件，可以实现图片、文字等内容的自动轮播。它具有以下特点：</li></ol> 
<ul><li>可以设置自动播放、循环播放等属性。</li><li>可以通过设置indicator-dots属性来显示轮播图的指示点。</li><li>可以通过设置indicator-color属性来自定义指示点的颜色。</li><li>可以通过设置autoplay属性来控制是否自动播放。</li><li>可以通过设置interval属性来控制轮播图切换的时间间隔。</li></ul> 
<ol><li>Swiper-nav（导航轮播图）： Swiper-nav是小程序中的导航轮播图组件，它可以实现带有导航功能的轮播图。它具有以下特点：</li></ol> 
<ul><li>可以设置导航按钮的样式和位置。</li><li>可以通过设置indicator-dots属性来显示轮播图的指示点。</li><li>可以通过设置indicator-color属性来自定义指示点的颜色。</li><li>可以通过设置autoplay属性来控制是否自动播放。</li><li>可以通过设置interval属性来控制轮播图切换的时间间隔。</li></ul> 
<p>总结： Swiper主要用于展示图片、文字等内容的自动轮播，而Swiper-nav则是在Swiper的基础上增加了导航功能，可以实现带有导航按钮的轮播图。</p> 
<h5><span style="background-color:#6eaad7;">wxs文件 是什么</span></h5> 
<p>wxs文件是一种用于描述Windows Installer安装程序的XML格式文件。它是Windows Installer XML (WiX) 工具集的一部分，用于创建和编辑安装程序。WXS文件包含了安装程序的组件、文件、注册表项、快捷方式等信息。</p> 
<p>WXS文件使用一种类似于HTML的标记语言来定义安装程序的结构和行为。通过编写WXS文件，开发人员可以指定要安装的文件、创建注册表项、创建快捷方式等操作。WXS文件还可以定义自定义的安装界面、升级策略、安装条件等。</p> 
<p>WXS文件需要使用WiX工具集进行编译，生成最终的安装程序。WiX工具集提供了一系列命令行工具和库，可以将WXS文件转换为MSI（Microsoft Installer）格式的安装程序。</p> 
<h5><span style="background-color:#6eaad7;">.d.ts 文件是什么</span></h5> 
<p>.d.ts文件是TypeScript的<span style="background-color:#fefcd8;">声明文件</span>，用于描述JavaScript库、框架或模块的类型信息。在TypeScript中，通过声明文件可以为JavaScript代码提供静态类型检查和智能提示的支持。声明文件通常以.d.ts为后缀名，并包含了对应JavaScript代码的类型定义、接口、类、函数等信息。</p> 
<p>声明文件可以定义全局变量、全局函数、全局对象、模块等的类型信息，使得在TypeScript使用这些JavaScript库时能够获得更好的开发体验。通过引入声明文件，TypeScript编译器可以根据声明文件中的类型信息进行类型检查，提供代码补全和错误等功能。</p> 
<p>声明文件可以由开发者手动编写，也可以通过工具自动生成。一些流行的JavaScript库和框架已经提供了官方的声明文件，也社区维护的第三方声明文件库（如DefinitelyTyped），可以便地引入和使用。</p> 
<p></p> 
<h3><span style="background-color:#a2e043;">swiper.d.ts</span></h3> 
<pre><code class="language-TypeScript">import { SuperComponent, RelationsOptions } from '../common/src/index';
export default class Swiper extends SuperComponent {
    externalClasses: string[];
    options: {
        multipleSlots: boolean;
    };
    properties: import("./type").TdSwiperProps;
    observers: {
        navCurrent(v: any): void;
    };
    $nav: any;
    relations: RelationsOptions;
    data: {
        prefix: string;
        classPrefix: string;
    };
    lifetimes: {
        ready(): void;
    };
    methods: {
        updateNav(currentValue: any): void;
        onTap(e: any): void;
        onChange(e: any): void;
        onNavBtnChange(e: any): void;
        doNavBtnChange(dir: any, source: any): void;
        onImageLoad(e: any): void;
    };
}
</code></pre> 
<p>这段代码是一个名为Swiper的类的定义，它继承自SuperComponent类。Swiper类有以下属性和方法：</p> 
<p>属性：</p> 
<ul><li>externalClasses: 字符串数组类型，用于指定外部样式类。</li><li>options: 对象类型，包含一个布尔类型的属性multipleSlots，用于指示是否支持多个插槽。</li><li>properties: 类型为import(“./type”).TdSwiperProps的属性，用于定义组件的属性。</li><li>observers: 对象类型，包含一个函数类型的属性navCurrent，用于观察navCurrent属性的变化。</li></ul> 
<p>方法：</p> 
<ul><li>$nav: 任意类型，用于存储导航相关的数据。</li><li>relations: 对象类型，用于定义组件之间的关系。</li><li>data: 对象类型，包含两个字符串类型的属性prefix和classPrefix。</li><li>lifetimes: 对象类型，包含一个函数类型的属性ready，用于在组件实例被创建并插入到页面中时执行。</li><li>methods: 对象类型，包含多个函数类型的属性，用于定义组件的方法。</li></ul> 
<h5><span style="background-color:#6eaad7;">typescript是什么语言</span></h5> 
<p>TypeScript是一种开源的编程语言，它是JavaScript的一个<span style="background-color:#d4e9d5;">超集</span>。它添加了静态类型和面向对象的特性，使得开发者能够更好地进行代码组织、重构和调试。TypeScript通过在编译时进行类型检查，可以帮助开发者在开发过程中发现潜在的错误，并提供更好的代码提示和自动补全功能。此外，TypeScript还支持最新的ECMAScript标准，并且可以与现有的JavaScript代码无缝集成。</p> 
<h3><span style="background-color:#a2e043;">swiper.js</span></h3> 
<pre><code class="language-javascript">var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;
    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;
};
import { SuperComponent, wxComponent } from '../common/src/index';
import config from '../common/config';
import props from './props';
const { prefix } = config;
const name = `${prefix}-swiper`;
let Swiper = class Swiper extends SuperComponent {
    constructor() {
        super(...arguments);
        this.externalClasses = [
            `${prefix}-class`,
            `${prefix}-class-nav`,
            `${prefix}-class-image`,
            `${prefix}-class-prev-image`,
            `${prefix}-class-next-image`,
        ];
        this.options = {
            multipleSlots: true,
        };
        this.properties = props;
        this.observers = {
            navCurrent(v) {
                this.updateNav(v);
            },
        };
        this.$nav = null;
        this.relations = {
            '../swiper-nav/swiper-nav': {
                type: 'child',
            },
        };
        this.data = {
            prefix,
            classPrefix: name,
        };
        this.lifetimes = {
            ready() {
                const { current } = this.properties;
                this.setData({ navCurrent: current });
            },
        };
        this.methods = {
            updateNav(currentValue) {
                var _a;
                if (this.data.navigation)
                    return;
                const $nav = (_a = this.getRelationNodes('./swiper-nav')) === null || _a === void 0 ? void 0 : _a[0];
                if (!$nav)
                    return;
                const { direction, paginationPosition, list } = this.properties;
                $nav.setData({
                    current: currentValue,
                    total: list.length,
                    direction,
                    paginationPosition,
                });
            },
            onTap(e) {
                const { index } = e.currentTarget.dataset;
                this.triggerEvent('click', { index });
            },
            onChange(e) {
                const { current, source } = e.detail;
                this.setData({
                    navCurrent: current,
                });
                this.triggerEvent('change', { current, source });
            },
            onNavBtnChange(e) {
                const { dir, source } = e.detail;
                this.doNavBtnChange(dir, source);
            },
            doNavBtnChange(dir, source) {
                const { current, list, loop } = this.data;
                const count = list.length;
                let nextPos = dir === 'next' ? current + 1 : current - 1;
                if (loop) {
                    nextPos = dir === 'next' ? (current + 1) % count : (current - 1 + count) % count;
                }
                else {
                    nextPos = nextPos &lt; 0 || nextPos &gt;= count ? current : nextPos;
                }
                if (nextPos === current)
                    return;
                this.setData({
                    current: nextPos,
                });
                this.triggerEvent('change', { current: nextPos, source });
            },
            onImageLoad(e) {
                this.triggerEvent('image-load', { index: e.target.dataset.custom });
            },
        };
    }
};
Swiper = __decorate([
    wxComponent()
], Swiper);
export default Swiper;
</code></pre> 
<p>这段代码是一个JavaScript模块，其中定义了一个名为Swiper的类。这个类继承自SuperComponent类，并且使用了装饰器来修饰类的属性和方法。</p> 
<p>装饰器是一种特殊的语法，可以用来修改类的行为。在这段代码中，使用了一个名为__decorate的函数来应用装饰器。</p> 
<p>具体来说，这段代码做了以下几件事情：</p> 
<ol><li>导入了名为SuperComponent和wxComponent的模块。</li><li>导入了名为config的模块，并从中获取了prefix属性。</li><li>定义了一个名为Swiper的类，该类继承自SuperComponent类。</li><li>在Swiper类中定义了一个名为externalClasses的属性，它是一个数组，包含了一些字符串。</li><li>Swiper类还有一个constructor构造函数，用于初始化对象的属性。</li></ol> 
<h5><span style="background-color:#6eaad7;">问题1： var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;</span></h5> 
<p>这段代码是一个变量声明语句，其中包含了多个变量的初始化操作。让我逐一解释一下：</p> 
<ol><li> <p><span style="color:#fe2c24;"><code><span style="background-color:#f3f3f4;">var c = arguments.length</span></code></span>：这行代码将变量 <code>c</code> 初始化为 <code>arguments.length</code> 的值。<code>arguments</code> 是一个特殊的对象，它包含了函数调用时传递的所有参数。<code>arguments.length</code> 表示传递给函数的参数个数。</p> </li><li> <p><span style="color:#fe2c24;"><code><span style="background-color:#f3f3f4;">r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,d</span></code></span>：这是一个条件表达式，用于初始化变量 <code>r</code>。</p> </li></ol> 
<p>根据条件判断，如果 <code>c</code> 小于 3，则将 <code>target</code> 赋值给 <code>r</code>；</p> 
<p>                        否则，判断 <code>desc</code> 是否为 <code>null</code>，如果是，则将 <code>Object.getOwnPropertyDescriptor(target, key)</code> 的返回值赋值给 <code>desc</code>；</p> 
<p>                                                                          否则，将 <code>desc</code> 的值赋给 <code>r</code>。</p> 
<ol><li> <p><span style="color:#fe2c24;"><code><span style="background-color:#f3f3f4;">d</span></code></span>：这是一个未初始化的变量 <code>d</code>。</p> <p>在给定的代码中，变量d的作用是存储Object.getOwnPropertyDescriptor(target, key)的返回值。根据代码逻辑，如果变量c小于3，则将target赋值给变量r；否则，如果desc为null，则通过Object.getOwnPropertyDescriptor(target, key)获取target对象中指定属性的属性描述符，并将其赋值给desc；最后，将d赋值为desc。因此，变量d用于存储获取到的属性描述符。</p> </li></ol> 
<h5><span style="background-color:#6eaad7;">d的作用是不是在满足条件后将d的值赋值给desc?</span></h5> 
<p>是的，变量d的作用是在满足条件后将其值赋给变量desc。根据给出的代码，变量c表示参数的个数，变量r用于存储根据条件判断后的结果。如果参数个数小于3，则将target赋值给r；如果desc为null，则通过Object.getOwnPropertyDescriptor(target, key)获取属性描述符并赋值给desc；否则将desc的值赋给r。最后，如果满足条件，则将d的值赋给desc。</p> 
<h5><span style="background-color:#6eaad7;">问题2： JavaScript 中标点符号的作用</span></h5> 
<p>在JavaScript中，标点符号具有不同的作用和功能。以下是一些常见的标点符号及其作用：</p> 
<ol><li> <p>分号 (;)：用于分隔语句。在JavaScript中，每个语句通常以分号结尾，表示语句的结束。</p> </li><li> <p>逗号 (,)：用于分隔多个表达式或变量。逗号可以用于在一行中同时声明多个变量，或者在函数调用中传递多个参数。</p> </li><li> <p>圆括号 (())：用于控制表达式的优先级和分组。圆括号可以改变表达式的计算顺序，并且在函数调用时用于传递参数。</p> </li><li> <p>方括号 ([])：用于访问数组中的元素。通过在方括号内指定索引值，可以获取或修改数组中特定位置的元素。</p> </li><li> <p>大括号 ({})：用于创建对象字面量和代码块。大括号可以用于定义对象的属性和方法，也可以用于创建代码块，例如if语句、循环等。</p> </li><li> <p>小括号 (())：用于函数定义和调用。小括号可以包裹函数的参数列表，在函数调用时用于传递参数。</p> </li><li> <p>冒号 (:)：用于对象字面量中的属性定义。冒号用于分隔属性名和属性值。</p> </li><li> <p>点号 (.)：用于访问对象的属性和方法。通过对象名后面跟随点号，可以访问对象的属性和调用对象的方法。</p> </li><li> <p>等号 (=)：用于赋值操作。等号将右侧的值赋给左侧的变量或属性。</p> </li><li> <p>加号 (+)：用于数字相加和字符串拼接。加号可以用于对数字进行加法运算，也可以用于将字符串连接起来。</p> </li></ol> 
<h5><span style="background-color:#6eaad7;">一个简单的html的案例，其中使用script和javascript定义的几个变量以及一个三元表达式，其变量值在html中使用{<!-- -->{}}的方式呈现出来</span></h5> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Variable Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Variable Example&lt;/h1&gt;

    &lt;script&gt;
        // 定义变量
        var name = "John";
        var age = 25;
        var isStudent = true;

        // 使用三元表达式判断是否为学生
        var studentStatus = isStudent ? "Yes" : "No";

        // 在HTML中使用{<!-- -->{}}呈现变量的值
        document.write("&lt;p&gt;Name: {<!-- -->{name}}&lt;/p&gt;");
        document.write("&lt;p&gt;Age: {<!-- -->{age}}&lt;/p&gt;");
        document.write("&lt;p&gt;Is Student: {<!-- -->{studentStatus}}&lt;/p&gt;");

        document.write("&lt;p&gt;num1的值为：" + num1 + "&lt;/p&gt;");
        document.write("&lt;p&gt;num2的值为：" + num2 + "&lt;/p&gt;");
        document.write("&lt;p&gt;比较结果为：" + result + "&lt;/p&gt;");    
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h5><span style="background-color:#6eaad7;">document.write</span></h5> 
<p>document.write是JavaScript中的一个方法，它可以将指定的内容直接写入到HTML文档中。通过使用document.write，我们可以在网页加载时动态地向网页添加内容。</p> 
<p>使用document.write的语法如下：</p> 
<pre><code class="language-javascript">document.write(content);</code></pre> 
<p>其中，content是要写入到HTML文档中的内容，可以是文本、HTML标签或JavaScript代码。</p> 
<p>需要注意的是，document.write会在页面加载时直接将内容写入到HTML文档中，如果在页面加载完成后再使用document.write，它会覆盖整个文档。因此，在实际开发中，我们一般会将document.write与其他DOM操作方法结合使用，以实现更灵活的页面内容更新。</p> 
<h5><span style="background-color:#6eaad7;">在HTML中，除了使用</span><code><span style="background-color:#6eaad7;">document.write</span></code><span style="background-color:#6eaad7;">来动态生成内容外，还有其他方式可以展现变量的值。以下是一些常见的展现变量值的方法：</span></h5> 
<p></p> 
<ol><li>使用innerHTML属性：可以通过获取HTML元素的引用，然后使用<code>innerHTML</code>属性将变量的值赋给该元素的内容。例如：</li></ol> 
<pre><code class="language-javascript">var name = "John";
var age = 25;
var isStudent = true;

document.getElementById("name").innerHTML = name;
document.getElementById("age").innerHTML = age;
document.getElementById("studentStatus").innerHTML = isStudent ? "Yes" : "No";</code></pre> 
<p>在HTML中，需要为对应的元素添加id属性，例如：</p> 
<pre><code class="language-html">&lt;p id="name"&gt;&lt;/p&gt;
&lt;p id="age"&gt;&lt;/p&gt;
&lt;p id="studentStatus"&gt;&lt;/p&gt;</code></pre> 
<p>2 使用textContent属性：与innerHTML类似，可以通过获取HTML元素的引用，然后使用<code>textContent</code>属性将变量的值赋给该元素的文本内容。例如：</p> 
<pre><code class="language-javascript">var name = "John";
var age = 25;
var isStudent = true;

document.getElementById("name").textContent = name;
document.getElementById("age").textContent = age;
document.getElementById("studentStatus").textContent = isStudent ? "Yes" : "No";</code></pre> 
<p>在HTML中，需要为对应的元素添加id属性，例如：</p> 
<pre><code class="language-html">&lt;p id="name"&gt;&lt;/p&gt;
&lt;p id="age"&gt;&lt;/p&gt;
&lt;p id="studentStatus"&gt;&lt;/p&gt;</code></pre> 
<p>3 使用模板字符串：可以使用ES6中的模板字符串来动态生成HTML内容，并将变量的值插入到模板字符串中。例如：</p> 
<pre><code class="language-javascript">var name = "John";
var age = 25;
var isStudent = true;

var html = `
    &lt;p&gt;Name: ${name}&lt;/p&gt;
    &lt;p&gt;Age: ${age}&lt;/p&gt;
    &lt;p&gt;Is Student: ${isStudent ? "Yes" : "No"}&lt;/p&gt;
`;

document.getElementById("output").innerHTML = html;</code></pre> 
<p>在HTML中，需要有一个容器元素来展示生成的HTML内容，例如：</p> 
<pre><code class="language-html">&lt;div id="output"&gt;&lt;/div&gt;</code></pre> 
<p>这些方法都可以替代<code>document.write</code>来展现变量的值。选择哪种方法取决于具体的需求和场景。</p> 
<p></p> 
<h4><span style="background-color:#e6b223;">updateNav(currentValue)</span></h4> 
<pre><code class="language-javascript">updateNav(currentValue) {
                var _a;
                if (this.data.navigation)
                    return;
                const $nav = (_a = this.getRelationNodes('./swiper-nav')) === null || _a === void 0 ? void 0 : _a[0];
                if (!$nav)
                    return;
                const { direction, paginationPosition, list } = this.properties;
                $nav.setData({
                    current: currentValue,
                    total: list.length,
                    direction,
                    paginationPosition,
                });
            },</code></pre> 
<p>这段代码是一个函数<code>updateNav(currentValue)</code>的实现。函数的作用是更新导航栏的状态。下面是函数的具体实现逻辑：</p> 
<ol><li>首先，函数会检查是否已经存在导航栏，如果已经存在则直接返回，不进行任何操作。</li><li>接下来，函数会通过<code>this.getRelationNodes('./swiper-nav')</code>方法获取与当前组件关联的<code>swiper-nav</code>组件实例，并将其赋值给变量<code>$nav</code>。</li><li>如果没有找到<code>swiper-nav</code>组件实例，则直接返回，不进行任何操作。</li><li>如果找到了<code>swiper-nav</code>组件实例，则从函数的参数<code>properties</code>中获取<code>direction</code>、<code>paginationPosition</code>和<code>list</code>的值。</li><li>最后，函数会调用<code>$nav.setData()</code>方法更新导航栏的状态，传入的参数包括当前值<code>currentValue</code>、列表长度<code>list.length</code>、方向<code>direction</code>和分页位置<code>paginationPosition</code>。</li></ol> 
<pre><code class="language-javascript">const $nav = (_a = this.getRelationNodes('./swiper-nav')) === null || _a === void 0 ? void 0 : _a[0];</code></pre> 
<p>这段代码是在JavaScript中定义了一个常量<code>$nav</code>，它的值是通过调用<code>getRelationNodes</code>方法获取到的与当前组件关联的<code>swiper-nav</code>节点数组的第一个元素。在这段代码中，还使用了空值合并运算符<code>??</code>来处理可能的空值情况。</p> 
<p>其中<code>$nav</code>是一个变量名，<code>||</code>是逻辑运算符。</p> 
<ol><li> <p><code>$</code>符号的作用： 在JavaScript中，<code>$</code>符号通常被用作函数或变量名的前缀，表示该函数或变量与DOM元素相关联。这种命名约定通常用于标识与DOM操作相关的代码，例如使用jQuery库时，选择器函数通常以<code>$</code>开头。</p> </li><li> <p><code>||</code>逻辑运算符的作用： <code>||</code>是JavaScript中的逻辑或运算符。它用于在两个表达式之间进行逻辑或操作，并返回第一个为真的表达式的值。如果第一个表达式为真，则不会计算第二个表达式。</p> </li><li> <p><a href="https://www.runoob.com/js/js-void.html" rel="nofollow" title="javascript:void(0) 含义 | 菜鸟教程">javascript:void(0) 含义 | 菜鸟教程</a></p> </li></ol> 
<h5><span style="background-color:#6eaad7;">getRelationNodes</span></h5> 
<p><a href="https://blog.csdn.net/qq_40850839/article/details/128008104?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171029821516800180677000%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171029821516800180677000&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128008104-null-null.142%5Ev99%5Epc_search_result_base3&amp;utm_term=getRelationNodes&amp;spm=1018.2226.3001.4187" title="微信小程序关联组件_微信小程序 relations-CSDN博客">微信小程序关联组件_微信小程序 relations-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2753d2e13b06f953bf7d34464284c22e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度剖析：数字经济下人工智能水平的新测算模型数据集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59e1d1a10aa3b5605570744a968dbaa8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于单片机的智能台灯设计1.42</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>