<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>web端攻击类型 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="web端攻击类型" />
<meta property="og:description" content="本文介绍了各种类型的安全攻击和缓解它们的技术。
点击劫持 点击劫持是一种欺骗用户点击链接、按钮等的做法，这与用户认为的不同。例如，这可以用来窃取登录凭据或让用户在不知情的情况下安装恶意软件。（点击劫持有时被称为“用户界面纠正”，尽管这是对“纠正”一词的误用。）
跨站脚本 (XSS) 跨站点脚本 (XSS) 是一种安全漏洞，允许攻击者将恶意客户端代码注入网站。此代码由受害者执行，让攻击者绕过访问控制并冒充用户。根据开放 Web 应用程序安全项目，XSS 是2017 年第七大最常见的 Web 应用程序漏洞。
如果 Web 应用程序没有采用足够的验证或编码，这些攻击就会成功。用户的浏览器无法检测到恶意脚本是不可信的，因此可以访问任何 cookie、会话令牌或其他敏感的站点特定信息，或者让恶意脚本重写HTML内容。
跨站点脚本攻击通常发生在 1) 数据通过不受信任的来源（通常是 Web 请求）进入 Web 应用程序或 2) 动态内容在未经验证的情况下发送给 Web 用户是否存在恶意内容。
恶意内容通常包括JavaScript，但有时也包括 HTML、Flash 或浏览器可以执行的任何其他代码。基于 XSS 的攻击种类几乎是无限的，但它们通常包括向攻击者传输 cookie 或其他会话信息等私有数据，将受害者重定向到攻击者控制的网页，或在用户机器上执行其他恶意操作。伪装易受攻击的网站。
XSS 攻击可以分为三类：存储（也称为持久）、反射（也称为非持久）或基于 DOM。
存储型 XSS 攻击
注入的脚本永久存储在目标服务器上。然后，当浏览器发送数据请求时，受害者会从服务器检索此恶意脚本。
反射型 XSS 攻击
当用户被诱骗点击恶意链接、提交特制表单或浏览恶意网站时，注入的代码会传播到易受攻击的网站。Web 服务器将注入的脚本反射回用户的浏览器，例如在错误消息、搜索结果或任何其他响应中，其中包括作为请求的一部分发送到服务器的数据。浏览器执行代码是因为它假定响应来自用户已经与之交互的“可信”服务器。
基于 DOM 的 XSS 攻击
由于修改了原始客户端脚本使用的 DOM 环境（在受害者的浏览器中），payload 被执行。即页面本身并没有改变，但是页面中包含的客户端代码却因为对DOM环境的恶意修改而以意想不到的方式运行。
跨站请求伪造 (CSRF) CSRF（有时也称为 XSRF）是一类相关的攻击。攻击者使用户的浏览器在未经用户同意或不知情的情况下向网站后端执行请求。攻击者可以使用 XSS 载荷来发起 CSRF 攻击。
维基百科提到了 CSRF 的一个很好的例子。在这种情况下，某人包含的图片并非真正的图片（例如在未经过滤的聊天或论坛中），而是向您的银行服务器发出的取款请求：
&lt;img src=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/01ac18722cdfe18f7259124762f59b24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-12T00:03:53+08:00" />
<meta property="article:modified_time" content="2022-04-12T00:03:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">web端攻击类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文介绍了各种类型的安全攻击和缓解它们的技术。</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#click-jacking" rel="nofollow" title="点击劫持">点击劫持</a></h4> 
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Clickjacking" rel="nofollow" title="点击劫持">点击劫持</a>是一种欺骗用户点击链接、按钮等的做法，这与用户认为的不同。例如，这可以用来窃取登录凭据或让用户在不知情的情况下安装恶意软件。（点击劫持有时被称为“用户界面纠正”，尽管这是对“纠正”一词的误用。）</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#cross-site_scripting_xss" rel="nofollow" title="跨站脚本 (XSS)">跨站脚本 (XSS)</a></h4> 
<p>跨站点脚本 (XSS) 是一种安全漏洞，允许攻击者将恶意客户端代码注入网站。此代码由受害者执行，让攻击者绕过访问控制并冒充用户。根据开放 Web 应用程序安全项目，XSS 是2017 年<a href="https://owasp.org/www-project-top-ten/2017/Top_10" rel="nofollow" title="第七大最常见的 Web 应用程序漏洞">第七大最常见的 Web 应用程序漏洞</a>。</p> 
<p>如果 Web 应用程序没有采用足够的验证或编码，这些攻击就会成功。用户的浏览器无法检测到恶意脚本是不可信的，因此可以访问任何 cookie、会话令牌或其他敏感的站点特定信息，或者让恶意脚本重写<a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML" rel="nofollow" title="HTML">HTML</a>内容。</p> 
<p>跨站点脚本攻击通常发生在 1) 数据通过不受信任的来源（通常是 Web 请求）进入 Web 应用程序或 2) 动态内容在未经验证的情况下发送给 Web 用户是否存在恶意内容。</p> 
<p>恶意内容通常包括<a href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript" rel="nofollow" title="JavaScript">JavaScript</a>，但有时也包括 HTML、Flash 或浏览器可以执行的任何其他代码。基于 XSS 的攻击种类几乎是无限的，但它们通常包括向攻击者传输 cookie 或其他会话信息等私有数据，将受害者重定向到攻击者控制的网页，或在用户机器上执行其他恶意操作。伪装易受攻击的网站。</p> 
<p>XSS 攻击可以分为三类：存储（也称为持久）、反射（也称为非持久）或基于 DOM。</p> 
<ul><li> <p>存储型 XSS 攻击</p> <p>注入的脚本永久存储在目标服务器上。然后，当浏览器发送数据请求时，受害者会从服务器检索此恶意脚本。</p> </li><li> <p>反射型 XSS 攻击</p> <p>当用户被诱骗点击恶意链接、提交特制表单或浏览恶意网站时，注入的代码会传播到易受攻击的网站。Web 服务器将注入的脚本反射回用户的浏览器，例如在错误消息、搜索结果或任何其他响应中，其中包括作为请求的一部分发送到服务器的数据。浏览器执行代码是因为它假定响应来自用户已经与之交互的“可信”服务器。</p> </li><li> <p>基于 DOM 的 XSS 攻击</p> <p>由于修改了原始客户端脚本使用的 DOM 环境（在受害者的浏览器中），payload 被执行。即页面本身并没有改变，但是页面中包含的客户端代码却因为对DOM环境的恶意修改而以意想不到的方式运行。</p> </li></ul> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#cross-site_request_forgery_csrf" rel="nofollow" title="跨站请求伪造 (CSRF)">跨站请求伪造 (CSRF)</a></h4> 
<p>CSRF（有时也称为 XSRF）是一类相关的攻击。攻击者使用户的浏览器在未经用户同意或不知情的情况下向网站后端执行请求。攻击者可以使用 XSS 载荷来发起 CSRF 攻击。</p> 
<p>维基百科提到了 CSRF 的一个很好的例子。在这种情况下，某人包含的图片并非真正的图片（例如在未经过滤的聊天或论坛中），而是向您的银行服务器发出的取款请求：</p> 
<pre><code class="language-html">&lt;img src="https://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory"&gt;</code></pre> 
<p>复制到剪贴板</p> 
<p>现在，如果您登录到您的银行帐户并且您的 cookie 仍然有效（并且没有其他验证），您将在加载包含此图像的 HTML 后立即转账。对于需要 POST 请求的端点，可以在页面加载时以编程方式触发 &lt;form&gt; 提交（可能在不可见的 &lt;iframe&gt; 中）：</p> 
<pre><code class="language-html">&lt;form action="https://bank.example.com/withdraw" method="POST"&gt;
  &lt;input type="hidden" name="account" value="bob"&gt;
  &lt;input type="hidden" name="amount" value="1000000"&gt;
  &lt;input type="hidden" name="for" value="mallory"&gt;
&lt;/form&gt;
&lt;script&gt;window.addEventListener('DOMContentLoaded', (e) =&gt; { document.querySelector('form').submit(); }&lt;/script&gt;</code></pre> 
<p>复制到剪贴板</p> 
<p>应该使用一些技术来防止这种情况发生：</p> 
<ul><li> <p>GET 端点应该是幂等的——执行更改但不检索数据的操作应该需要发送 POST（或其他 HTTP 方法）请求。POST 端点不应互换地接受带有查询字符串中的参数的 GET 请求。</p> </li><li> <p>CSRF 令牌应该通过隐藏的输入字段包含在 &lt;form&gt; 元素中。此令牌对于每个用户应该是唯一的并存储（例如，在 cookie 中），以便服务器可以在发送请求时查找预期值。对于所有可能执行操作的非 GET 请求，应将此输入字段与预期值进行比较。如果不匹配，则应中止请求。</p> </li><li> <p>这种保护方法依赖于攻击者无法预测用户分配的 CSRF 令牌。应在登录时重新生成令牌。</p> </li><li> <p>用于敏感操作（例如会话 cookie）的 cookie 的生命周期应该很短，并且 SameSite 属性设置为 Strict 或 Lax。（请参阅上面的 SameSite cookie）。在支持浏览器的情况下，这将具有确保会话 cookie 不与跨站点请求一起发送的效果，因此该请求实际上是未经身份验证的应用程序服务器。</p> </li><li> <p>应该部署 CSRF 令牌和 SameSite cookie。这可确保所有浏览器都受到保护，并在 SameSite cookie 无法提供帮助的情况下提供保护（例如来自单独子域的攻击）。</p> </li></ul> 
<p>有关更多预防提示，请参阅 OWASP CSRF 预防备忘单。</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#man-in-the-middle_mitm" rel="nofollow" title="中间人（MitM）">中间人（MitM）</a></h4> 
<p>第三方拦截 Web 服务器和客户端（浏览器）之间的流量，并冒充 Web 服务器以捕获数据（例如登录凭据或信用卡信息）。交通通过，可能有改动。开放 WiFi 网络是执行这种攻击的典型手段。</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_hijacking" rel="nofollow" title="会话劫持">会话劫持</a></h4> 
<p>会话劫持包括访问和滥用用户的已验证会话。这可能通过窃取现有会话的 cookie 或通过欺骗用户（或他们的浏览器）设置具有预定会话 ID 的 cookie 来发生。</p> 
<p>可以通过部署严格的内容安全策略来限制渗透途径。</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation" rel="nofollow" title="会话固定">会话固定</a></h4> 
<p>第三方能够确定用户的会话标识符（即，通过读取或设置它），因此作为该用户与服务器交互。窃取 cookie 是一种方法。</p> 
<p>回想一下，诸如 application.example.com 之类的子域可以通过设置<code>Domain</code>属性来设置一个 cookie，以便与请求一起发送到 example.com 或其他子域：</p> 
<pre><code>Set-Cookie: CSRF=e8b667; Secure; Domain=example.com</code></pre> 
<p>如果子域上存在易受攻击的应用程序，则此机制可能会在会话固定攻击中被滥用。当用户访问父域（或另一个子域）上的页面时，应用程序可能会信任用户 cookie 中发送的现有值。这可能允许攻击者绕过 CSRF 保护或在用户登录后劫持会话。或者，如果父域不使用HTTP <a href="https://developer.mozilla.org/en-US/docs/Glossary/HSTS" rel="nofollow" title="Strict-Transport-">Strict-Transport-</a><code>includeSubdomains</code> Security WiFi 网络）可以从不存在的子域获得带有 Set-Cookie 标头的响应。最终结果将大致相同，浏览器存储非法 cookie 并将其发送到 example.com 下的所有其他页面。</p> 
<p>会话固定应该主要通过在用户进行身份验证时重新生成会话 cookie 值（即使 cookie 已经存在）以及通过将任何 CSRF 令牌绑定到用户来减轻。</p> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_side-jacking" rel="nofollow" title="会话侧推">会话侧推</a></h4> 
<h4><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#browser_hijacking_malware" rel="nofollow" title="浏览器劫持恶意软件">浏览器劫持恶意软件</a></h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39c5574d5fe91d2ce838c1ace48b19e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2-蛇形矩阵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11a2502a0dd8f1b7cdb0c9d565e9b74b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 服务器突然连接不上</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>