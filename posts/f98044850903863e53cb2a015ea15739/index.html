<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>虚拟化与docker基础 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="虚拟化与docker基础" />
<meta property="og:description" content="文章目录 一、虚拟化1.虚拟化概述2、虚拟化的功能3、虚拟化的三种模式4、容器与虚拟化 二、Docker1、容器概述2、Docker概述3、Docker的设计宗旨4、容器与虚拟机的区别5、容器在内核中支持两种重要的技术6、Docker核心概念 三、安装Docker1、环境准备2、安装依赖包3、设置阿里云镜像源4、安装Docker-CE并设置为开机自动启动 四、docker镜像操作1、查看版本信息和详细内容2、搜索镜像3、获取镜像4、镜像加速下载5、查看镜像信息6、查看镜像列表7、获取镜像信息8、为镜像添加新标签9、删除镜像10、存出镜像，将镜像保存成为本地文件11、载入镜像，将镜像文件重新导入镜像库中12、上传镜像 一、虚拟化 1.虚拟化概述 什么是虚拟化？
虚拟化：将应用程序和系统内核资源进行解耦，以操作系统级别进行隔离，目的是提高资源利用率
CPU的时间分片
2、虚拟化的功能 将虚拟化的性能优化趋近于物理资源的性能，主要用于提高资源利用率
①在一个操作系统内,模拟多个操作系统
②以软件的方式模拟物理设备的功能
3、虚拟化的三种模式 1、全虚拟化(50%)
2、 半虚拟化(软、硬件结合的方式)
3、直通(以全硬件的方式，实现虚拟化的功能)
6大名称空间
mount文件系统，挂载点（一个文件系统内，不能重复挂载一个指定目录，例如: /mnt）user操作进程的用户和用户组pid进程编号uts主机名和主机域ipc信号量、消息队列，共享内存(理解，不同的应用调用内存资源的时候应该使用不同的内存空间)net网络设备、网络协议栈、端口等 4、容器与虚拟化 容器:
特性：性能损耗10-20%之间
容器基础概念就是名称空间
名称空间:
是 Linux 内核的一个强大特性，为容器虚拟化的实现带来极大便利，利用这特性，每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样 命名 间机制保证了容器之间彼此互不影响。
容器小的架构系统
其中nginx 吃一些CPU内存资源，吃一些操作系统所需要的文件系统资源
/usr/local/
容器:
bootfs是轻量级的操作文件系统centos，它300- 500M就够了
内核自带的rootfs提供的
二、Docker 1、容器概述 以linux而言，linux操作系统会有一个主进程pid=1派生出其他进程来控制不同服务
例如:
pid=2 ——&gt; python pid=3——&gt;java pid4——&gt;php，三个服务可能会相互影响
使用者期望将这三个不同的服务，跑在不同的运行时环境中实现相互不影响，同时不会增加服务器成本
同时延伸出能否将这三种服务分别封装起来这就需要KVM虚拟化技术，实现了一个操作系统模拟多个操作系统/不同的运行时环境
随着技术发展虚拟化技术开销较大(例如:只要运行一个py脚本，想要使用虚拟化方式实现，还需要安装一个操作系统，并不方便/合理)
延伸出容器技术
虚拟化层的抽象层(用户层)剥离，使用docker engine来替代(来宾操作系统去除)，只要通过引擎就可以直接连接到宿主机操作系统中，极大减小了开销。
2、Docker概述 1、Docker是一个开源的应用容器引擎，基于go语言开发并遵循apache2.0协议开源
2、Docker是在Linux容器里运行应用的开源工具，是一种轻量级的“虚拟机”
3、Docker的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的、可移植的、自给自足的容器，也可以利用docker在多台主机上轻松的创建并运行容器
3、Docker的设计宗旨 Build，Ship and Run Any App Anywhere
通过对应用组件的封装、发布、部署、运行等生命周期的管理，达到应用组件级别的“一次封装，到处运行”的目的。这里的组件，既可以是一个应用，也可以是一套服务，甚至是一个完整的操作系统。
4、容器与虚拟机的区别 容器是在Linux上本机运行，并与其他容器共享主机的内核，它运行的是一个独立的进程，不占其他任何可执行文件的内存，非常轻量。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f98044850903863e53cb2a015ea15739/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-10T18:30:02+08:00" />
<meta property="article:modified_time" content="2022-01-10T18:30:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">虚拟化与docker基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、虚拟化</a></li><li><ul><li><a href="#1_3" rel="nofollow">1.虚拟化概述</a></li><li><a href="#2_13" rel="nofollow">2、虚拟化的功能</a></li><li><a href="#3_20" rel="nofollow">3、虚拟化的三种模式</a></li><li><a href="#4_38" rel="nofollow">4、容器与虚拟化</a></li></ul> 
  </li><li><a href="#Docker_59" rel="nofollow">二、Docker</a></li><li><ul><li><a href="#1_61" rel="nofollow">1、容器概述</a></li><li><a href="#2Docker_78" rel="nofollow">2、Docker概述</a></li><li><a href="#3Docker_86" rel="nofollow">3、Docker的设计宗旨</a></li><li><a href="#4_92" rel="nofollow">4、容器与虚拟机的区别</a></li><li><a href="#5_112" rel="nofollow">5、容器在内核中支持两种重要的技术</a></li><li><a href="#6Docker_117" rel="nofollow">6、Docker核心概念</a></li></ul> 
  </li><li><a href="#Docker_139" rel="nofollow">三、安装Docker</a></li><li><ul><li><a href="#1_141" rel="nofollow">1、环境准备</a></li><li><a href="#2_150" rel="nofollow">2、安装依赖包</a></li><li><a href="#3_164" rel="nofollow">3、设置阿里云镜像源</a></li><li><a href="#4DockerCE_174" rel="nofollow">4、安装Docker-CE并设置为开机自动启动</a></li></ul> 
  </li><li><a href="#docker_187" rel="nofollow">四、docker镜像操作</a></li><li><ul><li><a href="#1_189" rel="nofollow">1、查看版本信息和详细内容</a></li><li><a href="#2_202" rel="nofollow">2、搜索镜像</a></li><li><a href="#3_213" rel="nofollow">3、获取镜像</a></li><li><a href="#4_225" rel="nofollow">4、镜像加速下载</a></li><li><a href="#5_244" rel="nofollow">5、查看镜像信息</a></li><li><a href="#6_254" rel="nofollow">6、查看镜像列表</a></li><li><a href="#7_265" rel="nofollow">7、获取镜像信息</a></li><li><a href="#8_276" rel="nofollow">8、为镜像添加新标签</a></li><li><a href="#9_286" rel="nofollow">9、删除镜像</a></li><li><a href="#10_297" rel="nofollow">10、存出镜像，将镜像保存成为本地文件</a></li><li><a href="#11_307" rel="nofollow">11、载入镜像，将镜像文件重新导入镜像库中</a></li><li><a href="#12_317" rel="nofollow">12、上传镜像</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、虚拟化</h2> 
<h3><a id="1_3"></a>1.虚拟化概述</h3> 
<p><strong>什么是虚拟化？</strong></p> 
<p>虚拟化：将应用程序和系统内核资源进行解耦，以操作系统级别进行隔离，目的是提高资源利用率</p> 
<p><strong>CPU的时间分片</strong></p> 
<p><img src="https://images2.imgbox.com/71/e7/VE6ZZaUC_o.png" alt=""></p> 
<h3><a id="2_13"></a>2、虚拟化的功能</h3> 
<p>将虚拟化的性能优化趋近于物理资源的性能，主要用于提高资源利用率</p> 
<p>①在一个操作系统内,模拟多个操作系统<br> ②以软件的方式模拟物理设备的功能</p> 
<h3><a id="3_20"></a>3、虚拟化的三种模式</h3> 
<p>1、全虚拟化(50%)<br> 2、 半虚拟化(软、硬件结合的方式)<br> 3、直通(以全硬件的方式，实现虚拟化的功能)</p> 
<p><img src="https://images2.imgbox.com/dd/e8/BychDFBZ_o.png" alt=""></p> 
<p><strong>6大名称空间</strong></p> 
<table><thead><tr><th>mount</th><th>文件系统，挂载点（一个文件系统内，不能重复挂载一个指定目录，例如: /mnt）</th></tr></thead><tbody><tr><td>user</td><td>操作进程的用户和用户组</td></tr><tr><td>pid</td><td>进程编号</td></tr><tr><td>uts</td><td>主机名和主机域</td></tr><tr><td>ipc</td><td>信号量、消息队列，共享内存(理解，不同的应用调用内存资源的时候应该使用不同的内存空间)</td></tr><tr><td>net</td><td>网络设备、网络协议栈、端口等</td></tr></tbody></table> 
<h3><a id="4_38"></a>4、容器与虚拟化</h3> 
<p><img src="https://images2.imgbox.com/25/a0/KXbcVEYE_o.png" alt=""></p> 
<p><strong>容器:</strong><br> 特性：性能损耗10-20%之间<br> 容器基础概念就是名称空间<br> <strong>名称空间:</strong></p> 
<p>是 Linux 内核的一个强大特性，为容器虚拟化的实现带来极大便利，利用这特性，每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样 命名 间机制保证了容器之间彼此互不影响。</p> 
<p>容器小的架构系统</p> 
<p>其中nginx 吃一些CPU内存资源，吃一些操作系统所需要的文件系统资源<br> /usr/local/<br> 容器:<br> bootfs是轻量级的操作文件系统centos，它300- 500M就够了<br> 内核自带的rootfs提供的</p> 
<h2><a id="Docker_59"></a>二、Docker</h2> 
<h3><a id="1_61"></a>1、容器概述</h3> 
<p>以linux而言，linux操作系统会有一个主进程pid=1派生出其他进程来控制不同服务</p> 
<p>例如:</p> 
<p>pid=2 ——&gt; python pid=3——&gt;java pid4——&gt;php，三个服务可能会相互影响</p> 
<p>使用者期望将这三个不同的服务，跑在不同的运行时环境中实现相互不影响，同时不会增加服务器成本<br> 同时延伸出能否将这三种服务分别封装起来这就需要KVM虚拟化技术，实现了一个操作系统模拟多个操作系统/不同的运行时环境</p> 
<p>随着技术发展虚拟化技术开销较大(例如:只要运行一个py脚本，想要使用虚拟化方式实现，还需要安装一个操作系统，并不方便/合理)</p> 
<p><strong>延伸出容器技术</strong></p> 
<p>虚拟化层的抽象层(用户层)剥离，使用docker engine来替代(来宾操作系统去除)，只要通过引擎就可以直接连接到宿主机操作系统中，极大减小了开销。</p> 
<h3><a id="2Docker_78"></a>2、Docker概述</h3> 
<p><img src="https://images2.imgbox.com/48/df/65PSsMtZ_o.png" alt="">1、Docker是一个开源的应用容器引擎，基于go语言开发并遵循apache2.0协议开源<br> 2、Docker是在Linux容器里运行应用的开源工具，是一种轻量级的“虚拟机”<br> 3、Docker的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的、可移植的、自给自足的容器，也可以利用docker在多台主机上轻松的创建并运行容器</p> 
<h3><a id="3Docker_86"></a>3、Docker的设计宗旨</h3> 
<p>Build，Ship and Run Any App Anywhere</p> 
<p>通过对应用组件的封装、发布、部署、运行等生命周期的管理，达到应用组件级别的“一次封装，到处运行”的目的。这里的组件，既可以是一个应用，也可以是一套服务，甚至是一个完整的操作系统。</p> 
<h3><a id="4_92"></a>4、容器与虚拟机的区别</h3> 
<p>容器是在Linux上本机运行，并与其他容器共享主机的内核，它运行的是一个独立的进程，不占其他任何可执行文件的内存，非常轻量。</p> 
<p>虚拟机运行的是一个完整的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。</p> 
<table><thead><tr><th>特性</th><th>Docker容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>计算能力损耗</td><td>几乎无</td><td>损耗50%左右</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量（单机）</td><td>上千个（根据业务大小而定，一般在200多个左右）</td><td>几十个</td></tr><tr><td>操作系统</td><td>主要支持Linux</td><td>几乎所有</td></tr><tr><td>隔离性</td><td>进程级别，资源隔离/限制</td><td>系统级别，完全隔离</td></tr><tr><td>部署难度</td><td>非常简单</td><td>组件多，部署复杂</td></tr><tr><td>执行性能</td><td>和物理系统几乎一致</td><td>vm会占用一些资源</td></tr><tr><td>镜像体积</td><td>镜像MB级别</td><td>镜像GB级别</td></tr><tr><td>管理效率</td><td>简单</td><td>组件相互依赖，管理复杂</td></tr><tr><td>网络连接</td><td>比较弱</td><td>借助neutron可以灵活组件各类网络管理</td></tr></tbody></table> 
<h3><a id="5_112"></a>5、容器在内核中支持两种重要的技术</h3> 
<p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写实复制技术（copy-on-write）实现了高效的文件系统（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p> 
<h3><a id="6Docker_117"></a>6、Docker核心概念</h3> 
<p>（1）镜像</p> 
<p>Docker的镜像是创建容器的基础，类似虚拟机的快照，可以理解为一个面向Docker容器引擎的只读模板。</p> 
<p>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码、运行时间、库、环境变量、和配置文件。</p> 
<p>Docker镜像也是一个压缩包，只是这个压缩包不只是可执行文件，环境部署脚本，它还包含了完整的操作系统。因为大部分的镜像都是基于操作系统来构建，所以很轻松的就可以构建本地和远端一样的环境，这也是Docker镜像的精髓</p> 
<p>（2）容器</p> 
<p>Docker的容器是从镜像创建的运行实例，他可以被启动、停止和删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性</p> 
<p>可以把容器看做是一个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。</p> 
<p>（3）仓库</p> 
<p>Docker仓库是用来集中保存镜像的地方，当创建了自己的镜像之后，可以使用push命令将它上传到公有仓库（pubile）或者私有仓库（private）。当下次要在另外一台机器上使用这个镜像时，只需从仓库获取</p> 
<p>注：Docker的镜像、容器、日志等内容全部都默认存储在 /var/lib/docker/目录下</p> 
<h2><a id="Docker_139"></a>三、安装Docker</h2> 
<h3><a id="1_141"></a>1、环境准备</h3> 
<pre><code>systemctl stop firewalld
setenforce 0
</code></pre> 
<p><img src="https://images2.imgbox.com/cb/78/bW4jfMzT_o.png" alt="img"></p> 
<h3><a id="2_150"></a>2、安装依赖包</h3> 
<pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2
-------------------------------------------------------
1.yum-utils:提供了yum-config-manager工具
2.device mapper:是Linux内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构
3.device mapper存储驱动程序需要device-mapper-persistent-data和lvm2
</code></pre> 
<p><img src="https://images2.imgbox.com/de/10/5z4O4zQb_o.png" alt="img"></p> 
<h3><a id="3_164"></a>3、设置阿里云镜像源</h3> 
<pre><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<p><img src="https://images2.imgbox.com/13/b6/oj5wuZay_o.png" alt="img"></p> 
<h3><a id="4DockerCE_174"></a>4、安装Docker-CE并设置为开机自动启动</h3> 
<pre><code>yum install -y docker-ce docker-ce-cli containerd.io
 
systemctl start docker.service
systemctl enable docker.service
</code></pre> 
<p><img src="https://images2.imgbox.com/27/1c/nJZvrFzE_o.png" alt="img"></p> 
<h2><a id="docker_187"></a>四、docker镜像操作</h2> 
<h3><a id="1_189"></a>1、查看版本信息和详细内容</h3> 
<pre><code>docker version
docker info
</code></pre> 
<p><img src="https://images2.imgbox.com/79/c8/qD8i2gF6_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/05/c0/4oSPHTU9_o.png" alt="img"></p> 
<h3><a id="2_202"></a>2、搜索镜像</h3> 
<pre><code>docker search 关键字
docker search nginx
</code></pre> 
<p><img src="https://images2.imgbox.com/24/fb/M0f6Pkoa_o.png" alt="img"></p> 
<h3><a id="3_213"></a>3、获取镜像</h3> 
<pre><code>docker pull 仓库名称[:标签]
#如果下载镜像时不指定标签，则默认会下载仓库中最新版本的镜像，即选择标签为 latest标签
docker pull nginx
</code></pre> 
<p><img src="https://images2.imgbox.com/94/5f/aVoKWRET_o.png" alt="img"></p> 
<h3><a id="4_225"></a>4、镜像加速下载</h3> 
<pre><code>浏览器访问 http://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 获取镜像加速器配置
 
mkdir -p /etc/docker
tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  "registry-mirrors": ["https://jd2yg3cx.mirror.aliyuncs.com"]
}
EOF
systemctl daemon-reload
systemctl restart docker
</code></pre> 
<p><img src="https://images2.imgbox.com/27/4f/WXiJhxDu_o.png" alt="img"></p> 
<h3><a id="5_244"></a>5、查看镜像信息</h3> 
<pre><code>镜像下载后存放在 /var/lib/docker
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/d1/wyk6TvvR_o.png" alt="img"></p> 
<h3><a id="6_254"></a>6、查看镜像列表</h3> 
<pre><code>#查看下载镜像信息列表
docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/8d/82/JI8ABjXT_o.png" alt="img"></p> 
<h3><a id="7_265"></a>7、获取镜像信息</h3> 
<pre><code>docker inspect 镜像id
docker inspect 实例：标签
</code></pre> 
<p><img src="https://images2.imgbox.com/fd/78/05V4bROF_o.png" alt="img"></p> 
<h3><a id="8_276"></a>8、为镜像添加新标签</h3> 
<pre><code>docker tag 仓库名：标签 新仓库名：新标签名
</code></pre> 
<p><img src="https://images2.imgbox.com/3e/a8/bl1GiBnN_o.png" alt="img"></p> 
<h3><a id="9_286"></a>9、删除镜像</h3> 
<pre><code>docker rmi 仓库名：标签   #当一个镜像有多个标签时，只是删除其中指定的标签
docker rmi 镜像id  (-f)      #会彻底删除该镜像，如果该镜像已经被容器使用，正确的做法是先删除依赖该镜像的所有容器，再去删除镜像
</code></pre> 
<p><strong><img src="https://images2.imgbox.com/c2/fa/xMmsgN8t_o.png" alt="img"></strong></p> 
<h3><a id="10_297"></a>10、存出镜像，将镜像保存成为本地文件</h3> 
<pre><code>docker save -o 存储位置/存储文件名 镜像
</code></pre> 
<p><strong><img src="https://images2.imgbox.com/fd/8e/Cw93W5qr_o.png" alt="img"></strong></p> 
<h3><a id="11_307"></a>11、载入镜像，将镜像文件重新导入镜像库中</h3> 
<pre><code>docker load &lt; 存出的文件
docker load -i 存出的文件
</code></pre> 
<p><strong><img src="https://images2.imgbox.com/e1/91/DHPqRwc0_o.png" alt="img"></strong></p> 
<h3><a id="12_317"></a>12、上传镜像</h3> 
<pre><code>默认上传到 docker Hub官方公共仓库，需要注册使用公共仓库的账号https://hub.docker.com
点击使用 docker login 命令来输入用户名、密码和邮箱来完成注册和登录。
在上传镜像之前，还需要先对本地镜像添加新的标签，然后再使用docker push 命令进行上传
 
docker tag nginx:latest jc111/nginx:web           #添加新的标签时必须在前面加上自己的dockerhub的username
docker login                                               #登录公共仓库
Username:账号
password:密码               
docker push jc111/nginx:web                             #上传镜像
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/8b/GdCPtRU6_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/fc/dc/S6A7974e_o.png" alt="img"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85c6c1a88665963a09946ebac293fa17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我理解的前端发展方向</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c274119e8b1925a904214841685cfe50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器被攻击了怎么办</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>