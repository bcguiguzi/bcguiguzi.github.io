<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UmiJS学习 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UmiJS学习" />
<meta property="og:description" content="UmiJS4学习笔记 起步 官网学习：https://umijs.org/
开发环境 Umi.js 需要使用 Node.js来进行开发，因此请先确保电脑已经安装了 Node.js 且版本在 14 以上。 安装pnpm：npm install pnpm -g 创建项目 Umi 官方提供了一个脚手架 ，可以轻松快速创建一个项目：
pnpm dlx create-umi@latest 创建时会进行三个选择：
Pick Umi App Template ? &gt; Simple App	// 普通项目 &gt; Ant Design Pro	// 使用了umi max &gt; Vue Simple App	// vue项目 Pick Npm Client ? &gt; npm &gt; cnpm &gt; tnpm &gt; yarn &gt; pnpm (推荐) Pick Npm Registry ? &gt; npm &gt; taobao (推荐) 选择完成 -&gt; 等待项目创建。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3f83c69fd275c3651bce74c3d78a96a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-10T17:30:14+08:00" />
<meta property="article:modified_time" content="2023-02-10T17:30:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UmiJS学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;">UmiJS4学习笔记</h2> 
 <h3 style="text-align:left;">起步</h3> 
 <p style="">官网学习：<a class="kdocs-link" style="color:#0A6CFF;" href="https://umijs.org/" rel="nofollow noopener noreferrer" target="_blank">https://umijs.org/</a></p> 
 <h4 style="text-align:left;">开发环境</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   Umi.js 需要使用 Node.js来进行开发，因此请先确保电脑已经安装了 Node.js 且版本在 14 以上。 
  <br>安装pnpm：npm install pnpm -g 
 </blockquote> 
 <h4 style="text-align:left;">创建项目</h4> 
 <p style="">Umi 官方提供了一个脚手架 ，可以轻松快速创建一个项目：</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">pnpm dlx create-umi@latest</code></pre> 
 <p style="">创建时会进行三个选择：</p> 
 <pre class="kdocs-json"><code class="language-json">Pick Umi App Template ?
    &gt; Simple App	// 普通项目
    &gt; Ant Design Pro	// 使用了umi max
    &gt; Vue Simple App	// vue项目
Pick Npm Client ?
    &gt; npm
    &gt; cnpm
    &gt; tnpm
    &gt; yarn
    &gt; pnpm (推荐)
Pick Npm Registry ?
    &gt; npm
    &gt; taobao (推荐)</code></pre> 
 <p style="">选择完成 -&gt; 等待项目创建。</p> 
 <h3 style="text-align:left;">路由</h3> 
 <h4 style="text-align:left;">配置路由</h4> 
 <p style="">在<span class="kdocs-bold" style="font-weight:bold;">config/config.ts</span>或者<span class="kdocs-bold" style="font-weight:bold;">umirc.ts</span>中通过<span class="kdocs-bold" style="font-weight:bold;">routes</span>进行配置：</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">export default {
  routes: [
    { path: '/', component: 'index' }, 
    { path: '/user', component: 'user' },
  ],
}</code></pre> 
 <blockquote class="kdocs-blockquote" style="text-align:left;"> 
  <span class="kdocs-bold" style="font-weight:bold;">path</span> 
  <br>只支持两种占位符 
  <br>:id 的形式 
  <br>*通配符，只能出现路由字符串的最后。 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">component</span> 
  <br>用于匹配成功后渲染的 React 组件路径。如果是相对路径，会从 src/pages 开始找起。 
  <br>如果指向 src 目录的文件，可以用 @，也可以用 ../。比如 component: '@/layouts/basic'，或者 component: '../layouts/basic'，推荐用前者。 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">routes</span> 
  <br>export default { routes: [ { path: '/login', component: 'login' }, { path: '/', component: '@/layouts/index', routes: [ // 子路由 { path: '/list', component: 'list' }, { path: '/admin', component: 'admin' }, ], }, ], } 
  <br>通过**&lt;Outlet/ &gt;**进行子路由渲染 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">rediret</span> 
  <br>export default { routes: [ { path: '/', redirect: '/list' }, // 访问 / 会跳转到 /list，并由 src/pages/list 文件进行渲染。 { path: '/list', component: 'list' }, ], } 
  <br>wrappers 
  <br>export default { routes: [ { path: '/user', component: 'user', wrappers: [ '@/wrappers/auth', ], }, { path: '/login', component: 'login' }, ] } 
  <br>然后在 src/wrappers/auth 中， 
  <br>import { Navigate, Outlet } from 'umi' export default (props) =&gt; { const { isLogin } = useAuth(); if (isLogin) { return &lt;Outlet /&gt;; } else{ return &lt;Navigate to="/login" /&gt;; } } 
  <br>title 
  <br>配置路由的标题。 
 </blockquote> 
 <h4 style="text-align:left;">加载组件</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   在项目 src 目录下创建 loading.tsx 或者 loading.jsx 或者 loading.js 文件，默认导出的组件会在组件加载的时候渲染。 
  <br>const Loading:React.FC = () =&gt; { return( &lt;div&gt; &lt;h1&gt;正在加载中。。。&lt;/h1&gt; &lt;/div&gt; ) } export default Loading; 
  <br>可以将开发者模式的网络切换为3G慢速查看效果 
 </blockquote> 
 <h4 style="text-align:left;">路由传参</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   Umi4 使用 react-router@6 作为路由组件，路由参数的获取使其 hooks。（参考react-router@6） 
 </blockquote> 
 <h4 style="text-align:left;">数据加载</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   在路由文件中，除了默认导出的页面组件外，再导出一个 clientLoader 函数，并且在该函数内完成路由数据加载的逻辑。 
  <br>// pages/.../some_page.tsx import { useClientLoaderData } from 'umi'; export default function SomePage() { const data = useClientLoaderData(); return &lt;div&gt;{data}&lt;/div&gt;; } export async function clientLoader() { const data = await fetch('/api/data'); return data; } 
  <br>如上代码，在 clientLoader 函数返回的数据，可以在组件内调用 useClientLoaderData 获取。 
 </blockquote> 
 <h3 style="text-align:left;">Mock</h3> 
 <blockquote class="kdocs-blockquote" style="text-align:left;"> 
  <span class="kdocs-bold" style="font-weight:bold;">Umi 约定 /mock 目录下的所有文件为 Mock 文件</span> 
  <br>Mock 文件默认导出一个对象，而对象的每个 Key 对应了一个 Mock 接口，值则是这个接口所对应的返回数据 
  <br>export default { // 返回值可以是数组形式 'GET /api/users': [ { id: 1, name: 'foo' }, { id: 2, name: 'bar' } ], // 返回值也可以是对象形式 'GET /api/users/1': { id: 1, name: 'foo' }, } 
  <br>自定义函数 
  <br>export default { 'POST /api/users/create': (req, res) =&gt; { // 添加跨域请求头 res.setHeader('Access-Control-Allow-Origin', '*'); res.end('ok'); } } 
  <br>关于 req 和 res 的 API 可参考 Express@4 官方文档 来进一步了解。 
  <br>关闭 Mock 
  <br>Umi 默认开启 Mock 功能，如果不需要的话可以从配置文件关闭： 
  <br>// .umirc.ts export default { mock: false, }; 
  <br>引入 Mock.js 
  <br>生成随机的模拟数据 
  <br>import mockjs from 'mockjs'; export default { // 使用 mockjs 等三方库 'GET /api/tags': mockjs.mock({ 'list|100': [{ name: '@city', 'value|1-100': 50, 'type|0-2': 1 }], }), }; 
 </blockquote> 
 <h3 style="text-align:left;">代理</h3> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   只需在配置文件中加上以下代码： 
  <br>proxy: { '/api': { 'target': ' 
  <a class="kdocs-link" style="color:#0A6CFF;" href="http://jsonplaceholder.typicode.com/'%20rel=" target="_blank" rel="noopener noreferrer">http://jsonplaceholder.typicode.com/',</a>proxy: { '/api': { 'target': 'http://jsonplaceholder.typicode.com/', 'changeOrigin': true, 'pathRewrite': { '^/api' : '' }, }, }, 
  <br>将 /api 前缀的请求，代理到 
  <a class="kdocs-link" style="color:#0A6CFF;" href="http://jsonplaceholder.typicode.com/" rel="nofollow noopener noreferrer" target="_blank">http://jsonplaceholder.typicode.com/</a> 
  <br>将请求来源修改为目标url 
  <br>替换请求地址中的 /api 为 '' 
  <br>▲ proxy 暂时只能解开发时（dev）的跨域访问问题，生产上的发生跨域问题的话，可以将类似的配置转移到 Nginx 容器上。 
 </blockquote> 
 <h3 style="text-align:left;">样式</h3> 
 <h4 style="text-align:left;">CSS Modules</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   在 js 文件中引入样式时，如果赋予他一个变量名，就可以将样式以 CSS Module 的形式引入。 
  <br>import styles from './index.css'; export default function () { return &lt;div className={styles.title}&gt; Hello World &lt;/div&gt;; } 
 </blockquote> 
 <h3 style="text-align:left;">微生成器</h3> 
 <h4 style="text-align:left;">使用</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   下面的命令会列出目前所有可用的生成器，可以通过交互式方式来选择你使用的功能，都有详细的提示。 
  <br>$ umi generate # 或者 $ umi g 
  <br>你也可以通过 umi g &lt;generatorName&gt; 的形式来使用对应的生成器。 
 </blockquote> 
 <h4 style="text-align:left;">生成器列表</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   参考官方文档： 
  <a class="kdocs-link" style="color:#0A6CFF;" href="https://umijs.org/docs/guides/generator" rel="nofollow noopener noreferrer" target="_blank">https://umijs.org/docs/guides/generator</a> 
 </blockquote> 
 <h3 style="text-align:left;">数据流</h3> 
 <h4 style="text-align:left;">model</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   这里以一个计数器为例 
  <br>创建model 
  <br>// src/models/counter.ts import { useState } from "react" export default () =&gt; { const [num, setNum] = useState(0); const increment = (num: number) =&gt; { setNum(num + 1); } const decrement = (num: number) =&gt; { setNum(num - 1); } return { num, increment, decrement } } 
  <br>使用model 
  <br>const Children01: React.FC = () =&gt; { const { num, increment, decrement } = useModel('counter'); return ( &lt;h1&gt;计数器model&lt;/h1&gt; &lt;h2&gt;这是结果：{num}&lt;/h2&gt; &lt;button onClick={() =&gt; { increment(num) }}&gt;+1&lt;/button&gt; &lt;button onClick={() =&gt; { decrement(num) }}&gt;-1&lt;/button&gt; &lt;hr /&gt; ) } 
  <br>这就是一个 Model。插件所做的工作就是将其中的状态或数据变成了 
  <span class="kdocs-bold" style="font-weight:bold;">全局数据</span>，不同的组件在使用该 Model 时，拿到的是同一份状态或数据。 
  <br>性能优化 
  <br>useModel() 方法可以接受可选的第二个参数，当组件只需要使用 Model 中的部分参数，而对其它参数的变化不感兴趣时，可以传入一个函数进行过滤。 
  <br>const { add, minus } = useModel('counterModel', (model) =&gt; ({ add: model.increment, minus: model.decrement, })); 
 </blockquote> 
 <h4 style="text-align:left;">全局初始状态</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   全局初始状态在整个 Umi 项目的最开始创建。 
  <br>编写 src/app.ts 的导出方法 getInitialState()，其返回值将成为全局初始状态。 
  <br>// src/app.ts import { fetchInitialData } from '@/services/initial'; export async function getInitialState() { const initialData = await fetchInitialData(); return initialData; } 
  <br>现在，各种插件和您定义的组件都可以通过 useModel('@@initialState') 直接获取到这份全局的初始状态 
  <br>import { useModel } from 'umi'; export default () =&gt; { const { initialState, loading, error, refresh, setInitialState } = useModel('@@initialState'); return &lt;&gt;{initialState}&lt;/&gt;; }; 
  <br> 
 </blockquote> 
 <h3 style="text-align:left;">请求</h3> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   request 
  <br>request 接收的 options除了透传 
  <a class="kdocs-link" style="color:#0A6CFF;" href="https://axios-http.com/docs/req_config" rel="nofollow noopener noreferrer" target="_blank">axios</a> 的所有 config 之外， 
  <br>我们还额外添加了几个属性 skipErrorHandler，getResponse，requestInterceptors 和 responseInterceptors 。 
  <br>request('/api/user', { params: { name : 1 }, timeout: 2000, // other axios options skipErrorHandler: true, getResponse: false, requestInterceptors: [], responseInterceptors: [], } 
  <br>useRequest 
  <br>插件内置了 
  <a class="kdocs-link" style="color:#0A6CFF;" href="https://ahooks-v2.js.org/hooks/async" rel="nofollow noopener noreferrer" target="_blank">@ahooksjs/useRequest</a> ，你可以在组件内通过该 Hook 简单便捷的消费数据。 
  <br>import { useRequest } from 'umi'; export default () =&gt; { const { data, error, loading } = useRequest(() =&gt; { return services.getUserList('/api/test'); }); if (loading) { return &lt;div&gt;loading...&lt;/div&gt;; } if (error) { return &lt;div&gt;{error.message}&lt;/div&gt;; } return &lt;div&gt;{data.name}&lt;/div&gt;; }; 
  <br>request配置 
  <br>在 src/app.ts 中你可以通过配置 request 项，来为你的项目进行统一的个性化的请求设定。 
  <br>import type { RequestConfig } from 'umi'; export const request: RequestConfig = { timeout: 1000, // other axios options you want errorConfig: { errorHandler(){ }, errorThrower(){ } }, requestInterceptors: [], responseInterceptors: [] }; 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">在这里配置的规则将应用于所有的</span> request 和 useRequest 
  <span class="kdocs-bold" style="font-weight:bold;">方法</span>。 
  <br>errorConfig 
  <br>接收你后端返回的数据并且需要抛出一个你自己设定的 error， 你可以在这里根据后端的数据进行一定的处理。 
  <br>request 会 catch errorThrower 抛出的错误，并且执行你的 errorHandler 方法， 
  <br>该方法接收两个参数，第一个参数是 catch 到的 error，第二个参数则是 request 的 opts。 
  <br>requestInterceptors 
  <br>为 request 方法添加请求阶段的拦截器。 
  <br>传入一个数组，每个元素都是一个拦截器。 
  <br>const request: RequestConfig = { requestInterceptors: [ // 直接写一个 function，作为拦截器 (url, options) =&gt; { // do something return { url, options } }, // 一个二元组，第一个元素是 request 拦截器，第二个元素是错误处理 [(url, options) =&gt; {return { url, options }}, (error) =&gt; {return Promise.reject(error)}], // 数组，省略错误处理 [(url, options) =&gt; {return { url, options }}] ] } 
  <br>responseInterceptors 
  <br>为 request 方法添加响应阶段的拦截器。 
  <br>传入一个数组，每个元素都是一个拦截器。 
  <br>const request: RequestConfig = { responseInterceptors: [ // 直接写一个 function，作为拦截器 (response) =&gt; { // 不再需要异步处理读取返回体内容，可直接在data中读出，部分字段可在 config 中找到 const { data = {} as any, config } = response; // do something return response }, // 一个二元组，第一个元素是 request 拦截器，第二个元素是错误处理 [(response) =&gt; {return response}, (error) =&gt; {return Promise.reject(error)}], // 数组，省略错误处理 [(response) =&gt; {return response}] ] } 
 </blockquote> 
 <h3 style="text-align:left;">dva</h3> 
 <h4 style="text-align:left;">配置dva</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   首先你需要在umirc.ts里配置 dva: {} 打开 Umi 内置的 dva 插件。 
 </blockquote> 
 <h4 style="text-align:left;">添加model</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   model 的写法参考如下示例： 
  <br>export default { state: { user: { name: 'zhangsan' }, }, effects: { *setName({ payload }: any, { call, put }: any) { console.log('异步访问') yield put({ type: 'update', payload: payload }) } }, reducers: { update(state: any, action: any) { return { ...state, ...action.payload } }, test(state: any) { console.log('test'); return state; }, }， } 
 </blockquote> 
 <h4 style="text-align:left;">connect</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;"> 
  <span class="kdocs-bold" style="font-weight:bold;">把组件和 model connect 在一起，并在组件中 dispatch 事件</span> 
  <br>const Children03 = (props: any) =&gt; { return ( &lt;div&gt; &lt;h1&gt;获取state&lt;/h1&gt; &lt;h2&gt;{props.user.user.name}&lt;/h2&gt; &lt;button onClick={() =&gt; { props.dispatch({ type: 'user/update', payload: { user: { name: 'lisi' } } }) }}&gt;修改name·同步&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button onClick={() =&gt; { props.dispatch({ type: 'user/setName', payload: { user: { name: 'wangwu' } } }) }}&gt;修改name·异步&lt;/button&gt; &lt;hr /&gt; &lt;/div&gt; ) } export default connect(({ user }: any) =&gt; ({ user, }))(Children03); 
 </blockquote> 
 <h4 style="text-align:left;">文档</h4> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   model 
  <br>namespace # model 的命名空间，唯一标识一个 model，如果与文件名相同可以省略不写 
  <br>state # model 中的数据 
  <br>effects # 异步 action，用来发送异步请求 
  <br>reducers # 同步 action，用来修改 state 
  <br>connect 
  <br>connect 的是用来将 model 和组件关联在一起的，它会将相关数据和 dispatch 添加到组件的 props 中。 
  <br>dispatch 
  <br>在使用 connect 将组件和 model 关联在一起的同时框架也会添加一个 this.props.dispatch 的方法，通过该方法你可以触发一个 action 到 model 中。 
  <br>Reducer 
  <br>reducer 是一个函数，用来处理修改数据的逻辑（同步，不能请求后端）。接受 state 和 action，返回老的或新的 state 。即：(state, action) =&gt; state。 
  <br>Effects 
  <br>put 用于触发 action 。 
  <br>yield put({ type: 'todos/add', payload: 'Learn Dva' }); 
  <br>call 用于调用异步逻辑，支持 promise 。 
  <br>const result = yield call(fetch, '/todos'); 
  <br>select 用于从 state 里获取数据。 
  <br>const todos = yield select(state =&gt; state.todos); 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">loading 框架会默认添加一个命名空间为 loading 的 model，该 model 包含 effects 异步加载 loading 的相关信息，它的 state 格式如下：</span> 
  <br>{ global: Boolean, // 是否真正有异步请求发送中 models: { [modelnamespace]: Boolean, // 具体每个 model 的加载情况 }, effects: { [modelnamespace/effectname]: Boolean, // 具体每个 effect 的加载情况 }, } 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82aab475cc55fb1bbf1e8ebae68e8127/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">antd-mobile中Picker选项更新的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72eb8fd5cb9432a9fc9752913e0ffa36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[CVPR 2017] Look Closer to See Better: Recurrent Attention Convolutional Neural Network for FGVC</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>