<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity 小知识 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity 小知识" />
<meta property="og:description" content="1.Component的复制黏贴 等同于Inspector窗口下的Copy Component，Paste Component Values，Paste Component As New
#if UNITY_EDITOR //首先复制需要复制的组件 UnityEditorInternal.ComponentUtility.CopyComponent(needCopyComponent); //粘贴组件的值到另一个组件上 UnityEditorInternal.ComponentUtility.PasteComponentValues(newComponent); //为GameObject添加复制的组件 UnityEditorInternal.ComponentUtility.PasteComponentAsNew(gameObject); #endif 2.组件删除 //Running模式下 Destroy(component); //Editor模式下 DestroyImmediate(component); 3.Editor模式下执行脚本的Update或OnGUI 方法 有时为了帮助策划搞一下编辑工具，需要在Editor模式下，自动帮其做些操作，要在Update下进行检测。在类的定义前添加ExecuteInEditMode标签即可。
[ExecuteInEditMode] public class TestComponent : MonoBehaviour { } 4.弧度与角度的转换 Mathf.Sin(float)，Mathf.Cos(float)这些正弦余弦的方法中，参数的单位是弧度而不是角度。
弧度：弧长等于半径的弧，其所对的圆心角为1弧度，单位缩写是rad。（半径为r的圆，当某个角度α的弧长为r，那么角度α即为一弧长）
根据定义我们可以知道，圆的周长为2πr，对应360°，即360°=2πr，180°=πr。1rad对应弧长r，可以得出，1rad=180°÷π≈57.295°反过来，1°≈0.01745rad
在Mathf中有两个变量用于转换
Mathf.Deg2Rad = 0.0174532924F;//角度转弧度
Mathf.Rad2Deg = 57.29578F;//弧度转角度
所以如果我们要求sin30°，写法应该为
Mathf.Sin(30 * Mathf.Deg2Rad); 5.Vector3.ProjectOnPlane Vector3.ProjectOnPlane(Vector3 vector, Vector3 planeNormal);将向量vector投影到法向量为planeNormal的平面上。
例如你有个向量Vector3 v = new Vector3(x, y, z); 你想求他在xy轴平面上的向量(法向量为z轴)，就可以使用该方法
Vector3.ProjectOnPlane(v, Vector3.forward); 6.向量的点积，叉积 点积
Vector3.Dot(Vector3 lhs, Vector3 rhs);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b8d7ef1cc2f85e786e19cf5b57745309/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-01T11:25:50+08:00" />
<meta property="article:modified_time" content="2019-08-01T11:25:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity 小知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">1.Component的复制黏贴</h4> 
<p>等同于Inspector窗口下的Copy Component，Paste Component Values，Paste Component As New</p> 
<pre class="has"><code class="language-cs">#if UNITY_EDITOR

//首先复制需要复制的组件
UnityEditorInternal.ComponentUtility.CopyComponent(needCopyComponent);

//粘贴组件的值到另一个组件上
UnityEditorInternal.ComponentUtility.PasteComponentValues(newComponent);

//为GameObject添加复制的组件
UnityEditorInternal.ComponentUtility.PasteComponentAsNew(gameObject);

#endif</code></pre> 
<p> </p> 
<h4 id="2.%E7%BB%84%E4%BB%B6%E5%88%A0%E9%99%A4">2.组件删除</h4> 
<pre class="has"><code class="language-cs">//Running模式下
Destroy(component);

//Editor模式下
DestroyImmediate(component);</code></pre> 
<p> </p> 
<h4 id="3.Editor%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84Update%E6%88%96OnGUI%20%E6%96%B9%E6%B3%95">3.Editor模式下执行脚本的Update或OnGUI 方法</h4> 
<p>有时为了帮助策划搞一下编辑工具，需要在Editor模式下，自动帮其做些操作，要在Update下进行检测。在类的定义前添加ExecuteInEditMode标签即可。</p> 
<pre class="has"><code class="language-cs">[ExecuteInEditMode]
public class TestComponent : MonoBehaviour
{
}</code></pre> 
<p> </p> 
<h4 id="4.%E5%BC%A7%E5%BA%A6%E4%B8%8E%E8%A7%92%E5%BA%A6%E7%9A%84%E8%BD%AC%E6%8D%A2">4.弧度与角度的转换</h4> 
<p>Mathf.Sin(float)，Mathf.Cos(float)这些正弦余弦的方法中，参数的单位是<strong>弧度</strong>而不是<strong>角度</strong>。</p> 
<p>弧度：弧长等于半径的弧，其所对的圆心角为1弧度，单位缩写是rad。（半径为r的圆，当某个角度α的弧长为r，那么角度α即为一弧长）</p> 
<p>根据定义我们可以知道，圆的周长为2πr，对应360°，即360°=2πr，<strong>180°=πr</strong>。1rad对应弧长r，可以得出，<strong>1rad=180°÷π≈57.295°</strong>反过来，<strong>1°≈0.01745rad</strong></p> 
<p>在Mathf中有两个变量用于转换</p> 
<p>Mathf.Deg2Rad = 0.0174532924F;//角度转弧度</p> 
<p>Mathf.Rad2Deg = 57.29578F;//弧度转角度</p> 
<p>所以如果我们要求sin30°，写法应该为</p> 
<pre class="has"><code>Mathf.Sin(30 * Mathf.Deg2Rad);</code></pre> 
<p> </p> 
<h4 id="5.Vector3.ProjectOnPlane">5.Vector3.ProjectOnPlane</h4> 
<p>Vector3.ProjectOnPlane(Vector3 vector, Vector3 planeNormal);将向量vector投影到法向量为planeNormal的平面上。</p> 
<p>例如你有个向量Vector3 v = new Vector3(x, y, z); 你想求他在xy轴平面上的向量(法向量为z轴)，就可以使用该方法</p> 
<pre class="has"><code>Vector3.ProjectOnPlane(v, Vector3.forward);</code></pre> 
<p> </p> 
<h4 id="6.%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E7%A7%AF%EF%BC%8C%E5%8F%89%E7%A7%AF">6.向量的点积，叉积</h4> 
<p><strong>点积</strong></p> 
<p>Vector3.Dot(Vector3 lhs, Vector3 rhs);</p> 
<p>计算方式为:  a·b = |a|·|b|cos&lt;a,b&gt;  其中|a|和|b|表示向量的模，&lt;a,b&gt;表示两个向量的夹角。另外在 点积 中，&lt;a,b&gt;和&lt;b,a&gt; 夹角是不分顺序的。</p> 
<p>在a，b非零的前提下，点积如果为负，则a，b形成的角大于90度；如果为零，那么a，b垂直；如果为正，那么a，b形成的角为锐角。<span style="color:#f33b45;">由于单位向量的模为1，所以两个单位向量的点积得到两个向量的夹角的cos值</span>，因此我们可以通过点积，计算两个向量的夹角。</p> 
<pre class="has"><code class="language-cs">Vector3 a = new Vector3(7, 0, 0);
Vector3 b = new Vector3(0, 8, 0);

//cos&lt;a,b&gt; = x
float x = Vector3.Dot(a.normalized, b.normalized);

//反余弦 Cos(r) = x, r = Acos(x);
float r = Mathf.Acos(x);

//前面得到的是弧度，转角度
float angle = r * Mathf.Rad2Deg;</code></pre> 
<p><strong>叉积</strong></p> 
<p>Vector3.Cross(Vector3 lhs, Vector3 rhs);</p> 
<p>计算方式为:  |c| = |axb| = |a|·|b|sin&lt;a,b&gt;</p> 
<p>Vector3.Cross(a, b)得到的值依旧为一个向量c，c垂直于a，b所形成的平面，并且方向遵守右手定则（即b到a的转向为右手四指弯曲的方向，大拇指的方向即为c的方向）<span style="color:#f33b45;">因此axb ≠ bxa，而是axb = – bxa</span>。因此我们可以利用这个性质来判断a，b的相对位置，同样也可以求得a，b的夹角，<span style="color:#f33b45;">两个单位向量的叉积的模为两个向量的夹角的sin值</span></p> 
<pre class="has"><code class="language-cs">Vector3 a = new Vector3(1, 0, 1);
Vector3 b = new Vector3(0, 0, 1);

Vector3 c1 = Vector3.Cross(a, b);
Debug.Log("c1:" + c1);//c1:(0.0, -1.0, 0.0)
//xz平面上，b到a为顺时针

Vector3 c2 = Vector3.Cross(b, a);
Debug.Log("c2:" + c2);//c2:(0.0, 1.0, 0.0)
//xz平面上，a到b为顺时针

//|c| = sin&lt;a, b&gt;
Vector3 c = Vector3.Cross(a.normalized, b.normalized);
//x = |c|
float x = Vector3.Distance(Vector3.zero, c);
//反余弦 Sin(r) = x, r = Asin(x);
float r = Mathf.Asin(x);

//前面得到的是弧度，转角度
float angle = r * Mathf.Rad2Deg;
Debug.Log("angle:" + angle);//angle:45</code></pre> 
<p> </p> 
<h4 id="7.%E7%89%A9%E4%BD%93%E5%8C%80%E9%80%9F%E8%BF%90%E5%8A%A8%EF%BC%8C%E5%8C%80%E5%8A%A0%E9%80%9F%E8%BF%90%E5%8A%A8">7.物体匀速运动，匀加速运动</h4> 
<p>匀速运动，由公式：位移 = 速度 * 时间</p> 
<pre class="has"><code class="language-cs">float speed = 10;

void Update()
{
    transform.position += transform.forward * speed * Time.deltaTime;
}
</code></pre> 
<p>匀加速运动，由公式：<img alt="" class="has" height="39" src="https://images2.imgbox.com/e0/9b/VfqsZLyu_o.png" width="245"></p> 
<pre class="has"><code class="language-cs">float speed = 0;
float endspeed;
int acceleration = 10;//加速度

void Update()
{
    endspeed = speed + acceleration * Time.deltaTime;
    //transform.position += transform.forward * (speed * Time.deltaTime + acceleration * Time.deltaTime* Time.deltaTime*0.5f);
    transform.position += transform.forward * (speed + endspeed) * 0.5f * Time.deltaTime;
    speed = endspeed;
}
</code></pre> 
<p> </p> 
<h4 id="8.Unity%20%E9%A1%B9%E7%9B%AE%E5%A4%9A%E5%BC%80">8.Unity 项目多开</h4> 
<p>有些项目需要多人在线，测试的时候就需要多开来模拟。但是同一个unity工程只能打开一次，我们可以通过联接的方式来引用出一个新的相同的工程来实现多开。如图，需要多开的原工程为MainProject，而MainProject_copy就是我们的镜像工程</p> 
<p><img alt="" class="has" height="56" src="https://images2.imgbox.com/c5/e8/ZqfzqtaP_o.png" width="498"><img alt="" class="has" height="108" src="https://images2.imgbox.com/1d/bd/Z9HVQDuW_o.png" width="382"></p> 
<p>我们在需要多开的项目的根目录的同级目录下新建一个.bat文件，内容如下：</p> 
<pre class="has"><code>%cd%
 
rem 需要创建的目录
set dir = CopeProjectFolderName
 
rem 如果没有则创建
if not exist %dir% ( md %dir%) 
 
rem 创建链接
mklink /J %dir%\Assets YourProjectFolderName\Assets
mklink /J %dir%\ProjectSettings YourProjectFolderName\ProjectSettings
 
pause</code></pre> 
<p>CopeProjectFolderName：镜像工程的文件名</p> 
<p>YourProjectFolderName：原工程文件名</p> 
<p>原理就是在镜像工程中创建原工程的Assets目录和ProjectSettings目录的联接，这样原目录修改的话，镜像目录也会一并的改变。</p> 
<p>运行.bat文件后，建好新的工程，最后用unity打开这个新建的工程即可。</p> 
<p> </p> 
<h4 id="9.Unity%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%88%E4%BE%8B%E5%A6%82%20.exe%20.bat%E6%96%87%E4%BB%B6%EF%BC%89">9.Unity调用外部可执行文件（例如 .exe .bat文件）</h4> 
<p>我们可以使用System.Diagnostics.Process来实现Unity调用外部可执行文件，官方文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.process?view=netframework-4.8" rel="nofollow">https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.process?view=netframework-4.8</a></p> 
<pre class="has"><code class="language-cs">public class EditorUtil
{
    public static void ExecuteProcess(string filePath, string command, int seconds = 0)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            UnityEngine.Debug.LogError(filePath + " 找不到");
            return;
        }
        Process process = new Process();//创建进程对象
        //process.StartInfo.WorkingDirectory = workPath;//文件目录，可以不设置，在FileName中带上路径
        process.StartInfo.FileName = filePath;//文件名
        process.StartInfo.Arguments = command;//参数（会传入到如exe的Main()函数或者bat的%1 %2）
        process.StartInfo.CreateNoWindow = true;//启动该进程而不创建包含它的新窗口
        process.StartInfo.RedirectStandardOutput = false;//不重定向输出
        try
        {
            if (process.Start())
            {
                if (seconds == 0)
                {
                    process.WaitForExit(); //无限等待进程结束
                }
                else
                {
                    process.WaitForExit(seconds); //在指定的毫秒数内等待关联进程退出
                }
            }
        }
        catch (Exception e)
        {
            UnityEngine.Debug.LogError(e.Message);
        }
        finally
        {
            process.Close();
        }
    }
}</code></pre> 
<p>举例：根据上面的方法我们可以在Unity中进行svn的相关操作，即写好svn的命令行脚本后存为.bat文件，然后在Unity中调用，其中的参数：目录路径，即在process.StartInfo.Arguments传入，每个参数之间用空格分隔</p> 
<p>svn.bat：</p> 
<pre class="has"><code>set path=%1
svn revert -R %path%
svn update %path%
::svn commit -m "log" %path%</code></pre> 
<p>如果命令行svn无效可以看看是否环境变量没有配置，或者安装的时候没有勾选（默认不勾选）</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/8f/c8/hOYbjS6A_o.png"></p> 
<p>使用svn还有一种比较蠢的方法是使用小乌龟svn安装目录下bin/TortoiseProc.exe文件，同样也是要使用上面的Process来调用并传递参数，具体的大家可以百度看看</p> 
<p> </p> 
<h4 id="10.%E5%90%91%E9%87%8F%E7%9A%84%E9%95%BF%E5%BA%A6sqrMagnitude%E5%92%8Cmagnitude">10.向量的长度sqrMagnitude和magnitude</h4> 
<p>magnitude：用于获取向量的大小。适用于Vector2.magnitude或Vector3.magnitude</p> 
<p>假设在一个平面上有两个点，A：Vector2(1,1)，B：Vector2(7,8)，根据勾股定理那么A到B的长度即为<img alt="\sqrt{(7-1)^{2} + (8-1)^{2} } \approx 9.22" class="mathcode" src="https://images2.imgbox.com/18/b5/vKWNjPQ5_o.gif">，(B-A).magnitude的值即为此。</p> 
<p>由于上面的操作需要开根号操作，计算的消耗会很大。<span style="color:#f33b45;">因此我们可以使用sqrMagnitude来代替，以节省性能。</span></p> 
<p>sqrMagnitude：向量大小的平方，即为 <img alt="magnitude^{2}" class="mathcode" src="https://images2.imgbox.com/b0/16/AVBovcJc_o.gif"> 。</p> 
<p> </p> 
<h4 id="11.%E8%8E%B7%E5%8F%96Scene%E4%B8%ADGameObject%E7%9A%84LocalId%EF%BC%88Local%20Indentfier%20In%20File%EF%BC%89">11.获取Scene中GameObject的LocalId（Local Indentfier In File）</h4> 
<p><img alt="" class="has" height="219" src="https://images2.imgbox.com/a9/a2/UNbaX0vc_o.png" width="396"></p> 
<p>官方有个API是<a href="https://docs.unity3d.com/ScriptReference/AssetDatabase.TryGetGUIDAndLocalFileIdentifier.html" rel="nofollow">AssetDatabase.TryGetGUIDAndLocalFileIdentifier</a>，但是这个方法只能用于查看Project视图中的资源文件，无法查看Hierarchy中已在场景中的GameObject的LocalId。</p> 
<p>如果要获取场景中的GameObject的LocalId，我们需要通过反射去读取内部的值（原文链接：<a href="https://forum.unity.com/threads/how-to-get-the-local-identifier-in-file-for-scene-objects.265686/" rel="nofollow">https://forum.unity.com/threads/how-to-get-the-local-identifier-in-file-for-scene-objects.265686/</a>）</p> 
<pre class="has"><code class="language-cs">PropertyInfo inspectorModeInfo = typeof(SerializedObject).GetProperty("inspectorMode", BindingFlags.NonPublic | BindingFlags.Instance);
 
SerializedObject serializedObject = new SerializedObject(unityObject);
inspectorModeInfo.SetValue(serializedObject, InspectorMode.Debug, null);
 
SerializedProperty localIdProp = serializedObject.FindProperty("m_LocalIdentfierInFile");   //note the misspelling!
 
int localId = localIdProp.intValue;</code></pre> 
<p> </p> 
<h4 id="12.%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8DScene%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84GameObject">12.获取当前Scene中所有的GameObject</h4> 
<pre class="has"><code class="language-cs">GameObject[] array = UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects();</code></pre> 
<p> </p> 
<h4 id="13.Unity2019%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DHierarchy%E6%98%AF%E5%90%A6%E5%9C%A8Prefab%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2">13.Unity2019判断当前Hierarchy是否在Prefab编辑页面</h4> 
<pre><code class="language-cs">bool IsEditPrefab()
{
	var prefabStage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage();
	return prefabStage != null;
}</code></pre> 
<p> </p> 
<h4 id="14.%E7%94%A8%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%BD%93%E5%89%8DPrefab%E7%9A%84%E4%BF%AE%E6%94%B9">14.用代码提交当前Prefab的修改</h4> 
<p>有时候我们修改了某个在Hierarchy面板的Prefab，此时想将改动通过代码Apply到Project中的.prefab文件时，可以使用下面方法</p> 
<pre><code class="language-cs">//获取到Prefab的根目录
GameObject parent = PrefabUtility.GetCorrespondingObjectFromSource(this.gameObject);
//提交修改
PrefabUtility.ApplyPrefabInstance(parent,  InteractionMode.UserAction);
//刷新Project面板
AssetDatabase.Refresh();</code></pre> 
<p> </p> 
<h4 id="15.No%20'git'%20executable%20was%20found.%20Please%20install%20Git%C2%A0...">15.No 'git' executable was found. Please install Git ...</h4> 
<p>在我们使用PackageManager时，Unity允许我们使用Git上的package（点击加号，选择add package from git URL...）</p> 
<p>但是这操作需要我们的电脑里事先装好git，并且配置好相应的环境变量，否则会报错</p> 
<pre><code>Cannot perform upm operation: Unable to add package [git://github.com/.../XXX.git]:
No 'git' executable was found. Please install Git on your system then restart Unity and Unity Hub [NotFound]</code></pre> 
<p>我们只需要找到git.exe的目录，并且将其配置到系统环境变量的Path中即可。验证方式为，打开命令行窗口输入git，若有效即可。（若使用sourcetree的，可以参考<a href="https://blog.csdn.net/wangjiangrong/article/details/80287041">https://blog.csdn.net/wangjiangrong/article/details/80287041</a> 最后面的环境变量相关内容）</p> 
<p>配置好环境变量后需要重启Unity以及Unity Hub，注意一定要都重启，否则还是会报错。</p> 
<p> </p> 
<h4>16.一些快捷键</h4> 
<p><strong>windows</strong>：</p> 
<p><img alt="" height="742" src="https://images2.imgbox.com/12/27/IWYvdd7P_o.png" width="924"></p> 
<p><strong>mac</strong>：</p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/de/95/GD6Jczqw_o.png" width="934"></p> 
<p> </p> 
<p>常见的如<strong>QWERTY</strong>对应编辑器的拖动，移动，旋转等：</p> 
<p><img alt="" height="39" src="https://images2.imgbox.com/b3/3b/FQaytjcD_o.png" width="213"></p> 
<p> </p> 
<p>展开或收起所有的子层，按住 <strong>alt </strong>再去点击Hierarchy面板的小箭头：</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/c5/f5/c9kBs15P_o.png" width="263"></p> 
<p> </p> 
<p>按住<strong>鼠标右键</strong>然后就可以通过<strong>WASD</strong>四个方向键来移动我们<strong>Scene</strong>窗口的视角了</p> 
<p> </p> 
<p>2019新增<strong> Shortcuts Manager</strong>（快捷键管理器）可以自定义快捷键：</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/af/0a/bFeUrdgW_o.png" width="324"></p> 
<p> </p> 
<p> </p> 
<h4>17.Snap</h4> 
<p>在Scene目录下，我们可以通过按住<strong>Ctrl</strong>或者<strong>Cmd</strong>键，然后拖动或旋转物体时，会按照一定的数值进行变化</p> 
<p>相关设置在 Editor-&gt; Snap Settings，可以在里面设置每次移动的距离等。</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/1c/42/tvQpoeWV_o.png" width="222"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45d942394d019b988c9e67e10a53ea8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">牛客——计算系数（组合数学）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7aaa38bdffca0f503ae525d6fd2d023a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Numpy数字类型 dtype</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>