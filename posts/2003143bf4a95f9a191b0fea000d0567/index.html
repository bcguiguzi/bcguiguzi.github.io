<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>onvif开发之设备发现功能的实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="onvif开发之设备发现功能的实现" />
<meta property="og:description" content="忙了一个多月，onvif总算告一段落了。这几个星期忙着其他的项目，也没有好好整理一下onvif的东西。接下来得好好整理一下自己的项目思路和项目经验，同时将自己的一些心得写出来，希望对人有所帮助。
相信大多数兄弟和我一样，onvif开发，最开始做的就是发现功能。这两天登录onvif的官网看才发现，onvif版本在八月份有更新，已经更新到V2.4了，于是下载最新的版本来进行。代码的生成可以详见我的前一篇文章。V2.4版本新增了一个wsdl文件，现在用于生成源码的文件一共有18个。为了保证全功能，最好一次性生成包含所有功能的源码。然后根据最新生成的源码来实现onvif客户端和服务端的发现功能。
1. 创建onvif_test目录。以下这些源码由最新的gsoap（2.8.16）和最新的onvif的wsdl文件（2.4）生成。（截止2013.09.16）
onvif.h
soapClientLib.c
soapServerLib.c
soapC.c
soapClient.c
soapH.h
soapServer.c
soapStub.h
2.以下文件来自gsoap_2.8.16\gsoap-2.8\gsoap
stdsoap2.c
stdsoap2.h
3.以下文件来自gsoap_2.8.16\gsoap-2.8\gsoap\custom
duration.c
4.生成的soapClientLib.c和soapServerLib.c无实际作用，可直接删除。
5.增加自定义文件：
onvif_server.c onvif服务端实现代码
onvif_client.c onvif客户端实现代码
onvif_server_interface.c onvif服务端接口实现
onvif_function.c onvif实现函数，公用
onvif_function.h onvif实现函数，公用
onvif_server.c为服务端的实现代码，主要是定义main函数，服务端主要是监听，并处理和应答消息。
Main函数定义如下：
[cpp] view plain copy print ? int main(int argc,char ** argv) { printf(&#34;[%s][%d][%s][%s] start \n&#34;, __FILE__, __LINE__, __TIME__, __func__); int count = 0; struct soap ServerSoap; struct ip_mreq mcast; soap_init1(&amp;ServerSoap, SOAP_IO_UDP | SOAP_XML_IGNORENS); soap_set_namespaces(&amp;ServerSoap, namespaces); printf(&#34;[%s][%d][%s][%s] ServerSoap.version = %d \n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2003143bf4a95f9a191b0fea000d0567/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-01-06T20:40:35+08:00" />
<meta property="article:modified_time" content="2014-01-06T20:40:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">onvif开发之设备发现功能的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4> </h4> 
<div class="article_content" id="article_content"> 
 <p><span style="font-size:18px">        忙了一个多月，<span style="font-family:Calibri">onvif</span><span style="font-family:宋体">总算告一段落了。这几个星期忙着其他的项目，也没有好好整理一下</span><span style="font-family:Calibri">onvif</span><span style="font-family:宋体">的东西。接下来得好好整理一下自己的项目思路和项目经验，同时将自己的一些心得写出来，希望对人有所帮助。</span></span></p> 
 <p><span style="font-size:18px">        相信大多数兄弟和我一样，<span style="font-family:Calibri">onvif</span><span style="font-family:宋体">开发，最开始做的就是发现功能。这两天登录</span><span style="font-family:Calibri">onvif</span><span style="font-family:宋体">的官网看才发现，</span><span style="font-family:Calibri">onvif</span><span style="font-family:宋体">版本在八月份有更新，已经更新到</span><span style="font-family:Calibri">V2.4</span><span style="font-family:宋体">了，于是下载最新的版本来进行。代码的生成可以详见我的前一篇文章。</span><span style="font-family:Calibri">V2.4</span><span style="font-family:宋体">版本新增了一个</span><span style="font-family:Calibri">wsdl</span><span style="font-family:宋体">文件，现在用于生成源码的文件一共有</span><span style="font-family:Calibri">18</span><span style="font-family:宋体">个</span>。为了保证全功能，最好一次性生成包含所有功能的源码。然后根据最新生成的源码来实现onvif客户端和服务端的发现功能。</span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">1. <span style="font-family:宋体">创建</span><span style="font-family:Calibri">onvif_test</span><span style="font-family:宋体">目录。以下这些源码由最新的</span><span style="font-family:Calibri">gsoap</span><span style="font-family:宋体">（</span><span style="font-family:Calibri">2.8.16</span><span style="font-family:宋体">）和最新的</span><span style="font-family:Calibri">onvif</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">wsdl</span><span style="font-family:宋体">文件（</span><span style="font-family:Calibri">2.4</span><span style="font-family:宋体">）生成。（截止</span><span style="font-family:Calibri">2013.09.16</span><span style="font-family:宋体">）</span></span></p> 
 <p><span style="font-size:18px">onvif.h</span></p> 
 <p><span style="font-size:18px">soapClientLib.c</span></p> 
 <p><span style="font-size:18px">soapServerLib.c</span></p> 
 <p><span style="font-size:18px">soapC.c</span></p> 
 <p><span style="font-size:18px">soapClient.c</span></p> 
 <p><span style="font-size:18px">soapH.h</span></p> 
 <p><span style="font-size:18px">soapServer.c</span></p> 
 <p><span style="font-size:18px">soapStub.h</span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">2.<span style="font-family:宋体">以下文件来自</span><span style="font-family:Calibri">gsoap_2.8.16\gsoap-2.8\gsoap</span></span></p> 
 <p><span style="font-size:18px">stdsoap2.c</span></p> 
 <p><span style="font-size:18px">stdsoap2.h</span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">3.<span style="font-family:宋体">以下文件来自</span><span style="font-family:Calibri">gsoap_2.8.16\gsoap-2.8\gsoap\custom</span></span></p> 
 <p><span style="font-size:18px">duration.c</span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">4.生成的soapClientLib.c<span style="font-family:宋体">和</span><span style="font-family:Calibri">soapServerLib.c</span><span style="font-family:宋体">无实际作用，可直接删除。</span></span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">5.<span style="font-family:宋体">增加自定义文件</span>：</span></p> 
 <p><span style="font-size:18px">onvif_server.c   onvif<span style="font-family:宋体">服务端实现代码</span></span></p> 
 <p><span style="font-size:18px">onvif_client.c   onvif<span style="font-family:宋体">客户端实现代码</span></span></p> 
 <p><span style="font-size:18px">onvif_server_interface.c   onvif<span style="font-family:宋体">服务端接口实现</span></span></p> 
 <p><span style="font-size:18px">onvif_function.c  onvif<span style="font-family:宋体">实现函数，公用</span></span></p> 
 <p><span style="font-size:18px">onvif_function.h  onvif<span style="font-family:宋体">实现函数，公用</span></span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">onvif_server.c为服务端的实现代码，主要是定义main<span style="font-family:宋体">函数，服务端主要是监听，并处理和应答消息。</span></span></p> 
 <p><span style="font-size:18px">Main<span style="font-family:宋体">函数定义如下：</span></span></p> 
 <div class="dp-highlighter bg_cpp"> 
  <div class="bar"> 
   <div class="tools"> 
    <strong>[cpp]</strong> 
    <a target="_blank" title="view plain" class="ViewSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer"> view plain</a> 
    <a target="_blank" title="copy" class="CopyToClipboard" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">copy</a> 
    <a target="_blank" title="print" class="PrintSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">print</a> 
    <a target="_blank" title="?" class="About" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">?</a> 
   </div> 
  </div> 
  <ol class="dp-cpp"><li class="alt"><span class="datatypes">int</span> main(<span class="datatypes">int</span> argc,<span class="datatypes">char</span> ** argv)  </li><li>{  </li><li class="alt">    printf(<span class="string">"[%s][%d][%s][%s] start \n"</span>, __FILE__, __LINE__, __TIME__, __func__);  </li><li>  </li><li class="alt">    <span class="datatypes">int</span> count = 0;  </li><li>    <span class="keyword">struct</span> soap ServerSoap;  </li><li class="alt">    <span class="keyword">struct</span> ip_mreq mcast;  </li><li>      </li><li class="alt">    soap_init1(&amp;ServerSoap, SOAP_IO_UDP | SOAP_XML_IGNORENS);  </li><li>    soap_set_namespaces(&amp;ServerSoap,  namespaces);  </li><li class="alt">      </li><li>    printf(<span class="string">"[%s][%d][%s][%s] ServerSoap.version = %d \n"</span>, __FILE__, __LINE__, __TIME__, __func__, ServerSoap.version);  </li><li class="alt">      </li><li>    <span class="keyword">if</span>(!soap_valid_socket(soap_bind(&amp;ServerSoap, NULL, ONVIF_LISTEN_PORT, 10)))  </li><li class="alt">    {  </li><li>        soap_print_fault(&amp;ServerSoap, stderr);  </li><li class="alt">        exit(1);  </li><li>    }  </li><li class="alt">      </li><li>    mcast.imr_multiaddr.s_addr = inet_addr(<span class="string">"239.255.255.250"</span>);  </li><li class="alt">    mcast.imr_interface.s_addr = htonl(INADDR_ANY);  </li><li>  </li><li class="alt">    <span class="keyword">if</span>(setsockopt(ServerSoap.master, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="datatypes">char</span>*)&amp;mcast, <span class="keyword">sizeof</span>(mcast)) &lt; 0)  </li><li>    {  </li><li class="alt">            printf(<span class="string">"setsockopt error! error code = %d,err string = %s\n"</span>,errno,strerror(errno));  </li><li>        <span class="keyword">return</span> 0;  </li><li class="alt">    }  </li><li>  </li><li class="alt">    <span class="keyword">for</span>(;;)  </li><li>    {  </li><li class="alt">        <span class="keyword">if</span>(soap_serve(&amp;ServerSoap))  </li><li>        {  </li><li class="alt">            soap_print_fault(&amp;ServerSoap, stderr);  </li><li>        }  </li><li class="alt">  </li><li>        soap_destroy(&amp;ServerSoap);  </li><li class="alt">        soap_end(&amp;ServerSoap);  </li><li>  </li><li class="alt">        <span class="comment">//客户端的IP地址</span>  </li><li>        printf(<span class="string">"RECEIVE count %d, connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n"</span>, count, ((ServerSoap.ip)&gt;&gt;24)&amp;0xFF, ((ServerSoap.ip)&gt;&gt;16)&amp;0xFF, ((ServerSoap.ip)&gt;&gt;8)&amp;0xFF,(ServerSoap.ip)&amp;0xFF, (ServerSoap.socket));  </li><li class="alt">        count++;  </li><li>    }  </li><li class="alt">  </li><li>    <span class="comment">//分离运行时的环境</span>  </li><li class="alt">    soap_done(&amp;ServerSoap);  </li><li>  </li><li class="alt">    <span class="keyword">return</span> 0;  </li><li>}  </li></ol> 
 </div> 
 <pre><code class="language-cpp">int main(int argc,char ** argv)
{
	printf("[%s][%d][%s][%s] start \n", __FILE__, __LINE__, __TIME__, __func__);

	int count = 0;
	struct soap ServerSoap;
	struct ip_mreq mcast;
	
	soap_init1(&amp;ServerSoap, SOAP_IO_UDP | SOAP_XML_IGNORENS);
	soap_set_namespaces(&amp;ServerSoap,  namespaces);
	
	printf("[%s][%d][%s][%s] ServerSoap.version = %d \n", __FILE__, __LINE__, __TIME__, __func__, ServerSoap.version);
	
	if(!soap_valid_socket(soap_bind(&amp;ServerSoap, NULL, ONVIF_LISTEN_PORT, 10)))
	{
		soap_print_fault(&amp;ServerSoap, stderr);
		exit(1);
	}
	
	mcast.imr_multiaddr.s_addr = inet_addr("239.255.255.250");
	mcast.imr_interface.s_addr = htonl(INADDR_ANY);

	if(setsockopt(ServerSoap.master, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&amp;mcast, sizeof(mcast)) &lt; 0)
	{
	    	printf("setsockopt error! error code = %d,err string = %s\n",errno,strerror(errno));
		return 0;
	}

	for(;;)
	{
		if(soap_serve(&amp;ServerSoap))
		{
			soap_print_fault(&amp;ServerSoap, stderr);
		}

		soap_destroy(&amp;ServerSoap);
		soap_end(&amp;ServerSoap);

		//客户端的IP地址
		printf("RECEIVE count %d, connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n", count, ((ServerSoap.ip)&gt;&gt;24)&amp;0xFF, ((ServerSoap.ip)&gt;&gt;16)&amp;0xFF, ((ServerSoap.ip)&gt;&gt;8)&amp;0xFF,(ServerSoap.ip)&amp;0xFF, (ServerSoap.socket));
		count++;
	}

	//分离运行时的环境
	soap_done(&amp;ServerSoap);

	return 0;
}</code></pre> 
 <p><span style="font-size:18px">onvif_server_interface.c   此文件用来定义所有服务端需要填充的接口。这里我们填充__wsdd__Probe接口即可，其他赞不支持的接口可以用宏统一处理。</span></p> 
 <p><span style="font-size:18px">__wsdd__Probe的填充如下：</span></p> 
 <div class="dp-highlighter bg_cpp"> 
  <div class="bar"> 
   <div class="tools"> 
    <strong>[cpp]</strong> 
    <a target="_blank" title="view plain" class="ViewSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer"> view plain</a> 
    <a target="_blank" title="copy" class="CopyToClipboard" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">copy</a> 
    <a target="_blank" title="print" class="PrintSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">print</a> 
    <a target="_blank" title="?" class="About" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">?</a> 
   </div> 
  </div> 
  <ol class="dp-cpp"><li class="alt">SOAP_FMAC5 <span class="datatypes">int</span> SOAP_FMAC6  __wsdd__Probe(<span class="keyword">struct</span> soap* soap, <span class="keyword">struct</span> wsdd__ProbeType *wsdd__Probe)  </li><li>{  </li><li class="alt">  </li><li><span class="preprocessor">    #define MACH_ADDR_LENGTH 6</span>  </li><li class="alt"><span class="preprocessor">    #define INFO_LENGTH 512</span>  </li><li><span class="preprocessor">    #define LARGE_INFO_LENGTH 1024</span>  </li><li class="alt"><span class="preprocessor">    #define SMALL_INFO_LENGTH 512</span>  </li><li>      </li><li class="alt">    printf(<span class="string">"[%d] __wsdd__Probe start !\n"</span>, __LINE__);  </li><li>      </li><li class="alt">    unsigned <span class="datatypes">char</span> macaddr[6] = {0};  </li><li>    <span class="datatypes">char</span> _IPAddr[INFO_LENGTH] = {0};  </li><li class="alt">    <span class="datatypes">char</span> _HwId[1024] = {0};  </li><li>      </li><li class="alt">    wsdd__ProbeMatchesType ProbeMatches;  </li><li>    ProbeMatches.ProbeMatch = (<span class="keyword">struct</span> wsdd__ProbeMatchType *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsdd__ProbeMatchType));  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;XAddrs = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * INFO_LENGTH);  </li><li>    ProbeMatches.ProbeMatch-&gt;Types = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * INFO_LENGTH);  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;Scopes = (<span class="keyword">struct</span> wsdd__ScopesType*)soap_malloc(soap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsdd__ScopesType));  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties = (<span class="keyword">struct</span> wsa__ReferencePropertiesType*)soap_malloc(soap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsa__ReferencePropertiesType));  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters = (<span class="keyword">struct</span> wsa__ReferenceParametersType*)soap_malloc(soap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsa__ReferenceParametersType));  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName = (<span class="keyword">struct</span> wsa__ServiceNameType*)soap_malloc(soap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsa__ServiceNameType));  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType = (<span class="datatypes">char</span> **)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span> *) * SMALL_INFO_LENGTH);  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any = (<span class="datatypes">char</span> **)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>*) * SMALL_INFO_LENGTH);  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__anyAttribute = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * SMALL_INFO_LENGTH);  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.Address = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * INFO_LENGTH);  </li><li class="alt">  </li><li>    netGetMac(<span class="string">"eth4"</span>, macaddr); <span class="comment">//eth0  根据实际情况填充</span>  </li><li class="alt">    macaddr[0]=0x01;macaddr[1]=0x01;macaddr[2]=0x01;macaddr[3]=0x01;macaddr[4]=0x01;macaddr[5]=0x01;  </li><li>    sprintf(_HwId,<span class="string">"urn:uuid:2419d68a-2dd2-21b2-a205-%02X%02X%02X%02X%02X%02X"</span>,macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);  </li><li class="alt">  </li><li>  </li><li class="alt">    unsigned <span class="datatypes">int</span> localIp = 0;  </li><li>    netGetIp(<span class="string">"eth4"</span>, &amp;localIp); <span class="comment">//eth0 根据实际情况填充</span>  </li><li class="alt">    sprintf(_IPAddr, <span class="string">"http://%s/onvif/device_service"</span>, inet_ntoa(*((<span class="keyword">struct</span> in_addr *)&amp;localIp)));  </li><li>    printf(<span class="string">"[%d] _IPAddr ==== %s\n"</span>, __LINE__, _IPAddr);  </li><li class="alt">      </li><li>    ProbeMatches.__sizeProbeMatch = 1;  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item =(<span class="datatypes">char</span> *)soap_malloc(soap, 1024);  </li><li>    memset(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item,0,<span class="keyword">sizeof</span>(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item));    </li><li class="alt">  </li><li>    <span class="comment">//Scopes MUST BE</span>  </li><li class="alt">    strcat(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item, <span class="string">"onvif://www.onvif.org/type/NetworkVideoTransmitter"</span>);  </li><li>  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;Scopes-&gt;MatchBy = NULL;  </li><li>    strcpy(ProbeMatches.ProbeMatch-&gt;XAddrs, _IPAddr);  </li><li class="alt">    strcpy(ProbeMatches.ProbeMatch-&gt;Types, wsdd__Probe-&gt;Types);  </li><li>    printf(<span class="string">"wsdd__Probe-&gt;Types=%s\n"</span>,wsdd__Probe-&gt;Types);  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;MetadataVersion = 1;  </li><li>      </li><li class="alt">    <span class="comment">//ws-discovery规定 为可选项</span>  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties-&gt;__size = 0;  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties-&gt;__any = NULL;  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters-&gt;__size = 0;  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters-&gt;__any = NULL;  </li><li>      </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType[0] = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * SMALL_INFO_LENGTH);  </li><li>    <span class="comment">//ws-discovery规定 为可选项</span>  </li><li class="alt">    strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType[0], <span class="string">"ttl"</span>);  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;__item = NULL;  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;PortName = NULL;  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;__anyAttribute = NULL;  </li><li class="alt">    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any[0] = (<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * SMALL_INFO_LENGTH);  </li><li>    strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any[0], <span class="string">"Any"</span>);  </li><li class="alt">    strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__anyAttribute, <span class="string">"Attribute"</span>);  </li><li>    ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__size = 0;  </li><li class="alt">    strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.Address, _HwId);  </li><li>      </li><li class="alt">    soap-&gt;header-&gt;wsa__To = <span class="string">"http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous"</span>;  </li><li>    soap-&gt;header-&gt;wsa__Action = <span class="string">"http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches"</span>;  </li><li class="alt">    soap-&gt;header-&gt;wsa__RelatesTo = (<span class="keyword">struct</span> wsa__Relationship*)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> wsa__Relationship));  </li><li>    soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item = soap-&gt;header-&gt;wsa__MessageID;  </li><li class="alt">    soap-&gt;header-&gt;wsa__RelatesTo-&gt;RelationshipType = NULL;  </li><li>    soap-&gt;header-&gt;wsa__RelatesTo-&gt;__anyAttribute = NULL;  </li><li class="alt">  </li><li>    soap-&gt;header-&gt;wsa__MessageID =(<span class="datatypes">char</span> *)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="datatypes">char</span>) * INFO_LENGTH);  </li><li class="alt">    strcpy(soap-&gt;header-&gt;wsa__MessageID,_HwId+4);  </li><li>  </li><li class="alt">        <span class="keyword">if</span> (SOAP_OK == soap_send___wsdd__ProbeMatches(soap, <span class="string">"http://"</span>, NULL, &amp;ProbeMatches))  </li><li>        {  </li><li class="alt">        printf(<span class="string">"send ProbeMatches success !\n"</span>);  </li><li>        <span class="keyword">return</span> SOAP_OK;  </li><li class="alt">    }  </li><li>  </li><li class="alt">    printf(<span class="string">"[%d] soap error: %d, %s, %s\n"</span>, __LINE__, soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));    </li><li>      </li><li class="alt">    <span class="keyword">return</span> soap-&gt;error;;  </li><li>  </li><li class="alt">}  </li></ol> 
 </div> 
 <pre><code class="language-cpp">SOAP_FMAC5 int SOAP_FMAC6  __wsdd__Probe(struct soap* soap, struct wsdd__ProbeType *wsdd__Probe)
{

	#define MACH_ADDR_LENGTH 6
	#define INFO_LENGTH 512
	#define LARGE_INFO_LENGTH 1024
	#define SMALL_INFO_LENGTH 512
	
	printf("[%d] __wsdd__Probe start !\n", __LINE__);
	
	unsigned char macaddr[6] = {0};
	char _IPAddr[INFO_LENGTH] = {0};
	char _HwId[1024] = {0};
	
	wsdd__ProbeMatchesType ProbeMatches;
	ProbeMatches.ProbeMatch = (struct wsdd__ProbeMatchType *)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType));
	ProbeMatches.ProbeMatch-&gt;XAddrs = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH);
	ProbeMatches.ProbeMatch-&gt;Types = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH);
	ProbeMatches.ProbeMatch-&gt;Scopes = (struct wsdd__ScopesType*)soap_malloc(soap,sizeof(struct wsdd__ScopesType));
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties = (struct wsa__ReferencePropertiesType*)soap_malloc(soap,sizeof(struct wsa__ReferencePropertiesType));
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters = (struct wsa__ReferenceParametersType*)soap_malloc(soap,sizeof(struct wsa__ReferenceParametersType));
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName = (struct wsa__ServiceNameType*)soap_malloc(soap,sizeof(struct wsa__ServiceNameType));
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType = (char **)soap_malloc(soap, sizeof(char *) * SMALL_INFO_LENGTH);
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any = (char **)soap_malloc(soap, sizeof(char*) * SMALL_INFO_LENGTH);
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__anyAttribute = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH);
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.Address = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH);

	netGetMac("eth4", macaddr); //eth0  根据实际情况填充
	macaddr[0]=0x01;macaddr[1]=0x01;macaddr[2]=0x01;macaddr[3]=0x01;macaddr[4]=0x01;macaddr[5]=0x01;
	sprintf(_HwId,"urn:uuid:2419d68a-2dd2-21b2-a205-%02X%02X%02X%02X%02X%02X",macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);


	unsigned int localIp = 0;
	netGetIp("eth4", &amp;localIp); //eth0 根据实际情况填充
	sprintf(_IPAddr, "http://%s/onvif/device_service", inet_ntoa(*((struct in_addr *)&amp;localIp)));
	printf("[%d] _IPAddr ==== %s\n", __LINE__, _IPAddr);
	
	ProbeMatches.__sizeProbeMatch = 1;
	ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item =(char *)soap_malloc(soap, 1024);
	memset(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item,0,sizeof(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item));	

	//Scopes MUST BE
	strcat(ProbeMatches.ProbeMatch-&gt;Scopes-&gt;__item, "onvif://www.onvif.org/type/NetworkVideoTransmitter");

	ProbeMatches.ProbeMatch-&gt;Scopes-&gt;MatchBy = NULL;
	strcpy(ProbeMatches.ProbeMatch-&gt;XAddrs, _IPAddr);
	strcpy(ProbeMatches.ProbeMatch-&gt;Types, wsdd__Probe-&gt;Types);
	printf("wsdd__Probe-&gt;Types=%s\n",wsdd__Probe-&gt;Types);
	ProbeMatches.ProbeMatch-&gt;MetadataVersion = 1;
	
	//ws-discovery规定 为可选项
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties-&gt;__size = 0;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceProperties-&gt;__any = NULL;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters-&gt;__size = 0;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ReferenceParameters-&gt;__any = NULL;
	
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType[0] = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH);
	//ws-discovery规定 为可选项
	strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.PortType[0], "ttl");
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;__item = NULL;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;PortName = NULL;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.ServiceName-&gt;__anyAttribute = NULL;
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any[0] = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH);
	strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__any[0], "Any");
	strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__anyAttribute, "Attribute");
	ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.__size = 0;
	strcpy(ProbeMatches.ProbeMatch-&gt;wsa__EndpointReference.Address, _HwId);
	
	soap-&gt;header-&gt;wsa__To = "http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous";
	soap-&gt;header-&gt;wsa__Action = "http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches";
	soap-&gt;header-&gt;wsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship));
	soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item = soap-&gt;header-&gt;wsa__MessageID;
	soap-&gt;header-&gt;wsa__RelatesTo-&gt;RelationshipType = NULL;
	soap-&gt;header-&gt;wsa__RelatesTo-&gt;__anyAttribute = NULL;

	soap-&gt;header-&gt;wsa__MessageID =(char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH);
	strcpy(soap-&gt;header-&gt;wsa__MessageID,_HwId+4);

    	if (SOAP_OK == soap_send___wsdd__ProbeMatches(soap, "http://", NULL, &amp;ProbeMatches))
    	{
		printf("send ProbeMatches success !\n");
		return SOAP_OK;
	}

	printf("[%d] soap error: %d, %s, %s\n", __LINE__, soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));  
	
	return soap-&gt;error;;

}</code></pre> 
 <p><span style="font-size:18px">onvif_client.c   onvif<span style="font-family:宋体">客户端实现代码</span>，主要是定义客户端的main<span style="font-family:宋体">函数：</span></span></p> 
 <p><span style="font-size:18px">Main<span style="font-family:宋体">定义如下：</span></span></p> 
 <div class="dp-highlighter bg_cpp"> 
  <div class="bar"> 
   <div class="tools"> 
    <strong>[cpp]</strong> 
    <a target="_blank" title="view plain" class="ViewSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer"> view plain</a> 
    <a target="_blank" title="copy" class="CopyToClipboard" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">copy</a> 
    <a target="_blank" title="print" class="PrintSource" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">print</a> 
    <a target="_blank" title="?" class="About" href="http://blog.csdn.net/love_xjhu/article/details/11821037#" rel="noopener noreferrer">?</a> 
   </div> 
  </div> 
  <ol class="dp-cpp"><li class="alt"><span class="datatypes">int</span> main()    </li><li>{    </li><li class="alt">    printf(<span class="string">"[%s][%d][%s][%s] start \n"</span>, __FILE__, __LINE__, __TIME__, __func__);  </li><li>  </li><li class="alt">    <span class="datatypes">int</span> result = 0;    </li><li>    wsdd__ProbeType req;  </li><li class="alt">    <span class="keyword">struct</span> __wsdd__ProbeMatches resp;  </li><li>    wsdd__ScopesType sScope;  </li><li class="alt">    <span class="keyword">struct</span> SOAP_ENV__Header header;    </li><li>      </li><li class="alt">    <span class="keyword">struct</span> soap *soap;    </li><li>    soap = soap_new();    </li><li class="alt">    <span class="keyword">if</span>(NULL == soap )    </li><li>    {    </li><li class="alt">        printf(<span class="string">"sopa new error\r\n"</span>);    </li><li>        <span class="keyword">return</span> -1;    </li><li class="alt">    }    </li><li>  </li><li class="alt">    soap-&gt;recv_timeout = 10;    </li><li>    soap_set_namespaces(soap, namespaces);    </li><li class="alt">    soap_default_SOAP_ENV__Header(soap, &amp;header);    </li><li>  </li><li class="alt">    uuid_t <span class="keyword">uuid</span>;  </li><li>    <span class="datatypes">char</span> guid_string[100];  </li><li class="alt">    uuid_generate(<span class="keyword">uuid</span>);  </li><li>    uuid_unparse(<span class="keyword">uuid</span>, guid_string);  </li><li class="alt">  </li><li>    header.wsa__MessageID = guid_string;   </li><li class="alt">    header.wsa__To = <span class="string">"urn:schemas-xmlsoap-org:ws:2005:04:discovery"</span>;    </li><li>    header.wsa__Action = <span class="string">"http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe"</span>;    </li><li class="alt">    soap-&gt;header = &amp;header;    </li><li>      </li><li class="alt">    soap_default_wsdd__ScopesType(soap, &amp;sScope);    </li><li>    sScope.__item = <span class="string">""</span>;    </li><li class="alt">    soap_default_wsdd__ProbeType(soap, &amp;req);    </li><li>    req.Scopes = &amp;sScope;    </li><li class="alt">    req.Types = <span class="string">""</span>; <span class="comment">//"dn:NetworkVideoTransmitter";  </span>  </li><li>  </li><li class="alt">    <span class="datatypes">int</span> i = 0;        </li><li>       result = soap_send___wsdd__Probe(soap, MULTICAST_ADDRESS, NULL, &amp;req);    </li><li class="alt">       <span class="keyword">while</span>(result == SOAP_OK)    </li><li>       {    </li><li class="alt">        result = soap_recv___wsdd__ProbeMatches(soap, &amp;resp);    </li><li>        <span class="keyword">if</span>(result == SOAP_OK)    </li><li class="alt">        {    </li><li>            <span class="keyword">if</span>(soap-&gt;error)    </li><li class="alt">            {    </li><li>                printf(<span class="string">"soap error 1: %d, %s, %s\n"</span>, soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));    </li><li class="alt">                result = soap-&gt;error;    </li><li>            }    </li><li class="alt">            <span class="keyword">else</span>    </li><li>            {    </li><li class="alt">                printf(<span class="string">"guog *********************************************\r\n"</span>);    </li><li>                <span class="keyword">if</span>(soap-&gt;header-&gt;wsa__MessageID)    </li><li class="alt">                {    </li><li>                    printf(<span class="string">"MessageID   : %s\r\n"</span>, soap-&gt;header-&gt;wsa__MessageID);    </li><li class="alt">                }    </li><li>                <span class="keyword">if</span>(soap-&gt;header-&gt;wsa__RelatesTo &amp;&amp; soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item)    </li><li class="alt">                {    </li><li>                    printf(<span class="string">"RelatesTo   : %s\r\n"</span>, soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item);    </li><li class="alt">                }    </li><li>                <span class="keyword">if</span>(soap-&gt;header-&gt;wsa__To)    </li><li class="alt">                {    </li><li>                    printf(<span class="string">"To          : %s\r\n"</span>, soap-&gt;header-&gt;wsa__To);    </li><li class="alt">                }    </li><li>                <span class="keyword">if</span>(soap-&gt;header-&gt;wsa__Action)    </li><li class="alt">                {    </li><li>                    printf(<span class="string">"Action      : %s\r\n"</span>, soap-&gt;header-&gt;wsa__Action);    </li><li class="alt">                }    </li><li>  </li><li class="alt">                <span class="keyword">for</span>(i = 0; i &lt; resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch; i++)    </li><li>                {    </li><li class="alt">                    printf(<span class="string">"__sizeProbeMatch        : %d\r\n"</span>, resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch);    </li><li>                    printf(<span class="string">"wsa__EndpointReference       : %p\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;wsa__EndpointReference);    </li><li class="alt">                    printf(<span class="string">"Target EP Address       : %s\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;wsa__EndpointReference.Address);    </li><li>                    printf(<span class="string">"Target Type             : %s\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Types);    </li><li class="alt">                    printf(<span class="string">"Target Service Address  : %s\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs);    </li><li>                    printf(<span class="string">"Target Metadata Version : %d\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;MetadataVersion);    </li><li class="alt">                    <span class="keyword">if</span>(resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Scopes)    </li><li>                    {    </li><li class="alt">                        printf(<span class="string">"Target Scopes Address   : %s\r\n"</span>, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Scopes-&gt;__item);    </li><li>                    }    </li><li class="alt">                }  </li><li>            }    </li><li class="alt">        }    </li><li>        <span class="keyword">else</span> <span class="keyword">if</span> (soap-&gt;error)    </li><li class="alt">        {    </li><li>            printf(<span class="string">"[%d] soap error 2: %d, %s, %s\n"</span>, __LINE__, soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));    </li><li class="alt">            result = soap-&gt;error;    </li><li>        }    </li><li class="alt">       }    </li><li>  </li><li class="alt">    soap_destroy(soap);   </li><li>    soap_end(soap);   </li><li class="alt">    soap_free(soap);  </li><li>  </li><li class="alt">    printf(<span class="string">"[%d] guog discover over !\n"</span>, __LINE__);  </li><li>      </li><li class="alt">    <span class="keyword">return</span> result;    </li><li>}    </li></ol> 
 </div> 
 <pre><code class="language-cpp">int main()  
{  
	printf("[%s][%d][%s][%s] start \n", __FILE__, __LINE__, __TIME__, __func__);

	int result = 0;  
	wsdd__ProbeType req;
	struct __wsdd__ProbeMatches resp;
	wsdd__ScopesType sScope;
	struct SOAP_ENV__Header header;  
	
	struct soap *soap;  
	soap = soap_new();  
	if(NULL == soap )  
	{  
		printf("sopa new error\r\n");  
		return -1;  
	}  

	soap-&gt;recv_timeout = 10;  
	soap_set_namespaces(soap, namespaces);  
	soap_default_SOAP_ENV__Header(soap, &amp;header);  

	uuid_t uuid;
	char guid_string[100];
	uuid_generate(uuid);
	uuid_unparse(uuid, guid_string);

	header.wsa__MessageID = guid_string; 
	header.wsa__To = "urn:schemas-xmlsoap-org:ws:2005:04:discovery";  
	header.wsa__Action = "http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe";  
	soap-&gt;header = &amp;header;  
	
	soap_default_wsdd__ScopesType(soap, &amp;sScope);  
	sScope.__item = "";  
	soap_default_wsdd__ProbeType(soap, &amp;req);  
	req.Scopes = &amp;sScope;  
	req.Types = ""; //"dn:NetworkVideoTransmitter";  

	int i = 0;  	
       result = soap_send___wsdd__Probe(soap, MULTICAST_ADDRESS, NULL, &amp;req);  
       while(result == SOAP_OK)  
       {  
		result = soap_recv___wsdd__ProbeMatches(soap, &amp;resp);  
		if(result == SOAP_OK)  
		{  
			if(soap-&gt;error)  
			{  
				printf("soap error 1: %d, %s, %s\n", soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));  
				result = soap-&gt;error;  
			}  
			else  
			{  
				printf("guog *********************************************\r\n");  
				if(soap-&gt;header-&gt;wsa__MessageID)  
				{  
					printf("MessageID   : %s\r\n", soap-&gt;header-&gt;wsa__MessageID);  
				}  
				if(soap-&gt;header-&gt;wsa__RelatesTo &amp;&amp; soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item)  
				{  
					printf("RelatesTo   : %s\r\n", soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item);  
				}  
				if(soap-&gt;header-&gt;wsa__To)  
				{  
					printf("To          : %s\r\n", soap-&gt;header-&gt;wsa__To);  
				}  
				if(soap-&gt;header-&gt;wsa__Action)  
				{  
					printf("Action      : %s\r\n", soap-&gt;header-&gt;wsa__Action);  
				}  

				for(i = 0; i &lt; resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch; i++)  
				{  
					printf("__sizeProbeMatch        : %d\r\n", resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch);  
					printf("wsa__EndpointReference       : %p\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;wsa__EndpointReference);  
					printf("Target EP Address       : %s\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;wsa__EndpointReference.Address);  
					printf("Target Type             : %s\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Types);  
					printf("Target Service Address  : %s\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs);  
					printf("Target Metadata Version : %d\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;MetadataVersion);  
					if(resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Scopes)  
					{  
						printf("Target Scopes Address   : %s\r\n", resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;Scopes-&gt;__item);  
					}  
				}
			}  
		}  
		else if (soap-&gt;error)  
		{  
			printf("[%d] soap error 2: %d, %s, %s\n", __LINE__, soap-&gt;error, *soap_faultcode(soap), *soap_faultstring(soap));  
			result = soap-&gt;error;  
		}  
       }  

	soap_destroy(soap); 
	soap_end(soap); 
	soap_free(soap);

	printf("[%d] guog discover over !\n", __LINE__);
	
	return result;  
}  </code></pre> 
 <p><span style="font-size:18px">6.<span style="font-family:宋体">将</span><span style="font-family:Calibri">wsdd.nsmap</span><span style="font-family:宋体">改为</span><span style="font-family:Calibri">nsmap.h</span><span style="font-family:宋体">，并删除其余的</span><span style="font-family:Calibri">*.nsmap(</span><span style="font-family:宋体">都一样</span><span style="font-family:Calibri">)</span></span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">7.<span style="font-family:宋体">编写</span><span style="font-family:Calibri">makefile</span><span style="font-family:宋体">文件。注意在</span><span style="font-family:Calibri">makefile</span><span style="font-family:宋体">中打开开关</span><span style="font-family:Calibri">DEBUG</span><span style="font-family:宋体">，以便跟踪日志。</span></span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">8.tcpdump<span style="font-family:宋体">为</span><span style="font-family:Calibri">gcc</span><span style="font-family:宋体">环境的抓包工具，调试的时候用。</span></span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">make编译通过，运行，客户端发现功能<span style="font-family:Calibri">ok</span><span style="font-family:宋体">；</span></span></p> 
 <p><span style="font-family:宋体; font-size:18px"><img alt="" src="https://images2.imgbox.com/22/75/eHKRkE3X_o.jpg"></span></p> 
 <p><span style="font-size:18px">    但是服务端的发现功能却不行；别急，这是由于SOAP<span style="font-family:宋体">的版本</span>问题；<span style="font-family:Calibri">soap</span><span style="font-family:宋体">的版本是根据命名空间来自动确定的；在</span><span style="font-family:Calibri">soap</span><span style="font-family:宋体">结构体的</span><span style="font-family:Calibri">version</span><span style="font-family:宋体">字段表示</span><span style="font-family:Calibri">soap</span><span style="font-family:宋体">版本；</span></span></p> 
 <p><span style="font-size:18px">以下命名空间表示<span style="font-family:Calibri">SOAP1.1</span><span style="font-family:宋体">版本：</span></span></p> 
 <p><span style="font-size:14px">{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},</span></p> 
 <p><span style="font-size:14px">{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL}, //1.1</span></p> 
 <p><span style="font-size:18px"></span></p> 
 <p><span style="font-size:18px">以下命名空间表示<span style="font-family:Calibri">SOAP1.2</span><span style="font-family:宋体">版本：</span></span></p> 
 <p><span style="font-size:14px">{"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},</span></p> 
 <p><span style="font-size:14px">{"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},  //1.2</span></p> 
 <p><span style="font-size:18px">    注意确定自己当前的命名空间。我们用<span style="font-family:Calibri">SOAP1.2</span><span style="font-family:宋体">版本才能被测试工具发现</span><span style="font-family:Calibri">(ONVIF Device Test Tool version 13.06)</span><span style="font-family:宋体">。</span></span></p> 
 <p><span style="font-size:18px">不清楚可以查看<span style="font-family:Calibri">soap_set_namespaces</span><span style="font-family:宋体">接口和</span><span style="font-family:Calibri">soap_set_local_namespaces</span><span style="font-family:宋体">接口；</span></span></p> 
 <p><span style="font-size:18px">于是将nsmap.h中的命名空间前两行改为：</span></p> 
 <p><span style="font-size:14px">{"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},</span></p> 
 <p><span style="font-size:14px">{"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},  //1.2</span></p> 
 <p><span style="font-size:18px">再编译运行，发现功能ok<span style="font-family:宋体">。</span></span></p> 
 <p> <img width="574" height="460" alt="" src="https://images2.imgbox.com/83/8f/e16t2QbG_o.jpg"></p> 
 <p> </p> 
 <p><span style="font-size:14px">最后，将所用的工具和源码提供给大家，大家根据需要下载。</span></p> 
 <p><br> <span style="font-size:14px">onvif测试工具V13.06：</span><a target="_blank" href="http://download.csdn.net/detail/u011597695/6288593" rel="noopener noreferrer"><span style="font-size:14px">http://download.csdn.net/detail/u011597695/6288593</span></a></p> 
 <p><br> <span style="font-size:14px">gsoap 2.8.16版本： </span><a target="_blank" href="http://download.csdn.net/detail/u011597695/6288615" rel="noopener noreferrer"><span style="font-size:14px">http://download.csdn.net/detail/u011597695/6288615</span></a></p> 
 <p><br> <span style="font-size:14px">onvif v2.4版本的wsdl文件：</span><a target="_blank" href="http://download.csdn.net/detail/u011597695/6288627" rel="noopener noreferrer"><span style="font-size:14px">http://download.csdn.net/detail/u011597695/6288627</span></a></p> 
 <p><br> <span style="font-size:14px">onvif v2.4版本的wsdl文件（适于离线生成源码）：</span><a target="_blank" href="http://download.csdn.net/detail/u011597695/6288647" rel="noopener noreferrer"><span style="font-size:14px">http://download.csdn.net/detail/u011597695/6288647</span></a></p> 
 <p><br> <span style="font-size:14px">onvif源代码V2.4：</span><a target="_blank" href="http://download.csdn.net/detail/u011597695/6288663" rel="noopener noreferrer"><span style="font-size:14px">http://download.csdn.net/detail/u011597695/6288663</span></a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2f02d5aa7a4fcf01c3a83f364982a2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Perl的缘起</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/523b0968c3f9a26a8ccbdf8fcab73519/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Onvif开发之Linux下gsoap的使用及移植</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>