<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java aop日志记录_AOP实现日志记录功能 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java aop日志记录_AOP实现日志记录功能" />
<meta property="og:description" content="场景：整个系统的DML操作需要记录日志
记录内容：1 操作人 2 操作时间 3 操作类型(登录 新增 修改 删除) 4 操作描述 5 详细请求数据(varchar2()) 6 操作IP ==&gt;日志表
实现：
原来方式：在每个方法的里面编写记录日志代码；
缺点：代码重复 ，与原有逻辑耦合度高。
AOP: 将日志记录功能提取到切面中。动态切入到需要日志记录的方法上即可；
优点： 解耦合，代码复用。
1) 先写一个日志切面LogAspect.java；
//日志切面
@Component//对象由spring管理
@Aspect//切面注解
public classLogAspect {//定义切入点，切入到添加了LogData注解的方法上
@Pointcut(&#34;@annotation(aop.LogData)&#34;)public voidpointCut(){}/**
* 记录日志的切面方法
* 在该方法中定义统一的日志记录逻辑
* @param joinPoint*/@Before(&#34;pointCut()&#34;)public voidlog(JoinPoint joinPoint){
System.out.println(&#34;进入日志Aspect&#34;);
}
}
2)写一个日志信息LogData.java；
//自定义日志注解
@Target({ElementType.METHOD})//指定作用的目标对象(可以添加的位置)
@Retention(RetentionPolicy.RUNTIME)//指定在运行期间起作用
public@interface LogData {//定义注解中的属性
String description() default &#34;&#34;;//日志类型
intlogType();
}
3)在控制层方法上写上注解，加上描述信息，描述日志；
@LogData(logType = 1,description = &#34;学生信息修改&#34;)
@RequestMapping(&#34;/update&#34;)publicString update(Integer id,ModelMap modelMap){//查询用户信息，展示到页面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/79bfc997dee6478fb245f11adf35cef4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-13T16:57:45+08:00" />
<meta property="article:modified_time" content="2021-02-13T16:57:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java aop日志记录_AOP实现日志记录功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>场景：整个系统的DML操作需要记录日志</p> 
 <p>记录内容：1 操作人 2 操作时间 3 操作类型(登录 新增 修改 删除) 4 操作描述  5 详细请求数据(varchar2()) 6 操作IP  ==&gt;日志表</p> 
 <p>实现：</p> 
 <p>原来方式：在每个方法的里面编写记录日志代码；</p> 
 <p>缺点：代码重复 ，与原有逻辑耦合度高。</p> 
 <p align="center"><img src="https://images2.imgbox.com/54/25/9kCOKoL9_o.png" alt="0b76602f4f9e08cd53263fbdb0b4ad5e.png"></p> 
 <p>AOP: 将日志记录功能提取到切面中。动态切入到需要日志记录的方法上即可；</p> 
 <p>优点： 解耦合，代码复用。</p> 
 <p>1) 先写一个日志切面LogAspect.java；</p> 
 <p>//日志切面</p> 
 <p>@Component//对象由spring管理</p> 
 <p>@Aspect//切面注解</p> 
 <p>public classLogAspect {//定义切入点，切入到添加了LogData注解的方法上</p> 
 <p>@Pointcut("@annotation(aop.LogData)")public voidpointCut(){}/**</p> 
 <p>* 记录日志的切面方法</p> 
 <p>* 在该方法中定义统一的日志记录逻辑</p> 
 <p>* @param joinPoint*/@Before("pointCut()")public voidlog(JoinPoint joinPoint){<!-- --></p> 
 <p>System.out.println("进入日志Aspect");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>2)写一个日志信息LogData.java；</p> 
 <p>//自定义日志注解</p> 
 <p>@Target({ElementType.METHOD})//指定作用的目标对象(可以添加的位置)</p> 
 <p>@Retention(RetentionPolicy.RUNTIME)//指定在运行期间起作用</p> 
 <p>public@interface LogData {//定义注解中的属性</p> 
 <p>String description() default "";//日志类型</p> 
 <p>intlogType();</p> 
 <p>}</p> 
 <p>3)在控制层方法上写上注解，加上描述信息，描述日志；</p> 
 <p>@LogData(logType = 1,description = "学生信息修改")</p> 
 <p>@RequestMapping("/update")publicString update(Integer id,ModelMap modelMap){//查询用户信息，展示到页面</p> 
 <p>Student student=studentService.findById(id);</p> 
 <p>modelMap.put("student",student);return "update.jsp";</p> 
 <p>}</p> 
 <p>要想起作用，还要在springmvc.xml配置文件中配置AOP注解；</p> 
 <p>二、自定义注解</p> 
 <p>枚举：jdk1.5之后存在的一种数据类型。用来定义有限个对象。 enum</p> 
 <p>语法：</p> 
 <p>Public enum 类名{<!-- --></p> 
 <p>对象定义;</p> 
 <p>类的成员定义</p> 
 <p>}</p> 
 <p>调用: 类名.对象名 获取枚举对象。</p> 
 <p>1)创建一个LogType.java文件来写枚举；</p> 
 <p>/**</p> 
 <p>* 日志枚举类型</p> 
 <p>* 枚举是一个特殊的类</p> 
 <p>* class 可以创建n个对象</p> 
 <p>* 枚举类型的对象是固定的*/</p> 
 <p>public enumLogType {//创建枚举对象，对象的个数是有限的，对象与对象之间用逗号隔开</p> 
 <p>LOGIN(1),DELETE(2),UPDATE(3),INSERT(4);//可以定义任意的方法和属性，与普通类类似</p> 
 <p>private final inttype;//构造方法</p> 
 <p>LogType(inttype) {this.type =type;</p> 
 <p>}public intgetType() {returntype;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>2)日志的注解也需要改变为枚举类型的，在LogData.java文件中；</p> 
 <p>/**</p> 
 <p>* 自定义注解*/@Target({ElementType.METHOD,ElementType.FIELD})//指定作用的目标对象(可以添加的位置)</p> 
 <p>@Retention(RetentionPolicy.RUNTIME)public@interface LogData {//定义注解中的属性</p> 
 <p>String description() default "";//日志类型 1、登录 2、删除 3、修改 4、插入</p> 
 <p>LogType logType();</p> 
 <p>}</p> 
 <p>3)调用日志对象，在控制层中；</p> 
 <p>@LogData(logType = LogType.DELETE,description = "学生信息删除")</p> 
 <p>@RequestMapping("/delete")publicString delete(Integer id){<!-- --></p> 
 <p>studentService.delete(id);return "redirect:list";</p> 
 <p>}</p> 
 <p>@LogData(logType= LogType.UPDATE,description = "学生信息修改")</p> 
 <p>@RequestMapping("/update2")publicString update2(Integer id,ModelMap modelMap){<!-- --></p> 
 <p>Student student=studentService.selectById(id);</p> 
 <p>modelMap.put("student",student);return "update.jsp";</p> 
 <p>}</p> 
 <p>@LogData(logType= LogType.INSERT,description = "学生信息新增")</p> 
 <p>@RequestMapping("/insert")publicString insert(Student student){<!-- --></p> 
 <p>studentService.insert(student);return "redirect:list";</p> 
 <p>}</p> 
 <p>4)写LogAspect.java文件；</p> 
 <p>@Component//对象由spring管理</p> 
 <p>@Aspect//切面注解</p> 
 <p>public classLogAspect {private static final Logger LOGGER = LogManager.getLogger(LogAspect.class);//定义切入点，切入到添加了LogData注解的方法上</p> 
 <p>@Pointcut("@annotation(aop.LogData)")public voidpointCut(){<!-- --></p> 
 <p>}/**</p> 
 <p>* 记录日志的切面方法</p> 
 <p>* 在该方法中定义统一的日志记录逻辑</p> 
 <p>* @param joinPoint*/@Before("pointCut()")public voidlog(JoinPoint joinPoint){<!-- --></p> 
 <p>System.out.println("进入日志Aspect");//获取到方法签名</p> 
 <p>MethodSignature signature=(MethodSignature) joinPoint.getSignature();//获取到连接点方法对象</p> 
 <p>Method method=signature.getMethod();//获取方法上面特定的注解</p> 
 <p>LogData annotation=method.getAnnotation(LogData.class);</p> 
 <p>LogType logType=annotation.logType();</p> 
 <p>String description=annotation.description();</p> 
 <p>LOGGER.info("获取到注解内容：logType="+logType.getType()+",description:"+description);//aop中获取request</p> 
 <p>ServletRequestAttributes requestAttributes=(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</p> 
 <p>HttpServletRequest request=requestAttributes.getRequest();</p> 
 <p>HttpSession session=request.getSession();//获取操作人</p> 
 <p>Student student= (Student) session.getAttribute("student");//获取请求数据</p> 
 <p>Map parameterMap=request.getParameterMap();//将对象转换成json字符串==&gt;存储到请求数据字段中//jackSon json字符串操作</p> 
 <p>ObjectMapper objectMapper=newObjectMapper();try{<!-- --></p> 
 <p>String s=objectMapper.writeValueAsString(parameterMap);</p> 
 <p>LOGGER.info("请求数据："+s);</p> 
 <p>}catch(JsonProcessingException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}//todo 将日志信息保存到数据库 LogController service mapper jsp</p> 
 <p>}</p> 
 <p>}</p> 
 <p>三、枚举</p> 
 <p>枚举可用于switch语句中</p> 
 <p>public classT {public static voidmain(String[] args) {<!-- --></p> 
 <p>test(LogType.DELETE);//获取到枚举对象</p> 
 <p>LogType logType =LogType.DELETE;//获取到对象之后，与普通对象操作方式一样</p> 
 <p>int type =logType.getType();</p> 
 <p>}/**</p> 
 <p>* 枚举类型在switch中的使用</p> 
 <p>* @param logType*/</p> 
 <p>public static voidtest(LogType logType) {switch(logType){caseLOGIN:</p> 
 <p>System.out.println("登录操作");break;caseDELETE:</p> 
 <p>System.out.println("删除操作");break;caseINSERT:</p> 
 <p>System.out.println("插入操作");break;caseUPDATE:</p> 
 <p>System.out.println("修改操作");break;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>四、枚举还是实现单例模式的最佳方式</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a455c54b5d7829acc71bdc2294d33523/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[cJSON教程]02：简单使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d645fcd79e5bc6b60b7371289b03818d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;获取数据类型字节数和范围</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>