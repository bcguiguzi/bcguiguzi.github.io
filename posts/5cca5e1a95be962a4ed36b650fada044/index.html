<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【华为机试在线训练】Day 7 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【华为机试在线训练】Day 7" />
<meta property="og:description" content="题目描述 请实现如下接口
/* 功能：四则运算
* 输入：strExpression：字符串格式的算术表达式，如: &#34;3&#43;2*{1&#43;2*[-4/(8-6)&#43;7]}&#34;
* 返回：算术表达式的计算结果
*/
public static int calculate(String strExpression)
{
/* 请实现*/
return 0;
} 约束：
pucExpression字符串中的有效字符包括[‘0’-‘9’],‘&#43;’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。
pucExpression算术表达式的有效性由调用者保证; 输入描述: 输入一个算术表达式
输出描述: 得到计算结果
//先中缀转后缀再计算后缀表达式的值，需要注意的是对于‘-’为一元运算符的处理和数字//的位数做一个记录。当看到python只有一行代码时，吐了一口老血。。。 #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;stack&gt; using namespace std; int main() { string s; while (cin &gt;&gt; s) { stack&lt;char&gt; opera; vector&lt;int&gt; numcnt;//用来保存每个数字的位数，以保证计算后缀表达式时的正确性 string s1;//后缀表达式 //中缀表达式转后缀表达式 for (int i = 0;i&lt;s.size();i&#43;&#43;) { if (s[i] &gt;= &#39;0&#39;&amp;&amp;s[i] &lt;= &#39;9&#39;) { int tmp = 0; while (s[i] &gt;= &#39;0&#39;&amp;&amp;s[i] &lt;= &#39;9&#39;) { tmp&#43;&#43;; s1 &#43;= s[i]; i&#43;&#43;; } i--; numcnt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5cca5e1a95be962a4ed36b650fada044/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-06T15:45:42+08:00" />
<meta property="article:modified_time" content="2018-08-06T15:45:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【华为机试在线训练】Day 7</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>题目描述</h3> 
<p>请实现如下接口</p> 
<p>    /* 功能：四则运算</p> 
<p>     * 输入：strExpression：字符串格式的算术表达式，如: "3+2*{1+2*[-4/(8-6)+7]}"</p> 
<p>         * 返回：算术表达式的计算结果</p> 
<p>     */</p> 
<p>    <strong>public</strong> <strong>static</strong> <strong>int</strong> calculate(String strExpression)</p> 
<p>    {<!-- --></p> 
<p>        /* 请实现*/</p> 
<p>        <strong>return</strong> 0;</p> 
<p>    } </p> 
<p>约束：</p> 
<ol><li> <p>pucExpression字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。</p> </li><li> <p>pucExpression算术表达式的有效性由调用者保证; </p> </li></ol> 
<h3>输入描述:</h3> 
<p>输入一个算术表达式</p> 
<h3>输出描述:</h3> 
<p>得到计算结果</p> 
<p><img alt="" class="has" height="268" src="https://images2.imgbox.com/aa/16/O9IJ8TIU_o.png" width="372"></p> 
<pre class="has"><code>//先中缀转后缀再计算后缀表达式的值，需要注意的是对于‘-’为一元运算符的处理和数字//的位数做一个记录。当看到python只有一行代码时，吐了一口老血。。。
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
using namespace std;
int main() {
    string s;
    while (cin &gt;&gt; s) {
        stack&lt;char&gt; opera;
        vector&lt;int&gt; numcnt;//用来保存每个数字的位数，以保证计算后缀表达式时的正确性
        string s1;//后缀表达式
        //中缀表达式转后缀表达式
        for (int i = 0;i&lt;s.size();i++) {
            if (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9') {
                int tmp = 0;
                while (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9') {
                    tmp++;
                    s1 += s[i];
                    i++;
                }
                i--;
                numcnt.push_back(tmp);
            }
            else if (s[i] == '-' || s[i] == '+') {
                if (s[i] == '-' &amp;&amp; (s[i - 1] == '(' || s[i - 1] == '[' || s[i - 1] == '{'))
                    s1 += '0';
                while (!opera.empty()&amp;&amp;(opera.top() == '*' || opera.top() == '/' || opera.top() == '+' || opera.top() == '-')) {
                    s1 += opera.top();
                    opera.pop();
                }
                opera.push(s[i]);
            }
            else if (s[i] == '*' || s[i] == '/') {
                while (!opera.empty()&amp;&amp;(opera.top() == '*' || opera.top() == '/')) {
                    s1 += opera.top();
                    opera.pop();
                }
                opera.push(s[i]);
            }
            else if (s[i] == '(' || s[i] == '[' || s[i] == '{')
                opera.push(s[i]);
            else if (s[i] == ')') {
                while (opera.top() != '(') {
                    s1 += opera.top();
                    opera.pop();
                }
                opera.pop();
            }
            else if (s[i] == ']') {
                while (opera.top() != '[') {
                    s1 += opera.top();
                    opera.pop();
                }
                opera.pop();
            }
            else if (s[i] == '}') {
                while (opera.top() != '{') {
                    s1 += opera.top();
                    opera.pop();
                }
                opera.pop();
            }
            else
                cout &lt;&lt; "Invalid input!" &lt;&lt; endl;
        }
        while (!opera.empty()) {
            s1 += opera.top();
            opera.pop();
        }
        //计算后缀表达式的值
        stack&lt;int&gt; nums;
        int ind = 0;
        for (int i = 0;i&lt;s1.size();i++) {
            if (s1[i] &gt;= '0'&amp;&amp;s1[i] &lt;= '9') {
                int total = 0;
                while (numcnt[ind]--)
                    total = 10 * total + (s1[i++] - '0');
                i--;
                nums.push(total);
                ind++;
            }          
            else {
                int tmp1 = nums.top();
                nums.pop();
                int tmp2 = nums.top();
                nums.pop();
                if (s1[i] == '+')
                    nums.push(tmp2 + tmp1);
                else if (s1[i] == '-')
                    nums.push(tmp2 - tmp1);
                else if (s1[i] == '*')
                    nums.push(tmp2*tmp1);
                else
                    nums.push(tmp2 / tmp1);
            }
        }
        cout &lt;&lt; nums.top() &lt;&lt; endl;    
    }
}</code></pre> 
<hr> 
<hr> 
<p>参考：<a href="https://blog.csdn.net/shizheng163/article/details/50988023">https://blog.csdn.net/shizheng163/article/details/50988023</a></p> 
<h3>题目描述</h3> 
<p>Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离的算法是首先由俄国科学家Levenshtein提出的，故又叫Levenshtein Distance。</p> 
<p>Ex：</p> 
<p>字符串A:abcdefg</p> 
<p>字符串B: abcdef</p> 
<p>通过增加或是删掉字符”g”的方式达到目的。这两种方案都需要一次操作。把这个操作所需要的次数定义为两个字符串的距离。</p> 
<p>要求：</p> 
<p>给定任意两个字符串，写出一个算法计算它们的编辑距离。</p> 
<p> </p> 
<p>请实现如下接口</p> 
<p>/*  功能：计算两个字符串的距离</p> 
<p> *  输入： 字符串A和字符串B</p> 
<p> *  输出：无</p> 
<p> *  返回：如果成功计算出字符串的距离，否则返回-1</p> 
<p> */</p> 
<p>     <strong>public </strong>  <strong>static </strong>  <strong>int </strong> calStringDistance (String charA, String  charB)</p> 
<p>    {<!-- --></p> 
<p>        <strong>return </strong> 0;</p> 
<p>    }  </p> 
<p> </p> 
<h3>输入描述:</h3> 
<p>输入两个字符串</p> 
<h3>输出描述:</h3> 
<p>得到计算结果</p> 
<p><img alt="" class="has" height="297" src="https://images2.imgbox.com/fc/65/n73NvtXC_o.png" width="265"></p> 
<pre class="has"><code>//典型的动态规划优化编辑器问题
//参考博客 http://blog.csdn.net/shizheng163/article/details/50988023
#include&lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int calStringDistance(string a,string b){
    int n = (int)a.size(),m = (int)b.size();
    vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(m+1,0));
    dp[0][0] = 0;//dp[x][y]代表将a字符串前x个字符修改成b字符串前y个字符
    for (int i=1; i&lt;=m; ++i) dp[0][i] = i;
    for (int i=1; i&lt;=n; ++i) dp[i][0] = i;
    for (int i=1; i&lt;=n; ++i) {
        for (int j=1; j&lt;=m; ++j) {
            int one = dp[i-1][j] +1,two = dp[i][j-1]+1,three = dp[i-1][j-1];
            if(a[i-1]!=b[j-1]) three+=1;
            dp[i][j] = min(min(one,two),three);
        }
    }
    return dp[n][m];
}
int main(){
    string a,b;
    while(cin&gt;&gt;a&gt;&gt;b)
        cout&lt;&lt;calStringDistance(a, b)&lt;&lt;endl;
    return 0;
}</code></pre> 
<hr> 
<hr> 
<h3>题目描述</h3> 
<p>题目描述</p> 
<p>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。</p> 
<p> </p> 
<p>输入</p> 
<p>每个用例包含二个整数M和N。0&lt;=m&lt;=10，1&lt;=n&lt;=10。</p> 
<p> </p> 
<p>样例输入</p> 
<p>7 3</p> 
<p> </p> 
<p>样例输出</p> 
<p>8</p> 
<p> </p> 
<p>/**</p> 
<p>* 计算放苹果方法数目</p> 
<p><br> * 输入值非法时返回-1</p> 
<p>* 1 &lt;= m,n &lt;= 10</p> 
<p>* @param m 苹果数目</p> 
<p>* @param n 盘子数目数</p> 
<p>* @return 放置方法总数</p> 
<p>*</p> 
<p>*/</p> 
<p>public static int count(int m, int n)</p> 
<h3>输入描述:</h3> 
<p>输入两个int整数</p> 
<h3>输出描述:</h3> 
<p>输出结果，int型</p> 
<p><img alt="" class="has" height="285" src="https://images2.imgbox.com/88/ff/38pBifuZ_o.png" width="259"></p> 
<pre class="has"><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
using namespace std;
int count1(int m,int n)
{
    if(m==0 || n==1)
    {
    return 1;
    }
    if(m&lt;n)
    {
        return count1(m,m);
    }
    else
    {
        return (count1(m,n-1)+count1(m-n,n));
    }
}
int main()
{
    int m;
    int n;
    while(cin&gt;&gt;m&gt;&gt;n)
    {
        cout&lt;&lt;count1(m,n)&lt;&lt;endl;
    }
    return 0;
}
/*  解题分析：
        设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，
        当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m)　　
        当n&lt;=m：不同的放法可以分成两类：
        1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1); 
        2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).
        而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n)
    递归出口条件说明：
        当n=1时，所有苹果都必须放在一个盘子里，所以返回１；
        当没有苹果可放时，定义为１种放法；
        递归的两条路，第一条n会逐渐减少，终会到达出口n==1;
        第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m)　所以终会到达出口m==0．
*/</code></pre> 
<hr> 
<hr> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/247145456648b5c9682977659437d953/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库之事务详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84cf7af7aba1e60c35093f6c0a4c44e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微擎应用插件整合DIY官网上线了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>