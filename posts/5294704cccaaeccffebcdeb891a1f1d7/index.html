<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Javaweb做的页面置换算法模拟实验平台 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Javaweb做的页面置换算法模拟实验平台" />
<meta property="og:description" content="Javaweb做的页面置换算法模拟实验平台 在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。
在学习完操作系统之后，为了对页面置换算法有更深一步的认识，于是做了关于OPT、FIFO、LRU、LFU四种页面置换算法的模拟过程，为了使展示效果更加形象，采取了在web网页上显示。
这四种页面置换算法相信大家已经很熟悉了，下面简单介绍之后就放上自己的界面效果截图，有感兴趣的我们可以一起交流。
OPT
最佳置换算法（OPT）就是从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。
FIFO
先进先出置换算法，这是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，成为替换指针，使它总是指向在内存中驻留时间最久的页面。
LRU
最近最久未使用置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰，该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面予以淘汰。
LFU
LFU(Least Frequently Used)最近最少使用算法，顾名思义，算法的主要思想是如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。
在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如 100 ns，在 1 ms 时间内可能对某页面连续访问成千上万次， 因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置 1，再每隔一定时间(例如 100 ms)右移一次。 这样，在最近一段时间使用最少的页面将是∑Ri 最小的页。然而LFU 算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，访问一次和访问 10000 次是等效的。
界面运行截图
1.主界面
2.模拟一次设置参数
3.模拟一次中间结果
4.保存实验数据
（1）多次结果
（2）单次实验结果
5.模拟多次试验数据结果
（1）使用默认参数
（2）使用自定义参数
中间还有一些关于数据库的部分本人是利用可视化工具Navicat连接mysql处理的，也可以使用其他工具。
这就是我做的系统的大部分截图，有兴趣的伙伴我们可以一起交流，今后可能还会增加一些其他置换算法的模拟过程（待更）。
附加鸡汤一句：
这世上有两样东西是别人抢不走的：一是藏在心中的梦想，二是读进大脑的知识。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5294704cccaaeccffebcdeb891a1f1d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-08T16:35:40+08:00" />
<meta property="article:modified_time" content="2020-08-08T16:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Javaweb做的页面置换算法模拟实验平台</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Javaweb_0"></a>Javaweb做的页面置换算法模拟实验平台</h3> 
<p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。<br> 在学习完操作系统之后，为了对页面置换算法有更深一步的认识，于是做了关于OPT、FIFO、LRU、LFU四种页面置换算法的模拟过程，为了使展示效果更加形象，采取了在web网页上显示。<br> 这四种页面置换算法相信大家已经很熟悉了，下面简单介绍之后就放上自己的界面效果截图，有感兴趣的我们可以一起交流。<br> <strong>OPT</strong></p> 
<p>最佳置换算法（OPT）就是从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p> 
<p><strong>FIFO</strong></p> 
<p>先进先出置换算法，这是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，成为替换指针，使它总是指向在内存中驻留时间最久的页面。</p> 
<p><strong>LRU</strong></p> 
<p>最近最久未使用置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰，该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面予以淘汰。</p> 
<p><strong>LFU</strong></p> 
<p>LFU(Least Frequently Used)最近最少使用算法，顾名思义，算法的主要思想是如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。</p> 
<p>在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如 100 ns，在 1 ms 时间内可能对某页面连续访问成千上万次， 因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置 1，再每隔一定时间(例如 100 ms)右移一次。 这样，在最近一段时间使用最少的页面将是∑Ri 最小的页。然而LFU 算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，访问一次和访问 10000 次是等效的。</p> 
<p><strong>界面运行截图</strong><br> 1.主界面<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/70/24/hbusae52_o.png"></p> 
<p>2.模拟一次设置参数<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/ea/95/6DbHs9PT_o.png"><br> 3.模拟一次中间结果<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/32/0a/kc7If74Y_o.png"><br> 4.保存实验数据<br> （1）多次结果<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/d5/c8/9uno8nfc_o.png"><br> （2）单次实验结果<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/64/a7/fq5EdfQ1_o.png"><br> 5.模拟多次试验数据结果<br> （1）使用默认参数<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/d1/2a/U4rC6CWU_o.png"><br> （2）使用自定义参数<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/47/09/OXjH9GMY_o.png"><br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/cd/7d/bcpOlGbS_o.png"><br> 中间还有一些关于数据库的部分本人是利用可视化工具Navicat连接mysql处理的，也可以使用其他工具。</p> 
<p>这就是我做的系统的大部分截图，有兴趣的伙伴我们可以一起交流，今后可能还会增加一些其他置换算法的模拟过程（待更）。</p> 
<p>附加鸡汤一句：<br> 这世上有两样东西是别人抢不走的：一是藏在心中的梦想，二是读进大脑的知识。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7d9a5819f35ff4617dd525a2c6bf08f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">逆向工程核心原理源代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/abe8222a2be487e7d557418d2c0506cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">遍历vector容器的4种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>