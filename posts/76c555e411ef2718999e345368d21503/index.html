<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java9到Java13各版本新特性代码全部详解(全网独家原创) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java9到Java13各版本新特性代码全部详解(全网独家原创)" />
<meta property="og:description" content="Java现在已经发展到了Java13了（正式版本），相信很多朋友还对各个版本还不是很熟悉，这里面专门把Java9到Java13各个版本的一些新特性做了一些详细讲解。我在网上也找了很多，但基本都是官方文档的CV，没有任何代码演示，而且官方的示例代码也不是很好找得到，官方API目前还是Java10，官方文档真是坑啊。所以我在这里专门写了一篇文章，主要针对平时开发与有关的功能Java9到Java13各个版本都做了代码详细讲解。
【PS】：这个季节太冷了，南方湿冷，我的手都生冻疮了，看在年前最后几天了，没办法，我最后选择去网吧花了几天时间，网费都花了好几百块，为了打造这篇干货不惜下血本啊。终于奋战几天写出来了这篇文章。每一个语法细节都经过实例演示过的，我特意把每个版本的Open JDK都下载了一遍，体验里面的细节差距和新特性。
希望大家点赞，评论和收藏三连，也不负我的一片苦心，谢谢大家了。
想获得更多干货，欢迎大家多多关注我的博客。本文为作者AWeiLoveAndroid原创，未经授权，严禁转载。
文章目录 一、Java 9Java 9 集合工厂方法REPL (JShell)接口支持私有方法和私有静态方法：改进的 Stream API和Optional 类改进的 CompletableFuture API异常处理机制改进try-with-resources改进的 @Deprecated 注解钻石操作符(Diamond Operator“&lt;&gt;”)Unicode 7.0扩展支持： 二、Java 10var 局部变量类型推断支持Unicode 8.0。 三、Java 11局部变量的语法lambda参数启动单文件源代码程序 四、Java 12对 switch 语句进行扩展： 五、Java 13switch表达式预览版Text Blocks预览版（文字块） 一、Java 9 【注：】Java9的更新是最多的，这个需要特别注意学一下。
Java 9 集合工厂方法 示例：
public static void main(String[] args) { Set&lt;String&gt; set = Set.of(&#34;set1&#34;, &#34;set2&#34;, &#34;set3&#34;); // set: [set1, set3, set2] System.out.println(&#34;set: &#34; &#43; set); Map&lt;String, String&gt; maps1 = Map.of( &#34;map1&#34;,&#34;Apple&#34;, &#34;map2&#34;,&#34;Orange&#34;,&#34;map3&#34;,&#34;Banana&#34;, &#34;map4&#34;,&#34;cherry&#34;); // maps1: {map3=Banana, map2=Orange, map1=Apple, map4=cherry} System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/76c555e411ef2718999e345368d21503/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-17T15:12:41+08:00" />
<meta property="article:modified_time" content="2020-01-17T15:12:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java9到Java13各版本新特性代码全部详解(全网独家原创)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>Java现在已经发展到了Java13了（正式版本），相信很多朋友还对各个版本还不是很熟悉，这里面专门把Java9到Java13各个版本的一些新特性做了一些详细讲解。我在网上也找了很多，但基本都是官方文档的CV，没有任何代码演示，而且官方的示例代码也不是很好找得到，官方API目前还是Java10，官方文档真是坑啊。所以我在这里专门写了一篇文章，主要针对平时开发与有关的功能Java9到Java13各个版本都做了代码详细讲解。</p> 
</blockquote> 
<p>【PS】：这个季节太冷了，<code>南方湿冷，我的手都生冻疮了</code>，看在年前最后几天了，没办法，我最后选择去网吧花了几天时间，网费都花了<code>好几百块</code>，为了打造这篇<code>干货</code>不惜下血本啊。终于奋战几天写出来了这篇文章。每一个语法细节都经过实例演示过的，我特意把每个版本的Open JDK都下载了一遍，体验里面的细节差距和新特性。</p> 
<p><strong>希望大家点赞，评论和收藏三连，也不负我的一片苦心，谢谢大家了。</strong></p> 
<p>想获得更多干货，欢迎大家多多关注我的博客。<code>本文为作者AWeiLoveAndroid原创，未经授权，严禁转载</code>。</p> 
<p><img src="https://images2.imgbox.com/4d/8a/qYEHhOTG_o.png" alt=""></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Java_9_16" rel="nofollow">一、Java 9</a></li><li><ul><li><ul><li><a href="#Java_9__20" rel="nofollow">Java 9 集合工厂方法</a></li><li><a href="#REPL_JShell_129" rel="nofollow">REPL (JShell)</a></li><li><a href="#_148" rel="nofollow">接口支持私有方法和私有静态方法：</a></li><li><a href="#_Stream_APIOptional__221" rel="nofollow">改进的 Stream API和Optional 类</a></li><li><a href="#_CompletableFuture_API_293" rel="nofollow">改进的 CompletableFuture API</a></li><li><a href="#trywithresources_309" rel="nofollow">异常处理机制改进try-with-resources</a></li><li><a href="#_Deprecated__334" rel="nofollow">改进的 @Deprecated 注解</a></li><li><a href="#Diamond_Operator_347" rel="nofollow">钻石操作符(Diamond Operator“&lt;&gt;”)</a></li><li><a href="#Unicode_70_394" rel="nofollow">Unicode 7.0扩展支持：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Java_10_407" rel="nofollow">二、Java 10</a></li><li><ul><li><ul><li><a href="#var__411" rel="nofollow">var 局部变量类型推断</a></li><li><a href="#Unicode_80_424" rel="nofollow">支持Unicode 8.0。</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Java_11_457" rel="nofollow">三、Java 11</a></li><li><ul><li><ul><li><a href="#lambda_460" rel="nofollow">局部变量的语法lambda参数</a></li><li><a href="#_473" rel="nofollow">启动单文件源代码程序</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Java_12_489" rel="nofollow">四、Java 12</a></li><li><ul><li><ul><li><a href="#_switch__491" rel="nofollow">对 switch 语句进行扩展：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Java_13_571" rel="nofollow">五、Java 13</a></li><li><ul><li><ul><li><a href="#switch_573" rel="nofollow">switch表达式预览版</a></li><li><a href="#Text_Blocks_649" rel="nofollow">Text Blocks预览版（文字块）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="Java_9_16"></a>一、Java 9</h2> 
<p>【注：】Java9的更新是最多的，这个需要特别注意学一下。</p> 
<h4><a id="Java_9__20"></a>Java 9 集合工厂方法</h4> 
<p>示例：</p> 
<pre><code>public static void main(String[] args) {
  Set&lt;String&gt; set = Set.of("set1", "set2", "set3");
  // set: [set1, set3, set2]
  System.out.println("set: " + set);
       
  Map&lt;String, String&gt; maps1 = Map.of(
     "map1","Apple", "map2","Orange","map3","Banana", "map4","cherry");
  // maps1: {map3=Banana, map2=Orange, map1=Apple, map4=cherry}        
  System.out.println("maps1: " + maps1);
    
  Map&lt;String, String&gt; maps2 = Map.ofEntries (
           new AbstractMap.SimpleEntry&lt;&gt;("map1","Apple"),
           new AbstractMap.SimpleEntry&lt;&gt;("map2","Orange"),
           new AbstractMap.SimpleEntry&lt;&gt;("map3","Banana"),
           new AbstractMap.SimpleEntry&lt;&gt;("map4","cherry"),
           new AbstractMap.SimpleEntry&lt;&gt;("map5","Apple"),
           new AbstractMap.SimpleEntry&lt;&gt;("map6","Orange"),
           new AbstractMap.SimpleEntry&lt;&gt;("map7","Banana"),
           new AbstractMap.SimpleEntry&lt;&gt;("map8","cherry"),
           new AbstractMap.SimpleEntry&lt;&gt;("map9","Apple"),
           new AbstractMap.SimpleEntry&lt;&gt;("map10","Orange"),
           new AbstractMap.SimpleEntry&lt;&gt;("map11","Banana"),
           new AbstractMap.SimpleEntry&lt;&gt;("map12","cherry")
  );
  // maps2: {map3=Banana, map2=Orange, map1=Apple, map12=cherry, map11=Banana, map10=Orange, 
  // map9=Apple, map8=cherry, map7=Banana, map6=Orange, map5=Apple, map4=cherry}      
  System.out.println("maps2: " + maps2);
}
</code></pre> 
<p>Java9以前的做法：</p> 
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("A");
list.add("B");
list.add("C");

Set&lt;String&gt; set = new HashSet&lt;&gt;();
set.add("A");
set.add("B");
set.add("C");

Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("A","Apple");
map.put("B","Boy");
map.put("C","Cat");
</code></pre> 
<p>Java9可以直接输出集合的内容，在此之前必须遍历集合才能全部获取里面的元素。这是一个很大的改进。</p> 
<p>Java 9 List，Set 和 Map 接口中，新增静态工厂方法可以创建这些集合的不可变实例。</p> 
<p>Java 9 中，可以使用以下方法创建 List，Set 和 Map 的集合对象。重载方法有很多，示例如下：</p> 
<pre><code>static &lt;E&gt; List&lt;E&gt; of()
static &lt;E&gt; List&lt;E&gt; of(E e1)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
static &lt;E&gt; List&lt;E&gt; of(E... elements)

static &lt;E&gt; Set&lt;E&gt; of()
static &lt;E&gt; Set&lt;E&gt; of(E e1)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
static &lt;E&gt; Set&lt;E&gt; of(E... elements)


static &lt;K, V&gt; Map&lt;K, V&gt; of() 
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)
static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)
static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Entry&lt;? extends K, ? extends V&gt;... entries)
</code></pre> 
<p>List ，Set 和Map 接口, of(…) 方法重载了 0 ~ 10 个参数的不同方法 。Map 接口如果超过 10 个参数, 可以使用 ofEntries(…) 方法。</p> 
<h4><a id="REPL_JShell_129"></a>REPL (JShell)</h4> 
<p>REPL(Read Eval Print Loop)意为交互式的编程环境。JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接输入表达式并查看其执行结果。</p> 
<p>例如：</p> 
<p>输入“jshell”打开jshell命令窗口：</p> 
<p><img src="https://images2.imgbox.com/28/9d/0fTPtcxT_o.png" alt="在这里插入图片描述"></p> 
<p>输入“/help”查看帮助信息：</p> 
<p><img src="https://images2.imgbox.com/71/f7/VPGR2U29_o.png" alt=""></p> 
<p>进行运算，创建和使用函数，以及退出：</p> 
<p><img src="https://images2.imgbox.com/8e/e3/A02DMCQr_o.png" alt=""></p> 
<h4><a id="_148"></a>接口支持私有方法和私有静态方法：</h4> 
<p>下图是Java8和java9的接口的变化的对比：</p> 
<p><img src="https://images2.imgbox.com/ca/38/D4EQSksD_o.png" alt="在这里插入图片描述"></p> 
<p>示例如下：</p> 
<pre><code>interface Test{
    String fields = "interface field";

    public abstract void abstractMethods();

    default void defaultMethods() {
        System.out.println("default Method");
        staticMethods();
        privateMethods();
        privateStaticMethods();
     }

    static void staticMethods() {
        System.out.println("static Method");
     }

    private void privateMethods() {
        System.out.println("private Method");
    }
   
    private static void privateStaticMethods() {
        System.out.println("private Static Method");
    }
   
}
</code></pre> 
<p>接口实现类：</p> 
<pre><code>public class TestImpl implements Test{

    @Override
    public void abstractMethods() {
        System.out.println("abstract Method");
    }
    
}
</code></pre> 
<p>测试类：</p> 
<pre><code>public class Demo{
    public static void main(String[] args) {
        TestImpl testImpl = new TestImpl();
        System.out.println(testImpl.fields);
        testImpl.abstractMethods();
        testImpl.defaultMethods();
    }
}
</code></pre> 
<p>测试结果：</p> 
<pre><code>interface field
abstract Method
default Method
static Method
private Method
private Static Method
</code></pre> 
<h4><a id="_Stream_APIOptional__221"></a>改进的 Stream API和Optional 类</h4> 
<p>Java 9 改进的 Stream API ，为 Stream 新增了几个方法：dropWhile、takeWhile、ofNullable，为 iterate 方法新增了一个重载方法，使流处理更容易。</p> 
<p>Optional 类在Java8中引入，它的引入很好的解决空指针异常，在 java 9 中, 添加了stream()，ifPresentOrElse()和or()三个方法来改进它的功能。</p> 
<p>示例如下：</p> 
<pre><code>Stream.of("a","b","c","","e","f").takeWhile(s-&gt;!s.isEmpty())
    .forEach(System.out::print);
System.out.println();
Stream.of("10","20","30","","40","50").dropWhile(s-&gt; !s.isEmpty())
    .forEach(System.out::print);
System.out.println();
IntStream.iterate(3, x -&gt; x &lt; 10, x -&gt; x+ 3).forEach(System.out::print);
System.out.println();
System.out.println(Stream.ofNullable(100).count());
System.out.println(Stream.ofNullable(null).count());
</code></pre> 
<p>结果：</p> 
<pre><code>// abc
// 4050
// 369
// 1
// 0
</code></pre> 
<pre><code>public static void main(String[] args) {
    // stream()用法：
    List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList (
        Optional.of("data1"), 
        Optional.empty(), 
        Optional.of("data2"),
        Optional.empty(),
        Optional.of("data3"));

    List&lt;String&gt; result = list.stream()
    .flatMap(Optional::stream)
    .collect(Collectors.toList());
    // 结果 [data1, data2, data3]
    System.out.println(result); 

  // ifPresentOrElse使用：
  Optional&lt;String&gt; optional = Optional.of("datas");
  // 结果 Value: datas
  optional.ifPresentOrElse( x -&gt; System.out.println("Value: " + x),() -&gt; 
    System.out.println("No data found"));
  optional = Optional.empty();
  // 结果 No data found
  optional.ifPresentOrElse( x -&gt; System.out.println("Value: " + x),() -&gt; 
  System.out.println("No data found"));

    Optional&lt;String&gt; optional1 = Optional.of("datas");
    Supplier&lt;Optional&lt;String&gt;&gt; nullData = () -&gt; Optional.of("No data found");
    optional1 = optional1.or(nullData);
    // Value: datas
    optional1.ifPresent( x -&gt; System.out.println("Value: " + x));

    optional1 = Optional.empty();    
    optional1 = optional1.or(nullData);
    // Value: No data found
    optional1.ifPresent( x -&gt; System.out.println("Value: " + x));

}
</code></pre> 
<h4><a id="_CompletableFuture_API_293"></a>改进的 CompletableFuture API</h4> 
<p>支持 delays 和 timeouts，提升了对子类化的支持，新的工厂方法：</p> 
<p><code>public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</code>：在timeout（单位在java.util.concurrent.Timeunits units中，比如 MILLISECONDS ）前以给定的 value 完成这个 CompletableFutrue。返回这个 CompletableFutrue。</p> 
<p><code>public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</code>：如果没有在给定的 timeout 内完成，就以 java.util.concurrent.TimeoutException 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。</p> 
<p><code>public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture()</code>：使得CompletableFuture可以被更简单的继承</p> 
<p><code>&lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value)</code>：返回一个新的以指定 value 完成的CompletionStage ，并且只支持 CompletionStage 里的接口。</p> 
<p><code>&lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)</code>：返回一个新的以指定异常完成的CompletionStage ，并且只支持 CompletionStage 里的接口。</p> 
<h4><a id="trywithresources_309"></a>异常处理机制改进try-with-resources</h4> 
<p><code>try-with-resources</code> 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p> 
<p>示例如下：</p> 
<pre><code>public static void main(String[] args) throws IOException {
  System.out.println(readData("test"));// 结果：test
}

static String readData(String message) throws IOException {
    Reader inputString = new StringReader(message);
    BufferedReader br = new BufferedReader(inputString); 
    // Java8处理方式：
    // try (BufferedReader br1 = br) {
    //    return br1.readLine();
    // }
    // Java9处理方式：
    try (br) {
      return br.readLine();
    }
}
</code></pre> 
<h4><a id="_Deprecated__334"></a>改进的 @Deprecated 注解</h4> 
<p>Java 9 中注解增加了两个新元素：<strong>since</strong>和<strong>forRemoval</strong>。<br> <code>since</code>: 元素指定已注解的API元素已被弃用的版本。<br> <code>forRemoval</code>: 元素表示注解的 API 元素在将来的版本中被删除，应该迁移 API。<br> 示例如下：</p> 
<pre><code>@Deprecated(since = "1.9", forRemoval = true)
class Test{
}
</code></pre> 
<h4><a id="Diamond_Operator_347"></a>钻石操作符(Diamond Operator“&lt;&gt;”)</h4> 
<p>在 java 9 中， “<code>&lt;&gt;</code>”可以与匿名的内部类一起使用，从而提高代码的可读性。</p> 
<p>示例：</p> 
<pre><code>public class Test {
   public static void main(String[] args) {
      Handler&lt;Integer&gt; intHandler = new Handler&lt;&gt;(1) {
         @Override
         public void handle() {
            System.out.println(content);
         }
      };
      intHandler.handle();
      Handler&lt;? extends Number&gt; intHandler1 = new Handler&lt;&gt;(2) {
         @Override
         public void handle() {
            System.out.println(content);
         }
      };
      intHandler1.handle();
      Handler&lt;?&gt; handler = new Handler&lt;&gt;("test") {
         @Override
         public void handle() {
            System.out.println(content);
         }
      };
 
      handler.handle();    
   }  
}
 
abstract class Handler&lt;T&gt; {
   public T content;
 
   public Handler(T content) {
      this.content = content; 
   }
   
   abstract void handle();
}
</code></pre> 
<p>在java8中，上例中的 newHandler&lt;&gt;后面的&lt;&gt;里面必须带有泛型类型。Java9就不需要了。</p> 
<h4><a id="Unicode_70_394"></a>Unicode 7.0扩展支持：</h4> 
<p>从Java SE 9，升级现有平台的API，支持7.0版本的Unicode标准，主要在以下类中：</p> 
<p>java.lang.Character和java.lang.String<br> java.text包中的Bidi，BreakIterator和Normalizer<br> 此次升级将包括改善双向行为，从而可以更好地显示Unicode 6.3中引入的阿拉伯语和希伯来语等文本。 Unicode 7.0本身将添加大约三千个字符和二十多个脚本。</p> 
<p>更多详情请查看：<br> https://openjdk.java.net/projects/jdk9/</p> 
<hr> 
<h2><a id="Java_10_407"></a>二、Java 10</h2> 
<p>这里重点看我们开发者能够直接体验到的一些功能：</p> 
<h4><a id="var__411"></a>var 局部变量类型推断</h4> 
<p>示例：</p> 
<pre><code>var list = new ArrayList&lt;String&gt;();  // 代表 ArrayList&lt;String&gt;
var stream = list.stream();          // 代表 Stream&lt;String&gt;
</code></pre> 
<p>这种处理将仅限于带有初始值设定项的局部变量，增强的for循环中的索引以及在传统的for循环中声明的局部变量。它不适用于方法形式，构造函数形式，方法返回类型，字段，catch形式或任何其他类型的变量声明。</p> 
<h4><a id="Unicode_80_424"></a>支持Unicode 8.0。</h4> 
<p>增强了java.util.Locale和相关的API，以实现BCP 47语言标签的其他Unicode扩展。</p> 
<p>此次针对BCP 47语言标签扩展包括：</p> 
<ul><li>cu （货币类型）</li><li>fw （一周的第一天）</li><li>rg （区域覆盖）</li><li>tz （时区）</li></ul> 
<p>具体API变更有：</p> 
<ul><li>java.text.DateFormat::get*Instance将根据扩展名返回实例ca，rg和/或tz</li><li>java.text.DateFormatSymbols::getInstance 将根据扩展名返回实例 rg</li><li>java.text.DecimalFormatSymbols::getInstance 将根据扩展名返回实例 rg</li><li>java.text.NumberFormat::get*Instance将根据扩展名nu和/或返回实例rg</li><li>java.time.format.DateTimeFormatter::localizedBy将返回DateTimeFormatter基于扩展情况下ca，rg和/或tz</li><li>java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern将根据rg扩展名返回模式字符串。</li><li>java.time.format.DecimalStyle::of将DecimalStyle根据扩展名返回实例nu，和/或rg</li><li>java.time.temporal.WeekFields::of将WeekFields根据扩展名fw和/或返回实例rg</li><li>java.util.Calendar::{getFirstDayOfWeek,getMinimalDaysInWeek}将根据扩展名fw和/或返回值rg</li><li>java.util.Currency::getInstance将Currency根据扩展名cu和/或返回实例rg</li><li>java.util.Locale::getDisplayName 将返回一个字符串，其中包括这些U扩展名的显示名称</li><li>java.util.spi.LocaleNameProvider 这些U扩展的键和类型将具有新的SPI</li></ul> 
<p>其他特性都是有关垃圾回收，编译器，证书，以及命令工具等有关的，这里就不列举了。</p> 
<p>更多详情请查看：<br> https://openjdk.java.net/projects/jdk/10/</p> 
<hr> 
<h2><a id="Java_11_457"></a>三、Java 11</h2> 
<h4><a id="lambda_460"></a>局部变量的语法lambda参数</h4> 
<p>Java11中的lambda表达式可以为隐式类型，其中类型的形式参数都可以被推断出。对于隐式类型的lambda表达式的形式参数，允许使用保留的类型名称var，以便：<br> <code>(var x, var y) -&gt; x.process(y)</code><br> 等效于：</p> 
<pre><code>(x, y) -&gt; x.process(y) // 这样的对的
(var x, int y) -&gt; x.process(y)  // 这样就会报错
</code></pre> 
<p>其他的lambda用法和Java8里的lambda用法一样。</p> 
<h4><a id="_473"></a>启动单文件源代码程序</h4> 
<p>增强java启动器以运行作为Java源代码的单个文件提供的程序，包括通过“ shebang”文件和相关技术从脚本内部使用该程序。</p> 
<p>从JDK 10开始，java启动器以三种模式运行：启动类文件，启动JAR文件的main类或启动模块的main类。在这里，我们添加了新的第四种模式：启动在源文件中声明的类。</p> 
<p>如果“类名”标识具有.java扩展名的现有文件，则选择源文件模式，并编译和运行该文件。该–source选项可用于指定源代码的源版本。</p> 
<p>如果文件没有.java扩展名，则–source必须使用该选项来强制源文件模式。例如当源文件是要执行的“脚本”并且源文件的名称不遵循Java源文件的常规命名约定时。</p> 
<p>更多详情请查看：<br> https://openjdk.java.net/projects/jdk/11/</p> 
<hr> 
<h2><a id="Java_12_489"></a>四、Java 12</h2> 
<h4><a id="_switch__491"></a>对 switch 语句进行扩展：</h4> 
<p>扩展switch语句，以便可以将其用作语句或表达式，并且两种形式都可以使用“传统”或“简化”作用域并控制流的行为。这些变化将简化日常编码在switch中。这是JDK 12中的预览功能。</p> 
<p>请注意：此JEP已被JDK 13的JEP 354取代。</p> 
<p>普通写法：</p> 
<pre><code>switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}
</code></pre> 
<p>现在引入一种新的switch标签形式，写为“case L -&gt;”，表示如果匹配标签，则只执行标签右边的代码。例如，现在可以编写以前的代码：</p> 
<pre><code>switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);
    case TUESDAY                -&gt; System.out.println(7);
    case THURSDAY, SATURDAY     -&gt; System.out.println(8);
    case WEDNESDAY              -&gt; System.out.println(9);
}
</code></pre> 
<p>再比如局部变量，普通写法是这样的：</p> 
<pre><code>int numLetters;
switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        numLetters = 6;
        break;
    case TUESDAY:
        numLetters = 7;
        break;
    case THURSDAY:
    case SATURDAY:
        numLetters = 8;
        break;
    case WEDNESDAY:
        numLetters = 9;
        break;
    default:
        throw new IllegalStateException("Wat: " + day);
}
</code></pre> 
<p>现在的写法是这样的：</p> 
<pre><code>int numLetters = switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; 6;
    case TUESDAY                -&gt; 7;
    case THURSDAY, SATURDAY     -&gt; 8;
    case WEDNESDAY              -&gt; 9;
};
</code></pre> 
<p>更多详情请查看：<br> https://openjdk.java.net/projects/jdk/12/</p> 
<hr> 
<h2><a id="Java_13_571"></a>五、Java 13</h2> 
<h4><a id="switch_573"></a>switch表达式预览版</h4> 
<p>JDK 13中新增 switch 表达式beta 版本，这是对Java12 switch表达式功能的增强版本，并且Java13版本的switch表达式的更新可以用于生产环境中。switch 表达式扩展了 switch 语句，使其不仅可以作为语句（statement），还可以作为表达式（expression），并且两种写法都可以使用传统的 switch 语法。</p> 
<p>除了Java12的用法之外，Java13的更新引入一个新的关键字yield。大多数switch表达式在“case L -&gt;”开关标签的右侧都有一个表达式。如果需要一个完整的块，需要使用yield语句来产生一个值，该值是封闭switch表达式的值。</p> 
<p>示例：</p> 
<pre><code>int j = switch (day) {
    case MONDAY  -&gt; 0;
    case TUESDAY -&gt; 1;
    default      -&gt; {
        int k = day.toString().length();
        int result = f(k);
        yield result;
    }
};
</code></pre> 
<p>上例也可以使用传统的switch语句：</p> 
<pre><code>int result = switch (s) {
    case "Foo": 
        yield 1;
    case "Bar":
        yield 2;
    default:
        System.out.println("Neither Foo nor Bar, hmmm...");
        yield 0;
};
</code></pre> 
<p>switch表达的情况必须详细;对于所有可能的值，必须有一个匹配的switch标签。（显然，switch声明并非必须详细。）这通常意味着需要一个default子句。但是enum switch对于覆盖所有已知常量的表达式，default编译器会插入一个子句以指示该enum定义在编译时和运行时之间已更改。依靠这种隐式default子句的插入可以使代码更健壮。现在，当重新编​​译代码时，编译器将检查所有情况是否得到明确处理。</p> 
<p>此外，switch表达式必须以一个值正常完成，或者必须通过引发异常来突然完成。这有许多后果。首先，编译器会检查每个开关标签是否匹配，然后产生一个值。</p> 
<p>示例：</p> 
<pre><code>int i = switch (day) {
    case MONDAY -&gt; {
        System.out.println("Monday"); 
        // ERROR! Block doesn't contain a yield statement
    }
    default -&gt; 1;
};
i = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY: 
        yield 0;
    default: 
        System.out.println("Second half of the week");
        // ERROR! Group doesn't contain a yield statement
};
</code></pre> 
<p>另一种后果是，控制语句，break，yield，return和continue，无法通过跳switch表达式，示例：</p> 
<pre><code>z: 
    for (int i = 0; i &lt; MAX_VALUE; ++i) {
        int k = switch (e) { 
            case 0:  
                yield 1;
            case 1:
                yield 2;
            default: 
                continue z; 
                // ERROR! Illegal jump through a switch expression 
        };
    ...
    }

</code></pre> 
<h4><a id="Text_Blocks_649"></a>Text Blocks预览版（文字块）</h4> 
<p>简单地说就是：可以跨多行显示字符串并且不对转义字符进行转义。目标是编写Java程序的任务，同时避免了常见情况下的转义序列，增强Java程序中表示用非Java语言编写的代码的字符串的可读性。</p> 
<p>在Java中，在字符串文字中嵌入HTML，XML，SQL或JSON片段"…"通常需要先进行转义和串联的大量编辑工作，然后才能编译包含该代码块的代码。该代码快通常难以阅读且难以维护。但是Java13的代码块功能会更直观地表示字符串，而且可以跨越多行，而且不会出现转义的视觉混乱，这将提高Java程序的可读性和可写性。本质上是二维文本块，而不是一维字符序列。</p> 
<p>基本语法形式：</p> 
<pre><code>"""
line 1
line 2
line 3
"""
</code></pre> 
<p>等效于：<code>"line 1\nline 2\nline 3\n"</code></p> 
<p>或字符串文字的串联：</p> 
<pre><code>"line 1\n" +
"line 2\n" +
"line 3\n"
</code></pre> 
<p>如果在字符串的末尾不需要行终止符，则可以将结束定界符放在内容的最后一行。例如，文本块：</p> 
<pre><code>"""
line 1
line 2
line 3"""
</code></pre> 
<p>具体使用：</p> 
<p>字符串里面写HTML代码，</p> 
<p>Java13之前写法：</p> 
<pre><code>String html = "&lt;html&gt;\n" +
              "    &lt;body&gt;\n" +
              "        &lt;p&gt;Hello, world&lt;/p&gt;\n" +
              "    &lt;/body&gt;\n" +
              "&lt;/html&gt;\n";
</code></pre> 
<p>Java13写法：</p> 
<pre><code>String html = """
              &lt;html&gt;
                  &lt;body&gt;
                      &lt;p&gt;Hello, world&lt;/p&gt;
                  &lt;/body&gt;
              &lt;/html&gt;
              """;
</code></pre> 
<p>再比如SQL示例：</p> 
<p>Java13之前写法：</p> 
<pre><code>String query = "SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n" +
               "WHERE `CITY` = 'INDIANAPOLIS'\n" +
               "ORDER BY `EMP_ID`, `LAST_NAME`;\n";
</code></pre> 
<p>Java13写法：</p> 
<pre><code>String query = """
               SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`
               WHERE `CITY` = 'INDIANAPOLIS'
               ORDER BY `EMP_ID`, `LAST_NAME`;
               """;
               
</code></pre> 
<p>再比如：</p> 
<p>Java13之前写法：</p> 
<pre><code>ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
Object obj = engine.eval("function hello() {\n" +
                         "    print('\"Hello, world\"');\n" +
                         "}\n" +
                         "\n" +
                         "hello();\n");
                         
</code></pre> 
<p>Java13写法：</p> 
<pre><code>ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
Object obj = engine.eval("""
                         function hello() {
                             print('"Hello, world"');
                         }
                         
                         hello();
                         """);

</code></pre> 
<p>更多详情请查看：<br> https://openjdk.java.net/projects/jdk/13/</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12143a626a4469d63209ed3a73753bdf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter For Web 创建和运行Web应用程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb5a6edda28d778b38fd79eb138d176f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UML用例图关系（Include 和extend）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>