<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>全网最硬核PHP面试题 2021年学习面试跳槽必备（一） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="全网最硬核PHP面试题 2021年学习面试跳槽必备（一）" />
<meta property="og:description" content="很多PHPer在进阶的时候总会遇到一些问题和瓶颈，业务代码写多了没有方向感，不知道该从那里入手去提升，对此我整理了一些资料，包括但不限于：分布式架构、高可扩展、高性能、高并发、服务器性能调优、Thinkphp，laravel，YII2，Redis，Swoole、Swoft、Kafka、Mysql优化、shell脚本、Docker、微服务、Nginx等多个知识点高级进阶干货需要的可以免费分享给大家。
还将大量资料整理成了一个PHP面试手册，是PDF版的。
关注微信公众号：PHP大神，然后回复“面试手册”即可免费获取~
1.实现删除一个数组里面的重复值？ 使用键值反转
array_flip(); &lt;?php $a1=array(&#34;a&#34;=&gt;&#34;red&#34;,&#34;b&#34;=&gt;&#34;green&#34;,&#34;c&#34;=&gt;&#34;blue&#34;,&#34;d&#34;=&gt;&#34;yellow&#34;); $result=array_flip($a1); print_r($result); ?&gt; function unique3(array){ var n = [array[0]];//结果数组 //从第二项开始遍历 for(var i = 1; i&lt;array.length; i&#43;&#43;){ //如果当前数组的第i项在当前数组中第一次出现的位置不是i； //那么表示第i项是重复的，忽略掉。否则存入结果数组。 if(array.indexOf(array[i]) == i){ n.push(array[i]); } } return n;} 2. 什么是 redis? 开源 先进的 key-value 存储 远程字典服务器 内存级数据库 数据结构服务器 一个基于内存的网络存储系统 3.redis 数据类型有哪几种？ 值（value）可以是：字符串 (String), 哈希 (hash), 列表 (list), 集合 (sets) 有序集合 (sorted sets) 4.redis 持久化是如何操作的？ 为了保证效率数据都缓存在内存中，可以周期性写入磁盘或者把修改操作写入文件（持久化）。 RDB 持久化，将 redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。 AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 redis 的协议格式来保存的。 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d755821017e3504addcd8b2f7787d7a5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-02T13:43:07+08:00" />
<meta property="article:modified_time" content="2021-04-02T13:43:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全网最硬核PHP面试题 2021年学习面试跳槽必备（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>很多PHPer在进阶的时候总会遇到一些问题和瓶颈，业务代码写多了没有方向感，不知道该从那里入手去提升，对此我整理了一些资料，包括但不限于：分布式架构、高可扩展、高性能、高并发、服务器性能调优、Thinkphp，laravel，YII2，Redis，Swoole、Swoft、Kafka、Mysql优化、shell脚本、Docker、微服务、Nginx等多个知识点高级进阶干货需要的可以免费分享给大家。</p> 
<p>还将大量资料整理成了一个PHP面试手册，是PDF版的。</p> 
<p>关注微信公众号：<strong>PHP大神</strong>，然后回复“<strong>面试手册</strong>”即可免费获取~</p> 
<h3>1.实现删除一个数组里面的重复值？</h3> 
<p>使用键值反转</p> 
<pre><code class="language-php">array_flip();
&lt;?php
$a1=array("a"=&gt;"red","b"=&gt;"green","c"=&gt;"blue","d"=&gt;"yellow");
$result=array_flip($a1);
print_r($result);
?&gt;
function unique3(array){    
var n = [array[0]];//结果数组    
//从第二项开始遍历    
for(var i = 1; i&lt;array.length; i++){        
//如果当前数组的第i项在当前数组中第一次出现的位置不是i；       
//那么表示第i项是重复的，忽略掉。否则存入结果数组。        
if(array.indexOf(array[i]) == i){            
n.push(array[i]);        
}    
}    
return n;}</code></pre> 
<h3>2. 什么是 redis?</h3> 
<blockquote>
  开源 先进的 key-value 存储 
 <br> 远程字典服务器 内存级数据库 数据结构服务器 
 <br> 一个基于内存的网络存储系统 
</blockquote> 
<h3>3.redis 数据类型有哪几种？</h3> 
<blockquote>
  值（value）可以是：字符串 (String), 
 <br> 哈希 (hash), 
 <br> 列表 (list), 
 <br> 集合 (sets) 
 <br> 有序集合 (sorted sets) 
</blockquote> 
<h3>4.redis 持久化是如何操作的？</h3> 
<blockquote>
  为了保证效率数据都缓存在内存中，可以周期性写入磁盘或者把修改操作写入文件（持久化）。 
 <br> RDB 持久化，将 redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。 
 <br> AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 redis 的协议格式来保存的。 
</blockquote> 
<p> </p> 
<h3>5.redis 适应的一些场景</h3> 
<p>1、取最新 N 个数据的操作</p> 
<p>2、排行榜应用,取 TOP N 操作</p> 
<p>3、需要精准设定过期时间的应用</p> 
<p>4、计数器应用</p> 
<p>5、Uniq 操作,获取某段时间所有数据排重值</p> 
<p>6、实时系统,反垃圾系统</p> 
<p>7、Pub/Sub 构建实时消息系统</p> 
<p>8、构建队列系统</p> 
<p>9、缓存</p> 
<h3>6.redis 的三个特点？</h3> 
<blockquote>
  - Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 
 <br> - Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 
 <br> - Redis支持数据的备份，即master-slave模式的数据备份。 
</blockquote> 
<h3>7.ECS 与虚拟主机的区别介绍</h3> 
<blockquote>
  一个是服务器 
 <br> 一个相当于是服务器里的文件夹 
 <br> 云主机是在集群服务器上划分出来的独立的内存.硬盘.带宽等资源搭建而成的 一个虚拟服务器.有独立的IP和带宽,可以根据需求安装各版本操作系统以及 配置各种网站运行环境,有远程桌面连接东西.是完全独立的. 
 <br> 而虚拟主机是在服务器硬盘上划分出来的一部分存储空间,它共享的是服务器 的IP和带宽.没有独立的资源和独立的操作系统.没有远程桌面功能,通常虚拟主机所支持的网站程序也是默认分配好的.没有办法由用户自己配置环境.功能相对单一. 
</blockquote> 
<h3>8. 重启 redis</h3> 
<p>service redis-server restart</p> 
<h3>9. 有序集合是怎么排序的？</h3> 
<p>它给集合中的每一个元素设置分数，按照其分数进行排序，也不允许有重复值</p> 
<h3>10. 谈谈你对 memcache 的理解</h3> 
<p>免费并且开源，高性能的，分布式的内存对象缓存系统</p> 
<p>数据形态以key-&gt;value结构</p> 
<p>用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象)。</p> 
<h3>11. 谈谈你对 redis 的理解</h3> 
<p>- 开源 先进的key-value存储</p> 
<p>- 远程字典服务器 内存级数据库 数据结构服务器</p> 
<p>- 一个基于内存的网络存储系统</p> 
<p>五种数据类型 字符串(String), 哈希(hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)</p> 
<p>三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p> 
<p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存 储。</p> 
<p>Redis支持数据的备份，即master-slave模式的数据备份。</p> 
<p>应用场景：</p> 
<p>1、取最新 N 个数据的操作</p> 
<p>2、排行榜应用,取 TOP N 操作</p> 
<p>3、需要精准设定过期时间的应用</p> 
<p>4、计数器应用</p> 
<p>5、Uniq 操作,获取某段时间所有数据排重值</p> 
<p>6、实时系统,反垃圾系统</p> 
<p>7、Pub/Sub 构建实时消息系统</p> 
<p>8、构建队列系统</p> 
<p>9、缓存</p> 
<h3>12. memcached 与 redis 的区别</h3> 
<p>两者对比：</p> 
<ul><li>redis提供数据持久化功能，memcached无持久化；</li><li>redis的数据结构比memcached要丰富，能完成场景以外的事情；</li><li>memcached的单个key限制在250B，value限制在1MB；redis的K、V都为512MB;当然这些值可以在源码中修改；</li><li>memcached数据回收基于LRU算法，Redis提供了多种回收策略（包含LRU），但是redis的回收策的过期逻辑不可依赖，没法根据是否存在一个key判断是否过期。但是可根据ttl返回值判断是否过期；</li><li>memcached使用多线程，而redis使用单线程，基于IO多路复用实现高速访问。所以可以理解为在极端情况下memcached的吞吐大于redis。</li></ul> 
<p>结论：</p> 
<p>普通KV场景：memcached、redis都可以。</p> 
<p>从功能模块单一这个角度考虑的话，推荐memcached，只做cache一件事。</p> 
<p>在KV长度偏大、数据结构复杂（比如取某个value的一段数据）、需要持久化的情况下，用redis更适合：但是在使用redis的时候单个请求的阻塞会导致后续请求的积压，需要注意</p> 
<h3>13. 缓存的原理</h3> 
<p>有缓存则读缓存，没缓存则读数据库然后做缓存</p> 
<h3>14. memcache 和 memcached 的区别</h3> 
<p>memcached是php连接memcached服务器的php扩展它的名字就叫memcached</p> 
<p>以前有个叫memcache也是php连接memcached服务器的扩展，它的名字叫memcache</p> 
<p>php的memcache和memcached扩展都是作为客户端去连接memcached服务器</p> 
<p>但memcached作为客户端比memcache性能更好功能更强大，而且memcache已经停止更新了，因此现在使用扩展的 话就用memcached</p> 
<h3>15. 存放 session 的三种方法</h3> 
<p>1、如果你能修改到服务器配置文件，那就打开打开php.ini</p> 
<p>修改下面两项：</p> 
<p>session.save_handler = memcache</p> 
<p>session.save_path = "tcp://127.0.0.1:11211"</p> 
<p>2、修改网站根目录下的.htaccess文件</p> 
<p>php_value session.save_handler "memcache"</p> 
<p>php_value session.save_path "tcp://127.0.0.1:11211"</p> 
<p>3、最常用的方法 在程序代码中修改（推荐）</p> 
<p>ini_set("session.save_handler", "memcache");</p> 
<p>ini_set("session.save_path", "tcp://127.0.0.1:11211");</p> 
<h3>16. mysql 优化的一般步骤？</h3> 
<p>1. sql及索引</p> 
<p>索引优化</p> 
<p>开启慢查询日志 分析sql语句 分析是否加上索引 分析是否用上索引</p> 
<p>2. 数据库表结构</p> 
<p>3.系统配置</p> 
<p>4. 优化计算机硬件</p> 
<h3>17. 对 mysql 事物的理解？</h3> 
<p>是多个步骤为一个过程的事务（整体）</p> 
<p>1. 事务使用 INNODB 数据库引擎</p> 
<p>如果你不是INNODB ,开启事务,删除那就真的删除了.</p> 
<p>2. 要么成批的sql全部执行,要么不执行</p> 
<p>3. 事务用来管理 insert update delete 的语句</p> 
<p>事务条件:</p> 
<p>原子性 一组事务,要么成功,要么撤回.</p> 
<p>稳定性 有非法数据(外键约束),事务撤回</p> 
<p>隔离性 事务独立运行. 一个事务,处理后的结果影响到了其他事务,则事务撤回!</p> 
<p>可靠性 软件或者硬件崩溃,Innodb 表驱动,会利用日志文件,重构修改. 可靠 性 高速度 不可兼得</p> 
<p>关键字:</p> 
<p>Commit 提交 当一个事务完成后,发出commit 命令使所有的参与表 完成更改.</p> 
<p>Rollback 回滚 如果发送故障,发出rollback命令 使事务返回到 所有表以前的状态.</p> 
<p>语句：</p> 
<blockquote>
  set autocommit = 0; 
 <br> sql操作 
 <br> savepoint p1; 
 <br> sql操作 
 <br> savepoint p2; 
 <br> sql操作 
 <br> ROLLBACK to p2; 
 <br> commit; 
</blockquote> 
<h3>18. mysql 触发器是什么？</h3> 
<blockquote>
  监视某种事件，并触发某种操作 (商品的添加，订单的删除 等等 连贯操作时候使用) 
 <br> ###触发四要素 
 <br> 1. 监视地点 table 
 <br> 2. 触发时间 (after/ before) 
 <br> 3. 监视事件 (insert/update/delete) 
 <br> 4. 触发事件 (insert/update/delete) 
 <br> 1、创建一个名为tg1的触发器，当向t1表中插入数据前，就向a表中插入一条数据 
 <br> delimiter // mysql中可以转换结束符 
 <br> mysql&gt;create trigger tg1 before insert on t1 for each row #固定写法 
 <br> -&gt;begin 
 <br> -&gt; insert into a values (4); 
 <br> -&gt;end// 
</blockquote> 
<h3>19. 什么是组合索引，及使用情况？</h3> 
<blockquote>
  将两个字段共同添加一条索引 
 <br> 例子：当前组合索引是这样一个顺序 ind_status_email(status,email) 
 <br> 单独查询status时，可以用到这个索引，单独查询email时，却用不到 
 <br> 再问: id name password 建立组合索引 怎么建立?为什么? 
 <br> name,password 
 <br> 因为先到先得, name查询是多!!! 很少会通过password来查 
 <br> 先到先得 如何设置我索引? 
 <br> 根据字段的辨识度来做 
</blockquote> 
<h3>20. 为什么 like 在 % 第一个字符用不到索引？</h3> 
<p>like % 校 会查处当前所有的姓，再去查名中有没有校 所以 会进行全表扫描，浪费性能</p> 
<h3>21. 测试分析 sql 语句</h3> 
<blockquote>
  普通查询分析： 
 <br> desc select * from users 或 explain select * from users 效果一样 
 <br> 关键字段: table：输出结果集的表名 
 <br> key：表示实际使用的索引 
 <br> keys_possible (可能用到的索引) 
 <br> rows：扫描行的数量 
</blockquote> 
<h3>22. 为什么不分开加索引？而非要加组合索引？</h3> 
<p>1. 索引不是越多越好. 浪费资源 索引暂用资源,影响插入性能</p> 
<p>2. 根据要加索引的字段辨识度而来. 如果你给辨识度小的字段加索引</p> 
<p>第一, 加了你不常用 第二,影响性能</p> 
<p>3. 尤其是 name pasword 经典的组合索引例子</p> 
<h3>23. 慢查询是什么？及其操作？</h3> 
<p>MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“慢查询”。</p> 
<blockquote>
  1、查看是否开启慢查询 
 <br> mysql&gt; show variables like "%slow%"; 
 <br> log_slow_queries | OFF 
 <br> 2、查看慢查询时间线 
 <br> mysql&gt; show variables like "%long%"; 
 <br> | long_query_time | 10.000000 | //默认10秒 
 <br> 3、开启慢查询记录功能 
 <br> vi /etc/my.cnf 
 <br> [mysqld] 
 <br> #将慢查询日志写在这个文件中 
 <br> ---log_slow_queries=slow.log 
 <br> #超过多少秒的算是慢查询 
 <br> ---long_query_time=1 
 <br> #自定义，和理解可，试验用1秒方便查看日志。 
 <br> 4、重启mysql 
 <br> ps -le | grep mysqld 
 <br> pkill mysqld或者/usr/local/mysql/bin/mysqladmin –uroot –p shutdown（推荐，安全关闭） 
 <br> /usr/local/mysql/bin/mysqld_safe --user=mysql &amp; 
 <br> 重启后慢查询功能开启 
 <br> 5、查看慢查询次数 
 <br> mysql&gt;show status like "Slow_queries"; //当前链接，超时的查询次数 
 <br> mysql&gt;show global status like "Slow_queries"; //全局的 
 <br> 如果有慢查询，需要去日志中分析，到底是什么原因 
 <br> vi /usr/local/mysql/data/slow.log #慢查询日志文件在开启慢查询功能后自动生成 
 <br> 需要将里面的SQL语句，用desc 分析，如果发现没有索引，则添加索引，如果是用不到索引，则修改SQL语句。 
 <br> 6、查看MySQL的各项状态*(了解) 
 <br> show session status; 当前连接(可以省略session) 
 <br> show global status; 全局，服务器启动以来 
 <br> 筛选一部份内容查看: 
 <br> show status like "com_insert%"; 执行insert操作的次数，一次查询只累计加1 
 <br> show status like "com_update%"; 
 <br> show status like "com_delete%"; 
 <br> show status like "com_select%"; 
 <br> show global status like "com_select%"; 
 <br> //不管有没有查到数据，都算一次查询操作 
 <br> 只针对于InnoDB存储引擎的: 
 <br> show global status like "innodb_rows%"; 
 <br> InnoDB_rows_read 
 <br> InnoDB_rows_updated 
 <br> InnoDB_rows_inserted 
 <br> InnoDB_rows_deleted 
</blockquote> 
<h3>24.bin.log 日志是什么？</h3> 
<p>记录数据库变化操作的二进制日志文件</p> 
<p>记录了所有的数据库变化操作(数据增删改，创建表等)</p> 
<p>在数据丢失的紧急情况下，我们往往会想到用binlog日志功能进行数据恢复</p> 
<h3>25. 聚簇索引和非聚簇索引的区别？</h3> 
<blockquote>
  聚簇索引： 聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条； 
 <br> 说明： 
 <br> 平时习惯逛图书馆的童鞋可能比较清楚，如果你要去图书馆借一本书，最开始是去电脑里面查书名然后根据书名来定位藏书在那个区，哪个书柜，哪一行，第多少本。。。清晰明确，一目了然，因为藏书的结构与图书室的位置，书架的顺序，书本的摆放顺序与书籍的编号都是从大到小一致的顺序摆放的，所以很容易找到。比如，你的目标藏书在C区2柜3排5仓，那么你走到B区你就很快知道前面就快到了C区了，你直接奔着2柜区就能找到了。 这就是雷同于聚簇索引的功效了，聚簇索引，实际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引，当然有人说我不想拿主键作为聚簇索引，我需要用其他字段作为索引，当然这也是可以的，这就需要你在设置主键之前自己手动的先添加上唯一的聚簇索引，然后再设置主键，这样就木有问题啦。 
 <br> 非聚簇索引: 非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的 非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引； 
 <br> 说明： 
 <br> 同样的，如果你去的不是图书馆，而是某城市的商业性质的图书城，那么你想找的书就摆放比较随意了，由于商业图书城空间比较紧正，藏书通常按照藏书上架的先后顺序来摆放的，所以如果查询到某书籍放在C区2柜3排5仓，但你可能要绕过F区，而不是A.B.C.D...连贯一致的，也可能同在C区的2柜，书柜上第一排是计算机类的书籍，也可能最后一排就是医学类书籍； 
</blockquote> 
<h3>26.mysql 分区有哪几种？</h3> 
<p>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。</p> 
<p>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。</p> 
<p>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p> 
<p>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p> 
<h3>27.MyISAM 和 InnoDB 的区别？从事物和表结构分析？</h3> 
<p>1.MyISAM不支持事务，InnoDB是事务类型的存储引擎，当我们的表需要用到事务支持的时候，那肯定是不能选择MyISAM了</p> 
<p>2、MyISAM只支持表级锁，，而InnoDB支持行级锁和表级锁默认为行级锁</p> 
<p>3、MyISAM引擎不支持外键，InnoDB支持外键</p> 
<p>4、MyISAM支持全文类型索引，而InnoDB不支持全文索引</p> 
<p>5、MyISAM引擎的表在大量高并发的读写下会经常出现表损坏的情况</p> 
<p>6、MyISAM保有表的总行数，InnoDB只能遍历</p> 
<h3>28.InnoDB 共享表空间和独立表空间的优缺点？</h3> 
<blockquote>
  优点： 
 <br> 共享表空间： 
 <br> 可以放表空间分成多个文件存放到各个磁盘上（表空间文件大小不受表大小的限制，如一个表可以 分布在不同步的文件上）。数据和文件放在一起方便管理 
 <br> 独立表空间： 
 <br> 1.每个表都有自已独立的表空间。 
 <br> 2.每个表的数据和索引都会存在自已的表空间中。 
 <br> 3.可以实现单表在不同的数据库中移动。 
 <br> 4.空间可以回收（除drop table操作处，表空不能自已回收） 
 <br> a) Drop table操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通 过:alter table TableName engine=innodb;回缩不用的空间。 
 <br> b) 对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。 
 <br> c) 对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会 处理. 
 <br> 
 <br> 缺点： 
 <br> 共享表空间： 
 <br> 所有的数据和索引存放到一个文件中意味着将有一个很常大的文件，虽然可以把一个大文件分成多 个小文件，但是多个表及索引在表空间中混合存储，这样对于一个表做了大量删除操作后表空间中 将会有大量的空隙，特别是对于统计分析，日值系统这类应用最不适合用共享表空间 
 <br> 独立表空间： 
 <br> 单表增加过大，如超过100个G 
 <br> 相比较之下，使用独占表空间的效率以及性能会更高一点 
</blockquote> 
<h3>29.Node.js 是什么？</h3> 
<p>Node.js是一个让JavaScript运行在服务器端的开发平台.</p> 
<h3>30. Node.js 的特点</h3> 
<blockquote>
  单线程 | 非阻塞 I/O | 事件驱动 
 <br> 1). 单线程 
 <br> 所有客户端请求的连接 都使用一个线程来处理. 
 <br> nodejs 不是为每个用户 创建一个新的连接,而是仅仅使用一个线程. 
 <br> 单线程 带来的好处: 操作系统 不会为新线程 创建 || 销毁 内容空间,而暂用额外资源. 
 <br> 2). 非阻塞 I/O 
 <br> I/O操作不会阻塞程序的运行 
 <br> 3). 事件驱动 
 <br> 客户端 请求建立连接，提交数据等行为，就会触发 相应的事件. 
 <br> 在Node中，在一个时刻，只能执行 一个事件回调函数，但是在执行 一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制. 
 <br> 4). 三特点说明 
 <br> 单线程 
 <br> 是为了 减少内存的消耗,OS的内存(创建和销毁) 
 <br> 但是,如果每个请求都有I/O,单线程就会 被 阻塞. 
 <br> 非阻塞 I/O: 
 <br> 不会傻等着 I/O操作完成后,才去 执行后面的操作,而会 直接执行后的语句. 
 <br> 非阻塞I/O,的操作,一个操作还未完成,下一个操作又来了.那么使用,事件环 
 <br> 事件驱动 (事件环): 
 <br> 不管新用户的请求,还是老用户的请求(I/O操作),都将以事件的方式加入,事件环,等待调度. 
 <br> nodejs 所有的 I/O 都是异步的,回调函数套用回调函数. 
</blockquote> 
<h3>31. Node.js 的优缺点？</h3> 
<blockquote>
  1). 优点 
 <br> 善于 I/O,不善于计算. 
 <br> 处理高并发 
 <br> 服务器推送 
 <br> 2). 缺点 
 <br> 单一线程,一旦崩溃,整个服务就挂了. 
 <br> 超人死了,世界都末日了. 
</blockquote> 
<h3>32. Node.js 适用场景</h3> 
<blockquote>
  不能完全替代 传统的后端语言,但在某些方面优于传统. (nodejs 请求后端api) 
 <br> 当应用程序需要处理大量并发的I/O操作，而在发出响应之前，应用程序内部 并不需要进行非常复杂的计算处理的时候，Node.js非常适合。 
 <br> Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。 
 <br> 考试系统 
 <br> 聊天室 
 <br> 图文直播 
 <br> 用户表单收集(大数据处理) 
 <br> 复杂的计算 
 <br> 提供 api(数据格式:json) 
</blockquote> 
<h3>33 Node.js 创建的 http 步骤</h3> 
<blockquote>
  第一:引入http模块 
 <br> var http = require('http'); // http 是内置模块 所以 不需要指定路径 
 <br> 第二: 指定服务器 ip 和 端口号 
 <br> var hostname = '127.0.0.1'; 
 <br> var port = '3000'; 
 <br> 第三 创建服务器 
 <br> nodejs 所有的函数 都是 异步 回调函数 所以都需要用function 来接收 和处理 
 <br> createServer 回调中有2个参数 req res 代表请求和响应 
 <br> var server = http.createServer(function(req,res){ 
 <br> 业务逻辑 
 <br> res.end(); 
 <br> }); 
 <br> // 第四步 运行服务器 
 <br> server.listen(port,hostname,function(){ 
 <br> 
 <br> }); 
</blockquote> 
<h3>34. Node.js 中 parse 的用法</h3> 
<p>url.parse 会解析一个 URL 字符串并返回一个 URL 对象。</p> 
<p>url.parse(req.url,true) 加true会解析为JSON格式，不加解析为字串格式</p> 
<h3>35. Node.js 文件怎么打开？</h3> 
<blockquote>
  第一:引入模块 
 <br> var fs =require('fs'); 
 <br> 第二: 语法 
 <br> 回调有两个参数 (err, data)，其中 data 是文件的内容。 
 <br> fs.readFile('./fei.jpg',function(err,data){ 
 <br> if (err) throw err; 
 <br> // 没有err 就 返回data 
 <br> // 设置mime 类型 
 <br> res.writeHead(200,{"Content-type":"image/jpeg;charset=utf-8"}); 解析图片格式 
 <br> res.writeHead(200,{"Content-type":"text/html;charset=utf-8"}); 解析文本 
 <br> res.end(data); 
 <br> }); 
</blockquote> 
<h3>36.http 请求的流程？</h3> 
<blockquote>
  1. 域名解析 
 <br> 2. 发起TCP的3次握手 
 <br> 3. 建立TCP连接后发起http请求 
 <br> 4. 服务器端响应http请求，浏览器得到html代码 
 <br> 5. 浏览器解析html代码，并请求html代码中的资源 
 <br> 6. 浏览器对页面进行渲染呈现给用户 
 <br> 
 <br> 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 
 <br> 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 
 <br> 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 
 <br> 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 
 <br> 5、释放 TCP连接; 
 <br> 6、浏览器将该 html 文本并显示内容; 
</blockquote> 
<h3>37.node.js 中模块是什么？</h3> 
<blockquote>
  在Node.js中,不可能用一个js文件去写全部的业务,肯定要有MVC. 
 <br> 它以模块为单位 划分所有功能,并且提供了一个 完整的模块加载机制,我们可以将应用程序 划分为各个不同的部 分. 
 <br> 每一个JavaScript文件都是一个模块；而多个JavaScript文件可以使用require引入,使他们共同实现了一个功能 模块. 
 <br> 38.node.js 输出的方法？ 
 <br> 输出变量/函数 
 <br> Node.js中,JS文件中定义的变量、函数,都只在这个文件内部有效. 
 <br> 其他文件中需要引用变量、函数时,必须使用`exports对象`进行暴露(输出).使用者要用`require()`命令,引用执行这个JS文件. 
 <br> 输出一个类(构造函数) 
 <br> 可以用`module.exports = 构造函数名;`的方式 向外输出一个类 
</blockquote> 
<h3>39. 谈谈对 npm 的理解？</h3> 
<blockquote>
  这是一个工具名字.npm的主要职责是 安装开发包和管理依赖项. 
 <br> 安装开发包:安装 npm install命令；更新 npm update命令. 
 <br> 管理依赖项:借助package.json文件;最简单生成package.json的方法就是npm init 
 <br> 开发时,会使用到各种功能的组件,所有组件都由我们自己来写代码的话,开发效率就会很低.我们不要重复的去造轮子,要学会使用已有的工具,来完善我们的项目,站在巨人的肩膀上去工作. 
 <br> npm是js世界里的一个伟大的社区,能够让开发者更加轻松的共享代码和共用代码片段或模块组件. 
</blockquote> 
<h3>40. node.js 中如何处理 post 请求？</h3> 
<p>相比较GET请求，POST请求比较复杂。因为Node.js认为，使用POST请求时，数据量会比较多。为了追求极致的效率，它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件，将这些小数据块有序传递给回调函数。</p> 
<h3>41. node.js 中如何接收 post 数据？</h3> 
<blockquote>
  特定的事件 去接收 addListener 
 <br> querystring.parse 解析 url 返回键值对的对象 
 <br> 特定的事件 去接收 addListener 
 <br> // 第一步: 设置空的标量 
 <br> var postData = ''; 
 <br> // 第二步 开始监听 data 
 <br> req.addListener('data',function(chunk){ 
 <br> console.log(chunk); // 这里得到二进制数据 没有被解析 
 <br> }); 
 <br> // 第三步: 监听结束 end 
 <br> req.addListener('end',function(){ 
 <br> // 处理得到的postData 是一个 拼接好的 url字符串 
 <br> // 第四步: 处理接收完毕的数据 转化为对象 
 <br> // 解析 url字符串 
 <br> // querystring.parse 解析url 返回键值对的对象 
 <br> var dataObj = querystring.parse(postData); 
 <br> }); 
</blockquote> 
<h3>42. 学习框架的基础块？</h3> 
<p>1. 路由</p> 
<p>2. 中间件</p> 
<p>3. 数据操作</p> 
<p>4. 模板引擎</p> 
<h3>43. node.js 如何处理图片上传？</h3> 
<blockquote>
  一 引入模板 
 <br> var formidable = require('formidable'); 
 <br> 二 // 接收参数 以及文件 
 <br> var form = new formidable.IncomingForm(); 
 <br> // 设置上传,目录 
 <br> form.uploadDir = "./uploads"; 
 <br> 
 <br> form.parse(req, function(err, fields, files) { 
 <br> 
 <br> // 处理 接受到的参数 再处理图片的上传 
 <br> 
 <br> // 处理上传文件的名字 
 <br> // 改名字的步骤 
 <br> 
 <br> 
 <br> // 起名字 
 <br> 
 <br> // 时间 + 随机数 + 后缀 
 <br> var t = datetime.format(new Date(),'YYYYMMDDHHmmss'); 
 <br> var ran = parseInt(Math.random()*100000); 
 <br> var extname = path.extname(files.sexy_photo.name); 
 <br> // 执行改名字 旧名字 新名字 
 <br> 
 <br> // 旧名字 
 <br> // 当前目录 __dirname 
 <br> // path: 'uploads\\upload_621966da1b7a1d762c8a79c838f99b03', 
 <br> 
 <br> var oldpath = __dirname + '/' + files.sexy_photo.path; 
 <br> 
 <br> // 新名字 
 <br> 
 <br> var newpath = __dirname + '/uploads/' + t + ran + extname; 
 <br> 
 <br> // 改名字 
 <br> // rename 
 <br> fs.rename(oldpath,newpath,function(err){ 
 <br> res.end('图片上传成功'); 
 <br> }); 
</blockquote> 
<h3>44. ejs 如何渲染模板？</h3> 
<p>Render(str,data,[option]):直接渲染字符串并生成html</p> 
<p>str：需要解析的字符串模板</p> 
<p>data：数据</p> 
<p>option：配置选项</p> 
<h3>45.ejs 常用标签？</h3> 
<blockquote>
  &lt;% %&gt;流程控制标签 
 <br> &lt;%= %&gt;输出标签（原文输出HTML标签） 
 <br> &lt;%- %&gt;输出标签（HTML会被浏览器解析） 
 <br> &lt;%# %&gt;注释标签 
 <br> % 对标记进行转义 
 <br> -%&gt;去掉没用的空格 
 <br> 说明：ejs中的逻辑代码全部用JavaScript 
</blockquote> 
<h3>46. 如何使用 express 创建一个服务器？</h3> 
<blockquote>
  // 引入express 框架 
 <br> var express = require('express'); 
 <br> // 创建一个http服务 
 <br> var app = express(); 
 <br> // 定义一个路由 
 <br> app.get('/',function(req,res){ 
 <br> res.send('xxxx'); 
 <br> // 不建议使用end 因为end 会结束响应 
 <br> }); 
 <br> // 运行服务 
 <br> // 可以不写第二个参数 代表本地 和外网 均可以访问 
 <br> app.listen(3000); 
</blockquote> 
<h3>47.express 如何定义路由？</h3> 
<blockquote>
  app.get('/',function(req,res){ 
 <br> res.send('xxxx'); 
 <br> // 不建议使用end 因为end 会结束响应 
 <br> }); 
 <br> app.post('/chenpin',function(req,res){ 
 <br> res.send(''); 
 <br> }); 
</blockquote> 
<h3>48.res 中 end 和 send 的区别？</h3> 
<p>如果服务器端没有数据返回到客户端 那么就可以用 res.end</p> 
<p>但是 如果 服务器端有数据返回到客户端 这个时候必须用res.send ,不能用 res.end（会报错）</p> 
<h3>49. php 命名空间是如何定义的？</h3> 
<p>命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。</p> 
<p>命名空间一个最明确的目的就是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。这种情况下只要避免命名重复就可以解决，最常见的一种做法是约定一个前缀。</p> 
<p>基础</p> 
<p>命名空间将代码划分出不同的空间（区域），每个空间的常量、函数、类（为了偷懒，我下边都将它们称为元素）的名字互不影响， 这个有点类似我们常常提到的‘封装'的概念</p> 
<h3>50.php 接口是如何实现的？</h3> 
<blockquote>
  如果一个抽象类里面的所有方法都是抽象方法，且没有声明变量，而且接口里面所有的成员都是public权限的，那么这种特殊的抽象类就叫接口 
 <br> 接口是什么？ 
 <br> 使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 
 <br> 接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 
 <br> 接口中定义的所有方法都必须是公有，这是接口的特性。 
 <br> 接口使用规范 
 <br> 接口不能实例化 
 <br> 接口的属性必须是常量 
 <br> 接口的方法必须是public【默认public】，且不能有函数体 
 <br> 类必须实现接口的所有方法 
 <br> 一个类可以同时实现多个接口，用逗号隔开 
 <br> 接口可以继承接口【用的少】 
</blockquote> 
<p><strong>未完待续~~~~</strong></p> 
<p>需要的可以关注微信公众号“PHP大神”回复“面试手册”即可</p> 
<p>以上内容希望帮助到大家，<img alt="image.png" src="https://images2.imgbox.com/1e/df/JPDgiu80_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2411946dcb386e78533dbf6bb19c0060/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">执行appium-doctor时提示不是内部或外部的命令的处理方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31a88d9e8027d72e397f5ff94c8d599a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(图像/视频/实时网络摄像头)动作位点预测（human-pose-estimation）手把手教程:Anaconda&#43;Jupyter&#43;Opencv</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>