<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数组刷题总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数组刷题总结" />
<meta property="og:description" content="数组刷题总结 1.1 二分答案 当题目要求最大化某最小、最小化某最大，考虑使用二分查找。遍历所有可能得key，然后送入check函数进行题目判断
1760. 袋子里最少数目的球 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
class Solution { public: bool check(int cost,vector&lt;int&gt;&amp; nums, int maxOperations){ int count=0; for(int i=0;i&lt;nums.size();i&#43;&#43;){ if(nums[i]%cost==0) count&#43;= nums[i]/cost-1; else count &#43;= nums[i]/cost; } if(count&lt;=maxOperations) return true; return false; } int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) { int left =1; int right = 1e9; while(left&lt;right){ int mid = left&#43;(right-left)/2; if(check(mid,nums,maxOperations)){ right = mid; } else{ left = mid&#43;1; } } return left; } }; 在本题目中，需要最小化，拆分后剩余的最大值。所以在check函数中，由于除法得到的余数肯定小于被除数，所以直接用数组值除以遍历得到的最大值，得到需要划分的次数，并进行判断。 1552." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/96f81ec94040b8f293074dfe97100e06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T22:04:09+08:00" />
<meta property="article:modified_time" content="2023-05-06T22:04:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数组刷题总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>数组刷题总结</h2> 
<h3><a id="11__2"></a>1.1 二分答案</h3> 
<p>当题目要求最大化某最小、最小化某最大，考虑使用二分查找。遍历所有可能得key，然后送入check函数进行题目判断</p> 
<h6><a id="1760__4"></a>1760. 袋子里最少数目的球</h6> 
<p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。</p> 
<p>你可以进行如下操作至多 maxOperations 次：</p> 
<p>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br> 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br> 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</p> 
<p>请你返回进行上述操作后的最小开销。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    bool check(int cost,vector&lt;int&gt;&amp; nums, int maxOperations){
        int count=0;
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]%cost==0) count+= nums[i]/cost-1;
            else count += nums[i]/cost;

        }
        if(count&lt;=maxOperations) return true;
        return false;
    }
    int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) {
        int left =1;
        int right = 1e9;
        while(left&lt;right){
            int mid = left+(right-left)/2;
            if(check(mid,nums,maxOperations)){
                right = mid;
            }
            else{
                left = mid+1;
            }
        }
        return left;
    }
};
在本题目中，需要最小化，拆分后剩余的最大值。所以在check函数中，由于除法得到的余数肯定小于被除数，所以直接用数组值除以遍历得到的最大值，得到需要划分的次数，并进行判断。
</code></pre> 
<h6><a id="1552__44"></a>1552. 两球之间的磁力</h6> 
<p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p> 
<p>已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。</p> 
<p>给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    bool check(vector&lt;int&gt;&amp; position, int m,int work){
        int j =0;
        int n = position.size();
        int count=0;
        for(int i =0;i&lt;n;i++){
            if((position[i]-position[j])&gt;=work){
                count++;
                j = i;
            }
        }
        if(count&gt;=(m-1)) return true;
        return false;
    }
    int maxDistance(vector&lt;int&gt;&amp; position, int m) {
        sort(position.begin(),position.end());
        int n = position.size();
        int left =1;
        int right = 1e9;
        while(left&lt;right){
            int mid = left+(right-left)/2;
            if(check(position,m,mid)){
                left = mid+1;
            }
            else{
                right = mid;
            }
        }
        return left-1;
    }
};
在这道题中，讲题目抽象为，求最大均分长度，在check中判断均分长度最大能分成多少段
</code></pre> 
<h6><a id="1011_D_85"></a>1011 D天内运船</h6> 
<p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</p> 
<p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p> 
<p>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    bool check(vector&lt;int&gt;&amp; weights, int days,int mid){
        int n = 0;
        int sum=0;
        int n1=0;
        for(auto c:weights){
            sum+=c;
            if(mid&lt;c) return false;
            if(mid&lt;sum){
                n++;
                sum=c;
            }
        }
        if(sum&lt;mid) n++;
        return n&lt;=days;
    }
    int shipWithinDays(vector&lt;int&gt;&amp; weights, int days) {
        int l = 1;
        int r = 1e9;
        while(l&lt;r){
            int mid = l+(r-l)/2;
            if(check(weights,days,mid)){
                r = mid;
            }
            else l = mid+1;
        }
        return l;
    }
};
在这道题目中，主要难点在于check函数中，计算运载天数时，如果船满载，则需要放弃当前货物，下次再运。且船的运载能力不能小于货物大小。
</code></pre> 
<h6><a id="410__124"></a>410 分割数组最大值的个数最小</h6> 
<p>给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。</p> 
<p>设计一个算法使得这 m 个子数组各自和的最大值最小。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    bool check(vector&lt;int&gt;&amp; nums, int k,int mid){
        int sum1=0;
        int n = 1;
        for(auto c:nums){
            sum1+=c;
            if(sum1&gt;mid){
                sum1 = c;
                n++;
            }
        }
        return n&lt;=k;
    }
    int splitArray(vector&lt;int&gt;&amp; nums, int k) {
        int maxc = 0;
        int all =0;
        for(auto c:nums){
            maxc = max(maxc,c);
            all+=c;
        }
        int l = maxc;
        int r = all;
        while(l&lt;r){
            int mid = l+(r-l)/2;
            if(check(nums,k,mid)){
                r = mid;
            }
            else l = mid+1;
        }
        return l;
    }
};
由于这道题要求最大连续字数组和，所以先猜一个数字。在check函数中，求所有值和小于等于这个值的数组数，最后再加上一个大于这个值的数组，就是当前猜的值可以划分的数组数。如果这个数小于要求的k，说明猜的和大了，需要r = mid。
并且由于check函数中包含了等于条件，所以在r=mid中包含了正确答案。
</code></pre> 
<h3><a id="21__165"></a>2.1 差分</h3> 
<h6><a id="1094__166"></a>1094. 拼车</h6> 
<p>车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）</p> 
<p>给定整数 capacity 和一个数组 trips , trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。</p> 
<p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) {
        vector&lt;int&gt; bus(1000,0);
        for(auto c:trips){
            bus[c[1]]+=c[0];
            if(c[2]&lt;1000) bus[c[2]]-=c[0];
        }
        for(int i=0;i&lt;bus.size();i++){
            if(i&gt;0) bus[i]+=bus[i-1];
            if(bus[i]&gt;capacity) return false;
        }
        return true;
    }
};
通过差分的思想，维护一个差分数组，使得多次对数组内容增删操作可以在数组遍历外部一次实现。从n*m的复杂度变为n+m
</code></pre> 
<h6><a id="1_190"></a>1、服务器能耗统计</h6> 
<p>服务器有三种运行状态:空载、单任务、多任务，每个时间片的能耗的分别为1、3、4;</p> 
<p>每个任务由起始时间片和结束时间片定义运行时间:</p> 
<p>如果一个时间片只有一个任务需要执行，则服务器处于单任务状态；</p> 
<p>如果一个时间片有多个任务需要执行，则服务器处于多任务状态；</p> 
<p>给定一个任务列表，请计算出从第一个任务开始，到所有任务结束，服务器的总能耗。</p> 
<pre><code class="prism language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int N = 1e7;
vector&lt;int&gt;vec(N,0);
int n;
int main(){
    cin&gt;&gt;n;
    int max=0;
    for(int i=0;i&lt;n;i++){
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        max = max&lt;b? b:max;
        vec[a]+=1;
        if(b&lt;N) vec[b+1]-=1;
    }
    for(int i=1;i&lt;vec.size();i++){
        vec[i]+=vec[i-1];
    }
    int ans=0;
    int start=0;
    for(int i=0;i&lt;=max;i++){
        int c = vec[i];
        if(vec[i]!=0) start=1;
        if(start==1){
            if(c==0) ans+=1;
            else if(c==1) ans+=3;
            else if(c&gt;1) ans+=4;
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
在这道题中，每一个时间片段，通过差分加1.。然后再输入数据的过程中，得到工作的最大时长。
</code></pre> 
<h3><a id="31__236"></a>3.1 前缀和</h3> 
<h4><a id="311__237"></a>3.1.1 连续子数组的和</h4> 
<h6><a id="1031__238"></a>1031. 两个非重叠子数组的最大和</h6> 
<p>给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。</p> 
<p>长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。</p> 
<p>子数组是数组的一个 连续 部分。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; nums, int firstLen, int secondLen) {
        vector&lt;int&gt;pre(nums.size()+1,0);
        for(int i=1;i&lt;=nums.size();i++){
            pre[i]=pre[i-1]+nums[i-1];
        }
        
        int n = nums.size();
        int ans=0;

        for(int i=0;i+firstLen-1&lt;n;i++){
            int fir_sum=0;
            int se_sum=0;
            int path=0;
            int fir_end = i+firstLen-1;
            fir_sum = pre[fir_end+1]-pre[i];

            for(int j=0;j+secondLen-1&lt;i;j++){
                int se_end = j+secondLen-1;
                se_sum = pre[se_end+1]-pre[j];
                path=fir_sum+se_sum;
                ans = ans&lt;path? path:ans;
                
            }
            for(int j=fir_end+1;j+secondLen-1&lt;n;j++){
                int se_end = j+secondLen-1;
                se_sum = pre[se_end+1]-pre[j];
                path=fir_sum+se_sum;
                ans = ans&lt;path? path:ans;
            }
        }
        return ans;
    }
};
思路为通过前缀和，免去相加的循环部分，然后用n2的复杂度爆搜。
</code></pre> 
<h6><a id="2106__282"></a>2106. 摘水果</h6> 
<p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。</p> 
<p>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p> 
<p>返回你可以摘到水果的 最大总数 。</p> 
<pre><code class="prism language-c++">class Solution {
public:
    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) {
        int N = 2e5;
        int n = fruits.size();
        if(n==1&amp;&amp;k!=0) return fruits[0][1];
        vector&lt;int&gt;dist(N+1,0);
        for(int i=0;i&lt;n;i++){
            vector&lt;int&gt; tmp = fruits[i];
            int a = tmp[0];
            int b = tmp[1];
            dist[a] = b;
        }
        vector&lt;int&gt; presum(N+2,0);
        for(int i=1;i&lt;=N+1;i++){
            presum[i]+=presum[i-1]+dist[i-1];
        }
        if(k==0) return dist[startPos];
        int ans=0;
        for(int x=k;x&gt;=0;x--){
            int y = (k - x) / 2;
            int l, r;
            // x + 2y = k
            l = startPos - x, r = startPos + y;

            if(l&gt;=0&amp;&amp;r&lt;=N) ans = max(ans, presum[r+1] - presum[l]);
            // 2y + x = k
            l = startPos - y, r = startPos + x;

            if(l&gt;=0&amp;&amp;r&lt;=N) ans = max(ans, presum[r+1] - presum[l]);

        }
        return ans;
    }
};
先求出无限数组的前缀和，然后通过二分法遍历每一种可能得步法。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/110e6c931ac13d4e4e4b21cae1f7d861/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nvm如何变更npm版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c6e239029a1250ec300f1976b78f2ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C/C&#43;&#43; 基于Linux的高并发后台服务器-经验小结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>