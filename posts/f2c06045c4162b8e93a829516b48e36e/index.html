<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AveragePooling1D层 和 MaxPooling1D layer - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AveragePooling1D层 和 MaxPooling1D layer" />
<meta property="og:description" content="AveragePooling1D层
tf.keras.layers.AveragePooling1D(
pool_size=2, strides=None, padding=“valid”, data_format=“channels_last”, **kwargs
)
平均池化用于时序数据。
下采样输入表示，通过对被定义为pool_size的窗口取平均值。窗口根据步长strides进行切换。
当使用&#34;valid&#34; （padding）填充选项时，结果的输出的形状为：output_shape = (input_shape - pool_size &#43; 1) / strides)
示例代码1：
x = tf.constant([1., 2., 3., 4., 5.])
x = tf.reshape(x, [1, 5, 1])
x
&lt;tf.Tensor: shape=(1, 5, 1), dtype=float32, numpy=
array([[[1.],
[2.],
[3.],
[4.],
[5.]], dtype=float32)&gt;
avg_pool_1d = tf.keras.layers.AveragePooling1D(pool_size=2,
… strides=1, padding=‘valid’)
avg_pool_1d(x)
&lt;tf.Tensor: shape=(1, 4, 1), dtype=float32, numpy=
array([[[1.5],
[2.5],
[3.5],
[4.5]]], dtype=float32)&gt;
当使用&#34;same&#34;（padding）填充选项时，输出形状：output_shape = input_shape / strides" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f2c06045c4162b8e93a829516b48e36e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-25T11:45:04+08:00" />
<meta property="article:modified_time" content="2024-02-25T11:45:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AveragePooling1D层 和 MaxPooling1D layer</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>AveragePooling1D层<br> tf.keras.layers.AveragePooling1D(<br> pool_size=2, strides=None, padding=“valid”, data_format=“channels_last”, **kwargs<br> )<br> 平均池化用于时序数据。<br> 下采样输入表示，通过对被定义为pool_size的窗口取平均值。窗口根据步长strides进行切换。<br> 当使用"valid" （padding）填充选项时，结果的输出的形状为：output_shape = (input_shape - pool_size + 1) / strides)<br> 示例代码1：</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>x = tf.constant([1., 2., 3., 4., 5.])<br> x = tf.reshape(x, [1, 5, 1])<br> x<br> &lt;tf.Tensor: shape=(1, 5, 1), dtype=float32, numpy=<br> array([[[1.],<br> [2.],<br> [3.],<br> [4.],<br> [5.]], dtype=float32)&gt;<br> avg_pool_1d = tf.keras.layers.AveragePooling1D(pool_size=2,<br> … strides=1, padding=‘valid’)<br> avg_pool_1d(x)<br> &lt;tf.Tensor: shape=(1, 4, 1), dtype=float32, numpy=<br> array([[[1.5],<br> [2.5],<br> [3.5],<br> [4.5]]], dtype=float32)&gt;<br> 当使用"same"（padding）填充选项时，输出形状：output_shape = input_shape / strides<br> 示例代码2：<br> x = tf.constant([1., 2., 3., 4., 5.])<br> x = tf.reshape(x, [1, 5, 1])<br> x<br> &lt;tf.Tensor: shape=(1, 5, 1), dtype=float32, numpy=<br> array([[[1.],<br> [2.],<br> [3.],<br> [4.],<br> [5.]], dtype=float32)&gt;<br> avg_pool_1d = tf.keras.layers.AveragePooling1D(pool_size=2,<br> … strides=1, padding=‘same’)<br> avg_pool_1d(x)<br> &lt;tf.Tensor: shape=(1, 5, 1), dtype=float32, numpy=<br> array([[[1.5],<br> [2.5],<br> [3.5],<br> [4.5],<br> [5.]]], dtype=float32)&gt;<br> 参数：<br> pool_size：平均池化窗口的大小；<br> strides：步长，如果是None，它默认值为pool_size。<br> data_format：字符串，可选项为“channels_last”和“channels_first”。也就是输入中的维度排序，channels_last 对应于inputs with shape (batch, steps, features)，channels_first 对应于 inputs with shape (batch, features, steps)。<br> GlobalAveragePooling1D层<br> tf.keras.layers.GlobalAveragePooling1D(data_format=“channels_last”, **kwargs)</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>示例代码：</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>input_shape = (2, 3, 4)<br> x = tf.random.normal(input_shape)<br> y = tf.keras.layers.GlobalAveragePooling1D()(x)<br> print(y.shape)</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>1、MaxPooling1D layer<br> 一维最大池化层</p> 
<p>keras.layers.MaxPooling1D(<br> pool_size=2, strides=None, padding=“valid”, data_format=None, name=None, **kwargs<br> )<br> 参数说明<br> pool_size：整数或整数元组，表示池化窗口的大小。如果为整数，则在每个维度上使用相同的池化窗口大小。例如，pool_size=2 表示在每个维度上使用大小为 2 的池化窗口。<br> strides：整数或整数元组，表示池化窗口在每个维度上的步长。如果为整数，则在每个维度上使用相同的步长。例如，strides=2 表示在每个维度上使用步长为 2 的池化窗口。默认值为 None，此时步长与池化窗口大小相同。<br> padding：字符串，表示填充方式。可选值为 “valid”（不填充）和 “same”（填充）。默认值为 “valid”。<br> data_format：字符串，表示输入数据的格式。可选值为 “channels_first”（通道优先）和 “channels_last”（通道最后一个）。默认值为 None，此时根据 TensorFlow 的版本自动选择数据格式。<br> name：字符串，表示该层的名称。默认值为 None。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a469a0950950cefdecc94098c862d40e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(None, 0, 5) 用keras.layers.MaxPool1D 出错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/882b5ba2b8a73043935b91ace2479553/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【大数据】Flink 内存管理（四）：TaskManager 内存分配（实战篇）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>