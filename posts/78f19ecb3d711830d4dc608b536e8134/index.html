<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>光流法 HS与LK - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="光流法 HS与LK" />
<meta property="og:description" content="1、HS算法
#include &#34;cv.h&#34; #include &#34;highgui.h&#34; #include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &#34;opencv2/legacy/legacy.hpp&#34; #define CVX_GRAY50 cvScalar(100) #define CVX_WHITE cvScalar(255) int main(int argc, char** argv) { // Initialize, load two images from the file system, and // allocate the images and other structures we will need for // results. // exit if no input images IplImage *imgA = 0, *imgB = 0; //imgA = cvLoadImage(&#34;OpticalFlow0.jpg&#34;,0); //imgB = cvLoadImage(&#34;OpticalFlow1.jpg&#34;,0); //if(!(imgA)||!(imgB)){ printf(&#34;One of OpticalFlow0.jpg and/or OpticalFlow1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/78f19ecb3d711830d4dc608b536e8134/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-03T14:55:33+08:00" />
<meta property="article:modified_time" content="2016-12-03T14:55:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">光流法 HS与LK</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、HS算法</p> 
<p></p> 
<pre><code class="language-cpp">#include "cv.h"
#include "highgui.h"
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include "opencv2/legacy/legacy.hpp"
#define CVX_GRAY50 cvScalar(100)
#define CVX_WHITE  cvScalar(255)

int main(int argc, char** argv)
{
    // Initialize, load two images from the file system, and
    // allocate the images and other structures we will need for
    // results.

    // exit if no input images
	 IplImage *imgA = 0, *imgB = 0;
    //imgA = cvLoadImage("OpticalFlow0.jpg",0);
    //imgB = cvLoadImage("OpticalFlow1.jpg",0);
    //if(!(imgA)||!(imgB)){ printf("One of OpticalFlow0.jpg and/or OpticalFlow1.jpg didn't load\n"); return -1;}
	imgA = cvLoadImage("OpticalFlow0.jpg",0);
    imgB = cvLoadImage("OpticalFlow1.jpg",0);
    if(!(imgA)||!(imgB)){ printf("One of OpticalFlow0.jpg and/or OpticalFlow1.jpg didn't load\n"); return -1;}

    IplImage* velx = cvCreateImage(cvGetSize(imgA),IPL_DEPTH_32F,1);
    IplImage* vely = cvCreateImage(cvGetSize(imgA),IPL_DEPTH_32F,1);

    IplImage* imgC = cvCreateImage(cvGetSize(imgA),IPL_DEPTH_8U,3);

    cvNamedWindow( "OpticalFlow0" );
    cvNamedWindow( "OpticalFlow1" );
    cvNamedWindow( "Flow Results" );

    cvShowImage( "OpticalFlow0",imgA );
    cvShowImage( "OpticalFlow1",imgB );

    // Call the actual Horn and Schunck algorithm
    //
    cvCalcOpticalFlowHS( 
        imgA, 
        imgB, 
        0,
        velx,
        vely,
        .10,
        cvTermCriteria( 
            CV_TERMCRIT_ITER | CV_TERMCRIT_EPS,
            imgA-&gt;width,
            1e-6
        )
    );

    // Now make some image of what we are looking at:
    //
    cvZero( imgC );
    int step = 4;
    for( int y=0; y&lt;imgC-&gt;height; y += step ) {
        float* px = (float*) ( velx-&gt;imageData + y * velx-&gt;widthStep );
        float* py = (float*) ( vely-&gt;imageData + y * vely-&gt;widthStep );
        for( int x=0; x&lt;imgC-&gt;width; x += step ) {
            if( px[x]&gt;1 &amp;&amp; py[x]&gt;1 ) {
                cvCircle(
                    imgC,
                    cvPoint( x, y ),
                    2,
                    CVX_GRAY50,
                    -1
                );
                cvLine(
                    imgC,
                    cvPoint( x, y ),
                    cvPoint( x+px[x]/2, y+py[x]/2 ),
                    CV_RGB(255,0,0),
                    1,
                    0
                );
            }
        }
    }
    // show tracking
    cvShowImage( "Flow Results",imgC );
    
    cvWaitKey(0);

    // destroy windows
    cvDestroyWindow( "OpticalFlow0" );
    cvDestroyWindow( "OpticalFlow1" );
    cvDestroyWindow( "Flow Results" );
    // release memory
    cvReleaseImage( &amp;imgA );
    cvReleaseImage( &amp;imgB );
    cvReleaseImage( &amp;imgC );

    return 0;
}
</code></pre> 
<p></p> 
<p><br> </p> 2、LK算法 
<p></p> 
<pre><code class="language-cpp">#include "cv.h"
#include "cxcore.h"
#include "highgui.h"
#include "stdio.h"

const int MAX_CORNERS = 500;
int main(int argc, char** argv) {
   // Initialize, load two images from the file system, and
   // allocate the images and other structures we will need for
   // results.
	//IplImage* imgA = cvLoadImage("OpticalFlow0.jpg",CV_LOAD_IMAGE_GRAYSCALE);
	//IplImage* imgB = cvLoadImage("OpticalFlow1.jpg",CV_LOAD_IMAGE_GRAYSCALE);
	IplImage* imgA = cvLoadImage("3.jpg",CV_LOAD_IMAGE_GRAYSCALE);
	IplImage* imgB = cvLoadImage("4.jpg",CV_LOAD_IMAGE_GRAYSCALE);
	//IplImage* imgA = cvLoadImage("10.png",CV_LOAD_IMAGE_GRAYSCALE);
	//IplImage* imgB = cvLoadImage("11.png",CV_LOAD_IMAGE_GRAYSCALE);
	CvSize      img_sz    = cvGetSize( imgA );
	int         win_size = 10;
	//IplImage* imgC = cvLoadImage("OpticalFlow1.jpg",CV_LOAD_IMAGE_UNCHANGED);
	IplImage* imgC = cvLoadImage("4.jpg",CV_LOAD_IMAGE_UNCHANGED);
	//IplImage* imgC = cvLoadImage("11.png",CV_LOAD_IMAGE_UNCHANGED);
	
	// The first thing we need to do is get the features
	// we want to track.
	//
	IplImage* eig_image = cvCreateImage( img_sz, IPL_DEPTH_32F, 3 );
	IplImage* tmp_image = cvCreateImage( img_sz, IPL_DEPTH_32F, 3 );
	int              corner_count = MAX_CORNERS;
	CvPoint2D32f* cornersA        = new CvPoint2D32f[ MAX_CORNERS ];
	cvGoodFeaturesToTrack(
		imgA,
		eig_image,
		tmp_image,
		cornersA,
		&amp;corner_count,
		0.01,
		5.0,
		0,
		3,
		0,
		0.04
	);
	cvFindCornerSubPix(
		imgA,
		cornersA,
		corner_count,
		cvSize(win_size,win_size),
		cvSize(-1,-1),
		cvTermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS,20,0.03)
	);
	// Call the Lucas Kanade algorithm
	//
	char features_found[ MAX_CORNERS ];
	float feature_errors[ MAX_CORNERS ];
	CvSize pyr_sz = cvSize( imgA-&gt;width+8, imgB-&gt;height/3 );
	IplImage* pyrA = cvCreateImage( pyr_sz, IPL_DEPTH_32F,3 );
    IplImage* pyrB = cvCreateImage( pyr_sz, IPL_DEPTH_32F,3 );
  CvPoint2D32f* cornersB        = new CvPoint2D32f[ MAX_CORNERS ];
  cvCalcOpticalFlowPyrLK(
     imgA,
     imgB,
     pyrA,
     pyrB,
     cornersA,
     cornersB,
     corner_count,
     cvSize( win_size,win_size ),
     5,
     features_found,
     feature_errors,
     cvTermCriteria( CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, .3 ),
     0
  );
  // Now make some image of what we are looking at:
  //
  for( int i=0; i&lt;corner_count; i++ ) {
     if( features_found[i]==0|| feature_errors[i]&gt;550 ) {
 //       printf("Error is %f/n",feature_errors[i]);
        continue;
     }
 //    printf("Got it/n");
     CvPoint p0 = cvPoint(
        cvRound( cornersA[i].x ),
        cvRound( cornersA[i].y )
     );
     CvPoint p1 = cvPoint(
        cvRound( cornersB[i].x ),
        cvRound( cornersB[i].y )
     );
     cvLine( imgC, p0, p1, CV_RGB(255,0,0),2 );
  }
  cvNamedWindow("ImageA",0);
  cvNamedWindow("ImageB",0);
  cvNamedWindow("LKpyr_OpticalFlow",0);
  cvShowImage("ImageA",imgA);
  cvShowImage("ImageB",imgB);
  cvShowImage("LKpyr_OpticalFlow",imgC);
  cvWaitKey(0);
  return 0;
}</code></pre> 
<br> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/123e61b7454e1bdcd91e6ac62ce705bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nodejs取得当前执行路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/304894cc7fc6065ed3514b47a664d817/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">光流法目标跟踪</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>