<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>时间序列预测算法总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="时间序列预测算法总结" />
<meta property="og:description" content="一、背景介绍 绝大部分行业场景，尤其是互联网、量化行业，每天都会产生大量的数据。金融领域股票价格随时间的走势；电商行业每日的销售额；旅游行业随着节假日周期变化的机票酒店价格等；我们称这种不同时间收到的，描述一个或多种特征随着时间发生变化的数据，为时间序列数据（Time Series Data）。而时间序列预测做的就是通过多种维度的数据本身内在与时间的关联特性，利用历史的数据预测未来这么一件事情。
二、算法汇总 时序预测从不同角度看有不同分类：
从实现原理的角度，可以分为传统统计学，机器学习（又分非深度学习和深度学习）。 按预测步长区分，可以分为单步预测和多步预测，简单来说就是一次预测未来一个时间单元还是一次预测未来多个时间单元的区别。 按输入变量区分，可以分为自回归预测和使用协变量进行预测，区别在于维度中是否含有协变量，例如预测未来销售量时，如果只接受时间和历史销售量数据，则是自回归预测，如果可以接受天气、经济指数、政策事件分类等其他相关变量（称为协变量），则称为使用协变量进行预测。 按输出结果区分，可以分为点预测和概率预测，很多模型只提供了点预测而不提供概率预测，点预测模型后再加蒙特卡洛模拟（或其他转化为概率预测的方式）往往不能准确反映模型输出的预测概念，而在大多数场景下，概率预测更贴近事实情况，对于未来的预测本身就应该是一种概率分布。 按目标个数区分，可以分为一元、多元、多重时间序列预测。举例理解，使用历史的销售量预测未来1天的销售量为一元时间序列预测，使用历史的进店人数、销售量、退货量预测未来1天的进店人数、销售量、退货量（预测目标有三个）为多元时间序列预测，使用历史的红烧牛肉面、酸菜牛肉面、海鲜面的销售量预测未来1天的红烧牛肉面、酸菜牛肉面、海鲜面的销售量（预测目标有三种）为多重时间序列预测。 [1] 本文接下来会从实现原理的角度切入，大致介绍一下场景的时间序列预测方法的原理以及具体python实现，大部分深度学习的实现依赖于AWS于2019开源的时间序列建模工具包Gluon Time Series（GluonTS）
2.1 传统经典时间序列预测方法 ARIMA 简介 ARIMA是一种非常流行的时间序列预测统计方法，它是自回归综合移动平均（Auto-Regressive Integrated Moving Averages）的首字母缩写。ARIMA模型建立在以下假设的基础上： 数据序列是平稳的，这意味着均值和方差不应随时间而变化。 通过对数变换或差分可以使序列平稳。
算法详解：时间序列预测之ARIMA - 标点符实现（GluonTS） from gluonts.model.r_forecast import RForecastPredictor # build model arima_estimator = RForecastPredictor(freq=&#39;1D&#39;, prediction_length=args.horizon, method_name=&#34;arima&#34;) # Predicting forecast_df = pd.DataFrame(columns=[&#39;id&#39;, &#39;target_start_date&#39;, &#39;point_fcst_value&#39;]) # df_pred for entry_, forecast_ in tqdm(zip(training_data, estimator.predict(training_data))): id = entry_[&#34;id&#34;] forecast_df = forecast_df.append( pd.DataFrame({&#34;id&#34;: id, &#34;target_start_date&#34;: forecast_.index.map(lambda s: s.strftime(&#39;%Y%m%d&#39;)), &#34;point_fcst_value&#34;: forecast_.median})) Holt-Winters 简介 其实就是一种（三次）指数平滑方法，Holt (1957) 和 Winters (1960) 将Holt方法进行拓展用来捕获季节因素。Holt-Winters季节性方法包括预测方程和三个平滑方程：一个用于水平 ，一个用于趋势 ，另一个用于季节性分量。然后以累加或累乘的方式叠加分量组成预测。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/58c8d33cb95a8634780aa47380f90325/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-07T16:18:03+08:00" />
<meta property="article:modified_time" content="2022-12-07T16:18:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">时间序列预测算法总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="h_421710621_0">一、背景介绍</h3> 
<p>        绝大部分行业场景，尤其是互联网、量化行业，每天都会产生大量的数据。金融领域股票价格随时间的走势；电商行业每日的销售额；旅游行业随着节假日周期变化的机票酒店价格等；我们称这种不同时间收到的，描述一个或多种特征随着时间发生变化的数据，为时间序列数据（Time Series Data）。而时间序列预测做的就是<strong>通过多种维度的数据本身内在与时间的关联特性</strong>，<strong>利用历史的数据预测未来</strong>这么一件事情。</p> 
<h3 id="h_421710621_1">二、算法汇总</h3> 
<p>时序预测从不同角度看有不同分类：</p> 
<blockquote>
          从实现原理的角度，可以分为传统统计学，机器学习（又分非深度学习和深度学习）。 
 <br>         按预测步长区分，可以分为单步预测和多步预测，简单来说就是一次预测未来一个时间单元还是一次预测未来多个时间单元的区别。 
 <br>         按输入变量区分，可以分为自回归预测和使用协变量进行预测，区别在于维度中是否含有协变量，例如预测未来销售量时，如果只接受时间和历史销售量数据，则是自回归预测，如果可以接受天气、经济指数、政策事件分类等其他相关变量（称为协变量），则称为使用协变量进行预测。 
 <br>         按输出结果区分，可以分为点预测和概率预测，很多模型只提供了点预测而不提供概率预测，点预测模型后再加蒙特卡洛模拟（或其他转化为概率预测的方式）往往不能准确反映模型输出的预测概念，而在大多数场景下，概率预测更贴近事实情况，对于未来的预测本身就应该是一种概率分布。 
 <br>         按目标个数区分，可以分为一元、多元、多重时间序列预测。举例理解，使用历史的销售量预测未来1天的销售量为一元时间序列预测，使用历史的进店人数、销售量、退货量预测未来1天的进店人数、销售量、退货量（预测目标有三个）为多元时间序列预测，使用历史的红烧牛肉面、酸菜牛肉面、海鲜面的销售量预测未来1天的红烧牛肉面、酸菜牛肉面、海鲜面的销售量（预测目标有三种）为多重时间序列预测。 
 <a href="https://zhuanlan.zhihu.com/p/421710621#ref_1" rel="nofollow" id="ref_1_0" title="[1]">[1]</a> 
</blockquote> 
<p>        本文接下来会从实现原理的角度切入，大致介绍一下场景的时间序列预测方法的原理以及具体python实现，大部分深度学习的实现依赖于AWS于2019开源的时间序列建模工具包Gluon Time Series（GluonTS）</p> 
<h3 id="h_421710621_2">2.1 传统经典时间序列预测方法</h3> 
<h3 id="h_421710621_3">ARIMA</h3> 
<ul><li>简介</li></ul> 
<p>        ARIMA是一种非常流行的时间序列预测统计方法，它是自回归综合移动平均（Auto-Regressive Integrated Moving Averages）的首字母缩写。ARIMA模型建立在以下假设的基础上： 数据序列是平稳的，这意味着均值和方差不应随时间而变化。 通过对数变换或差分可以使序列平稳。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//www.biaodianfu.com/arima.html" rel="nofollow" title="时间序列预测之ARIMA - 标点符">时间序列预测之ARIMA - 标点符</a></li><li>实现（GluonTS）</li></ul> 
<pre><code>from gluonts.model.r_forecast import RForecastPredictor
# build model
arima_estimator = RForecastPredictor(freq='1D', prediction_length=args.horizon, method_name="arima")
# Predicting 
forecast_df = pd.DataFrame(columns=['id', 'target_start_date', 'point_fcst_value'])  # df_pred
for entry_, forecast_ in tqdm(zip(training_data, estimator.predict(training_data))):
     id = entry_["id"]
     forecast_df = forecast_df.append( 
                       pd.DataFrame({"id": id,
                                     "target_start_date": forecast_.index.map(lambda s: s.strftime('%Y%m%d')),
                                     "point_fcst_value": forecast_.median}))</code></pre> 
<h3 id="h_421710621_4">Holt-Winters</h3> 
<ul><li>简介</li></ul> 
<p>        其实就是一种（三次）指数平滑方法，<a href="https://link.zhihu.com/?target=https%3A//otexts.com/fppcn/holt-winters.html%23ref-Holt57" rel="nofollow" title="Holt">Holt</a> (<a href="https://link.zhihu.com/?target=https%3A//otexts.com/fppcn/holt-winters.html%23ref-Holt57" rel="nofollow" title="1957">1957</a>) 和 <a href="https://link.zhihu.com/?target=https%3A//otexts.com/fppcn/holt-winters.html%23ref-Winters60" rel="nofollow" title="Winters">Winters</a> (<a href="https://link.zhihu.com/?target=https%3A//otexts.com/fppcn/holt-winters.html%23ref-Winters60" rel="nofollow" title="1960">1960</a>) 将Holt方法进行拓展用来捕获季节因素。Holt-Winters季节性方法包括预测方程和三个平滑方程：一个用于水平 ，一个用于趋势 ，另一个用于季节性分量。然后以累加或累乘的方式叠加分量组成预测。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//otexts.com/fppcn/holt-winters.html" rel="nofollow" title="7.3 Holt-Winters季节性方法 | 预测： 方法与实践">7.3 Holt-Winters季节性方法 | 预测： 方法与实践</a></li><li>实现</li></ul> 
<pre><code>from statsmodels.tsa.holtwinters import ExponentialSmoothing
data = pd.Series(data)
yhat = ExponentialSmoothing(data, seasonal_periods=4, trend='add', seasonal='add').fit(use_boxcox=True)</code></pre> 
<p> </p> 
<h3 id="h_421710621_5">Facebook Prophet</h3> 
<ul><li>简介</li></ul> 
<p>        prophet 算法是基于时间序列分解（同上：seasonal、trend、residual）和机器学习的拟合来做的，它最适用于具有强烈季节性影响和多个季节历史数据的时间序列。Prophet 对缺失数据和趋势变化具有稳健性，并且通常可以很好地处理异常值。</p> 
<ul><li>算法详解：<a href="https://zhuanlan.zhihu.com/p/52330017" rel="nofollow" title="张戎：Facebook 时间序列预测算法 Prophet 的研究">张戎：Facebook 时间序列预测算法 Prophet 的研究</a></li><li>实现（GluonTS）</li></ul> 
<pre><code>from gluonts.model.prophet import ProphetPredictor
# build model
prophet_estimator = ProphetPredictor(freq='1D',
                             prediction_length=args.horizon,
                             prophet_params={'daily_seasonality': True,
                                             'weekly_seasonality': True,
                                             'changepoint_prior_scale': 0.03,
                                             'changepoint_range': 0.5,
                                             'seasonality_mode': 'multiplicative'
                                                         }
# Predicting 
# same as above</code></pre> 
<h3 id="h_421710621_6">2.2 特征工程+ML类方法</h3> 
<h3 id="h_421710621_7">GBM类回归算法</h3> 
<ul><li>简介</li></ul> 
<p>        Boosting 是集成学习中非常重要的一类算法，其基本原理是串行生成一系列弱学习器（weak learner），这些弱学习器直接通过组合到一起构成最终的模型。Boosting 算法可以用于解决分类和回归问题，主要的算法包括早期的AdaBoost 和 后续的Gradient Boosting。</p> 
<p>        而GBDT（Gradient Boosting Decision Tree）是弱学习器使用 <u><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2586%25B3%25E7%25AD%2596%25E6%25A0%2591%25E5%25AD%25A6%25E4%25B9%25A0" rel="nofollow" title="CART">CART</a></u> 回归树的一种 Gradient Boosting，使用决策树作为弱学习器的一个好处是：决策树本身是一种不稳定的学习器（训练数据的一点波动可能给结果带来较大的影响），从统计学的角度单棵决策树的方差比较大。而在集成学习中，弱学习器间方差越大，弱学习器本身泛化性能越好，则集成学习模型的泛化性能就越好。因此使用决策树作为弱学习器通常比使用较稳定的弱学习器（如线性回归等）泛化性能更好。</p> 
<p>        包括后续演变而出的XGBoost和LightGBM算法等基于GBM的衍生算法，在早年由于泛化性好，训练速度快等优点在Kaggle等比赛中得到广泛使用。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//voidoc.blog/21629.html%2341-xgboost%25E5%259F%25BA%25E6%259C%25AC%25E6%2580%259D%25E6%2583%25B3" rel="nofollow" title="机器学习 | 梯度提升机GBM(Grandient Boosting Machine)详解">机器学习 | 梯度提升机GBM(Grandient Boosting Machine)详解</a></li><li>实现</li></ul> 
<pre><code>from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split

# 重新分割训练和测试数据
dm_trainDF = dm_allDF[:len(trainDF)]
dm_testDF = dm_allDF[len(trainDF):]

# 去掉id号
train_data = dm_trainDF.drop(['Id'],axis=1).values
train_label = trainDF_label.values

X_test_ids = dm_testDF['Id'].values
X_test = dm_testDF.drop(['Id'],axis=1).values

# 分割训练集和验证集
X_train, X_valid, Y_train, Y_valid = train_test_split(train_data, train_label,test_size=0.2)

xgb = XGBRegressor(n_estimators=500, learning_rate=0.05, min_child_weight=5, max_depth=4)
xgb.fit(X_train,Y_train)
print "Validation:",xgb.score(X_valid,Y_valid)

predict = xgb.predict(X_test)</code></pre> 
<h3 id="h_421710621_10">2.3 深度学习类方法</h3> 
<h3 id="h_421710621_11">2.3.1 Seq2Seq类</h3> 
<p><strong>如RNN、LSTM、DeepAR等</strong></p> 
<h3 id="h_421710621_12"><strong>DeepAR</strong></h3> 
<ul><li>简介</li></ul> 
<p>        DeepAR 是一个自回归循环神经网络，使用递归神经网络 (RNN) 结合自回归 AR 来预测标量（一维）时间序列。可以冷启动预测，直接学习概率分布的参数，但受限于RNN框架，对于较长时间的周期季节等信息则难以补获。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1704.04110" rel="nofollow" title="DeepAR：概率性预测与自回归递归网络">DeepAR：概率性预测与自回归递归网络</a>。</li><li>实现（GluonTS）</li></ul> 
<pre><code>from gluonts.model.deepar import DeepAREstimator
# build model  
deepar_estimator = DeepAREstimator(
        freq="1D",
        num_layers=num_layers,
        num_cells=num_cells,
        cell_type=cell_type,
        dropout_rate=dropout_rate,
        prediction_length=args.horizon,
        trainer=Trainer(epochs=80))

# Predicting 
# same as above</code></pre> 
<ul><li>协变量引入实现</li></ul> 
<blockquote>
  确定输入的协变量的参数： 
 <br>         use_feat_dynamic_real：是否启用时变连续变量作为协变量，如果我们调用天气信息作为协变量，需要设置为True 
 <br>         use_feat_static_cat：是否采用时不变类别变量作为协变量，这里我们设置为True，因为我们需要提供观测点的信息​。对于上文提到的管网和测点分布，如果合理分析，可以提取更多有用的时不变类别信息 
 <br>         use_feat_static_real：是否启用时不变连续变量作为协变量，这里我们设置为False 
 <br>         lags_seq：显式设置lag参数，否则系统自动计算lag 
 <br>         time_features：显式设置时间特征，否则系统自动计算 
</blockquote> 
<p>        输入数据的格式相对简单，因为GluonTS对输入数据格式ListDataset要求比较宽松。<strong>多重时间序列用list表示，每个时间序列需要指定一个字典</strong>：</p> 
<ul><li>Target：预测对象</li><li>start：预测起始值</li><li>FieldName.FEAT_STATIC_CAT：时不变类别变量</li><li>FieldName. FEAT_DYNAMIC_REAL：时变连续变量</li><li>等等其他FieldName</li></ul> 
<p>详见： <a href="https://zhuanlan.zhihu.com/p/348889806" rel="nofollow" title="数据如琥珀：多重时序高阶算法-DeepAR（供水管网压力预测Baseline）">数据如琥珀：多重时序高阶算法-DeepAR（供水管网压力预测Baseline）</a></p> 
<blockquote> 
 <strong>对deepAR引入的协变量是“动态cat feature”还是 “静态cat feature”区分的讨论：</strong> 
 <br> 
 <a href="https://link.zhihu.com/?target=https%3A//github.com/awslabs/gluon-ts/issues/392" title="https://github.com/awslabs/gluon-ts/issues/392">https://github.com/awslabs/gluon-ts/issues/392</a> 
 <br> 
 <a href="https://zhuanlan.zhihu.com/p/383036166" rel="nofollow" title="马东什么：temporal fusion transformer">马东什么：temporal fusion transformer</a> 
</blockquote> 
<ul><li>context <em>length澄清：context_length即滑动窗口长度。</em>我们要训练 DeepAR 模型，让它能基于之前的 context_length 值预测下一个 prediction_length 值。 DeepAR 模型并不是对每个未来的时间点提供单一的预测值，而是针对每个输出点给出一个参数化的概率分布。<a href="https://zhuanlan.zhihu.com/p/421710621#ref_3" rel="nofollow" id="ref_3_0" title="[3]">[3]</a></li></ul> 
<pre><code>import tqdm
from gluonts.model.deepar import DeepAREstimator

# Building training dataset
train_data_list = []
def _split_times_series(df, data_list, dynamic_real_1, dynamic_cat_1, dynamic_cat_2):
    new_df = df.sort_values(by=date_col, ascending=True)
    time_series_dict = {
            "item_id": new_df[id_col].values[0],
            "start": pd.to_datetime(new_df[date_col].min()),
            "target": new_df[target_col].values,
            "dynamic_real_1": [dynamic_real_1.T], # 主要是这行的差别
            "dynamic_cat_1": dynamic_cat_1,
            "dynamic_cat_2": dynamic_cat_2,
    }
    data_list.append(time_series_dict)

tqdm.pandas(desc='progress: ')
train_df.groupby(train_df[id_col]).progress_apply(_split_times_series,
       data_list=train_data_list,
       dynamic_real_1=camp_df_real_features_for_train,
       dynamic_cat_1=camp_df_cat1_features_for_train,
       dynamic_cat_2=camp_df_cat2_features_for_train)

training_data = ListDataset(train_data_list, freq="1D")

# build model 
rmv_imputation = RollingMeanValueImputation(10)
estimator = DeepAREstimator(
                freq="1D",
                num_layers=num_layers,
                num_cells=num_cells,
                prediction_length=args.horizon,
                imputation_method=rmv_imputation,
                impute_missing_values=True,
                use_feat_dynamic_real=True,
                trainer=Trainer(epochs=epochs))

# Predicting 
# same as above</code></pre> 
<ul><li><strong>Does DeepAR need features and target to be normalized？</strong></li></ul> 
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/aws/amazon-sagemaker-examples/issues/1312" title="https://github.com/aws/amazon-sagemaker-examples/issues/1312">https://github.com/aws/amazon-sagemaker-examples/issues/1312</a></p> 
<h3 id="h_421710621_13">2.3.2 CNN类</h3> 
<p><strong>如TCN、WaveNet等</strong></p> 
<h3 id="h_421710621_14">WaveNet</h3> 
<ul><li>简介</li></ul> 
<p>        WaveNet是DeepMind于2016年9月提出的一种基于空洞因果卷积式的语音生产模型，后面专家们发现它也可被用于时间序列的预测，他的感受野较大，网络结构可以自动的在不同时间尺度上提取周期信息。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//deepmind.com/blog/article/high-fidelity-speech-synthesis-wavenet" rel="nofollow" title="High-fidelity speech synthesis with WaveNet">High-fidelity speech synthesis with WaveNet</a></li><li>实现（GluonTS）</li></ul> 
<pre><code>rom gluonts.model.wavenet import WaveNetEstimator
# build model  
wavenet_estimator = WaveNetEstimator(
        freq="1D",
        n_residue=n_residue,
        embedding_dimension=embedding_dimension,
        act_type=act_type,
        n_skip=n_skip,
        prediction_length=args.horizon,
        trainer=Trainer(epochs=50, learning_rate=learning_rate)
    )

# Predicting 
# same as above</code></pre> 
<h3 id="h_421710621_15">2.3.3 参数回归类</h3> 
<h3 id="h_421710621_16"><strong>N-BEATS</strong></h3> 
<ul><li>简介</li></ul> 
<p>        N-BEATS是Bengio团队于2019年5月提出的用于时间序列预测的深度网络，主要结构包括前向后向残差链接以及不同的模块分解。他的可解释性相较其他深度学习模型会强一些（通过模块分解），但由于其存在复原原序列的过程，因此预测结果的稳定性要差一些。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1905.10437.pdf" rel="nofollow" title="https://arxiv.org/pdf/1905.10437.pdf">https://arxiv.org/pdf/1905.10437.pdf</a></li><li>实现（GluonTS）</li></ul> 
<pre><code>from gluonts.model.n_beats import NBEATSEstimator
# build model
nbeats_estimator = NBEATSEstimator(
                freq="1D",
                widths=[64, 64],
                num_stacks=2,
                num_blocks=[3],
                num_block_layers=[10],
                stack_types=['T', 'S'],
                prediction_length=args.horizon,
                trainer=Trainer(epochs=30))

# Predicting 
# same as above</code></pre> 
<h3 id="h_421710621_17">2.3.4 Attention类</h3> 
<p><strong>如Transformer、Informer、TFT等</strong></p> 
<h3 id="h_421710621_18">Transformer</h3> 
<ul><li>简介</li></ul> 
<p>        Transformer是Google 在 2017 年提出的一种 用于NLP任务的模型，可以用来做时间序列预测。它可以关注到序列的长期依赖信息，且支持并行化计算，但其本身没有序列的概念，需要增加position embedding是网络学习到序列位置信息。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1706.03762" rel="nofollow" title="Attention Is All You Need">Attention Is All You Need</a></li><li>实现（GluonTS）</li></ul> 
<pre><code>from gluonts.model.transformer import TransformerEstimator
# build model
transformer_estimator = TransformerEstimator(
        freq="1D",
        embedding_dimension=15,
        model_dim=64,
        num_heads=4,
        prediction_length=args.horizon,
        trainer=Trainer(epochs=50)
    )

# Predicting 
# same as above</code></pre> 
<h3 id="h_421710621_19">TFT<a href="https://zhuanlan.zhihu.com/p/421710621#ref_4" rel="nofollow" id="ref_4_0" title="[4]">[4]</a></h3> 
<ul><li>简介</li></ul> 
<p>        来源鱼arxiv上的一篇文章《Temporal Fusion Transformers for Interpretable Multi-horizon Time Series Forecasting》，用于可解释多元时间序列预测的时间融合变换器。</p> 
<ul><li>算法详解：<a href="https://link.zhihu.com/?target=https%3A//github.com/google-research/google-research/tree/master/tft" title="https://github.com/google-research/google-research/tree/master/tft">https://github.com/google-research/google-research/tree/master/tft</a></li><li>实现</li></ul> 
<pre><code>import tqdm
from gluonts.model.tft import TemporalFusionTransformerEstimator
# Building training dataset
train_data_list = []
def _split_times_series(df, data_list, dynamic_real_1, dynamic_cat_1, dynamic_cat_2):
    new_df = df.sort_values(by=date_col, ascending=True)
    time_series_dict = {
            "item_id": new_df[id_col].values[0],
            "start": pd.to_datetime(new_df[date_col].min()),
            "target": new_df[target_col].values,
            "dynamic_real_1": np.array(dynamic_real_1, ndmin=2),
            "dynamic_cat_1": dynamic_cat_1,
            "dynamic_cat_2": dynamic_cat_2,
    }
    data_list.append(time_series_dict)
tqdm.pandas(desc='progress: ')
train_df.groupby(train_df[id_col]).progress_apply(_split_times_series,
       data_list=train_data_list,
       dynamic_real_1=camp_df_real_features_for_train,
       dynamic_cat_1=camp_df_cat1_features_for_train,
       dynamic_cat_2=camp_df_cat2_features_for_train)

training_data = ListDataset(train_data_list, freq="1D")
# build model
estimator = TemporalFusionTransformerEstimator(
        freq="1D",
        prediction_length=args.horizon,
        batch_size=batch_size,
        context_length=context_length,
        dropout_rate=dropout_rate,
        trainer=Trainer(batch_size=batch_size, epochs=epochs),
        # 数值型协变量dimension引入
        dynamic_feature_dims={"dynamic_real_1": 1},
        # 非数值型协变量引入
        dynamic_cardinalities={"dynamic_cat_1": cat1_cardinality, "dynamic_cat_2": cat2_cardinality},
        num_heads=num_heads,
        hidden_dim=hidden_dim)

# Predicting 
# same as above</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83b704201fc68a513c31027a80629556/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Wireshark启动后找不到网卡】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c17f2d403db4bb61c9372e4fa2a8fa2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javac编译程序，出现‘javac’不是内部或外部命令，也不是可运行的程序或批处理文件。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>