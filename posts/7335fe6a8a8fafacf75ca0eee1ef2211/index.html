<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Primer (暂时完结) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; Primer (暂时完结)" />
<meta property="og:description" content="C&#43;&#43; Primer C&#43;&#43; 预备知识泛型编程第二章 开始学习C&#43;&#43;2.1.3 C&#43;&#43;预处理器 和iostream 文件名称空间第二章 输出输入endl控制符换行符规范的书写格式c&#43;&#43;源码风格 程序清单2.2 输入类的简介2.4 函数有返回值的函数 函数变体自定义函数带返回值的参数 编程练习第三章 处理数据简单变量变量名 sizeof运算符头文件limits初始化无符号类型 整型字面值C&#43;&#43; 如何确定常量的类型char类型，字符和小整数转义字符 bool类型const 限定符 3.3浮点数setf()浮点数的优缺点float double 精度浮点数如何存储呢? C&#43;&#43; 算术运算符复合类型4.1 数组数组初始化规则变量类型缩窄 字符串在数组中操作字符串getline（）get() string 类简介赋值，拼接，附加 string类I/O结构体的位字段 4.5 共用体4.6 枚举设置枚举量的值 4.7 指针和自由存储空间如何声明指针4.7.2 指针的危险4.7.4 使用new来分配内存使用delete释放内存使用new创建动态数组 指针，数组，指针算术数组的动态联编和静态联编指针和字符串接收动态字符串开辟空间函数 类型组合数组的替代品模板类vector 模板类array 循环第八章 函数探幽C&#43;&#43; 内联函数 8.2 引用变量创建引用变量将引用用作函数参数8.5函数模板8.5.1重载的模板8.5.2 模板的局限性8.5.3 显式具体化8.5.4 实例化和具体化自己选择 合适的函数调用 单独编译存储秩序性，作用域和链接性使用C&#43;&#43; 11 中的auto作用域解析运算符 静态持续性，内部链接性无链接性的局部变量 说明符和限定符CV限定符const 函数和链接性语言的链接性存储方案和动态分配定位new运算符 9.3 名称空间9.3.2 新的名称空间特性using 声明和using 编译指令 未命名的名称空间 第十章 类和对象访问控制控制对成员的访问，公有还是私有 10.2.3 实现类成员函数内联方法 10.2.4 使用类类的构造和析构函数使用构造函数 10.3.4 析构函数10.4 this指针10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7335fe6a8a8fafacf75ca0eee1ef2211/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-02T21:13:11+08:00" />
<meta property="article:modified_time" content="2021-08-02T21:13:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Primer (暂时完结)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C++ Primer</h4> 
 <ul><li><a href="#C__1" rel="nofollow">C++ 预备知识</a></li><li><ul><li><a href="#_19" rel="nofollow">泛型编程</a></li><li><a href="#_C_33" rel="nofollow">第二章 开始学习C++</a></li><li><a href="#213_C_iostream__56" rel="nofollow">2.1.3 C++预处理器 和iostream 文件</a></li><li><a href="#_81" rel="nofollow">名称空间</a></li><li><a href="#__109" rel="nofollow">第二章 输出输入</a></li><li><ul><li><a href="#endl_137" rel="nofollow">endl控制符</a></li><li><a href="#_149" rel="nofollow">换行符</a></li><li><a href="#_157" rel="nofollow">规范的书写格式</a></li><li><ul><li><a href="#c_159" rel="nofollow">c++源码风格</a></li></ul> 
    </li><li><a href="#22_163" rel="nofollow">程序清单2.2</a></li></ul> 
   </li><li><a href="#_223" rel="nofollow">输入</a></li><li><a href="#_252" rel="nofollow">类的简介</a></li><li><a href="#24__272" rel="nofollow">2.4 函数</a></li><li><ul><li><a href="#_274" rel="nofollow">有返回值的函数</a></li></ul> 
   </li><li><a href="#_338" rel="nofollow">函数变体</a></li><li><a href="#_358" rel="nofollow">自定义函数</a></li><li><ul><li><a href="#_385" rel="nofollow">带返回值的参数</a></li></ul> 
   </li><li><a href="#_421" rel="nofollow">编程练习</a></li><li><a href="#__455" rel="nofollow">第三章 处理数据</a></li><li><ul><li><a href="#_463" rel="nofollow">简单变量</a></li><li><a href="#_476" rel="nofollow">变量名</a></li></ul> 
   </li><li><a href="#sizeof_514" rel="nofollow">sizeof运算符</a></li><li><ul><li><a href="#limits_522" rel="nofollow">头文件limits</a></li><li><a href="#_534" rel="nofollow">初始化</a></li><li><a href="#_550" rel="nofollow">无符号类型</a></li></ul> 
   </li><li><a href="#_565" rel="nofollow">整型字面值</a></li><li><a href="#C__585" rel="nofollow">C++ 如何确定常量的类型</a></li><li><ul><li><a href="#char_593" rel="nofollow">char类型，字符和小整数</a></li><li><a href="#_627" rel="nofollow">转义字符</a></li></ul> 
   </li><li><a href="#bool_635" rel="nofollow">bool类型</a></li><li><ul><li><a href="#const__641" rel="nofollow">const 限定符</a></li></ul> 
   </li><li><a href="#33_666" rel="nofollow">3.3浮点数</a></li><li><ul><li><a href="#setf_678" rel="nofollow">setf()</a></li><li><a href="#_774" rel="nofollow">浮点数的优缺点</a></li><li><a href="#float_double__786" rel="nofollow">float double 精度</a></li><li><ul><li><a href="#_788" rel="nofollow">浮点数如何存储呢?</a></li></ul> 
   </li></ul> 
   </li><li><a href="#C__835" rel="nofollow">C++ 算术运算符</a></li><li><a href="#_909" rel="nofollow">复合类型</a></li><li><a href="#41__911" rel="nofollow">4.1 数组</a></li><li><ul><li><a href="#_958" rel="nofollow">数组初始化规则</a></li><li><a href="#_970" rel="nofollow">变量类型缩窄</a></li></ul> 
   </li><li><a href="#_1028" rel="nofollow">字符串</a></li><li><ul><li><a href="#_1056" rel="nofollow">在数组中操作字符串</a></li><li><a href="#getline_1092" rel="nofollow">getline（）</a></li><li><a href="#get_1127" rel="nofollow">get()</a></li></ul> 
   </li><li><a href="#string__1161" rel="nofollow">string 类简介</a></li><li><ul><li><ul><li><a href="#_1169" rel="nofollow">赋值，拼接，附加</a></li></ul> 
    </li><li><a href="#stringIO_1217" rel="nofollow">string类I/O</a></li><li><a href="#_1283" rel="nofollow">结构体的位字段</a></li></ul> 
   </li><li><a href="#45__1295" rel="nofollow">4.5 共用体</a></li><li><a href="#46__1347" rel="nofollow">4.6 枚举</a></li><li><ul><li><a href="#_1385" rel="nofollow">设置枚举量的值</a></li></ul> 
   </li><li><a href="#47__1399" rel="nofollow">4.7 指针和自由存储空间</a></li><li><ul><li><a href="#_1415" rel="nofollow">如何声明指针</a></li><li><a href="#472__1440" rel="nofollow">4.7.2 指针的危险</a></li><li><a href="#474_new_1448" rel="nofollow">4.7.4 使用new来分配内存</a></li><li><a href="#delete_1489" rel="nofollow">使用delete释放内存</a></li><li><ul><li><a href="#new_1515" rel="nofollow">使用new创建动态数组</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1541" rel="nofollow">指针，数组，指针算术</a></li><li><ul><li><a href="#_1547" rel="nofollow">数组的动态联编和静态联编</a></li><li><a href="#_1557" rel="nofollow">指针和字符串</a></li><li><ul><li><a href="#_1591" rel="nofollow">接收动态字符串开辟空间函数</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1601" rel="nofollow">类型组合</a></li><li><a href="#_1603" rel="nofollow">数组的替代品</a></li><li><ul><li><ul><li><a href="#vector_1607" rel="nofollow">模板类vector</a></li></ul> 
    </li><li><a href="#array_1619" rel="nofollow">模板类array</a></li></ul> 
   </li><li><a href="#_1664" rel="nofollow">循环</a></li><li><a href="#__1680" rel="nofollow">第八章 函数探幽</a></li><li><ul><li><a href="#C__1684" rel="nofollow">C++ 内联函数</a></li></ul> 
   </li><li><a href="#82__1728" rel="nofollow">8.2 引用变量</a></li><li><ul><li><a href="#_1734" rel="nofollow">创建引用变量</a></li><li><a href="#_1744" rel="nofollow">将引用用作函数参数</a></li><li><a href="#85_1756" rel="nofollow">8.5函数模板</a></li><li><a href="#851_1824" rel="nofollow">8.5.1重载的模板</a></li><li><a href="#852__1931" rel="nofollow">8.5.2 模板的局限性</a></li><li><a href="#853___1947" rel="nofollow">8.5.3 显式具体化</a></li><li><a href="#854__2048" rel="nofollow">8.5.4 实例化和具体化</a></li><li><ul><li><a href="#__2052" rel="nofollow">自己选择 合适的函数调用</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_2128" rel="nofollow">单独编译</a></li><li><a href="#_2253" rel="nofollow">存储秩序性，作用域和链接性</a></li><li><a href="#C_11_auto_2261" rel="nofollow">使用C++ 11 中的auto</a></li><li><ul><li><a href="#_2273" rel="nofollow">作用域解析运算符</a></li></ul> 
   </li><li><a href="#_2344" rel="nofollow">静态持续性，内部链接性</a></li><li><ul><li><a href="#_2368" rel="nofollow">无链接性的局部变量</a></li></ul> 
   </li><li><a href="#_2386" rel="nofollow">说明符和限定符</a></li><li><ul><li><a href="#CV_2396" rel="nofollow">CV限定符</a></li><li><ul><li><a href="#const_2402" rel="nofollow">const</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_2406" rel="nofollow">函数和链接性</a></li><li><a href="#_2416" rel="nofollow">语言的链接性</a></li><li><a href="#_2428" rel="nofollow">存储方案和动态分配</a></li><li><ul><li><a href="#new_2448" rel="nofollow">定位new运算符</a></li></ul> 
   </li><li><a href="#93__2502" rel="nofollow">9.3 名称空间</a></li><li><ul><li><a href="#932__2508" rel="nofollow">9.3.2 新的名称空间特性</a></li><li><ul><li><a href="#using_using__2528" rel="nofollow">using 声明和using 编译指令</a></li></ul> 
    </li><li><a href="#_2564" rel="nofollow">未命名的名称空间</a></li></ul> 
   </li><li><a href="#__2570" rel="nofollow">第十章 类和对象</a></li><li><ul><li><a href="#_2576" rel="nofollow">访问控制</a></li><li><a href="#_2582" rel="nofollow">控制对成员的访问，公有还是私有</a></li></ul> 
   </li><li><a href="#1023__2619" rel="nofollow">10.2.3 实现类成员函数</a></li><li><ul><li><a href="#_2635" rel="nofollow">内联方法</a></li></ul> 
   </li><li><a href="#1024__2714" rel="nofollow">10.2.4 使用类</a></li><li><a href="#_2746" rel="nofollow">类的构造和析构函数</a></li><li><ul><li><a href="#_2783" rel="nofollow">使用构造函数</a></li></ul> 
   </li><li><a href="#1034__2949" rel="nofollow">10.3.4 析构函数</a></li><li><a href="#104_this_2975" rel="nofollow">10.4 this指针</a></li><li><a href="#105__3001" rel="nofollow">10.5 对象数组</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="C__1"></a>C++ 预备知识</h2> 
<p>面向对象的编程（OOP）</p> 
<p><img src="https://images2.imgbox.com/17/b1/J87fdGTR_o.png" alt="image-20210802174233194"></p> 
<p>什么是类，什么是对象</p> 
<p>类包含 数据和操作</p> 
<p><img src="https://images2.imgbox.com/da/6e/QkTimyhK_o.png" alt="image-20210802174655217"></p> 
<h3><a id="_19"></a>泛型编程</h3> 
<p>独立于特定的数据类型，</p> 
<p>和数据类型无关，不管你是什么数据类型，只实现这个功能</p> 
<p><img src="https://images2.imgbox.com/d7/e7/MhIgrz6x_o.png" alt="image-20210802175703932"></p> 
<p><img src="https://images2.imgbox.com/c0/84/0Shp6f35_o.png" alt="image-20210802180020700"></p> 
<p><img src="https://images2.imgbox.com/36/b6/fu0Yfq2I_o.png" alt="image-20210802180227120"></p> 
<h3><a id="_C_33"></a>第二章 开始学习C++</h3> 
<p>main 函数框架</p> 
<p><img src="https://images2.imgbox.com/ef/da/E8ZiQpv0_o.png" alt="image-20210802181521123"></p> 
<p>g++是编译c++工具的</p> 
<p><img src="https://images2.imgbox.com/1c/52/onJmzRM9_o.png" alt="image-20210802182645810"></p> 
<p>任何一个程序的开始都是从main开始</p> 
<p><img src="https://images2.imgbox.com/74/b3/aucksa9w_o.png" alt="image-20210802182751129"></p> 
<p>单片机可以不用main，动态链接库也可以不用main</p> 
<p>注释</p> 
<pre><code>//两个斜线，单行注释
/**/ 多行注释
</code></pre> 
<h3><a id="213_C_iostream__56"></a>2.1.3 C++预处理器 和iostream 文件</h3> 
<pre><code>#include &lt;iostream&gt;
using namespace std:
想要输入输出，就要有这两个

</code></pre> 
<p>我包含了iostream文件，iostream里面所有的文件都会被包含在里面~</p> 
<p><img src="https://images2.imgbox.com/6c/35/pWsqfZN6_o.png" alt="image-20210802184626446"></p> 
<p>input output 流</p> 
<p><img src="https://images2.imgbox.com/6e/ea/gyCNxO9y_o.png" alt="image-20210802184729038"></p> 
<p><img src="https://images2.imgbox.com/56/0b/SIj8KpBd_o.png" alt="image-20210802184751350"></p> 
<p><img src="https://images2.imgbox.com/eb/0e/16CYpg44_o.png" alt="image-20210802184827973"></p> 
<p><img src="https://images2.imgbox.com/d9/aa/I6F4GVTt_o.png" alt="image-20210802184838787"></p> 
<p>想调用c库的话，前面加c 把点h去掉</p> 
<h3><a id="_81"></a>名称空间</h3> 
<p>using 编译指令</p> 
<p><img src="https://images2.imgbox.com/e7/92/ADVeR4Qd_o.png" alt="image-20210802185020652"></p> 
<p>如果我们想要有两个封装好的函数</p> 
<p>两个，都有wanda（） 函数</p> 
<p>我们到底用哪个？</p> 
<p><img src="https://images2.imgbox.com/be/68/1TTVXbHd_o.png" alt="image-20210802185233573"></p> 
<p>我们使用这个就可以找到具体的一个</p> 
<p><img src="https://images2.imgbox.com/a8/ce/emRSOakl_o.png" alt="image-20210802185430883"></p> 
<p>如果不加using namespace的话，那就需要std:: 这样</p> 
<p>然后加了的话，就会默认来自于std这个名称空间</p> 
<p><img src="https://images2.imgbox.com/22/e7/gRgsHzqm_o.png" alt="image-20210802185653850"></p> 
<p>这样的话，我们只会使用一点点，</p> 
<p>声明之后，只开放了std的方法 count endl cin，这仨而且之后都可以随便使用</p> 
<h3><a id="__109"></a>第二章 输出输入</h3> 
<p><img src="https://images2.imgbox.com/76/32/Kpo75Cd5_o.png" alt="image-20210802205325465"></p> 
<p><img src="https://images2.imgbox.com/58/71/TQTNINBg_o.png" alt="image-20210802205454191"></p> 
<p><img src="https://images2.imgbox.com/65/7d/3dvWXpRK_o.png" alt="image-20210802205501767"></p> 
<p>输出流，将字符串流到输出</p> 
<p><img src="https://images2.imgbox.com/eb/d4/TwN2bugH_o.png" alt="image-20210802205525546"></p> 
<p>右侧信息插入到输出流中</p> 
<p><img src="https://images2.imgbox.com/01/a7/uOj29xrp_o.png" alt="image-20210802205641117"></p> 
<p><img src="https://images2.imgbox.com/a6/a9/cGbgG8HG_o.png" alt="image-20210802205655669"></p> 
<p>运算符重载，</p> 
<p>这两个运算符相同</p> 
<p><img src="https://images2.imgbox.com/c4/8b/97kybfFA_o.png" alt="image-20210802205739295"></p> 
<p>多个符号，编译器会进行识别</p> 
<h4><a id="endl_137"></a>endl控制符</h4> 
<p>end line</p> 
<p>结束这一行</p> 
<p>作用是为了重启一行</p> 
<p><img src="https://images2.imgbox.com/b8/d2/cUIx4XW4_o.png" alt="image-20210802205838913"></p> 
<p><img src="https://images2.imgbox.com/3e/93/y2c73Hyp_o.png" alt="image-20210802205854158"></p> 
<h4><a id="_149"></a>换行符</h4> 
<p><img src="https://images2.imgbox.com/dc/c0/sbUMLfF7_o.png" alt="image-20210802210024780"></p> 
<pre><code>cout &lt;&lt; "" &lt;&lt; endl
</code></pre> 
<h4><a id="_157"></a>规范的书写格式</h4> 
<h5><a id="c_159"></a>c++源码风格</h5> 
<p><img src="https://images2.imgbox.com/1b/18/po1pFloR_o.png" alt="image-20210802210127478"></p> 
<h4><a id="22_163"></a>程序清单2.2</h4> 
<pre><code>#include&lt;iostream&gt;
int main() {
	using namespace std;
	cout &lt;&lt; "hello world\n";
	cout &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>C++ 首次使用前进行定义即可</p> 
<p><img src="https://images2.imgbox.com/ee/e8/fyiCKRxF_o.png" alt="image-20210802210502166"></p> 
<pre><code>#include&lt;iostream&gt;
int main() {
	using namespace std;

	int carrots;

	carrots = 25;
	cout &lt;&lt; carrots &lt;&lt; endl;

	int c = 10;
	cout &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/18/88/jnwarJJn_o.png" alt="image-20210802210541788"></p> 
<p>打印的是字符串25 在内存中是存的11001 数字</p> 
<p>cout 会字符串输出</p> 
<pre><code>#include&lt;iostream&gt;
int main() {
	using namespace std;

	int carrots;

	carrots = 25;
	cout &lt;&lt; carrots &lt;&lt; endl;

	int c = 10;
	cout &lt;&lt; c &lt;&lt; endl;

	cout &lt;&lt; "i have" &lt;&lt; c &lt;&lt; "is" &lt;&lt; carrots &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h3><a id="_223"></a>输入</h3> 
<p>cin 输入流</p> 
<p><img src="https://images2.imgbox.com/a4/45/f29dm8PS_o.png" alt="image-20210803104332973"></p> 
<p><img src="https://images2.imgbox.com/2f/ad/M1NMWMHe_o.png" alt="image-20210803104809396"></p> 
<pre><code>#include&lt;iostream&gt;

int main() {
	using namespace std;
	int carrots;

	cout &lt;&lt; "hello can you guess" &lt;&lt; endl;

	cin &gt;&gt; carrots;

	cout &lt;&lt; "noooooo " &lt;&lt; carrots &lt;&lt; endl;

	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/95/e5/x620dQL2_o.png" alt="image-20210803104959298"></p> 
<p>一行比较长 可以这么写</p> 
<h3><a id="_252"></a>类的简介</h3> 
<p>就相当于是一个数据类型了</p> 
<p><img src="https://images2.imgbox.com/c5/4e/WlqDFtfj_o.png" alt="image-20210803105342673"></p> 
<p>数据和方法对吧，和java一样的</p> 
<p><img src="https://images2.imgbox.com/cc/a9/8jZTGcsb_o.png" alt="image-20210803105522934"></p> 
<p><img src="https://images2.imgbox.com/b3/76/O91TFYPp_o.png" alt="image-20210803105530387"></p> 
<p>使用对象内的方法，也可以使用运算符重载</p> 
<p><img src="https://images2.imgbox.com/a1/1b/s6TBf5Yb_o.png" alt="image-20210803105832998"></p> 
<p>也就是<code>&lt;&lt;</code></p> 
<p>将信息传递给输出流对象</p> 
<h3><a id="24__272"></a>2.4 函数</h3> 
<h4><a id="_274"></a>有返回值的函数</h4> 
<p>例如那个sqrt（） 函数</p> 
<p>x = sqrt(6.25)</p> 
<p>这个是已经写好的函数，</p> 
<p>求平方根</p> 
<p><img src="https://images2.imgbox.com/ab/e1/49IQouec_o.png" alt="image-20210803110610223"></p> 
<p><img src="https://images2.imgbox.com/bb/73/C3OLdrSz_o.png" alt="image-20210803110744836"></p> 
<p>传参的类型，返回的类型，</p> 
<p>必须要知道这两个</p> 
<p>缺少类型就报错了</p> 
<p><img src="https://images2.imgbox.com/5f/d2/pH2HQxgN_o.png" alt="image-20210803110939661"></p> 
<p>说明他返回就是double</p> 
<p>函数声明，带分号</p> 
<p><img src="https://images2.imgbox.com/bb/f9/2h5gpJEe_o.png" alt="image-20210803111030744"></p> 
<p>提供原型，有两种方法</p> 
<p><img src="https://images2.imgbox.com/2a/a0/1O8METB7_o.png" alt="image-20210803111136206"></p> 
<p>第二种方法更好，</p> 
<p>函数原型在main前面</p> 
<p><img src="https://images2.imgbox.com/83/f3/T82Oy1NS_o.png" alt="image-20210803111319410"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;

int main() {
	using namespace std;
	int carrots;

	cout &lt;&lt; "hello can you guess" &lt;&lt; endl;

	cin &gt;&gt; carrots;
	
	cout &lt;&lt; "noooooo " &lt;&lt; carrots &lt;&lt; endl;

	double area;
	cout &lt;&lt; "Enter the floor area, in square feet,of your home:";
	cin &gt;&gt; area;
	cout &lt;&lt; sqrt(area);
	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/12/Lf88siJm_o.png" alt="image-20210803112042924"></p> 
<h3><a id="_338"></a>函数变体</h3> 
<p><img src="https://images2.imgbox.com/fa/01/XX5yLlvI_o.png" alt="image-20210803112252577"></p> 
<p>函数带多个参数</p> 
<p>pow（） 求几次方</p> 
<p>rand （） 不带参数的函数</p> 
<p>bucks （） 函数可以i没有返回值</p> 
<p><img src="https://images2.imgbox.com/69/85/9VNUkZn2_o.png" alt="image-20210803112334660"></p> 
<p>没返回值不带参数</p> 
<p>标准库中的函数~</p> 
<h3><a id="_358"></a>自定义函数</h3> 
<p><img src="https://images2.imgbox.com/3b/d4/dtpFto3w_o.png" alt="image-20210803112810584"></p> 
<p><img src="https://images2.imgbox.com/10/61/Xl7JzDNk_o.png" alt="image-20210803113241359"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;

void simon(int n);

int main() {
	using namespace std;

	simon(3);
	return 0;
}

void simon(int n) {
	using namespace std;

	cout &lt;&lt; "Simon says touch your toes " &lt;&lt; n &lt;&lt; " times." &lt;&lt; endl;

}
</code></pre> 
<h4><a id="_385"></a>带返回值的参数</h4> 
<p><img src="https://images2.imgbox.com/a3/de/94gZmJ4F_o.png" alt="image-20210803114215897"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;

void simon(int n);
int stonetolb(int sts);
int main() {
	using namespace std;

	cout &lt;&lt; "Enter the weight in stone:";
	int stone;
	int pounds;
	cin &gt;&gt; stone;
	pounds = stonetolb(stone);
	cout &lt;&lt; pounds &lt;&lt; endl;
	return 0;
}

void simon(int n) {
	using namespace std;

	cout &lt;&lt; "Simon says touch your toes " &lt;&lt; n &lt;&lt; " times." &lt;&lt; endl;

}
//1 stone = 14 lbs
int stonetolb(int sts) {
	int pounds = 14 * sts;
	
	return pounds;
}
</code></pre> 
<h3><a id="_421"></a>编程练习</h3> 
<p><img src="https://images2.imgbox.com/de/76/j7Eg5KHl_o.png" alt="image-20210803115910867"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
using namespace std;

int hiahia(long x);
int main() {
	cout &lt;&lt; "Wum1ng " &lt;&lt; "Peking" &lt;&lt; endl;
	long x;
	int c;
	cin &gt;&gt; x;
	c = hiahia(x);
	cout &lt;&lt; c;

	return 0;
}

int hiahia(long x) {
	return x * 220;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/49/GJX2mqdG_o.png" alt="image-20210803120036367"></p> 
<p><img src="https://images2.imgbox.com/02/74/ROLD3uhr_o.png" alt="image-20210803120055934"></p> 
<p><img src="https://images2.imgbox.com/52/50/6WvGvphA_o.png" alt="image-20210803120224564"></p> 
<p><img src="https://images2.imgbox.com/af/e3/JMYuMTLX_o.png" alt="image-20210803120318554"></p> 
<h3><a id="__455"></a>第三章 处理数据</h3> 
<p>C++原生带着，内置的数据类型</p> 
<p>基本数据类型，|复合数据类型</p> 
<p>整形 浮点型 | 字符串，数组，结构体</p> 
<h4><a id="_463"></a>简单变量</h4> 
<p><img src="https://images2.imgbox.com/32/e6/pvBzEZHA_o.png" alt="image-20210803124644605"></p> 
<pre><code>int braincount;
braincount = 5;
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/2d/XUKpR4Qm_o.png" alt="image-20210803124823931"></p> 
<p>braincount 标记名称</p> 
<h4><a id="_476"></a>变量名</h4> 
<p>字母数字下划线</p> 
<p>不能数字开头</p> 
<p>没有关键字</p> 
<p>两个下划线，一个下划线，编译器保留使用，</p> 
<p><img src="https://images2.imgbox.com/35/85/FSrvDvll_o.png" alt="image-20210803124906589"></p> 
<p>区分大小写的</p> 
<p>他存放的只是一个整数的子集</p> 
<p>基本整形</p> 
<ul><li> <p>char</p> </li><li> <p>short</p> </li><li> <p>int</p> </li><li> <p>long</p> </li><li> <p>long long</p> <p><img src="https://images2.imgbox.com/72/ab/GZ2ej35y_o.png" alt="image-20210803125623753"></p> </li></ul> 
<p><img src="https://images2.imgbox.com/71/be/rNhy60RX_o.png" alt="image-20210803130104546"></p> 
<p>直接声明就可以</p> 
<h3><a id="sizeof_514"></a>sizeof运算符</h3> 
<p>求在内存空间中的占用</p> 
<p><img src="https://images2.imgbox.com/62/d7/6s9q5saV_o.png" alt="image-20210803133300263"></p> 
<p>定义常量 我们 一般全用大写~</p> 
<h4><a id="limits_522"></a>头文件limits</h4> 
<p>包含一些宏定义</p> 
<p><img src="https://images2.imgbox.com/55/77/iRGplzMI_o.png" alt="image-20210803133416501"></p> 
<p><img src="https://images2.imgbox.com/6f/7e/F9Hdgx5R_o.png" alt="image-20210803134059575"></p> 
<p><img src="https://images2.imgbox.com/3f/2d/08ovHLH6_o.png" alt="image-20210803134339365"></p> 
<p><img src="https://images2.imgbox.com/21/f0/soOQqzJS_o.png" alt="image-20210803135047641"></p> 
<h4><a id="_534"></a>初始化</h4> 
<p>声明和赋值合并在一起</p> 
<p><img src="https://images2.imgbox.com/6c/38/pC8aOEXa_o.png" alt="image-20210803135343436"></p> 
<p>也可以用圆括号进行赋值</p> 
<p><img src="https://images2.imgbox.com/93/b3/cnqqV8f3_o.png" alt="image-20210803135516688"></p> 
<p>也可以使用{} 花括号初始化器</p> 
<p>可以应用于任何的数据类型</p> 
<p><img src="https://images2.imgbox.com/c0/4c/kvPpVUPC_o.png" alt="image-20210803135909882"></p> 
<h4><a id="_550"></a>无符号类型</h4> 
<p><img src="https://images2.imgbox.com/e6/e9/qmeFUzIU_o.png" alt="image-20210803140139487"></p> 
<p>最大值会扩大</p> 
<p><img src="https://images2.imgbox.com/bd/3d/6rhNR5y4_o.png" alt="image-20210803140707377"></p> 
<p><img src="https://images2.imgbox.com/e1/21/tEOhrkkr_o.png" alt="image-20210803140731260"></p> 
<p>让他们均+1 然后会发生越界</p> 
<p><img src="https://images2.imgbox.com/b4/51/OOt2v9pb_o.png" alt="image-20210803140959569"></p> 
<h3><a id="_565"></a>整型字面值</h3> 
<p><img src="https://images2.imgbox.com/c1/c9/oC4tLOBQ_o.png" alt="image-20210803154120095"></p> 
<p>十进制，十六进制，八进制</p> 
<p><img src="https://images2.imgbox.com/3f/ee/LC3VRUTP_o.png" alt="image-20210803154222168"></p> 
<p>cout 默认是输出的十进制输出</p> 
<p><img src="https://images2.imgbox.com/e7/7e/HhEXDwn5_o.png" alt="image-20210803154404078"></p> 
<p><img src="https://images2.imgbox.com/95/5e/1q9bIF78_o.png" alt="image-20210803154915906"></p> 
<p>切换cout</p> 
<p><img src="https://images2.imgbox.com/8f/09/mP17SNCH_o.png" alt="image-20210803155013379"></p> 
<p>然后是各个进制的</p> 
<h3><a id="C__585"></a>C++ 如何确定常量的类型</h3> 
<p>可以添加后缀</p> 
<p><img src="https://images2.imgbox.com/31/bc/9mWfv8pc_o.png" alt="image-20210803155955717"></p> 
<p>L ul ull</p> 
<h4><a id="char_593"></a>char类型，字符和小整数</h4> 
<p>char其实就是整形，他会存储成整型，只不过会对应一个表而已</p> 
<p>一个字节就够了 2^8</p> 
<p>ASCII</p> 
<p><img src="https://images2.imgbox.com/42/a2/p3iqZwm7_o.png" alt="image-20210803161355213"></p> 
<p>输入一个字符</p> 
<p><img src="https://images2.imgbox.com/fa/bd/GZZ0NPSz_o.png" alt="image-20210803161624243"></p> 
<p>cin 和cout</p> 
<p><img src="https://images2.imgbox.com/e9/c3/lV77wEt3_o.png" alt="image-20210803162720596"></p> 
<p>可以看出来，是77 同时 是M</p> 
<p><img src="https://images2.imgbox.com/d5/36/LTkXxWeU_o.png" alt="image-20210803162743339"></p> 
<p>如果我们+1 就会变成 78 也就是N</p> 
<p>类里有变量，函数，我们需要访问对象对吧，</p> 
<p>cin，cout 可以访问类内的函数</p> 
<p><img src="https://images2.imgbox.com/c2/b7/F2EjxupW_o.png" alt="image-20210803163132622"></p> 
<p>我们调用 cout 的put函数试试</p> 
<h4><a id="_627"></a>转义字符</h4> 
<p><img src="https://images2.imgbox.com/60/0d/Ck1SStyY_o.png" alt="image-20210803163752326"></p> 
<p><img src="https://images2.imgbox.com/30/a9/ja3dIEuy_o.png" alt="image-20210803163803763"></p> 
<p>转义序列使用十六进制</p> 
<h3><a id="bool_635"></a>bool类型</h3> 
<p><img src="https://images2.imgbox.com/f3/94/3uRA5AEv_o.png" alt="image-20210803164951270"></p> 
<p>bool 类型转换成了int 也就是01转换</p> 
<h4><a id="const__641"></a>const 限定符</h4> 
<p>定义为了常量</p> 
<p>不允许被修改</p> 
<p>字母都大写的话，一般就是去使用#define</p> 
<p><img src="https://images2.imgbox.com/3d/56/PQksGaAW_o.png" alt="image-20210803165804425"></p> 
<p><img src="https://images2.imgbox.com/81/38/VJOD05V4_o.png" alt="image-20210803165849929"></p> 
<pre><code>一般使用
const int xx = 111;
</code></pre> 
<p>这样好</p> 
<p>只希望某个常量在某个中实现，我们用const</p> 
<p><img src="https://images2.imgbox.com/14/7e/He4y0ID4_o.png" alt="image-20210803170147462"></p> 
<p>使用const 不用define</p> 
<h3><a id="33_666"></a>3.3浮点数</h3> 
<p><img src="https://images2.imgbox.com/46/b2/54KsVKKe_o.png" alt="image-20210803170435812"></p> 
<p>E表示法</p> 
<p><img src="https://images2.imgbox.com/c0/86/ai7RGrb4_o.png" alt="image-20210803170508942"></p> 
<p><img src="https://images2.imgbox.com/91/a1/xbPGK91h_o.png" alt="image-20210803170518145"></p> 
<h4><a id="setf_678"></a>setf()</h4> 
<p>迫使输出定点表示，防止转换为E表示法</p> 
<p><img src="https://images2.imgbox.com/50/84/7q9uFMQl_o.png" alt="image-20210803171425855"></p> 
<p>迫使显示后六位</p> 
<p>cout默认打印后六位</p> 
<p><img src="https://images2.imgbox.com/7f/1f/SZpWvrvy_o.png" alt="image-20210803171638163"></p> 
<p><img src="https://images2.imgbox.com/68/03/kM40UaDW_o.png" alt="image-20210803171651532"></p> 
<p>cout会删除结尾的0</p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
using namespace std;

int main() {

	cout.setf(ios_base::fixed, ios_base::floatfield);
	float tub = 10.0 / 3.0;

	const float million = 1.0E6;
	cout &lt;&lt; "tub = " &lt;&lt; tub &lt;&lt; endl;
	return 0;
}






这里是带乘法的

#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
using namespace std;

int main() {

	cout.setf(ios_base::fixed, ios_base::floatfield);
	float tub = 10.0 / 3.0;

	const float million = 1.0E6;
	cout &lt;&lt; "tub = " &lt;&lt; tub &lt;&lt; endl;

	cout &lt;&lt; "A million tubs " &lt;&lt; million * tub &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/33/69/qwaaCpYa_o.png" alt="image-20210803172400478"></p> 
<p>这里已经出现问题拉</p> 
<p>后面都是0了</p> 
<p>因为float精度达不到</p> 
<p><img src="https://images2.imgbox.com/f3/7c/ZpwzK0yT_o.png" alt="image-20210803172600413"></p> 
<p><img src="https://images2.imgbox.com/df/f4/7DNv9zOj_o.png" alt="image-20210803172604535"></p> 
<p>我们使用double 保证了精度</p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
using namespace std;

int main() {

	cout.setf(ios_base::fixed, ios_base::floatfield);
	float tub = 10.0 / 3.0;

	const float million = 1.0E6;
	cout &lt;&lt; "tub = " &lt;&lt; tub &lt;&lt; endl;

	cout &lt;&lt; "A million tubs " &lt;&lt; million * tub &lt;&lt; endl;


	double mint = 10.0 / 3.0;
	cout &lt;&lt; mint * million;
	return 0;
}

</code></pre> 
<h4><a id="_774"></a>浮点数的优缺点</h4> 
<p>运算的时候，浮点数运算会降低</p> 
<p><img src="https://images2.imgbox.com/97/10/B8vJfe2j_o.png" alt="image-20210803173227786"></p> 
<p>a和b差1.0 但是 相减为0，精度降低了</p> 
<p><img src="https://images2.imgbox.com/f8/fd/mqNPXJ1C_o.png" alt="image-20210803173248798"></p> 
<h4><a id="float_double__786"></a>float double 精度</h4> 
<h5><a id="_788"></a>浮点数如何存储呢?</h5> 
<p>单精度 32bit</p> 
<p>double 双精度 64 bit</p> 
<p><img src="https://images2.imgbox.com/20/e7/aS9t0GTo_o.png" alt="image-20210804105456645"></p> 
<p>都要遵循 IEEE 标准，任意一个浮点数都是以科学计数法来表示</p> 
<p>二进制的科学计数法</p> 
<pre><code>例如 8.25

整数+小数
1000. 01
0.25 * 2  =0.5 取处整数0
0.5 * 2  = 1 取出整数 1

1000.01转换为科学计数法，
1.00001*2^3
整数部分一定是1

计算机存储科学计数法，有符号的
符号正负（1 bit）
正数 0 负数 1
2^3    2^-3

</code></pre> 
<p><img src="https://images2.imgbox.com/4c/25/ZqSLh4O6_o.png" alt="image-20210804110811723"></p> 
<p>因为要表示正负次幂，所以</p> 
<pre><code>2^(127+3)
计算机中存储浮点数，
一共32位，小数部分23位
精度是6位-7位，说的是十进制，2^23次约等于 10^6.923
符号(1位)+指数位（8位）+小数部分（0001000000000000000）
double类型，小数部分52个

</code></pre> 
<h3><a id="C__835"></a>C++ 算术运算符</h3> 
<p>求加减乘除</p> 
<p><img src="https://images2.imgbox.com/40/e6/tzNBkVtQ_o.png" alt="image-20210804113639420"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
using namespace std;

int main() {
	float hats, head;
	cout.setf(ios_base::fixed, ios_base::floatfield);
	cout &lt;&lt; "Enter a number:";
	cin &gt;&gt; hats;
	cout &lt;&lt; "enter another number : ";
	cin &gt;&gt; head;
	cout &lt;&lt; "heat= " &lt;&lt; head &lt;&lt;"\n"&lt;&lt; "hats" &lt;&lt; hats &lt;&lt; endl;
;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/bf/62/hdVsG3lz_o.png" alt="image-20210804113819491"></p> 
<p>很明显，加出来不对</p> 
<p><img src="https://images2.imgbox.com/d9/a3/2UAEJ6vF_o.png" alt="image-20210804113932136"></p> 
<p>位数会一直往下增加</p> 
<p>浮点数他要变二进制，小数一直×2</p> 
<p><img src="https://images2.imgbox.com/ec/c0/FTGYbrDX_o.png" alt="image-20210804114534690"></p> 
<p>这行注释掉，就对了</p> 
<p>四舍五入之后，才会对，之前是强制显示后六位</p> 
<p><img src="https://images2.imgbox.com/e5/b5/FylExL6v_o.png" alt="image-20210804115119192"></p> 
<p>加减乘除都会有这个问题</p> 
<p>float类型，真不行</p> 
<p>我们要使用double类型</p> 
<p><img src="https://images2.imgbox.com/96/60/Dluy2KQy_o.png" alt="image-20210804115338483"></p> 
<p>整数除法</p> 
<p><img src="https://images2.imgbox.com/f6/e8/r8C0NPS9_o.png" alt="image-20210804115437796"></p> 
<p>向上转数据类型</p> 
<p>位数加长，默认转为了double类型的除法</p> 
<p><img src="https://images2.imgbox.com/7c/22/dEGi4rry_o.png" alt="image-20210804115542438"></p> 
<p>强制转float的话，加一个F</p> 
<p><img src="https://images2.imgbox.com/bc/b9/XQcDWip8_o.png" alt="image-20210804115607935"></p> 
<p><img src="https://images2.imgbox.com/bd/91/GSJb6Lba_o.png" alt="image-20210804115714773"></p> 
<p><img src="https://images2.imgbox.com/ed/0d/XgEEHgKe_o.png" alt="image-20210804115742052"></p> 
<h3><a id="_909"></a>复合类型</h3> 
<h3><a id="41__911"></a>4.1 数组</h3> 
<p>数组存相同的数据类型</p> 
<p><img src="https://images2.imgbox.com/30/d7/T0IhExae_o.png" alt="image-20210804140529647"></p> 
<p>数组中的内容在内存中是连续排列的</p> 
<p><img src="https://images2.imgbox.com/4a/1f/fk0XFrS8_o.png" alt="image-20210804140653887"></p> 
<p>这三个点必须要有</p> 
<pre><code>short months[12]

声明通用通用格式
typeName arrayName[arraysize]


</code></pre> 
<p>里面必须存放的是常量</p> 
<p><img src="https://images2.imgbox.com/b9/03/yXyEVEsP_o.png" alt="image-20210804140849038"></p> 
<p>数组中的编号从0开始~</p> 
<p>程序员要确认好数组下标不越界</p> 
<p><img src="https://images2.imgbox.com/cd/3c/O75zXSLn_o.png" alt="image-20210804141757702"></p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
using namespace std;

int main() {
	int yams[3] = {7,8,6};
	int yamscosts[3] = { 20,30,5 };
	cout &lt;&lt; "The total yams = " &lt;&lt; yams[0] + yams[1] + yams[2] &lt;&lt; endl;
	cout &lt;&lt; "The package with" &lt;&lt; yams[1] &lt;&lt; "yams cost " &lt;&lt; yamscosts[1] &lt;&lt; endl;
	return 0;
}

</code></pre> 
<h4><a id="_958"></a>数组初始化规则</h4> 
<p><img src="https://images2.imgbox.com/8a/1f/qBKWHhok_o.png" alt="image-20210804142206329"></p> 
<p>定义的时候才能给值</p> 
<p>一小部分初始化，其他都为0</p> 
<p>也可以为空，编译器会自动计算个数</p> 
<p>short things[] = {1,5,3,8}</p> 
<h4><a id="_970"></a>变量类型缩窄</h4> 
<p>其实说白了就是一个变量赋值给另一个变量的时候发生溢出的情况，万一发生了缩窄转换，程序一般是不会报错的，这将非常不利于bug调试，因此要尽可能避免它。话不多说，看看例子吧。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 5000000; //-2147483648~2147483647
	short int b = a;
	cout &lt;&lt; b &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/9b/94/Ox0djXAD_o.png" alt="image-20210804142721368"></p> 
<p>可以很明显地看到结果不是我们想要的，甚至不符合溢出。那么怎么避免变量类型缩窄转换呢？<code>C++11</code>提供了初始化列表就可以避免这一问题。</p> 
<p><img src="https://images2.imgbox.com/1e/cf/SpVWhhdJ_o.png" alt="image-20210804142729342"></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 5000000, b = 10000; //-2147483648~2147483647
	short int c{a};
	short int d{b};
	cout &lt;&lt; c &lt;&lt; endl;
	cout &lt;&lt; d &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/3e/7e/4gkNTQoz_o.png" alt="image-20210804142839535"></p> 
<p>默认都为0</p> 
<p><img src="https://images2.imgbox.com/79/61/kxhyzoDg_o.png" alt="image-20210804142922995"></p> 
<p>有效位降低是不允许的！</p> 
<p>也就是缩窄</p> 
<p>double放在long中不允许</p> 
<p><img src="https://images2.imgbox.com/2a/3a/JMKj7k5R_o.png" alt="image-20210804143136313"></p> 
<p>数组替代品 vector</p> 
<h3><a id="_1028"></a>字符串</h3> 
<p><img src="https://images2.imgbox.com/c6/7c/2Q6M0RVM_o.png" alt="image-20210804143211925"></p> 
<p>一种是，C语言风格，把字符串存在数组里</p> 
<p>第二种，基于string类库的方法</p> 
<p>字符串要以<code>\0</code>结尾</p> 
<p>第一个就不是string</p> 
<p>第一个是字符数组</p> 
<p><img src="https://images2.imgbox.com/d8/67/RwA184gB_o.png" alt="image-20210804143546071"></p> 
<p>他会自动加上\0 编译器加进来的</p> 
<p><img src="https://images2.imgbox.com/ef/e8/fPEHTNiC_o.png" alt="image-20210804143741109"></p> 
<p><img src="https://images2.imgbox.com/fb/bb/hXAEeuMU_o.png" alt="image-20210804143753339"></p> 
<p>单引号是字符，双引号是字符串</p> 
<p>双引号里面是两个，外加一个\0</p> 
<p>字符串常量存的是地址</p> 
<h4><a id="_1056"></a>在数组中操作字符串</h4> 
<p>strlen 字符串长度</p> 
<p>sizeof（） 占用内存空间</p> 
<p><img src="https://images2.imgbox.com/32/da/gL9gAATE_o.png" alt="image-20210804145844303"></p> 
<p>15字节</p> 
<p>strlen字符串长度忽略\0</p> 
<p><img src="https://images2.imgbox.com/39/62/bgj6Juqd_o.png" alt="image-20210804150224979"></p> 
<p>第二次输入就没了</p> 
<p>我们加了个空格</p> 
<p><img src="https://images2.imgbox.com/c0/f2/J5vZhRRw_o.png" alt="image-20210804150247234"></p> 
<p>cin使用空白字符（空格，回车，制表符）</p> 
<p>确定字符串</p> 
<p>他认为当前结束了</p> 
<p>dreeb会存到缓冲区</p> 
<p><img src="https://images2.imgbox.com/05/dd/Zb0GGggF_o.png" alt="image-20210804150709737"></p> 
<p><img src="https://images2.imgbox.com/0c/06/FVbsmtXy_o.png" alt="image-20210804152343652"></p> 
<p>都会放在输入缓冲区</p> 
<p>直接去缓冲区读取，</p> 
<h4><a id="getline_1092"></a>getline（）</h4> 
<p>每一次读取一行字符串输入</p> 
<p>cin.getline()</p> 
<p><img src="https://images2.imgbox.com/72/83/a1w6PhxF_o.png" alt="image-20210804152725481"></p> 
<p>设置20 最多会读取19个字符</p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;cmath&gt;
#include&lt;climits&gt;
# include&lt;cstring&gt;
using namespace std;

int main() {
	const int Size = 20;
	char name[Size];
	char dessert[Size];
	cout &lt;&lt; "11" &lt;&lt; endl;
	cin.getline(name, Size);
	cout &lt;&lt; "22" &lt;&lt; endl;

	cin.getline(dessert, Size);
	cout &lt;&lt; "delicious" &lt;&lt; dessert &lt;&lt; endl;

	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/1b/a3/2c6fE77Y_o.png" alt="image-20210804155937168"></p> 
<h4><a id="get_1127"></a>get()</h4> 
<p>和getline一样，都是对行的接收</p> 
<p><img src="https://images2.imgbox.com/d6/97/kiebMW85_o.png" alt="image-20210804155919157"></p> 
<p>get会丢弃换行符，遇到换行符结束</p> 
<p><img src="https://images2.imgbox.com/fa/db/EhQh1GYB_o.png" alt="image-20210804160028244"></p> 
<p>输入后直接会跳两次</p> 
<p><img src="https://images2.imgbox.com/26/4b/hpJJgcLx_o.png" alt="image-20210804160052813"></p> 
<p>空字符，没输入</p> 
<p><img src="https://images2.imgbox.com/68/c5/IbTZD3KW_o.png" alt="image-20210804160438747"></p> 
<p><img src="https://images2.imgbox.com/da/56/ySwV1GN0_o.png" alt="image-20210804160555443"></p> 
<p>中间接受一个回车</p> 
<p><img src="https://images2.imgbox.com/3a/80/fYSULKdQ_o.png" alt="image-20210804160747326"></p> 
<p>函数重载</p> 
<p>参数列表不同参数名字相同</p> 
<p><img src="https://images2.imgbox.com/61/3d/EyLyUw3U_o.png" alt="image-20210804161039509"></p> 
<p><img src="https://images2.imgbox.com/80/db/Hxk1vQwN_o.png" alt="image-20210804161435794"></p> 
<h3><a id="string__1161"></a>string 类简介</h3> 
<p>可以通过数组的类型来操作string，下标之类的都可以</p> 
<p><img src="https://images2.imgbox.com/4c/94/6dljcUtD_o.png" alt="image-20210804162542887"></p> 
<p><img src="https://images2.imgbox.com/b8/a5/r16duCmd_o.png" alt="image-20210804162646276"></p> 
<h5><a id="_1169"></a>赋值，拼接，附加</h5> 
<p>可以把string对象，赋值给另一个string对象</p> 
<p><img src="https://images2.imgbox.com/dd/00/xzxDFlJi_o.png" alt="image-20210804162740650"></p> 
<p><img src="https://images2.imgbox.com/af/82/VpQkxzKm_o.png" alt="image-20210804162905227"></p> 
<p>附加</p> 
<pre><code>#include&lt;iostream&gt;
# include&lt;string&gt;
using namespace std;

int main() {
   char charr1[20];
   char charr2[20] = "jaguar";
   string str1;
   string str2 = "panther";
   cout &lt;&lt; "Enter a kind of feline"&lt;&lt; endl;
   cin &gt;&gt; charr1;
   cout &lt;&lt; "Enter another kind of feline : ";
   cin &gt;&gt; str1;
   cout &lt;&lt; "Here are some felines:\n";
   cout &lt;&lt; charr1 &lt;&lt; " " &lt;&lt; charr2 &lt;&lt; " "&lt;&lt; str1 &lt;&lt; " " &lt;&lt; str2 &lt;&lt; endl;

   return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/c7/f0/INbCfLkA_o.png" alt="image-20210804163221497"></p> 
<p>strcp(charr1,charr2)</p> 
<p>复制</p> 
<p>sstr1+=""</p> 
<p>strcat(charr,“juice”);</p> 
<p>z字符串连接</p> 
<h4><a id="stringIO_1217"></a>string类I/O</h4> 
<p><img src="https://images2.imgbox.com/bf/a8/cyyUVjVZ_o.png" alt="image-20210804163449038"></p> 
<p>如何用getline读取一大串，存在string中</p> 
<p><img src="https://images2.imgbox.com/81/9d/OmghALpf_o.png" alt="image-20210804163713045"></p> 
<p>strlen 查看一下，发现和20不一样，</p> 
<p>因为我们没有进行输入值，内存中随机的</p> 
<p>我们查看str.size()</p> 
<p><img src="https://images2.imgbox.com/7b/20/ubcWqsKz_o.png" alt="image-20210804164141979"></p> 
<p><img src="https://images2.imgbox.com/69/a1/JDcgmC3U_o.png" alt="image-20210804164251270"></p> 
<p>cin.getline</p> 
<p>和</p> 
<p>getline</p> 
<p><img src="https://images2.imgbox.com/b5/d9/p8J2K2aj_o.png" alt="image-20210804164423798"></p> 
<p><img src="https://images2.imgbox.com/87/7f/7vNYtB67_o.png" alt="image-20210804165232308"></p> 
<p>结构体设定</p> 
<p><img src="https://images2.imgbox.com/14/89/BVMTQjID_o.png" alt="image-20210804165303470"></p> 
<p>允许声明结构体省略struct</p> 
<p><img src="https://images2.imgbox.com/fd/aa/tsTg7TuE_o.png" alt="image-20210804165413800"></p> 
<p>填充的时候需要逗号</p> 
<p><img src="https://images2.imgbox.com/df/0e/3wgZYV75_o.png" alt="image-20210804165433175"></p> 
<p><img src="https://images2.imgbox.com/44/81/7Y9GrspA_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/e9/51/5Irm3tKe_o.png" alt="image-20210804165529216"></p> 
<p>外部声明，在所有中都可见</p> 
<p>perk在main函数内可见</p> 
<p><img src="https://images2.imgbox.com/8c/c0/iPaCD1eW_o.png" alt="image-20210804165602083"></p> 
<p>同一种结构体类型就能直接赋值</p> 
<p>结构体和类型直接声明</p> 
<p><img src="https://images2.imgbox.com/9a/ed/xhrDtFTz_o.png" alt="image-20210804194741576"></p> 
<p>同时赋值也可以</p> 
<p><img src="https://images2.imgbox.com/b7/9f/GolAvGNG_o.png" alt="image-20210804194751752"></p> 
<p>不推荐这么干</p> 
<p><img src="https://images2.imgbox.com/ae/37/0OSzPzhY_o.png" alt="image-20210804195302894"></p> 
<p><img src="https://images2.imgbox.com/c1/5d/4ZShJKTC_o.png" alt="image-20210804195327083"></p> 
<h4><a id="_1283"></a>结构体的位字段</h4> 
<p><img src="https://images2.imgbox.com/e0/c0/PRhP7yJm_o.png" alt="image-20210804195410613"></p> 
<p>标志着你有多少位，多少bit</p> 
<p>位字段是低级编程</p> 
<p><img src="https://images2.imgbox.com/a4/6d/nVZVsBJb_o.png" alt="image-20210804195538501"></p> 
<h3><a id="45__1295"></a>4.5 共用体</h3> 
<p>union是一个数据格式</p> 
<p><img src="https://images2.imgbox.com/bc/3e/Pmo9Y9P2_o.png" alt="image-20210804200949954"></p> 
<p><img src="https://images2.imgbox.com/24/8b/OTJpNF87_o.png" alt="image-20210804200715035"></p> 
<p>联合体中，三选一，同一时间，只能使用一个</p> 
<p><img src="https://images2.imgbox.com/bc/35/bhDlmfGD_o.png" alt="image-20210804200805061"></p> 
<p><img src="https://images2.imgbox.com/11/68/ioFsxSUD_o.png" alt="image-20210804200929014"></p> 
<p>和结构体很相似</p> 
<p><img src="https://images2.imgbox.com/e8/4f/KwgflAjt_o.png" alt="image-20210804201021440"></p> 
<p>共用体长度为最大长度</p> 
<p><img src="https://images2.imgbox.com/d7/e0/ut1bKbSi_o.png" alt="image-20210804201536849"></p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;

union one2all {
	char ch;
	int n;

};

int main() {
	one2all num;
	cout &lt;&lt; "sizeof(num)= " &lt;&lt; sizeof(num) &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/92/68/DPOXZuCl_o.png" alt="image-20210804201731934"></p> 
<p>比如你存一个 A 他int 输出 65 他字符串输出A</p> 
<p>同一个内存空间</p> 
<p>结构体放结构体，结构体放联合体都可以</p> 
<p><img src="https://images2.imgbox.com/42/1f/c2Dj6eWQ_o.png" alt="image-20210804202012659"></p> 
<p>可以用联合体查看计算机是大端模式还是小端模式</p> 
<h3><a id="46__1347"></a>4.6 枚举</h3> 
<p>C++ 的 enum 工具提供了创建符号常量的方法</p> 
<p>也相当于struct这种</p> 
<p><img src="https://images2.imgbox.com/50/60/yWYrYcqJ_o.png" alt="image-20210804202110393"></p> 
<p><img src="https://images2.imgbox.com/b4/c6/Yove1Z0g_o.png" alt="image-20210804202214111"></p> 
<p>这样的话，red，orange，等等，都变成了常量</p> 
<p>里面的每个值都是整型，从零开始</p> 
<p><img src="https://images2.imgbox.com/47/2d/P4BxRyZZ_o.png" alt="image-20210804202501680"></p> 
<p>枚举类型声明这种变量，</p> 
<p><code>spectrum band</code></p> 
<p>同时，只能将定义枚举的枚举量赋值给枚举的变量</p> 
<p>只能给0-7或者是red等</p> 
<p>枚举类型，只能赋值，没有算数运算</p> 
<p><img src="https://images2.imgbox.com/99/cb/xWwSXF7I_o.png" alt="image-20210804202815571"></p> 
<p><img src="https://images2.imgbox.com/eb/d1/y4nUSYrZ_o.png" alt="image-20210804202840530"></p> 
<p>可以转换为int 比如转成0 1 之类的</p> 
<p>低转高</p> 
<p><img src="https://images2.imgbox.com/c0/db/5r4727v4_o.png" alt="image-20210804202915068"></p> 
<p>枚举类型，为了定义常量，而不是创建新的常量</p> 
<h4><a id="_1385"></a>设置枚举量的值</h4> 
<p><img src="https://images2.imgbox.com/a7/bf/Hd4HjqOi_o.png" alt="image-20210804203107413"></p> 
<p>比如认识整数哟</p> 
<p><img src="https://images2.imgbox.com/2e/51/CnVhKduP_o.png" alt="image-20210804203257276"></p> 
<p>他有上限和下限，这里赋值就可以</p> 
<p>他的限制必须是最大的2的幂次 （2的三次 =8 二的四次-1 也就是15）</p> 
<p><img src="https://images2.imgbox.com/db/f6/aGc7HuzB_o.png" alt="image-20210804203357383"></p> 
<h3><a id="47__1399"></a>4.7 指针和自由存储空间</h3> 
<p><img src="https://images2.imgbox.com/2a/45/5cryfDFz_o.png" alt="image-20210805101527656"></p> 
<p>存储到何处？</p> 
<p>值为多少，</p> 
<p>存储的信息是什么类型</p> 
<p>求出他值得地址，</p> 
<p><img src="https://images2.imgbox.com/f1/d4/XDebmqxv_o.png" alt="image-20210805103558314"></p> 
<p>加一个取地址符号</p> 
<h4><a id="_1415"></a>如何声明指针</h4> 
<p>指针里面放地址</p> 
<p><img src="https://images2.imgbox.com/9a/e5/5NXXMz6S_o.png" alt="image-20210805104854316"></p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;



int main() {
	int updates = 6;
	int *p_updates;
	p_updates = &amp;updates;
	cout &lt;&lt; "value : updates = " &lt;&lt; updates &lt;&lt; endl;
	cout &lt;&lt; "p_updates = " &lt;&lt; p_updates &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/5b/f6/YWuYO9bV_o.png" alt="image-20210805105057918"></p> 
<h4><a id="472__1440"></a>4.7.2 指针的危险</h4> 
<p><img src="https://images2.imgbox.com/28/b1/eVnB08UR_o.png" alt="image-20210805105152710"></p> 
<p>他地址并不明确，给地址里面送值会有bug</p> 
<p><img src="https://images2.imgbox.com/57/16/UzYfv77d_o.png" alt="image-20210805105651092"></p> 
<h4><a id="474_new_1448"></a>4.7.4 使用new来分配内存</h4> 
<p>指针是访问内存的别名</p> 
<p>new运算符分配内存，比malloc好多了</p> 
<p>new会返回内存块的地址</p> 
<p><img src="https://images2.imgbox.com/1a/0a/QZ5JBZBD_o.png" alt="image-20210805110515276"></p> 
<p><code>int *pn = new int</code>;</p> 
<p><code>typeName * pointer_name = new typeName</code></p> 
<p><img src="https://images2.imgbox.com/0b/e3/KmlrXODA_o.png" alt="image-20210805111330726"></p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;



int main() {
	int nights = 1001;
	int *pt = new int;
	*pt = 1001;

	cout &lt;&lt; "nights value = " &lt;&lt; nights &lt;&lt; "address " &lt;&lt; &amp;nights &lt;&lt; endl;
	cout &lt;&lt; "int value = " &lt;&lt; *pt &lt;&lt; "address value = " &lt;&lt; pt &lt;&lt; endl;
	double * pd = new double;
	*pd = 10000001.0;
	cout &lt;&lt; "double value = " &lt;&lt; *pd &lt;&lt; "address " &lt;&lt; pd &lt;&lt; endl;
	return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/00/1e/alYYrZUd_o.png" alt="image-20210805111344221"></p> 
<h4><a id="delete_1489"></a>使用delete释放内存</h4> 
<p>只会删除内存空间，释放掉，不会删除ps指针，</p> 
<p>new 和 delete要成对使用，</p> 
<p>delete后不要delete，结果不可预知</p> 
<p>delete 不呢个释放声明变量所获得的内存</p> 
<p><img src="https://images2.imgbox.com/40/b4/1HXpIoxN_o.png" alt="image-20210805111627816"></p> 
<p><img src="https://images2.imgbox.com/45/fc/eicjQgIY_o.png" alt="image-20210805111712083"></p> 
<p>没new，就不能delete</p> 
<p>小数据，直接定义就行，大量数据，还是new方便</p> 
<p><img src="https://images2.imgbox.com/2f/af/lx0dyfD2_o.png" alt="image-20210805114250749"></p> 
<p>静态创建数组，浪费，new的时候，不需要就可以不用开创空间</p> 
<p>动态联编</p> 
<h5><a id="new_1515"></a>使用new创建动态数组</h5> 
<p><img src="https://images2.imgbox.com/b4/fa/nA1dojAI_o.png" alt="image-20210805114404140"></p> 
<pre><code>int * psome = new int [10];
</code></pre> 
<p>释放数组：</p> 
<pre><code>delete [] psome;
</code></pre> 
<p>如果不带方括号</p> 
<p>释放的只是第一个元素</p> 
<p><img src="https://images2.imgbox.com/98/44/biPL8cnH_o.png" alt="image-20210805114639010"></p> 
<p><img src="https://images2.imgbox.com/16/ee/ZIiE47cr_o.png" alt="image-20210805114756661"></p> 
<p>指针是变量，数组值是 常量</p> 
<p>数组不能增加/运算之类，</p> 
<h3><a id="_1541"></a>指针，数组，指针算术</h3> 
<p><img src="https://images2.imgbox.com/98/cf/pnJ0G2gw_o.png" alt="image-20210805143708644"></p> 
<p><img src="https://images2.imgbox.com/18/f7/EdtbdWrM_o.png" alt="image-20210805144350913"></p> 
<h4><a id="_1547"></a>数组的动态联编和静态联编</h4> 
<p><img src="https://images2.imgbox.com/f4/f8/zV2zS2NX_o.png" alt="image-20210805144509867"></p> 
<p>使用new[]</p> 
<p><img src="https://images2.imgbox.com/e8/a3/iYLO3Pki_o.png" alt="image-20210805144520202"></p> 
<p>不用不分配</p> 
<h4><a id="_1557"></a>指针和字符串</h4> 
<p><img src="https://images2.imgbox.com/b4/09/Dtd2Xmgc_o.png" alt="image-20210805144716313"></p> 
<p>相当于打印了rose第一个字母r，一次性取出所有字符串，rose 直到找到\0</p> 
<p>strncpy（） 拷贝多少个</p> 
<p><img src="https://images2.imgbox.com/32/81/4xBTaJiN_o.png" alt="image-20210805145257571"></p> 
<p>防止溢出</p> 
<p><img src="https://images2.imgbox.com/be/5a/qYdbmAUH_o.png" alt="image-20210805145354644"></p> 
<p>new char 数组</p> 
<p>动态开辟空间</p> 
<p>new动态创建结构体</p> 
<p>优于编译时候</p> 
<p><img src="https://images2.imgbox.com/08/e0/2EiQ6n2N_o.png" alt="image-20210805145527150"></p> 
<p>结构体类型指针</p> 
<p><img src="https://images2.imgbox.com/31/a4/D5FwezSm_o.png" alt="image-20210805160905284"></p> 
<p><img src="https://images2.imgbox.com/a8/81/lbb1mjrT_o.png" alt="image-20210805160931927"></p> 
<p><img src="https://images2.imgbox.com/0d/38/24R3fc5u_o.png" alt="image-20210805160957458"></p> 
<p>这样也可以实现</p> 
<h5><a id="_1591"></a>接收动态字符串开辟空间函数</h5> 
<p><img src="https://images2.imgbox.com/2d/20/KlEHgLRE_o.png" alt="image-20210805161446124"></p> 
<p><img src="https://images2.imgbox.com/a2/78/w9E3wNa9_o.png" alt="image-20210805161700926"></p> 
<p><img src="https://images2.imgbox.com/eb/2d/YW3XQKuS_o.png" alt="image-20210805161740836"></p> 
<h3><a id="_1601"></a>类型组合</h3> 
<h3><a id="_1603"></a>数组的替代品</h3> 
<p><img src="https://images2.imgbox.com/1a/63/tKrySllS_o.png" alt="image-20210805161910066"></p> 
<h5><a id="vector_1607"></a>模板类vector</h5> 
<p><img src="https://images2.imgbox.com/44/d0/1ELMSmap_o.png" alt="image-20210805162241199"></p> 
<p>用的是圆括号了这儿</p> 
<p><code>vector&lt;typeName&gt; vt(n_elem);</code></p> 
<p>vector代价，效率比较低</p> 
<p>功能强大</p> 
<h4><a id="array_1619"></a>模板类array</h4> 
<p>array长度是固定数组</p> 
<p>array&lt;int ,5&gt; ai;</p> 
<p><img src="https://images2.imgbox.com/41/f8/051gDMp3_o.png" alt="image-20210805162736275"></p> 
<p><img src="https://images2.imgbox.com/b6/29/LRMcsEHb_o.png" alt="image-20210805163704130">v</p> 
<p>vector 是存储在堆中，肯定和其他存储的不一样】</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;array&gt;
using namespace std;



int main() {
	int nights = 1001;
	double a1[4] = { 1.2,2.4,3.6,4.8 };
	vector&lt;double&gt; a2(4);
	a2[0] = 1.0 / 3.0;
	a2[1] = 1.0 / 5.0;
	a2[2] = 1.0 / 7.0;
	a2[3] = 1.0 / 9.0;
	array&lt;double, 4&gt; a3 = { 3.14,2.72,1.62,1.41 };
	array&lt;double, 4&gt; a4;


	return 0;
}

</code></pre> 
<p>使用成员函数，可以使用at来进行检测下标越界</p> 
<p><img src="https://images2.imgbox.com/dd/6b/1tmhyOpI_o.png" alt="image-20210805164328280"></p> 
<h3><a id="_1664"></a>循环</h3> 
<p><img src="https://images2.imgbox.com/9b/a7/Jz4GCdav_o.png" alt="image-20210805165241875"></p> 
<p>这样没加括号，他会等号分开两边</p> 
<p>都不认识</p> 
<p><img src="https://images2.imgbox.com/4f/6a/TrX7LK9A_o.png" alt="image-20210805165826623"></p> 
<p>输出 0 1 之类的</p> 
<p><img src="https://images2.imgbox.com/6a/8f/8HWNOgU9_o.png" alt="image-20210805170900188"></p> 
<p>阶乘的输出</p> 
<h3><a id="__1680"></a>第八章 函数探幽</h3> 
<h4><a id="C__1684"></a>C++ 内联函数</h4> 
<p>为了提高程序运行速度</p> 
<p><img src="https://images2.imgbox.com/4e/91/4vQA0IdK_o.png" alt="image-20210805180150808"></p> 
<p>运行速度快</p> 
<p><img src="https://images2.imgbox.com/60/99/vnj9K2LI_o.png" alt="image-20210805180800578"></p> 
<p>常规函数，很废时间</p> 
<p>花费精力，入栈出栈</p> 
<p>代码执行短的话，方便内联</p> 
<p><img src="https://images2.imgbox.com/eb/a6/4ovBmwUE_o.png" alt="image-20210805201143377"></p> 
<p><img src="https://images2.imgbox.com/cd/bd/xFn79CpM_o.png" alt="image-20210805201239051"></p> 
<p>square就是内联函数</p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;

inline double square(double x) { return x * x; };

int main() {
	double a, b;
	double c = 13.0;

	a = square(5.0);
	b = square(4.5 + 7.5);
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; "b = " &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;
	cout &lt;&lt; "Now c = " &lt;&lt; square(c++) &lt;&lt; endl;
	
	return 0;
}

</code></pre> 
<h3><a id="82__1728"></a>8.2 引用变量</h3> 
<p>引用就是定义变量的别名</p> 
<p><img src="https://images2.imgbox.com/8c/23/dfKWwKN9_o.png" alt="image-20210805201817437"></p> 
<h4><a id="_1734"></a>创建引用变量</h4> 
<p><img src="https://images2.imgbox.com/bb/31/iUoPeLbr_o.png" alt="image-20210805201853474"></p> 
<p>rats 和rodents 可以互换</p> 
<p>引用和指针还是有区别的</p> 
<p><img src="https://images2.imgbox.com/7b/c0/T67hEFhv_o.png" alt="image-20210805202630895"></p> 
<h4><a id="_1744"></a>将引用用作函数参数</h4> 
<p>形参实参一回事儿了</p> 
<p>形参操纵实参，</p> 
<p>脱离C语言</p> 
<p><img src="https://images2.imgbox.com/be/8f/OJ00Rxm1_o.png" alt="image-20210805203814240"></p> 
<p>名字一样，参数不同，也可以哟~</p> 
<h4><a id="85_1756"></a>8.5函数模板</h4> 
<p>交换两个数的值</p> 
<p>怎么写呢？</p> 
<p><img src="https://images2.imgbox.com/ee/06/1tDT1Zzi_o.png" alt="image-20210806101646997"></p> 
<p>函数重载，也可以使用函数模板</p> 
<p>c++函数模板功能可以自动完成这一过程</p> 
<p><img src="https://images2.imgbox.com/a2/d1/gdAHkpuD_o.png" alt="image-20210806101833597"></p> 
<pre><code>template &lt;typename anytype&gt;
</code></pre> 
<p>和class差不多</p> 
<p><img src="https://images2.imgbox.com/f7/43/WVRbsHRF_o.png" alt="image-20210806101922692"></p> 
<p>类型名称任意选</p> 
<p>为了方便，一般都写T ，图省事</p> 
<p>可以接收任意类型~</p> 
<p><img src="https://images2.imgbox.com/11/61/4Os5wL89_o.png" alt="image-20210806102705808"></p> 
<p>两次替换，可以模板函数，也可以函数重载</p> 
<p><img src="https://images2.imgbox.com/69/1f/6GY9wxTM_o.png" alt="image-20210806103308652"></p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;

template&lt;typename T&gt;
void Swap(T &amp;a, T &amp;b);

int main() {
	int i = 10;
	int j = 20;
	cout &lt;&lt; "i,j = " &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; "." &lt;&lt; endl;
	Swap(i, j);
	cout &lt;&lt; "after swap ,now i,j = " &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;

	double x = 24.5;
	double y = 81.7;
	cout &lt;&lt; "i,j = " &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; "." &lt;&lt; endl;
	Swap(x, y);
	cout &lt;&lt; "after swap ,now i,j = " &lt;&lt; x &lt;&lt; "," &lt;&lt; y&lt;&lt; endl;
	return 0;
}

template &lt;typename T&gt;
void Swap(T &amp;a,T &amp;b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
}
</code></pre> 
<p>编写是一个，但是编译器会最终编译生成两个</p> 
<h4><a id="851_1824"></a>8.5.1重载的模板</h4> 
<p>如果说我们想交换数组，必须要重载，不重载很明显就不可以</p> 
<p><img src="https://images2.imgbox.com/58/31/rwOuA5I8_o.png" alt="image-20210806105114652"></p> 
<p>输出没有任何问题</p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;

template&lt;typename T&gt;
void Swap(T &amp;a, T &amp;b);
const int LIM = 8;
void show(int arr[], int n);

int main() {
	int i = 10;
	int j = 20;
	cout &lt;&lt; "i,j = " &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; "." &lt;&lt; endl;
	Swap(i, j);
	cout &lt;&lt; "after swap ,now i,j = " &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;

	int d1[LIM] = { 0,7,0,4,1,7,7,6 };
	int d2[LIM] = { 0,7,2,0,1,9,6,9 };
	cout &lt;&lt; "origianl arrays" &lt;&lt; endl;
	show(d1, LIM);
	show(d2, LIM);

	return 0;
}

template &lt;typename T&gt;
void Swap(T &amp;a,T &amp;b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
}
void show(int arr[], int n) {
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; arr[i] &lt;&lt; " ";

	}
	cout &lt;&lt; endl;

}
</code></pre> 
<p>我们来写模板</p> 
<p><img src="https://images2.imgbox.com/e1/25/GFOADAJ2_o.png" alt="image-20210806105945291"></p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;

template&lt;typename T&gt;
void Swap(T &amp;a, T &amp;b);
template&lt;typename T&gt;
void Swap(T a[], T b[], int n);
const int LIM = 8;
void show(int arr[], int n);

int main() {

	int d1[LIM] = { 0,7,0,4,1,7,7,6 };
	int d2[LIM] = { 0,7,2,0,1,9,6,9 };
	cout &lt;&lt; "origianl arrays" &lt;&lt; endl;
	show(d1, LIM);
	show(d2, LIM);
	Swap(d1, d2, LIM);
	cout &lt;&lt; "Swapped arrays = " &lt;&lt; endl;
	show(d1,LIM);
	show(d2, LIM);

	return 0;
}

template &lt;typename T&gt;
void Swap(T &amp;a,T &amp;b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
}
template&lt;typename T&gt;
void Swap(T a[], T b[], int n) {
	T temp;
	for (int i = 0; i &lt; n; i++) {
		temp = a[i];
		a[i] = b[i];
		b[i] = temp;
	}
}
void show(int arr[], int n) {
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

}
</code></pre> 
<h4><a id="852__1931"></a>8.5.2 模板的局限性</h4> 
<p><img src="https://images2.imgbox.com/6f/29/pPwymfj0_o.png" alt="image-20210806110203065"></p> 
<p><img src="https://images2.imgbox.com/d7/dd/cpZgipP7_o.png" alt="image-20210806110739729"></p> 
<p>交换结构体，直接把所有东西都交换了</p> 
<p><img src="https://images2.imgbox.com/75/ed/5SRLdy0f_o.png" alt="image-20210806110802109"></p> 
<p>我只想交换钱，</p> 
<p><img src="https://images2.imgbox.com/1d/6c/Txl9Fp9v_o.png" alt="image-20210806110826089"></p> 
<p>重载，参数类型，数量需要不同</p> 
<h4><a id="853___1947"></a>8.5.3 显式具体化</h4> 
<p>template &lt;&gt; void Swap(job &amp;j1,job &amp;j2)</p> 
<p><img src="https://images2.imgbox.com/62/10/FkpXh8u1_o.png" alt="image-20210806111705501"></p> 
<p>告诉编译器。如果传过来的是job类型，就不能去用其他的模板</p> 
<p><img src="https://images2.imgbox.com/ab/a1/qsKIM1xj_o.png" alt="image-20210806113336500"></p> 
<p>成功替换</p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;

template&lt;typename T&gt;
void Swap(T &amp;a, T &amp;b);
template&lt;typename T&gt;
void Swap(T a[], T b[], int n);
const int LIM = 8;
void show(int arr[], int n);


struct job
{
	char name[40];
	double salary;
	int floor;
};

template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2);
void show(job &amp;j);

int main() {

	int d1[LIM] = { 0,7,0,4,1,7,7,6 };
	int d2[LIM] = { 0,7,2,0,1,9,6,9 };
	cout &lt;&lt; "origianl arrays" &lt;&lt; endl;
	show(d1, LIM);
	show(d2, LIM);
	Swap(d1, d2, LIM);
	cout &lt;&lt; "Swapped arrays = " &lt;&lt; endl;
	show(d1,LIM);
	show(d2, LIM);

	job Rick = { "Rick",100,10 };
	job Jack = { "Jack",1100,11 };
	show(Rick);
	show(Jack);
	Swap(Rick, Jack);
	show(Rick);
	show(Jack);

	return 0;
}

template &lt;typename T&gt;
void Swap(T &amp;a,T &amp;b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
}
template&lt;typename T&gt;
void Swap(T a[], T b[], int n) {
	T temp;
	for (int i = 0; i &lt; n; i++) {
		temp = a[i];
		a[i] = b[i];
		b[i] = temp;
	}
}
void show(int arr[], int n) {
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

}
void show(job &amp;j) {
	cout &lt;&lt; j.name &lt;&lt; ":" &lt;&lt; j.salary &lt;&lt; "onfloor" &lt;&lt; j.floor &lt;&lt; endl;
}
template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2) {
	double t1;
	int t2;

	t1 = j1.salary;
	j1.salary = j2.salary;
	j2.salary = t1;

	t2 = j1.floor;
	j1.floor = j2.floor;
	j2.floor = t2;
}

</code></pre> 
<p>优先显示具体化的函数</p> 
<h4><a id="854__2048"></a>8.5.4 实例化和具体化</h4> 
<p><img src="https://images2.imgbox.com/0a/ef/GR3DV4k4_o.png" alt="image-20210806120010031"></p> 
<h5><a id="__2052"></a>自己选择 合适的函数调用</h5> 
<p><img src="https://images2.imgbox.com/b7/a2/dxk55Sz4_o.png" alt="image-20210806120210655"></p> 
<p>我们定义一个模板函数和一个非模板函数</p> 
<p><img src="https://images2.imgbox.com/c4/ee/bcJjOdld_o.png" alt="image-20210806174943976"></p> 
<p>非模板函数优先</p> 
<p><img src="https://images2.imgbox.com/a3/21/EgmeL4uF_o.png" alt="image-20210806175052811"></p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;
template&lt;class T&gt;
T lesser(T a, T b) {
	return a &lt; b ? a : b;
}

int lesser(int a, int b) {
	a = a &lt; 0 ? -a : a;
	b = b &lt; 0 ? -b : b;
	return a &lt; b ? a : b;
}
int main(void) {
	int m = 20;
	int n = -30;

	double x = 15.5;
	double y = 25.9;
	cout &lt;&lt; lesser(m, n) &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/4a/b9/n623TBN8_o.png" alt="image-20210806175305318"></p> 
<p>这样，优先使用模板函数</p> 
<p><img src="https://images2.imgbox.com/5c/08/qQugCdmQ_o.png" alt="image-20210806175338853"></p> 
<pre><code>#include&lt;iostream&gt;

using namespace std;
template&lt;class T&gt;
T lesser(T a, T b) {
	return a &lt; b ? a : b;
}

int lesser(int a, int b) {
	a = a &lt; 0 ? -a : a;
	b = b &lt; 0 ? -b : b;
	return a &lt; b ? a : b;
}
int main(void) {
	int m = 20;
	int n = -30;

	double x = 15.5;
	double y = 25.9;
	cout &lt;&lt; lesser(m, n) &lt;&lt; endl;

	cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/a0/b4/6U4gFwFW_o.png" alt="image-20210806175557349"></p> 
<p>告诉模板函数，参数强转为int</p> 
<p><img src="https://images2.imgbox.com/96/0e/AxF0AmCd_o.png" alt="image-20210806175619043"></p> 
<h3><a id="_2128"></a>单独编译</h3> 
<p>工程可能会包含很多源代码和头文件</p> 
<p>除了内联函数，其他定义不放头文件</p> 
<p><img src="https://images2.imgbox.com/4c/ae/NBhNZvlC_o.png" alt="image-20210806183835926"></p> 
<p>可以写.c .cpp 专门来调用其他</p> 
<p>上面那些东西都放头文件里面</p> 
<p><img src="https://images2.imgbox.com/8b/67/O6eVaHjD_o.png" alt=""></p> 
<p>一个 功能一个cpp比较香</p> 
<p><img src="https://images2.imgbox.com/4e/25/FdJUtT4S_o.png" alt="image-20210806190720342"></p> 
<p>把两个拆开，然后编译，然后链接</p> 
<p><img src="https://images2.imgbox.com/ac/3e/2H5oWluR_o.png" alt="image-20210806191257251"></p> 
<p>保证了项目只会定义一次，</p> 
<p>if not define 如果没有定义过，然后才会去定义头文件，</p> 
<p>有if 必须要有endif</p> 
<p><img src="https://images2.imgbox.com/b6/16/zeLKeHaL_o.png" alt="image-20210806194025143"></p> 
<p>双引号，代表去你当前目录去获取头文件</p> 
<p>函数调用</p> 
<p>file1.cpp</p> 
<pre><code># include&lt;iostream&gt;
#include "coordin.h"
using namespace std;
int main(void) {
	rect rplace;
	polar pplace;

	cout &lt;&lt; "Enter the x and y values :";
	while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) {
		pplace = rect_to_polar(rplace);
		show_polar(pplace);
		cout &lt;&lt; "Next two number (q to quit):";

	}
	return 0;
}
</code></pre> 
<p>函数原型声明 .h</p> 
<pre><code>#pragma once
#pragma once
#ifndef __COORDIN_H__
#define __COORDIN_H__

struct polar
{
	double distance;
	double angle;
};

struct rect {
	double x;
	double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);


#endif // !__COORDIN_H__

</code></pre> 
<p>函数定义</p> 
<p>file2.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include "coordin.h"

using namespace std;

polar rect_to_polar(rect xypos) {
	polar answer;

	answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
	answer.angle = atan2(xypos.y, xypos.x);

	return answer;
}
void show_polar(polar dapos) {
	const double Rad_to_deg = 57.29577951;

	cout &lt;&lt; "distance = " &lt;&lt; dapos.distance &lt;&lt; endl;
	cout &lt;&lt; "angle = " &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; " degree " &lt;&lt; endl;

}
</code></pre> 
<h3><a id="_2253"></a>存储秩序性，作用域和链接性</h3> 
<p><img src="https://images2.imgbox.com/3f/c9/qaAdD3DQ_o.png" alt="image-20210809181220011"></p> 
<p>形参，实参，以及参数的区域，c学过了</p> 
<h3><a id="C_11_auto_2261"></a>使用C++ 11 中的auto</h3> 
<p>register auto</p> 
<p><img src="https://images2.imgbox.com/a1/3b/vRXXbwCi_o.png" alt="image-20210809193143340"></p> 
<p>extern</p> 
<p><img src="https://images2.imgbox.com/7e/0f/hOrDl9QI_o.png" alt="image-20210809193211834"></p> 
<p>声明函数，说明这个参数是外来的，这里只是想用到</p> 
<h4><a id="_2273"></a>作用域解析运算符</h4> 
<p><img src="https://images2.imgbox.com/dd/2c/z8NrQoeQ_o.png" alt="image-20210809193615620"></p> 
<p><code>::</code></p> 
<p>加上以后相当于调用全局变量</p> 
<p><img src="https://images2.imgbox.com/47/71/rXHhknSl_o.png" alt="image-20210809193637034"></p> 
<p>这里的：：warming ，表示使用的全局版本</p> 
<p>support.cpp</p> 
<pre><code>#include "support.h"

using namespace std;

void update(double dt) {
	warming += dt;
	cout &lt;&lt; "Update" &lt;&lt; warming &lt;&lt; endl;


}
void local(void) {

}
</code></pre> 
<p>external.cpp</p> 
<pre><code># include&lt;iostream&gt;
# include "support.h"

using namespace std;

double warming = 0.3;

int main(void) {
	cout &lt;&lt; "Global warming is " &lt;&lt; warming &lt;&lt; "degrees." &lt;&lt; endl;
	update(0.1);
	cout &lt;&lt; "Global warming is " &lt;&lt; warming &lt;&lt; "degrees." &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>support.h</p> 
<pre><code>#pragma once
#ifndef __SUPPORT_H__
#define __SUPPORT_H__

#include&lt;iostream&gt;
extern double warming;
void update(double dt);
void local(void);

#endif


</code></pre> 
<h3><a id="_2344"></a>静态持续性，内部链接性</h3> 
<p><img src="https://images2.imgbox.com/70/4d/KFIiOL5c_o.png" alt="image-20210809193947223"></p> 
<p><img src="https://images2.imgbox.com/aa/44/qnnlJh5i_o.png" alt="image-20210809194030930"></p> 
<p>内部只能内部文件用，</p> 
<p><img src="https://images2.imgbox.com/fc/2b/fn0aohtA_o.png" alt="image-20210809194145005"></p> 
<p>就近原则，差不多~</p> 
<p>file1.cpp</p> 
<p><img src="https://images2.imgbox.com/83/22/3pq0qgK0_o.png" alt="image-20210809194659434"></p> 
<p>file2.cpp</p> 
<p><img src="https://images2.imgbox.com/cf/90/aG7NqGvK_o.png" alt="image-20210809194706990"></p> 
<h4><a id="_2368"></a>无链接性的局部变量</h4> 
<p>其他函数，文件，看不到你</p> 
<p><img src="https://images2.imgbox.com/2d/5a/jUYmwcF8_o.png" alt="image-20210809195225124"></p> 
<p>cin.get() 获取内容</p> 
<p><img src="https://images2.imgbox.com/ef/06/Y14NmbEm_o.png" alt="image-20210809195755426"></p> 
<p><img src="https://images2.imgbox.com/c7/20/9ARRk8pg_o.png" alt="image-20210809195742972"></p> 
<p><img src="https://images2.imgbox.com/a2/3c/Gfx0mRQc_o.png" alt="image-20210809195909636">total只再第一次调用。count会掉一次初始化位0</p> 
<p><img src="https://images2.imgbox.com/e9/c5/2XqYaz2w_o.png" alt="image-20210809200102444"></p> 
<p>total 值之后就不变了</p> 
<h3><a id="_2386"></a>说明符和限定符</h3> 
<p>auto 自动匹配 变量类型</p> 
<p>register 分配内存分配到寄存器</p> 
<p><img src="https://images2.imgbox.com/8a/37/GSuqkgne_o.png" alt="image-20210809200333388"></p> 
<p><img src="https://images2.imgbox.com/16/6f/hHHv0elE_o.png" alt="image-20210809200500361"></p> 
<h4><a id="CV_2396"></a>CV限定符</h4> 
<p>volatile和mutable</p> 
<p>固件用的比较多</p> 
<h5><a id="const_2402"></a>const</h5> 
<p>链接性为内部的，不会影响到其他文件</p> 
<h3><a id="_2406"></a>函数和链接性</h3> 
<p>C++ 不允许一个函数中，定义另一个函数，所有的函数存储持续性为静态</p> 
<p>extern 函数指出另一个文件中定义，是可选的，默认不写</p> 
<p>函数static 定义，只能在一个文件中使用</p> 
<p><img src="https://images2.imgbox.com/07/4f/dq6gSk0a_o.png" alt="image-20210809200731989"></p> 
<h3><a id="_2416"></a>语言的链接性</h3> 
<p>C语言一个名称一个函数</p> 
<p><img src="https://images2.imgbox.com/71/1b/KaDXeVIy_o.png" alt="image-20210809200808322"></p> 
<p>C++ 中同一个名称可能多个函数</p> 
<p><img src="https://images2.imgbox.com/76/56/5KoDet6l_o.png" alt="image-20210809200835572"></p> 
<p>编译器可能会改他的名字</p> 
<h3><a id="_2428"></a>存储方案和动态分配</h3> 
<p>new开辟，delete释放</p> 
<p>使用new进行初始化</p> 
<p><img src="https://images2.imgbox.com/4b/ca/E0WXoolr_o.png" alt="image-20210809200955109"></p> 
<p><img src="https://images2.imgbox.com/96/69/ndLvcEoV_o.png" alt="image-20210809201025877"></p> 
<p>开辟内存空间，初值为6</p> 
<p><img src="https://images2.imgbox.com/95/a5/novUEx0j_o.png" alt="image-20210809201050598"></p> 
<p><img src="https://images2.imgbox.com/5c/bb/ps2kGSLJ_o.png" alt="image-20210809201122997"></p> 
<p><img src="https://images2.imgbox.com/9b/4b/usnYoK0m_o.png" alt="image-20210809201142137"></p> 
<h4><a id="new_2448"></a>定位new运算符</h4> 
<p><img src="https://images2.imgbox.com/b8/1f/R7VnoXjC_o.png" alt="image-20210809201306464"></p> 
<p>可以指定，存放的位置</p> 
<p>使用new</p> 
<p>处理特定位置i访问的硬件或者是创建对象</p> 
<p><img src="https://images2.imgbox.com/89/ea/NhIpxXa7_o.png" alt="image-20210809201310440"></p> 
<p><img src="https://images2.imgbox.com/3d/19/lfcA6LFE_o.png" alt="image-20210809201353737"></p> 
<p><img src="https://images2.imgbox.com/53/04/WpFVEXO8_o.png" alt="image-20210809201424626"></p> 
<p>指定在那个内存空间中，</p> 
<p>指定在buffer1里面</p> 
<p>new定位运算符，需要new头文件</p> 
<p><img src="https://images2.imgbox.com/81/93/offnrlln_o.png" alt="image-20210809201834475"></p> 
<p><img src="https://images2.imgbox.com/da/d0/yMvxSXMw_o.png" alt="image-20210809201851729"></p> 
<p><img src="https://images2.imgbox.com/07/c5/GlJDqJ5g_o.png" alt="image-20210809202156524"></p> 
<p>c++，我们想要输出字符串的地址，buffer，这样肯定式字符串，我们要强制转换，让他知道我们出地址</p> 
<p><img src="https://images2.imgbox.com/6b/19/efgYSokS_o.png" alt="image-20210809202230568"></p> 
<p><img src="https://images2.imgbox.com/ff/b0/XtAut2z3_o.png" alt="image-20210809202343187"></p> 
<p>很明现，这两个地址不一样</p> 
<p><img src="https://images2.imgbox.com/d2/fe/uJgMDdnY_o.png" alt="image-20210809202513056"></p> 
<p><img src="https://images2.imgbox.com/d9/5c/OlzLHS7J_o.png" alt="image-20210809202914339"></p> 
<p>我们发现，pd2和buffer一样的</p> 
<p>delete的时候</p> 
<p><img src="https://images2.imgbox.com/5b/f0/cSnT2Y8s_o.png" alt="image-20210809203018870"></p> 
<p>delete 不能用于定位的new运算符</p> 
<p>delete 删除的是动态内存，动态释放内存，new也是</p> 
<p><img src="https://images2.imgbox.com/1d/39/PwgZoYnV_o.png" alt="image-20210809203513883"></p> 
<h3><a id="93__2502"></a>9.3 名称空间</h3> 
<p>不同厂家类库，可能会冲突~</p> 
<p><img src="https://images2.imgbox.com/26/a5/IhGZJhpF_o.png" alt="image-20210809203628499"></p> 
<h4><a id="932__2508"></a>9.3.2 新的名称空间特性</h4> 
<p><img src="https://images2.imgbox.com/f2/83/0cIyrxn2_o.png" alt="image-20210809203736400"></p> 
<p>我们可以使用任意一个名称，用的时候，写具体就可以</p> 
<p>名称空间包含名称空间也可以，默认外部，但是不能在代码块中</p> 
<p><img src="https://images2.imgbox.com/d8/34/1zdQFZ7k_o.png" alt="image-20210809203830192"></p> 
<p>新的名称，随便加</p> 
<p><img src="https://images2.imgbox.com/25/df/kLZPbhvZ_o.png" alt="image-20210809203844444"></p> 
<p><img src="https://images2.imgbox.com/a6/ed/WwpRoxrd_o.png" alt="image-20210809203908771"></p> 
<p>当然，需要作用域解析运算符</p> 
<p>指名道姓</p> 
<h5><a id="using_using__2528"></a>using 声明和using 编译指令</h5> 
<p><img src="https://images2.imgbox.com/79/8d/4b9A1ewE_o.png" alt="image-20210809204011161"></p> 
<p><img src="https://images2.imgbox.com/1b/1d/GEFFPyJ0_o.png" alt="image-20210809204030477"></p> 
<p><img src="https://images2.imgbox.com/a3/96/z1qzsWzF_o.png" alt="image-20210809204112150"></p> 
<p>放到了局部声明区域</p> 
<p>编译指令</p> 
<p><img src="https://images2.imgbox.com/9a/54/p5IjOq5p_o.png" alt="image-20210809204151941"></p> 
<p><img src="https://images2.imgbox.com/62/44/bEnKnipo_o.png" alt="image-20210809204219246"></p> 
<p><img src="https://images2.imgbox.com/f6/6b/s7I6lfiB_o.png" alt="image-20210809204253850"></p> 
<p><img src="https://images2.imgbox.com/c7/08/cPdtJSQL_o.png" alt="image-20210809204815632"></p> 
<p>如果使用fetch，优先局部变量，不会进行冲突</p> 
<p><img src="https://images2.imgbox.com/79/fb/GEqkKZYv_o.png" alt="image-20210809205314291"></p> 
<p>名称空间的套用</p> 
<p><img src="https://images2.imgbox.com/b1/b1/KKiAfIJY_o.png" alt="image-20210809205328035"></p> 
<p>这样using的编译指令</p> 
<p><img src="https://images2.imgbox.com/42/45/VpaUyaEw_o.png" alt="image-20210809205338587"></p> 
<h4><a id="_2564"></a>未命名的名称空间</h4> 
<p><img src="https://images2.imgbox.com/6f/c8/eXNkS3Q3_o.png" alt="image-20210809205446494"></p> 
<p>从声明开始，到结束</p> 
<h3><a id="__2570"></a>第十章 类和对象</h3> 
<p>通过public方法，调用private的隐私数据</p> 
<p>头文件只做类的声明，不会把他具体写出来</p> 
<h4><a id="_2576"></a>访问控制</h4> 
<p><img src="https://images2.imgbox.com/81/f6/AXli9cjP_o.png" alt="image-20210810105140190"></p> 
<p>只有通过public能改private</p> 
<h4><a id="_2582"></a>控制对成员的访问，公有还是私有</h4> 
<p>没private，数据默认私有，</p> 
<p><img src="https://images2.imgbox.com/70/42/Em1inPpa_o.png" alt="image-20210810105838144"></p> 
<p>stock00.h 头文件</p> 
<pre><code>#pragma once
#ifndef __STOCK00__H__
#define __ STOCK00__H__
#include&lt;string&gt;

class Stock
{
private:
	std::string company;
	long shares;
	double share_val;
	double total_val;
	void set_total() { total_val = shares * share_val };
public:
	void acquire(const std::string &amp;co,long n,double pr);//哪一个公司的股票
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show();

};


#endif
</code></pre> 
<h3><a id="1023__2619"></a>10.2.3 实现类成员函数</h3> 
<p><img src="https://images2.imgbox.com/3d/6a/KzIWM2eQ_o.png" alt="image-20210810110123221"></p> 
<p>用 ：： 标识类</p> 
<p><img src="https://images2.imgbox.com/28/79/mNzlzFc4_o.png" alt="image-20210810110201735"></p> 
<p><img src="https://images2.imgbox.com/2f/88/3Xez66Lm_o.png" alt="image-20210810110210139"></p> 
<p>我们可以跟另一个也可以定义同样的函数</p> 
<p>类内，不需要指定</p> 
<h4><a id="_2635"></a>内联方法</h4> 
<p><img src="https://images2.imgbox.com/87/23/U2t5gru8_o.png" alt="image-20210810111949374"></p> 
<p>定义位于类声明中的函数都将自动成为内联函数</p> 
<p><img src="https://images2.imgbox.com/33/35/thrf5Xnd_o.png" alt="image-20210810112229622"></p> 
<p>函数声明时候，就定义了，这个就自动成为了内联函数</p> 
<p>如果有inline 也会是内联函数</p> 
<p><img src="https://images2.imgbox.com/c1/25/I0ZB3s2e_o.png" alt="image-20210810112509807"></p> 
<p>放在外面实现</p> 
<p>类的定义</p> 
<p>stock00.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include "stock00.h"



void Stock::acquire(const std::string &amp;co,long n,double pr) {
	company = co;
	if (n &lt; 0) {
		std::cout &lt;&lt; "Number of share can't be negative;" &lt;&lt; company &lt;&lt; std::endl;

	}
	else
		shares = n;

	set_total();
}

void Stock::buy(long num, double price) {
	if (num &lt; 0) {
		std::cout &lt;&lt; "number of shares can't be negative,Transaction is aborted" &lt;&lt; std::endl;

	}
	else {
		shares += num;
		share_val = price;
		set_total();
	}
}
void Stock::sell(long num, double price) {
	using std::cout;
	if (num) {
		std::cout &lt;&lt; "number of shares can't be negative " &lt;&lt; std::endl;

	}
	else if (num &gt; shares) {
		cout &lt;&lt; "you can't sell more than you have " &lt;&lt; std::endl;

	}
	else {
		shares -= num;
		share_val = price;
		set_total();
	}
}

void Stock::update(double price) {
	share_val = price;
	set_total();
}

void Stock::show() {
	std::cout &lt;&lt; "Company: " &lt;&lt; company &lt;&lt; std::endl;
	std::cout &lt;&lt; "Shares: " &lt;&lt; shares &lt;&lt; std::endl;
	std::cout &lt;&lt; "share price : " &lt;&lt; share_val &lt;&lt; std::endl;
	std::cout &lt;&lt; "TOtal worth:" &lt;&lt; total_val &lt;&lt; std::endl;
}
</code></pre> 
<h3><a id="1024__2714"></a>10.2.4 使用类</h3> 
<pre><code>#include&lt;iostream&gt;
#include"stock00.h"


int main(void) {
	Stock fluffy_the_cat;
	fluffy_the_cat.acquire("wuwu",20,12.5);//第一次获取一个股票
	fluffy_the_cat.show();
	
	fluffy_the_cat.buy(15, 18.125);//再买多少zhi，meizhi多少钱
	fluffy_the_cat.show();
	
	fluffy_the_cat.sell(400, 20.00);//尝试卖400份，查看报错
	fluffy_the_cat.show();
	
	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/7c/XopcgLfh_o.png" alt="image-20210810113410568"></p> 
<p><img src="https://images2.imgbox.com/c1/52/hC1YwkI6_o.png" alt="image-20210810114101864"></p> 
<p><img src="https://images2.imgbox.com/5d/7a/gquDOIDn_o.png" alt="image-20210810114645337"></p> 
<p>卖多了，提示，不能卖</p> 
<h3><a id="_2746"></a>类的构造和析构函数</h3> 
<p><img src="https://images2.imgbox.com/12/f5/BnuKTjkB_o.png" alt="image-20210810115201768"></p> 
<p><img src="https://images2.imgbox.com/ad/71/RyestLem_o.png" alt="image-20210810115617708"></p> 
<p>不能将参数当作构造函数的参数</p> 
<p>避免混乱，我们在数据前面加前缀m_</p> 
<p>构造函数没有返回值~~</p> 
<p>stock10.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include"stock00.h"

Stock::Stock(const std::string &amp;co, long n, double pr) {
	company = co;
	if (n &lt; 0) {
		std::cout &lt;&lt; "Number of share can't be negative;" &lt;&lt; company &lt;&lt; std::endl;
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_total();
}
</code></pre> 
<p>C++ 提供了两种方法来构造函数，第一种是显式的 调用构造函数</p> 
<h4><a id="_2783"></a>使用构造函数</h4> 
<p><img src="https://images2.imgbox.com/5c/d0/0ReaSrl5_o.png" alt="image-20210810150942461"></p> 
<p><img src="https://images2.imgbox.com/75/ac/8YspsJtX_o.png" alt="image-20210810152250202"></p> 
<p>如果使用默认参数，这里在声明中直接填入值(默认值)</p> 
<p><img src="https://images2.imgbox.com/b6/01/KBV0nV2h_o.png" alt="image-20210810152436583"></p> 
<p>另一种方式是函数重载，来定义另一个构造函数，一个没有参数的构造参数，</p> 
<p>上面两种只能采用其一。否则会冲突</p> 
<p><img src="https://images2.imgbox.com/d9/11/IVK5deBD_o.png" alt="image-20210810152945557"></p> 
<p>usestock2.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include "stock00.h"
int main(void) {
	/*
	Stock stock1("Nanosmart", 12, 20.0);
	stock1.show();

	Stock stock2 = Stock("Boffo objects", 2, 2.0);
	stock2.show();
	*/
	Stock stock1;
	stock1.show();
}
</code></pre> 
<p>stock.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include"stock00.h"
/*
Stock::Stock(const std::string &amp;co, long n, double pr) {
	company = co;
	if (n &lt; 0) {
		std::cout &lt;&lt; "Number of share can't be negative;" &lt;&lt; company &lt;&lt; std::endl;
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_total();
}*/

Stock::Stock() {
	company = "no name";
	shares = 0;
	share_val = 0.0;
	total_val = 0.0;
}
</code></pre> 
<p>stock00.h</p> 
<pre><code>#pragma once
#ifndef __STOCK00__H__
#define __ STOCK00__H__
#include&lt;string&gt;

class Stock
{
private:
	std::string company;
	long shares;
	double share_val;
	double total_val;
	void set_total() { total_val = shares * share_val; };
public:
	Stock();
	//Stock(const std::string &amp;co, long n, double pr);
	void acquire(const std::string &amp;co,long n,double pr);//哪一个公司的股票
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show();

};


#endif
</code></pre> 
<p>stock00.cpp</p> 
<pre><code>#include&lt;iostream&gt;
#include "stock00.h"



void Stock::acquire(const std::string &amp;co,long n,double pr) {
	company = co;
	if (n &lt; 0) {
		std::cout &lt;&lt; "Number of share can't be negative;" &lt;&lt; company &lt;&lt; std::endl;
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_total();
}

void Stock::buy(long num, double price) {
	if (num &lt; 0) {
		std::cout &lt;&lt; "number of shares can't be negative,Transaction is aborted" &lt;&lt; std::endl;

	}
	else {
		shares += num;
		share_val = price;
		set_total();
	}
}
void Stock::sell(long num, double price) {
	using std::cout;
	if (num) {
		std::cout &lt;&lt; "number of shares can't be negative " &lt;&lt; std::endl;

	}
	else if (num &gt; shares) {
		cout &lt;&lt; "you can't sell more than you have " &lt;&lt; std::endl;

	}
	else {
		shares -= num;
		share_val = price;
		set_total();
	}
}

void Stock::update(double price) {
	share_val = price;
	set_total();
}

void Stock::show() {
	std::cout &lt;&lt; "Company: " &lt;&lt; company &lt;&lt; std::endl;
	std::cout &lt;&lt; "Shares: " &lt;&lt; shares &lt;&lt; std::endl;
	std::cout &lt;&lt; "share price : " &lt;&lt; share_val &lt;&lt; std::endl;
	std::cout &lt;&lt; "TOtal worth:" &lt;&lt; total_val &lt;&lt; std::endl;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/cc/69/FvSJZ2LF_o.png" alt="image-20210810153048225"></p> 
<p>传参了，就一定不是默认的构造函数</p> 
<p><img src="https://images2.imgbox.com/f0/00/JiotRzz8_o.png" alt="image-20210810153152309"></p> 
<p>第三个，默认的构造函数</p> 
<h3><a id="1034__2949"></a>10.3.4 析构函数</h3> 
<p><img src="https://images2.imgbox.com/4d/ac/JlwfZ569_o.png" alt="image-20210810154313230"></p> 
<p>对象使用完毕后，会自动调用析构函数，</p> 
<p>如果在构造函数中new来分配内存，析构函数将调用delete释放</p> 
<p>析构函数也没有返回值和类型</p> 
<p><img src="https://images2.imgbox.com/45/12/ubs6qB05_o.png" alt="image-20210810154445579"></p> 
<p>析构函数没有参数</p> 
<p><code>~Stock();</code></p> 
<p>同时，因为上一个没new，所以，析构函数为空</p> 
<p><img src="https://images2.imgbox.com/6a/7b/v04vcNei_o.png" alt="image-20210810154536807"></p> 
<p><img src="https://images2.imgbox.com/d5/12/8xkXSwrX_o.png" alt="image-20210810154624248"></p> 
<h3><a id="104_this_2975"></a>10.4 this指针</h3> 
<p><img src="https://images2.imgbox.com/12/56/8UDod9Ma_o.png" alt="image-20210810160024522"></p> 
<p>如果我们需要比较，两个类的时候，</p> 
<p>我们要比较两个类对象，</p> 
<p>指向用来调用成员函数的对象，this表示正在访问的对象，</p> 
<p><img src="https://images2.imgbox.com/49/2d/0nbthFRL_o.png" alt="image-20210810163247598"></p> 
<p>tips</p> 
<p><img src="https://images2.imgbox.com/0c/5f/qBIgQPpr_o.png" alt="image-20210810163258908"></p> 
<p>*this 这样表示了整个调用对象</p> 
<p><img src="https://images2.imgbox.com/96/51/WiXny68u_o.png" alt="image-20210810163423399"></p> 
<p>这里的return就是<code>*this</code></p> 
<p><strong>this指针指向调用成员的对象</strong></p> 
<h3><a id="105__3001"></a>10.5 对象数组</h3> 
<p><img src="https://images2.imgbox.com/76/87/YSy514mb_o.png" alt="image-20210810171056578"></p> 
<p>构造函数初始化数组</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c74615293dccfb54e13f8c28b185663/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python实现Excel转JSON</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9e62625cce27cf7c88a0705dc4e5feb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器虚拟化书籍,服务器虚拟化解决方案书模板-精选版.doc</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>