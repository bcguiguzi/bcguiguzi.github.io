<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【DR_CAN-MPC学习笔记】3&amp;4.详细的MPC建模例子和matlab代码 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【DR_CAN-MPC学习笔记】3&amp;4.详细的MPC建模例子和matlab代码" />
<meta property="og:description" content="上一篇博客：【DR_CAN-MPC学习笔记】2.最优化数学建模推导
参照二次规划一般形式，详细推导了MPC的数学模型，即最小化代价函数的表达式，最终推导结果为：
DR_CAN的视频：
【MPC模型预测控制器】3_一个详细的建模例子
【MPC模型预测控制器】3
【MPC模型预测控制器】4_完整案例讲解 - Octave代码
【MPC模型预测控制器】4
离散系统状态空间一般形式： 其中 为状态向量（n×1）， 为输入向量（p×1）， 为系统状态矩阵（n×n）， 为系统输入矩阵（n×p）。
单输入二阶系统的例子： 上式中，，，n = 2，p = 1
系统状态向量和输入向量的关系： 表示在k时刻预测 k＋1 时刻的系统状态。由于 由 决定，因此不需要 ，所以 比 少一个维度。因为初始值 和 均为 n×1 向量，因此 为 (N&#43;1)n×1 向量。同理可推出 为 Np×1 向量。 为 (N&#43;1)n×n 矩阵。 矩阵上面所有的 0 与初始状态 有关（n×1矩阵）， 均为 n×p 矩阵，因此 为 (N&#43;1)n×Np 矩阵。 具体可参考上一篇博客的推导（【DR_CAN-MPC学习笔记】2.最优化数学建模推导）：
分析过程： 回到单输入二阶系统的例子，，，n = 2，p = 1，假设预测区间 N=3 ，
整理一下维度：
=&#43;(N&#43;1)n×1=(N&#43;1)n×nn×1&#43;(N&#43;1)n×NpNp×18×1=8×22×1&#43;8×33×1 对于系统输出方程： ，参考值 ，误差 ，代价函数为：
代价函数 = 误差加权和 &#43; 输入加权和 &#43; 终端误差，其中 和 为权重系数矩阵且均为对角矩阵。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2d714f81994dbff0ed17d790bda41283/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-02T19:32:39+08:00" />
<meta property="article:modified_time" content="2023-03-02T19:32:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【DR_CAN-MPC学习笔记】3&amp;4.详细的MPC建模例子和matlab代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一篇博客：<a class="link-info" href="https://blog.csdn.net/weixin_43470383/article/details/125883441?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125883441%22%2C%22source%22%3A%22weixin_43470383%22%7D&amp;ctrtid=fYfwL" title="【DR_CAN-MPC学习笔记】2.最优化数学建模推导">【DR_CAN-MPC学习笔记】2.最优化数学建模推导</a></p> 
<p>参照二次规划一般形式，详细推导了MPC的数学模型，即最小化代价函数的表达式，最终推导结果为：</p> 
<p style="text-align:center;"><img alt="gif.latex?J%3Dx_k%5ETGx_k&amp;plus;2x_k%5ETEU_k&amp;plus;U_k%5ETHU_k" class="mathcode" src="https://images2.imgbox.com/8b/f1/VRK0dI7Z_o.png"></p> 
<p>DR_CAN的视频：</p> 
<p>【MPC模型预测控制器】3_一个详细的建模例子</p> 
<div class="csdn-video-box"> 
 <iframe id="xClXuNtY-1659538940977" frameborder="0" src="https://player.bilibili.com/player.html?aid=975621520" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>【MPC模型预测控制器】3</p> 
</div> 
<p> 【MPC模型预测控制器】4_完整案例讲解 - Octave代码</p> 
<div class="csdn-video-box"> 
 <iframe id="iiQiaTQk-1659834434238" frameborder="0" src="https://player.bilibili.com/player.html?aid=597117364" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>【MPC模型预测控制器】4</p> 
</div> 
<p></p> 
<hr> 
<h2>离散系统状态空间一般形式：</h2> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20x%28k&amp;plus;1%29%3D%5Cboldsymbol%20A%20%5Cboldsymbol%20x%28k%29&amp;plus;%5Cboldsymbol%20B%20%5Cboldsymbol%20u%28k%29" class="mathcode" src="https://images2.imgbox.com/84/ce/thjQhKxq_o.png"></p> 
<p>其中 <img alt="gif.latex?x%28k%29" class="mathcode" src="https://images2.imgbox.com/ce/e7/1vWNaz3m_o.png"> 为状态向量（n×1），<img alt="gif.latex?u%28k%29" class="mathcode" src="https://images2.imgbox.com/5f/00/QYhTHek3_o.png"> 为输入向量（p×1），<img alt="gif.latex?A" class="mathcode" src="https://images2.imgbox.com/c8/17/gKMheIf0_o.png"> 为系统状态矩阵（n×n），<img alt="gif.latex?B" class="mathcode" src="https://images2.imgbox.com/f5/f2/zx0UfEVY_o.png"> 为系统输入矩阵（n×p）。</p> 
<p></p> 
<h2>单输入二阶系统的例子：</h2> 
<p style="text-align:center;"><img alt="gif.latex?%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20x_%7B1%7D%28k&amp;plus;1%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;1%29%20%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%200%20%26%202%20%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20x_%7B1%7D%28k%29%20%5C%5C%20x_%7B2%7D%28k%29%20%5Cend%7Barray%7D%5Cright%5D&amp;plus;%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%200%20%5C%5C%200.5%20%5Cend%7Barray%7D%5Cright%5D%20u%28k%29" class="mathcode" src="https://images2.imgbox.com/f1/a4/vO57Ob4J_o.png"></p> 
<p>上式中，<img alt="gif.latex?%5Cboldsymbol%20A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%200%20%26%202%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/10/91/wAo94cPi_o.png">，<img alt="gif.latex?%5Cboldsymbol%20B%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%200%20%5C%5C%200.5%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/af/7d/jmJlKcCB_o.png">，n = 2，p = 1</p> 
<p></p> 
<h2>系统状态向量和输入向量的关系：</h2> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20X_k%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%20x%28k%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;i%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;N%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D%2C%5Cboldsymbol%20U_k%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%20u%28k%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;i%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;N-1%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/a7/e9/Rb07B6bA_o.png"></p> 
<ul><li><img alt="gif.latex?x%28k&amp;plus;1%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/18/7f/KFGiGI0j_o.png"> 表示在k时刻预测 k＋1 时刻的系统状态。</li><li>由于 <img alt="gif.latex?x%28k%20&amp;plus;N%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/f6/93/Ie1HcbSH_o.png"> 由 <img alt="gif.latex?u%28k&amp;plus;N-1%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/3e/e7/u0jAUoJ4_o.png"> 决定，因此不需要 <img alt="gif.latex?u%28k&amp;plus;N%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/52/16/19Y2xCtP_o.png"> ，所以 <img alt="gif.latex?U_k" class="mathcode" src="https://images2.imgbox.com/9e/61/DvtL8bNY_o.png"> 比 <img alt="gif.latex?X_k" class="mathcode" src="https://images2.imgbox.com/d4/54/Vh5EbgXF_o.png"> 少一个维度。</li><li>因为初始值 <img alt="gif.latex?x%28k%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/8f/7e/pBKcmQYt_o.png"> 和 <img alt="gif.latex?x%28k&amp;plus;i%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/34/5a/klLuw8k8_o.png"> 均为 n×1 向量，因此 <img alt="gif.latex?X_k" class="mathcode" src="https://images2.imgbox.com/e9/f0/g1fas37m_o.png"> 为 (N+1)n×1 向量。同理可推出 <img alt="gif.latex?U_k" class="mathcode" src="https://images2.imgbox.com/99/04/bhHkRLvs_o.png"> 为 Np×1 向量。</li></ul> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%7BM%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%7BI%7D_%7Bn%20%5Ctimes%20n%7D%20%5C%5C%20%5Cboldsymbol%7BA%7D_%7Bn%20%5Ctimes%20n%7D%20%5C%5C%20%5Cboldsymbol%7BA%7D_%7Bn%20%5Ctimes%20n%7D%5E%7B2%7D%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%7BA%7D%5E%7BN%7D%20%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cboldsymbol%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%200%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cldots%20%26%20%5Cvdots%20%5C%5C%200%20%26%200%20%26%20%26%200%20%5C%5C%20%5Cboldsymbol%7BB%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%20B%7D%20%26%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%7D%5E%7BN-1%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cboldsymbol%7BA%7D%5E%7BN-2%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%20%5Cboldsymbol%7BB%7D%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/8f/43/6EuVWC5k_o.png"></p> 
<ul><li><img alt="gif.latex?M" class="mathcode" src="https://images2.imgbox.com/c3/95/tYlrsHDt_o.png"> 为 (N+1)n×n 矩阵。</li><li><img alt="gif.latex?C" class="mathcode" src="https://images2.imgbox.com/ff/4d/zCadyLOs_o.png"> 矩阵上面所有的 0 与初始状态 <img alt="gif.latex?x%28k%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/92/fa/UNofT8C2_o.png"> 有关（n×1矩阵），<img alt="gif.latex?B%2CAB...A%5E%7BN-1%7DB" class="mathcode" src="https://images2.imgbox.com/81/40/wSpOZAMg_o.png"> 均为 n×p 矩阵，因此 <img alt="gif.latex?C" class="mathcode" src="https://images2.imgbox.com/c5/53/GzNOD54o_o.png"> 为 (N+1)n×Np 矩阵。</li></ul> 
<p>具体可参考上一篇博客的推导（<a class="link-info" href="https://blog.csdn.net/weixin_43470383/article/details/125883441?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125883441%22%2C%22source%22%3A%22weixin_43470383%22%7D&amp;ctrtid=fYfwL" title="【DR_CAN-MPC学习笔记】2.最优化数学建模推导">【DR_CAN-MPC学习笔记】2.最优化数学建模推导</a>）：</p> 
<p><img alt="257f713d8284457f80484c23c347319c.png" src="https://images2.imgbox.com/57/2c/lvrPuKEk_o.png"></p> 
<h2>分析过程：</h2> 
<p>回到单输入二阶系统的例子，<img alt="gif.latex?%5Cboldsymbol%20A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%200%20%26%202%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/24/f9/JYP5z1Oj_o.png">，<img alt="gif.latex?%5Cboldsymbol%20B%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%200%20%5C%5C%200.5%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/20/f9/3dCT1cxW_o.png">，n = 2，p = 1，假设预测区间 N=3 ，</p> 
<p>整理一下维度：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;vertical-align:middle;"><img alt="gif.latex?X_k" src="https://images2.imgbox.com/0f/1b/9E82D0o3_o.png"></td><td style="text-align:center;vertical-align:middle;">=</td><td style="text-align:center;vertical-align:middle;"><img alt="gif.latex?M" src="https://images2.imgbox.com/3a/dd/nV3zEl6f_o.png"></td><td style="text-align:center;vertical-align:middle;"><img alt="gif.latex?x_k" src="https://images2.imgbox.com/03/13/xyf2oMly_o.png"></td><td style="text-align:center;vertical-align:middle;">+</td><td style="text-align:center;vertical-align:middle;"><img alt="gif.latex?C" src="https://images2.imgbox.com/bb/d4/E85SpjN6_o.png"></td><td style="text-align:center;vertical-align:middle;"><img alt="gif.latex?U_k" src="https://images2.imgbox.com/aa/b4/AeTkO1Jk_o.png"></td></tr><tr><td style="text-align:center;vertical-align:middle;">(N+1)n×1</td><td style="text-align:center;vertical-align:middle;">=</td><td style="text-align:center;vertical-align:middle;">(N+1)n×n</td><td style="text-align:center;vertical-align:middle;">n×1</td><td style="text-align:center;vertical-align:middle;">+</td><td style="text-align:center;vertical-align:middle;">(N+1)n×Np</td><td style="text-align:center;vertical-align:middle;">Np×1</td></tr><tr><td style="text-align:center;vertical-align:middle;">8×1</td><td style="text-align:center;vertical-align:middle;">=</td><td style="text-align:center;vertical-align:middle;">8×2</td><td style="text-align:center;vertical-align:middle;">2×1</td><td style="text-align:center;vertical-align:middle;">+</td><td style="text-align:center;vertical-align:middle;">8×3</td><td style="text-align:center;vertical-align:middle;">3×1</td></tr></tbody></table> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%7BX%7D%28k%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%20x%28k%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;2%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20x%28k&amp;plus;3%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20x_%7B1%7D%28k%20%5Cmid%20k%29%20%5C%5C%20x_%7B2%7D%28k%20%5Cmid%20k%29%20%5C%5C%20x_%7B1%7D%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20x_%7B1%7D%28k&amp;plus;2%20%5Cmid%20k%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;2%20%5Cmid%20k%29%20%5C%5C%20x_%7B1%7D%28k&amp;plus;3%20%5Cmid%20k%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;3%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/a9/51/SEqdCahF_o.png"></p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%7BU%7D%28k%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%20u%28k%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;2%20%5Cmid%20k%29%20%5C%5C%20%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20u%28k%20%5Cmid%20k%29%20%5C%5C%20u%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20u%28k&amp;plus;2%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/9b/f7/2WVoNSPE_o.png"></p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20M%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bcccc%7D%20%5Cboldsymbol%20I_%7B2%5Ctimes%202%7D%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%5E2%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%5E3%20%5C%5C%20%5Cend%7Barray%7D%20%5Cright%5D%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bcccccccc%7D%201%261%20%5C%5C%201%261%20%5C%5C%201%260.1%20%5C%5C0%262%20%5C%5C%201%260.3%20%5C%5C0%264%20%5C%5C%201%260.7%20%5C%5C0%268%20%5C%5C%5Cend%7Barray%7D%20%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/fe/96/aFe8YqJx_o.png"></p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%200%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cldots%20%26%20%5Cvdots%20%5C%5C%200%20%26%200%20%26%20%26%200%20%5C%5C%20%5Cboldsymbol%7BB%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%7D%5E%7BN-1%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cboldsymbol%7BA%7D%5E%7BN-2%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%20%5Cboldsymbol%7BB%7D%20%5Cend%7Barray%7D%5Cright%5D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%20%5Cboldsymbol%20B%20%26%200%20%26%200%20%5C%5C%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%20B%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%5E2B%7D%20%26%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%20B%20%5Cend%7Barray%7D%5Cright%5D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%200.5%20%26%200%20%26%200%20%5C%5C%200.05%20%26%200%20%26%200%20%5C%5C%201%20%26%200.5%20%26%200%20%5C%5C%200.15%20%26%200.05%20%26%200%20%5C%5C%202%20%26%201%20%26%200.5%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/73/da/cAc6admy_o.png"></p> 
<p>对于系统输出方程： <img alt="gif.latex?y%3Dx" class="mathcode" src="https://images2.imgbox.com/d3/b6/LsUgL0OQ_o.png"> ，参考值 <img alt="gif.latex?R%27%3D0" class="mathcode" src="https://images2.imgbox.com/de/06/SsznGkHM_o.png"> ，误差 <img alt="gif.latex?E%27%3Dy-R%27%3Dx-0%3Dx" class="mathcode" src="https://images2.imgbox.com/e0/02/7OoWtWwm_o.png"> ，代价函数为：</p> 
<p><img alt="gif.latex?%5Cboldsymbol%20J%3D%5Csum_%7Bi%3D0%7D%5E%7BN-1%7D%5Cleft%28%5Cboldsymbol%20x%28k&amp;plus;i%20%5Cmid%20k%29%5E%7BT%7D%20%5Cboldsymbol%20Q%20%5Cboldsymbol%20x%28k&amp;plus;i%20%5Cmid%20k%29&amp;plus;%5Cboldsymbol%20u%28k&amp;plus;i%20%5Cmid%20k%29%5E%7BT%7D%20%5Cboldsymbol%20R%20%5Cboldsymbol%20u%28k&amp;plus;i%20%5Cmid%20k%29&amp;plus;%5Cboldsymbol%20x%28k&amp;plus;N%20%5Cmid%20k%29%5E%7BT%7D%20%5Cboldsymbol%20F%20%5Cboldsymbol%20x%28k&amp;plus;N%20%5Cmid%20k%29%5Cright%29" class="mathcode" src="https://images2.imgbox.com/9e/ad/V5SC2YYh_o.png"></p> 
<p>代价函数 = <img alt="gif.latex?x%28k&amp;plus;i%20%5Cmid%20k%29%5E%7BT%7D%20Q%20x%28k&amp;plus;i%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/ed/a7/SS0AJd6C_o.png"><strong> 误差加权和</strong> + <img alt="gif.latex?u%28k&amp;plus;i%20%5Cmid%20k%29%5E%7BT%7D%20R%20u%28k&amp;plus;i%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/9f/0b/lN1dZzxc_o.png"><strong> 输入加权和</strong> + <img alt="gif.latex?x%28k&amp;plus;N%20%5Cmid%20k%29%5E%7BT%7D%20F%20x%28k&amp;plus;N%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/3f/fe/WpEfjuji_o.png"><strong> 终端误差</strong>，其中 <img alt="gif.latex?Q" class="mathcode" src="https://images2.imgbox.com/86/01/U6BfXq1t_o.png"> 和 <img alt="gif.latex?R" class="mathcode" src="https://images2.imgbox.com/72/c5/Fcivy01v_o.png"> 为权重系数矩阵且均为对角矩阵。</p> 
<p>经过简化后消去变量 <img alt="gif.latex?X_k" class="mathcode" src="https://images2.imgbox.com/c8/fc/JBXwSOxF_o.png"> （简化过程参考<a class="link-info" href="https://blog.csdn.net/weixin_43470383/article/details/125883441?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125883441%22%2C%22source%22%3A%22weixin_43470383%22%7D&amp;ctrtid=fYfwL" title="【DR_CAN-MPC学习笔记】2.最优化数学建模推导">【DR_CAN-MPC学习笔记】2.最优化数学建模推导</a>）：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20J%3D%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20G%20%5Cboldsymbol%20x_k&amp;plus;2%20%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20E%20%5Cboldsymbol%20U_k&amp;plus;%20%5Cboldsymbol%20U_k%5ET%20%5Cboldsymbol%20H%20%5Cboldsymbol%20U_k" class="mathcode" src="https://images2.imgbox.com/a1/6c/t1JCEUnn_o.png"></p> 
<p>由上式可见，<img alt="gif.latex?J" class="mathcode" src="https://images2.imgbox.com/70/7e/a2Tp2vwE_o.png"> 只包含了初始状态项 <img alt="gif.latex?x_k" class="mathcode" src="https://images2.imgbox.com/86/00/c19UR9bL_o.png"> 和输入项 <img alt="gif.latex?U_k" class="mathcode" src="https://images2.imgbox.com/4b/80/QzQCotu1_o.png"> ，对 <img alt="gif.latex?J" class="mathcode" src="https://images2.imgbox.com/68/3c/etw3kMuX_o.png"> 进行最优化可以得到输入项 <img alt="gif.latex?U_k" class="mathcode" src="https://images2.imgbox.com/4d/4e/yI9WYFzz_o.png"> 。</p> 
<p>矩阵 <img alt="gif.latex?G%2CE%2CH" class="mathcode" src="https://images2.imgbox.com/3d/eb/dRnHxYJL_o.png"> 与 <img alt="gif.latex?M%2CC" class="mathcode" src="https://images2.imgbox.com/75/a2/IzZHjR9Y_o.png"> 有关：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cbegin%7Baligned%7D%20%5Cboldsymbol%7BG%7D%20%26%3D%5Cboldsymbol%7BM%7D%5E%7BT%7D%20%5Cbar%7B%20%5Cboldsymbol%20Q%7D%20%5Cboldsymbol%20M%20%5C%5C%20%5Cboldsymbol%20E%20%26%3D%5Cboldsymbol%20M%5E%7BT%7D%20%5Cbar%7B%20%5Cboldsymbol%20Q%7D%20%5Cboldsymbol%20C%5C%5C%20%5Cboldsymbol%20H%20%26%3D%20%5Cboldsymbol%20C%5E%7BT%7D%20%5Cbar%7B%20%5Cboldsymbol%20Q%7D%20%5Cboldsymbol%20C&amp;plus;%5Cbar%7B%20%5Cboldsymbol%20R%7D%20%5Cend%7Baligned%7D" class="mathcode" src="https://images2.imgbox.com/05/f5/fBUGvn92_o.png"></p> 
<p> 其中 <img alt="gif.latex?%5Cbar%20Q" class="mathcode" src="https://images2.imgbox.com/55/fc/JLLv28YH_o.png"> 和 <img alt="gif.latex?%5Cbar%20R" class="mathcode" src="https://images2.imgbox.com/ea/a0/1uYChq2i_o.png"> 是原来两个权重矩阵 <img alt="gif.latex?Q" class="mathcode" src="https://images2.imgbox.com/1a/de/qzTXIX0o_o.png"> 和 <img alt="gif.latex?R" class="mathcode" src="https://images2.imgbox.com/2f/64/BRt9EHcm_o.png"> 的增广形式：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cbar%7BQ%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%20Q%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%200%20%26%20Q%20%26%20%5Ccdots%20%26%200%5C%5C%20%5Cvdots%20%26%20%26%20%5Cddots%20%26%20%5Cvdots%5C%5C%200%20%26%200%20%26%20%5Ccdots%20%26%20F%20%5Cend%7Barray%7D%5Cright%5D%2C%5Cbar%7BR%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%20R%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%200%20%26%20R%20%26%20%5Ccdots%20%26%200%5C%5C%20%5Cvdots%20%26%20%26%20%5Cddots%20%26%20%5Cvdots%5C%5C%200%20%26%200%20%26%20%5Ccdots%20%26%20R%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/89/26/4xjefU4F_o.png"></p> 
<p>矩阵计算较为复杂，可用编程求解。</p> 
<h2>例子代码：</h2> 
<p><img alt="gif.latex?%5Cboldsymbol%20x%28k&amp;plus;1%29%3D%5Cboldsymbol%20A%20%5Cboldsymbol%20x%28k%29&amp;plus;%5Cboldsymbol%20B%20%5Cboldsymbol%20u%28k%29" class="mathcode" src="https://images2.imgbox.com/47/eb/eNTolHG9_o.png"></p> 
<p>控制目标：设计合适的 <img alt="gif.latex?u%28k%29" class="mathcode" src="https://images2.imgbox.com/1e/5b/xeOh6RJ9_o.png"> 使得 <img alt="gif.latex?x%28k&amp;plus;1%29" class="mathcode" src="https://images2.imgbox.com/1b/47/lUgIr9sX_o.png"> 随着 <img alt="gif.latex?k" class="mathcode" src="https://images2.imgbox.com/ed/1b/8o5Y8eEQ_o.png"> 的增加，趋近于0。引入误差 <img alt="gif.latex?e" class="mathcode" src="https://images2.imgbox.com/4f/20/KKJdZxT8_o.png"> ：</p> 
<p style="text-align:center;"><img alt="gif.latex?e%3Dx_d-x_%7Bk&amp;plus;1%7D" class="mathcode" src="https://images2.imgbox.com/b4/34/5wh1vgKA_o.png"></p> 
<p><img alt="gif.latex?x_d" class="mathcode" src="https://images2.imgbox.com/ea/62/wBZNCWKr_o.png"> 为目标值，控制目标为令误差接近0。</p> 
<p>状态矩阵（n×k）：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20X_K%3D%5B%5Cboldsymbol%20x%280%29%2C%5Cboldsymbol%20x%281%29%2C%5Cboldsymbol%20x%282%29...%5Cboldsymbol%20x%28k%29%5D" class="mathcode" src="https://images2.imgbox.com/44/78/YbzGd3M3_o.png"></p> 
<p><img alt="gif.latex?%5Cboldsymbol%20x%281%29%3Ax_1%281%29%2Cx_2%281%29...x_n%281%29" class="mathcode" src="https://images2.imgbox.com/84/44/4SmtMgjN_o.png"></p> 
<p>...</p> 
<p><img alt="gif.latex?%5Cboldsymbol%20x%28k%29%3Ax_1%28k%29%2Cx_2%28k%29...x_n%28k%29" class="mathcode" src="https://images2.imgbox.com/59/66/jGUwmS5R_o.png"></p> 
<p>输入矩阵（p×k）：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20U_K%3D%5B%5Cboldsymbol%20u%280%29%2C%5Cboldsymbol%20u%281%29%2C%5Cboldsymbol%20u%282%29...%5Cboldsymbol%20u%28k%29%5D" class="mathcode" src="https://images2.imgbox.com/6e/a0/Oge3nVp4_o.png"></p> 
<p><img alt="gif.latex?%5Cboldsymbol%20u%281%29%3Au_1%281%29%2Cu_2%281%29...u_p%281%29" class="mathcode" src="https://images2.imgbox.com/dc/c7/hDzgP15L_o.png"></p> 
<p>...</p> 
<p><img alt="gif.latex?%5Cboldsymbol%20u%28k%29%3Au_1%28k%29%2Cu_2%28k%29...u_p%28k%29" class="mathcode" src="https://images2.imgbox.com/2a/d0/ZixfN0z2_o.png"></p> 
<p>状态方程：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20X_K%28%3A%2Ck&amp;plus;1%29%3D%28%5Cboldsymbol%20A*%5Cboldsymbol%20X_K%28%3A%2Ck%29&amp;plus;%5Cboldsymbol%20B%20*%20%5Cboldsymbol%20U_K%28%3A%2Ck%29%29%3B" class="mathcode" src="https://images2.imgbox.com/14/29/Z4OAnVex_o.png"></p> 
<p>例如：k=1 时，<img alt="gif.latex?X_K%28%3A%2C2%29" class="mathcode" src="https://images2.imgbox.com/1a/e3/XReS7yP1_o.png"> 表示第2列 <img alt="gif.latex?x_1%282%29%2Cx_2%282%29...x_n%282%29" class="mathcode" src="https://images2.imgbox.com/a0/5c/OwQb8wPA_o.png"></p> 
<p>回到单输入二阶系统的例子：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cbegin%7Barray%7D%7Bc%7D%20%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20x_%7B1%7D%28k&amp;plus;1%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;1%29%20%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%200%20%26%202%20%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20x_%7B1%7D%28k%29%20%5C%5C%20x_%7B2%7D%28k%29%20%5Cend%7Barray%7D%5Cright%5D&amp;plus;%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%200%20%5C%5C%200.5%20%5Cend%7Barray%7D%5Cright%5D%20u%28k%29%7D%20%5Cend%7Barray%7D" class="mathcode" src="https://images2.imgbox.com/e7/34/iwBI6M1q_o.png"></p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%7BQ%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%201%20%26%200%20%5C%5C%200%20%26%201%20%5Cend%7Barray%7D%5Cright%29%20%5Cquad%20%5Cboldsymbol%7BF%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%201%20%26%200%20%5C%5C%200%20%26%201%20%5Cend%7Barray%7D%5Cright%29%20%5Cquad%20%5Cboldsymbol%7BR%7D%3D0.1" class="mathcode" src="https://images2.imgbox.com/62/21/soQHURsQ_o.png"></p> 
<p>  <img alt="gif.latex?Q" class="mathcode" src="https://images2.imgbox.com/ed/20/H0QboarU_o.png"> 为系统状态变量权重矩阵， <img alt="gif.latex?R" class="mathcode" src="https://images2.imgbox.com/0a/09/aus1DWPr_o.png"> 为系统输入变量权重矩阵，<img alt="gif.latex?F" class="mathcode" src="https://images2.imgbox.com/a5/83/TpghvWPZ_o.png"> 为终端权重矩阵。</p> 
<p></p> 
<p>DR_CAN给出了Octave代码，在Matlab中也可以运行。下面的代码是我在此基础上修改后的单输入例子的代码，后面也有介绍如何修改为多输入系统。</p> 
<p>传送门：（二输入系统）<a class="link-info" href="https://www.bilibili.com/read/cv16891782" rel="nofollow" title="【MPC模型预测控制器】4_Octave代码">【MPC模型预测控制器】4_Octave代码</a></p> 
<p>代码一共由三个部分组成，分别为主程序：MPC_Test.m，以及两个函数：MPC_Matrices.m和Prediction.m</p> 
<h3>MPC_Test.m</h3> 
<p>设置初始参数：</p> 
<p> <img alt="gif.latex?%5Cboldsymbol%20A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%200%20%26%202%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/7a/e9/ZQN2lRrv_o.png">，<img alt="gif.latex?%5Cboldsymbol%20B%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%200%20%5C%5C%200.5%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/3e/ba/ge1ggJAq_o.png">...</p> 
<pre><code>%% 清屏
clear; 
close all; 
clc;

%% 加载 optim package,若使用matlab，则注释掉此行
pkg load optim;

%% 第一步，定义状态空间矩阵
%% 定义状态矩阵 A, n x n 矩阵
A = [1 0.1; 0 2];
n= size (A,1); % 计算矩阵第一个维度的长度

%% 定义输入矩阵 B, n x p 矩阵
B = [0; 0.5];
p = size(B,2); % 计算矩阵第二个维度的长度

%% 定义Q矩阵，n x n 矩阵
Q=[1 0; 0 1];

%% 定义F矩阵，n x n 矩阵
F=[1 0; 0 1];

%% 定义R矩阵，p x p 矩阵
R=[0.1];

%% 定义step数量k
k_steps=100; 

%% 定义矩阵 X_K， n x k 矩 阵
X_K=zeros(n,k_steps);

%% 初始状态变量值， n x 1 向量
X_K(:,1)=[20;-20]; % 初始状态不为0，控制目标为0

%% 定义输入矩阵 U_K， p x k 矩阵
U_K=zeros(p,k_steps);

%% 定义预测区间K
N=5;

%% Call MPC_Matrices 函数 求得 E,H矩阵 
[E,H]=MPC_Matrices(A,B,Q,R,F,N);

%% 计算每一步的状态变量的值
for k = 1 : k_steps 
%% 求得U_K(:,k)
U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);
%% 计算第k+1步时状态变量的值
X_K(:,k+1)=(A*X_K(:,k)+B*U_K(:,k));
end

%% 绘制状态变量和输入的变化
subplot(2, 1, 1);
hold;
for i =1 :size (X_K,1)
plot(X_K(i,:));
end
legend("x1","x2")
hold off;
subplot(2, 1, 2);
hold;
for i =1 : size(U_K,1)
plot(U_K(i,:));
end
legend("u1") 

%% 作者：DR_CAN https://www.bilibili.com/read/cv16891782 出处：bilibili</code></pre> 
<h4>分析：</h4> 
<p>注释掉以下行，即输入设为0，可单独运行：</p> 
<pre><code>N=5;
[E,H]=MPC_Matrices(A,B,Q,R,F,N);
U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</code></pre> 
<p>得到：</p> 
<p><img alt="76ebac27960a46b1997e0ca9454d266c.png" src="https://images2.imgbox.com/2d/8e/l1ZL01Jx_o.png"></p> 
<p></p> 
<p>由上图可见，<img alt="gif.latex?x_1%2Cx_2" class="mathcode" src="https://images2.imgbox.com/6b/a3/DN2gvT6q_o.png"> 均趋于无穷，因为初始状态不为0且输入为0.</p> 
<p>接下来设置合适的输入使得状态值趋于0.</p> 
<p>代价函数：</p> 
<p><img alt="gif.latex?%5Cboldsymbol%20J%3D%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20G%20%5Cboldsymbol%20x_k&amp;plus;2%20%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20E%20%5Cboldsymbol%20U_k&amp;plus;%20%5Cboldsymbol%20U_k%5ET%20%5Cboldsymbol%20H%20%5Cboldsymbol%20U_k" class="mathcode" src="https://images2.imgbox.com/e5/d9/Mq5h2dKo_o.png"></p> 
<p><img alt="gif.latex?%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20G%20%5Cboldsymbol%20x" class="mathcode" src="https://images2.imgbox.com/3e/31/SpSj2iRB_o.png"> 与初始状态有关，不影响代价函数，因此控制目标为最小化 <img alt="gif.latex?2%20%5Cboldsymbol%20x_k%5ET%20%5Cboldsymbol%20E%20%5Cboldsymbol%20U_k&amp;plus;%20%5Cboldsymbol%20U_k%5ET%20%5Cboldsymbol%20H%20%5Cboldsymbol%20U_k" class="mathcode" src="https://images2.imgbox.com/05/46/9J6FaSgd_o.png"> .</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cboldsymbol%20U_k%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%5Cboldsymbol%20u%28k%20%5Cmid%20k%29%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;1%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;i%20%5Cmid%20k%29%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cboldsymbol%20u%28k&amp;plus;N-1%20%5Cmid%20k%29%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/f0/6c/nxKMyhOH_o.png"></p> 
<p>预测了N项，但结果只取第一项 <img alt="gif.latex?%5Cboldsymbol%20u%28k%20%5Cmid%20k%29" class="mathcode" src="https://images2.imgbox.com/81/3c/FS9FG9HQ_o.png"> .</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cbegin%7Baligned%7D%20%5Cboldsymbol%20E%20%26%3D%5Cboldsymbol%20M%5E%7BT%7D%20%5Cbar%7B%20%5Cboldsymbol%20Q%7D%20%5Cboldsymbol%20C%2C%20%5Cboldsymbol%20H%20%26%3D%20%5Cboldsymbol%20C%5E%7BT%7D%20%5Cbar%7B%20%5Cboldsymbol%20Q%7D%20%5Cboldsymbol%20C&amp;plus;%5Cbar%7B%20%5Cboldsymbol%20R%7D%20%5Cend%7Baligned%7D" class="mathcode" src="https://images2.imgbox.com/7f/95/upkYYPQj_o.png"></p> 
<p>矩阵 <img alt="gif.latex?C%2CM%2CQ%2CR" class="mathcode" src="https://images2.imgbox.com/d5/bf/QRdmJzvX_o.png"> 在之前已经分析过了：</p> 
<p><img alt="gif.latex?%5Cboldsymbol%20M%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bcccc%7D%20%5Cboldsymbol%20I_%7B2%5Ctimes%202%7D%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%5E2%20%5C%5C%20%5Cboldsymbol%20A_%7B2%5Ctimes%202%7D%5E3%20%5C%5C%20%5Cend%7Barray%7D%20%5Cright%5D%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bcccccccc%7D%201%261%20%5C%5C%201%261%20%5C%5C%201%260.1%20%5C%5C0%262%20%5C%5C%201%260.3%20%5C%5C0%264%20%5C%5C%201%260.7%20%5C%5C0%268%20%5C%5C%5Cend%7Barray%7D%20%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/51/01/wS1PLzwu_o.png"></p> 
<p><img alt="gif.latex?%5Cbar%7BQ%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%20Q%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%200%20%26%20Q%20%26%20%5Ccdots%20%26%200%5C%5C%20%5Cvdots%20%26%20%26%20%5Cddots%20%26%20%5Cvdots%5C%5C%200%20%26%200%20%26%20%5Ccdots%20%26%20F%20%5Cend%7Barray%7D%5Cright%5D%2C%5Cbar%7BR%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%20R%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%200%20%26%20R%20%26%20%5Ccdots%20%26%200%5C%5C%20%5Cvdots%20%26%20%26%20%5Cddots%20%26%20%5Cvdots%5C%5C%200%20%26%200%20%26%20%5Ccdots%20%26%20R%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/eb/d5/aNv1xUUU_o.png"></p> 
<p><img alt="gif.latex?%5Cboldsymbol%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%200%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cldots%20%26%20%5Cvdots%20%5C%5C%200%20%26%200%20%26%20%26%200%20%5C%5C%20%5Cboldsymbol%7BB%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%200%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%7D%5E%7BN-1%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cboldsymbol%7BA%7D%5E%7BN-2%7D%20%5Cboldsymbol%7BB%7D%20%26%20%5Cldots%20%26%20%5Cboldsymbol%7BB%7D%20%5Cend%7Barray%7D%5Cright%5D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%20%5Cboldsymbol%20B%20%26%200%20%26%200%20%5C%5C%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%20B%20%26%200%20%5C%5C%20%5Cboldsymbol%7BA%5E2B%7D%20%26%20%5Cboldsymbol%7BAB%7D%20%26%20%5Cboldsymbol%20B%20%5Cend%7Barray%7D%5Cright%5D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%200%20%26%200%20%26%200%20%5C%5C%200.5%20%26%200%20%26%200%20%5C%5C%200.05%20%26%200%20%26%200%20%5C%5C%201%20%26%200.5%20%26%200%20%5C%5C%200.15%20%26%200.05%20%26%200%20%5C%5C%202%20%26%201%20%26%200.5%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/3b/b4/H5XK1uwl_o.png"></p> 
<p>矩阵的计算用 <strong>MPC_Matrices</strong> 函数解决，即代码：</p> 
<pre><code>[E,H]=MPC_Matrices(A,B,Q,R,F,N);</code></pre> 
<p>功能：输入矩阵 A,B,Q,R,F 和预测区间 N ，输出矩阵 E,H。具体过程参考下面的 MPC_Matrices.m 文件。接下来进行预测：</p> 
<pre><code>U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</code></pre> 
<p></p> 
<h3>MPC_Matrices.m</h3> 
<pre><code>function  [E , H]=MPC_Matrices(A,B,Q,R,F,N)

n=size(A,1);   % A 是 n x n 矩阵, 得到 n
p=size(B,2);   % B 是 n x p 矩阵, 得到 p

M=[eye(n);zeros(N*n,n)]; % 初始化 M 矩阵. M 矩阵是 (N+1)n x n的， 
                         % 它上面是 n x n 个 "I", 这一步先把下半部
                         % 分写成 0 
C=zeros((N+1)*n,N*p); % 初始化 C 矩阵, 这一步令它有 (N+1)n x NP 个 0

% 定义M 和 C 
tmp=eye(n);  %定义一个n x n 的 I 矩阵

%　更新Ｍ和C
for i=1:N % 循环，i 从 1到 N
    rows =i*n+(1:n); %定义当前行数，从i x n开始，共n行 
    C(rows,:)=[tmp*B,C(rows-n, 1:end-p)]; %将c矩阵填满
    tmp= A*tmp; %每一次将tmp左乘一次A
    M(rows,:)=tmp; %将M矩阵写满
end 

% 定义Q_bar和R_bar
Q_bar = kron(eye(N),Q);
Q_bar = blkdiag(Q_bar,F);
R_bar = kron(eye(N),R); 

% 计算G, E, H
G=M'*Q_bar*M; % G: n x n
E=C'*Q_bar*M; % E: NP x n
H=C'*Q_bar*C+R_bar; % NP x NP 
end 

%%作者：DR_CAN https://www.bilibili.com/read/cv16891782 出处：bilibili</code></pre> 
<p></p> 
<h3>Prediction.m</h3> 
<pre><code>function u_k= Prediction(x_k,E,H,N,p)

U_k = zeros(N*p,1); % NP x 1
U_k = quadprog(H,E*x_k); % 求出代价函数最小时U_k的数值
u_k = U_k(1:p,1); % 取第一个结果

end 

%%作者：DR_CAN https://www.bilibili.com/read/cv16891782 出处：bilibili</code></pre> 
<h4>分析：</h4> 
<p>quadprog：matlab自带的最优化函数</p> 
<p><img alt="381a539c375e40f89ccd1cfe410e033e.png" src="https://images2.imgbox.com/7f/9a/sgJklOnC_o.png"></p> 
<p></p> 
<p>运行结果：</p> 
<p><img alt="7056c855bf9e487894e6a12bf8f214dc.png" src="https://images2.imgbox.com/7e/10/lyuEHFkp_o.png"></p> 
<p></p> 
<p></p> 
<p>由上图所示，状态值 <img alt="gif.latex?x_1%2Cx_2" class="mathcode" src="https://images2.imgbox.com/d8/e2/N7akteA8_o.png"> 趋于0.</p> 
<p>以上为单输入系统的例子。</p> 
<h3>二输入例子：</h3> 
<p>代码修改一下，也可以用于多输入，比如：</p> 
<p style="text-align:center;"><img alt="gif.latex?%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20x_%7B1%7D%28k&amp;plus;1%29%20%5C%5C%20x_%7B2%7D%28k&amp;plus;1%29%20%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%201%20%26%200.1%20%5C%5C%20-1%20%26%202%20%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20x_%7B1%7D%28k%29%20%5C%5C%20x_%7B2%7D%28k%29%20%5Cend%7Barray%7D%5Cright%5D&amp;plus;%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%200.2%20%26%201%20%5C%5C%200.5%20%26%202%20%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20u_%7B1%7D%28k%29%20%5C%5C%20u_%7B2%7D%28k%29%20%5Cend%7Barray%7D%5Cright%5D" class="mathcode" src="https://images2.imgbox.com/09/cc/BUaCM8uX_o.png"></p> 
<p>修改矩阵 A,B,R,Q,F,R ，使得 <img alt="gif.latex?x_1" class="mathcode" src="https://images2.imgbox.com/80/f0/Fko54k7f_o.png"> 变化得更快（通过对矩阵Q的设置），且降低能耗减小 <img alt="gif.latex?u_1" class="mathcode" src="https://images2.imgbox.com/6a/95/XNwzp6fy_o.png"> 初始值（系统的输入一般是耗能的部分，通过对矩阵R的设置）</p> 
<p>修改后的 MPC_Test.m：（其余不变）</p> 
<pre><code>%% 清屏
clear; 
close all; 
clc;

%% 加载 optim package,若使用matlab，则注释掉此行
% pkg load optim;

%% 第一步，定义状态空间矩阵
%% 定义状态矩阵 A, n x n 矩阵
% A = [1 0.1; 0 2];
A = [1 0.1; -1 2];
n= size (A,1); % 计算矩阵维度

%% 定义输入矩阵 B, n x p 矩阵
% B = [0; 0.5];
B=[0.2 1; 0.5 2];
p = size(B,2);

%% 定义Q矩阵，n x n 矩阵
% Q=[1 0; 0 1];
Q=[100 0; 0 1]; % 更加看重x_1的变化

%% 定义F矩阵，n x n 矩阵
% F=[1 0; 0 1];
F=[100 0; 0 1];

%% 定义R矩阵，p x p 矩阵
% R=[0.1];
R=[1 0; 0 0.1]; % 减小能耗，减小输入u_1

%% 定义step数量k
k_steps=100; 

%% 定义矩阵 X_K， n x k 矩 阵
X_K = zeros(n,k_steps);

%% 初始状态变量值， n x 1 向量
X_K(:,1) =[20;-20];

%% 定义输入矩阵 U_K， p x k 矩阵
U_K=zeros(p,k_steps);

%% 定义预测区间K
N=5;

%% Call MPC_Matrices 函数 求得 E,H矩阵 
[E,H]=MPC_Matrices(A,B,Q,R,F,N);

%% 计算每一步的状态变量的值
for k = 1 : k_steps 
%% 求得U_K(:,k)
U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);
%% 计算第k+1步时状态变量的值
X_K(:,k+1)=(A*X_K(:,k)+B*U_K(:,k));
end

%% 绘制状态变量和输入的变化
subplot(2, 1, 1);
hold;
for i =1 :size (X_K,1)
plot(X_K(i,:));
end
legend("x1","x2")
hold off;
subplot(2, 1, 2);
hold;
for i =1 : size (U_K,1)
plot(U_K(i,:));
end
legend("u1","u2") 

%% 作者：DR_CAN https://www.bilibili.com/read/cv16891782 出处：bilibili</code></pre> 
<p></p> 
<p><img alt="95357d359de9448998812bd926199b2e.png" src="https://images2.imgbox.com/9b/fc/9A0NAiaC_o.png"></p> 
<p></p> 
<p>由上图所示，<img alt="gif.latex?x_1" class="mathcode" src="https://images2.imgbox.com/f2/be/488MDVfF_o.png"> 迅速趋近于0. 相比于 R=[0.1 0; 0 0.1] 时，R=[1 0; 0 0.1] 时的输入 <img alt="gif.latex?u_1" class="mathcode" src="https://images2.imgbox.com/a8/a8/cuEr6pck_o.png"> 减小，但 <img alt="gif.latex?x_1" class="mathcode" src="https://images2.imgbox.com/9d/e9/NrHVSj1B_o.png"> 趋近于0的速度变缓。由此也可以看出MPC的最优化的决策结果不是绝对的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d49624945c52ee4fcc9a1bcbf23c1af6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器被攻击进黑洞了怎么快速解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17b57772df577e40e47df513c6349135/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Set-Cookie:SameSite=Lax 问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>