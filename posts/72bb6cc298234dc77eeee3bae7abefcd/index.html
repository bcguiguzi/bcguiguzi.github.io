<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跟着Google学-Hilt - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跟着Google学-Hilt" />
<meta property="og:description" content="Hilt最详细教程 by google
1. 简介 在本 Codelab 中，您将了解在打造可靠且能够顺利发展为大型项目的应用时，依赖项注入 (DI) 的重要性。我们将使用 Hilt 作为依赖项注入工具来管理依赖项。
依赖项注入是一种在编程中运用广泛的技术，非常适用于 Android 开发。遵循依赖项注入的原则可以为良好的应用架构奠定基础。
实现依赖项注入可为您带来以下优势：
重用代码易于重构易于测试 Hilt 是 Android 颇具特色的依赖项注入库，可减少在项目中使用手动依赖项注入时产生的样板代码。手动依赖项注入要求您手动构造每个类及其依赖项，并借助容器来重复使用和管理依赖项。
Hilt 通过为项目中的每个 Android 组件提供容器并自动为您管理容器生命周期，提供了一种在应用中执行依赖项注入的标准方法。这通过利用热门依赖项注入库 Dagger 实现。
如果在此 Codelab 的操作过程中遇到任何问题（代码错误、语法错误、措辞含义不明等），欢迎通过 Codelab 左下角的“报告错误”链接向我们报告相应问题。
前提条件 您有 Kotlin 语法经验。您了解依赖项注入为什么对应用至关重要。 如需详细了解依赖项注入，请参阅以下资源：
依赖项注入基础知识Android 中的手动依赖项注入 学习内容 如何在 Android 应用中使用 Hilt。与打造可持续发展的应用相关的 Hilt 概念。如何使用限定符为同一类型添加多个绑定。如何使用 @EntryPoint 从 Hilt 不支持的类访问容器。如何使用单元测试和插桩测试来测试使用 Hilt 的应用。 所需条件 Android Studio 4.0 或更高版本。 2. 准备工作 获取代码 从 GitHub 获取 Codelab 代码：
$ git clone https://github.com/googlecodelabs/android-hilt" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/72bb6cc298234dc77eeee3bae7abefcd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T16:43:48+08:00" />
<meta property="article:modified_time" content="2024-03-12T16:43:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跟着Google学-Hilt</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Hilt_0"></a>Hilt最详细教程</h2> 
<p>by google<br> <img src="https://images2.imgbox.com/04/d5/X0OUjFi0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn0_4"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#0" rel="nofollow">1. 简介</a></h3> 
<p>在本 Codelab 中，您将了解在打造可靠且能够顺利发展为大型项目的应用时，<a href="https://developer.android.com/training/dependency-injection?hl=zh-cn" rel="nofollow">依赖项注入</a> (DI) 的重要性。我们将使用 Hilt 作为依赖项注入工具来管理依赖项。</p> 
<p>依赖项注入是一种在编程中运用广泛的技术，非常适用于 Android 开发。遵循依赖项注入的原则可以为良好的应用架构奠定基础。</p> 
<p>实现依赖项注入可为您带来以下优势：</p> 
<ul><li>重用代码</li><li>易于重构</li><li>易于测试</li></ul> 
<p>Hilt 是 Android 颇具特色的依赖项注入库，可减少在项目中使用手动依赖项注入时产生的样板代码。<a href="https://developer.android.com/training/dependency-injection/manual?hl=zh-cn" rel="nofollow">手动依赖项注入</a>要求您手动构造每个类及其依赖项，并借助容器来重复使用和管理依赖项。</p> 
<p>Hilt 通过为项目中的每个 Android 组件提供容器并自动为您管理容器生命周期，提供了一种在应用中执行依赖项注入的标准方法。这通过利用热门依赖项注入库 <a href="https://developer.android.com/training/dependency-injection/dagger-basics?hl=zh-cn" rel="nofollow">Dagger</a> 实现。</p> 
<p>如果在此 Codelab 的操作过程中遇到任何问题（代码错误、语法错误、措辞含义不明等），欢迎通过 Codelab 左下角的“报告错误”链接向我们报告相应问题。</p> 
<h3><a id="_22"></a>前提条件</h3> 
<ul><li>您有 Kotlin 语法经验。</li><li>您了解依赖项注入为什么对应用至关重要。</li></ul> 
<p>如需详细了解依赖项注入，请参阅以下资源：</p> 
<ol><li><a href="https://developer.android.com/training/dependency-injection?hl=zh-cn" rel="nofollow">依赖项注入基础知识</a></li><li><a href="https://developer.android.com/training/dependency-injection/manual?hl=zh-cn" rel="nofollow">Android 中的手动依赖项注入</a></li></ol> 
<h3><a id="_32"></a>学习内容</h3> 
<ul><li>如何在 Android 应用中使用 Hilt。</li><li>与打造可持续发展的应用相关的 Hilt 概念。</li><li>如何使用限定符为同一类型添加多个绑定。</li><li>如何使用 <code>@EntryPoint</code> 从 Hilt 不支持的类访问容器。</li><li>如何使用单元测试和插桩测试来测试使用 Hilt 的应用。</li></ul> 
<h3><a id="_40"></a>所需条件</h3> 
<ul><li>Android Studio 4.0 或更高版本。</li></ul> 
<h3><a id="2_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn1_45"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#1" rel="nofollow">2. 准备工作</a></h3> 
<h3><a id="_47"></a>获取代码</h3> 
<p>从 GitHub 获取 Codelab 代码：</p> 
<p>$ git clone https://github.com/googlecodelabs/android-hilt</p> 
<p>或者，您可以下载 Zip 文件形式的代码库：</p> 
<p><a href="https://github.com/googlecodelabs/android-hilt/archive/master.zip">下载 Zip 文件</a></p> 
<h3><a id="_Android_Studio_57"></a>打开 Android Studio</h3> 
<p>本 Codelab 需要 Android Studio 4.0 或更高版本。如果您需要下载 Android Studio，可以在<a href="https://developer.android.com/studio/?hl=zh-cn" rel="nofollow">此处</a>下载。</p> 
<h3><a id="_61"></a>运行示例应用</h3> 
<p>在本 Codelab 中，您将向<strong>记录用户互动</strong>并使用 <a href="https://developer.android.com/topic/libraries/architecture/room?hl=zh-cn" rel="nofollow">Room</a> 将数据存储到本地数据库的应用添加 Hilt。</p> 
<p>按照下列说明在 Android Studio 中打开示例应用。</p> 
<ul><li>如果您是下载的 zip 压缩档，请在本地解压缩文件。</li><li>在 Android Studio 中打开项目。</li><li>点击 <img src="https://images2.imgbox.com/09/c9/ITtnKPdh_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"> Run 按钮，然后选择模拟器或连接 Android 设备。</li></ul> 
<p><img src="https://images2.imgbox.com/6a/95/ro7rd2oa_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"> <img src="https://images2.imgbox.com/72/7f/9ty9n9BM_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p>如您所见，每当您与某个有编号的按钮互动时，系统都会创建并存储一条日志。在 <strong>See All Logs</strong> 屏幕中，您将看到之前所有互动的列表。如需移除日志，请点按 <strong>Delete Logs</strong> 按钮。</p> 
<h3><a id="_75"></a>项目设置</h3> 
<p>本项目在多个 GitHub 分支中构建：</p> 
<ul><li><code>master</code> 是您签出或下载的分支，也是本 Codelab 的起点。</li><li><code>solution</code> 包含本 Codelab 的解决方案。</li></ul> 
<p>建议您从 <code>master</code> 分支中的代码着手，按照自己的节奏逐步完成 Codelab。</p> 
<p>在本 Codelab 中，系统会为您显示需要添加到项目的代码段。在某些地方，您还需要移除代码，我们将在代码段的注释中明确标出这部分内容。</p> 
<p>如需使用 Git 获取 <code>solution</code> 分支，请使用以下命令：</p> 
<p><code>$ git clone -b solution https://github.com/googlecodelabs/android-hilt</code></p> 
<h3><a id="3__Hilt_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn2_91"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#2" rel="nofollow">3. 将 Hilt 添加到项目中</a></h3> 
<h3><a id="_Hilt_93"></a>为什么选择 Hilt？</h3> 
<p>如果您查看起始代码，会看到 <code>ServiceLocator</code> 类的一个实例存储在 <code>LogApplication</code> 类中。<code>ServiceLocator</code> 会创建并存储依赖项，供需要它的类按需获取。您可以将其视为依赖项的<strong>容器</strong>，这种容器附着于应用的生命周期，因为当应用不存在时它将随之销毁。</p> 
<p><strong>容器</strong>是一个类，负责在您的代码库中提供依赖项，并且知道如何为应用的其他类型创建实例。它通过创建依赖项并管理其生命周期来管理提供这些实例所需的依赖关系图。</p> 
<p>容器给出了一些方法，可用于获取它所提供的类型的实例。这些方法可能会始终返回不同的实例或相同的实例。如果方法始终提供相同的实例，则表明相应类型的<strong>作用域限定</strong>为容器。</p> 
<p>如 <a href="https://developer.android.com/training/dependency-injection?hl=zh-cn#choosing-right-di-tool" rel="nofollow">Android 依赖项注入指南</a>中所述，若使用服务定位器，一开始样板代码较少，但随着代码规模逐渐增长，会出现一些问题。如需开发大型 Android 应用，您应使用 Hilt。</p> 
<p>在 Android 应用中使用手动依赖项注入或服务定位器模式需要样板代码，而 Hilt 通过生成本应由您手动创建的代码（例如，<code>ServiceLocator</code> 类中的代码），消除了不必要的样板代码。</p> 
<p>如需详细了解<a href="https://developer.android.com/training/dependency-injection?hl=zh-cn" rel="nofollow">服务定位器模式</a>，请参阅关于在 Android 上实现依赖项注入的指南。</p> 
<p>在接下来的步骤中，您将使用 Hilt 来替换 <code>ServiceLocator</code> 类。然后，我们会为该项目添加新功能，以探索 Hilt 的更多功能。</p> 
<h3><a id="_Hilt_109"></a>在项目中使用 Hilt</h3> 
<p><strong>Hilt 已在</strong> <strong><code>master</code></strong> <strong>分支（您下载的代码）中进行配置</strong>。您无需将以下代码添加到项目中，因为我们已代您执行该操作。尽管如此，我们还是来看看在 Android 应用中使用 Hilt 需要做些什么。</p> 
<p>除了库依赖项之外，Hilt 还会使用在项目中配置的 Gradle 插件。打开根 <code>build.gradle</code> 文件，并在类路径中找到以下 Hilt 依赖项：</p> 
<pre><code>buildscript {
    ...
    ext.hilt_version = '2.28-alpha'
    dependencies {
        ...
        classpath "com.google.dagger:hilt-android-gradle-plugin:$hilt_version"
    }
}

</code></pre> 
<p>然后，为在 <code>app</code> 模块中使用 gradle 插件，我们应在 <code>app/build.gradle</code> 文件中指定它，具体方法为：将 gradle 插件添加到此文件的顶部、<code>kotlin-kapt</code> 插件之下：</p> 
<pre><code>...
apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'

android {
    ...
}
</code></pre> 
<p>最后，Hilt 依赖项会包含在项目的同一个 <code>app/build.gradle</code> 文件中：</p> 
<pre><code>...
dependencies {
    ...
    implementation "com.google.dagger:hilt-android:$hilt_version"
    kapt "com.google.dagger:hilt-android-compiler:$hilt_version"
}
</code></pre> 
<p>在您构建和同步项目时会下载包括 Hilt 在内的所有库。让我们开始使用 Hilt！</p> 
<h3><a id="4__Hilthttpsdeveloperandroidcomcodelabsandroidhilthlzhcn3_152"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#3" rel="nofollow">4. 在应用中使用 Hilt</a></h3> 
<p>与 <code>LogApplication</code> 类中 <code>ServiceLocator</code> 的实例的使用和初始化方式类似，要添加<strong>附着于应用的****生命周期的容器</strong>，我们需要为 <code>Application</code> 类添加 <code>@HiltAndroidApp</code> 注解。打开 <code>LogApplication.kt</code> 并为该类添加注解：</p> 
<pre><code>@HiltAndroidApp
class LogApplication : Application() {
    ...
}
</code></pre> 
<p><code>@HiltAndroidApp</code> 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类可使用依赖项注入。application 容器是应用的父级容器，这意味着其他容器可以访问它提供的依赖项。</p> 
<p>现在，应用已经可以开始使用 Hilt 了！</p> 
<h3><a id="5__Hilt_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn4_167"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#4" rel="nofollow">5. 使用 Hilt 实现字段注入</a></h3> 
<p>我们将使用 Hilt 提供依赖项，而不是从类的 <code>ServiceLocator</code> 中按需抓取依赖项。接下来，我们开始替换对类中 <code>ServiceLocator</code> 的调用。</p> 
<p>打开 <code>ui/LogsFragment.kt</code> 文件。<code>LogsFragment</code> 会在 <code>onAttach</code> 中填充其字段。我们可以使用 Hilt 来创建和管理 <code>LoggerLocalDataSource</code> 和 <code>DateFormatter</code> 的实例，而不是使用 <code>ServiceLocator</code> 手动填充这些类型的实例。</p> 
<p>如要让 <code>LogsFragment</code> 使用 Hilt，我们需要为其添加 <code>@AndroidEntryPoint</code> 注解。</p> 
<pre><code>@AndroidEntryPoint
class LogsFragment : Fragment() {
    ...
}
</code></pre> 
<p>为 Android 类添加 <code>@AndroidEntryPoint</code> 注解会创建一个沿袭 Android 类生命周期的依赖项容器。</p> 
<p>Hilt 目前支持以下 Android 类型：<code>Application</code>（通过使用 <code>@HiltAndroidApp</code>）、<code>Activity</code>、<code>Fragment</code>、<code>View</code>、<code>Service</code> 和 <code>BroadcastReceiver</code>。</p> 
<p>Hilt 仅支持扩展 <a href="https://developer.android.com/reference/androidx/fragment/app/FragmentActivity?hl=zh-cn" rel="nofollow"><code>FragmentActivity</code></a>（例如 <a href="https://developer.android.com/reference/kotlin/androidx/appcompat/app/AppCompatActivity?hl=zh-cn" rel="nofollow"><code>AppCompatActivity</code></a>）的 activity 和扩展 Jetpack 库 <code>Fragment</code> 的 fragment，不支持 Android 平台中的 <code>Fragment</code>（现已弃用）。</p> 
<p>警告：Hilt 不支持保留的 fragment。</p> 
<p>利用 <code>@AndroidEntryPoint</code>，Hilt 可创建附着于 <code>LogsFragment</code> 生命周期的依赖项容器，并能够将实例注入 <code>LogsFragment</code>。如何让 Hilt 进行字段注入？</p> 
<p>对于要进行注入的字段（例如 <code>logger</code> 和 <code>dateFormatter</code>），我们可以利用 <strong><code>@Inject</code></strong> <strong>注解****让 Hilt 注入不同类型的实例</strong>：</p> 
<pre><code>@AndroidEntryPoint
class LogsFragment : Fragment() {

    @Inject lateinit var logger: LoggerLocalDataSource
    @Inject lateinit var dateFormatter: DateFormatter

    ...
}
</code></pre> 
<p>这就是所谓的<strong>字段注入</strong>。</p> 
<p>如要执行字段注入，请对您希望由 Hilt 提供（或注入）的 Android 类字段使用 <code>@Inject</code> 注解。</p> 
<p>警告：由 Hilt 注入的字段不能是私有字段。</p> 
<p>由于 Hilt 将负责填充这些字段，因此我们不再需要 <code>populateFields</code> 方法。让我们从类中移除该方法：</p> 
<pre><code>@AndroidEntryPoint
class LogsFragment : Fragment() {

    // Remove following code from LogsFragment

    override fun onAttach(context: Context) {
        super.onAttach(context)

        populateFields(context)
    }

    private fun populateFields(context: Context) {
        logger = (context.applicationContext as LogApplication).serviceLocator.loggerLocalDataSource
        dateFormatter =
            (context.applicationContext as LogApplication).serviceLocator.provideDateFormatter()
    }

    ...
}
</code></pre> 
<p>在后台，Hilt 将使用自动生成的 <code>LogsFragment</code> 依赖项容器中内置的实例在 <code>onAttach()</code> 生命周期方法中填充这些字段。</p> 
<p>要详细了解 Android 类注入到了哪些生命周期回调，请参阅文档的<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-lifetimes" rel="nofollow">“组件生命周期”部分</a>。</p> 
<p>要执行字段注入，Hilt 需要知道如何提供这些依赖项的实例！在本例中，Hilt 需要知道如何提供 <code>LoggerLocalDataSource</code> 和 <code>DateFormatter</code> 的实例。但是，Hilt 还不知道如何提供这些实例。</p> 
<h3><a id="_Hilt__Inject__241"></a>告知 Hilt 如何通过 @Inject 提供依赖项</h3> 
<p>打开 <code>ServiceLocator.kt</code> 文件，以了解 <code>ServiceLocator</code> 是如何实现的。您可以看看为什么调用 <code>provideDateFormatter()</code> 总是返回 <code>DateFormatter</code> 的不同实例。</p> 
<p>这与我们希望通过 Hilt 实现的行为完全相同。幸运的是，<code>DateFormatter</code> 不依赖其他类，因此目前我们无需考虑传递依赖项。</p> 
<p><strong>如要告知 Hilt 如何提供类型的实例，请向要注入的类的构造函数添加 @Inject 注解</strong>。</p> 
<p>打开 <code>util/DateFormatter.kt</code> 文件并为 <code>DateFormatter</code> 的构造函数添加 <code>@Inject</code> 注解。请注意，要在 Kotlin 中为构造函数添加注解，您还需要 <code>constructor</code> 关键字：</p> 
<pre><code>class DateFormatter @Inject constructor() { ... }
</code></pre> 
<p>通过它，Hilt 便会知道如何提供 <code>DateFormatter</code> 的实例。需要针对 <code>LoggerLocalDataSource</code> 执行相同的操作。打开 <code>data/LoggerLocalDataSource.kt</code> 文件并为其构造函数添加 <code>@Inject</code> 注解：</p> 
<pre><code>class LoggerLocalDataSource @Inject constructor(private val logDao: LogDao) {
    ...
}

</code></pre> 
<p>Hilt 拥有的有关如何提供不同类型的实例的信息也称为<strong>绑定</strong>。</p> 
<p>目前，Hilt 有两个绑定：如何提供 1) <code>DateFormatter</code> 和 2) <code>LoggerLocalDataSource</code> 的实例。</p> 
<p>如果再次打开 <code>ServiceLocator</code> 类，可以看到有一个公开的 <code>LoggerLocalDataSource</code> 字段。这意味着，无论何时调用 <code>ServiceLocator</code>，它始终返回 <code>LoggerLocalDataSource</code> 的相同实例。这就是所谓的“<strong>将实例的作用域限定为容器</strong>”。在 Hilt 中如何实现这一点？</p> 
<h3><a id="6_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn5_270"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#5" rel="nofollow">6. 将实例的作用域限定为容器</a></h3> 
<p>我们可以使用注解将实例的作用域限定为容器。由于 Hilt 可以生成具有不同生命周期的不同容器，因此有不同的注解可用于将作用域限定为这些容器。</p> 
<p>将实例的作用域限定为 application 容器的注解是 <code>@Singleton</code>。该注解将使 application 容器始终提供相同的实例，无论相应类型是否用作其他类型的依赖项，也无论它是否需要字段注入。</p> 
<p>可以将同一逻辑应用到附着于 Android 类的所有容器。您可以在该<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-bindings" rel="nofollow">文档</a>中找到所有限定作用域的注解列表。例如，如果您希望 activity 容器始终提供某类型的相同实例，则可以为该类型添加 @<code>ActivityScoped</code> 注解。</p> 
<p>如上所述，由于我们希望 application 容器始终提供 <code>LoggerLocalDataSource</code> 的相同实例，因此为其类添加 <code>@Singleton</code> 注解：</p> 
<pre><code>@Singleton
class LoggerLocalDataSource @Inject constructor(private val logDao: LogDao) {
    ...
}
</code></pre> 
<p><strong>如果绑定在层次结构的较高层级中可用，那么在较低层级的容器中也可用</strong>。因此，如果 <code>LoggerLocalDataSource</code> 的某个实例在 application 容器中可用，那么它在 activity 和 fragment 容器中也可用。</p> 
<p>现在，Hilt 知道如何提供 <code>LoggerLocalDataSource</code> 实例了。但是，这一次，该类型具有传递依赖项！如要提供 <code>LoggerLocalDataSource</code> 实例，Hilt 还需要知道如何提供 <code>LogDao</code> 实例。</p> 
<p>不过，由于 <code>LogDao</code> 是一个接口，而接口没有构造函数，因此我们无法为其构造函数添加 <code>@Inject</code> 注解。该怎么告知 Hilt 如何提供该类型的实例？</p> 
<h3><a id="7_Hilt_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn6_293"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#6" rel="nofollow">7. Hilt 模块</a></h3> 
<p><strong>模块用于向 Hilt 添加绑定</strong>，换句话说，用于告知 Hilt 如何提供不同类型的实例。在 Hilt 模块中，您可以为<strong>无法通过构造函数注入的类型</strong>（例如接口或未包含在您项目中的类）添加绑定。这种类型的一个示例是 <code>OkHttpClient</code>，您需要使用其构建器来创建实例。</p> 
<p><strong>Hilt 模块是带有</strong>**<code>@Module</code>** <strong>和</strong> <strong><code>@InstallIn</code></strong> 注解的类。<code>@Module</code> 会告知 Hilt 这是一个模块，而 <code>@InstallIn</code> 会通过指定 Hilt 组件告知 Hilt 绑定在哪些容器中可用。您可以将 Hilt 组件视为容器，如需查看组件的完整列表，请点击<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#generated-components" rel="nofollow">此处</a>。</p> 
<p><strong>对于每个可被 Hilt 注入的 Android 类，都有一个关联的 Hilt 组件</strong>。例如，<code>Application</code> 容器与 <code>SingletonComponent</code> 相关联，而 <code>Fragment</code> 容器与 <code>FragmentComponent</code> 相关联。</p> 
<h3><a id="_301"></a>创建模块</h3> 
<p>我们来创建一个可添加绑定的 Hilt 模块。在 <code>hilt</code> 文件包下创建一个名为 <code>di</code> 的新文件包，并在该文件包中创建一个名为 <code>DatabaseModule.kt</code> 的新文件。</p> 
<p>由于 <code>LoggerLocalDataSource</code> 的作用域限定为 application 容器，因此 <code>LogDao</code> 绑定需要在 application 容器中可用。我们通过传递与其相关联的 Hilt 组件的类（即 <code>SingletonComponent:class</code>），使用 <code>@InstallIn</code> 注解指定该要求：</p> 
<pre><code>package com.example.android.hilt.di

@InstallIn(ApplicationComponent::class)
@Module
object DatabaseModule {

}

</code></pre> 
<p>在 <code>ServiceLocator</code> 类实现中，<code>LogDao</code> 的实例通过调用 <code>logsDatabase.logDao()</code> 来获取。因此，为了提供 LogDao 的实例，我们在 <code>AppDatabase</code> 类上创建了一个传递依赖项。</p> 
<p>在 Kotlin 中，仅包含 <code>@Provides</code> 函数的模块可以是 <code>object</code> 类。通过这种方式，提供程序会得到优化，并几乎内嵌到生成的代码中。</p> 
<h3><a id="_Provides__322"></a>使用 @Provides 提供实例</h3> 
<p>我们可以在 Hilt 模块中为函数添加 <code>@Provides</code> 注解，告知 Hilt 如何提供无法通过构造函数注入的类型。</p> 
<p>每当 Hilt 需要提供相应类型的实例时，都会执行带有 <code>@Provides</code> 注解的函数的函数主体。带有 <code>@Provides</code> 注解的函数的返回值类型会告知 Hilt 绑定的类型，即如何提供该类型的实例。函数参数是该类型的依赖项。</p> 
<p>在本例中，我们将此函数包含在 <code>DatabaseModule</code> 类中：</p> 
<pre><code>@Module
object DatabaseModule {

    @Provides
    fun provideLogDao(database: AppDatabase): LogDao {
        return database.logDao()
    }
}
</code></pre> 
<p>上述代码告知 Hilt 当提供 <code>LogDao</code> 的实例时需要执行 <code>database.logDao()</code>。由于我们将 <code>AppDatabase</code> 作为传递依赖项，因此还需要告知 Hilt 如何提供该类型的实例。</p> 
<p><code>AppDatabase</code> 类由 Room 生成，我们的项目也不拥有该类，因此我们也能够以类似于在 <code>ServiceLocator</code> 类中构建数据库实例的方式，使用 <code>@Provides</code> 函数提供它。</p> 
<pre><code>@Module
object DatabaseModule {

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext appContext: Context): AppDatabase {
        return Room.databaseBuilder(
            appContext,
            AppDatabase::class.java,
            "logging.db"
        ).build()
    }

    @Provides
    fun provideLogDao(database: AppDatabase): LogDao {
        return database.logDao()
    }
}
</code></pre> 
<p>由于我们希望 Hilt 始终提供相同的数据库实例，因此为 <code>@Provides provideDatabase</code> 方法添加了 <code>@Singleton</code> 注解。</p> 
<p>每个 Hilt 容器都随附一组默认绑定，可作为依赖项注入到您的自定义绑定。<code>applicationContext</code> 便是这样：要访问它，您需要为字段添加 <code>@ApplicationContext</code> 注解。</p> 
<p>如需查看预定义的绑定列表，请参阅<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-default" rel="nofollow">文档的这一页面</a>。</p> 
<h3><a id="_372"></a>运行应用</h3> 
<p>现在，Hilt 具有在 <code>LogsFragment</code> 中注入实例所需的全部信息。但是，在运行应用之前，Hilt 需要了解托管 <code>Fragment</code> 的 <code>Activity</code> 才能正常运作。我们需要为 <code>MainActivity</code> 添加 <code>@AndroidEntryPoint</code> 注解。</p> 
<p>打开 <code>ui/MainActivity.kt</code> 文件并为 <code>MainActivity</code> 添加 <code>@AndroidEntryPoint</code> 注解：</p> 
<pre><code>@AndroidEntryPoint
class MainActivity : AppCompatActivity() { ... }
</code></pre> 
<p>现在，您可以运行应用并检查一切是否可以像以前一样正常工作。</p> 
<p>我们来继续重构应用，以从 <code>MainActivity</code> 中移除 <code>ServiceLocator</code> 调用。</p> 
<h3><a id="8__Binds_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn7_387"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#7" rel="nofollow">8. 使用 @Binds 提供接口</a></h3> 
<p><code>MainActivity</code> 从调用 <code>provideNavigator(activity: FragmentActivity)</code> 函数的 <code>ServiceLocator</code> 中获取 <code>AppNavigator</code> 的实例。</p> 
<p>由于 <code>AppNavigator</code> 是一个接口，因此我们无法使用构造函数注入。<strong>要告知 Hilt 为接口使用哪种实现，您可以对 Hilt 模块内的函数使用</strong> <strong><code>@Binds</code></strong> <strong>注解</strong>。</p> 
<p>必须为抽象函数添加 <code>@Binds</code> 注解（它是抽象的，因此不包含任何代码，且该类也需要是抽象的）。抽象函数的返回值类型是我们要提供实现的接口（即 <code>AppNavigator</code>）。实现通过添加具有接口实现类型（即 <code>AppNavigatorImpl</code>）的唯一参数指定。</p> 
<p>我们可以向之前创建的 <code>DatabaseModule</code> 类中添加信息吗，或者我们需要新模块吗？应创建新模块的原因有多种：</p> 
<ul><li>为便于组织，模块的名称应体现它提供的信息类型。例如，在名为 <code>DatabaseModule</code> 的模块中添加导航绑定是没有意义的。</li><li><code>DatabaseModule</code> 模块安装在 <code>SingletonComponent</code> 中，因此绑定在 application 容器中可用。新导航信息（即 <code>AppNavigator</code>）需要特定于 Activity 的信息（因为 <code>AppNavigatorImpl</code> 将 <code>Activity</code> 作为依赖项）。因此，<strong>它必须安装在</strong> <strong><code>Activity</code></strong> <strong>容器中</strong>而不是 <code>Application</code> 容器中，因为关于 <code>Activity</code> 的信息位于前者之中。</li><li>Hilt 模块不能同时包含非静态和抽象绑定方法，因此您不能将 <code>@Binds</code> 和 <code>@Provides</code> 注解放在同一个类中。</li></ul> 
<p>在 <code>di</code> 文件夹中创建一个名为 <code>NavigationModule.kt</code> 的新文件。在该文件中，我们来创建一个名为 <code>NavigationModule</code> 的新抽象类，并为其添加 <code>@Module</code> 和 <code>@InstallIn(ActivityComponent::class)</code> 注解，如上所述：</p> 
<pre><code>@InstallIn(ActivityComponent::class)
@Module
abstract class NavigationModule {

    @Binds
    abstract fun bindNavigator(impl: AppNavigatorImpl): AppNavigator
}
</code></pre> 
<p>在该模块内，我们可以为 <code>AppNavigator</code> 添加绑定。一个抽象函数会返回我们告知 Hilt 的接口（即 <code>AppNavigator</code>），而函数参数是该接口的实现（即 <code>AppNavigatorImpl</code>）。</p> 
<p>现在，我们必须告知 Hilt 如何提供 <code>AppNavigatorImpl</code> 的实例。由于该类可以进行构造函数注入，因此我们只需为其构造函数添加 <code>@Inject</code> 注解。</p> 
<p>打开 <code>navigator/AppNavigatorImpl.kt</code> 文件，然后执行该操作：</p> 
<pre><code>class AppNavigatorImpl @Inject constructor(
    private val activity: FragmentActivity
) : AppNavigator {
    ...
}
</code></pre> 
<p><code>AppNavigatorImpl</code> 依赖于 <code>FragmentActivity</code>。由于 <code>AppNavigator</code> 实例在 <code>Activity</code> 容器（因为 <code>NavigationModule</code> 安装在 <code>ActivityComponent</code> 中，所以该实例也在 <code>Fragment</code> 容器和 <code>View</code> 中可用）中提供，<code>FragmentActivity</code> 以<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-default" rel="nofollow">预定义绑定</a>的形式提供，因此它已经可用。</p> 
<h3><a id="_Activity__Hilt_429"></a>在 Activity 中使用 Hilt</h3> 
<p>现在，Hilt 具有注入 <code>AppNavigator</code> 实例所需的全部信息。打开 <code>MainActivity.kt</code> 文件并执行以下操作：</p> 
<ol><li>为 <code>navigator</code> 字段添加 <code>@Inject</code> 注解，以供 Hilt 获取；</li><li>移除 <code>private</code> 可见性修饰符；并</li><li>移除 <code>onCreate</code> 函数中的 <code>navigator</code> 初始化代码。</li></ol> 
<p>新代码应如下所示：</p> 
<pre><code>@AndroidEntryPoint
class MainActivity : AppCompatActivity() {

    @Inject lateinit var navigator: AppNavigator

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        if (savedInstanceState == null) {
            navigator.navigateTo(Screens.BUTTONS)
        }
    }

    ...
}
</code></pre> 
<h3><a id="_458"></a>运行应用</h3> 
<p>您可以运行该应用，看看它是否按预期工作。</p> 
<h3><a id="_462"></a>完成重构</h3> 
<p>目前唯一仍在使用 <code>ServiceLocator</code> 提取依赖项的类是 <code>ButtonsFragment</code>。由于 Hilt 已经知道如何提供 <code>ButtonsFragment</code> 需要的所有类型，因此我们只需在该类中执行字段注入。</p> 
<p>正如我们之前所了解的，要让 Hilt 对该类进行字段注入，我们需要执行以下操作：</p> 
<ol><li>为 <code>ButtonsFragment</code> 添加 <code>@AndroidEntryPoint</code> 注解；</li><li>从 <code>logger</code> 和 <code>navigator</code> 字段中移除私有修饰符，并为其添加 <code>@Inject</code> 注解；</li><li>移除字段初始化代码（即 <code>onAttach</code> 和 <code>populateFields</code> 方法）。</li></ol> 
<p><code>ButtonsFragment</code> 的代码如下：</p> 
<pre><code>@AndroidEntryPoint
class ButtonsFragment : Fragment() {

    @Inject lateinit var logger: LoggerLocalDataSource
    @Inject lateinit var navigator: AppNavigator

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_buttons, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        ...
    }
}
</code></pre> 
<p>请注意，<code>LoggerLocalDataSource</code> 的实例与我们在 <code>LogsFragment</code> 中所用的实例相同，因为该类型的作用域限定为 application 容器。但是，<code>AppNavigator</code> 的实例与 <code>MainActivity</code> 中的实例不同，因为我们尚未将其作用域限定为相应的 <code>Activity</code> 容器。</p> 
<p>现在，<code>ServiceLocator</code> 类不再提供依赖项，因此我们可以将其从项目中彻底移除。只有 <code>LogApplication</code> 类使用了它，我们在此类中保留了它的一个实例。由于不再需要该类，下面我们来将其清除。</p> 
<p>打开 <code>LogApplication</code> 类并移除使用的 <code>ServiceLocator</code>。<code>Application</code> 类的新代码如下：</p> 
<pre><code>@HiltAndroidApp
class LogApplication : Application()
</code></pre> 
<p>现在，您可以随时从项目中彻底移除 <code>ServiceLocator</code> 类。由于 <code>ServiceLocator</code> 仍在测试中使用，请也从 <code>AppTest</code> 类中将其移除。</p> 
<h3><a id="_508"></a>已介绍基本内容</h3> 
<p><strong>您刚刚所学的知识应该足以让您在 Android 应用中将 Hilt 用作依赖项注入工具。</strong></p> 
<p>从现在开始，我们将向应用添加一些新功能，以便您了解如何在不同情形中使用更高级的 Hilt 功能。</p> 
<h3><a id="9_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn8_514"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#8" rel="nofollow">9. 限定符</a></h3> 
<p>现在，我们已从项目中移除 <code>ServiceLocator</code> 类，并且您学习了 Hilt 的基础知识，下面我们来向应用中添加新功能，以探索其他 Hilt 功能。</p> 
<p><strong>在本部分中，您将学习以下内容</strong>：</p> 
<ul><li>如何将作用域限定为 Activity 容器。</li><li>什么是<strong>限定符</strong>、限定符解决什么问题以及如何使用。</li></ul> 
<p>为展示这一部分内容，我们需要应用有不同的行为。我们会将日志存储位置从数据库切换为内存中列表，以仅记录应用会话期间的日志。</p> 
<h3><a id="LoggerDataSource__525"></a>LoggerDataSource 接口</h3> 
<p>让我们开始将数据源抽象化到一个接口中。在 <code>data</code> 文件夹下创建一个名为 <code>LoggerDataSource.kt</code> 的新文件，并在其中包含以下内容：</p> 
<pre><code>package com.example.android.hilt.data

// Common interface for Logger data sources.
interface LoggerDataSource {
    fun addLog(msg: String)
    fun getAllLogs(callback: (List&lt;Log&gt;) -&gt; Unit)
    fun removeLogs()
}}
</code></pre> 
<p><code>ButtonsFragment</code> 和 <code>LogsFragment</code> 这两个 Fragment 都使用 <code>LoggerLocalDataSource</code>。我们需要重构它们，使其改为使用 <code>LoggerDataSource</code> 的实例。</p> 
<p>打开 <code>LogsFragment</code> 并将 logger 变量的类型设置为 <code>LoggerDataSource</code>：</p> 
<pre><code>@AndroidEntryPoint
class LogsFragment : Fragment() {

    @Inject lateinit var logger: LoggerDataSource
    ...
}

</code></pre> 
<p>在 <code>ButtonsFragment</code> 中执行相同的操作：</p> 
<pre><code>@AndroidEntryPoint
class ButtonsFragment : Fragment() {

    @Inject lateinit var logger: LoggerDataSource
    ...
}
</code></pre> 
<p>接下来，让我们让 <code>LoggerLocalDataSource</code> 实现此接口。打开 <code>data/LoggerLocalDataSource.kt</code> 文件并：</p> 
<ol><li>使其实现 <code>LoggerDataSource</code> 接口，以及</li><li>使用 <code>override</code> 标记其方法</li></ol> 
<pre><code>@Singleton
class LoggerLocalDataSource @Inject constructor(
    private val logDao: LogDao
) : LoggerDataSource {
    ...
    override fun addLog(msg: String) { ... }
    override fun getAllLogs(callback: (List&lt;Log&gt;) -&gt; Unit) { ... }
    override fun removeLogs() { ... }
} 

</code></pre> 
<p>现在，我们创建 <code>LoggerDataSource</code> 的另一个实现，名为 <code>LoggerInMemoryDataSource</code>，它会将日志保存到内存中。在 <code>data</code> 文件夹下创建一个名为 <code>LoggerInMemoryDataSource.kt</code> 的新文件，并在其中包含以下内容：</p> 
<pre><code>package com.example.android.hilt.data

import java.util.LinkedList

class LoggerInMemoryDataSource : LoggerDataSource {

    private val logs = LinkedList&lt;Log&gt;()

    override fun addLog(msg: String) {
        logs.addFirst(Log(msg, System.currentTimeMillis()))
    }

    override fun getAllLogs(callback: (List&lt;Log&gt;) -&gt; Unit) {
        callback(logs)
    }

    override fun removeLogs() {
        logs.clear()
    }
}
</code></pre> 
<h3><a id="_Activity__608"></a>将作用域限定为 Activity 容器</h3> 
<p>为了能够将 <code>LoggerInMemoryDataSource</code> 用作实现细节，我们需要告知 Hilt 如何提供此类型的实例。和以前一样，我们为类构造函数添加 <code>@Inject</code> 注解：</p> 
<pre><code>class LoggerInMemoryDataSource @Inject constructor(
) : LoggerDataSource { ... }
</code></pre> 
<p>由于我们的应用仅包含一个 Activity（也称为“单 Activity”应用），因此我们应该在 <code>Activity</code> 容器中有一个 <code>LoggerInMemoryDataSource</code> 的实例，并在 <code>Fragment</code> 中重复使用该实例。</p> 
<p>我们可以通过将 <code>LoggerInMemoryDataSource</code> 的作用域限定为 <code>Activity</code> 容器来实现内存中记录行为：创建的每个 <code>Activity</code> 都有自己的容器及不同的实例。在每个容器中，当 logger 需要作为依赖项或用于字段注入时，系统将提供 <code>LoggerInMemoryDataSource</code> 的相同实例。此外，在<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-hierarchy" rel="nofollow">组件层次结构</a>下的容器中，也将提供相同的实例。</p> 
<p>根据<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-scopes" rel="nofollow">“将作用域限定为组件”文档</a>，要将某个类型的作用域限定为 <code>Activity</code> 容器，我们需要为该类型添加 <code>@ActivityScoped</code> 注解：</p> 
<pre><code>@ActivityScoped
class LoggerInMemoryDataSource @Inject constructor(
) : LoggerDataSource { ... }
</code></pre> 
<p>目前，Hilt 知道如何提供 <code>LoggerInMemoryDataSource</code> 和 <code>LoggerLocalDataSource</code> 的实例，但 <code>LoggerDataSource</code> 呢？Hilt 不知道请求 <code>LoggerDataSource</code> 时应使用哪种实现。</p> 
<p>如前面部分所述，我们可以在模块中使用 <code>@Binds</code> 注解来告知 Hilt 应使用哪种实现。但是，**如果我们需要在同一项目中提供两种实现，该怎么办？**例如，在应用运行时使用 <code>LoggerInMemoryDataSource</code>并在 <code>Service</code> 中使用 <code>LoggerLocalDataSource</code>。</p> 
<h3><a id="_633"></a>同一接口的两种实现</h3> 
<p>让我们在 <code>di</code> 文件夹中创建一个名为 <code>LoggingModule.kt</code> 的新文件。由于 <code>LoggerDataSource</code> 的不同实现的作用域限定为不同的容器，因此我们不能使用同一个模块：<code>LoggerInMemoryDataSource</code> 的作用域限定为 <code>Activity</code> 容器，而 <code>LoggerLocalDataSource</code> 的作用域限定为 <code>Application</code> 容器。</p> 
<p>幸运的是，我们可以在刚才创建的同一文件中为两个模块定义绑定：</p> 
<pre><code>package com.example.android.hilt.di

@InstallIn(ApplicationComponent::class)
@Module
abstract class LoggingDatabaseModule {

    @Singleton
    @Binds
    abstract fun bindDatabaseLogger(impl: LoggerLocalDataSource): LoggerDataSource
}

@InstallIn(ActivityComponent::class)
@Module
abstract class LoggingInMemoryModule {

    @ActivityScoped
    @Binds
    abstract fun bindInMemoryLogger(impl: LoggerInMemoryDataSource): LoggerDataSource
}
</code></pre> 
<p><strong>如果类型限定了作用域，</strong><code>@Binds</code>** 方法必须具有限定作用域的注解**，因此，上面的函数带有 <code>@Singleton</code> 和 <code>@ActivityScoped</code> 注解。如果 <code>@Binds</code> 或 <code>@Provides</code> 用作某个类型的绑定，则该类型中限定作用域的注解将不会再使用，因此您可以开始将其从其他实现类中移除。</p> 
<p>如果您现在尝试构建项目，将看到 <code>DuplicateBindings</code> 错误！</p> 
<pre><code>error: [Dagger/DuplicateBindings] com.example.android.hilt.data.LoggerDataSource is bound multiple times
</code></pre> 
<p>这是因为 <code>LoggerDataSource</code> 类型注入到了 <code>Fragment</code> 中，但**同一类型有两个绑定，Hilt 不知道应使用哪种实现！**如何告知 Hilt 应使用哪种实现呢？</p> 
<h3><a id="_671"></a>使用限定符</h3> 
<p><strong>如要告知 Hilt 如何提供同一类型的不同实现（多个绑定），您可以使用<strong><strong>限定符</strong></strong>。</strong></p> 
<p>限定符是用于标识绑定的注解。</p> 
<p>由于每个限定符将用于标识一个绑定，我们需要为每种实现定义一个限定符。在 Android 类中注入该类型或将该类型作为其他类的依赖项时，需要使用限定符注解以避免歧义。</p> 
<p>由于限定符只是注解，因此我们可以在添加模块的 <code>LoggingModule.kt</code> 文件中定义它们：</p> 
<pre><code>package com.example.android.hilt.di

@Qualifier
annotation class InMemoryLogger

@Qualifier
annotation class DatabaseLogger
</code></pre> 
<p>现在，我们必须使用限定符为提供每种实现的 <code>@Binds</code>（或 <code>@Provides</code>，如果我们需要它）函数添加注解。请查看完整的代码，并注意 <code>@Binds</code> 方法中使用的限定符：</p> 
<pre><code>package com.example.android.hilt.di

@Qualifier
annotation class InMemoryLogger

@Qualifier
annotation class DatabaseLogger

@InstallIn(ApplicationComponent::class)
@Module
abstract class LoggingDatabaseModule {

    @DatabaseLogger
    @Singleton
    @Binds
    abstract fun bindDatabaseLogger(impl: LoggerLocalDataSource): LoggerDataSource
}

@InstallIn(ActivityComponent::class)
@Module
abstract class LoggingInMemoryModule {

    @InMemoryLogger
    @ActivityScoped
    @Binds
    abstract fun bindInMemoryLogger(impl: LoggerInMemoryDataSource): LoggerDataSource
}
</code></pre> 
<p>此外，在注入时，必须将这些限定符用于要注入的实现。在本例中，我们将在 <code>Fragment</code> 中使用 <code>LoggerInMemoryDataSource</code> 实现。</p> 
<p><strong>重要提示</strong>：<code>@DatabaseLogger</code> 限定符安装在 <code>SingletonComponent</code> 中，可注入到 <code>LogApplication</code> 类中。但是，由于 <code>@InMemoryLogger</code> 安装在 <code>ActivityComponent</code> 中，它无法注入到 <code>LogApplication</code> 类中，原因是 application 容器不知道该绑定。</p> 
<p>打开 <code>LogsFragment</code> 并对 logger 字段使用 <code>@InMemoryLogger</code> 限定符，已告知 Hilt 注入 <code>LoggerInMemoryDataSource</code> 的实例：</p> 
<pre><code>@AndroidEntryPoint
class LogsFragment : Fragment() {

    @InMemoryLogger
    @Inject lateinit var logger: LoggerDataSource
    ...
}
</code></pre> 
<p>对 <code>ButtonsFragment</code> 执行相同的操作：</p> 
<pre><code>@AndroidEntryPoint
class ButtonsFragment : Fragment() {

    @InMemoryLogger
    @Inject lateinit var logger: LoggerDataSource
    ...
}
</code></pre> 
<p>如果您希望更改要使用的数据库实现，只需为注入的字段添加 <code>@DatabaseLogger</code> 而不是 <code>@InMemoryLogger</code> 注解。</p> 
<h3><a id="_753"></a>运行应用</h3> 
<p>我们可以运行应用，通过与按钮互动并观察“See all logs”屏幕上是否显示相应的日志，确认所执行的操作是否有效。</p> 
<p>请注意，系统不会再将日志保存到数据库。日志不会在不同会话之间保留，只要您关闭并再次打开应用，日志屏幕就是空的。</p> 
<p><img src="https://images2.imgbox.com/6c/09/PgTq1zc0_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="10_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn9_761"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#9" rel="nofollow">10. 界面测试</a></h3> 
<p>现在，该应用已完全迁移到 Hilt，我们还可以迁移项目中的插桩测试。该测试用于检查应用的功能，位于 <code>app/androidTest</code> 文件夹下的 <code>AppTest.kt</code> 文件中。打开它！</p> 
<p>您会发现，该测试无法编译，这是因为我们从项目中移除了 <code>ServiceLocator</code> 类。通过从类中移除 <code>@After tearDown</code> 方法，移除对不再使用的 <code>ServiceLocator</code> 的引用。</p> 
<p><code>androitTest</code> 测试在模拟器上运行。<code>happyPath</code> 测试会确认对“Button 1”的点按已记录到数据库中。由于应用使用的是内存中数据库，因此测试结束后，所有日志都会消失。</p> 
<h3><a id="_Hilt__769"></a>使用 Hilt 进行界面测试</h3> 
<p>Hilt 会在您的界面测试中注入依赖项，就像在您的生产代码中一样。</p> 
<p><strong>使用 Hilt 进行测试不需要维护，因为 Hilt 会自动为每个测试生成一组新的组件</strong>。</p> 
<h4><a id="_775"></a>添加测试依赖项</h4> 
<p>Hilt 使用另外一个包含测试专用注解的库，该库名为 <code>hilt-android-testing</code>，可让您更轻松地测试代码。此外，由于 Hilt 需要在 <code>androidTest</code> 文件夹中为各个类生成代码，因此其注解处理器也必须能够在其中运行。要实现这一点，您需要在 <code>app/build.gradle</code> 文件中添加两个依赖项。</p> 
<p>如要添加这些依赖项，请打开 <code>app/build.gradle</code> 并将以下配置添加到 <code>dependencies</code> 部分的底部：</p> 
<pre><code>dependencies {

    // Hilt testing dependency
    androidTestImplementation "com.google.dagger:hilt-android-testing:$hilt_version"
    // Make Hilt generate code in the androidTest folder
    kaptAndroidTest "com.google.dagger:hilt-android-compiler:$hilt_version"
}
</code></pre> 
<h4><a id="_TestRunner_791"></a>自定义 TestRunner</h4> 
<p>使用 Hilt 的插桩测试需要在支持 Hilt 的 <code>Application</code> 中执行。该库中已随附 <code>HiltTestApplication</code>，可用于运行界面测试。通过在项目中创建新的测试运行程序，可指定要在测试中使用的 <code>Application</code>。</p> 
<p>在同一级别，<code>AppTest.kt</code> 文件位于 <code>androidTest</code> 文件夹下，创建一个名为 <code>CustomTestRunner</code> 的新文件。<code>CustomTestRunner</code> 从 <a href="https://developer.android.com/training/testing/junit-runner?hl=zh-cn" rel="nofollow">AndroidJUnitRunner</a> 扩展而来，并按如下方式实现：</p> 
<pre><code>class CustomTestRunner : AndroidJUnitRunner() {

    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {
        return super.newApplication(cl, HiltTestApplication::class.java.name, context)
    }
}
</code></pre> 
<p>接下来，我们需要指示项目在插桩测试中使用该测试运行程序。这在 <code>app/build.gradle</code> 文件的 <code>testInstrumentationRunner</code> 属性中指定。打开该文件，并用以下内容替换默认的 <code>testInstrumentationRunner</code> 内容：</p> 
<pre><code>...
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner "com.example.android.hilt.CustomTestRunner"
    }
    ...
}
...

</code></pre> 
<p>现在，我们可以开始在界面测试中使用 Hilt 了！</p> 
<h3><a id="_Hilt__824"></a>运行使用 Hilt 的测试</h3> 
<p>接下来，模拟器测试类要使用 Hilt，它需要满足以下条件：</p> 
<ol><li>带有 <code>@HiltAndroidTest</code> 注解，该注解负责为每个测试生成 Hilt 组件</li><li>使用 <code>HiltAndroidRule</code>，该规则可用于管理组件的状态，并对测试执行注入。</li></ol> 
<p>我们来将其添加到 <code>AppTest</code> 中：</p> 
<pre><code>@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
class AppTest {

    @get:Rule
    var hiltRule = HiltAndroidRule(this)

    ...
}
</code></pre> 
<p>现在，如果您使用类定义或测试方法定义旁边的播放按钮运行测试，模拟器将会启动。如果您已配置模拟器，测试将通过。</p> 
<p>要详细了解测试和功能，例如字段注入或如何在测试中替换绑定，请参阅<a href="https://developer.android.com/training/dependency-injection/hilt-testing?hl=zh-cn" rel="nofollow">此文档</a>。</p> 
<h3><a id="11_EntryPoint_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn10_849"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#10" rel="nofollow">11. @EntryPoint 注释</a></h3> 
<p>在本 Codelab 的这一部分，我们将了解如何使用 <code>@EntryPoint</code> 注解，该注解用于<strong>在 Hilt 不支持的类中注入依赖项</strong>。</p> 
<p>正如我们之前看到的那样，Hilt 随附对最常见的 Android 组件的支持。但是，您可能需要在 Hilt 不直接支持或无法使用 Hilt 的类中执行字段注入。</p> 
<p>在此类情况下，您可以使用 <code>@EntryPoint</code>。入口点是一个边界位置，在该位置，您可以从无法使用 Hilt 注入依赖项的代码中获取由 Hilt 提供的对象。在入口点，代码首次进入到由 Hilt 管理的容器中。</p> 
<h3><a id="_857"></a>用例</h3> 
<p>我们希望能够在应用进程之外导出日志。为此，需要使用 <a href="https://developer.android.com/reference/android/content/ContentProvider?hl=zh-cn" rel="nofollow"><code>ContentProvider</code></a>。我们仅允许使用方使用 <code>ContentProvider</code> 查询应用中的某个特定日志（提供一个 <code>id</code>）或所有日志。我们将使用 Room 数据库检索数据。因此，<code>LogDao</code> 类应提供使用数据库 <a href="https://developer.android.com/reference/android/database/Cursor?hl=zh-cn" rel="nofollow"><code>Cursor</code></a> 返回所需信息的方法。打开 <code>LogDao.kt</code> 文件并向接口添加以下方法。</p> 
<pre><code>@Dao
interface LogDao {
    ...

    @Query("SELECT * FROM logs ORDER BY id DESC")
    fun selectAllLogsCursor(): Cursor

    @Query("SELECT * FROM logs WHERE id = :id")
    fun selectLogById(id: Long): Cursor?
}
</code></pre> 
<p>接下来，我们必须创建一个新的 <code>ContentProvider</code> 类，并替换 <code>query</code> 方法，以返回包含日志的 <code>Cursor</code>。在新的 <code>contentprovider</code> 目录下创建一个名为 <code>LogsContentProvider.kt</code> 的新文件，并在其中包含以下内容：</p> 
<pre><code>package com.example.android.hilt.contentprovider

import android.content.ContentProvider
import android.content.ContentUris
import android.content.ContentValues
import android.content.Context
import android.content.UriMatcher
import android.database.Cursor
import android.net.Uri
import com.example.android.hilt.data.LogDao
import dagger.hilt.EntryPoint
import dagger.hilt.EntryPoints
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ApplicationComponent
import java.lang.UnsupportedOperationException

/** The authority of this content provider.  */
private const val LOGS_TABLE = "logs"

/** The authority of this content provider.  */
private const val AUTHORITY = "com.example.android.hilt.provider"

/** The match code for some items in the Logs table.  */
private const val CODE_LOGS_DIR = 1

/** The match code for an item in the Logs table.  */
private const val CODE_LOGS_ITEM = 2

/**
 * A ContentProvider that exposes the logs outside the application process.
 */
class LogsContentProvider: ContentProvider() {

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
        addURI(AUTHORITY, LOGS_TABLE, CODE_LOGS_DIR)
        addURI(AUTHORITY, "$LOGS_TABLE/*", CODE_LOGS_ITEM)
    }

    override fun onCreate(): Boolean {
        return true
    }

    /**
     * Queries all the logs or an individual log from the logs database.
     *
     * For the sake of this codelab, the logic has been simplified.
     */
    override fun query(
        uri: Uri,
        projection: Array&lt;out String&gt;?,
        selection: String?,
        selectionArgs: Array&lt;out String&gt;?,
        sortOrder: String?
    ): Cursor? {
        val code: Int = matcher.match(uri)
        return if (code == CODE_LOGS_DIR || code == CODE_LOGS_ITEM) {
            val appContext = context?.applicationContext ?: throw IllegalStateException()
            val logDao: LogDao = getLogDao(appContext)

            val cursor: Cursor? = if (code == CODE_LOGS_DIR) {
                logDao.selectAllLogsCursor()
            } else {
                logDao.selectLogById(ContentUris.parseId(uri))
            }
            cursor?.setNotificationUri(appContext.contentResolver, uri)
            cursor
        } else {
            throw IllegalArgumentException("Unknown URI: $uri")
        }
    }

    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        throw UnsupportedOperationException("Only reading operations are allowed")
    }

    override fun update(
        uri: Uri,
        values: ContentValues?,
        selection: String?,
        selectionArgs: Array&lt;out String&gt;?
    ): Int {
        throw UnsupportedOperationException("Only reading operations are allowed")
    }

    override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;out String&gt;?): Int {
        throw UnsupportedOperationException("Only reading operations are allowed")
    }

    override fun getType(uri: Uri): String? {
        throw UnsupportedOperationException("Only reading operations are allowed")
    }
}

</code></pre> 
<p>您会发现，<code>getLogDao(appContext)</code> 调用无法编译！我们需要通过从 Hilt application 容器获取 <code>LogDao</code> 依赖项来实现它。但是，Hilt 不提供对注入到 <code>ContentProvider</code> 的开箱支持；对于 Activity，则提供该支持，例如使用 <code>@AndroidEntryPoint</code>。</p> 
<p>我们需要创建一个带有 <code>@EntryPoint</code> 注解的新接口才能访问它。</p> 
<h3><a id="EntryPoint__976"></a>@EntryPoint 的实际应用</h3> 
<p><strong>入口点是一个接口，对于我们所需的每个绑定（包括其限定符），都具有访问器方法</strong>。此外，该接口还必须带有 <code>@InstallIn</code> 注解，以指定要安装入口点的组件。</p> 
<p>最佳做法是在使用入口点接口的类中添加新的接口。因此，我们将该接口添加到 <code>LogsContentProvider.kt</code> 文件中：</p> 
<pre><code>class LogsContentProvider: ContentProvider() {

    @InstallIn(ApplicationComponent::class)
    @EntryPoint
    interface LogsContentProviderEntryPoint {
        fun logDao(): LogDao
    }

    ...
}

</code></pre> 
<p>请注意，该接口带有 <code>@EntryPoint</code> 注解，并且安装在 <code>SingletonComponent</code> 中，因为我们需要来自 <code>Application</code> 容器的实例的依赖项。在该接口中，我们会提供要访问的绑定的方法，在本例中为 <code>LogDao</code>。</p> 
<p>如需访问入口点，请使用来自 <code>EntryPointAccessors</code> 的适当静态方法。参数应该是组件实例或充当组件持有者的 <code>@AndroidEntryPoint</code> 对象。确保您以参数形式传递的组件和 <code>EntryPointAccessors</code> 静态方法都与 <code>@EntryPoint</code> 接口上的 <code>@InstallIn</code> 注解中的 Android 类匹配：</p> 
<p>现在，我们可以实现上面的代码中缺少的 <code>getLogDao</code> 方法。让我们在 <code>LogsContentProviderEntryPoint</code> 类中使用在上面定义的入口点接口：</p> 
<pre><code>class LogsContentProvider: ContentProvider() {
    ...

    private fun getLogDao(appContext: Context): LogDao {
        val hiltEntryPoint = EntryPointAccessors.fromApplication(
            appContext,
            LogsContentProviderEntryPoint::class.java
        )
        return hiltEntryPoint.logDao()
    }
}
</code></pre> 
<p>请注意我们如何将 <code>applicationContext</code> 传递给静态 <code>EntryPoints.get</code> 方法和带有 <code>@EntryPoint</code> 注解的接口的类。</p> 
<h3><a id="12_httpsdeveloperandroidcomcodelabsandroidhilthlzhcn11_1018"></a><a href="https://developer.android.com/codelabs/android-hilt?hl=zh-cn#11" rel="nofollow">12. 恭喜！</a></h3> 
<p>现在，您已经熟悉 Hilt，应该能够将其添加到您的 Android 应用。在本 Codelab 中，您学习了以下内容：</p> 
<ul><li>如何使用 <code>@HiltAndroidApp</code> 在 Application 类中设置 Hilt。</li><li>如何使用 <code>@AndroidEntryPoint</code> 向不同的 Android 生命周期组件添加依赖项容器。</li><li>如何使用模块告知 Hilt 如何提供特定类型。</li><li>如何使用限定符为某些类型提供多个绑定。</li><li>如何使用 Hilt 测试应用。</li><li><code>@EntryPoint</code> 何时实用以及如何使用它。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b873a0a5eee0df7eca4f7cc655dfc0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">测试用例的设计(2)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/286b39672c4e6109bbab84585a5ef61b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hbase集群搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>