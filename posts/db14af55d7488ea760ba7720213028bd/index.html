<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法笔记12_贪心 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法笔记12_贪心" />
<meta property="og:description" content="贪心活动安排问题贪心的理论基础贪心选择性质最优子结构性质求结过程 背包问题 慕课贪心法的例子:活动选择问题贪心法正确性证明:活动选择 贪心 在求最优解问题的过程中，依据某种贪心标准，从问题的初始状态出发，直接去求每一步的最优解，通过若干次的贪心选择，最终得出整个问题的最优解，这种求解方法就是贪心算法。
从贪心算法的定义可以看出，贪心算法不是从整体上考虑问题，它所做出的选择只是在某种意义上的局部最优解，而由问题自身的特性决定了该题运用贪心算法可以得到最优解。
如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。
活动安排问题 活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。
该问题要求高效地安排一系列争用某一公共资源的活动。
贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。
设有n个活动的集合E＝{1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。
每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi，且si＜fi。如果选择了活动i，则它在半开时间区间[si ，fi )内占用资源。若区间[si ，fi )与区间[sj，fj )不相交，则称活动i与活动j是相容的。当 si ≥ fj 或 sj ≥ fi 时，活动i与活动j相容。
活动安排问题就是在所给的活动集合中选出最大的相容活动子集合。
数据结构
struct action{ int s;	//起始时间 int f;	//结束时间 int index;	//活动的编号 }; 活动的集合E记为数组：
action a[1000]; 按活动的结束时间升序排序
排序比较因子：
bool cmp(const action &amp;a, const action &amp;b) { if (a.f&lt;=b.f) return true; return false; } 使用标准模板库函数排序（下标0未用）：
sort(a, a&#43;n&#43;1, cmp); //形参数组b用来记录被选中的活动 void GreedySelector(int n, action a[], bool b[]) { b[1] = true;　//第1个活动是必选的 //记录最近一次加入到集合b中的活动 int preEnd = 1; for(int i=2; i&lt;=n; i&#43;&#43;) if (a[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/db14af55d7488ea760ba7720213028bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-12T22:03:56+08:00" />
<meta property="article:modified_time" content="2020-04-12T22:03:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法笔记12_贪心</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> </h4> 
 <ul><li><a href="#_1" rel="nofollow">贪心</a></li><li><ul><li><a href="#_5" rel="nofollow">活动安排问题</a></li><li><a href="#_62" rel="nofollow">贪心的理论基础</a></li><li><ul><li><a href="#_70" rel="nofollow">贪心选择性质</a></li><li><a href="#_78" rel="nofollow">最优子结构性质</a></li><li><a href="#_85" rel="nofollow">求结过程</a></li></ul> 
   </li><li><a href="#_115" rel="nofollow">背包问题</a></li></ul> 
  </li><li><a href="#_202" rel="nofollow">慕课</a></li><li><ul><li><a href="#_203" rel="nofollow">贪心法的例子:活动选择问题</a></li><li><a href="#_212" rel="nofollow">贪心法正确性证明:活动选择</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>贪心</h2> 
<p>在求最优解问题的过程中，依据某种贪心标准，从问题的初始状态出发，直接去求每一步的最优解，通过若干次的贪心选择，最终得出整个问题的最优解，这种求解方法就是贪心算法。<br> 从贪心算法的定义可以看出，贪心算法不是从整体上考虑问题，它所做出的选择只是在某种意义上的局部最优解，而由问题自身的特性决定了该题运用贪心算法可以得到最优解。<br> 如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。</p> 
<h3><a id="_5"></a>活动安排问题</h3> 
<p>活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。<br> 该问题要求高效地安排一系列争用某一公共资源的活动。<br> 贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</p> 
<p>设有n个活动的集合E＝{1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。<br> 每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi，且s<sub>i</sub>＜f<sub>i</sub>。如果选择了活动i，则它在半开时间区间[s<sub>i</sub> ，f<sub>i</sub> )内占用资源。若区间[s<sub>i</sub> ，f<sub>i</sub> )与区间[s<sub>j</sub>，f<sub>j</sub> )不相交，则称活动i与活动j是相容的。当 s<sub>i</sub> ≥ f<sub>j</sub> 或 s<sub>j</sub> ≥ f<sub>i</sub> 时，活动i与活动j相容。<br> 活动安排问题就是在所给的活动集合中选出最大的相容活动子集合。</p> 
<p>数据结构</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> action<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> s<span class="token punctuation">;</span>			<span class="token comment">//起始时间</span>
	<span class="token keyword">int</span> f<span class="token punctuation">;</span>			<span class="token comment">//结束时间</span>
	<span class="token keyword">int</span> index<span class="token punctuation">;</span>		<span class="token comment">//活动的编号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>活动的集合E记为数组：</p> 
<pre><code class="prism language-cpp">action a<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>按活动的结束时间升序排序<br> 排序比较因子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> action <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> action <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>f<span class="token operator">&lt;=</span>b<span class="token punctuation">.</span>f<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用标准模板库函数排序（下标0未用）：</p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//形参数组b用来记录被选中的活动</span>
<span class="token keyword">void</span> <span class="token function">GreedySelector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> action a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
　　b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>　　　　　<span class="token comment">//第1个活动是必选的</span>
　　<span class="token comment">//记录最近一次加入到集合b中的活动</span>
　　<span class="token keyword">int</span> preEnd <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
　　<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
　　　　<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>s<span class="token operator">&gt;=</span>a<span class="token punctuation">[</span>preEnd<span class="token punctuation">]</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span>
　　　　<span class="token punctuation">{<!-- --></span>
　　　　　　b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
　　　　　　preEnd <span class="token operator">=</span> i<span class="token punctuation">;</span>
　　　　<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/3f/CMwME2DJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_62"></a>贪心的理论基础</h3> 
<p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，希望得到结果是最好或最优的算法。<br> 贪心算法是一种能够得到某种度量意义下的最优解的分级处理方法，通过一系列的选择得到一个问题的解，而它所做的每一次选择都是当前状态下某种意义的最好选择。即希望通过问题的局部最优解求出整个问题的最优解。<br> 这种策略是一种很简洁的方法，对许多问题它能产生整体最优解，但不能保证总是有效，因为它不是对所有问题都能得到整体最优解。<br> 利用贪心策略解题，需要解决两个问题：<br> （1）该题是否适合于用贪心策略求解；<br> （2）如何选择贪心标准，以得到问题的最优/较优解。</p> 
<h4><a id="_70"></a>贪心选择性质</h4> 
<p>贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p> 
<ul><li>这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</li></ul> 
<p>（1）在动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题后，才能做出选择。<br> （2）在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，然后再去解出这个选择后产生的相应的子问题。</p> 
<h4><a id="_78"></a>最优子结构性质</h4> 
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p> 
<ul><li>运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。</li></ul> 
<p>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</p> 
<ul><li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li><li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li></ul> 
<h4><a id="_85"></a>求结过程</h4> 
<p>使用贪心算法求解问题应该考虑如下几个方面：<br> （1）候选集合A：为了构造问题的解决方案，有一个候选集合A作为问题的可能解，即问题的最终解均取自于候选集合A。<br> （2）解集合S：随着贪心选择的进行，解集合S不断扩展，直到构成满足问题的完整解。<br> （3）解决函数solution：检查解集合S是否构成问题的完整解。<br> （4）选择函数select：即贪心策略，这是贪心法的关键，它指出哪个候选对象最有希望构成问题的解，选择函数通常和目标函数有关。<br> （5）可行函数feasible：检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//A是问题的输入集合即候选集合</span>
<span class="token function">Greedy</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
　　S<span class="token operator">=</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>　　　　　　　　　　　<span class="token comment">//初始解集合为空集</span>
　　<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">not</span> <span class="token function">solution</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>　　<span class="token comment">//集合S没有构成问题的一个解</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　x <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　<span class="token comment">//在候选集合A中做贪心选择</span>
　　　　<span class="token keyword">if</span> <span class="token function">feasible</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span>　　　　<span class="token comment">//判断集合S中加入x后的解是否可行</span>
　　　　　　S <span class="token operator">=</span> S<span class="token operator">+</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>
　　　　　　A <span class="token operator">=</span> A<span class="token operator">-</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">return</span> S<span class="token punctuation">;</span>
｝
</code></pre> 
<blockquote> 
 <p>（1）候选集合A：问题的最终解均取自于候选集合A。<br> （2）解集合S：解集合S不断扩展，直到构成满足问题的完整解。<br> （3）解决函数solution：检查解集合S是否构成问题的完整解。<br> （4）选择函数select：贪心策略，这是贪心算法的关键。<br> （5）可行函数feasible：解集合扩展后是否满足约束条件。</p> 
</blockquote> 
<h3><a id="_115"></a>背包问题</h3> 
<p>给定一个载重量为M的背包，考虑n个物品，其中第i个物品的重量 ，价值w<sub>i</sub> （1≤i≤n），要求把物品装满背包，且使背包内的物品价值最大。<br> 有两类背包问题（根据物品是否可以分割），如果物品不可以分割，称为<strong>0—1背包问题（动态规划）</strong>；如果物品可以分割，则称为<strong>背包问题（贪心算法）</strong>。</p> 
<p>假设x<sub>i</sub>是物品i装入背包的部分(0≤x<sub>i</sub>≤1)，当x<sub>i</sub>=0时表示物品i没有被装入背包;当x<sub>i</sub>= 1时表示物品i被全部装入背包。<br> 根据问题的要求，该问题可形式化描述为：<br> <img src="https://images2.imgbox.com/37/94/P0UaLxas_o.png" alt="在这里插入图片描述"><br> (0≤x<sub>i</sub>≤1)</p> 
<p>有3种方法来选取物品：<br> （1）当作0—1背包问题，用动态规划算法，获得最优值220；<br> （2）当作0—1背包问题，用贪心算法，按性价比从高到底顺序选取物品，获得最优值160。由于物品不可分割，剩下的空间白白浪费。<br> （3）当作背包问题，用贪心算法，按性价比从高到底的顺序选取物品，获得最优值240。由于物品可以分割，剩下的空间装入物品3的一部分，而获得了更好的性能。<br> <img src="https://images2.imgbox.com/ec/5e/ko40K2x0_o.png" alt="在这里插入图片描述"><br> 数据结构</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> bag<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> w<span class="token punctuation">;</span>			<span class="token comment">//物品的重量</span>
	<span class="token keyword">int</span> v<span class="token punctuation">;</span>			<span class="token comment">//物品的价值</span>
	<span class="token keyword">double</span> c<span class="token punctuation">;</span>		<span class="token comment">//性价比</span>
<span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//存放物品的数组</span>
</code></pre> 
<p>排序因子（按性价比降序）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>bag a<span class="token punctuation">,</span> bag b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token punctuation">.</span>c <span class="token operator">&gt;=</span> b<span class="token punctuation">.</span>c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用标准模板库函数排序（最好使用stable_sort()函数，在性价比相同时保持输入的顺序）：</p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//形参n是物品的数量，c是背包的容量M，数组a是按物品的性价比降序排序</span>
<span class="token keyword">double</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> bag a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">double</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
　　<span class="token keyword">double</span> cleft <span class="token operator">=</span> c<span class="token punctuation">;</span>　　　　　　　　<span class="token comment">//背包的剩余容量</span>
　　<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
　　<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>　　　　　　　　　　<span class="token comment">//获得的价值</span>
　　<span class="token comment">//当背包还能完全装入物品i</span>
　　<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token operator">&lt;</span>cleft<span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　cleft <span class="token operator">-</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
　　　　b <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
　　　　i<span class="token operator">++</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token comment">//装满背包的剩余空间</span>
　　<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">)</span> b <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">*</span>cleft<span class="token operator">/</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
　　<span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果要获得解向量X=(x<sub>1</sub>,x<sub>2</sub>,…x<sub>n</sub>)，则需要在数据结构中加入物品编号：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> bag<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> w<span class="token punctuation">;</span>
	<span class="token keyword">int</span> v<span class="token punctuation">;</span>
	<span class="token keyword">double</span> x<span class="token punctuation">;</span>		<span class="token comment">//装入背包的量，0≤x≤1</span>
	<span class="token keyword">int</span> index<span class="token punctuation">;</span>		<span class="token comment">//物品编号</span>
	<span class="token keyword">double</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> bag a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">double</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
　　<span class="token keyword">double</span> cleft <span class="token operator">=</span> c<span class="token punctuation">;</span>
　　<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
　　<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
　　<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token operator">&lt;=</span>cleft<span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　cleft <span class="token operator">-</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
　　　　b <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
　　　　<span class="token comment">//物品原先的序号是a[i].index，全部装入背包</span>
　　　　a<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
　　　　i<span class="token operator">++</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>　<span class="token punctuation">{<!-- --></span>
　　　　a<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">*</span>cleft<span class="token operator">/</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
　　　　b <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_202"></a>慕课</h2> 
<h3><a id="_203"></a>贪心法的例子:活动选择问题</h3> 
<p><img src="https://images2.imgbox.com/47/cc/ILrGAqDt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0b/29/E6JCw1XO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fa/1e/LRT8QBwZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/63/ab/15uvtdQm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/3e/PS5pPE9Y_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/da/sGYGsYme_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/18/6c/BruzhNZ9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_212"></a>贪心法正确性证明:活动选择</h3> 
<p><img src="https://images2.imgbox.com/fb/af/Uq8PECr6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9a/08/cgdPsfwc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bb/17/HoTLizjE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c3/e8/cljYjz9J_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/08/Wjuzolhl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/73/22/YwuZntIH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/b7/9OTleDB9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/37/84/vxHK0U9o_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/81/56/b4sbooIA_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d2215891467af3fc75e70afb137cb19/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx环境下安装aria2和web界面的aria2-Ng</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/814b37ac2fad2000e75f79eee39144db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【pytorch错误】：Pytorch RuntimeError: “host_softmax” not implemented for &#39;torch.cuda.LongTensor&#39;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>