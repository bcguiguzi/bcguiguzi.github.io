<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>布隆过滤器定义长度为m的数组，插入n个元素，k个哈希函数，已知m和n的值，k的值为多少时，求误判率最低的推导过程？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="布隆过滤器定义长度为m的数组，插入n个元素，k个哈希函数，已知m和n的值，k的值为多少时，求误判率最低的推导过程？" />
<meta property="og:description" content="布隆过滤器是怎么存储数据的？ 这里m=11，数组长度为11，n=3，插入3个元素，分别是hello、how、yes，k=3，使用了3个哈希函数，每插入一个元素要经过三个哈希函数的运算。
①插入hello元素，需要经过3个哈希函数，得出3个不同的哈希值索引【1,3,6】，那么在1,3,6的位置设置为1。
②插入how元素，需要经过3个哈希函数，得出3个不同的哈希索引值【4,8,10】，那么在4,8,10的位置设置为1。
③插入yes元素，需要经过3个哈希函数，得出3个不同的哈希值索引值【0,1,3】，那么在0,1,3的位置设置为1。
④误判的情况：判断ok元素是否存在？ok这个元素经过3个哈希函数运算以后，得出的索引值也是【0,1,3】，这个索引值和yes元素是一样的，然而布隆过滤器认为ok这个元素是存在的，但实际上不存在的，因为哈希值冲突了。
设布隆过滤器的长度为m，插入n个素，进行k个哈希函数运算，已知m和n的值，问：当k的值为多少的时候，误判率最低？ 解：
长度为m，插入1个元素，1个哈希函数运算的情况下，某一位是1的概率为：，那么某一位为0的概率就是 长度为m，插入n个元素，1个哈希函数运算的情况下，一次插入1个元素（每次插入的元素可能有某几次是重复的），插入n次，相当于插入了n个元素，插入这么多次以后，某一位仍然为0的概率是
长度为m，插入n个元素，每插入一个元素之前就经过k个哈希函数运算的情况下，一次插入1个元素，插入n次，相当于插入了n个元素，插入这么多次以后，某一位仍然为0的概率是
反过来，某一位为1的概率就是
那么，某两位同时为1的概率就是 ，某三位同时为1的概率就是 ，某k位同时为1的概率就是，这个概率，就是误判率，因为检查是否有某个元素的时候，某k位同时为1，说明有这个元素，但这个元素是外来的，本身不存在于集合当中。
误判率 ，其中m，n都是常数，求这个函数是最小值的时候，k等于多少？
当m足够大的时候，也就是数组足够长的时候，能够确保误判率足够，此时，把式子变形：
因为m是一个很大的数字，可能是100万，1000万这个数量级别的，足以让趋近于 e
所以，
两边都取ln对数得：
，即 令 ，那么 两边求导：
因为，且，所以
式子两边同时乘以f(k)得到：
再令 所以
提出一个
因为k是大于等于1的整数，b是大于1的数字， ，那么，t的取值范围就是(0,1)
那么研究在(0,1)的区间里面的正负性，我们发现当t＝1/2 的时候， ，那么，咱们就来研究，这个导函数在区间和区间的正负性。
在研究正负性之前，咱们要先研究的极限和增减性。
首先来看极限：
研究函数 和函数 的极限，因为函数包含了这两种函数，所以咱们要研究它
当x -&gt; 0&#43; 的时候，使用洛必达法则：
对函数 的分子以及分母 分别求导，得到分子是，分母是，这时候，分别在分子和分母同时乘以，得到，即 ，当x-&gt;0&#43; 的时候， 是趋近于0- 的，所以当x-&gt;0&#43; 的时候，函数 也是无限趋近于0的，并且是负数。
x-&gt;0&#43; 的时候 ，函数，是无穷趋近于1的且小于1，是无穷趋近于0的，并且小于0，那么这两个数不是0/0或者∞/∞形式的，就不适用于洛必达法则去求极限了，直接得出极限是函数无穷趋近于0，并且小于0，一个有限的数乘以一个无穷趋近于0的负数，结果肯定是无穷趋近于0。
那么这时候当t-&gt;0&#43; 的时候， ， 不用说，咱们只要能够画出函数的图像，判断函数在区间(0,1)的正负性即可。
函数确认了3个点：
函数图像是怎么经过这3个点的呢？(0,0)和(1,0)是无限趋近的点。
再次对函数求导：
我们通过工具，发现，这个导函数的图像是这样的：
在的区间，，是单调递减的，
在区间 ，，是单调递增的，
在区间 ，，是单调递增的，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d66e7dc6503e5e34335c999c90978e3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-10T16:06:29+08:00" />
<meta property="article:modified_time" content="2021-04-10T16:06:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">布隆过滤器定义长度为m的数组，插入n个元素，k个哈希函数，已知m和n的值，k的值为多少时，求误判率最低的推导过程？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>布隆过滤器是怎么存储数据的？</h4> 
<p>这里m=11，数组长度为11，n=3，插入3个元素，分别是hello、how、yes，k=3，使用了3个哈希函数，每插入一个元素要经过三个哈希函数的运算。</p> 
<p>①插入hello元素，需要经过3个哈希函数，得出3个不同的哈希值索引【1,3,6】，那么在1,3,6的位置设置为1。</p> 
<p>②插入how元素，需要经过3个哈希函数，得出3个不同的哈希索引值【4,8,10】，那么在4,8,10的位置设置为1。</p> 
<p>③插入yes元素，需要经过3个哈希函数，得出3个不同的哈希值索引值【0,1,3】，那么在0,1,3的位置设置为1。</p> 
<p>④误判的情况：判断ok元素是否存在？ok这个元素经过3个哈希函数运算以后，得出的索引值也是【0,1,3】，这个索引值和yes元素是一样的，然而布隆过滤器认为ok这个元素是存在的，但实际上不存在的，因为哈希值冲突了。</p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/5d/bd/L841LOdL_o.png" width="453"></p> 
<p> </p> 
<h4>设布隆过滤器的长度为m，插入n个素，进行k个哈希函数运算，已知m和n的值，问：当k的值为多少的时候，误判率最低？</h4> 
<p>解：</p> 
<p>长度为m，插入1个元素，1个哈希函数运算的情况下，某一位是1的概率为：<img alt="\frac{1}{m}" class="mathcode" src="https://images2.imgbox.com/de/34/De2qaWne_o.png">，那么某一位为0的概率就是 <img alt="1-\frac{1}{m}" class="mathcode" src="https://images2.imgbox.com/a5/66/r9rmzoMa_o.png"></p> 
<p>长度为m，插入n个元素，1个哈希函数运算的情况下，一次插入1个元素（每次插入的元素可能有某几次是重复的），插入n次，相当于插入了n个元素，插入这么多次以后，某一位仍然为0的概率是<img alt="(1-\frac{1}{m})^{n}" class="mathcode" src="https://images2.imgbox.com/5d/3a/WwXjoQeE_o.png"></p> 
<p>长度为m，插入n个元素，每插入一个元素之前就经过k个哈希函数运算的情况下，一次插入1个元素，插入n次，相当于插入了n个元素，插入这么多次以后，某一位仍然为0的概率是<img alt="(1-\frac{1}{m})^{kn}" class="mathcode" src="https://images2.imgbox.com/83/b3/Mdz04F7z_o.png"></p> 
<p>反过来，某一位为1的概率就是<img alt="1-(1-\frac{1}{m})^{kn}" class="mathcode" src="https://images2.imgbox.com/76/6b/bMDlftCV_o.png"></p> 
<p>那么，某两位同时为1的概率就是<img alt="[1-(1-\frac{1}{m})^{kn}]^{2}" class="mathcode" src="https://images2.imgbox.com/ea/6e/lhl9OMsg_o.png"> ，某三位同时为1的概率就是<img alt="[1-(1-\frac{1}{m})^{kn}]^{3}" class="mathcode" src="https://images2.imgbox.com/6e/60/JnKr8joE_o.png"> ，某k位同时为1的概率就是<img alt="[1-(1-\frac{1}{m})^{kn}]^{k}" class="mathcode" src="https://images2.imgbox.com/bf/cc/NoRVO1Qt_o.png">，这个概率，就是误判率，因为检查是否有某个元素的时候，某k位同时为1，说明有这个元素，但这个元素是外来的，本身不存在于集合当中。</p> 
<p>误判率 <img alt="f(k) = [1-(1-\frac{1}{m})^{kn}]^{k}" class="mathcode" src="https://images2.imgbox.com/10/71/RKbpc9zK_o.png"> ，其中m，n都是常数，求这个函数是最小值的时候，k等于多少？</p> 
<p>当m足够大的时候，也就是数组足够长的时候，能够确保误判率足够，此时，把式子变形：</p> 
<p><span style="color:#f33b45;"><img alt="f(k) = [1 - (1 - \frac{1}{m})^{-m\cdot \frac{-kn}{m}}]^{k}" class="mathcode" src="https://images2.imgbox.com/a3/a3/1sFj26SH_o.png"></span></p> 
<p>因为m是一个很大的数字，可能是100万，1000万这个数量级别的，足以让<img alt="(1 - \frac{1}{m})^{-m}" class="mathcode" src="https://images2.imgbox.com/d4/88/B2XLNTOL_o.png">趋近于 e</p> 
<p>所以，<img alt="f(k) = (1-e^{-\frac{n}{m}\cdot k})^{k}" class="mathcode" src="https://images2.imgbox.com/a2/df/uYPvHhA4_o.png"></p> 
<p>两边都取ln对数得：</p> 
<p><img alt="lnf(k) = ln(1-e^{-\frac{n}{m}\cdot k})^{k}" class="mathcode" src="https://images2.imgbox.com/d3/f2/7psxJCit_o.png"> ，即 <img alt="lnf(k) = k\cdot ln(1-e^{-\frac{n}{m}\cdot k})" class="mathcode" src="https://images2.imgbox.com/73/43/uiSprEYF_o.png"></p> 
<p>令 <img alt="b = e^{\frac{n}{m}}" class="mathcode" src="https://images2.imgbox.com/95/f9/3rG8flZe_o.png"> ，那么 <img alt="lnf(k) = k\cdot ln(1-b^{-k})^{k}" class="mathcode" src="https://images2.imgbox.com/8b/1c/ZtzQNOYs_o.png"></p> 
<p>两边求导：</p> 
<p><img alt="\frac{1}{f(k)}\cdot {f'(k)} = ln(1-b^{-k})+k\cdot \frac{1}{1-b^{-k}}\cdot (-b^{-k}\cdot lnb\cdot (-1))" class="mathcode" src="https://images2.imgbox.com/af/c3/3fr0FuPJ_o.png"></p> 
<p><img alt="\frac{1}{f(k)}\cdot {f'(k)} = ln(1-b^{-k})+\frac{k\cdot b^{-k}\cdot lnb}{1-b^{-k}}" class="mathcode" src="https://images2.imgbox.com/58/0e/7R5N0Eoa_o.png"></p> 
<p>因为<img alt="f(k) = (1-e^{-\frac{n}{m}\cdot k})^{k}" class="mathcode" src="https://images2.imgbox.com/88/b8/GCEkvrPS_o.png">，且<img alt="b = e^{\frac{n}{m}}" class="mathcode" src="https://images2.imgbox.com/b3/a2/SJymZhIz_o.png">，所以<img alt="f(k) = (1-b^{-k})^{k}" class="mathcode" src="https://images2.imgbox.com/d3/44/Z5wot82f_o.png"></p> 
<p>式子两边同时乘以f(k)得到：</p> 
<p><img alt="{f'(k)} = (1-b^{-k})^{k}ln(1-b^{-k}) - b^{-k}\cdot lnb^{-k}\cdot (1-b^{-k})^{k-1}" class="mathcode" src="https://images2.imgbox.com/d9/5e/9Au5kF6U_o.png"></p> 
<p>再令 <img alt="t = 1 - b^{-k}" class="mathcode" src="https://images2.imgbox.com/76/d7/YLFkSyBw_o.png"></p> 
<p>所以<img alt="{f'(t)} = t^{k}lnt - (1-t)\cdot ln(1-t)\cdot t^{k-1}" class="mathcode" src="https://images2.imgbox.com/03/80/ORk71p5U_o.png"></p> 
<p>提出一个<img alt="t^{k-1}" class="mathcode" src="https://images2.imgbox.com/3a/8b/nOzVosvc_o.png"></p> 
<p><img alt="{f'(t)} = t^{k-1}[tlnt - (1-t)ln(1-t)]" class="mathcode" src="https://images2.imgbox.com/f1/e2/DzWZJazI_o.png"></p> 
<p>因为k是大于等于1的整数，b是大于1的数字，<img alt="b = e^{\frac{n}{m}}" class="mathcode" src="https://images2.imgbox.com/a1/0c/Qj1fli1D_o.png"> ，那么<img alt="t = 1 - b^{-k}" class="mathcode" src="https://images2.imgbox.com/cb/6d/U1VUCpC1_o.png">，t的取值范围就是(0,1)</p> 
<p>那么研究<img alt="{f'(t)}" class="mathcode" src="https://images2.imgbox.com/4e/40/uR1u0p6y_o.png">在(0,1)的区间里面的正负性，我们发现当t＝1/2 的时候，<img alt="{f'(t)} = 0" class="mathcode" src="https://images2.imgbox.com/e8/c3/pXjOcZFI_o.png"> ，那么，咱们就来研究，这个导函数在区间<img alt="(0,\frac{1}{2})" class="mathcode" src="https://images2.imgbox.com/56/fd/bv3HplXj_o.png">和区间<img alt="[\frac{1}{2},1)" class="mathcode" src="https://images2.imgbox.com/09/e4/k1DCFmCP_o.png">的正负性。</p> 
<p>在研究正负性之前，咱们要先研究<img alt="{f'(t)}" class="mathcode" src="https://images2.imgbox.com/33/ca/CQXFwj6U_o.png">的极限和增减性。</p> 
<p>首先来看极限：</p> 
<p>研究函数 <img alt="f(x) = xlnx" class="mathcode" src="https://images2.imgbox.com/b4/35/8U9eXEv3_o.png"> 和函数 <img alt="f(x)=(1-x)ln(1-x)" class="mathcode" src="https://images2.imgbox.com/07/6d/h5MINWpU_o.png"> 的极限，因为函数<img alt="{f'(t)}" class="mathcode" src="https://images2.imgbox.com/87/05/zyQucJX7_o.png">包含了这两种函数，所以咱们要研究它</p> 
<p>当x -&gt; 0+ 的时候，使用洛必达法则：</p> 
<p>对函数<img alt="f(x) =\frac{lnx}{\frac{1}{x}}" class="mathcode" src="https://images2.imgbox.com/9d/65/u2o6l22B_o.png">  的分子<img alt="lnx" class="mathcode" src="https://images2.imgbox.com/fa/e3/qniMjX8M_o.png">以及分母<img alt="\frac{1}{x}" class="mathcode" src="https://images2.imgbox.com/cb/be/RwbF4lFm_o.png"> 分别求导，得到分子是<img alt="\frac{1}{x}" class="mathcode" src="https://images2.imgbox.com/f2/9a/mhMqk2Rn_o.png">，分母是<img alt="-\frac{1}{x^{2}}" class="mathcode" src="https://images2.imgbox.com/30/0d/ingu9Brs_o.png">，这时候，分别在分子和分母同时乘以<img alt="x" class="mathcode" src="https://images2.imgbox.com/35/60/FZHKLOBQ_o.png">，得到<img alt="\frac{1}{-\frac{1}{x}}" class="mathcode" src="https://images2.imgbox.com/b2/86/INQVxLRd_o.png">，即<img alt="-x" class="mathcode" src="https://images2.imgbox.com/1f/9d/AtxpUb5S_o.png"> ，当x-&gt;0+ 的时候，<img alt="-x" class="mathcode" src="https://images2.imgbox.com/3c/3d/taCXFA1B_o.png"> 是趋近于0- 的，所以当x-&gt;0+ 的时候，函数 <img alt="f(x) = xlnx" class="mathcode" src="https://images2.imgbox.com/5e/ad/QTImrdSG_o.png"> 也是无限趋近于0的，并且是负数。</p> 
<p>x-&gt;0+ 的时候 ，函数<img alt="f(x)=(1-x)ln(1-x)" class="mathcode" src="https://images2.imgbox.com/a6/c8/tCB4lvXZ_o.png">，<img alt="(1-x)" class="mathcode" src="https://images2.imgbox.com/1d/52/W7lBf2kU_o.png">是无穷趋近于1的且小于1，<img alt="ln(1-x)" class="mathcode" src="https://images2.imgbox.com/fe/cd/96hHfogr_o.png">是无穷趋近于0的，并且小于0，那么这两个数不是0/0或者∞/∞形式的，就不适用于洛必达法则去求极限了，直接得出极限是函数<img alt="f(x)=(1-x)ln(1-x)" class="mathcode" src="https://images2.imgbox.com/40/8b/N8bfoq9t_o.png">无穷趋近于0，并且小于0，一个有限的数乘以一个无穷趋近于0的负数，结果肯定是无穷趋近于0。</p> 
<p>那么这时候当t-&gt;0+ 的时候，<img alt="{f'(t)} = t^{k-1}[tlnt - (1-t)ln(1-t)]" class="mathcode" src="https://images2.imgbox.com/16/81/kFTwPYBd_o.png"> ， <img alt="t^{k-1} &gt; 0" class="mathcode" src="https://images2.imgbox.com/79/99/0wkSQ7JB_o.png"> 不用说，咱们只要能够画出函数<img alt="{g'(t)} = tlnt - (1-t)ln(1-t)" class="mathcode" src="https://images2.imgbox.com/87/47/mOtYqJ3f_o.png">的图像，判断函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/b0/70/EU7TIssv_o.png">在区间(0,1)的正负性即可。</p> 
<p>函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/f2/7d/HWH5SzVu_o.png">确认了3个点：</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/e7/65/KbqYNpGh_o.png" width="438"></p> 
<p> </p> 
<p>函数图像是怎么经过这3个点的呢？(0,0)和(1,0)是无限趋近的点。</p> 
<p>再次对函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/6e/98/wWCE3KFF_o.png">求导：</p> 
<p><img alt="g''(t) = lnt + ln(1-t) + 2" class="mathcode" src="https://images2.imgbox.com/b8/68/WSo8Rso6_o.png"></p> 
<p>我们通过工具，发现，这个导函数的图像是这样的：</p> 
<p>在<img alt="(0,t_{0})" class="mathcode" src="https://images2.imgbox.com/9e/e9/iix2aSMf_o.png">的区间，<img alt="g''(t) &lt; 0" class="mathcode" src="https://images2.imgbox.com/2a/0c/m7kZ83J7_o.png">，<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/93/ef/l0iGyNas_o.png">是单调递减的，</p> 
<p>在区间<img alt="(t_{0},\frac{1}{2})" class="mathcode" src="https://images2.imgbox.com/b5/3d/qs7o0FPq_o.png"> ，<img alt="g''(t) &gt; 0" class="mathcode" src="https://images2.imgbox.com/24/29/fQrKRjld_o.png">，<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/52/10/M1UbNAbe_o.png">是单调递增的，</p> 
<p>在区间<img alt="(\frac{1}{2},t_{1})" class="mathcode" src="https://images2.imgbox.com/5a/60/q6iP293W_o.png"> ，<img alt="g''(t) &gt; 0" class="mathcode" src="https://images2.imgbox.com/fd/4d/NDGExYYf_o.png">，<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/ed/b8/SXw4zu1K_o.png">是单调递增的，</p> 
<p>在区间<img alt="(t_{1},1)" class="mathcode" src="https://images2.imgbox.com/37/63/GkTjOPnZ_o.png"> ， <img alt="g''(t) &lt; 0" class="mathcode" src="https://images2.imgbox.com/6f/f0/iOIMCgvs_o.png">，<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/a1/2f/5XdvwLb9_o.png">是单调递减的</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/d3/db/cep2K8RB_o.png" width="455"></p> 
<p>知道函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/a3/12/VuCxSgzE_o.png">经过了<img alt="(0,0) , (\frac{1}{2},0),(1,0)" class="mathcode" src="https://images2.imgbox.com/2e/3f/t35PtEyS_o.png">这三个点，(不包括(0,0)和(1,0)，只能无穷趋近这两个点)，也知道在某些区间的增减性了。</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/15/05/q3UIHNJl_o.png" width="347"></p> 
<p>那么在<img alt="(0,\frac{1}{2})" class="mathcode" src="https://images2.imgbox.com/d9/29/cbMLKxDW_o.png">区间，一定是先减后增的，图像必须这么画：</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/9a/e6/EXwzWtlk_o.png" width="307"></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/a0/87/3lXnZnjJ_o.png" width="360"></p> 
<p>那么在<img alt="(\frac{1}{2},1)" class="mathcode" src="https://images2.imgbox.com/39/d3/RYyPsc21_o.png">区间，必须是先增后减的，图像必须这么画：</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/78/b3/hWJBsi5s_o.png" width="285"></p> 
<p>可见函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/f7/c7/F2Pozqk2_o.png">在<img alt="(0,\frac{1}{2})" class="mathcode" src="https://images2.imgbox.com/c4/26/omBgUNMe_o.png">区间，<img alt="{g'(t)}&lt;0" class="mathcode" src="https://images2.imgbox.com/80/a1/v3sChHYo_o.png">则<img alt="{f'(t)}&lt;0" class="mathcode" src="https://images2.imgbox.com/a4/18/L4zzEZlz_o.png">，<img alt="{f(t)}" class="mathcode" src="https://images2.imgbox.com/23/1d/v0SU7dCP_o.png">单调递减，函数<img alt="{g'(t)}" class="mathcode" src="https://images2.imgbox.com/a8/33/1DAInN6x_o.png">在<img alt="(\frac{1}{2},1)" class="mathcode" src="https://images2.imgbox.com/d5/d8/hmbnNCSh_o.png">区间，<img alt="{g'(t)}&gt;0" class="mathcode" src="https://images2.imgbox.com/56/26/5a5KrUIW_o.png">，则<img alt="{f'(t)}&gt;0" class="mathcode" src="https://images2.imgbox.com/34/1a/icJnngLv_o.png">，<img alt="{f(t)}" class="mathcode" src="https://images2.imgbox.com/64/03/O0r5fXBo_o.png">单调递增，当<img alt="t=\frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/bb/49/Y0bMsQEJ_o.png">时，<img alt="{g'(t)}=0" class="mathcode" src="https://images2.imgbox.com/8d/ea/3EWJzSyE_o.png">，则<img alt="{f'(t)}=0" class="mathcode" src="https://images2.imgbox.com/77/a3/T4Rl1OZx_o.png"></p> 
<p>那么，当<img alt="t=\frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/58/4e/SNSvAzvw_o.png">时候，误判率<img alt="{f(k)}" class="mathcode" src="https://images2.imgbox.com/0e/a4/jplPzJIU_o.png">取得最小值，由于<img alt="t = 1 - b^{-k}" class="mathcode" src="https://images2.imgbox.com/90/15/rYYTqORs_o.png"> ，<img alt="b = e^{\frac{n}{m}}" class="mathcode" src="https://images2.imgbox.com/57/ff/VcI58N5X_o.png"> </p> 
<p>得出<img alt="b^{-k}=\frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/80/ea/l6gRTA2y_o.png"> ，<img alt="e^{-\frac{n}{m}\cdot k} = \frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/8f/5b/NWeL83ne_o.png"> </p> 
<p><img alt="lne^{-\frac{n}{m}\cdot k} = ln\frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/2f/c2/PcxZ3nbc_o.png"></p> 
<p><img alt="\frac{n}{m}\cdot k = ln2" class="mathcode" src="https://images2.imgbox.com/68/7c/5Jkr42EZ_o.png"></p> 
<p><img alt="k = \frac{m}{n}\cdot ln2" class="mathcode" src="https://images2.imgbox.com/22/90/VZXtJ6Od_o.png"></p> 
<p>当知道数组长度m和插入数据量为n的时候，最优的哈希函数个数 k 为 <img alt="\frac{m}{n}\cdot ln2" class="mathcode" src="https://images2.imgbox.com/8d/bd/RnI7znYC_o.png"> 个，（k属于正整数）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9808c19752bbc7171c922e5a3c98c96e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php最新帮助文档,PHP-PHP-帮助文档-京东智联云</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b66e4165f924c2b3c8e8cd4b14540dcf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AxGlyph矢量绘图软件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>