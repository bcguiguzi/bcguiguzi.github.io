<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编译-glib交叉编译 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编译-glib交叉编译" />
<meta property="og:description" content="glib是一个C语言函数库，它对很多系统调用进行了封装，提供了很多实用的功能，能极大地方便编程。
为了在产品上尝试使用glib，需要对glib进行交叉编译，使其能在ARM9上运行。
以下是版本信息：
开发平台：Linux ubuntu 3.8.0-35-generic #52~precise1-Ubuntu SMP
PC gcc 版本 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)
ARM gcc version 4.1.2
zlib-1.2.8
libffi-3.2.1
glib-2.45.3
为了方便说明，先假设
1、zlib-1.2.8.tar.gz、libffi-3.2.1.tar.gz和glib-2.45.3.zip都已经解压到/home/user/build/目录下，分别是/home/user/build/zlib-1.2.8、/home/user/build/libffi-3.2.1和/home/user/build/glib-2.45.3。
2、CC是交叉编译器，根据自己的实际编译器而不同，这里CC最好时包含完整的路径。我这里是/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc
开始编译
1. 编译zlib，编译脚本如下：
cd /home/user/build/zlib-1.2.8 CC=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc \ ./configure --prefix=/home/user/build/zlib-1.2.8/install/arm/ make if [ $? == 0 ]; then make install else echo -e &#34;\n\tmake fail\n&#34; fi 执行成功之后，zlib就会安装在/home/user/build/zlib-1.2.8/install/arm/目录
2. 编译libffi，编译脚本如下：
#!/bin/bash cd /home/user/build/libffi-3.2.1 ./configure --prefix=/home/huo/dbus/libffi-3.2.1/install/arm/ \ CC=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc \ --host=arm-none-linux-gnueabi make if [ $? == 0 ]; then make install else echo -e &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4a071c39786c4bc4f572c9fd0b9dc4cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-07T11:42:50+08:00" />
<meta property="article:modified_time" content="2022-10-07T11:42:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编译-glib交叉编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        glib是一个C语言函数库，它对很多系统调用进行了封装，提供了很多实用的功能，能极大地方便编程。</p> 
<p>        为了在产品上尝试使用glib，需要对glib进行交叉编译，使其能在ARM9上运行。</p> 
<p>以下是版本信息：</p> 
<p>        开发平台：Linux ubuntu 3.8.0-35-generic #52~precise1-Ubuntu SMP</p> 
<p>        PC gcc 版本 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)</p> 
<p>        ARM gcc version 4.1.2</p> 
<p>        zlib-1.2.8</p> 
<p>        libffi-3.2.1</p> 
<p>        glib-2.45.3</p> 
<p></p> 
<p>        为了方便说明，先假设</p> 
<p>1、zlib-1.2.8.tar.gz、libffi-3.2.1.tar.gz和glib-2.45.3.zip都已经解压到/home/user/build/目录下，分别是/home/user/build/zlib-1.2.8、/home/user/build/libffi-3.2.1和/home/user/build/glib-2.45.3。</p> 
<p>2、CC是交叉编译器，根据自己的实际编译器而不同，这里CC最好时包含完整的路径。我这里是/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc</p> 
<p></p> 
<p>开始编译</p> 
<p>1. 编译zlib，编译脚本如下：</p> 
<p></p> 
<pre class="has"><code class="language-plain">cd /home/user/build/zlib-1.2.8
CC=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc \
./configure --prefix=/home/user/build/zlib-1.2.8/install/arm/

make
if [ $? == 0 ]; then
    make install
else
    echo -e "\n\tmake fail\n"
fi

</code></pre> 
<p>执行成功之后，zlib就会安装在/home/user/build/zlib-1.2.8/install/arm/目录</p> 
<p></p> 
<p></p> 
<p>2. 编译libffi，编译脚本如下：</p> 
<p></p> 
<pre class="has"><code class="language-plain">#!/bin/bash
cd /home/user/build/libffi-3.2.1
./configure --prefix=/home/huo/dbus/libffi-3.2.1/install/arm/ \
CC=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc \
--host=arm-none-linux-gnueabi 

make
if [ $? == 0 ]; then
	make install
else
	echo -e "\n\tmake fail\n"
fi</code></pre> 
<p>执行成功之后，zlib就会安装在/home/user/build/libffi-3.2.1/install/arm/目录</p> 
<p></p> 
<p></p> 
<p>3. 下面编译glib，是个硬骨头，会有一些错误。</p> 
<p>1)首先，glib需要一些配置，下面是一个配置文件glib.cache，这个配置文件需要放在/home/user/glib-2.45.3目录下面。</p> 
<p></p> 
<pre class="has"><code class="language-plain">glib_cv_long_long_format=ll
glib_cv_stack_grows=no
glib_cv_have_strlcpy=no
glib_cv_have_qsort_r=yes
glib_cv_va_val_copy=yes
glib_cv_uscore=no
glib_cv_rtldglobal_broken=no
ac_cv_func_posix_getpwuid_r=yes
ac_cv_func_posix_getgrgid_r=yes
</code></pre> 
<p>这个配置文件的选项，以及选项的意义看这里</p> 
<p></p> 
<p>https://developer.gnome.org/glib/stable/glib-cross-compiling.html</p> 
<p></p> 
<p>2)运行autogen.sh</p> 
<p></p> 
<pre class="has"><code class="language-plain">#!/bin/bash
cd /home/user/build/glib-2.45.3
./autogen.sh</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>3)编译PC版glib</p> 
<p>没错，你没看错，想交叉编译glib，需要先编译一个PC版本，而编译PC版glib又需要依赖PC版zlib和libffi</p> 
<p>由于我使用的是ubuntu，所以直接sudo apt-get install libffi-dev就可以了，zlib系统已经带了</p> 
<p>所以我编译PC版glib非常简单</p> 
<p></p> 
<pre class="has"><code class="language-plain">#!/bin/bash
cd /home/user/build/glib-2.45.3
./configure --prefix=/home/usr/build/glib-2.45.3/install/pc --cache-file=glib.cache 

make
if [ $? == 0 ]; then
	make install
else
	echo -e "\n\tmake fail\n"
fi</code></pre> 
<p>编译完成以后，就会在/home/usr/build/glib-2.45.3/install/pc/bin/目录下得到glib-genmarshal，否则在执行configure的时候会提示</p> 
<p></p> 
<p>configure: error: Could not find a glib-genmarshal in your PATH。至于为什么PC版就可以这个我还没有搞懂。</p> 
<p></p> 
<p>4)开始编译glib</p> 
<p></p> 
<pre class="has"><code class="language-plain">#!/bin/bash
export PATH=$PATH:/home/huo/dbus/glib-2.45.3/install/pc/bin
cd /home/user/build/glib-2.45.3
./configure --prefix=/home/user/build/glib-2.45.3/install/arm \
CC=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-gcc  \
--host=arm-none-linux-gnueabi LIBFFI_CFLAGS="-I/home/user/build/libffi-3.2.1/install/lib/libffi-3.2.1/include" \
LIBFFI_LIBS="-lffi -L/home/user/build/libffi-3.2.1/install/lib" ZLIB_CFLAGS="-I/home/user/build/zlib-1.2.8/install/include" \
ZLIB_LIBS="-lz -L/home/user/build/zlib-1.2.8/install/lib" --cache-file=glib.cache \
--disable-selinux  --disable-xattr --disable-libelf

make
if [ $? == 0 ]; then
	make install
else
	echo -e "\n\tmake fail\n"
fi</code></pre> 
<p><br> 这时，make的时候就应该会出错，提示</p> 
<p></p> 
<p></p> 
<p></p> 
<p><code>CCLD gobject-query./.libs/libgobject-2.0.so: undefined reference to `ffi_type_pointer'</code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_float' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_void' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_sint64' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_prep_cif' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_uint32' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_double' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_call' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_sint32' </code></p> 
<p><code>./.libs/libgobject-2.0.so: undefined reference to `ffi_type_uint64' </code></p> 
<p><code>collect2: ld returned 1 exit status</code></p> 
<p>这是由于没找到libffi.so的缘故。虽然我在配置里已经指定了libffi.so的路径，但glib就是死活找不到，暂时没找到解决方法，只能绕一下，把libffi.so libffi.so.6 libffi.so.6.0.4</p> 
<p>复制到arm gcc的目录下，我这里的目录是/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/arm-none-linux-gnueabi/sysroot/lib。如果你不知道</p> 
<p>你该复制到哪里，你可以在你的交叉编译器目录下找以下libc.so.*，比如find /opt/freescale -name libc.so.*，看libc.so.*放哪你就放哪。</p> 
<p>同理，libz.so libz.so.1和libz.1.2.8也要拷贝到这个目录下。</p> 
<p></p> 
<p>后面继续make，又会弹出来一个错误</p> 
<p>gfile.c:2749: error: too many arguments to function 'splice'</p> 
<p>这个错误是跟系统以及编译器的版本有关系的。splice是一个系统调用，它的声明在交叉编译器的fcntl.h文件里的，但我这个编译器的splice只有4个参数，glib却传了6个参数。</p> 
<p>这肯定不匹配嘛，没办法，只能修改glib-2.45.3目录下的config.h，把#define HAVE_SPLICE注释掉，这样就能编译过去了。至于影响，暂时还不清楚，这个splice是linux的</p> 
<p>一个数据拷贝优化技术，可以减少数据的拷贝次数，提高系统效率，即使没有应该也是可以正常工作的。</p> 
<p></p> 
<p>再继续make，又蹦出来一个错误，我内心也是崩溃的</p> 
<p><code>./.libs/libgio-2.0.so: undefined reference to `g_module_close' </code></p> 
<p><code>./.libs/libgio-2.0.so: undefined reference to `g_module_symbol' </code></p> 
<p><code>./.libs/libgio-2.0.so: undefined reference to `g_module_supported' </code></p> 
<p><code>./.libs/libgio-2.0.so: undefined reference to `g_module_open' </code></p> 
<p><code>./.libs/libgio-2.0.so: undefined reference to `g_module_error'</code></p> 
<p><code>collect2: error: ld returned 1 exit status</code></p> 
<p>这个错误又是没找到动态库，这次是没找到gmodule.so，需要修改gio/Makefile</p> 
<p>找到glib_compile_resources_LDADD, gsettings_LDADD, gdbus_LDADD, gapplication_LDADD, gresource_LDADD这几个变量，在给每个变量都加上一句</p> 
<p>$(top_builddir)/gmodule/libgmodule-2.0.la \</p> 
<p>加上之后类似这样</p> 
<p>gdbus_LDADD = libgio-2.0.la                 \<br>     $(top_builddir)/gobject/libgobject-2.0.la    \<br>     $(top_builddir)/gmodule/libgmodule-2.0.la    \<br>     $(top_builddir)/glib/libglib-2.0.la        \<br>     $(NULL)</p> 
<p></p> 
<p>再继续make。。。。。。。终于。。。。。。。</p> 
<p></p> 
<p>4. make install</p> 
<p></p> 
<p></p> 
<p></p> 
<p><br><br><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4b385e95501f19709cd5982ff644f74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">介绍-fs、ramdisk、ramfs、tmpfs、initramfs和rootfs</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ba5afb9fa0601596f258cdafee833da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用-screen命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>