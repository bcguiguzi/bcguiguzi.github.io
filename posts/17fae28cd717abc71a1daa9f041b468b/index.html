<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flutter--GestureDetector手势识别组件 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flutter--GestureDetector手势识别组件" />
<meta property="og:description" content="一、GestureDetector 的介绍 GestureDetector：是手势识别的组件，可以识别点击、双击、长按事件、拖动、缩放等手势
二、GestureDetector的源码介绍 GestureDetector({ Key key, this.child, this.onTapDown,//按下时回调 this.onTapUp,//抬起时回调 this.onTap,//点击事件回调 this.onTapCancel,//点击取消事件回调 this.onSecondaryTap, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onDoubleTapDown,//短时间内双击按下时回调 this.onDoubleTap,//短时间内双击回调 this.onDoubleTapCancel,//短时间内双击取消事件回调 this.onLongPress,//长按事件回调 this.onLongPressStart,//长按开始事件回调 this.onLongPressMoveUpdate,//长按移动事件回调 this.onLongPressUp,//长按抬起事件回调 this.onLongPressEnd,//长按结束事件回调 this.onSecondaryLongPress, this.onSecondaryLongPressStart, this.onSecondaryLongPressMoveUpdate, this.onSecondaryLongPressUp, this.onSecondaryLongPressEnd, this.onVerticalDragDown,//垂直滑动按下事件回调 this.onVerticalDragStart,//垂直滑动开始事件回调 this.onVerticalDragUpdate,//垂直滑动更新事件回调 this.onVerticalDragEnd,//垂直滑动结束事件回调 this.onVerticalDragCancel,//垂直滑动取消事件回调 this.onHorizontalDragDown,//水平滑动按下事件回调 this.onHorizontalDragStart,///水平滑动开始事件回调 this.onHorizontalDragUpdate,//水平滑动更新事件回调 this.onHorizontalDragEnd,//水平滑动结束事件回调 this.onHorizontalDragCancel,//水平滑动取消事件回调 this.onForcePressStart,//回调函数只会在有压力的设备上被触发 this.onForcePressPeak, this.onForcePressUpdate, this.onForcePressEnd, this.onPanDown,//按压时回调 this.onPanStart,//按压拖动开始回调 this.onPanUpdate,//按压拖动回调 this.onPanEnd,//按压拖动结束回调 this.onPanCancel,//按压拖动取消回调 this.onScaleStart,//缩放开始事件回调 this.onScaleUpdate,//缩放更新事件回调 this.onScaleEnd,//缩放结束事件回调 this.behavior,//手势检测器在触摸中应该如何工作 this.excludeFromSemantics = false, this.dragStartBehavior = DragStartBehavior.start, }) : assert(excludeFromSemantics != null), assert(dragStartBehavior != null), assert(() { final bool haveVerticalDrag = onVerticalDragStart !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/17fae28cd717abc71a1daa9f041b468b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T17:57:27+08:00" />
<meta property="article:modified_time" content="2022-06-07T17:57:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flutter--GestureDetector手势识别组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、GestureDetector 的介绍</h3> 
<p>GestureDetector：是手势识别的组件，可以识别点击、双击、长按事件、拖动、缩放等手势</p> 
<h3>二、GestureDetector的源码介绍</h3> 
<pre><code class="language-javascript">GestureDetector({
    Key key,
    this.child,
    this.onTapDown,//按下时回调
    this.onTapUp,//抬起时回调
    this.onTap,//点击事件回调
    this.onTapCancel,//点击取消事件回调
    this.onSecondaryTap,
    this.onSecondaryTapDown,
    this.onSecondaryTapUp,
    this.onSecondaryTapCancel,
    this.onTertiaryTapDown,
    this.onTertiaryTapUp,
    this.onTertiaryTapCancel,
    this.onDoubleTapDown,//短时间内双击按下时回调
    this.onDoubleTap,//短时间内双击回调
    this.onDoubleTapCancel,//短时间内双击取消事件回调
    this.onLongPress,//长按事件回调
    this.onLongPressStart,//长按开始事件回调
    this.onLongPressMoveUpdate,//长按移动事件回调
    this.onLongPressUp,//长按抬起事件回调
    this.onLongPressEnd,//长按结束事件回调
    this.onSecondaryLongPress,
    this.onSecondaryLongPressStart,
    this.onSecondaryLongPressMoveUpdate,
    this.onSecondaryLongPressUp,
    this.onSecondaryLongPressEnd,
    this.onVerticalDragDown,//垂直滑动按下事件回调
    this.onVerticalDragStart,//垂直滑动开始事件回调
    this.onVerticalDragUpdate,//垂直滑动更新事件回调
    this.onVerticalDragEnd,//垂直滑动结束事件回调
    this.onVerticalDragCancel,//垂直滑动取消事件回调
    this.onHorizontalDragDown,//水平滑动按下事件回调
    this.onHorizontalDragStart,///水平滑动开始事件回调
    this.onHorizontalDragUpdate,//水平滑动更新事件回调
    this.onHorizontalDragEnd,//水平滑动结束事件回调
    this.onHorizontalDragCancel,//水平滑动取消事件回调
    this.onForcePressStart,//回调函数只会在有压力的设备上被触发
    this.onForcePressPeak,
    this.onForcePressUpdate,
    this.onForcePressEnd,
    this.onPanDown,//按压时回调
    this.onPanStart,//按压拖动开始回调
    this.onPanUpdate,//按压拖动回调
    this.onPanEnd,//按压拖动结束回调
    this.onPanCancel,//按压拖动取消回调
    this.onScaleStart,//缩放开始事件回调
    this.onScaleUpdate,//缩放更新事件回调
    this.onScaleEnd,//缩放结束事件回调
    this.behavior,//手势检测器在触摸中应该如何工作
    this.excludeFromSemantics = false,
    this.dragStartBehavior = DragStartBehavior.start,
  }) : assert(excludeFromSemantics != null),
       assert(dragStartBehavior != null),
       assert(() {
         final bool haveVerticalDrag = onVerticalDragStart != null || onVerticalDragUpdate != null || onVerticalDragEnd != null;
         final bool haveHorizontalDrag = onHorizontalDragStart != null || onHorizontalDragUpdate != null || onHorizontalDragEnd != null;
         final bool havePan = onPanStart != null || onPanUpdate != null || onPanEnd != null;
         final bool haveScale = onScaleStart != null || onScaleUpdate != null || onScaleEnd != null;
         if (havePan || haveScale) {
           if (havePan &amp;&amp; haveScale) {
             throw FlutterError.fromParts(&lt;DiagnosticsNode&gt;[
               ErrorSummary('Incorrect GestureDetector arguments.'),
               ErrorDescription(
                 'Having both a pan gesture recognizer and a scale gesture recognizer is redundant; scale is a superset of pan.'
               ),
               ErrorHint('Just use the scale gesture recognizer.')
             ]);
           }
           final String recognizer = havePan ? 'pan' : 'scale';
           if (haveVerticalDrag &amp;&amp; haveHorizontalDrag) {
             throw FlutterError(
               'Incorrect GestureDetector arguments.\n'
               'Simultaneously having a vertical drag gesture recognizer, a horizontal drag gesture recognizer, and a $recognizer gesture recognizer '
               'will result in the $recognizer gesture recognizer being ignored, since the other two will catch all drags.'
             );
           }
         }
         return true;
       }()),
       super(key: key);</code></pre> 
<h3>三、GestureDetector的属性介绍</h3> 
<p></p> 
<p><span style="color:#a2e043;"> </span><span style="color:#1c7331;">onTapDown</span><span style="color:#a2e043;"> </span> 按下时回调</p> 
<p><span style="color:#1c7331;">onTapUp</span>  抬起时回调</p> 
<p>onTap  点击事件回调</p> 
<p>onTapCancel 点击取消事件回调</p> 
<p>onDoubleTapDown 短时间内双击按下时回调</p> 
<p>onDoubleTap 短时间内双击回调</p> 
<p>onDoubleTapCancel 短时间内双击取消事件回调</p> 
<p>onLongPress 长按事件回调</p> 
<p>onLongPressStart 长按开始事件回调</p> 
<p>onLongPressMoveUpdate 长按移动事件回调</p> 
<p>onLongPressUp 长按抬起事件回调</p> 
<p>onLongPressEnd 长按结束事件回调</p> 
<p>onVerticalDragDown 垂直滑动按下事件回调</p> 
<p>onVerticalDragStart 垂直滑动开始事件回调</p> 
<p>onVerticalDragUpdate 垂直滑动更新事件回调</p> 
<p>onVerticalDragEnd 垂直滑动结束事件回调</p> 
<p>onVerticalDragCancel 垂直滑动取消事件回调</p> 
<p>onHorizontalDragDown 水平滑动按下事件回调</p> 
<p>onHorizontalDragStart 水平滑动开始事件回调</p> 
<p>onHorizontalDragUpdate 水平滑动更新事件回调</p> 
<p>onHorizontalDragEnd 水平滑动结束事件回调</p> 
<p>onHorizontalDragCancel 水平滑动取消事件回调</p> 
<p>onPanDown 按压时回调（我自己理解为点击事件，但是比onTap优先级高，onPan先执行先取消,onPan比onTap多个滑动监听）</p> 
<p>onPanStart 按压拖动开始回调,按压开始，不能与 onScale ，onVerticalDrag，onHorizontalDrag，同时使用 onPanUpdate 按压拖动回调 onPanEnd 按压拖动结束回调</p> 
<p>onPanCancel 按压拖动取消回调</p> 
<p>onScaleStart 缩放开始事件回调缩放开始，不能与 onPan ，onVerticalDrag，onHorizontalDrag，同时使用</p> 
<p>onScaleUpdate 缩放更新事件回调</p> 
<p>onScaleEnd 缩放结束事件回调</p> 
<p>behavior 手势检测器在触摸中应该如何工作<br> HitTestBehavior.deferToChild:只有当前容器中的child被点击时才会响应点击事件<br> HitTestBehavior.opaque:点击整个区域都会响应点击事件，但是点击事件不可穿透向下传递，注释翻译：阻止视觉上位于其后方的目标接收事件。<br> HitTestBehavior.translucent:同样是点击整个区域都会响应点击事件，和opaque的区别是点击事件是否可以向下传递，注释翻译：半透明目标既可以在其范围内接受事件，也可以允许视觉上位于其后方的目标接收事件</p> 
<h3>四、一些触摸事件，监听的调用顺序</h3> 
<p>4.1、点击屏幕：onPanDown--onPanCancel--onTapDown--onTapUp--onTap</p> 
<p>4.2、点击滑动：onPanDown--onTapDown--onTapCancel--onPanStart--onPanUpdate--onPanEnd</p> 
<p>4.3、双击屏幕：onPanDown--onPanCancel--onDoubleTapDown--onPanDown--onPanCancel--onDoubleTap</p> 
<p>4.4、长按屏幕：onPanDown--onTapDown--onTapCancel--onPanCancel--onLongPressStart--onLongPress--onLongPressMoveUpdate--onLongPressEnd--onLongPressUp</p> 
<p>4.5、手指左右滑动：onVerticalDragDown--onHorizontalDragDown--onVerticalDragCancel--onHorizontalDragStart--onHorizontalDragUpdate--onHorizontalDragEnd</p> 
<p>4.6、手指上下滑动：onVerticalDragDown--onHorizontalDragDown--onHorizontalDragCancel--onVerticalDragStart--onVerticalDragUpdate--onVerticalDragEnd</p> 
<p>4.7、缩放：onScaleStart--onScaleUpdate--onScaleEnd</p> 
<h3>五、GestureDetector的demo</h3> 
<p>5.1、给组件添加按键监听</p> 
<pre><code class="language-objectivec">class _GestureDetectorFulState extends State&lt;GestureDetectorFul&gt; {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
        home: Scaffold(
      appBar: AppBar(
        title: Text("GestureDetector学习"),
      ),
      body: Center(
        child: GestureDetector(
          //一定要加（按钮和文字之间的空白，也添加监听了）
          behavior: HitTestBehavior.opaque,
          onPanDown: (value) {
            print("我是onPanDown");
          },
          child: Row(
            children: [
              OutlinedButton(
                child: Text("按钮"),
                onPressed: () {
                  print("点击了button");
                },
              ),
              SizedBox(width: 80),
              Text("文字")
            ],
          )
        ),
      )
    ));
  }
}</code></pre> 
<p><a class="has-card" href="https://www.jianshu.com/p/c338c7975f30" rel="nofollow" title="Flutter--GestureDetector手势识别组件 - 简书"><span class="link-card-box"><span class="link-title">Flutter--GestureDetector手势识别组件 - 简书</span><span class="link-desc">一、GestureDetector 的介绍 GestureDetector：是手势识别的组件，可以识别点击、双击、长按事件、拖动、缩放等手势 二、GestureDetecto...</span><span class="link-link">https://www.jianshu.com/p/c338c7975f30</span></span></a></p> 
<p></p> 
<p></p> 
<h2>Flutter手势操作 —全局坐标与局部坐标的获取</h2> 
<h4>全局坐标与局部坐标</h4> 
<p>在GestureDetector中有两个重要属性值<strong>globalPosition</strong>和<strong>localPosition</strong>，两者都是<strong>Offset对象</strong>。<br><strong>globalPosition</strong>就像它的命名表示当前手势触点在**<code>全局坐标系位置</code><strong>与</strong><code>对应组件顶点坐标的偏移量（dx，dy）</code><strong>；<br><strong>localPosition</strong>则就表示当前手势触点在</strong><code>对应组件坐标系位置</code><strong>与</strong><code>对应组件顶点坐标的偏移量（dx，dy）</code>**。</p> 
<blockquote> 
 <p>例如如下代码中，为Container设置了GestureDetector手势监听，在update回调中获取updateDetail对象，在Text中显示globalPosition偏移量。从中获取到的globalPosition和localPosition中dx的值相同，dy却不同。也就是因为Scaffold中设置了AppBar，相对于body他的全局坐标系并非它自身。但若将Scaffold中的AppBar去除，让body撑满整个Scaffold，那么在手势监听中获取到的globalPosition和localPosition偏移量将相同。</p> 
 <p>需要注意的是对于globalPosition在安卓中还包含了手机状态栏的高度。</p> 
</blockquote> 
<h4>通过DRAGUPDATEDETAILS获取全局坐标和局部坐标</h4> 
<p><strong>DragUpdateDetails</strong> 相当网页前端的Evnet事件，可以获取当前触摸点的全局坐标和局部坐标。</p> 
<pre><code class="language-objectivec">  onPanUpdate: (DragUpdateDetails detail) {   
    //获取当前触摸点的全局坐标
    var globalPosition=detail.globalPosition;
    //获取当前触摸点的局部坐标
    var localPosition=detail.localPosition;
   }
</code></pre> 
<h4>通过CONTEXNT.FINDRENDEROBJECT()获取全局坐标和局部坐标</h4> 
<p>当前的页面结构(PainterPage)：</p> 
<ul><li> <p>Scafford</p> 
  <ul><li> <p>body</p> 
    <ul><li>GestureDetector //手势Widget 
      <ul><li>onPanUpdate(detail)</li></ul></li></ul></li></ul></li></ul> 
<pre><code>onPanUpdate:(detail){
  final RenderBox Box = context.findRenderObject();   									// 获取的对象为当前页面对象，PainterPage
  Offset localPosition = Box.globalToLocal(detail.globalPosition);			// 转换为局部坐标但实际是全局坐标
  Offset globalPosition = Box.localToGlobal(detail.globalPosition);			// 获得的是全局坐标。
}
</code></pre> 
<p>为甚么通过这样的方式，不能正确获取到局部坐标呢？</p> 
<p>原因在于<code>context.findRenderObject()</code>,通过<code>context</code>,获取到的Box,实际上是<strong>PaintPage</strong>本身。所以，对于Box自身来说<code>全局坐标</code>和<code>局部坐标</code>是一致的。</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/2c/e0/5P9fQzFV_o.png" width="298"></p> 
<p> </p> 
<p>而实际上我们真正想要的是GestureDetector里的坐标系。由前面我们可以知道<code>context.findRenderObject()</code>只能获取<code>context</code>当前所在页面的<code>页面 Widget</code>。</p> 
<p>为了解决不能获取到<code>GuesterDetector</code>的坐标的问题，我们需要将<code>GuesterDetector</code>封装成一个StatefulWidget或者一个StatelessWidget，即<code>GuesterDetectorWidget</code>。再将<code>GuesterDetectorWidget</code>引入到<code>PainterPage</code>。</p> 
<p>更详细的说明可以参详<a href="https://blog.csdn.net/Salmonberry/article/details/106682583" title="字母索引快速定位">字母索引快速定位</a></p> 
<pre><code>onPanUpdate:(detail){
  final RenderBox Box = context.findRenderObject();   									// 获取的对象为当前页面对象，PainterPage
  Offset localPosition = Box.globalToLocal(detail.globalPosition);			// 转换为局部坐标
  Offset globalPosition = Box.localToGlobal(detail.globalPosition);			// 获得的是全局坐标。
}
</code></pre> 
<p><img alt="" height="383" src="https://images2.imgbox.com/29/28/EuKB5NnE_o.png" width="284"></p> 
<pre><code class="language-objectivec">MaterialApp(
      theme: AppTheme.themes[store.state.appThemeState.themeType],
      home: Scaffold(
        appBar: AppBar(),
        body: GestureDetector(
          onPanStart: (detail) {
            showLog(detail.runtimeType, detail.localPosition,
                detail.globalPosition);
          },
          onPanUpdate: (detail) {
            showLog(detail.runtimeType, detail.localPosition,
                detail.globalPosition);
            setState(() {
              offsetText = "globalPosition: ${Offset(detail.globalPosition.dx, detail.globalPosition.dy).toString()} \n"
                  "localPosition: ${Offset(detail.localPosition.dx, detail.localPosition.dy).toString()}";
            });
          },
          onPanEnd: (detail) {
            setState(() {
              offsetText = "end";
            });
          },
          child: Container(
            color: Colors.red,
            width: double.infinity,
            height: double.infinity,
            child: Center(
              child: Text(
                 offsetText,
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 25,
                ),
              ),
            ),
          ),
        ),
      ),
    );
</code></pre> 
<p><span style="color:#fe2c24;"> 可以看到当Scaffold包含和未包含AppBar时，Container两个偏移量输出的差异</span></p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/43/9c/zJAguesk_o.png" width="275"></p> 
<p> <img alt="" height="426" src="https://images2.imgbox.com/29/11/Q5OoaY5d_o.png" width="240"></p> 
<p> <br> #### 知识地图</p> 
<ul><li> <p>Flutter的坐标体系是以Widget的左上角为原点，向左为正x轴，以下为正y轴；</p> </li><li> <p>全局坐标是整个屏幕的左上角开始计算的</p> </li><li> <p>局部坐标，是以当前GestureDetector包裹的Wiget的左上角为原点开始计算的</p> </li><li></ul> 
<p>参考资料：</p> 
<p><a href="https://juejin.im/post/5d4fb0e4e51d453b8b5fa598" rel="nofollow" title="Flutter实战之手势操作篇">Flutter实战之手势操作篇</a></p> 
<p><a href="https://www.jianshu.com/p/2c4363da2036" rel="nofollow" title="实现 View 的移动拖拽">实现 View 的移动拖拽</a></p> 
<p>flutter 白板工具</p> 
<p>我们通过for循环建立的控件的时候，通过点击判断索引值跳转到不同页面</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/5d/49/HGqPeNdR_o.png" width="977"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f080a64b67d5a4ce528fec413357b5cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派实现温控风扇智能降温</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3813fd0fa26ca4b4f6d98b4badeb503/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">导出功能测试规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>