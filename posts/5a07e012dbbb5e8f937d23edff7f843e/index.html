<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MQ】消息中间件集群崩溃，如何保证百万生产数据不丢失？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【MQ】消息中间件集群崩溃，如何保证百万生产数据不丢失？" />
<meta property="og:description" content=" “上一篇讲消息中间件的文章《扎心！线上服务宕机时，如何保证数据100%不丢失？》，初步给大家介绍了一个在生产环境中可能遇到的问题，就是你的消费者服务可能会宕机，一旦宕机，你就需要考虑是否会导致没处理完的消息丢失。
这篇文章，再给不太熟悉MQ技术的同学，介绍另外一个生产环境中可能会遇到的问题。
目前为止，你的RabbitMQ部署在线上服务器了，对吧？然后订单服务和仓储服务都可以基于RabbitMQ来收发消息，同时仓储服务宕机，不会导致消息丢失。
好，我们来看下目前为止的架构图。
那如果此时出现一个问题，就是说订单服务投递了订单消息到RabbitMQ里去，RabbitMQ暂时放在了自己的内存中，还没来得及投递给下游的仓储服务呢，此时RabbitMQ突然宕机了，会怎么样？
答案其实很简单，默认情况下，按照我们目前的代码和配置，这个数据就会丢失了。
所以在这里而言，就牵扯到了RabbitMQ的一个较为重要的概念：消息的持久化，用英文来说就是durable机制。
然后这里又有一个引申的概念，如果按照我们之前的代码和配置，默认情况下，RabbitMQ一旦宕机就再次重启，就会丢失我们之前创建的queue。所以首先得先让queue是持久化的。
使用下面的代码，就可以把我们的“warehouse_schedule_delivery”这个queue，也就是仓储调度发货的queue，设置为持久化的。
这样，即使RabbitMQ宕机后重启，也会恢复之前创建好的这个queue。
channel.queueDeclare(&#34;warehouse_schedule_delivery&#34;,true,false,false,null);
大家看到上面那行定义和创建queue的代码么？核心在于第二个参数，第二个参数是true。
他的意思就是说，这个创建的queue是durable的，也就是支持持久化的。
RabbitMQ会把这queue的相关信息持久化的存储到磁盘上去，这样RabbitMQ重启后，就可以恢复持久化的queue。
OK，现在你的queue的信息可以持久化了，RabbitMQ宕机重启后会自动恢复queue。但是，你的queue里的message数据呢？
queue里都是订单服务发送过去的订单消息数据，如果RabbitMQ还没来得及投递queue里的订单消息到仓储服务，结果RabbitMQ就宕机了。
那此时RabbitMQ重启之后，他可以恢复queue的信息，但是queue的message数据是没法恢复了。
所以此时还有一个重要的点，就是在你的订单服务发送消息到RabbitMQ的时候，需要定义这条消息也是durable，即持久化的。
channel.basicPublish(&#34;&#34;, &#34;warehouse_schedule_delivery&#34;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
通过上面的方式来发送消息，就可以让发送出去的消息是持久化的。
一旦标记了消息是持久化之后，就会让RabbitMQ把消息持久化写入到磁盘上去，此时如果RabbitMQ还没投递数据到仓储服务，结果就突然宕机了。那么再次重启的时候，就会把磁盘上持久化的消息给加载出来。
整个过程，如下图所示：
但是这里要注意一点，RabbitMQ的消息持久化，是不承诺100%的消息不丢失的。
因为有可能RabbitMQ接收到了消息，但是还没来得及持久化到磁盘，他自己就宕机了，这个时候消息还是会丢失的。
如果要完全100%保证写入RabbitMQ的数据必须落地磁盘，不会丢失，需要依靠其他的机制。
下次有机会再继续给不太熟悉MQ技术的同学，来讲解这里的东西
转载自： 石杉的架构笔记 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5a07e012dbbb5e8f937d23edff7f843e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-16T16:13:58+08:00" />
<meta property="article:modified_time" content="2019-07-16T16:13:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MQ】消息中间件集群崩溃，如何保证百万生产数据不丢失？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>“</strong>上一篇讲消息中间件的文章<a href="https://blog.csdn.net/l18848956739/article/details/96144336">《扎心！线上服务宕机时，如何保证数据100%不丢失？》</a>，初步给大家介绍了一个在生产环境中可能遇到的问题，就是你的消费者服务可能会宕机，一旦宕机，你就需要考虑是否会导致没处理完的消息丢失。</p> 
<p>这篇文章，再给不太熟悉MQ技术的同学，介绍另外一个生产环境中可能会遇到的问题。</p> 
<p><strong>目</strong>前为止，你的RabbitMQ部署在线上服务器了，对吧？然后订单服务和仓储服务都可以基于RabbitMQ来收发消息，同时仓储服务宕机，不会导致消息丢失。</p> 
<p><img alt="" class="has" height="336" src="https://images2.imgbox.com/12/47/XG3j5LII_o.png" width="1059"></p> 
<p>好，我们来看下目前为止的架构图。</p> 
<p>那如果此时出现一个问题，就是说订单服务投递了订单消息到RabbitMQ里去，RabbitMQ暂时放在了自己的内存中，还没来得及投递给下游的仓储服务呢，此时RabbitMQ突然宕机了，会怎么样？</p> 
<p>答案其实很简单，默认情况下，按照我们目前的代码和配置，这个数据就会丢失了。</p> 
<p>所以在这里而言，就牵扯到了RabbitMQ的一个较为重要的概念：<strong>消息的持久化</strong>，用英文来说就是durable机制。</p> 
<p>然后这里又有一个引申的概念，如果按照我们之前的代码和配置，默认情况下，RabbitMQ一旦宕机就再次重启，就会丢失我们之前创建的queue。所以首先得先让queue是持久化的。</p> 
<p>使用下面的代码，就可以把我们的“warehouse_schedule_delivery”这个queue，也就是仓储调度发货的queue，设置为持久化的。</p> 
<p>这样，即使RabbitMQ宕机后重启，也会恢复之前创建好的这个queue。</p> 
<blockquote> 
 <p>channel.queueDeclare("warehouse_schedule_delivery",true,false,false,null);</p> 
</blockquote> 
<p>大家看到上面那行定义和创建queue的代码么？核心在于第二个参数，第二个参数是true。</p> 
<p>他的意思就是说，这个创建的queue是durable的，也就是支持持久化的。</p> 
<p>RabbitMQ会把这queue的相关信息持久化的存储到磁盘上去，这样RabbitMQ重启后，就可以恢复持久化的queue。</p> 
<p><img alt="" class="has" height="410" src="https://images2.imgbox.com/2b/42/2ZGScxdO_o.png" width="1048"></p> 
<p>OK，现在你的queue的信息可以持久化了，RabbitMQ宕机重启后会自动恢复queue。但是，你的queue里的message数据呢？</p> 
<p>queue里都是订单服务发送过去的订单消息数据，如果RabbitMQ还没来得及投递queue里的订单消息到仓储服务，结果RabbitMQ就宕机了。</p> 
<p>那此时RabbitMQ重启之后，他可以恢复queue的信息，但是queue的message数据是没法恢复了。<br> 所以此时还有一个重要的点，就是在你的订单服务发送消息到RabbitMQ的时候，需要定义这条消息也是durable，即持久化的。</p> 
<blockquote> 
 <p>channel.basicPublish("",  "warehouse_schedule_delivery", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</p> 
</blockquote> 
<p>通过上面的方式来发送消息，就可以让发送出去的消息是持久化的。</p> 
<p>一旦标记了消息是持久化之后，就会让RabbitMQ把消息持久化写入到磁盘上去，此时如果RabbitMQ还没投递数据到仓储服务，结果就突然宕机了。那么再次重启的时候，就会把磁盘上持久化的消息给加载出来。</p> 
<p>整个过程，如下图所示：</p> 
<p><img alt="" class="has" height="389" src="https://images2.imgbox.com/18/50/N8BTKivy_o.png" width="1053"></p> 
<p>但是这里要注意一点，<strong>RabbitMQ的消息持久化，是不承诺100%的消息不丢失的。</strong></p> 
<p>因为有可能RabbitMQ接收到了消息，但是还没来得及持久化到磁盘，他自己就宕机了，这个时候消息还是会丢失的。</p> 
<p>如果要完全100%保证写入RabbitMQ的数据必须落地磁盘，不会丢失，需要依靠其他的机制。</p> 
<p>下次有机会再继续给不太熟悉MQ技术的同学，来讲解这里的东西</p> 
<p>转载自： <a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247484257&amp;idx=1&amp;sn=e7704f92a1008ab7a292e2826bd079aa&amp;chksm=fba6eb62ccd1627451d439bbc21e46e6fc1d7bfbe2a431fd887cf974a7bd0d9d482697f0e4fd&amp;scene=21#wechat_redirect" rel="nofollow" id="js_name">石杉的架构笔记</a> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05770fb3b5be2dec558e7e00d4631037/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MQ】扎心！线上服务宕机时，如何保证数据100%不丢失？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4684311b81dd9bdb31985730abfe3cd9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot中@Value的工作原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>