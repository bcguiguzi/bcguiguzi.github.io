<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础知识笔记 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础知识笔记" />
<meta property="og:description" content="一、数据类型 1.基本数据类型 1.整数类型
byte
short
int
long 建议使用大写L
2.浮点类型
float
有限、离散、舍入误差、大约、接近但不等于
double
避免用浮点类型比较数值
BigDecimal 数学工具类
3.字符类型
char占2个字节 对应Unicode码
转义字符
4.布尔类型
boolean
只占一位，而且只有两个值true和false，常用语判断
5.类型转换
低--------------&gt;高
byte, short, char--&gt;int--&gt;long--&gt;float--&gt;double
运算中，不同类型的数据先转化为同一类型，然后进行运算。
1.强制类型转换 高 --&gt;低
int i = 128;
byte b = (byte) i;//导致内存溢出
2.自动类型转换 低 --&gt;高
int i = 128;
double d = i;
不能对布尔值进行转换。
不能把对象类型转换为不相干的类型。
在把高容量转换到低容量的时候，强制转换。
转换的时候可能存在内存溢出，或者精度问题。
2.变量类型 Java时一种强类型语言，每个变量都必须声明其类型。
Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。
注意事项
每个变量都有类型，类型可以是基本类型，也可以是引用类型。
变量名必须是合法的标识符。
变量声明是一条完整的语句，因此每一个声明都必须以分号结束。
变量作用域
类变量 1.加关键字static；2.从属于类，随着类存在或消亡
实例变量 1.从属于对象；2.未初始化值，会给默认值(0、0.0、null、false)
局部变量 1.必须声明和初始化值；2.作用域在方法里面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8341f5e238bab023fb9abe6d95246245/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-12T17:01:40+08:00" />
<meta property="article:modified_time" content="2023-03-12T17:01:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础知识笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">一、数据类型</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.基本数据类型</span></h5> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1.整数类型</span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>byte</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>short</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>int</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>long 建议使用大写L</p></li></ol> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2.浮点类型</span></p> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>float</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>有限、离散、舍入误差、大约、接近但不等于</p></li></ul> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>double</p></li></ol> 
 <ol start="7"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>避免用浮点类型比较数值</p></li></ol> 
 <ol start="8"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>BigDecimal 数学工具类</p></li></ol> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">3.字符类型</span></p> 
 <ol start="9"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>char占2个字节 对应Unicode码</p></li></ol> 
 <ol start="10"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>转义字符</p></li></ol> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">4.布尔类型</span></p> 
 <ol start="11"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>boolean</p></li></ol> 
 <ol start="12"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>只占一位，而且只有两个值true和false，常用语判断</p></li></ol> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">5.类型转换</span></p> 
 <ol start="13"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>低--------------&gt;高</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>byte, short, char--&gt;int--&gt;long--&gt;float--&gt;double</p></li></ul> 
 <ol start="14"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>运算中，不同类型的数据先转化为同一类型，然后进行运算。</p></li></ol> 
 <p style="text-align:left;">1.强制类型转换 高 --&gt;低</p> 
 <p style="text-align:left;">int i = 128;</p> 
 <p style="text-align:left;">byte b = (byte) i;//导致内存溢出</p> 
 <p style="text-align:left;">2.自动类型转换 低 --&gt;高</p> 
 <p style="text-align:left;">int i = 128;</p> 
 <p style="text-align:left;">double d = i;</p> 
 <ol start="15"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>不能对布尔值进行转换。</p></li></ol> 
 <ol start="16"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>不能把对象类型转换为不相干的类型。</p></li></ol> 
 <ol start="17"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在把高容量转换到低容量的时候，强制转换。</p></li></ol> 
 <ol start="18"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>转换的时候可能存在内存溢出，或者精度问题。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.变量类型</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java时一种强类型语言，每个变量都必须声明其类型。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">注意事项</span></p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>变量名必须是合法的标识符。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p></li></ul> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">变量作用域</span></p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>类变量 1.加关键字static；2.从属于类，随着类存在或消亡</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>实例变量 1.从属于对象；2.未初始化值，会给默认值(0、0.0、null、false)</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>局部变量 1.必须声明和初始化值；2.作用域在方法里面</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.常量类型</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>常量名一般使用大写字符。</p></li></ol> 
 <p style="text-align:left;">final double PI = 3.14;</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.变量的命名规范</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>所有变量、方法、类名：<span class="kdocs-bold" style="font-weight:bold;">见名知意</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>类成员变量：首字母小写和驼峰原则 ex：monthSalary lastName</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>局部变量：首字母小写和驼峰原则</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>常量：大写字母和下划线 ex：MAX_VALUE</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>类名：首字母大写和驼峰原则 ex：Man, GoodMan</p></li></ol> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>方法名：首字母小写和驼峰原则 ex：run(), testRun()</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.运算符</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>算术运算符 ：+，-，*，/，%，++，--</p></li></ol> 
 <p style="text-align:left;">面试题</p> 
 <p style="text-align:left;">int a = 10;</p> 
 <p style="text-align:left;">int b = 20;</p> 
 <p style="text-align:left;">System.out.println("" + a + b);//输出1020</p> 
 <p style="text-align:left;">System.out.println(a + b + "");//输出30</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>赋值运算符：=</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>逻辑运算符：&amp;&amp;，||，！</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>位运算符：&amp;，|，^，&gt;&gt;（左移就是 /2），&lt;&lt; （右移就是 *2），&gt;&gt;&gt; <span class="kdocs-bold" style="font-weight:bold;">（了解）</span></p></li></ol> 
 <p style="text-align:left;">面试题</p> 
 <p style="text-align:left;">计算机最快方式算出2*8=16</p> 
 <p style="text-align:left;">System.out.println(2&lt;&lt;3);//输出16</p> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>条件运算符：？ ： （一真大师） <span class="kdocs-bold" style="font-weight:bold;">必须掌握</span></p></li></ol> 
 <ol start="7"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>扩展赋值运算符：+=，-=，*=，/=</p></li></ol> 
 <ol start="8"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Math类</p></li></ol> 
 <ol start="9"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>很多运算我们会使用工具类来操作</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.包机制</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>包的本质就是文件夹。（防止重名）</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>一般利用公司域名倒置作为包名。ex：com.baidu.www </p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用 import 语句完成。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7.JavaDoc 生成文档</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>参数信息</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@author 作者名</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@version 版本号</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@since 指明需要最早使用的jdk版本</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@param 参数名</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@return 返回值情况</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>@throws 异常抛出情况</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在文件执行Dos命令窗口，javadoc -encoding UTF-8 -charset UTF-8 类名.java</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>用IDEA生成JavaDoc文档：选中要生成的包--&gt;Tools--&gt;Generate JavaDoc--&gt;Output directory(路径)--&gt;locale(zh_CN)--&gt;Other command line arguments(-encoding utf-8 -charset utf-8)。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">引用数据类型</span></h5> 
 <p style="text-align:null;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">二、流程控制</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.Scanner对象</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>java.util.Scanner 获取用户的输入。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>基本语法：</p></li></ol> 
 <p style="text-align:left;">Scanner scanner = new Scanner(System.in)</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>通过Scanner类的Next()和nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()和hasnextLine()判断是否还有输入的数据。</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>next()方法一定要读取到有效字符后才可以结束输入；对输入有效字符前遇到的空白，该方法会自动将其去掉；<span class="kdocs-bold" style="font-weight:bold;">不能等得到带有空格的字符串</span>。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>nextLine()方法以输入回车之前的所有字符，可以获得空白。</p></li></ul> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>此外通过Scanner还可以接收到整数nextInt()，浮点数nextDouble，等其他方法。</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>凡是IO流使用完都要关掉。</p></li></ol> 
 <p style="text-align:left;">scanner.close();</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.顺序结构</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java的基本结构就是顺序结构，除非特别指明，否则按照顺序一句一句执行。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>顺序结构是最简单的算法结构。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个以此执行的处理步骤组成的，<span class="kdocs-bold" style="font-weight:bold;">它是任何一个算法都离开的一种基本算法结构。</span></p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.选择结构</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>if单选择结构</p></li></ol> 
 <p style="text-align:left;">过关斩将：</p> 
 <p style="text-align:left;">if(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">}</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>if双选择结构</p></li></ol> 
 <p style="text-align:left;">if(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">} else {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为false将执行语句</p> 
 <p style="text-align:left;">}</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>if多选择结构</p></li></ol> 
 <p style="text-align:left;">if(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">} else if() {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">} else if() {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">} else if() {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;">} else {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为false将执行语句</p> 
 <p style="text-align:left;">}</p> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>嵌套的if结构</p></li></ol> 
 <p style="text-align:left;">if(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;"> if(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //如果布尔表达式为true将执行语句</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>switch多选择结构</p></li></ol> 
 <p style="text-align:left;">switch(expression) {//int char String</p> 
 <p style="text-align:left;"> case value:</p> 
 <p style="text-align:left;"> //语句</p> 
 <p style="text-align:left;"> break;</p> 
 <p style="text-align:left;"> case value:</p> 
 <p style="text-align:left;"> //语句</p> 
 <p style="text-align:left;"> break;</p> 
 <p style="text-align:left;"> //可以有多个case语句</p> 
 <p style="text-align:left;"> default:</p> 
 <p style="text-align:left;"> //语句</p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.循环结构</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>while循环</p></li></ol> 
 <p style="text-align:left;">while(布尔表达式) {<!-- --></p> 
 <p style="text-align:left;"> //循环内容</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">while(true) {<!-- --></p> 
 <p style="text-align:left;"> //死循环，尽量不要使用</p> 
 <p style="text-align:left;">}</p> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>只要布尔表达式为true，循环就会一直执行下去。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>我们大多数情况会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>do...while循环</p></li></ol> 
 <p style="text-align:left;">do {<!-- --></p> 
 <p style="text-align:left;"> //语句</p> 
 <p style="text-align:left;">} while(布尔表达式);</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>while和do...while的区别</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>while先判断后执行，do...while是先执行后判断。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>do...while总是爆炸循环体会被至少执行一次！这是主要区别。</p></li></ul> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>for循环</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>for循环语句是支持迭代的一种通用结构，<span class="kdocs-bold" style="font-weight:bold;">是最有效、最灵活的循环结构</span>。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>for循环执行的次数是在执行前就确定的。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;text-align:left;"><p>for(初始化; 布尔表达式; 迭代) {<!-- --><br> //代码语句<br>}<br>for(; ; 迭代) {//死循环<br> //代码语句 <br>}<br>练习题：打印九九乘法表<br>for (int i = 1; i &lt; 9; i++) {<!-- --><br> for (int j = 1; j &lt; i; j++) {<!-- --><br> System.out.print(j + "*" + i + "=" + (i * j) + "\t");<br> }<br> System.out.println();//换行<br> }</p></li></ul> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>增强for循环</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块中，其值与此时数组元素的值是否相等。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>主要用于<span class="kdocs-bold" style="font-weight:bold;">数组</span>和<span class="kdocs-bold" style="font-weight:bold;">集合</span>。</p></li></ul> 
 <p style="text-align:left;">for(声明语句 : 表达式) {<!-- --></p> 
 <p style="text-align:left;"> //代码句子</p> 
 <p style="text-align:left;">}</p> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>break、continue</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>break语句跳出当前循环或选择语句（while和switch），强制退出循环，会继续执行下面语句。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p></li></ul> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">三、方法</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.何谓方法</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java方法是语句的集合，它们在一起执行一个功能</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法是解决一类问题的步骤的有序组合</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法包含类或对象中</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法在程序中被创建，在其他地方被引用</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。<span class="kdocs-bold" style="font-weight:bold;">一个方法只完成1个功能，这样利于我们后期的扩展。</span></p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>System.out.println(); 类.out对象.println方法</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.方法的定义及调用</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含一下语法：</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>修饰符：这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>返回值类型：方法可能有返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，关键字是void。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>参数类型：</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>形式参数：在方法被调用时用于接收外接输入的数据。</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>实参：调用方法时实际传给方法的数据。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法体：包含具体的语句，定义该方法的功能。</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>方法的调用</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>调用方法：对象名.方法名(实参列表)</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>Java支持两种调用方法的方式，根据方法是返回值来选择。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：int larger = max(30, 40);</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>如果方法返回值是void，方法调用一定是一条语句。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>System.out.println("hello,java!");</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.方法重载</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>方法的重载规则：</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法名称必须相同。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法的返回类型可以相同也可以不相同。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>仅仅返回类型不同不足以成为方法的重载。</p></li></ul> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>实现理论：</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译报错。</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.命令行传参</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>有时候你希望运行一个程序时候再传递给他消息。这要靠传递命令行参数给main()函数实现。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.可变参数</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在方法声明中，在指定参数类型后加一个省略号(...)。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>一个方法中只能指定一个可变参数，她必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.递归</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>A方法调用B方法，我们很容易理解！</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>递归就是：A方法调用A方法！就是自己调用自己</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>递归的能力在于用有限的语句来定义对象的无限集合。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>递归结构包括两个部分：</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>递归体：什么时候需要调用自身方法。</p></li></ul> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">四、数组</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.数组概述</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组是<span class="kdocs-bold" style="font-weight:bold;">相同类型</span>数据的<span class="kdocs-bold" style="font-weight:bold;">有序</span>集合。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组描述的是相同类型的若干数据，按照一定的先后次序排列组合而成。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>其中，每一个数据乘作一个数组元素，每个数组元素可以通过一个下标来访问他们。<span class="kdocs-bold" style="font-weight:bold;">下标从0开始</span>。</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.数组声明创建</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>首先声明数组变量，才能在程序中使用数组。</p></li></ol> 
 <p style="text-align:left;">dataType[] arrayRefVar;//首选方法</p> 
 <p style="text-align:left;">dataType arrayRefVar[];//不建议使用</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java语言使用new操作符来创建数组。</p></li></ol> 
 <p style="text-align:left;">dataType[] arrayRefVar = new dataType[arraySize]</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组的元素是通过索引访问的，<span class="kdocs-bold" style="font-weight:bold;">数组索引从0开始</span>。</p></li></ol> 
 <p style="text-align:left;">arrays.length</p> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>获取数组长度。</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>静态初始化</p></li></ol> 
 <p style="text-align:left;">int[] a = {1, 2, 3};</p> 
 <p style="text-align:left;">Man[] mans = {new Man(1, 1), new Man(2, 2)};//引用类型</p> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>动态初始化</p></li></ol> 
 <p style="text-align:left;">int[] a = new int[2];</p> 
 <p style="text-align:left;">a[0] = 1;</p> 
 <p style="text-align:left;">a[1] = 2;</p> 
 <ol start="7"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组的默认初始化</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素被按照实例变量同样的方式被隐式初始化。</p></li></ul> 
 <ol start="8"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组的长度是确定的。</p></li></ol> 
 <ol start="9"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组的元素必须是相同类型的，不允许出现混合类型。</p></li></ol> 
 <ol start="10"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。<span class="kdocs-bold" style="font-weight:bold;">数组对象本身是在堆中的。</span></p></li></ol> 
 <ol start="11"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>下标的合法区间[0,length-1]。</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>ArrayIndexOutOfBoundsException 数组下标越界异常！</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.数组使用</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>For-Each循环 适合打印输出 遍历元素。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组作方法入参</p></li></ol> 
 <p style="text-align:left;">public class ArrayDemo {<!-- --></p> 
 <p style="text-align:left;"> public static void main(String[] args) {<!-- --></p> 
 <p style="text-align:left;"> int[] arrays = {1, 2, 3, 4, 5};</p> 
 <p style="text-align:left;"> int[] reverse = reverse(arrays); //调用方法reverse</p> 
 <p style="text-align:left;"> printArray(reverse); //调用方法printArray</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //反转数组方法</p> 
 <p style="text-align:left;"> pulic static int[] reverse(int[] arrays) {<!-- --></p> 
 <p style="text-align:left;"> int[] result = new int[arrays.length];</p> 
 <p style="text-align:left;"> //反转操作</p> 
 <p style="text-align:left;"> for(int i = 0, j = result.length - 1; i &lt; arrays.length; i++, j--) {<!-- --></p> 
 <p style="text-align:left;"> result[j] = arrays[i];</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> return result;</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //打印数组方法</p> 
 <p style="text-align:left;"> public static void printArray(int[] arrays) {<!-- --></p> 
 <p style="text-align:left;"> for(int i = 0; i &lt; arrays.length; i++) {<!-- --></p> 
 <p style="text-align:left;"> System.out.print(arrays[i] + "\t");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组作返回值</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.多维数组</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一位数组，其每一个元素都是一个一维数组。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>二维数组</p></li></ol> 
 <p style="text-align:left;">int[][] a = new int[2][5]; //可以看成是2行5列的数组</p> 
 <p style="text-align:left;">int[][] array = {<!-- -->{1, 2}, {3, 4}, {5, 6}};</p> 
 <p style="text-align:left;">array[0][0] = 1;</p> 
 <p style="text-align:left;">array[0][1] = 2;</p> 
 <p style="text-align:left;">array[1][0] = 3;</p> 
 <p style="text-align:left;">array.length = 3;</p> 
 <p style="text-align:left;">array[0].length = 2;</p> 
 <p style="text-align:left;">//打印输出数组</p> 
 <p style="text-align:left;">for(int i = 0; i &lt; array.length; i++) {<!-- --></p> 
 <p style="text-align:left;"> for(int j = 0; j &lt; array[i].length; j++) {<!-- --></p> 
 <p style="text-align:left;"> System.out.println(array[i][j]);</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.Arrays类</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数组的工具类java.util.Arrays</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>可查看JDK帮助文档</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而<span class="kdocs-bold" style="font-weight:bold;">不用</span>使用对象来调用。</p></li></ol> 
 <p style="text-align:left;">Arrays.toString(array);//该方法打印数组</p> 
 <p style="text-align:left;">Arrays.sort(array);//该方法升序数组</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.冒泡排序</span></h5> 
 <p style="text-align:left;">public static int[] sort(int[] array){<!-- --></p> 
 <p style="text-align:left;"> int temp = 0;</p> 
 <p style="text-align:left;"> for(int i = 0; i&lt; array.length -1; i++) {<!-- --></p> 
 <p style="text-align:left;"> for(int j = 0; j&lt;array.length - 1 -i; j++) {<!-- --></p> 
 <p style="text-align:left;"> if(array[j + 1] &lt; array[j]) {<!-- --></p> 
 <p style="text-align:left;"> temp = array[j];</p> 
 <p style="text-align:left;"> array[j] = array[j + 1];</p> 
 <p style="text-align:left;"> array[j + 1] = temp;</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> return array;</p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7.稀疏数组</span></h5> 
 <p style="text-align:left;">int[][] array1 = new int[11][11];</p> 
 <p style="text-align:left;">array1[1][2] = 1;</p> 
 <p style="text-align:left;">array1[2][3] = 1;</p> 
 <p style="text-align:left;">System.out.println("输出原始的数组：")</p> 
 <p style="text-align:left;">for(int[] ints : array1) {<!-- --></p> 
 <p style="text-align:left;"> for(int anInt : ints) {<!-- --></p> 
 <p style="text-align:left;"> System.out.print(anInt + "\t");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> System.out.print();</p> 
 <p style="text-align:left;"> //转换为稀疏数组</p> 
 <p style="text-align:left;"> int sum = 0;</p> 
 <p style="text-align:left;"> for(int i = 0; i &lt; 11; i++) {<!-- --></p> 
 <p style="text-align:left;"> for(int j = 0; i &lt; 11; j++) {<!-- --></p> 
 <p style="text-align:left;"> if(array[i][j] != 0) {<!-- --></p> 
 <p style="text-align:left;"> sum++;</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //创建稀疏数组</p> 
 <p style="text-align:left;"> int[][] array2 = new int[sum+1][3];</p> 
 <p style="text-align:left;"> array[0][0] = 11;</p> 
 <p style="text-align:left;"> array[0][1] = 11;</p> 
 <p style="text-align:left;"> array[0][2] = sum;</p> 
 <p style="text-align:left;"> //遍历二维数组将值存入到稀疏数组里</p> 
 <p style="text-align:left;"> int count = 0;</p> 
 <p style="text-align:left;"> for(int i = 0; i &lt; array1.length; i++) {<!-- --></p> 
 <p style="text-align:left;"> for(int j = 0; i &lt; array[i].length; j++) {<!-- --></p> 
 <p style="text-align:left;"> if(array[i][j] != 0) {<!-- --></p> 
 <p style="text-align:left;"> count++;</p> 
 <p style="text-align:left;"> array2[count][0] = i;//保存行</p> 
 <p style="text-align:left;"> array2[count][1] = j;//保存列</p> 
 <p style="text-align:left;"> array2[count][2] = array[i][j];//保存值</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //输出稀疏数组</p> 
 <p style="text-align:left;"> for(int i = 0; i &lt; array2.length; i++) {<!-- --></p> 
 <p style="text-align:left;"> System.out.print(aray2[i][0] + "\t" + aray2[i][1] + "\t" +aray2[i][2]);</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> System.out.print("还原数组");</p> 
 <p style="text-align:left;"> int[][] array3 = new int[array2[0][0]][array2[0][1]];</p> 
 <p style="text-align:left;"> for(int i = 1; i &lt; array2.length; i++) {<!-- --></p> 
 <p style="text-align:left;"> array3[array2[i][0]][array2[i][1]] = array2[i][2];</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //打印还原数组</p> 
 <p style="text-align:left;"> for(int[] ints : array1) {<!-- --></p> 
 <p style="text-align:left;"> for(int anInt : ints) {<!-- --></p> 
 <p style="text-align:left;"> System.out.print(anInt + "\t");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">五、面向对象(OOP)</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.初识面向对象</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>面向过程思想</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>步骤清晰简单，第一步做什么，第二步做什么...</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>适合处理一些较为简单的问题</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>面向对象思想</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>物以类聚，分类的思维模式，</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>适合处理复杂的问题，适合处理需要多人协作的问题！</p></li></ul> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>对于描述复杂的事物，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是具体到微观操作，仍然需要面向过程的思路去处理。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>面向对象(Object-Oriented Programming,OOP)</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>面向对象编程的本质就是：<span class="kdocs-bold" style="font-weight:bold;">以类的方式组织代码，以对象的组织(封装)数据。</span></p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>三大特性：</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>封装</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>继承</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>多态</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.方法回顾和加深</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>方法的定义</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>修饰符</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>返回类型</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>break:跳出switch，结束循环和return的区别</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>方法名</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>参数列表</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>异常抛出</p></li></ul> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>方法的调用</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>静态方法</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>非静态方法</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>形参和实参</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>值传递和引用传递</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>this关键字</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.对象的创建分析</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>对象是抽象概念的具体实例。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">一个项目应该只存在一个main方法</span>。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>使用<span class="kdocs-bold" style="font-weight:bold;">new</span>关键字创建对象。</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>类中的<span class="kdocs-bold" style="font-weight:bold;">构造器</span>也称构造方法，是在进行创建对象的时候必须要调用的。并且构造器有一下两个特点：</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>必须和类的名字相同</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>必须没有返回类型，也不能写void</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>new 本质在调用构造方法</p></li></ol> 
 <ol start="4"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>初始化对象的值</p></li></ol> 
 <ol start="5"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>定义有参构造之后，如果想使用无参构造，显示的定义一个无参的构造</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.面向对象三大特性</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>封装</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>该露的露，该藏的藏。<span class="kdocs-bold" style="font-weight:bold;">“高内聚，低耦合”</span>。</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>属性私有，<span class="kdocs-bold" style="font-weight:bold;">get/set方法</span>。</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>提高程序安全性，保护数据。</p></li></ol> 
 <ol start="4"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>隐藏代码细节。</p></li></ol> 
 <ol start="5"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>统一接口。</p></li></ol> 
 <ol start="6"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>提高系统可维护性。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>继承</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>extands的意思“扩展”，子类是父类的扩展。</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>Java中只有单继承，没有多继承！</p></li></ol> 
 <ol start="4"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</p></li></ol> 
 <ol start="5"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>继承是 is a 的关系。</p></li></ol> 
 <ol start="6"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>super关键字</p></li></ol> 
 <ol start="1"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>super()调用父类的构造方法，必须在构造方法的第一个。</p></li></ol> 
 <ol start="2"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>super必须只能出现在子类的方法或者构造方法中。</p></li></ol> 
 <ol start="3"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>super和this不能同时调用构造方法。</p></li></ol> 
 <ol start="7"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>this关键字</p></li></ol> 
 <ol start="1"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>表示本身调用者这个对象。</p></li></ol> 
 <ol start="2"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>没有继承也可以使用。</p></li></ol> 
 <ol start="3"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>本类的构造方法。</p></li></ol> 
 <ol start="8"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>方法的重写</p></li></ol> 
 <ol start="1"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>需要有继承关系，子类重写父类的<span class="kdocs-bold" style="font-weight:bold;">方法</span>。</p></li></ol> 
 <ol start="2"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>方法名必须相同，参数列表必须相同，修饰符范围可以扩大不能缩小。(public&gt;protected&gt;default&gt;private)</p></li></ol> 
 <ol start="3"><li style="margin-left:4.2em;list-style-type:Lower-roman;text-indent:0;"><p>抛出的异常范围可以缩小但不能扩大。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>多态</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>是方法的多态。</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>父类和子类存在关系，类型转换异常(ClassCastException)</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>继承关系，方法需要重写，父类引用指向子类对象！</p></li></ol> 
 <ol start="4"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>static方法不能重写，final修饰常量；private私有方法也不能重写。</p></li></ol> 
 <ol start="5"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>instanceof关键字。</p></li></ol> 
 <ol start="6"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>向上转型：把子类转换成父类。</p></li></ol> 
 <ol start="7"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>向下转型：把父类转换成子类，强制转换。</p></li></ol> 
 <ol start="8"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>final修饰的类就不能被继承。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>代码块</p></li></ol> 
 <p style="text-align:left;">//静态导入包</p> 
 <p style="text-align:left;">import static java.lang.Math.reandom;</p> 
 <p style="text-align:left;">{<!-- --></p> 
 <p style="text-align:left;"> System.out.println("匿名代码块");//输出顺序2</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">static {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("匿名代码块");//输出顺序1，只执行一次</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">pulic Person() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("构造方法");//输出顺序3</p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.抽象类和接口</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">abstract</span>修饰符的类；</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>不能new这个抽象类，只能靠子类去实现它。</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>抽象类可以没有抽象方法，抽象方法必须在抽象类中。</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>抽象类可以提高开发效率。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>接口就是规范，<span class="kdocs-bold" style="font-weight:bold;">接口的本质是契约</span>，关键字interface。</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>接口中的所有定义其实都是抽象的public abstract(可不写)；</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>一个类可以实现多个接口，关键字<span class="kdocs-bold" style="font-weight:bold;">implements</span>；</p></li></ol> 
 <ol start="3"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>实现了接口的类，就<span class="kdocs-bold" style="font-weight:bold;">必须重写</span>接口中的方法；</p></li></ol> 
 <ol start="4"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>定义的属性都是常量，public static final；</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.内部类</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>成员内部类</p></li></ol> 
 <p style="text-align:left;">public class Outer {<!-- --></p> 
 <p style="text-align:left;"> private int id;</p> 
 <p style="text-align:left;"> public void out() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("这是外部类的方法");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> public class Inner {<!-- --></p> 
 <p style="text-align:left;"> public void in() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("这是内部类的方法");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>内部类可以直接访问外部类方法和属性，不需要创建外部类的对象。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>静态内部类</p></li></ol> 
 <p style="text-align:left;">public class Outer {<!-- --></p> 
 <p style="text-align:left;"> private int id;</p> 
 <p style="text-align:left;"> public void out() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("这是外部类的方法");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> public static class Inner {<!-- --></p> 
 <p style="text-align:left;"> public void in() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("这是静态内部类的方法");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>局部内部类</p></li></ol> 
 <p style="text-align:left;">public class Outer {<!-- --></p> 
 <p style="text-align:left;"> public void method() {<!-- --></p> 
 <p style="text-align:left;"> class Inner {//局部内部类</p> 
 <p style="text-align:left;"> public void in() {<!-- --></p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>匿名内部类</p></li></ol> 
 <p style="text-align:left;">public class Outer {<!-- --></p> 
 <p style="text-align:left;"> public static void main(String[] args) {<!-- --></p> 
 <p style="text-align:left;"> new Apple.eat();</p> 
 <p style="text-align:left;"> UserServie userService = new UserService() {//匿名内部类</p> 
 <p style="text-align:left;"> @Override</p> 
 <p style="text-align:left;"> pubblic void hello() {<!-- --></p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> };</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">class Apple {<!-- --></p> 
 <p style="text-align:left;"> public void eat() {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("吃苹果");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">interface UserService {<!-- --></p> 
 <p style="text-align:left;"> void hello();</p> 
 <p style="text-align:left;">}</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">六、异常</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.什么是异常</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>软件程序在运行过程中，可能遇到异常问题，<span class="kdocs-bold" style="font-weight:bold;">Exception</span>；</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.异常体系结构</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>检查性异常。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>运行时异常。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>错误error，致命。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Java把异常当做对象来处理，并定义一个java.lang.Throwable作为异常的超类。</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在Java API 中定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。</p></li></ol> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1710px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:55.906433%;height:0;"> 
    <img src="https://images2.imgbox.com/56/56/8TgSkq3q_o.png" style="margin-left:;display:block;width:1710px;margin-top:-55.906433%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.Java异常处理机制</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>抛出异常</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>throw关键字，在代码块里使用，不管程序是否有异常，执行到throw语句一定会抛出一个异常。</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>throws关键字，使用在方法上。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>捕获异常</p></li></ol> 
 <p style="text-align:left;">int a = 1;</p> 
 <p style="text-align:left;">int b = 0;</p> 
 <p style="text-align:left;">//选中捕获代码，快捷键ctrl + alt + t</p> 
 <p style="text-align:left;">try {//监控区域</p> 
 <p style="text-align:left;"> System.out.println(a / b);</p> 
 <p style="text-align:left;">} catch(ArithmeticException e) {//想要捕获的异常类型</p> 
 <p style="text-align:left;"> System.out.println("程序出现异常");</p> 
 <p style="text-align:left;">} finally {//善后工作，始终会运行finally</p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.自定义异常</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>创建自定义异常类；</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在方法中通过throw关键字抛出异常对象。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在出现异常方法的调用者中捕获并处理异常。</p></li></ol> 
 <p style="text-align:left;">public class MyException extands Exception {<!-- --></p> 
 <p style="text-align:left;"> //传递数字 &gt; 10 就抛出异常</p> 
 <p style="text-align:left;"> private int detail;</p> 
 <p style="text-align:left;"> public MyException(int a) {<!-- --></p> 
 <p style="text-align:left;"> this.detail = a;</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> //打印异常信息</p> 
 <p style="text-align:left;"> @Override</p> 
 <p style="text-align:left;"> public String toString() {<!-- --></p> 
 <p style="text-align:left;"> return "MyException"{ + </p> 
 <p style="text-align:left;"> "detail=" + detail + '}';</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <p style="text-align:left;">public class Test {<!-- --></p> 
 <p style="text-align:left;"> static void test(int a) {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("传递参数为：" + a);</p> 
 <p style="text-align:left;"> if(a &gt; 10) {<!-- --></p> 
 <p style="text-align:left;"> throw new MyException(a);</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> System.out.println("OK");</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> public static void main(String[] args) {<!-- --></p> 
 <p style="text-align:left;"> try {<!-- --></p> 
 <p style="text-align:left;"> test(1);</p> 
 <p style="text-align:left;"> } catch(MyException e) {<!-- --></p> 
 <p style="text-align:left;"> System.out.println("MyException--&gt;" + e);</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;"> }</p> 
 <p style="text-align:left;">}</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.总结</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>对于不确定的代码，也可以加上try-catch，处理潜在的异常</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>尽量去处理异常，切记只是简单的调用printStackTrace()去打印输出</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>具体如何处理异常，要根据不同的业务需求和异常类型去决定</p></li></ol> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>尽量添加finally语句去释放占用的资源(IO流、Scanner、)</p></li></ol> 
 <p style="text-align:null;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">JDBC API</span></h3> 
 <hr> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.DriverManager 驱动管理类</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>getConnection(url,user,pwd) 获取到连接</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.Connection接口</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>create Statement 创建Statement 对象</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>prepaerdStatement(sql) 生成预处理对象</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3. Statement接口</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>executeUpdate(sql) 执行dml语句，返回影响的行数</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>executeQuery(sql) 执行查询，返回ResultSet对象</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>execute(sql) 执行任意的sql，返回布尔值</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Statement存在Sql注入问题</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>输入用户名为 1‘ or</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>输入万能密码为 or '1'= '1</p></li></ul> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>PreparedStatement【预处理】</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>不再使用 + 拼接sql语句，减少语法错误</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>有效地解决了Sql注入问题</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>大大减少了编译次数，效率较高</p></li></ul> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.PreparedStatement接口</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>executeUpdate() 执行dml语句</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>executeQuery() 执行查询，返回ResultSet对象</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>execute() 执行任意sql，返回布尔值</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>setString(index,value) 解决sql注入</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>setObject(index,value)</p></li></ol> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.ResultSet(结果集)</span></h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>next() 表示向下移动一行，如果没有下一行返回false</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>previous() 向上移动一行，如果没有上一行返回false</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>getXxx(index or 列名) 可以通过列名得到数据库的数据</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>getObject(index or 列名) 返回object对象</p></li></ol> 
 <p style="text-align:null;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">反编译</span></h3> 
 <hr> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>可以直接将class文件丢入到IDEA里面</p></li></ol> 
 <p style="text-align:left;">System.out.println(); //会换一行输出</p> 
 <p style="text-align:left;">System.out.print(); //不会会换一行输出</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62d1289ca847af079be3d80938c90b37/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">负载均衡SLB介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f13daf09ed3df76bee19d068ce854571/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python练习代码-第十一章-字典练习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>