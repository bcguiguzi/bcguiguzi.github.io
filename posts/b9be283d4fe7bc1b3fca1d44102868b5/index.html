<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Generalized Intersection over Union(GIOU)论文核心思想解读笔记 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Generalized Intersection over Union(GIOU)论文核心思想解读笔记" />
<meta property="og:description" content="Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression论文核心解读 （最近在忙于考研(20)，所以这里就放核心的思想，详细的其他，以后有时间再补充吧）
目录
Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression论文核心解读
本文的主要贡献总结如下：
什么是IOU
针对IOU问题的改进
对象检测精度测量
边界框表示和损失
使用近似函数或替代函数优化IoU
GIOU的算法公式
GIOU与IOU的区别
GIOU的边界回归损失
这是一遍关于目标监测的一篇论文，作者通过敏锐的观察发现了一个被大家所忽视的一点------基于并集交叉点（IOU）计算的度量损失替换替代回归损失。不得不说，作者对细节观察很仔细而且想法很大胆。
本文的主要贡献总结如下： •我们介绍了IOU的广义版本，作为比较任意两个任意形状的新指标。
•我们提供了将giou用作两个轴对齐矩形之间的损耗的分析解决方案，通常是n-orthotopes。
•我们将giou loss纳入最流行的目标检测算法，如更快的r-cnn、mask r-cnn和yolo v3，并在标准目标检测基准上显示其性能改进。
什么是IOU IOU，也称为JacCard索引，是比较两个任意形状之间相似性的最常用指标。IOU将要比较的对象的形状属性（例如，两个边界框的宽度、高度和位置）编码到Region属性中，然后计算聚焦于其区域（或体积）的标准化度量。此属性使IOU对所考虑问题的规模不变。由于这一吸引人的特性，用于评估分段、目标检测和跟踪的所有性能指标都依赖于这一指标。
然而，可以证明，在最小化常用损失（例如“Ln-norm”）与改进其IOU值之间没有很强的相关性，这是在二维/三维中两个边界框的参数表示上定义的。例如，考虑图1（a）中的简单二维场景，其中预测的边界框（黑色矩形）和真值框（绿色矩形）由它们的左上角和右下角表示，即（x1、y1、x2、y2）。为了简单起见，假设两个框的一个角之间的距离（例如“L2-norm”）是固定的。因此，任何第二个角位于以绿色矩形第二个角为中心的固定半径圆上的预测边界框（以灰色虚线圆表示）与真值框之间的“2-范数距离”将完全相同，但是它们的IOU值可以显著不同（图1（a））。同样的论点可以扩展到任何其他表示和损失，例如图1（b）。直观地说，对于这些类型的目标来说，一个好的局部优化未必是IOU的局部优化。此外，与IOU相比，基于上述参数表示定义的n-范数目标对问题的规模并不是不变的。为此，具有相同重叠级别但不同比例（例如透视）的多对边界框将具有不同的目标值。此外，一些表示可能会受到用于表示的不同类型参数之间缺乏正则化的影响。例如，在中心和大小表示中，（xc，yc）在位置空间上定义，而（w，h）属于大小空间。复杂度随着参数的增加而增加，例如旋转，或者在为问题添加更多维度时。为了缓解上述一些问题，最先进的物体探测器引入锚箱的概念作为假设良好的初始猜测。它们还定义了非线性表示来天真地补偿比例变化。即使有了这些手工制作的更改，优化回归损失和IOU值之间仍然存在差距。
在本文中，我们探讨了两个轴对齐矩形之间或通常是两个轴对齐的N-正交体之间的IOU的计算，这是一个简单的分析解，与普遍的观点相反，在这种情况下，IOU可以被反向传播，即它可以直接用作优化的目标函数。因此，最好使用IOU作为二维目标检测任务的目标函数。考虑到优化度量本身与代理损失函数之间的选择，最佳选择是度量本身。
然而，IOU作为度量和损失有两个主要问题：
（i）如果两个对象不重叠，IOU值将为零，并且不会反映两个形状彼此之间的距离。在非重叠对象的情况下，如果将IOU用作损耗，则其梯度将为零，无法优化；
（ii）IOU无法正确区分两个对象的不同对齐方式。更准确地说，两个物体在多个不同方向上重叠，且交叉点水平相同，其IOU将完全相等。因此，iou函数的值并不反映两个对象之间如何发生重叠。
针对IOU问题的改进 在本文中，我们将通过将IOU的概念扩展到不重叠的情况来解决IOU的这两个弱点。我们确保这种概括
（a）遵循与IOU相同的定义，即将比较对象的形状属性编码为区域属性；
（b）保持IOU的比例不变量属性；
（c）在对象重叠的情况下确保与IOU的强相关性。
我们介绍了IOU的这个广义版本，即giou，作为比较任意两个凸形的一个新指标。我们还提供了计算两个轴对齐矩形之间的giou的解析解，允许在这种情况下将其用作损失。将giou loss纳入最先进的目标检测算法中，我们始终使用基于iou的标准和新的基于giou的性能度量，在流行的目标检测基准（如pascal voc和ms coco）上提高它们的性能。
对象检测精度测量 联合交叉（IoU）是在对象检测中使用的事实评估度量。 它用于确定一组预测中的正确性和误差。 使用IoU作为评估指标时，必须选择准确度阈值。 例如，在PASCAL VOC挑战中，广泛报告的检测精度测量值，即平均平均精度（mAP），是基于固定的IoU阈值，即0.5来计算的。 然而，任意选择IoU阈值并不能完全反映不同方法的定位性能。 任何高于阈值的定位精度都被平等对待。 为了使此性能测量对IoU阈值的选择不那么敏感，MS COCO基准测试在多个IoU阈值中平均mAP。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b9be283d4fe7bc1b3fca1d44102868b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-01T11:04:30+08:00" />
<meta property="article:modified_time" content="2019-03-01T11:04:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Generalized Intersection over Union(GIOU)论文核心思想解读笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h2 id="Generalized%20Intersection%20over%20Union%3A%20A%20Metric%20and%20A%20Loss%20for%20Bounding%20Box%20%C2%A0Regression%E8%AE%BA%E6%96%87%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB">Generalized Intersection over Union: A Metric and A Loss for Bounding Box  Regression论文核心解读</h2> 
<p>（最近在忙于考研(20)，所以这里就放核心的思想，详细的其他，以后有时间再补充吧）</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Generalized%20Intersection%20over%20Union%3A%20A%20Metric%20and%20A%20Loss%20for%20Bounding%20Box%20%C2%A0Regression%E8%AE%BA%E6%96%87%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB-toc" style="margin-left:0px;"><a href="#Generalized%20Intersection%20over%20Union%3A%20A%20Metric%20and%20A%20Loss%20for%20Bounding%20Box%20%C2%A0Regression%E8%AE%BA%E6%96%87%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB" rel="nofollow">Generalized Intersection over Union: A Metric and A Loss for Bounding Box  Regression论文核心解读</a></p> 
<p id="%E6%9C%AC%E6%96%87%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%9C%AC%E6%96%87%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">本文的主要贡献总结如下：</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFIOU-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFIOU" rel="nofollow">什么是IOU</a></p> 
<p id="%E9%92%88%E5%AF%B9IOU%E9%97%AE%E9%A2%98%E7%9A%84%E6%94%B9%E8%BF%9B-toc" style="margin-left:40px;"><a href="#%E9%92%88%E5%AF%B9IOU%E9%97%AE%E9%A2%98%E7%9A%84%E6%94%B9%E8%BF%9B" rel="nofollow">针对IOU问题的改进</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%87%8F" rel="nofollow">对象检测精度测量</a></p> 
<p id="%E8%BE%B9%E7%95%8C%E6%A1%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%8D%9F%E5%A4%B1-toc" style="margin-left:80px;"><a href="#%E8%BE%B9%E7%95%8C%E6%A1%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%8D%9F%E5%A4%B1" rel="nofollow">边界框表示和损失</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E8%BF%91%E4%BC%BC%E5%87%BD%E6%95%B0%E6%88%96%E6%9B%BF%E4%BB%A3%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96IoU-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E8%BF%91%E4%BC%BC%E5%87%BD%E6%95%B0%E6%88%96%E6%9B%BF%E4%BB%A3%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96IoU" rel="nofollow">使用近似函数或替代函数优化IoU</a></p> 
<p id="GIOU%E7%9A%84%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#GIOU%E7%9A%84%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%8F" rel="nofollow">GIOU的算法公式</a></p> 
<p id="GIOU%E4%B8%8EIOU%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#GIOU%E4%B8%8EIOU%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">GIOU与IOU的区别</a></p> 
<p id="GIOU%E7%9A%84%E8%BE%B9%E7%95%8C%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1-toc" style="margin-left:40px;"><a href="#GIOU%E7%9A%84%E8%BE%B9%E7%95%8C%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1" rel="nofollow">GIOU的边界回归损失</a></p> 
<hr id="hr-toc"> 
<p>这是一遍关于目标监测的一篇论文，作者通过敏锐的观察发现了一个被大家所忽视的一点------<strong>基于并集交叉点（IOU）计算的度量损失替换替代回归损失</strong>。不得不说，作者对细节观察很仔细而且想法很大胆。</p> 
<h3 id="%E6%9C%AC%E6%96%87%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A">本文的主要贡献总结如下：</h3> 
<p>•我们介绍了IOU的广义版本，作为比较任意两个任意形状的新指标。</p> 
<p>•我们提供了将giou用作两个轴对齐矩形之间的损耗的分析解决方案，通常是n-orthotopes。</p> 
<p>•我们将giou loss纳入最流行的目标检测算法，如更快的r-cnn、mask r-cnn和yolo v3，并在标准目标检测基准上显示其性能改进。</p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AFIOU">什么是IOU</h3> 
<p>IOU，也称为JacCard索引，是比较两个任意形状之间相似性的最常用指标。IOU将要比较的对象的形状属性（例如，两个边界框的宽度、高度和位置）编码到Region属性中，然后计算聚焦于其区域（或体积）的标准化度量。此属性使IOU对所考虑问题的规模不变。由于这一吸引人的特性，用于评估分段、目标检测和跟踪的所有性能指标都依赖于这一指标。</p> 
<p>然而，可以证明，在最小化常用损失（例如“Ln-norm”）与改进其IOU值之间没有很强的相关性，这是在二维/三维中两个边界框的参数表示上定义的。例如，考虑图1（a）中的简单二维场景，其中预测的边界框（黑色矩形）和真值框（绿色矩形）由它们的左上角和右下角表示，即（x1、y1、x2、y2）。为了简单起见，假设两个框的一个角之间的距离（例如“L2-norm”）是固定的。因此，<strong>任何第二个角位于以绿色矩形第二个角为中心的固定半径圆上的预测边界框（以灰色虚线圆表示）与真值框之间的“2-范数距离”将完全相同，但是它们的IOU值可以显著不同</strong>（图1（a））。同样的论点可以扩展到任何其他表示和损失，例如图1（b）。直观地说，对于这些类型的目标来说，<span style="color:#f33b45;"><strong>一个好的局部优化未必是IOU的局部优化</strong></span>。此外，与IOU相比，基于上述参数表示定义的n-范数目标对问题的规模并不是不变的。为此，具有相同重叠级别但不同比例（例如透视）的多对边界框将具有不同的目标值。此外，一些表示可能会受到用于表示的不同类型参数之间缺乏正则化的影响。例如，在中心和大小表示中，（xc，yc）在位置空间上定义，而（w，h）属于大小空间。复杂度随着参数的增加而增加，例如旋转，或者在为问题添加更多维度时。为了缓解上述一些问题，最先进的物体探测器引入锚箱的概念作为假设良好的初始猜测。它们还定义了非线性表示来天真地补偿比例变化。即使有了这些手工制作的更改，优化回归损失和IOU值之间仍然存在差距。</p> 
<p style="text-align:center;"><img alt="" class="has" height="696" src="https://images2.imgbox.com/84/4b/rFMQSOUz_o.png" width="710"></p> 
<p>在本文中，我们探讨了两个轴对齐矩形之间或通常是两个轴对齐的N-正交体之间的IOU的计算，这是一个简单的分析解，与普遍的观点相反，在这种情况下，<span style="color:#f33b45;"><strong>IOU可以被反向传播</strong>，<strong>即它可以直接用作优化的目标函数</strong></span>。因此，最好使用IOU作为二维目标检测任务的目标函数。考虑到优化度量本身与代理损失函数之间的选择，最佳选择是度量本身。</p> 
<p><strong>然而，IOU作为度量和损失有两个主要问题：</strong></p> 
<p>（i）如果两个对象不重叠，IOU值将为零，并且不会反映两个形状彼此之间的距离。在非重叠对象的情况下，如果将IOU用作损耗，则其梯度将为零，无法优化；</p> 
<p>（ii）IOU无法正确区分两个对象的不同对齐方式。更准确地说，两个物体在多个不同方向上重叠，且交叉点水平相同，其IOU将完全相等。因此，iou函数的值并不反映两个对象之间如何发生重叠。</p> 
<h3 id="%E9%92%88%E5%AF%B9IOU%E9%97%AE%E9%A2%98%E7%9A%84%E6%94%B9%E8%BF%9B">针对IOU问题的改进</h3> 
<p>在本文中，我们将通过将IOU的概念扩展到不重叠的情况来解决IOU的这两个弱点。我们确保这种概括</p> 
<p>（a）遵循与IOU相同的定义，即将比较对象的形状属性编码为区域属性；</p> 
<p>（b）保持IOU的比例不变量属性；</p> 
<p>（c）在对象重叠的情况下确保与IOU的强相关性。</p> 
<p>我们介绍了IOU的这个广义版本，即giou，作为比较任意两个凸形的一个新指标。我们还提供了计算两个轴对齐矩形之间的giou的解析解，允许在这种情况下将其用作损失。将giou loss纳入最先进的目标检测算法中，我们始终使用基于iou的标准和新的基于giou的性能度量，在流行的目标检测基准（如pascal voc和ms coco）上提高它们的性能。</p> 
<h4 id="%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%87%8F">对象检测精度测量</h4> 
<p>联合交叉（IoU）是在对象检测中使用的事实评估度量。 它用于确定一组预测中的正确性和误差。 使用IoU作为评估指标时，必须选择准确度阈值。 例如，在PASCAL VOC挑战中，广泛报告的检测精度测量值，即平均平均精度（mAP），是基于固定的IoU阈值，即0.5来计算的。 然而，任意选择IoU阈值并不能完全反映不同方法的定位性能。 任何高于阈值的定位精度都被平等对待。 为了使此性能测量对IoU阈值的选择不那么敏感，MS COCO基准测试在多个IoU阈值中平均mAP。</p> 
<h4 id="%E8%BE%B9%E7%95%8C%E6%A1%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%8D%9F%E5%A4%B1">边界框表示和损失</h4> 
<p>在2D对象检测中，学习边界框参数是至关重要的。在文献中已经提出了各种边界框表示和损失，如 Redmon等。在YOLO v1 中提出了对边界框参数的直接回归，并用一个小的调整来预测边界框大小的平方根，以弥补尺度灵敏度。 Girshick等。 RCNN中的通过预测来自使用选择性搜索算法计算的先前边界框的位置和大小偏移来参数化边界框表示[。为了减轻表示的缩放灵敏度，在日志空间中定义边界框大小偏移。然后，使用“2范数目标”（也称为MSE损失）作为优化目标。后来，在快速R-CNN 中，Girshick提出了“1  - 平滑损失”，使学习对异常值更加强大。任等人。 建议使用一组密集的先前边界框，称为锚框，然后回归到边界框位置和大小的小变化。然而，由于正样本和负样本之间显着的类别不平衡，这使得训练边界框分数更加困难。为了缓解这个问题，作者后来引入了焦点丢失，这与我们论文的主要焦点正交。最流行的物体检测器[20,21,3,12,13,16]利用上述边界框表示和损失的某种组合。这些相当大的努力在物体检测方面取得了显着的进步。我们表明，使用GIoU可能有一些机会进一步改进本地化，因为它们的边界框回归损失并不直接代表核心评估指标，即IoU。</p> 
<h4 id="%E4%BD%BF%E7%94%A8%E8%BF%91%E4%BC%BC%E5%87%BD%E6%95%B0%E6%88%96%E6%9B%BF%E4%BB%A3%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96IoU">使用近似函数或替代函数优化IoU</h4> 
<p>在语义分割任务中，已经尝试使用近似函数[18]或代理丢失[17]来优化IoU。 类似地，对于对象检测任务，最近的工作[8,24]已经尝试直接或间接地合并IoU以更好地执行边界框回归。 然而，它们在非重叠情况下在优化IoU时存在近似或平台。 在本文中，我们通过引入IoU的通用版本来解决IoU的弱点，该版本直接包含在内。</p> 
<h3 id="GIOU%E7%9A%84%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%8F">GIOU的算法公式</h3> 
<p style="text-align:center;"><img alt="" class="has" height="145" src="https://images2.imgbox.com/7e/96/Rom8v93U_o.png" width="410"></p> 
<h4 id="GIOU%E4%B8%8EIOU%E7%9A%84%E5%8C%BA%E5%88%AB">GIOU与IOU的区别</h4> 
<p>1.类似于IoU，GIoU作为距离，例如<img alt="" class="has" height="25" src="https://images2.imgbox.com/1c/2f/plv91jjC_o.png" width="58"> = 1  -  GIoU，保留度量的所有属性，如非负性，不可分辨的同一性，对称性和三角不等式。</p> 
<p>2.与IoU类似，GIoU对问题的规模不变。</p> 
<p>3.GIoU始终是IoU的下界，即∀A，B⊆S GIUU（A，B）≤IOU（A，B），当A和B具有更强的形状相似性和接近度时，该下界变得更紧密，即<img alt="" class="has" height="25" src="https://images2.imgbox.com/da/f8/PCrEN4Fe_o.png" width="150">= IoU（A，B）。</p> 
<p>4.<img alt="" class="has" height="18" src="https://images2.imgbox.com/4e/7b/wajpwbV6_o.png" width="220">，但是，GIoU具有对称范围如：<img alt="" class="has" height="18" src="https://images2.imgbox.com/94/f2/x8SkiLLO_o.png" width="110">−1 ≤ GIoU(A,B) ≤ 1.</p> 
<p>5.与IoU相比，GIoU不仅关注重叠区域。 当A和B相对于彼此没有很好地对准时，封闭形状C中的两个对称形状A和B之间的空白空间增加（图2）。 因此，GIoU的值可以更好地反映两个对称物体之间如何发生重叠。</p> 
<p> </p> 
<h3 id="GIOU%E7%9A%84%E8%BE%B9%E7%95%8C%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1">GIOU的边界回归损失</h3> 
<p>到目前为止，我们引入了GIoU作为任意两种任意形状的度量。 然而，与IoU的情况一样，没有分析解决方案来计算两个任意形状之间的交叉和/或为它们找到最小的封闭凸形物体<br> 幸运的是，对于2D对象检测任务，其任务是比较两个轴对齐的边界框，我们可以证明GIoU有一个简单的解决方案。 在这种情况下，交叉点和最小的封闭对象都具有矩形形状。 可以看出，它们的顶点的坐标只是被比较的两个边界框之一的坐标，这可以通过使用最小和最大函数比较每个顶点的坐标来实现。 要检查两个边界框是否重叠，还必须检查条件。 因此，我们有一个精确的解决方案来计算IoU和GIoU。</p> 
<p>由于反向传播最小，最大和分段线性函数，例如， Relu，是可行的，它可以显示Alg中的每个组件。<span style="color:#f33b45;">2</span>具有良好的导数。因此，IoU或GIoU可以直接用作损失，即LIoU或LGIoU，用于优化基于深度神经网络的物体检测器。在这种情况下，我们直接将度量标准优化为损失，这是度量标准的最佳选择。然而，在所有非重叠的情况下，IoU具有零梯度，这既影响训练质量又影响收敛速度。相比之下，GIoU在所有可能的情况下都有一个梯度，包括不重叠的情况。此外，使用属性<span style="color:#f33b45;">3</span>，我们表明，GIoU与IoU具有很强的相关性，尤其是在高IoU值时。我们还通过从两个2D矩形的参数中获取超过10K的随机样本，在图3中定性地证明了这种相关性。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/92/59/Gc5vpjJi_o.jpg"></p> 
<p>在图3中，我们还观察到在低重叠的情况下，例如， IoU≤0.2且GIoU≤0.2，与IoU相比，GIoU有机会发生更大的变化。为此，与IoU相比，在这些情况下，GIoU可能在任何可能的状态下具有更陡峭的梯度。因此，优化GIoU作为损失，LGIoU与LIoU相比可能是更好的选择，无论最终使用哪种基于IoU的性能测量。我们的实验结果证实了这一说法.</p> 
<p>公式如下：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/84/f9/U050QOue_o.jpg"></p> 
<p> </p> 
<p>就先写到这里，等我有时间推到一下后再整理。。。maybe</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00d1350f539ea80f29c8f2b43770f37c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue---前端crypto.js加解密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/683d910a4fc9b7c66a2a51d3af1880d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Failed to load resource: net::ERR_FILE_NOT_FOUND admin.js:21 Uncaught ReferenceError: echarts is not</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>