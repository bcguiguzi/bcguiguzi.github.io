<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android开发秘籍学习笔记（二） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android开发秘籍学习笔记（二）" />
<meta property="og:description" content="Android中有关线程Thread等相关知识的笔记
线程Thread 每个应用程序在创建时都会默认运行单一的进程，其中包含所有的任务。为避免用户界面被挂起，那些耗时的任务 ，诸如网络下载或密集的计算，应当驻留于单独的后台线程中，如何适当地实现这种操作由开发者决定，但之后则是由Android系统基于开发者的实现来确定线程的优先级。 大多数应用程序都通过使用线程来提升性能。如果用户界面的挂起在软件设计阶段没有被发觉，到了测试阶段就会迅速体现出来，因为Android系统会在用户界面挂起时弹出警告—告诉用户Slow app isn’t responding.
Android Thread的使用方法： Thread的使用方法主要有两种方法：其中一种是extends Thread，然后重载Thread的run()函数，另一种是构建一个新的Thread对象，可带Runnable或不带。但不管怎么样，都是要通过start()函数来运行相应的代码 构建Thread对象的方法如下： 1、Thread()不代任何参数，该方法会在构建的时候自动生成线程名字。 举例：
Thread mThread = new Thread(){ @Override public void run() { // TODO Auto-generated method stub System.out.println(&#34;This is thread_test&#34;); super.run(); } }; mThread.start(); System.out.println(mThread.getName()); 得到的logcat：
04-27 09:22:08.692: INFO/System.out(831): Thread-10 04-27 09:22:08.702: INFO/System.out(831): This is thread_test 2、Thread(Runnable runnable)该函数多了Runnable个对象，被运行的代码在Runnable对象里。 举例：
Runnable mRunnable = new Runnable(){ @Override public void run() { // TODO Auto-generated method stub System.out.println(&#34;This is thread with Runnable&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0af12d9592f355fc1c8193bd6174926e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-09T13:43:50+08:00" />
<meta property="article:modified_time" content="2015-05-09T13:43:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android开发秘籍学习笔记（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  Android中有关线程Thread等相关知识的笔记</p> 
<p><strong>线程Thread</strong> <br>   每个应用程序在创建时都会默认运行单一的进程，其中包含所有的任务。为避免用户界面被挂起，那些耗时的任务 ，诸如网络下载或密集的计算，应当驻留于单独的后台线程中，如何适当地实现这种操作由开发者决定，但之后则是由Android系统基于开发者的实现来确定线程的优先级。 <br>   大多数应用程序都通过使用线程来提升性能。如果用户界面的挂起在软件设计阶段没有被发觉，到了测试阶段就会迅速体现出来，因为Android系统会在用户界面挂起时弹出警告—告诉用户Slow app isn’t responding.</p> 
<p><strong>Android Thread的使用方法：</strong> <br>   Thread的使用方法主要有两种方法：其中一种是extends Thread，然后重载Thread的run()函数，另一种是构建一个新的Thread对象，可带Runnable或不带。但不管怎么样，都是要通过start()函数来运行相应的代码 <br> 构建Thread对象的方法如下： <br> 1、Thread()不代任何参数，该方法会在构建的时候自动生成线程名字。 <br> 举例：</p> 
<pre class="prettyprint"><code class=" hljs cs">     Thread mThread = <span class="hljs-keyword">new</span> Thread(){
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                <span class="hljs-comment">// TODO Auto-generated method stub</span>
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"This is thread_test"</span>);
                super.run();
            }
        };
        mThread.start();
        System.<span class="hljs-keyword">out</span>.println(mThread.getName());
</code></pre> 
<p>得到的logcat：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-number">04</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">22</span>:<span class="hljs-number">08.692</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">831</span>): Thread-<span class="hljs-number">10</span>
<span class="hljs-number">04</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">22</span>:<span class="hljs-number">08.702</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">831</span>): This <span class="hljs-keyword">is</span> thread_test</code></pre> 
<p>2、Thread(Runnable runnable)该函数多了Runnable个对象，被运行的代码在Runnable对象里。 <br> 举例：</p> 
<pre class="prettyprint"><code class=" hljs cs">      Runnable mRunnable = <span class="hljs-keyword">new</span> Runnable(){
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                <span class="hljs-comment">// TODO Auto-generated method stub</span>
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"This is thread with Runnable"</span>);
            }

        };
        Thread mThread = <span class="hljs-keyword">new</span> Thread(mRunnable);
        mThread.start();
        System.<span class="hljs-keyword">out</span>.println(mThread.getName());</code></pre> 
<p>得到的logcat：</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-number">0</span>4-<span class="hljs-number">27</span> <span class="hljs-number">0</span>9:<span class="hljs-number">37</span>:<span class="hljs-number">47.832</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">865</span>): Thread-<span class="hljs-number">11</span>
<span class="hljs-number">0</span>4-<span class="hljs-number">27</span> <span class="hljs-number">0</span>9:<span class="hljs-number">37</span>:<span class="hljs-number">47.861</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">865</span>): This <span class="hljs-keyword">is</span> thread <span class="hljs-keyword">with</span> Runnable</code></pre> 
<p>3、Thread(Runnable runnable,String threadName)该函数有Runnable也有自己的名字threadName。 <br> 举例：</p> 
<pre class="prettyprint"><code class=" hljs cs">     Runnable mRunnable = <span class="hljs-keyword">new</span> Runnable(){
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                <span class="hljs-comment">// TODO Auto-generated method stub</span>
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"This is thread with Runnable and Name"</span>);
            }

        };
        Thread mThread = <span class="hljs-keyword">new</span> Thread(mRunnable,<span class="hljs-string">"mThreadTest"</span>);
        mThread.start();
        System.<span class="hljs-keyword">out</span>.println(mThread.getName());</code></pre> 
<p>得到的logcat：</p> 
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-number">04</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">03.682</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">900</span>): mThreadTest
<span class="hljs-number">04</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">03.702</span>: INFO/System.<span class="hljs-keyword">out</span>(<span class="hljs-number">900</span>): This <span class="hljs-keyword">is</span> thread <span class="hljs-keyword">with</span> Runnable <span class="hljs-keyword">and</span> Name</code></pre> 
<p><strong>Runable和Thread的关系</strong> <br>   在java中可有两种方法实现多线程，一种是继承Thread类，一种是实现Runnable接口； <br> 1）继承Thread类的方式</p> 
<p>Thread类是在java.lang包中定义的 。一个类只要继承了Thread类同时覆写了本类中的run() <br> 步骤就可以实现多线程操作了，然而一个类只能继承一个父类，这是此种方法的的局限 。 下面看例子：</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Thread</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> MyThread(String name) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) {
    System.out.println(<span class="hljs-string">"线程开端："</span>+<span class="hljs-keyword">this</span>.name+<span class="hljs-string">",i="</span>+i);
    }
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo01</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) {
        MyThread mt1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"线程a"</span>);
        MyThread mt2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"线程b"</span>);
        mt1.start();
        mt2.start();
    }
}</code></pre> 
<p>2） Runnable接口</p> 
<p>  在实际开辟中一个多线程的操作很少 使用Thread类，而是通过Runnable接口实现 。 public interface Runnable{ public void run(); } <br> 例子：</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Runnable</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> MyThread(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run(){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++){
            System.out.println(<span class="hljs-string">"线程开端："</span>+<span class="hljs-keyword">this</span>.name+<span class="hljs-string">",i="</span>+i);
        }
    }
};</code></pre> 
<p>  然而在Runnable的子类中没有start() 方法，只有Thread类中才有 。此时视察Thread类，有一个构造函数：public Thread(Runnable targer) 此构造函数接受Runnable的子类实例，也就是说可以通过Thread类来启动Runnable实现多线程 。(start() 可以协调系统的资源)：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ThreadDemo01 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        MyThread mt1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"线程a"</span>);
        MyThread mt2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"线程b"</span>);
        <span class="hljs-keyword">new</span> Thread(mt1).start();
        <span class="hljs-keyword">new</span> Thread(mt2).start();
    }
}</code></pre> 
<p>3）实际中如何应用这两种实现模式 <br>   在程序实现多线程应优先以实现Runnable接口为主，由于实现Runnable接口相比继承Thread类有如下好处： <br> 1.避免点继承的局限，一个类可以继承多个接口 。 <br> 2. 利于资源的共享。 <br> 以卖票程序为例，通过Thread类实现： </p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Thread</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket=<span class="hljs-number">10</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run(){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++) {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.ticket&gt;<span class="hljs-number">0</span>){
                System.out.println(<span class="hljs-string">"卖票：ticket"</span>+<span class="hljs-keyword">this</span>.ticket--);
            }
        }
    }
};     </code></pre> 
<p>下面通过三个线程对象，同时卖票：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ThreadTicket {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        MyThread mt1=<span class="hljs-keyword">new</span> MyThread();
        MyThread mt2=<span class="hljs-keyword">new</span> MyThread();
        MyThread mt3=<span class="hljs-keyword">new</span> MyThread();
        mt1.start();<span class="hljs-comment">//每个线程都各卖了10张，共卖了30张票</span>
        mt2.start();<span class="hljs-comment">//但实际只有10张票，每个线程都卖自己的票</span>
        mt3.start();<span class="hljs-comment">//没有达到资源共享</span>
    }
}</code></pre> 
<p>  假如用Runnable就 可以实现资源共享，下面看例子：</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Runnable</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket=<span class="hljs-number">10</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run(){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++){
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.ticket&gt;<span class="hljs-number">0</span>){
                System.out.println(<span class="hljs-string">"卖票：ticket"</span>+<span class="hljs-keyword">this</span>.ticket--);
            }
        }
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableTicket</span> {<!-- --></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) {
    MyThread mt=<span class="hljs-keyword">new</span> MyThread();
    <span class="hljs-keyword">new</span> Thread(mt).start();<span class="hljs-comment">//同一个mt</span>
    <span class="hljs-keyword">new</span> Thread(mt).start();
    <span class="hljs-keyword">new</span> Thread(mt).start();
}
};</code></pre> 
<p>  现在程序中有三个线程，然而一共卖了10张票，也就是说使用Runnable实现多线程可以达到资源共享的目的。</p> 
<p>4）Runnable接口和Thread的关系总结 <br>    (1) 说白了就是类和接口的区别。Thread是一个类，java中是不允许继承多个父类的，这就是Thread的一个局限性。而使用Runnable就不同了，可以implements多个接口，同时继承一个父类，这样会更加灵活。 <br>    (2) 当多个线程需要共享资源时，用Thread很难达到目的，但是用Runnable接口就容易许多了。 <br>   (3) 二者的联系：看源码可以发现，Thread其实就是继承了Runnable接口的子类。</p> 
<p><strong>取消线程</strong> <br>   有时，当一个组件完成或被杀死是，开发者希望有它产生的线程也同样被杀死，例如在某个Acitivity中定义了线程： <br> <strong>  private …Thread myThread;</strong> <br> myThread.stop（）方法已经被弃用了，因为它会将应用程序置于不可预知的状态，取而代之的是下面的方法，比如在父组件的onStop（）方法中加入</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">if</span>(myThread <span class="hljs-subst">!=</span> <span class="hljs-built_in">null</span>){
    <span class="hljs-keyword">Thread</span> dummy <span class="hljs-subst">=</span> myThread;
    myThread <span class="hljs-subst">=</span> <span class="hljs-built_in">null</span>;
    dummy<span class="hljs-built_in">.</span>interrupt();
}</code></pre> 
<p>在应用程序层面上还有另外一种方法来完成相同的工作：使用setDaemon（true）方法将所有生成的线程都声明为守护线程，可以确保所有与应用程序关联的线程在应用程序的主线程终结时，也随之被杀死。</p> 
<pre class="prettyprint"><code class=" hljs bash">//use when initially starting a thread
myThread。<span class="hljs-keyword">set</span>Daemon（<span class="hljs-literal">true</span>);
myThread.start();</code></pre> 
<p><strong>设置线程的优先级</strong> <br>   Android系统会处理线程的优先级，默认情况下，一个新线程，如myThread，其优先级被定为5。开发者可以在myThread.start（）执行之前，通过调用myThread.setPriority（priority）来为线程设定另外的优先级。优先级不能高于Thread.MAX_PRIORITY（10）或者低于Thread.MIN_PRIORITY（1） <br>   Android还提供了另一种设定线程优先级的方法通过android.os.Process.setThreadPriority (int tid, int priority)</p> 
<p>priority：【-20, 19】，高优先级 -&gt; 低优先级。在实际操作中，因为setThreadPriority 是一个基于“良好的”Linux值得优先级，可以设定的粒度更细，并且对线程的影响也更加明显。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a98e0a881a9aae1a728249e45f9f170/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javascript中 $ 的作用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3699251bc04a22d24735e5b59f2c6fba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Targan 算法[有向图强连通分量]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>