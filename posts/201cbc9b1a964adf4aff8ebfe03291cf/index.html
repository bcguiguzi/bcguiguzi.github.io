<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C库字符串函数介绍 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C库字符串函数介绍" />
<meta property="og:description" content="1、strstr（） C 库函数 char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 &#39;\0&#39;。
下面是 strstr() 函数的声明。
char *strstr(const char *haystack, const char *needle) 参数
haystack -- 要被检索的 C 字符串。needle -- 在 haystack 字符串内要搜索的小字符串。 返回值
该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。
返回值：若str2是str1的子串，则返回str2在str1的首次出现的地址；如果str2不是str1的子串，则返回NULL。
需要注意的是haystack的长度要大于needle
示例1：
输出：str str2 str1
示例2：
char str[]=&#34;1234xyz&#34;;
char *str1=strstr(str,&#34;34&#34;);
cout 输出: 34xyz
2、char *和char[]的区别是什么 在C和C&#43;&#43;中，char*和char[]都用于表示字符数组，但它们之间存在一些重要的区别：
存储：char*是一个指向字符的指针，它只存储了一个地址，这个地址通常指向一个字符串常量或者动态分配的内存。另一方面，char[]是一个真正的字符数组，它存储了一串字符。生命周期：char[]的内存是在栈上分配的，其生命周期与包含它的函数或代码块一致。当函数或代码块执行完毕，该内存将被自动释放。另一方面，char*可以指向动态分配的内存，其生命周期取决于程序员如何管理它。如果程序员忘记释放内存，可能会导致内存泄漏。字符串常量：当char*指向一个字符串常量时，例如char* s = &#34;Hello&#34;;，实际上s只是一个指向字符串常量的指针。字符串常量是不可修改的，试图修改它会导致未定义行为。这种情况下，使用const char*更安全。另一方面，char[]可以创建一个可以修改的字符串。 下面是一些例子来说明这些区别：
// char* example char* s1 = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/201cbc9b1a964adf4aff8ebfe03291cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-02T09:10:54+08:00" />
<meta property="article:modified_time" content="2023-09-02T09:10:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C库字符串函数介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h3>1、strstr（）</h3> 
<p>C 库函数 char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\0'。</p> 
<p>下面是 strstr() 函数的声明。</p> 
<pre><code class="hljs">char *strstr(const char *haystack, const char *needle)</code></pre> 
<p><strong>参数</strong></p> 
<ul><li>haystack -- 要被检索的 C 字符串。</li><li>needle -- 在 haystack 字符串内要搜索的小字符串。</li></ul> 
<p><strong>返回值</strong></p> 
<p>该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。</p> 
<p>返回值：若str2是str1的子串，则返回str2在str1的首次出现的地址；如果str2不是str1的子串，则返回NULL。</p> 
<p><span style="color:#fe2c24;">需要注意的是haystack的长度要大于needle</span></p> 
<p></p> 
<p><strong>示例1：</strong></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/09/66/I3phVS7m_o.png" width="303"></p> 
<p>输出：str str2 str1</p> 
<p></p> 
<p>示例2：</p> 
<table><tbody><tr><td> <p>char str[]="1234xyz";</p> <p>char *str1=strstr(str,"34");</p> <p>cout </p> </td></tr></tbody></table> 
<p>输出: 34xyz</p> 
<p></p> 
<h3>2、char *和char[]的区别是什么</h3> 
<p>在C和C++中，<code>char*</code>和<code>char[]</code>都用于表示字符数组，但它们之间存在一些重要的区别：</p> 
<ol><li><strong>存储</strong>：<code>char*</code>是一个指向字符的指针，它只存储了一个地址，这个地址通常指向一个字符串常量或者动态分配的内存。另一方面，<code>char[]</code>是一个真正的字符数组，它存储了一串字符。</li><li><strong>生命周期</strong>：<code>char[]</code>的内存是在栈上分配的，其生命周期与包含它的函数或代码块一致。当函数或代码块执行完毕，该内存将被自动释放。另一方面，<code>char*</code>可以指向动态分配的内存，其生命周期取决于程序员如何管理它。如果程序员忘记释放内存，可能会导致内存泄漏。</li><li><strong>字符串常量</strong>：当<code>char*</code>指向一个字符串常量时，例如<code>char* s = "Hello";</code>，实际上<code>s</code>只是一个指向字符串常量的指针。字符串常量是不可修改的，试图修改它会导致未定义行为。这种情况下，使用<code>const char*</code>更安全。另一方面，<code>char[]</code>可以创建一个可以修改的字符串。</li></ol> 
<p>下面是一些例子来说明这些区别：</p> 
<pre><code class="language-cpp">// char* example 
char* s1 = "Hello"; // s1 is a pointer to a string literal 
printf("%s\n", s1); // Prints "Hello" 


// char[] example 
char s2[] = "Hello"; // s2 is an array of characters 
printf("%s\n", s2); // Prints "Hello" 


// Modifying a char* 
char* s3 = malloc(6 * sizeof(char)); // Allocate memory dynamically 
strcpy(s3, "Hello"); // Copy the string "Hello" into the memory pointed by s3 
s3[0] = 'h'; // Modifying the first character of the string 
printf("%s\n", s3); // Prints "hello" 
free(s3); // Don't forget to free the memory! 


// Modifying a char[] 
char s4[] = "Hello"; // s4 is an array of characters, including the '\0' terminator 
s4[0] = 'h'; // Modifying the first character of the string 
printf("%s\n", s4); // Prints "hello"</code></pre> 
<p>注意：在C++中，推荐使用<code>std::string</code>来处理字符串，因为它提供了更安全、更高效的方式来处理字符串。</p> 
<h3>C字符串</h3> 
<p>在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。</p> 
<p><strong>空字符（Null character</strong>）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。</p> 
<p>下面的声明和初始化创建了一个 <strong>RUNOOB</strong> 字符串。由于在数组的末尾存储了空字符 \0，所以字符数组的大小比单词 <strong>RUNOOB</strong> 的字符数多一个。</p> 
<pre>char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};</pre> 
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p> 
<pre>char site[] = "RUNOOB";</pre> 
<p>其实，您不需要把 null 字符放在字符串常量的末尾。<strong>C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾</strong>。让我们尝试输出上面的字符串：</p> 
<p>在使用不定长数组初始化字符串时默认结尾为 \0</p> 
<p>char greeting[] = "Hello";<br> printf("Greeting message: %s, greeting[] Length: %d\n", greeting, sizeof(greeting));</p> 
<p>输出结果:</p> 
<pre>Greeting message: Hello, greeting[] Length: 6</pre> 
<p></p> 
<p>字符数组如果不预留'0'编译器会报错,如下图所示</p> 
<p><img alt="" height="32" src="https://images2.imgbox.com/33/f9/0e0Pyuuu_o.png" width="219"></p> 
<p>再如</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/ad/0e/rHzPxFJZ_o.png" width="382"></p> 
<p><img alt="" height="56" src="https://images2.imgbox.com/e0/ee/UqMIeG5d_o.png" width="1084"></p> 
<p><strong>C 中有大量操作字符串的函数：</strong></p> 
<table><tbody><tr><th>序号</th><th>函数 &amp; 目的</th></tr><tr><td>1</td><td><strong>strcpy(s1, s2);</strong><br> 复制字符串 s2 到字符串 s1。</td></tr><tr><td>2</td><td><strong>strcat(s1, s2);</strong><br> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td>3</td><td><strong>strlen(s1);</strong><br> 返回字符串 s1 的长度。</td></tr><tr><td>4</td><td><strong>strcmp(s1, s2);</strong><br> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td>5</td><td><strong>strchr(s1, ch);</strong><br> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td>6</td><td><strong>strstr(s1, s2);</strong><br> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table> 
<p><strong>其中函数的英文全称为</strong></p> 
<p>strcmp: string compare </p> 
<p>strcat: string catenate   字符串连接</p> 
<p>strcpy: string copy </p> 
<p>strlen: string length </p> 
<p>strlwr: string lowercase </p> 
<p>strupr: string upercase</p> 
<p>下面的实例使用了上述的一些函数：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
int main ()
{
   char str1[14] = "runoob";
   char str2[14] = "google";
   char str3[14];
   int  len ;
 
   /* 复制 str1 到 str3 */
   strcpy(str3, str1);
   printf("strcpy( str3, str1) :  %s\n", str3 );
 
   /* 连接 str1 和 str2 */
   strcat( str1, str2);
   printf("strcat( str1, str2):   %s\n", str1 );
 
   /* 连接后，str1 的总长度 */
   len = strlen(str1);
   printf("strlen(str1) :  %d\n", len );
 
   return 0;
}</code></pre> 
<p></p> 
<p>转载自：<a href="https://www.runoob.com/cprogramming/c-strings.html" rel="nofollow" title="C 字符串 | 菜鸟教程 (runoob.com)">C 字符串 | 菜鸟教程 (runoob.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25589a0a124b3fa1503775d02c311158/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言文件操作入门指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9ac956ca6f849929d312cb21ee4fd04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于aarch64分析kernel源码 四：printk 内核打印</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>