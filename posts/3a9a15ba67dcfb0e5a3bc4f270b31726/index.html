<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三种线程安全的单例模式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三种线程安全的单例模式" />
<meta property="og:description" content="1、概念： 单例模式(Singleton)：又叫单态模式，它出现的目的是为了保证一个类在系统中只有一个实例，并提供一个访问它的全局访问点。即：为了可以保证系统中一个类只有一个实例而且该实例又易于外界访问，从而方便对实例个数的控制并节约系统资源而出现的解决方案；
2、应用场景： 2.1、有频繁实例化然后销毁的情况，也就是频繁的 new 对象，可以考虑单例模式；
2.2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象；
2.3、频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件；
3、线程安全的单例模式 3.1 静态内部类模式：
public class Singleton{ // 无参构造器 private Singleton(){ } // 静态内部类 private static class Innerclass{ private static final Singleton SINGLETON = new Singleton(); } public Singleton getInstance(){ return Innerclass.SINGLETON } } 3.2 双重检查锁:
public class Singleton{ // 静态可见的实例 private static volatile Singleton instance = null; // 无参构造器 private Singleton(){} public Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance ; } } 4、五种单例示例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3a9a15ba67dcfb0e5a3bc4f270b31726/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-20T10:56:26+08:00" />
<meta property="article:modified_time" content="2019-03-20T10:56:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三种线程安全的单例模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1、概念：</h4> 
<p>单例模式(Singleton)：又叫单态模式，它出现的目的是为了保证一个类在系统中只有一个实例，并提供一个访问它的全局访问点。即：为了可以保证系统中一个类只有一个实例而且该实例又易于外界访问，从而方便对实例个数的控制并节约系统资源而出现的解决方案；</p> 
<h4>2、应用场景：</h4> 
<p>2.1、有频繁实例化然后销毁的情况，也就是频繁的 new 对象，可以考虑单例模式；</p> 
<p>2.2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象；</p> 
<p>2.3、频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件；</p> 
<h4>3、线程安全的单例模式</h4> 
<p><strong>3.1 静态内部类模式：</strong></p> 
<pre class="has"><code>public class Singleton{

    // 无参构造器
    private Singleton(){

    }
    
    // 静态内部类
    private static class Innerclass{
        private static final Singleton SINGLETON = new Singleton();
    }

    public Singleton getInstance(){
        return Innerclass.SINGLETON
    }
}</code></pre> 
<p><strong>3.2 双重检查锁:</strong></p> 
<pre class="has"><code>public class Singleton{
    // 静态可见的实例
    private static volatile Singleton instance = null;
    // 无参构造器
    private Singleton(){}

    public Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance ;
    } 
}</code></pre> 
<p><strong>4、五种单例示例</strong></p> 
<pre class="has"><code>package org.sw.single;

/**
 * 单例模式
 * 
 * @Description: TODO
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */

/**
 * 饿汉式
 * 
 * @Description: TODO
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
public class Singleton {

	private static Singleton instance = new Singleton();

	private Singleton() {
	}

	public static Singleton getInstance() {
		return instance;
	}

}

/**
 * 懒汉式
 * 
 * @Description: TODO
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class LazySingleton {

	private static LazySingleton lazySingleton;

	private LazySingleton() {
	}

	private static LazySingleton getInstance() {

		if (null == lazySingleton) {
			lazySingleton = new LazySingleton();
		}
		return lazySingleton;
	}
}

/**
 * 多线程下线程安全的懒汉式单例
 * 
 * @Description: 1 同步延迟加载 — synchronized方法
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class MultiThreadSingleton {

	private static MultiThreadSingleton instance;

	private MultiThreadSingleton() {
	}

	public static synchronized MultiThreadSingleton getInstance() {
		if (null == instance) {
			instance = new MultiThreadSingleton();
		}
		return instance;
	}
}

/**
 * 多线程下线程安全的懒汉式单例
 * 
 * @Description: 2 同步延迟加载 — synchronized块
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class BlockSingle {

	private static BlockSingle instance;

	private BlockSingle() {

	}

	private static BlockSingle getInstance() {
		// 使用 synchronized 块，临界资源的同步互斥访问
		synchronized (BlockSingle.class) {
			if (null == instance) {
				instance = new BlockSingle();
			}
		}
		return instance;
	}

}

/**
 * 多线程下线程安全的懒汉式单例
 * 
 * @Description: 3 同步延迟加载 — 使用内部类实现延迟加载
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class InterClassSingleton {

	private InterClassSingleton() {
	}

	private static class InterClass {
		private static InterClassSingleton instance = new InterClassSingleton();
	}

	private static InterClassSingleton getInstance() {
		return InterClass.instance;
	}
}

/**
 * 多线程下线程安全的懒汉式单例
 * 
 * @Description: 4 双重检测（线程安全的懒汉式单例）
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class DoubleCheckSingleton {

	private static DoubleCheckSingleton instance;

	private DoubleCheckSingleton() {
	}

	private static DoubleCheckSingleton getInstance() {
		// Double.Check idiom
		if (null == instance) {
			synchronized (DoubleCheckSingleton.class) {
				if (null == instance) {
					instance = new DoubleCheckSingleton();
				}
			}
		}
		return instance;
	}
}

/**
 * 多线程下线程安全的懒汉式单例
 * 
 * @Description: 5 ThreadLocal
 * @author liangsw
 * @date 2019-07-22
 * @version 1.0v
 */
class ThreadLocalSingleton {

	// ThreadLocal 线程局部变量,将单例instance线程私有化
	private static ThreadLocal&lt;ThreadLocalSingleton&gt; threadLocal = new ThreadLocal&lt;ThreadLocalSingleton&gt;();

	private static ThreadLocalSingleton instance;

	private ThreadLocalSingleton() {
	}

	private static ThreadLocalSingleton getInstance() {
		if (threadLocal.get() == null) {
			synchronized (ThreadLocalSingleton.class) {
				if (instance == null) {
					instance = new ThreadLocalSingleton();
				}
			}
			threadLocal.set(instance);
		}
		return threadLocal.get();
	}
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f8edb30f73e672601858e945d3e5c50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jcaptcha使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d26196c2c3ffed988dd12f120338330d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js拼接html(onclick传字符串)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>