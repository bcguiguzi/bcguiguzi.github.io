<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2、RTSP协议的实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2、RTSP协议的实现" />
<meta property="og:description" content="写在前面 此系列只追求精简，旨在学习RTSP协议的实现过程，不追求复杂完美，所以这里要实现的RTSP服务器为了简单，实现上同一时间只能有一个客户端，下面开始介绍实现过程
在写一个RTSP服务器之前，我们必须知道一个RTSP服务器最简单的包含两部分，一部分是RTSP的交互，一部分是RTP发送，本文先实现RTSP交互过程
一、创建套接字 想一下我们在vlc输入rtsp://127.0.0.1:8554后发生了什么事？
在这种情况下，vlc其实是一个rtsp客户端，当输入这个url后，vlc知道目的IP为127.0.0.1，目的端口号为8854，这时vlc会发起一个tcp连接取连接服务器，连接成功后就开始发送请求，服务端响应
所以我们要写一个rtsp服务器，第一步肯定是创建tcp服务器
首先创建tcp套接字，绑定端口，监听
//1.创建套接字 serverSockfd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(serverSockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;on, sizeof(on)); //2.绑定地址和端口号 这个示例绑定的地址是INADDR_ANY，端口号为8554 bind(serverSockfd, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr) //3.开始监听 listen(serverSockfd, 10); RTSP服务器传输音视频数据和信息使用的是RTP和RTCP，所以我们还要为RTP和RTCP创建UDP套接字，并绑定号端口
//1.创建套接字 serverRtpSockfd = createUdpSocket(); serverRtcpSockfd = createUdpSocket(); //2.绑定端口号 当创建好套接字还有绑定号端口后，就可以接收客户端请求了 bindSocketAddr(serverRtpSockfd, &#34;0.0.0.0&#34;, SERVER_RTP_PORT); bindSocketAddr(serverRtcpSockfd, &#34;0.0.0.0&#34;, SERVER_RTCP_PORT); //3.开始accept等待客户端连接 clientfd = accept(serverSockfd, (struct sockaddr *)&amp;addr, &amp;len); 二、解析请求 当rtsp客户端连接成功后就会开始发送请求，服务器这是需要接收客户端请求并开始解析，再采取相应得操作
这里我们做得最简单，首先解析第一行得到方法，对于OPTIONS、DESCRIBE、PLAY、TEARDOWN我们只解析CSeq。对于SETUP，我们讲client_port解析出来
所以我们要做的第一步就是解析请求中的信息
解析完请求命令后，接下来就是更具不同得方法做不同的响应了，如下
/* * 作者：_JT_ * 博客：https://blog.csdn.net/weixin_42462202 */ if(!strcmp(method, &#34;OPTIONS&#34;)) { handleCmd_OPTIONS(); } else if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/95ce37a8a86a5ddd22710f89cd0262f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-27T00:14:44+08:00" />
<meta property="article:modified_time" content="2020-02-27T00:14:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2、RTSP协议的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>写在前面</h4> 
<p><br> 此系列只追求精简，旨在学习RTSP协议的实现过程，不追求复杂完美，所以这里要实现的RTSP服务器为了简单，实现上同一时间只能有一个客户端，下面开始介绍实现过程</p> 
<p>在写一个RTSP服务器之前，我们必须知道一个RTSP服务器最简单的包含两部分，一部分是RTSP的交互，一部分是RTP发送，本文先实现RTSP交互过程</p> 
<h4>一、创建套接字</h4> 
<p><br> 想一下我们在vlc输入rtsp://127.0.0.1:8554后发生了什么事？</p> 
<p>在这种情况下，vlc其实是一个rtsp客户端，当输入这个url后，vlc知道目的IP为127.0.0.1，目的端口号为8854，这时vlc会发起一个tcp连接取连接服务器，连接成功后就开始发送请求，服务端响应</p> 
<p>所以我们要写一个rtsp服务器，第一步肯定是创建tcp服务器</p> 
<p>首先创建tcp套接字，绑定端口，监听</p> 
<pre><code>//1.创建套接字
serverSockfd = socket(AF_INET, SOCK_STREAM, 0);
setsockopt(serverSockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;on, sizeof(on));

//2.绑定地址和端口号  这个示例绑定的地址是INADDR_ANY，端口号为8554
bind(serverSockfd, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr)

//3.开始监听
listen(serverSockfd, 10);
</code></pre> 
<p><strong><span style="color:#f33b45;">RTSP服务器传输音视频数据和信息使用的是RTP和RTCP，所以我们还要为RTP和RTCP创建UDP套接字，并绑定号端口</span></strong></p> 
<pre><code>//1.创建套接字
serverRtpSockfd = createUdpSocket();
serverRtcpSockfd = createUdpSocket();

//2.绑定端口号 当创建好套接字还有绑定号端口后，就可以接收客户端请求了
bindSocketAddr(serverRtpSockfd, "0.0.0.0", SERVER_RTP_PORT);
bindSocketAddr(serverRtcpSockfd, "0.0.0.0", SERVER_RTCP_PORT);

//3.开始accept等待客户端连接
clientfd = accept(serverSockfd, (struct sockaddr *)&amp;addr, &amp;len);
</code></pre> 
<p> </p> 
<h3>二、解析请求</h3> 
<p>当rtsp客户端连接成功后就会开始发送请求，服务器这是需要接收客户端请求并开始解析，再采取相应得操作</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/96/98/XFu3kWYs_o.png" width="756"></p> 
<p>这里我们做得最简单，首先解析<code>第一行</code>得到<code>方法</code>，对于<span style="color:#f33b45;"><code>OPTIONS</code>、<code>DESCRIBE</code>、<code>PLAY</code>、<code>TEARDOWN</code></span>我们只解析<code>CSeq</code>。对于<code>SETUP</code>，我们讲<code>client_port</code>解析出来</p> 
<p>所以我们要做的第一步就是解析请求中的信息</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/d8/bd/WwHRVX7X_o.png" width="738"></p> 
<p> </p> 
<p>解析完请求命令后，接下来就是更具不同得方法做不同的响应了，如下</p> 
<pre><code>/*
 * 作者：_JT_
 * 博客：https://blog.csdn.net/weixin_42462202
 */
if(!strcmp(method, "OPTIONS"))
{
	handleCmd_OPTIONS();
}
else if(!strcmp(method, "DESCRIBE"))
{
	handleCmd_DESCRIBE();
}
else if(!strcmp(method, "SETUP"))
{
	handleCmd_SETUP();
}
else if(!strcmp(method, "PLAY"))
{
	handleCmd_PLAY();
}
else if(!strcmp(method, "TEARDOWN"))
{
	handleCmd_TEARDOWN();
}
</code></pre> 
<p> </p> 
<h3>三、OPTIONS响应</h3> 
<p>OPTIONS是客户端向服务端请求可用的方法，我们这里就向客户端回复我们当前可用的方法</p> 
<pre><code>sprintf(sBuf, "RTSP/1.0 200 OK\r\n"
				"CSeq: %d\r\n"
				"Public: OPTIONS, DESCRIBE, SETUP, PLAY\r\n"
				"\r\n",
				cseq);
send(clientSockfd, sBuf, strlen(sBuf));
</code></pre> 
<h3>四、DESCRIBE响应</h3> 
<p>DESCRIBE是客户端向服务器请求媒体信息，这是服务器需要回复sdp描述文件，这个例子中的媒体是H.264</p> 
<ul><li> <p>sdp文件生成</p> </li></ul> 
<pre><code>sprintf(sdp, "v=0\r\n"
			"o=- 9%ld 1 IN IP4 %s\r\n"
			"t=0 0\r\n"
			"a=control:*\r\n"
			"m=video 0 RTP/AVP 96\r\n"
			"a=rtpmap:96 H264/90000\r\n"
			"a=control:track0\r\n",
			time(NULL), localIp);
</code></pre> 
<p>回复</p> 
<pre><code>sprintf(sBuf, "RTSP/1.0 200 OK\r\n"
		"CSeq: %d\r\n"
		"Content-Base: %s\r\n"
		"Content-type: application/sdp\r\n"
		"Content-length: %d\r\n\r\n"
		"%s",
		cseq,
		url,
		strlen(sdp),
		sdp);
		
send(clientSockfd, sBuf, strlen(sBuf));
</code></pre> 
<h3>五、SETUP响应</h3> 
<p>SETUP是客户端请求建立会话连接，并发送了客户端的RTP端口和RTCP端口，那么此时服务端需要回复服务端的RTP端口和RTCP端口</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/93/cc/nOzVg0UP_o.png" width="780"></p> 
<h3>六、PLAY响应</h3> 
<p>PLAY时客户端向服务器请求播放，这时服务端回复完请求后就开始通过setup过程中创建的udp套接字发送RTP包</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/04/5e/Emh4NbhI_o.png" width="805"></p> 
<h2>七、源码</h2> 
<pre><code>
 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;time.h&gt;

#define SERVER_PORT     8554
#define SERVER_RTP_PORT  55532
#define SERVER_RTCP_PORT 55533
#define BUF_MAX_SIZE    (1024*1024)

static int createTcpSocket()
{
    int sockfd;
    int on = 1;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd &lt; 0)
        return -1;

    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;on, sizeof(on));

    return sockfd;
}

static int createUdpSocket()
{
    int sockfd;
    int on = 1;

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if(sockfd &lt; 0)
        return -1;

    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;on, sizeof(on));

    return sockfd;
}

static int bindSocketAddr(int sockfd, const char* ip, int port)
{
    struct sockaddr_in addr;

    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(ip);

    if(bind(sockfd, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr)) &lt; 0)
        return -1;

    return 0;
}

static int acceptClient(int sockfd, char* ip, int* port)
{
    int clientfd;
    socklen_t len = 0;
    struct sockaddr_in addr;

    memset(&amp;addr, 0, sizeof(addr));
    len = sizeof(addr);

    clientfd = accept(sockfd, (struct sockaddr *)&amp;addr, &amp;len);
    if(clientfd &lt; 0)
        return -1;
    
    strcpy(ip, inet_ntoa(addr.sin_addr));
    *port = ntohs(addr.sin_port);

    return clientfd;
}

static char* getLineFromBuf(char* buf, char* line)
{
    while(*buf != '\n')
    {
        *line = *buf;
        line++;
        buf++;
    }

    *line = '\n';
    ++line;
    *line = '\0';

    ++buf;
    return buf; 
}

static int handleCmd_OPTIONS(char* result, int cseq)
{
    sprintf(result, "RTSP/1.0 200 OK\r\n"
                    "CSeq: %d\r\n"
                    "Public: OPTIONS, DESCRIBE, SETUP, PLAY\r\n"
                    "\r\n",
                    cseq);
                
    return 0;
}

static int handleCmd_DESCRIBE(char* result, int cseq, char* url)
{
    char sdp[500];
    char localIp[100];

    sscanf(url, "rtsp://%[^:]:", localIp);

    sprintf(sdp, "v=0\r\n"
                 "o=- 9%ld 1 IN IP4 %s\r\n"
                 "t=0 0\r\n"
                 "a=control:*\r\n"
                 "m=video 0 RTP/AVP 96\r\n"
                 "a=rtpmap:96 H264/90000\r\n"
                 "a=control:track0\r\n",
                 time(NULL), localIp);
    
    sprintf(result, "RTSP/1.0 200 OK\r\nCSeq: %d\r\n"
                    "Content-Base: %s\r\n"
                    "Content-type: application/sdp\r\n"
                    "Content-length: %d\r\n\r\n"
                    "%s",
                    cseq,
                    url,
                    strlen(sdp),
                    sdp);
    
    return 0;
}

static int handleCmd_SETUP(char* result, int cseq, int clientRtpPort)
{
    sprintf(result, "RTSP/1.0 200 OK\r\n"
                    "CSeq: %d\r\n"
                    "Transport: RTP/AVP;unicast;client_port=%d-%d;server_port=%d-%d\r\n"
                    "Session: 66334873\r\n"
                    "\r\n",
                    cseq,
                    clientRtpPort,
                    clientRtpPort+1,
                    SERVER_RTP_PORT,
                    SERVER_RTCP_PORT);
    
    return 0;
}

static int handleCmd_PLAY(char* result, int cseq)
{
    sprintf(result, "RTSP/1.0 200 OK\r\n"
                    "CSeq: %d\r\n"
                    "Range: npt=0.000-\r\n"
                    "Session: 66334873; timeout=60\r\n\r\n",
                    cseq);
    
    return 0;
}

static void doClient(int clientSockfd, const char* clientIP, int clientPort,
                        int serverRtpSockfd, int serverRtcpSockfd)
{
    char method[40];
    char url[100];
    char version[40];
    int cseq;
    int clientRtpPort, clientRtcpPort;
    char *bufPtr;
    char* rBuf = malloc(BUF_MAX_SIZE);
    char* sBuf = malloc(BUF_MAX_SIZE);
    char line[400];

    while(1)
    {
        int recvLen;

        recvLen = recv(clientSockfd, rBuf, BUF_MAX_SIZE, 0);
        if(recvLen &lt;= 0)
            goto out;

        rBuf[recvLen] = '\0';
        printf("---------------C-&gt;S--------------\n");
        printf("%s", rBuf);

        /* 解析方法 */
        bufPtr = getLineFromBuf(rBuf, line);
        if(sscanf(line, "%s %s %s\r\n", method, url, version) != 3)
        {
            printf("parse err\n");
            goto out;
        }

        /* 解析序列号 */
        bufPtr = getLineFromBuf(bufPtr, line);
        if(sscanf(line, "CSeq: %d\r\n", &amp;cseq) != 1)
        {
            printf("parse err\n");
            goto out;
        }

        /* 如果是SETUP，那么就再解析client_port */
        if(!strcmp(method, "SETUP"))
        {
            while(1)
            {
                bufPtr = getLineFromBuf(bufPtr, line);
                if(!strncmp(line, "Transport:", strlen("Transport:")))
                {
                    sscanf(line, "Transport: RTP/AVP;unicast;client_port=%d-%d\r\n",
                                    &amp;clientRtpPort, &amp;clientRtcpPort);
                    break;
                }
            }
        }

        if(!strcmp(method, "OPTIONS"))
        {
            if(handleCmd_OPTIONS(sBuf, cseq))
            {
                printf("failed to handle options\n");
                goto out;
            }
        }
        else if(!strcmp(method, "DESCRIBE"))
        {
            if(handleCmd_DESCRIBE(sBuf, cseq, url))
            {
                printf("failed to handle describe\n");
                goto out;
            }
        }
        else if(!strcmp(method, "SETUP"))
        {
            if(handleCmd_SETUP(sBuf, cseq, clientRtpPort))
            {
                printf("failed to handle setup\n");
                goto out;
            }
        }
        else if(!strcmp(method, "PLAY"))
        {
            if(handleCmd_PLAY(sBuf, cseq))
            {
                printf("failed to handle play\n");
                goto out;
            }
        }
        else
        {
            goto out;
        }

        printf("---------------S-&gt;C--------------\n");
        printf("%s", sBuf);
        send(clientSockfd, sBuf, strlen(sBuf), 0);
    }
out:
    close(clientSockfd);
    free(rBuf);
    free(sBuf);
}

int main(int argc, char* argv[])
{
    int serverSockfd;
    int serverRtpSockfd, serverRtcpSockfd;
    int ret;

    serverSockfd = createTcpSocket();
    if(serverSockfd &lt; 0)
    {
        printf("failed to create tcp socket\n");
        return -1;
    }

    ret = bindSocketAddr(serverSockfd, "0.0.0.0", SERVER_PORT);
    if(ret &lt; 0)
    {
        printf("failed to bind addr\n");
        return -1;
    }

    ret = listen(serverSockfd, 10);
    if(ret &lt; 0)
    {
        printf("failed to listen\n");
        return -1;
    }

    serverRtpSockfd = createUdpSocket();
    serverRtcpSockfd = createUdpSocket();
    if(serverRtpSockfd &lt; 0 || serverRtcpSockfd &lt; 0)
    {
        printf("failed to create udp socket\n");
        return -1;
    }

    if(bindSocketAddr(serverRtpSockfd, "0.0.0.0", SERVER_RTP_PORT) &lt; 0 ||
        bindSocketAddr(serverRtcpSockfd, "0.0.0.0", SERVER_RTCP_PORT) &lt; 0)
    {
        printf("failed to bind addr\n");
        return -1;
    }

    printf("rtsp://127.0.0.1:%d\n", SERVER_PORT);

    while(1)
    {
        int clientSockfd;
        char clientIp[40];
        int clientPort;

        clientSockfd = acceptClient(serverSockfd, clientIp, &amp;clientPort);
        if(clientSockfd &lt; 0)
        {
            printf("failed to accept client\n");
            return -1;
        }

        printf("accept client;client ip:%s,client port:%d\n", clientIp, clientPort);

        doClient(clientSockfd, clientIp, clientPort, serverRtpSockfd, serverRtcpSockfd);
    }

    return 0;
}
</code></pre> 
<h2>八、测试</h2> 
<p>编译运行源码，打开vlc，输入rtsp://127.0.0.1:8554，点击开始播放，可以看到控制台会打印出交互过程，或是用wireshak抓包</p> 
<p>本篇文章到这里结束，至此完成了RTSP协议的交互部分，在PLAY之后并没有开始发送RTP包，所以暂时还看不到视频，究竟如何发送RTP包，请看下一篇文章<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/925862d0762ecc89da83761d35626872/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">antd-设置RangePicker默认选择时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/589e63372d31b86c358ae25af7b540c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2019年度精选文章</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>