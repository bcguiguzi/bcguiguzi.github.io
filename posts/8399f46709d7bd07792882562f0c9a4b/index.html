<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Retrofit2 完全解析 探索与okhttp之间的关系 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Retrofit2 完全解析 探索与okhttp之间的关系" />
<meta property="og:description" content="转载请标明出处： http://blog.csdn.net/lmj623565791/article/details/51304204； 本文出自:【张鸿洋的博客】
一、概述 之前写了个okhttputils的工具类，然后有很多同学询问这个工具类和retrofit什么区别，于是上了下官网，发现其底层对网络的访问默认也是基于okhttp，不过retrofit非常适合于restful url格式的请求，更多使用注解的方式提供功能。
既然这样，我们本篇博文首先研究其所提供的常用的用法：
一般的get、post请求动态url，动态参数设置，各种注解的使用上传文件（单文件，多文件上传等）下载文件等（这个不推荐retrofit去做，具体看下文） 此外，由于其内部提供了ConverterFactory用于对返回的requestBody进行转化和特殊的requestBody的构造，所以本文也包含：
如何自定义ConverterFactory 最后呢，因为其源码并不复杂，本文将对源码进行整体的介绍，即
retrofit 源码分析 ok，说这么多，既然需要restful url，我只能捡起我那个半桶水的spring mvc 搭建一个服务端的小例子~~
最后本文使用版本：
compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39; 主要是源码解析，自定义Converter.Factory等一些细节的探索。
恩，写完后，发现本文很长，中途请没事站起来走两步。
retrofit2官网地址：https://github.com/square/retrofit/
二、retrofit 用法示例 (1)一般的get请求 retrofit在使用的过程中，需要定义一个接口对象，我们首先演示一个最简单的get请求，接口如下所示：
public interface IUserBiz { @GET(&#34;users&#34;) Call&lt;List&lt;User&gt;&gt; getUsers(); } 可以看到有一个getUsers(）方法，通过@GET注解标识为get请求，@GET中所填写的value和baseUrl组成完整的路径，baseUrl在构造retrofit对象时给出。
下面看如何通过retrofit完成上述的请求：
Retrofit retrofit = new Retrofit.Builder() .baseUrl(&#34;http://192.168.31.242:8080/springmvc_users/user/&#34;) .addConverterFactory(GsonConverterFactory.create()) .build(); IUserBiz userBiz = retrofit.create(IUserBiz.class); Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsers(); call.enqueue(new Callback&lt;List&lt;User&gt;&gt;() { @Override public void onResponse(Call&lt;List&lt;User&gt;&gt; call, Response&lt;List&lt;User&gt;&gt; response) { Log.e(TAG, &#34;normalGet:&#34; &#43; response.body() &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8399f46709d7bd07792882562f0c9a4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-04T10:02:00+08:00" />
<meta property="article:modified_time" content="2016-05-04T10:02:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Retrofit2 完全解析 探索与okhttp之间的关系</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="markdown_views"> 
 <blockquote> 
  <p>转载请标明出处： <br><a href="http://blog.csdn.net/lmj623565791/article/details/51304204">http://blog.csdn.net/lmj623565791/article/details/51304204</a>； <br> 本文出自:<a href="http://blog.csdn.net/lmj623565791/">【张鸿洋的博客】</a></p> 
 </blockquote> 
 <h3 id="一概述">一、概述</h3> 
 <p>之前写了个okhttputils的工具类，然后有很多同学询问这个工具类和<code>retrofit</code>什么区别，于是上了下官网，发现其底层对网络的访问默认也是基于<code>okhttp</code>，不过<code>retrofit</code>非常适合于<code>restful url</code>格式的请求，更多使用注解的方式提供功能。</p> 
 <p>既然这样，我们本篇博文首先研究其所提供的常用的用法：</p> 
 <ul><li>一般的get、post请求</li><li>动态url，动态参数设置，各种注解的使用</li><li>上传文件（单文件，多文件上传等）</li><li>下载文件等（这个不推荐retrofit去做，具体看下文）</li></ul> 
 <p>此外，由于其内部提供了<code>ConverterFactory</code>用于对返回的<code>requestBody</code>进行转化和特殊的<code>requestBody</code>的构造，所以本文也包含：</p> 
 <ul><li>如何自定义<code>ConverterFactory</code> </li></ul> 
 <p>最后呢，因为其源码并不复杂，本文将对源码进行整体的介绍，即</p> 
 <ul><li>retrofit 源码分析</li></ul> 
 <p>ok，说这么多，既然需要<code>restful url</code>，我只能捡起我那个半桶水的spring mvc 搭建一个服务端的小例子~~</p> 
 <p>最后本文使用版本：</p> 
 <pre class="prettyprint"><code class="hljs bash">compile <span class="hljs-string">'com.squareup.retrofit2:retrofit:2.0.2'</span></code></pre> 
 <p>主要是源码解析，自定义<code>Converter.Factory</code>等一些细节的探索。</p> 
 <p>恩，写完后，发现本文很长，中途请没事站起来走两步。</p> 
 <p>retrofit2官网地址：<a href="https://github.com/square/retrofit/">https://github.com/square/retrofit/</a></p> 
 <h3 id="二retrofit-用法示例">二、retrofit 用法示例</h3> 
 <h4 id="1一般的get请求">(1)一般的get请求</h4> 
 <p><code>retrofit</code>在使用的过程中，需要定义一个接口对象，我们首先演示一个最简单的get请求，接口如下所示：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"users"</span>)
    Call&lt;List&lt;User&gt;&gt; getUsers();
}</code></pre> 
 <p>可以看到有一个getUsers(）方法，通过<code>@GET</code>注解标识为get请求，<code>@GET</code>中所填写的value和<code>baseUrl</code>组成完整的路径，<code>baseUrl</code>在构造retrofit对象时给出。</p> 
 <p>下面看如何通过<code>retrofit</code>完成上述的请求：</p> 
 <pre class="prettyprint"><code class="language-java hljs">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()
        .baseUrl(<span class="hljs-string">"http://192.168.31.242:8080/springmvc_users/user/"</span>)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
IUserBiz userBiz = retrofit.create(IUserBiz.class);
Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsers();
        call.enqueue(<span class="hljs-keyword">new</span> Callback&lt;List&lt;User&gt;&gt;()
        {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call&lt;List&lt;User&gt;&gt; call, Response&lt;List&lt;User&gt;&gt; response)
            {
                Log.e(TAG, <span class="hljs-string">"normalGet:"</span> + response.body() + <span class="hljs-string">""</span>);
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call&lt;List&lt;User&gt;&gt; call, Throwable t)
            {

            }
        });</code></pre> 
 <p>依然是构造者模式，指定了<code>baseUrl</code>和<code>Converter.Factory</code>，该对象通过名称可以看出是用于对象转化的，本例因为服务器返回的是json格式的数组，所以这里设置了<code>GsonConverterFactory</code>完成对象的转化。</p> 
 <p>ok，这里可以看到很神奇，我们通过<code>Retrofit.create</code>就可以拿到我们定义的<code>IUserBiz</code>的实例，调用其方法即可拿到一个<code>Call</code>对象，通过<code>call.enqueue</code>即可完成异步的请求。</p> 
 <p>具体retrofit怎么得到我们接口的实例的，以及对象的返回结果是如何转化的，我们后面具体分析。</p> 
 <p>这里需要指出的是：</p> 
 <ol><li>接口中的方法必须有返回值，且比如是<code>Call&lt;T&gt;</code>类型</li><li> <p><code>.addConverterFactory(GsonConverterFactory.create())</code>这里如果使用gson，需要额外导入：</p> <pre><code>compile 'com.squareup.retrofit2:converter-gson:2.0.2'
</code></pre> <p>当然除了gson以外，还提供了以下的选择：</p> <pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre> <p>当然也支持自定义，你可以选择自己写转化器完成数据的转化，这个后面将具体介绍。</p> </li><li><p>既然<code>call.enqueue</code>是异步的访问数据，那么同步的访问方式为<code>call.execute</code>，这一点非常类似okhttp的API，实际上默认情况下内部也是通过<code>okhttp3.Call</code>实现。</p></li></ol> 
 <p>那么，通过这么一个简单的例子，应该对<code>retrofit</code>已经有了一个直观的认识，下面看更多其支持的特性。</p> 
 <h4 id="2动态的url访问path">（2）动态的url访问<code>@PATH</code> </h4> 
 <p>文章开头提过，<code>retrofit</code>非常适用于<code>restful url</code>的格式，那么例如下面这样的url：</p> 
 <pre class="prettyprint"><code class="hljs cs"><span class="hljs-comment">//用于访问zhy的信息</span>
http:<span class="hljs-comment">//192.168.1.102:8080/springmvc_users/user/zhy</span>
<span class="hljs-comment">//用于访问lmj的信息</span>
http:<span class="hljs-comment">//192.168.1.102:8080/springmvc_users/user/lmj</span></code></pre> 
 <p>即通过不同的username访问不同用户的信息，返回数据为json字符串。</p> 
 <p>那么可以通过retrofit提供的<code>@PATH</code>注解非常方便的完成上述需求。</p> 
 <p>我们再定义一个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"{username}"</span>)
    Call&lt;User&gt; getUser(<span class="hljs-annotation">@Path</span>(<span class="hljs-string">"username"</span>) String username);
}</code></pre> 
 <p>可以看到我们定义了一个getUser方法，方法接收一个username参数，并且我们的<code>@GET</code>注解中使用<code>{username}</code>声明了访问路径，这里你可以把<code>{username}</code>当做占位符，而实际运行中会通过<code>@PATH("username")</code>所标注的参数进行替换。</p> 
 <p>那么访问的代码很类似：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-comment">//省略了retrofit的构建代码</span>
Call&lt;User&gt; call = userBiz.getUser(<span class="hljs-string">"zhy"</span>);
<span class="hljs-comment">//Call&lt;User&gt; call = userBiz.getUser("lmj");</span>
call.enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;()
{

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call&lt;User&gt; call, Response&lt;User&gt; response)
    {
        Log.e(TAG, <span class="hljs-string">"getUsePath:"</span> + response.body());
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call&lt;User&gt; call, Throwable t)
    {

    }
});
</code></pre> 
 <h4 id="3查询参数的设置query">（3）查询参数的设置<code>@Query</code> </h4> 
 <p>看下面的url</p> 
 <pre class="prettyprint"><code class="hljs cs">http:<span class="hljs-comment">//baseurl/users?sortby=username</span>
http:<span class="hljs-comment">//baseurl/users?sortby=id</span></code></pre> 
 <p>即一般的传参，我们可以通过<code>@Query</code>注解方便的完成，我们再次在接口中添加一个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"users"</span>)
    Call&lt;List&lt;User&gt;&gt; getUsersBySort(<span class="hljs-annotation">@Query</span>(<span class="hljs-string">"sortby"</span>) String sort);
}</code></pre> 
 <p>访问的代码，其实没什么写的：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-comment">//省略retrofit的构建代码</span>
Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsersBySort(<span class="hljs-string">"username"</span>);
<span class="hljs-comment">//Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsersBySort("id");</span>
<span class="hljs-comment">//省略call执行相关代码</span></code></pre> 
 <p>ok，这样我们就完成了参数的指定，当然相同的方式也适用于POST，只需要把注解修改为<code>@POST</code>即可。</p> 
 <p>对了，我能刚才学了<code>@PATH</code>，那么会不会有这样尝试的冲动，对于刚才的需求，我们这么写：</p> 
 <pre class="prettyprint"><code class="language-java hljs"> <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"users?sortby={sortby}"</span>)
 Call&lt;List&lt;User&gt;&gt; getUsersBySort(<span class="hljs-annotation">@Path</span>(<span class="hljs-string">"sortby"</span>) String sort);</code></pre> 
 <p>乍一看别说好像有点感觉，哈，实际上运行是不支持的~估计是<code>@ Path</code>的定位就是用于url的路径而不是参数，对于参数还是选择通过<code>@Query</code>来设置。</p> 
 <h4 id="4post请求体的方式向服务器传入json字符串body">（4）POST请求体的方式向服务器传入json字符串<code>@Body</code> </h4> 
 <p>大家都清楚，我们app很多时候跟服务器通信，会选择直接使用POST方式将json字符串作为请求体发送到服务器，那么我们看看这个需求使用<code>retrofit</code>该如何实现。</p> 
 <p>再次添加一个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
 <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"add"</span>)
 Call&lt;List&lt;User&gt;&gt; addUser(<span class="hljs-annotation">@Body</span> User user);
}</code></pre> 
 <p>提交的代码其实基本都是一致的：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-comment">//省略retrofit的构建代码</span>
 Call&lt;List&lt;User&gt;&gt; call = userBiz.addUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1001</span>, <span class="hljs-string">"jj"</span>, <span class="hljs-string">"123,"</span>, <span class="hljs-string">"jj123"</span>, <span class="hljs-string">"jj@qq.com"</span>));
<span class="hljs-comment">//省略call执行相关代码</span></code></pre> 
 <p>ok，可以看到其实就是使用<code>@Body</code>这个注解标识我们的参数对象即可，那么这里需要考虑一个问题，retrofit是如何将user对象转化为字符串呢？下文将详细解释~</p> 
 <p>下面对应okhttp，还有两种requestBody，一个是<code>FormBody</code>，一个是<code>MultipartBody</code>，前者以表单的方式传递简单的键值对，后者以POST表单的方式上传文件可以携带参数，<code>retrofit</code>也二者也有对应的注解，下面继续~</p> 
 <h4 id="5表单的方式传递键值对formurlencoded">（5）表单的方式传递键值对<code>@FormUrlEncoded</code> </h4> 
 <p>这里我们模拟一个登录的方法，添加一个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"login"</span>)
    <span class="hljs-annotation">@FormUrlEncoded</span>
    Call&lt;User&gt; login(<span class="hljs-annotation">@Field</span>(<span class="hljs-string">"username"</span>) String username, <span class="hljs-annotation">@Field</span>(<span class="hljs-string">"password"</span>) String password);
}</code></pre> 
 <p>访问的代码：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-comment">//省略retrofit的构建代码</span>
Call&lt;User&gt; call = userBiz.login(<span class="hljs-string">"zhy"</span>, <span class="hljs-string">"123"</span>);
<span class="hljs-comment">//省略call执行相关代码</span></code></pre> 
 <p>ok，看起来也很简单，通过<code>@POST</code>指明url，添加<code>FormUrlEncoded</code>，然后通过<code>@Field</code>添加参数即可。</p> 
 <h4 id="6单文件上传multipart">（6）单文件上传<code>@Multipart</code> </h4> 
 <p>下面看一下单文件上传，依然是再次添加个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@Multipart</span>
    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"register"</span>)
    Call&lt;User&gt; registerUser(<span class="hljs-annotation">@Part</span> MultipartBody.Part photo, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"username"</span>) RequestBody username, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"password"</span>) RequestBody password);
}
</code></pre> 
 <p>这里<code>@MultiPart</code>的意思就是允许多个<code>@Part</code>了，我们这里使用了3个<code>@Part</code>，第一个我们准备上传个文件，使用了<code>MultipartBody.Part</code>类型，其余两个均为简单的键值对。</p> 
 <p>使用：</p> 
 <pre class="prettyprint"><code class="language-java hljs">File file = <span class="hljs-keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="hljs-string">"icon.png"</span>);
RequestBody photoRequestBody = RequestBody.create(MediaType.parse(<span class="hljs-string">"image/png"</span>), file);
MultipartBody.Part photo = MultipartBody.Part.createFormData(<span class="hljs-string">"photos"</span>, <span class="hljs-string">"icon.png"</span>, photoRequestBody);

Call&lt;User&gt; call = userBiz.registerUser(photo, RequestBody.create(<span class="hljs-keyword">null</span>, <span class="hljs-string">"abc"</span>), RequestBody.create(<span class="hljs-keyword">null</span>, <span class="hljs-string">"123"</span>));</code></pre> 
 <p>ok，这里感觉略为麻烦。不过还是蛮好理解~~多个<code>@Part</code>，每个Part对应一个RequestBody。</p> 
 <p>这里插个实验过程，其实我最初对于文件，也是尝试的<code>@Part RequestBody</code>，因为<code>@Part("key")</code>，然后传入一个代表文件的<code>RequestBody</code>，我觉得更加容易理解，后来发现试验无法成功，而且查了下issue，给出了一个很奇怪的解决方案，这里可以参考：<a href="https://github.com/square/retrofit/issues/1063">retrofit#1063</a>。</p> 
 <p>给出了一个类似如下的方案：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiInterface</span> {<!-- --></span>
        <span class="hljs-annotation">@Multipart</span>
        <span class="hljs-annotation">@POST</span> (<span class="hljs-string">"/api/Accounts/editaccount"</span>)
        Call&lt;User&gt; editUser (<span class="hljs-annotation">@Header</span>(<span class="hljs-string">"Authorization"</span>) String authorization, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"file\"; filename=\"pp.png"</span>) RequestBody file , <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"FirstName"</span>) RequestBody fname, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"Id"</span>) RequestBody id);
    }</code></pre> 
 <p>可以看到对于文件的那个<code>@Part</code>value竟然写了这么多奇怪的东西，而且filename竟然硬编码了~~这个不好吧，我上传的文件名竟然不能动态指定。</p> 
 <p>为了文件名不会被写死，所以给出了最上面的上传单文件的方法，ps:上面这个方案经测试也是可以上传成功的。</p> 
 <p>恩，这个奇怪方案，为什么这么做可行，下文会给出非常详细的解释。</p> 
 <p>最后看下多文件上传~</p> 
 <h4 id="7多文件上传partmap">（7）多文件上传<code>@PartMap</code> </h4> 
 <p>再添加一个方法~~~</p> 
 <pre class="prettyprint"><code class="language-java hljs"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
 {<!-- --></span>
     <span class="hljs-annotation">@Multipart</span>
     <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"register"</span>)
      Call&lt;User&gt; registerUser(<span class="hljs-annotation">@PartMap</span> Map&lt;String, RequestBody&gt; params,  <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"password"</span>) RequestBody password);
}</code></pre> 
 <p>这里使用了一个新的注解<code>@PartMap</code>，这个注解用于标识一个Map，Map的key为String类型，代表上传的键值对的key(与服务器接受的key对应),value即为RequestBody，有点类似<code>@Part</code>的封装版本。</p> 
 <p>执行的代码：</p> 
 <pre class="prettyprint"><code class="language-java hljs">File file = <span class="hljs-keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="hljs-string">"messenger_01.png"</span>);
        RequestBody photo = RequestBody.create(MediaType.parse(<span class="hljs-string">"image/png"</span>, file);
Map&lt;String,RequestBody&gt; photos = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
photos.put(<span class="hljs-string">"photos\"; filename=\"icon.png"</span>, photo);
photos.put(<span class="hljs-string">"username"</span>,  RequestBody.create(<span class="hljs-keyword">null</span>, <span class="hljs-string">"abc"</span>));

Call&lt;User&gt; call = userBiz.registerUser(photos, RequestBody.create(<span class="hljs-keyword">null</span>, <span class="hljs-string">"123"</span>));
</code></pre> 
 <p>可以看到，可以在Map中put进一个或多个文件，键值对等，当然你也可以分开，单独的键值对也可以使用<code>@Part</code>，这里又看到设置文件的时候，相对应的key很奇怪，例如上例<code>"photos\"; filename=\"icon.png"</code>,前面的photos就是与服务器对应的key，后面filename是服务器得到的文件名，ok，参数虽然奇怪，但是也可以动态的设置文件名，不太影响使用~~</p> 
 <h4 id="8下载文件">（8）下载文件</h4> 
 <p>这个其实我觉得直接使用okhttp就好了，使用retrofit去做这个事情真的有点瞎用的感觉~~</p> 
 <p>增加一个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-annotation">@GET</span>(<span class="hljs-string">"download"</span>)
Call&lt;ResponseBody&gt; downloadTest();</code></pre> 
 <p>调用：</p> 
 <pre class="prettyprint"><code class="language-java hljs">Call&lt;ResponseBody&gt; call = userBiz.downloadTest();
call.enqueue(<span class="hljs-keyword">new</span> Callback&lt;ResponseBody&gt;()
{
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)
    {
        InputStream is = response.body().byteStream();
        <span class="hljs-comment">//save file</span>
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call&lt;ResponseBody&gt; call, Throwable t)
    {

    }
});</code></pre> 
 <p>可以看到可以返回<code>ResponseBody</code>，那么很多事都能干了~~</p> 
 <p>but，也看出这种方式下载感觉非常鸡肋，并且onReponse回调虽然在UI线程，但是你还是要处理io操作，也就是说你在这里还要另外开线程操作，或者你可以考虑同步的方式下载。</p> 
 <p>最后还是建议使用okhttp去下载，例如使用<a href="https://github.com/hongyangAndroid/okhttp-utils">okhttputils</a>.</p> 
 <p>有人可能会问，使用okhttp，和使用retrofit会不会造成新建多个<code>OkHttpClient</code>对象呢，其实是可设置的，参考下文。</p> 
 <p>ok，上面就是一些常用的方法，当然还涉及到一些没有介绍的注解，但是通过上面这么多方法的介绍，再多一二个注解的使用方式，相信大家能够解决。</p> 
 <h3 id="三配置okhttpclient">三、配置OkHttpClient</h3> 
 <p>这个需要简单提一下，很多时候，比如你使用retrofit需要统一的log管理，给每个请求添加统一的header等，这些都应该通过okhttpclient去操作，比如<code>addInterceptor</code></p> 
 <p>例如：</p> 
 <pre class="prettyprint"><code class="language-java hljs">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder().addInterceptor(<span class="hljs-keyword">new</span> Interceptor()<span class="hljs-comment">//log，统一的header等</span>
{
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> okhttp3.Response <span class="hljs-title">intercept</span>(Chain chain) <span class="hljs-keyword">throws</span> IOException
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}).build();</code></pre> 
 <p>或许你需要更多的配置，你可以单独写一个OkhttpClient的单例生成类，在这个里面完成你所需的所有的配置，然后将<code>OkhttpClient</code>实例通过方法公布出来，设置给retrofit。</p> 
 <p>设置方式：</p> 
 <pre class="prettyprint"><code class="language-java hljs">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()
    .callFactory(OkHttpUtils.getClient())
    .build();</code></pre> 
 <p><code>callFactory</code>方法接受一个<code>okhttp3.Call.Factory</code>对象，<code>OkHttpClient</code>即为一个实现类。</p> 
 <h3 id="四retrofit-源码解析">四、retrofit 源码解析</h3> 
 <p>ok，接下来我们队retrofit的源码做简单的分析，首先我们看retrofit如何为我们的接口实现实例；然后看整体的执行流程；最后再看详细的细节； </p> 
 <h4 id="1retrofit如何为我们的接口实现实例">（1）retrofit如何为我们的接口实现实例</h4> 
 <p>通过上文的学习，我们发现使用retrofit需要去定义一个接口，然后可以通过调用<code>retrofit.create(IUserBiz.class);</code>方法，得到一个接口的实例，最后通过该实例执行我们的操作，那么retrofit如何实现我们指定接口的实例呢？</p> 
 <p>其实原理是：动态代理。但是不要被动态代理这几个词吓唬到，Java中已经提供了非常简单的API帮助我们来实现动态代理。</p> 
 <p>看源码前先看一个例子：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITest</span>
{<!-- --></span>
    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"/heiheihei"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b);

}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
{
    ITest iTest = (ITest) Proxy.newProxyInstance(ITest.class.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]{ITest.class}, <span class="hljs-keyword">new</span> InvocationHandler()
    {
        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span>(Object proxy, Method method, Object[] args) <span class="hljs-keyword">throws</span> Throwable
        {
            Integer a = (Integer) args[<span class="hljs-number">0</span>];
            Integer b = (Integer) args[<span class="hljs-number">1</span>];
            System.out.println(<span class="hljs-string">"方法名："</span> + method.getName());
            System.out.println(<span class="hljs-string">"参数："</span> + a + <span class="hljs-string">" , "</span> + b);

            GET get = method.getAnnotation(GET.class);
            System.out.println(<span class="hljs-string">"注解："</span> + get.value());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
    });
    iTest.add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
}</code></pre> 
 <p>输出结果为：</p> 
 <pre class="prettyprint"><code class="language-java hljs">方法名：add
参数：<span class="hljs-number">3</span> , <span class="hljs-number">5</span>
注解：/heiheihei</code></pre> 
 <p>可以看到我们通过<code>Proxy.newProxyInstance</code>产生的代理类，当调用接口的任何方法时，都会调用<code>InvocationHandler#invoke</code>方法，在这个方法中可以拿到传入的参数，注解等。</p> 
 <p>试想，retrofit也可以通过同样的方式，在invoke方法里面，拿到所有的参数，注解信息然后就可以去构造<code>RequestBody</code>，再去构建<code>Request</code>，得到<code>Call</code>对象封装后返回。</p> 
 <p>ok，下面看<code>retrofit#create</code>的源码：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title">create</span>(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) {
    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] { service },
        <span class="hljs-keyword">new</span> InvocationHandler() {
            <span class="hljs-annotation">@Override</span> 
            <span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span>(Object proxy, Method method, Object... args) <span class="hljs-keyword">throws</span> Throwable {
       });
  }</code></pre> 
 <p>哈，和上面对应。到这里，你应该明白retrofit为我们接口生成实例对象并不神奇，仅仅是使用了<code>Proxy</code>这个类的API而已，然后在<code>invoke</code>方法里面拿到足够的信息去构建最终返回的Call而已。</p> 
 <p>哈，其实真正的动态代理一般是有具体的实现类的，只是在这个类调用某个方法的前后去执行一些别的操作，比如开事务，打log等等。当然，本博文并不需要涉及这些详细的内容，如果你希望详细去了解，可以搜索关键字：<code>Proxy InvocationHandler</code>。</p> 
 <h4 id="2retrofit整体实现流程">（2）retrofit整体实现流程</h4> 
 <h5 id="421-retrofit的构建">4.2.1 Retrofit的构建</h5> 
 <p>这里依然是通过构造者模式进行构建retrofit对象，好在其内部的成员变量比较少，我们直接看build()方法。</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span>() {
    <span class="hljs-keyword">this</span>(Platform.get());
}

<span class="hljs-keyword">public</span> Retrofit <span class="hljs-title">build</span>() {
  <span class="hljs-keyword">if</span> (baseUrl == <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Base URL required."</span>);
  }

  okhttp3.Call.Factory callFactory = <span class="hljs-keyword">this</span>.callFactory;
  <span class="hljs-keyword">if</span> (callFactory == <span class="hljs-keyword">null</span>) {
    callFactory = <span class="hljs-keyword">new</span> OkHttpClient();
  }

  Executor callbackExecutor = <span class="hljs-keyword">this</span>.callbackExecutor;
  <span class="hljs-keyword">if</span> (callbackExecutor == <span class="hljs-keyword">null</span>) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  <span class="hljs-comment">// Make a defensive copy of the adapters and add the default Call adapter.</span>
  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  <span class="hljs-comment">// Make a defensive copy of the converters.</span>
  List&lt;Converter.Factory&gt; converterFactories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.converterFactories);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}</code></pre> 
 <ul><li>baseUrl必须指定，这个是理所当然的；</li><li>然后可以看到如果不着急设置callFactory，则默认直接<code>new OkHttpClient()</code>，可见如果你需要对okhttpclient进行详细的设置，需要构建<code>OkHttpClient</code>对象，然后传入；</li><li>接下来是callbackExecutor，这个想一想大概是用来将回调传递到UI线程了，当然这里设计的比较巧妙，利用platform对象，对平台进行判断，判断主要是利用<code>Class.forName("")</code>进行查找，具体代码已经被放到文末，如果是Android平台，会自定义一个<code>Executor</code>对象，并且利用<code>Looper.getMainLooper()</code>实例化一个handler对象，在<code>Executor</code>内部通过<code>handler.post(runnable)</code>，ok，整理凭大脑应该能构思出来，暂不贴代码了。</li><li>接下来是adapterFactories，这个对象主要用于对Call进行转化，基本上不需要我们自己去自定义。</li><li>最后是converterFactories，该对象用于转化数据，例如将返回的<code>responseBody</code>转化为对象等；当然不仅仅是针对返回的数据，还能用于一般备注解的参数的转化例如<code>@Body</code>标识的对象做一些操作，后面遇到源码详细再描述。</li></ul> 
 <p>ok，总体就这几个对象去构造retrofit，还算比较少的~~</p> 
 <h5 id="422-具体call构建流程">4.2.2 具体Call构建流程</h5> 
 <p>我们构造完成retrofit，就可以利用retrofit.create方法去构建接口的实例了，上面我们已经分析了这个环节利用了动态代理，而且我们也分析了具体的Call的构建流程在invoke方法中，下面看代码：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title">create</span>(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) {
    Utils.validateServiceInterface(service);
    <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] { service },
        <span class="hljs-keyword">new</span> InvocationHandler() {
           <span class="hljs-annotation">@Override</span> 
          <span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span>(Object proxy, Method method, Object... args){
            <span class="hljs-comment">//...</span>
            ServiceMethod serviceMethod = loadServiceMethod(method);
            OkHttpCall okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);
            <span class="hljs-keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);
          }
        });
}
</code></pre> 
 <p>主要也就三行代码，第一行是根据我们的method将其包装成ServiceMethod，第二行是通过ServiceMethod和方法的参数构造<code>retrofit2.OkHttpCall</code>对象，第三行是通过<code>serviceMethod.callAdapter.adapt()</code>方法，将<code>OkHttpCall</code>进行代理包装；</p> 
 <p>下面一个一个介绍：</p> 
 <ul><li>ServiceMethod应该是最复杂的一个类了，包含了将一个method转化为Call的所有的信息。</li></ul> 
 <pre class="prettyprint"><code class="language-java hljs">#Retrofit class
ServiceMethod loadServiceMethod(Method method) {
    ServiceMethod result;
    <span class="hljs-keyword">synchronized</span> (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {
        result = <span class="hljs-keyword">new</span> ServiceMethod.Builder(<span class="hljs-keyword">this</span>, method).build();
        serviceMethodCache.put(method, result);
      }
    }
    <span class="hljs-keyword">return</span> result;
  }

#ServiceMethod
<span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span>() {
      callAdapter = createCallAdapter();
      responseType = callAdapter.responseType();
      <span class="hljs-keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) {
        <span class="hljs-keyword">throw</span> methodError(<span class="hljs-string">"'"</span>
            + Utils.getRawType(responseType).getName()
            + <span class="hljs-string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);
      }
      responseConverter = createResponseConverter();

      <span class="hljs-keyword">for</span> (Annotation annotation : methodAnnotations) {
        parseMethodAnnotation(annotation);
      }


      <span class="hljs-keyword">int</span> parameterCount = parameterAnnotationsArray.length;
      parameterHandlers = <span class="hljs-keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; parameterCount; p++) {
        Type parameterType = parameterTypes[p];
        <span class="hljs-keyword">if</span> (Utils.hasUnresolvableType(parameterType)) {
          <span class="hljs-keyword">throw</span> parameterError(p, <span class="hljs-string">"Parameter type must not include a type variable or wildcard: %s"</span>,
              parameterType);
        }

        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
        <span class="hljs-keyword">if</span> (parameterAnnotations == <span class="hljs-keyword">null</span>) {
          <span class="hljs-keyword">throw</span> parameterError(p, <span class="hljs-string">"No Retrofit annotation found."</span>);
        }

        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(<span class="hljs-keyword">this</span>);
    }</code></pre> 
 <p>直接看build方法，首先拿到这个callAdapter最终拿到的是我们在构建retrofit里面时adapterFactories时添加的，即为：<code>new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call)</code>，该<code>ExecutorCallbackCall</code>唯一做的事情就是将原本call的回调转发至UI线程。</p> 
 <p>接下来通过<code>callAdapter.responseType()</code>返回的是我们方法的实际类型，例如:<code>Call&lt;User&gt;</code>,则返回<code>User</code>类型，然后对该类型进行判断。</p> 
 <p>接下来是<code>createResponseConverter</code>拿到responseConverter对象，其当然也是根据我们构建retrofit时,<code>addConverterFactory</code>添加的ConverterFactory对象来寻找一个合适的返回，寻找的依据主要看该converter能否处理你编写方法的返回值类型，默认实现为<code>BuiltInConverters</code>，仅仅支持返回值的实际类型为<code>ResponseBody</code>和<code>Void</code>，也就说明了默认情况下，是不支持<code>Call&lt;User&gt;</code>这类类型的。</p> 
 <p>接下来就是对注解进行解析了，主要是对方法上的注解进行解析，那么可以拿到httpMethod以及初步的url（包含占位符）。</p> 
 <p>后面是对方法中参数中的注解进行解析，这一步会拿到很多的<code>ParameterHandler</code>对象，该对象在<code>toRequest()</code>构造Request的时候调用其apply方法。</p> 
 <p>ok，这里我们并没有去一行一行查看代码，其实意义也不太大，只要知道ServiceMethod主要用于将我们<code>接口中的方法</code>转化为一个<code>Request对象</code>，于是根据我们的接口返回值确定了responseConverter,解析我们方法上的注解拿到初步的url,解析我们参数上的注解拿到构建RequestBody所需的各种信息，最终调用toRequest的方法完成Request的构建。</p> 
 <ul><li>接下来看OkHttpCall的构建，构造函数仅仅是简单的赋值</li></ul> 
 <pre class="prettyprint"><code class="language-java hljs">OkHttpCall(ServiceMethod&lt;T&gt; serviceMethod, Object[] args) {
    <span class="hljs-keyword">this</span>.serviceMethod = serviceMethod;
    <span class="hljs-keyword">this</span>.args = args;
  }</code></pre> 
 <ul><li>最后一步是<code>serviceMethod.callAdapter.adapt(okHttpCall)</code> </li></ul> 
 <p>我们已经确定这个callAdapter是<code>ExecutorCallAdapterFactory.get()</code>对应代码为：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">final</span> class ExecutorCallAdapterFactory extends CallAdapter.Factory {
  <span class="hljs-keyword">final</span> Executor callbackExecutor;

  ExecutorCallAdapterFactory(Executor callbackExecutor) {
    <span class="hljs-keyword">this</span>.callbackExecutor = callbackExecutor;
  }

  <span class="hljs-annotation">@Override</span>
  <span class="hljs-keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; <span class="hljs-title">get</span>(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    <span class="hljs-keyword">if</span> (getRawType(returnType) != Call.class) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() {
      <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> Type <span class="hljs-title">responseType</span>() {
        <span class="hljs-keyword">return</span> responseType;
      }

      <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> &lt;R&gt; Call&lt;R&gt; <span class="hljs-title">adapt</span>(Call&lt;R&gt; call) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);
      }
    };
  }</code></pre> 
 <p>可以看到<code>adapt</code>返回的是<code>ExecutorCallbackCall</code>对象，继续往下看：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
    <span class="hljs-keyword">final</span> Executor callbackExecutor;
    <span class="hljs-keyword">final</span> Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
      <span class="hljs-keyword">this</span>.callbackExecutor = callbackExecutor;
      <span class="hljs-keyword">this</span>.delegate = delegate;
    }

    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span>(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback) {
      <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"callback == null"</span>);

      delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;T&gt;() {
        <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call&lt;T&gt; call, <span class="hljs-keyword">final</span> Response&lt;T&gt; response) {
          callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
              <span class="hljs-keyword">if</span> (delegate.isCanceled()) {
                <span class="hljs-comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span>
                callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));
              } <span class="hljs-keyword">else</span> {
                callback.onResponse(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, response);
              }
            }
          });
        }

        <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call&lt;T&gt; call, <span class="hljs-keyword">final</span> Throwable t) {
          callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
              callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, t);
            }
          });
        }
      });
    }
    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> Response&lt;T&gt; <span class="hljs-title">execute</span>() <span class="hljs-keyword">throws</span> IOException {
      <span class="hljs-keyword">return</span> delegate.execute();
    }
  }</code></pre> 
 <p>可以看出ExecutorCallbackCall仅仅是对Call对象进行封装，类似装饰者模式，只不过将其执行时的回调通过callbackExecutor进行回调到UI线程中去了。</p> 
 <h5 id="423-执行call">4.2.3 执行Call</h5> 
 <p>在4.2.2我们已经拿到了经过封装的<code>ExecutorCallbackCall</code>类型的call对象，实际上就是我们实际在写代码时拿到的call对象，那么我们一般会执行<code>enqueue</code>方法，看看源码是怎么做的</p> 
 <p>首先是<code>ExecutorCallbackCall.enqueue</code>方法，代码在4.2.2，可以看到除了将onResponse和onFailure回调到UI线程，主要的操作还是delegate完成的，这个delegate实际上就是OkHttpCall对象，我们看它的enqueue方法</p> 
 <pre class="prettyprint"><code class="language-java hljs"> <span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span>(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)
{
    okhttp3.Call call;
    Throwable failure;

    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)
    {
        <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already executed."</span>);
        executed = <span class="hljs-keyword">true</span>;

        <span class="hljs-keyword">try</span>
        {
            call = rawCall = createRawCall();
        } <span class="hljs-keyword">catch</span> (Throwable t)
        {
            failure = creationFailure = t;
        }
    }

    <span class="hljs-keyword">if</span> (failure != <span class="hljs-keyword">null</span>)
    {
        callback.onFailure(<span class="hljs-keyword">this</span>, failure);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (canceled)
    {
        call.cancel();
    }

    call.enqueue(<span class="hljs-keyword">new</span> okhttp3.Callback()
    {
        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(okhttp3.Call call, okhttp3.Response rawResponse)
                <span class="hljs-keyword">throws</span> IOException
        {
            Response&lt;T&gt; response;
            <span class="hljs-keyword">try</span>
            {
                response = parseResponse(rawResponse);
            } <span class="hljs-keyword">catch</span> (Throwable e)
            {
                callFailure(e);
                <span class="hljs-keyword">return</span>;
            }
            callSuccess(response);
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(okhttp3.Call call, IOException e)
        {
            <span class="hljs-keyword">try</span>
            {
                callback.onFailure(OkHttpCall.<span class="hljs-keyword">this</span>, e);
            } <span class="hljs-keyword">catch</span> (Throwable t)
            {
                t.printStackTrace();
            }
        }

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callFailure</span>(Throwable e)
        {
            <span class="hljs-keyword">try</span>
            {
                callback.onFailure(OkHttpCall.<span class="hljs-keyword">this</span>, e);
            } <span class="hljs-keyword">catch</span> (Throwable t)
            {
                t.printStackTrace();
            }
        }

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callSuccess</span>(Response&lt;T&gt; response)
        {
            <span class="hljs-keyword">try</span>
            {
                callback.onResponse(OkHttpCall.<span class="hljs-keyword">this</span>, response);
            } <span class="hljs-keyword">catch</span> (Throwable t)
            {
                t.printStackTrace();
            }
        }
    });
}
</code></pre> 
 <p>没有任何神奇的地方，内部实际上就是okhttp的Call对象，也是调用<code>okhttp3.Call.enqueue</code>方法。</p> 
 <p>中间对于<code>okhttp3.Call</code>的创建代码为：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">private</span> okhttp3.Call <span class="hljs-title">createRawCall</span>() <span class="hljs-keyword">throws</span> IOException
{
    Request request = serviceMethod.toRequest(args);
    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
    <span class="hljs-keyword">if</span> (call == <span class="hljs-keyword">null</span>)
    {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Call.Factory returned null."</span>);
    }
    <span class="hljs-keyword">return</span> call;
}</code></pre> 
 <p>可以看到，通过<code>serviceMethod.toRequest</code>完成对request的构建，通过request去构造call对象，然后返回.</p> 
 <p>中间还涉及一个<code>parseResponse</code>方法，如果顺利的话，执行的代码如下：</p> 
 <pre class="prettyprint"><code class="language-java hljs">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) <span class="hljs-keyword">throws</span> IOException
{
    ResponseBody rawBody = rawResponse.body();
    ExceptionCatchingRequestBody catchingBody = <span class="hljs-keyword">new</span> ExceptionCatchingRequestBody(rawBody);

    T body = serviceMethod.toResponse(catchingBody);
    <span class="hljs-keyword">return</span> Response.success(body, rawResponse);
</code></pre> 
 <p>通过serviceMethod对ResponseBody进行转化，然后返回，转化实际上就是通过<code>responseConverter</code>的convert方法。</p> 
 <pre class="prettyprint"><code class="language-java hljs">#ServiceMethod
 T toResponse(ResponseBody body) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">return</span> responseConverter.convert(body);
  }</code></pre> 
 <p>ok，关于<code>responseConverter</code>后面还会细说，不用担心。</p> 
 <p>到这里，我们整个源码的流程分析就差不多了，目的就掌握一个大体的原理和执行流程，了解下几个核心的类。</p> 
 <p>那么总结一下：</p> 
 <ul><li>首先构造retrofit，几个核心的参数呢，主要就是baseurl,callFactory(默认okhttpclient),converterFactories,adapterFactories,excallbackExecutor。</li><li>然后通过create方法拿到接口的实现类，这里利用Java的<code>Proxy</code>类完成动态代理的相关代理</li><li>在invoke方法内部，拿到我们所声明的注解以及实参等，构造ServiceMethod，ServiceMethod中解析了大量的信息，最痛可以通过<code>toRequest</code>构造出<code>okhttp3.Request</code>对象。有了<code>okhttp3.Request</code>对象就可以很自然的构建出<code>okhttp3.call</code>，最后calladapter对Call进行装饰返回。</li><li>拿到Call就可以执行enqueue或者execute方法了</li></ul> 
 <p>ok,了解这么多足以。</p> 
 <p>下面呢，有几个地方需要注意，一方面是一些特殊的细节；另一方面就是<code>Converter</code>。</p> 
 <h3 id="五retrofit中的各类细节">五、retrofit中的各类细节</h3> 
 <h4 id="1上传文件中使用的奇怪value值">（1）上传文件中使用的奇怪value值</h4> 
 <p>第一个问题涉及到文件上传，还记得我们在单文件上传那里所说的吗？有种类似于hack的写法，上传文件是这么做的？</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiInterface</span> {<!-- --></span>
        <span class="hljs-annotation">@Multipart</span>
        <span class="hljs-annotation">@POST</span> (<span class="hljs-string">"/api/Accounts/editaccount"</span>)
        Call&lt;User&gt; editUser (<span class="hljs-annotation">@Part</span>(<span class="hljs-string">"file_key\"; filename=\"pp.png"</span>),<span class="hljs-annotation">@Part</span>(<span class="hljs-string">"username"</span>) String username);
    }</code></pre> 
 <p>首先我们一点明确，因为这里使用了<code>@ Multipart</code>，那么我们认为<code>@Part</code>应当支持普通的key-value，以及文件。</p> 
 <p>对于普通的key-value是没问题的，只需要这样<code>@Part("username") String username</code>。</p> 
 <p>那么对于文件，为什么需要这样呢？<code>@Part("file_key\"; filename=\"pp.png")</code></p> 
 <p>这个value设置的值不用看就会觉得特别奇怪，然而却可以正常执行，原因是什么呢？</p> 
 <p>原因是这样的：</p> 
 <p>当上传key-value的时候，实际上对应这样的代码：</p> 
 <pre class="prettyprint"><code class="hljs vbnet">builder.addPart(Headers.<span class="hljs-keyword">of</span>(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"form-data; name=\"" + key + "</span>\<span class="hljs-string">""</span>),
                        RequestBody.create(null, params.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">key</span>)));</code></pre> 
 <p>也就是说，我们的<code>@Part</code>转化为了</p> 
 <pre class="prettyprint"><code class="hljs vbnet">Headers.<span class="hljs-keyword">of</span>(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"form-data; name=\"" + key + "</span>\<span class="hljs-string">""</span>)</code></pre> 
 <p>这么一看，很随意，只要把key放进去就可以了。</p> 
 <p>但是，retrofit2并没有对文件做特殊处理，文件的对应的字符串应该是这样的</p> 
 <pre class="prettyprint"><code class="hljs avrasm"> Headers<span class="hljs-preprocessor">.of</span>(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"form-data; name="</span>filekey<span class="hljs-string">";filename="</span>filename<span class="hljs-preprocessor">.png</span><span class="hljs-string">");</span></code></pre> 
 <p>与键值对对应的字符串相比，多了个<code>;filename="filename.png</code>，就因为retrofit没有做特殊处理，所以你现在看这些hack的做法</p> 
 <pre class="prettyprint"><code class="hljs 1c">@Part(<span class="hljs-string">"file_key\"</span>; filename=\<span class="hljs-string">"pp.png"</span>)
拼接：==&gt;
Content-Disposition<span class="hljs-string">", "</span>form-data; name=\<span class="hljs-string">""</span> + key + <span class="hljs-string">"\"</span>
结果：==&gt;
Content-Disposition<span class="hljs-string">", "</span>form-data; name=file_key\<span class="hljs-string">"; filename=\"</span>pp.png\<span class="hljs-string">"</span></code></pre> 
 <p>ok，到这里我相信你已经理解了，为什么要这么做，而且为什么这么做可以成功！</p> 
 <p>恩，值得一提的事，因为这种方式文件名写死了，我们上文使用的的是<code>@Part MultipartBody.Part file</code>,可以满足文件名动态设置，这个方式貌似也是2.0.1的时候支持的。</p> 
 <p>上述相关的源码：</p> 
 <pre class="prettyprint"><code class="language-java hljs">#ServiceMethod
<span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> Part) {
    <span class="hljs-keyword">if</span> (!isMultipart) {
      <span class="hljs-keyword">throw</span> parameterError(p, <span class="hljs-string">"@Part parameters can only be used with multipart encoding."</span>);
    }
    Part part = (Part) annotation;
    gotPart = <span class="hljs-keyword">true</span>;

    String partName = part.value();

    Headers headers =
          Headers.of(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"form-data; name=\""</span> + partName + <span class="hljs-string">"\""</span>,
              <span class="hljs-string">"Content-Transfer-Encoding"</span>, part.encoding());
}</code></pre> 
 <p>可以看到呢，并没有对文件做特殊处理，估计下个版本说不定<code>@Part</code>会多个<code>isFile=true|false</code>属性，甚至修改对应形参，然后在这里做简单的处理。</p> 
 <p>ok，最后来到关键的<code>ConverterFactory</code>了~</p> 
 <h3 id="六自定义converterfactory">六、自定义Converter.Factory</h3> 
 <h4 id="1responsebodyconverter">（1）responseBodyConverter</h4> 
 <p>关于<code>Converter.Factory</code>，肯定是通过<code>addConverterFactory</code>设置的</p> 
 <pre class="prettyprint"><code class="language-java hljs">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create())
        .build();</code></pre> 
 <p>该方法接受的是一个<code>Converter.Factory factory</code>对象</p> 
 <p>该对象呢，是一个抽象类，内部包含3个方法：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">abstract</span> class Factory {

    <span class="hljs-keyword">public</span> Converter&lt;ResponseBody, ?&gt; <span class="hljs-title">responseBodyConverter</span>(Type type, Annotation[] annotations,
        Retrofit retrofit) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }


    <span class="hljs-keyword">public</span> Converter&lt;?, RequestBody&gt; <span class="hljs-title">requestBodyConverter</span>(Type type,
        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }


    <span class="hljs-keyword">public</span> Converter&lt;?, String&gt; <span class="hljs-title">stringConverter</span>(Type type, Annotation[] annotations,
        Retrofit retrofit) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
  }</code></pre> 
 <p>可以看到呢，3个方法都是空方法而不是抽象的方法，也就表明了我们可以选择去实现其中的1个或多个方法，一般只需要关注<code>requestBodyConverter</code>和<code>responseBodyConverter</code>就可以了。</p> 
 <p>ok，我们先看如何自定义，最后再看<code>GsonConverterFactory.create</code>的源码。</p> 
 <p>先来个简单的，实现<code>responseBodyConverter</code>方法，看这个名字很好理解，就是将responseBody进行转化就可以了。</p> 
 <p>ok，这里呢，我们先看一下上述中我们使用的接口：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">package</span> com.zhy.retrofittest.userBiz;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserBiz</span>
{<!-- --></span>
    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"users"</span>)
    Call&lt;List&lt;User&gt;&gt; getUsers();

    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"users"</span>)
    Call&lt;List&lt;User&gt;&gt; getUsersBySort(<span class="hljs-annotation">@Query</span>(<span class="hljs-string">"sort"</span>) String sort);

    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"{username}"</span>)
    Call&lt;User&gt; getUser(<span class="hljs-annotation">@Path</span>(<span class="hljs-string">"username"</span>) String username);

    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"add"</span>)
    Call&lt;List&lt;User&gt;&gt; addUser(<span class="hljs-annotation">@Body</span> User user);

    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"login"</span>)
    <span class="hljs-annotation">@FormUrlEncoded</span>
    Call&lt;User&gt; login(<span class="hljs-annotation">@Field</span>(<span class="hljs-string">"username"</span>) String username, <span class="hljs-annotation">@Field</span>(<span class="hljs-string">"password"</span>) String password);

    <span class="hljs-annotation">@Multipart</span>
    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"register"</span>)
    Call&lt;User&gt; registerUser(<span class="hljs-annotation">@Part</span>(<span class="hljs-string">"photos"</span>) RequestBody photos, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"username"</span>) RequestBody username, <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"password"</span>) RequestBody password);

    <span class="hljs-annotation">@Multipart</span>
    <span class="hljs-annotation">@POST</span>(<span class="hljs-string">"register"</span>)
    Call&lt;User&gt; registerUser(<span class="hljs-annotation">@PartMap</span> Map&lt;String, RequestBody&gt; params,  <span class="hljs-annotation">@Part</span>(<span class="hljs-string">"password"</span>) RequestBody password);

    <span class="hljs-annotation">@GET</span>(<span class="hljs-string">"download"</span>)
    Call&lt;ResponseBody&gt; downloadTest();

}
</code></pre> 
 <p>不知不觉，方法还蛮多的，假设哈，我们这里去掉retrofit构造时的<code>GsonConverterFactory.create</code>，自己实现一个<code>Converter.Factory</code>来做数据的转化工作。</p> 
 <p>首先我们解决<code>responseBodyConverter</code>，那么代码很简单，我们可以这么写：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Converter</span>.<span class="hljs-title">Factory</span>
{<!-- --></span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Converter&lt;ResponseBody, ?&gt; <span class="hljs-title">responseBodyConverter</span>(Type type, Annotation[] annotations, Retrofit retrofit)
    {
        <span class="hljs-comment">//根据type判断是否是自己能处理的类型，不能的话，return null ,交给后面的Converter.Factory</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserConverter(type);
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserResponseConverter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">ResponseBody</span>, <span class="hljs-title">T</span>&gt;
{<!-- --></span>
    <span class="hljs-keyword">private</span> Type type;
    Gson gson = <span class="hljs-keyword">new</span> Gson();

    <span class="hljs-keyword">public</span> <span class="hljs-title">UserResponseConverter</span>(Type type)
    {
        <span class="hljs-keyword">this</span>.type = type;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title">convert</span>(ResponseBody responseBody) <span class="hljs-keyword">throws</span> IOException
    {
        String result = responseBody.string();
        T users = gson.fromJson(result, type);
        <span class="hljs-keyword">return</span> users;
    }
}
</code></pre> 
 <p>使用的时候呢，可以</p> 
 <pre class="prettyprint"><code class="language-java hljs"> Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()
.callFactory(<span class="hljs-keyword">new</span> OkHttpClient())               .baseUrl(<span class="hljs-string">"http://example/springmvc_users/user/"</span>)
<span class="hljs-comment">//.addConverterFactory(GsonConverterFactory.create())</span>
.addConverterFactory(<span class="hljs-keyword">new</span> UserConverterFactory())
            .build();</code></pre> 
 <p>ok，这样的话，就可以完成我们的<code>ReponseBody</code>到<code>List&lt;User&gt;</code>或者<code>User</code>的转化了。</p> 
 <p>可以看出，我们这里用的依然是Gson，那么有些同学肯定不希望使用Gson就能实现，如果不使用Gson的话，一般需要针对具体的返回类型，比如我们针对返回<code>List&lt;User&gt;</code>或者<code>User</code></p> 
 <p>你可以这么写：</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">package</span> com.zhy.retrofittest.converter;
<span class="hljs-javadoc">/**
 * Created by zhy on 16/4/30.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserResponseConverter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">ResponseBody</span>, <span class="hljs-title">T</span>&gt;
{<!-- --></span>
    <span class="hljs-keyword">private</span> Type type;
    Gson gson = <span class="hljs-keyword">new</span> Gson();

    <span class="hljs-keyword">public</span> <span class="hljs-title">UserResponseConverter</span>(Type type)
    {
        <span class="hljs-keyword">this</span>.type = type;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title">convert</span>(ResponseBody responseBody) <span class="hljs-keyword">throws</span> IOException
    {
        String result = responseBody.string();

        <span class="hljs-keyword">if</span> (result.startsWith(<span class="hljs-string">"["</span>))
        {
            <span class="hljs-keyword">return</span> (T) parseUsers(result);
        } <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> (T) parseUser(result);
        }
    }

    <span class="hljs-keyword">private</span> User <span class="hljs-title">parseUser</span>(String result)
    {
        JSONObject jsonObject = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span>
        {
            jsonObject = <span class="hljs-keyword">new</span> JSONObject(result);
            User u = <span class="hljs-keyword">new</span> User();
            u.setUsername(jsonObject.getString(<span class="hljs-string">"username"</span>));
            <span class="hljs-keyword">return</span> u;
        } <span class="hljs-keyword">catch</span> (JSONException e)
        {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">private</span> List&lt;User&gt; <span class="hljs-title">parseUsers</span>(String result)
    {
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">try</span>
        {
            JSONArray jsonArray = <span class="hljs-keyword">new</span> JSONArray(result);
            User u = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jsonArray.length(); i++)
            {
                JSONObject jsonObject = jsonArray.getJSONObject(i);
                u = <span class="hljs-keyword">new</span> User();
                u.setUsername(jsonObject.getString(<span class="hljs-string">"username"</span>));
                users.add(u);
            }
        } <span class="hljs-keyword">catch</span> (JSONException e)
        {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> users;
    }
}
</code></pre> 
 <p>这里简单读取了一个属性，大家肯定能看懂，这样就能满足返回值是<code>Call&lt;List&lt;User&gt;&gt;</code>或者<code>Call&lt;User&gt;</code>.</p> 
 <p>这里郑重提醒：如果你针对特定的类型去写<code>Converter</code>，一定要在<code>UserConverterFactory#responseBodyConverter</code>中对类型进行检查，发现不能处理的类型<code>return null</code>，这样的话，可以交给后面的<code>Converter.Factory</code>处理，比如本例我们可以按照下列方式检查:</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Converter</span>.<span class="hljs-title">Factory</span>
{<!-- --></span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Converter&lt;ResponseBody, ?&gt; <span class="hljs-title">responseBodyConverter</span>(Type type, Annotation[] annotations, Retrofit retrofit)
    {
        <span class="hljs-comment">//根据type判断是否是自己能处理的类型，不能的话，return null ,交给后面的Converter.Factory</span>
        <span class="hljs-keyword">if</span> (type == User.class)<span class="hljs-comment">//支持返回值是User</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserResponseConverter(type);
        }

        <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType)<span class="hljs-comment">//支持返回值是List&lt;User&gt;</span>
        {
            Type rawType = ((ParameterizedType) type).getRawType();
            Type actualType = ((ParameterizedType) type).getActualTypeArguments()[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (rawType == List.class &amp;&amp; actualType == User.class)
            {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserResponseConverter(type);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

}</code></pre> 
 <p>好了，到这呢<code>responseBodyConverter</code>方法告一段落了，谨记就是将reponseBody-&gt;返回值返回中的实际类型，例如<code>Call&lt;User&gt;中的User</code>;还有对于该converter不能处理的类型一定要返回null。</p> 
 <h4 id="2requestbodyconverter">（2）requestBodyConverter</h4> 
 <p>ok，上面接口一大串方法呢，使用了我们的Converter之后，有个方法我们现在还是不支持的。</p> 
 <pre class="prettyprint"><code class="hljs sql">@POST("add")
<span class="hljs-operator"><span class="hljs-keyword">Call</span>&lt;List&lt;<span class="hljs-keyword">User</span>&gt;&gt; addUser(@Body <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>);</span></code></pre> 
 <p>ok，这个<code>@Body</code>需要用到这个方法，叫做<code>requestBodyConverter</code>，根据参数转化为<code>RequestBody</code>，下面看下我们如何提供支持。</p> 
 <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRequestBodyConverter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">RequestBody</span>&gt;
{<!-- --></span>
    <span class="hljs-keyword">private</span> Gson mGson = <span class="hljs-keyword">new</span> Gson();
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> RequestBody <span class="hljs-title">convert</span>(T value) <span class="hljs-keyword">throws</span> IOException
    {
        String string = mGson.toJson(value);
        <span class="hljs-keyword">return</span> RequestBody.create(MediaType.parse(<span class="hljs-string">"application/json; charset=UTF-8"</span>),string);
    }
}
</code></pre> 
 <p>然后在UserConverterFactory中复写requestBodyConverter方法，返回即可：</p> 
 <pre class="prettyprint"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Converter</span>.<span class="hljs-title">Factory</span>
{<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Converter&lt;?, RequestBody&gt; <span class="hljs-title">requestBodyConverter</span>(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRequestBodyConverter&lt;&gt;();
    }
}</code></pre> 
 <p>这里偷了个懒，使用Gson将对象转化为json字符串了，如果你不喜欢使用框架，你可以选择拼接字符串，或者反射写一个支持任何对象的，反正就是对象-&gt;json字符串的转化。最后构造一个RequestBody返回即可。</p> 
 <p>ok,到这里，我相信如果你看的细致，自定义<code>Converter.Factory</code>是干嘛的，但是我还是要总结下：</p> 
 <ul><li>responseBodyConverter 主要是对应<code>@Body</code>注解，完成ResponseBody到实际的返回类型的转化，这个类型对应<code>Call&lt;XXX&gt;</code>里面的泛型XXX，其实<code>@Part</code>等注解也会需要responseBodyConverter，只不过我们的参数类型都是<code>RequestBody</code>，由默认的converter处理了。</li><li>requestBodyConverter 完成对象到RequestBody的构造。</li><li>一定要注意，检查type如果不是自己能处理的类型，记得return null （因为可以添加多个，你不能处理return null ,还会去遍历后面的converter）.</li></ul> 
 <h3 id="七值得学习的api">七、值得学习的API</h3> 
 <p>其实一般情况下看源码呢，可以让我们更好的去使用这个库，当然在看的过程中如果发现了一些比较好的处理方式呢，是非常值得记录的。如果每次看别人的源码都能吸取一定的精华，比你单纯的去理解会好很多，因为你的记忆力再好，源码解析你也是会忘的，而你记录下来并能够使用的优越的代码，可能用久了就成为你的代码了。</p> 
 <p>我举个例子：比如retrofit2中判断当前运行的环境代码如下，如果下次你有这样的需求，你也可以这么写，甚至源码中根据不同的运行环境还提供了不同的<code>Executor</code>都很值得记录：</p> 
 <pre class="prettyprint"><code class="language-java hljs">class Platform {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Platform PLATFORM = findPlatform();

  <span class="hljs-keyword">static</span> Platform get() {
    <span class="hljs-keyword">return</span> PLATFORM;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Platform <span class="hljs-title">findPlatform</span>() {
    <span class="hljs-keyword">try</span> {
      Class.forName(<span class="hljs-string">"android.os.Build"</span>);
      <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Android();
      }
    } <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) {
    }
    <span class="hljs-keyword">try</span> {
      Class.forName(<span class="hljs-string">"java.util.Optional"</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Java8();
    } <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) {
    }
    <span class="hljs-keyword">try</span> {
      Class.forName(<span class="hljs-string">"org.robovm.apple.foundation.NSObject"</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IOS();
    } <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) {
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Platform();
  }
</code></pre> 
 <hr> 
 <p>ok，文章结束，最后打个广告，个人微信公众号目前关注大概9000人左右，无奈个人博文更新频率无法做到很好的为这么多人服务，所以本公众号欢迎大家投稿，如果你希望你的文章可以被更多人看到，直接将md、doc等格式的文章发我邮箱即可（623565791@qq.com），也可以加我好友，需要注明（投稿），谢谢。</p> 
 <p>文章要求：原创+你觉得通过文章你能学到一些有价值的东西。</p> 
 <p>福利：您的文章还可以发到csdn，简书等其他平台，但不能投稿至其他微信公众号了；更多人能够发现你的文章（好文我会帮你发送至我的各大群）+您的署名+您的原文链接，如果后期有打赏收益均归投稿人所有。</p> 
 <hr> 
 <p>欢迎关注我的微博： <br><a href="http://weibo.com/u/3165018720" rel="nofollow">http://weibo.com/u/3165018720</a></p> 
 <hr> 
 <blockquote> 
  <p>群号：<font color="#FF0000">535687182</font>，欢迎入群</p> 
  <p>微信公众号：hongyangAndroid <br> （欢迎关注，第一时间推送博文信息） <br><img src="https://images2.imgbox.com/8e/3d/USye2fbf_o.jpg" width="200" alt="1422600516_2905.jpg"></p> 
 </blockquote> 
</div> &lt;script type="text/javascript"&gt; $(function () { $('pre.prettyprint code').each(function () { var lines = $(this).text().split('\n').length; var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide(); $(this).addClass('has-numbering').parent().append($numbering); for (i = 1; i &lt;= lines; i++) { $numbering.append($('&lt;li/&gt;').text(i)); }; $numbering.fadeIn(1700); }); }); &lt;/script&gt;
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e867f5aea0cbb7813a6e0aa54185d2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android dialog 点击空白dialog不消失问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b1de01d67d92964e9d5f5c7923d8da2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">opengl版本更新和绘制方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>