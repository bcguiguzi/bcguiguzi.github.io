<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux用户空间访问物理地址 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux用户空间访问物理地址" />
<meta property="og:description" content="因为项目需要，需要在Linux userspace 读写访问实际物理地址。
一）用户空间可以直接通过打开 /dev/mem 设备文件，然后mmap() 影射进行访问
static int read_type() { void * map_base; FILE *f; int type,fd; #define	READ_REG32(reg)	( *((volatile int *) (reg)) ) #define	ALLOC_SIZE	(1024) fd = open(&#34;/dev/mem&#34;, O_RDWR | O_SYNC); if (fd)	{ printf(&#34;Success to open /dev/mem fd=%08x\n&#34;, fd); } else { printf(&#34;Fail to open /dev/mem fd=%08x\n&#34;, fd);	} map_base = mmap(0, ALLOC_SIZE, PROT_READ, MAP_PRIVATE, fd, 0x35004000); type = READ_REG32(map_base &#43; 0x20); close(fd); munmap(map_base, ALLOC_SIZE); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d9b01bc1bcaa1f0ad79b4f5ff8a3cc7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-03-03T13:37:55+08:00" />
<meta property="article:modified_time" content="2014-03-03T13:37:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux用户空间访问物理地址</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>因为项目需要，需要在Linux userspace 读写访问实际物理地址。</p> 
<p> </p> 
<p>一）用户空间可以直接通过打开 /dev/mem 设备文件，然后mmap() 影射进行访问</p> 
<p> </p> 
<pre><code class="language-cpp">static int read_type()
{
	void * map_base;
	FILE *f;
	int type,fd;

#define		READ_REG32(reg)		( *((volatile int *) (reg)) )
#define		ALLOC_SIZE			(1024)

	fd = open("/dev/mem", O_RDWR | O_SYNC);
	if (fd)	{
		printf("Success to open /dev/mem fd=%08x\n", fd);
	}
	else {
		printf("Fail to open /dev/mem fd=%08x\n", fd);	
	}
	map_base = mmap(0, ALLOC_SIZE, PROT_READ, MAP_PRIVATE, fd, 0x35004000);

	type = READ_REG32(map_base + 0x20);

	close(fd);
	munmap(map_base, ALLOC_SIZE);

	printf("reg32[%08x] = value[%08x] \n", map_base, type);

	type = (type &amp; ( 1 &lt;&lt; 27 )) &gt;&gt; 27 ;

	printf("reg32[%08x] = value[%08x] \n", map_base, type);

	return type;
}</code></pre> 
<p> </p> 
<p dir="ltr">mmap，通过内核建立一个虚拟地址到物理地址的映射，然后通过这一虚拟地址就可以在用户空间访问真实的物理地址了</p> 
<p>mmap() 其中有几个参数需要说明: </p> 
<ul dir="ltr" style="margin-right:0px"><li>PROT_READ     区域可读； </li><li>PROT_WRITE   区域可写； </li><li>MAP_SHARED  对映射区域的写入数据会复制回文件内, 而且允许其他映射该文件的进程共享。</li></ul> 
<p>在Android 4.4上实际运行的结果：</p> 
<ul><li>编译生成的用户空间可执行程序，需要root user权限才能运行。即使程序本身已经是 rwx-rwx-rwx权限。</li><li>mmap()中映射的缓冲区必须是 PAGE size 的整数倍。 如果不是，会产生segmentation fault。</li><li>实际访问的物理地址如果不是恰好是PAGE size 的整数倍，必须要对mmap()返回的映射基地址加上对应的偏移量，得到最终的影射后地址。<br> </li></ul> 
<p>二）用户空间驱动程序</p> 
<p>如果用户空间可以访问实际物理地址，则可以更进一步实现用户空间的硬件驱动程序。</p> 
<p> </p> 
<p>用户空间驱动的优点: </p> 
<ul><li>完整的 C 库可以连接. 驱动可以进行许多奇怪的任务, 不用依靠外面的程序(实现使用策略的工具程序, 常常随着驱动自身发布). </li><li>程序员可以在驱动代码上运行常用的调试器, 而不必走调试一个运行中的内核的弯路. </li><li>如果一个用户空间驱动挂起了, 你可简单地杀掉它. 驱动的问题不可能挂起整个系统, 除非被控制的硬件真的疯掉了. </li><li>用户内存是可交换的, 不象内核内存. 一个不常使用的却有很大一个驱动的设备不会占据别的程序可以用到的 RAM, 除了在它实际在用时. </li><li>一个精心设计的驱动程序仍然可以, 如同内核空间驱动, 允许对设备的并行存取. </li><li>如果你必须编写一个封闭源码的驱动, 用户空间的选项使你容易避免不明朗的许可的情况和改变的内核接口带来的问题. </li></ul> 
<p>用户空间的设备驱动的方法有几个主要缺点：</p> 
<ul><li>中断在用户空间无法用. 在某些平台上有对这个限制的解决方法, 例如在 IA32 体系上的 vm86 系统调用. </li><li>只可能通过内存映射 /dev/mem 来使用 DMA, 而且只有特权用户可以这样做. </li><li>存取 I/O 端口只能在调用 ioperm 或者 iopl 之后. 此外, 不是所有的平台支持这些系统调用, 而存取/dev/port可能太慢而无效率. 这些系统调用和设备文件都要求特权用户. </li><li>响应时间慢, 因为需要上下文切换在客户和硬件之间传递信息或动作. <br>   </li></ul> 
<p>更不好的是, </p> 
<ul><li>如果驱动已被交换到硬盘, 响应时间会长到不可接受. 使用 mlock 系统调用可能会有帮助, 但是常常的你将需要锁住许多内存页, 因为一个用户空间程序依赖大量的库代码. mlock, 也, 限制在授权用户上. </li><li>最重要的设备不能在用户空间处理, 包括但不限于, 网络接口和块设备. <br> </li></ul> 
<p>如你所见, 用户空间驱动不能做的事情毕竟太多. 感兴趣的应用程序还是存在: 例如, 对 SCSI 扫描器设备的支持( 由 SANE 包实现 )和 CD 刻录器 ( 由 cdrecord 和别的工具实现 ). 在两种情况下, 用户级别的设备情况依赖 "SCSI gneric" 内核驱动, 它输出了低层的 SCSI 功能给用户程序, 因此它们可以驱动它们自己的硬件.<br>   <br> 一种在用户空间工作的情况可能是有意义的, 当你开始处理新的没有用过的硬件时. 这样你可以学习去管理你的硬件, 不必担心挂起整个系统. 一旦你完成了, 在一个内核模块中封装软件就会是一个简单操作了. </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a40492745c1c75f1227cefa8158d19d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sql 中的where 1=1 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85b112127ebfacc0ccdb1b26fd3c6485/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android webview 与 LinearLayout 布局的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>