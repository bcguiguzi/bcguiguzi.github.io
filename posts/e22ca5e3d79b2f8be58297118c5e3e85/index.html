<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux篇】第十七篇——信号量 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux篇】第十七篇——信号量" />
<meta property="og:description" content="前言
POSIX信号量
信号量的概念
信号量的工作原理
信号量函数
二元信号量模拟实现互斥功能
基于环形队列的生产消费模型
空间资源和数据资源
生产者和消费者申请和释放资源
必须遵守的两个规则
代码实现
信号量保护环形队列的原理
前言 将可能被多个执行流同时访问的资源叫做临界资源，临界资源需要进行保护否则会出现数据不一致等问题。当我们仅用一个互斥锁对临界资源进行保护时，相当于我们将这块临界资源看作一个整体，同一时刻只允许一个执行流对这块临界资源进行访问。但实际我们可以将这块临界资源再分割为多个区域，当多个执行流需要访问临界资源时，如果这些执行流访问的是临界资源的不同区域，那么我们可以让这些执行流同时访问临界资源的不同区域，此时不会出现数据不一致等问题。 POSIX信号量 信号量的概念 信号量本质是一个计数器(不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证&#43;&#43;引用计数为原子操作),用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源(信号量也属于临界资源)，使得资源在一个时刻只有一个进程独享。 每个执行流在进入临界区之前都应该先申请信号量,申请成功就有了操作特点的临界资源的权限，当操作完毕后就应该释放信号量。
信号量的工作原理 由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的:
(1)P(sv):我们将申请信号量称为P操作，申请信号量的本质就是申请获得临界资源中某块资源的使用权限，当申请成功时临界资源中资源的数目应该减去一，因此P操作的本质就是让计数器减一，如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行
(2)V(sv):我们将释放信号量称为V操作，释放信号量的本质就是归还临界资源中某块资源的使用权限，当释放成功时临界资源中资源的数目就应该加一，因此V操作本质就是让计数器加一，如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给他加1
PV操作必须是原子操作
多个执行流为了访问临界资源会竞争式的申请信号量, 因此信号量是会被多个执行流同时访问的，也就是说信号量本质也是临界资源。
信号量本质就是用于保护临界资源的，我们不可能再用信号量去保护信号量，所以信号量的PV操作必须是原子操作。
注意： 内存当中变量的&#43;&#43;、--操作并不是原子操作，因此信号量不可能只是简单的对一个全局变量进行&#43;&#43;、--操作。
申请信号量失败被挂起等待
当执行流在申请信号量时，可能此时信号量的值为0，也就是说信号量描述的临界资源已经全部被申请了，此时该执行流就应该在该信号量的等待队列当中进行等待，直到有信号量被释放时再被唤醒。
注意： 信号量的本质是计数器，但不意味着只有计数器，信号量还包括一个等待队列。
信号量函数 初始化信号量
初始化信号量的函数叫做sem_init，该函数的函数原型如下：
int sem_init(sem_t *sem, int pshared, unsigned int value); 参数说明:
sem：需要初始化的信号量。pshared：传入0值表示线程间共享，传入非零值表示进程间共享。value：信号量的初始值（计数器的初始值）。 返回值说明：
初始化信号量成功返回0，失败返回-1。 注意： POSIX信号量和System V信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的，但POSIX信号量可以用于线程间同步。
销毁信号量
销毁信号量的函数叫做sem_destroy，该函数的函数原型如下：
int sem_destroy(sem_t *sem); 参数说明：
sem：需要销毁的信号量。 返回值说明：
销毁信号量成功返回0，失败返回-1。 等待信号量（申请信号量）
等待信号量的函数叫做sem_wait，该函数的函数原型如下：
int sem_wait(sem_t *sem); 参数说明：
sem：需要等待的信号量。 返回值说明：
等待信号量成功返回0，信号量的值减一。等待信号量失败返回-1，信号量的值保持不变。 发布信号量（释放信号量）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e22ca5e3d79b2f8be58297118c5e3e85/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-06T14:19:26+08:00" />
<meta property="article:modified_time" content="2022-11-06T14:19:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux篇】第十七篇——信号量</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:40px;"><a href="#POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow">POSIX信号量</a></p> 
<p id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">信号量的概念</a></p> 
<p id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">信号量的工作原理</a></p> 
<p id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0" rel="nofollow">信号量函数</a></p> 
<p id="%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD" rel="nofollow">二元信号量模拟实现互斥功能</a></p> 
<p id="%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B" rel="nofollow">基于环形队列的生产消费模型</a></p> 
<p id="%E7%A9%BA%E9%97%B4%E8%B5%84%E6%BA%90%E5%92%8C%E6%95%B0%E6%8D%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%E7%A9%BA%E9%97%B4%E8%B5%84%E6%BA%90%E5%92%8C%E6%95%B0%E6%8D%AE%E8%B5%84%E6%BA%90" rel="nofollow">空间资源和数据资源</a></p> 
<p id="%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90" rel="nofollow">生产者和消费者申请和释放资源</a></p> 
<p id="%E5%BF%85%E9%A1%BB%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%E5%BF%85%E9%A1%BB%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%84%E5%88%99" rel="nofollow">必须遵守的两个规则</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">信号量保护环形队列的原理</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80"><span style="color:#956fe7;">前言</span></h2> 
<ul><li>将可能被多个执行流同时访问的资源叫做临界资源，临界资源需要进行保护否则会出现数据不一致等问题。</li><li>当我们仅用一个互斥锁对临界资源进行保护时，相当于我们将这块临界资源看作一个整体，同一时刻只允许一个执行流对这块临界资源进行访问。</li><li>但实际我们可以将这块临界资源再分割为多个区域，当多个执行流需要访问临界资源时，如果这些执行流访问的是临界资源的不同区域，那么我们可以让这些执行流同时访问临界资源的不同区域，此时不会出现数据不一致等问题。</li></ul> 
<h3 id="POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span style="color:#956fe7;">POSIX信号量</span></h3> 
<h3 id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#38d8f0;">信号量的概念</span></h3> 
<blockquote> 
 <p>信号量本质是一个<strong>计数器</strong>(不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作),用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来<strong>保护共享资源</strong>(信号量也属于临界资源)，使得资源在一个时刻只有一个进程独享。 </p> 
</blockquote> 
<p>每个执行流在进入临界区之前都应该先申请信号量,申请成功就有了操作特点的临界资源的权限，当操作完毕后就应该释放信号量。</p> 
<p class="img-center"><img alt="" height="210" src="https://images2.imgbox.com/59/bc/w6cxoICC_o.png" width="367"></p> 
<h3 id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span style="color:#38d8f0;">信号量的工作原理</span></h3> 
<p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的:</p> 
<p>(1)P(sv):我们将申请信号量称为P操作，申请信号量的本质就是申请获得临界资源中某块资源的使用权限，当申请成功时临界资源中资源的数目应该减去一，因此P操作的本质就是让计数器减一，如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p> 
<p>(2)V(sv):我们将释放信号量称为V操作，释放信号量的本质就是归还临界资源中某块资源的使用权限，当释放成功时临界资源中资源的数目就应该加一，因此V操作本质就是让计数器加一，如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给他加1</p> 
<blockquote> 
 <p>PV操作必须是原子操作</p> 
</blockquote> 
<p>多个执行流为了访问临界资源会竞争式的申请信号量, 因此信号量是会被多个执行流同时访问的，也就是说信号量本质也是临界资源。</p> 
<p>信号量本质就是用于保护临界资源的，我们不可能再用信号量去保护信号量，所以信号量的PV操作必须是原子操作。</p> 
<p><strong>注意：</strong> 内存当中变量的<code>++</code>、<code>--</code>操作并不是原子操作，因此信号量不可能只是简单的对一个全局变量进行<code>++</code>、<code>--</code>操作。</p> 
<blockquote> 
 <p>申请信号量失败被挂起等待</p> 
</blockquote> 
<p>当执行流在申请信号量时，可能此时信号量的值为0，也就是说信号量描述的临界资源已经全部被申请了，此时该执行流就应该在该信号量的等待队列当中进行等待，直到有信号量被释放时再被唤醒。</p> 
<p><strong>注意：</strong> 信号量的本质是计数器，但不意味着只有计数器，信号量还包括一个等待队列。</p> 
<h3 id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span style="color:#38d8f0;">信号量函数</span></h3> 
<blockquote> 
 <p>初始化信号量</p> 
</blockquote> 
<p> 初始化信号量的函数叫做sem_init，该函数的函数原型如下：</p> 
<pre><code class="language-cpp">int sem_init(sem_t *sem, int pshared, unsigned int value);
</code></pre> 
<p> 参数说明:</p> 
<ul><li>sem：需要初始化的信号量。</li><li>pshared：传入0值表示线程间共享，传入非零值表示进程间共享。</li><li>value：信号量的初始值（计数器的初始值）。</li></ul> 
<p>返回值说明：</p> 
<ul><li>初始化信号量成功返回0，失败返回-1。</li></ul> 
<p><strong>注意：</strong> POSIX信号量和System V信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的，但POSIX信号量可以用于线程间同步。</p> 
<blockquote> 
 <p>销毁信号量</p> 
</blockquote> 
<p> 销毁信号量的函数叫做sem_destroy，该函数的函数原型如下：</p> 
<pre><code class="language-cpp">int sem_destroy(sem_t *sem);
</code></pre> 
<p>参数说明：</p> 
<ul><li>sem：需要销毁的信号量。</li></ul> 
<p>返回值说明：</p> 
<ul><li>销毁信号量成功返回0，失败返回-1。</li></ul> 
<blockquote> 
 <p>等待信号量（申请信号量）</p> 
</blockquote> 
<p> 等待信号量的函数叫做sem_wait，该函数的函数原型如下：</p> 
<pre><code class="language-cpp">int sem_wait(sem_t *sem);
</code></pre> 
<p> 参数说明：</p> 
<ul><li>sem：需要等待的信号量。</li></ul> 
<p>返回值说明：</p> 
<ul><li>等待信号量成功返回0，信号量的值减一。</li><li>等待信号量失败返回-1，信号量的值保持不变。</li></ul> 
<blockquote> 
 <p>发布信号量（释放信号量）</p> 
</blockquote> 
<p> 发布信号量的函数叫做sem_post，该函数的函数原型如下：</p> 
<pre><code class="language-cpp">int sem_post(sem_t *sem);
</code></pre> 
<p> 参数说明</p> 
<ul><li>sem：需要发布的信号量。</li></ul> 
<p>返回值说明：</p> 
<ul><li>发布信号量成功返回0，信号量的值加一。</li><li>发布信号量失败返回-1，信号量的值保持不变。</li></ul> 
<h2 id="%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD"><span style="color:#956fe7;">二元信号量模拟实现互斥功能</span></h2> 
<blockquote> 
 <p>二元信号量是最简单的一种锁(互斥锁)，它只用两种状态:占用与非占用，所以它的引用计数为1,说明信号量所描述的临界资源只有一份，此时信号量的作用基本就等价于互斥锁</p> 
</blockquote> 
<p> 例如，下面我们实现一个多线程抢票系统，其中我们用二元信号量模拟实现多线程互斥。</p> 
<p>我们在主线程当中创建四个新线程，让这四个新线程执行抢票逻辑，并且每次抢完票后打印输出此时剩余的票数，其中我们用全局变量tickets记录当前剩余的票数，此时tickets是会被多个执行流同时访问的临界资源，在下面的代码中我们并没有对tickets进行任何保护操作。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int tickets = 2000;
void* TicketGrabbing(void* arg)
{
	std::string name = (char*)arg;
	while (true){
		if (tickets &gt; 0){
			usleep(1000);
			std::cout &lt;&lt; name &lt;&lt; " get a ticket, tickets left: " &lt;&lt; --tickets &lt;&lt; std::endl;
		}
		else{
			break;
		}
	}
	std::cout &lt;&lt; name &lt;&lt; " quit..." &lt;&lt; std::endl;
	pthread_exit((void*)0);
}

int main()
{
	pthread_t tid1, tid2, tid3, tid4;
	pthread_create(&amp;tid1, nullptr, TicketGrabbing, (void*)"thread 1");
	pthread_create(&amp;tid2, nullptr, TicketGrabbing, (void*)"thread 2");
	pthread_create(&amp;tid3, nullptr, TicketGrabbing, (void*)"thread 3");
	pthread_create(&amp;tid4, nullptr, TicketGrabbing, (void*)"thread 4");
	
	pthread_join(tid1, nullptr);
	pthread_join(tid2, nullptr);
	pthread_join(tid3, nullptr);
	pthread_join(tid4, nullptr);
	return 0;
}
</code></pre> 
<p> 运行代码后可以看到，线程打印输出剩余票数时出现了票数剩余为负数的情况，这是不符合我们预期的。</p> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/83/a8/6Mz1RtSw_o.png" width="394"></p> 
<p> 下面我们在抢票逻辑当中加入二元信号量，让每个线程在访问全局变量tickets之前先申请信号量，访问完毕后再释放信号量，此时二元信号量就达到了互斥的效果。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

class Sem{
public:
	Sem(int num)
	{
		sem_init(&amp;_sem, 0, num);
	}
	~Sem()
	{
		sem_destroy(&amp;_sem);
	}
	void P()
	{
		sem_wait(&amp;_sem);
	}
	void V()
	{
		sem_post(&amp;_sem);
	}
private:
	sem_t _sem;
};

Sem sem(1); //二元信号量
int tickets = 2000;
void* TicketGrabbing(void* arg)
{
	std::string name = (char*)arg;
	while (true){
		sem.P();
		if (tickets &gt; 0){
			usleep(1000);
			std::cout &lt;&lt; name &lt;&lt; " get a ticket, tickets left: " &lt;&lt; --tickets &lt;&lt; std::endl;
			sem.V();
		}
		else{
			sem.V();
			break;
		}
	}
	std::cout &lt;&lt; name &lt;&lt; " quit..." &lt;&lt; std::endl;
	pthread_exit((void*)0);
}

int main()
{
	pthread_t tid1, tid2, tid3, tid4;
	pthread_create(&amp;tid1, nullptr, TicketGrabbing, (void*)"thread 1");
	pthread_create(&amp;tid2, nullptr, TicketGrabbing, (void*)"thread 2");
	pthread_create(&amp;tid3, nullptr, TicketGrabbing, (void*)"thread 3");
	pthread_create(&amp;tid4, nullptr, TicketGrabbing, (void*)"thread 4");
	
	pthread_join(tid1, nullptr);
	pthread_join(tid2, nullptr);
	pthread_join(tid3, nullptr);
	pthread_join(tid4, nullptr);
	return 0;
}
</code></pre> 
<p> 运行代码后就不会出现剩余票数为负的情况了，因为此时同一时刻只会有一个执行流对全局变量tickets进行访问，不会出现数据不一致的问题。</p> 
<h2 id="%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B"><span style="color:#956fe7;">基于环形队列的生产消费模型</span></h2> 
<p class="img-center"><img alt="" height="310" src="https://images2.imgbox.com/c5/70/RTszEXrh_o.png" width="492"></p> 
<h3 id="%E7%A9%BA%E9%97%B4%E8%B5%84%E6%BA%90%E5%92%8C%E6%95%B0%E6%8D%AE%E8%B5%84%E6%BA%90"><span style="color:#38d8f0;">空间资源和数据资源</span></h3> 
<blockquote> 
 <p>生产者关注的是空间资源，消费者关注的是数据资源</p> 
</blockquote> 
<p> 对于生产者和消费者来说，它们关注的资源是不同的:</p> 
<ul><li>生产者关注的是环形队列当中是否有空间(blank),只要有空间生产者就可以进行生产。</li><li>消费者关注的是环形队列当中是否有数据(data),只要有数据消费者就可以进行消费。</li></ul> 
<blockquote> 
 <p>blank_sem和data_sem的初始值设置</p> 
</blockquote> 
<p>现在我们用信号量来描述环形队列当中的空间资源(blank_sem)和数据资源(data_sem),在我们初始信号量时给它们设置的初始值是不同的:</p> 
<ul><li>blank_sem的初始值我们应该设置为环形队列的容量，因为刚开始时环形队列当中全是空间</li><li>data_sem的初始值我们应该设置为0，因为刚开始时环形队列当中没有数据。</li></ul> 
<h3 id="%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span style="color:#38d8f0;">生产者和消费者申请和释放资源</span></h3> 
<blockquote> 
 <p>生产者申请空间资源，释放数据资源</p> 
</blockquote> 
<p>对于生产者来说，生产者每次生产数据前都需要先申请blank_sem:</p> 
<ul><li>如果blank_sem的值不为0，则信号量申请成功，此时生产者可以进行生产操作。</li><li>如果blank_sem的值为0，则信号量申请失败，此时生产者需要在blank_sem的等待队列下进行阻塞等待，直到环形队列当中有新的空间再被唤醒。</li></ul> 
<p>当生产者生产完数据后，应该释放data_sem:</p> 
<ul><li>虽然生产者在进行生产前是对blank_sem进行的P操作，但是当生产者生产完数据，应该对data_sem进行V操作而不是blank_sem.</li><li>生产者在生产数据前申请到的是blank位置，当生产者生产完数据后，该位置当中存储的是生产者生产的数据，在该数据被消费者消费之前，该位置不再是blank位置，儿应该是data位置。</li><li>当生产者生产完数据后，意味着环形队列当中多了一个data位置，因此我们应该对data_sem进行v操作。</li></ul> 
<blockquote> 
 <p>消费者申请数据资源，释放空间资源</p> 
</blockquote> 
<p> 对于消费者来说，消费者每次消费数据前都需要先申请data_sem：</p> 
<ul><li>如果data_sem的值不为0，则信号量申请成功，此时消费者可以进行消费操作。</li><li>如果data_sem的值为0，则信号量申请失败，此时消费者需要在data_sem的等待队列下进行阻塞等待，直到环形队列当中有新的数据后再被唤醒。</li></ul> 
<p>当消费者消费完数据后，应该释放blank_sem：</p> 
<ul><li>虽然消费者在进行消费前是对data_sem进行的P操作，但是当消费者消费完数据，应该对blank_sem进行V操作而不是data_sem。</li><li>消费者在消费数据前申请到的是<code>data位置</code>，当消费者消费完数据后，该位置当中的数据已经被消费过了，再次被消费就没有意义了，为了让生产者后续可以在该位置生产新的数据，我们应该将该位置算作<code>blank位置</code>，而不是<code>data位置</code>。</li><li>当消费者消费完数据后，意味着环形队列当中多了一个<code>blank位置</code>，因此我们应该对blank_sem进行V操作。</li></ul> 
<h3 id="%E5%BF%85%E9%A1%BB%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%84%E5%88%99"><span style="color:#38d8f0;">必须遵守的两个规则</span></h3> 
<p>在基于环形队列的生产者和消费者模型当中，生产者和消费者必须遵守如下两个规则。</p> 
<blockquote> 
 <p>第一个规则：生产者和消费者不能对同一个位置进行访问。</p> 
</blockquote> 
<p> 生产者和消费者在访问环形队列时：</p> 
<ul><li>如果生产者和消费者访问的是环形队列当中的同一个位置，那么此时生产者和消费者就相当于同时对这一块临界资源进行了访问，这当然是不允许的。</li><li>而如果生产者和消费者访问的是环形队列当中的不同位置，那么此时生产者和消费者是可以同时进行生产和消费的，此时不会出现数据不一致等问题。</li></ul> 
<p><img alt="" height="269" src="https://images2.imgbox.com/a0/3c/2iUOZduy_o.png" width="685"></p> 
<blockquote> 
 <p> 第二个规则：无论是生产者还是消费者，都不应该将对方套一个圈以上。</p> 
</blockquote> 
<ul><li>生产者从消费者的位置开始一直按顺时针方向进行生产，如果生产者生产的速度比消费者消费的速度快，那么当生产者绕着消费者生产了一圈数据后再次遇到消费者，此时生产者就不应该再继续生产了，因为再生产就会覆盖还未被消费者消费的数据。</li><li>同理，消费者从生产者的位置开始一直按顺时针方向进行消费，如果消费者消费的速度比生产者生产的速度快，那么当消费者绕着生产者消费了一圈数据后再次遇到生产者，此时消费者就不应该再继续消费了，因为再消费就会消费到缓冲区中保存的废弃数据。</li></ul> 
<h3 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span style="color:#38d8f0;">代码实现</span></h3> 
<p>其中的RingQueue就是生产者消费者模型当中的交易场所，我们可以用C++STL库当中的vector进行实现。</p> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;vector&gt;

#define NUM 8

template&lt;class T&gt;
class RingQueue
{
private:
	//P操作
	void P(sem_t&amp; s)
	{
		sem_wait(&amp;s);
	}
	//V操作
	void V(sem_t&amp; s)
	{
	    sem_post(&amp;s);
	}
public:
	RingQueue(int cap = NUM)
		: _cap(cap), _p_pos(0), _c_pos(0)
	{
		_q.resize(_cap);
		sem_init(&amp;_blank_sem, 0, _cap); //blank_sem初始值设置为环形队列的容量
		sem_init(&amp;_data_sem, 0, 0); //data_sem初始值设置为0
	}
	~RingQueue()
	{
	sem_destroy(&amp;_blank_sem);
	sem_destroy(&amp;_data_sem);
	}
	//向环形队列插入数据（生产者调用）
	void Push(const T&amp; data)
	{
		P(_blank_sem); //生产者关注空间资源
		_q[_p_pos] = data;
		V(_data_sem); //生产

		//更新下一次生产的位置
		_p_pos++;
		_p_pos %= _cap;
	}
	//从环形队列获取数据（消费者调用）
	void Pop(T&amp; data)
	{
		P(_data_sem); //消费者关注数据资源
		data = _q[_c_pos];
		V(_blank_sem);

		//更新下一次消费的位置
		_c_pos++;
		_c_pos %= _cap;
	}
private:
	std::vector&lt;T&gt; _q; //环形队列
	int _cap; //环形队列的容量上限
	int _p_pos; //生产位置
	int _c_pos; //消费位置
	sem_t _blank_sem; //描述空间资源
	sem_t _data_sem; //描述数据资源
};
</code></pre> 
<p>相关说明:</p> 
<ul><li>当不设置环形队列的大小时，我们默认将环形队列的容量上限设置为8。</li><li>代码中的RingQueue是用vector实现的，生产者每次生产的数据放到vector下标为p_pos的位置，消费者每次消费的数据来源于vector下标为c_pos的位置。</li><li>生产者每次生产数据后p_pos都会进行++，标记下一次生产数据的存放位置，++后的下标会与环形队列的容量进行取模运算，实现“环形”的效果。</li><li>消费者每次消费数据后c_pos都会进行++，标记下一次消费数据的来源位置，++后的下标会与环形队列的容量进行取模运算，实现“环形”的效果。</li><li>p_pos只会由生产者线程进行更新，c_pos只会由消费者线程进行更新，对这两个变量访问时不需要进行保护，因此代码中将p_pos和c_pos的更新放到了V操作之后，就是为了尽量减少临界区的代码。</li></ul> 
<p>为了方便理解，我们这里实现单生产者、单消费者的生产者消费者模型。于是在主函数我们就只需要创建一个生产者线程和一个消费者线程，生产者线程不断生产数据放入环形队列，消费者线程不断从环形队列里取出数据进行消费。</p> 
<pre><code class="language-cpp">#include "RingQueue.hpp"

void* Producer(void* arg)
{
	RingQueue&lt;int&gt;* rq = (RingQueue&lt;int&gt;*)arg;
	while (true){
		sleep(1);
		int data = rand() % 100 + 1;
		rq-&gt;Push(data);
		std::cout &lt;&lt; "Producer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}
void* Consumer(void* arg)
{
	RingQueue&lt;int&gt;* rq = (RingQueue&lt;int&gt;*)arg;
	while (true){
		sleep(1);
		int data = 0;
		rq-&gt;Pop(data);
		std::cout &lt;&lt; "Consumer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}
int main()
{
	srand((unsigned int)time(nullptr));
	pthread_t producer, consumer;
	RingQueue&lt;int&gt;* rq = new RingQueue&lt;int&gt;;
	pthread_create(&amp;producer, nullptr, Producer, rq);
	pthread_create(&amp;consumer, nullptr, Consumer, rq);
	
	pthread_join(producer, nullptr);
	pthread_join(consumer, nullptr);
	delete rq;
	return 0;
}
</code></pre> 
<p> <strong>相关说明：</strong></p> 
<ul><li>环形队列要让生产者线程向队列中Push数据，让消费者线程从队列中Pop数据，因此这个环形队列必须要让这两个线程同时看到，所以我们在创建生产者线程和消费者线程时，需要将环形队列作为线程执行例程的参数进行传入。</li><li>代码中生产者生产数据就是将获取到的随机数Push到环形队列，而消费者就是从环形队列Pop数据，为了便于观察，我们可以将生产者生产的数据和消费者消费的数据进行打印输出。</li></ul> 
<blockquote> 
 <p>生产者消费者步调一致</p> 
</blockquote> 
<p>由于代码中生产者是每隔一秒生产一个数据，而消费者是每隔一秒消费一个数据，因此运行代码后我们可以看到生产者和消费者的执行步调是一致的。</p> 
<p class="img-center"><img alt="" height="331" src="https://images2.imgbox.com/01/d1/3MwFYw65_o.png" width="426"></p> 
<blockquote> 
 <p> 生产者生产的快，消费者消费的慢</p> 
</blockquote> 
<p> 我们可以让生产者不停的进行生产，而消费者每隔一秒进行消费。</p> 
<p>此时由于生产者生产的很快，运行代码后一瞬间生产者就将环形队列打满了，此时生产者想要再进行生产，但空间资源已经为0了，于是生产者只能在blank_sem的等待队列下进行阻塞等待，直到由消费者消费完一个数据后对blank_sem进行了V操作，生产者才会被唤醒进而继续进行生产。</p> 
<p>但由于生产者的生产速度很快，生产者生产完一个数据后又会进行等待，因此后续生产者和消费者的步调又变成一致的了。</p> 
<blockquote> 
 <p>生产者生产的慢，消费者消费的快</p> 
</blockquote> 
<p> 当然我们也可以让生产者每隔一秒进行生产，而消费者不停的进行消费。</p> 
<p>虽然消费者消费的很快，但一开始环形队列当中的数据资源为0，因此消费者只能在data_sem的等待队列下进行阻塞等待，直到生产者生产完一个数据后对data_sem进行了V操作，消费者才会被唤醒进而进行消费。</p> 
<p>但由于消费者的消费速度很快，消费者消费完一个数据后又会进行等待，因此后续生产者和消费者的步调又变成一致的了。</p> 
<h3 id="%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86"><span style="color:#38d8f0;">信号量保护环形队列的原理</span></h3> 
<blockquote> 
 <p>在blank_sem和data_sem两个信号量的保护后，该环形队列中不可能会出现数据不一致的问题。</p> 
</blockquote> 
<p> 因为只有当生产者和消费者指向同一个位置并访问时，才会导致数据不一致的问题，而此时生产者和消费者在对环形队列进行写入或读取数据时，只有两种情况会指向同一个位置：</p> 
<ul><li>环形队列为空时</li><li>环形队列为满时。</li></ul> 
<p>但是在这两种情况下，生产者和消费者不会同时对环形队列进行访问：</p> 
<ul><li>当环形队列为空的时，消费者一定不能进行消费，因为此时数据资源为0。</li><li>当环形队列为满的时，生产者一定不能进行生产，因为此时空间资源为0。</li></ul> 
<p>也就是说，当环形队列为空和满时，我们已经通过信号量保证了生产者和消费者的串行化过程。而除了这两种情况之外，生产者和消费者指向的都不是同一个位置，因此该环形队列当中不可能会出现数据不一致的问题。并且大部分情况下生产者和消费者指向并不是同一个位置，因此大部分情况下该环形队列可以让生产者和消费者并发的执行。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/faea0ceceaaa8a8377a92fa27e18787e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python----程序的基本结构、顺序结构、分支结构、循环结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8ecdaea3143e47846323730eb0b6d62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MSTP基本配置及优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>