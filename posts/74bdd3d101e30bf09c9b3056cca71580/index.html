<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>考研机试题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="考研机试题" />
<meta property="og:description" content="目录 头文件与STL动态规划最大数组子串和最长公共子序列最长连续公共子串最长递增子序列最大上升子序列和0-1背包多重背包多重背包问题 I整数拆分最小邮票最大子矩阵 数学问题朴素法筛素数线性筛素数快速幂 石子合并锯木棍并查集Dijkstra单源最短路Python进制转换(整数无限大)全排列神奇的口袋全排列II放苹果求第k小八皇后问题哈夫曼编码KMP算法遍历建立二叉树 头文件与STL #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; vector.insert(vector.begin(),2,99)//在头部插入2个99 vector.erase(vector.begin() &#43; 5, vector.end()) //删除第5个以后的元素 map&lt;string,int&gt; map.insert(pair&lt;string, int&gt;()) map.count() //0或1 map.earse() //删除 string s; s.find() s.substr(int start,int length) //切割子串 //输入含空格字符串 getline(cin,s); //优先队列 priority_queue&lt;int,vecotr&lt;int&gt;,greater&lt;int&gt;&gt;; //less是降序 python输入
import sys for line in sys.stdin: arr = line.split() //拼接列表 &#39; &#39;.join(list) a = int(arr[0]) 动态规划 最大数组子串和 dp[i]其实代表的是以i结尾的最大子串和
for(int i=0;i&lt;n;i&#43;&#43;){ cin&gt;&gt;a[i]; // 需要额外的ans存储max，因为是子串 dp[i&#43;1]=max(dp[i]&#43;a[i],a[i]); ans=max(dp[i&#43;1],ans); } 最长公共子序列 动态规划" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/74bdd3d101e30bf09c9b3056cca71580/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T18:52:12+08:00" />
<meta property="article:modified_time" content="2024-03-16T18:52:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">考研机试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#STL_3" rel="nofollow">头文件与STL</a></li><li><a href="#_46" rel="nofollow">动态规划</a></li><li><ul><li><a href="#_48" rel="nofollow">最大数组子串和</a></li><li><a href="#_61" rel="nofollow">最长公共子序列</a></li><li><a href="#_74" rel="nofollow">最长连续公共子串</a></li><li><a href="#_96" rel="nofollow">最长递增子序列</a></li><li><a href="#_114" rel="nofollow">最大上升子序列和</a></li><li><a href="#01_118" rel="nofollow">0-1背包</a></li><li><a href="#_142" rel="nofollow">多重背包</a></li><li><a href="#_I_154" rel="nofollow">多重背包问题 I</a></li><li><a href="#_167" rel="nofollow">整数拆分</a></li><li><a href="#_178" rel="nofollow">最小邮票</a></li><li><a href="#_198" rel="nofollow">最大子矩阵</a></li></ul> 
  </li><li><a href="#_237" rel="nofollow">数学问题</a></li><li><ul><li><a href="#_238" rel="nofollow">朴素法筛素数</a></li><li><a href="#_258" rel="nofollow">线性筛素数</a></li><li><a href="#_281" rel="nofollow">快速幂</a></li></ul> 
  </li><li><a href="#_296" rel="nofollow">石子合并</a></li><li><a href="#_340" rel="nofollow">锯木棍</a></li><li><a href="#_388" rel="nofollow">并查集</a></li><li><a href="#Dijkstra_409" rel="nofollow">Dijkstra单源最短路</a></li><li><a href="#Python_444" rel="nofollow">Python进制转换(整数无限大)</a></li><li><a href="#_458" rel="nofollow">全排列</a></li><li><a href="#_491" rel="nofollow">神奇的口袋</a></li><li><a href="#II_515" rel="nofollow">全排列II</a></li><li><a href="#_552" rel="nofollow">放苹果</a></li><li><a href="#k_587" rel="nofollow">求第k小</a></li><li><a href="#_638" rel="nofollow">八皇后问题</a></li><li><a href="#_643" rel="nofollow">哈夫曼编码</a></li><li><a href="#KMP_651" rel="nofollow">KMP算法</a></li><li><a href="#_696" rel="nofollow">遍历建立二叉树</a></li></ul> 
</div> 
<p></p> 
<h2><a id="STL_3"></a>头文件与STL</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

vector<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token comment">//在头部插入2个99</span>
vector<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> vector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//删除第5个以后的元素</span>

map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span>
map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//0或1</span>
map<span class="token punctuation">.</span><span class="token function">earse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//删除</span>

string s<span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token comment">//切割子串</span>
<span class="token comment">//输入含空格字符串</span>
<span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    
<span class="token comment">//优先队列    </span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>vecotr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">//less是降序</span>
 
</code></pre> 
<p>python输入</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys
<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>
  arr <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">//</span>拼接列表
  <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>
  a <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

</code></pre> 
<h2><a id="_46"></a>动态规划</h2> 
<h3><a id="_48"></a>最大数组子串和</h3> 
<p>dp[i]其实代表的是<strong>以i结尾</strong>的最大子串和</p> 
<pre><code class="prism language-c++">for(int i=0;i&lt;n;i++){
    cin&gt;&gt;a[i];
    // 需要额外的ans存储max，因为是子串
    dp[i+1]=max(dp[i]+a[i],a[i]);
    ans=max(dp[i+1],ans);
}
</code></pre> 
<h3><a id="_61"></a>最长公共子序列</h3> 
<p>动态规划</p> 
<pre><code>for(int i=1;i&lt;=s1.size();i++){
	for(int j=1;j&lt;=s2.size();j++){
        if(s1[i-1]==s2[j-1])dp[i][j]=dp[i-1][j-1]+1;
        else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
	}
}
</code></pre> 
<h3><a id="_74"></a>最长连续公共子串</h3> 
<pre><code class="prism language-c++">//t存储公共子串在s1中的末尾位置
int t=0;
//最大长度，要额外的maxLen存储max，因为是子串
int maxLen=0;
for(int i=1;i&lt;=n;i++){
    for(int j=1;j&lt;=m;j++){
        if(s1[i-1]==s2[j-1]){
            dp[i][j]=dp[i-1][j-1]+1;
            // =号确保 如果不唯一，则输出s1中的最后一个。
            if(dp[i][j]&gt;=maxLen){
                maxLen=dp[i][j];
                //存储公共子串在s1中的末尾位置，可以输出子串
                t=i-1;
            }
        } 
    }
}
</code></pre> 
<h3><a id="_96"></a>最长递增子序列</h3> 
<p>https://www.nowcoder.com/practice/cf209ca9ac994015b8caf5bf2cae5c98?tpId=40&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=</p> 
<p><strong>dp[i]只代表以i结尾的最长递增子序列数</strong></p> 
<pre><code class="prism language-c++">for(int i=0;i&lt;n;i++){
    //初始化：最长为本身 1
	dp[i]=1;
	for(int j=0;j&lt;i;j++){
        //dp[i]代表以i结尾的最长递增子序列数
		if(a[i]&gt;a[j])dp[i]=max(dp[j]+1,dp[i]);
        ans=max(dp[i],ans);
	}
}
</code></pre> 
<h3><a id="_114"></a>最大上升子序列和</h3> 
<p>和上述最长递增子序列思路一致，不过<strong>dp[i]代表以i结尾的最长递增子序列的和</strong>，用ans存储结果</p> 
<h3><a id="01_118"></a>0-1背包</h3> 
<pre><code class="prism language-c++">int dp[1001][1001];//代表前i个物体，背包为j的最大价值
int n,bag;
int v[10001],w[10001];
cin&gt;&gt;n&gt;&gt;bag;
for(int i=1;i&lt;=n;i++){
    cin&gt;&gt;v[i]&gt;&gt;w[i];
}
dp[0][0]=0;
for(int i=1;i&lt;=n;i++){
    for(int j=1;j&lt;=bag;j++){
        if(j&gt;=v[i]){
            dp[i][j]=max(dp[i-1][j-v[i]]+w[i],dp[i-1][j]);
        }
        else{
            dp[i][j]=dp[i-1][j];
        }
    }
}
cout&lt;&lt;dp[n][bag];
</code></pre> 
<h3><a id="_142"></a>多重背包</h3> 
<p>每种物品无限件</p> 
<pre><code class="prism language-c++">for(int i=1;i&lt;=n;i++){
    for(int j=v[i];j&lt;=m;j++){
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
}
</code></pre> 
<h3><a id="_I_154"></a>多重背包问题 I</h3> 
<p>第 i 种物品最多有 si件，</p> 
<pre><code class="prism language-c++">//将 si拆成多个物品，即01背包
 while(s--)
{
    a[++t]=v;
    b[t]=w;
}//死拆，把多重背包拆成01背包
</code></pre> 
<h3><a id="_167"></a>整数拆分</h3> 
<p>一个整数总可以拆分为2的幂的和</p> 
<pre><code class="prism language-c++">//奇数
if(i%2)dp[i]=dp[i-1];
//偶数 ？没想明白***
else dp[i]=(dp[i-1]+dp[i/2])%1000000000;
</code></pre> 
<h3><a id="_178"></a>最小邮票</h3> 
<pre><code class="prism language-c++">dp[0][0]=0;
for(int i=1;i&lt;=m;i++){
    //代表集不齐
    dp[0][i]=1e9;
}


for(int i=1;i&lt;=n;i++){
    for(int j=1;j&lt;=m;j++){
        if(j-a[i]&gt;=0)
        dp[i][j]=min(dp[i-1][j-a[i]]+1,dp[i-1][j]);
        else
        dp[i][j]=dp[i-1][j];
    }
}
</code></pre> 
<h3><a id="_198"></a>最大子矩阵</h3> 
<blockquote> 
 <p><code>子矩阵的和：pivot - dp[k-1][j] - dp[i][q-1] + dp[k-1][q-1]</code></p> 
</blockquote> 
<pre><code> for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            cin &gt;&gt; matrix[i][j];
            //计算机前缀和
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i][j];
        }
    }
	
    int  ans = INT_MIN;
    //记录最大子矩阵位置
    int x1,x2,y1,y2;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            int pivot = dp[i][j];
            for (int k = 1; k &lt;= i; k++) {
                for (int q = 1; q &lt;= j; q++) {
                    if((pivot - dp[k-1][j] - dp[i][q-1] + dp[k-1][q-1])&gt;ans){
                        ans = max(ans, pivot - dp[k-1][j] - dp[i][q-1] + dp[k-1][q-1]);
                        x1=k;
                        x2=i;
                        y1=q;
                        y2=j;
                    }
                    
                }
            }
        }
    }
    cout &lt;&lt; ans&lt;&lt;endl;
    cout&lt;&lt;x1&lt;&lt;y1&lt;&lt;" "&lt;&lt;x2&lt;&lt;y2&lt;&lt;endl;
</code></pre> 
<h2><a id="_237"></a>数学问题</h2> 
<h3><a id="_238"></a>朴素法筛素数</h3> 
<p>求n以内的所有素数，时间O(nlog(logn))【不是最优：例如14会被2和7筛重复2次】</p> 
<pre><code class="prism language-c++">void get_primes(int n){
	for(int i=2;i&lt;n;i++){
        //i被筛了，直接跳过
        if(st[i]) continue;
        //i是素数，添加进数组,并筛掉与i成倍数的非素数
        else {primes[cnt ++ ] = i;
            for(int j=2*i;j&lt;=n;j+=i){
                //j一定不是素数
                st[j]=true;
            }
         }
    }
}
</code></pre> 
<h3><a id="_258"></a>线性筛素数</h3> 
<p>时间O(n)，解决重复筛</p> 
<pre><code class="prism language-c++">for（int i=2;i&lt;=n;i++){
    //i没被筛，加入
    if(!st[i]) primes[prime_count++]=i;
    for(int j=0;j&lt;prime_count;++j)
    {
        if(prime[j]*i&gt;n) break;
        //翻倍，一个数 * 素数一定为合数 
        st[primes[j]*i]=true;
        //退出循环，避免之后重复进行筛选
        if(i%primes[j]==0) break;
    }
}
</code></pre> 
<h3><a id="_281"></a>快速幂</h3> 
<pre><code class="prism language-c++">int qmi(int a,int b, int p){
    if(b==0)return 1 ; 
    int k = qmi(a,b/2,p)%p;
    // k*k可能会超过int 
    if(b%2==0)return (1LL*k*k) %p;
    else return ((1LL*k*k)%p*a)%p;
    
}
</code></pre> 
<h2><a id="_296"></a>石子合并</h2> 
<p>贪心：<strong>只能合并相邻的最小的两堆</strong></p> 
<pre><code class="prism language-c++">int n;
	int min_idx=0;
	int min_sum=1e7;
//	边界处理
	ve.push_back(1e7);
	int ans=0;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		int x;
		cin&gt;&gt;x;
		ve.push_back(x);
		if(min_sum&gt;ve[i]+ve[i-1]){
			min_sum=ve[i]+ve[i-1];
			min_idx=i;
		}
	}

	while(ve.size()&gt;2){
		ans += min_sum;
		ve[min_idx]=ve[min_idx]+ve[min_idx-1];
		ve.erase(ve.begin()+min_idx-1);
		
		min_sum=1e7;
//		min_idx=0;
	
		if(ve.size()&lt;=2) break;	
		for(int i=1;i&lt;ve.size();i++){
			if(min_sum&gt;ve[i]+ve[i-1]){
			min_sum=ve[i]+ve[i-1];
			min_idx=i;
		}
			
		}
	}

	cout&lt;&lt;ans&lt;&lt;endl;
	
</code></pre> 
<h2><a id="_340"></a>锯木棍</h2> 
<p>贪心-思想是WPL最小带权路径,永远合并最小的两个</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
//自定义比较结构体
struct cmp{
    //函数重载 注意两个括号！！！
	bool operator()(int a,int b){
        //稳定
		if(a==b) return false;
		else return a&gt;b;
		
	}
};

int main(int argc, char** argv) {
    //priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; que;
	priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; que;
	int n,l;
	cin&gt;&gt;n&gt;&gt;l;
	int tmp;
	int ans=0;
	while(n--){
		cin&gt;&gt;tmp;
		que.push(tmp);
	}	
	while(que.size()!=1){
		int a=que.top();
		que.pop();
		int b=que.top();
		que.pop();
			
		que.push(a+b);
		ans=ans+a+b;
	}
	cout&lt;&lt;ans;	
	return 0;
}
</code></pre> 
<h2><a id="_388"></a>并查集</h2> 
<pre><code class="prism language-c++">int Find(int a){
    int x=a;
    while(s[x]&gt;0){
        x=s[x];
    }
    return x;
}
void Union(int a,int b){
    root1=Find(a);
    root2=Find(b);
    if(root2==root1)return ;
    else{
        s[root2]=root1;
    }
    
}
</code></pre> 
<h2><a id="Dijkstra_409"></a>Dijkstra单源最短路</h2> 
<pre><code class="prism language-c++">int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，确定一个最短的点
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
    
        // 用t更新其他点的距离
        for (int j = 1; j &lt;= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    	
        st[t] = true;
    }
    
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];

}
</code></pre> 
<h2><a id="Python_444"></a>Python进制转换(整数无限大)</h2> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys

<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>
    a <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    a<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    b<span class="token operator">=</span><span class="token builtin">bin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    s<span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
</code></pre> 
<h2><a id="_458"></a>全排列</h2> 
<p>回溯法</p> 
<pre><code class="prism language-c++">void dfs(int k){
	if(k==n+1){
		for(int i=1;i&lt;=n;i++){
			cout&lt;&lt;arr[i]&lt;&lt;' ';
		}
		cout&lt;&lt;'\n';
		return ;
	}
	for(int i=1;i&lt;=n;i++){
		//还没访问的数
		if(!st[i]){
			st[i]=true;
			// 存储第k个数
			arr[k]=i;
			dfs(k+1);
			// 恢复-现场
			st[i]=false;
		}
	}
}
int main() {    
    cin&gt;&gt;n;
    dfs(1);
    
}

</code></pre> 
<h2><a id="_491"></a>神奇的口袋</h2> 
<p>有一个神奇的口袋，总容积是40，有n个物品,体积为Vi，装满40有多少种装法</p> 
<pre><code class="prism language-c++">void dfs(int u,int j){
    if(u==40){
        ans++;   
    }
    else{
        //从j开始，前面用过的舍弃掉，防止重复
        for(int i=j;i&lt;n;i++){
            if(!st[i]){
                st[i]=true;
                dfs(u+v[i],i);
                st[i]=false;
            }
        }
    }
}
</code></pre> 
<h2><a id="II_515"></a>全排列II</h2> 
<p>带有重复元素的全排列</p> 
<pre><code class="prism language-c++">void dfs(int k){
	if(k==n+1){
		for(int i=1;i&lt;=n;i++){
			cout&lt;&lt;arr[i]&lt;&lt;' ';
		}
		cout&lt;&lt;'\n';
		return ;
	}
	for(int i=1;i&lt;=n;i++){
		//还没访问的数
		if(!st[i]){
			st[i]=true;
			// 存储第k个数
			arr[k]=i;
			dfs(k+1);
			// 恢复-现场
			st[i]=false;
       		
            //***当与后一个元素重复时，跳过不排列,且这一步要在恢复现场之后做
            while(s[i+1]==s[i])i++;
		}
	}
}
int main() {    
    cin&gt;&gt;n;
   //使重复的元素排在一起
    sort(a,a+n);
    dfs(1);
    
}
</code></pre> 
<h2><a id="_552"></a>放苹果</h2> 
<p>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？</p> 
<pre><code class="prism language-c++">//处理边界
for(int i=0;i&lt;=m;i++){
    //为0的可以不用处理，数组默认为0
    //1个盘子的
    dp[i][1]=1;
}
for(int i=0;i&lt;=n;i++){
    //0个苹果的
    dp[0][i]=1;
}

for(int i=1;i&lt;=m;i++){
    for(int j=1;j&lt;=n;j++){
        //如果盘子多，多余的用不到的盘子都是没用的
        if(j&gt;i){
            dp[i][j]=dp[i][i];
        }
        //如果苹果多，dp[i][j]等于 有空盘子的(挑一个盘子为空)+没有空盘子(每个盘子初始都放一个苹果)的状态
        else{
            dp[i][j]=dp[i][j-1]+dp[i-j][j];
        }

    }
}
</code></pre> 
<h2><a id="k_587"></a>求第k小</h2> 
<p>使用快排划分的思想</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
/**求第k小 */
using namespace std;
int n;
int a[10001];
int k;
void partition(int start,int end) {
	int pivot=a[start];
	int l=start;
	int r=end;
	while(l&lt;r) {
		while(a[l]&lt;pivot) {
			l++;
		}
		while(a[r]&gt;pivot) {
			r--;
		}
		swap(a[l],a[r]);
	}
	a[l]=pivot;
	if(l==k-1) {
		cout&lt;&lt;a[l];
		return ;
	}
	else if(l&lt;k){
		partition(l+1,end);
	}
	else{
		partiton(start,l);
	}
}



int main(int argc, char** argv) {
	cin&gt;&gt;n;
	cin&gt;&gt;k;
	for(int i=0; i&lt;n; i++) {
		cin&gt;&gt;a[i];
	}
	partition(0,n-1);
	return 0;
}
</code></pre> 
<h2><a id="_638"></a>八皇后问题</h2> 
<pre><code class="prism language-c++"></code></pre> 
<h2><a id="_643"></a>哈夫曼编码</h2> 
<pre><code class="prism language-c++">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; q;
int alpha[26];
//去最小的两个
</code></pre> 
<h2><a id="KMP_651"></a>KMP算法</h2> 
<pre><code class="prism language-C++">//字符串下标都从0开始
void getNextTable(int m){
    int j=0;
    next[0]=-1;
    int i=-1;
    while(j&lt;m){
        if(i==-1 || pattern[j]==pattern[i]){
            i++;
            j++;
            next[j]=i;
        }
        else{
            i=next[i];
        }
    }
    return ;
}


int kMP(string a,string b){
    int i=0,j=0;
    while(i&lt;n&amp;&amp;j&lt;m){
        if(j==-1 || s[i]==pattern[j]){
            i++;
            j++;
        }
        else{
            j=next[j];
        }
    }
    if(j==m){
        return i-j+1;
    }
    else{
        //匹配失败
        return -1;
    }
}
</code></pre> 
<h2><a id="_696"></a>遍历建立二叉树</h2> 
<blockquote> 
 <p><strong>TNode(char c):data©,left(nullptr),right(nullptr){};</strong></p> 
</blockquote> 
<pre><code class="prism language-c++">using TreeNode = struct TNode{
	char data;
	struct TNode* left;
	struct TNode* right;
	TNode(char c):data(c),left(nullptr),right(nullptr){};
};

TreeNode* Build(TreeNode* root,char c){
    
	if(c=='#')return NULL;
//	C style：(TreeNode*)malloc(sizeof(TreeNode))
	root=new TNode(c);
	char c1=s[cnt++];
	root-&gt;left=Build(root-&gt;left,c1);
	char c2=s[cnt++];
	root-&gt;right=Build(root-&gt;right,c2);
	
	return root;
}

void Inorder(TreeNode* root){
	if(root-&gt;left)
	Inorder(root-&gt;left);
	cout&lt;&lt;root-&gt;data&lt;&lt;endl;
	if(root-&gt;right)
	Inorder(root-&gt;right);
	
}
void postOrder(TreeNode* root){
	
}


int main(int argc, char** argv) {
	TreeNode* T=NULL;
	T=Build(T,s[cnt++]);
	Inorder(T);
	
	return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a438c2748d5e44bc94fc04db7f4f0389/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络工程师——2024自学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef423be91e3c397fed988717d4e1dd75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">魔域枫叶魔方</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>