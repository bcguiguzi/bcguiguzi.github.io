<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在 HTML canvas 绘制文本 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在 HTML canvas 绘制文本" />
<meta property="og:description" content="绘制文本有两种方式：
fillText(text, x, y)strokeText(text, x, y) 下面，我们来看看如何在 canvas 上绘制文本。
我们先创建一个 canvas 标签，并设置基本的宽高：
&lt;canvas width=&#34;200&#34; height=&#34;400&#34;&gt;&lt;/canvas&gt; 首先，获取对画布的引用：
const canvas = document.querySelector(&#39;canvas&#39;) 并从中创建一个上下文对象：
const ctx = canvas.getContext(&#39;2d&#39;) getContext() 方法根据作为参数传递的类型返回画布上的绘图上下文。
有效值为：
2d 二维渲染上下文 webgl 使用 WebGL 版本 1 webgl2 使用 WebGL 版本 2与 ImageBitmap 一起使用的 bitmaprenderer 点击此处查看详细内容。
现在我们可以调用 ctx 对象的 fillText() 方法：
ctx.fillText(&#39;Hello, Canvas!&#39;, 100, 100) fillText 方法的后两个参数分别为 x 和 y 的坐标。
在调用 fillText() 之前，还可以传递其他属性来自定义外观，例如：
ctx.font = &#39;bold 20pt Menlo&#39; ctx.fillStyle = &#39;#ccc&#39; ctx." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2a6c5168683742271720298859addfd5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T14:21:59+08:00" />
<meta property="article:modified_time" content="2022-09-08T14:21:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在 HTML canvas 绘制文本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article class="_2rhmJa" style="font-size: 16px;"> 
 <p>绘制文本有两种方式：</p> 
 <ul><li><code>fillText(text, x, y)</code></li><li><code>strokeText(text, x, y)</code></li></ul> 
 <p>下面，我们来看看如何在 <code>canvas</code> 上绘制文本。</p> 
 <p>我们先创建一个 <code>canvas</code> 标签，并设置基本的宽高：</p> 
 <pre class="has"><code class="html">&lt;canvas width="200" height="400"&gt;&lt;/canvas&gt;</code></pre> 
 <p>首先，获取对画布的引用：</p> 
 <pre class="has"><code class="js">const canvas = document.querySelector('canvas')</code></pre> 
 <p>并从中创建一个上下文对象：</p> 
 <pre class="has"><code class="js">const ctx = canvas.getContext('2d')</code></pre> 
 <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHTMLCanvasElement%2FgetContext" rel="nofollow noopener noreferrer" target="_blank"><code>getContext()</code></a> 方法根据作为参数传递的类型返回画布上的绘图上下文。</p> 
 <p>有效值为：</p> 
 <ul><li> <code>2d</code> 二维渲染上下文</li><li> <code>webgl</code> 使用 WebGL 版本 1</li><li> <code>webgl2</code> 使用 WebGL 版本 2</li><li>与 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FImageBitmap" rel="nofollow noopener noreferrer" target="_blank"><code>ImageBitmap</code></a> 一起使用的 <code>bitmaprenderer</code> </li></ul> 
 <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHTMLCanvasElement%2FgetContext%23%25E5%258F%2582%25E6%2595%25B0" rel="nofollow noopener noreferrer" target="_blank">点击此处查看详细内容</a>。</p> 
 <p>现在我们可以调用 <code>ctx</code> 对象的 <code>fillText()</code> 方法：</p> 
 <pre class="has"><code class="js">ctx.fillText('Hello, Canvas!', 100, 100)</code></pre> 
 <p><code>fillText</code> 方法的后两个参数分别为 <code>x</code> 和 <code>y</code> 的坐标。</p> 
 <p>在调用 <code>fillText()</code> 之前，还可以传递其他属性来自定义外观，例如：</p> 
 <pre class="has"><code class="js">ctx.font = 'bold 20pt Menlo'
ctx.fillStyle = '#ccc'
ctx.fillText('Hello, Canvas!', 100, 100)</code></pre> 
 <ul><li> <code>font</code> 属性更改字体样式</li><li> <code>fillStyle</code> 属性更改图形的填充颜色。默认值是 <code>#000</code>。</li></ul> 
 <p>如果画布看起来太小，你可以设置它的 <code>width</code> 和 <code>height</code> 属性：</p> 
 <pre class="has"><code class="js">ctx.width = 600
ctx.height = 600</code></pre> 
 <p>另一种绘制文本的方式：</p> 
 <pre class="has"><code class="js">ctx.strokeStyle = '#ccc'
ctx.strokeText('Hello, Canvas!', 100, 100)</code></pre> 
 <p><code>strokeStyle</code> 属性更改图形的描边颜色。默认值是 <code>#000</code>。</p> 
 <p><code>fillStyle</code> 和 <code>strokeStyle</code> 接受任何有效的 CSS 颜色，包括字符串和 RGB 计算。</p> 
 <p>您还可以更改与文本(<code>* = default</code>)相关的其他属性：</p> 
 <ul><li> <code>textAlign: start*, end, left, right, center</code> — 文本的对齐方式</li><li> <code>textBaseline: top, hanging, middle, alphabetic*, ideographic, bottom</code> — 文本基线</li><li> <code>direction: ltr | rtl | inherit*</code> — 文本方向</li></ul> 
 <blockquote> 
  <p>您可以在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCanvasRenderingContext2D" rel="nofollow noopener noreferrer" target="_blank">此处</a>找到有关使用 <code>2d</code> 选项返回的所有 API 。</p> 
 </blockquote> 
 <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.juejin.cn%2Fpen%2F7128056881381113892" rel="nofollow noopener noreferrer" target="_blank">演示地址</a></p> 
 <hr> 
 <p>本文首发 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flio-zero%2Fblog" rel="nofollow noopener noreferrer" target="_blank">blog</a>，如果喜欢或者有所启发，欢迎 <code>Star</code>，对作者也是一种鼓励。</p> 
</article>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba68f27dd8612f8f99c97790268af956/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">各种卷积方式的最全讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5105ef81730b95630a4091fbcef69fac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Codeforces Round #775 (Div. 2) ABCDE题解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>