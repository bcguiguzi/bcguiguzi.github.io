<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】初入数据结构中的B类树（B Tree , B&#43; Tree） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】初入数据结构中的B类树（B Tree , B&#43; Tree）" />
<meta property="og:description" content="初入数据结构中的B类树（B- Tree , B&#43; Tree） 如果觉得对你有帮助，能否点个赞或关个注，以示鼓励笔者呢？！博客目录 | 先点这里
前提概念 数据域指针域 B树 什么是B树(B-树)？B树的定义B树的特性B树的高 B&#43; 树 什么是B&#43;树？B&#43;树的定义B&#43;树的小特性为什么B&#43;树会替代B树？ 为什么需要B树，B&#43;树？ 引文为什么我们需要B类树？
前提概念 为了更好的理解B类树，我们先来简单的了解一下两个概念
数据域 B类树的结点中有两个区域，一个是数据域，一个是指针域
什么是数据域？
简单的说，B类树中每个结点存储数据的地方，我们就称之为数据域而数据域中存储的数据通常是一个个的键值对，键值对就分为键(key)和值(value)，这里通常称键为关键字，也通常会将关键字直接指代整个键值对站在数据库索引的角度，关键字就是用于建立索引的字段值，而对应的值就是该关键字所对应的目的数据，可以是主键信息，也可以指向实际数据的地址，甚至是完整的一行数据 指针域 什么是指针域？
我们知道二叉树在代码的实现中，通常会有两个指针，既左孩子指针和右孩子指针。而这两个指针所在的区域，我们就称之为指针域而存放左右孩子指针的因为B类树并不是一棵二叉树，它是一棵多叉树。也就说明了，一棵B类树，可能有多个指针，每个的结点的所有的指针所在的区域就是我们说的指针域啦。概念都是一样的。 B树 什么是B树(B-树)？ B-树，即为B树。需要强调的是它们两者都是同一种树，并非两种不一样的树。因为B树的英文名称为B-tree，-实际是杠的意思，但是也就不知怎么的B-tree就被翻译成为B-(减)树。
B树，又名B-树(B减树)。它是一棵多路平衡多路查找树
B树的定义 一棵m阶B树的定义
结点需要满足
(1) 根结点至少有两个孩子结点
(2) 树中每个结点最多有m个孩子结点(m&gt;=2)
(3) 除根结点和叶子结点外，其他所有结点至少要有 ceil(m/2)个孩子
(4) 所有的叶子结点都位于同一层（平衡特性）
关键字需要满足
假设每个非叶子结点中包含n个关键字信息，关键字以k表示，指针以p表示
(1) Ki (i = 1,…,n)某个非叶子结点的关键字，关键字需要满足升序序列排序，k(i-1) &lt; k(i)
(2) 每个非叶子结点中的关键字个数n需要满足 ceil(m/2) -1 &lt;= n &lt;= m - 1
(3) 非叶子结点的指针p[1]…p[m]中
第一个指针，p[1]指向的孩子结点的所有关键字必然小于当前结点k[1]关键字；最后一个指针，p[m]指向的孩子结点的所有关键字肯定大于当前结点k[m-1]关键字 ;其他p[i]指向孩子结点所有的关键字必然在当前结点(k[i-1],k[i])的开区间范围内 通俗版解释一下
m就是几阶的含义，m取决结点的容量和相关配置。3阶B树的每个结点分叉数最多为3，最多三个孩子结点ceil函数是指向上取整的意思，非四舍五入，如ceil(1.5) = 2, ceil(1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f62c605e2475bcea0d3f24cc2b06c7f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-12T09:16:51+08:00" />
<meta property="article:modified_time" content="2019-07-12T09:16:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】初入数据结构中的B类树（B Tree , B&#43; Tree）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="BB_Tree__B_Tree_0"></a>初入数据结构中的B类树（B- Tree , B+ Tree）</h3> 
<hr> 
<p><font color="grey"><strong>如果觉得对你有帮助，能否点个赞或关个注，以示鼓励笔者呢？！<a href="https://blog.csdn.net/SnailMann/article/details/88392514">博客目录 | 先点这里</a></strong></font></p> 
<ul><li><strong>前提概念</strong> 
  <ul><li>数据域</li><li>指针域</li></ul> </li><li><strong>B树</strong> 
  <ul><li>什么是B树(B-树)？</li><li>B树的定义</li><li>B树的特性</li><li>B树的高</li></ul> </li><li><strong>B+ 树</strong> 
  <ul><li>什么是B+树？</li><li>B+树的定义</li><li>B+树的小特性</li><li>为什么B+树会替代B树？</li></ul> </li><li><strong>为什么需要B树，B+树？</strong> 
  <ul><li>引文</li><li>为什么我们需要B类树？<br> <br></li></ul> </li></ul> 
<h4><a id="font_color__block_font_22"></a><font color="block">前提概念</font></h4> 
<hr> 
<p>为了更好的理解B类树，我们先来简单的了解一下两个概念</p> 
<h5><a id="font_color__greenfont_26"></a><font color="green">数据域</font></h5> 
<p>B类树的结点中有两个区域，一个是数据域，一个是指针域</p> 
<p><strong>什么是数据域？</strong></p> 
<ul><li>简单的说，B类树中每个结点存储数据的地方，我们就称之为数据域</li><li>而数据域中存储的数据通常是一个个的键值对，键值对就分为<code>键(key)</code>和<code>值(value)</code>，这里通常称键为<code>关键字</code>，<strong>也通常会将<code>关键字</code>直接指代整个键值对</strong></li><li>站在数据库索引的角度，关键字就是用于建立索引的字段值，而对应的值就是该关键字所对应的目的数据，可以是主键信息，也可以指向实际数据的地址，甚至是完整的一行数据</li></ul> 
<hr> 
<h5><a id="font_color__green_font_39"></a><font color="green">指针域</font></h5> 
<p><strong>什么是指针域？</strong></p> 
<ul><li>我们知道二叉树在代码的实现中，通常会有两个指针，既左孩子指针和右孩子指针。而这两个指针所在的区域，我们就称之为指针域</li><li>而存放左右孩子指针的因为B类树并不是一棵二叉树，它是一棵多叉树。也就说明了，一棵B类树，可能有多个指针，每个的结点的所有的指针所在的区域就是我们说的指针域啦。概念都是一样的。</li></ul> 
<br> 
<h4><a id="font_color__block_Bfont_54"></a><font color="block">B树</font></h4> 
<hr> 
<h5><a id="font_color__greenBBfont_57"></a><font color="green">什么是B树(B-树)？</font></h5> 
<blockquote> 
 <p><code>B-树</code>，即为<code>B树</code>。需要强调的是它们两者都是同一种树，并非两种不一样的树。因为B树的英文名称为<code>B-tree</code>，<code>-</code>实际是杠的意思，但是也就不知怎么的B-tree就被翻译成为<code>B-(减)树</code>。</p> 
</blockquote> 
<p>B树，又名B-树(<code>B减树</code>)。它是一棵多路平衡多路查找树</p> 
<hr> 
<h5><a id="font_color__greenBfont_64"></a><font color="green">B树的定义</font></h5> 
<blockquote> 
 <p>一棵m阶B树的定义</p> 
 <ul><li> <p><strong>结点需要满足</strong><br> <strong>(1)</strong> 根结点至少有两个孩子结点<br> <strong>(2)</strong> 树中每个结点最多有m个孩子结点<code>(m&gt;=2)</code><br> <strong>(3)</strong> 除根结点和叶子结点外，其他所有结点至少要有 <code>ceil(m/2)</code>个孩子<br> <strong>(4)</strong> 所有的叶子结点都位于同一层（<code>平衡特性</code>）</p> </li><li> <p><strong>关键字需要满足</strong><br> 假设每个非叶子结点中包含<code>n</code>个关键字信息，关键字以<code>k</code>表示，指针以<code>p</code>表示<br> <strong>(1)</strong> Ki (i = 1,…,n)某个非叶子结点的关键字，关键字需要满足<code>升序</code>序列排序，<code>k(i-1) &lt; k(i)</code><br> <strong>(2)</strong> 每个非叶子结点中的关键字个数n需要满足 <code>ceil(m/2) -1</code> &lt;= <code>n</code> &lt;= <code>m - 1</code><br> <strong>(3)</strong> 非叶子结点的指针p[1]…p[m]中</p> 
   <ul><li>第一个指针，<code>p[1]</code>指向的<code>孩子结点的所有关键字</code>必然小于<code>当前结点k[1]关键字</code>；</li><li>最后一个指针，<code>p[m]</code>指向的<code>孩子结点的所有关键字</code>肯定大于<code>当前结点k[m-1]关键字</code> ;</li><li>其他<code>p[i]</code>指向孩子结点所有的关键字必然在<code>当前结点(k[i-1],k[i])</code>的开区间范围内</li></ul> </li></ul> 
</blockquote> 
<p><strong>通俗版解释一下</strong></p> 
<ul><li><code>m</code>就是几阶的含义，m取决结点的容量和相关配置。<strong>3阶B树的每个结点分叉数最多为3，最多三个孩子结点</strong></li><li><code>ceil函数</code>是指向上取整的意思，非四舍五入，如<code>ceil(1.5) = 2</code>, <code>ceil(1.2) = 2</code> ,<code>ceil(3.4) = 4</code></li><li><strong><code>关键字定义(2)</code></strong> 的意思可以通俗的理解成，每个非叶子结点的关键字个数肯定小于该结点能拥有的孩子结点树，最多就存储<code>m - 1</code>个关键字，最少也要存储<code>ceil(m/2) - 1</code>个</li><li><strong><code>关键字定义(3)</code></strong> 的意思是某结点<code>最左孩子结点的所有关键字</code>肯定小于当前结点<code>最左关键字</code>的值，就像下图的<code>3,5</code>肯定小于<code>8</code></li><li><code>最右孩子结点的所有关键字</code>肯定大于当前结点的<code>最右关键字</code> ; 例如下图的<code>13</code>肯定大于12和8</li><li>而中间的孩子结点的所有关键字肯定满足于一个当前结点关键字的开区间范围<code>(k[i - 1] , k[i])</code> , 例如下图的p2孩子结点的9关键字肯定位于<code>(8,12)</code>关键字之间<br> <img src="https://images2.imgbox.com/a1/ee/fkZGHCdw_o.png" alt="在这里插入图片描述"><br> <code>上图是一个3阶B树</code></li></ul> 
<p>总之，我们大致的知道，B树并不是一棵二叉搜索树，而是一颗具有平衡性质的多路查找树。同时B树的定义比较复杂，具有指针域和关键字域的概念，一个结点可以存储多个数据元素，上一段是对结点定义约束，下一段是对结点内部所存储的关键字的约束</p> 
<hr> 
<h5><a id="font_color__greenBfont_96"></a><font color="green">B树的特性</font></h5> 
<ul><li>关键字集合分布在整棵树中</li><li>任何一个关键字出现且只出现在一个结点中</li><li>搜索有可能在非叶子结点结束</li><li>B树的查找性能基本等价于平衡二叉树的二分查找（不考虑IO的情况下）</li><li>可以实现自平衡，让所有叶子结点都在同一个层级</li></ul> 
<hr> 
<h5><a id="font_color__greenBfont_105"></a><font color="green">B树的高</font></h5> 
<p>现在有一个问题，<strong>关键字总数为n的m阶B树的高是多少？</strong></p> 
<ul><li> <p>(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           l 
          
         
           o 
          
          
          
            g 
           
           
           
             c 
            
           
             e 
            
           
             i 
            
           
             l 
            
           
             ( 
            
           
             m 
            
           
             / 
            
           
             2 
            
           
             ) 
            
           
          
          
          
            ( 
           
          
            n 
           
          
            + 
           
          
            1 
           
          
            ) 
           
          
            / 
           
          
            2 
           
          
         
        
          log_{ceil(m/2)}{(n+1)/2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">c</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathit mtight">m</span><span class="mord mtight">/</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathit">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span></span></span>) + 1</p> </li><li> <p>既底数是<code>ceil(m/2)</code>，最后的对数结果 + 1就是这颗B树的高</p> </li></ul> 
<p><strong>引用至<a href="https://baike.baidu.com/item/B%E6%A0%91/5411672" rel="nofollow">@百度百科</a></strong><br> <img src="https://images2.imgbox.com/7a/70/UdrdLQj8_o.png" alt="在这里插入图片描述"></p> 
<p>因为求B树，B+树的高的资料的确是有些少，所以看完之后，说实话，我是一脸懵逼的。的确有挺多问题，我都没有理解好，比如说B树含N个关键字，为什么就有N +1个叶子结点呢？这个是怎么推出来的。这个问题可以确定的话，中间步骤还是好理解的。但是…但是后面的归纳还是懵了。</p> 
<p>所以，想想算了，时间有限，因为学习性价比，所以还是暂时留给有志之士去解答吧，贫道暂无能为力</p> 
<br> 
<h4><a id="font_color__block_B_font_124"></a><font color="block">B+ 树</font></h4> 
<hr> 
<h5><a id="font_color__greenBfont_128"></a><font color="green">什么是B+树？</font></h5> 
<blockquote> 
 <p>B+树是一种树型数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。<br> <a href="https://baike.baidu.com/item/B+%E6%A0%91/7845683" rel="nofollow">B+树 - @百度百科</a></p> 
</blockquote> 
<hr> 
<h5><a id="font_color__greenBfont_134"></a><font color="green">B+树的定义</font></h5> 
<blockquote> 
 <p><strong>B+树是B树的变种，其定义基本与B树相同</strong>，除了</p> 
 <ul><li>非叶子结点的子树指针与关键字<strong>个数相同</strong>，不像B树的关键字数要少于指针数</li><li>非叶子结点的子树指针p[i]所指向的<code>孩子结点的所有关键字</code>处于当前结点关键字<code>[k[i],k[i+1])</code>左闭右开的范围区间内</li><li>所有的非叶子结点的关键字，都会继承至其中孩子结点中，是其孩子结点元素的最大值或最小值</li><li>非叶子结点仅用来索引，数据都保存在叶子结点中</li><li>所有叶子结点的数据均有两个<code>链指针</code>分别指向上一个数据和下一个数据，构成<strong>双向链表</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/46/5f/K9iBAMaW_o.png" alt="在这里插入图片描述"><br> <strong>B树和B+树的区别</strong></p> 
<ul><li>B+树，不同于B树的是，所有数据都存储在叶子结点中，非叶子结点不存储任何数据，仅仅是一个索引值。所以B+树查找的时间复杂度非常稳定，都是从根遍历到叶子结点，不会在非叶子结点上中断。</li></ul> 
<hr> 
<h5><a id="font_color__greenBfont_152"></a><font color="green">B+树小特性</font></h5> 
<p>因为B+树的定义中，所有的非叶子结点的关键字，都会继承至其中孩子结点中，是其孩子结点元素的最大值或最小值，所以就造成了一个特性，<strong>根结点的最小值，<code>可能</code>是整棵树的最小值。根结点的最大值<code>可能</code>是整棵树的最大值</strong></p> 
<p><strong>举例如下图：</strong></p> 
<p><img src="https://images2.imgbox.com/aa/b6/0Pa7oz8O_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/94/iYhWUZi9_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="font_color__greenBBfont_162"></a><font color="green">为什么B+树会替代B树？</font></h5> 
<p><strong>总之呢，在数据库索引，文件系统等许多场景中，B+树逐渐替代B树，这是为什么呢？</strong></p> 
<ul><li><strong><code>B+树的磁盘读写代价更低</code></strong><br> 因为B+树的中间结点存储的都是索引数据，仅仅是一个地址，并非直接的数据，所以同一个结点中（同一个磁盘页大小），B+树可容纳的关键字数会比B树更多（因为一个简单的地址几乎肯定小于一个直接的数据）。<strong>所以同样的数据量下，B+树会比B树更加“矮胖”，树高更小，所以查询时需要的IO次数就更少</strong></li><li><strong><code>B+树的查询效率更加稳定</code></strong><br> 因为B+树的所有元素都存储在叶子结点中，而叶子结点都属于同一层级，<strong>每一个B+树查询都是从根结点遍历到叶子结点的过程</strong>，所以不管查询什么，时间复杂度相比B树查询都更加的稳定和近似。</li><li><strong><code>B+树更有利对数据的扫描</code></strong><br> B树中虽然解决了查询的效率，但是如果需要查询一串相邻的数值，有可能需要回溯来回扫描或是从根结点多次中序遍历。而B+树的所有元素都存储叶子结点，每个叶子结点都有指向下一个结点的指针，直接线性遍历即可。<strong>同样B+树也更加的利于做<code>范围查询</code></strong></li></ul> 
<br> 
<h4><a id="font_color__block_BBfont_178"></a><font color="block">为什么需要B树，B+树？</font></h4> 
<hr> 
<h5><a id="font_color__greenfont_183"></a><font color="green">引文</font></h5> 
<p><font color="orange"><strong>阶段一</strong></font><br> 在了解为什么需要B类树之前，我们首先来了解一下，<strong>我们为什么需要二叉查找树？</strong><br> <img src="https://images2.imgbox.com/ff/9f/oxVvhYgc_o.png" alt="在这里插入图片描述"><br> <strong>我们为什么需要二叉查找树呢？</strong></p> 
<ul><li>简单的说，就是我们想要更快的从一堆数据中，找到我们想要的数据对吧。</li><li>一个n长度的线性数据集合，正确情况下的查找，就是一个一个的遍历，时间复杂度是<code>O(n)</code>, 所以非常慢，这时候我们就引入了<strong>二分查找</strong>，时间复杂度就从<code>O(n)</code>骤降到<code>O(logn)</code>，<strong>Wow! NiuBei!!</strong></li></ul> 
<p><font color="orange"><strong>阶段二</strong></font><br> 我们有了二叉查找树啦，终于可以快速的查找速度了。但是有一天，我们突然的发现这个二叉查找树，也变的很慢很慢？？<strong>怎么回事？有Bug吗？！！！</strong><br> <img src="https://images2.imgbox.com/88/3f/9ePmUXXV_o.png" alt="在这里插入图片描述"><br> <strong>自平衡二叉查找树</strong><br> 因为二叉查找树的不平衡现象，导致最差的查找结果会退化成O(n)的线性遍历，所以我们要避免出现这么一个情况。于是<code>自平衡二叉树</code>就出现了</p> 
<ul><li>自平衡二叉查找树的出现，让二叉查找树在不断的增删查改中得到平衡的维护。<strong>总之一句话，就是不会让搜索退化成O(n)的线性遍历，依然保持高性能的O(logn)， Wow! NiuBei!!</strong></li><li>当然这个阶段也有很多的分类哈，比如<code>AVL树</code>，<code>红黑树</code>，等等</li></ul> 
<p><font color="orange"><strong>阶段三</strong></font></p> 
<ul><li> <p><strong>鉴于我知识体系的逐渐丰富，我突然想造个数据库诶，然后陷入造数据库的庞大工程中…</strong><br> 嗯，使用起来还可以诶，我真NiuBi。（一段时间后，数据量大了~~）</p> </li><li> <p><strong>Wo Cao! 这有点慢，怎么办？怎么办？</strong><br> 行吧，那就上索引吧，加入索引特性，<strong>我的<code>索引</code>就用<code>平衡二叉搜索树</code>来实现吧，之前感觉很良好</strong>（<code>AVL树</code>，<code>红黑树</code>等随便一种啦，逃…），</p> </li><li> <p><strong>索引新特性上线中</strong><br> 呀，提升不小呀! 至少比以前快了来不少，看来我还是<strong>Niu Bei !</strong> (数据量持续增大中~)</p> </li><li> <p><strong>Wo Cao! 怎么有索引还这么慢？又出Bug了？</strong><br> 啊，我上索引了，<strong>IO操作还这么频繁的嘛？</strong> IO资源都要炸啦！ 凉凉，看来还是我操作系统基础太差了，不该用平衡二叉树作为索引的底层实现呀！</p> </li></ul> 
<hr> 
<h5><a id="font_color__greenBfont_218"></a><font color="green">为什么我们需要B类树？</font></h5> 
<p>从上面的引文中，我们知道，当我们使用平衡二叉查找树作为数据库索引的底层实现时，会面临着大量IO操作，从而导致查找性能不佳。</p> 
<p><font color="orange"><strong>原因一</strong></font><br> <strong>那么以平衡二叉查找树为底层实现的索引查找为什么会面临这么大量的IO操作呢？</strong></p> 
<ul><li> <p>我们知道平衡二叉查找树的本质是一棵二叉树，二叉树的每个结点最多只能有两个孩子结点。树高为n的二叉树最多只能有<code>(2^n) - 1</code>个结点。</p> </li><li> <p>也就是说, 一棵高为n的平衡二叉查找树，最多只能存放<code>(2^n) -1</code>个数据的索引。那么我们的数据库如果有1亿的数据量，那么我们索引树的高大概就有27层，<code>2^27</code> = <code>1,3421,7728(1亿+)</code>。</p> </li><li> <p>当我们要在1亿个数据中查找我们想要的数据，<strong>最差的情况下，就要进行27次判断，也就是要进行27次IO操作。</strong> 这27次IO操作听上去可能还很少的样子，但是因为磁盘读写速度很慢（不是内存计算呀），所以27次慢速读写累加起来就是一个庞大的耗时操作了。</p> </li></ul> 
<p>所以现在我们知道了以平衡二叉查找树为底层实现的索引查找为什么这么慢了。而B树，B+ 树可以远远的降低我们索引树的高度，同样的数据量，因为B树，B+树的一个结点可以容纳很多很多个关键字，同时还可以由很多个孩子结点，从几个到上千个，所以整体索引树的高度可能只有 <strong><code>3~4层</code></strong> 的高。<code>27 -&gt;4</code> 什么概念？简直是削减呀！<strong>这就是我们为什么需要B类树的原因之一啦</strong></p> 
<blockquote> 
 <ul><li>简单的说，B类树在数据库索引上的应用性能会比平衡二叉搜索高，并不是B类树在设计上就比平衡二叉搜索树牛逼，而是在数据库读写是站在磁盘读写基础上的，追求的是少量的IO操作，而B类树恰好可以做到这一点。</li><li>但是如果要换成以内存计算为前提的查找，B类树的性能就不一定要比平衡二叉树要高了，性能甚至会更低。因为内存计算中没有所谓的IO操作。以降低IO操作次数为卖点之一的B类树没有太多的优势可言了。</li></ul> 
</blockquote> 
<p><font color="orange"><strong>原因二</strong></font></p> 
<p>我们知道关系型数据库，文件管理系统领域，数据主要是存储在磁盘中的</p> 
<ul><li>而磁盘读取数据是以<strong>盘块</strong>(<code>block</code>)为基本单位的，<strong>既磁盘读取数据一个IO操作就读取一个盘块的数据</strong>。而我们的B类树一个结点可以存储多个关键字就恰好可以符合这么一个磁盘的特性</li><li>想想如果磁盘每一个盘块的数据，恰好对映射到B类树的一个结点中，既每一个结点所存储的关键字量恰好对应一个磁盘盘块的数据。同一个结点中关键字的线性遍历，也不需要在磁盘方面<strong>跨盘块</strong>进行操作，这样就又省了一笔IO操作</li></ul> 
<p><strong>这就是我们为什么需要B类树的原因之二</strong></p> 
<p><font color="orange"><strong>总结一下</strong></font></p> 
<p>所以我们可以简单的总结一下，为什么在数据库，文件管理系统领域，我们需要使用B类树来替代平衡二叉搜索树成为索引的底层实现，主要就是两个原因：</p> 
<ul><li>B类树的一个结点可以存储多个数据， 可以有多个分支，<strong>所以可以大大的降低正棵树的高度，减少磁盘IO操作</strong></li><li>B类树的一个结点可以存储多个数据的特点，恰好也符合了磁盘的物理构造特性，通过将一个结点最多存储对应一个物理盘块的数据，<strong>让同结点数据进行线性遍历时，不需要跨盘块进行查询，同样也减少了磁盘查询时间</strong></li></ul> 
<br> 
<h4><a id="font_color__block_font_264"></a><font color="block">参考资料</font></h4> 
<hr> 
<ul><li><a href="https://www.cnblogs.com/hdk1993/p/5840599.html" rel="nofollow">从B树、B+树、B*树谈到R 树 - @作者：程序员修练之路</a></li><li><a href="https://zhuanlan.zhihu.com/p/27700617" rel="nofollow">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 - @勤劳的小手</a></li><li><a href="https://www.cnblogs.com/tangchuanyang/p/6634581.html" rel="nofollow">mysql在innodb索引下b+树的高度问题。- @作者：面壁偷光</a></li><li><a href="https://www.cnblogs.com/nullzx/p/8729425.html" rel="nofollow">B树和B+树的插入、删除图文详解 - @作者：nullzx</a></li><li><strong>如果觉得对你有帮助，能否点个赞或关个注，以示鼓励笔者呢？！</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/204d9d5b1a6661e5ada721cf6645fb0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我的Redis集群搭建之路</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf28a992bca9991d633ea42419de5845/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c/c&#43;&#43; float和double的表示范围详细解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>