<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;实现的二叉树创建和遍历，超入门邻家小女也懂了 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;实现的二叉树创建和遍历，超入门邻家小女也懂了" />
<meta property="og:description" content="目录
二叉树 特点
性质
二叉树的创建
声明
创建
成员运算符-&gt;
批量创建
完全二叉树的创建
打印二叉树
普通二叉树的创建
二叉树的遍历
层序遍历
先序遍历
中序遍历
后序遍历
递归法
前中后序对比
DFS遍历
树的相关术语
特殊二叉树
满二叉树
完全二叉树
二叉树 树（Tree）是n(n≥0)个节点的有限集。在任意一棵树中有且仅有一个特定的称为根（Root）的节点；当n＞1时，其余节点可分m(m＞0)为个互不相交的有限集T1,T2,...,Tm；其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。
二叉树（Binary Tree）是一种特殊的有序树型结构，所有节点最多只有2棵子树。
特点 （1）每个节点至多有两棵子树；
（2）二叉树的子树有左右之分；
（3）子树的次序不能任意颠倒（有序树）。
性质 （1）二叉树的第i层上至多有2^(i-1)个节点（i≥1）。
（2）深度为h的二叉树中至多含有2^h-1个节点(h≥1)。
（3）若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2&#43;1。
（4）具有n个节点的满二叉树深为log2n&#43;1。
（5）若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），
那么，对于编号为i（i≥1）的节点： 当i=1时，该节点为根，它无双亲节点。
当i&gt;1时，该节点的双亲节点的编号为i/2。
若2i≤n，则有编号为2i的左节点，否则没有左节点。
若2i&#43;1≤n，则有编号为2i&#43;1的右节点，否则没有右节点。
二叉树的创建 声明 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 在C/C&#43;&#43;语言中，经常使用 NULL 来表示空指针。
NULL在头文件里的定义：
#ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif 即在 C&#43;&#43;中，NULL 被定义为整形常量 0，而在 C 中，被定义为无类型指针常量 (void*) 0 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5381c3a942e44cc98adb407dcee0305e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-09T21:47:46+08:00" />
<meta property="article:modified_time" content="2023-03-09T21:47:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;实现的二叉树创建和遍历，超入门邻家小女也懂了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="480" src="https://images2.imgbox.com/c3/17/hkQ04er2_o.png" width="800"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0" rel="nofollow">二叉树 </a></p> 
<p id="%E7%89%B9%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E7%82%B9%EF%BC%9A" rel="nofollow">特点</a></p> 
<p id="%E6%80%A7%E8%B4%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%80%A7%E8%B4%A8%EF%BC%9A" rel="nofollow">性质</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">二叉树的创建</a></p> 
<p id="%E5%A3%B0%E6%98%8E%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%A3%B0%E6%98%8E%EF%BC%9A" rel="nofollow">声明</a></p> 
<p id="%E5%88%9B%E5%BB%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%EF%BC%9A" rel="nofollow">创建</a></p> 
<p id="-%3E%C2%A0%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#-%3E%C2%A0%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">成员运算符-&gt;</a></p> 
<p id="%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA" rel="nofollow">批量创建</a></p> 
<p id="%C2%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow"> 完全二叉树的创建</a></p> 
<p id="%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">打印二叉树</a></p> 
<p id="%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">普通二叉树的创建</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的遍历</a></p> 
<p id="%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">层序遍历</a></p> 
<p id="%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">先序遍历</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">中序遍历</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">后序遍历</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92%E6%B3%95" rel="nofollow">递归法</a></p> 
<p id="%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E5%AF%B9%E6%AF%94" rel="nofollow">前中后序对比</a></p> 
<p id="DFS%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#DFS%E9%81%8D%E5%8E%86" rel="nofollow">DFS遍历</a></p> 
<p id="%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%EF%BC%9A" rel="nofollow">树的相关术语</a></p> 
<p id="%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">特殊二叉树</a></p> 
<p id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A" rel="nofollow">满二叉树</a></p> 
<p id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A" rel="nofollow">完全二叉树</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0">二叉树 </h2> 
<p>树（Tree）是n(n≥0)个节点的有限集。在任意一棵树中有且仅有一个特定的称为根（Root）的节点；当n＞1时，其余节点可分m(m＞0)为个互不相交的有限集T1,T2,...,Tm；其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p> 
<p>二叉树（Binary Tree）是一种特殊的有序树型结构，所有节点最多只有2棵子树。</p> 
<h3 id="%E7%89%B9%E7%82%B9%EF%BC%9A">特点</h3> 
<p>（1）每个节点至多有两棵子树；<br> （2）二叉树的子树有左右之分；<br> （3）子树的次序不能任意颠倒（有序树）。</p> 
<h3 id="%E6%80%A7%E8%B4%A8%EF%BC%9A">性质</h3> 
<p>（1）二叉树的第i层上至多有2^(i-1)个节点（i≥1）。<br> （2）深度为h的二叉树中至多含有2^h-1个节点(h≥1)。<br> （3）若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1。<br> （4）具有n个节点的满二叉树深为log2n+1。<br> （5）若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），<br> 那么，对于编号为i（i≥1）的节点： <br> 　　当i=1时，该节点为根，它无双亲节点。<br> 　　当i&gt;1时，该节点的双亲节点的编号为i/2。<br> 　　若2i≤n，则有编号为2i的左节点，否则没有左节点。<br> 　　若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点。</p> 
<hr> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA">二叉树的创建</h2> 
<h3 id="%E5%A3%B0%E6%98%8E%EF%BC%9A">声明</h3> 
<pre><code class="language-cpp">struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};</code></pre> 
<p>在C/C++语言中，经常使用 NULL 来表示空指针。</p> 
<p>NULL在头文件里的定义：</p> 
<pre><code class="language-cpp">#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif</code></pre> 
<p>即在 C++中，NULL 被定义为整形常量 0，而在 C 中，被定义为无类型指针常量 <span style="color:#be191c;">(void*) 0</span> 。</p> 
<p><strong>C++11标准增加了新的关键字 nullptr，表示空指针。</strong></p> 
<p>建议使用C++11及以上版本的用以下的二叉树声明：</p> 
<pre><code class="language-cpp">struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};</code></pre> 
<h3 id="%E5%88%9B%E5%BB%BA%EF%BC%9A">创建</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int main() {
	
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;right-&gt;left = new TreeNode(4);
    root-&gt;right-&gt;right = new TreeNode(5);

    return 0;
}</code></pre> 
<p> 创建结果：</p> 
<p><img alt="" class="left" src="https://images2.imgbox.com/a9/03/PMrv8pYH_o.png"></p> 
<h3 id="-%3E%C2%A0%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符-&gt;</h3> 
<p>指向结构体或对象的指针访问其内成员。当一个指针指向一个结构体、对象时，称之为结构体指针或对象指针。结构体指针或对象指针中的值是所指向的结构体或对象的首地址。通过结构体指针或对象指针即可访问该结构体或对象。</p> 
<p>结构体指针变量定义的一般形式为：</p> 
<pre><code class="language-cpp">struct 结构体类型名 *指针名; //结构体指针
struct 结构体类型名 *指针名 = &amp;一个结构体的名字; //结构体指针并赋初值
struct 结构体类型名 *指针名 = new struct 结构体类型名; //结构体指针并用new申请内存
struct 结构体类型名 *指针名 =(struct 结构体类型名 *)malloc(sizeof(struct 结构体类型名)) 
//结构体指针并用malloc申请内存 使用应包含头文件stdlib.h</code></pre> 
<p>子树root-&gt;left, root-&gt;right 还可以<span style="color:#fe2c24;"><strong> . </strong></span>运算表示，也是成员运算符。两者的区别：</p> 
<p>点运算符 <span style="color:#fe2c24;"><strong>.</strong></span> 左边必须用<span style="color:#fe2c24;"><strong> * </strong></span>寻址运算符取到指针root指向的结构或者对象实体，如(*root)；对比箭头状的成员运算符 <span style="color:#fe2c24;"><strong>-&gt;</strong></span> ，其左边必须为结构体指针，如root。</p> 
<pre><code class="language-cpp">    TreeNode* root = new TreeNode(1);
    (*root).left = new TreeNode(2);
    (*root).right = new TreeNode(3);
    (*(*root).right).left = new TreeNode(4);
    (*(*root).right).right = new TreeNode(5);</code></pre> 
<h3 id="%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA">批量创建</h3> 
<p>上例只是创建5节点，如要建更多节点，这样一个一个增加节点写起来复杂；可以用数组或容器等可迭代数据类型批量来创建。</p> 
<h4 id="%C2%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"> 完全二叉树的创建</h4> 
<pre><code class="language-python">        _______1________
       /                \
    __2__             ___3___
   /     \           /       \
  4       5        _6        _7
 / \     / \      /  \      /  \
8   9   10  11   12   13   14   15</code></pre> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
	if (nums.empty()) return nullptr;
    TreeNode *root = new TreeNode(nums.front());
    vector&lt;TreeNode*&gt; q = {root};
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.assign(q.begin() + 1, q.end());
        if(i &lt; nums.size())
        {
            cur-&gt;left = new TreeNode(nums[i++]);
            q.push_back(cur-&gt;left);
        }
        if(i &lt; nums.size())
        {
            cur-&gt;right = new TreeNode(nums[i++]);
            q.push_back(cur-&gt;right);
        }
    }
    return root;
}

int main()
{
    vector&lt;int&gt; nums = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
    TreeNode *root = buildTree(nums);

    return 0;
}</code></pre> 
<p>创建后，可以用代码把二叉树打印出来以供验证： </p> 
<h4 id="%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">打印二叉树</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
	if (nums.empty()) return nullptr;
    TreeNode *root = new TreeNode(nums.front());
    vector&lt;TreeNode*&gt; q = {root};
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.assign(q.begin() + 1, q.end());
        if(i &lt; nums.size())
        {
            cur-&gt;left = new TreeNode(nums[i++]);
            q.push_back(cur-&gt;left);
        }
        if(i &lt; nums.size())
        {
            cur-&gt;right = new TreeNode(nums[i++]);
            q.push_back(cur-&gt;right);
        }
    }
    return root;
}

void levelOrderPrint(TreeNode* root)
{
    if(!root) return;
    vector&lt;TreeNode*&gt; q = {root};
    while(!q.empty())
    {
        int size = q.size();
        for(int i = 0; i &lt; size; i++)
        {
            TreeNode *cur = q.front();
            q.assign(q.begin() + 1, q.end());
            cout &lt;&lt; cur-&gt;val &lt;&lt; " ";
            if(cur-&gt;left)
                q.push_back(cur-&gt;left);
            if(cur-&gt;right)
                q.push_back(cur-&gt;right);
        }
        cout &lt;&lt; endl;
    }
}

int main()
{
    vector&lt;int&gt; nums;
    for (int i = 0; i &lt; 15; i++)
    	nums.push_back(i+1);   
    TreeNode *root = buildTree(nums);
    levelOrderPrint(root);

    return 0;
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>1<br> 2 3<br> 4 5 6 7<br> 8 9 10 11 12 13 14 15</p> 
<p>逐个打印二叉树节点的过程，称为遍历，稍后再讲。</p> 
<h4 id="%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA">普通二叉树的创建</h4> 
<p>如下这棵树比上面的树少了3个节点：</p> 
<pre><code class="language-python">        _______1________
       /                \
    __2__             ___3___
   /     \           /       \
  4       5        _6         7
 /       /        /  \         \
8       10      12   13        15</code></pre> 
<p>空结点一般用null描述，如：{1,2,3,4,5,6,7,8,null,10,11,null,13,null,15}。</p> 
<p>为了不改变数组的描述，用最小负整数来定义null： <span style="color:#1c7331;">#define null INT_MIN</span></p> 
<p><strong>代码：</strong></p> 
<p>增加对空节点的判断 if(i &lt; nums.size() &amp;&amp; <span style="color:#956fe7;">nums[i] != null</span>)</p> 
<pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define null INT_MIN
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty()) return nullptr;
	TreeNode *root = new TreeNode(nums.front());
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.pop();
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;left = new TreeNode(nums[i]);
            q.push(cur-&gt;left);
        }
        i++;
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;right = new TreeNode(nums[i]);
            q.push(cur-&gt;right);
        }
        i++;
    }
    return root;
}

void levelOrder(TreeNode* root)
{
    if(!root) return;
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    while(!q.empty())
    {
        int size = q.size();
        for(int i = 0; i &lt; size; i++)
        {
            TreeNode *cur = q.front();
            q.pop();
            cout &lt;&lt; cur-&gt;val &lt;&lt; " ";
            if(cur-&gt;left)
                q.push(cur-&gt;left);
            if(cur-&gt;right)
                q.push(cur-&gt;right);
        }
        cout &lt;&lt; endl;
    }
}

int main()
{
    vector&lt;int&gt; nums = {1,2,3,4,5,6,7,8,null,10,11,null,13,null,15};
    TreeNode *root = buildTree(nums);
    levelOrder(root);
    
    return 0;
}</code></pre> 
<p><strong>输出： </strong></p> 
<p>1<br> 2 3<br> 4 5 6 7<br> 8 10 11 13 15</p> 
<p>以上代码，直接用<strong>队列 queue</strong>来存放二叉树各节点的指针，queue有队列操作的专用内置方法pop和push，所以要比在前一例中用vector模拟的队列操作要稍微方便一点。</p> 
<p>注：二叉树的遍历，如</p> 
<p>用<strong>队列</strong>操作的一般是广度优先遍历 （BFS，Breath First Search）</p> 
<p>而用<strong>栈</strong>操作的一般是深度优先遍历 （DFS，Depth First Search）</p> 
<hr> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</h2> 
<p>指如何按某种搜索路径巡防树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。<br> 常见的遍历方法有：<strong>层序遍历，先序遍历，中序遍历，后序遍历</strong>。</p> 
<h3 id="%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</h3> 
<p>若二叉树为空，为空操作；否则从上到下、从左到右按层次进行访问。</p> 
<p>遍历结果： 1 [2 3] [4 5 6 7] [8 9 10 11 12 13 14 15]<br><img alt="" src="https://images2.imgbox.com/4e/56/fSkvuGtu_o.png"></p> 
<p>层序遍历的BFS代码在上面的<strong>打印二叉树</strong>章节已放出，这里放上我见过的一种用递归法写的二叉树层序遍历：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define null INT_MIN
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty()) return nullptr;
	TreeNode *root = new TreeNode(nums.front());
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.pop();
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;left = new TreeNode(nums[i]);
            q.push(cur-&gt;left);
        }
        i++;
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;right = new TreeNode(nums[i]);
            q.push(cur-&gt;right);
        }
        i++;
    }
    return root;
}

int countNodesAtLevel(TreeNode* root, int level)
{
    if(root == nullptr) return 0;
    if(level == 0) return 1;
    return countNodesAtLevel(root-&gt;left, level - 1) + countNodesAtLevel(root-&gt;right, level - 1);
}

TreeNode* getNodeAtLevel(TreeNode* root, int level, int index)
{
    if(root == nullptr) return nullptr;
    if(level == 0)
    {
        if(index == 0) return root;
        else return nullptr;
    }
    TreeNode *left = getNodeAtLevel(root-&gt;left, level - 1, index);
    if(left != nullptr) return left;
    return getNodeAtLevel(root-&gt;right, level - 1, index - countNodesAtLevel(root-&gt;left, level - 1));
}

void levelOrder(TreeNode* root)
{
    int level = 0;
    while(true)
    {
        int cnt = countNodesAtLevel(root, level);
        if(cnt == 0) break;
        for(int i = 0; i &lt; cnt; i++)
        {
            TreeNode *node = getNodeAtLevel(root, level, i);
            cout &lt;&lt; node-&gt;val &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
        level++;
    }
}

int main()
{
    vector&lt;int&gt; nums = {1,2,3,4,5,6,7,8,null,10,11,null,13,null,15};
    TreeNode *root = buildTree(nums);
    levelOrder(root);
    
    return 0;
}</code></pre> 
<h3>先序遍历</h3> 
<p>若二叉树为空，为空操作；<br> 否则（1）访问根节点；（2）先序遍历左子树；（3）先序遍历右子树。</p> 
<p>遍历结果： 1 [2 [4 8 9] [5 10 11]] [3 [6 12 13] [7 14 15]   “<strong>根左右</strong>”</p> 
<p><img alt="" src="https://images2.imgbox.com/51/40/axxYMOe2_o.png"></p> 
<h3 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</h3> 
<p>若二叉树为空，为空操作；<br> 否则（1）中序遍历左子树；（2）访问根结点；（3）中序遍历右子树。</p> 
<p>遍历结果： [[8 4 9] 2 [10 5 11]] 1 [[12 6 13] 3 [14 7 15]]  “<strong>左根右</strong>”</p> 
<p><img alt="" src="https://images2.imgbox.com/44/75/RxfMjARC_o.png"></p> 
<h3 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</h3> 
<p>若二叉树为空，为空操作；<br> 否则（1）后序遍历左子树；（2）后序遍历右子树；（3）访问根结点。</p> 
<p>遍历结果： [[8 9 4] [10 11 5] 2] [[12 13 6] [14 15 7] 3] 1  “<strong>左右根</strong>”</p> 
<p><img alt="" src="https://images2.imgbox.com/b4/45/gOjutyiL_o.png"></p> 
<h4 id="%E9%80%92%E5%BD%92%E6%B3%95">递归法</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define null INT_MIN
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty()) return nullptr;
	TreeNode *root = new TreeNode(nums.front());
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.pop();
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;left = new TreeNode(nums[i]);
            q.push(cur-&gt;left);
        }
        i++;
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;right = new TreeNode(nums[i]);
            q.push(cur-&gt;right);
        }
        i++;
    }
    return root;
}

void preOrderTraversal(TreeNode* root) {
    if (root == nullptr) {
	        return;
    }
    cout &lt;&lt; root-&gt;val &lt;&lt; " ";
    preOrderTraversal(root-&gt;left);
    preOrderTraversal(root-&gt;right);
}

void inOrderTraversal(TreeNode* root) {
    if (root == nullptr) {
	        return;
    }
    inOrderTraversal(root-&gt;left);
    cout &lt;&lt; root-&gt;val &lt;&lt; " ";
    inOrderTraversal(root-&gt;right);
}

void postOrderTraversal(TreeNode* root) {
    if (root == nullptr) {
	        return;
    }
    postOrderTraversal(root-&gt;left);
    postOrderTraversal(root-&gt;right);
    cout &lt;&lt; root-&gt;val &lt;&lt; " ";
}

int main()
{
    vector&lt;int&gt; nums;
    for (int i = 0; i &lt; 15; i++)
    	nums.push_back(i+1);
    TreeNode *root = buildTree(nums);
    preOrderTraversal(root);
    cout &lt;&lt; endl;
    inOrderTraversal(root);
    cout &lt;&lt; endl;
    postOrderTraversal(root);
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>1 2 4 8 9 5 10 11 3 6 12 13 7 14 15<br> 8 4 9 2 10 5 11 1 12 6 13 3 14 7 15<br> 8 9 4 10 11 5 2 12 13 6 14 15 7 3 1</p> 
<h4 id="%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E5%AF%B9%E6%AF%94">前中后序对比</h4> 
<p>遍历时核心代码的顺序是关键，就是上面讲过的用“<strong>根左右</strong>”“<strong>左根右</strong>”“<strong>左右根</strong>”记忆，看根节点的左右子树节点的位置比较：</p> 
<blockquote> 
 <p><strong>根左右——前序</strong><br>     cout &lt;&lt; root-&gt;val &lt;&lt; " ";<br>     preOrderTraversal(root-&gt;left);<br>     preOrderTraversal(root-&gt;right);</p> 
 <p><strong>左根右——中序</strong><br>     inOrderTraversal(root-&gt;left);<br>     cout &lt;&lt; root-&gt;val &lt;&lt; " ";<br>     inOrderTraversal(root-&gt;right);</p> 
 <p><strong>左右根——后序</strong><br>     postOrderTraversal(root-&gt;left);<br>     postOrderTraversal(root-&gt;right);<br>     cout &lt;&lt; root-&gt;val &lt;&lt; " ";</p> 
</blockquote> 
<p>遍历除了直接打印节点外，还可以把各节点值域存入数组，以中序为例：</p> 
<pre><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    inorderTraversal(root, res);
    return res;
}
void inorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; res) {
    if (root == nullptr) {
        return;
    }
    inorderTraversal(root-&gt;left, res);
    res.push_back(root-&gt;val);
    inorderTraversal(root-&gt;right, res);
}</code></pre> 
<hr> 
<h4 id="DFS%E9%81%8D%E5%8E%86">DFS遍历</h4> 
<p>DFS会用到&lt;stack&gt;，直接打印版：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#define null INT_MIN
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty()) return nullptr;
	TreeNode *root = new TreeNode(nums.front());
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int i = 1;
    while(!q.empty() &amp;&amp; i &lt; nums.size())
    {
        TreeNode *cur = q.front();
        q.pop();
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;left = new TreeNode(nums[i]);
            q.push(cur-&gt;left);
        }
        i++;
        if(i &lt; nums.size() &amp;&amp; nums[i] != null)
        {
            cur-&gt;right = new TreeNode(nums[i]);
            q.push(cur-&gt;right);
        }
        i++;
    }
    return root;
}

void preOrderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    TreeNode* node = root;
    while (node != nullptr || !st.empty()) {
        while (node != nullptr) {
            cout &lt;&lt; node-&gt;val &lt;&lt; " ";
            st.push(node);
            node = node-&gt;left;
        }
        node = st.top();
        st.pop();
        node = node-&gt;right;
    }
}

void inOrderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    TreeNode* node = root;
    while (node != nullptr || !st.empty()) {
        while (node != nullptr) {
            st.push(node);
            node = node-&gt;left;
        }
        node = st.top();
        st.pop();
        cout &lt;&lt; node-&gt;val &lt;&lt; " ";
        node = node-&gt;right;
    }
}

void postOrderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    TreeNode* node = root;
    TreeNode* last = nullptr; // 上一次访问的节点
    while (node != nullptr || !st.empty()) {
        while (node != nullptr) {
            st.push(node);
            node = node-&gt;left;
        }
        node = st.top();
        if (node-&gt;right == nullptr || node-&gt;right == last) { 
			// 右子树为空或已经访问过
            cout &lt;&lt; node-&gt;val &lt;&lt; " ";
            st.pop();
            last = node; // 更新上一次访问的节点
            node = nullptr; // 继续弹出栈顶元素
        } else { // 右子树还未访问
            node = node-&gt;right;
        }
    }
}

int main()
{
    vector&lt;int&gt; nums;
    for (int i = 0; i &lt; 15; i++)
    	nums.push_back(i+1);
    TreeNode *root = buildTree(nums);
    preOrderTraversal(root);
    cout &lt;&lt; endl;
    inOrderTraversal(root);
    cout &lt;&lt; endl;
    postOrderTraversal(root);
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre> 
<p>二叉树转数组，分别用DFS,BFS实现：</p> 
<pre><code class="language-cpp">vector&lt;int&gt; DFSinorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    stack&lt;TreeNode*&gt; st;
    while (root != nullptr || !st.empty()) {
        while (root != nullptr) {
            st.push(root);
            root = root-&gt;left;
        }
        root = st.top();
        st.pop();
        res.push_back(root-&gt;val);
        root = root-&gt;right;
    }
    return res;
}

vector&lt;int&gt; BFSinorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    queue&lt;TreeNode*&gt; q;
    if (root != nullptr) {
        q.push(root);
    }
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        if (node-&gt;left != nullptr) {
            q.push(node-&gt;left);
        }
        res.push_back(node-&gt;val);
        if (node-&gt;right != nullptr) {
            q.push(node-&gt;right);
        }
    }
    return res;
}</code></pre> 
<hr> 
<h2 id="%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%EF%BC%9A"><strong>树的相关术语</strong></h2> 
<p><strong>节点</strong>：包含一个数据元素及若干指向其子树的分支，又的译成“<strong>结点</strong>”（Node）<br><strong>根</strong>：树和子树的“顶点”（Root）<br><strong>度</strong>：节点拥有的子树数量称为<strong>节点的度</strong>（Degree）；<strong>树的度</strong>是指树内个结点的度的最大值<br><strong>分支节点</strong>：度不为0的节点<br><strong>叶子</strong>：没有子树的节点，即它的度为0 （Leaf）<br><strong>子节点</strong>：结点的子树的根称为该节点的<strong>孩子</strong>（Child）<br><strong>父节点</strong>：对应子节点上一层(level)节点称为该节点的<strong>双亲</strong>（Parent）<br><strong>兄弟结点</strong>：同一父节点的子节点，互称<strong>兄弟</strong>（Sibling）<br> 节点的<strong>祖先</strong>：是从根到该结点所经分支上的所有节点<br> 节点的<strong>子孙</strong>：以某结点为根的子树中的所有节点<br><strong>层</strong>：从根开始，根为第一层，根的孩子为第二层...（Level）<br><strong>深度</strong>：树中结点的最大层次数，称为树的深度或高度 （Depth or Height）<br><strong>森林</strong>：是很多互不相交的树的集合（Forest）</p> 
<p><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树<br><strong>有序树</strong>：树中任意节点的子节点之间有顺序关系，这种树称为有序树<br><strong>最大树（最小树）</strong>：每个结点的值都大于（小于）或等于其子结点（如果有的话）值的树</p> 
<hr> 
<h2 id="%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91">特殊二叉树</h2> 
<h3 id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A">满二叉树</h3> 
<p>所有层的节点都达到最大数量，叶子除外的所有节点都有两个子节点，所有叶子都在最底一层(k)且数目为2^(k - 1)。即深度k且有2^k - 1个节点(叶子“长”满最后一层)，或称完美二叉树 （Perfect Binary Tree）</p> 
<pre><code>         ______12_______
        /               \
     __3__             __5__
    /     \           /     \
  _7       6        _9       11
 /  \     / \      /  \     /  \
13   8   1   4    10   2   0    14</code></pre> 
<h3 id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A">完全二叉树</h3> 
<p>如果删除最底一层的所有叶子它就是满二叉树，即除了最后一层，每层节点都达到最大数量 ，即有深度k的个节点数在左闭右开【2^(k-1)+1,2^k-1】区间内。（Complete Binary Tree）</p> 
<pre><code>         ________3______
        /               \
    ___11___           __4__
   /        \         /     \
  14         7       9       13
 /  \      /  \     /   
2    5    8    6   1 
</code></pre> 
<p><strong>完全二叉树性质：</strong></p> 
<p>1. 具有N个节点的完全二叉树的深度为[log2 N]+1，其中[x]为高斯函数，截尾取整。<br> 2. 如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层到最后一层，每层从左到右），则对任一节点，有：<br> （1）如果i=1，则节点i是二叉树的根，无双亲；如果i&gt;1,则其双亲节点为[i/2]；<br> （2）如果2i&gt;n，则节点i无左孩子；否则其左孩子是节点2i；<br> （3）如果2i+1&gt;n，则节点i无右孩子；否则其右孩子是节点2i+1。</p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f830d7af268f36e00015edce926b7f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多进制调制系统MPSK性能仿真</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/759c3ab209056b1a8c34b707f2511463/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CompletableFuture中的CompletionException异常真是坑到我了！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>