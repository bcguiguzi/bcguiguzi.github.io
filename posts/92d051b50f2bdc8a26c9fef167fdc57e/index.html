<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bitmap的分析与使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bitmap的分析与使用" />
<meta property="og:description" content="Bitmap的分析与使用 Bitmap的创建
创建Bitmap的时候，Java不提供new Bitmap()的形式去创建，而是通过BitmapFactory中的静态方法去创建,如:BitmapFactory.decodeStream(is);//通过InputStream去解析生成Bitmap(这里就不贴BitmapFactory中创建Bitmap的方法了，大家可以自己去看它的源码)，我们跟进BitmapFactory中创建Bitmap的源码，最终都可以追溯到这几个native函数 private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts); private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd, Rect padding, Options opts); private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts); private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts); 而Bitmap又是Java对象，这个Java对象又是从native，也就是C/C&#43;&#43;中产生的，所以，在Android中Bitmap的内存管理涉及到两部分，一部分是native，另一部分是dalvik，也就是我们常说的java堆(如果对java堆与栈不了解的同学可以戳)，到这里基本就已经了解了创建Bitmap的一些内存中的特性(大家可以使用adb shell dumpsys meminfo去查看Bitmap实例化之后的内存使用情况)。
Bitmap的使用
我们已经知道了BitmapFactory是如何通过各种资源创建Bitmap了，那么我们如何合理的使用它呢？以下是几个我们使用Bitmap需要关注的点 Size
这里我们来算一下，在Android中，如果采用Config.ARGB_8888的参数去创建一个Bitmap，这是Google推荐的配置色彩参数，也是Android4.4及以上版本默认创建Bitmap的Config参数(Bitmap.Config.inPreferredConfig的默认值)，那么每一个像素将会占用4byte，如果一张手机照片的尺寸为1280×720，那么我们可以很容易的计算出这张图片占用的内存大小为 1280x720x4 = 3686400(byte) = 3.5M，一张未经处理的照片就已经3.5M了! 显而易见，在开发当中，这是我们最需要关注的问题，否则分分钟OOM!那么，我们一般是如何处理Size这个重要的因素的呢？，当然是调整Bitmap的大小到适合的程度啦！辛亏在BitmapFactory中，我们可以很方便的通过BitmapFactory.Options中的options.inSampleSize去设置Bitmap的压缩比，官方给出的说法是 If set to a value &gt; 1, requests the decoder to subsample the original image, returning a smaller image to save memory…For example, inSampleSize == 4 returns" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/92d051b50f2bdc8a26c9fef167fdc57e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-17T14:21:11+08:00" />
<meta property="article:modified_time" content="2023-06-17T14:21:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bitmap的分析与使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Bitmap_0"></a><strong>Bitmap</strong>的分析与使用</h3> 
<ul><li> <p>Bitmap的创建</p> 
  <ul><li>创建Bitmap的时候，Java不提供<code>new Bitmap()</code>的形式去创建，而是通过<code>BitmapFactory</code>中的静态方法去创建,如:<code>BitmapFactory.decodeStream(is);//通过InputStream去解析生成Bitmap</code>(这里就不贴<code>BitmapFactory</code>中创建<code>Bitmap</code>的方法了，大家可以自己去看它的源码)，我们跟进<code>BitmapFactory</code>中创建<code>Bitmap</code>的源码，最终都可以追溯到这几个native函数</li></ul> <pre><code>    private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage,
                Rect padding, Options opts);
    private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd,
            Rect padding, Options opts);
    private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts);
    private static native Bitmap nativeDecodeByteArray(byte[] data, int offset,
            int length, Options opts);
</code></pre> <p>而<code>Bitmap</code>又是Java对象，这个Java对象又是从native，也就是C/C++中产生的，所以，在Android中Bitmap的内存管理涉及到两部分，一部分是<em>native</em>，另一部分是<em>dalvik</em>，也就是我们常说的java堆(如果对java堆与栈不了解的同学可以戳)，到这里基本就已经了解了创建Bitmap的一些内存中的特性(大家可以使用<code>adb shell dumpsys meminfo</code>去查看Bitmap实例化之后的内存使用情况)。</p> </li><li> <p>Bitmap的使用</p> 
  <ul><li>我们已经知道了<code>BitmapFactory</code>是如何通过各种资源创建<code>Bitmap</code>了，那么我们如何合理的使用它呢？以下是几个我们使用<code>Bitmap</code>需要关注的点 
    <ol><li> <p><strong>Size</strong></p> 
      <ul><li>这里我们来算一下，在Android中，如果采用<code>Config.ARGB_8888</code>的参数去创建一个<code>Bitmap</code>，<a href="https://developer.android.com/reference/android/graphics/Bitmap.Config.html" rel="nofollow">这是Google推荐的配置色彩参数</a>，也是Android4.4及以上版本默认创建Bitmap的Config参数(<code>Bitmap.Config.inPreferredConfig</code>的默认值)，那么每一个像素将会占用4byte，如果一张手机照片的尺寸为1280×720，那么我们可以很容易的计算出这张图片占用的内存大小为 1280x720x4 = 3686400(byte) = 3.5M，一张未经处理的照片就已经3.5M了! 显而易见，在开发当中，这是我们最需要关注的问题，否则分分钟OOM!</li><li><em>那么，我们一般是如何处理Size这个重要的因素的呢？</em>，当然是调整<code>Bitmap</code>的大小到适合的程度啦！辛亏在<code>BitmapFactory</code>中，我们可以很方便的通过<code>BitmapFactory.Options</code>中的<code>options.inSampleSize</code>去设置<code>Bitmap</code>的压缩比，官方给出的说法是</li></ul> 
      <blockquote> 
       <p>If set to a value &gt; 1, requests the decoder to subsample the original image, returning a smaller image to save memory…For example, inSampleSize == 4 returns<br> an image that is 1/4 the width/height of the original, and 1/16 the<br> number of pixels. Any value &lt;= 1 is treated the same as 1.</p> 
      </blockquote> <p>很简洁明了啊！也就是说，只要按计算方法设置了这个参数，就可以完成我们Bitmap的Size调整了。那么，应该怎么调整姿势才比较舒服呢？下面先介绍其中一种通过<code>InputStream</code>的方式去创建<code>Bitmap</code>的方法，上一段从Gallery中获取照片并且将图片Size调整到合适手机尺寸的代码：</p> </li></ol> <pre><code>    static final int PICK_PICS = 9;
    
    public void startGallery(){
        Intent i = new Intent();
        i.setAction(Intent.ACTION_PICK);
        i.setType("image/*");
        startActivityForResult(i,PICK_PICS);
    }
    
     private int[] getScreenWithAndHeight(){
        WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics dm = new DisplayMetrics();
        wm.getDefaultDisplay().getMetrics(dm);
        return new int[]{dm.widthPixels,dm.heightPixels};
    }
    
    /**
     *
     * @param actualWidth 图片实际的宽度，也就是options.outWidth
     * @param actualHeight 图片实际的高度，也就是options.outHeight
     * @param desiredWidth 你希望图片压缩成为的目的宽度
     * @param desiredHeight 你希望图片压缩成为的目的高度
     * @return
     */
    private int findBestSampleSize(int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
        double wr = (double) actualWidth / desiredWidth;
        double hr = (double) actualHeight / desiredHeight;
        double ratio = Math.min(wr, hr);
        float n = 1.0f;
        //这里我们为什么要寻找 与ratio最接近的2的倍数呢？
        //原因就在于API中对于inSimpleSize的注释：最终的inSimpleSize应该为2的倍数，我们应该向上取与压缩比最接近的2的倍数。
        while ((n * 2) &lt;= ratio) {
            n *= 2;
        }

        return (int) n;
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if(resultCode == RESULT_OK){
            switch (requestCode){
                case PICK_PICS:
                    Uri uri = data.getData();
                    InputStream is = null;
                    try {
                        is = getContentResolver().openInputStream(uri);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    }

                    BitmapFactory.Options options = new BitmapFactory.Options();
                    //当这个参数为true的时候,意味着你可以在解析时候不申请内存的情况下去获取Bitmap的宽和高
                    //这是调整Bitmap Size一个很重要的参数设置
                    options.inJustDecodeBounds = true;
                    BitmapFactory.decodeStream( is,null,options );

                    int realHeight = options.outHeight;
                    int realWidth = options.outWidth;

                    int screenWidth = getScreenWithAndHeight()[0];
                    
                    int simpleSize = findBestSampleSize(realWidth,realHeight,screenWidth,300);
                    options.inSampleSize = simpleSize;
                    //当你希望得到Bitmap实例的时候，不要忘了将这个参数设置为false
                    options.inJustDecodeBounds = false;

                    try {
                        is = getContentResolver().openInputStream(uri);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    }

                    Bitmap bitmap = BitmapFactory.decodeStream(is,null,options);

                    iv.setImageBitmap(bitmap);

                    try {
                        is.close();
                        is = null;
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                    break;
            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }
</code></pre> </li></ul> <p>我们来看看这段代码的功效：<br> 压缩前：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-71RdDTMP-1686982219413)(null)]<br> 压缩后：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UMmm4QUO-1686982219094)(null)]<br> <strong>对比条件为：1080P的魅族Note3拍摄的高清无码照片</strong></p> <pre><code> 2.  Reuse
 上面介绍了BitmapFactory通过InputStream去创建Bitmap的这种方式，以及BitmapFactory.Options.inSimpleSize 和 BitmapFactory.Options.inJustDecodeBounds的使用方法，但将单个Bitmap加载到UI是简单的，但是如果我们需要一次性加载大量的图片，事情就会变得复杂起来。Bitmap是吃内存大户，我们不希望多次解析相同的Bitmap，也不希望可能不会用到的Bitmap一直存在于内存中，所以，这个场景下，Bitmap的重用变得异常的重要。
 在这里只介绍一种BitmapFactory.Options.inBitmap的重用方式，下一篇文章会介绍使用三级缓存来实现Bitmap的重用。
 
       根据官方文档[在Android 3.0 引进了BitmapFactory.Options.inBitmap](https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap)，如果这个值被设置了，decode方法会在加载内容的时候去重用已经存在的bitmap. 这意味着bitmap的内存是被重新利用的，这样可以提升性能, 并且减少了内存的分配与回收。然而，使用inBitmap有一些限制。特别是在Android 4.4 之前，只支持同等大小的位图。
     我们看来看看这个参数最基本的运用方法。
</code></pre> </li></ul> 
<pre><code>          new BitmapFactory.Options options = new BitmapFactory.Options();
          //inBitmap只有当inMutable为true的时候是可用的。
          options.inMutable = true;
          Bitmap reusedBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.reused_btimap,options);
          options.inBitmap = reusedBitmap;
 
          
            这样，当你在下一次decodeBitmap的时候，将设置了`options.inMutable=true`以及`options.inBitmap`的`Options`传入，Android就会复用你的Bitmap了，具体实例：
          
  
          @Override
          protected void onCreate(@Nullable Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(reuseBitmap());
          }
  
          private LinearLayout reuseBitmap(){
              LinearLayout linearLayout = new LinearLayout(this);
              linearLayout.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
              linearLayout.setOrientation(LinearLayout.VERTICAL);
      
              ImageView iv = new ImageView(this);
              iv.setLayoutParams(new ViewGroup.LayoutParams(500,300));
      
              options = new BitmapFactory.Options();
              options.inJustDecodeBounds = true;
              //inBitmap只有当inMutable为true的时候是可用的。
              options.inMutable = true;
              BitmapFactory.decodeResource(getResources(),R.drawable.big_pic,options);
              
              //压缩Bitmap到我们希望的尺寸
              //确保不会OOM
              options.inSampleSize = findBestSampleSize(options.outWidth,options.outHeight,500,300);
              options.inJustDecodeBounds = false;
      
              Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.big_pic,options);
              options.inBitmap = bitmap;
      
              iv.setImageBitmap(bitmap);
      
              linearLayout.addView(iv);
      
              ImageView iv1 = new ImageView(this);
              iv1.setLayoutParams(new ViewGroup.LayoutParams(500,300));
              iv1.setImageBitmap( BitmapFactory.decodeResource(getResources(),R.drawable.big_pic,options));
              linearLayout.addView(iv1);
      
              ImageView iv2 = new ImageView(this);
              iv2.setLayoutParams(new ViewGroup.LayoutParams(500,300));
              iv2.setImageBitmap( BitmapFactory.decodeResource(getResources(),R.drawable.big_pic,options));
              linearLayout.addView(iv2);
      
      
              return linearLayout;
          }
</code></pre> 
<pre><code>         以上代码中，我们在解析了一次一张1080P分辨率的图片，并且设置在`options.inBitmap`中，然后分别decode了同一张图片，并且传入了相同的`options`。最终只占用一份第一次解析`Bitmap`的内存。
        
    3. Recycle
    一定要记得及时回收Bitmap，否则如上分析，你的native以及dalvik的内存都会被一直占用着，最终导致OOM
    
    
    
    // 先判断是否已经回收
    if(bitmap != null &amp;&amp; !bitmap.isRecycled()){
        // 回收并且置为null
        bitmap.recycle();
        bitmap = null;
    }
    System.gc();
   
    
- Enjoy Android  :) 如果有误，轻喷，欢迎指正。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ca22d7fbbb4fda0df1742014186f4aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[常见问题] - 解决地图KEY无效的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e42c54583dd0f447f9d37bd78e4ad07c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis Desktop Manager中出现\xAC\xED\x00\x05t\x00乱码问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>