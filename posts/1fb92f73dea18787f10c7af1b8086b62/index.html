<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dart的语法详解系列篇（1）---- 老司机用一篇博客带你快速熟悉Dart语法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dart的语法详解系列篇（1）---- 老司机用一篇博客带你快速熟悉Dart语法" />
<meta property="og:description" content="声明：本文是作者AWeiLoveAndroid原创，版权归作者AWeiLoveAndroid所有，侵权必究。如若转发，请注明作者和来源地址！未经授权，严禁私自转载！
________________________________________________________________________________________________
【前言】Dart语言是使用flutter框架开发时候必备的语言，flutter是一个跨平台的框架，一套代码就可以完美实现安卓和ios两个平台，适配也很不错，Dart语言很友好，和java很类似，学习成本也是很低的。所以这也是我推荐学习Dart语言的一个原因。
从本篇文章开始讲解Dart语言的基本使用，我将会连续推出好几篇文章详解，希望帮助大家快速掌握Dart语言。
本文目录：
一、注释
二、关键字（56个）
三、变量和常量
四、特殊数据类型
五、运算符
六、控制流程语句
七、异常
本文代码同步发布在Github:
https://github.com/AweiLoveAndroid/Flutter-learning/tree/master/projects/dart_demo
怎么运行代码？
如果你使用IDEA或者Android Studio：
打开IDEA或者Android Studio，新建一个Flutter项目，然后在test目录运行我的代码；或者里面去写你自己的dart文件，然后右键run就可以运行了。（注意：需要连接手机或者模拟器）。
如果你使用vscode：
打开vscode，执行菜单栏运行，就可以了（确保只有一个dart文件，免得运行的文件不是你想要的，就很尴尬了，vscode也可以设置默认运行的文件是哪个，但是新手不建议去设置，很麻烦。因为你们想最快的运行效果，所有建议只有一个dart文件是最好的）。
一、注释 Dart的注释分为3种：单行注释、多行注释、文档注释。
1、单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。
例如：// todo:待完成
2、多行注释以/*开头，以*/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释）。多行注释可以嵌套。
例如：/* todo:待完成 */
3、文档注释以///或者/**开头。可以通过dartdoc命令导出文档。
文档注释的使用，例如：/// todo:待完成
文档的导出如图所示：
文档的导出 导出的结果在我的工程根路径的/doc/api/文件夹里面，如图所示：
导出的结果 然后浏览器打开index.html就可以看到文档了。如图所示：
本地的文档 二、关键字（60个） 5个上下文关键字（仅在特定位置具有含义。它们在任何地方都是有效的标识符） 关键字---asynchideonshowsync--- 其中内置标志符有：（20个） 关键字---abstractascovariantdefereddynamicexportexternalfactoryFunctiongetimplementsimportinterfacelibrarymixinoperatorpartsetstatictypedef Dart新增的，有限的保留字,支持异步功能的关键字有：（2个） 关键字---awaityield 33个保留字（不能使用保留字作为标识符） 关键字---assertbreakcasecatchclassconstcontinuedefaultdoelseenumextendsfalsefinalfinallyforifinisnewnullrethrowreturnsuperswitchthisthrowtruetryvarvoidwhilewith--- 跟java相比，Dart特有的关键字有：（27个） 关键字---asasyncawaitcovariantdeferreddynamicexportexternalfactoryFunctiongethideinislibrarymixinonoperatorpartrethrowsetshowsynctypedefvarwithyield 三、变量和常量 （一）变量的声明，可以使用 var、Object 或 dynamic 关键字。 创建变量并初始化变量实例：
var name = &#39;张三&#39; ; 变量存储引用。
使用Object或dynamic关键字 dynamic name = &#39;张三&#39;; 调用的变量name包含对String值为“张三” 的对象的引用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1fb92f73dea18787f10c7af1b8086b62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-16T21:04:55+08:00" />
<meta property="article:modified_time" content="2018-05-16T21:04:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dart的语法详解系列篇（1）---- 老司机用一篇博客带你快速熟悉Dart语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>声明：本文是作者AWeiLoveAndroid原创，版权归作者AWeiLoveAndroid所有，侵权必究。如若转发，请注明作者和来源地址！未经授权，严禁私自转载！</strong></p> 
<p>________________________________________________________________________________________________</p> 
<p>【前言】Dart语言是使用flutter框架开发时候必备的语言，flutter是一个跨平台的框架，一套代码就可以完美实现安卓和ios两个平台，适配也很不错，Dart语言很友好，和java很类似，学习成本也是很低的。所以这也是我推荐学习Dart语言的一个原因。</p> 
<blockquote> 
 <p>从本篇文章开始讲解Dart语言的基本使用，我将会连续推出好几篇文章详解，希望帮助大家快速掌握Dart语言。</p> 
</blockquote> 
<hr> 
<p>本文目录：</p> 
<blockquote> 
 <p>一、注释<br> 二、关键字（56个）<br> 三、变量和常量<br> 四、特殊数据类型<br> 五、运算符<br> 六、控制流程语句<br> 七、异常</p> 
</blockquote> 
<hr> 
<p><strong>本文代码同步发布在Github:<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FAweiLoveAndroid%2FFlutter-learning%2Ftree%2Fmaster%2Fprojects%2Fdart_demo" rel="nofollow">https://github.com/AweiLoveAndroid/Flutter-learning/tree/master/projects/dart_demo</a></strong></p> 
<blockquote> 
 <p>怎么运行代码？</p> 
</blockquote> 
<p>如果你使用IDEA或者Android Studio：</p> 
<blockquote> 
 <p>打开IDEA或者Android Studio，新建一个Flutter项目，然后在test目录运行我的代码；或者里面去写你自己的<code>dart</code>文件，然后右键<code>run</code>就可以运行了。（<strong>注意：需要连接手机或者模拟器</strong>）。</p> 
</blockquote> 
<p>如果你使用vscode：</p> 
<blockquote> 
 <p>打开vscode，执行菜单栏<code>运行</code>，就可以了（确保只有一个dart文件，免得运行的文件不是你想要的，就很尴尬了，vscode也可以设置默认运行的文件是哪个，但是新手不建议去设置，很麻烦。因为你们想最快的运行效果，所有建议只有一个dart文件是最好的）。</p> 
</blockquote> 
<hr> 
<h2>一、注释</h2> 
<p>Dart的注释分为3种：单行注释、多行注释、文档注释。</p> 
<blockquote> 
 <p>1、单行注释以<code>//</code>开头。Dart编译器会忽略//和行尾之间的所有内容。</p> 
</blockquote> 
<p>例如：<code>// todo:待完成</code></p> 
<blockquote> 
 <p>2、多行注释以<code>/*</code>开头，以<code>*/</code>结尾。介于<code>/*</code>和 <code>*/</code>两者之间的内容会被编译器忽略（除非该注释是一个文档注释）。多行注释可以嵌套。</p> 
</blockquote> 
<p>例如：<code>/* todo:待完成 */</code></p> 
<blockquote> 
 <p>3、文档注释以<code>///</code>或者<code>/**</code>开头。可以通过<code>dartdoc</code>命令导出文档。</p> 
</blockquote> 
<p>文档注释的使用，例如：<code>/// todo:待完成</code></p> 
<p>文档的导出如图所示：</p> 
<p> </p> 
<div> 
 <div> 
  <div>
      
  </div> 
  <div> 
   <img alt="6098829-f958d7a9c526a705.png" class="has" src="https://images2.imgbox.com/6a/70/yMtQcyxc_o.png"> 
  </div> 
 </div> 
 <div>
   文档的导出 
 </div> 
</div> 
<p> </p> 
<p>导出的结果在我的<code>工程根路径的/doc/api/</code>文件夹里面，如图所示：</p> 
<div> 
 <div> 
  <div>
      
  </div> 
  <div> 
   <img alt="6098829-808c461eb43c34ad.png" class="has" src="https://images2.imgbox.com/3d/b5/Ajx1rJRd_o.png"> 
  </div> 
 </div> 
 <div>
   导出的结果 
 </div> 
</div> 
<p>然后浏览器打开<code>index.html</code>就可以看到文档了。如图所示：</p> 
<div> 
 <div> 
  <div>
      
  </div> 
  <div> 
   <img alt="6098829-f92d372334dd31ce.png" class="has" src="https://images2.imgbox.com/1b/79/GXkS2tBJ_o.png"> 
  </div> 
 </div> 
 <div>
   本地的文档 
 </div> 
</div> 
<hr> 
<h2>二、关键字（60个）</h2> 
<h4>5个上下文关键字（仅在特定位置具有含义。它们在任何地方都是有效的标识符）</h4> 
<table><thead><tr><th>关键字</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>async</td><td>hide</td><td>on</td><td>show</td></tr><tr><td>sync</td><td>-</td><td>-</td><td>-</td></tr></tbody></table> 
<h4>其中内置标志符有：（20个）</h4> 
<table><thead><tr><th>关键字</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>abstract</td><td>as</td><td>covariant</td><td>defered</td></tr><tr><td>dynamic</td><td>export</td><td>external</td><td>factory</td></tr><tr><td>Function</td><td>get</td><td>implements</td><td>import</td></tr><tr><td>interface</td><td>library</td><td>mixin</td><td>operator</td></tr><tr><td>part</td><td>set</td><td>static</td><td>typedef</td></tr></tbody></table> 
<h4>Dart新增的，有限的保留字,支持异步功能的关键字有：（2个）</h4> 
<table><thead><tr><th>关键字</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>await</td><td>yield</td><td> </td><td> </td></tr></tbody></table> 
<h4>33个保留字（不能使用保留字作为标识符）</h4> 
<table><thead><tr><th>关键字</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>assert</td><td>break</td><td>case</td><td>catch</td></tr><tr><td>class</td><td>const</td><td>continue</td><td>default</td></tr><tr><td>do</td><td>else</td><td>enum</td><td>extends</td></tr><tr><td>false</td><td>final</td><td>finally</td><td>for</td></tr><tr><td>if</td><td>in</td><td>is</td><td>new</td></tr><tr><td>null</td><td>rethrow</td><td>return</td><td>super</td></tr><tr><td>switch</td><td>this</td><td>throw</td><td>true</td></tr><tr><td>try</td><td>var</td><td>void</td><td>while</td></tr><tr><td>with</td><td>-</td><td>-</td><td>-</td></tr></tbody></table> 
<h4>跟java相比，Dart特有的关键字有：（27个）</h4> 
<table><thead><tr><th>关键字</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>as</td><td>async</td><td>await</td><td>covariant</td></tr><tr><td>deferred</td><td>dynamic</td><td>export</td><td>external</td></tr><tr><td>factory</td><td>Function</td><td>get</td><td>hide</td></tr><tr><td>in</td><td>is</td><td>library</td><td>mixin</td></tr><tr><td>on</td><td>operator</td><td>part</td><td>rethrow</td></tr><tr><td>set</td><td>show</td><td>sync</td><td>typedef</td></tr><tr><td>var</td><td>with</td><td>yield</td><td> </td></tr></tbody></table> 
<hr> 
<h2>三、变量和常量</h2> 
<h4>（一）变量的声明，可以使用 var、Object 或 dynamic 关键字。</h4> 
<p>创建变量并初始化变量实例：</p> 
<pre class="has"><code>var name = '张三' ;
</code></pre> 
<p>变量存储引用。</p> 
<ul><li> 
  <ol><li>使用Object或dynamic关键字</li></ol></li></ul> 
<pre class="has"><code>dynamic name = '张三';
</code></pre> 
<p>调用的变量name包含对String值为“张三” 的对象的引用。<br> name推断变量的类型是String，但可以通过指定它来更改该类型。<br> 如果对象不限于单一类型（没有明确的类型），请使用Object或dynamic关键字</p> 
<pre class="has"><code>Object name = '张三';
dynamic name = '李四';
</code></pre> 
<ul><li> 
  <ol><li>显式声明将被推断的类型</li></ol></li></ul> 
<p>比如String,int等。</p> 
<pre class="has"><code>//可以使用String显示声明字符串类型
String name = '张三' ; //代替var name = '张三';
</code></pre> 
<p>这个类型有很多，具体在下文有介绍。</p> 
<h4>（二）默认值</h4> 
<p>未初始化的变量的初始值为null（包括数字），因此数字、字符串都可以调用各种方法。</p> 
<pre class="has"><code>//测试 数字类型的初始值是什么?
int intDefaultValue;
// assert 是语言内置的断言函数，仅在检查模式下有效
// 在开发过程中， 除非条件为真，否则会引发异常。(断言失败则程序立刻终止)
assert(intDefaultValue == null);
print(intDefaultValue);//打印结果为null，证明数字类型初始化值是null
</code></pre> 
<h4>（三）Final 和 Const的用法</h4> 
<p>如果您从未打算更改一个变量，那么使用 final 或 const，不是var，也不是一个类型。<br> 一个 final 变量只能被设置一次;const 变量是一个编译时常量。(Const变量是隐式的final。)<br> final的顶级或类变量在第一次使用时被初始化。</p> 
<ul><li>1、被final或者const修饰的变量，变量类型可以省略。</li></ul> 
<pre class="has"><code>//可以省略String这个类型声明
final name1 = "张三";
//final String name1  = "张三";
    
const name2 = "李四";
//const String name2 = "李四";
</code></pre> 
<ul><li>2、被 final 或 const 修饰的变量无法再去修改其值。</li></ul> 
<pre class="has"><code>final name1 = "张三";
// 这样写，编译器提示：a final variable, can only be set once
// 一个final变量，只能被设置一次。
//name1 = "zhangsan";
    
const name2 = "李四";

// 这样写，编译器提示：Constant variables can't be assigned a value
// const常量不能赋值
// name2 = "lisi";
</code></pre> 
<ul><li>3、注意：flnal 或者 const 不能和 var 同时使用</li></ul> 
<pre class="has"><code>//这样写都会报错
//final var name1 = "张三";
//const var name2 = "李四";
</code></pre> 
<ul><li>4、常量如果是类级别的，请使用 static const</li></ul> 
<pre class="has"><code>static const speed = 100;
</code></pre> 
<ul><li>5、常量的运算</li></ul> 
<pre class="has"><code>const speed = 100; //速度（km/h）
const double distance = 2.5 * speed; // 距离 = 速度 * 时间

final speed2 = 100; //速度（km/h）
final double distance2 = 2.5 * speed2; // 距离 = 速度 * 时间
</code></pre> 
<ul><li>6、const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。 任何变量都可以有一个常量值。</li></ul> 
<pre class="has"><code>// 注意: [] 创建的是一个空的list集合
// const []创建一个空的、不可变的列表（EIL）。
var varList = const []; // varList 当前是一个EIL
final finalList = const []; // finalList一直是EIL
const constList = const []; // constList 是一个编译时常量的EIL

// 可以更改非final,非const变量的值
// 即使它曾经具有const值
varList = ["haha"];

// 不能更改final变量或const变量的值
// 这样写，编译器提示：a final variable, can only be set once
// finalList = ["haha"];
// 这样写，编译器提示：Constant variables can't be assigned a value  
// constList = ["haha"];
</code></pre> 
<ul><li>7、只要任何插值表达式是一个计算结果为null或数字，字符串或布尔值的编译时常量，那么文字字符串就是编译时常量。(关于$表达式和不同的数据类型后面会讲解。)</li></ul> 
<pre class="has"><code>// 这些是常量字符串
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'a constant string';

// 这些不是常量字符串

var aNum = 0;
var aBool = true;
var aString = 'a string';
const aConstList = const [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString';

//这样用就会报错：Const variables must be initialized with a constant value
// const常量必须用conat类型的值初始化。
// const invalidConstString = '$aNum $aBool $aString $aConstList';
</code></pre> 
<hr> 
<h2>四、特殊数据类型</h2> 
<p><strong>Dart支持以下特殊类型：</strong></p> 
<blockquote> 
 <p>numbers 数字<br> strings 字符串<br> booleans 布尔<br> lists list集合（也称为数组）<br> maps map集合<br> runes 字符（用于在字符串中表示Unicode字符）</p> 
</blockquote> 
<h4>（一）num数字类型</h4> 
<p>num是数字类型的父类，有两个子类 <code>int</code> 和 <code>double</code>。<br> num类型包括基本的运算符，如+,-,/和*，位运算符，如&gt;&gt;，在int类中定义。如果num和它的子类没有你要找的东西，math库可能会找到。比如你会发现abs(),ceil()和floor()等方法。</p> 
<p>（1）int类型</p> 
<p><code>int</code>表示整数，int默认是64位二进制补码整数，int的取值不大于64位，具体取决于平台。编译为JavaScript时，整数仅限于valus，可以用双精度浮点值精确表示。可用的整数值包括-253和253之间的所有整数，以及一些幅度较大的整数。这包括一些大于2^63的整数。 因此，在编译为JavaScript的Dart VM和Dart代码之间，int类中的运算符和方法的行为有时会有所不同。例如，当编译为JavaScript时，按位运算符将其操作数截断为32位整数。<br> 示例如下：</p> 
<pre class="has"><code>int intNum1 = 10 ;
print(intNum1);//结果是10
int intNum2 = 0xDEADBEEF ;
print(intNum2);//结果是3735928559
</code></pre> 
<p>判断一个int值需要多少bit(位)，可以使用<code>bitLength</code>，例如：</p> 
<pre class="has"><code>// bitLength 返回存储此int整数所需的最小位数
int a1 = 1; // 占了1个bit     相当于二进制数字 00000000 00000001
int a2 = 12; // 占了4个bit    相当于二进制数字 00000000 00001100
int a3 = 123; // 占了7个bit   相当于二进制数字 00000000 01111011
int a4 = 1234; // 占了11个bit 相当于二进制数字 00000100 11010010
print('${a1.bitLength}'); //  1
print('${a2.bitLength}');  // 4
print('${a3.bitLength}'); // 7
print('${a4.bitLength}'); // 11
</code></pre> 
<p>（2）double类型</p> 
<p>Dart的double是IEEE 754标准中规定的64位浮点数。double的最大值是：<code>1.7976931348623157e+308</code>，double类里面有一个常量<code>maxFinite</code>，我们通过语句<code>print(double. maxFinite)</code>可以得到<code>double的最大值</code>。<br> 如果一个数字包含一个小数，那么它就是一个double类型。示例如下：</p> 
<pre class="has"><code>double doubleNum1 = 1.1;
print(doubleNum1); //结果是1.1
double doubleNum2 = 1.42e5;
print(doubleNum2); //结果是142000.0
</code></pre> 
<p>（3）Dart2.1里面新增特性，当double的值为int值时，int自动转成double。</p> 
<p>例如：<code>double test = 12;//打印结果是12.0</code></p> 
<p>（4）Dart2.1,int也有api转成double。</p> 
<p>例如：</p> 
<pre class="has"><code>int test = 10;
print(test.toDouble()); // 结果是： 10.0
</code></pre> 
<p>（5）Dart2.1,double也有api转成int,会把小数点后面的全部去掉。</p> 
<p>例如：</p> 
<pre class="has"><code>double test2 = 15.1;
double test3 = 15.1234;
print(test2.toInt());// 结果是15
print(test3.toInt());// 结果是15
</code></pre> 
<h4>（二）String字符串类型</h4> 
<p>Dart里面的String是一系列 UTF-16代码单元。</p> 
<p>（1）您可以使用单引号或双引号来创建一个字符串。</p> 
<pre class="has"><code>String str1 = '单引号基本使用demo.';
String str2 = "双引号基本使用demo.";
</code></pre> 
<p>（2）单引号或者双引号里面嵌套使用引号。</p> 
<p>单引号里面嵌套单引号，或者//双引号里面嵌套双引号，必须在前面加反斜杠。</p> 
<pre class="has"><code>// 单引号里面有单引号，必须在前面加反斜杠
String str3 = '单引号里面有单引号it\'s，必须在前面加反斜杠.';
//双引号里面嵌套单引号（正常使用）
String str4 = "双引号里面有单引号it's.";
//单引号里面嵌套双引号（正常使用）
String str5 = '单引号里面有双引号，"hello world"';
//双引号里面嵌套双引号，必须在前面加反斜杠
String str6 = "双引号里面有双引号，\"hello world\"";

print(str3);// 双引号里面有单引号it's，必须在前面加反斜杠
print(str4);// 双引号里面有单引号it's.
print(str5);// 单引号里面有双引号，hello world"
print(str6);//双引号里面有双引号，"hello world"
</code></pre> 
<p>（3）多个字符串相邻中间的空格问题：</p> 
<p>除了单引号嵌套单引号或者双引号嵌套双引号不允许出现空串之外，其余的几种情况都是可以运行的。<br> 示例如下：</p> 
<pre class="has"><code>这个会报错
//String blankStr1 = 'hello''''world';
//这两个运行正常
String blankStr2 = 'hello'' ''world'; //结果： hello world
String blankStr3 = 'hello''_''world'; //结果： hello_world


// 这个会报错
//String blankStr4 = "hello""""world";
这两个运行正常
String blankStr5 = "hello"" ""world"; //结果： hello world
String blankStr6 = "hello""_""world"; //结果： hello_world
</code></pre> 
<p>单引号里面有双引号，混合使用运行正常</p> 
<pre class="has"><code>String blankStr7 = 'hello""""world'; //结果： hello""""world
String blankStr8 = 'hello"" ""world'; //结果： hello"" ""world
String blankStr9 = 'hello""_""world'; //结果： hello""_""world
</code></pre> 
<p>双引号里面有单引号，混合使用运行正常</p> 
<pre class="has"><code>String blankStr10 = "hello''''world"; //结果： hello''''world
String blankStr11 = "hello'' ''world"; //结果： hello'' ''world
String blankStr12 = "hello''_''world"; //结果： hello''_''world
</code></pre> 
<p>（4）您可以使用相邻字符串文字或+ 运算符连接字符串：</p> 
<blockquote> 
 <ol><li>直接把相邻字符串写在一起，就可以连接字符串了。</li></ol> 
</blockquote> 
<pre class="has"><code>  String connectionStr1 =  '字符串连接''甚至可以在''换行的时候进行。';
  print(connectionStr1);// 字符串连接甚至可以在换行的时候进行。
</code></pre> 
<blockquote> 
 <ol><li>用+把相邻字符串连接起来。</li></ol> 
</blockquote> 
<pre class="has"><code>  String connectionStr2 =  '字符串连接'+ '甚至可以在'+ '换行的时候进行。';
  print(connectionStr2);// 字符串连接甚至可以在换行的时候进行。
</code></pre> 
<blockquote> 
 <ol><li>使用单引号或双引号的三引号：</li></ol> 
</blockquote> 
<pre class="has"><code>String connectionStr3 = ''' 
  这是用单引号创建的
  多行字符串。
  ''' ;
print(connectionStr3);
String connectionStr4 = """这是用双引号创建的
  多行字符串。""";
print(connectionStr4);
</code></pre> 
<p>print(connectionStr3)输出结果如下：</p> 
<pre class="has"><code>  这是用单引号创建的
  多行字符串。
</code></pre> 
<p>print(connectionStr4)的输出结果如下：</p> 
<pre class="has"><code>这是用双引号创建的
  多行字符串。
</code></pre> 
<p>（5）关于转义符号的使用</p> 
<p>声明<code>raw字符串（前缀为r）</code>，在字符串前加字符<code>r</code>，或者在<code>\</code>前面再加一个<code>\</code>，<br> 可以避免“\”的转义作用，在正则表达式里特别有用。</p> 
<p>举例如下：</p> 
<pre class="has"><code>print(r"换行符：\n"); //这个结果是 换行符：\n
print("换行符：\\n"); //这个结果是 换行符：\n
print("换行符：\n");  //这个结果是 换行符：
</code></pre> 
<p>（6）使用<code>$</code>可以获得字符串中的内容，使用<code>${表达式}</code>也可以将表达式的值放入字符串中。使用<code>${表达式}</code>时可以使用字符串拼接，也可以使用<code>String</code>类或者<code>Object</code>里面的某些方法获得相关字符串属性。</p> 
<blockquote> 
 <p>1、使用<code>$+字符串</code></p> 
</blockquote> 
<pre class="has"><code>var height = 48.0;
print('当前标题的高度是$height'); //当前标题的高度是48.0
</code></pre> 
<blockquote> 
 <p>2、使用$+字符串，以及字符串拼接</p> 
</blockquote> 
<pre class="has"><code>String name = "张三";
print("$name"+"是我们的部门经理"); // 张三是我们的部门经理
</code></pre> 
<blockquote> 
 <p>3、这里使用了字符串的拼接，以及使用了String类里面的toUpperCase()函数，把字母全部变成大写。</p> 
</blockquote> 
<pre class="has"><code>String replaceStr = 'Android Studio';
assert('你知道' +
'${replaceStr.toUpperCase()}'
+ '最新版本是多少吗？' ==
'你知道ANDROID STUDIO最新版本是多少吗？'); 
</code></pre> 
<p>注：<code>==</code>操作符测试两个对象是否相等。<code>assert</code>是断言，如果条件为true，继续进行，否则抛出异常，中端操作。</p> 
<h4>（三）bool布尔类型</h4> 
<p>Dart表示布尔值的类型叫做<code>bool</code>，它有两个值，分别是：<code>true</code>和<code>false</code>，它们都是编译时常量。<br> Dart使用的是显式的检查值，检查值的类型，如下所示：</p> 
<pre class="has"><code>  // 检查是否为空字符串
  var emptyStr = '';
  assert(emptyStr.isEmpty);

  // 检查是否小于等于0
  var numberStr = 0;
  assert(numberStr &lt;= 0);  

  // 检查是否为null
  var nullStr;
  assert(nullStr == null);

  // 检查是否为NaN
  var value = 0 / 0;
  assert(value.isNaN);
</code></pre> 
<p><code>assert</code> 是Dart语言里的的<code>断言函数</code>，仅在<code>Debug模式下有效</code>。<br> 在开发过程中， 除非条件为真，否则会引发异常。(断言失败则程序立刻终止)。</p> 
<h4>（四）list集合，也成为数组</h4> 
<p>在Dart中，数组是List对象，因此大多数人只是将它们称为List。<br> 以下是一个简单的Dart的List：</p> 
<p>创建一个int类型的list</p> 
<pre class="has"><code>List list = [10, 7, 23];
print(list);// 输出结果  [10, 7, 23]
</code></pre> 
<p>要创建一个编译时常量const的list，示例如下：</p> 
<pre class="has"><code>List constantList = const[10,3,15];
print(constantList);// 输出结果  [10, 3, 15]
</code></pre> 
<p><strong>注意事项：</strong></p> 
<blockquote> 
 <p>1.可以直接打印list包括list的元素，list也是一个对象。但是java必须遍历才能打印list，java若直接打印list，结果是地址值。<br> 2.和java一样list里面的元素必须保持类型一致，不一致就会报错。<br> 3.和java一样list的角标从0开始。</p> 
</blockquote> 
<p>Dart的list集合给我们提供了很多api，示例如下，api太多就不逐个展示了：</p> 
<table><thead><tr><th>操作</th><th>代码</th><th>含义</th><th>输出结果</th></tr></thead><tbody><tr><td>新增</td><td>list.add(1);print(list);</td><td>把数字1添加到list中，默认是添加到末尾</td><td>[10, 7, 23, 1]</td></tr><tr><td>移除</td><td>list.remove(1);print(list);</td><td>移除数字1</td><td>[10, 7, 23]</td></tr><tr><td>插入</td><td>list.insert(0, 5);print(list);</td><td>在索引为0的地方插入数字5</td><td>[5, 10, 7, 23]</td></tr><tr><td>查找某个索引的值</td><td>int value = list.indexOf(10);print(value);</td><td>查找10在list中的索引</td><td>1</td></tr><tr><td>判断元素是否包含</td><td>bool result = list.contains(5);print(result);</td><td>查找list中是否包含数字5</td><td>true</td></tr></tbody></table> 
<h4>（五）map集合</h4> 
<p>Dart中的<code>map</code>是将键和值相关联的对象。键和值都可以是任何类型的对象。每个键只出现一次，但您可以多次使用相同的值。</p> 
<p>（1）创建方式：</p> 
<ul><li> 
  <ol><li>直接声明，用{}表示，里面写key和value，每组键值对中间用逗号隔开。</li></ol></li></ul> 
<pre class="has"><code>Map companys = {'first': '阿里巴巴', 'second': '腾讯', 'fifth': '百度'};
print(companys);//打印结果 {first: 阿里巴巴, second: 腾讯, fifth: 百度}
</code></pre> 
<ul><li> 
  <ol><li>先声明，再去赋值。</li></ol></li></ul> 
<pre class="has"><code>  Map companys1 = new Map();
  companys1['first'] = '阿里巴巴';
  companys1['second'] = '腾讯';
  companys1['fifth'] = '百度';
  print(companys1);
  //打印结果 {first: 阿里巴巴, second: 腾讯, fifth: 百度}
</code></pre> 
<ul><li> 
  <ol><li>要创建一个编译时常量const的map，请在map文字之前添加const：</li></ol></li></ul> 
<pre class="has"><code>final fruitConstantMap = const {2: 'apple',10: 'orange',18: 'banana'};
// 打印结果{second: 腾讯, fifth: 百度, 5: 华为}
</code></pre> 
<p>（2）添加元素。格式: 变量名[key] = value,其中key可以是不同类型。</p> 
<pre class="has"><code>//添加一个新的元素，key为“5”，value为“华为”
  companys[5] = '华为';
  print(companys);//打印结果 {first: 阿里巴巴, second: 腾讯, fifth: 百度, 5: 华为}
</code></pre> 
<p>（3）修改元素。格式：变量名[key] = value</p> 
<p>例如：把key为first的元素对应的value改成 alibaba</p> 
<pre class="has"><code>  companys['first'] = 'alibaba';
  print(companys);//打印结果 {first: alibaba, second: 腾讯, fifth: 百度, 5: 华为}
</code></pre> 
<p>（4）查询元素</p> 
<pre class="has"><code>  bool mapKey = companys.containsKey('second');
  bool mapValue = companys.containsValue('百度');
  print(mapKey); //结果为：true
  print(mapValue); //结果为：true
</code></pre> 
<p>（5）删除元素.可以使用map的remove或者clear方法。</p> 
<pre class="has"><code>  companys.remove('first');// 移除key为“first”的元素。
  print(companys);// 打印结果{second: 腾讯, fifth: 百度, 5: 华为}

  companys.clear();// 清空map集合的数据。
  print(companys);// 打印结果{}
</code></pre> 
<p>（6）关于map集合的小结：</p> 
<pre class="has"><code>1.创建map有两种方式。
2.map的key类型不一致也不会报错。
3.添加元素的时候，会按照你添加元素的顺序逐个加入到map里面，哪怕你的key不连续。
比如key分别是 1,2,4，看起来有间隔，事实上添加到map的时候{1:value,2:value,4:value} 这种形式。
4.添加的元素的key如果是map里面某个key的英文，照样可以添加到map里面，
比如可以为3和key为three可以同时存在。
5.map里面的key不能相同，但是value可以相同,value可以为空字符串或者为null。
</code></pre> 
<h4>（六）runes 字符（用于在字符串中表示Unicode字符）</h4> 
<p>Unicode为世界上所有的书写系统中使用的每个字母，数字和符号定义了唯一的数值。<br> Dart字符串是UTF-16代码单元的序列，所以在字符串中表达32位Unicode值需要特殊的语法。<br> Unicode代码点的常用方法是<code>\uXXXX</code>，其中<code>XXXX</code>是一个4位十六进制值。</p> 
<p>例如，心形字符（）是<code>\u2665</code>。要指定多于或少于4个十六进制数字，请将该值放在大括号中。 例如，笑的表情符号是<code>\u{1f600}</code>。</p> 
<p>String类有几个属性可以用来提取符文信息。 codeUnitAt和codeUnit属性返回16位代码单元。<br> 以下示例说明了符文，16位代码单元和32位代码点之间的关系。</p> 
<pre class="has"><code>var clapping = '\u{1f44f}';
print(clapping);
print(clapping.codeUnits);
print(clapping.runes.toList());

//使用String. fromCharCodes显示字符图形 
Runes input = new Runes(
        '\u2665  \u{1f605}  \u{1f60e}  \u{1f47b}  \u{1f596}  \u{1f44d}');
print(new String.fromCharCodes(input));
</code></pre> 
<hr> 
<h2>五、运算符</h2> 
<p>运算符在每一种语言中都很常见，Dart的运算符如下表所示：</p> 
<div> 
 <div> 
  <div>
      
  </div> 
  <div> 
   <img alt="6098829-58d0dd182cb1ac4b.png" class="has" src="https://images2.imgbox.com/25/a8/MRdzxS4E_o.png"> 
  </div> 
 </div> 
 <div>
     
 </div> 
</div> 
<p>我这里不详细去讲解每个运算符的用法，我这里主要讲一下Dart里面比较有代表性的以及有特点的一些运算符相关用法。</p> 
<h4>（一）<code>?.</code>像<code>.</code>一样，但最左边的操作数可以为空。</h4> 
<p>比如：<code>Test?.funs</code>从表达式Test中选择属性funs，除非Test为空（当Test为空时，<code>Test?.funs</code>的值为空)。</p> 
<pre class="has"><code>class Test {
  static int funs = 5;

  Test() {
    print('构造函数 Test');
  }
  static fun() {
    print('Test fun函数');
  }
}
void main(){
  print(Test?.funs); // 打印5
}
</code></pre> 
<h4>（二）<code>..</code>级联符号<code>..</code></h4> 
<p>级联符号<code>..</code>允许您在同一个对象上进行一系列操作。 除了函数调用之外，还可以访问同一对象上的字段。其实相当于java的链式调用。<br> 例如：</p> 
<pre class="has"><code>String s = (new StringBuffer()
        ..write('test1 ')
        ..write('test2 ')
        ..write('test3 ')
        ..write('test4 ')
        ..write('test5'))
      .toString();
print(s); // test1 test2 test3 test4 test5
</code></pre> 
<h4>（三）?? 三目运算符的一种形式。</h4> 
<p><code>expr1 ?? expr2</code> 表示如果expr1非空，则返回其值; 否则返回expr2的值。</p> 
<pre class="has"><code>//普通三元运算符
int a = 10;
var values = a &gt; 5 ? a : 0;
//??操作符
print('a ??=3 : ${a ??= 3}');  // 3
</code></pre> 
<h4>（四）~/ 除法，返回一个整数结果，其实就是取商。</h4> 
<p><code>小学都学过：被除数 ÷ 除数 = 商 ... 余数</code>，在Dart里面<code>A ~/ B = C</code>，这个C就是商，这个语句相当于Java里面的<code>A / B = C</code>。Dart与java不同的是，Dart里面如果使用<code>A / B = D</code>语句，这个结果计算出来的是真实的结果。示例如下：</p> 
<pre class="has"><code>  var result1 = 15/7;
  print(result1); // 结果是：2.142857...
  var result2 = 15~/7;
  print(result2); // 结果是：2
</code></pre> 
<p>顺便提一下<code>取模</code>操作，在Dart里面<code>A % B = E</code>，这个E就是余数，<code>%</code>符号表示<code>取模</code>，例如：</p> 
<pre class="has"><code> var result3 = 15%7;
  print(result3); // 结果是：1
</code></pre> 
<h4>（五）as、is与is!</h4> 
<p><code>as</code> 判断属于某种类型<br><code>is</code> 如果对象具有指定的类型，则为true<br><code>is!</code> 如果对象具有指定的类型，则为false</p> 
<p>例如：</p> 
<pre class="has"><code>class Test {
  static int funs = 5;

  Test() {
    print('构造函数 Test');
  }
  static fun() {
    print('Test fun函数');
  }
}

class Test2 extends Test {
  Test2() {
    print('构造函数 Test2');
  }
  void fun() {
    print('Test2 fun函数');
  }
}

void main(){
  print(test2 is Test);  // true
  print(test is! Test2);  // true

  (test2 as Test2).fun();  // Test2 fun函数
  // 相当于
  // if (test2 is Test) {
  //   test2.fun();
  // }
</code></pre> 
<hr> 
<h2>六、控制流程语句</h2> 
<p>控制流程语句和Java语言差不多，有这些语句：</p> 
<h4>（一）if else</h4> 
<pre class="has"><code>if(条件语句){
    内容体
}else{
内容体
}
</code></pre> 
<h4>（二）for循环</h4> 
<blockquote> 
 <p>1.简单for循环</p> 
</blockquote> 
<pre class="has"><code>for(初始值;判断条件;循环后的语句){
    内容体
}
</code></pre> 
<p>例如:</p> 
<pre class="has"><code>for(int i=0;i&lt;10;i++){
    print(i);
}
</code></pre> 
<p>也可以通过for循环内部的闭包获取索引的值。</p> 
<pre class="has"><code>var array = [];
for(var i=0;i&lt;10;i++){
    array.add(()=&gt; print(i));
}
</code></pre> 
<blockquote> 
 <p>2.使用foreach循环，一般List和Set都可以使用foreach遍历元素。</p> 
</blockquote> 
<p>如果要迭代的对象是Iterable，或者你不想知道当前的迭代次数，可以使用<code>foreach()</code>方法。</p> 
<pre class="has"><code>var numbers = [1,2,3,4,5,6,7,8,9];
numbers.foreach((number)=&gt; print(number));
</code></pre> 
<blockquote> 
 <p>3.使用for in循环，一般List和Set使用for-in遍历元素。</p> 
</blockquote> 
<pre class="has"><code>var list = [1,2,3];
for(var data in list){
    print(data);
}
</code></pre> 
<blockquote> 
 <p>4.Dart的for循环里面可以使用标记：（比较有特色的地方）</p> 
</blockquote> 
<p>Dart的标记：<code>标记是后面跟着冒号的标识符</code>。带标记的陈述是以标记 L为前缀的陈述。带标签的case子句是标签L前缀的switch语句中的case子句。标签的唯一作用是为“break”和“continue”声明提供对象。<br> 大多数此功能与其他语言类似，因此以下大部分内容可能对读者来说都很熟悉。Dart的switch声明中处理continue是比较独特的，所以这一部分需要一点时间去阅读和熟悉。</p> 
<ul><li>1.循环（Loops）</li></ul> 
<p>标签最常用作<code>break</code> 和 <code>continue</code>内部循环。假设你有嵌套的循环，并要跳转到<code>break</code>或<code>continue</code>到外部循环。如果没有标记，这不可能（轻松）实现。</p> 
<p>以下示例使用<code>continue 标记名称</code>从内部循环直接跳转到外部循环的下一轮循环：</p> 
<pre class="has"><code>// 返回具有最小总和的内部列表（正整数）。
/// Returns the inner list (of positive integers) with the smallest sum.
List&lt;int&gt; smallestSumList(List&lt;List&lt;int&gt;&gt; lists) {
  var smallestSum = 0xFFFFFFFF; //已知list的总和较小。
  var smallestList = null;
  outer: // 这就是标记
  for (var innerList in lists) {
    var sum = 0;
    for (var element in innerList) {
      assert(element &gt;= 0);
      sum += element;
      // 无需继续迭代内部列表。它的总和已经太高了。
      if (sum &gt; smallestSum) continue outer; // continue 跳出到标记处(outer)
    }
    smallestSum = sum;
    smallestList = innerList;
  }
  return smallestList;
}
</code></pre> 
<p>此函数在所有list中运行，但只要总和过高，就会停止累加变量。</p> 
<p>同理，可以使用break跳出到外部循环：</p> 
<pre class="has"><code>// 计算第一个非空list
List&lt;int&gt; firstListWithNullValueList(List&lt;List&lt;int&gt;&gt; lists) {
  var firstListWithNullValues = null;
  outer:
  for (var innerList in lists) {
    for (var element in innerList) {
      if (element == null) {
        firstListWithNullValues = innerList;
        break outer;  // break 返回到标记处
      }
    }
  }
  // 现在继续正常的工作流程
  if (firstListWithNullValues != null) {
    // ...
  }
  return firstListWithNullValues;
}
</code></pre> 
<ul><li>2.跳出代码块</li></ul> 
<p>标记也可以用于跳出代码块。假设我们想要统一处理错误条件，但有多个条件（可能是深度嵌套）来揭示（reveal）错误。标签可以帮助构建此代码。</p> 
<pre class="has"><code>void doSomethingWithA(A a) {
  errorChecks: {
    if (a.hasEntries) {
      for (var entry in a.entries) {
        if (entry is Bad) break errorChecks;   // 跳出代码块
      }
    }
    if (a.hasB) {
      var b = new A.b();
      if (b.inSomeBadState()) break errorChecks;  // 跳出代码块
    }
    // 一些看起来都正常
    use(a);
    return;
  }
  // 错误的情况，执行这里的代码：
  print("something bad happened");
}

class A{
  bool hasEntries = false;
  bool hasB = true;
  List&lt;Bad&gt; entries = [new Bad2(),new Bad2()];
  A.b(){

  }

  bool inSomeBadState(){
    return false;
  }
  
}

void use(A a){}

abstract class Bad{}
class Bad1 extends Bad{}
class Bad2 extends Bad{}
</code></pre> 
<p>对代码块的使用break指令，使得Dart继续执行块之后的语句。从某个角度来看，它是一个结构化的<code>goto</code>，它只允许跳转到当前指令之后的嵌套较少的位置。</p> 
<p>虽然声明标签在代码块中最有用，但它们可以用在在每个语句中。<br> 例如，<code>foo: break foo;</code>是一个有效的声明。</p> 
<p>请注意：<code>continue</code>上面的循环可以通过将循环体包装到带标记的代码块中并使用break来实现。<br> 也就是说，以下两个循环是等效的：</p> 
<pre class="has"><code>//以下两种描述是等价的：

// 使用 continue
for (int i = 0; i &lt; 10; i++) {
  if (i.isEven) continue;
  print(i);
}

// 使用 break.
for (int i = 0; i &lt; 10; i++) {
  labels: {
    // isEven 当且仅当该整数为偶数时才返回true
    if (i.isEven) break labels;
    print(i);
  }
}
</code></pre> 
<ul><li>3.Switch中的标记(label)</li></ul> 
<p>标记也可以用于switch内部。<br> Switch中的标记允许<code>continue</code> 使用其它的<code>case</code> 子句。在最简单的形式中，这可以作为一种方式来实现下一个子句：</p> 
<pre class="has"><code>void switchExample(int foo) {
  switch (foo) {
    case 0:
      print("foo is 0");
      break;
    case 1:
      print("foo is 1");
      continue shared; // Continue使用在被标记为shared的子句中
    shared:
    case 2:
      print("foo is either 1 or 2");
      break;
  }
}
</code></pre> 
<p>有趣的是, Dart没有要求<code>continue</code>的目标子句是当前<code>case</code>子句之后的子句。<br> 带标记的任何<code>case</code>子句都是有效的目标。这意味着，Dart的<code>switch</code>语句实际上是状态机（state machines）。</p> 
<p>以下示例演示了这种滥用，其中整个<code>switch</code>实际上只是用作状态机（state machines）。</p> 
<pre class="has"><code>void main() {
  runDog();
}

void runDog() {
  int age = 0;
  int hungry = 0;
  int tired = 0;

  bool seesSquirrel() =&gt; new Random().nextDouble() &lt; 0.1;
  bool seesMailman() =&gt; new Random().nextDouble() &lt; 0.1;

  switch (1) {
    start:
    case 0:
      print("dog 方法已经开始");
      print('case 0 ==&gt; age: $age');
      print('case 0 ==&gt; hungry: $hungry');
      print('case 0 ==&gt; tired: $tired');
      continue doDogThings;

    sleep:
    case 1:
      print("sleeping");
      tired = 0;
      age++;
      if (age &gt; 20) break;
      print('case 1 ==&gt; age: $age');
      print('case 1 ==&gt; hungry: $hungry');
      print('case 1 ==&gt; tired: $tired');
      continue doDogThings;

    doDogThings:
    case 2:  
      if (hungry &gt; 2) continue eat;
      if (tired &gt; 3) continue sleep;
      if (seesSquirrel()) continue chase;
      if (seesMailman()) continue bark;
      print('case 2 ==&gt; age: $age');
      print('case 2 ==&gt; hungry: $hungry');
      print('case 2 ==&gt; tired: $tired');
      continue play;

    chase:
    case 3:  
      print("chasing");
      hungry++;
      tired++;
      print('case 3 ==&gt; age: $age');
      print('case 3 ==&gt; hungry: $hungry');
      print('case 3 ==&gt; tired: $tired');
      continue doDogThings;

    eat:
    case 4:  
      print("eating");
      hungry = 0;
      print('case 4 ==&gt; age: $age');
      print('case 4 ==&gt; hungry: $hungry');
      print('case 4 ==&gt; tired: $tired');
      continue doDogThings;

    bark:
    case 5: 
      print("barking");
      tired++;
      print('case 5 ==&gt; age: $age');
      print('case 5 ==&gt; hungry: $hungry');
      print('case 5 ==&gt; tired: $tired');
      continue doDogThings;

    play:
    case 6: 
      print("playing");
      tired++;
      hungry++;
      print('case 6 ==&gt; age: $age');
      print('case 6 ==&gt; hungry: $hungry');
      print('case 6 ==&gt; tired: $tired');
      continue doDogThings;
  }
}
</code></pre> 
<p>这个函数从一个switch子句跳到另一个子句，模拟了狗的生命。<br> 在Dart中，标签只允许在case子句中使用，因此我必须添加一些case永远不会到达的行。</p> 
<p>这个功能很酷，但很少使用。由于我们的编译器增加了复杂性，我们经常讨论它的删除。到目前为止，它已经在我们的审查中幸存下来，但我们最终可能会简化我们的规范并让用户自己添加一个<code>while(true)</code>循环（带有标记）。这个dog的示例可以重写如下：</p> 
<pre class="has"><code>var state = 0;
loop:
while (true)
  switch (state) {
    case 0:
      print("dog has started");
      state = 2; continue;

    case 1:  // sleep.
      print("sleeping");
      tired = 0;
      age++;
      // The inevitable... :(
      if (age &gt; 20) break loop;  // 跳出循环
      // Wake up and do dog things.
      state = 2; continue;
    
    case 2:  // doDogThings.
      if (hungry &gt; 2) { state = 4; continue; }
      if (tired &gt; 3) { state = 1; continue; }
      if (seesSquirrel()) { state = 3; continue; }
      ...
</code></pre> 
<p>如果状态值被命名为常量，那么它将与原始版本一样具有可读性，但不需要<code>switch</code>语句来支持状态机。</p> 
<h4>（三）while 和do while</h4> 
<pre class="has"><code>while(判断条件){
    内容体
}
</code></pre> 
<pre class="has"><code>do{
内容体
} while(判断条件);
</code></pre> 
<pre class="has"><code>while(a&gt;5){
    print(a);
}
</code></pre> 
<pre class="has"><code>do{
print(a);
} while(a&gt;5);
</code></pre> 
<h4>（四）break continue</h4> 
<p>break 停止循环</p> 
<pre class="has"><code>while(a&gt;5){
  if(b&gt;5){
  print(a);
    break;
  }
}
</code></pre> 
<p>continue 跳到下一个循环</p> 
<pre class="has"><code>while(a&gt;5){
  if(b&lt;10){
  print(b);
    continue;
  }
}
</code></pre> 
<p>如果使用<code>Iterable（list或者set）</code>，则可以使用下面这种方式：</p> 
<pre class="has"><code>// 第一个是满足条件就进入  第二个是foreach遍历
arrays
  .when((c)=&gt;c.counts &gt;=5)
  .foreach((c)=&gt;c.next());
</code></pre> 
<h4>（五）switch case</h4> 
<p>比较integer, string,编译时常量 使用==。比较对象必须是同一个类的实例（不是其子类的实例），并且该类不能重写==。枚举类型在switch也可以运行。<br> 每一条非空case字子句以break结束，也可以使用其他的方式结束：<code>continue</code>,<code>throw</code>或者<code>return</code>。</p> 
<pre class="has"><code>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}
</code></pre> 
<h4>（六）assert</h4> 
<p>如果布尔条件为false，则使用assert语句来中断正常执行。例如：</p> 
<pre class="has"><code>// 确保变量具有非空值 
assert(text != null);
// 确保值小于100
assert(number &lt; 100);
// 确保这是一个 https 网址
assert(urlString.startsWith('https'));
</code></pre> 
<p>要将消息附加到断言，请添加一个字符串作为第二个参数。</p> 
<pre class="has"><code>assert(urlString.startsWith('https'),'URL ($urlString) should start with "https".');
</code></pre> 
<p>上例中<code>assert</code>的第一个参数可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果为false，则断言失败并抛出异常</p> 
<hr> 
<h2>七、异常</h2> 
<p>Dart代码可以抛出并捕获异常。Exception是指示发生意外事件的错误。如果未捕获异常，则会暂停引发异常的isolate ，并且通常会终止isolate及其程序。</p> 
<p><code>与Java相比，Dart的所有异常都是未经检查的异常。方法不会声明它们可能引发的异常，并且您不需要捕获任何异常。</code></p> 
<p>Dart提供了<code>Exception</code>和<code>Error</code> 类型，以及许多预定义的子类型。当然，您可以定义自己的Exception。但是，Dart程序可以抛出任何非null对象，作为Exception(不仅仅是Exception和Error对象)。</p> 
<h4>（一）throw</h4> 
<p>以下是抛出或引发异常的示例：</p> 
<pre class="has"><code>throw FormatException('Expected at least 1 section');
</code></pre> 
<p>你也可以抛出任意对象，例如：<code>throw '格式不正确!';</code><br> 通常在开发中会抛出Error或者Exception类型。</p> 
<p>因为抛出异常是一个表达式，所以可以在=&gt;语句中以及允许表达式的任何其他地方抛出异常：</p> 
<pre class="has"><code>void distanceTo(Point other) =&gt; throw UnimplementedError();   
</code></pre> 
<h4>（二）try catch</h4> 
<p>捕获或捕获异常会阻止异常传递（除非您重新抛出异常）。捕获异常使您有机会处理它：</p> 
<pre class="has"><code>try {
    breedMoreLlamas();
} on OutOfLlamasException {
    buyMoreLlamas();
}
</code></pre> 
<p>要处理可能抛出多种类型异常的代码，可以<code>指定多个catch子句</code>。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句未指定类型，则该子句可以处理任何类型的抛出对象。<br> 您可以<code>使用on或catch</code>或<code>两者兼而有之</code>。使用<code>on时需要指定异常类型</code>。使用catch时，你的异常处理程序需要异常对象。<br> 示例：</p> 
<pre class="has"><code>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}
</code></pre> 
<p>您可以指定一个或两个参数catch()。第一个是抛出的异常，第二个是堆栈跟踪（StackTrace对象）。<br> 示例：</p> 
<pre class="has"><code>try {
  // ···
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
</code></pre> 
<p>要部分处理异常，同时允许它传递，请使用rethrow关键字。<br> 示例：</p> 
<pre class="has"><code>void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // 运行时异常
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // 允许调用者查看exception.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}
</code></pre> 
<h4>（三）finally</h4> 
<p>无论是否抛出异常，要确保某些代码运行，请使用<code>finally</code>子句。如果没有catch子句匹配该异常，则在finally子句运行后传递异常。<br> 示例：</p> 
<pre class="has"><code>try {
  breedMoreLlamas();
} finally {
  // 即使抛出异常  也会执行这句代码.
  cleanLlamaStalls();
}
该finally子句在任何匹配的catch子句之后运行：
try {
  breedMoreLlamas();
} catch (e) {
    // 首先会处理异常
  print('Error: $e'); 
} finally {
  // 然后执行这句语句
  cleanLlamaStalls(); 
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df95b33f1b492472c181e0e9a253c4db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2018湘潭邀请赛A题题解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87c0f7b0fff591f6c0a98071d73c2699/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Type-C与Type-A、Type-B接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>