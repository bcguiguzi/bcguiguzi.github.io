<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>垃圾回收算法：引用计数法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="垃圾回收算法：引用计数法" />
<meta property="og:description" content="本文是《垃圾回收的算法与实现》读书笔记 上一篇为《GC 标记-清除算法》
引用计数算法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这也就是需要回收的对象。 引用计数算法是对象记录自己被多少程序引用，引用计数为零的对象将被清除。
计数器表示的是有多少程序引用了这个对象（被引用数）。计数器是无符号整数。
计数器的增减 引用计数法没有明确启动 GC 的语句，它与程序的执行密切相关，在程序的处理过程中通过增减计数器的值来进行内存管理。
new_obj() 函数 与GC标记-清除算法相同，程序在生成新对象的时候会调用 new_obj()函数。
func new_obj(size){ obj = pickup_chunk(size, $free_list) if(obj == NULL) allocation_fail() else obj.ref_cnt = 1 // 新对象第一只被分配是引用数为1 return obj } 这里 pickup_chunk()函数的用法与GC标记-清除算法中的用法大致相同。不同的是这里返回 NULL 时，分配就失败了。这里 ref_cnt 域代表的是 obj 的计数器。
在引用计数算法中，除了连接到空闲链表的对象，其他对象都是活跃对象。所以如果 pickup_chunk()返回 NULL，堆中也就没有其它大小合适的块了。 update_ptr() 函数 update_ptr() 函数用于更新指针 ptr，使其指向对象 obj，同时进行计数器值的增减。
func update_ptr(ptr, obj){ inc_ref_cnt(obj) // obj 引用计数&#43;1 dec_ref_cnt(*ptr) // ptr之前指向的对象(*ptr)的引用计数-1 *ptr = obj } 这里 update_ptr 为什么需要先调用 inc_ref_cnt，再调用 dec_ref_cnt呢？ 是因为有可能 *ptr和 obj 可能是同一个对象，如果先调用dec_ref_cnt可能会误伤。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/dc630749b0bf0d2af3884ceed8aeca5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-12T08:10:14+08:00" />
<meta property="article:modified_time" content="2018-08-12T08:10:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">垃圾回收算法：引用计数法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote>
   本文是《垃圾回收的算法与实现》读书笔记 
  <p>上一篇为<a href="https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw" rel="nofollow">《GC 标记-清除算法》</a></p> 
 </blockquote> 
 <h4>引用计数算法</h4> 
 <blockquote>
   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这也就是需要回收的对象。 
  <p><code>引用计数算法</code>是对象记录自己被多少<strong>程序</strong>引用，引用计数为零的对象将被清除。</p> 
  <p><code>计数器</code>表示的是有多少程序引用了这个对象（被引用数）。计数器是无符号整数。</p> 
 </blockquote> 
 <h5>计数器的增减</h5> 
 <p>引用计数法没有明确启动 GC 的语句，它与程序的执行密切相关，在程序的处理过程中通过增减计数器的值来进行内存管理。</p> 
 <h6> <strong>new_obj()</strong> 函数</h6> 
 <p>与<code>GC标记-清除</code>算法相同，程序在生成新对象的时候会调用 new_obj()函数。</p> 
 <pre><code class="c">func new_obj(size){
    obj = pickup_chunk(size, $free_list)
    
    if(obj == NULL)
        allocation_fail()
    else
        obj.ref_cnt = 1  // 新对象第一只被分配是引用数为1
        return obj
}</code></pre> 
 <p>这里 <code>pickup_chunk()</code>函数的用法与<code>GC标记-清除算法</code>中的用法大致相同。不同的是这里返回 NULL 时，分配就失败了。这里 <code>ref_cnt</code> 域代表的是 obj 的计数器。</p> 
 <blockquote>
   在引用计数算法中，除了连接到空闲链表的对象，其他对象都是活跃对象。所以如果 pickup_chunk()返回 NULL，堆中也就没有其它大小合适的块了。 
 </blockquote> 
 <h6> <strong>update_ptr()</strong> 函数</h6> 
 <p>update_ptr() 函数用于更新指针 <code>ptr</code>，使其指向对象 obj，同时进行计数器值的增减。</p> 
 <pre><code class="c">func update_ptr(ptr, obj){
    inc_ref_cnt(obj)     // obj 引用计数+1
    dec_ref_cnt(*ptr)    // ptr之前指向的对象(*ptr)的引用计数-1
    *ptr = obj
}</code></pre> 
 <blockquote>
   这里 update_ptr 为什么需要先调用 
  <code>inc_ref_cnt</code>，再调用 
  <code>dec_ref_cnt</code>呢？ 
  <p>是因为有可能 *ptr和 obj 可能是同一个对象，如果先调用<code>dec_ref_cnt</code>可能会误伤。</p> 
 </blockquote> 
 <p><strong>inc_ref_cnt()</strong>函数</p> 
 <p>这里inc_ref_cnt函数只对对象 obj 引用计数+1</p> 
 <pre><code class="go">func inc_ref_cnt(obj){
    obj.ref_cnt++
}</code></pre> 
 <p><strong>dec_ref_cnt()</strong> 函数</p> 
 <p>这里 dec_ref_cnt 函数会把之前引用的对象进行-1 操作，如果这时对象的计数器变为0，说明这个对象是一个垃圾对象，需要销毁，那么被它引用的对象的计数器值都需要相应的-1。</p> 
 <pre><code class="go">func dec_ref_cnt(obj){
    obj_ref_cnt--
    if(obj.ref_cnt == 0)
        for(child : children(obj))
            dec_ref_cnt(*child)  // 递归将被需要销毁对象引用的对象计数-1
    reclaim(obj)
}</code></pre> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/f8/cc/v1AVBLtn_o.jpg" alt="update_prt() 函数执行是的情况" title="update_prt() 函数执行是的情况"></span></p> 
 <p>上图这里开始时，A 指向 B，第二步 A 指向了 C。可以看到通过更新，B 的计数器值变为了0，因此 B 被回收（连接到空闲链表），C 的计数器值由1变成了2。</p> 
 <blockquote> 
  <p>通过上边的介绍，应该可以看出引用计数垃圾回收的特点。</p> 
  <ol><li>在变更数组元素的时候会进行指针更新</li><li>通过更新执行计数可能会产生没有被任何程序引用的垃圾对象</li><li>引用计数算法会时刻监控更新指针是否会产生垃圾对象，一旦生成会立刻被回收。</li></ol> 
  <p>所以如果调用 <code>pickup_chunk</code>函数返回 NULL，说明堆中所有对象都是活跃对象。</p> 
 </blockquote> 
 <h5>引用计数算法的优点</h5> 
 <ol><li> <p>可立即回收垃圾</p> 
   <blockquote>
     每个对象都知道自己的引用计数，当变为0时可以立即回收，将自己接到空闲链表 
   </blockquote> </li><li> <p>最大暂停时间短</p> 
   <blockquote> 
    <p>因为只要程序更新指针时程序就会执行垃圾回收，也就是每次通过执行程序生成垃圾时，这些垃圾都会被回收，内存管理的开销分布于整个应用程序运行期间，无需挂起应用程序的运行来做，因此消减了最大暂停时间（但是增多了垃圾回收的次数）</p> 
    <blockquote> 
     <code>最大暂停时间</code>，因执行 GC 而暂停执行程序的最长时间。 
    </blockquote> 
   </blockquote> </li><li> <p>不需要沿指针查找</p> 
   <blockquote>
     产生的垃圾立即就连接到了空闲链表，所以不需要查找哪些对象是需要回收的 
   </blockquote> </li></ol> 
 <h5>引用计数算法的缺点</h5> 
 <ol><li> <p>计数器值的增减处理频繁</p> 
   <blockquote>
     因为每次对象更新都需要对计数器进行增减，特别是被引用次数多的对象。 
   </blockquote> </li><li> <p>计数器需要占用很多位</p> 
   <blockquote>
     计数器的值最大必须要能数完堆中所有对象的引用数。比如我们用的机器是32位，那么极端情况，可能需要让2的32次方个对象同时引用一个对象。这就必须要确保各对象的计数器有32位大小。也就是对于所有对象，必须保留32位的空间。 
    <p>假如对象只有两个域，那么其计数器就占用了整体的1/3。</p> 
   </blockquote> </li><li> <p>循环引用无法回收</p> 
   <blockquote>
     这个比较好理解，循环引用会让计数器最小值为1，不会变为0。 
   </blockquote> </li></ol> 
 <h5>循环引用</h5> 
 <pre><code class="python">class Person{  // 定义 Person 类
    string name
    Person lover
}

lilw = new Person("李雷")    // 生成 person 类的实例 lilw
hjmmwmw = new Person("韩梅梅") // 生成 person 类的实例 hjmwmw

lilw.lover = hjmwmw   // lilw 引用 hjmwmw
hjmwmw.lover = lilw   // hjmwmw 引用 lilw
</code></pre> 
 <p>像这样，两个对象相互引用，所以各个对象的计数器都为1，且这些对象没有被其他对象引用。所以计数器最小值也为1，不可能为0。</p> 
 <h4>延迟引用计数法</h4> 
 <p>引用计数法虽然缩小了<code>最大暂停时间</code>，但是<code>计数器的增减处理</code>特别多。为了改善这个缺点，<code>延迟引用计数法(Deferred Reference Counting)</code>被研究了出来。</p> 
 <p>通过上边的描述，可以知道之所以计数器增减处理特别繁重，是因为有些增减是根引用的变化，因此我们可以让根引用的指针变化不反映在计数器上。比如我们把 <code>update_ptr($ptr, obj)</code>改写成<code>*$ptr = obj</code>，这样频繁重写对重对象中引用关系时，计数器也不需要修改。但是这有一个问题，那就是计数器并不能正确反映出对象被引用的次数，就有可能会出现，对象仍在活动，却被回收。</p> 
 <p>在<strong>延迟引用计数法</strong>中使用<code>ZCT(Zero Count Table)</code>，来修正这一错误。</p> 
 <blockquote>
   ZCT 是一个表，它会事先记录下计数器在 
  <code>dec_ref_cnt()</code>函数作用下变成 0 的对象。 
 </blockquote> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/80/ea/YJTiOVCh_o.jpg" alt="ZCT" title="ZCT"></span></p> 
 <h5>dec_ref_cnt 函数</h5> 
 <p>在延迟引用计数法中，引用计数为0 的对象并不一定是垃圾，会先存入到 zct 中保留。</p> 
 <pre><code class="go">func dec_ref_cnt(obj){
    obj_ref_cnt--
    if(obj.ref_cnt == 0) //引用计数为0 先存入到 $zct 中保留
        if(is_full($zct) == TRUE) // 如果 $zct 表已经满了 先扫描 zct 表，清除真正的垃圾
            scan_zct()
        push($zct, obj)
}</code></pre> 
 <h5>scan_zct 函数</h5> 
 <pre><code class="python">func scan_zct(){
    for(r: $roots)
        (*r).ref_cnt++
    
    for(obj : $zct)
        if(obj.ref_cnt == 0)
            remove($zct, obj)
            delete(obj)
    
    for(r: $roots)
        (*).ref_cnt--
}</code></pre> 
 <ol><li>第二行和第三行，程序先把所有根直接引用的计数器都进行增量。这样，来修正计数器的值。</li><li>接下来检查 <code>$zct</code> 表中的对象，如果此时计数器还为0，则说明没有任何引用，那么将对象先从 <code>$zct</code>中清除，然后调用 <code>delete()</code>回收。</li></ol> 
 <p>delete() 函数定义如下：</p> 
 <pre><code class="python">func delete(obj){
    for(child : children(obj)) // 递归清理对象的子对象
        (*child).ref_cnt--
        if (*child).ref_cnt == 0 
            delete(*child)
    
    reclaim(obj)
}</code></pre> 
 <h5>new_obj() 函数</h5> 
 <p>除 dec_ref_cnt 函数需要调整，new_obj 函数也要做相应的修改。</p> 
 <pre><code class="go">func new_obj(size){
    obj = pickup_chunk(size, $free_list)
    
    if(obj == NULL) // 空间不足
        scan_zct()  // 扫描 zct 以便获取空间
        obj = pickup_chunk(size, $free_list) // 再次尝试分配
        if(obj == NULL)
            allocation_fail()  // 提示失败
            
     obj.ref_cnt = 1
     return obj
}</code></pre> 
 <blockquote>
   如果第一次分配空间不足，需要扫描 $zct，以便再次分配，如果这时空间还不足，就提示失败 
 </blockquote> 
 <p>在延迟引用计数法中，程序延迟了根引用的计数，通过延迟，减轻了因根引用频繁变化而导致的计数器增减所带来的额外的负担。</p> 
 <p>但是，延迟引用计数却不能马上将垃圾进行回收，<code>可立即回收垃圾</code>这一优点也就不存在了。<code>scan_zct</code>函数也会增加程序的最大暂停时间。</p> 
 <h4>Sticky 引用计数法</h4> 
 <p>对于引用计数法，有一个不能忽略的部分是计数器位宽的设置。假设为了反映所有引用，计数器需要1个字（32位机器就是32位）的空间。但是这会大量的消耗内存空间。比如，2个字的对象就需要一个字的计数器。也就是计数器会使对象所占的空间增大1.5倍。</p> 
 <p><code>sticky 引用计数法</code>就是用来减少位宽的。</p> 
 <blockquote>
   如果我们为计数器的位数设为5，那么计数器最大的引用数为31，如果有超过31个对象引用，就会爆表。对于爆表，我们怎么处理呢？ 
 </blockquote> 
 <h5>1. 什么都不做</h5> 
 <p>这种处理方式对于计数器爆表的对象，再有新的引用也不在增加，当然，当计数器为0 的时候，也不能直接回收（因为可能还有对象在引用）。这样其实是会产生残留的对象占用内存。</p> 
 <blockquote>
   不过，研究表明，大部分对象其实只被引用了一次就被回收了，出现5位计数器溢出的情况少之又少。 
  <p>爆表的对象大部分也都是重要的对象，不会轻易回收。</p> 
  <p>所以，什么都不做也是一个不错的办法。</p> 
 </blockquote> 
 <h5>2. 使用GC 标记-清除算法进行管理</h5> 
 <p>这种方法是，对于爆表的对象，使用 GC 标记-清除算法来管理。</p> 
 <pre><code class="go">func mark_sweep_for_counter_overflow(){
    reset_all_ref_cnt()
    mark_phase()
    sweep_phase()
}</code></pre> 
 <p>首先，把所有对象的计数器都设为0，然后进行标记和清除阶段。</p> 
 <p>标记阶段代码为：</p> 
 <pre><code class="go">func mark_phase(){
    for (r: $roots)  // 先把根引用的对象推到标记栈中
        push(*r, $mark_stack)
    
    while(is_empty($mark_stack) == False) // 如果堆不为空
        obj = pop($mark_stack)
        obj.ref_cnt++  
        if(obj.ref_cnt == 1) // 这里必须把各个对象及其子对象堆进行标记一次
            for(child : children(obj))
                push(*child, $mark_stack)
}</code></pre> 
 <blockquote>
   在标记阶段，先把根引用的对象推到标记栈中 
  <p>然后按顺序从标记栈中取出对象，对计数器进行增量操作。</p> 
  <p>对于循环引用的对象来说，obj.ref_cnt &gt; 1，为了避免无谓的 push 这里需要进行 if(obj.ref_cnt == 1) 的判断</p> 
 </blockquote> 
 <p>清除阶段代码为：</p> 
 <pre><code class="go">func sweep_phase(){
    sweeping = $heap_top
    while(sweeping &lt; $heap_end)  // 因为循环引用的所有对象都会被 push 到 head_end 所以也能被回收
        if(sweeping.ref_cnt == 0)
            reclaim(sweeping)
        sweeping += sweeping.size
}</code></pre> 
 <p>在清除阶段，程序会搜索整个堆，回收计数器仍为0的对象。</p> 
 <blockquote> 
  <p>这里的 GC 标记-清除算法和上一篇<a href="https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw" rel="nofollow">GC 标记-清除算法</a> 主要不同点如下：</p> 
  <ol><li>开始时将所有对象的计数器值设为0</li><li>不标记对象，而是对计数器进行增量操作</li><li>为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索。</li></ol> 
 </blockquote> 
 <p>这里将 GC 标记-清除算法和引用计数法结合起来，在计数器溢出后，对象称为垃圾也不会漏掉清除。并且也能回收循环引用的垃圾。</p> 
 <p>因为在查找对象时不是设置标志位而是把计数器进行增量，所以需要多次查找活动对象，所以这里的标记处理比以往的标记清除花的时间更长，吞吐量会相应的降低。</p> 
 <h3>参考链接</h3> 
 <ul><li><a href="https://book.douban.com/subject/26821357/" rel="nofollow">垃圾回收的算法与实现</a></li><li><a href="https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw" rel="nofollow">《GC 标记-清除算法》</a></li></ul> 
 <hr> 
 <p><strong>最后，感谢女朋友支持和包容，比❤️</strong></p> 
 <p>也可以在公号输入以下关键字获取历史文章：<code>公号&amp;小程序</code> | <code>设计模式</code> | <code>并发&amp;协程</code></p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/d7/1f/3IATcTJC_o.jpg" alt="" title=""></span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06513cc68cff08ad0955ca666c80cd2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">李宏毅机器学习（2017full）-Lecture 2: Where does the error come from?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8dd735096d9aa80472983eb16a2c526/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决使用SSH连接Linux服务器时连接失败的故障</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>