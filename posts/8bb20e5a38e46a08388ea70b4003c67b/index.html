<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 从硬件到应用：一步一步向上爬 3 -- 硬件抽象层访问硬件驱动 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 从硬件到应用：一步一步向上爬 3 -- 硬件抽象层访问硬件驱动" />
<meta property="og:description" content="Android 标准的硬件驱动分为两个部分，一个是运行在linux内核里的硬件驱动，而另外一部分是运行在用户空间的硬件抽象层。采用这种方法，就可以使系统具有硬件无关性，也保护了部分厂商的利益。在 Android 从硬件到应用：一步一步向上爬 1 -- 从零编写底层硬件驱动程序 中已经有了编写硬件驱动到linux内核里的步骤，下面就要接着这个工程去看看怎么在硬件抽象层增加硬件模块和我们的内核驱动程序进行交互，完成硬件控制。
进入hardware/libhardware/include/hardware目录，新建gpio.h:
#ifndef ANDROID_GPIO_INTERFACE_H #define ANDROID_GPIO_INTERFACE_H #include &lt;hardware/hardware.h&gt; __BEGIN_DECLS /*module ID*/ #define GPIO_HARDWARE_MODULE_ID &#34;gpio&#34; /*module struct*/ struct gpio_module_t { struct hw_module_t common; }; /*interface struct*/ struct gpio_device_t { struct hw_device_t common; int fd; int (*set_val)(struct gpio_device_t* dev, int val); int (*get_val)(struct gpio_device_t* dev, int* val); }; __END_DECLS #endif 其中set_val和get_val是HAL层向上层应用提供的API接口。 cd到hardware/libhardware/modules目录，新建gpio目录，在里面新建gpio.c文件：
#include &lt;hardware/hardware.h&gt; #include &lt;hardware/gpio.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;cutils/log.h&gt; #include &lt;cutils/atomic.h&gt; #define DEVICE_NAME &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8bb20e5a38e46a08388ea70b4003c67b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-12-14T22:34:06+08:00" />
<meta property="article:modified_time" content="2014-12-14T22:34:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 从硬件到应用：一步一步向上爬 3 -- 硬件抽象层访问硬件驱动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       Android 标准的硬件驱动分为两个部分，一个是运行在linux内核里的硬件驱动，而另外一部分是运行在用户空间的硬件抽象层。采用这种方法，就可以使系统具有硬件无关性，也保护了部分厂商的利益。在<a target="_blank" href="http://blog.csdn.net/wu20093346/article/details/41871429" rel="noopener noreferrer"> Android 从硬件到应用：一步一步向上爬 1 -- 从零编写底层硬件驱动程序 </a>中已经有了编写硬件驱动到linux内核里的步骤，下面就要接着这个工程去看看怎么在硬件抽象层增加硬件模块和我们的内核驱动程序进行交互，完成硬件控制。</p> 
<p>进入hardware/libhardware/include/hardware目录，新建gpio.h:</p> 
<p></p> 
<pre><code class="language-javascript">#ifndef ANDROID_GPIO_INTERFACE_H  
#define ANDROID_GPIO_INTERFACE_H  
#include &lt;hardware/hardware.h&gt;  
      
__BEGIN_DECLS  
      
/*module ID*/  
#define GPIO_HARDWARE_MODULE_ID "gpio"  
/*module struct*/  
struct gpio_module_t {
	struct hw_module_t common;  
};       
/*interface struct*/  
struct gpio_device_t {
	struct hw_device_t common;  
	int fd;  
	int (*set_val)(struct gpio_device_t* dev, int val);  
	int (*get_val)(struct gpio_device_t* dev, int* val);  
}; 
__END_DECLS
#endif  </code></pre>其中set_val和get_val是HAL层向上层应用提供的API接口。 
<p></p> 
<p>cd到hardware/libhardware/modules目录，新建gpio目录，在里面新建gpio.c文件：</p> 
<p></p> 
<pre><code class="language-javascript">#include &lt;hardware/hardware.h&gt;  
#include &lt;hardware/gpio.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;errno.h&gt;  
#include &lt;cutils/log.h&gt;  
#include &lt;cutils/atomic.h&gt;  
#define DEVICE_NAME "/dev/AdrIO"  
#define MODULE_NAME "Gpio"  

//open and close
static int gpio_device_open(const struct hw_module_t* module, const char* name, struct hw_device_t** device);  
static int gpio_device_close(struct hw_device_t* device);  
//device access
static int gpio_set_val(struct gpio_device_t* dev, int val);  
static int gpio_get_val(struct gpio_device_t* dev, int* val);  

static struct hw_module_methods_t gpio_module_methods = {  
    open: gpio_device_open  
};  

struct gpio_module_t HAL_MODULE_INFO_SYM = {  
    common: {  
        tag: HARDWARE_MODULE_TAG,  
        version_major: 1,  
        version_minor: 0,  
        id: GPIO_HARDWARE_MODULE_ID,  
        name: MODULE_NAME,  
        author: "HAL",  
        methods: &amp;gpio_module_methods, }  
}; 

static int gpio_device_open(const struct hw_module_t* module, const char* name, struct hw_device_t** device) 
{  
	struct gpio_device_t* dev;
	dev = (struct gpio_device_t*)malloc(sizeof(struct gpio_device_t));  
	memset(dev, 0, sizeof(struct gpio_device_t));  
	dev-&gt;common.tag = HARDWARE_DEVICE_TAG;  
	dev-&gt;common.version = 0;  
	dev-&gt;common.module = (hw_module_t*)module;  
	dev-&gt;common.close = gpio_device_close;  
	dev-&gt;set_val = gpio_set_val;
	dev-&gt;get_val = gpio_get_val;  
	if((dev-&gt;fd = open(DEVICE_NAME, O_RDWR)) == -1) {  
		LOGE("gpio: failed to open /dev/AdrIO -- %s.", strerror(errno));
		free(dev);  
		return -EFAULT;  
	}  
	*device = &amp;(dev-&gt;common);  
	return 0;  
}  

static int gpio_device_close(struct hw_device_t* device) 
{  
	struct gpio_device_t* gpio_device = (struct gpio_device_t*)device;  

	if(gpio_device) {  
	    close(gpio_device-&gt;fd);  
	    free(gpio_device);  
	}    
	return 0;  
}  

static int gpio_set_val(struct gpio_device_t* dev, int val) 
{  
	LOGI("gpio: set value %d to device.", val);  
	write(dev-&gt;fd, &amp;val, sizeof(val));  
	return 0;  
}  

static int gpio_get_val(struct gpio_device_t* dev, int* val) 
{  
	return 0;
}</code></pre>为了防止调用时出现 Permission denied的情况： 
<p></p> 
<p>打开am335xevm文件系统根目录rootfs，打开ueventd.rc添加：</p> 
<p></p> 
<pre><code class="language-javascript">/dev/AdrIO  0666 root root</code></pre> 
<p>该文件并不会创建设备节点，而是当有设备节点产生的时候，eventd 会根据这个数据库设置设备的权限。<br> </p> 
<p>修改hardware/libhardware/modules目录下Android.mk在harware_modules ：=后面加上“gpio”<br> </p> 
<p>在gpio目录中继续添加Android.mk文件：</p> 
<p></p> 
<p></p> 
<pre><code class="language-javascript">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional
LOCAL_PRELINK_MODULE := false
LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
LOCAL_SHARED_LIBRARIES := liblog
LOCAL_SRC_FILES := gpio.c
LOCAL_MODULE := gpio.default
include $(BUILD_SHARED_LIBRARY)</code></pre> 
<p>编译HAL层：</p> 
<p></p> 
<pre><code class="language-javascript">make TARGET_PRODUCT=am335xevm_sk -j8 OMAPES=4.x</code></pre> 
<p></p> 
<p>如果出现错误，参考：<br> </p> 
<p><a target="_blank" href="http://blog.csdn.net/wu20093346/article/details/41930493" rel="noopener noreferrer">没有规则可以创建 /lib/liblog.so </a></p> 
<p>如果成功，就可以生成 gpio.default.so</p> 
<p></p> 
<pre><code class="language-javascript">out/target/product/am335xevm_sk/obj/lib/gpio.default.so
</code></pre>这个就是我们需要的硬件抽象层模块，这一步完成之后，还要接着向上走，最终完成硬件调用。 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ed74f9392a23112d90fdc8cfd492e6c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL之函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9082d155ca9cdd1fae2ecf0493c7cdbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 从硬件到应用：一步一步向上爬 5 -- 在Frameworks层添硬件服务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>