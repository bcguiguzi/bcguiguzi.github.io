<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编译原理 LR语法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编译原理 LR语法" />
<meta property="og:description" content="复习 我们想要通过自底向上文法来进行语法分析，就要使用移入-归约法不断将右串归约成左侧的非终结符最后回到开始字符。在这个过程中，遇到的问题有：何时移入？何时归约？归约时哪部分归约？归约成哪部分？
LR(k)语法 L表示从左往右扫描，R表示反向构造出一个最右推导，k表示向前看k个字符，缺省为1。
一个输入：字符串w；一个输出：分析完成的树；一个栈；一个驱动程序；一个语法分析表。分析表包括Action部分和Goto部分。
每次实现，先将初始状态S0压入栈，将串w$作为输入缓冲区内容。接着调用驱动程序。
LR表结构 两部分构成，一个语法分析动作函数Action，一个转换函数Goto。
1.Action函数
ACTION[i, a]，其中i为状态，a为输入符号 (或者结束符$)，有以下操作：
(1) sj：移入状态j进状态栈，将符号a移入符号栈；
(2) rj：使用第j个产生式A -&gt; β进行归约，将状态栈的 |β| 个状态出栈，并且将新的状态移入栈 (Goto函数求新状态)；将符号栈的 |β| 个符号出栈，将A移入符号栈；
(3) 接受 (acc)；
(4) 报错 (error)；
2.Goto函数
如果GOTO[Ii, A] = Ij, 那么GOTO把状态I和一个非终结符号A映射到状态j。
基于LR分析表的自底向下分析 分析程序如下：
对于下面的文法：
(1)E -&gt; E &#43; T (2) E -&gt; T
(3) T -&gt; T * F (4) T -&gt;F
(5) F -&gt; ( E ) (6) F -&gt; id
给出了LR语法分析表：
执行id * id &#43; id的分析。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4a2ac2ab9b0c6ae0fe1ba1e2989fef5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-19T21:02:19+08:00" />
<meta property="article:modified_time" content="2020-05-19T21:02:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编译原理 LR语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>复习</h3> 
<p>我们想要通过自底向上文法来进行语法分析，就要使用移入-归约法不断将右串归约成左侧的非终结符最后回到开始字符。在这个过程中，遇到的问题有：何时移入？何时归约？归约时哪部分归约？归约成哪部分？</p> 
<h3><a id="LRk_3"></a>LR(k)语法</h3> 
<ul><li> <p>L表示从左往右扫描，R表示反向构造出一个最右推导，k表示向前看k个字符，缺省为1。</p> </li><li> <p>一个输入：字符串w；一个输出：分析完成的树；一个栈；一个驱动程序；一个语法分析表。分析表包括Action部分和Goto部分。</p> </li><li> <p>每次实现，先将初始状态S<sub>0</sub>压入栈，将串w$作为输入缓冲区内容。接着调用驱动程序。</p> </li></ul> 
<h3><a id="LR_11"></a>LR表结构</h3> 
<p>两部分构成，一个语法分析动作函数Action，一个转换函数Goto。</p> 
<p>1.Action函数</p> 
<p>ACTION[i, a]，其中i为状态，a为输入符号 (或者结束符$)，有以下操作：<br> (1) s<sub>j</sub>：移入状态j进状态栈，将符号a移入符号栈；<br> (2) r<sub>j</sub>：使用第j个产生式A -&gt; β进行归约，将状态栈的 |β| 个状态出栈，并且将新的状态移入栈 (Goto函数求新状态)；将符号栈的 |β| 个符号出栈，将A移入符号栈；<br> (3) 接受 (acc)；<br> (4) 报错 (error)；</p> 
<p>2.Goto函数<br> 如果GOTO[I<sub>i</sub>, A] = I<sub>j</sub>, 那么GOTO把状态I和一个非终结符号A映射到状态j。</p> 
<h3><a id="LR_26"></a>基于LR分析表的自底向下分析</h3> 
<p>分析程序如下：<br> <img src="https://images2.imgbox.com/a1/cf/15gLjwKY_o.png" alt="在这里插入图片描述"></p> 
<p>对于下面的文法：<br> (1)E -&gt; E + T (2) E -&gt; T<br> (3) T -&gt; T * F (4) T -&gt;F<br> (5) F -&gt; ( E ) (6) F -&gt; id<br> 给出了LR语法分析表：<br> <img src="https://images2.imgbox.com/5f/f4/311MnEA8_o.png" alt="在这里插入图片描述"><br> 执行id * id + id的分析。</p> 
<p>流程：<br> <img src="https://images2.imgbox.com/3f/8a/JJuYOX0G_o.png" alt="在这里插入图片描述"><br> 1.将初始状态0入栈，输入串加$如缓冲区。<br> 2.每次比较栈顶元素和输入缓冲区第一个字符，查表，s<sub>j</sub>表示移入，并且将状态j入栈。r<sub>j</sub>表示归约，按照表达式j进行归约。然后弹出表达式长度个字符，得到新的栈顶元素t，再查表，将Goto[t,A]的状态入栈。<br> 3.重复以上操作，如果出现查表为空，则转错误处理。如果查表得acc，则成功完成。</p> 
<h3><a id="SLRSLRLR_44"></a>构造SLR分析表（SLR：简单LR技术）</h3> 
<p>1、从文法构造识别可行前缀的DFA<br> 2、从以上DFA构造分析表<br> 在构造表分析表前，先让我们了解一些基本概念。</p> 
<h4><a id="_48"></a>可行前缀</h4> 
<p>定义：一个可行前缀是一个最右句型的前缀，并且它没有越过该最右句型的最右句柄的右端。<br> 举例：S=&gt;*<sub>rm</sub> γAw =&gt;*<sub>rm</sub> γBw ，这里句柄是B，因此可行前缀包括γB的所有前缀（包括空串e和γB本身），但不能是γBw。</p> 
<h4><a id="_51"></a>项</h4> 
<p>定义：文法的一个产生式G加上其右部某一位置的一个点，这个点表示了分析过程中的状态。<br> 举例：产生式A-&gt;XYZ 产生的四个项：<br> A-&gt;·XYZ<br> A-&gt;X·YZ<br> A-&gt;XY·Z<br> A-&gt;XYZ·<br> 以第二个项为例，其表示已经接收了一个可以由X推导的串，如果希望能归约，那么接下来要识别一个能够由YZ推导的串。<br> （A-&gt;空串e 只产生一个项A-&gt;·）</p> 
<h4><a id="_60"></a>增广文法（拓广文法）</h4> 
<p>定义：如果G是一个以S为开始符号的文法, 那么G的拓广文法G’就是在G中加上新开始符号S’和产生式S’ -&gt; S而得到的文法。<br> 简言之，就是给文法添加一条文法：S’-&gt;S，其中S是原文法的开始符号。</p> 
<h4><a id="_64"></a>项集闭包的求法</h4> 
<p>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下面的两个规则从I构造得到的项集:：</p> 
<ol><li>一开始，将I中的各个项加入到CLOSURE(I)中。</li><li>如果A -&gt; α•Bβ在CLOSURE(I)中，B-&gt;γ是一个产生式，并且B-&gt;•γ不在CLOSURE(I)中，就将这个项加入其中。不断应用这个规则，直至没有新项添加。（大概意思就是如果闭包里如果没有希望识别γ的状态，就添加这个状态）</li></ol> 
<p>OK，准备工作完成，接下来开始实例构造。</p> 
<p><em>给定文法<br> • E -&gt; E + T | T<br> • T -&gt; T * F | F<br> • F -&gt; ( E ) | id</em><br> 构造识别可行前缀的DFA。</p> 
<p>1）先改写成增广文法：</p> 
<p><em>• E ’ -&gt; E<br> • E -&gt; E + T | T<br> • T -&gt; T * F | F<br> • F -&gt; ( E ) | id</em></p> 
<p>2）下面求项集的闭包。</p> 
<p><strong>I<sub>0</sub></strong>=CLOSURE({E ’ -&gt; •E})={<!-- --><mark>E ’ -&gt; •E</mark>， E -&gt; •E + T， E -&gt; •T, T -&gt; •T * F, T -&gt; •F, F -&gt; •( E ), F -&gt; •id}<br> //第一条是固定的，都是求增广出的文法的闭包，而文法E ’ -&gt; •E又可以根据项集闭包的求法，推出之后的几条。</p> 
<p><strong>I<sub>1</sub></strong> = GO(I<sub>0</sub>, E) = CLOSURE({E’ -&gt;E•, E -&gt; E• + T}) = {<!-- --><mark>E’ -&gt;E•</mark>, <mark>E -&gt; E• + T</mark>}<br> //第二步，对I<sub>0</sub>中的项，先加入自己，再识别E后产生的新项的闭包。</p> 
<p><strong>I<sub>2</sub></strong> = GO(I<sub>0</sub>, T) = CLOSURE({E -&gt; T•, T -&gt;T•*F}) = {<!-- --><mark>E -&gt; T•</mark>, <mark>T -&gt;T•*F</mark>}</p> 
<p><strong>I<sub>3</sub></strong> = GO(I<sub>0</sub>, F) = CLOSURE({T -&gt; F•}) = {<!-- --><mark>T -&gt; F•</mark>}</p> 
<p><strong>I<sub>4</sub></strong> = GO(I<sub>0</sub>, ( ) = CLOSURE({F -&gt; ( •E )}) = {<!-- --><mark>F -&gt; ( •E )</mark>, E -&gt; •E + T， E -&gt; •T, T -&gt; •T * F, T -&gt; •F, F -&gt; •( E ), F -&gt; •id}<br> //这一步，除了加入自己，又根据闭包的规则加入了很多别的项</p> 
<p><strong>I<sub>5</sub></strong> = GO(I<sub>0</sub>, id) = CLOSURE({F -&gt; id•}) = {<!-- --><mark>F -&gt; id•</mark>}</p> 
<p><mark>GO(I<sub>1</sub>, $) = accept<br> //接收，不另外设状态。</mark></p> 
<p><strong>I<sub>6</sub></strong> = GO(I<sub>1</sub>, +) = CLOSURE({E -&gt; E + •T}) = {<!-- --><mark>E -&gt; E + •T</mark>, T -&gt; •T * F, T -&gt; •F, F -&gt; •( E ), F -&gt; •id}<br> //I<sub>1</sub>的下一个状态求完了</p> 
<p><strong>I<sub>7</sub></strong> = GO(I<sub>2</sub>, *) = CLOSURE({T -&gt;T*•F}) = {<!-- --><mark>T -&gt;T*•F</mark>, F -&gt; •( E ), F -&gt; •id}</p> 
<p><strong>I<sub>8</sub></strong> = GO(I<sub>4</sub>, E) = CLOSURE({F -&gt; ( E•), E -&gt; E •+ T} = {<!-- --><mark>F -&gt; ( E•)</mark>, <mark>E -&gt; E •+ T</mark>}</p> 
<p>（<strong>I<sub>9</sub></strong> = GO(I<sub>4</sub>, T) = CLOSURE({E -&gt; T•, T -&gt; T •* F}与I<sub>2</sub>一致，故不用新设状态。I<sub>9</sub>继续为下面的状态所用。）</p> 
<p><strong>I<sub>9</sub></strong> = GO(I<sub>6</sub>, T) = CLOSURE({E -&gt; E + T•, T -&gt; T •* F}) = {<!-- --><mark>E -&gt; E + T•</mark>, <mark>T -&gt; T •* F</mark>}</p> 
<p><strong>I<sub>10</sub></strong> = GO(I<sub>7</sub>, F) = CLOSURE({T -&gt;T*F•}) = {<!-- --><mark>T -&gt;T*F•</mark>}</p> 
<p><strong>I<sub>11</sub></strong> = GO(I<sub>8</sub>, )) = CLOSURE({F -&gt; ( E)•}) = {<!-- --><mark>F -&gt; ( E)•</mark>}<br> //至此，没有更多新状态生成，并且所有状态都编号了。<br> //GO函数相当于DFA的边，理论上每构造一个新状态I<sub>i</sub>，只要某终结符x存在于它的FOLLOW集中，即下一步有可能会出现，那么必然存在GO(I<sub>i</sub>, x)，这里没有全部列出来只是因为去掉了重复的状态。<br> //所有高亮显示的为核心项，包括初始项E ’ -&gt; •E以及所有•不在最左端的项；除了E’ -&gt; •E之外所有的点在最左端的所有项为非核心项。</p> 
<p>3）画NFA图：<br> <img src="https://images2.imgbox.com/7d/16/14tB0l8L_o.png" alt="在这里插入图片描述"><br> 因为是手工构建，所以可以跳过写闭包的部分直接画图。</p> 
<p>4）构建分析表</p> 
<p>• 使用下面规则构造状态i的goto函数：对所有的非终结符A，如果goto(I<sub>i</sub>, A) = I<sub>j</sub>, 那么goto[i, A] = j。<br> 理解：简要来说，就是根据DFA进行归约。</p> 
<p>• 使用下面的规则构造状态i的action函数：<br> (1)如果A -&gt; α •aβ在I<sub>i</sub>中，并且goto(I<sub>i</sub>, a) = I<sub>j</sub>，那么置action[i, a]为s<sub>j</sub>。<br> (2)如果A -&gt; α•在I<sub>i</sub>中，那么对FOLLOW(A)中的所有a，置action[i, a]为r<sub>j</sub>，j是产生式 A -&gt; a的编号。<br> (3)如果S’ -&gt; S•在I<sub>i</sub>中，那么置action[ i, $ ]为接受acc。<br> (4)不能由上面两步定义的条目都置为error。<br> 理解：先画好表格框架，再对于状态I<sub>i</sub>的许多的项，寻找•右侧带终结符的项，再查图，DFA接收该终结符后转移到的状态I<sub>j</sub>，对应表格就填s<sub>j</sub>。仍然对于这些项，寻找已经接收到了最后一个了（即•在最右端）的项，把这些项的左侧非终结符的FOLLOW集求出来，将里面的元素全标记成要归约的。accept比较简单。FOLLOW集最好一开始就先求一下，具体求法见《编译原理 LL(1)文法》。</p> 
<p><img src="https://images2.imgbox.com/f2/12/4fhISIf0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_141"></a>小结</h3> 
<p>一些值得思考的问题：<br> 1）为什么要对文法G进行拓广?不拓广会怎么样？<br> 拓广后，归约成开始符号一定是接受状态。不拓广，归约成开始符号也不一定是接受状态，有可能是某些文法中间就包括了开始符号。不拓广，可能会在多处出现acc。</p> 
<p>2）为什么称为LR(0)自动机?<br> 0指构造自动机的时候，没有假设下一个输入符号是什么。</p> 
<p>3）为什么称LR(0)自动机为识别文法活前缀 (可行前缀)的DFA?<br> 功能: 从开始状态到接受状态中间的那些符号， 构成一个活前缀。</p> 
<p>4）SLR指什么?<br> 简单的LR语法分析。</p> 
<p>5）SLR(1)文法指什么?<br> 根据分析表，自底向上构造语法分析的时候，只需要看一个lookahead符号 。SLR(1) 简称为SLR。</p> 
<p>6）LR(0)文法和SLR(1)文法的关系？<br> LR(0)文法是SLR(1)文法的子集。LR(0)文法不能解决移进-归约冲突和归约-归约冲突。所以如果存在以上两种冲突，LR(0)文法不能处理。SLR(1)文法能解决归约-归约冲突但不能解决移进-归约冲突，所以预测分析表的一个窗口可能会出现两个入口（移进或归约）。但他们构造预测分析表的流程是一样的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8af22f2b66d04657d36698d0039df4c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">每日一题：判断是否为字符重排（C&#43;&#43;）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/676692f6332236fe9b7c1d96a8d04518/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac 安装.net core sdk后-bash: dotnet: command not found</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>