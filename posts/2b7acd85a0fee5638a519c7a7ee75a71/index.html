<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录算法训练营day57|第九章 动态规划part17 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码随想录算法训练营day57|第九章 动态规划part17" />
<meta property="og:description" content="目录
647. 回文子串 516.最长回文子序列 动态规划总结篇 647. 回文子串 动态规划解决的经典题目，如果没接触过的话，别硬想 直接看题解。
代码随想录
这道题对dp数组的定义就很特别，事实上，对于dp数组的定义一般会和题目所要求的东西有关，但这道题不同，因为不难发现dp[i] 和 dp[i-1] ，dp[i &#43; 1] 看上去都没啥关系。但是仔细考虑会发现一种递推关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于它的子字符串（下表范围[i &#43; 1, j - 1]）） 是否是回文，如果子字符串回文，那只要判定两端的字符是否相等即可。由此也可见，只凭借一维数组是没办法同时反映左端点和右端点两个要素的，故而需要使用二维数组，因为依赖关系是“是否”，所以必然要使用bool类型的dp数组，dp[i][j]表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
递推公式还是依据上面来看还是要先判断两个字符是否相等，因为如果两端的字符不相等，那就一定不能构成回文串，只有相等才能进一步判定；相等，那就判断两端点所涵盖的字符个数，如果只包含一个字符或两个字符，内部根本不可能有别的回文子串，那就直接判定是回文子串，而如果不止，那就要判断dp[i&#43;1][j-1]是否为true，也就是内部是否是回文子串。
这个递推公式需要从左下角来推导当前元素的值，所以必然要正向遍历j，反向便利 i，而且因为 i 代表左端点、j 表示右端点，所以必然要 j&gt;=i ，也就是 j 从 i 开始向后遍历。涉及到初始化的问题，因为没有正式判断之前是不能武断地确认当前子串是回文子串的，所以必然要全部初始化为false。
注意还要用res来捡拾结果。
int countSubstrings(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i &gt;= 0; i--) { // 注意遍历顺序 for (int j = i; j &lt; s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2b7acd85a0fee5638a519c7a7ee75a71/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T00:12:30+08:00" />
<meta property="article:modified_time" content="2024-03-13T00:12:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录算法训练营day57|第九章 动态规划part17</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#647.%C2%A0%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%C2%A0%C2%A0%C2%A0" rel="nofollow">647. 回文子串   </a></p> 
<p style="margin-left:0px;"><a href="#516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%C2%A0" rel="nofollow">516.最长回文子序列 </a></p> 
<p style="margin-left:0px;"><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87%C2%A0" rel="nofollow">动态规划总结篇 </a></p> 
<hr> 
<p> </p> 
<h2><strong>647. 回文子串   </strong></h2> 
<div> 
 <blockquote> 
  <p style="margin-left:0;text-align:left;">动态规划解决的经典题目，如果没接触过的话，别硬想 直接看题解。</p> 
  <p style="margin-left:0;text-align:left;"><a href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html" rel="nofollow" title="代码随想录">代码随想录</a></p> 
 </blockquote> 
 <p style="margin-left:0;text-align:left;">这道题对dp数组的定义就很特别，事实上，对于dp数组的定义一般会和题目所要求的东西有关，但这道题不同，因为不难发现dp[i] 和 dp[i-1] ，dp[i + 1] 看上去都没啥关系。但是仔细考虑会发现一种递推关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于它的子字符串（下表范围[i + 1, j - 1]）） 是否是回文，如果子字符串回文，那只要判定两端的字符是否相等即可。由此也可见，只凭借一维数组是没办法同时反映左端点和右端点两个要素的，故而需要使用二维数组，因为依赖关系是“是否”，所以必然要使用bool类型的dp数组，dp[i][j]表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p> 
 <p style="margin-left:0;text-align:left;">递推公式还是依据上面来看还是要先判断两个字符是否相等，因为如果两端的字符不相等，那就一定不能构成回文串，只有相等才能进一步判定；相等，那就判断两端点所涵盖的字符个数，如果只包含一个字符或两个字符，内部根本不可能有别的回文子串，那就直接判定是回文子串，而如果不止，那就要判断dp[i+1][j-1]是否为true，也就是内部是否是回文子串。</p> 
 <p style="margin-left:0;text-align:left;">这个递推公式需要从左下角来推导当前元素的值，所以必然要正向遍历j，反向便利 i，而且因为 i 代表左端点、j 表示右端点，所以必然要 j&gt;=i ，也就是 j 从 i 开始向后遍历。涉及到初始化的问题，因为没有正式判断之前是不能武断地确认当前子串是回文子串的，所以必然要全部初始化为false。</p> 
 <p style="margin-left:0;text-align:left;">注意还要用res来捡拾结果。</p> 
 <pre><code class="language-cpp">int countSubstrings(string s) {
        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i &gt;= 0; i--) {  // 注意遍历顺序
            for (int j = i; j &lt; s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i &lt;= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }</code></pre> 
 <p style="margin-left:0;text-align:left;">实际上用动态规划来做空间上消耗太大，这道题也可以使用双指针来做。每一个回文子串必然有一个中心点，这个中心点有可能是一个值、有可能两个值（看字符串长度奇偶数），但是从中心点向两端延申必然对应的字符是相等的，注意奇字符串一定和偶字符串不相同，所以要分开考虑。</p> 
 <pre><code class="language-cpp">class Solution {
public:
    int countSubstrings(string s) {
        int res=0;
        for(int i=0;i&lt;s.size();i++){
            res+=extend(s,i,i,s.size());
            res+=extend(s,i,i+1,s.size());
        }
        return res;
    }
    int extend(string&amp; s,int i,int j,int n){
        int res=0;
        while(i&gt;=0&amp;&amp;j&lt;n&amp;&amp;s[i]==s[j]){
            i--;
            j++;
            res++;
        }
        return res;
    }
};</code></pre> 
 <h2 style="margin-left:0pt;text-align:left;"><strong>516.最长回文子序列 </strong></h2> 
 <blockquote> 
  <p style="margin-left:0;text-align:left;"> 647. 回文子串，求的是回文子串，而本题要求的是回文子序列， 大家要搞清楚两者之间的区别。 </p> 
  <p style="margin-left:0;text-align:left;"><a href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html" rel="nofollow" title="代码随想录">代码随想录</a></p> 
 </blockquote> 
 <p style="margin-left:0;text-align:left;">这道题dp数组的含义是字符串s在[i, j]范围内最长的回文子序列的长度。思路和上一题有点像，还是要用 i 作为子字符串的左端点， j 作为子字符串的右端点，但是这回遇到两端字符相等的情况，就直接让dp数组在原来的基础上加2（所谓原来的基础自然是两个指针各往中间缩一格的值），直接加2，是因为已经事先判定好了左右端点所包含的字符一定不小于3个，这就同时要求j从 i+1 处开始遍历，也同时要求dp[ i ][ i ]在初始化的时候就赋值为1；而如果不相等，那就删除左端点的字符或者删除右端点的字符，也就是不同时让两个指针向中心处靠近一格，比较哪种情况的值更大。</p> 
 <p style="margin-left:0;text-align:left;">至于遍历顺序，这道题当前值可以从它的左边、下边和左下角推导出来，所以整体的遍历顺序和上题的一样。初始化时候，考虑当i 和j 相同的情况，由于递推公式：dp[i][j] = dp[i + 1][j - 1] + 2，看出递推公式是计算不到 i 和j相同时候的情况。所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 中<strong>dp[i][j]才不会被初始值覆盖</strong>(次要原因是剩下的值你也确实不知道是几)。</p> 
 <p style="margin-left:0;text-align:left;">虽然文章中的 i 是从s.size()-1开始，但实际上因为 j 从 i + 1开始遍历，所以 i 第1遍循环是不会有任何结果产生的，实际上 i 也可以从s.size()-2开始遍历。除此之外，每次 j 的遍历里面第1次执行dp[i][j] = dp[i + 1][j - 1] + 2，所用的之前的值dp[i + 1][j - 1]实际上为0( j 从 i + 1开始遍历，每次恰好错过初始化这个值)，所以在仅有两个元素的时候，如果这两个元素恰好相等或不相等，都能按照这种递推方式来推导当前值。</p> 
 <p style="margin-left:0;text-align:left;">至于最后收集结果，注意dp数组的含义是字符串s在[i, j]范围内最长的回文子序列的长度，所以最大值必然在[0, s.size()-1]范围内。</p> 
 <pre><code class="language-cpp">int longestPalindromeSubseq(string s) {
        vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));
        for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;
        for (int i = s.size() - 2; i &gt;= 0; i--) {
            for (int j = i + 1; j &lt; s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.size() - 1];
    }</code></pre> 
 <h2 style="margin-left:0pt;text-align:left;"><strong>动态规划总结篇 </strong></h2> 
 <blockquote> 
  <p style="margin-left:0;text-align:left;"><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html" rel="nofollow" title="代码随想录">代码随想录</a></p> 
 </blockquote> 
</div> 
<p>动规五部曲分别为：</p> 
<ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol> 
<p> 动态规划的问题主要有：背包问题系列、打家劫舍系列、股票系列、子序列系列。</p> 
<p><img src="https://images2.imgbox.com/96/a0/dCgCwIJq_o.png" alt="47ed3b3a11af40cea071df302180ef06.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4229f56ec35c0b7627528e12afe990c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hanlp，pyhanlp 实现 NLP 任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cdf8fdc2126e57d2132bcdca8a9e009e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ribbon-负载均衡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>