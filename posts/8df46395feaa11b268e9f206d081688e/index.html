<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔试题汇总（4） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔试题汇总（4）" />
<meta property="og:description" content="已经n 次倒在c 语言面试的问题上，总结了一下，是由于基础知识不扎实。痛定思痛，决定 好好努力！
1.引言 本文的写作目的并不在于提供C/C&#43;&#43;程序员求职面试指导，而旨在从技术上分析面试题 的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。 许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一 个最简单的strcpy 函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一 个strcpy 函数吗？我们都觉得自己能，可是我们写出的strcpy 很可能只能拿到10 分中的2 分。读者可从本文看到strcpy 函数从2 分到10 分解答的例子，看看自己属于什么样的层次。 此外，还有一些面试题考查面试者敏捷的思维能力。 分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的 深入剖析则可进一步增强自身的内功。
2.找错题 试题1： void test1() { char string[10]; char* str1 = &#34;0123456789&#34;; strcpy( string, str1 ); } 试题2： void test2() { char string[10], str1[10]; int i; for(i=0; i＜10; i&#43;&#43;) { str1[i] = &#39;a&#39;; } strcpy( string, str1 ); } 试题3： void test3(char* str1) { char string[10]; if( strlen( str1 ) ＜= 10 ) { strcpy( string, str1 ); } } 解答： 试题1 字符串str1 需要11 个字节才能存放下（包括末尾的’ 0’），而string 只有10 个字 节的空间，strcpy 会导致数组越界； 对试题2，如果面试者指出字符数组str1 不能在数组内结束可以给3 分；如果面试者指 出strcpy(string, str1)调用使得从str1 内存起复制到string 内存起所复制的字节数具有不确定 性可以给7 分，在此基础上指出库函数strcpy 工作方式的给10 分； 对试题3，if(strlen(str1) ＜= 10)应改为if(strlen(str1) ＜ 10)，因为strlen 的结果未统计’ 0’所占用的1 个字节。 剖析： 考查对基本功的掌握： (1)字符串以’ 0’结尾； (2)对数组越界把握的敏感度； (3)库函数strcpy 的工作方式，如果编写一个标准strcpy 函数的总分值为10，下面给出 几个不同得分的答案： 2 分 void strcpy( char *strDest, char *strSrc ) { while( (*strDest&#43;&#43; = * strSrc&#43;&#43;) !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8df46395feaa11b268e9f206d081688e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-10T00:25:00+08:00" />
<meta property="article:modified_time" content="2011-04-10T00:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔试题汇总（4）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <br>已经n 次倒在c 语言面试的问题上，总结了一下，是由于基础知识不扎实。痛定思痛，决定 <br>好好努力！</p> 
<p> <br>1.引言 <br>本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分析面试题 <br>的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。 <br>许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一 <br>个最简单的strcpy 函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一 <br>个strcpy 函数吗？我们都觉得自己能，可是我们写出的strcpy 很可能只能拿到10 分中的2 <br>分。读者可从本文看到strcpy 函数从2 分到10 分解答的例子，看看自己属于什么样的层次。 <br>此外，还有一些面试题考查面试者敏捷的思维能力。 <br>分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的 <br>深入剖析则可进一步增强自身的内功。</p> 
<p> <br>2.找错题 <br>试题1： <br>void test1() <br>{ <br>char string[10]; <br>char* str1 = "0123456789"; <br>strcpy( string, str1 ); <br>} <br>试题2： <br>void test2() <br>{ <br>char string[10], str1[10]; <br>int i; <br>for(i=0; i＜10; i++) <br>{ <br>str1[i] = 'a'; <br>} <br>strcpy( string, str1 ); <br>} <br>试题3： <br>void test3(char* str1) <br>{ <br>char string[10]; <br>if( strlen( str1 ) ＜= 10 ) <br>{ <br>strcpy( string, str1 ); <br>} <br>} <br>解答： <br>试题1 字符串str1 需要11 个字节才能存放下（包括末尾的’ 0’），而string 只有10 个字 <br>节的空间，strcpy 会导致数组越界； <br>对试题2，如果面试者指出字符数组str1 不能在数组内结束可以给3 分；如果面试者指 <br>出strcpy(string, str1)调用使得从str1 内存起复制到string 内存起所复制的字节数具有不确定 <br>性可以给7 分，在此基础上指出库函数strcpy 工作方式的给10 分； <br>对试题3，if(strlen(str1) ＜= 10)应改为if(strlen(str1) ＜ 10)，因为strlen 的结果未统计’ <br>0’所占用的1 个字节。 <br>剖析： <br>考查对基本功的掌握： <br>(1)字符串以’ 0’结尾； <br>(2)对数组越界把握的敏感度； <br>(3)库函数strcpy 的工作方式，如果编写一个标准strcpy 函数的总分值为10，下面给出 <br>几个不同得分的答案： <br>2 分 <br>void strcpy( char *strDest, char *strSrc ) <br>{ <br>while( (*strDest++ = * strSrc++) != ‘ 0’ ); <br>} <br>4 分 <br>void strcpy( char *strDest, const char *strSrc ) <br>//将源字符串加const，表明其为输入参数，加2 分 <br>{ <br>while( (*strDest++ = * strSrc++) != ‘ 0’ ); <br>} <br>7 分 <br>void strcpy(char *strDest, const char *strSrc) <br>{ <br>//对源地址和目的地址加非0 断言，加3 分 <br>assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); <br>while( (*strDest++ = * strSrc++) != ‘ 0’ ); <br>} <br>10 分 <br>//为了实现链式操作，将目的地址返回，加3 分！ <br>char * strcpy( char *strDest, const char *strSrc ) <br>{ <br>assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); <br>char *address = strDest; <br>while( (*strDest++ = * strSrc++) != ‘ 0’ ); <br>return address; <br>} <br>从2 分到10 分的几个答案我们可以清楚的看到，小小的strcpy 竟然暗藏着这么多玄机， <br>真不是盖的！需要多么扎实的基本功才能写一个完美的strcpy 啊！ <br>(4)对strlen 的掌握，它没有包括字符串末尾的' 0'。 <br>读者看了不同分值的strcpy 版本，应该也可以写出一个10 分的strlen 函数了，完美的 <br>版本为： <br>int strlen( const char *str ) //输入参数const <br>{ <br>assert( strt != NULL ); //断言字符串地址非0 <br>int len; <br>while( (*str++) != ' 0' ) <br>{ <br>len++; <br>} <br>return len; <br>} <br>试题4： <br>void GetMemory( char *p ) <br>{ <br>p = (char *) malloc( 100 ); <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>GetMemory( str ); <br>strcpy( str, "hello world" ); <br>printf( str ); <br>} <br>试题5： <br>char *GetMemory( void ) <br>{ <br>char p[] = "hello world"; <br>return p; <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>str = GetMemory(); <br>printf( str ); <br>} <br>试题6： <br>void GetMemory( char **p, int num ) <br>{ <br>*p = (char *) malloc( num ); <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>GetMemory( &amp;str, 100 ); <br>strcpy( str, "hello" ); <br>printf( str ); <br>} <br>试题7： <br>void Test( void ) <br>{ <br>char *str = (char *) malloc( 100 ); <br>strcpy( str, "hello" ); <br>free( str ); <br>... //省略的其它语句 <br>} <br>解答： <br>试题4 传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并 <br>不能真正的改变传入形参的值，执行完 <br>char *str = NULL; <br>GetMemory( str ); <br>后的str 仍然为NULL； <br>试题5 中 <br>char p[] = "hello world"; <br>return p; <br>的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序 <br>员常犯的错误，其根源在于不理解变量的生存期。 <br>试题6 的GetMemory 避免了试题4 的问题，传入GetMemory 的参数为字符串指针的指 <br>针，但是在GetMemory 中执行申请内存及赋值语句 <br>*p = (char *) malloc( num ); <br>后未判断内存是否申请成功，应加上： <br>if ( *p == NULL ) <br>{ <br>...//进行申请内存失败处理 <br>} <br>试题7 存在与试题6 同样的问题，在执行 <br>char *str = (char *) malloc(100); <br>后未进行内存是否申请成功的判断；另外，在free(str)后未置str 为空，导致可能变成一 <br>个“野”指针，应加上： <br>str = NULL; <br>试题6 的Test 函数中也未对malloc 的内存进行释放。 <br>剖析： <br>试题4～7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回 <br>答其中50~60 的错误。但是要完全解答正确，却也绝非易事。 <br>对内存操作的考查主要集中在： <br>（1）指针的理解； <br>（2）变量的生存期及作用范围； <br>（3）良好的动态内存申请和释放习惯。 <br>再看看下面的一段程序有什么错误： <br>swap( int* p1,int* p2 ) <br>{ <br>int *p; <br>*p = *p1; <br>*p1 = *p2; <br>60 <br>*p2 = *p; <br>} <br>在swap 函数中，p 是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++ <br>中DEBUG 运行时提示错误“Access Violation”。该程序应该改为： <br>swap( int* p1,int* p2 ) <br>{ <br>int p; <br>p = *p1; <br>*p1 = *p2; <br>*p2 = p; <br>} <br>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>3.内功题 <br>试题1：分别给出BOOL，int，float，指针变量与“零值”比较的if 语句（假设变量名 <br>为var） <br>解答： <br>BOOL 型变量：if(!var) <br>int 型变量： if(var==0) <br>float 型变量： <br>const float EPSINON = 0.00001; <br>if ((x ＞= - EPSINON) &amp;&amp; (x ＜= EPSINON) <br>指针变量： if(var==NULL) <br>剖析： <br>考查对0 值判断的“内功”，BOOL 型变量的0 判断完全可以写成if(var==0)，而int 型变 <br>量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运 <br>行，但是未能清晰地表达程序的意思。 <br>一般的，如果想让if 判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其 <br>为“逻辑”判断；如果用if 判断一个数值型变量(short、int、long 等)，应该用if(var==0)，表 <br>明是与0 进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程 <br>习惯。 <br>浮点型变量并不精确，所以不可将float 变量用“==”或“！=”与数字比较，应该设法转化 <br>成“＞=”或“＜=”形式。如果写成if (x == 0.0)，则判为错，得0 分。 <br>试题2：以下为Windows NT 下的32 位C++程序，请计算sizeof 的值 <br>void Func ( char str[100] ) <br>{ <br>sizeof( str ) = ? <br>} <br>void *p = malloc( 100 ); <br>sizeof ( p ) = ? <br>解答： <br>sizeof( str ) = 4 <br>sizeof ( p ) = 4 <br>剖析： <br>Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的 <br>内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自 <br>减等操作，可以被修改。 <br>数组名的本质如下： <br>（1）数组名指代一种数据结构，这种数据结构就是数组； <br>例如： <br>char str[10]; <br>cout ＜＜ sizeof(str) ＜＜ endl; <br>输出结果为10，str 指代数据结构char[10]。 <br>（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、 <br>自减等操作，不能被修改； <br>char str[10]; <br>str++; //编译出错，提示str 不是左值 <br>（3）数组名作为函数形参时，沦为普通指针。 <br>Windows NT 32 位平台下，指针的长度（占用内存的大小）为4 字节，故sizeof( str ) 、 <br>sizeof ( p ) 都为4。 <br>试题3：写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写 <br>下面的代码时会发生什么事 <br>least = MIN(*p++, b); <br>解答： <br>#define MIN(A,B) ((A) ＜= (B) ? (A) : (B)) <br>MIN(*p++, b)会产生宏的副作用 <br>剖析： <br>这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是 <br>它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进 <br>行的是一对一的替换。 <br>程序员对宏定义的使用要非常小心，特别要注意两个问题： <br>（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解 <br>答： <br>#define MIN(A,B) (A) ＜= (B) ? (A) : (B) <br>#define MIN(A,B) (A ＜= B ? A : B ) <br>都应判0 分； <br>（2）防止宏的副作用。 <br>宏定义#define MIN(A,B) ((A) ＜= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是： <br>((*p++) ＜= (b) ? (*p++) : (*p++)) <br>这个表达式会产生副作用，指针p 会作三次++自增操作。 <br>除此之外，另一个应该判0 分的解答是： <br>#define MIN(A,B) ((A) ＜= (B) ? (A) : (B)); <br>这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清，只能被无情地判0 <br>分并被面试官淘汰。 <br>试题4：为什么标准头文件都有类似以下的结构？ <br>#ifndef __INCvxWorksh <br>#define __INCvxWorksh <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br>解答： <br>头文件中的编译宏 <br>#ifndef __INCvxWorksh <br>#define __INCvxWorksh <br>#endif <br>的作用是防止被重复引用。 <br>作为一种面向对象的语言，C++支持函数重载，而过程式语言C 则不支持。函数被C++ <br>编译后在symbol 库中的名字与C 语言的不同。例如，假设某个函数的原型为： <br>void foo(int x, int y); <br>该函数被C 编译器编译后在symbol 库中的名字为_foo，而C++编译器则会产生像 <br>_foo_int_int 之类的名字。_foo_int_int 这样的名字包含了函数名和函数参数数量及类型信息， <br>C++就是考这种机制来实现函数重载的。 <br>为了实现C 和C++的混合编程，C++提供了C 连接交换指定符号extern "C"来解决名字 <br>匹配问题，函数声明前加上extern "C"后，则编译器就会按照C 语言的方式将该函数编译为 <br>_foo，这样C 语言中就可以调用C++的函数了。 <br>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>试题5：编写一个函数，作用是把一个char 组成的字符串循环右移n 个。比如原来是 <br>“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” <br>函数头是这样的： <br>//pStr 是指向以' 0'结尾的字符串的指针 <br>//steps 是要求移动的n <br>void LoopMove ( char * pStr, int steps ) <br>{ <br>//请填充... <br>} <br>解答： <br>正确解答1： <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>strcpy ( tmp, pStr + n ); <br>strcpy ( tmp + steps, pStr); <br>*( tmp + strlen ( pStr ) ) = ' 0'; <br>strcpy( pStr, tmp ); <br>} <br>正确解答2： <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>memcpy( tmp, pStr + n, steps ); <br>memcpy(pStr + steps, pStr, n ); <br>memcpy(pStr, tmp, steps ); <br>} <br>剖析： <br>这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大 <br>程度上简化程序编写的工作量。 <br>最频繁被使用的库函数包括： <br>（1） strcpy <br>（2） memcpy <br>（3） memset <br>试题6：已知WAV 文件格式如下表，打开一个WAV 文件，以适当的数据结构组织WAV <br>文件头并解析WAV 格式的各项信息。 <br>WAVE 文件格式说明表 <br>1 ＃i nclude “filename.h”和＃i nclude 的区别? <br>答：对于＃i nclude 编译器从标准库开始搜索filename.h <br>对于＃i nclude “filename.h”编译器从用户工作路径开始搜索filename.h <br>2 头文件的作用是什么? <br>答：一、通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提 <br>供头文件和二进制的库即可。用户只需 <br>要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的 <br>代码。 <br>二、头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致， <br>编译器就会指出错误，这一简单的规 <br>则能大大减轻程序员调试、改错的负担。 <br>3 C++函数中值的传递方式有哪几种? <br>答：C++函数的三种传递方式为：值传递、指针传递和引用传递。 <br>4 内存的分配方式的分配方式有几种? <br>答：一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期 <br>间都存在。例如全局变量。 <br>二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这 <br>些存储单元自动被释放。栈内 <br>存分配运 <br>算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 <br>三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存， <br>程序员自己负责在何时用free <br>或delete 释放 <br>内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。 <br>5 实现双向链表删除一个节点P，在节点P 后插入一个节点，写出这两个函数; <br>答：双向链表删除一个节点P <br>template void list::delnode(int p) <br>{ <br>int k=1; <br>listnode *ptr,*t; <br>ptr=first; <br>while(ptr-&gt;next!=NULL&amp;&amp;k!=p) <br>{ <br>ptr=ptr-&gt;next; <br>k++; <br>} <br>t=ptr-&gt;next; <br>cout&lt;&lt;"你已经将数据项"&lt;&lt;"删除"&lt; <br>ptr-&gt;next=ptr-&gt;next-&gt;next; <br>length--; <br>delete t; <br>} <br>在节点P 后插入一个节点： <br>template bool list::insert(type t,int p) <br>{ <br>listnode *ptr; <br>ptr=first; <br>int k=1; <br>while(ptr!=NULL&amp;&amp;k{ <br>ptr=ptr-&gt;next; <br>k++; <br>} <br>if(ptr==NULL&amp;&amp;k!=p) <br>return false; <br>else <br>{ <br>listnode *tp; <br>tp=new listnode; <br>tp-&gt;data=t; <br>tp-&gt;next=ptr-&gt;next; <br>ptr-&gt;next=tp; <br>length++; <br>return true; <br>} <br>} <br>6 写一个函数，将其中的/t 都转换成4 个空格。 <br>void change(char* pstr) <br>{ <br>while(*pstr++ != '/0') <br>{ <br>if (*pstr == '/t') <br>} <br>} <br>7 Windows 程序的入口是哪里？写出Windows 消息机制的流程. <br>答：Winmain()，它定义窗口界面和消息循环。设置全局资源-&gt;登记实例-&gt;调入全局资源-&gt;初始化 <br>应用-&gt;消息循环(解释消息,分发消息) <br>8 如何定义和实现一个类的成员函数为回调函数？ <br>1). 不使用成员函数，直接使用普通C 函数，为了实现在C 函数中可以访问类的成员变量，可以使 <br>用友元操作符(friend)，在C++中将该C 函数说明为类的友元即可。这种处理机制与普通的C 编程 <br>中使用回调函数一样。 <br>2). 使用静态成员函数，静态成员函数不使用this 指针作为隐含参数，这样就可以作为回调函数了。 <br>9 C++里面是不是所有的动作都是main()引起的？如果不是，请举例. <br>答：在运行c++程序时，通常从main()函数开始执行。因此如果没有main(),程序将不完整，编译 <br>器将指出未定义main()函数。 <br>例外情况：如， 在windows 编程中，可以编写一个动态连接库（dll)模块，这是其他windows 程 <br>序可以使用的代码。由于 <br>DLL 模块不是独立的程序，因此不需要main().用于专用环境的程序--如机器人中的控制器芯片-- <br>可能不需要main().但常规的 <br>独立程序都需要main(). <br>10 C++里面如何声明const void f(void)函数为C 程序中的库函数？ <br>11 下列哪两个是等同的 <br>int b; <br>A const int* a = &amp;b; <br>B const* int a = &amp;b; <br>C const int* const a = &amp;b; <br>D int const* const a = &amp;b; <br>12 内联函数在编译时是否做参数类型检查 <br>13 三个float:a,b,c <br>问值 <br>(a+b)+c==(b+a)+c <br>(a+b)+c==(a+c)+b <br>14 把一个链表反向填空 <br>void reverse(test* head) <br>{ <br>test* pe = head; <br>test* ps = head-&gt;next; <br>while(ps) <br>{ <br>pe-&gt;next = ps-&gt;next; <br>ps-&gt;next = head; <br>head = ps; <br>ps = pe-&gt;next; <br>} <br>} <br>15 设计一个重采样系统，说明如何anti-alias <br>16 某个程序在一个嵌入式系统(200M 的CPU,50M 的SDRAM)中已经最化了，换到另一个系统 <br>(300M 的CPU,50M 的SDRAM)中运行，还需要优化吗？ <br>17. 下面哪种排序法对12354 最快 <br>a quick sort <br>b.buble sort <br>c.merge sort <br>18. 哪种结构，平均来讲，获取一个值最快 <br>a. binary tree <br>b. hash table <br>c. stack <br>19 请问C++的类和C 里面的struct 有什么区别？ <br>答：c++的类的成员默认情况下是私有的,c 的struct 的成员默认情况下是公共的. <br>20 请讲一讲析构函数和虚函数的用法和作用？ <br>答：析构函数的作用是当对象生命期结束时释放对象所占用的资源。析构函数用法：析构函数是特 <br>殊的类成员函数 <br>它的名字和类名相同，没有返回值，没有参数不能随意调用也没有重载。只是在类对象生命期结束时 <br>有系统自动调用。 <br>虚函数用在继承中，当在派生类中需要重新定义基类的函数时需要在基类中将该函数声明为虚函数， <br>作用为使程序支持动态联遍。 <br>21 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？ <br>答：一些变量整个程序中都是可见的，它们称为全局变量，一些变量在函数内部定义且只在函数中可 <br>知，则称为局部变量。 <br>全局变量由编译器建立且存放在内存的全局数据区，局部变量存放在栈区 <br>22 一些寄存器的题目，主要是寻址和内存管理等一些知识。 <br>23 8086 是多少尉的系统？在数据总线上是怎么实现的？ <br>24 多态。overload 和override 的区别。 <br>答：重载在相同范围（同一个类中），函数名字相同，参数不同，virtual 关键字可有可无。 <br>覆盖是指派生类函数覆盖基类函数，不同的范围，函数名字相同，参数相同，基类函数必须有virtual <br>关键字。 <br>&lt;&gt; <br>25．完成下列程序 <br>* <br>*.*. <br>*..*..*.. <br>*...*...*...*... <br>*....*....*....*....*.... <br>*.....*.....*.....*.....*.....*..... <br>*......*......*......*......*......*......*...... <br>*.......*.......*.......*.......*.......*.......*.......*....... <br>＃i nclude <br>using namespace std; <br>const int n = 8; <br>main() <br>{ <br>int i; <br>int j; <br>int k; <br>for(i = n; i &gt;= 1; i--) <br>{ <br>for(j = 0; j &lt; n-i+1; j++) <br>{ <br>cout&lt;&lt;"*"; <br>for(k=1; k &lt; n-i+1; k++) <br>{ <br>cout&lt;&lt;"."; <br>} <br>} <br>cout&lt; } <br>system("pause"); <br>} <br>26 完成程序，实现对数组的降序排序 <br>＃i nclude <br>using namespace std; <br>void sort(int* arr, int n); <br>int main() <br>{ <br>int array[]={45,56,76,234,1,34,23,2,3}; <br>sort(array, 9); <br>for(int i = 0; i &lt;= 8; i++)//曾经在这儿出界 <br>cout&lt;} <br>void sort(int* arr, int n) <br>{ <br>int temp; <br>for(int i = 1; i &lt; 9; i++) <br>{ <br>for(int k = 0; k &lt; 9 - i; k++)//曾经在这儿出界 <br>{ <br>if(arr[k] &lt; arr[k + 1]) <br>{ <br>temp = arr[k]; <br>arr[k] = arr[k + 1]; <br>arr[k + 1] = temp; <br>} <br>} <br>} <br>} <br>27 费波那其数列，1，1，2，3，5……编写程序求第十项。可以用递归，也可以用其他方法，但要 <br>说明你选择的理由。 <br>非递归 <br>＃i nclude <br>using namespace std; <br>int Pheponatch(int n); <br>main() <br>{ <br>int Ph = Pheponatch(10); <br>cout&lt; system("pause"); <br>} <br>int Pheponatch(int n) <br>{ <br>int elem; <br>int n1 = 1; <br>int n2 = 1; <br>if(n == 1 || n ==2) <br>return 1; <br>else <br>{ <br>for(int i = 3; i &lt;= n; i++) <br>{ <br>elem = n1 + n2; <br>n1 = n2; <br>n2 = elem; <br>} <br>return elem; <br>} <br>} <br>递归 <br>＃i nclude <br>using namespace std; <br>int Pheponatch(int n); <br>main() <br>{ <br>int n; <br>cin&gt;&gt;n; <br>int ph = Pheponatch(n); <br>cout&lt; system("pause"); <br>} <br>int Pheponatch(int n) <br>{ <br>if(n &lt;= 0) <br>exit(-1); <br>else <br>if(n == 1 || n ==2) <br>return 1; <br>else <br>return Pheponatch(n - 1) + Pheponatch(n - 2); <br>} <br>28 下列程序运行时会崩溃，请找出错误并改正，并且说明原因。 <br>＃i nclude <br>＃i nclude <br>typedef struct{ <br>TNode* left; <br>TNode* right; <br>int value; <br>} TNode; <br>TNode* root=NULL; <br>void append(int N); <br>int main() <br>{ <br>append(63); <br>append(45); <br>append(32); <br>append(77); <br>append(96); <br>append(21); <br>append(17); // Again, 数字任意给出 <br>} <br>void append(int N) <br>{ <br>TNode* NewNode=(TNode *)malloc(sizeof(TNode)); <br>NewNode-&gt;value=N; <br>if(root==NULL) <br>{ <br>root=NewNode; <br>return; <br>} <br>else <br>{ <br>TNode* temp; <br>temp=root; <br>while((N&gt;=temp.value &amp;&amp; temp.left!=NULL) || (N <br>)) <br>{ <br>while(N&gt;=temp.value &amp;&amp; temp.left!=NULL) <br>temp=temp.left; <br>while(N <br>temp=temp.right; <br>} <br>if(N&gt;=temp.value) <br>temp.left=NewNode; <br>else <br>temp.right=NewNode; <br>return; <br>} <br>} <br>29. A class B network on the internet has a subnet mask of 255.255.240.0, what is the <br>maximum number of hosts per subnet . <br>a. 240 b. 255 c. 4094 d. 65534 <br>30. What is the difference: between o(log n) and o(log n^2), where both logarithems <br>have base 2 . <br>a. o(log n^2) is bigger b. o(log n) is bigger <br>c. no difference <br>31. For a class what would happen if we call a class’s constructor from with the same <br>class’s constructor . <br>a. compilation error b. linking error <br>c. stack overflow d. none of the above <br>32. “new” in c++ is a: . <br>a. library function like malloc in c <br>b. key word c. operator <br>d. none of the above <br>33. Which of the following information is not contained in an inode . <br>a. file owner b. file size <br>c. file name d. disk address <br>34. What’s the number of comparisons in the worst case to merge two sorted lists <br>containing n elements each . <br>a. 2n b.2n-1 c.2n+1 d.2n-2 <br>35. Time complexity of n algorithm T(n), where n is the input size ,is T(n)=T(n-1)+1/n <br>if n&gt;1 otherwise 1 the order of <br>this algorithm is . <br>a. log (n) b. n c. n^2 d. n^n <br>36. The number of 1’s in the binary representation of 3*4096+ 15*256+5*16+3 are . <br>a. 8 b. 9 c. 10 d. 12 <br>37．设计函数int atoi(char *s)。 <br>38．int i=(j=4,k=8,l=16,m=32); printf(“%d”, i); 输出是多少？ <br>39．解释局部变量、全局变量和静态变量的含义。 <br>40．解释堆和栈的区别。 <br>栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似 <br>于数据结构中的栈。 <br>堆:一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS 回收。注意它与数据结构中 <br>的堆是两回事，分配方式倒是类似于 <br>链表. <br>41．论述含参数的宏与函数的优缺点。 <br>42. 以下三条输出语句分别输出什么？[C 易] <br>char str1[] = "abc"; <br>char str2[] = "abc"; <br>const char str3[] = "abc"; <br>const char str4[] = "abc"; <br>const char* str5 = "abc"; <br>const char* str6 = "abc"; <br>cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; // 输出什么？ <br>cout &lt;&lt; boolalpha &lt;&lt; ( str3==str4 ) &lt;&lt; endl; // 输出什么？ <br>cout &lt;&lt; boolalpha &lt;&lt; ( str5==str6 ) &lt;&lt; endl; // 输出什么？ <br>43. 非C++内建型别A 和B，在哪几种情况下B 能隐式转化为A？[C++中等] <br>答： <br>a. class B : public A { ……} // B 公有继承自A，可以是间接继承的 <br>b. class B { operator A( ); } // B 实现了隐式转化为A 的转化 <br>c. class A { A( const B&amp; ); } // A 实现了non-explicit 的参数为B（可以有其他带默认值的参数） <br>构造函数 <br>d. A&amp; operator= ( const A&amp; ); // 赋值操作，虽不是正宗的隐式类型转换，但也可以勉强算一个 <br>44. 以下代码中的两个sizeof 用法有问题吗？[C 易] <br>void UpperCase( char str[] ) // 将str 中的小写字母转换成大写字母 <br>{ <br>for( size_t i=0; i if( 'a'&lt;=str[i] &amp;&amp; str[i]&lt;='z' ) <br>str[i] -= ('a'-'A' ); <br>} <br>char str[] = "aBcDe"; <br>cout &lt;&lt; "str 字符长度为: " &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl; <br>UpperCase( str ); <br>cout &lt;&lt; str &lt;&lt; endl; <br>45. 以下代码有什么问题？[C 难] <br>void char2Hex( char c ) // 将字符以16 进制表示 <br>{ <br>char ch = c/0x10 + '0'; if( ch &gt; '9' ) ch += ('A'-'9'-1); <br>char cl = c%0x10 + '0'; if( cl &gt; '9' ) cl += ('A'-'9'-1); <br>cout &lt;&lt; ch &lt;&lt; cl &lt;&lt; ' '; <br>} <br>char str[] = "I love 中国"; <br>for( size_t i=0; i char2Hex( str[i] ); <br>cout &lt;&lt; endl; <br>46. 以下代码有什么问题？[C++易] <br>struct Test <br>{ <br>Test( int ) {} <br>Test() {} <br>void fun() {} <br>}; <br>void main( void ) <br>{ <br>Test a(1); <br>a.fun(); <br>Test b(); <br>b.fun(); <br>} <br>*** Test b();//定义了一个函数 <br>47. 以下代码有什么问题？[C++易] <br>cout &lt;&lt; (true?1:"1") &lt;&lt; endl; <br>8. 以下代码能够编译通过吗，为什么？[C++易] <br>unsigned int const size1 = 2; <br>char str1[ size1 ]; <br>unsigned int temp = 0; <br>cin &gt;&gt; temp; <br>unsigned int const size2 = temp; <br>char str2[ size2 ]; <br>48. 以下代码中的输出语句输出0 吗，为什么？[C++易] <br>struct CLS <br>{ <br>int m_i; <br>CLS( int i ) : m_i(i) {} <br>CLS() <br>{ <br>CLS(0); <br>} <br>}; <br>CLS obj; <br>cout &lt;&lt; obj.m_i &lt;&lt; endl; <br>49. C++中的空类，默认产生哪些类成员函数？[C++易] <br>答： <br>class Empty <br>{ <br>public: <br>Empty(); // 缺省构造函数 <br>Empty( const Empty&amp; ); // 拷贝构造函数 <br>~Empty(); // 析构函数 <br>Empty&amp; operator=( const Empty&amp; ); // 赋值运算符 <br>Empty* operator&amp;(); // 取址运算符 <br>const Empty* operator&amp;() const; // 取址运算符const <br>}; <br>50. 以下两条输出语句分别输出什么？[C++难] <br>float a = 1.0f; <br>cout &lt;&lt; (int)a &lt;&lt; endl; <br>cout &lt;&lt; (int&amp;)a &lt;&lt; endl; <br>cout &lt;&lt; boolalpha &lt;&lt; ( (int)a == (int&amp;)a ) &lt;&lt; endl; // 输出什么？ <br>float b = 0.0f; <br>cout &lt;&lt; (int)b &lt;&lt; endl; <br>cout &lt;&lt; (int&amp;)b &lt;&lt; endl; <br>cout &lt;&lt; boolalpha &lt;&lt; ( (int)b == (int&amp;)b ) &lt;&lt; endl; // 输出什么？ <br>51. 以下反向遍历array 数组的方法有什么错误？[STL 易] <br>vector array; <br>array.push_back( 1 ); <br>array.push_back( 2 ); <br>array.push_back( 3 ); <br>for( vector::size_type i=array.size()-1; i&gt;=0; --i ) // 反向遍历array 数组 <br>{ <br>cout &lt;&lt; array[i] &lt;&lt; endl; <br>} <br>52. 以下代码有什么问题？[STL 易] <br>typedef vector IntArray; <br>IntArray array; <br>array.push_back( 1 ); <br>array.push_back( 2 ); <br>array.push_back( 2 ); <br>array.push_back( 3 ); <br>// 删除array 数组中所有的2 <br>for( IntArray::iterator itor=array.begin(); itor!=array.end(); ++itor ) <br>{ <br>if( 2 == *itor ) array.erase( itor ); <br>} <br>53. 写一个函数，完成内存之间的拷贝。[考虑问题是否全面] <br>答： <br>void* mymemcpy( void *dest, const void *src, size_t count ) <br>{ <br>char* pdest = static_cast( dest ); <br>const char* psrc = static_cast( src ); <br>if( pdest&gt;psrc &amp;&amp; pdest { <br>for( size_t i=count-1; i!=-1; --i ) <br>pdest[i] = psrc[i]; <br>} <br>else <br>{ <br>for( size_t i=0; i pdest[i] = psrc[i]; <br>} <br>return dest; <br>} <br>int main( void ) <br>{ <br>char str[] = "0123456789"; <br>mymemcpy( str+1, str+0, 9 ); <br>cout &lt;&lt; str &lt;&lt; endl; <br>system( "Pause" ); <br>return 0; <br>} <br>54 线程与进程的区别 <br>进程：（在批处理系统中）是资源分配的最小单位 <br>线程：最独立运行的最小单位。 <br>一个进程中可以一个或多个线程。当系统的资源分配给进程，线程从所属的进程中得到保证能运行的 <br>很少的资源，线程完成后把资源“还”给进程，只有当进程中的线程全都完成后，进程才把占有的系统 <br>的资源释放（进程挂起除外）。 <br>Top <br>55：请你分别划划OSI 的七层网络结构图，和TCP/IP 的五层结构图？ <br>56：请你详细的解释一下IP 协议的定义，在哪个层上面，主要有什么作用？ TCP 与UDP 呢？ <br>IP 协议是网络层的协议，它实现了Internet 中自动路由的功能，即寻径的功能，TCP 协议是一个传 <br>输性的协议它向下屏蔽了IP 协议不可靠传输的特性，向上提供一个可靠的点到点的传输，UDP 提供 <br>的是一种无连接的服务,主要考虑到很多应用不需要可靠的连接，但需要快速的传输 <br>57：请问交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？ <br>交换机用在局域网中，交换机通过纪录局域网内各节点机器的MAC 地质(物理地址)就可以实现传递 <br>报文,无需看报文中的IP 地质。路由器识别不同网络的方法是通过识别不同网络的网络ID 号(IP 地 <br>址的高端部分)进行的，所以为了保证路由成功，每个网络都必须有一个唯一的网络编号。路由器通 <br>过察看报文中IP 地址，来决定路径，向那个子网(下一跳)路由，也就是说交换机工作在数据链路层 <br>看MAC 地址，路由器工作在网际层看IP 地质 <br>但是由于现在网络设备的发展，很多设备既有交换机的功能有由路由器的功能(交换试路由器)使得两 <br>者界限越来越模糊。 <br>58:请问C++的类和C 里面的struct 有什么区别？ <br>59:请讲一讲析构函数和虚函数的用法和作用？ <br>60:全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？ <br>全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束(在程序结束 <br>时所占内存释放)，而局部变量存在于模块(子程序，函数)中，只有所在模块可以访问，其他模块不 <br>可直接访问，模块结束(函数调用完毕)，局部变量消失，所占据的内存释放。 <br>全局变量分配在全局数据段并且在程序开始运行的时候被加载. 局部变量则分配在堆栈里面。 <br>61:一些寄存器的题目，主要是寻址和内存管理等一些知识。 <br>2、交换机用在局域网中，交换机通过纪录局域网内各节点机器的MAC 地质(物理地址)就可以实现 <br>传递报文,无需看报文中的IP 地质。路由器识别不同网络的方法是通过识别不同网络的网络ID 号(IP <br>地址的高端部分)进行的，所以为了保证路由成功，每个网络都必须有一个唯一的网络编号。路由器 <br>通过察看报文中IP 地址，来决定路径，向那个子网(下一跳)路由，也就是说交换机工作在数据链路 <br>层看MAC 地址，路由器工作在网际层看IP 地质 <br>但是由于现在网络设备的发展，很多设备既有交换机的功能有由路由器的功能(交换试路由器)使得两 <br>者界限越来越模糊。 <br>3、IP 协议是网络层的协议，它实现了Internet 中自动路由的功能，即寻径的功能，TCP 协议是一 <br>个传输性的协议它向下屏蔽了IP 协议不可靠传输的特性，向上提供一个可靠的点到点的传输，UDP <br>提供的是一种无连接的服务,主要考虑到很多应用不需要可靠的连接，但需要快速的传输 <br>4、 <br>Test b();//定义了一个函数 <br>62:8086 是多少位的系统？在数据总线上是怎么实现的？ <br>&lt;&gt; <br>63.怎样用最快的方法判断链表是否有环? <br>64.c++中引用和指针有什么不同?指针加上什么限制等于引用? <br>答：1 引用被创建的时候必须被初始化，而指针不是必需的。2 引用在创建后就不能改变引用的关 <br>系，而指针在初始化后可以随时指向 <br>其它的变量或对象。3 没有NULL 引用,引用必须与合法的存储单元关联，而指针可以是NULL。 <br>65.做的项目,遇到的困难,怎样解决? <br>69.操作符重载 <br>class CMyObject:pulic CObject <br>{ <br>Public: <br>CMyObject(); <br>CMyObject &amp;operator=(const CMyObject &amp;my); <br>private: <br>CString strName; <br>int nId: <br>}; <br>请重载赋值操作符 <br>70.链表 <br>Struct structList <br>{ <br>int value; <br>structList *pHead; <br>} <br>Struct LinkedList *pMyList; <br>请编写删除链表的头、尾和第n 个节点的程序 <br>71.用Socket API 制作一个聊天程序，通讯协议使用tcp/ip。要求有简单界面即可，支持多人聊天。 <br>72.如果有过工作经验，请说明在先前公司的工作以及离职原因（如无，请说明毕业后的个人展望） <br>******************************************************************** <br>******* <br>73 对于C++中类(class) 与结构(struct)的描述正确的为: <br>A,类中的成员默认是private 的,当是可以声明为public,private 和protected,结构中定义的成员 <br>默认的都是public; <br>B,结构中不允许定义成员函数,当是类中可以定义成员函数; <br>C,结构实例使用malloc() 动态创建,类对象使用new 操作符动态分配内存; <br>D,结构和类对象都必须使用new 创建; <br>E,结构中不可以定义虚函数,当是类中可以定义虚函数. <br>F,结构不可以存在继承关系,当是类可以存在继承关系. <br>答:A,D,F <br>74,两个互相独立的类:ClassA 和ClassB,都各自定义了非静态的公有成员函数PublicFunc() 和 <br>非静态的私有成员函数PrivateFunc(); <br>现在要在ClassA 中增加定义一个成员函数ClassA::AdditionalPunction(ClassA a,ClassB b); <br>则可以在AdditionalPunction(ClassA x,ClassB y)的实现部分(函数功能体内部) <br>出现的合法的表达是最全的是: <br>A,x.PrivateFunc();x.PublicFunc();y.PrivateFunc();y.PublicFunc(); <br>B,x.PrivateFunc();x.PublicFunc();y.PublicFunc(); <br>C,x.PrivateFunc();y.PrivateFunc();y.PublicFunc(); <br>D,x.PublicFunc();y.PublicFunc(); <br>答:B <br>75,C++程序下列说法正确的有: <br>A,对调用的虚函数和模板类都进行迟后编译. <br>B,基类与子类中函数如果要构成虚函数,除了要求在基类中用virtual 声名,而且必须名字相同且参数 <br>类型相同返回类型相同 <br>C,重载的类成员函数都必须要:或者返回类型不同,或者参数数目不同,或者参数序列的类型不同. <br>D,静态成员函数和内联函数不能是虚函数,友员函数和构造函数也不能是虚函数,但是析构函数可以 <br>是虚函数. <br>答:A <br>******************************************************************** <br>******* <br>76,C++中的类与结构的区别? <br>77,构造函数和析构函数是否可以被重载,为什么? <br>答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构 <br>函数只能有一个，且不能带参数。 <br>78,一个类的构造函数和析构函数什么时候被调用,是否需要手工调用? <br>答：构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用。 <br>1 ＃i nclude “filename.h”和＃i nclude 的区别? <br>答：＃i nclude “filename.h”表明该文件是用户提供的头文件，查找该文件时从当前文件目录开始； <br>＃i nclude 表明这个文件是一个工程或标准头文件，查找过程会检查预定义的目录。 <br>2 头文件的作用是什么? <br>答：一、通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提 <br>供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎 <br>么实现的。编译器会从库中提取相应的代码。 <br>二、头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致， <br>编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。 <br>3 C++函数中值的传递方式有哪几种? <br>答：C++函数的三种传递方式为：值传递、指针传递和引用传递。 <br>4 内存的分配方式的分配方式有几种? <br>答：一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期 <br>间都存在。例如全局变量。 <br>二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这 <br>些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量 <br>有限。 <br>三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存， <br>程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由我们决定，使用非常灵活， <br>但问题也最多。 <br>5 实现双向链表删除一个节点P，在节点P 后插入一个节点，写出这两个函数; <br>答：双向链表删除一个节点P <br>template void list::delnode(int p) <br>{ <br>int k=1; <br>listnode *ptr,*t; <br>ptr=first; <br>while(ptr-&gt;next!=NULL&amp;&amp;k!=p) <br>{ <br>ptr=ptr-&gt;next; <br>k++; <br>} <br>t=ptr-&gt;next; <br>cout&lt;&lt;"你已经将数据项"&lt;&lt;"删除"&lt; <br>ptr-&gt;next=ptr-&gt;next-&gt;next; <br>length--; <br>delete t; <br>} <br>在节点P 后插入一个节点： <br>template bool list::insert(type t,int p) <br>{ <br>listnode *ptr; <br>ptr=first; <br>int k=1; <br>while(ptr!=NULL&amp;&amp;k{ <br>ptr=ptr-&gt;next; <br>k++; <br>} <br>if(ptr==NULL&amp;&amp;k!=p) <br>return false; <br>else <br>{ <br>listnode *tp; <br>tp=new listnode; <br>tp-&gt;data=t; <br>tp-&gt;next=ptr-&gt;next; <br>ptr-&gt;next=tp; <br>length++; <br>return true; <br>} <br>} </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec028150d122ea469226eb02caaa25de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;string</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc035a62b458c5a80ae5f0f1730ab5a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（5）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>