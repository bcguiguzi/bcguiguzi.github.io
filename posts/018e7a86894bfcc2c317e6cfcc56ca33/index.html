<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一个AI产品（数据挖掘）的产生过程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一个AI产品（数据挖掘）的产生过程" />
<meta property="og:description" content="模型的训练一般包括以下步骤：
1：数据的输入： 一般使用pandas库，他有几种常用的读入不同文件类型的函数：
一般我使用read_csv(File_Path,[params]);（对应的文件类型为csv文件，这是数据挖掘中的常用文件格式）
2:数据的预处理： 1）：缺失值的处理： 使用方法可以用pandas下的imputing这个方法
但是其实自己根据实际问题（结合业务来进行填充可能要更好一些，如一些特征，本身他的缺失可能就意味着某种信息，如房屋数据里面的泳池，普通家庭可能是没有泳池的，如果该字段缺失可能说明该栋房屋本身就没有泳池）
上面的是本身缺失有意义的情况下：
那么在没有意义的情况下，我们又想此条数据保留下来，我们又改如何填充呢：
最好的方式就是根据不同的类别算出一个平均值或者众数，中位数，来进行填充，
具体该用什么值进行填充是需要进行实际测试的 ，这也就是数据挖掘过程中复杂的地方，但是这只是过程的复杂，并不是逻辑的复杂，
关于问题建模和优化问题的复杂，处理过程的多样性的复杂，你至少通过时间的积累，慢慢的总结出那种数据的处理方式带来更好的效果；（这也就是目前AI方向调包侠存在的价值所在，因为这一部分跟业务有特别紧密的联系，具体到了更加实际的问题）
至于后面的模型的选择和优化问题，那是正真更加高级的东西；本人还没有这方面的能力，鄙人目前也是调包调参侠一名；对别人的算法原理有一定的了解，知道什么问题该用什么问题，至于在再别人的模型的基础上优化出更加好的模型，还需要努力，
说一下模型的优化问题，就拿rnn来举例把，对于序列化的问题，一开始人是懵逼的，不知道怎么做，但是这时候大牛出现了，实现了一个rnn的算法来解决像时间这种序列化的问题；但是随着使用，rnn的问题又暴露了出来，对于很久之前的序列，rnn无法记住，没有记忆功能，如NLP（自然语言处理）中的一个问题：
eg: 今天上午有英语课，所以我应该带_____书；
很明显答案是英语书，如果用传统的rnn模型，由于没有记忆功能，训练得到我们答案的正确率不搞，好了，那这个时候我们该怎么办呢：
好了大牛又出现了，发明了一个LSTM(Long short term memory)模型，加入了门逻辑单元，有效的解决了对于之前内容的遗忘问题；
2）：数据的归一化（标准化）问题 数据归一化问题在特征区间差别太大时需要处理的问题；如房屋的价格特征：他的值可能最大能达到好几百万的程度，但是房屋的另外一个特征房价数可能只有几个，这时候就出现了数据值相差太大的问题：
我在用tensorflow做回归任务的时候遇到过，归一化和不归一化的相差结果确实有一定的差距；
但是看过一篇博客说，基于平方损失的最小二乘法不需要进行归一化，但是对于大多数的数值型的回归预测，基本使用的损失函数都是最小二乘法，
如果你拿不准，那就都试试之后看哪个效果更好一些；再进行选择；（毕竟这东西有点玄学，更偏向于实践，数据挖掘过程就是不断把假设进行测试的过程）
下面是关于一个关于需要进行归一化算法的总结：
数据需要归一化的机器学习算法
需要归一化的模型：
有些模型在各个维度进行不均匀伸缩后，最优解与原来不等价，例如SVM（距离分界面远的也拉近了，支持向量变多？）。对于这样的模型，除非本来各维数据的分布范围就比较接近，否则必须进行标准化，以免模型参数被分布范围较大或较小的数据dominate。
有些模型在各个维度进行不均匀伸缩后，最优解与原来等价，例如logistic regression（因为θ的大小本来就自学习出不同的feature的重要性吧？）。对于这样的模型，是否标准化理论上不会改变最优解。但是，由于实际求解往往使用迭代算法，如果目标函数的形状太“扁”，迭代算法可能收敛得很慢甚至不收敛。所以对于具有伸缩不变性的模型，最好也进行数据标准化。
有些模型/优化方法的效果会强烈地依赖于特征是否归一化，如LogisticReg，SVM，NeuralNetwork，SGD等。
不需要归一化的模型：
（0/1取值的特征通常不需要归一化，归一化会破坏它的稀疏性。）
有些模型则不受归一化影响，如DecisionTree。
ICA好像不需要归一化（因为独立成分如果归一化了就不独立了？）。
基于平方损失的最小二乘法OLS不需要归一化。
原文：https://blog.csdn.net/pipisorry/article/details/52247379 关于特征的归一化和标准化，pandas里面都有相应的库，再pandas.preprocess里面；
3）:最重要的一点就是关于异常值的检测了 异常值的检测关乎数据的质量问题，我觉得是最重要也是最难的问题的，因为一批数据的异常值往往很难定义，一条数据根据不同的判别方法，也可能表现出不同的效果，而且目前的异常值检测算法大多数对于阈值的确定需要自己的判断：（如基于距离的，基于密度的等）
下面说一下有哪些异常值的检测算法：
1）iforest：这是我比较推荐的一种异常值检测算法：因为它不需要你人为的设置一个阈值，在实际的测试效果也不错；
2）：基于距离的：KNN算法
3）：基于简单统计量的，如3σ原则，分位点原则等等；
3：特征工程部分 可以说特征工程是决定一个训练好模型好坏的决定性步骤，数据决定了你模型的上线，而模型算法只是逼近这个上线，有时你提炼出了一个关键特征之后，可能你的精度会有很大的提升：
1）：特征转换：常用的有log(np.log)变换（可以让特征更normal）对于数值类型的回归模型，如果越符合正太分布的标准，那么模型的精度就会越高；还有box-cox(scipy.state)
2）：离散特征（one_hot编码，label编码，）
3）：连续特征：离散化操作：分箱（bin）（有等频，和等距）
4）：对于一些原始看起来并没有用的特征，如日期：你可能需要通过特征衍生的方式将它转换成有用的特征，如：距离某一个具有重大时间点的天数这个特征；
5：特征组合：
1）如：经纬度特征，他俩组合起来就可以唯一确定一个点（也就是精确位置了）
2）：离散性之间：不同类别之间相互组合
3）连续型的变量之间：加减乘除等；
其实对于一些高级的框架，如tensorflow，他已经将这些方法封装起来了，详情的使用方法见：
https://mp.csdn.net/postedit/80933921
做完这些数据的处理之后，是的，我个人觉得这些其实都属于数据的处理；只是特征工程显得更加重要和复杂，更具有研究型，所以从数据数据处理中提出来，当成了一个单个的过程；
4：算法的选择 算法的选择情况有很多种情况：
1：根据实际的问题可以分为回归，分类，聚类前两者属于监督学习，聚类问题属于无监督的学习；
2：更具算法来分：可以分为机器学习和深度学习：
3：然后根据每一个算法适用领域又还可以分；；比如CNN多用于图像问题；RNN多用于语音识别问题等
5：参数的调节和bagging思想 由于这些方法有很多的超参数，所以你需要通过调参的方式对你的模型进行调整；对于机器学习而言，GridSearch（网格搜索是一个不错的选择，但是不是说把参数全部放进去就可以了，你需要针对不同算法的特点，对参数进行分组调参，这里以xgboost来举例子：如决策树中有两个参数是depth和 min_child_weight(树的深度和树的深度，最小孩子权重）这些都是决定树特性的，还有一些其他的参数；分开调节可以节约计算量，参数过多，如果全都一起调节，可能爬不动；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/018e7a86894bfcc2c317e6cfcc56ca33/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-22T14:36:51+08:00" />
<meta property="article:modified_time" content="2018-10-22T14:36:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一个AI产品（数据挖掘）的产生过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>模型的训练一般包括以下步骤：</p> 
<h3>1：数据的输入：</h3> 
<p>一般使用pandas库，他有几种常用的读入不同文件类型的函数：</p> 
<p>一般我使用read_csv(File_Path,[params]);（对应的文件类型为csv文件，这是数据挖掘中的常用文件格式）</p> 
<h3>2:数据的预处理：</h3> 
<h4>1）：缺失值的处理：</h4> 
<p>使用方法可以用pandas下的imputing这个方法</p> 
<p>但是其实自己根据实际问题（结合业务来进行填充可能要更好一些，如一些特征，本身他的缺失可能就意味着某种信息，如房屋数据里面的泳池，普通家庭可能是没有泳池的，如果该字段缺失可能说明该栋房屋本身就没有泳池）</p> 
<p>上面的是本身缺失有意义的情况下：</p> 
<p>那么在没有意义的情况下，我们又想此条数据保留下来，我们又改如何填充呢：</p> 
<p>最好的方式就是根据不同的类别算出一个平均值或者众数，中位数，来进行填充，</p> 
<p>具体该用什么值进行填充是需要进行实际测试的 ，这也就是数据挖掘过程中复杂的地方，但是这只是过程的复杂，并不是逻辑的复杂，</p> 
<p>关于问题建模和优化问题的复杂，处理过程的多样性的复杂，你至少通过时间的积累，慢慢的总结出那种数据的处理方式带来更好的效果；（这也就是目前AI方向调包侠存在的价值所在，因为这一部分跟业务有特别紧密的联系，具体到了更加实际的问题）</p> 
<p>至于后面的模型的选择和优化问题，那是正真更加高级的东西；本人还没有这方面的能力，鄙人目前也是调包调参侠一名；对别人的算法原理有一定的了解，知道什么问题该用什么问题，至于在再别人的模型的基础上优化出更加好的模型，还需要努力，</p> 
<p>说一下模型的优化问题，就拿rnn来举例把，对于序列化的问题，一开始人是懵逼的，不知道怎么做，但是这时候大牛出现了，实现了一个rnn的算法来解决像时间这种序列化的问题；但是随着使用，rnn的问题又暴露了出来，对于很久之前的序列，rnn无法记住，没有记忆功能，如NLP（自然语言处理）中的一个问题：</p> 
<p>           eg: 今天上午有英语课，所以我应该带_____书；</p> 
<p>很明显答案是英语书，如果用传统的rnn模型，由于没有记忆功能，训练得到我们答案的正确率不搞，好了，那这个时候我们该怎么办呢：</p> 
<p>好了大牛又出现了，发明了一个LSTM(Long short term memory)模型，加入了门逻辑单元，有效的解决了对于之前内容的遗忘问题；</p> 
<h4>2）：数据的归一化（标准化）问题</h4> 
<p>数据归一化问题在特征区间差别太大时需要处理的问题；如房屋的价格特征：他的值可能最大能达到好几百万的程度，但是房屋的另外一个特征房价数可能只有几个，这时候就出现了数据值相差太大的问题：</p> 
<p>我在用tensorflow做回归任务的时候遇到过，归一化和不归一化的相差结果确实有一定的差距；</p> 
<p>但是看过一篇博客说，基于平方损失的最小二乘法不需要进行归一化，但是对于大多数的数值型的回归预测，基本使用的损失函数都是最小二乘法，</p> 
<p>如果你拿不准，那就都试试之后看哪个效果更好一些；再进行选择；（毕竟这东西有点玄学，更偏向于实践，数据挖掘过程就是不断把假设进行测试的过程）</p> 
<p>下面是关于一个关于需要进行归一化算法的总结：</p> 
<p>数据需要归一化的机器学习算法<br> 需要归一化的模型：</p> 
<p>        有些模型在各个维度进行不均匀伸缩后，最优解与原来不等价，例如SVM（距离分界面远的也拉近了，支持向量变多？）。对于这样的模型，除非本来各维数据的分布范围就比较接近，否则必须进行标准化，以免模型参数被分布范围较大或较小的数据dominate。<br>         有些模型在各个维度进行不均匀伸缩后，最优解与原来等价，例如logistic regression（因为θ的大小本来就自学习出不同的feature的重要性吧？）。对于这样的模型，是否标准化理论上不会改变最优解。但是，由于实际求解往往使用迭代算法，如果目标函数的形状太“扁”，迭代算法可能收敛得很慢甚至不收敛。所以对于具有伸缩不变性的模型，最好也进行数据标准化。</p> 
<p>        有些模型/优化方法的效果会强烈地依赖于特征是否归一化，如LogisticReg，SVM，NeuralNetwork，SGD等。</p> 
<p>不需要归一化的模型：</p> 
<p>    （0/1取值的特征通常不需要归一化，归一化会破坏它的稀疏性。）</p> 
<p>    有些模型则不受归一化影响，如DecisionTree。</p> 
<p>    ICA好像不需要归一化（因为独立成分如果归一化了就不独立了？）。</p> 
<p>    基于平方损失的最小二乘法OLS不需要归一化。<br> 原文：https://blog.csdn.net/pipisorry/article/details/52247379 </p> 
<p>关于特征的归一化和标准化，pandas里面都有相应的库，再pandas.preprocess里面；</p> 
<p> </p> 
<h4>3）:最重要的一点就是关于异常值的检测了</h4> 
<p>异常值的检测关乎数据的质量问题，我觉得是最重要也是最难的问题的，因为一批数据的异常值往往很难定义，一条数据根据不同的判别方法，也可能表现出不同的效果，而且目前的异常值检测算法大多数对于阈值的确定需要自己的判断：（如基于距离的，基于密度的等）</p> 
<p>下面说一下有哪些异常值的检测算法：</p> 
<p>1）iforest：这是我比较推荐的一种异常值检测算法：因为它不需要你人为的设置一个阈值，在实际的测试效果也不错；</p> 
<p>2）：基于距离的：KNN算法</p> 
<p>3）：基于简单统计量的，如3σ原则，分位点原则等等；</p> 
<p> </p> 
<h3>3：特征工程部分</h3> 
<p>可以说特征工程是决定一个训练好模型好坏的决定性步骤，数据决定了你模型的上线，而模型算法只是逼近这个上线，有时你提炼出了一个关键特征之后，可能你的精度会有很大的提升：</p> 
<p>1）：特征转换：常用的有log(np.log)变换（可以让特征更normal）对于数值类型的回归模型，如果越符合正太分布的标准，那么模型的精度就会越高；还有box-cox(scipy.state)</p> 
<p>2）：离散特征（one_hot编码，label编码，）</p> 
<p>3）：连续特征：离散化操作：分箱（bin）（有等频，和等距）</p> 
<p>4）：对于一些原始看起来并没有用的特征，如日期：你可能需要通过特征衍生的方式将它转换成有用的特征，如：距离某一个具有重大时间点的天数这个特征；</p> 
<p>5：特征组合：</p> 
<p>1）如：经纬度特征，他俩组合起来就可以唯一确定一个点（也就是精确位置了）</p> 
<p>2）：离散性之间：不同类别之间相互组合</p> 
<p>3）连续型的变量之间：加减乘除等；</p> 
<p>其实对于一些高级的框架，如tensorflow，他已经将这些方法封装起来了，详情的使用方法见：</p> 
<p><a href="https://mp.csdn.net/postedit/80933921">https://mp.csdn.net/postedit/80933921</a></p> 
<p>做完这些数据的处理之后，是的，我个人觉得这些其实都属于数据的处理；只是特征工程显得更加重要和复杂，更具有研究型，所以从数据数据处理中提出来，当成了一个单个的过程；</p> 
<h3>4：算法的选择</h3> 
<p>算法的选择情况有很多种情况：</p> 
<p>1：根据实际的问题可以分为回归，分类，聚类前两者属于监督学习，聚类问题属于无监督的学习；</p> 
<p>2：更具算法来分：可以分为机器学习和深度学习：</p> 
<p>3：然后根据每一个算法适用领域又还可以分；；比如CNN多用于图像问题；RNN多用于语音识别问题等</p> 
<h3>5：参数的调节和bagging思想</h3> 
<p>由于这些方法有很多的超参数，所以你需要通过调参的方式对你的模型进行调整；对于机器学习而言，GridSearch（网格搜索是一个不错的选择，但是不是说把参数全部放进去就可以了，你需要针对不同算法的特点，对参数进行分组调参，这里以xgboost来举例子：如决策树中有两个参数是depth和 min_child_weight(树的深度和树的深度，最小孩子权重）这些都是决定树特性的，还有一些其他的参数；分开调节可以节约计算量，参数过多，如果全都一起调节，可能爬不动；</p> 
<p>也可以选择不同的算法，把预测结果取平均或者是给定一个权重值进行相乘求和；这就是bagging；</p> 
<h4>以上就是整个过程了，但是对于一个AI产品而言，是不够的，最重要的就是数据的获取，以目前人工智能的现状，更多的是基于统计的，也就是数据驱动的产品，需要从互联网上获取需要的数据，这就需要爬虫的知识了，当然也有自身产生数据的生成对抗网络；如棋的对弈过程，他是自生产生数据，你只需要给他一个反馈；</h4> 
<p> </p> 
<h2>总结：</h2> 
<h3>1：其实那些算法就是一个个数学公式：如：归一化操作（x-min/x-max)标准化（x-μ）/σ；</h3> 
<h3>2：数据挖掘过程就是不断的重复上面的步骤，直至结果最优；其实对于语音识别和图像识别领域也类似，思路不变，只是具体的处理方式和算法（也就是数学公式变了）</h3> 
<h4>3：其实人工智能就是人们不断把世界“定量”化的过程；所谓的定量化就是任何东西都可以用数字表示，这牵涉到哲学问题；解释一下，拿雷电来举例，以往人类不知道电荷的时候，以为是雷神发怒了，这是“定性的”；而知道了电荷之后，用特定符号来表示，这就是“定量”问题；</h4> 
<h4>4：是不是感受到了恐惧？未来的你会不会被人工智能替代？</h4> 
<h4>别紧张，肯定不会的，情感这个东西，人际交往这些东西是不会被替代的；当然如果真被量化了，那这个时代就真被机器所替代了，anyway，至少我们这一代是看不到的，活在当下才是最好的，不要杞人忧天</h4> 
<p> </p> 
<p> </p> 
<h4><br>  </h4> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4e0ee2d9ed0ef9782cfbc1d2eda74c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python学习笔记，51job数据清洗篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f670df70424663cc3738b44e93eca61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nodejs阿里云OSS获取STS 授权</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>