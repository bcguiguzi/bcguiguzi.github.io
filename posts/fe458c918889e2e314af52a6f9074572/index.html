<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ELK日志 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ELK日志" />
<meta property="og:description" content="ELK 介绍 日志处理 日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因, 经常分析日志可以了解服务器的负荷, 性能安全性, 从而及时采取措施纠正错误 理想的日志系统特点 收集
能够采集多种来源的日志数据 传输
能够稳定的把日志数据传输到中央系统 存储
如何存储日志数据 分析
可以支持 UI 分析 警告
能够提供错误报告, 监控机制（ElastAlert） ELK 介绍
ELK提供了一整套解决方案, 都是开源软件, 之间互相配合、 完美衔接, 高效的满足了很多场合的应用，是目前主流的日志系统。由ElasticSearch、Logstash和Kibana三个开源工具组成，后新增了FileBeat，亦称ELFK 组成
ElasticSearch
一个基于Lucene的开源分布式搜索服务器。基于RESTful web接口，用Java开发分布式, 零配置, 自动发现, 索引自动分片, 索引副本机制, restful风格接口, 多数据源, 自动搜索负载设计用于云计算中, 能够达到实时搜索, 稳定, 可靠, 快速, 安装使用方便 Logstash
对日志进行收集、过滤、分析，开源免费一般为c/s架构, client端安装在需要收集日志的主机上, server端负责将收到的各节点日志进行过滤、修改等操作再一并发往elasticsearch上去 Kibana
基于浏览器页面的Elasticsearch前端展示工具，可以汇总、分析和搜索重要数据日志。开源免费 FileBeat
轻量级的日志收集处理工具(Agent)，占用资源少, 适合于在各服务器上搜集日志后传给Logstash，官方推荐 工作原理
应用程序(AppServer)→FileBeat→Logstash→ElasticSearch→Kibana→浏览器(Browser)FileBeat收集应用产生的日志，发给Logstash进行处理，处理后存放到ElasticSearch集群中，Kibana从ES集群中查询数据生成图表返回给Browser(原始模式由Logstash收集并处理) 文档
elastic中文社区
https://elasticsearch.cn/ Elasticsearch
https://www.elastic.co/guide/en/elasticsearch/reference/index.html Logstash
https://www.elastic.co/guide/en/logstash/index.html Kibana
https://www.elastic.co/guide/en/kibana/index.html Filebeat
https://www.elastic.co/guide/en/beats/filebeat/index.html 部署准备 服务器 至少2台，配置至少2U3G1.1.1.11 es1 Elasticsearch/kibana/head1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/fe458c918889e2e314af52a6f9074572/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-17T16:48:24+08:00" />
<meta property="article:modified_time" content="2022-09-17T16:48:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ELK日志</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ELK_0"></a>ELK</h2> 
<h3><a id="_2"></a>介绍</h3> 
<h4><a id="_4"></a>日志处理</h4> 
<ul><li>日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因, 经常分析日志可以了解服务器的负荷, 性能安全性, 从而及时采取措施纠正错误</li></ul> 
<h4><a id="_8"></a>理想的日志系统特点</h4> 
<ul><li> <p>收集</p> 
  <ul><li>能够采集多种来源的日志数据</li></ul> </li><li> <p>传输</p> 
  <ul><li>能够稳定的把日志数据传输到中央系统</li></ul> </li><li> <p>存储</p> 
  <ul><li>如何存储日志数据</li></ul> </li><li> <p>分析</p> 
  <ul><li>可以支持 UI 分析</li></ul> </li><li> <p>警告</p> 
  <ul><li>能够提供错误报告, 监控机制（ElastAlert）</li></ul> </li></ul> 
<h4><a id="ELK_30"></a>ELK</h4> 
<ul><li> <p>介绍</p> 
  <ul><li>ELK提供了一整套解决方案, 都是开源软件, 之间互相配合、 完美衔接, 高效的满足了很多场合的应用，是目前主流的日志系统。由ElasticSearch、Logstash和Kibana三个开源工具组成，后新增了FileBeat，亦称ELFK</li></ul> </li><li> <p>组成</p> 
  <ul><li> <p>ElasticSearch</p> 
    <ul><li>一个基于Lucene的开源分布式搜索服务器。基于RESTful web接口，用Java开发</li><li>分布式, 零配置, 自动发现, 索引自动分片, 索引副本机制, restful风格接口, 多数据源, 自动搜索负载</li><li>设计用于云计算中, 能够达到实时搜索, 稳定, 可靠, 快速, 安装使用方便</li></ul> </li><li> <p>Logstash</p> 
    <ul><li>对日志进行收集、过滤、分析，开源免费</li><li>一般为c/s架构, client端安装在需要收集日志的主机上, server端负责将收到的各节点日志进行过滤、修改等操作再一并发往elasticsearch上去</li></ul> </li><li> <p>Kibana</p> 
    <ul><li>基于浏览器页面的Elasticsearch前端展示工具，可以汇总、分析和搜索重要数据日志。开源免费</li></ul> </li><li> <p>FileBeat</p> 
    <ul><li>轻量级的日志收集处理工具(Agent)，占用资源少, 适合于在各服务器上搜集日志后传给Logstash，官方推荐</li></ul> </li></ul> </li><li> <p>工作原理</p> 
  <ul><li>应用程序(AppServer)→FileBeat→Logstash→ElasticSearch→Kibana→浏览器(Browser)</li><li>FileBeat收集应用产生的日志，发给Logstash进行处理，处理后存放到ElasticSearch集群中，Kibana从ES集群中查询数据生成图表返回给Browser(原始模式由Logstash收集并处理)</li></ul> </li><li> <p>文档</p> 
  <ul><li> <p>elastic中文社区</p> 
    <ul><li>https://elasticsearch.cn/</li></ul> </li><li> <p>Elasticsearch</p> 
    <ul><li>https://www.elastic.co/guide/en/elasticsearch/reference/index.html</li></ul> </li><li> <p>Logstash</p> 
    <ul><li>https://www.elastic.co/guide/en/logstash/index.html</li></ul> </li><li> <p>Kibana</p> 
    <ul><li>https://www.elastic.co/guide/en/kibana/index.html</li></ul> </li><li> <p>Filebeat</p> 
    <ul><li>https://www.elastic.co/guide/en/beats/filebeat/index.html</li></ul> </li></ul> </li></ul> 
<h3><a id="_84"></a>部署准备</h3> 
<h4><a id="_86"></a>服务器</h4> 
<ul><li>至少2台，配置至少2U3G</li><li>1.1.1.11 es1 Elasticsearch/kibana/head</li><li>1.1.1.12 es2 Elasticsearch/logstash</li></ul> 
<h4><a id="_92"></a>角色划分</h4> 
<ul><li>2台机器全部安装jdk1.8, 因为elasticsearch是java开发的</li><li>2台全部安装elasticsearch (后续都简称为es)</li><li>master节点(es1)上需要安装kibana以及head插件</li><li>data(es2)上安装logstash</li></ul> 
<h4><a id="ELK_99"></a>ELK版本信息</h4> 
<ul><li>Elasticsearch-6.4.1</li><li>logstash-6.4.1</li><li>kibana-6.4.1</li><li>filebeat-6.4.1</li><li>所有软件版本保持一致</li></ul> 
<h4><a id="_107"></a>其他</h4> 
<ul><li>所有机器做好互相解析,时间同步, 关闭防火墙, selinux</li></ul> 
<h3><a id="Elasticsearch_111"></a>Elasticsearch</h3> 
<h4><a id="_113"></a>简介</h4> 
<ul><li> <p>可扩展性</p> 
  <ul><li>通过索引分片机制实现，index为索引，每个index下面分为n个shard，真正的数据以doc(文档数据,类似于Gruntfile.js中格式)的形式存储在每个shard中</li></ul> </li><li> <p>高可用</p> 
  <ul><li>通过shard冗余备份、跨可用区域部署以及数据快照等方式实现，并能够应对集群节点故障和数据损坏</li></ul> </li><li> <p>节点(Node)</p> 
  <ul><li>一个运行中的Elasticsearch实例称为一个节点</li><li>集群是由一个或者多个拥有相同cluster.name配置的节点组成，它们共同承担数据和负载的压力</li><li>当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据</li></ul> </li><li> <p>主节点(Master Node)</p> 
  <ul><li>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等</li><li>主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量增加它也不会成为瓶颈</li></ul> </li><li> <p>请求</p> 
  <ul><li>用户可以将请求发送到集群中的任何节点 ，包括主节点</li><li>每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点</li><li>无论请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端</li></ul> </li><li> <p>索引(index)</p> 
  <ul><li>为了将数据添加到Elasticsearch，我们需要索引(index) —— 一个存储关联数据的地方</li><li>实际上，索引只是一个用来指向一个或多个分片(shards)的"逻辑命名空间(logical namespace)"</li></ul> </li><li> <p>分片(shard)</p> 
  <ul><li>最小级别的工作单元 ,保存索引中所有数据的一部分。分为主分片(primary shard)或副本分片(replica shard)</li><li>数据存储在分片中，并且在分片中被索引，应用程序直接与索引通信，索引中的每个文档属于一个单独的主分片</li><li>分片分配到集群中的节点上，当集群扩容或缩小，Elasticsearch会自动在节点间迁移分片，以使集群保持平衡</li><li>分片的最大容量取决于使用状况：硬件存储大小、文档大小和复杂度、如何索引和查询文档、期望的响应时间</li><li>复制分片只是主分片的一个副本，它可以防止硬件故障导致的数据丢失，同时可以提供读请求</li><li>当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整</li></ul> </li><li> <p>数据分布示例</p> 
  <ul><li> <p>例如一个索引中分配了3个主分片(默认是5个)和一个副本</p> </li><li> <p>一个节点</p> 
    <ul><li> <p>3个主分片分布在主节点</p> </li><li> <p>集群健康情况</p> 
      <ul><li>“status”: “yellow”,<br> “active_primary_shards”: 3,<br> “active_shards”: 3,<br> “unassigned_shards”: 3,</li></ul> </li><li> <p>在同一个节点上保存相同的数据副本没有必要，如果这个节点故障了，所有的副本也会丢失</p> </li></ul> </li><li> <p>两个节点</p> 
    <ul><li> <p>3个主分片分布在主节点，3个复制分片分布在节点2</p> </li><li> <p>集群健康情况</p> 
      <ul><li>“status”: “green”,<br> “active_primary_shards”: 3,<br> “active_shards”: 6,</li></ul> </li></ul> </li><li> <p>三个节点</p> 
    <ul><li>每个节点分布两个分片，意味着每个节点的硬件资源(CPU、RAM、I/O)被较少的分片共享，这样每个分片就会有更好的表现</li></ul> </li><li> <p>分片本身就是一个完整成熟的搜索引擎，它可以使用单一节点的所有资源。使用这6个分片(3主+3复制)最多可以扩展到6个节点，每个节点上有一个分片，这样每个分片就可以100%使用这个节点的资源了</p> </li></ul> </li><li> <p>服务端口</p> 
  <ul><li> <p>9200</p> 
    <ul><li>传输数据</li></ul> </li><li> <p>9300</p> 
    <ul><li>集群通信</li></ul> </li></ul> </li></ul> 
<h4><a id="_194"></a>集群部署</h4> 
<ul><li> <p>布署java环境(略)</p> 
  <ul><li>所有节点</li></ul> </li><li> <p>安装elasticsearch<br> (所有节点)</p> 
  <ul><li> <p>创建用户</p> 
    <ul><li>elasticsearch不能以root用户运行,必须要创建一个普通用户运行</li><li>useradd es</li><li>echo 123|passwd --stdin es</li></ul> </li><li> <p>解压</p> 
    <ul><li>tar xf elasticsearch-6.4.1.tar.gz -C /usr/local/</li><li>ln -s /usr/local/elasticsearch-6.4.1 /usr/local/es</li></ul> </li><li> <p>创建数据目录</p> 
    <ul><li>mkdir -p /data/es/{data,logs}</li></ul> </li><li> <p>授权</p> 
    <ul><li>chown -R es.es /data/es/ /usr/local/es/</li></ul> </li></ul> </li><li> <p>配置本地解析<br> (所有节点)</p> 
  <ul><li>vim /etc/hosts<br> 1.1.1.11 es1<br> 1.1.1.12 es2</li></ul> </li><li> <p>配置es-master<br> 1.1.1.11</p> 
  <ul><li> <h2><a id="vim_usrlocalesconfigelasticsearchyml_232"></a>vim /usr/local/es/config/elasticsearch.yml</h2> </li></ul> </li></ul> 
<p>cluster.name: es-cluster # 集群名称，各节点配成相同的集群名称<br> node.name: es1 # 节点名称，各节点配置不同。<br> node.master: true # 指示某个节点是否符合成为主节点的条件<br> node.data: true # 指示节点是否为数据节点。数据节点包含并管理索引的一部分<br> path.data: /data/es/data # 数据存储目录<br> path.logs: /data/es/logs # 日志存储目录<br> bootstrap.memory_lock: true # 内存锁定，是否禁用交换<br> network.host: 0.0.0.0 # 绑定节点IP<br> http.port: 9200 # rest api端口<br> discovery.zen.ping.unicast.hosts: [“es1”, “es2”] #集群节点IP或主机<br> http.cors.enabled: true #允许http跨域访问<br> http.cors.allow-origin: “*” #允许的源地址</p> 
<ul><li> <p>配置es-data<br> 1.1.1.12</p> 
  <ul><li>在master的基础上作如下修改<br> node.name: es2<br> node.master: false</li></ul> </li><li> <p>设置JVM堆大小<br> (所有节点)</p> 
  <ul><li> <p>sed -i ‘s/-Xms1g/-Xms4g/’ /es/config/jvm.options</p> </li><li> <p>sed -i ‘s/-Xmx1g/-Xmx4g/’ /usr/local/es/config/jvm.options</p> </li><li> <p>注意</p> 
    <ul><li>确保堆内存最小值(Xms)与最大值(Xmx)的大小相同，防止程序在运行时改变堆内存大小</li><li>如果系统内存足够大，将堆内存最大和最小值设置为31G，因为有一个32G性能瓶颈问题。堆内存大小不要超过系统内存的50%</li><li>这一步本实验中不做(虚拟机内存小), 若公司服务器性能较高, 为了提高es性能需要设置</li></ul> </li></ul> </li><li> <p>修改资源限制</p> 
  <ul><li>[root@es ~]# vim /etc/security/limits.conf<br> es soft nofile 65536<br> es hard nofile 131072<br> es soft nproc 4096<br> es hard nproc 4096<br> es soft memlock unlimited<br> es hard memlock unlimited</li></ul> </li></ul> 
<p>[root@es ~]# echo “vm.max_map_count=262144” &gt;&gt; /etc/sysctl.conf<br> [root@es es]# sysctl -p<br> vm.max_map_count = 262144</p> 
<ul><li> <p>启动服务</p> 
  <ul><li> <p>先启动master, 再启动data</p> </li><li> <p>su - es -c ‘/usr/local/es/bin/elasticsearch -d’</p> 
    <ul><li> <p>-c</p> 
      <ul><li>切换到es用户执行命令</li></ul> </li><li> <p>-d</p> 
      <ul><li>es以守护进程方式运行</li></ul> </li></ul> </li></ul> </li><li> <p>验证</p> 
  <ul><li> <p>查看端口</p> 
    <ul><li>netstat -tlnp |egrep “:9200|:9300”</li></ul> </li><li> <p>查看服务情况</p> 
    <ul><li>curl 1.1.1.11:9200 uuid有值</li><li>curl 1.1.1.12:9200</li></ul> </li><li> <p>查看集群<br> 健康状况</p> 
    <ul><li> <p>curl 1.1.1.11:9200/_cluster/health?pretty</p> </li><li> <p>curl 1.1.1.12:9200/_cluster/health?pretty</p> </li><li> <p>字段</p> 
      <ul><li> <p>status</p> 
        <ul><li> <p>green</p> 
          <ul><li>所有的主分片和副本分片都正常运行</li></ul> </li><li> <p>yellow</p> 
          <ul><li>所有的主分片都正常运行，但不是所有的副本分片都正常运行</li></ul> </li><li> <p>red</p> 
          <ul><li>有主分片没能正常运行</li></ul> </li></ul> </li><li> <p>number_of_nodes、number_of_data_nodes</p> 
        <ul><li>节点数量</li></ul> </li><li> <p>active_primary_shards</p> 
        <ul><li>集群中的主分片数量。涵盖了所有索引的汇总值</li></ul> </li><li> <p>active_shards</p> 
        <ul><li>涵盖了所有索引的所有分片的汇总值，即包括副本分片</li></ul> </li><li> <p>relocating_shards</p> 
        <ul><li>当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是0，不过在ES发现集群不太均衡时，该值会上涨</li></ul> </li><li> <p>initializing_shards</p> 
        <ul><li>刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于initializing状态</li></ul> </li><li> <p>unassigned_shards</p> 
        <ul><li>已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本</li></ul> </li></ul> </li></ul> </li></ul> </li><li> <p>安装问题</p> 
  <ul><li> <p>1</p> 
    <ul><li> <p>报错</p> 
      <ul><li>[WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [es2] uncaught exception in thread [main]<br> org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</li></ul> </li><li> <p>解决</p> 
      <ul><li>使用普通用户运行</li></ul> </li></ul> </li><li> <p>2</p> 
    <ul><li> <p>报错</p> 
      <ul><li>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</li><li>进程最大可同时打开文件数太小,至少要65536</li></ul> </li><li> <p>解决</p> 
      <ul><li> <h2><a id="vim_etcsecuritylimitsconf_369"></a>vim /etc/security/limits.conf</h2> </li></ul> </li></ul> </li></ul> </li></ul> 
<p>es soft nofile 65536 #第一列用户名<br> es hard nofile 65536<br> - ulimit -n</p> 
<pre><code>			- 查看当前用户的进程最大可同时打开文件数

		- ulimit -a

			- 查看所有限制

- 3

	- 报错

		- memory locking requested for elasticsearch process but memory is not locked
		- 请求锁内存失败,系统默认能让进程锁住的最大内存为64k

	- 解决

		- # vim /etc/security/limits.conf
</code></pre> 
<p>es soft memlock unlimited<br> es hard memlock unlimited</p> 
<pre><code>- 4

	- 报错

		- max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
		- es用户拥有的内存权限太小了，至少需要262114

	- 解决

		- echo vm.max_map_count=262144 &gt;&gt; /etc/sysctl.conf
		- sysctl -p

			- 从配置文件"/etc/sysctl.conf"加载内核参数设置

- 使用问题分析实例

  一个10节点的ES集群，某天碰到问题了，集群健康状态看起来像是这样：
  {
     "cluster_name": "elasticsearch_zach",
     "status": "red",
     "timed_out": false,
     "number_of_nodes": 8,
     "number_of_data_nodes": 8,
     "active_primary_shards": 90,
     "active_shards": 180,
     "relocating_shards": 0,
     "initializing_shards": 0,
     "unassigned_shards": 20
  }
  我们集群是 red ，意味着我们缺数据（主分片 + 副本分片）了。
  我们知道我们集群原先有 10 个节点，但是在这个健康状态里列出来的只有 8 个数据节点。
  有两个数据节点不见了。我们看到有 20 个未分配分片。
  
  这就是我们能收集到的全部信息。那些缺失分片的情况依然是个谜：
  我们是缺了 20 个索引，每个索引里少 1 个主分片？
  还是缺 1 个索引里的 20 个主分片？
  还是 10 个索引里的各 1 主 1 副本分片？
  具体是哪个索引？
  
  要回答这个问题，我们需要使用 level 参数让 cluster-health 答出更多一点的信息：
  GET _cluster/health?level=indices
  
  {
     "cluster_name": "elasticsearch_zach",
     "status": "red",
     "timed_out": false,
     "number_of_nodes": 8,
     "number_of_data_nodes": 8,
     "active_primary_shards": 90,
     "active_shards": 180,
     "relocating_shards": 0,
     "initializing_shards": 0,
     "unassigned_shards": 20
     "indices": {
        "v1": {
           "status": "green",
           "number_of_shards": 10,
           "number_of_replicas": 1,
           "active_primary_shards": 10,
           "active_shards": 20,
           "relocating_shards": 0,
           "initializing_shards": 0,
           "unassigned_shards": 0
        },
        "v2": {
           "status": "red", 
           "number_of_shards": 10,
           "number_of_replicas": 1,
           "active_primary_shards": 0,
           "active_shards": 0,
           "relocating_shards": 0,
           "initializing_shards": 0,
           "unassigned_shards": 20 
        },
        "v3": {
           "status": "green",
           "number_of_shards": 10,
           "number_of_replicas": 1,
           "active_primary_shards": 10,
           "active_shards": 20,
           "relocating_shards": 0,
           "initializing_shards": 0,
           "unassigned_shards": 0
        },
        ....
     }
  }
  
  我们可以看到 v2 索引就是让集群变 red 的那个索引。
  由此明确了，20 个缺失分片全部来自这个索引。
  
  我们还可以看到这个索引曾经有 10 个主分片和一个副本，而现在这 20 个分片全不见了。
  可以推测，这 20 个索引就是位于从我们集群里不见了的那两个节点上。
</code></pre> 
<h4><a id="head_487"></a>安装head插件</h4> 
<p>1.1.1.11</p> 
<ul><li> <p>下载</p> 
  <ul><li> <p>head插件</p> 
    <ul><li>https://github.com/mobz/elasticsearch-head/archive/refs/heads/master.zip</li></ul> </li><li> <p>node</p> 
    <ul><li>https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/v14.19.3/node-v14.19.3-linux-s390x.tar.gz</li></ul> </li></ul> </li><li> <p>安装</p> 
  <ul><li> <p>解压工具</p> 
    <ul><li>yum -y install bzip2 unzip</li></ul> </li><li> <p>node环境</p> 
    <ul><li>tar xf node-v14.19.3-linux-x64.tar.xz</li><li>mv node-v14.19.3-linux-x64 /usr/local/node</li><li> <h2><a id="vim_etcprofilednodesh_510"></a>vim /etc/profile.d/node.sh</h2> </li></ul> </li></ul> </li></ul> 
<p>export NODE_HOME=/usr/local/node<br> export NODE_PATH=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
         O 
        
       
         D 
        
        
        
          E 
         
        
          H 
         
        
       
         O 
        
       
         M 
        
       
         E 
        
       
         / 
        
       
         l 
        
       
         i 
        
       
         b 
        
       
         / 
        
       
         n 
        
       
         o 
        
       
         d 
        
        
        
          e 
         
        
          m 
         
        
       
         o 
        
       
         d 
        
       
         u 
        
       
         l 
        
       
         e 
        
       
         s 
        
       
         e 
        
       
         x 
        
       
         p 
        
       
         o 
        
       
         r 
        
       
         t 
        
       
         P 
        
       
         A 
        
       
         T 
        
       
         H 
        
       
         = 
        
       
      
        NODE_HOME/lib/node_modules export PATH= 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">NO</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0813em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.0576em;">OME</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">ib</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">ese</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord mathnormal" style="margin-right: 0.1389em;">tP</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span></span></span></span></span>NODE_HOME/bin:$PATH<br> - . /etc/profile.d/node.sh<br> - node -v</p> 
<pre><code>- head

	- unzip elasticsearch-head-master.zip
	- mv  elasticsearch-head-master  /usr/local

		- 注意不能安装在es的插件目录plugins中

	- cd  /usr/local/elasticsearch-head-master
	- npm install -g cnpm --registry=https://registry.npmmirror.com/

		- 安装cnmp工具

	- cnpm install -g grunt-cli
	- grunt -version
	- cnpm install
</code></pre> 
<ul><li> <p>服务端口</p> 
  <ul><li>9100</li></ul> </li><li> <p>配置</p> 
  <ul><li> <h2><a id="vim_Gruntfilejs_539"></a>vim Gruntfile.js</h2> <pre><code>      hostname: '1.1.1.11',   #port前面加上主机IP
      port: 9100,
</code></pre> </li></ul> </li><li> <p>启动</p> 
  <ul><li> <p>grunt server &amp;</p> 
    <ul><li>需在elasticsearch-head-master目录中启动</li></ul> </li></ul> </li><li> <p>使用</p> 
  <ul><li> <p>http://1.1.1.11:9100</p> 
    <ul><li>浏览器访问9100端口</li></ul> </li><li> <p>连接集群</p> 
    <ul><li>连接URL中localhost改为集群节点IP</li></ul> </li></ul> </li></ul> 
<h4><a id="_559"></a>索引操作</h4> 
<ul><li> <p>创建索引</p> 
  <ul><li> <p>默认为5分片1副本，最新版本貌似默认1分片，可自定义创建</p> </li><li> <p>默认</p> 
    <ul><li> <p>curl -X PUT “1.1.1.11:9200/twitter?pretty”</p> 
      <ul><li>创建索引twitter</li></ul> </li></ul> </li><li> <p>自定义</p> 
    <ul><li>创建一个索引facebook，4分片2副本</li><li>curl -X PUT “1.1.1.11:9200/facebook?pretty” -H ‘Content-Type: application/json’ -d’<br> {<!-- --><br> “settings” : {<!-- --><br> “index” : {<!-- --><br> “number_of_shards” : 4,<br> “number_of_replicas” : 2<br> }<br> }<br> }’</li></ul> </li></ul> </li><li> <p>删除索引</p> 
  <ul><li> <p>curl -X DELETE “1.1.1.11:9200/twitter?pretty”</p> </li><li> <p>网页操作</p> 
    <ul><li>动作-&gt;删除</li></ul> </li></ul> </li></ul> 
<h3><a id="logstash_590"></a>logstash</h3> 
<h4><a id="_592"></a>介绍</h4> 
<ul><li> <p>简介</p> 
  <ul><li>logstash是一个接收、处理、转发日志的工具。支持系统日志、webserver日志等所有可以抛出来的日志类型</li><li>Logstash在ELK中担任搬运工的角色，它为数据存储、报表查询和日志解析创建了一个功能强大的管道链</li><li>Logstash提供了多种多样的 input,filters,codecs和output组件,让使用者轻松实现强大的功能</li></ul> </li><li> <p>文档</p> 
  <ul><li> <p>官方文档</p> 
    <ul><li>https://www.elastic.co/cn/products/logstash</li></ul> </li><li> <p>Logstash 参考</p> 
    <ul><li>https://www.elastic.co/guide/en/logstash/index.html</li></ul> </li><li> <p>标准日志grok正则</p> 
    <ul><li>https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</li></ul> </li><li> <p>常用filter插件</p> 
    <ul><li>https://blog.csdn.net/wfs1994/article/details/80862952</li></ul> </li></ul> </li><li> <p>服务端口</p> 
  <ul><li>9600</li></ul> </li></ul> 
<h4><a id="_622"></a>工作阶段</h4> 
<ul><li> <p>input</p> 
  <ul><li>数据输入端，可接收来自任何地方的源数据</li></ul> </li><li> <p>filter</p> 
  <ul><li>数据中转层, 主要进行格式处理, 数据类型转换、数据过滤、字段添加, 修改等</li></ul> </li><li> <p>output</p> 
  <ul><li>数据输出端，负责将数据输出到指定位置，兼容大多数应用</li></ul> </li></ul> 
<h4><a id="_636"></a>安装配置</h4> 
<p>1.1.1.12</p> 
<ul><li> <p>安装</p> 
  <ul><li>tar xf logstash-6.4.1.tar.gz -C /usr/local</li><li>ln -s /usr/local/logstash-6.4.1 /usr/local/logstash</li></ul> </li><li> <p>配置</p> 
  <ul><li> <h2><a id="vim_usrlocallogstashconfiglogstashyml_646"></a>vim /usr/local/logstash/config/logstash.yml</h2> </li></ul> </li></ul> 
<p>http.host: “0.0.0.0”<br> - ln -s /usr/local/logstash/bin/logstash /usr/bin/logstash</p> 
<pre><code>	- 软链接

- cd /usr/local/logstash/config

	- 进入配置目录
</code></pre> 
<ul><li> <p>命令</p> 
  <ul><li> <p>logstash -f syslog-test.conf -t</p> 
    <ul><li>检测文件有没有错误</li></ul> </li><li> <p>logstash -f syslog-test.conf</p> 
    <ul><li>启动服务，端口9600</li></ul> </li><li> <p>选项</p> 
    <ul><li> <p>-f file</p> 
      <ul><li>指定配置文件</li></ul> </li><li> <p>-t</p> 
      <ul><li>检测配置并退出</li></ul> </li></ul> </li></ul> </li></ul> 
<h4><a id="input_676"></a>[input</h4> 
<p>插件](https://www.elastic.co/guide/en/logstash/6.4/input-plugins.html)</p> 
<ul><li> <p>stdin</p> 
  <ul><li> <p>从标准输入读取</p> 
    <ul><li>input { stdin {} }</li></ul> </li></ul> </li><li> <p>file</p> 
  <ul><li> <p>从本地文件中读取</p> </li><li> <p>配置项</p> 
    <ul><li> <p>path</p> 
      <ul><li>输入文件的路径，可多个，类型为数组。必选</li><li>path =&gt; [“/var/log/httpd/access_log”,“/var/log/message*”]</li></ul> </li><li> <p>start_position</p> 
      <ul><li> <p>起始位置，beginning或end，类型为字符串</p> </li><li> <p>beginning</p> 
        <ul><li>从文件开头位置开始读取，文件读完不会终止</li></ul> </li><li> <p>end(默认)</p> 
        <ul><li>从文件结尾位置开始读取，即读取新写入的内容</li></ul> </li></ul> </li></ul> </li><li> <p>例</p> 
    <ul><li>input {<!-- --><br> file {<!-- --><br> path =&gt; [“/var/log/httpd/access_log”]<br> start_position =&gt; “beginning”<br> }<br> }</li></ul> </li></ul> </li><li> <p>syslog</p> 
  <ul><li> <p>接收系统日志信息(默认监听端口514), 并解析成RFC3164格式</p> </li><li> <p>例</p> 
    <ul><li> <p>input {<!-- --><br> syslog {}<br> }</p> </li><li> <p>采集端系统日志配置</p> 
      <ul><li> <h2><a id="vim_etcrsyslogconf_725"></a>vim /etc/rsyslog.conf</h2> </li></ul> </li></ul> </li></ul> </li></ul> 
<p><em>.</em> @1.1.1.12<br> - systemctl restart rsyslog</p> 
<ul><li> <p>beat</p> 
  <ul><li> <p>接收来自Filebeat的事件</p> </li><li> <p>配置项</p> 
    <ul><li> <p>port</p> 
      <ul><li>必选</li></ul> </li></ul> </li><li> <p>例</p> 
    <ul><li>input {<!-- --><br> beats {<!-- --><br> port =&gt; 5044<br> codec =&gt; json #直接将保存在message中的json字串解析出来<br> }<br> }</li></ul> </li></ul> </li><li> <p>redis</p> 
  <ul><li>从redis-server list中获取</li></ul> </li><li> <p>kafka</p> 
  <ul><li>从kafka消息队列中获取</li></ul> </li></ul> 
<h4><a id="filter_755"></a>filter插件</h4> 
<ul><li> <p>grok</p> 
  <ul><li> <p>介绍</p> 
    <ul><li>正则捕获，通过正则解析任意文本，将非结构化日志数据弄成结构化和方便查询的结构</li><li>目前logstash中解析非结构化日志数据最好的方式</li></ul> </li><li> <p>配置项</p> 
    <ul><li> <p>match</p> 
      <ul><li>定义查找位置和模式的映射，类型为哈希</li></ul> </li></ul> </li><li> <p>语法规则</p> 
    <ul><li>match =&gt; {“message” =&gt; “%{内置模式名称:自定义字段名称}”}</li><li>pattern_definitions =&gt; { “自定义模式名称” =&gt; “正则表达式” }<br> match =&gt; {“message” =&gt; “%{自定义模式名称:自定义字段名称}”}</li><li>match =&gt; {“message” =&gt; “(?&lt;自定义字段名称&gt;正则表达式)”}</li><li>patterns_dir =&gt; [“自定义结构化模式文件目录”]<br> match =&gt; {“message” =&gt; “%{自定义结构化模式名称}”}</li></ul> </li><li> <p>内置模式</p> 
    <ul><li>安装目录的vendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns目录中</li><li>读取目录中所有文件</li></ul> </li><li> <p>例(httpd日志)</p> 
    <ul><li> <p>过滤IP</p> 
      <ul><li> <p>内置</p> 
        <ul><li>input { stdin {} }<br> filter {<!-- --><br> grok {<!-- --><br> match =&gt; {“message” =&gt; “%{IPV4:ip}”}<br> }<br> }<br> output { stdout {} }</li></ul> </li><li> <p>自定义</p> 
        <ul><li>input { stdin {} }<br> filter {<!-- --><br> grok {<!-- --><br> match =&gt; {“message” =&gt; “(?(\d+.){3}\d+)”}<br> }<br> }<br> output { stdout {} }</li></ul> </li></ul> </li><li> <p>结构化</p> 
      <ul><li> <p>内置</p> 
        <ul><li> <h2><a id="vim_grok1conf_812"></a>vim grok1.conf</h2> </li></ul> </li></ul> </li></ul> </li></ul> </li></ul> 
<p>input { stdin {} }<br> filter {<!-- --><br> grok {<!-- --><br> remove_field =&gt; [“message”]<br> match =&gt; {“message” =&gt; “%{COMBINEDAPACHELOG}”}<br> }<br> }<br> output { stdout {} }</p> 
<pre><code>		- 自定义

			- # vim grok2.conf
</code></pre> 
<p>input { stdin {} }<br> filter {<!-- --><br> grok {<!-- --><br> remove_field =&gt; [“message”]<br> patterns_dir =&gt; [“/logstash/patterns/”]<br> match =&gt; {“message” =&gt; “%{APACHE_LOG}”}<br> }<br> }<br> output { stdout {} }<br> - # vim /logstash/patterns/httpd<br> IPADDR (\d+.){3}\d+<br> ALL .*<br> UPPER [A-Z]+<br> NUMBER \d+<br> APACHE_LOG %{IPADDR:ip} .* [%{ALL:time}] “(%{UPPER:method} %{ALL:url} HTTP/%{ALL:http_version}|-)” %{NUMBER:http_code} %{NUMBER:bytes} “(%{ALL:http_referer}|-)” “(%{ALL:http_agent}|-)”</p> 
<ul><li> <p>mutate</p> 
  <ul><li> <p>数据修改插件，提供了丰富的基础类型数据处理能力，包括重命名、删除、替换、修改日志事件中的字段</p> </li><li> <p>convert</p> 
    <ul><li>用于数据类型的转换, 可以设置的转换类型包括: “integer”, “float” 和"string"</li></ul> </li><li> <p>gsub</p> 
    <ul><li>通过正则表达式替换字段中匹配到的值，只对字符串字段有效</li></ul> </li><li> <p>lowercase</p> 
    <ul><li>将大写字母全部转换成小写. 这个需求非常常见, 因为ES默认是按照小写字母进行检索的, 建议对常用检索字段启用lowercase配置</li></ul> </li><li> <p>filter {<!-- --><br> grok {<!-- --><br> match =&gt; {“message” =&gt; “%{COMBINEDAPACHELOG}”}<br> }<br> mutate { #执行顺序从上到下<br> rename =&gt; [“clientip”,“ip”] #将client字段重命名为ip<br> update #更新某个字段的内容, 如果字段不存在, 不会新建<br> replace #替代某个字段的内容, 如果字段不存在, 会新建<br> convert =&gt; [“response”,“integer”,“bytes”,“integer”] #将response和bytes数据类型转换为整型<br> gsub =&gt; [“clientip”,“.”,“<em>“] #将clientip字段的值中”.“替换成”</em>”<br> uppercase #将小写字母全部转换成大写<br> lowercase =&gt; [“verb”] #将verb字段的值中大写字母转换为小写<br> strip #去除字段前后的空格<br> remove_field =&gt; [“message”] #删除message字段<br> split =&gt; [“clientip”,“.”] #将ip地址以"."为分隔符分割<br> join #合并数组中的元素<br> merge #合并数组或哈希字段<br> }<br> }</p> </li></ul> </li><li> <p>geoip</p> 
  <ul><li>geoip是常见的免费的IP地址归类查询库，可以根据IP地址查询其地域信息，包括国别、省市、经纬度等等，此插件对于可视化地图和区域统计非常有用</li><li>input { stdin {} }<br> filter {<!-- --><br> grok { match =&gt; {“message” =&gt; “%{IPV4:ip}”} }<br> geoip {<!-- --><br> source =&gt; “ip”<br> fields =&gt; [“ip”,“country_name”,“region_name”,“city_name”] #自定义geoip中的显示字段<br> }<br> }<br> output { stdout {} }</li></ul> </li><li> <p>date</p> 
  <ul><li> <p>时间戳</p> 
    <ul><li> <p>@timestamp</p> 
      <ul><li>默认字段。表示系统时间，elasticsearch用此字段标注日志的产生时间</li></ul> </li><li> <p>timestamp</p> 
      <ul><li>自定义或内置模式中定义的时间字段，日志的实际产生时间</li></ul> </li><li> <p>问题</p> 
      <ul><li>若是实时监控，这两个字段时间几乎一致，但若是导入历史日志记录，则这两个时间完全不同，会导致kibana中展示的日志产生时间全部都是导入时的系统时间</li></ul> </li></ul> </li><li> <p>data插件作用</p> 
    <ul><li>将自定义的时间字段的值，转存到(覆盖)@timestamp字段</li></ul> </li><li> <p>配置</p> 
    <ul><li>filter {<!-- --><br> grok {<!-- --><br> match =&gt; { “message” =&gt; “%{HTTPDATE:time}”}<br> }<br> date {<!-- --><br> match =&gt; [“time”,“dd/MMM/yyyy:HH:mm:ss Z”]<br> }<br> }</li></ul> </li><li> <p>时区</p> 
    <ul><li>es内部时间类型字段以及日志存储都是采用UTC(0时区)时间</li><li>在kibana平台上系统会自动读取浏览器的当前时区，并将时间类型字段转换为当前时区的时间</li></ul> </li></ul> </li><li> <p>clone</p> 
  <ul><li>复制事件, 可能添加或者删除字段</li></ul> </li><li> <p>drop</p> 
  <ul><li>完全丢弃事件, 如debug事件</li></ul> </li><li> <p>通用配置项</p> 
  <ul><li> <p>可用于所有的filter插件</p> </li><li> <p>remove_field</p> 
    <ul><li>删除字段，类型为数组</li><li>remove_field =&gt; [“message”,“ident”]</li></ul> </li><li> <p>remove_tag、periodic_flush、id、enable_metric、add_tag、add_field</p> </li></ul> </li></ul> 
<h4><a id="output_943"></a>output插件</h4> 
<ul><li> <p>stdout</p> 
  <ul><li>输出到标准输出</li></ul> </li><li> <p>elasticsearch</p> 
  <ul><li>发送事件数据到Elasticsearch, 便于查询, 分析, 绘图</li><li>output {<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; [“1.1.1.11:9200”] #es集群套接字<br> index =&gt; [“http_access_log-%{+YYYY.MM.dd}”] #自定义索引名-系统时间<br> }<br> }</li></ul> </li><li> <p>file</p> 
  <ul><li>将事件数据写入到磁盘文件上</li></ul> </li><li> <p>mongodb</p> 
  <ul><li>将事件数据发送至高性能NoSQL mongodb, 便于永久存储, 查询, 分析, 大数据分片</li></ul> </li><li> <p>redis</p> 
  <ul><li>将数据发送至redis-server, 常用于中间层暂时缓存</li><li>output {<!-- --><br> redis {<!-- --><br> host =&gt; [“127.0.0.1”]<br> port =&gt; “6379”<br> data_type =&gt; “list”<br> key =&gt; “logstash:nginx_log_test”<br> }<br> }</li></ul> </li><li> <p>graphite</p> 
  <ul><li>发送事件数据到graphitehttp://graphite.wikidot.com/</li></ul> </li><li> <p>statsd</p> 
  <ul><li>发送事件数据到statsd</li></ul> </li><li> <p>kafka</p> 
  <ul><li>将数据发送至kafka</li></ul> </li></ul> 
<h3><a id="logstashnginx_991"></a>logstash收集nginx日志</h3> 
<h4><a id="_993"></a>方案一</h4> 
<ul><li> <p>nginx</p> 
  <ul><li>#vim /etc/nginx/nginx.conf<br> log_format json ‘{’<br> ‘“client”:“<span class="katex--inline">KaTeX parse error: Double superscript at position 37: … '̲"time":"</span>time_local”,’<br> ‘“verb”:“<span class="katex--inline">KaTeX parse error: Double superscript at position 40: … '̲"url":"</span>request_uri”,’<br> ‘“status”:"<span class="katex--inline">KaTeX parse error: Double superscript at position 32: … '̲"size":</span>body_bytes_sent,’<br> ‘“referer”: “<span class="katex--inline">KaTeX parse error: Double superscript at position 38: … '̲"agent": "</span>http_user_agent”’<br> ‘}’;<br> access_log /var/log/nginx/access_json.log json;</li></ul> </li><li> <p>logstash</p> 
  <ul><li> <h2><a id="vim_nginxconf_1012"></a>vim nginx.conf</h2> </li></ul> </li></ul> 
<p>input {<!-- --><br> file {<!-- --><br> path =&gt; “/var/log/nginx/access_json.log”<br> codec =&gt; “json” #输入预定义好的JSON数据, 可以省略filter/grok 配置, 从而减轻logstash的负载<br> start_position =&gt; “beginning”<br> }<br> }<br> output {<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; [“1.1.1.11:9200”]<br> index =&gt; “nginx-log-%{+YYYY.MM.dd}”<br> }<br> }</p> 
<h4><a id="_1027"></a>方案二</h4> 
<ul><li>Logstash自带apache标准日志的grok正则，nginx只是最后多了$http_x_forwarded_for</li><li>input {<!-- --><br> file {<!-- --><br> path =&gt; “/var/log/nginx/access.log”<br> start_position =&gt; beginning<br> }<br> }<br> filter {<!-- --><br> grok {<!-- --><br> match =&gt; { “message” =&gt; “%{COMBINEDAPACHELOG} %{QS:x_forwarded_for}”}<br> }<br> date {<!-- --><br> match =&gt; [ “timestamp” , “dd/MMM/YYYY:HH:mm:ss Z” ]<br> }<br> geoip {<!-- --><br> source =&gt; “clientip”<br> }<br> }<br> output {<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; “1.1.1.11:9200”<br> }<br> }</li></ul> 
<h3><a id="kibana_1053"></a>kibana</h3> 
<h4><a id="_1055"></a>安装</h4> 
<p>1.1.1.11</p> 
<ul><li>tar xf kibana-6.4.1-linux-x86_64.tar.gz -C /usr/local</li><li>ln -s /usr/local/kibana-6.4.1-linux-x86_64 /usr/local/kibana</li></ul> 
<h4><a id="_1061"></a>配置</h4> 
<ul><li> <h2><a id="vim_usrlocalkibanaconfigkibanayml_1063"></a>vim /usr/local/kibana/config/kibana.yml</h2> </li></ul> 
<p>server.port: 5601<br> server.host: “0.0.0.0”<br> elasticsearch.url: “http://1.1.1.11:9200” #es集群任意节点的套接字<br> logging.dest: /usr/local/kibana/logs</p> 
<h4><a id="_1069"></a>服务端口</h4> 
<ul><li>5601</li></ul> 
<h4><a id="_1073"></a>启动</h4> 
<ul><li>/usr/local/kibana/bin/kibana &amp;</li></ul> 
<h4><a id="_1077"></a>使用</h4> 
<ul><li> <p>浏览器访问：1.1.1.11：5601</p> </li><li> <p>添加索引</p> 
  <ul><li>Management-&gt;Index Patterns-&gt;Create Index Patterns-&gt;Index pattern搜索到唯一结果-&gt;Next step-&gt;配置Time Filter name选择timestamp-&gt;Create index pattern</li></ul> </li><li> <p>索引管理</p> 
  <ul><li>Management-&gt;Index Management-&gt;勾选索引&gt;Manage n indices-&gt;管理操作</li></ul> </li><li> <p>查看索引</p> 
  <ul><li>Discover-&gt;选择索引-&gt;勾选索引&gt;选择事件戳</li></ul> </li></ul> 
<h3><a id="filebeat_1092"></a>filebeat</h3> 
<h4><a id="_1094"></a>介绍</h4> 
<ul><li>beats是ELK体系中新增的一个轻量的日志采集器，前面日志采集使用的是logstash，但是logstash占用的资源比较大，官方推荐使用beats来作为日志采集工具。且beats可扩展，支持自定义构建</li><li>Beats可以直接(或者通过Logstash)将数据发送到Elasticsearch，在es可以进一步处理和增强数据，然后在Kibana中将其可视化</li><li>filebeat是beats家族中最常用的一种。其他成员：auditbeat,metricbeat,packetbeat,heartbeat,winlogbeat</li></ul> 
<h4><a id="_1100"></a>安装</h4> 
<ul><li>tar xf filebeat-6.4.1-linux-x86_64.tar.gz</li><li>mv filebeat-6.4.1-linux-x86_64 /usr/local/filebeat</li></ul> 
<h4><a id="_1105"></a>基本配置</h4> 
<ul><li> <h2><a id="vim_usrlocalfilebeatfilebeatyml_1107"></a>vim /usr/local/filebeat/filebeat.yml</h2> </li></ul> 
<p>filebeat.inputs:</p> 
<ul><li>type: log<br> enabled: true #注释掉或者改成true，默认false<br> paths:<br> - /var/log/httpd/access_log #指定需要收集的日志文件的路径</li></ul> 
<h4><a id="_1114"></a>启动</h4> 
<ul><li> <p>cd /usr/local/filebeat</p> </li><li> <p>./filebeat -c filebeat.yml &amp;</p> 
  <ul><li>-c指定配置文件</li></ul> </li></ul> 
<h4><a id="_1121"></a>输出类型配置</h4> 
<ul><li> <p>标准输出</p> 
  <ul><li> <h2><a id="vim_usrlocalfilebeat_1125"></a>vim /usr/local/filebeat/</h2> </li></ul> <p>output.console:<br> enable: true</p> </li><li> <p>发送到ES(默认)</p> 
  <ul><li> <h2><a id="vim_usrlocalfilebeat_1131"></a>vim /usr/local/filebeat/</h2> </li></ul> <p>output.elasticsearch:<br> hosts: [“1.1.1.11:9200”] #es集群节点的套接字</p> </li><li> <p>发送到kafka</p> 
  <ul><li> <h2><a id="vim_usrlocalfilebeat_1137"></a>vim /usr/local/filebeat/</h2> </li></ul> </li></ul> 
<p>output.kafka:<br> hosts: [“1.1.10.1:9092,1.1.10.2:9092,1.1.10.3:9092”]<br> topic: ‘nginx’</p> 
<ul><li> <p>发送到logstash</p> 
  <ul><li> <h2><a id="vim_usrlocalfilebeat_1144"></a>vim /usr/local/filebeat/</h2> </li></ul> </li></ul> 
<p>output.logstash:<br> hosts: [“1.1.1.12:5044”] #logstash监听套接字</p> 
<h4><a id="filebeatlogstash_1148"></a>filebeat&amp;logstash</h4> 
<ul><li> <p>采集处理<br> 单个日志</p> 
  <ul><li> <p>filebeat</p> 
    <ul><li>filebeat.inputs:</li></ul> </li></ul> </li><li> <p>type: log<br> paths:</p> 
  <ul><li>/var/log/httpd/access_log</li></ul> </li></ul> 
<p>output.logstash:<br> hosts: [“1.1.1.12:5044”]</p> 
<pre><code>- logstash

	- input {
beats {port =&gt; 5044}
</code></pre> 
<p>}</p> 
<ul><li> <p>采集处理<br> 多个日志</p> 
  <ul><li> <p>filebeat</p> 
    <ul><li>filebeat.inputs:</li></ul> </li></ul> </li><li> <p>type: log<br> paths:</p> 
  <ul><li>/var/log/httpd/access_log<br> fields:<br> filetype: web # 用于区别不同的日志<br> fields_under_root: true # 将自定义字段置于顶层</li></ul> </li><li> <p>type: log<br> paths:</p> 
  <ul><li>/var/log/secure<br> fields:<br> filetype: sys<br> fields_under_root: true</li></ul> </li></ul> 
<p>output.logstash:<br> hosts: [“1.1.1.12:5044”]</p> 
<pre><code>- logstash

	- input {
beats {port =&gt; 5044}
</code></pre> 
<p>}</p> 
<p>filter {<!-- --><br> if [filetype] == “web” {<!-- --><br> grok {<!-- --><br> match =&gt; {<!-- --><br> “message” =&gt; “%{COMBINEDAPACHELOG}”<br> }<br> remove_field =&gt; [“message”,“beat”,“offset”,“tags”,“prospector”]<br> }<br> }<br> }</p> 
<p>output {<!-- --><br> if [filetype] == “web” {<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; [“1.1.1.11:9200”] #es集群节点的套接字<br> index =&gt; “http-%{+YYYY.MM.dd}” #索引名自定义<br> }<br> }<br> else if [filetype] == “sys” {<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; [“1.1.1.11:9200”]<br> index =&gt; “syslog-%{+YYYY.MM.dd}”<br> }<br> }<br> }</p> 
<h3><a id="es_1224"></a>es集群中的角色</h3> 
<h4><a id="Master_Node_1226"></a>Master Node</h4> 
<ul><li> <p>作用</p> 
  <ul><li>主要负责集群中索引的创建、删除以及数据的Rebalance等操作</li><li>当Master节点失联或者挂掉的时候，ES集群会自动从其他Master节点选举出一个Leader</li></ul> </li><li> <p>建议</p> 
  <ul><li>稳定的主节点对集群的健康是非常重要的, 为了确保集群的稳定建议分离主节点和数据节点</li><li>为了防止脑裂，设置参数discovery.zen.minimum_master_nodes=N/2+1，N为Master个数</li><li>集群中Master节点的个数为奇数个，如3个或者5个</li></ul> </li><li> <p>设置</p> 
  <ul><li>配置文件：node.master: true</li></ul> </li></ul> 
<h4><a id="Data_Node_1243"></a>Data Node</h4> 
<ul><li> <p>作用</p> 
  <ul><li>主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等</li></ul> </li><li> <p>建议</p> 
  <ul><li>数据节点对cpu，内存，io要求较高， 在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点</li><li>和Master节点分开，避免因为Data Node节点出问题影响到Master节点</li></ul> </li><li> <p>设置</p> 
  <ul><li>配置文件：node.data: true</li></ul> </li></ul> 
<h4><a id="Client_Node_1258"></a>Client Node</h4> 
<ul><li>当master和data都设置为false的时候，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器</li><li>独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求</li></ul> 
<h4><a id="_1263"></a>生产环境中</h4> 
<p>集群部署建议</p> 
<ul><li>设置3台以上的节点作为master节点，这些节点只负责成为主节点，维护整个集群的状态</li><li>根据数据量设置一批data节点，这些节点只负责存储数据，后期提供建立索引和查询索引的服务</li><li>如果用户请求比较频繁，在集群中建议再设置一批client节点，这些节点只负责处理用户请求，实现请求转发，负载均衡等功能, 以减轻data节点的压力</li></ul> 
<h3><a id="ELKkafka_1270"></a>ELK+kafka</h3> 
<h4><a id="_1272"></a>架构</h4> 
<ul><li> <p>架构图</p> 
  <ul><li></ul> </li><li> <p>分层</p> 
  <ul><li> <p>数据采集层</p> 
    <ul><li>业务服务器集群，用filebeat做日志采集，同时把采集的日志分别发送给两个logstash服务</li></ul> </li><li> <p>数据处理层，数据缓冲层</p> 
    <ul><li>logstash服务把接受到的日志经过格式处理，转存到本地的kafka broker+zookeeper集群中</li></ul> </li><li> <p>数据转发层</p> 
    <ul><li>这个单独的Logstash节点会实时去kafka broker集群拉数据，转发至ES DataNode</li></ul> </li><li> <p>数据持久化存储</p> 
    <ul><li>ES DataNode 会把收到的数据，写磁盘，建索引库</li></ul> </li><li> <p>数据检索，数据展示</p> 
    <ul><li>ES Master + Kibana 主要 协调 ES集群，处理数据检索请求，数据展示</li></ul> </li></ul> </li></ul> 
<h4><a id="_1300"></a>消息队列介绍</h4> 
<ul><li> <p>是什么</p> 
  <ul><li>Message queue是一种进程间或同一进程的不同线程间的通信方式, 软件的贮列用来处理一系列的输入，可以是来自用户或应用服务</li><li>是一种异步通信, 每个贮列中的纪录包含数据的详细信息(发生的时间,输入设备,输入参数等)</li><li>消息的发送者和接收者不需要同时与消息队列交互，消息会保存在队列中, 直到接收者取回它</li><li>消息队列主要解决应用耦合、异步处理、流量削锋等问题</li><li>当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等, 而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能</li></ul> </li><li> <p>使用场景</p> 
  <ul><li> <p>应用耦合</p> 
    <ul><li>多应用间通过消息队列对同一消息进行处理, 避免调用接口失败导致整个过程失败</li></ul> </li><li> <p>异步处理</p> 
    <ul><li>多应用对消息队列中同一消息进行处理, 应用间并发处理消息, 相比串行处理, 减少处理时间</li></ul> </li><li> <p>限流削峰</p> 
    <ul><li>广泛应用于秒杀或抢购活动中, 避免流量过大导致应用系统挂掉的情况</li></ul> </li></ul> </li><li> <p>优点</p> 
  <ul><li> <p>解耦</p> 
    <ul><li>在项目启动之初来预测将来项目会碰到什么需求, 是极其困难的</li><li>消息系统在处理过程中间插入了一个隐含的、基于数据的接口层, 两边的处理过程都要实现这一接口</li><li>这允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样的接口约束</li></ul> </li><li> <p>冗余</p> 
    <ul><li>有些情况下, 处理数据的过程会失败，除非数据被持久化, 否则将造成丢失</li><li>消息队列把数据进行持久化直到它们已经被完全处理, 通过这一方式规避了数据丢失风险</li><li>许多消息队列在把一个消息从队列中删除之前, 需要你的处理系统明确的指出该消息已经被处理完毕, 从而确保数据被安全的保存直到你使用完毕</li></ul> </li><li> <p>扩展性</p> 
    <ul><li>因为消息队列解耦了处理过程, 所以增大消息入队和处理的频率很容易, 只要另外增加处理过程即可，不需要改变代码、不需要调节参数</li></ul> </li><li> <p>峰值处理</p> 
    <ul><li>在访问量剧增的情况下, 应用仍然需要继续发挥作用, 但是这样的突发流量并不常见</li><li>如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费</li><li>使用消息队列能够使关键组件顶住突发的访问压力, 而不会因为突发的超负荷的请求而完全崩溃</li></ul> </li><li> <p>可恢复性</p> 
    <ul><li>系统的一部分组件失效时, 不会影响到整个系统</li><li>即使一个处理消息的进程挂掉, 加入队列中的消息仍然可以在系统恢复后被处理</li></ul> </li><li> <p>顺序保证</p> 
    <ul><li>在大多使用场景下, 数据处理的顺序都很重要</li><li>大部分消息队列本来就是排序的, 并且能保证数据会按照特定的顺序来处理</li><li>如Kafka能保证一个Partition内的消息的有序性</li></ul> </li><li> <p>缓冲</p> 
    <ul><li>在任何重要的系统中, 都会有需要不同的处理时间的元素</li><li>消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速</li><li>该缓冲有助于控制和优化数据流经过系统的速度</li></ul> </li><li> <p>异步通信</p> 
    <ul><li>很多时候, 用户不想也不需要立即处理消息</li><li>消息队列提供了异步处理机制, 允许用户把一个消息放入队列, 但并不立即处理它</li><li>想向队列中放入多少消息就放多少, 然后在需要的时候再去处理它们</li></ul> </li></ul> </li><li> <p>模式</p> 
  <ul><li> <p>点对点模式</p> 
    <ul><li> <p>角色</p> 
      <ul><li>消息队列</li><li>发送者 (生产者)</li><li>接收者（消费者）</li></ul> </li><li> <p>特点</p> 
      <ul><li>队列可以有多个接收者，但一个消息只能被其中之一接收</li><li>消息一旦被消费(接收者成功接收后要应答)就会被删除</li><li>发送者发送消息之后, 不管有没有接收者在运行, 都不影响发送者发送消息</li><li>当没有消费者可用时, 这个消息会被保存直到有 一个可用的消费者</li></ul> </li></ul> </li><li> <p>发布/订阅模式</p> 
    <ul><li> <p>角色</p> 
      <ul><li>角色主题（Topic）</li><li>发布者(Publisher)</li><li>订阅者(Subscriber)</li></ul> </li><li> <p>特点</p> 
      <ul><li>每个消息可以有多个订阅者，订阅者需要提前订阅该角色主题, 并保持在线运行</li><li>针对某个主题，必须创建订阅者之后，才能消费发布者发布的消息</li><li>当发布一个消息, 所有订阅这个topic的服务都能得到这个消息</li></ul> </li></ul> </li></ul> </li><li> <p>常用开源消息队列</p> 
  <ul><li> <p>Kafka</p> 
    <ul><li>常用于分布式架构，对性能要求高的可考虑Kafka</li></ul> </li><li> <p>RocketMQ</p> 
    <ul><li>思路来源于kafka, 改成了主从结构, 在事务性可靠性方面做了优化</li></ul> </li><li> <p>RabbitMQ</p> </li></ul> </li></ul> 
<h4><a id="kafka_1414"></a>kafka介绍</h4> 
<ul><li> <p>官网</p> 
  <ul><li>http://kafka.apache.org/documentation.html</li></ul> </li><li> <p>概述</p> 
  <ul><li>分布式消息队列。有高性能、持久化、多副本备份、横向扩展能力</li><li>一般在架构设计中起到解耦、削峰、异步处理的作用</li><li>kafka对外使用topic的概念, 生产者往topic里写消息, 消费者从中读消息。消息保存根据topic归类</li><li>为了做到水平扩展, 一个topic实际是由多个partition组成的, 遇到瓶颈时, 可以通过增加partition的数量来进行横向扩容，单个parition内是保证消息有序</li><li>发送消息者称为Producer，消息接受者称为Consumer，集群的实例称为broker。它们都依赖于zookeeper来保证系统可用性，zookeeper集群保存一些meta信息</li></ul> </li><li> <p>AMQP协议</p> 
  <ul><li>Advanced Message Queuing Protocol(高级消息队列协议)，是一个标准开放的应用层的消息中间件(Message Oriented Middleware)协议</li><li>AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台</li><li>前面说的几种比较流行的消息队列协议，要么支持AMQP协议，要么借鉴了AMQP协议的思想进行了开发、实现、设计</li></ul> </li><li> <p>基本概念</p> 
  <ul><li> <p>消费者(Consumer)</p> 
    <ul><li>从消息队列中请求消息的客户端应用程序</li></ul> </li><li> <p>生产者(Producer)</p> 
    <ul><li>向broker发布消息的应用程序</li></ul> </li><li> <p>AMQP服务端(broker)</p> 
    <ul><li>用来接收生产者发送的消息并将这些消息路由给服务器中的队列，便于fafka将生产者发送的消息，动态的添加到磁盘并给每一条消息一个偏移量，所以对于kafka一个broker就是一个应用程序的实例</li></ul> </li><li> <p>主题(Topic)</p> 
    <ul><li>一个主题类似新闻中的体育、娱乐等分类概念，在实际工程中通常一个业务一个主题</li></ul> </li><li> <p>分区(Partition)</p> 
    <ul><li>一个Topic中的消息数据按照多个分区组织，分区是kafka消息队列组织的最小单位，一个分区可以看作是一个FIFO(First Input First Output，先入先出)的队列</li><li>kafka分区是提高kafka性能的关键所在，当你发现你的集群性能不高时，常用手段就是增加Topic的分区，分区里面的消息是按照从新到老的顺序进行组织，消费者从队列头订阅消息，生产者从队列尾添加消息</li></ul> </li><li> <p>备份(Replication)</p> 
    <ul><li>为了保证分布式可靠性，kafka0.8开始对每个分区的数据进行备份(不同的Broker上)，防止其中一个Broker宕机造成分区上的数据不可用</li></ul> </li></ul> </li><li> <p>支持的客户端语言</p> 
  <ul><li>C、C++、Erlang、Java、.net、perl、PHP、Python、Ruby、Go、Javascript</li></ul> </li><li> <p>服务端口</p> 
  <ul><li>9092</li></ul> </li></ul> 
<h4><a id="zookeeper_1469"></a>zookeeper介绍</h4> 
<ul><li> <p>官网</p> 
  <ul><li>http://zookeeper.apache.org</li></ul> </li><li> <p>概述</p> 
  <ul><li>Zookeeper是一种在分布式系统中被广泛用来作为分布式状态管理、分布式协调管理、分布式配置管理、和分布式锁服务的集群</li></ul> </li><li> <p>分布式配置管理</p> 
  <ul><li>将多个分布式服务器的应用配置文件，保存在zookeeper的某个目录节点中，所有相关的应用程序对这个目录进行监听。若配置信息发生改变，每个应用程序就会收到zookeeper的通知，然后从zookeeper获取新的配置信息应用到系统中</li></ul> </li><li> <p>kafka</p> 
  <ul><li>kafka增加和减少服务器都会在Zookeeper节点上触发相应的事件</li><li>kafka系统会捕获这些事件，进行新一轮的负载均衡，客户端也会捕获这些事件来进行新一轮的处理</li><li>Kafka集群是把状态保存在Zookeeper中的，首先要部署Zookeeper集群</li></ul> </li><li> <p>服务端口</p> 
  <ul><li> <p>2181</p> 
    <ul><li>客户端连接Zookeeper服务器的端口</li></ul> </li><li> <p>2888</p> 
    <ul><li>leader和follower之间的通信端口，服务启动后只有leader会监听这个端口</li></ul> </li><li> <p>3888</p> 
    <ul><li>leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口</li></ul> </li></ul> </li><li> <p>集群</p> 
  <ul><li>Zookeeper集群的工作是超过半数才能对外提供服务,成员数量一般为奇数台</li><li>zk集群一般只有一个leader，多个follower，主一般是相应客户端的读写请求，而从主同步数据，当主挂掉之后就会从follower里投票选举一个leader出来</li></ul> </li></ul> 
<h4><a id="_1508"></a>部署集群</h4> 
<p>zookeeper</p> 
<ul><li> <p>准备</p> 
  <ul><li> <p>软件版本</p> 
    <ul><li>zookeeper-3.4.12</li></ul> </li><li> <p>服务器</p> 
    <ul><li>1.1.1.21<br> 1.1.1.22<br> 1.1.1.23</li></ul> </li></ul> </li><li> <p>布署java环境</p> 
  <ul><li>略</li></ul> </li><li> <p>安装zookeeper</p> 
  <ul><li>tar xf zookeeper-3.4.12.tar.gz -C /usr/local/</li><li>ln -s /usr/local/zookeeper-3.4.12/ /usr/local/zookeeper</li></ul> </li><li> <p>修改配置文件</p> 
  <ul><li>cd /usr/local/zookeeper/conf</li><li>cp zoo_sample.cfg zoo.cfg</li><li> <h2><a id="vim_zoocfg_1536"></a>vim zoo.cfg</h2> </li></ul> </li></ul> 
<p>dataDir=/data/zookeeper/data #快照日志的存储路径<br> dataLogDir=/data/zookeeper/datalog #事物日志的存储路径，默认存储到dataDir制定的目录(会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多)<br> server.1=1.1.1.21:2888:3888 #server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到数据目录下面myid文件里<br> server.2=1.1.1.22:2888:3888<br> server.3=1.1.1.23:2888:3888<br> - 其他默认配置注释</p> 
<pre><code>  tickTime=2000              #Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔
  initLimit=10                  #这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，
                                      #而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。
                                      #当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，
                                      #那么表明这个客户端连接失败。总的时间长度就是 10*2=20 秒
  syncLimit=5                   #这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，
                                      #总的时间长度就是5*2=10秒
  dataDir=/data/zookeeper/data         #快照日志的存储路径
  dataLogDir=/data/zookeeper/datalog   #事物日志的存储路径，如果不配置这个那么事物日志会默认存储到dataDir制定的目录
                                                         #这样会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多
  clientPort=2181                                #这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求
  server.1=192.168.10.21:2888:3888              
  server.2=192.168.10.22:2888:3888
  server.3=192.168.10.23:2888:3888
  #server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到数据目录下面myid文件里
  #192.168.10.21为IP地址，第一个端口是leader和follower之间的通信端口，默认是2888,服务启动后,只有leader会监听这个端口
  #第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888
</code></pre> 
<ul><li> <p>创建数据目录及服务器id</p> 
  <ul><li> <p>mkdir /data/zookeeper/data{,log} -p</p> </li><li> <p>echo 1 &gt; /data/zookeeper/data/myid</p> 
    <ul><li>id分别为1 2 3，与配置文件对应</li></ul> </li></ul> </li><li> <p>启动服务</p> 
  <ul><li> <p>/usr/local/zookeeper/bin/zkServer.sh start</p> 
    <ul><li>启动服务</li></ul> </li><li> <p>/usr/local/zookeeper/bin/zkServer.sh status</p> 
    <ul><li>查看状态</li></ul> </li><li> <p>netstat -tanp |grep -E “2888|3888”</p> </li><li> <p>jps</p> 
    <ul><li>看运行的进程号</li></ul> </li></ul> </li><li> <p>重要说明</p> 
  <ul><li> <p>myid和server.myid</p> 
    <ul><li>在快照目录下存放的标识本台服务器的文件，他是整个zk集群用来发现彼此的一个重要标识</li></ul> </li><li> <p>conf/zoo.cfg</p> 
    <ul><li>zookeeper配置文件</li></ul> </li><li> <p>conf/log4j.properties</p> 
    <ul><li>zk的日志输出文件。用java写的程序基本上日志都用log4j来进行管理</li></ul> </li><li> <p>bin/zkServer.sh</p> 
    <ul><li>主管理程序文件</li></ul> </li><li> <p>bin/zkEnv.sh</p> 
    <ul><li>主要配置zookeeper集群启动时配置环境变量的文件</li></ul> </li><li> <p>zookeeper不会主动的清除旧的快照和日志文件，这个是操作者的责任</p> </li><li> <p>清理方法</p> 
    <ul><li>脚本+计划任务清理</li><li>使用bin/zkCleanup.sh这个脚本清理,具体使用方法找官方文档</li><li>3.4.0开始zookeeper可自动清理snapshot和事务日志，在zoo.cfg中配置：</li></ul> </li></ul> </li></ul> 
<h2><a id="vim_confzoocfg_1612"></a>vim conf/zoo.cfg</h2> 
<h2><a id="autopurgepurgeInterval1__0_1613"></a>autopurge.purgeInterval=1 #清理频率，单位是小时，默认是0不开启</h2> 
<h2><a id="autopurgesnapRetainCount3__3_1614"></a>autopurge.snapRetainCount=3 #需要保留的文件数目, 默认是保留3个</h2> 
<h4><a id="_1616"></a>部署集群</h4> 
<p>kafka</p> 
<ul><li> <p>环境</p> 
  <ul><li> <p>已经搭建好的zookeeper集群(虽然kafka中集成了zookeeper,但还是建议使用独立的zk集群)</p> </li><li> <p>软件版本</p> 
    <ul><li>kafka_2.12-2.1.0</li></ul> </li></ul> </li><li> <p>安装kafka</p> 
  <ul><li>tar xf kafka_2.12-2.1.0.tgz -C /usr/local/</li><li>ln -s /usr/local/kafka_2.12-2.1.0/ /usr/local/kafka</li></ul> </li><li> <p>创建数据目录</p> 
  <ul><li>mkdir /data/kafka-logs</li></ul> </li><li> <p>修改配置文件</p> 
  <ul><li> <h2><a id="vim_usrlocalkafkaconfigserverproperties_1637"></a>vim /usr/local/kafka/config/server.properties</h2> </li></ul> </li></ul> 
<p>broker.id=1 #当前机器在集群中的唯一标识，和zookeeper的myid性质一样<br> listeners=PLAINTEXT://1.1.1.21:9092 #监听套接字，每台服务器独立<br> log.dirs=/data/kafka-logs #消息存放的目录，多个目录’,'分隔，num.io.threads要大于这个目录的个数，如果配置多个目录，新创建的topic把消息持久化在分区数最少那一个目录中<br> num.partitions=1 #默认的分区数，一个topic默认1个分区数<br> default.replication.factor=2 #kafka保存消息的副本数<br> zookeeper.connect=1.1.1.21:2181,1.1.1.22:2181,1.1.1.23:2181 #zookeeper集群<br> - 其他默认配置注释</p> 
<pre><code>      broker.id=1        #当前机器在集群中的唯一标识，和zookeeper的myid性质一样
      listeners=PLAINTEXT://192.168.10.21:9092   #监听套接字
      num.network.threads=3     #这个是borker进行网络处理的线程数
      num.io.threads=8              #这个是borker进行I/O处理的线程数
      socket.send.buffer.bytes=102400   #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能
      socket.receive.buffer.bytes=102400 #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘
      socket.request.max.bytes=104857600 #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小
      log.dirs=/data/kafka-logs   #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数
                                             #如果配置多个目录，新创建的topic把消息持久化在分区数最少那一个目录中
      num.partitions=1            #默认的分区数，一个topic默认1个分区数
      num.recovery.threads.per.data.dir=1    #在启动时恢复日志和关闭时刷新日志时每个数据目录的线程的数量，默认1
      offsets.topic.replication.factor=2  
      transaction.state.log.replication.factor=1 
      transaction.state.log.min.isr=1
      log.retention.hours=168           #默认消息的最大持久化时间，168小时，7天
      message.max.byte=5242880     #消息保存的最大值5M
      default.replication.factor=2        #kafka保存消息的副本数
      replica.fetch.max.bytes=5242880  #取消息的最大字节数
      log.segment.bytes=1073741824   #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件
      log.retention.check.interval.ms=300000  #每隔300000毫秒去检查上面配置的log失效时间,到目录查看是否有过期的消息如果有，删除
      zookeeper.connect=192.168.10.21:2181,192.168.10.22:2181,192.168.10.23:2181  
      zookeeper.connection.timeout.ms=6000
      group.initial.rebalance.delay.ms=0
</code></pre> 
<ul><li> <p>启动kafka</p> 
  <ul><li> <p>/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp;</p> </li><li> <p>jps</p> 
    <ul><li>看运行的进程号</li></ul> </li></ul> </li><li> <p>验证</p> 
  <ul><li> <p>创建topic</p> 
    <ul><li>/usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 1.1.1.21:2181 --replication-factor 2</li></ul> </li><li> <p>创建发布者</p> 
    <ul><li>/usr/local/kafka/bin/kafka-console-producer.sh --broker-list 1.1.1.22:9092 --topic qian</li><li>交互输入发布内容</li></ul> </li><li> <p>创建订阅者</p> 
    <ul><li>/usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server 1.1.1.21:9092 --topic qian --from-beginning</li><li>如果都能接收到发布者发布的内容，说明kafka部署成功</li></ul> </li><li> <p>topic、发布者、订阅者在kafka集群中任意服务器上创建均可</p> </li><li> <p>其他操作</p> 
    <ul><li> <p>查看所有topic</p> 
      <ul><li>/usr/local/kafka/bin/kafka-topics.sh --zookeeper 1.1.1.23:2181 --list</li></ul> </li><li> <p>查看指定topic的详细信息</p> 
      <ul><li>/usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper 1.1.1.23:2181 --topic qian</li></ul> </li><li> <p>删除topic</p> 
      <ul><li>/usr/local/kafka/bin/kafka-topics.sh --delete --zookeeper 1.1.1.23:2181 --topic qian</li></ul> </li></ul> </li></ul> </li><li> <p>filebeat-&gt;logstash-&gt;kafka</p> 
  <ul><li> <h2><a id="vim_logstashkafkaconf_1710"></a>vim logstash-kafka.conf</h2> </li></ul> </li></ul> 
<p>input {<!-- --><br> beats {<!-- --><br> port =&gt; 5044<br> }<br> }</p> 
<p>filter {<!-- --><br> grok {<!-- --><br> match =&gt; {<!-- --><br> “message” =&gt; “%{COMBINEDAPACHELOG}”<br> }<br> remove_field =&gt; [“message”,“beat”,“offset”,“tags”,“prospector”]<br> }<br> }</p> 
<p>output {<!-- --><br> kafka {<!-- --><br> bootstrap_servers =&gt; “1.1.1.21:9092,1.1.1.22:9092,1.1.1.23:9092”<br> topic_id =&gt; “httpd-log”<br> compression_type =&gt; “snappy”<br> codec =&gt; “json”<br> }<br> }</p> 
<h3><a id="eflk_1735"></a>eflk数据流</h3> 
<h4><a id="_1737"></a>数据流</h4> 
<ul><li>appserver --&gt; filebeat --&gt; kafka --&gt; logstash --&gt; elasicsearch --&gt; kibana</li></ul> 
<h4><a id="filebeat_1741"></a>filebeat配置</h4> 
<ul><li> <h2><a id="vim_usrlocalfilebeatfilebeatym_1743"></a>vim /usr/local/filebeat/filebeat.ym</h2> </li></ul> 
<p>filebeat.inputs:</p> 
<ul><li>type: log<br> paths: 
  <ul><li>/var/log/nginx/access.log<br> json.keys_under_root: true<br> json.add_error_key: true<br> json.message_key: log<br> output.kafka:<br> hosts: [ “1.1.1.21:9092”,“1.1.1.22:9092”,“1.1.1.23:9092”]<br> topic: ‘nginx-access-log’</li></ul> </li></ul> 
<h4><a id="logstash_1755"></a>logstash配置</h4> 
<ul><li> <h2><a id="vim_usrlocallogstashconfigkafkaconf_1757"></a>vim /usr/local/logstash/config/kafka.conf</h2> </li></ul> 
<p>input {<!-- --><br> kafka {<!-- --><br> bootstrap_servers =&gt; “1.1.1.21:9092”,“1.1.1.22:9092”,“1.1.1.23:9092”<br> topics =&gt; “nginx-access-log”<br> auto_offset_reset =&gt; “earliest”<br> codec =&gt; “json”<br> decorate_events =&gt; true<br> }<br> }</p> 
<p>filter {<!-- --><br> grok {<!-- --><br> match =&gt; {“log” =&gt; “%{COMBINEDAPACHELOG} %{QS:x-forwarded-for}”}<br> remove_field =&gt; [“error”,“beat”,“offset”,“auth”,“ident”,“log”]<br> }<br> }</p> 
<p>output{<!-- --><br> elasticsearch {<!-- --><br> hosts =&gt; [“1.1.1.11:9200”]<br> index =&gt; “nginx-access-log-%{+YYYY.MM.dd}”<br> }<br> }</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e746a0a8f74519fd45902d4f364ddb24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS3动画之奔跑的小熊熊案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8cc40d0864f7cda9c79431d3c28d3fe0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux学习，配置bond</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>