<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BUG: scheduling while atomic 分析 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BUG: scheduling while atomic 分析" />
<meta property="og:description" content="遇到一个典型的ｓｃｈｅｄｕｌｅ问题。
&lt;3&gt;[26578.636839] C1 [ swapper/1] BUG: scheduling while atomic: swapper/1/0/0x00000002 &lt;6&gt;[26578.636869] C0 [ kworker/u:1] CPU1 is up &lt;4&gt;[26578.636900] C1 [ swapper/1] Modules linked in: bcm15500_i2c_ts &lt;4&gt;[26578.636961] C1 [ swapper/1] [&lt;c00146d0&gt;] (unwind_backtrace&#43;0x0/0x11c) from [&lt;c0602684&gt;] (__schedule&#43;0x70/0x6e0) &lt;4&gt;[26578.636991] C1 [ swapper/1] [&lt;c0602684&gt;] (__schedule&#43;0x70/0x6e0) from [&lt;c06030ec&gt;] (schedule_preempt_disabled&#43;0x14/0x20) &lt;4&gt;[26578.637052] C1 [ swapper/1] [&lt;c06030ec&gt;] (schedule_preempt_disabled&#43;0x14/0x20) from [&lt;c000f05c&gt;] (cpu_idle&#43;0xf0/0x104) &lt;4&gt;[26578.637083] C1 [ swapper/1] [&lt;c000f05c&gt;] (cpu_idle&#43;0xf0/0x104) from [&lt;c05e98e0&gt;] (cpu_die&#43;0x2c/0x5c) &lt;3&gt;[26578.637510] C1 [ swapper/1] BUG: scheduling while atomic: swapper/1/0/0x00000002 &lt;4&gt;[26578." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9bb4b7af0cef62ff73a2ba1c2b1ca722/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-09-27T13:53:36+08:00" />
<meta property="article:modified_time" content="2013-09-27T13:53:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BUG: scheduling while atomic 分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>遇到一个典型的ｓｃｈｅｄｕｌｅ问题。<br> </p> 
<p></p> 
<pre><code class="language-java">&lt;3&gt;[26578.636839] C1 [      swapper/1] BUG: scheduling while atomic: swapper/1/0/0x00000002
&lt;6&gt;[26578.636869] C0 [    kworker/u:1] CPU1 is up
&lt;4&gt;[26578.636900] C1 [      swapper/1] Modules linked in: bcm15500_i2c_ts
&lt;4&gt;[26578.636961] C1 [      swapper/1] [&lt;c00146d0&gt;] (unwind_backtrace+0x0/0x11c) from [&lt;c0602684&gt;] (__schedule+0x70/0x6e0)
&lt;4&gt;[26578.636991] C1 [      swapper/1] [&lt;c0602684&gt;] (__schedule+0x70/0x6e0) from [&lt;c06030ec&gt;] (schedule_preempt_disabled+0x14/0x20)
&lt;4&gt;[26578.637052] C1 [      swapper/1] [&lt;c06030ec&gt;] (schedule_preempt_disabled+0x14/0x20) from [&lt;c000f05c&gt;] (cpu_idle+0xf0/0x104)
&lt;4&gt;[26578.637083] C1 [      swapper/1] [&lt;c000f05c&gt;] (cpu_idle+0xf0/0x104) from [&lt;c05e98e0&gt;] (cpu_die+0x2c/0x5c)
&lt;3&gt;[26578.637510] C1 [      swapper/1] BUG: scheduling while atomic: swapper/1/0/0x00000002
&lt;4&gt;[26578.637510] C1 [      swapper/1] Modules linked in: bcm15500_i2c_ts
&lt;4&gt;[26578.637602] C1 [      swapper/1] [&lt;c00146d0&gt;] (unwind_backtrace+0x0/0x11c) from [&lt;c0602684&gt;] (__schedule+0x70/0x6e0)
&lt;4&gt;[26578.637663] C1 [      swapper/1] [&lt;c0602684&gt;] (__schedule+0x70/0x6e0) from [&lt;c06030ec&gt;] (schedule_preempt_disabled+0x14/0x20)
&lt;4&gt;[26578.637724] C1 [      swapper/1] [&lt;c06030ec&gt;] (schedule_preempt_disabled+0x14/0x20) from [&lt;c000f05c&gt;] (cpu_idle+0xf0/0x104)
&lt;4&gt;[26578.637754] C1 [      swapper/1] [&lt;c000f05c&gt;] (cpu_idle+0xf0/0x104) from [&lt;c05e98e0&gt;] (cpu_die+0x2c/0x5c)
&lt;3&gt;[26578.648069] C1 [      swapper/1] BUG: scheduling while atomic: swapper/1/0/0x00000002</code></pre> 
<br> 查看源代码 
<p></p> 
<p></p> 
<pre><code class="language-cpp">/*
 * __schedule() is the main scheduler function.
 */
static void __sched __schedule(void)
{
	struct task_struct *prev, *next;
	unsigned long *switch_count;
	struct rq *rq;
	int cpu;

need_resched:
	preempt_disable();
	cpu = smp_processor_id();
	rq = cpu_rq(cpu);
	rcu_note_context_switch(cpu);
	prev = rq-&gt;curr;

	schedule_debug(prev);
　　　　....
｝</code></pre> 
<br> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">/*
 * Print scheduling while atomic bug:
 */
static noinline void __schedule_bug(struct task_struct *prev)
{
	if (oops_in_progress)
		return;

	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",
		prev-&gt;comm, prev-&gt;pid, preempt_count());

	debug_show_held_locks(prev);
	print_modules();
	if (irqs_disabled())
		print_irqtrace_events(prev);

	dump_stack();
}

/*
 * Various schedule()-time debugging checks and statistics:
 */
static inline void schedule_debug(struct task_struct *prev)
{
	/*
	 * Test if we are atomic. Since do_exit() needs to call into
	 * schedule() atomically, we ignore that path for now.
	 * Otherwise, whine if we are scheduling when we should not be.
	 */
	if (unlikely(in_atomic_preempt_off() &amp;&amp; !prev-&gt;exit_state))
		__schedule_bug(prev);
	rcu_sleep_check();

	profile_hit(SCHED_PROFILING, __builtin_return_address(0));

	schedstat_inc(this_rq(), sched_count);
}</code></pre> 
<br> 可以看出，　满足如下条件将会打印该出错信息 
<pre><code class="language-cpp">unlikely(in_atomic_preempt_off() &amp;&amp; !prev-&gt;exit_state</code></pre> 
<p></p> 
<p>为0表示TASK_RUNNING状态,当前进程在运行;　并且处于原子状态,,那么就不能切换给其它的进程<br> </p> 
<p></p> 
<pre><code class="language-cpp"><code class="cpp plain">Linux/include/linux/sched.h </code>

/*
 * Task state bitmask. NOTE! These bits are also
 * encoded in fs/proc/array.c: get_task_state().
 *
 * We have two separate sets of flags: task-&gt;state
 * is about runnability, while task-&gt;exit_state are
 * about the task exiting. Confusing, but this way
 * modifying one set can't modify the other one by
 * mistake.
 */
#define TASK_RUNNING		0
#define TASK_INTERRUPTIBLE	1
#define TASK_UNINTERRUPTIBLE	2
#define __TASK_STOPPED		4
#define __TASK_TRACED		8
/* in tsk-&gt;exit_state */
#define EXIT_ZOMBIE		16
#define EXIT_DEAD		32
/* in tsk-&gt;state again */
#define TASK_DEAD		64
#define TASK_WAKEKILL		128
#define TASK_WAKING		256
#define TASK_STATE_MAX		512
</code></pre> 
<p></p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-cpp">kernel/include/linux/hardirq.h

#if defined(CONFIG_PREEMPT_COUNT)
# define PREEMPT_CHECK_OFFSET 1
#else
# define PREEMPT_CHECK_OFFSET 0
#endif

/*
 * Are we running in atomic context?  WARNING: this macro cannot
 * always detect atomic context; in particular, it cannot know about
 * held spinlocks in non-preemptible kernels.  Thus it should not be
 * used in the general case to determine whether sleeping is possible.
 * Do not use in_atomic() in driver code.
 */
#define in_atomic()	((preempt_count() &amp; ~PREEMPT_ACTIVE) != 0)

/*
 * Check whether we were atomic before we did preempt_disable():
 * (used by the scheduler, *after* releasing the kernel lock)
 */
#define in_atomic_preempt_off() \
		((preempt_count() &amp; ~PREEMPT_ACTIVE) != PREEMPT_CHECK_OFFSET)</code></pre> 
<p><br> </p> 
<p><span style="font-size:18px">结论整理</span><br> </p> 
<p>linux内核打印"BUG: scheduling while atomic"和"bad: scheduling from the idle thread"错误的时候，</p> 
<p>通常是在中断处理函数中调用了可以休眠的函数，如semaphore,mutex,sleep之类的可休眠的函数，</p> 
<p>而linux内核要求在中断处理的时候，不允许系统调度，不允许抢占，要等到中断处理完成才能做其他事情。</p> 
<p>因此，要充分考虑中断处理的时间，一定不能太久。<br> <br> 另外一个能产生此问题的是在idle进程里面，做了不该做的事情。现在Linux用于很多手持式设备，为了降低功耗，</p> 
<p>通常的作法是在idle进程里面降低CPU或RAM的频率、关闭一些设备等等。要保证这些动作的原子性才能确保</p> 
<p>不发生"bad: scheduling from the idle thread"这样的错误！<br> </p> 
<p><br> </p> 
<p>禁止内核抢占是指内核不会主动的抢占你的process，但是现在是你在自己的程序中主动call schedule()，</p> 
<p>kernel并不能阻止你这么作。</p> 
<p><br> </p> 
<p>Scheduling while atomic" means that a thread has called schedule() during an operation which is supposed to be atomic (ie uninterrupted).</p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-java">190 NOTE: ***** WARNING *****
191 NEVER SLEEP IN A COMPLETION HANDLER. These are normally called
192 during hardware interrupt processing. If you can, defer substantial
193 work to a tasklet (bottom half) to keep system latencies low. You'll
194 probably need to use spinlocks to protect data structures you manipulate
195 in completion handlers. </code></pre> 
<br> 
<pre><code class="language-java">GFP_ATOMIC is used when 
(a) you are inside a completion handler, an interrupt, bottom half, tasklet or timer, or 
(b) you are holding a spinlock or rwlock (does not apply to semaphores), or 
(c) current-&gt;state != TASK_RUNNING, this is the case only after you've changed it. </code></pre> 
<br> 
<br> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d3577d3c0552e149d1c0a764be6e8677/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Google-Project-Hosting搭建自己的网络SVN服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69ad2dc940143a056701b84a4ee73aeb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于android中  TextView   EditText  中的一些文本效果的实现i</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>