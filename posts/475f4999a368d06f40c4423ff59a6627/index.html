<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>保守式GC - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="保守式GC" />
<meta property="og:description" content="简单来说，就是不能识别指针和非指针的GC
寄存器，调用栈和全局变量空间都是不明确的根
以调用栈为例：
调用栈里有调用帧，调用帧里有函数内的局部变量和参数的值，不过，局部变量既有int double这样的非指针，也有void * 这样的指针，而对于GC调用帧的值只是一堆位的排列，所以，GC并不能识别指针和非指针，所以，叫做不明确的根
保守式GC：把不能识别指针还是非指针的对象当做指针来保守处理，也就是当成活动对象保留下来
比如C里边的union
union{ long n; void *ptr;}ambiguous_data; 它是联合体，所以，GC没法发识别是指针还是非指针，当对象有这样的数据结构时，就可能会识别错误
优点：处理程序不依赖于GC，代码编写者即使没有意识到GC的存在，程序也会自己回收
缺点：
1）识别指针和非指针需要耗费成本
2）错误识别的指针会被当成活动的对象，包括其子对象，可能会造成垃圾对象压迫堆
3）能够使用的GC算法有限
### 精准式GC
可以精准的识别指针和非指针
打标签：利用指针的值是4的倍数的特性(所以低2位都是0)，作为识别指针和非指针的依据
1）将非指针的值向左移动1位
2）将低1位置1
注意，打标签的过程不要让数据溢出，用这种方式打标签的话，处理程序里的数值都会是奇数，在程序里进行计算时必须先取消标签，再计算数值，基本上打标签和取消标签都是在程序里手动执行的
优点：不会留下非活动对象
缺点：要求处理程序的配合，给实现者带来麻烦，且每次取消标签，再重新设置，会影响到程序处理的整体速度
#### 间接引用：
根和对象之间是有一个句柄存在的，它持有指向对象的指针，且局部变量和全局变量这些不明确的跟里没有指向对象的指针，值的指针，只装着指向句柄，也就是mutator操作对象时，要经过有句柄的间接引用来执行处理，也就是如果采用间接引用，即使移到了引用目标的对象，也不用改写关键的值，只需要改写句柄里的指针即可
优点：有可能实现GC复制算法和压缩标记算法
缺点：所有对象都是间接引用，会拉低访问对象内数据的速度，这会关系到整个语言的处理速度
#### 保守式GC复制
就是把不明确的根指向的对象以外的对象都复制的GC算法，需要满足以下前提：
1）根是不明确的根
2）没有不明确的数据结构（表明GC可以明确判断对象里的域是指针还是非指针）
3）对象大小随意
4）CPU是32位（不是说，必须是32位，而是在此以32位CPU为例）
堆结构：
堆被分成一定大小的页，那些未被分配到对象的空页则有一个$current_space以外的编号
分配：
1）正在使用的页刚好有符合mutator申请的对象大小的分块，直接分配
2）正在使用的页没有合适的分块，会被分配到新的页，然后将改页设置object标记
3）申请分配大小超过页空间时，和平时分配一样，在开头设定object，然后在第二个页之后设置continued标志
当正在使用的页 &#43; 准备分配的页 &gt;= 总夜大小/2时，就会开始运行GC
GC执行的过程：先对next_space的值&#43;&#43;，然后将保留有从根引用对象的页的编号设定为next_page的值,即2，最后GC把所有从根引用的页next_space&#43;&#43;之后，就把to页里的对象的子对象复制到空白页，复制完成之后，GC就结束了，这时程序把current_page的值设定为next_space的值
注意，它不会回收包含有从根指向的对象的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的子对象
﻿
#### 黑名单机制
黑名单就是把需要注意的地址空间记录下来
在将对象分配到黑名单内的地址时，所分配的对象有以下限制：
1）小对象
2）没有子对象的对象
这样，即使对象成了垃圾且没有被回收也不会有很大的损失
优点：使保守式GC因错误识别对象而压迫堆的问题得到缓解，堆的使用效率提升
缺点：需要花费时间检查黑名单" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/475f4999a368d06f40c4423ff59a6627/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-18T11:25:38+08:00" />
<meta property="article:modified_time" content="2016-12-18T11:25:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">保守式GC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 简单来说，就是不能识别指针和非指针的GC</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 寄存器，调用栈和全局变量空间都是不明确的根</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 以调用栈为例：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 调用栈里有调用帧，调用帧里有函数内的局部变量和参数的值，不过，局部变量既有int  double这样的非指针，也有void * 这样的指针，而对于GC调用帧的值只是一堆位的排列，所以，GC并不能识别指针和非指针，所以，叫做不明确的根</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 保守式GC：把不能识别指针还是非指针的对象当做指针来保守处理，也就是当成活动对象保留下来</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 比如C里边的union</p> 
<div style='font-family:"Helvetica Neue"; font-size:15px; margin:0.667rem 0px; line-height:24px'> 
 <pre class="prettyprint linenums prettyprinted" style='margin-top:0.667rem; margin-bottom:0.667rem; background-color:rgb(247,247,249); border:1px solid rgb(225,225,232); font-size:13px; line-height:19px; overflow:auto; padding:10px; word-wrap:break-word; font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace'>  
  <ol class="linenums list-paddingleft-2" style="margin:0px; padding-left:2.13rem; color:rgb(30,52,123)"><li class="L0" style="color:rgb(190,190,197); line-height:18px; padding-left:12px"><code class="language-c" style='margin:0px; padding:0px; border:none; background-color:transparent; font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace; word-wrap:break-word; max-width:100%'><span class="kwd" style="color:rgb(30,52,123)">union</span><span class="pun" style="color:rgb(147,161,161)">{<!-- --></span></code></li><li class="L1" style="color:rgb(190,190,197); line-height:18px; padding-left:12px"><code class="language-c" style='margin:0px; padding:0px; border:none; background-color:transparent; font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace; word-wrap:break-word; max-width:100%'><span class="pln" style="color:rgb(72,72,76)">   </span><span class="kwd" style="color:rgb(30,52,123)">long</span><span class="pln" style="color:rgb(72,72,76)"> n</span><span class="pun" style="color:rgb(147,161,161)">;</span></code></li><li class="L2" style="color:rgb(190,190,197); line-height:18px; padding-left:12px"><code class="language-c" style='margin:0px; padding:0px; border:none; background-color:transparent; font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace; word-wrap:break-word; max-width:100%'><span class="pln" style="color:rgb(72,72,76)">   </span><span class="kwd" style="color:rgb(30,52,123)">void</span><span class="pln" style="color:rgb(72,72,76)"> </span><span class="pun" style="color:rgb(147,161,161)">*</span><span class="pln" style="color:rgb(72,72,76)">ptr</span><span class="pun" style="color:rgb(147,161,161)">;</span></code></li><li class="L3" style="color:rgb(190,190,197); line-height:18px; padding-left:12px"><code class="language-c" style='margin:0px; padding:0px; border:none; background-color:transparent; font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace; word-wrap:break-word; max-width:100%'><span class="pun" style="color:rgb(147,161,161)">}</span><span class="pln" style="color:rgb(72,72,76)">ambiguous_data</span><span class="pun" style="color:rgb(147,161,161)">;</span></code></li></ol></pre> 
</div> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 它是联合体，所以，GC没法发识别是指针还是非指针，当对象有这样的数据结构时，就可能会识别错误</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 优点：处理程序不依赖于GC，代码编写者即使没有意识到GC的存在，程序也会自己回收</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 缺点：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 1）识别指针和非指针需要耗费成本</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 2）错误识别的指针会被当成活动的对象，包括其子对象，可能会造成垃圾对象压迫堆</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 3）能够使用的GC算法有限</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> <br> </p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> ### 精准式GC</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 可以精准的识别指针和非指针</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 打标签：利用指针的值是4的倍数的特性(所以低2位都是0)，作为识别指针和非指针的依据<br> </p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 1）将非指针的值向左移动1位</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 2）将低1位置1</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 注意，打标签的过程不要让数据溢出，用这种方式打标签的话，处理程序里的数值都会是奇数，在程序里进行计算时必须先取消标签，再计算数值，基本上打标签和取消标签都是在程序里手动执行的</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 优点：不会留下非活动对象</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 缺点：要求处理程序的配合，给实现者带来麻烦，且每次取消标签，再重新设置，会影响到程序处理的整体速度</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> <br> </p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> #### 间接引用：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 根和对象之间是有一个句柄存在的，它持有指向对象的指针，且局部变量和全局变量这些不明确的跟里没有指向对象的指针，值的指针，只装着指向句柄，也就是mutator操作对象时，要经过有句柄的间接引用来执行处理，也就是如果采用间接引用，即使移到了引用目标的对象，也不用改写关键的值，只需要改写句柄里的指针即可</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 优点：有可能实现GC复制算法和压缩标记算法</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 缺点：所有对象都是间接引用，会拉低访问对象内数据的速度，这会关系到整个语言的处理速度</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> <br> </p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> #### 保守式GC复制</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 就是把不明确的根指向的对象以外的对象都复制的GC算法，需要满足以下前提：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 1）根是不明确的根</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 2）没有不明确的数据结构（表明GC可以明确判断对象里的域是指针还是非指针）</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 3）对象大小随意</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 4）CPU是32位（不是说，必须是32位，而是在此以32位CPU为例）</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 堆结构：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 堆被分成一定大小的页，那些未被分配到对象的空页则有一个$current_space以外的编号</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 分配：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 1）正在使用的页刚好有符合mutator申请的对象大小的分块，直接分配</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 2）正在使用的页没有合适的分块，会被分配到新的页，然后将改页设置object标记</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 3）申请分配大小超过页空间时，和平时分配一样，在开头设定object，然后在第二个页之后设置continued标志</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 当正在使用的页 + 准备分配的页 &gt;= 总夜大小/2时，就会开始运行GC</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> GC执行的过程：先对next_space的值++，然后将保留有从根引用对象的页的编号设定为next_page的值,即2，最后GC把所有从根引用的页next_space++之后，就把to页里的对象的子对象复制到空白页，复制完成之后，GC就结束了，这时程序把current_page的值设定为next_space的值</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 注意，它不会回收包含有从根指向的对象的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的子对象</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> ﻿<br> </p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> #### 黑名单机制</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 黑名单就是把需要注意的地址空间记录下来</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 在将对象分配到黑名单内的地址时，所分配的对象有以下限制：</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 1）小对象</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 2）没有子对象的对象</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 这样，即使对象成了垃圾且没有被回收也不会有很大的损失</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 优点：使保守式GC因错误识别对象而压迫堆的问题得到缓解，堆的使用效率提升</p> 
<p style='font-family:"Helvetica Neue"; font-size:15px; margin-top:0.667rem; margin-bottom:0.667rem; line-height:24px'> 缺点：需要花费时间检查黑名单</p> 
<div> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2f9b441c35f0aadc2c70f65a2542193/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js中点击事件可能产生的闭包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca8c48afcde772a32f829d941af4036d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">u-boot relocate_code原理简单说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>