<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>❤️ 单例模式：中秋佳节C站陪你不孤单 ❤️ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="❤️ 单例模式：中秋佳节C站陪你不孤单 ❤️" />
<meta property="og:description" content="目录 前言一、C&#43;&#43; 单例模式总结与剖析1.1 什么是单例 二、C&#43;&#43;单例实现2.1 基础要点2.2 C&#43;&#43; 实现单例的几种方式2.2.1 有缺陷的懒汉式2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量2.2.4 函数返回引用 2.3 单例的模板2.3.1 CRTP 奇异递归模板模式实现 三、使用场景 前言 系列文章的开始主要目的在于学习和分享，在浏览众多的教程过程中，发现了一位大佬的文章说的十分深入，观看他的其他内容也颇有深度，我愿称之为“精通c&#43;&#43;”，你懂我意思吧🐶。在本篇文章中大量采用了原文的描述，也从易于阅读和传播的角度做了一些改进，希望大家都能有所收获，参考原文地址连接。
一、C&#43;&#43; 单例模式总结与剖析 单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。
本文对C&#43;&#43; 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C&#43;&#43; 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C&#43;&#43;语言特性还是很有帮助的。
1.1 什么是单例 单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;
具体运用场景如： 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;
数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;
二、C&#43;&#43;单例实现 2.1 基础要点 全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）线程安全禁止赋值和拷贝用户通过接口获取实例：使用 static 类成员函数 2.2 C&#43;&#43; 实现单例的几种方式 2.2.1 有缺陷的懒汉式 懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。
#include &lt;iostream&gt; // version1: // with problems below: // 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cf55078cdd3204a11d9d0e3336a3a250/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-20T19:19:08+08:00" />
<meta property="article:modified_time" content="2021-09-20T19:19:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">❤️ 单例模式：中秋佳节C站陪你不孤单 ❤️</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#C__8" rel="nofollow">一、C++ 单例模式总结与剖析</a></li><li><ul><li><a href="#11__12" rel="nofollow">1.1 什么是单例</a></li></ul> 
  </li><li><a href="#C_19" rel="nofollow">二、C++单例实现</a></li><li><ul><li><a href="#21__20" rel="nofollow">2.1 基础要点</a></li><li><a href="#22_C__27" rel="nofollow">2.2 C++ 实现单例的几种方式</a></li><li><ul><li><a href="#221__28" rel="nofollow">2.2.1 有缺陷的懒汉式</a></li><li><a href="#222___86" rel="nofollow">2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）</a></li><li><a href="#223_magic_static__154" rel="nofollow">2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量</a></li><li><a href="#224__211" rel="nofollow">2.2.4 函数返回引用</a></li></ul> 
   </li><li><a href="#23__248" rel="nofollow">2.3 单例的模板</a></li><li><ul><li><a href="#231_CRTP__249" rel="nofollow">2.3.1 CRTP 奇异递归模板模式实现</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_309" rel="nofollow">三、使用场景</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>系列文章的开始主要目的在于学习和分享，在浏览众多的教程过程中，发现了一位大佬的文章说的十分深入，观看他的其他内容也颇有深度，我愿称之为“精通c++”，你懂我意思吧🐶。在本篇文章中大量采用了原文的描述，也从易于阅读和传播的角度做了一些改进，希望大家都能有所收获，<a href="https://www.cnblogs.com/sunchaothu/p/10389842.html" rel="nofollow">参考原文地址连接</a>。<br> <img src="https://images2.imgbox.com/7c/01/5RNSz8Df_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="C__8"></a>一、C++ 单例模式总结与剖析</h2> 
<p>单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。<br> 本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。</p> 
<h3><a id="11__12"></a>1.1 什么是单例</h3> 
<p><strong>单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例</strong>;</p> 
<ul><li>具体运用场景如：</li></ul> 
<blockquote> 
 <p>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;<br> 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;</p> 
</blockquote> 
<h2><a id="C_19"></a>二、C++单例实现</h2> 
<h3><a id="21__20"></a>2.1 基础要点</h3> 
<ul><li>全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）</li><li>线程安全</li><li>禁止赋值和拷贝</li><li>用户通过接口获取实例：使用 static 类成员函数</li></ul> 
<h3><a id="22_C__27"></a>2.2 C++ 实现单例的几种方式</h3> 
<h4><a id="221__28"></a>2.2.1 有缺陷的懒汉式</h4> 
<p>懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// version1:</span>
<span class="token comment">// with problems below:</span>
<span class="token comment">// 1. thread is not safe</span>
<span class="token comment">// 2. memory leak</span>

<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span>Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> m_instance_ptr<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>m_instance_ptr<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
              m_instance_ptr <span class="token operator">=</span> <span class="token keyword">new</span> Singleton<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> m_instance_ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in use"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Singleton<span class="token operator">*</span> Singleton<span class="token operator">::</span>m_instance_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    Singleton<span class="token operator">*</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">*</span> instance_2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果</li></ul> 
<pre><code class="prism language-cpp">constructor called<span class="token operator">!</span>
</code></pre> 
<p><strong>可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？</strong></p> 
<p><strong>1）、线程安全的问题,当多线程获取单例时有可能引发竞态条件</strong>：<br> 第一个线程在if中判断 m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来;<br> <strong>解决办法</strong>:<br> 加锁</p> 
<p><strong>2）、内存泄漏</strong>:<br> 注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。<br> <strong>解决办法</strong>：<br> 使用共享指针;</p> 
<h4><a id="222___86"></a>2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）</h4> 
<p>因此，这里提供一个改进的，线程安全的、使用智能指针的实现;</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span> <span class="token comment">// shared_ptr</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span>  <span class="token comment">// mutex</span></span>

<span class="token comment">// version 2:</span>
<span class="token comment">// with problems below fixed:</span>
<span class="token comment">// 1. thread is safe now</span>
<span class="token comment">// 2. memory doesn't leak</span>

<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Singleton<span class="token operator">&gt;</span> Ptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span>Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Ptr <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token comment">// "double checked lock"</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>m_instance_ptr<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>m_instance_ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
              m_instance_ptr <span class="token operator">=</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Singleton<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> Singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> m_instance_ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> Ptr m_instance_ptr<span class="token punctuation">;</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>mutex m_mutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// initialization static variables out of class</span>
Singleton<span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Ptr</span> Singleton<span class="token operator">::</span><span class="token class-name">m_instance_ptr</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span></span><span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex Singleton<span class="token operator">::</span>m_mutex<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    Singleton<span class="token operator">::</span>Ptr instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">::</span>Ptr instance2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果如下，发现确实只构造了一次实例，并且发生了析构。</li></ul> 
<pre><code class="prism language-cpp">constructor called<span class="token operator">!</span>
destructor called<span class="token operator">!</span>
</code></pre> 
<p><strong>shared_ptr和mutex都是C++11的标准，以上这种方法的优点是</strong>：</p> 
<p>基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,<strong>当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉</strong>。以此避免内存泄漏。<br> 加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，<strong>锁的开销毕竟还是有点大的</strong>。<br> <strong>不足之处在于</strong>： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。</p> 
<p><img src="https://images2.imgbox.com/ff/75/YYnNOZuV_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="223_magic_static__154"></a>2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量</h4> 
<p>因此这里还有第三种的基于 Magic Staic的方法达到线程安全</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Singleton<span class="token operator">&amp;</span> instance_1 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> instance_2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>运行结果</li></ul> 
<pre><code class="prism language-cpp">constructor called<span class="token operator">!</span>
destructor called<span class="token operator">!</span>
</code></pre> 
<p>这种方法又叫做 Meyers’ SingletonMeyer’s的单例， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在C++11标准中的Magic Static特性：</p> 
<blockquote> 
 <p>If control enters the declaration concurrently while the variable is<br> being initialized, the concurrent execution shall wait for completion<br> of the initialization.</p> 
 <p><strong>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</strong></p> 
</blockquote> 
<p>C++静态变量的生存期 是从声明到程序结束，这也是一种懒汉式。</p> 
<p>这是最推荐的一种单例实现方式：</p> 
<ul><li><strong>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</strong></li><li><strong>不需要使用共享指针，代码简洁；</strong></li></ul> 
<p><strong>注意</strong>：在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。</p> 
<h4><a id="224__211"></a>2.2.4 函数返回引用</h4> 
<p>有人在网上提供了这样一种单例的实现方式；</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor"</span> <span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


A<span class="token operator">&amp;</span> <span class="token function">ret_singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> A instance<span class="token punctuation">;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    A<span class="token operator">&amp;</span> instance_1 <span class="token operator">=</span> <span class="token function">ret_singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    A<span class="token operator">&amp;</span> instance_2 <span class="token operator">=</span> <span class="token function">ret_singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了ret_singleton 的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过ret_singleton()的方法。</p> 
<p>以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会比较推荐 C++11 标准下的 2.2.3 的方式，即使用static local的方法，简单的理由来说是因为其足够简单却满足所有需求和顾虑。</p> 
<p>在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ <strong>很自然的我们会考虑使用模板技术或者继承的方法</strong></p> 
<h3><a id="23__248"></a>2.3 单例的模板</h3> 
<h4><a id="231_CRTP__249"></a>2.3.1 CRTP 奇异递归模板模式实现</h4> 
<p>代码示例如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// brief: a singleton base class offering an easy way to create singleton</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> T<span class="token operator">&amp;</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> T instance<span class="token punctuation">;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor called!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/********************************************/</span>
<span class="token comment">// Example:</span>
<span class="token comment">// 1.friend class declaration is requiered!</span>
<span class="token comment">// 2.constructor should be private</span>


<span class="token keyword">class</span> <span class="token class-name">DerivedSingle</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span><span class="token class-name">DerivedSingle</span><span class="token operator">&gt;</span></span><span class="token punctuation">{<!-- --></span>
   <span class="token comment">// !!!! attention!!!</span>
   <span class="token comment">// needs to be friend in order to</span>
   <span class="token comment">// access the private constructor/destructor</span>
   <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>DerivedSingle<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">DerivedSingle</span><span class="token punctuation">(</span><span class="token keyword">const</span> DerivedSingle<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
   DerivedSingle<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> DerivedSingle<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
   <span class="token function">DerivedSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    DerivedSingle<span class="token operator">&amp;</span> instance1 <span class="token operator">=</span> <span class="token class-name">DerivedSingle</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    DerivedSingle<span class="token operator">&amp;</span> instance2 <span class="token operator">=</span> <span class="token class-name">DerivedSingle</span><span class="token operator">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上实现一个单例的模板基类，使用方法如例子所示意，子类需要将自己作为模板参数T 传递给 Singleton 模板; 同时需要将基类声明为友元，这样才能调用子类的私有构造函数。</p> 
<p><strong>基类模板的实现要点是</strong>：</p> 
<ul><li>构造函数需要是 protected，这样子类才能继承； 使用了奇异递归模板模式CRTP(Curiously recurring</li><li>template pattern) get instance 方法和 2.2.3 的static local方法一个原理；</li><li>在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致。<br> <img src="https://images2.imgbox.com/e4/d1/GRXP21I5_o.jpg" alt="在这里插入图片描述"></li></ul> 
<h2><a id="_309"></a>三、使用场景</h2> 
<blockquote> 
 <p>You need to have one and only one object of a type in system<br> 你需要系统中只有唯一一个实例存在的类的全局变量的时候才使用单例。</p> 
</blockquote> 
<blockquote> 
 <p>如果使用单例，应该用什么样子的？<br> How to create the best singleton:</p> 
 <p>1、The smaller, the better. I am a minimalist Make sure it is thread safe<br> 2、Make sure it is never null Make sure it is created only once Lazy or<br> 3、system initialization? Up to your requirements Sometimes the OS or the<br> 4、JVM creates singletons for you (e.g. in Java every class definition is<br> 5、a singleton) Provide a destructor or somehow figure out how to dispose<br> 6、resources Use little memory<br> 越小越好，越简单越好，线程安全，内存不泄露</p> 
</blockquote> 
<p><font color="green"><strong>又是夹带私货的一天，学习也不忘有个舒适的心情，夏天去了，秋天剩下的就是凉凉的风和云…</strong><br> <img src="https://images2.imgbox.com/f5/ef/9dnbitza_o.jpg" alt="在这里插入图片描述"></font></p> 
<p>❤️❤️❤️ <strong>如果本文对你有所帮助，请不要忘了点赞、关注、收藏哦！灰常感谢！</strong> ❤️❤️❤️</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0a691e18da31489bec327f000ada176/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vmware 虚拟机在 windows10 启动蓝屏问题小结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21de8f81eeb1b42baecbb3b9ea1db62d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">backtrader 数据源相关的几个问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>