<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UE4如何调用打开系统消息对话窗口 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UE4如何调用打开系统消息对话窗口" />
<meta property="og:description" content="游戏开发过程中，有时需要明显的提示游戏运行时出现的问题，比如配置错误等信息，不仅需要输出错误到日记文件，还需要明显的显示错误信息给到非程序人员看到。那么打开系统窗口提示就是一个非常好的选择。
案例1： 在UE4中，你可以使用 FMessageDialog::Open 函数来打开一个自定义的消息对话框。以下是一个简单的示例：
#include &#34;Runtime/Engine/Public/Slate/Dialogs/MessageDialog.h&#34; void AMyTestActor::TestFMessageDialog() { FText Title = FText::FromString(&#34;My Dialog&#34;); FText Message = FText::FromString(&#34;This is a message.The UE invokes the interface and displays the Windows window.Display this information.&#34;); EAppMsgType::Type Type = EAppMsgType::OkCancel; const EAppReturnType::Type Response = FMessageDialog::Open(Type, Message, &amp;Title); if (Response == EAppReturnType::Ok) { UE_LOG(LogTemp, Log, TEXT(&#34;User clicked OK.&#34;)); // 处理用户确认... } else if (Response == EAppReturnType::Cancel) { UE_LOG(LogTemp, Log, TEXT(&#34;User clicked Cancel.&#34;)); // 处理用户取消." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ceeb2c3fbbacd1923d81ef3d576ed357/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-24T10:53:00+08:00" />
<meta property="article:modified_time" content="2023-03-24T10:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UE4如何调用打开系统消息对话窗口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>游戏开发过程中，有时需要明显的提示游戏运行时出现的问题，比如配置错误等信息，不仅需要输出错误到日记文件，还需要明显的显示错误信息给到非程序人员看到。那么打开系统窗口提示就是一个非常好的选择。</p> 
<h2>案例1：</h2> 
<p>在UE4中，你可以使用 <code>FMessageDialog::Open</code> 函数来打开一个自定义的消息对话框。以下是一个简单的示例：</p> 
<pre><code class="language-cpp">#include "Runtime/Engine/Public/Slate/Dialogs/MessageDialog.h"

void AMyTestActor::TestFMessageDialog()
{
	FText Title = FText::FromString("My Dialog");
	FText Message = FText::FromString("This is a message.The UE invokes the interface and displays the Windows window.Display this information.");
	EAppMsgType::Type Type = EAppMsgType::OkCancel;

	const EAppReturnType::Type Response = FMessageDialog::Open(Type, Message, &amp;Title);

	if (Response == EAppReturnType::Ok)
	{
		UE_LOG(LogTemp, Log, TEXT("User clicked OK."));
		// 处理用户确认...
	}
	else if (Response == EAppReturnType::Cancel)
	{
		UE_LOG(LogTemp, Log, TEXT("User clicked Cancel."));
		// 处理用户取消...
	}
}</code></pre> 
<p>在这个示例中，我们使用了 <code>FMessageDialog::Open</code> 函数来打开一个自定义的消息对话框。<code>Title</code> 参数指定了对话框显示的标题文本，<code>Message</code> 参数指定了对话框显示的消息文本。<code>Type</code> 参数指定了对话框按钮类型。</p> 
<p>如果用户单击了对话框上的“确定”按钮，则 <code>FMessageDialog::Open</code> 函数返回 <code>EAppReturnType::Ok</code>。否则，如果用户单击了“取消”按钮，则函数返回 <code>EAppReturnType::Cancel</code>。你可以使用这个返回值来处理用户的选择。</p> 
<p>效果：</p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/c6/8c/AeA39GiD_o.png" width="561"></p> 
<p> </p> 
<h2>案例2：</h2> 
<p>在UE4中，你可以使用 <code>FPlatformMisc::MessageBoxExt</code> 函数来打开系统消息对话框。以下是一个简单的示例：</p> 
<pre><code class="language-cpp">#include "Runtime/Core/Public/GenericPlatform/GenericPlatformMisc.h"

void AMyTestActor::TestMessageBoxExt()
{
	FText Message = FText::FromString("This is a message.");
	FText Title = FText::FromString("Message Box");
	EAppMsgType::Type Type = EAppMsgType::Ok;

	EAppReturnType::Type ret = FPlatformMisc::MessageBoxExt(Type, *Message.ToString(), *Title.ToString());

	switch (ret)
	{
	case EAppReturnType::Ok:
		UE_LOG(LogTemp, Log, TEXT("User clicked OK."));
		// 处理用户确认...
		break;
	case EAppReturnType::Cancel:
		UE_LOG(LogTemp, Log, TEXT("User clicked Cancel."));
		// 处理用户取消...
		break;
	}
}</code></pre> 
<p>在这个示例中，我们使用了 <code>FPlatformMisc::MessageBoxExt</code> 函数来打开一个简单的消息对话框。<code>Message</code> 参数指定了对话框显示的消息文本，<code>Title</code> 参数指定了对话框的标题。<code>Type</code> 参数指定了对话框按钮类型。</p> 
<p>如果用户单击了对话框上的“确定”按钮，则 <code>FPlatformMisc::MessageBoxExt</code> 函数返回 true。否则，它将返回 false。你可以使用这个返回值来处理用户的选择。</p> 
<p>效果：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/aa/06/0ypmgT2M_o.png" width="158"></p> 
<p> </p> 
<p></p> 
<h2>参考：</h2> 
<p>UE引擎代码：ProjectManager.cpp</p> 
<pre><code class="language-cpp">bool FProjectManager::LoadModulesForProject( const ELoadingPhase::Type LoadingPhase )
{
	DECLARE_SCOPE_CYCLE_COUNTER(TEXT("Loading Game Modules"), STAT_GameModule, STATGROUP_LoadTime);

	bool bSuccess = true;

	if ( CurrentProject.IsValid() )
	{
		TMap&lt;FName, EModuleLoadResult&gt; ModuleLoadFailures;
		FModuleDescriptor::LoadModulesForPhase(LoadingPhase, CurrentProject-&gt;Modules, ModuleLoadFailures);

		if ( ModuleLoadFailures.Num() &gt; 0 )
		{
			FText FailureMessage;
			for ( auto FailureIt = ModuleLoadFailures.CreateConstIterator(); FailureIt; ++FailureIt )
			{
				const EModuleLoadResult FailureReason = FailureIt.Value();

				if( FailureReason != EModuleLoadResult::Success )
				{
					const FText TextModuleName = FText::FromName(FailureIt.Key());

					if ( FailureReason == EModuleLoadResult::FileNotFound )
					{
						FailureMessage = FText::Format( LOCTEXT("PrimaryGameModuleNotFound", "The game module '{0}' could not be found. Please ensure that this module exists and that it is compiled."), TextModuleName );
					}
					else if ( FailureReason == EModuleLoadResult::FileIncompatible )
					{
						FailureMessage = FText::Format( LOCTEXT("PrimaryGameModuleIncompatible", "The game module '{0}' does not appear to be up to date. This may happen after updating the engine. Please recompile this module and try again."), TextModuleName );
					}
					else if ( FailureReason == EModuleLoadResult::FailedToInitialize )
					{
						FailureMessage = FText::Format( LOCTEXT("PrimaryGameModuleFailedToInitialize", "The game module '{0}' could not be successfully initialized after it was loaded."), TextModuleName );
					}
					else if ( FailureReason == EModuleLoadResult::CouldNotBeLoadedByOS )
					{
						FailureMessage = FText::Format( LOCTEXT("PrimaryGameModuleCouldntBeLoaded", "The game module '{0}' could not be loaded. There may be an operating system error, the module may not be properly set up, or a plugin which has been included into the build has not been turned on."), TextModuleName );
					}
					else
					{
						ensure(0);	// If this goes off, the error handling code should be updated for the new enum values!
						FailureMessage = FText::Format( LOCTEXT("PrimaryGameModuleGenericLoadFailure", "The game module '{0}' failed to load for an unspecified reason.  Please report this error."), TextModuleName );
					}

					// Just report the first error
					break;
				}
			}

			FMessageDialog::Open(EAppMsgType::Ok, FailureMessage);
			bSuccess = false;
		}
	}

	OnLoadingPhaseCompleteEvent.Broadcast(LoadingPhase, bSuccess);
	return bSuccess;
} </code></pre> 
<p>----</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e11a29f72b266aa1bb1d9f07baaa6676/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Autoware实车测试记录（二）-- 实车NDT定位</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03b5350e0ea840718eb2cab787a4e569/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ssh远程连接@远程文件传输scp@sftp@Linux查看ip地址的若干种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>