<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pt-archive使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pt-archive使用" />
<meta property="og:description" content="归档，在 MySQL 中，是一个相对高频的操作。
它通常涉及以下两个动作：
迁移。将数据从业务实例迁移到归档实例。删除。从业务实例中删除已迁移的数据。 在处理类似需求时，都是开发童鞋提单给 DBA，由 DBA 来处理。
于是，很多开发童鞋就好奇，DBA 都是怎么执行归档操作的？归档条件没有索引会锁表吗？安全吗，会不会数据删了，却又没归档成功？
针对这些疑问，下面介绍 MySQL 中的数据归档神器 - pt-archiver。
本文主要包括以下几部分：
什么是 pt-archiver安装简单入门实现原理批量归档不同归档参数之间的速度对比常见用法如何避免主从延迟常用参数 什么是 pt-archiver pt-archiver 是 Percona Toolkit 中的一个工具。
Percona Toolkit 是 Percona 公司提供的一个 MySQL 工具包。工具包里提供了很多实用的 MySQL 管理工具。
譬如，我们常用的表结构变更工具 pt-online-schema-change ，主从数据一致性校验工具 pt-table-checksum 。
毫不夸张地说，熟练使用 Percona Toolkit 是 MySQL DBA 必备的技能之一。
安装 Percona Toolkit 下载地址：Download Percona Toolkit
官方针对多个系统提供了现成的软件包。
我常用的是 Linux - Generic 二进制包。
下面以 Linux - Generic 版本为例，看看它的安装方法。
# cd /usr/local/# wget https://downloads.percona.com/downloads/percona-toolkit/3.3.1/binary/tarball/percona-toolkit-3.3.1_x86_64.tar.gz --no-check-certificate# tar xvf percona-toolkit-3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5844f08040c8488a0aeb2888585c35fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-07T18:07:07+08:00" />
<meta property="article:modified_time" content="2022-08-07T18:07:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pt-archive使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>归档，在 MySQL 中，是一个相对高频的操作。</p> 
<p>它通常涉及以下两个动作：</p> 
<ol><li>迁移。将数据从业务实例迁移到归档实例。</li><li>删除。从业务实例中删除已迁移的数据。</li></ol> 
<p>在处理类似需求时，都是开发童鞋提单给 DBA，由 DBA 来处理。</p> 
<p>于是，很多开发童鞋就好奇，DBA 都是怎么执行归档操作的？归档条件没有索引会锁表吗？安全吗，会不会数据删了，却又没归档成功？</p> 
<p>针对这些疑问，下面介绍 MySQL 中的数据归档神器 - pt-archiver。</p> 
<p>本文主要包括以下几部分：</p> 
<ol><li>什么是 pt-archiver</li><li>安装</li><li>简单入门</li><li>实现原理</li><li>批量归档</li><li>不同归档参数之间的速度对比</li><li>常见用法</li><li>如何避免主从延迟</li><li>常用参数</li></ol> 
<h2>什么是 pt-archiver</h2> 
<p>pt-archiver 是 Percona Toolkit 中的一个工具。</p> 
<p>Percona Toolkit 是 Percona 公司提供的一个 MySQL 工具包。工具包里提供了很多实用的 MySQL 管理工具。</p> 
<p>譬如，我们常用的表结构变更工具 pt-online-schema-change ，主从数据一致性校验工具 pt-table-checksum 。</p> 
<p>毫不夸张地说，熟练使用 Percona Toolkit 是 MySQL DBA 必备的技能之一。</p> 
<h2>安装</h2> 
<p>Percona Toolkit 下载地址：<a href="https://www.percona.com/downloads/percona-toolkit/LATEST/" rel="nofollow" title="Download Percona Toolkit">Download Percona Toolkit</a></p> 
<p></p> 
<p>官方针对多个系统提供了现成的软件包。</p> 
<p>我常用的是 Linux - Generic 二进制包。</p> 
<p>下面以 Linux - Generic 版本为例，看看它的安装方法。</p> 
<pre></pre> 
<ol><li># cd /usr/local/</li><li># wget https://downloads.percona.com/downloads/percona-toolkit/3.3.1/binary/tarball/percona-toolkit-3.3.1_x86_64.tar.gz --no-check-certificate</li><li># tar xvf percona-toolkit-3.3.1_x86_64.tar.gz</li><li># cd percona-toolkit-3.3.1</li><li># yum install perl-ExtUtils-MakeMaker perl-DBD-MySQL perl-Digest-MD5</li><li># perl Makefile.PL</li><li># make</li><li># make install</li></ol> 
<h2>简单入门</h2> 
<p>首先，我们看一个简单的归档 Demo。</p> 
<p><strong>测试数据</strong></p> 
<pre></pre> 
<ol><li>mysql&gt; show create table employees.departments\G</li><li>*************************** 1. row ***************************</li><li>Table: departments</li><li>Create Table: CREATE TABLE `departments` (</li><li>`dept_no` char(4) NOT NULL,</li><li>`dept_name` varchar(40) NOT NULL,</li><li>PRIMARY KEY (`dept_no`),</li><li>UNIQUE KEY `dept_name` (`dept_name`)</li><li>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</li><li>1 row in set (0.00 sec)</li><li><li>mysql&gt; select * from employees.departments;</li><li>+---------+--------------------+</li><li>| dept_no | dept_name |</li><li>+---------+--------------------+</li><li>| d009 | Customer Service |</li><li>| d005 | Development |</li><li>| d002 | Finance |</li><li>| d003 | Human Resources |</li><li>| d001 | Marketing |</li><li>| d004 | Production |</li><li>| d006 | Quality Management |</li><li>| d008 | Research |</li><li>| d007 | Sales |</li><li>+---------+--------------------+</li><li>9 rows in set (0.00 sec)</li></ol> 
<p>下面，我们将 employees.departments 表的数据从 192.168.244.10 归档到 192.168.244.128。</p> 
<p>具体命令如下：</p> 
<pre></pre> 
<ol><li>pt-archiver --source h=192.168.244.10,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --dest h=192.168.244.128,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --where "1=1"</li></ol> 
<p>命令行中指定了三个参数。</p> 
<ul><li> <p>--source：源库（业务实例）的 DSN。</p> <p>DSN 在 Percona Toolkit 中比较常见，可理解为目标实例相关信息的缩写。</p> <p>支持的缩写及含义如下：</p> <pre></pre> 
  <ol><li>缩写 含义</li><li>=== =============================================</li><li>A 默认的字符集</li><li>D 库名</li><li>F 只从给定文件中读取配置信息，类似于MySQL中的--defaults-file</li><li>P 端口</li><li>S 用于连接的socket文件</li><li>h 主机名</li><li>p 密码</li><li>t 表名</li><li>u 用户名</li></ol></li><li> <p>--dest：目标库（归档实例）的 DSN。</p> </li><li> <p>--where：归档条件。"1=1"代表归档全表。</p> </li></ul> 
<h2>实现原理</h2> 
<p>下面结合 General log 的输出看看 pt-archiver 的实现原理。</p> 
<p>源库日志</p> 
<pre></pre> 
<ol><li>2022-03-06T10:58:20.612857+08:00 10 Query SELECT /*!40001 SQL_NO_CACHE */ `dept_no`,`dept_name` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) ORDER BY `dept_no` LIMIT 1</li><li><li>2022-03-06T10:58:20.613451+08:00 10 Query DELETE FROM `employees`.`departments` WHERE (`dept_no` = 'd001')</li><li>2022-03-06T10:58:20.620327+08:00 10 Query commit</li><li><li>2022-03-06T10:58:20.628409+08:00 10 Query SELECT /*!40001 SQL_NO_CACHE */ `dept_no`,`dept_name` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) AND ((`dept_no` &gt;= 'd001')) ORDER BY `dept_no` LIMIT 1</li><li><li>2022-03-06T10:58:20.629279+08:00 10 Query DELETE FROM `employees`.`departments` WHERE (`dept_no` = 'd002')</li><li>2022-03-06T10:58:20.636154+08:00 10 Query commit</li><li>...</li></ol> 
<p>目标库日志</p> 
<pre></pre> 
<ol><li>2022-03-06T10:58:20.613144+08:00 18 Query INSERT INTO `employees`.`departments`(`dept_no`,`dept_name`) VALUES ('d001','Marketing')</li><li>2022-03-06T10:58:20.613813+08:00 18 Query commit</li><li><li>2022-03-06T10:58:20.628843+08:00 18 Query INSERT INTO `employees`.`departments`(`dept_no`,`dept_name`) VALUES ('d002','Finance')</li><li>2022-03-06T10:58:20.629784+08:00 18 Query commit</li><li>...</li></ol> 
<p>结合源库和目标库的日志，可以看到，</p> 
<ol><li> <p>pt-archiver 首先会从源库查询一条记录，然后再将该记录插入到目标库中。</p> <p>目标库插入成功，才会从源库中删除这条记录。</p> <p>这样就能确保数据在删除之前，一定是归档成功的。</p> </li><li> <p>仔细观察这几个操作的执行时间，其先后顺序如下。</p> <p>（1）源库查询记录。</p> <p>（2）目标库插入记录。</p> <p>（3）源库删除记录。</p> <p>（4）目标库 COMMIT。</p> <p>（5）源库 COMMIT。</p> <p>这种实现借鉴了分布式事务中的两阶段提交算法。</p> </li><li> <p>--where 参数中的 "1=1" 会传递到 SELECT 操作中。</p> <p>"1=1" 代表归档全表，也可指定其它条件，如我们常用的时间。</p> </li><li> <p>每次查询都是使用主键索引，这样即使归档条件中没有索引，也不会产生全表扫描。</p> </li><li> <p>每次删除都是基于主键，这样可避免归档条件没有索引导致全表被锁的风险。</p> </li></ol> 
<h2>批量归档</h2> 
<p>如果使用 Demo 中的参数进行归档，在数据量比较大的情况下，效率会非常低，毕竟 COMMIT 是一个昂贵的操作。</p> 
<p>所以在线上，我们通常都会进行批量操作。</p> 
<p>具体命令如下：</p> 
<pre></pre> 
<ol><li>pt-archiver --source h=192.168.244.10,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --dest h=192.168.244.128,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --where "1=1" --bulk-delete --limit 1000 --commit-each --bulk-insert</li></ol> 
<p>相对于之前的归档命令，这条命令额外指定了四个参数，其中，</p> 
<ul><li> <p>--bulk-delete：批量删除。</p> </li><li> <p>--limit：每批归档的记录数。</p> </li><li> <p>--commit-each：对于每一批记录，只会 COMMIT 一次。</p> </li><li> <p>--bulk-insert：归档数据以 LOAD DATA INFILE 的方式导入到归档库中。</p> </li></ul> 
<p>看看上述命令对应的 General log 。</p> 
<p>源库</p> 
<pre></pre> 
<ol><li>2022-03-06T12:13:56.117984+08:00 53 Query SELECT /*!40001 SQL_NO_CACHE */ `dept_no`,`dept_name` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) ORDER BY `dept_no` LIMIT 1000</li><li>...</li><li>2022-03-06T12:13:56.125129+08:00 53 Query DELETE FROM `employees`.`departments` WHERE (((`dept_no` &gt;= 'd001'))) AND (((`dept_no` &lt;= 'd009'))) AND (1=1) LIMIT 1000</li><li>2022-03-06T12:13:56.130055+08:00 53 Query commit</li></ol> 
<p>目标库</p> 
<pre></pre> 
<ol><li>2022-03-06T12:13:56.124596+08:00 51 Query LOAD DATA LOCAL INFILE '/tmp/hitKctpQTipt-archiver' INTO TABLE `employees`.`departments`(`dept_no`,`dept_name`)</li><li>2022-03-06T12:13:56.125616+08:00 51 Query commit：</li></ol> 
<p>注意：</p> 
<ol><li> <p>如果要执行 LOAD DATA LOCAL INFILE 操作，需将目标库的 local_infile 参数设置为 ON。</p> </li><li> <p>如果不指定 --bulk-insert 且没指定 --commit-each，则目标库的插入还是会像 Demo 中显示的那样，逐行提交。</p> </li><li> <p>如果不指定 --commit-each，即使表中的 9 条记录是通过一条 DELETE 命令删除的，但因为涉及了 9 条记录，pt-archiver 会执行 COMMIT 操作 9 次。目标库同样如此。</p> </li><li> <p>在使用 --bulk-insert 归档时要注意，如果导入的过程中出现问题，譬如主键冲突，pt-archiver 是不会提示任何错误的。</p> </li></ol> 
<h2>不同归档参数之间的速度对比</h2> 
<p>下表是归档 20w 数据，不同参数之间的执行时间对比。</p> 
<table><thead><tr><th>归档参数</th><th>执行时间（s）</th></tr></thead><tbody><tr><td>不指定任何批量相关参数</td><td>850.040</td></tr><tr><td>--bulk-delete --limit 1000</td><td>422.352</td></tr><tr><td>--bulk-delete --limit 1000 --commit-each</td><td>46.646</td></tr><tr><td>--bulk-delete --limit 5000 --commit-each</td><td>46.111</td></tr><tr><td>--bulk-delete --limit 1000 --commit-each --bulk-insert</td><td>7.650</td></tr><tr><td>--bulk-delete --limit 5000 --commit-each --bulk-insert</td><td>6.540</td></tr><tr><td>--bulk-delete --limit 1000 --bulk-insert</td><td>47.273</td></tr></tbody></table> 
<p>通过表格中的数据，我们可以得出以下几点：</p> 
<ol><li> <p>第一种方式是最慢的。</p> <p>这种情况下，无论是源库还是归档库，都是逐行操作并提交的。</p> </li><li> <p>只指定 --bulk-delete --limit 1000 依然很慢。</p> <p>这种情况下，源库是批量删除，但 COMMIT 次数并没有减少。</p> <p>归档库依然是逐行插入并提交的。</p> </li><li> <p>--bulk-delete --limit 1000 --commit-each</p> <p>相当于第二种归档方式，源库和目标库都是批量提交的。</p> </li><li> <p>--limit 1000 和 --limit 5000 归档性能相差不大。</p> </li><li> <p>--bulk-delete --limit 1000 --bulk-insert 与 --bulk-delete --limit 1000 --commit-each --bulk-insert 相比，没有设置 --commit-each。</p> <p>虽然都是批量操作，但前者会执行 COMMIT 操作 1000 次。</p> <p>由此来看，空事务并不是没有代价的。</p> </li></ol> 
<h2>其它常见用法</h2> 
<h3>（1）删除数据</h3> 
<p>删除数据是 pt-archiver 另外一个常见的使用场景。</p> 
<p>具体命令如下：</p> 
<pre></pre> 
<ol><li>pt-archiver --source h=192.168.244.10,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --where "1=1" --bulk-delete --limit 1000 --commit-each --purge --primary-key-only</li></ol> 
<p>命令行中的 --purge 代表只删除，不归档。</p> 
<p>指定了 --primary-key-only ，这样，在执行 SELECT 操作时，就只会查询主键，不会查询所有列。</p> 
<p>接下来，我们看看删除命令相关的 General log 。</p> 
<p>为了直观地展示 pt-archiver 删除数据的实现逻辑，实际测试时将 --limit 设置为了 3。</p> 
<pre></pre> 
<ol><li># 开启事务</li><li>set autocommit=0;</li><li><li># 查看表结构，获取主键</li><li>SHOW CREATE TABLE `employees`.`departments`;</li><li><li># 开始删除第一批数据</li><li># 通过 FORCE INDEX(`PRIMARY`) 强制使用主键</li><li># 指定了 --primary-key-only，所以只会查询主键</li><li># 这里其实无需获取所有满足条件的主键值，只取一个最小值和最大值即可。</li><li>SELECT /*!40001 SQL_NO_CACHE */ `dept_no` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) ORDER BY `dept_no` LIMIT 3;</li><li><li># 基于主键进行删除，删除的时候同时带上了 --where 指定的删除条件，以避免误删</li><li>DELETE FROM `employees`.`departments` WHERE (((`dept_no` &gt;= 'd001'))) AND (((`dept_no` &lt;= 'd003'))) AND (1=1) LIMIT 3;</li><li><li># 提交</li><li>commit;</li><li><li># 删除第二批数据</li><li>SELECT /*!40001 SQL_NO_CACHE */ `dept_no` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) AND ((`dept_no` &gt;= 'd003')) ORDER BY `dept_no` LIMIT 3;</li><li>DELETE FROM `employees`.`departments` WHERE (((`dept_no` &gt;= 'd004'))) AND (((`dept_no` &lt;= 'd006'))) AND (1=1); LIMIT 3</li><li>commit;</li><li><li># 删除第三批数据</li><li>SELECT /*!40001 SQL_NO_CACHE */ `dept_no` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) AND ((`dept_no` &gt;= 'd006')) ORDER BY `dept_no` LIMIT 3;</li><li>DELETE FROM `employees`.`departments` WHERE (((`dept_no` &gt;= 'd007'))) AND (((`dept_no` &lt;= 'd009'))) AND (1=1) LIMIT 3;</li><li>commit;</li><li><li># 删除最后一批数据</li><li>SELECT /*!40001 SQL_NO_CACHE */ `dept_no` FROM `employees`.`departments` FORCE INDEX(`PRIMARY`) WHERE (1=1) AND ((`dept_no` &gt;= 'd009')) ORDER BY `dept_no` LIMIT 3;</li><li>commit;</li></ol> 
<p>在业务代码中，如果我们有类似的删除需求，不妨借鉴下 pt-archiver 的实现方式。</p> 
<h3>（2）将数据归档到文件中</h3> 
<p>数据除了能归档到数据库，也可归档到文件中。</p> 
<p>具体命令如下：</p> 
<pre></pre> 
<ol><li>pt-archiver --source h=192.168.244.10,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --where "1=1" --bulk-delete --limit 1000 --file '/tmp/%Y-%m-%d-%D.%t'</li></ol> 
<p>指定的是 --file ，而不是 --dest。</p> 
<p>文件名使用了日期格式化符号，支持的符号及含义如下：</p> 
<pre></pre> 
<ol><li>%d Day of the month, numeric (01..31)</li><li>%H Hour (00..23)</li><li>%i Minutes, numeric (00..59)</li><li>%m Month, numeric (01..12)</li><li>%s Seconds (00..59)</li><li>%Y Year, numeric, four digits</li><li>%D Database name</li><li>%t Table name</li></ol> 
<p>生成的文件是 CSV 格式，后续可通过 LOAD DATA INFILE 命令加载到数据库中。</p> 
<h2>如何避免主从延迟</h2> 
<p>无论是数据归档还是删除，对于源库，都需要执行 DELETE 操作。</p> 
<p>很多人担心，如果删除的记录数太多，会造成主从延迟。</p> 
<p>事实上，pt-archiver 本身就具备了基于主从延迟来自动调节归档（删除）操作的能力。</p> 
<p>如果从库的延迟超过 1s（由 --max-lag 指定）或复制状态不正常，则会暂停归档（删除）操作，直到从库恢复。</p> 
<p>默认情况下，pt-archiver 不会检查从库的延迟情况。</p> 
<p>如果要检查，需通过 --check-slave-lag 显式设置从库的地址，譬如，</p> 
<pre></pre> 
<ol><li>pt-archiver --source h=192.168.244.10,P=3306,u=pt_user,p=pt_pass,D=employees,t=departments --where "1=1" --bulk-delete --limit 1000 --commit-each --primary-key-only --purge --check-slave-lag h=192.168.244.20,P=3306,u=pt_user,p=pt_pass</li></ol> 
<p>这里只会检查 192.168.244.20 的延迟情况。</p> 
<p>如果有多个从库需要检查，需将 --check-slave-lag 指定多次，每次对应一个从库。</p> 
<h2>常用参数</h2> 
<p><strong>--analyze</strong></p> 
<p>在执行完归档操作后，执行 ANALYZE TABLE 操作。</p> 
<p>后面可接任意字符串，如果字符串中含有 s ，则会在源库执行 ANALYZE 操作。</p> 
<p>如果字符串中含有 d ，则会在目标库执行 ANALYZE 操作。</p> 
<p>如果同时带有 d 和 s ，则源库和目标库都会执行 ANALYZE 操作。如，</p> 
<pre></pre> 
<ol><li>--analyze ds</li></ol> 
<pre></pre> 
<ol><li></ol> 
<p><strong>--optimize</strong></p> 
<p>在执行完归档操作后，执行 OPTIMIZE TABLE 操作。</p> 
<p>用法同 --analyze 类似。</p> 
<p><strong>--charset</strong></p> 
<p>指定连接（Connection）字符集。</p> 
<p>在 MySQL 8.0 之前，默认是 latin1。</p> 
<p>在 MySQL 8.0 中，默认是 utf8mb4 。</p> 
<p>注意，这里的默认值与 MySQL 服务端字符集 character_set_server 无关。</p> 
<p>若显式设置了该值，pt-archiver 在建立连接后，会首先执行 SET NAMES 'charset_name' 操作。</p> 
<p><strong>--[no]check-charset</strong></p> 
<p>检查源库（目标库）连接（Connection）字符集和表的字符集是否一致。</p> 
<p>如果不一致，会提示以下错误：</p> 
<pre></pre> 
<ol><li>Character set mismatch: --source DSN uses latin1, table uses gbk. You can disable this check by specifying --no-check-charset.</li></ol> 
<p>这个时候，切记不要按照提示指定  --no-check-charset 忽略检查，否则很容易导致乱码。</p> 
<p>针对上述报错，可将 --charset 指定为表的字符集。</p> 
<p>注意，该选项并不是比较源库和目标库的字符集是否一致。</p> 
<p><strong>--[no]check-columns</strong></p> 
<p>检查源表和目标表列名是否一致。</p> 
<p>注意，只会检查列名，不会检查列的顺序、列的数据类型是否一致。</p> 
<p><strong>--columns</strong></p> 
<p>归档指定列。</p> 
<p>在有自增列的情况下，如果源表和目标表的自增列存在交集，可不归档自增列，这个时候，就需要使用 --columns 显式指定归档列。</p> 
<p><strong>--dry-run</strong></p> 
<p>只打印待执行的 SQL，不实际执行。</p> 
<p>常用于实际操作之前，校验待执行的 SQL 是否符合自己的预期。</p> 
<p><strong>--ignore</strong></p> 
<p>使用 INSERT IGNORE 归档数据。</p> 
<p><strong>--no-delete</strong></p> 
<p>不删除源库的数据。</p> 
<p><strong>--replace</strong></p> 
<p>使用 REPLACE 操作归档数据。</p> 
<p><strong>--[no]safe-auto-increment</strong></p> 
<p>在归档有自增主键的表时，默认不会删除自增主键最大的那一行。</p> 
<p>这样做，主要是为了规避 MySQL 8.0 之前自增主键不能持久化的问题。</p> 
<p>在对全表进行归档时，这一点需要注意。</p> 
<p>如果需要删除，需指定 --no-safe-auto-increment 。</p> 
<p><strong>--source</strong></p> 
<p>给出源端实例的信息。</p> 
<p>除了常用的选项，其还支持如下选项：</p> 
<ul><li> <p>a：指定连接的默认数据库。</p> </li><li> <p>b：设置 SQL_LOG_BIN=0 。</p> <p>如果是在源库指定，则 DELETE 操作不会写入到 Binlog 中。</p> <p>如果是在目标库指定，则 INSERT 操作不会写入到 Binlog 中。</p> </li><li> <p>i：设置归档操作使用的索引，默认是主键。</p> </li></ul> 
<p><strong>--progress</strong></p> 
<p>显示进度信息，单位行数。</p> 
<p>如 --progress 10000，则每归档（删除）10000 行，就打印一次进度信息。</p> 
<pre></pre> 
<ol><li>TIME ELAPSED COUNT</li><li>2022-03-06T18:24:19 0 0</li><li>2022-03-06T18:24:20 0 10000</li><li>2022-03-06T18:24:21 1 20000</li></ol> 
<p>第一列是当前时间，第二列是已经消耗的时间，第三列是已归档（删除）的行数。</p> 
<h2>总结</h2> 
<p>前面，我们对比了归档操作中不同参数的执行时间。</p> 
<p>其中，--bulk-delete --limit 1000 --commit-each --bulk-insert 是最快的。不指定任何批量操作参数是最慢的。</p> 
<p>但在使用 --bulk-insert 时要注意 ，如果导入的过程中出现问题，pt-archiver 是不会提示任何错误的。</p> 
<p>常见的错误有主键冲突，数据和目标列的数据类型不一致。</p> 
<p>如果不使用 --bulk-insert，而是通过默认的 INSERT 操作来归档，大部分错误是可以识别出来的。</p> 
<p>譬如，主键冲突，会提示以下错误。</p> 
<pre></pre> 
<ol><li>DBD::mysql::st execute failed: Duplicate entry 'd001' for key 'PRIMARY' [for Statement "INSERT INTO `employees`.`departments`(`dept_no`,`dept_name`) VALUES (?,?)" with ParamValues: 0='d001', 1='Marketing'] at /usr/local/bin/pt-archiver line 6772.</li></ol> 
<p>导入的数据和目标列的数据类型不一致，会提示以下错误。</p> 
<pre></pre> 
<ol><li>DBD::mysql::st execute failed: Incorrect integer value: 'Marketing' for column 'dept_name' at row 1 [for Statement "INSERT INTO `employees`.`departments`(`dept_no`,`dept_name`) VALUES (?,?)" with ParamValues: 0='d001', 1='Marketing'] at /usr/local/bin/pt-archiver line 6772.</li></ol> 
<p>当然，数据和类型不一致，能被识别出来的前提是归档实例的 SQL_MODE 为严格模式。</p> 
<p>如果待归档的实例中有 MySQL 5.6 ，我们其实很难将归档实例的 SQL_MODE 开启为严格模式。</p> 
<p>因为 MySQL 5.6 的 SQL_MODE 默认为非严格模式，所以难免会产生很多无效数据，譬如时间字段中的 0000-00-00 00:00:00 。</p> 
<p>这种无效数据，如果插入到开启了严格模式的归档实例中，会直接报错。</p> 
<p>从数据安全的角度出发，最推荐的归档方式是：</p> 
<ol><li>先归档，但不删除源库的数据。</li><li>比对源库和归档库的数据是否一致。</li><li>如果比对结果一致，再删除源库的归档数据。</li></ol> 
<p>其中，第一步和第三步可通过 pt-archiver 搞定，第二步可通过 pt-table-sync 搞定。</p> 
<p>相对于边归档边删除的这种方式，虽然麻烦不少，但相对来说，更安全。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a13e4f1693ffa6cf5c2fb89f7459634/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用GDB&#43;QEMU调试Cosmos内核代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/faa6542b1888f5c9aa58e9f43a6aacdb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">eNSP综合实验2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>