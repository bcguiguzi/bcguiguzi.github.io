<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java线程池ThreadPoolExecutor详解及使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java线程池ThreadPoolExecutor详解及使用" />
<meta property="og:description" content="java线程池ThreadPoolExecutor的使用 在日常开发中我们经常会使用多线程，但是当线程数量达到一定程度时，频繁的创建线程、执行任务、销毁线程就会造成资源的浪费和性能的开销，那么这个时候就要考虑使用线程池了，它可以很好的避免这个问题，尤其是程序中需要创建大量的生存周期很短的线程时，更应该考虑使用线程池。
线程池的概念 线程池（ThreadPool），简单的说，它就是一个装有线程的池子，我们只需把任务（多线程执行的内容）交给线程池来处理，和数据库连接池、Http连接池的概念差不多的，通过维护一定数量的线程来达到多个线程复用的效果，同时它也能够帮我们自动管理线程的生命周期。
线程池的好处 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换提供更强大的功能，延时定时线程池。 线程池底层类ThreadPoolExcutor介绍 线程池的种类有4种，下面会讲，但是他们的底层使用的都是ThreadPoolExcutor这个类，所以只需把这个类搞懂，就基本能解决一些常规的业务了。
常用构造方法 五个参数的
/** * @param corePoolSize 线程池的核心数量 * @param maximumPoolSize 线程池的总数量 * @param keepAliveTime 在任务量大于队列长度需要需要创建的线程数量时，会创建新的临时线程，假如新创建的临时线程把队列中的任务都执行完了，那么接下来这	个临时线程并不是立即释放，而是会等待新的任务与核心线程一起去执行， * @param unit 设置等待时间的时间单位 DAYS、HOURS、MINUTES等等 * @param workQueue 阻塞队列,用于存放没有执行的任务，只存放由execute()方法提交的、实现Runnable接口的任务。 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue); 六个参数的
/** * @param corePoolSize 线程池的核心数量 * @param maximumPoolSize 线程池的总数量 * @param keepAliveTime 在任务量大于队列长度需要需要创建的线程数量时，会创建新的临时线程，假如新创建的临时线程把队列中的任务都执行完了，那么接下来这	个临时线程并不是立即释放，而是会等待新的任务与核心线程一起去执行， * @param unit 设置等待时间的时间单位 DAYS、HOURS、MINUTES等等 * @param workQueue 阻塞队列,用于存放没有执行的任务，只存放由execute()方法提交的、实现Runnable接口的任务。 * @param handler 任务拒绝策略，当任务量大于我们线程池设置的最大线程数时，那么就会触发这个拒绝策略，java中定义的拒绝策略有4中，之后给大家演示。 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler); ThreadPoolExcutor类总共有4个，熟悉以上两个常用的构造方法即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/938d2c57c5db69566eaa688d9df67674/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-06T21:14:31+08:00" />
<meta property="article:modified_time" content="2020-08-06T21:14:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java线程池ThreadPoolExecutor详解及使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="javaThreadPoolExecutor_0"></a>java线程池ThreadPoolExecutor的使用</h2> 
<blockquote> 
 <p>在日常开发中我们经常会使用多线程，但是当线程数量达到一定程度时，频繁的创建线程、执行任务、销毁线程就会造成资源的浪费和性能的开销，那么这个时候就要考虑使用线程池了，它可以很好的避免这个问题，尤其是程序中需要创建大量的生存周期很短的线程时，更应该考虑使用线程池。</p> 
</blockquote> 
<h3><a id="_4"></a>线程池的概念</h3> 
<p>线程池（ThreadPool），简单的说，它就是一个装有线程的池子，我们只需把任务（多线程执行的内容）交给线程池来处理，和数据库连接池、Http连接池的概念差不多的，通过维护一定数量的线程来达到多个线程复用的效果，同时它也能够帮我们自动管理线程的生命周期。</p> 
<h3><a id="_8"></a>线程池的好处</h3> 
<ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行</li><li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换</li><li>提供更强大的功能，延时定时线程池。</li></ul> 
<h3><a id="ThreadPoolExcutor_15"></a>线程池底层类ThreadPoolExcutor介绍</h3> 
<blockquote> 
 <p>线程池的种类有4种，下面会讲，但是他们的底层使用的都是ThreadPoolExcutor这个类，所以只需把这个类搞懂，就基本能解决一些常规的业务了。</p> 
</blockquote> 
<h4><a id="_19"></a>常用构造方法</h4> 
<p><strong>五个参数的</strong></p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @param corePoolSize 线程池的核心数量
 * @param maximumPoolSize 线程池的总数量
 * @param keepAliveTime 在任务量大于队列长度需要需要创建的线程数量时，会创建新的临时线程，假如新创建的临时线程把队列中的任务都执行完了，那么接下来这			个临时线程并不是立即释放，而是会等待新的任务与核心线程一起去执行，
 * @param unit 设置等待时间的时间单位 DAYS、HOURS、MINUTES等等
 * @param workQueue 阻塞队列,用于存放没有执行的任务，只存放由execute()方法提交的、实现Runnable接口的任务。
 */</span>
<span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          TimeUnit unit<span class="token punctuation">,</span>
                          BlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>六个参数的</strong></p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @param corePoolSize 线程池的核心数量
 * @param maximumPoolSize 线程池的总数量
 * @param keepAliveTime 在任务量大于队列长度需要需要创建的线程数量时，会创建新的临时线程，假如新创建的临时线程把队列中的任务都执行完了，那么接下来这			个临时线程并不是立即释放，而是会等待新的任务与核心线程一起去执行，
 * @param unit 设置等待时间的时间单位 DAYS、HOURS、MINUTES等等
 * @param workQueue 阻塞队列,用于存放没有执行的任务，只存放由execute()方法提交的、实现Runnable接口的任务。
 * @param handler 任务拒绝策略，当任务量大于我们线程池设置的最大线程数时，那么就会触发这个拒绝策略，java中定义的拒绝策略有4中，之后给大家演示。
 */</span>
<span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              TimeUnit unit<span class="token punctuation">,</span>
                              BlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                              RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>ThreadPoolExcutor类总共有4个，熟悉以上两个常用的构造方法即可。</p> 
</blockquote> 
<h3><a id="_61"></a>线程池的使用</h3> 
<blockquote> 
 <p>这里我就举一个简单的使用场景，用多线程去网页上下载图片。</p> 
</blockquote> 
<p>创建一个springboot项目</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootTemplateApplication</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        ConfigurableApplicationContext application <span class="token operator">=</span> SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringbootTemplateApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        DownloadPicService service <span class="token operator">=</span> application<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DownloadPicService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        service<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 往ioc容器中注入一个自定义的线程池
     * 核心线程数为30
     * 最大线程数为30
     * 临时线程等待任务时间为30s
     * 阻塞队列的长度为10
     * 拒绝策略为丢弃新任务
     * @return
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> ThreadPoolExecutor <span class="token function">threadPoolExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span>
                                     <span class="token number">30</span><span class="token punctuation">,</span>
                                     <span class="token number">30</span><span class="token punctuation">,</span>
                                     TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                     <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DownloadPicService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>DownloadPicService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//将线程池注入</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> ThreadPoolExecutor threadPoolExecutor<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">41</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

            <span class="token comment">//将任务提交到线程池，</span>
            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DownloadTask</span><span class="token punctuation">(</span><span class="token string">"https://image.baidu.com/xxxxxxxxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 这里我为了方便，直接创建的是一个静态内部类，实现 Runnable接口
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DownloadTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> String path<span class="token punctuation">;</span>    <span class="token comment">//图片地址</span>

        <span class="token keyword">public</span> <span class="token function">DownloadTask</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            FileOutputStream fos <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> IOUtils<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URI</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                String picName <span class="token operator">=</span> uuid<span class="token operator">+</span><span class="token string">".jpg"</span><span class="token punctuation">;</span>
                fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"F:\\labelTest"</span><span class="token operator">+</span>File<span class="token punctuation">.</span>separator<span class="token operator">+</span>picName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                IOUtils<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> fos<span class="token punctuation">)</span><span class="token punctuation">;</span>
                logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"图片下载成功,{}"</span><span class="token punctuation">,</span> picName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"下载图片失败，原因:{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>fos <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                            fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>启动后发现报错</p> 
</blockquote> 
<pre><code class="prism language-shell">Caused by: java.util.concurrent.RejectedExecutionException: Task com.pihao.service.DownloadPicService<span class="token variable">$DownloadTask@22f314c7</span> rejected from java.util.concurrent.ThreadPoolExecutor@4ec3005d<span class="token punctuation">[</span>Running, pool size <span class="token operator">=</span> 30, active threads <span class="token operator">=</span> 30, queued tasks <span class="token operator">=</span> 10, completed tasks <span class="token operator">=</span> 0<span class="token punctuation">]</span>
	at java.util.concurrent.ThreadPoolExecutor<span class="token variable">$AbortPolicy</span>.rejectedExecution<span class="token punctuation">(</span>ThreadPoolExecutor.java:2063<span class="token punctuation">)</span>
	at java.util.concurrent.ThreadPoolExecutor.reject<span class="token punctuation">(</span>ThreadPoolExecutor.java:830<span class="token punctuation">)</span>
	at java.util.concurrent.ThreadPoolExecutor.execute<span class="token punctuation">(</span>ThreadPoolExecutor.java:1379<span class="token punctuation">)</span>
	at com.pihao.service.DownloadPicService.start<span class="token punctuation">(</span>DownloadPicService.java:35<span class="token punctuation">)</span>
	at com.pihao.SpringbootTemplateApplication.main<span class="token punctuation">(</span>SpringbootTemplateApplication.java:20<span class="token punctuation">)</span>
	<span class="token punctuation">..</span>. 5 <span class="token function">more</span>
<span class="token comment"># 这是什么原因呢？AbortPolicy，这是我设置的线程池拒绝策略，当现有任务数量超过线程池设置的最大线程数时会触发，究其原因，是因为我执行了41个下载任务，而最大线程数设置的40，所以第41个任务就被舍弃了，拒绝执行，抛出错误，前面40个任务继续执行不受影响。</span>
</code></pre> 
<h3><a id="_173"></a>线程池的执行步骤</h3> 
<p><strong>先来看一张原理图</strong></p> 
<p><img src="https://images2.imgbox.com/42/c7/DMPwJfAn_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FAJAOHD9-1596719539105)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200806155151733.png)]"></p> 
<ul><li>首先用户提交任务到线程池，线程池判断现有的任务数量是否大于核心线程数 
  <ul><li>如果没有大于核心线程数，那么就直接使用线程池中闲置的线程来执行任务；</li><li>如果现有任务数量超过了核心线程数，并且阻塞队列中还没有放满，那么之后进来的任务就会暂时存放到阻塞队列中，等待核心线程来执行</li><li>如果现有任务数量超过了核心线程数，并且阻塞队列也已经放满了，那么就会创建新的临时线程 
    <ul><li>如果此时临时线程数量+核心线程数量没有超过最大线程数量，由新线程与核心线程一起分摊执行任务</li><li>如果此时临时线程数量+核心线程数量超过最大线程数量，就会触发任务拒绝策略，有四种，后面讲</li></ul> </li></ul> </li></ul> 
<blockquote> 
 <p>ok，执行步骤就是这样</p> 
</blockquote> 
<h3><a id="_193"></a>线程池的种类</h3> 
<h4><a id="newFixedThreadPool_195"></a>newFixedThreadPool</h4> 
<blockquote> 
 <p>固定的线程池</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                      <span class="token number">0</span>L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>特点：核心线程数和最大线程数相等，而空闲的存活时间为0毫秒，说明这个参数也没有啥意义，工作队列为最大的Integer.MAX_VALUE大小的阻塞队列。当执行任务时，如果线程都很忙，就会丢到工作队列等有空闲线程时再执行，队列满就执行默认的拒绝策略</p> 
<h4><a id="newSingleThreadExecutor_212"></a>newSingleThreadExecutor</h4> 
<blockquote> 
 <p>单例的线程池</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                    <span class="token number">0</span>L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>特点：核心线程数和最大线程数均为1，空闲的存活时间为0毫秒，工作队列也是最大的Integer.MAX_VALUE大小的阻塞队列。意味着每次执行一个线程，多余的任务先存储到工作队列，一个一个的执行，这样就保证了线程的顺序执行</p> 
<h4><a id="newCachedThreadPool_229"></a>newCachedThreadPool</h4> 
<blockquote> 
 <p>带缓冲的线程池</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                                      <span class="token number">60</span>L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>特点：核心线程数为0，最大线程数为最大值Integer.MAX_VALUE,创建的新的临时线程等待60秒后释放，SynchronousQueue这是一个直接提交的队列，意味着每个新任务都会有线程来执行，如果线程池有可用的线程则执行任务，否则就创建一个来执行，线程池中的线程数不确定，一般建议执行速度较快较小的线程，不然这个最大线程池边界过大容易造成内存溢出。</p> 
<h4><a id="newScheduledThreadPool_245"></a>newScheduledThreadPool</h4> 
<blockquote> 
 <p>调度线程池</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>
              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>特点：延时队列，支持时间控制，详细请查看它的 schedule ( ) 方法</p> 
<h3><a id="_264"></a>线程池任务拒绝策略</h3> 
<blockquote> 
 <p>之前说过，当提交的任务总数大于最大线程数时才会触发任务拒绝策略，java中的定义的策略有4中，分别如下</p> 
</blockquote> 
<h4><a id="AbortPolicy_268"></a>AbortPolicy</h4> 
<p>这个是最简单的，直接拒绝后面提交的任务，并抛出拒绝异常</p> 
<h4><a id="DiscardPolicy_272"></a>DiscardPolicy</h4> 
<p>后面的任务不做任务处理，不执行，也不抛出异常</p> 
<h4><a id="DiscardOldestPolicy_276"></a>DiscardOldestPolicy</h4> 
<p>丢弃最老的任务，就是从队列中取出最老的任务，然后放入新进来的任务执行</p> 
<h4><a id="CallerRunsPolicy_280"></a>CallerRunsPolicy</h4> 
<p>如果线程池未关闭，则调用主线程来帮忙执行新的任务，这也会导致主线程效率</p> 
<h3><a id="_284"></a>总结</h3> 
<blockquote> 
 <p>线程以及线程池这一块面试必问，躲不掉的！！！重点是线程池的执行步骤那一部分。与其每次侥幸心理背面试题还不如静下心来好好把它理解透彻，事半功倍。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7f4a20978642bd4297ebdaecb6c8d5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pandas两列转换成字典的健和值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2a207304309b1e3a5f5b3b33d5a7e95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言总结（郝斌笔记）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>