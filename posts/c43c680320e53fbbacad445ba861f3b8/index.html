<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenGL with QtWidgets：练习之绘制2D环形进度条 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenGL with QtWidgets：练习之绘制2D环形进度条" />
<meta property="og:description" content="1.实现思路 这里主要涉及几个点：绘制圆环，绘制文字，动画，抗锯齿。
绘制圆环网上有些人是计算好圆边的顶点后传入的，我这里直接在片段着色器里根据距离圆心的距离来渲染的圆环。
void main() { float len = abs(sqrt(pow(thePos.x,2)&#43;pow(thePos.y,2))); float alpha = abs(len-0.75); alpha = (alpha&gt;0.15)?0.0:1.0; FragColor = vec4(0.4,0.1,0.6,alpha); } 绘制文字的话，网上有的人是先绘制到纹理上再渲染问题，不过 Qt 的 QOpenGLWidget 类可以配合 QPianter 使用。因为是 2D，我直接使用 QPianter 绘制的文字。这里面也遇到问题，就是 QPainter 绘制的文字和在别的画布上呈现的效果不一样，最后选择的微软雅黑效果才好点。
void CircleProgressBar::paintGL() { QPainter painter(this); painter.setPen(Qt::white); painter.setFont(QFont(&#34;Microsoft YaHei&#34;,16)); const QString text_val=QString::number(progress*100,&#39;f&#39;,2)&#43;&#34; %&#34;; const int text_x=width()/2-painter.fontMetrics().width(text_val)/2; const int text_y=height()/2&#43;painter.fontMetrics().height()/2; painter.drawText(text_x,text_y,text_val); } 动画我使用的属性动画而不是 QTimer，让 Qt 来决定刷新的时机。
抗锯齿我参照了网上的一些方式，比如多重采样什么的都没效果，最后用的 smoothstep 函数来实现的圆环部分的抗锯齿。
（参照：Shader smoothstep使用_冠位仓鼠--慕白-CSDN博客_smoothstep）
void main() { float len = abs(sqrt(pow(thePos.x,2)&#43;pow(thePos.y,2))); //float alpha = 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c43c680320e53fbbacad445ba861f3b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-10T22:04:33+08:00" />
<meta property="article:modified_time" content="2020-05-10T22:04:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenGL with QtWidgets：练习之绘制2D环形进度条</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.实现思路</h2> 
<p>这里主要涉及几个点：绘制圆环，绘制文字，动画，抗锯齿。</p> 
<p>绘制圆环网上有些人是计算好圆边的顶点后传入的，我这里直接在片段着色器里根据距离圆心的距离来渲染的圆环。</p> 
<pre><code class="language-cpp">void main()
{
    float len = abs(sqrt(pow(thePos.x,2)+pow(thePos.y,2)));
    float alpha = abs(len-0.75);
    alpha = (alpha&gt;0.15)?0.0:1.0;
    FragColor = vec4(0.4,0.1,0.6,alpha);
}</code></pre> 
<p>绘制文字的话，网上有的人是先绘制到纹理上再渲染问题，不过 Qt 的 QOpenGLWidget 类可以配合 QPianter 使用。因为是 2D，我直接使用 QPianter 绘制的文字。这里面也遇到问题，就是 QPainter 绘制的文字和在别的画布上呈现的效果不一样，最后选择的微软雅黑效果才好点。</p> 
<pre><code class="language-cpp">void CircleProgressBar::paintGL()
{
    QPainter painter(this);
    painter.setPen(Qt::white);
    painter.setFont(QFont("Microsoft YaHei",16));
    const QString text_val=QString::number(progress*100,'f',2)+" %";
    const int text_x=width()/2-painter.fontMetrics().width(text_val)/2;
    const int text_y=height()/2+painter.fontMetrics().height()/2;
    painter.drawText(text_x,text_y,text_val);
}</code></pre> 
<p>动画我使用的属性动画而不是 QTimer，让 Qt 来决定刷新的时机。</p> 
<p>抗锯齿我参照了网上的一些方式，比如多重采样什么的都没效果，最后用的 smoothstep 函数来实现的圆环部分的抗锯齿。</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/3f/3f/q8v3p2Fi_o.png" width="730"></p> 
<p>（参照：<a href="https://blog.csdn.net/u010333737/article/details/82859246" title="Shader smoothstep使用_冠位仓鼠--慕白-CSDN博客_smoothstep">Shader smoothstep使用_冠位仓鼠--慕白-CSDN博客_smoothstep</a>）</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/ab/11/AKMoUk6D_o.png" width="741"></p> 
<pre><code class="language-cpp">void main()
{
    float len = abs(sqrt(pow(thePos.x,2)+pow(thePos.y,2)));
    //float alpha = 1.0-smoothstep(0.15,0.15+aSmoothWidth,abs(len-0.75));
    float alpha = smoothstep(0.15+aSmoothWidth,0.15,abs(len-0.75));
    FragColor = vec4(0.4,0.1,0.6,alpha);
}</code></pre> 
<p>色条上的锯齿用的 smoothstep 配合 mix 消除。</p> 
<p>（题外话，我开始以为 GLSL 没有 atan2 函数，哪成想他的 atan 有个重载版本就是 atan2 的功能；此外，OpenGL 和 OpenGL ES  的 GLSL 在语法上有一些小的区别，有点坑） </p> 
<p>（2021-5-4）修改了进度值为 0 时因为 smoothstep 导致还有一条横线的 bug，增加了进度大于零的判断。</p> 
<h2>2.实现代码</h2> 
<p>（项目 git 链接：<a href="https://github.com/gongjianbo/EasyOpenGL2D" title="https://github.com/gongjianbo/EasyOpenGL2D">https://github.com/gongjianbo/EasyOpenGL2D</a>）</p> 
<p>实现效果（GIF）：</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/b3/c8/gD0w2buH_o.gif" width="213"></p> 
<p>主要实现代码：</p> 
<pre><code class="language-cpp">#ifndef CIRCLEPROGRESSBAR_H
#define CIRCLEPROGRESSBAR_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;

#include &lt;QPropertyAnimation&gt;

//龚建波：环形进度条
class CircleProgressBar : public QOpenGLWidget, protected QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
    Q_PROPERTY(double drawValue READ getDrawValue WRITE setDrawValue)
public:
    explicit CircleProgressBar(QWidget *parent = nullptr);
    ~CircleProgressBar();

    void setRange(double min,double max);
    void setValue(double value);

    double getDrawValue() const;
    void setDrawValue(double value);

protected:
    //设置OpenGL资源和状态。在第一次调用resizeGL或paintGL之前被调用一次
    void initializeGL() override;
    //渲染OpenGL场景，每当需要更新小部件时使用
    void paintGL() override;
    //设置OpenGL视口、投影等，每当尺寸大小改变时调用
    void resizeGL(int width, int height) override;

private:
    //着色器程序
    QOpenGLShaderProgram shaderProgram;
    //顶点数组对象
    QOpenGLVertexArrayObject vao;
    //顶点缓冲
    QOpenGLBuffer vbo;
    //属性动画
    QPropertyAnimation *animation;
    //进度值
    double progressMin=0;
    double progressMax=100;
    double progressValue=0; //设置的值
    double progressDraw=0; //绘制临时值
};

#endif // CIRCLEPROGRESSBAR_H
</code></pre> 
<pre><code class="language-cpp">#include "CircleProgressBar.h"

#include &lt;QPainter&gt;
#include &lt;QDebug&gt;

CircleProgressBar::CircleProgressBar(QWidget *parent)
    : QOpenGLWidget(parent)
{
    animation=new QPropertyAnimation(this,"drawValue");
    animation-&gt;setDuration(2000); //动画持续时间
    animation-&gt;setEasingCurve(QEasingCurve::OutQuart); //先快后慢
}

CircleProgressBar::~CircleProgressBar()
{
    makeCurrent();
    vbo.destroy();
    vao.destroy();
    doneCurrent();
}

void CircleProgressBar::setRange(double min, double max)
{
    if(progressMax&lt;=progressMin)
        return;
    progressMin=min;
    progressMax=max;
}

void CircleProgressBar::setValue(double value)
{
    if(value&lt;progressMin||value&gt;progressMax)
        return;
    progressDraw=progressValue;
    progressValue=value;

    animation-&gt;setStartValue(progressDraw);
    animation-&gt;setEndValue(progressValue);
    animation-&gt;start();
}

double CircleProgressBar::getDrawValue() const
{
    return progressDraw;
}

void CircleProgressBar::setDrawValue(double value)
{
    progressDraw=value;
    update();
}

void CircleProgressBar::initializeGL()
{
    //为当前上下文初始化OpenGL函数解析
    initializeOpenGLFunctions();

    //着色器代码
    //in输入，out输出,uniform从cpu向gpu发送
    //[aPos]两个三角的顶点数据
    //[thePos]表示当前像素点
    const char *vertex_str=R"(#version 330 core
                           layout (location = 0) in vec2 aPos;
                           out vec2 thePos;
                           void main()
                           {
                             gl_Position = vec4(aPos, 0.0, 1.0);
                             thePos = aPos;
                           })";
    //GLSL的atan2也叫atan，不过参数不同，我们封装一个0-360度的归一化值[0,1]的版本
    //[FragColor]该点输出颜色，gl_FragColor在3移除了，自己声明一个
    //[aValue]进度值
    //[aSmoothWidth]用来计算平滑所需宽度，根据绘制区域大小来计算
    //[len]坐标点距离圆心的距离,[0,1]，勾股定理
    //[alpha]使用smoothstep平滑函数取0.75±0.15的圆圈透明度为1
    //[angle]thePos像素点对应的角度值，用于调节渐变，归一化到[0，1]
    //[angle_smooth]进度值那条斜线取平滑
    //[ret smoothstep(a,b,x)]可以用来生成0-1的平滑过渡，达到抗锯齿效果
    //返回0: x&lt;a&lt;b 或者 x&gt;a&gt;b
    //返回1: x&lt;b&lt;a 或者 x&gt;b&gt;a
    //返回n: 根据x在ab间位置，返回[0,1]过度值
    const char *fragment_str=R"(#version 330 core
                             #define PI 3.14159265
                             uniform float aValue;
                             uniform float aSmoothWidth;
                             in vec2 thePos;
                             out vec4 FragColor;

                             float myatan2(float y,float x)
                             {
                               float ret_val = 0.0;
                               if(x != 0.0){
                                 ret_val = atan(y,x);
                                 if(ret_val &lt; 0.0){
                                   ret_val += 2.0*PI;
                                 }
                               }else{
                                 ret_val = y&gt;0 ? PI*0.5 : PI*1.5;
                               }
                               return ret_val/(2.0*PI);
                             }

                             void main()
                             {
                             float len = abs(sqrt(pow(thePos.x,2.0)+pow(thePos.y,2.0)));
                             float alpha = smoothstep(0.15+aSmoothWidth,0.15,abs(len-0.75));
                             float angle = myatan2(thePos.y,thePos.x);
                             float angle_smooth = smoothstep(aValue+aSmoothWidth/3.0,aValue,angle);

                             if(angle_smooth&gt;0.0 &amp;&amp; aValue&gt;0.0){
                               if(angle_smooth&gt;=1.0){
                                 FragColor = vec4(1.0,0.1,(1.0-angle),alpha);
                               }else{
                                 FragColor = vec4(mix(vec3(1.0,0.1,(1.0-angle)),vec3(0.4,0.1,0.6),1.0-angle_smooth),alpha);
                               }
                             }else{
                               FragColor = vec4(0.4,0.1,0.6,alpha);
                             }
                             })";


    //将source编译为指定类型的着色器，并添加到此着色器程序
    if(!shaderProgram.addCacheableShaderFromSourceCode(
                QOpenGLShader::Vertex,vertex_str)){
        qDebug()&lt;&lt;"compiler vertex error"&lt;&lt;shaderProgram.log();
    }
    if(!shaderProgram.addCacheableShaderFromSourceCode(
                QOpenGLShader::Fragment,fragment_str)){
        qDebug()&lt;&lt;"compiler fragment error"&lt;&lt;shaderProgram.log();
    }
    //使用addShader()将添加到该程序的着色器链接在一起。
    if(!shaderProgram.link()){
        qDebug()&lt;&lt;"link shaderprogram error"&lt;&lt;shaderProgram.log();
    }

    //两个三角拼接的一个矩形
    const float vertices[] = {
        -1.0f, -1.0f, //左下角
        +1.0f, -1.0f, //右下角
        +1.0f, +1.0f, //右上角

        +1.0f, +1.0f, //右上角
        -1.0f, +1.0f, //左上角
        -1.0f, -1.0f, //左下角
    };
    vao.create();
    vao.bind();
    vbo=QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo.create();
    vbo.bind();
    vbo.allocate(vertices,sizeof(vertices));

    // position attribute
    int attr = -1;
    attr = shaderProgram.attributeLocation("aPos");
    //setAttributeBuffer(int location, GLenum type, int offset, int tupleSize, int stride = 0)
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 2, sizeof(GLfloat) * 2);
    shaderProgram.enableAttributeArray(attr);
}

void CircleProgressBar::paintGL()
{
    //以短边为边长，保持比例，Qt这里有个问题，在resize里设置的没用
    const int item_w=width()&gt;height()?height():width();
    glViewport((width()-item_w)/2,
               (height()-item_w)/2,
               item_w,
               item_w);

    glClearColor(0.1f, 0.2f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glEnable(GL_BLEND);
    //基于源像素Alpha通道值的半透明混合函数
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
    //开启多重采样抗锯齿，貌似没啥效果
    //glEnable(GL_MULTISAMPLE);

    shaderProgram.bind();
    //把进度[min,max]归一化[0,1]
    const float progress=(progressDraw-progressMin)/(progressMax-progressMin);
    qDebug()&lt;&lt;"draw progress"&lt;&lt;progress;
    shaderProgram.setUniformValue("aValue", progress);
    //aSmoothWidth用来计算平滑所需宽度，根据不同的大小来计算，这里用N px的宽度
    shaderProgram.setUniformValue("aSmoothWidth", float(3.0/item_w));
    vao.bind();

    glDrawArrays(GL_TRIANGLES, 0, 6);

    vao.release();
    shaderProgram.release();

    //目前文字用QPainter绘制
    QPainter painter(this);
    painter.setPen(Qt::white);
    painter.setFont(QFont("Microsoft YaHei",16));
    const QString text_val=QString::number(progress*100,'f',2)+" %";
    const int text_x=width()/2-painter.fontMetrics().width(text_val)/2;
    const int text_y=height()/2+painter.fontMetrics().height()/2;
    painter.drawText(text_x,text_y,text_val);
}

void CircleProgressBar::resizeGL(int width, int height)
{
    //以短边为边长，保持比例，Qt这里有个问题，在resize里设置的没用
    const int item_w=width&gt;height?height:width;
    glViewport((width-item_w)/2,
               (height-item_w)/2,
               item_w,
               item_w);
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07ed3d29535ffb84ee188fd5af938a2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vs2019整理代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce3eb576a5a7f21be96e6b9ccb54251b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Fiddler常用QuickExec命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>