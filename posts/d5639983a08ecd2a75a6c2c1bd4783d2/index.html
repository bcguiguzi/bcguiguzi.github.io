<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>玩转Jetson nano系列（2）：结合ncnn的实时yolov2目标检测 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="玩转Jetson nano系列（2）：结合ncnn的实时yolov2目标检测" />
<meta property="og:description" content="结合上篇玩转Jetson nano系列（1），在jetson安装好ncnn，就可以开发各种模型了。
上篇最后提到，可以通过在ncnn根目录下修改CMakefile.txt文件，去掉examples的编译注释，就可以编译出ncnn自带的模型。
一. 修改自带yolov2源码 因为自带yolov2是基于mobilenet的，而且只支持图片检测，为了让模型支持cam的实时检测，因此需要对自带的源码进行修改。
进入自带模型源码文件夹：
并备份得到新的yolov2_cam.cpp
cd ~/ncnn/examples cp yolov2.cpp yolov2_cam.cpp 打开修改yolov2_cam.cpp
vim yolov2_cam.cpp 因为我用的是树莓派cam，设置cam参数：
这里参考自：
https://github.com/JetsonHacksNano/CSI-Camera
std::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) { return &#34;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)&#34; &#43; std::to_string(capture_width) &#43; &#34;, height=(int)&#34; &#43; std::to_string(capture_height) &#43; &#34;, format=(string)NV12, framerate=(fraction)&#34; &#43; std::to_string(framerate) &#43; &#34;/1 ! nvvidconv flip-method=&#34; &#43; std::to_string(flip_method) &#43; &#34; ! video/x-raw, width=(int)&#34; &#43; std::to_string(display_width) &#43; &#34;, height=(int)&#34; &#43; std::to_string(display_height) &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d5639983a08ecd2a75a6c2c1bd4783d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-04T21:38:51+08:00" />
<meta property="article:modified_time" content="2019-08-04T21:38:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">玩转Jetson nano系列（2）：结合ncnn的实时yolov2目标检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>结合上篇玩转Jetson nano系列（1），在jetson安装好ncnn，就可以开发各种模型了。</p> 
<p>上篇最后提到，可以通过在ncnn根目录下修改CMakefile.txt文件，去掉examples的编译注释，就可以编译出ncnn自带的模型。</p> 
<h3><a id="_yolov2_4"></a>一. 修改自带yolov2源码</h3> 
<p>因为自带yolov2是基于mobilenet的，而且只支持图片检测，为了让模型支持cam的实时检测，因此需要对自带的源码进行修改。</p> 
<p>进入自带模型源码文件夹：<br> 并备份得到新的yolov2_cam.cpp</p> 
<pre><code>cd ~/ncnn/examples
cp yolov2.cpp yolov2_cam.cpp
</code></pre> 
<p>打开修改yolov2_cam.cpp</p> 
<pre><code>vim yolov2_cam.cpp
</code></pre> 
<p>因为我用的是树莓派cam，设置cam参数：</p> 
<p>这里参考自：</p> 
<blockquote> 
 <p><a href="https://github.com/JetsonHacksNano/CSI-Camera">https://github.com/JetsonHacksNano/CSI-Camera</a></p> 
</blockquote> 
<pre><code>std::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) {
    return "nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)" + std::to_string(capture_width) + ", height=(int)" +
           std::to_string(capture_height) + ", format=(string)NV12, framerate=(fraction)" + std::to_string(framerate) +
           "/1 ! nvvidconv flip-method=" + std::to_string(flip_method) + " ! video/x-raw, width=(int)" + std::to_string(display_width) + ", height=(int)" +
           std::to_string(display_height) + ", format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink";
}

</code></pre> 
<p>通过配置gstreamer_pipeline可以修改cam的分辨率和fps</p> 
<pre><code>std::string pipeline = gstreamer_pipeline(capture_width,
        capture_height,
        display_width,
        display_height,
        framerate,
        flip_method);

</code></pre> 
<p>因为这里不再需要输入图片，通过cam，所以关于图片传入的部分可以去掉，于是整个代码如下：</p> 
<pre><code># 头文件加一下 #include &lt;iostream&gt;
int main(int argc, char** argv)
{

    int capture_width = 480 ;
    int capture_height = 360 ;
    int display_width = 480 ;
    int display_height = 360 ;
    int framerate = 30 ;
    int flip_method = 0 ;

    std::string pipeline = gstreamer_pipeline(capture_width,
        capture_height,
        display_width,
        display_height,
        framerate,
        flip_method);
    std::cout &lt;&lt; "Using pipeline: \n\t" &lt;&lt; pipeline &lt;&lt; "\n";

    cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER);
    if(!cap.isOpened()) {
        std::cout&lt;&lt;"Failed to open camera."&lt;&lt;std::endl;
        return (-1);
    }

    cv::namedWindow("CSI Camera", cv::WINDOW_AUTOSIZE);
    cv::Mat img;

    std::cout &lt;&lt; "Hit ESC to exit" &lt;&lt; "\n" ;

    #if NCNN_VULKAN
    ncnn::create_gpu_instance();
    #endif // NCNN_VULKAN
    
    while(true)
    {
        if (!cap.read(img)) {
                std::cout&lt;&lt;"Capture read error"&lt;&lt;std::endl;
                break;
        }
        
        std::vector&lt;Object&gt; objects;
        detect_yolov2(img, objects);

        draw_objects(img, objects);

        int keycode = cv::waitKey(30) &amp; 0xff ;
        if (keycode == 27) break ;
    }

    cap.release();
    cv::destroyAllWindows() ;

    #if NCNN_VULKAN
    ncnn::destroy_gpu_instance();
    #endif // NCNN_VULKAN

    return 0;
}

</code></pre> 
<p>同时，实时显示目标检测框和label的部分也要改下，去掉下面部分：</p> 
<pre><code># draw_objects() 函数内
cv::waitKey(0);
</code></pre> 
<p>另外，我在detect_yolov2函数里改了下模型的路径，方便文件管理：</p> 
<pre><code>yolov2.load_param("model/mobilenet_yolo.param");
yolov2.load_model("model/mobilenet_yolo.bin");
</code></pre> 
<p>这样，基本就改完了。</p> 
<h3><a id="_121"></a>二.代码编译</h3> 
<p>在编译前，修改examples下的CMakefiles.txt，添加需要编译的yolov2_cam，如下：</p> 
<pre><code>add_executable(yolov2_cam yolov2_cam.cpp)
target_link_libraries(yolov2_cam ${NCNN_EXAMPLE_LINK_LIBRARIES})
</code></pre> 
<p>同理，以后要编译自己的其他模型，在CMakefiles.txt里这样添加就行。</p> 
<p>在玩转Jetson nano系列（1）编译完成的基础上，进入编译文件夹，如：</p> 
<pre><code>cd ~/ncnn/build
make -j4
</code></pre> 
<p>就会把新改的代码编译完成。</p> 
<p>进入生成文件夹的目录</p> 
<pre><code>cd examples
</code></pre> 
<p>还记得之前改了模型的存放位置吧，把模型放在相应位置就行，如果没改就放在当前位置。</p> 
<p>感谢下这位博主的分享，文末有模型链接：<br> <a href="https://blog.csdn.net/sinat_31425585/article/details/83243961">文末有下载链接，嗯</a></p> 
<h3><a id="_148"></a>三.测试实现</h3> 
<p>保证cam和模型都没问题的情况下，就可以执行了：</p> 
<pre><code>./yolov2_cam
</code></pre> 
<p>报什么问题的话，在ncnn/examples下修改代码，然后在build下重新编译就行了。</p> 
<p>Esc键退出</p> 
<p>测试效果如下：<br> <img src="https://images2.imgbox.com/71/36/OLTIUF9c_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41ae8f8e50d639b5b41ac03430eb78e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">玩转Jetson nano系列（1）：Jetson nano编译安装ncnn</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44deabf3adceaefd02ad6fa6bd532aa2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pandas透视表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>