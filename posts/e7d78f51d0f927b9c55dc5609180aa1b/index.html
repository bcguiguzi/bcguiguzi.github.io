<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UniTask异步解决方案 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UniTask异步解决方案" />
<meta property="og:description" content="是一个高性能，0GC的async/await异步方案
协程缺点：
依赖monobehaviour
不能进行异常处理
方法返回值获取困难
c#原生Task：
优点：
不依赖monobehaviour
可以处理异常
缺点：
Task消耗大，设计跨线程操作
uniTask
优点:
继承c#的task优点
基于值类型解决方案，0GC
默认使用主协程
https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask
延时操作：Delay DelayFrame Yield NextFrame WaitForEndOfFrame
等待操作: Wait Until Wait Until Value Changed
条件操作: When All When Any
异步委托生成UniTask及相关的封装: UniTask.Void UniTask.Defer UniTask.Lazy
取消：CancellationToken GetCancellationTokenOnDeatory()
异常处理：Try Catch SuppressCancellationThrow
超时处理：取消的变种，通过 CancellationTokenSouce.CancelAfterSlim(TimeSpan)设置超时并将CancellationToken 传递给异步方法
Forget()
事件处理：
1.异步事件 Lamaba 表达式注册 使用 UniTask.Action 或 UniTask.UnityAction
2.UGUI 事件转换为可等待事件
AsAsyncEnumerable
3.MonoBehaviour 消息事件都可以转换异步流
异步Linq
异步迭代器
响应式组件
协程和task
void Start() { StartCoroutine(waitting()); } Ienumerator waitting() { yield return new waitForSeconds(2); } using System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e7d78f51d0f927b9c55dc5609180aa1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-01T15:13:02+08:00" />
<meta property="article:modified_time" content="2023-12-01T15:13:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UniTask异步解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>是一个高性能，0GC的async/await异步方案</p> 
<blockquote> 
 <p><strong>协程缺点：</strong></p> 
 <p>依赖monobehaviour</p> 
 <p>不能进行异常处理</p> 
 <p>方法返回值获取困难</p> 
 <p><strong>c#原生Task：</strong></p> 
 <p>优点：</p> 
 <p>不依赖monobehaviour</p> 
 <p>可以处理异常</p> 
 <p>缺点：</p> 
 <p>Task消耗大，设计跨线程操作</p> 
 <p><strong>uniTask</strong></p> 
 <p>优点:</p> 
 <p>继承c#的task优点</p> 
 <p>基于值类型解决方案，0GC</p> 
 <p>默认使用主协程</p> 
</blockquote> 
<p> <a href="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask" title="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask">https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</a></p> 
<blockquote> 
 <p>延时操作：Delay DelayFrame Yield NextFrame WaitForEndOfFrame</p> 
 <p>等待操作: Wait Until Wait Until Value Changed</p> 
 <p>条件操作: When All When Any</p> 
 <p>异步委托生成UniTask及相关的封装: UniTask.Void UniTask.Defer UniTask.Lazy</p> 
 <p>取消：CancellationToken GetCancellationTokenOnDeatory()</p> 
 <p>异常处理：Try Catch SuppressCancellationThrow</p> 
 <p>超时处理：取消的变种，通过 CancellationTokenSouce.CancelAfterSlim(TimeSpan)设置超时并将CancellationToken 传递给异步方法</p> 
 <p>Forget()</p> 
 <p>事件处理：</p> 
 <p>1.异步事件 Lamaba 表达式注册 使用 UniTask.Action 或 UniTask.UnityAction</p> 
 <p>2.UGUI 事件转换为可等待事件</p> 
 <p>AsAsyncEnumerable</p> 
 <p>3.MonoBehaviour 消息事件都可以转换异步流</p> 
 <p>异步Linq</p> 
 <p>异步迭代器</p> 
 <p>响应式组件</p> 
</blockquote> 
<p> 协程和task</p> 
<pre><code class="language-cs">void Start()
{
    StartCoroutine(waitting());
}
Ienumerator waitting()
{
    yield return new waitForSeconds(2);
}</code></pre> 
<p></p> 
<pre><code class="language-cs">using System.Threading.Tasks;
using UnityEngine;

public class Zero :MonoBehaviour 
{
    async void Start()
    {
        await DealTest();   
    }
    async Task&lt;int&gt; DealTest()
    {
        Debug.Log(Time.time);
        await Task.Delay(100);
        Debug.Log(Time.time);
        return 1;
    }
}</code></pre> 
<p>延迟操作的API、Dealy方法、方法的重载及参数作用</p> 
<blockquote> 
 <p>UniTask.Delay                   延迟秒</p> 
 <p>UniTask.DelayFrame         延迟帧</p> 
 <p>UniTask.NextFrame          等待一帧</p> 
 <p>UniTask.Yield                    等待一帧，用于处理转回主线程用。yield之前再其他线程跑，yield之后回到主线程跑。</p> 
</blockquote> 
<p></p> 
<pre><code class="language-cs">Time.timeScale=0F;
//等待时间，是否忽略时间缩放的影响(即便时间缩放为0但依然执行等待并向下执行，但是Time.time会受到影响)，
await UniTask.Delay(1000,true);</code></pre> 
<p>WaitUntil等方法</p> 
<blockquote> 
 <p>WaitUntil</p> 
 <p>//知道达到------才执行</p> 
 <p>//等到指定对象的参数发生变化时 参数目标 判断方法的委托 如果返回值变化的话 就发生变化</p> 
 <p>//WaitUntilValueChanged</p> 
 <p>//等到指定对象的参数发生变化时，才完成。</p> 
</blockquote> 
<pre><code class="language-cs">using Cysharp.Threading.Tasks;
using UnityEngine;

public class Two : MonoBehaviour
{
    public GameObject ball;
    void Start()
    {
        WaitUtilTest();
        WaitUntilValueTest();
    }
    void Update()
    {
        ball.transform.Translate(new Vector3(1,0,0)*Time.deltaTime);
    }
    async void WaitUtilTest()
    {
 
        await UniTask.WaitUntil(()=&gt;isFarThanOne());//等到小球的x轴大于1后再执行方法的语句
        ball.GetComponent&lt;Renderer&gt;().material.color = Color.red;
    }
    public bool isFarThanOne()
    {
        if (ball.transform.position .x&gt;1)
        {
            return true;
        }
        return false;
    }
    //如果小球的x轴变化就输出“小球值的变化”
    async void WaitUntilValueTest()
    {
        await UniTask.WaitUntilValueChanged(ball.transform,x=&gt;x.position);
        Debug.Log("小球值的变化");
    }
}</code></pre> 
<p> WhenAll方法</p> 
<blockquote> 
 <p>当两个小球都达到1的时候，就执行等待函数代码</p> 
</blockquote> 
<pre><code class="language-cs">using Cysharp.Threading.Tasks;
using UnityEngine;

public class Three : MonoBehaviour
{
    public GameObject ball1;
    public GameObject ball2;
    void Start()
    {
        TestWhenAll();
    }
    void Update()
    {
        ball1.transform.Translate(new Vector3(1, 0, 0) * Time.deltaTime);
        ball2.transform.Translate(new Vector3(1, 0, 0) * Time.deltaTime * 0.5f);

    }
    async void TestWhenAll()
    {
        UniTask task1 = UniTask.WaitUntil(() =&gt; ball1.transform.position.x &gt; 1);
        UniTask task2 = UniTask.WaitUntil(() =&gt; ball2.transform.position.x &gt; 1);

        await UniTask.WhenAll(task1, task2);
        string str = $"ball1:{ball1.transform.position.x},ball2:{ball2.transform.position.x}";
        Debug.Log(str);
    }
}</code></pre> 
<p></p> 
<p>WhenAny方法</p> 
<blockquote> 
 <p>只有其中一个任务完成了就执行等待的方法</p> 
</blockquote> 
<p></p> 
<pre><code class="language-cs">using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;

public class Four : MonoBehaviour
{
    public Button btn1;
    public Button btn2;
    public bool isClick1;
    public bool isClick2;
    void Start()
    {
        btn1.onClick.AddListener(() =&gt; Click1());
        btn2.onClick.AddListener(() =&gt; Click2());
        AllBtnClick();
    }
    public void Click1()
    {
        isClick1 = true;
    }
    public void Click2()
    {
        isClick2 = true;
    }
    async void AllBtnClick()
    {
        UniTask task1 = UniTask.WaitUntil(() =&gt; isClick1);
        UniTask task2 = UniTask.WaitUntil(() =&gt; isClick2);

        await UniTask.WhenAny(task1, task2);//uniTask 不能await两次
        Debug.Log("11");
    }
}
</code></pre> 
<p></p> 
<p>Defer</p> 
<blockquote> 
 <p>UniTask.Void 参数异步委托 直接启动一个异步委托 不考虑其等待 无需加await</p> 
 <p>UniTask.Defer 用异步委托快速生成返回UniTask的异步方法，必须加await 才能执行</p> 
</blockquote> 
<pre><code class="language-cs">void Start
{
    UniTask.Void(async () =&gt;
    {
         Debug.Log("start" + Time.frameCount);
         await UniTask.NextFrame();
          Debug.Log("end" + Time.frameCount);
    });
}</code></pre> 
<p></p> 
<pre><code class="language-cs">void Start()
{
    await UniTask.Defer(async () =&gt;
    {
         Debug.Log("start" + Time.frameCount);
         await UniTask.NextFrame();
          Debug.Log("end" + Time.frameCount);
    });
}</code></pre> 
<p>协程与uniTask的转换</p> 
<blockquote> 
 <p>一些需要用到等待的unity对戏提供GetAwaiter()功能，从而拿到Awaiter对戏就可以进行await了。UniTask已经对各种各样的unity对戏进行了GetAwaiter的扩展。</p> 
 <p>1.Coroutine的等待及UniTask的转换</p> 
 <p>2.AsyncOperation的等待 如场景异步加载 资源异步加载 网络请求</p> 
 <p>3.UGUI的部分响应方法等待 如鼠标点击事件</p> 
 <p>4.MonoBehaviour的部分功能可以等待 如触发器</p> 
 <p>5.部分插件的扩展DOTween</p> 
 <p>Task -&gt; UniTask : 使用AsUniTask</p> 
 <p>UniTask -&gt; UniTask : 使用AsAsyncUnitUniTask</p> 
 <p>UniTask -&gt; UniTask : 使用AsUniTask，这两者的转换是无消耗的</p> 
</blockquote> 
<pre><code class="language-cs">//动画序列
await transform.DOMoveX(2,10);
await  transform.DOMoveX(5,20);
//并行 并传递cancellation用于取消
var ct=this.GetCancellationTokenOnDestroy();
await  UniTask.WhenAll(
    transform.DoMoveX(10,3).withCancellation(ct),
    transform.DoScale(10,3).withCancellation()
);</code></pre> 
<pre><code class="language-cs">using Cysharp.Threading.Tasks;
using System.Collections;
using UnityEngine;

public class Six : MonoBehaviour
{
    async void Start()
    {
        StartCoroutine(CorotineTest());
        //实现协程等待
        await CorotineTest();
    }

    IEnumerator CorotineTest()
    {
        Debug.Log("start");
        yield return new WaitForSeconds(1);
        Debug.Log("end");
    }
}
</code></pre> 
<pre><code class="language-cs">using Cysharp.Threading.Tasks;
using System;
using System.Collections;

using UnityEngine;

public class Six : MonoBehaviour
{
    async void Start()
    {
        StartCoroutine(CorotineTest1());
     

    }


    IEnumerator CorotineTest1()
    {
        Debug.Log("start");
        //使用这个方法将UniTask组件转化成协程
        //如果你想将异步转换成协程，你可以使用.ToCoroutine()，如果你只想允许使用携程系统，这很有用。
        yield return UniTask.Delay(TimeSpan.FromSeconds(1)).ToCoroutine();
        Debug.Log("end");
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5df5d9f7b849bdc68b1e3252dd864adc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter-使用setState来实现动态UI刷新实现UI交互</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9734ee1aeebbfd5abe428c66d923a8b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">远程连接工具为什么连接不上我的虚拟机？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>