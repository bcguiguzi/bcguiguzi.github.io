<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebView与ListView滑动冲突——(二)LinearLayout控制WebView滚动 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WebView与ListView滑动冲突——(二)LinearLayout控制WebView滚动" />
<meta property="og:description" content="上一篇我们大致了解了一下View中 事件的一些基础《WebView与ListView滑动冲突——(一)事件基础篇》，Scroll是为了实现View平滑滚动的一个Helper类，通常在自定义View中使用。 这次我们从一下几个方面来了解一下Scroll与VelocityTracker的用法：
View和MotionEvent的位置信息View中的Scroll方法Scroll中的scroll*()方法touchSlop与VelocityTrackerLinearLayout控制WebView滚动 通过上面几个方面的学习，将会对View的滑动有一定的认知。废话不多说了，开始
View和MotionEvent中的位置信息 在我们自定义View中，经常要获取各种位置坐标，但是View的get方法那么多，我也不知道这个get方法获取的到底是不是那个位置坐标，我能怎么办，我也很绝望呀。所以就整理了一些View和MotionEvent中的一些获取位置信息的一些方法。
View的位置信息 View中的获取位置信息的get方法。有些是不能直接在Activity的onCreate()中调用，因为当时View还未绘制完成，这个时候调用View的get方法，获取到的位置信息当然是0了。一般可以在Activity的onWindowFocusChanged()方法中获取，或者使用延迟策略去获取。
下面我们来看一下View中的通过那些信息来定位View的位置
left、right、top、bottom、elevation 这五个参数表示的是View的原始位置距离父控件边缘的距离，并且无论这个View被移动到了什么位置，或者被缩放、旋转了多少，这五个值都是永久不变的
left：目标View的最左边和这个View所在父控件的最左边的距离，通过view.getLeft()方法获取；right：目标View的最右边和这个View所在父控件的最左边的距离，通过view.getRight()方法获取；top：目标View的最上边和这个View所在父控件的最上边的距离，通过view.getTop()方法获取；bottom：目标View的最下边和这个View所在父控件的最上边的距离，通过view.getBottom()方法获取；elevation：目标View的Z轴高度和这个View所在的父控件所在的Z轴高度的距离，通过view.getElevation()方法获取（这个属性是Android 5.0之后添加的新属性） 撒？你说还是不明白，没事。我也没明白。还是用一张图来认识一下把：
translationX、translationY、translationZ 这三个参数代表的是在动画或者滑动View的时候，View的当前位置相对于其原始位置平移的距离：
translationX：在滑动过程中，View当前位置的最左边和这个View原始位置的最左边的距离，通过view.getTranslationX()方法获取；translationY：在滑动过程中，View当前位置的最上边和这个View原始位置的最上边的距离，通过view.getTranslationY()方法获取；translationZ：在动画过程中，View当前位置的Z轴高度和这个View原始Z轴高度的距离，通过view.getTranslationZ()方法获取（这个方法是Android 5.0之后添加的新方法）。 x、y、z 这三个参数代表的是View的当前位置相对于其父控件的距离：
x：目标View的当前位置的最左边和这个View所在父布局的最左边的距离，通过view.getX()方法获取；y：目标View的当前位置的最上边和这个View所在父布局的最上边的距离，通过view.getY()方法获取；z：目标View的当前位置的Z轴位置和这个View所在父布局的Z轴位置的距离，通过view.getZ()方法获取（这个方法是Android 5.0之后添加的新方法）。 这三个参数和前面的几个参数的关系公式如下：
x = left &#43; translationX; y = top &#43; translationY; z = elevation &#43; translationZ; MotionEvent的位置信息 使用MotionEvent类，我们还可以获取到触摸屏幕时View的一些位置参数：
x：当前触摸的位置相对于目标View的X轴坐标，通过getX()方法获取；y：当前触摸的位置相对于目标View的Y轴坐标，通过getY()方法获取；rawX：当前触摸的位置相对于屏幕最左边的X轴坐标，通过getRawX()方法获取；rawY：当前触摸的位置相对于屏幕最上边的Y轴坐标，通过getRawY()方法获取。 下面也通过一张图来清楚的认识一下把，要不然看完还是懵逼&#43;懵逼=懵逼²。。。
好了。对于View和MotionEvent的位置信息就简单说这么多把，够用就行。再说下去就 下笔千言离题万里了（关键是就知道这么多了- -！）
View中的Scroll方法 Android中为了实现View的滑动，系统为此提供了scrollTo()和scrollBy()两个方法。打开源码来让我们一探究竟。
/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2d4bbd515389cc775678a3136ef87f1a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-01T09:51:22+08:00" />
<meta property="article:modified_time" content="2017-09-01T09:51:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebView与ListView滑动冲突——(二)LinearLayout控制WebView滚动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上一篇我们大致了解了一下View中 事件的一些基础<a href="http://blog.csdn.net/tianzhaoai/article/details/77688071" target="_blank" rel="noopener noreferrer">《WebView与ListView滑动冲突——(一)事件基础篇》</a>，<strong>Scroll是为了实现View平滑滚动的一个Helper类，通常在自定义View中使用。</strong> 这次我们从一下几个方面来了解一下Scroll与VelocityTracker的用法：</p> 
<ul><li><strong>View和MotionEvent的位置信息</strong></li><li><strong>View中的Scroll方法</strong></li><li><strong>Scroll中的scroll*()方法</strong></li><li><strong>touchSlop与VelocityTracker</strong></li><li><strong>LinearLayout控制WebView滚动</strong></li></ul> 
<p>通过上面几个方面的学习，将会对View的滑动有一定的认知。废话不多说了，开始</p> 
<h3 id="view和motionevent中的位置信息">View和MotionEvent中的位置信息</h3> 
<p>在我们自定义View中，经常要获取各种位置坐标，但是View的get方法那么多，我也不知道这个get方法获取的到底是不是那个位置坐标，我能怎么办，我也很绝望呀。所以就整理了一些View和MotionEvent中的一些获取位置信息的一些方法。</p> 
<h4 id="view的位置信息">View的位置信息</h4> 
<p>View中的获取位置信息的get方法。有些是不能直接在Activity的onCreate()中调用，因为当时View还未绘制完成，这个时候调用View的get方法，获取到的位置信息当然是0了。一般可以在Activity的<code>onWindowFocusChanged()</code>方法中获取，或者使用延迟策略去获取。</p> 
<p>下面我们来看一下View中的通过那些信息来定位View的位置</p> 
<h5 id="leftrighttopbottomelevation"><strong>left、right、top、bottom、elevation</strong></h5> 
<p>这五个参数表示的是View的原始位置距离父控件边缘的距离，<font color="red">并且无论这个View被移动到了什么位置，或者被缩放、旋转了多少，这五个值都是永久不变的</font></p> 
<ul><li><strong>left</strong>：目标View的最左边和这个View所在父控件的最左边的距离，通过view.getLeft()方法获取；</li><li><strong>right</strong>：目标View的最右边和这个View所在父控件的最左边的距离，通过view.getRight()方法获取；</li><li><strong>top</strong>：目标View的最上边和这个View所在父控件的最上边的距离，通过view.getTop()方法获取；</li><li><strong>bottom</strong>：目标View的最下边和这个View所在父控件的最上边的距离，通过view.getBottom()方法获取；</li><li><strong>elevation</strong>：目标View的Z轴高度和这个View所在的父控件所在的Z轴高度的距离，通过view.getElevation()方法获取（这个属性是Android 5.0之后添加的新属性）</li></ul> 
<p>撒？你说还是不明白，没事。我也没明白。还是用一张图来认识一下把：</p> 
<p><img src="https://images2.imgbox.com/d5/a5/eF1hcibQ_o.png" alt="这里写图片描述" title=""></p> 
<h5 id="translationxtranslationytranslationz"><strong>translationX、translationY、translationZ</strong></h5> 
<p>这三个参数代表的是在动画或者滑动View的时候，View的当前位置相对于其原始位置平移的距离：</p> 
<ul><li>translationX：在滑动过程中，View当前位置的最左边和这个View原始位置的最左边的距离，通过view.getTranslationX()方法获取；</li><li>translationY：在滑动过程中，View当前位置的最上边和这个View原始位置的最上边的距离，通过view.getTranslationY()方法获取；</li><li>translationZ：在动画过程中，View当前位置的Z轴高度和这个View原始Z轴高度的距离，通过view.getTranslationZ()方法获取（这个方法是Android 5.0之后添加的新方法）。</li></ul> 
<h5 id="xyz"><strong>x、y、z</strong></h5> 
<p>这三个参数代表的是View的当前位置相对于其父控件的距离：</p> 
<ul><li>x：目标View的当前位置的最左边和这个View所在父布局的最左边的距离，通过view.getX()方法获取；</li><li>y：目标View的当前位置的最上边和这个View所在父布局的最上边的距离，通过view.getY()方法获取；</li><li>z：目标View的当前位置的Z轴位置和这个View所在父布局的Z轴位置的距离，通过view.getZ()方法获取（这个方法是Android 5.0之后添加的新方法）。</li></ul> 
<p>这三个参数和前面的几个参数的关系公式如下：</p> 
<pre><code>x = left + translationX;
y = top + translationY;
z = elevation + translationZ;
</code></pre> 
<h4 id="motionevent的位置信息">MotionEvent的位置信息</h4> 
<p>使用MotionEvent类，我们还可以获取到触摸屏幕时View的一些位置参数：</p> 
<ul><li>x：当前触摸的位置相对于目标View的X轴坐标，通过getX()方法获取；</li><li>y：当前触摸的位置相对于目标View的Y轴坐标，通过getY()方法获取；</li><li>rawX：当前触摸的位置相对于屏幕最左边的X轴坐标，通过getRawX()方法获取；</li><li>rawY：当前触摸的位置相对于屏幕最上边的Y轴坐标，通过getRawY()方法获取。</li></ul> 
<p>下面也通过一张图来清楚的认识一下把，要不然看完还是懵逼+懵逼=懵逼²。。。</p> 
<p><img src="https://images2.imgbox.com/5b/5b/g5WvMVi1_o.png" alt="这里写图片描述" title=""></p> 
<p>好了。对于View和MotionEvent的位置信息就简单说这么多把，够用就行。再说下去就 下笔千言离题万里了（关键是就知道这么多了- -！）</p> 
<h3 id="view中的scroll方法">View中的Scroll方法</h3> 
<p>Android中为了实现View的滑动，系统为此提供了scrollTo()和scrollBy()两个方法。打开源码来让我们一探究竟。</p> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-javadoc">/** 
     * Set the scrolled position of your view. This will cause a call to 
     * {@link #onScrollChanged(int, int, int, int)} and the view will be 
     * invalidated. 
     *<span class="hljs-javadoctag"> @param</span> x the x position to scroll to 
     *<span class="hljs-javadoctag"> @param</span> y the y position to scroll to 
     */</span>  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollTo</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) {  
        <span class="hljs-keyword">if</span> (mScrollX != x || mScrollY != y) {  
            <span class="hljs-keyword">int</span> oldX = mScrollX;  
            <span class="hljs-keyword">int</span> oldY = mScrollY;  
            mScrollX = x;  
            mScrollY = y;  
            invalidateParentCaches();  
            onScrollChanged(mScrollX, mScrollY, oldX, oldY);  
            <span class="hljs-keyword">if</span> (!awakenScrollBars()) {  
                postInvalidateOnAnimation();  
            }  
        }  
    }  
    <span class="hljs-javadoc">/** 
     * Move the scrolled position of your view. This will cause a call to 
     * {@link #onScrollChanged(int, int, int, int)} and the view will be 
     * invalidated. 
     *<span class="hljs-javadoctag"> @param</span> x the amount of pixels to scroll by horizontally 
     *<span class="hljs-javadoctag"> @param</span> y the amount of pixels to scroll by vertically 
     */</span>  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollBy</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) {  
        scrollTo(mScrollX + x, mScrollY + y);  
    }  </code></pre> 
<p>scrollTo()方法的注释中，我们可以看到，这个方法将会调用onScrollChanged()方法并且这个View将会被重绘，这就达到了View的<font color="red">内容</font>位置<font color="red">变化</font>效果。而scrollBy()，这货就比较懒了，内部直接调用了scrollTo(）方法。不过两者的区别还是很明显的，scrollTo()是直接一步到位，而scrollBy()则是慢慢的累积。</p> 
<p>mScrollX和mScrollY则是View的偏移量。而且都是指当前view的内容相对view本身左上角起始坐标的偏移量。看了下面这幅图你就明白了：</p> 
<p><img src="https://images2.imgbox.com/2e/a1/psdnLQiV_o.png" alt="这里写图片描述" title=""></p> 
<p><font size="4"><strong>来个小结：</strong></font></p> 
<ul><li>scrollTo()的移动是一步到位，而scrollBy()逐步累加的</li><li>scrollTo()和scrollBy()传递的参数是偏移量而非坐标</li><li><p>scrollTo()和scrollBy()移动的都只是View的内容,View的背景本身是不移动的。</p> <p><font color="red"><strong>注：</strong></font>在实际操作中你会发现，传入的参数完全跟想执行的操作相反。所以如果我们想往x轴和y轴正方向移动时，mScrollY和mScrollX必须为负值，相反如果我们想往x轴和y轴负方向移动时，mScrollY和mScrollX就必须为正值</p></li></ul> 
<h3 id="touchslop与velocitytracker">TouchSlop与VelocityTracker</h3> 
<h4 id="touchslop">TouchSlop</h4> 
<p>在自定义View中，我们有时会用到下面这行代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">mTouchSlop = ViewConfiguration<span class="hljs-preprocessor">.get</span>(context)<span class="hljs-preprocessor">.getScaledTouchSlop</span>()<span class="hljs-comment">;  </span></code></pre> 
<p>那么这个方法获取到的int值到底是个啥啊？通过方法上面的注释才知道，TouchSlop是一个滑动距离的常量值，并且需要注意的是不同的设备，touchSlop的值可能是不同的，一切以上述的函数获取为准。</p> 
<p>这个值对于自定义View有什么用呢？我们来举个例子，当你按下屏幕后，不上下滑动，也不松开，而是手指左右上下抖一抖，会一直触发ACTION_MOVE事件，只有当滑动距离大于TouchSlop这个值时，系统才认为我们做了滑动操作。</p> 
<h4 id="velocitytracker">VelocityTracker</h4> 
<p>VelocityTracker是一个滑动速率的Helper类。它可以辅助跟踪触摸事件的速率，比如快速滑动或者其他的滑动手势。我们一般会在ACTION_DOWN事件中初始化VelocityTracker对象，比如：</p> 
<pre class="prettyprint"><code class=" hljs r">    @Override
    public boolean onTouchEvent(MotionEvent event) {
            VelocityTracker mVelocityTracker =VelocityTracker.obtain();
            //收集速率追踪点数据  
            velocityTracker.addMovement(event);  
            <span class="hljs-keyword">switch</span> (event.getAction()) {
                    <span class="hljs-keyword">...</span>
                case MotionEvent.ACTION_DOWN:    
                     <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">...</span>
            }
    }</code></pre> 
<p>在ACTION_MOVE事件中我们就可以获取当前事件的滑动速率了，关于computeCurrentVelocity(int units,int maxVelocity)</p> 
<ul><li><p><strong>units : </strong> 我们想要指定的得到的速度单位，如果值为1，代表1毫秒运动了多少像素。如果值为1000，代表1秒内运动了多少像素。如果值为100，代表100毫秒内运动了多少像素。（这个参数设置真有点…….什么鬼嘛!）这个方法还有一个重载函数 computeCurrentVelocity (int units, float maxVelocity), 跟上面一样也就是多了一个参数。</p></li><li><p><strong>maxVelocity :</strong> 该方法所能得到的最大速度，这个速度必须和你指定的units使用同样的单位，而且必须是整数.也就是，你指定一个速度的最大值，如果计算超过这个最大值，就使用这个最大值，否则，使用计算的的结果，</p> <p><font color="red"><strong>注：</strong></font>最后一定别忘了在ACTION_UP或者ACTION_CANCEL中回收一下</p></li></ul> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//获取最大速度</span>
mMaxVelocity = ViewConfiguration.<span class="hljs-keyword">get</span>(context).getScaledMaximumFlingVelocity()

<span class="hljs-keyword">switch</span> (<span class="hljs-keyword">event</span>.getAction()) {
    <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
    <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:
         <span class="hljs-comment">//计算瞬时速度  </span>
         mVelocityTracker .computeCurrentVelocity(units, mMaxVelocity);  
         <span class="hljs-keyword">float</span> velocityX = mVelocityTracker .getXVelocity();  
         <span class="hljs-keyword">float</span> velocityY = mVelocityTracker .getYVelocity();   
         <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-keyword">null</span>) {  
              mVelocityTracker.clear();  
              mVelocityTracker.recycle();  
              mVelocityTracker = <span class="hljs-keyword">null</span>;  
         }    
         <span class="hljs-keyword">break</span>;
        ...
}</code></pre> 
<h3 id="linearlayout控制webview滚动">LinearLayout控制WebView滚动</h3> 
<h4 id="实现view简单的移动">实现View简单的移动</h4> 
<p>注意，是移动，是移动（难不成还是联通- -！）而不是滚动。达到这种效果只需要View的scrollTo或者scrollBy即可实现，不是很复杂。直接看代码把：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> com.tianzhao.demo;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.graphics.Color;
<span class="hljs-keyword">import</span> android.support.annotation.AttrRes;
<span class="hljs-keyword">import</span> android.support.annotation.NonNull;
<span class="hljs-keyword">import</span> android.support.annotation.Nullable;
<span class="hljs-keyword">import</span> android.util.AttributeSet;
<span class="hljs-keyword">import</span> android.view.Gravity;
<span class="hljs-keyword">import</span> android.view.MotionEvent;
<span class="hljs-keyword">import</span> android.view.VelocityTracker;
<span class="hljs-keyword">import</span> android.view.View;
<span class="hljs-keyword">import</span> android.view.ViewConfiguration;
<span class="hljs-keyword">import</span> android.view.ViewGroup;
<span class="hljs-keyword">import</span> android.widget.LinearLayout;
<span class="hljs-keyword">import</span> android.widget.TextView;

<span class="hljs-keyword">import</span> java.util.Locale;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context) {
        <span class="hljs-keyword">super</span>(context);
        init(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context, @Nullable AttributeSet attrs) {
        <span class="hljs-keyword">super</span>(context, attrs);
        init(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes <span class="hljs-keyword">int</span> defStyleAttr) {
        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);
        init(context);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(Context context) {
        setOrientation(VERTICAL);
        initChildView(context);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChildView</span>(Context context) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">60</span>; i++) {
            TextView view = <span class="hljs-keyword">new</span> TextView(context);
            LayoutParams params = <span class="hljs-keyword">new</span> LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,<span class="hljs-number">120</span>);
            view.setLayoutParams(params);
            view.setText(String.format(Locale.CHINA,<span class="hljs-string">"%d"</span>,i));
            view.setGravity(Gravity.CENTER);
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                view.setBackgroundColor(Color.parseColor(<span class="hljs-string">"#FF40FF9C"</span>));
            } <span class="hljs-keyword">else</span> {
                view.setBackgroundColor(Color.parseColor(<span class="hljs-string">"#303F9F"</span>));
            }
            addView(view);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> mLastY;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span>(MotionEvent event) {
        <span class="hljs-keyword">switch</span> (event.getAction()) {
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword">int</span> offsetY = (<span class="hljs-keyword">int</span>) (event.getY() - mLastY);
                ((View) getParent()).scrollBy(<span class="hljs-number">0</span>, -offsetY);
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

}
</code></pre> 
<p>来看看效果图，只要手指停下。就不移动了，达不到View滚动的效果。 <br> <img src="https://images2.imgbox.com/9c/fd/OTleE501_o.gif" alt="这里写图片描述" title=""></p> 
<h4 id="实现view的滚动">实现View的滚动</h4> 
<p>注意，这里说的是滚动、是滚动、滚动、动。不是移动！</p> 
<p>我们在 <code>onInterceptTouchEvent（）</code> 方法中主要处理事件的一些初始化，和是否拦截当前事件的相关操作。而 <code>onTouchEvent（）</code> 则主要处理事件的滑动与滚动。不必要的代码我已经剔除了。只留了最基本有用的代码，注释也补充了。雅酷，伊利卡通，代码，开！</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> com.tianzhao.demo;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.support.annotation.AttrRes;
<span class="hljs-keyword">import</span> android.support.annotation.NonNull;
<span class="hljs-keyword">import</span> android.support.annotation.Nullable;
<span class="hljs-keyword">import</span> android.util.AttributeSet;
<span class="hljs-keyword">import</span> android.util.Log;
<span class="hljs-keyword">import</span> android.view.MotionEvent;
<span class="hljs-keyword">import</span> android.view.VelocityTracker;
<span class="hljs-keyword">import</span> android.view.ViewConfiguration;
<span class="hljs-keyword">import</span> android.webkit.WebView;
<span class="hljs-keyword">import</span> android.widget.LinearLayout;
<span class="hljs-keyword">import</span> android.widget.Scroller;

<span class="hljs-javadoc">/**
 * Desc:使用LinearLayout的事件来操控WebView的滚动
 * Created by tianzhao on 2017/8/31.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"CustomView"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG_LOG = <span class="hljs-keyword">true</span>;

    <span class="hljs-keyword">private</span> Scroller mScroll;

    <span class="hljs-keyword">private</span> VelocityTracker mVelocityTracker;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mTouchSlop;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mMinimumVelocity;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mMaximumVelocity;

    <span class="hljs-keyword">private</span> WebView mWebView;

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context) {
        <span class="hljs-keyword">super</span>(context);
        init(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context, @Nullable AttributeSet attrs) {
        <span class="hljs-keyword">super</span>(context, attrs);
        init(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span>(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes <span class="hljs-keyword">int</span> defStyleAttr) {
        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);
        init(context);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(Context context) {

        mScroll = <span class="hljs-keyword">new</span> Scroller(context);

        ViewConfiguration viewConfiguration = ViewConfiguration.get(context);
        mTouchSlop = viewConfiguration.getScaledTouchSlop();
        mMaximumVelocity = viewConfiguration.getScaledMaximumFlingVelocity();
        mMinimumVelocity = viewConfiguration.getScaledMinimumFlingVelocity();

        initChildView(context);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChildView</span>(Context context) {

        mWebView = <span class="hljs-keyword">new</span> WebView(context);
        mWebView.loadUrl(<span class="hljs-string">"file:///android_asset/index.html"</span>);
        mWebView.setFocusable(<span class="hljs-keyword">false</span>);
        addView(mWebView);
    }

    <span class="hljs-javadoc">/**
     * 初始化值,并且选择是否拦截事件
     */</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span>(MotionEvent event) {

        <span class="hljs-keyword">boolean</span> isIntercept = <span class="hljs-keyword">false</span>;

        <span class="hljs-comment">/*
         * 这里不能使用event.getAction()
         * 注意event.getAction()和event.getActionMasked()的区别
         * 当MotionEvent对象只包含一个触摸点的事件时，上边两个函数的结果是相同的，
         * 但是当包含多个触摸点时，二者的结果就不同啦。
         * getAction获得的int值是由pointer的index值和事件类型值组合而成的，
         * 而getActionWithMasked则只返回事件的类型值
         */</span>
        <span class="hljs-keyword">switch</span> (event.getActionMasked()) {
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:
                <span class="hljs-keyword">boolean</span> flingFinished = stopFling();
                mTouchLastY = event.getY();
                mPointerID = event.getPointerId(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (!flingFinished) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">else</span> {
                    addVelocityTracker(event);
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword">int</span> pointerIndex = event.findPointerIndex(mPointerID);
                <span class="hljs-keyword">if</span> (pointerIndex &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">int</span> offsetY = (<span class="hljs-keyword">int</span>) (mTouchLastY - event.getY(pointerIndex));
                mTouchLastY = event.getY();
                <span class="hljs-comment">//判断上下滑动距离是否大于最小滑动距离</span>
                <span class="hljs-comment">//如果大于，则将事件向下传递给onTouchEvent处理</span>
                <span class="hljs-comment">//反之则进行拦截，不进行任何响应</span>
                <span class="hljs-keyword">if</span> (Math.abs(offsetY) &gt;= mTouchSlop) {
                    isIntercept = <span class="hljs-keyword">true</span>;
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_POINTER_DOWN:
                isIntercept = <span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">return</span> isIntercept;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> mTouchLastY;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mPointerID;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span>(MotionEvent event) {
        addVelocityTracker(event);
        <span class="hljs-comment">//这里不能使用event.getAction()</span>
        <span class="hljs-comment">//注意event.getAction()和event.getActionMasked()的区别</span>
        <span class="hljs-keyword">switch</span> (event.getActionMasked()) {
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-comment">//将当前LinearLayout的滑动事件透传给WebView去进行滚动</span>
                <span class="hljs-keyword">int</span> pointerIndex = event.findPointerIndex(mPointerID);
                <span class="hljs-keyword">int</span> offsetY = (<span class="hljs-keyword">int</span>) (mTouchLastY - event.getY(pointerIndex));
                mTouchLastY = event.getY(pointerIndex);
                mWebView.scrollBy(<span class="hljs-number">0</span>, offsetY);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
                <span class="hljs-comment">//手指离开时，计算当前的滑动速率</span>
                <span class="hljs-comment">//使用Scroll和VelocityTracker进行滚动</span>
                startFling(-(<span class="hljs-keyword">int</span>) getScrollVelocityY());
                recycleVelocityTracker();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_POINTER_UP:
                <span class="hljs-comment">//当两个触摸点，有一个离开屏幕时</span>
                <span class="hljs-comment">//将当前的触摸点</span>
                solvePointerUp(event);
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solvePointerUp</span>(MotionEvent event) {
        <span class="hljs-comment">// 获取离开屏幕的手指的索引</span>
        <span class="hljs-keyword">int</span> pointerIndexLeave = event.getActionIndex();
        <span class="hljs-keyword">int</span> pointerIdLeave = event.getPointerId(pointerIndexLeave);
        <span class="hljs-comment">// 离开屏幕的手指如果正是目前的有效手指，此处需要重新调整</span>
        <span class="hljs-keyword">if</span> (mPointerID == pointerIdLeave) {
            <span class="hljs-comment">// 将还在屏幕的手指标记为有效手指，并且重置VelocityTracker</span>
            <span class="hljs-keyword">int</span> reIndex = pointerIndexLeave == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
            mPointerID = event.getPointerId(reIndex);
            <span class="hljs-comment">// 调整触摸位置，防止出现跳动</span>
            mTouchLastY = event.getY(reIndex);
            <span class="hljs-comment">// 清除mVelocityTracker记录的信息</span>
            clearVelocity();
        }
    }

    <span class="hljs-javadoc">/**
     * VelocityTracker也有最大值和最小值
     * computeCurrentVelocity获取到的只 &lt;= mMaximumVelocity
     * 所以需要判断是否大于最小值
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getScrollVelocityY</span>() {
        <span class="hljs-keyword">float</span> velocityY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-keyword">null</span>) {
            mVelocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>, mMaximumVelocity);
            velocityY = mVelocityTracker.getYVelocity(mPointerID);
            print(<span class="hljs-string">"getScrollVelocityY : "</span> + velocityY);
        }
        <span class="hljs-keyword">if</span> (Math.abs(velocityY) &gt; mMinimumVelocity) {
            <span class="hljs-keyword">return</span> velocityY;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mLastFlingY;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startFling</span>(<span class="hljs-keyword">int</span> velocityY) {
        mLastFlingY = <span class="hljs-number">0</span>;
        print(<span class="hljs-string">" startFling : "</span> + velocityY);
        mScroll.fling(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, velocityY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, Integer.MIN_VALUE, Integer.MAX_VALUE);
        <span class="hljs-comment">//注意此处一定要调用postInvalidate()或者invalidate()，置于两者的区别，这块就不多做解释了</span>
        postInvalidate();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">stopFling</span>() {
        <span class="hljs-keyword">if</span> (mScroll != <span class="hljs-keyword">null</span> &amp;&amp; !mScroll.isFinished()) {
            mScroll.abortAnimation();<span class="hljs-comment">//停止滚动</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }


    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span>() {
        <span class="hljs-comment">//此处一定要通过 mScroll.computeScrollOffset() 方法判断是否滚动结束</span>
        <span class="hljs-comment">//要不然发生死循环就GG了</span>
        <span class="hljs-keyword">if</span> (mScroll != <span class="hljs-keyword">null</span> &amp;&amp; mScroll.computeScrollOffset()) {
            <span class="hljs-keyword">int</span> y = mScroll.getCurrY();
            print(<span class="hljs-string">" offsetY : "</span> + (y - mLastFlingY));
            mWebView.scrollBy(<span class="hljs-number">0</span>, y - mLastFlingY);
            mLastFlingY = y;
            <span class="hljs-comment">//注意此处同上一样一定要调用postInvalidate()或者invalidate()</span>
            <span class="hljs-comment">//以达成一种循环的效果</span>
            postInvalidate();
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVelocityTracker</span>(MotionEvent event) {
        <span class="hljs-keyword">if</span> (mVelocityTracker == <span class="hljs-keyword">null</span>) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(event);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycleVelocityTracker</span>() {
        <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-keyword">null</span>) {
            mVelocityTracker.clear();
            mVelocityTracker.recycle();
            mVelocityTracker = <span class="hljs-keyword">null</span>;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearVelocity</span>() {
        <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-keyword">null</span>) {
            mVelocityTracker.clear();
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(String msg) {
        <span class="hljs-keyword">if</span> (DEBUG_LOG) {
            Log.d(TAG, msg);
        }
    }
}</code></pre> 
<p>这次来看一下最终的效果</p> 
<p><img src="https://images2.imgbox.com/2a/70/lCTw5lPL_o.gif" alt="这里写图片描述" title=""></p> 
<p>这节就说道这里把，下节来正式进入主题——WebView与ListView共存。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8620d8976317519e5a9808ac2ff81a0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据读取入门——xlsread</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a741d7a0ee46388a4969e750f9091ece/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php 获取移动端ip和pc端ip</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>