<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue 中 watch(监听属性) 和 computed(计算属性) 的对比 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue 中 watch(监听属性) 和 computed(计算属性) 的对比" />
<meta property="og:description" content="vue 中的监听属性 watch 和计算属性 computed 都有监听的作用，但具体的适用场景和方法是由区别的
computed computed 相当于定义一个变量，这个变量接收其后函数的返回值，函数里面的属性值经过计算返回给函数前面的变量，当函数里面的属性发生变化的时候，就会触发这个函数进行计算，更新computed 定义的变量，并将计算后的结果进行缓存，在函数里面的属性没有发生变化的情况下，都会调用缓存中的数据。
compute中定义的变量都是新的变量，这个变量可以直接在代码中进行使用，而不是在props/data中进行定义，更注重的是计算而得的变量。
计算属性(computed)不能进行异步操作因为计算属性(computed)是通过return返回值传递参数 异步操作的时候return是没有意义的。
computed 的方法里面的属性值发生变化，触发计算函数，并将计算结果进行缓存，在返回给变量，和watch的顺序刚好是相反的。
import { computed, defineComponent } from &#39;vue&#39; export default defineComponent({ setup({ const name = ref&lt;any&gt;(&#39;&#39;) const ristName = ref&lt;any&gt;(&#39;&#39;) const lastName= ref&lt;any&gt;(&#39;&#39;) // 添加watch监听 name.value = computed(() =&gt; { // fristName 或者 lastName变化触发方法，重新计算，从而改变name的值 return fristName &#43; lastName }) return { name, ristName, lastName } }) }) 适用环境：一个数据受多个数据影响的场景。
watch watch像是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2863a90f4c07748c94785709e12e1a36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-04T17:02:39+08:00" />
<meta property="article:modified_time" content="2023-06-04T17:02:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue 中 watch(监听属性) 和 computed(计算属性) 的对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>vue 中的监听属性 watch 和计算属性 computed 都有监听的作用，但具体的适用场景和方法是由区别的</p> 
<h2><a id="computed_2"></a>computed</h2> 
<p>computed 相当于定义一个<strong>变量</strong>，这个变量接收其后函数的返回值，函数里面的属性值经过计算返回给函数前面的变量，当函数里面的属性发生变化的时候，就会触发这个函数进行计算，更新computed 定义的变量，并将计算后的结果进行缓存，在函数里面的属性没有发生变化的情况下，都会调用缓存中的数据。</p> 
<p>compute中定义的变量都是新的变量，这个变量可以直接在代码中进行使用，而不是在props/data中进行定义，更注重的是计算而得的变量。</p> 
<p>计算属性(computed)<strong>不能进行异步操作</strong>因为计算属性(computed)是通过return返回值传递参数 异步操作的时候return是没有意义的。</p> 
<p>computed 的方法里面的属性值发生变化，触发计算函数，并将计算结果进行缓存，在返回给变量，和watch的顺序刚好是相反的。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> computed<span class="token punctuation">,</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">const</span> name <span class="token operator">=</span> ref<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> ristName <span class="token operator">=</span> ref<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> lastName<span class="token operator">=</span> ref<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token comment">// 添加watch监听</span>
        name<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// fristName 或者 lastName变化触发方法，重新计算，从而改变name的值</span>
           <span class="token keyword">return</span> fristName <span class="token operator">+</span> lastName
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
            name<span class="token punctuation">,</span>
            ristName<span class="token punctuation">,</span>
            lastName
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>适用环境：一个数据受多个数据影响的场景。</p> 
<h2><a id="watch_35"></a>watch</h2> 
<p>watch像是一个<strong>对象</strong>，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。</p> 
<p>watch 是浅层的，被侦听的属性，仅在被赋新值时，才会触发回调函数，而嵌套属性的变化不会被触发，（如对象中的属性），如果想要侦听所有嵌套属性的变更，则需要深层侦听器。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 深层侦听</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">someObject</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 注意：在嵌套的变更中，</span>
        <span class="token comment">// 只要没有替换对象本身，</span>
        <span class="token comment">// 那么这里的 `newValue` 和 `oldValue` 相同</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 深层侦听，需要遍历被侦听对象的所有嵌套的属性，当遇到复杂度高的大型数据结构的时候，开销会很大。</span>
</code></pre> 
<p>watch 支持异步，没有缓存，他监听的变量是在props/data中已经定义的变量，<strong>更加侧重的是处理的函数</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token comment">//在vue中3使用：</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> watch， defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">const</span> name <span class="token operator">=</span> ref<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token comment">// 添加watch监听</span>
        <span class="token function">watch</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">oldValue<span class="token punctuation">,</span> newValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// name 发生变化，触发方法，进行逻辑处理</span>
            <span class="token comment">// todo 进行相应的逻辑， 重点在于name值变化之后，回调方法的逻辑处理</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
            name
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>适用环境：适用于一个数据影响多个数据。如省市级多级联动菜单，根据上一级的值，获取下一级的选项。</p> 
<h2><a id="_79"></a>区别</h2> 
<p>1、watch通过代码修改监听的对象从而触发 compute是通过修改方法里面的属性值从而触发</p> 
<p>2、watch代码能直接修改监听对象的值 compute则不能，若想要修改对应的值，就只能修改方法里面的属性，通过计算才能修改对应的值。</p> 
<p>3.watch 没有缓存但支持异步，computed 有缓存但不支持异步。</p> 
<p><a href="https://blog.csdn.net/chenlong316048157/article/details/123286382">参考博客：vue里面的watch和computed的区别</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e2445b4f23415bc8aae9d93997e3fb0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">go语言操作MySql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a1fe4a4445b8204014bd7a4b093f711/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【信号调制】使用不同的分类器（逻辑回归分类器、决策树、随机森林、全连接密集层和CNN）来训练模型，以预测不同信噪比值下信号的调制类型（Python代码实现）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>