<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Retrofit2使用详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Retrofit2使用详解" />
<meta property="og:description" content="简介 A type-safe HTTP client for Android and Java,一种类型安全的Http联网构架。
出品公司Square，项目地址。
项目导入 compile &#39;com.squareup.retrofit2:retrofit:2.2.0&#39; 需android 2.3以上
网络请求步骤 1.创建一个接口,设置请求的类型与参数 接口中创建一个方法，返回一个Call对象，泛型是网络请求返回的数据转换成实体类对象集合，用注解来确定请求是GET还是POST
public interface GitHubService { @GET(&#34;users/{user}/repos&#34;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&#34;user&#34;) String user); } 2.创建一个Retrofit对象 baseUrl()方法一般放置地址的主体部分，以/结尾
Retrofit retrofit = new Retrofit.Builder() .baseUrl(&#34;https://api.github.com/&#34;) .build(); 3.生成一个接口实现对象 调用retrofit的create方法，传入第一步创建的请求接口，生成一个请求接口的实现对象
GitHubService service = retrofit.create(GitHubService.class); 4.生成一个Call实例对象 调用请求接口的对象方法可以生成一个Call对象实例，到这一步就可以得到最后的请求地址了。
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&#34;octocat&#34;); 这是一个Get请求，传的是Path的参数，所以最后的请求地址拼接起来就是https://api.github.com/users/octocat/repos
5.发送请求 调用Call实例对象的方法就可以发送联网请求了，有两种方式，一种是同步请求，一种是异步请求。
同步请求 调用execute()方法，需要捕捉异常，返回结果的响应体，泛型为接口类中定义方法里返回类的泛型一样
try { Response&lt;List&lt;Repo&gt;&gt; response= repos.execute(); } catch (IOException e) { e.printStackTrace(); } 该方法源码解释
/** * Synchronously send the request and return its response." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c471bbc412c8a1dffa27c8497bd751fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-15T00:47:37+08:00" />
<meta property="article:modified_time" content="2017-04-15T00:47:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Retrofit2使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>简介</h3> 
<p>A type-safe HTTP client for Android and Java,一种类型安全的Http联网构架。<br> 出品公司Square，<a href="https://github.com/square/retrofit">项目地址</a>。</p> 
<hr> 
<h3><a id="_4"></a>项目导入</h3> 
<pre><code>compile 'com.squareup.retrofit2:retrofit:2.2.0'
</code></pre> 
<p>需android 2.3以上</p> 
<hr> 
<h3><a id="_12"></a>网络请求步骤</h3> 
<h3><a id="1_13"></a>1.创建一个接口,设置请求的类型与参数</h3> 
<p>接口中创建一个方法，返回一个Call对象，泛型是网络请求返回的数据转换成实体类对象集合，用注解来确定请求是GET还是POST</p> 
<pre><code>public interface GitHubService {
  @GET("users/{user}/repos")
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);
}
</code></pre> 
<h3><a id="2Retrofit_21"></a>2.创建一个Retrofit对象</h3> 
<p>baseUrl()方法一般放置地址的主体部分，以/结尾</p> 
<pre><code>Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .build();


</code></pre> 
<h3><a id="3_30"></a>3.生成一个接口实现对象</h3> 
<p>调用retrofit的create方法，传入第一步创建的请求接口，生成一个请求接口的实现对象</p> 
<pre><code>GitHubService service = retrofit.create(GitHubService.class);
</code></pre> 
<h3><a id="4Call_35"></a>4.生成一个Call实例对象</h3> 
<p>调用请求接口的对象方法可以生成一个Call对象实例，到这一步就可以得到最后的请求地址了。</p> 
<pre><code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("octocat");
</code></pre> 
<p>这是一个Get请求，传的是Path的参数，所以最后的请求地址拼接起来就是<code>https://api.github.com/users/octocat/repos</code></p> 
<h3><a id="5_41"></a>5.发送请求</h3> 
<p>调用Call实例对象的方法就可以发送联网请求了，有两种方式，一种是同步请求，一种是异步请求。</p> 
<h4><a id="_43"></a><strong>同步请求</strong></h4> 
<p>调用execute()方法，需要捕捉异常，返回结果的响应体，泛型为接口类中定义方法里返回类的泛型一样</p> 
<pre><code>	 try {
       Response&lt;List&lt;Repo&gt;&gt; response= repos.execute();
     } catch (IOException e) {
           e.printStackTrace();
        }
</code></pre> 
<p>该方法源码解释</p> 
<pre><code>/**
   * Synchronously send the request and return its response.
   *
   * @throws IOException if a problem occurred talking to the server.
   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
   * or decoding the response.
   */
  Response&lt;T&gt; execute() throws IOException;
</code></pre> 
<h4><a id="_64"></a><strong>异步请求</strong></h4> 
<p>调用enqueue()方法，参数是一个回调，实现两个方法，一是请求成功调用的onResponse,可以得到响应体;二是请求失败调用的onFailure,可以查看异常。</p> 
<pre><code>  repos.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {
                @Override
                public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) {
                //调用响应的body()方法，即可得到返回的数据
                    List&lt;Repo&gt; repoList=response.body();
                }

                @Override
                public void onFailure(Call&lt;String&gt; call, Throwable t) {
                //t即是异常类，可以打印异常信息
					  t.printStackTrace();
                }
            });
           
</code></pre> 
<p>该方法源码解释</p> 
<pre><code>/**
   * Asynchronously send the request and notify {@code callback} of its response or if an error
   * occurred talking to the server, creating the request, or processing the response.
   */
  void enqueue(Callback&lt;T&gt; callback);
</code></pre> 
<p>##6.添加返回数据自动转换功能<br> 上述第五步中有一句关键代码，实现了返回数据自动转换成实体类集合的过程，简单快捷。</p> 
<pre><code> List&lt;Repo&gt; repoList=response.body();
</code></pre> 
<p>要实现该功能，有两步。<br> 第一，添加Gson依赖,注意对应当前Retrofix版本</p> 
<pre><code>com.squareup.retrofit2:converter-gson:2.2.0
</code></pre> 
<p>第二，构建Retrofit时，加上这句关键代码</p> 
<pre><code>Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com")
    //关键代码，添加转换工厂
    .addConverterFactory(GsonConverterFactory.create())
    .build();
</code></pre> 
<p>也可以添加其它转换工厂，注意要在后面加上**:2.2.0**，当前的版本号</p> 
<ul><li>Gson: com.squareup.retrofit2:converter-gson</li><li>Jackson: com.squareup.retrofit2:converter-jackson</li><li>Moshi: com.squareup.retrofit2:converter-moshi</li><li>Protobuf: com.squareup.retrofit2:converter-protobuf</li><li>Wire: com.squareup.retrofit2:converter-wire</li><li>Simple XML: com.squareup.retrofit2:converter-simplexml</li><li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars //String类型的支持</li></ul> 
<hr> 
<h3><a id="_124"></a>所有请求方式的注解及参数类型关键字</h3> 
<p>retrofix内置有五个请求方式注解 GET, POST, PUT, DELETE, and HEAD.<br> 其中GET请求与POST请求是Http经常使用的.</p> 
<h4><a id="GET__POST_127"></a><strong>GET &amp; POST请求方式传参数</strong></h4> 
<p>以GET为例进行说明</p> 
<pre><code>@GET("group/{id}/users")
Call&lt;List&lt;User&gt;&gt; groupList(
@Path("id") int groupId,
 @Query("sort") String sort);
</code></pre> 
<p>参数说明:<br> @Path:请求URL的字符替代，将网址中的{id}替换成自己传递的id<br> @Query:要传递的参数<br> 如Call方法为:groupList(“9527”,“order by age desc”);<br> 则最后发送的请求网址为:<br> <code>https://api.github.com/group/9527/users?sort=order by age desc</code><br> 注意@Path只能用于地址的通配，如要传参数必须用@Query</p> 
<h4><a id="_143"></a><strong>传递多个参数</strong></h4> 
<p>要实现的请求地址如下：<br> <code>https://api.github.com/group/9527/users?name=android&amp;sort=order by age desc</code><br> 方法1：添加多个@Query注解的参数</p> 
<pre><code>@GET("group/{id}/users")
Call&lt;List&lt;User&gt;&gt; groupList(
@Path("id") int groupId, 
@Query("name") String name);
@Query("sort") String sort);
</code></pre> 
<p>方法2：添加一个@QueryMap注解参数，里面包含多个@Query注解的参数</p> 
<pre><code>@GET("group/{id}/users")
Call&lt;List&lt;User&gt;&gt; groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);

Map&lt;String,String&gt; options=new HashMap();
options.put("name","android");
options.put("sort","order by age desc");
Call call=service.groupList("9527",options);
</code></pre> 
<p>另也可以用同一个key值来传递多个数据</p> 
<pre><code>Map&lt;String,List&lt;String&gt;&gt; options=new HashMap();
list.add("android");
list.add("IOS");
options.put("name",list);
</code></pre> 
<p>得到的URL地址为</p> 
<pre><code>https://api.github.com/group/9527/users?name=android&amp;name=IOS&amp;sort=order by age desc
</code></pre> 
<p>方法3：用@Body直接添加一个实体类对象，<strong>只适用于POST方式</strong></p> 
<pre><code>@POST("users/new")
Call&lt;User&gt; createUser(@Body User user);
</code></pre> 
<h4><a id="FormencodedURL_184"></a><strong>Form-encoded（URL编码）</strong></h4> 
<p>可以指定http请求URL编码,application/x-www-form-urlencoded，传递表单数据是键值对形式，适用于POST请求方式</p> 
<pre><code>@FormUrlEncoded
@POST("user/edit")
Call&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last);
</code></pre> 
<p>在带有@FormURLEncode的POST请求中，只能用@Filed来传递参数，用法与@Query一致.</p> 
<h4><a id="_194"></a><strong>上传文件</strong></h4> 
<p>指定编码方式为@Multipart,即是multipart/form-data，只有这种编码格式才可上传文件，可以用@PUT,也可以用@POST方式，<strong>参数只能用@Part注解</strong></p> 
<pre><code>@Multipart
@PUT("user/photo")
Call&lt;User&gt; updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);
</code></pre> 
<h4><a id="Headers_201"></a>添加表头@Headers</h4> 
<pre><code>//单项表头
@Headers("Cache-Control: max-age=640000")
@GET("widget/list")
Call&lt;List&lt;Widget&gt;&gt; widgetList();

//多项表头
@Headers({
    "Accept: application/vnd.github.v3.full+json",
    "User-Agent: Retrofit-Sample-App"
})
@GET("users/{username}")
Call&lt;User&gt; getUser(@Path("username") String username);

//动态表头
@GET("user")
Call&lt;User&gt; getUser(@Header("Authorization") String authorization)
</code></pre> 
<hr> 
<h3><a id="retrofit2_223"></a>用retrofit2实现网络请求案例</h3> 
<h3><a id="1_224"></a>1.构建一个小型服务器</h3> 
<p>使用eclipse创建一个web server项目HttpRequestDemo，然后创建一个继承HttpServlet的实现类。<br> 这是一个用户登录的验证服务，正确的用户名qq123456,密码666666,返回一个json字符串。<br> 这里处理的是GET请求，post请求用的也是一模一样的代码。</p> 
<pre><code>public class WebServerDemo extends HttpServlet {
	private static final long serialVersionUID = 29328731L;

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String name =request.getParameter("name");
		String password=request.getParameter("pwd");
		String result="";
		String msg="";
		if(!"qq123456".equalsIgnoreCase(name)){
			result="fail";
			msg="user name is fail";
		}else{
			if(!"666666".equals(password)){
				result="fail";
				msg="password is fail";
			}else{
				result="success";
				msg="mession success";
			}
		}
		String returnJson="{\"result\":\""+result+"\",\"msg\":\""+msg+"\"}";
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("&lt;HTML&gt;");
		out.println("  &lt;HEAD&gt;&lt;TITLE&gt;login page&lt;/TITLE&gt;&lt;/HEAD&gt;");
		out.println("  &lt;BODY&gt;");
		out.println(returnJson);
		out.println("  &lt;/BODY&gt;");
		out.println("&lt;/HTML&gt;");
		out.flush();
		out.close();
	}
}
</code></pre> 
<p>在WebRoot/WEB_INF/web.xml里配置servlet与外部访问的路径地址</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
....
  &lt;!--配置servlet对应的类名与路径名 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;WebServerDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;server.WebServerDemo&lt;/servlet-class&gt;
  &lt;/servlet&gt;
	&lt;!--将servlet与web对应 --&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;WebServerDemo&lt;/servlet-name&gt;
    &lt;!--/login即是外部访问的路径--&gt;
    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;	
.....
&lt;/web-app&gt;

</code></pre> 
<p>最后将HttpRequestDemo部署至Tomcat中即可完成这个用户登录验证的小型服务器。 <strong><a href="http://download.csdn.net/detail/pigdreams/9815269">下载地址</a></strong></p> 
<h3><a id="2_285"></a>2.发送登录请求</h3> 
<p>首先创建一个as自带的loginactivity登录界面，然后简化一些代码，减少登录过程中的一些验证。<br> 然后运用上文步骤来发送联网请求。</p> 
<pre><code>public interface LoginService {
        @GET("{filepath}/login")
        Call&lt;String&gt; login4Path(@Path("filepath") String filepath);
    }
</code></pre> 
<pre><code>//注意这里的baseUrl是本机的IP地址,端口是tomcat默认的8080
//这里并没有添加任何转换器
mRetrofit=new Retrofit.Builder()
                .baseUrl("http://192.168.0.199:8080/")
                .build();
</code></pre> 
<pre><code>  Call&lt;String&gt; call=mRetrofit.create(LoginService.class).login4Path("HttpRequestDemo");
 call.enqueue(new Callback&lt;String&gt;() {
            @Override
            public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) {
                String resultStr=response.body();
                mResultTextView.setText(resultStr);
                showProgress(false);
                if(resultStr.contains("fail")){
                    mPasswordView.requestFocus();
                    Toast.makeText(getApplicationContext(),"登录失败",Toast.LENGTH_SHORT).show();
                }else if(resultStr.contains("success")){
                    startActivity(new Intent(RetrofixDemoActivity.this,LitepalDemoActivity.class));
                }

            }

            @Override
            public void onFailure(Call&lt;String&gt; call, Throwable t) {
                t.printStackTrace();
            }
        });

</code></pre> 
<p>点击登录按钮，程序崩溃，一直报如下异常，无法创建一个转换器，LoginService.login4Path这个方法的结果无法转换成String.</p> 
<pre><code>java.lang.IllegalArgumentException: Unable to create converter for class java.lang.String for method LoginService.login4Path at retrofit2.ServiceMethod$Builder.methodError(ServiceMethod.java:751) at retrofit2.ServiceMethod$Builder.createResponseConverter(ServiceMethod.java:737) at retrofit2.ServiceMethod$Builder.build(ServiceMethod.java:168) at retrofit2.Retrofit.loadServiceMethod(Retrofit.java:169) at retrofit2.Retrofit$1.invoke(Retrofit.java:146) at $Proxy0.login4Path(Native Method)
</code></pre> 
<p><strong>这个错误的原因在于如果构建时retrofix实例时没有添加转换器</strong>，<strong>则Call对象的泛型只能使用RequestBody</strong>,这是比较容易忽略的异常。<br> 将所有Call里的泛型换成RequestBody类，然后再运行程序,登录成功会跳转至另一个界面。</p> 
<pre><code>Call&lt;ResponseBody&gt; call=service.login4Path("HttpRequestDemo");
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                ResponseBody body=response.body();
                String resultStr= "";
                try {
                    resultStr = body.string();
                } catch (IOException e) {
                    e.printStackTrace();
                }
......
</code></pre> 
<p>这里不管输入什么都是返回用户名错误，因为这个请求并没有传参数，只是简单地返回了用户名不相同时的result与msg.<br> <img src="https://images2.imgbox.com/a9/0b/7Zv6jjuW_o.png" alt="这里写图片描述"><br> 用一个Textview来显示服务器返回的所有数据。<br> ###3.用Post方式进行请求</p> 
<pre><code> public interface LoginService {
        @POST("{filepath}/login")
        Call&lt;ResponseBody&gt; login4Path(@Path("filepath") String filePath,
                                      @Query("name")String name,
                                      @Query("pwd")String pwd);
    }
</code></pre> 
<pre><code>  String email = mEmailView.getText().toString();
   String password = mPasswordView.getText().toString();
 LoginService service=mRetrofit.create(LoginService.class);
 Call&lt;ResponseBody&gt;call=
 service.login4Path("HttpRequestDemo",email,password);
  call.enqueue(new Callback&lt;ResponseBody&gt;() {...}
</code></pre> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/bf/2e/9tZyG9gk_o.png" alt="这里写图片描述"></p> 
<p><strong><a href="https://github.com/hapzhu/MyApplication">demo地址</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b00c6618bc6d4fb08e7850cf07a05359/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gitlab部署CI并使用.gitlab-ci.yml配置您的作业(中文翻译)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b54c152cbf3ffc29318988ee8d3080c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang string 和 int 的互相转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>