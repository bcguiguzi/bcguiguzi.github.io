<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDU 5314 Happy King （点分治） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDU 5314 Happy King （点分治）" />
<meta property="og:description" content="Happy King Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)
Total Submission(s): 1077 Accepted Submission(s): 265
Problem Description
There are n cities and n−1 roads in Byteland, and they form a tree. The cities are numbered 1 through n. The population in i-th city is pi.
Soda, the king of Byteland, wants to travel from a city u to another city v along the shortest path. Soda would be happy if the difference between the maximum and minimum population among the cities passed is **no larger than** D." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9506437a29ca89535f38cb79b881fd98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-20T18:04:25+08:00" />
<meta property="article:modified_time" content="2018-01-20T18:04:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDU 5314 Happy King （点分治）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Happy King</h2> 
<p> </p> 
<p><strong><span style="color:#008000;"><strong>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 262144/262144 K (Java/Others)<br> Total Submission(s): 1077    Accepted Submission(s): 265</strong></span></strong></p> 
<p> </p> 
<p> </p> 
<p>Problem Description</p> 
<p>There are <em id="MathJax-Span-3">n</em> cities and <em id="MathJax-Span-6">n</em>−1 roads in Byteland, and they form a tree. The cities are numbered 1 through <em id="MathJax-Span-14">n</em>. The population in <em id="MathJax-Span-17">i</em>-th city is <em id="MathJax-Span-21">p</em><em id="MathJax-Span-22">i</em>.<br><br> Soda, the king of Byteland, wants to travel from a city <em id="MathJax-Span-25">u</em> to another city <em id="MathJax-Span-28">v</em> along the shortest path. Soda would be happy if the difference between the maximum and minimum population among the cities passed is **no larger than** <em id="MathJax-Span-31">D</em>. So, your task is to tell Soda how many different pairs (<em id="MathJax-Span-35">u</em>,<em id="MathJax-Span-37">v</em>) that can make him happy.</p> 
<p> </p> 
<p> </p> 
<p>Input</p> 
<p>There are multiple test cases. The first line of input contains an integer <em id="MathJax-Span-41">T</em> (1≤<em id="MathJax-Span-47">T</em>≤500), indicating the number of test cases. For each test case:<br><br> The first line contains two integers <em id="MathJax-Span-53">n</em> and <em id="MathJax-Span-56">D</em> (1≤<em id="MathJax-Span-62">n</em>≤100000,1≤<em id="MathJax-Span-68">D</em>≤109).<br><br> The second line contains <em id="MathJax-Span-76">n</em> integers <em id="MathJax-Span-80">p</em>1,<em id="MathJax-Span-84">p</em>2,…,<em id="MathJax-Span-90">p</em><em id="MathJax-Span-91">n</em> (0≤<em id="MathJax-Span-98">p</em><em id="MathJax-Span-99">i</em>≤109).<br><br> Each of the following <em id="MathJax-Span-107">n</em>−1 lines describing roads contains two integers <em id="MathJax-Span-112">u</em>,<em id="MathJax-Span-114">v</em> (1≤<em id="MathJax-Span-120">u</em>,<em id="MathJax-Span-122">v</em>≤<em id="MathJax-Span-124">n</em>,<em id="MathJax-Span-126">u</em>≠<em id="MathJax-Span-128">v</em>) meaning that there is a road connecting city <em id="MathJax-Span-132">u</em> and city <em id="MathJax-Span-135">v</em>.<br><br> It is guaranteed that the total number of vertices in the input doesn't exceed 5×105.</p> 
<p> </p> 
<p> </p> 
<p>Output</p> 
<p>For each test case, output the number of different pairs that can make Soda happy.</p> 
<p> </p> 
<p> </p> 
<p>Sample Input</p> 
<pre> </pre> 
<p>1 3 3 1 2 3 1 2 2 3</p> 
<p> </p> 
<p> </p> 
<p>Sample Output</p> 
<p>6</p> 
<p> </p> 
<p>题意：<br> 第一个t，测试数据<br> 给你n个点，每个点有权值pi,再给你n-1条边，问你有多少对(u,v)使得,u-&gt;v的最短路径上经过的点的最大权值与最小权值的差&lt;=k</p> 
<p>解析：<br> 实际上就是树的点分治。<br> 不过这里的条件是路径上经过的最大权值和最小权值。<br> 找重心的代码就说了。</p> 
<p>关键是在一个子树中，找到当前子树的根节点到子树中各个节点路径上的最小值和最大值，然后如果最大值-最小值&lt;=k,那么保存在pp[]里</p> 
<p>之后，将pp按最小值排序，这样从前往后扫一遍就可以得出，经过当前子树根节点且满足条件的(u,v)的个数</p> 
<p>因为这里当你用Pp[i].max去找时满足条件的节点Pp[j].min(j&lt;i)时，</p> 
<p>Pp[i].max-Pp[i].min&lt;=k,</p> 
<p>pp[j].max-pp[j].min&lt;=k</p> 
<p>pp[j].min&lt;=pp[i].min</p> 
<p>=&gt;pp[j].max&lt;=k+pp[j].min&lt;=pp[i].min+k</p> 
<p>所以只要构造pp[i].max-pp[j].min&lt;=k，那么这两个点无论如何(i点的max大，还是j点的max大)，都能满足条件</p> 
<pre class="has"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
typedef long long int lli;
#define INF 9999999999

typedef struct node
{
    int u,v;
    int nxt;
}node;


typedef struct point
{
    lli _min,_max;
    bool operator &lt; (const point&amp; b)
    {
        return _min==b._min?_max&lt;b._max:_min&lt;b._min;
    }
}point;
const int MAXN = 1e5+110;

point pp[MAXN];
int n,cnt,ck,ncount;
lli k;
lli ver[MAXN];
int head[MAXN];
node edge[2*MAXN];
int visit[MAXN],siz[MAXN],maxf[MAXN];
lli ans;

void addedge(int u,int v)
{
    edge[cnt].u=u;
    edge[cnt].v=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt++;
}

int wr;

void getroot(int u,int fa)
{
    siz[u]=1;
    maxf[u]=0;
    for(int i=head[u];i!=-1;i=edge[i].nxt)
    {
        int v=edge[i].v;
        if(v!=fa&amp;&amp;!visit[v])
        {
            getroot(v,u);
            maxf[u]=max(maxf[u],siz[v]);
            siz[u]+=siz[v];
        }
    }
    maxf[u]=max(maxf[u],ncount-siz[u]); //Count表示当前子树的结点的总个数
    if(maxf[u]&lt;maxf[wr]) wr=u;
}

void dfs_maxmin(int u,int fa,lli maxv,lli minv)   //这里还需要重新计算每个子树的size
{                                              算出从根节点到每一个节点的路径中的最大值和最小值
    maxv=max(maxv,ver[u]);
    minv=min(minv,ver[u]);
    if(maxv-minv&lt;=k)
    {
        pp[ck]=point{minv,maxv};
        ck++;
    }
    for(int i=head[u];i!=-1;i=edge[i].nxt)
    {
        int v=edge[i].v;
        if(v!=fa&amp;&amp;!visit[v])
        {
            dfs_maxmin(v,u,maxv,minv);
        }
    }


}

lli cal(int u,int _min,int _max)
{
    lli ret=0;
    ck=0;
    dfs_maxmin(u,-1,_max,_min);
    sort(pp,pp+ck);      //P+i限制了查找答案只能在比P[i].min小的点里面找，那么无论是P[i].max大还是P[j].max大，最后他与最小值的差p[j].min都小于等于k(j在[1,i)满足条件的节点)
    for(int i=ck-1;i&gt;=0;i--)
    {
        int num=lower_bound(pp,pp+i,point{pp[i]._max-k,0})-pp;
        ret+=i-num;    //num为最远的满足条件的下标，在[num,i)之间的值都满足条件
    }
    return ret;

}

void DFS(int u)
{
    maxf[0]=ncount=siz[u];
    wr=0;
    getroot(u,-1);
    int root=wr;
    visit[root]=1;
    ans+=cal(root,INF,-INF);

    for(int i=head[root];i!=-1;i=edge[i].nxt)
    {
        int v=edge[i].v;
        if(!visit[v])
        {   //保持与前面情况一样，只是节点只有的左(右)子树的点，这样就可以找出一边的重复情况
            ans-=cal(v,ver[root],ver[root]);
            DFS(v);
        }
    }
}

int main()
{
    int t;
    scanf("%d",&amp;t);
    while(t--)
    {
        ans=0;
        scanf("%d%lld",&amp;n,&amp;k);
        for(int i=1;i&lt;=n;i++)
            scanf("%lld",&amp;ver[i]);
        cnt=0;
        memset(head,-1,sizeof(head));
        for(int i=1;i&lt;n;i++)
        {
            int u,v;
            scanf("%d%d",&amp;u,&amp;v);
            addedge(u,v);
            addedge(v,u);
        }
        memset(visit,0,sizeof(visit));
        siz[1]=n;
        DFS(1);
        printf("%lld\n",ans*2);

    }
}
</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd50bdce8cd8689ff5e746afadd7bf79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Anconda环境下Vscode安装Python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d18500525be2f212f4cf7eefb59aec79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实战：向GitHub提交代码时触发Jenkins自动构建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>