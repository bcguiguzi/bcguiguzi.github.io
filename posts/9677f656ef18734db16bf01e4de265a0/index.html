<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql表空间回收 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql表空间回收" />
<meta property="og:description" content="回收方法 1. alter table tb_test engine=innodb;
2. optimize table tb_test；
3. gh-ost/pt-osc
alter table tb_test engine=innodb 原理介绍 MySQL5.6 开始采用 Inplace 方式重建表，Alter 期间，支持 DML 查询和更新操作，语句为 alter table t engine=innodb, ALGORITHM=inplace;之所以支持 DML 更新操作，是因为数据拷贝期间会将 DML 更新操作记录到 Row log 中。
重建过程中最耗时的就是拷贝数据的过程，这个过程中支持 DML 查询和更新操作，对于整个 DDL 来说，锁时间很短，就可以近似认为是 Online DDL。
执行过程：
1、获取 MDL（Meta Data Lock）写锁，innodb 内部创建与原表结构相同的临时文件
2、拷贝数据之前，MDL 写锁退化成 MDL 读锁，支持 DML 更新操作
3、根据主键递增顺序，将一行一行的数据读出并写入到临时文件，直至全部写入完成。并且，会将拷贝期间的 DML 更新操作记录到 Row log 中
4、上锁，再将 Row log 中的数据应用到临时文件
5、互换原表和临时表表名
6、删除临时表
alter table、analyze table和optimize table区别 alter table tb_test engine = innode；（也就是 recreate）就是 Online DDL 重建表过程；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9677f656ef18734db16bf01e4de265a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-27T16:54:57+08:00" />
<meta property="article:modified_time" content="2021-10-27T16:54:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql表空间回收</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>回收方法</h2> 
<p>    1. alter table tb_test engine=innodb;<br>     2. optimize table tb_test；<br>     3. gh-ost/pt-osc<br>     </p> 
<h2>alter table tb_test engine=innodb 原理介绍</h2> 
<p>        MySQL5.6 开始采用 Inplace 方式重建表，Alter 期间，支持 DML 查询和更新操作，语句为 alter table t engine=innodb, ALGORITHM=inplace;之所以支持 DML 更新操作，是因为数据拷贝期间会将 DML 更新操作记录到 Row log 中。</p> 
<p>        重建过程中最耗时的就是拷贝数据的过程，这个过程中支持 DML 查询和更新操作，对于整个 DDL 来说，锁时间很短，就可以近似认为是 Online DDL。</p> 
<p>        执行过程：</p> 
<p>        1、获取 <span style="color:#fe2c24;">MDL（Meta Data Lock）写锁</span>，innodb 内部创建与原表结构相同的临时文件</p> 
<p>        2、拷贝数据之前，<span style="color:#fe2c24;">MDL 写锁退化成 MDL 读锁</span>，支持 DML 更新操作</p> 
<p>        3、根据主键递增顺序，将一行一行的数据读出并写入到临时文件，直至全部写入完成。并且，会将拷贝期间的 DML 更新操作记录到 Row log 中</p> 
<p>        4、<span style="color:#fe2c24;">上锁，再将 Row log 中的数据应用到临时文件</span></p> 
<p>        5、互换原表和临时表表名</p> 
<p>        6、删除临时表</p> 
<h2><br> alter table、analyze table和optimize table区别</h2> 
<p>        alter table tb_test engine = innode；（也就是 recreate）就是 Online DDL 重建表过程；</p> 
<p>        analyze table tb_test ； 不是重建表过程，它只是对索引信息重新统计，会上 MDL 读锁；</p> 
<p>        optimize table tb_test ；是 alter table tb_test engine = innode； + analyze 过程。</p> 
<p></p> 
<p></p> 
<p>OPTIMIZE TABLE 和ALTER TABLE xxxx ENGINE= INNODB哪个更好</p> 
<p>        OPTIMIZE TABLE 还是ALTER TABLE xxxx ENGINE= INNODB基本上是一样的。但是在有些情况下，ALTER TABLE xxxx ENGINE= INNODB更好。例如old_alter_table系统变量没有启用等等。另外对于MyISAM类型表，使用ALTER TABLE xxxx ENGINE= INNODB是明显要优于OPTIMIZE TABLE这种方法的。</p> 
<p></p> 
<p>ALTER TABLE xxxx ENGINE= INNODB 表上的索引碎片会整理么</p> 
<p>        ALTER TABLE ENGINE= INNODB,会重新整理在聚簇索引上的数据和索引。如果你想用实验验证，可以对比执行该命令前后index_length的大小。</p> 
<p></p> 
<p>        对于大表的重建，十分消耗 IO 和 CPU 资源。如果是线上服务，为了安全性考虑，建议使用 GitHub 开源的 gh-ost 来做。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73d6d09f0f7f381bc3db4dbabaad17f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决VS Code编辑运行C/C&#43;&#43;代码文件中文乱码问题；修改编码为GBK</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19fc8cb78130b0824ef04a13b255a892/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">漂泊不定的人生，终究在层层浪花中，站稳了跟脚，姐成功了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>