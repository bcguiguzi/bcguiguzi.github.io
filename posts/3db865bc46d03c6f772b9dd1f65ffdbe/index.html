<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring redis和缓存的应用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring redis和缓存的应用" />
<meta property="og:description" content="spring redis和缓存的应用 1、在springboot项目中引入redis的包，即在pom.xml文件中导入一下依赖，刷新maven可看见右侧依赖
2、使用缓存前在项目启动类（Demo1Application）中开启缓存
3、启动redis
4、配置application.properties文件以连接redis
5、导入redis配置类
/** * Redis配置类 * @author xiaoshu */ @Configuration public class RedisConfig { // ${cache} 获取配置文件的配置信息 #{}是spring表达式，获取Bean对象的属性 @Value(&#34;${spring.cache.ttl}&#34;) //${spring.cache.ttl}:绝对路径 private int ttlParams; /** * @param redisConnectionFactory * @功能描述 redis作为缓存时配置缓存管理器CacheManager，主要配置序列化方式、自定义 * &lt;p&gt; * 注意：配置缓存管理器CacheManager有两种方式： * 方式1：通过RedisCacheConfiguration.defaultCacheConfig()获取到默认的RedisCacheConfiguration对象， * 修改RedisCacheConfiguration对象的序列化方式等参数【这里就采用的这种方式】 * 方式2：通过继承CachingConfigurerSupport类自定义缓存管理器，覆写各方法，参考： * https://blog.csdn.net/echizao1839/article/details/102660649 * &lt;p&gt; * 切记：在缓存配置类中配置以后，yaml配置文件中关于缓存的redis配置就不会生效，如果需要相关配置需要通过@value去读取 */ @Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig(); redisCacheConfiguration = redisCacheConfiguration // 设置key采用String的序列化方式 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer.UTF_8)) //设置value序列化方式采用jackson方式序列化 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3db865bc46d03c6f772b9dd1f65ffdbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-17T20:50:24+08:00" />
<meta property="article:modified_time" content="2022-05-17T20:50:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring redis和缓存的应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="spring_redis_0"></a>spring redis和缓存的应用</h2> 
<p>1、在springboot项目中引入redis的包，即在pom.xml文件中导入一下依赖，刷新maven可看见右侧依赖<br> <img src="https://images2.imgbox.com/e0/7d/mICabV3b_o.png" alt="在这里插入图片描述"><br> 2、使用缓存前在项目启动类（Demo1Application）中开启缓存<br> <img src="https://images2.imgbox.com/d2/24/TXMDNiYS_o.png" alt="在这里插入图片描述"><br> 3、启动redis<br> <img src="https://images2.imgbox.com/00/c8/2TK3OE1q_o.png" alt="在这里插入图片描述"><br> 4、配置application.properties文件以连接redis<br> <img src="https://images2.imgbox.com/f5/36/oA5sNLhB_o.png" alt="在这里插入图片描述"><br> 5、导入redis配置类</p> 
<pre><code>/**
 * Redis配置类
 * @author xiaoshu
 */

@Configuration
public class RedisConfig {

    // ${cache} 获取配置文件的配置信息   #{}是spring表达式，获取Bean对象的属性
    @Value("${spring.cache.ttl}")  //${spring.cache.ttl}:绝对路径
    private int ttlParams;

    /**
     * @param redisConnectionFactory
     * @功能描述 redis作为缓存时配置缓存管理器CacheManager，主要配置序列化方式、自定义
     * &lt;p&gt;
     * 注意：配置缓存管理器CacheManager有两种方式：
     * 方式1：通过RedisCacheConfiguration.defaultCacheConfig()获取到默认的RedisCacheConfiguration对象，
     * 修改RedisCacheConfiguration对象的序列化方式等参数【这里就采用的这种方式】
     * 方式2：通过继承CachingConfigurerSupport类自定义缓存管理器，覆写各方法，参考：
     * https://blog.csdn.net/echizao1839/article/details/102660649
     * &lt;p&gt;
     * 切记：在缓存配置类中配置以后，yaml配置文件中关于缓存的redis配置就不会生效，如果需要相关配置需要通过@value去读取
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        redisCacheConfiguration = redisCacheConfiguration
                // 设置key采用String的序列化方式
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer.UTF_8))
                //设置value序列化方式采用jackson方式序列化
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer()))
                //当value为null时不进行缓存
                .disableCachingNullValues()
                // 配置缓存空间名称的前缀
                .prefixCacheNameWith("demo:")
                //全局配置缓存过期时间【可以不配置】
                .entryTtl(Duration.ofMinutes(30L));
        //专门指定某些缓存空间的配置，如果过期时间【主要这里的key为缓存空间名称】
        Map&lt;String, RedisCacheConfiguration&gt; map = new HashMap&lt;&gt;();
        map.put("user", redisCacheConfiguration.entryTtl(Duration.ofSeconds(ttlParams)));
        return RedisCacheManager
                .builder(redisConnectionFactory)
                .cacheDefaults(redisCacheConfiguration)  //默认配置
                .withInitialCacheConfigurations(map)  //某些缓存空间的特定配置
                .build();
    }


    /**
     * 自定义缓存的redis的KeyGenerator【key生成策略】
     * 注意: 该方法只是声明了key的生成策略,需在@Cacheable注解中通过keyGenerator属性指定具体的key生成策略
     * 可以根据业务情况，配置多个生成策略
     * 如: @Cacheable(value = "key", keyGenerator = "cacheKeyGenerator")
     */
    @Bean
    public KeyGenerator keyGenerator() {
        /**
         * target: 类
         * method: 方法
         * params: 方法参数
         */
        return (target, method, params) -&gt; {
            //获取代理对象的最终目标对象
            StringBuilder sb = new StringBuilder();
            sb.append(target.getClass().getSimpleName()).append(":");
            sb.append(method.getName()).append(":");
            //调用SimpleKey的key生成器
            Object key = SimpleKeyGenerator.generateKey(params);
            return sb.append(key);
        };
    }


    /**
     * @param redisConnectionFactory：配置不同的客户端，这里注入的redis连接工厂不同： JedisConnectionFactory、LettuceConnectionFactory
     * @功能描述 ：配置Redis序列化，原因如下：
     * （1） StringRedisTemplate的序列化方式为字符串序列化，
     * RedisTemplate的序列化方式默为jdk序列化（实现Serializable接口）
     * （2） RedisTemplate的jdk序列化方式在Redis的客户端中为乱码，不方便查看，
     * 因此一般修改RedisTemplate的序列化为方式为JSON方式【建议使用GenericJackson2JsonRedisSerializer】
     */
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = serializer();
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        // key采用String的序列化方式
        redisTemplate.setKeySerializer(StringRedisSerializer.UTF_8);
        // value序列化方式采用jackson
        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);
        // hash的key也采用String的序列化方式
        redisTemplate.setHashKeySerializer(StringRedisSerializer.UTF_8);
        //hash的value序列化方式采用jackson
        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }

    /**
     * 此方法不能用@Ben注解，避免替换Spring容器中的同类型对象
     */
    public GenericJackson2JsonRedisSerializer serializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
}
</code></pre> 
<p>6、自动装配cache对象<br> <img src="https://images2.imgbox.com/10/9a/E37uGvRy_o.png" alt="在这里插入图片描述"><br> 7、缓存注解使用<br> 注解 作用 参数<br> @EnableCaching 开启缓存 /<br> @Cacheable 对方法返回结果进行缓存 cacheNames / value / key / keyGenerator<br> @CacheEvict 清空缓存 cacheNames / value / key / keyGenerator<br> @CachePut 保证方法被调用，又希望结果被缓存 cacheNames / value / key/ keyGenerator<br> <img src="https://images2.imgbox.com/31/d2/EwlLkxFA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2f/cc/WVT0RWHL_o.png" alt="在这里插入图片描述"><br> 8、安装redis helper并连接redis<br> <img src="https://images2.imgbox.com/9f/9c/F4zgvOyN_o.png" alt="在这里插入图片描述"><br> 9、使用RESTED查询一个用户<br> <img src="https://images2.imgbox.com/9e/df/S3cJtj4j_o.png" alt="在这里插入图片描述"><br> 10、回到IDEA刷新缓存对象<br> <img src="https://images2.imgbox.com/41/df/5NhbNFOn_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/134ef62252aeef5beead30d9c5150008/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实验1:同一VLAN下不同交换机之间的数据转发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54f55ab79389c9668604663b740ea13d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">巴特沃斯(Butterworth)滤波器（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>