<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RAID技术详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RAID技术详解" />
<meta property="og:description" content="目录
1、RAID技术概述 2、RAID数据组织形式
3、RAID数据保护方式
4、常用的RAID级别
4.1 RAID 0
RAID 0工作原理
RAID 0数据的存取
4.2 RAID 1
RAID 1工作原理
RAID 1数据的存取
4.3 RAID 3 RAID 3工作原理
RAID 3数据的存取
4.4 RAID 5
RAID 5工作原理
RAID 5数据的存取
4.5 RAID 6
RAID 6 P&#43;Q的工作原理
RAID 6 DP工作原理
数据恢复
4.6 混合RAID
RAID 10
RAID 50
1、RAID技术概述 RAID（redundant array of independent disks）技术，独立磁盘冗余阵列，是提高磁盘可靠性和可用性的一种技术。RAID技术出现的初衷是把多个小容量的硬盘组合起来，以获得更大的存储容量。当前我们所说的RAID技术更多则是与数据保护相关，换言之，当物理设备失效时，RAID能够用来防止数据的丢失。
RAID技术的主要功能： 通过对硬盘上的数据进行条带化，实现对数据成块存取，减少硬盘的机械寻道时间，提高了数据存取速度。 通过对一阵列中的几块硬盘同时读取（并行访问），减少了硬盘的机械寻道时间，提高了数据存取速度。 通过镜像或者存储奇偶校验信息的方式，实现了对数据的冗余保护。
随着阵列技术的发展，已经产生了很多不同类型的RAID，但现在只有少数几种RAID仍在使用。选择不同的RAID类型意味着不同的性能/成本。 在存储设备中，可以通过2种方式实现RAID功能：硬件RAID和软件RAID。
硬件RAID使用专用的RAID适配器、硬盘控制器或存储处理器。RAID控制器有自己的处理器，I/O处理芯片，和内存，用来提高资源利用率和数据传输速度。RAID控制器管理路由、缓冲区，控制主机与RAID间数据流。硬件RAID通常在服务器中使用。软件实现的RAID没有它自己的处理器或I/O处理芯片，而是完全依赖于主机处理器。因此，低速CPU不能满足RAID实施的要求。软件RAID通常在企业级存储设备上使用。 总结来说，RAID技术的优势体现在如下几个方面：
把多个硬盘组合成一个逻辑盘组，以提供更大容量的存储。将数据分割成数据块，对多个硬盘并行进行写入/读出，提高硬盘访问速度。通过提供镜像或奇偶校验来提供容错。 2、RAID数据组织形式 条带（strip）：硬盘中单个或多个连续的扇区构成一个条带，它是一块硬盘上进一次数据读写的最小单元。它是组成分条的元素。
分条（stipe）：同一个硬盘阵列中，多个硬盘驱动器上的相同位置的条带（或者说相同编号）。
分条深度：一个条带的大小。
分条宽度：一个分条中，数据盘成员的个数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/10442c2793aff996b5297be6f6894f31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-21T21:00:20+08:00" />
<meta property="article:modified_time" content="2020-08-21T21:00:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RAID技术详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81RAID%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%C2%A0-toc" style="margin-left:0px;"><a href="#1%E3%80%81RAID%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%C2%A0" rel="nofollow">1、RAID技术概述 </a></p> 
<p id="2%E3%80%81RAID%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F-toc" style="margin-left:0px;"><a href="#2%E3%80%81RAID%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F" rel="nofollow">2、RAID数据组织形式</a></p> 
<p id="3%E3%80%81RAID%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#3%E3%80%81RAID%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E5%BC%8F" rel="nofollow">3、RAID数据保护方式</a></p> 
<p id="4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84RAID%E7%BA%A7%E5%88%AB-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84RAID%E7%BA%A7%E5%88%AB" rel="nofollow">4、常用的RAID级别</a></p> 
<p id="4.1%20RAID%200-toc" style="margin-left:40px;"><a href="#4.1%20RAID%200" rel="nofollow">4.1 RAID 0</a></p> 
<p id="RAID%200%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%200%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 0工作原理</a></p> 
<p id="RAID%200%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96-toc" style="margin-left:80px;"><a href="#RAID%200%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96" rel="nofollow">RAID 0数据的存取</a></p> 
<p id="4.2%20RAID%201-toc" style="margin-left:40px;"><a href="#4.2%20RAID%201" rel="nofollow">4.2 RAID 1</a></p> 
<p id="RAID%201%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%201%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 1工作原理</a></p> 
<p id="%C2%A0RAID%201%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96-toc" style="margin-left:80px;"><a href="#%C2%A0RAID%201%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96" rel="nofollow">RAID 1数据的存取</a></p> 
<p id="4.3%20RAID%203%C2%A0-toc" style="margin-left:40px;"><a href="#4.3%20RAID%203%C2%A0" rel="nofollow">4.3 RAID 3 </a></p> 
<p id="RAID%203%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%203%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 3工作原理</a></p> 
<p id="RAID%203%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96-toc" style="margin-left:80px;"><a href="#RAID%203%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96" rel="nofollow">RAID 3数据的存取</a></p> 
<p id="4.4%20RAID%205-toc" style="margin-left:40px;"><a href="#4.4%20RAID%205" rel="nofollow">4.4 RAID 5</a></p> 
<p id="RAID%205%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%205%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 5工作原理</a></p> 
<p id="RAID%205%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96-toc" style="margin-left:80px;"><a href="#RAID%205%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96" rel="nofollow">RAID 5数据的存取</a></p> 
<p id="4.5%20RAID%206-toc" style="margin-left:40px;"><a href="#4.5%20RAID%206" rel="nofollow">4.5 RAID 6</a></p> 
<p id="RAID%206%20P%2BQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%206%20P%2BQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 6 P+Q的工作原理</a></p> 
<p id="RAID%206%20DP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#RAID%206%20DP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">RAID 6 DP工作原理</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D" rel="nofollow">数据恢复</a></p> 
<p id="4.6%20%E6%B7%B7%E5%90%88RAID-toc" style="margin-left:40px;"><a href="#4.6%20%E6%B7%B7%E5%90%88RAID" rel="nofollow">4.6 混合RAID</a></p> 
<p id="RAID%2010-toc" style="margin-left:80px;"><a href="#RAID%2010" rel="nofollow">RAID 10</a></p> 
<p id="RAID%2050-toc" style="margin-left:80px;"><a href="#RAID%2050" rel="nofollow">RAID 50</a></p> 
<hr id="hr-toc"> 
<h2>1、RAID技术概述 </h2> 
<p style="text-indent:33px;">RAID（redundant array of independent disks）技术，独立磁盘冗余阵列，是提高磁盘可靠性和可用性的一种技术。RAID技术出现的初衷是把多个小容量的硬盘组合起来，以获得更大的存储容量。当前我们所说的<span style="color:#3399ea;">RAID技术更多则是与数据保护相关</span>，换言之，当物理设备失效时，RAID能够用来防止数据的丢失。</p> 
<p style="text-align:center;"><img alt="" height="131" src="https://images2.imgbox.com/c2/d2/vyKrkZ1y_o.png" width="500"></p> 
<p style="text-indent:33px;"><strong>RAID技术的主要功能：</strong> 通过对硬盘上的数据进行条带化，实现对数据成块存取，减少硬盘的机械寻道时间，提高了数据存取速度。 通过对一阵列中的几块硬盘同时读取（并行访问），减少了硬盘的机械寻道时间，提高了数据存取速度。 通过镜像或者存储奇偶校验信息的方式，实现了对数据的冗余保护。</p> 
<p style="text-indent:33px;">随着阵列技术的发展，已经产生了很多不同类型的RAID，但现在只有少数几种RAID仍在使用。选择不同的RAID类型意味着不同的性能/成本。 在存储设备中，可以通过2种方式实现RAID功能：硬件RAID和软件RAID。</p> 
<ul><li>硬件RAID使用专用的RAID适配器、硬盘控制器或存储处理器。RAID控制器有自己的处理器，I/O处理芯片，和内存，用来提高资源利用率和数据传输速度。RAID控制器管理路由、缓冲区，控制主机与RAID间数据流。硬件RAID通常在服务器中使用。</li><li>软件实现的RAID没有它自己的处理器或I/O处理芯片，而是完全依赖于主机处理器。因此，低速CPU不能满足RAID实施的要求。软件RAID通常在企业级存储设备上使用。</li></ul> 
<blockquote> 
 <p>总结来说，RAID技术的优势体现在如下几个方面：</p> 
 <ol><li>把多个硬盘组合成一个逻辑盘组，以提供更大容量的存储。</li><li>将数据分割成数据块，对多个硬盘并行进行写入/读出，提高硬盘访问速度。</li><li>通过提供镜像或奇偶校验来提供容错。</li></ol> 
</blockquote> 
<h2 id="2%E3%80%81RAID%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F">2、RAID数据组织形式</h2> 
<p><strong>条带</strong>（strip）：硬盘中单个或多个连续的扇区构成一个条带，它是一块硬盘上进一次数据读写的最小单元。它是组成分条的元素。</p> 
<p><strong>分条</strong>（stipe）：同一个硬盘阵列中，多个硬盘驱动器上的相同位置的条带（或者说相同编号）。</p> 
<p style="text-align:center;"><img alt="" height="200" src="https://images2.imgbox.com/9c/b1/pryXPbyE_o.png" width="755"></p> 
<p><strong>分条深度</strong>：一个条带的大小。</p> 
<p><strong>分条宽度</strong>：一个分条中，数据盘成员的个数。</p> 
<h2 id="3%E3%80%81RAID%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E5%BC%8F">3、RAID数据保护方式</h2> 
<p><strong>1.冗余备份：</strong>拿出额外的硬盘，对数据进行保存备份。</p> 
<p><strong>2.奇偶校验算法：</strong>使用用户数据计算出额外的信息，同样的道理使用奇偶校验的RAID类型，必须拿出额外的校验硬盘。奇偶校验算法采用的是异或算法（XOR）。</p> 
<p>奇偶校验算法：</p> 
<ul><li>XOR运算广泛地使用在数字电子和计算机科学中。</li><li>XOR校验的算法——相同为假，相异为真： 0⊕0= 0； 0⊕1= 1； 1⊕0= 1； 1⊕1= 0；</li></ul> 
<p style="text-align:center;"><img alt="" height="200" src="https://images2.imgbox.com/14/e8/k3Xbiwie_o.png" width="511"></p> 
<p style="text-indent:33px;">这样不管哪块硬盘出现了损坏，都可以通过剩余的两块硬盘来推算出损坏的数据；前提是拿出了一块额外的校验硬盘来保证数据的安全。</p> 
<h2 id="4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84RAID%E7%BA%A7%E5%88%AB">4、常用的RAID级别</h2> 
<p style="text-indent:33px;">RAID技术将多个单独的物理硬盘以不同的方式组合成一个逻辑硬盘，提高了硬盘的读写性和数据安全性，根据不同的组合方式分为不同的RAID级别。</p> 
<p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/6a/29/piNfMBDf_o.png" width="407"></p> 
<h3 id="4.1%20RAID%200">4.1 RAID 0</h3> 
<h4 id="RAID%200%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RAID 0工作原理</h4> 
<p style="text-indent:33px;">在所有的RAID级别中，RAID 0（也被称为条带化RAID）的具有最高的存储性能。RAID 0使用条带化技术将数据分布存储于RAID组的所有硬盘中。逻辑容量为所有物理硬盘的总和。</p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/63/83/Ln8URIXH_o.png" width="569"></p> 
<p style="text-indent:33px;">一个RAID 0包含至少2个成员盘。RAID 0组将数据分为大小不等的从512个字节至兆字节的数据块（通常是512字节的倍数），并行将其写入到不同的硬盘中。</p> 
<p style="text-indent:33px;">如图所示的两个硬盘（驱动器）构成的RAID中：前两块数据被写入到分条0上，其中，第一个数据块被写在硬盘1的条带0上，第二个数据块并行存放在硬盘2的条带0上；这时，再下一个数据块被写到硬盘1上的下一个条带（条带1）上，以此类推。以这种方式，I/O的负载平衡分布在RAID中的所有硬盘上，由于数据传输总线上的速度远大于硬盘读写速度，因此，RAID组上的硬盘可以认为在同时进行读写。</p> 
<p style="text-indent:33px;">一个RAID 0的硬盘组中的硬盘必须具有相同的大小，转速。如果一个RAID0的由4个硬盘组成，则读写速率理论上可达单个硬盘的4倍（实际上可能有系统损耗），容量为单个硬盘的4倍。RAID 0 中硬盘的容量大小不同，可用容量是最小的硬盘的容量的4倍，速度也是最小硬盘速度的4倍。</p> 
<p style="text-indent:33px;">RAID 0像是提供了一个单一的大容量的硬盘，还同时具有非常快速I/O的特点。在RAID 0技术使用之前，类似RAID 0的一种技术被称为JBOD。一个JBOD（Just a Bundle Of Disks，简称一堆硬盘）是一组硬盘组合成一个虚拟的大硬盘。与RAID 0最大的区别是，一个JBOD的数据块不是同时并行写入不同硬盘的。在JBOD中，只有将第一块硬盘的存储空间使用完，才会使用第二块硬盘。所以JBOD总的可用容量是所有个硬盘容量的总和，但性能是单个硬盘的性能！</p> 
<h4 id="RAID%200%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96">RAID 0数据的存取</h4> 
<p><strong>写入数据：</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/6a/a6/J6y5KBXj_o.png" width="283"></p> 
<ul><li>RAID 0采用条带化技术将数据写入硬盘中，它将数据分为数据块，并分布存储在RAID组的所有硬盘上，只有当前一个RAID组的分条被数据写满后。数据才会写入到下一个分条。在图中数据块D0、D1分别放入到了不同的硬盘的同一分条中；分条0放满后，在放入硬盘1的分条1，以此类推。通过条带化并行的方式，将所有的数据写入RAID 0组。</li><li>RAID 0的写入性能与硬盘数量成正比。 </li></ul> 
<p style="text-indent:0;"><strong>数据读取</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/36/68/BmrtLzJK_o.png" width="282"></p> 
<ul><li> 当RAID 0接收数据读取请求时，它会在所有硬盘上搜索目标数据块并读取数据。在图中，我们可以看到整个读取过程。 首先，阵列收到读取数据块D0，D1，D2，D3，D4，D5的请求。接下来，阵列并行从硬盘1读取D0，从硬盘2读取D1，其他数据块也按类似的方式读取。所有的数据块从RAID读取后，他们被集成到RAID控制器，然后发送到主机。</li><li>同写入数据一样，RAID 0的读取性能与硬盘的数量成正比</li></ul> 
<h3 id="4.2%20RAID%201">4.2 RAID 1</h3> 
<h4 id="RAID%201%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RAID 1工作原理</h4> 
<p style="text-indent:33px;">RAID 1（也被称为镜像结构的硬盘阵列）旨在建立一个高安全性的RAID级别。RAID1使用2个相同的硬盘系统，并设置了镜像。一个RAID 1组存储的数据量只是单个硬盘的容量，另一硬盘保存的是数据的副本。</p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/be/74/1NR4j4KB_o.png" width="494"></p> 
<ul><li> <p style="text-indent:0;">当数据写入到一个硬盘上时，数据的副本会同时存储在镜像硬盘上。当源硬盘（物理）失败时，镜像硬盘从源硬盘接管服务，保证服务的连续性。镜像盘作为备份，提供高数据可靠性。 相当于每一G字节的数据存储占用了2G字节的硬盘空间，所以说两个硬盘组成的RAID 1的空间利用率是50%。</p> </li><li> <p style="text-indent:0;">RAID 1的两个硬盘必须具有相同的大小。如果两个硬盘的容量大小不同，可用容量是最小的硬盘的容量。</p> </li></ul> 
<h4 id="%C2%A0RAID%201%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96">RAID 1数据的存取</h4> 
<p><strong>写入数据</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/bd/fa/5IrgB3lf_o.png" width="256"></p> 
<ul><li>RAID 0采用条带化技术将不同数据并行写入到硬盘中，而RAID 1则是同时写入相同的数据到每个硬盘，数据在所有成员硬盘中都是相同的。在上图所示，数据块D0，D1和D2，等待写入到硬盘。D0和D0的副本同时写入到两个硬盘中（硬盘1和硬盘2），其他数据块也以相同的方式（镜像）写入到RAID 1硬盘组中。</li><li>通常来说，一个RAID 1的写性能是单个硬盘的写性能。</li></ul> 
<p><strong>数据读取</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/29/f1/IeTpoVZD_o.png" width="255"></p> 
<ul><li>RAID 1读取数据时，会同时读取数据盘和镜像盘，以提高读取性能。如果其中一个硬盘失败，可以从另一个硬盘读取数据。</li><li>RAID 1系统的读取性能等于两个硬盘的性能之和。在RAID组降级的情况下，性能下降一半。</li></ul> 
<h3 id="4.3%20RAID%203%C2%A0">4.3 RAID 3 </h3> 
<h4 id="RAID%203%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><strong>RAID 3工作原理</strong></h4> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/c0/2d/G8IYKnjM_o.png" width="444"></p> 
<p style="text-indent:33px;">RAID3与RAID 0类似，不过RAID 3带有专用的奇偶校验分条。在RAID 3中，一块专用硬盘（校验盘）用来保存同一分条上其他硬盘的相应条带中的校验数据。如果其他盘上的数据出现丢失，或者磁盘出现损坏，我们可以使用校验盘的信息来恢复，损失的数据。</p> 
<p style="text-indent:33px;">RAID 3适用于数据密集型或单用户环境，需要长期、连续访问的数据块。RAID 3将数据写入操作分配给RAID组内的数据成员盘。但是，当有新数据需要写入时，无论写入哪个硬盘，RAID 3都需要重新计算并重写校验信息。因此，当某个应用程序需要大量写入时，RAID 3的奇偶校验盘将有很大的工作量。因为需要等待奇偶校验，所以会对RAID 3组的读写性能有一定影响。此外，因为校验盘有较高的工作负载，它往往是RAID 3里最容易失效的硬盘。这就是为什么校验盘被称为RAID 3的瓶颈的原因。</p> 
<p style="text-indent:33px;">假定一个RAID 3的硬盘数为N，其中有效用户数据存储容量为N-1个硬盘的容量。与其他RAID一样，RAID 3中的成员盘的容量和转速应该是相同的。 </p> 
<h4 id="RAID%203%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96">RAID 3数据的存取</h4> 
<p><strong>写入数据</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/e6/af/Nn7bO8Oa_o.png" width="508"></p> 
<ul><li>RAID 3采用单硬盘容错和并行数据传输。换句话说，RAID 3采用分条技术将数据分块，这些块进行异或算法，并将奇偶校验数据写到最后一个盘——RAID 3组的奇偶校验硬盘。当硬盘出现故障时，数据被写入到那些没有故障的硬盘上，奇偶校验继续。</li><li>RAID 3的性能不是固定的。原则上，RAID 3采用的是N+1的数据保护方法。这意味着当有N个硬盘的用户数据需要保护时，需要一个额外的硬盘来存储校验信息。在这种情况下，新的数据块被写入硬盘同时，奇偶校验信息被计算生成后，写入校验硬盘。 通常情况下，RAID 3组的所有的硬盘会在分条过程中合作，N个硬盘会并行写入。但当新写入的数据较少，只需写入一个或两个硬盘时，按照RAID 3的工作原理，仍需要读所有的硬盘以便重新计算新的奇偶校验值。这种少量写入数据的场景，因为需要额外的读和写操作，相对于对单个硬盘进行数据写入，并没有提升硬盘的性能，这种情况被称为RAID 3的“写惩罚”。  </li><li>RAID 3的写入性能取决于更改数据的数量、硬盘的数目、以及计算和存储奇偶校验信息所需的时间。假定一个RAID 3的硬盘数为N，当所有成员盘的转速相同时，在不考虑写惩罚，满分条写的情况下，RAID 3的顺序IO写性能理论上略小于 N-1倍单个硬盘的性能（计算冗余校验需要额外的计算时间）。</li></ul> 
<p><strong>数据读取</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/7b/37/b3mPDCuz_o.png" width="340"></p> 
<p style="text-indent:33px;">在RAID 3中，数据以分条的方式进行读取。RAID中的每个硬盘的硬盘驱动器被控制，所以RAID 3里同一条带上的数据块可以并行读取。所以，RAID 3的每一个硬盘被充分利用，提升了读取性能。 RAID 3使用并行数据读（写）模式。 RAID 3的读取性能取决于读取的数据量和RAID 3阵列的硬盘数量。</p> 
<h3 id="4.4%20RAID%205">4.4 RAID 5</h3> 
<h4 id="RAID%205%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RAID 5工作原理</h4> 
<p style="text-indent:33px;">RAID 5是改进版的RAID 3，使用条带化并计算奇偶校验信息。在RAID 3中有一块专用硬盘负责奇偶校验数据的写入和读取，这导致了我们前面提到的性能瓶颈问题。RAID 5使用的是分布式奇偶校验，每个成员硬盘将用于存储用户数据和奇偶校验数据。所以RAID 5没有瓶颈或热点。</p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/95/8f/LiHhCRPr_o.png" width="335"></p> 
<p style="text-indent:33px;">假定一个RAID 5的硬盘数为N，其中有效用户数据存储容量为N-1个硬盘的容量。与其他RAID一样，RAID 5阵列中的成员盘的容量和转速应该是相同的。 在RAID 3级别和RAID 5级别的硬盘阵列中，如果一个硬盘失效，该硬盘组将从在线（正常）状态转变为降级状态，直到完成重构失效硬盘。如果RAID中的另一个硬盘也出现故障，则硬盘组的数据将丢失</p> 
<h4 id="RAID%205%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96">RAID 5数据的存取</h4> 
<p><strong>写入数据</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/a5/1a/a32obyqz_o.png" width="294"></p> 
<ul><li>在RAID 5中，数据以分条的形式写入硬盘组中。硬盘组中的每个硬盘都存储数据块和校验信息，数据块写一个分条时，奇偶信息被写入相应的校验硬盘。在RAID 5进行连续写入的时候，不同分条用来存储奇偶校验的硬盘是不同的。因此RAID 5的不同分条的奇偶校验数据不是单独存在一个固定的校验盘里的，而是按一定规律分散存放的。<strong><span style="color:#f33b45;"> </span></strong></li><li><span style="color:#f33b45;">RAID 3在少量的数据被写入时有写惩罚，RAID 5类似。</span> RAID 5的写入性能取决于所写的数据量和RAID 5组中硬盘的数量。假定一个RAID 5的硬盘数为N，当所有成员盘的转速相同时，在不考虑写惩罚，满分条写的情况下，RAID 5的顺序IO写性能理论上略小于 N-1倍单个硬盘的性能（计算冗余校验需要额外的计算时间）。 </li></ul> 
<p><strong>数据读取</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/9c/7a/EJAof30L_o.png" width="267"></p> 
<ul><li>RAID 5组的数据以分条的形式存储在硬盘上。只需N-1个硬盘的数据就可以恢复全部数据。</li><li>RAID 5组的读取性能取决于所写的数据量和RAID组中的硬盘数量。</li></ul> 
<h3 id="4.5%20RAID%206">4.5 RAID 6</h3> 
<p style="text-indent:33px;">前面讨论到的RAID组数据保护都是考虑单一硬盘失效的场景（RAID 0排除在外）。现在，硬盘的容量已经增加了很多，同时重构时间也增加了。很多大容量的硬盘组合起来形成的一个RAID 5组重建失效硬盘可能需要几天，而不是几个小时。在重建过程中，系统处于降级状态，这种情况下，任何额外的硬盘故障都会导致硬盘组失效和数据丢失。</p> 
<p style="text-indent:33px;">这就是为什么一些组织或单位需要一个双冗余系统。换句话说：一个RAID组应该允许2个硬盘故障时，同时所有的数据应该是可访问的。这种双重冗余数据保护类型的实现有一些不同的方式：</p> 
<ul><li>第一种是多重镜像。多重镜像是指数据块存储在主盘时同步存储多个多个副本到多余硬盘的方法。这种方式意味着大量的开销。</li><li>第二种方式是RAID 6级别硬盘阵列。RAID 6组对2个硬盘失效提供保护。这些硬盘甚至可以在同一时间失效。</li></ul> 
<p style="text-indent:33px;"><span style="color:#f33b45;"><strong>RAID 6的正式名称是分布式双校验RAID</strong></span>。本质上它是一种改进的RAID 5，也具有条带化和分布式奇偶校验。现在在RAID 6有双校验，这意味着两点： 写入用户数据时，附加的双校验计算需要进行。所以，在所有RAID 类型中，RAID 6是 “最慢”的。 额外的校验信息需要占用两个盘的存储空间。这就是为什么我们把RAID 6看作是一个N+2类型的RAID。</p> 
<p style="text-indent:33px;">具有两种校验算法的RAID类型；需要至少N+2个硬盘来构成阵列，一般用在数据可用性、可靠性极高的场合。</p> 
<blockquote> 
 <p>目前，RAID 6没有一个统一的标准。不同公司以不同的方式实施RAID 6。以下2个是主要的实现方式：</p> 
 <ul><li>RAID P + Q：华为，HDS</li><li>RAID DP：NetApp</li></ul> 
 <p>这2种模式获得校验数据的方法不同。然而，在RAID组有2块硬盘故障的情况下，他们可以确保数据的完整性，并支持数据访问。</p> 
</blockquote> 
<h4 id="RAID%206%20P%2BQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RAID 6 P+Q的工作原理</h4> 
<p style="text-indent:33px;">RAID6 P＋Q需要计算出两个校验数据P和Q，当有两个数据丢失时，根据P和Q恢复出丢失的数据。校验数据P和Q是由以下公式计算得来的：</p> 
<ul><li>P = D0 ⊕ D1 ⊕ D2…</li><li>Q = (α ⊕ D0) ⊕ (β ⊕ D1) ⊕ (γ ⊕ D2)…</li></ul> 
<p style="text-align:center;"><img alt="" height="200" src="https://images2.imgbox.com/0a/49/xhyAaamJ_o.png" width="693"></p> 
<p style="text-indent:33px;">RAID 6采用P+Q校验时，P和Q是2个彼此独立的校验值。它们使用不同的算法，用户数据和校验数据分布在同一分条的所有硬盘上。</p> 
<p style="text-indent:33px;">P是用户数据块的简单的异或运算得到的。Q是对用户数据进行GF（GF =伽罗瓦域）变换再异或运算得到，α，β和γ为常量系统，由此产生的值是一个所谓的“芦苇码”。该算法将数据硬盘相同分条的所有数据进行转换和异或运算。</p> 
<p style="text-indent:33px;">如图所示，P1是通过对D0，D1，D2所在的分条0进行异或操作获得的，P2是对D3，D4，D5所在的分条1异或操作实现的。 Q1是对D0，D1，D2 所在的分条0条进行GF变换再异或操作实现的，Q2是对D3，D4，D5 所在的分条1进行GF变换再异或运算。</p> 
<p style="text-indent:33px;">如果一个硬盘中的一个分条失效，只需有P校验值即可恢复失效硬盘上的数据，异或运算在P校验值和其它数据硬盘间执行。如果同一个分条有2个硬盘同时故障，不同的场景有不同的处理方法。如果Q校验值不在失效的一个硬盘上，数据可以被恢复到数据盘上，然后重新计算校验信息。如果Q在其中一个失效的硬盘上，两个的公式都需要使用才能恢复两个失效硬盘上的数据。</p> 
<h4 id="RAID%206%20DP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RAID 6 DP工作原理</h4> 
<p style="text-indent:33px;">DP - Double Parity，就是在RAID 4所使用的一个行XOR校验硬盘的基础上又增加了一个硬盘用于存放斜向的XOR校验信息 具体实现过程如下：</p> 
<ul><li>横向校验盘中P0 - P3为各个数据盘中横向数据的校验信息，例：P0=D0  XOR D1 XOR D2 XOR D3</li><li>斜向校验盘中DP0 - DP3为各个数据盘及横向校验盘的斜向数据校验信息，例：DP0=D0 XOR D5 XOR D10 XOR D15</li></ul> 
<p style="text-align:center;"><img alt="" height="200" src="https://images2.imgbox.com/c0/14/FGNY8Yyg_o.png" width="782"></p> 
<p style="text-indent:33px;">RAID 6 DP也有两个独立的校验数据块。第一个校验信息与RAID 6 P+Q的第一个校验值是相同的，第二个不同于RAID 6 P+Q，采用的是斜向异或运算得到行对角奇偶校验数据块。</p> 
<p style="text-indent:33px;">行奇偶校验值是同一分条的用户数据异或运算获得到，所图所示：P0是由分条0上的D0，D1，D2和D3异或运算得到，P1由分条1上的D4，D5，D6，D7异或运算，等等。所以，P0 = D0 ⊕D1⊕ D2⊕D3，P1 = D4⊕D5⊕D6⊕D7，如此类推。 第二个校验数据块是由阵列的对角线数据块进行异或运算。数据块的选择过程比较复杂。DP0是由硬盘1 的分条0上的D0，硬盘2的分条1上的D5，硬盘3上的分条2的D10，和硬盘上4 分条3上的D15异或操作得到。DP1是对硬盘2 的分条0上的D1，硬盘3的分条1上的D6，硬盘4上分条2的 D11，和的第一块校验硬盘上分条3 上的P3进行异或运算得到，如此类推。</p> 
<h4 id="%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">数据恢复</h4> 
<p style="text-indent:33px;">一个RAID 6阵列能够容忍双硬盘失效。如上图所示，如果硬盘1和2失效，上面的所有数据会丢失，但其他硬盘上的数据和奇偶校验信息是有效的，我们了解一下阵列数据是如何恢复的。恢复D12采用DP2和斜向校验（D12 = D2⊕D7⊕P2⊕DP2）；恢复D13利用P3和横向校验（D13 = D12⊕D14⊕D15⊕P3），通过使用DP3和斜向校验恢复D8（D8 = D3⊕P1⊕DP3⊕D13），使用P2和横向校验得到D9（D9 = D8⊕D10⊕D11⊕P2），恢复D4采用DP4和斜向校验，利用P1和横向校验得到D5等。这些操作是重复的，直到所有数据在故障盘被恢复。</p> 
<p style="text-indent:33px;">一个RAID 6组的性能，无论算法是DP还是P+Q，相对都比较慢。因此，RAID 6适用两种场景： 数据非常重要，需要尽可能长的时间处于在线和可使用的状态。 使用的硬盘容量非常大（通常超过2T）。大容量硬盘的重建时间较长，两个硬盘都失效是会造成数据较长时间不能访问。在RAID 6中，可以实现一个硬盘重构时另一个硬盘失效。一些企业希望在使用大容量硬盘后，存储阵列的供应商使用一个双重保护的RAID组。</p> 
<h3 id="4.6%20%E6%B7%B7%E5%90%88RAID">4.6 混合RAID</h3> 
<h4 id="RAID%2010">RAID 10</h4> 
<p style="text-indent:33px;">RAID 10是将镜像和条带进行组合的RAID级别，先进行RAID 1镜像然后再做RAID  0。RAID 10也是一种应用比较广泛的RAID级别。</p> 
<p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/54/b3/W0d7s4RW_o.png" width="430"></p> 
<p style="text-indent:33px;">对于大多数的企业客户而言，RAID 0并不是一个真正可以操作的选择，而RAID 1受限于硬盘容量利用率。RAID 10组合了RAID 1和RAID 0，提供了最好的解决方案，特别是在随机写入时，由于不存在写惩罚，性能优势比较明显。 RAID 10组的硬盘数量总是偶数。一半硬盘进行用户数据写入，另一半保存用户数据的镜像副本。镜像基于分条执行。</p> 
<p style="text-indent:33px;">在图中，物理硬盘1和2构成一个RAID 1，物理硬盘3和物理硬盘4形成另一个RAID 1。这2个RAID 1子组再形成RAID 0。 RAID 10组写入数据时，子组间采用并行的方式写入数据块，子组内数据采用镜像的方式写入。如图所示，D0将写入物理硬盘1，副本将被写入物理硬盘2。</p> 
<p style="text-indent:33px;">当硬盘在不同的RAID 1组故障（例如硬盘2和4），RAID 10组的数据访问不受影响。这是因为其他2个硬盘（3和1）上有故障盘2和4上数据的完整副本。但是，如果同一RAID 1子组的硬盘（例如，硬盘1和2）在同一时间失败，数据将不能访问。</p> 
<p style="text-indent:33px;">从理论上讲，RAID 10可以忍受总数一半的物理硬盘失效，然而，从最坏的情况来看，在同一个子组的两个硬盘故障时，RAID 10也可能出现数据丢失。通常RAID 10用来保护单一的硬盘失效。 </p> 
<h4 id="RAID%2050">RAID 50</h4> 
<p style="text-indent:33px;">RAID 50是将RAID 5和RAID 0进行两级组合的RAID级别，第一级是 RAID 5，第二级为RAID 0。</p> 
<p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/f5/05/0GDgisLM_o.png" width="532"></p> 
<p style="text-indent:33px;">RAID 50是RAID 0和RAID 5的组合。两个子组被配置成RAID 5，这两个子组再形成RAID 0。每个RAID 5子组完全独立于对方。RAID 50需要至少六个硬盘,因为一个RAID 5组最少需要三个硬盘。</p> 
<p style="text-indent:33px;">所图所示，物理硬盘1，2，和3形成一个RAID 5，物理硬盘4，5，和6形成另一组RAID 5组。两个RAID 5子组间再构成一个RAID 0。 在RAID 50中，RAID可以同时接受多个硬盘的并发故障。然而，一旦两块硬盘在同一RAID5组同时失败，RAID 50的数据将丢失。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5aace0c4e732597693e030f01d2b0b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux云计算架构-SELinux安全子系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a1f768c023c006022eda0f07fe3a4ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DHCP简介与部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>