<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker镜像的创建与dockerfile - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker镜像的创建与dockerfile" />
<meta property="og:description" content="文章目录 一、docker镜像的创建1、创建镜像的方法2、基于现有镜像创建3、基于本地模板创建4、基于dockerfile创建 二、Dockerfile1、概述2、Dockerfile结构3、Dockerfile镜像结构的分层4、Dockerfile操作常用的指令5、在编写Dockerfile时，要遵循的格式 三、Dockerfile案例1、构建apache容器服务2、构建SSH镜像3、构建systemctl镜像 一、docker镜像的创建 1、创建镜像的方法 创建镜像有三种方法，分别为基于已有镜像创建、基于本地模板创建以及基于Dockerfile创建。
2、基于现有镜像创建 （1）启动一个镜像，在容器里修改
docker run -it --name jc1 centos:7 bash #先创建一个容器 yum install -y net-tools #安装网络工具，能用ifconfig （2）将容器里面运行的程序及运行环境打包生成新的镜像
格式：docker commit [选项] 容器id/容器名 仓库名:标签 docker commit -m &#34;new image for ifconfig&#34; -a &#34;jc&#34; e48a70d96722 centos:ifconfig -m:说明信息 -a:作者信息 -p:生成过程中停止容器的运行 docker images 或docker inspect 新镜像名 #查看镜像信息 （3）测试新镜像
docker run -it --name jc2 centos:ifconfig bash #用新镜像创建容器 ifconfig #直接能使用ifconfig命令看网卡信息，不用再先yum安装net-tools 3、基于本地模板创建 （1）使用wget命令导入镜像包
通过导入操作系统模板文件生成新的镜像 wget http://download.openvz.org/template/precreated/debian-7.0-x86-minimal.tar.gz （2）导入镜像
cat debian-7.0-x86-minimal.tar.gz | docker import - debian:jc docker images （3）把镜像导入到容器中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b6b4dd341c937302ab0103e5ded5d662/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-17T10:05:42+08:00" />
<meta property="article:modified_time" content="2022-01-17T10:05:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker镜像的创建与dockerfile</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#docker_1" rel="nofollow">一、docker镜像的创建</a></li><li><ul><li><a href="#1_3" rel="nofollow">1、创建镜像的方法</a></li><li><a href="#2_7" rel="nofollow">2、基于现有镜像创建</a></li><li><a href="#3_46" rel="nofollow">3、基于本地模板创建</a></li><li><a href="#4dockerfile_77" rel="nofollow">4、基于dockerfile创建</a></li></ul> 
  </li><li><a href="#Dockerfile_98" rel="nofollow">二、Dockerfile</a></li><li><ul><li><a href="#1_100" rel="nofollow">1、概述</a></li><li><a href="#2Dockerfile_107" rel="nofollow">2、Dockerfile结构</a></li><li><a href="#3Dockerfile_111" rel="nofollow">3、Dockerfile镜像结构的分层</a></li><li><a href="#4Dockerfile_124" rel="nofollow">4、Dockerfile操作常用的指令</a></li><li><a href="#5Dockerfile_198" rel="nofollow">5、在编写Dockerfile时，要遵循的格式</a></li></ul> 
  </li><li><a href="#Dockerfile_207" rel="nofollow">三、Dockerfile案例</a></li><li><ul><li><a href="#1apache_211" rel="nofollow">1、构建apache容器服务</a></li><li><a href="#2SSH_275" rel="nofollow">2、构建SSH镜像</a></li><li><a href="#3systemctl_311" rel="nofollow">3、构建systemctl镜像</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="docker_1"></a>一、docker镜像的创建</h2> 
<h3><a id="1_3"></a>1、创建镜像的方法</h3> 
<p>创建镜像有三种方法，分别为基于已有镜像创建、基于本地模板创建以及基于Dockerfile创建。</p> 
<h3><a id="2_7"></a>2、基于现有镜像创建</h3> 
<p>（1）启动一个镜像，在容器里修改</p> 
<pre><code>docker run -it --name jc1 centos:7 bash #先创建一个容器
yum install -y net-tools #安装网络工具，能用ifconfig
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/53/0R4tSH2I_o.png" alt="img"></p> 
<p>（2）将容器里面运行的程序及运行环境打包生成新的镜像</p> 
<pre><code>格式：docker commit [选项] 容器id/容器名 仓库名:标签
 
docker commit -m "new image for ifconfig" -a "jc" e48a70d96722 centos:ifconfig
 
-m:说明信息
-a:作者信息
-p:生成过程中停止容器的运行
 
docker images
或docker inspect 新镜像名    #查看镜像信息
</code></pre> 
<p><img src="https://images2.imgbox.com/48/fe/8l7SFwya_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/88/f9/D858kyK2_o.png" alt="img"></p> 
<p>（3）测试新镜像</p> 
<pre><code>docker run -it --name jc2 centos:ifconfig bash  #用新镜像创建容器
ifconfig       #直接能使用ifconfig命令看网卡信息，不用再先yum安装net-tools
</code></pre> 
<p><img src="https://images2.imgbox.com/44/63/N7MB3JCb_o.png" alt="img"></p> 
<h3><a id="3_46"></a>3、基于本地模板创建</h3> 
<p>（1）使用wget命令导入镜像包</p> 
<pre><code>通过导入操作系统模板文件生成新的镜像
wget http://download.openvz.org/template/precreated/debian-7.0-x86-minimal.tar.gz
</code></pre> 
<p><img src="https://images2.imgbox.com/78/60/JnKDk5jY_o.png" alt="img"></p> 
<p>（2）导入镜像</p> 
<pre><code>cat debian-7.0-x86-minimal.tar.gz | docker import - debian:jc
docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/95/wNxuegrQ_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/24/e4/hkU0IfZs_o.png" alt="img"></p> 
<p>（3）把镜像导入到容器中</p> 
<pre><code>docker run -it --name jc2 debian:jc bash
ls
</code></pre> 
<p><img src="https://images2.imgbox.com/43/9b/4JtdrskK_o.png" alt="img"></p> 
<h3><a id="4dockerfile_77"></a>4、基于dockerfile创建</h3> 
<p>（1）联合文件系统(UnionFS)</p> 
<p>• UnionFS(联合文件系统）:Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。AUES、OverlayES及Devicemapper都是一种UnionFS<br> • Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像<br> • 特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加教会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录<br> • 我们下载的时候看到的一层层的就是联合文件系统</p> 
<p>（2）镜像加载原理（bootfs、rootfs）</p> 
<p>• Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionES<br> • bootfs主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统<br> • 在Docker镜像的最底层是bootfs，这一层与我们典型的Linux./tTnix系统是一样的，包含boot加载器和内核。当iboot加u载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs<br> • rootfs，在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu, centos等等<br> • 我们可以理解成一开始内核里什么都没有，操作一个命令下载debian，这时就会在内核上面加了一层基础镜像;再安装一个emacs，会在基础镜像上叠加一层image;接着再安装一个apache，又会在images上面再叠加一层image。最后它们看起来就像一个文件系统即容器的rootfs。在Docker的体系里把这些rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs</p> 
<p>（3）为什么Docker里的centos的大小才200M?</p> 
<p>因为对于精简的OS，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p> 
<h2><a id="Dockerfile_98"></a>二、Dockerfile</h2> 
<h3><a id="1_100"></a>1、概述</h3> 
<p>• Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如核名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变<br> • 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是Dockerfile<br> • Dockerfile是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了pockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦<br> • 除了手动生成Docker镜像之外，可以使用nockerfile自动生成镜像。Dockerfile是由多条的指令组成的文件，其中每条指令对应Linux中的一条命令，Docker程序将读取Dockerfile中的指令生成指定镜像</p> 
<h3><a id="2Dockerfile_107"></a>2、Dockerfile结构</h3> 
<p>Dockerfile结构大致分为四个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。Dockerfile每天支持一条指令，每条指令可携带多个参数，支持使用“#”号开头的注释</p> 
<h3><a id="3Dockerfile_111"></a>3、Dockerfile镜像结构的分层</h3> 
<p><img src="https://images2.imgbox.com/49/d5/oum2me6x_o.png" alt=""></p> 
<p>**镜像不是一个单一的文件，而是有多层构成。**容器其实是在镜像的最上面加了一层读写层，在运行容器里做的任何文件改动,都会写到这个读写层。<br> 如果删除了容器，也就删除了其最上面的读写层，文件改动也就丢失了。Docker使用存储驱动管理镜像每层内容及可读写层的容器层</p> 
<p>（1）Dockerfile中的每个指令都会创建一个新的镜像层<br> （2）镜像层将被缓存和复用<br> （3）当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效<br> （4）某一层的镜像缓存失效，它之后的镜像层缓存都会失效<br> （5）镜像层是不可变的，如果在某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了</p> 
<h3><a id="4Dockerfile_124"></a>4、Dockerfile操作常用的指令</h3> 
<p><strong>（1）FORM指令</strong></p> 
<p>开启一个新的镜像，必须写。</p> 
<p><strong>（2）MAINTAINER名字</strong></p> 
<p>说明新镜像的维护人信息</p> 
<p><strong>（3）RUN指令</strong></p> 
<p>在所基于的镜像上执行命令，并提交到新的镜像中</p> 
<p><strong>（4）CMD [“要运行的程序”，“参数1”，“参数2”]</strong></p> 
<p>前者是：exec形式，后者是：shell形式。指令启动容器时默认执行的命令或者脚本，Dockerfile只能由一条CMD命令，如果指定多条命令，则只能最后一条被执行。如果在docker run时指定了命令或者镜像中有ENTRYPOINT，那么CDM就会被覆盖</p> 
<p><strong>（5）ENTRYPOINT [“要运行的程序”，“参数1”，“参数2”]</strong></p> 
<p>设定容器启动时第一个运行的命令及其参数。可以通过使用命令docker run --entrypoint来覆盖镜像中的ENTRYPOINT指令的命令</p> 
<p><strong>（6）EXPOSE端口号</strong></p> 
<p>指定新镜像加载到Docker时要开启端口</p> 
<p><strong>（7）ENV 环境变量 变量值</strong></p> 
<p>设置一个环境变量的值，会被后面的RUN使用</p> 
<p><strong>（8）ADD 源文件/目录 目标文件/目录</strong></p> 
<p>将原文件复制到镜像中，源文件要与Dockerfile位于相同目录中，或者是一个URL</p> 
<p>注意事项：</p> 
<p>1）如果源路径是个文件，且目标路径是以/结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。如果目标路径不存在，则会自动创建目标路径。</p> 
<p>2）如果源路径是个文件，且目标路径是不以/结尾，则docker会把目标路径当作一个文件。如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件;如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。注意， 这种情况下，最好显示的以/结尾，以避免混淆。</p> 
<p>3）如果源路径是个目录，且目标路径不存在，则docker会自动以目标路径创建-一个目录，把源路径目录下的文件拷贝进来。如果目标路径是个已经存在的目录，则docker 会把源路径目录下的文件拷贝到该目录下。</p> 
<p>4）如果源文件是个归档文件(tar。bzip2压缩文件)，则docker会自动帮解压。</p> 
<p>URL"下载和解压特性不能一 起使用。任何压缩文件通过URL拷贝，都不会自动解压。</p> 
<p><strong>（9）COPY源文件/目录 目标文件/目录</strong></p> 
<p>只复制本地主机_上的文件/目录复制到目标地点，源文件/目录要与Dockerfile在相同的目录中</p> 
<p><strong>（10）VOLUME [“目录”]</strong></p> 
<p>在容器中创建一个挂载点</p> 
<p><strong>（11）USER用户名/UID</strong></p> 
<p>指定运行容器时的用户</p> 
<p><strong>（12）WORKDIR路径</strong></p> 
<p>为后续的 RUN、CMD、ENTRYPOINT 指定工作目录</p> 
<p><strong>（13）ONBUILD命令</strong></p> 
<p>指定所生成的镜像作为一个基础镜像时所要运行的命令。</p> 
<p>当在一个Dockerfile 文件中加上ONBUILD指令， 该指令对利用该Dockerfile构建镜像 (比如为A镜像) 不会产生实质性影响。</p> 
<p>但是当编写一个新的Dockerfile文件来基于A镜像构建一个镜像 ( 比如为B镜像)时，这时构造A镜像的Dockerfile文件中的ONBUILD指令就生效了，在构建B镜像的过程中，首先会执行0NBUILD指令指定的指令，然后才会执行其它指令。</p> 
<p><strong>（14）HEALTHCHECK</strong></p> 
<p>健康检查</p> 
<h3><a id="5Dockerfile_198"></a>5、在编写Dockerfile时，要遵循的格式</h3> 
<p>（1）第一行必须使用FROM指令指明所基于的镜像名称<br> （2）之后使用MAINTAINER指令说明维护该镜像的用户信息<br> （3）然后是镜像操作相关指令，如RUN指令。每运行一条指令，都会给基础镜像添加新的一层<br> （4）最后使用CMD指令指定启动容器时要运行的命令操作</p> 
<h2><a id="Dockerfile_207"></a>三、Dockerfile案例</h2> 
<h3><a id="1apache_211"></a>1、构建apache容器服务</h3> 
<p>（1）建立工作目录</p> 
<pre><code>cd /opt
mkdir apache
cd apache
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/bc/wE36GVSD_o.png" alt="img"></p> 
<p>（2）编写Dockerfile</p> 
<pre><code>vim Dockerfile
 
FROM centos:7   #基于的基础镜像
MAINTAINER this is apache image（gxd）  #镜像操作指令安装apache软件
RUN yum -y install httpd   #运行命令
EXPOSE 80        #开启80瑞口
ADD index.html /var/www/html/index.html  #复制网站首页文件
CMD ["/usr/sbin/apachectl","-D","FOREGROUND"]  #在前台执行一直开启apache服务（pid=1），让容器一直处于运行中，否则命令失效则容器停止
</code></pre> 
<p><img src="https://images2.imgbox.com/60/46/aLmRMbbT_o.png" alt="img"></p> 
<p>（3）给本地网页文件添加内容</p> 
<pre><code>echo 'this is dockerfile web1' &gt; index.html   #Dockerfile中ADD指令只写了index.html代表当前的工作目录
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/99/ahl7Zrcg_o.png" alt="img"></p> 
<p>（4）生成镜像</p> 
<pre><code>docker build -t apache:jc .  #末尾有“.”代表当前目录
docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/81/a2/W3gM4HEh_o.png" alt="img"></p> 
<p>（5）新镜像运行容器</p> 
<pre><code>docker run -d -p 43999:80 apache:jc
</code></pre> 
<p><img src="https://images2.imgbox.com/75/20/fU1k210u_o.png" alt="img"></p> 
<p>（6）浏览器测试</p> 
<p><img src="https://images2.imgbox.com/c4/7a/iYQCe1HX_o.png" alt="img"></p> 
<h3><a id="2SSH_275"></a>2、构建SSH镜像</h3> 
<pre><code>1.mkdir /opt/sshd
cd /opt/sshd
 
2.vim Dockerfile
 
FROM centos:7                        #第一行必须指明基于的基础镜像
MAINTAINER this is ssh image &lt;jc&gt;   #作者信息
 
#镜像的操作指令
RUN yum -y install openssh* net-tools lsof telnet passwd
RUN echo '123456' | passwd --stdin root
RUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config                        #不使用PAM认证
RUN sed -ri '/^session\s+required\s+pam_loginuid.so/s/^/#/' /etc/pam.d/sshd        #取消pam限制
RUN ssh-keygen -t rsa -A   #生成密钥认证文件
RUN mkdir -p /root/.ssh &amp;&amp; chown root.root /root &amp;&amp; chmod 700 /root/.ssh
EXPOSE 22
CMD ["/usr/sbin/sshd" , "-D"]
 
3.生成镜像
docker build -t sshd:centos .
 
4.启动容器并修改root密码
docker run -d -P sshd:centos
docker ps -a
ssh localhost -p 49153
</code></pre> 
<p><img src="https://images2.imgbox.com/f1/41/lPVo3GEp_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a7/b6/1qu36zyv_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/04/0b/CpDRVXYM_o.png" alt="img"></p> 
<h3><a id="3systemctl_311"></a>3、构建systemctl镜像</h3> 
<pre><code>1.mkdir /opt/systemctl
cd /opt/systemctl
 
2.vim Dockerfile
 
FROM sshd:centos
MAINTAINER this is systemctl image &lt;jc&gt;
ENV container docker
#除了systemd-tmpfiles-setup.service，删除其它所有文件
RUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == systemd-tmpfiles-setup.service ] || rm -f $i; done); \   
rm -f /lib/systemd/system/multi-user.target.wants/*; \
rm -f /etc/systemd/system/*.wants/*; \
rm -f /lib/systemd/system/local-fs.target.wants/*; \
rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
rm -f /lib/systemd/system/basic.target.wants/*;\
rm -f /lib/systemd/system/anaconda.target.wants/*;
VOLUME [ "/sys/fs/cgroup" ]
CMD ["/usr/sbin/init"]
 
 
3.生成镜像
docker build -t systemctl:centos .
 
4.启动容器，并挂载宿主机目录挂载到容器中，和进行初始化
docker run --privileged -it -v -P /sys/fs/cgroup:/sys/fs/cgroup:ro systemctl:centos
#--privileged：使container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。
 
docker ps -a
 
5.进入容器
docker exec -it fed4ea999b47 bash
 
systemctl status sshd
 
方法二：
docker run -d -P --privileged sshd:centos /usr/sbin/init &amp;
前提在dockerfile中把CMD命令注释掉

</code></pre> 
<p><img src="https://images2.imgbox.com/75/a1/2zbsuN5V_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/50/a9/0pq02BX6_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/b3/bc/hOYIH44s_o.png" alt="img"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b6d5138e248e468f4a4dcffbe1f7760/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Pycharm出现的Debug无法正常运行（Frames are not available）的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab2a2c6a92d34ed49eec33cba7d31fb4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">org/apache/velocity/context/Context</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>