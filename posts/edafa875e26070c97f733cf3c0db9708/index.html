<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>比特币地址与密钥 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="比特币地址与密钥" />
<meta property="og:description" content="比特币中没有账户的概念，那么如何确定你的比特币是你比特币，或者说如何证明你是你？
这个主要应用到密码学，举个简单的例子，小王向小张转100btc，其实是把这100btc放到区块链上的，然后使用锁定脚本把这笔钱锁定到小张的地址，而小张只需要提供签名和公钥就可以使用这笔钱；同样的道理小张要花这笔钱的时候，也是将btc锁到一个新的地址，由下个人解开去花费；那么这里小张的地址，是什么呢，这次主要介绍一下比特币中的钱包，地址等概念。
公钥和私钥
在比特币中，私钥相当于密码，而公钥相当于你的账号；别人向你的公钥地址转钱，你用私钥去取钱。
私钥就是一个随机选出的数字而已。如果我们自己随便写一个，肯定安全性不够容易被破解的，毕竟和钱相关，这一步很重要的，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。
有了私钥以后，通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。反向运算困难可以简单的理解成，你知道公钥是1024，1024=k*G，那么你能才出来k是多少吗？当然这个比较简单，如果公钥K是一个非常大的数字呢？你可以在想想结果会怎么样。
比特币地址
上文说的小张的地址是什么呢，现在就要解释一下他是如果生成的。
1、添加版本的目的是为了明确需要编码的数据类型，数据类型如下：
2、添加校验码主要是为了检测转录过程中出现的错误；
3、Base58check是什么？
让我们从进制说起来，
二进制：0、1
十进制：0~9
十六进制：0~9，A~F
Base64（相当于64进制）:0~9,a~z,A~F,以及连个符号（例如，-、&#43;）
Base58：是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“&#43;”和“/”两个字符。
Base58Check：是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。
最终生成的这个地址，就是你的账号了。
密钥格式
公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。
私钥格式
不同格式之间是可以转换的。
公钥格式
公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。
公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。
公钥=04xy
引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。根据椭圆曲线公式，可以分析出，只要知道了x就可以推算出y，所以存储公钥可以省略y，这样公钥的大小就减少了256比特了。但是有一个问题是y的值有正负两种可能，对应到椭圆曲线对应y的奇数偶数，因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。
压缩私钥
将压缩格式公钥和非压缩格式公钥转化成比特币地址后，得到两个不相同地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。
由于，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。
为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。
实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。
要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/edafa875e26070c97f733cf3c0db9708/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-06T16:52:16+08:00" />
<meta property="article:modified_time" content="2024-03-06T16:52:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">比特币地址与密钥</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>    比特币中没有账户的概念，那么如何确定你的比特币是你比特币，或者说如何证明你是你？</p> 
<p>    这个主要应用到密码学，举个简单的例子，小王向小张转100btc，其实是把这100btc放到区块链上的，然后使用锁定脚本把这笔钱锁定到<strong>小张的地址</strong>，而小张只需要提供签名和公钥就可以使用这笔钱；同样的道理小张要花这笔钱的时候，也是将btc锁到一个新的地址，由下个人解开去花费；那么这里小张的地址，是什么呢，这次主要介绍一下比特币中的钱包，地址等概念。</p> 
<p></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/bd/87/g2LzhtBZ_o.png"></p> 
<p>   </p> 
<p>    公钥和私钥</p> 
<p>    在比特币中，私钥相当于密码，而公钥相当于你的账号；别人向你的公钥地址转钱，你用私钥去取钱。</p> 
<p>    私钥就是一个随机选出的数字而已。如果我们自己随便写一个，肯定安全性不够容易被破解的，毕竟和钱相关，这一步很重要的，<span style="color:#333333;">一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。</span><br>     有了私钥以后，<span style="color:#333333;">通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。</span>反向运算困难可以简单的理解成，你知道公钥是1024，1024=k*G，那么你能才出来k是多少吗？当然这个比较简单，如果公钥K是一个非常大的数字呢？你可以在想想结果会怎么样。</p> 
<p>    </p> 
<p>    比特币地址</p> 
<p>    上文说的小张的地址是什么呢，现在就要解释一下他是如果生成的。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/db/d8/BOgZLsHG_o.png"></p> 
<p></p> 
<p>1、添加版本的目的是为了明确需要编码的数据类型，数据类型如下：</p> 
<p></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/bf/e9/XqxUhvE7_o.png"></p> 
<p>2、<span style="color:#4f4f4f;">添加校验码主要是为了检测转录过程中出现的错误；</span></p> 
<p><span style="color:#4f4f4f;"><span style="color:#4f4f4f;">3、Base58check是什么？</span></span></p> 
<p><span style="color:#4f4f4f;">    让我们从进制说起来，</span></p> 
<p>    二进制：0、1</p> 
<p>    十进制：0~9</p> 
<p>    十六进制：0~9，A~F</p> 
<p>    Base64（相当于64进制）:0~9,a~z,A~F,以及连个符号（例如，-、+）</p> 
<p>    Base58：是Base64编码格式的子集，<span style="color:#333333;">同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。</span></p> 
<p>    Base58Check：<span style="color:inherit;">是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。</span></p> 
<p>最终生成的这个地址，就是你的账号了。</p> 
<p></p> 
<p>    密钥格式</p> 
<p><span style="color:#333333;">公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。</span></p> 
<p>私钥格式<img alt="" class="has" src="https://images2.imgbox.com/89/9e/ZgRZW6kn_o.png"></p> 
<p>    不同格式之间是可以转换的。</p> 
<p>公钥格式</p> 
<p>    <span style="color:#333333;">公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。</span></p> 
<p>    <span style="color:#333333;">公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。</span></p> 
<p>                                                                        公钥=04xy</p> 
<p>    <span style="color:#333333;">引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。</span>根据椭圆曲线公式，可以分析出，只要知道了x就可以推算出y，所以存储公钥可以省略y，这样公钥的大小就减少了256比特了。但是有一个问题是y的值有正负两种可能，对应到椭圆曲线对应y的奇数偶数，因此，为了区分y坐标的两种可能值，<span style="color:#333333;">我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</span></p> 
<p>    <img alt="" class="has" src="https://images2.imgbox.com/76/4c/9GcrsNdZ_o.png"></p> 
<p></p> 
<p>压缩私钥</p> 
<p>   <span style="color:#333333;">将压缩格式公钥和非压缩格式公钥转化成比特币地址后，得到两个不相同地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。</span></p> 
<p>    <span style="color:#333333;">由于，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。</span></p> 
<p>    <span style="color:#333333;">为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。</span></p> 
<p><span style="color:#333333;">    实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。<span style="color:#333333;">为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</span></span></p> 
<p>    <span style="color:#333333;">要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。</span></p> 
<p><img alt="" class="has" height="542" src="https://images2.imgbox.com/dd/82/ljrbPXgF_o.png" width="1004"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4d500c5b7a745029ee9d045ac3bd81f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">以太坊 EVM虚拟机框架分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f37a0b00b300890ad1972c71f93840cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字货币钱包 分层确定性钱包介绍（HD wallets）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>