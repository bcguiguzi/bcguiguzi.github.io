<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis分布式锁的原理与实现【分布式】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis分布式锁的原理与实现【分布式】" />
<meta property="og:description" content="文章目录 前言一、什么是分布式锁1、原理2、场景 二、redis实现分布式锁1、redis实现分布式锁原理2、Lock函数的实现3、实际使用 三、redis实现分布式锁出现的经典问题死锁问题问题锁不住与删除别人锁问题锁不住问题解决（锁过期了，业务没执行完，需要续期): 前言 一、什么是分布式锁 1、原理 分布式锁是指在分布式系统中，为了实现协调和同步访问共享资源，而对分布式环境下的多个进程或线程进行同步的一种机制。它可以保证在分布式环境下各进程访问共享资源的时序一致性和互斥性，避免不同进程之间发生冲突。
常见的分布式锁实现方式有以下几种：
基于数据库的分布式锁：使用数据库的事务机制来实现分布式锁，通过在数据库插入一个唯一的记录来实现锁定，其他进程尝试并发获取锁时会阻塞等待。
基于缓存的分布式锁：利用缓存服务器来实现锁，比如使用 Redis 的 SETNX 或者 RedLock 算法来实现分布式锁，其中 RedLock 是一种多重锁定方式，能够在不同节点之间避免竞争条件。
基于 ZooKeeper 的分布式锁：使用 ZooKeeper 集群节点来实现分布式锁，ZooKeeper 提供了顺序节点以及 watch 机制来帮助实现分布式锁的获取和释放
2、场景 举个例子来说明分布式锁的应用场景：假设某个电商网站的秒杀活动每天只有固定的5000件特价商品，多个用户同时尝试秒杀商品时会引发超卖问题，需要使用分布式锁来解决。在多个用户尝试秒杀特价商品时，他们所在的应用进程都要向 Redis 缓存服务请求获取锁，只有一个请求可以成功获取到锁并执行秒杀操作，其他请求则会被阻塞。在执行完秒杀操作后，该进程会释放锁，使得其他请求可以获取锁并继续秒杀操作，从而避免了超卖问题的发生。这种场景下，分布式锁能够保证秒杀操作的互斥性和时序一致性，保障秒杀活动的公正性。
二、redis实现分布式锁 1、redis实现分布式锁原理 由于 Redis 是单线程的，可以保证 SETNX 命令与 DEL 命令的原子性操作，因此可以通过 Redis 的 SETNX 命令实现分布式锁。在分布式系统中，要保证同一时间只有一个客户端可以访问某个共享资源，因此需要使用分布式锁来协调各个客户端的访问。Redis 分布式锁实现简单、灵活，只需要使用 SETNX 命令设置锁，并设置有效期即可，无需复杂的代码实现。redis 支持的编程语言非常多，比如 Python、Java、Go、PHP 等，这就意味着可以在不同语言的应用程序中使用同样的锁来管理共享资源，从而避免了不同编程语言之间的锁管理差异性问题。
2、Lock函数的实现 通过 Redis 的 SET 命令设置了一个锁。获取 Redis 分布式锁时采用了一个基于协程和 select 的非阻塞性等待方式
具体步骤如下：
1、获取 Redis 连接池中的一个连接 conn。
2、使用 channel ch 和超时通道 timeoutCh 进行非阻塞性等待获取锁。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ae0cc9d5c6480fd2c93a72a6a16677d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T11:39:03+08:00" />
<meta property="article:modified_time" content="2023-06-19T11:39:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis分布式锁的原理与实现【分布式】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#_9" rel="nofollow">一、什么是分布式锁</a></li><li><ul><li><a href="#1_10" rel="nofollow">1、原理</a></li><li><a href="#2_19" rel="nofollow">2、场景</a></li></ul> 
  </li><li><a href="#redis_22" rel="nofollow">二、redis实现分布式锁</a></li><li><ul><li><a href="#1redis_23" rel="nofollow">1、redis实现分布式锁原理</a></li><li><a href="#2Lock_27" rel="nofollow">2、Lock函数的实现</a></li><li><a href="#3_82" rel="nofollow">3、实际使用</a></li></ul> 
  </li><li><a href="#redis_117" rel="nofollow">三、redis实现分布式锁出现的经典问题</a></li><li><ul><li><a href="#_118" rel="nofollow">死锁问题问题</a></li><li><a href="#_121" rel="nofollow">锁不住与删除别人锁问题</a></li><li><a href="#_126" rel="nofollow">锁不住问题解决（锁过期了，业务没执行完，需要续期):</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_5"></a>前言</h2> 
<h2><a id="_9"></a>一、什么是分布式锁</h2> 
<h3><a id="1_10"></a>1、原理</h3> 
<p>分布式锁是指在分布式系统中，为了实现协调和同步访问共享资源，而对分布式环境下的多个进程或线程进行同步的一种机制。它可以保证在分布式环境下各进程访问共享资源的时序一致性和互斥性，避免不同进程之间发生冲突。<br> 常见的分布式锁实现方式有以下几种：</p> 
<p><strong>基于数据库的分布式锁</strong>：使用数据库的事务机制来实现分布式锁，通过在数据库插入一个唯一的记录来实现锁定，其他进程尝试并发获取锁时会阻塞等待。</p> 
<p><strong>基于缓存的分布式锁</strong>：利用缓存服务器来实现锁，比如使用 Redis 的 SETNX 或者 RedLock 算法来实现分布式锁，其中 RedLock 是一种多重锁定方式，能够在不同节点之间避免竞争条件。</p> 
<p><strong>基于 ZooKeeper 的分布式锁</strong>：使用 ZooKeeper 集群节点来实现分布式锁，ZooKeeper 提供了顺序节点以及 watch 机制来帮助实现分布式锁的获取和释放</p> 
<h3><a id="2_19"></a>2、场景</h3> 
<p><strong>举个例子</strong>来说明分布式锁的应用场景：假设某个电商网站的秒杀活动每天只有固定的5000件特价商品，多个用户同时尝试秒杀商品时会引发超卖问题，需要使用分布式锁来解决。在多个用户尝试秒杀特价商品时，他们所在的应用进程都要向 Redis 缓存服务请求获取锁，只有一个请求可以成功获取到锁并执行秒杀操作，其他请求则会被阻塞。在执行完秒杀操作后，该进程会释放锁，使得其他请求可以获取锁并继续秒杀操作，从而避免了超卖问题的发生。这种场景下，分布式锁能够保证秒杀操作的互斥性和时序一致性，保障秒杀活动的公正性。</p> 
<h2><a id="redis_22"></a>二、redis实现分布式锁</h2> 
<h3><a id="1redis_23"></a>1、redis实现分布式锁原理</h3> 
<p><strong>由于 Redis 是单线程的</strong>，可以保证 <strong>SETNX</strong> 命令与 <strong>DEL</strong> 命令的原子性操作，因此可以通过 Redis 的 SETNX 命令实现分布式锁。在分布式系统中，要保证同一时间只有一个客户端可以访问某个共享资源，因此需要使用分布式锁来协调各个客户端的访问。Redis 分布式锁实现简单、灵活，只需要使用 SETNX 命令设置锁，并设置有效期即可，无需复杂的代码实现。redis 支持的编程语言非常多，比如 Python、Java、Go、PHP 等，这就意味着可以在不同语言的应用程序中使用同样的锁来管理共享资源，从而避免了不同编程语言之间的锁管理差异性问题。</p> 
<h3><a id="2Lock_27"></a>2、Lock函数的实现</h3> 
<p><strong>通过 Redis 的 SET 命令设置了一个锁。获取 Redis 分布式锁时采用了一个基于协程和 select 的非阻塞性等待方式</strong><br> 具体步骤如下：<br> 1、获取 Redis 连接池中的一个连接 conn。<br> 2、使用 channel ch 和超时通道 timeoutCh 进行非阻塞性等待获取锁。<br> 3、将要获取锁的操作放在一个协程中执行（即 go func(){}()），用于不断地轮询 Redis，尝试获取锁。<br> 4、通过 select 监听 ch 和 timeoutCh 两个 channel 上的数据。<br> 5、如果 ch 上有数据（即成功获取到锁），则返回 true。<br> 6、如果 timeoutCh 上有数据（即超时），则记录日志并返回 false。<br> 在上面获取锁的步骤中：<br> SET 命令用于设置 Redis 键值对。lockKey 是锁的键名，前缀"lock:"是为了与其他键进行区分。<br> “1” 是锁的值，可以是任意值，只要保证不与其他进程的值冲突即可。<br> “NX” 表示只在键不存在时才执行设置操作。<br> <strong>“EX 10” 表示设置键的过期时间为10秒，这样即使持有锁的进程崩溃或异常退出，其它进程也能够及时再次获取锁。</strong><br> 该函数采用了 Redis 的 SET 命令中的 NX（Not eXists）选项，只有当键不存在时才执行设置操作。这样保证了多个进程之间只有一个能够成功地获取到这个锁，即“抢到锁的进程会关闭 锁通道并停止运行，因为已经获得了锁。其余等待的进程会在锁超时或者释放锁的时候后继续执行，并再次尝试获取锁。</p> 
<pre><code class="prism language-go"><span class="token comment">// 加锁封装函数</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>UserModel<span class="token punctuation">)</span> <span class="token function">lock</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{<!-- --></span>
    conn <span class="token operator">:=</span> m<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 设置管道和超时通道</span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    timeoutCh <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>

    <span class="token comment">// SET key value [EX seconds] [PX milliseconds] [NX|XX]</span>
    <span class="token comment">// NX - 只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</span>
    <span class="token comment">// PX - 毫秒为单位设置 key 的过期时间。 SET key value PX 1000 等效于 PSETEX key 1000 value</span>
    <span class="token comment">// EX - 秒为单位设置 key 的过期时间。等效于 SET key value EX seconds 的效果。</span>
    lockKey <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"lock:%s"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取锁</span>
            res<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token string">"SET"</span><span class="token punctuation">,</span> lockKey<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"NX"</span><span class="token punctuation">,</span> <span class="token string">"EX"</span><span class="token punctuation">,</span> <span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">==</span> <span class="token string">"OK"</span> <span class="token punctuation">{<!-- --></span>
                ch <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 用 select 监听两个通道，任意一个有数据就返回</span>
    <span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>timeoutCh<span class="token punctuation">:</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Failed to acquire lock after "</span><span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_82"></a>3、实际使用</h3> 
<p>首先要连接线程池</p> 
<pre><code class="prism language-go">	pool <span class="token operator">:=</span> <span class="token operator">&amp;</span>redis<span class="token punctuation">.</span>Pool<span class="token punctuation">{<!-- --></span>
		Dial<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"localhost:6379"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>成功获取到了锁之后，defer 关键字后的语句会在函数执行完毕后自动调用，此处实现了在解锁时删除锁键，即通过 DEL 命令删除锁键值对。然后进行数据库的操作。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>FriendModel<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>userid <span class="token builtin">uint32</span><span class="token punctuation">,</span> friendid <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 组装 SQL 语句</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token string">"FriendInsert"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"failed to acquire lock"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        m<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">,</span> <span class="token string">"lock:FriendInsert"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 组装 SQL 语句</span>
    sql <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"INSERT INTO friend VALUES('%d', '%d')"</span><span class="token punctuation">,</span> userid<span class="token punctuation">,</span> friendid<span class="token punctuation">)</span>
    <span class="token comment">// 执行 SQL 语句</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>Db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span>
    
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="redis_117"></a>三、redis实现分布式锁出现的经典问题</h2> 
<h3><a id="_118"></a>死锁问题问题</h3> 
<pre><code>如果获取锁的进程在持有锁期间出现了宕机等异常情况，那么可能会导致锁一直不能被释放，这样会导致其他进程无法获取到锁，相当于锁失效了。为了避免这种情况的发生，需要对锁设置超时时间，一旦超时时间到了，锁会自动释放。加锁逻辑与设置过期时间要是原子操作，一起操作的。
</code></pre> 
<h3><a id="_121"></a>锁不住与删除别人锁问题</h3> 
<pre><code>A线程获得锁之后卡了30秒，导致已释放锁了，导致锁不住，B线程拿到锁之后，原来的A线程接着执行，删除掉了线程B的锁，导致删除别人锁问题

 **删除别人的锁问题解决：**可以将锁的 value 设置为一个唯一的标识，例如是一个包含了 UUID 的字符串，在客户端删除锁时，首先需要检查该客户端所持有的锁是否与 Redis 中的锁一致，即锁的 value 值是否与客户端持有的一样，以确保只有占用锁的客户端可以删除其所持有的锁。     
**进一步解决问题：**如果A卡在了删除 锁的前一行，也几句是说已经判断过了取出的value是属于自己的，也就是说拿value，比对value和解锁并没有保证原子性，使用lua表达式保证原子性解决。就是传一个控制字符串给redis.
</code></pre> 
<h3><a id="_126"></a>锁不住问题解决（锁过期了，业务没执行完，需要续期):</h3> 
<pre><code>Redisson - 是一个高级的分布式协调Redis客户，redisson很好的解决了redis在分布式环境下的一些棘手问题
它的宗旨就是让使用者减少对Redis的关注，将更多精力用在处理业务逻辑上。redisson对分布式锁做了很好封装，只需调用API即可。RLock lock = redissonClient.getLock("stockLock");
 redisson在加锁成功后，会注册一个定时任务监听这个锁，每隔10秒就去查看这个锁，如果还持有锁，就对过期时间进行续期。默认过期时间30秒。这个机制也被叫做：“看门狗”
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee2b0161a2b05f39fbe58d7c24e4d799/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">xss攻击 SQL注入</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33a111ad765e89e3eddbc61719e00457/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">远程桌面的端口号是多少?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>