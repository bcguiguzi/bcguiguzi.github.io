<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二层转发原理详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二层转发原理详解" />
<meta property="og:description" content="一、什么是二层转发 二层转发就是基于MAC地址进行数据包转发。 1. 二层指的就是网络七层模型中的数据链路层 2. 数据链路层传输的数据单元叫 – 帧 以太帧格式
前两个字段分别是目的地址和源地址字段。第3个字段是2字节的类型字段，用来标识上一层是什么协议(0x800：IP协议，0x0806：ARP协议等)。第4个字段是数据字段，长度在46-1500字节之间。最后一个字段是CRC检验字段，存放4字节的帧检测序列FCS。校验范围是目的地址、源地址、类型、数据字段。
MAC帧长度最小为64字节，数据字段最小为46字节，如果不够，则自动加0填充。
3. MAC 地址 MAC地址也就是物理地址，大小为48位，6个字节，前24位是厂商代码，后24位为序号，比如H3C厂商代码为00-0f-e2。
单播地址：第一个字节最低位为0，如 00-0f-e2-00-00-06多播地址：第一个字节最低位为1，如 01-0f-e2-00-00-06广播地址：48位全为1，如ff-ff-ff-ff-ff-ff 4. 冲突域与广播域 冲突网络（冲突域）：连接在同一个到导线上的所有工作站点集合，一个节点发出的报文其余节点都能收到，从而产生冲突。广播网络（广播域）：限制以太网广播报文的范围，一个站点发送一个广播报文其余站点都可以收到。 5. 转发 基于MAC地址转发：主要是根据原MAC、目的MAC、MAC地址表进行业务转发（详细见原理）。基于VLAN转发：为了解决广播域的问题引入了VLAN机制进行隔离。 二、二层转发原理 1. 转发原理及流程 原理：基于原MAC、目的MAC、MAC地址表进行业务转发
流程：PC_A 与 PC_B通信
① PC_A 发送 ARP 请求给交换机1来尝试获取计算机B的mac地址（基于以太网的通信必须在数据帧中指定目标MAC地址才能通信）
②交换机1 收到广播帧（ARP请求）后，会将他发给除接收端口外的所有端口，也就是flooding了。
③计算机B 收到 ARP 后，回复 MAC 地址给A。
④计算机A 收到 B 的MAC地址后，写入以太帧目的MAC中，开始业务传输。
⑤交换机1 收到 PC_A 发出的以太帧后，会进行查表。如果查到，就按照MAC地址表指定的端口转发；查不到的话就进行广播转发。
附：查表流程 附：MAC地址学习流程（以下流程按照地址表中未学习到介绍，学习到的话直接转发）： ① PC_A 发送的以太帧进入交换机（假设与A连的端口是1，与B连的端口是2）
② 交换机查表，无相应信息
③ 交换机将收到 “以太帧的端口和源MAC地址” 学习到MAC转发表
④ 利用目的MAC转发，查表发现，MAC转发表中无 “目的MAC” 的对应信息
⑤ 广播，其他端口收到后丢弃，目的为以太帧中DMAC的设备接收" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/082a508adf294234e0068209010d64a5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-02T10:39:54+08:00" />
<meta property="article:modified_time" content="2022-11-02T10:39:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二层转发原理详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_2"></a>一、什么是二层转发</h2> 
<h5><a id="MAC_5"></a><strong>二层转发就是<code>基于MAC地址进行数据包转发</code>。</strong></h5> 
<h5><a id="1__7"></a>1. 二层指的就是网络七层模型中的数据链路层</h5> 
<p><img src="https://images2.imgbox.com/6f/2a/ko1LBCI7_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="2____13"></a>2. 数据链路层传输的数据单元叫 – 帧</h5> 
<p>以太帧格式</p> 
<p><img src="https://images2.imgbox.com/31/65/ZkEiYqll_o.png" alt="在这里插入图片描述"></p> 
<p>前两个字段分别是目的地址和源地址字段。第3个字段是2字节的类型字段，用来标识上一层是什么协议(0x800：IP协议，0x0806：ARP协议等)。第4个字段是数据字段，长度在46-1500字节之间。最后一个字段是CRC检验字段，存放4字节的帧检测序列FCS。校验范围是目的地址、源地址、类型、数据字段。</p> 
<p>MAC帧长度最小为64字节，数据字段最小为46字节，如果不够，则自动加0填充。</p> 
<hr> 
<h5><a id="3_MAC__24"></a>3. MAC 地址</h5> 
<p>MAC地址也就是物理地址，大小为48位，6个字节，前24位是厂商代码，后24位为序号，比如H3C厂商代码为00-0f-e2。</p> 
<ul><li>单播地址：第一个字节最低位为0，如 00-0f-e2-00-00-06</li><li>多播地址：第一个字节最低位为1，如 01-0f-e2-00-00-06</li><li>广播地址：48位全为1，如ff-ff-ff-ff-ff-ff</li></ul> 
<hr> 
<h5><a id="4__33"></a>4. 冲突域与广播域</h5> 
<ul><li>冲突网络（冲突域）：连接在同一个到导线上的所有工作站点集合，一个节点发出的报文其余节点都能收到，从而产生冲突。</li><li>广播网络（广播域）：限制以太网广播报文的范围，一个站点发送一个广播报文其余站点都可以收到。</li></ul> 
<hr> 
<h5><a id="5__40"></a>5. 转发</h5> 
<ul><li><strong>基于MAC地址转发：主要是根据原MAC、目的MAC、MAC地址表进行业务转发（详细见原理）</strong>。</li><li><strong>基于VLAN转发：为了解决广播域的问题引入了VLAN机制进行隔离</strong>。</li></ul> 
<hr> 
<h2><a id="_50"></a>二、二层转发原理</h2> 
<h3><a id="1__52"></a>1. 转发原理及流程</h3> 
<p>原理：基于原MAC、目的MAC、MAC地址表进行业务转发<br> 流程：PC_A 与 PC_B通信</p> 
<p><img src="https://images2.imgbox.com/7f/b3/8xCTAp05_o.png" alt="在这里插入图片描述"><br> ① PC_A 发送 ARP 请求给交换机1来尝试获取计算机B的mac地址（基于以太网的通信必须在数据帧中指定目标MAC地址才能通信）<br> ②交换机1 收到广播帧（ARP请求）后，会将他发给除接收端口外的所有端口，也就是flooding了。<br> ③计算机B 收到 ARP 后，回复 MAC 地址给A。<br> ④计算机A 收到 B 的MAC地址后，写入以太帧目的MAC中，开始业务传输。<br> ⑤交换机1 收到 PC_A 发出的以太帧后，会进行查表。如果查到，就按照MAC地址表指定的端口转发；查不到的话就进行广播转发。</p> 
<hr> 
<h5><a id="_65"></a><strong>附：查表流程</strong></h5> 
<p><img src="https://images2.imgbox.com/d0/85/3uu14sUX_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="MAC_69"></a>附：MAC地址学习流程（以下流程按照地址表中未学习到介绍，学习到的话直接转发）：</h5> 
<p>① PC_A 发送的以太帧进入交换机（假设与A连的端口是1，与B连的端口是2）<br> ② 交换机查表，无相应信息<br> ③ 交换机将收到 “<strong>以太帧的端口和源MAC地址</strong>” 学习到MAC转发表<br> ④ 利用目的MAC转发，查表发现，MAC转发表中无 “目的MAC” 的对应信息<br> ⑤ 广播，其他端口收到后丢弃，目的为以太帧中DMAC的设备接收</p> 
<p>注意：除非 PC_B 和 PC_A 是双向业务的交换机才会学到B的MAC地址，A-&gt;B单向不会。</p> 
<hr> 
<h5><a id="_80"></a>缺陷：</h5> 
<p><strong>当网络过大时，采用无vlan的二层转发会增加网络的负载，给设备CPU造成负担</strong>。</p> 
<p><img src="https://images2.imgbox.com/57/39/3Mny4ju7_o.png" alt="在这里插入图片描述"><br> 图中，是一个由5台二层交换机（交换机1一5）连接了大量客户机构成的网络。假设这时，计算机A 需要与 计算机B 通信。在基于以太网的通信中，必须在数据帧中指定目标MAC地址才能正常通信，因此 计算机A 必须先广播“ARP请求(ARP Request)信息”，来尝试获取 计算机B 的MAC地址。</p> 
<p>交换机1 收到广播帧(ARP请求)后，会将它转发给除接收端口外的其他所有端口，也就是Flooding了。接着，交换机2 收到广播帧后也会Flooding。交换机3、4、5也还会Flooding。最终ARP请求会被转发到同一网络中的所有客户机上。</p> 
<p>这个ARP请求原本是为了获得 计算机B 的MAC地址而发出的。可是事实上，数据帧却传遍整个网络，导致所有的计算机都收到了它。如此一来，一方面广播信息消耗了网终整体的带宽，另一方面，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。</p> 
<hr> 
<h3><a id="2VLAN_94"></a>2、VLAN转发原理及流程</h3> 
<p>说明：为了解决上面1.中提到的802.1d存在的问题，就引入了VLAN技术（Virtual Local Area Network），即虚拟局域网技术。通过 vlan 划分广播域解决802.1d的问题。</p> 
<p>特点：<br> <strong>①相同 vlan 内的主机可以任意通信。<br> ②不同 vlan 的主机在二层就可以完全隔离。</strong></p> 
<hr> 
<h5><a id="VLAN_103"></a>VLAN的基本概念</h5> 
<p>1）VLAN帧结构概述<br> 802.1Q帧格式是现在使用最广泛的VLAN协议标准，许多厂家的交换机路由器都支持IEEE 802.1Q标准。</p> 
<p>2）802.1Q标准的VLAN帧格式<br> <img src="https://images2.imgbox.com/81/5f/MTxfQ5CL_o.png" alt="在这里插入图片描述"></p> 
<p>802.1QTag的长度是4bytes，它位于以太网帧中源MAC地址和长度/类型之间。802.1QTag包含4个字段。</p> 
<p><strong>Type</strong>：长度为2bytes，表示帧类型，802.1Qtag帧中type字段取固定值0x8100，如果不支持802.1Q的设备收到802.1Q帧，则将其丢弃。<br> <strong>PRI</strong>：priority字段，长度为3bit，表示以太网帧的优先级，取值范围是0~7，数值越大，优先级越高。当交换机/路由器发生传输用色时，优先发送优先级高的数据帧。<br> <strong>CFI</strong>：Canonical FormatIndicator，长度为1bit，表示MAC地址是否是经典格式。CFI为0说明是经典格式，CFI为1表示为非经典格式。该字段用于区分以太网帧、FDDI帧和令牌环网帧，在以太网帧中，CFI取值为0。<br> <strong>VID</strong>：VLAN ID，长度为12bit，取值范围是0~4095，其中0和4095是保留值，不能给用户使用。</p> 
<p>3）以太端口TAG数据简述（端口链路类型）</p> 
<p><strong>Access</strong> 类型端口端口<strong>只能属于1个VLAN，一般用于连接计算机的端口</strong>。</p> 
<p><img src="https://images2.imgbox.com/ab/ea/Q8Hyq0Iv_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Trunk</strong> 类型的端口<strong>可以允许多个VLAN通过，可以接受和发送多个VLAN的报文，一般用于交换机之间的连接端口</strong>。</p> 
<p><img src="https://images2.imgbox.com/9e/c5/qAiF0zOx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Hybrid</strong> 类型的端口<strong>可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，可以用于交换机之间的连接也可以用于连接用户的计算机</strong>。</p> 
<p><strong>知识点</strong>：<br> ①<strong>Hybrid</strong> 和 <strong>Trunk</strong> 的异同<br> 同：Hybrid 和 Trunk 在接收数据是处理方式相同<br> 异：发送时 Hybrid 可以允许多个VLAN的报文发送时不带标签，而Trunk端口只允许缺省VLAN的报文发送时不打标签。<br> ②缺省VLAN<br> Access 端口只属于1个VLAN，所以它的缺省VLAN就是他所在的VLAN，不用设置。<br> Hybrid 端口和 Trunk 端口属于多个VLAN ID，缺省情况下， Hybrid 端口和 Trunk 端口的缺省 VLAN 为 VLAN 1。<br> ③tag list 和 untag list<br> 从两方面将，一方面如果是指报文，untag就是普通的Eth报文，普通PC机的网卡是可以识别这样的报文进行通讯；tag报文结构的变化是在源mac地址和目的mac地址后加上了4bytes的vlan信息，也就是vlan tag头，一般来说这样的报文不同PC机的网卡是不能识别的。另一方面，在报文进入端口和从端口发送出去时，还需要对报文中携带的VLAN、tag list和untag list这两个列表进行对比再进行下一步处理，而tag list和untag list就是由一个或多个VLAN值组成的列表。在设备设置二层转发是进行配置。<br> <img src="https://images2.imgbox.com/52/bd/FS1M7hOv_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="MAC__143"></a>MAC 学习方式</h5> 
<p><img src="https://images2.imgbox.com/dc/9a/oqJ279v9_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>SVL 方式的二层交换机</strong></p> 
<p><strong>SVL</strong>（Shared VLAN Learning）<strong>方式的二层交换机</strong>在学习 MAC 地址并建立 MAC 地址表的过程中并不附加VLAN ID，<strong>或者说它的 MAC 地址表是为所有 VLAN 共享使用的</strong>。它的二层转发基本流程如下：</p> 
<p>（1） 根据接收到的以太网帧的<strong>源MAC信息</strong>添加或刷新MAC地址表项；</p> 
<p>（2） 根据<strong>目的MAC信息</strong>查找MAC地址表，<strong>如果没有找到匹配项，那么在报文对应的VLAN内广播</strong>；</p> 
<p>（3） 如果找到匹配项，但是<strong>表项对应的端口并不属于报文对应的VLAN，那么丢弃该帧</strong>；</p> 
<p>（4） 如果找到匹配项，且<strong>表项对应的端口属于报文对应的VLAN，那么将报文转发到该端口</strong>，但是如果表项对应端口与收到以太网帧的端口相同，则丢弃该帧。</p> 
<p>这种类型的二层交换机转发与普通二层交换机转发基本相同，只是多了转发过程中的VLAN检查。这样的交换机可能遇到下述问题：位于不同VLAN的主机（或网络设备）具有相同的MAC地址，由于SVL交换机所有VLAN共享一个MAC表，这样对应的MAC表项中端口就会不断的变化，而且两个VLAN的报文转发也会受到影响。<br> 在实际应用中，SVL方式的二层交换机已经比较少见了。</p> 
<hr> 
<p><strong>IVL方式的二层交换机</strong></p> 
<p><strong>IVL（Independent VLAN Learning）方式的交换机</strong>在学习MAC地址并建立MAC地址表的过程中<strong>同时附加VLAN ID</strong>，<strong>同一个MAC地址可以出现在不同的VLAN中，这样的方式也可以理解为每个VLAN都有自己独立的MAC地址表</strong>。它的二层转发基本流程如下：</p> 
<p>（1） 根据接收到的以太网帧的<strong>源MAC＋VLAN-ID信息</strong>添加或刷新MAC地址表项；</p> 
<p>（2） 根据<strong>目的MAC＋VLAN-ID查找MAC地址表项</strong>，如果没有找到匹配项，那么在<strong>VLAN-ID对应的VLAN内广播</strong>；</p> 
<p>（3） 如果能够找到匹配表项，则向表项所示的对应端口转发，但是如果表项所示端口与收到以太网帧的端口相同，则丢弃该帧。</p> 
<p><strong>IVL方式的二层交换机转发流程更加清晰，VLAN之间不会互相影响，目前实际应用中的二层交换机大多采用这种方式。</strong></p> 
<hr> 
<h2><a id="_181"></a><strong>问题</strong>：</h2> 
<h3><a id="1_182"></a>1、二层交换出现环路会有什么影响？</h3> 
<p>-----对于MAC表中存在的报文，会出现MAC地址表刷表，导致业务中断；对于广播报文，会出现物理带宽被占满，最终导致业务中断。</p> 
<h3><a id="2_184"></a>2、如何避免环路？</h3> 
<p>-----第一物理链路避免，第二使用SIP等生成树协议，阻止二层交换成环。</p> 
<hr> 
<p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11207397.html" rel="nofollow">原文链接</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1eb1d9f72414711c186d925ae50f6df7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是 TypeScript？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0534f87be7b94427ad59a799a6b0a5c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">How to fix “__dirname is not defined in ES module scope“</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>