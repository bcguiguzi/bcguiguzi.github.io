<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>蓝桥杯算法基础（20）：（快速排序的其他优化）java版 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="蓝桥杯算法基础（20）：（快速排序的其他优化）java版" />
<meta property="og:description" content="三点中值法 选主元 三点中值法 左，中，右，三个位置，取中间值作为主元，与第一个元素交换 public static int partition(int[] A,int p,int r){ int pivot=A[p]; //优化，在p,r,mid之间，选一个中间作为主元 int midIndex=p&#43;((r-p)&lt;&lt;1);//中间下标 int midValueIndex=-1;//中值的下标 if(A[p]&lt;=A[midIndex]&amp;&amp;A[p]&gt;=A[r]){ midValueIndex=p; }else if(A[r]&lt;A[midIndex]&amp;&amp;A[r]&gt;=A[p]){ midValueIndex=r; }else{ midValueIndex=midIndex; } Util.swap(A,p,midValueIndex)//java中的交换方法 int pivot=A[p]; int left=p&#43;1; int right=r; while(left&lt;=right){ while(left&lt;=right&amp;&amp;A[left]&lt;=pivot)left&#43;&#43;; swap(left,right); right--; } } 绝对中值法 //绝对中值:分组，每5个一组，最后一组可能不足5个，每组都排序然后取中间值，再在所有的中间值中再次取中值 //工程中不常用 //获取绝对的中值数，o(N)的样子 public static int getMedian(int[] arr,int p,int r){ int size=r-p&#43;1;//数组长度 //每五个元素一组 int groupSize=(size%5==0)?(size/5):(size/5&#43;1);//每五个一组，最后一组小于等于五 //存储各小组的中值 int medians[]=new int[groupSize]; int indexOfMedains=0; //对每一组进行插入排序 for(int j=0;j&lt;groupSize;j&#43;&#43;){ //单独处理最后一组，因为最后一组可能不满5个元素 if(j==groupSize-1){ _3InsertionSort.sort(arr,p&#43;j*5,r);//自己定义的包和sort方法，插入排序，排序最后一组 medians[indexOfMedians&#43;&#43;]=arr[(p&#43;j*5&#43;r)/2];//最后一组的中间那个，对最后一组找中间值 }else{ _3InsertionSort." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/11345104deba6d75aff93c1266bd3efd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T17:49:56+08:00" />
<meta property="article:modified_time" content="2024-03-15T17:49:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">蓝桥杯算法基础（20）：（快速排序的其他优化）java版</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>三点中值法</h3> 
<blockquote> 
 <pre>选主元

三点中值法

左，中，右，三个位置，取中间值作为主元，与第一个元素交换
public static int partition(int[] A,int p,int r){
    int pivot=A[p];
    //优化，在p,r,mid之间，选一个中间作为主元
    int midIndex=p+((r-p)&lt;&lt;1);//中间下标
    int midValueIndex=-1;//中值的下标
    if(A[p]&lt;=A[midIndex]&amp;&amp;A[p]&gt;=A[r]){
    midValueIndex=p;
    }else if(A[r]&lt;A[midIndex]&amp;&amp;A[r]&gt;=A[p]){
    midValueIndex=r;
    }else{
    midValueIndex=midIndex;
    }

    Util.swap(A,p,midValueIndex)//java中的交换方法

    int pivot=A[p];
    int left=p+1;
    int right=r;

    while(left&lt;=right){
    while(left&lt;=right&amp;&amp;A[left]&lt;=pivot)left++;
    swap(left,right);
    right--;
    }
}
</pre> 
</blockquote> 
<h3>绝对中值法</h3> 
<blockquote> 
 <pre>//绝对中值:分组，每5个一组，最后一组可能不足5个，每组都排序然后取中间值，再在所有的中间值中再次取中值
//工程中不常用

//获取绝对的中值数，o(N)的样子
public static int getMedian(int[] arr,int p,int r){
    int size=r-p+1;//数组长度
    //每五个元素一组
    int groupSize=(size%5==0)?(size/5):(size/5+1);//每五个一组，最后一组小于等于五
   //存储各小组的中值
    int medians[]=new int[groupSize];
    int indexOfMedains=0;
    //对每一组进行插入排序
    for(int j=0;j&lt;groupSize;j++){
    //单独处理最后一组，因为最后一组可能不满5个元素
        if(j==groupSize-1){
        _3InsertionSort.sort(arr,p+j*5,r);//自己定义的包和sort方法，插入排序，排序最后一组
        medians[indexOfMedians++]=arr[(p+j*5+r)/2];//最后一组的中间那个，对最后一组找中间值

        }else{
        _3InsertionSort.sort(arr,p+j*5,p+j*5+4);//排序非最后一组的某个组
        medians[indexOfMedians++]=arr[p+j*5+2];//当数组排序后取5个元素里中间那个也就是第三个
        }
    }

    //对medians排序
    ——3InsertionSort.Sort(medians,0,medians.length-1);
    return medians[median.length/2];//排完序，在取中间值

}
</pre> 
</blockquote> 
<h3>待排序列表较短时，应插入排序</h3> 
<blockquote> 
 <pre>待排序个数小于等于8的时候，用插入排序
如果r-p+1&lt;=8,再快排中直接调取插入排序即可</pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d26fc24604ae28598d7ad309f3a7fbe8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java文件大小转换的两种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/579e90af5750c55b6c881007a3aedcbf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三、贪心算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>