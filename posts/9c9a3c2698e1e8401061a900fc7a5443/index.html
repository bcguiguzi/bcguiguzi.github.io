<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Xorg，X11，Wayland？Linux显示服务器和协议介绍 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Xorg，X11，Wayland？Linux显示服务器和协议介绍" />
<meta property="og:description" content="转自：https://www.linuxmi.com/xorg-x11-wayland-linux.html
2021年3月15日
您是否想知道X Server，Xorg，X11，Wayland以及诸如此类的东西到底是什么？Wayland vs Xorg，哪个更好？本指南就为你详细讲解。
您总是会遇到这些术语，并且知道它们与图形有关，但您可能想更深入了解它们。
Linux中的显示服务器是什么？
显示服务器是一个程序，其主要任务是协调客户端与其他操作系统，硬件以及彼此之间的输入和输出。显示服务器通过显示服务器协议与其客户端进行通信。
显示服务器是任何图形用户界面（尤其是窗口系统）中的关键组件。它是图形用户界面（GUI）的基本组件，位于图形界面和内核之间。因此，借助显示服务器，您可以将计算机与GUI一起使用。没有它，您将只能使用命令行界面。
不要将显示服务器与桌面环境混淆是非常重要的。桌面环境(Gnome、KDE、Xfce、MATE等)使用了底层的显示服务器。
比如：Ubuntu 21.04现在默认启用Wayland https://www.linuxmi.com/ubuntu-21-04-linux-5-10-lts-wayland.html
显示服务器通过显示服务器协议与其客户端进行通信。Linux中提供了三种显示服务器协议。X11和Wayland是其中两个。第三个Mir超出了本文的范围。
X Window System, X.Org, X11介绍
X Window System（通常仅称为X或X11）确实很古老。它最初起源于1984年，最终成为大多数类似UNIX的操作系统（包括Linux）的默认窗口系统。
X.Org服务器是X.Org基金会管理的X Window System显示服务器的免费开放源代码实现。它是一个通过X11协议与客户端应用程序进行交互的应用程序，用于在显示器上绘制内容并发送输入事件，例如鼠标移动，单击和击键。通常，将启动一个X服务器，它将等待客户端应用程序连接到它。Xorg基于客户端/服务器模型，因此允许客户端在另一台计算机上本地或远程运行。
在X11的设计中，应用程序和显示器不必在同一台计算机上，这一点并不明显。在开发X时，X server运行在工作站上，而用户在具有更强处理能力的远程计算机上运行应用程序是很常见的。
X11 是网络协议。它描述了如何在客户端（应用程序）和显示器（服务器）之间交换消息。这些消息通常带有原始的绘制命令，例如“绘制框”，“在此位置写这些字符”，“已单击鼠标左键”等。
但是X11已经很古老了，X server协议提供的大部分功能不再使用。X11所做的几乎所有工作都重新分配给了各个应用程序和窗口管理器。然而，所有这些旧特性仍然存在，给所有这些应用程序带来了压力，损害了性能和安全性。
下一代显示服务器Wayland
Wayland 由X.Org开发人员Kristian Hogsberg于2008年作为个人项目开始。它是一种通信协议 ，用于指定显示服务器与其客户端之间的通信。Wayland是作为一个免费的开源社区驱动的项目而开发的，目的是用现代，安全和简单的窗口系统代替X Window System（也称为X11或Xorg）。
在Wayland中，合成器是显示服务器。Compositor是一个窗口管理器，它为应用程序提供每个窗口的屏幕外缓冲区。窗口管理器将窗口缓冲区合成为代表屏幕的图像，并将结果写入显示内存。
Wayland协议允许合成器将输入事件直接发送到客户端，并让客户端将损坏事件直接发送到合成器。
与X情况一样，客户端在接收到事件时会作为响应更新用户界面（UI）。但是，在Wayland中，渲染发生在客户端中，并且客户端只是向合成器发送请求以指示已更新的区域。
Wayland与X相比的主要优势在于它是从头开始的。X的复杂性的主要原因之一是，多年来，它的作用已经改变。结果，今天，X11很大程度上充当了客户端和窗口管理器之间的“一个非常糟糕的”通信协议。
Wayland在安全性方面也很出色。使用X11，可以通过允许任何程序在后台存在并读取X11区域中打开的其他窗口所发生的事情来执行称为“键盘记录”的操作。使用Wayland，这根本不会发生，因为每个程序都是独立工作的。
总结
但是，与Wayland相比，X Window System仍具有许多优势。即使Wayland消除了Xorg的大多数设计缺陷，它也有其自身的问题。即使Wayland项目已经进行了十多年，事情还是不是100％稳定的。截至2020年，大多数用于Linux的视频游戏和图形密集型应用程序仍为X11编写。另外，许多封闭源代码的图形驱动程序，例如NVIDIA GPU的驱动程序，都尚未完全提供对Wayland的支持。
X不能持久，Wayland在许多方面都可以改善。但是到目前为止，现有的绝大多数本机应用程序都是为Xorg编写的。在移植所有这些应用程序之前，需要维护Xorg。与Xorg相比，Wayland还不是很稳定。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9c9a3c2698e1e8401061a900fc7a5443/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-02T22:31:40+08:00" />
<meta property="article:modified_time" content="2023-03-02T22:31:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Xorg，X11，Wayland？Linux显示服务器和协议介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>转自：https://www.linuxmi.com/xorg-x11-wayland-linux.html<br> 2021年3月15日</p> 
</blockquote> 
<p>您是否想知道X Server，Xorg，X11，Wayland以及诸如此类的东西到底是什么？Wayland vs Xorg，哪个更好？本指南就为你详细讲解。</p> 
<p>您总是会遇到这些术语，并且知道它们与图形有关，但您可能想更深入了解它们。</p> 
<p>Linux中的显示服务器是什么？</p> 
<p>显示服务器是一个程序，其主要任务是协调客户端与其他操作系统，硬件以及彼此之间的输入和输出。显示服务器通过显示服务器协议与其客户端进行通信。</p> 
<p>显示服务器是任何图形用户界面（尤其是窗口系统）中的关键组件。它是图形用户界面（GUI）的基本组件，位于图形界面和内核之间。因此，借助显示服务器，您可以将计算机与GUI一起使用。没有它，您将只能使用命令行界面。</p> 
<p><img src="https://images2.imgbox.com/60/37/qFc1HBoH_o.png" alt="在这里插入图片描述"></p> 
<p>不要将显示服务器与桌面环境混淆是非常重要的。桌面环境(Gnome、KDE、Xfce、MATE等)使用了底层的显示服务器。</p> 
<p>比如：Ubuntu 21.04现在默认启用Wayland https://www.linuxmi.com/ubuntu-21-04-linux-5-10-lts-wayland.html</p> 
<p>显示服务器通过显示服务器协议与其客户端进行通信。Linux中提供了三种显示服务器协议。X11和Wayland是其中两个。第三个Mir超出了本文的范围。</p> 
<p>X Window System, X.Org, X11介绍</p> 
<p>X Window System（通常仅称为X或X11）确实很古老。它最初起源于1984年，最终成为大多数类似UNIX的操作系统（包括Linux）的默认窗口系统。</p> 
<p><img src="https://images2.imgbox.com/85/c8/rGgrbpxN_o.png" alt="在这里插入图片描述"></p> 
<p>X.Org服务器是X.Org基金会管理的X Window System显示服务器的免费开放源代码实现。它是一个通过X11协议与客户端应用程序进行交互的应用程序，用于在显示器上绘制内容并发送输入事件，例如鼠标移动，单击和击键。通常，将启动一个X服务器，它将等待客户端应用程序连接到它。Xorg基于客户端/服务器模型，因此允许客户端在另一台计算机上本地或远程运行。</p> 
<p>在X11的设计中，应用程序和显示器不必在同一台计算机上，这一点并不明显。在开发X时，X server运行在工作站上，而用户在具有更强处理能力的远程计算机上运行应用程序是很常见的。</p> 
<p>X11 是网络协议。它描述了如何在客户端（应用程序）和显示器（服务器）之间交换消息。这些消息通常带有原始的绘制命令，例如“绘制框”，“在此位置写这些字符”，“已单击鼠标左键”等。</p> 
<p>但是X11已经很古老了，X server协议提供的大部分功能不再使用。X11所做的几乎所有工作都重新分配给了各个应用程序和窗口管理器。然而，所有这些旧特性仍然存在，给所有这些应用程序带来了压力，损害了性能和安全性。</p> 
<p>下一代显示服务器Wayland</p> 
<p>Wayland 由X.Org开发人员Kristian Hogsberg于2008年作为个人项目开始。它是一种通信协议 ，用于指定显示服务器与其客户端之间的通信。Wayland是作为一个免费的开源社区驱动的项目而开发的，目的是用现代，安全和简单的窗口系统代替X Window System（也称为X11或Xorg）。</p> 
<p><img src="https://images2.imgbox.com/58/90/zRsPjdp7_o.png" alt="在这里插入图片描述"></p> 
<p>在Wayland中，合成器是显示服务器。Compositor是一个窗口管理器，它为应用程序提供每个窗口的屏幕外缓冲区。窗口管理器将窗口缓冲区合成为代表屏幕的图像，并将结果写入显示内存。</p> 
<p>Wayland协议允许合成器将输入事件直接发送到客户端，并让客户端将损坏事件直接发送到合成器。</p> 
<p>与X情况一样，客户端在接收到事件时会作为响应更新用户界面（UI）。但是，在Wayland中，渲染发生在客户端中，并且客户端只是向合成器发送请求以指示已更新的区域。</p> 
<p>Wayland与X相比的主要优势在于它是从头开始的。X的复杂性的主要原因之一是，多年来，它的作用已经改变。结果，今天，X11很大程度上充当了客户端和窗口管理器之间的“一个非常糟糕的”通信协议。</p> 
<p>Wayland在安全性方面也很出色。使用X11，可以通过允许任何程序在后台存在并读取X11区域中打开的其他窗口所发生的事情来执行称为“键盘记录”的操作。使用Wayland，这根本不会发生，因为每个程序都是独立工作的。</p> 
<p>总结</p> 
<p>但是，与Wayland相比，X Window System仍具有许多优势。即使Wayland消除了Xorg的大多数设计缺陷，它也有其自身的问题。即使Wayland项目已经进行了十多年，事情还是不是100％稳定的。截至2020年，大多数用于Linux的视频游戏和图形密集型应用程序仍为X11编写。另外，许多封闭源代码的图形驱动程序，例如NVIDIA GPU的驱动程序，都尚未完全提供对Wayland的支持。</p> 
<p>X不能持久，Wayland在许多方面都可以改善。但是到目前为止，现有的绝大多数本机应用程序都是为Xorg编写的。在移植所有这些应用程序之前，需要维护Xorg。与Xorg相比，Wayland还不是很稳定。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17b57772df577e40e47df513c6349135/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Set-Cookie:SameSite=Lax 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8f7c2c57f9a95bbff517f293d81221e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Watch 在 vue 3 中使用说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>