<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Asp.net的身份验证有有三种，分别是&#34;Windows | Forms | Passport&#34;， - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Asp.net的身份验证有有三种，分别是&#34;Windows | Forms | Passport&#34;，" />
<meta property="og:description" content="Asp.net的身份验证有有三种，分别是&#34;Windows | Forms | Passport&#34;，其中又以Forms验证用的最多，也最灵活。
Forms 验证方式对基于用户的验证授权提供了很好的支持，可以通过一个登录页面验证用户的身份，将此用户的身份发回到客户端的Cookie，之后此用户再访问这个web应用就会连同这个身份Cookie一起发送到服务端。服务端上的授权设置就可以根据不同目录对不同用户的访问授权进行控制了。
问题来了，在实际是用中我们往往需要的是基于角色，或者说基于用户组的验证和授权。对一个网站来说，一般的验证授权的模式应该是这样的：根据实际需求把用户分成不同的身份，就是角色，或者说是用户组，验证过程不但要验证这个用户本身的身份，还要验证它是属于哪个角色的。而访问授权是根据角色来设置的，某些角色可以访问哪些资源，不可以访问哪些资源等等。要是基于用户来授权访问将会是个很不实际的做法，用户有很多，还可能随时的增减，不可能在配置文件中随时的为不断增加的新用户去增加访问授权的。 下面大概的看一下Forms的过程。
Forms身份验证基本原理：
一 身份验证
要采用Forms身份验证，先要在应用程序根目录中的Web.config中做相应的设置:
??&lt;authentication mode=&#34;Forms&#34;&gt;
???&lt;forms name=&#34;.ASPXAUTH&#34; loginUrl=&#34;/Default.aspx&#34; protection=&#34;All&#34; timeout=&#34;30&#34; path=&#34;/&#34; /&gt;
??&lt;/authentication&gt;
其中&lt;authentication mode= &#34;forms&#34;&gt; 表示本应用程序采用Forms验证方式。
1. &lt;forms&gt;标签中的name表示指定要用于身份验证的 HTTP Cookie。默认情况下，name 的值是 .ASPXAUTH。采用此种方式验证用户后,以此用户的信息建立一个FormsAuthenticationTicket类型的身份验证票,再加密序列化为一个字符串,最后将这个字符串写到客户端的name指定名字的Cookie中.一旦这个Cookie写到客户端后,此用户再次访问这个web应用时会将连同Cookie一起发送到服务端,服务端将会知道此用户是已经验证过的. 再看一下身份验证票都包含哪些信息呢,我们看一下FormsAuthenticationTicket类:
CookiePath： 返回发出 Cookie 的路径。注意，窗体的路径设置为 /。由于窗体区分大小写，这是为了防止站点中的 URL 的大小写不一致而采取的一种保护措施。这在刷新 Cookie 时使用
Expiration： 获取 Cookie 过期的日期/时间。
IsPersistent： 如果已发出持久的 Cookie，则返回 true。否则，身份验证 Cookie 将限制在浏览器生命周期范围内。
IssueDate： 获取最初发出 Cookie 的日期/时间。
Name： 获取与身份验证 Cookie 关联的用户名。
UserData ：获取存储在 Cookie 中的应用程序定义字符串。
Version： 返回字节版本号供将来使用。
2. &lt;forms&gt;标签中的loginUrl指定如果没有找到任何有效的身份验证 Cookie，为登录将请求重定向到的 URL。默认值为 default." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/61754f742a3de454b15e87608913fcb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2008-04-21T14:58:00+08:00" />
<meta property="article:modified_time" content="2008-04-21T14:58:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Asp.net的身份验证有有三种，分别是&#34;Windows | Forms | Passport&#34;，</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">Asp.net的身份验证有有三种，分别是"Windows | Forms | Passport"，其中又以Forms验证用的最多，也最灵活。<br>Forms 验证方式对基于用户的验证授权提供了很好的支持，可以通过一个<strong style="COLOR: white; BACKGROUND-COLOR: #880000">登录</strong>页面验证用户的身份，将此用户的身份发回到客户端的Cookie，之后此用户再访问这个web应用就会连同这个身份Cookie一起发送到服务端。服务端上的授权设置就可以根据不同目录对不同用户的访问授权进行控制了。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">问题来了，在实际是用中我们往往需要的是基于角色，或者说基于用户组的验证和授权。对一个网站来说，一般的验证授权的模式应该是这样的：根据实际需求把用户分成不同的身份，就是角色，或者说是用户组，验证过程不但要验证这个用户本身的身份，还要验证它是属于哪个角色的。而访问授权是根据角色来设置的，某些角色可以访问哪些资源，不可以访问哪些资源等等。要是基于用户来授权访问将会是个很不实际的做法，用户有很多，还可能随时的增减，不可能在配置文件中随时的为不断增加的新用户去增加访问授权的。 </font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">下面大概的看一下Forms的过程。</font></span></span></span></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">Forms身份验证基本原理：</font></span></span></span></strong></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">一 身份验证</font></span></span></span></strong></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">要采用Forms身份验证，先要在应用程序根目录中的Web.config中做相应的设置:</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">??&lt;authentication mode="Forms"&gt;<br>???&lt;forms <strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong>=".ASPXAUTH" loginUrl="/Default.aspx" protection="All" timeout="30" path="/" /&gt;<br>??&lt;/authentication&gt;</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">其中&lt;authentication mode= "forms"&gt; 表示本应用程序采用Forms验证方式。<br>1. &lt;forms&gt;标签中的<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong>表示指定要用于身份验证的 HTTP Cookie。默认情况下，<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong> 的值是 .ASPXAUTH。采用此种方式验证用户后,以此用户的信息建立一个<a name="baidusnap0"></a><strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong>类型的身份验证票,再加密序列化为一个字符串,最后将这个字符串写到客户端的<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong>指定名字的Cookie中.一旦这个Cookie写到客户端后,此用户再次访问这个web应用时会将连同Cookie一起发送到服务端,服务端将会知道此用户是已经验证过的. </font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">再看一下身份验证票都包含哪些信息呢,我们看一下<strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong>类:<br><strong>CookiePath</strong>： 返回发出 Cookie 的路径。注意，窗体的路径设置为 /。由于窗体区分大小写，这是为了防止站点中的 URL 的大小写不一致而采取的一种保护措施。这在刷新 Cookie 时使用<br><strong>Expiration</strong>： 获取 Cookie 过期的日期/时间。<br><strong>IsPersisten</strong>t： 如果<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>发出持久的 Cookie，则返回 true。否则，身份验证 Cookie 将限制在浏览器生命周期范围内。<br><strong>IssueDate</strong>： 获取最初发出 Cookie 的日期/时间。<br><strong><strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">Name</strong></strong>： 获取与身份验证 Cookie 关联的用户名。<br><strong>UserData</strong> ：获取存储在 Cookie 中的应用程序定义字符串。<br><strong>Version</strong>： 返回字节版本号供将来使用。</font></span></span></span></p> 
<p><br><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">2. &lt;forms&gt;标签中的loginUrl指定如果没有找到任何有效的身份验证 Cookie，为<strong style="COLOR: white; BACKGROUND-COLOR: #880000">登录</strong>将请求重定向到的 URL。默认值为 default.aspx。loginUrl指定的页面就是用来验证用户身份的,一般此页面提供用户输入用户名和密码,用户提交后由程序来根据自己的需要来验证用户的合法性(大多情况是将用户输入信息同数据库中的用户表进行比较),如果验证用户有效,则生成同此用户对应的身份验证票,写到客户端的Cookie,最后将浏览器重定向到用户初试请求的页面.一般是用FormsAuthentication.RedirectFromLoginPage 方法来完成生成身份验证票,写回客户端,浏览器重定向等一系列的动作.<br><br>public static void RedirectFromLoginPage( string userName, bool createPersistentCookie, string strCookiePath );<br><br>其中:<br><strong>userName</strong>： 就是此用户的标示,用来标志此用户的唯一标示,不一定要映射到用户账户名称.<br><strong>createPersistentCookie</strong>： 标示<strong style="COLOR: black; BACKGROUND-COLOR: #ff9999">是否</strong>发出持久的 Cookie。<br>若不是持久Cookie，Cookie的有效期Expiration属性有当前时间加上web.config中timeout的时间，每次请求页面时，在验证身份过程中，会<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">判断</strong><strong style="COLOR: black; BACKGROUND-COLOR: #ff9999">是否</strong>过了有效期的一半，要是的话更新一次cookie的有效期；若是持久cookie，Expiration属性无意义，这时身份验证票的有效期有cookie的Expires决定，RedirectFromLoginPage方法给Expires属性设定的是50年有效期。<br><strong>strCookiePath</strong>： 标示将生成的Cookie的写到客户端的路径，身份验证票中保存这个路径是在刷新身份验证票Cookie时使用（这也是生成Cookie的Path），若没有strCookiePath 参数，则使用web.config中 path属性的设置。<br><br>这里可以看到,此方法参数只有三个,而身份验证票的属性有七个,不足的四个参数是这么来的:<br><strong>IssueDate</strong>： Cookie发出时间由当前时间得出,<br><strong>Expiration</strong>：过期时间由当前时间和下面要说的&lt;forms&gt;标签中timeout参数算出。此参数对非持久性cookie有意义。<br><strong>UserData：</strong> 这个属性可以用应用程序写入一些用户定义的数据,此方法没有用到这个属性,只是简单的将此属性置为空字符串,请注意此属性,在后面我们将要使用到这个属性。<br><strong>Version：</strong> 版本号由系统自动提供.<br><br>RedirectFromLoginPage方法生成生成身份验证票后，会调用FormsAuthentication.Encrypt 方法，将身份验证票加密为字符串，这个字符串将会是以.ASPXAUTH为名字的一个Cookie的值。这个Cookie的其它属性的生成：Domain，Path属性为确省值，Expires视createPersistentCookie参数而定，若是持久cookie，Expires设为50年以后过期；若是非持久cookie，Expires属性不设置。<br>生成身份验证Cookie后，将此Cookie加入到Response.Cookies中，等待发送到客户端。<br>最后RedirectFromLoginPage方法调用FormsAuthentication.GetRedirectUrl 方法获取到用户原先请求的页面，重定向到这个页面。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">3. &lt;forms&gt;标签中的timeout和path,是提供了身份验证票写入到Cookie过期时间和默认路径。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">以上就是基于Forms身份验证的过程，它完成了对用户身份的确认。下面介绍基于Forms身份验证的访问授权。</font></span></span></span></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">二 访问授权</font></span></span></span></strong></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">验证了身份，是要使用这个身份，根据不同的身份我们可以进行不同的操作，处理，最常见的就是对不同的身份进行不同的授权，Forms验证就提供这样的功能。Forms授权是基于目录的，可以针对某个目录来设置访问权限，比如，这些用户可以访问这个目录，那些用户不能访问这个目录。<br>同样，授权设置是在你要控制的那个目录下的web.config文件中来设置：<br></font></span></span></span><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">&lt;authorization&gt;<br>????&lt;allow users="comma-separated list of users"<br>????????roles="comma-separated list of roles"<br>????????verbs="comma-separated list of verbs" /&gt;<br>???? &lt;deny users="comma-separated list of users"<br>????????roles="comma-separated list of roles"<br>????????verbs="comma-separated list of verbs" /&gt;<br>&lt;/authorization&gt;</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">&lt;allow&gt;标签表示允许访问，其中的属性<br>1. users：一个逗号分隔的用户名列表，这些用户名<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>被授予对资源的访问权限。问号 (?) 允许匿名用户；星号 (*) 允许所有用户。<br>2. roles：一个逗号分隔的角色列表，这些角色<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>被授予对资源的访问权限。<br>3. verbs：一个逗号分隔的 HTTP 传输方法列表，这些 HTTP 传输方法<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>被授予对资源的访问权限。注册到 ASP.NET 的谓词为 GET、HEAD、POST 和 DEBUG。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">&lt;deny&gt;标签表示不允许访问。其中的属性同上面的。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">在运行时，授权模块迭代通过 &lt;allow&gt; 和 &lt;deny&gt; 标记，直到它找到适合特定用户的第一个访问规则。然后，它根据找到的第一项访问规则是 &lt;allow&gt; 还是 &lt;deny&gt; 规则来允许或拒绝对 URL 资源的访问。Machine.config 文件中的默认身份验证规则是 &lt;allow users="*"/&gt;，因此除非另行配置，否则在默认情况下会允许访问。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">那么这些user 和roles又是如何得到的呢？下面看一下授权的详细过程：</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">1. 一旦一个用户访问这个网站，就行<strong style="COLOR: white; BACKGROUND-COLOR: #880000">登录</strong>确认了身份，身份验证票的cookie也写到了客户端。之后，这个用户再次申请这个web的页面，身份验证票的cookie就会发送到服务端。在服务端，asp.net为每一个http请求都分配一个HttpApplication对象来处理这个请求，在HttpApplication.AuthenticateRequest事件后，安全模块<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>建立用户标识，就是此用户的身份在web端已经建立起来，这个身份完全是由客户端发送回来的身份验证票的cookie建立的。<br>2. 用户身份在HttpContext.User 属性中，在页面中可以通过Page.Context 来获取同这个页面相关的HttpContext对象。对于Forms验证，HttpContext.User属性是一个GenericPrincipal类型的对象，GenericPrincipal只有一个公开的属性Identity，有个私有的m_role属性，是string[]类型，存放此用户是属于哪些role的数组，还有一个公开的方法IsInRole(string role)，来<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">判断</strong>此用户<strong style="COLOR: black; BACKGROUND-COLOR: #ff9999">是否</strong>属于某个角色。<br>由于身份验证票的cookie中根本没有提供role这个属性，就是说Forms身份验证票没有提供此用户的role信息，所以，对于Forms验证，在服务端得到的GenericPrincipal 用户对象的m_role属性永远是空的。<br>3. GenericPrincipal. Identity 属性是一个FormsIdentity类型的对象，这个对象有个<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">Name</strong>属性，就是此用户的标示，访问授权就是将此属性做为user来进行授权验证的。FormsIdentity还有一个属性，就是Ticket属性，此属性是身份验证票<strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong>类型，就是之前服务器写到客户端的身份验证票。<br>服务器在获取到身份验证票<strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong>对象后，查看这个身份验证票是不是非持久的身份验证，是的话要根据web.config中timeout属性设置的有效期来更新这个身份验证票的cookie（为避免危及性能，在经过了超过一半的指定时间后更新该 Cookie。这可能导致精确性上的损失。持久性 Cookie 不超时。）<br>4. 在HttpApplication.ResolveRequestCache事件之前，asp.net开始取得用户请求的页面，建立HttpHandler控制点。这就意味着，在HttpApplication.ResolveRequestCache事件要对用户访问权限就行验证，看此用户或角色<strong style="COLOR: black; BACKGROUND-COLOR: #ff9999">是否</strong>有权限访问这个页面，之后在这个请求的生命周期内再改变此用户的身份或角色就没有意义了。</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">以上是Forms验证的全过程，可以看出，这个Forms验证是基于用户的，没有为角色的验证提供直接支持。身份验证票<strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> 中的<strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">Name</strong>属性是用户标示，其实还有一个属性UserData，这个属性可以由应用程序来写入自定义的一些数据，我们可以利用这个字段来存放role的信息，从而达到基于角色验证的目的。</font></span></span></span></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">Forms身份验证基于角色的授权</font></span></span></span></strong></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">一 身份验证</font></span></span></span></strong></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">在web.config的&lt;authentication&gt;的设置还是一样：</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">&lt;authentication mode="forms"&gt; <br>????&lt;forms <strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong>=".ASPXAUTH " loginUrl="/login.aspx" timeout="30" path= "/"&gt;<br>????&lt;/forms&gt; <br>&lt;/authentication&gt;</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">/login.aspx验证用户合法性页面中，在验证了用户的合法性后，还要有个取得此用户属于哪些role的过程，这个看各个应用的本身如何设计的了，一般是在数据库中会有个use_role表，可以从数据库中获得此用户属于哪些role，在此不深究如何去获取用户对应的role，最后肯定能够获得的此用户对应的所有的role用逗号分割的一个字符串。<br>在上面的非基于角色的方法中，我们用了FormsAuthentication.RedirectFromLoginPage 方法来完成生成身份验证票,写回客户端,浏览器重定向等一系列的动作。这个方法会用一些确省的设置来完成一系列的动作，在基于角色的验证中我们不能用这一个方法来实现，要分步的做，以便将一些定制的设置加进来：</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">1. 首先要根据用户标示，和用户属于的角色的字符串来创建身份验证票<br>public <strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong>(<br>int version, //设为1<br>string <strong style="COLOR: black; BACKGROUND-COLOR: #a0ffff">name</strong>, //用户标示<br>DateTime issueDate, //Cookie 的发出时间, 设置为 DateTime.Now <br>DateTime expiration, //过期时间<br>bool isPersistent, //<strong style="COLOR: black; BACKGROUND-COLOR: #ff9999">是否</strong>持久性(根据需要设置,若是设置为持久性,在发出<br>cookie时,cookie的Expires设置一定要设置)<br>string userData, //这里用上面准备好的用逗号分割的role字符串<br>string cookiePath </font></span></span></span><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">// 设为"/",这要同发出cookie的路径一致,因为刷新cookie<br>要用这个路径<br>);</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier"><strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> Ticket = new <strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> (1,"kent",DateTime.Now, DateTime.Now.AddMinutes(30), false,UserRoles,"/") ;</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">2. 生成身份验证票的Cookie<br>2.1 将身份验证票加密序列化成一个字符串<br>string HashTicket = FormsAuthentication.Encrypt (Ticket) ;<br>2.2 生成cookie<br>HttpCookie UserCookie = new HttpCookie(FormsAuthentication.FormsCookieName, HashTicket) ;<br>FormsAuthentication.FormsCookieName 是用来获取web.config中设置的身份验证cookie的名字,缺省为" .ASPXAUTH".<br>若身份验证票中的isPersistent属性设置为持久类,则这个cookie的Expires属性一定要设置,这样这个cookie才会被做为持久cookie保存到客户端的cookie文件中.<br>3. 将身份验证票Cookie输出到客户端<br>通过Response.Cookies.Add(UserCookie) 将身份验证票Cookie附加到输出的cookie集合中,发送到客户端.<br>4. 重定向到用户申请的初试页面.</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">验证部分代码(这部分代码是在login.aspx页面上点击了<strong style="COLOR: white; BACKGROUND-COLOR: #880000">登录</strong>按钮事件处理代码):</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">private void Buttonlogin_Click(object sender, System.EventArgs e)<br>{<!-- --><br>???? string user = TextBoxUser.Text; //读取用户名<br>???? string password = TextBoxPassword.Text; //读取密码<br>???? if(Confirm(user,password) == true) //confirm方法用来验证用户合法性的<br>????{<!-- --><br>???????? string userRoles = UserToRole(user); //调用UserToRole方法来获取role字符串<br>???????? <strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> Ticket = new <strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> (1,user,DateTime.Now, ???????? DateTime.Now.AddMinutes(30), false,userRoles,"/") ; //建立身份验证票对象<br>???????? string HashTicket = FormsAuthentication.Encrypt (Ticket) ; //加密序列化验证票为字符串<br>???????? HttpCookie UserCookie = new HttpCookie(FormsAuthentication.FormsCookieName, HashTicket) ; <br>//生成Cookie<br>???? ???? Context.Response.Cookies.Add (UserCookie) ; //输出Cookie<br>???????? Context.Response.Redirect (Context.Request["ReturnUrl"]) ; // 重定向到用户申请的初始页面<br>???? }<br>????else<br>????{<!-- --><br>????????// 用户身份未被确认时的代码<br>????}<br>}<br>//此方法用来验证用户合法性的<br>private bool Confirm(string user,string password)<br>{<!-- --><br>????//相应的代码<br>}<br>//此方法用来获得的用户对应的所有的role用逗号分割的一个字符串<br>private string UserToRole(string user)<br>{<!-- --><br>????//相应的代码<br>}</font></span></span></span></p> 
<p><strong><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">二 基于角色访问授权</font></span></span></span></strong></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">这里我们要做的是,将客户端保存的身份验证票中UserData中保存的表示角色的信息恢复到在服务端表示用户身份的GenericPrincipal对象中(记住,原来的验证过程中, GenericPrincipal对象只包含了用户信息,没有包含role信息)<br>一个Http请求的过程中,HttpApplication.AuthenticateRequest事件表示安全模块<strong style="COLOR: black; BACKGROUND-COLOR: #ff66ff">已</strong>建立用户标识，就是此用户的身份在web端已经建立起来, 在这个事件之后我们就可以获取用户身份信息了.<br>在HttpApplication.ResolveRequestCache事件之前，asp.net开始取得用户请求的页面，建立HttpHandler控制点,这时就已经要验证用户的权限了,所以恢复用户角色的工作只能在HttpApplication.AuthenticateRequest事件和HttpApplication.ResolveRequestCache事件之间的过程中做.<br>我们选择Application_AuthorizeRequest事件中做这个工作,可以在global.asax文件中处理HttpApplication的所有的事件,代码如下:</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">protected void Application_AuthorizeRequest(object sender, System.EventArgs e)<br>{<!-- --><br>????HttpApplication App = (HttpApplication) sender;<br>???? HttpContext Ctx = App.Context ; //获取本次Http请求相关的HttpContext对象<br>????if (Ctx.Request.IsAuthenticated == true) //验证过的用户才进行role的处理<br>????{<!-- --><br>????????FormsIdentity Id = (FormsIdentity)Ctx.User.Identity ;<br>????????<strong style="COLOR: black; BACKGROUND-COLOR: #ffff66">FormsAuthenticationTicket</strong> Ticket = Id.Ticket ; //取得身份验证票<br>????????string[] Roles = Ticket.UserData.Split (',') ; //将身份验证票中的role数据转成字符串数组<br>????????Ctx.User = new GenericPrincipal (Id, Roles) ; //将原有的Identity加上角色信息新建一个GenericPrincipal表示当前用户,这样当前用户就拥有了role信息<br>????}<br>}</font></span></span></span></p> 
<p><span style="FONT-FAMILY: Courier"><span style="FONT-SIZE: 10pt"><span style="FONT-SIZE: 8pt"><font face="Courier">访问者同时具有了user和role信息,就可以据此在web.config中用role来控制用户的访问权限了.</font></span></span></span> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ba38c8f8c775f5d19fdb224d9f5b1c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何定制对话框中的回车键（转）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c1cd09db76355dd2f42a1e1135d9c00/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PhotoshopCS中的CS是什么意思？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>