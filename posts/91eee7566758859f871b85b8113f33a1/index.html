<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QThread常用相关函数、线程启动方式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QThread常用相关函数、线程启动方式" />
<meta property="og:description" content="一、常用相关函数 可以将常用的函数按照功能进行以下分类：
线程启动
void start()
调用后会执行run()函数，但在run()函数执行前会发射信号started()，操作系统将根据优先级参数调度线程。如果线程已经在运行，那么这个函数什么也不做。优先级参数的效果取决于操作系统的调度策略。
线程执行
int exec()
每一个线程可以有自己的事件循环，可以通过调用exec()函数来启动事件循环。
void run()
线程的起点，在调用start()之后，新创建的线程就会调用这个函数，默认实现调用exec()，大多数需要重新实现这个函数，便于管理自己的线程。该函数返回后，线程便执行结束，就像应用程序离开main()函数一样。
线程退出
void quit()
使线程退出事件循环，返回0表示成功，相当于调用了QThread::exit(0)。
void exit(int returnCode = 0)
使线程退出事件循环，返回0表示成功，任何非0值表示失败。
void terminate()
在极端情况下，可能想要强制终止一个正在执行的线程，这时可以使用terminate()函数。但是，线程可能会立即被终止也可能不会，这取决于操作系统的调度策略，使用terminate()之后再使用QThread::wait()，以确保万无一失。
警告：使用terminate()函数，线程可能在任何时刻被终止而无法进行一些淸理工作，因此该函数是很危险的，一般不建议使用，只有在绝对必要的时候使用。
void requestInterruption()
Qt5新引入接口，请求线程的中断，用于关闭线程。该请求是咨询意见并且取决于线程上运行的代码，来决定是否及如何执行这样的请求。此函数不停止线程上运行的任何事件循环，并且在任何情况下都不会终止它。
线程等待
void msleep(unsigned long msecs) [static]
强制当前线程睡眠msecs毫秒。
void sleep(unsigned long secs) [static]
强制当前线程睡眠secs秒。
void usleep(unsigned long usecs) [static]
强制当前线程睡眠usecs微秒。
bool wait(unsigned long time = ULONG_MAX)
线程将会被阻塞，等待time毫秒。和sleep不同的是，如果线程退出，wait会返回。
线程状态
bool isFinished() const
判断线程是否结束
bool isRunning() const
判断线程是否正在运行
bool isInterruptionRequested() const
如果线程上的任务运行应该停止，返回true；可以使用requestInterruption()请求中断。 Qt5新引入接口，用于使长时间运行的任务干净地中断。从不检查或作用于该函数返回值是安全的，但是建议在长时间运行的函数中经常这样做。注意：不要过于频繁调用，以保持较低的开销。示例程序如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/91eee7566758859f871b85b8113f33a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T16:02:38+08:00" />
<meta property="article:modified_time" content="2024-03-14T16:02:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QThread常用相关函数、线程启动方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="一qthread常用函数">一、常用相关函数</h3> 
<p>可以将常用的函数按照功能进行以下分类：</p> 
<ul><li> <p>线程启动</p> 
  <ul><li> <p>void start()</p> <p>调用后会执行run()函数，但在run()函数执行前会发射信号started()，操作系统将根据优先级参数调度线程。如果线程已经在运行，那么这个函数什么也不做。优先级参数的效果取决于操作系统的调度策略。</p> </li></ul></li><li> <p>线程执行</p> 
  <ul><li> <p>int exec()</p> <p>每一个线程可以有自己的事件循环，可以通过调用exec()函数来启动事件循环。</p> </li><li> <p>void run()</p> <p>线程的起点，在调用start()之后，新创建的线程就会调用这个函数，默认实现调用exec()，大多数需要重新实现这个函数，便于管理自己的线程。该函数返回后，线程便执行结束，就像应用程序离开main()函数一样。</p> </li></ul></li><li> <p>线程退出</p> 
  <ul><li> <p>void quit()</p> <p>使线程退出事件循环，返回0表示成功，相当于调用了QThread::exit(0)。</p> </li><li> <p>void exit(int returnCode = 0)</p> <p>使线程退出事件循环，返回0表示成功，任何非0值表示失败。</p> </li><li> <p>void terminate()</p> <p>在极端情况下，可能想要强制终止一个正在执行的线程，这时可以使用terminate()函数。但是，线程可能会立即被终止也可能不会，这取决于操作系统的调度策略，使用terminate()之后再使用QThread::wait()，以确保万无一失。</p> <p><strong>警告：</strong>使用terminate()函数，线程可能在任何时刻被终止而无法进行一些淸理工作，因此该函数是很危险的，一般不建议使用，只有在绝对必要的时候使用。</p> </li><li> <p>void requestInterruption()</p> <p>Qt5新引入接口，请求线程的中断，用于关闭线程。该请求是咨询意见并且取决于线程上运行的代码，来决定是否及如何执行这样的请求。此函数不停止线程上运行的任何事件循环，并且在任何情况下都不会终止它。</p> </li></ul></li><li> <p>线程等待</p> 
  <ul><li> <p>void msleep(unsigned long msecs) [static]</p> <p>强制当前线程睡眠msecs毫秒。</p> </li><li> <p>void sleep(unsigned long secs) [static]</p> <p>强制当前线程睡眠secs秒。</p> </li><li> <p>void usleep(unsigned long usecs) [static]</p> <p>强制当前线程睡眠usecs微秒。</p> </li><li> <p>bool wait(unsigned long time = ULONG_MAX)</p> <p>线程将会被阻塞，等待time毫秒。和sleep不同的是，如果线程退出，wait会返回。</p> </li></ul></li><li> <p>线程状态</p> 
  <ul><li> <p>bool isFinished() const</p> <p>判断线程是否结束</p> </li><li> <p>bool isRunning() const</p> <p>判断线程是否正在运行</p> </li><li> <p>bool isInterruptionRequested() const<br> 如果线程上的任务运行应该停止，返回true；可以使用requestInterruption()请求中断。 Qt5新引入接口，用于使长时间运行的任务干净地中断。从不检查或作用于该函数返回值是安全的，但是建议在长时间运行的函数中经常这样做。注意：不要过于频繁调用，以保持较低的开销。示例程序如下：</p> <pre><code>void run() 
{
	// 是否请求终止
	while (!isInterruptionRequested())
	{
		// 耗时操作
	}
}
</code></pre> </li></ul></li><li> <p>线程优先级</p> 
  <ul><li> <p>void setPriority(Priority priority)</p> <p>设置正在运行线程的优先级。如果线程没有运行，此函数不执行任何操作并立即返回。使用的start()来启动一个线程具有特定的优先级。优先级参数可以是QThread::Priority枚举除InheritPriortyd的任何值。</p> </li></ul></li></ul> 
<p>枚举QThread::Priority：</p> 
<table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>QThread::IdlePriority</td><td>0</td><td>没有其它线程运行时才调度</td></tr><tr><td>QThread::LowestPriority</td><td>1</td><td>比LowPriority调度频率低</td></tr><tr><td>QThread::LowPriority</td><td>2</td><td>比NormalPriority调度频率低</td></tr><tr><td>QThread::NormalPriority</td><td>3</td><td>操作系统的默认优先级</td></tr><tr><td>QThread::HighPriority</td><td>4</td><td>比NormalPriority调度频繁</td></tr><tr><td>QThread::HighestPriority</td><td>5</td><td>比HighPriority调度频繁</td></tr><tr><td>QThread::TimeCriticalPriority</td><td>6</td><td>尽可能频繁的调度</td></tr><tr><td>QThread::InheritPriority</td><td>7</td><td>使用和创建线程同样的优先级. 这是默认值</td></tr></tbody></table> 
<p><a name="_label1"></a></p> 
<h3 id="二子类化qthread方式启动线程">二、QThread线程启动方式</h3> 
<p>一、继承QThread，实现它的run()函数，将需要执行的耗时代码放在run()里面运行</p> 
<pre><code>void myThread::run()
{
    m_stop = false;
    while (!m_stop)
    {
        /*耗时任务*/
        ...
    }
}</code></pre> 
<p>此方法，如果要退出可使用</p> 
<pre><code>void myThread::stop()
{
    m_stop = true;
    quit();
    wait();
}</code></pre> 
<p><br> 使用时，调用start()函数，则相当于执行run()函数，在程任务执行完毕时，会发出 finished() 信号</p> 
<pre><code>/*子类化线程*/
mythread = new myThread();
connect(mythread,SIGNAL(finished()),this,SLOT(dealfinished()));
mythread-&gt;start();</code></pre> 
<p><br><br> 二、使用moveToThread()。即子类化一个QObject实现需要执行的操作，再将派生类对象移到QThread中，并通过信号和槽触开始执行。</p> 
<pre><code>/*QObject派生类，即耗时工作在这里实现*/
work = new Work;
/*通过信号和槽获取返回信息*/
connect(work,SIGNAL(resultReady(int)),this,SLOT(dealWorkresultReady(int)));

/*将派生类对象移动到QThread中*/
thread = new QThread(this);
connect(thread,SIGNAL(finished()),this,SLOT(dealfinished_2()));
work-&gt;moveToThread(thread);
/*通过信号链接派生类的槽函数，并通过信号触发*/
connect(thread,SIGNAL(started()),work,SLOT(start()));
thread-&gt;start();</code></pre> 
<p></p> 
<h4>三、实现案例及代码</h4> 
<p><img alt="" height="369" src="https://images2.imgbox.com/e0/04/YYW8m0iM_o.png" width="762"></p> 
<p>方式一：子类化QThread</p> 
<p>mythread.h</p> 
<pre><code class="hljs">#ifndef MYTHREAD_H
#define MYTHREAD_H

#include &lt;QThread&gt;

class myThread : public QThread
{
    Q_OBJECT
public:
    explicit myThread(QObject *parent = NULL);
    void stop();
protected:
    virtual void run();

signals:
    void resultReady(int value);
private:
    bool m_stop;
};

#endif // MYTHREAD_H
</code></pre> 
<p> mythread.cpp</p> 
<pre><code class="hljs">#include "mythread.h"
myThread::myThread(QObject *parent) : QThread(parent)
{
}

void myThread::stop()
{
    m_stop = true;
    quit();
    wait();
}

void myThread::run()
{
    /*start会触发run，即需要执行的耗时工作加这里*/
    m_stop = false;
    int nValue = 0;
    while (nValue &lt; 100 &amp;&amp; !m_stop)
    {
        emit resultReady(nValue);
        /*耗时0.5秒*/
        system("sleep 0.5");
        ++nValue;
        /*发送信号，更新进度条*/
    }
}

</code></pre> 
<p> 方式二：子类化QObject</p> 
<p>work.h </p> 
<pre><code class="hljs">#ifndef WORK_H
#define WORK_H

#include &lt;QObject&gt;

class Work : public QObject
{
    Q_OBJECT
public:
    explicit Work(QObject *parent = NULL);
    void stop();

public slots:
    void start();
signals:
    void resultReady(int value);
private:
    bool m_stop;
};

#endif // WORK_H</code></pre> 
<p>work.cpp</p> 
<pre><code class="hljs">#include "work.h"
Work::Work(QObject *parent) : QObject(parent)
{

}

void Work::stop()
{
    m_stop = true;
}

void Work::start()
{
    m_stop = false;
    int nValue = 0;
    while (nValue &lt; 100 &amp;&amp; !m_stop )
    {
        emit resultReady(nValue);
        /*耗时0.5秒*/
        system("sleep 0.5");
        ++nValue;
    }
}</code></pre> 
<p>效果图界面 widget.cpp</p> 
<pre><code class="hljs">#include "widget.h"
#include "ui_widget.h"
#include &lt;QDateTime&gt;
#include &lt;QDebug&gt;
Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);

    /*定时器，加载时间*/
    timer = new QTimer(this);
    connect(timer,SIGNAL(timeout()),this,SLOT(dealTimeout()));
    timer-&gt;start(1000);

    ui-&gt;progressBar-&gt;setValue(0);
    ui-&gt;progressBar-&gt;setMaximum(100);
    ui-&gt;progressBar_2-&gt;setValue(0);
    ui-&gt;progressBar_2-&gt;setMaximum(100);
    ui-&gt;progressBar_3-&gt;setValue(0);
    ui-&gt;progressBar_3-&gt;setMaximum(100);

    /*子类化线程*/
    mythread = new myThread(this);
    connect(mythread,SIGNAL(resultReady(int)),this,SLOT(dealresultReady(int)));
    connect(mythread,SIGNAL(finished()),this,SLOT(dealfinished()));


    /*QObject派生类，即耗时工作在这里实现*/
    work = new Work;
    /*通过信号和槽获取返回信息*/
    connect(work,SIGNAL(resultReady(int)),this,SLOT(dealWorkresultReady(int)));

    /*将派生类对象移动到QThread中*/
    thread = new QThread(this);
    connect(thread,SIGNAL(finished()),this,SLOT(dealfinished_2()));

    work-&gt;moveToThread(thread);
    /*通过信号链接派生类的槽函数，并通过信号触发*/
    connect(thread,SIGNAL(started()),work,SLOT(start()));

}

Widget::~Widget()
{
    delete ui;
}

void Widget::dealresultReady(int value)
{
    ui-&gt;progressBar-&gt;setValue(value);
}

void Widget::dealWorkresultReady(int value)
{
    ui-&gt;progressBar_3-&gt;setValue(value);
}

void Widget::on_pushButton_1_clicked()
{
    if(!mythread-&gt;isRunning()){
        ui-&gt;pushButton_1-&gt;setText("stop");
        mythread-&gt;start();
    }else{
        ui-&gt;pushButton_1-&gt;setText("start_1");
        mythread-&gt;stop();
    }
}

void Widget::on_pushButton_2_clicked()
{
    if(!thread-&gt;isRunning()){
        ui-&gt;pushButton_2-&gt;setText("stop");
        thread-&gt;start();
    }else{
        ui-&gt;pushButton_2-&gt;setText("start_2");
        work-&gt;stop();
        thread-&gt;quit();
        thread-&gt;wait();
    }
}

void Widget::on_pushButton_clicked()
{
    ui-&gt;label_2-&gt;setText("&lt;font style='color: red;'&gt;完犊子，直接卡死! 点其他按钮么反应! 时间都没更新了!&lt;/font&gt;");
    update();
    int cnt=0;
    while(cnt &lt; 100)
    {
        system("sleep 0.5");
        ui-&gt;progressBar_2-&gt;setValue(cnt);
        cnt++;
        update();
    }
}

void Widget::dealfinished()
{
    qDebug()&lt;&lt; "start_1 over";
}

void Widget::dealfinished_2()
{
    qDebug()&lt;&lt; "start_2 over";
}

void Widget::dealTimeout()
{
    QDateTime dateTime = QDateTime::currentDateTime();
    QString date = dateTime.toString("hh:mm:ss");
    ui-&gt;label_3-&gt;setText("当前时间："+date);
}</code></pre> 
<p></p> 
<p>              <br> 原文链接：https://blog.csdn.net/kchmmd/article/details/121202881</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/065baa36bca7c047ae2ea3fea3805240/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">List 多个集合如何找出重复的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d1688d0d46101ff0bbbff0789841657/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue.js&#43;SpringBoot开发APK检测管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>