<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PCL教程-点云分割之欧式聚类分割 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PCL教程-点云分割之欧式聚类分割" />
<meta property="og:description" content="原文链接：Euclidean Cluster Extraction
目录
理论基础
程序代码
代码解析
使用Kd-tree作为抽取算法的搜索方法
创建EuclideanClusterExtraction对象，并设置参数
实验结果
点云处理全过程
滤波
平面分割并去除
聚类抽取
打印结果
CMakeLists.txt
在本篇教程中，我们将学习使用pcl::EuclideanClusterExtraction类提取欧几里德聚类。为了使本篇教程更加精简，之前教程中提到的知识点将不再重复说明，比如平面模型分割，可参考之前的博文：PCL教程-点云分割之平面模型分割
数据集下载链接： table_scene_lms400.pcd
理论基础 聚类方法，通过特征空间确定点与点之间的亲疏程度。
一个聚类方法需要将一个无序的点云模型P分割成更小的部分，使得处理P的整体时间显著减少。一种简单的欧氏聚类方法可以通过使用固定宽度的框对空间进行三维网格细分来实现，或者更普遍地说，使用八叉树数据结构。
这种特殊的表示非常快速，对于需要占用空间的体积表示，或者对每个结果3D盒子(或八叉树叶子)中的数据可以近似为不同的结构的情况非常有用。
然而，在更一般的意义上，我们可以利用最近邻并实现一种本质上类似于漫水填充算法的聚类技术。
假设我们使用的点云数据的场景为：一张桌子，以及桌子上放置的一些东西。我们要找出并分割平面上的单个目标点云族:
假设我们使用Kd-tree结构去查找最近邻，算法步骤如下：
为输入的点云数据集P创建Kd-tree的表示设置一个空的聚类列表C，以及一个需要被检查的点云队列Q然后对P中的每一个点p_i进行如下步骤： 将p_i添加到当前队列Q对每个Q中的 p_i 进行如下步骤： 设置半径 r&lt;d_th，在此范围内搜索 p_i 的 最近邻 点云集 P_i_k.对于每个最近邻点云集 P_i_k ,检查其中的点是否被处理过，如果没有被处理过，就添加到Q中。当Q中列表中的所有点都被处理完成了，把Q添加到聚类列表C中，并将Q清空。当数据集P中的所有点都被处理过了，并且成了聚类列表中的一部分，算法完成。 算法流程简述： 找到空间中某点p，有kdTree找到离他最近的n个点，判断这n个点到p的距离。将距离小于阈值r的点 p1,p2,p3....放在类Q里在 Q里找到一点p1,重复1，找到p22,p23,p24....全部放进Q里 当 Q 再也不能有新点加入了，则完成搜索了 程序代码 #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/filters/voxel_grid.h&gt; #include &lt;pcl/features/normal_3d.h&gt; #include &lt;pcl/kdtree/kdtree.h&gt; #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/segmentation/extract_clusters.h&gt; #include&lt;pcl/visualization/pcl_visualizer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/20db70af6310ccfed415fd4875538a15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-11T21:16:49+08:00" />
<meta property="article:modified_time" content="2022-04-11T21:16:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PCL教程-点云分割之欧式聚类分割</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>原文链接：<a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/cluster_extraction.html#cluster-extraction" rel="nofollow" title="Euclidean Cluster Extraction">Euclidean Cluster Extraction</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" rel="nofollow"> 理论基础</a></p> 
<p id="%C2%A0%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81" rel="nofollow"> 程序代码</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" rel="nofollow">代码解析</a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8Kd-tree%E4%BD%9C%E4%B8%BA%E6%8A%BD%E5%8F%96%E7%AE%97%E6%B3%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8Kd-tree%E4%BD%9C%E4%B8%BA%E6%8A%BD%E5%8F%96%E7%AE%97%E6%B3%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95" rel="nofollow"> 使用Kd-tree作为抽取算法的搜索方法</a></p> 
<p id="%C2%A0%E5%88%9B%E5%BB%BAEuclideanClusterExtraction%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%88%9B%E5%BB%BAEuclideanClusterExtraction%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0" rel="nofollow"> 创建EuclideanClusterExtraction对象，并设置参数</a></p> 
<p id="%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C" rel="nofollow">实验结果</a></p> 
<p id="%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E5%85%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E5%85%A8%E8%BF%87%E7%A8%8B" rel="nofollow">点云处理全过程</a></p> 
<p id="%C2%A0%E6%BB%A4%E6%B3%A2-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%BB%A4%E6%B3%A2" rel="nofollow"> 滤波</a></p> 
<p id="%C2%A0%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E5%B9%B6%E5%8E%BB%E9%99%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E5%B9%B6%E5%8E%BB%E9%99%A4" rel="nofollow"> 平面分割并去除</a></p> 
<p id="%C2%A0%E8%81%9A%E7%B1%BB%E6%8A%BD%E5%8F%96-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%81%9A%E7%B1%BB%E6%8A%BD%E5%8F%96" rel="nofollow"> 聚类抽取</a></p> 
<p id="%C2%A0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C" rel="nofollow"> 打印结果</a></p> 
<p id="%C2%A0CMakeLists.txt-toc" style="margin-left:40px;"><a href="#%C2%A0CMakeLists.txt" rel="nofollow"> CMakeLists.txt</a></p> 
<hr id="hr-toc"> 
<p>在本篇教程中，我们将学习使用<strong>pcl::EuclideanClusterExtraction类</strong>提取欧几里德聚类。为了使本篇教程更加精简，之前教程中提到的知识点将不再重复说明，比如平面模型分割，可参考之前的博文：PCL教程-<a href="https://blog.csdn.net/luolaihua2018/article/details/120136665" title="点云分割之平面模型分割">点云分割之平面模型分割</a></p> 
<blockquote> 
 <p>数据集下载链接： <a href="https://raw.github.com/PointCloudLibrary/data/master/tutorials/table_scene_lms400.pcd" rel="nofollow" title="table_scene_lms400.pcd">table_scene_lms400.pcd</a></p> 
</blockquote> 
<h2 id="%C2%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"> 理论基础</h2> 
<p><strong>聚类方法，通过特征空间确定点与点之间的亲疏程度。</strong></p> 
<p>一个聚类方法需要将一个无序的点云模型P分割成更小的部分，使得处理P的整体时间显著减少。一种简单的欧氏聚类方法可以通过使用固定宽度的框对空间进行三维网格细分来实现，或者更普遍地说，使用八叉树数据结构。</p> 
<p>这种特殊的表示非常快速，对于需要占用空间的体积表示，或者对每个结果3D盒子(或八叉树叶子)中的数据可以近似为不同的结构的情况非常有用。</p> 
<p>然而，在更一般的意义上，我们可以利用最近邻并实现一种本质上类似于漫水填充算法的聚类技术。</p> 
<p>假设我们使用的点云数据的场景为：一张桌子，以及桌子上放置的一些东西。我们要找出并分割平面上的单个目标点云族:</p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/33/3c/IFNq3Id6_o.png" width="914"></p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/f0/79/UeDePquj_o.png" width="891"></p> 
<p> 假设我们使用Kd-tree结构去查找最近邻，算法步骤如下：</p> 
<ol><li>为输入的点云数据集P创建Kd-tree的表示</li><li>设置一个空的聚类列表C，以及一个需要被检查的点云队列Q</li><li>然后对P中的每一个点p_i进行如下步骤： 
  <ol><li>将p_i添加到当前队列Q</li><li>对每个Q中的 p_i 进行如下步骤： 
    <ol><li>设置半径 r&lt;d_th，在此范围内搜索 p_i 的 最近邻 点云集 P_i_k.</li><li>对于每个最近邻点云集 P_i_k ,检查其中的点是否被处理过，如果没有被处理过，就添加到Q中。</li></ol></li></ol></li><li>当Q中列表中的所有点都被处理完成了，把Q添加到聚类列表C中，并将Q清空。</li><li>当数据集P中的所有点都被处理过了，并且成了聚类列表中的一部分，算法完成。</li></ol> 
<p><strong>算法流程简述： </strong></p> 
<ol><li><strong>找到空间中某点p，有kdTree找到离他最近的n个点，判断这n个点到p的距离。将距离小于阈值r的点 p1,p2,p3....放在类Q里</strong></li><li><strong>在 Q里找到一点p1,重复1，找到p22,p23,p24....全部放进Q里 </strong></li><li><strong>当 Q 再也不能有新点加入了，则完成搜索了</strong></li></ol> 
<h2 id="%C2%A0%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81"> 程序代码</h2> 
<pre><code class="language-cpp">#include &lt;pcl/ModelCoefficients.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/kdtree/kdtree.h&gt;
#include &lt;pcl/sample_consensus/method_types.h&gt;
#include &lt;pcl/sample_consensus/model_types.h&gt;
#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/segmentation/extract_clusters.h&gt;
#include&lt;pcl/visualization/pcl_visualizer.h&gt;
bool isPushSpace = false;
//键盘事件
void keyboard_event_occurred(const pcl::visualization::KeyboardEvent&amp; event, void * nothing)
{
	if (event.getKeySym() == "space" &amp;&amp; event.keyDown())
	{
		isPushSpace = true;
	}
}
int
main(int argc, char** argv)
{
	// 从PCD文件中读取点云数据
	pcl::PCDReader reader;
	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_f(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
	reader.read("table_scene_lms400.pcd", *cloud);
	std::cout &lt;&lt; "PointCloud before filtering has: " &lt;&lt; cloud-&gt;points.size() &lt;&lt; " data points." &lt;&lt; std::endl; //*

	pcl::visualization::PCLVisualizer viewer("Cluster Extraction");
	// 注册键盘事件
	viewer.registerKeyboardCallback(&amp;keyboard_event_occurred, (void*)NULL);
	int v1(1);
	int v2(2);
	viewer.createViewPort(0, 0, 0.5, 1, v1);
	viewer.createViewPort(0.5, 0, 1, 1, v2);

	//创建滤波对象: 使用下采样，叶子的大小为 1cm
	pcl::VoxelGrid&lt;pcl::PointXYZ&gt; vg;
	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
	vg.setInputCloud(cloud);
	vg.setLeafSize(0.01f, 0.01f, 0.01f);
	vg.filter(*cloud_filtered);
	std::cout &lt;&lt; "PointCloud after filtering has: " &lt;&lt; cloud_filtered-&gt;points.size() &lt;&lt; " data points." &lt;&lt; std::endl; //*

	viewer.addPointCloud(cloud, "cloud1", v1);
	viewer.addPointCloud(cloud_filtered, "cloud2", v2);
	//渲染10秒再继续
	viewer.spinOnce(10000);

	// 创建平面分割对象
	pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
	pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
	pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
	pcl::PCDWriter writer;
	seg.setOptimizeCoefficients(true);
	seg.setModelType(pcl::SACMODEL_PLANE);
	seg.setMethodType(pcl::SAC_RANSAC);
	seg.setMaxIterations(100);
	seg.setDistanceThreshold(0.02);

	// 把点云中所有的平面全部过滤掉，重复过滤，直到点云数量小于原来的0.3倍
	int i = 0, nr_points = (int)cloud_filtered-&gt;points.size();
	while (cloud_filtered-&gt;points.size() &gt; 0.3 * nr_points)
	{	
		// Segment the largest planar component from the remaining cloud
		seg.setInputCloud(cloud_filtered);
		seg.segment(*inliers, *coefficients);
		if (inliers-&gt;indices.size() == 0)
		{
			std::cout &lt;&lt; "Could not estimate a planar model for the given dataset." &lt;&lt; std::endl;
			break;
		}

		// Extract the planar inliers from the input cloud
		pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
		extract.setInputCloud(cloud_filtered);
		extract.setIndices(inliers);
		extract.setNegative(false);

		// Write the planar inliers to disk
		extract.filter(*cloud_plane);
		std::cout &lt;&lt; "PointCloud representing the planar component: " &lt;&lt; cloud_plane-&gt;points.size() &lt;&lt; " data points." &lt;&lt; std::endl;

		// Remove the planar inliers, extract the rest
		extract.setNegative(true);
		extract.filter(*cloud_f);

		//更新显示点云
		viewer.updatePointCloud(cloud_filtered, "cloud1");
		viewer.updatePointCloud(cloud_f, "cloud2");
		//渲染3秒再继续
		viewer.spinOnce(3000);

		cloud_filtered = cloud_f;

	}

	viewer.removePointCloud("cloud2", v2);

	// 创建KdTreee对象作为搜索方法
	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
	tree-&gt;setInputCloud(cloud_filtered);

	std::vector&lt;pcl::PointIndices&gt; cluster_indices;
	pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
	ec.setClusterTolerance(0.02); // 2cm
	ec.setMinClusterSize(100);
	ec.setMaxClusterSize(25000);
	ec.setSearchMethod(tree);
	ec.setInputCloud(cloud_filtered);
	//聚类抽取结果保存在一个数组中，数组中每个元素代表抽取的一个组件点云的下标
	ec.extract(cluster_indices);

	//遍历抽取结果，将其显示并保存
	int j = 0;
	for (std::vector&lt;pcl::PointIndices&gt;::const_iterator it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
	{
		//创建临时保存点云族的点云
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_cluster(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		//通过下标，逐个填充
		for (std::vector&lt;int&gt;::const_iterator pit = it-&gt;indices.begin(); pit != it-&gt;indices.end(); pit++)
			cloud_cluster-&gt;points.push_back(cloud_filtered-&gt;points[*pit]); //*

		//设置点云属性
		cloud_cluster-&gt;width = cloud_cluster-&gt;points.size();
		cloud_cluster-&gt;height = 1;
		cloud_cluster-&gt;is_dense = true;

		std::cout &lt;&lt; "当前聚类 "&lt;&lt;j&lt;&lt;" 包含的点云数量: " &lt;&lt; cloud_cluster-&gt;points.size() &lt;&lt; " data points." &lt;&lt; std::endl;
		std::stringstream ss;
		ss &lt;&lt; "cloud_cluster_" &lt;&lt; j &lt;&lt; ".pcd";
		writer.write&lt;pcl::PointXYZ&gt;(ss.str(), *cloud_cluster, false); //*
		j++;

		//显示,随机设置不同颜色，以区分不同的聚类
		pcl::visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt; cluster_color(cloud_cluster, rand()*100 + j * 80, rand() * 50 + j * 90, rand() * 200 + j * 100);
		viewer.addPointCloud(cloud_cluster,cluster_color, ss.str(), v2);
		viewer.spinOnce(5000);
	}
	while (!viewer.wasStopped())
	{
		viewer.spinOnce();
	}
	return (0);
}
</code></pre> 
<h2 id="%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">代码解析</h2> 
<h3 id="%C2%A0%E4%BD%BF%E7%94%A8Kd-tree%E4%BD%9C%E4%B8%BA%E6%8A%BD%E5%8F%96%E7%AE%97%E6%B3%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95"> 使用Kd-tree作为抽取算法的搜索方法</h3> 
<pre><code class="language-cpp">// Creating the KdTree object for the search method of the extraction
  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
  tree-&gt;setInputCloud (cloud_filtered);</code></pre> 
<h3 id="%C2%A0%E5%88%9B%E5%BB%BAEuclideanClusterExtraction%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"> 创建EuclideanClusterExtraction对象，并设置参数</h3> 
<ul><li> 点云类型为：PointXYZ</li><li><strong>setClusterTolerance(0.02)：设置聚类容忍度为2cm，如果设置的值过小，可能会将一个对象误判为多个聚类，反之，如果过大，则可能会将多个多个对象误判为一个聚类。所以需根据实际情况进行设置。</strong></li><li><strong>setMinClusterSize()、setMaxClusterSize()</strong> ：设置最大聚类和最小聚类的点云数量大小</li><li>结果保存在<strong>cluster_indices，一个vector类型的数组，每个元素代表一个聚类的所有点云下标。</strong></li></ul> 
<pre><code class="language-cpp">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
  ec.setClusterTolerance (0.02); // 2cm
  ec.setMinClusterSize (100);
  ec.setMaxClusterSize (25000);
  ec.setSearchMethod (tree);
  ec.setInputCloud (cloud_filtered);
  ec.extract (cluster_indices);</code></pre> 
<p></p> 
<h2 id="%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">实验结果</h2> 
<h3 id="%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E5%85%A8%E8%BF%87%E7%A8%8B">点云处理全过程</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/62/G1Dbw5Id_o.gif"></p> 
<h3 id="%C2%A0%E6%BB%A4%E6%B3%A2"> 滤波</h3> 
<p>左图为原始点云数据，右图为滤波后的点云：</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/83/e9/xSVSh4tn_o.png" width="960"></p> 
<h3 id="%C2%A0%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E5%B9%B6%E5%8E%BB%E9%99%A4"> 平面分割并去除</h3> 
<p>将点云中所有平面都分割出来，并剔除：</p> 
<h3 id="%E2%80%8B"><img alt="" height="576" src="https://images2.imgbox.com/3a/98/bPl5QsT1_o.png" width="950"></h3> 
<p> <img alt="" height="577" src="https://images2.imgbox.com/d5/d7/DLaLn1Fr_o.png" width="958"></p> 
<h3 id="%C2%A0%E8%81%9A%E7%B1%BB%E6%8A%BD%E5%8F%96"> 聚类抽取</h3> 
<p>使用Kd-tree的结构，对处理后的点云进行聚类抽取，右图为抽取之后的结果，不同颜色代表不同聚类点云：</p> 
<p> ​​​​​​<img alt="" height="575" src="https://images2.imgbox.com/d4/2c/FpearWJG_o.png" width="959"></p> 
<h3 id="%C2%A0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C"> 打印结果</h3> 
<blockquote> 
 <p>PointCloud before filtering has: 460400 data points.<br> PointCloud after filtering has: 41049 data points.<br> PointCloud representing the planar component: 20536 data points.<br> PointCloud representing the planar component: 12442 data points.<br> 当前聚类 0 包含的点云数量: 4857 data points.<br> 当前聚类 1 包含的点云数量: 1386 data points.<br> 当前聚类 2 包含的点云数量: 321 data points.<br> 当前聚类 3 包含的点云数量: 291 data points.<br> 当前聚类 4 包含的点云数量: 123 data points.</p> 
</blockquote> 
<h2 id="%C2%A0CMakeLists.txt"> CMakeLists.txt</h2> 
<pre><code class="language-cpp">cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

project(cluster_extraction)

find_package(PCL 1.2 REQUIRED)

include_directories(${PCL_INCLUDE_DIRS})
link_directories(${PCL_LIBRARY_DIRS})
add_definitions(${PCL_DEFINITIONS})

add_executable (cluster_extraction cluster_extraction.cpp)
target_link_libraries (cluster_extraction ${PCL_LIBRARIES})</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97349e6594a0ebf4a4d70d3883dcb780/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenFOAM写代码用并行时出错的一种解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20ea1f7a7721b04b7137896925f7519b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PCL教程-点云分割之平面模型分割</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>