<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3 &#43;ts 安装并封装axios - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3 &#43;ts 安装并封装axios" />
<meta property="og:description" content="目录
1、为什么要封装axios
2、安装
3、封装request
4、使用步骤
步骤1:请求数据 ( 举例下面几个常用的 )
步骤2:在要请求的组件上使用
5、代理
1、为什么要封装axios axios.get().then() 这样的书写,会有缺陷,在以下缺点
1、请求头能不能统一处理
解决： 创建一个 request/request.js 文件夹，
在里面可以使用axios.create创建实例对象
也可以在里面设置 请求 与 响应 拦截器
2、不便于接口的统一管理 解决：在 request 文件夹加多一个api文件来管理所有接口，
(会先导入rerequest.js的实例)
并使用函数，不然每次发请求时都会跑一次api文件
3、容易出现回调地狱
LogoutAPI () 最终的结果是返回proise对象
解决:acync &#43; await
await 后面一般放promise对象
注意：但封装axios后还是可以用 .then() 2、安装 npm install axios 3、封装request 先在 src 下创建一个 request 文件夹，并添加一个 request.ts 文件
import axios from &#39;axios&#39; // 创建axios实例 const request = axios.create({ baseURL: &#39;&#39;,// 所有的请求地址前缀部分 timeout: 80000, // 请求超时时间(毫秒) withCredentials: true,// 异步请求携带cookie // headers: { // 设置后端需要的传参类型 // &#39;Content-Type&#39;: &#39;application/json&#39;, // &#39;token&#39;: x-auth-token&#39;,//一开始就要token // &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;, // }, }) // request拦截器 request." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4b04543da9fee5f2ac1ffbcfff4417f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-22T16:47:04+08:00" />
<meta property="article:modified_time" content="2024-02-22T16:47:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3 &#43;ts 安装并封装axios</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">1、为什么要封装axios</a></p> 
<p id="%E5%AE%89%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E5%AE%89%E8%A3%85" rel="nofollow">2、安装</a></p> 
<p id="%E5%B0%81%E8%A3%85request-toc" style="margin-left:0px;"><a href="#%E5%B0%81%E8%A3%85request" rel="nofollow">3、封装request</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" rel="nofollow">4、使用步骤</a></p> 
<p id="%C2%A0%E6%AD%A5%E9%AA%A41%3A%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%20(%20%E4%B8%BE%E4%BE%8B%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%20)-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%AD%A5%E9%AA%A41%3A%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%20%28%20%E4%B8%BE%E4%BE%8B%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%20%29" rel="nofollow"> 步骤1:请求数据 ( 举例下面几个常用的 )</a></p> 
<p id="%C2%A0%E6%AD%A5%E9%AA%A42%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%AD%A5%E9%AA%A42%3A" rel="nofollow"> 步骤2:在要请求的组件上使用</a></p> 
<p id="%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%90%86" rel="nofollow">5、代理</a></p> 
<hr id="hr-toc"> 
<h2>1、为什么要封装axios</h2> 
<blockquote> 
 <p>axios.get().then()   这样的书写,会有缺陷,在以下缺点<br> 1、请求头能不能统一处理<br>     解决： 创建一个 request/request.js 文件夹，<br>         在里面可以使用axios.create创建实例对象<br>         也可以在里面设置  请求 与 响应 拦截器</p> 
 <p>2、不便于接口的统一管理  <br>     解决：在 request 文件夹加多一个api文件来管理所有接口，<br>         (会先导入rerequest.js的实例)<br>         并使用函数，不然每次发请求时都会跑一次api文件</p> 
 <p>3、容易出现回调地狱<br>     LogoutAPI () 最终的结果是返回proise对象<br>     解决:acync + await<br>     await 后面一般放promise对象</p> 
</blockquote> 
<p><strong>注意：</strong>但封装axios后还是可以用 .then() </p> 
<h2 id="%E5%AE%89%E8%A3%85">2、安装</h2> 
<pre><code>npm install axios
</code></pre> 
<h2 id="%E5%B0%81%E8%A3%85request">3、封装request</h2> 
<p>先在 src 下创建一个 request 文件夹，并添加一个  request.ts  文件</p> 
<pre><code class="language-javascript">import axios from 'axios'
// 创建axios实例
const request = axios.create({
    baseURL: '',// 所有的请求地址前缀部分
    timeout: 80000, // 请求超时时间(毫秒)
    withCredentials: true,// 异步请求携带cookie
    // headers: {
    // 设置后端需要的传参类型
    // 'Content-Type': 'application/json',
    // 'token': x-auth-token',//一开始就要token
    // 'X-Requested-With': 'XMLHttpRequest',
    // },
})

// request拦截器
request.interceptors.request.use(
    config =&gt; {
        // 如果你要去localStor获取token,(如果你有)
        // let token = localStorage.getItem("x-auth-token");
        // if (token) {
                //添加请求头
                //config.headers["Authorization"]="Bearer "+ token
        // }
        return config
    },
    error =&gt; {
        // 对请求错误做些什么
        Promise.reject(error)
    }
)

// response 拦截器
request.interceptors.response.use(
    response =&gt; {
        // 对响应数据做点什么
        return response.data
    },
    error =&gt; {  
        // 对响应错误做点什么
        return Promise.reject(error)
    }
)
export default request
</code></pre> 
<h2 id="%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">4、使用步骤</h2> 
<blockquote> 
 <p><strong>注意：</strong>​​因为get请求的参数需要`params`，它是即将与请求一起发送的 URL 参数，为了简写采用了ES6的解构，就是把下面的 params 解构，<strong>只有get 请求需要加多一层`params`</strong>。</p> 
</blockquote> 
<blockquote> 
 <p> 其它请求，如 post 等请求等就不用解构，形参是什么都行。</p> 
</blockquote> 
<h4 id="%C2%A0%E6%AD%A5%E9%AA%A41%3A%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%20(%20%E4%B8%BE%E4%BE%8B%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%20)"> 步骤1:请求数据 ( 举例下面几个常用的 )</h4> 
<p>在 request 文件夹，再添加一个  api.ts  文件</p> 
<blockquote> 
 <p>定义接口格式：</p> 
 <p>export  const  自定义接口名  =  (形参:请求类型)：返回类型  =&gt;  instance.方法(路径，后端要的参数);</p> 
</blockquote> 
<pre><code class="language-javascript">import instance from "./request";

//一般情况下，接口类型会放到一个文件
// 下面两个TS接口，表示要传的参数
interface ReqLogin {
    name: string
    paw: string
}
interface ReqStatus {
    id: string
    navStatus: string
}


// Res是返回的参数，T是泛型，需要自己定义，返回对数统一管理***
type Res&lt;T&gt; = Promise&lt;ItypeAPI&lt;T&gt;&gt;;
// 一般情况下响应数据返回的这三个参数，
// 但不排除后端返回其它的可能性，
interface ItypeAPI&lt;T&gt; {
    data: T,//请求的数据，用泛型
    msg: string | null // 返回状态码的信息，如请求成功等
    code: number //返回后端自定义的200，404，500这种状态码
}


// post请求 ，没参数
export const LogoutAPI = (): Res&lt;null&gt; =&gt; 
    instance.post("/admin/logout");

// post请求，有参数,如传用户名和密码
export const loginAPI = (data: ReqLogin): Res&lt;string&gt; =&gt;
    instance.post("/admin/login", data);

// post请求 ，没参数，但要路径传参
export const StatusAPI = (data: ReqStatus): Res&lt;null&gt; =&gt;
    instance.post(`/productCategory?ids=${data.id}&amp;navStatus=${data.navStatus}`);


//  get请求，没参数，
export const FlashSessionListApi = (): Res&lt;null&gt; =&gt;
    instance.get("/flashSession/list");

// get请求，有参数，路径也要传参  (也可能直接在这写类型，不过不建议,大点的项目会维护一麻烦)
export const ProductCategoryApi = (params: { parentId: number }): any =&gt;
    instance.get(`/productCategory/list/${params.parentId}`, { params });

// get请求，有参数，(如果你不会写类型也可以使用any,不过不建议,因为用了之后 和没写TS一样)
export const AdminListAPI = (params:any): any =&gt; 
    instance.get("/admin/list", { params });

</code></pre> 
<h4 id="%C2%A0%E6%AD%A5%E9%AA%A42%3A"> 步骤2:在要请求的组件上使用</h4> 
<p>使用方式一：直接使用(和vue2在cretae上用一样，setup自带async，await在顶层可以直接使用)</p> 
<pre><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { indexAPI} from "../../request/api";
    //直接使用，一般用在进入页面入请求数据的接口
    let res = await indexAPI()
    console.log( "***" ,res);

&lt;/script&gt;</code></pre> 
<p>使用方式二：使用 async / await，（setup虽然自带async，但单独用await只能在顶层使用，如果在函数下还是要async / await一起写）</p> 
<pre><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { returnApplyListAPi } from "../../request/api";

const search = async(val: IUseTableParam) =&gt; {
    let res = await returnApplyListAPi({
        ...val,
    })
    console.log( "***" ,res);
    let { list, pageNum, pageSize, total } = res.data
    console.log(list, pageNum, pageSize, total);
}
&lt;/script&gt;</code></pre> 
<p>使用方式三：使用.then</p> 
<pre><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { returnApplyListAPi} from "../../request/api";

const logout = () =&gt; {
    returnApplyListAPi({
        ...val,
    }).then((res) =&gt; {
         console.log('***',res );
        let { list, pageNum, pageSize, total } = res.data
    })

};
&lt;/script&gt;</code></pre> 
<h2 id="%E4%BB%A3%E7%90%86">5、代理</h2> 
<blockquote> 
 <p>需要代理才写</p> 
</blockquote> 
<p>上面的request 文件中 </p> 
<pre><code class="language-javascript">const request = axios.create({
    //这时你要代理
    //填写后端统一的前缀，
    //如：123.xx.xx.xx:456/api/...
    //这个/api是每一个接口都有的，就写它
    //如果没有，也写，下面会讲区别
    baseURL: '/api',
})</code></pre> 
<p>vite.config.ts 文件</p> 
<pre><code class="language-javascript">// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue(),
        //...
    ],
    server: {
        proxy: {
            '/api': { // 匹配请求路径，
                target: '你要代理的地址', // 代理的目标地址
                 // 开发模式，默认的127.0.0.1,开启后代理服务会把origin修改为目标地址
                changeOrigin: true,
                // secure: true, // 是否https接口
                // ws: true, // 是否代理websockets

                // 路径重写，**** 如果你的后端有统一前缀(如:/api)，就不开启；没有就开启
                //简单来说，就是是否改路径 加某些东西
                rewrite: (path) =&gt; path.replace(/^\/api/, '') 
            }
        }
    }
})
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/881a3dff5240270c425daa14b9ef2b61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">下载、编译、安装、使用 vue-devtools</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0477f039a5c72ce06c76e60753db6fee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js对象的赋值，浅拷贝，深拷贝区分和使用场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>