<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的模板（初阶） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的模板（初阶）" />
<meta property="og:description" content="一、函数模板 1.概念 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生数的特定类型版本。
2.函数模板格式 template&lt;typename T1, typename T2,......,typename Tn&gt;
返回值类型 函数名(参数列表){}
template&lt;typename T&gt; void Swap(T&amp; a, T&amp; b) { T temp = a; a = b; b = temp; } 注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替class)
3.函数模板原理 在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此
4.函数模板的实例化 用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。
（1）隐式实例化： 让编译器根据实参推演模板参数的实际类型
template&lt;class T&gt; T ADD(const T&amp; a,const T&amp; b) { return a &#43; b; } int main() { int a = 1, b = 2; double c = 1.0, d = 2.0; ADD(a, b); ADD(c, d); ADD(a, c);//这里会报错 return 0; } 上述代码的ADD(a,c)会报错，因为因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a将T推演为int，通过实参c将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/67dbd6245ab5b6d5aace2bd30ad7b716/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-06T16:12:39+08:00" />
<meta property="article:modified_time" content="2024-03-06T16:12:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的模板（初阶）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、函数模板</h2> 
<h3>1.概念</h3> 
<p>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生数的特定类型版本。<br>  </p> 
<h3 style="background-color:transparent;">2.函数模板格式</h3> 
<p>template&lt;typename T1, typename T2,......,typename Tn&gt;<br> 返回值类型 函数名(参数列表){}<br>  </p> 
<pre><code class="language-cpp">template&lt;typename T&gt;
void Swap(T&amp; a, T&amp; b)
{
	T temp = a;
	a = b;
	b = temp;
}</code></pre> 
<p>注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替class)<br>  </p> 
<h3>3.函数模板原理</h3> 
<p>在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此<br>  </p> 
<h3>4.函数模板的实例化</h3> 
<p>用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。<br>  </p> 
<h4>（1）隐式实例化：</h4> 
<p>让编译器根据实参推演模板参数的实际类型</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
T ADD(const T&amp; a,const T&amp; b)
{
	return a + b;
}

int main()
{
	int a = 1, b = 2;
	double c = 1.0, d = 2.0;
	ADD(a, b);
	ADD(c, d);

	ADD(a, c);//这里会报错
	return 0;
}</code></pre> 
<p>上述代码的ADD(a,c)会报错，因为因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a将T推演为int，通过实参c将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错</p> 
<p>此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化<br> 用户自己强制转化如下：</p> 
<pre><code class="language-cpp">ADD(a, (int)c);
ADD((double)a, c);
//两种都可以</code></pre> 
<h4>（2）显式实例化：</h4> 
<p>在函数名后的&lt;&gt;中指定模板参数的实际类型</p> 
<pre><code class="language-cpp">ADD&lt;int&gt;(a, c);
ADD&lt;double&gt;(a, c);</code></pre> 
<p>如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。<br>  </p> 
<h3>5.模板参数的匹配原则</h3> 
<p>（1）一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</p> 
<pre><code class="language-cpp">//专门处理int的加法函数
int ADD(int left, int right)
{
	return left + right;
}
//通用加法函数
template&lt;class T&gt;
T ADD(T a,T b)
{
	return a + b;
}
void Test()
{
	ADD(1, 2);//与非模板函数匹配，编译器不需要特化
	ADD&lt;int&gt;(1, 2);//调用编译器特化的Add版本
}</code></pre> 
<p>（2）对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板<br>  </p> 
<pre><code class="language-cpp">Add(1, 2); // 与非函数模板类型完全匹配，不需要函数模板实例化
Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数</code></pre> 
<p>（3）模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</p> 
<h2>二、类模板</h2> 
<h3>1.类模板的定义格式</h3> 
<p>template&lt;class T1, class T2, ..., class Tn&gt;<br> class 类模板名<br> {<!-- --><br>         // 类内成员定义<br> };</p> 
<pre><code class="language-cpp">// 动态顺序表
// 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具
template&lt;class T&gt;
class Vector
{
public:
	Vector(size_t capacity = 10)
		: _pData(new T[capacity])
		, _size(0)
		, _capacity(capacity)
	{}
	// 使用析构函数演示：在类中声明，在类外定义。
	~Vector();
	void PushBack(const T&amp; data)；
		void PopBack()；
		// ...
		size_t Size() { return _size; }
	T&amp; operator[](size_t pos)
	{
		assert(pos &lt; _size);
		return _pData[pos];
	}
private:
	T* _pData;
	size_t _size;
	size_t _capacity;
};
// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表
template &lt;class T&gt;
Vector&lt;T&gt;::~Vector()
{
	if (_pData)
		delete[] _pData;
	_size = _capacity = 0;
}</code></pre> 
<h3>2.类模板的实例化</h3> 
<p>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类<br>  </p> 
<pre><code class="language-cpp">// Vector类名，Vector&lt;int&gt;才是类型
Vector&lt;int&gt; s1;
Vector&lt;double&gt; s2;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/136e93b49a45305ff29a2158a2491169/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Echarts 动态实现柱状图、折线图、饼状图的切换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3dfef2d1d669bdd2fa8b2639018274c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react中封装一个自己的hook</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>