<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>读读文档吧 - SQLAlchemy 2.0 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="读读文档吧 - SQLAlchemy 2.0" />
<meta property="og:description" content="ORM Mapped Class Overview https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html
The original mapping API is commonly referred to as “classical” style, whereas the more automated style of mapping is known as “declarative” style. SQLAlchemy now refers to these two mapping styles as imperative mapping and declarative mapping.
The Declarative Mapping is the typical way that mappings are constructed in modern SQLAlchemy. # flask_sqlalchemy的源码，说明它用的是Declarative Mapping self.Model = self._make_declarative_base(model_class) &#34;&#34;&#34;A SQLAlchemy declarative model class. Subclass this to define database models." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/48026983e9ce47e9f577037666a156f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T12:21:01+08:00" />
<meta property="article:modified_time" content="2023-11-13T12:21:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">读读文档吧 - SQLAlchemy 2.0</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a class="has-card" href="https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html" rel="nofollow" title="ORM Mapped Class Overview "><span class="link-card-box"><span class="link-title">ORM Mapped Class Overview </span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/03/52/nymrkUEU_o.png" alt="icon-default.png?t=N7T8">https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html</span></span></a></p> 
<p>The original mapping API is commonly referred to as “<span style="color:#4da8ee;">classical</span>” style, whereas the <span style="color:#fe2c24;">more automated</span> style of mapping is known as “<span style="color:#fe2c24;">declarative</span>” style. SQLAlchemy now refers to these two mapping styles as <span style="color:#4da8ee;">imperative </span>mapping and declarative mapping.</p> 
<p>The <strong>Declarative Mapping</strong> is the typical way that mappings are constructed in modern SQLAlchemy. </p> 
<pre><code class="language-python"># flask_sqlalchemy的源码，说明它用的是Declarative Mapping
self.Model = self._make_declarative_base(model_class)
        """A SQLAlchemy declarative model class. Subclass this to define database
        models."""</code></pre> 
<p>The <strong>imperative mapping </strong><span style="color:#ad720d;">（总之先忽略这个方式就是了）</span> form is a lesser-used form of mapping that originates from the very first releases of SQLAlchemy in 2006.  It's recommended that new users start with Declarative Table configuration.</p> 
<p>Note that classes which are mapped with the Imperative approach are fully interchangeable with those mapped with the Declarative approach. <span style="color:#4da8ee;">Both systems ultimately create the same configuration, consisting of a Table, user-defined class, linked together with a Mapper object. （底层没区别）</span> When we talk about “the behavior of Mapper”, this includes when using the Declarative system as well - it’s still used, just behind the scenes.</p> 
<p></p> 
<p>In the vast majority of common cases this is an instance of Table. For more advanced use cases, it may also refer to any kind of <span style="color:#4da8ee;">FromClause </span>object, the most common alternative objects being the <span style="color:#4da8ee;">Subquery and Join object. （也可以和子查询、视图进行map）</span></p> 
<p></p> 
<p>The registry applies a default constructor, i.e. __init__ method, to all mapped classes that don’t explicitly have their own __init__ method. The behavior of this method is such that it provides a convenient keyword constructor that will accept as optional keyword arguments all the attributes that are named. （有一个默认的构造函数）</p> 
<p>A class that includes an explicit __init__() method will maintain that method, and no default constructor will be applied. （自己定义了，就把默认的覆盖了）<br>  </p> 
<p><a class="has-card" href="https://docs.sqlalchemy.org/en/20/orm/declarative_styles.html" rel="nofollow" title="Declarative Mapping Styles"><span class="link-card-box"><span class="link-title">Declarative Mapping Styles</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/fe/12/nhtF0fmN_o.png" alt="icon-default.png?t=N7T8">https://docs.sqlalchemy.org/en/20/orm/declarative_styles.html</span></span></a></p> 
<p><strong>继承（一般就用这个就好）</strong> The most common approach is to generate a “Declarative Base” class by subclassing the DeclarativeBase superclass.</p> 
<p><strong>装饰器</strong> The decorator form of mapping is useful when combining a SQLAlchemy declarative mapping with other class instrumentation systems such as dataclasses and attrs, though note that SQLAlchemy 2.0 now features dataclasses integration with Declarative Base classes as well.</p> 
<p></p> 
<p><a class="has-card" href="https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html" rel="nofollow" title="Table Configuration with Declarative"><span class="link-card-box"><span class="link-title">Table Configuration with Declarative</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/03/14/nXucfnh5_o.png" alt="icon-default.png?t=N7T8">https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html</span></span></a></p> 
<p>The <span style="color:#fe2c24;">mapped_column() 新特性 </span>construct, which features additional ORM-specific configuration capabilities not present in the plain <span style="color:#fe2c24;">Column 旧的也能用 </span>class, is then used within the class body to indicate columns in the table. </p> 
<p>each instance of mapped_column() will then be used to generate a Column object during this process, which will become part of the Table.columns collection of this Table object.</p> 
<p>mapped_column() supersedes the use of Column()<br> This ORM-specific construct is intended first and foremost to be a drop-in replacement for the use of Column within Declarative mappings only, adding new ORM-specific convenience features such as the ability to establish mapped_column.deferred within the construct, and most importantly to indicate to typing tools such as Mypy and Pylance an accurate representation of how the attribute will behave at runtime at both the class level as well as the instance level. </p> 
<p>Users of legacy code should be aware that the Column form will always work in Declarative in the same way it always has. The different forms of attribute mapping may also be mixed within a single mapping on an attribute by attribute basis, so migration to the new form can be at any pace. </p> 
<p></p> 
<p><a class="has-card" href="https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html" rel="nofollow" title="Relationship Loading Techniques — SQLAlchemy 2.0 Documentation"><span class="link-card-box"><span class="link-title">Relationship Loading Techniques — SQLAlchemy 2.0 Documentation</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/6d/2a/rbYGdvwN_o.png" alt="icon-default.png?t=N7T8">https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html</span></span></a></p> 
<p><span style="color:#fe2c24;">​多种方式控制对嵌套对象的加载</span> A big part of SQLAlchemy is providing a wide range of control over how related objects get loaded when querying. By “related objects” we refer to <span style="color:#fe2c24;">collections </span>or scalar associations configured on a mapper using <span style="color:#fe2c24;">relationship()</span>. This behavior can be configured at mapper construction time using <span style="background-color:#fff5e6;">the relationship.lazy parameter to the relationship() function <span style="color:#fe2c24;">静态写死</span></span>, as well as by using <span style="background-color:#edf6e8;">ORM loader options with the Select construct. <span style="color:#fe2c24;">动态</span></span></p> 
<h4 style="text-align:center;">三类方式</h4> 
<p><strong>Lazy loading 延迟加载-简单-加载列表小心</strong> refers to objects that are returned from a query without the related objects loaded at first. When the given collection or reference is first accessed on a particular object, <span style="background-color:#d4e9d5;">an additional SELECT statement is emitted</span> such that the requested collection is loaded.</p> 
<p><strong>Eager loading</strong> <strong>一次完成、按需加载 </strong>refers to objects returned from a query with the related collection or scalar reference <span style="background-color:#ffd7b9;">already loaded up front</span>. The ORM achieves this either by augmenting the SELECT statement it would normally emit with a JOIN to load in related rows simultaneously, or by emitting additional SELECT statements after the primary one to load collections or scalar references at once.</p> 
<p><strong>“No” loading</strong> refers to the disabling of loading on a given relationship, either that the attribute is empty and is just never loaded, or that it raises an error when it is accessed, in order to <span style="background-color:#dad5e9;">guard against unwanted lazy loads.</span></p> 
<h4 style="text-align:center;">细分方式</h4> 
<p><strong>lazy loading</strong> -  is the <span style="color:#fe2c24;">default loading style </span><span style="color:#38d8f0;">默认</span> for all relationship() constructs that don’t otherwise indicate the relationship.lazy option. </p> 
<p><strong>select IN loading</strong> -  assembles the primary key identifiers of the parent objects into an IN clause, so that <span style="color:#fe2c24;">all members of related collections</span> / scalar references are loaded<span style="color:#fe2c24;"> at once</span> <span style="color:#fe2c24;">by primary key</span>. <span style="color:#38d8f0;">貌似可以用来筛选relationship？</span></p> 
<p><strong>joined loading</strong> - this form of loading applies a JOIN to the given SELECT statement so that <span style="color:#fe2c24;">related rows are loaded in the same result set</span>. <span style="color:#38d8f0;">都给加载了啊</span></p> 
<p><strong>raise loading </strong>-  this form of loading is triggered at the same time a lazy load would normally occur, <span style="color:#fe2c24;">except it raises an ORM exception </span><span style="color:#38d8f0;">某些情况下会抛异常？</span> in order to guard against the application making unwanted lazy loads.</p> 
<p><strong>subquery loading</strong> - this form of loading emits a second SELECT statement which re-states the original query embedded inside of a subquery, then JOINs that subquery to the related table to be loaded to <span style="color:#fe2c24;">load all members</span> of related collections / scalar references <span style="color:#fe2c24;">at once</span>. </p> 
<p><strong>write only loading </strong>- This collection-only loader style produces an alternative attribute instrumentation that<span style="color:#fe2c24;"> never implicitly loads records from the database</span>, instead only allowing WriteOnlyCollection.add(), WriteOnlyCollection.add_all() and WriteOnlyCollection.remove() methods. Querying the collection is performed by invoking a SELECT statement which is constructed using the WriteOnlyCollection.select() method.</p> 
<p><strong>dynamic loading</strong> - This is a <span style="color:#38d8f0;">老东西</span> <span style="color:#fe2c24;">legacy collection-only loader style</span> which produces a Query object when the collection is accessed, allowing custom SQL to be emitted against the collection’s contents. However, dynamic loaders will implicitly iterate the underlying collection in various circumstances which<span style="color:#fe2c24;"> makes them less useful for managing truly large collections</span>. <span style="color:#fe2c24;">Dynamic loaders are superseded by “write only” collections </span><span style="color:#38d8f0;">用这个新的</span>, which will prevent the underlying collection from being implicitly loaded under any circumstances.</p> 
<p></p> 
<pre><code class="language-python"># 定义时
children: Mapped[List["Child"]] = relationship(lazy="selectin")

# 查询时
stmt = select(Parent).options(joinedload(Parent.children))</code></pre> 
<p>The loader options can also be “chained” using <strong>method chaining</strong> to specify how loading should occur further levels deep. <span style="color:#38d8f0;">层层深入</span>​​​​​​​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b40434bc4c84edce982d50040dd57ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">visualvm工具远程对linux服务器上的JVM虚拟机进行监控与调优方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91f77fd3a107d3aea069276079f1cb23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【华为OD机试 C卷】机器人仓库搬砖</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>