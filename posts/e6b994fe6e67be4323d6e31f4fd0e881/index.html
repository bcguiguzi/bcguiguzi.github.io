<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021 RoboCom 世界机器人开发者大赛-本科组（初赛） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021 RoboCom 世界机器人开发者大赛-本科组（初赛）" />
<meta property="og:description" content="编程题得分：100 总分：100
7-1 懂的都懂 (20分) 众所周知，在互联网上有很多话是不好直接说出来的，不过一些模糊的图片仍然能让网友看懂你在说什么。然而对这种言论依然一定要出重拳，所以请你实现一个简单的匹配算法。
现在我们采集了原图的一些特征数据，由 N 个小于 255 的非负整数组成，假设对于给定的若干张由 Mi​ 个同样小于 255 的非负整数组成的新图的特征数据，每个数据都可以由原图中任意四个不同数据的平均值计算而来，则称新图为原图的相似图片。对于给出的数据，请你判断是不是相似图片。
注意，不同数据指的并非是数据的值不同，而是不能取同一个数据多次。对于两个相同值的数据，如果给出两次，则可以取两次。
输入格式: 输入第一行是两个整数 N,K (1 ≤ N ≤ 50, 1 ≤ K ≤ 200)，表示采集的原图的特征数据个数和新图的张数。
接下来一行为 N 个小于 255 的非负整数，表示原图的特征数据。
最后的 K 行，每行第一个数是 Mi​ (1 ≤ Mi​ ≤ 200)，表示新图的特征数据个数。然后是 Mi​ 个小于 255 的非负整数，表示新图的特征数据。
输出格式: 对于每一张新图，如果为相似图片，则在一行中输出 Yes，否则输出 No。
输入样例: 5 3 4 8 12 20 40 3 11 16 19 3 12 16 19 10 11 11 11 11 11 11 11 11 11 11 输出样例: Yes No Yes 编译器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e6b994fe6e67be4323d6e31f4fd0e881/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-10T20:24:22+08:00" />
<meta property="article:modified_time" content="2023-07-10T20:24:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021 RoboCom 世界机器人开发者大赛-本科组（初赛）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>编程题得分：100 总分：100</p> 
<blockquote> 
 <h3 id="7-1%20%E6%87%82%E7%9A%84%E9%83%BD%E6%87%82%20(20%E5%88%86)">7-1 懂的都懂 (20分)</h3> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/67/fa/XvVQl2G0_o.jpg"></p> 
<p>众所周知，在互联网上有很多话是不好直接说出来的，不过一些模糊的图片仍然能让网友看懂你在说什么。然而对这种言论依然一定要出重拳，所以请你实现一个简单的匹配算法。</p> 
<p>现在我们采集了原图的一些特征数据，由 N 个小于 255 的非负整数组成，假设对于给定的若干张由 Mi​ 个同样小于 255 的非负整数组成的新图的特征数据，每个数据都可以由原图中任意四个不同数据的平均值计算而来，则称新图为原图的相似图片。对于给出的数据，请你判断是不是相似图片。</p> 
<p>注意，不同数据指的并非是数据的值不同，而是不能取同一个数据多次。对于两个相同值的数据，如果给出两次，则可以取两次。</p> 
<h4 id="输入格式">输入格式:</h4> 
<p>输入第一行是两个整数 N,K (1 ≤ N ≤ 50, 1 ≤ K ≤ 200)，表示采集的原图的特征数据个数和新图的张数。</p> 
<p>接下来一行为 N 个小于 255 的非负整数，表示原图的特征数据。</p> 
<p>最后的 K 行，每行第一个数是 Mi​ (1 ≤ Mi​ ≤ 200)，表示新图的特征数据个数。然后是 Mi​ 个小于 255 的非负整数，表示新图的特征数据。</p> 
<h4 id="输出格式">输出格式:</h4> 
<p>对于每一张新图，如果为相似图片，则在一行中输出 Yes，否则输出 No。</p> 
<h4 id="输入样例">输入样例:</h4> 
<pre><code>5 3
4 8 12 20 40
3 11 16 19
3 12 16 19
10 11 11 11 11 11 11 11 11 11 11
</code></pre> 
<h4 id="输出样例">输出样例:</h4> 
<pre><code>Yes
No
Yes
</code></pre> 
<p>编译器</p> 
<p>NO_COMPILER</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt; 
using namespace std;

int n, k, a[55], t;
int b;
bool tong[1500];

int main(){
	cin&gt;&gt;n&gt;&gt;k;
	for(int i = 1; i&lt;=n; ++i){
		scanf("%d", &amp;a[i]);
	}
	
	for(int i = 1; i&lt;=n; ++i)
	for(int j = i+1; j&lt;=n; ++j)
	for(int k = j+1; k&lt;=n; ++k)
	for(int p = k+1; p&lt;=n; ++p){
		tong[a[i]+a[j]+a[k]+a[p]] = 1;
	}
	
	while(k--){
		cin&gt;&gt;t;
		bool flag = 1;
		for(int i = 1; i&lt;=t; ++i){
			scanf("%d", &amp;b);
			if(tong[b*4] == 0)  flag = 0;
		}
		if(flag) cout&lt;&lt;"Yes"&lt;&lt;endl;
		else cout&lt;&lt;"No"&lt;&lt;endl;
	}

    return 0;
}</code></pre> 
<p>编译器输出</p> 
<pre>a.cpp: In function ‘int main()’:
a.cpp:12:8: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]
   scanf("%d", &amp;a[i]);
   ~~~~~^~~~~~~~~~~~~
a.cpp:26:9: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]
    scanf("%d", &amp;b);
    ~~~~~^~~~~~~~~~</pre> 
<table><thead><tr><th>测试点</th><th>结果</th><th>测试点得分</th><th>耗时</th><th>内存</th></tr></thead><tbody><tr><td>0</td><td>答案正确</td><td>10</td><td>4.00 ms</td><td>572 KB</td></tr><tr><td>1</td><td>答案正确</td><td>2</td><td>4.00 ms</td><td>728 KB</td></tr><tr><td>2</td><td>答案正确</td><td>1</td><td>4.00 ms</td><td>604 KB</td></tr><tr><td>3</td><td>答案正确</td><td>3</td><td>4.00 ms</td><td>568 KB</td></tr><tr><td>4</td><td>答案正确</td><td>4</td><td>8.00 ms</td><td>580 KB</td></tr></tbody></table> 
<p>评测结果 答案正确 (20 分)</p> 
<p></p> 
<blockquote> 
 <h3 id="7-2%20%E8%8A%AC%E5%85%B0%E6%9C%A8%E6%A3%8B%20(25%E5%88%86)">7-2 芬兰木棋 (25分)</h3> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3f/e2/jql0stkS_o.png"></p> 
<p>芬兰木棋（Mölkky，又称芬兰木柱）是源自芬兰的一项运动。哲哲将这个运动改造成了赛博朋克单人版，现在场上一开始有 N 根立起的小木棋（上面分别标有一个非负整数），哲哲投掷一根大木棋去击倒这些小木棋以获得分数。分数规则如下：</p> 
<ul><li>如果仅击倒 1 根木棋，则得木棋上的分数。</li><li>如果击倒 2 根或以上的木棋，则只得击倒根数的分数。（例如击倒 5 根，则得 5 分。）</li></ul> 
<p>哲哲固定站在 (0,0) 点上，四周放着若干个小木棋 (Xi​,Yi​)，坐标均为整数。每次哲哲可以朝一个方向扔出大木棋，大木棋会打倒这个方向上离哲哲最近的 k 个小木棋。哲哲游戏水平很高超，所以这个 k 可以自由控制。</p> 
<p>请问哲哲最多能拿多少分，在获得最多分数的情况下最少需要扔出多少次大木棋？</p> 
<p><em>规则与真实规则有较大出入，真实游玩时请以国际莫尔基组织的规则为准</em></p> 
<h4>输入格式:</h4> 
<p>输入第一行是一个正整数 N (1 ≤ N ≤ 105)，表示场上一开始有 N 个木棋。</p> 
<p>接下来 N 行，每行 3 个整数 Xi​,Yi​,Pi​，分别表示木棋放置在 (Xi​,Yi​)，木棋上的分数是 Pi​。坐标在 32 位整数范围内，分数为小于等于 1000 的正整数。</p> 
<p>保证 (0,0) 点没有木棋，也没有木棋重叠放置。</p> 
<h4>输出格式:</h4> 
<p>输出一行两个数，表示最多分数以及获得最多分数最少需要投掷大木棋多少次。</p> 
<h4>输入样例:</h4> 
<pre><code>11
1 2 2
2 4 3
3 6 4
-1 2 2
-2 4 3
-3 6 4
-1 -2 1
-2 -4 1
-3 -6 1
-4 -8 2
2 -1 999
</code></pre> 
<h4>输出样例:</h4> 
<pre><code>1022 9
</code></pre> 
<p>编译器</p> 
<p>NO_COMPILER</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt; 
#define int long long
using namespace std;

int n, c;
int ans, cnt;
double a, b;

int gcdd(int a, int b){
	if(b==0) return a;
	else return gcd(b, a%b);
}

struct node{
	int x;
	int y;
	double dist;
	int p;
}g[100005];

bool cmp(node x, node y){
	if(x.x != y.x) return x.x &lt; y.x;
	else{
		if(x.y != y.y) return x.y &lt; y.y;
		else if(x.dist != y.dist) return x.dist &lt; y.dist;
	}
}

signed main(){
	cin&gt;&gt;n;
	
	for(int i = 1; i&lt;=n; ++i){
		scanf("%lf %lf %lld", &amp;a, &amp;b, &amp;c);  //lf?f?
		g[i].dist = a*a + b*b;
		if(a &amp;&amp; b){
			int chu = gcdd(abs(a),abs(b));
			g[i].x = a/chu;
			g[i].y = b/chu;
		}
		if(a==0){
			g[i].x = 0;
			if(b&gt;0) g[i].y = 1;
			else g[i].y = -1;
		}
		if(b==0){
			if(a&gt;0) g[i].x = 1;
			else g[i].x = -1;
			g[i].y = 0;
		}
		g[i].p = c;
		ans += c;
	}
	
	sort(g+1, g+1+n, cmp);
	cnt = n;
	for(int i = 2; i&lt;=n; ++i){
//		cout&lt;&lt;g[i].dir&lt;&lt;" "&lt;&lt;g[i].k&lt;&lt;" "&lt;&lt;g[i].p&lt;&lt;endl;
		if(g[i-1].x == g[i].x &amp;&amp; g[i-1].y == g[i].y &amp;&amp; g[i-1].p == 1 &amp;&amp; g[i].p == 1) cnt--; 
	}
	
	cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;cnt;
    return 0;
}</code></pre> 
<p>编译器输出</p> 
<pre>a.cpp: In function ‘bool cmp(node, node)’:
a.cpp:27:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
a.cpp: In function ‘int main()’:
a.cpp:33:8: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]
   scanf("%lf %lf %lld", &amp;a, &amp;b, &amp;c);  //lf?f?
   ~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre> 
<table><thead><tr><th>测试点</th><th>结果</th><th>测试点得分</th><th>耗时</th><th>内存</th></tr></thead><tbody><tr><td>0</td><td>答案正确</td><td>12</td><td>4.00 ms</td><td>596 KB</td></tr><tr><td>1</td><td>答案正确</td><td>1</td><td>4.00 ms</td><td>452 KB</td></tr><tr><td>2</td><td>答案正确</td><td>1</td><td>4.00 ms</td><td>456 KB</td></tr><tr><td>3</td><td>答案正确</td><td>2</td><td>84.00 ms</td><td>6212 KB</td></tr><tr><td>4</td><td>答案正确</td><td>2</td><td>52.00 ms</td><td>5308 KB</td></tr><tr><td>5</td><td>答案正确</td><td>1</td><td>77.00 ms</td><td>6024 KB</td></tr><tr><td>6</td><td>答案正确</td><td>6</td><td>79.00 ms</td><td>5812 KB</td></tr></tbody></table> 
<p>评测结果 答案正确 (25 分)</p> 
<p></p> 
<blockquote> 
 <h3 id="7-3%20%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%20(25%E5%88%86)">7-3 打怪升级 (25分)</h3> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6c/e2/CSIgoxTW_o.jpg"></p> 
<p>很多游戏都有打怪升级的环节，玩家需要打败一系列怪兽去赢取成就和徽章。这里我们考虑一种简单的打怪升级游戏，游戏规则是，给定有 N 个堡垒的地图，堡垒之间有道路相连，每条道路上有一只怪兽把守。怪兽本身有能量，手里的武器有价值。打败怪兽需要的能量等于怪兽本身的能量，而怪兽一旦被打败，武器就归玩家所有 —— 当然缴获的武器价值越高，玩家就越开心。</p> 
<p>你的任务有两件：</p> 
<ul><li> 
  <ol><li>帮助玩家确定一个最合算的空降位置，即空降到地图中的某个堡垒，使得玩家从这个空降点出发，到攻下最难攻克（即耗费能量最多）的那个堡垒所需要的能量最小；</li></ol></li><li> 
  <ol><li>从这个空降点出发，帮助玩家找到攻克任意一个其想要攻克的堡垒的最省能量的路径。如果这种路径不唯一，则选择沿途缴获武器总价值最高的解，题目保证这种解是唯一的。</li></ol></li></ul> 
<h4>输入格式:</h4> 
<p>输入第一行给出两个正整数 N (≤1000) 和 M，其中 N 是堡垒总数，M 是怪兽总数。为简单起见，我们将堡垒从 1 到 N 编号。随后 M 行，第 i 行给出了第 i 只怪兽的信息，格式如下：</p> 
<pre><code>B1 B2 怪兽能量 武器价值
</code></pre> 
<p>其中 <code>B1</code> 和 <code>B2</code> 是怪兽把守的道路两端的堡垒编号。题目保证每对堡垒之间只有一只怪兽把守，并且 <code>怪兽能量</code> 和 <code>武器价值</code> 都是不超过 100 的正整数。</p> 
<p>再后面是一个正整数 K（≤N）和玩家想要攻克的 K 个目标堡垒的编号。</p> 
<h4>输出格式:</h4> 
<p>首先在一行中输出玩家空降的堡垒编号 <code>B0</code>。如果有多种可能，则输出编号最小的那个。</p> 
<p>随后依次为玩家想要攻克的每个堡垒 <code>B</code> 推荐最省能量的攻克路径，并列出需要耗费的能量值和沿途缴获武器的总价值。注意如果最省力的路径不唯一，则选择沿途缴获武器总价值最高的解。格式为：</p> 
<pre><code>B0-&gt;途经堡垒1-&gt;...-&gt;B
总耗费能量 武器总价值
</code></pre> 
<h4>输入样例:</h4> 
<pre><code>6 12
1 2 10 5
2 3 16 20
3 1 4 2
2 4 20 22
4 5 2 2
5 3 12 6
4 6 8 5
6 5 10 5
6 1 20 25
1 5 8 5
2 5 2 1
2 6 8 5
4
2 3 6 5

</code></pre> 
<h4>输出样例:</h4> 
<pre><code>5
5-&gt;2
2 1
5-&gt;1-&gt;3
12 7
5-&gt;4-&gt;6
10 7
5
0 0

</code></pre> 
<p>编译器</p> 
<p>NO_COMPILER</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt; 
using namespace std;
 
int n, m, a, b, c, d, q, p;
int f[1005][1005];
 
const int N = 2000000;
int ne[N], w[N], ww[N], e[N], h[N], idx, dist[1005];
bool st[1005];
 
struct node{
	int distance, power, name;
};
 
struct cmp{
	bool operator() (node x, node y){
		if(x.distance != y.distance) return x.distance &gt; y.distance;
		else{
			if(x.power != y.power) return x.power &lt; y.power;
			else return x.name &lt; y.name;
		} 
	}
}; 
 
int pre[1005];//难点1
int pw[1005];//难点2 
 
void add(int a, int b, int c, int d){
	e[idx] = b, w[idx] = c, ww[idx] = d, ne[idx] = h[a], h[a] = idx++;
}
 
void dijk(int s){
	priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; heap;
	heap.push({0, 0, s});
	dist[s] = 0;
	while(heap.size()){
		node head = heap.top();
		heap.pop();
		int ver = head.name, distance = head.distance, power = head.power;
		if(st[ver]) continue;
		st[ver] = 1;
		
		for(int i = h[ver]; i!=-1; i = ne[i]){
			int j = e[i];
			if(distance + w[i] &lt; dist[j]){
				pre[j] = ver;
				dist[j] = distance + w[i];
				pw[j] = power + ww[i];
				heap.push({dist[j], pw[j], j});
			}
			else if(distance + w[i] == dist[j]){
				if(power + ww[i] &gt; pw[j]){
					pre[j] = ver;
					dist[j] = distance + w[i];
					pw[j] = power + ww[i];
					heap.push({dist[j], pw[j], j});
				}
			}
		}
	}
//	cout&lt;&lt;"debug";
}
 
int main(){
	memset(h, -1, sizeof h);
	memset(dist, 127, sizeof dist);
	
	cin&gt;&gt;n&gt;&gt;m;
	memset(f, 63, sizeof f);
	for(int i = 1; i&lt;=m; ++i){
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
		f[a][b] = c;
		f[b][a] = c;
		add(a,b,c,d);
		add(b,a,c,d);
	}
 
	for(int k = 1; k&lt;=n; ++k)
		for(int i = 1; i&lt;=n; ++i)
			for(int j = 1; j&lt;=n; ++j)
				f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
 
	int ans1 = 0;
	int ans1max = 100000000;
	for(int i = 1; i&lt;=n; ++i){
		int curmax = 0;
		for(int j = 1; j&lt;=n; ++j){
			curmax = max(curmax, f[i][j]);
		}
		if(curmax&lt;ans1max){
			ans1 = i;
			ans1max = curmax;
		}
	}
	cout&lt;&lt;ans1&lt;&lt;endl;
 
	dijk(ans1);
	cin&gt;&gt;q;
	for(int i = 1; i&lt;=q; ++i){
		cin&gt;&gt;p;
		vector&lt;int&gt; ans2;
		
		int cur = p;
		while(cur!=ans1){
			ans2.push_back(cur);
			cur = pre[cur];
		}
		ans2.push_back(ans1);
		
		for(int i = ans2.size()-1; i&gt;=0; --i){
			cout&lt;&lt;ans2[i];
			if(i!=0) cout&lt;&lt;"-&gt;";
		}
		cout&lt;&lt;"\n";		
		
		cout&lt;&lt;dist[p]&lt;&lt;" "&lt;&lt;pw[p]&lt;&lt;endl;
	}
 
    return 0;
}</code></pre> 
<p>编译器输出</p> 
<pre></pre> 
<table><thead><tr><th>测试点</th><th>结果</th><th>测试点得分</th><th>耗时</th><th>内存</th></tr></thead><tbody><tr><td>0</td><td>答案正确</td><td>13</td><td>12.00 ms</td><td>12348 KB</td></tr><tr><td>1</td><td>答案正确</td><td>5</td><td>12.00 ms</td><td>12228 KB</td></tr><tr><td>2</td><td>答案正确</td><td>1</td><td>12.00 ms</td><td>12352 KB</td></tr><tr><td>3</td><td>答案正确</td><td>2</td><td>813.00 ms</td><td>12392 KB</td></tr><tr><td>4</td><td>答案正确</td><td>4</td><td>1154.00 ms</td><td>30820 KB</td></tr></tbody></table> 
<p>评测结果 答案正确 (25 分)</p> 
<p></p> 
<blockquote> 
 <h3 id="7-4%20%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%20(30%E5%88%86)">7-4 疫情防控 (30分)</h3> 
</blockquote> 
<p>疫情尚未结束，严防疫情反复。为了做好疫情防控工作，国内设置了地区风险等级，对于中高风险地区的人员采取限制移动、居家隔离等手段。</p> 
<p>为了研究疫情防控对于跨地区交通运输的影响，假设现在有 N 个机场，M 条航线，每天都会新增一个防控地区，一个防控地区会导致一个机场无法正常运作，航线也自然无法正常运行，每天会有 Qi​ 对旅客从 Xi​ 机场前往 Yi​ 机场，请计算有多少对旅客会受到影响无法完成行程。</p> 
<p>旅客只要能直达或通过若干次中转，且乘坐的所有航线的出发和到达机场都正常运作，即视作可完成行程。</p> 
<h4>输入格式:</h4> 
<p>输入第一行是三个整数 N,M,D (1≤N≤5×104, 1≤M≤2×105, 1≤D≤103), 表示机场数、航线数以及新增防控地区的天数。</p> 
<p>接下来首先有 M 行，每行给出空格分隔的两个数字 A 和 B，表示编号为 A 和 B 的机场之间有一条航线。航线是双向的，机场编号从 1 到 N。</p> 
<p>然后是 D 块输入，每块输入内第一行为空格分隔的两个整数 C 和 Q （1≤Q≤103)，表示新增机场编号为 C 所在的城市为防控地区，今天有 Q 段行程。数据保证新增的城市之前一定不是防控地区。</p> 
<p>接下来的 Q 行，每行是空格分隔的两个数字 X 和 Y，表示编号为 X 和 Y 的机场的一段行程。行程有可能包括之前就已经成为防控地区的城市。</p> 
<h4>输出格式:</h4> 
<p>对于每天的询问，请在一行中输出在新增了一个防控地区后当天的行程有多少不能成行。</p> 
<h4>输入样例:</h4> 
<pre><code>5 5 3
1 2
1 3
1 5
2 5
3 4
4 3
1 3
1 4
2 3
5 3
3 4
2 3
3 5
1 3
2 3
2 5
3 4
</code></pre> 
<h4>输出样例:</h4> 
<pre><code>1
2
3
</code></pre> 
<p>编译器</p> 
<p>NO_COMPILER</p> 
<p>代码</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt; 
using namespace std;
 
bool openn[400005];//第i个地点是开通的 
int n, m, d, a[400005], b[400005];//a b放的是地点 
int c[400005], q[400005], fa[400005], ans[1005];
int xx[1005][1005], yy[1005][1005];  //第i天第j次询问的地点的编号 
vector&lt;int&gt; nextt[50005];
 
int findd(int x){
	if(fa[x] == x) return x;
	else return fa[x] = findd(fa[x]);
}
 
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;//机场数、航线数以及新增防控地区的天数 
	for(int i = 1; i&lt;=n; ++i) openn[i] = 1;
	for(int i = 1; i&lt;=m; ++i){
		cin&gt;&gt;a[i]&gt;&gt;b[i];
		nextt[a[i]].push_back(b[i]);
		nextt[b[i]].push_back(a[i]);
	}
	
	for(int i = 1; i&lt;=d; ++i){
		cin&gt;&gt;c[i]&gt;&gt;q[i];
		for(int j = 1; j&lt;=q[i]; ++j)
			cin&gt;&gt;xx[i][j]&gt;&gt;yy[i][j];
		//close
		openn[c[i]] = 0;
	}
	
	for(int k = 1; k&lt;=n; ++k) fa[k] = k;
	
	//先连一次啊，别漏了啊
	for(int i = 1; i&lt;=m; ++i){
		if(openn[a[i]] &amp;&amp; openn[b[i]]) fa[findd(a[i])] = findd(b[i]);
	} 
	
	for(int i = d; i&gt;=1; --i){
		if(d!=i){
			//open &amp;&amp; unite
			int p1 = c[i+1];
			openn[p1] = 1;  //open
			for(int j = 0; j&lt;nextt[p1].size(); ++j){
				int p2 = nextt[p1][j];
//				cout&lt;&lt;"debug:"&lt;&lt;p1&lt;&lt;" "&lt;&lt;p2&lt;&lt;endl; 
				if( openn[ p2 ] ) 
					fa[findd(p1)] = findd(p2);
			}
		}
 
		//check
		int temp = 0;
		for(int j = 1; j&lt;=q[i]; ++j){
			if( findd(xx[i][j]) != findd(yy[i][j]) ) temp++;
		}
		ans[i] = temp;
	}
	for(int i = 1; i&lt;=d; ++i) cout&lt;&lt;ans[i]&lt;&lt;endl;
 
    return 0;
}</code></pre> 
<p>编译器输出</p> 
<pre>a.cpp: In function ‘int main()’:
a.cpp:48:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
    for(int j = 0; j&lt;nextt[p1].size(); ++j){
                   ~^~~~~~~~~~~~~~~~~</pre> 
<table><thead><tr><th>测试点</th><th>结果</th><th>测试点得分</th><th>耗时</th><th>内存</th></tr></thead><tbody><tr><td>0</td><td>答案正确</td><td>15</td><td>5.00 ms</td><td>1592 KB</td></tr><tr><td>1</td><td>答案正确</td><td>1</td><td>5.00 ms</td><td>1600 KB</td></tr><tr><td>2</td><td>答案正确</td><td>1</td><td>5.00 ms</td><td>1720 KB</td></tr><tr><td>3</td><td>答案正确</td><td>5</td><td>12.00 ms</td><td>2752 KB</td></tr><tr><td>4</td><td>答案正确</td><td>8</td><td>553.00 ms</td><td>28332 KB</td></tr></tbody></table> 
<p>评测结果 答案正确 (30 分)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6cd7047ada16c7833be1072945294f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">终端复用器——tmux实用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17d6b349a69822e00c9bd07b284db4a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】-vector的具体使用（迭代器失效问题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>