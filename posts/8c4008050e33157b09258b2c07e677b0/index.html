<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3.0——监听属性、Vue3生命周期函数、Teleport、属性传值、自定义事件、状态驱动的动态 CSS、注册组件、异步组件、占位组件 Suspense - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3.0——监听属性、Vue3生命周期函数、Teleport、属性传值、自定义事件、状态驱动的动态 CSS、注册组件、异步组件、占位组件 Suspense" />
<meta property="og:description" content="一、监听属性-watch 与vue2.x中的watch配置功能一致
注意
监视reactive定义的响应式数据时，oldvalue无法正确获取，强制开始了深度监视（deep的配置失效）
监视reactive定义的响应式数据的某一个值时：deep配置有效
1.监听ref定义的响应式数据 示例：
&lt;script setup&gt; import { ref, reactive, watch } from &#34;vue&#34;; //监听一个数据 let msg = ref(&#34;今天星期二&#34;); function changemsg() { msg.value = &#34;Today is Tuesday&#34;; } watch(msg, (newv, oldv) =&gt; { console.log(newv, oldv, &#34;msg发生了变化&#34;); }); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;button @click=&#34;changemsg&#34;&gt;change-msg&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; 结果显示：
2.监听reactive定义的一个响应式数据的全部属性 示例：
&lt;script setup&gt; import { reactive, watch } from &#34;vue&#34;; let user = reactive({name: &#34;haha&#34;,age: 21,shopping: { cloth: 2, shooes: 1 }}); watch(user, function(newv, oldv) { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8c4008050e33157b09258b2c07e677b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-20T22:49:22+08:00" />
<meta property="article:modified_time" content="2022-09-20T22:49:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3.0——监听属性、Vue3生命周期函数、Teleport、属性传值、自定义事件、状态驱动的动态 CSS、注册组件、异步组件、占位组件 Suspense</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、监听属性-watch</h2> 
<ul><li> <p>与vue2.x中的watch配置功能一致</p> </li><li> <p>注意</p> 
  <ul><li> <p>监视reactive定义的响应式数据时，oldvalue无法正确获取，强制开始了深度监视（deep的配置失效）</p> </li><li> <p>监视reactive定义的响应式数据的某一个值时：deep配置有效</p> </li></ul></li></ul> 
<h4>1.监听ref定义的响应式数据</h4> 
<p>  示例：</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
import { ref, reactive, watch } from "vue";

//监听一个数据
let msg = ref("今天星期二");
function changemsg() {
  msg.value = "Today is Tuesday";
}
watch(msg, (newv, oldv) =&gt; {
  console.log(newv, oldv, "msg发生了变化");
});

&lt;/script&gt;
  
  &lt;template&gt;
      &lt;div&gt;
       &lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;
       &lt;button @click="changemsg"&gt;change-msg&lt;/button&gt;
      &lt;/div&gt;   
  &lt;/template&gt;</code></pre> 
<p>  结果显示：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/e7/e8/IeDOZel4_o.png" width="1062"></p> 
<h4>2.监听reactive定义的一个响应式数据的全部属性</h4> 
<p>  示例：</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
import { reactive, watch } from "vue";

let user = reactive({name: "haha",age: 21,shopping: { cloth: 2, shooes: 1 }});
watch(user, function(newv, oldv) {
  console.log("修改了name/age/shopping属性");
  console.log(newv, oldv);
});
function changecloth() {
  user.shopping.cloth = 3;
}
function changeshopping() {
  user.shopping="no-shopping";
}
function changename() {
  user.name = "xixi";
}
function changeage() {
  user.age = 21;
  console.log("点击了changeage按钮,修改了age,但是没有触发watch")
}
&lt;/script&gt;
      
      &lt;template&gt;
          &lt;div class="box1"&gt;
            &lt;p&gt;{<!-- -->{user}}&lt;/p&gt;
            &lt;button @click="changecloth"&gt;changecloth&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;
            &lt;button @click="changeshopping"&gt;changeshopping&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;
            &lt;button @click="changename"&gt;changename&lt;/button&gt;
            &lt;button @click="changeage"&gt;changeage&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;
          &lt;/div&gt;
      &lt;/template&gt;</code></pre> 
<p> 显示结果：</p> 
<p><img alt="" height="769" src="https://images2.imgbox.com/08/d7/Nrowg3Iy_o.png" width="1200"></p> 
<h2>二、Vue3生命周期</h2> 
<ul><li> <p>什么是生命周期？</p> <p>Vue中每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁、这就是一个组件所谓的生命中周期</p> </li><li> <p>Vue2.x中的生命周期</p> </li></ul> 
<blockquote> 
 <p>beforeCreate   created</p> 
 <p>beforeMount    mounted</p> 
 <p>beforeUpdate  updated</p> 
 <p>beforeDestroy  destroyed</p> 
 <p>activated    deactivated   errorCaptured</p> 
</blockquote> 
<ul><li> <p>Vue3.x的生命周期</p> <p>在Vue3.x中，新增了一个setup生命周期函数，setup执行的时机是在beforeCreate之前，因为在这个函数中不能通过this来获取实例的；同时为了命名的统一，将beforeDestory改名为beforeUnmount，destoryed改名为unmounted</p> </li></ul> 
<blockquote> 
 <p>beforeCreate  created（建议使用setup代替）</p> 
 <p>setup</p> 
 <p>beforeMount     mounted</p> 
 <p>beforeUpdate   updated</p> 
 <p>beforeUnmount   unmounted</p> 
</blockquote> 
<ul><li> <p><strong>vue3</strong>新增了<strong>生命周期钩子</strong>，我们可以通过在<strong>生命周期函数</strong>前加<strong>on</strong>来访问组件的生命周期</p> <p><strong>Composition API 形式的生命周期钩子</strong></p> </li></ul> 
<blockquote> 
 <p>onBeforeMount  onMounted</p> 
 <p>onBeforeUpdate onUpdated</p> 
 <p>onBeforeUnmount onUnmounted</p> 
 <p>onErrorCaptured onRenderTracked onRenderTriggered</p> 
</blockquote> 
<p>  示例：</p> 
<p>  App.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
import {onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,ref} from "vue"
import Box from "./Box.vue";

   let msg =ref("哈哈");
    function changemsg() {
      msg.value = "修改了msg,更新了页面";
    }
  onBeforeMount(function() {
		console.log("beforeMount--app组件挂载前执行")
	})
	onMounted(function() {
		console.log("onMounted--app组件挂载了以后执行")
	})
  onBeforeUpdate(function() {
		console.log("onBeforeUpdate--app组件更新前执行")
	})
	onUpdated(function(){
		console.log("onUpdated--app组件更新以后执行")
	})
	onBeforeUnmount(function() {
		console.log("onBeforeUnmount--app组件销毁前执行")
	})
  onUnmounted(function() {
		console.log("onUnmounted--app组件销毁了以后执行")
	})
&lt;/script&gt;

&lt;template&gt;
	&lt;div class="app"&gt;
       &lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;
       &lt;button @click="changemsg"&gt;修改app的msg&lt;/button&gt;
       &lt;Box&gt;&lt;/Box&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  Box.vue</p> 
<pre><code class="language-javascript">&lt;script&gt;
  import {onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,ref} from 'vue'
   
  export default {
    setup () {
      onBeforeMount (() =&gt; {console.log("触发了beforeMount")})
      onMounted (() =&gt; {console.log("触发了mounted")})
      onBeforeUpdate (() =&gt; {console.log("触发了beforeUpdate")}) 
      onUpdated (() =&gt; {console.log("触发了updated")}) 
      onBeforeUnmount (() =&gt; {console.log("触发了beforeDestroy")}) 
      onUnmounted (() =&gt; {console.log("触发了destroyed")})
      let msg =ref("嘻嘻");
       function changemsg() {
          msg.value = "修改了msg,更新了页面"
       }
      return {msg,changemsg}
    }
  }
  &lt;/script&gt;
     
&lt;template&gt;
	&lt;div class="box"&gt;
     &lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;
     &lt;button @click="changemsg"&gt;修改box的msg&lt;/button&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  显示结果：</p> 
<p><img alt="" height="630" src="https://images2.imgbox.com/36/b5/LRnh44rg_o.png" width="937"></p> 
<h2> 三、Teleport</h2> 
<ul><li>Vue 鼓励我们通过将 UI 和相关行为封装到组件中来构建 UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。</li><li>然而，有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置</li><li>to属性：放到指定位置</li></ul> 
<p>  示例：</p> 
<p>  App.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
  import Box from "./Box.vue"
&lt;/script&gt;

&lt;template&gt;
	&lt;div class="app"&gt;
    &lt;h1&gt;app&lt;/h1&gt;
        &lt;Box&gt;&lt;/Box&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  Box.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
  import {ref} from "vue"
  let msg=ref("haha")
  let changemsg=()=&gt;{
    msg.value="xixi"
  }
&lt;/script&gt; 
  
  &lt;template&gt;
    &lt;div&gt;
      &lt;h2&gt;box&lt;/h2&gt;
      &lt;teleport to="body"&gt;
        &lt;div&gt;
          &lt;p @click="changemsg"&gt;{<!-- -->{msg}}&lt;/p&gt;
          &lt;button @click="changemsg"&gt;change-msg&lt;/button&gt;
        &lt;/div&gt;
      &lt;/teleport&gt;
    &lt;/div&gt;
  &lt;/template&gt;</code></pre> 
<p>  显示结果：</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/5a/8f/laThK6lt_o.png" width="984"></p> 
<h2>四、 属性传值</h2> 
<p>  示例：</p> 
<p>  App.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
  import Box from "./Box.vue"
  let haha="哈哈"
&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;	
      &lt;Box :name="haha" :age=21 @myclick="fn"&gt;&lt;/Box&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  Box.vue</p> 
<pre><code class="language-javascript">&lt;script&gt;
  export default {
     props:["name","age"],
     setup(props){
         let fn=()=&gt;{console.log(props)}//必须在组件中注册属性不然setup函数收不到数据
         return {fn}
     }    
  }
&lt;/script&gt;
&lt;template&gt;
    &lt;div&gt;
       &lt;p&gt;{<!-- -->{name}}:{<!-- -->{age}}&lt;/p&gt;
        &lt;button @click="fn"&gt;look&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  结果显示：</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/3d/62/MQJIE88k_o.png" width="482"></p> 
<h2> 五、自定义事件</h2> 
<ul><li> <p>事件名</p> <p>事件名提供了自动的大小写转换即如果在子组件中触发一个以 camelCase (驼峰式命名) 命名的事件，可以在父组件中添加一个 kebab-case (短横线分隔命名) 的监听器</p> </li></ul> 
<p>  示例：</p> 
<p>  App.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
  import MyBox from "./MyBox.vue"
  function mysum(arg1,arg2){
		let sum=arg1+arg2
    console.log(sum)
	}
&lt;/script&gt;

&lt;template&gt;
	&lt;div&gt;	
	    &lt;h1&gt;app&lt;/h1&gt;
		  &lt;my-box @my-click="mysum"&gt;&lt;/my-box&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>  MyBox.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
	import {ref,watch,defineEmits} from "vue"
	let count=ref(1)
	let fm=()=&gt;{
		count.value++
	}
	let emit=defineEmits()
	watch(count,(v)=&gt;{
		if(v==3){
        //触发自定义事件的同时给父组件传值
		   	emit("myClick",5,10)
		}
	})
&lt;/script&gt;

&lt;template&gt;
	&lt;div class="box"&gt;
		&lt;p&gt;{<!-- -->{count}}&lt;/p&gt;
		&lt;button @click="fm"&gt;点两下打印结果&lt;/button&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>结果显示：</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/7b/2b/mwiFdnxU_o.png" width="866"></p> 
<h2> 六、状态驱动的动态 CSS</h2> 
<ul><li>单文件组件的 <code>&lt;style&gt;</code> 标签可以通过 <code>v-bind</code> 这一 CSS 函数将 CSS 的值关联到动态的组件状态上</li></ul> 
<p>  示例：</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
	import {ref} from "vue"
	
	let color = ref("lightpink")
	let ishow=ref("block")
	let flag=0
	let change=()=&gt;{
		if(flag==0){
			color.value="lightblue"
		    ishow.value="none"
			flag=1
		}else{
			color.value="lightpink"
		    ishow.value="block"
			flag=0
		}
	}	
&lt;/script&gt;
&lt;template&gt;
	&lt;div&gt;
		&lt;h1 class="box1"&gt;我出现啦&lt;/h1&gt;
		&lt;button @click="change"&gt;点击切换显隐&lt;/button&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped lang="scss"&gt;
	.box1 {
		color: v-bind(color);
		display: v-bind(ishow);
	}
&lt;/style&gt;</code></pre> 
<p>  结果显示：</p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/8e/d3/exauwQQ2_o.png" width="1146"></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/0c/fd/TV0M2dci_o.png" width="1084"></p> 
<h2> 七、注册组件</h2> 
<h3>  1.组件内部注册：</h3> 
<pre><code class="language-javascript">&lt;script&gt;
    import Box1 from "./Box1.vue"
    export defult{
        components:{
            Box1
        },
        setup(){}
    }
&lt;/script&gt;
&lt;template&gt;
    &lt;Box1&gt;&lt;/Box1&gt;	
&lt; /template&gt;</code></pre> 
<h3>  2.vue3组件内部组合式API setup语法糖中注册组件</h3> 
<pre><code class="language-javascript">&lt;script setup&gt;
    import Box1 from "./Box1.vue"  
    //只需要导入 不用写注册代码  会在打包的时候自动帮我们注册 
&lt;/script&gt;
&lt;template&gt;
    &lt;Box1&gt;&lt;/Box1&gt;   
&lt;/template&gt;</code></pre> 
<h3>  3.注册全局组件</h3> 
<pre><code class="language-javascript">//main.js文件:
import { createApp} from 'vue'
import App from './App.vue'
const app=createApp(App)
​
import Box1 from "./Box1.vue"
app.component(Box1.name,Box1)
​
app.mount('#app')//注意 一定要在app.mount之前注册全局组件 否则使用不了
​
//App.vue文件:
&lt;template&gt;
    &lt;Box1&gt;&lt;/Box1&gt;   
&lt; /template&gt;</code></pre> 
<h3>  4.定义同步组件:</h3> 
<pre><code class="language-javascript">//Box1.vue文件:
&lt;script&gt;
  import {defineComponent} from "vue"
  export default defineComponent({
        data(){
            return {}
        },
        methods:{},     
        setup(){
        }       
    });
&lt;/script&gt;</code></pre> 
<h3>  5.定义异步组件:</h3> 
<h4>  （1）局部异步组件</h4> 
<p> <strong>     组件内部：</strong></p> 
<pre><code class="language-javascript">&lt;script&gt;
    import {defineAsyncComponent} from "vue"
    let Box1 = defineAsyncComponent(() =&gt; import("./Box1.vue")) 
    //注意3.2之后不用引入defineAsyncComponent
    export default {
        components: {
            Box1
        },
        setup() {}
    }
&lt;/script&gt;</code></pre> 
<p>    <strong> setup语法糖：</strong></p> 
<pre><code class="language-javascript">&lt;script setup&gt;
    import {defineAsyncComponent} from "vue"
    let Box3=defineAsyncComponent(()=&gt;import("./Box3.vue"))
   //注意3.2之后不用引入defineAsyncComponent,而且这个变量名直接就是注册的组件名(打包时自动注册的)
&lt;/script&gt;</code></pre> 
<h4> （2）全局异步组件</h4> 
<pre><code class="language-javascript">//main.js文件:
import { createApp,defineAsyncComponent} from 'vue'
import App from './App.vue'
const app=createApp(App)
let Box1=defineAsyncComponent(()=&gt;import("./Box1.vue"))
app.component("Box1",Box1)
//注意 一定要在app.mount之前注册全局组件 否则使用不了
app.mount('#app')</code></pre> 
<h2>八、占位组件Suspense</h2> 
<ul><li> <p>等待异步组件时渲染一些额外的内容,让应用有更好的用户体验</p> <p><code>&lt;suspense&gt;</code> 组件有两个插槽。它们都只接收一个直接子节点。</p> </li><li> <p><code>default</code> 插槽里的节点会尽可能展示出来。如果不能，则展示 <code>fallback</code> 插槽里的节点。</p> </li></ul> 
<p>  示例：</p> 
<p>   App.vue</p> 
<pre><code class="language-javascript">&lt;script setup&gt;
  import Box1 from "./Box1.vue"
  import Box2 from "./Box2.vue"
  import {defineAsyncComponent} from "vue"
  let Box3=defineAsyncComponent(()=&gt;import("./Box3.vue"))

&lt;/script&gt;
&lt;template&gt;
&lt;div&gt;
  &lt;Box1&gt;&lt;/Box1&gt;
  &lt;Box2&gt;&lt;/Box2&gt;
  &lt;suspense&gt;
    &lt;template #default&gt;
      &lt;Box3&gt;&lt;/Box3&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;div&gt;loading....&lt;/div&gt;
    &lt;/template&gt;
  &lt;/suspense&gt;
  &lt;Box4&gt;&lt;/Box4&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre> 
<p>   Box2.vue</p> 
<pre><code class="language-javascript">&lt;template&gt;
	&lt;div&gt;
		&lt;h3&gt;box2&lt;/h3&gt;
		&lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,defineComponent} from "vue"
	let Box2=defineComponent({		
		setup(){
			let msg=ref("box2--msg")
			return {msg}
		}		
	})
	export default Box2;
&lt;/script&gt;</code></pre> 
<p>   Box3.vue</p> 
<pre><code class="language-javascript">&lt;template&gt;
	&lt;div&gt;
		&lt;h3&gt;加载box3&lt;/h3&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p><img alt="" height="258" src="https://images2.imgbox.com/78/0b/YbpWqWph_o.png" width="790"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/411487221e5272b3addfb0a0a3baeb00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Widget</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f55faba15c35477e3dad15f80e78010/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python虚拟机安装教程,虚拟机运行python文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>