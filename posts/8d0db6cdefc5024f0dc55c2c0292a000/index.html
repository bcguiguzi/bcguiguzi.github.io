<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础知识归纳(4)-杂记&#43;补充 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础知识归纳(4)-杂记&#43;补充" />
<meta property="og:description" content=" 一些小知识点 输出数组内容 a[1]=*(a&#43;1)=*(1&#43;a)=1[a] cout&lt;&lt;1[a];//也可以 堆的大小是没有限制的，而栈有，一般为8MB，因此不宜在线程中嵌套太深的函数或太大的局部变量。结构体变量占用的内存并不是各部分相加，而是必须是其中最大数据类型的整数倍，目的是为地址对齐，提高读写速度。C&#43;&#43;中使用多态时，不要使用派生类给父类初始化，否则会导致对象切断。每个派生类都调用自己直接基类的构造函数，但最终派生类的构造函数负责调用虚基类的构造函数，可以不是直接基类！（一般每个类都由自己的构造函数构造，但虚基类由最终派生类负责构造）。所有虚基类都由最终派生类的构造函数初始化，如果创建了最终派生类对象，那么将忽略通过子对象的构造函数对虚基类的现有调用。友元函数可以访问类中所有数据！友元关系不可以传递。 顶层const:不可使用*p更改内容；底层const：不可改变p指向，但可以改变*p内容 静态成员函数不可以调用非静态成员函数，但可以调用构造函数； 在c&#43;&#43;中，由于面向对象的思维，它与C语言中的作用有一些不同，有了类中静态成员的说法。静态成员不属于对象，而属于类。不创建对象也可调用。从代码形式上来说没有任何区别。普通类成员函数与静态成员函数的区别在于普通成员函数有一个隐藏的调用参数（this）指针。所以就是说静态成员函数没有对象也可调用。
对类的静态和非静态函数的不同的调用要求决定了它们在使用上的方便程度：
非静态成员函数要通过对象调用，所以要求首先建立一个对象；而静态成员函数可不建立对象就可以被使用。一般对象也可以调用静态成员函数；
另外，如果类的成员函数想作为回调函数来使用，一般情况下只能将它定义为静态成员才行。
decltype : 对出现过的数据推断类型，用于声明新变量 Decltype(preNum) newNum; 使用静态函数/静态变量的好处
1.限定作用域在本文件
2.不会与其他文件中的函数名称冲突 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。 使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。
函数指针 ：double (*fac)(int a,int b) : 相比函数多个括号用户空间和内核空间
32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0-3G是用户态空间，3-4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分为：3G用户空间和1G内核空间使用引用传参时，也可以触发多态，但不可以给基类取派生类的别名；
形参为基类引用，可以传递派生类实参；但反之不行；编译阶段分为编译是读取源程序(字符流)，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码;一个初始化的奇葩方法
判断小数相等 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8d0db6cdefc5024f0dc55c2c0292a000/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-09T16:20:49+08:00" />
<meta property="article:modified_time" content="2021-01-09T16:20:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础知识归纳(4)-杂记&#43;补充</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>一些小知识点</h4> 
<ul><li>输出数组内容</li></ul> 
<pre><code class="prism language-cpp">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>
cout<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//也可以</span>
</code></pre> 
<ul><li>堆的大小是没有限制的，而栈有，一般为8MB，因此不宜在线程中嵌套太深的函数或太大的局部变量。</li><li>结构体变量占用的内存并不是各部分相加，而是必须是其中最大数据类型的整数倍，目的是为地址对齐，提高读写速度。</li><li>C++中使用多态时，不要使用派生类给父类初始化，否则会导致对象切断。</li><li>每个派生类都调用自己直接基类的构造函数，<strong>但最终派生类的构造函数负责调用虚基类的构造函数，可以不是直接基类</strong>！（一般每个类都由自己的构造函数构造，但虚基类由最终派生类负责构造）。所有虚基类都由最终派生类的构造函数初始化，如果创建了最终派生类对象，那么将忽略通过子对象的构造函数对虚基类的现有调用。</li><li>友元函数可以访问类中所有数据！友元关系不可以传递。</li></ul> 
<blockquote> 
 <ul><li>顶层const:不可使用*p更改内容；</li><li>底层const：不可改变p指向，但可以改变*p内容</li></ul> 
</blockquote> 
<ul><li>静态成员函数不可以调用非静态成员函数，但可以调用构造函数；</li></ul> 
<blockquote> 
 <p>在c++中，由于面向对象的思维，它与C语言中的作用有一些不同，有了类中静态成员的说法。静态成员不属于对象，而属于类。不创建对象也可调用。从代码形式上来说没有任何区别。普通类成员函数与静态成员函数的区别在于普通成员函数有一个隐藏的调用参数（this）指针。所以就是说静态成员函数没有对象也可调用。</p> 
</blockquote> 
<blockquote> 
 <p>对类的静态和非静态函数的不同的调用要求决定了它们在使用上的方便程度：<br> 非静态成员函数要通过对象调用，所以要求首先建立一个对象；而静态成员函数可不建立对象就可以被使用。一般对象也可以调用静态成员函数；<br> 另外，如果类的成员函数想作为回调函数来使用，一般情况下只能将它定义为静态成员才行。</p> 
</blockquote> 
<ul><li>decltype : 对出现过的数据推断类型，用于声明新变量</li></ul> 
<pre><code class="prism language-cpp"><span class="token function">Decltype</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span> newNum<span class="token punctuation">;</span>
</code></pre> 
<ul><li>使用静态函数/静态变量的好处<br> 1.限定作用域在本文件<br> 2.不会与其他文件中的函数名称冲突</li></ul> 
<blockquote> 
 <p>静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。</p> 
</blockquote> 
<blockquote> 
 <p>关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。 使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。</p> 
</blockquote> 
<ul><li>函数指针 ：double (*fac)(int a,int b) : 相比函数多个括号</li><li>用户空间和内核空间<br> 32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0-3G是用户态空间，3-4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分为：3G用户空间和1G内核空间</li><li>使用引用传参时，也可以触发多态，但不可以给基类取派生类的别名；<br> 形参为基类引用，可以传递派生类实参；但反之不行；</li><li>编译阶段分为编译是读取源程序(字符流)，<strong>对之进行词法和语法的分析</strong>，将高级语言指令转换为功能等效的汇编代码;</li><li>一个初始化的奇葩方法<br> <img src="https://images2.imgbox.com/86/ec/wUCI8wfb_o.png" alt="在这里插入图片描述"></li><li>判断小数相等<img src="https://images2.imgbox.com/b6/e4/PcnpfSj4_o.png" alt="在这里插入图片描述"></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe58aa98c7ca29e3d8d88cfc2a9ea0b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三菱凌云3故障代码_三菱-菱云系列电梯故障代码表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/adbb08c787bef6b37f0a8a27dcb15d0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keras保存加载模型报错“AttributeError: ‘str‘ object has no attribute ‘decode‘”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>