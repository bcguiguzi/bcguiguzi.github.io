<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>git 进阶系列教程--add - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="git 进阶系列教程--add" />
<meta property="og:description" content="git add ---- 将工作区内容放入暂存区 功能介绍 将工作区(working directory)中的内容放入暂存区(staging area)追踪文件(解释：刚被添加到工作区的文件处于未跟踪状态(Untracked files),该命令会将新添加的文件放入暂存区，并且文件将处于已跟踪状态) 命令解析 git add . 添加工作区所有文件进入暂存区
最后的点可以理解为正则里的通配符，git add后面添加的是可以为任意合法的路径。
比如：a.txt、/b.txt、*.txt、a/b.txt…
git add --all 这个命令和git add .命令很像。都是添加工作区所有文件进入暂存区。但是区别还是有的。
区别一：在git的2.0版本之前，git add .只会添加修改的文件、创建的文件。但是，如果你删除了一个文件，这个命令运行后，不会记录你删除了这个文件。以至于，如果你从暂存区恢复所有文件时，删除的文件还会出现在工作区，或者是提交代码后，被删除的文件依旧会在版本库中。所以你需要做其他的操作来办到删除功能，例如：git rm。但是git add --all命令会将所有结果一起放入暂存区（修改、创建、删除）。然后在git的2.0版本后，两者统一了。都是git add --all的效果了。
区别二：git add .命令认为是添加工作区所有文件进入暂存区，是因为我们在运行git命令时，通常是在项目的根目录。git add .的命令其实是提交当前目录的所有文件，而不是项目中的所有文件都提交。git add --all则是真正的将项目中的所有未忽略的文件添加到暂存区。
工作中，上面的这条命令能处理99%需要add命令的情况。下面的知识是为有好奇add命令还能做什么的同学准备的
git add -n . 这条命令多了一个选项：-n,是选项：--dry-run的简写形式 作用是：并不会将匹配到的文件真的添加到暂存区，而是查看一下是否存在文件还没被追踪或者是修改过但是未添加到暂存区。 回车后，会将没有追踪的文件或未添加到暂存区的文件显示出来。 但是通常我们都不会用到该选项，因为查看工作区的状态我们有更好的选择：git status git add -v . 这条命令的选项：-v，全写是：--verbose 作用：提交的冗余模式 我也不清楚这个冗余模式是什么，官网对它这个命令的解释就一句话：Be verbose. 有清楚的同学踢我一下，评论甩我个链接，不胜感激。 git add -p 文件名.txt 作用是，这样添加一个文件的部分内容进入暂存区。具体做法是，输入命令后会进入交互模式。如果输入Y就全部添加，如果输入e就进入编辑模式，只保留想添加的部分，然后保存退出，最后Y确认。
git add -f . 选项：-f,全写：--force 作用：允许添加已经被忽略的文件 众所周知，在项目的根目录，一版会有.gitignore文件，用于告诉git，哪些文件是不用纳入git管理的。 而-f选项则不惯着这个配置文件。就算被忽略的文件，它也会强行追踪，毕竟force(强制)是程序员的老朋友了。 git add -i ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f28995172d4275c9f0aa3bb19e2be5b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T22:12:10+08:00" />
<meta property="article:modified_time" content="2022-11-27T22:12:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">git 进阶系列教程--add</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="git_add___1"></a>git add ---- 将工作区内容放入暂存区</h3> 
<h4><a id="_2"></a>功能介绍</h4> 
<ol><li>将工作区(working directory)中的内容放入暂存区(staging area)</li><li>追踪文件(解释：刚被添加到工作区的文件处于未跟踪状态(Untracked files),该命令会将新添加的文件放入暂存区，并且文件将处于已跟踪状态)</li></ol> 
<h4><a id="_7"></a>命令解析</h4> 
<pre><code>git add .
</code></pre> 
<blockquote> 
 <p>添加工作区所有文件进入暂存区<br> 最后的点可以理解为正则里的通配符，git add后面添加的是可以为任意合法的路径。<br> 比如：a.txt、/b.txt、*.txt、a/b.txt…</p> 
</blockquote> 
<pre><code>git add --all
</code></pre> 
<blockquote> 
 <p>这个命令和git add .命令很像。都是添加工作区所有文件进入暂存区。但是区别还是有的。<br> 区别一：在git的2.0版本之前，git add .只会添加修改的文件、创建的文件。但是，如果你删除了一个文件，这个命令运行后，不会记录你删除了这个文件。以至于，如果你从暂存区恢复所有文件时，删除的文件还会出现在工作区，或者是提交代码后，被删除的文件依旧会在版本库中。所以你需要做其他的操作来办到删除功能，例如：git rm。但是git add --all命令会将所有结果一起放入暂存区（修改、创建、删除）。然后在git的2.0版本后，两者统一了。都是git add --all的效果了。<br> 区别二：git add .命令认为是添加工作区所有文件进入暂存区，是因为我们在运行git命令时，通常是在项目的根目录。git add .的命令其实是提交当前目录的所有文件，而不是项目中的所有文件都提交。git add --all则是真正的将项目中的所有未忽略的文件添加到暂存区。</p> 
</blockquote> 
<p><strong>工作中，上面的这条命令能处理99%需要add命令的情况。下面的知识是为有好奇add命令还能做什么的同学准备的</strong></p> 
<pre><code>git add -n .
</code></pre> 
<pre><code>这条命令多了一个选项：-n,是选项：--dry-run的简写形式
作用是：并不会将匹配到的文件真的添加到暂存区，而是查看一下是否存在文件还没被追踪或者是修改过但是未添加到暂存区。
回车后，会将没有追踪的文件或未添加到暂存区的文件显示出来。
但是通常我们都不会用到该选项，因为查看工作区的状态我们有更好的选择：git status
</code></pre> 
<pre><code>git add -v .
</code></pre> 
<pre><code>这条命令的选项：-v，全写是：--verbose
作用：提交的冗余模式
我也不清楚这个冗余模式是什么，官网对它这个命令的解释就一句话：Be verbose.
有清楚的同学踢我一下，评论甩我个链接，不胜感激。
</code></pre> 
<pre><code>git add -p 文件名.txt
</code></pre> 
<blockquote> 
 <p>作用是，这样添加一个文件的部分内容进入暂存区。具体做法是，输入命令后会进入交互模式。如果输入Y就全部添加，如果输入e就进入编辑模式，只保留想添加的部分，然后保存退出，最后Y确认。</p> 
</blockquote> 
<pre><code>git add -f .
</code></pre> 
<pre><code>选项：-f,全写：--force
作用：允许添加已经被忽略的文件
众所周知，在项目的根目录，一版会有.gitignore文件，用于告诉git，哪些文件是不用纳入git管理的。
而-f选项则不惯着这个配置文件。就算被忽略的文件，它也会强行追踪，毕竟force(强制)是程序员的老朋友了。
</code></pre> 
<pre><code>git add -i .
</code></pre> 
<pre><code>选项：-i，全写：--interactive
作用：进入提交文件的交互模式。
交互模式...，我想想怎么解释。命令行就是我敲命令，然后收到反馈对吧。交互模式就是你打出命令，会收到几个选项，让你选择。如下。
</code></pre> 
<p><img src="https://images2.imgbox.com/23/7b/AqqSDZxo_o.png" alt="add交互模式"><br> 未完待续。。。</p> 
<pre><code>git add 说明附录
usage: git add [&lt;options&gt;] [--] &lt;pathspec&gt;

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files
    --renormalize         renormalize EOL of tracked files (implies -u)
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files
    --ignore-removal      ignore paths removed in the working tree (same as --no-all)
    --refresh             don't add, only refresh the index
    --ignore-errors       just skip files which cannot be added because of errors
    --ignore-missing      check if - even missing - files are ignored in dry run
    --sparse              allow updating entries outside of the sparse-checkout cone
    --chmod (+|-)x        override the executable bit of the listed files
    --pathspec-from-file &lt;file&gt;
                          read pathspec from file
    --pathspec-file-nul   with --pathspec-from-file, pathspec elements are separated with NUL character
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b62f34979660483065b52b3728f41c7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ArcGIS Engine基础（29）之加载arcgis server切片地图服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1f00d4d290aa8cbdecc1f10cc0ce594/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库——数据库备份与恢复</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>