<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tensorflow数据读取方式总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Tensorflow数据读取方式总结" />
<meta property="og:description" content="1、使用placeholder读内存中的数据 最简单的一种方法是用placeholder，然后以feed_dict将数据给holder的变量，进行传递值。如下面代码所示：
from __future__ import print_function import tensorflow as tf import numpy as np x1 = tf.placeholder(tf.float32,shape=(3,2)) y1 = tf.placeholder(tf.float32,shape=(2,3)) z1 = tf.matmul(x1,y1) x2 = tf.placeholder(tf.float32,shape=None) y2 = tf.placeholder(tf.float32,shape=None) z2 = x2 &#43; y2 # using feed_dict when placehoder with tf.Session() as sess: z2_value = sess.run(z2,feed_dict={x2:1,y2:2}) print(z2_value) rand_x = np.random.rand(3,2) rand_y = np.random.rand(2,3) z1_value,z2_value = sess.run( [z1,z2], # run together feed_dict={ x1:rand_x,y1:rand_y, x2:1,y2:2 } ) print(z1_value,z2_value) 2、使用queue读硬盘中的数据 参考如下的连接，不过感觉队列读取方式较为复杂，有了Dataset API后大部分不用此方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/94c329130ddfed82fd7a760b19385056/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-17T17:36:48+08:00" />
<meta property="article:modified_time" content="2018-03-17T17:36:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tensorflow数据读取方式总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="1使用placeholder读内存中的数据">1、使用placeholder读内存中的数据</h2> 
<p>最简单的一种方法是用placeholder，然后以feed_dict将数据给holder的变量，进行传递值。如下面代码所示：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">from __future__ import print_function
import tensorflow as tf
import numpy as np

x1 = tf<span class="hljs-preprocessor">.placeholder</span>(tf<span class="hljs-preprocessor">.float</span>32,shape=(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))
y1 = tf<span class="hljs-preprocessor">.placeholder</span>(tf<span class="hljs-preprocessor">.float</span>32,shape=(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))
z1 = tf<span class="hljs-preprocessor">.matmul</span>(x1,y1)

x2 = tf<span class="hljs-preprocessor">.placeholder</span>(tf<span class="hljs-preprocessor">.float</span>32,shape=None)
y2 = tf<span class="hljs-preprocessor">.placeholder</span>(tf<span class="hljs-preprocessor">.float</span>32,shape=None)
z2 = x2 + y2

<span class="hljs-preprocessor"># using feed_dict when placehoder</span>
with tf<span class="hljs-preprocessor">.Session</span>() as sess:
    z2_value = sess<span class="hljs-preprocessor">.run</span>(z2,feed_dict={x2:<span class="hljs-number">1</span>,y2:<span class="hljs-number">2</span>}) 
    print(z2_value)
    rand_x = np<span class="hljs-preprocessor">.random</span><span class="hljs-preprocessor">.rand</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)
    rand_y = np<span class="hljs-preprocessor">.random</span><span class="hljs-preprocessor">.rand</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
    z1_value,z2_value = sess<span class="hljs-preprocessor">.run</span>(
        [z1,z2],                   <span class="hljs-preprocessor"># run together</span>
        feed_dict={
            x1:rand_x,y1:rand_y,
            x2:<span class="hljs-number">1</span>,y2:<span class="hljs-number">2</span>
        }
    )
    print(z1_value,z2_value)</code></pre> 
<h2 id="2使用queue读硬盘中的数据">2、使用queue读硬盘中的数据</h2> 
<p>参考如下的连接，不过感觉队列读取方式较为复杂，有了Dataset API后大部分不用此方法。</p> 
<p><a href="https://zhuanlan.zhihu.com/p/27238630" rel="nofollow">十图详解tensorflow数据读取机制（附代码）</a></p> 
<h2 id="3dataset-api">3、Dataset API</h2> 
<p>Dataset可以看作是相同类型“元素”的有序列表。在实际使用时，单个“元素”可以是向量，也可以是字符串、图片，甚至是tuple或者dict。</p> 
<p><strong>注意下图的继承关系</strong></p> 
<p><img src="https://images2.imgbox.com/06/f7/AH50LO70_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="tfdatatextlinedataset">tf.data.TextLineDataset</h3> 
<p>可以直接从文件中读取数据</p> 
<pre class="prettyprint"><code class=" hljs mathematica">__init__(
    filenames,
    compression_type=<span class="hljs-keyword">None</span>,
    buffer_size=<span class="hljs-keyword">None</span>
)</code></pre> 
<p>代码示例：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">with</span> tf.Graph().as_default(),tf.Session() <span class="hljs-keyword">as</span> sess:
    <span class="hljs-comment"># instance a dataset,np.array() =&gt; tf.constant =&gt; tensorflow</span>
    dataset = tf.data.Dataset.from_tensor_slices(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))
    <span class="hljs-comment"># we can also use tf.data.TextLineDataset because this inherit tf.data.Dataset</span>
    <span class="hljs-comment"># dataset = tf.data.TextLineDataset.from_tensor_slices(np.array([1,2,3,4,5]))</span>
    <span class="hljs-comment"># return a Iterator over the element of this dataset </span>
    iterator = dataset.make_one_shot_iterator()
    element = iterator.get_next() <span class="hljs-comment"># every element is a number</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
        print(sess.run(element))  <span class="hljs-comment"># 1,2,3,4,5</span>


<span class="hljs-comment">##### read data from file</span>
<span class="hljs-string">"""
we have a file test.csv:
1,2,0
4,5,1
7,8,2
"""</span>
<span class="hljs-keyword">with</span> tf.Graph().as_default(),tf.Session() <span class="hljs-keyword">as</span> sess:
    dataset = tf.data.TextLineDataset(<span class="hljs-string">"test.csv"</span>)
    iterator = dataset.make_one_shot_iterator()
    element = iterator.get_next() <span class="hljs-comment"># every element is a vector</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            print(sess.run(element))
    <span class="hljs-keyword">except</span> tf.errors.OutOfRangeError:
        print(<span class="hljs-string">"end!"</span>)

<span class="hljs-comment">##### more complex dataset</span>
<span class="hljs-string">"""
1,2,0
4,5,1
7,8,2
the last column is label we create =&gt; batch of feature,label
"""</span>

<span class="hljs-keyword">with</span> tf.Graph().as_default(),tf.Session() <span class="hljs-keyword">as</span> sess:
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_tensor</span><span class="hljs-params">(line)</span>:</span>
        parsed_line = tf.decode_csv(line,[[<span class="hljs-number">0.</span>],[<span class="hljs-number">0.</span>],[<span class="hljs-number">0</span>]]) <span class="hljs-comment"># =&gt; tensor</span>
        <span class="hljs-comment">#label = parsed_line[-1]</span>
        label =  parsed_line[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">del</span> parsed_line[-<span class="hljs-number">1</span>]
        features = parsed_line
        features_names = [<span class="hljs-string">'feature_1'</span>,<span class="hljs-string">'feature_2'</span>]
        d = dict(zip(features_names,features)),label
        <span class="hljs-keyword">return</span> d

    dataset = tf.data.TextLineDataset(<span class="hljs-string">"test.csv"</span>).map(to_tensor).batch(<span class="hljs-number">2</span>)
    iterator = dataset.make_one_shot_iterator()
    batch_features,batch_labels = iterator.get_next()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            batch_fea,batch_lab = sess.run([batch_features,batch_labels])           
            print(batch_fea,batch_lab)
    <span class="hljs-keyword">except</span> tf.errors.OutOfRangeError:
        print(<span class="hljs-string">"end!"</span>)
</code></pre> 
<p>注意dataloader的使用方式</p> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor"># create dataloader</span>
dataset = tf<span class="hljs-preprocessor">.data</span><span class="hljs-preprocessor">.Dataset</span><span class="hljs-preprocessor">.from</span>_tensor_slices((tfx,tfy)) <span class="hljs-preprocessor">#reference tf_dataset_basic.py</span>
dataset = dataset<span class="hljs-preprocessor">.shuffle</span>(buffer_size=<span class="hljs-number">1000</span>)
dataset = dataset<span class="hljs-preprocessor">.batch</span>(<span class="hljs-number">32</span>)
dataset = dataset<span class="hljs-preprocessor">.repeat</span>(<span class="hljs-number">5</span>)
iterator = dataset<span class="hljs-preprocessor">.make</span>_initializable_iterator()
</code></pre> 
<p>使用dataset具体的一个例子</p> 
<pre class="prettyprint"><code class=" hljs python">x = np.random.uniform(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>)) 
y = np.power(x,<span class="hljs-number">2</span>) + np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>,size=x.shape)
x_train,x_test = np.split(x,[<span class="hljs-number">800</span>])
y_train,y_test = np.split(y,[<span class="hljs-number">800</span>])
print(
    <span class="hljs-string">'\nx_train shape'</span>,x_train.shape,
    <span class="hljs-string">'\ny_train shape'</span>,y_train.shape,
)
<span class="hljs-string">"""
plt.scatter(x_train,y_train)
plt.show()
"""</span>

tfx = tf.placeholder(x_train.dtype,x_train.shape)
tfy = tf.placeholder(y_train.dtype,y_train.shape)

<span class="hljs-comment"># create dataloader</span>
dataset = tf.data.Dataset.from_tensor_slices((tfx,tfy)) <span class="hljs-comment">#reference tf_dataset_basic.py</span>
dataset = dataset.shuffle(buffer_size=<span class="hljs-number">1000</span>)
dataset = dataset.batch(<span class="hljs-number">32</span>)
dataset = dataset.repeat(<span class="hljs-number">5</span>)
iterator = dataset.make_initializable_iterator()

<span class="hljs-comment"># built network</span>
batch_x,batch_y = iterator.get_next()  <span class="hljs-comment"># batch_x:(32,1)</span>
h1 = tf.layers.dense(batch_x,<span class="hljs-number">10</span>,tf.nn.relu) <span class="hljs-comment"># batch_x:(32,10)</span>
out = tf.layers.dense(h1,<span class="hljs-number">1</span>) <span class="hljs-comment"># 32*1</span>
loss = tf.losses.mean_squared_error(batch_y,out)
train = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.1</span>).minimize(loss)

<span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:
    <span class="hljs-comment">#initializable</span>
    sess.run([iterator.initializer,tf.global_variables_initializer()],
            feed_dict={tfx:x_train,tfy:y_train})
    <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> range(<span class="hljs-number">301</span>):
        <span class="hljs-keyword">try</span>:
            _,train_loss = sess.run([train,loss])
            <span class="hljs-keyword">if</span> step % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:
                test_loss = sess.run(loss,{batch_x:x_test,batch_y:y_test})
                print(<span class="hljs-string">'\nsetp:'</span>,step,
                    <span class="hljs-string">'\ntrain loss:'</span>,train_loss,
                    <span class="hljs-string">'\ntest loss:'</span>,test_loss,
                )
        <span class="hljs-keyword">except</span> tf.errors.OutOfRangeError:
            print(<span class="hljs-string">"finish!"</span>)
            <span class="hljs-keyword">break</span>
</code></pre> 
<p>完整代码在我的<a href="https://github.com/yqtaowhu">github</a>上~</p> 
<p><strong>参考资料</strong></p> 
<ul><li><a href="https://zhuanlan.zhihu.com/p/30751039" rel="nofollow">Dataset API入门教程</a></li><li><a href="https://developers.googleblog.com/2017/09/introducing-tensorflow-datasets.html" rel="nofollow">Introduction to TensorFlow Datasets and Estimators</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfeb04136839faa43b679d7d91c54997/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring-boot jar方式部署   java类获取资源文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/766ac5e31734376f57e10e8e204a2193/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络-TCP详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>