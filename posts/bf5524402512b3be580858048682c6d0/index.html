<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#，图论与图算法，图（Graph）的数据结构设计与源代码 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#，图论与图算法，图（Graph）的数据结构设计与源代码" />
<meta property="og:description" content="因为后面即将发布的大量有关“图”的算法与源代码都需要用到下面的这些基础数据，为避免大家去下载，特意先发布于此。
一、图（Graph）的基础知识 图（Graph）是一组对象的图示，其中一些对象对通过链接连接。互连对象由称为顶点的点表示，连接顶点的链接称为边。
形式上，图是一对集（V，E），其中V是顶点集，E是连接顶点对的边集。
图形数据结构
数学图可以用数据结构表示。我们可以使用顶点数组和二维边数组来表示图。在继续之前，让我们先熟悉一些重要的术语−
顶点− 图的每个节点都表示为一个顶点。在以下示例中，带标签的圆表示顶点。因此，A到G是顶点。我们可以使用下图所示的数组来表示它们。这里A可以通过索引0来标识。B可以使用索引1等进行识别。
边− 边表示两个顶点之间的路径或两个顶点之间的线。在以下示例中，从A到B、B到C等的线表示边。我们可以使用二维数组来表示数组，如下图所示。这里AB可以表示为第0行第1列的1，BC可以表示为第1行第2列的1，依此类推，其他组合保持为0。
邻接关系− 如果两个节点或顶点通过边相互连接，则它们是相邻的。在以下示例中，B与A相邻，C与B相邻，依此类推。
路径− 路径表示两个顶点之间的边序列。
二、图的基本操作 以下是图形的基本主要操作：
添加顶点 — 将顶点添加到图形中。
添加边 — 在图形的两个顶点之间添加边。
显示顶点 — 显示图形的顶点。
遍历 — 深度优先遍历，宽度优先遍历；
布局 — 图的布局算法
三、图的相关数据 1、节点 using System; using System.Text; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { /// &lt;summary&gt; /// 图的结点（坐标）信息 /// &lt;/summary&gt; public class Node { /// &lt;summary&gt; /// 编号 /// &lt;/summary&gt; public int Id { get; set; } = 0; /// &lt;summary&gt; /// X坐标 /// &lt;/summary&gt; public double X { get; set; } = 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bf5524402512b3be580858048682c6d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T08:15:53+08:00" />
<meta property="article:modified_time" content="2024-03-16T08:15:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#，图论与图算法，图（Graph）的数据结构设计与源代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="799" src="https://images2.imgbox.com/c5/c6/L5ogYTlO_o.png" width="1200"></p> 
<p><em>因为后面即将发布的大量有关“图”的算法与源代码都需要用到下面的这些基础数据，为避免大家去下载，特意先发布于此。</em></p> 
<p></p> 
<h2>一、图（Graph）的基础知识</h2> 
<p>图（Graph）是一组对象的图示，其中一些对象对通过链接连接。互连对象由称为顶点的点表示，连接顶点的链接称为边。</p> 
<p>形式上，图是一对集（V，E），其中V是顶点集，E是连接顶点对的边集。</p> 
<p><strong>图形数据结构</strong></p> 
<p>数学图可以用数据结构表示。我们可以使用顶点数组和二维边数组来表示图。在继续之前，让我们先熟悉一些重要的术语−</p> 
<p>顶点− 图的每个节点都表示为一个顶点。在以下示例中，带标签的圆表示顶点。因此，A到G是顶点。我们可以使用下图所示的数组来表示它们。这里A可以通过索引0来标识。B可以使用索引1等进行识别。</p> 
<p><strong>边</strong>− 边表示两个顶点之间的路径或两个顶点之间的线。在以下示例中，从A到B、B到C等的线表示边。我们可以使用二维数组来表示数组，如下图所示。这里AB可以表示为第0行第1列的1，BC可以表示为第1行第2列的1，依此类推，其他组合保持为0。</p> 
<p><strong>邻接关系</strong>− 如果两个节点或顶点通过边相互连接，则它们是相邻的。在以下示例中，B与A相邻，C与B相邻，依此类推。</p> 
<p><strong>路径</strong>− 路径表示两个顶点之间的边序列。</p> 
<p></p> 
<h2>二、图的基本操作</h2> 
<p></p> 
<p>以下是图形的基本主要操作：</p> 
<p><strong>添加顶点 </strong>— 将顶点添加到图形中。</p> 
<p><strong>添加边 </strong>— 在图形的两个顶点之间添加边。</p> 
<p><strong>显示顶点 </strong>— 显示图形的顶点。</p> 
<p><strong>遍历 </strong>— 深度优先遍历，宽度优先遍历；</p> 
<p><strong>布局 </strong>— 图的布局算法</p> 
<p></p> 
<h2>三、图的相关数据</h2> 
<p><img alt="" height="471" src="https://images2.imgbox.com/8d/26/9SdaWh1x_o.png" width="934"></p> 
<p></p> 
<h3>1、节点</h3> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace Legalsoft.Truffer.Algorithm
{
    /// &lt;summary&gt;
    /// 图的结点（坐标）信息
    /// &lt;/summary&gt;
    public class Node
    {
        /// &lt;summary&gt;
        /// 编号
        /// &lt;/summary&gt;
        public int Id { get; set; } = 0;
        /// &lt;summary&gt;
        /// X坐标
        /// &lt;/summary&gt;
        public double X { get; set; } = 0.0;
        /// &lt;summary&gt;
        /// Y坐标
        /// &lt;/summary&gt;
        public double Y { get; set; } = 0.0;
        //public int Weight { get; set; } = 0;
        /// &lt;summary&gt;
        /// 默认构造函数
        /// &lt;/summary&gt;
        public Node() 
		{
		}

		public Node(int id) 
		{
			Id = id;
		}

        /// &lt;summary&gt;
        /// 长度（原点距离）
        /// &lt;/summary&gt;
        public double Length
        {
            get
            {
                double len = LengthSquare;
                if (Math.Abs(len) &lt; float.Epsilon) return 0.0;
                return Math.Sqrt(len);
            }
        }

        /// &lt;summary&gt;
        /// 长度平方
        /// &lt;/summary&gt;
        public double LengthSquare
        {
            get
            {
                return (X * X) + (Y * Y);
            }
        }

        /// &lt;summary&gt;
        /// 缩放
        /// &lt;/summary&gt;
        /// &lt;param name="rate"&gt;&lt;/param&gt;
        public void Scale(double rate)
        {
            X *= rate;
            Y *= rate;
        }

        /// &lt;summary&gt;
        /// 移动到目的点
        /// &lt;/summary&gt;
        /// &lt;param name="x"&gt;&lt;/param&gt;
        /// &lt;param name="y"&gt;&lt;/param&gt;
        public void MoveTo(double x, double y)
        {
            X = x;
            Y = y;
        }

        /// &lt;summary&gt;
        /// 移动
        /// &lt;/summary&gt;
        /// &lt;param name="delta"&gt;&lt;/param&gt;
        public void Move(Node delta)
        {
            this.X += delta.X;
            this.Y += delta.Y;
        }

        /// &lt;summary&gt;
        /// 加号重载
        /// &lt;/summary&gt;
        /// &lt;param name="a"&gt;&lt;/param&gt;
        /// &lt;param name="b"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Node operator +(Node a, Node b)
        {
            Node c = new Node();
            c.X = a.X + b.X;
            c.Y = a.Y + b.Y;
            return c;
        }

        /// &lt;summary&gt;
        /// 减号重载
        /// &lt;/summary&gt;
        /// &lt;param name="a"&gt;&lt;/param&gt;
        /// &lt;param name="b"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Node operator -(Node a, Node b)
        {
            Node c = new Node();
            c.X = a.X - b.X;
            c.Y = a.Y - b.Y;
            return c;
        }
    }
}
</code></pre> 
<h3>2、边</h3> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace Legalsoft.Truffer.Algorithm
{
	public class Edge
	{
		/// &lt;summary&gt;
		/// 起点（第一点）编号
		/// &lt;/summary&gt;
		public int First { get; set; } = -1;
		/// &lt;summary&gt;
		/// 终点（第二点）编号
		/// &lt;/summary&gt;
		public int Second { get; set; } = -1;
		/// &lt;summary&gt;
		/// 权值
		/// &lt;/summary&gt;
		public int Weight { get; set; } = 0;
		/// &lt;summary&gt;
		/// 默认构造函数
		/// &lt;/summary&gt;
		public Edge()
		{
		}
		/// &lt;summary&gt;
		/// 两点构造函数
		/// &lt;/summary&gt;
		/// &lt;param name="f"&gt;&lt;/param&gt;
		/// &lt;param name="s"&gt;&lt;/param&gt;
		public Edge(int f, int s)
		{
			First = f;
			Second = s;
		}
		/// &lt;summary&gt;
		/// 两点及权值构造函数
		/// &lt;/summary&gt;
		/// &lt;param name="f"&gt;&lt;/param&gt;
		/// &lt;param name="s"&gt;&lt;/param&gt;
		/// &lt;param name="w"&gt;&lt;/param&gt;
		public Edge(int f, int s, int w)
		{
			First = f;
			Second = s;
			Weight = w;
		}
	}
}
</code></pre> 
<p>3、图</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace Legalsoft.Truffer.Algorithm
{
	public partial class Graph
	{
		/// &lt;summary&gt;
		/// 是否为有向图？
		/// &lt;/summary&gt;
		public bool Direction { get; set; } = false;
		/*
		/// &lt;summary&gt;
		/// 节点编码的起始编号0或1
		/// &lt;/summary&gt;
		public int Node_Index_Start { get; set; } = 0;
		/// &lt;summary&gt;
		/// 节点编码的结束编号
		/// &lt;/summary&gt;
		public int Node_Index_End { get; set; } = 0;
		*/
		/// &lt;summary&gt;
		/// 节点总数
		/// &lt;/summary&gt;
		public int Node_Number { get; set; } = 0;
		/*
		/// &lt;summary&gt;
		/// 连线编码的起始编号0或1
		/// &lt;/summary&gt;
		public int Edge_Start { get; set; } = 0;
		*/
		/// &lt;summary&gt;
		/// 连接线总数
		/// &lt;/summary&gt;
		public int Edge_Number { get; set; } = 0;
		/// &lt;summary&gt;
		/// 节点编码列表
		/// &lt;/summary&gt;
		public List&lt;Node&gt; Nodes { get; set; } = new List&lt;Node&gt;();
		/// &lt;summary&gt;
		/// 连接线列表
		/// &lt;/summary&gt;
		public List&lt;Edge&gt; Edges { get; set; } = new List&lt;Edge&gt;();
		/// &lt;summary&gt;
		/// 节点邻接表
		/// &lt;/summary&gt;
		public List&lt;int&gt;[] Adjacency { get; set; } = null;
		/// &lt;summary&gt;
		/// 邻接矩阵
		/// &lt;/summary&gt;
		public int[,] Matrix { get; set; } = null;

		public Graph()
		{
		}

		public Graph(int v, int e = 0, bool direct = false)
		{
			Direction = direct;
			Node_Number = v;
			Edge_Number = e;
			Adjacency = new List&lt;int&gt;[Node_Number + 1];
			for (int i = 0; i &lt;= Node_Number; i++)
			{
				Adjacency[i] = new List&lt;int&gt;();
			}
		}

		public void AddEdge(int a, int b)
		{
			Adjacency[a].Add(b);
			if (Direction == false)
			{
				Adjacency[b].Add(a);
			}
		}

		public void AddEdge(int a, int b, int w)
		{
			AddEdge(a, b);
			Edges.Add(new Edge(a, b, w));
		}

		public void AddEdge(int idx, int a, int b, int w)
		{
			Edges[idx] = new Edge(a, b, w);
		}

		public void AddNode(int a)
		{
			if (!Nodes.Exists(t =&gt; t.Id == a))
			{
				Nodes.Add(new Node(a));
			}
		}

		/// &lt;summary&gt;
		/// 按三元组构造图数据
		/// 三元数组为: {source,destination,weight}
		/// &lt;/summary&gt;
		/// &lt;param name="ternary_array"&gt;三元数据&lt;/param&gt;
		public Graph(int[,] ternary_array, bool dir = false)
		{
			// 有向图？无向图？
			Direction = dir;

			Nodes = new List&lt;Node&gt;();
			Edges = new List&lt;Edge&gt;();
			Edge_Number = ternary_array.GetLength(0);
			for (int i = 0; i &lt; ternary_array.GetLength(0); i++)
			{
				int n1 = ternary_array[i, 0];
				int n2 = ternary_array[i, 1];
				int wt = ternary_array[i, 2];
				AddEdge(n1, n2, wt);
			}
		}

		/// &lt;summary&gt;
		/// 按关联矩阵数据构建图
		/// [N x N]，元素=0，无连接，&gt;0 有连接线及weight
		/// &lt;/summary&gt;
		/// &lt;param name="v"&gt;节点数&lt;/param&gt;
		/// &lt;param name="e"&gt;连边数&lt;/param&gt;
		/// &lt;param name="matrix"&gt;关联矩阵&lt;/param&gt;
		public Graph(int[,] matrix)
		{
			Node_Number = matrix.GetLength(0);
			Nodes = new List&lt;Node&gt;();
			Edges = new List&lt;Edge&gt;();
			Matrix = new int[Node_Number, Node_Number];
			for (int i = 0; i &lt; Node_Number; i++)
			{
				for (int j = 0; j &lt; Node_Number; j++)
				{
					if (matrix[i, j] &gt; 0)
					{
						AddEdge(i, j, matrix[i, j]);
						Matrix[i, j] = matrix[i, j];
					}
				}
			}
		}

		public Edge FindEdge(int a, int b)
        {
			foreach (Edge e in Edges)
			{
				if (e.First == a &amp;&amp; e.Second == b)
				{
					return e;
				}
				if (Direction == false)
				{
					if (e.First == b &amp;&amp; e.Second == a)
					{
						return e;
					}
				}
			}
			return null;
        }

		/// &lt;summary&gt;
		/// 按邻接表的构造函数
		/// &lt;/summary&gt;
		/// &lt;param name="adj"&gt;&lt;/param&gt;
		public Graph(List&lt;List&lt;int&gt;&gt; adj, bool dir = false)
		{
			// 有向图？无向图？
			Direction = dir;

			Node_Number = adj.Count;
			Nodes = new List&lt;Node&gt;();
			Edges = new List&lt;Edge&gt;();

			// 邻接矩阵
			Adjacency = adj.ToArray();

			int idx = 1;
			foreach (List&lt;int&gt; xu in adj)
			{
				foreach (int xv in xu)
				{
					AddEdge(idx, xv);
				}
				idx++;
			}
		}

		/// &lt;summary&gt;
		/// 邻接表 转为 邻接矩阵
		/// 1 起步！
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public int[,] AdjacencyMatrix()
		{
			if (Matrix == null)
			{
				Matrix = new int[Node_Number + 1, Node_Number + 1];
				int idx = 0;
				foreach (List&lt;int&gt; xu in Adjacency)
				{
					// 因为 Adjacency[0] 没有被使用！跳过！
					if (idx &gt; 0)
					{
						foreach (int xv in xu)
						{
							Matrix[idx, xv] = 1;
						}
					}
					idx++;
				}
			}
			return Matrix;
		}
	}
}
</code></pre> 
<p>POWER BY TRUFFER.CN</p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/dc/3b/zXmKavMO_o.png" width="887"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ff5d4b555734061ef9faee7956d8c1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python实用技能】建议收藏：自动化实现网页内容转PDF并保存的方法探索（含代码，亲测可用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45d3d55ebc222239d334011cf6f81bf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蓝桥杯算法基础（21）：（6道小题：奇数在左，第k个元素,超过一半的数字，最小可用ID，合并有序数组，逆序对个数）java版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>