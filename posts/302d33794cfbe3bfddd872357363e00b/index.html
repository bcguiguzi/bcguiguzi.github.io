<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从 XML 到 Compose 快速迁移指南 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从 XML 到 Compose 快速迁移指南" />
<meta property="og:description" content="前言 日常工作，业务需求中的界面布局是至关重要的一部分，长期以来，我们一直都是使用XML布局文件来定义自己的用户界面，但随着Jetpack Compose已经崭露头角，无疑成为了一种强大的UI工具，允许我们以更声明性和可组合的方式构建用户界面。
到目前为止，Compose正在逐步取代XML，越来越多的技术团队已经开始普及使用。下面笔者将以初学者的角度出发，简单阐述如何将现有的XML布局文件转换为Jetpack Compose，实现无缝衔接，以便逐步迁移应用程序的用户界面。
为什么要使用Jetpack Compose Jetpack Compose是Google官方提供的声明式UI工具包，它引入了一种全新的方式来构建用户界面，基于Kotlin编写，而Kotlin作为目前Android的第一生产力语言，这无疑是相得益彰的。由于笔者长期使用XML编写布局，虽然近期才开始重新学习Compose并开始实践用于工作和学习当中， 但Compose必定是未来大势所趋的；虽说目前国内还未完全普及，应用市场上还是有很多应用还在使用着传统的XML布局；
不得不说，现在更新后的AS（笔者这里是Android Studio Giraffe | 2022.3.1 Patch 2）创建的新项目都是默认使用Compose进行界面编写，完全摒弃了传统XML界面布局，这已经说明Compose基本上成为了Google官方主推的UI工具包了；
这时候有人就会说了，既然会成为主流，那它一定有巨大的优势吧；没错，与传统的XML布局文件相比，Jetpack Compose提供了以下优势：
声明性UI编程：Compose允许以声明性的方式描述UI，而不再需要手动操作XML布局文件。这使得UI代码更易于阅读、维护和调试。可组合性：Compose的核心概念是可组合性。可以将小部件组合在一起，构建复杂的UI元素，而不必担心繁琐的布局层次。实时预览：Compose提供了实时预览功能，可以在编写代码的同时查看UI的外观和行为，提高了开发效率。更少的样板代码：与XML布局相比，Compose代码通常更少，因为它减少了样板代码的需要。动态性：Compose允许在运行时动态更改UI，这在某些情况下非常有用。 从XML 迁移到Compose 由于最近一个小项目需要将之前的传统布局代码全部迁移为Compose，虽然整体项目布局文件不算太多，但这过程就我而言，非常繁琐，需要自己对传统布局以及Compose相应的替代方案有一定的熟练度，难度不大，不过相对于初学者来说真的挺折磨，毕竟是在旧项目上操刀，尤其是在替换后需要处理布局的差异，要尽可能保持一致，不影响现有效果；话不多说，下面是笔者简单替换的流程图(仅供参考)
步骤1：创建Compose界面 首先，我们需要在Compose中创建一个等效的界面。对于每个XML布局，我们将创建一个Compose函数，以相同的UI元素作为参数。举个例子，如果我们有一个XML布局文件包含一个TextView和一个Button，我们可以创建如下的Compose函数：
@Composable fun MyComposeScreen(text: String, buttonText: String) { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text(text = text) Button(onClick = { /* 点击处理逻辑 */ }) { Text(text = buttonText) } } } 步骤2：将数据绑定到Compose界面 接下来，我们需要将数据从XML布局中绑定到Compose界面。这通常涉及创建ViewModel或使用其他数据绑定技术，以确保数据在Compose界面中正确显示。
步骤3：逐步替换XML 一旦Compose界面准备好，并且数据绑定完成，我们可以开始逐步替换XML布局。在每个步骤中，我们将删除XML布局的引用，并在适当的位置调用我们的Compose函数。
这里作为初学者，可以给大家推荐一个网站
Which Compose API to use" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/302d33794cfbe3bfddd872357363e00b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-18T16:39:20+08:00" />
<meta property="article:modified_time" content="2024-03-18T16:39:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从 XML 到 Compose 快速迁移指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言</h4> 
<p>日常工作，业务需求中的界面布局是至关重要的一部分，长期以来，我们一直都是使用XML布局文件来定义自己的用户界面，但随着<em>Jetpack Compose</em>已经崭露头角，无疑成为了一种强大的UI工具，允许我们以更声明性和可组合的方式构建用户界面。</p> 
<p>到目前为止，<em>Compose</em>正在逐步取代<em>XML</em>，越来越多的技术团队已经开始普及使用。下面笔者将以初学者的角度出发，简单阐述如何将现有的<em>XML</em>布局文件转换为<em>Jetpack Compose</em>，实现无缝衔接，以便逐步迁移应用程序的用户界面。</p> 
<h4>为什么要使用<em>Jetpack Compose</em></h4> 
<p><em>Jetpack Compose</em>是<em>Google</em>官方提供的声明式UI工具包，它引入了一种全新的方式来构建用户界面，基于<em>Kotlin</em>编写，而<em>Kotlin</em>作为目前Android的第一生产力语言，这无疑是相得益彰的。由于笔者长期使用<em>XML</em>编写布局，虽然近期才开始重新学习<em>Compose</em>并开始实践用于工作和学习当中， 但<em>Compose</em>必定是未来大势所趋的；虽说目前国内还未完全普及，应用市场上还是有很多应用还在使用着传统的<em>XML</em>布局；</p> 
<p>不得不说，现在更新后的AS（笔者这里是<em>Android Studio Giraffe | 2022.3.1 Patch 2</em>）创建的新项目都是默认使用Compose进行界面编写，完全摒弃了传统<em>XML</em>界面布局，这已经说明<em>Compose</em>基本上成为了<em>Google</em>官方主推的UI工具包了；</p> 
<p></p> 
<p class="img-center"><img alt="1.png" height="278" src="https://images2.imgbox.com/b6/2a/6DdmaccF_o.png" width="337"></p> 
<p>这时候有人就会说了，既然会成为主流，那它一定有巨大的优势吧；没错，与传统的XML布局文件相比，<em>Jetpack Compose</em>提供了以下优势：</p> 
<ul><li><strong>声明性UI编程</strong>：<em>Compose</em>允许以声明性的方式描述UI，而不再需要手动操作<em>XML</em>布局文件。这使得UI代码更易于阅读、维护和调试。</li><li><strong>可组合性</strong>：<em>Compose</em>的核心概念是可组合性。可以将小部件组合在一起，构建复杂的UI元素，而不必担心繁琐的布局层次。</li><li><strong>实时预览</strong>：<em>Compose</em>提供了实时预览功能，可以在编写代码的同时查看UI的外观和行为，提高了开发效率。</li><li><strong>更少的样板代码</strong>：与XML布局相比，<em>Compose</em>代码通常更少，因为它减少了样板代码的需要。</li><li><strong>动态性</strong>：<em>Compose</em>允许在运行时动态更改UI，这在某些情况下非常有用。</li></ul> 
<h4>从XML 迁移到Compose</h4> 
<p>由于最近一个小项目需要将之前的传统布局代码全部迁移为Compose，虽然整体项目布局文件不算太多，但这过程就我而言，非常繁琐，需要自己对传统布局以及Compose相应的替代方案有一定的熟练度，难度不大，不过相对于初学者来说真的挺折磨，毕竟是在旧项目上操刀，尤其是在替换后需要处理布局的差异，要尽可能保持一致，不影响现有效果；话不多说，下面是笔者简单替换的流程图(仅供参考)</p> 
<p></p> 
<p class="img-center"><img alt="untitled.png" height="613" src="https://images2.imgbox.com/e2/7f/A1S2OxLk_o.png" width="630"></p> 
<h6>步骤1：创建Compose界面</h6> 
<p>首先，我们需要在<em>Compose</em>中创建一个等效的界面。对于每个XML布局，我们将创建一个Compose函数，以相同的UI元素作为参数。举个例子，如果我们有一个XML布局文件包含一个<em>TextView</em>和一个Button，我们可以创建如下的<em>Compose</em>函数：</p> 
<pre><code class="hljs">@Composable
fun MyComposeScreen(text: String, buttonText: String) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = text)
        Button(onClick = { /* 点击处理逻辑 */ }) {
            Text(text = buttonText)
        }
    }
}</code></pre> 
<h6>步骤2：将数据绑定到Compose界面</h6> 
<p>接下来，我们需要将数据从XML布局中绑定到Compose界面。这通常涉及创建ViewModel或使用其他数据绑定技术，以确保数据在Compose界面中正确显示。</p> 
<h6>步骤3：逐步替换XML</h6> 
<p>一旦Compose界面准备好，并且数据绑定完成，我们可以开始逐步替换XML布局。在每个步骤中，我们将删除XML布局的引用，并在适当的位置调用我们的Compose函数。</p> 
<p>这里作为初学者，可以给大家推荐一个网站</p> 
<ul><li> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetpackcompose.app%2FWhat-is-the-equivalent-of-ProgressBar-in-Jetpack-Compose" rel="nofollow" title="Which Compose API to use">Which Compose API to use</a></p> <p>在替换的时候，有人肯定想问，如果使用<em>RecyclerView</em>的话，我们在<em>Compose</em>中应该用什么呢，<em>ProgressBar</em>我们又该用什么替换呢，等等相关疑问。这个网站的宗旨就是输入传统布局组件它会告诉我们应该用什么，非常实用，直接对症下药，可进一步提高开发效率</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="whats.png" height="1200" src="https://images2.imgbox.com/a7/a5/S4625cGh_o.png" width="1200"></p> 
<h6>步骤4：处理布局差异</h6> 
<p>在某些情况下，XML布局和Compose之间可能存在布局差异。例如，Compose使用Modifier来管理布局属性，而XML布局使用约束和布局参数。在这种情况下，您需要确保在Compose中正确处理这些差异，以确保UI的外观和行为保持一致。</p> 
<h6>步骤5：测试和迭代</h6> 
<p>最后，不要忘记对迁移后的界面进行彻底测试，并根据需要进行迭代和修复。</p> 
<h4>关于Compose替换XML</h4> 
<p>在逐步替换<em>XML</em>的过程中，如果在不中断现有功能的情况下实现无缝衔接的话，需要对<em>XML</em>布局有一定的理解和认识，所以为了在转化过程中更加顺利流畅，下面笔者<em>XML</em>中一些常用的布局和组件的替换方案，一起看看在<em>Compose</em>中是怎么实现的吧</p> 
<p>这里笔者简单统计了下开发过程中常用的一些布局/组件替换方案，由于代码过多，将以图文的形式展示，方便大家参考</p> 
<h5>替代xml中的常用布局</h5> 
<p>我们常用的六大布局，相信大家已经非常熟悉了，就不过多解释啦，下面是它们在Compose的替代方案</p> 
<p></p> 
<p class="img-center"><img alt="xml布局-_Compose布局.png" height="766" src="https://images2.imgbox.com/32/d3/Rd0RvUYh_o.png" width="1200"></p> 
<h6>1. LinearLayout</h6> 
<p>在<em>XML</em>中，<em>LinearLayout</em>用于线性排列其子视图，可以垂直或水平排列。在<em>Compose</em>中，我们可以使用<strong>Column</strong>和<strong>Row</strong>来实现类似的布局，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="LinearLayout.png" height="562" src="https://images2.imgbox.com/83/63/FCSikirv_o.png" width="1200"></p> 
<blockquote> 
 <p>水平布局也是如此，换成<em>Row</em>即可</p> 
</blockquote> 
<h6>2. RelativeLayout</h6> 
<p><em>RelativeLayout</em>允许在<em>XML</em>中相对于其他视图定位子视图。在<em>Compose</em>中，我们可以使用<strong>Box</strong>和<strong>Modifier</strong>相互配合来实现类似的布局，具体得根据实际项目出发，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="RelativeLayout.png" height="526" src="https://images2.imgbox.com/b4/5a/0RSySypV_o.png" width="1200"></p> 
<h6>3. FrameLayout</h6> 
<p><em>FrameLayout</em>作为帧布局,主要就是为了堆叠子视图，在<em>Compose</em>中，可以使用<strong>Box</strong>来实现类似的效果，但要注意<em>Box</em>中的子视图是按照层叠顺序绘制的，简单替换代码如下所示</p> 
<p></p> 
<p class="img-center"><img alt="FrameLayout.png" height="492" src="https://images2.imgbox.com/a8/47/NPX9AoRo_o.png" width="1200"></p> 
<h6>4. GridLayout</h6> 
<p><em>GridLayout</em>用于构建灵活的网格布局，在<em>Compose</em>中，由于之前的Grid组件已经被废弃了，目前需要根据项目本身的需求去自定义布局实现，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="GridLayout.png" height="810" src="https://images2.imgbox.com/55/53/mPVlPGZm_o.png" width="1200"></p> 
<p>我们也可以使用LazyVerticalGrid / LacyHorizontalGrid去实现，它们是Compose中专门用于网格布局的组件，这里简单举一个示例</p> 
<pre><code> val itemsList = List(12) { index -&gt; "Item $index" }
    LazyVerticalGrid(columns = GridCells.Fixed(2),
        modifier = Modifier.fillMaxSize(), content = {
            items(itemsList) { item -&gt;
                // 创建并放置子视图
                Text(
                    text = item,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                )
            }
        })
</code></pre> 
<blockquote> 
 <p>这里使用LazyVerticalGrid来创建一个垂直网格布局，通过GridCells.Fixed(2)指定了每行的列数为2。然后，我们使用items函数来迭代并放置子视图</p> 
</blockquote> 
<h5>5. TableLayout</h5> 
<p>TableLayout在XML中用于创建表格布局，通常用于显示数据表格或多行多列的内容。在Compose中，可以使用LazyColumn或LazyRow来创建类似的表格布局，简单替换代码如下所示：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="449" src="https://images2.imgbox.com/c2/59/Emc1zVpk_o.png" width="1080"></p> 
<blockquote> 
 <p>在Compose中，我们可以使用LazyColumn来创建表格布局，通过嵌套Row和Text组件来实现表格行和单元格。通过调整items的数量和添加更多的表格行，可以创建一个多行多列的表格布局</p> 
</blockquote> 
<h6>6. ConstraintLayout</h6> 
<p><em>ConstraintLayout</em>无疑是我们日常使用最频繁的布局了，它非常强大，可以用来实现一些复杂的界面，在<em>Compose</em>中没有直接对应的布局，需要我们额外引入相对应依赖库来实现约束布局的效果</p> 
<pre><code>implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"
</code></pre> 
<p>简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="482" src="https://images2.imgbox.com/01/08/2yMf2Vxw_o.png" width="1080"></p> 
<blockquote> 
 <p><em>Compose</em>中，使用<code>ConstraintLayout</code>创建了两个子视图，并使用<code>constrainAs</code>修饰符定义了它们之间的约束关系</p> 
</blockquote> 
<h5>替代xml中的常用组件</h5> 
<p>在<em>XML</em>中我们平常会用到很多很多组件，针对这些组件的替换，Compose也提供了相应的解决方案，如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="xml组件-_Compose组件.png" height="1200" src="https://images2.imgbox.com/3e/29/5elGNkYV_o.png" width="1200"></p> 
<h6>1. Button，ImageView，TextView</h6> 
<p>这些组件平常写传统布局的时候一定离不开它们，而它们在<em>Compose</em>中的替代方案也非常简单，分别是：</p> 
<ul><li><strong>Button</strong>组件允许我们创建可交互的按钮，可以自定义文本、样式和点击事件</li><li><strong>Text</strong>组件用于显示文本内容，支持自定义样式和文本格式。</li><li><strong>Image</strong>组件用于显示图像，支持从资源、网络或本地文件加载图像。</li></ul> 
<p>简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="Button,ImageView,Text.png" height="473" src="https://images2.imgbox.com/74/b6/8OIRIeqM_o.png" width="1200"></p> 
<h6>2. CardView</h6> 
<p><em>CardView</em>在<em>XML</em>中用于创建卡片式布局，常用于显示列表项或单独的信息块。在<em>Compose</em>中，可以使用<strong>Card</strong>组件来实现类似的效果，简单替换代码如下所示</p> 
<p></p> 
<p class="img-center"><img alt="Card.png" height="315" src="https://images2.imgbox.com/3e/9e/uHALtulo_o.png" width="1200"></p> 
<blockquote> 
 <p>可以设置卡片的<em>elevation（阴影）</em> 和<em>shape（形状）</em> 等属性</p> 
</blockquote> 
<h6>3. RecyclerView</h6> 
<p><em>RecyclerView</em>在<em>XML</em>中用于显示大量数据列表，是Android应用中常见的UI组件之一；在<em>Compose</em>中，您可以使用<strong>LazyColumn</strong>或<strong>LazyRow</strong>来创建类似的可滚动列表，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="recyclerview.png" height="406" src="https://images2.imgbox.com/e1/03/iijPpcyW_o.png" width="1200"></p> 
<blockquote> 
 <p>使用<code>LazyColumn</code>可以轻松创建可滚动的垂直列表，而<code>LazyRow</code>用于创建水平列表。在Compose中，使用<code>items</code>函数来绑定数据到列表项，并在其中创建列表项的内容</p> 
</blockquote> 
<h6>4. ViewPager，ViewPager2</h6> 
<p><em>ViewPager、ViewPager2</em>在<em>XML</em>中用于创建可滑动的页面容器，通常用于实现轮播图或分页浏览；在<em>Compose</em>中没有直接内置的<em>ViewPager</em>相关组件，这里笔者引入了<em>Accompanist</em>里的库，使用<strong>HorizontalPager、VerticalPager</strong>来完成类似的效果</p> 
<pre><code>implementation "com.google.accompanist:accompanist-pager-indicators:0.22.0-rc"
implementation "com.google.accompanist:accompanist-pager:0.22.0-rc"
</code></pre> 
<p>简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="232" src="https://images2.imgbox.com/27/f8/VAUACNpH_o.png" width="1080"></p> 
<h6>5. AppBarLayout</h6> 
<p><em>AppBarLayout</em>在<em>XML</em>中常用于创建标题栏，通常包含标题、操作按钮等。在<em>Compose</em>中，可以使用<strong>TopAppBar</strong>来实现标题栏效果，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="AppBarLayout.png" height="405" src="https://images2.imgbox.com/68/ff/E5GDyZ6U_o.png" width="1200"></p> 
<blockquote> 
 <p><em>TopAppBar</em>可以设置标题、背景颜色、文本颜色以及操作按钮等属性。</p> 
</blockquote> 
<h6>6. TabLayout</h6> 
<p><em>TabLayout</em>在<em>XML</em>中用于创建选项卡式布局，通常用于导航不同的标签页。在<em>Compose</em>中，可以使用<strong>TabRow</strong>来实现类似的选项卡效果，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="TabLayout.png" height="865" src="https://images2.imgbox.com/6f/9f/cOpGPYOE_o.png" width="1200"></p> 
<blockquote> 
 <p><code>TabRow</code>和<code>Tab</code>可以实现选项卡式布局，并在用户与选项卡进行交互时更新界面</p> 
</blockquote> 
<h6>7. BottomNavigationView</h6> 
<p><em>BottomNavigationView</em>在<em>XML</em>中常用于底部导航栏，用于切换不同的页面或模块。在<em>Compose</em>中，可以使用<strong>BottomNavigation</strong>和<strong>BottomNavigationItem</strong>来实现底部导航栏效果，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="BottomNavigationView.png" height="676" src="https://images2.imgbox.com/7f/09/rz5SHbSP_o.png" width="1200"></p> 
<blockquote> 
 <p>使用<code>BottomNavigation</code>和<code>BottomNavigationItem</code>可以轻松创建底部导航栏，并实现页面切换效果</p> 
</blockquote> 
<h6>8. SearchView</h6> 
<p><em>SearchView</em>在<em>XML</em>中用于创建搜索框，通常用于搜索功能。在<em>Compose</em>中，可以使用<strong>TextField</strong>和<strong>Icons.Default.Search</strong>等组件来创建搜索框，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="SearchView.png" height="728" src="https://images2.imgbox.com/4a/ec/gROlBw68_o.png" width="1200"></p> 
<blockquote> 
 <p>使用<code>TextField</code>、<code>Icon</code>和状态管理，可以创建具有搜索和清除功能的搜索框，是不是更加方便了呢</p> 
</blockquote> 
<h6>9. ScrollView</h6> 
<p><em>ScrollView</em>在<em>XML</em>中用于滚动一个或多个子视图，以便在屏幕上显示超出可见区域的内容。在<em>Compose</em>中，可以使用<strong>LazyColumn</strong>来实现类似的滚动效果，简单替换代码如下所示</p> 
<p></p> 
<p class="img-center"><img alt="ScrollView.png" height="369" src="https://images2.imgbox.com/94/0c/YA4d2Hbu_o.png" width="1071"></p> 
<blockquote> 
 <p><code>LazyColumn</code>基本适用于常见的滚动列表，它会根据需要延迟加载内容</p> 
</blockquote> 
<h6>10. ProgressBar</h6> 
<p><em>ProgressBar</em>在<em>XML</em>中用于显示加载进度，通常用于等待长时间操作或网络请求。在<em>Compose</em>中，可以使用<strong>LinearProgressIndicator</strong>来创建加载进度条，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="ProgressBar.png" height="509" src="https://images2.imgbox.com/8e/d6/4geF5HR1_o.png" width="1200"></p> 
<blockquote> 
 <p>使用<code>LinearProgressIndicator</code>可以轻松创建加载进度条，并使用状态管理来控制进度</p> 
</blockquote> 
<h6>11. WebView</h6> 
<p><em>WebView</em>在<em>XML</em>中用于显示Web页面或嵌入网页内容。在<em>Compose</em>中，可以使用<strong>AndroidView</strong>来嵌入<em>WebView</em>，简单替换代码如下所示</p> 
<p></p> 
<p class="img-center"><img alt="WebView.png" height="466" src="https://images2.imgbox.com/e8/60/n2MYWucI_o.png" width="1200"></p> 
<blockquote> 
 <p>创建一个嵌入的<em>WebView</em>，并加载指定的<em>URL</em></p> 
</blockquote> 
<h6>12. Switch</h6> 
<p><em>Switch</em>在<em>XML</em>中用于创建开关按钮，通常用于切换某个设置或状态。在<em>Compose中</em>，可以使用<strong>Switch</strong>组件来实现类似的开关按钮，简单替换代码如下所示</p> 
<p></p> 
<p class="img-center"><img alt="Switch.png" height="367" src="https://images2.imgbox.com/4f/ae/QRw35TcU_o.png" width="1200"></p> 
<h6>13. DrawerLayout</h6> 
<p><em>DrawerLayout</em>在<em>XML</em>中用于创建抽屉式布局，通常用于侧边栏导航。在<em>Compose</em>中，可以使用<strong>ModalDrawer</strong>来实现侧边栏效果，简单替换代码如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="DrawerLayout.png" height="657" src="https://images2.imgbox.com/ff/79/lXyWyjOA_o.png" width="1200"></p> 
<blockquote> 
 <p>使用<code>ModalDrawer</code>可以实现抽屉式布局，可以控制抽屉的状态并自定义抽屉和内容</p> 
</blockquote> 
<p>以上就是一些常见的组件简单替换方案，具体的要根据项目需求，选择适合的<em>Compose</em>布局元素和修饰符，以满足我们的UI设计需求</p> 
<h4>最后想说的话</h4> 
<p>目前来说，国内<em>Compose</em>并没有完全替代<em>XML</em>传统布局，但将<em>XML</em>布局转换为<em>Compose</em>无疑是一项重要的工作，它可以带来许多好处，包括更好的可维护性、更高的开发效率和更好的用户体验。随着项目版本迭代，通过逐步迁移，我们可以逐渐引入<em>Compose</em>，并在不中断现有功能的情况下实现无缝衔接。</p> 
<p></p> 
<p>作者：RainyJiang<br> 链接：https://juejin.cn/post/7288151382533390395<br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/013fd1113257b219dbc88398ee0793e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# Selenium Edge 驱动下的常见用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f44ed1ab05b36974541efaad2589858/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">App接入Android指纹识别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>