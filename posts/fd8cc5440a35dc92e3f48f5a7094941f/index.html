<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 翁凯老师 数据结构 链表学习（1） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 翁凯老师 数据结构 链表学习（1）" />
<meta property="og:description" content="链表的建立
linked-list.c
#include&#34;node.h&#34; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; // typedef struct _node // { // int value; // struct _node *next; // } Node; int main() { Node * head = NULL;//初始化 int number; do{ scanf(&#34;%d&#34;,&amp;number); if(number != 1){ //add to linked-list Node *p = (Node*)malloc(sizeof(Node)); p-&gt;value = number; p-&gt;next = NULL; //find the last Node *last = head; if(last){ while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位 last = last-&gt;next; } //attach last-&gt;next = p; }else{ head = p; } } }while (number !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/fd8cc5440a35dc92e3f48f5a7094941f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-20T19:49:50+08:00" />
<meta property="article:modified_time" content="2022-02-20T19:49:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 翁凯老师 数据结构 链表学习（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>链表的建立</p> 
<blockquote> 
 <p>linked-list.c</p> 
</blockquote> 
<pre><code class="language-cpp">#include"node.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// typedef struct _node
// {
//     int value;
//     struct  _node *next;
// } Node;

int main()
{
    Node * head = NULL;//初始化
    int number;
    do{
        scanf("%d",&amp;number);
        if(number != 1){
            //add to linked-list
            Node *p = (Node*)malloc(sizeof(Node));
            p-&gt;value = number;
            p-&gt;next = NULL;
            //find the last
            Node *last = head;
            if(last){
                 while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位
                  last = last-&gt;next;
                }
                //attach
                last-&gt;next = p;
            }else{
                head = p;
            }
        }
    }while (number != -1);

    printf("%d",head-&gt;value);//为了验证链表的有效性
    
    return 0;
}</code></pre> 
<blockquote> 
 <p>node.h</p> 
</blockquote> 
<pre><code class="language-cpp">#ifndef _NODE_H_
#define _NODE_H_

typedef struct _node
{
    int value;
    struct  _node *next;
} Node;

#endif</code></pre> 
<p>链表的函数</p> 
<p>缺点：要求 使用add函数的程序员 必须做这件事情，但是我们没有办法强制他人做这件事情【如果没有head=add()对空链表不做这件事情的话就是错的】</p> 
<pre><code class="language-cpp">#include"node.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// typedef struct _node
// {
//     int value;
//     struct  _node *next;
// } Node;

Node* add(Node *head,int number);

// 如果是void add 函数的话就要使用全局变量Node*head 但是，最好不要用全局变量，全局变量是有害的，程序只会是一次性的，只能对这一个链表有作用

int main()
{
    Node * head = NULL;//初始化
    int number;
    do{
        scanf("%d",&amp;number);
        if(number != 1){
            head = add(head,number);
        }
    }while (number != -1);
    printf("%d",head-&gt;value);//为了验证链表的有效性
    return 0;
}

Node* add(Node *head,int number)
{
//add to linked-list
    Node *p = (Node*)malloc(sizeof(Node));
    p-&gt;value = number;
    p-&gt;next = NULL;
    //find the last
    Node *last = head;
    if(last){
        while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位
            last = last-&gt;next;
        }
        //attach
        last-&gt;next = p;
    }else{
        head = p;
    }
    return head;
}</code></pre> 
<blockquote> 
 <p>优化1：将*head变为**phead【head = add（）没有改进】</p> 
 <pre><code class="language-cpp">#include"node.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// typedef struct _node
// {
//     int value;
//     struct  _node *next;
// } Node;

Node* add(Node** phead,int number);

// 如果是void add 函数的话就要使用全局变量Node*head 但是，最好不要用全局变量，全局变量是有害的，程序只会是一次性的，只能对这一个链表有作用

int main()
{
    Node * head = NULL;//初始化
    int number;
    do{
        scanf("%d",&amp;number);
        if(number != 1){
            head = add(head,number);
        }
    }while (number != -1);
    printf("%d",head-&gt;value);//为了验证链表的有效性
    return 0;
}

Node* add(Node** phead,int number)
{
//add to linked-list
    Node *p = (Node*)malloc(sizeof(Node));
    p-&gt;value = number;
    p-&gt;next = NULL;
    //find the last
    Node *last = *phead;
    if(last){
        while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位
            last = last-&gt;next;
        }
        //attach
        last-&gt;next = p;
    }else{
        head = p;
    }
    // return head;
}</code></pre> 
 <p>优化2：用自己定义的一种数据list，代表整个链表，方便以后做修改。</p> 
 <p>eg：可以在定义一个数据，让链表存储不需要总是从第一位开始搜寻，而直接从最后一位开始存储</p> 
 <pre><code class="language-cpp">#include"node.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// typedef struct _node
// {
//     int value;
//     struct  _node *next;
// } Node;

typedef struct _list
{
    Node* head;
    // Node* tail;
}List;

void * add(List* plist,int number);

// 如果是void add 函数的话就要使用全局变量Node*head 但是，最好不要用全局变量，全局变量是有害的，程序只会是一次性的，只能对这一个链表有作用

int main()
{
    List list;
    list.head /* = list.tail */= NULL;
    int number;
    do{
        scanf("%d",&amp;number);
        if(number != 1){
            add(&amp;list,number);
        }
    }while (number != -1);
   
    return 0;
}

void * add(List* plist,int number)
{
//add to linked-list
    Node *p = (Node*)malloc(sizeof(Node));
    p-&gt;value = number;
    p-&gt;next = NULL;
    //find the last
    Node *last = plist-&gt;head;
    if(last){
        while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位
            last = last-&gt;next;
        }
        //attach
        last-&gt;next = p;
    }else{
        plist-&gt;head = p;
    }
    // return head;
}</code></pre> 
 <p>在List的中再创建一个tail指针代表尾结点，使tail永远指向新加进去的节点。这样让链表存储不需要总是从第一位开始搜寻，而直接从最后一位开始存储</p> 
 <pre><code class="language-cpp">#include"node.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// typedef struct _node
// {
//     int value;
//     struct  _node *next;
// } Node;

typedef struct _list
{
    Node* head;
    Node* tail;//永远指向最后一个节点
}List;

void * add(List* plist,int number);

// 如果是void add 函数的话就要使用全局变量Node*head 但是，最好不要用全局变量，全局变量是有害的，程序只会是一次性的，只能对这一个链表有作用

int main()
{
    List list;
    list.head = list.tail = NULL;
    int number;
    do{
        scanf("%d",&amp;number);
        if(number != 1){
            add(&amp;list,number);
            // head = add(head,number);
        }
    }while (number != -1);
    printf("%d",list.tail-&gt;value);
    return 0;
}

void * add(List* plist,int number)
{
//add to linked-list
    Node *p = (Node*)malloc(sizeof(Node));
    p-&gt;value = number;
    p-&gt;next = NULL;
    //find the last
    Node *last = plist-&gt;tail;
    if(last){
        /* while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位
            last = last-&gt;next;
        }
        // attach */
        last-&gt;next = p;
        plist-&gt;tail = p;
    }else{
        plist-&gt;head = p;
        plist-&gt;tail = p;
    }
    // return head;
}</code></pre> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9454954aba3efe80e284c14af9d8daf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10 VS2015&#43;OpenCV4.1.2一劳永逸的永久性配置方式及不同OpenCV版本之间的无缝切换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccf15da2b5810f9a0f394492cbc699cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(已解决)错误：Plugin [id: ‘org.springframework.boot‘, version: ‘2.3.3.RELEASE‘] was not found</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>