<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Go性能优化:Go语言如何进行代码检查和性能优化】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Go性能优化:Go语言如何进行代码检查和性能优化】" />
<meta property="og:description" content="如何进行Go语言的代码检查和优化？ 在项目开发中，保证代码质量和性能的手段不只有单元测试和基准测试，还有代码规范检查和性能优化。
1.代码规范检查是对单元测试的一种补充，它可以从非业务的层面检查代码是否还有优化的空间，比如变量是否被使用、是否是死代码等。
2.性能优化是通过基准测试来衡量的，这样我们才知道优化部分是否真的提升了程序的性能。
代码规范检查
什么是代码规范检查？
​ 代码规范检查，顾名思义，是从Go语言层面出发，依赖Go语言的规范，对代码进行的静态扫描检查，这种检查和业务无关。 比如定义了某个常量，未使用，虽然对代码运行没什么影响，但是为了节省内存，这个常量是可以删除的。这种未使用的常量可以通过代码规范检查检测出来。
​ 在比如调用了一个函数，该函数返回了一个error，但是并没有对error做判断，这种情况下， 程序也可以正常编译运行。但是代码写的不严谨，因为返回的error 被忽略了。如果使用代码规范检查，这类潜在的问题也会被检测出来。除了这两种情况，还有拼写问题、死代码、代码简化检测、命名中带下划线、冗余代码等，都可以使用代码规范检查检测出来。
golangci-lint
​ 要想对代码进行检查，则需要对代码进行扫描，静态分析写的代码是否存在规范问题。可用于Go语言飞马分析的工具有很多，比如golint、gofmt、misspell等，如果一一引用配置，就会很繁琐，所以通常不会单独使用，而是使用 golangci-lint。
提示： 静态代码分析是不会运行代码的。
​ golangci-lint 是一个集成工具，它集成了很多静态代码分析工具，便于使用。通过配置这一工具，我们可以很灵活的启动需要的代码规范检查。 要想使用 golangci-lint ，首先要安装。 因为 golangci-lint 本身就是Go语言编写的，所以我们可以从源代码安装，打开终端，输入如下命令即可安装：
go get github.com/golangci/gilangci-lint/cmd/golangci-lint@v1.32.3
​ 使用命令安装的是v1.32.2版本的 golangci-lint，安装完成后，在终端输入如下命令，检测是否安装成功。
golangci-lint version golangci-lint has version v1.32.2 提示： 在MacOS下也可以使用brew 来安装golangci-lint。
​ 安装成功后，可以使用它进行代码规范检查了。方法如下：
golangci-lint run test/ // 检测目录中test下的代码，运行 golangci-lint配置
​ golangci-lint配置比较灵活，比如可以自定义要启用哪些 linter。 golangci-lint 默认启用的linter，包括：
deadcode - 死代码检查 errcheck - 返回错误是否使用检查 gosimple - 检查代码是否可以简化 govet - 代码可疑检查，比如格式化字符串和类型不一致 ineffassign - 检查是否有未使用的代码 staticcheck - 静态分析检查 struccheck - 查找未使用的结构体字段 typecheck - 类型检查 unused - 未使用代码检查 varcheck - 未使用的全局变量和常量检查 提示： golangci-lint 支持的更多linter，可以在终端中输入 golangci-lint 命令查看，并且可以看到每个 linter 的说明。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9cf4146b17537919e6b5e3d05e19de9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-24T10:28:57+08:00" />
<meta property="article:modified_time" content="2021-12-24T10:28:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Go性能优化:Go语言如何进行代码检查和性能优化】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>如何进行Go语言的代码检查和优化？ 在项目开发中，<strong>保证代码质量和性能的手段不只有单元测试和基准测试，还有代码规范检查和性能优化</strong>。</p> 
<blockquote> 
 <p>1.代码规范检查是对单元测试的一种补充，它可以从非业务的层面检查代码是否还有优化的空间，比如变量是否被使用、是否是死代码等。<br> 2.性能优化是通过基准测试来衡量的，这样我们才知道优化部分是否真的提升了程序的性能。</p> 
</blockquote> 
<p><strong>代码规范检查</strong></p> 
<p><strong>什么是代码规范检查</strong>？</p> 
<p>​ 代码规范检查，顾名思义，是从Go语言层面出发，依赖Go语言的规范，对代码进行的<strong>静态扫描检查</strong>，这种检查和业务无关。 比如定义了某个常量，未使用，虽然对代码运行没什么影响，但是为了节省内存，这个常量是可以删除的。这种<strong>未使用的常量</strong>可以通过代码规范检查检测出来。</p> 
<p>​ 在比如调用了一个函数，该函数返回了一个error，但是并没有对error做判断，这种情况下， 程序也可以正常编译运行。但是代码写的不严谨，因为返回的error 被忽略了。如果使用代码规范检查，这类潜在的问题也会被检测出来。除了这两种情况，还有拼写问题、死代码、代码简化检测、命名中带下划线、冗余代码等，都可以使用代码规范检查检测出来。</p> 
<p><strong>golangci-lint</strong></p> 
<p>​ 要想对代码进行检查，则需要对代码进行扫描，静态分析写的代码是否存在规范问题。可用于Go语言飞马分析的工具有很多，比如golint、gofmt、misspell等，如果一一引用配置，就会很繁琐，所以通常不会单独使用，而是使用 <strong>golangci-lint</strong>。</p> 
<blockquote> 
 <p>提示： 静态代码分析是不会运行代码的。</p> 
</blockquote> 
<p>​ golangci-lint 是一个<strong>集成工具</strong>，它集成了很多静态代码分析工具，便于使用。通过配置这一工具，我们可以很灵活的启动需要的代码规范检查。 要想使用 golangci-lint ，首先要安装。 因为 golangci-lint 本身就是Go语言编写的，所以我们可以从源代码安装，打开终端，输入如下命令即可安装：</p> 
<p><code>go get github.com/golangci/gilangci-lint/cmd/golangci-lint@v1.32.3</code></p> 
<p>​ 使用命令安装的是v1.32.2版本的 golangci-lint，安装完成后，在终端输入如下命令，检测是否安装成功。</p> 
<pre><code class="prism language-go">golangci<span class="token operator">-</span>lint version
golangci<span class="token operator">-</span>lint has version v1<span class="token punctuation">.</span><span class="token number">32.2</span> 
</code></pre> 
<blockquote> 
 <p>提示： 在MacOS下也可以使用brew 来安装golangci-lint。</p> 
</blockquote> 
<p>​ 安装成功后，可以使用它进行代码规范检查了。方法如下：</p> 
<pre><code class="prism language-go">golangci<span class="token operator">-</span>lint run test<span class="token operator">/</span>
<span class="token comment">// 检测目录中test下的代码，运行</span>
</code></pre> 
<p><strong>golangci-lint配置</strong></p> 
<p>​ golangci-lint配置比较灵活，比如可以自定义要启用哪些 linter。 golangci-lint 默认启用的linter，包括：</p> 
<pre><code class="prism language-go">deadcode  <span class="token operator">-</span> 死代码检查
errcheck  <span class="token operator">-</span> 返回错误是否使用检查
gosimple  <span class="token operator">-</span> 检查代码是否可以简化
govet     <span class="token operator">-</span> 代码可疑检查，比如格式化字符串和类型不一致
ineffassign  <span class="token operator">-</span> 检查是否有未使用的代码
staticcheck  <span class="token operator">-</span> 静态分析检查
struccheck   <span class="token operator">-</span> 查找未使用的结构体字段
typecheck    <span class="token operator">-</span> 类型检查
unused       <span class="token operator">-</span> 未使用代码检查
varcheck     <span class="token operator">-</span> 未使用的全局变量和常量检查
</code></pre> 
<blockquote> 
 <p>提示： golangci-lint 支持的更多linter，可以在终端中输入 golangci-lint 命令查看，并且可以看到每个 linter 的说明。</p> 
</blockquote> 
<p>​ 如果要修改默认启用的 linter，就需要对 golangci-lint 进行配置。即<strong>在项目的根目录下创建一个名字为 .golangci.yml 的文件，这就是 golangci-lint 的配置文件</strong>。在运行代码规范检查的时候，golangci-lint 会自动使用它，假设只启用 unused 检查，可以这样配置：</p> 
<pre><code class="prism language-go">linters<span class="token punctuation">:</span>
	disable<span class="token operator">-</span>all<span class="token punctuation">:</span> <span class="token boolean">true</span>
	enable<span class="token punctuation">:</span>
		<span class="token operator">-</span> unused
</code></pre> 
<p>​ 在团队多人协作开发中，有一个固定的 golangci-lint 版本非常重要，这样大家就可以<strong>基于同样的标准检查代码</strong>。要配置 golangci-lint 使用版本也很简单，在配置文件中添加如下代码：</p> 
<pre><code class="prism language-go">servcie<span class="token punctuation">:</span>
	golangci<span class="token operator">-</span>lint<span class="token operator">-</span>version<span class="token punctuation">:</span> <span class="token number">1.32</span><span class="token number">.2</span> <span class="token comment">// use the fixed version to not introduce new linters unexpectedly</span>
</code></pre> 
<p>​ 此外，还可以针对每个启用的 linter 进行配置，比如要设置拼写检测语言为US，可以使用如下代码设置，golangci-lint 的配置比较多，可以自己灵活配置。关于golangci-lint 的更多配置可以参考 <a href="https://golangci-lint.run/usage/configuration/" rel="nofollow" title="golangci-lint 官方文档">golangci-lint 官方文档</a> ， 这里给一个常用配置，如下</p> 
<pre><code class="prism language-go">linters<span class="token operator">-</span>settings<span class="token punctuation">:</span>
	misspell<span class="token punctuation">:</span>
		locale<span class="token punctuation">:</span> US




linters<span class="token operator">-</span>settings<span class="token punctuation">:</span>
  golint<span class="token punctuation">:</span>
    min<span class="token operator">-</span>confidence<span class="token punctuation">:</span> <span class="token number">0</span>
  misspell<span class="token punctuation">:</span>
    locale<span class="token punctuation">:</span> US
linters<span class="token punctuation">:</span>
  disable<span class="token operator">-</span>all<span class="token punctuation">:</span> <span class="token boolean">true</span>
  enable<span class="token punctuation">:</span>
    <span class="token operator">-</span> typecheck
    <span class="token operator">-</span> goimports
    <span class="token operator">-</span> misspell
    <span class="token operator">-</span> govet
    <span class="token operator">-</span> golint
    <span class="token operator">-</span> ineffassign
    <span class="token operator">-</span> gosimple
    <span class="token operator">-</span> deadcode
    <span class="token operator">-</span> structcheck
    <span class="token operator">-</span> unused
    <span class="token operator">-</span> errcheck
service<span class="token punctuation">:</span>
  golangci<span class="token operator">-</span>lint<span class="token operator">-</span>version<span class="token punctuation">:</span> <span class="token number">1.32</span><span class="token number">.2</span> # use the fixed version to not introduce <span class="token builtin">new</span> linters unexpectedly
</code></pre> 
<p><strong>集成 golangci-lint 到CI</strong></p> 
<p>​ <strong>代码检查一定要集成到CI流程中</strong>，效果才会更好，这样开发者提交代码的时候，CI就会自动检查代码，及时发现问题并纠正。 不管是使用 Jenkins，还是 Gitlab Ci，或者Github Action，都可以通过 <strong>Makefiel</strong>的方式运行golangci-lint。在项目跟目录下创建一个 Makefile文件，添加如下代码：</p> 
<pre><code class="prism language-go">getdeps<span class="token punctuation">:</span>
   @mkdir <span class="token operator">-</span>p $<span class="token punctuation">{<!-- --></span>GOPATH<span class="token punctuation">}</span><span class="token operator">/</span>bin
   @which golangci<span class="token operator">-</span>lint <span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">/</span>dev<span class="token operator">/</span>null <span class="token operator">||</span> <span class="token punctuation">(</span>echo <span class="token string">"Installing golangci-lint"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">go</span> get github<span class="token punctuation">.</span>com<span class="token operator">/</span>golangci<span class="token operator">/</span>golangci<span class="token operator">-</span>lint<span class="token operator">/</span>cmd<span class="token operator">/</span>golangci<span class="token operator">-</span>lint@v1<span class="token punctuation">.</span><span class="token number">32.2</span><span class="token punctuation">)</span>
lint<span class="token punctuation">:</span>
   @echo <span class="token string">"Running $@ check"</span>
   @GO111MODULE<span class="token operator">=</span>on $<span class="token punctuation">{<!-- --></span>GOPATH<span class="token punctuation">}</span><span class="token operator">/</span>bin<span class="token operator">/</span>golangci<span class="token operator">-</span>lint cache clean
   @GO111MODULE<span class="token operator">=</span>on $<span class="token punctuation">{<!-- --></span>GOPATH<span class="token punctuation">}</span><span class="token operator">/</span>bin<span class="token operator">/</span>golangci<span class="token operator">-</span>lint run <span class="token operator">--</span>timeout<span class="token operator">=</span><span class="token number">5</span>m <span class="token operator">--</span>config <span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span>golangci<span class="token punctuation">.</span>yml
verifiers<span class="token punctuation">:</span> getdeps lint
</code></pre> 
<p><strong>性能优化</strong></p> 
<p>​ <strong>性能优化的目的是让程序更好、更快的运行，但是它不是必要的，这一点一定要记住</strong>。所以在程序开始的时候，不必刻意追求性能优化，先大胆的写代码就好了，<strong>写正确的代码是性能优化的前提</strong>。</p> 
<p><strong>堆分配还是栈</strong></p> 
<p>​ 在比较古老的C语言中，内存分配是手动申请的，内存释放也需要手动完成。</p> 
<ul><li>手动控制有一个很大的<strong>好处</strong>就是需要多少就申请多杀，可以最大化的<strong>利用内存</strong></li><li>但是这种方式也有一个明显的<strong>缺点</strong>，就是如果忘记释放内存，就会导致<strong>内存泄露</strong></li></ul> 
<p>​ 所以，为了让程序员更专注于业务代码的实现，Go语言增加了垃圾回收机制，自动的回收不在使用的内存。Go语言有两部分内存空间： <strong>栈内存和堆内存</strong>。</p> 
<ul><li><strong>栈内存</strong> 由编译器自动分配和回收，开发者无法控制。栈内存一般存储函数中的局部变量、参数等，函数创建的时候，浙西内存会被自动创建，函数返回的时候，这些内存会被自动释放</li><li><strong>堆内存</strong> 的生命周期比栈内存要长，如果函数返回的值还会在其他地方使用，那么这个值就会被编译期自动分配到堆上。堆内存相比栈内存来说，不能自动被编译器释放，只能通过垃圾回收才能释放，所以栈内存效率会很高</li></ul> 
<p><strong>逃逸分析</strong></p> 
<p>​ 既然栈内存的效率更高，肯定优先使用栈内存。那么Go语言是如何判断一个变量应该分配在堆上还是栈上呢？ 这就需要<strong>逃逸分析</strong>了。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">newString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>
    s <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>
    <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token string">"奔跑的蜗牛"</span>
    <span class="token keyword">return</span> s
<span class="token punctuation">}</span>

<span class="token comment">// 提示： newString 函数是没有意义的，只是为了方便演示。</span>


<span class="token comment">// 现在通过逃逸分析来看是否发生了逃逸，命令如下；</span>
<span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token string">"-m -l"</span> <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span>
# command<span class="token operator">-</span>line<span class="token operator">-</span>arguments
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">8</span>  <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> escapes to heap

<span class="token comment">// 命令中， -m 表示打印出逃逸分析信息， -l 表示禁止内联，可以更好的观察逃逸。从以上输出结果看，发生了逃逸，也就是说指针作为函数返回值都时候，一定会发生逃逸。</span>
</code></pre> 
<pre><code>1. 通过 new 函数 申请了一块内存
1. 然后把它赋值给了变量s
1. 通过return关键字 返回
</code></pre> 
<p>​ 逃逸到堆内存的变量不能马上被回收，只能通过垃圾回收标记清除，增加了垃圾回收的压力，所以要尽可能的避免逃逸，让变量分配在栈内存上，这样函数返回时就可以回收资源，提升效率。对上述示例进行优化：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">newString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> sting<span class="token punctuation">{<!-- --></span>
    s <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>
    <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token string">"奔跑的蜗牛"</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>s
<span class="token punctuation">}</span>

<span class="token comment">// 再次执行逃逸分析</span>
<span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token string">"-m -l"</span> <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span>
# command<span class="token operator">-</span>line<span class="token operator">-</span>arguments
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">8</span>  <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> daes not escape

<span class="token comment">// 通过结果可以看到，虽然还是声明了指针变量s，但是函数返回的并不是指针，所以没有发生逃逸。</span>
</code></pre> 
<p>​</p> 
<p>​ 上面就是关于指针作为函数返回逃逸的例子，那么是不是不使用指针就不会发生逃逸了呢？ 看下面的例子</p> 
<pre><code class="prism language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"独臂阿童木"</span><span class="token punctuation">)</span>

<span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token string">"-m -l"</span> <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span>
#comman<span class="token operator">-</span>line<span class="token operator">-</span>arguments
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span>  <span class="token operator">...</span> argument does not escape
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span>  <span class="token string">"独臂阿童木"</span> escapes to heap
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span>   <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> does not escape

<span class="token comment">// 观察这个结果，发现 “独臂阿童木”字符串逃逸到了堆上，这是因为 “独臂阿童木”这个字符串被已经逃逸的指针变量引用，所以它也跟着逃逸了，引用代码如下：</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>pp<span class="token punctuation">)</span> <span class="token function">printArg</span><span class="token punctuation">(</span>arg <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> verb <span class="token builtin">rune</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span>arg <span class="token operator">=</span> arg
<span class="token punctuation">}</span>
</code></pre> 
<p>​ 所以<strong>被已经逃逸的指针引用的变量也会跟着发生逃逸</strong>。在Go语言中有3个比较特殊的类型，它们是slice、map和chan，被这三种类型引用的指针也会发生逃逸，如下</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    s <span class="token operator">:=</span> <span class="token string">"奔跑的蜗牛"</span>
    m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>s
<span class="token punctuation">}</span>

<span class="token comment">// 运行逃逸分析，结果如下</span>
<span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token string">"-m -l"</span> <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span>
#command<span class="token operator">-</span>line<span class="token operator">-</span>arguments
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> moved to heap<span class="token punctuation">:</span> s
test<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">20</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span> literal does not escape

<span class="token comment">// 从结果看，变量m没有逃逸，反而被变量m引用的变量s 逃逸到了堆上。</span>
</code></pre> 
<p>​ <strong>所以被map、slice和chan 这三种类型引用的指针一定会发生逃逸的</strong>。逃逸分析是判断变量是分配在堆上还是栈上的一种方法，在实际项目中要尽量避免逃逸，这样就不会被GC拖慢速度，从而提升效率。</p> 
<blockquote> 
 <p>提示： 从逃逸分析看，指针虽然可以减少内存的拷贝，但它同样会引起逃逸，所以要根据实际情况选择是否使用指针。</p> 
</blockquote> 
<p><strong>优化技巧</strong></p> 
<p>​ 我们已经了解了堆内存和栈内存，以及变量何时会逃逸，那么优化的时候思路也就比较清晰了，因为都是基于以上原理进行的。总结几个优化的小技巧：</p> 
<ol><li>首先需要介绍的技巧是尽可能避免逃逸，因为栈内存效率更高，还不用GC。比如对象传单，array要比slice效果好。</li><li>如果避免不了逃逸，还是在堆上费配了内存，那么对于频繁的内存申请操作，我们要学会重用内存，比如使用sync.Pool，这是第二个技巧。</li><li>第三个技巧是选用合适的算法，达到高性能的目的，比如空间换时间。</li></ol> 
<blockquote> 
 <p>提示：性能优化的时候，要结合基准测试，来验证优化是否有提升。</p> 
</blockquote> 
<p>​ 以上是基于Go语言的内存管理机制总结出 3个方向的技巧，基于这3个大方向可以优化出想要的效率。除此之外， 还有一些小技巧，比如要尽可能避免使用锁、并发加锁的范围要尽可能小、使用 StringBuilder 做 string 和[]byte 之间的转换、defer嵌套不要太多等。</p> 
<p>​ 最后推荐一个Go语言自带的性能剖析工具 pprof， 通过它可以查看CPU分析、内存分析、阻塞分析、互斥锁分析等，它的使用不是太复杂。</p> 
<p><strong>总结</strong></p> 
<p>​ 主要介绍了代码规范检查和性能优化两部分，其中代码规范检查是从工具使用的角度展开，而性能优化涉及的点太多，所以是从原理的角度展开，明白了原理，才能更好的优化代码。</p> 
<p>​ 是否进行性能优化取决于两点：<strong>业务需求和自我驱动</strong>。所以不要刻意的做性能优化，尤其是不要提前做，先保证代码正确并上线，然后在根据业务需要，决定是否进行优化以及花多少时间优化。自我驱动其实是一种编码能力的体现，比如有经验的开发者在编码的时候，潜意识就避免了逃逸，减少内存拷贝，在高并发的场景中设计低延迟的架构。</p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eca1370c2760643b5ab174fa1364e0e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android筑基——BroadcastReceiver 的动态注册、发送和接收过程（基于api21）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7060f45bbaa2ffeb56b7777a714f0353/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用ApkTools反编译apk并查看apk签名信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>