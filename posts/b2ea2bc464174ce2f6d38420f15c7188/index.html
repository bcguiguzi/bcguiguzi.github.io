<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux第77步_处理Linux并发的相关函数 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux第77步_处理Linux并发的相关函数" />
<meta property="og:description" content="了解linux中的“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体，以及相关函数。
并发就是多个“用户”同时访问同一个共享资源。如：多个线程同时要求读写同一个EEPROM芯片，这个EEPROM就是共享资源，为了保证读写的正确性，其它线程必须等待“持有者”释放使用权限，才可以使用该EEPROM。并发带来的问题就是竞争。Linux采用“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体的函数来解决并发与竞争。
1、Linux系统并发产生的原因:
1)、多线程并发访问。
2)、抢占式并发访问，从2.6版本内核开始，Linux内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。
3)、中断程序并发访问。
4)、SMP(多核)核间并发访问。
注意：SOC称为系统级芯片，也有称片上系统。
如果线程A和线程B修改同一个存储单元，如果没有竞争，就会按照下面的流程执行，都会得到正确的结果。
线程A:
ldr r0, =0X30000000 /* r0=0X30000000 */
ldr r1, =10 /* r1=10 */
str r1, [r0] /*将地址0X30000000的存储单元设置为10*/
线程B:
ldr r0, =0X30000000 /* r0=0X30000000 */
ldr r1, =20 /* r1=20 */
str r1, [r0] /*将地址0X30000000的存储单元设置为20*/
如果线程A和线程B发生竞争，地址0X30000000的存储单元设置的值可能是错误的。
2、原子操作：
原子操作是指不能再进行分割的操作。主要指整型变量操作或者位变量操作。
1)、“原子整形数据”操作：
①、在“include/linux/types.h”文件中，atomic_t的结构体如下
如果是32位的系统级芯片，Linux内核定义的32位原子结构体如下：
typedef struct {
int counter;
}atomic_t;
如果是64位的系统级芯片，Linux内核也定义了64位原子结构体如下：
typedef struct {
s64 counter;
} atomic64_t;
②、“原子整形数据”操作函数:
ATOMIC INIT(int i)
定义原子变量的时候对其初始化；
int atomic read(atomic_t *v)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b2ea2bc464174ce2f6d38420f15c7188/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T16:42:05+08:00" />
<meta property="article:modified_time" content="2024-03-14T16:42:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux第77步_处理Linux并发的相关函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;">了解linux中的“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体，以及相关函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">并发就是多个“用户”同时访问同一个共享资源。如：多个线程同时要求读写同一个EEPROM芯片，这个EEPROM就是共享资源，为了保证读写的正确性，其它线程必须等待“持有者”释放使用权限，才可以使用该EEPROM。并发带来的问题就是竞争。Linux采用<span style="color:#ff0000;">“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体</span>的函数来解决并发与竞争。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">1、Linux系统并发产生的原因:</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)、多线程并发访问。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)、抢占式并发访问，从2.6版本内核开始，Linux内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)、中断程序并发访问。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)、SMP(多核)核间并发访问。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">注意：SOC称为系统级芯片，也有称片上系统。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">如果线程A和线程B修改同一个存储单元，如果没有竞争，就会按照下面的流程执行，都会得到正确的结果。</p> 
<p style="margin-left:.0001pt;text-align:justify;">线程A:</p> 
<p style="margin-left:.0001pt;text-align:justify;">ldr r0, =0X30000000    <span style="color:#00b050;">/* r0=0X30000000  */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">ldr r1, =10            <span style="color:#00b050;">/* r1=10  */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">str r1, [r0]           <span style="color:#00b050;">/*</span><span style="color:#00b050;">将地址0X30000000的存储单元设置为10*/</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">线程B:</p> 
<p style="margin-left:.0001pt;text-align:justify;">ldr r0, =0X30000000    <span style="color:#00b050;">/* r0=0X30000000  */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">ldr r1, =20            <span style="color:#00b050;">/* r1=20  */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">str r1, [r0]           <span style="color:#00b050;">/*</span><span style="color:#00b050;">将地址0X30000000的存储单元设置为20*/</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">如果线程A和线程B发生竞争，<span style="color:#000000;">地址0X30000000的存储单元设置的值可能是错误的。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="348" src="https://images2.imgbox.com/71/51/svPfeO13_o.png" width="576"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2、原子操作：</p> 
<p style="margin-left:.0001pt;text-align:justify;">原子操作是指不能再进行分割的操作。主要指整型变量操作或者位变量操作。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)、“原子整形数据”操作：</p> 
<p style="margin-left:.0001pt;text-align:justify;">①、在“<span style="color:#00b0f0;">include/linux/types.h</span>”文件中，atomic_t的结构体如下</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果是32位的系统级芯片，Linux内核定义的32位原子结构体如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">typedef struct</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">  <span style="color:#00b0f0;">int</span> counter;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}atomic_t;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">如果是64位的系统级芯片，Linux内核也定义了64位原子结构体如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">typedef struct</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">s64 counter;</p> 
<p style="margin-left:.0001pt;text-align:justify;">} atomic64_t;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">②、“原子整形数据”操作函数:</p> 
<p style="margin-left:.0001pt;text-align:justify;">ATOMIC INIT(<span style="color:#00b0f0;">int</span> i)</p> 
<p style="margin-left:.0001pt;text-align:justify;">定义原子变量的时候对其初始化；</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic read(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">读取v-&gt;counter的值，并且返回;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> atomic_set(atomic_t *v, <span style="color:#00b0f0;">int</span> i)</p> 
<p style="margin-left:.0001pt;text-align:justify;">向v-&gt;counter写入i值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> atomic_add(<span style="color:#00b0f0;">int</span> i. atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">给v-&gt;counter加上i值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> atomic_sub(<span style="color:#00b0f0;">int</span> i, atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">从v-&gt;counter减去i值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> atomic_inc(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">给v-&gt;counter加1，也就是自增;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> atomic_dec(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">从v-&gt;counter减1，也就是自减;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_dec_return(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">从v-&gt;counter减1，并且返回v的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_inc_return(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">给v-&gt;counter加1，并且返回v的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_sub_and_test(<span style="color:#00b0f0;">int</span> i.atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">从v-&gt;counter减i，如果结果为0就返回真，否则返回假;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_dec_and_test(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">从v-&gt;counter减1，如果结果为0就返回真，否则返回假;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_inc_and_test(atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">给v-&gt;counter加1，如果结果为0就返回真，否则返回假;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> atomic_add_negative(int i, atomic_t *v)</p> 
<p style="margin-left:.0001pt;text-align:justify;">给v-&gt;counter加i，如果结果为负就返回真，否则返回假;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">举例：</p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_t v = ATOMIC_INIT(0); <span style="color:#00b050;">/* </span><span style="color:#00b050;">定义原子变量v，并初始化原子变零v=0 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_set(&amp;v, 10);         <span style="color:#00b050;">/* 设置</span>v-&gt;counter<span style="color:#00b050;">=10 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_read(&amp;v);<span style="color:#00b050;">            /* 读取</span>v-&gt;counter<span style="color:#00b050;">的值，肯定是10 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_inc(&amp;v);             <span style="color:#00b050;">/* </span>v-&gt;counter<span style="color:#00b050;">的值加1，</span>v-&gt;counter<span style="color:#00b050;">=11 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_t Mylock;                   <span style="color:#00b050;">/* </span><span style="color:#00b050;">原子变量 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">Mylock = (atomic_t)ATOMIC_INIT(0); <span style="color:#00b050;">//</span><span style="color:#00b050;">初始化原子变量</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">atomic_set(&amp;Mylock, 1);            <span style="color:#00b050;">//原子变量初始值为</span>Mylock-&gt;counter=<span style="color:#00b050;">1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">if</span> (!atomic_dec_and_test(&amp;Mylock)) {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">//当</span>Mylock-&gt;counter<span style="color:#00b050;">=1时，atomic_dec_and_test()返回1</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">//从</span>Mylock-&gt;counter<span style="color:#00b050;">减1，如果结果为0就返回1，否则返回0;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"> atomic_inc(&amp;Mylock);</p> 
<p style="margin-left:.0001pt;text-align:justify;"> return -EBUSY; <span style="color:#00b050;">/* Mylock</span><span style="color:#00b050;">被使用，返回忙 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2)、“原子位数据”操作：</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要包含“<span style="color:#FF0000;">#include &lt;bitops.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> set_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位置1;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> clear_bit(<span style="color:#00b0f0;">int</span> nr,<span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位清零;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> change_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位进行翻转;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> test_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取p地址的第nr位的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> test_and_set_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位置 1，并且返回第nr位原来的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> test_and_clear_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位清零，并且返回第nr位原来的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> test_and_change_bit(<span style="color:#00b0f0;">int</span> nr, <span style="color:#00b0f0;">void</span> *p)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将p地址的第nr位翻转，并且返回第nr位原来的值;</p> 
<p style="margin-left:.0001pt;text-align:justify;">举例：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#FF0000;">#include &lt;bitops.h&gt;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">unsigned long</span>     mig_status;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> NFS_MIG_FAILED          (2)</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> ret;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">if</span> ( test_bit(NFS_MIG_FAILED, &amp;mig_status) )</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --><span style="color:#00b050;">//mig_status</span><span style="color:#00b050;">的bit2=1，则执行</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    ret = -EIO;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">return</span> ret;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3)、原子操作只对整型变量和位变量数据进行保护。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3、自旋锁</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)、自旋锁结构体spinlock_t</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">需要包含头文件“</span><span style="color:#00b0f0;">#include &lt; spinlock_types.h &gt;</span><span style="color:#000000;">”;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">Linux内核使用结构体spinlock_t表示自旋锁，定义如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;">typedef struct</span> spinlock {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#0000ff;">union</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">       <span style="color:#0000ff;">struct</span> raw_spinlock rlock;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0000ff;"># define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</p> 
<p style="margin-left:.0001pt;text-align:justify;">       <span style="color:#0000ff;">struct</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">           u8 __padding[LOCK_PADSIZE];</p> 
<p style="margin-left:.0001pt;text-align:justify;">           <span style="color:#0000ff;">struct</span> lockdep_map dep_map;</p> 
<p style="margin-left:.0001pt;text-align:justify;">       };</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#endif</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    };</p> 
<p style="margin-left:.0001pt;text-align:justify;">} spinlock_t;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2)、采用“自旋锁”，实现<span style="color:#000000;">线程之间的并发访问函数：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">需要包含头文件“</span><span style="color:#00b0f0;">#include &lt;spinlock.h&gt;</span><span style="color:#000000;">”;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> DEFINE_SPINLOCK(x)  spinlock_t x = __SPIN_LOCK_UNLOCKED(x)</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明x为自旋锁结构，并初始化;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> spin_lock_init(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">初始化自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_lock(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取指定的自旋锁，也叫做加锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_unlock(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放指定的自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> spin_trylock(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">尝试获取指定的自旋锁，如果没有获取到就返回0;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> spin_is_locked(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回0;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">注意：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">线程之间的并发访问函数</span><span style="color:#ff0000;">，适用于线程之间的并发访问，但不适合中断程序并发访问</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3)、采用“自旋锁”，实现线程与中断之间的并发访问函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_lock_irq(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">禁止本地中断，并获取自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_unlock_irq(spinlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">激活本地中断，并释放自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_lock_irqsave(spinlock_t *lockunsigned <span style="color:#00b0f0;">long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">保存中断状态，禁止本地中断，并获取自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_unlock_irqrestore(spinlock_t*lock, <span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">注意：<span style="color:#00b0f0;">在线程中使用spin_lock_irqsave()和spin_unlock_irqrestore();在中断中使用spin_lock()和spin_unlock()来获取自旋锁和释放自旋锁</span>。<span style="color:#ff0000;">不推荐使用spin_lock_irq()和spin_unlock_irq函数</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4)、举例：</p> 
<p style="margin-left:.0001pt;text-align:justify;">DEFINE_SPINLOCK(MyLock) <span style="color:#00b050;">/*</span>声明MyLock为自旋锁结构，并初始化<span style="color:#00b050;">*/</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">线程A */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> functionA (){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">unsigned long</span> flags; <span style="color:#00b050;">/* </span><span style="color:#00b050;">中断状态 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">spin_lock_irqsave(&amp;MyLock, flags); <span style="color:#00b050;">/* </span><span style="color:#00b050;">获取锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b050;">//</span><span style="color:#00b050;">保存中断状态，禁止本地中断，并获取自旋锁;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">临界区 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">spin_unlock_irqrestore(&amp;MyLock, flags); <span style="color:#00b050;">/* </span><span style="color:#00b050;">释放锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">   //</span><span style="color:#00b050;">将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">中断服务函数 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> irq() {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">spin_lock(&amp;MyLock); <span style="color:#00b050;">/* </span><span style="color:#00b050;">获取锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">//</span><span style="color:#00b050;">获取MyLock自旋锁，也叫做加锁;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">临界区 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">spin_unlock(&amp;MyLock); <span style="color:#00b050;">/* </span><span style="color:#00b050;">释放锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">//</span><span style="color:#00b050;">释放MyLock自旋锁;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)、“下半部”并发访问函数</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要包含文件“<span style="color:#FF0000;">#include &lt;spinlock.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;">下半部(BH)也会竟争共享资源，有些资料也会将下半部叫做底半部。如果要在“下半部”里面使用自旋锁，则需要用到下面的函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_lock_bh(spinlock_t*lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">关闭下半部，并获取自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> spin_unlock_bh(spinlock_t*lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开下半部，并释放自旋锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">6)、自旋锁使用注意事项：</p> 
<p style="margin-left:.0001pt;text-align:justify;">①、“其它线程”在等待自旋锁的时处于“自旋”状态,因此“持有锁的线程”不能长时间持用这个自旋锁，一定要短,否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如信号量和互斥体。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②、自旋锁保护的<span style="color:#00b0f0;">临界区内不能调用任何可能导致线程休眠的API函数</span>，否则的话可能导致死锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;">③、不能递归申请白旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了!</p> 
<p style="margin-left:.0001pt;text-align:justify;">④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的SOC，都将其当做多核SOC来编写驱动程序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4</strong><strong>、读写锁函数</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">需要包含文件“<span style="color:#00b0f0;">#include &lt;rwlock_types.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">typedef struct</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    arch_rwlock_t raw_lock;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#ifdef</span> CONFIG_DEBUG_SPINLOCK</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">unsigned int</span> magic, owner_cpu;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">void</span> *owner;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#endif</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#ff0000;">struct</span> lockdep_map dep_map;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#endif</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">} rwlock_t;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> DEFINE_RWLOCK(x) rwlock_t x = __RW_LOCK_UNLOCKED(x)</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明“读写锁结构变量x”，并初始化读写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">读写锁函数需要包含文件“<span style="color:#00b0f0;">#include &lt;rwlock.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> rwlock_init(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">初始化读写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_lock(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_unlock(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_lock_irq(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">禁止本地中断，并且获取读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_unlock_irg(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开本地中断，并且释放读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_lock_irgsave(rwlock_t *lock,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">保存中断状态，禁止本地中断，并获取读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_unlock_irqrestore(rwlock_t *lock,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将中断状态恢复到以前的状态，并且激活本地中断，释放读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_lock_bh(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">关闭下半部，并获取读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> read_unlock_bh(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开下半部，并释放读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_lock(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_unlock(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_lock_irg(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">禁止本地中断，并且获取写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_unlock_irg(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开本地中断，并且释放写锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_lock_irqsave(rwlock_t *lock,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">保存中断状态，禁止本地中断，并获取写锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_unlock_irqrestore(rwlock_t *lock,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_lock_bh(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">关闭下半部，并获取读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_unlock_bh(rwlock_t *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开下半部，并释放读锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5</strong><strong>、顺序锁</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">顺序锁结构需要包含文件“<span style="color:#00b0f0;">#include &lt;seqlock.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;">顺序锁结构体seqlock_t</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">typedef struct</span> {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">struct</span> seqcount seqcount;</p> 
<p style="margin-left:.0001pt;text-align:justify;">spinlock_t lock;</p> 
<p style="margin-left:.0001pt;text-align:justify;">}seqlock_t;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用顺序锁，实现同时读写，但是不允许同时进行并发的写操作。虽然顺序锁的读和写操作可以同时进行,但是如果在读的过程中发生了写操作,最好重新进行读取，保证数据完整性。</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">顺序锁“保护的资源”不能是指针，因为如果在写操作的时候可能会导致指针无效，而这个时候恰巧有读操作访问指针的话就可能导致意外发生，比如读取野指针导致系统崩溃</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> DEFINE_SEQLOCK(x) \</p> 
<p style="margin-left:.0001pt;text-align:justify;">       seqlock_t x = __SEQLOCK_UNLOCKED(x)</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明“顺序锁结构变量x”,并初始化</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_seqlock(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_sequnlock(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_seqlock_irq(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">禁止本地中断，并且获取“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_sequnlock_irq(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开本地中断，并且释放“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_seqlock_irqsave(seqlock_t *sl,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">保存中断状态，禁止本地中断，并获取“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_sequnlock_irqrestore(seqlock_t *sl,<span style="color:#00b0f0;">unsigned long</span> flags)</p> 
<p style="margin-left:.0001pt;text-align:justify;">将中断状态恢复到以前的状态，并且激活本地中断，释放“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_seqlock_bh(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">关闭下半部，并获取“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> write_sequnlock_bh(seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开下半部，并释放“写顺序锁”;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">unsigned</span> read_seqbegin(<span style="color:#00b0f0;">const</span> seqlock_t *sl)</p> 
<p style="margin-left:.0001pt;text-align:justify;">读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">unsigned</span> read_seqretry(<span style="color:#00b0f0;">const</span> seqlock_t *sl,<span style="color:#00b0f0;">unsigned</span> start)</p> 
<p style="margin-left:.0001pt;text-align:justify;">读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6</strong><strong>、信号量</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">信号量有一个“信号量值”，用来控制访问共享资源的访问数量，相当于通过“信号量值”控制访问资源的线程数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果将“信号量值”设置大于 1，那么这个信号量就是“计数型信号量”，它允许多个线程同时访问共享资源。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果将“信号量值”设置为0，那么这个信号量就是“二值信号量”，它具有互斥访问共享资源的作用。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">需要包含文件“<span style="color:#00b0f0;">#include &lt;semaphore.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)、信号量结构体semaphore</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">struct</span> semaphore {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    raw_spinlock_t       lock;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">unsigned int</span>      count;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">struct</span> list_head  wait_list;</p> 
<p style="margin-left:.0001pt;text-align:justify;">};</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> <span style="color:#7030a0;">__SEMAPHORE_INITIALIZER</span>(name, n)             \</p> 
<p style="margin-left:.0001pt;text-align:justify;">{                               \</p> 
<p style="margin-left:.0001pt;text-align:justify;">    .lock      = __RAW_SPIN_LOCK_UNLOCKED((name).lock),  \</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#ff0000;">.count     = n</span>,                     \</p> 
<p style="margin-left:.0001pt;text-align:justify;">    .wait_list = LIST_HEAD_INIT((name).wait_list),       \</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">并将“name.count”设置为n;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2)、信号量函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> DEFINE_SEMAPHORE(name)  \</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">struct</span> semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明信号量结构变量为name，并将信号量的值“name. count”设置为1;这是一个“计数型信号量”。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">static inline void</span> sema_init(<span style="color:#00b0f0;">struct</span> semaphore *sem, <span style="color:#00b0f0;">int</span> val)</p> 
<p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">static struct</span> lock_class_key __key;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    *sem = (struct semaphore) <span style="color:#7030a0;">__SEMAPHORE_INITIALIZER</span>(*sem, val);</p> 
<p style="margin-left:.0001pt;text-align:justify;">    lockdep_init_map(&amp;sem-&gt;lock.dep_map, "semaphore-&gt;lock", &amp;__key, 0);</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">初始化信号量结构变量sem，并将“sem-&gt;count”设置为val;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> down(<span style="color:#00b0f0;">struct</span> semaphore *sem)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取信号量，但<span style="color:#ff0000;">会导致休眠</span>，进入休眠状态的线程不能被信号打断，因此<span style="color:#ff0000;">不能在中断中使用</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> down_trylock(<span style="color:#00b0f0;">struct</span> semaphore *sem)</p> 
<p style="margin-left:.0001pt;text-align:justify;">尝试获取信号量，如果能获取到信号量就获取，并且返回0。如果不能就返回非0，并不会进入休眠。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> down_interruptible(<span style="color:#00b0f0;">struct</span> semaphore *sem)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取信号量,进入休眠状态的线程可以被信号打断。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> up(<span style="color:#00b0f0;">struct</span> semaphore *sem)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放信号量</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> down_killable(<span style="color:#00b0f0;">struct</span> semaphore *sem)</p> 
<p style="margin-left:.0001pt;text-align:justify;">进入休眠状态的线程可以被唤醒,中断获取信号量的操作;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3)、举例：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">struct</span> semaphore sem; <span style="color:#00b050;">/* </span><span style="color:#00b050;">定义信号量 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">sema_init(&amp;sem, 1)； <span style="color:#00b050;">/* </span><span style="color:#00b050;">初始化信号量 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">down(&amp;sem);          <span style="color:#00b050;">/* </span><span style="color:#00b050;">申请信号量 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">临界区 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">up(&amp;sem); <span style="color:#00b050;">/* </span><span style="color:#00b050;">释放信号量 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4)、信号量的特点:</p> 
<p style="margin-left:.0001pt;text-align:justify;">信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场</p> 
<p style="margin-left:.0001pt;text-align:justify;">合，因此信号量不能用于中断中，因为信号量会引起休眠，中断是不能进入休眠的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果共享资源的持有时间比较短，那就不适合使用信号量。因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>7</strong><strong>、互斥体</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">需要包含文件“<span style="color:#00b0f0;">#include &lt;mutex.h&gt;</span>”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">struct</span> mutex {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    atomic_long_t     owner;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    spinlock_t    wait_lock;</p> 
<p style="margin-left:.0001pt;text-align:justify;">};</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">#define</span> DEFINE_MUTEX(mutexname) \</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#00b0f0;">struct</span> mutex mutexname = __MUTEX_INITIALIZER(mutexname)</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明互斥结构变量mutexname，并初始化;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> mutex_init(<span style="color:#00b0f0;">struct</span> mutex *lock);</p> 
<p style="margin-left:.0001pt;text-align:justify;">并初始化互斥结构变量lock</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> mutex_lock(<span style="color:#00b0f0;">struct</span> mutex *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">void</span> mutex_unlock(<span style="color:#00b0f0;">struct</span> mutex *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">释放 mutex，也就给 mutex 解锁;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> mutex_trylock(<span style="color:#00b0f0;">struct</span> mutex *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">尝试获取mutex，如果成功就返回 1，如果失败就返回 0;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> mutex_is_locked(<span style="color:#00b0f0;">struct</span> mutex *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">判断mutex_是否被获取，如果是的话就返回1，否则返回 0;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">int</span> mutex_lock_interruptible(<span style="color:#00b0f0;">struct</span> mutex *lock)</p> 
<p style="margin-left:.0001pt;text-align:justify;">使用此函数获取信号量失败进入休眠以后可以被信号打断;</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">举例：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b0f0;">struct</span> mutex lock; <span style="color:#00b050;">/* </span><span style="color:#00b050;">定义一个互斥体 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">mutex_init(&amp;lock); <span style="color:#00b050;">/* </span><span style="color:#00b050;">初始化互斥体 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">mutex_lock(&amp;lock); <span style="color:#00b050;">/* </span><span style="color:#00b050;">上锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#00b050;">/* </span><span style="color:#00b050;">临界区 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">mutex_unlock(&amp;lock); <span style="color:#00b050;">/* </span><span style="color:#00b050;">解锁 */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用“互斥体”时，需要注意如下几点:</p> 
<p style="margin-left:.0001pt;text-align:justify;">①、互斥体可以导致休眠，因此不能在中断中使用互斥体，<span style="color:#ff0000;">在中断中只能使用自旋锁</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②、和信号量一样，“互斥体”保护的临界区可以调用引起阻塞的API函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">因为一次只有一个线程可以持有“互斥体”，因此，必须由“互斥体”的持有者释放“互斥体”。</p> 
<p style="margin-left:.0001pt;text-align:justify;">③、“互斥体”不能递归上锁和解锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd48c96450ba60976631d0b7f93290c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网页防篡改：网络安全界的“护宝奇兵”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2993dd7413af8c3304e66102515826d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文阅读——Align before Fuse</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>