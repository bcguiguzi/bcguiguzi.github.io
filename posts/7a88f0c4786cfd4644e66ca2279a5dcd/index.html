<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Cloud Alibaba一一熔断降级 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Cloud Alibaba一一熔断降级" />
<meta property="og:description" content="熔断降级 一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方API等。例如，支付的时候，可能需要远程调用银联提供的API，查询摸个商品的价格，可能需要进行数据库查询，然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。
现代微服务架构都是分布式的，由于非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的若依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。
1、熔断策略
慢调用比例（平均响应时间）：选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。档单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测回复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。异常比例（ERROR_RATIO）：当单位统计时长（satIntervalMs）内请求数且大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是[0.0,1.0]，代表0%-100%。异常数（ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 2、平均响应时间
平均响应时间超过5ms，后续的所有请求都会被熔断，熔断时间为5s，后续有一个请求响应时间小于5ms则结束熔断。
案例：定义一个接口休眠1s后返回内容，用Jemeter 3s内发送10个请求发现全部处理了，设置降级规则后发现只处理了部分请求，其他请求被熔断了。
3、异常比例
异常比例超过28%自动熔断，熔断时间为3s。
案例
int i = 0; @GetMapping(&#34;/hel1o1&#34;) public string hello1() ( 1&#43;&#43;; //出现异常的概率为1/3 if (i % 3 == @){ throw new RuntimeException(); } return &#34;hello1&#34;; } 4、异常数
这里需要注意的是异常数量是按照封装来计算的，异常比例和平均响应时间都是秒级别的。
热点参数限流 热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行限制。
比如：
商品ID为参数，统计一段时间内最常购买的商品ID并进行限制 用户ID为参数，针对一段时间内频繁访问的用户ID进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热电参数的资源调用生效。
1、定义接口
@GetMapping(&#34;/hel1o3&#34;) @SentinelResource(&#34;he11o3”) // 热点参数需要配置这个注解使用 public string hello3(string str1, string str2){ return &#34;hello3 --&gt;&#34;&#43;str1&#43;&#34;,--&gt;&#34;&#43;str2; } 2、设置限流规则
参数限流规则表示，hello3资源中第一个参数1s只能调用一次，超过阈值就限流。
3、限流后返回自定义兜底数据
@GetMapping(&#34;/hello3&#34;) @SentinelResource(value =&#34;hello3&#34;,blockHandler =&#34;hello3Handler&#34;) // 热点参数需要配需这个注解使用 public string hello3(string str1, string str2) { return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7a88f0c4786cfd4644e66ca2279a5dcd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-05T13:17:58+08:00" />
<meta property="article:modified_time" content="2024-03-05T13:17:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Cloud Alibaba一一熔断降级</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>熔断降级</h3> 
<p>       一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方API等。例如，支付的时候，可能需要远程调用银联提供的API，查询摸个商品的价格，可能需要进行数据库查询，然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p> 
<p></p> 
<p class="img-center"><img alt="" height="452" src="https://images2.imgbox.com/0a/4c/LnV8ofTg_o.png" width="750"></p> 
<p>    现代微服务架构都是分布式的，由于非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的若<strong>依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。<strong>熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</strong></p> 
<p>1、熔断策略</p> 
<ul><li>慢调用比例（平均响应时间）：选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。档单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测回复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。</li><li>异常比例（ERROR_RATIO）：当单位统计时长（satIntervalMs）内请求数且大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是[0.0,1.0]，代表0%-100%。</li><li>异常数（ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul> 
<p>2、平均响应时间</p> 
<p></p> 
<p class="img-center"><img alt="" height="469" src="https://images2.imgbox.com/f2/6a/n4LyNLoR_o.png" width="996"></p> 
<p>        平均响应时间超过5ms，后续的所有请求都会被熔断，熔断时间为5s，后续有一个请求响应时间小于5ms则结束熔断。</p> 
<p>        案例：定义一个接口休眠1s后返回内容，用Jemeter 3s内发送10个请求发现全部处理了，设置降级规则后发现只处理了部分请求，其他请求被熔断了。</p> 
<p>  3、异常比例</p> 
<p></p> 
<p class="img-center"><img alt="" height="438" src="https://images2.imgbox.com/e3/cc/UleaqFoo_o.png" width="991"></p> 
<p>异常比例超过28%自动熔断，熔断时间为3s。</p> 
<p>案例</p> 
<pre><code>int i = 0;
@GetMapping("/hel1o1")
public string hello1() (
     1++;
     //出现异常的概率为1/3
     if (i % 3 == @){
            throw new RuntimeException();
     }
     return "hello1";
}</code></pre> 
<p>4、异常数</p> 
<p></p> 
<p class="img-center"><img alt="" height="446" src="https://images2.imgbox.com/1b/33/SJ9f3cCE_o.png" width="991"></p> 
<p>这里需要注意的是异常数量是按照封装来计算的，异常比例和平均响应时间都是秒级别的。</p> 
<h3>热点参数限流</h3> 
<p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行限制。</p> 
<p>比如：</p> 
<ul><li>    商品ID为参数，统计一段时间内最常购买的商品ID并进行限制</li><li>    用户ID为参数，针对一段时间内频繁访问的用户ID进行限制</li></ul> 
<p>热点参数限流会统计传入参数中的热点参数，并根据配置限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热电参数的资源调用生效。</p> 
<p>1、定义接口</p> 
<pre><code>@GetMapping("/hel1o3")
@SentinelResource("he11o3”) // 热点参数需要配置这个注解使用
public string hello3(string str1, string str2){
  return "hello3 --&gt;"+str1+",--&gt;"+str2;
}</code></pre> 
<p>2、设置限流规则</p> 
<p></p> 
<p class="img-center"><img alt="" height="246" src="https://images2.imgbox.com/56/71/pvKM7fCL_o.png" width="990"></p> 
<p></p> 
<p class="img-center"><img alt="" height="566" src="https://images2.imgbox.com/f7/7d/HqNztBzE_o.png" width="973"></p> 
<p>参数限流规则表示，hello3资源中第一个参数1s只能调用一次，超过阈值就限流。</p> 
<p>3、限流后返回自定义兜底数据</p> 
<pre><code>@GetMapping("/hello3")
@SentinelResource(value ="hello3",blockHandler ="hello3Handler") // 热点参数需要配需这个注解使用
public string hello3(string str1, string str2) {
     return "hel1o3 --&gt;"+str1+",--&gt;"+str2;
}
// 这个方法只负责参数限流的异常，不会处理方法的运行时异常
// hel13Handler方法的参数和返回值要和原方法一直，BlockException用来接收方法的异常
public String hello3Handler(string str1, String str2, BlockException e){
    System.out.println("str1 = " + str1 + ", str2 = " + str2 + ", e = " + e);
    return"该资源已被限流”;
}</code></pre> 
<p>4、参数列外项</p> 
<p>   热点参数还可以对不同的参数设置不同的qps的值。</p> 
<p></p> 
<p class="img-center"><img alt="" height="873" src="https://images2.imgbox.com/d3/6b/mpWjoYBB_o.png" width="802"></p> 
<p>当方法第一个参数值10的时候qps为5。</p> 
<p>当方法第一个参数值为11的时候qps为10。</p> 
<p>当方法第一个参数值为15的时候qps为15。</p> 
<p></p> 
<h3>系统自适应限流</h3> 
<p>     Sentinel系统自适应限流从整个维度对应用入口流量进行控制，结合应用的Load、CPU使用率、总体平均RT、入口QPS和并发线程数等几个维度的监控指标、通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p> 
<p>1、系统规则</p> 
<p>    系统保护规则是从应用级别的入口流量进行控制，从单台机器的load、CPU使用率、平均RT、入口QPS和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p> 
<p>   系统保护规则是应用整体维度的，而不是资源维度的，并且**仅对入口流量生效**。入口流量指的是进入应用的流量（EntryType.IN），比如Web服务或Dubbo服务端接收的请求，都属于入口流量。</p> 
<p>系统规则支持以下的模式：</p> 
<ul><li><strong>Load自适应</strong>（仅对Linux/Unix-like机器生效）：系统的load作为启发指标，进行自适应系统保护。当系统load超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才触发系统保护（BBR阶段）。系统容量由系统的<strong>maxQPS*minRt</strong>估算得出。设定参考值一般是<strong>CPU cores*2.5</strong>。</li><li><strong>CPU usage</strong>（1.5.0+版本）：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0-1.0），比较灵敏。</li><li><strong>平均RT</strong>：当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口QPS</strong>：当单台机器上所有入口流量的QPS达到阈值即触发系统保护。</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/1a/59/y8d7PnIo_o.png" width="967"></p> 
<p>案例：测试接口中的所有方法qps都是1。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b841cdf30244398f6d6eca88c16dbea0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为路由器QOS限速实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6f919bb69b2666d8333b0abde03381c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Cloud Alibaba一一SentinelResource</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>