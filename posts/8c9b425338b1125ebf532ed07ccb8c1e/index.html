<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小程序学习3 goods-card - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小程序学习3 goods-card" />
<meta property="og:description" content="pages/home/home home.wxml &lt;goods-list wr-class=&#34;goods-list-container&#34; goodsList=&#34;{{goodsList}}&#34; bind:click=&#34;goodListClickHandle&#34; bind:addcart=&#34;goodListAddCartHandle&#34; /&gt; &lt;goods-list&gt;是一个自定义组件，它具有以下属性和事件：
属性：
wr-class：用于设置组件容器的样式类名。goodsList：用于传递商品列表数据给组件。 事件：
click：当用户点击商品列表中的某个商品时触发该事件，可以通过绑定该事件来执行相应的处理函数。addcart：当用户点击商品列表中的添加购物车按钮时触发该事件，可以通过绑定该事件来执行相应的处理函数。 可以根据需要设置wr-class属性来自定义组件的样式，同时通过goodsList属性传递商品列表数据给组件。另外，你还可以绑定click事件和addcart事件来处理用户的点击操作。
home.json &#34;usingComponents&#34;: { &#34;goods-list&#34;: &#34;/components/goods-list/index&#34;, } home.js import { fetchHome } from &#39;../../services/home/home&#39;; import { fetchGoodsList } from &#39;../../services/good/fetchGoods&#39;; import Toast from &#39;tdesign-miniprogram/toast/index&#39;; Page({ data: { imgSrcs: [], tabList: [], goodsList: [], goodsListLoadStatus: 0, pageLoading: false, current: 1, autoplay: true, duration: &#39;500&#39;, interval: 5000, navigation: { type: &#39;dots&#39; }, swiperImageProps: { mode: &#39;scaleToFill&#39; }, }, goodListPagination: { index: 0, num: 10, }, privateData: { tabIndex: 0, }, onShow() { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8c9b425338b1125ebf532ed07ccb8c1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T14:38:21+08:00" />
<meta property="article:modified_time" content="2024-03-15T14:38:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小程序学习3 goods-card</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="381" src="https://images2.imgbox.com/d5/32/8BklQLlq_o.png" width="300"></p> 
<h3><span style="background-color:#a2e043;">pages/home/home</span></h3> 
<h4><span style="background-color:#ffd7b9;">        home.wxml</span></h4> 
<pre><code class="language-html">  &lt;goods-list
    wr-class="goods-list-container"
    goodsList="{<!-- -->{goodsList}}"
    bind:click="goodListClickHandle"
    bind:addcart="goodListAddCartHandle"
  /&gt;</code></pre> 
<p>&lt;goods-list&gt;是一个自定义组件，它具有以下属性和事件：</p> 
<p><span style="background-color:#edf6e8;">属性：</span></p> 
<ul><li>wr-class：用于设置组件容器的样式类名。</li><li>goodsList：用于传递商品列表数据给组件。</li></ul> 
<p><span style="background-color:#fefcd8;">事件：</span></p> 
<ul><li>click：当用户点击商品列表中的某个商品时触发该事件，可以通过绑定该事件来执行相应的处理函数。</li><li>addcart：当用户点击商品列表中的添加购物车按钮时触发该事件，可以通过绑定该事件来执行相应的处理函数。</li></ul> 
<p>可以根据需要设置wr-class属性来自定义组件的样式，同时通过goodsList属性传递商品列表数据给组件。另外，你还可以绑定click事件和addcart事件来处理用户的点击操作。</p> 
<h4><span style="background-color:#ffd7b9;">        home.json</span></h4> 
<pre><code class="language-html">"usingComponents": {
    "goods-list": "/components/goods-list/index",
}</code></pre> 
<h4><span style="background-color:#ffd7b9;">        home.js</span></h4> 
<pre><code class="language-javascript">import { fetchHome } from '../../services/home/home';
import { fetchGoodsList } from '../../services/good/fetchGoods';
import Toast from 'tdesign-miniprogram/toast/index';

Page({
  data: {
    imgSrcs: [],
    tabList: [],
    goodsList: [],
    goodsListLoadStatus: 0,
    pageLoading: false,
    current: 1,
    autoplay: true,
    duration: '500',
    interval: 5000,
    navigation: { type: 'dots' },
    swiperImageProps: { mode: 'scaleToFill' },
  },

  goodListPagination: {
    index: 0,
    num: 10,
  },

  privateData: {
    tabIndex: 0,
  },

  onShow() {
    this.getTabBar().init();
  },

  onLoad() {
    this.init();
  },

  onReachBottom() {
    if (this.data.goodsListLoadStatus === 0) {
      this.loadGoodsList();
    }
  },

  onPullDownRefresh() {
    this.init();
  },

  init() {
    this.loadHomePage();
  },

  loadHomePage() {
    wx.stopPullDownRefresh();

    this.setData({
      pageLoading: true,
    });
    fetchHome().then(({ swiper, tabList }) =&gt; {
      this.setData({
        tabList,
        imgSrcs: swiper,
        pageLoading: false,
      });
      this.loadGoodsList(true);
    });
  },

  tabChangeHandle(e) {
    this.privateData.tabIndex = e.detail;
    this.loadGoodsList(true);
  },

  onReTry() {
    this.loadGoodsList();
  },

  async loadGoodsList(fresh = false) {
    if (fresh) {
      wx.pageScrollTo({
        scrollTop: 0,
      });
    }

    this.setData({ goodsListLoadStatus: 1 });

    const pageSize = this.goodListPagination.num;
    let pageIndex = this.privateData.tabIndex * pageSize + this.goodListPagination.index + 1;
    if (fresh) {
      pageIndex = 0;
    }

    try {
      const nextList = await fetchGoodsList(pageIndex, pageSize);
      this.setData({
        goodsList: fresh ? nextList : this.data.goodsList.concat(nextList),
        goodsListLoadStatus: 0,
      });

      this.goodListPagination.index = pageIndex;
      this.goodListPagination.num = pageSize;
    } catch (err) {
      this.setData({ goodsListLoadStatus: 3 });
    }
  },

  goodListClickHandle(e) {
    const { index } = e.detail;
    const { spuId } = this.data.goodsList[index];
    wx.navigateTo({
      url: `/pages/goods/details/index?spuId=${spuId}`,
    });
  },

  goodListAddCartHandle() {
    Toast({
      context: this,
      selector: '#t-toast',
      message: '点击加入购物车',
    });
  },

  navToSearchPage() {
    wx.navigateTo({ url: '/pages/goods/search/index' });
  },

  navToActivityDetail({ detail }) {
    const { index: promotionID = 0 } = detail || {};
    wx.navigateTo({
      url: `/pages/promotion-detail/index?promotion_id=${promotionID}`,
    });
  },
});
</code></pre> 
<h5><span style="background-color:#6eaad7;"> 解析：async loadGoodsList(fresh = false) {<!-- --></span></h5> 
<blockquote> 
 <p>说白了，这段儿代码就是鼠标滚轮往下拉，商品列表就刷刷刷的往外刷</p> 
</blockquote> 
<p>这段代码是一个异步函数<code>loadGoodsList</code>，它接受一个参数<code>fresh</code>，默认为<code>false</code>。函数的作用是加载商品列表。</p> 
<p>首先，如果<code>fresh</code>为<code>true</code>，则调用<code>wx.pageScrollTo</code>函数将页面滚动到顶部。</p> 
<p>然后，通过调用<code>setData</code>方法将<code>goodsListLoadStatus</code>设置为1，表示正在加载商品列表。</p> 
<p>接下来，根据当前的页码和每页的数量计算出要请求的页码。如果<code>fresh</code>为<code>true</code>，则将页码设置为0。</p> 
<p>然后，使用<code>fetchGoodsList</code>函数异步获取商品列表。获取到列表后，通过调用<code>setData</code>方法将<code>goodsList</code>更新为新的列表。如果是刷新操作，则直接使用新的列表；如果是加载更多操作，则将新的列表与原有列表合并。同时，将<code>goodsListLoadStatus</code>设置为0，表示加载完成。</p> 
<p>最后，更新分页信息，将页码和每页数量保存到<code>goodListPagination</code>对象中。</p> 
<p>如果在获取商品列表过程中发生错误，则通过调用<code>setData</code>方法将<code>goodsListLoadStatus</code>设置为3，表示加载失败。</p> 
<h5><span style="background-color:#6eaad7;">  goodListAddCartHandle() {  }</span></h5> 
<pre><code class="language-javascript"> goodListAddCartHandle() {
    Toast({
      context: this,
      selector: '#t-toast',
      message: '点击加入购物车',
    });
  },</code></pre> 
<p><a href="https://tdesign.tencent.com/miniprogram/components/toast" rel="nofollow" title="TDesign">TDesign</a>    Toast 轻提示</p> 
<p>用于轻量级反馈或提示，不会打断用户操作。</p> 
<p>goodListAddCartHandle()是一个函数，用于处理点击加入购物车的操作。在函数内部，它会调用Toast组件来显示一个提示消息，提示用户已成功将商品加入购物车。</p> 
<p>在函数中，Toast组件的参数包括：</p> 
<ul><li>context：表示上下文，即函数所在的环境或组件。</li><li>selector：表示选择器，用于指定要显示提示消息的位置。</li><li>message：表示要显示的提示消息内容，这里是"点击加入购物车"。</li></ul> 
<p>这样，当用户点击加入购物车时，函数会调用Toast组件来显示提示消息。</p> 
<p></p> 
<p></p> 
<h3><span style="background-color:#a2e043;">components/goods-list</span></h3> 
<h4><span style="background-color:#ffd7b9;">        index.wxml</span></h4> 
<pre><code class="language-html">&lt;view class="goods-list-wrap wr-class" id="{<!-- -->{independentID}}"&gt;
	&lt;block wx:for="{<!-- -->{goodsList}}" wx:for-item="item" wx:key="index"&gt;
		&lt;goods-card
		  id="{<!-- -->{independentID}}-gd-{<!-- -->{index}}"
		  data="{<!-- -->{item}}"
		  currency="{<!-- -->{item.currency || '¥'}}"
		  thresholds="{<!-- -->{thresholds}}"
		  class="goods-card-inside"
		  data-index="{<!-- -->{index}}"
		  bind:thumb="onClickGoodsThumb"
		  bind:click="onClickGoods"
		  bind:add-cart="onAddCart"
		/&gt;
	&lt;/block&gt;
&lt;/view&gt;</code></pre> 
<h4> <span style="background-color:#ffd7b9;">       index.json</span></h4> 
<pre><code class="language-javascript">{
    "component": true,
    "usingComponents": {
        "goods-card": "/components/goods-card/index"
    }
}</code></pre> 
<p></p> 
<h3><span style="background-color:#a2e043;">components/goods-card</span></h3> 
<h4><span style="background-color:#ffd7b9;">        index.wxml</span></h4> 
<pre><code class="language-html">&lt;view
  id="{<!-- -->{independentID}}"
  class="goods-card"
  bind:tap="clickHandle"
  data-goods="{<!-- -->{ goods }}"
&gt;
	&lt;view class="goods-card__main"&gt;
		&lt;view class="goods-card__thumb" bind:tap="clickThumbHandle"&gt;
			&lt;t-image
			  wx:if="{<!-- -->{ !!goods.thumb }}"
			  t-class="goods-card__img"
			  src="{<!-- -->{ goods.thumb }}"
			  mode="aspectFill"
			  lazy-load
			/&gt;
		&lt;/view&gt;
		&lt;view class="goods-card__body"&gt;
			&lt;view class="goods-card__upper"&gt;
				&lt;view wx:if="{<!-- -->{ goods.title }}" class="goods-card__title"&gt;
					{<!-- -->{ goods.title }}
				&lt;/view&gt;
				&lt;view wx:if="{<!-- -->{ goods.tags &amp;&amp; !!goods.tags.length }}" class="goods-card__tags"&gt;
					&lt;view
					  wx:for="{<!-- -->{ goods.tags }}"
					  wx:key="index"
					  wx:for-item="tag"
					  class="goods-card__tag"
					  data-index="{<!-- -->{index}}"
					&gt;
						{<!-- -->{tag}}
					&lt;/view&gt;
				&lt;/view&gt;
			&lt;/view&gt;
			&lt;view class="goods-card__down"&gt;
				&lt;price
				  wx:if="{<!-- -->{ goods.price }}"
				  wr-class="spec-for-price"
				  symbol-class="spec-for-symbol"
				  symbol="{<!-- -->{currency}}"
				  price="{<!-- -->{goods.price}}"
				/&gt;
				&lt;price
				  wx:if="{<!-- -->{ goods.originPrice &amp;&amp; isValidityLinePrice }}"
				  wr-class="goods-card__origin-price"
				  symbol="{<!-- -->{currency}}"
				  price="{<!-- -->{goods.originPrice}}"
				  type="delthrough"
				/&gt;
				&lt;t-icon
				  class="goods-card__add-cart"
				  prefix="wr"
				  name="cartAdd"
				  id="{<!-- -->{independentID}}-cart"
				  data-id="{<!-- -->{independentID}}"
				  catchtap="addCartHandle"
				  size="48rpx"
				  color="#FA550F"
				/&gt;
			&lt;/view&gt;
		&lt;/view&gt;
	&lt;/view&gt;
&lt;/view&gt;

</code></pre> 
<h5><span style="background-color:#ffd7b9;">  &lt;view class="goods-card__main"&gt;</span></h5> 
<p></p> 
<p><a href="https://tdesign.tencent.com/miniprogram/components/image" rel="nofollow" title="TDesign">TDesign</a>  mode为   裁切</p> 
<h5><span style="background-color:#6eaad7;">lazy-load</span></h5> 
<p>懒加载（Lazy Load）是一种延迟加载的策略，它在编程中常用于优化系统性能和资源利用。懒加载的核心思想是将对象的创建或数据的加载推迟到真正需要的时候再进行，而不是在初始化阶段就立即进行。</p> 
<p>懒加载的优点是可以减少系统启动时间和内存占用，特别适用于大型系统或者需要加载大量资源的场景。通过懒加载，可以避免不必要的资源浪费，提高系统的响应速度和效率。</p> 
<p>在软件开发中，懒加载可以应用于多个方面，比如：</p> 
<ol><li> <p>对象的懒加载：当一个对象在程序中被创建时，并不立即初始化其成员变量或关联对象，而是在真正需要使用时才进行初始化。这样可以避免不必要的对象创建和资源消耗。</p> </li><li> <p>数据库查询的懒加载：在使用ORM（对象关系映射）框架进行数据库操作时，可以延迟加载关联对象的数据。只有当访问关联对象时才会触发实际的数据库查询操作，从而减少数据库访问次数和提高查询效率。</p> </li><li> <p>图片或文件的懒加载：在网页或移动应用中，可以延迟加载图片或文件资源。当用户滚动到可见区域时，再进行实际的资源加载，避免一次性加载大量资源导致页面卡顿或流量浪费。</p> </li></ol> 
<h4></h4> 
<h4></h4> 
<h4><span style="background-color:#ffd7b9;">       index.json</span></h4> 
<pre><code class="language-javascript">{
    "component": true,
    "usingComponents": {
        "price": "/components/price/index",
        "t-icon": "tdesign-miniprogram/icon/icon",
        "t-image": "/components/webp-image/index"
    }
}</code></pre> 
<h5><span style="background-color:#ffd7b9;">        index.js</span></h5> 
<pre><code class="language-javascript">Component({
  options: {
    addGlobalClass: true,
  },

  properties: {
    id: {
      type: String,
      value: '',
      observer(id) {
        this.genIndependentID(id);
        if (this.properties.thresholds?.length) {
          this.createIntersectionObserverHandle();
        }
      },
    },
    data: {
      type: Object,
      observer(data) {
        if (!data) {
          return;
        }
        let isValidityLinePrice = true;
        if (data.originPrice &amp;&amp; data.price &amp;&amp; data.originPrice &lt; data.price) {
          isValidityLinePrice = false;
        }
        this.setData({ goods: data, isValidityLinePrice });
      },
    },
    currency: {
      type: String,
      value: '¥',
    },

    thresholds: {
      type: Array,
      value: [],
      observer(thresholds) {
        if (thresholds &amp;&amp; thresholds.length) {
          this.createIntersectionObserverHandle();
        } else {
          this.clearIntersectionObserverHandle();
        }
      },
    },
  },

  data: {
    independentID: '',
    goods: { id: '' },
    isValidityLinePrice: false,
  },

  lifetimes: {
    ready() {
      this.init();
    },
    detached() {
      this.clear();
    },
  },

  pageLifeTimes: {},

  methods: {
    clickHandle() {
      this.triggerEvent('click', { goods: this.data.goods });
    },

    clickThumbHandle() {
      this.triggerEvent('thumb', { goods: this.data.goods });
    },

    addCartHandle(e) {
      const { id } = e.currentTarget;
      const { id: cardID } = e.currentTarget.dataset;
      this.triggerEvent('add-cart', {
        ...e.detail,
        id,
        cardID,
        goods: this.data.goods,
      });
    },

    genIndependentID(id) {
      let independentID;
      if (id) {
        independentID = id;
      } else {
        independentID = `goods-card-${~~(Math.random() * 10 ** 8)}`;
      }
      this.setData({ independentID });
    },

    init() {
      const { thresholds, id } = this.properties;
      this.genIndependentID(id);
      if (thresholds &amp;&amp; thresholds.length) {
        this.createIntersectionObserverHandle();
      }
    },

    clear() {
      this.clearIntersectionObserverHandle();
    },

    intersectionObserverContext: null,

    createIntersectionObserverHandle() {
      if (this.intersectionObserverContext || !this.data.independentID) {
        return;
      }
      this.intersectionObserverContext = this.createIntersectionObserver({
        thresholds: this.properties.thresholds,
      }).relativeToViewport();

      this.intersectionObserverContext.observe(
        `#${this.data.independentID}`,
        (res) =&gt; {
          this.intersectionObserverCB(res);
        },
      );
    },

    intersectionObserverCB() {
      this.triggerEvent('ob', {
        goods: this.data.goods,
        context: this.intersectionObserverContext,
      });
    },

    clearIntersectionObserverHandle() {
      if (this.intersectionObserverContext) {
        try {
          this.intersectionObserverContext.disconnect();
        } catch (e) {}
        this.intersectionObserverContext = null;
      }
    },
  },
});
</code></pre> 
<p></p> 
<h6>properties     </h6> 
<h6>        <span style="background-color:#6eaad7;">data</span></h6> 
<pre><code class="language-javascript">    data: {
      type: Object,
      observer(data) {
        if (!data) {
          return;
        }
        let isValidityLinePrice = true;
        if (data.originPrice &amp;&amp; data.price &amp;&amp; data.originPrice &lt; data.price) {
          isValidityLinePrice = false;
        }
        this.setData({ goods: data, isValidityLinePrice });
      },
    },</code></pre> 
<p>这段代码是一个小程序中的一个数据观察器（observer用于监听一个名为"data"的对象类型数据的变化。当"data"对象发生变化时，触发observer函数进行处理。</p> 
<p>在observer函数中，首先判断"data"是否存在，如果不存在则直接返回。接着，通过比较"data"对象中的"originPrice"和"price"属性的值，判断是否满足某个条件（即"originPrice"小于"price"），并将结果保存在名为"isValidityLinePrice"的变量中。</p> 
<p>最后，通过调用小程序的setData方法，将"data"对象以及"isValidityLinePrice"变量的值更新到小程序的数据中。</p> 
<p></p> 
<p></p> 
<h6><span style="background-color:#6eaad7;">        thresholds: {<!-- --></span></h6> 
<p>thresholds是一个属性，它是一个数组类型，初始值为空数组。在该属性的观察器(observer)中，当thresholds发生变化时，会执行相应的操作。</p> 
<p>在这段代码中，当thresholds存在且长度大于0时，会调用createIntersectionObserverHandle()方法；否则，会调用clearIntersectionObserverHandle()方法。</p> 
<p>createIntersectionObserverHandle是一个用于创建IntersectionObserver实例的函数。IntersectionObserver一个用于观察目标元素与其祖先元素或视窗交叉状态的API。通过使用IntersectionObserver，我们可以监听目标元素进入或离开视窗，或者与其祖先元素交叉的情况。</p> 
<p>createIntersectionObserverHandle函数的作用是创建一个IntersectionObserver实例，并返回一个用于控制观察行为的句柄。通过这个句柄，我们可以对观察行为进行控制，例如开始观察、停止观察、设置观察回调等。</p> 
<h6><span style="background-color:#eaf4fc;">                createIntersectionObserverHandle</span></h6> 
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createIntersectionObserver.html" rel="nofollow" title="IntersectionObserver | 微信开放文档">IntersectionObserver | 微信开放文档</a></p> 
<p></p> 
<p>使用createIntersectionObserverHandle函数的一般步骤如下：</p> 
<ol><li>调用createIntersectionObserverHandle函数创建一个IntersectionObserver实例的句柄。</li><li>通过句柄调用observe方法，指定要观察的目标元素。</li><li>设置观察回调函数，当目标元素与其祖先元素或视窗交叉状态发生变化时，会触发该回调函数。</li><li>可选地，通过句柄调用unobserve方法停止对目标元素的观察。</li></ol> 
<h6><span style="background-color:#cbe0f1;">                IntersectionObserver</span></h6> 
<p>IntersectionObserver是一个用于监测元素是否进入或离开视口的API。它可以帮助我们实现懒加载、无限滚动、可见性检测等功能。</p> 
<p>IntersectionObserver的基本原理是通过创建一个观察器（IntersectionObserver对象），然后指定要观察的目标元素和一些配置选项。当目标元素进入或离开视口时，观察器会触发回调函数，我们可以在回调函数中执行相应的操作。</p> 
<p>以下是IntersectionObserver的一些常用配置选项：</p> 
<ol><li>root：指定根元素，即观察器所在的容器，默认为浏览器视口。</li><li>rootMargin：指定根元素的边界，可以用来扩大或缩小触发回调的范围。</li><li>threshold：指定目标元素可见性的阈值，可以是一个或多个0到1之间的值。</li></ol> 
<p>使用IntersectionObserver的基本步骤如下：</p> 
<ol><li>创建一个IntersectionObserver对象，并传入一个回调函数。</li><li>使用observe()方法指定要观察的目标元素。</li><li>在回调函数中处理目标元素进入或离开视口的情况。</li></ol> 
<h6>methods:{   </h6> 
<h6 style="background-color:transparent;">    <span style="background-color:#6eaad7;">clickHandle() {<!-- --></span></h6> 
<pre><code class="language-javascript">    clickHandle() {
      this.triggerEvent('click', { goods: this.data.goods });
    },</code></pre> 
<p>clickHandle()是一个函数，它的作用是触发一个名为’click’的事件，并传递一个包含商品信息的对象{ goods: this.data.goods }作为参数。这个函数通常用于处理点击事件，并将商品信息传递给其他组件或模块进行处理。</p> 
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/xr-frame/classes/EventManager.html" rel="nofollow" title="Class: EventManager | 微信开放文档">Class: EventManager | 微信开放文档</a>   </p> 
<p><a href="https://blog.csdn.net/qq_52697994/article/details/125133145?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171048004216800180673920%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171048004216800180673920&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-125133145-null-null.142%5Ev99%5Epc_search_result_base3&amp;utm_term=triggerEvent&amp;spm=1018.2226.3001.4187" title="微信小程序 组件传值(二) triggerEvent 子传父_triggerevent传多个参-CSDN博客">微信小程序 组件传值(二) triggerEvent 子传父_triggerevent传多个参-CSDN博客</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/796cdacea0f5d50f1fd4f78c6cc6b53a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ElasticSearch之通过update_by_query和_reindex重建索引</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1cb5e0b2fc2254bc62095cab359acff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决 ArrayList 的并发问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>