<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 学习笔记（七）：时间片 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 学习笔记（七）：时间片" />
<meta property="og:description" content="一、时间片概念 时间片（timeslice）又称为 “量子”（quantum）或 “处理器片”（processor slice），是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。
简单来说，时间片就是 CPU 分配给各个程序的时间，即该进程允许运行的时间。如果进程在时间片结束时还在运行，则 CPU 将被强制剥夺并分配给另一个进程；如果进程在时间片结束前就阻塞或结束，则 CPU 会在阻塞或结束时当即进行切换。
二、并行计算 说到并行计算，尤其是单台计算机的并行计算，一定要先建立时间片的概念。
现在使用的的操作系统基本都是多任务操作系统（Windows、Linux、Mac OS X 等），它们允许同时运行多个进程 —— 例如，我们可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件，这样看来播放器和浏览器是同时运行的。
但事实上，虽然一台计算机可能有多个 CPU ，但是同一个 CPU 在一个时刻永远只能运行一个任务，而不可能真正地同时运行多个任务。
三、如何实现并行计算 实现这种同时运行的 “假象” ，其实是操作系统按照一定的策略，定期给每个活动的进程执行其内部程序的机会，并且每次只执行一小段时间，然后操作系统利用中断强行退出运行，并将当前程序信息压栈，然后转去执行下一个进程的一小段程序。
通过这样不断快速的循环切换，每个程序都得到了执行。由于切换时间非常短，在用户看来，就是很多程序在同时的执行，这就模拟了并行计算。
现在新的多核 CPU 以及超线程 CPU ，内部有超过 1 个的 CPU 执行体，它们运行时就不是模拟并行计算，而是真的有两个及以上的程序同时被执行 这里我们只需要理解 —— 程序是被操作系统片段执行的，每个片段就是一个时间片。在只考虑一个 CPU 的情况下，时间片使得这些进程 “看起来像” 同时运行的，实则是轮番穿插地运行。时间片通常都很短（Linux上为5ms－800ms），所以用户并不会感觉到进程的切换。
由于是片段执行，我们需要知道，自己的程序在运行时并不是独一无二的。在用户看来很顺畅的工作，其实是由一个个的执行片段构成的。在我们眼中相邻的两条语句甚至同一条语句中两个不同的运算符之间，都有可能插入其他线程或进程的动作。
四、时间片的分配 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间。当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
也就是说，一个系统中所有的进程分配到的时间片长短并不是相等的，尽管初始时间片基本相等（其实 Linux 系统中，初始时间片也不相等，而是各自父进程的一半）。
系统通过测量进程处于 “睡眠” 和 “正在运行” 状态的时间长短来计算每个进程的交互性，交互性和每个进程预设的静态优先级（Nice 值）的叠加即是动态优先级。动态优先级按比例缩放就是要分配给对应进程时间片的长短。一般地，为了获得较快的响应速度，交互性强的进程（趋向于 I/O 消耗型）分配到的时间片要长于交互性弱的（趋向于处理器消耗型）进程。
五、时间片的长度 从一个进程切换到另一个进程是需要一定时间的 —— 保存和装入寄存器值及内存映像、更新各种表格和队列等都是需要时间的。
假如进程切换（process switch）【有时也称为上下文切换（context switch）】，需要 5 毫秒，再假设时间片设置为 20 毫秒。则 CPU 在做完 20 毫秒有用的工作之后，还将花费 5 毫秒来进行进程的切换。也就是说 CPU 时间的 20%（ 5/(20&#43;5) ）都浪费在管理开销上。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2339d12b00498aa830c0147d9fc03a31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-28T14:10:37+08:00" />
<meta property="article:modified_time" content="2023-05-28T14:10:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 学习笔记（七）：时间片</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>一、时间片概念</strong></h2> 
<p>       <span style="color:#ed7976;"><strong>时间片</strong></span>（timeslice）又称为 “量子”（quantum）或 “处理器片”（processor slice），是<span style="color:#494949;"><strong>分时操作系统</strong></span>分配给每个正在运行的<span style="color:#ed7976;">进程</span>微观上的一段 CPU 时间（在<span style="color:#ed7976;">抢占内核</span>中是：从进程开始运行直到被抢占的时间）。</p> 
<p>       简单来说，时间片就是 CPU 分配给各个程序的时间，即该进程允许运行的时间。如果进程在时间片结束时还在运行，则 CPU 将被<strong>强制剥夺</strong>并分配给另一个进程；如果进程在时间片结束前就阻塞或结束，则 CPU 会在阻塞或结束时<strong>当即</strong>进行切换。</p> 
<p></p> 
<p></p> 
<h2><strong>二、并行计算</strong></h2> 
<p>      说到<span style="color:#ed7976;">并行计算</span>，尤其是单台计算机的并行计算，一定要先建立<span style="color:#ed7976;">时间片</span>的概念。</p> 
<p>      现在使用的的操作系统基本都是<span style="color:#79c6cd;">多任务</span><span style="color:#494949;">操作系统</span>（Windows、Linux、Mac OS X 等），它们允许<span style="color:#ed7976;">同时运行多个进程</span> —— 例如，我们可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件，这样看来播放器和浏览器是同时运行的。</p> 
<p>      但事实上，虽然一台计算机可能有多个 CPU ，但是同一个 CPU 在一个时刻永远只能运行一个任务，而不可能真正地同时运行多个任务。</p> 
<p></p> 
<p></p> 
<h2><strong>三、如何实现并行计算</strong></h2> 
<p>      实现这种<span style="color:#494949;">同时运行</span>的 “假象” ，其实是操作系统按照一定的策略，定期给每个活动的进程执行其内部程序的机会，并且每次只执行一小段时间，然后操作系统利用中断<span style="color:#ed7976;">强行退出</span>运行，并将当前程序信息<span style="color:#ed7976;">压栈</span>，然后转去执行下一个进程的一小段程序。</p> 
<p>      通过这样不断快速的<span style="color:#fe2c24;"><strong>循环切换</strong></span>，每个程序都得到了执行。由于切换时间非常短，在用户看来，就是很多程序在同时的执行，这就<span style="color:#494949;">模拟了并行计算</span>。</p> 
<ul><li><span style="color:#7b7f82;">现在新的</span><span style="color:#ed7976;">多核 CPU </span><span style="color:#7b7f82;">以及</span><span style="color:#ed7976;">超线程 CPU</span><span style="color:#7b7f82;"> ，内部有超过 1 个的 CPU 执行体，它们运行时就不是模拟并行计算，而是真的有两个及以上的程序同时被执行</span></li></ul> 
<p></p> 
<p>      这里我们只需要理解 —— 程序是被<span style="color:#ed7976;">操作系统片段</span>执行的，每个片段就是一<span style="color:#494949;">个时间片</span>。在只考虑一个 CPU 的情况下，时间片使得这些进程 “看起来像” 同时运行的，实则是<span style="color:#fe2c24;"><strong>轮番穿插</strong></span>地运行。时间片通常都很短（Linux上为5ms－800ms），所以用户并不会感觉到进程的切换。</p> 
<p>      由于是片段执行，我们需要知道，自己的程序在运行时并不是独一无二的。在用户看来很顺畅的工作，其实是由一个个的执行片段构成的。在我们眼中相邻的两条语句甚至同一条语句中两个不同的运算符之间，都有可能插入其他线程或进程的动作。</p> 
<p></p> 
<p></p> 
<h2><strong>四、时间片的分配</strong></h2> 
<p>     <span style="color:#494949;"> 时间片由</span>操作系统<span style="color:#494949;">内核的</span><span style="color:#ed7976;">调度程序</span>分配给每个进程。首先，内核会给每个进程分配<span style="color:#ed7976;">相等</span>的初始时间片，然后每个进程轮番地执行相应的时间。当所有进程都处于时间片耗尽的状态时，内核会<span style="color:#ed7976;">重新</span>为每个进程计算并分配时间片，如此往复。</p> 
<p>      也就是说，一个系统中所有的进程分配到的<span style="color:#ed7976;">时间片</span>长短<span style="color:#ed7976;">并不是相等</span>的，尽管初始时间片基本相等（其实 Linux 系统中，初始时间片也不相等，而是各自父进程的一半）。</p> 
<p>      系统通过测量进程处于 <span style="color:#79c6cd;">“睡眠”</span> 和<span style="color:#79c6cd;"> “正在运行” </span>状态的时间长短来计算每个进程的<span style="color:#ed7976;">交互性</span>，交互性和每个进程预设的<span style="color:#ed7976;"><strong>静态优先级</strong></span>（Nice 值）的叠加即是<span style="color:#fe2c24;"><strong>动态优先级</strong></span>。动态优先级按比例缩放就是要分配给对应进程时间片的长短。一般地，为了获得较快的响应速度，交互性强的进程（趋向于 I/O 消耗型）分配到的时间片要长于交互性弱的（趋向于处理器消耗型）进程。</p> 
<p></p> 
<p></p> 
<h2><strong>五、时间片的长度</strong></h2> 
<p>       从一个进程切换到另一个进程是需要一定时间的 —— 保存和装入寄存器值及内存映像、更新各种表格和队列等都是需要时间的。</p> 
<p>       假如<span style="color:#79c6cd;">进程切换</span>（process switch）【有时也称为<span style="color:#79c6cd;">上下文切换</span>（context switch）】，需要 <span style="color:#a2e043;">5</span> 毫秒，再假设时间片设置为 <span style="color:#a2e043;">20</span> 毫秒。则 CPU 在做完 20 毫秒有用的工作之后，还将花费 5 毫秒来进行进程的切换。也就是说 CPU 时间的 <span style="color:#a2e043;">20%</span>（ 5/(20+5) ）都浪费在管理开销上。</p> 
<p>       为了提高 CPU 使用的效率，我们将时间片设置为 500 毫秒，这样 CPU 浪费的时间只有 1% 不到。<span style="color:#494949;">但是这样真的好吗？</span>如果在一个分时系统中，有十个交互用户几乎同时按下了回车键，会发生什么情况？假设前九个进程都用足了它们的时间片，那么最后一个不幸的进程必须等待将近 5 秒才能获得运行的机会。如果恰好最后一个运行的倒霉进程只是一条简短的命令，却要 5 秒才能做出响应，这样对用户的使用体验非常不好。同样的问题在一台支持多道程序的个人计算机上也会发生。</p> 
<p>       所以结论总结如下：时间片太短会导致过多的进程切换，降低了 CPU 利用效率；而时间片太长又可能导致对较短交互请求的响应变差。所以需要寻找一个<strong><span style="color:#fe2c24;">合适的时间片长度</span></strong>，平衡 CPU 效率和交互响应效果（100毫秒通常是一个比较合理的折中值）。</p> 
<p></p> 
<p></p> 
<h2><strong>六、总结</strong>      </h2> 
<p>      在数据传输领域，我们亲眼看见的，都不一定是真的。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖、同时运行。但是在微观上：由于只有一个 CPU ，一次只能处理一个程序中的一部分内容。</p> 
<p>      如何公平地进行处理，一种方法就是引入时间片，每个程<span style="color:#494949;">序<strong>轮流</strong>执行</span>。时间片使得各个程序从表面上看是<span style="color:#494949;"><strong>同时进行</strong></span>的，又减少了 CPU 资源的浪费。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee9ed73c07ffbbeba9d9ffc235e89f73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IT行业实用的学习网站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4eccaaa17f6e1bc8950e3992705c35e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql解压缩安装的详细步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>