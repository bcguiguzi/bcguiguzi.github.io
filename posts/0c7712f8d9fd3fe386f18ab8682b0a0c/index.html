<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>让你看看我肝了好多天的git教程吧 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="让你看看我肝了好多天的git教程吧" />
<meta property="og:description" content="本文章最初发布在 XJHui’s Blog，未经允许，任何人禁止转载！
注意：最新修改版本已发布在 这里，点击前往查看！
关于笔记 视频地址：Git（中级）教程（12h深入掌握git）(28p)学前基础： linuxgithub 学后技能： git底层、高层命令git分支、存储、后悔药、标签git团队协作、Pull Request 版本控制 集中式(svn) 原理：服务器存放项目的所有版本，工作时从服务器下载项目最新版本，工作完成后将代码提交到服务器
原理图：
分布式(git) 原理：每台电脑中都存放了项目的所有版本，即使服务器故障也不会影响工作更不会将丢失项目
原理图：
差异比较 存储方式：svn存储版本差异，git存储所有版本
注意：git是先压缩后存储，尽管存储占用比svn大，但不会大太多
安全性：
svn：工作时只会下载项目最新版本，如果服务器存储故障，就无法从员工电脑恢复项目所有版本git：每位员工电脑上都有项目的所有版本，即使服务器存储故障，任意一位员工都能恢复整个项目 版本回退速度：
svn：存储的是版本差异，每回退一个版本都需要打一次补丁，导致回退速度慢git：存储所有版本，只要找到该版本对应的提交对象，就可直接回退到该版本 服务器故障时：
svn：新写的代码不满意，不能回退到初始版本git：本地操作不受服务器限制，可任意提交、回退 总结：
svn：存储占用小git：安全、高效 git 简史 创始人：Linus Benedict Torvalds（林纳斯·托瓦兹）
git起源：
安装 下载访问： https://xjhui.lanzoux.com/iap7Odtezyf，感谢：蓝奏云
注意：如果与您的电脑版本不匹配，请访问：https://git-scm.com/download/win 下载指定版本
安装：一路next
验证安装：桌面右键，出现框选内容代表安装成功
初始化 命令：
git init # 初始化一个git仓库 案例：在/workspace下初始化一个git仓库
文件夹内右键选择 Git Bash Here：
输入指令： git init：
注意：.git为隐藏文件，若不显示请点击 查看 -&gt; 勾选 隐藏的项目
git文件（.git文件夹内）：
文件功能：
hooks：存放钩子文件（提交代码前、后要做的事，例如检查代码规范）info：说明哪些文件不需要管理objects：对象库（类似对象库，存放git对象、树对象、提交对象）refs、HEAD：分支相关内容description：仓库描述信息 git区域 三个区域：
工作区：就是你在电脑里能看到的目录暂存区：一般存放在 .git 目录下的 index 文件（." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0c7712f8d9fd3fe386f18ab8682b0a0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-21T12:31:30+08:00" />
<meta property="article:modified_time" content="2020-11-21T12:31:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">让你看看我肝了好多天的git教程吧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文章最初发布在 <a href="https://plushine.cn" rel="nofollow">XJHui’s Blog</a>，未经允许，任何人禁止转载！</p> 
<p><font color="red">注意：</font>最新修改版本已发布在 <a href="https://plushine.cn/24775.html" rel="nofollow">这里</a>，点击前往查看！</p> 
<h2><a id="_5"></a>关于笔记</h2> 
<ol><li>视频地址：<a href="https://www.bilibili.com/video/BV15J411973T?p=1" rel="nofollow">Git（中级）教程（12h深入掌握git）(28p)</a></li><li>学前基础： 
  <ul><li>linux</li><li>github</li></ul> </li><li>学后技能： 
  <ul><li>git底层、高层命令</li><li>git分支、存储、后悔药、标签</li><li>git团队协作、Pull Request</li></ul> </li></ol> 
<h2><a id="_16"></a>版本控制</h2> 
<h3><a id="svn_18"></a>集中式(svn)</h3> 
<ol><li> <p>原理：服务器存放项目的所有版本，工作时从服务器下载项目最新版本，工作完成后将代码提交到服务器</p> </li><li> <p>原理图：</p> <img src="https://images2.imgbox.com/e2/91/niqSilMi_o.png" width="70%"> </li></ol> 
<h3><a id="git_26"></a>分布式(git)</h3> 
<ol><li> <p>原理：每台电脑中都存放了项目的所有版本，即使服务器故障也不会影响工作更不会将丢失项目</p> </li><li> <p>原理图：</p> <img src="https://images2.imgbox.com/e1/2d/fIx4nCqt_o.png" width="70%"> </li></ol> 
<h3><a id="_34"></a>差异比较</h3> 
<ol><li> <p>存储方式：svn存储版本差异，git存储所有版本</p> <img src="https://images2.imgbox.com/6e/3d/rSxU9FRB_o.png" width="70%"> <p>注意：git是先压缩后存储，尽管存储占用比svn大，但不会大太多</p> </li><li> <p>安全性：</p> 
  <ul><li>svn：工作时只会下载项目最新版本，如果服务器存储故障，就无法从员工电脑恢复项目所有版本</li><li>git：每位员工电脑上都有项目的所有版本，即使服务器存储故障，任意一位员工都能恢复整个项目</li></ul> </li><li> <p>版本回退速度：</p> 
  <ul><li>svn：存储的是版本差异，每回退一个版本都需要打一次补丁，导致回退速度慢</li><li>git：存储所有版本，只要找到该版本对应的提交对象，就可直接回退到该版本</li></ul> </li><li> <p>服务器故障时：</p> 
  <ul><li>svn：新写的代码不满意，不能回退到初始版本</li><li>git：本地操作不受服务器限制，可任意提交、回退</li></ul> </li><li> <p>总结：</p> 
  <ul><li>svn：存储占用小</li><li>git：安全、高效</li></ul> </li></ol> 
<h2><a id="git_62"></a>git</h2> 
<h3><a id="_64"></a>简史</h3> 
<ol><li> <p>创始人：Linus Benedict Torvalds（林纳斯·托瓦兹）</p> <img src="https://images2.imgbox.com/d7/dc/lIW3Rdbi_o.png" width="70%"> </li><li> <p>git起源：</p> <img src="https://images2.imgbox.com/83/93/SeKqgCzW_o.png" width="70%"> </li></ol> 
<h3><a id="_74"></a>安装</h3> 
<ol><li> <p>下载访问： https://xjhui.lanzoux.com/iap7Odtezyf，感谢：蓝奏云</p> <img src="https://images2.imgbox.com/35/3d/bhPKbnNO_o.png" width="70%"> <p>注意：如果与您的电脑版本不匹配，请访问：https://git-scm.com/download/win 下载指定版本</p> <img src="https://images2.imgbox.com/49/82/aDwREB7X_o.png" width="70%"> </li><li> <p>安装：一路next</p> <img src="https://images2.imgbox.com/02/b9/XtvhVJLW_o.png" width="50%"> </li><li> <p>验证安装：桌面右键，出现框选内容代表安装成功</p> <img src="https://images2.imgbox.com/33/3f/pDTgbTaB_o.png" width="70%"> </li></ol> 
<h3><a id="_92"></a>初始化</h3> 
<ol><li> <p>命令：</p> <pre><code class="prism language-git">git init  # 初始化一个git仓库
</code></pre> </li><li> <p>案例：在/workspace下初始化一个git仓库</p> 
  <ul><li> <p>文件夹内右键选择 <code>Git Bash Here</code>：</p> <img src="https://images2.imgbox.com/26/0b/7tus6gEA_o.png" width="70%"> </li><li> <p>输入指令： <code>git init</code>：</p> <img src="https://images2.imgbox.com/38/cf/8Xk51rnB_o.png" width="70%"> <p>注意：.git为隐藏文件，若不显示请点击 <code>查看</code> -&gt; 勾选 <code>隐藏的项目</code></p> <img src="https://images2.imgbox.com/02/aa/C6Vqw958_o.png" width="70%"> </li></ul> </li><li> <p>git文件（.git文件夹内）：</p> <img src="https://images2.imgbox.com/73/4b/ATMej4j4_o.png" width="70%"> <p>文件功能：</p> 
  <ul><li>hooks：存放钩子文件（提交代码前、后要做的事，例如检查代码规范）</li><li>info：说明哪些文件不需要管理</li><li>objects：对象库（类似对象库，存放git对象、树对象、提交对象）</li><li>refs、HEAD：分支相关内容</li><li>description：仓库描述信息</li></ul> </li></ol> 
<h3><a id="git_126"></a>git区域</h3> 
<ol><li> <p>三个区域：</p> 
  <ul><li>工作区：就是你在电脑里能看到的目录</li><li>暂存区：一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们有时也把暂存区叫作索引（index）</li><li>版本库：工作区有一个隐藏目录.git</li></ul> <p>注意：暂存区是存在于版本库中的，而版本库是存在于工作区的</p> </li><li> <p>关系图：</p> <img src="https://images2.imgbox.com/46/97/dFb6XbaY_o.png" width="70%"> </li></ol> 
<h2><a id="git_140"></a>git底层概念</h2> 
<blockquote> 
 <p>底层概念代码不需要掌握，但一定得懂</p> 
</blockquote> 
<h3><a id="git_144"></a>git对象</h3> 
<ol><li> <p>定义：通过 <code>git hash-object -w</code> 命令在objects目录下生成的对象都是git对象</p> </li><li> <p>生成git对象的方法：</p> 
  <ul><li> <p>方法一：将字符串直接写入对象库</p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-git">echo 'test content' | git hash-object -w --stdin
</code></pre> <p>参数功能：</p> 
      <ul><li>-w：返回hash值并写入对象库，若不添加该参数则只返回hash值</li><li>–stdin：标准输入流读取字符串，不可省略</li></ul> <p>运行结果：</p> <img src="https://images2.imgbox.com/c1/51/V6vDy9v6_o.png" width="70%"> </li><li> <p>查看value（字符串）值：</p> 
      <ul><li> <p><code>cat</code> 命令：</p> <img src="https://images2.imgbox.com/4d/62/FvBFxFME_o.png" width="70%"> </li><li> <p><code>git cat-file -p</code> 命令：</p> <img src="https://images2.imgbox.com/af/e7/E5vPmuZL_o.png" width="70%"> </li><li> <p><code>git cat-file -t</code> 命令可查看git对象的类型：</p> <img src="https://images2.imgbox.com/fd/f7/yTdV55Vt_o.png" width="70%"> </li></ul> </li></ul> </li><li> <p>方法二：将文本文件中的字符串写入对象库</p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-git">git hash-object -w 文件名
</code></pre> <p>参数功能：</p> 
      <ul><li>-w：返回hash值并写入对象库，若不添加该参数则只返回hash值</li><li>文件名：包含文本内容的文件，不可省略</li></ul> </li><li> <p>案例1：使用 <code>git hash-object</code> 命令将test.txt文件（v1版本）内容写入到对象库</p> <img src="https://images2.imgbox.com/16/db/VBiaNYdM_o.png" width="70%"> <p>命令：</p> <pre><code class="prism language-git">git hash-object -w test.txt
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/47/82/FUZb5M0f_o.png" width="70%"> </li><li> <p>案例2：修改test.txt文件（v2版本），并再次写入对象库</p> <img src="https://images2.imgbox.com/5e/dc/CEh7n3W2_o.png" width="70%"> <p>命令：</p> <pre><code class="prism language-git">git hash-object -w test.txt
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/44/31/Awzl7i61_o.png" width="70%"> <p>使用 <code>find .git/objects/ -type f</code> 命令查看所有git对象：</p> <img src="https://images2.imgbox.com/6a/12/MZ6ZSijN_o.png" width="70%"> </li></ul> </li></ul> </li><li> <p>git对象总结：git对象仅能存储文件的内容，对文件名称的存储却无能为力</p> </li></ol> 
<h3><a id="_227"></a>树对象</h3> 
<ol><li> <p>定义：解决git对象无法存储文件名称的问题，创建树对象需要先将git对象放入暂存区</p> </li><li> <p>将git对象放入暂存区：</p> 
  <ul><li> <p>放入前查看缓存区内容：</p> <pre><code class="prism language-git">git ls-files -s
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/b8/07/dCCfTtMy_o.png" width="70%"> </li><li> <p>将git对象放入暂存区：</p> <pre><code class="prism language-git">git update-index --add --cacheinfo 100644 a0423896973644771497bdc03eb99d5281615b51 test.txt
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/91/e9/fJWDFcH4_o.png" width="70%"> <p>参数解释：</p> 
    <ul><li>–add：文件首次加入暂存区时需要添加该参数</li><li>–cacheinfo：要添加的git对象位于git对象库中，而不是位于当前目录下</li><li>文件类型：100644（ 普通文件）、100755（可执行文件）、120000（符号链接）</li></ul> </li><li> <p>放入后再次查看缓存区内容：</p> <img src="https://images2.imgbox.com/6c/63/i007mJEU_o.png" width="70%"> </li></ul> </li><li> <p>生成树对象：</p> <pre><code class="prism language-git">git write-tree
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/03/41/HmWRVMfY_o.png" width="70%"> <p>查看树对象类型：</p> <img src="https://images2.imgbox.com/5f/37/hJenEwPF_o.png" width="70%"> <p>注意：树对象也会被存储到objects目录下：</p> <img src="https://images2.imgbox.com/3d/c9/e7cLNpYl_o.png" width="70%"> <p>git、树对象差异：git对象代表文件的一次次版本，树对象代表项目的一次次版本</p> </li><li> <p>树对象的不足：</p> 
  <ul><li>objects文件中放置了git对象和树对象，很难区分开来</li><li>有git、树对象但不知道提交人、提交时间、版本差异</li></ul> </li></ol> 
<h3><a id="_288"></a>提交对象</h3> 
<img src="https://images2.imgbox.com/f5/54/n0KhPlsa_o.png" width="50%"> 
<ol><li> <p>概念：</p> 
  <ul><li>创建树对象后就要创建一个提交对象，用来存储该树对象的具体信息（提交人、时间、注释等信息）</li><li>每个提交对象分别指向一个树对象和一个父提交对象（第一个提交对象仅指向一个树对象）</li></ul> </li><li> <p>创建提交对象：</p> 
  <ul><li> <p>创建第一个提交对象：</p> <pre><code class="prism language-git">echo '注释' | git commit-tree 树对象
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/3d/9b/TYTs4P1J_o.png" width="70%"> <p>注意：第一个提交对象不需要指向父提交对象，但其他提交对象必须指向父提交对象</p> </li><li> <p>创建其它提交对象：</p> <pre><code class="prism language-git"></code></pre> </li></ul> <p>echo ‘注释’ | git commit-tree 树对象 -p 父提交对象</p> <pre><code>
运行结果：

&lt;img src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/03/9740faa72dff75a4235c671c4fdd9a9f.png" width="70%"/&gt;

查看提交对象内容：

&lt;img src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/20s/e350d2d85d6ec73cd3d6241f420567b8.png" width="70%"/&gt;

</code></pre> </li></ol> 
<h3><a id="_325"></a>命令总结</h3> 
<blockquote> 
 <p>命令中所有对象（git、树、提交对象）都要用对应hash值代替</p> 
</blockquote> 
<ol><li>git init：初始化git仓库</li><li>生成git对象： 
  <ul><li>echo “字符串” | git hash-object -w --stdin：将字符串写入对象库</li><li>git hash-object -w 文件名：将文件内容写入对象库</li></ul> </li><li>生成树对象： 
  <ul><li>git update-index --add --cacheinfo 文件类型 git对象：将git对象存入暂存区</li><li>git write-tree：生成树对象</li></ul> </li><li>生成提交对象： 
  <ul><li>echo “注释” | git commit-tree 树对象：生成第一个提交对象</li><li>echo “注释” | git commit-tree 树对象 -p 父提交对象：生成其它提交对象</li></ul> </li><li>查看对象信息： 
  <ul><li>git cat-file -t 对象：查看对象类型</li><li>git cat-file -p 对象：查看对象内容</li><li>git ls-file -s：查看暂存区内容</li><li>find .git/objects/ -type f：查看对象库中的所有对象</li></ul> </li></ol> 
<h2><a id="git_345"></a>git高层命令</h2> 
<h3><a id="_347"></a>最基本流程</h3> 
<ol><li> <p>git init：初始化git仓库</p> </li><li> <p>git add ./：给所有文件生成git对象并添加到暂存区</p> <pre><code class="prism language-git">git hash-object -w 文件名  # 等同于该命令被执行n次（n=文件数目）
git update-index --add --cacheinfo 文件类型 git对象
</code></pre> <p>注意：暂存区在版本库中，所以执行git add命令后git对象先进入版本库再进去暂存区</p> </li><li> <p>git commit -m “提交备注”：生成树对象和提交对象</p> <pre><code class="prism language-git">git write-tree  # 生成树对象
echo "备注" | git commit-tree 树对象 -p 父提交对象  # 生成提交对象
</code></pre> </li></ol> 
<h3><a id="_367"></a>查看文件</h3> 
<ol><li> <p>文件状态：未跟踪、已跟踪（已暂存、已提交、已修改）</p> <img src="https://images2.imgbox.com/7d/79/IajU31Dr_o.png" width="70%"> </li><li> <p>git status</p> 
  <blockquote> 
   <p>查看文件状态（未跟踪、已跟踪（已暂存，已提交，已修改））</p> 
  </blockquote> 
  <ul><li> <p>查看未跟踪文件的状态：</p> <pre><code class="prism language-git">echo "hello world!" &gt; laofu.txt
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c9/3d/b7IbT0Iv_o.png" width="70%"> <p>注意：新建的文件为未跟踪状态</p> </li><li> <p>查看已跟踪文件状态</p> 
    <ul><li> <p>已暂存：</p> <pre><code class="prism language-git">git add laofu.txt  # 将文件放入暂存区，add后也可跟./或文件夹
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c3/e0/sxtmHX2C_o.png" width="70%"> </li><li> <p>已提交：</p> <pre><code class="prism language-git">git commit -m "提交注释"  # 将暂存区文件提交到版本库
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/86/46/k0kJEVvi_o.png" width="70%"> <p>注意：</p> 
      <ul><li> <p>如果注释内容过多，可以使用git commit 命令在文件中键入注释：</p> <img src="https://images2.imgbox.com/2f/8e/IJfteWx1_o.png" width="70%"> </li><li> <p>对已跟踪文件，使用git commit命令时添加参数 -a，可跳过git add命令，直接提交到版本库</p> </li></ul> </li><li> <p>已修改</p> 
      <ul><li> <p>查看已提交的文件修改后状态：</p> <pre><code class="prism language-git">vim laofu.txt  # 修改已提交文件的内容
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/aa/32/nSiJGakO_o.png" width="70%"> <p>注意：虽然改文件未被暂存，但已被跟踪，可以直接使用 git commit -m 命令提交到版本库</p> </li><li> <p>查看已暂存的文件修改后的状态：</p> <pre><code class="prism language-git">git add ./  # 将文件添加到暂存区
vim laofu.txt  # 修改已暂存文件的内容
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/76/ce/NzQG5Ycf_o.png" width="70%"> <p>注意：已暂存的文件修改后会出现两种状态，必须再次执行git add命令，否则提交的内容还是上次暂存的版本</p> </li></ul> </li></ul> </li></ul> </li><li> <p>git diff</p> 
  <blockquote> 
   <p>批量查看已跟踪文件的状态</p> 
  </blockquote> 
  <ul><li> <p>查看已跟踪的文件中哪些修改需要暂存：</p> <pre><code class="prism language-git">vim laofu.txt  # 修改文件，将其变为未暂存状态
git diff  # 查看哪些更新需要暂存
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/d0/05/1lGzOwqd_o.png" width="70%"> </li><li> <p>查看已跟踪的文件中哪些暂存需要提交：</p> <pre><code class="prism language-git">git add ./  # 将文件添加到暂存区
git diff --cached  # 查看哪些暂存需要提交
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/19/65/b4kFeUFD_o.png" width="70%"> </li></ul> </li><li> <p>查看提交记录</p> 
  <ul><li> <p>详细显示提交记录：</p> <pre><code class="prism language-git">git log  # 查看提交记录（包含提交对象hash值、提交者、时间等）
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/74/ac/47ImeP5X_o.png" width="70%"> <p>注意：如果内容过多，可以按上下键翻页查看，按q键退出</p> </li><li> <p>单行显示提交记录：</p> <pre><code class="prism language-git">git log  --oneline  # 单行显示每条提交记录
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/0f/eb/8aFzpZCU_o.png" width="70%"> </li><li> <p>显示提交记录：</p> <pre><code class="prism language-git">git log --oneline --decorate --graph --all
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/ab/ed/gyVCqq0l_o.png" width="70%"> </li></ul> </li></ol> 
<h3><a id="_510"></a>删除文件</h3> 
<ol><li> <p>定义：将某个文件从工作区中删除</p> </li><li> <p>案例1：使用rm命令删除laofu.txt文件后再使用 <code>git status</code> 命令查看文件状态</p> <pre><code class="prism language-git">rm -rf laofu.txt  # 删除文件
ls  # 查看文件目录
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/ac/57/GA4TK1Cb_o.png" width="70%"> <pre><code class="prism language-git">git add ./  # 将修改加入暂存区
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/6b/66/hyhHathu_o.png" width="70%"> </li><li> <p>案例2：使用 <code>git rm</code> 命令删除已跟踪的文件，比较与rm的区别</p> <img src="https://images2.imgbox.com/9e/c0/DlKGZb9v_o.png" width="70%"> </li><li> <p>比较 <code>git rm</code> 和 <code>rm</code> ：<code>git rm</code> 与 <code>rm -rf</code> + <code>git add</code> 作用相同</p> </li></ol> 
<h3><a id="_540"></a>修改文件</h3> 
<ol><li> <p>定义：将工作区文件重命名后添加到暂存区</p> </li><li> <p>案例1：将laoliu.txt重命名为laoliuliu.txt后将其添加到暂存区，查看文件状态</p> <pre><code class="prism language-git">mv laoliu.txt laoliuliu.txt  # 文件重命名
git status  # 查看重命名后的文件状态
git add ./  # 将改名后的文件添加到暂存区
git status  # 查看重新添加到暂存区后文件的状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/d0/44/6B9h8hWD_o.png" width="70%"> </li><li> <p>案例2：使用 <code>git mv</code> 命令重命名已跟踪的文件，比较与mv的区别</p> <pre><code class="prism language-git">git mv test.txt tests.txt  # 文件重命名
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/e7/81/ESFGpHkv_o.png" width="70%"> </li><li> <p>比较 <code>git mv</code> 和 <code>mv</code> ：<code>git mv</code> 与 <code>mv</code> + <code>git add</code> 作用相同</p> </li></ol> 
<h2><a id="git_570"></a>git分支操作</h2> 
<h3><a id="_572"></a>创建分支</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git branch 分支名  # 在当前分支创建分支
git branch 分支名 提交对象  # 创建分支并指向某个提交对象
</code></pre> </li><li> <p>案例1：创建一个名为damu的分支</p> <pre><code class="prism language-git">git branch damu
git log --oneline  # 查看当前分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/70/f5/zMalbAGY_o.png" width="70%"> <p>注意：HEAD所指向的分支就是当前所在分支</p> </li><li> <p>案例2：在hash值为e319357的提交对象上创建dev分支</p> <pre><code class="prism language-git">git branch dev e319357  # 创建名为dev的分支，指向提交对象e319357
git log --oneline  # 查看当前分支信息
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/31/71/kaj3WG1E_o.png" width="70%"> <p>创建dev分支后，工作区并没有dev分支对应的文件：</p> <img src="https://images2.imgbox.com/78/0d/ew8RdDox_o.png" width="70%"> <p>注意：想要在工作区显示某个分支的文件，就要将当前分支切换到该分支</p> </li></ol> 
<h3><a id="_611"></a>切换分支</h3> 
<ol><li> <p>用途：当想给项目添加一个新功能时，就可以新建一个分支</p> 
  <ul><li>对新分支代码满意：将新分支合并到master分支，从而在项目中添加该新功能</li><li>对新分支代码不满意：回退到master分支</li></ul> </li><li> <p>语法：</p> <pre><code class="prism language-git">git checkout 分支名  # 切换分支
git checkout -b 分支名  # 创建并切换到该分支
</code></pre> <p>注意：</p> 
  <ul><li>每次切换分支之前，都要保证当前分支是干净的（git status看一下，防止分支被污染）</li><li>切换分支会改变HEAD、暂存区、工作区（版本库内容不会改变，只会无限的增多）</li></ul> </li><li> <p>案例：切换当前分支到dev分支，并显示工作区文件目录</p> <pre><code class="prism language-git">git log --oneline  # 查看当前分支信息
git checkout dev  # 切换分支为dev
ll  # 查看工作区文件目录
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c3/75/L7BAuLwr_o.png" width="70%"> <p>分支切换到dev后，由于master分支在dev分支的后面，导致使用 <code>git log</code> 命令无法显示：</p> <img src="https://images2.imgbox.com/00/c2/CsoIv6em_o.png" width="70%"> <p>可以使用 <code>git log --oneline --decorate --graph --all</code> 显示完整分支信息：</p> <img src="https://images2.imgbox.com/2e/70/eDEYQ3zF_o.png" width="70%"> </li></ol> 
<h3><a id="_650"></a>删除分支</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git branch -D 分支名  # 删除指定分支
</code></pre> <p>注意：若要删除的分支为当前所在分支则必须先切换到其它分支，不可以自己删自己</p> </li><li> <p>案例：删除分支dev</p> <pre><code class="prism language-git">git log --oneline  # 查看当前分支
git checkout master  # 切换分支到master
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/99/82/RCyKQg0m_o.png" width="70%"> <p>注意：切换到其它分支前要保证分支干净，但上图未做判断（git status）</p> <pre><code class="prism language-git">git log --oneline  # 再次查看当前分支
</code></pre> </li></ol> 
<p>git branch -D dev # 删除dev分支</p> 
<pre><code>
运行结果：

&lt;img src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/13/d6c01be3bc0bd254bc1e19f487514fa9.png" width="70%"/&gt;

注意：其实删除分支的参数是 `-d` ，`-D` 是强制删除某个分支

## 查看分支

1. 语法：

```git
git log --oneline  # 查看当前分支
git branch  # 打印分支列表
git branch -v  # 查看每个分支最后的提交信息（git log也能查看，但不够直观）
</code></pre> 
<ol start="2"><li> <p>案例：</p> 
  <ul><li> <p>查看当前所在分支：</p> <pre><code class="prism language-git">git log --oneline  # 查看当前分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/fa/53/YrgVWi5q_o.png" width="70%"> <p>注意：HEAD所指向的分支就是当前所在分支</p> </li><li> <p>打印分支列表：</p> <pre><code class="prism language-git">git branch  # 打印分支列表
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c2/10/yoLE1QAA_o.png" width="70%"> </li><li> <p>查看每个分支最后的提交信息：</p> <pre><code class="prism language-git">git branch -v  # 显示每个分支最后的提交信息
git log --oneline  # 显示当前版本信息
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/ad/31/EgqbNI07_o.png" width="70%"> </li></ul> </li></ol> 
<h3><a id="_729"></a>合并分支</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git merge 分支名  # 将当前分支与某分支合并
</code></pre> </li><li> <p>案例1：将damu分支合并到master分支（快速合并）</p> <pre><code class="prism language-git">git log --oneline  # 查看当前分支
git status  # 查看文件状态
git checkout master  # 切换到master分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c8/63/7PEulMQQ_o.png" width="70%"> <pre><code class="prism language-git">git merge damu  # 将damu分支合并到master分支
git log --oneline  # 再次查看当前分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/29/2c/OoNFlgDj_o.png" width="70%"> </li><li> <p>案例2：模拟并解决合并冲突（典型合并）</p> <pre><code class="prism language-git">git checkout -b "ct-test"  # 创建并切换到新分支
ll  # 查看文件目录
vim a.txt  # 修改a.txt
git add ./
git commit -m "2 commit for a.txt v2 for ct-test"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/de/04/LHgSHadS_o.png" width="70%"> <pre><code class="prism language-git">git status  # 切换分支前，确保分支干净
git checkout master  # 切换分支到master
vim a.txt  # 修改a.txt
git commit -am "3 commit for a.txt v2 for master"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7d/83/mikiXr3V_o.png" width="70%"> <pre><code class="prism language-git">git merge ct-test  # 将ct-test分支合并到master
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/f0/5a/etG56i7B_o.png" width="70%"> <p>注意：上图中能看到是a.txt文件冲突</p> <pre><code class="prism language-git">vim a.txt  # 查看冲突的文件
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/11/ec/uizprUDe_o.png" width="70%"> <pre><code class="prism language-git">git add ./  # 告知git冲突已经解决
git commit -m "4 commit for fix ct"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/81/1f/EslGkoUN_o.png" width="70%"> </li></ol> 
<h3><a id="_810"></a>其它内容</h3> 
<ol><li> <p>分支模式</p> 
  <ul><li>长期分支：master</li><li>特性分支：要实现某个功能而开的分支</li></ul> </li><li> <p>分支本质：提交对象</p> <img src="https://images2.imgbox.com/2a/42/QVUdFqcy_o.png" width="70%"> <p>注意：每次提交后，分支对应的提交对象都会改变</p> </li><li> <p>分支原理：</p> 
  <ul><li> <p>HEAD：存放其指向的分支名</p> <img src="https://images2.imgbox.com/0f/0c/kRdYaers_o.png" width="70%"> </li><li> <p>.git/refs/heads：存放该分支对应的提交对象</p> <img src="https://images2.imgbox.com/af/cf/8KFRXprJ_o.png" width="70%"> <p>注意：项目中的所有分支都会被存放在.git/refs/heads/master目录下</p> </li></ul> </li><li> <p>配别名：</p> 
  <ul><li> <p>将命令git status配别名为git st：</p> <pre><code class="prism language-git">git config --global alias.st "status"  # 总结配别名的规律
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/9f/4c/Vgp1zEgg_o.png" width="70%"> <p>注意：当双引号中只有一个单词时，可将双引号省略</p> </li><li> <p>将命令 git log --oneline --decorate --graph --all 配别名为 git lol：</p> <pre><code class="prism language-git">git config --global alias.lol "log --oneline --decorate --graph --all"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/92/ee/Oo8PC2YU_o.png" width="70%"> </li></ul> </li></ol> 
<h2><a id="git_859"></a>git存储</h2> 
<ol><li> <p>应用场景：要切换到其它分支，但当前分支的工作还没有完成，就可以利用git存储</p> </li><li> <p>语法：</p> <pre><code class="prism language-git">git stash list  # 查看当前分支下存储栈内容
git stash  # 保存存储，将当前分支文件存入栈中
git stash pop  # 应用栈顶存储，并将栈顶元素删除
git stash apply  # 仅应用栈顶存储
git stash drop 元素名称  # 仅删除栈中指定存储
</code></pre> <p>注意：</p> 
  <ul><li>存储后当前分支会变成干净的分支，可以切换到其它分支（其本质还是做了一次提交，只是不计入log）</li><li>栈中一般只存储一次，否则操作会很复杂</li></ul> </li><li> <p>案例：在damu分支中修改a.txt文件，存储damu分支后切换到master分支，再切换到damu分支并恢复修改</p> <pre><code class="prism language-git">git branch  # 查看当前所在分支
vim a.txt  # 修改a.txt内容
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/90/be/WveyrI0n_o.png" width="70%"> <p>注意：当前分支不干净，不能直接切换到master分支</p> <pre><code class="prism language-git">git stash  # 通过存储当前分支文件，将当前分支变为干净分支
git stash list # 查看存储栈
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/36/9e/3IkkUh5t_o.png" width="70%"> <pre><code class="prism language-git">git checkout master  # 切换分支到master
git checkout damu  # 切换分支到damu
git stash list  # 查看当前分支存储内容
git stash pop  # 应用栈顶存储，并删除栈顶内容
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/93/e7/nMX5H0sD_o.png" width="70%"> </li></ol> 
<h2><a id="git_913"></a>git后悔药</h2> 
<h3><a id="_915"></a>工作区</h3> 
<blockquote> 
 <p>撤销修改</p> 
</blockquote> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git checkout --文件名  # 撤销修改
</code></pre> </li><li> <p>案例：master分支下修改a.txt文件后撤销修改</p> <pre><code class="prism language-git">git status  # 查看文件状态
git checkout -- a.txt  # 撤销修改
git status  # 再次查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/e0/cc/2eRh9h8M_o.png" width="70%"> <p>注意：git只能撤销已跟踪的文件</p> </li></ol> 
<h3><a id="_939"></a>暂存区</h3> 
<blockquote> 
 <p>撤销暂存</p> 
</blockquote> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git restore --staged 文件名  # 撤销暂存
</code></pre> </li><li> <p>案例：修改a.txt内容并将其添加到暂存区后撤销暂存</p> <pre><code class="prism language-git">vim a.txt  # 修改文件内容
git add ./  # 将文件添加到暂存区
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7c/83/EChnGABG_o.png" width="70%"> <pre><code class="prism language-git">git restore --staged a.txt  # 撤销暂存
git status  # 查看文件状态
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/9f/44/jORunyvX_o.png" width="70%"> </li></ol> 
<h3><a id="_970"></a>版本库</h3> 
<blockquote> 
 <p>撤销提交</p> 
</blockquote> 
<ol><li> <p>场景：提交后发现注释错误，需要修改注释</p> </li><li> <p>语法：</p> <pre><code class="prism language-git">git commit --amend  # 撤销提交
</code></pre> </li><li> <p>案例1：提交a.txt后修改注释内容</p> <pre><code class="prism language-git">git commit -m "1 commit for a.txt v5"  # 提交到版本库
git lol  # 查看注释
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/49/12/F05ksx3G_o.png" width="70%"> <pre><code class="prism language-git">git commit --amend  # 撤销提交（修改注释）
git lol  # 查看注释
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/9c/60/dqpyAzN9_o.png" width="70%"> </li><li> <p>案例2：修改a.txt并将其提交到版本库，修改版本库中a.txt的内容</p> <pre><code class="prism language-git">vim a.txt  # 修改a.txt文件内容
git st  # 查看文件状态
git commit -am "1 commit for a.txt v6 50%"  # 提交到版本库
git lol  # 查看版本内容
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/0f/c6/9LJ3ga4k_o.png" width="70%"> <pre><code class="prism language-git">vim a.txt  # 再次修改a.txt文件内容
git st  # 查看文件状态
git add ./  # 将修改后的a.txt文件添加到暂存区
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/ca/b4/ZinVsVQu_o.png" width="70%"> <p>注意区分：</p> 
  <ul><li> <p>若执行：git commit --amend</p> <p>运行结果：</p> <img src="https://images2.imgbox.com/eb/a3/wcwe7qIR_o.png" width="70%"> </li><li> <p>若执行：git commit -m “1 commit for a.txt v6 50%”</p> <p>运行结果：</p> <img src="https://images2.imgbox.com/95/a5/YNrSlscO_o.png" width="70%"> </li></ul> <p>总结：</p> 
  <ul><li>使用 <code>git commit --amend</code> 命令会覆盖上次提交</li><li>使用 <code>git commit -m ""</code> 命令提交与上次提交没有关系</li></ul> </li></ol> 
<h3><a id="reset_1044"></a>reset三部曲</h3> 
<h4><a id="reset_1046"></a>reset命令</h4> 
<ol><li> <p>作用：通过移动HEAD来实现版本回退</p> </li><li> <p>HEAD移动图示：</p> <img src="https://images2.imgbox.com/cc/42/afpl9eoL_o.png" width="70%"> <p>注意：HEAD会带着分支移动，要与checkout（切换分支）区分开</p> </li><li> <p>参数：</p> 
  <ul><li>–soft：只更新版本库内容</li><li>–mixed：更新版本库、暂存区内容</li><li>–hard：更新版本库、暂存区内容</li></ul> </li></ol> 
<h4><a id="soft_1062"></a>–soft</h4> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git reset --soft HEAD~【提交对象】  # 版本回退，并更新版本库内容；HEAD~表示上一次提交，也可使用提交对象
</code></pre> </li><li> <p>案例：切换file.txt到上一次提交版本</p> <img src="https://images2.imgbox.com/37/f8/V5krdnkE_o.png" width="70%"> <pre><code class="prism language-git">git lol  # 查看当前版本
git reset --soft HEAD~  # 切换版本
git lol  # 再次查看当前版本
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/70/c9/VzctmRYo_o.png" width="70%"> <pre><code class="prism language-git">cat file.txt  # 查看工作区内容
git ls-file -s
git cat-file -p git对象  # 查看暂存区内容
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/b1/5a/WowAI5Gy_o.png" width="70%"> <p>总结：–soft参数只会更新版本库内容，不会更新暂存区、工作区内容</p> </li></ol> 
<h4><a id="mixed_1096"></a>–mixed</h4> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git reset 【--mixed】 HEAD~【提交对象】  # 版本回退，并更新版本库、暂存区内容
</code></pre> </li><li> <p>案例：切换file.txt到最后一次提交版本</p> <img src="https://images2.imgbox.com/8a/d7/keZiZsEp_o.png" width="70%"> <pre><code class="prism language-git">git reflog  # 查看第三次提交的提交对象（git reflog能显示全部提交版本）
git reset --mixed 提交对象  # 切换到最后一次提交
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7e/80/P8I2iQeX_o.png" width="70%"> <pre><code class="prism language-git">git lol  # 查看版本库变化
git ls-files -s
git cat-file -p  git对象# 查看暂存区变化
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/13/56/22Hs2njl_o.png" width="70%"> <p>总结：–mixed参数会更新版本库、暂存区内容，不会更新工作区内容</p> </li></ol> 
<h4><a id="hard_1129"></a>–hard</h4> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git reset --hard HEAD~【提交对象】  # 版本回退，并更新版本库、暂存区、工作区内容
</code></pre> </li><li> <p>案例：切换file.txt到上一次提交版本</p> <img src="https://images2.imgbox.com/02/83/eJ3YmyyF_o.png" width="70%"> <pre><code class="prism language-git">git reset --hard HEAD~  # 切换到上次提交
cat file.txt  # 查看工作区变化
git lol  # 查看版本库变化
git ls-files -s
git cat-file -p git对象  # 查看暂存区变化运行结果：
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7c/13/e475q4xQ_o.png" width="70%"> <p>总结：–hard参数会更新版本库、暂存区、工作区内容</p> </li><li> <p>区分checkout：</p> 
  <ul><li>checkout只动HEAD，–hard动HEAD而且带着当前分支一起走</li><li>checkout对工作目录是安全的，–hard是强制覆盖工作目录</li></ul> </li></ol> 
<h2><a id="tag_1160"></a>打tag</h2> 
<h3><a id="_1162"></a>标签列表</h3> 
<ol><li> <p>标签用途：想要发布项目的1.0.0版本，就可以打一个v1.0.0的标签（版本号）</p> </li><li> <p>语法：</p> <pre><code class="prism language-git">git tag  # 列出所有标签
git tag -l "1.1.0*"  # 列出所有1.1.0以后的版本
</code></pre> </li></ol> 
<h3><a id="_1173"></a>创建标签</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git tag v1.0.0  # 创建标签
git tag v1.0.0 提交对象  # 给指定提交对象创建标签
</code></pre> </li><li> <p>案例：创建一个v1.0的标签</p> <pre><code class="prism language-git">git tag v1.0  # 创建标签
git lol  # 查看标签
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/fc/b4/FLmLGgMo_o.png" width="70%"> <p>注意：创建新的提交后，tag位置不会随HEAD</p> <img src="https://images2.imgbox.com/f4/43/H2VUwLpj_o.png" width="70%"> </li></ol> 
<h3><a id="_1197"></a>查看标签</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git show v1.0  # 查看指定标签
</code></pre> </li><li> <p>案例：查看标签v1.0</p> <pre><code class="prism language-git">git show v1.0
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/cf/dc/hjqZhEDZ_o.png" width="70%"> </li></ol> 
<h3><a id="_1215"></a>删除标签</h3> 
<ol><li> <p>语法：</p> <pre><code class="prism language-git">git tag -d 标签名  # 删除指定标签
</code></pre> </li><li> <p>案例：给第一次提交打标签v1.0</p> <pre><code class="prism language-git">git tag -d v1.0  # 删除原来的v1.0标签
git lol  # 查看第一次提交的commitHash
git tag v1.0 提交对象  # 给指定提交对象打v1.0标签
git lol  # 查看版本日志
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/73/ad/k7xsqaQS_o.png" width="70%"> </li></ol> 
<h3><a id="_1236"></a>检出标签</h3> 
<ol><li> <p>用途：想查看、修改某个版本的文件内容</p> </li><li> <p>语法：</p> <pre><code class="prism language-git">git checkout "标签号"  # 先切换到指定标签
git checkout -b "标签号"  # 再给当前标签创建分支
</code></pre> <p>注意：如果仅执行 <code>git checkout "标签号"</code> 这个命令，会导致git处于“头”，“身”分离的状态</p> <img src="https://images2.imgbox.com/0a/57/S7a3rTlb_o.png" width="70%"> </li></ol> 
<h2><a id="_1251"></a>远程仓库</h2> 
<h3><a id="_1253"></a>项目经理</h3> 
<ol><li> <p>创建远程仓库</p> 
  <ul><li> <p>登录github，点击右上角“+”，选择New repository：</p> <img src="https://images2.imgbox.com/83/c6/GOlIEEEL_o.png" width="70%"> </li><li> <p>输入仓库信息：</p> <img src="https://images2.imgbox.com/bc/3e/Zy3pUzht_o.png" width="70%"> </li><li> <p>创建完成：</p> <img src="https://images2.imgbox.com/b9/82/okIrOaJh_o.png" width="70%"> </li></ul> </li><li> <p>创建工作目录</p> 
  <ul><li> <p>新建空白文件夹：</p> <img src="https://images2.imgbox.com/72/06/v4WKc7JB_o.png" width="70%"> </li><li> <p>输入命令，初始化仓库：</p> <pre><code class="prism language-git">git init  # 初始化仓库
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/2a/d8/3CYsYqU2_o.png" width="70%"> </li></ul> </li><li> <p>为远程仓库配置别名、用户信息</p> 
  <ul><li> <p>为远程仓库配置别名：</p> <pre><code class="prism language-git">git remote -v  # 显示远程仓库别名和对应url
git remote add 别名 url  # 添加一个新的远程仓库同时指定一个别名
git remote rename 别名 新别名  # 重命名远程仓库
git remote rm 别名  # 删除某个远程仓库
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/16/56/Hw92lhk9_o.png" width="70%"> </li><li> <p>配置用户信息：</p> <pre><code class="prism language-git">git config --list  # 查看配置信息
git config --global user.name "XJHui"
git config --global user.email "admin@mail.plushine.cn"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/d2/88/FoUBhlXr_o.png" width="70%"> </li><li> <p>删除配置信息：</p> <pre><code class="prism language-git">git config --list  # 查看配置信息
git config --global --unset user.name  # 删除配置信息
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/37/dd/HkWa5KCp_o.png" width="70%"> </li></ul> </li><li> <p>推送本地项目到远程仓库</p> 
  <ul><li> <p>创建文件，提交到版本库：</p> <pre><code class="prism language-git">echo "damu.txt v1" &gt; damu.txt
git add ./
git commit -m "1 commit for damu.txt v1 from taobao"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/25/d3/tPeZ4lIu_o.png" width="70%"> </li><li> <p>将版本库内容推送到远程仓库：</p> <pre><code class="prism language-git">git lol  # 查看版本库
git push 别名 分支名  # 将版本库内容推送到远程仓库
</code></pre> <p>运行结果：（下图提到的用户名和密码是github的用户名和密码，非git中所配置的用户信息）</p> <img src="https://images2.imgbox.com/bf/73/58SkDWiw_o.png" width="70%"> <p>推送成功：</p> <img src="https://images2.imgbox.com/7d/e8/Hmu4bViK_o.png" width="70%"> </li></ul> </li><li> <p>邀请成员</p> 
  <ul><li> <p>进入项目设置-》Settings-》Manage access-》Invite a collaborator：</p> <img src="https://images2.imgbox.com/c8/2e/t8es9rUZ_o.png" width="70%"> </li><li> <p>输入用户名，搜索成员：</p> <img src="https://images2.imgbox.com/c4/e6/qEMM9b5Y_o.png" width="70%"> </li><li> <p>等待成员同意邀请：</p> <img src="https://images2.imgbox.com/ba/af/GzHCQ1fN_o.png" width="70%"> <p>成员访问邀请链接：</p> <img src="https://images2.imgbox.com/c0/16/FSn8tI5Z_o.png" width="70%"> </li></ul> </li></ol> 
<h3><a id="_1370"></a>成员操作</h3> 
<ol><li> <p>克隆仓库到本地</p> 
  <ul><li> <p>创建文件夹，克隆项目：</p> <pre><code class="prism language-git">git clone url  # 克隆远程仓库
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/4f/81/hI7tyv1t_o.png" width="70%"> <p>注意：</p> 
    <ul><li>克隆后会生成一个与远程仓库同名的文件夹存放项目文件</li><li>成员克隆项目前不需要执行 <code>git init</code> 命令</li></ul> </li><li> <p>查看克隆的项目：</p> <pre><code class="prism language-git">cd git-study  # 进入文件夹
ll  # 查看文件目录
cat damu.txt  # 查看文件内容
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/06/31/aR7IT6GZ_o.png" width="70%"> </li><li> <p>查看项目默认别名：</p> <pre><code class="prism language-git">git remote -v
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7f/26/tAGc1Ewe_o.png" width="70%"> <p>注意：克隆下来的仓库别名默认为origin</p> </li></ul> </li><li> <p>修改文件，推送提交：</p> <pre><code class="prism language-git">echo "plushine.txt v1" &gt; plushine.txt  # 新建文件
git add ./
git commit -m "2 commit for plushine.cn v1 from plushine"
git push origin master  # 推送到远程仓库
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/d9/4d/EgtPbZsG_o.png" width="70%"> </li><li> <p>补充：本地分支、远程分支、跟踪分支（远程跟踪分支，本地分支和远程分支之间的媒介）</p> <img src="https://images2.imgbox.com/0a/f0/7KQVXokp_o.png" width="70%"> </li></ol> 
<h3><a id="_1430"></a>更新内容</h3> 
<ol><li> <p>场景：当团队中其它成员向远程仓库中提交了新的代码，就需要将自己电脑上的内容更新</p> </li><li> <p>案例：更新项目经理电脑上的内容</p> <pre><code class="prism language-git">ll  # 查看文件列表
git remote -v  # 查看别名
git fetch 别名  # 内容会更新到跟踪分支上
ll  # 再次查看文件列表
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/c6/67/R1IkGrlP_o.png" width="70%"> <pre><code class="prism language-git">git status  # 切换分支前保证分支干净
git checkout  跟踪分支  # 切换当前分支到跟踪分支
ll  # 查看文件目录
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/7e/65/R71OQFop_o.png" width="70%"> <pre><code class="prism language-git">git checkout master  # 切换分支到master
git merge taobao/master  # 将跟踪分支内容合并到本地分支
ls  # 查看文件目录
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/66/58/8FDRLl5c_o.png" width="70%"> </li></ol> 
<h3><a id="pushpull_1467"></a>push和pull</h3> 
<ol><li> <p>如果本地分支跟踪了远程跟踪分支就可以直接使用git push和git pull命令上传和拉取文件，否则：</p> 
  <ul><li>上传：git push 别名 分支名</li><li>拉取：git fetch 别名，git merge 远程跟踪分支</li></ul> </li><li> <p>判断是否跟踪：</p> <pre><code class="prism language-git">git branch -vv  # 查看本地分支是否跟踪远程跟踪分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/10/db/7VUTqVH3_o.png" width="70%"> <p>注意：上图中存在联系即代表已跟踪，不存在联系代表未跟踪</p> </li><li> <p>如何让本地分支跟踪远程跟踪分支</p> 
  <ul><li> <p>clone仓库时本地分支会自动跟踪远程跟踪分支（成员可直接执行 git push 和 git pull 命令）</p> </li><li> <p>在新建分支时，可以让本地分支跟踪指定的远程跟踪分支：</p> <pre><code class="prism language-git">git checkout -b 本地分支名 跟踪分支名  # 新建本地分支，并让本地分支跟踪远程跟踪分支
git checkout --track 远程跟踪分支名  # 新建与远程跟踪分支同名的本地分支，并让本地分支跟踪远程跟踪分支
</code></pre> <p>注意：存在远程跟踪分支时才能使用该命令，可以使用 <code>git fetch</code> 命令生成远程跟踪分支</p> </li><li> <p>让已存在的本地分支跟踪远程跟踪分支：</p> <pre><code class="prism language-git">git branch -u 远程分支名
</code></pre> <p>注意：同时存在本地分支、远程跟踪分支时才能使用该命令（git lol判断是否存在）</p> </li></ul> </li><li> <p>案例：a、b两个文件夹分别代表团队项目经理和成员，模拟使用 git pull 和 git push 命令</p> 
  <ul><li> <p>a中创建分支zdy和文件zdy.txt：</p> <pre><code class="prism language-git">git checkout -b zdy  # 创建并切换到新分支
echo 'zdy.txt v1' &gt; zdy.txt
git add ./
git commit -m "2 commit for zdy.txt v1 from a"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/6b/34/rdYXTQ5V_o.png" width="70%"> <pre><code class="prism language-git">git push  # 上传分支
git push git-study zdy  # 上传分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/db/c3/J3cCiNnr_o.png" width="70%"> <p>注意：</p> 
    <ul><li>新分支要用 <code>git push 别名 分支名</code> 上传，<code>git branch -u</code> 也无法创建联系，因为没有远程跟踪分支</li><li>执行命令 <code>git push git-study zdy</code> 后，git会自动创建远程跟踪分支，但本地分支并不会自动跟踪它</li></ul> </li><li> <p>b从仓库获取zdy分支并修改zdy.txt文件：</p> <pre><code class="prism language-git">git pull  # 成员b克隆仓库代码后本地分支会自动跟踪远程跟踪分支，所以可以使用git pull命令
git lol
git checkout --track origin/zdy  # b中创建zdy本地分支，并跟踪远程跟踪分支
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/b7/40/FzkfKi6V_o.png" width="70%"> <pre><code class="prism language-git">vim zdy.txt
git add ./
git commit -m "3 commit for zdy.txt v2 from b"
git push  # 上传修改
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/00/62/CsRUFzio_o.png" width="70%"> </li><li> <p>a再次获取zdy分支内容：</p> <pre><code class="prism language-git">git pull # 拉取仓库
git branch -u git-study/zdy  # 让本地分支跟踪远程跟踪分支
git pull # 拉取仓库
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/e1/95/51ubDfee_o.png" width="70%"> <pre><code class="prism language-git">cat zdy.txt
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/1c/a6/BJ4gpJWV_o.png" width="70%"> </li></ul> </li></ol> 
<h3><a id="_1579"></a>远程冲突</h3> 
<ol><li> <p>冲突场合：本地操作（典型合并）、远程协作（push、pull）</p> </li><li> <p>案例1：模拟并解决push冲突（a为项目经理，b为团队成员）</p> 
  <ul><li> <p>仓库内容：</p> <img src="https://images2.imgbox.com/24/4a/VnR7BmRq_o.png" width="70%"> </li><li> <p>a中修改a.txt并push到远程仓库：</p> <pre><code class="prism language-git">vim a.txt
</code></pre> </li></ul> <p>git add ./<br> git commit -m “2 commit for a.txt v2 from a”<br> git push git-study master # 本地分支未跟踪远程跟踪分支，不能使用git push命令</p> <pre><code>
运行结果：

&lt;img src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/18/8a17ccf11ef63255ecfdacaf17478159.png" width="70%"/&gt;

- b也修改a.txt并push到远程仓库：

```git
vim a.txt
git add ./
git commit -m "2 commit for a.txt v2 from b"
git push
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/cb/3f/OdsvbpE0_o.png" width="70%"> <p>上图提示：当前推送所修改的内容在仓库已经做了修改，可以先git pull 拉取仓库内容，解决冲突后重新推送</p> 
  <ul><li> <p>b中拉取仓库内容：</p> <pre><code class="prism language-git">git pull
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/68/c3/CXLAfDfF_o.png" width="70%"> <pre><code class="prism language-git">vim a.txt  # 修改冲突
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/f4/2d/UXq7gZXs_o.png" width="70%"> <pre><code class="prism language-git">git add ./  # 告知git冲突已经解决
git commit -m "4 commit for fix a.txt conflict"
git push  # 再次推送
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/bc/41/XyHGdu7Z_o.png" width="70%"> </li></ul> </li><li> <p>案例2：模拟并解决pull冲突（a为项目经理，b为团队成员）</p> 
  <ul><li> <p>在案例1基础上，a拉取仓库内容：</p> <pre><code class="prism language-git">git branch -u git-study/master  # 本地分支跟踪远程跟踪分支
git pull  # 拉取仓库内容
cat a.txt  # 查看文件内容
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/10/85/wp3dpTrc_o.png" width="70%"> </li><li> <p>a中修改a.txt文件并推送到远程仓库：</p> <pre><code class="prism language-git">vim a.txt
git add ./
git commit -m "5 commit for a.txt v3 from a"
git push
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/55/d1/kjOOdS9h_o.png" width="70%"> </li><li> <p>b中修改a.txt文件，提交后使用git pull命令拉取仓库内容：</p> <pre><code class="prism language-git">vim a.txt
git add ./
git commit -m "6 commit for a.txt v3 from b"
git pull
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/b2/fd/IPgkBu09_o.png" width="70%"> <pre><code class="prism language-git">vim a.txt  # 解决冲突
git add ./  # 告知git冲突已解决
git commit -m "7 commit for fix a.txt conflict"
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/5f/52/aJgJ3NR1_o.png" width="70%"> </li></ul> </li></ol> 
<h3><a id="Pull_Request_1695"></a>Pull Request</h3> 
<ol><li> <p>场景：当你想要参与修改某个项目，但没有推送权限，这时可以对这个项目进行“派生”（fork，在你的github空间中创建一个完全属于你的项目副本），将自己的修改提交到派生出的项目副本中并创建PR（Pull Request）请求，项目所有者审核同意后你所修改的内容就会进入源版本库。</p> <img src="https://images2.imgbox.com/ea/c0/rQdCd5kj_o.png" width="70%"> </li><li> <p>基本流程：</p> 
  <ul><li>fork项目，clone副本项目到工作区</li><li>修改文件，push到仓库，创建PR</li><li>项目所有者审核，提交成功（失败）</li></ul> </li><li> <p>案例：模拟使用PR（xingjiahui：项目创建者，PluShine：无推送权限但想参与修改）</p> 
  <ul><li> <p>fork项目：</p> <img src="https://images2.imgbox.com/0c/f4/4TyTdsGk_o.png" width="70%"> <p>fork后PluShine新增了项目副本仓库：</p> <img src="https://images2.imgbox.com/33/b7/f9fzwqB4_o.png" width="70%"> </li><li> <p>克隆副本仓库，push修改内容：</p> <pre><code class="prism language-git">git clone https://github.com/PluShine/git-study.git
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/e7/03/mone4bk4_o.png" width="70%"> <pre><code class="prism language-git">vim a.txt
git add ./
git commit -m "7 commit for a.txt bug fix from PluShine"
git push
</code></pre> <p>运行结果：</p> <img src="https://images2.imgbox.com/a1/a4/4e78oedz_o.png" width="70%"> <p>进入仓库，创建Pull Request：</p> <img src="https://images2.imgbox.com/99/81/XmzXbYci_o.png" width="70%"> <p>PR创建成功：</p> <img src="https://images2.imgbox.com/95/84/h16khro1_o.png" width="70%"> </li><li> <p>项目创建者审核PR：</p> <img src="https://images2.imgbox.com/05/97/6wJPpIvg_o.png" width="70%"> <p>合并提交：</p> <img src="https://images2.imgbox.com/1e/d5/3x5XdXBv_o.png" width="70%"> <p>合并成功：</p> <img src="https://images2.imgbox.com/df/fa/rAPKWZg5_o.png" width="70%"> </li></ul> </li></ol> 
<hr> 
<p>不足之处，欢迎留言，会及时回复，及时更正！</p> 
<p>创作不易，感谢支持！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee25c6bf8652902e1b9523d2a534b8f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python雨课堂答案_python实现雨课堂自动预习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a123c6256529f5af64ffe354bd2d38d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言樱花飘落代码_&amp;quot;云&amp;quot;看花，教你用Python画樱花</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>