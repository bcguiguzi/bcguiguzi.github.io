<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库的事务 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库的事务" />
<meta property="og:description" content="一、什么是事务？ 事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。
转账业务：必须同时成功或失败 二、事务的特性 ① 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；例如转账的这两个关键操作（将张三的余额减少200元，将李四的余额增加200元）要么全部完成，要么全部失败。
② 一致性： 确保从一个正确的状态转换到另外一个正确的状态，这就是一致性。例如转账业务中，将张三的余额减少200元，中间发生断电情况，李四的余额没有增加200元，这个就是不正确的状态，违反一致性。又比如表更新事务，一部分数据更新了，但一部分数据没有更新，这也是违反一致性的；
③ 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
④ 持久性：一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
三、事务间的相互影响 脏读，丢失更新，不可重复读，幻读 是因为事务之间的相互影响造成的
脏读：事务2读取到了事务1未提交的数据。例如：事务1修改数据库数据a，修改成a&#43;1，但是事务1还未提交。此时事务2，查询此数据，查到的是a&#43;1。此时事务1，做了回滚操作。数据库数据还是a，但是事务2查询到的是a&#43;1。
不可重复读：事务1对数据a做查询，未结束时，事务2修改数据库数据a，修改（update）成a&#43;1，事务1（未结束的事务）再次对数据a查询。查询到数据为a&#43;1。两次查询结果不一致。
幻读：事务1根据某条件（name=小王）查询，查询到数据a。在事务1未结束时，事务2增添（insert）了数据b，其中b对应的name是小王（符合事务1的查询条件）。此时事务1再次根据此条件（name=小王）查询，查询到了数据a和数据b。两次查询结果不一致。
不可重复读和幻读的主要区分是update操作和insert操作 四、事务的隔离级别以及原理 读未提交（Read uncommitted）：可能会出现脏读，重复读，幻读；
读已提交（Read committed）：可能会出现重复读，幻读（mysql默认的隔离级别）；
重复读（Repeatable read）：可能会出现幻读。带来了更多的性能损失；
串读（Serializable ）：不会引发事务之间的相互影响，但是事务串行执行资源消耗巨大。
原理：
不同的隔离级别是通过加锁来实现的。
共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。
排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。
读未提交（Read uncommitted）：
事务对当前数据读取时不加锁事务对数据更新时添加行级共享锁，直到事务结束释放锁 读已提交（Read committed）：
事务对当前读取的数据加行级共享锁（不被其他事务修改），读完之后立即释放此共享锁；事务对数据更新瞬间会添加行级排它锁，直到事务结束释放锁 重复读（Repeatable read）：
事务在读取的数据的瞬间加行级共享锁（不被其他事务修改），直到事务结束释放锁；事务对数据更新瞬间会添加行级排它锁，直到事务结束释放锁 串读（Serializable ）：
事务在读取的数据的瞬间加表级排他锁，直到事务结束释放锁；串读的本质是串行化，只能做一种操作，其他别的操作会被阻止，所以也会很大程度影响效率。 五、事务的传播机制 REQUIRED
如果当前方法有事务则加入事务，没有则创建一个事务。
NOT_SUPPORTED
不支持事务，如果当前有事务则挂起事务运行。
REQUIREDS_NEW
新建一个事务并在这个事务中运行，如果当前存在事务就把当前事务挂起。新建的事务的提交与回滚一挂起事务没有联系，不会影响挂起事务的操作。
MANDATORY
强制当前方法使用事务运行，如果当前没有事务则抛出异常。
NEVER
当前方法不能存在事务，即非事务状态运行，如果存在事务则抛出异常。
SUPPORTS
支持当前事务，如果当前没事务也支持非事务状态运行。
NESTED
如果当前存在事务，则在嵌套事务内执行。嵌套事务的提交与回滚与父事务没有任务关系，反之，当父事务提交嵌套事务也一起提交，父事务回滚会也回滚嵌套事务的。
如果当前没有事务，则新建一个事务运行，这时候则与PROPAGATION_REQUIRED场景一致。
六、@Transactional 注解控制事务有哪些不生效的场景 1、数据库引擎不支持事务 这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b02fc6ec8e1672b8e965b851488545f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-08T09:20:19+08:00" />
<meta property="article:modified_time" content="2022-10-08T09:20:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库的事务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、什么是事务？</h3> 
<blockquote> 
 <p><strong>事务是逻辑上的一组数据库操作，要么都执行，要么都不执行</strong>。</p> 
</blockquote> 
<p>转账业务：必须同时成功或失败 </p> 
<h3>二、事务的特性</h3> 
<p><strong>① 原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；例如转账的这两个关键操作（将张三的余额减少200元，将李四的余额增加200元）要么全部完成，要么全部失败。</p> 
<p><strong>② 一致性</strong>： 确保从一个正确的状态转换到另外一个正确的状态，这就是一致性。例如转账业务中，将张三的余额减少200元，中间发生断电情况，李四的余额没有增加200元，这个就是不正确的状态，违反一致性。又比如表更新事务，一部分数据更新了，但一部分数据没有更新，这也是违反一致性的；</p> 
<p><strong>③ 隔离性</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p> 
<p><strong>④ 持久性</strong>：一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>  </p> 
<h3>三、事务间的相互影响</h3> 
<blockquote> 
 <p><strong>脏读，丢失更新，不可重复读，幻读 是因为事务之间的相互影响造成的</strong></p> 
</blockquote> 
<p><strong>脏读</strong>：<span style="background-color:#fbd4d0;">事务2</span>读取到了<span style="background-color:#d4e9d5;">事务1</span>未提交的数据。例如：<span style="background-color:#d4e9d5;">事务1</span>修改数据库数据a，修改成a+1，但是<span style="background-color:#d4e9d5;">事务1</span>还未提交。此时<span style="background-color:#fbd4d0;">事务2</span>，查询此数据，查到的是a+1。此时<span style="background-color:#d4e9d5;">事务1</span>，做了回滚操作。数据库数据还是a，但是<span style="background-color:#fbd4d0;">事务2</span>查询到的是a+1。</p> 
<p><strong>不可重复读</strong>：<span style="background-color:#c7e6ea;">事务1</span>对数据a做查询，未结束时，<span style="background-color:#ffd7b9;">事务2</span>修改数据库数据a，修改（<span style="background-color:#faa572;">update</span>）成a+1，<span style="background-color:#c7e6ea;">事务1</span>（未结束的事务）再次对数据a查询。查询到数据为a+1。两次查询结果不一致。</p> 
<p><strong>幻读</strong>：<span style="background-color:#cbe0f1;">事务1</span>根据某条件（name=小王）查询，查询到数据a。在<span style="background-color:#cbe0f1;">事务1</span>未结束时，<span style="background-color:#f9eda6;">事务2</span>增添（<span style="background-color:#faa572;">insert</span>）了数据b，其中b对应的name是小王（符合<span style="background-color:#cbe0f1;">事务1</span>的查询条件）。此时<span style="background-color:#cbe0f1;">事务1</span>再次根据此条件（name=小王）查询，查询到了数据a和数据b。两次查询结果不一致。</p> 
<blockquote> 
 <h3>不可重复读和幻读的主要区分是update操作和insert操作</h3> 
</blockquote> 
<h3>四、事务的隔离级别以及原理</h3> 
<p><strong>读未提交（Read uncommitted）：</strong>可能会出现脏读，重复读，幻读；</p> 
<p><strong>读已提交（Read committed）：</strong>可能会出现重复读，幻读（mysql默认的隔离级别）；</p> 
<p><strong>重复读（Repeatable read）：</strong>可能会出现幻读。带来了更多的性能损失；</p> 
<p><strong>串读（Serializable ）：</strong>不会引发事务之间的相互影响，但是事务串行执行资源消耗巨大。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/e8/c1/gtq6vSLK_o.png" width="519"></p> 
<p><strong>原理</strong>：</p> 
<p>不同的隔离级别是通过加锁来实现的。</p> 
<p><strong>共享锁</strong>(S锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>可以</strong>读数据A，<strong>不能</strong>修改数据A。<br><strong>排他锁</strong>(X锁):假设事务T1对数据A加上排他锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A。</p> 
<p><strong>读未提交（Read uncommitted）：</strong></p> 
<ul><li>事务对当前数据读取时<span style="background-color:#fbd4d0;">不加锁</span></li><li>事务对数据更新时添加<span style="background-color:#f9eda6;">行级<strong>共享</strong>锁</span>，直到事务结束释放锁</li></ul> 
<p><strong>读已提交（Read committed）：</strong></p> 
<ul><li>事务对当前<span style="background-color:#d7d8d9;">读取的数据加</span><span style="background-color:#fbd4d0;">行级共享锁</span>（不被其他事务修改），<strong><span style="background-color:#fbd4d0;">读完之后</span></strong>立即释放此共享锁；</li><li>事务对数据更新瞬间会添加<span style="background-color:#f9eda6;">行级<strong>排它</strong>锁</span>，直到事务结束释放锁</li></ul> 
<p><strong>重复读（Repeatable read）：</strong></p> 
<ul><li>事务在读取的数据的瞬间加行级共享锁（不被其他事务修改），直到<strong><span style="background-color:#fbd4d0;">事务结束</span></strong>释放锁；</li><li>事务对数据更新瞬间会添加<span style="background-color:#f9eda6;">行级<strong>排它</strong>锁</span>，直到事务结束释放锁</li></ul> 
<p><strong>串读（Serializable ）：</strong></p> 
<ul><li>事务在读取的数据的瞬间加<span style="background-color:#c7e6ea;">表级排他锁</span>，直到事务结束释放锁；</li><li>串读的本质是串行化，只能做一种操作，其他别的操作会被阻止，所以也会很大程度影响效率。</li></ul> 
<h3>五、事务的传播机制</h3> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">REQUIRED</span></strong></span></p> 
<p>如果当前方法有事务则加入事务，没有则创建一个事务。</p> 
<p><strong><span style="background-color:#ffd7b9;">NOT_SUPPORTED</span></strong></p> 
<p>不支持事务，如果当前有事务则挂起事务运行。</p> 
<p><strong><span style="background-color:#f9eda6;">REQUIREDS_NEW</span></strong></p> 
<p>新建一个事务并在这个事务中运行，如果当前存在事务就把当前事务挂起。新建的事务的提交与回滚一挂起事务没有联系，不会影响挂起事务的操作。</p> 
<p><strong><span style="background-color:#d4e9d5;">MANDATORY</span></strong></p> 
<p>强制当前方法使用事务运行，如果当前没有事务则抛出异常。</p> 
<p><strong><span style="background-color:#c7e6ea;">NEVER</span></strong></p> 
<p>当前方法不能存在事务，即非事务状态运行，如果存在事务则抛出异常。</p> 
<p><strong><span style="background-color:#cbe0f1;">SUPPORTS</span></strong></p> 
<p>支持当前事务，如果当前没事务也支持非事务状态运行。</p> 
<p><strong><span style="background-color:#dad5e9;">NESTED</span></strong></p> 
<p>如果当前存在事务，则在嵌套事务内执行。嵌套事务的提交与回滚与父事务没有任务关系，反之，当父事务提交嵌套事务也一起提交，父事务回滚会也回滚嵌套事务的。</p> 
<p>如果当前没有事务，则新建一个事务运行，这时候则与PROPAGATION_REQUIRED场景一致。</p> 
<h3>六、<code>@Transactional</code> 注解控制事务有哪些不生效的场景</h3> 
<h4>1、<strong>数据库引擎不支持事务</strong></h4> 
<p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，<span style="background-color:#d4e9d5;">InnoDB</span> 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。</p> 
<p>从 MySQL 5.5.5 开始的默认存储引擎是：InnoDB，之前默认的都是：MyISAM，所以这点要值得注意，底层引擎不支持事务再怎么搞都是白搭。</p> 
<h4>2、<strong>没有被 Spring 管理 </strong></h4> 
<p>如下面例子所示：</p> 
<pre><code class="language-java">// @Service

public class OrderServiceImpl implements OrderService {


    @Transactional

    public void updateOrder(Order order) {

        // update order

    }


}</code></pre> 
<p>如果此时把 <code><span style="background-color:#ffd7b9;">@Service</span></code><span style="background-color:#ffd7b9;"> </span>注解<span style="background-color:#c7e6ea;">注释掉</span>，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。</p> 
<h4>3、<strong>方法不是 public 的</strong></h4> 
<p>以下来自 Spring 官方文档：</p> 
<blockquote> 
 <p>When using proxies, you should apply the @<a href="https://so.csdn.net/so/search?q=Transactional&amp;spm=1001.2101.3001.7020" title="Transactional">Transactional</a> annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p> 
</blockquote> 
<p>大概意思就是 <code><span style="background-color:#fbd4d0;">@Transactional</span></code><span style="background-color:#fbd4d0;"> 只能用于</span><span style="background-color:#edf6e8;"> public</span><span style="background-color:#fbd4d0;"> 的方法上</span>，否则事务不会失效，如果要用在非 public 方法上，可以开启 <code>AspectJ</code> 代理模式。</p> 
<h4>4、<strong>自身调用问题</strong></h4> 
<p>来看两个示例：</p> 
<pre><code class="language-java">@Service

public class OrderServiceImpl implements OrderService {


    public void update(Order order) {

        updateOrder(order);

    }


    @Transactional

    public void updateOrder(Order order) {

        // update order

    }


}</code></pre> 
<p>update方法上面没有加 <code>@Transactional</code> 注解，调用有 <code>@Transactional</code> 注解的 updateOrder 方法，updateOrder 方法上的事务管用吗？<span style="background-color:#fbd4d0;">不管用</span></p> 
<p>再来看下面这个例子：</p> 
<pre><code class="language-java">@Service

public class OrderServiceImpl implements OrderService {


    @Transactional

    public void update(Order order) {

        updateOrder(order);

    }


    @Transactional(propagation = Propagation.REQUIRES_NEW)

    public void updateOrder(Order order) {

        // update order

    }


}</code></pre> 
<p>这次在 update 方法上加了 <code>@Transactional</code>，updateOrder 加了 <code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？<span style="background-color:#fbd4d0;">不管用！</span></p> 
<p><span style="background-color:#edf6e8;">因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效</span>。</p> 
<p>这个的解决方案之一就是在的类中注入自己，用注入的对象再调用另外一个方法，这个不太优雅，另外一个可行的方案可以参考《<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247491775&amp;idx=2&amp;sn=142f1d6ab0415f17a413a852efbde54f&amp;scene=21#wechat_redirect" rel="nofollow" title="Spring 如何在一事务失效的事务个事务中开启另一个事务？">Spring 如何在一事务失效的事务个事务中开启另一个事务？</a>》这篇文章。</p> 
<h4>5、<strong>数据源没有配置事务管理器</strong></h4> 
<pre><code class="language-java">@Bean

public PlatformTransactionManager transactionManager(DataSource dataSource) {

    return new DataSourceTransactionManager(dataSource);

}</code></pre> 
<p>如上面所示，当前数据源若没有配置事务管理器，那也是白搭！</p> 
<h4>6、<strong>不支持事务</strong></h4> 
<p>来看下面这个例子：</p> 
<pre><code class="language-java">@Service

public class OrderServiceImpl implements OrderService {


    @Transactional

    public void update(Order order) {

        updateOrder(order);

    }


    @Transactional(propagation = Propagation.NOT_SUPPORTED)

    public void updateOrder(Order order) {

        // update order

    }


}</code></pre> 
<p> <strong>Propagation.NOT_SUPPORTED：</strong> 表示不以事务运行，当前若存在事务则挂起</p> 
<p>都主动不支持以事务方式运行了，那事务生效也是白搭！</p> 
<h4>7、<strong>异常被吃了</strong></h4> 
<p>这个也是出现比较多的场景：</p> 
<pre><code class="language-java">// @Service

public class OrderServiceImpl implements OrderService {


    @Transactional

    public void updateOrder(Order order) {

        try {

            // update order

        } catch {


        }

    }


}</code></pre> 
<p> 把异常吃了，然后又不抛出来，事务怎么回滚吧！</p> 
<h4>8、<strong>异常类型错误</strong></h4> 
<p>上面的例子再抛出一个异常：</p> 
<pre><code class="language-java">// @Service

public class OrderServiceImpl implements OrderService {


    @Transactional

    public void updateOrder(Order order) {

        try {

            // update order

        } catch {

            throw new Exception("更新错误");

        }

    }


}</code></pre> 
<p>这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如：</p> 
<div> 
 <pre><code>@Transactional(rollbackFor = Exception.class)
</code></pre> 
</div> 
<p>这个配置仅限于 <code>Throwable</code> 异常类及其子类。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b9716167adea0de3b4ad4e058a180b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;常用性能分析工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a23aa60982b0a9bccf2b8c2c1600d89c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录 ｜CentOS7 arm架构配置yum包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>