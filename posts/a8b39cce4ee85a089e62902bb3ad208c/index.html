<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸" />
<meta property="og:description" content="分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸
自己总结的面试简历资料：https://pan.quark.cn/s/8b602fe53b58
文章目录 SSMspring============================================spring 的优点？IoC和AOP的理解**Bean 的生命周期****列举一些重要的Spring模块？****Spring框架中用到了哪些设计模式****@Component和@Bean的区别是什么****Spring事务管理的方式有几种？****Spring事务中的隔离级别有哪几种？****Spring事务中有哪几种事务传播行为？**spring常用的注入方式有哪些？spring中的bean是线程安全的吗？ springmvc===================================SpringMVC的流程？JSP 九大内置对象和四大作用域spring mvc有哪些组件？@RequestMapping的作用是什么？@Autowired的作用是什么？@Autowired 与@Resource的区别Springmvc的优点:FactoryBean 与 BeanFactory 有什么区别？@Transactional 注解哪些情况下会失效？项目中如何用 Spring 和 Spring MVC 框架的？ mybatis=======================================MyBatis是什么？有什么作用？Mybaits 的优缺点#{} 和 ${} 的区别MyBatis 中实体类的属性名与表中的字段名不一致怎么处理？Mapper 接口如何与写 SQL 的 XML 文件进行绑定的？MyBatis 如何批量插入？MyBatis 是如何与 Spring 集成的？ springboot====================================**为什么要用 Spring Boot？****Spring Boot 的核心配置文件有哪几个？它们的区别是什么？****Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**常用注解**开启 Spring Boot 特性有哪几种方式？****运行 Spring Boot 有哪几种方式？****Spring Boot 自动配置原理是什么？**SpringBoot 有几种读取配置文件的方式**你如何理解 Spring Boot 配置加载顺序？****Spring Boot 如何定义多套不同环境配置？****Spring Boot 可以兼容老 Spring 项目吗，如何做？** springCloud微服务架构====================什么是微服务架构Spring Cloud 是什么SpringCloud的优缺点SpringBoot和SpringCloud的区别？pringCloud由什么组成Spring Cloud 和dubbo区别?Eureka服务注册和发现是什么意思？Spring Cloud 如何实现？什么是EurekaEureka怎么实现高可用什么是Eureka的自我保护模式，DiscoveryClient的作用Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 Zuul什么是网关?网关的作用是什么网关与过滤器有什么区别常用网关框架有那些？Zuul与Nginx有什么区别？既然Nginx可以实现网关？为什么还需要使用Zuul框架Zuul网关如何搭建集群 Ribbon负载平衡的意义什么？Ribbon是什么？Nginx与Ribbon的区别Ribbon底层实现原理@LoadBalanced注解的作用 Hystrix什么是断路器什么是 Hystrix？谈谈服务雪崩效应在微服务中，如何保护服务?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a8b39cce4ee85a089e62902bb3ad208c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-17T13:33:22+08:00" />
<meta property="article:modified_time" content="2024-03-17T13:33:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸</strong></p> 
<p><strong>自己总结的面试简历资料：https://pan.quark.cn/s/8b602fe53b58</strong><br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#SSM_4" rel="nofollow">SSM</a></li><li><a href="#spring_8" rel="nofollow">spring============================================</a></li><li><ul><li><ul><li><a href="#spring__16" rel="nofollow">spring 的优点？</a></li><li><a href="#IoCAOP_29" rel="nofollow">IoC和AOP的理解</a></li><li><a href="#Bean__54" rel="nofollow">**Bean 的生命周期**</a></li><li><a href="#Spring_72" rel="nofollow">**列举一些重要的Spring模块？**</a></li><li><a href="#Spring_90" rel="nofollow">**Spring框架中用到了哪些设计模式**</a></li><li><a href="#ComponentBean_106" rel="nofollow">**@Component和@Bean的区别是什么**</a></li><li><a href="#Spring_114" rel="nofollow">**Spring事务管理的方式有几种？**</a></li><li><a href="#Spring_120" rel="nofollow">**Spring事务中的隔离级别有哪几种？**</a></li><li><a href="#Spring_128" rel="nofollow">**Spring事务中有哪几种事务传播行为？**</a></li><li><a href="#spring_148" rel="nofollow">spring常用的注入方式有哪些？</a></li><li><a href="#springbean_167" rel="nofollow">spring中的bean是线程安全的吗？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#springmvc_172" rel="nofollow">springmvc===================================</a></li><li><ul><li><ul><li><a href="#SpringMVC_182" rel="nofollow">SpringMVC的流程？</a></li><li><a href="#JSP__186" rel="nofollow">JSP 九大内置对象和四大作用域</a></li><li><a href="#spring_mvc_208" rel="nofollow">spring mvc有哪些组件？</a></li><li><a href="#RequestMapping_225" rel="nofollow">@RequestMapping的作用是什么？</a></li><li><a href="#Autowired_231" rel="nofollow">@Autowired的作用是什么？</a></li><li><a href="#Autowired_Resource_236" rel="nofollow">@Autowired 与@Resource的区别</a></li><li><a href="#Springmvc_246" rel="nofollow">Springmvc的优点:</a></li><li><a href="#FactoryBean__BeanFactory__255" rel="nofollow">FactoryBean 与 BeanFactory 有什么区别？</a></li><li><a href="#Transactional__260" rel="nofollow">@Transactional 注解哪些情况下会失效？</a></li><li><a href="#_Spring__Spring_MVC__342" rel="nofollow">项目中如何用 Spring 和 Spring MVC 框架的？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#mybatis_346" rel="nofollow">mybatis=======================================</a></li><li><ul><li><ul><li><a href="#MyBatis_352" rel="nofollow">MyBatis是什么？有什么作用？</a></li><li><a href="#Mybaits__367" rel="nofollow">Mybaits 的优缺点</a></li><li><a href="#____383" rel="nofollow">#{} 和 ${} 的区别</a></li><li><a href="#MyBatis__395" rel="nofollow">MyBatis 中实体类的属性名与表中的字段名不一致怎么处理？</a></li><li><a href="#Mapper__SQL__XML__401" rel="nofollow">Mapper 接口如何与写 SQL 的 XML 文件进行绑定的？</a></li><li><a href="#MyBatis__407" rel="nofollow">MyBatis 如何批量插入？</a></li><li><a href="#MyBatis__Spring__440" rel="nofollow">MyBatis 是如何与 Spring 集成的？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#springboot_496" rel="nofollow">springboot====================================</a></li><li><ul><li><a href="#_Spring_Boot_516" rel="nofollow">**为什么要用 Spring Boot？**</a></li><li><a href="#Spring_Boot__527" rel="nofollow">**Spring Boot 的核心配置文件有哪几个？它们的区别是什么？**</a></li><li><a href="#Spring_Boot__542" rel="nofollow">**Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**常用注解</a></li><li><a href="#_Spring_Boot__620" rel="nofollow">**开启 Spring Boot 特性有哪几种方式？**</a></li><li><a href="#_Spring_Boot__626" rel="nofollow">**运行 Spring Boot 有哪几种方式？**</a></li><li><a href="#Spring_Boot__634" rel="nofollow">**Spring Boot 自动配置原理是什么？**</a></li><li><a href="#SpringBoot__638" rel="nofollow">SpringBoot 有几种读取配置文件的方式</a></li><li><a href="#_Spring_Boot__661" rel="nofollow">**你如何理解 Spring Boot 配置加载顺序？**</a></li><li><a href="#Spring_Boot__673" rel="nofollow">**Spring Boot 如何定义多套不同环境配置？**</a></li><li><a href="#Spring_Boot__Spring__687" rel="nofollow">**Spring Boot 可以兼容老 Spring 项目吗，如何做？**</a></li></ul> 
  </li><li><a href="#springCloud_691" rel="nofollow">springCloud微服务架构====================</a></li><li><ul><li><a href="#_693" rel="nofollow">什么是微服务架构</a></li><li><a href="#Spring_Cloud__697" rel="nofollow">Spring Cloud 是什么</a></li><li><a href="#SpringCloud_701" rel="nofollow">SpringCloud的优缺点</a></li><li><a href="#SpringBootSpringCloud_729" rel="nofollow">SpringBoot和SpringCloud的区别？</a></li><li><a href="#pringCloud_737" rel="nofollow">pringCloud由什么组成</a></li><li><a href="#Spring_Cloud_dubbo_747" rel="nofollow">Spring Cloud 和dubbo区别?</a></li><li><a href="#Eureka_753" rel="nofollow">Eureka</a></li><li><ul><li><a href="#Spring_Cloud__755" rel="nofollow">服务注册和发现是什么意思？Spring Cloud 如何实现？</a></li><li><a href="#Eureka_757" rel="nofollow">什么是Eureka</a></li><li><a href="#Eureka_761" rel="nofollow">Eureka怎么实现高可用</a></li><li><a href="#Eureka_765" rel="nofollow">什么是Eureka的自我保护模式，</a></li><li><a href="#DiscoveryClient_769" rel="nofollow">DiscoveryClient的作用</a></li><li><a href="#EurekaZooKeeper_773" rel="nofollow">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</a></li></ul> 
   </li><li><a href="#Zuul_788" rel="nofollow">Zuul</a></li><li><ul><li><a href="#_790" rel="nofollow">什么是网关?</a></li><li><a href="#_794" rel="nofollow">网关的作用是什么</a></li><li><a href="#_800" rel="nofollow">网关与过滤器有什么区别</a></li><li><a href="#_804" rel="nofollow">常用网关框架有那些？</a></li><li><a href="#ZuulNginx_808" rel="nofollow">Zuul与Nginx有什么区别？</a></li><li><a href="#NginxZuul_812" rel="nofollow">既然Nginx可以实现网关？为什么还需要使用Zuul框架</a></li><li><a href="#Zuul_816" rel="nofollow">Zuul网关如何搭建集群</a></li></ul> 
   </li><li><a href="#Ribbon_820" rel="nofollow">Ribbon</a></li><li><ul><li><a href="#_822" rel="nofollow">负载平衡的意义什么？</a></li><li><a href="#Ribbon_826" rel="nofollow">Ribbon是什么？</a></li><li><a href="#NginxRibbon_830" rel="nofollow">Nginx与Ribbon的区别</a></li><li><a href="#Ribbon_834" rel="nofollow">Ribbon底层实现原理</a></li><li><a href="#LoadBalanced_838" rel="nofollow">@LoadBalanced注解的作用</a></li></ul> 
   </li><li><a href="#Hystrix_842" rel="nofollow">Hystrix</a></li><li><ul><li><a href="#_844" rel="nofollow">什么是断路器</a></li><li><a href="#_Hystrix_848" rel="nofollow">什么是 Hystrix？</a></li><li><a href="#_852" rel="nofollow">谈谈服务雪崩效应</a></li><li><a href="#_856" rel="nofollow">在微服务中，如何保护服务?</a></li><li><a href="#_860" rel="nofollow">服务雪崩效应产生的原因</a></li><li><a href="#_864" rel="nofollow">谈谈服务降级、熔断、服务隔离</a></li><li><a href="#_887" rel="nofollow">服务降级底层是如何实现的？</a></li></ul> 
   </li><li><a href="#Feign_891" rel="nofollow">Feign</a></li><li><ul><li><a href="#Feign_893" rel="nofollow">什么是Feign？</a></li><li><a href="#SpringCloud_898" rel="nofollow">SpringCloud有几种调用接口方式</a></li><li><a href="#RibbonFeign_903" rel="nofollow">Ribbon和Feign调用服务的区别</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Dubbo_907" rel="nofollow">Dubbo=======================================</a></li><li><ul><li><a href="#Dubbo_909" rel="nofollow">介绍一下Dubbo？</a></li><li><a href="#Dubbo_913" rel="nofollow">Dubbo有哪些核心组件？</a></li><li><a href="#Dubbo_921" rel="nofollow">Dubbo框架分了哪些层？</a></li><li><a href="#Dubbo_936" rel="nofollow">Dubbo支持哪些序列化方式?</a></li><li><a href="#Dubbo_943" rel="nofollow">Dubbo的主要作用？</a></li><li><a href="#Dubbo_949" rel="nofollow">Dubbo有哪些负载均衡策略？</a></li><li><a href="#_Dubbo__Spring_Cloud__960" rel="nofollow">**你觉得用 Dubbo 好还是 Spring Cloud 好？**</a></li></ul> 
  </li><li><a href="#_964" rel="nofollow">数据库==============================</a></li><li><a href="#mysql_966" rel="nofollow">mysql================================</a></li><li><ul><li><ul><li><a href="#_968" rel="nofollow">事务的四大特性</a></li><li><a href="#_986" rel="nofollow">事务有哪些隔离级别？</a></li><li><a href="#_993" rel="nofollow">数据库如何优化</a></li><li><a href="#MySql_1035" rel="nofollow">**MySql集群主从复制**（主从同步）</a></li><li><a href="#mysql_1055" rel="nofollow">mysql默认的存储引擎是什么？</a></li><li><a href="#MyISAMInnoDB_1064" rel="nofollow">MyISAM与InnoDB的区别？</a></li><li><a href="#Innodb_1087" rel="nofollow">Innodb引擎有什么特性？</a></li><li><a href="#_1094" rel="nofollow">数据库的三范式是什么？有什么作用？</a></li><li><a href="#Mysql_1100" rel="nofollow">Mysql驱动程序是什么？</a></li><li><a href="#MySQL_1107" rel="nofollow">如何连接MySQL服务端、关闭连接？</a></li><li><a href="#_1112" rel="nofollow">左连接、右连接、内连接和全外连接的区别</a></li><li><a href="#_1119" rel="nofollow">**什么是表分区？**</a></li><li><a href="#_1123" rel="nofollow">**表分区与分表的区别**</a></li><li><a href="#_1129" rel="nofollow">**表分区有什么好处？**</a></li><li><a href="#_1139" rel="nofollow">**分区表的限制因素**</a></li><li><a href="#MySQL_1147" rel="nofollow">**如何判断当前MySQL是否支持分区？**</a></li><li><a href="#MySQL_1153" rel="nofollow">**MySQL支持的分区类型有哪些？**</a></li><li><a href="#_1160" rel="nofollow">如何实现分库分表？怎么配置？</a></li><li><a href="#_1168" rel="nofollow">索引</a></li><li><a href="#_1178" rel="nofollow">什么是索引？什么场景使用？</a></li><li><a href="#_1192" rel="nofollow">索引如何创建与删除？</a></li><li><a href="#_1199" rel="nofollow">索引的种类有哪些？</a></li><li><a href="#MySQL_1209" rel="nofollow">MySQL创建和使用索引的注意事项？</a></li><li><a href="#_1223" rel="nofollow">说一些索引失效的情况</a></li><li><a href="#_1233" rel="nofollow">索引对性能有哪些影响？</a></li></ul> 
   </li><li><a href="#NULL_1249" rel="nofollow">列值为NULL时，查询是否会用到索引？</a></li><li><ul><li><a href="#_1255" rel="nofollow">**缓存**</a></li><li><a href="#_1287" rel="nofollow">**为什么使用数据索引能提高效率**</a></li><li><a href="#_1295" rel="nofollow">锁</a></li><li><a href="#_1317" rel="nofollow">**行级锁定的优点：**</a></li><li><a href="#_1325" rel="nofollow">**行级锁定的缺点：**</a></li><li><a href="#MySQL_1332" rel="nofollow">MySQL的乐观锁和悲观锁？</a></li><li><a href="#MySQL_1353" rel="nofollow">MySQL中如何避免死锁？</a></li><li><a href="#MySQL__1363" rel="nofollow">MySQL 单表上亿，怎么优化分页查询？</a></li><li><a href="#MySQL_1422" rel="nofollow">MySQL有哪些常用函数？</a></li><li><a href="#OracleMysql_1460" rel="nofollow">与Oracle相比，Mysql有什么优势？</a></li><li><a href="#MySQLSQL_1466" rel="nofollow">MySQL如何进行慢SQL优化？</a></li><li><a href="#sql_1516" rel="nofollow">如何避免sql注入？</a></li><li><a href="#XSS_1525" rel="nofollow">什么是XSS攻击，如何避免？</a></li><li><a href="#CSRF_1533" rel="nofollow">什么是CSRF攻击，如何避免？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Oracle_1547" rel="nofollow">Oracle========================================</a></li><li><ul><li><ul><li><a href="#Oracle_1549" rel="nofollow">Oracle中字符串链接符是什么？</a></li><li><a href="#Oracle_1555" rel="nofollow">**Oracle中有哪几种文件？**</a></li><li><a href="#Oracle_1559" rel="nofollow">**Oracle优化**</a></li><li><a href="#Oracle_1583" rel="nofollow">Oracle有哪几种索引?</a></li><li><a href="#oracle_1609" rel="nofollow">哪些因素影响oracle查询性能？</a></li><li><a href="#Oracle_1618" rel="nofollow">Oracle中排序对性能的影响？</a></li><li><a href="#Oracle_1627" rel="nofollow">**Oracle中字符串用什么符号链接？**</a></li><li><a href="#Oracle_1631" rel="nofollow">Oracle有哪些备份方式？</a></li><li><a href="#_1646" rel="nofollow">冷备和热备的优缺点？</a></li><li><a href="#Oracle_1676" rel="nofollow">Oracle怎么分页？</a></li><li><a href="#__1686" rel="nofollow">**怎样创建一个视图,视图的好处, 视图可以控制权限吗?**</a></li><li><a href="#rowid_rownum_1695" rel="nofollow">**rowid, rownum的定义**</a></li><li><a href="#oracle_1701" rel="nofollow">oracle中存储过程，游标和函数的区别</a></li><li><a href="#Oracle_1706" rel="nofollow">Oracle怎样实现每天备份一次？</a></li><li><a href="#Oracle_1728" rel="nofollow">Oracle分区有哪些作用?</a></li><li><a href="#Oracle_1738" rel="nofollow">Oracle数据库如何迁移？</a></li><li><a href="#oracle_1746" rel="nofollow">oracle临时表有几种。</a></li><li><a href="#Oracle_1764" rel="nofollow">Oracle存储文件类型的字段？</a></li><li><a href="#oracle_1771" rel="nofollow">oracle数据库中有多行相同数据,只留一行怎么实现?</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Redis_1777" rel="nofollow">Redis=========================================</a></li><li><ul><li><a href="#Redis_1779" rel="nofollow">介绍一下Redis</a></li><li><a href="#Redis_1793" rel="nofollow">Redis支持哪些数据类型？</a></li><li><a href="#redis_1797" rel="nofollow">redis受到攻击怎么办？</a></li><li><a href="#Redis__1808" rel="nofollow">Redis 缓存穿透、击穿、雪崩现象及解决方案</a></li><li><ul><li><a href="#_1810" rel="nofollow">缓存穿透</a></li><li><a href="#_1826" rel="nofollow">缓存击穿</a></li><li><a href="#_1840" rel="nofollow">缓存雪崩</a></li><li><a href="#Redis__1853" rel="nofollow">Redis 缓存穿透、击穿、雪崩的区别？</a></li></ul> 
   </li><li><a href="#Redis_1859" rel="nofollow">Redis有哪些优缺点？</a></li><li><a href="#Redis_1876" rel="nofollow">Redis的哨兵原理</a></li><li><ul><li><a href="#_1904" rel="nofollow">心跳检测</a></li></ul> 
   </li><li><a href="#redis_1916" rel="nofollow">redis主从复制</a></li><li><ul><li><a href="#_1920" rel="nofollow">全量复制</a></li><li><a href="#_1931" rel="nofollow">增量复制</a></li><li><a href="#Redis_1935" rel="nofollow">Redis主从同步策略</a></li></ul> 
   </li><li><a href="#Redis_1939" rel="nofollow">Redis持久化机制有哪些？各有什么优缺点？</a></li><li><a href="#Redis_1972" rel="nofollow">Redis使用过程中的注意事项？</a></li><li><a href="#Redis_1980" rel="nofollow">Redis过期键的删除策略有哪些？</a></li><li><a href="#Redis_1986" rel="nofollow">为什么Redis所有数据放到内存中？</a></li><li><a href="#Redis_1992" rel="nofollow">说说Redis的同步机制？</a></li><li><a href="#Redis_2004" rel="nofollow">说说Redis集群？</a></li><li><a href="#Redis_2010" rel="nofollow">说说遇到的Redis集群方案不可用的情况？</a></li><li><a href="#Redis_2015" rel="nofollow">Redis如何设置密码？</a></li><li><a href="#Redis__2031" rel="nofollow">Redis 集群会有写操作丢失吗？</a></li><li><a href="#Redis_2040" rel="nofollow">Redis如何做内存优化？</a></li><li><a href="#Redis_2048" rel="nofollow">Redis集群之间是如何复制？</a></li><li><a href="#Redis_2060" rel="nofollow">Redis如何选择数据库？</a></li><li><a href="#Redis_2070" rel="nofollow">说一说你对Redis的事务的理解？</a></li><li><a href="#Redis_2092" rel="nofollow">Redis如何设置过期时间？</a></li><li><a href="#MySQL2000wredis20wredis_2100" rel="nofollow">MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</a></li><li><ul><li><a href="#_2109" rel="nofollow">内存淘汰策略</a></li></ul> 
   </li><li><a href="#Redis_2120" rel="nofollow">Redis事务支持隔离性吗</a></li><li><a href="#Redis_2124" rel="nofollow">Redis事务保证原子性吗，支持回滚吗</a></li></ul> 
  </li><li><a href="#nginx_2128" rel="nofollow">nginx==========================================</a></li><li><ul><li><a href="#Nginx_2130" rel="nofollow">什么是Nginx？</a></li><li><a href="#Nginx_2134" rel="nofollow">为什么要用Nginx？</a></li><li><a href="#Nginx_2148" rel="nofollow">Nginx怎么处理请求的？</a></li><li><a href="#_2160" rel="nofollow">什么是正向代理和反向代理？</a></li><li><a href="#Nginx_2167" rel="nofollow">Nginx的优缺点？</a></li><li><a href="#Nginx_2178" rel="nofollow">Nginx应用场景？</a></li><li><a href="#Nginx_2185" rel="nofollow">如何用Nginx解决前端跨域问题？</a></li><li><a href="#_2195" rel="nofollow">限流怎么做的？</a></li><li><a href="#_2219" rel="nofollow">漏桶算法</a></li><li><ul><li><a href="#Nginx_2223" rel="nofollow">Nginx负载均衡的算法怎么实现的?策略有哪些?</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Linux_2296" rel="nofollow">Linux=========================================</a></li><li><ul><li><a href="#linux_2298" rel="nofollow">linux如何添加新系统用户?</a></li><li><a href="#bash_2304" rel="nofollow">什么是bash别名？</a></li><li><a href="#linuxls_2322" rel="nofollow">linux指令-ls</a></li><li><a href="#_rmdir_2326" rel="nofollow">删除目录 rmdir</a></li><li><a href="#_linux__chmod_2328" rel="nofollow">改变 linux 系统文件或目录的访问权限 chmod</a></li><li><a href="#_2354" rel="nofollow">查看文件内容有哪些命令可以使用？</a></li><li><a href="#_2363" rel="nofollow">复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？</a></li><li><a href="#_2367" rel="nofollow">删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</a></li><li><a href="#Linux__2371" rel="nofollow">Linux 下命令有哪几种可使用的通配符？分别代表什么含义?</a></li><li><a href="#_2379" rel="nofollow">用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)</a></li><li><a href="#__2383" rel="nofollow">搜索文件用什么命令? 格式是怎么样的?</a></li><li><a href="#_2395" rel="nofollow">使用什么命令查看用过的命令列表?</a></li></ul> 
  </li><li><a href="#docker_2399" rel="nofollow">docker========================================</a></li><li><ul><li><a href="#dockerdocker_2401" rel="nofollow">什么是docker？什么是docker镜像？</a></li><li><a href="#dockerdockerdocker_2406" rel="nofollow">什么是docker容器？docker容器有几种状态？docker容器内部机制？容器与主机之间的数据拷贝？启动容器并挂在目录？</a></li><li><a href="#Docker_2417" rel="nofollow">Docker容器有几种状态</a></li><li><a href="#docker_2421" rel="nofollow">docker常用命令</a></li></ul> 
  </li><li><a href="#JVM_2430" rel="nofollow">JVM===========================================</a></li><li><ul><li><a href="#JVM_2432" rel="nofollow">JVM内存结构</a></li><li><a href="#_2440" rel="nofollow">内存划分</a></li><li><ul><li><a href="#Program_Counter_Register_2454" rel="nofollow">一、程序计数器(Program Counter Register)</a></li><li><a href="#JavaVM_Stack_2462" rel="nofollow">二、Java虚拟机栈(VM Stack)</a></li><li><a href="#Native_Method_Stack_2482" rel="nofollow">三、本地方法栈(Native Method Stack)</a></li><li><a href="#Heap_2488" rel="nofollow">四、堆(Heap)：</a></li><li><a href="#_2506" rel="nofollow">五、方法区</a></li><li><a href="#_2518" rel="nofollow">六：直接内存</a></li></ul> 
   </li><li><a href="#GC_2524" rel="nofollow">GC垃圾回收</a></li><li><a href="#GC__2565" rel="nofollow">GC 优化</a></li><li><a href="#_2571" rel="nofollow">新生代和老年代的区别(**阿里面试官的题目**)：</a></li><li><ul><li><a href="#_2575" rel="nofollow">新生代</a></li><li><a href="#_2591" rel="nofollow">老年代</a></li><li><a href="#_2601" rel="nofollow">永久代</a></li><li><a href="#_2617" rel="nofollow">元数据</a></li></ul> 
   </li><li><a href="#JDKJREJVM_2625" rel="nofollow">JDK,JRE,JVM区别</a></li><li><a href="#_2638" rel="nofollow">**说一下堆栈的区别？**</a></li><li><a href="#_2646" rel="nofollow">**队列和栈是什么？有什么区别？**</a></li><li><a href="#_2652" rel="nofollow">**说一下类加载的执行过程？**</a></li><li><a href="#_2662" rel="nofollow">什么是乐观锁和悲观锁？</a></li><li><ul><li><a href="#_2664" rel="nofollow">悲观锁</a></li><li><a href="#_2668" rel="nofollow">乐观锁</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Zookeeper_2672" rel="nofollow">Zookeeper=====================================</a></li><li><ul><li><a href="#zookeeper__2674" rel="nofollow">**zookeeper 是什么？**</a></li><li><a href="#zookeeper__2678" rel="nofollow">**zookeeper 都有哪些功能？**</a></li><li><a href="#zookeeper__2685" rel="nofollow">**zookeeper 有几种部署模式？**</a></li><li><a href="#zookeeper__2693" rel="nofollow">**zookeeper 怎么保证主从节点的状态同步？**</a></li><li><a href="#_2697" rel="nofollow">**集群中为什么要有主节点？**</a></li><li><a href="#_3__zookeeper__2701" rel="nofollow">**集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？**</a></li><li><a href="#_zookeeper__2705" rel="nofollow">说一下 zookeeper 的通知机制？</a></li></ul> 
  </li><li><a href="#_2709" rel="nofollow">集合===========================================</a></li><li><ul><li><a href="#ArrayListVector_2717" rel="nofollow">ArrayList和Vector的联系和区别</a></li><li><a href="#CollectionCollections_2731" rel="nofollow">Collection和Collections有什么区别？</a></li><li><a href="#ListSetMap__2737" rel="nofollow">List、Set、Map 之间的区别是什么？</a></li><li><a href="#HashMapHashtable__2743" rel="nofollow">HashMap和Hashtable 有什么区别？</a></li><li><a href="#HashMapTreeMap_2753" rel="nofollow">如何决定使用HashMap还是TreeMap？</a></li><li><a href="#HashMap_2759" rel="nofollow">HashMap原理</a></li><li><a href="#_HashMap_2790" rel="nofollow">手动实现 HashMap</a></li><li><a href="#ArrayArrayList_2977" rel="nofollow">Array和ArrayList有何区别？</a></li><li><a href="#List_2983" rel="nofollow">如何实现数组和List之间的转换？</a></li><li><a href="#_2989" rel="nofollow">哪些集合类是线程安全的？</a></li><li><a href="#Iterator_2996" rel="nofollow">Iterator怎么使用？有什么特点？</a></li></ul> 
  </li><li><a href="#_3004" rel="nofollow">多线程线程池====================================</a></li><li><ul><li><a href="#_3006" rel="nofollow">什么是线程？</a></li><li><a href="#_3012" rel="nofollow">什么是线程安全和线程不安全？</a></li><li><a href="#_3016" rel="nofollow">线程安全</a></li><li><a href="#_3022" rel="nofollow">线程不安全</a></li><li><a href="#_3030" rel="nofollow">什么是多线程？优缺点？</a></li><li><a href="#_3047" rel="nofollow">什么是多线程的上下文切换？</a></li><li><a href="#_Java__3057" rel="nofollow">如何创建、启动 Java 线程？</a></li><li><a href="#_3098" rel="nofollow">**什么是线程池？**</a></li><li><a href="#_3102" rel="nofollow">一个线程池包括以下四个基本组成部分：</a></li><li><a href="#_3109" rel="nofollow">常见线程池</a></li><li><a href="#_3120" rel="nofollow">线程池常用参数</a></li><li><a href="#_3130" rel="nofollow">**为什么要使用线程池？**</a></li><li><a href="#_3135" rel="nofollow">如何在两个线程之间共享数据</a></li></ul> 
  </li><li><a href="#java_3141" rel="nofollow">java基础=======================================</a></li><li><ul><li><a href="#equals_3143" rel="nofollow">==和equals的区别是什么?</a></li><li><a href="#hashCodeequalstrue_3160" rel="nofollow">hashCode()相同，equals()也一定为true吗？</a></li><li><a href="#final_finally_finalize_3175" rel="nofollow">final finally finalize()区别</a></li><li><a href="#_3181" rel="nofollow">如何将字符串反转？</a></li><li><a href="#String_3187" rel="nofollow">String类的常用方法有哪些？</a></li><li><a href="#_3221" rel="nofollow">普通类和抽象类有哪些区别？</a></li><li><a href="#_3258" rel="nofollow">方法重载和重写是什么？有什么区别？</a></li><li><a href="#_3266" rel="nofollow">内存泄漏和内存溢出的区别</a></li><li><a href="#_3272" rel="nofollow">什么是多态？如何实现？有什么好处？</a></li><li><a href="#LambdaRunnable_3283" rel="nofollow">用Lambda表达式实现Runnable：</a></li><li><a href="#String_sabcd_3297" rel="nofollow">String s="a"+"b"+"c"+"d";创建了几个对象？</a></li><li><a href="#String_s__new_StringxyzString_3305" rel="nofollow">String s = new String("xyz");创建几个String对象？</a></li><li><a href="#_3312" rel="nofollow">序列化</a></li><li><ul><li><a href="#_3318" rel="nofollow">**为什么要序列化？**</a></li></ul> 
   </li><li><a href="#_3328" rel="nofollow">**什么情况下需要序列化？**</a></li><li><a href="#_3336" rel="nofollow">**序列化的方式**</a></li><li><a href="#_3344" rel="nofollow">序列化技术选型的几个关键点</a></li><li><a href="#Java__3362" rel="nofollow">**Java 是如何实现序列化的？**</a></li><li><a href="#JAVA_3368" rel="nofollow">**JAVA序列化中常见的问题**</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SSM_4"></a>SSM</h2> 
<p>SSM搭建的版本有很多，例如有一个版本可以这么搭建，两个核心配置文件web.xml,applicationContext.xml。<code>1</code>.前端控制器DispatcherServlet<code> </code>2<code>.过滤器CharacterEncodingFilter` ` ` `applicationContext.xml` `1</code>.扫描包 &lt;context:component-scan base-<code>package</code>=<code>"cn"</code>/&gt;<code> </code>2<code>.mvc驱动 &lt;mvc:annotation-driven/&gt;` `3</code>.事务驱动 &lt;tx:annotation-driven transaction-manager=<code>"txManager"</code>/&gt;<code> </code>4<code>.配置数据源` `5</code>.SqlSessionFactoryBean <code> </code>6<code>.配置事务` `7</code>.数据映射器<code> </code>8``.视图解析器</p> 
<h2><a id="spring_8"></a>spring============================================</h2> 
<pre><code>Spring是一个开源的轻量级的Java开发框架。是一种简化应用程序的开发。
在spring出来之前，service层调用dao层都是用new的方式，在spring出来之后，service层和到dao层都会放在spring容器去管理，这是spring的第一种特性，我们称之为IOC，控制反转。
spring还有一种特性，我们称之为AOP，大白话，所谓“面向切面”，说白了就是专门的人干专门的事。在项目很多公有的或是要被重复被调用的模块可以被抽取出来，利用的就AOP的特性，例如日志模块。
</code></pre> 
<h4><a id="spring__16"></a>spring 的优点？</h4> 
<p>1.降低了组件之间的耦合性 ，实现了软件各层之间的解耦<br> 2.可以使用容易提供的众多服务，如事务管理，消息服务等<br> 3.容器提供单例模式支持<br> 4.容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能<br> 5.容器提供了众多的辅助类，能加快应用的开发<br> 6.spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等<br> 7.spring属于低侵入式设计，代码的污染极低<br> 8.独立于各种应用服务器<br> 9.spring的DI机制降低了业务对象替换的复杂性<br> 10.Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部</p> 
<h4><a id="IoCAOP_29"></a>IoC和AOP的理解</h4> 
<p>IoC（控制反转）</p> 
<p>就是 将<strong>原本在程序中手动创建对象的控制权，交由Spring框架来管理</strong>。</p> 
<p>​ IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将<strong>对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入</strong>。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p> 
<p>aop（<strong>面向切面编程</strong>）</p> 
<p>面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面<br> 1.面向切面编程提供声明式事务管理<br> 2.spring支持用户自定义的切面</p> 
<p>面向切面编程（aop）是对面向对象编程（oop）的补充，<br> 面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。</p> 
<p>aop框架具有的两个特征：<br> 1.各个步骤之间的良好隔离性<br> 2.源代码无关性</p> 
<p>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，<strong>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</strong></p> 
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p> 
<h4><a id="Bean__54"></a><strong>Bean 的生命周期</strong></h4> 
<pre><code>1.Bean容器找到配置文件中Spring Bean的定义。
2.Bean容器利用Java Reflection API创建一个Bean的实例。
3.如果涉及到一些属性值，利用set()方法设置一些属性值。
4.如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。
5.如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。
6.如果Bean实现了BeanFactoryAware接口，调用setBeanClassFacotory()方法，传入ClassLoader对象的实例。
7.与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。
8.如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。
9.如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。
10.如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。
11.如果有和加载这个Bean的Spring容器相关的BeanPostProcess对象，执行postProcessAfterInitialization()方法。
12.当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。
13.当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。
</code></pre> 
<h4><a id="Spring_72"></a><strong>列举一些重要的Spring模块？</strong></h4> 
<p>Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC和DI功能。</p> 
<p>Spring Aspects：该模块为与AspectJ的集成提供支持。</p> 
<p>Spring AOP：提供面向方面的编程实现。</p> 
<p>Spring JDBC：Java数据库连接。</p> 
<p>Spring JMS：Java消息服务。</p> 
<p>Spring ORM：用于支持Hibernate等ORM工具。</p> 
<p>Spring Web：为创建Web应用程序提供支持。</p> 
<p>Spring Test：提供了对JUnit和TestNG测试的支持。</p> 
<h4><a id="Spring_90"></a><strong>Spring框架中用到了哪些设计模式</strong></h4> 
<p>1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。</p> 
<p>2.代理设计模式：Spring AOP功能的实现。</p> 
<p>3.单例设计模式：Spring中的bean默认都是单例的。</p> 
<p>4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。</p> 
<p>5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p> 
<p>6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。</p> 
<p>7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。</p> 
<h4><a id="ComponentBean_106"></a><strong>@Component和@Bean的区别是什么</strong></h4> 
<p>1.作用对象不同。@Component注解作用于类，而@Bean注解作用于方法。</p> 
<p>2.@Component注解通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用@ComponentScan注解定义要扫描的路径）。@Bean注解通常是在标有该注解的方法中定义产生这个bean，告诉Spring这是某个类的实例，当我需要用它的时候还给我。</p> 
<p>3.@Bean注解比@Component注解的自定义性更强，而且很多地方只能通过@Bean注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过@Bean注解来实现。</p> 
<h4><a id="Spring_114"></a><strong>Spring事务管理的方式有几种？</strong></h4> 
<p>1.编程式事务：在代码中硬编码（不推荐使用）。</p> 
<p>2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务。</p> 
<h4><a id="Spring_120"></a><strong>Spring事务中的隔离级别有哪几种？</strong></h4> 
<ul><li>ISOLATION_DEFAULT：PlatfromTransactionManager 默认隔离级别，使用数据库默认的事务隔离级别。</li><li>ISOLATION_READ_UNCOMMITTED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据。</li><li>ISOLATION_READ_COMMITTED：读已提交，允许事务在执行过程中，读取其他事务已经提交的数据。</li><li>ISOLATION_REPEATABLE_READ：可重复读，在同一个事务内，任意时刻的查询结果都是一致的。</li><li>ISOLATION_SERIALIZABLE：最严格的事务，序列化执行。</li></ul> 
<h4><a id="Spring_128"></a><strong>Spring事务中有哪几种事务传播行为？</strong></h4> 
<p>在TransactionDefinition接口中定义了八个表示事务传播行为的常量。</p> 
<p>支持当前事务的情况：</p> 
<p>PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p> 
<p>PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p> 
<p>PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）。</p> 
<p>不支持当前事务的情况：</p> 
<p>PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p> 
<p>PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p> 
<p>PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常</p> 
<h4><a id="spring_148"></a>spring常用的注入方式有哪些？</h4> 
<p><strong>1、xml中配置</strong></p> 
<p><strong>2、注解</strong></p> 
<ul><li><strong>bean 的申明、注册</strong></li></ul> 
<p>@Component //注册所有bean<br> @Controller //注册控制层的bean<br> @Service //注册服务层的bean<br> @Repository //注册dao层的bean</p> 
<ul><li><strong>bean 的注入</strong></li></ul> 
<p>@Autowired 作用于 构造方法、字段、方法，常用于成员变量字段之上。<br> @Autowired + @Qualifier 注入，指定 bean 的名称<br> @Resource JDK 自带注解注入，可以指定 bean 的名称和类型等</p> 
<h4><a id="springbean_167"></a>spring中的bean是线程安全的吗？</h4> 
<p><strong>Spring 不保证 bean 的线程安全。</strong><br> <strong>默认 spring 容器中的 bean 是单例的。当单例中存在竞态条件，即有线程安全问题。</strong></p> 
<h2><a id="springmvc_172"></a>springmvc===================================</h2> 
<p><strong>spring mvc 是 spring web mvc，spring 框架的一部分，一个 mvc 设计模型的表现层框架。</strong></p> 
<p>Spring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一个模块,无需中间整合层来整合 ，它和Struts2一样都属于表现层的框架。在web模型中，MVC是一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p> 
<p>Spring MVC下我们一般把后端项目分为Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层（控制层，返回数据给前台页面）。</p> 
<p>当用户发送请求到springmvc中的前端控制器中，通过映射器和适配器返回ModelAndView对象到客户端。这就是SpringMVC的基本原理。</p> 
<h4><a id="SpringMVC_182"></a>SpringMVC的流程？</h4> 
<p>（1）用户发送请求至前端控制器DispatcherServlet； （2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle； （3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； （4）DispatcherServlet 调用 HandlerAdapter处理器适配器； （5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)； （6）Handler执行完成返回ModelAndView； （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet； （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析； （9）ViewResolver解析后返回具体View； （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） （11）DispatcherServlet响应用户。</p> 
<h4><a id="JSP__186"></a>JSP 九大内置对象和四大作用域</h4> 
<p>名称 类型 含义 获取方式<br> request HttpSevletRequest 封装所有请求信息 方法参数<br> response HttpServletResponse 封装所有响应信息 方法参数<br> session HttpSession 封装所有会话信息 req.getSession()<br> application ServletContext 所有信息 getServletContext();<br> out PrintWriter 输出对象 response.getWriter()<br> exception Exception 异常对象 response.getWriter()<br> page Object 当前页面对象 <br> pageContext PageContext 获取其他对象 <br> config ServletConfig 配置信息</p> 
<p>四大作用域</p> 
<p>1.page 在当前页面不会重新实例化</p> 
<p>2.request 在一次请求中同一个对象，下次请求重新实例化一个request对象。</p> 
<p>3.session 一次会话中只有一个session对象，依赖于cookie，只要Cookie中传递的Jsessionid不变，Session就不会重新实例化（在不超过默认生效时间的情况下）<br> 4.application:只有在tomcat启动项目时实例化，只有当关闭tomcat服务器时销毁application</p> 
<h4><a id="spring_mvc_208"></a>spring mvc有哪些组件？</h4> 
<ul><li>前端控制器（DispatcherServlet）</li><li>处理器映射器（HandlerMapping）</li><li>处理器适配器（HandlerAdapter）</li><li>拦截器（HandlerInterceptor）</li><li>语言环境处理器（LocaleResolver）</li><li>主题解析器（ThemeResolver）</li><li>视图解析器（ViewResolver）</li><li>文件上传处理器（MultipartResolver）</li><li>异常处理器（HandlerExceptionResolver）</li><li>数据转换（DataBinder）</li><li>消息转换器（HttpMessageConverter）</li><li>请求转视图翻译器（RequestToViewNameTranslator）</li><li>页面跳转参数管理器（FlashMapManager）</li><li>处理程序执行链（HandlerExecutionChain）</li></ul> 
<h4><a id="RequestMapping_225"></a>@RequestMapping的作用是什么？</h4> 
<p><strong>@RequestMapping 是一个注解，用来标识 http 请求地址与 Controller 类的方法之间的映射。</strong></p> 
<p>可作用于类和方法上，方法匹配的完整是路径是 Controller 类上 @RequestMapping 注解的 value 值加上方法上的 @RequestMapping 注解的 value 值。</p> 
<h4><a id="Autowired_231"></a>@Autowired的作用是什么？</h4> 
<p><strong>@Autowired 是一个注释，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。<br> @Autowired 默认是按照类去匹配，配合 @Qualifier 指定按照名称去装配 bean。</strong></p> 
<h4><a id="Autowired_Resource_236"></a>@Autowired 与@Resource的区别</h4> 
<p>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。</p> 
<p>@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false</p> 
<p>@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p> 
<p>推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</p> 
<h4><a id="Springmvc_246"></a>Springmvc的优点:</h4> 
<p>如下：<br> （1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成<br> （2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)<br> （3）可以任意使用各种视图技术,而不仅仅局限于JSP<br> （4） 支持各种请求资源的映射策略<br> （5）它应是易于扩展的</p> 
<h4><a id="FactoryBean__BeanFactory__255"></a>FactoryBean 与 BeanFactory 有什么区别？</h4> 
<ul><li>BeanFactory 是 IoC 底层容器，提供了 bean 的管理</li><li>FactoryBean 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑</li></ul> 
<h4><a id="Transactional__260"></a>@Transactional 注解哪些情况下会失效？</h4> 
<p>1、@Transactional 作用在非 public 修饰的方法上</p> 
<p>2、@Transactional 作用于接口，使用 CGLib 动态代理</p> 
<p>3、@Transactional 注解属性 propagation 设置以下三种可能导致无法回滚</p> 
<ul><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul> 
<p>4、同一类中加 @Transactional 方法被无 @Transactional 的方法调用，事务失效</p> 
<p>5、@Transactional 方法内异常被捕获</p> 
<p>6、默认 RuntimeException 和 Error 及子类抛出，会回滚；rollbackFor 指定的异常及子类发生才会回滚</p> 
<p>7、数据库不支持事务，如 MySQL 使用 MyISAM 存储引擎</p> 
<p>8、Spring 的配置文件中未配置事务注解生效</p> 
<p><strong>Spring MVC的异常处理 ？</strong></p> 
<p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p> 
<p><strong>SpringMvc的核心入口类是什么,Struts1,Struts2的分别是什么：</strong></p> 
<p>答：SpringMvc的是DispatchServlet,Struts1的是ActionServlet,Struts2的是StrutsPrepareAndExecuteFilter。</p> 
<p><strong>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</strong></p> 
<p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p> 
<p><strong>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</strong></p> 
<p>答：一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</p> 
<p><strong>@RequestMapping注解用在类上面有什么作用？</strong></p> 
<p>答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p> 
<p><strong>怎么样把某个请求映射到特定的方法上面？</strong></p> 
<p>答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。</p> 
<p><strong>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</strong></p> 
<p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p> 
<p><strong>怎么样在方法里面得到Request,或者Session？</strong></p> 
<p>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。</p> 
<p><strong>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</strong></p> 
<p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p> 
<p><strong>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</strong></p> 
<p>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</p> 
<p><strong>SpringMvc中函数的返回值是什么？</strong></p> 
<p>答：返回值可以有很多类型,有String, ModelAndView，但一般用String比较好。</p> 
<p><strong>SpringMvc用什么对象从后台向前台传递数据的？</strong></p> 
<p>答：通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p> 
<p><strong>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</strong></p> 
<p>答：ModelAndView。</p> 
<p><strong>怎么样把ModelMap里面的数据放入Session里面？</strong></p> 
<p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p> 
<p><strong>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</strong></p> 
<p>答：要加上@ResponseBody注解。</p> 
<h4><a id="_Spring__Spring_MVC__342"></a>项目中如何用 Spring 和 Spring MVC 框架的？</h4> 
<p>通过 web.xml 的配置、@Controller、@Service、@Repository，完成 http 请求到数据库的 crud 再到 view 层展示，整个调用链。其中还要配置对象转 json 的 Converter、登录拦截器、文件上传大小限制、数据源及连接池相关等等…</p> 
<h2><a id="mybatis_346"></a>mybatis=======================================</h2> 
<ul><li>支持自定义 SQL、存储过程以及高级映射</li><li>免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作</li><li>通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</li></ul> 
<h4><a id="MyBatis_352"></a>MyBatis是什么？有什么作用？</h4> 
<p>MyBatis（前身是iBatis）是一个支持普通SQL查询、存储过程以及高级映射的持久层框架，它消除了几乎所有的JDBC代码和参数的手动设置以及对结果集的检索，并使用简单的XML或注解进行配置和原始映射，用以将接口和Java的POJO（Plain Old Java Object，普通Java对象）映射成数据库中的记录，使得Java开发人员可以使用面向对象的编程思想来操作数据库。</p> 
<p>MyBatis 框架也被称之为 ORM（Object/Relational Mapping，即对象关系映射）框架。所谓的 ORM 就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述Java对象与数据库表之间的映射关系，自动将Java应用程序中的对象持久化到关系型数据库的表中。ORM框架的工作原理如下图所示。</p> 
<p><img src="https://images2.imgbox.com/8d/59/G6ULxtwt_o.jpg" alt="img"></p> 
<p>从上图可以看出，使用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象（Persisent Object，PO），而ORM框架则会通过映射关系将这些面向对象的操作转换成底层的SQL操作。</p> 
<h4><a id="Mybaits__367"></a>Mybaits 的优缺点</h4> 
<p>优点:</p> 
<ul><li>消除 JDBC 中的重复代码</li><li>可以在 XML 或注解中直接编写 SQL 语句，比较灵活，方便对 SQL 的优化与调整</li><li>SQL 写在 XML 中，与代码解耦，按照对应关系方便管理</li><li>XML 中提供了动态 SQL 的标签，方便根据条件拼接 SQL</li><li>提供了 XML、注解与 Java 对象的映射机制</li><li>与 Spring 集成比较方便</li></ul> 
<p>缺点:</p> 
<ul><li>字段较多、关联表多时，编写 SQL 工作量较大</li><li>SQL 语句依赖了数据库特性，会导致程序的移植性较差，切换数据库困难</li></ul> 
<h4><a id="____383"></a>#{} 和 ${} 的区别</h4> 
<p>都是用于传值</p> 
<p>MyBatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ?，预编译 SQL</p> 
<p>#是预编译占位符，在sql语句中用？代替，可以防止sql注入</p> 
<p>$是用于sql语句的拼接，要判断参数类型，不能防止sql注入</p> 
<p>#{} 比 ${} 安全，但还是提供了 ${} 这种动态替换参数的方式，是因为有些复杂的 SQL 使用场景通过预编译的方式比较麻烦，且在代码中完全可以做到控制非法参数，有些参数可能是一些常量或字段值。</p> 
<h4><a id="MyBatis__395"></a>MyBatis 中实体类的属性名与表中的字段名不一致怎么处理？</h4> 
<p>1、修改 SQL，给查询字段重命名，如 将 user_id 重命名为 userId</p> 
<p>2、MyBatis 的 XML 映射文件中，使用 标签，定义数据库字段名与实体 bean 的属性字段名的映射关系</p> 
<h4><a id="Mapper__SQL__XML__401"></a>Mapper 接口如何与写 SQL 的 XML 文件进行绑定的？</h4> 
<ul><li>Mapper 接口与 XML 文件的绑定是通过 XML 里 mapper 标签的 namespace 值与 Mapper 接口的 <strong>包路径.接口名</strong> 进行绑定</li><li>Mapper 接口的方法名与 XML 文件中的 sql、select、insert、update、delete 标签的 id 参数值进行绑定</li><li>其中涉及到了 MappedStatement 的 id、SqlCommand 的 name 的值为 Mapper 接口的 <strong>包路径.接口名.方法名</strong></li></ul> 
<h4><a id="MyBatis__407"></a>MyBatis 如何批量插入？</h4> 
<p><strong>方式一、打开批量插入的 SqlSession</strong></p> 
<pre><code class="prism language-javascript">SqlSession sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>ExecutorType<span class="token punctuation">.</span><span class="token constant">BATCH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
UserMapper userMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">36</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">45</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    userMapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"ConstXiong"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>方式二、拼接批量插入的 insert SQL</strong></p> 
<pre><code class="prism language-javascript"><span class="token comment">//Java 代码</span>
List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">46</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">55</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"ConstXiong"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
userMapper<span class="token punctuation">.</span><span class="token function">insertUserBatch</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>Mapper xml 中配置<span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>insert id<span class="token operator">=</span><span class="token string">"insertUserBatch"</span> parameterType<span class="token operator">=</span><span class="token string">"java.util.List"</span><span class="token operator">&gt;</span>
    insert into user values
    <span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"list"</span> item<span class="token operator">=</span><span class="token string">"item"</span> separator <span class="token operator">=</span><span class="token string">","</span><span class="token operator">&gt;</span>
        <span class="token punctuation">(</span>#<span class="token punctuation">{<!-- --></span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token punctuation">,</span> #<span class="token punctuation">{<!-- --></span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>insert<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="MyBatis__Spring__440"></a>MyBatis 是如何与 Spring 集成的？</h4> 
<p>单纯使用 spring-context 和 spring-jdbc 集成 MyBatis，配置步骤：</p> 
<ul><li>加载 spring-context、spring-jdbc、MyBatis、MyBatis-Spring 的 jar 包</li><li>spring 集成 MyBatis 的 xml 配置文件，配置 dataSource、sqlSessionFactory、Mapper 接口包扫描路径</li><li>Mapper 接口代理 bean 直接从 spring ioc 容器中获得使用即可</li></ul> 
<p>最核心的就是 spring 的配置文件，如下</p> 
<pre><code class="prism language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">?</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>
       <span class="token literal-property property">xmlns</span><span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="token literal-property property">xmlns</span><span class="token operator">:</span>context<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/context"</span>
       <span class="token literal-property property">xsi</span><span class="token operator">:</span>schemaLocation<span class="token operator">=</span>"
        <span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans
        <span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans<span class="token operator">/</span>spring<span class="token operator">-</span>beans<span class="token punctuation">.</span>xsd
        <span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context
        <span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context<span class="token operator">/</span>spring<span class="token operator">-</span>context<span class="token operator">-</span><span class="token number">4.3</span><span class="token punctuation">.</span>xsd
        "<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>context<span class="token operator">:</span>property<span class="token operator">-</span>placeholder location<span class="token operator">=</span><span class="token string">"classpath:db.properties"</span> ignore<span class="token operator">-</span>unresolvable<span class="token operator">=</span><span class="token string">"true"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"dataSource"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.apache.ibatis.datasource.pooled.PooledDataSource"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 基本属性 url、user、password <span class="token operator">--</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"driver"</span> value<span class="token operator">=</span><span class="token string">"${jdbc_driver}"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"url"</span> value<span class="token operator">=</span><span class="token string">"${jdbc_url}"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"username"</span> value<span class="token operator">=</span><span class="token string">"${jdbc_username}"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"password"</span> value<span class="token operator">=</span><span class="token string">"${jdbc_password}"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> spring 和 Mybatis整合 <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"sqlSessionFactory"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.mybatis.spring.SqlSessionFactoryBean"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"dataSource"</span> ref<span class="token operator">=</span><span class="token string">"dataSource"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"mapperLocations"</span> value<span class="token operator">=</span><span class="token string">"classpath:constxiong/mapper/*.xml"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token constant">DAO</span>接口所在包，配置自动扫描 <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"basePackage"</span> value<span class="token operator">=</span><span class="token string">"constxiong.mapper"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">&gt;</span>
</code></pre> 
<p>核心配置就是 dataSource、SqlSessionFactoryBean、MapperScannerConfigurer</p> 
<ul><li> <p>dataSource 是数据源</p> </li><li> <p>SqlSessionFactoryBean，配置数据源、可以加载解析 MyBatis 的配置文件、可以设置 Mapper xml 的文件路径与解析、SqlSessionFactory 对象的创建等</p> </li></ul> 
<p>buildSqlSessionFactory() 方法中利用 MyBatis 的核心类解析 MyBatis 的配置文件、Mapper xml 文件，生成 Configuration 对象设置其中属性，创建 SqlSessionFactory 对象</p> 
<p>MapperScannerConfigurer，设置 Mapper 接口的的包扫描路径，加载所有的 Mapper 接口生成 BeanDefinition，设置 BeanDefinition 的 beanClass 属性为 MapperFactoryBean，设置 sqlSessionFactory 和 sqlSessionTemplate 属性</p> 
<h2><a id="springboot_496"></a>springboot====================================</h2> 
<pre><code>SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务。
版本号：2.1.6

SpringBoot基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 [1] 
SpringBoot所具备的特征有：
（1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；
（2）内嵌Tomcat或Jetty等Servlet容器；
（3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；
（4）尽可能自动配置Spring容器；
（5）提供准备好的特性，如指标、健康检查和外部化配置；
（6）绝对没有代码生成，不需要XML配置。

SpringBoot框架中还有两个非常重要的策略：开箱即用和约定优于配置。
	开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。
	约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。
</code></pre> 
<h3><a id="_Spring_Boot_516"></a><strong>为什么要用 Spring Boot？</strong></h3> 
<p>Spring Boot 优点非常多，如：</p> 
<ul><li>独立运行</li><li>简化配置</li><li>自动配置</li><li>无代码生成和XML配置</li><li>应用监控</li><li>上手容易</li></ul> 
<h3><a id="Spring_Boot__527"></a><strong>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</strong></h3> 
<p>SpringBoot的核心配置文件有application和bootstarp配置文件。<br> 2.他们的区别是什么？<br> application文件主要用于Springboot自动化配置文件。</p> 
<p>bootstarp文件主要有以下几种用途：</p> 
<p>使用Spring Cloud Config注册中心时 需要在bootStarp配置文件中添加链接到配置中心的配置属性来加载外部配置中心的配置信息。<br> 一些固定的不能被覆盖的属性<br> 一些加密/解密的场景<br> 都有什么格式？<br> .properties 和 .yml<br> .yml采取的是缩进的格式 不支持@PeopertySource注解导入配置</p> 
<h3><a id="Spring_Boot__542"></a>**Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**常用注解</h3> 
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p> 
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p> 
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p> 
<p>@ComponentScan：Spring组件扫描。</p> 
<p><strong>1、@SpringBootApplication</strong></p> 
<p>这个注解是Spring Boot最核心的注解，用在 Spring Boot的主类上</p> 
<p><strong>2、@EnableAutoConfiguration</strong></p> 
<p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p> 
<p><strong>3、@Configuration</strong></p> 
<p>用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。</p> 
<p><strong>4、@ComponentScan</strong></p> 
<p>组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。</p> 
<p><strong>5、@Repository</strong></p> 
<p>用于标注数据访问组件，即DAO组件。</p> 
<p><strong>6、@Service</strong></p> 
<p>一般用于修饰service层的组件</p> 
<p><strong>7、@RestController</strong></p> 
<p>用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。</p> 
<p><strong>8、@ResponseBody</strong></p> 
<p>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p> 
<p><strong>9、@Component</strong></p> 
<p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p> 
<p><strong>10、@Bean</strong></p> 
<p>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p> 
<p><strong>11、@AutoWired</strong></p> 
<p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p> 
<p><strong>12、@Qualifier</strong></p> 
<p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p> 
<p><strong>13、@Resource(name=“name”,type=“type”)</strong></p> 
<p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p> 
<p><strong>14、@RequestMapping</strong></p> 
<p>RequestMapping是一个用来处理请求地址映射的注解；提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p> 
<p><strong>15、@RequestParam</strong></p> 
<p>用在方法的参数前面。</p> 
<p><strong>16、@Profiles</strong></p> 
<p>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。</p> 
<p><strong>17、@PathVariable</strong></p> 
<p>路径变量。参数与大括号里的名字一样要相同。</p> 
<h3><a id="_Spring_Boot__620"></a><strong>开启 Spring Boot 特性有哪几种方式？</strong></h3> 
<p>1）继承spring-boot-starter-parent项目</p> 
<p>2）导入spring-boot-dependencies项目依赖</p> 
<h3><a id="_Spring_Boot__626"></a><strong>运行 Spring Boot 有哪几种方式？</strong></h3> 
<p>1）打包用命令或者放到容器中运行</p> 
<p>2）用 Maven/ Gradle 插件运行</p> 
<p>3）直接执行 main 方法运行</p> 
<h3><a id="Spring_Boot__634"></a><strong>Spring Boot 自动配置原理是什么？</strong></h3> 
<p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p> 
<h3><a id="SpringBoot__638"></a>SpringBoot 有几种读取配置文件的方式</h3> 
<p><strong>看配置文件 application.properties</strong></p> 
<pre><code class="prism language-java">user<span class="token punctuation">.</span>username<span class="token operator">=</span><span class="token constant">CCCCXXX</span>
user<span class="token punctuation">.</span>password<span class="token operator">=</span><span class="token number">123123123</span>
user<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span>
user<span class="token punctuation">.</span>salary<span class="token operator">=</span><span class="token number">2000.00</span>
</code></pre> 
<ol><li> <p>@Value读取</p> </li><li> <p>@PropertySource读取 <strong>@PropertySource读取不支持yml文件配置</strong>*</p> </li><li> <p>@Environment读取</p> <p><strong>配置文件里面所有的配置都可以用Environment来获取</strong></p> </li><li> <p>@ConfigurationProperties读取</p> </li></ol> 
<p>**这个注解就更屌了…**可以配合着别的注解一起使用</p> 
<h3><a id="_Spring_Boot__661"></a><strong>你如何理解 Spring Boot 配置加载顺序？</strong></h3> 
<p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p> 
<p>1）properties文件；</p> 
<p>2）YAML文件；</p> 
<p>3）系统环境变量；</p> 
<p>4）命令行参数；</p> 
<h3><a id="Spring_Boot__673"></a><strong>Spring Boot 如何定义多套不同环境配置？</strong></h3> 
<p>提供多套配置文件，如：</p> 
<pre><code>applcation.properties

application-dev.properties

application-test.properties

application-prod.properties
</code></pre> 
<h3><a id="Spring_Boot__Spring__687"></a><strong>Spring Boot 可以兼容老 Spring 项目吗，如何做？</strong></h3> 
<p>可以兼容，使用 <code>@ImportResource</code> 注解导入老 Spring 项目配置文件。</p> 
<h2><a id="springCloud_691"></a>springCloud微服务架构====================</h2> 
<h3><a id="_693"></a>什么是微服务架构</h3> 
<p>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</p> 
<h3><a id="Spring_Cloud__697"></a>Spring Cloud 是什么</h3> 
<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p> 
<h3><a id="SpringCloud_701"></a>SpringCloud的优缺点</h3> 
<p>优点：</p> 
<p>1.耦合度比较低。不会影响其他模块的开发。</p> 
<p>2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</p> 
<p>3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。</p> 
<p>4.微服务跨平台的，可以用任何一种语言开发。</p> 
<p>5.每个微服务可以有自己的独立的数据库也有用公共的数据库。</p> 
<p>6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</p> 
<p>缺点：</p> 
<p>1.部署比较麻烦，给运维工程师带来一定的麻烦。</p> 
<p>2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</p> 
<p>3.系统集成测试比较麻烦</p> 
<p>4.性能的监控比较麻烦。【最好开发一个大屏监控系统】</p> 
<p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p> 
<h3><a id="SpringBootSpringCloud_729"></a>SpringBoot和SpringCloud的区别？</h3> 
<p>SpringBoot专注于快速方便的开发单个个体微服务。<br> SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，<br> 为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务<br> SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系<br> SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p> 
<h3><a id="pringCloud_737"></a>pringCloud由什么组成</h3> 
<p>这就有很多了，我讲几个开发中最重要的<br> Spring Cloud Eureka：服务注册与发现<br> Spring Cloud Zuul：服务网关<br> Spring Cloud Ribbon：客户端负载均衡<br> Spring Cloud Feign：声明性的Web服务客户端<br> Spring Cloud Hystrix：断路器<br> Spring Cloud Confifig：分布式统一配置管理</p> 
<h3><a id="Spring_Cloud_dubbo_747"></a>Spring Cloud 和dubbo区别?</h3> 
<p>（1）服务调用方式：dubbo是RPC springcloud Rest Api<br> （2）注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper<br> （3）服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p> 
<h3><a id="Eureka_753"></a>Eureka</h3> 
<h4><a id="Spring_Cloud__755"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h4> 
<h4><a id="Eureka_757"></a>什么是Eureka</h4> 
<p>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过EurekaService来监控各个微服务是否运行正常。</p> 
<h4><a id="Eureka_761"></a>Eureka怎么实现高可用</h4> 
<p>集群吧，注册多台 Eureka ，然后把 SpringCloud 服务互相注册，客户端从 Eureka 获取信息时，按照Eureka 的顺序来访问。</p> 
<h4><a id="Eureka_765"></a>什么是Eureka的自我保护模式，</h4> 
<p>默认情况下，如果 Eureka Service 在一定时间内没有接收到某个微服务的心跳， Eureka Service 会进入自我保护模式，在该模式下Eureka Service 会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式</p> 
<h4><a id="DiscoveryClient_769"></a>DiscoveryClient的作用</h4> 
<p>可以从注册中心中根据服务别名获取注册的服务器信息。</p> 
<h4><a id="EurekaZooKeeper_773"></a>Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</h4> 
<ol><li> <p>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</p> </li><li> <p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p> </li><li> <p>Eureka本质上是一个工程,而ZooKeeper只是一个进程</p> </li><li> <p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</p> </li><li> <p>ZooKeeper保证的是CP，Eureka保证的是AP</p> </li></ol> 
<p>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</p> 
<h3><a id="Zuul_788"></a>Zuul</h3> 
<h4><a id="_790"></a>什么是网关?</h4> 
<p>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。</p> 
<h4><a id="_794"></a>网关的作用是什么</h4> 
<p>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</p> 
<p>什么是Spring Cloud Zuul（服务网关）</p> 
<h4><a id="_800"></a>网关与过滤器有什么区别</h4> 
<p>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</p> 
<h4><a id="_804"></a>常用网关框架有那些？</h4> 
<p>Nginx 、 Zuul 、 Gateway</p> 
<h4><a id="ZuulNginx_808"></a>Zuul与Nginx有什么区别？</h4> 
<p>Zuul 是 java 语言实现的，主要为 java 服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx 是使用 C 语言实现，性能高于 Zuul ，但是实现自定义操作需要熟悉 lua 语言，对程序员要求较高，可以使用Nginx 做 Zuul 集群。</p> 
<h4><a id="NginxZuul_812"></a>既然Nginx可以实现网关？为什么还需要使用Zuul框架</h4> 
<p>Zuul 是 SpringCloud 集成的网关，使用 Java 语言编写，可以对 SpringCloud 架构提供更灵活的服务。</p> 
<h4><a id="Zuul_816"></a>Zuul网关如何搭建集群</h4> 
<p>使用 Nginx 的 upstream 设置 Zuul 服务集群，通过 location 拦截请求并转发到 upstream ，默认使用轮询机制对Zuul 集群发送请求。</p> 
<h3><a id="Ribbon_820"></a>Ribbon</h3> 
<h4><a id="_822"></a>负载平衡的意义什么？</h4> 
<p><img src="https://images2.imgbox.com/22/90/XPQI0K3S_o.png" alt="img"></p> 
<h4><a id="Ribbon_826"></a>Ribbon是什么？</h4> 
<p><img src="https://images2.imgbox.com/2d/53/uTLjAQ1U_o.png" alt="img"></p> 
<h4><a id="NginxRibbon_830"></a>Nginx与Ribbon的区别</h4> 
<p><img src="https://images2.imgbox.com/00/60/rPWNnac9_o.png" alt="img"></p> 
<h4><a id="Ribbon_834"></a>Ribbon底层实现原理</h4> 
<p>Ribbon 使用 discoveryClient 从注册中心读取目标服务信息，对同一接口请求进行计数，使用 % 取余算法获取目标服务集群索引，返回获取到的目标服务信息。</p> 
<h4><a id="LoadBalanced_838"></a>@LoadBalanced注解的作用</h4> 
<p>开启客户端负载均衡。</p> 
<h3><a id="Hystrix_842"></a>Hystrix</h3> 
<h4><a id="_844"></a>什么是断路器</h4> 
<p><img src="https://images2.imgbox.com/28/c0/zZFP2A4e_o.png" alt="img"></p> 
<h4><a id="_Hystrix_848"></a>什么是 Hystrix？</h4> 
<p><img src="https://images2.imgbox.com/da/57/A2MIaNZc_o.png" alt="img"></p> 
<h4><a id="_852"></a>谈谈服务雪崩效应</h4> 
<p><img src="https://images2.imgbox.com/3e/aa/sfQ6Dyan_o.png" alt="img"></p> 
<h4><a id="_856"></a>在微服务中，如何保护服务?</h4> 
<p><img src="https://images2.imgbox.com/21/58/jRvyJEVo_o.png" alt="img"></p> 
<h4><a id="_860"></a>服务雪崩效应产生的原因</h4> 
<p>因为 Tomcat 默认情况下只有一个线程池来维护客户端发送的所有的请求，这时候某一接口在某一时刻被大量访问就会占据tomcat 线程池中的所有线程，其他请求处于等待状态，无法连接到服务接口。</p> 
<h4><a id="_864"></a>谈谈服务降级、熔断、服务隔离</h4> 
<p><img src="https://images2.imgbox.com/6e/bc/4GOsaA7q_o.png" alt="img"></p> 
<p>整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。</p> 
<p><strong>1、服务降级的特征：</strong><br> 原因：整体负荷超出整体负载承受能力。<br> 目的：保证重要或基本服务正常运行，非重要服务延迟使用或暂停使用<br> 大小：降低服务粒度，要考虑整体模块粒度的大小，将粒度控制在合适的范围内<br> 可控性：在服务粒度大小的基础上增加服务的可控性，后台服务开关的功能是一项必要配置（单机可配置文件，其他可领用数据库和缓存），可分为手动控制和自动控制。<br> 次序：一般从外围延伸服务开始降级，需要有一定的配置项，重要性低的优先降级，比如可以分组设置等级1-10，当服务需要降级到某一个级别时，进行相关配置<br> <strong>2、降级的方式：</strong></p> 
<pre><code> （1）、延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。
 （2）、在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区
 （3）、页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
 （3）、页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址
 （4）写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。
 （5）读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；
</code></pre> 
<h4><a id="_887"></a>服务降级底层是如何实现的？</h4> 
<p>Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。</p> 
<h3><a id="Feign_891"></a>Feign</h3> 
<h4><a id="Feign_893"></a>什么是Feign？</h4> 
<p>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易<br> 他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</p> 
<h4><a id="SpringCloud_898"></a>SpringCloud有几种调用接口方式</h4> 
<p>Feign<br> RestTemplate</p> 
<h4><a id="RibbonFeign_903"></a>Ribbon和Feign调用服务的区别</h4> 
<p><img src="https://images2.imgbox.com/4c/46/jrwvAc6q_o.png" alt="img"></p> 
<h2><a id="Dubbo_907"></a>Dubbo=======================================</h2> 
<h3><a id="Dubbo_909"></a>介绍一下Dubbo？</h3> 
<p>Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成</p> 
<h3><a id="Dubbo_913"></a>Dubbo有哪些核心组件？</h3> 
<ul><li>Provider：服务的提供方</li><li>Consumer：调用远程服务的服务消费方</li><li>Registry：服务注册和发现的注册中心</li><li>Monitor：统计服务调用次数和调用时间的监控中心</li><li>Container：服务运行容器</li></ul> 
<h3><a id="Dubbo_921"></a>Dubbo框架分了哪些层？</h3> 
<p><strong>Dubbo 框架设计一共划分了 10 层：</strong></p> 
<ul><li>服务接口层(Service)：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现</li><li>配置层(Config)：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li><li>服务代理层(Proxy)：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton</li><li>服务注册层(Registry)：封装服务地址的注册与发现，以服务 URL 为中心</li><li>集群层(Cluster)：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心</li><li>监控层(Monitor)：RPC 调用次数和调用时间监控</li><li>远程调用层(Protocol)：封将 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocol、Invoker、Exporter</li><li>信息交换层(Exchange)：封装请求响应模式，同步转异步，以 Request 和 Response 为中心</li><li>网络传输层(Transport)：抽象 mina 和 netty 为统一接口，以 Message 为中心</li><li>数据序列化层(Serialize)：序列化的一些工具</li></ul> 
<h3><a id="Dubbo_936"></a>Dubbo支持哪些序列化方式?</h3> 
<ul><li>Hessian 序列化：是修改过的 hessian lite，默认启用</li><li>json 序列化：使用 FastJson 库</li><li>java 序列化：JDK 提供的序列化，性能不理想</li><li>dubbo 序列化：未成熟的高效 java 序列化实现，不建议在生产环境使用</li></ul> 
<h3><a id="Dubbo_943"></a>Dubbo的主要作用？</h3> 
<ul><li>透明化的远程方法调用，像调用本地方法一样调用远程方法</li><li>负载均衡及容错机制，负载分发请求到不同的服务提供者，解决单点故障</li><li>服务自动注册与发现，动态服务注册与请求分发，能够平滑添加或删除服务提供者</li></ul> 
<h3><a id="Dubbo_949"></a>Dubbo有哪些负载均衡策略？</h3> 
<p>Dubbo 实现了常见的集群策略，并提供扩展点予以自行实现。</p> 
<ul><li>Random LoadBalance：随机选取提供者策略，随机转发请求，可以加权</li><li>RoundRobin LoadBalance：轮循选取提供者策略，请求平均分布</li><li>LeastActive LoadBalance：最少活跃调用策略，可以让慢提供者接收更少的请求</li><li>ConstantHash LoadBalance：一致性 Hash 策略，相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者</li></ul> 
<p>缺省时为 Random LoadBalance</p> 
<h3><a id="_Dubbo__Spring_Cloud__960"></a><strong>你觉得用 Dubbo 好还是 Spring Cloud 好？</strong></h3> 
<p>扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使用 Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐，还有很多我觉得是没有 Dubbo 顺手的地方……</p> 
<h2><a id="_964"></a>数据库==============================</h2> 
<h2><a id="mysql_966"></a>mysql================================</h2> 
<h4><a id="_968"></a>事务的四大特性</h4> 
<ul><li>原子性（Atomicity）</li></ul> 
<p>事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p> 
<ul><li>一致性（Consistency）</li></ul> 
<p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p> 
<ul><li>隔离性（Isolation）</li></ul> 
<p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p> 
<ul><li>持久性（Durability）</li></ul> 
<p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p> 
<h4><a id="_986"></a>事务有哪些隔离级别？</h4> 
<ul><li>读未提交（Read Uncommitted）：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。</li><li>读已提交（Read Committed）：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读。</li><li>可重复读（Repeatable Read）：这种事务隔离级别可以防止脏读，不可重复读，但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了不可重复读。</li><li>串行化（Serializable）：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。防止脏读、不可重复读、幻象读。</li></ul> 
<h4><a id="_993"></a>数据库如何优化</h4> 
<pre><code>1优化sql语句
原则:
1.尽量根据主键查询
2.尽量使用单表查询/不要关联查询

3.查询时可以使用in但是绝对不要使用not in

2.创建索引 为搜索字段建索引
 create index 索引名称 on 表名称(列名称)
 	为什么使用数据索引能提高效率
    数据索引的存储是 有序的
    在有序的情况下, 通过索引查询一个数据是无需遍历索引记录的
    极端情况下，数据索引的查询效率为二分法查询效率,趋近于log2(N)

3.添加缓存
 例如:mybatis 一/二级缓存 该操作效率低
 主要:redis/memercache
 作用:可以有效的缓解数据库压力。

4.使用数据库的读写分离

5.定期将历史数据进行转储
 当前表/查询历史表
6.进行分库分表(最后策略，最有效的策略)
 数据库服务器数量和运维都要花费很多的时间和精力
 什么是表分区?
    表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成
    表分区与分表的区别?
    分表：指的是通过一定规则， 将一张表分解成多 张不同的表。比如将用户订单记录根据时间成多个表。
    分表与分区的区别在于:分区从逻辑上来讲只有一张表 ,而分表则是将一张表分解成多张表。

    表分区有什么好处?
    存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据
    优化E询。在where语句中包含分区条件时，可以只扫描一个或多 个分区表来提高查询效率;涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。
    分区表更容易维护。例如:想批量删除大量数据可以清除整个分区。
    避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问， ext3问价你系统的inode锁竞争等。
7.选择正确的存储引擎
</code></pre> 
<h4><a id="MySql_1035"></a><strong>MySql集群主从复制</strong>（主从同步）</h4> 
<p><strong>原理</strong></p> 
<p>主(master) 从(slave)</p> 
<ol><li> <p>master将数据改变记录到二进制日志（binary log）中，即配置文件log-bin指定的文件（这些记录叫做二进制日志事件，binary log events）</p> </li><li> <p>slave 将 master 的 binary log events 拷贝到它的中继日志（relay log）</p> </li><li> <p>slave重做中继日志中的事件，将改变反映它自己的数据（数据重演）</p> <p>\1. 主库和从库的版本要一致</p> <p>\2. 主库和从库的数据一致</p> <p>\3. 主库开启二进制日志，主库和从库的server_id都必须唯一</p> <p><strong>在项目中，使用读写分离本质上就是，增加数据库服务器资源 + 网络带宽，来分摊对数据库的读写请求，从而提高了性能和可用性。主从复制实现读写分离最大的缺点就是从库同步到主库的数据存在延迟，网络不好的时候，延迟比较严重。</strong></p> </li></ol> 
<h4><a id="mysql_1055"></a>mysql默认的存储引擎是什么？</h4> 
<pre><code>Mysql在V5.1之前默认存储引擎是MyISAM；在此之后默认存储引擎是InnoDB。
MyISAM不支持事务，InnoDB支持事务。
MySIAM不支持外键，InnoDB支持外键，
MySIAM支持全文索引，InnoDB不支持全文索引。
</code></pre> 
<h4><a id="MyISAMInnoDB_1064"></a>MyISAM与InnoDB的区别？</h4> 
<ul><li> <p>InnoDB 支持事务；MyISAM 不支持事务</p> </li><li> <p>InnoDB 支持行级锁；MyISAM 支持表级锁</p> </li><li> <p>InnoDB 支持 MVCC(多版本并发控制)；MyISAM 不支持</p> </li><li> <p>InnoDB 支持外键，MyISAM 不支持</p> </li><li> <p>MySQL 5.6 以前的版本，InnoDB 不支持全文索引，MyISAM 支持；MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引</p> </li><li> <p>InnoDB 不保存表的总行数，执行 select count(*) from table 时<br> 需要全表扫描；MyISAM 用一个变量保存表的总行数，查总行数速度很快</p> </li><li> <p>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，<br> 通过主键索引效率很高。辅助索引需要两次查询，先查询到主键，再通过主键查询到数据。主键太大，其他索引也会很大；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的</p> <p><strong>总结</strong></p> </li><li> <p>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</p> </li><li> <p>MyISAM 不支持事务、也不支持外键，优势是访问的速度快。对事务的完整性没有要求、以 SELECT 和 INSERT 为主的应用可以使用这个存储引擎</p> </li></ul> 
<h4><a id="Innodb_1087"></a>Innodb引擎有什么特性？</h4> 
<ul><li>插入缓冲(insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul> 
<h4><a id="_1094"></a>数据库的三范式是什么？有什么作用？</h4> 
<ul><li>列不可分，确保表的每一列都是不可分割的原子数据项。作用：方便字段的维护、查询效率高、易于统计。</li><li>属性字段完全依赖（完全依赖指不能存在仅依赖主键的部分属性）于主键。作用：保证每行数据都是按主键划分的独立数据。</li><li>任何非主属性字段不依赖于其它非主属性字段。作用：减少表字段与数据存储，让相互依赖的非主键字段单独成为一张关系表，记录被依赖字段即可。</li></ul> 
<h4><a id="Mysql_1100"></a>Mysql驱动程序是什么？</h4> 
<ul><li>Mysql 提供给 Java 编程语言的驱动程序就是这样 mysql-connector-java-5.1.18.jar 包</li><li>针对不同的数据库版本，驱动程序包版本也不同</li><li>不同的编程语言，驱动程序的包形式也是不一样的</li><li>驱动程序主要帮助编程语言与 MySQL 服务端进行通信，如果连接、关闭、传输指令与数据等</li></ul> 
<h4><a id="MySQL_1107"></a>如何连接MySQL服务端、关闭连接？</h4> 
<ul><li>连接：使用指令 mysql -u -p -h -P (-u:指定用户名 -p:指定密码 -h:主机 -P:端口) 连接 MySQL 服务端</li><li>关闭：使用指令 exit 或 quit</li></ul> 
<h4><a id="_1112"></a>左连接、右连接、内连接和全外连接的区别</h4> 
<ul><li>左连接(left join)：返回包括左表中的所有记录和右表中连接字段相等的记录。</li><li>右连接(right join)：返回包括右表中的所有记录和左表中连接字段相等的记录。</li><li>内连接(inner join)：只返回两个表中连接字段相等的记录。</li><li>全外连接(full join)：返回左右表中连接字段相等的记录和剩余所有记录。</li></ul> 
<h4><a id="_1119"></a><strong>什么是表分区？</strong></h4> 
<p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p> 
<h4><a id="_1123"></a><strong>表分区与分表的区别</strong></h4> 
<p><strong>分表</strong>：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p> 
<p><strong>分表与分区的区别在于</strong>：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p> 
<h4><a id="_1129"></a><strong>表分区有什么好处？</strong></h4> 
<p>1、<strong>存储更多数据</strong>。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据</p> 
<p>2、<strong>优化查询</strong>。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</p> 
<p>3、<strong>分区表更容易维护</strong>。例如：想批量删除大量数据可以清除整个分区。</p> 
<p>4、<strong>避免某些特殊的瓶颈</strong>，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</p> 
<h4><a id="_1139"></a><strong>分区表的限制因素</strong></h4> 
<ol><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ol> 
<h4><a id="MySQL_1147"></a><strong>如何判断当前MySQL是否支持分区？</strong></h4> 
<p>命令：show variables like ‘%partition%’ 运行结果:</p> 
<p>have_partintioning 的值为YES，表示支持分区。</p> 
<h4><a id="MySQL_1153"></a><strong>MySQL支持的分区类型有哪些？</strong></h4> 
<ol><li><strong>RANGE分区</strong>： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li><strong>LIST分区</strong>： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li><strong>HASH分区</strong> ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li><strong>KEY分区</strong> ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ol> 
<h4><a id="_1160"></a>如何实现分库分表？怎么配置？</h4> 
<p><strong>分库分表的实现方案，一般分为两种</strong></p> 
<p>1、增加一个中间层，中间层实现 MySQL 客户端协议，可以做到应用程序无感知地与中间层交互。由于是基于协议层的代理，可以做到支持多语言，但需要多启动一个进程、SQL 的解析也耗费大量性能、由于协议绑定仅支持单个种类的数据库库。</p> 
<p>2、在代码层面增加一个路由程序，控制对数据库与表的读写。路由程序写在项目里，与编程语言绑定、连接数高、但相对轻量（比如 Java 仅需要引入 SharingShpere 组件中 Sharding-JDBC 的 jar 即可）、支持任意数据库。</p> 
<h4><a id="_1168"></a>索引</h4> 
<p>Mysql索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p> 
<p>Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p> 
<p><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p> 
<p><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></p> 
<h4><a id="_1178"></a>什么是索引？什么场景使用？</h4> 
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p> 
<p>使用索引目的是加快检索表中数据</p> 
<p>使用场景：</p> 
<ul><li>中到大数据量表适合使用索引</li><li>小数据量表，大部分情况全表扫描效率更高</li><li>特大数据量表，建立和使用索引的代价会随之增大，适合使用分区或分库</li></ul> 
<h4><a id="_1192"></a>索引如何创建与删除？</h4> 
<ul><li>创建单个字段索引的语法：CREATE INDEX 索引名 on 表名(字段名)</li><li>创建联合索引的语法：CREATE INDEX 索引名 on 表名(字段名1，字段名2)</li><li>索引命名格式一般可以这样：idx_表名_字段名。注意有长度限制</li><li>删除索引：DROP INDEX 索引名 ON 表名</li></ul> 
<h4><a id="_1199"></a>索引的种类有哪些？</h4> 
<ul><li>普通索引：最基本的索引，没有任何约束限制。列值<strong>可以取空值或重复值</strong>。创建使用关键字INDEX或KEY；</li><li>唯一索引：和普通索引类似，但是具有唯一性约束，可以有 null；创建使用关键字UNIQUE；</li><li>主键索引：特殊的唯一索引，主键索引是系统自动创建的主键索引，<strong>并且是唯一的</strong>。与唯一索引区别是；<strong>列值不能为空</strong>；</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li><li>聚簇索引：就是数据存储的物理存储顺序，非聚簇索引就是索引顺序与数据的物理顺序无关。一个表只能有一个聚簇索引。目前只有InoDB和solidDB支持。</li><li>全文索引：对文本的内容进行分词、搜索</li><li>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</li></ul> 
<h4><a id="MySQL_1209"></a>MySQL创建和使用索引的注意事项？</h4> 
<ul><li>适合创建索引的列是出现在 WHERE 或 ON 子句中的列，而不是出现在 SELECT 关键字后的列</li><li>索引列的基数越大，数据区分度越高，索引的效果越好</li><li>对字符串列进行索引，可制定一个前缀长度，节省索引空间</li><li>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率</li><li>主键尽可能选择较短的数据类型，可减少索引的磁盘占用，提高查询效率</li><li>联合索引遵循前缀原则</li><li>LIKE 查询，%在前不到索引，可考虑使用 ElasticSearch、Lucene 等搜索引擎</li><li>MySQL 在数据量较小的情况可能会不使用索引，因为全表扫描比使用索引速度更快</li><li>关键词 or 前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到</li><li>列类型是字符串，查询时一定要给值加引号，否则索引失效</li><li>联合索引要遵从最左前缀原则，否则不会用到索引</li></ul> 
<h4><a id="_1223"></a>说一些索引失效的情况</h4> 
<ul><li>如果条件中有 or，即使其中有部分条件是索引字段，也不会使用索引</li><li>复合索引，查询条件不使用索引前面的字段，后续字段也将无法使用索引</li><li>以 % 开头的 like 查询</li><li>索引列的数据类型存在隐形转换</li><li>where 子句里对索引列有数学运算</li><li>where 子句里对索引列使用函数</li><li>MySQL 引擎估算使用全表扫描要比使用索引快，则不使用索引</li></ul> 
<h4><a id="_1233"></a>索引对性能有哪些影响？</h4> 
<p>优点：</p> 
<ul><li>减少数据库服务器需要扫描的数据量</li><li>帮助数据库服务器避免排序和临时表</li><li>将随机 I/O 变顺序I/O</li><li>提高查询速度</li><li>唯一索引，能保证数据的唯一性</li></ul> 
<p>缺点：</p> 
<ul><li>索引的创建和维护耗时随着数据量的增加而增加</li><li>对表中数据进行增删改时，索引也要动态维护，降低了数据的维护速度</li><li>增大磁盘占用</li></ul> 
<h3><a id="NULL_1249"></a>列值为NULL时，查询是否会用到索引？</h3> 
<p>MySQL 中存在 NULL 值的列也是走索引的</p> 
<p>计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度</p> 
<h4><a id="_1255"></a><strong>缓存</strong></h4> 
<p>my.cnf加入以下配置，重启Mysql开启查询缓存</p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">query_cache_type</span><span class="token operator">=</span><span class="token number">1</span>



<span class="token assign-left variable">query_cache_size</span><span class="token operator">=</span><span class="token number">600000</span>
</code></pre> 
<p>Mysql执行以下命令也可以开启查询缓存</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">set</span> global  <span class="token assign-left variable">query_cache_type</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>



<span class="token builtin class-name">set</span> global  <span class="token assign-left variable">query_cache_size</span><span class="token operator">=</span><span class="token number">600000</span><span class="token punctuation">;</span>
</code></pre> 
<p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果也不会被缓存。</p> 
<p>缓存建立之后，Mysql的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p> 
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</strong></p> 
<pre><code class="prism language-bash"><span class="token keyword">select</span> sql_no_cache count<span class="token punctuation">(</span>*<span class="token punctuation">)</span> from usr<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1287"></a><strong>为什么使用数据索引能提高效率</strong></h4> 
<ol><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ol> 
<h4><a id="_1295"></a>锁</h4> 
<p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p> 
<ul><li> <p>MyISAM采用表级锁(table-level locking)。</p> </li><li> <p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p> <p><strong>表级锁和行级锁对比：</strong></p> </li><li> <p><strong>表级锁：</strong> Mysql中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p> </li><li> <p><strong>行级锁：</strong> Mysql中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p> <p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p> </li><li> <p>Record lock：单个行记录上的锁</p> </li><li> <p>Gap lock：间隙锁，锁定一个范围，不包括记录本身</p> </li><li> <p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p> </li></ul> 
<h4><a id="_1317"></a><strong>行级锁定的优点：</strong></h4> 
<p>1、当在许多线程中访问不同的行时只存在少量锁定冲突。</p> 
<p>2、回滚时只有少量的更改</p> 
<p>3、可以长时间锁定单一的行。</p> 
<h4><a id="_1325"></a><strong>行级锁定的缺点：</strong></h4> 
<ol><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ol> 
<h4><a id="MySQL_1332"></a>MySQL的乐观锁和悲观锁？</h4> 
<p>乐观锁：每次去获取数据的时候都认为别人不会修改，不会上锁，但是在提交修改的时候会判断一下在此期间别人有没有修改这个数据。<br> 悲观锁：每次去获取数据的时候都认为别人会修改，每次都会上锁，阻止其他线程获取数据，直到这个锁释放。</p> 
<p>MySQL 的乐观锁需要自己实现。一般在表里面添加一个 version 字段，每次修改成功值加 1；每次其他字段值的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就可以返回失败也可以进行重试。</p> 
<p>MySQL 的悲观锁，以 Innodb 存储引擎为例，将 MySQL 设置为非 autoCommit 模式</p> 
<pre><code class="prism language-javascript">begin<span class="token punctuation">;</span>
select <span class="token operator">*</span> from table where id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> update<span class="token punctuation">;</span>
insert <span class="token operator">...</span>
update <span class="token operator">...</span>
commit<span class="token punctuation">;</span>
</code></pre> 
<p>当上面语句未 commit，id = 1 的数据是被锁定的，即其他事务中的查到这条语句会被阻塞，直到事务提交。</p> 
<p>数据的锁定还涉及到索引的不同可能是行锁、表锁的问题。</p> 
<h4><a id="MySQL_1353"></a>MySQL中如何避免死锁？</h4> 
<ul><li>尽量以相同的顺序来访问索引记录和表</li><li>业务上能够接受幻读和不可重复读，考虑降低锁的级别到 Read committed，降低死锁发生的概率</li><li>添加合理的索引，走索引避免为每一行加锁，降低死锁的概率</li><li>在事务中一次锁定所需要的所有资源，如 MyISAM 引擎的表锁</li><li>避免大事务，尽量将大事务拆成多个小事务来处理</li><li>尽量避免同时并发对同一表进行读写操作，特别是执行加锁且操作数据量较大的语句</li><li>设置锁等待超时参数</li></ul> 
<h4><a id="MySQL__1363"></a>MySQL 单表上亿，怎么优化分页查询？</h4> 
<p><strong>1、表容量的问题</strong></p> 
<p>首先，MySQL 不管怎么优化也是很难支持单表一亿数据量带查询条件的分页查询，需要提前考虑分表分库。单表设计以 200-500 万为宜；优化的好，单表数据到一两千万，性能也还行。出现那么单表那么大的数据量，已经是设计问题了。</p> 
<p><strong>2、总页数的问题</strong></p> 
<p>页面<strong>不需要显示总页数</strong>，仅显示附近的页码，这样可以避免单表总行数的查询。</p> 
<p><strong>需要显示总页数</strong>，这种情况就比较难处理一些。首先 MySQL 的 MyISAM 引擎把一个表的总行数记录在磁盘中，查询 count(*) 可以直接返回；InnoDB 引擎是一行行读出来累加计数，大数据量时性能堪忧，大几秒甚至几十秒都有可能（我相信你一定遇到过）。所以 MyISAM 的总行数查询速度是比 InnoDB 快的，但这个快也仅限于不带 where 条件的。MyISAM 还有一个硬伤，不支持事务。</p> 
<p><strong>3、具体的 SQL 优化</strong></p> 
<p>新增表记录业务表的总数，也是无法彻底解决带查询条件的总行数查询慢的问题。这里只能借助具体的 SQL 优化。</p> 
<p><strong>不带条件 + 自增 id 字段连续</strong></p> 
<p>这种理想情况就不讨论了，通过 pageNo 和 pageSize 算出 id 的起始与结束值</p> 
<pre><code class="prism language-javascript">where id <span class="token operator">&gt;=</span> <span class="token operator">?</span> and id <span class="token operator">&lt;</span><span class="token operator">?</span>
where id between
where id <span class="token operator">&gt;=</span> <span class="token operator">?</span> limit <span class="token number">10</span>
</code></pre> 
<p>就可以直接搞定了。</p> 
<p><strong>带查询条件 + 主键 id 不连续</strong></p> 
<p>这种就是我们最需要解决的情况。使用 limit 分页，有个查询耗时与起始记录的位置成正比的问题，所以不能直接使用。</p> 
<p>可以这样根据主键进行关联查询</p> 
<pre><code class="prism language-javascript">select <span class="token operator">*</span> from table t1
<span class="token function">join</span> <span class="token punctuation">(</span>select id from table where condition limit <span class="token number">10</span><span class="token punctuation">)</span> t2
on t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id 
order by t1<span class="token punctuation">.</span>id asc
</code></pre> 
<p>其中 condition 是包含索引的查询条件，使用 id 字段进行具体信息的关联回查。当然查询条件 condition 中索引是否生效对性能影响也很大。</p> 
<p>索引没有生效的一些情况：</p> 
<ul><li>组合索引的「最左前缀」原则</li><li>or 的使用可能导致索引未生效，可使用 union all 替代</li><li>like 查询以 % 开头</li><li>对 null 值判断</li><li>使用 != 或 &lt;&gt; 操作符</li><li>索引列上使用计算、函数</li></ul> 
<p><strong>4、其他解法</strong></p> 
<ul><li>继续优化数据库配置</li><li>提升数据库服务器硬件性能</li><li>引入大数据组件</li><li>引入大型商业数据库或者非关系型数据库解决大表问题</li></ul> 
<h4><a id="MySQL_1422"></a>MySQL有哪些常用函数？</h4> 
<p><strong>数值型函数</strong></p> 
<ul><li>ABS：计算绝对值 SQRT：计算二次方根 MOD：计算余数 CEIL、CEILING：返回不小于参数的最小整数，即向上取整 
  <ul><li>FLOOR：向下取整，返回值转化为一个 BIGINT RAND：生成一个 0~1 之间的随机数</li></ul> </li><li>ROUND：四舍五入</li><li>SIGN：返回参数的符号</li><li>POW、POWER：参数次方的值</li></ul> 
<p><strong>字符串函数</strong></p> 
<ul><li>LENGTH：返回字符串的字节长度</li><li>CONCAT：合并字符串，返回结果为连接参数产生的字符串，参数可以使一个或多个</li><li>INSERT：替换字符串</li><li>LOWER：将字符串中的字母转换为小写</li><li>UPPER：将字符串中的字母转换为大写</li><li>LEFT：从左侧字截取符串，返回字符串左边的若干个字符</li><li>RIGHT：从右侧字截取符串，返回字符串右边的若干个字符</li><li>TRIM：删除字符串左右两侧的空格</li><li>REPLACE：字符串替换，返回替换后的新字符串</li><li>SUBSTRING：截取字符串，返回从指定位置开始的指定长度的字符换</li><li>REVERSE：字符串反转，返回与原始字符串顺序相反的字符串</li></ul> 
<p><strong>聚合函数</strong></p> 
<ul><li>MAX：查询指定列的最大值</li><li>MIN：查询指定列的最小值</li><li>COUNT：统计查询结果的行数</li><li>SUM：求和，返回指定列的总和</li><li>AVG：求平均值，返回指定列数据的平均值</li></ul> 
<p><strong>流程控制函数</strong></p> 
<ul><li>IF：判断是否为 true</li><li>IFNULL：判断是否为空</li><li>CASE：分支判断</li></ul> 
<h4><a id="OracleMysql_1460"></a>与Oracle相比，Mysql有什么优势？</h4> 
<ul><li>Mysql 是开源软件、无需付费</li><li>操作简单、部署方便，用户可以根据应用的需求去定制数据库</li><li>Mysql 的引擎是插件式</li></ul> 
<h4><a id="MySQLSQL_1466"></a>MySQL如何进行慢SQL优化？</h4> 
<p>思路：</p> 
<ul><li>通过慢查询日志去寻找哪些 SQL 执行效率低</li><li>使用 explain 获取低效率 SQL 的执行计划</li><li>结合 SQL 与执行计划，进行分析与优化</li></ul> 
<p>引起 SQL 查询很慢的原因与解决办法：</p> 
<p>1、没有索引。解决办法：</p> 
<ul><li>根据 where 和 order by 使用比较频繁的字段创建索引，提高查询效率</li><li>索引不宜过多，单表最好不要超过 6 个。索引过多会导致占用存储空间变大；insert、update 变慢</li><li>删除未使用的索引</li></ul> 
<p>2、索引未生效。解决办法：</p> 
<ul><li>避免在 where 子句中对字段进行 null 值判断，创建表默认值是 NULL。尽量使用 NOT NULL，或使用特殊值，如 0、-1</li><li>避免在 where 子句中使用 != 或 &lt;&gt; 操作符， MySQL 只有对以下操作符才使用索引：&lt;、&lt;=、=、&gt;、&gt;=、BETWEEN、IN、非 % 开头的 LIKE</li><li>避免在 where 子句中使用 or 来连接条件，可以使用 UNION 进行连接</li><li>能用 union all 就不用 union，union 过滤重复数据要耗费更多的 CPU 资源</li><li>避免部分 like 查询，如 ‘%ConstXiong%’</li><li>避免在索引列上使用计算、函数</li><li>in 和 not in 慎用，能用 between 不要用 in</li><li>select 子句中避免使用 *</li></ul> 
<p>3、单表数据量太大。解决办法：</p> 
<ul><li>分页查询(在索引上完成排序分页操作、借助主键进行关联)</li><li>单表数据过大，进行分库分表</li><li>考虑使用非关系型数据库提高查询效率</li><li>全文索引场景较多，考虑使用 ElasticSearch、solr</li></ul> 
<p>提升性能的一些技巧：</p> 
<ul><li>尽量使用数字型字段</li><li>只需要一行数据时使用 limit 1</li><li>索引尽量选择较小的列</li><li>不需要的数据在 GROUP BY 之前过滤掉</li><li>大部分时候 exists、not exists 比 in、not in 效率（除了子查询是小表的情况使用 in 效率比 exists 高）</li><li>不确定长度的字符串字段使用 varchar/nvarchar，如使用 char/nchar 定长存储会带来空间浪费</li><li>不要使用 select *，去除不需要的字段查询</li><li>避免一次性查询过大的数据量</li><li>使用表别名，减少多表关联解析时间</li><li>多表 join 最好不超过 5 个，视图嵌套最好不超过 2 个</li><li>or 条件查询可以拆分成 UNION 多个查询</li><li>count(1) 比 count(*) 有效</li><li>判断是否存在数据使用 exists 而非 count，count 用来获取数据行数</li></ul> 
<h4><a id="sql_1516"></a>如何避免sql注入？</h4> 
<ul><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ul> 
<h4><a id="XSS_1525"></a>什么是XSS攻击，如何避免？</h4> 
<p><strong>XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。</strong></p> 
<ul><li>web 页面中可由用户输入的地方，如果对输入的数据转义、过滤处理</li><li>后台输出页面的时候，也需要对输出内容进行转义、过滤处理（因为攻击者可能通过其他方式把恶意脚本写入数据库）</li><li>前端对 html 标签属性、css 属性赋值的地方进行校验</li></ul> 
<h4><a id="CSRF_1533"></a>什么是CSRF攻击，如何避免？</h4> 
<p><strong>CSRF：Cross Site Request Forgery（跨站点请求伪造）。</strong><br> CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p> 
<p><strong>避免方法：</strong></p> 
<ul><li>CSRF 漏洞进行检测的工具，如 CSRFTester、CSRF Request Builder…</li><li>验证 HTTP Referer 字段</li><li>添加并验证 token</li><li>添加自定义 http 请求头</li><li>敏感操作添加验证码</li><li>使用 post 请求</li></ul> 
<h2><a id="Oracle_1547"></a>Oracle========================================</h2> 
<h4><a id="Oracle_1549"></a>Oracle中字符串链接符是什么？</h4> 
<p>Oracle中使用 || 这个符号连接字符串</p> 
<p>如 ‘Const’ || ‘Xiong’</p> 
<h4><a id="Oracle_1555"></a><strong>Oracle中有哪几种文件？</strong></h4> 
<p>数据文件（一般后缀为.dbf或者.ora），日志文件(后缀名.log)，控制文件（后缀名为.ctl）*</p> 
<h4><a id="Oracle_1559"></a><strong>Oracle优化</strong></h4> 
<p>个人理解，数据库性能最关键的因素在于IO，因为操作内存是快速的，但是读写磁盘是速度很慢的，优化数据库最关键的问题在于减少磁盘的IO，就个人理解应该分为物理的和逻辑的优化， 物理的是指oracle产品本身的一些优化，逻辑优化是指应用程序级别的优化<br> 物理优化的一些原则：<br> 1). Oracle的运行环境（网络，硬件等）<br> 2). 使用合适的优化器<br> 3). 合理配置oracle实例参数<br> 4). 建立合适的索引（减少IO）<br> 5). 将索引数据和表数据分开在不同的表空间上（降低IO冲突）<br> 6). 建立表分区，将数据分别存储在不同的分区上（以空间换取时间，减少IO）<br> <strong>逻辑上优化：</strong><br> 1). 可以对表进行逻辑分割，如中国移动用户表，可以根据手机尾数分成10个表，这样对性能会有一定的作用<br> 2). Sql语句使用占位符语句，并且开发时候必须按照规定编写sql语句（如全部大写，全部小写等）oracle解析语句后会放置到共享池中<br> 如： select * from Emp where name=? 这个语句只会在共享池中有一条，而如果是字符串的话，那就根据不同名字存在不同的语句，所以占位符效率较好<br> 3). 数据库不仅仅是一个存储数据的地方，同样是一个编程的地方，一些耗时的操作，可以通过存储过程等在用户较少的情况下执行，从而错开系统使用的高峰时间，提高数据库性能<br> 4). 尽量不使用*号，如select * from Emp，因为要转化为具体的列名是要查数据字典，比较耗时<br> 5). 选择有效的表名<br> 对于多表连接查询，可能oracle的优化器并不会优化到这个程度， oracle 中多表查询是根据FROM字句从右到左的数据进行的，那么最好右边的表（也就是基础表）选择数据较少的表，这样排序更快速，如果有link表（多对多中间表），那么将link表放最右边作为基础表，在默认情况下oracle会自动优化，但是如果配置了优化器的情况下，可能不会自动优化，所以平时最好能按照这个方式编写sql<br> 6). Where字句 规则<br> Oracle 中Where字句时从右往左处理的，表之间的连接写在其他条件之前，能过滤掉非常多的数据的条件，放在where的末尾， 另外!=符号比较的列将不使用索引，列经过了计算（如变大写等）不会使用索引（需要建立起函数）， is null、is not null等优化器不会使用索引<br> 7). 使用Exits Not Exits 替代 In Not in<br> 8). 合理使用事务，合理设置事务隔离性<br> 数据库的数据操作比较消耗数据库资源的，尽量使用批量处理，以降低事务操作次数</p> 
<h4><a id="Oracle_1583"></a>Oracle有哪几种索引?</h4> 
<ul><li>单列索引与复合索引</li></ul> 
<p>单列索引是基于单列所创建的索引，复合索引是基于两列或者多列所创建的索引</p> 
<ul><li>唯一索引与非唯一索引</li></ul> 
<p>唯一索引是索引列值不能重复的索引，非唯一索引是索引列可以重复的索引。都允许取 NULL 值，默认 Oracle 创建的索引是不唯一索引</p> 
<ul><li>B 树索引</li></ul> 
<p>B 树索引是按 B 树算法组织并存放索引数据的，B 树索引主要依赖其组织并存放索引数据的算法来实现快速检索功能</p> 
<ul><li>位图索引</li></ul> 
<p>它采用位图偏移方式来与表的行 ROWID 号对应，通过位图索引中的映射函数完成位到行的 ROWID 的转换</p> 
<p>主要用于节省空间，减少oracle对数据块的访问</p> 
<p>采用位图索引一般是重复值太多、只有几个枚举值的表字段</p> 
<ul><li>函数索引</li></ul> 
<p>Oracle 对包含列的函数或表达式创建的索引</p> 
<h4><a id="oracle_1609"></a>哪些因素影响oracle查询性能？</h4> 
<ul><li>硬件：处理器速度，内存大小，磁盘读写速度，网络传输速度等</li><li>索引：是否建立了索引，索引是否合理</li><li>碎片：表碎片和索引碎片，生产库长时间运营，碎片可能导致查询使用错误的执行计划，导致查询速度变慢</li><li>initial 参数：表或索引的 initial 参数配置不同，导致数据扩展区大小不一，也可能导致查询速度降低</li><li>慢 SQL：编写的 SQL 执行效率低，查询速度慢</li><li>负载：数据库负载过大</li></ul> 
<h4><a id="Oracle_1618"></a>Oracle中排序对性能的影响？</h4> 
<p>order by 只有满足如下情况才会使用索引：</p> 
<ul><li>order by中的列必须包含相同的索引并且索引顺序和排序顺序一致</li><li>不能有 null 值的列</li></ul> 
<p>所以排序的性能并不高，尽量避免 order by</p> 
<h4><a id="Oracle_1627"></a><strong>Oracle中字符串用什么符号链接？</strong></h4> 
<p>Oracle中使用 || 这个符号连接字符串 如 ‘abc’ || ‘d’</p> 
<h4><a id="Oracle_1631"></a>Oracle有哪些备份方式？</h4> 
<p>备份就是把数据库复制到转储设备的过程</p> 
<p><strong>从物理与逻辑的角度：</strong></p> 
<ul><li>物理备份：对数据库操作系统的物理文件(数据文件、控制文件、日志文件)的备份。物理备份又可以分为脱机备份(冷备份)和联机备份(热备份)，前者是在关闭数据库的时候进行的，后者是以归档日志的方式对运行的数据库进行备份</li><li>逻辑备份：对数据库逻辑组件(如表和存储过程等数据库对象)的备份。逻辑备份的手段很多，如 EXP、EXPDP、第三方工具</li></ul> 
<p><strong>从数据库的备份角度：</strong></p> 
<ul><li>完全备份：每次对数据库进行完整备份</li><li>增量备份：在上次完全备份或增量备份后被修改的文件才会被备份</li><li>差异备份：备份自从上次完全备份之后被修改过的文件</li></ul> 
<h4><a id="_1646"></a>冷备和热备的优缺点？</h4> 
<p>冷备发生在数据库已经正常关闭的情况下，将数据库文件拷贝到其他位置<br> 热备是在数据库运行的情况下，采用归档方式备份数据</p> 
<p><strong>冷备的优缺点：</strong></p> 
<ul><li> <p>只需拷贝文件，非常快速</p> </li><li> <p>拷贝即可，容易归档</p> </li><li> <p>文件拷贝回去，即可恢复到某个时间点上</p> </li><li> <p>能与归档方法相结合<br> <strong>冷备份的不足：</strong></p> </li><li> <p>只能提供到数据库文件备份的时间点的恢复</p> </li><li> <p>在冷备过程中，数据库必须是关闭状态，不能工作</p> </li><li> <p>不能按表或按用户恢复</p> </li></ul> 
<p><strong>热备的优缺点：</strong></p> 
<ul><li> <p>可在表空间或数据文件级备份</p> </li><li> <p>备份时数据库可用</p> </li><li> <p>可达到秒级恢复到某时间点</p> </li><li> <p>可对几乎所有数据库实体作恢复</p> </li><li> <p>数据完整性与一致性好<br> <strong>热备份的不足：</strong></p> </li><li> <p>维护较复杂</p> </li><li> <p>设备要求高，网络环境稳定性要求高</p> </li><li> <p>若热备份不成功，所得结果不可用</p> </li></ul> 
<h4><a id="Oracle_1676"></a>Oracle怎么分页？</h4> 
<p>Oracle 使用 rownum 进行分页</p> 
<pre><code class="prism language-javascript">select col1<span class="token punctuation">,</span>col2 <span class="token function">from</span> 
  <span class="token punctuation">(</span> select rownum r<span class="token punctuation">,</span>col1<span class="token punctuation">,</span>col2 from tablename where rownum <span class="token operator">&lt;=</span> <span class="token number">20</span> <span class="token punctuation">)</span> 
where r <span class="token operator">&gt;</span> <span class="token number">10</span> 
</code></pre> 
<h4><a id="__1686"></a><strong>怎样创建一个视图,视图的好处, 视图可以控制权限吗?</strong></h4> 
<p>create view 视图名 as select 列名 [别名] … from 表 [unio [all] select … ] ]<br> 好处：<br> \1. 可以简单的将视图理解为sql查询语句，视图最大的好处是不占系统空间<br> \2. 一些安全性很高的系统，不会公布系统的表结构，可能会使用视图将一些敏感信息过虑或者重命名后公布结构<br> \3. 简化查询<br> 可以控制权限的，在使用的时候需要将视图的使用权限grant给用户</p> 
<h4><a id="rowid_rownum_1695"></a><strong>rowid, rownum的定义</strong></h4> 
<p>\1. rowid和rownum都是虚列<br> \2. rowid是物理地址，用于定位oracle中具体数据的物理存储位置<br> \3. rownum则是sql的输出结果排序，从下面的例子可以看出其中的区别。</p> 
<h4><a id="oracle_1701"></a>oracle中存储过程，游标和函数的区别</h4> 
<p>游标类似指针，游标可以执行多个不相关的操作.如果希望当产生了结果集后,对结果集中的数据进行多 种不相关的数据操作<br> 函数可以理解函数是存储过程的一种； 函数可以没有参数,但是一定需要一个返回值，存储过程可以没有参数,不需要返回值；两者都可以通过out参数返回值, 如果需要返回多个参数则建议使用存储过程；在sql数据操纵语句中只能调用函数而不能调用存储过程</p> 
<h4><a id="Oracle_1706"></a>Oracle怎样实现每天备份一次？</h4> 
<p>通过操作系统的定时任务调用脚本导出数据库</p> 
<p><strong>windows：</strong></p> 
<pre><code class="prism language-javascript">在 任务计划程序 里创建基本任务，设置备份周期，执行 bat 脚本，脚本参考：
cd d<span class="token operator">:</span>\oracle_back
del oracle<span class="token punctuation">.</span>dmp
expdp username<span class="token operator">/</span>password@orcl directory<span class="token operator">=</span><span class="token constant">DIR_EXP</span> dumpfile<span class="token operator">=</span>oracle<span class="token punctuation">.</span>dmp
</code></pre> 
<p><strong>linux：</strong></p> 
<pre><code class="prism language-javascript">通过 crontab 制作定时任务，执行 shell 脚本，脚本参考：
cd <span class="token operator">/</span>back<span class="token operator">/</span>oracle_back
rm oracle<span class="token punctuation">.</span>dmp
expdp username<span class="token operator">/</span>password@orcl directory<span class="token operator">=</span><span class="token constant">DIR_EXP</span> dumpfile<span class="token operator">=</span>oracle<span class="token punctuation">.</span>dmp
</code></pre> 
<h4><a id="Oracle_1728"></a>Oracle分区有哪些作用?</h4> 
<ul><li>Oracle的分区分为：列表分区、范围分区、散列分区、复合分区</li><li>增强可用性：表的一个分区由于系统故障不能使用，其他好的分区仍可以使用</li><li>减少故障修复时间：如果系统故障只影响表的一部份分区，只需修复部分分区，比修复整个表花的时间少</li><li>维护轻松：独产管理公区比管理单个大表轻松</li><li>均衡 I/O：把表的不同分区分配到不同的磁盘，平衡 I/O</li><li>改善性能：对大表的查询、增加、修改等操作可以分解到表的不同分区来并行执行，加快执行速度</li><li>在使用层是感觉不到分区的存在</li></ul> 
<h4><a id="Oracle_1738"></a>Oracle数据库如何迁移？</h4> 
<ul><li>使用 imp/exp 将老库中的数据导入到新的库中。可以跨平台使用，但停机时间长</li><li>如果是存储迁移直接将存储设备挂到新机器上，在新机器上启动数据库。这种方式操作简单，但要求新老库版本一致</li><li>使用 rman，适合跨文件系统的迁移</li><li>使用 dataguard 迁移</li><li>借助工具，如 pl/sql</li></ul> 
<h4><a id="oracle_1746"></a>oracle临时表有几种。</h4> 
<p>临时表和普通表的主要区别有哪些，使用临时表的主要原因是什么？</p> 
<p>在Oracle中，可以创建以下两种临时表：<br> a。会话特有的临时表<br> CREATE GLOBAL TEMPORARY ( )<br> ON COMMIT PRESERVE ROWS；</p> 
<p>b。事务特有的临时表<br> CREATE GLOBAL TEMPORARY ( )<br> ON COMMIT DELETE ROWS；<br> CREATE GLOBAL TEMPORARY TABLE MyTempTable<br> 所建的临时表虽然是存在的，但是你试一下insert 一条记录然后用别的连接登上去select，记录是空的，明白了吧。<br> 下面两句话再贴一下：<br> –ON COMMIT DELETE ROWS 说明临时表是事务指定，每次提交后ORACLE将截断表（删除全部行）<br> –ON COMMIT PRESERVE ROWS 说明临时表是会话指定，当中断会话时ORACLE将截断表。</p> 
<h4><a id="Oracle_1764"></a>Oracle存储文件类型的字段？</h4> 
<ul><li>clob：可变长度的字符型数据，文本型数据类型</li><li>nclob：可变字符类型的数据，存储的是 Unicode 字符集的字符数据</li><li>blob：可变长度的二进制数据</li><li>Bfile：存储在数据库外的操作系统文件，变二进制数据，不参与数据库事务操作</li></ul> 
<h4><a id="oracle_1771"></a>oracle数据库中有多行相同数据,只留一行怎么实现?</h4> 
<p>distinct 函数查询出来 插入另一张表 最简单了</p> 
<p>select distinct col1,col2,col3 from table</p> 
<h2><a id="Redis_1777"></a>Redis=========================================</h2> 
<h3><a id="Redis_1779"></a>介绍一下Redis</h3> 
<p>Redis 是一款使用 C 语言编写的高性能 key-value 数据库，开源免费，遵守 BSD 协议。</p> 
<p><strong>特点：</strong></p> 
<ul><li>性能极高，能到 100000 次/s 读写速度</li><li>支持数据的持久化，对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上</li><li>丰富的数据类型，String(字符串)、List(列表)、Hash(字典)、Set(集合)、Sorted Set(有序集合)</li><li>原子性：Redis 的所有操作都是原子性的，多个操作通过 MULTI 和 EXEC 指令支持事务</li><li>丰富的特性：key 过期、publish/subscribe、notify</li><li>支持数据的备份，快速的主从复制</li><li>节点集群，很容易将数据分布到多个Redis实例中</li></ul> 
<h3><a id="Redis_1793"></a>Redis支持哪些数据类型？</h3> 
<ul><li>string：字符串 hash：哈希 list：列表 set：集合 sorted set：有序集合</li></ul> 
<h3><a id="redis_1797"></a>redis受到攻击怎么办？</h3> 
<p>1.主从配置</p> 
<p>2.持久化储存redis，不以root账户启动<br> 3,。增加redis密码验证（设置复杂密码）<br> 4.不允许key方式登录<br> 5.以非root权限启动redis<br> 6.禁止公网开放redis端口，<br> 7.检查authorized_keys是否非法</p> 
<h3><a id="Redis__1808"></a>Redis 缓存穿透、击穿、雪崩现象及解决方案</h3> 
<h4><a id="_1810"></a>缓存穿透</h4> 
<p>1、缓存空结果<br> 如果系统发现 Redis 及 DB 中都不存在该资源，就缓存空结果一段时间。需要注意哈，这次的失效时间不能设置的太长，否则数据的实效性会产生很大的问题。</p> 
<p>2、用户合法性校验<br> 对用户的请求合法性进行校验，拦截恶意重复请求。</p> 
<p>3、布隆过滤器<br> 看到这个名词不要慌。简单来说布隆过滤器的用途就是帮助你判断某个值是否存在。举个例子来看下：假设我们现在有一个长度为 9 的 bit 数组，该数组的每个位置上只能保存 1 或者 0，1 标识该位置被占用，0 标识该位置未被使用。</p> 
<p>对于 key1，我们借助三个 Hash 函数分别对其哈希运算。<br> 再将得到的这三个哈希值对 9 求模。<br> 最后将这三个模值落入到 bit 数组上。<br> key2、key3 按照同样的方式再处理一遍。</p> 
<h4><a id="_1826"></a>缓存击穿</h4> 
<p>关键词：定点打击<br> 试想如果所有请求对着一个 key 照死里搞，这是不是就是一种定点打击呢？</p> 
<p>怎么理解呢？举个极端的例子：比如某某明星爆出一个惊天狠料，海量吃瓜群众同时访问微博去查看该八卦新闻，而微博 Redis 集群中数据在此刻正好过期了，那么无数的请求则直接打到了微博系统的物理 DB 上，DB 瞬间挂了。</p> 
<p>解决方案：<br> 1、热点数据永远不过期<br> 比如我们可以将某个 key 的缓存时间设置为 25 小时，然后后台有个 JOB 每隔 24 小时就去批量刷新一下热点数据。就可以解决这个问题了。</p> 
<p>2、使用互斥锁<br> 容易影响吞吐量，大部分项目设置热点 key 永不过期就妥妥的了。</p> 
<h4><a id="_1840"></a>缓存雪崩</h4> 
<p>关键词：Redis 崩了，没有数据了<br> 这里的 Redis 崩了指的并不是 Redis 集群宕机了。而是说在某个时刻 Redis 集群中的热点 key 都失效了。如果集群中的热点 key 在某一时刻同时失效了的话，试想海量的请求都将直接打到 DB 上，DB 可能在瞬间就被打爆了。</p> 
<p>解决方案：</p> 
<p>1、Redis 失效时间加上随机数<br> Redis 失效时间加上随机数，是一种比较取巧的解决方案。在一定程度上减轻了 DB 的瞬时压力，但是这种方案也在一定程度上增加了维护的成本。</p> 
<p>2、Redis 永不过期<br> 实现方案在上文中简单提过了。</p> 
<h4><a id="Redis__1853"></a>Redis 缓存穿透、击穿、雪崩的区别？</h4> 
<ul><li>缓存穿透—穿过（绕过） Redis 和 DB 来搞你</li><li>缓存击穿—定点打击来搞你</li><li>缓存雪崩—热点 key 在某一个时刻同时失效</li></ul> 
<h3><a id="Redis_1859"></a>Redis有哪些优缺点？</h3> 
<p><strong>优点：</strong></p> 
<ul><li>性能极高，能到 100000 次/s 读写速度</li><li>支持数据的持久化，对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上</li><li>丰富的数据类型，String(字符串)、List(列表)、Hash(字典)、Set(集合)、Sorted Set(有序集合)</li><li>原子性：Redis 的所有操作都是原子性的，多个操作通过 MULTI 和 EXEC 指令支持事务</li><li>丰富的特性：key 过期、publish/subscribe、notify</li><li>支持数据的备份，快速的主从复制</li><li>节点集群，很容易将数据分布到多个Redis实例中</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写</li><li>适合的场景主要局限在较小数据量的高性能操作和运算上</li></ul> 
<h3><a id="Redis_1876"></a>Redis的哨兵原理</h3> 
<p>每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave<strong>定时</strong>发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).<br> 若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master"彻底死亡"(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。<br> 虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动哨兵(sentinel)。</p> 
<p>哨兵有三个定时监控任务完成对各节点的发现和监控：</p> 
<p><strong>任务1，<strong>每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时</strong>只要配置对主节点的监控</strong>即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到</p> 
<p>**任务2，**每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的；</p> 
<p>**任务3，**每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据</p> 
<p><strong>主观下线和客观下线：</strong></p> 
<p>**主观下线：**刚知道哨兵节点每隔1秒对主节点和从节点、其它哨兵节点发送ping做心跳检测，当这些心跳检测时间超过down-after-milliseconds时，哨兵节点则认为该节点错误或下线，这叫主观下线；这可能会存在错误的判断。</p> 
<p>**客观下线：**当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，当超过quorum（法定人数）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线</p> 
<p><strong>领导者哨兵选举流程：</strong></p> 
<p>**a,**每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</p> 
<p>**b,**当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</p> 
<p>**c,**如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………</p> 
<h4><a id="_1904"></a>心跳检测</h4> 
<p>在命令传播阶段，<strong>从服务器默认以每秒一次的频率</strong>，向主服务器发送命令：</p> 
<p><strong>REPLCONF ACK &lt;replication_offset&gt;</strong> //replication_offset是从服务器当前的复制偏移量。</p> 
<p>心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。</p> 
<p>检测主从服务器的网络连接状态</p> 
<p>通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。</p> 
<h3><a id="redis_1916"></a>redis主从复制</h3> 
<p>Redis主从复制可以根据是否是全量分为全量同步和增量同步。</p> 
<h4><a id="_1920"></a>全量复制</h4> 
<p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br> 　　1）Slave 连接Master ，发送SYNC命令；<br> 　　2）Master 接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件 , 同时将这之后新的写命令记入缓冲区；<br> 　　3）Master BGSAVE执行完后，向所有Slave 发送快照文件， 并继续记录写命令；<br> 　　4）Slave 收到快照文件后丢弃所有旧数据，载入收到的快照；<br> 　　5）Master 快照发送完毕后开始向Slave 发送缓冲区中的写命令；<br> 　　6）Slave 完成对快照的载入，开始接收命令请求，并执行来自Master 缓冲区的写命令；<br> 　　完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p> 
<h4><a id="_1931"></a>增量复制</h4> 
<p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p> 
<h4><a id="Redis_1935"></a>Redis主从同步策略</h4> 
<p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p> 
<h3><a id="Redis_1939"></a>Redis持久化机制有哪些？各有什么优缺点？</h3> 
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p> 
<p>Redis 提供两种持久化机制： RDB 和 AOF</p> 
<p>RDB(**RDBRedis DataBase：*)</p> 
<p>指用数据集快照的方式半持久化模式，记录 redis 数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，可恢复数据</p> 
<p>优点：</p> 
<ul><li>只有一个文件 dump.rdb，恢复操作简单，容灾性好</li><li>性能较高，fork 子进程进行写操作，主进程继续处理命令</li><li>大数据集比 AOF 的恢复效率高</li></ul> 
<p>缺点：</p> 
<ul><li>数据安全性低，RDB 是每间隔一段时间进行持久化，若期间 redis 发生故障，可能会发生数据丢失</li></ul> 
<p>AOF（<strong>AOFAppend-only file）</strong></p> 
<p>指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储，保存为 aof 文件</p> 
<p>优点：</p> 
<ul><li>数据安全，aof 持久化可以配置 appendfsync 属性为 always，记录每个命令操作到 aof 文件中一次；通过 append 模式写文件，即使中途服务器宕机，也可以通过 redis-check-aof 工具解决数据一致性问题</li><li>AOF 机制的 rewrite 模式，AOF 文件没被 rewrite 之前可以进行处理，如删除文件中的 flushall 命令</li></ul> 
<p>缺点：</p> 
<ul><li>AOF 的持久化文件比 RDB 大，恢复速度慢</li></ul> 
<h3><a id="Redis_1972"></a>Redis使用过程中的注意事项？</h3> 
<ul><li>主库压力很大，可以考虑读写分离</li><li>Master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件。(Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程，文件较大时会间断性暂停服务；AOF 文件过大会影响 Master 重启的恢复速度)</li><li>如果数据比较重要，使用 AOF 方式备份数据，设置合理的备份频率</li><li>保证主从复制的速度和网络连接的稳定性，主从机器最好在同一内网</li><li>官方推荐，使用 sentinel 集群配合多个主从节点集群，解决单点故障问题实现高可用</li></ul> 
<h3><a id="Redis_1980"></a>Redis过期键的删除策略有哪些？</h3> 
<ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器，达到过期时间，执行键的删除操作</li><li>惰性删除：不主动删除过期键，从键空间中获取键时，都检查取得的键是否过期，过期则删除；没过期则返回</li><li>定期删除：每隔一段时间对数据库进行一次检查，删除里面的过期键。删除多少过期键、检查多少个数据库，由算法决定。</li></ul> 
<h3><a id="Redis_1986"></a>为什么Redis所有数据放到内存中？</h3> 
<ul><li>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，所以 Redis 具有高速读写和数据持久化的特征</li><li>如果程序直接与磁盘交互，磁盘 IO 速度会严重影响 Redis 的性能</li><li>内存的硬件成本降低，使得 Redis 更受欢迎</li></ul> 
<h3><a id="Redis_1992"></a>说说Redis的同步机制？</h3> 
<p>Redis 通过同步(sync)和指令传播(command propagate)两个操作完成同步</p> 
<p><strong>同步(sync)：将从节点的数据库状态更新至与主节点的数据库状态一致</strong></p> 
<ul><li>从节点向主节点发送 SYNC 指令</li><li>收到 SYNC 指令，主节点执行 BGSAVE 指令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写指令</li><li>主节点 BGSAVE 指令执行后，会将生成的 RDB 文件发送给从节点</li><li>从节点接收、载入 RDB 文件，将数据库状态更新至主节点执行 BGSAVE 指令时的数据库状态</li><li>从节点加载完 RDB 文件，通知主节点将记录在缓冲区里面的所有写指令发送给从节点，从节点执行这些写指令，将数据库状态更新至主节点当前数据库状态</li></ul> 
<h3><a id="Redis_2004"></a>说说Redis集群？</h3> 
<ul><li>主从同步/复制：解决读写分离的问题。分为主库 master、从库 slave。一般主库可以写数据，从库只读自动同步主库更新的数据。集群情况下，有节点宕机会导致请求不可用；主机宕机可能会导致数据不一致；从机重启同步数据需要考虑主机的 io 压力。生产环境建议使用下面两种方法</li><li>Redis Sentinel，哨兵机制，解决主从节点高可用的问题。监控主从服务器运行状态；检测到 master 宕机时，会发布消息进行选举，自动将 slave 提升为 master</li><li>Redis Cluster，分布式解决方案，解决单点故障与扩展性以及哨兵机制中每台 Redis 服务器都存储相同的数据浪费内存的问题。实现了 Redis 的分布式存储，也就是每台 Redis 节点上存储不同的内容</li></ul> 
<h3><a id="Redis_2010"></a>说说遇到的Redis集群方案不可用的情况？</h3> 
<ul><li>集群主库半数宕机(根据 failover 原理，fail 掉一个主需要一半以上主都投票通过才可以)</li><li>集群某一节点的主从全数宕机</li></ul> 
<h3><a id="Redis_2015"></a>Redis如何设置密码？</h3> 
<p>配置文件，修改 requirepass 属性，重启有效</p> 
<p>指令设置密码为 123456，无需重启</p> 
<pre><code class="prism language-javascript">config <span class="token keyword">set</span> requirepass <span class="token number">123456</span>
</code></pre> 
<p>设置验证密码为 654321，登录完之后没有通过密码认证还是无法访问 Redis</p> 
<pre><code class="prism language-javascript">auth <span class="token number">654321</span>
</code></pre> 
<h3><a id="Redis__2031"></a>Redis 集群会有写操作丢失吗？</h3> 
<p>以下情况可能导致写操作丢失：</p> 
<ul><li>过期 key 被清理</li><li>最大内存不足，导致 Redis 自动清理部分 key 以节省空间</li><li>主库故障后自动重启，从库自动同步</li><li>单独的主备方案，网络不稳定触发哨兵的自动切换主从节点，切换期间会有数据丢失</li></ul> 
<h3><a id="Redis_2040"></a>Redis如何做内存优化？</h3> 
<ul><li>缩减键值对象：满足业务要求下 key 越短越好；value 值进行适当压缩</li><li>共享对象池：即 Redis 内部维护[0-9999]的整数对象池，开发中在满足需求的前提下，尽量使用整数对象以节省内存</li><li>尽可能使用散列表(hashes)</li><li>编码优化，控制编码类型</li><li>控制 key 的数量</li></ul> 
<h3><a id="Redis_2048"></a>Redis集群之间是如何复制？</h3> 
<p>2.8 版以前，Redis 通过同步(sync)和指令传播(command propagate)两个操作完成同步</p> 
<ul><li>同步(sync)：将从节点的数据库状态更新至与主节点的数据库状态一致</li><li>指令传播(command propagate)：主节点数据被修改，会主动向从节点发送执行的写指令，从节点执行之后，两个节点数据状态又保持一致</li></ul> 
<p>2.8 版开始新增 PSYNC 指令，PSYNC 具有两种模式：</p> 
<ul><li>完整重同步(full resynchronization)，与 SYNC 过程基本一致</li><li>部分重同步(partial resynchronization)，借助复制偏移量、复制积压缓冲区、服务器运行 ID ，完成主从节点断开连接后，从节点重连主节点后，条件允许，主节点将连接断开期间执行的写指令发送给从节点，从节点接收并执行写指令，将数据库更新至主节点当前状态</li></ul> 
<h3><a id="Redis_2060"></a>Redis如何选择数据库？</h3> 
<pre><code class="prism language-javascript"><span class="token constant">SELECT</span> index
</code></pre> 
<p>切换到指定的数据库，数据库索引号 index 用数字值指定，0 作为起始索引值</p> 
<p>连接建立后，如果不 select，默认对 db 0 操作</p> 
<h3><a id="Redis_2070"></a>说一说你对Redis的事务的理解？</h3> 
<p><strong>Redis事务的特性：</strong></p> 
<ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别，事务提交前结果不可见，事务提交执行后可见</li><li>不保证原子性，Redis 同一个事务中有命令执行失败，其后的命令仍然会被执行，不会回滚</li></ul> 
<p><strong>事务三阶段：</strong></p> 
<ul><li>开启：MULTI 指令开启一个事务</li><li>入队：将多个命令入队到事务中，这些命令不会立即执行，而是放到等待执行的事务队列</li><li>执行：由 EXEC 指令触发事务执行</li></ul> 
<p><strong>相关指令：</strong></p> 
<ul><li>multi，标记一个事务块的开始，返回 ok</li><li>exec，执行所有事务块内，事务块内所有命令执行的先后顺序的返回值，操作被，返回空值 nil</li><li>discard，取消事务，放弃执行事务块内的所有命令，返回 ok</li><li>watch，监视 key 在事务执行之前是否被其他指令改动，若已修改则事务内的指令取消执行，返回 ok</li><li>unwatch，取消 watch 命令对 key 的监视，返回 ok</li></ul> 
<h3><a id="Redis_2092"></a>Redis如何设置过期时间？</h3> 
<pre><code class="prism language-javascript">redis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> expiration<span class="token punctuation">)</span>
</code></pre> 
<p>setex name2 10 wangwu 设置一个键值对，时间为10秒，过期后自动删除</p> 
<h3><a id="MySQL2000wredis20wredis_2100"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h3> 
<p>这个问题主要考察了以下几点内容：</p> 
<p>1.Redis的内存淘汰策略。<br> 2.Redis的最大内存设置。</p> 
<p>思路：首先计算出20w数据所需的内存空间，设置最大内存，然后选择合适的内存淘汰策略。</p> 
<h4><a id="_2109"></a>内存淘汰策略</h4> 
<p>（1）volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。<br> （2）volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。<br> （3）volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。<br> （4）volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。<br> （5）allkeys-lru：从数据集中挑选最近最少使用的数据淘汰<br> （6）allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。<br> （7）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br> （8） no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</p> 
<h3><a id="Redis_2120"></a>Redis事务支持隔离性吗</h3> 
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p> 
<h3><a id="Redis_2124"></a>Redis事务保证原子性吗，支持回滚吗</h3> 
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p> 
<h2><a id="nginx_2128"></a>nginx==========================================</h2> 
<h3><a id="Nginx_2130"></a>什么是Nginx？</h3> 
<p>Nginx是一个 轻量级/高性能的反向代理Web服务器，他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如：新浪、网易、 腾讯等。</p> 
<h3><a id="Nginx_2134"></a>为什么要用Nginx？</h3> 
<p>跨平台、配置简单、方向代理、高并发连接：处理2-3万并发连接数，官方监测能支持5万并发，内存消耗小：开启10个nginx才占150M内存 ，nginx处理静态文件好，耗费内存少，</p> 
<p>而且Nginx内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。</p> 
<p>使用Nginx的话还能：</p> 
<p>节省宽带：支持GZIP压缩，可以添加浏览器本地缓存<br> 稳定性高：宕机的概率非常小<br> 接收用户请求是异步的<br> 为什么Nginx性能这么高？<br> 因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决</p> 
<h3><a id="Nginx_2148"></a>Nginx怎么处理请求的？</h3> 
<p>nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址<br> server { # 第一个Server区块开始，表示一个独立的虚拟主机站点<br> listen 80； # 提供服务的端口，默认80<br> server_name localhost； # 提供服务的域名主机名<br> location / { # 第一个location区块开始<br> root html； # 站点的根目录，相当于Nginx的安装目录<br> index index.html index.htm； # 默认的首页文件，多个用空格分开<br> } # 第一个location区块结果</p> 
<h3><a id="_2160"></a>什么是正向代理和反向代理？</h3> 
<p>正向代理就是一个人发送一个请求直接就到达了目标的服务器<br> 反方代理就是请求统一被Nginx接收，nginx反向代理服务器接收到之后，按照一定的规 则分发给了后端的业务处理服务器进行处理了<br> 使用“反向代理服务器的优点是什么?<br> 反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。</p> 
<h3><a id="Nginx_2167"></a>Nginx的优缺点？</h3> 
<p>优点：</p> 
<p>占内存小，可实现高并发连接，处理响应快<br> 可实现http服务器、虚拟主机、方向代理、负载均衡<br> Nginx配置简单<br> 可以不暴露正式的服务器IP地址<br> 缺点：<br> 动态处理差：nginx处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用nginx作为反向代理抗住压力，</p> 
<h3><a id="Nginx_2178"></a>Nginx应用场景？</h3> 
<p>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br> 虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。<br> 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。<br> nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。</p> 
<h3><a id="Nginx_2185"></a>如何用Nginx解决前端跨域问题？</h3> 
<p>使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。<br> Nginx虚拟主机怎么配置?<br> 1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</p> 
<p>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</p> 
<p>3、基于ip的虚拟主机。</p> 
<h3><a id="_2195"></a>限流怎么做的？</h3> 
<ul><li> <p>Nginx限流就是限制用户请求速度，防止服务器受不了</p> </li><li> <p>限流有3种</p> 
  <ol><li> <p>正常限制访问频率（正常流量）</p> <p>限制一个用户发送的请求，我Nginx多久接收一个请求。</p> <p>Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</p> </li><li> <p>突发限制访问频率（突发流量）</p> <p>限制一个用户发送的请求，我Nginx多久接收一个。</p> <p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。</p> </li><li> <p>限制并发连接数</p> <p>Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。</p> </li></ol> </li><li> <p>Nginx的限流都是基于漏桶流算法</p> </li></ul> 
<h3><a id="_2219"></a>漏桶算法</h3> 
<p>漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。也就是我们刚才所讲的情况。漏桶算法提供的机制实际上就是刚才的案例：突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。</p> 
<h4><a id="Nginx_2223"></a>Nginx负载均衡的算法怎么实现的?策略有哪些?</h4> 
<p>为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</p> 
<p>Nginx负载均衡实现的策略有以下五种：</p> 
<p>1 轮询(默认)<br> 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p> 
<pre><code>upstream backserver {  
	server 192.168.0.12; 
	server 192.168.0.13;  
} 
</code></pre> 
<p>2 权重 weight<br> weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</p> 
<pre><code>upstream backserver { 
 server 192.168.0.12 weight=2; 
 server 192.168.0.13 weight=8; 
} 
</code></pre> 
<p>权重越高，在被访问的概率越大，如上例，分别是20%，80%。</p> 
<p>3 ip_hash( IP绑定)<br> 每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题<br> upstream backserver {<!-- --><br> ip_hash;<br> server 192.168.0.12:88;<br> server 192.168.0.13:80;<br> 4 fair(第三方插件)<br> 必须安装upstream_fair模块。</p> 
<p>对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p> 
<pre><code>upstream backserver { 
 server server1; 
 server server2; 
 fair; 
</code></pre> 
<p>哪个服务器的响应速度快，就将请求分配到那个服务器上。<br> 5、url_hash(第三方插件)<br> 必须安装Nginx的hash软件包</p> 
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p> 
<p>upstream backserver {<!-- --><br> server squid1:3128;<br> server squid2:3128;<br> hash $request_uri;<br> hash_method crc32;<br> }</p> 
<h2><a id="Linux_2296"></a>Linux=========================================</h2> 
<h3><a id="linux_2298"></a>linux如何添加新系统用户?</h3> 
<ul><li>以 root 身份登录 linux 系统，进入终端</li><li>增加一个新用户，useradd 用户名</li><li>设置密码，passwd 用户名</li></ul> 
<h3><a id="bash_2304"></a>什么是bash别名？</h3> 
<p>相当于自定义 shell 指令<br> 如：ll 指令可以查看文件的详细信息，ll 就是一个被定义好的别名，能够大大的简化指令</p> 
<pre><code class="prism language-javascript"><span class="token number">1.</span>通过 alias 命令可以查看命令别名
<span class="token punctuation">[</span>root<span class="token punctuation">]</span># alias
alias cp<span class="token operator">=</span><span class="token string">'cp -i'</span>
alias egrep<span class="token operator">=</span><span class="token string">'egrep --color=auto'</span>
alias fgrep<span class="token operator">=</span><span class="token string">'fgrep --color=auto'</span>
alias grep<span class="token operator">=</span><span class="token string">'grep --color=auto'</span>
<span class="token number">2.</span>定义新的别
<span class="token punctuation">[</span>root<span class="token punctuation">]</span>#alias rmall <span class="token operator">=</span> <span class="token string">'rm -rf'</span>
<span class="token number">3.</span>取消别名
<span class="token punctuation">[</span>root<span class="token punctuation">]</span># unalias rmall
</code></pre> 
<h3><a id="linuxls_2322"></a>linux指令-ls</h3> 
<p>list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。</p> 
<h3><a id="_rmdir_2326"></a>删除目录 rmdir</h3> 
<h3><a id="_linux__chmod_2328"></a>改变 linux 系统文件或目录的访问权限 chmod</h3> 
<p>该命令有两种用法：一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法<br> 每一文件或目录的访问权限都有三组，每组用三位代号表示：</p> 
<ul><li>文件属主的读、写和执行权限</li><li>与属主同组的用户的读、写和执行权限</li><li>系统中其他用户的读、写和执行权限</li></ul> 
<pre><code class="prism language-javascript">常用参数：
<span class="token operator">-</span>c 当发生改变时，报告处理信息
<span class="token operator">-</span><span class="token constant">R</span> 处理指定目录以及其子目录下所有文件
权限范围：
u：目录或者文件的当前的用户
g：目录或者文件的当前的群组
o：除了目录或者文件的当前用户或群组之外的用户或者群组
a：所有的用户及群组
权限代号：
r：读权限，用数字<span class="token number">4</span>表示
w：写权限，用数字<span class="token number">2</span>表示
x：执行权限，用数字<span class="token number">1</span>表示
<span class="token operator">-</span>：删除权限，用数字<span class="token number">0</span>表示
s：特殊权限
</code></pre> 
<h3><a id="_2354"></a>查看文件内容有哪些命令可以使用？</h3> 
<p>vi 文件名 #编辑方式查看，可修改<br> cat 文件名 #显示全部文件内容<br> more 文件名 #分页显示文件内容<br> less 文件名 #与 more 相似，更好的是可以往前翻页<br> tail 文件名 #仅查看尾部，还可以指定行数<br> head 文件名 #仅查看头部,还可以指定行数</p> 
<h3><a id="_2363"></a>复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？</h3> 
<p>cp cp -r ？？？？</p> 
<h3><a id="_2367"></a>删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</h3> 
<p>rm rm -r rmdir</p> 
<h3><a id="Linux__2371"></a>Linux 下命令有哪几种可使用的通配符？分别代表什么含义?</h3> 
<p>“？”可替代单个字符。</p> 
<p>“*”可替代任意多个字符。</p> 
<p>方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]</p> 
<h3><a id="_2379"></a>用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)</h3> 
<p>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。</p> 
<h3><a id="__2383"></a>搜索文件用什么命令? 格式是怎么样的?</h3> 
<p>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</p> 
<p>whereis 加参数与文件名</p> 
<p>locate 只加文件名</p> 
<p>find 直接搜索磁盘，较慢。</p> 
<p>find / -name “string*”</p> 
<h3><a id="_2395"></a>使用什么命令查看用过的命令列表?</h3> 
<p>history</p> 
<h2><a id="docker_2399"></a>docker========================================</h2> 
<h3><a id="dockerdocker_2401"></a>什么是docker？什么是docker镜像？</h3> 
<p>docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。<br> 是docker容器的源代码，用于创建容器。使用build命令创建镜像。</p> 
<h3><a id="dockerdockerdocker_2406"></a>什么是docker容器？docker容器有几种状态？docker容器内部机制？容器与主机之间的数据拷贝？启动容器并挂在目录？</h3> 
<p>（1）docker容器：docker容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。<br> （2）docker容器4种状态：运行+已暂停+重新启动+已退出<br> （3）docker容器内部机制：每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。<br> 【操作系统的一个功能是允许将全局资源（如网络和磁盘）共享到进程。如果将这些全局资源包装在命名空间中，以使它们仅对在同一命名空间中运行的那些进程可见】<br> （4）主机copy到容器：docker cp /www 96f7f14e99ab:/www/ 容器copy到主机：docker cp 96f7f14e99ab:/www /tmp/<br> （5）启动nginx容器(随机端口映射)，并挂载本地文件目录到容器html的命令：<br> docker run -d -P --name nginx2 -v /home/nginx:/usr/share/nginx/html nginx<br> docker run</p> 
<h3><a id="Docker_2417"></a>Docker容器有几种状态</h3> 
<p>四种状态：运行、已暂停、重新启动、已退出。</p> 
<h3><a id="docker_2421"></a>docker常用命令</h3> 
<p>docker pull 拉取或者更新指定镜像<br> docker push 将镜像推送至远程仓库<br> docker rm 删除容器<br> docker rmi 删除镜像<br> docker images 列出所有镜像<br> docker ps 列出所有容器</p> 
<h2><a id="JVM_2430"></a>JVM===========================================</h2> 
<h3><a id="JVM_2432"></a>JVM内存结构</h3> 
<p>JVM内存结构主要有三大块：<strong>堆内存、方法区和栈</strong>。</p> 
<p>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间、From Survivor空间、To Survivor空间</strong>,默认情况下年轻代按照8:1:1的比例来分配；<strong>方法区存储类信息、常量、静态变量等数据，是线程共享的区域</strong>，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p> 
<p><strong>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</strong></p> 
<h3><a id="_2440"></a>内存划分</h3> 
<p>Java虚拟机按照运行时内存使用区域划分如图：</p> 
<p><img src="https://images2.imgbox.com/ab/1f/WGNw8wms_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/01/08/RFReWdnu_o.png" alt="img"></p> 
<h4><a id="Program_Counter_Register_2454"></a>一、程序计数器(Program Counter Register)</h4> 
<p>程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。</p> 
<p>Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是<strong>线程私有</strong>的。</p> 
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p> 
<h4><a id="JavaVM_Stack_2462"></a>二、Java虚拟机栈(VM Stack)</h4> 
<p>Java虚拟机栈是<strong>线程私有</strong>，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。</p> 
<p>虚拟机执行java程序的时候，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。</p> 
<p>栈帧又分为一下几个区域：<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等。</p> 
<p>平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在java虚拟机栈的局部变量表中。</p> 
<p>Java的8中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。</p> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>当用户请求web服务器，每个请求开启一个线程负责用户的响应计算（每个线程分配一个虚拟机栈空间），如果并发量大时，可能会导致内存溢出（OutOfMemoneyError），可以适当的把每个虚拟机栈的大小适当调小一点，减少内存的使用量来提高系统的并发量。</p> 
 <p>当栈空间调小以后，又会引发方法调用深度的的问题。因为，每个方法都会生成一个栈帧，如果方法调用深度很深就意味着，栈里面存放大量的栈帧，可能导致栈内存溢出（StackOverFlowError）。</p> 
</blockquote> 
<h4><a id="Native_Method_Stack_2482"></a>三、本地方法栈(Native Method Stack)</h4> 
<p>本地方法栈 为虚拟机使用到本地方法服务（native）。本地方法栈为线程私有，功能和虚拟机栈非常类似。线程在调用本地方法时，来存储本地方法的局部变量表，本地方法的操作数栈等等信息。</p> 
<blockquote> 
 <p>本地方法：是非java语言实现的方法，例如，java调用C语言，来操作某些硬件信息。</p> 
</blockquote> 
<h4><a id="Heap_2488"></a>四、堆(Heap)：</h4> 
<p>堆是被所有<strong>线程共享</strong>的区域，实在虚拟机启动时创建的。堆里面存放的都是<strong>对象的实例</strong>（new 出来的对象都存在堆中）。</p> 
<p>我们平常所说的垃圾回收，主要回收的就是堆区。为了提升垃圾回收的性能，又把堆分成两块区<strong>新生代（young）<strong>和</strong>年老代（old）</strong>，更细一点划分新生代又可划分为Eden区和2个Survivor区（From Survivor和To Survivor）。</p> 
<p>如下图结构：</p> 
<p><img src="https://images2.imgbox.com/97/50/0VhY8tdu_o.png" alt="img"></p> 
<blockquote> 
 <p>**Eden：**新创建的对象存放在Eden区</p> 
 <p>**From Survivor和To Survivor：**保存新生代gc后还存活的对象。（使用复制算法，导致有一个Survivor空间浪费）Hotspot虚拟机新生代Eden和Survivor的大小比值为4：1，因为有两个Survivor，所以Eden:From Survivor:To Survivor比值为8：1：1。</p> 
 <p>**老年代：**对象存活时间比较长（经过多次新生代的垃圾收集，默认是15次）的对象则进入老年的。当堆中分配的对象实例过多，且大部分对象都在使用，就会报内存溢出异常（OutOfMemoneyError）。</p> 
</blockquote> 
<h4><a id="_2506"></a>五、方法区</h4> 
<p>方法区是被所有<strong>线程共享</strong>区域，用于存放<strong>已被虚拟机加载</strong>的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）</p> 
<p>永久代也会垃圾回收，主要针对常量池回收，类型卸载（比如反射生成大量的临时使用的Class等信息）。</p> 
<p>常量池用于存放<strong>编译期</strong>生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；<strong>运行期间</strong>的常量也可以添加进入常量池中，比如string的intern()方法。</p> 
<p>当方法区满时，无法在分配空间，就会抛出内存溢出的异常（OutOfMemoneyError）。</p> 
<p>Java8中已经没有方法区了，取而代之的是元空间（Metaspace）。</p> 
<h4><a id="_2518"></a>六：直接内存</h4> 
<p><strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域</strong>，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p> 
<p>JDK1.4加的NIO中，ByteBuffer有个方法是allocateDirect(int capacity) ，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p> 
<h3><a id="GC_2524"></a>GC垃圾回收</h3> 
<p>：主要就是为了提高内存利用率，只回收“托管堆中的内存资源”，没有引用的对象。不回收“栈”上的资源（比如值类型）。</p> 
<p>一个跟踪过程，它传递性地跟踪指向当前使用的对象的所有指针，以便找到可以引用的所有对象，然后重新使用在此跟踪过程中未找到的任何堆内存。公共语言运行库垃圾回收器还压缩使用中的内存，以缩小堆所需要的工作空间。<br> Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。<br> Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：<br> System.gc()<br> Runtime.getRuntime().gc()</p> 
<p><strong>GC垃圾回收机制（</strong></p> 
<p>引入“代”的概念，</p> 
<p>①总共有三代，0~2代。</p> 
<p>②每次新建对象都在第0代中。</p> 
<p>③每代有固定大小。</p> 
<p>这个叫“自动回收”，肯定有小朋友会问，那是不是可以手动回收。答案是肯定的，比如析构函数就可以达到这个目的。</p> 
<p>将引用可分为强引用、软引用、弱引用、虚引用。</p> 
<p>强引用：如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError，使程序异常终止；<br> 软引用：如果内存空间够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用，软引用可用来实现内存敏感的高速缓存。<br> 弱引用：比软引用更弱一些，弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<br> 虚引用：在任何时候都可能被垃圾回收器回收，主要用于跟踪对象被垃圾回收器回收的活动</p> 
<p><strong>弱引用</strong></p> 
<p>人就是这样，得不到的永远在骚动，得到的有恃无恐。当失去了，才追悔莫及。假如对象要被回收了，但是我又想再次用这个对象，该怎么办？这个时候就出来了这个–“弱引用”。</p> 
<p>为什么需要弱对象呢？因为，有一些数据创建起来很容易，但是却需要很多内存。</p> 
<p>例如：有一个程序需要去访问用户硬盘上的所有文件夹和文件名；你可以在程序第一次需要这个数据时访问用户磁盘生成一次数据，数据生成之后你就可以访问内存中的数据来得到用户文件数据，而不是每次都去读磁盘获得数据，这样做可以提升程序的性能。</p> 
<p>你可以这么理解，你跟你女朋友闹分手，微信电话什么的全部删除了，但是还留着QQ，以后想要联系，可以通过这个QQ来联系，而此时的这个QQ，就相当于是弱引用了。至于为什么分手了还要联系，这个原因也就是为什么要有弱引用的原因了~</p> 
<p>软引用、弱引用都在引用对象被垃圾回收之后，JVM才把引用加入到与之关联的引用队列中；而虚引用对象在垃圾回收之前，JVM把引用加入到阈值关联的引用队列中。虚引用必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，若发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。这样就可以通过判断引用队列中是否已经加入了虚引用来了解被引用对象是否将要被垃圾回收器回收</p> 
<h3><a id="GC__2565"></a>GC 优化</h3> 
<ul><li>将进入老年代的对象数量降到最低</li><li>减少Full GC的执行时间</li><li>优化JVM参数——堆和栈的大小，设置垃圾收集器的模式</li></ul> 
<h3><a id="_2571"></a>新生代和老年代的区别(<strong>阿里面试官的题目</strong>)：</h3> 
<p>所谓的新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区 当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了 Mark-Compact算法清理</p> 
<h4><a id="_2575"></a>新生代</h4> 
<p>新生代存放一些新生的对象实例。</p> 
<p>新生代内又划分了3个区域，分别是：</p> 
<p>Eden<br> SurvivorFrom<br> SurvivorTo<br> 一般情况占据的位置是8:1:1<br> 当新生代的Eden区区域不够的时候，就会发生minor GC。</p> 
<p>每当进行一次minor GC时，区域间进行数据交换，Eden区和SurvivorFrom区域会把存活的对象放进SurvivorTo区域。</p> 
<p>在新生代之中一般采用复制算法进行GC。</p> 
<h4><a id="_2591"></a>老年代</h4> 
<p>老年代存放比较稳定存活的对象。<br> 对于老年代有Major GC的垃圾回收机制。</p> 
<p>有两个触发条件：</p> 
<p>一个是当新生代发生minor GC之后，仍然不够位置存放新生对象时，借用老年代空间不足时，会发生major GC<br> 另一个是当申请一个大的连续空间（如大数组）给较大对象时，也会触发Major GC进行垃圾回收。</p> 
<h4><a id="_2601"></a>永久代</h4> 
<p>永久代在方法区内，存放Class和Meta的信息。</p> 
<p>在GC里面回收永久代的信息有两个</p> 
<p>一是废弃变量<br> 一个是无用的类<br> 废弃变量比较好处理，只要常量池中没有String对象引用，也没有其他对象引用，就会回收。</p> 
<p>无用的类的话就有比较多的判断标准。</p> 
<p>一是Java堆中没有这个类的实例对象<br> 二是这个类的类加载器以及被回收<br> 三是该类对应的Class对象没有被其他方法引用，不能通过反射访问该类的方法</p> 
<h4><a id="_2617"></a>元数据</h4> 
<p>在Java8中完全移除了永久代这个概念，新创建了元数据这个概念。</p> 
<p>原本永久代存放的Meta的数据不再存在于方法区内，而是依赖于Native Memory（本地内存）里，而String常量池和类的静态变量转移到Java堆里，因此Java堆内存有所变动。</p> 
<p>默认情况下，元数据只受本地内存限制（操作系统的虚拟内存），可以定义新参数MaxMetaspaceSize来限制元数据的大小，如果不限制元空间就会根据需要动态调整。<img src="https://images2.imgbox.com/1a/12/lKr4T0cc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="JDKJREJVM_2625"></a>JDK,JRE,JVM区别</h3> 
<p>Jdk中包括了Jre，Jre中包括了JVM</p> 
<p>jdk<br> Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。</p> 
<p>jre<br> Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。</p> 
<p>jvm<br> Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p> 
<h3><a id="_2638"></a><strong>说一下堆栈的区别？</strong></h3> 
<p>\1. 栈内存存储的是局部变量而堆内存存储的是实体；</p> 
<p>\2. 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p> 
<p>\3. 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p> 
<h3><a id="_2646"></a><strong>队列和栈是什么？有什么区别？</strong></h3> 
<ul><li>队列和栈都是被用来预存储数据的。</li><li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li><li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li></ul> 
<h3><a id="_2652"></a><strong>说一下类加载的执行过程？</strong></h3> 
<p>类加载分为以下 5 个步骤：</p> 
<ol><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作</li></ol> 
<h3><a id="_2662"></a>什么是乐观锁和悲观锁？</h3> 
<h4><a id="_2664"></a>悲观锁</h4> 
<p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p> 
<h4><a id="_2668"></a>乐观锁</h4> 
<p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p> 
<h2><a id="Zookeeper_2672"></a>Zookeeper=====================================</h2> 
<h3><a id="zookeeper__2674"></a><strong>zookeeper 是什么？</strong></h3> 
<p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p> 
<h3><a id="zookeeper__2678"></a><strong>zookeeper 都有哪些功能？</strong></h3> 
<ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。配置中心</li></ul> 
<h3><a id="zookeeper__2685"></a><strong>zookeeper 有几种部署模式？</strong></h3> 
<p>zookeeper 有三种部署模式：</p> 
<ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul> 
<h3><a id="zookeeper__2693"></a><strong>zookeeper 怎么保证主从节点的状态同步？</strong></h3> 
<p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p> 
<h3><a id="_2697"></a><strong>集群中为什么要有主节点？</strong></h3> 
<p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p> 
<h3><a id="_3__zookeeper__2701"></a><strong>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong></h3> 
<p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p> 
<h3><a id="_zookeeper__2705"></a>说一下 zookeeper 的通知机制？</h3> 
<p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p> 
<h2><a id="_2709"></a>集合===========================================</h2> 
<p>集合有两个父接口，一个collection，一个Map；<br> 而collection有两个子接口，一个List，一个Set；<br> List有两个常见的实现类 ArrayList，LinkedList；<br> Set有两个常见的实现类 HashSet，TreeSet；<br> Map有两个常见的实现类 HashMap，HashTable。</p> 
<h3><a id="ArrayListVector_2717"></a>ArrayList和Vector的联系和区别</h3> 
<p><strong>相同点：</strong></p> 
<ul><li>底层都使用数组实现</li><li>功能相同，实现增删改查等操作的方法相似</li><li>长度可变的数组结构</li></ul> 
<p><strong>不同点：</strong></p> 
<ul><li>Vector是早期JDK版本提供，ArrayList是新版本替代Vector的</li><li>Vector 的方法都是同步的，线程安全；ArrayList 非线程安全，但性能比Vector好</li><li>默认初始化容量都是10，Vector 扩容默认会翻倍，可指定扩容的大小；ArrayList只增加 50%</li></ul> 
<h3><a id="CollectionCollections_2731"></a>Collection和Collections有什么区别？</h3> 
<p>Collection 是JDK中集合层次结构中的最根本的接口。定义了集合类的基本方法。</p> 
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法,不能实例化，Collection 集合框架的工具类。</p> 
<h3><a id="ListSetMap__2737"></a>List、Set、Map 之间的区别是什么？</h3> 
<ul><li>List：有序集合，元素可重复</li><li>Set：不重复集合，LinkedHashSet按照插入排序，SortedSet可排序，HashSet无序</li><li>Map：键值对集合，存储键、值和之间的映射；Key无序，唯一；value 不要求有序，允许重复</li></ul> 
<h3><a id="HashMapHashtable__2743"></a>HashMap和Hashtable 有什么区别？</h3> 
<ul><li>线程安全性不同。HashMap 线程不安全；Hashtable 中的方法是 synchronized 的。</li><li>key、value 是否允许 null。HashMap 的 key 和 value 都是可以是 null，key 只允许一个 null；Hashtable 的 key 和 value 都不可为 null。</li><li>迭代器不同。HashMap 的 Iterator 是 fail-fast 迭代器；Hashtable 还使用了 enumerator 迭代器。</li><li>hash的计算方式不同。HashMap 计算了 hash值；Hashtable 使用了 key 的 hashCode方法。</li><li>默认初始大小和扩容方式不同。HashMap 默认初始大小 16，容量必须是 2 的整数次幂，扩容时将容量变为原来的2倍；Hashtable 默认初始大小 11，扩容时将容量变为原来的 2 倍加 1。</li><li>是否有 contains 方法。HashMap 没有 contains 方法；Hashtable 包含 contains 方法，类似于 containsValue。</li><li>父类不同。HashMap 继承自 AbstractMap；Hashtable 继承自 Dictionary。</li></ul> 
<h3><a id="HashMapTreeMap_2753"></a>如何决定使用HashMap还是TreeMap？</h3> 
<ul><li>HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。</li><li>HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。</li><li>HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。都是非线程安全。</li></ul> 
<h3><a id="HashMap_2759"></a>HashMap原理</h3> 
<p>1，无序的。</p> 
<p>2，可以接受null键值和值</p> 
<p>3，非同步的，线程不安全的</p> 
<p>1，hashmap是我们几乎每天用到的集合类,它以键值对的形式存在。<br> 2,在jdk1.7中：底层是数组加链表，1.8中采用的是数组加链表加红黑树，红黑树的引入是为了提高查询效率<br> 3，1.7中hash碰撞采用头插法，头插法会形成循环链表（？），1.8尾插法<br> 4，hash算法1.8进行了简化<br> 5，最好传入一个二的次幂的初始化容量， put时，会初始化数组，容量为大于等于初始化容量的最近的二次幂，比如初始化容量为6，他初始化就是8。<br> 6，key的hash值 与 上容量-1，计算出所在位置<br> 7，扩容的问题：加载因子0.75，达到 容量 *0.75后就会扩容，两倍扩容<br> 8，树化，数组容量达到64,链表长度大于等于8，后才会进行树化，链表长度小于6就会解除树化</p> 
<p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p> 
<p>​ 以键值对（key-value）的形式存储元素</p> 
<p>通过 hashcode() 和 equals() 方法定位键值对存储的准确位置</p> 
<ol><li>首先通过 hashcode() 获得key映射的散列值（也叫 hash 值），通过 hash 值确定键值对存储在哪个链表。不过，不同的 key 生成的 hash 值可能是一样的。</li><li>如果 hash 值定位到的存储空间存在其它的键值对，那就通过 equals() 比较 key ，如果一样，就更新它的 value，如果不一样，就添加在链表后面</li><li>通俗的说，hashcode() 就相当于字典目录，确定好某个字所在的页数，equals()相当于页数上存放的位置</li></ol> 
<p>在场景应用上，hashcode() 和 equals() 是重点修改的部分</p> 
<h3><a id="_HashMap_2790"></a>手动实现 HashMap</h3> 
<pre><code class="prism language-csharp"><span class="token comment">// 键值对存储</span>
<span class="token class-name">package</span> HashMap<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> key<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    @Override
    <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"[key="</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", value="</span> <span class="token operator">+</span> <span class="token keyword">value</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-tsx">// put，get接口
package HashMap;

public interface IHashMap {
    public void put(Object key, Object object);
    public Object get(Object key);
}
</code></pre> 
<pre><code class="prism language-cpp">package HashMap<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token module">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyHashMap</span> implements IHashMap <span class="token punctuation">{<!-- --></span>

    LinkedList<span class="token operator">&lt;</span>Entry<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token keyword">new</span> LinkedList<span class="token punctuation">[</span><span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    @Override
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获得 hash 值</span>
        <span class="token keyword">int</span> hashcode <span class="token operator">=</span> <span class="token function">hashcode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据 hash 值确定存储在哪个链表位置</span>
        LinkedList<span class="token operator">&lt;</span>Entry<span class="token operator">&gt;</span> list <span class="token operator">=</span> values<span class="token punctuation">[</span>hashcode<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            values<span class="token punctuation">[</span>hashcode<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        boolean found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry entry <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 通过比较确定存储的链表位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                entry<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>found<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Entry entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    @Override
    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获得 hash 值</span>
        <span class="token keyword">int</span> hashcode <span class="token operator">=</span> <span class="token function">hashcode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据 hash 值确定存储在哪个链表位置</span>
        LinkedList<span class="token operator">&lt;</span>Entry<span class="token operator">&gt;</span> list <span class="token operator">=</span> values<span class="token punctuation">[</span>hashcode<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> list<span class="token punctuation">)</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>
         <span class="token comment">// 通过比较确定存储的链表位置，并取出相应的 value</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry entry <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                result <span class="token operator">=</span> entry<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 自定义 hash 值，使其落在 0~1999 之间</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hashcode</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        String str <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> hashcode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            hashcode <span class="token operator">+=</span> cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        hashcode <span class="token operator">*=</span> <span class="token number">23</span><span class="token punctuation">;</span>
        <span class="token comment">// 取绝对值</span>
        Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>hashcode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 取值落在 0 - 1999 之间</span>
        hashcode <span class="token operator">%=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashcode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        MyHashMap map <span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">MyHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"坦克"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"物理"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token string">"坦克2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        

   <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/db/3d/ecpoOmIo_o.png" alt="img"></p> 
<p>运行结果</p> 
<p>场景应用</p> 
<ol><li>有一个 people 类，HashMap 的 key 想通过 name 和 age 判断 people 是否相等，而不是通过 people 对象的存储地址</li></ol> 
<p><strong>实现方法</strong>：根据 HashMap 原理，需同时重写 equals() 和 hashCode()。很容易犯的错误是，只重写 equals()，而忘记重写 hashCode()</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token class-name">HashMap</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">37</span> <span class="token operator">+</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">People</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">People</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/87/6b/cUnkrlKZ_o.png" alt="img"></p> 
<p>运行结果</p> 
<ul><li>ArrayList 基于动态数组实现的非线程安全的集合；LinkedList 基于双向链表实现的非线程安全的集合。</li><li>扩容问题：ArrayList 使用数组实现，无参构造函数默认初始化长度为 10，数组扩容是会将原数组中的元素重新拷贝到新数组中，长度为原来的 1.5 倍(扩容代价高)；LinkedList 不存在扩容问题，新增元素放到集合尾部，修改相应的指针节点即可。</li><li>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用节点，一个指向前一个元素，一个指向下一个元素。</li><li>对于随机 index 访问的 get 和 set 方法，一般 ArrayList 的速度要优于 LinkedList。因为 ArrayList 直接通过数组下标直接找到元素；LinkedList 要移动指针遍历每个元素直到找到为止。</li><li>新增和删除元素，一般 LinkedList 的速度要优于 ArrayList。因为 ArrayList 在新增和删除元素时，可能扩容和复制数组；LinkedList 实例化对象需要时间外，只需要修改节点指针即可。</li><li>LinkedList 集合不支持高效的随机访问（RandomAccess）</li><li>ArrayList 的空间浪费主要体现在在list列表的结尾预留一定的容量空间；LinkedList 的空间花费则体现在它的每一个元素都需要消耗存储指针节点对象的空间。</li></ul> 
<p>都是非线程安全，允许存放 null</p> 
<h3><a id="ArrayArrayList_2977"></a>Array和ArrayList有何区别？</h3> 
<p>Array 即数组 定义一个 Array 时，必须指定数组的数据类型及数组长度，即数组中存放的元素个数固定并且类型相同。</p> 
<p>ArrayList 是动态数组，长度动态可变，会自动扩容。不使用泛型的时候，可以添加不同类型元素。</p> 
<h3><a id="List_2983"></a>如何实现数组和List之间的转换？</h3> 
<p>数组转 List ，使用 JDK 中 java.util.Arrays 工具类的 asList 方法</p> 
<p>List 转数组，使用 List 的 toArray 方法。无参 toArray 方法返回 Object 数组，传入初始化长度的数组对象，返回该对象数组</p> 
<h3><a id="_2989"></a>哪些集合类是线程安全的？</h3> 
<ul><li>Vector</li><li>Stack</li><li>Hashtable</li><li>java.util.concurrent 包下所有的集合类 ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque…</li></ul> 
<h3><a id="Iterator_2996"></a>Iterator怎么使用？有什么特点？</h3> 
<ul><li>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</li><li>next() 方法获得集合中的下一个元素</li><li>hasNext() 检查集合中是否还有元素</li><li>remove() 方法将迭代器新返回的元素删除</li><li>forEachRemaining(Consumer&lt;? super E&gt; action) 方法，遍历所有元素</li></ul> 
<h2><a id="_3004"></a>多线程线程池====================================</h2> 
<h3><a id="_3006"></a>什么是线程？</h3> 
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p> 
<p>比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒</p> 
<h3><a id="_3012"></a>什么是线程安全和线程不安全？</h3> 
<p><strong>通俗的说：加锁的就是是线程安全的，不加锁的就是是线程不安全的</strong></p> 
<h3><a id="_3016"></a>线程安全</h3> 
<p><strong>线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染</strong>。</p> 
<p>一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将<strong>集合类分成两组，线程安全和非线程安全的</strong>。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p> 
<h3><a id="_3022"></a>线程不安全</h3> 
<p><strong>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</strong></p> 
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p> 
<p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p> 
<h3><a id="_3030"></a>什么是多线程？优缺点？</h3> 
<p><strong>什么是多线程？</strong></p> 
<p>多线程：是指从软件或者硬件上实现多个线程的并发技术。</p> 
<p><strong>多线程的好处：</strong></p> 
<ol><li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载</li><li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</li></ol> 
<p><strong>多线程的缺点：</strong></p> 
<ol><li>大量的线程降低代码的可读性；</li><li>更多的线程需要更多的内存空间</li><li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li></ol> 
<h3><a id="_3047"></a>什么是多线程的上下文切换？</h3> 
<p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）</p> 
<p><strong>上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行</strong></p> 
<p><strong>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态</strong></p> 
<ul><li><strong>从任务保存到再加载的过程就是一次上下文切换</strong></li></ul> 
<h3><a id="_Java__3057"></a>如何创建、启动 Java 线程？</h3> 
<p><strong>一、重写 Thread 类的 run() 方法。</strong></p> 
<p>表现形式有两种：<strong>1）new Thread 对象匿名重写 run() 方法</strong></p> 
<p><strong>2）继承 Thread 对象，重写 run() 方法</strong></p> 
<p><strong>二、实现 Runnable 接口，重写 run() 方法。</strong></p> 
<p>表现形式有两种：<strong>1）new Runnable 对象，匿名重写 run() 方法</strong></p> 
<p>2）实现 Runnable 接口，重写 run() 方法</p> 
<p><strong>三、实现 Callable 接口，使用 FutureTask 类创建线程</strong></p> 
<p><strong>四、使用线程池创建、启动线程</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">package</span> constxiong<span class="token punctuation">.</span>concurrency<span class="token punctuation">.</span>a006<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span>

<span class="token comment">/**
 * 线程池的方式启动线程
 * @author ConstXiong
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCreateThreadByThreadPool</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token parameter">String<span class="token punctuation">[</span><span class="token punctuation">]</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用工具类 Executors 创建单线程线程池</span>
        ExecutorService singleThreadExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//提交执行任务</span>
        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"单线程线程池执行任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//关闭线程池</span>
        singleThreadExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_3098"></a><strong>什么是线程池？</strong></h3> 
<p>线程池就是创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。</p> 
<h3><a id="_3102"></a>一个线程池包括以下四个基本组成部分：</h3> 
<p>1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br> 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br> 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；<br> 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</p> 
<h3><a id="_3109"></a>常见线程池</h3> 
<p>①newSingleThreadExecutor<br> 单个线程的线程池，即线程池中每次只有一个线程工作，单线程串行执行任务<br> ②newFixedThreadExecutor(n)<br> 固定数量的线程池，没提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成才继续执行<br> ③newCacheThreadExecutor（推荐使用）<br> 可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行。<br> ④newScheduleThreadExecutor<br> 大小无限制的线程池，支持定时和周期性的执行线程</p> 
<h3><a id="_3120"></a>线程池常用参数</h3> 
<p>corePoolSize：核心线程数量，会一直存在，除非allowCoreThreadTimeOut设置为true<br> maximumPoolSize：线程池允许的最大线程池数量<br> keepAliveTime：线程数量超过corePoolSize，空闲线程的最大超时时间<br> unit：超时时间的单位<br> workQueue：工作队列，保存未执行的Runnable 任务<br> threadFactory：创建线程的工厂类<br> handler：当线程已满，工作队列也满了的时候，会被调用。被用来实现各种拒绝策略。</p> 
<h3><a id="_3130"></a><strong>为什么要使用线程池？</strong></h3> 
<p>因为 Java 中创建一个线程，需要调用操作系统内核的 API，操作系统要为线程分配一系列的资源，成本很高，所以线程是一个重量级的对象，应该避免频繁创建和销毁。<br> 使用线程池就能很好地避免频繁创建和销毁。</p> 
<h3><a id="_3135"></a>如何在两个线程之间共享数据</h3> 
<p>1，如果每个线程执行的<strong>代码相同</strong>，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。</p> 
<p>2，如果每个线程执行的<strong>代码不同</strong>，这时候需要用不同的Runnable对象，例如，设计4个线程。其中两个线程每次对j增加1，另外两个线程对j每次减1，银行存取款</p> 
<h2><a id="java_3141"></a>java基础=======================================</h2> 
<h3><a id="equals_3143"></a>==和equals的区别是什么?</h3> 
<ul><li>== 是关系运算符，equals() 是方法，结果都返回布尔值</li><li>Object 的 == 和 equals() 比较的都是地址，作用相同</li></ul> 
<p><strong>== 作用：</strong></p> 
<ul><li>基本类型，比较值是否相等</li><li>引用类型，比较内存地址值是否相等</li><li>不能比较没有父子关系的两个对象</li></ul> 
<p><strong>equals()方法的作用：</strong></p> 
<ul><li>JDK 中的类一般已经重写了 equals()，比较的是内容</li><li>自定义类如果没有重写 equals()，将调用父类（默认 Object 类）的 equals() 方法，Object 的 equals() 比较使用了 this == obj</li><li>可以按照需求逻辑，重写对象的 equals() 方法（重写 equals 方法，一般须重写 hashCode 方法）</li></ul> 
<h3><a id="hashCodeequalstrue_3160"></a>hashCode()相同，equals()也一定为true吗？</h3> 
<p>首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。</p> 
<ul><li>类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。</li><li>hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。</li></ul> 
<p>关于 hashCode() 和 equals() 是方法是有一些 常规协定：</p> 
<p>1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。</p> 
<p>2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。</p> 
<p>3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。</p> 
<h3><a id="final_finally_finalize_3175"></a>final finally finalize()区别</h3> 
<ul><li>final 表示最终的、不可改变的。用于修饰类、方法和变量。final 修饰的类不能被继承；final 方法也同样只能使用，不能重写，但能够重载；final 修饰的成员变量必须在声明时给定初值或者在构造方法内设置初始值，只能读取，不可修改；final 修饰的局部变量必须在声明时给定初值；final 修饰的变量是非基本类型，对象的引用地址不能变，但对象的属性值可以改变</li><li>finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）</li><li>finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。</li></ul> 
<h3><a id="_3181"></a>如何将字符串反转？</h3> 
<ul><li>使用 StringBuilder 或 StringBuffer 的 reverse 方法，本质都调用了它们的父类 AbstractStringBuilder 的 reverse 方法实现。（JDK1.8）</li><li>不考虑字符串中的字符是否是 Unicode 编码，自己实现。</li><li>递归</li></ul> 
<h3><a id="String_3187"></a>String类的常用方法有哪些？</h3> 
<p>String 类的常用方法：</p> 
<ul><li>equals：字符串是否相同</li><li>equalsIgnoreCase：忽略大小写后字符串是否相同</li><li>compareTo：根据字符串中每个字符的Unicode编码进行比较</li><li>compareToIgnoreCase：根据字符串中每个字符的Unicode编码进行忽略大小写比较</li><li>indexOf：目标字符或字符串在源字符串中位置下标</li><li>lastIndexOf：目标字符或字符串在源字符串中最后一次出现的位置下标</li><li>valueOf：其他类型转字符串</li><li>charAt：获取指定下标位置的字符</li><li>codePointAt：指定下标的字符的Unicode编码</li><li>concat：追加字符串到当前字符串</li><li>isEmpty：字符串长度是否为0</li><li>contains：是否包含目标字符串</li><li>startsWith：是否以目标字符串开头</li><li>endsWith：是否以目标字符串结束</li><li>format：格式化字符串</li><li>getBytes：获取字符串的字节数组</li><li>getChars：获取字符串的指定长度字符数组</li><li>toCharArray：获取字符串的字符数组</li><li>join：以某字符串，连接某字符串数组</li><li>length：字符串字符数</li><li>matches：字符串是否匹配正则表达式</li><li>replace：字符串替换</li><li>replaceAll：带正则字符串替换</li><li>replaceFirst：替换第一个出现的目标字符串</li><li>split：以某正则表达式分割字符串</li><li>substring：截取字符串</li><li>toLowerCase：字符串转小写</li><li>toUpperCase：字符串转大写</li><li>trim：去字符串首尾空格</li></ul> 
<h3><a id="_3221"></a>普通类和抽象类有哪些区别？</h3> 
<ul><li>抽象类不能被实例化</li><li>抽象类可以有抽象方法，抽象方法只需申明，无需实现</li><li>含有抽象方法的类必须申明为抽象类</li><li>抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</li><li>抽象方法不能被声明为静态</li><li>抽象方法不能用 private 修饰</li><li>抽象方法不能用 final 修饰</li></ul> 
<p>**重写：**在子类中将父类的成员方法的名称保留，重新编写成员方法的实现内容，更改方法的访问权限，修改返回类型的为父类返回类型的子类。<br> <strong>一些规则：</strong><br> 重写发生在子类继承父类<br> 参数列表必须完全与被重写方法的相同<br> 重写父类方法时，修改方法的权限只能从小范围到大范围<br> 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的子类(JDK1.5 及更早版本返回类型要一样，JDK1.7 及更高版本可以不同)<br> 访问权限不能比父类中被重写的方法的访问权限更低。如：父类的方法被声明为 public，那么子类中重写该方法不能声明为 protected<br> 重写方法不能抛出新的检查异常和比被重写方法申明更宽泛的异常(即只能抛出父类方法抛出异常的子类)<br> 声明为 final 的方法不能被重写<br> 声明为 static 的方法不能被重写<br> 声明为 private 的方法不能被重写</p> 
<p>**重载：**一个类中允许同时存在一个以上的同名方法，这些方法的参数个数或者类型不同</p> 
<p><strong>重载条件：</strong></p> 
<ul><li>方法名相同</li><li>参数类型不同 或 参数个数不同 或 参数顺序不同</li></ul> 
<p><strong>规则：</strong><br> 被重载的方法<strong>参数列表(个数或类型)不一样<br> 被重载的方法可以修改返回类型<br> 被重载的方法可以修改访问修饰符<br> 被重载的方法可以修改异常抛出<br> 方法能够在同一个类中或者在一个子类中被重载<br> 无法以返回值类型作为重载函数的区分标准</strong></p> 
<h3><a id="_3258"></a>方法重载和重写是什么？有什么区别？</h3> 
<ul><li>作用范围：重写的作用范围是父类和子类之间；重载是发生在一个类里面</li><li>参数列表：重载必须不同；重写不能修改</li><li>返回类型：重载可修改；重写方法返回相同类型或子类</li><li>抛出异常：重载可修改；重写可减少或删除，一定不能抛出新的或者更广的异常</li><li>访问权限：重载可修改；重写一定不能做更严格的限制</li></ul> 
<h3><a id="_3266"></a>内存泄漏和内存溢出的区别</h3> 
<ul><li>内存溢出(out of memory)：指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory。</li><li>内存泄露(memory leak)：指程序在申请内存后，无法释放已申请的内存空间，内存泄露堆积会导致内存被占光。</li><li>memory leak 最终会导致 out of memory。</li></ul> 
<h3><a id="_3272"></a>什么是多态？如何实现？有什么好处？</h3> 
<p><strong>多态：</strong><br> 同一个接口，使用不同的实例而执行不同操作。同一个行为具有多个不同表现形式或形态的能力。</p> 
<p><strong>实现多态有三个条件：</strong></p> 
<ul><li>继承</li><li>子类重写父类的方法</li><li>父类引用变量指向子类对象</li></ul> 
<h3><a id="LambdaRunnable_3283"></a>用Lambda表达式实现Runnable：</h3> 
<pre><code>@Test
public void test1(){
    //使用Java8之前
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("使用Lambda表达式之前，需要这么写！");
        }
    }).start();
    //使用Lambda表达式
    new Thread(() -&gt; System.out.println("使用Lambda表达式，只需要这一句话！")).start();
</code></pre> 
<h3><a id="String_sabcd_3297"></a>String s=“a”+“b”+“c”+“d”;创建了几个对象？</h3> 
<p>1个</p> 
<p>Java 编译器对字符串常量直接相加的表达式进行优化，不等到运行期去进行加法运算，在编译时就去掉了加号，直接将其编译成一个这些常量相连的结果。</p> 
<p>所以 “a”+“b”+“c”+“d” 相当于直接定义一个 “abcd” 的字符串。</p> 
<h3><a id="String_s__new_StringxyzString_3305"></a>String s = new String(“xyz”);创建几个String对象？</h3> 
<p>两个或一个</p> 
<ul><li>第一次调用 new String(“xyz”); 时，会在堆内存中创建一个字符串对象，同时在字符串常量池中创建一个对象 “xyz”</li><li>第二次调用 new String(“xyz”); 时，只会在堆内存中创建一个字符串对象，指向之前在字符串常量池中创建的 “xyz”</li></ul> 
<h3><a id="_3312"></a>序列化</h3> 
<p>**序列化：**把对象转化为可传输的字节序列过程称为序列化。</p> 
<p>**反序列化：**把字节序列还原为对象的过程称为反序列化。</p> 
<h4><a id="_3318"></a><strong>为什么要序列化？</strong></h4> 
<p>如果光看定义我想你很难一下子理解序列化的意义，那么我们可以从另一个角度来推导出什么是序列化, 那么究竟序列化的目的是什么？</p> 
<p>其实序列化最终的目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</p> 
<p>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则**（序列化）<strong>，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来</strong>（反序列化）。**</p> 
<p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p> 
<h3><a id="_3328"></a><strong>什么情况下需要序列化？</strong></h3> 
<p>通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p> 
<p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p> 
<hr> 
<h3><a id="_3336"></a><strong>序列化的方式</strong></h3> 
<p>序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：</p> 
<p>JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protostuff、FST（不支持跨语言）</p> 
<hr> 
<h3><a id="_3344"></a>序列化技术选型的几个关键点</h3> 
<p>序列化协议各有千秋，不能简单的说一种序列化协议是最好的，只能从你的当时环境下去选择最适合你们的序列化协议，如果你要为你的公司项目进行序列化技术的选型，那么主要从以下几个因素。</p> 
<p><strong>协议是否支持跨平台</strong></p> 
<p>如果你们公司有好多种语言进行混合开发，那么就肯定不适合用有语言局限性的序列化协议，要不然你JDK序列化出来的格式，其他语言并没法支持。</p> 
<p><strong>序列化的速度</strong></p> 
<p>如果序列化的频率非常高，那么选择序列化速度快的协议会为你的系统性能提升不少。</p> 
<p><strong>序列化出来的大小</strong></p> 
<p>如果频繁的在网络中传输的数据那就需要数据越小越好，小的数据传输快，也不占带宽，也能整体提升系统的性能。</p> 
<hr> 
<h3><a id="Java__3362"></a><strong>Java 是如何实现序列化的？</strong></h3> 
<p>前面主要介绍了一下什么是序列化，那么下面主要讲下JAVA是如何进行序列化的，以及序列化的过程中需要注意的一些问题</p> 
<ul><li><strong>java 实现序列化很简单，只需要实现Serializable 接口即可。</strong></li></ul> 
<h3><a id="JAVA_3368"></a><strong>JAVA序列化中常见的问题</strong></h3> 
<ul><li><strong>问题一：static 属性不能被序列化</strong></li></ul> 
<p>原因：序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p> 
<ul><li><strong>问题二：Transient 属性不会被序列化</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27e929bec693af9fe87ca7a5609a2831/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS:mix-blend-mode 颜色混合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ce2d00254404f50f1fb5f77dd9dafa1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tiktok在线网页版和Tiktok安卓解锁版教程（Tiktok免登录国内直接看）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>