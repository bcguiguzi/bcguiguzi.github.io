<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c：rand()和time函数 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c：rand()和time函数" />
<meta property="og:description" content="rand rand函数使用线性同余法实现随机数，是伪随机数，由于周期较长（至少是32767），因此在一定范围内可以看成是随机的。 int rand(void) : stdlib.h 返回[0,RAND_MAX]范围的整数，ANSI C只规定了函数rand的返回值类型（即int）和返回值上界（即RAND_MAX），也就是说，任何一个具体的实现，只要RAND_MAX不超过其所在平台int的正向最大值都是允许的（不然返回值发生溢出），例如，
在VC&#43;&#43;2010和MinGW GCC TDM 5.1 32bit中，RAND_MAX=32767=0x7FFF，即short int的正向最大值。
在CentOS 7的GCC 4.8.2 x86_64中，RAND_MAX=2147483647=0x7FFFFFFF，即其int的正向最大值。
其中RAND_MAX这个宏定义位于stdlib.h中
在rand函数内，维护着一个计数器，每次调用rand函数都会使计数器&#43;1，然后计数器与种子发生运算，返回[0,RAND_MAX]中的一个整数，这也导致了每次运行相同的rand函数总是返回相同的值，如，
int i; for (i=0;i&lt;10;i&#43;&#43;){ printf(&#34;%d\n&#34;,rand()); } 每次运行，得到的10个随机数都相同。
void srand(unsigned int) : stdlib.h 依据传入的无符号整数，来设置对应的随机数种子，这个随机数种子是全局的变量，能够被rand函数读取，能够被srand函数修改。
time.h time_t time(time_t *) : time.h 返回从Unix元年（1970年1月1日0点）到当前时间所经过的秒数.
日历时间，即机器时，1970年之后的秒数
UTC，GMT，世界标准时间（经度0），中国是UTC&#43;8
epoch：时间点，当前机器时
clock tick：时钟计时单元，一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C&#43;&#43;的一个基本计时单位（单位为毫秒）
typedef __time64_t time_t; : types.h typedef __int64 __time64_t; : types.h #define __int64 long long : _mingw.h time函数获取秒数有两种方式，
1.直接通过函数的返回值获取秒数，
2.通过传入一个time_t类型的地址，函数会将秒数也保存到这个地址上，
当传入的指针是NULL或0时，函数只通过返回值返回秒数。
由于秒数总是在向前变化，所以可以利用time函数的返回值来作为srand的传入参数。
在写这篇文章时，time(0)返回的值是1583975156，在unsigned int范围内。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0ad7bff57f5b009cbc1ab4e260a9e202/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-10T03:31:22+08:00" />
<meta property="article:modified_time" content="2022-04-10T03:31:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c：rand()和time函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li>rand</li></ul> 
<p>rand函数使用线性同余法实现随机数，是伪随机数，由于周期较长（至少是32767），因此在一定范围内可以看成是随机的。 </p> 
<pre><code class="language-cpp">int rand(void) : stdlib.h</code></pre> 
<p>返回[0,RAND_MAX]范围的整数，ANSI C只规定了函数rand的返回值类型（即int）和返回值上界（即RAND_MAX），也就是说，任何一个具体的实现，只要RAND_MAX不超过其所在平台int的正向最大值都是允许的（不然返回值发生溢出），例如，<br> 在VC++2010和MinGW GCC TDM 5.1 32bit中，RAND_MAX=32767=0x7FFF，即short int的正向最大值。<br> 在CentOS 7的GCC 4.8.2 x86_64中，RAND_MAX=2147483647=0x7FFFFFFF，即其int的正向最大值。<br> 其中RAND_MAX这个宏定义位于stdlib.h中</p> 
<p>在rand函数内，维护着一个计数器，每次调用rand函数都会使计数器+1，然后计数器与种子发生运算，返回[0,RAND_MAX]中的一个整数，这也导致了每次运行相同的rand函数总是返回相同的值，如，</p> 
<pre><code>int i;
for (i=0;i&lt;10;i++){
printf("%d\n",rand());
}</code></pre> 
<p>每次运行，得到的10个随机数都相同。</p> 
<pre><code>void srand(unsigned int) : stdlib.h</code></pre> 
<p>依据传入的无符号整数，来设置对应的随机数种子，这个随机数种子是全局的变量，能够被rand函数读取，能够被srand函数修改。</p> 
<ul><li>time.h</li></ul> 
<pre><code>time_t time(time_t *) : time.h</code></pre> 
<p>返回从Unix元年（1970年1月1日0点）到当前时间所经过的秒数.</p> 
<p>日历时间，即机器时，1970年之后的秒数</p> 
<p>UTC，GMT，世界标准时间（经度0），中国是UTC+8</p> 
<p>epoch：时间点，当前机器时</p> 
<p>clock tick：时钟计时单元，一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C++的一个基本计时单位（单位为毫秒）</p> 
<pre><code>typedef __time64_t time_t; : types.h
typedef __int64 __time64_t; : types.h
#define __int64 long long : _mingw.h</code></pre> 
<p>time函数获取秒数有两种方式，<br> 1.直接通过函数的返回值获取秒数，<br> 2.通过传入一个time_t类型的地址，函数会将秒数也保存到这个地址上，<br> 当传入的指针是NULL或0时，函数只通过返回值返回秒数。</p> 
<p>由于秒数总是在向前变化，所以可以利用time函数的返回值来作为srand的传入参数。<br> 在写这篇文章时，time(0)返回的值是1583975156，在unsigned int范围内。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab7afb3b06351eda8aeb8a41a7d80a58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装miktex&#43;winedit</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c0f1630d09935d306f0ff6bf4e509a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrap-fileinput分片上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>