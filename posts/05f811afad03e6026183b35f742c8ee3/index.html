<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言 对一个字节的某一位进行操作,位操作的实现与分析 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言 对一个字节的某一位进行操作,位操作的实现与分析" />
<meta property="og:description" content="每个位操作都可操作缓冲区中的数据，缓冲区由无符号字符作为指针来指定。该指针指向足够多的字节来表示缓冲区中的位数。如果缓冲区中的位数不是8的倍数，那么说明最后一个字节的某些位没有使用。
bit_get
bit_get 操作获取缓冲区中一个位的状态。要做到这一点，首先要确定位所在的字节，然后通过一个掩码从字节中获取相应的位。掩码中设置为1的位是将要从字节中读出的位。接着用一个循环操作将位移动到适当的位置。通过索引bits中相应的字节，并应用掩码，可以获取所需的位。
bit_get的时间复杂度为O(1)。这是因为获取缓冲区中位的状态所进行的所有操作都能够在固定时间内完成。
bit_set
bit_set 操作设置缓冲区中一个位的状态。此操作与bit_get的工作方式相 似，只是它是利用掩码设置指定位的状态，而获取指定位的状态。
bit_set 的时间复杂度为O(1)。这是因为获取缓冲区中位的状态所进行的所有操作都能够 在固定时间内完成。
bit_xor
对两个缓冲区bits1和bits2进行按位异或运算，并将计算的结果放到缓冲区bitsx中。要做到这一点，将bits1中第i个位置的位与bits2中第i个位置的位进行比较，如果位值相同，将第i个位置的位置0；否则，将第i个位置的位置1。这个过程会持续下去直到size指定的每个缓冲区中的位都计算完成。
bit_xor 的时间复杂度为O(β)，其中β是每个缓冲区中的位数。这是因为此操作要在毎个位上循环迭代一次。
bit_rot_left
bit_rot_left 将缓冲区指定数量的位向左轮转。首先保存最左端字节的最左端位值，然后向左一位一位地移动每个字节的位值。在移动字节的过程中，将前一个字节最右边的位移到当前字节的最左边。当处理到最后一个字节时，将其最右边的位移动到首字节的最高位上。这个过程一直持续下去直到所有的位都轮转到位。
bit_rot_left 的时间复杂度为O(nβ)，其中n为要向左轮转的位的个数，β是缓冲区中位的个数。这是因为，对于每次轮转，要进行(β/8)&#43;1次移动。
位操作的实现代码：
/* bit.c */
#include #include “bit.h”
/* bit_get */
int bit_get(const unsigned char *bits, int pos)
{
unsigned char mask;
int i;
/* Set a mask for the bit to get. */
mask = 0x80;
for (i = 0; i &lt; (pos % 8); i&#43;&#43;)
mask = mask &gt;&gt; 1;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/05f811afad03e6026183b35f742c8ee3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-17T13:51:00+08:00" />
<meta property="article:modified_time" content="2021-05-17T13:51:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言 对一个字节的某一位进行操作,位操作的实现与分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>每个位操作都可操作缓冲区中的数据，缓冲区由无符号字符作为指针来指定。该指针指向足够多的字节来表示缓冲区中的位数。如果缓冲区中的位数不是8的倍数，那么说明最后一个字节的某些位没有使用。</p> 
 <p>bit_get</p> 
 <p>bit_get 操作获取缓冲区中一个位的状态。要做到这一点，首先要确定位所在的字节，然后通过一个掩码从字节中获取相应的位。掩码中设置为1的位是将要从字节中读出的位。接着用一个循环操作将位移动到适当的位置。通过索引bits中相应的字节，并应用掩码，可以获取所需的位。</p> 
 <p>bit_get的时间复杂度为O(1)。这是因为获取缓冲区中位的状态所进行的所有操作都能够在固定时间内完成。</p> 
 <p>bit_set</p> 
 <p>bit_set 操作设置缓冲区中一个位的状态。此操作与bit_get的工作方式相 似，只是它是利用掩码设置指定位的状态，而获取指定位的状态。</p> 
 <p>bit_set 的时间复杂度为O(1)。这是因为获取缓冲区中位的状态所进行的所有操作都能够 在固定时间内完成。</p> 
 <p>bit_xor</p> 
 <p>对两个缓冲区bits1和bits2进行按位异或运算，并将计算的结果放到缓冲区bitsx中。要做到这一点，将bits1中第i个位置的位与bits2中第i个位置的位进行比较，如果位值相同，将第i个位置的位置0；否则，将第i个位置的位置1。这个过程会持续下去直到size指定的每个缓冲区中的位都计算完成。</p> 
 <p>bit_xor 的时间复杂度为O(β)，其中β是每个缓冲区中的位数。这是因为此操作要在毎个位上循环迭代一次。</p> 
 <p>bit_rot_left</p> 
 <p>bit_rot_left 将缓冲区指定数量的位向左轮转。首先保存最左端字节的最左端位值，然后向左一位一位地移动每个字节的位值。在移动字节的过程中，将前一个字节最右边的位移到当前字节的最左边。当处理到最后一个字节时，将其最右边的位移动到首字节的最高位上。这个过程一直持续下去直到所有的位都轮转到位。</p> 
 <p>bit_rot_left 的时间复杂度为O(nβ)，其中n为要向左轮转的位的个数，β是缓冲区中位的个数。这是因为，对于每次轮转，要进行(β/8)+1次移动。</p> 
 <p>位操作的实现代码：</p> 
 <p>/* bit.c */</p> 
 <p>#include </p> 
 <p>#include “bit.h”</p> 
 <p>/* bit_get */</p> 
 <p>int bit_get(const unsigned char *bits, int pos)</p> 
 <p>{<!-- --></p> 
 <p>unsigned char mask;</p> 
 <p>int i;</p> 
 <p>/* Set a mask for the bit to get. */</p> 
 <p>mask = 0x80;</p> 
 <p>for (i = 0; i &lt; (pos % 8); i++)</p> 
 <p>mask = mask &gt;&gt; 1;</p> 
 <p>/* Get the bit. */</p> 
 <p>return (((mask &amp; bits[(int)(pos / 8)]) == mask) ? 1 : 0);</p> 
 <p>}</p> 
 <p>/* bit_set */</p> 
 <p>void bit_set(unsigned char *bits, int pos, int state)</p> 
 <p>{<!-- --></p> 
 <p>unsigned char mask;</p> 
 <p>int i;</p> 
 <p>/* Set a mask for the bit to set. */</p> 
 <p>mask = 0x80;</p> 
 <p>for (1 = 0; i &lt; (pos % 8); i++)</p> 
 <p>mask = mask &gt;&gt; 1;</p> 
 <p>/* Set the bit. */</p> 
 <p>if (state)</p> 
 <p>bits[pos / 8] = bits[pos / 8] | mask;</p> 
 <p>else</p> 
 <p>bits[pos / 8] = bits[pos / B] &amp; (~mask);</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>/* bit_xor */</p> 
 <p>void *bit_xor(const unsigned char *bits1, const unsigned char *bits2, unsigned char *bitsx, int size)</p> 
 <p>{<!-- --></p> 
 <p>int i;</p> 
 <p>/* Compute the bitwise XOR (exclusive OR) of the two buffers. */</p> 
 <p>for (i = 0; i &lt; size; i++)</p> 
 <p>{<!-- --></p> 
 <p>if (bit_ get(bits1, i) != bit_ get(bits2, i))</p> 
 <p>bit_set(bitsx, i, 1);</p> 
 <p>else</p> 
 <p>bit_set(bitsx, i, 0);</p> 
 <p>}</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>/* bit_rot_left */</p> 
 <p>void bit_rot_left(unsigned char *bits, int size, int count)</p> 
 <p>{<!-- --></p> 
 <p>int fbit,</p> 
 <p>lbit,</p> 
 <p>i,</p> 
 <p>j;</p> 
 <p>/* Rotate the buffer to the left the specified number of bits. */</p> 
 <p>if (size &gt; 0)</p> 
 <p>{<!-- --></p> 
 <p>for (j = 0; j &lt; count; j++)</p> 
 <p>{<!-- --></p> 
 <p>for (i = 0; i &lt;= ((size - l) / 8); i十十)</p> 
 <p>{<!-- --></p> 
 <p>/* Get the bit about to be shifted off the current byte. */</p> 
 <p>lbit = bit_get(&amp;bits[i], 0);</p> 
 <p>if (i == 0)</p> 
 <p>{<!-- --></p> 
 <p>/* Save the bit shifted off the first byte for later. */</p> 
 <p>fbit = lbit;</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>/* Set the rightmost bit of the previous byte to the leftmost *</p> 
 <p>* bit about to be shifted off the current byte. */</p> 
 <p>bit_set(&amp;bits[i - 1], 7, lbit);</p> 
 <p>}</p> 
 <p>/* Shift the current byte to the left. */</p> 
 <p>bits[i] = bits[i] &lt;&lt; 1;</p> 
 <p>}</p> 
 <p>/* Set the rightmost bit of the buffer to the bit shifted off the *</p> 
 <p>* first byte. */</p> 
 <p>bit_set(bits, size - 1, fbit);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return;</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8b1414f0dbdabd07d6a01568709ac06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Windows上搭建TensorFlow</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53bf289342742809eb7a1b42d6cf5baf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符串———find（）函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>