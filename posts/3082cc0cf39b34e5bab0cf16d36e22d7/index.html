<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣LeetCode-贪心算法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣LeetCode-贪心算法" />
<meta property="og:description" content="贪心算法 基本知识 1.思想 基于局部最优的选择逐渐推导出全局最优解
2.一般步骤 将问题分解为若干个子问题；
找出合适的贪心策略；
求解每一个子问题的最优解；
将局部最优解合成为全局最优解；
典型例题 1. LeetCode 376. 摆动序列 题目
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
来源：力扣（LeetCode） 链接：力扣 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路
求取摆动子序列元素个数，则与原数组峰值个数有关；
遍历原数组，记录相邻两个数的差值，若后面相邻两数差值与之前异号，则摆动子序列元素个数加1；
代码
class Solution { public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if(nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3082cc0cf39b34e5bab0cf16d36e22d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-04T22:31:03+08:00" />
<meta property="article:modified_time" content="2022-03-04T22:31:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣LeetCode-贪心算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>贪心算法</h2> 
<h3>基本知识</h3> 
<h4>1.思想</h4> 
<p>基于局部最优的选择逐渐推导出全局最优解</p> 
<h4>2.一般步骤</h4> 
<ol><li> <p>将问题分解为若干个子问题；</p> </li><li> <p>找出合适的贪心策略；</p> </li><li> <p>求解每一个子问题的最优解；</p> </li><li> <p>将局部最优解合成为全局最优解；</p> </li></ol> 
<h3>典型例题</h3> 
<h4>1. LeetCode 376. 摆动序列</h4> 
<p>题目</p> 
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p> 
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p> 
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p> 
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>求取摆动子序列元素个数，则与原数组峰值个数有关；</p> </li><li> <p>遍历原数组，记录相邻两个数的差值，若后面相邻两数差值与之前异号，则摆动子序列元素个数加1；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1)return 1;
        int pre_off = 0, cur_off;//pre_off用于记录最后录入两个元素的差值的正负，cur_off用于记录原数组相邻两个数的差值
        int result = 1;
        for(int i=1; i&lt;nums.size(); i++){
            cur_off = nums[i] - nums[i-1];
            if((pre_off &lt;= 0 &amp;&amp; cur_off &gt;0) || (pre_off &gt;=0 &amp;&amp; cur_off &lt;0)){//pre_off需要设置=0是由于初始化时pre_off设置为0，后面由于pre_off = cur_off则不可能再出现=0可能
                result++;
                pre_off = cur_off;
            }
        }
        return result;
    }
};</pre> 
<h4>2. LeetCode 122. 买卖股票的最佳时机II</h4> 
<p>题目</p> 
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p> 
<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。 返回 你能获得的 最大 利润 。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<p>方法一（贪心算法）</p> 
<ol><li> <p>遍历数组，若后一天价格高于前一天则累加收益；</p> </li><li> <p>上面操作能获得最大利润的原因是，遍历到某一天时并不确定当天是否进行买入，直到第二天看到存在利润才决定前一天的是否进行买入，而看到利润的同时并没有决定是否卖出，直至后面出现新利润才决定是否卖出；</p> </li></ol> 
<p>方法二（动态规划）</p> 
<ol><li> <p>p[i] [0]示第i+1天手中无股票，可能昨天没有或者昨天有今天卖出；</p> </li><li> <p>p[i] [1]表示第i+1天手中有股票，可能昨天有股票或者昨天没有今天买入；</p> </li><li> <p>由前一天两种可能的状态推断今天两种可能的状态（获取较高的利润）；</p> </li></ol> 
<p>代码</p> 
<p>方法一（贪心算法）</p> 
<pre>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for(int i=1; i&lt;prices.size(); i++){
            if(prices[i]&gt;prices[i-1]){
                result+=prices[i]-prices[i-1];
            }
        }
        return result;
    }
};</pre> 
<p>方法二（动态规划）</p> 
<pre>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len = prices.size();
        vector&lt;vector&lt;int&gt;&gt; p(len, vector&lt;int&gt;(2, 0));
        p[0][0] = 0;
        p[0][1] = -prices[0];
        for(int i=1; i&lt;len; i++){
            p[i][0] = max(p[i-1][0], p[i-1][1]+prices[i]);
            p[i][1] = max(p[i-1][1], p[i-1][0]-prices[i]);
        }
        return p[len-1][0];
    }
};</pre> 
<h4>3. LeetCode 45. 跳跃游戏</h4> 
<p>题目</p> 
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p> 
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p> 
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p> 
<p>假设你总是可以到达数组的最后一个位置。</p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>每次跳跃时，计算每个可跳跃节点中最远跳跃距离下标，当可跳跃节点遍历后，即进行下一次跳跃，跳跃次数增加1；</p> </li><li> <p>用temp记录尝试过可跳跃节点最远跳跃下标，在每次可跳跃节点遍历后更新reach；</p> </li><li> <p>当reach&gt;=nums.size()-1时代表本次跳跃可以跳到最后，增加跳跃次数后，退出循环；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int count = 0;//记录跳跃次数
        int reach = nums[0];//记录一次跳跃中可跳跃节点最远跳跃距离下标
        int temp = nums[0];//持续更新跳跃最远距离下标
        for(int i=1; i&lt;nums.size(); i++){
            temp = max(nums[i]+i, temp);
            if(reach &gt;=nums.size()-1){
                count++;
                break;
            }
            if(i == reach){
                reach = temp;
                count++;
            }
        }
        return count;
    }
};</pre> 
<h4>4. LeetCode 1005. K次取反后最大化的数组和</h4> 
<p>题目</p> 
<p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p> 
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p> 
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>将数组按绝对值从大到小进行排序；</p> </li><li> <p>从头遍历数组，将负数变为正数，同时k减1，当k为0或者数组遍历结束后退出循环；</p> </li><li> <p>退出循环后，若k仍大于0，且为奇数时，则将数组最后一个元素取反；</p> </li><li> <p>思想就是将最小的负数变为正数，若所有元素均为正数时，且变化次数剩余为奇数，则将最小正数直接取反；（若变化剩余次数为偶数，则可认为将任意一个数做偶次数取反变化，最终值不变化）</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
private:
    static bool mycompare(const int &amp;a, const int &amp;b){
        return abs(a)&gt;abs(b);
    }
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) {
        sort(nums.begin(), nums.end(), mycompare);
        for(int i=0; i&lt;nums.size() &amp;&amp; k&gt;0; i++){
            if(nums[i] &lt; 0){
                nums[i] = -nums[i];
                k--;
            }
        }
        if(k%2==1){
            nums[nums.size()-1] *= -1;
        }
​
        int result = 0;
        for(int i=0; i&lt;nums.size(); i++){
            result+= nums[i];
        }
        return result;
    }
};</pre> 
<h4>5. LeetCode 134. 加油站</h4> 
<p>题目</p> 
<p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p> 
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p> 
<p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/gas-station" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>遍历一遍，用run记录总油量是否可以走完全程（即能否完成一圈）</p> </li><li> <p>oil用于记录从某一位置开始油箱中的当前油量，当油量为负数时，说明前一部分路程不能到达，开始位置应该设置为下一地点</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int oil = 0, run = 0, start = 0;
        for(int i=0; i&lt;gas.size(); i++){
            oil += gas[i]-cost[i];
            run += gas[i]-cost[i];
            if(oil &lt; 0){
                start = i+1;
                oil = 0;
            }
        }
        return run&gt;=0?start:-1;
    }
};
​
​</pre> 
<h4>6. LeetCode 135. 分发糖果</h4> 
<p>题目</p> 
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p> 
<p>你需要按照以下要求，给这些孩子分发糖果：</p> 
<p>每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/candy" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>由于每个孩子所能获得的糖果同时与两边孩子评分有关，则单通过一个方向的遍历不能得到答案；</p> </li><li> <p>从两个方向遍历，即可同时兼顾两边情况，当从左向右遍历时，若左边评分大于自身评分，则设置糖果数比左边大1，否则设置为1；</p> </li><li> <p>当从右向左遍历时，若右边评分小于自身评分，则比较上次遍历后该位置糖果数与右边糖果数+1，取较大者，从而使该位置同时满足两个方向的要求；</p> </li><li> <p>最终得到的数组即为所需糖果数最少的分配方案；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        vector&lt;int&gt;result(ratings.size(), 1);
        for(int i=1; i&lt;ratings.size(); i++){
            if(ratings[i] &gt; ratings[i-1]){
                result[i] = result[i-1]+1;
            }
        }
​
        for(int i=ratings.size()-2; i&gt;=0; i--){
            if(ratings[i] &gt; ratings[i+1]){
                result[i] = max(result[i], result[i+1]+1);
            }
        }
​
        int count = 0;
        for(int i=0; i&lt;result.size(); i++){
            count += result[i];
        }
​
        return count;
    }
};</pre> 
<h4>7. LeetCode 406. 根据身高重建队列</h4> 
<p>题目</p> 
<p>思路</p> 
<p>方法一（vector插入元素）</p> 
<ol><li> <p>由于身高较小的人对身高较高的人参数无影响，则将数组按照身高从高到低进行排序，若身高相等则参数二较小的在前面；</p> </li><li> <p>按照数组从左向右遍历，设置vector结果数组，依次将每个人按照第二参数添加到vector数组；</p> </li></ol> 
<p>方法二（list插入元素）（省时）</p> 
<ol><li> <p>思路与方法一相同，唯一不同在于设置list结果链表；</p> </li><li> <p>由于使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p> <p>所以使用vector（动态数组）来insert，是费时的，因此使用链表速度更快；</p> </li></ol> 
<p>代码</p> 
<p>方法一（vector插入元素）</p> 
<pre>class Solution {
private:
    static bool mycompare(vector&lt;int&gt;a, vector&lt;int&gt;b){
        if(a[0] == b[0])
            return a[1]&lt;b[1];
        return a[0]&gt;b[0];
    }
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) {
        sort(people.begin(), people.end(), mycompare);
        vector&lt;vector&lt;int&gt;&gt;queue;
        for(int i=0; i&lt;people.size(); i++){
            queue.insert(queue.begin()+people[i][1], people[i]);
        }
        return queue;
    }
};</pre> 
<p>方法二（list插入元素）</p> 
<pre>class Solution {
private:
    static bool mycompare(vector&lt;int&gt;a, vector&lt;int&gt;b){
        if(a[0] == b[0])
            return a[1]&lt;b[1];
        return a[0]&gt;b[0];
    }
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) {
        sort(people.begin(), people.end(), mycompare);
        list&lt;vector&lt;int&gt;&gt;queue;
        for(int i=0; i&lt;people.size(); i++){
            list&lt;vector&lt;int&gt;&gt;::iterator it = queue.begin();
            for(int j=0; j&lt;people[i][1]; j++){
                it++;
            }
            queue.insert(it, people[i]);
        }
        vector&lt;vector&lt;int&gt;&gt;result(queue.begin(), queue.end());
        return result;
    }
};</pre> 
<h4>8. LeetCode 452. 用最少数量的箭引爆气球</h4> 
<p>题目</p> 
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p> 
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p> 
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>将所有气球按照左边界从小到大进行排序，从左向右遍历数组，记录（保证本次射箭开始后至今所有气球均被引爆情况）射箭最大右边界；</p> </li><li> <p>若遍历至气球左边界大于射箭右边界，则需要增加射箭次数，并更新射箭最大右边界；</p> </li><li> <p>若遍历至气球右边界小于射箭右边界，为保证该气球被引爆，则需更改射箭右边界为该气球右边界；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
private:
    static bool mycompare(const vector&lt;int&gt;&amp;a, const vector&lt;int&gt;&amp;b){
        return a[0]&lt;b[0];
    }
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) {
        if(points.size() ==1 )
            return 1;
        sort(points.begin(), points.end(), mycompare);
        int result = 1;
        for(int i=1; i&lt;points.size(); i++){
            if(points[i][0] &gt; points[i-1][1]){
                result++;
            }
            else{
                points[i][1] = min(points[i-1][1], points[i][1]);
            }
        }
        return result;
    }
};</pre> 
<h4>9. LeetCode 435. 无重叠区间</h4> 
<p>题目</p> 
<p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<p>方法一（记录不交叉区间个数）</p> 
<ol><li> <p>由于最右边界越小，为其它区间留下的空间越大，同时存在的区间数越多；</p> </li><li> <p>对区间集合按照右边界从小到大进行排序；</p> </li><li> <p>利用当前不交叉最右边界判断后面区间是否与前面区间重叠，并记录不交叉区间个数，同时更新最右边界；</p> </li><li> <p>用区间总数减去不交叉区间个数即为所求；</p> </li></ol> 
<p>方法二（记录交叉区间个数）</p> 
<ol><li> <p>将区间按照左边界从小到大进行排序，若左边界相等，则右边界较小的在前面；</p> </li><li> <p>记录目前不交叉区间最右边界，若遍历当前区间右边界小于不交叉最右边界，则交叉区间个数加1，并且更新不交叉区间最右边界；</p> </li><li> <p>若遍历当前区间左边界小于不交叉最右边界，则交叉区间个数加1；</p> </li><li> <p>否则其他情况就为遍历当前区间左边界大于等于不交叉最右边界，则更新不交叉最右边界；</p> </li></ol> 
<p>代码</p> 
<p>方法一</p> 
<pre>class Solution {
private:
    static bool mycompare(const vector&lt;int&gt;&amp;a, const vector&lt;int&gt;&amp;b){
        return a[1]&lt;b[1];
    }
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.size() == 1)
            return 0;
        sort(intervals.begin(), intervals.end(), mycompare);
        int count = 1;// 用于记录不交叉集合个数
        int pre_end = intervals[0][1];
        for(int i=0; i&lt;intervals.size(); i++){
            if(pre_end &lt;= intervals[i][0]){
                count++;
                pre_end = intervals[i][1];
            }
        }
        return intervals.size() - count;
    }
};</pre> 
<p>方法二</p> 
<pre>class Solution {
private:
    static bool mycompare(const vector&lt;int&gt;&amp;a, const vector&lt;int&gt;&amp;b){
        if(a[0] == b[0]){
            return a[1]&lt;b[1];
        }
        return a[0]&lt;b[0];
    }
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.size() == 1)
            return 0;
        int result = 0, pre_end;
        sort(intervals.begin(), intervals.end(), mycompare);
        pre_end = intervals[0][1];
        for(int i=1; i&lt;intervals.size(); i++){
            if(intervals[i][1]&lt; pre_end){
                result++;
                pre_end = intervals[i][1];
            }
            else if(intervals[i][0] &lt; pre_end){
                result++;
            }
            else{
                pre_end = intervals[i][1];
            }
        }
        return result;
    }
};</pre> 
<h4>10. LeetCode 763. 划分字母区间</h4> 
<p>题目</p> 
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p> 
<p>思路</p> 
<ol><li> <p>遍历字符串，记录每个字母最后出现位置；</p> </li><li> <p>设置begin用于记录每个段的起始下标，end用于记录每个段中各字母最后出现的最右下标；</p> </li><li> <p>重新遍历字符串，不断更新end使其为该段中字母最后出现下标，直至遍历下标到达end则完成一段的分割，记录段中字符个数，继续循环；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    vector&lt;int&gt; partitionLabels(string s) {
       int begin = 0, end;
       vector&lt;int&gt;result;
       vector&lt;int&gt;array(26, 0);
       for(int i=0; i&lt;s.size(); i++){
           array[s[i]-'a'] = max(array[s[i]-'a'], i);
       }
        end = array[s[0]-'a'];
       for(int i=0; i&lt;s.size(); i++){
            end = max(end, array[s[i]-'a']);
           if(i == end){
               result.push_back(end-begin+1);
               begin = i+1;
           }
       }
       return result;
    }
};</pre> 
<h4>11. LeetCode 738. 单调递增的数字</h4> 
<p>题目</p> 
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。</p> 
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/monotone-increasing-digits" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>设置count用于记录循环层数，flag用于记录最左面不满足相邻位数字时循环层数，temp_n用于记录最左面不满足相邻位数字时左边剩余数字，low用于记录相邻位较低位，high用于记录相邻位较高位；</p> </li><li> <p>整体相当于对n从右向左按位比较，当不满足时记录循环层数flag及左边剩余数字temp_n，至循环结束就可以找到最左面不满足条件的位置；</p> </li><li> <p>利用temp_n与flag将temp_n重新扩充至原来位数，减一后即为不满足单调递增的结果；</p> </li><li> <p>若flag为初始值0，则题目所给数字n满足单调递增，同时temp_n仍为初始值n则可以直接返回temp_n;</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        int count = 0, flag=0, temp_n = n, low, high;
        while(n){
            low = n%10;
            n = n/10;
            high = n%10;
            count++;
            if(low &lt; high){
                flag = count;
                temp_n = n;
                n--;
            }
        }
        for(int i=0; i&lt;flag; i++){
            temp_n*=10;
        }
        return flag?temp_n-1:temp_n;
    }
};</pre> 
<h4>12. LeetCode 714. 买卖股票的最佳时机含手续费</h4> 
<p>题目</p> 
<p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p> 
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p> 
<p>返回获得利润的最大值。</p> 
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p> 
<p></p> 
<p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" rel="nofollow" title="力扣">力扣</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<ol><li> <p>设置一个买入的最低票价min，遍历股票价格数组，若股票价格小于min则更新min；</p> </li><li> <p>若股票价格大于等于min，但小于等于min+fee，则此时卖出不获利，继续循环；</p> </li><li> <p>若股票价格大于min+fee，此时可以获利，增加获利结果，但并不确定在此时卖出，更改min为该天股票价-fee，若后面出现比该min小，则确定在此次卖出，若后面出现比min+fee大的股票价格，则此次不卖出；</p> </li></ol> 
<p>代码</p> 
<pre>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {
        int min = prices[0];
        int result = 0;
        for(int i=1; i&lt;prices.size(); i++){ 
            if(prices[i] &lt; min){    //用于寻找股票买入点
                min = prices[i];
            }
            else if(prices[i]&gt;=min &amp;&amp; prices[i]&lt;=min+fee){    //抛弃无法获利点
                continue;
            }
            else{    //尝试在该点卖出股票，若后面出现新的股票买入点时则确定在该点卖出股票，否则若仍然该分支则为不在该点卖出股票；
                result += prices[i] - min -fee;
                min = prices[i] - fee;   //用于后面卖出股票时，抵消多用的手续费
                                        //此外，min用于后面寻找买入点，只有比该值小的股票价格才有可能获利
            }
        }
        return result;
    }
};</pre> 
<h4>13. LeetCode 968. 监控二叉树</h4> 
<p>题目</p> 
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p> 
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p> 
<p>计算监控树的所有节点所需的最小摄像头数量。</p> 
<p>思路</p> 
<ol><li> <p>若使监控树所需最小摄像头数，则将每个叶子节点的父节点设置为摄像头；</p> </li><li> <p>构造travel函数用于返回遍历节点的状态，返回0表示未覆盖，返回1表示覆盖，返回2表示摄像头；</p> </li><li> <p>当遍历一个节点的左右节点都覆盖时，则返回0表示该节点没有必要安装摄像头，可由父节点设置摄像头将该节点覆盖；</p> </li><li> <p>当遍历一个节点的左右节点存在未覆盖时，则返回2表示设置摄像头，只有这样才能将子节点覆盖；</p> </li><li> <p>当遍历一个节点的左右节点存在摄像头时，则返回1表示覆盖，子节点的摄像头将本节点覆盖；</p> </li></ol> 
<p>代码</p> 
<pre>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int result;
    //travel返回值为0表示未覆盖
    //返回1表示覆盖
    //返回2表示摄像头
    int travel(TreeNode* node){
        if(!node)return 1;
        int left = travel(node-&gt;left);
        int right = travel(node-&gt;right);
        if(left==1 &amp;&amp; right==1){
            return 0;
        }
        else if(left==0 || right==0){
            result++;
            return 2;
        }
        else return 1;
        // else if(left==2 || right==2){
        //     return 1;
        // }
    }
public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        if(!root){
            return result;
        }
        if(travel(root) == 0){
            result++;
        }
        return result;
    }
};</pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4bf32cd398fb3de1eab66a2354a071fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Autoware 1.12学习整理--03--NDT点云定位</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a776993dcc1dc85af618a0a42f9fd90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CompletableFuture 使用及应用场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>