<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis源码详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis源码详解" />
<meta property="og:description" content="Mybatis源码详解 Mybatis相关全览一、JDBC与Mybatis对比JDBC调用Mybatis调用两者对比 二、Mybatis资源加载数据源获取SqlSessionFactoryBuilder.buildXMLConfigBuilder.parseXMLConfigBuilder.environmentsElement SQL语句获取1.入口2.两种方式3.XML方式获取SQL3.1 XMLMapperBuilder.parse()3.2 XMLMapperBuilder.configurationElement3.4 XMLMapperBuilder.buildStatementFromContext3.5 XMLStatementBuilder.parseStatementNode3.6 MapperBuilderAssistant.addMappedStatement 4.注解的方式获取SQL4.1 MapperRegistry.addMapper4.2 MapperAnnotationBuilder.parse4.3 MapperAnnotationBuilder.parseStatement 5.最终的SQL处理方法XMLLanguageDriver.createSqlSource动/静SQL判断静态SQL处理 6.如果两种配置方式我都配了会怎样？先走Xml解析，后走注解的方式先走注解的方式，后走Xml的解析 Mapper代理对象获取命名空间加载入口包/类名加载入口 总结 三、Mybatis语句执行1.代理对象的生成2.代理对象的执行方法3.方法的执行4.查询一条为例5.执行器执行5.1 获取StatementHandler5.2 获取连接并获取SQL5.2.1 预处理Statement5.2.2 SQL传参处理 5.3 执行并处理返回结果 6.总结 四、总结核心部件遗漏的知识点 本文用的是3.5.10版本
源码地址：https://github.com/mybatis/mybatis-3/releases
文档地址：https://mybatis.org/mybatis-3/zh/sqlmap-xml.html
环境的搭建本文不做阐述了，文档里面有，本文适用已经对Mybatis使用有一定了解的人阅读！
Mybatis相关全览 一. Mybatis源码详解
二. Mybatis二级缓存详解
三. Mybatis三大执行器介绍
四. Mybatis拦截器源码详解
一、JDBC与Mybatis对比 我们先看看Mybatis调用Mysql和JDBC调用Mysql有什么区别？这样就知道Mybatis帮我们做了哪些事了
JDBC调用 加载驱动后，先获取连接(数据源)获取操作对象(预编译)传参处理执行返回值处理 Connection connection =null; try { // 加载驱动 Class.forName(&#34;com.mysql.cj.jdbc.Driver&#34;); //1.获取连接 数据源 connection = DriverManager.getConnection(url, user, password); //2.获取操作对象 PreparedStatement preparedStatement = connection.prepareStatement(&#34;select * from test_user where id=?&#34;); //3.传参处理 preparedStatement." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/68135f11b6421d0bfd3e6d269816858a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T22:40:23+08:00" />
<meta property="article:modified_time" content="2022-11-17T22:40:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis源码详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Mybatis源码详解</h4> 
 <ul><li><a href="#Mybatis_7" rel="nofollow">Mybatis相关全览</a></li><li><a href="#JDBCMybatis_14" rel="nofollow">一、JDBC与Mybatis对比</a></li><li><ul><li><a href="#JDBC_18" rel="nofollow">JDBC调用</a></li><li><a href="#Mybatis_58" rel="nofollow">Mybatis调用</a></li><li><a href="#_88" rel="nofollow">两者对比</a></li></ul> 
  </li><li><a href="#Mybatis_112" rel="nofollow">二、Mybatis资源加载</a></li><li><ul><li><a href="#_119" rel="nofollow">数据源获取</a></li><li><ul><li><a href="#SqlSessionFactoryBuilderbuild_125" rel="nofollow">SqlSessionFactoryBuilder.build</a></li><li><a href="#XMLConfigBuilderparse_130" rel="nofollow">XMLConfigBuilder.parse</a></li><li><a href="#XMLConfigBuilderenvironmentsElement_136" rel="nofollow">XMLConfigBuilder.environmentsElement</a></li></ul> 
   </li><li><a href="#SQL_145" rel="nofollow">SQL语句获取</a></li><li><ul><li><a href="#1_147" rel="nofollow">1.入口</a></li><li><a href="#2_156" rel="nofollow">2.两种方式</a></li><li><a href="#3XMLSQL_182" rel="nofollow">3.XML方式获取SQL</a></li><li><ul><li><a href="#31_XMLMapperBuilderparse_186" rel="nofollow">3.1 XMLMapperBuilder.parse()</a></li><li><a href="#32_XMLMapperBuilderconfigurationElement_191" rel="nofollow">3.2 XMLMapperBuilder.configurationElement</a></li><li><a href="#34_XMLMapperBuilderbuildStatementFromContext_198" rel="nofollow">3.4 XMLMapperBuilder.buildStatementFromContext</a></li><li><a href="#35_XMLStatementBuilderparseStatementNode_204" rel="nofollow">3.5 XMLStatementBuilder.parseStatementNode</a></li><li><a href="#36_MapperBuilderAssistantaddMappedStatement_223" rel="nofollow">3.6 MapperBuilderAssistant.addMappedStatement</a></li></ul> 
    </li><li><a href="#4SQL_230" rel="nofollow">4.注解的方式获取SQL</a></li><li><ul><li><a href="#41_MapperRegistryaddMapper_237" rel="nofollow">4.1 MapperRegistry.addMapper</a></li><li><a href="#42_MapperAnnotationBuilderparse_244" rel="nofollow">4.2 MapperAnnotationBuilder.parse</a></li><li><a href="#43_MapperAnnotationBuilderparseStatement_251" rel="nofollow">4.3 MapperAnnotationBuilder.parseStatement</a></li></ul> 
    </li><li><a href="#5SQL_267" rel="nofollow">5.最终的SQL处理方法</a></li><li><ul><li><a href="#XMLLanguageDrivercreateSqlSource_287" rel="nofollow">XMLLanguageDriver.createSqlSource</a></li><li><a href="#SQL_296" rel="nofollow">动/静SQL判断</a></li><li><a href="#SQL_309" rel="nofollow">静态SQL处理</a></li></ul> 
    </li><li><a href="#6_329" rel="nofollow">6.如果两种配置方式我都配了会怎样？</a></li><li><ul><li><a href="#Xml_331" rel="nofollow">先走Xml解析，后走注解的方式</a></li><li><a href="#Xml_344" rel="nofollow">先走注解的方式，后走Xml的解析</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Mapper_359" rel="nofollow">Mapper代理对象获取</a></li><li><ul><li><a href="#_366" rel="nofollow">命名空间加载入口</a></li><li><a href="#_380" rel="nofollow">包/类名加载入口</a></li></ul> 
   </li><li><a href="#_396" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#Mybatis_407" rel="nofollow">三、Mybatis语句执行</a></li><li><ul><li><a href="#1_414" rel="nofollow">1.代理对象的生成</a></li><li><a href="#2_428" rel="nofollow">2.代理对象的执行方法</a></li><li><a href="#3_442" rel="nofollow">3.方法的执行</a></li><li><a href="#4_451" rel="nofollow">4.查询一条为例</a></li><li><a href="#5_467" rel="nofollow">5.执行器执行</a></li><li><ul><li><a href="#51_StatementHandler_484" rel="nofollow">5.1 获取StatementHandler</a></li><li><a href="#52_SQL_500" rel="nofollow">5.2 获取连接并获取SQL</a></li><li><ul><li><a href="#521_Statement_511" rel="nofollow">5.2.1 预处理Statement</a></li><li><a href="#522_SQL_527" rel="nofollow">5.2.2 SQL传参处理</a></li></ul> 
    </li><li><a href="#53__548" rel="nofollow">5.3 执行并处理返回结果</a></li></ul> 
   </li><li><a href="#6_569" rel="nofollow">6.总结</a></li></ul> 
  </li><li><a href="#_589" rel="nofollow">四、总结</a></li><li><ul><li><a href="#_591" rel="nofollow">核心部件</a></li><li><a href="#_609" rel="nofollow">遗漏的知识点</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>本文用的是3.5.10版本<br> 源码地址：<a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a><br> 文档地址：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" rel="nofollow">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p> 
</blockquote> 
<p><strong>环境的搭建本文不做阐述了，文档里面有，本文适用已经对Mybatis使用有一定了解的人阅读！</strong></p> 
<h2><a id="Mybatis_7"></a>Mybatis相关全览</h2> 
<p>一. <a href="https://blog.csdn.net/weixin_44102992/article/details/127893787?spm=1001.2014.3001.5501">Mybatis源码详解</a><br> 二. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913052?spm=1001.2014.3001.5501">Mybatis二级缓存详解</a><br> 三. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913263?spm=1001.2014.3001.5501">Mybatis三大执行器介绍</a><br> 四. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913360?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127913360%22%2C%22source%22%3A%22weixin_44102992%22%7D">Mybatis拦截器源码详解</a></p> 
<h2><a id="JDBCMybatis_14"></a>一、JDBC与Mybatis对比</h2> 
<p>我们先看看Mybatis调用Mysql和JDBC调用Mysql有什么区别？这样就知道Mybatis帮我们做了哪些事了</p> 
<h3><a id="JDBC_18"></a>JDBC调用</h3> 
<ol><li>加载驱动后，先获取连接(数据源)</li><li>获取操作对象(预编译)</li><li>传参处理</li><li>执行</li><li>返回值处理</li></ol> 
<pre><code class="prism language-Java">Connection connection =null;
    try {
      // 加载驱动
      Class.forName("com.mysql.cj.jdbc.Driver");
      //1.获取连接 数据源
      connection = DriverManager.getConnection(url, user, password);
      //2.获取操作对象
      PreparedStatement preparedStatement = connection.prepareStatement("select * from test_user where id=?");
      //3.传参处理
      preparedStatement.setInt(1,1);
      //4.执行
      ResultSet resultSet = preparedStatement.executeQuery();
      //5.返回值处理
      while (resultSet.next()){
        TestVO testVO = new TestVO(
          resultSet.getInt("id"),
          resultSet.getString("name"),
          resultSet.getString("team"),
          resultSet.getInt("grade")
        );
        System.out.println(JSONObject.toJSON(testVO));
      }
    } catch (Exception e) {
      e.printStackTrace();
    }finally {
      if(connection!=null){
        connection.close();
      }
    }
</code></pre> 
<h3><a id="Mybatis_58"></a>Mybatis调用</h3> 
<p>加载驱动就不说了，总的分几步：</p> 
<ol><li>加载配置文件把资源放入工厂</li><li>从工厂获取一个会话（会话就可以理解成是个连接）</li><li>从会话里面获取动态代理的Mapper对象执行对应方法就可以了</li></ol> 
<pre><code class="prism language-Java">    // 获取数据源  获取SQL语句  获取Mapper  传参处理   执行   返回值处理
    try {
      String resource = "resources/mybatis-config.xml";
      // 通过classLoader获取到配置文件
      InputStream inputStream = Resources.getResourceAsStream(resource);
      SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
      // 获取会话工厂
      SqlSessionFactory sqlSessionFactory = builder.build(inputStream);
      // 获取一个会话
      SqlSession sqlSession = sqlSessionFactory.openSession();

      // 动态代理方式
      TestMapper mapper = sqlSession.getMapper(TestMapper.class);
      List&lt;TestVO&gt; dataList = mapper.findDataList(1,"张三");
      System.out.println("通过动态代理返回结果" + JSONObject.toJSON(dataList));
      sqlSession.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
</code></pre> 
<h3><a id="_88"></a>两者对比</h3> 
<p><strong>首先要达成一个共识，Mybatis最终调用Mysql的方式和JDBC是不是一样的？</strong></p> 
<p>是一样的，所以Mybatis只是对JDBC做了一层封装，帮我们简化了很多操作，比如：</p> 
<ol><li>SQL传参的自动适配处理（JDBC传参还要传参与SQL参数索引对应）</li><li>返回值处理自动映射处理（JDBC返回值还要自己与实体类映射吧）</li></ol> 
<p>最主要就这两个吧，SQL还是需要我们自己写，连接、预编译、执行器这些JDBC都有吧！</p> 
<p><strong>所以为什么Mybatis被称为半ORM框架这些懂了吧？就是SQL还需要自己写，传参和返回值处理它帮你搞定了</strong></p> 
<p><strong>所以我们总结一下Mybatis做了什么？怎么帮我们做的封装，接下来分步骤一步一步看：</strong></p> 
<ul><li>一、资源的获取 
  <ol><li>数据源获取</li><li>SQL语句获取</li><li>Mapper代理对象获取</li></ol> </li><li>二、执行 
  <ol><li>传参处理</li><li>语句执行</li><li>返回值处理</li></ol> </li></ul> 
<h2><a id="Mybatis_112"></a>二、Mybatis资源加载</h2> 
<p>资源的获取就是XML文件的解析，我们再回顾一下Mybatis的代码，是不是加载了一份资源文件</p> 
<p><img src="https://images2.imgbox.com/99/b9/0bjyrteh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_119"></a>数据源获取</h3> 
<p>数据源就是XML配置文件里面environments标签部分，我们需要解析并加载，如下图所示：<br> <img src="https://images2.imgbox.com/94/52/pOSF3AtM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="SqlSessionFactoryBuilderbuild_125"></a>SqlSessionFactoryBuilder.build</h4> 
<p><img src="https://images2.imgbox.com/1b/73/oUpAn1Qv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="XMLConfigBuilderparse_130"></a>XMLConfigBuilder.parse</h4> 
<p>找到我们需要解析的environments标签，就是数据源的配置解析<br> <img src="https://images2.imgbox.com/f6/af/WGY5k8xV_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="XMLConfigBuilderenvironmentsElement_136"></a>XMLConfigBuilder.environmentsElement</h4> 
<p>还通过了遍历获取，说明<strong>数据源可以有多个</strong>，然后数据源被放到了<strong>Configuration</strong>里面，到这数据源就解析完成了</p> 
<p>（这个Configuration记住哈，资源的解析完了后都是放到这里面的，很重要）</p> 
<p><img src="https://images2.imgbox.com/f7/c0/QyKO3IH2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="SQL_145"></a>SQL语句获取</h3> 
<h4><a id="1_147"></a>1.入口</h4> 
<p><strong>XMLConfigBuilder.parse</strong></p> 
<p>和上面一样同样在解析XML配置文件里面</p> 
<p><img src="https://images2.imgbox.com/63/68/NwI2OaHv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_156"></a>2.两种方式</h4> 
<p>我们看看配置文件里面mappers标签是怎么配置的，官方给出了四种配置方式：</p> 
<ol><li>Mapper.xml文件的相对路径引用（解析XML获取SQL）</li><li>Mapper.xml文件的绝对路径引用（解析XML获取SQL）</li><li>Mapper.java类文件的完全限定类名（解析注解获取SQL）</li><li>Mapper.java类文件所在的包路径（解析注解获取SQL）</li></ol> 
<p><img src="https://images2.imgbox.com/91/2b/8MiEQgun_o.png" alt="在这里插入图片描述"></p> 
<p>既然配置有4种配置方法，那对应的解析的时候也有4种解析方法：</p> 
<p><strong>XMLConfigBuilder.mapperElement</strong></p> 
<p><img src="https://images2.imgbox.com/37/65/hhbkNFXZ_o.png" alt="在这里插入图片描述"></p> 
<p>所以我们要知道SQL语句有两个地方可以获取（应该都知道霍，SQL本身就可以写两个地方）</p> 
<ol><li>加载XML资源文件获取</li><li>加载Mapper接口文件通过注解的形式获取</li></ol> 
<p><strong>所以接下来我们要分两种方式来解析！</strong></p> 
<h4><a id="3XMLSQL_182"></a>3.XML方式获取SQL</h4> 
<p>从入口处看，XML方式都会调用</p> 
<h5><a id="31_XMLMapperBuilderparse_186"></a>3.1 XMLMapperBuilder.parse()</h5> 
<p><img src="https://images2.imgbox.com/cc/93/GIGpC27Y_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="32_XMLMapperBuilderconfigurationElement_191"></a>3.2 XMLMapperBuilder.configurationElement</h5> 
<p>有很多标签就不一一看了，直接看增删改查的标签</p> 
<p><img src="https://images2.imgbox.com/4e/ac/UjUleo4D_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="34_XMLMapperBuilderbuildStatementFromContext_198"></a>3.4 XMLMapperBuilder.buildStatementFromContext</h5> 
<p>遍历XML节点一个一个获取<br> <img src="https://images2.imgbox.com/ed/37/xzWy6SUW_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="35_XMLStatementBuilderparseStatementNode_204"></a>3.5 XMLStatementBuilder.parseStatementNode</h5> 
<p>这个方法有点长我们分三个截图，分别代表三个关键的点，一个一个来</p> 
<p><strong>第一段：</strong> 这个是干嘛的，我们后面说（判断重复加载）</p> 
<p><img src="https://images2.imgbox.com/38/a4/Mf7rGokS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第二段：<strong>这就是获取SQL资源的地方，我们一样后面说，因为通过注解的方式解析的时候也会调用这个方法，后面一起说，先记着是</strong>LanguageDriver.createSqlSource</strong>方法</p> 
<p><img src="https://images2.imgbox.com/3c/81/EKLW871k_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第三段：<strong>这个可以是最后的一步了，我们的数据源被加载放到了</strong>Configuration</strong>里面，所以SQL相关的也不例外要放入<strong>Configuration</strong>中</p> 
<p><img src="https://images2.imgbox.com/f9/20/YQIZBsBW_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="36_MapperBuilderAssistantaddMappedStatement_223"></a>3.6 MapperBuilderAssistant.addMappedStatement</h5> 
<p>最终被封装成了<strong>MappedStatement</strong>放入了<strong>Configuration</strong>中</p> 
<p><img src="https://images2.imgbox.com/f8/83/hgLa0u4y_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4SQL_230"></a>4.注解的方式获取SQL</h4> 
<p>我们一样从入口开始看</p> 
<p><img src="https://images2.imgbox.com/83/d9/4p3KzIEu_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="41_MapperRegistryaddMapper_237"></a>4.1 MapperRegistry.addMapper</h5> 
<p>两个入口一直往下都会到这个方法，中间的就不看了，没啥好说的</p> 
<p><img src="https://images2.imgbox.com/23/01/Q91IJzGd_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="42_MapperAnnotationBuilderparse_244"></a>4.2 MapperAnnotationBuilder.parse</h5> 
<p>中间要做什么处理，搞什么鬼的一律不理，我们直奔主题</p> 
<p><img src="https://images2.imgbox.com/99/44/me364z7m_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="43_MapperAnnotationBuilderparseStatement_251"></a>4.3 MapperAnnotationBuilder.parseStatement</h5> 
<p>这个方法有点长我们同样分几段</p> 
<p><strong>第一段：<strong>第一步获取SQL资源，这个buildSource一样会到我们上面说的</strong>LanguageDriver.createSqlSource</strong>方法，后面一起说</p> 
<p><img src="https://images2.imgbox.com/ea/64/B1TasORm_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d7/09/HNLCuSIk_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第二段：<strong>是不是有点熟悉又是</strong>MapperBuilderAssistant.addMappedStatement</strong>方法，和上面一样的最后被封装成<strong>MappedStatement</strong>放入了<strong>Configuration</strong>中（和上面一样就不说了）</p> 
<p><img src="https://images2.imgbox.com/4c/22/juMUGVaG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5SQL_267"></a>5.最终的SQL处理方法</h4> 
<p>我们解析XML的时候或者解析注解的时候难道拿不到SQL吗？还需要单独去解析获取SQL？</p> 
<blockquote> 
 <p>这里的SQL资源获取并不代表是获取XML或者注解里面的SQL，恰恰是对里面的SQL处理一次，我们最终需要的SQL是像JDBC里面那样参数是 "?"的SQL格式，所以<strong>这里的处理是将XML或者注解里面SQL中的占位符处理掉，并建立占位符下标索引和传参参数的映射</strong></p> 
</blockquote> 
<p><strong>如下图所示：</strong></p> 
<p>处理后SQL已经变成了最后执行所需的样子，同时产生了占位符的下标索引和传参的映射关系的<strong>ParameterMapping</strong>对象</p> 
<p><img src="https://images2.imgbox.com/29/b6/WFRWmc8j_o.png" alt="在这里插入图片描述"></p> 
<p>所以需要处理两种情况：</p> 
<ul><li><strong>带${}占位符</strong>：处理方式是直接用传参直接替换</li><li><strong>带#{}占位符</strong>：处理方式是需要将占位符变成 “？”，然后再用传参顺序替换 “？”</li></ul> 
<p>上面我们说到<strong>createSqlSource</strong>方法，实际是在<strong>XMLLanguageDriver</strong>中，存在两个重载方法</p> 
<h5><a id="XMLLanguageDrivercreateSqlSource_287"></a>XMLLanguageDriver.createSqlSource</h5> 
<p>不管是注解形式的SQL还是XML形式的SQL最终都会到这，两者解析完最终都会判断SQL是静态SQL还是动态SQL，有不同的处理方法</p> 
<ul><li><strong>静态SQL</strong>：SQL中不存在${}占位符，采用RawSqlSource类处理</li><li><strong>动态SQL</strong>：SQL中存在${}占位符或者像XML中<strong>if</strong>动态判断标签，采用DynamicSqlSource类处理<br> <img src="https://images2.imgbox.com/96/6f/bnB8HIxR_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="SQL_296"></a>动/静SQL判断</h5> 
<p><strong>TextSqlNode.isDynamic()</strong></p> 
<p>该方法中会调用GenericTokenParser类进行对SQL中"${}"占位符的处理，而处理方法正是DynamicCheckerTokenParser.handleToken方法，该方法中将标志位设置为了True，而这种动态的SQL会在最终执行的时候才去处理(用传参替换)</p> 
<p>动态SQL一共有两种，<strong>一是${}占位符，二是XML中存在IF标签等判断语句</strong>(这种大家可以从XML入口去看)<br> <img src="https://images2.imgbox.com/92/44/3GnPLUKI_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/22/59/g5i9640W_o.png" alt=""></p> 
<h5><a id="SQL_309"></a>静态SQL处理</h5> 
<p><strong>RawSqlSource</strong></p> 
<p>静态的SQL会在该类中的构造方法中直接处理了</p> 
<p><img src="https://images2.imgbox.com/28/3f/FBiGsdvG_o.png" alt="在这里插入图片描述"></p> 
<p><strong>SqlSourceBuilder.parse()</strong></p> 
<p>相比于动态SQL，处理的Handler换了，看替换的本文变成了"?"，同时还加上了下标的映射关系</p> 
<blockquote> 
 <p>GenericTokenParser这个是占位符的处理类，就等于是一个工具类，这里就不贴了，有兴趣的可以去看看，实际开发说不定也能用得上哦</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b6/9e/1O0UfkBi_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3c/97/v6v2M9TY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6_329"></a>6.如果两种配置方式我都配了会怎样？</h4> 
<h5><a id="Xml_331"></a>先走Xml解析，后走注解的方式</h5> 
<p><img src="https://images2.imgbox.com/32/de/8qzWJ9mg_o.png" alt="在这里插入图片描述"></p> 
<p>结果会报错，因为注解的方式后解析，而在注解的方式解析过程中并没有判断<strong>MappeStatement</strong>是否已经存在，此时会继续往<strong>Configuration</strong>中添加<strong>MappeStatement</strong>，而<strong>Configuration</strong>里面用的Map是自定义的<strong>StrictMap</strong>，put相同的key会报错</p> 
<p><img src="https://images2.imgbox.com/ea/02/bNgf8Oai_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/1e/85/ENLnxkIv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Xml_344"></a>先走注解的方式，后走Xml的解析</h5> 
<p><img src="https://images2.imgbox.com/8a/79/R84YtmwV_o.png" alt="在这里插入图片描述"></p> 
<p>无事发生，因为在xml解析过程中有判断<strong>MappeStatement</strong>是否已经存在</p> 
<p>（这就是我上面说截图第一段后面说的，至此坑已经填完）</p> 
<p><img src="https://images2.imgbox.com/92/53/qZY1bGer_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/95/2a/c2oY8DDA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Mapper_359"></a>Mapper代理对象获取</h3> 
<p>应该都知道Mapper的执行原理是动态代理，所以Mapper也需要加载变成代理对象，结合SQL的获取方式，Mapper加载也有两种</p> 
<ul><li><strong>XML方式加载</strong>：通过XML里面配置的命名空间获取Mapper对象</li><li><strong>注解方式加载</strong>：配置的是包名或者全类名所以直接直接获取Mapper对象</li></ul> 
<h4><a id="_366"></a>命名空间加载入口</h4> 
<p>就在XML解析的下面</p> 
<p><img src="https://images2.imgbox.com/8d/16/SNb4q8Ca_o.png" alt="在这里插入图片描述"></p> 
<p><strong>XMLMapperBuilder.bindMapperForNamespace()</strong></p> 
<p>会调用addMapper()这个方法</p> 
<p><img src="https://images2.imgbox.com/5d/f2/hHaXM7gd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_380"></a>包/类名加载入口</h4> 
<p>就在加载的时候，也会调用addMapper()方法，我们直接看这个方法</p> 
<p><img src="https://images2.imgbox.com/66/90/qWT1J1ob_o.png" alt="在这里插入图片描述"></p> 
<p><strong>MapperRegistry.addMapper()</strong></p> 
<p>先判断是否存在，不存在就直接加入到了knownMappers这个Map对象中，加入的是一个代理工厂</p> 
<p><strong>MapperProxyFactory</strong>，然后就没了，等着执行时调用</p> 
<p><img src="https://images2.imgbox.com/ec/f3/czd2Geal_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_396"></a>总结</h3> 
<ol><li>在配置文件加载过程中，加载了数据源、SQL资源、Mapper代理工厂</li><li>SQL分为动态SQL和静态SQL，静态SQL是在加载过程中就处理好了，动态SQL需要在执行时获取参数才能处理（带${}占位符或者IF等判断标签）</li><li>Mapper会生成其代理工厂保存在一个Map对象中</li><li>MappedStatement保存着所有SQL相关资源(SQL语句、参数映射关系等)</li><li>除了Mapper代理对象，其他资源都会放入<strong>Configuration</strong>中</li></ol> 
<p><img src="https://images2.imgbox.com/92/c1/PLrlEFSt_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Mybatis_407"></a>三、Mybatis语句执行</h2> 
<p><img src="https://images2.imgbox.com/f7/06/jywroMQe_o.png" alt="在这里插入图片描述"></p> 
<p>应该都知道，前面也说过获取的Mapper是一个代理对象，最后的执行是代理对象的执行方法，所以我们直接点进去看看代理对象的执行方法是什么，先看看代理对象如何生成的</p> 
<h3><a id="1_414"></a>1.代理对象的生成</h3> 
<p><strong>MapperRegistry.getMapper</strong></p> 
<blockquote> 
 <p>我们随着getMapper方法一路进来会找到该方法，一眼过去非常的眼熟是不是，先从Mapper集合取出代理工厂，然后用代理工厂去生成代理对象，这里的SqlSession是什么？就是<strong>DefaultSqlSession</strong>，里面就包含之前装载资源的<strong>Configuration</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/40/bd/vw1zd8w5_o.png" alt="在这里插入图片描述"></p> 
<p>采用的就是JDK的动态代理，所以这个MapperProxy很明显里面就有最终代理对象的处理方法了</p> 
<p><img src="https://images2.imgbox.com/7f/e6/wjByxmkj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_428"></a>2.代理对象的执行方法</h3> 
<p><strong>MapperProxy.invoke</strong></p> 
<p>很容易就找到了方法执行处，忽略掉一系列判断，我们直接找到最终的处理方法</p> 
<p><img src="https://images2.imgbox.com/6c/e7/AWnXstHS_o.png" alt="在这里插入图片描述"></p> 
<p>又采用了一个静态代理的方式调用了执行</p> 
<p><img src="https://images2.imgbox.com/42/84/Uqdn3poi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_442"></a>3.方法的执行</h3> 
<p><strong>MapperMethod.execute</strong></p> 
<p>到了这里是不是就顺眼多了，熟悉的增删改查，我们以查为例，查还分无返回值、查多条、查Map、查一条这些情况，我们就简单一点以差一条为例子走</p> 
<p><img src="https://images2.imgbox.com/e1/ec/K12iwkIc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_451"></a>4.查询一条为例</h3> 
<p><strong>DefaultSqlSession.selectOne</strong></p> 
<blockquote> 
 <p>进来这里你看看这个类下的方法，虽然是以查询一条为例，但是增删改查操作最终都会到这，而且你看看查询一条的时候实际也是查询的是list，最后只是返回了一条结果而已，下面那个报错异常相信大家也很熟悉吧</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/55/18/GiHz4R9I_o.png" alt="在这里插入图片描述"></p> 
<p><strong>DefaultSqlSession.selectList</strong></p> 
<blockquote> 
 <p>顺着上面下来，这里会先获取一个<strong>MappedStatement</strong>，这个是什么东西？还记得上面说的SQL资源获取吗？这里面就是SQL相关的所有资源，比如SQL语句、返回值、传参映射等等，所以这里的获取指的就是去获取现在要执行的方法对应的SQL资源（<strong>MappedStatement</strong>），通过这个方法的<strong>全路径类名+方法名称获取</strong>，然后再调用执行器执行查询！</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3d/bf/9rWYuOZu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_467"></a>5.执行器执行</h3> 
<p>执行这块涉及到两个知识点，<strong>一是Mybatis的二级缓存，二是Mybatis的三大执行器</strong></p> 
<p>这里我们先跳过这两个点，直接来看默认的执行器（<strong>SimpleExecutor</strong>）执行过程</p> 
<p><strong>SimpleExecutor.doQuery</strong></p> 
<p>这里分三步</p> 
<ol><li>获取具体的操作类，这里的操作类就类似于JDBC中的PreparedStatement</li><li>获取最后要执行的SQL（处理传参）、获取连接并设置相关参数（超时时间等）</li><li>执行并处理返回结果</li></ol> 
<p><img src="https://images2.imgbox.com/85/13/MKerFaWg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="51_StatementHandler_484"></a>5.1 获取StatementHandler</h4> 
<p><strong>Configuration.newStatementHandler</strong></p> 
<p>这里主要就是选择采用哪个<strong>StatementHandler</strong></p> 
<p><img src="https://images2.imgbox.com/8a/1c/JqHcnSQv_o.png" alt="在这里插入图片描述"></p> 
<p><strong>RoutingStatementHandler</strong>：</p> 
<p><strong>StatementHandler</strong>的选择是根据参数来的，这个参数在XML里面是可以配置的，默认是<strong>PreparedStatementHandler</strong></p> 
<p><img src="https://images2.imgbox.com/f2/ab/OiBWJ75m_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="52_SQL_500"></a>5.2 获取连接并获取SQL</h4> 
<p><strong>SimpleExecutor.prepareStatement</strong></p> 
<ol><li>先获取连接</li><li>预处理一下Statement（设置超时时间、获取SQL）</li><li>SQL传参处理</li></ol> 
<p><img src="https://images2.imgbox.com/c2/50/gocF7iE2_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="521_Statement_511"></a>5.2.1 预处理Statement</h5> 
<p><strong>BaseStatementHandler.prepare</strong></p> 
<p>获取连接就不看了，没啥看的，直接看看预处理，主要关注这个初始化</p> 
<p><img src="https://images2.imgbox.com/6a/f7/qpZ894ZQ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>PreparedStatementHandler.instantiateStatement</strong></p> 
<p>看这是不是跟JDBC里面第二步一模一样？现在就只差传参处理、执行、返回值处理了是不是？</p> 
<p><img src="https://images2.imgbox.com/9b/fc/AaTiZSQH_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="522_SQL_527"></a>5.2.2 SQL传参处理</h5> 
<p><strong>PreparedStatementHandler.parameterize</strong></p> 
<p><img src="https://images2.imgbox.com/5e/39/VU1oq5UQ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>DefaultParameterHandler.setParameters</strong></p> 
<blockquote> 
 <p>这个就是处理传参的，根据之前处理后的映射关系，找到对应类型的处理类处理参数，然后与JDBC类型映射，这整个过程都是自动完成的，所以这里的参数处理还需要所有类型的对应处理方式是不是，一旦处理方式没匹配上就会有问题对吧</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6a/fa/WwBoqWG3_o.png" alt="在这里插入图片描述"></p> 
<p><strong>TypeHandler</strong></p> 
<p>所以Mybatis里面列举了很多类型的处理方式，而且看方法，不仅处理参数，还处理返回值</p> 
<p><img src="https://images2.imgbox.com/72/73/kfkZ71gx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="53__548"></a>5.3 执行并处理返回结果</h4> 
<p><strong>PreparedStatementHandler.query</strong></p> 
<p><img src="https://images2.imgbox.com/6a/19/nnf57oRn_o.png" alt="在这里插入图片描述"></p> 
<p><strong>DefaultResultSetHandler.handleResultSets</strong></p> 
<p>获取了JAVA中与JDBC参数类型的映射关系、获取XML中的配置、然后遍历处理结果集</p> 
<p><img src="https://images2.imgbox.com/2b/3d/DdRS8t6j_o.png" alt="在这里插入图片描述"></p> 
<p><strong>ResultSetWrapper</strong></p> 
<p>JAVA中与JDBC参数类型的映射关系如下</p> 
<p><img src="https://images2.imgbox.com/31/60/djscAGC0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_569"></a>6.总结</h3> 
<p>以查询一条、<strong>SimpleExecutor</strong>执行器为例：</p> 
<ol><li>首先会获取Mapper代理对象</li><li>然后判断要执行的是增、删、改、查其中的哪种</li><li>然后选择执行器执行（默认<strong>SimpleExecutor</strong>）</li><li>然后选择操作处理类StatementHandler</li><li>获取连接、获取SQL</li><li>传参处理，然后执行，然后返回值处理</li></ol> 
<p><img src="https://images2.imgbox.com/9a/6e/DSwHtn49_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这里网上找了图，结构上更明了：</strong></p> 
<p><img src="https://images2.imgbox.com/36/1f/1mnFXHXO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_589"></a>四、总结</h2> 
<h3><a id="_591"></a>核心部件</h3> 
<p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p> 
<ul><li><strong>Configuration</strong>：初始化基础配置，比如MyBatis的别名等，一些重要的类型对象，如插件，映射器，ObjectFactory和typeHandler对象，MyBatis所有的配置信息都维持在Configuration对象之中。</li><li><strong>SqlSessionFactory</strong>：SqlSession工厂。</li><li><strong>SqlSession</strong>：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要的数据库增删改查功能。</li><li><strong>Executor：</strong> MyBatis的内部执行器，它负责调用StatementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外，它还处理二级缓存的操作。</li><li><strong>StatementHandler</strong>： MyBatis直接在数据库执行SQL脚本的对象。</li><li><strong>ParameterHandler</strong>： 负责将用户传递的参数转换成JDBC Statement所需要的参数。是MyBatis实现SQL入参设置的对象。</li><li><strong>ResultSetHandler</strong>： 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合。是MyBatis把ResultSet集合映射成POJO的接口对象。</li><li><strong>TypeHandler</strong>：负责Java数据类型和JDBC数据类型之间的映射和转换。</li><li><strong>MappedStatement</strong>： MappedStatement维护了SQL相关资源</li><li><strong>SqlSource</strong>：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回。</li><li><strong>BoundSql</strong>：表示动态生成的SQL语句以及相应的参数信息SqlSource ：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回。</li></ul> 
<h3><a id="_609"></a>遗漏的知识点</h3> 
<p>这三个可能有些人平时用的少，但都算是Mybatis提供的一些功能，后续单独拿出来说</p> 
<ol><li>Mybatis二级缓存</li><li>三大执行器</li><li>扩展功能之Mybatis拦截器</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee644aacd06aa32daf6b8255c6410d44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue过滤器的与Boot CDN的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a705b7360ed4f0c7df3254925c62e93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FPGA学习笔记(七): DSB调制解调的仿真</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>