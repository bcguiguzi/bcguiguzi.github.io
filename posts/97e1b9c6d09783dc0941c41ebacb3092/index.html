<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔记：从零开始一步步手撕高阶数据结构AVL树 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔记：从零开始一步步手撕高阶数据结构AVL树" />
<meta property="og:description" content="文章目录 高度平衡二叉搜索树实现一颗AVL树结点与树的描述——定义类AVL树的插入操作步骤1：按照二叉搜索树的方法插入结点步骤2：自底向上调整平衡因子步骤3：触发旋转操作（AVL树平衡的精髓）右单旋左单旋左右双旋右左双旋 验证AVL树是否平衡 参考文章 高度平衡二叉搜索树 二叉搜索树是一种特殊的树形数据结构，一般情况下，该树能够缩短查找的效率，但是它有个缺陷，在结点的插入或删除顺序较为特殊时结构会退化成链表，导致搜索、插入和删除等操作的时间复杂度从O(log n)退化到O(n)。
【二叉搜索树退化成链表的例子】
高度平衡二叉搜索树是针对二叉搜索树的缺陷所发明出来的一种改良结构。
高度平衡二叉搜索树常被称为 “ AVL树 ”，这主要是为了纪念发明它两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis，AVL是两位数学家的名字的缩写。
一颗AVL树或者是空树，或者是具有以下性质的二叉搜索树：
左右子树高度之差（简称为平衡因子）的绝对值不超过1。在这里平衡因子的求法定义为：右子树的高度 - 左子树的高度。结点的左右两棵子树也都是一棵平衡二叉树。 实现一颗AVL树 概念部分讲的差不多了，至于AVL树相较于二叉搜索树是如何保持平衡结构，就在接下来的实现过程中一步步讲解。
结点与树的描述——定义类 namespace ljh { template&lt;class K, class V&gt; struct AVLTreeNode { AVLTreeNode(const pair&lt;K, V&gt; kv) : _kv(kv) {} AVLTreeNode&lt;K, V&gt;* _parent = nullptr;	// A pointer to node&#39;s father AVLTreeNode&lt;K, V&gt;* _left = nullptr;	// A pointer to node&#39;s left child AVLTreeNode&lt;K, V&gt;* _right = nullptr;	// A pointer to node&#39;s right child int _bf = 0;	// balance factor pair&lt;K, V&gt; _kv;	// key-value }; template&lt;class K, class V&gt; class AVLTree { typedef AVLTreeNode&lt;K, V&gt; Node; public: // AVL树的操作方法 protected: Node* _root = nullptr; }; } 【说明】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/97e1b9c6d09783dc0941c41ebacb3092/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T18:50:14+08:00" />
<meta property="article:modified_time" content="2024-03-12T18:50:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔记：从零开始一步步手撕高阶数据结构AVL树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">高度平衡二叉搜索树</a></li><li><a href="#AVL_20" rel="nofollow">实现一颗AVL树</a></li><li><ul><li><a href="#_22" rel="nofollow">结点与树的描述——定义类</a></li><li><a href="#AVL_73" rel="nofollow">AVL树的插入操作</a></li><li><ul><li><a href="#1_75" rel="nofollow">步骤1：按照二叉搜索树的方法插入结点</a></li><li><a href="#2_131" rel="nofollow">步骤2：自底向上调整平衡因子</a></li><li><a href="#3AVL_186" rel="nofollow">步骤3：触发旋转操作（AVL树平衡的精髓）</a></li><li><ul><li><a href="#_190" rel="nofollow">右单旋</a></li><li><a href="#_264" rel="nofollow">左单旋</a></li><li><a href="#_336" rel="nofollow">左右双旋</a></li><li><a href="#_400" rel="nofollow">右左双旋</a></li></ul> 
   </li></ul> 
   </li><li><a href="#AVL_465" rel="nofollow">验证AVL树是否平衡</a></li></ul> 
  </li><li><a href="#_567" rel="nofollow">参考文章</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>高度平衡二叉搜索树</h2> 
<p><font color="black">二叉搜索树是一种特殊的树形数据结构，一般情况下，该树能够缩短查找的效率，但是它有个缺陷，在结点的插入或删除顺序较为特殊时结构会退化成链表，导致搜索、插入和删除等操作的时间复杂度从O(log n)退化到O(n)。</font></p> 
<p><font color="black">【二叉搜索树退化成链表的例子】</font><br> <img src="https://images2.imgbox.com/9f/57/9iM0wbaw_o.png" alt="在这里插入图片描述"></p> 
<p><font color="black">高度平衡二叉搜索树是针对二叉搜索树的缺陷所发明出来的一种改良结构。</font></p> 
<p><font color="black">高度平衡二叉搜索树常被称为 “ AVL树 ”，这主要是为了纪念发明它两位俄罗斯的数学家G.M.<strong>A</strong>delson-<strong>V</strong>elskii和E.M.<strong>L</strong>andis，AVL是两位数学家的名字的缩写。</font></p> 
<p><font color="black">一颗AVL树或者是空树，或者是具有以下性质的二叉搜索树：</font></p> 
<ul><li><font color="black">左右子树高度之差（简称为平衡因子）的绝对值不超过1。</font></li><li><font color="black">在这里平衡因子的求法定义为：右子树的高度 - 左子树的高度。</font></li><li><font color="black">结点的左右两棵子树也都是一棵平衡二叉树。</font></li></ul> 
<p><img src="https://images2.imgbox.com/22/86/T2TGXpAK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/29/11/69dnc9lF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/07/16/qqAPHJJ8_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="AVL_20"></a>实现一颗AVL树</h2> 
<p><font color="black">概念部分讲的差不多了，至于AVL树相较于二叉搜索树是如何保持平衡结构，就在接下来的实现过程中一步步讲解。</font></p> 
<h3><a id="_22"></a>结点与树的描述——定义类</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> ljh
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
	<span class="token keyword">struct</span> <span class="token class-name">AVLTreeNode</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">AVLTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> kv<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

		AVLTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>	<span class="token comment">// A pointer to node's father</span>
		AVLTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>		<span class="token comment">// A pointer to node's left child</span>
		AVLTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>	<span class="token comment">// A pointer to node's right child</span>
		<span class="token keyword">int</span> _bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">// balance factor</span>
		pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>		<span class="token comment">// key-value</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">AVLTree</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">typedef</span> AVLTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>

	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">// AVL树的操作方法</span>

	<span class="token keyword">protected</span><span class="token operator">:</span>
		Node<span class="token operator">*</span> _root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="black"><strong>【说明】</strong></font></p> 
<ol><li><font color="black"><strong>模板化设计：</strong></font> 
  <ul><li><font color="black">使用<code>template&lt;class K, class V&gt;</code>来定义<code>AVLTreeNode</code>和<code>AVLTree</code>，使得该数据结构能够处理任意类型的键（Key）和值（Value），提高了代码的复用性和灵活性。</font></li><li><font color="black"><code>K</code>代表键的类型，<code>V</code>代表值的类型。使用者可以根据自己的需求，在AVL树存储任何类型的键值对。</font></li></ul> </li><li><font color="black"><strong>AVLTreeNode类：</strong></font> 
  <ul><li><font color="black"><font color="black"><code>AVLTreeNode</code>结构体定义了AVL树中每个节点的结构，用<code>struct</code>定义是为了方便在树类访问。</font></font></li><li><font color="black"><code>_parent</code>指针：指向父节点，用于在<strong>旋转</strong>等操作中快速定位父节点（记住这里的旋转，这将是后面的重点）。</font></li><li><font color="black"><code>_left</code>和<code>_right</code>指针：分别指向左孩子和右孩子，是二叉树结构的基础。</font></li><li><font color="black"><code>_bf</code>（平衡因子）：存储节点的平衡因子，用于衡量树是否平衡。</font></li><li><font color="black"><code>_kv</code>：存储于结点中的键值对，其中<code>K</code>是键的类型，<code>V</code>是值的类型。 </font></li></ul> </li><li><font color="black"><strong>构造函数：</strong></font> 
  <ul><li><font color="black"><code>AVLTreeNode</code>的构造函数接收一个<code>pair&lt;K, V&gt;</code>对象，并初始化<code>_kv</code>成员变量。这样，当创建新节点时，可以方便地传入键值对。</font></li></ul> </li><li><font color="black"><strong>AVLTree类：</strong></font> 
  <ul><li><font color="black"><code>AVLTree</code>类代表整个AVL树结构。</font></li><li><font color="black"><code>typedef AVLTreeNode&lt;K, V&gt; Node;</code>，在内部使用定义了一个类型别名Node，目的是简化代码书写。</font></li><li><font color="black"><code>_root</code>指针：指向AVL树的根节点，是整棵树的入口点。</font></li></ul> </li><li><font color="black"><strong>保护成员：</strong></font> 
  <ul><li><font color="black"><code>_root</code>成员变量被设计为<code>protected</code>，意味着它只能在<code>AVLTree</code>类及其派生类中被访问。这种设计是为了将AVL树的内部实现细节隐藏起来，而只暴露必要的公共接口给外部使用。</font></li></ul> </li><li><font color="black"><strong>命名空间：</strong></font> 
  <ul><li><font color="black">为了方便使用库函数，使用<code>using namespace std;</code>展开标准库，但这容易引发同名类或函数发生冲突，因而将所有定义放在<code>ljh</code>命名空间中。</font></li></ul> </li></ol> 
<h3><a id="AVL_73"></a>AVL树的插入操作</h3> 
<p>AVL树的插入操作实现起来大致分成以下三个大步骤</p> 
<h4><a id="1_75"></a>步骤1：按照二叉搜索树的方法插入结点</h4> 
<ol><li><font color="black">树为空，则构造新结点，让_root 指针指向该结点，返回<code>true</code>。</font></li><li><font color="black">树不空，按key的大小寻找插入位置，如果已存在，按插入失败处理，返回<code>false</code>。</font></li><li><font color="black">走到空表示找到合适位置，然后插入构造的新结点，插入时要判断左边插入或者右边插入。</font></li></ol> 
<p><font color="black"><strong>此时插入并未结束，接下来进行步骤二的平衡因子更新操作！</strong></font></p> 
<p><strong>【步骤1的代码如下：】</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> kv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// empty tree -&gt; 直接插入</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// not empty tree -&gt; 找到合适的位置再插入</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> child <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 大，往右走</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
				child <span class="token operator">=</span> child<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 小，往左走</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&gt;</span> kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
				child <span class="token operator">=</span> child<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 相同，插入失败</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// child == nullptr, 找到合适的位置</span>
		child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&gt;</span> parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span>	parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> child<span class="token punctuation">;</span>
		<span class="token keyword">else</span>	parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> child<span class="token punctuation">;</span>
		child<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

		<span class="token comment">// 自底向上更新平衡因子</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_131"></a>步骤2：自底向上调整平衡因子</h4> 
<p><font color="black">我们将新插入结点称为<code>child</code>，新插入结点的双亲结点称为<code>parent</code>。</font></p> 
<p><font color="black">平衡因子的更新规则如下：</font></p> 
<ul><li><font color="black">如果<code>child</code>是<code>parent</code>的左孩子，<code>parent</code>的平衡因子-1。</font></li><li><font color="black">如果<code>child</code>是<code>parent</code>的右孩子，<code>parent</code>的平衡因子+1。</font></li></ul> 
<p><font color="black">这是第一次更新，更新完之后要不要继续向上更新取决于以<code>parent</code>为根结点的这棵树的高度是否变化，情况有以下3种：</font></p> 
<ol><li> <p><font color="black"><strong>平衡因子更新后，<code>parent</code>的平衡因子为<code>0</code>：</strong></font><br> <font color="black">这意味着<code>parent-&gt;_bf</code>是<code>从-1 -&gt; 0</code>或者 <code>从1 -&gt; 0</code>，以<code>parent</code>为根结点的这棵树的<strong>高度没有发生变化</strong>，不用再向上更新平衡因子，可以返回<code>true</code>，表示插入成功。</font></p> </li><li> <p><font color="black"><strong>平衡因子更新后，<code>parent</code>的平衡因子为<code>-1</code>或<code>+1</code>：</strong></font><br> <font color="black">这意味着<code>parent-&gt;_bf</code>是<code>从0 -&gt; -1</code>或者 <code>从0 -&gt; 1</code>，以<code>parent</code>为根结点的这棵树的<strong>高度发生了变化，但还没有达到需要旋转的程度。</strong></font><br> <font color="black">在这种情况下，更新<code>child = child-&gt;_parent</code>，更新<code>parent = parent-&gt;_parent</code>，继续更新<code>parent</code> 的平衡因子，直到情况1：找到平衡因子为<code>0</code>的节点；或者情况2：到达根节点（<code>parent == nullptr</code>）。</font></p> </li><li> <p><font color="black"><strong>平衡因子更新后，<code>parent</code>的平衡因子为<code>-2</code>或<code>+2</code>：</strong></font><br> <font color="black">这意味着此时以<code>parent</code>为根结点的这棵树已经<strong>违反了AVL树的规则，需要进行旋转处理</strong>，处理完之后，可以直接返回<code>true</code>。</font></p> </li></ol> 
<p><font color="black">【步骤2的代码如下：】</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 自底向上更新平衡因子</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">--</span>parent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>parent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		child <span class="token operator">=</span> child<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
		parent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 违反规则，旋转处理</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 理论上没错误不会走到这里</span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3AVL_186"></a>步骤3：触发旋转操作（AVL树平衡的精髓）</h4> 
<p><font color="black">根据节点插入位置的不同，AVL树的旋转分为以下4种：</font></p> 
<p><font color="black">由于具象图的种类繁多，根本不可能画得完，下面AVL树旋转的图解中大多画的是抽象图。</font></p> 
<h5><a id="_190"></a>右单旋</h5> 
<p><font color="black">这里给出了一棵以结点90作为根节点的AVL树的抽象图，图中 a / b / c 代表三棵高度为 h 的子树。<br> 这颗AVL树的<strong>左子树高度高于右子树高度</strong>。</font><br> <img src="https://images2.imgbox.com/75/4b/b6VtB1My_o.png" alt="在这里插入图片描述" width="287" height="251"></p> 
<hr> 
<p><font color="black">首先，以90为根结点的这棵树有三种可能：</font></p> 
<ol><li><font color="black">它是某棵AVL树的左子树；</font></li><li><font color="black">它是某棵AVL树的右子树；</font></li><li><font color="black">它就是AVL树的根结点；</font></li></ol> 
<p><img src="https://images2.imgbox.com/25/7a/Ve5D9cOE_o.png" alt="在这里插入图片描述" width="804" height="251"></p> 
<hr> 
<p><font color="black"><strong>当新结点插入在了较高左子树的左侧</strong>，即 a 子树时，child 和 parent 自底向上更新平衡因子，当出现<code>parent-&gt;_bf == -2, child-&gt;_bf == -1</code>时，该树违反了AVL树的规则，需要进行右单旋操作。</font><br> <img src="https://images2.imgbox.com/7d/65/IXCaE6I3_o.png" alt="在这里插入图片描述" width="280" height="252"></p> 
<hr> 
<p><font color="black">在右单旋中，涉及到改变链接关系的结点主要有以下4个：</font><br> <img src="https://images2.imgbox.com/d7/ec/oyAEj1q5_o.png" alt="在这里插入图片描述" width="774" height="260"></p> 
<hr> 
<p><font color="black">当 a / b / c 3棵子树高度为零时插入新结点，平衡因子为 <strong>-2</strong> 的结点向右旋转：</font><br> <img src="https://images2.imgbox.com/8a/c7/IBZlaHqZ_o.png" alt="在这里插入图片描述" width="590" height="243"></p> 
<p><font color="black">当 a / b / c 3棵子树高度不为零时插入新结点，平衡因子为 <strong>-2</strong> 的结点向右旋转：</font><br> <img src="https://images2.imgbox.com/53/4a/3AqgB9zq_o.png" alt="在这里插入图片描述" width="770" height="289"></p> 
<hr> 
<p><font color="black"><strong>【右单旋操作的代码如下】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">R_Rotate</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> ppnode <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>

	<span class="token comment">// subL and parent</span>
	subL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subL<span class="token punctuation">;</span>

	<span class="token comment">// parent and subLR</span>
	parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subLR<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>subLR<span class="token punctuation">)</span>	subLR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

	<span class="token comment">// ppnode and subL</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ppnode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> subL<span class="token punctuation">;</span>
		subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> ppnode<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> ppnode<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			ppnode<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subL<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			ppnode<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subL<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_264"></a>左单旋</h5> 
<p><font color="black">这里给出了一棵以结点30作为根节点的AVL树的抽象图，图中 a / b / c 代表三棵高度为 h 的子树。<br> 这颗AVL树的<strong>右子树高度高于左子树高度</strong>。</font><br> <img src="https://images2.imgbox.com/69/76/oNMt5Lun_o.png" alt="在这里插入图片描述" width="287" height="251"></p> 
<hr> 
<p><font color="black">首先，以30为根结点的这棵树有三种可能：</font></p> 
<ol><li><font color="black">它是某棵AVL树的左子树；</font></li><li><font color="black">它是某棵AVL树的右子树；</font></li><li><font color="black">它就是AVL树的根结点；</font></li></ol> 
<p><img src="https://images2.imgbox.com/3d/d5/iRNZy1Nq_o.png" alt="在这里插入图片描述" width="804" height="252"></p> 
<hr> 
<p><font color="black"><strong>当新结点插入在了较高右子树的右侧</strong>，即 c 子树时，child 和 parent 自底向上更新平衡因子，当出现<code>parent-&gt;_bf == 2, child-&gt;_bf == 1</code>时，该树违反了AVL树的规则，需要进行左单旋操作。</font><br> <img src="https://images2.imgbox.com/7e/7e/BlvCN9Pr_o.png" alt="在这里插入图片描述" width="280" height="252"></p> 
<hr> 
<p><font color="black">在左单旋中，涉及到改变链接关系的结点同样有4个：</font><br> <img src="https://images2.imgbox.com/0c/31/MfKNiFS0_o.png" alt="在这里插入图片描述" width="775" height="265"></p> 
<hr> 
<p><font color="black">当 a / b / c 3棵子树高度为零时插入新结点，平衡因子为 <strong>2</strong> 的结点向左旋转：</font><br> <img src="https://images2.imgbox.com/c3/f9/HVWuiopC_o.png" alt="在这里插入图片描述" width="539" height="196"></p> 
<p><font color="black">当 a / b / c 3棵子树高度不为零时插入新结点，平衡因子为 <strong>2</strong> 的结点向左旋转：</font><br> <img src="https://images2.imgbox.com/df/51/Fi9JjrJb_o.png" alt="在这里插入图片描述" width="771" height="288"></p> 
<hr> 
<p><font color="black"><strong>【左单旋操作的代码如下】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">L_Rotate</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> ppnode <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>

	<span class="token comment">// subR and parent</span>
	subR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subR<span class="token punctuation">;</span>

	<span class="token comment">// parent and subRL</span>
	parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subRL<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>subRL<span class="token punctuation">)</span>	subRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

	<span class="token comment">//ppnode and subR</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ppnode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> subR<span class="token punctuation">;</span>
		subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> ppnode<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> ppnode<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			ppnode<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subR<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			ppnode<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subR<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_336"></a>左右双旋</h5> 
<p><font color="black">这里给出了一棵以结点90作为根节点的AVL树的抽象图，图中 a / b / c / d 代表四棵子树。<br> 这颗AVL树的<strong>左子树高度高于右子树高度</strong>。</font><br> <img src="https://images2.imgbox.com/af/3e/plF2fCGT_o.png" alt="在这里插入图片描述" width="288" height="252"></p> 
<hr> 
<p><font color="black">首先，以90为根结点的这棵树有三种可能：</font></p> 
<ol><li><font color="black">它是某棵AVL树的左子树；</font></li><li><font color="black">它是某棵AVL树的右子树；</font></li><li><font color="black">它就是AVL树的根结点；</font></li></ol> 
<p><img src="https://images2.imgbox.com/d4/17/gaFOIYmO_o.png" alt="在这里插入图片描述" width="962" height="264"></p> 
<hr> 
<p><font color="black">下面三种情况都有一个共同给特点，就是<code>parent-&gt;_bf == -2, child-&gt;_bf == 1</code>。</font><br> <font color="black">我们不难发现，左右双旋可以视为先左旋再右旋，即结点30先左旋，结点90再右旋。</font><br> <img src="https://images2.imgbox.com/ae/c8/DHRNlkPe_o.png" alt="在这里插入图片描述" width="863" height="378"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/ec/8e/QWJGmK77_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><font color="black">单旋中的<code>subLR</code>不管怎么操作，它的平衡因子都是 0，但是在双旋中，<code>subLR</code>有可能是 -1、0、1中任意一种，因此，虽然双旋操作我们可以复用单旋的代码，但是双旋之后的平衡因子调整需要单独处理。</font><br> <img src="https://images2.imgbox.com/82/27/juIAsGbr_o.png" alt="在这里插入图片描述"></p> 
<p><font color="black"><strong>【左右双旋的代码如下】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">LR_Rotate</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> subL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>

	<span class="token comment">// 双旋之后要靠bf来更新平衡因子</span>
	<span class="token keyword">int</span> bf <span class="token operator">=</span> subLR<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>

	<span class="token function">L_Rotate</span><span class="token punctuation">(</span>subL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">R_Rotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		subLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		subL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		subLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		subL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		subLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		subL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_400"></a>右左双旋</h5> 
<p><font color="black">这里给出了一棵以结点30作为根节点的AVL树的抽象图，图中 a / b / c / d 代表四棵子树。<br> 这颗AVL树的<strong>右子树高度高于左子树高度</strong>。</font><br> <img src="https://images2.imgbox.com/9c/62/3aFUbNN7_o.png" alt="在这里插入图片描述" width="306" height="261"></p> 
<hr> 
<p><font color="black">首先，以30为根结点的这棵树有三种可能：</font></p> 
<ol><li><font color="black">它是某棵AVL树的左子树；</font></li><li><font color="black">它是某棵AVL树的右子树；</font></li><li><font color="black">它就是AVL树的根结点；</font></li></ol> 
<p><img src="https://images2.imgbox.com/4c/5d/52PniC2L_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><font color="black">下面三种情况都有一个共同给特点，就是<code>parent-&gt;_bf == 2, child-&gt;_bf == -1</code>。</font><br> <font color="black">我们不难发现，右左双旋可以视为先右旋再左旋，即结点90先右旋，结点30再左旋。</font><br> <img src="https://images2.imgbox.com/0e/3c/GgJ9vQWg_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/90/47/5qO3bXkS_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><font color="black">单旋中的<code>subRL</code>不管怎么操作，它的平衡因子都是 0，但是在双旋中，<code>subRL</code>有可能是 -1、0、1中任意一种，因此，虽然双旋操作我们可以复用单旋的代码，但是双旋之后的平衡因子调整需要单独处理。</font><br> <img src="https://images2.imgbox.com/b3/85/z0ETLYIG_o.png" alt="在这里插入图片描述"></p> 
<p><font color="black"><strong>【右左双旋的代码如下】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">RL_Rotate</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> subR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>

	<span class="token comment">// 双旋之后要靠bf来更新平衡因子</span>
	<span class="token keyword">int</span> bf <span class="token operator">=</span> subRL<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>

	<span class="token function">R_Rotate</span><span class="token punctuation">(</span>subR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">L_Rotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		subRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		subR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		subRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		subR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		subRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		subR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="AVL_465"></a>验证AVL树是否平衡</h3> 
<p><font color="black"> 虽然目前已经将AVL树的插入操作的代码已经写出来了，但是仅仅是写出来了一定能够保证代码就是正确的吗——肯定不是！</font></p> 
<p><font color="black">所以，接下来还要再实现一个方法，来验证一棵AVL树是不是平衡的。<font color="black"></font></font></p> 
<p><font color="black">AVL树是在二叉搜索树的基础上加入了平衡性的限制，因此要验证AVL树，可以分两步：</font></p> 
<ol><li><font color="black"><strong>验证其为二叉搜索树</strong></font><br> <font color="black">如果中序遍历可得到一个有序的序列，就说明为二叉搜索树。</font></li><li><font color="black"><strong>验证其为平衡树</strong></font><br> <font color="black">每个结点子树高度差的绝对值不超过1（注意节点中如果没有平衡因子）。</font><br> <font color="black">结点的平衡因子是否计算正确。</font></li></ol> 
<p><font color="black"><strong>【写法一代码：简单但是效率低】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 求AVL树的高度</span>
size_t <span class="token function">_Height</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> leftHeight <span class="token operator">&gt;</span> rightHeight <span class="token operator">?</span> leftHeight <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> rightHeight <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

size_t <span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">_Height</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">_IsBalance</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 空树也是AVL树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 计算root节点的平衡因子：即root左右子树的高度差</span>
	<span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 如果计算出的平衡因子与pRoot的平衡因子不相等，或者</span>
	<span class="token comment">// root平衡因子的绝对值超过1，则一定不是AVL树</span>
	<span class="token keyword">int</span> diff <span class="token operator">=</span> rightHeight <span class="token operator">-</span> leftHeight<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">"不平衡"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">!=</span> root<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">"平衡因子异常"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// root的左和右如果都是AVL树，则该树一定是AVL树</span>
	<span class="token keyword">return</span> <span class="token function">_IsBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IsBalance</span><span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="black"><strong>【写法二代码：效率高但是相较写法一难理解】</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 判断AVL树是否平衡，高效</span>
<span class="token keyword">bool</span> <span class="token function">_IsBalance</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 空树也是AVL树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 后序递归，leftHeight、rightHeight会分别获取root的左右子树的高度</span>
	<span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_IsBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span> leftHeight<span class="token punctuation">)</span> 
	 <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">_IsBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 如果高度差的绝对值 &gt;= 2，AVL树不平衡</span>
	<span class="token keyword">int</span> diff <span class="token operator">=</span> rightHeight <span class="token operator">-</span> leftHeight<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">"不平衡"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 如果高度差 != root-&gt;_bf，AVL树插入过程中的平衡因子更新有问题</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">!=</span> root<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">"平衡因子异常"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 将root自己的高度通过引用返回给上一层栈帧</span>
	height <span class="token operator">=</span> leftHeight <span class="token operator">&gt;</span> rightHeight <span class="token operator">?</span> leftHeight <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> rightHeight <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token comment">// root的左子树平衡、右子树平衡、root自身也平衡，那这棵AVL树就平衡</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_567"></a>参考文章</h2> 
<blockquote> 
 <p><a href="https://blog.csdn.net/xiaojin21cen/article/details/97602146">数据结构 —— 图解AVL树(平衡二叉树)</a><br> <a href="https://blog.csdn.net/qq_49613557/article/details/121317987">高度平衡二叉搜索树（AVLTree）</a><br> <a href="https://blog.csdn.net/Shun_Hua/article/details/132917187?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171006395716800188591324%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171006395716800188591324&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-132917187-null-null.142%5Ev99%5Epc_search_result_base5&amp;utm_term=avl%E6%A0%91%E5%88%A0%E9%99%A4&amp;spm=1018.2226.3001.4187">【数据结构】AVL树的删除（解析有点东西哦）</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/720e2792257ef4ed5b69638069a96e9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Github高级搜索【指定日期区间，星星数，用户仓库名多条件精确搜索】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/101e5f267d4bf111c058e83315339b1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搜索引擎：6种引擎霸屏推广的颠覆性想法激发新商机-华媒舍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>