<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编译原理 CS-143(更新至week4) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编译原理 CS-143(更新至week4)" />
<meta property="og:description" content="编译原理 CS-143 Pre-Course SurveyNavigation Your Course01-01: Introduction (8m20s)01-02: Structure of a Compiler (13m53s)【编译器结构】first step：recognize words句法分析句意分析optiimization（优化）finally code Gen 01-03: The Economy of Programming Languages (19m51s)【编译器性价比】why are there so many progamming languageswhy are there new programming languages？what is a good programming language？Summarize 02-01: Cool Overview (19m58s)【cool语言概述】02-02: Cool Example II (15m04s)【cool样例2】02-03: Cool Example III (18m05s)【cool样例3】 CS-143 Week2 Lexical Analysis&amp;Finite Automata[词法分析和有限自动机]03-01: Lexical Analysis (12m06s)【词法分析】Token class（标记类）样例分析SummarizeQuiz 03-02: Lexical Analysis Examples (13m03s)【词法分析案例】为什么需要lookaheadPL/1 keywords are not reservedSummarize 03-03: Regular Languages Part 1 (11m48s)【正则语言part1】regular expressions 正则表达式基本表达式复合正则表达式 exampleQuizSummarize 03-04: Formal Languages (13m40s)【形式语言】03-05: Lexical Specifications (16m19s)【词法规则】keywordintegeridentifierwhitespace课外exampleSummarize 04-01: Lexical Specification (14m30s)【词法规则2】1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c31fc1806044c3fe390ac3515fb11bd1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-04T11:40:45+08:00" />
<meta property="article:modified_time" content="2022-03-04T11:40:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编译原理 CS-143(更新至week4)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>编译原理 CS-143</h4> 
 <ul><li><a href="#PreCourse_Survey_1" rel="nofollow">Pre-Course Survey</a></li><li><ul><li><a href="#Navigation_Your_Course_10" rel="nofollow">Navigation Your Course</a></li><li><a href="#0101_Introduction_8m20s_24" rel="nofollow">01-01: Introduction (8m20s)</a></li><li><a href="#0102_Structure_of_a_Compiler_13m53s_90" rel="nofollow">01-02: Structure of a Compiler (13m53s)【编译器结构】</a></li><li><ul><li><a href="#first_steprecognize_words_92" rel="nofollow">first step：recognize words</a></li><li><a href="#_130" rel="nofollow">句法分析</a></li><li><a href="#_170" rel="nofollow">句意分析</a></li><li><a href="#optiimization_216" rel="nofollow">optiimization（优化）</a></li><li><a href="#finally_code_Gen_248" rel="nofollow">finally code Gen</a></li></ul> 
   </li><li><a href="#0103_The_Economy_of_Programming_Languages_19m51s_262" rel="nofollow">01-03: The Economy of Programming Languages (19m51s)【编译器性价比】</a></li><li><ul><li><a href="#why_are_there_so_many_progamming_languages_278" rel="nofollow">why are there so many progamming languages</a></li><li><a href="#why_are_there_new_programming_languages_294" rel="nofollow">why are there new programming languages？</a></li><li><a href="#what_is_a_good_programming_language_336" rel="nofollow">what is a good programming language？</a></li><li><a href="#Summarize_350" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0201_Cool_Overview_19m58scool_359" rel="nofollow">02-01: Cool Overview (19m58s)【cool语言概述】</a></li><li><a href="#0202_Cool_Example_II_15m04scool2_582" rel="nofollow">02-02: Cool Example II (15m04s)【cool样例2】</a></li><li><a href="#0203_Cool_Example_III_18m05scool3_705" rel="nofollow">02-03: Cool Example III (18m05s)【cool样例3】</a></li></ul> 
  </li><li><a href="#CS143_Week2_Lexical_AnalysisFinite_Automata_833" rel="nofollow">CS-143 Week2 Lexical Analysis&amp;Finite Automata[词法分析和有限自动机]</a></li><li><ul><li><a href="#0301_Lexical_Analysis_12m06s_835" rel="nofollow">03-01: Lexical Analysis (12m06s)【词法分析】</a></li><li><ul><li><a href="#Token_class_864" rel="nofollow">Token class（标记类）</a></li><li><a href="#_942" rel="nofollow">样例分析</a></li><li><a href="#Summarize_977" rel="nofollow">Summarize</a></li><li><a href="#Quiz_991" rel="nofollow">Quiz</a></li></ul> 
   </li><li><a href="#0302_Lexical_Analysis_Examples_13m03s_1015" rel="nofollow">03-02: Lexical Analysis Examples (13m03s)【词法分析案例】</a></li><li><ul><li><a href="#lookahead_1079" rel="nofollow">为什么需要lookahead</a></li><li><a href="#PL1_keywords_are_not_reserved_1089" rel="nofollow">PL/1 keywords are not reserved</a></li><li><a href="#Summarize_1137" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0303_Regular_Languages_Part_1_11m48spart1_1149" rel="nofollow">03-03: Regular Languages Part 1 (11m48s)【正则语言part1】</a></li><li><ul><li><a href="#regular_expressions__1157" rel="nofollow">regular expressions 正则表达式</a></li><li><ul><li><a href="#_1163" rel="nofollow">基本表达式</a></li><li><a href="#_1169" rel="nofollow">复合正则表达式</a></li></ul> 
    </li><li><a href="#example_1215" rel="nofollow">example</a></li><li><a href="#Quiz_1260" rel="nofollow">Quiz</a></li><li><a href="#Summarize_1290" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0304_Formal_Languages_13m40s_1302" rel="nofollow">03-04: Formal Languages (13m40s)【形式语言】</a></li><li><a href="#0305_Lexical_Specifications_16m19s_1409" rel="nofollow">03-05: Lexical Specifications (16m19s)【词法规则】</a></li><li><ul><li><a href="#keyword_1411" rel="nofollow">keyword</a></li><li><a href="#integer_1425" rel="nofollow">integer</a></li><li><a href="#identifier_1451" rel="nofollow">identifier</a></li><li><a href="#whitespace_1467" rel="nofollow">whitespace</a></li><li><a href="#example_1475" rel="nofollow">课外example</a></li><li><a href="#Summarize_1523" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0401_Lexical_Specification_14m30s2_1534" rel="nofollow">04-01: Lexical Specification (14m30s)【词法规则2】</a></li><li><ul><li><a href="#1Write_a_rexp_for_the_lexemes_of_each_token_class_1556" rel="nofollow">1.Write a rexp for the lexemes of each token class</a></li><li><a href="#2Construct_Rmatching_all_lexemes_for_all_tokens_1566" rel="nofollow">2.Construct R,matching all lexemes for all tokens</a></li><li><a href="#3Let_input_be_x1xn_1574" rel="nofollow">3.Let input be x1...xn</a></li><li><a href="#4if_success_then_we_know_that_1596" rel="nofollow">4.if success ，then we know that</a></li><li><a href="#5remove_x1xi_from_input_and_go_to_3_1602" rel="nofollow">5.remove x1...xi from input and go to (3)</a></li><li><a href="#question_1608" rel="nofollow">question</a></li><li><a href="#Summarize_1662" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0402_Finite_Automata_Part_1_13m01s_1686" rel="nofollow">04-02: Finite Automata Part 1 (13m01s)【有限自动机】</a></li><li><ul><li><a href="#Transition_1710" rel="nofollow">Transition</a></li><li><a href="#_1750" rel="nofollow">另一种有限自动机的表达方式</a></li><li><a href="#_1_1764" rel="nofollow">编写 只接受数字1的自动机</a></li><li><a href="#complex_1811" rel="nofollow">complex的例子</a></li><li><a href="#Quiz_1851" rel="nofollow">Quiz</a></li><li><a href="#DFA_NFA_1900" rel="nofollow">DFA 和NFA</a></li></ul> 
   </li><li><a href="#0403_Regular_Expressions_into_NFAs_9m41sNFA_1980" rel="nofollow">04-03: Regular Expressions into NFAs (9m41s)【从正则表达式到NFA】</a></li><li><ul><li><a href="#for_each_kind_of_rexp_define_an_NFA_1998" rel="nofollow">for each kind of rexp ，define an NFA</a></li><li><a href="#_2020" rel="nofollow">复杂的正则表示</a></li><li><a href="#example_2056" rel="nofollow">example</a></li><li><a href="#quiz_2083" rel="nofollow">quiz</a></li></ul> 
   </li><li><a href="#0404_NFA_to_DFA_15m12snfadfa_2109" rel="nofollow">04-04: NFA to DFA (15m12s)【从nfa到dfa】</a></li><li><ul><li><a href="#_2153" rel="nofollow">任意的非确定性自动优先级映射到一个等效的确定性有限自动机</a></li><li><a href="#example_2235" rel="nofollow">example</a></li><li><a href="#Quiz_2277" rel="nofollow">Quiz</a></li></ul> 
   </li><li><a href="#0405_Implementing_Finite_Automata_11m56s_2325" rel="nofollow">04-05: Implementing Finite Automata (11m56s)【实现有限自动机】</a></li><li><ul><li><a href="#A_DFA_can_be_implemented_by_a_2D_table_T_2331" rel="nofollow">A DFA can be implemented by a 2D table T</a></li><li><a href="#example_2347" rel="nofollow">example</a></li><li><ul><li><a href="#__2_dimension_2349" rel="nofollow">二维 表 2 dimension</a></li><li><a href="#_1dimension_2391" rel="nofollow">一维表 1dimension</a></li></ul> 
    </li><li><a href="#NFA_2405" rel="nofollow">NFA直接转换自动机</a></li><li><a href="#summarize_2423" rel="nofollow">summarize</a></li></ul> 
   </li><li><a href="#week2_Quiz_2437" rel="nofollow">week2 Quiz</a></li></ul> 
  </li><li><a href="#CS143_Week3_Parsing__TopDown_Parsing__2602" rel="nofollow">CS-143 Week3 Parsing &amp; Top-Down Parsing 【解析器&amp;自顶向下的解析器】</a></li><li><ul><li><a href="#0501_Introduction_to_Parsing_5m31s__2604" rel="nofollow">05-01: Introduction to Parsing (5m31s) 【解释器介绍】</a></li><li><ul><li><a href="#parseing__2646" rel="nofollow">parseing 可以做什么</a></li><li><a href="#Summarize_2660" rel="nofollow">Summarize</a></li></ul> 
   </li><li><a href="#0502_Context_Free_Grammars_Part_1_12m38s_2674" rel="nofollow">05-02: Context Free Grammars Part 1 (12m38s)【上下文无关法】</a></li><li><ul><li><a href="#_2734" rel="nofollow">上下文无关法的例子</a></li><li><a href="#productions_can_be_read_as_rules_2766" rel="nofollow">productions can be read as rules</a></li><li><ul><li><a href="#1begin_with_a_string_with_only_the_start_symbol_S_2774" rel="nofollow">1.begin with a string with only the start symbol S</a></li><li><a href="#2replace_any_nonterminal_X_in_the_string_by_the_righthand_side_of_some_production_XY1Yn_2778" rel="nofollow">2.replace any non-terminal X in the string by the right-hand side of some production X-&gt;Y1..Yn</a></li><li><a href="#3repeat2_until_there_are_no_nonterminals_2784" rel="nofollow">3.repeat(2) until there are no non-terminals</a></li></ul> 
    </li><li><a href="#example_2788" rel="nofollow">example</a></li><li><a href="#finally_2820" rel="nofollow">finally</a></li><li><ul><li><a href="#terminal_2834" rel="nofollow">terminal</a></li></ul> 
    </li><li><a href="#a_fragment_of_cool_2844" rel="nofollow">a fragment of cool</a></li><li><a href="#some_elements_of_the_language_2878" rel="nofollow">some elements of the language</a></li><li><a href="#simple_arithmetic_expression_2908" rel="nofollow">simple arithmetic expression</a></li><li><a href="#the_idea_of_a_CFG_is_a_big_step_2931" rel="nofollow">the idea of a CFG is a big step</a></li></ul> 
   </li><li><a href="#0503_Derivations_Part_1_7m07s_2954" rel="nofollow">05-03: Derivations Part 1 (7m07s)【推导】</a></li><li><ul><li><a href="#example_2964" rel="nofollow">example</a></li><li><a href="#parsing_tree_2992" rel="nofollow">parsing tree</a></li><li><a href="#summarize_3032" rel="nofollow">summarize</a></li></ul> 
   </li><li><a href="#0504_Ambiguity_3044" rel="nofollow">05-04: Ambiguity【歧义性】</a></li><li><ul><li><a href="#_3090" rel="nofollow">消除歧义</a></li><li><a href="#example_3168" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0601_Error_Handling_13m03s_3272" rel="nofollow">06-01: Error Handling (13m03s)【错误处理】</a></li><li><ul><li><a href="#_3290" rel="nofollow">处理错误需要什么</a></li><li><a href="#error_handling_3300" rel="nofollow">error handling</a></li><li><a href="#panic_example_3318" rel="nofollow">panic example</a></li><li><ul><li><a href="#bsion_3332" rel="nofollow">bsion</a></li></ul> 
    </li><li><a href="#error_production_3352" rel="nofollow">error production</a></li><li><a href="#__3368" rel="nofollow">最后一个策略 错误更正</a></li><li><a href="#past__3394" rel="nofollow">past 过去的错误处理</a></li></ul> 
  </li></ul> 
  </li><li><a href="#0602_Abstract_Syntax_Trees_3m50s_3409" rel="nofollow">06-02: Abstract Syntax Trees (3m50s)【抽象语法树】</a></li><li><ul><li><a href="#0603_Recursive_Descent_Parsing_6m35s_3453" rel="nofollow">06-03: Recursive Descent Parsing (6m35s)【递归下降解析】</a></li><li><ul><li><a href="#example_3467" rel="nofollow">example</a></li><li><a href="#quiz_3513" rel="nofollow">quiz</a></li></ul> 
   </li><li><a href="#0604_Recursive_Descent_Algorithm_13m28s_3529" rel="nofollow">06-04: Recursive Descent Algorithm (13m28s)【递归下降算法】</a></li><li><ul><li><a href="#example_3571" rel="nofollow">example</a></li><li><a href="#Functions_for_nonterminal_T_3630" rel="nofollow">Functions for non-terminal T</a></li><li><a href="#summarize_3674" rel="nofollow">summarize</a></li><li><a href="#quiz_3716" rel="nofollow">quiz</a></li></ul> 
   </li><li><a href="#06041_Recursive_Descent_Limitations_6m56s_3724" rel="nofollow">06-04-1: Recursive Descent Limitations (6m56s)【自顶向下递归局限性】</a></li><li><a href="#0605_Left_Recursion_Part_1_8m05s_3764" rel="nofollow">06-05: Left Recursion Part 1 (8m05s)【左递归】</a></li><li><ul><li><a href="#_3794" rel="nofollow">左递归语法形式</a></li><li><a href="#summarize_3859" rel="nofollow">summarize</a></li></ul> 
  </li></ul> 
  </li><li><a href="#CS143_Week4_BottomUp_Parsing__3873" rel="nofollow">CS-143 Week4 Bottom-Up Parsing 【自底向上解析】</a></li><li><ul><li><a href="#0701_Predictive_Parsing_Part_1_7m40s_3875" rel="nofollow">07-01: Predictive Parsing Part 1 (7m40s)【预测解析】</a></li><li><ul><li><a href="#example_3973" rel="nofollow">example</a></li><li><a href="#_3997" rel="nofollow">解析表进行解析的算法</a></li></ul> 
   </li><li><a href="#0702_First_Sets_14m02sfirst_4047" rel="nofollow">07-02: First Sets (14m02s)【first集】</a></li><li><ul><li><a href="#first_4086" rel="nofollow">first集合的计算</a></li><li><a href="#example_4126" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0703_Follow_Sets_17m05s_4164" rel="nofollow">07-03: Follow Sets (17m05s)</a></li><li><ul><li><a href="#algorithm_sketch__4194" rel="nofollow">algorithm sketch 算法概述</a></li><li><a href="#example_4206" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0704_LL1_Parsing_Tables_14m41sLL1_4292" rel="nofollow">07-04: LL1 Parsing Tables (14m41s)【LL1解析表】</a></li><li><ul><li><a href="#example_4306" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0705_BottomUp_Parsing_Part_1_7m06s_4453" rel="nofollow">07-05: Bottom-Up Parsing Part 1 (7m06s)【自下而上的解析】</a></li><li><ul><li><a href="#example_4467" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0706_ShiftReduce_Parsing_Part_1_5m40s_4545" rel="nofollow">07-06: Shift-Reduce Parsing Part 1 (5m40s)【移位规约解析】</a></li><li><a href="#0801_Handles_Part_1_4m35s_4669" rel="nofollow">08-01: Handles Part 1 (4m35s)【句柄】</a></li><li><a href="#0802_Recognizing_Handles_13m12s_4765" rel="nofollow">08-02: Recognizing Handles (13m12s)【句柄识别】</a></li><li><ul><li><a href="#example_4817" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0803_Recognizing_Viable_Prefixes_14m57s_4967" rel="nofollow">08-03: Recognizing Viable Prefixes (14m57s)【识别可行前缀】</a></li><li><ul><li><a href="#example_5041" rel="nofollow">example</a></li></ul> 
   </li><li><a href="#0804_Valid_Items_3m31sitem_5185" rel="nofollow">08-04: Valid Items (3m31s)【有效item】</a></li><li><a href="#0805_SLR_Parsing_14m16sSLR_5247" rel="nofollow">08-05: SLR Parsing (14m16s)【SLR解析】</a></li><li><a href="#0806_SLR_Parsing_Example_6m42sSLR_5451" rel="nofollow">08-06: SLR Parsing Example (6m42s)【SLR解析案例】</a></li><li><a href="#0_807_SLR_Improvements_11m49sSLR_5557" rel="nofollow">0 8-07: SLR Improvements (11m49s)【SLR改进】</a></li><li><a href="#0808_SLR_Examples_12m47sSLR_5677" rel="nofollow">08-08: SLR Examples (12m47s)【SLR案例】</a></li><li><ul><li><a href="#example_5745" rel="nofollow">example</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="PreCourse_Survey_1"></a>Pre-Course Survey</h2> 
<p><img src="https://images2.imgbox.com/d4/aa/L1B48hSi_o.png" alt="image-20220114183629932"></p> 
<p>一个小调查，无伤大雅</p> 
<p>实验所需虚拟机<br> 链接: https://pan.baidu.com/s/16KXICHhpBb22v4CyNQugMg 提取码: n44a</p> 
<h3><a id="Navigation_Your_Course_10"></a>Navigation Your Course</h3> 
<p>课程导览</p> 
<p>属性bar用的</p> 
<p><img src="https://images2.imgbox.com/72/f6/HhiKq9IL_o.png" alt="image-20220114183851092"></p> 
<p>介绍了 课程模块，大纲模块，讨论模块，测评模块，测评模块会打分</p> 
<p><img src="https://images2.imgbox.com/0f/a6/jIvWDjcK_o.png" alt="image-20220114184149658"></p> 
<p>讨论模块要遵守规则，不发一些不必要的内容，淫秽色情，垃圾邮件，抄袭的内容</p> 
<h3><a id="0101_Introduction_8m20s_24"></a>01-01: Introduction (8m20s)</h3> 
<p><img src="https://images2.imgbox.com/14/d9/jr9WLNac_o.png" alt="image-20220114184612313"></p> 
<p>编程语言又两种实现，也就是编译器和解释器</p> 
<p>解释器做了啥</p> 
<p><img src="https://images2.imgbox.com/8f/59/p6aAVYME_o.png" alt="image-20220114184845505"></p> 
<p>我们将数据和程序发送给了解释器，解释器开始运行，有了输出，解释器相当于是一个在线的</p> 
<p><img src="https://images2.imgbox.com/c1/b5/wROsRmdH_o.png" alt="image-20220114185018915"></p> 
<p>写一个程序，产生了一个可执行文件，当然不只是可执行文件</p> 
<p>可能是汇编，字节码之类的，</p> 
<p>现在你不需要输入数据，就能得到输出</p> 
<p>在结构中就是线下，</p> 
<p>当然是相对于解释器的，解释器需要结合一个数据进行执行，而编译器不需要</p> 
<p><img src="https://images2.imgbox.com/48/1c/EiqF9G9K_o.png" alt="image-20220114185325263"></p> 
<p>因此，我们不需要对程序进行重编译或者做其他处理，我们就能对可执行程序传入很多不同的值或数据集进行处理</p> 
<p>编译器开发历史：</p> 
<p>IBM 704软件成本超过了硬件成本</p> 
<p><img src="https://images2.imgbox.com/f8/4d/pT8nK5nW_o.png" alt="image-20220114185938859"></p> 
<p><img src="https://images2.imgbox.com/40/e6/fVac6PWW_o.png" alt="image-20220114190037039"></p> 
<p>用解释器比你直接跑代码会慢很多，10-20倍</p> 
<p>fortran</p> 
<p>直接翻译成机器可执行的，会快很多</p> 
<p>formulas translated 公式翻译</p> 
<p><img src="https://images2.imgbox.com/bd/ff/2urHJUW1_o.png" alt="image-20220114190246583"></p> 
<p><img src="https://images2.imgbox.com/43/b0/4L4uAnUU_o.png" alt="image-20220114190625171"></p> 
<p>有些仍然保留了FORTRAN 1的框架</p> 
<p>什么是fortran 1 框架呢</p> 
<p>lexical Analysis 词法分析</p> 
<p>parsing 解析</p> 
<p>这两个共同关注语言的语法部分syntactic</p> 
<p>semantic analysis 语义分析，关注语义方面，包括类型和作用域</p> 
<p>optimization 优化 运行的更快，更节省</p> 
<p>code generation 也就是translation 转换，转换结果可以是字节码，机器码，或者是另一种高级语言</p> 
<p><img src="https://images2.imgbox.com/4e/0b/QtP80OyJ_o.png" alt="image-20220114191008501"></p> 
<h3><a id="0102_Structure_of_a_Compiler_13m53s_90"></a>01-02: Structure of a Compiler (13m53s)【编译器结构】</h3> 
<h4><a id="first_steprecognize_words_92"></a>first step：recognize words</h4> 
<p>对单词的认识/理解</p> 
<p><img src="https://images2.imgbox.com/5d/98/7IFdQXdi_o.png" alt="image-20220114214214204"></p> 
<p><img src="https://images2.imgbox.com/88/13/VaOFQc75_o.png" alt="image-20220114214239789"></p> 
<p><code>this is a sentence</code></p> 
<p>你需要理解 大小写，空格，句点才能够正确的理解这个意思</p> 
<p>如果给我们一个其他的</p> 
<p><code>ist his ase nte nce</code></p> 
<p><code>is this a sentence</code></p> 
<p>我们也无法很容易得到结果</p> 
<p><img src="https://images2.imgbox.com/62/6e/UY4RbvQr_o.png" alt="image-20220114214432046"></p> 
<p>词法分析的目标，就是将程序代码文本按照他的方式进行分词，</p> 
<p>也就是对词的一个区分</p> 
<p>这个句子，分为几个token呢（词法单元）</p> 
<p><code>if,then,else,</code></p> 
<p><code>x,y,z</code></p> 
<p><code>1,2</code></p> 
<p><code>=，空格</code> ，</p> 
<p>同时，我们仍然要区分一个等于号和两个等于号</p> 
<h4><a id="_130"></a>句法分析</h4> 
<p><img src="https://images2.imgbox.com/0a/4a/pMn7qHfk_o.png" alt="image-20220114214723666"></p> 
<p><img src="https://images2.imgbox.com/6e/a4/Oz4WZLJ3_o.png" alt="image-20220114214749082"></p> 
<p>分析词的意思后（名词，动词，形容词），我们就会有句法</p> 
<p>（主语subject，谓语verb，宾语object）</p> 
<p><img src="https://images2.imgbox.com/ab/5e/4EFAsyW3_o.png" alt="image-20220114214856668"></p> 
<p><img src="https://images2.imgbox.com/0f/54/6oSLWIp4_o.png" alt="image-20220114214906888"></p> 
<p>共同构成了一个句子树，这就是一个英文句子进行语法分析的例子</p> 
<p>代码也同理</p> 
<p><img src="https://images2.imgbox.com/52/70/xg2X6OTB_o.png" alt="image-20220115120728962"></p> 
<p>针对if then else进行分析</p> 
<p>if-then-else就是解析树的树根</p> 
<p>如下为if-then-else的分析树</p> 
<p><img src="https://images2.imgbox.com/3c/37/wUKIC9Qk_o.png" alt="image-20220115120852555"></p> 
<p>if then else</p> 
<p>分成了三个部分，断言部分，then部分，else部分</p> 
<p>if包含了 x == y</p> 
<p>then包含了 z = 1</p> 
<p>else 包含了 z = 2</p> 
<h4><a id="_170"></a>句意分析</h4> 
<p><img src="https://images2.imgbox.com/4b/01/s02KTwZb_o.png" alt="image-20220115121122792"></p> 
<p>当理解句子结构厚，我们就要去理解这句话写了什么内容</p> 
<p>编译器只能做有限的语义分析，找到自相矛盾的地方，</p> 
<p><img src="https://images2.imgbox.com/2a/b0/JU124XAA_o.png" alt="image-20220115121401909"></p> 
<p>example</p> 
<p><code>jack said jerry left his assignment at home</code></p> 
<p>这里的his 我们无法知道他是指定jack还是jerry</p> 
<p><img src="https://images2.imgbox.com/e7/f9/F1Hu5oGV_o.png" alt="image-20220115121713821"></p> 
<p>worse</p> 
<p><code>jaca said jack left his assignment at home</code></p> 
<p>这个更糟糕的情况，我们不知道有几个人，jack是两个人，his是一个人？</p> 
<p>可能性很多</p> 
<p><img src="https://images2.imgbox.com/d9/05/YZJilYh8_o.png" alt="image-20220115121826017"></p> 
<p><img src="https://images2.imgbox.com/54/7e/JMzb8XHd_o.png" alt="image-20220115121900533"></p> 
<p>编程语言中，为了避免这种尴尬，就有了变量绑定</p> 
<p>非常严格的规则，防止歧义</p> 
<p>如上的程序，会输出4</p> 
<p>外层的定义jack会被隐藏</p> 
<p><img src="https://images2.imgbox.com/ac/23/sx91mhrB_o.png" alt="image-20220115122012038"></p> 
<p>编译器执行文本的语义分析时，不需要考虑对变量进行作用域的绑定分析</p> 
<p>jack和her的类型不匹配，肯定不是一个人</p> 
<h4><a id="optiimization_216"></a>optiimization（优化）</h4> 
<p><img src="https://images2.imgbox.com/a5/69/gyl95tCF_o.png" alt="image-20220115123507823"></p> 
<p>比较像一个专业的编辑在一定的字数范围内对文章长度做删减</p> 
<p><code>but a little bit like editing</code></p> 
<p>替换为</p> 
<p><code>but akin to editing</code></p> 
<p>意思没变，但是词变少了，节省了资源</p> 
<p>run faster，use less memory，lower power,database,network</p> 
<p>一个需要优化的程序</p> 
<p><img src="https://images2.imgbox.com/8e/ba/jbkC9UKM_o.png" alt=""></p> 
<p>y*0 和给x赋值为0 是一致的，因此我们比起乘法，仅仅做赋值即可</p> 
<p><strong>但是这个不是一个正确的规则</strong></p> 
<p>仅仅对integer有效</p> 
<p><img src="https://images2.imgbox.com/b3/f5/ggEWB975_o.png" alt="image-20220115123941638"></p> 
<p>浮点数无效，</p> 
<h4><a id="finally_code_Gen_248"></a>finally code Gen</h4> 
<p><img src="https://images2.imgbox.com/a7/97/rgCOHY5w_o.png" alt="image-20220115124119383"></p> 
<p>也就是翻译成其他语言，编译器把高级语言转换为汇编语言</p> 
<p><img src="https://images2.imgbox.com/58/55/kerMieX2_o.png" alt="image-20220115124227579"></p> 
<p>最基本的fortran对于语义分析会很小</p> 
<p>而现代的编译器，优化会占据很大</p> 
<p><img src="https://images2.imgbox.com/7e/9c/lZOkXc0k_o.png" alt="image-20220115124308263"></p> 
<h3><a id="0103_The_Economy_of_Programming_Languages_19m51s_262"></a>01-03: The Economy of Programming Languages (19m51s)【编译器性价比】</h3> 
<p><img src="https://images2.imgbox.com/f2/6a/yV6Imtk3_o.png" alt="image-20220115180537506"></p> 
<p>本节课，将会谈论这三个问题，</p> 
<pre><code>为什么这么多的语言
为什么又新的语诞生
什么是一个好的编程语言
</code></pre> 
<p>首先第一个</p> 
<h4><a id="why_are_there_so_many_progamming_languages_278"></a>why are there so many progamming languages</h4> 
<p><img src="https://images2.imgbox.com/c6/0e/VxssoJoM_o.png" alt="image-20220115181057596"></p> 
<p>首先我们是有三个大概的范围，应用领域不同</p> 
<p>他们的优势不同，作用域不同，语言不同</p> 
<p>科学研究：需要好的浮点数运算，FP，好的数组支持，大并行支持（parallelism）FORTRAN语言 （公式 翻译）fomulate translate</p> 
<p>商业领域：需要好的稳定性，防止丢失数据，而且要可靠，需要报告的生成，数据分析，数据处理之类的， 也就是SQL比较常用</p> 
<p>系统编程：也就是嵌入式，控制设备之类的，我们需要控制一些底层的资源，细粒度控制，需要能够预判时间（实时控制），在一定时间内做出反应，或者对网络进行大量的响应 广泛的就是c和c++</p> 
<h4><a id="why_are_there_new_programming_languages_294"></a>why are there new programming languages？</h4> 
<p>为什么需要设计一个新的语言</p> 
<p><img src="https://images2.imgbox.com/67/75/DOoHGX6j_o.png" alt="image-20220115181648133"></p> 
<p>培养程序员以及培养某种语言程序员的成本 这个比较重要，如何教会他们去使用</p> 
<p>因为去开发，去开发一个新的编译器的成本并不是很高</p> 
<p>有如下的预测</p> 
<p>有两点，也就是</p> 
<p>第一个预测是 广泛使用的编程语言改变的很慢，会越来越保守</p> 
<p>第二个预测是 很容易的去开发一个新的语言，培训成本为0，新的编程语言进化的会很快。</p> 
<p>productivity &gt; tranning cost</p> 
<p>生产力要大于学习耗费</p> 
<p>就会选择新的语言</p> 
<p><img src="https://images2.imgbox.com/6f/fa/lZ8X1X31_o.png" alt="image-20220115184117460"></p> 
<p>什么时候呢？</p> 
<p>需要一种语言去填补空白的时候（新的应用领域），往往 会选择新的语言</p> 
<p>旧的语言不一定能够支持新的应用领域</p> 
<p>新的语言有时候会看起来像旧的语言，就比如java很像c++</p> 
<p>猜测:为了降低培训成本，通过学过的语言更轻松的去解除</p> 
<p><img src="https://images2.imgbox.com/95/71/iKremU5B_o.png" alt="image-20220115184353195"></p> 
<h4><a id="what_is_a_good_programming_language_336"></a>what is a good programming language？</h4> 
<p>从语言设计的通用性来说，没有一个好的编程语言</p> 
<p><img src="https://images2.imgbox.com/c2/9a/EhNhBhNE_o.png" alt="image-20220115184510989"></p> 
<p>讨论这个问题，无法达成共识，关于什么是好的语言，也没有普遍接受的共识，</p> 
<p>讲师的猜测：</p> 
<p>是大众的接受度/使用度，可以作为是一个好的语言的标准</p> 
<p><img src="https://images2.imgbox.com/61/27/HqKFhbZU_o.png" alt="image-20220115184637859"></p> 
<h4><a id="Summarize_350"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/69/1c/PN9LJE3W_o.png" alt="image-20220115182920040"></p> 
<p>很难设计出一个整合你所有想要功能的语言</p> 
<p>培养程序员花费了大量成本</p> 
<h3><a id="0201_Cool_Overview_19m58scool_359"></a>02-01: Cool Overview (19m58s)【cool语言概述】</h3> 
<p>classroom object oriented language = cool</p> 
<p>课堂专用面向对象语言</p> 
<p>被设计短期内/一个学期内写出编译器，需要易于编写</p> 
<p><img src="https://images2.imgbox.com/36/3c/6ZfeOfB0_o.png" alt="image-20220115191815059"></p> 
<p>本课程的目的：完整的编译器编写，包括MIPS 指令集</p> 
<p><img src="https://images2.imgbox.com/e6/d7/grl4snyn_o.png" alt="image-20220115192007173"></p> 
<p>我们可以运行编译器，也可以生成mips汇编语言，然后可以在你能访问的任何机器上模拟mips汇编语言</p> 
<p>分为五个任务，编译器本身包含四个阶段</p> 
<p>词法分析</p> 
<p>语法分析</p> 
<p>语义分析</p> 
<p>代码生成</p> 
<p>我们编写如上模块采用的是 插件兼容</p> 
<p>也就是，我们可以使用模板填充其他几个，然后我们只是去编写词法分析，然后和标准输出进行比对，保证自己编写的足迹按没问题</p> 
<p><img src="https://images2.imgbox.com/54/07/SVtNGq6y_o.png" alt="image-20220115192358338"></p> 
<p>优化可以当一个可选的作业</p> 
<p><img src="https://images2.imgbox.com/dc/a8/ZyjZoleQ_o.png" alt="image-20220115192530573"></p> 
<p>开始编写程序</p> 
<p>1- 每个cool程序必须要有一名为main的class</p> 
<pre><code>class main{

};
</code></pre> 
<p>class 后面跟名字，然后花括号带分号结尾</p> 
<p>一个程序包含若干类</p> 
<p>main类中，main方法必须存在，这个方法用来启动程序，此外，这个方法必须无参，main方法永远无参</p> 
<pre><code>class Main{
	main():Int{
	1
	};
};
</code></pre> 
<p>在main类中，有一个main方法</p> 
<p>cool中，需要对方法指明返回值的类型，这里写int</p> 
<p>cool是一种表达式语言，也就是一段代码</p> 
<p>表达式可以写的随意一点，即这个表达式对于这个方法的表达而言没有显示的返回语句</p> 
<pre><code>() -&gt; a+b ,返回a+b的值
</code></pre> 
<p>上面那个方法体中只有一个数字1 所以运行程序的时候，返回的就是这个方法的值</p> 
<p>那么如何编译？</p> 
<p>coolc就是cool的编译器，</p> 
<p><code>coolc 1.cl</code></p> 
<p>就会生成1.s的新文件，</p> 
<p>我们尝试运行，spim（mips模拟器）</p> 
<p>接着出现了一些数据，例如 执行了多少条指令，load指令，store指令，和一些分支的数量</p> 
<p><img src="https://images2.imgbox.com/48/b9/spXdogVa_o.png" alt="image-20220115201325968"></p> 
<p><img src="https://images2.imgbox.com/09/4e/EVRQEqBC_o.png" alt="image-20220115201354908"></p> 
<pre><code>spim 1.s
</code></pre> 
<p><img src="https://images2.imgbox.com/28/bf/YN57u4Eo_o.png" alt="image-20220115201413073"></p> 
<p>stat里面的参数是为了让我们进行优化使用的，现在我们不需要考虑</p> 
<p>如果在cool程序中打印出某些内容，则必须对此操作进行明确声明</p> 
<p>cool中有特殊的类，也就是IO原始类</p> 
<p>可以为main这个类进行属性的声明，我们声明一个属性为IO的i变量，同时给i分配一个新的对象，之后就能用它进行IO操作了</p> 
<pre><code>class Main{
	i : IO &lt;- new IO;
	main():Int{
	1
	};
};
</code></pre> 
<p>在main方法中，添加out_string的调用，</p> 
<p><code>i.out_string()</code> 就是我们调用方法的方式</p> 
<p>我们尝试输出helloworld</p> 
<p><img src="https://images2.imgbox.com/8c/c1/1WFhZfIa_o.png" alt="image-20220115205628141"></p> 
<pre><code>class Main{
	i : IO &lt;- new IO;
	main():Int{
		{
		i.out_string("Hello World\n");
		1;
	};
};
</code></pre> 
<p>方法中语句块由用分号分隔的一系列表达式组成，</p> 
<p>tips：</p> 
<p>感叹号小贴士</p> 
<pre><code>!运算符跟着之前输入的命令前缀，就可以执行之前的命令
例如：
执行过coolc 1.cl
那么我们执行
!c
和coolc 1.cl是一样的
</code></pre> 
<p>修改：</p> 
<p>{i.out_string(“hello world”);}1; 很繁琐，修改成如下问题，但是返回值类型会不同，不是int了，类型匹配出错</p> 
<pre><code>class Main{
	i : IO &lt;- new IO;
	main():Int{
	i.out_string("Hello World\n");
	};
};
</code></pre> 
<p>因此我们修改成IO</p> 
<pre><code class="prism language-cool">class Main{
	i : IO &lt;- new IO;
	main():IO{
	i.out_string("Hello World\n")
	};
};
</code></pre> 
<p>当然我们可以增加自己的灵活性</p> 
<p><img src="https://images2.imgbox.com/0f/5d/Onns1QeU_o.png" alt="image-20220115205916729"></p> 
<p>main返回结果设置为object</p> 
<pre><code>class Main{
	i : IO &lt;- new IO;
	main():Object{
	i.out_string("Hello World\n");
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/ad/84/GP7VIid5_o.png" alt="image-20220115205952590"></p> 
<p>这里我们在外面进行定义，我们可以直接在里面调用</p> 
<pre><code>class Main{
	main():Object{
	(new IO).out_string("Hello World\n");
	};
};
</code></pre> 
<p>或者说，我们main类直接继承io，main就能够拥有io的所有功能,cool中self等于this</p> 
<pre><code>class Main inherits IO{
	main():Object{
	self.out_string("Hello World\n");
	};
};
</code></pre> 
<p>或者，cool的特性，不显式命名调用对象的情况下调用方法默认为self</p> 
<pre><code>class Main inherits IO{
	main():Object{
	out_string("Hello World\n");
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/69/aiCoTuv8_o.png" alt="image-20220115210052980"></p> 
<h3><a id="0202_Cool_Example_II_15m04scool2_582"></a>02-02: Cool Example II (15m04s)【cool样例2】</h3> 
<p>这次我们写阶乘，不写hello world</p> 
<pre><code>class Main{
	main():Object{
		(new IO).out_string("1\n")
	};
};
</code></pre> 
<p>我们想让用户输入，然后进行输出</p> 
<p>需要调用in_string,同时为了美观，我们组合一个换行</p> 
<pre><code>class Main{
	main():Object{
		(new IO).out_string((new IO).in_string().concat("\n"))
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/96/RL3yPvEf_o.png" alt="image-20220116185309293"></p> 
<p>我们输入多少，就会返回多少</p> 
<p>接下来，我们讨论如何将字符串转换为整数</p> 
<p>阶乘计算需要对数字，我们这里接受的是字符串</p> 
<p>cool中有一个专门编写的库用来做整数和字符串之间的转换</p> 
<p>也就是A2I 意思是ascii码转换为整数</p> 
<pre><code>class Main inherits A2I{
	main():Object{
		(new IO).out_string(i2a(a2i((new IO).in_string())+1).concat("\n"))
	};
};
</code></pre> 
<p>代码的意思就是，输入的字符串ascii转整数 然后加一然后 整数转ascii（字符串）输出</p> 
<p>但是编译器中没有提供a2i的相关函数，需要我们在编译的时候，指明我们需要的函数，</p> 
<pre><code>coolc fact.cl atoi.cl
</code></pre> 
<p><img src="https://images2.imgbox.com/51/2c/oVA0nukq_o.png" alt="image-20220116191215298"></p> 
<p>我们找到相关atoi.cl库函数</p> 
<p>复制到code中，即可编译完成</p> 
<p><img src="https://images2.imgbox.com/2f/47/6BKYNKyN_o.png" alt="image-20220116191308282"></p> 
<p><img src="https://images2.imgbox.com/0a/f4/ejfzMFE0_o.png" alt="image-20220116191331658"></p> 
<p>我们来编写阶乘，需要调用fact（阶乘）函数</p> 
<p>在cool中，if的结构是 if-then-else-fi 也就是一个完整定义</p> 
<p>这里可能会感到奇怪，i=0不是赋值么，但是这里确实是一个判断</p> 
<pre><code>class Main inherits A2I{
	main():Object{
		(new IO).out_string(i2a(fact(a2i((new IO).in_string())).concat("\n"))
	};

    fact(i:Int):Int{
        if(i = 0) then 1 else i * fact(i-1) fi
    };
};
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/6a/9YLMHJUY_o.png" alt="image-20220116201526983"></p> 
<p>我们尝试把i == 0试试</p> 
<p><img src="https://images2.imgbox.com/7d/e5/7Q8vbe99_o.png" alt="image-20220116201607033"></p> 
<p>发现编译失败</p> 
<p>我们接下来使用循环来写阶乘</p> 
<p>我们在cool中使用let声明局部变量</p> 
<p>定义fact值为1</p> 
<p>cool中赋值为<code>&lt;-</code></p> 
<p>循环的开始和结束是loop和pool</p> 
<p>最后一个语法块的值，就是这个方法的返回值</p> 
<pre><code>class Main inherits A2I{
	main():Object{
		(new IO).out_string(i2a(fact(a2i((new IO).in_string()))).concat("\n"))
	};

    fact(i:Int):Int{
        let fact:Int &lt;- 1 in{
  			while(not (i = 0)) loop
            {
            	fact &lt;- fact *i;
            	i &lt;- i-1;
            }
            pool;
            fact;
        }
    };
};
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/22/vL5hAZr5_o.png" alt="image-20220116225035970"></p> 
<p><img src="https://images2.imgbox.com/32/32/QuBOLNg7_o.png" alt="image-20220116225045536"></p> 
<h3><a id="0203_Cool_Example_III_18m05scool3_705"></a>02-03: Cool Example III (18m05s)【cool样例3】</h3> 
<p>本次课程，我们学习创建list</p> 
<p>let表达式可以定义多个常量,使用逗号做分隔符</p> 
<pre><code>class Main inherits IO{
	main() : Object{
	let hello : String &lt;- "Hello",
	    world : String &lt;- "World!!",
	    newline : String &lt;- "\n"
	in
		out_string(hello.concat(world.concat(newline)))
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/e4/NbElhbIX_o.png" alt="image-20220117152937329"></p> 
<p>没有问题</p> 
<p>然后，我们不使用这样的引入，而是使用一个抽象的list，构建字符串列表</p> 
<p>list都会包含两部分，一个是值，一个是next指针指向其他list</p> 
<p>nil:List 如果不赋值，默认是为空的也就是void</p> 
<p>isvoid cool自带的检查是否为空</p> 
<pre><code>class List{
	item:String;
	next:List;
	
	init(i:String, n:List):List{
		{
			item&lt;-i;
			next&lt;-n;
			self;
		}
	};
	
	flatten():String{
        if(isvoid next) then
            item
        else
            item.concat(next.flatten())
        fi
    };
};
class Main inherits IO{
	main() : Object{
	let hello : String &lt;- "Hello",
	    world : String &lt;- "World!!",
	    newline : String &lt;- "\n",
	    nil:List,
	    list:List &lt;- (new List).init(hello,(new List).init(world,(new List).init(newline,nil)))
	in
		out_string(list.flatten())
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/cc/dAIYw3MU_o.png" alt="image-20220117165446742"></p> 
<p>同样，成功输出</p> 
<p>我们这里item可以进行修改，成为object</p> 
<p>同时，我们需要修改flatten，通过case进行选择他的类型进行输出</p> 
<p>如果传入int 那就i2a，其他同理</p> 
<p>abort函数，终止并退出,返回一个object对象，但是这里的case需要返回stirng对象，我们放入语句块中</p> 
<p>case分支必须分号结束</p> 
<pre><code>class List inherits A2I{
	item:Object;
	next:List;
	
	init(i:Object, n:List):List{
		{
			item&lt;-i;
			next&lt;-n;
			self;
		}
	};
	
	flatten():String{
       let string:String &lt;-	
       	   case item of
       	   		i:Int =&gt; i2a(i);
       	   		s:String =&gt;s;
       	   		o:Object =&gt;{abort();"";};
       	   esac
       	in
       		if(isvoid next) then
           		string
            else
                string.concat(next.flatten())
            fi
    };
};
class Main inherits IO{
	main() : Object{
	let hello : String &lt;- "Hello",
	    world : String &lt;- "World!!",
	    i:Int &lt;-42,
	    newline : String &lt;- "\n",
	    nil:List,
	    list:List &lt;- (new List).init(hello,
	    					(new List).init(world,
	    							(new List).init(i,(new List).init(newline,nil))))
	in
		out_string(list.flatten())
	};
};
</code></pre> 
<p><img src="https://images2.imgbox.com/bd/e9/xOtdzCH4_o.png" alt="image-20220117171820955"></p> 
<p><img src="https://images2.imgbox.com/48/eb/yk3Z5cPp_o.png" alt="image-20220117171939514"></p> 
<h2><a id="CS143_Week2_Lexical_AnalysisFinite_Automata_833"></a>CS-143 Week2 Lexical Analysis&amp;Finite Automata[词法分析和有限自动机]</h2> 
<h3><a id="0301_Lexical_Analysis_12m06s_835"></a>03-01: Lexical Analysis (12m06s)【词法分析】</h3> 
<p><img src="https://images2.imgbox.com/7b/17/As5Fvpjm_o.png" alt="image-20220117230455219"></p> 
<p>我们对该段进行分割</p> 
<pre><code>if(i == j)
	z = 0;
else 
	z = 1;
</code></pre> 
<p>将他们转换成为（token）词法单元，if，变量名 i,n,j 关系运算符，== 之类的</p> 
<p>在词法分析器的眼中，是这样的</p> 
<p><img src="https://images2.imgbox.com/7a/1b/ipoZihM9_o.png" alt="image-20220117230652340"></p> 
<pre><code>\tif(i==j)\n\t\tz=0;\n\telse\n\t\tz=1;
</code></pre> 
<p>整个代码就像字符串，也可以类比作为字节</p> 
<p>词法分析器通过绘制分割线，将字符串转换为词法单元</p> 
<p><img src="https://images2.imgbox.com/26/5c/ND2jB5wm_o.png" alt="image-20220117230859758"></p> 
<h4><a id="Token_class_864"></a>Token class（标记类）</h4> 
<p>光分词法单元是不行的，需要根据作用进行分类</p> 
<p><img src="https://images2.imgbox.com/df/50/KuBT7ysn_o.png" alt="image-20220117231116936"></p> 
<p>这里类比在英语中，和在编程语言中的标记类</p> 
<p>每个标记类，都会对应程序中的一组字符串，</p> 
<p>比如：</p> 
<p>名词：apple，banana，。。。</p> 
<p>keywords：if，else，while</p> 
<p><img src="https://images2.imgbox.com/b6/fe/cgFBR4yR_o.png" alt="image-20220117231829212"></p> 
<p>标记类对应一组字符串，也就是，这组字符串可以用来被标记类描述</p> 
<pre><code>
identifier（标识符）

大多数编程语言中，标识符的标记类是字母或数字，以字母开头

例子：C语言中

integer（整数）

非空数字字符串
例：0，12，001，00，
keyword：
keywords：if，else，while

whitespace（空格）
空格也是一个标记类
例：if_ _ _()这里三个空格，就会被当作一个空格

</code></pre> 
<p><img src="https://images2.imgbox.com/56/ee/3cMT1Blq_o.png" alt="image-20220117232258929"></p> 
<p>词法分析的目标是根据程序的子串的角色，然后对其进行分类</p> 
<p>这里的role就是一个标记类</p> 
<p>然后把标记类传递给解析器</p> 
<p>这里是词法分析器和解析器之间的传递</p> 
<p><img src="https://images2.imgbox.com/22/f2/CjJhlHUy_o.png" alt="image-20220117233018987"></p> 
<p>1- 词法分析器获取到字符串，并存储为字节序列</p> 
<p>2-发送给解析器的时候是一个序列对<code>&lt;class,string&gt;</code>,也就是，标记类和你的子字符串，也就是<code>&lt;class,string&gt;</code> 这个pair叫做token</p> 
<p>例如：</p> 
<p>如果字符串是</p> 
<p>“foo = 42”</p> 
<p>会传递三个token（词法单元）</p> 
<p>&lt;identifier,“foo”&gt;,&lt;operator,"="&gt;,&lt;“integer”,“42”&gt;</p> 
<p>传递的单元是以字符串形式来存储的，这里的<code>42</code>也是字符串</p> 
<p>这些序列传递给解析器</p> 
<pre><code>词法分析器本质：
输入字符串并将其分块儿为成对的序列，其中每一个对都是一个标记类和原始输入的子字符串
</code></pre> 
<h4><a id="_942"></a>样例分析</h4> 
<pre><code>\tif(i==j)\n\t\tz=0;\n\telse\n\t\tz=1;
</code></pre> 
<p>我们首先写一下标记类</p> 
<pre><code>whitespace  空格，回车，tab
keywords
identifiers
numbers（integer）
operator

</code></pre> 
<p>特例： <code>(</code> 、<code>)</code> 、<code>;</code>、<code>=</code> 这四个是单字符标记类,一组中只有这一个字符串</p> 
<p>但是一个特殊的<code>==</code> 归类为关系运算符的标记类</p> 
<p>这里使用开头首字母当作划分</p> 
<pre><code>\tif(i == j)\n\t\tz=0;\n\telse\n\t\tz=1;

w|k|(|i|w|o|w|i|)|w|w|w|i|=|n|;|w|w|k|w|w|w|i|=|n|;
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/9d/9C8jjWDI_o.png" alt="image-20220117234252414"></p> 
<h4><a id="Summarize_977"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/90/c0/MUFkFRDO_o.png" alt="image-20220117232922147"></p> 
<p>总结两点，</p> 
<p>第一个：识别输入中与标记相对应的子字符串</p> 
<p>tips 这是编译器的术语，这些子字符串称为词素lexemes（构成词的要素）</p> 
<p>第二个，对于每个词素，我们需要确定标记类token class</p> 
<p><code>&lt;token class,lexemes&gt;</code> 等于<code>token</code></p> 
<h4><a id="Quiz_991"></a>Quiz</h4> 
<p><img src="https://images2.imgbox.com/a0/12/pHfkK46w_o.png" alt="image-20220118224348639"></p> 
<pre><code>x=0;\n\twhile (x &lt; 10) { \n \tx++; \n }
W: Whitespace
K: Keyword
I: Identifier
N: Number
O: Other Tokens:
{ } ( ) &lt; ++ ; =
ionowwkwoiwownwowwwwioowwwo
虽然对空格有异议，但是I K N 是固定的，3 1 2

</code></pre> 
<pre><code>Note that '\t\n' is a single whitespace token. Also remember that 'x' is an identifier but 'while' is a keyword. Finally, note that '++' and '10' are both single tokens.
请注意“\t\n”是单个空白标记。还要记住，“x”是一个标识符，“while”是一个关键字。最后，请注意，'+'和'10'都是单个标记。
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/40/9IOlvTcN_o.png" alt="image-20220118234521133"></p> 
<h3><a id="0302_Lexical_Analysis_Examples_13m03s_1015"></a>03-02: Lexical Analysis Examples (13m03s)【词法分析案例】</h3> 
<p><img src="https://images2.imgbox.com/2a/45/bscB8Msj_o.png" alt="image-20220118145448794"></p> 
<p>在fortran中，空格是不重要的</p> 
<p>例如:<code>VAR1</code> 和 <code>VA R1</code>是一样的</p> 
<p>fortran理念：你可以将程序中所有的空格删除，但是不会改变你程序想要表达的东西</p> 
<p>tips:以后的例子部分来自龙书🐉</p> 
<p><img src="https://images2.imgbox.com/b9/66/ED3mj7ML_o.png" alt="image-20220118150158152"></p> 
<p>这个例子是FORTRAN循环的头部</p> 
<p><code>do</code> 是循环的关键词，<code>i</code>的变换区间是在1-25</p> 
<p><code>5</code>是用来规定循环的范围</p> 
<pre><code> -do 5
|
|
|
|
|_
一共是延伸五个标签
</code></pre> 
<p><img src="https://images2.imgbox.com/49/58/pg6OnWE2_o.png" alt="image-20220118151941541"></p> 
<p><img src="https://images2.imgbox.com/c0/e8/aRiaDvjx_o.png" alt="image-20220118151947324"></p> 
<p>根据标点的不同，第二行的作用也就不同，</p> 
<p>第二行，<code>do 5 I</code> <code>5 I</code> 5空格I其实是变量名 ，也就是说，第二行是赋值语句</p> 
<p><code>DO 5I=1.25</code></p> 
<p>我们怎么能够知道DO是干什么的？</p> 
<p>从左到右逐个字符进行扫描，然后通过lookahead 向前看，许许多多的向前看</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uAxJVCfb-1642520737888)(https://gitee.com/dingpengs/image/raw/master/imgwin/image-20220118153653605.png)]</p> 
<p>在1之前，两者完全一致，当到了<code>,.</code>的时候，才会区分出来DO的作用</p> 
<p>因此，词法分析系统的目标：最小化向前看，或者限定需要向前看的内容数量</p> 
<p>为什么FORTRAN对空格不做检查？</p> 
<p>因为对于打点编程，如果不忽略，容易造成误操作</p> 
<p><img src="https://images2.imgbox.com/70/b2/KF8lhwYL_o.png" alt="image-20220118193307651"></p> 
<p>翻译：这里的目标是为了将字符串分割，（也就是分割字符串，变为逻辑单元），从左到右扫描读取实现的，一次识别一个token</p> 
<p><img src="https://images2.imgbox.com/dc/97/5WyGUj3c_o.png" alt="image-20220118194531588"></p> 
<p>翻译：“回顾”也许就是决定一个词法单元的呢结束与下一个词法单元的开始</p> 
<p><strong>始终需要向前看（回顾）</strong></p> 
<h4><a id="lookahead_1079"></a>为什么需要lookahead</h4> 
<p><img src="https://images2.imgbox.com/c9/0a/qycHa9lO_o.png" alt="image-20220118194737227"></p> 
<p>假设我们读取到了<code>else</code>,这里存在lookahead问题，我读取e，是当作keyword，还是当作变量，还是某个大型语法单元的一部分呢？（因为变量i，z都存在对吧）</p> 
<p>另一个是等于号，读取一个<code>=</code> 我们需要判断赋值过程中的等于号还是<code>==</code></p> 
<p>这些情况下，我们都需要lookahead</p> 
<h4><a id="PL1_keywords_are_not_reserved_1089"></a>PL/1 keywords are not reserved</h4> 
<p><img src="https://images2.imgbox.com/84/8d/b2OgiFPq_o.png" alt="image-20220118200039288"></p> 
<p>pl/1 programming language one(第一编程语言) IBM设计</p> 
<p>这里是他的一个例子</p> 
<p>example1</p> 
<p>PL特性：不保留关键字，也就是可以使用关键字当作变量名</p> 
<p>结构if-then-else,结构如下</p> 
<p><code>IF</code> Else <code>THEN</code> then = else;<code>ELSE</code> else = then</p> 
<p>这造成词法分析很复杂</p> 
<p>example2</p> 
<p><img src="https://images2.imgbox.com/05/94/Ua7cghBK_o.png" alt="image-20220118200603961"></p> 
<p>DECLARE（ARG1…ARGN）</p> 
<p>declare有n个参数，既可能表达keyword，也可能表达数组的引用</p> 
<p>因此这个在词法分析器中的判断，需要lookahead，判断declare后面是否存在<code>=</code> 存在即为赋值，也就是作为了数组的名称</p> 
<p>C++的bug</p> 
<p><img src="https://images2.imgbox.com/54/f6/zCzgeczP_o.png" alt="image-20220118201556776"></p> 
<p>C++中，<code>&gt;&gt;</code> <code>&lt;&lt;</code> 被当作输入输出流</p> 
<p>如果在模板类中，<code>Foo&lt;Bar&lt;Barz&gt;&gt;</code></p> 
<p>这里就会存在bug，在词法分析器中会当作输入输出流</p> 
<p>因此，如果模板类需要能够使用，这里需要加空格</p> 
<p>也就是</p> 
<p><code>Foo&lt;Bar&lt;Barzz&gt;_&gt;</code> 这里的下划线是空格</p> 
<h4><a id="Summarize_1137"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/72/0b/NwF9GVTX_o.png" alt="image-20220118195632258"></p> 
<p>词法分析的目标是将输入流划分为词素</p> 
<p>辨别每个词素的标记</p> 
<p>正因为我们从左向右扫描，因此我们必须lookahead，回顾，才能够弄清楚当前正在查看的字符串，子字符串，的角色</p> 
<h3><a id="0303_Regular_Languages_Part_1_11m48spart1_1149"></a>03-03: Regular Languages Part 1 (11m48s)【正则语言part1】</h3> 
<p><img src="https://images2.imgbox.com/f5/9a/GlIt4tFI_o.png" alt="image-20220118225209382"></p> 
<p>简要回顾token/tokenclass</p> 
<p>我们需要使用一种方法来指定每个字符串集所属的标记类，通常使用的是正则</p> 
<h4><a id="regular_expressions__1157"></a>regular expressions 正则表达式</h4> 
<p>每个正则就是一个集合</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qDD9tt3C-1642520737899)(https://gitee.com/dingpengs/image/raw/master/imgwin/image-20220118225559463.png)]</p> 
<h5><a id="_1163"></a>基本表达式</h5> 
<p>对于单个字符，他的表达式所表示的集和就是这个单个字符</p> 
<p>对于Epsilon（ε）代表的是一个单个字符的空字符串，<strong>不是空表达式，不代表空字符串</strong></p> 
<h5><a id="_1169"></a>复合正则表达式</h5> 
<p><img src="https://images2.imgbox.com/b6/4d/dfJ4aTrI_o.png" alt="image-20220118231335255"></p> 
<p>第一个，并集比较好理解，也就是</p> 
<p><code>A+B</code> 代表 A的集合和B的集合 合并</p> 
<p>{1，2，3} {4，5，6} = {1，2，3，4，5，6}</p> 
<p>第二个，级联<code>AB</code> 相当于所有来自A表达式所示集合的小a,与来自B表达式所示集合小b进行级联</p> 
<p>也就是 一个叉积的操作</p> 
<p>{a,b}与{c,d}级联得到{ac,ad,bc,bd}</p> 
<p>第三个</p> 
<p><code>A*</code> A STAR</p> 
<p>A的i次方表示他自己和自己级联i次，这里也就是A^i</p> 
<p>当i等于0的时候，也就是A^0 这个时候也就代表ε（Epsilon） 这个表达式包含空字符串</p> 
<p><strong>也就是空字符串永远是A*的一个元素</strong></p> 
<p><img src="https://images2.imgbox.com/f5/71/SAz9rCGt_o.png" alt="image-20220118232141428"></p> 
<p>匹配字母表的正则表达式<code>Σ</code>是最小表达式的集合</p> 
<p>也就是说，我们先定义一个集合R，它包含哪些呢？</p> 
<p>R = ε 因为ε永远是他的一个元素，代表了一个空字符串</p> 
<p>或者他是单字符串c，c表示字母表中的一个元素</p> 
<p>R+R代表的是一个正则和一个正则的集合/并集</p> 
<p>RR代表的是正则的级联</p> 
<p>R*则代表正则表达式的迭代</p> 
<p><strong>这五个例子是基于给定字母表的正则表达式集</strong>，也即是R的所有情况</p> 
<p>如上 也就是正则的语法</p> 
<h4><a id="example_1215"></a>example</h4> 
<p>我们需要知道组成正则的字母有哪些，这里简化使用了0，1</p> 
<p><code>Σ={0，1}</code></p> 
<p><img src="https://images2.imgbox.com/d6/79/EylsC44z_o.png" alt="image-20220118233029307"></p> 
<p><code>1*</code> 的正则表达式 *代表着从1到i的并集，i大于等于0</p> 
<p>也就是<code>""(空字符串)+1+11+111+1111+11111+111（i个1）111</code> 这就是<code>1*</code>的所有字符串</p> 
<p><img src="https://images2.imgbox.com/ba/33/EFPGEhWb_o.png" alt="image-20220118233317553"></p> 
<p>第二个例子<code>(1+0)1</code> 也就是{ab|a∈1+0 且 b∈ 1}</p> 
<p>最终结果就是{11，01}</p> 
<p><img src="https://images2.imgbox.com/f7/41/1OF3WxpI_o.png" alt="image-20220118233412645"></p> 
<p>第三个例子 <code>0*+1*</code></p> 
<p>0*代表的只有0字符串</p> 
<p><img src="https://images2.imgbox.com/fe/cf/Y1xqtEm3_o.png" alt="image-20220118234248206"></p> 
<p>第四个例子<code>(0+1)*</code> 也就是<code>""(空字符串)+(0+1)+(0+1)(0+1)+(0+1)(0+1)(0+1)+(0+1)(0+1)(i个（0+1）)(0+1)</code></p> 
<p><code>(i个（0+1）)</code> 代表的是 有i长度的字符串，每个位置都能用0/1来替代</p> 
<p>第四个例子整体的意思就是，我们整个字符串 由0和1 组成不论长度</p> 
<p>当你有一个正则表达式可以从字母表（也就是所给的集合） 中形成的所有字符串的集合时候，就会有一个特殊的名称<code>Σ*</code></p> 
<p>也就意味着所有字母字符串都可以根据需要进行多次级联</p> 
<p><strong>同时，不同的表达式能够表达完全相同的集合</strong></p> 
<p>比如第二个例子，<code>11+10</code> === <code>(1+0)1</code></p> 
<p>或者 <code>1*</code> 和 <code>1*+1</code></p> 
<h4><a id="Quiz_1260"></a>Quiz</h4> 
<p><img src="https://images2.imgbox.com/23/4c/pjUG2ySP_o.png" alt="image-20220119132214885"></p> 
<p>需要选择结果相同的</p> 
<p><code>(0+1)* 1(0+1)*</code></p> 
<p>这个的意思就是 由0和1组成的任意字符串</p> 
<p>第二部分的意思就是 <code>(0+1)*</code> 每一个字符配一个1组成一个集合</p> 
<p>也就是 任意字符串+1+任意字符串</p> 
<p>我们在选项中，挑选一个合适的</p> 
<p>这里因为是多选，答错了（焯）</p> 
<p><img src="https://images2.imgbox.com/6e/9b/LBGkl4rY_o.png" alt="image-20220119133311927"></p> 
<pre><code>给定的正则表达式要求每个字符串至少有一个1，且在1之前或之后有任意数字组合。因此，排除了第一个和第四个选项，因为这两个选项都接受字符串“0”。第二个选项是等效的，因为中间词“（10+11+1）”保证字符串中有一个1，实际上这个表达式可以替换为“1”，而不影响语言。第三个选项是等效的，因为“+”是可交换的，“（0+1）”可以替换为“（1+0）”。
</code></pre> 
<h4><a id="Summarize_1290"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/5b/41/ViipGXwA_o.png" alt="image-20220118230905212"></p> 
<p>我们学了正则表达式的语法，（正则语言）</p> 
<p>标准定义中有五种正则表达式，</p> 
<p>一个空字符串表达式ε，一个只包含一个字符的所有字符串表达式</p> 
<p>三个复合表达式，并集，级联，迭代，</p> 
<h3><a id="0304_Formal_Languages_13m40s_1302"></a>03-04: Formal Languages (13m40s)【形式语言】</h3> 
<p>在编译器内部，通常会操作多种不同的formal languages，正则表达式就是形式语言中的一个例子</p> 
<p>形式语言的定义：</p> 
<p><img src="https://images2.imgbox.com/b2/3b/OikCthp8_o.png" alt="image-20220119134257693"></p> 
<p>一个形式语言要有一个字符集（就如同ascii字符集），使用Σ来指代这个字符集</p> 
<p>那么Σ对于这个formal language 指代的就是一组字符串</p> 
<p>总的来说 一个形式语言就是基于一些字符所构建的任意字符集</p> 
<p>在这个例子中（正则语言），我们由几种方式来创建字符集</p> 
<p>例子：<code>Σ ={1，2}</code></p> 
<p><img src="https://images2.imgbox.com/b7/f0/ATI0A5bx_o.png" alt="image-20220119140246823"></p> 
<p>一个比较熟悉的例子就是英文字母表，可构成单词，可构成句子</p> 
<p>但是不能叫做严谨的formal language，有些构成的句子不是句子</p> 
<p>严谨的formallanguage是：</p> 
<p><img src="https://images2.imgbox.com/b6/53/U9Y0p4cF_o.png" alt="image-20220119140502782"><br> Aplhabet = ASCII</p> 
<p>ASCII作为c编译器的所接受的输入集</p> 
<p><img src="https://images2.imgbox.com/c2/68/EnFkefGt_o.png" alt="image-20220119140608534"></p> 
<p>另一个重要的概念是meaning function</p> 
<p>例如：<code>f(x) = a(x)+b(x)</code> 在编译器编译的时候直接替换为<code>a(x)+b(x)</code></p> 
<p><img src="https://images2.imgbox.com/76/e4/SB8FR9R9_o.png" alt="image-20220119140806911"></p> 
<p>L(e)是正则表达式，M是对应的字符集</p> 
<p>这是由正则表达式所表示的正则语言，</p> 
<p>然后我们取上节课的例子</p> 
<p><img src="https://images2.imgbox.com/c6/10/QtioZ2HW_o.png" alt="image-20220119140946814"></p> 
<p>左边是表达式，右边是集合</p> 
<p>A是表达式 a是集合 a属于A，即a复合A这个表达式的规则</p> 
<p>meaning function就是为了解决这些问题，使得定义明确</p> 
<p><img src="https://images2.imgbox.com/19/51/QcqehktZ_o.png" alt="image-20220119141226788"></p> 
<p>关于正则表达式含义的正确定义，我们使用L(…) 来进行显式表达</p> 
<p>通过L(…) 递归的将符合表达式分解为多个子表达式</p> 
<p>也就是对子集 计算得到最终的集合</p> 
<p><img src="https://images2.imgbox.com/fa/8a/Z0slHRxD_o.png" alt="image-20220119141352506"></p> 
<p>为什么使用meaning function</p> 
<p>1- 确保语法清晰，语义清晰，（表达式AB，集合ab）</p> 
<p>2-允许我们考虑 语法和语义分开，改变语法，语义不变</p> 
<p>3- 语法和语义不是一对一的 多个表达式一个意思</p> 
<p>语法和语义分开的好处</p> 
<p><img src="https://images2.imgbox.com/ea/24/9KBfdUxc_o.png" alt="image-20220119141621722"></p> 
<p>罗马数字和阿拉伯数字，同样的意思，但是写起来，做起来的语法完全不同，难度也不同</p> 
<p>符号非常重要，能够决定你的思维方式，这也是分离语法和语义的重要原因</p> 
<p>多个表达式表达一个语义</p> 
<p><img src="https://images2.imgbox.com/c7/33/ZvoxJuzQ_o.png" alt="image-20220119141758628"></p> 
<p><code>0*</code> <code>0+0*</code> 等等，这些都表达一个意思</p> 
<p><img src="https://images2.imgbox.com/96/19/wHkn2rnH_o.png" alt=""></p> 
<p>左侧代表不同的表达式，右侧代表语义</p> 
<p>这就是formal languages 的一个通用特征，</p> 
<p>对编译器非常重要，这就是优化的基础</p> 
<p><img src="https://images2.imgbox.com/42/60/UoFjqSzD_o.png" alt="image-20220119141941419"></p> 
<p>含义是多对一的关系， <strong>绝不是一对多</strong></p> 
<h3><a id="0305_Lexical_Specifications_16m19s_1409"></a>03-05: Lexical Specifications (16m19s)【词法规则】</h3> 
<h4><a id="keyword_1411"></a>keyword</h4> 
<p><img src="https://images2.imgbox.com/4f/ac/NyFsHWJ0_o.png" alt="image-20220119182833082"></p> 
<p>我们首先来写一个if的正则表达式</p> 
<p>也就首先是i的和f的，然后串联在一起,然后与else做一个并联</p> 
<p><code>'i''f' + 'e''l''s''e'</code></p> 
<p>很显然，这个else比较复杂，我们选用c系列，（单个字符的系列也可以）</p> 
<p><code>'if'+'else'+'then'+'...'</code></p> 
<h4><a id="integer_1425"></a>integer</h4> 
<p><img src="https://images2.imgbox.com/94/b6/Bz3XpMcx_o.png" alt="image-20220119183128851"></p> 
<p>一个非空的数字字符串</p> 
<p>如下也就是单个数字的对应字符串集合的正则表达式</p> 
<p><code>'0'+'1'+'2'+'3'+'4'+'5'+'6'+'7'+'8'+'9'</code></p> 
<p>因为比较常用，因此我们可以定义为一个常量</p> 
<p>digit = <code>'0'+'1'+'2'+'3'+'4'+'5'+'6'+'7'+'8'+'9'</code></p> 
<p>这个digit正则表达式 可以表示集合中的任意一个数字</p> 
<p>多个数字如何匹配?我们可以做一个简单的迭代，并将空字符串去掉</p> 
<p><code>digit digit*</code></p> 
<p>这样的迭代就保证了，开头必须一个数字，后面紧跟0或者更多其他的数字</p> 
<p>例如：至少要一个A 就可以写成<code>AA*</code> 每个正则都会支持，<code>A^+</code> === <code>AA*</code></p> 
<p><img src="https://images2.imgbox.com/ad/d1/XaliSfEE_o.png" alt="image-20220119184234591"></p> 
<h4><a id="identifier_1451"></a>identifier</h4> 
<p><img src="https://images2.imgbox.com/ca/9a/4SG1eadz_o.png" alt="image-20220119184406235"></p> 
<p>由字母和数字组成的字符串，以字母开头</p> 
<p>我们直接定义一个所有字母的letter</p> 
<p>letter = <code>'a'+'b'+'c'+'d'+'e'+'...'</code></p> 
<p>同时我们可以简写为：(通过使用character range的正则表达式)</p> 
<p>letter = <code>[a-zA-Z]</code></p> 
<p>最终的结果就是<code>letter(letter+digit)*</code></p> 
<h4><a id="whitespace_1467"></a>whitespace</h4> 
<p><img src="https://images2.imgbox.com/81/cd/455k0fK7_o.png" alt="image-20220119190232812"></p> 
<p>需要识别tab 空白，换行 rubout（退格）等非空序列,因为是要非空的，因此我们直接加puls</p> 
<p><code>(' '+'\n'+'\t')^+</code></p> 
<h4><a id="example_1475"></a>课外example</h4> 
<p>邮件的匹配</p> 
<p><code>xxxxx@cs.stanford.edu</code></p> 
<p><code>letter^+'@'letter^+'.'letter^+'.'letter^+</code></p> 
<p><img src="https://images2.imgbox.com/06/30/tAHy2xkV_o.png" alt="image-20220119191755051"></p> 
<p>ALGOL语言家族中的Pascal语言，和fortran 和c是同一个家族</p> 
<p><img src="https://images2.imgbox.com/49/23/gXYZfYZy_o.png" alt="image-20220119191811084"></p> 
<p>他的num 数字由 digits opt_fraction(分数) opt_exponent(表示指数) 组成</p> 
<p>digit 通用数字的并集</p> 
<p>digits是<code>digit^+</code> 非空数字集合</p> 
<p>如何定义的的分数和指数呢？</p> 
<p>分数实际上就是 小数，</p> 
<p>opt_fraction = <code>('.'digits)</code></p> 
<p>第一个部分表示小数点后跟着一连串数字，ε 表示这个数字的分数部分可以存在或者完全不存在，也就表示了这部分是可选的</p> 
<p>也就是可选分数</p> 
<p>可选指数 也同样是因为和ε做了并集，这样的话，整个指数部分就是可选的</p> 
<p><code>3298e+10</code></p> 
<p><code>('E'('+'+'-'+ε)digits)</code></p> 
<p>指数永远E开头 ，digits一个非空数字字符串</p> 
<p>他俩中间包含了可选的，中间可有可无，这个符号可以是－ 也可以是+</p> 
<p><code>+</code> 是或的关系</p> 
<p>通常写法：</p> 
<p>把加ε 当作可选的，通常写作<code>('.'digits)?</code></p> 
<p>指数可以写作<code>('E'('+'+'-')?digits)?</code></p> 
<h4><a id="Summarize_1523"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/dc/4e/UATWb6l9_o.png" alt="image-20220119193451768"></p> 
<p>使用正则来描述许多有用的语言（描述email，phone number等）</p> 
<p>正则语言作为一种语言规范，仍然需要一个词法分析的实现</p> 
<p>下次课：判断给定字符串s和一个正则表达式R，如何判断字符串是否在这个正则表达式所定义的集合呢？</p> 
<h3><a id="0401_Lexical_Specification_14m30s2_1534"></a>04-01: Lexical Specification (14m30s)【词法规则2】</h3> 
<p><img src="https://images2.imgbox.com/c2/e5/i6shUA4V_o.png" alt="image-20220120215906261"></p> 
<p>快速总结</p> 
<p>有一个重要的：[a-z]的补集为<code>[^a-z]</code></p> 
<p>表示除了a-z的所有字符</p> 
<p><img src="https://images2.imgbox.com/9e/76/6XPCM4E5_o.png" alt="image-20220120220127529"></p> 
<p>给定的字符串s就是正则表达式所代表的集合中的元素</p> 
<p>L® 他的语义其实就是一系列字符串，s属于L®</p> 
<p><img src="https://images2.imgbox.com/2d/f7/Ww5yg0a5_o.png" alt="image-20220120220343476"></p> 
<p>但是，仅仅能够将字符串归为某一个正则下，回答yes/no，是不够的，我们需要针对正则表达式进行小拓展</p> 
<h4><a id="1Write_a_rexp_for_the_lexemes_of_each_token_class_1556"></a>1.Write a rexp for the lexemes of each token class</h4> 
<p>当我们想要设计一门语言的词法规则的时候，我们需要为词法写出正则表达式</p> 
<p><img src="https://images2.imgbox.com/d0/f0/FC02Wchm_o.png" alt="image-20220120220551880"></p> 
<p>这样才能构成token类</p> 
<p>上图是上节课我们所定义的</p> 
<h4><a id="2Construct_Rmatching_all_lexemes_for_all_tokens_1566"></a>2.Construct R,matching all lexemes for all tokens</h4> 
<p>第二步，我们要做的就是去构建一个能够匹配所有词法单元的负责的正则表达式</p> 
<p>也就是做所有正则表达式的并集</p> 
<p><img src="https://images2.imgbox.com/ca/fb/9QpfOwe1_o.png" alt="image-20220120221124398"></p> 
<h4><a id="3Let_input_be_x1xn_1574"></a>3.Let input be x1…xn</h4> 
<p>假设我们输入的是x1…xn</p> 
<p>然后把每个前缀去检查，是否满足正则表达式的函数</p> 
<p>也就是说，输入abcd</p> 
<p>检查的是</p> 
<p><code>a</code></p> 
<p><code>ab</code></p> 
<p><code>abc</code></p> 
<p><code>abcd</code></p> 
<p>所以叫检查前缀</p> 
<p><img src="https://images2.imgbox.com/3a/cb/Go0ddqgW_o.png" alt="image-20220120221606307"></p> 
<h4><a id="4if_success_then_we_know_that_1596"></a>4.if success ，then we know that</h4> 
<p><img src="https://images2.imgbox.com/db/ba/nmwWsALl_o.png" alt="image-20220120221645585"></p> 
<p>如果匹配成功，我们就能能知道，他这个x1x2x3 是我们token中的一个</p> 
<h4><a id="5remove_x1xi_from_input_and_go_to_3_1602"></a>5.remove x1…xi from input and go to (3)</h4> 
<p>然后我们将前缀进行删除，也就是我们把我们匹配到的删除，然后跳转到第三步，接着去检查前缀</p> 
<p>也就能持续的去检查，直到为空字符串</p> 
<h4><a id="question_1608"></a>question</h4> 
<p>how much input is used?</p> 
<p>输入值中的内容有多少确实被用上了？</p> 
<p><img src="https://images2.imgbox.com/e6/7a/9tOlpPdh_o.png" alt="image-20220120222059553"></p> 
<p>也就是说，我们的开始相同，但是我们的结束不同，那么，token会取哪个？</p> 
<p>example：双等号(==)</p> 
<p>一个等号赋值，两个等号比较运算符</p> 
<p>我们需要的方法是：最长匹配（maximal munch）</p> 
<p>两种都有效，我们选择更长的token</p> 
<p>which token is uesd？</p> 
<p>匹配到多个词法单元，我们选择哪个？</p> 
<p><img src="https://images2.imgbox.com/cc/b5/Tq61o1EZ_o.png" alt="image-20220120222500236"></p> 
<p>也就是说，一个keyword的正则包含if，一个标识符的正则也包含if，</p> 
<p><strong>在大部分语言中，标识符实际上不包含关键字</strong></p> 
<p>因此这里需要采用优先度顺序来进行选择，这个规则优先选用列表在前面的</p> 
<p>优先选出列出的第一个标记类，也就和词法规则中，我们将关键字的匹配放在标识符之前</p> 
<p>what if no rule mathes？</p> 
<p>我输入的前缀不符合词法规范的表达式语言，怎么办？</p> 
<p><img src="https://images2.imgbox.com/4c/e5/2z8ZLUSC_o.png" alt="image-20220120223001932"></p> 
<p>当然是做好错误处理，提供程序员错误的位置和错误类型的反馈</p> 
<p>当然对于词法分析来说，最佳的解决方案是 编写意类错误字符串的正则</p> 
<p>也就是不在语言词法规则中的当做另一个种规则，</p> 
<p>同时，把该规则放在最后面</p> 
<h4><a id="Summarize_1662"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/0a/f6/RkbfK9Ty_o.png" alt="image-20220120223447731"></p> 
<p>翻译：</p> 
<p>正则表达式可以匹配各种字符串类型</p> 
<p>在词法分析种使用需要一些拓展</p> 
<p>消除一些特定的歧义，匹配最长的字符串，最高优先匹配度</p> 
<p>错误的处理，写一个可能错误字符串的正则，赋予最低的优先级</p> 
<p>优秀的一些算法（之后的课程）</p> 
<p>可以只进行一次遍历</p> 
<p>对于每个字符进行很少的操作，仅仅需要一个简单的表的查找</p> 
<h3><a id="0402_Finite_Automata_Part_1_13m01s_1686"></a>04-02: Finite Automata Part 1 (13m01s)【有限自动机】</h3> 
<p>正则实现模型</p> 
<p><img src="https://images2.imgbox.com/0f/84/bapjhpQK_o.png" alt="image-20220121173412054"></p> 
<p>通过有限自动机，来方便大家了解他内部使用正则表达式的实现机制</p> 
<p>正则表达式和有限自动机关系密切，都是同一种语言，也就是正则语言</p> 
<p>有限自动机的标准定义：</p> 
<p>1- 包含了一组能读取的输入字符集</p> 
<p>2-他管理了一系列状态</p> 
<p>3-特殊的一个开始状态</p> 
<p>4- 一组用于接收状态的集合</p> 
<p>（自动机在读取这些它可以接受的状态输入后回自动结束，否则拒绝这些输入，因为他们不符合规则）</p> 
<p>5- 自动机有一些用于状态转化的集合（输入转换到另一种状态）</p> 
<h4><a id="Transition_1710"></a>Transition</h4> 
<p>关于有限自动机的转换细节</p> 
<p><img src="https://images2.imgbox.com/97/22/AGgLMpPB_o.png" alt="image-20220121174358374"></p> 
<p>处于状态（s1） 读取到输入值a，自动机就能将他转换到状态2（s2）</p> 
<p><img src="https://images2.imgbox.com/f6/90/lz9ootjF_o.png" alt="image-20220121174455246"></p> 
<p><img src="https://images2.imgbox.com/eb/50/3DlXdd59_o.png" alt="image-20220121174508635"></p> 
<p>如果输入结束，那么自动机就会以此结尾的输入所转换得到的状态作为接受状态（例如：z=1+a，自动机初始状态为1.接收的输入值是z，我们输入123123，最终的接收状态为224124）</p> 
<p><img src="https://images2.imgbox.com/30/11/BeAl8f6U_o.png" alt="image-20220121174831466"></p> 
<p>如果不满足上面的条件，就会拒绝输入（就好比 写代码过程中，IDE根据输入自动提示错误）</p> 
<p><img src="https://images2.imgbox.com/ef/e3/7WtWsHaF_o.png" alt="image-20220121175522294"></p> 
<p>例如：</p> 
<p>因为状态s而终止，也就是 状态s不属于最终状态集，或者是 接受状态集</p> 
<p>除了以接受的状态结束以外，其他任何状态都将被拒绝</p> 
<p>或者</p> 
<p>如果当机器卡住的时候，意味着他自己处于以重无论输入什么都不会发生转换的状态</p> 
<p>也就是有一个news的状态集 输入了A但是美有规则可以将A转换到对应的指定状态，这样他就卡住了，也算一个拒绝状态</p> 
<p>上面的例子也即是 到达输入的末尾，但是自动机并未处于最终状态或者说，由于卡住永远不会到达末尾，都会拒绝输入</p> 
<p>也就是，</p> 
<p>该字符串不是有限自动机的语言（也可以理解为 没有正则处理的字符串）</p> 
<h4><a id="_1750"></a>另一种有限自动机的表达方式</h4> 
<p><img src="https://images2.imgbox.com/bc/3b/qh2iezow_o.png" alt="image-20220121180918816"></p> 
<p>一个圈表示一个状态，</p> 
<p>一个箭头一个圈代表开始状态</p> 
<p>两个圈代表接收状态</p> 
<p>一个单项箭头链接两个圆表示状态的转换</p> 
<h4><a id="_1_1764"></a>编写 只接受数字1的自动机</h4> 
<p><img src="https://images2.imgbox.com/1a/14/bLIs5Xik_o.png" alt="image-20220121181405423"></p> 
<p>例子1</p> 
<p>一个开始状态，接受到数字1 然后转变为了可接受状态</p> 
<p><img src="https://images2.imgbox.com/b3/a5/pTwSvb45_o.png" alt="image-20220121181815682"></p> 
<p>在状态A侠，我们输入字符1，我们同时用指针来直向当前输入值的位置</p> 
<p>指针输入就会前进，不会回退，输入字符的时候，指针向右移动</p> 
<p>在状态b的时候，我们的指针到了1的后面，位于输入的末尾</p> 
<p>我们处于接受状态，再传入一个输入结束的信号，我们得到最终的accept</p> 
<p>下一个例子：</p> 
<p><img src="https://images2.imgbox.com/02/f7/uz8ARBRT_o.png" alt="image-20220121182248896"></p> 
<p>当我们在状态A的时候，我们开始输入，我们的指针读取发现0并不会发生转换，所以是reject</p> 
<p>另一个例子</p> 
<p>我们在状态A的时候，输入10 指针开始读取，然后读取到1 状态发生转换，可接受状态，也就是B的最终状态，接受状态，但是输入流仍然没有完，B的状态不能处理0这个输入，同样reject这个字符串</p> 
<p>tips：</p> 
<pre><code>自我感悟：不知道对错：轻点喷
这个有限自动机，感觉学到这里，他应该是用来处理ifelse，A状态输入了if，正常语句后面会有其他的，但是B的状态转换为可接受，但是，B拒绝输入后续的字符，直到读取到了else，B接着向后转换
</code></pre> 
<p>通常，我们上所说的有限自动机语言，他等价于接受的字符串的集合（也就是正则表达式所指代的字符串的集合）</p> 
<p><img src="https://images2.imgbox.com/92/0d/DZ0texv9_o.png" alt="image-20220121182802466"></p> 
<h4><a id="complex_1811"></a>complex的例子</h4> 
<p><img src="https://images2.imgbox.com/d2/0d/WVlSRS6h_o.png" alt="image-20220121182824246"></p> 
<p>尝试写一个自动机，该自动机接收任意数量的1并后跟一个0</p> 
<p><img src="https://images2.imgbox.com/11/8b/SoVUIhOw_o.png" alt="image-20220121182954226"></p> 
<p>也就是，当读取到1的时候，自循环，当读取到0的时候，状态改变</p> 
<p><img src="https://images2.imgbox.com/44/48/5iYu3xCu_o.png" alt="image-20220121190847335"></p> 
<p>例如我们在状态A的情况下，我们输入110</p> 
<p><img src="https://images2.imgbox.com/05/87/boL9yddm_o.png" alt="image-20220121190954496"></p> 
<p>例如我们输入一个拒绝的例子</p> 
<p><img src="https://images2.imgbox.com/9b/84/7wYAjZra_o.png" alt="image-20220121191040343"></p> 
<p>当我们读取到这里，虽然我们B是接受状态，但是仍然会reject</p> 
<p><img src="https://images2.imgbox.com/76/f0/M5WoThs6_o.png" alt="image-20220121191120025"></p> 
<p>另一种转换，输入指针会一个一个移动</p> 
<p>一种空跳，也就是说我们不需要输入东西就能够自动的跳转到另一个状态</p> 
<p>空跳的时候，指针不会发生改变</p> 
<p>空跳是一种无消耗的移动</p> 
<p><img src="https://images2.imgbox.com/9b/51/ErDfbNBJ_o.png" alt="image-20220121191510629"></p> 
<p>自动机并不是必须要空跳，是可以选择的</p> 
<h4><a id="Quiz_1851"></a>Quiz</h4> 
<p><img src="https://images2.imgbox.com/5d/c0/R1dolH7O_o.png" alt="image-20220123193745077"></p> 
<p>Select the regular language that denotes（标志） the same language as this finite automaton</p> 
<pre><code>选择表示与此有限自动机相同语言的常规语言
</code></pre> 
<p>因为 1 在循环，所以首先肯定是我们接受到1，同时101 1001 也是循环</p> 
<p>需要末尾是0的 1不限制，</p> 
<pre><code>(0+1)* 代表着 01 不限制
(1*+0)(1+0) 任意数量1 补一个0 然后 ×（1+0）补一个1，或补一个0，
1*+(01)*+(001)*+(000*1)* 这个也就是 全1
(0+1)*00 任意01补00
</code></pre> 
<p>很明显，就是D</p> 
<p><img src="https://images2.imgbox.com/a8/51/1QENWAQZ_o.png" alt="image-20220123194911412"></p> 
<p><img src="https://images2.imgbox.com/f3/fb/mjmaoGT0_o.png" alt="image-20220123194925603"></p> 
<pre><code>Explanation

The automaton denotes the language of all strings ending in "00". This language is most concisely written by the expression "(0 + 1)*00". Note that the first three expressions will all incorrectly match the string "1".

解释

自动机表示以“00”结尾的所有字符串的语言。这种语言最简洁的表达方式是“（0+1）*00”。请注意，前三个表达式都与字符串“1”不匹配。
</code></pre> 
<h4><a id="DFA_NFA_1900"></a>DFA 和NFA</h4> 
<p><img src="https://images2.imgbox.com/11/fb/pWuKPF0J_o.png" alt="image-20220121191540339"></p> 
<p>通过两个属性来确定有限自动机</p> 
<p>没有空跳，也就是必须要消费输入值</p> 
<p>对于确定性自动机 每个输入和每个状态之间只有一个转换（也就是，自动机的任何一个状态都不会出现同一种输入匹配了两种可能的状态）</p> 
<p><img src="https://images2.imgbox.com/6f/a2/taWgzsWE_o.png" alt="image-20220121191715155"></p> 
<p><img src="https://images2.imgbox.com/b0/74/upYVyHts_o.png" alt="image-20220121191730000"></p> 
<p>对于非确定性自动机</p> 
<p>这些是不起欸的那个的，尤其是非确定自动机可以仅需空跳</p> 
<p>一个输入也可以进行多个转换</p> 
<p><img src="https://images2.imgbox.com/01/5d/sdTC8BLw_o.png" alt="image-20220121191843757"></p> 
<p><strong>确定性自动机和非确定性自动机的区别就是 有没有空跳</strong></p> 
<p><img src="https://images2.imgbox.com/39/5e/h7iFPP3W_o.png" alt="image-20220121221819952"></p> 
<p>确定性自动机的关键特性 是每个输入只能通过状态图的一条路径</p> 
<p>不确定自动机却不是可以进行状态转换</p> 
<p>对于何时接收不确定自动机的规则是：如果有任何路径可以被接受，则接收（也就是能够接受多条路，就接受）</p> 
<p>输入会导出多个状态</p> 
<p><img src="https://images2.imgbox.com/a8/9e/7IpjAOgI_o.png" alt="image-20220121222003076"></p> 
<p>在运行过程中，根据NFA不同的选择，他们能进入不同的状态</p> 
<p>也就是<code>if...else if ...else</code></p> 
<p><img src="https://images2.imgbox.com/8c/67/6AeoCD1W_o.png" alt="image-20220121222051812"></p> 
<p>这是一个小的自动机</p> 
<p>当输入0的时候就会有两种状态</p> 
<p><img src="https://images2.imgbox.com/3b/05/6bvgcL5x_o.png" alt="image-20220121222151643"></p> 
<p><img src="https://images2.imgbox.com/b4/90/PnefbETt_o.png" alt="image-20220121222650337"></p> 
<p>当我们输入1的时候，循环，</p> 
<p>当输入0的时候，既可以是状态A，也可以是状态B，都是可能的</p> 
<p>当我们又读一个0，我们既可以到C，也可以仍然是A</p> 
<p>每一个步骤不确定自动机都有自己的一组状态，并且在需要的时候，我们考虑输入的所有可能动作，并计算出自动机下一步可能出现的完整状态集</p> 
<p>当然，我们在输入最后一个0之后，必须要决定机器最终接受的状态</p> 
<p>如果在这个集合中有任何最终状态，那么自动机都会接受他</p> 
<p>就比如这个例子，我们读取到最后一个0，接受状态C，自动机就会接受</p> 
<p><img src="https://images2.imgbox.com/2a/3f/zkpbrjei_o.png" alt="image-20220121222728926"></p> 
<p><img src="https://images2.imgbox.com/d6/9b/ysMIPo2i_o.png" alt="image-20220121222837463"></p> 
<p>NFA和DFA以及正则表达式都有相同的能力，他们都是指定的正则语言</p> 
<p>DFA比NFA快很多，不需要考虑其他可能</p> 
<p>但是NFA的优势是比较小，会小很多</p> 
<p>NFA 小巧紧凑，DFA执行速度快</p> 
<h3><a id="0403_Regular_Expressions_into_NFAs_9m41sNFA_1980"></a>04-03: Regular Expressions into NFAs (9m41s)【从正则表达式到NFA】</h3> 
<p><img src="https://images2.imgbox.com/cb/2e/HVhOrypz_o.png" alt="image-20220123224137737"></p> 
<p><img src="https://images2.imgbox.com/14/87/IO9ucTHc_o.png" alt="image-20220123224150441"></p> 
<p>我们需要实现一个词法规范</p> 
<p>也就首先需要一个正则表达式，一个词法规则，做词法分析</p> 
<p>需要将正则表达式转换为非确定性有限自动机</p> 
<p>一部分非确定性自动机会转换为确定性自动机</p> 
<p>最后我们使用一组lookup tables（查找表） 通过代码对这个表进行遍历，</p> 
<p>以此来实现确定性自动机</p> 
<h4><a id="for_each_kind_of_rexp_define_an_NFA_1998"></a>for each kind of rexp ，define an NFA</h4> 
<p>我们要实现的就是每种正则表达式对应的非确定性自动机</p> 
<p><img src="https://images2.imgbox.com/81/14/CXwyHK1E_o.png" alt="image-20220123225711414"></p> 
<p>我们使用L表示开始状态，使用两个圆来表示最终状态</p> 
<p>我们只需要处理开始状态和最终状态，不需要担心自动机的整体结构</p> 
<p>我们设计的自动机只有一种最终状态</p> 
<p>对于epsilon</p> 
<p><img src="https://images2.imgbox.com/f8/0b/pATenwBw_o.png" alt="image-20220123225738811"></p> 
<p>对于单个字符，我们也是直接的进行装换</p> 
<p><img src="https://images2.imgbox.com/34/12/3eVvQqB6_o.png" alt="image-20220123225823106"></p> 
<h4><a id="_2020"></a>复杂的正则表示</h4> 
<p>对于AB 级联</p> 
<p><img src="https://images2.imgbox.com/0f/9e/DgeLsqqa_o.png" alt="image-20220123225907231"></p> 
<p>AB两个自动机合并，虽然A的状态转变了，但是并不是整体自动机的最终状态</p> 
<p>也就是我们不会损耗（消费）任何输入，就能够提走到自动机B</p> 
<p>对于A+B union</p> 
<p><img src="https://images2.imgbox.com/cc/4f/y6pK6ZaI_o.png" alt="image-20220123230208515"></p> 
<p>意思是无论找个输入是属于自动机A所接受的语言，还是自动机B所接受的，我们整体的都能够接受</p> 
<p>找个地方就是一个不定项，都可以走，然后才会具体的读取字符串，看选则哪个</p> 
<p>同时使用空跳，跳转到最终状态</p> 
<p>对于A的迭代<code>A*</code></p> 
<p><img src="https://images2.imgbox.com/65/56/JWUgyCVO_o.png" alt="image-20220123230757412"></p> 
<p>Epilon始终属于A*</p> 
<p>从开始状态，接受空字符串，直接转到最终状态</p> 
<p>在A的最终状态，我们通过空跳，直接跳转到开始状态</p> 
<p>在A中循环迭代</p> 
<p>也就实现了，能够识别0个或多个A中所接受的字符串</p> 
<h4><a id="example_2056"></a>example</h4> 
<p><img src="https://images2.imgbox.com/f1/23/FOjAvLhT_o.png" alt="image-20220123231025720"></p> 
<p><code>1+0)*1·</code></p> 
<p>我们首先看看这个正则表达式的结构，然后用来画自动机</p> 
<p>简单的构成复杂</p> 
<p><img src="https://images2.imgbox.com/d7/fa/uCNBOyuO_o.png" alt="image-20220123231342687"></p> 
<p>首先自动机接收1，一个自动机接收0，组合起来，两个都接受，空跳，然后空跳到自己的最终状态</p> 
<p>我们把小自动机放在 迭代的自动机模式里面</p> 
<p><img src="https://images2.imgbox.com/4a/32/WMifxcPw_o.png" alt="image-20220123231353625"></p> 
<p>另一个是接收1的自动机</p> 
<p><img src="https://images2.imgbox.com/2b/70/KPYWY8T8_o.png" alt="image-20220123231405497"></p> 
<p>然后我们将她两个进行级联，直接空跳，标记好最终状态</p> 
<p><img src="https://images2.imgbox.com/21/04/NwAx9W1Y_o.png" alt="image-20220123231432644"></p> 
<h4><a id="quiz_2083"></a>quiz</h4> 
<p>Choose the NFA that accepts the following regular expression: 1* + 0.</p> 
<p><img src="https://images2.imgbox.com/56/92/ocCimwK5_o.png" alt="image-20220126172255967"></p> 
<p><img src="https://images2.imgbox.com/69/42/EX9WcGOl_o.png" alt="image-20220126172300340"></p> 
<pre><code>1*+0 也就是不限量个1后面跟一个0 
我们的A* 长这样，我们的1* 也要长这样
先排除AD，没有返回的空跳，
答案就是B了
由小到大，A+B是两条路径


</code></pre> 
<p><img src="https://images2.imgbox.com/0f/11/ACJXkOhG_o.png" alt="image-20220126172341191"></p> 
<pre><code>Try to build the NFA from machines that you already know. Start with the machines for "0" and "1", then build the machine for "1*" and finally for the union of "1*" and "0".

尝试从你已经知道的机器上构建NFA。从“0”和“1”的机器开始，然后为“1*”构建机器，最后为“1*”和“0”的并集构建机器。
</code></pre> 
<h3><a id="0404_NFA_to_DFA_15m12snfadfa_2109"></a>04-04: NFA to DFA (15m12s)【从nfa到dfa】</h3> 
<p><img src="https://images2.imgbox.com/af/69/nqum8upb_o.png" alt="image-20220126173131216"></p> 
<p>本次课是NFA到DFA</p> 
<p>举例</p> 
<p><img src="https://images2.imgbox.com/26/24/V1882acn_o.png" alt="image-20220126173151474"></p> 
<p>上节课的NFA</p> 
<p>我们来选出epsilon-closure(这里我觉得是某个点的状态),这个我感觉像可达的集合</p> 
<p><code>epsilon-closure(B) = {B,C,D}</code></p> 
<p><code>epsilon-closure(G) = {A、B、C、D、G、H、I、}</code></p> 
<p><img src="https://images2.imgbox.com/c6/82/lN0DafEJ_o.png" alt=""></p> 
<p>nfa一个输入有多个不同的状态，</p> 
<p>如果解决有多少个不同的状态，我们也就能够使用DFA来确定</p> 
<p>对于<code>epsilon-closure(B) = {B,C,D}</code> 用到的状态数量肯定是小于等于n</p> 
<p>那么将这个数量使用一个子集表示</p> 
<p><img src="https://images2.imgbox.com/4a/db/XNKS1mW7_o.png" alt="image-20220126183751166"></p> 
<p>​ 他的子集有2^n-1个子集</p> 
<p><img src="https://images2.imgbox.com/b2/a7/YGKpLUAg_o.png" alt="image-20220126183857843"></p> 
<p>这样我们就可以转换DFA，找到一个能够用确定性自动机模拟非确定性自动机行为模式的方法，</p> 
<h4><a id="_2153"></a>任意的非确定性自动优先级映射到一个等效的确定性有限自动机</h4> 
<p><img src="https://images2.imgbox.com/98/de/QFqywaIq_o.png" alt="image-20220126193042596"></p> 
<p>NFA中，所有的状态S集合</p> 
<p>初始状态、结束状态，s和f当然都属于S</p> 
<p>我们尝试写一个状态转化函数，用它来定义运算符，这样在定义DFA时会很方便</p> 
<p><code>a(x) ={y|x∈X ∩ x-a-&gt; y}</code></p> 
<p><img src="https://images2.imgbox.com/72/80/Wb4k6UYf_o.png" alt="image-20220126194224996"></p> 
<p>epsilon-clos</p> 
<p><img src="https://images2.imgbox.com/f7/4c/Qxvujzbu_o.png" alt="image-20220126194415081"></p> 
<p>DFA需要有哪些东西呢？</p> 
<p><img src="https://images2.imgbox.com/fc/5e/bYz0FSV2_o.png" alt="image-20220126194729052"></p> 
<p>除了空集意外，这些状态都是状态S的子集</p> 
<p>因此，这些DFA的状态，都会是NFA的状态的所有可能子集</p> 
<p>DFA的一种状态就对应了NFA的状态的每种可能子集</p> 
<p>DFA的开始状态是什么呢 非确定性自动机关于开始状态的epsilon-closure即epsilon-clos（s）</p> 
<p>DFA的每个状态，都对应了一个不同的状态子集</p> 
<p>DFA的每个状态，会告诉我们他们所可能在的NFA的某个特定状态集中</p> 
<p>当然，NFA的开始就是epsilon-clos</p> 
<p>（DFA的状态，都是NFA中的状态集）</p> 
<p>最终状态包含了，<code>{x|x∩F≠空}</code></p> 
<p>集合x与nfa的最终状态集相交，并且他不为空集</p> 
<p>DFA的一个最终状态，都有至少一个NFA的最终状态在这个集合里面</p> 
<p>接下来我们定义一个转换函数</p> 
<p><img src="https://images2.imgbox.com/10/75/X9tITx3S_o.png" alt="image-20220126200934777"></p> 
<p>我们给定一个状态X，状态Y</p> 
<p>有一个用于转换的a</p> 
<p>在NFA中，我们想要知道输入a所达到的状态，也就是a(x)</p> 
<p><code>有字符a输入，就能从状态x中获得结果，也就是字符a符合x集合中的哪一个执行路线</code></p> 
<p>但是在这个后，仍然有空跳的可能</p> 
<p>因此，我们加一层clos</p> 
<p>x和y的转换</p> 
<p><code>Y = epsilon-clos(a(x))</code></p> 
<p><img src="https://images2.imgbox.com/6f/f3/3BLCE7mx_o.png" alt="image-20220126201233960"></p> 
<p>对于任何的X，都只有这样一个状态集，</p> 
<p>（即一个输入字符只能对应一条执行路线，这个路线包含了一系列的多个状态）</p> 
<p>也就保证了确定性自动机</p> 
<p>有开始状态，最终状态集，，而且针对输入只存在一种移动路线的转换，并且没有空跳</p> 
<h4><a id="example_2235"></a>example</h4> 
<p><img src="https://images2.imgbox.com/e5/a6/mkJkMvqR_o.png" alt="image-20220126201450476"></p> 
<p>使用非确定新自动机来构筑确定性自动机的例子</p> 
<p><img src="https://images2.imgbox.com/af/00/ZkTJf51H_o.png" alt="image-20220126201608820"></p> 
<p>这个非确定自动机的初始就是epsilon-clos</p> 
<p>也就是这个紫色的，</p> 
<p>所以DFA的开始状态就是状态ABCDHI的子集</p> 
<p>从开始状态后，我们算出每个输入会让自动机发生的变化，也就是1和0</p> 
<p><img src="https://images2.imgbox.com/c2/a0/jbdTv0Gi_o.png" alt="image-20220126201806716"></p> 
<p>0的话也就是有D到F</p> 
<p>因此，放到公式中，第二个状态对应了一个更大的集合epsilon(F)</p> 
<p><img src="https://images2.imgbox.com/82/36/70Z73AEz_o.png" alt="image-20220126201851568"></p> 
<p>当输入1的时候，可能从C-》e 也可能I -》j，当然还可以进行空跳</p> 
<p>所以，除了F，他都可达，而且她包含了最终状态</p> 
<p><img src="https://images2.imgbox.com/45/d9/5FMR1tiP_o.png" alt="image-20220126202404094"></p> 
<p><img src="https://images2.imgbox.com/4f/e6/YZkMlTY9_o.png" alt="image-20220126202656252"></p> 
<p>当然，我们做一些补充，一些跳转</p> 
<p>这个就是完善的确定性自动机</p> 
<p>每一步转换都记录了NFA的集合</p> 
<h4><a id="Quiz_2277"></a>Quiz</h4> 
<p><img src="https://images2.imgbox.com/21/a9/YXrVeClj_o.png" alt="image-20220127113605474"></p> 
<p>选择代表与给定NFA相同语言的DFA。</p> 
<p><img src="https://images2.imgbox.com/6d/65/oXO4uGKy_o.png" alt="image-20220127113722779"></p> 
<p><img src="https://images2.imgbox.com/40/5f/MqnMcBwD_o.png" alt="image-20220127113727486"></p> 
<p>首先起始状态，也就是直接包含空跳的</p> 
<p><img src="https://images2.imgbox.com/f6/57/bArKha6p_o.png" alt="image-20220127113912104"></p> 
<p>然后我们可以分支，一个1一个0</p> 
<p>如果是1，我们寻找带1的，同时空跳的</p> 
<p><img src="https://images2.imgbox.com/e4/19/BcukO7Wc_o.png" alt="image-20220127114037932"></p> 
<p>带0的</p> 
<p><img src="https://images2.imgbox.com/03/03/tXIkL32K_o.png" alt="image-20220127114133545"></p> 
<p>除了中间两个，全都是</p> 
<p>说明，0跳转后，通过1可以转换，1状态也可以通过0互相转换</p> 
<p>看图说话，起始状态 通过0也可以自己循环</p> 
<p>首先排除B，因为我们这个是两条路，</p> 
<p>一条直接通过0 到达 了最终状态</p> 
<p>另一条通过则为</p> 
<p><img src="https://images2.imgbox.com/e9/aa/Gr7FWJ35_o.png" alt="image-20220127120438823"></p> 
<p>因为如果从0直达最终态，不能返回1，所以，他的另一条路独立</p> 
<p>排除B</p> 
<h3><a id="0405_Implementing_Finite_Automata_11m56s_2325"></a>04-05: Implementing Finite Automata (11m56s)【实现有限自动机】</h3> 
<p><img src="https://images2.imgbox.com/04/b0/MmoKmhhJ_o.png" alt="image-20220127120857275"></p> 
<p>实现有限自动机的时候，有时候可以不通过转换DFA直接实现</p> 
<h4><a id="A_DFA_can_be_implemented_by_a_2D_table_T_2331"></a>A DFA can be implemented by a 2D table T</h4> 
<p><img src="https://images2.imgbox.com/48/40/oSwd7B9q_o.png" alt="image-20220127120932289"></p> 
<p>从DFA开始，可以很简单的通过二维的形式来实现一个确定性有限自动机</p> 
<p>一个维度是states状态</p> 
<p>一个维度是输入符号</p> 
<p><img src="https://images2.imgbox.com/72/c6/3oWZXrNh_o.png" alt="image-20220127121227901"></p> 
<p>一个状态i和一个输入a 能够确定所要移动的下一个位置k</p> 
<p>这张表，保存每个特定的输入和状态，以及自动机会达到的下一个状态</p> 
<h4><a id="example_2347"></a>example</h4> 
<h5><a id="__2_dimension_2349"></a>二维 表 2 dimension</h5> 
<p><img src="https://images2.imgbox.com/84/0d/XScODrEq_o.png" alt="image-20220127121339648"></p> 
<p>DFA转换程由表驱动实现的例子</p> 
<p><img src="https://images2.imgbox.com/53/9d/BGtTayHj_o.png" alt="image-20220127123321064"></p> 
<p>三个状态，两个输入</p> 
<p><img src="https://images2.imgbox.com/8e/8a/yCZAoD0h_o.png" alt="image-20220127123429579"></p> 
<p>看图说话，填好我们的表格</p> 
<p>然后通过打表 写出代码</p> 
<p><img src="https://images2.imgbox.com/4a/19/EZoqNA9V_o.png" alt="image-20220127123706676"></p> 
<pre><code>i = 0;
state = 0;
while(input[i]){
	state = A[state,input[i++]];
}
</code></pre> 
<p>最开始状态，i和state都是0</p> 
<p>然后我们需要对输入进行遍历，并对他进行检查，判断它是否需要跳转</p> 
<p>我们输入一个字符数组input[i]，数组元素不为空的时候进行跳转</p> 
<p>我们上面的表我们定义为A，他是一个转换关系表</p> 
<p>state = A[] 在A中寻找</p> 
<p>通过一个当前状态和输入进行寻找</p> 
<p>也就是<code>A[state,input[i++]];</code></p> 
<p>一个用于input数组遍历，一个用于对遍历得到的每个字符进行转换</p> 
<h5><a id="_1dimension_2391"></a>一维表 1dimension</h5> 
<p>这个方法对于表的重复比较高，我们可以通过略微不同的表达方式来节省空间</p> 
<p>使用一张一维表 也就是链表，共享表</p> 
<p><img src="https://images2.imgbox.com/c0/22/wPfbyElw_o.png" alt="image-20220127124748548"></p> 
<p>因为词法分析中，重复的行非常常见</p> 
<p>在dfa中可能会有<code>2^n-1</code>个状态（子集） 对于NFA则有n个</p> 
<h4><a id="NFA_2405"></a>NFA直接转换自动机</h4> 
<p><img src="https://images2.imgbox.com/4a/66/dqyzXz0p_o.png" alt="image-20220127124957636"></p> 
<p>因为NFA 转DFA 再转表，会造成很大消耗</p> 
<p>直接NFA打表，</p> 
<p><img src="https://images2.imgbox.com/54/ff/gjyNVhbh_o.png" alt="image-20220127125103375"></p> 
<p>但是这个里面填入的都是集合</p> 
<p><img src="https://images2.imgbox.com/06/5e/PGHaWAo2_o.png" alt="image-20220127125141661"></p> 
<p>这样的话，他相当于是在递归，内耗比较大，因为他每一个都是一组状态</p> 
<p>当然这样节省了表空间，执行速度会慢很多</p> 
<h4><a id="summarize_2423"></a>summarize</h4> 
<p><img src="https://images2.imgbox.com/d5/ae/0wu3zgag_o.png" alt="image-20220127125328463"></p> 
<p>实现词法规则的关键思想就是将非确定性优先自动挡及转换为确定性有限自动机</p> 
<p>（也就是，把不确定的，赋予了确定的特性）</p> 
<p>工具需要在速度和空间上权衡</p> 
<p>DFA faster，less compact</p> 
<p>NFA slower concise</p> 
<h3><a id="week2_Quiz_2437"></a>week2 Quiz</h3> 
<p><img src="https://images2.imgbox.com/d4/12/ZTz9maK7_o.png" alt="image-20220127125810975"></p> 
<p>答案31</p> 
<pre><code>We have 16 distinct strings of length 4, 8 distinct strings of length 3, 4 distinct strings of length 2, 2 distinct strings of length 1, and one empty string. In total, we have 16+8+4+2+1=31 distinct strings.

我们有16个长度为4的不同字符串，8个长度为3的不同字符串，4个长度为2的不同字符串，2个长度为1的不同字符串，以及一个空字符串。我们总共有16+8+4+2+1=31个不同的字符串。

2*2*2*2+2*2*2+2*2+2+1
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/d3/ntfyiPXB_o.png" alt="image-20220127130218517"></p> 
<p><img src="https://images2.imgbox.com/36/ea/TqI2s9Bf_o.png" alt="image-20220127130355646"></p> 
<p>那个词法规则可以分割成如下这样</p> 
<p>emm，这个我看不懂他选项，他写的不是一个完整的式子，先跳过</p> 
<p><img src="https://images2.imgbox.com/22/46/BudIt32i_o.png" alt="image-20220127131109859"></p> 
<p><img src="https://images2.imgbox.com/ea/fe/U4lOknxf_o.png" alt="image-20220127141430296"></p> 
<pre><code>Both rule 3 and 4 match the whole string, while 3 has a higher priority.
规则3和4都匹配整个字符串，而规则3的优先级更高。
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/bf/1HNAftxI_o.png" alt="image-20220127141518600"></p> 
<p><img src="https://images2.imgbox.com/07/e4/v6xEOPTb_o.png" alt="image-20220127141523515"></p> 
<p><img src="https://images2.imgbox.com/74/02/9nbSfxNE_o.png" alt="image-20220127142147276"></p> 
<pre><code>In this NFA, there are five states, S0, S1, S2, S3 and S4. S0 is the start state, S4 is the accepting state. The transactions are following.
If we are in state S0 and read input 0, we go to S1.
If we are in state S1, we can go to state S3 without consuming any input, that is a -move. If we are in state S1 and read 0, we go to S2.
If we are in state S2 and read 0, we go to S0.
If we are in state S3 and read 1, we go to S4.
If we are in S4 and read 0, we go to S3.

在这个NFA中，有五个状态：S0、S1、S2、S3和S4。S0为开始状态，S4为接受状态。交易如下。

如果我们处于状态S0并读取输入0，我们将进入S1。

如果我们处于状态S1，我们可以在不消耗任何输入的情况下进入状态S3，这就是移动。如果我们处于状态S1并读取0，则转到S2。

如果我们处于S2状态并读取0，则转到S0。

如果我们处于S3状态并读取1，则进入S4。

如果我们在S4，读0，我们进入S3。
</code></pre> 
<p><img src="https://images2.imgbox.com/ed/7a/wyCBofoH_o.png" alt="image-20220127142329180"></p> 
<p><img src="https://images2.imgbox.com/f9/b1/UZ0ZG3Eg_o.png" alt="image-20220127142335071"></p> 
<p><img src="https://images2.imgbox.com/e2/da/qomyJyRt_o.png" alt="image-20220127142343212"></p> 
<p><img src="https://images2.imgbox.com/9d/5c/DDE9NxuL_o.png" alt="image-20220127142429145"></p> 
<p><img src="https://images2.imgbox.com/b2/10/2sjaIzJv_o.png" alt="image-20220127142435290"></p> 
<p>CD只是包含了ab，而不是正则的（abab）*</p> 
<p><img src="https://images2.imgbox.com/dc/f4/B5ihsscG_o.png" alt="image-20220127142619757"></p> 
<p><img src="https://images2.imgbox.com/1c/fd/ZK7VkDok_o.png" alt="image-20220127142623798"></p> 
<pre><code>We need 4 states, S1, S2, S3 and S4. S1 is start state and S4 is the accepting state.
If we are in S1 and read input a, we go to S2.
If we are in S2 and read input b, we go to S3. If we are in S2 and read d, we go to S4.
If we are in S3 and read c, we go to S2.
我们需要4个状态，S1，S2，S3和S4。S1为开始状态，S4为接受状态。

如果我们在S1中，读取输入a，我们进入S2。

如果我们在S2中，读取输入b，我们进入S3。如果我们在S2读d，我们就进入S4。

如果我们在S3中读c，我们进入S2。
</code></pre> 
<p><img src="https://images2.imgbox.com/d6/04/cnfhd0Zu_o.png" alt="image-20220127142852616"></p> 
<p><img src="https://images2.imgbox.com/7b/fb/9ENeKNFz_o.png" alt="image-20220127142857559"></p> 
<p><img src="https://images2.imgbox.com/02/d3/wUTNuZgW_o.png" alt="image-20220127142839352"></p> 
<p><img src="https://images2.imgbox.com/f7/5b/0DiphOSu_o.png" alt="image-20220127142911586"></p> 
<p><img src="https://images2.imgbox.com/74/e6/CiDwEfyA_o.png" alt="image-20220127142953878"></p> 
<p>这些规则不能处理那些字符串</p> 
<p><img src="https://images2.imgbox.com/4b/33/1k3rsFiC_o.png" alt="image-20220127143033192"></p> 
<p>CD 处理完成后是</p> 
<p>The string will be tokenized as 00/011/01.</p> 
<p>The string will be tokenized as 011/00/100.</p> 
<p>挑DFA</p> 
<p><img src="https://images2.imgbox.com/77/9f/hLfrpBAg_o.png" alt="image-20220127131558904"></p> 
<p><img src="https://images2.imgbox.com/80/1d/nRUVc79y_o.png" alt="image-20220127131603794"></p> 
<p><img src="https://images2.imgbox.com/f5/92/gMdFeSH9_o.png" alt="image-20220127132139552"></p> 
<p>这里我觉得是，这个他都满足nfa和dfa</p> 
<p>12题 挑选NFA ，有空跳</p> 
<p>排除DFA即可，不能有多个输入对一个，</p> 
<p>也就是ABC</p> 
<p><img src="https://images2.imgbox.com/28/37/x7ssg6GV_o.png" alt="image-20220127131513415"></p> 
<p><img src="https://images2.imgbox.com/bb/19/8lHfGIC4_o.png" alt="image-20220127131518051"></p> 
<pre><code>This automata has 4 states, S0, S1, S2 and S3. S0 is the start state, S3 is the accepting state. The Transactions are following: If we are in S0 and read 0, we go to S1. If we are in S0 and read 1, we go to S2. If we are in S1 and read 0, we go to S3. If we are in S2 and read 0, we go to S3. If we are in S3 and read 1, we go to S0.
This automata has 4 states, S0, S1, S2 and S3. S0 is the start state, S3 is the accepting state. The Transactions are following: If we are in S0 and read 0, we can go to S1. If we are in S0 and read 0, we can go to S2. If we are in S1 and read 0, we go to S3. If we are in S2 and read 1, we go to S3. If we are in S3 and read 1, we go to S0.
This automata has 3 states, S0, S1 and S3. S0 is the start state, S3 is the accepting state. The transactions are following: If we are in S0, we go to S1 with out consuming any input, that is an -move. If we are in S1 and read 0, we go to S3.
This automata has a state Si for every non-negative integer i: S0, S1... Sn, and so on. S0 is the start state and the accepting state. The transitions are following: If we are in state Si, (i&gt;=0) and read 0, we go to state Si+1. If we are in state Si, (i&gt;=1) and read 1, we go to state Si-1.


这个自动机有4个状态，S0，S1，S2和S3。S0是开始状态，S3是接受状态。这些事务如下：如果我们在S0中，读到0，我们进入S1。如果我们在S0读到1，我们进入S2。如果我们在S1读0，我们就进入S3。如果我们在S2读0，我们就进入S3。如果我们在S3中读到1，我们进入S0。

这个自动机有4个状态，S0，S1，S2和S3。S0是开始状态，S3是接受状态。这些事务如下：如果我们在S0，读0，我们可以转到S1。如果我们在S0，读到0，我们可以转到S2。如果我们在S1读0，我们就进入S3。如果我们在S2读1，我们就进入S3。如果我们在S3中读到1，我们进入S0。

这个自动机有三种状态，S0，S1和S3。S0是开始状态，S3是接受状态。交易如下：如果我们在S0，我们去S1没有消耗任何输入，这是一个移动。如果我们在S1读0，我们就进入S3。

对于每个非负整数i:S0，S1，这个自动机有一个状态Si。。。Sn等等。S0是开始状态和接受状态。转换如下：如果我们处于状态Si，（i&gt;=0）并读取0，我们进入状态Si+1。如果我们处于状态Si，（i&gt;=1）并读取1，我们将进入状态Si-1。
</code></pre> 
<h2><a id="CS143_Week3_Parsing__TopDown_Parsing__2602"></a>CS-143 Week3 Parsing &amp; Top-Down Parsing 【解析器&amp;自顶向下的解析器】</h2> 
<h3><a id="0501_Introduction_to_Parsing_5m31s__2604"></a>05-01: Introduction to Parsing (5m31s) 【解释器介绍】</h3> 
<p><img src="https://images2.imgbox.com/b6/09/yn5DjNOG_o.png" alt="image-20220128173748679"></p> 
<p>正则语言被广泛使用的最弱形式语言</p> 
<p>许多应用</p> 
<p>但是，有很大一部分相当重要的但无法以正则表达式或者有限自动机表达 的语言</p> 
<p><img src="https://images2.imgbox.com/35/ec/12bGb392_o.png" alt="image-20220128173915581"></p> 
<p>元素在许许多多括号之中，也包括ifelse的嵌套</p> 
<p><img src="https://images2.imgbox.com/3a/f4/uMeKUgnU_o.png" alt="image-20220128174010152"></p> 
<p>这些不能够被正则处理</p> 
<p><img src="https://images2.imgbox.com/5e/42/nB5nlAad_o.png" alt="image-20220128174639288"></p> 
<p>正则可以表达什么</p> 
<p>正则其实也就是自动机，这里举一个简单的双形态自动机来解释正则语言和有限自动机的局限性</p> 
<p><img src="https://images2.imgbox.com/14/94/pEdBjDhA_o.png" alt="image-20220128174817182"></p> 
<p>读入奇数个1 我们处于最终状态</p> 
<p>读入偶数个1我们处于开始状态</p> 
<p>比如我们输入<code>1111111</code></p> 
<p>自动机不会记住字符串长度，他也不知道你经历了几次最终状态</p> 
<p>有限自动机只能表达一些 对k取模<code>count mod k</code> (k是机器中的状态数)</p> 
<p>但是不能对任意数来做取模</p> 
<p>因此如果需要识别数学操作的表达式语言 例如</p> 
<p>识别所有的<code>()</code> 中的字符串并做计算操作</p> 
<h4><a id="parseing__2646"></a>parseing 可以做什么</h4> 
<p><img src="https://images2.imgbox.com/0b/19/GqZkXogK_o.png" alt="image-20220128175303926"></p> 
<p>它可以讲词法分析器生成的词法单元序列作为输入，并生成程序的解析树</p> 
<p>在cool语言中，这个是一个表达式，将他输入到词法分析器中</p> 
<p><img src="https://images2.imgbox.com/e2/a9/qOvj6vp4_o.png" alt="image-20220128175345741"></p> 
<p>词法分析器会产生这个词法单元序列 作为一个输出</p> 
<p>解析器会生成这个嵌套明显，结构明确的解析树</p> 
<h4><a id="Summarize_2660"></a>Summarize</h4> 
<p><img src="https://images2.imgbox.com/85/dc/bJenx9N0_o.png" alt="image-20220128175526660"></p> 
<p>词法分析器讲字符串作为输入，并生成token（词法单元） 作为输出</p> 
<p>然后解析器 把token当做输入，并生成程序解析树</p> 
<p><img src="https://images2.imgbox.com/26/fd/4RbPPlX7_o.png" alt="image-20220128175640559"></p> 
<p>有些时候，解析树是隐式的，虽然大部分编译器会构建显式解析树</p> 
<p>现在的解析器通常把词法分析和解析放在一起</p> 
<h3><a id="0502_Context_Free_Grammars_Part_1_12m38s_2674"></a>05-02: Context Free Grammars Part 1 (12m38s)【上下文无关法】</h3> 
<p><img src="https://images2.imgbox.com/c3/fe/2rlUfCOX_o.png" alt="image-20220128180727576"></p> 
<p>并不是所有的token字符串都是一个有效的程序</p> 
<p>解析器必须告诉用户区别，它需要知道，那些有效，哪些没效果，并给出错误信息</p> 
<p>我们需要一种方式来表述有效的token字符串</p> 
<p>然后需要某种算法来区分有效token字符串和无效token字符串</p> 
<p><img src="https://images2.imgbox.com/76/a4/IK8mtgxI_o.png" alt="image-20220128182047573"></p> 
<p>编程语言具有自然的递归结构</p> 
<p>例如在cool中，我们需要一个用来表示多个条件的判断选择表达式</p> 
<p>也就是if和while 表达式</p> 
<p>if expr then expr else expr fi</p> 
<p>while expr loop expr pool</p> 
<p>这些表达式本身由其他表达式递归组成的</p> 
<p>if条件表达式，由then分支和else分支</p> 
<p>while中，判断是一个表达式，循环体也是一个表达式</p> 
<p>上下文无关法能自然的用域描述这种递归结构（recursive structure）</p> 
<p><img src="https://images2.imgbox.com/07/22/W3j3wwbt_o.png" alt="image-20220128182746677"></p> 
<p>上下文无关法在形式上由如下组成</p> 
<p>一组终端 T</p> 
<p>一组非终端 N</p> 
<p>一个起始符号 S （S是非终端之一）</p> 
<p>一组产生式 （ps：这个可以叫做上下文无关法的规则）</p> 
<p>一个产生式 指的是 一个符号跟着一个箭头，紧接着一串符号（x-&gt;Y1…YN）</p> 
<p>这些符号有一定的规则，例如</p> 
<p>箭头左侧的x必须是非终端符号（非终结符）<code>x∈n</code></p> 
<p>箭头右边的每个Yi可以是非终端符，也可以是特殊符号epsilon</p> 
<p>也就是<code>Yi ∈ N∪T∪{epsilon}</code></p> 
<h4><a id="_2734"></a>上下文无关法的例子</h4> 
<p>使用上一次的例子</p> 
<p>一种可能是一对括号中间有一个字符串</p> 
<p><code>S -&gt;(s)</code></p> 
<p>另一种可能就是括号里面是一个空的字符串</p> 
<p><code>S-&gt;epsilon</code></p> 
<p><img src="https://images2.imgbox.com/a3/00/tBGXKlEJ_o.png" alt="image-20220128190311100"></p> 
<p>我们的非终结符是<code>N = {S}</code></p> 
<p>我们的终结符是<code>T = {(,)}</code>左括号和右括号</p> 
<p>开始符号是什么？是S，因为只有他一个非终结符</p> 
<p>箭头左边都是非终结符，只要有式子产生，非终结符就会产 生</p> 
<p>对于产生式</p> 
<p><img src="https://images2.imgbox.com/df/d8/ZNTofbZv_o.png" alt="image-20220128190541388"></p> 
<p>对于特定的上下文无关法，括号中的一组为产生式</p> 
<h4><a id="productions_can_be_read_as_rules_2766"></a>productions can be read as rules</h4> 
<p>产生式可以当作规则来使用</p> 
<p>比如<code>S-&gt;(s)</code></p> 
<p>这个产生式，我们无论在哪儿看到这个S都可以使用箭头右边的字符串符号进行替代</p> 
<h5><a id="1begin_with_a_string_with_only_the_start_symbol_S_2774"></a>1.begin with a string with only the start symbol S</h5> 
<p>刚开始，我们只有这个开始符号–字符串S</p> 
<h5><a id="2replace_any_nonterminal_X_in_the_string_by_the_righthand_side_of_some_production_XY1Yn_2778"></a>2.replace any non-terminal X in the string by the right-hand side of some production X-&gt;Y1…Yn</h5> 
<p>我们替换为任意一个在右手边出现的非终结符字符串</p> 
<p>例如可以用<code>Y1..Yn</code> 替换X</p> 
<h5><a id="3repeat2_until_there_are_no_nonterminals_2784"></a>3.repeat(2) until there are no non-terminals</h5> 
<p>我们不断重复第二步，直到字符串中没有任何非终结符的存在，只存在终结符</p> 
<h4><a id="example_2788"></a>example</h4> 
<p>一个推导过程</p> 
<p><img src="https://images2.imgbox.com/71/03/U36tBPDi_o.png" alt="image-20220128202059079"></p> 
<p>我们有一串符号</p> 
<p>有一个产生式</p> 
<p><img src="https://images2.imgbox.com/89/b7/ob8NPz61_o.png" alt="image-20220128202145368"></p> 
<p>进行了替换，这只是第一步</p> 
<p>如果想要执行多个步骤 例如</p> 
<p><img src="https://images2.imgbox.com/d2/5d/asZOSea3_o.png" alt="image-20220128202320684"></p> 
<p>也就是<code>α-*-&gt;αn</code> α0 经过0步或多步改写，最终得到αn （*号代表0个或多个步骤）</p> 
<p><img src="https://images2.imgbox.com/2f/1a/aFsHuRzt_o.png" alt="image-20220128202441706"></p> 
<p>正常来说，我们从一个开始状态，会一步一步转换为其他字符串</p> 
<p><img src="https://images2.imgbox.com/d3/0e/mcqXauIW_o.png" alt="image-20220128202524248"></p> 
<h4><a id="finally_2820"></a>finally</h4> 
<p>我们可以定义上下文无关法</p> 
<p><img src="https://images2.imgbox.com/c3/07/p2M3utK6_o.png" alt="image-20220128202557488"></p> 
<pre><code>上下文无关法L(G)有一个开始符号S，这个上下文无关法的语言将是符号字符串a1到an

对于所有的αi来说 αi是G的一个终结元素，T代表G的终结符集合

开始符号S代表a1...an 也就是我们推导的所有终结字符串都可以 以开始符为开始
</code></pre> 
<h5><a id="terminal_2834"></a>terminal</h5> 
<p><img src="https://images2.imgbox.com/91/dd/1ics586f_o.png" alt="image-20220128202945909"></p> 
<p>terminal 也就是终端，终结，就是说，一旦这个字符串中包含了终结符，那么就没有规则可以进行替换他们</p> 
<p>也就是一旦终结符出现，他就是这个字符串中无法改变的存在</p> 
<p>在编程语言和上下文无关法的应用程序中，终结符是我们使用上下文无关法进行语言建模的标记</p> 
<h4><a id="a_fragment_of_cool_2844"></a>a fragment of cool</h4> 
<p>尝试使用上下文无关法，编写一段cool</p> 
<p>if的表达式</p> 
<p><code>EXPR -&gt; if EXPR then EXPR else EXPR fi</code></p> 
<p>在这个产生式中，我们将这些非终结字符变为大写，终结符都是小写</p> 
<p>或者是while的表达式</p> 
<p><code>EXPR -&gt; while EXPR loop EXPR pool</code></p> 
<p>最后一种可能性是他可能是标识符id</p> 
<p><code>EXPR -&gt; id</code></p> 
<p>实际上会有很多很多可能性和其他很多很多情况</p> 
<p><img src="https://images2.imgbox.com/63/58/bHBYTxyj_o.png" alt="image-20220128203654217"></p> 
<p>因此，对于同一个非终结符，我们会有许多的产生式</p> 
<p>通常使用语法把他们拼接在一起 这里使用<code>|</code></p> 
<p><img src="https://images2.imgbox.com/e4/3f/vLEU4X13_o.png" alt="image-20220128203757076"></p> 
<p>这样可以说EXPR -》 是右手边所有元素对应的非终结符</p> 
<p>三个产生式组合在一起</p> 
<h4><a id="some_elements_of_the_language_2878"></a>some elements of the language</h4> 
<p>我们查看一下上下文无关法的一些字符串</p> 
<p>单个标识符id就是一个有效的cool表达式</p> 
<p>这里的产生式为<code>EXPR -&gt; id</code> id（单个变量名）</p> 
<p>我们可以直接将开始符号直接带到终端字符串中</p> 
<p>示例：if表达式</p> 
<p><code>if id then id else id fi</code></p> 
<p>类似的，我们也可以对while进行操作</p> 
<p><code>while id loop id pool</code></p> 
<p>用产生式右边的替换左边</p> 
<p>更复杂的表达式if+while</p> 
<p><code>if while id loop id pool then id else id fi</code></p> 
<p>if+if 内嵌if</p> 
<p><code>if if id then id else id fi then id else id fi</code></p> 
<p><img src="https://images2.imgbox.com/8c/11/owGhJe7c_o.png" alt="image-20220129114122867"></p> 
<h4><a id="simple_arithmetic_expression_2908"></a>simple arithmetic expression</h4> 
<p>我们再来看一个例子，简单的算术表达式</p> 
<p>有一个开始符号，唯一的的非终结符E</p> 
<p><code>E -&gt; E+E|E*E |(E)|id</code></p> 
<p>这个就是一个关于加，乘，括号运算以及变量名的一个语法</p> 
<p><img src="https://images2.imgbox.com/e7/c2/GiQU36y9_o.png" alt="image-20220129115148313"></p> 
<pre><code>单个变量名（id）  就在上面这个语法中

id+id 同样在这个中，

id+id*id
(id+id)*id
</code></pre> 
<p><img src="https://images2.imgbox.com/7a/fa/1xKkbifD_o.png" alt="image-20220129115316567"></p> 
<h4><a id="the_idea_of_a_CFG_is_a_big_step_2931"></a>the idea of a CFG is a big step</h4> 
<p><img src="https://images2.imgbox.com/aa/8b/zXbnoRk3_o.png" alt="image-20220129115344316"></p> 
<p>虽然上下文无关法能让我们在解析器中去表达想要的内容，但是仍然需要一些东西</p> 
<pre><code>在这个语言中，上下文无关法只能给出是或否的答案，一个字符串是或者不是这个上下文无关法中的，我们仍然需要一种在input（输入）处构建解析树的方法

我们必须要能够优雅的处理报错

我们需要实现上面两步，才能够真正实现上下文无关法

</code></pre> 
<p><img src="https://images2.imgbox.com/27/d9/qC9BzOsq_o.png" alt="image-20220129115824901"></p> 
<p>上下文无关法的形式很重要</p> 
<p>这个工具通常对特殊语法很敏感，</p> 
<p>这里的意思应该是：开始符和结束符都是限定的，不能够任意进行修改</p> 
<h3><a id="0503_Derivations_Part_1_7m07s_2954"></a>05-03: Derivations Part 1 (7m07s)【推导】</h3> 
<p>推导就是，我们从开始符号开始，通过一系列产生式的替换，</p> 
<p><img src="https://images2.imgbox.com/68/3e/jmbMsuYk_o.png" alt="image-20220129235549654"></p> 
<p>当然也可以使用不同的方式而不是线性的替换顺序来 推导</p> 
<p>我们可以做一个树，一个非终结符X，当我们替换X的时候，可以通过X的子节点来表示，也就是这些子节点可以用来替换这个产生式规则中左手的X</p> 
<h4><a id="example_2964"></a>example</h4> 
<p><img src="https://images2.imgbox.com/56/49/KQMeWzh3_o.png" alt="image-20220206171021490"></p> 
<p>我们想要构建一个树</p> 
<p>也就是找个表达式或者输入字符串的解析树</p> 
<p><img src="https://images2.imgbox.com/a5/9e/WiRGvipV_o.png" alt="image-20220206171103837"></p> 
<p>首先根据我们的语法式子，第一个就是简单的加法</p> 
<p><img src="https://images2.imgbox.com/6d/50/LaLbqVZy_o.png" alt="image-20220206171644403"></p> 
<p>乘法</p> 
<p><img src="https://images2.imgbox.com/ae/c1/dWEJhi63_o.png" alt="image-20220206171824650"></p> 
<p><img src="https://images2.imgbox.com/7e/b7/nkGnN4Ei_o.png" alt="image-20220206171915192"></p> 
<p>逐个替换id，</p> 
<p>也就构建了解析树</p> 
<h4><a id="parsing_tree_2992"></a>parsing tree</h4> 
<p><img src="https://images2.imgbox.com/c0/a8/0B5DEgX7_o.png" alt="image-20220206172034483"></p> 
<p>首先，解析树的叶子节点上是终结符，非终结符则位于内部节点</p> 
<p>叶子节点的中序遍历所得结果就是我们的原始输入，（先遍历左子树，然后访问根节点，最后遍历右子树）</p> 
<p>我们这个例子中，只有一个非终结符E，所有的内部节点都是E，并且叶子节点都是终结符字符串，，我们对叶子节点进行中序遍历，就是我们开始的输入字符串</p> 
<p><img src="https://images2.imgbox.com/4a/09/r2N9SQCz_o.png" alt="image-20220206174154078"></p> 
<p>这个解析树中，<code>*</code> 号比<code>+</code> 更优先</p> 
<p>因为星号的树是加号树的子树，做加法前先做乘法</p> 
<p><img src="https://images2.imgbox.com/93/6f/W5eEb7F0_o.png" alt="image-20220206174418592"></p> 
<p>刚刚的推导叫做左推导，</p> 
<p>每一步都将字符粗，替换为最左边的非终结字符</p> 
<p>当然也有相同字符串的最右推导，我们都在替换最右边的非终结符</p> 
<p>E 换成id，</p> 
<p><img src="https://images2.imgbox.com/5c/6c/krUUY44l_o.png" alt="image-20220206174702979"></p> 
<p><img src="https://images2.imgbox.com/a6/38/YknLPTIN_o.png" alt="image-20220206174710486"></p> 
<p><img src="https://images2.imgbox.com/ad/00/DZNzpHvl_o.png" alt="image-20220206174717316"></p> 
<p>最左和最右推导都有相同的解析树</p> 
<p><img src="https://images2.imgbox.com/1c/c0/MqOkTSVf_o.png" alt="image-20220206174735725"></p> 
<p>当然还有其他的推导，随机选择非终结符进行替换之类的</p> 
<h4><a id="summarize_3032"></a>summarize</h4> 
<p><img src="https://images2.imgbox.com/50/0f/IeG7EsxG_o.png" alt="image-20220206174833938"></p> 
<p>我们不仅仅对于这个字符串是不是在这个特定的上下文无关法中，同时我们对解析树也感兴趣</p> 
<p>一个推导有一颗解析树，一颗解析树有很多推导</p> 
<p>最左和最右推导，在解析器的实现中是比较重要的</p> 
<h3><a id="0504_Ambiguity_3044"></a>05-04: Ambiguity【歧义性】</h3> 
<p><img src="https://images2.imgbox.com/54/9c/pXiiexNW_o.png" alt="image-20220206223702061"></p> 
<p><img src="https://images2.imgbox.com/4a/7b/H5oHCS3V_o.png" alt="image-20220206223726721"></p> 
<p>这个字符串有两个解析树，通过解析树去反推产生式</p> 
<p><img src="https://images2.imgbox.com/ff/b9/MFiaJFE3_o.png" alt="image-20220206231422559"></p> 
<p>最后把id替换了</p> 
<p><img src="https://images2.imgbox.com/1c/87/ub24KACH_o.png" alt="image-20220206231437483"></p> 
<p><img src="https://images2.imgbox.com/69/28/F5ztDbYh_o.png" alt="image-20220206231453855"></p> 
<p><img src="https://images2.imgbox.com/65/9e/DgSqijFE_o.png" alt="image-20220206231506642"></p> 
<p>我们发现，两个截然不同的解析树，推导出了一样的产生式</p> 
<p>两种推导，生成了两种完全不同的解析树</p> 
<p>这就是ambiguity 歧义，模棱两可</p> 
<p>如果对于某个字符串有多个解析树，那么这个语法就是有歧义的</p> 
<p><img src="https://images2.imgbox.com/4c/08/PoSBCo5T_o.png" alt="image-20220206231655429"></p> 
<p>也就是，对于某个字符串有多个最右推导或者最左推导</p> 
<p>也就会有截然不同的解析树</p> 
<p>语法就有歧义</p> 
<p>而且，对于有一些程序，如果有多个解析树，那么我们就需要使用编译器对程序的两种歧义进行选择来生成代码</p> 
<p>当然，我们不希望出现歧义，编程语言中不希望出现模棱两可的地方</p> 
<h4><a id="_3090"></a>消除歧义</h4> 
<p><img src="https://images2.imgbox.com/de/84/8xm1ru6W_o.png" alt="image-20220206232017265"></p> 
<p>最直接的方法就是重写语法</p> 
<p>我们的字符串仍然是<code>id*id+id</code></p> 
<p><img src="https://images2.imgbox.com/b3/f0/M8mDkF7O_o.png" alt="image-20220206232136196"></p> 
<p>我们从E开始，E不再生成一个+或者*号</p> 
<p>我们讲语法分为了两组产生式，两个非终结符</p> 
<p>E’ 负责乘法E负责加法</p> 
<p><img src="https://images2.imgbox.com/a0/d4/iB5fGXo5_o.png" alt="image-20220206232320989"></p> 
<p>我们刚开始必须选用<code>E'+E</code>没有其他写法</p> 
<p>我们看E‘的产生式，它能够生成id×其他东西 E’的乘法需要生成优先级表达式，但是带括号的优先级表达式和我们尝试解析的字符串不匹配也就是<code>(E)*E'</code> 我们只能使用 <code>id * E'</code></p> 
<p><img src="https://images2.imgbox.com/cd/d8/w5IDOEdi_o.png" alt="image-20220206232635844"></p> 
<p>为了匹配字符串，E‘ 只能替换为id，这里只有一个产生式可以做到</p> 
<p>夹在*号和+号之间的元素</p> 
<p>那么剩下的一个E怎么办</p> 
<p><img src="https://images2.imgbox.com/22/64/pxdBKg2R_o.png" alt="image-20220206232746978"></p> 
<p>E 变E’ 在变id</p> 
<p><img src="https://images2.imgbox.com/7b/95/SEOMtaXO_o.png" alt="image-20220206232812155"></p> 
<p>我们将产生式分类，一个处理加法一个处理乘法，每个运算符都有一个非终结符</p> 
<p>E 用来处理加法，</p> 
<p><code>E -》 E' +E -&gt; E'+E'+E -&gt; E'+E'+E'+E'+E-&gt; E‘+E'....E'</code></p> 
<p>任意数量的E‘相加，停止后，我们把最后一个E转换为E’</p> 
<p><img src="https://images2.imgbox.com/29/90/T9547a5W_o.png" alt="image-20220206233236893"></p> 
<p>E’的前两个产生式用来处理乘法id*，后两个产生式用来处理括号</p> 
<p><code>E'-&gt;id*E'-&gt;id*id*E'-&gt;id*id*id*id*E'-&gt;id*id*id...*id</code></p> 
<p>或者我们生成带括号的</p> 
<p><img src="https://images2.imgbox.com/7f/09/qE4yk9nA_o.png" alt="image-20220206233509492"></p> 
<p>消除歧义的做法：</p> 
<p>所有加法必须是在乘法操作之前生成的</p> 
<p>乘号将比加号在解析树的更下方（更深处）</p> 
<p>E’在加法操作内生成乘法操作</p> 
<p>这个语法强制乘法优先级比加法高</p> 
<p><img src="https://images2.imgbox.com/b6/08/8QpprChh_o.png" alt="image-20220206233817557"></p> 
<p>在括号表达式的是E 而不是E‘</p> 
<p>因为括号可以提高优先级，括号里面可以是加法</p> 
<p><img src="https://images2.imgbox.com/5e/87/rjOt99tl_o.png" alt="image-20220207174539787"></p> 
<p>通过重写语法，右边的解析树就无法使用了，左侧的解析树会有一定的更改</p> 
<p><img src="https://images2.imgbox.com/70/bb/S6Diulzg_o.png" alt="image-20220207174618657"></p> 
<h4><a id="example_3168"></a>example</h4> 
<p><img src="https://images2.imgbox.com/a7/98/nkM1UdHA_o.png" alt="image-20220207175333051"></p> 
<p>我们这里通常会有if then else</p> 
<p>同时也会有if then 没有else的产生式</p> 
<p>也可能有其他other表达式</p> 
<p><img src="https://images2.imgbox.com/71/3f/ZnDulYGP_o.png" alt="image-20220207175531447"></p> 
<p>这个表达式也会产生歧义，</p> 
<p>也就是两种解析树</p> 
<p>1- 可能是if E2 then E3 一组，是内部的，，if E1 then else E4 为一组</p> 
<p>2- 也可能是if E1 then 一组 if E2 then E3 else E4 一组</p> 
<p>当然我们想要的是第二种，也就是需要规定，else和离他最近的if-then相关联</p> 
<p><img src="https://images2.imgbox.com/20/04/hUYkQQAd_o.png" alt="image-20220207200257461"></p> 
<p>我们的if语句会分为两类</p> 
<p>一种是被匹配的，将所有嵌套在其中的then-else语句与if匹配</p> 
<p>一种是没有被匹配的，就是在内部有一些then</p> 
<p>if-then-else 是最常见的if匹配，在他的分支中，任何内嵌的if语句都必须要有匹配的else 如果有非if-else的构造，也能够被认为是一个已经配对儿的if</p> 
<p>都是<code>MIF</code> 配对儿过的if</p> 
<p>那么关于未匹配的if呢</p> 
<p>一种可能就是他是一个未匹配的if没有else 也就是<code>if-then</code></p> 
<p>另一种就是<code>if -then-else</code> then 里是MIF 也就是匹配的if，else后的才是UIF</p> 
<p>这里是为什么呢？</p> 
<p>如果我们的这里不是MIF 也就是 UIF， 那么里面就是if then 必然就会和后面的else 就近原则匹配在一起</p> 
<p><img src="https://images2.imgbox.com/86/4b/klfEEiaR_o.png" alt="image-20220207202755795"></p> 
<p><img src="https://images2.imgbox.com/cc/8b/99ZRC8lA_o.png" alt="image-20220207202944480"></p> 
<p>那么我们来回顾之前的表达式</p> 
<p>else是匹配了最近的if then</p> 
<p><img src="https://images2.imgbox.com/94/13/51os0ynJ_o.png" alt="image-20220207203013220"></p> 
<p>有歧义的语法自动转换为一个明确的语法，这是不可能的</p> 
<p>必须我们手动来做</p> 
<p><img src="https://images2.imgbox.com/3a/9f/fWIQPvr3_o.png" alt="image-20220207203607724"></p> 
<p>一种方法就是我们会以某种方式将这种模棱两可的特性纳入其中，这能让我们有更深入的自然语义</p> 
<p>另一种就是、我们需要一些消除歧义的机制</p> 
<p>当多个解析树出现的时候，值出哪个解析树是我们想要的</p> 
<p><img src="https://images2.imgbox.com/89/3e/PisCMRk3_o.png" alt="image-20220207203833129"></p> 
<p>当然我们不会去重写语法，我们会使用更自然的歧义语法，配合消除歧义机制来做，一些工具也会提供消除歧义声明</p> 
<p>最常见的就是优先级和关联性声明</p> 
<p><img src="https://images2.imgbox.com/b4/92/M87t0lB0_o.png" alt="image-20220207204017153"></p> 
<p>即使只有一个中缀，也会产生歧义</p> 
<p>这里 我们定义加号为左相连性 是<code>BISON</code>中的表示法，</p> 
<p><img src="https://images2.imgbox.com/49/36/QF1Qe3cb_o.png" alt="image-20220207204104648"></p> 
<p><img src="https://images2.imgbox.com/78/8d/wmb8aomx_o.png" alt="image-20220207204112636"></p> 
<p>有一个更复杂的语法， 有加法，乘法，</p> 
<p>我们定义多个关联性 和优先性</p> 
<p><img src="https://images2.imgbox.com/66/80/IpgVmj2O_o.png" alt="image-20220207204154648"></p> 
<p>乘法排在加法后面也就是乘法具有比加法更高的优先级</p> 
<h3><a id="0601_Error_Handling_13m03s_3272"></a>06-01: Error Handling (13m03s)【错误处理】</h3> 
<p>编译器有两个职责，通过程序代码生成更低级的代码</p> 
<p>另一个就是 给错误处理程序提供良好的反馈，检测无效的程序</p> 
<p>针对不符合语法的无效代码不进行编译</p> 
<p>比如词法错误，使用了根本不会再该语言中出现的字符，会在词法分析中找到</p> 
<p>语法错误 每个词法单元能够正确识别后，组合起来，不能生效，这种情况就是解析错误，</p> 
<p>语义错误，类型检查器就会进行捕获</p> 
<p><img src="https://images2.imgbox.com/af/6b/7d44nlvf_o.png" alt="image-20220207231407750"></p> 
<p>剩下的问题由使用者解决</p> 
<h4><a id="_3290"></a>处理错误需要什么</h4> 
<p><img src="https://images2.imgbox.com/ae/b9/jTgo9nbC_o.png" alt="image-20220207231451001"></p> 
<p>1- 需要编译器能够准确清晰的报告错误</p> 
<p>2- 编译器能够从错误中很快的恢复过来</p> 
<p>3- 不应该让错误处理机制来降低有效代码的编译速度</p> 
<h4><a id="error_handling_3300"></a>error handling</h4> 
<p>我们使用紧急模式和错误产生式</p> 
<p>旧的方法是：自动局部或者全局校正 过分追求完美</p> 
<p><img src="https://images2.imgbox.com/2a/4c/LqVO0O9z_o.png" alt="image-20220207231635089"></p> 
<p><img src="https://images2.imgbox.com/81/ba/Soz36LS9_o.png" alt="image-20220207231752119"></p> 
<p>紧急模式比较简单，当有一个错误被检测到时，解析器开始抛弃token知道在这么语言中找到一个作用明确的token为止</p> 
<p>编译器会自己重启，从那个新的token继续工作</p> 
<p>这个寻找的这些token被称为同步token（synchronizing token）</p> 
<p>也就是说，当遇到问题的时候，通常的解决方案就是试着跳到语句的末尾或者函数的末尾</p> 
<h4><a id="panic_example_3318"></a>panic example</h4> 
<p><img src="https://images2.imgbox.com/eb/49/4mmWUbYt_o.png" alt="image-20220207232201492"></p> 
<p>例如<code>(1++2)+3</code></p> 
<p>这里多了一个+号，</p> 
<p>解析器读取到第二个加号的时候，就卡住了，这里先忽略自增</p> 
<p>他切换模式，然后开始不断地丢弃输入的字符，直到遇到解析器能够识别的字符，这种错误的恢复就是，有一个规则，挑倒下一个数字，然后试着继续往下走</p> 
<p>我们就将第二个+号忽略了</p> 
<h5><a id="bsion_3332"></a>bsion</h5> 
<p>bison是一种广泛使用的解析生成器，</p> 
<p>bison有一种被称为error的特殊终结符，可以用来描述多少输入需要调过</p> 
<p>bison的产生式为</p> 
<p><img src="https://images2.imgbox.com/78/68/S9Cdk07q_o.png" alt="image-20220207232718773"></p> 
<p>E 可以是一个数字，可以是两个E之和，或者两个表达式相加，括号表达式，</p> 
<p>如果不是这三种normal的表达式，那就是 error（bison特有的）</p> 
<p><code>error int</code> 就是抛出所有的输入，直到遇到下一个int数字，同理，括号表达式中有错误，直接忽略内部，继续解析</p> 
<h4><a id="error_production_3352"></a>error production</h4> 
<p>另一种策略 错误产生式</p> 
<p><img src="https://images2.imgbox.com/50/fd/CHpehi10_o.png" alt="image-20220207232233620"></p> 
<p>也就是编译器设计者可能知道代码中有一些常见错误，使用增强语法，在遇到这些错误是生成相关的错误结构</p> 
<p>也就是将程程序员已知的错误指定为语法中的替代产生式</p> 
<p>5x一般来说代表5*x但是计算机不会识别</p> 
<p>因此增加一个产生式就可，E-&gt;EE</p> 
<p>缺点是 我们的语法比较复杂，难维护（但是在实践中比较多）</p> 
<h4><a id="__3368"></a>最后一个策略 错误更正</h4> 
<p><img src="https://images2.imgbox.com/a7/90/pZgegw5V_o.png" alt="image-20220207234401521"></p> 
<p>一些错误编译器会帮你改，找到合适的替换程序</p> 
<p>可以进行一些token的插入和删除</p> 
<p>这里就是想要将edit distance 编辑距离最小化，也就是（a转换为b最少操作次数） 这是一种量化测量方式，用来判断一个程序是否接近程序员所提供的源程序</p> 
<p>或者可以在一定范围内详细的搜所，来找到与源程序相近的所有可能的程序</p> 
<p>exhaustive（详尽的）</p> 
<p>缺点就是</p> 
<p>比较难实现，降低对正确程序的解析速度，因为我们需要存储足够多的状态（替换规则） 让我们去搜所，进行距离编辑保证最小化改动</p> 
<p>意思表达的相近 可能并不会被程序员接收，因为可能是不符合预期的</p> 
<p>错误更正做的比较好的就是PL/C编译器</p> 
<p>PL代表PL/1编译器，C代表东阿是康奈尔大学</p> 
<h4><a id="past__3394"></a>past 过去的错误处理</h4> 
<p><img src="https://images2.imgbox.com/7f/c0/48aNX8IV_o.png" alt="image-20220207232338379"></p> 
<p>在过去，</p> 
<p>重编译非常的慢，可能你一跑就是一天</p> 
<p>一旦由于你输入错误一个关键字，编译器就会尝试努力找到一个可运行的程序，如果修正小，就会减少你的时间，</p> 
<p>在现在，</p> 
<p>重编译很快，</p> 
<p>一个周期一个bug，发现并且修复第一个错误，</p> 
<h2><a id="0602_Abstract_Syntax_Trees_3m50s_3409"></a>06-02: Abstract Syntax Trees (3m50s)【抽象语法树】</h2> 
<p><img src="https://images2.imgbox.com/7d/f1/1WblD6cG_o.png" alt="image-20220208164015979"></p> 
<p>解析器用来跟踪一系列词法单元的推导</p> 
<p>但是 编译器还需要知道程序所代表的含义</p> 
<p>编译器需要一种实际的数据结构来告诉他程序中有什么操作</p> 
<p>解析树并不是我们想要处理的数据结构，我们是在抽象语法树的数据结构上面进行工作</p> 
<p>abbreviated（缩写）</p> 
<p>抽象语法树缩写为AST</p> 
<p><img src="https://images2.imgbox.com/ee/3c/DZoflgEF_o.png" alt="image-20220208173251343"></p> 
<p>这里有一个关于整数的加法运算和括号表达式</p> 
<p>有一个输入字符串，经过词法分析后，得到一个词法单元序列以及对应的词素</p> 
<p>接着传入解析器，就会构建出一颗解析树</p> 
<p><img src="https://images2.imgbox.com/5c/3b/7JgA0bvd_o.png" alt="image-20220208173430646"></p> 
<p>解析树十分的冗余</p> 
<p>E 转换为int 就不是必要的</p> 
<p><img src="https://images2.imgbox.com/0c/7b/Rm8SoIZp_o.png" alt="image-20220208173618922"></p> 
<p>因此选用AST来将这些垃圾信息进行压缩</p> 
<p><img src="https://images2.imgbox.com/05/b1/q4eE2Zi2_o.png" alt="image-20220208173659148"></p> 
<p>我们有两个加法，三个参数</p> 
<p>他们之间的关联性就是看那个加号在另一个里面</p> 
<p>我们也没有任何无关的非终结符元素，也没有括号</p> 
<p>AST 取消了具体语法的细节，保留了足够的信息，能够很好的表示程序要做的事情，并进行编译</p> 
<h3><a id="0603_Recursive_Descent_Parsing_6m35s_3453"></a>06-03: Recursive Descent Parsing (6m35s)【递归下降解析】</h3> 
<p>递归下降解析是一种自上而下的解析算法 Top-down</p> 
<p>在自上而下的解析算法中，解析树是从上面开始构建的</p> 
<p>从根节点开始，按照从左到右的顺序</p> 
<p>终结符元素会按照他们在词法单元字符串中出现的顺序进行排序</p> 
<p>例如<code>t2 t5 t6 t8 t9</code> 就会构建如下的图</p> 
<p><img src="https://images2.imgbox.com/9e/ac/lLf23vtk_o.png" alt="image-20220208221712258"></p> 
<h4><a id="example_3467"></a>example</h4> 
<p>整数表达式的语法</p> 
<p><img src="https://images2.imgbox.com/df/85/0cwxeSkx_o.png" alt="image-20220208221921726"></p> 
<p>输入是一个<code>（int5）</code></p> 
<p>我们使用递归下降策略解析这个表达式</p> 
<p>我们从一个非终结符元素开始，也就是根节点，尝试E-》T ，不行的话尝试E-》T+E</p> 
<p>当一个产生式失败的时候，就需要替换为其他的产生式</p> 
<p><img src="https://images2.imgbox.com/b3/4b/zmjNoA38_o.png" alt="image-20220208222414140"></p> 
<p>我们首先尝试采用E-&gt;T</p> 
<p>然后T-&gt;INT</p> 
<p>但是我们的输入是括号，因此不能和这个解析树进行匹配，我们就需要回溯几步，如果是<code>(E)</code> 这个就可以进行匹配了</p> 
<p>我们回溯一步，接着采用</p> 
<p>T-&gt;INT*T</p> 
<p><img src="https://images2.imgbox.com/22/54/dxLb7z0W_o.png" alt="image-20220208222904020"></p> 
<p>接着使用int和<code>(int5)</code> 进行匹配，很明显，不匹配，</p> 
<p>接着和（E） 匹配</p> 
<p><img src="https://images2.imgbox.com/1f/ed/iUYzJvfj_o.png" alt="image-20220208222934796"></p> 
<p>括号匹配到了</p> 
<p>接着我们需要扩展括号里面的E</p> 
<p><img src="https://images2.imgbox.com/09/6a/3wdnKaqw_o.png" alt="image-20220208223020427"></p> 
<p><img src="https://images2.imgbox.com/d9/9d/Sj6MopnV_o.png" alt="image-20220208223206846"></p> 
<p>同样逐个匹配，然后最终指针指向字符串的下一个位置，</p> 
<p>也就是我们接受这个解析树，解析器会成功结束</p> 
<h4><a id="quiz_3513"></a>quiz</h4> 
<p><img src="https://images2.imgbox.com/c4/a0/9BcCf780_o.png" alt="image-20220212162455621"></p> 
<p><img src="https://images2.imgbox.com/c1/c3/WySolsE2_o.png" alt="image-20220212162502233"></p> 
<p><img src="https://images2.imgbox.com/50/9a/nf4ag0Om_o.png" alt="image-20220212162914931"></p> 
<p><img src="https://images2.imgbox.com/a1/57/MqTaItcB_o.png" alt="image-20220212162951121"></p> 
<h3><a id="0604_Recursive_Descent_Algorithm_13m28s_3529"></a>06-04: Recursive Descent Algorithm (13m28s)【递归下降算法】</h3> 
<p>背景提要</p> 
<p><img src="https://images2.imgbox.com/73/5f/9VzXHyZt_o.png" alt="image-20220212163252186"></p> 
<p>TOKEN 代表了一系列的词法单元 用来写代码用，比如有INT,OPEN,CLOSE,PLUS,TIMES 等token</p> 
<p>需要一个全局变量指针，next，指向下一个输入的token</p> 
<p><img src="https://images2.imgbox.com/6d/2b/WfMGD996_o.png" alt="image-20220212163617230"></p> 
<p>我们首先定义一些define，用来匹配输入中所给定的token的函数</p> 
<p><code>bool term(TOKEN tok){return *next++ == tok;}</code></p> 
<p>这里返回的是boolean值，如果我们传入的token和输入的相匹配，就是true</p> 
<p>无论是true还是false,指针都会向前</p> 
<p>第二个定义的函数是，对S的第n个产生式进行匹配</p> 
<p><code>bool Sn(){...}</code></p> 
<p>这个是用来检查里面是否有与S中产生式成功匹配的函数</p> 
<p>第三个就是验证匹配S中所有产生式的函数</p> 
<p><code>bool S(){...}</code></p> 
<p>也就是有任意一个产生式能够匹配输入，我们就解析成功</p> 
<p>对于每个非终结符元素，我们都有两类函数</p> 
<p>一类就是对于每个产生式都有一个对应函数，他检查这个产生式是否能和这个输入匹配上</p> 
<p>另一类就是将关于这个特定非中介元素的所有产生式组合在一起，然后检查这些产生式中是否有任何一个能和输入进行匹配</p> 
<h4><a id="example_3571"></a>example</h4> 
<p>这个语法的第一个产生式是E-&gt;T</p> 
<p>我们想一个函数，判断该产生式能否匹配某些输入</p> 
<p><img src="https://images2.imgbox.com/8d/5d/tPOXiWCv_o.png" alt="image-20220212165910560"></p> 
<p><code>bool E1(){return T();}</code></p> 
<p>首先我们写出函数E1 它用来处理第一个产生式E，仅当产生式成功匹配输入的时候返回true</p> 
<p>这个函数如何匹配输入的呢?</p> 
<p>也就是在当T的部分产生式匹配输入的时候，他才能匹配一些输入，也就是T()函数</p> 
<p>T（）返回结果为true的时候，E1才会返回true</p> 
<p>对于第二个产生式<code>for production E-&gt;T+E</code></p> 
<p><code>bool E2() {return T() &amp;&amp; term(PLUS) &amp;&amp; E();}</code></p> 
<p>首先函数T() 必须要匹配一些输入，T中的一些产生式必须匹配输入中的一部分内容，才可以接着走下去</p> 
<p>我们必须在匹配T的输入中找到一个带+号的输入，也就是PLUS</p> 
<p>如果加号匹配了，对于E（）所代表的产生式需要匹配输入中的一部分</p> 
<p>&amp;&amp; 与运算 在C和C++中是按照从左到右的顺序来计算</p> 
<p>先T（） 执行到找到后，执行trem（PLUS） 在执行E（）</p> 
<p>最后一个产生式E，<strong>这里需要回滚</strong></p> 
<p>我们需要E能够匹配更多，也就是为他写一个备选函数</p> 
<pre><code>bool E(){
	TOKEN *save = next;
	return (next = save,E1()) || (next = save,E2());
}
</code></pre> 
<p>输入需要匹配这两个中的一个</p> 
<p>我们在回滚中需要考虑next指针，因此我们使用局部变量save，用来记录我们最初next的位置</p> 
<p>如果E1匹配成功，E2就不会去匹配，会在<code>||</code>停止</p> 
<p>E1的next=save这句为了工整才写，没有其他作用</p> 
<p>E1返回false，第二部分为true，就需要恢复next，</p> 
<p>如果E返回true，就需要去找其他方法了，</p> 
<h4><a id="Functions_for_nonterminal_T_3630"></a>Functions for non-terminal T</h4> 
<p><img src="https://images2.imgbox.com/52/9f/HvNFVvzG_o.png" alt="image-20220212182243197"></p> 
<p>对于非终结符T，有三个产生式匹配函数</p> 
<p>第一个产生式就是</p> 
<p><code>bool T1(){return term(INT;)}</code></p> 
<p>也就是T-&gt;int</p> 
<p>去匹配terminal(int)</p> 
<p>因此我们接下来输入的就是整数才会进行匹配</p> 
<p>第二个产生式就是T-&gt;int*T</p> 
<p><code>bool T2(){return term(INT) &amp;&amp; term(TIMES) &amp;&amp; T();}</code></p> 
<p>因此我们需要匹配的就是int，后跟一个*，在跟一个T这个产生式的内容</p> 
<p>第三个产生式是<code>T-&gt;(E)</code></p> 
<p><code>bool T3() {return term(OPEN) &amp;&amp; E() &amp;&amp; term(CLOSE);}</code></p> 
<p>先匹配左括号， 然后匹配函数E能够匹配的，然后匹配右括号</p> 
<p>将他们三个放入函数T（） 当备选</p> 
<p><img src="https://images2.imgbox.com/40/85/y48OyEDK_o.png" alt="image-20220212183427755"></p> 
<p>启动解析器</p> 
<p>初始化指针，调用E()</p> 
<p>递归下降解析器很容易手动实现</p> 
<h4><a id="summarize_3674"></a>summarize</h4> 
<p><img src="https://images2.imgbox.com/f4/85/BzFmo5HP_o.png" alt="image-20220212183556472"></p> 
<p>最上面是我们的两个语法</p> 
<p>下面是我们根据递归下降的所有代码</p> 
<p>我们的输入是<code>(int)</code></p> 
<p>指针从开始记录token，<code>(</code></p> 
<p>然后我们构建解析树，从E开始推导，</p> 
<p>接着尝试E1，调用了T</p> 
<p><img src="https://images2.imgbox.com/fe/b9/ZVes4M5q_o.png" alt="image-20220212183737146"></p> 
<p>T又去调用，后面的三个</p> 
<p><img src="https://images2.imgbox.com/3d/3e/DSoGGI0N_o.png" alt="image-20220212183751528"></p> 
<p>T1失败。T2失败，T3成功</p> 
<p>然后指针指向了int</p> 
<p><img src="https://images2.imgbox.com/40/85/zamFNVsO_o.png" alt="image-20220212183941706"></p> 
<p>然后我们重新调用E，E调用了E1</p> 
<p>只有匹配了T才能够匹配E1，因此这个树从T接着画</p> 
<p><img src="https://images2.imgbox.com/9a/67/rmScTmLg_o.png" alt="image-20220212184029429"></p> 
<p>在T中，逐步尝试，匹配了T1，</p> 
<p><img src="https://images2.imgbox.com/97/e3/NkkSKmMf_o.png" alt="image-20220212184242988"></p> 
<p>匹配右括号后，成功解析字符串</p> 
<h4><a id="quiz_3716"></a>quiz</h4> 
<p><img src="https://images2.imgbox.com/08/8b/yBzFtrMy_o.png" alt="image-20220212185024726"></p> 
<p><img src="https://images2.imgbox.com/bd/19/mMUjbbJ9_o.png" alt="image-20220212185037903"></p> 
<h3><a id="06041_Recursive_Descent_Limitations_6m56s_3724"></a>06-04-1: Recursive Descent Limitations (6m56s)【自顶向下递归局限性】</h3> 
<p>从上节课开始，我们</p> 
<p><img src="https://images2.imgbox.com/de/f0/a4tNrxA5_o.png" alt="image-20220213164701332"></p> 
<p>假设有一个int，我们如何匹配呢？</p> 
<p>首先E()-&gt;T()-&gt;T1()</p> 
<p>T1识别int返回true，</p> 
<p>那么我们假设有一个int*int 怎么匹配</p> 
<p>E()-&gt;E1()-&gt;T()-&gt;T1() 然后我们匹配到了int，T1返回true，逐步向上逐步true，然后匹配字符串结束，然后rejected</p> 
<p><img src="https://images2.imgbox.com/39/36/SOYsfeLw_o.png" alt="image-20220213170704985"></p> 
<p>这里是为什么呢？ 因为你没有匹配到语法，</p> 
<p>我们如果匹配的是T2（） 那么肯定是一个乘法，虽然有回滚，但是也是在第一个T1 也就是匹配int，失败以后，才会去尝试下一个T2</p> 
<p><img src="https://images2.imgbox.com/36/4c/Ss5SHSh0_o.png" alt="image-20220213171336016"></p> 
<p>这里的问题是如果找到一个能应用于非终结符元素的产生式的话，之后就没办法进行回滚了，</p> 
<p>因此，一旦针对x的函数有返回值，就结束了，因此递归下降算法，并不是完全通用的，</p> 
<p><img src="https://images2.imgbox.com/33/53/tzBiOhcB_o.png" alt="image-20220213171526549"></p> 
<p>展示递归下降是因为，递归下降很容易实现，但是有局限性</p> 
<p>我们可以看到，根据一个给定的语法，去设计一个而解析器是非常简单的，而且适用于相当大的一类语法，它适用于任何语法，在该语法中，任意一个非终结符最多使用一个产生式就可以完成解析，可以用来构建我们自己的语法，在任何情况下都可以使用递归下降算法解析</p> 
<p>我们需要优化/重写这个算法</p> 
<h3><a id="0605_Left_Recursion_Part_1_8m05s_3764"></a>06-05: Left Recursion Part 1 (8m05s)【左递归】</h3> 
<p><img src="https://images2.imgbox.com/d6/b8/W3P8re81_o.png" alt="image-20220213172200334"></p> 
<p>首先有例子S-&gt;Sa</p> 
<p><img src="https://images2.imgbox.com/24/0f/PXQE9bkc_o.png" alt="image-20220213172337117"></p> 
<p>我们写两个函数，就不需要去回滚了，只要s1成立，s就成立</p> 
<p>但是，很明显，这里有问题，</p> 
<p>输入字符串我们就调用s，s调用s1，s1调用s，无限循环</p> 
<p>infinite（无限的）</p> 
<p>原因就是 他是左递归，左递归语法是指具有非终结符的任何语法（就是对S解释中又包含了S这个非终结符）</p> 
<p>如果从非终结符开始，就要做一系列非空序列重写，就需要循环调用，</p> 
<p><img src="https://images2.imgbox.com/b0/1c/1navzQUo_o.png" alt="image-20220213172843749"></p> 
<p>+号就是重写很多次，我们无限次的对最左边的进行替换，对最左边的进行解析</p> 
<p><img src="https://images2.imgbox.com/0c/25/GCGMbWVR_o.png" alt="image-20220213173022153"></p> 
<p>我们就不能匹配任何输入，他从S-&gt;Sa-&gt;Saa，一直把最左边的s替换掉</p> 
<p>递归下降的解析方式不适合左递归语法</p> 
<h4><a id="_3794"></a>左递归语法形式</h4> 
<p><img src="https://images2.imgbox.com/cc/a6/V03XbCm1_o.png" alt="image-20220213183230643"></p> 
<p>S-&gt;Sα S-&gt;β</p> 
<p>这里有两个关于S的产生式</p> 
<p>也就是说，字符串的生成就是，一个β和后面任意数量的α</p> 
<p><code>S-&gt;Sα-&gt;Sαα-&gt;...-&gt;βααααααααααα。。</code></p> 
<p>我们这个字符串，我们可以看到， 先生成的α，第一个β是最后生成的，也就是为什么递归下降不能够生成字符串的原因，</p> 
<p>我们可以通过右递归，代替左递归，</p> 
<p>重写使用右递归，</p> 
<p><img src="https://images2.imgbox.com/9e/0d/EUfe2l8d_o.png" alt="image-20220213184642549"></p> 
<p>第一个位置是β，S‘ 是代表一系列α，当然也可能是空字符串</p> 
<p><code>s-&gt;βS'-&gt;βαS'-&gt;...-&gt;βααααααααααα</code></p> 
<p>我们最后生成的两个字符串完全一样</p> 
<p><img src="https://images2.imgbox.com/2f/bb/ingTOCXP_o.png" alt="image-20220213184945542"></p> 
<p>我们会有很多产生式，有些是左递归，有些不是，</p> 
<p>这些字符串从β开始，不包含S，但是后面会跟着0个或多个α</p> 
<p><img src="https://images2.imgbox.com/3c/b0/vR4FlChQ_o.png" alt="image-20220213185237441"></p> 
<p>右递归来重写左递归，多一个S’</p> 
<p><img src="https://images2.imgbox.com/14/bd/qKFPLGMY_o.png" alt="image-20220213185001619"></p> 
<p>这并不是左递归最常见的形式，有其他方法来对在一个语法中的左递归进行编码</p> 
<p>首先有一个看起来不像左递归的语法，</p> 
<pre><code>S-&gt;Aα|
A-&gt;Sβ
</code></pre> 
<p>第一个产生式右侧甚至没有S，</p> 
<p>第二个产生式右侧并没有A</p> 
<p>这两个在语法中被称为非直接左递归</p> 
<p>其实是一个左递归，因为S会变为Aα，然后又能变成为Sβα</p> 
<p>花两步生哼另一个左侧有S的字符串</p> 
<p><code>S-&gt;Aα-&gt;Sβα</code></p> 
<p>因此在这个S返回之前，我们可以在最左位置是插入其他的非终结符来对他进行延迟操作</p> 
<p>这个左递归能够自动消除，在龙书里面有实现的算法</p> 
<h4><a id="summarize_3859"></a>summarize</h4> 
<p><img src="https://images2.imgbox.com/13/dc/rw6WGwqT_o.png" alt="image-20220213185031863"></p> 
<p>在常见的解析策略中，他是很简单的一个例子，你能够通过使用递归下降来解析任何上下文无关法，但他不适用于左递归文法</p> 
<p><img src="https://images2.imgbox.com/6b/97/Oj7m1ndJ_o.png" alt="image-20220213191723991"></p> 
<p>因此必须消除左递归，实际上，人门通常手动消除左递归，</p> 
<p>gcc的前端就是用的手写递归下降解析器</p> 
<h2><a id="CS143_Week4_BottomUp_Parsing__3873"></a>CS-143 Week4 Bottom-Up Parsing 【自底向上解析】</h2> 
<h3><a id="0701_Predictive_Parsing_Part_1_7m40s_3875"></a>07-01: Predictive Parsing Part 1 (7m40s)【预测解析】</h3> 
<p>我们使用预测解析继续对自上而下的解析算法进行处理</p> 
<p><img src="https://images2.imgbox.com/4d/64/xhCYXt93_o.png" alt="image-20220214163609515"></p> 
<p>预测解析和递归下降很像，依然是一个自上而下的解析器，</p> 
<p>但是它能够预测该使用哪个产生式，永不出错，</p> 
<p>这个解析器能够正确的猜出该使用哪个产生式来得到一个正确的解析</p> 
<ul><li>第一个“L”：left to right，按照从左到右的顺序处理输入的token序列</li><li>第二个“L”：leftmost derivation，从文法的最左边开始进行推导</li><li>“(1)”：使用1个token来预测解析的方向（当然也有LL(n)）</li></ul> 
<p>预测解析有两个特征：</p> 
<p>1- 解析器会去看接下来的一些token，会采用向前看的方式来尝试值出该使用哪个产生式 lookahead 但是限制于语法形式很固定的情况</p> 
<p>2-解析器不需要回滚，能够自己肯定所要使用的产生式</p> 
<p>预测解析器接受一种<code>LL(k)</code> 的语法</p> 
<p>第一个L 按照从左到右的顺序读取</p> 
<p>第二个L代表了最左推导，使用最左推导构建解析树，</p> 
<p>k代表有k个需要向前看的token k可以是任意数 我们只讨论1的情况</p> 
<p><img src="https://images2.imgbox.com/8e/97/d62IWwKt_o.png" alt="image-20220214170353136"></p> 
<p>在递归下降的规则中，每一步都有很多的产生式供我们选择，必须要去回滚来撤销错误的选择，</p> 
<p>在LL(1)解析器中，每一步只会有一个可供选择的产生式来进行使用</p> 
<p>如果有一个输入字符串，这个字符串中，有一些终结符号w和一个非终结符号A，后面可能还有一些其他字符串</p> 
<p><code>wAβ</code> 下一个输入的token是T</p> 
<p>这里有一个产生式<code>A-&gt;α</code> 我们只能使用这个，甚至这个产生式都可能会不成功，</p> 
<p>但是在LL(1) 解析器中，始终会有最多一个可供我们使用的产生式</p> 
<p>在这个例子中，我们会将字符串重写为<code>wαβ</code></p> 
<p><img src="https://images2.imgbox.com/13/6f/9eX3aLhG_o.png" alt="image-20220214172656360"></p> 
<p>T的前两个都是int开头，如果说输入流中有int，并不能帮助你判断使用这两个产生式中的哪个去使用，</p> 
<p>只是向前看一个token的话，没有办法再这两个产生式中进行选择，</p> 
<p>我们对E也有同样的问题，不光是T</p> 
<p>E的两个产生式都是以非终结符T开头</p> 
<p>仅向前看一个token，去判断，并不容易</p> 
<p>我们需要改变语法，上面的语法，对于预测解析是不能接受的</p> 
<p>我们提取左公因子</p> 
<p>提取左公因子的思路就是消除一个非终结符的多个产生式的公共前缀</p> 
<p><img src="https://images2.imgbox.com/4e/5e/AwY0d5Gp_o.png" alt="image-20220214175450963"></p> 
<pre><code>E-&gt;TX
X-&gt;+E|epsilon
</code></pre> 
<p>这里引入一个新的非终结符X用来处理剩下的部分</p> 
<p>这样会延迟我们选用哪个产生式</p> 
<p>第二个</p> 
<pre><code>T-&gt;intY|(E)
Y-&gt;*T|epsilon
</code></pre> 
<p>(E) 不受影响，所以可以写在第一步里面</p> 
<p><img src="https://images2.imgbox.com/2a/ef/bNh9fwGh_o.png" alt="image-20220214180136702"></p> 
<p>这个是我们提取左因子之后的语法，</p> 
<p>使用这个语法构建解析表</p> 
<h4><a id="example_3973"></a>example</h4> 
<p><img src="https://images2.imgbox.com/51/e0/3buMyyTg_o.png" alt="image-20220214180259229"></p> 
<p>第一个TX格子的意思是找到当前非终结符为E，同时下一个输入是int的格子</p> 
<p>我们使用产生式 E-&gt;TX</p> 
<p><img src="https://images2.imgbox.com/db/74/idhRjchH_o.png" alt="image-20220214180309331"></p> 
<p>当左侧是Y，下一个是+号</p> 
<p>唯一解析的就是不生成任何东西，如果想要解析这个字符串的话，需要拜托T并且而移动到另一个非终结符上，也就是Y之后的最左非终结符</p> 
<p>这里有很多单元格都是空的</p> 
<p><img src="https://images2.imgbox.com/ea/40/zdXxrtQj_o.png" alt="image-20220214180318022"></p> 
<p>最左终结符是E，token是* 那么没办法选择任何产生式，就会遇上解析错误</p> 
<h4><a id="_3997"></a>解析表进行解析的算法</h4> 
<p><img src="https://images2.imgbox.com/b5/aa/WcG3UfBl_o.png" alt="image-20220214183741177"></p> 
<p>我么你需要看最左非终结符S，同时要看下一个输入token，通过解析表查找（S,a）这一格的产生式，而不是通过递归函数去构建解析树</p> 
<p>我们使用栈的方式来记录边界</p> 
<p>解析树上我们会有一些还未展开的非终结符，他们始终处于当前解析树的叶子节点上，</p> 
<p>当然还有一些未被匹配的终结符，他们会被记录在栈中，</p> 
<p>这个栈的重要属性就是把最左终结符或非终结符始终放在栈顶</p> 
<p>因此我们试着去匹配的终结符还是尝试去展开的非终结符，他们始终处于栈顶</p> 
<p>如果我们找到空单元格，直接拒绝解析</p> 
<p>如果我们到达输入的末尾的话，就会有一个空的栈，这样就会接受这个解析，意味着没有待处理的不匹配终结符或者为扩展的非终结符了</p> 
<p><img src="https://images2.imgbox.com/4d/b6/8OorI5U6_o.png" alt="image-20220214183802804"></p> 
<p>这个是他的算法，我们将栈初始化，里面有开始符号S和特殊符号$</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         符 
        
       
         号 
        
       
         并 
        
       
         不 
        
       
         属 
        
       
         于 
        
       
         字 
        
       
         符 
        
       
         表 
        
       
         中 
        
       
         的 
        
       
         一 
        
       
         部 
        
       
         分 
        
       
         ， 
        
       
         我 
        
       
         们 
        
       
         将 
        
       
         字 
        
       
         符 
        
       
         表 
        
       
         进 
        
       
         行 
        
       
         了 
        
       
         扩 
        
       
         展 
        
       
         ， 
        
       
         引 
        
       
         入 
        
       
         了 
        
       
         新 
        
       
         符 
        
       
         号 
        
       
         ‘ 
        
       
      
        符号并不属于字符表中的一部分，我们将字符表进行了扩展，引入了新符号` 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">扩</span><span class="mord cjk_fallback">展</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">号</span><span class="mord">‘</span></span></span></span></span>`</p> 
<p>$ 标记了栈底位置，也就是一个输入结束的标记</p> 
<p>完成匹配后，我们就是处于输入的末尾</p> 
<p>上面整个处于一个循环之中，知道我们无法重复这些代码，或者直到整个栈为空</p> 
<p>这里有两类</p> 
<p>第一类是假设栈顶元素处理终结符t，如果栈顶终结符匹配了输入中的下一个元素，我们就移动到下一个元素，否则调用error，没有回滚</p> 
<p>第二类是假设栈顶元素非终结符X，根据解析表来查找非终结符x和下一个输入字符所对应的产生式右手边的内容</p> 
<p>我们将解析树中x的子节点压入栈内，</p> 
<p><img src="https://images2.imgbox.com/2a/0f/iV7ex4kL_o.png" alt="image-20220214183824535"></p> 
<p>这个是我们的栈，和输入的字符串，产生式的相关匹配</p> 
<p>从E开始，同时构建解析树</p> 
<p>接着，E被弹出，TX被压入</p> 
<h3><a id="0702_First_Sets_14m02sfirst_4047"></a>07-02: First Sets (14m02s)【first集】</h3> 
<p>如何构建LL(1)解析表</p> 
<p><img src="https://images2.imgbox.com/5c/13/nb8r0PQ4_o.png" alt="image-20220215140306004"></p> 
<p>我们需要知道一个给定的非终结符A，给定的输入t，T[A,t] =a</p> 
<p>第一种情况，如果α可以推导出t在第一个位置，α经过多次推导</p> 
<p>推导出t∈first（α）</p> 
<p>tips：</p> 
<pre><code>产生式S-&gt;ABCD,A-&gt;a|epsilon ，B-&gt;B|epsilon,C-&gt;c,D-&gt;d
a，b可能为空，就是c了，不会有d，
如果在A,B,C 中，A生成了一个t，那么就没有后续bc产生式了，

</code></pre> 
<p>另一种情况，A最为最左非终结符，t作为下一个输入，我们会使用α替换A，即A-&gt;α，</p> 
<p>我们要考虑的就是α无论经过多少次推导都无法得出t，t不是first(α)中的元素</p> 
<p>我们依旧能够解析，</p> 
<p>我们提供一个产生式<code>α-&gt;*epsilon</code></p> 
<p>α通过0次或者多次推导，变为epsilon</p> 
<p>并且在语法中，t能够紧挨着A，</p> 
<p>这里t是属于Follow(A)的</p> 
<p>A不会生成t，t是在A之后推导出来的</p> 
<p>这个A之后的t和A生成的元素没有任何关系</p> 
<h4><a id="first_4086"></a>first集合的计算</h4> 
<p><img src="https://images2.imgbox.com/44/7e/zefJHMlN_o.png" alt="image-20220215141819432"></p> 
<p>对于任意字符串，如果经过多次推导后，X能够在右手边第一个位置推导出t的话，那么我们就说t是一个终结符，并且是First（x）中的元素</p> 
<p>如果X通过0或多次推导后能得到epsilon，我们也会说epsilon是first（x）中的元素</p> 
<p>算法简述 （algorithm sketch）</p> 
<p>对于所有的终结符，他们的first集由该终结符的元素组成</p> 
<p><img src="https://images2.imgbox.com/fb/3e/nTIfZMK2_o.png" alt="image-20220215142225431"></p> 
<p>非终结符</p> 
<p><img src="https://images2.imgbox.com/5e/03/JyuAL0ke_o.png" alt="image-20220215142353454"></p> 
<p>这里匹配每一个非终结符 递归的算出每个符</p> 
<p>第一个，X-》epsilon 所以epsion是first（x）中的元素</p> 
<p>第二个，x-》a1…an 右边都是非终结符的情况下，也就是a1…an经过0-n次变化都能够变成epsilon，这种情况下，epsilon才能够属于first（A）</p> 
<p><img src="https://images2.imgbox.com/00/ef/mPTODMAi_o.png" alt="image-20220215142659739"></p> 
<p>另一种情况</p> 
<p>first（α） 属于first（x） 的子集</p> 
<p>当a1.。。an都能转换为epsilon的时候</p> 
<p>x通过0-n变为了α，</p> 
<p>第一个计算终结符的first集，第二、三个计算非终结符的first集，</p> 
<h4><a id="example_4126"></a>example</h4> 
<p><img src="https://images2.imgbox.com/af/16/rko0oSnD_o.png" alt="image-20220215143550280"></p> 
<p>我们先计算终结符的first集</p> 
<pre><code>First(+)={+}
First(*) = {*}

</code></pre> 
<p><img src="https://images2.imgbox.com/99/17/7qoaExAu_o.png" alt="image-20220215143639541"></p> 
<p>非终结符的first集</p> 
<p>我们知道，first（T）中的元素同样是first（E）中的元素、</p> 
<p>first（T） ∈first（E）</p> 
<p>first（T） 是first（E）的子集</p> 
<p>首先得推出firstT，T的产生式中，右侧第一个位置生成了终结符<code>(</code>或者<code>int</code></p> 
<pre><code>First(T) = {(,int}
那么firstE是什么，如果T能够变成epsilon的话，firstx能够成为firstE的子集，我们得出了，firstT的集合，epsilon并不在其中，也就是说firstT至少会生成一个终结符，X永远不会是firstE，因此，firstT和firstE相等

First(E) = first(T)
First(X) = {+，epsilon}//右边表达式的第一个就是终结符，所以填进去
First(Y) = {*,epsilon}//同X

</code></pre> 
<h3><a id="0703_Follow_Sets_17m05s_4164"></a>07-03: Follow Sets (17m05s)</h3> 
<p><img src="https://images2.imgbox.com/a4/93/G1qLhpwO_o.png" alt="image-20220216143810544"></p> 
<p>这里给了定义，Follow集，经过一些推导， 该终端t可以紧接着在符号X之后出现，所有的这些t组成了follow集</p> 
<p>如果我们由X-&gt;AB，那么first(B) 属于follow(A)</p> 
<p>X-&gt;AB-&gt;Atβ</p> 
<p>这个t是first(B)的元素，同时也属于Follow（A）</p> 
<p>当有两个相邻符号的时候，第二个符号的first集中的元素是第一个符号的follow集合中的元素</p> 
<p>产生式末尾字符</p> 
<p>如果B能够编成epsilon 或者能偶小时，A就会作为产生式的末尾符号</p> 
<p>Follow(X)成为了Follow(A)的子集</p> 
<p><code>S-&gt;xt-&gt;ABt -&gt;At</code></p> 
<p>那么$符号在哪个集合中呢，是在开始符号Follow集合中的元素</p> 
<p><img src="https://images2.imgbox.com/95/a1/RaF8qBdu_o.png" alt="image-20220216170534110"></p> 
<h4><a id="algorithm_sketch__4194"></a>algorithm sketch 算法概述</h4> 
<p><img src="https://images2.imgbox.com/d9/b2/DXDBS71I_o.png" alt="image-20220216143855857"></p> 
<p>前两个就是固定的，没什么考虑的，</p> 
<p>第三个</p> 
<p>如果产生式的后缀β可以被消除，也就是epsilon，左边的A 元素的follow集就是followX的子集</p> 
<h4><a id="example_4206"></a>example</h4> 
<p><img src="https://images2.imgbox.com/c3/4c/7oJebyDv_o.png" alt="image-20220216144001167"></p> 
<p>我们计算这些语法的Follow集</p> 
<p>根据定义，$肯定是FollowE的元素</p> 
<p>我们找E在哪儿使用过</p> 
<p><code>T-&gt;（E）</code></p> 
<p>E在终结符后，所以<code>)</code>是followE的元素</p> 
<p>FollowX属于是FollowE的子集</p> 
<p>如果我们想要算FollowE 就需要先算FollowX</p> 
<p><code>E-&gt;Tx</code></p> 
<p>这个里面，左侧符号，FollowE 是FollowX的子集</p> 
<p>所以FollowX = FollowE</p> 
<p>我们接着计算FollowT</p> 
<p>只有两个地方使用了T</p> 
<p><img src="https://images2.imgbox.com/47/f0/0bZkQOlG_o.png" alt="image-20220216174749580"></p> 
<p><img src="https://images2.imgbox.com/b1/ca/LcTjfCyT_o.png" alt="image-20220216174755016"></p> 
<p><code>FollowT = {+，$,),}</code></p> 
<p><code>E-&gt;TX-&gt;T+E</code>因为我们不考虑epsilon，所以不做补充，</p> 
<p>在<code>E-&gt;TX</code>中，因为X可以被消除，FollowE中的任何元素同样是FollowT</p> 
<p><img src="https://images2.imgbox.com/a5/55/OG60bDCS_o.png" alt="image-20220216175129085"></p> 
<p>这个里面，T在最末尾，因此FollowY中任何元素也都是FollowT中的元素</p> 
<p>FollowY也是FollowT的子集</p> 
<p>为了计算FollowT 因此我们需要知道FollowY</p> 
<p><img src="https://images2.imgbox.com/12/19/Lma7Jflz_o.png" alt="image-20220216175411716"></p> 
<p>Y出现在右侧末尾，因此</p> 
<p>FollowT 是FollowY的子集</p> 
<p>因此FollowY = FollowT</p> 
<p><code>Follow Y = {+,$,)}</code></p> 
<p>上面计算完了所有的非终结符Follow集</p> 
<p>接下来我们计算终结符Follow集</p> 
<pre><code>Follow('(') =  就是First(E) 中所有的元素
FirstE 和FirstT相同，First有一个( 和int

</code></pre> 
<p><img src="https://images2.imgbox.com/7f/3a/h0JGBymv_o.png" alt="image-20220216175732753"></p> 
<p>在这里面</p> 
<p><img src="https://images2.imgbox.com/15/83/azSZxWrz_o.png" alt="image-20220216175815765"></p> 
<p>Follow(T)中的任何元素都是Follow(’)’) 的元素</p> 
<p><img src="https://images2.imgbox.com/58/bb/6lntUP4u_o.png" alt="image-20220216175906885"></p> 
<p>Follow(’+’) 用在这里，因此FirstE 中的任何元素都是Follow+中的元素</p> 
<p>FirstT中的元素都是 Follow(*) 中的元素</p> 
<p>Follow(int) = {}</p> 
<p>Follow(int) 会包含FirstT中的所有元素，<code>*，+，$,)</code></p> 
<h3><a id="0704_LL1_Parsing_Tables_14m41sLL1_4292"></a>07-04: LL1 Parsing Tables (14m41s)【LL1解析表】</h3> 
<p><img src="https://images2.imgbox.com/f1/71/56tdLY0Q_o.png" alt="image-20220216214807425"></p> 
<p>语法G中的一个产生式<code>A-&gt;α</code></p> 
<p>当我们遇到，A是最左非终结符，t是输入中的下一个token的话，这个表T[A,t] = α</p> 
<p>第二个，t是follow(A)中的元素，并且产生式右手边的内容是epsilon，A是最左非终结符，t是输入中的下一个token的话，这个表T[A,t] = α</p> 
<p>最后一种情况，为了消除A，epsion是First(α) 的元素，并且在一个推导中$ 能跟在A的后面</p> 
<p>上面就是构建一张解析表的流程/规则</p> 
<h4><a id="example_4306"></a>example</h4> 
<p><img src="https://images2.imgbox.com/44/66/rYz7VXnk_o.png" alt="image-20220216222635896"></p> 
<p>我们来构建解析表</p> 
<p><img src="https://images2.imgbox.com/8f/5d/0DDt1pRn_o.png" alt="image-20220216222711833"></p> 
<p>列名，肯定就是终结符，非终结符用来当行名（ETXY）</p> 
<p>我们只需要考虑他在产生式右侧的第一个位置能生成什么即可</p> 
<p>当然这个就是T的first集合中的元素，也就是<code>(,int</code></p> 
<p><img src="https://images2.imgbox.com/68/06/VLZqOtY4_o.png" alt="image-20220216223038125"></p> 
<p>当我们使用T-&gt;(E) 的时候</p> 
<p>T是最左非终结符，）是输入中的下一个符号</p> 
<p>我们使用(E) 来替换T，</p> 
<p>另一个产生式，T是最左非终结符，int为输入，</p> 
<p><img src="https://images2.imgbox.com/e6/61/p1Xjh0xb_o.png" alt="image-20220216223247262"></p> 
<p>当我们选用X-&gt;+E</p> 
<p>左边的非终结符是X，右侧第一个位置是+</p> 
<p><img src="https://images2.imgbox.com/e9/66/7SY87D47_o.png" alt="image-20220216223343518"></p> 
<p>Y也一样，当Y是一个非终结符的时候，我们尝试把他展开，如果输入* 我们使用产生式Y-&gt;*T</p> 
<p><img src="https://images2.imgbox.com/ee/64/vixfMSah_o.png" alt="image-20220216223424558"></p> 
<p>我们考虑epsilon ，</p> 
<p>我们为了知道什么时候使用产生式X-&gt;epsion 就需要知道Follow（X）中有什么，上节课写了</p> 
<pre><code>Follow(x)
需要先找那里用到了X
E-&gt;TX
在右手边，他就是FollowE的元素，
FollowE有什么？
E是开始符号，$,")" 都是followE的元素


</code></pre> 
<p><img src="https://images2.imgbox.com/cd/a8/8Yk8jfgx_o.png" alt="image-20220216223731518"></p> 
<pre><code>接着Y同理，
FollowT中的任何元素都是fOLLOWy的元素
followY中包含firstT的元素，因为X能跟在T后面出现


</code></pre> 
<p><img src="https://images2.imgbox.com/4e/7a/Ni5qaOfV_o.png" alt="image-20220216223916723"></p> 
<p><img src="https://images2.imgbox.com/db/6e/8YYBTqmm_o.png" alt="image-20220216223951527"></p> 
<p>当输入末尾的时候，我们把X替换为epsilon</p> 
<p>如果栈内有一个”)“ 我们就把X替换为epsilon 因为x自身无法生成一个),我们消除了X，栈内就能生成其他符号的语言</p> 
<p>这就是followX</p> 
<p><img src="https://images2.imgbox.com/58/98/7d5ByCUY_o.png" alt="image-20220216224156984"></p> 
<p>Follow 同理</p> 
<p><img src="https://images2.imgbox.com/c7/0f/kdbwlzy4_o.png" alt="image-20220216224216191"></p> 
<p>空白单元格对应什么呢？</p> 
<p>当然就是解析错误，</p> 
<p>我们来思考一下我们为一个非LL(1) 语法构建LL（1） 解析表时会发生什么</p> 
<p>S-&gt;Sa|b</p> 
<p>为了构架这个语法的相关解析表，我们需要知道first集，和follow集</p> 
<p>First（S）产生式的右边第一个能产生b,并且没有任何可能生成epsilon</p> 
<p>First(S) = {b}</p> 
<p>Follow（S）={$,a}</p> 
<p>因为S是开始夫，所以$是followS的元素,因为第一个产生式中，a跟在S后面，所以a是followS的元素</p> 
<p>构建解析表</p> 
<p>比较小。</p> 
<p><img src="https://images2.imgbox.com/4e/ef/eLiwggUk_o.png" alt="image-20220216225238425"></p> 
<p>如果我们在输入中看到b的话，我们就会使用S-&gt;b</p> 
<p><img src="https://images2.imgbox.com/c8/25/gqEUmgLB_o.png" alt="image-20220216225334341"></p> 
<p>同时有多种选择，Sa</p> 
<p><img src="https://images2.imgbox.com/cf/58/xKsxGNOk_o.png" alt="image-20220216225410841"></p> 
<p>这就是一个多重定义的单元格</p> 
<p>如果我们想要展开的最左非终结符，也就是栈顶元素为S，b是我们下一个输入符号的话，</p> 
<p>这张解析表并不会明确的告诉你走哪里，这就是不是一个ll（1）</p> 
<p>如果构建解析表有多重操作，就不是一个LL（1）</p> 
<p><img src="https://images2.imgbox.com/f6/8e/4Wjs06KL_o.png" alt="image-20220216225615555"></p> 
<p>LL（1） 的一个定义，检查这个语法是否是ll1的唯一方法就是去构建ll1 解析表，然后检查解析表中所有的单元格内选择是否只有一种</p> 
<p>当然有很多语法不是ll1语法</p> 
<p>比如，任何无法被提取左公因式的语法都不是ll1语法</p> 
<p>任何左递归语法也不是ll1语法</p> 
<p>任何语义混淆的语法也不是</p> 
<p>如果向前看多个token也不是ll1</p> 
<p><img src="https://images2.imgbox.com/92/52/10alLAGn_o.png" alt="image-20220216225837834"></p> 
<p>这些是可以快速判断的，</p> 
<h3><a id="0705_BottomUp_Parsing_Part_1_7m06s_4453"></a>07-05: Bottom-Up Parsing Part 1 (7m06s)【自下而上的解析】</h3> 
<p><img src="https://images2.imgbox.com/ee/11/C3Zb7lc7_o.png" alt="image-20220217135219087"></p> 
<p>自下而上的解析不仅更通用，而且同样高效，而且是大部分解析生成工具所使用的一种首选方法，</p> 
<p><img src="https://images2.imgbox.com/a3/12/Eob2olE3_o.png" alt="image-20220217135557394"></p> 
<p>自下而上不需要提取左公因子，因此能够回归自然的语法</p> 
<p>我们仍然需要对+号和*号的优先权进行编码</p> 
<h4><a id="example_4467"></a>example</h4> 
<p>string <code>int*int+int</code></p> 
<p>有关自下而上的解析要知道的第一件事就是他会进行归约，通过反转产生式，逆向替换，将字符串归约为起始符号</p> 
<p>（tips：从具体元素开始逐层替换为上一级可处理的产生式，最后聚合为一个产生式，即为归约）</p> 
<p>inverting ：倒置</p> 
<p><img src="https://images2.imgbox.com/1e/1a/3qV0tURD_o.png" alt="image-20220217135938991"></p> 
<p>左边是字符串状态序列，右边是使用的产生式</p> 
<p>我们进行逆向使用，我们在这里将int替换为了T</p> 
<p>然后下一步，我们对子字符串int*t 替换为了T，</p> 
<p>依此类推</p> 
<p><img src="https://images2.imgbox.com/fb/21/ei31rIXl_o.png" alt="image-20220217140404742"></p> 
<p>最后我们以开始符号E结束</p> 
<p>我们从底部向上读，其实就是一个产生式，逆向推导就是Reduction（归约）</p> 
<p><img src="https://images2.imgbox.com/97/5f/MnX4Mhkq_o.png" alt="image-20220217140510295"></p> 
<p>事实上，编译器解析过程也是向下的，</p> 
<p><img src="https://images2.imgbox.com/22/b7/GVauLeEL_o.png" alt="image-20220217140602822"></p> 
<p>如果我们从开始符号，往上看，他就是一个最右展开，</p> 
<p>一个自下而上型解析器，将反向追踪一个最右推导</p> 
<p><img src="https://images2.imgbox.com/ad/cc/oLotJuSR_o.png" alt="image-20220217140723772"></p> 
<p>自下而上的解析器跟踪的是一个最右推导</p> 
<p>他通过使用归约来代替产生式的推导，然后以反方向的顺序进行</p> 
<p><img src="https://images2.imgbox.com/29/a1/6qDyrmNi_o.png" alt="image-20220217140829428"></p> 
<p>左侧是归约过程，右侧是根据归约构建的解析树</p> 
<p><img src="https://images2.imgbox.com/c3/38/vqtkiGpr_o.png" alt="image-20220217140902806"></p> 
<p>我们从输入开始，</p> 
<p><img src="https://images2.imgbox.com/65/51/0tl1baNL_o.png" alt="image-20220217140918993"></p> 
<p>通过展开当前叶子节点的非终结符来主键生成解析树</p> 
<p>自下而上的解析树，从底部开始构建</p> 
<p><img src="https://images2.imgbox.com/90/dd/SI7a2Xgv_o.png" alt="image-20220217153337706"></p> 
<p><img src="https://images2.imgbox.com/22/51/dYQEYBMl_o.png" alt="image-20220217153345622"></p> 
<p>总结，一个自下而上的解析器会以逆序追踪一个最右推导</p> 
<p>通过将小型解析树结合在一起来构建更大的解析树</p> 
<h3><a id="0706_ShiftReduce_Parsing_Part_1_5m40s_4545"></a>07-06: Shift-Reduce Parsing Part 1 (5m40s)【移位规约解析】</h3> 
<p>通过所有自下而上解析器所使用的主要策略（也就是所谓的移位规约解析） 来继续对自下而上解析进行讨论</p> 
<p><img src="https://images2.imgbox.com/69/b6/FAcWsaum_o.png" alt="image-20220217153826600"></p> 
<p>上节课的重点，</p> 
<p><img src="https://images2.imgbox.com/42/d0/HEnCSr9B_o.png" alt="image-20220217153845208"></p> 
<p>假设我们有字符串<code>αβw</code> ,我们来思考下以为归约解析的状态</p> 
<p>假设我们下一步归约是使用X对β进行替换</p> 
<p>规定<code>w</code>是一个终结符</p> 
<p>如果从最右推导来看，X必须是最右非终结符，也就是X的右侧不存在任何非终结符，<code>w</code> 所代表的也就必须是终结符token</p> 
<p><img src="https://images2.imgbox.com/34/20/0FzElfim_o.png" alt="image-20220217154318185"></p> 
<p>这些最右非终结符右边的终结符再自底向上解析器视线中，恰好是未经检查的输入，</p> 
<p>当我们读到X，<code>w</code> 是我们还没有读取到的输入，也就是未经检查的输入</p> 
<p>我们通过<code>|</code> 来在已读部分和未读部分画一根竖线</p> 
<p>竖线左侧是终结/非终结 都可以，但是在右侧，我们并不知道有什么，即使我们知道是终结符</p> 
<p><img src="https://images2.imgbox.com/0e/f1/4SIvuV5F_o.png" alt="image-20220217154330223"></p> 
<p>为了实现自下而上解析，我们需要两种操作，移位操作和归约操作</p> 
<p><img src="https://images2.imgbox.com/c8/cd/URlS2o38_o.png" alt="image-20220217154341037"></p> 
<p>一次移位操作就代表了从输入中读取一个token</p> 
<p>我们可以将他解释为将竖线向右移动一个token的位置</p> 
<p>yz是解析器还没有读取到的部分</p> 
<p><img src="https://images2.imgbox.com/e2/13/J2swHV0y_o.png" alt="image-20220217154355683"></p> 
<p>归约操作是对竖线左侧字符串的右端末尾逆向使用产生式</p> 
<p>如果有这样一个产生式A-&gt;xy,同时竖线的左边有x和y</p> 
<p>我们使用产生式左侧来替换产生式右侧的内容</p> 
<p>这就是归约操作</p> 
<p><img src="https://images2.imgbox.com/48/b9/dJcrekk8_o.png" alt="image-20220217154405283"></p> 
<p>这就是上节课的例子，我们来展示归约操作和移位操作</p> 
<p><img src="https://images2.imgbox.com/2a/2d/faRY3rjM_o.png" alt="image-20220217154438460"></p> 
<p><img src="https://images2.imgbox.com/67/be/Rh6gHiev_o.png" alt="image-20220217160700489"></p> 
<p>第一次操作就是要进行一个移位</p> 
<p><img src="https://images2.imgbox.com/5d/80/4kIqrIDD_o.png" alt="image-20220217160717326"></p> 
<p><img src="https://images2.imgbox.com/f6/52/qkHoP9Dj_o.png" alt="image-20220217160739474"></p> 
<p>有一次移位，又一次移位</p> 
<p><img src="https://images2.imgbox.com/de/5f/ilMwUENn_o.png" alt="image-20220217160753826"></p> 
<p>只允许我们去对箭头左侧的内容进行归约</p> 
<p>执行一个归约操作前我们需要读足够多的输入</p> 
<p><img src="https://images2.imgbox.com/36/7e/aHKJbyN8_o.png" alt="image-20220217160845269"></p> 
<p>再来两次移位</p> 
<p>到末尾了，不移动了，</p> 
<p>就开始归约</p> 
<p><img src="https://images2.imgbox.com/8e/56/9V1Qkx4F_o.png" alt="image-20220217160948693"></p> 
<p><img src="https://images2.imgbox.com/0f/d5/r2ImI8kg_o.png" alt="image-20220217161001599"></p> 
<p><img src="https://images2.imgbox.com/f7/e9/VGRxCbfK_o.png" alt="image-20220217154458423"></p> 
<p>事实证明，竖线左边的字符串能够由一个栈进行实现，</p> 
<p>因为我们支队竖线左侧的字符串进行归约，</p> 
<p>移位就是将token压栈</p> 
<p>一个归约操作，将一些符号从栈内弹出</p> 
<p><img src="https://images2.imgbox.com/99/a8/Uthnz1fF_o.png" alt="image-20220217154507747"></p> 
<p>在一个给定状态下，经过多次移位或者归约，我们可能会得到一个有效的解析</p> 
<p>特别是，如果移位或者归约操作是合法的话，也就是，既可以移位，又可以归约，就会有shift-reduce冲突，这个一般可以消除，通过优先级声明</p> 
<p>解析器既可以读入token，压入栈内，也可以执行归约操作</p> 
<p>如果归约操作由两种不同的产生式都可以做到并是合法的，那么这里就会由一种成为reduce-reduce的冲突</p> 
<p>这表明语法出现了问题，比较严重，</p> 
<h3><a id="0801_Handles_Part_1_4m35s_4669"></a>08-01: Handles Part 1 (4m35s)【句柄】</h3> 
<p><img src="https://images2.imgbox.com/08/16/1PeyhzYN_o.png" alt="image-20220217220541540"></p> 
<p>回顾：自下而上有两种操作，移位操作，读取完一个token，并将竖线向右移动一个token</p> 
<p>归约操作用产生式右手边的内容来替换产生式左手边的内容</p> 
<p><img src="https://images2.imgbox.com/76/60/9tRl98J1_o.png" alt="image-20220217220549340"></p> 
<p>竖线左边的字符串能够用一个栈来实现，栈顶元素使用竖线进行标记</p> 
<p>移位操作会将终结符压入栈内，归约操作则会让栈弹出0个或多个符号</p> 
<p>会将非终结符压入栈内，也就是该产生式的左手边的内容，</p> 
<p><img src="https://images2.imgbox.com/3a/9d/O2t8G4Qr_o.png" alt="image-20220217221101445"></p> 
<p>有个关键的问题，我们如何判断什么时候移位，什么时候归约呢?</p> 
<p>当我们读取到int的时候</p> 
<p>我们可以使用<code>T-&gt;int</code> 变成<code>T|*int+int</code></p> 
<p>但是没有T* 相关的任何产生式</p> 
<p>因此，如果我们归约后再去移位，就很难了</p> 
<p>移位的结果可能是<code>T*int，T*int+，T*int+E</code></p> 
<p>但是永远无法返回E，没法处理T*</p> 
<p><img src="https://images2.imgbox.com/8d/70/YLccQOH6_o.png" alt="image-20220217220642521"></p> 
<p>我们不能一味地去归约，</p> 
<p>即使栈顶元素是产生式右手边的内容，他也有可能是一个错误的归约操作</p> 
<p>我们来看这个最右推导</p> 
<p>S经过若干步变为αXw，再变成αβw</p> 
<p>反过来就是解析器解析的方向，也就是归约的方向</p> 
<p>总之，如果这是一个最右推导，αβ就是αβw的句柄</p> 
<p>也就是说β归约为X是正确的</p> 
<p>能够使用X替换β</p> 
<p><img src="https://images2.imgbox.com/f7/95/hvDZC3t2_o.png" alt="image-20220217220652176"></p> 
<p>句柄可以将进行归约操作的地方直观的展示出来</p> 
<p>句柄就是一个古i粤电，可以允许解析器通过进一步的归约操作回到开始符号的位置，</p> 
<p>tips：句柄包含了一个可规约的操作路径，</p> 
<p>我们只想在句柄处进行归约，不在句柄处归约，解析器可能会卡住</p> 
<p>我们怎么去找出句柄呢？（见下节课）</p> 
<p><img src="https://images2.imgbox.com/1c/12/t2qVXin2_o.png" alt="image-20220217220701548"></p> 
<p>自底向上解析的第二个重要事实，在归约和移位操作中，句柄只会出现在栈顶，所有操作都在左侧，用栈足够</p> 
<p><img src="https://images2.imgbox.com/e0/9c/V5arcA9b_o.png" alt="image-20220217220710928"></p> 
<p>这里有一个句柄只会出现在栈顶的非正式证明，通过一系列归约操作做到的</p> 
<p>初始为true，栈空，</p> 
<p>当我们结束归约操作后，最右非终结符就会成为栈顶元素</p> 
<p>也就是一个最右非终结符X，还有一个竖线，见图</p> 
<p>由于是最右推导，也就是下一个句柄必须在最右非终结符右边的某个位置</p> 
<p>下一个句柄<strong>必须</strong>包含<code>X|</code> 这些部分</p> 
<p>因为我们无法对最有非终结符的左边进行任何归约操作</p> 
<p>一旦我们的栈顶元素是这个非终结符的话，下一个句柄必然在他的右边某个位置</p> 
<p><img src="https://images2.imgbox.com/e8/03/HXdhaGc2_o.png" alt="image-20220217220719570"></p> 
<p>句柄永远不会出现在最有非终结符的左边</p> 
<p>归约和移位我们永远不需要向左移动</p> 
<h3><a id="0802_Recognizing_Handles_13m12s_4765"></a>08-02: Recognizing Handles (13m12s)【句柄识别】</h3> 
<p><img src="https://images2.imgbox.com/fb/64/Sl6qIyvm_o.png" alt="image-20220218185119362"></p> 
<p>坏消息，：解析的时候没有一种合适的算法，能够快速找出句柄</p> 
<p>好消息：有heuristics（启发器） 可以用来帮助猜测句柄，对于相当大的一类上下文无关文法来说，这些启发器始终能够正确的识别句柄</p> 
<p><img src="https://images2.imgbox.com/ca/b9/ebs7Nv7d_o.png" alt="image-20220218185919617"></p> 
<p>我们可以使用文氏图来解释这个情况</p> 
<p>所有的上下文无关法作为一个集合，明确的上下文无关语法是他的一个子集</p> 
<p>LR(k)语法更小</p> 
<p>L代表从左到右扫描，R代表了最右推导，k代表了需要向前看k个数量的token</p> 
<p>LR(k) 语法是我们所知道的最普遍的确定性语法之一，实战不用</p> 
<p>大部分自下而上型工具实际会用到一种语法，被称为LALR(k)语法</p> 
<p>他是LR(k)的子集，然后我们会主要讨论的是它们的一个简化版语法</p> 
<p>SLR(k)上下文无关法</p> 
<p><img src="https://images2.imgbox.com/56/9b/lNr8MaoJ_o.png" alt="image-20220218213124006"></p> 
<p>解析器会看到这个栈，在每一步中，解析器都会知道有哪些元素在栈内</p> 
<p>有一个定义：</p> 
<p>假设α是一个可行前缀，如果此处有一个w，并且α|w是移位归约解析的一个有效配置的话，这里的α它处于栈顶，w是input输入的剩余部分</p> 
<p>意味着解析器知道α的这部分，但是对w的那部分并不了解</p> 
<p>解析器虽然能向前看一些内容，但是也就是一个token，</p> 
<p><img src="https://images2.imgbox.com/fe/da/mCYdh6Ch_o.png" alt="image-20220218213440215"></p> 
<p>可行前缀是一个字符串，他不会延伸到句柄的右端</p> 
<p>我们称他为可行前缀的理由是因为他是句柄的前缀，因此只要解析器在栈上有可行的前缀的话，就不会检测到解析错误</p> 
<p>自下而上解析的第三个也是最后一个重要的事实</p> 
<p><img src="https://images2.imgbox.com/d0/c9/UvfvaPmz_o.png" alt="image-20220218213719527"></p> 
<p>对于任何语法来说，可行前缀集就是一个正则语言</p> 
<p>这个就是自下而上解析的基于这个事实开发的，可行前缀集可以被有限自动机所识别</p> 
<h4><a id="example_4817"></a>example</h4> 
<p>演示可接受可行性前缀的自动机如何进行计算</p> 
<p><img src="https://images2.imgbox.com/1a/e4/rKGTEmOo_o.png" alt="image-20220218213925159"></p> 
<p>辅助的额外定义</p> 
<p>定义item</p> 
<p>item是指一个产生式右手边某处存在的一个<code>.</code></p> 
<p><img src="https://images2.imgbox.com/fb/48/W2DdCnz5_o.png" alt="image-20220218214019488"></p> 
<p>例如，我们有一个item这里的<code>.</code> 始终在产生式右手边的左端处，<code>(E)</code>的最左端</p> 
<p>我们也有一个<code>.</code> 始终在产生式右手边的右端处<code>(E)</code> 的最右端</p> 
<p>我们还会有<code>.</code> 在括号内的情况</p> 
<p>在这个例子中，对这个产生式，存在了四种item</p> 
<p><img src="https://images2.imgbox.com/e2/cc/htGaHBMq_o.png" alt="image-20220218215611767"></p> 
<p>有一种特殊情况，对于一个epsilon产生式，在产生式的右手边没有任何符号</p> 
<p>我们就会说这里有个item，即<code>X-&gt;.</code></p> 
<p>如果你看过帮助页的话，这些item被称为LR(0) items</p> 
<p><img src="https://images2.imgbox.com/7d/d4/8YTVknY1_o.png" alt="image-20220218215654270"></p> 
<p>我们准备讨论如何识别可行前缀</p> 
<p>在栈内，我们只有产生式右手边的部分内容</p> 
<p>栈内的内容并不是随机的。他有一种特殊的结构，这些片段始终是产生式右手边的内容的前缀</p> 
<p>在一个成功的解析中，栈上的元素始终必须是产生式右手边的前缀</p> 
<p><img src="https://images2.imgbox.com/39/82/WYfLCziK_o.png" alt="image-20220218215635170"></p> 
<p>在栈内，我们有<code>(E</code></p> 
<p>在input 我们有<code>)</code></p> 
<p>（E就是 T-&gt;(E) 的前缀</p> 
<p>当我们将剩下的)也压入栈内后，我们就会得到一个产生式右手边的完整内容，这样我们就准备好对他进行归约操作了</p> 
<p>这就是item的由来，</p> 
<p>这个item就是<code>T-&gt;(E.)</code> 用来描述这种情况</p> 
<p>他表示了，目前为止，我们已经看到了这个产生式的<code>(E</code> 这部分</p> 
<p>并且我们希望在之后看到<code>)</code></p> 
<p><code>.</code> 的左侧就是栈内的，右侧就是在我们能够进行归约操作前我们想要读取的内容，解析器并不知道输入是什么</p> 
<p><img src="https://images2.imgbox.com/07/cd/6ZkM5u1X_o.png" alt="image-20220218215717867"></p> 
<p>我们来讨论栈的结构，这是一个存储了产生式右手边前缀的栈</p> 
<p>有一些列前缀堆叠在栈上，如果取处一个前缀，Prefixi 这必须是产生式右手边的前缀</p> 
<p>也就是，prefixi最终会被归约为产生式左边的元素，这个例子中最终归约为Xi</p> 
<p>然后Xi必须是栈内前缀所缺失的后缀部分</p> 
<p>递归的，前缀k上的所有前缀最终都必须归约聚合到前缀k右侧的缺失部分前面，即右手边的α_k</p> 
<p>我们始终都在栈的最上层的前缀进行处理，当前缀递归后，就会对栈中更下面的前缀进行处理</p> 
<p><img src="https://images2.imgbox.com/3d/e5/4z3ZvA11_o.png" alt="image-20220218215741270"></p> 
<p>输入的字符串是<code>(int*int)</code></p> 
<p>栈内我们有<code>(int*</code> input还剩下int)</p> 
<p>我们从下面开始处理的 栈顶是T-》int*T产生式的前缀</p> 
<p><img src="https://images2.imgbox.com/31/73/SROdYyi5_o.png" alt="image-20220218225006539"></p> 
<p>读到int*我们想要读T</p> 
<p><img src="https://images2.imgbox.com/39/49/Jt29RYW3_o.png" alt="image-20220218225138261"></p> 
<p>int下面还有一个前缀，int和（之间 有一个epsilon</p> 
<p>也就是说栈内位空，但是，int*归约为T，T归约为E，</p> 
<p><img src="https://images2.imgbox.com/be/fb/GZ35fIq5_o.png" alt="image-20220218215803988"></p> 
<p>现在我们能记录栈内所有的item</p> 
<p>在上面的处理中，我们只看到了前缀，就让他处理，变成产生式右侧的一部分</p> 
<p>每一次向前移动，都要把做左手边的内容归约到不能不能再归约位置，也就是说，每移动一次，就要再次进行整体的归约操作，即每次栈顶放置的就是归约后的非终结符</p> 
<p><img src="https://images2.imgbox.com/9d/39/P0QjQt3l_o.png" alt="image-20220218225605019"></p> 
<p><img src="https://images2.imgbox.com/1d/90/5pQZhePq_o.png" alt="image-20220218221032821"></p> 
<p>问题再于是被一系列产生式右手边的片段</p> 
<p>这些产生式右手边的片段内容最终会归约为所缺后缀的前置部分</p> 
<h3><a id="0803_Recognizing_Viable_Prefixes_14m57s_4967"></a>08-03: Recognizing Viable Prefixes (14m57s)【识别可行前缀】</h3> 
<p>研究一波算法</p> 
<p><img src="https://images2.imgbox.com/21/92/GJIQwbZi_o.png" alt="image-20220221185917562"></p> 
<p>第一个点，给G语法添加一个伪产生式S’-&gt;S</p> 
<p>只是为了让我们试着计算出G的可行性前缀而进行的设置</p> 
<p>我们声明，对于给定语法的可行前缀集，它是正则的，</p> 
<p>也就是需要构建一个非确定性有限自动机（NFA） 来识别可行前缀</p> 
<p>NFA读取栈，从底到上，让我们能够知道解析器有没有真的遇见解析错误，yes，没问题，栈中内容能够完全正确的解析这个输入，no遇到了错误，无效输入</p> 
<p>第三个点，需要让自动机进行怎样的状态转换</p> 
<p>假设我们处于某个状态<code>E-&gt;α.Xβ</code></p> 
<p>这个表示，我们目前在栈中读取到了α，自动机是自下而上的读取这个栈</p> 
<p>如果这个是一个有效栈的话，如果栈内的下一个元素是X</p> 
<p><img src="https://images2.imgbox.com/1d/03/3cZCKHE8_o.png" alt="image-20220221223602911"></p> 
<p>我们就可以转换到这个状态，<code>E-&gt;αX.β</code></p> 
<p>我们现在记录了我们在栈内看到X的这个事实，并且我们之后想看到产生式剩下的部分β，</p> 
<p>我们为每个item添加这个转换，如果当有任何符号出现在<code>.</code> 的右边的话，<code>.</code> 就会向右移动</p> 
<p><img src="https://images2.imgbox.com/42/ce/WgFCoWqY_o.png" alt="image-20220224185438252"></p> 
<p>X是任意语法符号，不仅仅是一个非终结符，但是这里的第四条是仅仅针对非终结符</p> 
<p>在栈内的这些东西必须是从X推导出来的，我们通过使用一系列的X的产生式能生成这些东西，因为最终会归约为X</p> 
<p>如果栈内没有X的话，我们可以进行空跳，移位到某个状态，也就是当我们试着去识别右手边内容的时候，我们可以加上某些从X推导出来的内容</p> 
<p><img src="https://images2.imgbox.com/de/31/TvwTM3yD_o.png" alt="image-20220224185735483"></p> 
<p>只有两种操作，一种是我们在栈内寻找语法符号，另一种是对产生式右手边前缀进行扩展</p> 
<p>当我们在栈内要看更多产生式右手边内容的时候，NFA会试着猜测这些前缀的末尾是什么</p> 
<p>如果当前栈上看到的是产生式α，那么接下来这里就必须是X，此处的这一点必须标记在栈中α右手侧，他指向另一个产生式</p> 
<p>我们希望可以看到那些从X指向的产生式中所推导出来的一些东西</p> 
<p><img src="https://images2.imgbox.com/df/fb/fuPsHmBB_o.png" alt="image-20220224190052244"></p> 
<p>自动机中的每个状态都是一个接收状态，</p> 
<p>这意味着如果自动机成功的处理了整个栈，那么这就是一个可行的栈</p> 
<p>要注意就是对于每个可能的符号而言，不是每个状态都会有相应的状态转换（可能该符号就找不到可以适配的产生式）</p> 
<p>这就会造成大量的栈被拒绝，自动机会被卡住</p> 
<p><img src="https://images2.imgbox.com/9a/43/0tU1IUEb_o.png" alt="image-20220224190237307"></p> 
<p>最后一个，自动机的开始状态<code>S'</code> 即item 就是<code>S'-&gt;.S</code></p> 
<p>自动机的状态就是语法的item，每一个item都可以认为是一个语法规则</p> 
<p>这就是为什么我们添加这个伪产生式的原因，这样能方便我们命名开始状态（也就是对每一个小的语法规则进行命名）</p> 
<h4><a id="example_5041"></a>example</h4> 
<p>我们通过额外的产生式<code>S'-&gt;E</code> 来对她进行扩展</p> 
<p><img src="https://images2.imgbox.com/65/a2/3uiW89pD_o.png" alt="image-20220221190012990"></p> 
<p>这个就是用来识别该语法可行前缀的自动机</p> 
<p><img src="https://images2.imgbox.com/16/66/3yV4e5XE_o.png" alt="image-20220221190035160"></p> 
<p>我们一步一步推导，</p> 
<p><img src="https://images2.imgbox.com/2f/84/3aEh0GO2_o.png" alt="image-20220224190923826"></p> 
<p>我们首先从自动机开始状态开始，我们读取这个栈，并且希望之后在站内看到一个E</p> 
<p>如果没有的话，我们也希望看到某些从E推导出来的东西出现在栈内，</p> 
<p>基于这个状态，我们能做什么转换呢？</p> 
<p>一种情况，我们在栈内看到了E</p> 
<p><img src="https://images2.imgbox.com/62/d1/k8XxXtJx_o.png" alt="image-20220224191343636"></p> 
<p><code>.</code> 移动完毕，我们已经在栈内读到了第一个item，或者说在栈内读到了E，</p> 
<p>这样我们就已经完整的读取到了这个产生式的右手边内容</p> 
<p>也就是，我们可能完成了解析，</p> 
<p>但是如果没有在栈内看到这个E的话，那么你就希望你能看到某些由E推导出来的东西在栈内出现，</p> 
<p><img src="https://images2.imgbox.com/fc/07/0FwmwILJ_o.png" alt="image-20220224191716029"></p> 
<p>空跳，一种可能是，自动机最终会用这个产生式<code>E-&gt;T</code></p> 
<p>我们还没看到任何东西，所以我们把<code>.</code> 放在左边，以此来表示我们希望看到一个T，这样就能归约成E，然后归约为S’</p> 
<p><img src="https://images2.imgbox.com/9a/2f/xsgjtAv9_o.png" alt="image-20220224191723351"></p> 
<p>另一种可能，如果在栈内没有读到T，就是我们可以使用<code>E-&gt;T+E</code></p> 
<p>因为我们还没有看到任何T，因此，<code>.</code> 仍然会在左手边</p> 
<p>我们不知道哪一个产生式的右手边内容会出现在栈内，这些产生式甚至没有提取左公因子</p> 
<p>因此我们并不知道它会去选择使用E-&gt;T,还是E-&gt;T+E</p> 
<p>但是我们只需要使用NFA的预测能力，它可以去选择使用哪个产生式，</p> 
<p>NFA接受任何可能的选择，</p> 
<p>当然我们能将他编译为一个确定性自动机，这样就不会做任何猜测了</p> 
<p>这里我们使用的是非确定性自动机，</p> 
<p><img src="https://images2.imgbox.com/71/d8/VNlr0h4X_o.png" alt="image-20220224193306838"></p> 
<p>一种可能就是，传来的是T，<code>.</code>推进 当<code>.</code> 在最右侧的时候，就可以准备归约了</p> 
<p>这就是识别句柄的方式，</p> 
<p>当我们最终到达一个状态，即<code>.</code> 在T右侧的时候，这就表示这个可能是一个句柄，看可以用来归约，</p> 
<p>如果在栈内没有看见T，我们就看到某些由T所推导出来的，</p> 
<p><img src="https://images2.imgbox.com/2b/eb/nLkOcQbc_o.png" alt="image-20220224193605015"></p> 
<p>一种是T-》int</p> 
<p>另一种是T-》(E)</p> 
<p><img src="https://images2.imgbox.com/93/28/UpOOZX4m_o.png" alt="image-20220224193628256"></p> 
<p>第三种是，T-》int*T</p> 
<p><img src="https://images2.imgbox.com/9b/8d/PX4ioS18_o.png" alt="image-20220224193646099"></p> 
<p>当然<code>.</code> 始终在左端，因为没有真的收到任何字符串对吧，</p> 
<p>我们切到这个item，E-&gt;.T+E</p> 
<p>一种可能是看到T了，读取</p> 
<p><img src="https://images2.imgbox.com/9f/0a/JtBZ5PS2_o.png" alt="image-20220224193752948"></p> 
<p>另一种是遇到某些从T推导出来的</p> 
<p><img src="https://images2.imgbox.com/cf/87/HPBZIynM_o.png" alt="image-20220224193825118"></p> 
<p>T开始的产生式，</p> 
<p>能从E-&gt;.T+E 这个item转化到这三种状态</p> 
<p>我们目光转向<code>T-&gt;.(E)</code></p> 
<p>因为括号是终结符，因此不会有推导出来的东西对吧，</p> 
<p>我们必须看到栈内有括号，</p> 
<p><img src="https://images2.imgbox.com/be/a5/4ElA3b69_o.png" alt="image-20220224194616653"></p> 
<p>因为是E，因此，可以找E或者E生成的一系列</p> 
<p><img src="https://images2.imgbox.com/59/61/fNpiEX4A_o.png" alt="image-20220224194647553"></p> 
<p>当然我们也想要看到E所推导的</p> 
<p><img src="https://images2.imgbox.com/67/62/zpuaYjog_o.png" alt="image-20220224194725164"></p> 
<p><img src="https://images2.imgbox.com/23/06/6pDOHd7V_o.png" alt="image-20220224194719497"></p> 
<p>添加了两个状态转换</p> 
<p>回顾一下，这里找下一个终结符</p> 
<p><img src="https://images2.imgbox.com/99/6d/e5WD1wMx_o.png" alt="image-20220224194820776"></p> 
<p>最终以<code>T-&gt;(E).</code> 这个item结束</p> 
<p><img src="https://images2.imgbox.com/1f/94/da8pk4UE_o.png" alt="image-20220224194930245"></p> 
<p>我们来看这条路</p> 
<p>读取到E，在把E能推导的或者E本身的连一下</p> 
<p><img src="https://images2.imgbox.com/e1/82/Dd8s5WrF_o.png" alt="image-20220224195010439"></p> 
<p>把剩下的终结符转换一下</p> 
<p><img src="https://images2.imgbox.com/f7/76/RkL8q5os_o.png" alt="image-20220224195039656"></p> 
<p><img src="https://images2.imgbox.com/8e/98/w9HgtLWG_o.png" alt="image-20220224195136604"></p> 
<p>再把T推导的东西补上</p> 
<p><img src="https://images2.imgbox.com/79/d6/0ydlH19i_o.png" alt="image-20220224195211626"></p> 
<p>这就是用来识别这个语法可行前缀的自动机的所有状态和状态转换了</p> 
<h3><a id="0804_Valid_Items_3m31sitem_5185"></a>08-04: Valid Items (3m31s)【有效item】</h3> 
<p><img src="https://images2.imgbox.com/0e/c4/McAa6A89_o.png" alt="image-20220224234223461"></p> 
<p>通过构造标准的状态构造子集，能够构建出于非确定新自动机等同的确定性自动机</p> 
<p>这个是用来识别完全相同语言的确定性自动机</p> 
<p>每个状态都是一个item集合</p> 
<p>在每个状态中，都有一组非确定性自动机的状态，</p> 
<p>这意味着，非确定性自动机可能处于上述集合中的任何一种状态</p> 
<p><img src="https://images2.imgbox.com/fa/c7/Ag3v6xSV_o.png" alt="image-20220224235601399"></p> 
<p>这个状态是开始状态，也就是这一整个，因为他有S’-&gt;E 这个item</p> 
<p>这种确定性自动机状态成为item的各种规范集合或者LR(0) item的规范集合</p> 
<p><img src="https://images2.imgbox.com/aa/bf/LpqVoM7a_o.png" alt="image-20220224235654648"></p> 
<p>现在我们需要另一个定义</p> 
<p><img src="https://images2.imgbox.com/57/59/ccOQl1xo_o.png" alt="image-20220225000026451"></p> 
<p>对于一个可行前缀αβ来讲，我们会说这样一个给定的item:X-&gt;β.Y是有效的</p> 
<p>如果满足一下条件，则从起始符号开始<code>S‘</code></p> 
<p>通过一系列最右推导，我们能够得到一个配置αXw</p> 
<p>进一步得到X-&gt;βy</p> 
<p><img src="https://images2.imgbox.com/0d/59/yiDxL5rg_o.png" alt="image-20220225000227511"></p> 
<p>就是说，当解析完α后，在α后紧挨着就看到了β，β在栈上，那这些可以解析到栈顶的items就是有效的items</p> 
<p>那这个item可能就是这个非确定性自动机的确定状态，</p> 
<p><img src="https://images2.imgbox.com/04/79/IrxR9uQj_o.png" alt="image-20220225000349228"></p> 
<p>换一个更加简单的方式来说就是，对于给定的可行前缀α，在DFA读取到这个前缀后，会有一个确切有效的item来辨析辨别，即该item在这个DFA管理的最终状态中，</p> 
<p>当你在栈内看到α，这就是用来描述状态的items</p> 
<p>对于许多前缀来说，item通常是有效的</p> 
<p><img src="https://images2.imgbox.com/70/0c/qUOyfybb_o.png" alt="image-20220225000559553"></p> 
<p>例如，itemT-&gt;(.E) 对于一系列的’（‘ 来说是有效的</p> 
<p>比如有五个括号，</p> 
<p><img src="https://images2.imgbox.com/8d/90/311jTcPO_o.png" alt="image-20220225000638135"></p> 
<p>就会在这里item，进行五次循环，</p> 
<h3><a id="0805_SLR_Parsing_14m16sSLR_5247"></a>08-05: SLR Parsing (14m16s)【SLR解析】</h3> 
<p>SLR解析（简单LR解析） 是基于有效item和可行前缀的思想构建的</p> 
<p><img src="https://images2.imgbox.com/a0/95/PFp4QCkx_o.png" alt="image-20220226175411242"></p> 
<p>LR（0）解析假定</p> 
<p>我们有一个栈，栈内包含元素α，并且下一个输入是词法单元t，这个DFA能用来识别可行前缀，输入α，状态s结束</p> 
<p>如果DFA的最终状态S包含了x-&gt;β，这个item的话，也就是栈顶我们看到了产生式右手边的完整内容，也就是X-&gt;β</p> 
<p>此外，在堆栈下方的所有内容适用于这个状态中的<code>x-&gt;β.</code>，也就是说<code>x-&gt;β.</code>也是一个有效item</p> 
<p>可以使用X-&gt;β 来归约</p> 
<p>移位:</p> 
<p>某种状态s，包含<code>X-&gt;β.tw</code></p> 
<p>那么LR(0)在解析上会遇到什么问题呢？</p> 
<p><img src="https://images2.imgbox.com/a4/d7/gLJXmuRU_o.png" alt="image-20220226181257047"></p> 
<p>他可能会遇到两种问题</p> 
<p>如果DFA中的任何一种状态里有两个可能的归约操作的话，这意味着，这回又两个完整的产生式可供选择进行归约操作</p> 
<p>然后还没有足够的信息供我们去选择该执行哪个归约，所以这部分并不是完全确定性的</p> 
<p>没有足够的信息供我们选择去执行哪个归约，所以这个部分并不是完全确定性的</p> 
<p>被叫做reduce/reduce冲突：如果一个特定状态有两个item，即可以进行两个归约的话，那么这种冲突就会发生</p> 
<p>另一种就是，在DFA的最终状态中，当解析器读取了栈内内容后，可能会遇到一个item可以进行归约操作，但是另一个item进行移位操作</p> 
<p>这就被成为shift/reduce冲突</p> 
<p>这个例子中，这个状态只有一个冲突，即当t是输入中的下一项时，不知道</p> 
<p>t移入栈内，还是选择归约，</p> 
<p><img src="https://images2.imgbox.com/98/49/YhtKwhOC_o.png" alt="image-20220226181846713"></p> 
<p>这个是前两集识别可行前缀的DFA</p> 
<p>这个DFA中存在了一些问题，</p> 
<p><img src="https://images2.imgbox.com/7b/67/rlqdnyya_o.png" alt="image-20220226182226941"></p> 
<p>当我们读取到+号，我们既可以归约E-&gt;T，也可以读取E</p> 
<p>会有一个shift/reduce冲突，</p> 
<p><img src="https://images2.imgbox.com/62/26/pMGb9FAW_o.png" alt="image-20220226185324445"></p> 
<p>当然这个状态，我们也存在shift/reduce冲突，</p> 
<p>改进LR(0) 就是通过SLR</p> 
<p>在移位或则和归约的时候加入一些引导，提升LR（0） 的解析</p> 
<p><img src="https://images2.imgbox.com/cd/07/andZoUAs_o.png" alt="image-20220226185439035"></p> 
<p><img src="https://images2.imgbox.com/54/90/TtB8d7k5_o.png" alt="image-20220226201307793"></p> 
<p>我们只是给这个归约例子添加了一个新的条件，</p> 
<p>这个状态是，β在栈顶，可以进行归约，</p> 
<p>这里的自动机并没有利用输入中出现的任何优势（即根据后续输入来判断接下来所用的产生式）</p> 
<p>这里所做的选择完全是基于栈的内容</p> 
<p>我们预估后面的，既然后面会压入栈内，也就是说后面的t是属于Follow（t）的</p> 
<p>如果t不能跟在X后面的话，或者说t是一个终结符，那么他就不能跟在非终结符X后面，（tips：此时是X-&gt;β.,如果后面跟着一个终结符，β后面的点就没有必要）</p> 
<p>所以新加限制<code>t∈Follow(X)</code></p> 
<p><img src="https://images2.imgbox.com/b8/73/q5kfqcTk_o.png" alt="image-20220226202258089"></p> 
<p>如果在这些规则下还存在冲突的话，这个语法就不叫SLR</p> 
<p>这些规则就构成了用于检测句柄的启发式规则，</p> 
<p>当我们处于栈顶的时候， DFA 就会告诉我们可能有哪些item，以及输入中接下来会出现的内容</p> 
<p>通过这个来定义我们的归约选择，这个可以精确引导，</p> 
<p>我们改进这个旧的例子</p> 
<p><img src="https://images2.imgbox.com/5a/75/UqfEN6VQ_o.png" alt="image-20220226204832479"></p> 
<p>在这两个冲突的时候，</p> 
<p>读取到+ 移位，或者我们可以进行归约，，</p> 
<p>也就是在输入是Folllow（E）中的元素时，我们才会去进行归约，</p> 
<p>我们之前算过， Follow（E）={$,)}</p> 
<p>因为<code>）</code>紧跟在E后所以在里面</p> 
<p><img src="https://images2.imgbox.com/01/c4/FcnZqTsh_o.png" alt="image-20220226205233981"></p> 
<p>只有读取到这些，才会归约，</p> 
<p>我们来看另一个例子的FollowT</p> 
<p>FollowT包含了FollowE的所有元素，但同时，+号也是followT的元素，因为他在T的后面用到了</p> 
<p><img src="https://images2.imgbox.com/31/09/RlMS1erc_o.png" alt="image-20220226205416797"></p> 
<p><img src="https://images2.imgbox.com/54/09/x66cWr9s_o.png" alt="image-20220226205407442"></p> 
<p>当我们处理完输入，或者下一个元素是）或者+的时候，我们进行归约，</p> 
<p>整个这个就相当于是一个SLR（1）语法</p> 
<p><img src="https://images2.imgbox.com/d2/e8/G3PlTpAx_o.png" alt="image-20220226205524320"></p> 
<p>许多语法都不是一个SLR语法，SLR只是对LR(0)的改进，它依然不是一类非常常见的语法</p> 
<p>例如：所有语义混淆的语法都不是SLR语法</p> 
<p>我们可以通过优先级声明来让解析器更加语法化，并解决冲突。</p> 
<p><img src="https://images2.imgbox.com/c8/71/dHJ7eHUx_o.png" alt="image-20220226205702433"></p> 
<p>我们回到这个最自然，同时语义也是最混淆的语法，即在整数运算时用到+和*</p> 
<p><img src="https://images2.imgbox.com/32/86/BARbVCuk_o.png" alt="image-20220226205815469"></p> 
<p>当我们为该语法的可行前缀构造DFA的时候，</p> 
<p>一个状态中，会有两个item，冲突，当我们栈内有E的时候，下一个的接受会影响，*和+ 是要规约呢还是要移位呢？</p> 
<p>是否*和+有优先级的区别</p> 
<p>通过声明，*号比+有更高的优先级，就不会有冲突</p> 
<p><img src="https://images2.imgbox.com/5f/b0/PZtDmjdx_o.png" alt="image-20220226210149238"></p> 
<p>声明并不是去定义优先级，他们会告诉我们请做这个操作，而不是另一个操作，</p> 
<p><img src="https://images2.imgbox.com/05/56/KZPMuviD_o.png" alt="image-20220226210517749"></p> 
<p>这里给出了SLR解析的相关算法</p> 
<p>M是解析自动机，用来识别前缀，初始时，<code>|</code>在最左边，表示栈空，</p> 
<p>$来标记输入的末尾</p> 
<p>我们会进行重复操作，直到栈内，只有开始符号并且输入中只有$ 这意味着完成了所有的输入，也将整个的输入归约为了开始符号，</p> 
<p>我们当前是<code>α|w</code> α是栈内内容，w是输入中剩下的部分</p> 
<p>我们去运行自动机，让他读取栈内α，（我们需要使用自动机对栈进行一波前缀解析操作，为后续做准备，）如果M拒绝了α的话，或者如果M表示α并不是一个可行前缀的话，那么我们就会爆出一个解析错误</p> 
<p>M如果接受了α，如果以这个状态下item结束的话，就会去看下一个输入a</p> 
<p>我们就会进行移位操作，如果下一个看到终结符a，这是ok的，</p> 
<p>我们进行归约，要求和我们之前的一样，</p> 
<p><img src="https://images2.imgbox.com/cc/32/Z8JxRByb_o.png" alt="image-20220226211219062"></p> 
<p>而事实上，这里并不需要M检查前缀，因为不符合的，都会被爆解析错误，（在最后）</p> 
<p>如果在最后一步有任何冲突的话， 就不是SLR（k）语法</p> 
<p>k就是向前看几个token，一般向前看一个</p> 
<h3><a id="0806_SLR_Parsing_Example_6m42sSLR_5451"></a>08-06: SLR Parsing Example (6m42s)【SLR解析案例】</h3> 
<p><img src="https://images2.imgbox.com/3c/f9/z0ERqbPb_o.png" alt="image-20220227223945045"></p> 
<p>简单回顾：</p> 
<p><img src="https://images2.imgbox.com/de/4a/OKfWws6L_o.png" alt="image-20220227224044481"></p> 
<p>$标记结尾，</p> 
<p>状态一开始，栈为空栈，对于初始状态，这些产生式是可以进入的</p> 
<p><img src="https://images2.imgbox.com/cd/ba/SEKVpy6r_o.png" alt="image-20220227224206399"></p> 
<p>这些item中，有两个item可以让我们将int进行移位操作，</p> 
<p><img src="https://images2.imgbox.com/5d/b7/pw3QhPtX_o.png" alt="image-20220227224259991"></p> 
<p>这里点都在最左边，没办法归约</p> 
<p><img src="https://images2.imgbox.com/46/46/4WSaipjX_o.png" alt="image-20220227224411148"></p> 
<p>在初始状态下，DFA会在状态1停止，这个状态让我们移位</p> 
<p>进入下一个状态，下一个元素是*</p> 
<p><img src="https://images2.imgbox.com/43/8b/gNlIdnSt_o.png" alt="image-20220227224523631"></p> 
<p>当然首先我们可以通过T-》int. 来进行归约，只有当接下来输入元素是FollowT，才能进行归约，</p> 
<p>但是，*不是FollowT的元素，因此不能使用来归约，</p> 
<p>我们可以看另一个item，可以将*进行移位操作</p> 
<p><img src="https://images2.imgbox.com/27/55/u0pSZHus_o.png" alt="image-20220227224733303"></p> 
<p>下一个输入元素是int，</p> 
<p><img src="https://images2.imgbox.com/ed/87/UpblYuHX_o.png" alt="image-20220227224921075"></p> 
<p>栈内有int和*</p> 
<p>*处于栈顶，下面是int，DFA从栈底开始读取</p> 
<p>int -》*》然后进入11状态</p> 
<p><img src="https://images2.imgbox.com/2f/a4/Mkk1gIvd_o.png" alt="image-20220227225033252"></p> 
<p>我们看到没有归约，点没有在最右边，因此可以是移位</p> 
<p>下一个int 移位，</p> 
<p><img src="https://images2.imgbox.com/61/69/1NQvGLo1_o.png" alt="image-20220227225155727"></p> 
<p>栈内为int*int</p> 
<p><img src="https://images2.imgbox.com/31/ed/6vvWuMgE_o.png" alt="image-20220227225519394"></p> 
<p>最后到了第三个item 下一个输入是$</p> 
<p>因此是FollowT的元素，因此可以进行归约</p> 
<p><img src="https://images2.imgbox.com/1e/61/eO1Q8ZgH_o.png" alt="image-20220227225923142"></p> 
<p>然后我们再接着读取栈内，<code>int * T</code></p> 
<p><img src="https://images2.imgbox.com/b9/31/rDdzuUFT_o.png" alt="image-20220227230026623"></p> 
<p>读取到T，到达了4，在状态4停止。</p> 
<p>可以进行归约，</p> 
<p><img src="https://images2.imgbox.com/ad/95/V8NCoWnc_o.png" alt="image-20220227230139823"></p> 
<p><img src="https://images2.imgbox.com/10/e1/meUeIxya_o.png" alt="image-20220227230202541"></p> 
<p>栈内读取到T，从1跳到了5</p> 
<p>如果输入中的下一个元素是+好，就能进行移位，可惜不能，</p> 
<p>因此使用E-》T 进行归约，</p> 
<p><img src="https://images2.imgbox.com/c2/4b/rJZ8lMkX_o.png" alt="image-20220227230247037"></p> 
<p>栈内只剩E，</p> 
<p><img src="https://images2.imgbox.com/9d/1c/fITI2R4s_o.png" alt="image-20220227230301308"></p> 
<p>因此，我们只有一个状态可以，然后我们接受这个解析</p> 
<p><img src="https://images2.imgbox.com/87/e6/YNn7Tx7z_o.png" alt="image-20220227230356929"></p> 
<h3><a id="0_807_SLR_Improvements_11m49sSLR_5557"></a>0 8-07: SLR Improvements (11m49s)【SLR改进】</h3> 
<p>SLR解析算法 比较低效</p> 
<p><img src="https://images2.imgbox.com/58/d0/r9X5L1ex_o.png" alt="image-20220227233403783"></p> 
<p>自动机读取栈时所做的大部分工作，实际上是多余的</p> 
<p><img src="https://images2.imgbox.com/2f/bf/Hsjms1qj_o.png" alt="image-20220228224446396"></p> 
<p>每次重复的去读取栈，就会十分的耗费时间空间</p> 
<p><img src="https://images2.imgbox.com/73/85/5c94Xuj6_o.png" alt="image-20220228224536157"></p> 
<p>我们只需要记住栈前缀是多少即可省略这些重复的步骤</p> 
<p>栈内都存储的是一个pair，</p> 
<p><img src="https://images2.imgbox.com/17/d9/X529ZIzG_o.png" alt="image-20220228224824534"></p> 
<p>这里的DFA状态就是DFA的运行结果，</p> 
<p>sym1----symn就是之前的栈内保存的符号，与dfa一一对应</p> 
<p><img src="https://images2.imgbox.com/a6/1d/yob469Ur_o.png" alt="image-20220228224942230"></p> 
<p>在栈上任意取一点，就会得到DFA对整个栈中这一点前的内容的运行结果</p> 
<p>我们需要将开始状态存储在栈底，</p> 
<p>算法细节：</p> 
<p><img src="https://images2.imgbox.com/b7/11/8gqmOFup_o.png" alt="image-20220228225113672"></p> 
<p>首先定义一个goto表， 根据一个状态和一个符号映射到另一个状态</p> 
<p>goto表仅仅是一个DFA的状态转换函数，是把DFA的图以数组的形式写出</p> 
<p>我们的SLR算法有四种操作，</p> 
<p>移位 会压栈</p> 
<p>x代表DFA的一个状态</p> 
<p>pair的另一个元素a就是当前输入</p> 
<p><img src="https://images2.imgbox.com/10/05/tSN7Mzjb_o.png" alt="image-20220228225330568"></p> 
<p>归约 会从栈内弹出</p> 
<p>最后成功解析没有成功解析的，error，</p> 
<p><img src="https://images2.imgbox.com/52/5c/6QYuD3Vx_o.png" alt="image-20220228225613589"></p> 
<p>接着是一个解析表，也就是动作表，他告诉我们在每个可能的状态下，我们应该进行哪一种操作，</p> 
<p>动作表是根据自动机的一个状态和下一个输入符号来做的索引</p> 
<p>里面有移位，归约，accept，error</p> 
<p>如果在栈顶处自动机的最终状态中有一个item，也就是说可以对a进行移位操作，输入a，可以进入状态j</p> 
<p>当我处于状态i并接受到输入a，就会将j压入栈内</p> 
<p><img src="https://images2.imgbox.com/11/a4/d5ncUcZV_o.png" alt="image-20220228230154463"></p> 
<p>也就是状态i结束，并且下一个输入a的时候，pair&lt;a,j&gt; 压入栈内</p> 
<p>其他几个同理，</p> 
<p>处于状态si，并且输入为a，使用产生式X-&gt;α进行归约</p> 
<p>如果左手边符号是特殊开始符号S‘的话，我们不进行归约，</p> 
<p>如果要归约的item是S’-&gt;S. 此时处于输入末尾，那就接受accept</p> 
<p>其他情况报错error</p> 
<p><img src="https://images2.imgbox.com/86/1e/0d7RTq8z_o.png" alt="image-20220301003748447"></p> 
<p>这个就是SLR原始算法</p> 
<p>初始输入I，index变量j，可以指向token</p> 
<p>repeat 重复这些过程直到我们成功解析</p> 
<p><img src="https://images2.imgbox.com/66/d0/EBnySTcU_o.png" alt="image-20220228231412356"></p> 
<p>他没有用到栈内的任何东西，只是使用了DFA的状态和输入，</p> 
<p>在编译器的后续阶段，我们仍然需要用到程序，用来类型检查和代码生成</p> 
<p><img src="https://images2.imgbox.com/ec/43/kS1JxqG8_o.png" alt="image-20220301003342889"></p> 
<p>被广泛使用的自下而上型解析算法是基于一类被称为LR语法的更强大的语法</p> 
<p>LR语法和SLR本质区别就是把向前看这种能力内置到了item中，</p> 
<p>LR（1） item 就会变成一个包含 一个item的pair</p> 
<p>如果看到$,当然就是进行归约，</p> 
<p>现在一般使用LALR 他是对LR的一种优化</p> 
<h3><a id="0808_SLR_Examples_12m47sSLR_5677"></a>08-08: SLR Examples (12m47s)【SLR案例】</h3> 
<p><img src="https://images2.imgbox.com/88/e1/7aFknro7_o.png" alt="image-20220301231935844"></p> 
<p>提供了一些语法，</p> 
<pre><code>S-&gt;Sa
S-&gt;b



</code></pre> 
<p>我们先写出解析该语法所对应的自动机</p> 
<p>首先补充一个开始状态，<code>S'-&gt;S</code></p> 
<pre><code>S'-&gt;S
S-&gt;Sa
S-&gt;b
</code></pre> 
<p><code>S'-&gt;.S</code> 这个item就是这个NFA解析自动机的开始状态</p> 
<p>我们继续前进，然后算DFA的第一个状态重，必须要有那些item</p> 
<p>NFA中的所有空跳， 只有在我们在栈上看不到一个非终结符的时候才会产生，这往往可以从对非终结符元素推导的过程中看到，（比如这里的First集，这里包含了通过空跳得到的元素）</p> 
<p>在NFA中，对于该非终结符的所有产生式而言，内在的first集都有一个空跳epsilon</p> 
<p>空跳得到，<code>S-&gt;.Sa</code></p> 
<p>对于S而言，也可以,<code>S-&gt;.b</code></p> 
<p><img src="https://images2.imgbox.com/78/c3/dTIwrP3a_o.png" alt="image-20220301232726511"></p> 
<p>这三个item就是DFA第一个状态所包含的items</p> 
<p>现在我们需要思考下，我们可能在栈上看到的每个符号下可能发生的状态转换</p> 
<p>如果我们在栈内看到一个b，状态只有S-&gt;b.</p> 
<p><img src="https://images2.imgbox.com/f9/9e/LsBQV0GH_o.png" alt="image-20220301232901381"></p> 
<p>另一种可能性，看到S</p> 
<p>一种是<code>S'-&gt;S.</code>, 另一个<code>S-&gt;S.a</code></p> 
<p><img src="https://images2.imgbox.com/12/9e/bVW2dYiO_o.png" alt="image-20220301232952603"></p> 
<p><img src="https://images2.imgbox.com/5f/67/vuUt8bbJ_o.png" alt="image-20220301233107920"></p> 
<p>这些大部分状态不存在归约/移位 冲突</p> 
<p>如果说判断是否是SLR（1），</p> 
<p>但是有一个</p> 
<p><img src="https://images2.imgbox.com/39/84/CuedFDIj_o.png" alt="image-20220301233216066"></p> 
<p>读取到S，既可以归约，又可以移位</p> 
<p>S’的Follow集合有什么呢？</p> 
<p>也就是S’ 后面能跟什么呢？也就是唯一的<code>$</code></p> 
<h4><a id="example_5745"></a>example</h4> 
<p>一个比较复杂的例子</p> 
<p><img src="https://images2.imgbox.com/fe/54/lYxJX9tV_o.png" alt="image-20220301233412501"></p> 
<p>初始语法，</p> 
<p>我们接着构建解析自动机</p> 
<p>正常需要我们去画NFA的草图，然后进行状态子集的构建，</p> 
<p>因为语法规则比较少，这里直接写,.后跟S我们可以空跳</p> 
<pre><code>S'-&gt;.S
S -&gt;.SaS
S-&gt;.b
</code></pre> 
<p>这就是关于S的初始item</p> 
<p><img src="https://images2.imgbox.com/ae/db/Bf4bBcEW_o.png" alt="image-20220301233611570"></p> 
<p>可以在栈内看到一个b</p> 
<p><img src="https://images2.imgbox.com/e9/93/8VlcW6zl_o.png" alt="image-20220301233622926"></p> 
<p>另一种，栈内看到S，</p> 
<p><img src="https://images2.imgbox.com/8d/b6/L78q2OO3_o.png" alt="image-20220301233636453"></p> 
<p>看到a，</p> 
<p><img src="https://images2.imgbox.com/ec/cf/CP1ODVbJ_o.png" alt="image-20220301233716755"></p> 
<p>这里就会复杂一些，因为<code>.S</code>我们在栈内除了会看到一个S，我们也可能会在栈内的下一个位置看到某些从S推导出来的东西，</p> 
<p>也就需要把S的产生式都填进来</p> 
<p><img src="https://images2.imgbox.com/48/34/0Dx43VEY_o.png" alt="image-20220301234146632"></p> 
<p>如果看到b，就转到b，看到S就会产生新的状态</p> 
<p><img src="https://images2.imgbox.com/2a/c5/vtNF33tH_o.png" alt="image-20220301234207427"></p> 
<p><img src="https://images2.imgbox.com/59/f1/VUt9xOwB_o.png" alt="image-20220301234246382"></p> 
<p>我们有一次遇到a的时候，</p> 
<p>就会回去，</p> 
<p><img src="https://images2.imgbox.com/73/69/95BW2vWk_o.png" alt="image-20220301234315609"></p> 
<p>这就是完整的状态转化那系统，也就是DFA的所有状态，</p> 
<p>这是一个SLR（1）么?</p> 
<p>我们需要检查一下reduce/reduce，shift/reduce冲突</p> 
<p><img src="https://images2.imgbox.com/be/5b/FLn2Ryws_o.png" alt="image-20220301234519399"></p> 
<p>首先找到这里，</p> 
<p>Follow(S’)={$}</p> 
<p>这儿不存在冲突，</p> 
<p><img src="https://images2.imgbox.com/a8/23/LZCFHxgf_o.png" alt="image-20220301234708838"></p> 
<p>我们看这里</p> 
<p>只有栈内的下一个元素为b或者s的时候，才会发生状态转换</p> 
<p>没有归约，</p> 
<p><img src="https://images2.imgbox.com/65/0d/PKBI2RMW_o.png" alt="image-20220301234713827"></p> 
<p>最后一个状态</p> 
<p>第一个item就是可以进行归约的item</p> 
<p>FollowS中的任何都应该使用S-&gt;SaS来归约，根据S’-&gt;S,FollowS’都是followS的元素</p> 
<p>Follow(S) = {$,a,}</p> 
<p>根据<code>S-&gt;SaS</code> 第一个S后面跟着a，所以followS里面有a</p> 
<p>又根据，S是最右边的一个，因此产生式右手边的任何东西也就是左手边非终结符Follow集合中的元素，FollowS是FollowS的子集，</p> 
<p>在输入中，遇到$进行归约，遇到a移位，这里会有shift-reduce冲突</p> 
<p><img src="https://images2.imgbox.com/1d/50/QrtXeyI9_o.png" alt="image-20220301235141872"></p> 
<p>这并不是一个SLR(1)语法</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f72169f084bb841ebf9b7926e1210a3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">卡西欧计算器——三角函数的角度模式与弧度模式的切换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bf32cd398fb3de1eab66a2354a071fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Autoware 1.12学习整理--03--NDT点云定位</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>