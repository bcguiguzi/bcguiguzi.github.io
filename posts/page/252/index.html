<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176b4ac5f3685fd6f418d91ec6741dd1/" rel="bookmark">
			windows内存占用过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows开机内存占用超过30%（6G/18G）,Come on:
Round 1 msconfig-&gt;常规：有选择的启动-&gt;服务-&gt;隐藏所有Microsoft服务，全部禁用。Ban了再说。需要的自己单独启。
发现触摸板配置没了（主要是连接外部设备时禁用触摸板的设置），查找刚刚关闭的服务，是SynTPEnhService(制造商：Synaptics)，开启它。设置以后记得点击应用才会生效。
添加虚拟内存，设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;高级-&gt;性能：设置-&gt;更改，改成8192G. 建议位置放在非C盘。
重新审视一下自己设置自启动的软件：任务管理器-&gt;启动。将没必要的禁用。有些服务是偶尔想要使用一次，但日常百分之八十时间都没用，没必要一直挂着，用的时候再手动启动就行了。个人把像everything、搜词这样的都关了。个人自启动的有：Clash(代理)、Ditto(粘贴板，Windows有自带的，在设置-&gt;系统-&gt;剪贴板中开启，个人觉得不够好用，不能缓存如图片等)、Traffic Monitor(占用率监视)等。
经过前三步。重启后内存占用仅20%以下（2G左右)
Round 2 重启后再打开任务管理器瞧瞧，看下有哪些好康的.
Vmmen：每次开启占用很高。是安装WSL使用的Hyper-v导致的。不过一段时间后就消失。WSL不用时最好还是shutdown了，关注window + hper-v +docker可能有坑：https://zhuanlan.zhihu.com/p/277825426。
secure system：一直都存在。名字可疑的像病毒…解释是：由于启用内存完整性需要启用虚拟化，以便可以打开 Hyper-V 虚拟机以包含核心 Windows 操作系统组件。又是Hyper-v，真麻烦。动不了，留着吧。
开始：开始菜单。留着
Windows Modules Installer Worker：windows更新。可以在设置-&gt;更新中，暂停更新，或者关闭自动更新。
MoUSO Core Worker Process：管理 Windows 更新的安装。同Windows更新。不过这几个都是开机一会就没了。一般可以不用管，除非占用大量资源。
Microsoft Text input Application：设置-&gt;隐私-&gt;墨迹书写和键入个性化
Microsoft Office Click-to-Run (SxS)：Microsoft Office自带的东西。一直会留着，没占用太多不管。
然后是后台服务。任务管理器-&gt;服务，一个一个看看。主要挑前几个占用较高的吧。参考：https://www.zhihu.com/question/36192602
服务主机UtcSvc(Connected User Experiences and Telemetry):
微软用于改进 Windows 平台的体验和质量的。干掉。
服务主机WindowsEventlog：大概是事件日志，留着吧。
windowsUpdate：这个也是开机一段时间就没了。想干掉可以干掉。
Diagnostic：断你的系统错误，反馈给微软，帮你自动解决。屁用。干掉。
还有好多懒得一个一个去找了…
更多服务解释：https://blog.51cto.com/u_13762952/3628967
虚拟机 装个win10虚拟机，卡死人了。
服务主机 SysMain
它的工作是随着时间的推移维护和改善系统性能
services.msc 关掉SysMain
antimalware service executable
Windows Defender扫描杀毒(你才是最大的毒，烦死我的毒)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176b4ac5f3685fd6f418d91ec6741dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb9663c6e22898faab48fc4775cdbd5/" rel="bookmark">
			TCP可靠传输、拥塞控制、沾包知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP面向连接，传输可靠
传输数据前需要先建立连接，结束后断开
TCP分层：
应用层：通过应用进程间交互完成网络任务
传输层：负责进程间提供数据传输服务（TCP/UDP）
网络层：网络层选择合适路由、节点确保数据传送（TCP/IP采用IP协议）
链路层：链路层将IP数据报装成帧
物理层：物理层实现计算机比特流传送
UDP面向无连接，传输不可靠
发送方直接发送，接收方直接接受
TCP保证可靠传输：
①校验和：TCP将保存首部和数据的校验和，当接收端接收后将计算，若校验和不一致，丢弃，不确定收到。
②流量控制：TCP连接每一方都有一个固定大小缓冲区，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方不可处理发送方数据，可以提示发送方降低发送速率。
③拥塞控制：当网络拥塞，发送方调整数据发送策略。
④ARQ（自动重传）协议：每发完一个分组停止，等待确认后再继续发送。（有超时、确认两个机制）
⑤超时重传：TCP发送分组后启动定时器，等待确认，若确认超时则重新发送。
流量控制：TCP采用滑动窗口控制，接收方的确认报文可以控制发送方窗口大小。
拥塞控制：
①慢开始：当刚开始发送数据时，先从小到大增大发送窗口（二倍提升）
②拥塞避免：当窗口达到慢开始门限值（初始16），改用拥塞避免算法，即一个一个开始加窗口大小。当网络拥塞后，窗口门限设置为当前一半，再重新慢开始、拥塞避免
③快重传：当接收方收到一个失序报文时立刻发送重复确认，而不是等到自己发送时再确认。发送方接收到连续重复确认三次后，直接重传丢失部分。
④快恢复：当连续收到三个重复确认，将窗口门限减半，但不执行慢开始，而是将窗口大小直接设置为门限大小，并执行拥塞控制增大窗口。
粘包：
定义：发送方若干数据包在到达接收方时粘到一起。
原因：
发送端：①要发送的数据小于缓冲区大小，发送时将多次写入缓冲区的数据一次性发送出去。
②Nagle算法：作用：减少网络报文数量
机制：在上一个小组确认，才发送下一个小组；收集多个小组，在一个确认到达时才一起发送。
接收端：没有及时读取缓冲区数据
处理：
发送方：关闭Nagle算法
接收方：让应用层从接收方缓存区读取数据时，给每个数据加上开始、结束标志
注：因为TCP为了保证可靠传输，采用基于流的传输，流并不认为消息是一条一条的，而是无保护消息边界的。
UDP是面向消息传输，接收方一次只接收一条独立消息（有消息保护边界），不存在粘包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050e3e6f20c48ba8415b76d33c9d18e4/" rel="bookmark">
			Java四种引用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强引用、软引用、弱引用、虚引用
强引用： 创建一个对象并且把对象赋值给引用变量
Object object = new Object(); 这里object属于强引用，永远不会被垃圾回收。
若想使其回收，需要将变量赋值为null。
软引用： 如：
MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 当我们
aRef = null; 即将对象强引用移除后，aSoftRef就只作为软引用。
软引用当内存不足时，将会被回收。
弱引用： 如：
WeakReference&lt;People&gt;reference=new WeakReference&lt;People&gt;(new People("mhy",20)); 当JVM进行垃圾回收，无论内存是否充足，若引用都将被回收。
虚引用： 虚引用必须搭配引用队列使用，当JVM需要回收一个对象，先判断是否有虚引用，若有则先加入引用队列，当引用队列被处理时，该对象才会被操作。（被虚引用≈没有被引用，无法通过虚引用获取对象，主要用来跟踪对象被垃圾回收的过程）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9947694cf6e5686b4097ca88b2920c/" rel="bookmark">
			厉害，我带的实习生仅用四步就整合好SpringSecurity&#43;JWT实现登录认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小二是新来的实习生，作为技术 leader，我还是很负责任的，有什么锅都想甩给他，啊，不，一不小心怎么把心里话全说出来了呢？重来！
小二是新来的实习生，作为技术 leader，我还是很负责任的，有什么好事都想着他，这不，我就安排了一个整合SpringSecurity+JWT实现登录认证的小任务交，没想到，他仅用四步就搞定了，这让我感觉倍有面。
一、关于 SpringSecurity 在 Spring Boot 出现之前，SpringSecurity 的使用场景是被另外一个安全管理框架 Shiro 牢牢霸占的，因为相对于 SpringSecurity 来说，SSM 中整合 Shiro 更加轻量级。Spring Boot 出现后，使这一情况情况大有改观。正应了那句古话：一人得道鸡犬升天，虽然有点不大合适，就将就着用吧。
这是因为 Spring Boot 为 SpringSecurity 提供了自动化配置，大大降低了 SpringSecurity 的学习成本。另外，SpringSecurity 的功能也比 Shiro 更加强大。
二、关于 JWT JWT，是目前最流行的一个跨域认证解决方案：客户端发起用户登录请求，服务器端接收并认证成功后，生成一个 JSON 对象（如下所示），然后将其返回给客户端。
从本质上来说，JWT 就像是一种生成加密用户身份信息的 Token，更安全也更灵活。
三、整合步骤 第一步，给需要登录认证的模块添加 codingmore-security 依赖：
&lt;dependency&gt; &lt;groupId&gt;top.codingmore&lt;/groupId&gt; &lt;artifactId&gt;codingmore-security&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 比如说 codingmore-admin 后端管理模块需要登录认证，就在 codingmore-admin/pom.xml 文件中添加 codingmore-security 依赖。
第二步，在需要登录认证的模块里添加 CodingmoreSecurityConfig 类，继承自 codingmore-security 模块中的 SecurityConfig 类。
@Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class CodingmoreSecurityConfig extends SecurityConfig { @Autowired private IUsersService usersService; @Bean public UserDetailsService userDetailsService() { //获取登录用户信息 return username -&gt; usersService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9947694cf6e5686b4097ca88b2920c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a261a4111379ace7054da2b1ac7a04/" rel="bookmark">
			蓝桥杯 杨辉三角形【第十二届】【省赛】【C组】H题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：“蓝桥杯”练习系统
题面： 唠嗑：今天重新打一遍这题，我发现对比去年的自己解题思路上面没有丝毫进步，又被打击了，果然生活很甜应该多吃点苦，去年怎么打今年怎么打，只会跑暴力，只会枚举整个杨辉三角，于是只得了惨惨的30分，自闭
n的最大情况1e9，如果没有推错应该在第1000000001层的第二个，然后杨辉三角的第i层有i个数，枚举就是sum(i * i)(1 - 1000000001)贴t
然后学习一个比较巧妙的方法
我们看杨辉三角的左半边，然后斜线看
可以发现第一斜行是C(0, 0)，第二斜行是C(2,1)，第i行是C(2 * i, i)
我们可以快速的计算出C(32,16) &lt; 1e9,C(34, 17) &gt; 1e9,那么最大的就在第16斜行，然后从第16斜行遍历到第0斜行，去二分查找n的位置，因为第i斜行的第一个数是C(2 * i, i),第二个是C(2 * i + 1, i),第l个就是C(2 * i + l - 1, i)
二分的右区间是max(n, 2 * i)这个对于输入1的时候至关重要
#include &lt;bits/stdc++.h&gt; using namespace std; #define endl "\n" #define ll long long int main(){ int n; while(~scanf("%d", &amp;n)){ bool f = 0; for(int i = 16; i &gt;= 0; i--){ int l = i * 2; int r = max(n, l); while(l &lt;= r){ ll mid = (l + r) / 2; ll ans = 1; for(int x = mid, y = 1; y &lt;= i; y++, x--){ ans *= x; ans /= y; if(ans &gt; n){ r = mid - 1; break; } } if(ans &lt; n){ l = mid + 1; }else if(ans == n){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a261a4111379ace7054da2b1ac7a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2783acf5e178ff457ec796afee7b7fd2/" rel="bookmark">
			Edge小技巧(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式化复制网页 Web 选择可帮助您复制格式化的 Web 内容，如表格、页眉和图像。只需右键单击浏览器窗口，然后选择 “Web 选择”，或使用键盘快捷键 Ctrl + Shift + X。然后选择并拖动光标以突出显示所需的内容，然后选择 “复制”。
适合将网页内容带格式的复制到word文档，如果粘贴到markdown会变成图片。更重要的是，如果网页本身是不允许选择复制的，用这种方式也能复制出来。一个字，屌！
网页截图 通过 Web 捕获，您可以轻松地从整个 Web 中抓取和标记屏幕截图。只需右键单击浏览器窗口并选择 “Web 捕获”，或使用键盘快捷键 Ctrl + Shift + S。
这个快捷键只能在浏览器窗口截图，那么问题来了，Windows屏幕截图快捷键是什么呢？
答案是win + shift + s。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb09f064c21d1fc18ddd8c33b3489fb4/" rel="bookmark">
			深入详解数据库事务（开发必用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.事务的概念： 一组逻辑操作单元，时数据从一个状态转换到另一个状态。
二.事务处理的原则： 保证所有的事务都被当做一个操作单元来执行，即使出现了故障，也不能改变这种处置原则。要么与事务相关的数据全部被修改，并永远的提交保存下来，要么所有的事务全部回滚到事务没被执行的状态。
三.那些操作会影响数据库的提交 （一）.数据库连接一旦断开，数据库的数据都被会提交
（二）.DDL操作完成，数据自动提交，并且无法回滚
（三）.DML操作默认为提交，但是可以通过 set auto commit = false;来设置不允许自动提交
四.模拟事务提交
事务执行过程图：
通用的包含事务的更新方法
/** * 包含事务的通行的方法实现增删改 * @param conn 从外部传入的数据库连接，意图在执行完一次DML操作时，数据库的连接不会断开， * 确保事务不会因为连接断而出现提交的现象 * @param sql 增删改语句 * @param args 占位符？个数不一定，根据sql占位符的个数，传入对应数量object */ public static int update(Connection conn,String sql,Object... args){ int temp = -1; PreparedStatement pst = null; try{ //2.预编译sql语句 pst = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { pst.setObject(i+1,args[i]); } //4.执行 /* pst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb09f064c21d1fc18ddd8c33b3489fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf16abe0a2a6002ea7bf53729f0c8225/" rel="bookmark">
			组合设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合设计模式 一、组合设计模式 1、介绍 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构。将对象组合成树状结构以表示“整体-部分”的层次关系组合模式依据树形结构来组合对象，用来表示部分以及整体层次组合模式属于结构型模式组合模式使得用户对单个对象和组合对象的访问具有一致性。即：组合能让客户以一致的方式处理个别对象以及组合对象 2、原理UML类图 Component：这是组合中对象声明接口，定义或实现公共有的接口默认行为，用于访问和管理Component子部件，Component可以是抽象类或接口Composite：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加、删除、操作Leaf：在组合中表示叶子节点，叶子节点没有子节点 3、组合模式优点和使用 简化客户端操作。客户端只需面对一致的对象而不用考虑整体部分或者节点的问题具有较强扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系。客户端不用做出任何改动方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子，从而创建出复杂的树形结构需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式要求较高的抽象性，如果节点和叶子有很多差异性的话。比如很多方法和树形不一样，那么不适合使用组合模式 二、普通设计编程 1、介绍 公司、部门、组构成三个层次。
公司包含部门，部门包含组。
如果没有学过组合设计模式，我们一开始的解决方法会如下方所示。Company类聚合Department类，Department类聚合Group类。
此种方法的优势在于简单、容易理解。
但是对于客户端来说，操作复杂，无论我们是增加还是删除一个公司下的部门（或部门下的组），涉及的代码较多。同时这种设计也不利于管理。
2、UML 3、代码 import java.util.List; /** * @description: 公司 * @author: dashu * @create: 10:43 */ public class Company { /** * 名称 */ private String name; /** * 部门 */ private List&lt;Department&gt; departments; public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;Department&gt; getDepartments() { return departments; } public void setDepartments(List&lt;Department&gt; departments) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf16abe0a2a6002ea7bf53729f0c8225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bba41376fa6e1b3fb711cfcb07f1d5/" rel="bookmark">
			Android WebView 调起H5支付，提示商家参数格式有误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：Android WebView 调起H5支付，提示商家参数格式有误 - 知乎题记 —— 执剑天涯，从你的点滴积累开始，所及之处，必精益求精，即是折腾每一天。 重要消息精通点的可以查看这里 精述Flutter 从入门实践到开发一个APP之UI基础篇 视频flutter从入门 到精通 系列文章1 引言场景…https://zhuanlan.zhihu.com/p/103539764 1 引言 场景描述：在APP 中使用webView 显示第三方H5, H5中涉及到微信支付流程，无法正常支付，提示 “商家参数格式有误，请联系商家解决”。
1.1 线索分析 参照微信H5 支付开发官方文档点击这里查看
描述一
一般提示出错，我们可以先去微信商户管理平台点击这里查看 配制，当然出错后，也不急着去商户后台去查看配制，因为在开发微信支付功能初期这些都是已经配制好的，当然是在其平台比如 浏览器、Ios UIWebview 等都可以正常的调起支付，那说明在商户后台的配制是没有问题的，不过我们也可以再次去查看一下商户后台配制的具体值。
描述二
参照微信H5 支付开发官方文档常见问题点击这里查看
在网络发生变动的情况会出现此提示之一
也有提到 “如果是APP里调起H5支付，需要在webview中手动设置referer”，具体内容如下
那么到这里，我们可以手动的在 Android WebView 中添加头 referer ,这个请求头
简言之，HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器 籍此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。Referer其实应该是英文单词Referrer，不过拼错的人太多了，所以编写标准的人也就将错就错了 在安卓WebView中手动配制请求头 referer
然后再次使用 安卓 WebView 来加载 H5 项目，然后发起微信支付，然后发起成功
分析： 当没有在Android WebView 中添加头 referer 请求头， 同样的 H5 项目，分别在 在 Android WebView 、浏览器、ios UIWebVie 中访问打开，浏览器、ios UIWebVie 中，都可以正常调起支付，只有 Android WebView 中微信支付调起失败，提示商家参数格式有误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bba41376fa6e1b3fb711cfcb07f1d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffc3c8c978193371bda42e78a6933d3/" rel="bookmark">
			Python实现BF算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目要求 实现字符串模式匹配BF（Brute-Force）算法（基于链串也可以）。
函数功能：BF算法­——求模式串t在目标串s是否匹配
函数输入：目标串s、模式串t
函数输出：匹配成功：返回模式串t首次在s中出现的位置
匹配不成功：返回-1
二、思路： 借鉴网上C++思路写了python的实现：
1 子串t从头开始，依次与主串对比，匹配失败时子串从头开始，主串后移
2 一个循环三个判断
i和k(主串每次匹配的开头)的距离与j和开头的距离相同且j位于子串末尾——匹配成功 不断判断对应位置是否相同，相同向后遍历 一旦不同使主串后移，子串清0重新开始对比(如果一轮开始前主串剩余长度&lt;子串长度直接匹配失败) 三、代码： #!/usr/bin/python3 # author lzx # python实现 def BF(s, t): i = 0 j = 0 k = 0 flag1 = -1 while (i &lt; len(s) and j &lt; len(t)): # 匹配成功 if (i - k == j) and (j == len(t) - 1) and (s[i] == t[j]): flag1 = k break # s和t相等就继续向后匹配 if s[i] == t[j]: i = i + 1 j = j + 1 # 不相等从k的位置开始匹配 else: k = k + 1 i = k j = 0 # 假如s中所剩字符小于t中所剩字符 if (len(s) - i) &lt; len(t): flag1 = -1 break return flag1 if __name__ == '__main__': s = input('输入目标串s：') t = input('输入模式串t：') flag = BF(s, t) if flag !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffc3c8c978193371bda42e78a6933d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e725e098bdb9c72f0da2008f5be2e7/" rel="bookmark">
			【结构体内存对齐】热门考点——计算结构体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么存在内存对齐 大部分的参考资料都是如是说的：
1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能再某些地址处取某些特定类型的数据，否则抛出硬件异常。
2.性能原因：数据结构(尤其是栈)应该尽可能地再自然边界上对齐。原因在于，为了访问未对其的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
总体来说：结构体的内存对齐是拿空间来换取时间的做法 二、（考点）如何计算？ 首先得掌握结构体得对齐规则：
1.第一个成员再与结构体变量偏移量为0得地址处。
2.其他成员变量要对齐到自身对齐数得整数倍得地址处。
对齐数 = 编译器默认得一个对齐数 与 该成员大小的较小值 （VS中默认的值为8）
3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
三、手撕代码 上面的干货太干了是不是，小伙伴们可以多读几遍，结合下面练习把这块知识点拿下。
练习1： struct s1 { char c1; int i; char c2; }; printf("%d\n", sizeof(struct s1)); //12 练习2： struct s2 { char c1; char c2; int i; }; printf("%d\n", sizeof(struct s2)); //8 练习3： struct s3 { double d; char c; int i; }; printf("%d\n", sizeof(struct s3)); //16 练习4： struct s4 { char c1; //0 struct s3 s; //8-23 double d; //24-31 int i; }; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e725e098bdb9c72f0da2008f5be2e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa43336be819b1d52e061fb645721d33/" rel="bookmark">
			Go语言操作MySql相关学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假期关于mysql相关的操作学习，总结记录，以飨读者
Mysql是业届常用的关系型数据库，本文以go语言学习如何操作mysql数据库。
主要包括以下几个部分：
Ping测试mysqlmysql连接池相关参数配置CURD相关操作mysql超时操作mysql事务操作 完整代码参考我的github工程go语言操作mysql
零、环境准备及go工程创建 环境：centos、mysql8.0
首先保证mysql服务正常，可以使用sql相关命令进行连接测试，创建几条测试数据方便后续操作。
mysql -u你的名字 -p你的密码 CREATE DATABASE sql_test; use sql_test; CREATE TABLE `user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT '', `age` INT(11) DEFAULT '0', PRIMARY KEY(`id`) )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; INSERT INTO user (name , age) VALUES ('张三', '18'), ('李四', '28'), ('翠花', '38'); select * from user; 在工作目录建立go工程，同时使用go mod进行初始化
mkdir go-sql-database-example # you can name the module according to your directory go mod init github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa43336be819b1d52e061fb645721d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f57a00bb297c1dae8f3969315907ab/" rel="bookmark">
			HTTPS加密以及认证手段以及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS SSL即安全套接字层，SSL 在1999年被IETF(互联网工程组)更名为TLS，即传输安全层，直到现在，TLS 一共出现过三个版本，1.1、 1.2 和1.3，目前最广泛使用的是1.2，所以接下来的探讨都是基于TLS 1.2的版本上的。
TLS用于两个通信应用程序之间提供保密性和数据完整性。
TLS由 记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。
ECDHE - ECDSA-AES256-GCM- SHA384
因为TLS的密码套件规范，基本格式就是
密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法组成的一个密码串
有时候还有分组模式
TLS在根本上使用对称加密和非对称加密两种形式。
对称加密（AES） 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。
所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。
因此加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。
在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。
对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。如果一方的秘钥被泄露，那么加密信息也就不安全了。
另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的独一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
非对称加密（RSA） 1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。
与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。
公开密钥与私有密钥是一对，
如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；
如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
密码体制的安全性依赖于密钥的安全性，现代密码学不追求加密算法的保密性，而是追求加密算法的完备，即：使攻击者在不知道密钥的情况下，没有办法从算法找到突破口。
根据加解密算法所使用的密钥是否相同，或能否由加(解)密密钥简单地求得解(加)密密钥。密码体制可分为对称密码体制和非对称密码体制。
非对称密码体制也叫公钥加密技术，该技术是针对私钥密码体制(对称加密算法)的缺陷被提出来的。
与对称密码体制不同，公钥加密系统中，加密和解密是相对独立的，加密和解密会使用两把不同的密钥，加密密钥(公开密钥)向公众公开，谁都可以使用，解密密钥(秘密密钥)只有解密人自己知道，非法使用者根据公开的加密密钥无法推算出解密密钥，这样就大大加强了信息保护的力度。
公钥密码体制不仅解决了密钥分配的问题，它还为签名和认证提供了手段。
非对称密码算法有很多，其中比较典型的是RSA算法，它的数学原理是大素数的分解。
工作过程 1、乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。
2、得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。
3、乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。
在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。
同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。
分析 非对称加密算法在使用时需要同时拥有公开密钥和私有密钥，公开密钥与私有密钥相对应，如果在对数据的加密过程中使用了公开密钥，那么只有使用相对应的私有密钥才能解密；
反之，如果在对数据进行加密时使用了私有密钥，也只有使用与之相对应的公开密钥才能解密。
非对称加密算法对传信息进行加密的基本过程是：
甲方首先生成一对密钥同时将其中的一把作为公开密钥；得到公开密钥的乙方再使用该密钥对需要加密的信息进行加密后再发送给甲方；甲方再使用另一把对应的私有密钥对加密后的信息进行解密，这样就实现了机密数据传输。 与上面的工作过程同理。
非对称加密算法的另一种加密过程是：
甲方使用自己的私有密钥对信息进行加密后再发送给乙方；乙方使用甲方提供的公开密钥对加密后的信息进行解密；如果成功解密即可证实信息确实是由甲方所发，并非他人冒充，这就是常用的数字签名技术。 优缺点 非对称加密算法的特点是算法强度复杂，其安全性依赖于算法与密钥。由于其算法复杂，而使得加密解密的速度远远低于对称加密算法，因此不适用于数据量较大的情况。
由于非对称加密算法有两种密钥，其中一个是公开的，所以在密钥传输上不存在安全性问题，使得其在传输加密数据的安全性上又高于对称加密算法。
常用算法 RSA：RSA 是一种目前应用非常广泛、历史也比较悠久的非对称秘钥加密技术，在1977年被麻省理工学院的罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）三位科学家提出，由于难于破解，RSA 是目前应用最广泛的数字加密和签名技术，比如国内的支付宝就是通过RSA算法来进行签名验证。它的安全程度取决于秘钥的长度，目前主流可选秘钥长度为 1024位、2048位、4096位等，理论上秘钥越长越难于破解，按照维基百科上的说法，小于等于256位的秘钥，在一台个人电脑上花几个小时就能被破解，512位的秘钥和768位的秘钥也分别在1999年和2009年被成功破解，虽然目前还没有公开资料证实有人能够成功破解1024位的秘钥，但显然距离这个节点也并不遥远，所以目前业界推荐使用 2048 位或以上的秘钥，不过目前看 2048 位的秘钥已经足够安全了，支付宝的官方文档上推荐也是2048位，当然更长的秘钥更安全，但也意味着会产生更大的性能开销。DSA：既 Digital Signature Algorithm，数字签名算法，他是由美国国家标准与技术研究所（NIST）与1991年提出。和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。ECDSA：Elliptic Curve Digital Signature Algorithm，椭圆曲线签名算法，是ECC（Elliptic curve cryptography，椭圆曲线密码学）和 DSA 的结合，椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的，相比于RSA算法，ECC 可以使用更小的秘钥，更高的效率，提供更高的安全保障，据称256位的ECC秘钥的安全性等同于3072位的RSA秘钥，和普通DSA相比，ECDSA在计算秘钥的过程中，部分因子使用了椭圆曲线算法。 混合加密 机密性 RSA的运算速度非常慢，而AES的加密速度比较快，而TLS正是使用了这种混合加密方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f57a00bb297c1dae8f3969315907ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4557d3578983455aba3e220abc4500a3/" rel="bookmark">
			CODESYS SoftMotion（二）单轴运动实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CODESYS SoftMotion编程实例 所有关于SoftMotion都会放在特定位置，可以参考学习，我自己的路径是：D:\CODESYS16\CODESYS\Projects\SoftMotion\4.6.3.0\Examples\Tutorial
3.1 单轴运动 功能块需要：使能功能块MC_Power、绝对运动功能块MC_MoveAbsolute。下面是编程步骤（极其繁琐）
Ctrl+N 新建一个工程：
因为我的设备是树莓派单核，所以选择CODESYS Control for Raspberry pi SL（...）：
左侧的设备栏如下图所示：
找到SoftMotion General Axis Pool，右键添加设备，选择虚拟驱动器，将这个设备重命名为drive：
重命名不能用F2，只能按照以下操作：
配置好了之后就可以编写程序了：点击文件PLC_PRG，将变量区声明内容写成如下：
PROGRAM PLC_PRG VAR iStatus:INT; Power:MC_Power;//功能块MC_Power声明 MoveAbsolute:MC_MoveAbsolute;//绝对运动功能块MC_MoveAbsolute声明 p:REAL:=1000;//变量p,运动位置 END_VAR 代码区写入：
CASE iStatus OF 0: Power(Enable:=TRUE,bRegulatorOn:=TRUE,bDriveStart:=TRUE,Axis:=Drive); IF Power.Status THEN istatus:=istatus+1; END_IF 1: MOVEAbsolute(Execute:=TRUE,Position:=p,Velocity:=100,Acceleration:=100,Deceleration:=100,Axis:=Drive); IF MoveAbsolute.Done THEN MOVEAbsolute(Execute:=FALSE,Axis:=Drive); istatus:=istatus+1; END_IF 2: MOVEAbsolute(Execute:=TRUE,Position:=0,Velocity:=100,Acceleration:=100,Deceleration:=100,Axis:=Drive); IF MoveAbsolute.Done THEN MOVEAbsolute(Execute:=FALSE,Axis:=Drive); iStatus:=1; END_IF END_CASE 连接我们的树莓派（一系列折腾）点击编译F11编译，确定没有问题之后登录（登录之后就能看到"PLC"状态了）：
启动：
点击Dirve设备，也就是我们刚刚创建出来的虚拟驱动器。
非常好可以看到我们轴确实按照我们预想往复运动：
再通过向Application添加一个监控功能来观察：
右上角点击配置，选中我们的任务MainTask
添加一个变量：
在track图表内点击下载跟踪：
可以看到跟踪内容：
你可以根据你的需要添加多个跟踪变量的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e50c44a8842490a1a9440896b2085b/" rel="bookmark">
			题目20：流水线工作最长时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目20：流水线工作最长时间 一个工厂有m条流水线
来并行完成n个独立的作业
该工厂设置了一个调度系统
在安排作业时，总是优先执行处理时间最短的作业
现给定流水线个数m
需要完成的作业数n
每个作业的处理时间分别为 t1,t2…tn
请你编程计算处理完所有作业的耗时为多少
当n&gt;m时 首先处理时间短的m个作业进入流水线
其他的等待
当某个作业完成时，
依次从剩余作业中取处理时间最短的
进入处理
输入描述：
第一行为两个整数(采取空格分隔)
分别表示流水线个数m和作业数n
第二行输入n个整数(采取空格分隔)
表示每个作业的处理时长 t1,t2…tn
0&lt;m,n&lt;100
0&lt;t1,t2…tn&lt;100
输出描述
输出处理完所有作业的总时长
案例
输入
3 5
8 4 3 2 10
输出
13
说明
先安排时间为2,3,4的三个作业
第一条流水线先完成作业
调度剩余时间最短的作业8
第二条流水线完成作业
调度剩余时间最短的作业10
总共耗时 就是二条流水线完成作业时间13(3+10)
3 9
1 1 1 2 3 4 6 7 8
private static void work() { Scanner scanner = new Scanner(System.in); String[] split = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e50c44a8842490a1a9440896b2085b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7167df0c1aca756452a405f2fd5b73a2/" rel="bookmark">
			安卓数据存储的5种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SharedPreferences： ①使用键值对的方式进行数据存储（以xml文件形式存储到手机中）
②常用与保存用户设置，如CheckBox选择状态、配置信息等
注：
①commit发生在UI主线程，apply发生在工作线程，线程可能不安全
②key和value不应太大
文件存储： 直接将所需要保存的内容写到手机文件中
手机内部、外部存储选择：
①数据私有-&gt;内部存储
②数据不大+访问频繁-&gt;内部存储
③数据较大-&gt;外部存储
④数据随应用卸载而删除-&gt;storage/sdcard/Android/data/package/files/xxx
⑤数据不随应用卸载删除-&gt;storage/sdcard/xxx/xxx
（④⑤所保存的数据不是应用私有的）
Sqlite数据库： 嵌入安卓的轻型数据库，可以直接用SQL语言，保存结构性数据（如客户信息、联系人信息）
ContentProvider： 通过Uri进行数据获取
可访问不同应用的数据库表数据
网络存储 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36d1c5aa6ef5c4a331831ccdad4e6ea/" rel="bookmark">
			Apache 服务器负载低访问慢的原因分析和优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		米扑博客采用的Apache服务器，搭建在阿里云上，最近总是出现访问慢，甚至无法访问。
重启Apache服务后，才可以正常访问，初步原因是米扑博客的访客增量过多，百度、谷歌、Bing等爬虫抓取压力过大。
统计访客IP和PV数量，发现跟平时差不多，甚至还略低（米扑博客服务器无法访问，造成访客访问不了），服务器应该不至于响应这么慢，从而需要针对这个问题进行分析，来解决网站访问过慢。
原因分析
1、发现网站访问变慢，使用 top 命令查看了服务器的负载情况，发现负载并不高，初步判断不是程序的问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 top - 13:20:06 up 2:22, 3 users, load average: 1.08, 1.43, 1.27 Tasks: 137 total, 1 running, 134 sleeping, 0 stopped, 2 zombie Cpu(s): 47.7%us, 2.0%sy, 0.0%ni, 50.3%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 1920944k total, 1738316k used, 182628k free, 38040k buffers Swap: 4095984k total, 11892k used, 4084092k free, 264372k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3393 mysql 20 0 1455m 833m 6972 S 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36d1c5aa6ef5c4a331831ccdad4e6ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f338604a781df9e4f191b1586b4ecc/" rel="bookmark">
			乐鑫Esp32学习之旅30 对接华为IoT物联网平台适配踩坑，使用ESP-IDF 编程使用HTTPS请求固件跳过证书校验，实现OTA远程升级文件。（附带源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列博客学习由非官方人员 半颗心脏 潜心所力所写，仅仅做个人技术交流分享，不做任何商业用途。如有不对之处，请留言，本人及时更改。 系列一：ESP32系列模组基础学习系列笔记
1、 爬坑学习新旅程，虚拟机搭建esp32开发环境，打印 “Hellow World”。
2、 巧用eclipes编辑器，官方教程在在Windows下搭建esp32开发环境，打印 “Hellow World”。
3、 认识基本esp32的GPIO接口，开始点亮您的第一盏 LED和中断回调实现按键功能 。
4、体会esp32的强大的定时器功能， 实现定时2s闪烁一盏LED灯。
5、接触实践esp32的pwm宽度脉冲功能， 实现呼吸效果闪烁一盏LED灯。
6、smartConfig和微信airKiss在esp32的实现，一键配网轻松快捷连接路由器。
7、利用GPIO中断做一个按键的短按和长按的回调事件，再也无须担心触发源。
8、esp32上实现本地 UDP 客户端和服务端角色，在局域网内实现通讯。
9、esp32上实现本地 TCP 客户端和服务端角色，可断线重连原路返回数据。
10、乐鑫esp32 SDK编程利用rmt驱动ws2812七彩灯，实现彩虹渐变效果。
11、入门 乐鑫esp-adf 音频框架开发，esp32造一个蓝牙耳机，实现切换歌曲，获取歌曲信息等功能。
12、开源一个微信公众号airkiss配网esp32以及局域网发现功能的工程，分享一个airkiss配网小工具。
13、esp32 内置 dns 服务器，无需外网访问域名返回指定网页。
14、esp32 sdk编程实现门户强制认证，连接esp32热点之后，自动强制弹出指定的登录界面。
15、认识本地离线语音唤醒识别框架 esp-skainet ，实现较低成本的硬件语音本地识别控制。
16、学习本地语音唤醒离线识别框架 esp-skainet ，如何修改唤醒词? 如何自定义命令词？如何做意图动作？
17、全网首发，乐鑫esp32 sdk直连京东微联·小京鱼 · IoT开放平台，实现叮咚音响语音智能控制。
18、入门京东微联·小京鱼的控制面板H5开发，读懂vue语法，做自己的控制页面。
19、重磅开源，如何在微信小程序上ble蓝牙配网esp32，blufi的那些事！
20、一篇好文，开发过程中编译esp32固件太大，无法正常启动？教你如何自定义分区表partitions.csv。
21、 esp32蓝牙配网blufi的高度封装，集成简单、使用简单、容易上手，提高开发效率！
22、讨论下程序员 “青春饭” 那些事，分享在esp32实现多种加密算法md5 |AES CBC-ECB| Sha1 | Sha256 等！
23、安信可 esp32-a1s 音频开发板移植最新 esp-adf 音频框架，小试牛刀如何实现在线文字转语音播放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f338604a781df9e4f191b1586b4ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08277ee342922652c390f3d716566401/" rel="bookmark">
			throw 和 throws 有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不同点：
一：位置不同。throws用在函数上，后边跟的是异常类，可以跟多个异常类。throw用在函数内，后面跟的是异常对象。
二：功能不同。①throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先得处理方式。throw抛出具体的问题对象，执行到throw。功能就已经结束了跳转到调用者，并将具体的问题对象抛给调用者，也就是说throw语句独立存在时，下面不要定义其他语句，因为执行不到。②throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常对象。
相同点：
两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
package com.apesource.exception; import java.io.IOException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.sql.SQLException; public class Demo01 { public static void main(String[] args) throws IOException, NullPointerException, SQLException, NoSuchAlgorithmException { dosth1(); dosth2(); SecureRandom.getInstanceStrong(); } // 定义方法时，throws声明该方法可能抛出的异常类型 // 抛出的异常类型，RuntimeException类或其子类，则该方法调用时，异常可以不处理 public static void dosth1() throws NullPointerException,SQLException{} // 抛出的异常类型，如果不是RuntimeException类或其子类，则该方法调用时，异常必须处理， public static void dosth2() throws IOException,StringIndexOutOfBoundsException{} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41c85b04717bb0d6b4a933eff09b5f3/" rel="bookmark">
			序列化Serializable和Parcelable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化介绍： 序列化：将对象转换为字节序列
反序列化：将字节序列恢复为对象
序列化使用场景：
①将内存中对象状态保存到文件或数据库中（如Session）
②使用套接字在网络传送对象
③用RMI传输对象
Java实现序列化：
引用Serializable接口，产生序列号UID即可
序列号作用：
涉及Java区分类：①用类名②相同类名用序列号
如果不写对应序列号，在更改类内容后执行序列化和反序列化，更改前后两个类的序列号不同，但实际是同一个类导致识别失败，会产生错误。
S与P两个序列化接口区别： Serializable：
Java自带
Parcelable：
Android专用，S是将对象序列化，而P是将一个完整对象分解，将每一部分都变为可被intent传输的数据类型
两者选择：
内存中传输对象用Parcelable：性能高，产生临时变量少，每一部分都可以用intent传输
持久化用Serializable：Serializable占用的存储空间较少，由于序列号的原因也不会由于类的改变而影响反序列过程。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/251/">«</a>
	<span class="pagination__item pagination__item--current">252/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/253/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>