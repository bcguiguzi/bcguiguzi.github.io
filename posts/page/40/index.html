<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3fc4ffae392e09013a43d7c3bc6bea/" rel="bookmark">
			【视觉三维重建】【论文笔记】Deblurring 3D Gaussian Splatting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去模糊的3D高斯泼溅，看Demo比3D高斯更加精细，对场景物体细节的还原度更高，[官网]（https://benhenryl.github.io/Deblurring-3D-Gaussian-Splatting/）
背景技术 Volumetric rendering-based nerual fields：NeRF.
Rasterization rendering: 3D-GS.
Rasterization比volumetric方法更加高效。
摘要 一种新的field-based的网络模型，实现对最新的rasterization rendering技术——3D高斯泼溅的去模糊。
设计MLP，对各个3D高斯的协方差建模；既能重建出优异、锐利的细节，又能保证实时渲染。
方法 一个MLP处理3D高斯模型，其输入包含视线方向向量 v v v，模型的位置 x x x、姿态 r r r、尺度系数 s s s，输出偏置量 δ r \delta r δr， δ s \delta s δs，在训练时加入此MLP，实现模型变换，再渲染；推理时则直接渲染。如下图。
MLP输出的系数对应各个3D高斯，则能控制不同的3D高斯产生不同程度的模糊，即实现选择性模糊图像不同区域，不同程度；一个高斯卷积无法实现此种能力的。
问题的假设、解决方法的原理 原作者从模糊是由于理想图像的高斯卷积之结论，提出如下假设，
We assume that big sized 3D Gaussians cause the blur, while relatively smaller 3D Gaussians correspond
to the sharp image.
又根据
The minima of these scaling factors (δr, δs) are clipped to 1 and element-wisely
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3fc4ffae392e09013a43d7c3bc6bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f458c46cf289a21108ff6afe6571831e/" rel="bookmark">
			计算机网络 基础知识 套接字 编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，端口号拼接到IP地址，即构成了套接字（Socket）。在网络中采用发送方和接收方的套接字来识别断电。套接字，实际上是一个通信端点，即：
套接字=IP地址：端口号
她唯一的标识网络中的一台主机上的一个应用进程。
在网络通信中，主机A发送给主机B的报文，包含目的端口号和源端口号，源端口号是“返回地址”的一部分，即当主机B需要发回一个报文给主机A的时候，主机B到主机A的报文中的目的端口号便是主机A到主机B的报文中的源端口号（完全的返回地址是主机A的IP地址和源端口号）。
无连接服务与面向连接服务
TCP/IP协议族在IP层之上，使用了两个传输协议，一个是面向连接的传输控制协议（TCP），采用TCP的时候，传输层向上提供的是一条全双工的可靠逻辑信道，另一个是无连接的用户数据报协议（UDP），采用UDP的时候，传输层向上提供的是一条不可靠的逻辑信道。
TCP提供面向连接的可靠服务，通信双方在传送数据之前必须先建立连接，然后基于此链接进行可靠的数据传输，数据传输结束后要释放连接。TCP不提供广播或者多播服务，TCP为了实现可靠的数据传输，必须要增加许多的举措，比如确认、流量控制、计时器以及连接管理等。这不仅对事的协议数据单元的首部增大很多，还要占用需要的处理机资源。因此TCP主要适用于可靠性更重要的场合，如文件传输协议（FTP）、超文本传输协议（HTTP）、远程登录（HELNET）等。
UDP提供无连接的不可靠服务，通信双方在传送数据之前不需要建立连接，接收方的传输在收到UDP用户数据报后，无需给发送方发回任何确认。UDP在IP层之上进提供两个附加服务；多路复用和对数据的错误检查，IP层知道，怎么把分组投递给一台主机，但是不知掉怎么把她们投递给主机上的具体应用。UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。因为UDP比较简单，所以执行速度比较快、实时性好，使用UDP地应用主要包括小文件传送协议（TFTP），DNS，SNMP和实时传输协议（RTP）。
通信子网，包括，1，物理层，2，数据链路层，3，网络层，主要负责数据通信，资源子网是OSI参考模型的上三层，传输层的主要任务是向高层用户屏蔽下面通信子网的细节（如，网络拓扑，路由拓扑等）。
OSI参考模型中，提供端到端的透明数据传输服务，差错控制和流量控制的层是传输层。
传输层为进程之间提供逻辑通信。
关于传输层的面向连接服务的特性是，保证可靠和顺序交付。
UDP数据报，UDP尽在IP层的数据报服务至上增加了两个最基本的功能，复用和分用，以及差错检测。
如果应用开发者，选择UDP而非TCP，则应用程序几乎直接与IP打交道。
UDP协议的特点：
1，UDP无虚建立连接，因此UDP不会引入建立连接的时延。
2，无连接状态，TCP需要在端系统中维护连接状态，次连接状态包括接受和发送缓存，拥塞控制参数和序号与确认好的参数。而UDP，既不维护连接状态，也不跟踪这些参数。因此，当某些专用服务器使用UDP地时候，一般都能支持更多的活动客户机。
3，UDP地首部开销小，
4，UDP没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率，某些实时应用要求源主机以稳定的速率发送数据，能容忍一些数据的丢失，但不允许有太大的时间延迟。
5，UDP支持，一对一，一对多，多对一，多对多的交互通信。
UDP经常用于一次性传输较少数据的网络应用，如DNS，SNMP等，因为对于这些应用，如果采用TCP，则将为连接创建，维护和拆除带来不小的开销。UDP页经常用于多媒体应用，如IP电话，实时视频会议，流媒体等等。显然，可靠的数据传输对于这些应用来说并不是最重要的，但是TCP的拥塞控制会导致数据出现较大的延迟，这是他们不可容忍的。
UDP不保证可靠交付，但是这并不意味着应用对于淑静的要求是不可靠的，所有维护可靠性的工作都可以由用户在应用层完成。应用开发者，可以根据应用的需求来灵活的设计自己的可靠性机制。
UDP是面向报文的，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，记不合并，也不拆分，而是保留这些报文的边界。接收方UDP对IP层交上来UDP数据报，在去除首部后就原封不动的交付给上层应用进程一次交付一个完整的报文。因此，报文是不可分割的，是UDP数据报处理的最小单位。因此，应用程序，必须选择合适大小的报文，如果报文太长，UDP把他交给IP层后，可能会导致分片。如果报文太短的话，UDP把他交给IP层后，会是的IP数据包的首部的相对长度太大，两者都会降低IP层的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d152d85f5729733e9f5382a1b6418e3/" rel="bookmark">
			MySQL作业一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1．掌握修改表结构的方法；
增加列 alter table 表名 add 列名 列类型
alter table 表名 add 列名 列类型 after 列名
修改列类型 alter table 表名 modify 列名 新类型
修改列 alter table 表名 change 列名 新字段名 字段选项 ;
调整列位置 alter table 表名 change 列名 新列名 字段选项 after字段名
删除列 alter table 表名 drop column 字段名
2．插入记录；
insert into 表名 values
二、实验内容
1．创建数据库（自己命名），使用以下代码创建表格yg
DROP TABLE IF EXISTS yg;
CREATE TABLE yg(
编号 char(6) NOT NULL primary key,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d152d85f5729733e9f5382a1b6418e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14146ca3ab8fbe4d95a67f0260a4937/" rel="bookmark">
			计算机网络—VLAN 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.拓扑图
2.实验环境准备
2.关闭不相关接口，并配置 Trunk
3.创建 VLAN
4.为客户端配置 IP地址
5.检测设备连通性，验证 VLAN 配置结果
6.配置 Hybrid 端口
7.配置文件
1.拓扑图 2.实验环境准备 在S1和S2上创建Eth-Trunk 1并配置该Eth-Trunk为静态LACP模式。然后 将G0/0/9和G0/0/10接口加入Eth-Trunk 1。
&lt;Quidway&gt;system-view [Quidway]sysname S1 [S1]interface Eth-trunk 1 [S1-Eth-Trunk1]mode lacp [S1-Eth-Trunk1]quit [S1]interface GigabitEthernet0/0/9 [S1-GigabitEthernet0/0/9]eth-trunk 1 [S1-GigabitEthernet0/0/9]interface GigabitEthernet0/0/10 [S1-GigabitEthernet0/0/10]eth-trunk 1 &lt;Quidway&gt;system-view [Quidway]sysname S2 [S2]interface eth-trunk 1 [S2-Eth-Trunk1]mode lacp [S2-Eth-Trunk1]trunkport GigabitEthernet 0/0/9 [S2-Eth-Trunk1]trunkport GigabitEthernet 0/0/10 2.关闭不相关接口，并配置 Trunk 为了确保测试结果的准确性，需要关闭S3上的E0/0/1和E0/0/7端口以及S4 上的E0/0/1和E0/0/14端口。
&lt;Quidway&gt;system-view Enter system view, return user view with Ctrl+Z. [Quidway]sysname S3 [S3]interface GigabitEthernet 0/0/1 [S3-GigabitEthernet0/0/1]shutdown [S3-GigabitEthernet0/0/1]quit [S3]interface GigabitEthernet 0/0/7 [S3-GigabitEthernet0/0/7]shutdown &lt;Quidway&gt;system-view Enter system view, return user view with Ctrl+Z.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b14146ca3ab8fbe4d95a67f0260a4937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a15c3aa237da30bb05653c7f00d052/" rel="bookmark">
			解决：chrome无痕模式下找不到插件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如需在 Chrome 浏览器或 ChromeOS 设备上以无痕模式使用扩展程序，请执行以下操作：
在新的无痕式窗口中，打开 chrome://extensions。找到要在无痕模式下使用的扩展程序。点击详情。开启在无痕模式下启用。 此时打开无痕模式，就能看到插件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b930a869224c93de9f1fa4e46fd2e92/" rel="bookmark">
			鸿蒙ArkTS语言快速入门-TS（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TS入门学习第三篇 TS入门学习第三篇函数普通函数定义类型的函数未定义类型的函数可选参数和默认参数剩余参数箭头函数this函数重载 TS入门学习第三篇 函数 和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。
普通函数 // Named function 有名函数 function add(x, y) { return x + y; } // Anonymous function 匿名函数 let myAdd = function(x, y) { return x + y; }; 定义类型的函数 // 有名函数：给变量设置为number类型 function add(x: number, y: number): number { return x + y; } // 匿名函数：给变量设置为number类型 let myAdd = function (x: number, y: number): number { return x + y; }; 完整的类型函数是这样的
let myAdd: (x:number, y:number) =&gt; number = function(x: number, y: number): number { return x + y; }; 未定义类型的函数 // 给函数类型设置为any类型，为任意类型 function add(x: number, y: number): any{ return x + y; } 可选参数和默认参数 JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b930a869224c93de9f1fa4e46fd2e92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4978509d05deff33983e5720701f2e3c/" rel="bookmark">
			Intel@cpu产品参数和命名@单核睿频和全核睿频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 选择合适的cpuintel cpu型号和命名小结 cpu排行时钟速度@睿频单核睿频和全核睿频网络上流传的方法 在线查询 产品比较跑分比较 选择合适的cpu 如何选择游戏 CPU - 英特尔 (intel.cn)在决定购买具体的产品之前,建议广泛地查阅用户对它的评价以及是否有哪些因素是不满足需要的,以减少不必要的麻烦这里仅讨论cpu,而不讨论其他部分,其他部分对于一台计算机也是重要的 intel cpu型号和命名 新产品:英特尔® 处理器名称、编号和代次列表 (intel.cn)
Intel® Processor Names, Numbers and Generation List 传统产品:英特尔® 游戏处理器和名称说明 (intel.cn)
Intel® Processors for Gaming and Names ExplanationCPU型号解读：教你CPU型号后缀怎么看？CPU型号后面的字母和数字区别是什么？ (zhihu.com) 小结 以下后缀通常表示 CPU 应考虑用于游戏目的：
S 或无后缀
无后缀或后缀为 S 的 CPU 属于 S 系列。这些处理器专为台式机而设计，可为各种预算和需求提供多种选择。H
后缀为 H 的 CPU 属于 H 系列，这是一系列功能强大的移动处理器5，适用于笔记本电脑游戏6。K
K 后缀表示允许超频的未锁频台式机处理器，而 “HK” 后缀 (H+K) 表示允许超频的未锁频高功率笔记本电脑处理器。 超频使您能够通过调整关键干值来实现超出规格的 CPU 性能2。F
后缀 F 表示 CPU 没有集成显卡。它们必须搭配独立显卡。G
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4978509d05deff33983e5720701f2e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2e6b613b5af8b3c9d3f492196b3e6c/" rel="bookmark">
			【Python】一文详细介绍plt.rcParams 在 Matplotlib 中的原理、作用、注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】一文详细介绍plt.rcParams 在 Matplotlib 中的原理、作用、注意事项
🌈 个人主页：高斯小哥
🔥 高质量专栏：Matplotlib之旅：零基础精通数据可视化、Python基础【高质量合集】、PyTorch零基础入门教程👈 希望得到您的订阅和支持~
💡 创作高质量博文(平均质量分92+)，分享更多关于深度学习、PyTorch、Python领域的优质内容！（希望得到您的关注~）
🌵文章目录🌵 🎨 一、plt.rcParams 的原理📝 二、plt.rcParams 的作用🔍 三、plt.rcParams 的注意事项💡 四、plt.rcParams 的高级用法💻 五、plt.rcParams 的代码示例🎨 六、plt.rcParams 的进一步定制🤝 七、期待与你共同进步🔍 关键词 🎨 一、plt.rcParams 的原理 在 Matplotlib 这个强大的 Python 数据可视化库中，plt.rcParams 是一个至关重要的配置工具，它允许我们自定义图形的各种属性，从而轻松打造出符合个人或项目需求的图表样式。plt.rcParams 实际上是一个字典对象，它存储了 Matplotlib 的所有默认配置参数。通过修改这个字典中的键值对，我们可以 全局地 改变 Matplotlib 的默认行为。
举个例子，如果你希望默认的图形尺寸是 10x8 英寸，而不是 Matplotlib 的默认尺寸，你可以通过以下方式设置：
import matplotlib.pyplot as plt plt.rcParams['figure.figsize'] = (10.0, 8.0) 之后，你创建的每一个图形都会默认使用这个尺寸，除非你显式地改变它。
📝 二、plt.rcParams 的作用 plt.rcParams 的作用主要体现在以下几个方面：
全局样式统一：通过 plt.rcParams，我们可以确保整个项目或应用中所有图形的样式统一，从而增强图表的可读性和美观性。
个性化定制：Matplotlib 提供了大量的配置选项，通过 plt.rcParams，我们可以根据自己的喜好或项目的需求，定制出个性化的图表样式。
动态调整：plt.rcParams 可以在脚本的任意位置进行修改，这意味着我们可以在运行时动态地调整图形的样式，以适应不同的场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2e6b613b5af8b3c9d3f492196b3e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eab3bfab24f1d233ef98ab9204adcba/" rel="bookmark">
			导出微软浏览器收藏的网页，并查看网页保存的登录密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出微软Edge浏览器收藏夹（书签）的步骤如下：
打开Microsoft Edge浏览器。右键点击浏览器收藏栏上的任意位置或使用快捷键Ctrl + Shift + O打开收藏夹管理页面。在收藏夹管理页面中，通常你会看到右上角或菜单区域有一个“…”或者三个点的更多选项按钮。点击这个“…”按钮，从下拉菜单中选择“导出收藏夹”选项。浏览器将会生成一个HTML文件，保存了你的所有书签，你可以指定位置保存这个文件，以便在其他浏览器或设备上导入。 对于查看或导出Edge浏览器保存的登录密码： 微软Edge浏览器本身并不直接提供导出保存的登录密码的功能。但用户可以通过以下方式访问和管理密码：
在Edge浏览器中，点击右上角的个人资料图片或菜单图标，进入设置和更多选项。选择“设置”，然后在设置菜单中找到“密码”或“密码和表单填充”选项。在此页面，你可以查看已保存的密码列表，但不能直接导出密码文本。若要迁移密码，可以考虑使用第三方工具或服务，或者在新的设备上登录同一微软账户以同步密码。 请注意，出于安全原因，浏览器一般不会允许用户直接导出明文密码，而是仅提供查看和管理功能。如果你需要在不同浏览器间迁移密码，建议使用各浏览器支持的同步功能，或手动重新输入并保存密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e364a6e3cd23a37e69700f8249f7300e/" rel="bookmark">
			云游戏发行是什么？云游戏发行的演进历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云游戏发行是一系列基于云游戏技术的游戏发行策略或行为，融合云试玩、云微端、可玩广告、跨端移植等技术，从而在传统游戏发行生态的基础上实现更为卓越的发行效果。
云游戏发行出现的原因
近年来，游戏市场出现负增长。其原因一方面在于游戏版号的逐渐减少，尤其是在21年7月至22年4月期间未发放任何游戏版号，使得许多游戏厂商不得不退出市场。同时，疫情“宅经济”效应减弱，实体经济复苏，短视频等新兴娱乐方式崭露头角，对游戏行业构成了巨大冲击。这种市场环境下，争夺有限资源的竞争日益激烈，投入与产出之间的比例迅速下降，迫切需要引入新的变革因素。
云游戏发行的崛起
在当前国内游戏市场，云游戏无疑是最为重要的变革因素之一。面对买量市场的竞争激烈和成本不断攀升的情况，云游戏以其“云发行”特性，为游戏发行商提供了一种降本增效的途径。尤其结合“内容营销”的兴起，云游戏有望降低游戏发行中的玩家转化门槛，提升游戏的投资回报率（ROI）。
云游戏发行的降本增效作用
在游戏发行过程中，广告获客一直是众多游戏企业的主要营销手段。然而，随着游戏朝着精品化方向发展，游戏包体不断增大，对设备性能的要求也越来越高，导致玩家下载游戏进行试玩的门槛相应提高。云游戏发行通过网页云试玩、下载云微端等手段，成功降低了玩家的转化门槛。
总而言之，云游戏发行的崛起在当前游戏行业带来了积极的变革。通过提供更为经济高效的发行途径，云游戏有望解决传统游戏发行面临的问题。未来，随着技术的不断进步，云游戏有望继续推动游戏产业的创新，为游戏发行商提供更多可能性。
如您对云游戏发行感兴趣，欢迎咨询Ogcloud，我们拥有强大技术支持，助您解决游戏发行中的各种难题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19032f6a882adcfa97a5b12e2e7be8f8/" rel="bookmark">
			QT中connect()的参数5：Qt::DirectConnection、Qt::QueuedConnection区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/Dasis/article/details/120916993
connect用于连接QT的信号和槽，在qt编程过程中不可或缺。它其实有第5个参数，只是一般使用默认值，在满足某些特殊需求的时候可能需要手动设置。
Qt::AutoConnection： 默认值，使用这个值则连接类型会 在信号发送时 自行决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。
Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。
Qt::QueuedConnection：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
Qt::UniqueConnection：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d09dae2b3f3af38842e794b3dde60a7/" rel="bookmark">
			VUE&#43;HBuilder的uniapp技术路线开发应用使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用总结 本来想做一个记录日常数据的应用，主要在Android端使用，后来发现在uniapp中使用sqllite数据库不是像原生中那样简单(所以当前准备去进行另一个路线，就是给我使用的电脑都安装一个portalble的服务端，用来记录数据，这样也不会占用手机的空间了)。当前的使用体验如下：考虑到兼容性问题，HBuilder比较适合写UI加服务端存储的项目（各种小程序，网页商城）（当然其他功能也可以进行uniapp的安卓原生插件开发或者与原生Android交互传递数据）Hbuilder编辑器在使用打包时要进行登录，手机绑定。使用中还出现了以下问题： 本地打包3.1.10版本起需要申请 Appkey。 基础 官方文档： https://uniapp.dcloud.net.cn/quickstart.html 重要组成说明注释vue的基础语法插值和数据绑定，条件与循环等重要App.vue应用入口文件,监听应用生命周期、配置全局样式、配置全局的存储globalData处理app启动，切换时的命令，可以不用管main.js/main.uts初始化vue实例、定义全局组件、使用需要的插件如 i18n、vueximport作用pages.json页面管理,pages数组中第一项表示应用启动页重要配置文件vue.config.js是一个可选的配置文件vite.config.js是一个可选的配置文件代码主要复用方式认识Vue 的 export、export default、import重要，例子各种控件比如label控件重要uni.scss整体控制应用的风格使用&lt;style lang="scss"&gt;存储uniapp本地kv存储：uni.getStorageSync父子组件props传递值例子Vue.mixin混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。提高复用性，在全局范围内共享代码uView组件库uni-app 分不清的全局变量this, uni, $u, vm, uni.$u, this.$u,API集中管理:uni.$u.api.this.$u.api.register(data)=&gt;http://192.168.0.30:8000/api/register状态管理Vuex状态管理模式this.$store.dispatch：调取store里的user.js的login方法插件快速实现各种功能时间格式化插件dayjs，Hbuilder使用tailwindcss 兼容性 比如文件系统 uni.getFileSystemManager()，app平台需要使用uni-app x支持，另见，但是uni-app x是用的uts语言(uni-app x 没有使用js和webview，它基于 uts 语言。在App端，uts在iOS编译为swift、在Android编译为kotlin，完全达到了原生应用的功能、性能。并且uni-app x不支持vue2，新基座名称默认为uni-app x（之前叫HBuilder）)。 例子 各端兼容问题，比如以下代码无法在安卓端运行 &lt;template&gt; &lt;view class="container"&gt; &lt;button @click="createAndWriteTxt"&gt;创建并写入txt文件&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { createAndWriteTxt() { // 创建文件内容 const content = "Hello, this is a txt file content."; // 创建Blob对象 const blob = new Blob([content], { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d09dae2b3f3af38842e794b3dde60a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25635121d189750f86c6b9907314fc9d/" rel="bookmark">
			计算机网络 传输层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据链路层提供链路上相邻结点之间的逻辑通信，网络层提供主机之间的逻辑通信。传输层位于网络层之上，应用层之下，他为运行在不同主机上的进程之间提供逻辑通信。传输层属于面向通信部分的最高层，同时也是用户功能的最底层。显然，即使网络层的协议不可靠，传输层同样能够为应用程序提供可靠的服务。
网络的边缘部分的两台主机使用网络的核心部分的功能进行端到端的通信的时候，只有主机的协议栈才有传输层，而路由器在乍富那分组的时候，都只用到了下层三层的功能，即，在通信子网中没有传输层，擦混熟层纸存在通信子网以外的主机中。传输层的功能如下。
1，应用进程之间的逻辑通信，
从网络层来说，通信的双方是两台主机，IP数据包的首部给出了两台主机的IP地址。但是两台主机之间的通信，实际上是两台主机中的应用进程之间的通信。应用进程之间的通信，又被称为端到端的逻辑通信。IP协议虽然能够吧分组送到目的主机，但是这个分组还停留在主机的网络层，而没有交付给主机中的进程。从传输层来看，通信的真正端点不是主机而是主机中的进程。
逻辑通信是指，对等层之间的通信好像是沿着水平方向传送的，但是两个对等层之间并没有一条水平方向的物理连接。
2，复用和分用，
复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据，分用食指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。
网络层也有复用和分用的功能，但网络层的复用是指发送方不同协议的数据都可以被封装成IP数据报发送出去，分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确的交付到目的应用进程。
3.检错检测，
传输层要对收到的报文（首部和数据部分）进行差错检测，对于TCP协议，如果接收方发现报文段出错，则要求发送方重新发送该报文段。
4.提供面向连接的和无连接的传输协议
传输层向高层用户屏蔽了底层网络核心的细节（如，网络拓扑，路由协议等），他使得应用进程看见的是在两个传输层实体之间好像有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却是因传输层协议不同而有很大的区别。当传输层采用面向连接的TCP协议的时候，尽管下面的网络时不可靠的（只提供尽最大努力的服务），但这种逻辑通信信道就相当于一套全双工的可靠信道。但，当传输层采用无连接的UDP协议的时候，这种逻辑通信信道仍然是一条不可靠信道。
而网络层无法同时实现两种协议，即在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式。
传输层的寻址和端口：端口的作用，
端口能够让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。端口在传输层的作用类似于IP地址在网络层的作用，只不过IP地址标识的是主机，而端口标识的是主机中的应用进程。
数据链路层的服务访问点为帧的“类型”字段，网络层的服务访问点为IP数据报的“协议”字段，传输层的服务访问点为”端口号“字段，应用层的服务访问点为“用户界面”。
在协议栈层面的抽象的协议端口是软件端口，他与路由器或者交换机上的硬件端口是完全不同的概念，硬件端口是不同的硬件设备进行交互的接口，而软件端口是应用层的各种协议进程域传输实体进行层间交互的一种地址。传输层使用的是软件端口。
端口号：
应用进程通过端口号进行识别，端口号长度为16比特。端口号只具有本地意义，即端口号纸标识本计算机应用层中的各个进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可以将端口分为两类：
1，服务器端使用的端口号。一种是，熟知端口号，熟知为0-1023，互联网地址指派机构将这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。另一类称为登记端口号，熟知为1024-49151，它是供没有熟知端口号的应用程序使用的，使用这类端口号都必须在IANA登记，以防止重复。
2，客户端使用的端口号，数值49151-65535，因为这列端口号尽在客户进程运行的时候才动态地选择，所以又称为短暂端口号。当服务器进程受到客户进程的报文的时候，就知道了客户进程所使用的端口号，因而可以吧数据发送给客户进程。通信结束后，刚用过的客户端口号就不复存在了，这个端口号就可以提供给其他的客户进程使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9eca197263dd00ab6188a2a51ae28b8/" rel="bookmark">
			回溯算法模板框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯算法框架 backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯算法demo window.onload = function () { console.log(111111) // n = 4; k = 2 let n = 4, k = 2 let result = [] let path = [] const combine = (n, k) =&gt; { result =[] combineHelper(n, k, 1) return result } const combineHelper = (n, k, startIndex) =&gt; { if (path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9eca197263dd00ab6188a2a51ae28b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7601b1a50c858f9b0c1f7be214d25a/" rel="bookmark">
			java jdbc mysql 8驱动,连接数据库 mysql serverTimezone 问题,时间少了8小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你发现时间正好少了8小时，不用问，肯定是时区设置有问题，找找在哪里设置下时区就好了。
遇到一个问题：Mysql驱动从5升级到8后，数据库链接配置了serverTimezone=UTC，导致数据库时间和Java时间相差8小时。
解决如下：
如果你设置serverTimezone=UTC，连接不报错，
但是我们在用java代码插入到数据库时间的时候却出现了问题。
比如在java代码里面插入的时间为：2018-06-24 17:29:56
但是在数据库里面显示的时间却为：2018-06-24 09:29:56
有了8个小时的时差
UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。
//北京时间==东八区时间！=北京当地时间
serverTimezone=GMT%2B8
//或者使用上海时间
serverTimezone=Asia/Shanghai
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9177f2265826962556330009888ad82/" rel="bookmark">
			HTML 学习笔记(十一)表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分块 1.单行文本框控件–文本框和密码框 文本框控件通过单标签input实现，其具有必要属性type来控制输入控件的类型(默认为text即文本信息)，密码框的type为password(口令)。
表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理，比如将表单信息提交到一个新的页面中。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;table&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=""&gt; 请输入用户名：&lt;input type="text"&gt; &lt;br&gt; 请输入密码：&lt;input type="password"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2.多行文本框控件(文本域控件) &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;table&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=""&gt; 请输入多行文本： &lt;-- 可以通过cols和rows属性控制文本框的大小 --&gt; &lt;textarea cols="50" rows="5"&gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 3.单选和多选 通过控制input标签中type的属性值来实现单选或多选
a.单选 1.单选框必须成组使用才有意义(每组数量大于等于2)
2.通过name属性来建立组，同名为一组
3.同组的单选框只能有一个处于被选中的状态
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9177f2265826962556330009888ad82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf8d97a6fe114fc751bbc99be4ee42d/" rel="bookmark">
			Python批量提取Word文档表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大数据处理与信息抽取领域中，Word文档是各类机构和个人普遍采用的一种信息存储格式，其中包含了大量的结构化和半结构化数据，如各类报告、调查问卷结果、项目计划等。这些文档中的表格往往承载了关键的数据信息，如统计数据、项目进度、研究成果等。然而，手动从大量的Word文档中逐一摘取并整理这些表格不仅耗时费力，且易出错，无法满足高效、准确的数据利用需求。因此，利用编程实现批量提取Word文档中的表格成为了一种必要且高效的解决方案。Python作为一种功能强大、易学易用的编程语言，可以有效地实现这一目标，极大地提升数据采集和预处理的工作效率，同时也为后续的数据分析和应用提供强有力的支持。本文将介绍如何使用Python实现对Word文档中表格的提取。
文章目录 提取Word文档表格并保存为Excel工作表提取Word文档表格并保存为CSV文件 本文所使用的方法需要用到Spire.Doc for Python，可从官网获取。如果是将表格保存到Excel工作表，则还需要用到Spire.XLS for Python。
提取Word文档表格并保存为Excel工作表 读取Word文档中的表格并写入Excel工作簿需要同时用到这两个库。以下是操作步骤：
创建 Document 和 Workbook 对象。使用 Document 类的 LoadFromFile() 方法载入指定路径下的 Word 文档。清除 Workbook 中的所有工作表。遍历加载的 Word 文档中的所有节（Sections）。在每个节中，遍历其包含的所有表格（Tables）。对于每一个表格，创建一个新的 Excel 工作表，并根据表格索引为其命名。遍历表格中的每一行（Rows），并获取当前行对象。再次遍历该行中的所有单元格（Cells），获取单元格对象。对于每个单元格，将其包含的段落内容合并为一个字符串（cellText）。使用 Workbook 的工作表对象的 SetCellValue() 方法将合并后的单元格文本内容写入到对应的工作表中。完成所有表格数据的写入后，使用 Workbook 的 SaveToFile() 方法将 Excel 数据保存到指定路径。 代码示例：
from spire.doc import * from spire.doc.common import * from spire.xls import * from spire.xls.common import * # 创建Document对象 doc = Document() # 载入Word文档 doc.LoadFromFile("示例.docx") # 创建Workbook对象 wb = Workbook() wb.Worksheets.Clear() # 遍历文档中的节 for i in range(doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf8d97a6fe114fc751bbc99be4ee42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00cf052fd44e912f96cc12a48d700b6/" rel="bookmark">
			手机和电脑同步的好用记事本软件有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我常常需要随手记录各种信息，以便随时查阅和使用。比如，在下班路上，我会用手机记录明天要处理的工作事项、购物清单，或是某个突然迸发的创意想法；而在办公室，我则需要在电脑上整理会议纪要、项目计划，或是编写日报。这种跨设备的记事需求让我深切感受到了一款能在手机和电脑之间无缝同步记事本内容的软件的重要性。
于是，我开始寻找一款能够满足我这种需求的记事本软件。那么，手机和电脑同步的好用记事本软件有哪些呢？在网上搜索和询问了不少同事后，我发现敬业签这款软件被广泛推荐。我决定尝试使用它，并很快发现这款记事本软件正是我所需要的。
它的内容自动上传到云端备份，支持在各种设备上使用，包括小米、荣耀等安卓手机，华为和苹果手机，以及Windows和Mac电脑。这样的多端同步功能极大地方便了我的日常使用，无论在哪个设备上记录的信息，都能够在另一个设备上实时查看并使用。
除了跨设备同步的便捷性，它的记录功能也让我印象深刻。我根据不同的内容创建多个记事分类和待办分类，每条记事本中不仅可以记录文字、统计字数、修改字体颜色，还可以上传图片、音频、视频、文档等多种格式的内容，让我可以以更加便捷的方式记录更多的信息。
对于待办事项、日程、计划等，我可以在待办分类中逐条记录下来。并且它的智能系统会根据记录的时间信息，自动设置相应年月日、时分的定时提醒。这样的设计有效避免了我忘记重要事项的尴尬，确保了我的工作和生活都能够井井有条。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591ab71a483692a68ead29eeb418c060/" rel="bookmark">
			spring boot 访问 static public 目录下的静态资源报404解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前提是你没有修改spring boot 默认拦截路径，跟默认访问资源的目录。
在idea 设置中 把 compiler 下的 Buid project automatically 勾选上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4525e10c3d808f07ece37469cabce1fb/" rel="bookmark">
			解决pandas使用sqlalchemy保存到Mysql数据库时，bool布尔类型数据转为tinyint数据的读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas在使用to_sql()保存数据到数据表中，Mysql会将bool类型的数据转为tinyint类型，比如：
此时数据表字段的类型为：
读取的时候，如果直接使用read_sql会原封不动的读取成1或0的数据，因此我们存储的时候没有办法将true/false存储进数据库，只能在读取的时候使用：
data_df = pd.read_sql_query( text('select * from test_bool_data'), con=engine.connect(), dtype={ "bool_true": bool, "bool_false": bool, }) # 读取sql 这样就可以在读取出数据之后，将指定的这两列bool_true与bool_false转为bool布尔类型的数据
示例程序 import pandas as pd import numpy as np from sqlalchemy import create_engine, text def get_engine(): mysql_config = { "db": "just_test", "host": "127.0.0.1", "user": "XXXX", "password": "XXXX", "port": 3306, } engine = create_engine( "mysql+pymysql://{}:{}@{}:{}/{}".format(mysql_config['user'], mysql_config['password'], mysql_config['host'], mysql_config['port'], mysql_config['db'])) return engine def save_sql(): engine = get_engine() # 保存dataframe tmp_df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4525e10c3d808f07ece37469cabce1fb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/41/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>