<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ff8076dab5d65ff7caf92fa9570d73/" rel="bookmark">
			python PIL和CV对 图片的读取，显示，裁剪，拉伸，保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIL 图片操作
读取图片
img = Image.open("a.jpg") 显示图片
im.show() # im是Image对象，im是numpy类型，通过Image.fromarray(nparr, mode='RGB')函数转换为Image对象 图片的size
(width, height) = img.size 图片的模式
mode = img.mode 裁剪
img_c = img.crop(x1,y1,x2,y2) 拉伸图片
img = img.resize((size,size), Image.ANTIALIAS) 保存图片
img.save(path) ImageDraw
imDrwa = ImageDraw.Draw(img) # boxes = [[10, 20, 129, 255],[126, 0, 221, 164]] imDrwa.rectangle((x1, y1, x2, y2), outline="red") # 画矩形 r = 2 x1 = 100 y1 = 100 imDrwa.ellipse((x1-r, y1-r, x1+r, y1+r), fill=(255,0,255)) # 画椭圆，r固定为圆 img.show() 图片过大加载，opencv加载30M+报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ff8076dab5d65ff7caf92fa9570d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396a561e13f90a191d5801e5a306e298/" rel="bookmark">
			小程序——Taro集成dva状态管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是DvaJs？ dva 首先是一个基于 redux 和 redux-saga 的数据流方案，还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。
如果你在使用Taro时，用的React语法，那么dva可能是你最好的选择；如果你使用的Vue，那么Vuex就是你的不二选择。
【DvaJs传送门】
二、安装dva 在Taro集成dva时，我们需要安装dva-core和dva-loading
yarn add dva-core dva-loading // 或者 npm install dva-core dva-loading --svae 三、如何配置 新建src/utils/dva.js
import { create } from "dva-core"; import createLoading from "dva-loading"; let app = { dispatch: null, }; let store; let dispatch; function createApp(opt) { app = create(opt); app.use(createLoading({})); if (!global.registered) { opt.models.forEach((model) =&gt; app.model(model)); } global.registered = true; app.start(); store = app._store; app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396a561e13f90a191d5801e5a306e298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a68b1afcf147f09b0bb86a878a4afd4/" rel="bookmark">
			（每日一练c&#43;&#43;）字符串相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串相乘 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = "2", num2 = "3" 输出: "6" 示例 2:
输入: num1 = "123", num2 = "456" 输出: "56088" 说明：
num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 以下程序实现了这一功能：
#include &lt;bits/stdc++.h&gt; using namespace std; class Solution { public: string multiply(string num1, string num2) { string res(num1.length() + num2.length(), '0'); for (int i = num2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a68b1afcf147f09b0bb86a878a4afd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21743a20aa5e95ce4e51881af8ca495a/" rel="bookmark">
			在一台服务器上用一个域名部署多个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一台服务器上用一个域名部署多个项目 写在前面 当你学一个新的技术的时候一直听别人讲，是学不会的。
一定要每学一个东西就自己去动手做点什么。脑子里有一个自己的想法，然后不停的去百度，你在解决这个问题的时候，碰踩过的坑，遇到和遇到的过程都会让你对这个知识本身理解的更加透彻。
所以一篇厉害的小作文并不能教会你什么，他只是告诉你一个方向，至于最后能不能做出来是需要你自己去不断尝试的。写好项目只有一个方法，多动手多百度。
如果对项目换自己域名不熟悉的同学可以参考：
如何在nginx里面配置自己的域名 - AcWing
大佬空间：
个人空间 - AcWing
在此感谢先行者们的分享，能让我们站在巨人的肩膀上更快的解决问题
需要准备的东西 硬件 云服务器一台域名一个(已经完成备案的) 软件 dockernginx 最好全程在root用户下完成
下载docker y总讲过，这里不写
下载nginx 为了加速下载，还可以配置阿里云容器镜像加速，方法：自己百度
apt-get update apt-get install nginx 为什么要用nginx 是因为你购买域名之后，会发现：DNS无法解析 IP地址加端口号这一格式的地址。
计算机或者服务器的每一个服务或者进程都是对应一个端口号的。我们在一个服务器想部署多个项目，**本质上就是把不同的服务运行在不同的端口，然后用域名的不同二级域名去解析每一个项目。**但是DNS无法直接做到这一点，那么就需要一个，帮你把不同网址发来的请求去转发到不同端口上的一层代理。他就是nginx
其实nginx的主要作用是把实现负载均衡把一个项目分布到不同服务器上，来降低服务器的负载压力。这里用它来部署多个项目，其实是杀鸡用牛刀。
用nginx部署y总项目前的一个天坑 这个坑当时困扰了我好几周，大家一定要认真阅读
首先nginx是默认运行在80端口的。
但是回想y总的容器会发现，y总把80端口映射在了80端口，443端口，443端口映射在了443端口，那么会导致一个问题，如果你想在你服务器上配置一个nginx那么80端口已经被y总容器内的nginx占用。你在你的服务器上nginx就无法运行。
解决方法1 当然我一开始没有想到一个好的解决办法，只能退而求其次。就是将y总容器内部的nginx作为控制所有项目的大脑。即用容器内部的去转发所有的请求,配置你服务器上的多个项目。
但这又带来了一个新的问题，就是其他项目的容器和y总项目的容器耦合性太高。一旦y总项目的容器重启或者停止，那么y总容器里的nginx服务也停止，这样你的其他的所有项目就都无法正确解析。
本来这个问题就这样以一个将就的方式解决了。但是在之前的课设中，我需要同时展示y总的项目和我的Java项目和docker的作用，这就要求我必须将所有项目的容器解耦，于是我再次直面了这个问题。在看完的b站3个nginx的教程，和大量百度后。我开始研究如何改动y总项目内部nginx的配置文件
解决方法二：将所有nginx配置写在一个nginx中 这个方法也比较合理，但坏处就是你需要对每个项目的nginx配置文件进行大修改，同时项目也不方便迁移
解决方法3：两层nginx代理 实际上，每一个项目都有自己独立的nginx配置，想要做到真正解耦，方法3显然是更合理的
改造y总容器 如果对项目换自己域名不熟悉的同学可以参考：
如何在nginx里面配置自己的域名 - AcWing
大佬空间：
个人空间 - AcWing
在此感谢先行者们的分享，能让我们站在巨人的肩膀上更快的解决问题
下面所有操作建议在服务器的root用户下运行
1.解除容器对80端口的占用 因为nginx是默认运行在80端口，不同的两个nginx服务不能同时监听80端口。所以要将容器内的nginx的80端口映射到主机的其他端口上。443端口同理。因为这里我并没有准备给所有的项目配置SSL。所以我只解除了80端口的占用，没有改443的。
docker不删除容器改端口号的方法 先用docker ps -a查看并记住你要改容器的id
停止docker服务
systemctl stop docker 编辑/var/lib/docker/containers/容器id/hostconfig.json，在里面就能修改端口映射
这里的容器id就是以你第一步记住的id开头的一个长字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21743a20aa5e95ce4e51881af8ca495a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9807e75e47e1fddec21a835e48956c01/" rel="bookmark">
			前端练习-CSS布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端练习-CSS布局 文章目录 前端练习-CSS布局在线练习一、盒模型CSS1 盒模型 - content-boxCSS2 盒模型 - border-boxCSS3 盒模型- 外边距折叠 二、浮动CSS4 浮动CSS5 浮动 - 清除 三、定位CSS7 定位 - inheritCSS8 定位 - absoluteCSS9 定位 - absolute - 评注CSS10 定位 - z-indexCSS11 定位 - relativeCSS12 定位 - fixedCSS13 定位 - fixed - 广告 四、displayCSS14 display - flexCSS15 display - flex - 可伸缩项属性CSS16 display - flex - 标签CSS17 display - flex - orderCSS18 display - gridCSS19 display - grid - 区域 五、单列布局CSS20 单列布局 六、双列布局CSS21 双列布局 - 浮动CSS22 双列布局 - 绝对定位CSS23 双列布局 - flexCSS24 双列布局 - grid 七、三列布局CSS25 三列布局 - 浮动CSS26 三列布局 - 绝对定位CSS27 三列布局 - flexCSS28 三列布局 - gridCSS29 三列布局 - 圣杯布局CSS30 三列布局 - 双飞翼布局 在线练习 一、盒模型 CSS1 盒模型 - content-box CSS2 盒模型 - border-box CSS3 盒模型- 外边距折叠 二、浮动 CSS4 浮动 CSS5 浮动 - 清除 三、定位 绝对定位：absolute 和 fixed 统称为绝对定位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9807e75e47e1fddec21a835e48956c01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c23ffa50ae39d1cfedf1f19fd45f81/" rel="bookmark">
			半监督学习(Semi-Supervised Learning, SSL)-简述及论文整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考An Overview of Deep Semi-Supervised Learning，An overview of proxy-label approaches for semi-supervised learning文中相关概念补充及论文的阅读笔记将进行持续编写 机器学习主要有三种类型: 有监督, 无监督和半监督学习.
有监督学习的目标是通过训练一个函数 f f f 来预测数据的标签, 更具体地说, 给定一个包含 l l l 个标记的训练集 L d \mathbf{L}_d Ld​ = { ( x 1 , y 1 ) , ( x 2 ， y 2 ) , … , ( x l , y l ) } \{(x_1,y_1) ,(x_2，y_2) ,\dots,(x_l,y_l)\} {(x1​,y1​),(x2​，y2​),…,(xl​,yl​)}, 其中 x i ∈ R n x_i \in \mathbf{R}^n xi​∈Rn, i = 1 , 2 , … , l i = 1,2,\dots,l i=1,2,…,l, 训练旨在预测数据 x x x 上的标签 y y y 的函数 f f f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c23ffa50ae39d1cfedf1f19fd45f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887d9a91aa220c1c30a760f45460ccc5/" rel="bookmark">
			高防IP是什么？有什么作用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近不少来咨询的客户都问什么是高防IP，客户接入这个高防IP的话需要做些什么准备，今天就给大家科普一下什么是高防IP，他的原理是什么，客户接入需要做些什么？
高防IP是指高防机房所提供的IP段，主要是针对网络中的DDOS攻击进行保护。在网络世界中，IP就相当于服务器的门牌号，无论是访问还是管理服务器，都是通过IP来进行。同理，如果一个网络攻击者想对目标进行DDOS攻击，都需要知道目标的IP地址，并用大量的无效流量数据对该IP的服务器进行请求,导致服务器的资源被大量占用，无法对正确的请求作出响应。同时，这些大量的无效数据还会占用该IP所在服务器的带宽资源，造成信息的堵塞。
高防IP的原理：
用户购买高防IP，把域名解析到高防IP上（web业务只要把域名指向高防IP即可，非web业务，把业务IP换成高防IP即可）。同时在高防IP上设置转发规则，所有公网流量都会走高防IP，通过端口协议转发的方式，将用户的访问通过高防IP转发到源站IP。
在这一过程中，将恶意攻击流量在高防IP上进行清洗过滤后，把正常访问流量返回给源站IP，确保源站IP能正常稳定访问的安全防护。
通常在租用服务器后，服务商会提供一个IP给用户用于防御和管理。如果IP出现异常流量，机房中的硬件防火墙，就会对恶意流量进行识别，并进行过滤和清洗，帮助用户防御恶意流量。
在IP防御不了的情况下，会暂时对该IP进行屏蔽，这时会造成服务器不能正常访问，业务无法正常开展。
高防ip的作用
高防IP是针对互联网服务器在遭受大流量的DDOS攻击后导致服务不可用的情况下，推出的付费增值服务，用户可以通过配置高防IP，将攻击流量引流到高防IP，确保源站的稳定可靠。（无需转移数据，任何主机都可以使用高防IP来防护DDOS攻击。
对接高防IP的流程，用户需要准备什么？
首先你得更换一条干净的源IP，为什么要更换干净的源IP，首先你的服务器是被攻击过的，高防IP的原理是将你的源IP隐藏起来，用高防IP去抗，如果源IP暴漏 黑客可以直接绕过我们的高防IP去攻击你的源服务器，更换源IP后在解析到高防IP上即可享受真正的高防对接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833be67a86c159aa971f1baba6f89b43/" rel="bookmark">
			HTML translate 属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 标准规定，默认情况下，所有 HTML 元素都处于启用翻译的状态，这意味着它们的文本内容和一些属性(包括 alt 和 placeholder)在页面本地化时将被翻译。通过将 translate 属性设置为 no，网页可以将特定 HTML 元素的这种状态更改为 no-translate。
WHATWG 博客写道：默认情况下，所有内容都可以翻译。您可以通过将 translate 属性设置为 "no" 值来覆盖它。这可用于名称、计算机代码、仅在给定语言中有意义的表达式等。
translate="no" 属性指示在线翻译服务以网页的原始语言保留单词或短语。例如，在一个用德语编写的网页上，句子 “Mein Kampf wurde 1923 veröffentlicht” 被谷歌翻译成 “我的战斗发表于 1923 年”。在这种情况下，将书名包含在 translate="no" 元素中将产生最佳翻译(“Mein Kampf 于 1923 年出版”)：
&lt;p&gt; &lt;em translate="no" class="notranslate"&gt;Mein Kampf&lt;/em&gt; wurde 1923 veröffentlicht. &lt;/p&gt; W3C 使用 HTML 的 translate 属性指南提供了多个使用示例 ，如：
作品名称： &lt;p&gt; The question in the title &lt;cite translate="no"&gt;How Far Can You Go?&lt;/cite&gt; applies to… &lt;/p&gt; 虽然 Google 翻译可以识别 translate="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833be67a86c159aa971f1baba6f89b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50130bd29c44c8a61e7c7f024890ebdd/" rel="bookmark">
			C&#43;&#43; Inline关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原创文章，转载请注明出处。
C++ Inline记录 前言1&gt;inline 函数工作原理2&gt;inline 函数作用2.1&gt;消除函数调用的开销宏定义（define）和内联函数（inline）的区别1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 2.2&gt;去除函数只能定义一次的限制 3&gt;要注意的几点问：内联函数一定会被编译器在调用点展开吗？问：“调用”普通函数时，一定是调用吗？问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？ 前言 inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。
1&gt;inline 函数工作原理 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。
2&gt;inline 函数作用 2.1&gt;消除函数调用的开销 在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。
宏定义（define）和内联函数（inline）的区别 1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。 3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 2.2&gt;去除函数只能定义一次的限制 内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。
3&gt;要注意的几点 问：内联函数一定会被编译器在调用点展开吗？ 错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。
问：“调用”普通函数时，一定是调用吗？ 错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。
问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？ 错。
首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。
而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。
问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？ 因为 内联是以代码膨胀复制为代价 ，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码, 将使程序的总代码量增大，消耗更多的内存空间。
以下情况不宜使用内联：
1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
以下情况适宜使用内联
对于只有几条语句的小函数来说，与函数的调用、返回有关的准备和收尾工作的代码往往比函数体本身的代码要大得多。因此，对于这类简单的、使用频繁的小函数，将之说明为内联函数可提高运行效率。
谢谢，创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 &lt;(￣︶￣)&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6038a3295c98a5b8f5a55280c874ad23/" rel="bookmark">
			UE4 Shipping下打开系统窗口崩溃问题 附插件下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
Shipping下打开系统窗口崩溃问题 插件下载链接前言崩溃原因解决方案插件怎么用 插件下载链接 SelectDialog插件下载链接
前言 如果你遇到了正常开发(Debug/Develope)下调用打开系统窗口接口没问题，而Shipping下直接崩溃的话，不妨看看是不是一样的问题。
崩溃现象描述：调用FDesktopPlatformModule::Get()-&gt;OpenFileDialog来打开不同系统下的界面，比如要在运行时导入模型，导入图片视频音频等功能，你就会用到这个功能。
如下图，我要在程序中选择一个电脑上fbx格式模型导入进来。在dubug下正常，打出来的包确崩溃了。
怎么解决？什么原因呢？
你调用的代码应该是类似下面的（FDesktopPlatformModuleEx是我封装的一个shipping下用的插件。FDesktopPlatformModuleEx::Get()）
/* 打开系统文件夹路径 参数1:文件绝对路径 参数2:文件类型 TEXT("*.*")=全部 记录:	TEXT("FBX,JPG,BMP,PNG files|*.fbx;*.jpg;*.png;*.bmp"); TEXT("FBX Files|*.fbx"); TEXT("JPG,BMP,PNG files|*.jpg;*.png;*.bmp"); TEXT("(Image Files)|*.BMP;*.JPG;*.PNG;*.JPEG;)") */ UFUNCTION(BlueprintCallable, Category = "OpenWindowsFile") static TArray&lt;FString&gt; OpenWindowsFiles(const FString&amp; sTitle, const FString&amp; sYourFullPath, const FString&amp; sExtensionStr = TEXT("*.*")); TArray&lt;FString&gt; URegionRiskReadLibrary::OpenWindowsFiles(const FString&amp; sTitle, const FString&amp; sYourFullPath, const FString&amp; sExtensionStr) { //用户选择的文件列表 TArray&lt;FString&gt; OpenFileNames; IDesktopPlatform* DesktopPlatform = FDesktopPlatformModuleEx::Get(); if (DesktopPlatform) { void* ParentWindowHandle = GEngine-&gt;GameViewport-&gt;GetWindow()-&gt;GetNativeWindow()-&gt;GetOSWindowHandle(); DesktopPlatform-&gt;OpenFileDialog(ParentWindowHandle, sTitle, sYourFullPath, TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6038a3295c98a5b8f5a55280c874ad23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba91e749962cb28f8cf5ca55384eec80/" rel="bookmark">
			基础排序方法总结与C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础排序方法总结 基础排序方法与思路：
实现的排序方法代码：主要理解 归并排序的递归终止条件 和 快速排序的Partition的思路和终止条件（单纯遍历的话会有很多冗余情况）。
// MethodsOfSort.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。 // #include &lt;iostream&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const int numlength = 15; class MethodOfSort { friend void printArray(int* arr); public: void Swap(int* arr, int i, int j) { int temp; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } // 选择排序 void SelectionSort(int* arr) { for (int i = 0; i &lt; numlength; i++) { int min_num = arr[i]; int min_index = i; for (int j = i; j &lt; numlength; j++) { if (arr[j] &lt; min_num) { min_num = arr[j]; min_index = j; } } this-&gt;Swap(arr, i, min_index); } } // 冒泡排序 void BubbleSort(int* arr) { int max_num = arr[0]; int max_index = 0; for (int i = 0; i &lt; numlength; i++) { max_num = arr[0]; max_index = 0; for (int j = 0; j &lt; numlength - i; j++) { if (arr[j] &gt; max_num) { max_num = arr[j]; max_index = j; } } this-&gt;Swap(arr, max_index, numlength -1 - i); } } // 插入排序 void InsertSort(int* arr) { for (int i = 1; i &lt; numlength; i++) { for (int j = i; j &gt; 0; j--) { if (arr[j] &lt; arr[j - 1]) { this-&gt;Swap(arr, j, j - 1); } } } } // 归并排序 void MergeSort(int* arr, int L, int R) { if (L == R) { return; } int mid = L + ((R - L) &gt;&gt; 1); //改成 int mid = L + (R - L) &gt;&gt; 1; 不对，这样子的话是先计算L + (R - L) 再左移 this-&gt;MergeSort(arr, L, mid); this-&gt;MergeSort(arr, mid + 1, R); this-&gt;Merge(arr, L, mid, R); } void Merge(int* arr, int L, int mid, int R) { int len = R - L + 1; int* temp = new int[len]; // 在堆区开辟一个临时数组 int l = L;//左指针 int r = mid + 1;//右指针 int i = 0; // 左右指针都不越界时 while (l &lt;= mid &amp;&amp; r &lt;= R) { temp[i++] = arr[l] &lt; arr[r] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba91e749962cb28f8cf5ca55384eec80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d1c48d00a1d97c000c68b815ca677c/" rel="bookmark">
			ARIMA基本概念和流程讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 p: 自回归阶数
q: 滑动平均阶数
d: 时间序列成为平稳时所做的差分次数
AR - Auto Regression, 自回归模型：AR可以解决当前数据与后期数据之间的关系；表示为自回归模型 AR( p )
MA - Moving Average，移动平均模型：MA则可以解决随机变动也就是噪声的问题；表示为移动平均模型 MA(q)
ARMA - Auto Regression and Moving Average，自回归移动平均模型。自回归移动平均模型(ARMA)是与自回归(AR)和移动平均模型(MA)两部分组成；表示为ARMA(p, d)。(以上三类模型可以直接应用于平稳时间序列模型)
ARIMA - Auto Regression Integreate Moving Average，差分自回归移动平均模型。同前面的三种模型，ARIMA模型也是基于平稳的时间序列的或者差分化后是稳定的，另外前面的几种模型都可以看作ARIMA的某种特殊形式。表示为ARIMA(p, d, q)。(前面三种模型，d=0，即平稳时间序列模型不需要做差分)
ARIMA模型是在ARMA模型演变出来的，它实际上是先对数据做了差分，之后再使用ARMA模型；换句话说，ARIMA模型是先将非平稳数据变得平稳（用差分），之后再用ARMA模型处理平稳数据
基本流程 导入模型 import sys import os import warnings warnings.filterwarnings("ignore") import pandas as pd import numpy as np from arch.unitroot import ADF import matplotlib.pylab as plt %matplotlib inline from matplotlib.pylab import style style.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d1c48d00a1d97c000c68b815ca677c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe8d4a500e563159746b06109b7a631/" rel="bookmark">
			如何在Intellij IDEA中设置sout、psvm快捷键输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在Intellij IDEA中设置sout、psvm快捷键输入 1、打开IDEA主页面找到设置 2、单击设置进入设置页面依次点击如下选项 3、设置psvm快捷代码 4、返回主页面新建一个项目，输入psvm回车即可 5、sout快捷代码设置同上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f357cab93c73f0562eee272d1cbcc0/" rel="bookmark">
			关于去中心化技术实现的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈起去中心化，我们首先得知晓何谓中心化？所谓中心化就是一切以中央为转移。古代的皇权社会就是典型的中心化组织，天下以皇帝为权力中心，一切经济、文化、政治等天下大事都以皇帝为转移，才算合法合规，不然就是“忤逆王法”。“普天之下，莫非王土；率土之滨，莫非王臣”这句话就充分体现了皇权社会的本质其实就是通过中央集权来达到控制天下的手段，所有人都被人玩弄于股掌之中，而这个人就是皇帝。
当今的互联网巨头公司也是中心化的组织，如谷歌、阿里、亚马逊、腾讯，这些公司都是以中心服务器为服务节点，所有数据全部都要集中到中心服务器上进行集中处理，然后再向客户提供相应的服务。当他们的中心服务器一旦崩溃，那相应的子系统将全部瘫痪，随之而来的就是用户再也打不开对应的进程，直到服务器修缮后再次响应才会返回数据给用户。
去中心化是互联网发展过程中形成的社会化关系形态和内容产生形态，是相对于中心化而言的新型网络内容生产过程。去中心化是一种现象或结构，其只能出现在拥有众多用户或众多节点的系统中，每个用户都可连接并影响其他节点。通俗地讲，就是每个人都是中心，每个人都可以连接并影响其他节点，这种扁平化、开源化、平等化的现象或结构，称之为去中心化。
同时去中心化是区块链的典型特征之一，通过去中心化技术可以使每一笔交易都清晰可见。其使用分布式储存与算力，整个网络节点的权利与义务相同，系统中数据本质为全网节点共同维护，从而区块链不再依靠于中央处理节点，实现数据的分布式存储、记录与更新。而每个区块链都遵循统一规则，该规则基于密码算法而不是信用证书，且数据更新过程都需用户批准，由此奠定区块链不需要中介与信任机构背书。
那区块链又是什么呢？
举例来说，我们把一笔钱存到了银行，照理来讲，银行应该要好好保管我们的钱。但是银行常常把我们的钱，偷偷的借给别人，以赚取中间的投资报酬。比如建商，建商赚了钱之后，会以税收的方式把钱缴给了政府，再连本带利地把钱还给银行。请问这时候你的钱在哪里呢？有的人会说在银行里，但是如果我们现在就去银行请他打开金库的大门，我们会发现其实银行里面根本没有这么多的钱。这时候又会有人说在政府里，但是仔细想一想，政府根本没有钱。现在全世界的政府都在负债，就拿美国来说，截止7月22号，它的债务总额已高达28.5万亿美元，这说明美国财务部的资金链即将“断裂”，从而将会引发新一轮的金融危机。这时候有人就会想钱是被建商给赚走了吗？错，这时候你看见的不过是一些美丽的泡泡罢了，那些所谓的高房价其实都只是虚幻而已。
那钱到底去哪儿了呢？其实钱都到了资本的手中，因为资本才是这场闹剧的始作俑者。资本通过将自己的钱投资给建商产生信任背书，而建商去向银行借钱的时候，人家银行才会把钱借给建商。如果建商资不抵债，傻子也不会把钱借给他吧，更别提养着一大群人的银行了。这时候建商不过就只是负责基建的工具罢了。你们始终要记住一句话：“钱始终是向上流的”。
说那么多，到底什么是区块链呢？区块链其实就是通过区块链技术把这些迷雾给一层层拨开，这样你就永远知道自己的钱在哪里，并且怎么去的都一清二楚。在你眼里，你只是把一笔钱存到了银行，根本不会想这么多。但是你只要想明白这其中的逻辑，也就明白了什么去中心化技术实现的真正意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8368ef5bc784fce2c0d36ad708d7e96f/" rel="bookmark">
			vscode当前工作区不受信任，因此已禁用此扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openGL系列文章目录 文章目录 openGL系列文章目录前言一、解决步骤首先点击左边的“扩展”，或者使用快捷键： ctrl+shift+x2.添加插件信任选择扩展工作区信任 前言 在vscode中安装插件Shader languages support for VS Code，结果发现vscode提示：“当前工作区不受信任，因此已禁用此扩展”，该如何解决呢？
一、解决步骤 首先点击左边的“扩展”，或者使用快捷键： ctrl+shift+x 然后再tab中输入：Shader languages support for VS Code
2.添加插件信任 点击齿轮图标“管理”
选择扩展 选择“扩展设置”
工作区信任 点击工作区信任
效果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf173fb49f21a7725d581f1750b80d7f/" rel="bookmark">
			如何通过JS调用快递单号查询接口，完成物流轨迹查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有网友留言说，想调用快递鸟API接口实现快递查询，但是又不懂后端开发，不懂JAVA，不懂PHP，不懂C#，也不懂python，问我能不实现快递接口查询，我说你会什么，他说,我只懂一点点JS，
我回答他，已经足够了，我现在就来告诉你如何通过JS来实现1600多家的物流轨迹查询。
你只需要一步，新建一个Text文本，把下面这段代码复制进去，替换你自己的快递鸟ID和APIkey, 将txt后缀改成HTML，用浏览器预览就可以看到效果。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;JS调用快递鸟API接口&lt;/title&gt; &lt;meta charset="utf-8" /&gt; &lt;script src="/base64.js"&gt;&lt;/script&gt; &lt;script src="/md5.js"&gt;&lt;/script&gt; &lt;script src="/jquery.json-2.2.min.js"&gt;&lt;/script&gt; &lt;script src="/common.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function GetAPI() { var key="快递鸟API Key"; var id = "快递鸟注册ID号"; var requestData="{'OrderCode':'','ShipperCode':'ZTO','LogisticCode':'78120038107849'}"; //MD5加密 var md5str = md5(requestData + key).toLowerCase(); //base64 var dataSign = Base64.encode(md5str); //拼接字符串（快递鸟请求报文格式）url编码 var reqData = "RequestData=" + escape(requestData) + "&amp;EBusinessID=" + id + "&amp;RequestType=1002&amp;DataSign=" + escape(dataSign) + "&amp;DataType=2"; //reqData = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf173fb49f21a7725d581f1750b80d7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31e91e1db9dd0fc1f83938d606031a8/" rel="bookmark">
			vue3中的watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写watch函数需要编写两个参数,第一个是要监听的值,然后是一个回调函数。在函数中你可以获得到新知和老值。
使用watch的时候同样需要先导入
监听使用ref定义的变量的时候时候,第一个参数直接使用 import {... , watch} from "vue" setup() { const selectGirl = ref(""); const data = reactive({ girls: ["a", "b", "c"], selectGirlFun: (index) =&gt; { selectGirl.value = data.girls[index]; }, }); const refData = toRefs(data); watch(selectGirl,(newValue, old) =&gt; { console.log(1111,newValue,old) }); return { ...refData, selectGirl }; }, 使用reactive定义的变量需要没在监听的时候需要使用函数返回值的形式才能监听到 setup() { const data = reactive({ girls: ["a", "b", "c"], selectGirl: "", selectGirlFun: (index) =&gt; { data.selectGirl = data.girls[index]; }, }); const refData = toRefs(data); onRenderTriggered((event) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31e91e1db9dd0fc1f83938d606031a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8302e4b774cce667eb1c0f2c2fa262e0/" rel="bookmark">
			使用Backtrader对股票历史数据进行指标回测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次使用tushare接口，股票为600018，时间是20200101——20211231。
使用的指标是：收盘价大于简单移动平均价。
佣金为0.001。
英文代码的英文原文：Quickstart Guide - Backtrader 注意：代码最后plot画图，在spyder中不能正常显示图片，只能显示提示信息：
&lt;IPython.core.display.Javascript object&gt;
&lt;IPython.core.display.HTML object&gt;
在Jupyter Notebook中则可以正常显示图片。
期初资金: 100000.00
2020-02-26, Close, 11.20
2020-02-26, 买入单, 11.20
2020-02-27, 已买入, 价格: 11.20, 费用: 112.00, 佣金 0.11
2020-02-27, Close, 11.21
2020-02-28, Close, 10.85
2020-02-28, 卖出单, 10.85
2020-03-02, 已卖出, 价格: 10.95, 费用: 112.00, 佣金 0.11
2020-03-02, 交易利润, 毛利润 -2.50, 净利润 -2.72
2020-03-02, Close, 11.04
2020-03-03, Close, 11.06
......
2022-01-21, Close, 8.76
2022-01-24, Close, 8.69
2022-01-25, Close, 8.56
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8302e4b774cce667eb1c0f2c2fa262e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef1bdfb0cb04899ace2988f34eb4c8c/" rel="bookmark">
			OpenSSL中的EVP接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 摘要算法（Digest）获取EVP_MDDigest API例子 对称加密（Cipher）获取EVP_CIPHERCipher API上下文管理Encrypt APIDecrypt API加解密统一API其他设置 例子 非对称加密密钥管理公钥算法上下文 EVP_PKEY_CTX生成密钥密钥参数打印密钥的提取和指定密钥的保存和读取使用OSSL_ENCODER和OSSL_DECODER使用EVP_PKEY_todata和EVP_PKEY_fromdata 检测私钥是否正确 加解密签名和验签 摘要算法（Digest） EVP_MD结构保存了摘要算法的实现，相同的API，使用不同的EVP_MD，就可以实现不同的摘要算法。
获取EVP_MD 直接根据算法获取：
#include &lt;openssl/evp.h&gt; const EVP_MD *EVP_md2(void); const EVP_MD *EVP_md4(void); const EVP_MD *EVP_md5(void); const EVP_MD *EVP_md5_sha1(void); const EVP_MD *EVP_mdc2(void); const EVP_MD *EVP_ripemd160(void); const EVP_MD *EVP_sha1(void); const EVP_MD *EVP_sha224(void); const EVP_MD *EVP_sha256(void); const EVP_MD *EVP_sha512_224(void); const EVP_MD *EVP_sha512_256(void); const EVP_MD *EVP_sha384(void); const EVP_MD *EVP_sha512(void); const EVP_MD *EVP_sha3_224(void); const EVP_MD *EVP_sha3_256(void); const EVP_MD *EVP_sha3_384(void); const EVP_MD *EVP_sha3_512(void); const EVP_MD *EVP_shake128(void); const EVP_MD *EVP_shake256(void); const EVP_MD *EVP_sm3(void); const EVP_MD *EVP_whirlpool(void); 根据名字查找：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef1bdfb0cb04899ace2988f34eb4c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2fb915d04475e4b4db751d2b4cc4fd4/" rel="bookmark">
			MyISAM与InnoDB 数据结构的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/343746709
mysql底层的数据结构是B+树，但是同样是B+树，但是确实有很大的不同。
先说一下B树与B+数，如下图
B树
B+树
1、MyISAM存储引擎 MyISAM索引文件在数据库中存放的对应表的磁盘文件有*.frm，.MYD，.MYI结尾的三个文件；
frm文件是存放的表结构，表的定义信息；
MYD文件是存放着表中的数据；
MYI文件存放着表的索引信息；
MyISAM存储引擎的数据结构是B+树，其结构如下：（MyISAM存储引擎的主键索引跟非主键索引结构是一样的）
解释：
图中白色方块，存储的是指针信息，指向下一个叶节点索引位置。
图中黄绿色方块存储的是索引信息
图中蓝色表是数据信息
索引最底层的叶节点，存储的是索引信息（第一层）及数据指针信息，第二层的指针信息则分别指向数据表位置及相邻索引磁盘位置。
图中上面部分带有指针信息及索引信息的存储在MYI索引文件
图中右下角的表格是数据信息及表结构信息，是MYD数据文件及frm文件
2、InnoDB存储引擎 InnoDB索引文件在数据库中存放的对应表的磁盘文件有*.frm，*.ibd结尾的两个文件；
frm文件是存放的表结构，表的定义信息；
*.ibd文件是存放着表中的数据、索引信息；
InnoDB存储引擎的数据结构是B+树，结构如下：
注意：
1、MyISAM存储引擎的非主键索引与InnoDB存储引擎的非主键索引数据结构是一样的，但是最底层叶节点存储的数据和指针信息是不同的。
MyISAM存储引擎的非主键索引最底层叶节点存储的是索引信息及数据指向文件的指针信息。
InnoDB存储引擎的非主键索引最底层叶节点存储的是索引信息及指向主键索引的指针信息。
2、MyISAM存储引擎的数据文件跟索引文件是两个文件。InnoDB存储引擎的数据文件跟索引文件是一个文件。所以找到了主键索引位置也就找到了数据位置。所以InnoDB主键索引被称为聚合索引。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/265/">«</a>
	<span class="pagination__item pagination__item--current">266/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/267/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>