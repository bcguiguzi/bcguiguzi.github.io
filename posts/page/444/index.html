<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed6b87c78dda6043e058daab461c1a5/" rel="bookmark">
			怎么用Q-Q图验证数据集的分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		样本数据集在构建机器学习模型的过程中具有重要的作用，样本数据集包括训练集、验证集、测试集，其中训练集和验证集的作用是对学习模型进行参数择优，测试集是测试该模型的泛化能力。
正负样本数据集符合独立同分布是构建机器学习模型的前提，从概率角度分析，样本数据独立同分布是正负样本数据是从某一特定的数据分布随机抽取得到的，且正负样本的分布是不一样的。举例来说，若我们用非洲的西瓜作为训练集，然后用中国的西瓜作为测试集，则数据集可能不满足同分布这一前提；抛硬币是最简单的独立同分布；用较专业的学术用语来举例，若训练数据集符合正态分布，测试集符合均匀分布，那么数据集不满足独立同分布这一前提。
本文用Q-Q可以分析不同数据集是否为同一分布，且可以用Q-Q图来验证数据集是否符合正态分布。
一、累积分布函数与分位数
累计分布函数（CDF，Cumulative Distribution Function），顾名思义，是概率累计的过程。对某一变量X取值为x，则x的累计分布函数是所有小于x值的概率相加，公式如下：
分位数（quantile）的概念与累计分布函数类似，也是一种概率累计过程，如第一四分位数是累积分布概率达到0.25时所对应的变量值，第二四分位数是累计分布概率达到0.5时多对应的值，第三四分位数是累计分布概率达到0.75时对应的值，公式如下：
α代表累计概率，分位数为Zα：
P(X&lt;=Zα) = α ；
二、Q-Q图定义
Q-Q是一种散点图，横坐标为某一样本的分位数，纵坐标为另一样本的分位数，横坐标与纵坐标组成的散点图代表同一个累计概率所对应的分位数。若散点图在直线y=x附近分布，则这两个样本是同等分布；若横坐标样本为标准正态分布且散点图是在直线y=x附近分布，则纵坐标样本符合正态分布，且直线斜率代表样本标准差，截距代表样本均值。
如上图左上角图为某一数据的累计概率分布函数，右上角为标准正态分布的累计概率分布函数，对上述两图取同一个累计概率值对应的分位数，绘制散点图，由图可知，数据符合正态分布，斜率和截距分别代表数据的标准差和均值。
QQ图中正态分布直线的推导：
若数据x是正态分布的，那么f(x)是一个正态分布的概率密度函数，根据正态分布的特性，数据x对应的标准正态分布函数的概率密度函数：
y =f((x-m)/std)，其中m为样本均值，std为样本标准差
横坐标的数据分布是标准正态分布，概率密度函数为f(n)，由QQ图定义可知两者是一一对应的，因此有：
(x-m)/std = n ;
即：x = n*std + m；
所以直线的斜率代表标准差，截距代表均值。
三、构建普通QQ图
普通QQ图用于评估两个数据集的分布的相似程度，如上节所说的，若散点图在直线y=x附近，则两个数据集的分布类似。普通QQ图与正态QQ图的不同点在于普通QQ图的横坐标是未知数据集的分位数，正态QQ图的横坐标是标准正态分布的分位数，其他步骤都一样。
由上图可知，散点图没有接近一条直线，因此数据集1和数据集2来自不同的分布集。
上图是本人所从事项目数据的普通QQ图，散点图接近一条直线，因此可以认为数据集是来自同一分布。
参考：https://blog.csdn.net/hzwwpgmwy/article/details/79178485
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4730989ee254ad8ea6bdcc483dd2b8/" rel="bookmark">
			5.6.2 低通滤波器（理想低通&#43;巴特沃斯低通滤波器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.低通滤波器
低通滤波是将频域图像中的高频部分滤除而通过低频部分。图像的边缘和噪声对应于频域图像中的高频部分，而低通滤波的作用即是减弱这部分的能量，从而达到图像平滑去噪的目的。
2.理想低通滤波器
最简单的低通滤波器是理想低通滤波器，基本思想是给定一个频率阈值，将高于该阈值的所有部分设置为0，而低于该频率的部分保持不变。
理想是指该滤波器不能用电子元器件来实现，但是可以通过计算机来模拟。
在VTK中定义了理想低通滤波器，下面我们来看下怎么使用该滤波器来对图像进行低通滤波:
//理想低通滤波器 #include &lt;vtkSmartPointer.h&gt; #include &lt;vtkJPEGReader.h&gt; #include &lt;vtkImageFFT.h&gt; #include &lt;vtkImageIdealLowPass.h&gt; #include &lt;vtkImageData.h&gt; #include &lt;vtkImageRFFT.h&gt; #include &lt;vtkImageCast.h&gt; #include &lt;vtkImageExtractComponents.h&gt; #include &lt;vtkImageActor.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; int main() { vtkSmartPointer&lt;vtkJPEGReader&gt; reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New(); reader-&gt;SetFileName("data\\lena.jpg"); reader-&gt;Update(); vtkSmartPointer&lt;vtkImageFFT&gt; fftFilter = vtkSmartPointer&lt;vtkImageFFT&gt;::New(); fftFilter-&gt;SetInputConnection(reader-&gt;GetOutputPort()); fftFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageIdealLowPass&gt; lowPassFilter = vtkSmartPointer&lt;vtkImageIdealLowPass&gt;::New(); lowPassFilter-&gt;SetInputConnection(fftFilter-&gt;GetOutputPort()); lowPassFilter-&gt;SetXCutOff(0.05); //设置x\y方向上的截断频率 lowPassFilter-&gt;SetYCutOff(0.05); lowPassFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageRFFT&gt; rfftFilter = vtkSmartPointer&lt;vtkImageRFFT&gt;::New();//将处理后的频域图像转换至空域图像， rfftFilter-&gt;SetInputConnection(lowPassFilter-&gt;GetOutputPort()); //注意：转换后的图像每个像素值都是一个复数； rfftFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageExtractComponents&gt; ifftExtractReal = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::New(); ifftExtractReal-&gt;SetInputConnection(rfftFilter-&gt;GetOutputPort()); ifftExtractReal-&gt;SetComponents(0);//提取实部分量 vtkSmartPointer&lt;vtkImageCast&gt; castFilter = vtkSmartPointer&lt;vtkImageCast&gt;::New();//数据类型转换为unsigned char类型 castFilter-&gt;SetInputConnection(ifftExtractReal-&gt;GetOutputPort()); castFilter-&gt;SetOutputScalarTypeToUnsignedChar(); castFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageActor&gt; originalActor = vtkSmartPointer&lt;vtkImageActor&gt;::New(); originalActor-&gt;SetInputData(reader-&gt;GetOutput()); vtkSmartPointer&lt;vtkImageActor&gt; erodedActor = vtkSmartPointer&lt;vtkImageActor&gt;::New(); erodedActor-&gt;SetInputData(castFilter-&gt;GetOutput()); double leftViewport[4] = { 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4730989ee254ad8ea6bdcc483dd2b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9715fdc6decfe20ba4f4f8d93fbb2aea/" rel="bookmark">
			科技英语写作句型积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 句型尽量复杂
例句1：
The use of this method of control unquestionably leads to safer and faster train running in the most adverse weather conditions.The use of this method of control unquestionably leads to safer and faster train running in the most adverse weather conditions.
这种控制方法的使用无疑会使列车在最恶劣的天气条件下行驶更安全、更快。
The use of this method句型 值得学习。
例句2：
口语：
Whenever I’d visited there before, I’d ended up feeling that it would be futile if I tried to do anything more.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9715fdc6decfe20ba4f4f8d93fbb2aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c0005844bf4ee74b439dd046d8d29b/" rel="bookmark">
			OpenCV iOS 上颜色的坑 drawContours  等draw操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV iOS 上颜色的坑 drawContours 等draw操作 ios上相机画面draw的坑 ios上相机画面draw的坑 因为实验适配移动端，然后在ios相机获得的Mat上使用drawContours， 发现轮廓总是白的，原来自己定义的颜色有问题，ios相机获得了四通道画面。
我的color是
Scalar color = Scalar(rand()%255, rand()%255, rand()%255); 但是画出来无论是轮廓还是形状都是白的。
google了半天关于这方面的回答也不多。不过总算看到一个相近的回答指出了核心，那就是opencv iOS camera获得的为四通道图像，不能用三通道的标量颜色去搞，要换成四通道的，把alpha通道赋成不透明255。
因此代码变为
Scalar color = Scalar(rand()%255, rand()%255, rand()%255, 255); 这样以后画轮廓或形状就都有颜色了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7326ca4a95389f8dda8aa0c28bf6e00f/" rel="bookmark">
			《Word中批量去除多余空格、空行、换行》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们从pdf文件中复制文字时往往会出现有很多多余空格符、空行符、换行符号的情况：
下面记录一下在word中如何批量去除多余空格、空行、换行等符号：
1.去多余换行符：按下快捷键：Ctril+H，在查找内容中输入^p，点全部替换
效果如下：
2.去多余换空格：再次按下快捷键：Ctril+H，在查找内容中输入^w，点全部替换,效果如下:
3.去多余换空行：如果是多了一个空行
查找内容中输入^p ^p (之间没有空格哈)，替换为输入 ^p
4.去多余换手动换行符：若是很多手动换行符号，查找内容中输入^l。
这里列出常用的符号，在左下角的更多里面还有更多的符号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e988de0a13e1980b5828a8016f3a75a/" rel="bookmark">
			Windows常用网络操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Ping
当您的机器不能访问Internet，首先确认是否是本地局域网的故障。假定局域网的代理服务器IP地址为192.168.0.1，您可以使用ping 192.168.0.1命令查看本机是否和代理服务器联通。此外可以测试本机的网卡是否正常工作，使用
ping 127.0.0.1命令。一般返回ping的信息就表示本地到该主机的网络线路连通。
但是很多服务器为了防止攻击，一般会关闭对ping的响应。所以ping一般作为测试连通性使用。ping命令后，会接收到对方发送的回馈信息，其中记录着对方的IP地址和TTL。TTL是该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。例如IP包在服务器中发送前设置的TTL是128，你使用ping命令后，得到服务器反馈的信息，其中的TTL为127，说明途中一共经过了1道路由器的转发，每经过一个路由，TTL减1。
二、Tracert
Tracert命令用来显示数据包到达目标主机所经过的路径（路由器），并显示到达每个节点（路由器）的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。
Tracert 先发送 TTL 为 1 的回应数据包，当数据包上的 TTL在路由器收到后TTL自动减1 ，一旦某个服务器将TTL减1后，等于了0，路由器应该将“ICMP Time Exceeded”的消息发回源计算机，源计算机就根据收到的信息判断达到的路由器和所用时间。下次再次发送数据包时，将TTL递增 1，继续上述测试，直到目标响应或 TTL 达到最大值，从而确定路由。通过检查中间路由器发回的“ICMP 已超时”的消息确定路由。某些路由器不经询问直接丢弃 TTL过期的数据包，这在 Tracert
实用程序中看不到，我们会显示请求超时的请求信息。下图所示，我们测试到新浪的路径经过了7道路由，同时根据上图测试ping 新浪时候，TTL=57，说明新浪的TTL初始设置为64，经过7道路由后到达本机，还剩下64-7 = 57。下图中ping www.edu.cn请求超时的反馈信息是因为路由器或服务器对ping命令做了处理，禁用了ICMP功能，所以我们收不到发给www.edu.cn服务器的反馈信息。
三、pathping
pathping 命令是一个路由跟踪工具，它将 ping 和 tracert 命令的功能与这两个工具所不提供的其他信息结合起来，综合了二者的功能。pathping会先显示中间的通过的路由器（类似tracert命令得到的信息），然后对每个中间路由器（节点）发送一定数量的ping包，通过统计他们对ping包响应的数据包来分析通信质量。上面也提到了，有的路由器对ping关闭了响应，所以有的节点的丢包率会达到100%，所以这种一般就是关闭了ping回复。你可以自己ping试一下。还有，对ping包丢弃程度只是节点本身对ping的处理，并不一定影响他的通信，你可以看到，关闭ping命令节点的下一个节点返回到数据是正常的，说明回复的包都成功发送回来。总之，pathping 命令在一段时间内将数据包发送到将到达最终目标的路径上的每个路由器，然后根据从每个跃点返回的数据包计算结果。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接。下图所示，我们看到，达到第二个就终止了，因为第二道节点（路由器），不支持ping，然后，程序就终止不在继续往下探测了。
四、 nslookup
Nslookup命令用于解析域名，一般用来检测本机的DNS设置是否配置正确。如： nslookup 网站域名，即可解析出网站的IP地址。如图，可以看出解析www.163.com的时候，可以解析出它所有的IP地址，而如果网路出现异常或者无法收到服务器发送来的信息时候，会出现下面第二张图片的显示。服务器和Address代表是解析这些IP地址和域名的DNS服务器信息。比如我使用的DNS是jtjndc007.home.langchao.com，DNS服务器地址是10.100.1.11。
如果想测试使用另外一台DNS的解析功能，可以这样手工指定使用特定的DNS来解析我们的域名，下面我们就使用了114.114.114.114这台DNS来解析www.163.com：
五、nbtstat
该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。
-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。
-A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。
-n 列出本地机器的NETBIOS信息。
本机的机器名为hp-8570p，拥有多块网络适配器（网卡）：
当得到了对方的IP或者机器名的时候，就可以使用nbtstat命令来进一步得到对方的信息了，这又增加了我们入侵的保险系数。
在机器中有多块网卡的情况下，可以使用nbtstat来测试我们与服务器之间的通信是通过哪些网卡来进行数据转发的，如下面本机与172.18.4.40之间的通信就是通过“以太网 3”来进行通信的：
六、netstat
这是一个用来查看网络状态的命令，操作简便功能强大。
-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息。
这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。
-r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。
七、net
这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了，这简直就是微软为我们提供的最好的入侵工具。首先让我们来看一看它都有那些子命令，键入net /?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e988de0a13e1980b5828a8016f3a75a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f1610ed38a766e627fdd1f5ed581a1/" rel="bookmark">
			android Studio3.2 plugins为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C:\Users\Administrator\.AndroidStudio3.2\config\plugins中将里面全部文件清空，再重启就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e6a7c8d72a46aa87fda3cac030dd78/" rel="bookmark">
			markdown 各种符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/garfielder007/article/details/51646604
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30bcf2b6547179b79b41bab24016512/" rel="bookmark">
			嵌入式大牛详解：嵌入式linux开发流程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以说嵌入式linux是学习比较困难的，会遇到各种各样的问题，那么嵌入式linux学习有一个重要的点就是嵌入式linux开发的流程，这是必须要知道的，接下来我们就看看这方面的大牛总结的嵌入式linux开发流程及一些遇到的困难，解决方法。
嵌入式开发流程其实很简单，但是里面是有很多小的东西需要你注意的，这也是我这么多年来的一些经验，先说嵌入式linux开发流程：
一、建立开发环境，首先你必须要会安装配置嵌入式linux开发环境，这个是基本
操作系统当然是LInux，或者在win系统下安装虚拟机，通过网络下载相应的GCC交叉编译器进行安装，或者安装产品厂家提供的交叉编译器。
这一步，就相当于在win系统下，要安装一个IDE开发环境，如MDK，IAR等。在这一点上，我时常会因为这出现一些问题，就因为配置没配好，导致下面的步骤没法进行，报错，要切记这里需要你仔细点。
二、配置开发主机
主要是配置minicom，也就是串口助手，minicom软件是作为调试嵌入式开发板信息输出的监视器和键盘输入工具，是一个非常方便的工具，我们开发其他嵌入式程序时，其实很多时候也采用串口调试，所以最终原理都是相通的。
1、嵌入式linux开发流程
配置网络，主要是配置NFS网络文件系统，这个主要是用于下载程序，当然不配置也可以，有很多别的办法。
三、建立引导装在程序的bootloader
常用的bootloader主要有u-boot、vivi等，貌似主流的就是u-boot，这个根据自己具体的芯片进行移植修改。有些芯片是没有内置引导加载程序的，这就需要编写开发板上的Flash的少些程序，当然也可以用windows下的通过JTAG并口和仿真器少些Flash芯片程序，也有linux下的公开源代码的J-Flash程序，在自己做的时候，可以预留多重方式，这样是有用的。
简单的讲，其实就是要做好一个属于自己板子的u-boot，完成初始化，内核引导，下载、烧写等。其实在这一点上，也会是个难点，这里需要掌握的东西多，这一流程的烧写，内核引导，网络上有免费下载的Windows下通过JTAG并口简易仿真器烧写ARM外围Flash芯片的烧写程序，也有Linux下的公开源代码的J-Flash程序。如果不能烧写自己的开发板，就需要根据自己的具体电路进行源代码修改。这是系统正常运行的第一步。如果购买了厂家的仿真器当然比较容易烧写Flash，这对于需要迅速开发自己产品的人来说可以极大地提高开发速度，但是其中的核心技术是无法了解的。
再来就是嵌入式Linux操作系统移植了
1、嵌入式linux开发流程
如果有专门针对你使用的CPU的Linux再好不过，比如uCLinux、ARM-Linux、PPC-Linux等，如果没有，就要尝试移植专属自己的linux了，然后再添加自己特定硬件的驱动程序，进行调试修改，对于带MMU的CPU可以使用模块方式调试驱动，而对于uCLinux这样的系统则需要编译进内核，与内核为一体，再进行调试。最好的就是下载别人已经移植好的Linux操作系统来弄，这样会高效
2、接下来就是根文件系统了
前面的文章讲述过，没有根文件系统的Linux是无法正常工作的，还需要根文件系统。所以需要下载使用busybox软件来实现制作根文件系统。
再根据自己的应用需要来添加其他程序，默认的启动脚本一般都不会符合应用的需求(因为所有的嵌入式开发都是自由定制的)，所以就要修改根文件系统中的启动脚本，它的存放位置至于/etc目录下，包括：/etc/init.d/rc.S、/etc/profile、/etc/.profile等，自动挂载文件系统的配置文件/etc/fstab，其实就是定制自己要开机启动的程序，具体情况会随着系统的不同而不同，根文件系统在嵌入式系统中一般设为只读，需要使用mkcramfs、genromfs等工具产生少些映像文件。记得这一步要看好，别为了省时间写错。
弄好上面那么接下来就简单了就是建立应用程序的Flash磁盘分区
一般会使用jffs2或者YAFF文件系统，这需要在内核中提供这些文件系统的驱动，有的系统使用NOR FLASH，有的系统使用NAND FLASH，也有的系统两种flash都使用，到时候就看具体情况了。
3、开发应用程序
应用程序可以放到根文件系统中，也可以放到yaffs、jffs2文件系统中，有的应用不使用根文件系统，直接将应用程序和内核设计在一起，就是类似于uCOS-II的方式。
其实，上面的那些步骤也就是为了这一步，在这里你要注意他有三种呈现方式：
(1)直接讲应用程序和内核设计在一起，类似与uCOS-II的方式
(2)基于qt等GUI开发应用程序
(3)没有屏幕，只有简单的人机接口，比如串口，按键，数码管，这种也能实现复杂功能开发
现在就是对烧写内核、根文件系统、应用程序的加载了(其实差不多也就完了)
无论怎么加载，模块也好，所有的这些开发，过程资料，都是要烧写到flash中的，然后应用程序需要什么，就加载对应的功能程序即可。
4、发布产品
开发一款中高型的控制器设备，功能比较复杂，甚至需要复杂的屏幕交互，比如手机(安卓是linux的亲儿子，OS是linux的亲表弟)，取款机，服务器交易系统，那么linux就非常合适了。
开发一款小型控制器设备，如果功能不太复杂，可以使用稍微高级的CPU，裸机或者ucos等来开发，也很方便，也能做很多定制版的工业小型控制器。
嵌入式linux开发流程差不多就是这样了，在学习时一步一步来，就不会出错，大牛说的这些都学习到了吗，掌握这些方法，嵌入式linux开发流程就不是事儿。
转载于:https://blog.51cto.com/14033587/2313039
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f70f5b285d988449566379ec741cffe/" rel="bookmark">
			关于Qos中常用的CIR、PIR、CBS、PBS、EBS的解释以及用法关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CIR（Committed Information Rate，承诺信息速率）：
每秒可通过的速率，计量单位为Kbps (以bit 位为单位）。如设置为500Kbps 。每8bit位=1Byte 1Kbps=1024bit
PIR（Peak Information Rate，峰值信息速率）：
即允许传输或转发报文的最大速率；单位为bit
CBS（Committed Burst Size）：
承诺突发尺寸突发尺寸，令牌桶的容量，即每次突发所允许的最大的流量尺寸。设置的突发尺寸必须大于最大报文长度。计量单位为byte（字节）。
PBS（Peak Burst Size，峰值突发尺寸）：
EBS（Excess Burst Size，超出突发尺寸）：
即瞬间能够通过的超出突发流量。
PIR 和PBS是只有在交换机中才有的参数。
配置交换机限速时，cir和cbs的关系如下：
cbs要大于报文的最大长度。
在连续流量的情况下对于cbs没有特殊的要求，保证平均速率是cir的速率。
在突发流量需要保证的情况下，如果cbs换算成kbit小于cir，那么cbs也无法保证突发流量。否则cbs可以配置大一些。
在对FTP业务进行限速时，由于FTP属于TCP业务，TCP协议有其特殊的传输机制导致流量无法达到所应该达到的限速速率，推荐配置：
CBS = 200 * CIR
PBS = 2 * CBS
说明： 不配置PIR，只配置CIR、CBS、PBS。
CIR单位为Kbps，CBS、PBS单位为Byte。
例如： 配置CIR带宽为2M=2048Kbps，则：
CBS = 200 * CIR = 200 * 2048 = 409600
PBS = 2 * CBS = 2 * 409600 = 819200
配置如下：
[Quidway-behavior-b1] car cir 2048 pir 2048 cbs 409600 pbs 8192000 green pass remark-8021p 5 yellow pass red discard
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbfbbc173487236b00423ac3d2389caf/" rel="bookmark">
			2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) J - Straight Master (思维乱搞)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J. Straight Master
time limit per test
2.0 s
memory limit per test
256 MB
input
standard input
output
standard output
A straight is a poker hand containing five cards of sequential rank, not necessarily to be the same suit. For example, a hand containing 7 club, 6 spade, 5 spade, 4 heart and 3 diamond forms a straight. In this problem, we extend the definition of a straight to allow 3 to 5 cards of sequential rank.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbfbbc173487236b00423ac3d2389caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222b9a0323588e77fbdeb12253501751/" rel="bookmark">
			scipy.stats的用法——常见的分布和函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍python统计函数库scipy.stats中常见的分布和函数
#commom distributions: ''' uniform,norm,poisson,bernoulli,expon,lognorm norm,t,chi2,f ''' #commom function: ''' rvs产生服从制定分布的随机数 pdf概率密度函数 cdf累计分布函数 sf残存函数(1-cdf) ppf分位点函数（CDF的你函数） isf逆残存函数 fit对随机取样进行你和，最大似然估计找到的概率密度函数系数 ''' 产生随机数 #1. random number #np.random.normal(loc=0.0, scale=1.0, size=None) rv_unif = st.uniform.rvs(size=10) print(rv_unif) rv_norm=st.norm.rvs(loc = 5,scale = 1,size =(2,2)) print(rv_norm) rv_beta=st.beta.rvs(size=10,a=4,b=2) print(rv_beta) solve pdf（求概率密度函数） x=st.norm.pdf(0,loc=0,scale=1) y=st.norm.pdf(np.arange(3),loc=0,scale=1) print(x) print(y) solve cdf（求累计概率密度函数） a=st.norm.cdf(0,loc=0,scale=1) print(a) x=st.norm.cdf(1.65,loc=0,scale=1) y=st.norm.cdf(1.96,loc=0,scale=1) z=st.norm.cdf(2.58,loc=0,scale=1) print(x,y,z) solve ppf（求累计分布函数的逆函数，即分位点函数） inv_z05=st.norm.ppf(0.05) print(inv_z05) z05=st.norm.cdf(inv_z05) print(z05) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78302a962d52873b199c385117197ca1/" rel="bookmark">
			ICPC2018 青岛站 赛后总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10.2：起一大早打滴滴到东站坐动车到了青岛，青岛站离海真的好近，一下车就感觉空气里有一点咸咸的味道。发现第一天不能报道，于是去栈桥和八大关走了一波。在栈桥上看到一种快艇（还是游轮不太记得清了）体验项目，最便宜的800/位，最贵的4800/位。嗯，有钱真好。必须吐槽一下八大关的路，非常的不平，不是上坡就是下坡，走起来累到爆。里面老别墅好多，名人故居好多，还有特别好看的花石楼和公主楼，异域风情浓厚，走到最里面还有一片海，路上和小道上拍照的人也好多。
10.3：睡到接近中午跑到有油大学打算报道，刚进校门口碰上一个可爱的女装大佬，程序员穿女装谁都不输，哈哈。下午热身3道ZOJ原题，1道今年省赛热身赛题。快速秒掉两道水题，发现D不会做于是跟着全场的节奏大力猜C疯狂提交，360个队硬是把评测机交挂了两次，以至最后出题组都把C题删了，哈哈。
10.4：开赛前5分钟，拿到时限表，瞄了一眼发现好多题时限都是0.5s，当时心里就想0.5s的题应该都偏简单。开赛后我登完系统，榜单，打印，PC方，弄好编译器，选了一个0.5s的J题看了起来。没过几分钟队友ZQL扔给了我一个签到题M，码完代码提交获WA一个，于是仔细看了一下代码，发现有一个地方奇偶判错了，修改提交AC。我继续想J想出了一个二分，正打算码的时候发现二分不对于是退下。这时ZQL和说C的题意，我们讨论了一下，感觉C可以做，只要讨论一下连续不同的段数就可以，码完代码提交AC。我再次回去看J，发现J是一个贪心，于是赶紧码起代码，提交AC。此时比赛过了1个小时，我们rk20左右，在金牌区，我继续开题开了D，ZQL和CZQ开了F。起初D我无思路，于是和ZQL和CZQ一起看F，讨论了一会发现F可写，正确答案已经知道，卡在了代码实现上。这时我有点吃力了，于是暂时离线了一会，大概花了一个小时，我们三个人在草稿本上写写画画，突然间得出了代码实现方法，于是我赶紧去码代码，测了样例测了几组数据都没问题，提交AC，4题。我瘫一会后继续想D，想了一会发现一个可写的方法，写写调调过了样例提交第一发WA，于是打印三人检查，查了10分钟，发现bug，提交AC，此时大概过了3.5H，rk20左右。继续开题，开了E，第一眼看去二分后转化为区间问题求最小值。看到这题我想金牌有望了呀，这种题我最擅长了呀！想了一想，怎么处理这个区间问题，发现一个贪心思路，直接开码，码完过了样例提交返回WA，感觉整个人都不太好了，有点渐渐走向。想与ZQL和CZQ表达做法，发现自己心态已经有点炸裂表达不清了。于是自闭调节代码，发现自己贪心有错，于是修改贪心写法，通过样例，提交WA，给我原本有点崩坏的心态又一击，顿时感觉有点凉了。脑子乱的一塌糊涂，当时还叫ZQL和CZQ去看L题，而不是打印代码让他们帮忙调一下bug，然后自己自闭没过E题，痛失金牌，这次也是我们学校最有希望获得ICPC金牌的一次。赛后得知我的算法已经正确，问题出现在了我没有考虑数据溢出。挫败感十足，如果当时最后20分钟拉ZQL和CZQ一起调bug会不会就可以将数据溢出问题，调出来了呢。赛后和教练汇报成绩，感觉自己有点失败，没有实现教练的期望。
经验：1.一定要多交流多交流多交流，重要的事情说三遍。2.一定要时刻调整自己的心态，保证自己的心态在比较平静的范围内。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf05ce615aac8c12079c9669129e133/" rel="bookmark">
			【Android】UI设计师给的px尺寸单位，安卓如何换算成dp?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多UI工程师为了适配iOS，常常拿iOS手机作用参考模型，设计出来的UI稿只有PX标注的。他们也不懂Android的dp和sp单位是怎么回事。这个时候我们Android工程师如果不注意怎么转换的话，就可能开发出很难看的界面。
那么如何才能正确的将UI稿的上的px转换成android的dp单位呢？这个取决于UI设计师的设计稿基于什么设备。
一般安卓开发者只要适配一款主流设备，比如Nexus5、Pixel 3，其它大部分手机都可以适配。如果要精确适配，就要针对不同分辨率进行单独适配。为了简单起见，我们只需要适配主流设备就可以了。
首先，我们要知道UI设计师的设计稿是基于什么设备设计的。知道了什么设备，这个设备的dpi也就知道了。那么px与dp之间换算就很简单：px=(dpi/160)dp。公式变形：dp=px*160/dpi
要注意的是这个公式中dpi并不是我们自己计算出来的(屏幕对角线的相素数除以对角线长度)，而是手机厂家ROM中设置density(density=dpi/160)，android通过java代码可以直接获取：
//以下是获取density，density=densityDpi/160 context.getResources().getDisplayMetrics().density; //以下是获取densityDpi,就是我们常说的dpi：像素密度 context.getResources().getDisplayMetrics().densityDpi; 而实际情况下，设计师常常并没有针对安卓设备单独做一套设计稿，而是选择了iphone手机作为参考机型。他们以为适配了IOS就等于适配了安卓。标注尺寸单位都是px。设计帅常常拿iphone6(s)或者是iphone6(s) plus作为参考机型，一个4.7寸一个5.5寸。比如是4.7英寸的iphone6，它的分辨率是1334x750(dpi是326)，而安卓设备最接近这个数值的分辨率是1280*720，对应这个分辨率的dpi一般是320，跟iphone 6(s)很接近，那么UI使用的iphone6(s)设计稿就对应安卓1280x720(dpi是320)的设备，所以我们就用320这个dpi进行换算。再比如是5.5英寸的iphone6 plus，它的分辨率是1920x1080(dpi是480)，而安卓设备刚好也有很多同等的分辨率，对应这个分辨率的dpi一般是480，而iphone6 plus的dpi也是480，所以我们用480的dpi进行换算。
举个例子，设计师基于iphone6的设计稿标注20px，换算成dp就是20*160/320=20*(1/2)=20/2=10，也就是除以2得到dp。如果设计师基于iphone6 plus的设计稿标注120px，那么dp就是120*160/480=120*(1/3)=120/3=40，也就是除以3得到dp。
那么如何知道设计稿是基于什么设备设计的呢？一般我们看UI稿的尺寸就可以推测出它的参考机型，比如UI稿的尺寸是1334x750，那肯定是iphone6(s)一类的机型，如果是1920x1080，那就是iphone6(s) plus一类的机型。如果UI稿的尺寸匹配不到一款主流的机型，那就是UI设计师不合格啦！
还有一种方法，程序员不需换算，UI设计师可以直接在设计工具中将px单位转换成dp单位，标注图上显示的就是dp单位，比如PxCook这个工具已经支持这个功能。
以上是一般性的适配方法，如果厂商生产的手机很奇葩，比如1280*720的分辨率dpi不是320，而是相差很大，比如是400，那么Android开发者就需要进行单独适配了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb72ae7f87b7341ebf571a0e34db86c/" rel="bookmark">
			matplotlib绘制平滑的曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib绘制平滑的曲线有2种常用的方法
1.曲线拟合 使用scipy库可以拟合曲线.
没拟合的图：
import matplotlib.pyplot as plt import numpy as np T = np.array([6, 7, 8, 9, 10, 11, 12]) power = np.array([1.53E+03, 5.92E+02, 2.04E+02, 7.24E+01, 2.72E+01, 1.10E+01, 4.70E+00]) plt.plot(T,power) plt.show() 使用scipy.interpolate.spline拟合曲线：
import matplotlib.pyplot as plt import numpy as np T = np.array([6, 7, 8, 9, 10, 11, 12]) power = np.array([1.53E+03, 5.92E+02, 2.04E+02, 7.24E+01, 2.72E+01, 1.10E+01, 4.70E+00]) from scipy.interpolate import spline xnew = np.linspace(T.min(),T.max(),300) #300 represents number of points to make between T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb72ae7f87b7341ebf571a0e34db86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3a44f9187bfa9141ee10c0a4910070/" rel="bookmark">
			【腾讯云,FTP】腾讯云安装配置了vsftp，读取目录列表失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云安装配置了vsftp，读取目录列表失败 问题描述： 腾讯云，配置了vsftp, 当客户端用Filezilla 访问时，主动ok, 被动就超时？
状态: 正在连接 *.*.*.*:21...
状态: 连接建立，等待欢迎消息...
状态: 不安全的服务器，不支持 FTP over TLS。
状态: 已登录
状态: 读取“/ROOT”的目录列表...
命令: CWD /ROOT
响应: 250 Directory successfully changed.
命令: TYPE I
响应: 200 Switching to Binary mode.
命令: PASV
错误: 20 秒后无活动，连接超时
错误: 读取目录列表失败
状态: 已从服务器断开
状态: 正在连接 123.207.16.157:21...
状态: 连接建立，等待欢迎消息...
状态: 不安全的服务器，不支持 FTP over TLS。
状态: 已登录
状态: 读取“/ROOT”的目录列表...
命令: CWD /ROOT
响应: 250 Directory successfully changed.
命令: TYPE I
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e3a44f9187bfa9141ee10c0a4910070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3ae9bf3f76b7a73abf3c16d63bb97d/" rel="bookmark">
			neo4j&#43;nginx 实现查询集群设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直都在研究Neo4j社区版的简单集群，是读写的集群，但是做了很多调研，一直没有得到理想的解决方案，所以又重新整理了思路，一步一步的做，先做读的集群。方案如下：服务+nginx+neo4j，中间放了一层代理nginx，这个代理可以连接N（N&gt;=2）台机器。最后经过多次实践，排除各种问题，最后成功，查询的集群能做到。GOOD!!! 具体步骤如下：
准备工作如下：两台机器，每台机器Neo4j用的版本是社区版3.4.7，这是最新的Neo4j版本，能容纳320亿个节点，320亿个关系，640亿个属性。
Nginx 用的版本是1.13.7，因为我需要这个stream，所以nginx版本必须是1.9版本以上的。
两个安装过程就不说了，网上教程都有。要说的是我采用的Neo4j连接是bolt协议，而bolt协议是建立在tcp协议或者websocket上，所以nginx必须支持tcp协议，所以nginx需要安装stream模块。
还有一个问题，就是集群的neo4j机器必须安装相同的版本和相同的用户名密码，因为客户端访问neo4j时需要ssl秘钥，否则会报General SSLEngine 错误
1，首先，升级nginx工程，让它支持stream功能，默认的Nginx安装功能是不支持的，所以需要升级。升级步骤很简单，如下：
1)cd =/usr/local/nginx/nginx-1.13.7(nginx安装路径) ，执行命令：
./configure --prefix=/usr/local/nginx/nginx-1.13.7 --with-stream
安装stream模块
2）执行 make 命令，不是make install 命令
3）备份nginx命令 ，执行：
cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak
4）把先生成的nginx命令覆盖以前的nginx命令，执行：
cp /usr/local/nginx/nginx-1.13.7/objs/nginx /usr/local/nginx/sbin/nginx
5) 测试是否升级成功，执行
/usr/local/nginx/sbin/nginx -t
成功，第一步升级工作完成。
2，配置nginx.conf文件，配置如下：
stream { upstream neo4j{ server localhost:17687 weight=2; server 10.10.8.143:7687; } server { listen 7687; proxy_pass neo4j; # &amp;lt;--- replace this with your neo4j server and bolt port&lt;br /&gt; } } 然后保存，退出。
3，设置neo4j.conf，cd到neo4j的安装路径下，找到neo4j.conf配置文件，打开，修改如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3ae9bf3f76b7a73abf3c16d63bb97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2143d2486e2ae90ef5b9306ecb913d/" rel="bookmark">
			minikube安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 其实装这个环境搞了很久，对于国内的网络，这玩意很折腾，这种教程走一波，还是gg了。试过windows、直接linux、虚拟机都不行，很大原因是墙的问题。最后用阿里云的重新编译的文件搞定了。果然墙内还是要用墙内的网络，因为minikube启动过程中会下载蛮多东西的（kubeadm、kubelet和启动过程下载的东西），不是阿里修改过都不知道要搞多久；还有就是使用虚拟机要注意内存和交换空间问题，最低要求是2g内存，1g交换空间。
2、系统环境 环境：vmware15
系统：ubuntu18.04 server
内存：4GB --其实好像实际占用内存不多，加上系统1g左右而已
3、安装过程 安装使用vm-driver为none，即使用linux本机作为环境使用。
以下安装过程全在root下操作。
3.1、docker安装 首先更行源，在/etc/apt/sources.list追加：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2143d2486e2ae90ef5b9306ecb913d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070e8b1b2b7883518e3f388a894d5326/" rel="bookmark">
			hadoop WARN：Unable to load native-hadoop library
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已配置好环境，可以编译程序，但是启动hadoop 和每次运行命令 会出现以下警告（不影响使用，看着不舒服）
WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
翻译：警告:无法为您的平台加载本机Hadoop库…使用可应用的Java类
解决方法：
一.在hadoop配置文件log4j.properties文件中添加以下内容，将警告无视掉
log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR
-----------------------------------------------------------------------------------------------------------------
二.在文件hadoop-env.sh中增加以下环境变量，使其指向hadoop本地lib：
export HADOOP_OPTS="-Djava.library.path=${HADOOP_HOME}/lib/native" 1.还是有警告且出现Starting namenodes on [OpenJDK Client VM warning: You have loaded library /usr/local/hadoop/lib/native/libhadoop.so.1.0.0 which might have disabled stack guard. The VM will try to fix the stack guard now.
解决方法：查看系统位数(getconf LONG_BIT) 与 libhadoop.so.1.0.0是否一致(file libhadoop.so.1.0.0) 不一致在网上找对应位数native库或者自己编译或者换个操作系统。
2.还是有警告可以ldd libhadoop.so.1.0.0，出现version `GLIBC_2.14' not found。
解决方法：可安装相应版本的glibc。
以上均亲测，可能由于版本或个人使用问题有细微差异
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d2a1433b5902f6521097076150a0fe/" rel="bookmark">
			C/S模式和B/S模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：C/S模式(Client/Server,客户机/服务器模式) 是软件系统结构的一种，C/S模式是基于企业内部网络的应用系统，与B/S模式的相比，最大的优点是，不依赖企业外网的环境，无论企业是否能够上网，都不影响应用。
服务器通常采用高性能的PC、工作站或者小型机，并采用大型数据库系统，客户端需要安转专用的客户端软件。C/S结构的软件针对不同的操作系统开发不同版本的软件，加之产品更新换代很快（每次更新，要给每个客户端电脑更新，麻烦），已经很难适应百台以上的局域网用户同时使用，而且代价高效率低。
优点：
1：C/S模式充分发挥客户端PC的处理能力，很多工作可以在客户端处理之后再提交给服务器，对应的优点就是客户端响应速度快。
2：将应用程序与服务器分离，系统具有稳定性和灵活性。 3：适合于局域网，安全性高
缺点：
1：只适用于局域网，随着互联网的飞速发展，移动办公和分布式办公越来越普及，远程访问需要专门的技术，同时要对系统进行专门的设计来处理分布式的数据。
2：客户端需要安转专门的客户端软件，首先涉及安装工作量，其次，任何一台电脑出现问题，如病毒，硬件损坏都需要进行安转和维护，如果软件需要升级，每台客户机都需要重新安转，维护和升级成本非常高。
3：.客户端软件对操作系统有限制，可能适应XP，不适应win7,更不必说Linux等。
2.B/S模式（Browser/Server,浏览器/服务器模式） 随着互联网的兴起，对C/S模式进行了扩展，B/S结构中用户界面是通过浏览器实现的，B/S是基于应用层http协议的web，建立在广域网上。B/S模式最大优点是运行维护比较简单，能实现不同人员在不同地点，以不同的接入方式访问和操作共同的数据。
B/S工作方式：用户通过WWW浏览器访问互联网的数据、图片、视频等信息。这些信息是由很多个Web服务器产生的，每个Web服务器又通过不同的方式与数据库服务器相连，大量数据存放在数据库服务器中。客户端一般除了浏览器，不需要安转任何用户程序，只需从web服务器下载到本地执行即可，在下载过程中若遇到数据库相关的指令，则web服务器交给数据库服务器执行，执行完后，返回给web服务器，web服务器在返回给用户。
优点：
1：维护、升级简单，每次维护或者升级，只要对服务器操作即可，客户端不需要修改。
2：开放性好（用户通过通用浏览器访问），可扩展性好（由于web平台的无关性，B/S可以任意扩展）
3：用户使用方便，用户接触的浏览器界面相似。
缺点：
1：安全性较弱。
2：响应速度受很多因素影响，用户体验不是特别好。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/443/">«</a>
	<span class="pagination__item pagination__item--current">444/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/445/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>