<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae94d7db7dd14d026cc75ff46a1d500/" rel="bookmark">
			Eigen库学习（三）Matrix和vector算术运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节来讲Matrix和Vector的一些算术运算。
一、简介 Eigen提供对C++常见的运算符进行了重载运算，如加减乘除；除此还有一些特殊的方法如dot corss等。需要注意Matlab不一样地方，这里支持的只是常规的线性代数运算，如matrix1*matrix2是支持的，matrix+scalar不支持（matlab支持，表示所有的元素都加上一个常数，但是乘上一个常数支持）。如果你想支持所有的数组元素，请看下一节。
二、加法、乘法 二元运算符 a+b二元运算符 a-b一元运算符 -a复合运算符 += -= #include &lt;iostream&gt; #include &lt;Eigen/Dense&gt; using namespace Eigen; int main() { Matrix2d a; a &lt;&lt; 1, 2, 3, 4; MatrixXd b(2,2); b &lt;&lt; 2, 3, 1, 4; std::cout &lt;&lt; "a + b =\n" &lt;&lt; a + b &lt;&lt; std::endl; std::cout &lt;&lt; "a - b =\n" &lt;&lt; a - b &lt;&lt; std::endl; std::cout &lt;&lt; "Doing a += b;" &lt;&lt; std::endl; a += b; std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae94d7db7dd14d026cc75ff46a1d500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bdd4896c9e4c360c5efe83da305348/" rel="bookmark">
			Centos7使用docker搭建elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装docker cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF [docker-ce-edge] name=Docker CE Edge - \$basearch baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge enabled=1 gpgcheck=1 gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg EOF yum安装 yum -y install docker-ce 查看docker版本 docker --version 启动docker systemctl enable docker systemctl start docker 安装docker-compose sudo curl -L "https://github.com/docker/compose/releases/download/v2.3.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 加速docker镜像 可登录阿里云
https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
然后获得
https://******.mirror.aliyuncs.com
页面中也有设置加速的代码
启动容器 创建对应文件夹目录
把下面文件保存成docker-compose.yml文件
执行:
docker-compose up
(如果有报错自行百度)
version: '2.2' services: es790: image: docker.elastic.co/elasticsearch/elasticsearch:7.9.0 container_name: es790 environment: - node.name=es790 - cluster.initial_master_nodes=es790 - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bdd4896c9e4c360c5efe83da305348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef0fda3cacbee0abf180580a1b489c2/" rel="bookmark">
			Linux命令行使用zip命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux命令行中使用zip命令学习记录。
从编译结果文件中删除SetupWizard文件
进入images对应目录：sf_user7/android_t/tran_mtk_t0.mp1_trunk/out_prd/target/product/x670_h814_d1_tssi_64_infinix/images$
从zip文件删除SetupWizard命令：
zip -d sysext.target_files.zip SYSTEM_EXT/priv-app/SetupWizard/*
从vnd.target_files.zip文件解压build.prop文件，命令：
unzip vnd.target_files.zip VENDOR/build.prop
解压后，会在当前目录下生成目录VENDOR，里面包含build.prop文件。
将VENDOR/build.prop文件压缩到vnd.target_files.zip，命令：
zip -r vnd.target_files.zip VENDOR/build.prop
这样就会将这个文件压缩到zip文件，如果原来存在这个文件则进行替换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfde4394636013419a01e7399eef262/" rel="bookmark">
			python爬虫: 查找自己浏览器的headers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器中打开任意一个网页——比如打开IP查询
在网页中右键单击点击“检查”，出现如下页面。
点击最上方选项卡中的‘Network’选项，再按F5，在‘name’框中会出现一个或多个选项，点击任意选项，在右侧点击‘headers’选项，在最下方找到‘User-Agent:’，如下图
将User-Agent:粘贴到自己代码headers中即可：
Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf9cc244df2aa504cf5d528bf6343ee5/" rel="bookmark">
			LM358是双运算放大器IC电路应用原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 概述 LM358 内部包括有两个独立的、高增益、内部频率补偿的双运算放大器，适合于电源电压范围很宽的单电源 使用，也适用于双电源工作模式，在推荐的工作条件下，电源电流与电源电压无关。它的使用范围包括传感放大 器、直流增益模组，音频放大器、工业控制、DC 增益部件和其它所有可用单电源供电的使用运算放大器的场合。 二、 特点 内部频率补偿。 低输入偏流。 低输入失调电压和失调电流。 共模输入电压范围宽，包括接地。 差模输入电压范围宽，等于电源电压范围。 直流电压增益高（约 100dB）。 单位增益频率带宽（约 1MHz）。 电源电压范围宽：单电源（3V ~ 20V）；双电源（±1.5V ~ ±10V）。 低功耗电流，适合于电池供电。 输出电压摆幅大（0 ~ VCC-1.5V）。 采用 SOP-8、D
LM358管脚说明
LM358电路应用原理图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52595a7dbf3018a35fcf2741750e184b/" rel="bookmark">
			Pytorch Bug解决：RuntimeError:one of the variables needed for gradient computation has been modified
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch Bug解决：RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation 编程环境Bug描述bug分析解决方法 编程环境 Python：3.9
Pytorch：1.11.0
Bug描述 Traceback (most recent call last): File "E:\Anaconda\envs\torch_c_13\lib\site-packages\IPython\core\interactiveshell.py", line 3343, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File "&lt;ipython-input-2-18bbaf295f9c&gt;", line 1, in &lt;module&gt; runfile('E:/Code/AEs by PyTorch/AEsingle_train_test_temp.py', wdir='E:/Code/AEs by PyTorch') File "E:\SoftWare\PyCharm\PyCharm 2021.2.3\plugins\python\helpers\pydev\_pydev_bundle\pydev_umd.py", line 198, in runfile pydev_imports.execfile(filename, global_vars, local_vars) # execute the script File "E:\SoftWare\PyCharm\PyCharm 2021.2.3\plugins\python\helpers\pydev\_pydev_imps\_pydev_execfile.py", line 18, in execfile exec(compile(contents+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52595a7dbf3018a35fcf2741750e184b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb67d2aadccbd327771cd5f01bf63da/" rel="bookmark">
			安装VMware虚拟机遇问题及命令作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装VMware虚拟机可能遇到问题及解决方法
问题1
解决方法:
1.重启，同时按快捷键f2/fn+f2进入 BIOS 设置页面；(联想电脑)
2、选择 configuration ，再选择intel virtual technology ，此时该选项应该是disabled（关闭）的；
3、将disabled（关闭）改为 enabled（开启）；
4、f10保存设置，重启即可。
问题2
使用ISO映像文件——浏览——找下载映像的路径
命令使用
pwd:查看当前路径
ls:显示目录内容
长格式：ls –l
ls –a:列出所有文件包括.开头隐藏文件
ls –au: 列出所有文件包括.开头隐藏文件并且按文件最近访问时间排序
ls –rt:逆序且文件最近修改时间排列
cd: 在不同的目录间切换，即更改当前工作目录
cd ..:进入上一级目录
cd -:进入上次所在目录
cd ~:进入进入当前用户登录主目录
tail:显示文件结尾若干行
tail –n num 文件名：显示文件结尾若干行
tail –n 2 test33:显示文件test33结尾2行
tail –c 3 test33:显示文件test33 结尾后3个字节
head:显示文件开头若干行
head –n num 文件名
head –n 1 test33:显示文件test33开头前一行
head –c 4 test33:显示文件test33开头前四个字节
more:分页显示文件一次显示一页内容
more +2 test33:文件test33从第二行开始显示
more -1 test33:文件每屏显示一行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb67d2aadccbd327771cd5f01bf63da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a75ac7aabf8dd7a781b145f919d1e48/" rel="bookmark">
			华为机试题80-整型数组合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 题目标题：
将两个整型数组按照升序合并，并且过滤掉重复数组元素。
输出时相邻两数之间没有空格。
输入描述： 输入说明，按下列顺序输入：
1 输入第一个数组的个数
2 输入第一个数组的数值
3 输入第二个数组的个数
4 输入第二个数组的数值
输出描述： 输出合并之后的数组
示例1 输入：
3 1 2 5 4 -1 0 3 2 输出：
-101235 这题也比较简单，用最笨的方法暴力求解，而且我只用一个数组，循环输入两次数组数据即可。
在存放新输入的整型元素之前，对比之前已经存储了的数组元素，如果和之前存储了的元素重复，则不再存储，否则进行存储。
将两组整型数据存储好后，随便用什么排序算法进行排序就行，笔者使用的是冒泡排序算法，代码如下：
#include &lt;stdio.h&gt; #define N 1000 int main() { int arr[N],m,i=0,j,temp,k=2; while(k&gt;0) { scanf("%d",&amp;m); while(m&gt;0) { scanf("%d",&amp;temp); if(i==0) arr[i++]=temp; else { for(j=0;j&lt;i;j++) { if(temp==arr[j]) break; } if(j==i) arr[i++]=temp; } m--; } k--; } m=i; //sort for(i=0;i&lt;m-1;i++) { for(j=0;j&lt;m-1-i;j++) { if(arr[j]&gt;arr[j+1]) { temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for(i=0;i&lt;m;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a75ac7aabf8dd7a781b145f919d1e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0d2206617a21ea7c4958e48a5429cb/" rel="bookmark">
			Java基础之==与equals
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 使用 ==1.1 基本类型比较1.2 字符串比较 2. 使用equals方法3. 空指针异常3.1 ==3.2 equals3.3 解决办法 4. Object.equals的坑 1. 使用 == 1.1 基本类型比较 int a = 1; int b = 1; byte c = 1; Integer d1 = new Integer(1); Integer d2 = new Integer(1); System.out.println(a == b); //结果：true System.out.println(a == c); //结果：true System.out.println(a == d1); //结果：true System.out.println(d2 == a); //结果：true System.out.println(d1 == d2); //结果：false java中的基本类型，包含：int、long、short、byte、char、boolean、float、double这8种，可以使用==号判断值是否相等。
如果出现了基本类型的包装类，比如：Integer，用一个基本类型和一个包装类，使用号也能正确判断(a == d1)，返回true，因为Integer和int比较时，会自动拆箱，这是比较值是否相等。
但如果有两个包装类(d1 == d2)，使用==号判断的结果可能是false，因为两个Integer比较时，比较的是它们指向的引用（即内存地址）是否相等。
Integer d3 = 1; Integer d4 = 1; Integer d5 = 128; Integer d6 = 128; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0d2206617a21ea7c4958e48a5429cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25597377c49037058df4f70f3ca5a4df/" rel="bookmark">
			【1】谷歌2021模型量化白皮书《A White Paper on Neural Network Quantization》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 Google模型量化白皮书 摘要引言模型量化的理论基础硬件背景均匀仿射量化对称均匀量化2的幂次方量化量化粒度 量化模拟Batch normalization foldingActivation function fusing其他网络层及其量化 Practical considerationsSymmetric vs. asymmetric quantizationPer-tensor and per-channel quantization 最近开始学习模型量化的知识，找到了一篇入门版的论文A White Paper on Neural Network Quantization.
在学习的过程中做一些记录加深理解，防止遗忘（记性不好让人头大，担心自己老年痴呆），并添加一些自己的理解。如果可以帮到大家，是我的荣幸。
摘要 当前神经网络在许多应用中都取得了进展，但它也总是带来很高的计算消耗。如果我们想要将神经网络部署在具有严格的功率和计算要求的边缘设备上，降低神经网络推理时的功率和延迟是关键。模型量化是达到这些要求的最有效的方法之一，但是模型量化过程中引入的噪声也会带来准确率的下降。
在这篇论文中，作者介绍了当前效果最好的模型量化算法，它们在保持低位权重和激活值的同时尽量消除量化噪声对模型性能影响。文章首先从硬件背景介绍模型量化，之后主要讨论两类主流的量化算法：训练后量化 (PTQ) 和量化感知训练 (QAT)。PTQ不需要预训练和标注的数据，因此，它是一种轻量级的按键式的量化方法。在大多数情况下，PTQ可以达到8比特量化，同时精度接近浮点型。QAT需要微调和标注数据，但是可以完成更低位的量化，取得更有竞争力的结果。对于这两种方案，作者基于已有的文献和扩展实验提供了测试好的pipelines，这些pipelines对于常见的深度学习模型和任务达到了SOTA的性能。
个人理解：为了追求性能，神经网络模型的体量不断增大，这给在边缘设备上部署模型造成了困难。因此需要一些技术使得模型轻量化，加快模型的推理速度和功率消耗。模型量化就是一种非常有效的模型轻量化算法。它主要通过对模型内的权重和激活值参数进行类型转化（比如浮点型转低位整型，或者混合精度等）来加快模型推理速度。但是，这种粗略的量化方式会引入噪声使得模型精度有所下降。主流的模型量化算法主要分为PTQ和QAT两种。PTQ是在模型参数训练好之后进行精度转换，这种算法可以解决大多数问题。QAT是在训练过程中进行量化，步骤要繁琐一些，需要微调和标注数据，但是其精度要好于PTQ。
引言 随着深度学习越来越作为一种通用方案用来给电子设备赋予智能属性，体量小、低延迟并且性能好的神经网络方案成为一种发展趋势。如今，在很多电子产品和服务中都可以看到神经网络的身影，比如智能手机、智能眼镜、智能家居、机器人、自动驾驶等。这些设备通常要求神经网络在执行中遵守严格的时间限制，并且为了长续航性能需要降低推理的功耗。
模型量化，是降低计算时间和能量消耗的最佳方法之一。模型训练的时候，权重和激活张量通常以16或32位精度的数据类型存储，而模型量化将权重和激活的张量存储在低精度的张量中。当把权重和激活张量从32位转为8位后，存储张量的内存空间缩小4倍，同时矩阵乘法的计算消耗降低14倍。神经网络已被证实，模型量化到较为低位的带宽之后，精度所受到的影响在可接受的范围之内。除此之外，模型量化还经常和其他模型优化的方法一同使用，比如网络架构搜索，模型压缩，模型剪枝等。所以模型量化是深度学习实际落地应用的一个核心步骤。但它也有缺点：低位宽量化会引入噪声到模型中，导致精度下降。尽管一些网络对噪声具有抗干扰性，但是其他网络还需要额外的工作去最大化量化的好处。
在这篇论文中，作者介绍了SOTA的模型量化算法。他们首先介绍量化，并讨论了硬件背景和实际应用条件。然后分别讨论两种主流量化算法：PTQ和QAT。PTQ处理的是已经训练好的网络，使用少量数据或者不需要使用数据进行量化，它需要较少的超参数进行调整，并且不用端到端的训练。这使得PTQ不需要太多工程量和计算消耗，并且可以看作一种push-button方法（按钮启动方法，我理解的是在模型训练的时候不需要考虑，模型训练好之后如果需要PTQ就设置添加PTQ，如果不需要就不用添加，类似于想用的时候只需要按一下即可）。QAT依赖于在训练pipeline中使用模拟量化重新训练神经网络。虽然这需要在训练和潜在的超参数调整方面付出更多努力，但与低位量化的 PTQ 相比，它通常会进一步缩小与全精度精度的差距。对于这两种方案，作者引入了基于现有文献和广泛实验的标准pipelines，从而为常见的计算机视觉和自然语言处理模型带来了最先进的性能。 我们还提出了一个调试工作流程来识别和解决量化新模型时的常见问题。
模型量化的理论基础 在本节中，作者介绍了神经网络量化的基本原理以及运行量化网络的定点加速器。这一节从硬件背景开始，然后介绍标准量化方案及其属性。 稍后又讨论了与现代神经网络中常见的层相关的实际考虑因素及其对定点加速器的影响。
硬件背景 在深入了解技术细节之前，首先探索量化的硬件背景以及它如何在设备上实现高效推理。图1展示了一个矩阵-向量如何在神经网络加速器（硬件模块）中相乘 y = ω x + b y = {\omega}x + b y=ωx+b 的机制图。这是大型矩阵之间相乘和卷积操作的基础模块。这样的硬件模块旨在通过并行计算提升神经网络的推理速度。图1中神经网络加速器的两个基本元素：处理元件 C n , m C_{n,m} Cn,m​和累加器 A n A_n An​。
其中 C n , m C_{n,m} Cn,m​执行的是乘法操作（ C n , m C_{n,m} Cn,m​里边， ω n , m 和 x m 相 乘 {\omega_{n,m}}和x_m相乘 ωn,m​和xm​相乘）,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25597377c49037058df4f70f3ca5a4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60a94ced478f58dc7da8d0d5bada035/" rel="bookmark">
			华为机试题61-放苹果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述 把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？
注意：如果有7个苹果和3个盘子，（5，1，1）和（1，5，1）被视为是同一种分法。
数据范围：0≤m≤10 ，1≤n≤10 。
输入描述： 输入两个int整数
输出描述： 输出结果，int型
示例1 输入：
7 3 输出：
8 动态规划的题对我来说都是难题，根本想不出状态转移方程要怎么写。。。
解题思路：
已知苹果个数为m（0~10），盘子个数为n（1~10），有两种情况：
先设f[m][n]为m个苹果，n个盘子时的分法；
1、如果苹果个数m&lt;盘子个数n，那么肯定会有n-m个盘子是空着的，去除这些盘子也不影响苹果的分发，于是可得f[m][n]=f[m][m]；
2、如果苹果个数m≥盘子个数n，此时也有两种情况：
2.1、如果有盘子为空，则f[m][n]=f[m][n-1]；
2.2、如果没有盘子为空，即每个盘子至少放了一个苹果，那我们把这n个苹果扔了，再用剩下的苹果m-n分发，也是同样大小的分法，即f[m][n]=f[m-n][n];
则f[m][n]=f[m][n-1]+f[m-n][n];
了解以上后，用递归还是动态规划，就看个人选择了，用递归的话注意添加结束条件，否则会一直递归，然后出错。用动态规划的话，也要添加初始值，这里苹果数m为0或者1时，给定f[m][n]的初始值为1，当盘子数n=1时，f[m][n]的初始值为1，即所有苹果放这一个盘子上。
ps：我认为把所有苹果分完就算一种分法（不重复为前提），所以如果苹果个数为0，所有盘子全空，算1种分法。
以下代码用的动态规划方法：
#include &lt;stdio.h&gt; #define N 11 int main() { int f[N][N],m,n,i,j; scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;N;i++) //i为苹果个数 { for(j=1;j&lt;N;j++) //j为盘子个数 { if(i==0||i==1) //0个或1个苹果时，为1种分法 f[i][j]=1; else { if(j==1) //只有1个盘子时，也是1种分法 f[i][j]=1; else { if(i&lt;j) f[i][j]=f[i][i]; //盘子数更多，把肯定空的盘子去了，分法保持不变 else f[i][j]=f[i][j-1]+f[i-j][j]; } } } } printf("%d\n",f[m][n]); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b3b78175d1187be0cffd664616c04a/" rel="bookmark">
			Apache国内镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址1：http://mirror.bit.edu.cn/apache/
地址2：https://mirrors.tuna.tsinghua.edu.cn/apache
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4554da17ce048644f66616e96173f8a7/" rel="bookmark">
			计算机图形学——向量间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向量点积（内积） 假设向量 a 为 (x, y), 向量 b 为 (x2, y2)，则 a · b 为 x * x2 + y * y2 。
用来计算两个向量之间的夹角，但是无法区分向量的位置关系，因为反余弦函数arccos的范围是[0, 180]
向量叉乘 二维叉乘 设两个向量分别为 ( x 1 , y 1 ) , ( x 2 , y 2 ) (x_{1},y_{1}),(x_{2},y_{2}) (x1​,y1​),(x2​,y2​)，那么它们的叉乘就为 ( x 1 ∗ y 2 − x 2 ∗ y 1 ) (x_{1}*y_{2}-x_{2}*y_{1}) (x1​∗y2​−x2​∗y1​)，它也是一个向量。
几何意义：叉乘的几何意义是以两向量为邻边的平行四边形的有向面积。另外，根据右手规则，另外，定义向量 a ⃗ \vec{a} a 、 b ⃗ \vec{b} b ，当 a ⃗ X b ⃗ &lt; 0 \vec{a}X\vec{b}&lt;0 a Xb &lt;0时（X就表示叉乘）， b ⃗ \vec{b} b 对应的线段在 a ⃗ \vec{a} a 的顺时针方向；当\vec{a}X\vec{b}=0时，\vec{a}、\vec{b}共线；当 a ⃗ X b ⃗ &gt; 0 \vec{a}X\vec{b}&gt;0 a Xb &gt;0时， b ⃗ \vec{b} b 在 a ⃗ \vec{a} a 的逆时针方向。（注意： a ⃗ X b ⃗ = − b ⃗ X a ⃗ \vec{a}X\vec{b}=-\vec{b}X\vec{a} a Xb =−b Xa ，因此判断时要注意顺序）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4554da17ce048644f66616e96173f8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c440533a3dad7d92fd01e95c8a0433bb/" rel="bookmark">
			【分布式】分布式事务基础概念（2PC，3PC，TCC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 XA协议两阶段提交协议（2PC）2PC 过程准备阶段提交阶段 2PC总结 三阶段提交协议（3PC）3PC过程阶段一 CanCommit阶段二 PreCommit阶段三 DoCommit 3PC总结 TCC（Try-Confirm-Cancel）流程设计要点TCC总结 XA协议 在讲分布式事务之前，必然需要先了解XA协议。XA是一个协议，由Oracle Tuxedo系统提出的XA分布式事务协议。
XA协议定义了分布式事务参与方的两个角色：
事务协调者（TM=Transaction Manager）
资源管理器/事务参与者（RM=Resource Manager）
XA协议包括两阶段提交（2PC）和三阶段提交（3PC）两种实现
两阶段提交协议（2PC） 二阶段提交协议（Two-phase Commit，即2PC）是常用的分布式事务解决方案，它可以保证在分布式事务中，要么所有参与进程都提交事务，要么都取消事务，即实现 ACID 的原子性（A）。在数据一致性中，它的含义是：要么所有副本（备份数据）同时修改某个数值，要么都不更改，以此来保证数据的强一致性。
2PC 要解决的问题可以简单总结为：在分布式系统中，每个节点虽然可以知道自己的操作是成功还是失败，却是无法知道其他节点的操作状态。当一个事务需要跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点（参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将操作结果通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
2PC 过程 顾名思义，2PC 分为两个过程：
准备阶段 就是在分布式事务的发起方在向分布式事务协调者（Coordinator）发送请求时，Coordinator首先会分别向参与者（Partcipant）、发送事务预处理请求，称之为Prepare，有些资料也叫"Vote Request"。
准备阶段有如下三个步骤：
协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。 提交阶段 协调者基于各个事务参与者的准备状态，来决策是事务提交Commit()或事务回滚Rollback()。如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息。
参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意：必须在最后阶段释放锁资源)
接下来分两种情况分别讨论提交阶段的过程。
提交事务
情况 1，当所有参与者均反馈 yes，提交事务，如下图所示：
协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。
参与者执行 commit 请求，并释放整个事务期间占用的资源。
各参与者向协调者反馈 ack(应答)完成的消息。
协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。
中断事务
情况 2，当准备阶段中任何一个参与者反馈 no，中断事务，如下图所示：
协调者向所有参与者发出回滚请求（即 rollback 请求）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c440533a3dad7d92fd01e95c8a0433bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca535815d86df60d4c657ac0e75fa6ec/" rel="bookmark">
			AFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rt.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42d55f4d0599a73da150ca8525741ae/" rel="bookmark">
			登录功能&amp;新增文章功能的测试点提取以及测试用例编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面：
这是基于SSM框架搭建的博客系统，对登录功能和新增文章功能两个模块进行测试点的提取及测试用例的编写。
软件质量模型指明了测试切入点：功能、性能、兼容性、安全性、易用性、可靠性、可移植性、可维护性、UI界面等。
下面的两个功能分别在功能、兼容性、界面UI测试给出分析和用例。
一、登录功能 1、需求分析 需要输入手机号，通过手机号获取并输入验证码，勾选协议即可登录。
手机号必须是注册账号。协议必须勾选。 2、提取测试点 3、测试用例的编写 编写测试用例时，正向用例一次可以覆盖多个正向的测试点，反向测试用例一次只能有一个反向测试点（类似于控制变量，每一个用例只能有一个不符合需求的点，如果反向测试点不单一那就说明不了是其中的哪个点有问题）。
用例编号格式：项目_模块_序号
用例标题：预期结果+测试点
二、新增文章功能 1、需求分析 发布文章页面有类别复选框，标题栏，内容栏，标签复选框以及提交按钮。
类别和标签不能为空标题栏的长度不能小于5个内容不能为空 2、提取测试点 3、测试用例的编写 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdc901300f58dd5e28155b22444a223/" rel="bookmark">
			【嵌入式Android开发学习攻略】手把手教你循序渐进的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式Android开发学习攻略】手把手教你循序渐进的学习
学习嵌入式主要有以下几个方面：
C语言：C是必须学的，它是最基础的
操作系统：Linux、Android 目前Linux是主流，这个一定要掌握。Android系统和设备的普及是Linux兴起的主要原因。
技术学习路线： 镜像烧写与源码编译、Linux系统编程教程、Linux驱动教程、Linux系统移植、Qt入门教程、Android入门教程、Linux系统开发、Linux内核开发、Qt开发专题、Android系统开发。
硬件平台：嵌入式开发是软件和硬件的结合，需要对软件和硬件都有一定的了解，所以学习中需要选择款开发板，这款4412开发板即可以学习Linux,Android开发，又有详细学习资料，是入门开发的不二之选。
详细学习资料目录：
第一部分 开发板入门
第一章 开发板使用前必读
第二章 开发板初体验
第三章 Ubuntu开发环境搭建
第四章 Windows常用软件安装和使用
第五章 Linux常用命令
第二部分 镜像烧写与源码编译
第六章 iTOP-4412系统固件的烧写
第七章 Android 4.0/Linux 源码编译
第八章 Android 4.4系统编译
第九章 QtE4.7系统编译
第十章 QtE5.7系统编译
第十一章 设备树Linux系统编译
第三部分 嵌入式Linux系统编程教程
第十二章 Linux系统编程简介
第十三章 制作最小linux文件系统
第十四章 最小Linux系统运行应用程序
第十五章 Linux用户_用户组_权限
第十六章 Linux文件IO编程
第十七章 Linux字符设备控制
第十八章 Linux串口编程
第十九章 搭建和测试TFTP服务器
第二十章 搭建和测试NFS服务器
第二十一章 延时函数专题
第二十二章 时间函数专题
第二十三章 管理文件和目录
第二十四章 进程创建与回收
第二十五章 进程间通信简介
第二十六章 进程间通信-无名管道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdc901300f58dd5e28155b22444a223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6595433d6f0544a76e25d47a1f62e1a5/" rel="bookmark">
			CAS 5.1.8 登录后重定向次数太多问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 终于，使用CAS 5.1.8作为单点登录服务器，应用程序可以输入账号密码了。但是，登录成功后，却看不到返回应用程序的页面，报错了：
该网页无法正常运作 localhost 将您重定向的次数过多。 尝试清除 Cookie. ERR_TOO_MANY_REDIRECTS 坑真多啊。
调试应用程序，根本还没运行到应用程序内部。CAS 在认证时，会与应用程序有一番你来我往的交互过程，应该就是在这个过程中死掉的。为什么会提示重定向次数太多呢？估计是有一个环节没有认证成功，重试了好多遍。
查看CAS的运行日志（C:\etc\cas\logs\），最后都是死于这样的：
2018-03-02 14:00:36,258 INFO [org.apereo.inspektr.audit.support.Slf4jLoggingAuditTrailManager] - Audit trail record BEGIN ============================================================= WHO: http://localhost/NTZHHY.Web/OneMap?proxyResponse=true WHAT: Supplied credentials: [http://localhost/NTZHHY.Web/OneMap?proxyResponse=true] ACTION: AUTHENTICATION_FAILED APPLICATION: CAS ============================================================= 看提示，怎么有个 proxyResponse=true 这样的参数？代理，没用什么代理啊。
这一次是修改应用程序的配置文件解决问题。我们的应用程序是一个.NET项目，配置文件里有关CAS的配置有这么一句：
&lt;casClientConfig casServerLoginUrl="http://192.168.0.231:8080/cas/login" casServerUrlPrefix="http://192.168.0.231:8080/cas/" serverName="http://localhost/" notAuthorizedUrl="~/NotAuthorized.aspx" cookiesRequiredUrl="~/CookiesRequired.aspx" redirectAfterValidation="true" gateway="false" renew="false" singleSignOut="true" ticketTimeTolerance="5000" ticketValidatorName="Cas20" proxyTicketManager="CacheProxyTicketManager" serviceTicketManager="CacheServiceTicketManager" gatewayStatusCookieName="CasGatewayStatus"/&gt; 里面有这么一个属性：proxyTicketManager="CacheProxyTicketManager" ，这是干啥的？问题似乎跟它有关，去掉，搞定了！
原来，我们之前一直用CAS 3.*作为单点登录，.NET里的配置语句，是从别的地方拷贝过来的，我一直都不清楚里面的含义，因为可以用，所以一直都不管它。现在换了高版本，不行了，问题才暴露出来。
官方说明文档里，默认的配置也没有这个属性：
&lt;casClientConfig casServerLoginUrl="https://server.example.com/cas/login" casServerUrlPrefix="https://server.example.com/cas/" serverName="https://client.example.com:8443" notAuthorizedUrl="~/NotAuthorized.aspx" cookiesRequiredUrl="~/CookiesRequired.aspx" redirectAfterValidation="true" renew="false" singleSignOut="true" ticketValidatorName="Cas20" serviceTicketManager="CacheServiceTicketManager" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303ed5fb8c533b2c9caecfad1d12246c/" rel="bookmark">
			使用restTemplate启动报错：Field restTemplate in com.demo.service.OrderToMemberService required a bean of ty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容：
Field restTemplate in com.demo.service.OrderToMemberService required a bean of type ‘org.springframework.web.client.RestTemplate’ that could not be found.
问题原因：spring没有将restTemplate注入到容器
解决方式：在启动类中将restTemplate注入到spring ioc容器中
重新启动一下，启动成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d689099a91251c4e68027ce08ea7649c/" rel="bookmark">
			计算机应届生毕业论文高分宝典-计算机毕业设计及答辩攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近又到毕设答辩的高峰期了,我们当年毕业是全程线上答辩的,B站账号下录的所有视频都是同学的答辩视频,经过本人同意发出的,视频过了几年在依旧有很多人关注,所以想对大家毕业做一些自己的分享,也会出视频给大家讲解,有不懂的可以在评论区讨论噢
毕业设计怎么做 如何选题 我们当时选题有两种:导师提供的,还有跟导师沟通协商的
感兴趣的能够找到范例的 (本科生不是科研,技术不是科研,不需要大家创造新技术)多跟导师沟通选题 技术栈选择
做自己今后职业需要用到的
要做有效毕设
自己实习中已经熟练的
有技术就不怕被导师为难了,说不定你的老师们都不会
自己还不会需要拿项目来提升学习的
让自己的毕设能够帮助自己的职业生涯,不要单纯的花时间用在应付毕设上面
技术项目查找渠道 githubgiteeB站腾讯课堂it营 毕业论文怎么写 论文格式 一定得按老师的要求,多跟老师沟通,老师说改哪就改哪
论文内容 一定得按老师的要求,多跟老师沟通,老师说改哪就改哪
论文查重 最开始可以用免费查重的软件,免费查重查出来重复的就一定是重复的
专业概念的东西使用引用
多用自己的话术来描述
网上的博客文章有可能会进学校的查重库,看你学校查重严不严
论文答辩怎么答 答辩PPT 简洁
重点突出
条例清晰
画图工具:processon
答辩表达 自信,让大家知道这项目我做的最牛了,你们都不会 语言流畅,没啥好结结巴巴的,大家都是四年的同学和老师,都太熟了放轻松
语言逻辑清晰,主要语言的逻辑,可以列个几个点,对每个点来描述,这样整个语言都比较有逻辑和条理性
答辩问题回答 学校老师用的技术实际上都比较旧宁外也比较局限性,所以你用一些新技术就可以把老师一顿忽悠啦 数据库老师可能就关系数据库怎么设计的,网络的老师就会关系网络方向,有的老师也会问也业务设计方向的 只要是自己知道自己的项目大概是怎么做的,老师的问题回答一些就都不会有太大的问题,记住,老师绝对不会为难你的
本文由博客一文多发平台 OpenWrite 发布！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/245/">«</a>
	<span class="pagination__item pagination__item--current">246/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/247/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>