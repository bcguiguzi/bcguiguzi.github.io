<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3846e80c0846beed8ef194f3fdf209/" rel="bookmark">
			java项目1DVD管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迷你DVD管理器 1、开发环境 ①开发语言②开发工具
2、案例覆盖的技能点 ①理解程序的基本概念-----程序、变量、数据类型
②会使用顺序、选择、循环、跳转语句编写程序
③会使用数组，操作数据
④会使用方法
⑤会定义类、创建和使用对象
3、项目需求 (1) 数据初始化
① 创建项目DVDMgr，创建类DVDSet类，添加四个属性DVD名称 (name),DVD状态(state)，借出日期(time)，借出次数(count)注:0表示已借 1:表示可借
(2) 实现菜单切换
① 执行程序，输出系统主菜单。用户根据提示的主菜单，输入功能编号实现菜单显示和菜单的切换，具体要求如下：
当输入0-6时，输出相关的菜单项信息，如果输入的不是0-6则重复输入显示“输入0返回”。输入0，则返回主菜单，否则退出系统，终止程序的运行，输出提示信息“谢谢使用，欢迎下次光临”。实现借出排行榜
① 对所有的DVD按照借出次数进行降序排序，并显示排序后的结果，内容包括序号、DVD名称、借出次数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
欢 迎 使 用 迷 你 DVD 管 理 器 ****************************************************************** 0. 借出排行榜 1. 新 增 DVD 2. 查 看 DVD 3. 删 除 DVD 4. 借 出 DVD 5. 归 还 DVD 6. 退 出 ****************************************************************** 请选择： 2 ---&gt; 查看DVD 序号	状 态	名称	借出日期 1	已借出	&lt;&lt;罗马假日&gt;&gt; 2019-7-1 2	可 借	&lt;&lt;风声鹤唳&gt;&gt; 3	可 借	&lt;&lt;浪漫满屋&gt;&gt; ****************************************************************** 输入0返回：0 (4) 实现新增DVD ① 为用户显示系统中提供的DVD信息，获取新增DVD名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c3846e80c0846beed8ef194f3fdf209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4e76d75178d96c1b2dcae207480f84/" rel="bookmark">
			pycharm 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过快捷键实现 添加、删除、选择、移动、复制 代码 shift shift = ctrl shift a 在 idea 中搜索任何内容，都可以通过 shift shift 唤醒 intention，搜索自己需要的内容
ctrl d 快捷复制自己选中的行，选中一行则赋值粘贴一行，选中多行则复制粘贴多行
ctrl y 快捷删除自己选中的行
ctrl w 快捷选取 插入光标所在位置的 单词、句子、加标点符号的句子、整个逻辑段，每多按依次 ctrl w 就多选取一部分
shift ctrl w 缩小选取得代码部分
shift 箭头 在原有基础上，通过上下箭头新增上边的行或者下边的行
alt shift 上下箭头 移动行，将该行代码 向上一行或者下一行移动
ctrl shift 上下箭头 移动代码段，将该代码段整体向上或向下移动
ctrl - 折叠代码段
ctrl = 展开代码段
ctrl shift - 折叠所有代码段
ctrl shift = 展开所有代码段
ctrl alt t 将选中的代码段，用 intention 提示的模板进行包装
ctrl shift del 恢复到之前的状态，或者说去除模板的部分，这个需要自己选择去除哪个模板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4e76d75178d96c1b2dcae207480f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e69f25f071494f1594eb5885b8861f4/" rel="bookmark">
			【交叉编译踩坑指北（一）】windows10下Vscode与Cmake编译生成文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、工具链安装 工具链版本如下
C:\Users\Lenovo&gt;cmake -version
cmake version 3.24.2
C:\Users\Lenovo&gt;mingw32-make -v
GNU Make 4.2.1 Built for x86_64-w64-mingw32
若没有以上工具则进行安装，将bin文件加入到环境变量中，注意：有的交叉编译器在安装时选择自动加入环境变量可能并不会加入，还是需要手动加入环境变量，本章首先介绍MinGW编译器，其环境变量如图中所示，位于D盘bin目录下
该目录下包含了mingw的一系列工具链
包括mingw的make文件，mingw32-make（在运行makefile时要使用mingw32-make而不是make）
还有mingw的gcc文件，用于编译.c文件生成可执行文件
它们的关系是这样的：make用于执行Makefiles，Makefiles中包含了一系列的gcc语句用于编译连接，因此make相当于借助makefiles执行一系列gcc指令的指令。（这里的make代表了一系列的make工具，对于mingw是mingw32-make，对于其他工具可能是其他名字。gcc也同理，这里是x86_64-w64-mingw32-gcc）
一个小探究，这里发现mingw的bin文件夹下除了x86_64-w64-mingw32-gcc还有一个gcc文件，但当我们在cmd中查看他们各自的版本时发现提示是一样的
C:\Users\Lenovo&gt;gcc -v Using built-in specs. COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
C:\Users\Lenovo&gt;x86_64-w64-mingw32-gcc -v Using built-in specs.
COLLECT_GCC=x86_64-w64-mingw32-gcc
COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
应当是都被重定向到了同一个可执行文件
2、安装Vscode插件 C/C++
Cmake
Cmake Tools
3、CMake介绍 CMake是一个跨平台的Makefile生成工具
依赖的文件是CMakeLists.txt，其作用简单归结为：
cmake执行CMakeLists.txt生成Makefiles，然后make执行Makefiles，调用Makefiles中一系列gcc编译生成可执行的目标文件
在这个过程中，make有不同的工具，gcc也有不同的工具，因此在整个工具链中需要进行配置。例如如果是生成windows可执行文件，Cmake就要配置生成MinGW Makefiles，执行Makefiles要选择mingw32-make，编译器要选择x86_64-w64-mingw32-gcc
4、VScode中CMake的使用 shift+ctrl+P:并输入如下指令
cmake:quick start
为本工程开启CMake tools 然后就会看到cmake tools在vscode中的UI
可以点击这里
来进行配置编译器的选择，比如mingw编译器或者arm交叉编译器
5、操作流程（简易版Cmake，无文件层次） 5.1创建文件夹并在VScode中打开 在桌面上新建了一个空文件夹test_hello，并在VScode中打开文件夹
5.2创建文件hello.c hello.c
#include&lt;stdio.h&gt; int main(){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e69f25f071494f1594eb5885b8861f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5b7e637dd3e4e3e6cfa9550f697ab7/" rel="bookmark">
			对于函数和的基础1（初学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的求和方法是使用 方法一 进行直接求和，用函数的方法进行求和就是像 方法二 那般。
//方法1：直接求和 #include&lt;stdio.h&gt; int main()
{
int num1,num2;
scanf("%d,%d",&amp;num1,&amp;num2);
int numtotal=num1+num2;
printf("total number is %d",numtotal);
return 0;
}
使用函数进行求和时，应该先定义一个函数，下面的例子是sum，然后在主函数部分中使用。
使用函数好比是先写好一篇论文，后面别人直接拿来引用就好了。
// 方法二 用函数来计算num1 和 num2的值 #include&lt;stdio.h&gt; //定义一个sum函数 int sum(a,b)//sum 为函数名 ，a，b为其中变量 {
int z=a+b; return z;// return z 表示返回z的值，就是执行完sum函数后sum的值 };
//主函数部分
int main()
{
int num1,num2;
scanf("%d,%d",&amp;num1,&amp;num2);
int numtotal=sum(num1,num2);//执行sum函数 ，将sum函数返回的值放入 numtotal printf("total number is %d",numtotal);
return 0;
}
数组部分（基础）
#include&lt;stdio.h&gt;
int main()
{
int arr[10]={1,2,3,4,5,6,7,8,9,10};//定义数组，在名字为arr的数组中有10个格子，每个格子中的数字分别是1,2,3,4,5,6,7,8,9,10。 若是没有赋值的格子则是默认为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5b7e637dd3e4e3e6cfa9550f697ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fdcc0f93225576bd56620fd9cb8deb/" rel="bookmark">
			Java | this和super关键字【深入理解子类和父类的继承关系】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文，我们来深入讲解一下通过this和super这两个关键字反映的子类和父类的继承关系
一、关键字介绍及引入 1、this关键字 this关键字是什么？ 之前我们在讲类的static关键字时也有提到过this关键字，它可以用来访问当前对象的成员变量和成员方法
this是一个引用，是一个变量，this变量中保存了内存地址指向了自身，它存储在JVM堆内存中Java对象的内部
==有关使用格式在下面super关键字中一起说明==
2、super关键字 super关键字是什么？ 对于super关键字，这个是在Java中出现的，而C++中没有，它表示子类继承父类之后可以通过这个关键字去访问父类的一些成员变量和成员方法，以及可以通过这个关键字去实现父类的构造器
this和super关键字要怎么使用（附有表格插图） 有关这个，我在上面的this关键字中并没有提到具体的使用格式，这里一并说明:book: 从上述表格我们可以很清晰的看出这两个关键字的使用方法和格式，主要是this.和this()以及super.和super()这两种方法，this.和super.主要是用于访问成员方法和成员变量，我们不做过多讲解，后面主要讲解的是this()和super()这两种如何去访问本类和父类的构造器 二、关键字的使用及分步讲解 1、this关键字 this关键字的基础应用 接下来分别来讲一下this关键字在构造方法和实例方法中的应用
public class People { String name; int leg,hand; People(String name){ this.name = name; this.init();	//可省略 } void init(){ leg = 2; hand = 3; System.out.println(name + "有" + leg + "条腿" + hand + "双手"); } public static void main(String[] args) { People people = new People("奥巴马"); } } 复制代码 首先是在构造方法中，从People类的有参构造中我们可以看出，不仅初始化了name成员变量，而且调用了成员方法init()，这里都是使用到了this关键字，但是这个this关键字对于成员变量和成员方法的调用时可以省略的，因为这个关键字即使你没写的话它系统中也是会默认有的 class A{ int x; static int y; void f(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4fdcc0f93225576bd56620fd9cb8deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22323936365101cc5db8b6d33694c289/" rel="bookmark">
			【Python】TypeError: __init__() takes 1 positional argument but 2 were given
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 以下代码使用关键词参数时出现错误：
TypeError: __init__() takes 1 positional argument but 2 were given
class DAFormerHead(BaseDecodeHead): def __init__(self, **kwargs): super(DAFormerHead, self).__init__(**kwargs) norm_cfg = dict(type='BN', requires_grad=True) decode_head = dict( # type='DAFormerHead', in_channels=[64, 128, 320, 512], in_index=[0, 1, 2, 3], channels=256, dropout_ratio=0.1, num_classes=1, norm_cfg=norm_cfg, align_corners=False, decoder_params=dict( embed_dims=256, embed_cfg=dict(type='mlp', act_cfg=None, norm_cfg=None), embed_neck_cfg=dict(type='mlp', act_cfg=None, norm_cfg=None), fusion_cfg=dict( # _delete_=True, type='aspp', sep=True, dilations=(1, 6, 12, 18), pool=False, act_cfg=dict(type='ReLU'), norm_cfg=norm_cfg), ), loss_decode=dict( type='CrossEntropyLoss', use_sigmoid=False, loss_weight=1.0)), self.decode_head = DAFormerHead(**decode_head) 分析解决 看代码感觉定义了dict参数后，使用**传参，感觉没问题但却报错了。跟代码发现定义的dict传参时实际是一个tuple，tuple里的元素是dict，因此修改以上代码传参部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22323936365101cc5db8b6d33694c289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e87cdcd7c2363defa36c859266df68/" rel="bookmark">
			git之更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 更新Git(需要先进入目录)(服务器不能立刻更新代码时使用)
git reset --hard
// 将本地作为最新的文件强制提交到服务器(当本地文件不能通过(Force Update)的时候使用)
1.将本地项目和服务端master分支进行同步或Fetch
2.在有冲突的文件右键点击进行OverWrite并Mark一下再Pull
3.若还是不行就修改文件进行提交
4.push到服务器
还可以打开GitStaging进行操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef62ca6d16e0141bfb6e840daf172d4/" rel="bookmark">
			什么是DHCP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCP是动态主机配置协议，英文为Dynamic Host Configuration Protocol。
DHCP功能：
保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。
DHCP应当可以给用户分配永久固定的IP地址。
DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。
DHCP服务器应当向现有的BOOTP客户端提供服务。 DHCP有三种机制分配IP地址：
自动分配方式（Automatic Allocation），DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器端租用到IP地址后，就可以永久性的使用该地址。
动态分配方式（Dynamic Allocation），DHCP服务器给主机指定一个具有时间限制的IP地址，时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。
手工分配方式（Manual Allocation），客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7d4098905bf08498fb4e7d49664d42/" rel="bookmark">
			用js模拟数据结构 栈 结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈是一种遵从后进先出（LIFO）原则的有序集合。 新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。
在栈里，新元素都靠近栈顶，旧元素都接近栈底。
栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。
我们将创建一个类来表示栈。简单地从创建一个stack-array.js文件并声明Stack类开始。 我们需要一种数据结构来保存栈里的元素。可以选择数组。
数组允许我们在任何位置添加或删除元素。
由于栈遵循LIFO原则，需要对元素的插入和删除功能进行限制。
接下来，要为栈声明一些方法。
push(element(s))：添加一个（或几个）新元素到栈顶。
pop()：移除栈顶的元素，同时返回被移除的元素。
peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。
isEmpty()：如果栈里没有任何元素就返回true，否则返回false。
clear()：移除栈里的所有元素。
size()：返回栈里的元素个数。
class Stocck{ construct(){ this.count = 0; this.list = []; } //向栈中插入元素 push(element) { this.items[this.count] = element; this.count++; } //从栈中弹出元素 pop() { if (this.isEmpty()) { // {1} return undefined; } this.count--; // {2} const result = this.items[this.count]; // {3} delete this.items[this.count]; // {4} return result; // {5} } //查看栈顶的值 peek() { if (this.isEmpty()) { return undefined; } return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7d4098905bf08498fb4e7d49664d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0aa46e679eeb0eff5b83bcd7dd32713/" rel="bookmark">
			pandas操作多列计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下，用pandas操作多列计算，得到结果并形成一列新数据的时候，可以用apply来实现。
df = pd.DataFrame({ 'a': [1,2,3,4], 'b': [5,6,7,8], }) def foo(x, y): return x * y df['c'] = df.apply(lambda x: foo(x['a'], x['b']), axis=1) 可对多列数据计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e329e652628491de3ffc7ef0e186fbf8/" rel="bookmark">
			Redis（ 基础篇 ==＞ SpringDataRedis的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章导学：
SpringData与SpringDataRedis介绍RedisTemplate工具类的API使用SpringBoot整合SpringDataRedis 一、什么是SpringDataRedis SpringData是Spring中数据操作的模块，包含了对各种数据库的集成。 其中对Redis的集成模块，就是SpringDataRedis
SpringDataRedis的特点如下：
提供了对不同Redis客户端的整合（Lettuce和Jedis（上一章提到的））
提供了RedisTemplate统一API来操作Redis支持Redis的发布订阅模型支持Redis哨兵和Redis集群支持基于Lettuce的响应式变成支持基于JDK、JSON、字符串，Spring对象的序列化和反序列化支持基于Redis的JDKCollection实现 二、RedisTemplate工具类的API使用 在SpringDataRedis中提供了RedisTemplate工具类，里面封装了对供桌Redis的操作，并且将不同的数据类型的操作API封装到了不同的类型中
API返回类型说明redisTemplate.opsForValue()ValueOperations 操作String类型数据
redisTemplate.opsForHash()HashOperations操作Hash类型数据redisTemplate.opsForList()ListOperations操作List类型数据redisTemplate.opsForSet()SetOperations操作Set类型数据redisTemplate.opsForZSet()ZSetOperations操作SortedSet类型数据redisTemplate通用命令 三、SpringBoot整合SpringDataRedis SpringBoot已经提供了对SpringDataRedis的支持，我们使用起来非常简单
分为以下几个步骤
引入依赖配置文件注入RedisTemplate编写测试 3.1、引入依赖 &lt;!-- Redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; 3.2、配置文件 我们在applicaiton.yml里对Redis做个简单的配置
spring: redis: host: 192.168.75.128 port: 6379 password: 124856 #选择数据库 database: 3 #连接池 lettuce: pool: #最大连接 max-active: 8 #最大空闲连接 max-idle: 8 #最小空闲连接 min-idle: 0 #等待时间 max-wait: 100 3.3、注入RedisTemplat 我们创建个测试类，注入它
3.4、编写测试用例 package com.brrbaii; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e329e652628491de3ffc7ef0e186fbf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff6827f0dc99ade2b9d656cd3bed4c6/" rel="bookmark">
			cannot be resolved to a variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cannot be resolved to a variable 不能解析为变量 1.可能写在了do循环中，成为了局部变量，应该写在外面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3688f911b64ab8b7806d664f32d85bb0/" rel="bookmark">
			uni-app可视化窗口高度兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni-app使用时因为不同的手机，操作系统（os,andriod,微信小程序）,他们的可视化窗口的高度有所不同，此篇是兼容可视化窗口高度的一种方法
&lt;script&gt; export default{ data() { return { //内容快的高度值 clientHeight: 0, }, onReady() { uni.getSystemInfo({ success: (res) =&gt; { //uni.upx2px(80)为顶部topBar的高度 this.clientHeight = res.windowHeight -uni.upx2px(80)-this.getClientHeight() } }) }, methods:{ //获取可视区高度【兼容】 getClientHeight(){ const res = uni.getSystemInfoSync() const system = res.platform if(system === 'os'){ return 44+res.statusBarHeight }else if(system === 'android'){ return 48+res.statusBarHeight }else{ return 0 } } } } &lt;/script&gt; 详细内容请查询uni-app官网，uni.getSystemInfo（）方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de4e6c7340aa3e9cb7b7209ca6653bef/" rel="bookmark">
			记录｜ mac M1 homebrew安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 homebrew官网的代码不管用
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 参照这个知乎文章管用
/bin/bash -c "$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)" 也就是可能连不上raw.githubusercontent.com的服务器但是可以练到gitee.com
执行成功，但是去吃饭之前出现这两个问题（卡住了，还在继续安装， 等回来看看）
没问题
根据文章和提示，开始配置环境变量
查看「终端类型」
echo $SHELL /bin/bash =&gt; bash =&gt; .bash_profile
/bin/zsh =&gt; zsh =&gt; .zprofile
所以本macbookpro的终端默认为zsh，使用.zprofile
对应命令为：
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; ~/.zprofile eval "$(/opt/homebrew/bin/brew shellenv)" 查看是否安装成功
homebrew -v homebrew --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31855f0e9d48612f2a537f18783fbe11/" rel="bookmark">
			内容分发网络（CDN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、原理1. DNS解析2. 使用CDN后的DNS解析3. 负载均衡系统4. 分发服务系统5. 总结 三、作用1. 性能2. 安全 四、使用场景1. 第三方的CDN服务2. 静态资源的缓存3. 直播传送 五、总结五、总结 一、简介 CDN (全称 Content Delivery Network)，即内容分发网络。
构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。
简单来讲，CDN就是根据用户位置分配最近的资源。
于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。如下图：
二、原理 1. DNS解析 CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 www.test.com 的解析过程如下：
（1） 检查浏览器缓存
（2）检查操作系统缓存，常见的如hosts文件
（3）检查路由器缓存
（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询
（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：
根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，该例子中会返回.com的地址接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.test的地址。接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回www.test.com的地址。Local DNS Server会缓存结果，并返回给用户，缓存在系统中。 2. 使用CDN后的DNS解析 未使用CDN缓存
浏览器通过DNS对域名进行解析，依次得到此域名对应的IP地址浏览器根据得到的IP地址，向域名的服务主机发送数据请求服务器向浏览器返回响应数据 使用CDN缓存资源
对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户用户向CDN的全局负载均衡设备发起数据请求CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备全局负载均衡设备把服务器的IP地址返回给用户用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。 如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。
CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。
3. 负载均衡系统 由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到CDN的全局负载均衡系统进行智能调度：
看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点看用户所在的运营商网络，找相同网络的边缘节点检查边缘节点的负载情况，找负载较轻的节点其他，比如节点的“健康状况”、服务能力、带宽、响应时间等 总结，得到最合适的边缘节点，然后把这个节点的IP返回给用户，用户就能够就近访问CDN的缓存代理。
整体流程如下图：
4. 分发服务系统 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。 5. 总结 应用CDN前： 用户提交域名→浏览器对域名进行解释→DNS 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复 应用CDN后： DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡。CNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键。 三、作用 CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31855f0e9d48612f2a537f18783fbe11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54bcc219ec7db9c585b37629b97ddab/" rel="bookmark">
			MySQL 索引结构用B&#43;树的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引(Index) 二叉树、平衡二叉树、红黑树、B树、B+树与B*树 一、MySQL 索引为什么用 B+ 树而不是 B 树 【B+树的磁盘读写代价更低】B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO 读写次数就降低了。
【B+树的查询效率更加稳定】由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可。但是B树因为其分支结点同样存储着数据，要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况。
B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决此问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。
二、MySQL 索引为什么用 B+ 树而不是红黑树 Mysql 如何衡量查询效率呢？磁盘IO次数。红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以选取 B+ 树。B+ 树可以有多个子女，从几十到上千，可以降低树的高度。
三、MySQL 索引为什么用 B+ 树而不是跳表 【B+树结构】
B+数是平衡多路查找树。特点是一个结点上可以存储多个元素，带来了扇出较高的优点。只需要很少的层数就可以存储大量的数据。和B树相比，它在叶子结点上存储所有的数据。
【跳表】
跳表也是分层的。每一层都是一个链表。除了最下面的一层，每个元素除了有指向下一个元素的指针，还有一个指针指向下一层中和自己相同的元素。上一层的链表做为索引加快对下层链表元素的查找。每一层元素都是顺序排列的。当插入一个元素时，使用随机函数决定其是否在每一层插入。在最底层插入的概率是100%，在倒数第二层是50%，依次类推。这样在从最上层往下查询时就实现了二分查找的效果。
B+ 树具有较高的扇出，即一个结点可以有成百上千个子节点。这种结构导致了B+数只需要3层就大概可以存储2kw的数据。而存储同样数据量的数据，跳表如果要达到二分查找的效果需要20多层。MySQL 的数据是存储在磁盘中的，层数越多磁盘 IO 的次数就越多。所以选择层数较少的 B+ 树做为 MySQL 索引的底层结构。
Redis 的 zset 为什么又用跳表实现 因为Redis是内存数据库，没有磁盘IO的问题。层数多一些不是明显的问题。
四、InnoDB 的 B+ 树可以存放约 2 千万行数据 为什么？要搞清楚这个问题，先从 InnoDB 索引数据结构、数据组织方式说起。计算机在存储数据的时候，有最小存储单元，这就好比今天进行现金的流通最小单位是一毛。
计算机磁盘存储数据最小单元是扇区，一个扇区的大小是 512字节。文件系统(例如 XFS/EXT4)的最小单元是块，一个块的大小是 4K。InnoDB 存储引擎最小储存单元是页(Page)，一个页的大小是 16K。 文件系统中一个文件大小只有 1 个字节，但不得不占磁盘上 4KB 的空间。
InnoDB 的所有数据文件(后缀为 ibd 的文件)大小始终都是 16384(16K)的整数倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54bcc219ec7db9c585b37629b97ddab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b42b21a11235c024bb5bc7365504972/" rel="bookmark">
			VsCode中使用git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否厌倦了每天早上到公司都要打开git 小黑框,执行git clone 地址去拉取代码,而强大的VsCode只需要点一下即可解决。
1.添加到暂存区，更改文件以后可以发现
点进去上图这个标志,如果没有，右击左侧菜单栏点击源代码管理。
可以看到vscode自动监听到了我更新的内容,点击加号可以将文件提交到暂存区
2.添加到本地仓库
暂存的修改就是暂存区,点击提交可以将代码提交到本地仓库,提交上面的输入框就是备注信息。
3.连接远程仓库 点击三个点 点击远程 点击添加远程仓库
输入仓库http地址
输入仓库名字 ,连接完成注意如果出现警告就是你没有拉取远程仓库的代码,就直接写了,找个地方先拉取远程代码,再进行提交修改。
4.提交代码
熟悉的三个点,点击拉取，推送,再点击推送到，会出现。
点击 origin完成推送。
5.之后每天拉取代码只需点击左下角的即可。
6.创建分支 三个点,分支,添加分支,输入分支名字
点击左下角上图标志会出现
此标志代表是本地分支, 代表是远程分支。可以看到我创建了一个test分支,默认来说本地有,但是远程不会有,因为没进行提交的情况来说,创建分支以后我提交了吗,没有,远程也不会有。我的有是我提交到远程了。
7.切换分支
点击哪一个就会切换到哪一个分支。
8.合并分支
三个点,分支,合并分支,会出来悬浮框问你合并哪一个分支进行选择即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113c35ce1be102a47b24aa6e03aebd1d/" rel="bookmark">
			pip install -r requirements.txt 超时 以及WARNING: Retrying (Retry(total=X ... 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pip install -r requirements.txt 经常会下载一些大的软件或第三方库，这就肥肠缓慢且容易超时。{PS：记得关VPN}
有可能会出现以下现象
因此，pip install 的时候换源这个第一方法就出现了(尝试切换国内源，下载速度会快很多)
1.清华：http://pypi.tuna.tsinghua.edu.cn/simple/[不过现在清华源大行其道，建议如果网速无明显改进，还是用下面的]
2.阿里云：http://mirrors.aliyun.com/pypi/simple/
3.中国科技大学 http://pypi.mirrors.ustc.edu.cn/simple/
4.华中理工大学：http://pypi.hustunique.com/
5.山东理工大学：http://pypi.sdutlinux.org/
6.豆瓣：http://pypi.douban.com/simple/
pip install -r requirements.txt -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com or
pip install -r requirements.txt -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com ERROR: Could not find a version that satisfies the requirement XXX == 1.0.0 (from versions: none)
ERROR: No matching distribution found for XXX==1.0.0
如果出现上述问题，将http改成https即可
其次，出现read time out的问题，那我不换源，改时间总行吧：
原先的代码上面也可以加上–default-timeout=xxx (xxx表示时间)
如
pip install -r requirements.txt -i http://pypi.tuna.tsinghua.edu.cn/simple/ --default-timeout=5000 或者直接运行：pip --default-timeout=1000 install -U pip，修改下载设置时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113c35ce1be102a47b24aa6e03aebd1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6967a31e8f69ebe5c0432abbb490b8/" rel="bookmark">
			Mysql解决中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql字符编码的设置以及mysql中文乱码的解决方法(治本) 2.1解决策略一： 最近在开发过程中，使用到mysql的数据库，而在将中文数据插入到数据库的时候出现了数据乱码的问题，在网上找了很多方法，问了很多人，试了很久才发现网上有的方法是不行的，因此在此记录下，以便他人查找。
查看字符编码
首先，将中文插入到数据库乱码是因为没有将数据库编码设置为支持中文的编码，mysql的默认编码是Latin1，不支持中文，应该设置为utf8查看自己的数据库编码是否已设置好，进入数据库，输入：show variables like "char%"，如果出现下面的结果
说明你的数据库编码正确，无需修改，应该是页面或者其他编码的问题。如果跟上面的结果不同，说明需要修改数据库的编码。
在windows系统下
1、在mysql的安装目录下找到my.ini文件(如果没有的话就把my-medium.ini复制，然后重命名为my.ini即可)
2、在my.ini文件中找到[client]和[mysqld]字段，在下面均加上default-character-set=utf8，保存并关闭
3、重启mysql服务
在linux系统下
1、打开配置文件，我使用的linux版本是ubuntu，配置文件在/etc/mysql/my.cnf
2、在[client]和[mysqld]字段下面均添加default-character-set=utf8，保存并关闭
3、重启mysql服务
注意：
如果重启成功，并查看数据库编码，如果结果如下
恭喜你，说明你已经修改成功了
如果在linux下重启mysql服务的时候出现Job failed to start，在window下重启失败，这是因为你安装了高版本的mysql(mysql5.5以上)，在高版本对字符编码方式修改的办法中，在[mysqld]下的修改发生了变化，正确方式如下：
[mysqld]下添加的应该为：
character-set-server=utf8
collation-server=utf8_general_ci
重启mysql，现在再次查看字符编码，如果跟下面一致，说明成功了
好吧，以上就是mysql字符乱码问题的解决，自己想记录下来，方便自己以后再次用到或者为别人需要是查阅，如果有错误的地方，请指出，谢谢。
----------------------------------------------------------------------
2.2解决策略二（治标）： MySQL会出现中文乱码的原因不外乎下列几点：
1.server本身设定问题，例如还停留在latin1
2.table的语系设定问题(包含character与collation)
3.客户端程式(例如php)的连线语系设定问题
强烈建议使用utf8!!!!
utf8可以兼容世界上所有字符!!!!
一、避免创建数据库及表出现中文乱码和查看编码方法
1、创建数据库的时候：
CREATE DATABASE `test` CHARACTER SET 'utf8' COLLATE 'utf8_general_ci'; 2、建表的时候 CREATE TABLE `database_user` ( `ID` varchar(40) NOT NULL default '', `UserID` varchar(40) NOT NULL default '', ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这3个设置好了，基本就不会出问题了,即建库和建表时都使用相同的编码格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6967a31e8f69ebe5c0432abbb490b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099494194db8239c204d782fc4167cfb/" rel="bookmark">
			SLB-负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负载均衡技术原理浅析 https://help.aliyun.com/knowledge_detail/39444.html?spm=5176.7839438.2.6.XBbX5l
阿里定制版的LVC 开源地址：https://github.com/alibaba/LVS?spm=5176.7739444.2.10.WxLaqZ
更新时间：2016-07-12 13:21:10 1、技术架构
2、LVS技术特点
FULLNAT技术概述
SYNPROXY技术概述
集群部署方式
Keepalived优化
3、Tengine技术特点
4、更多功能
SLB（Server Load Balancer）服务通过设置虚拟服务地址（IP），将位于同一地域（Region）的多台云服务器（Elastic Compute Service，简称ECS）资源虚拟成一个高性能、高可用的应用服务池；再根据应用指定的方式，将来自客户端的网络请求分发到云服务器池中。
SLB服务会检查云服务器池中ECS的健康状态，自动隔离异常状态的ECS，从而解决了单台ECS的单点问题，同时提高了应用的整体服务能力。在标准的负载均衡功能之外，SLB服务还具备TCP与HTTP抗DDoS攻击的特性，增强了应用服务器的防护能力。
SLB服务是ECS面向多机方案的一个配套服务，需要同ECS结合使用。
1、技术架构 整个负载均衡系统由3部分构成：四层负载均衡、七层负载均衡和控制系统，如下图所示：
四层负载均衡
采用开源软件LVS（Linux Virtual Server）构建，并根据云计算需求对其进行了定制和优化。
七层负载均衡
采用开源软件Tengine构建。
控制系统
用于配置和监控负载均衡系统。
2、LVS技术特点 LVS是全球最流行的四层负载均衡开源软件，可以实现LINUX平台下的负载均衡。
LVS是 基于Linux Netfilter框架实现的一个内核模块（ IPTables是基于Netfilter基本架构实现的一个可扩展的数据报高级管理系统或核外配置工具），名称为IPVS。其钩子函数分别HOOK在LOCAL_IN和FORWARD两个HOOK点，如下图所示：
在云计算大规模网络环境下，官方LVS存在如下问题：
问题1：LVS支持NAT/DR/TUNNEL三种转发模式，上述模式在多VLAN网络环境下部署时，存在网络拓扑复杂，运维成本高的问题。
问题2：和商用负载均衡设备（如F5等）相比，LVS缺少DDOS攻击防御功能。
问题3：LVS采用PC服务器，常用Keepalived软件的VRRP心跳协议进行主备部署，其性能无法扩展。
问题4：LVS常用管理软件Keepalived的配置和健康检查性能不足。
为了解决上述问题， SLB在官方LVS基础上进行了如下定制化和优化：
解决1：新增转发模式FULLNAT，实现LVS-RealServer间跨VLAN通讯。
解决2：新增了SYNPROXY等TCP标志位DDOS攻击防御功能。
解决3：采用LVS集群方式部署。
解决4：对Keepalived的性能进行了优化。
Aliyun-LVS开源地址： https://github.com/alibaba/LVS 。 更多相关说明如下所述。
FULLNAT技术概述 如下图所示，FULLNAT主要实现方式为：
引入local address（内网IP地址）。cip-vip转换为lip-&gt;rip，而 lip和rip均为IDC内网IP，可以跨VLAN通讯。
IN/OUT的数据流全部经过LVS，为了保证带宽，采用万兆（10G）网卡。
FULLNAT转发模式，当前仅支持TCP协议。
SYNPROXY技术概述 LVS针对TCP标志位DDOS攻击，采取如下策略：
对于SYN flood类型攻击，利用SYNPROXY模块进行防御。
如下图所示，主要实现方式为：参照Linux TCP协议栈中SYN cookie的思想，LVS代理TCP三次握手。代理过程：
1) Client发送SYN包给LVS。
2) LVS构造特殊SEQ的SYN ACK包给Client。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099494194db8239c204d782fc4167cfb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/208/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>