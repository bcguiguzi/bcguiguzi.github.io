<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08e31fa52979ae8ae191dd00a4044b9/" rel="bookmark">
			数组与指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个不带下标的数组名就是一个指向此数组的指针，具体来说就是第一个数组元素的地址。当一个指针变量被初始化为数组名时，就说该指针变量指向了数组（首元素）。
char str[20],*pstr; pstr=str 等价于 pstr=&amp;str[0]; 指针被置为指向数组（第一个元素），或者说指针存储了数组第一个元素的地址。
访问数组第6个元素，可以通过不同的方式：str[5], pstr[5], *(str+5), *(pstr+5)。
值得注意的是，pstr 是一个可以变化的指针变量，因此 pstr++; ++pstr; pstr+=5 都是正确的，而str是一个常数。因为数组一经声明定义，数组的地址也就被固定了，故 str++; ++str; str+=5 都是错误的。
任何能由数组下标完成的操作也可由指针来完成。编译系统在处理str[i]时，实际上就是将数组元素下标引用 str[i] 转换为等效的指针偏移表达式 *(str+i)，然后再进行取值运算的。
需要注意的是，虽然基于数组名脚标引用时按数组元素的size为单位执行偏移计算，但是针对数组名本身的计算释义时稍有不同。典型的如sizeof(str)=20，正如 sizeof(int)=sizeof(char[4])=4，sizeof(str) 是计算str这种类型的字节数。str 的类型是 char[20]，等效于 sizeof(char[20])。
那么，&amp;str 代表什么呢？&amp;str+1 到底指向了哪里呢？
&amp;str 取地址得到指针，这种指针指向的类型是 char[20]。因此，&amp;str+1 将偏移 sizeof(str)，即偏移一个 char[20] 数组的字节数，指向下一个数组（的首元素）。
二维数组稍有不同，相应的引用二维数组 a[i][j] 则等价于 (*(a+i))[j] 或 *(*(a+i)+j),通常式子 *(a+i)+j 是用来计算元素所在内存地址，并不是它的内容。
int a[3][4]; //二维整型数组，从右往左看，把一维数组int[4]当做一种类型，则a表示3个（int[4]），即成了数组(int[4])的数组。二维数组的元素类型为int[4]。
int *q[12]; //整形指针数组，可以指向12个整数a[0][0]~a[2][3]
int (*p)[4]; //整型数组指针，指向 int[4] 类型
这里数组名a的含义为指向二维数组第一个元素（int[4]型）的指针，针对a的算术运算是以一维数组int[4]为单位“1”进行偏移。
p=a; 中p指向a[0]，则 p+1 不是指向a[0][1]，而是指向 a[1]。需要注意的是 sizeof(p)=4，sizeof(a)=48。
/*二维数组即数组指针测试例程*/ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08e31fa52979ae8ae191dd00a4044b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d64cc8cc2bda544f7bbe9cfc665642/" rel="bookmark">
			【网络安全】手机不幸被远程监控，该如何破解，如何预防？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机如果不幸被远程监控了，用三招就可以轻松破解，再用三招可以防范于未然。 三招可破解可解除手机被远程监控
1、恢复出厂设置
这一招是手机解决软件故障和系统故障的终极大招。只要点了恢复出厂设置，你手机里后装的各种APP全部将灰飞烟灭。包括病毒软件、流氓软件、黑客木马也同样会付之一炬，但给机主带来的后果就是你存储在手机的数据也会随着付诸东流。所以，使用手机要记得定时做数据备份，尤其是重要数据。
2、修改云备份账号
苹果手机有icloud账号可以云端备份手机的图片、视频、音频、通讯录等等数据；华为手机也有华为云备份；小米等其他手机也有云备份功能；这些备份功能本身是很好的，但有不少人却没有正确使用它。为了自己好记住密码，设置了比较简单的弱口令，或者设置了和其他账号相同的口令。这就导致了密码容易被人暴力破解，或者被连带破解。如果黑客拿到了这些账号，它不用进入你的手机，也能在你的云备份中获取你的重要数据，监视你的一举一动。
面对这种情况，我们要做的就是定期修改云备份账号，并且采用复杂的字母+数字+符号+位数超过8位的密码，并且尽量不要和别的密码重复。有人说这样密码很难记，其实只要你想记始终还是记得住的。还记得以前没有手机的时候，我们轻松就可以记住几十个亲人朋友的电话号码。如果实在记不住，可以在家中自己的笔记本中记录下这些复杂密码，并放置在安全的地方。
【值得注意的是，如果你的密码被黑客修改后，你就无法进入了。如果你没有一点技术傍身，很难保障自己的安全。】
当然，前面提的这些技术我都整理录制成了视频教程，对网络安全&amp;黑客技术感兴趣的都可以来领取一下。
3、安全方式安装APP
为了防止手机被病毒、木马感染，我们应该选择安全方式去安装我们想要的APP。那如何以安全的方式安装手机APP呢？就三个原则：
在正规的知名的应用市场上安装必须要用的APP，或者在APP开发商的官方网站下载安装APP；
不应该给APP的权限，一律不允许。尤其是敏感的摄像头、麦克风、通讯录、电话权限；
定期检查手机APP的运行情况，比如：是否出现偷跑流量的，是否出现偷偷后台运行的；
三招预防手机被远程监控
出了问题再来应对总是滞后的，在出问题之前多做预防措施，避免出现问题才是上上之策。对于手机被远程个监控，也有三招可以预防。
1、不用弱密码、远离劣质应用和网站
弱密码是所有系统的重要安全危害之一。在使用手机系统时，为了安全起见，请尽量使用弱密码。很多人可能不知道什么叫做弱密码？其实弱密码就是指非常容易被猜到或者非常容易被计算出来的密码。比如：生日密码、规律数字、简单英文单词等等。这些都不应该作为APP的网络密码。
除了弱密码，日常使用手机过程中还要尽量远离劣质APP和不健康网站。因为它们都很容易被挂马，从而在用户不知情的情况下，远程监控手机。
2、定时备份数据、保持更新
为了预防在出问题的时候，数据依然可以被恢复，建议对手机重要数据定时做备份。备份方式可以通过云端备份，也可以本地备份到电脑或者移动硬盘。备份周期建议至少1个月备份一次。
除了备份数据，在日常使用手机过程中，如果碰到手机有安全更新，建议及时更新安全补丁。这样系统或者程序的漏洞就会被及时修补，减少被病毒、木马、黑客程序利用的机会。
3、机不离身，维修也不例外
手机如果离开了自己的视线，而且又是在解锁状态下的话。什么安全都是白搭，因为别有用心的人可以在你不知情的情况下安装了远程监视的木马，又或者直接在你手机的机器里放入了监听芯片。所以，日常使用手机，在解锁状态下一定要做到机不离身。在维修的时候，也要关注自己手机的安全。
总结 手机被远程监控虽然不是很常见，但如果不幸被远程监视，那损失可就不可估量，应该尽快按照上面的三个方法来应急处理。为了尽量减少这样的不幸发生，我们也可以按照预防的三招来安全使用手机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f24ca3094e519e792938b5699012860/" rel="bookmark">
			Java项目各框架部署教程合集-持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、项目部署1、SSM+微信小程序2、spring boot+vue前后端分离3、spring boot+vue+微信小程序4、spring boot+LayUI/vue前后端不分离 二、环境安装 前言 Java项目各框架部署教程合集-持续更新，你将会在这学习到怎么将项目部署到自己电脑、以及java等环境安装。
一、项目部署 1、SSM+微信小程序 SSM+微信小程序部署【通用教程】
2、spring boot+vue前后端分离 大学生校园社团管理系统部署
3、spring boot+vue+微信小程序 基于spring boot+vue微信小程序文创商城部署教程
4、spring boot+LayUI/vue前后端不分离 文章：https://blog.csdn.net/m0_51607907/article/details/130641049
二、环境安装 https://blog.csdn.net/m0_51607907/article/details/130681093
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0657f9e56ff6934b15af77fbc467c13/" rel="bookmark">
			计算机中有符号数的表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 二进制数制十进制二进制位模式 基本数据类型无符号数的编码有符号数的编码原码（Sign-Magnitude）反码（Ones' Complement）补码（Two's Complement）概念导读编码格式按权展开补码加法溢出判断 扩展一个数字的位表示有符号数和无符号数之间的转换参考 二进制数制 所谓数制是指计数的方法。
十进制 人两手加起来共10根手指，故日常计数和做算术都使用十进制。大家熟悉并使用了一千多年的十进制起源于印度，在12世纪被阿拉伯数学家改进，并在13世纪被意大利数学家Leonardo Pisano（Fibonacci）带到西方。1、2、3的罗马计数法是Ⅰ、Ⅱ、Ⅲ，Ⅰ+Ⅱ=Ⅲ 直观展示了加法运算的含义。
数据无论使用哪种进位制，都涉及两个基本要素：基数（radix）与各数位的“位权”（weight）。
十进制数有两个特点：
用0、1、2、3、…、9这10个基本符号表示；基本数字符号（数码）的个数叫基数。遵循“逢十进一”原则，每位计满十时向高位进一。 一般地，任意一个十进制数 N 都可以表示为 ∑ i = − m n − 1 K i ∗ 1 0 i \sum_{i=-m}^{n-1}K_i\ast10^i ∑i=−mn−1​Ki​∗10i：
N = K n − 1 ∗ 1 0 n − 1 + K n − 2 ∗ 1 0 n − 2 + ⋯ + K 1 ∗ 1 0 1 + K 0 ∗ 1 0 0 + K − 1 ∗ 1 0 − 1 + K − 2 ∗ 1 0 − 2 + ⋯ + K − m ∗ 1 0 − m N = K_{n-1}\ast10^{n-1} + K_{n-2}\ast10^{n-2} + \cdots + K_1\ast10^1 + K_0\ast10^0 + K_{-1}\ast10^{-1} + K_{-2}\ast10^{-2} + \cdots + K_{-m}\ast10^{-m} N=Kn−1​∗10n−1+Kn−2​∗10n−2+⋯+K1​∗101+K0​∗100+K−1​∗10−1+K−2​∗10−2+⋯+K−m​∗10−m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0657f9e56ff6934b15af77fbc467c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e720d1a7362ff6e26f2cad53e0715b3/" rel="bookmark">
			Linux之NFS网络文件系统详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华子目录 简介NFS背景介绍注意 生产应用场景NFS工作原理示例图流程 NFS的使用安装配置文件主配置文件分析权限参数/etc/exports文件内容示例 实验1nfs账户映射实验2实验3 autofs自动挂载服务产生原因安装配置文件分析挂载参数 实验4实验5：本机自动挂载光驱 简介 NFS背景介绍 NFS是一种古老的用于在UNIX/Linux主机之间进行文件共享的协议。它古老到你必须穿着白大褂才能接近一台计算机的年代。在那个年代，所有的联网计算机都被认为是可信的，而不像现今这样，任何人都有多种多样方法能连接到你的计算机。因此，NFS在开发的时候专注于快速及易用的文件共享，而忽视了其安全性设计NFS（Network File System，网络文件系统）是FreeBSD支持的文件系统中的一种，它允许网络中的计算机（不同的计算机、不同的操作系统）之间通过TCP/IP网络共享资源，主要在unix系列操作系统上使用。NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中看来，那个远程主机的目录就好像是自己的一个磁盘分区一样。由于NFS支持的功能比较多，而不同的功能都会使用不同的程序来启动，每启动一个功能就会启用一些端口来传输数据，因此NFS的功能所对应的端口并不固定，而是随机取用一些未被使用的小于1024的端口用于传输。但如此一来就会产生客户端连接服务器的问题，因为客户端需要知道服务器端的相关端口才能够连接。此时就需要RPCRPC（Remote Procedure Call，远程过程调用）：由于服务器在启动NFS时会随机选取数个端口号，并主动向RPC注册，所以RPC知道每个NFS功能所对应的端口号，RPC将端口号通知给客户端，让客户端可以连接到正确的端口上去。RPC采用固定端口号port 111来监听客户端的需求并向客户端响应正确的端口号。 注意 在启动NFS之前，要先启动RPC，否则NFS会无法向RPC注册。另外，RPC若重新启动，原来注册的数据会消失不见，因此RPC重启后，它管理的所有服务都需要重新启动以重新向RPC注册。
生产应用场景 NFS网络文件系统很像windows系统的网络共享、安全功能、网络驱动器映射，这也和linux系统里的Samba服务器类似。只不过一般情况下，windows网络共享服务或Samba服务用于办公局域网共享，而互联网中小型网站集群架构后端常用NFS进行数据共享，如果是大型网站，那可能会用到更复杂的分布式文件系统。在企业集群架构的工作场景中，NFS作为所有前端web服务的共享存储，存储的内容一般包括网站用户上传的图片、附件、头像等，注意，网站的程序代码就不要放在NFS共享里了，因为网站程序是开发运维人员统一发布，不存在发布延迟问题，直接批量发布到web节点提供访问比共享到NFS里访问效率会更高些。NFS是当前互联网系统架构中常用的数据存储服务之一，中小型网站（2000万pv(页面浏览量)以下）公示应用频率居高，大公司或门户除了使用NFS外，还可能会使用更为复杂的分布式文件系统 NFS工作原理 示例图 流程 首先服务器端启动RPC服务，并开启111端口之后服务器端启动NFS服务，并向RPC注册端口信息客户端启动RPC（portmap服务），向服务端的RPC（portmap）服务请求服务端的NFS端口服务端的RPC（portmap）服务反馈NFS端口信息给客户端。（服务器搭建成功后可以使用下列命令查看，一般都是2049） NFS的使用 安装 [root@server ~]# yum install nfs-utils -y #安装nfs [root@server ~]# yum install rpcbind -y # 安装rpc，默认已安装 配置文件 主配置文件：/etc/exports，该配置文件不一定存在/usr/sbin/exportfs：该文件是维护NFS共享目录资源的命令文件，可以使用命令重新共享/etc/exports的目录资源、卸载共享目录日志目录：/var/lib/nfs权限设置文件：/var/lib/nfs/etab 主配置文件分析 /etc/exports 文件默认为空文件，需要输入nfs共享命令格式：文件路径 允许访问的NFS客户端IP(权限参数)分析 允许访问的NFS客户端：可以是IP地址或IP网段，如： 192.168.80.129/24192.168.80.130/255.255.255.0192.168.80.0/24*：允许所有主机访问 权限参数 必须写在圆括号中，且括号是紧挨着主机名的，权限的相关参数如下，多个参数之间使用逗号隔开
权限参数作用ro只读rw读写（最终还是看文件系统rwx的权限）root_squash当NFS客户端以root账户访问时，映射为NFS服务器端的匿名账户（nobody），以普通账户访问时，映射为普通账户no_root_squash当NFS客户端以root账户访问时，映射为root账户（不推荐、不安全）all_squash无论NFS客户端使用什么账户访问，均映射为NFS 服务器的匿名账户（nobody）,推荐no_all_squash客户端普通账户访问服务器的数据时，实际的信息原样显示sync同步，同时将数据写入内存与硬盘中，保证数据不会丢失，推荐async异步，优先将数据保存到内存，然后在写入硬盘，效率高，但可能会数据丢失anonuid= anongid=将文件的用户和工作组映射为指定UID和GID，若不指定则默认为65534（nobody） /etc/exports文件内容示例 /home/public *(rw,sync) : 对所有主机共享/home/public目录，可读可写，同步传输/home/public 192.168.48.131/24(ro,all_squash,sync) : 只对131主机开发共享/home/public ，只读权限，客户端映射为nobody账户，同步传输/home/public 192.168.48.0/24(rw , sync , all_squash , anonuid=2000, anongid=2000): 对192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e720d1a7362ff6e26f2cad53e0715b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853b4efe5743520e22d4ea0aece35951/" rel="bookmark">
			推荐一款嵌入式C的开源代码框架-tboox / tbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐理由 这是一款大神级开源代码，基于c语言的，几乎包含了嵌入式开发的各个部分的封装，可以说是嵌入式系统的瑞士军刀！
注：该开源代码作者不是我，我这只是推荐，帮作者宣传。
欢迎关注：fensnote，了解更多有价值内容
简介 TBOX是一个用c语言实现的跨平台开发库。
针对各个平台，封装了统一的接口，简化了各类开发过程中常用操作，使你在开发过程中，更加关注实际应用的开发，而不是把时间浪费在琐碎的接口兼容性上面，并且充分利用了各个平台独有的一些特性进行优化。
这个项目的目的，是为了使C开发更加的简单高效。
目前支持的平台有: Windows, Macosx, Linux, Android, iOS, *BSD等等。
通过xmake支持各种编译模式：
Release: 正式版编译，禁用调试信息、断言，各种检测机制，启用编译器优化Debug: 调试模式，默认启用详细调试信息、断言、内存越界检测、内存泄漏、锁竞争分析等检测机制Small: 最小化编译，默认禁用所有扩展模块，启用编译器最小化优化Micro: 针对嵌入式平台，仅仅编译tbox微内核，仅提供最基础的跨平台接口，生成库仅64K左右（内置轻量libc接口实现） 如果你想了解更多，请参考：在线文档, Github以及Gitee
特性 流库 针对http、file、socket、data等流数据，实现统一接口进行读写，并且支持: 阻塞、非阻塞、异步 三种读写模式。
支持中间增加多层filter流进行流过滤，实现边读取，内部边进行解压、编码转换、加密等操作，极大的减少了内存使用。
主要提供以下模块：
stream：通用非阻塞流，用于一般的单独io处理，同时支持协程以实现异步传输。transfer：流传输器，维护两路流的传输。static_stream：针对静态数据buffer优化的静态流，用于轻量快速的数据解析。 协程库 快速高效的协程切换支持提供跨平台支持，核心切换算法参考boost，并且对其进行重写和优化，目前支持架构：x86, x86_64, arm, arm64, mips32提供channel协程间数据通信支持，基于生产、消费者模型提供信号量、协程锁支持socket、stream都模块原生支持协程，并且可在线程和协程间进行无缝切换提供http、file等基于协程的简单服务器实例，只需几百行代码，就可以从socket开始写个高性能io服务器，代码逻辑比异步回调模式更加清晰同时提供stackfull, stackless两种协程模式支持，stackless协程更加的轻量（每个协程只占用几十个bytes），切换更快（会牺牲部分易用性）支持epoll, kqueue, poll, select 和 IOCP在协程和poller中支持同时等待和调度socket，pipe io和process 数据库 统一并简化数据库操作接口，适配各种数据源，通过统一的url来自动连接打开支持的数据库，数据的枚举采用迭代器模型。目前支持sqlite3以及mysql两种关系型数据库，也可自定义扩展使用其他关系型数据库。 xml库 针对xml提供DOM和SAX两种解析模式，SAX方式采用外部迭代模式，灵活性和性能更高，并且可以选择指定路径，进行解析。解析过程完全基于stream，所以是高度流化的，可以实现边下载、边解压、边转码、边解析一条龙服务，使用较低的内存也可以解析大规模数据。提供xml writer以支持对xml生成 内存库 参考linux内核内存管理机制的实现，并对其进行各种改造和优化，所实现的TBOX独有的一整套内存池管理架构。调试模式下，可以轻松检测并定位内存泄露、内存越界溢出、内存重叠覆盖等常见内存问题，并对整体内存的使用进行了统计和简要分析。针对大块数据、小块数据、字符串数据进行了充分的利用，避免了大量外部碎片和内部碎片的产生。分配操作进行了各种优化，96%的情况下，效率都是在O(1)。 容器库 提供哈希、链表、数组、队列、堆栈、最小最大堆等常用容器。支持各种常用成员类型，在原有的容器期初上，其成员类型还可以完全自定义扩展。所有容器都支持迭代器操作。大部分容器都可以支持基于stream的序列化和反序列化操作。 算法库 提供各种排序算法：冒泡排序、堆排序、快速排序、插入排序。提供各种查找算法：线性遍历、二分法搜索。提供各种遍历、删除、统计算法。以迭代器为接口，实现算法和容器的分离，类似stl，但是c实现的，更加轻量。 网络库 实现http客户端模块实现cookies实现dns解析与缓存实现ssl(支持openssl, polarssl, mbedtls)支持ipv4、ipv6支持通过协程实现异步模式 数学运算库 提供各种精度的定点运算支持提供随机数生成器 libc库 libc的一个轻量级实现，完全跨平台，并且针对不同架构进行了优化。支持大部分字符串、宽字符串操作。扩展字符串、宽字符串的各种大小写不敏感操作接口扩展memset_u16、memset_u32等接口，并对其进行高度优化，尤其适合图形渲染程序 libm库 libm部分接口的一个轻量级实现，以及对常用系统接口的封装。（目前只实现了部分，之后有时间会完全实现掉）扩展部分常用接口，增加对sqrt、log2等常用函数的整数版本计算，进行高度优化，不涉及浮点运算，适合嵌入式环境使用。 object库 轻量级类apple的CoreFoundation库，支持object、dictionary、array、string、number、date、data等常用对象，并且可以方便扩展自定义对象的序列化。支持对xml、json、binary以及apple的plist(xplist/bplist)格式序列化和反序列化。
并且实现自有的binary序列化格式， 针对明文进行了简单的加密，在不影响性能的前提下，序列化后的大小比bplist节省30%。 平台库 提供file、directory、socket、thread、time等常用系统接口提供atomic、atomic64接口提供高精度、低精度定时器提供高性能的线程池操作提供event、mutex、semaphore、spinlock等事件、互斥、信号量、自旋锁操作提供获取函数堆栈信息的接口，方便调试和错误定位提供跨平台动态库加载接口（如果系统支持的话）提供io轮询器，针对epoll, poll, select, kqueue进行跨平台封装提供跨平台上下文切换接口，主要用于协程实现，切换效率非常高 压缩库 支持zlib/zlibraw/gzip的压缩与解压（需要第三方zlib库支持）。 字符编码库 支持utf8、utf16、gbk、gb2312、uc2、uc4 之间的互相转码，并且支持大小端格式。 实用工具库 实现base64/32编解码实现crc32、adler32、md5、sha1等常用hash算法实现日志输出、断言等辅助调试工具实现url编解码实现位操作相关接口，支持各种数据格式的解析，可以对8bits、16bits、32bits、64bits、float、double以及任意bits的字段进行解析操作，并且同时支持大端、小端和本地端模式，并针对部分操作进行了优化，像static_stream、stream都有相关接口对其进行了封装，方便在流上进行快速数据解析。实现swap16、swap32、swap64等位交换操作，并针对各个平台进行了优化。实现一些高级的位处理接口，例如：位0的快速统计、前导0和前导1的快速位计数、后导01的快速位计数实现单例模块，可以对静态对象、实例对象进行快速的单例封装，实现全局线程安全实现option模块，对命令行参数进行解析，提供快速方便的命令行选项建立和解析操作，对于写终端程序还是很有帮助的 正则表达式库 支持匹配和替换操作支持全局、多行、大小写不敏感等模式使用pcre, pcre2和posix正则库 一些使用tbox的项目： gboxvm86xmakeitrace更多项目 使用 Xmake 编译 请先安装: xmake
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853b4efe5743520e22d4ea0aece35951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322390c6d3287fc0b4ae0493d10ae8e9/" rel="bookmark">
			Material Studio 中 DMol3 计算材料吸附能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.先导入Cif文件 2.切表面 3.沿着你要切的晶面切 4.扩胞 5.加真空层（一般加10埃） 现在就是这样的了 6.然后对其结构优化（高斯几何优化） 7.再在体系上加原子或者想要的材料 8.Outmal文件中最后的Ef就是整个体系的能量，然后按照最开头的公式进行计算就可以得出物质表面的吸附能量，一般为负值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70de82fa1e1315c25dfc65d4f461672b/" rel="bookmark">
			从零开始利用MATLAB进行FPGA设计（一）：建立脉冲检测模型的Simulink模型1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章灵感来源于MATLAB官方免费教程：HDL Coder Self-Guided Tutorial
考虑到MATLAB官网的英文看着慢，再加上视频讲解老印浓浓的咖喱味，我决定记录利用MATLAB&amp;Simulink&amp;SystemGenerator进行FPGA数字信号处理的学习过程。
在进行数字信号处理的算法验证阶段，主要是通过MATLAB进行算法设计，然后用Simulink模块化进行算法验证。
1.MATLAB参考算法 1.1创建输入模拟 % Setup clear; clc; close all; % Create pulse to detect rng('default'); PulseLen = 64; theta = rand(PulseLen,1); pulse = exp(1i*2*pi*theta); % Insert pulse to Tx signal rng('shuffle'); TxLen = 5000; PulseLoc = randi(TxLen-PulseLen*2); TxSignal = zeros(TxLen,1); TxSignal(PulseLoc:PulseLoc+PulseLen-1) = pulse; % Create Rx signal by adding noise Noise = complex(randn(TxLen,1),randn(TxLen,1)); RxSignal = TxSignal + Noise; % Scale Rx signal to +/- one scale1 = max([abs(real(RxSignal)); abs(imag(RxSignal))]); RxSignal = RxSignal/scale1; 这段代码主要执行了以下操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70de82fa1e1315c25dfc65d4f461672b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ee0a38bb55ecd1330277cb3ceb8f3a/" rel="bookmark">
			一、Abaqus CAE 入门操作（薄膜应力计算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先双击APP进入 2.选择“创建标准模型” 3.点击“创建部件” 4.参数按照我这个选就行，一般都是三维实体，所以不需要变动，然后点继续 5.然后点“创建线” 6.在格子中随便拉一个矩形 7.点"添加尺寸"来设置长宽 8.然后点一下这个矩形的边就可以设置了 9.左下角设置具体数值 10.设置好了后，按鼠标滚轮确认，然后设置厚度（鼠标滚轮是快捷键） 11.到这里你就会得到这样的板子一个 12.给材料上属性 13.点“创建材料” 14.点通用-密度，然后在下面的质量密度输入你的材料密度值 15.点力学-弹性-弹性 16.输入你材料的弹性模量和泊松比，然后点确定 17.创建界面（基本不用改，点继续再确定就行） 18.点指派截面，选中板子，按鼠标滚轮确定 19.然后会发现板子变绿了 20.然后装配-Create Instance-直接点确定就行 21.分析步（告诉计算机你要解决什么问题）-创建分析步 22.线性振动-频率-继续（根据你的需求来） 23.输入震动特征值个数-确认 24.载荷-创建边界条件-位移/转角 25.选中这个面-滚轮确定-六个全选上 26.网格-部件-种子部件-确定-为部件划分网格 27.作业-创建作业-继续-确定-作业管理器-提交 28.正在计算-已完成-结果 29.绘制云图 搞定 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd7188934b02aea5a87e2d034b66c97/" rel="bookmark">
			用Origin快速拟合荧光寿命、PL Decay (TRPL)数据分析处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要准备材料：Origin、PL Decay数据txt文件 首先打开Origin画图软件 导入数据，按照下图箭头操作直接导入 双击你要导入的PL Decay的txt数据文件，然后点OK 继续点OK 数据导入后首先删除最大光子数之前的无效数据，分析的时候用不着，这里我最大的采集光子数为5000，那我就删除5000最大光子数之前的数据 然后打开PL Decay的txt数据文件，里面有一个参数：Time Calibration，记住这个值，这是时间校准参数，后面用得着 把第一列数据乘以刚刚的时间校准参数值，我这里是0.868，这个值根据仪器、测试样品不同而不同 时间参数校准后，再把第一列的所有值减去第一个值，第一个值对应为最大光子数的采集时间，减掉它，我这里时间参数校准后为30.38，那我就第一列所有值减去30.38 减完后第一列第一个值变为0 选中两列数据画散点图 画出散点图会出现“Speed Mode is On”，这是由于数据太多被简化了，下一步去掉这个简化模式 按照下面的操作就行 会发现简易模式被关掉了 双击纵坐标轴，对其取对数，按照如下操作 取完对数后调整一下显示范围让图像居中，这样美观一点，双击纵坐标轴，选择“Scale”板块，将Vertical的From改为合适的数值，这个根据你具体的图像取就行 得到我们处理好的图像 按照下面的操作分析数据 继续按照操作，Decay1、2、3到底用哪个根据具体情况，你看哪个能更加符合你的拟合曲线，我这里用Decay3 固定Fixed 0，前面打勾就行，不固定数据会发生变化 拟合完毕拟合完会自动出现拟合结果，然后就计算长短寿命的占比就行了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e87b491ed1d76d08889829d859eb9d/" rel="bookmark">
			创建vue3 ts项目 tsc.config在vscode下标红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3+TypeScript+Pinia初始化项目，vscode报错解决办法！_vscode vue3+ts 老是提示代码错误-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e6f0d0af0e6be7a2f93b8c020599f5/" rel="bookmark">
			http协议-基于TCP的超文本传输协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过http最终实现一个效果 用我们自己电脑上的浏览器去访问我们自己写的python程序，这个程序就可以满足浏览器的需求，你可以从浏览器里面看到自己写出来的网页。所谓的协议就是一种规定。
二、http协议 正常情况下www.xxx是域名，将来通过相应的协议会变成相应的IP地址，浏览器向服务器发送的请求，浏览器给予相应的回应；
头和内容之间以一个空行进行区别。
简单web服务器实现 import socket def service_client(new_socket): """为这个客户端返回数据""" #1.接收浏览器发送过来的请求，即HTTP发送来的请求 #GET /HTTP/2.0 #... request=new_socket.recv(1024)#一般来说应该空间是够了 print(request) #2.返回HTTP格式的数据给浏览器 #2.1准备发送给浏览器的数据--head就是HTML那些 response="http/2.0 200 OK\r\n"#浏览器不能解析换行符/n，必须使用/r/n的方式 response+="\r\n"#不可或缺的换行符，代表着body即将到来 #2.2准备一些--body部分内容，准备给浏览器送去 #response+="&lt;h1&gt;xixizi&lt;/h1&gt;" response+="xixizi" new_socket.send(response.encode("utf-8")) #关闭套接字 new_socket.close() def main(): "用来完成整体的控制" #1.创建套接字 tcp_server_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #2.绑定 tcp_server_socket.bind(("",65534)) #3.变为监听套接字 tcp_server_socket.listen(128) while True: #4.等待新客户端的链接 new_socket,client_addr=tcp_server_socket.accept() #5.为这个客户端服务 service_client(new_socket) #关闭监听套接字 tcp_server_socket.close() if __name__=="__main__": main() 总结 用python创造一个服务器，这样通过套接字，绑定，监听，等待，回传数据，关闭服务，关闭监听，这样一整套流程达成http协议的实现，实现远程客户端访问服务端的效果也就是所谓的上网效果。
协议说白了就是规定，通过最基础的套接字代码实现。
一个成功的程序需要经过一遍遍的测试调整改正才能成为最终的样子
以上是本人个人心得总结，如有不对，望批评指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccc6cbcaeb1b704c29861517705deb2/" rel="bookmark">
			AI 大模型赋能手机影像，小米14 Ultra 让真实有层次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2月22日，小米龙年第一场重磅发布会，正式发布专业影像旗舰小米14 Ultra。
此前小米发布的两代 Ultra，在不同维度，引领了移动影像行业的走向。最新的小米14 Ultra 在定义的时候，我们反复在思考：怎么才能把移动影像推向一个全新的层次？
为此，小米跟徕卡、用户、摄影师、专家学者做了大量的交流，最终确定小米14 Ultra 影像追求的目标：让真实有层次，要细节丰富，过渡细腻；要主次明确，远近分明，通过好的技术和审美，还原生活的丰富、从而直指人心。
当 AI 大模型与手机影像结合，会碰撞出什么火花？
为了让基于 AI 大模型实现的手机影像系统更符合小米的“光学味”，在结合小米14 Ultra 的设计理念下，我们层次性地去释放大模型的能力，给用户带来突破性的效果和使用体验。
这里，要和大家重点介绍小米首个 AI 大模型计算摄影平台 Xiaomi AISP，也是小米影像大脑的全新升级。Xiaomi AISP 是计算摄影的强力之作，它有哪些革命性升级？我们一起来看。
01 Xiaomi AISP 首个 AI 大模型计算摄影平台 AI 大模型一经问世，便展现了其惊人的技术能力，各行各业都相继涌现出了利用 AI 大模型来推动技术变革的不同思路。小米相机团队也一直在思考，AI 大模型会给手机影像带来哪些变革？又如何将 AI 大模型技术更好地引入到手机影像系统里来？
经过不断地技术验证及效果评估，小米确定了开发基于 AI 大模型的 Xiaomi AISP 影像处理系统的目标，并在效果、算力、生成三个方面有了独家的见解和想法创新。
效果：在图像领域，AI 大模型最初被用来生成描述包含各式内容、具有指定风格的图像。但随着技术的迭代，生成图像的质量、真实性、分辨率越来越高，甚至达到了影棚级的效果。
若将大模型用到相机影像系统的任务中，处理噪声、影调、人像等问题，效果是不是会更好？团队带着问题开始尝试和探索，认为在具备一定质量的图像输入的前提下，经过合适的调整和匹配，AI 大模型会得到相较于传统方法或者第一代 AI 技术更好的效果。
算力：算力，是将大模型应用到手机上、拍照影像系统里最大的问题。团队为了能将 AI 大模型应用到实时性要求非常高的手机相机影像系统中，在模型重构设计、模型求解优化（推理迭代）以及系统级管线管理及多硬件算法分配方面，投入了非常多的资源，也攻克了许多关键性的问题。
通过重新设计、训练适合相机影像任务的小型化 AI 大模型，并基于小米澎湃 OS 和自研的异构加速平台，全面整合了 CPU、GPU、NPU 和 ISP 的平台算力（计算能力达到 60 TOPS），最终成功地实现了基于 AI 大模型的 ISP 系统解决了端侧、拍照模型运行的速度、功耗等问题。
生成：为了让基于 AI 大模型实现的相机影像系统更符合小米的“光学味”，在结合小米14 Ultra 的设计理念下，我们层次性地去释放大模型的能力。在基础的影像功能任务和场景，从多个维度相对保守的使用了 AI 大模型的生成能力，以保持大模型原有的优势；相反的，在超出光学和传感器物理极限的场景，我们会适当释放大模型的生成能力，以带来不一样的效果体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccc6cbcaeb1b704c29861517705deb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c816010f5ea7a495ce29708d8389b29c/" rel="bookmark">
			Linux根据进程ID查看进程文件的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.执行命令：pwdx PID 命令，就得到进程jar包所在的位置
2.执行命令：ll /proc/PID/cwd 命令，也能得到进程jar包所在的位置
实践记录
[root@iZ2ze6gybozdabggz8w5deZ ~]# netstat -nltpeu | grep 9092 tcp 0 0 0.0.0.0:9092 0.0.0.0:* LISTEN 0 267623 2028/java [root@iZ2ze6gybozdabggz8w5deZ ~]# pwdx 2028 2028: /mnt/software/code-generator [root@iZ2ze6gybozdabggz8w5deZ ~]# [root@iZ2ze6gybozdabggz8w5deZ ~]# ll /proc/2028/cwd lrwxrwxrwx 1 root root 0 Mar 13 10:39 /proc/2028/cwd -&gt; /mnt/software/code-generator [root@iZ2ze6gybozdabggz8w5deZ ~]# 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d76c9b9f9679138048598e289a2c7e/" rel="bookmark">
			jQuery对象与DOM对象的区别以及相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jQuery与DOM对象的区别 dom对象是使用javascript方法获取页面中元素返回的对象，而jquery对象是使用jquery方法获取页面中元素返回的对象；dom对象只能访问dom中预定义的方法，jquery对象只能调用jquery提供的方法。 DOM对象 DOM树中的节点都是DOM元素节点。可以通过JS中的getElementByTagName或者getElementById来获取元素节点。像这样得到的DOM元素就是DOM对象。
jQuery对象 jQuery对象就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法。在jQuery对象中无法使用DOM对象的任何方法，同样的DOM对象也不能使用jQuery里的方法。jQuery实质上是一个JS数组，存放了DOM对象 互相转换 DOM对象转jQuery对象 对于一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。方式为$(DOM对象), 转换后，就可以任意使用jQuery中的方法了。 注意： 平时用的jQuery对象都是通过$()函数制造出来的，$()函数就是一个jQuery对象的制造工厂。 jQuery对象转DOM对象 jQuery对象是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象。例如只有一个类名为“bind”的DIV，在控制台输出console.log($(".bind")) 如图，通过调试工具，我们可以清除的看到，jQuery对象是一个类数组对象，我们可以通过$(".bind")[0]获得DOM对象。另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象。还是上面的.bind对象 ，我们可以通过 $(".bind").get(0)获得DOM对象。如图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412c78cc5ce2ec1a6125ec1057eb36c3/" rel="bookmark">
			OpenCV-图像基础处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 彩色（RGB）图像
2 灰度图像
3 黑白图像
1 彩色（RGB）图像 使用cv2.imread()函数加载RGB图像；使用cv2.split()函数分割颜色通道；将BGR颜色格式转换成RGB颜色格式；使用matplotlib或cv2.imshow()函数可视化图像。 import cv2 from matplotlib import pyplot as plt import numpy as np # 加载RGB图片 img_OpenCV = cv2.imread(r"demo.jpeg") print(type(img_OpenCV), img_OpenCV.shape) # &lt;class 'numpy.ndarray'&gt; (484, 515, 3) # 分割颜色通道，opencv使用BGR颜色格式 b, g, r = cv2.split(img_OpenCV) # imread()方法返回ndarray对象，因此也可以使用切片分割颜色通道 B = img_OpenCV[:, :, 0] G = img_OpenCV[:, :, 1] R = img_OpenCV[:, :, 2] print((b == B).all(), (g == G).all(), (r == R).all()) # True True True # 转换成RGB颜色格式 img_matplotlib = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412c78cc5ce2ec1a6125ec1057eb36c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ffbba20224d437348e8e09a3d9b2ff/" rel="bookmark">
			Linux下完全卸载Android studio相关内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到Android studio的文件目录，rm -rf android-studio-xxx-linux删除设置目录：~/.config/Google/AndroidStudioxxx删除数据缓存目录：~/.local/share/Google/AndroidStudioxxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87a2311e2197740ad54c283bfc96ca7/" rel="bookmark">
			vue&#43;vite根据版本号清空用户浏览器缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目生产环境发布新版本之后，用户可能会因为一些本地缓存的数据不一样而导致页面报错。这时候可以根据版本号去清空用户缓存。
1、在package.json文件中有一个管理版本号属性：version，在每次打包部署之前修改当前版本号。
2、在main.js文件中，加入版本号的判断逻辑，版本号不一致就重新加载，代码如下：
//根据版本号清空用户缓存 import {version} from '../package.json'; const VUE_APP_VERSION = version const vers = window.localStorage.getItem("Version"); if (VUE_APP_VERSION != vers) { localStorage.clear(); sessionStorage.clear(); Cookies.remove("token"); window.localStorage.setItem("Version", VUE_APP_VERSION); location.reload() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8917d5d3bb55479c81b6789bb98c23f/" rel="bookmark">
			第 5 章 TF坐标变换(自学二刷笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要参考：
课程链接:https://www.bilibili.com/video/BV1Ci4y1L7ZZ
讲义链接:Introduction · Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程
5.1.6 TF坐标变换实操 需求描述：
程序启动之初：产生两只乌龟，中间的乌龟(A) 和 左下乌龟(B)，B 会自动运行至A的位置，并且键盘控制时，只是控制 A 的运动，但是 B 可以跟随 A 运行
结果演示：
实现分析：
乌龟跟随实现的核心，是乌龟A和B都要发布相对世界坐标系的坐标信息，然后，订阅到该信息需要转换获取A相对于B坐标系的信息，最后，再生成速度信息，并控制B运动。
启动乌龟显示节点在乌龟显示窗体中生成一只新的乌龟(需要使用服务)编写两只乌龟发布坐标信息的节点编写订阅节点订阅坐标信息并生成新的相对关系生成速度信息 实现流程：C++ 与 Python 实现流程一致
新建功能包，添加依赖
编写服务客户端，用于生成一只新的乌龟
编写发布方，发布两只乌龟的坐标信息
编写订阅方，订阅两只乌龟信息，生成速度信息并发布
运行
准备工作：
1.了解如何创建第二只乌龟，且不受键盘控制
创建第二只乌龟需要使用rosservice，话题使用的是 spawn
rosservice call /spawn "x: 1.0 y: 1.0 theta: 1.0 name: 'turtle_flow'" name: "turtle_flow" 键盘是无法控制第二只乌龟运动的，因为使用的话题： /第二只乌龟名称/cmd_vel，对应的要控制乌龟运动必须发布对应的话题消息
2.了解如何获取两只乌龟的坐标
是通过话题 /乌龟名称/pose 来获取的
x: 1.0 //x坐标 y: 1.0 //y坐标 theta: -1.21437060833 //角度 linear_velocity: 0.0 //线速度 angular_velocity: 1.0 //角速度 方案A：C++实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8917d5d3bb55479c81b6789bb98c23f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146c5be85dbac51bbd2d923df3f2bb16/" rel="bookmark">
			Android Studio字体大小调节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外观页面字体调节 settings-&gt;Appearance-&gt;User cunstom font 代码字体调节 Settings-&gt;Editor-&gt;Font此时logcat窗口、Build窗口和Ternimal窗口字体大小也会同步调节（2023.2.1版本上验证）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/32/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>