<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbcc24a5c66d895e65336ae429db3c2/" rel="bookmark">
			闲鱼商品详情接口API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ api: "mtop.taobao.idle.awesome.detail", data: { uiTemplateDO: { }, needDecryptKeys: [ "sellerDO.nick", "flowData.body.sections.components.data.sellerId", "sellerDO.uniqueName", "flowData.body.sections.components.data.nick", "trackParams.sellerId", "sellerDO.identityTags.link", "flowData.floating.components.data.sellerId", "flowData.body.sections.components.data.jumpLink", "flowData.body.sections.components.data.userInfo.sellerId", "flowData.floating.components.data.nick", "flowData.body.sections.components.data.uniqueName", "flowData.body.sections.components.data.trackParams.sellerId", "flowData.body.sections.components.data.waterMark", "flowData.floating.components.data.userId", "flowData.body.sections.components.data.metaInfo.waterMark", "itemDO.trackParams.sellerId", "flowData.body.sections.components.data.userInfo.nick" ], itemDO: { itemType: "detailCommonBuy", simpleItem: "true", originalPrice: "698", transportFee: "0.00", itemStatusStr: "在线", shareData: { shareReportUrl: "https://market.m.taobao.com/app/msd/aq-idlefish-report/pages/report?wh_weex=true&amp;reportType=item&amp;itemid=710980749428", shareHelpUrl: "https://h5.m.goofish.com/app/service-hall/sh-rax-web/goofish.html?hcAppId=1283&amp;hcPageCode=home&amp;hcFromCode=dIekpEBMI&amp;item_id=710980749428", shareInfoJsonString: "{"contentParams":{"headerParams":{"subTitle":"发布于杭州","title":"头头是道","userAvatar":"http://img.alicdn.com/bao/uploaded/i2/O1CN0183Vg8Z1w82wl74ldq_!!0-mtopupload.jpg","userTag":{"height":"32","image":"https://gw.alicdn.com/bao/uploaded/TB1E3aKPFXXXXcKXpXXXXXXXXXX-32-32.png","width":"32"}},"mainParams":{"content":"家具店不开了，处理8个摇摇椅，舒适、简约\n科技布摇椅躺椅懒人椅子靠背椅网红直销阳台摇摇椅\n\n超级舒服的摇摇椅哦，没事我就喜欢在上面躺一会刷剧，玩手机，强烈推荐给大家哦，有米色，蓝色，黄色，橙色可以选择，不仅舒适颜值高，关键是价格也很美丽呢\n\n拍后备注颜色哦\n\n全新～多数地区包邮，偏远地区需补运费～","contentMaxLine":"2","extra":{"descRelativeTags":[],"priceRelativeTags":[{"additionMap":{},"bgColor":"#FFFFFF","borderColor":"#FFFFFF","order":99,"text":"包邮","textColor":"#1F1F1F","trackParams":{"tagType":"包邮"}}],"soldPrice":"15"},"images":[{"height":"720","image":"http://img.alicdn.com/bao/uploaded/i3/O1CN01ssj1iJ1w82zXpWy5i_!!0-fleamarket.jpg","width":"823"},{"height":"720","image":"http://img.alicdn.com/bao/uploaded/i4/O1CN01YIagqz1w82zc1jqlO_!!0-fleamarket.jpg","width":"721"},{"height":"959","image":"http://img.alicdn.com/bao/uploaded/i3/O1CN01vypFsg1w82zX6n6ku_!!0-fleamarket.jpg","width":"720"},{"height":"952","image":"http://img.alicdn.com/bao/uploaded/i1/O1CN011BUu9b1w82za3BEZk_!!0-fleamarket.jpg","width":"720"},{"height":"720","image":"http://img.alicdn.com/bao/uploaded/i3/O1CN01qiwuFB1w82zX6niBR_!!0-fleamarket.jpg","width":"720"},{"height":"720","image":"http://img.alicdn.com/bao/uploaded/i4/O1CN01dnimDw1w82zU9axc6_!!0-fleamarket.jpg","width":"960"},{"height":"960","image":"http://img.alicdn.com/bao/uploaded/i4/O1CN01A4DsGe1w82zPyYj2v_!!0-fleamarket.jpg","width":"720"},{"height":"941","image":"http://img.alicdn.com/bao/uploaded/i2/O1CN01vR9KhI1w82zUVCMUz_!!0-fleamarket.jpg","width":"720"},{"height":"793","image":"http://img.alicdn.com/bao/uploaded/i1/O1CN01GDnHKT1w82zVwU09j_!!0-fleamarket.jpg","width":"763"}]}},"sceneId":"710980749428","sceneType":"detail","shareMessageCard":{"coverImg":"","subTitle":"","title":""},"url":"fleamarket://item?id=710980749428&amp;flutter=true&amp;ignoreMiddle=true","version":2}" }, attitudes: [ { image: "https://gw.alicdn.com/imgextra/i4/O1CN01Bgss8723h2YneWrTE_!!6000000007286-2-tps-144-144.png", lottie: "https://g.alicdn.com/eva-assets/63c22c21841037745d6d122ae42dbe49/0.0.1/tmp/46150a7/46150a7.json", fullLottie: "https://g.alicdn.com/eva-assets/355cbc5f9eff697e226de7da654a37b8/0.0.1/tmp/499a606/499a606.json", supportedCnt: "0", title: "赞一个", key: "1" }, { image: "https://gw.alicdn.com/imgextra/i1/O1CN01zJVtzf20SR5Fda9DD_!!6000000006848-2-tps-144-144.png", lottie: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdbcc24a5c66d895e65336ae429db3c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64f0a061e20ba8670164c3e2dd76c9d/" rel="bookmark">
			实验室服务器conda使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 下载conda2. 安装conda3. 检查conda是否安装成功4. 配置conda镜像5. 创建conda环境6. 在环境中安装模型所需的库文件7. conda的其他用法8. 服务器离线安装python库文件（以torch-summary为例）参考 前言 Miniconda比较简单，只能在命令行中使用，anaconda比较强大，有一个界面化的软件，但是占用系统空间较大。实验室服务器使用Linux系统，用命令行操作的miniconda就可以了。
1. 下载conda 国内服务器需要选择conda镜像，通常有清华源、中科大、北京外国语镜像。这里选择清华源镜像（使用帮助）。
miniconda版本选择 网页（地址）上会显示对应不同系统、不同版本的Miniconda，服务器使用Linux系统，需要下载Linux版本对应的miniconda。看日期找到最新版本的Miniconda3-latest-Linux-X86_64.sh。复制链接地址。
复制链接到服务器，用服务器下载Miniconda。
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh 2. 安装conda 使用bash命令安装，注意安装路径，安装到自己的文件夹下。认真看安装过程提示信息，需要按Enter (回车键)或者输入yes，（如果输入yes时，不小心输多了，就按control和退格键删除）
bash Miniconda3-latest-Linux-x86_64.sh （1）看到more就是按空格键翻页查看协议，按q退出
（2）接受协议，输入yes
（3）默认安装路径，按enter
（4）会询问是否需要初始化，输入yes
（5）显示安装已完成的提示信息
激活刚安装完成的软件 一般安装软件完成后需要重启，在Linux叫激活，有两种方式，第一种是重新登录服务器，第二种是输入以下命令：
source ~/.bashrc 3. 检查conda是否安装成功 安装一个软件后，需要检查软件是否安装成功，调用软件的帮助文档。
conda --help 4. 配置conda镜像 主要看自己的服务器在哪里，无论人在国外还是国内，使用的服务器在国内，就配置国内镜像。
# 下面这三行配置官网的channel地址 conda config --add channels r conda config --add channels conda-forge conda config --add channels bioconda ##以上三句命令一次性复制粘贴或是单独复制粘贴到服务器 配置国内访问镜像，国内用户推荐的镜像，以下选清华或是北外的镜像都可以，以下代码块里的（1）和（2）选其中一个配置镜像，清华镜像的访问量很多，可以选北外镜像。
#（1）下面这四行配置清华大学的conda的channel地址，国内用户推荐 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64f0a061e20ba8670164c3e2dd76c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e97d9629e6140f061aaa0c810e7e50/" rel="bookmark">
			SQL的DATEDIFF( )函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DATEDIFF() 是 SQL 中的日期函数，用于计算两个日期之间的差值。
其语法如下：
DATEDIFF ( datepart , startdate , enddate ) 其中，datepart 是表示差值单位的关键字或缩写；startdate 和 enddate 表示要计算差值的两个日期。
datepart 参数可以是以下值之一：
year, yy, yyyy: 年quarter, qq, q: 季度month, mm, m: 月dayofyear, dy, y: 年中的天数day, dd, d: 日week, wk, ww: 周hour, hh: 小时minute, mi, n: 分钟second, ss, s: 秒millisecond, ms: 毫秒microsecond, mcs: 微秒nanosecond, ns: 纳秒 DATEDIFF() 函数返回一个整数，表示两个日期之间的差值。
以下是一个栗子：
SELECT DATEDIFF(day, '2022-05-10', '2022-05-15') AS diff; 结果返回 5，表示 2022 年 5 月 15 日与 2022 年 5 月 10 日之间相隔了 5 天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e999432b2c6c0c8a5451f4ea372db3c9/" rel="bookmark">
			3par交换机端口降级及相关排查命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3par交换机端口降级及相关排查命令 3par客户端告警端口降级，24小时内有丢包现象。 相关排查命令： showport，查看降级端口（问题中使用此命令，后插拔光口或者直接更换故障光口） loss sync: bit 或者 transmission-word无法被准确区分确认时会引起信号同步失败。末端设备的重启，光纤线的拔插，或交换机端口的上下线均可能带来该问题。
扩展命令（磁盘降级）： servicemag status ,查看盘阵信息状态 checkhealth -svc -detail 查看健康状态 servicemag status -d 查看当前进程 showpd -c showpd -s 查看硬盘是否正常 showpd -i 查看硬盘的wwn号、型号和固件版本号。 热插拔硬盘后，状态灯扔显示橙色告警，可手动取消告警，执行
locatecage -t 1 cagel 10 （locatecage -t 1 cageX Y 1，表示1秒 X表示磁盘所在的盘笼的id号 Y表示磁盘号 ）
参考：
Brocade交换机PortErrShow命令er_bad_os各输出项释义 - 鸿爪雪泥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284b880e12fca073d366c3e7c3f5b11f/" rel="bookmark">
			SQL Server 数据转换为 MySQL 数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将 SQL Server 数据转换为 MySQL 数据需要执行以下步骤：
1.导出 SQL Server 数据
首先，需要将 SQL Server 数据导出为一个可以被 MySQL 导入的格式，例如 CSV 格式或 SQL 语句。在 SQL Server Management Studio 中，可以使用“导出向导”功能导出数据。
2.转换数据类型
SQL Server 和 MySQL 使用不同的数据类型，因此在导入数据之前需要将数据类型进行转换。可以使用一些工具来完成数据类型转换，例如 SSIS（SQL Server Integration Services）。
3.创建 MySQL 数据库和表
在 MySQL 中创建与 SQL Server 数据库和表相同的结构，包括表名、列名和数据类型等。
4.导入数据
使用 MySQL 提供的数据导入工具将导出的数据文件导入到 MySQL 数据库中。
需要注意的是，由于 SQL Server 和 MySQL 存在一些语法差异，因此可能需要修改 SQL 语句以确保其在 MySQL 中的正确执行。此外，还需要确保两个数据库中的字符集和排序规则相同，以避免数据导入过程中出现错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd4a6d4846ce568a8248924f59e3149/" rel="bookmark">
			Linux系统中挂载共享文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统中挂载共享文件 今日问题：在其它服务器中挂载同一台服务器的文件 解决方法： mkdir /nasshare #首先在所有服务器中创建被挂载的目录 yum install nfs-utils -y #安装nfs system enable nfs #设置开机自启动nfs mount xxxx:/data/share /nasshare #挂载 echo ' xxxx:/data/share /nasshare nfs defaults,_netdev 0 0' &gt;&gt; /etc/fstab #增加开机自动挂载 ；_netdev 含义是在网络服务启动后再进行挂载。 这种自动挂载的方法有一定的局限性，但是问题是发生在云服务器中的，云管理平台有着很好的监控性，所以这种方式满足。如果是在实体机中，建议使用扩展中的第三种方法。
扩展： 自动挂载技术： 如果想实现客户端开机自动挂载nfs文件系统，可以进行相应的设置，无需手工执行挂载命令。
一、在/etc/fstab文件中，追加nfs文件系统的挂载信息，如下： 192.168.0.187:/data/lutixia /mnt/nfs nfs defaults,_netdev 0 0 _netdev 防止客户端在网络就绪之前开始挂载文件系统
如果服务端的nfs正常，这时客户端会开机自动挂载。
如果服务端nfs关闭了，这时客户端虽然能正常开机，但是会变得异常缓慢，而且不会挂载此文件系统。
二、把挂载命令写入/etc/rc.local文件中实现开机挂载，但是要保证/etc/rc.d/rc.local，这个文件有可执行权限： mount -t nfs -o soft,,timeo=10 192.168.0.187:/data/lutixia /mnt/nfs soft 软挂载，当超过我们配置的时间，则会返回错误，不会一直阻塞，推荐这种挂载方式，默认是硬挂载，服务端挂载会一直阻塞。
timeo 指定客户端去连接服务端的时长（单位为 0.1 秒),不要设置太长了。
授权：
chmod +x /etc/rc.d/rc.local ps:但是不管是以上那种方式，如果服务端出现异常，客户端的开机会异常缓慢，因为客户端一直在尝试挂载，所以以上两种方式并不是很可取！
三、自动挂载软件 自动挂载软件是触发式的，进入到指定挂载目录，自动实现挂载。
1、在客户端安装autofs软件包， 一般已经安装好了，如果没有执行以下命令： yum install autofs -y 2、编辑/etc/auto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd4a6d4846ce568a8248924f59e3149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f53bd7c3a5609d9b50398f76344acdf/" rel="bookmark">
			软件测试基础知识整理（一）- 计算机基础知识、计算机网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、计算机基础知识
1.1 计算机系统
1.2 硬件系统
1.2.1 硬件系统的组成
1.3 软件系统
1.3.1 操作系统分类
1.4 B/S架构 与 C/S架构
1.4.1 B/S架构 和 C/S架构 区别
二、计算机网络
2.1 OSI七层模型
2.2 TCP/IP 协议
2.2.1 IP地址分类
一、计算机基础知识 1.1 计算机系统 一个完整的计算机系统，是由 硬件系统 和 软件系统 组成的
1.2 硬件系统 计算机的硬件主要分为两类——主机和外设
1.2.1 硬件系统的组成 运算器、控制器 统称为 中央处理器，即CPU存储器：内存（rom只读存储器；ram随机存储器，断电数据会消失），外存（硬盘、光盘等）输入设备：例如 鼠标、键盘等输出设备：例如 显示器、打印机等 注意：ROM中存储的是固定的程序和数据，它们不能被修改或删除，而RAM中存储的是临时数据，它们只能在电源通电时被存储和访问，并且在断电后将被清除
举例说明：
当你打开游戏机，ROM存储器中的开机自检程序和游戏代码将被加载到游戏机的内存中。这些代码不能被修改或删除，因为它们存储在ROM中。而一旦你开始游戏，游戏数据将被存储在RAM中，这包括你的得分、游戏进度和其他临时数据。当你玩游戏时，RAM存储器将不断读取和写入数据，以快速响应你的操作和保持游戏状态。但是，一旦你关闭游戏机，RAM中存储的游戏数据将会丢失，而ROM中存储的游戏代码和其他数据将保留下来，以便下一次打开游戏机时重新加载。
1.3 软件系统 软件系统分为 系统软件 和 应用软件
系统软件：指操作系统、编译器、驱动程序、网络协议栈等软件系统，主要用于控制硬件和管理计算机系统的各种资源。应用软件：指针对具体应用领域开发的软件系统，如办公软件、设计软件、游戏软件、教育软件等。 1.3.1 操作系统分类 （1）桌面操作系统：Windows、macos、Linux
（2）服务器操作系统：Linux、Windows Server
（3）嵌入式操作系统：Linux，应用于智能家居、手机、医疗设备、汽车电子等
（4）移动设备操作系统：ios、Android
1.4 B/S架构 与 C/S架构 B/S架构：Browser-Server，浏览器和服务器架构。用户只需浏览器就可以访问服务，系统更新时，只需要更新服务端。如淘宝、百度等网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f53bd7c3a5609d9b50398f76344acdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6e239029a1250ec300f1976b78f2ff/" rel="bookmark">
			C/C&#43;&#43; 基于Linux的高并发后台服务器-经验小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多线程多进程模式 进程是操作系统资源分配最小的调度单位，意味着进程被暂停后，其下所有线程都会失去调度资源的权限。要充分利用系统资源，最好的形式是多线程多进程模式。
我们最好将一个整体功能，分散到多个进程当中，从而实现资源利用率最大化。否则就只能多个线程在一个进程内进行竞争，没办法充分利用系统资源。
2、进程创建 在linux中，开启进程一般通过exec系列函数或者fork函数来完成。即使是exec函数，也会要使用到fork函数。
所以开启进程，fork函数是无法绕开的。而fork函数会对线程造成影响，所以我们一定要先定好进程结构，然后再开启线程。原因：首先，由于线程无法被复制，所以在子进程中，一些线程会消失（没有被复制过来；其次，如果程序逻辑依赖多线程模式的时候，fork可能在子进程中破坏掉这种模式，进而使得程序出现无法预料的问题。所以一定要先准备好进程结构，再去使用线程！！！
3、进程入口函数的实现 a)使用无属性的指针参数和固定参数的进程入口函数来实现 b)使用面向对象的参数和统一的进程入口函数来实现 c)使用模板函数来实现 这三种方式都可以实现，但是方便程度和安全性不一样。第一种方式技术上最简单，但是类型在转换的时候，可能出现问题。而且可以传入的参数数量是固定的，以后其他项目很难复用此代码。第二种方式比第一种好了不少。参数不是固定的，可移植性强了很多。但是这种方式需要专门写一个参数封装和解析的代码。这种解析代码的复用性会比较差。因为每个进程的任务不一样，参数也不一样，参数的含义也可能大相径庭。第三种方式难度最大，但是使用起来最方便，可以移植性最强。参数可以随时修改，函数也可以是类的成员函数。此外参数无需解析，直接原样转发到目标函数。实现起来也不需要太多代码，stl里面准备好了很多工具，可以直接使用。就是模板编程不太好理解。
*3c 模板函数和模板类 std::bind用于给一个可调用对象绑定参数。可调用对象包括函数对象（仿函数）、函数指针、函数引用、成员函数指针和数据成员指针。 std::forward&lt;T&gt;(u)有两个参数：T 与 u。当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。 std::move是无条件的转为右值引用，而std::forward是有条件的转为右值引用，更准确的说叫做Perfect forwarding(完美转发)，而	std::forward里面蕴含着的条件则是Reference Collapsing(引用折叠)。 对于一个函数:虚函数特性和模板函数特性不能同时存在,但是一个模板类可以有虚函数
4、多进程通信为什么用本地套接字通信（最方便最快速）而不用其他通信方式？ 1.文件通信依赖磁盘速度（大量读写容易造成磁盘击穿），且慢于网络传输 2.管道在多线程环境下不太方便（可能会出现多个线程往一个管道内写入数据导致数据错误），而且管道为单向的。（除非是一对一管道通信，否则不建议使用管道通信） 3、信号量的信息容量过小（只能用于通知信号状态变化，大量的日志数据无法通过信号量传递），但是传输速度很快，也不会出现跨进程/线程的的问题 4、内存共享需要反复加锁同步，否则可能会出现问题（加锁需要极力避免，否则会出现卡顿） 5、消息函数（sendmsg、recvmsg）需要创建时确定收发方 （但是也有优势：可以收发大量数据，且不像管道同时有数据插入的情况以及不需要上锁） 6、“网络套接字”通信也可以，但需要额外的IP和端口（指定IP和端口随时都可以连上），但因为需要占用双方的一个IP和端口（占用资源），高并发可能造成挤占效应 *5、关于守护进程/正常进程被杀其子进程的去留？ 1、守护进程若设置了prctl(PR_SET_PDEATHSIG,SIGHUP);或者prctl(PR_SET_PDEATHSIG, SIGTERM)这个函数的作用是，当父进程挂掉后，会发送SIGHUP或者SIGTERM信号给子进程。做了测试程序，果然，这次关掉B脚本后，A就退出了。后来又在A的代码中加了个信号处理函数，处理了SIGTERM和SIGHUP，发现kill掉B脚本的时候，A确实接收到了信号。
2、正常情况下（默认），一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害。
3、一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。一个进程如果只复制fork子进程而不负责对子进程进行wait()或是waitpid()调用来释放其所占有资源的话，那么就会产生很多的僵死进程，如果要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会变成孤儿进程，从而被init所收养，这样init就会释放所有的僵死进程所占有的资源，从而结束僵死进程。
4、一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。
6、使用“本地套接字”通信的优势 1、无需IP和端口，不影响服务器对外资源（虚拟本地文件地址，内核文件映射出来的，不占IP和端口，可以放心使用），无挤占效应 2、信息无需加锁，可以多线程并发写（还可以采用epoll多线程并发读） 3、数据传输量巨大，传输速率高（纯内存读写），没有经过磁盘读写 4、本地模式采用“本地套接字”通信，集群模式（日志服务器程序和客户端程序在两台不同的物理机器上）采用“网络套接字”通信 5、使用本地套接字通信后，若后期想改为网络套接字通信，工作量很小，基本上可以完全沿用所有逻辑，只在套接字创建和客户端创建时做小修改（把原来的文件和地址改成网络套接字通信需要的IP和端口即可） 6、A和B同时发100MB的数据包，经网卡驱动排序后逐个发送后日志服务器逐个接收，不会产生数据异常“插入”等。 7、日志服务器处理从其他进程发送的日志操作 1、对每个请求都开大量的线程处理（在资源峰值出现过分挤占）
2、固定若干线程处理其他进程发送的日志（接受日志），这种方式更合适
8、禁止拷贝构造和复制的三种方式* 1、设置拷贝构造与copy assign为私有
2、继承不可拷贝构造与拷贝赋值的基类
因为默认生成的拷贝构造函数会自动调用基类的拷贝构造函数，如果基类的拷贝构造函数是 private，那么它无法访问，也就无法正常生成拷贝构造函数。
3、使用delete
9、进程间通信的实现 1、初始化（服务端：创建套接字、绑定位置、监听；客户端：创建套接字）
2、链接
3、发送/接收
4、关闭（关闭套接字）
10、封装，抽象 1、抽象类用于继承，具有OOP特性，客户端只用上层接口函数，不用关注下层的具体实现；
2、当具体实现需要变化时，上层接口不变，因而不用改变上层具体代码。
11、static修饰类内成员变量和成员函数 1、静态成员变量 1、静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。 2、静态成员变量必须在类中声明，在类外全局定义(也可以同时初始化)（在类外全局定义和初始化[无需加static]可行int Data::data = 125;，但若要在外部其他函数内定义初始化静态成员变量（公有和私有都不行）不可行）。 3、静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。 4、静态变量是所有对象共享的可以通过对象名访问。类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，若属于公有成员则可以通过类名直接去访问；私有静态变量在外部不能访问。 2、静态成员函数 1、静态成员函数的目的 操作静态成员数据。 2、静态成员函数 不能访问 非静态成员数据。（静态成员函数内部没有this指针） 3、普通成员函数 可以操作 静态成员数据 非静态成员数据。 4、静态成员变量和静态成员函数都有权限之分。 3、静态成员函数与非静态成员函数的异同 1、相同点：:无论静态函数还是非静态函数,都是属于类的(这一点与数据成员的静态非静态不同),对象并不拥有函数的拷贝。 2、区别： 非静态的函数由类对象(加.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6e239029a1250ec300f1976b78f2ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f81ec94040b8f293074dfe97100e06/" rel="bookmark">
			数组刷题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组刷题总结 1.1 二分答案 当题目要求最大化某最小、最小化某最大，考虑使用二分查找。遍历所有可能得key，然后送入check函数进行题目判断
1760. 袋子里最少数目的球 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
class Solution { public: bool check(int cost,vector&lt;int&gt;&amp; nums, int maxOperations){ int count=0; for(int i=0;i&lt;nums.size();i++){ if(nums[i]%cost==0) count+= nums[i]/cost-1; else count += nums[i]/cost; } if(count&lt;=maxOperations) return true; return false; } int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) { int left =1; int right = 1e9; while(left&lt;right){ int mid = left+(right-left)/2; if(check(mid,nums,maxOperations)){ right = mid; } else{ left = mid+1; } } return left; } }; 在本题目中，需要最小化，拆分后剩余的最大值。所以在check函数中，由于除法得到的余数肯定小于被除数，所以直接用数组值除以遍历得到的最大值，得到需要划分的次数，并进行判断。 1552.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f81ec94040b8f293074dfe97100e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110e6c931ac13d4e4e4b21cae1f7d861/" rel="bookmark">
			nvm如何变更npm版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 nvm 管理 Node.js 版本时，可以使用以下命令来变更 npm 版本：
首先，使用 nvm 切换到要使用的 Node.js 版本，例如：
nvm use 14.17.0 这将把当前 shell 环境切换到 Node.js 14.17.0 版本。
然后，使用 npm 命令查看当前的 npm 版本：
npm -v 如果需要切换 npm 版本，可以使用 npm 命令来安装指定版本的 npm。例如，安装 npm 7.20.3 版本：
npm install -g npm@7.20.3 安装完成后，可以再次使用 npm -v 命令来查看当前的 npm 版本，确认是否已经切换成功。
需要注意的是，切换 npm 版本时，建议先备份当前项目的 package.json 和 package-lock.json 文件，以避免版本不兼容等问题导致的依赖安装失败。同时，切换 npm 版本可能会影响全局安装的 npm 包，建议谨慎操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d7b2dd38f424cf168e8ea80deae593/" rel="bookmark">
			Linux 下 安装多个mysql8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:下载mysql
wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar
2：解压下载的mysql压缩包
解压mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar
tar -xf mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar
解压后生成3个压缩文件
继续解压mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar.xz
tar -xf mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar.xz
3：安装mysql
1：因为要安装多个mysql，所以要修改文件名称，修改文件所属的账户和权限
修改文件名称
mv mysql-8.0.33-linux-glibc2.17-x86_64-minimal mysql3310
mv mysql-8.0.33-linux-glibc2.17-x86_64-minimal mysql3309
修改文件所属的账户
先添加mysql用户组：groupadd mysql
在mysql用户组下添加mysql用户：useradd mysql -g mysql
修改文件所属账户：chown -R mysql:mysql /usr/local/soft/mysql*
修改文件的权限：chmod -R 755 usr/local/soft/mysql*
2：创建日志文件和存放数据文件，以及mysql的配置文件my.cnf
在mysql3310和mysql3309下创建
mkdir data mkdir log
vim my.cnf 这个文件的权限记得修改一下，因为它如果权限过大，在启动还是初始化的时候不行
3：修改my.cnf配置
[mysqld]
bind-address=0.0.0.0
port=3310
user=mysql
basedir=/usr/local/soft/mysql3310
datadir=/usr/local/soft/mysql3310/data
socket=/usr/local/soft/mysql3310/mysql3310.sock
log-error=/usr/local/soft/mysql3310/log/mysql.err
character_set_server=utf8mb4
symbolic-links=0
explicit_defaults_for_timestamp=true
general_log=1
general_log_file=/usr/local/soft/mysql3306/log/mysql_3306.log
lower_case_table_names=1
# 设置日期时间列的默认格式
sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
default_time_zone = '+8:00'
这5个表黄的也重要
mysqlx_port=33310
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d7b2dd38f424cf168e8ea80deae593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905d19692d53ab51f5eae6c1b26c31bf/" rel="bookmark">
			MPU6050详解（含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：MPU6050是一款强大的六轴传感器，需要理解MPU6050首先得有IIC的基础，MPU6050 内部整合了 3 轴陀螺仪和 3 轴加速度传感器，并且含有一个第二 IIC 接口，可用于连接外部磁力传感器，内部有硬件算法支持.
1.IO分配(MPU6050模块) 1. SCL 和 SDA 是连接 MCU 的 IIC 接口， MCU 通过这个 IIC 接口来控制 MPU6050，
另外还有一个 IIC 接口
2.AUX_CL 和 AUX_DA，这个接口可用来连接外部从设备，比如磁传感
器，这样就可以组成一个九轴传感器。
3.AD0 是从 IIC 接口（接 MCU）的地址控制引脚，该引脚控制 IIC 地址的最低位。如果接 GND，则 MPU6050 的 IIC 地址是： 0X68，如果接 VDD，则是 0X69.
2.MPU6050初始化（PA15 接 AD0 = GND） 注意：PA15默认是JTAG引脚，使用PA15时，需要使用IO的重映射功能。
（1）设置MPU6050的地址(AD0的电平) RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//打开辅助功能时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;	// GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); MPU_AD0_CTRL=0;	//设置为低电平	注：这里使用PA15是默认是JTAG引脚 ，需要重映射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905d19692d53ab51f5eae6c1b26c31bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbbd7526bb5195e59a165aed835644d/" rel="bookmark">
			From.Item 包裹自定义 RangePicker 组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From.Item 包裹自定义 RangePicker 组件 起初 业务当中要对RangePicker进行封装，对可选日期进行限制
问题 但是被&lt;Form.Item&gt;包裹的自定义组件往往无法进行setFieldValue,好在 antd 默认为子组件传递了onChange&amp;&amp;value
value为&lt;Form.Item&gt; name 对应的字段值
代码 import React, { memo, useState } from "react"; import { Button, Form, DatePicker, Space } from "antd"; import moment from "moment"; import "moment/locale/zh-cn"; moment.locale("zh-cn"); const { RangePicker } = DatePicker; /** * 自定义组件 */ const CustomComp = memo((props) =&gt; { const { onChange, value, disabled, platform } = props; // 将value设置为dates状态默认值，不然你在外部form.setFieldValue是不生效的 const [dates, setDates] = useState(value); function handleChange(value) { // value修改传入的onChange也要触发修改 onChange &amp;&amp; onChange(value); } const disabledDate = (current) =&gt; { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbbd7526bb5195e59a165aed835644d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f22bba5256e9db79c563a5418a113a/" rel="bookmark">
			JVM -- 垃圾回收；垃圾回收算法（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读前可参考 https://blog.csdn.net/MinggeQingchun/article/details/126947384
https://blog.csdn.net/MinggeQingchun/article/details/127066302
一、标记对象是否为垃圾 JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。
其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。
而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分
（一）引用计数法 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1
优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
缺点：无法检测出循环引用。 如A对象有一个对B对象的引用，B对象反过来引用A对象。这样，他们的引用计数永远不可能为0
JVM并未采取此种方式，而是可达性分析
（二）可达性分析 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
可达性算法是目前主流的虚拟机都采用的算法，程序把所有的引用关系看作一张图，从一个节点GC Roots开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。
在Java语言中，可作为GC Roots的对象包括下面几种：
（1）虚拟机栈中引用的对象（栈帧中的本地变量表）
（2）方法区中类静态属性引用的对象
（3）方法区中常量引用的对象
（4）本地方法栈中JNI（Native方法）引用的对象
从上图中，reference1、 reference2、reference3都是 GC Root
reference1 --&gt; 对象实例1
reference2 --&gt; 对象实例2
reference3 --&gt; 对象实例4 --&gt; 对象实例6
可以得出对象实例1、2、4、6都具有对象可达性，也就是存活对象，不能被GC回收的对象。而随想实例3、5虽然直接相连，但并没有任何一个GC Roots与之相连，即GC Roots不可达对象，就会被GC回收的对象
二、垃圾回收原理 垃圾回收 GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停
堆内存被划分为两块，一块的年轻代，另一块是老年代。老年代：年轻代比例为2:1
年轻代又分为Eden和survivor。他俩空间大小比例默认为8:2
幸存区又分为s0（From Space）和s1（To Space）。这两个空间大小是一模一样的，就是一对双胞胎，他俩是1:1的比例
堆内存垃圾回收过程 1、新生成的对象首先放到Eden区（伊甸园区），当Eden区满了会触发Minor GC
2、第一步GC活下来的对象，会被移动到survivor区中的S0区（From Space），S0区满了之后会触发Minor GC，S0区存活下来的对象会被移动到S1区（To Space），S0区空闲
S1满了之后再GC，存活下来的对象再次移动到S0区，S1区空闲，这样反反复复GC，每GC一次，对象的年龄就涨一岁，达到某个阈值后（15），就会进入老年代
3、在发生一次Minor GC后（前提条件），老年代可能会出现Major GC，这个视垃圾回收器而定
Full GC触发条件
手动调用System.gc，会不断的执行Full GC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f22bba5256e9db79c563a5418a113a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3cd83d50690bcb9f191e499758987d4/" rel="bookmark">
			什么是引用计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用计数是一种内存管理技术，用于自动管理动态分配的内存资源。它的基本思想是：对于每个被动态分配的内存块，都记录下它被引用的次数，即它的引用计数。当一个对象被引用时，它的引用计数加一；当一个对象不再被引用时，它的引用计数减一。当引用计数为零时，表示该对象不再被使用，可以安全地释放它所占用的内存资源。
引用计数的优点是简单、易于实现，能够自动释放不再被使用的内存资源，避免了内存泄漏的问题。但它也存在一些缺点，如在多线程环境下，需要使用原子操作来保证引用计数的安全性；同时，引用计数还可能存在循环引用的问题，导致对象无法被释放。
下面是一个简单的引用计数的示例：
```c++
#include &lt;iostream&gt; using namespace std; // 引用计数类 class RefCount { public: RefCount() : count(0) {} // 引用计数加一 void addRef() { count++; } // 引用计数减一 void release() { count--; } // 获取引用计数 int getCount() { return count; } private: int count; // 引用计数 }; // MyClass 类 class MyClass { public: MyClass() { refCount = new RefCount(); // 创建引用计数对象 refCount-&gt;addRef(); // 引用计数加一 } ~MyClass() { refCount-&gt;release(); // 引用计数减一 if (refCount-&gt;getCount() == 0) { // 如果引用计数为零，则释放内存资源 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3cd83d50690bcb9f191e499758987d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512d9c687b0044e8fa7f0d97f2749573/" rel="bookmark">
			云原生技术概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云原生技术是一种用于构建和运行现代化应用程序的技术和方法，它可以提高应用程序的可靠性、弹性和可伸缩性，加速应用程序的开发和部署，降低开发和运维的成本，提高业务的敏捷性和创新性。云原生技术的核心理念包括容器化、微服务架构、DevOps实践、服务网格和Serverless架构等。
下面将对这些云原生技术进行更详细的介绍：
容器化技术 容器化技术是云原生技术的基础，它可以将应用程序及其依赖项打包成一个独立的运行环境，实现跨平台和高度可移植性。容器化技术的核心是容器，容器是一种轻量级的虚拟化技术，可以将应用程序及其依赖项打包成一个独立的运行环境，运行在宿主操作系统上，避免了传统虚拟化技术的性能损失和资源浪费。
目前，最流行的容器化技术是 Docker。Docker 可以将应用程序及其依赖项打包成一个 Docker 镜像，镜像可以被运行在任何支持 Docker 的平台上。Docker 还提供了一系列命令和工具，用于创建、管理和部署容器，使得容器的使用变得非常简单和方便。
除了 Docker，还有其他一些容器化技术，如 rkt、LXC/LXD 等。这些容器化技术都可以用于构建和部署云原生应用程序，提高应用程序的可靠性、可伸缩性和可维护性，帮助企业更好地管理和运营现代化的应用程序。
微服务架构 微服务架构是一种架构模式，将应用程序拆分成多个小型、自治的服务，每个服务可独立部署、扩展和升级。微服务架构的目标是提高应用程序的可靠性和可伸缩性，同时降低开发和维护的复杂度。
微服务架构的核心是服务，服务是一组相关的功能模块，可以独立部署和运行。每个服务都有自己的 API，可以与其他服务进行通信。服务之间的通信通常通过轻量级的通信协议，如 HTTP、gRPC 等实现。
微服务架构的优势在于可以将应用程序拆分成多个小型、自治的服务，每个服务可独立部署、扩展和升级，从而提高应用程序的可靠性和可伸缩性。此外，微服务架构还可以降低开发和维护的复杂度，使得开发人员可以更加专注于实现业务逻辑。
DevOps实践 DevOps 是一种软件开发和运维的理念，旨在通过自动化和协作来提高软件交付速度和质量。在云原生技术中，DevOps 实践是必不可少的一部分，它包括持续集成、持续交付、自动化测试、自动化部署等。
持续集成是一种软件开发实践，旨在通过频繁地将代码集成到共享代码仓库中，从而实现快速反馈和减少代码冲突。持续集成可以通过使用自动化构建和测试工具，自动化构建、测试和评审代码，并及时向开发人员提供反馈。
持续交付是一种软件交付实践，旨在通过自动化构建、测试和部署流程，实现快速、可靠和频繁的软件交付。持续交付可以通过使用自动化部署工具和容器化技术，实现自动化部署和回滚，从而提高交付的速度和质量。
自动化测试是一种测试实践，旨在通过自动化测试工具和框架，实现自动化测试用例的编写、运行和评估。自动化测试可以帮助开发人员及时发现和解决软件缺陷，提高软件质量和可靠性。
自动化部署是一种部署实践，旨在通过自动化部署工具和容器化技术，实现快速、可靠和频繁的应用程序部署和回滚。自动化部署可以帮助企业快速响应市场变化，提高业务的敏捷性和创新性。
服务网格 服务网格是一种新兴的技术，用于管理和监控微服务的网络通信。服务网格通过将网络层逻辑抽象成一组服务，提供了一种可观察、安全和弹性的微服务通信解决方案。
服务网格的核心是代理，代理是一种运行在应用程序内部的网络代理，负责拦截应用程序的网络请求和响应，并进行一系列的操作，如路由、负载均衡、故障转移、流量控制、安全验证等。代理可以通过使用 Sidecar 模式，将其与应用程序一起部署在容器中。
目前，最流行的服务网格技术是 Istio。Istio 提供了一系列的功能，如流量管理、安全管理、故障恢复、可观察性等，可以帮助开发人员更好地管理和监控微服务的网络通信。
Serverless架构 Serverless 架构是一种新兴的云原生技术，它可以让开发人员将注意力集中在应用程序开发上，而不必关注底层的基础设施。Serverless 平台可以根据应用程序的负载自动扩展和缩减计算资源，从而提高应用程序的可伸缩性和弹性。
Serverless 架构的核心是函数，函数是一段独立的代码逻辑，可以在需要时被触发执行，而不必关注底层的基础设施。函数可以通过使用云提供商的 Functions as a Service (FaaS) 平台，实现快速部署和自动扩展。
目前，最流行的 Serverless 平台包括 AWS Lambda、Azure Functions、Google Cloud Functions 等。这些平台提供了一系列的功能，如自动扩展、事件触发、监控和日志等，可以帮助开发人员更好地构建和部署 Serverless 应用程序。
总的来说，云原生技术是一个综合性的概念，涵盖了多个方面的技术和实践。这些技术和实践旨在帮助企业更好地构建和运行现代化的应用程序，提高应用程序的可靠性、可伸缩性和可维护性，帮助企业更好地管理和运营现代化的应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6776e6073264757c654887766b106098/" rel="bookmark">
			使用rollup打包ts&#43;react缓存组件发布npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个项目目录比如叫root,下面新建一个rollup的配置文件: rollup.config.ts 因为rollup良好支持ts和esmodule 所以用ts配置文件
Setup 生成一个package.json文件,这里用pnpm生成:
pnpm init 安装rollup和Typescript:
pnpm add rollup pnpm add typescript 配置package.json的pnpm build命令:
{ "scripts": { "build": "rollup --c --configPlugin typescript2 --bundleConfigAsCjs", "build:dev": "cross-env NODE_ENV=development pnpm build", "build:prod": "cross-env NODE_ENV=production pnpm build" }, "type": "module" } rollup是跑在node环境的,node的模块化是commonjs不支持esmodule的 所以要在package.json的运行脚本里配置一个rollup命令–bundleConfigAsCjs将esmodule代码解析成commonjs让nodejs能够认识 然后package.json还要加上type:module支持esmodule
build命令解释:
–c是指定rollup读取项目根目录下的rollup.config配置文件进行构建–configPlugin是指定rollup构建时要使用的插件 包括对rollup配置文件的处理 这里指定用typescript2这个插件来处理ts的配置文件 防止rollup配置文件读取报错–bundleConfigAsCjs是rollup的一个命令用来将esmodule转换成commonjs便于node环境中使用cross-env是一个插件用来抹平不同操作系统中设置环境变量的方式,不同操作系统环境变量设置方式是不一样的 我们不能一个个去弄 所以用来实现跨平台的设置环境变量build:dev和build:prod用来根据获取环境变量注入的值process.env.NODE_ENV来做不同的操作type:module也是配置支持esmodule的一步 要加上 rollup.config.ts配置文件 文件要求导出一个RollupOptions对象/RollupOptions[]对象数组 一个对象就是一个文件的打包配置 要打包多少就多少个配置对象 这里我就指定一个入口文件对外暴露三个接口就行 rollup会根据入口文件的导入引用去查找文件进行构建
rollup配置文件配置:
import nodeResolve from '@rollup/plugin-node-resolve' import typescript2 from 'rollup-plugin-typescript2' // @ts-ignore import babel from 'rollup-plugin-babel' import commonjs from '@rollup/plugin-commonjs' import { join, resolve } from 'path' import { readdir } from 'fs/promises' import { RollupOptions, defineConfig } from 'rollup' import { IOptions } from 'rollup-plugin-typescript2/dist/ioptions' import { existsSync } from 'fs' import { unlink, rmdir, lstat } from 'fs/promises' const commonPlugins = [ nodeResolve({ extensions: ['.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6776e6073264757c654887766b106098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9034233d9506d34a4a17b4a87a8df9f/" rel="bookmark">
			python如何把excel文件转化为json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- import os import sys import openpyxl import json import io # 将json保存为文件 def save2json(jd, json_file_name): file = io.open(json_file_name, 'a+', encoding='utf-8') # 把对象转化为json对象 # indent: 参数根据数据格式缩进显示，读起来更加清晰 # ensure_ascii = True：默认输出ASCII码，如果把这个该成False, 就可以输出中文。 #txt = json.dumps(jd, ensure_ascii=False) #一次性把所有都转换为放入，然后在write for dict in jd: json.dump(dict, file, ensure_ascii=False) #dump会自动给没一条数据换行 file.write('\r') file.close() # excel表格转json文件 def excel2json(excel_file, json_file_name): # 加载工作薄 book = openpyxl.load_workbook(excel_file) # 获取sheet页 sheet = book["Sheet1"] # 行数 max_row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9034233d9506d34a4a17b4a87a8df9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca120777fbf4d784265c999b2dac0e8e/" rel="bookmark">
			vue.js动态数字时钟代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
vue.js动态数字时钟代码是一款带日期和星期天数的时钟特效。
dd:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dafa52560128c328599c5a571d26eb/" rel="bookmark">
			不同交换机上相同vlan的互联互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同交换机上相同vlan的互联互通 今日问题：连通两个平台的交换机来进行业务迁移。 环境：生产环境、安超测试平台均已搭建
二层交换机端口默认模式是access（通道）模式，此模式只允许有且仅有一个vlan帧通过，即默认Vlan1，若两台交换机共有三个vlan，他们相同vlan之间需要通信则需要在这两台交换机之间连接三条线，分别为这三个vlan使用。这种方法对交换机端口的利用率非常低。若要使vlan10内的两台主机互相通信运用上述方式的话。则需要在两台交换机上分别做配置，将0/3接口线路分配给vlan10使用以传输vlan10的帧。此时0/3接口只能传输vlan10的数据不能传输其他vlan的数据。
核心命令：
Switch(config)#int fa 0/3 Switch(config-if)#switchport mode access /将端口模式改为access（默认此模式可以不更改） Switch(config-if)#switchport access vlan 10 /将此端口加入vlan10供传输vlan10数据 在两台交换机上分别执行上述命令，即可达到PC0与PC2通信的目的。如下图所示。
两台主机ping测试也能通过，如下图所示。
上述方法并不常用，这种方法对设备端口利用率非常低，在实际生产中较为少见。
中继链路实现：
中继链路即vlan中继，指的是在两台交换机之间只用连接一条链路并且将这条链路更改为中继链路（Trunk）供所有vlan传输数据，成为trunk链路的通道并不是为某个vlan传输数据，而是为所有vlan传输数据。达到端口利用的最大化。如下图所示。
Switch(config)# int g0/1 Switch(config-if)# switchport mode trunk /将链路改为trunk模式（默认允许所有vlan通过） 两边交换机分别执行上述命令即可。
利用ping命令检测是否配置成功。两个vlan内的主机互相ping通，则配置成功如下图所示。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/153/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>