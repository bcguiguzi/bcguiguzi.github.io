<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef89a1bbcd385b02d3c182480e63be3/" rel="bookmark">
			【算法练习】字符串重新排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【100分】
题目描述： 给定一个字符串s，s包含以空格分隔的若干个单词，请对s进行如下处理后输出：
1、单词内部调整：对每个单词字母重新按字典序排序；
2、单词间顺序调整：
1）统计每个单词出现的次数，并按次数降序排列；
2）次数相同时，按单词长度升序排列；
3）次数和单词长度均相同时，按字典序升序排列。
请输出处理后的字符串，每个单词以一个空格分隔。
输入描述： 一行字符串，每个字符取值范围：[a-zA-Z0-9]以及空格，字符串长度范围：[1, 1000]
输出描述： 重新排序后的字符串，每个单词间隔1个空格，且首尾无空格
示例
示例1
输入： This is an apple
输出： an is This aelpp
示例2
输入： My sister is in the house not in the yard
输出： in in eht eht My is not adry ehosu eirsst
知识点：排序，数组
类似题：https://www.nowcoder.com/discuss/454418146515021824?sourceSSR=search
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8210e8b2aa42b8aa490972d58bf95fad/" rel="bookmark">
			C筑基——深入理解内存对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前言2 正文2.1 为什么要有内存对齐？2.2 内存对齐原则2.2.1 基本数据类型是自然对齐的2.2.2 包含基本数据类型成员的结构体套用结构体内存对齐原则来分析使用 gdb 查看这两个结构体的成员内存位置结构体类型变量是自然对齐的吗？ 2.2.3 数组类型 2.3 修改编译器的默认对齐方式（系数）编译器的默认对齐方式（系数）为什么要修改编译器的默认对齐系数？如何修改编译器的默认对齐系数？为什么修改了对齐系数会影响结构体的长度？发送方和接收方对同一个结构体使用不同的对齐系数例子 3 最后参考 1 前言 11月份的时候，同事维护的项目出现了内存对齐问题：传递数据的一方使用了 #pragma pack(4) 修改了结构体的对齐方式，而接收方数据的一方并没有对这个结构体使用同样的对齐方式，造成了获取数据时失败的问题。
本文主要说明：
为什么要有内存对齐？内存对齐原则如何修改默认对齐方式？ 2 正文 2.1 为什么要有内存对齐？ 单字或者双字操作数的存储跨越了 4 字节边界，或者一个四字节操作数的存储跨越了 8 字节边界，被认为是未对齐的。为了访问未对齐的内存，处理器需要作两次内存；而如果内存是对齐的，处理器仅需要一次内存访问。
处理器在访问内存时，每次读取一定的长度（这个长度就是处理器的默认对齐系数，或者是默认对齐系数的整数倍）。这个长度就是指上段中描述的 4 字节边界或者 8 字节边界。
需要说明的是，开发者并不需要直接负责如何进行内存对齐，编译器默认会对标准数据类型，结构中的成员数据进行内存对齐。开发者需要学习编译器进行内存对齐的原则，以便解决实际开发中的问题。
2.2 内存对齐原则 2.2.1 基本数据类型是自然对齐的 如果一个变量的内存地址正好是这个变量的长度的整数倍，那么这个变量就是自然对齐的。
这里通过代码来说明 char，short，int，double 类型变量是自然对齐的：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define mark(num) (num) == 0 ? "√" : "×" int main(void) { printf("sizeof(char): %zd, sizeof(short): %zd, sizeof(int): %zd, sizeof(double): %zd\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8210e8b2aa42b8aa490972d58bf95fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde77ea550b5bf1a227b40ad0d9b2f85/" rel="bookmark">
			领导叫你带徒弟怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		领导叫你带徒弟怎么办？我是做单片机嵌入式软件开发的，想了很久，写下来，发给领导了。
尊敬的领导，你好！
你已经两次提到叫XXX跟我学习写程序，我想你是认真的。
可以，没问题。但我先讲一下学习的难度。所有在校学习单片机的学生，即使有老师带，毕业之后，仍大约有90%的人写不了程序，做不了产品，因为他们没经验。
合肥有很多小公司，为在校学生提供实习的机会。学生们通常在周六和周天去上班。这些人将来都是选择走技术之路，或者是兴趣所使，没有工资或工资很少,也愿意干。为了获取经验，他们很吃苦，迫切希望能遇到有经验的工程师带他们上岸。有部分学生没有实习机会，就通过网络向有经验的人请教。除了吃饭睡觉，玩一小会游戏，几乎整日都在学习中度过，没有休息日，经常会学到夜深人静。干这一行，基本都是苦行僧。我当初也和他们一样。
学习需要加入很多交流学习群，人很多，但提问不一定会有人回你。水平差不多的，可能会聊得很火热。偶尔也会遇到热心人，给你指点迷津，但大部分都是在自言自语。
公司搞培训，要选好对象，其一是有兴趣，其二是能吃苦，其三是悟性好。基础差的，自己去打基础。但是给他上课是不可能的，公司还有很多事情要做，若在闲暇时，他们问，我来答，这是可以的。其他休息时间，公司给点钱，总不能白干吧，再说公司也不差这点钱。反正公司要发展，也需要人，现在招聘也难。为什么要钱?原因是担心将来学不会，有人会说我不用心教，或在在背后说我的小话，败坏我的名声，就当是给点精神损失费吧。最后一点，就是师傅领进门，修行在个人。包教包会，不大可能，反正我会用心去教。若能给多点额外的报酬，我就抽时间写教材。一年学不会，就两年，总能学会的。搞搞小程序开发，还是可以的。最难的是底层驱动程序开发，需要有硬件功底，要能看懂资料。常用的通讯可以去讲讲，实践还得靠自己，讲到嘴，讲不到心。
培训后的员工，还不能马上胜任编程工作，技术沉淀还需要一个过程，但公司还必须得给他们加薪，不加就不想干，讲不得，说不得，培训出个冤家来。在他们认为公司培训他们是为了榨取更多的剩余价值。不懂得感恩，建议最好不要去培训，要会自己去学。外面也有单片机培训班，可以叫他们去试试，看看他们愿不愿意掏钱，就知道了。
若可行，开发板，买两套，我一套，XXX一套，可以随时一对一沟通对接。
祝我们合作愉快！请你考虑一下。
发给领导后，周一去上班，没再说培训的事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01cc4bac2c4833832968240416ec99c/" rel="bookmark">
			更换服务器密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.鼠标右键点击我的电脑-&gt;选择“管理“选项。
2.点击"工具"（服务器有这个步骤）-&gt;在点击"计算机管理"
3.点击打开计算机管理界面，点击"系统工具"-&gt;"本地用户和组"-&gt;双击打开"用户"-&gt;右键点击某个用户-&gt;选择"设置密码"。
设置密码后，关闭远程或休眠。再次进入就需要输入新设置的密码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e2fd501faf96b1ffd350f0d2186ac2/" rel="bookmark">
			【GIS：基于shp矢量文件抠除栅格内部数据及批量处理（无需编程）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.单个栅格文件抠除【以抠除长春市内部水体举例】
编辑长春市水体shp文件 利用矢量编辑中的“merge”融合功能，将长春市水体中的多个水体要素融合为一个整体要素
对上述编辑的矢量要素新建要素，这里我们要创造一个图层蒙版
整个蒙版边界要将长春市包含进去
利用矢量编辑中的“clip”裁剪功能，选中长春市水体
clip功能弹出的窗口如下，选择“discard the area intersects”丢弃相交区域，ok执行成功后键盘敲一下delete键，相当于把选中的水体删除了，这样留下的才是去除水体后蒙版区域的剩余区域。
保存shp文件，这时我们就得到了想要的蒙版
按蒙版提取栅格文件，这个大家都会
得到了抠除长春市水体的栅格数据
2.批量处理：掌握了单个栅格数据抠除技巧，批处理时只需要结合栅格迭代器即可。
基于GIS的栅格迭代器——需要处理的栅格文件存在同一文件夹中，输出文件时注意文件命名为%name%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5149958a81895494360eba5baf5fa0d7/" rel="bookmark">
			Windows7下安装Anaconda3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在旧电脑（windows7）上直接安装Anaconda3官网提供的安装包时，出现了"Failed to create menus"问题：
在网上搜索了相关解决办法：
安装路径中不能包含中文字符（查看自己的 目录名字） 系统相对路径过长，修改路径放在盘的根目录下 使用默认安装路径，不适用自定义路径 安装时选择All users，而不是默认的 Just Me 我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt; 删除JAVA_HOME，以及PATH （注意提前保存path内容，安装完anaconda后，需要重新添加path） 重装操作系统 发现均无法解决此问题。
问题分析 在其中一个解决方法中提到了出现此错误是因为没有成功建立Anaconda的目录，可以通过控制台执行
python .\Lib\_nsis.py mkmenus 命令来实现目录建立。
但执行后提示没有安装python，但Anaconda安装过程中应该是包含了python安装的，由此怀疑是python安装过程出现问题。
在Anaconda官网发现，最新安装包所使用的是python3.9版本，但在python官网的版本列表中可以看到：
python3.9版本是不能在Windows7上使用的，最后一个支持Windows7的python版本为3.8！因此造成了Anaconda3安装过程中python没有被成功安装，也就无法通过执行python脚本来为自己创建目录。
问题解决方法 根据上述分析，需要找到python3.8版本对应的Anaconda，在这个网址可以找到anaconda的所有版本：
https://docs.anaconda.com/anaconda/packages/oldpkglists/
可以下载对应3.8或更低python版本的anaconda安装包，我下载了2020.02版本的Anaconda3安装包并成功安装在了Windows7系统上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a0d41d865016a87175667fbfc4c5c5/" rel="bookmark">
			以太网移植操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以太网：ST芯片内只有集成了MAC，并没有PHY，所以要外接一个LAN8720（DM9000）以太网芯片，之所以不集成到芯片内部是可能还是因为该芯片是模拟电路，如果添加进去会造成一定的功耗或IC的工艺不够
通信过程：MAC---》MII/RMII接口--》PHY
1.STM32F4以太网(Ethernet)MAC
1.1、MAC简介
STM32F407自带有10/100Mbit/s的以太网MAC内核，这个以太网MAC内核有 如下特性：
1、支持外部PHY接口实现10/100Mbit/s数据传输速率。
2、通过符合IEEE802.3的MII接口与外接快速以太网PHY进行通信
3、支持全双工和半双工操作
4、报头和帧起始数据(SFD)在发送路径中插入、在接收路径中删除
5、可逐帧控制CRC和pad自动生成。
6、可编程帧长度，支持高大16KB的巨型帧。
7、可编程帧间隔。
8、支持通过MDIO接口配置和管理PHY设备
STM32F407的ETH框图如下：
1.2、F407的MAC有3种接口：SMI、MII和RMII。
1.2.1、SMI站管理接口，程序中可以通过这个接口来访问PHY寄存器，SMI接口有两条线：数据线MDIO和时钟线MDC，该接口支持访问多达32个PHY。
MDC：周期性时钟，提供以最大频率 2.5 MHz 传输数据时的参考时序，在空闲状态下， SMI 管理接口将MDC 时钟信号驱动为低电平。
MDIO：数据输入/输出比特流，用于通过 MDC时钟信号向/从PHY 设备同步传输状态信息。
1.2.2、 MII介质独立接口：定义了 10Mbit/s 和100 Mbit/s 的数据传输速率下MAC 子层与PHY 之间的互连。
TX_CLK和RX_CLK为发送和接收连续时钟，当速率为10Mbit/s时为2.5MHZ，速率为100Mbit/s时为25MHZ。
要生成TX_CLK和RX_CLK时钟，必须向外部PHY提供25MHZ时钟，通常我们使用25M的晶振，也可以使用STM32F4xx的MCO引脚输出25MHZ的时钟。
1.2.3、RMII精简介质独立接口:规范降低了 10/100Mbit/s 下微控制器以太网外设与外部PHY 间的引脚数。根据 IEEE 802.3u 标准，MII 包括16 个数据和控制信号的引脚。RMII 规范将引脚数减少为 7 个（引脚数减少62.5%）。不过RMII接口的参考时钟必须是50MHZ！
RMII时钟源：通常使用50MHZ的时钟驱动PHY或使用嵌入式PLL生成50MHZ频率来驱动PHY。
2、LAN8720
2.1、LAN8720简介
LAN8720是低功耗的10/100M以太网PHY层芯片，I/O引脚电压符合IEEE802.3-2005标准。LAN8720支持通过RMII接口与以太网MAC层通信，内置10-BASE-T/100BASE-TX全双工传输模块，支持10Mbps和100Mbps。LAN8720可以通过自协商的方式与目的主机最佳的连接方式(速度和双工模式)。支持HP Auto-MDIX自动翻转功能，无需更换网线即可将连接更改为直连或交叉连接。
1、支持RMII接口以减少引脚数
2、支持全双工和半双工模式
3、可以使用25M晶振以降低成本
4、支持SMI串行管理接口
5、支持MAC接口
PHY地址设置
前面说了MAC可以通过SMI接口来读写PHY(LAN8720)的寄存器，SMI最多可以控制32个PHY芯片，通过不同的PHY芯片地址来对不同的PHY操作。LAN8720通过设置RXER/PHYAD0引脚来设置其PHY地址，默认情况下为0，其地址设置如下表所示。我们STM32F407开发板使用的是默认地址，也就是0X00。
RXER/PHYAD0引脚状态
PHY地址
上拉
0X01
下拉（默认）
0X00
nINT/REFCLKO配置
nINTSEL引脚(2号引脚)用于设置nINT/REFCLKO引脚(14号引脚)的功能。nINTSEL配置如下表所示。我们STM32F407开发板使用的是REF_CLK Out模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a0d41d865016a87175667fbfc4c5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eea291e4783c44c1476b1c0e8adc9cc/" rel="bookmark">
			css 修改浏览器滚动条样式（火狐Firefox，谷歌google）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改谷歌google： 修改样式：
1.全局修改，所有滚动条生效：
::-webkit-scrollbar{width:6px;height:6px;
background-color: #00000040;
}
::-webkit-scrollbar-thumb{background-color:rgba(0,0,0,1);border-radius:10px;}
::-webkit-scrollbar-track{background-color:transparent; }
2.针对某个容器来修改：
.mainPannel::-webkit-scrollbar{width:4px}
.mainPannel::-webkit-scrollbar-track{background-color:#ccc;}
.mainPannel::-webkit-scrollbar-thumb{background-color:#666;}
隐藏滚动条：
/* H5的时候，隐藏滚动条 */
// ::-webkit-scrollbar {
// display: none; // width: 0 !important; // height: 0 !important; // -webkit-appearance: none; // background: transparent; // }
二、修改火狐Firefox： 修改火狐滚动条样式的css属性只有 scrollbar-color 和 scrollbar-width 。
scrollbar-color: auto; /* 使用浏览器默认的滚动条样式 */
scrollbar-color: dark; /* 使用浏览器默认的深色或者黑色滚动效果 */
scrollbar-color: light; /* 使用浏览器默认的浅色滚动效果 */
scrollbar-color: red #00f; /* 第一个颜色为滚动条的颜色， 第二个颜色为滚动条轨道的颜色 */
scrollbar-width: auto; /* 使用浏览器默认的滚动宽度 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eea291e4783c44c1476b1c0e8adc9cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee5fed19bcbe657b00bd21aeb8392ff/" rel="bookmark">
			方格游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
〇，前言
一，数据建模
1，名词澄清
2，块的表示
3，块的初始化
4，玩家数据
5，玩家初始化
二，界面
1，方格输出
2，游戏界面
三，游戏规则
1，翻转和旋转
2，核心逻辑、结束控制
3，主控程序
4，玩家操作
四，完整代码
五，规则对比
〇，前言 因为是一边设计一边写代码一边写博客，所以本文的中间代码很多都不是最新版本，
代码以最终完整版为准。
一，数据建模 1，名词澄清 一个玩家有21个块，每个块由1-5个格子组成。
2，块的表示 对每个块，用最多5个点把每个格子的坐标存起来
typedef struct Point { int x,y; }Point; typedef struct Node { int num; Point p[5]; }Node; 那么，如何建立坐标系呢？
对每个块拓展为它的凸包，并把最左上角的快设为（0,0）那么所有格子的坐标都是2个非负整数组成。
实际上，除了十字交叉的块之外，其他20个块都可以适当的旋转和翻转，使得它的凸包的最左上角的点上有一个格子。
int num[]={5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,3,5,4,3,2,1}; int matrix[]={ 0,0,0,1,0,2,1,1,2,1, 0,0,1,0,1,1,1,2,2,1, 0,0,1,0,1,1,1,2,2,2, 0,1,1,0,1,1,1,2,2,1, 0,0,0,1,1,1,1,2,2,2, 0,0,0,1,0,2,1,2,2,2, 0,0,0,1,0,2,1,2,1,3, 0,0,0,1,0,2,0,3,1,2, 0,0,0,1,0,2,0,3,1,3, 0,0,0,1,0,2,1,0,1,2, 0,0,0,1,0,2,1,0,1,1, 0,0,0,1,1,0,1,1, 0,0,0,1,0,2,1,0, 0,0,0,1,1,1,1,2, 0,0,0,1,0,2,1,1, 0,0,0,1,1,0, 0,0,0,1,0,2,0,3,0,4, 0,0,0,1,0,2,0,3, 0,0,0,1,0,2, 0,0,0,1, 0,0, }; 对应代码，有20行都是0,0开头，只有一行不是。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee5fed19bcbe657b00bd21aeb8392ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f905c13835cea735bc4dc7fb6bc856f/" rel="bookmark">
			【云原生】k8s的pod基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、资源限制 Pod 是 kubernetes 中最小的资源管理组件，Pod 也是最小化运行容器化应用的资源对象。一个 Pod 代表着集群中运行的一个进程。kubernetes 中其他大多数组件都是围绕着 Pod 来进行支撑和扩展 Pod 功能的，例如用于管理 Pod 运行的 StatefulSet 和 Deployment 等控制器对象，用于暴露 Pod 应用的 Service 和 Ingress 对象，为 Pod 提供存储的 PersistentVolume 存储资源对象等。
二、Pod 的两种使用方式 一个 Pod 中运行一个容器。每个 Pod 中一个容器的模式是最常见的用法，在这种使用方式中，你可以把 Pod想象成是单个容器的封装，kubernetes 管理的是 Pod 而不是直接管理容器。在一个 Pod 中同时运行多个容器。一个 Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service单位，比如一个容器共享文件，另一个 sidecar 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。 三、Pod 资源共享 一个 Pod 下的容器必须运行于同一节点上。**现代容器技术建议一个容器只运行一个进程，该进程在容器中 PID 命令空间中的进程号为 1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。
若想在容器内运行多个进程，需要有一个类似 Linux 操作系统 init 进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这是由于容器间的隔离机制导致，k8s 中的 Pod 资源抽象正是解决此类问题，Pod 对象是一组容器的集合，这些容器共享 Network、UTS 及 IPC 命令空间，因此具有相同的域名、主机名和网络接口，并可通过 IPC 直接通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f905c13835cea735bc4dc7fb6bc856f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce3e1b12680718f7e3622b1c0c04456/" rel="bookmark">
			Fast_boot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fast_boot:
1.http://elinux.org/Deferred_Initcalls
echo 1 &gt; /proc/deferred_initcalls
2.https://www.elinux.org/Boot_Time
3.CONFIG_CC_OPTIMIZE_FOR_SIZE
4.https://elinux.org/Disable_Console#Projects
Disable Consoles
5.Disabled PTYS saved 0.64 s. 6.precalibrates a delay loop(lpj) can save 180ms
7.http://en.wikipedia.org/wiki/Ltrace APP (measure time)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781fee2c62fe6839b624cce7e8a403a3/" rel="bookmark">
			多区域的OSPF实战配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多区域的OSPF实战配置 需求 如图配置设备的接口IP地址如图规划OSPF网络的区域要求每个设备的 router-id 都是 x.x.x.x（x是每个路由器的名字）确保不同的PC之间可以互通 拓扑图 配置命令 PC1： 192.168.1.1 255.255.255.0 192.168.1.254 PC2: 192.168.2.1 255.255.255.0 192.168.2.254 R1: undo terminal monitor system-view sysname R1 interface gi0/0/2 ip address 192.168.1.254 24 quit interface gi0/0/0 ip address 192.168.12.1 24 ospf authentication-mode simple plain hcip quit ospf 1 router-id 1.1.1.1 area 12 network 192.168.12.0 0.0.0.255 network 192.168.1.0 0.0.0.255 quit quit R2: undo terminal monitor system-view sysname R2 interface gi0/0/1 ip address 192.168.12.2 24 ospf authentication-mode simple plain hcip quit interface gi0/0/0 ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781fee2c62fe6839b624cce7e8a403a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28ea0e25bb24922d107b0d720058764/" rel="bookmark">
			python 查看import package/function的具体路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qingfengxd1/article/details/105610274
https://blog.csdn.net/Li_Hungchieh/article/details/102991834
如下查看nn/d2l包的具体路径，以及查看nn.CrossEntropyLoss函数的路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e341d730fd8ac6801275fbc0d83f88c/" rel="bookmark">
			青龙面板教程(四)：线报监控系统开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 青龙面板挂活动，那就少不了线报，尤其是JD系活动的环境变量。通常线报都是在TG上发布的，由于网络限制的原因，获取也很不方便。市面上也有TG线报系统，不过大多都是付费的，我们完全可以自己开发一个定制的线报系统，监控活动和自动更新环境变量执行任务，解放双手，无需时刻守护。
二.原理介绍 核心是TDLib，TG官方提供了TG数据库库（或简称为 TDLib），这是一种供第三方开发人员使用的工具，可以轻松构建快速、安全且功能丰富的 TG应用程序。
TDLib 负责所有网络实现细节、加密和本地数据存储，以便开发人员可以将更多时间用于设计响应式界面和精美动画。
TDLib 支持所有 TG功能，并使在任何平台上开发 TG应用程序变得轻而易举。它可以在 Android、iOS、Windows、macOS、Linux 和几乎任何其他系统上使用。该库是开源的，几乎与任何编程语言兼容。
简而言之，就是利用了TDLib开发一个TG客户端来接收消息，然后提取我们需要的内容。
三.系统开发 TDLib支持的编程语言很多，为了开发和部署方便，这里选择了Python语言，同时官方也提供了Python+TDLib环境的Docker容器，我们只需要安装好容器，编写我们业务逻辑代码就行。
1.安装环境 宝塔面板——终端，拉取官方python-telegram镜像并建立容器，容器默认命名为py-tg，最大内存为512MB，不映射端口和目录，无特殊要求，输入如下命令即可：
docker run -dit --name py-tg -m 512MB akhmetov/python-telegram:latest 为了方便操作，我们采用宝塔面板自带的Docker模块进行接下来的操作，宝塔面板——Docker，可以看到刚创建的py-tg容器
至此，环境已搭建完毕。
2.业务代码 利用python-telegram的接口，我们可以实现TG客户端接收消息。在这里只实现自动更新环境变量的功能。
（1）在宝塔面板——Docker中打开py-tg容器的目录，可看到目录结构如下：
点击进入app目录，里面有个examples文件夹，这是官方提供的例子我们不管，接下来在app目录下创建三个文件：ql.py、config.json和main.py
（2）先编写青龙面板的环境变量提取和导入的逻辑代码，利用到了青龙面板的OpenApi，新建文件，命名为ql.py，代码如下：
import re import requests from json import dumps as jsonDumps class QL: def __init__(self, address: str, id: str, secret: str) -&gt; None: """ 初始化 """ self.address = address self.id = id self.secret = secret self.valid = True self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e341d730fd8ac6801275fbc0d83f88c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab30401efae73a92e09e39117385e3c/" rel="bookmark">
			sqlmap工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlmap Sqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库
Sqlmap采用了以下5种独特的SQL注入技术
基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已经执行(即页面返回时间是否增加)来判断基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中联合查询注入，在可以使用Union的情况下注入堆查询注入，可以同时执行多条语句时的注入 基础参数 测试信息展示(-v 0)(mozhe靶场) 测试时，可以使用 -v 等级 参数指定回显信息的复杂度，其范围为[0~6]，共有 7 个等级，默认为 1
0：只显示python错误以及严重的信息 1：同时显示基本信息和警告信息（默认） 2：同时显示debug信息 3：同时显示注入的payload 4：同时显示HTTP请求 5：同时显示HTTP响应头 6：同时显示HTTP响应页面 如果想看到 sqlmap 发送的测试 payload 最好的等级就是3没思路时也可以借鉴工具构造的payload扩展思路python sqlmap.py -u "http://219.153.49.228:45269/new_list.asp?id=2" -v 3 使用–batch会自动选项默认的选项执行，但可能会触发防火墙的告警
python sqlmap.py -u "http://127.0.0.1/sqlb/Less-1/?id=1" --batch 根据文本判断是否存在注入(-r 1.txt)(mozhe靶场) 将一个 HTTP 请求保存在文件中，使用参数-r加载该文件，其会解析该文件并发送请求，一般用于表单提交时的注入等发送数据复杂时的情况
当请求是HTTPS的时候需要配合–force-ssl参数来使用，或者可以在host头后面加上：443
将数据包存放到txt文件中，随后使用命令执行
python sqlmap.py -r zxgtwy.txt 探测等级选择(–level 1) 参数–level 等级 可以选择需要执行的测试等级，一共有5个等级[1-5]，不加 level 默认是1。5级包含的 Payload 最多，会自动破解出 cookie、XFF等头部注入。等级越高，执行的时间也会增长
该参数会影响测试的注入点，GET和POST的数据都会进行测试，HTTP cookie 在 level 为2时就会测试，HTTP User-Agent/Referer 头在 level 为3时就会测试。level为5时会检测Host是否存在注入漏洞。当在不确定哪个 payload 或参数为注入点时，为了保证全面性，建议使用高的 level 值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab30401efae73a92e09e39117385e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cfdb5ab84ae0810dcdc16fff56d63a/" rel="bookmark">
			C&#43;&#43;中vector容器的三种遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt;//标准算法头文件 void myPrint(int val) { cout&lt;&lt;val&lt;&lt;endl; } int main() { //创建一个vector容器 vector&lt;int&gt; v; //向容器中插入数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); //需要通过迭代器遍历访问容器中的元素 //第一种遍历方式 vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器指向容器中的第一个元素 vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器指向容器中最后一个元素的下一个位置 while (itBegin != itEnd) { //迭代器就是一个指针 需要解引用才能取出里面的值 cout &lt;&lt; *itBegin &lt;&lt; endl; itBegin++; } //第二种遍历方式 for(vector&lt;int&gt;::iterator it = v.begin();it!=v.end();it++){ cout&lt;&lt;*it&lt;&lt;endl; } //第三种遍历方式 利用STL中提供的遍历算法 需要先引入头文件&lt;algorithm&gt; //三个参数为 起始迭代器 结束迭代器 函数 //myPrint这个函数是个回调函数 for_each(v.begin(),v.end(),myPrint); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fe48170578cca869eb8ff5349aff19/" rel="bookmark">
			Ant-design 的 a-tree-select 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：
树形结构中的children 和 labels 需要同时展示在页面
递归处理数据，将labels 合并进入children
展示labels时需要在前面加一个标记○
// 需求1 需求2 /** * @description 获取标签分类的树形结构 */ getData(data, dataIndex) { const list = data.map((item, index) =&gt; { if (item.children &amp;&amp; item.children.length &gt; 0) { item.children = item.children.map((child) =&gt; { return { ...child, type: 'children', // 添加标识符，判断是否为children/labels 给需求4使用 label: child.name, // a-tree-select 中为选中子节点的内容和展示字节点内容做区分 } }) this.getData(item.children, dataIndex + '-' + index) } else { item.children = [] } if (item.labels &amp;&amp; item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fe48170578cca869eb8ff5349aff19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c840fb4e46468e5948fc3d3b8f99cb/" rel="bookmark">
			EMOS在线协同办公小程序解决Illegal instruction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 人脸识别小程序 上dokcer输入
nohup python3 -c "from app import app;"&gt; log.out 2&gt;&amp;1 &amp;
报错
[1]+ Illegal instruction (core dumped) nohup python3 -c "from app import app;" &gt; log.out 2&gt;&amp;1
解决方案 请私聊
以及这两个文件要的私聊 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6a0afdc2fa2e28a3349d89dce0abfc/" rel="bookmark">
			Qt强大控件：Qt-Advanced-Docking-System介绍及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概述 1.控件描述 QT自带的Dock布局管理大家都用过，中规中矩，但是满足不了现在ui强大的人机交互需求。而Qt-Advanced-Docking-System在Dock的基础上进一步完善功能，具有更高的自由度、灵活性和可扩展性，满足程序员对人机交互的自由定义。这个开源控件类似于Devexpress中的DockPanel。
2.下载地址 免费下载
二.使用教程 1.新建QT项目 在新建项目时，要选择子目录项目。
新建父项目后，会自动弹出子项目新建选项。
这个按照常规QT项目新建。
到这里，项目新建完成，下面可以开始编写代码了。
2.引入Qt-Advanced-Docking-System
解压Qt-Advanced-Docking-System-master.zip，找到src和ads.pri。
将src和ads.pri拷贝到父项目文件夹下
打开父项目.pro文件，在.pro中添加
DockUse.depends = src 打开子项目中.pro文件，在.pro中添加
# dock use ADS_OUT_ROOT = $${OUT_PWD}/.. # dock use DESTDIR = $${ADS_OUT_ROOT}/lib CONFIG += debug_and_release adsBuildStatic { DEFINES += ADS_STATIC } #LIBS += -L$${ADS_OUT_ROOT}/lib include(../ads.pri) INCLUDEPATH += ./src DEPENDPATH += ./src LIBS += -LD:/LiumuyiProgram/QTCode/TestPrograms/DoclProTest/ -lqtadvanceddockingd 在mainwindow.h中，引用
#include "../src/DockManager.h" #include "qlabel.h" 定义变量
ads::CDockManager* m_pDockManager; 在mainwindow.cpp中，可以在构造函数中加入：
m_pDockManager = new ads::CDockManager(this); QLabel* l = new QLabel(); l-&gt;setWordWrap(true); l-&gt;setAlignment(Qt::AlignTop | Qt::AlignLeft); l-&gt;setText("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6a0afdc2fa2e28a3349d89dce0abfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6fc70e08aff330c330f1bf015dacfc/" rel="bookmark">
			Git回滚文件常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 修改完，还未执行git add 缓存区没有任何文件时，使用
git checkout . 将暂存区的文件覆盖工作区
执行完 git add . 之后，再执行该命令是无效的，git checkout .和git add .是一对反义词
git checkout(覆盖) 1、只放弃工作区的改动，index 保持不变，其实就是从当前 index 恢复 工作区：
放弃工作区中全部的修改
git checkout . 放弃工作区中某个文件的修改：
git checkout -- filename 2、强制放弃 index 和 工作区 的改动：
git checkout -f 这是不可逆的操作，会直接覆盖，但是还是很有用的，有时候想放弃这些改动，使用svn的时候可以直接把文件删掉再update，但是使用git就不能这么操作，使用 git checkout 可以满足这一点。
git diff（查看差异） git diff 命令，默认查看的就是 工作区 和 暂存区之间文件的差异
2.使用git add 提交到暂存区，还未commit之前 撤销单个文件：
git reset HEAD file(文件名) 撤销多个文件：
git reset HEAD 3.已经git commit，还未git push git reset --hard origin/master 清空暂存区，执行此操作后要重新git add 后重新git commit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6fc70e08aff330c330f1bf015dacfc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/173/">«</a>
	<span class="pagination__item pagination__item--current">174/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/175/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>