<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6b1cf39097f623d779249bd879e14d/" rel="bookmark">
			‘javac‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在搭建Android自动化测试环境的时候，需要安装JDK，并配置环境
第一步：jdk下载
第二步 JDK安装
第三步 配置环境变量
第四步 查看是否安装完成，环境变量配置好了
打开cmd,输入java，java -version没有问题，但是javac提示不是内部命令
第五步 排查问题
1、新建系统环境变量JAVA_HOME变量值为C:\Program Files\Java\jdk-12.0.1
2、编辑Path添加%JAVA_HOME%\bin
3、新建系统环境变量CLASSPATH，变量值为.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369afd71cb420b3ff4b9309b66e15a77/" rel="bookmark">
			web前端行业调研报告_「干货福利」何如写一份行业调研报告？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一定要看到最下方哦，福利隐藏
大家都知道调研对企业发展的重要性，企业通过调研能够更好地进行产品策略的调整，从而使企业进入健康发展的良性循环模式。
而在调研过程中也需要写调研报告，那行业调研报告怎么写？我们在写行业调研报告过程中要特别注意哪些问题?接下来就对这一情况做详细解析与介绍，希望对有写这方面报告的人能提供有效的建议。
01
在写行业调研报告过程中首先要对整个行业背景有个大概了解，可以对行业的发展历程以及历史有个比较明确的认识，这对写好整个行业调研报告有着重要作用。
02
然后就是进行基本情况的介绍了，把调查所收集到的基本情况进行介绍，在这方面描述中要做到简洁明了、用词准确，且具有比较强的概括力度，能够比较详细具体地把整个基本情况描述恰当。
03
行业调研报告的第三方面就要做到分析预测作用，能够对行业发展的趋势做出预测，从而让行业在自身调整中做好准备，使得更为符合发展的趋势，从而使得自身得到更好的发展前景。因此在做分析预测时要做到具有准确性和可行性这两方面，这样才能更好地为行业发展奠定有利的基础。
04
行业调研报告的第四方面要提出行业营销的建议以及解决问题的办法。这是整个行业调研报告的最关键之处也是最具有意义之处。在这方面建议上要做到有针对性和科学性，这样才能使提出的建议更能有效地为行业发展提供有用指导，使行业的发展进入到更为广阔的空间。因此我们在写着方面时一定要做到科学严谨，才使整个行业调研报告更加具有规范性。
由此可见我们在写行业调研报告时要做到以上四个方面，把这四个方面具体落实到了，才能让行业调研报告更加具有客观化和规范化。在写行业调研报告具体四个方面过程中，不管是在写哪一方面我们都要做到用词准确、表达精准以及简洁有力。
1
为了感谢大家的一路陪伴成长，食品伙伴网行业研究中心又来给大家送福利啦！！！本次的福利内容简单明了，我们给您送干货来啦！！！
了解到大家在研发的过程中需要撰写产品研发计划书，在不了解行业研究的框架和需要罗列的具体内容时，关于行业趋势和市场前景这部分内容怎么写呢？哪些专业名词需要罗列出来呢？领导安排下的任务怎么完成呢？
自己写又不够专业，分析带有很大主观性，找专业咨询公司预算又不够？这个时候怎么办呢？那就快来献上我们为大家准备的干货，给大家解决难题！
扫码添加微信号，备注：行业研究，给您发送以上学习资料，帮您写好行业研究报告！
说起来很容易，写起来却很难！非专业人士写作具有很大的主观性，调查数据分析还是要我们来帮你写哦！
部分文章转自网络，侵权请联系删除！
扫码添加好友邀请您进入【食品饮料报告分享群】，每日免费分享行业研究报告
联系我们
1. 加入食品饮料报告分享群
2. 食品行业研究报告、专项调研
3.公开课/投稿合作推广
(食品行业发展趋势、市场前景等)
扫码添加客服微信，回复公司名+职务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9369c3b5b01943bb42736c383f86826e/" rel="bookmark">
			python伪代码的写法_伪代码的写法（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言(Pascal，C，Java，etc)实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 介于自然语言与编程语言之间。
它以编程语言的书写形式指明算法的职能。相比于程序语言(例如Java, C++,C, Dephi 等等)它更类似自然语言。它是半角式化、不标准的语言。我们可以将整个算法运行过程的结构用接近自然语言的形式(这里，你可以使用任何一种你熟悉的文字，中文，英文 等等，关键是你把你程序的意思表达出来)描述出来. 使用伪代码, 可以帮助我们更好的表述算法, 不用拘泥于具体的实现.
人们在用不同的编程语言实现同一个算法时意识到，他们的实现(注意:这里是实现,不是功能)很不同。尤其是对于那些熟练于不同编程语言的程序员要理解一个(用其他编程语言编写的程序的)功能时可能很难，因为程序语言的形式限制了程序员对程序关键部分的理解。这样伪代码就应运而生了。
当考虑算法功能(而不是其语言实现)时，伪代码常常得到应用。计算机科学在教学中通常使用虚拟码，以使得所有的程序员都能理解。
综上，简单的说，让人便于理解的代码。不依赖于语言的，用来表示程序执行过程，而不一定能编译运行的代码。在数据结构讲算法的时候用的很多。
语法规则
例如，类Pascal语言的伪代码的语法规则是： 在伪代码中，每一条指令占一行(else if，例外)。指令后不跟任何符号(Pascal和C中语句要以分号结尾)。书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进。
算法的伪代码语言在某些方面可能显得不太正规，但是给我们描述算法提供了很多方便，并且可以使我们忽略算法实现中很多麻烦的细节。通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上号码，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤。算法的伪代码描述形式上并不是非常严格，其主要特性和通常的规定如下：
1) 算法中出现的数组、变量可以是以下类型：整数、实数、字符、位串或指针。通常这些类型可以从算法的上下文来看是清楚的，并不需要额外加以说明。
2) 在算法中的某些指令或子任务可以用文字来叙述，例如，"设x是A中的最大项"，这里A是一个数组；或者"将x插入L中"，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。
3) 算术表达式可以使用通常的算术运算符(+，-，*，/，以及表示幂的^)。逻辑表达式可以使用关系运算符=,≠,,≤和≥，以及逻辑运算符与(and),或(or)，非(not)。
4) 赋值语句是如下形式的语句：a
这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。
5) 若a和b都是变量、数组项，那么记号ab 表示a和b的内容进行交换。
6) goto语句具有形式
goto label(goto标号)
它将导致转向具有指定标号的语句。
7) 条件语句有以下两种形式：
if c then s或者
if c then s
else s′
这里c是逻辑表达式，s和s′是单一的语句或者是被括在do和end之间的语句串。对于上述两种形式，假若c为真，则s被执行一次。假若c为假，则在第一种形式中，if语句的执行就完成了，而在第二种形式中，执行s′。在所有的情况下，控制就进行到了下一个语句，除非在s或s′中的goto语句使控制转向到其它地方。
8) 有两种循环指令：while和for。
while语句的形式是
while c do
s
end
这里c是逻辑表达式，而s是由一个或更多个语句组成的语句串。当c为真时，执行s。在每一次执行s之前，c都被检查一下；假若c为假，控制就进行到紧跟在while语句后面的语句。注意，当控制第一次达到while语句时，假若c为假，则s一次也不执行。
for语句的形式是
for var init to limit by incr do
s
end
这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。(假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上)。incr的符号不能由s来该改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9369c3b5b01943bb42736c383f86826e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5cbd883435973811f2c94d6ec3942b4/" rel="bookmark">
			Vuepress执行 build,出现 window is not defined 错误。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuepress 在主题的上面提供了扩展功能，使得我们可以使用第三方依赖包进行开发，如element ui , swiper 等库。
具体做法参考官网:
vuepress官网 应用级别配置
在开发完成执行build 的时候，由于一些第三方依赖包使用了浏览器API,如window 对象, vuepress 又是服务端渲染。服务端渲染没有window 对象，会导致build 出现如下错误。
官网提供了解决方式：
vuepress 官网 浏览器 Api 访问限制
另外的解决方式：
在github issues 上找到解决方式：
原理是通过判断是不是在服务端来进行第三方依赖包的引用。
在测试的过程中发现，由于异步加载第三方依赖包，导致页面渲染会出错。
解决方式，使用async await 进行处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ab33edc845c1496fe2af6c9c91c08c/" rel="bookmark">
			python3.10_python – 为什么10/3等于3.3333333333333335而不是… 332或..334？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是因为它是最接近的(64位)浮点数可以达到10/3的“真值”.
我在这里使用cython(包装math.h nexttoward函数),因为我不知道任何内置函数：
%load_ext cython
%%cython
cdef extern from "" nogil:
# A function that get's the next representable float for the
# first argument in direction to the second argument.
double nexttoward(double, long double)
def next_float_toward(double i, long double j):
return nexttoward(i, j)
(或者@DSM指出你也可以使用numpy.nextafter)
当我显示10/3的值以及此值的上一个和下一个可表示的浮点数时,我得到：
&gt;&gt;&gt; '{:.50}'.format(10/3)
3.3333333333333334813630699500208720564842224121094
&gt;&gt;&gt; '{:.50}'.format(next_float_toward(10/3., 0))
3.3333333333333330372738600999582558870315551757812
&gt;&gt;&gt; '{:.50}'.format(next_float_toward(10/3., 10))
3.3333333333333339254522798000834882259368896484375
所以彼此可表示的浮点值是“更远”的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4540283ad392e7668a8a52f87851cd/" rel="bookmark">
			错误: 此上下文中不支持函数定义。请在代码文件中创建函数。_Vulkan编程指南(章节4-基础代码)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		章节4 基础代码 一般结构 在本章节，我们开始使用Vulkan API编写代码。
#include &lt;vulkan/vulkan.h&gt; #include &lt;iostream&gt; #include &lt;stdexcept&gt; #include &lt;functional&gt; #include &lt;cstdlib&gt; class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } 代码中，我们首先包含了Vulkan API的头文件，它为我们提供了Vulkan API的函数，结构体和枚举。此外，包含stdexcept和iostream头文件用来报错。包含functional头文件用于资源管理。包含cstdlib头文件用来使用EXITSUCCESS和EXIT_FAILURE宏。
我们将程序本身包装为一个类，将Vulkan对象存储为类的私有成员。我们使用initVulkan函数来初始化Vulkan对象。初始化完成后，我们进入主循环进行渲染操作。mainLoop函数包含了一个循环，直到窗口被关闭，才会跳出这个循环。mainLoop函数返回后，我们使用cleanup函数完成资源的清理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4540283ad392e7668a8a52f87851cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c3d1d117044b83d6b365fcad17ac39/" rel="bookmark">
			#systemverilog# 关于关键字 “randc” 的几点理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		systemverilog中经常用randc 去随机化一个变量，究竟randc 如何实现周期性赋值和体现？小实验给大家展示一下 自己做了一个小实验，去验证randc的工作机制，发现：并没有取得实际预期的结果。请大神帮忙解答一下，感谢~~~
绿皮书中，有这样有段描述：
“randc 变量，表示周期随机性，即所有可能的值都被赋过之后随机值才可能重复。注意：周期性是单一变量的周期性，例如有8个元素的randc数组就会有8种不同的周期。”
个人比较菜，没有深刻理解含义。嘿嘿~
修改程序之后，运行，得到预取效果如下：
个人比较菜，没有深刻理解含义。嘿嘿~
修改程序之后，运行，得到预取效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7170cfe9ef7b6c9edaaad9ad19ba8d5/" rel="bookmark">
			神器 Codelf ！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 “五分钟学算法”
设为 “星标”，带你挖掘更多开发神器！
大家好，我是小 G。
程序员最头疼的事情除了头发以外就是给变量或函数命名，一开始学编程语言的时候还可以 abc、a1、x2 等方式命名，等到工作过程中开始真正的项目开发时，如果还是这样随意的命名，即使同事可以忍受你的 abc，隔几个月自己再重新看代码说不定都想锤自己一顿。
这个时候，英语好的同学可以挤尽脑子想一些与中文意思差不多的单词，英语捉急的便只能求助有道翻译。但这两种方法最后的效果都让人很不满意。
有没有第三方工具可以帮助大家轻轻松松的给变量或函数命名呢？
那必须是有的：变量命名网站 Codelf。
Codelf 是通过搜索在线开源平台Github, Bitbucket, Google Code, Codeplex, Sourceforge, Fedora Projec的项目源码，帮开发者从中找出已有的匹配关键字的变量名。它支持中文查询，可以根据需要查询尽可能满足我们所需要的结果，并展示与查询结果相关的支持各种编程语言的代码片段以及代码库。
实际操作如下：
1、直接在 Codelf 网站上搜索命名建议
网站地址：https://unbug.github.io/codelf
比如说搜索「人工智能」，很快的 Codelf 在总多的优秀项目源码中找出了大神们经常使用的变量名。
2、安装插件
没有什么插件是 VSCode 不支持的。
写代码是直接右键即可，马上跳转 web 页面给出建议。
当然，Codelf 不仅支持 VSCode，同样支持 Atom、Sublime Text 和 Chrome。
文末，再给你们贴下这个网站的地址，希望每一个程序员都不要因为想变量命名而秃头。
网站地址：https://unbug.github.io/codelf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff466a49437cc45cdee9b469e01e59f/" rel="bookmark">
			笔记本外接显示器没有声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本外接显示器没有声音怎么办？ 原因：
是因为有些HDWI转接口有音频传输的功能，只需要把显示器的音频禁用就可以了 按住win + s
打开控制面板,
选择硬件和声音
选择管理音频设备
然后笔记本就有声音了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b5bef059929c25fcc4d59cb4ddf6b2/" rel="bookmark">
			Python.Scrapy爬取当当网畅销图书保存csv格式详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初步了解scrapy框架爬虫的使用。
前言：
需要安装一下第三方库 在win下 pip install scrapy pip install bs4 在mac下把pip改成pip3即可 文章目录 一、创建scrapy项目二、代码实现——编辑爬虫——1.——2. 修改两个文件 三、运行爬虫四、保存为csv文件 一、创建scrapy项目 在cmd运行里输入（随便找个盘）
scrapy startproject dangdang
如上图创建成功，接下来在编译器中打开文件
这些文件都是自动生成的 来解释说明一下部分文件
二、代码实现——编辑爬虫 ——1. 接下来创建爬虫项目book.py(注意在spiders文件夹下创建)
在book.py里填写爬虫代码
import scrapy import bs4 from ..items import DangdangItem # 需要引用DangdangItem，它在items里面。因为是items在book.py的上一级目录，..items这是一个固定用法。 class DangdangSpider(scrapy.Spider): #定义一个爬虫类DoubanSpider。 name = 'dangdang' allowed_domains = ['http://bang.dangdang.com'] start_urls = [] for x in range(1, 4): url = 'http://bang.dangdang.com/books/bestsellers/01.00.00.00.00.00-year-2019-0-1-1' + str(x) start_urls.append(url) def parse(self, response): #parse是默认处理response的方法。 soup = bs4.BeautifulSoup(response.text, 'html.parser') elements = soup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b5bef059929c25fcc4d59cb4ddf6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62d8713b2a8f4719bcd70aca7fd3993/" rel="bookmark">
			Logback日志无法按天分割问题小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 线上查看Mqtt消息服务项目时，发现服务器中系统的日志不能按天生成日志文件，全部的日志信息都打印到了启动运行项目的那一天中了且此日志文件越来越大，只有重启项目之后才会生成当天的日志文件。
回想当时开发的时候为什么没有发现？ 开发的时候，基本每天都会重启，且日志正常；部署的时候，打包的时候日志文件夹也会打包进入，当时启动后看了看正常，就所以然了。 分析原因 这个Mqtt消息服务项目使用SpringBoot + Logback框架，查看其配置文件，发现** 策略组合** 使用问题。
以下是当时项目中的有问题的配置文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration debug="false"&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name="LOG_HOME" value="./logs" /&gt; &lt;!--配置CONSOLE控制台文件输出项--&gt; &lt;appender name="CONSOLELOG" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS } [%thread] %-5level %logger{50} - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--配置INFO文件输出项--&gt; &lt;appender name="DAYINFOLOG" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!--过滤error日志--&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--配置滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info/%d{yyyy-MM-dd}-info.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62d8713b2a8f4719bcd70aca7fd3993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15b601d5b1dc866e35888f7e25cbd12/" rel="bookmark">
			最全解决方案：提示Flutter plugin not installed，实际已安装插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter提示AndroidStudio4.1没有安装flutter插件，实际已经安装 错误体现错误原因解决方案 错误体现 具体表现为，android studio 4.1已经安装了flutter和dart插件，但是flutter doctor依然报错。
错误原因 经过一番查询，android studio 4.1升级过程中，改变了plugin folder的路径：
From : ~/Library/Application\ Support/AndroidStudio4.1
To: ~/Library/Application\ Support/Google/AndroidStudio4.1/plugins
具体各平台参见google链接: 点我（请确定能打开google）
导致flutter doctor 1.22版本不能检测到插件。目前flutter已经修复此问题在1.23版本（dev 分支）。
解决方案 如果是macos或者linux系统，添加以下软连接即可：
ln -s ~/Library/Application\ Support/Google/AndroidStudio4.1/plugins ~/Library/Application\ Support/AndroidStudio4.1 如果是windows系统，可以通过更新flutter版本来解决，具体命令如下：
flutter channel dev flutter upgrade upgrade中可能会遇到running pub upgrade一直运行，无法进入下一步。
根据官网的提示： 官方中文网，需要配置国内镜像，具体如下：
1、计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量，在环境变量下添加下面两个：
PUB_HOSTED_URL https://pub.flutter-io.cn
FLUTTER_STORAGE_BASE_URL https://storage.flutter-io.cn
2、重启电脑
3、将flutter SDK-&gt;bin目录-&gt;cache
4、打开命令行，重新输入 flutter doctor，会自动升级
升级成功后，运行flutter doctor ，大功告成。
或者回退android studio到4.0版本也可以解决，回退前请删除所有缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126ef660a5c0a959e9de43ef87f43ff1/" rel="bookmark">
			js已知文件路径得到file对象_Node之文件流与文件路径操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流的基本概念 用途 | 使用异步方式 | 使用同步方式1 ---|--- |--- 将文件完整写入缓存区 | readFile | readFileSync 将文件部分读入缓存区 | read | readSync 将数据完整写入文件 | writeFile | writeFileSync 将缓存区中的部分内容写入文件 | write | writeSync
在一个应用程序中，流是一组有序的、有起点和终点的字节数据的传输手段。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。
Node.js中的各种用于读取数据的对象 各种用于读取数据的对象将会触发的事件 各种用于读取数据的对象所拥有的方法 Node.js中的各种用于写入数据的对象 各种用于写入数据的对象将会触发的事件 各种用于写入数据的对象所拥有的方法 使用ReadStream对象读取文件 在fs模块中，可以使用createReadStream方法创建一个将文件内容读取为流数据的ReadStream对象
fs.createReadStream(path,[options]) path：用于指定需要被读取的文件的完整路径及文件名。options： flags：用于指定对该文件采取什么操作，默认值为'r'，可指定属性值与readFile方法中所使用的options参数对象中所使用的flags属性的可指定属性值相同。encoding：用于指定使用什么编码格式来读取该文件，可指定属性值为“utf8”、“ascii”与“base64”。默认值为null。autoClose：用于指定是否关闭在读取文件时操作系统内部使用的文件描述符。如果属性值设定为false，则文件不会自动关闭，即使在读取文件过程中产生了错误，开发者也必须通过使用close方法或closeSync方法来手动关闭文件。如果属性值设定为true，当文件读取完毕或读取文件过程中产生错误时文件将自动关闭。autoClose属性的默认属性值为true。start：使用整数值来指定文件的开始读取位置（单位为字节数）。end：使用整数值来指定文件的结束读取位置（单位为字节数）。 示例：
var fs = require('fs'); var file = fs.createReadStream('./message.txt',{start:3,end:12}); file.on('open',function(fd) { console.log('开始读取文件。'); }); file.on('data', function(data) { console.log('读取到数据：'); console.log(data); }); file.on('end', function(){ console.log('文件已全部读取完毕。'); }); file.on('close', function(){ console.log('文件被关闭。'); }); file.on('error', function(err) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/126ef660a5c0a959e9de43ef87f43ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b496196f9e05ff1eb1f434cb77c656/" rel="bookmark">
			【国际化】vue element 国际化 切换语言 中英文  i18n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装i18n npm i -S vue-i18n 2、创建lang文件夹 src下创建lang文件夹，创建三个文件，分别是 index.js en.js zh.js;如下：
2-1、index.js import Vue from 'vue' import VueI18n from 'vue-i18n' import locale from 'element-ui/lib/locale'; import enLocale from './en' import zhLocale from './zh' import elementEnLocale from 'element-ui/lib/locale/lang/en' import elementZHLocale from 'element-ui/lib/locale/lang/zh-CN' Vue.use(VueI18n) const i18n = new VueI18n({ locale: localStorage.lang || 'zh', //默认语言 messages: { en: { ...enLocale, ...elementEnLocale }, zh: { ...zhLocale, ...elementZHLocale } } }) // 国际化 locale.i18n((key, value) =&gt; i18n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b496196f9e05ff1eb1f434cb77c656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc12d090a43bd289970effdc377fd6d0/" rel="bookmark">
			Linux Graphics 周刊（第 8 期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：
dma-buf: Heaps: 代码重构及性能优化drm/uapi: 为 drm_mode_get_connector 添加详细说明drm/ttm: 一些小的修改AOSP/RenderEngine: 引入非线性 display color transformAOSP/SurfaceFlinger: 为 CaptureScreen buffer 添加 GRALLOC_USAGE_HW_COMPOSER usageMesa 20.3.0 发布Khronos 发布 Vulkan 光线追踪（Ray Tracing）最终版Khronos: Vulkan 光线追踪最佳实践之混合渲染Collabora: 在 Wayland 中添加 Color Management 和 HDR 支持Dave Airlie：为什么和 Windows 共享 Linux Graphics 驱动代码并不是件好事 DRM 1. dma-buf: Heaps: 代码重构及性能优化 在经历了7轮 patch review 之后，John Stultz (dma-heap maintainer, Linaro) 的 dma-buf heap 重构 patch 终于可以合入主线了。此次 patch 对 dma-buf heap 做了较大改动，主要是删除了 heap-helpers.c 文件，将其原来的内容合并到 cma-heap.c 和 system-heap.c 中。并对 system heap 做了性能上的优化，例如对于 device 没有 touch 过的 buffer，CPU 访问该 buffer 就无需再做 cache 同步。以及优先采用大页内存分配来提高效率。值得一提的是，在前5轮的 patch 中曾还包含添加 system-uncached heap（还记得周刊第1期中曾报道的 system-uncached heap 吗？），用来在 system heap 上分配不带 cache 的 memory，这种 memory 对于需要频繁在 CPU 和 device 之间来回切换的场景能有明显的性能改善（因为不用频繁刷 cache 了）。但 DRM Maintainer Daniel Vetter 对此 patch 持有反对意见，他需要 John 给出相关数据来证明 system-uncached heap 在性能上确实有所收益，否则这样的 heap 在他看来没有多大意义（而事实上 John 在邮件中也很明确告诉 Daniel，在 userspace 这一侧，Android 的 Hikey960 gralloc 以及 codec2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc12d090a43bd289970effdc377fd6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4cd3887de40cbeb4e6e152c4dc1367/" rel="bookmark">
			自己配置微擎/微赞的的nginx负载均衡&#43;redis &#43;mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单机nginx 不能满足业务,线上跑着一台4H8G10M的服务器 手头还有一台这个配置 于是做了个nginx的负载均衡 ,由于微擎官方收费 就自己做
这是第一个 代理域名的配置
, nginx 的负载的配置~ 这是负载到另外一台服务器的配置 具体操作是 现在A服务器上把微擎的程序配置好 ,因为session的问题 可以设置缓存为redis 服务器, 然后copy 程序所有代码到新的服务器 此处我正在升级为 创建自己的gitlab+jenkins 提交代码到主分支-&gt;触发jenklins的部署任务-&gt;分发部署到各个服务器~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1f09c2411baa8a8d146afd47b5c93a/" rel="bookmark">
			Hadoop中MapReduce程序的本地IDEA测试（及org.apache.hadoop.io.nativeio问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、配置Hadoop环境
二、编写MapReduce程序
三、本地测试
1.run——&gt;Edit Configurations
2.Create a new configuration
3.修改以下内容
4.在Driver类中运行程序
5.运行成功
一、在IDEA中配置Hadoop环境 1.创建一个maven工程后，修改pom.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;mr-0529&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.在项目的src/main/resources目录下，新建一个文件，命名为“log4j.properties”
log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/spring.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 二、编写MapReduce程序 分别编写Mapper、Reducer和Driver类，其中Driver类是主类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f1f09c2411baa8a8d146afd47b5c93a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb88637a00c347260ba1bc388e19159/" rel="bookmark">
			记录mysql 使用role赋予user权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create role "zdkall" 创建角色租
grant all privileges on *.* to 'zdkall'; 赋予角色租权限
create user "zdklngchen1"@"%" identified by "zdklngchen1"; 创建用户
grant zdkall to zdklngchen1; 把用户加入组
set default role all to zdklngchen1; 给组内用户设置组的权限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ed7cf25c1265eb795c32c9fad37b8c/" rel="bookmark">
			如何查看自己在CSDN积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里直接给出地址：查看CSDN积分
会自动跳转到自己的积分信息页面
参考：
https://blog.csdn.net/wu387894541/article/details/106994289/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378bec42b5f485218a1de934a3e35926/" rel="bookmark">
			用python输出0到100所有能被3整除的数字_python:  输出 1~100 之间不能被 7 整除的数，每行输出 10 个数字，要求应用字符串格式化方法美化输出格式。...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#输出 1~100 之间不能被 7 整除的数
j = 0 #
for i in range(1,101): # 遍历1-100取值，定义为变量 i
if i%7 != 0: # 找出不能被 7 整除的数
print("{:3d}".format(i),end=‘ ‘) # Format格式化输出
j += 1 # 对输出的 不能被 7 整除的数 进行计数
if j%10 == 0: # 控制每行输出数字保持10个
print(‘\n‘) # 每行输出数字到第11个，进行换行操作
输出结果：
1 2 3 4 5 6 8 9 10 11
12 13 15 16 17 18 19 20 22 23
24 25 26 27 29 30 31 32 33 34
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378bec42b5f485218a1de934a3e35926/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/353/">«</a>
	<span class="pagination__item pagination__item--current">354/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/355/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>