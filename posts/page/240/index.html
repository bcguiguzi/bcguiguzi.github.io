<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c85cd974b81c466a8b09c04f6b7b82/" rel="bookmark">
			Fritzing软件绘制Arduino面包板接线图传感器模块库文件185
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、硬件材料 1*Arduino MEGA 2560 开发板
1*20uf电容
1*GP2Y1010AU0F灰尘传感器
1*DHT11 温湿度传感器
2*MOS管模块
1*USB喷雾模块
1*LCD12864
1*ESP8266-01s
1*12V 风扇
1* 空气进化器
1*12V转5V降压模块
二、硬件接线图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a303392cbddb666084f2dfdbb7be8c9/" rel="bookmark">
			HTML基础之form表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：表单属性
1 name 属性
2 action属性
3 method属性
4 target属性
5 enctype属性
二：表单对象
1 input标签
2 多行文本textarea
3 下拉列表select
4 表单控件（元素）button
5 表单控件（元素）label标签
前言：
这里的表单指的是文本框、按钮、下拉列表等的统称。
一：表单属性 表单一共有五个重要属性：name 、 action、 method 和 target属性
1 name 属性 一个页面上的表单可能不止一个，为了区分这些表单，就需要name 属性给表单命名，通常与id属性值相同。需要注意的是表单名称中不能包含特殊字符和空格。
2 action属性 用于指定表单数据提交到那个地址进行处理。
3 method属性 作用是告诉浏览器，指定将表单中的数据使用哪一种HTTP提交方法，取值为get 或者 post。
其中：get 是默认值，表单中的数据被传送到action 属性指定的URL，然后这个新的URL 被传送到处理程序上。
post：表单数据被包含在表单主体中，然后被传送到处理程序上。
两者区别：
get：该请求会将请求参数的名和值转换成字符串，然后拼接到URL 之后，因此在地址栏等地方可以看到请求的参数；但是安全性差，并且安全性差，传输的数量比较小，在URL中的最大长度是2048个字符。
post：该请求方式通过HTTP的post 机制，将所有的请求参数的名和值放在HTML的header 中传输；并且安全性号，传输的数量也大。
4 target属性 该属性与a标签的target 属性一样，都是从来指定目标窗口的打开方式。
取值：
_self: 默认值，表示在当前的窗口打开页面。
_blank:在新的窗口打开页面。
_top: 表示页面载入到包含该链接的窗口，取值在当前的窗口中的所有页面。
_parent: 在父级窗口打开页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a303392cbddb666084f2dfdbb7be8c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b863222ba67edbff67f4866def2f4e51/" rel="bookmark">
			jQuery项目：京东商品详情页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 需求分析代码分析1. 鼠标移入显示,移出隐藏2. 鼠标移动切换二级导航菜单的切换显示和隐藏3. 输入搜索关键字, 列表显示匹配的结果4. 点击显示或者隐藏更多的分享图标5. 鼠标移入移出切换地址的显示隐藏6. 点击切换地址tab7. 鼠标移入移出切换显示迷你购物车8. 点击切换产品选项 (商品详情等显示出来)9. 点击向右/左, 移动当前展示商品的小图片10. 当鼠标悬停在某个小图上,在上方显示对应的中图11. 当鼠标在中图上移动时, 显示对应大图的附近部分区域 完整代码 需求分析 鼠标移入显示,移出隐藏
目标: 手机京东, 客户服务, 网站导航, 我的京东, 去购物车结算, 全部商品鼠标移动切换二级导航菜单的切换显示和隐藏输入搜索关键字, 列表显示匹配的结果点击显示或者隐藏更多的分享图标鼠标移入移出切换地址的显示隐藏点击切换地址tab鼠标移入移出切换显示迷你购物车点击切换产品选项 (商品详情等显示出来)点击向右/左, 移动当前展示商品的小图片当鼠标悬停在某个小图上,在上方显示对应的中图当鼠标在中图上移动时, 显示对应大图的附近部分区域 代码分析 1. 鼠标移入显示,移出隐藏 目标: 手机京东, 客户服务, 网站导航, 我的京东, 去购物车结算, 全部商品
function showhide() { $('[name=show_hide]').hover(function() { //	找到隐藏的id让他显示 var id = this.id + '_items' $('#' + id).show() }, function() { //	找到显示的id让他隐藏 var id = this.id + '_items' $('#' + id).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b863222ba67edbff67f4866def2f4e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db70cde7d4a67c32880ccc0605aa241/" rel="bookmark">
			利用命令简单检查网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：查看本地网络设置是否正确
ipconfig命令：ipconfig命令，可显示当前的TCP/IP配置的设置值，这些信息一般用于检验人工配置的TCP/IP是否正确。如果计算机和所在的局域网使用了动态主机配置协议（DHCP），这个程序所显示的信息将会更加实用。当ipconfig不带任何参数选项时，它为每个已经配置了接口显示IP地址，子网掩码和默认网关。
ipconfig/?就可以显示所有有关的命令，输入ipconfig/all就可以显示更多详细的信息。
ipconfig / all：当使用all参数时，ipconfig能为DNS和WINS服务器显示它已经配置所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址（MAC地址）。
2：检查本地的TCP/IP协议有没有设置好，ping 127.0.0.1（ping和127.0.0.1之间存在空格）
ping命令一般用于检测网络是否通畅以及网络速度的检测。在默认情况下发出的数据：
根据域名得到服务器ip
TTL的作用是限制IP数据包在计算机网络中的存在的时间。TTL的最大值是255，TTL的一个默认值是64。
3：检查本机的IP地址是否正确
config获取本机的IP地址
利用ping命令ping查到的IP地址
4：检查本地主机与本地网络连接是否正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7780e30a6fe1096c246ef51c1f9dbe4d/" rel="bookmark">
			PyTorch实现苹果M1芯片GPU加速：训练速度提升7倍，性能最高提升21倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5月18日，PyTorch官网宣布，通过与Apple的Metal工程团队合作，目前已可以支持在搭载M1芯片的Mac上使用GPU加速PyTorch训练。而在此之前，在Mac上进行PyTorch训练仅能利用CPU。
但随着PyTorch v1.12版本的发布，开发和研究人员可以利用Apple Silicon CPU的优势，大大加快模型训练速度。这解锁了在Mac上执行机器学习工作流程的能力，例如在本地进行原型设计和微调。
据PyTorch官网介绍，其使用Apple的Metal Performance Shaders（MPS）作为PyTorch的后端来加速GPU训练。MPS后端扩展了PyTorch框架，提供了在Mac上设置和运行操作的脚本和功能。MPS通过针对每个Metal GPU系列的独特特性进行微调的内核来优化计算性能。新设备将机器学习计算图和原语映射到MPS提供的MPS Graph框架和优化内核上。
此外，因为每台搭载Apple Silicon的Mac都有统一的内存架构，为GPU提供了直接访问完整内存存储的能力。这让Mac成为机器学习的绝佳平台，也使用户能够在本地训练更大的网络或批大小。同时，这也降低了与基于云的开发相关的成本或对额外本地GPU的需求。此外，统一内存架构还减少了数据检索延迟，提高了端到端的性能。
在下图中，显示了与CPU基线相比，加速GPU训练和评估所带来的性能提升：
图源： PyTorch官网
可以看出，使用GPU可将模型训练速度提升约7倍，评估（Evaluation）速度最高可提升约21倍。
以上是Apple于2022年4月使用配备Apple M1 Ultra、20核CPU、64核GPU、128GB内存和2TB SSD的Mac Studio系统进行的测试结果。系统为macOS Monterey 12.3、预发布的PyTorch 1.12，测试模型为ResNet50（batch size=128）、HuggingFace BERT（batch size=64）和VGG16（batch size=64）。性能测试是使用特定的计算机系统进行的，反映了Mac Studio的大致性能。
对于想要体验的用户，以下为具体要求：只需在搭载M1芯片的Mac上安装原生版本（arm64）的Python，并将系统升级至macOS 12.3或更高版本，然后去官网下载最新的PyTorch预览版就可以。
参考链接：
1.Introducing Accelerated PyTorch Training on Mac | PyTorch
2.Start Locally | PyTorch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed598053b6bb789f88364a85aa5060a/" rel="bookmark">
			Eggjs解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1:先安装egg-cors插件
npm install egg-cors -s 或者 yarn add egg-cors 2:在config/plugin.ts开启egg-cors插件
const plugin: EggPlugin = { // 其他的 cors: { enable: true, package: 'egg-cors' } // 其他的 }; 3:在config/config.default.ts中进行配置
export default (appInfo: EggAppInfo) =&gt; { // 其他的 config.cors = { origin: '*',//域名+端口 或者 *(全匹配) allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH' }; // 其他的 }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b821872760d6035997c51ca297a9d3b/" rel="bookmark">
			【C&#43;&#43;二叉树节点间的最大距离问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要点： 学习树形dp套路：分析可能性–&gt;左子树、右子树、整棵树的角度考虑
用递归先要左树信息和右数信息，然后再根据这些信息更新当前结点的信息
TIPS： 1.一定要注意递归时辅助变量的更新问题，此处qu不带引用会使初始化二叉树出错。
2.当前最大距离等于左树最大距离、右树最大距离、左右树高度和加一
代码： 参靠左神代码编写
#include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; struct Node //二叉树结点 { int value; Node *left; Node *right; Node() : value(0), left(nullptr), right(nullptr) {} Node(int a) : value(a), left(nullptr), right(nullptr) {} Node(int a, Node *left, Node *right) : value(a), left(left), right(right) {} }; struct ReturnType //自定义返回类型(返回子树最大距离和树高) { int maxlen; //最大距离 int height; //树高 ReturnType() : maxlen(0), height(0) {} ReturnType(int a, int b) : maxlen(a), height(b) {} }; ReturnType process(Node *head) { if (head == nullptr) { return ReturnType(0, 0); } ReturnType left_ret = process(head-&gt;left); //向左数要信息 ReturnType right_ret = process(head-&gt;right); //向右数要信息 int pre_height = max(left_ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b821872760d6035997c51ca297a9d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42f79bc209c21a30c9e441e3c8f1161/" rel="bookmark">
			stm32硬件SPI驱动3线SPI-LCD的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本控制原理
三线SPI LCD， 顾名思义，最少只需要3个IO控制LCD显示，如果采用硬件控制上电时序和背光，最少只需要接SCK，CS，MOSI三个引脚即可控制LCD，并且不管接不接其他引脚，控制刷屏的只需要这三个引脚；
CS为片选引脚，CS拉低代表数据传输开始；CS拉高，代表数据传输结束；
SCK为SPI时钟线，一般LCD上标识SCL；
MOSI是master数据输出，即单片机发送数据到LCD，一般LCD上标识SDA；
3线SPI-LCD与4线的唯一区别是少了一个DC引脚，DC拉低代表传输的是指令；DC拉高代表传输的是数据，3线SPI驱动需要使用MOSI模拟DC的时序；
那么使用STM32单片机驱动，很容易使用GPIO模拟SPI时序实现3线SPI-LCD的驱动，但是由于GPIO的翻转速度，就算使用寄存器操作，屏幕刷新速度也非常慢；
2.如何使用硬件SPI驱动3线SPI-LCD
本文提供两种方法使用stm32单片机实现：
（1）单字节转换后SPI发送；
所谓单字节转换后发送，就是每次只发送一个有效字节，将一个8位的数据，转换成16位，再位或0x8000，然后通过SPI发送出去，具体可以拆分成两个8bit数据发送；
具体实现如下：
unsigned char spi_send_data_8bit(unsigned char Txdata) { while((SPI2-&gt;SR &amp; SPI_I2S_FLAG_TXNE) == (uint16_t)RESET); SPI2-&gt;DR=Txdata; while((SPI2-&gt;SR &amp; SPI_I2S_FLAG_RXNE) == (uint16_t)RESET); return (unsigned char)(SPI2-&gt;DR)； } void LCD_Send_8bit(unsigned char data) { cs_low; spi_send_data_8bit((data&gt;&gt;1)|0x80); spi_send_data_8bit(data&lt;&lt;7); cs_high;	} 上述单字节发送在stm32F4平台，50MHz SPI下，320x240 分辨率显示能刷4fps；
320x240x2x4x8 大约有5Mbps，如果采用更小的分辨率刷10帧以上没有问题。
（2）多字节转换后发送
使用单字节发送存在一个问题，SPI 每次只能按字节发送，就算SPI速度再快，单字节发送出去也会影响性能，其次每次发送一个有效字节都存在cs的拉高拉低，极大的影响了效率。既然单字节转换后可以发送，多字节转换后当然也能发送。其原理就是每一个DC后面跟8个有效bit，使用MOSI模拟时序做数据转换；
先看看怎么一次发8个字节；
void LCD_Send_8byte(unsigned char *send_buf,unsigned char buflen) { if(send_buf==NULL||buflen!=8) { printf("param error"); return; } unsigned char *pbuf=send_buf; nsigned char lcd_buf[9]={0}; lcd_buf[0]=0x80|(*pbuf&gt;&gt;1); lcd_buf[1]=0x40|(*pbuf&lt;&lt;7)|(*(pbuf+1)&gt;&gt;2); lcd_buf[2]=0x20|(*(pbuf+1)&lt;&lt;6)|(*(pbuf+2)&gt;&gt;3); lcd_buf[3]=0x10|(*(pbuf+2)&lt;&lt;5)|(*(pbuf+3)&gt;&gt;4); lcd_buf[4]=0x08|(*(pbuf+3)&lt;&lt;4)|(*(pbuf+4)&gt;&gt;5); lcd_buf[5]=0x04|(*(pbuf+4)&lt;&lt;3)|(*(pbuf+5)&gt;&gt;6); lcd_buf[6]=0x02|(*(pbuf+5)&lt;&lt;2)|(*(pbuf+6)&gt;&gt;7); lcd_buf[7]=0x01|(*(pbuf+6)&lt;&lt;1); lcd_buf[8]=*(pbuf+7); int i=0; cs_low; for(i=0;i&lt;9;i++) { spi_send_data_8bit(lcd_buf[i]); } cs_high; } //使用CCM快速内存分配数据作为LCD的缓冲，如果内存足够这个缓冲也可以大一点 static int nwidth=image_width8/9*16*2；//分配一个16行的缓冲 unsigned char* lcd_buf=mymalloc(SRAM_CCM，nwidth); /******************************* 功能：lcd显示n行数据，发送RGB565 入参：图像数据指针，发送长度，LCD缓冲数据指针，长度 出参：无 *********************************/ void LCD_Send_Nwith(unsigned char *send_buf,unsigned int send_length，unsigned char *lcd_buf,unsigned int nwidth) { if((send_buf ==NULL)||((send_length%8)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42f79bc209c21a30c9e441e3c8f1161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea77b1e6f8e1d158698326fa61f56064/" rel="bookmark">
			离散pi仿真搭建并产生嵌入式代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，连续和离散在pi搭建上，最大的区别就在于积分环节:一个直接用1/s，一个用k*Ts/(z-1)。
仿真图如下：
理论输出：
接着，用matlab产生离散pi嵌入式代码
1、搭好模型
2、pi中的变量可以分为两类，一类是Kp、Ki参数，系统运行参数不会变化；另一类是输入、输出，是随系统变化的量。根据这两个分类，在Simulink中添加数据，步骤如下（21a版本）。
输入输出量这里用x 、y表示，同时x、y前还有一个标识，将鼠标放在信号线位置右击，选择properties。
同理，输出y也是这么操作。接着继续操作。
选择mpt signal，mpt parameter。
设置好了就可以Ctrl +B，然后就会产生代码了。
代码会有很多，所以注意观察。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1055a1f0b08d79117265be0bc0d8d4/" rel="bookmark">
			向日葵远程控制亮度慢慢变暗且不能调节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开设备管理器，没有找到监视器。
接下来第一步
打开显示适配器，对两个驱动程序都右键扫描检测硬件驱动，第二步：
然后自动刷新，监视器选项自动出来，然后问题莫名其妙就消失，屏幕亮度问题得到解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1879bb7e25cea71dde31ad72c0ff4680/" rel="bookmark">
			Stata 画图配色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f55ab79389c9668604663b740ea13d/" rel="bookmark">
			巴特沃斯(Butterworth)滤波器（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先考虑一个归一化（截止频率为1rad/s）的低通滤波器,其幅频特性表达式如下：
其幅频特性曲线如下图：
当n–&gt; ∞ \infty ∞ 时，得到一个理想的低通滤波器：
当w&gt;1(截止频率)时，增益为0；
当w&lt;1(截止频率)时，增益为1；
当w=1(截止频率)时，增益为0.707（衰减到-3dB）；
其次，我们根据上面的幅频特性表达式求滤波器传递函数
根据以下三个公式：
s = jw ∣ H ( s ) ∣ 2 = H ( s ) H ( s ) ‾ \left | H_{(s)}\right |^{2}=H_{(s)}\overline{ H_{(s)}} ∣∣​H(s)​∣∣​2=H(s)​H(s)​​ H ( − s ) = H ( s ) ‾ H_{(-s)} = \overline{ H_{(s)}} H(−s)​=H(s)​​ 推导下：
因此极点为：
下面是n=1到n=4阶的极点位置：
例如，四阶Butterworth低通滤波器的极点所在角度为：
这样 1到10阶的Butterworth多项式因子表格如下：
以上我们考虑的是截止频率为1的情况，其它截止频率可将传递函数中的s替换为：s/wc ,wc为截止频率，单位rad/s。例如二阶截止频率为100rad/s的传递函数为：
转载：https://www.cnblogs.com/xpvincent/p/5557659.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db865bc46d03c6f772b9dd1f65ffdbe/" rel="bookmark">
			spring redis和缓存的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring redis和缓存的应用 1、在springboot项目中引入redis的包，即在pom.xml文件中导入一下依赖，刷新maven可看见右侧依赖
2、使用缓存前在项目启动类（Demo1Application）中开启缓存
3、启动redis
4、配置application.properties文件以连接redis
5、导入redis配置类
/** * Redis配置类 * @author xiaoshu */ @Configuration public class RedisConfig { // ${cache} 获取配置文件的配置信息 #{}是spring表达式，获取Bean对象的属性 @Value("${spring.cache.ttl}") //${spring.cache.ttl}:绝对路径 private int ttlParams; /** * @param redisConnectionFactory * @功能描述 redis作为缓存时配置缓存管理器CacheManager，主要配置序列化方式、自定义 * &lt;p&gt; * 注意：配置缓存管理器CacheManager有两种方式： * 方式1：通过RedisCacheConfiguration.defaultCacheConfig()获取到默认的RedisCacheConfiguration对象， * 修改RedisCacheConfiguration对象的序列化方式等参数【这里就采用的这种方式】 * 方式2：通过继承CachingConfigurerSupport类自定义缓存管理器，覆写各方法，参考： * https://blog.csdn.net/echizao1839/article/details/102660649 * &lt;p&gt; * 切记：在缓存配置类中配置以后，yaml配置文件中关于缓存的redis配置就不会生效，如果需要相关配置需要通过@value去读取 */ @Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig(); redisCacheConfiguration = redisCacheConfiguration // 设置key采用String的序列化方式 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer.UTF_8)) //设置value序列化方式采用jackson方式序列化 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db865bc46d03c6f772b9dd1f65ffdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134ef62252aeef5beead30d9c5150008/" rel="bookmark">
			实验1:同一VLAN下不同交换机之间的数据转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置PC
配置IP地址、子网掩码
配置SW0
Switch&gt; en //进入全局模式 Switch# configure terminal //进入特权模式 Switch(config)# vlan 2 //声明vlan，如果要给一个接口划分vlan，先要声明 Switch(config-vlan)# ex Switch(config)# vlan 3 Switch(config-vlan)# ex Switch(config)# interface F0/1 Switch(config-if)# switchport mode access //命令作用为把这个接口划分为access口，这条命令在思科模拟器可不打，默认接口都为access口 Switch(config-if)# switchport access vlan 2 //为这个access接口添加vlan 2 Switch(config)# interface F0/2 Switch(config-if)# switchport mode access Switch(config-if)# switchport access vlan 3 Switch(config)# interface F0/3 Switch(config-if)# switchport mode trunk //命令为把这个接口划分为trunk口，允许所有vlan通过，二层交换机不需要封装协议，封装协议后面会介绍 配置SW1
Switch&gt; en //进入全局模式 Switch# configure terminal //进入特权模式 Switch(config)# vlan 2 //声明vlan，如果要给一个接口划分vlan，先要声明 Switch(config-vlan)# ex Switch(config)# vlan 3 Switch(config-vlan)# ex Switch(config)# interface F0/2 Switch(config-if)# switchport mode access //命令作用为把这个接口划分为access口，这条命令在思科模拟器可不打，默认接口都为access口 Switch(config-if)# switchport access vlan 2 //为这个access接口添加vlan 2 Switch(config)# interface F0/3 Switch(config-if)# switchport mode access Switch(config-if)# switchport access vlan 3 Switch(config)# interface F0/1 Switch(config-if)# switchport mode trunk 进行实验验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134ef62252aeef5beead30d9c5150008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f345580e07c60ff7e3afc935d148853/" rel="bookmark">
			golang MongoDB扩展库安装解决module declares its path as xxx错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误场景：安装mongodb驱动库出错 错误细节： 根据其他博主的安装方法：
go get github.com/mongodb/mongo-go-driver
，执行以后会报错
go: github.com/mongodb/mongo-go-driver@v1.9.1: parsing go.mod: module declares its path as: go.mongodb.org/mongo-driver but was required as: github.com/mongodb/mongo-go-driver 解决办法：根据最新Readme可知，使用 go get go.mongodb.org/mongo-driver/mongo 安装即可，参考链接: Github
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edc8c75bdac119d87d0ba217705e914/" rel="bookmark">
			新唐NUC980读取U盘配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		驱动配置
NUC980读取U盘需要开启相关配置:
$cd NUC970_Buildroot-master/ $make linux-menuconfig 读取U盘要打开USB Host端支持，NUC980 USB Host包含EHCI(USB2.0)和OHCI(USB1.1)两个USB Host控制器，必须全部打开。
选择Device Drivers &gt; USB support，图中标注处为必须选择项：
需要注意的是青色和黄色框中选项要根据硬件设计选择：
青色框中打开下拉选项：
此处根据USB硬件设计上是否有电源控制来选择，我的板子USB由5V直接供电，也无电流保护指示脚，故选择第四项，此处若选择有电源控制，即前两个选项，则还需要选择在休眠状态下，USB是否断电：
简单的说就是选择此项后，系统休眠时USB会关闭供电，唤醒时需重新连接设备和枚举，若连接的设备使用该USB进行供电，此选项不可选。
官方文档中对此解释如下：
黄色框中要注意的是USBH Lite的选择（我没有在官方文档中找到该选项相关内容，着实走了弯路！），0~5所用引脚均不相同，此处根据硬件设计，查看电路图上USB通信引脚来选择：
要支持U盘还需选择该页面下对大容量存储的支持：
但此选项需先开启SCSI设备支持才会出现，所以返回上一层Device Drivers界面，选择SCSI device support，下拉选项如下选择：
文件系统
使用U盘还需要支持对应的文件系统，我使用的U盘为FAT文件系统，选择File systems &gt; DOS/FAT/NT Filesystems，选项设置如下：
设置完成后make，烧录uimage。
测试
开启时可能会出现如下信息，并不影响，可忽视：
测试挂载点选择/mnt/usb，插上U盘后会出现相关信息：
此处可以看到U盘分区名为sda1，若没有U盘信息，可在USB support下选择打开此选项：
或使用lsusb、fdisk -l，命令进行查看，若无则U盘未连接上，检查设置是否正确，U盘，硬件设计是否可行。
保存，执行挂载命令，此时即可在usb中查看U盘文件：
不使用U盘则需执行命令放下挂载：
注意：执行此命令时需从usb文件夹内退出，否则会报错。
#umount /mnt/usb 参考资料：
官方文档—NUC980 Linux 4.4 BSP User Manual
下载地址：https://download.csdn.net/download/m0_46222499/85167997
自动挂载
让U盘进行自动挂载需要mdev功能，该功能描述及使用方法在mdev.txt(output/build/busybox-1.25.1/docs/mdev.txt)文件中描述的比较详细:
也有大致翻译的中文版本：
linux /etc/mdev.conf配置详解
主要进行修改的mdev.conf配置文件(output/target/etc)，可参考如下进行修改：
怎么使用mdev实现自动挂载
首先在mdev.conf底部增加：
#FAT device such as U-disk sd[a-z][0-9] root:root 660 */etc/automount $MDEV $ACTION automount文件中如下修改：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edc8c75bdac119d87d0ba217705e914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149a7dfb1efe11fcc9f1901b648d1115/" rel="bookmark">
			jvisualvm监控远程jvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：JMX 1、服务端添加配置
在tomcat/bin/catalina.sh文件中添加如下配置：
export JAVA_OPTS="-Xms256m -Xmx512m -Xss256m -XX:PermSize=512m -XX:MaxPermSize=1024m -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=192.168.16.239 -Dcom.sun.management.jmxremote.port=9015 -Dcom.sun.management.jmxremote.rmi.port=9015 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false" 详解：
要使用jmx远程监控功能，在远程java application启动时，必须通过jvm选项配置提供远程服务的端口：
-Dcom.sun.management.jmxremote.port=9015 一般同时指定为本地jmx client提供服务的端口与远程服务端口相同：
-Dcom.sun.management.jmxremote.rmi.port=9015 jmx远程服务默认是开启ssl和认证功能功能的，也可以通过jvm选项把这两个功能关闭：
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false 还可以设置虚拟机参数：
-Xms256m -Xmx512m -Xss256m -XX:PermSize=512m -XX:MaxPermSize=1024m jmx默认是通过localhost的ip地址提供RMI服务的，如果要明确指定RMI服务地址或主机名（比如主机有多个接口，想使用非hostname关联的接口），可以通过以下选项显式指定：
-Djava.rmi.server.hostname=服务器IP
这样开启jmx远程监控功能的最小配置具体如下：
-Xms256m -Xmx512m -Xss256m -XX:PermSize=512m -XX:MaxPermSize=1024m -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=服务器IP -Dcom.sun.management.jmxremote.port=9015 -Dcom.sun.management.jmxremote.rmi.port=9015 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false 2. 重启tomcat
java application启动后，远程监控工具就可以通过&lt;远程主机名或ip地址&gt;:8777，或jmx服务地址service:jmx:rmi:///jndi/rmi://&lt;远程主机名或ip地址&gt;:8777/jmxrmi连接远程java application进行监控了
3. 客户端操作
3.1 启动jvisualvm.exe
找到jdk安装目录进入bin目录下, 双击 jvisualvm.exe
3.2 配置JMX
方式二：JSTATD 1、创建 XXX.policy文件
jdk 1.8发布包中包括一个jstatd程序，使用jstatd需要指定一个policy文件，文件的后缀为 .policy,
比如：jstatd-all.policy的文件，
内容为：
grant codebase "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149a7dfb1efe11fcc9f1901b648d1115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39a9b7bcc3273d74ef4be9ec5b50be5/" rel="bookmark">
			使用LambdaQuery()有感-通过函数式接口获取字段名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 在平时使用mybatis-plus的时候，通常会使用下面两种方式
lambdaQuery()方式： List&lt;Person&gt; persons = lambdaQuery() .eq(Person::getName,"zhangsan") .eq(Person::getAge,11) .list(); 普通QueryWrapper的方式 List&lt;Person&gt; persons = baseMapper.selectList(new QueryWrapper&lt;Person&gt;() .eq("name","zhangsan") .eq("age",11)); 这两种方式对比我可能更喜欢使用lambdaQuery()那种方式，因为如果实体类里面的字段有更改的话，不需要单独取维护分布在各个地方的字符串，只需要字段本身就可以。那么就想到去定义一个工具类，让这种函数式接口方式取代很多直接定义字符串名称的场景。
2.工具类定义 定义一个实现Serializable的函数式接口（不实现Serializable的话，后面getDeclaredMethod("writeReplace")会获取不到）
import net.oschina.j2cache.util.Serializer; import java.io.Serializable; import java.util.function.Function; /** * 序列化的function函数式接口 * */ @FunctionalInterface public interface SerializedFunction&lt;T, R&gt; extends Function&lt;T, R&gt;, Serializable { } 定义LambdaUtil
import java.beans.Introspector; import java.lang.invoke.SerializedLambda; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Locale; /** * lambda工具类 * */ public class LambdaUtil { /** * 传入lambda表达式获取其字段名称 * &lt;pre&gt; * 例如传入Person::getName 返回：name * 传入Person::getAge 返回: age * &lt;/pre&gt; * * @param sFunction * @param &lt;T&gt; * @return */ public static &lt;T&gt; String getFiledName(SerializedFunction&lt;T, ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39a9b7bcc3273d74ef4be9ec5b50be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e878c5a2093526cfe8faef9d02d66ce7/" rel="bookmark">
			惯性导航原理(十)-INS 算法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 INS 算法INS测量在使用惯导系统做测量应用之前做动态测试来演练并考核系统性能典型的正式测试任务外业内业 INS 算法 一种典型的INS机械编排框图
对上述算法流程进行简单讲述：
1.加速度计所在流程，可看作是主干；其测得的是b系下的比力，不能直接将其积分，那样没有意义，因此需要投影；这时就需要姿态矩阵，而由姿态角可得姿态阵，因此就需要陀螺给提供这一数值，将量由b系转换到n系；
2.当将比力投影到n系之后，还需要扣除重力加速度，这样我们就会得到一个纯正的运动加速度；实际上，还存在哥氏加速度，与重力加速度统称为有害加速度，我们需要把有害加速度都补偿掉
3.陀螺测的是b系相对于i系(惯性坐标系)的角速度，且是投影到b系上的；
4.下图为求得n系相对于n系得角速度在n系下得投影得公式，可以理解一下
(1)等式右边第一项，只要知道当地纬度就可求得，也就是地球自转在当地的北、东、垂向的投影
(2)等式右边第二项，这一项为牵连角速度，上面章节介绍过
5.算法图中的详细介绍，后续章节我们会介绍
INS测量 在使用惯导系统做测量应用之前 认真阅读设备使用手册测试标定惯导系统, 估计出加速度计和陀螺仪的零偏和比例
因子误差的确定性部分，并加以补偿采集长时间的设备数据, 用来估计加速度计和陀螺的随机误
差特性(例如，白噪声、零偏的一阶Gauss-Markov过程参数)根据陀螺的噪声参数（ARW）估算所需初始对准的时长（考
虑现实可行性）, 以保证初始对准的航向角精度 做动态测试来演练并考核系统性能 验证导航算法实现的正确性, 精调算法参数, 预估辅助信息更
新所需要的频率来保障一定的测量精度.需要一个好的参考轨迹(参考真值，通常是GPS).测试轨迹通常是富含典型动态信息的“L”或“S”形轨迹. 典型的正式测试任务 外业 静态模式下5-15分钟初始对准INS初始化(初始化速度和位置)（初始动态以便组合导航算法收敛）也就是加加速，左拐右拐等机动定期进行零速修正(ZUPT) 或坐标修正(CUPT)（结束前动态改善反向平滑算法效果）也就是加加速，左拐右拐等机动结束前静止1-2分钟(可以与初始静止的数据进行对比分析) 内业 用惯导算法和Kalman 滤波进行数据处理（实时或事后）反向平滑处理（事后）结果显示、检查和输出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6fe8211d3ad25fc4f8d9131036a488/" rel="bookmark">
			分布式Session(Spring-session-data-redis)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pom中添加如下依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、在yml中配置redis 注：此处配置完全是spring-boot-starter-data-redis相关配置参数，跟spring-session-data-redis无关。后者依赖前者
#redis #spring.redis.host=localhost #spring.redis.port=6379 #spring.redis.sentinel.master = sentinel-name #spring.redis.sentinel.nodes = 192.168.1.2:6389,192.168.1.3:6390,192.168.1.4:6387 ##公共配置 #spring.redis.password = 123456 # ; 连接池最大连接数,默认8个，（使用负值表示没有限制） #spring.redis.pool.max-active = 21 # ; 连接池最大阻塞等待时间（使用负值表示没有限制） #spring.redis.pool.max-wait = -1 # ; 连接池中的最大空闲连接 #spring.redis.pool.max-idle = 8 # ; 连接池中的最小空闲连接 #spring.redis.pool.min-idle = 0 # ; 连接超时时间（毫秒） #spring.redis.timeout = 1000 spring: redis: password: 123456 pool: max-active: 21 max-idle: 8 max-wait: -1 min-idle: 0 sentinel: master: sentinel-name nodes: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6fe8211d3ad25fc4f8d9131036a488/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/239/">«</a>
	<span class="pagination__item pagination__item--current">240/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/241/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>