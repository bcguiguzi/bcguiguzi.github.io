<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21456b2585378e3ed626863c4127bf9/" rel="bookmark">
			注释代码快捷键:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注释代码快捷键:
1、//注释添加和取消
（1）添加：选中你要加注释的区域，用ctrl+shift+C 会加上//注释
（2）取消：选中你要加注释的区域，ctrl+shift+C去掉注释
2、/* */添加和取消
（1）添加：先把你要注释的东西选中，用shit+ctrl+/ 会加上/* */注释
（2）取消：选中你要加注释的区域，ctrl+shift+\去掉注释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2faf24907b5186e5594f1f82d39f6e/" rel="bookmark">
			在本地文件系统上测试MapReduce程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客已迁往http://coredumper.cn 在开发MapReduce程序的过程中，可以首先在本地文件系统上对程序进行测试，而不是一开始就在HDFS上，这样调试起来更加方便。
以《Hadoop权威指南》上的MaxTemperature程序为例，整个项目中包括如下3个源文件，依次为Mapper程序、Reducer程序和job启动程序：
MaxTemperatureMapper.java，MaxTemperatureReducer.java，MaxTemperature.java
MaxTemperatureMapper.java和MaxTemperatureReducer.java的代码可在MRUnit的安装和使用中找到。
MaxTemperature.java
import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; public class MaxTemperature { public static void main(String[] args) throws Exception { if(args.length != 2) { System.err.println("Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;"); System.exit(-1); } Job job = new Job(); job.setJarByClass(MaxTemperature.class); job.setJobName("Max temperature"); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.setMapperClass(MaxTemperatureMapper.class); job.setReducerClass(MaxTemperatureReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); System.exit(job.waitForCompletion(true) ? 0 : 1); } } 在Eclipse中执行测试程序的步骤如下： 选中文件MaxTemperatureDriver.java--&gt;右键Run As--&gt;Run Configurations--&gt;New launch configuration--&gt;选中Arguments，在Program arguments中填入本地文件系统中的输入输出路径，例如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2faf24907b5186e5594f1f82d39f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73cbaea169ba876e55ea1298d6ed00b/" rel="bookmark">
			C#开发之简单的日志打印类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的日志打印的帮助类，以后会继续补充更多的逻辑
public class LogHelper { private static readonly LogHelper Instance = new LogHelper(); public static LogHelper GetLogHelper() { return Instance; } #region 公共属性 public string StrStartupPath { get { return Environment.CurrentDirectory; } } public string FileName { get { return StrStartupPath + @"\Logs" + @"\SyncLog" + DateTime.Now.ToString("yyyyMMdd") + ".txt"; } } #endregion #region 写日志 public void CreateLog(string strMsg) { //1. 判断目录是否存在 var fileLocation = StrStartupPath + @"\Logs"; if (!Directory.Exists(fileLocation)) { Directory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73cbaea169ba876e55ea1298d6ed00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2dc1454d3e95619668b600c3c678db5/" rel="bookmark">
			经纬度换算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//km换算 var FINAL = 6378137.0 function calcDegree(d){ return d*Math.PI/180.0 ; } function calcDistance(f,t){ var flat = calcDegree(f[0]) ; var flng = calcDegree(f[1]) ; var tlat = calcDegree(t[0]) ; var tlng = calcDegree(t[1]) ; var result = Math.sin(flat)*Math.sin(tlat) ; result += Math.cos(flat)*Math.cos(tlat)*Math.cos(flng-tlng) ; return Math.acos(result)*FINAL ; } //保留小数点后一位 var km = calcDistance([31.303357,121.329748],[31.303357,121.329748]); 前面减后面的值。 km/1000 得出来的就是距离值 转载于:https://www.cnblogs.com/luckk/p/4228227.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f76c2b74e0051b04a9ed57f14bc20e/" rel="bookmark">
			windows 怎样查看计算机本地安装的证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		证书在计算机及网络中起着非常重要的作用，那如何查看本地计算机有没有安装某个证书呢。下面，介绍一种方法。
开始运行中输入certmgr.msc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5875c67eb56441b614bbcc5589b52072/" rel="bookmark">
			NSURLConnection方法内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 封装HTTPConnection的过程中，发现NSURLConnection的问题。NSURLConnection的实例化方法initWithRequest:delegate:startImmediately:，最后一个参数为NO表示实例化后网络请求不启动（默认是启动）。如果网络请求未启动就调用release或先调用cancel再release，都会有内存泄露，必须先start再cancel然后release才行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c339d0549fd43a13af3831fff7879bb/" rel="bookmark">
			读懂机器学习(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇文章中，我将对机器学习做个概要的介绍。本文的目的是能让即便完全不了解机器学习的人也能了解机器学习，并且上手相关的实践。这篇文档也算是EasyPR开发的番外篇，从这里开始，必须对机器学习了解才能进一步介绍EasyPR的内核。当然，本文也面对一般读者，不会对阅读有相关的前提要求。
在进入正题前，我想读者心中可能会有一个疑惑：机器学习有什么重要性，以至于要阅读完这篇非常长的文章呢？
我并不直接回答这个问题前。相反，我想请大家看两张图，下图是图一：
图1 机器学习界的执牛耳者与互联网界的大鳄的联姻
这幅图上上的三人是当今机器学习界的执牛耳者。中间的是Geoffrey Hinton, 加拿大多伦多大学的教授，如今被聘为“Google大脑”的负责人。右边的是Yann LeCun, 纽约大学教授，如今是Facebook人工智能实验室的主任。而左边的大家都很熟悉，Andrew Ng，中文名吴恩达，斯坦福大学副教授，如今也是“百度大脑”的负责人与百度首席科学家。这三位都是目前业界炙手可热的大牛，被互联网界大鳄求贤若渴的聘请，足见他们的重要性。而他们的研究方向，则全部都是机器学习的子类–深度学习。
下图是图二：
图2 语音助手产品
这幅图上描述的是什么？Windows Phone上的语音助手Cortana，名字来源于《光环》中士官长的助手。相比其他竞争对手，微软很迟才推出这个服务。Cortana背后的核心技术是什么，为什么它能够听懂人的语音？事实上，这个技术正是机器学习。机器学习是所有语音助手产品(包括Apple的siri与Google的Now)能够跟人交互的关键技术。
通过上面两图，我相信大家可以看出机器学习似乎是一个很重要的，有很多未知特性的技术。学习它似乎是一件有趣的任务。实际上，学习机器学习不仅可以帮助我们了解互联网界最新的趋势，同时也可以知道伴随我们的便利服务的实现技术。
机器学习是什么，为什么它能有这么大的魔力，这些问题正是本文要回答的。同时，本文叫做“从机器学习谈起”，因此会以漫谈的形式介绍跟机器学习相关的所有内容，包括学科(如数据挖掘、计算机视觉等)，算法(神经网络，svm)等等。本文的主要目录如下：
1.一个故事说明什么是机器学习 2.机器学习的定义 3.机器学习的范围 4.机器学习的方法 5.机器学习的应用–大数据 6.机器学习的子类–深度学习 7.机器学习的父类–人工智能 8.机器学习的思考–计算机的潜意识 9.总结 10.后记 1.一个故事说明什么是机器学习 机器学习这个词是让人疑惑的，首先它是英文名称Machine Learning(简称ML)的直译，在计算界Machine一般指计算机。这个名字使用了拟人的手法，说明了这门技术是让机器“学习”的技术。但是计算机是死的，怎么可能像人类一样“学习”呢？
传统上如果我们想让计算机工作，我们给它一串指令，然后它遵照这个指令一步步执行下去。有因有果，非常明确。但这样的方式在机器学习中行不通。机器学习根本不接受你输入的指令，相反，它接受你输入的数据! 也就是说，机器学习是一种让计算机利用数据而不是指令来进行各种工作的方法。这听起来非常不可思议，但结果上却是非常可行的。“统计”思想将在你学习“机器学习”相关理念时无时无刻不伴随，相关而不是因果的概念将是支撑机器学习能够工作的核心概念。你会颠覆对你以前所有程序中建立的因果无处不在的根本理念。
下面我通过一个故事来简单地阐明什么是机器学习。这个故事比较适合用在知乎上作为一个概念的阐明。在这里，这个故事没有展开，但相关内容与核心是存在的。如果你想简单的了解一下什么是机器学习，那么看完这个故事就足够了。如果你想了解机器学习的更多知识以及与它关联紧密的当代技术，那么请你继续往下看，后面有更多的丰富的内容。
这个例子来源于我真实的生活经验，我在思考这个问题的时候突然发现它的过程可以被扩充化为一个完整的机器学习的过程，因此我决定使用这个例子作为所有介绍的开始。这个故事称为“等人问题”。
我相信大家都有跟别人相约，然后等人的经历。现实中不是每个人都那么守时的，于是当你碰到一些爱迟到的人，你的时间不可避免的要浪费。我就碰到过这样的一个例子。
对我的一个朋友小Y而言，他就不是那么守时，最常见的表现是他经常迟到。当有一次我跟他约好3点钟在某个麦当劳见面时，在我出门的那一刻我突然想到一个问题：我现在出发合适么？我会不会又到了地点后，花上30分钟去等他？我决定采取一个策略解决这个问题。
要想解决这个问题，有好几种方法。第一种方法是采用知识：我搜寻能够解决这个问题的知识。但很遗憾，没有人会把如何等人这个问题作为知识传授，因此我不可能找到已有的知识能够解决这个问题。第二种方法是问他人：我去询问他人获得解决这个问题的能力。但是同样的，这个问题没有人能够解答，因为可能没人碰上跟我一样的情况。第三种方法是准则法：我问自己的内心，我有否设立过什么准则去面对这个问题？例如，无论别人如何，我都会守时到达。但我不是个死板的人，我没有设立过这样的规则。
事实上，我相信有种方法比以上三种都合适。我把过往跟小Y相约的经历在脑海中重现一下，看看跟他相约的次数中，迟到占了多大的比例。而我利用这来预测他这次迟到的可能性。如果这个值超出了我心里的某个界限，那我选择等一会再出发。假设我跟小Y约过5次，他迟到的次数是1次，那么他按时到的比例为80%，我心中的阈值为70%，我认为这次小Y应该不会迟到，因此我按时出门。如果小Y在5次迟到的次数中占了4次，也就是他按时到达的比例为20%，由于这个值低于我的阈值，因此我选择推迟出门的时间。这个方法从它的利用层面来看，又称为经验法。在经验法的思考过程中，我事实上利用了以往所有相约的数据。因此也可以称之为依据数据做的判断。
依据数据所做的判断跟机器学习的思想根本上是一致的。 刚才的思考过程我只考虑“频次”这种属性。在真实的机器学习中，这可能都不算是一个应用。一般的机器学习模型至少考虑两个量：一个是因变量，也就是我们希望预测的结果，在这个例子里就是小Y迟到与否的判断。另一个是自变量，也就是用来预测小Y是否迟到的量。假设我把时间作为自变量，譬如我发现小Y所有迟到的日子基本都是星期五，而在非星期五情况下他基本不迟到。于是我可以建立一个模型，来模拟小Y迟到与否跟日子是否是星期五的概率。见下图：
图3 决策树模型
这样的图就是一个最简单的机器学习模型，称之为决策树。
当我们考虑的自变量只有一个时，情况较为简单。如果把我们的自变量再增加一个。例如小Y迟到的部分情况时是在他开车过来的时候(你可以理解为他开车水平较臭，或者路较堵)。于是我可以关联考虑这些信息。建立一个更复杂的模型，这个模型包含两个自变量与一个因变量。
再更复杂一点，小Y的迟到跟天气也有一定的原因，例如下雨的时候，这时候我需要考虑三个自变量。
如果我希望能够预测小Y迟到的具体时间，我可以把他每次迟到的时间跟雨量的大小以及前面考虑的自变量统一建立一个模型。于是我的模型可以预测值，例如他大概会迟到几分钟。这样可以帮助我更好的规划我出门的时间。在这样的情况下，决策树就无法很好地支撑了，因为决策树只能预测离散值。我们可以用节2所介绍的线型回归方法建立这个模型。
如果我把这些建立模型的过程交给电脑。比如把所有的自变量和因变量输入，然后让计算机帮我生成一个模型，同时让计算机根据我当前的情况，给出我是否需要迟出门，需要迟几分钟的建议。那么计算机执行这些辅助决策的过程就是机器学习的过程。
机器学习方法是计算机利用已有的数据(经验)，得出了某种模型(迟到的规律)，并利用此模型预测未来(是否迟到)的一种方法。
通过上面的分析，可以看出机器学习与人类思考的经验过程是类似的，不过它能考虑更多的情况，执行更加复杂的计算。事实上，机器学习的一个主要目的就是把人类思考归纳经验的过程转化为计算机通过对数据的处理计算得出模型的过程。经过计算机得出的模型能够以近似于人的方式解决很多灵活复杂的问题。
下面，我会开始对机器学习的正式介绍，包括定义、范围，方法、应用等等，都有所包含。
2.机器学习的定义 从广义上来说，机器学习是一种能够赋予机器学习的能力以此让它完成直接编程无法完成的功能的方法。但从实践的意义上来说，机器学习是一种通过利用数据，训练出模型，然后使用模型预测的一种方法。
让我们具体看一个例子。
图4 房价的例子
拿国民话题的房子来说。现在我手里有一栋房子需要售卖，我应该给它标上多大的价格？房子的面积是100平方米，价格是100万，120万，还是140万？
很显然，我希望获得房价与面积的某种规律。那么我该如何获得这个规律？用报纸上的房价平均数据么？还是参考别人面积相似的？无论哪种，似乎都并不是太靠谱。
我现在希望获得一个合理的，并且能够最大程度的反映面积与房价关系的规律。于是我调查了周边与我房型类似的一些房子，获得一组数据。这组数据中包含了大大小小房子的面积与价格，如果我能从这组数据中找出面积与价格的规律，那么我就可以得出房子的价格。
对规律的寻找很简单，拟合出一条直线，让它“穿过”所有的点，并且与各个点的距离尽可能的小。
通过这条直线，我获得了一个能够最佳反映房价与面积规律的规律。这条直线同时也是一个下式所表明的函数：
房价 = 面积 * a + b
上述中的a、b都是直线的参数。获得这些参数以后，我就可以计算出房子的价格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c339d0549fd43a13af3831fff7879bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e6ab355bce9abda3d86130ef80c37b/" rel="bookmark">
			将属性文件交给spring管理，从spring容器中获取属性文件的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在spring上下文的配置文件中，加入需要管理的属性文件
&lt;bean id="propertyConfigurer" class="com.sg.syj.base.webservice.ReadSpringProperty"&gt;
&lt;property name="locations"&gt;
&lt;list&gt;
&lt;value&gt;WEB-INF/config/properties/jdbc.properties&lt;/value&gt;
&lt;value&gt;WEB-INF/config/properties/webservice.properties&lt;/value&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;
自定义类 ReadSpringProperty继承 org.springframework.beans.factory.config.PropertyPlaceholderConfigurer
package com.sg.syj.base;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;
/***
* * @author czm
* 获取spring管理的属性文件
*
*/
public class ReadSpringProperty extends PropertyPlaceholderConfigurer {
private static Map&lt;String, Object&gt; propertiesMap;
protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException { super.processProperties(beanFactoryToProcess, props);
propertiesMap = new HashMap&lt;String, Object&gt;();
for (Object key : props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e6ab355bce9abda3d86130ef80c37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4987842984792ada96eda2d87e41dbae/" rel="bookmark">
			关于动态获取设置像素大小以及TypedValue.applyDimension()的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数情况下,我们要考虑手机的适配问题,以前做项目的时候,都是以480为标准,现在手机越来越发达,都以720为标准(大多数)进行屏幕适配.进行适配的话,免不了用dimens文件,在文件中存储需要用到的值,然后根据不同的手机设置不同的文件夹,这是比较通用的解决方案,当然,这肯定不是唯一的.在dp能解决大多数的适配问题的时候,一些局部的适配我们通常是在代码里设置,根据不同的屏幕密度,获取不同的像素值来设置.
获取像素值的方法,一般我们是写一个工具类,将要设置的dp转成不同的px来进行适配.
例如这样:
&lt;span style="white-space:pre"&gt;	&lt;/span&gt;/** * 获取屏幕密度 * * @return float * @throws */ public static float getDensity(Context context) { DisplayMetrics dm = new DisplayMetrics(); dm = context.getResources().getDisplayMetrics(); return dm.density; } /** * dp转px * * @param dpValue * dp * @return int px * @throws */ public static int dp2px(Context context, float dpValue) { return (int) (dpValue * getDensity(context) + 0.5f); } 这样就能比较方便的设置控件的位置,并且做到适配的目的. 但是,Android本身是不是已经有方法帮助我们转化了,貌似大多数人都没有考虑过.这就是接下来要说的TypedValue这个类.
先看一段demo代码:
&lt;span style="white-space:pre"&gt;	&lt;/span&gt;public class MainActivity extends Activity { &lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4987842984792ada96eda2d87e41dbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dea8268aa53fd3e3c1643f5d714da19/" rel="bookmark">
			嵌入式 hi3518c平台上无线网卡rtl8188eu系列网卡移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式 hi3518c平台上无线网卡rtl8188eu系列网卡移植 首先修改driver下驱动文件中的Makefile文件：
添加自己的平台,我的平台是hi3518c，具体操作如下：
#add the new platform hi3518c alter by kj
CONFIG_PLATFORM_HI_3518C = y
添加平台的编译选项：
#add the compile option for hi_3518c
ifeq ($(CONFIG_PLATFORM_HI_3518C), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_MINIMAL_MEMORY_USAGE
ARCH := arm
CROSS_COMPILE := arm-hisiv100nptl-linux-
KVER := 3.0.8
KSRC := /home/kongjun/mywork/develop_kj/Hi3518_SDK_V1.0.3.0/osdrv/kernel/linux-3.0.y
endif
注意：
CONFIG_POWER_SAVING = n（省电模式最好关闭）
下面是官方文档的编译说明：
Introduction
Inthis document, we introduce two ways to compile and install our Wi-Fi driver:
1) Using install.sh script for PC-Linux and 2) Step by step manually .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dea8268aa53fd3e3c1643f5d714da19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba3888561bbc888be874c7b554476b5/" rel="bookmark">
			一个游戏网关 fooking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oschina介绍 http://www.oschina.net/p/fooking
git 地址 http://git.oschina.net/scgywx/fooking
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0cf32cfc3530152030e765481a4646/" rel="bookmark">
			Android复制文件,文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//相应的路径需要添加权限支持，各位看自己需要操作的文件添加对应的权限了 //头部 package Common; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; ///复制文件// /** * 复制单个文件 * @param oldPath String 原文件路径 如：c:/fqf.txt * @param newPath String 复制后路径 如：f:/fqf.txt * @return boolean */ public boolean copyFile(String oldPath, String newPath) { boolean isok = true ; try { int bytesum = 0 ; int byteread = 0 ; File oldfile = new File(oldPath); if (oldfile.exists()) { //文件存在时 InputStream inStream = new FileInputStream(oldPath); //读入原文件 FileOutputStream fs = new FileOutputStream(newPath); byte [] buffer = new byte [ 1024 ]; int length; while ( (byteread = inStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0cf32cfc3530152030e765481a4646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50ff0af0813fbf6030392a4b727b305/" rel="bookmark">
			Android 从硬件到应用：一步一步向上爬 6 -- 编写APP测试框架层硬件服务(完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建Android Application工程：使用Eclipse的Android插件ADT创建Android工程，工程名称为Gpio，创建完成后将工程目录拷贝到packages/apps/文件夹下，并删除工程目录下的gen文件夹，不删除的话会造成类重复的错误。
src/com/android/gpio/Gpio.java：
package com.android.gpio; import com.android.gpio.R; import android.app.Activity; import android.os.ServiceManager; import android.os.Bundle; import android.os.IGpioService; import android.os.RemoteException; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class Gpio extends Activity implements OnClickListener { private final static String LOG_TAG = "com.android.Gpio"; private IGpioService gpioService = null; private Button setButton = null; private Button clearButton = null; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50ff0af0813fbf6030392a4b727b305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cb47cd2d85059fbf690885a241eb0f/" rel="bookmark">
			StringUtils.isEmpty和StringUtils.isBlank用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;a target=_blank href="http://blog.csdn.net/ocean20/article/details/6674077"&gt;转载自:http://blog.csdn.net/ocean20/article/details/6674077&lt;/a&gt;StringUtils 方法的操作对象是 java.lang.String 类型的对象，是 JDK 提供的 String 类型操作方法的补充，并且是 null 安全的(即如果输入参数 String 为 null 则不会抛出 NullPointerException ，而是做了相应处理，例如，如果输入为 null 则返回也是 null 等，具体可以查看源代码)。 除了构造器，StringUtils 中一共有130多个方法，并且都是 static 的，所以我们可以这样调用 StringUtils.xxx() 下面分别对一些常用方法做简要介绍： 1. public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0 下面是 StringUtils 判断是否为空的示例： StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false //注意在 StringUtils 中空格作非空处理 StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false 2. public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cb47cd2d85059fbf690885a241eb0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124f3bdc141a65576a6475524655d447/" rel="bookmark">
			公钥基础设施PKI(Pubic Key Infrastructure)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公钥基础设施PKI 简介 摘要：本文简介了当前广泛用于解决电子商务中安全问题的PKI 技术。PKI(Pubic Key Infrastructure)是一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。PKI 的核心组成部分CA( Certification Authority)，即认证中心，它是数字证书的签发机构。数字证书，有时被称为数字身份证，是一个符合一定格式的电子文件，用来识别电子证书持有者的真实身份。
一 PKI 简介
随着Internet 的普及，人们通过因特网进行沟通越来越多，相应的通过网络进行商务活动即电子商务也得到了广泛的发展。电子商务为我国企业开拓国际国内市场、利用好国内外各种资源提供了一个千载难逢的良机。电子商务对企业来说真正体现了平等 竞争、高效率、低成本、高质量的优势，能让企业在激烈的市场竞争中把握商机、脱颖而出。发达国家已经把电子商务作为21 世纪国家经济的增长重点，我国的有关部门也正在大力推进我国企业发展电子商务。然而随着电子商务的飞速发展也相应的引发出一些Internet 安全问题。
概括起来，进行电子交易的互联网用户所面临的安全问题有： 一，保密性 ：如何保证电子商务中涉及的大量保密信息在公开网络的传输过程中不被窃取；
二，完整性 ：如何保证电子商务中所传输的交易信息不被中途篡改及通过重复发送进行虚假交易；
三，身份认证与授权 ：在电子商务的交易过程中，如何对双方进行认证，以保证交易双方身份的正确性；
四，抗抵赖 ：在电子商务的交易完成后，如何保证交易的任何一方无法否认已发生的交易。这些安全问题将在很大程度上限制电子商务的进一步发展，因此如何保证Internet 网上信息传输的安全，已成为发展电子商务的重要环节。
为解决这些Internet 的安全问题，世界各国对其进行了多年的研究，初步形成了一套完 整的Internet 安全解决方案，即目前被广泛采用的PKI 技术(Public Key Infrastructure-公钥基 础设施)，PKI（公钥基础设施）技术采用证书管理公钥，通过第三方的可信任机构--认证中 心CA(Certificate Authority)，把用户的公钥和用户的其他标识信息（如名称、e-mail、身份 证号等）捆绑在一起，在Internet 网上验证用户的身份。目前，通用的办法是采用基于PKI 结构结合数字证书，通过把要传输的数字信息进行加密，保证信息传输的保密性、完整性，签名保证身份的真实性和抗抵赖。
二 PKI 的基本定义与组成
PKI 的基本定义十分简单，所谓PKI 就是一个用公钥概念和技术实施和提供安全服务的具有普适性的安全基础设施。PKI 是一种新的安全技术，它由公开密钥密码技术、数字证书、证书发放机构（CA）和关于公开密钥的安全策略等基本成分共同组成的。PKI 是利用公钥技术实现电子商务安全的一种体系，是一种基础设施，网络通讯、网上交易是利用它来保证安全的。从某种意义上讲，PKI 包含了安全认证系统，即安全认证系统-CA 系统是PKI 不可缺的组成部分。 PKI（Public Key Infrastructure）公钥基础设施是提供公钥加密和数字签名服务的系统或平台，目的是为了管理密钥和证书。一个机构通过采用PKI 框架管理密钥和证书可以建立一个安全的网络环境。PKI 主要包括四个部分：X.509 格式的证书（X.509 V3）和证书废止列表CRL（X.509 V2）；CA 操作协议；CA 管理协议；CA 政策制定。一个典型、完整、有效的PKI 应用系统至少应具有以下五个部分； 1） 认证中心CA CA 是PKI 的核心，CA 负责管理PKI 结构下的所有用户（包括各种应用程序）的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份，CA 还要负责用户证书的黑名单登记和黑名单发布，后面有CA 的详细描述。 2） X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124f3bdc141a65576a6475524655d447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1c3f6525eace3646cf7414373b391f/" rel="bookmark">
			eclipse软件镜像地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在eclipse官网上下载eclipse软件时，总是发现跳转到一些国内的高校网站，都是国内的一些知名高校，我刚才下载了一下文件，最终下载地址跳转到了中国科学技术大学的镜像站点上，链接如下：
http://mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9082d155ca9cdd1fae2ecf0493c7cdbe/" rel="bookmark">
			Android 从硬件到应用：一步一步向上爬 5 -- 在Frameworks层添硬件服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Frameworks层提供了硬件服务，Android系统APP可以调用这些硬件服务，进而完成硬件的控制，实现应有的功能。接着上一篇，这一篇要在frameworks层为应用提供java接口的硬件服务。cd到frameworks/base/core/java/android/os目录，添加 IGpioService.aidl：
package android.os; interface IGpioService { void setVal(int val); int getVal(); } 我们通过setVal去设置LED的亮灭，getVal一直是省略的 打开frameworks/base下的Android.mk，修改LOCAL_SRC_FILES，增加：
core/java/android/os/IGpioService.aidl \编译IGpioService.aidl接口： make TARGET_PRODUCT=am335xevm_sk -j8 OMAPES=4.x 生成：
Install: out/target/product/am335xevm_sk/system/framework/framework.jar
成功后cd到frameworks/base/services/java/com/android/server目录，添加GpioService.java文件： package com.android.server; import android.content.Context; import android.os.IGpioService; import android.util.Slog; public class GpioService extends IGpioService.Stub { private static final String TAG = "GpioService"; GpioService() { init_native(); } public void setVal(int val) { setVal_native(val); } public int getVal() { return getVal_native(); } private static native boolean init_native(); private static native void setVal_native(int val); private static native int getVal_native(); }; 修改当前目录下的SystemServer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9082d155ca9cdd1fae2ecf0493c7cdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb20e5a38e46a08388ea70b4003c67b/" rel="bookmark">
			Android 从硬件到应用：一步一步向上爬 3 -- 硬件抽象层访问硬件驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 标准的硬件驱动分为两个部分，一个是运行在linux内核里的硬件驱动，而另外一部分是运行在用户空间的硬件抽象层。采用这种方法，就可以使系统具有硬件无关性，也保护了部分厂商的利益。在 Android 从硬件到应用：一步一步向上爬 1 -- 从零编写底层硬件驱动程序 中已经有了编写硬件驱动到linux内核里的步骤，下面就要接着这个工程去看看怎么在硬件抽象层增加硬件模块和我们的内核驱动程序进行交互，完成硬件控制。
进入hardware/libhardware/include/hardware目录，新建gpio.h:
#ifndef ANDROID_GPIO_INTERFACE_H #define ANDROID_GPIO_INTERFACE_H #include &lt;hardware/hardware.h&gt; __BEGIN_DECLS /*module ID*/ #define GPIO_HARDWARE_MODULE_ID "gpio" /*module struct*/ struct gpio_module_t { struct hw_module_t common; }; /*interface struct*/ struct gpio_device_t { struct hw_device_t common; int fd; int (*set_val)(struct gpio_device_t* dev, int val); int (*get_val)(struct gpio_device_t* dev, int* val); }; __END_DECLS #endif 其中set_val和get_val是HAL层向上层应用提供的API接口。 cd到hardware/libhardware/modules目录，新建gpio目录，在里面新建gpio.c文件：
#include &lt;hardware/hardware.h&gt; #include &lt;hardware/gpio.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;cutils/log.h&gt; #include &lt;cutils/atomic.h&gt; #define DEVICE_NAME "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb20e5a38e46a08388ea70b4003c67b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed74f9392a23112d90fdc8cfd492e6c/" rel="bookmark">
			SQL之函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：函数
函数可以理解为一种工具，用于完成定义明确的任务，如平方根、大小字母转换等。
有些函数需要输入参数，有些函数不需要输入参数，但是函数必须具有返回值。
函数分为确定性函数和非确定性函数，确定性函数只需要输入相同的参数，则返回值总是相同的，如abs函数，非确定性函数调用相同的参数，会出现返回值不同的情况，如SQL Server的getdate()函数
对于非确定函数，不同的关系数据库都使用了限制功能使用，如SQL Server 不允许在创建索引的计算列和创建索引的视图中使用非确定性函数，在Oracle中，基于函数的索引不能使用非确定性函数，在DB2中，不允许在连接条件表达式中使用非确定性函数；在SQL Server中，系统函数可以分为聚合函数、数值函数、字符串函数、数据类型转换函数、日期时间函数、文本图像函数、系统统计函数等。
2：统计标准偏差stdev()函数
该函数返回指定表达式中所有值的统计标准偏差
显示不同仓库的工资标准差： use db_sqlserver2 select 仓库号, STDEV(工资) as 工资标准差 from 职工 group by 仓库号 3：总体标准偏差stdevp()
返回指定表达式中所有值的总体标准偏差
4：统计方差var()
返回指定表达式中所有值的统计方差var(expression)，只可用于数字列，空值将被忽略。
5：总体变异方差varp()
返回指定表达式中所有值的总体变异方差
综合运用：
[html] view plain copy use db_sqlserver2 select MAX(工资) as 最大工资, STDEV(工资) as 工资标准差, STDEVP(工资) as 工资总体标准差, VAR(工资) as 工资统计方差, VARP(工资) as 工资总体变异方差 from 职工 效果图： 分类聚合的应用：显示不同城市职工的工资标准差、工资总体标准差、工资统计方差和工资总体变异方差信息
[sql] view plain copy create view view_mysun as select 城市, 工资 from 仓库, 职工 where 仓库.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed74f9392a23112d90fdc8cfd492e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfcca40cae986d9aeddd5029e6d8364/" rel="bookmark">
			VS中检测内存泄漏的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs中检测内存泄漏的方法 分类： MFC2013-03-08 21:44 2764人阅读 评论(0) 收藏 举报 使用vs的内存检测有以下几种方法。
在debug模式下以F5运行：
方法一：
[html] view plain copy #define CRTDBG_MAP_ALLOC #include &lt;stdlib.h&gt; #include &lt;crtdbg.h&gt; //在入口函数中包含 _CrtDumpMemoryLeaks(); //即可检测到内存泄露 //以如下测试函数为例： int main() { char* pChars = new char[10]; _CrtDumpMemoryLeaks(); return 0; } F5运行输出窗口会得到：
Detected memory leaks!
Dumping objects -&gt;
{58} normal block at 0x00341A38, 10 bytes long.
Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD Object dump complete.
以上方法没有输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfcca40cae986d9aeddd5029e6d8364/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/495/">«</a>
	<span class="pagination__item pagination__item--current">496/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/497/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>