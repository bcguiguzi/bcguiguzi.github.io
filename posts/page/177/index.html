<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d57ffd581031cfa292cb11b1d666e65/" rel="bookmark">
			APP 公众号 小程序 合作CPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接合作商城cps！定制化选品！h5页面样式定制！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e445585cd1920cf87afca9d83cbcc7/" rel="bookmark">
			拖拽式小程序系统源码 公众号小程序二合一版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一款拖拽式小程序系统源码，源码开源可自行二开，含完整前后端+搭建教程，公众号、小程序二合一版本，可视化控制后台。
源码下载地址：春哥技术博客获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1ac59ae8109c878e679562cbf6e72f/" rel="bookmark">
			Linux 定时任务调度(crontab)整理，太实用了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crontab命令用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。
可以使用crontab定时处理离线任务，比如每天凌晨2点更新数据等，经常用于系统任务调度。
服务启动和关闭 一般Linux系统中都会装有crontab，如果没有安装可以使用包管理工具安装：
yum -y install vixie-cronyum -y install crontabs crontab服务的启动和关闭命令如下：
service crond start # 启动服务service crond stop # 关闭服务service crond restart # 重启服务service crond reload # 重新载入配置service crond status # 查看crontab服务状态# 可以使用下面的命令加入开机启动chkconfig --level 345 crond on 任务调度全局配置 crontab全局任务调度配置在如下的目录：
cron.d/ cron.daily/ cron.deny cron.hourly/ cron.monthly/ crontab cron.weekly/ cron.daily是每天执行一次的job
cron.weekly是每个星期执行一次的job
cron.monthly是每月执行一次的job
cron.hourly是每个小时执行一次的job
cron.d是系统自动定期需要做的任务
crontab是设定定时任务执行文件
cron.deny文件就是用于控制不让哪些用户使用Crontab的功能
用户配置文件 每个用户都有自己的crontab配置文件，使用crontab -e命令进行编辑。保存后系统会自动存放与/var/spool/cron/目录中，文件以用户名命名。
linux的crontab服务每隔一分钟去读取一次/var/spool/cron,/etc/crontab,/etc/cron.d下面所有的内容。
crontab命令一览：
crontab -e: 编辑当前用户的定时任务列表
crontab -l: 查看当前用户的定时任务列表
crontab -r: 删除当前用户的定时任务列表
crontab定时任务格式 crontab每一条记录为一个定时任务，定时人遵循相应的定义规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1ac59ae8109c878e679562cbf6e72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c2b374c388ba09e80b664c35066c10/" rel="bookmark">
			Vite开启https — 离线和在线生成签名证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Vite构建工具，导致文件请求比较多，每个请求都需要三次握手四次挥手，而https可以多路复用，可以节约大量三次握手四次挥手时间，提升开发效率。
要想使用https协议，必不可少的是颁发证书这个步骤。
一、证书颁发 可以使用 OpenSSL 来操作一堆命令生成，这里使用更简单的工具mkcert
1、离线情况（win7系统） a. 若没有shell工具，安装shell 如果使用的是win7，系统是没有自带shell工具，需要手动安装Windows Management Framework 下载地址若不可用，请自行百度 下载地址: https://download.microsoft.com/download/6/F/5/6F5FF66C-6775-42B0-86C4-47D41F2DA187/Win7AndW2K8R2-KB3191566-x64.zip b. 下载 mkcert 工具 mkcert github地址：https://github.com/FiloSottile/mkcert 下载地址： https://github.com/FiloSottile/mkcert/releases 找到合适的下载包下载 c. 生成证书 打开PowerShell将exe文件直接拉进shell，在后面添加 -install， 然后回车，如下：PS F:\test&gt; D:\chrome\mkcert-v1.4.4-windows-arm64.exe -install 为指定IP或域名生成公钥和SSL证书
再将exe文件直接拉进shell，在后面添加 localhost 127.0.0.1， 然后回车，如下：PS F:\test&gt; D:\chrome\mkcert-v1.4.4-windows-arm64.exe localhost 127.0.0.1 即可在当前目录下生成两个文件，一个是公钥（发起请求时需要携带公钥），一个是证书
2、在线情况 按照官文（https://github.com/FiloSottile/mkcert）安装，略
二、Vite配置 把上面生成的两个文件放到项目根目录keys文件夹
server: { host: true, port: 3001, open: true, https: { key: fs.readFileSync("keys/localhost+1-key.pem"), // 读取我们上面生成的公钥 cert: fs.readFileSync("keys/localhost+1.pem"),	// 读取我们上面生成的证书 }, proxy: { "/api": { target: VITE_PROXY, changeOrigin: true, rewrite: (path) =&gt; path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c2b374c388ba09e80b664c35066c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c615524ab65281b8bbebbc7d721cb4/" rel="bookmark">
			网络编程之基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、基础理论
1. 网络分层模型
（1）OSI七层模型
（2）TCP/IP模型
2. ipv4和ipv6 3. 端口号 二、使用实例
1.TCP协议
2、相关API
(1)创建套接字
(2)绑定ip和端口号(自己的ip和端口号) (3)连接服务器 (4)监听--tcp协议允许多个客户端连接同一个服务器
(5)接受客户端的连接请求，愿意接听 (6)读函数
(7)写函数
(8)关闭文件描述符或套接字
2.代码实例
2.1 客户端双向通信代码
2.2 服务器双向通信代码 总结
前言 前面编写的进程间通信：只能用于同一台主机内部不同的进程，而这次讲诉的网络编程也是进程间通信的一种方式，它可以用于不同主机间的进程通信。
一、基础理论 1. 网络分层模型 （1）OSI七层模型 作用：为了方便大家去理解网络通信的整个流程，人为地把计算机网络划分为七个层次。
划分标准：
应用层 ：网络服务与最终用户的一个接口，需要用到这个层次中对应的通信协议，http协议(超文本传输协议，开发网页) ftp协议(文件传输协议) telnet协议(远程登录)等。表示层 ：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，JPEG、ASCll、EBCDIC、加密格式等。会话层：建立、管理、终止会话。（在五层模型里面已经合并到了应用层），对应主机进程，指本地主机与远程主机正在进行的会话。传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层网络层：找到数据传输的最优路径(路由功能) 协议有：ICMP IGMP IP（IPV4 IPV6）。数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验 等功能。（由底层网络定义协议）。物理层：建立、维护、断开物理连接。（由底层网络定义协议）。 网络协议：老外给七个层次，每个层次都制定了很多通信协议(网络协议，游戏规则) （2）TCP/IP模型 把七层模型简化成了四层，有些资料也会说 TCP/IP 是五层模型，所谓的五层模型指的是在数据链路层下面还有一个物理层，而作为软件工程师一般不需要关注物理层，所以通常我们说 TCP/IP 四层。
2. ipv4和ipv6 ipv4地址：32位的地址 文本格式为 nnn.nnn.nnn.nnn，其中 0&lt;=nnn&lt;=255，比如：192.168.24.2 (点分十进制ip，三个小数点划分为4个部分，每个部分各占一个字节) ipv6地址：解决ipv4不够用，扩展了位数，扩展到128位，文本格式为 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中每个 x 都是十六进制数，表示 4 位。 3. 端口号 作用：区分同一台主机内部不同的网络进程 特点：同一台主机内部，端口号不能一样，不同主机，端口号可以是一样的 本质：无符号短整型数字，取值范围0---65535之间，程序员是可以给程序指定端口号，但是需要注意，1024以内的端口号不要去使用(1024以内的端口号很多被linux系统占用)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c615524ab65281b8bbebbc7d721cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d74bdae1b1637a664e8265f0bb25ee/" rel="bookmark">
			ubuntu18.04 network有线网络图标缺失解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先按照博客１安装驱动 博客１链接：Ubuntu安装 Realtek R8125 驱动_Lwang2018的博客-CSDN博客_瑞昱8125 for ubunt
安装完成后，遇到问题：`ifconfig -a`显示的有线网接口（名字以`en`开头）没有ip地址等网卡信息。为解决这个问题，参考博客２查看网卡托管状态，发现网卡未托管。
博客２链接：Ubuntu系统用ifconfig看不到网卡信息 - 知乎
按照博客２方法修改托管状态。
对博客２改动的步骤：
在博客２中，在步骤－－查看NetworkManager 网卡设备配置文件时，执行命令`sudo vi /etc/netplan/01-network-manager-all.yaml`，不修改配置文件。
改为在配置文件中添加 IP 地址、子网掩码、网关、DNS 服务器等配置。假定有线网接口名为`ens33`，分别用 192.168.0.4 作为网卡 enp33 的 IP 地址，192.168.0.1 作为网关地址，255.255.255.0 作为子网掩码（对应CIDR Table中的24），用 8.8.8.8 、10.10.10.10 这两个 DNS 服务器 IP。
# This is the network config written by 'subiquity' network: version: 2 renderer: NetworkManager ethernets: ens33: # 有线网接口名 addresses: [192.168.0.4/24] # ip地址/子网掩码 gateway4: 192.168.0.1 # 网关 dhcp4: no dhcp6: no nameservers: addresses: [8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d74bdae1b1637a664e8265f0bb25ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8372a0e56316e29f5b15630fca4a34ca/" rel="bookmark">
			【牛客网】BC110 井字棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
描述
输入描述：
输出描述：
示例1
代码实现：
描述 KiKi和BoBo玩 “井”字棋。也就是在九宫格中，只要任意行、列，或者任意对角线上面出现三个连续相同的棋子，就能获胜。请根据棋盘状态，判断当前输赢。
输入描述： 三行三列的字符元素，代表棋盘状态，字符元素用空格分开，代表当前棋盘，其中元素为K代表KiKi玩家的棋子，为O表示没有棋子，为B代表BoBo玩家的棋子。
输出描述： 如果KiKi获胜，输出“KiKi wins!”；
如果BoBo获胜，输出“BoBo wins!”；
如果没有获胜，输出“No winner!”。
示例1 输入：
K O B O K B B O K 输出：
KiKi wins! 代码实现： #include &lt;stdio.h&gt; char Iswin(char board[3][3], int row, int col) { //横三行 int i = 0; for (i = 0; i &lt; row; i++) { if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][0] != 'O') return board[i][0]; } //竖三列 for (i = 0; i &lt; col; i++) { if (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[0][i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8372a0e56316e29f5b15630fca4a34ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92de9fce229cf7908aa7f59b5a913704/" rel="bookmark">
			quartus18.1--下载设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、quartus下载流程 1.打开Quartus工程，点击“Start Compilation”按钮进行程序全编译，如下图所示。
2.程序全编译无错误，编译信息如下图所示。
3
3.点击“Programmer”快捷按钮，进入程序下载页面。如下图所示。
4.选择“USB-Blaster”下载器，模式选择“JTAG”，点击“Add File”添加可执行文件“key_led.pof”并点击“Open”按钮打开，如下图所示。
5.选中“Program/Configure”复选款，点击“Start”按钮进行程序下载，如下图所示。
6.如下图所示“Progress”进程为100%时，程序下载完成。
二、quartus下载遇到的问题 如上图所示，这是博主最近遇到的问题，出现这种错误是因为下载方式选择的不对。
更改方式如下：
1.打开assignment--settings，点击右上角的device/board；
2.点击device and pin options;
3.更改下图设置匹配对应下载方式即可！
上文中参考http//jingyan.baidu.com/article/20b68a884fa174386dec627e.html。
有关quartus其他内容的详细规划设计以及代码实现，我们下期见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fa30d45733b1f46b9750547ab729c9/" rel="bookmark">
			联邦学习基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、联邦学习
二、联邦学习的分类
三、联邦学习的架构
四、联邦学习的精度损失
五、联邦学习的应用
六、总结
一、联邦学习 联邦学习（Federated Learning）是一种分布式机器学习技术，其核心思想是通过在多个拥有本地数据的数据源之间进行分布式模型训练，不需要交换本地数据，仅通过交换模型参数或中间结果来构建基于虚拟融合数据下的全局模型，从而实现数据隐私保护和数据共享计算的平衡。
随着人类社会数字化进程越来越快，产生了大量数据。通过机器学习技术可以自动化地挖掘数据中蕴藏的宝藏，经过大量数据训练出来的机器学习模型已经应用在各类场景中，正在深刻改变着我们的世界，例如精准医疗、人像识别、声纹识别、千人千面推荐算法等多模态学习。在应用中，模型的精度、泛化能力等至关重要，而这些都赖于机器对大量数据的学习。想要让机器学习模型的效果更好，就要获取尽可能多的数据，例如第三方数据。但受限于法律法规、政策监管、商业机密、个人隐私等数据隐私安全上的约束，多个数据来源方之间无法直接交换数据，形成了“数据孤岛”现象，这制约着人工智能模型能力的进一步提高。联邦学习的诞生即是为了解决这一问题，目前联邦学习技术在医疗、金融、电信、政务等领域有着广泛的应用。
联邦学习的技术理论基础可以追溯到分布式数据库（Distributed Database）关联规则挖掘技术，其发展简史如下图所示。联邦学习最早是在2016年由Google提出，用于解决安卓手机终端用户在本地更新模型的问题，目前的联邦学习技术旨在保证数据隐私安全及合法合规的基础上，实现共同建模，提升AI模型的效果。
二、联邦学习的分类 在现实中，往往会遇到这样的情况：各个data owners所拥有的用户列表不完全相同或完全不同，用户特征不完全相同或完全不同。具体而言，根据参与联邦学习的不同data owners之间数据分布的不同，可以把联邦学习分为三类：横向联邦学习、纵向联邦学习和联邦迁移学习。
横向联邦学习（Horizontal Federated Learning, HFL）：
又被称为基于样本的联邦学习，“横向”表示数据是横向（按行）划分的，横向联邦可以增加训练样本的总量，数据特征维度不变（或减少，因为取交集）。
应用场景：例如两家不同地区、同一行业的公司。它们的用户群体来自不同地域，其用户交集可能非常小。但是，由于处在同一行业中，其业务可能非常相似。因此，用户特征是相似的。此时，就可以使用横向联邦学习来构建联邦模型。前几年，Google 提出一个针对安卓手机模型更新的数据联合建模方案，即当用户使用安卓手机时，会在本地不断更新模型参数并将参数上传到安卓云上，从而使特征维度相同的各个data owners建立联合模型。
横向联邦学习 纵向联邦学习（Vertical Federated Learning, VFL）：
又被称为基于特征的联邦学习，纵向表示数据是纵向（按列）划分的，纵向联邦可以增加训练数据特征，训练样本总量不变（或者减少）。
应用场景：例如两家相同地区、不同行业的公司。由于两家公司处于同一地区，其用户群体很有可能有大量交集。但是，由于公司业务不同，其用户特征交集可能较小。纵向联邦学习就是将这些不同特征在加密的状态下加以聚合，以增强模型能力的联邦学习。目前机器学习模型如逻辑回归、决策树等均是建立在纵向联邦学习系统框架之下的。
纵向联邦学习 联邦迁移学习（Federated Transfer Learning, FTL）：
在两个数据集的用户与用户特征重叠都较少的情况下，我们不对数据进行切分，而可以利用迁移学习来克服小数据或无标签的情况。
应用场景：例如两家不同地区、不同行业的公司，由于地域等不同，这两家公司的用户群体交集很小。同时由于公司业务不同，两家公司用户群体的数据特征也只有小部分重合。在这种情况下，要想进行有效的联邦学习，就必须引入迁移学习来解决单边数据规模小和标签样本少的问题，从而提升模型的效果。
联邦迁移学习 三、联邦学习的架构 联邦学习系统主要由两部分构成。
1、加密样本对齐。由于各个data owners的用户群体并非完全重合，需要通过用户样本对齐技术在 不公开各自数据的前提下确认共有用户（且不暴露独有用户），随后就可以联合这些用户的特征进行建模。
2、加密模型训练。在确定共有用户群体后，就可以利用这些数据训练机器学习模型。为保证训练过程中数据的保密性，需要借助第三方协作者进行加密训练。①协作者把公钥分发给各个data owners，用以对训练过程中需要交换的数据进行加密；②data owners之间以加密形式交互中间结果用于计算梯度；③各data owners分别基于加密的梯度值进行计算，同时根据标签数据计算损失，并把这些结果汇总给第三方协作者，由第三方协作者通过汇总结果计算总梯度并将其解密；④第三方协作者将解密后的梯度回传给各data owners，让其根据梯度更新各自模型的参数。
联邦学习的架构（2 data owners） 迭代上述步骤直至损失函数收敛，这样就完成了整个训练过程。在样本对齐及模型训练过程中，各个data owners的数据始终保留在本地，且训练中的数据交互也不会导致数据隐私泄露。因此，联邦学习可实现多方合作训练模型。
四、联邦学习的精度损失 天下没有免费的午餐，想同时做到保护数据隐私和保持模型性能是不可能的。例如，同态加密中，对于密文的操作将比明文花费更长的时间，并且模型的精度会变差（半同态）。
定义N个data owners，通过合并各自的数据来训练机器学习模型，其常规方法是简单集合所有数据，使用训练模型M1。联邦学习系统是一个学习过程，其data owners在数据隐私保护的前提之下协作训练模型M2。模型M2的精度V2应非常接近模型M1的精度V1。形式上，若δ为非负实数，如果：
则认为该联邦学习算法具有δ-精度损失。δ值越小，则说明联邦学习系统的效果就越好。
2022年，杨强院士及WeBank团队提出了隐私与模型性能的"No-free-lunch安全-收益恒定"定律，从信息论的角度为隐私泄露和效用损失的权衡提供了一个通用的理论框架。这一理论框架揭示了对于满足“贝叶斯隐私”的多方计算系统而言，都满足“｜安全｜+｜效能｜≤常数” 这一“安全-效益恒定定律”。
安全联邦学习 上图的左边部分演示了四个过程：（1）Client使用自己的数据集学习本地模型信息；（2）Client采用保护机制M将模型信息转换为受保护模型信息；（3）每个Client将受保护模型信息上传到聚合器，聚合器将所有受保护模型信息聚合为一个全局模型；(4) 由Client下载全局模型并继续更新本地模型信息。右边部分说明了对手可能根据受保护模型信息推断私有数据的隐私泄露，以及保护机制导致聚合全局模型精度降低的效用损失。
五、联邦学习的应用 在金融风控中，检测多方借贷可以降低贷款损失的风险，例如当某些客户恶意从一家银行借款以支付另一家银行的贷款。多方借贷是对金融稳定的威胁，大量此类非法行为可能导致整个金融系统崩溃。为了在银行A和B之间找到此类客户，而不向彼此公开客户信息。则可以使用联邦学习的加密机制，对每一方的客户信息进行加密，然后在联邦学习系统中获取加密客户的交集，所获得结果解密后即违规客户的名单。
隐私计算在金融反欺诈场景应用示例 六、总结 联邦学习技术可以充分保护用户隐私与数据安全，为建立跨企业、跨数据、跨领域的大数据 AI 生态提供了良好的技术支持。与传统隐私保护技术相比，联邦学习不存在原始数据以及模型的交换，而是通过加密机制下的参数交换方式来保护用户数据隐私。而差分隐私、k匿名、l多样化技术通过将数据去隐私化然后进行数据交换，理论上还是存在数据泄露的可能性。联邦学习的多方联合训练与分布式机器学习也不大相同，横向联邦学习中的工作节点代表的是模型训练的数据拥有方，对本地的数据具有完全的自治权限，可以自主决定何时加入联邦学习进行建模，因此联邦学习系统变得更为复杂。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72fa30d45733b1f46b9750547ab729c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51496aa00e54058e984b3dd4ba52291c/" rel="bookmark">
			在html中select标签下拉框的高度怎么调节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要调整HTML中select标签下拉框的高度，您可以使用CSS中的height属性。具体来说，您可以通过以下方式将其高度设置为特定的像素值：
&lt;select style="height: 100px;"&gt; &lt;option value="1"&gt;选项1&lt;/option&gt; &lt;option value="2"&gt;选项2&lt;/option&gt; &lt;option value="3"&gt;选项3&lt;/option&gt; &lt;/select&gt; 在上面的代码中，将下拉框的高度设置为100像素。您也可以将其设置为其他值，以适应您的需要。另外，如果您不希望使用内联样式，可以将样式添加到CSS文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1bc055b193d6c29faaabdf11970555/" rel="bookmark">
			用php写一个京东登录，然后自动验证京东的人机验证登录进去后获取我的购物车列表...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，您需要了解京东登录API的工作原理，并确保您具有访问API所需的任何权限和凭据。
接下来，您可以使用PHP代码实现京东登录，如下所示：
``` &lt;?php // 设置cURL请求选项 $options = array( CURLOPT_RETURNTRANSFER =&gt; true, // 将请求的结果返回，而不是直接输出 CURLOPT_FOLLOWLOCATION =&gt; true, // 跟随重定向 CURLOPT_AUTOREFERER =&gt; true, // 自动设置Referer CURLOPT_SSL_VERIFYPEER =&gt; false, // 禁用SSL证书验证 CURLOPT_SSL_VERIFYHOST =&gt; false, // 仅在与SSL证书验证相关的情况下使用 CURLOPT_COOKIEJAR =&gt; 'cookie.txt', // 存储cookies CURLOPT_COOKIEFILE =&gt; 'cookie.txt', // 加载cookies CURLOPT_POST =&gt; true, // 发送POST请求 CURLOPT_POSTFIELDS =&gt; http_build_query(array( 'loginName' =&gt; 'YOUR_LOGIN_NAME', 'password' =&gt; 'YOUR_PASSWORD', )), );
// 初始化cURL会话 $ch = curl_init('https://passport.jd.com/new/login.aspx'); curl_setopt_array($ch, $options);
// 执行cURL请求 $response = curl_exec($ch);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1bc055b193d6c29faaabdf11970555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad86e19d4f62ecb389630b2ee924e125/" rel="bookmark">
			使用python爬取付费音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Python 爬取付费音乐时，有几点需要注意：
侵犯版权是违法行为，因此您需要确保您有权进行爬取。
如果您想爬取付费音乐，可能需要使用一些反爬虫技术来避免被网站封禁。这可能包括使用代理服务器、随机化爬取频率以及使用验证码等。
使用 Python 爬取网站内容通常需要使用第三方库，例如 BeautifulSoup 或者 Scrapy。这些库可以帮助您解析 HTML 和 XML 文档，并提取所需的数据。
在编写代码时，您需要考虑爬取的速度以及对目标网站的影响。过快的爬取可能会对目标网站造成负载和带宽压力，并且可能被封禁访问。因此，您应该谨慎地设计您的爬虫，以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b2635065eeb774d92ce152695e7fc8/" rel="bookmark">
			采用 spring 配置文件管理Bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 采用 spring 配置文件管理Bean一、安装配置Maven二、Spring 框架1、Spring 官网 三、Spring 容器演示-采用Spring配置文件管理Bean1、创建Manev项目2、添加Spring依赖3、创建杀龙骑士类4、创建勇敢骑士类5、采用传统方式让勇敢骑士完成杀龙任务6、采用Spring 容器让勇敢骑士完成杀龙任务1) 创建日志属性文件 log4j.properties2) 创建Spring 配置文件3) 在Spring配置文件里面创建Bean(1) 创建杀龙任务Bean(2) 创建勇敢骑士Bean 4) 创建新勇敢骑士测试类5) 创建两个勇敢骑士bean6) 修改新勇敢骑士测试类 7、采用构造方法注入方式注入属性值1) 创建救美任务类2) 创建救美骑士类3) 配置救美骑士Bean4) 创建旧救美骑士测试类5) 创建新救美骑士测试类 采用 spring 配置文件管理Bean 一、安装配置Maven 下载链接：https://pan.baidu.com/s/1pL4IRhwjuXAkezgWQdrnYQ
提取码：hjzs
先创建一个 MAVEN_HOME 变量是包存放的路径
然后在Path 里面添加 %MAVEN_HOME%\bin
配置好之后，在命令行进行测试 输入: mvn -version 可以
安装好之后在 IDEA 里面进行配置Maven
打开setting 选择自己的maven
二、Spring 框架 1、Spring 官网 链接：https://spring.io/
最新版本是6.0.4 因为我们用的JDK版本是17 为了与之对应所以我们这里使用的Spring Franework的版本是5.3.25
三、Spring 容器演示-采用Spring配置文件管理Bean 1、创建Manev项目 2、添加Spring依赖 Spring 框架与JDK版本对应关系
Spring框架版本JDK版本6.0.xJDK17-21（预期）5.3.xJDK8-19（预期）5.2.xJDK8-155.1.xJDK8-125.0.xJDK8-104.3.xJDK6-8 我们这篇博文的环境，JDK17，IntelliJ IDEA 2022，使用的是Spring 5.3.25
在Maven 仓库里面查找我们需要的依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b2635065eeb774d92ce152695e7fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17687e5682b9dd298d0cb0204f62022/" rel="bookmark">
			对比Vector、ArrayList、LinkedList有何区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第8讲 | 对比Vector、ArrayList、LinkedList有何区别？ 我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的 C 语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java 则要方便的多，针对通用场景的需求，Java 提供了强大的集合框架，大大提高了开发者的生产力。
今天我要问你的是有关集合框架方面的问题，对比 Vector、ArrayList、LinkedList 有何区别？
典型回答
这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。
Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。
ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。
LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。
考点分析
似乎从我接触 Java 开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。
一般来说，也可以补充一下不同容器类型适合的场景：
Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。
而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。
所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。
考察 Java 集合框架，我觉得有很多方面需要掌握：
Java 集合框架的设计结构，至少要有一个整体印象。
Java 提供的主要容器（集合和 Map）类型，了解或掌握对应的数据结构、算法，思考具体技术选择。
将问题扩展到性能、并发等领域。
集合框架的演进与发展。
作为 Java 专栏，我会在尽量围绕 Java 相关进行扩展，否则光是罗列集合部分涉及的数据结构就要占用很大篇幅。这并不代表那些不重要，数据结构和算法是基本功，往往也是必考的点，有些公司甚至以考察这些方面而非常知名（甚至是“臭名昭著”）。我这里以需要掌握典型排序算法为例，你至少需要熟知：
内部排序，至少掌握基础算法如归并排序、交换排序（冒泡、快排）、选择排序、插入排序等。
外部排序，掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路。
考察算法不仅仅是如何简单实现，面试官往往会刨根问底，比如哪些是排序是不稳定的呢（快排、堆排），或者思考稳定意味着什么；对不同数据集，各种排序的最好或最差情况；从某个角度如何进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异）等，从简单的了解，到进一步的思考，面试官通常还会观察面试者处理问题和沟通时的思路。
以上只是一个方面的例子，建议学习相关书籍，如《算法导论》《编程珠玑》等，或相关教程。对于特定领域，比如推荐系统，建议咨询领域专家。单纯从面试的角度，很多朋友推荐使用一些算法网站如 LeetCode 等，帮助复习和准备面试，但坦白说我并没有刷过这些算法题，这也是仁者见仁智者见智的事情，招聘时我更倾向于考察面试者自身最擅长的东西，免得招到纯面试高手。
知识扩展
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17687e5682b9dd298d0cb0204f62022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa782a0c27ccb79d87d361153c87ca9/" rel="bookmark">
			Jet颜色映射算法及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、颜色映射简介 opencv中cv::applyColorMap()包含了20中颜色映射算法，autumn bone jet winter rainbow ocean summer spring cool hsv pink hot parula magma inferno plasma viridis cividis twilight twilight_shifted
二、JET映射规律与实现 c++实现
void jetColorMap(double gray, int &amp;r, int &amp;g, int &amp;b) { if (gray &lt; 0 &amp;&amp; gray &gt; 255) { r = 0; g = 0; b = 0; return; } //0~31 if(gray &gt;= 0 &amp;&amp; gray &lt;= 31) { r = 0; g = 0; b = 128 + 4 * (gray - 0); return; } //32 if(gray == 32) { r = 0; g = 0; b = 255; return; } //33~95 if(gray &gt;= 33 &amp;&amp; gray &lt;= 95) { r = 0; g = 4 + 4 * (gray - 33); b = 255; return; } //96 if(gray == 32) { r = 2; g = 255; b = 254; return; } //97~158 if(gray &gt;= 97 &amp;&amp; gray &lt;= 158) { r = 6 + 4 * (gray - 97); g = 255; b = 250 - 4 * (gray - 97); return; } //159 if(gray == 32) { r = 254; g = 255; b = 1; return; } //160~223 if(gray &gt;= 160 &amp;&amp; gray &lt;= 223) { r = 255; g = 252 - 4 * (gray - 160) ; b = 0; return; } //224~255 if(gray &gt;= 224 &amp;&amp; gray &lt;= 255) { r = 252 - 4 * (gray - 224); g = 0; b = 0; return; } } 三、彩色点云应用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa782a0c27ccb79d87d361153c87ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b5f4e042b2bf8895c4b55b1ff7961b/" rel="bookmark">
			IP地址与用户行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址能够解决网络风险和提高网络安全的原因是：所有的网络请求都会带有IP信息，是访问者的独立标识，另外ip地址的分配和管理比较严格，难以造假。另外ip属于网络层，可以轻松的对其进行阻断。现有的各种网络安全、负载均衡的设备和软件，都是以ip为对象进行追踪和管理的。
因此，常见的攻击防范和风险控制都会利用IP来作为用户的身份标识，来进行分析和处理，常见的IP地址信息有：
IP归属地：每个IP的归属地在较短时间内都会保持固定，可以来判断大概的位置，IP数据云可以定位到街道。
所属机构：大型组织机构申请的固定ip都需要绑定信息，可以从ASN数据获取一些信息。例如我们可以借此判断IP是否属于公有云平台、教育网。
绑定域名：通过DNS可以查询到域名相关的ip，同样，部分ip可以反查出相关联的域名。
其他：还有一些其他属性，例如是否属于手机基站等，可在IP数据云上查看最详细的IP地址信息
以上的信息都是属于客观，我们还可以更深一步探索IP行为。
比如：该ip的请求是否有注入、撞库、ddos、漏洞扫描等网络攻击行为；该ip的用户是否有刷单、恶意欺诈、薅羊毛等风控相关的的行为；ip和用户名、设备指纹等的关联信息。
如果发现某个用户、设备上有非常多的用户，极大的概率可以将此用户和设备拉黑；反过来，当某个ip出现了大量的用户或设备，也是风险提示，不过要排除组织出口等属性的影响。
ip的归属地特性也可以与用户行为结合起来。常见的分析方法包括识别用户常用ip，以及用户是否短时间内发生了较大的地理偏移（通过比较使用的不同ip的归属地）。
更复杂的分析包括利用ip、用户、设备之间两两关联的信息可以勾画出网站内用户之间的关联网络、以及用户间的资金流向，这在反洗钱、复杂欺诈行为识别等方面具有显著效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba9861a627cf317e6a07cd2a2b02ef3/" rel="bookmark">
			Component is not found in path “components/xxx/xxx“ (using by “pages/xxx/xxx“) 问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相信做过小程序的都遇到过Component is not found in path “components/xxx/xxx“ (using by “pages/xxx/xxx“) 这个问题，一般情况的是引用路径有问题，检查代码路径改对就好了，又或者是分包影响的
先说一下我得使用场景，不一定适用于所有人，只是记录一下我遇到的
1.小程序是分包的
2.主包下有个components公用组件文件夹 （主包资源(如wxss、js、wxs、component、图片、template)是全局的, 主包和子包都能引用）
3.我的某个需求用到主包下面的business和mouth两个子包里的内容 （子包相当于有自己独立的作用域, 只能使用自己的或主包的资源, 不能使用其他子包的资源）
4.因为还有其他的业务就顺手在business里有个页面内定义了一个功能型组件A，这个A在mouth里也要进行使用（因为mouth有个一模一样的页面，可能以前同事写的，根据权限写了两份），A在business和mouth里的引用路径：/pages/business/xxx/A/index。
然后在business里无异常，在mouth里报错 Component is not found in path “components/xxx/xxx” (using by “pages/xxx/xxx”) 这个问题。
5.第一时间我觉得是引用路径写错了，然后检查路径确认无误之后还是报错，就想了下它们是不是在同一个子包内，打开app.json的subpackages里确认了一下，是两个子包 （子包资源不能共享的）
6.然后我就将business里的功能型组件A放到主包资源components里，然后其他子包引用主包的资源就可正常使用了。
7.so，遇到Component is not found in path “components/xxx/xxx” 这个错误
大部分都是引用路径错误，或者引用不规范导致的，认真检查一下
什么引用组件的json文件的{ component: true }，这是基本语法，这种就不啰嗦了。
总结：
检查当前文件内组件引用路径是否正确（在语法正确的前提下）检查是否是小程序子包资源的互相引用导致（在小程序分包前提下）主包资源(如wxss、js、wxs、component、图片、template)是全局的, 主包和子包都能引用（在小程序分包前提下）子包有自己独立的作用域, 只能使用自己的或主包的资源, 不能使用其他子包的资源（在小程序分包前提下） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7aae8475b534a6863d3b2c10da0396/" rel="bookmark">
			buildroot使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景介绍 在进行嵌入式终端开发过程中，如果使用的是linux系统的话，移植适配完成linux kernel后，我们还需要制作linux的启动文件系统，而文件系统通常要包含很多第三方软件，比如udhcpc，tftp，apache，sqlite，PHP，iptable，DNS等，为了避免繁杂的移植工作Buildroot应运而生。Buildroot是Linux平台上一个构建嵌入式Linux系统的框架，你可以和编译Linux内核一样，通过Buildroot的配置指令：make menuconfig，配置我们需要的功能，不需要的功能去掉，再执行make指令编译，Buildroot就会自动从指定的服务器上下载源码包,自动编译,自动搭建成我们所需要的嵌入式根文件系统，编译出一个完整的可以直接烧写到机器上运行的Linux系统软件，包含boot、kernel、rootfs以及rootfs中的各种库和应用程序，让我们的工作效率成百倍的提升。
2、获取buildroot 我们可以从buildroot官网(Buildroot - Making Embedded Linux Easy)获取buildroot源码包，我使用的是buildroot-2021.08.01.tar.gz（https://buildroot.org/downloads/buildroot-2021.08.1.tar.gz）版本。Buildroot的目录初始状态下都是一些脚本和配置文件，其中configs文件存放开发板的配置文件，详细介绍如下：
├── arch: 存放CPU架构相关的配置脚本，如arm/mips/x86,这些CPU相关的配置，在制作工具链时，编译uboot和kernel时很关键. ├── board ├── boot ├── CHANGES ├── Config.in ├── Config.in.legacy ├── configs: 放置开发板的一些配置参数. ├── COPYING ├── DEVELOPERS ├── dl: 存放下载的源代码及应用软件的压缩包. ├── docs: 存放相关的参考文档. ├── fs: 放各种文件系统的源代码. ├── linux: 存放着Linux kernel的自动构建脚本. ├── Makefile ├── Makefile.legacy ├── output: 是编译出来的输出文件夹. │ ├── build: 存放解压后的各种软件包编译完成后的现场. │ ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具. │ ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来. │ ├── staging │ └── target: 用来制作rootfs文件系统，里面放着Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7aae8475b534a6863d3b2c10da0396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca9e33a9df3f8b8f40c0556f0ec3baa/" rel="bookmark">
			Qemu模拟ARM64使用GDB调试linux kernel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qemu模拟ARM64使用GDB调试linux kernel 1、linux文件编译 大家在学习linux kernel时，需要购买硬件开发板，这是一笔不少的投入，今天就介绍大家如何使用模拟器来模拟ARM硬件，并且使用GDB来调试linux kernel。
linux 编译框架我使用的是buildroot，buildroot使用可以参考：buildroot使用介绍。
在buildroot编译框架下，我们使用qemu_aarch64_virt_defconfig配置进行编译，编译过程中，buildroot会根据配置文件自动下载相关的文件，包含编译工具链、linux、文件系统等。要使用GDB对linux kernel进行调试，需要开启内核参数CONFIG_DEBUG_INFO和CONFIG_GDB_SCRIPTS两个配置项目。
在buildroot编译框架下输入命令进入linux kernel配置目录：make linux-menuconfig
配置目录下进入kernel hacking条目，首先开启Kernel debugging选项，最后进入Compile-time checks and compiler options 条目，开启Compile the kernel with debug info和Provide GDB scripts for kernel debugging内核参数配置项。
配置完成后使用make命令编译，编译结果会输出到：buildroot-2021.08.1/output/images目录下。
2、qemu模拟器 qemu是一个广泛使用的开源计算机模拟器和虚拟机。当作为模拟器时，可以在一种架构（如x86 PC）下运行另一种架构（如ARM）下的操作系统和程序。通过使用动态翻译，它可以获得非常好的性能。作为虚拟机时，qemu可以使用其他虚拟机管理程序（ KVM）来使用CPU扩展进行虚拟化，通过在主机CPU上直接执行客户机代码来获得接近于宿主机的性能。
ubuntu下安装qemu：sudo apt-get install qemu qemu-system
安装好qemu后我们进入buildroot-2021.08.1/output/images目录下，用qemu_aarch64_virt_defconfig配置编译时自动会生成qemu启动脚本文件：start-qemu.sh，直接运行此文件则可以启动qemu模拟器，模拟ARM芯片启动编译好的linux kernel内核：
qemu启动参数说明：
参数说明-M vexpress-a9指定要仿真的开发板：vexpress-a9-m 512M指定DRAM内存大小为512MB-cpu cortex-a9指定CPU架构-smp nCPU的个数，不设置的话，默认是1-kernel ./zImage要运行的镜像-dtb ./vexpress-vap-ca9.dtb要加载的设备树文件-append cmdline设置Linux内核命令行、启动参数-initrd file使用file文件作为初始化ram disk-nographic非图形化启动，使用串口作为控制台-sd rootfs.ext3使用rootfs.ext3作为SD卡镜像文件-net nic创建一个网卡-net nic -net tap将开发板网卡和主机网卡建立桥接(Bridge) qemu启动运行linux后，退出指令：ctrl+a，然后在按x键。
3、GDB调试 ubuntu 默认安装的gdb 是x86的版本，需要调试aarch64架构的内核必须要安装gdb-multiarch命令：apt-get install gdb-multiarch
3.1、修改qemu启动文件 使用gdb调试，qemu启动命令需要添加一项参数“-s -S”：-s的意思是等待外面gdb的链接，默认开启1234端口进行监听；-S是在内核的入口打断点。添加-s -S参数到 start_qemu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca9e33a9df3f8b8f40c0556f0ec3baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52569c060610b4bacd64b36ffef8e70f/" rel="bookmark">
			软件测试面试十大必考题目（通用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
（1） 为什么想进本公司？
（2） 喜欢这份工作的哪一点？
（3） 自己的优缺点为何？
（4） 对公司的了解有多少？
（5） 对工作的期望与目标何在？
（6） 为什么要离职?
（7） 选择这份工作的原因为何？
（8） 你认为相关产业的发展为何？
（9） 你希望的待遇为多少？
（10）在工作中学习到了些什么？
面试时，有几个问题是公司面试人员常常会提出的，针对这些问题好好准备，在面试时也就不会哑口无言，无言以对了，下面就面试十大必考题做出分析,也许对HR经理也是一个小参考：
（1） 为什么想进本公司？ 这通常是面试官最先问到的问题。此时面试官就开始评断录用与否了，建议大家先判断自己去应徵的工作性质，是专业能力导向呢，或是需要沟通能力，其实现在市场多以服务为方向，所以口才被视为基本能力之一，所以在此时就要好好表现自己的口才，而口才较差者就务必表现出自己的专业能力即诚意，弥补口才不足的部分。
回答这个问题时，一定要积极正面，如想要使自己能有更好的发展空间，希望能在相关领域中有所发展，希望能在公司多多学习等等﹔此时可以稍稍夸一下面试公司，但切记一定要诚恳，不然可是会画蛇添足，得不偿失哦！对于社会新鲜人的建议则是，由于之前没有工作经验，所以建议你可以坦承的说出自己的动机，不过用语还是要思考一下。
（2） 喜欢这份工作的哪一点？ 相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。
（3） 自己的优缺点为何？ 有许多面试官都喜欢问这个问题，目的是在于检视人才是否适当，求职者的诚恳度等等，在这之前应该好好分析自己，将自己的优点与缺点列张单子，在其中挑选亦是缺点亦是优点的部分，在回答问题时，以优点作为主要诉求，强调可以为公司带来利益的优点，如积极，肯学习是最普遍的回答，而缺点部分则建议选择一些无伤大雅的小缺点，或是上述那些模嶙两可的优缺点作为回答，这样才不会使面试官太过针对缺点做发挥，造成面试上的困难。
（4） 对公司的了解有多少？ 这时准备的功夫就派上用场，将你之前所吸收的信息发挥出来吧！至少也要知道公司的产品是哪些，提供哪些服务等等，不然面试官一问当场傻在那儿就糗大了，所以一定要事前准备！
（5） 对工作的期望与目标何在？ 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。
（6） 为什么要离职? 回答这个问题时一定要小心，就算在前一个工作受到在大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。
（7） 选择这份工作的原因为何？ 这是面试官用来测试应聘者对工作理解度的问题，藉以了解求职者只是基于对工作的憧憬或是确实的兴趣来应徵这份工作，此时之前所强调的事先研究功夫又再度派上用场，建议你的回答应以个人的兴趣配合工作内容特质，表现出高度的诚意，这样才可以为自己铺下迈向成功之路。
（8） 你认为相关产业的发展为何？ 这也是事前准备的功夫，多阅读一些相关的报章杂志，做一些思考，表现出自己对此相关产业的的认识，如果是同业转职者，可强调以自己的经验为基础所做的个人见解，但若是初次接触此一行业，建议采取较为保守的方式，以目前资讯所提供的资料为主作答，表现出高度兴趣及诚意为最高指导原则。
（9） 你希望的待遇为多少？ 这是一个非常敏感的问题，其实在目前，一般大型企业在招聘时就会事先说明基本底薪等等薪资待遇为何，而一般中小型企业有许多仍以个人能力，面试评价做作为议薪的标准，所以建议求职者可以利用现在网络科技查询薪资定位的相关资料，配合个人的价值观，经验，能力等等条件，做出最基本的薪资底限，这时建议无工作经验者应采取保守的态度为准，以客观资料作为最主要考量重点，“依公司规定”的回答是不被建议的，这样不但表示出自己对于工作的自信程度不高，在薪资无法符合个人要求时更会造成许多困扰。
（10）在工作中学习到了些什么？ 这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了
感谢每一个认真阅读我文章的人！！！
我个人整理了我这几年软件测试生涯整理的一些技术资料，包含：电子书，简历模块，各种工作模板，面试宝典，自学项目等。欢迎大家点击下方名片免费领取，与我一起学习交流。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/176/">«</a>
	<span class="pagination__item pagination__item--current">177/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/178/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>