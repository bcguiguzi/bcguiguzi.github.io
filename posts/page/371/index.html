<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b09fadfc308fdf612fd4b7c23644e1/" rel="bookmark">
			arch linux2020年安装教程带图文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.正文 我会尽量写的简单详细
2.我使用的镜像 当前版本： 2020.08.01
包含内核： 5.7.11
ISO大小： 671.0 MB
镜像地址
3.需要用到的工具 电脑一台
U盘一个
烧录软件
虚拟机（建议在虚拟机先尝试安装）
4.安装 4.1 启动 启动后选择第一项
联网 安装过程必须联网这里不多赘述，连接wifi和插网线
检查网络通畅
# ping baidu.com 同步时间
# timedatectl set-ntp true 选择源 2020.08.01版本选择源更为简单
用nano或者vim编辑源
# nano /etc/pacman.d/mirrorlist 根据自己需要更改的源，新版本貌似会自动就近的源地址，所以你们的可能和我的不一样，这里我就不做更改了
分区 磁盘若被系统识别到，就会被分配为一个块设备，如 /dev/sda, /dev/nvme0n1 或 /dev/mmcblk0。可以使用 lsblk 或者 fdisk 查看：
# lsblk BIOS 与 MBR分区示例
挂载点分区分区类型建议大小/mnt/dev/sdX1Linux剩余空间[SWAP]/dev/sdX2Linux swap (交换空间)大于 512 MiB UEFI 与 GPT分区示例
挂载点分区分区类型建议大小/mnt/boot 或 /mnt/efi/dev/sdX1EFI 系统分区260–512 MiB/mnt/dev/sdX2Linux x86-64 根目录 (/)剩余空间[SWAP]/dev/sdX3Linux swap (交换空间)大于 512 MiB 开始UEFI分区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b09fadfc308fdf612fd4b7c23644e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279f794b828839033f7ea45bd6faac42/" rel="bookmark">
			go语言实现屏幕截图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借助第三方库
https://github.com/kbinani/screenshot
安装 go get github.com/kbinani/screenshot
方法 详情查看
https://godoc.org/github.com/kbinani/screenshot
自定义截图 Capture func Capture(x, y, width, height int) (*image.RGBA, error) 返回指定桌面区域的屏幕截图。x,y是起点坐标， width，height 是图片的宽和高。
全屏截图 CaptureDisplay func CaptureDisplay(displayIndex int) (*image.RGBA, error) 返回全屏截图。 displayIndex 是显示编号，默认屏幕是0，如果外接多个显示，则是1,2,3,4 … 。
获取活动显示器数量 NumActiveDisplays func NumActiveDisplays（）int 返回活动的显示器的数量。
获取指定屏幕显示范围 GetDisplayBounds func GetDisplayBounds(displayIndex int) image.Rectangle GetDisplayBounds返回displayIndex的显示范围， 范围从(0,0) 坐标开始，当前屏幕分辨率结束 ，例如：(0,0)-(1920,1080)。
获取自定义矩形区域的截图 CaptureRect func CaptureRect(rect image.Rectangle) (*image.RGBA, error) 捕获桌面的指定区域。跟Capture类似，主要搭配GetDisplayBounds 使用。
参数是一个矩形，即两个点，一个最小点，一个最大点
演示 package main import ( "fmt" "github.com/kbinani/screenshot" "image" "image/png" "os" ) // save *image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279f794b828839033f7ea45bd6faac42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67cdacad681b71c80163f3ac398caf1/" rel="bookmark">
			Java在手，世界我有！！！Java中日期时间类——Date类、DateFormat类（SimpleDateFormat子类）与Calendar类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date类 概述 java.util.Date是表示日期和时间的类。 Date类表示特定的瞬间（一个时间点，一刹那时间），精确到毫秒，（1000毫秒=1秒）。毫秒值的可以对时间和日期进行计算。还要清楚一个概念：时间原点。
时间原点（0毫秒）指的是1970年1月1日 00：00：00，这是英国格林威治的时间，需要注意，中国属于东八区，会把时间增加8个小时，也就是： 1970年1月1日 08：00：00。
把毫秒转换为日期：毫秒数/86400000 =天数。
1天 = 24 × 60 × 60 =86400 秒 =86400 × 1000 =86400000 毫秒、
Date类的常用构造方法 （1）Date类的空参数构造方法：Data()获取的就是当前系统的日期和时间
（2）Date类的带参数构造方法：Date(long date)：传递毫秒值，把毫秒值转换为Date日期
代码举例 import java.util.Date; public class Demo02Date { public static void main(String[] args) { //（1）Date类的空参数构造方法：Data()获取的就是当前系统的日期和时间 Date date=new Date(); System.out.println(date); //Sat Aug 22 16:17:15 CST 2020 //（2）Date类的带参数构造方法：Date(long date) ：传递毫秒值，把毫秒值转换为Date日期 Date date1=new Date(0L); System.out.println(date1); //Thu Jan 01 08:00:00 CST 1970 //（2）Date类的带参数构造方法：Date(long date) ：传递毫秒值，把毫秒值转换为Date日期 Date date2=new Date(15811111111L); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f67cdacad681b71c80163f3ac398caf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de4b35a73e10907a972d6afbacae699/" rel="bookmark">
			Hadoop之“WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform“问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上面两个图所示，每次启动hdfs或者使用hdfs命令的时候总是会出现警告WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable。对于一个码农来说这是不可接受的。
有很多大神在博客中给出了集中解决办法，但是个人都觉得相对复杂。本人通过多次阅读了hadoop官方文档，了解到出现这一警告是因为hadoop/lib目录下的本地仓库native未编译导致这一错误的。因此本人把haddop源码进行了一次编译，只需用编译好的libmulu替换原来的lib目录即可解决该问题
具体解决办法 1、下载已经编译好的native:https://pan.baidu.com/s/12iupK9RXektZma8xCflodw
密码:47xa
2、停止hdfs进程
3、在hadoop安装目录下使用rm -rf lib删除原有的lib目录
4、将下载好的文件使用命令tar -zxf 文件所在目录 -C hadoop安装目录解压到hadoop安装目录
5、重新启动hdfs进程，可以发现警告消失了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270854c4b4da1915a75a77a265bde857/" rel="bookmark">
			效率 | zotero和endnote互相导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自http://blog.sciencenet.cn/blog-41796-21812.html
仅仅导入文献标题 导入文献标题和PDF 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1f768c023c006022eda0f07fe3a4ec/" rel="bookmark">
			DHCP简介与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DHCP简介 1、什么是DHCP？
DHCP是一个自动分配IP地址的服务器，它可一避免IP冲突，提高IP地址的利用率。
2、DHCP原理
（1）客户端广播发送DHCP discover数据包，请求IP地址，这里的请求中还包含客户端的MAC地址。
（2）服务端响应DHCP offer包，发送一个IP地址，但是没有网关、DNS等参数。是以单播形式发送给客户端。
（3）客户端发送DHCP request广播包，确认使用这个IP地址。广播
（4）服务器发送DHCP ACK广播包，里面包含，网卡的详细参数，比如DNS、子网掩码、网关等。单播
（5）客户端发送DHCP request广播包，请求继续使用这个IP，这是在IP租约到50%时发送的。如服务器无响应，则会在87.5%时在发送一次请求，如还无响应，客户端就会释放这个IP地址。
3、什么是DHCP攻击？
DHCP是自动分配IP地址的，只要有人向它发送DHCP discover广播包，它就会从地址池中取出一个IP地址而不加验证给发送者，这就会使得黑客利用这一漏洞，不停的伪造MAC地址发送给DHCP服务器请求IP地址，直到地址池里的IP地址耗光，使得有的主机断网。防止这种攻击手段，可以在交换机端口绑定MAC地址。
还有就是黑客可以在自己的电脑中搭建DHCP服务器，只要有人发出请求DHCP discover广播包获取IP地址，如果黑客的DHCP服务器抢先收到客户端发出的请求，黑客的DHCP服务器就会把自己设置的IP地址发动给客户端，那么客户端就会优先接受这个IP地址。可以让DHCP服务端的端口发送offer广播包，其它主机的端口不允许发送此包。
当然也可以使用企业级交换机，因为我们平常用的是傻瓜式的交换机，没有企业级的交换机功能多。
4、在没有DHCP服务器或者是DHCP服务器无响应时，主机会自己分配一个169.254.x.x/16这个网段的IP地址，这时全球统一的无效IP地址，仅用于临时内网的通信。
二、DHCP部署
本实验是在vmwar虚拟机里部署的，使用的是一个win7和win2008R搭建的，这两个主机在同一个网段。还有就是在部署前还要把win2008r配置静态IP地址（在使用这一网段时请把VMware里自带的DHCP关掉，否者会造成实验失败。如果实验没成功也有可能是防火墙没关掉。）
1、这是win7的初始化界面，里面的IP地址是169.254.x.x/16网段的，前面已经讲过了，在这里我们可以看成是没有获取到IP地址的。
2、接下来我们在windows Server 2008 r里面安装DHCP服务器。打开服务管理器——角色——添加角色。
3、下一步。
4、选择DHCP服务器，下一步。
5、下一步。这里的IP地址就是我们在win2008r上设置的静态IP。
6、这里的父域是我随便设的，首选DNS服务器可以是运营商给你公司的，备用服务器可设可不设，最好设置。这里的首选与备选我选择的是电信的和谷歌的。下一步。
7、这里的WINS服务器已经过时了，可以选择不需要，但不排除一些公司使用这一服务器。下一步。
8、作用域里面的名称是我随便设的。起始地址与结束地址就是地址池，就是DHCP服务器从其抽出分配给主机的IP地址。在下面就是IP地址租约，这里我设置的是8天。
9、这里我选择的是禁用。因为是实验，用不到我就禁用了。下一不。
10、检查一下是否是你设置的信息，再点击安装。
11、安装成功。
12、打开DHCP服务器。
13、打开IPv4——作用域——地址池，可以看到我们设置的IP地址范围，
14、下一个是地址租用，也就是IP地址租期到期时间。
15、保留地址。
16、这里是设置的DNS和备用的DNS，还有DNS域名。
17、这里的筛选器是用来给主机是否分配IP地址的，可用可不用。
18、设置允许MAC为这个值的主机可以分配IP地址。这一步我就不做了。
19、拒绝与之相反，这一步我也不做了。
20、在win7运行以下命令，作用是释放IP。
21、重新获取IP，这就是我们在DHCP服务器地址池中获取的IP，这里的IP地址是我设置的保留地址，如果我在保留地址中不设置win7的MAC地址，就不会分配这个IP地址，而是从地址池中选取。
在20、21步中，当然也可以用其它方法。在网络共享中心——更改适配器设置——本地连接——右键禁用——右键启用，就可以刷新IP地址。
22、还有就是服务器备份，把服务器备份到移动介质里面，防止DHCP服务器崩溃没有备份。
23、还有就是可以建立多个作用域，分配多分网段，这就涉及到了DHCP中继技术。中继技术就是设立一个DHCP relay充当一个中间人，来保持客户端与服务器之间的通信。客户端与Relay之间是广播形式通信，DHCP服务器与Relay是单播形式通信。
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10442c2793aff996b5297be6f6894f31/" rel="bookmark">
			RAID技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、RAID技术概述 2、RAID数据组织形式
3、RAID数据保护方式
4、常用的RAID级别
4.1 RAID 0
RAID 0工作原理
RAID 0数据的存取
4.2 RAID 1
RAID 1工作原理
RAID 1数据的存取
4.3 RAID 3 RAID 3工作原理
RAID 3数据的存取
4.4 RAID 5
RAID 5工作原理
RAID 5数据的存取
4.5 RAID 6
RAID 6 P+Q的工作原理
RAID 6 DP工作原理
数据恢复
4.6 混合RAID
RAID 10
RAID 50
1、RAID技术概述 RAID（redundant array of independent disks）技术，独立磁盘冗余阵列，是提高磁盘可靠性和可用性的一种技术。RAID技术出现的初衷是把多个小容量的硬盘组合起来，以获得更大的存储容量。当前我们所说的RAID技术更多则是与数据保护相关，换言之，当物理设备失效时，RAID能够用来防止数据的丢失。
RAID技术的主要功能： 通过对硬盘上的数据进行条带化，实现对数据成块存取，减少硬盘的机械寻道时间，提高了数据存取速度。 通过对一阵列中的几块硬盘同时读取（并行访问），减少了硬盘的机械寻道时间，提高了数据存取速度。 通过镜像或者存储奇偶校验信息的方式，实现了对数据的冗余保护。
随着阵列技术的发展，已经产生了很多不同类型的RAID，但现在只有少数几种RAID仍在使用。选择不同的RAID类型意味着不同的性能/成本。 在存储设备中，可以通过2种方式实现RAID功能：硬件RAID和软件RAID。
硬件RAID使用专用的RAID适配器、硬盘控制器或存储处理器。RAID控制器有自己的处理器，I/O处理芯片，和内存，用来提高资源利用率和数据传输速度。RAID控制器管理路由、缓冲区，控制主机与RAID间数据流。硬件RAID通常在服务器中使用。软件实现的RAID没有它自己的处理器或I/O处理芯片，而是完全依赖于主机处理器。因此，低速CPU不能满足RAID实施的要求。软件RAID通常在企业级存储设备上使用。 总结来说，RAID技术的优势体现在如下几个方面：
把多个硬盘组合成一个逻辑盘组，以提供更大容量的存储。将数据分割成数据块，对多个硬盘并行进行写入/读出，提高硬盘访问速度。通过提供镜像或奇偶校验来提供容错。 2、RAID数据组织形式 条带（strip）：硬盘中单个或多个连续的扇区构成一个条带，它是一块硬盘上进一次数据读写的最小单元。它是组成分条的元素。
分条（stipe）：同一个硬盘阵列中，多个硬盘驱动器上的相同位置的条带（或者说相同编号）。
分条深度：一个条带的大小。
分条宽度：一个分条中，数据盘成员的个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10442c2793aff996b5297be6f6894f31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5aace0c4e732597693e030f01d2b0b6/" rel="bookmark">
			Linux云计算架构-SELinux安全子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux云计算架构-SELinux安全子系统1. selinux简介2. SELinux服务的配置模式3. SElinux域（开启或禁用某个功能）4. SELinux安全上下文（添加上下文，使得一般文件和目录文件支持某种服务） Linux云计算架构-SELinux安全子系统 1. selinux简介 Linux系统的双保险=SElinux域+SELinux安全上下文
SELinux域：对服务程序的功能进行限制，确保服务程序做不了出格的事。【限制使用的功能】SELinux安全上下文：确保文件资源只能被其所属服务程序进行访问。【限制功能的合理使用】
在使用SELinux安全子系统的时候，可以从限制资源使用的角度去理解问题，首先看有没有这个功能，其次是这个功能有没有正确的被使用。 2. SELinux服务的配置模式 selinux的配置模式
enforcing【强制启动安全策略模式，拦截服务的不合法请求】
permissive【若服务器越权访问，发出警告但不强制拦截】
disabled【对越权行为，不警告也不拦截】配置文件及命令
cat /etc/selinux/config 【查看selinux主配置文件的selinux的配置模式】【默认为：enforcing】【重启依然生效】
getenforce【获取当前的SELinux服务的运行模式】
setenforce 0 【临时修改SELinux服务的运行模式，0为禁用，1为启用】【禁用enforcing，即相当于启用permissive】【0为启用permissive，1为启用enforcing】【临时生效，重启失效】 一般SELinux安全子系统默认的配置模式是Enforcing
3. SElinux域（开启或禁用某个功能） 在这里先介绍布尔值的概念。布尔值是SELinux中功能的开关设置。可通过命令getsebool -a 找出系统中已设置的布尔值。
查询SELinux中所有与HTTP协议相关的安全策略(什么功能是允许的，什么功能是禁止的)【off为禁止，on为允许】【值为bool类型】
getsebool -a | grep httpd 【获取SELinux域的有关httpd服务程序的功能开启情况】启用或禁用SELinux域中关于某项服务的功能
setsebool -P httpd_enable_homedirs=on 【修改参数httpd_enable_homedirs，-P为修改后的SELinux策略规则永久生效，且立即生效】【-P参数一定要加】 4. SELinux安全上下文（添加上下文，使得一般文件和目录文件支持某种服务） 查看文件或者目录的SELinux安全上下文
-Z ：查看文件的SElinux安全上下文
-d ：查看的文件是目录文件
管理文件或者目录的SELinux安全上下文
①添加SELinux安全上下文(目录和目录下的所有文件都要添加)
semanage fcontext -a -t httpd_sys_content_t /home/wwwroot 【目录】
semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/* 【目录下所有文件】
②让SELinux安全上下文立即生效
restorecon -Rv /home/wwwroot/ 【-Rv参数对指定的目录进行递归操作，以及显示SELinux安全上下文的修改过程】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5aace0c4e732597693e030f01d2b0b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8974c4fb9a8df2c546bc735c3e7cf898/" rel="bookmark">
			Java——继承中this和super关键字的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Super的使用 super关键字的用法有三种：
【1】在子类的成员方法中，访问父类的成员变量；
【2】在子类的成员方法中，访问父类的成员方法；
【3】在子类的构造方法中，访问父类的构造方法。
代码举例 public class Fu { //父类成员变量 int num=10; //父类成员方法 public void method(){ System.out.println("父类成员方法！"); } //父类构造方法 public Fu(){ } } //子类 public class Zi extends Fu{ //子类成员变量 int num=20; //子类成员方法 public void methodZi(){ //【1】在子类的成员方法中，访问父类的成员变量； System.out.println(super.num); //父类当中的num } //子类成员方法 public void method(){ //【2】在子类的成员方法中，访问父类的成员方法； super.method(); System.out.println("子类成员方法！"); } public Zi(){ //【3】在子类的构造方法中，访问父类的构造方法 super(); } } 第三点补充说明：
在继承关系中，父子类构造方法的访问特点有如下三点：
1.子类构造方法中有一个默认隐含的"super();"调用，所以一定是先调用的父类构造，再执行的子类构造。
2.子类构造可以通过super关键字来调用父类重载构造。
3.super的父类构造调用，必须是子类构造方法的第一个语句。也就是说，不能一个子类构造调用多次super构造。
总结：子类必须调用父类构造方法，不写则赠送super()，写了则用写的指定super()调用，super只能有一个，还必须是第一个。
代码举例 public class Fu { //父类无参构造 public Fu(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8974c4fb9a8df2c546bc735c3e7cf898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dcd6a0cc4e526c8d047eac0c630204/" rel="bookmark">
			SQL Server是什么？SQL Server详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SQL Server数据库简介 SQL Server数据库是Microsoft开发设计的一个关系数据库智能管理系统(RDBMS)，现在是全世界主流数据库之一；
SQL Server数据库具备方便使用、可伸缩性好、相关软件集成程度高等优势，能够从单一的笔记本上运行或以高倍云服务器集群为基础，或在这两者之间任何东西上运行。尽管说成“任何东西”，可是依然要考虑有关的软件和硬件配置；
SQL Server应用集成化的商务智能(BI)专用工具提供了企业级的数据管理服务。Microsoft SQL Server数据库引擎为关系型数据和结构化数据提供了更可靠安全的存储功能，使用户能够搭建和管理用于业务流程的高可用性和性能卓越的程序。
SQL Server1.0在1989年公布，迄今SQL Server已变成一个企业级的信息化平台。SQL Server2014包含内嵌的商业智能专用工具，以及一系列的分析和报告工具，能够建立数据库、备份数据、拷贝，为数据安全提供了更强的保障。
更多 SQL Server 教程请见：树懒学堂_一站式数据知识平台_SQL Server 教程
二、SQL Server版本分类 SQL Server有下列三个版本：
1.商业版
考虑到保险费用开售，商业版的目地是向规模性大数据中心和数据库管理解决方法。数据管理和商务智能服务平台，提供企业级的高可用性和安全性。数据中心版的全部功能（它是包括在SQL Server的初期版本，但如今已不用）在SQL Server 2014商业版。
2.标准版
标准版的目的是为一些规模小的机构或单位的数据库提供数据管理服务和比较有限的商务智能运用。
3.商务智能版
主要针对那些需要商务智能和自助服务功能，而不需要完整的在线事务处理（OLTP）性能和可扩展性的企业。
三、SQL Server的优点和缺点： SQL Server 拥有众多优点，用以满足如今的商务环境，并根据不同的需求提供特定的数据库解决方案。它是一种运用普遍的数据库智能管理系统，具备很多明显的优势：
便捷性、合适分布式系统的可伸缩性、用以决策支持的数据服务、与很多别的服务器软件密不可分的集成性、优良的性价比等；除这点优势外，SQL Server更为用户的数据管理与分析提供了协调能力，容许企业在迅速转变的环境中快速响应，从而提高核心竞争力，获取竞争方面的优势；从数据管理和分析角度来看，将原始数据转化为商务智能和灵活运用Web产生的机遇十分关键。做为一个完善的数据库和数据统计分析包，SQL Server为快速开发新一代企业级商业应用程序、为公司提高核心竞争力打开了胜利之门；作为可伸缩性和速度方面测试中的记录保持者，SQLServer是具备完全web支持的数据库系统，提供了了对可拓展编译语言(XML)的核心支持及其在Internet上和服务器防火墙外进行查询的能力。 SQLServer尽管优势诸多，可是它和别的数据库相比也存在一些不足：
开放性不够好：只有运行在windows平台才能获得最大的性能支撑，可以说是没有丝毫的开放性可言；此外，SQL Server的并行处理执行和共存模型并不成熟，难以解决日渐增加的用户量和数据信息，伸缩性比较有限，和同类数据库比缺点显著；最后，因为SQLServer彻底重写了SQL语言的底层编码，经历了长期性的检测，不断延迟，很多功能需要时间来证明，并不十分适配早期的产品，在应用上存在一定风险性。 原文出自：https://www.shulanxt.com/doc/dbdoc/sqlserver-what
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06b17d3b5fa2c6c56ed519e8016a41f/" rel="bookmark">
			人工智能-windows环境安装配置部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载Anaconda安装成功后
测试是否安装成功conda activate
图片: https://uploader.shimo.im/f/SLKMyM75Ptg9y0GG.png
创建虚拟环境
conda create -n tf1 python3.7
conda activate tf1
conda deactivate tf1
安装opencv 不可颠倒
图片: https://uploader.shimo.im/f/j1LVKSFOqMwSzCRD.png
pip install opencv-python3.4.2.16 -i “https://pypi.doubanio.com/simple/”
pip install opencv-contrib-python==3.4.2.16 -i “https://pypi.doubanio.com/simple/”
测试opencv
图片: https://uploader.shimo.im/f/5mtIxBAoxDAlHJra.png
安装 tensorflow 首先需要先安装cuda cudnn
pip install -i https://pypi.mirrors.ustc.edu.cn/simple/ tensorflow-gpu1.14
测试tensorflow
图片: https://uploader.shimo.im/f/E82ibieSOY4fm5M4.png
安装cpu版本的
pip install tensorflow1.14 -i https://pypi.douban.com/simple
打开notebook
jupyter notebook
图片: https://uploader.shimo.im/f/Yj8tbDMCUAM8bW6h.png
done
(tf1) C:\Users\86176&gt;conda list
packages in environment at D:\ProgramData\Anaconda3\envs\tf1: Name Version Build Channel _py-xgboost-mutex 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06b17d3b5fa2c6c56ed519e8016a41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5975505c04690e9fdac05f2660317e5/" rel="bookmark">
			java中ByteBuffer和String相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java提供了缓冲类，在很多编解码和网络请求中会用到，其中ByteBuffer和String类型可以互相转换，代码如下：
Charset charset = StandardCharsets.UTF_8; String str = "Hello world"; ByteBuffer buffer = ByteBuffer.allocate(1024); //	将字符串转成ByteBuffer buffer.put(str.getBytes(StandardCharsets.UTF_8)); //	将ByteBuffer转成字符串1 buffer.flip(); String s = charset.decode(buffer).toString(); System.out.println(s); //	将ByteBuffer转成字符串2 buffer.flip(); String s1 = new String(buffer.array(), buffer.position(), buffer.limit(), StandardCharsets.UTF_8); System.out.println(s1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457a78cff72b9bfd0d1e8e504d681487/" rel="bookmark">
			Evernote（印象笔记） 如何迁移到语雀？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先，打开印象笔记，选中你要导出的笔记 2. 点击文件-导出 3. 选择导出为单个HTML网页，点击导出，选择导出的文件的位置 4. 将导出的文件压缩 5.打开语雀，新建一个笔记，将文件导入 6.找到印象笔记，找到自己的压缩包 ，点击导入，就可完成啦！！！ 7.开启你的语雀之旅吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ce4d2bb62b980396dc5b37cb8273ea/" rel="bookmark">
			SSC展频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何谓SSC： 展频spread spectrum(SSC)，所有会产生频率信号的电子组件都是潜在的电磁干扰（ EMI ）源,这些信号将会影响如收音机、电视或者移动电话等电子产品的正常运作。SSC让时钟慢慢地一点点地变化来分散输出时钟的能量。其原理类似于图1 所示的例子，让水压（频谱能量）一定的水从一个小孔（固定频率）中喷出，这和让它从淋浴喷头的多个小孔（分散频率）中喷出的效果是不同的。后者的水压得到了分散，水的喷出力度（辐射噪声）会变小很多。
SSC不仅对时钟振荡频率（基波）有抑制作用，对高次谐波的峰值也有抑制作用。图2所示为SSCG输出的基波和高次谐波的频谱波形
展频设计： 1、添加SSCG器件
添加SSCG IC器件实现对时钟频率的理想控制，可以取得很好的 EMI 抑制效果
2、软件实现
有些CPU的clock寄存器提供了SSC展频的控制功能，通过软件对寄存器的操作来实现SSC功能，同样可以达到展频的效果。本文主要采用软件实现SSC功能。
首先看一下A7 datasheet中关于Clock的介绍：
SYS3_SSCPLL支持SSC功能，找到寄存器，默认情况下SSC功能是关闭的，打开SSC需要设置SSCPLL寄存器：
poky/sources/u-boot/board/csr/atlas7cb/clock.c在Uboot的Clock.c文件中打开USE_SSC_RAM宏定义：
重新编译Uboot，并烧写到车机中，即可实现展频功能：
devmem 0x18620084
可以发现0x18620084（CLKC_SYS3_SSCPLL_AB_SSRAM_DATA）寄存器的值不再是固定值，用示波器测量可以看出展频的效果。
实际案例分享： 图 6 是默认关闭SSC EMC实验图，图7是打开SSC功能测试的EMC实验图
图 6 SSC OFF EMC实验图
图 7 SSC ON EMC实验图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76e4cabb935cbe58e386b7a982dcc0b/" rel="bookmark">
			如何在 Windows 中检测、启用和禁用 SMBv1、SMBv2 和 SMBv3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文介绍如何在 SMB 客户端和服务器组件上启用和禁用服务器消息块（SMB）版本1（SMBv1）、SMB 版本2（SMBv2）和 SMB 版本3（SMBv3）。 重要
建议你不要禁用 SMBv2或 SMBv3。 仅将 SMBv2 或 SMBv3 作为临时故障排除度量值禁用。 不要让 SMBv2 或 SMBv3 处于禁用状态。
在 Windows 7 和 Windows Server 2008 R2 中，禁用 SMBv2 将停用以下功能：
在 Windows 8、Windows 8.1、Windows 10、Windows Server 2012、Windows Server 2012 R2、Windows Server 2016 和 Windows Server 2019 中，禁用 SMBv3 将停用以下功能（以及前面的列表中所述的 SMBv2 功能）：
更多信息 Windows Vista 和 Windows Server 2008 中引入了 SMBv2 协议。
Windows 8 和 Windows Server 2012 中引入了 SMBv3 协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76e4cabb935cbe58e386b7a982dcc0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cfcdc6983aaf6e7b287946560d18dc3/" rel="bookmark">
			the “ssl“ directive is deprecated, use the “listen ... ssl“ directive instead in /etc/nginx/nginx.co
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.报错信息
nginx: [warn] the “ssl” directive is deprecated, use the “listen … ssl” directive instead in /etc/nginx/nginx.conf:46
ssl不建议作为一个指令使用，而只是listen指令的一个参数
解决方法
如果使用listen 443 ssl,删除ssl on就行了。
改成
server { listen 443 ssl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686e8043416468ebb7dbc27f5605bd18/" rel="bookmark">
			vue动态绑定v-model属性名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目标 首先配置列，根据配置渲染表单，每个表单项绑定配置中的属性
2.方案 &lt;template v-for="(item) in showQueryColumns" &gt; &lt;el-col :key="item.prop" :xs = "24" :sm = "12" :md="12" :lg = "12" :xl = "6"&gt; &lt;!--字符串类型--&gt; &lt;el-form-item v-if="item.type==='string'" :label="$t(item.i18n)" :prop="item.prop"&gt; &lt;el-input v-model="form[item.prop]" clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/template&gt; v-model绑定的必须是属性，可以使用方括号，取指定对象的属性 亲测有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df3c0feac168de85f48c34d742778d9/" rel="bookmark">
			Java中，String类字符串拼接 用concat方法 和直接用“&#43;”连接符拼接的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在String类中，字符串拼接既可以使用concat方法，也可以直接用连接符进行连接，那么两者有什么相同点和不同点呢，下面小编带大家通过代码一起来看一下。
concat方法的使用：public String concat(String str):将当前字符串和参数字符串拼接成为返回值新的字符串。
也就是说，concat可以将参数列表当中的字符串与当前字符串进行拼接，返回值为一个新的字符串。
“+”连接符的用法：它的非常简单，直接使用连接就可以了。
下面通过代码来看一下他们的相同点和区别。
public class Demo10String { public static void main(String[] args) { //拼接字符串相同点 String str1="Hello"; String str2="World"; String str3=str1.concat(str2); String str4=str1+str2; System.out.println(str3); //输出：HelloWorld System.out.println(str4); //输出：HelloWorld //不同点 String str="Hello" + 5; //输出：Hello5 System.out.println(str); } 通过上面代码我们可以看出：
相同点1：concat方法 和直接用“+”连接符拼接都可以对两个字符串进行拼接。
相同点2：两种拼接方法都会重新形成一个新的字符串，这是因为字符串的内容永远不可变，所以拼接一定会形成一个新的字符串。
不同点：concat只能连接两个字符串；但是"+"连接符可以将字符串与非字符串类型拼接到一起（注意：只要两个当中有一个是字符串类型，用"+"连接符就会拼接成一个新的字符串）。
除此之外，当我们生成一个class文件，再进行反编译的时候，通过concat源码可以发现，用连接符进行连接，StringBuilder创建了更多的对象，而concat却没有，它使用的String类的内部实现。
总结：当进行两个字符串连接的时候，我们应该优先考虑用concat()函数。
当需要连接字符串和其他非字符串类型的变量的时候，cancat无法满足需求，我们就要优先考虑使用“+”连接运算符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a48122538b616f1413fb2aeec0468b0/" rel="bookmark">
			java  接口 interface  内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口 interface 接口相当于特殊的抽象类，定义方式。组成部分都与抽象类相似 但接口不是类 接口只能定义公开静态常量，公开抽象方法 ( public static final abstract ) 关键字可以省去，但依旧是公开的 静态的 最终的 抽象的 接口中不写变量 阿里规范
与抽象类的异同： 同： 可编译成字节码文件不能创建对象可以作为引用类型具备Object类中定义的方法 不同： 所有属性都是公开的静态常量，隐式使用 public static final 修饰所有方法都是公开抽象方法，隐式使用public abstract 修饰没有构造方法，动态代码块，静态代码块。 接口微观概念：接口是一种能力和约定。 接口的定义：代表了某种能力 方法的定义： 能力的具体要求 java为单继承，当父类的方法种类无法满足子类需求时，可实现接口扩充子类的能力
接口支持多实现，可以为类扩充多种能力 implements 接口1，接口2,…
接口也可以继承接口，
类与类是单继承，接口与接口可以多继承
标识接口：Serializable序列化（实现对文件的持久化操作） cloneable克隆 接口中是空的，只是一个标识
内部类： 内部类：在一个类内部在定义一个完整的类 特点： ​ 内部类在编译为.class文件时，文件名会有$符号，代表。的内部类。
​ 内部类可以直接访问外部类的私有成员，而不破坏封装
​ 可为外部类提供必要的内部功能组件
成员内部类 在类的内部定义，与实例变量，实例方法同级别的类
当外部类，内部类存在重名属性时，会优先访问内部类属性
成员内部类不能定义静态成员,但可以定义静态常量
创建成员内部类的对象，必需依赖外部类对象
public class Out { public static void main(String[] args) { // Inner inner = new Out().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a48122538b616f1413fb2aeec0468b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce7b4e3401523e3f58e8b4fb9de0a05/" rel="bookmark">
			二维张量 乘以 三维张量_通量vs张量流误解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维张量 乘以 三维张量
TensorFlow is the 800-pound Gorilla of Machine Learning that almost everybody in the field have heard about and have some familiarity with. But there is a tiny uppity little upstart called Flux which is kicking ass and taking names, causing it to grab some attention. Yet it is still a very misunderstood machine learning library.
TensorFlow是重达800磅的机器学习大猩猩，该领域的几乎每个人都听说过并熟悉。 但是，有一个小小的新贵，叫做Flux ，它正在踢屁股并取名，从而引起了人们的注意。 但是，它仍然是一个非常容易被误解的机器学习库。 Emmett Boudreau is fellow Julia fan here on medium has written a number of articles on the topic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce7b4e3401523e3f58e8b4fb9de0a05/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/370/">«</a>
	<span class="pagination__item pagination__item--current">371/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/372/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>