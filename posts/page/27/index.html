<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881e0e00e406c16bc31215440d038ad2/" rel="bookmark">
			数据结构从入门到精通——树和二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树和二叉树 前言一、树概念及结构1.1树的概念1.2 树的相关概念（重要）1.3 树的表示1.4 树在实际中的运用（表示文件系统的目录树结构） 二、二叉树概念及结构2.1二叉树概念2.2现实中的二叉树2.3 特殊的二叉树2.4 二叉树的性质2.5 二叉树的存储结构 三、树和二叉树的练习题答案 前言 树和二叉树是计算机科学中常用的数据结构，它们在数据存储、搜索、排序等多个领域都有着广泛的应用。从简单的二叉树出发，我们可以逐步理解更复杂的树结构，如红黑树、AVL树等。
二叉树是一种每个节点最多有两个子节点的树结构，通常子节点被称为“左子节点”和“右子节点”。这种结构使得二叉树在编程中非常易于实现和操作。例如，我们可以使用数组或链表来存储二叉树，并通过递归算法来实现遍历、查找和插入等操作。
然而，二叉树并不是唯一的树结构。在实际应用中，我们可能需要处理更复杂的树形结构，如多叉树和森林等。多叉树是指每个节点可以有多个子节点的树结构，而森林则是由多个不相交的树组成的集合。这些树形结构在处理实际问题时，往往能够提供更好的解决方案。
除了上述的树形结构外，还有一些特殊的树形结构，如堆、并查集、字典树等。堆是一种特殊的完全二叉树，它可以用于实现优先队列等数据结构；并查集则是一种用于处理不相交集合合并及查询问题的数据结构；字典树则是一种用于快速查找字符串的数据结构。
总的来说，树形结构是一种非常有用的数据结构，它们在计算机科学中扮演着重要的角色。通过深入理解树和二叉树的基本原理和应用场景，我们可以更好地应用它们来解决实际问题，提高程序的效率和可靠性。因此，对于学习计算机科学的人来说，掌握树形结构是非常重要的。
一、树概念及结构 1.1树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点，除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继因此，树是递归定义的。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构
1.2 树的相关概念（重要） 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G…等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；这只是一般的认知，有些书上也会将第一层看作0，具体按题目来分析。一般题目不说都是按1来看
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3 树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/881e0e00e406c16bc31215440d038ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4b8261e1f3039fa802904c43866f0e/" rel="bookmark">
			WRF模型运行教程（ububtu系统）--I.模型运行前准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改namelist.wps文件 这个文件记录了各类WPS运行的基本参数，具体含义这里不做详细介绍，然后等之后有机会大家慢慢探索，但是为了后面测试成功，这里需要大家粗暴的修改该文件。
文件位置：\Build_WRF\WPS\namelist.wps
用记事本打开后，用以下代码覆盖原来的所有内容。
&amp;share wrf_core = 'ARW', max_dom = 1, start_date = '2021-10-15_00:00:00','2006-08-16_12:00:00', end_date = '2021-10-17_18:00:00','2006-08-16_12:00:00', interval_seconds = 21600 io_form_geogrid = 2, / &amp;geogrid parent_id = 1, 1, parent_grid_ratio = 1, 3, i_parent_start = 1, 31, j_parent_start = 1, 17, e_we = 74, 112, e_sn = 61, 97, ! !!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!! ! The default datasets used to produce the MAXSNOALB and ALBEDO12M ! fields have changed in WPS v4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4b8261e1f3039fa802904c43866f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938db57b8d221d08853f16e66123f48a/" rel="bookmark">
			CSS常见选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS常见选择器包括标签选择器、类选择器、ID选择器、属性选择器、伪类选择器等。每种选择器都有其特定的用途和应用场景。以下是一些常见选择器的应用案例：
标签选择器： 应用案例：将所有段落文本的颜色设置为蓝色。 css复制代码
p { color: blue; }在这个例子中，p 是标签选择器，它选择了页面上的所有 &lt;p&gt; 元素，并将它们的文本颜色设置为蓝色。类选择器： 应用案例：给具有特定类的元素应用样式。 css复制代码
.highlight { background-color: yellow; } html复制代码
&lt;p class="highlight"&gt;这段文字会有黄色背景。&lt;/p&gt;在这个例子中，.highlight 是类选择器，它选择了所有带有 class="highlight" 的元素，并将它们的背景颜色设置为黄色。ID选择器： 应用案例：为具有唯一ID的元素设置特定样式。 css复制代码
#unique-element { font-size: 20px; } html复制代码
&lt;div id="unique-element"&gt;这个元素有特定的字体大小。&lt;/div&gt;ID选择器 #unique-element 选择了具有 id="unique-element" 的元素，并设置了其字体大小。属性选择器： 应用案例：选择具有特定属性的元素。 css复制代码
a[target="_blank"] { background-color: lightgray; }这个选择器选择了所有 target 属性值为 _blank 的 &lt;a&gt; 元素，并将它们的背景颜色设置为浅灰色。这通常用于标识那些在新窗口或标签页中打开的链接。伪类选择器： 应用案例：选择元素的特定状态。 css复制代码
a:hover { color: red; }伪类选择器 :hover 选择了鼠标悬停时的 &lt;a&gt; 元素，并将它们的文本颜色设置为红色。这常用于实现鼠标悬停效果。子元素选择器： 应用案例：选择特定父元素的直接子元素。 css复制代码
div &gt; p { color: green; }这个选择器选择了所有作为 &lt;div&gt; 元素直接子元素的 &lt;p&gt; 元素，并将它们的文本颜色设置为绿色。相邻兄弟选择器： 应用案例：选择紧接在另一元素后的兄弟元素。 css复制代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938db57b8d221d08853f16e66123f48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a7dbbc215eb75744a103cb4a4b4ca0/" rel="bookmark">
			Node.js 中的事件循环（Event Loop）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js 中的事件循环（Event Loop）是一个非常重要的概念，它是 Node.js 实现非阻塞 I/O
操作的核心机制。在这篇教程中，我将详细解释事件循环的工作原理以及如何利用它来构建高效的 Node.js 应用程序。
什么是事件循环？ 事件循环是 Node.js 运行时环境中的一个重要组成部分，它负责处理异步操作和回调函数。Node.js 是单线程的，但通过事件循环，它能够实现非阻塞的 I/O 操作，从而提高应用程序的性能和吞吐量。
事件循环的工作原理 事件循环由不同阶段组成，每个阶段执行特定的任务。当 Node.js 启动时，事件循环进入第一个阶段，然后按顺序执行每个阶段的任务，直到所有阶段都执行完毕。然后事件循环再次从头开始执行，实现持续的事件处理。
事件循环的几个阶段包括：
Timers 阶段：处理定时器的回调函数。Pending callbacks 阶段：处理系统级的回调函数。Idle, prepare 阶段：准备阶段，一般不需要关注。Poll 阶段：处理 I/O 事件。Check 阶段：执行 setImmediate 回调函数。Close callbacks 阶段：处理 close 事件的回调函数。 示例代码 让我们来看一个简单的示例代码，演示事件循环的工作原理：
console.log('Start'); setTimeout(() =&gt; { console.log('Timer callback'); }, 0); setImmediate(() =&gt; { console.log('Immediate callback'); }); process.nextTick(() =&gt; { console.log('Next tick callback'); }); console.log('End'); 在这段代码中，我们使用了 setTimeout、setImmediate 和 process.nextTick 来演示事件循环的不同阶段。运行这段代码后，你会看到输出结果可能与你的预期有些不同，这是因为事件循环的执行顺序并不总是按照代码书写顺序来执行。
总结 通过本教程，我们了解了 Node.js 中事件循环的工作原理以及各个阶段的作用。理解事件循环是构建高效 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a7dbbc215eb75744a103cb4a4b4ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3219d6c14ac93eac28422e05d1d99ac6/" rel="bookmark">
			【RabbitMQ】【Docker】基于docker-compose构建rabbitmq容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过docker-compose构建一个单体的rabbtimq容器。
1，docker、docker-compose环境 首先需要有docker和docker-compose环境，docker安装[1]，docker-compose安装[2]。
通过下列命令确定docker、docker-compose是否安装成功。
[root@192 gengzhihao]# docker version Client: Docker Engine - Community Version: 25.0.3 API version: 1.44 Go version: go1.21.6 Git commit: 4debf41 Built: Tue Feb 6 21:17:10 2024 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 25.0.3 API version: 1.44 (minimum version 1.24) Go version: go1.21.6 Git commit: f417435 Built: Tue Feb 6 21:16:08 2024 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.28 GitCommit: ae07eda36dd25f8a1b98dfbf587313b99c0190bb runc: Version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3219d6c14ac93eac28422e05d1d99ac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b4c6009ed09e37b93d3db295390b04/" rel="bookmark">
			前端面试 ===＞ 【Vue2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2 相关面试题总结 1. 谈谈对Vue的理解 Vue是一种用于构建用户页面的渐进式JavaScript框架，也是一个创建SPA单页面应用的Web应用框架，Vue的核心是 数据驱动试图，通过组件内特定的方法实现视图和模型的交互；特性：（看自己要不要对每一项特性进行解释，如果解释可能会牵扯出很多面试题） 数据驱动试图： MVVM是一种双向数据绑定的模式，用ViewModel来建立起Model数据层和View视图层的连接，数据和视图的改变是双向的；可能会问：MVVM 和 MVC 的区别？(见4)； 组件开发： 组件可以在项目中直接进行复用，出现问题时可以实现快速定位，能够提高代码可复用性和可维护性。可能会问：如何封装一个组件？（见后面） 指令系统： Vue内置很多 v- 系列的指令，可以响应式的作用于DOM，比如v-if条件渲染，v-for列表渲染，v-model双向数据绑定等。可能会问：自定义封装指令的一些知识（见后面） 缺点： 不利于SEO优化： 解决办法： SSR服务器渲染；静态化；预渲染；骨架屏； 首屏加载速度慢：加载时，将所有的css，js文件都进行加载；不支持IE678（IE也不用了😂）；有些数据不需要响应式，但必须写在data里，影响加载速度和性能；Vue的响应式是通过Object.defineProperty: 无法监听ES6的Set、Map变化；无法监听Class类型的数据；属性的新加或删除无法监听；数组元素的增加和删除无法监听； 2. Vue最大优势 是一款轻量级框架，简单易学，数据双向绑定，虚拟DOM，组件化，数据和结构相分离，运行速度快等等；文档都是中文的，入门教程很多，上手简单；Vue是单页面应用，使页面局部刷新，不用每次跳转页面都去请求所有的数据和DOM，加快了访问速度和提升用户体验；相比传统的页面通过超链接实现页面的切换和跳转，Vue使用路由，不会刷新页面；第三方UI库使用起来非常方便，节省了很多开发时间，从而提升了开发效率。 3. Vue 和 jQuery 的区别是什么？ jQuery： 应该算是一个插件，里面封装了各种简单易用的方法，它的本质就是使用更少的代码操作DOM节点，它是使用选择器获取DOM对象，对其进行赋值、取值、事件绑定等操作，对数据的操作依赖于对应的DOM对象； Vue： 一套渐进式的框架，拥有自己的规则体系和语法，特别是MVVM的设计思想，让数据和视图进行双向绑定，极少操作DOM，对数据进行操作不再依赖于对应的DOM对象。 4. MVVM 和 MVC 区别是什么？ MVC： 一种设计模式，是Model数据模型，View视图，Controller控制器，在控制器这层里面编写代码，控制数据和视图进行关联，MVC是单向通信； MVVM： 既Model-View-ViewModel的简写（模型-视图-视图模型），VM是整个设计模式的核心，是用来连接视图和模型的桥梁；模型：指的是后端传递的数据；视图：指的是所看到的页面；有两个方向： 首先：模型转换为视图，将从后端请求回来的数据转换为网页； 实现方式：数据绑定； 其次，视图转换为模型，将网页转化为后端的数据； 实现方式：监听DOM事件。 这两个方向都实现的，我们称为数据的双向绑定。 区别： MVC是单向通信，MVVM是双向通信；主要是MVC中的Controller演变成了MVVM中的VM，MVVM主要解决了MVC中大量的DOM操作导致的页面渲染性能降低，加载速度慢，影响用户体验。 5. Vue常用修饰符 事件修饰符： .stop =&gt; 阻止事件冒泡 .prevent =&gt; 阻止事件默认行为 .once =&gt; 程序运行期间，事件处理函数只执行一次 .native =&gt; 原生事件（使用组件库的时候可能会用到） 按键修饰符： .enter ➡ 监测Enter键 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b4c6009ed09e37b93d3db295390b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5a33300e8ade4bec218d348d1fb341/" rel="bookmark">
			Css基础——绘制三角形、鼠标样式、轮廓线、放拖拽文本域、vertical-align属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、三角形的绘制方法 当一个盒子的width和height都为0时
四个边框都有颜色时，可以显示出三角形来
当其中的三边都是透明（transparent）的时候，就可以看到一个小三角形
2、鼠标样式（cursor） 代码部分：
html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="./css/style.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;p style="cursor: default;"&gt;迪幻迪幻迪幻迪幻迪幻&lt;/p&gt; &lt;p style="cursor: pointer;"&gt;迪幻迪幻迪幻迪幻迪幻&lt;/p&gt; &lt;p style="cursor: move;"&gt;迪幻迪幻迪幻迪幻迪幻&lt;/p&gt; &lt;p style="cursor: text;"&gt;迪幻迪幻迪幻迪幻迪幻&lt;/p&gt; &lt;p style="cursor: not-allowed;"&gt;迪幻迪幻迪幻迪幻迪幻&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3、轮廓线 outline 一般情况下，我们选中文本框时，文本框外面的边框会变粗或者有着蓝色的描边
这样是不利于我们的界面的美观的，所以我们可以通过设置outline: none来取消这个特效
这样，我们的边框特效就取消了
代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .inp { outline: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a5a33300e8ade4bec218d348d1fb341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e485414c965216b93525d1fccc6d2344/" rel="bookmark">
			代码随想录算法训练营day58|第十章 单调栈part01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
739. 每日温度 496.下一个更大元素 I 739. 每日温度 今天正式开始单调栈，这是单调栈一篇扫盲题目，也是经典题。大家可以读题，思考暴力的解法，然后在看单调栈的解法。 就能感受出单调栈的巧妙
代码随想录
通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。
单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。单调递增指的是栈顶到栈底的方向上是单调递增的，如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。
如图所示，一旦遍历到的元素大于栈顶元素，那就没办法维持顺序（从栈顶到栈底单调递增了），所以想要放入当前元素，需要将栈顶元素弹出，直到栈顶元素再也不小于当前遍历到的元素为止或栈为空，每弹出一个元素，在这道题中就相当于找到了之后比它温度大的一天，于是就要同步更新res数组记录二者的距离，这时候就凸现出单调栈存入下标的必要性了，这样可以直接操作对应下标的res值，等于当前遍历到的元素下标减去弹出的下标。
vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { stack&lt;int&gt; st; // 递增栈 vector&lt;int&gt; result(T.size(), 0); for (int i = 0; i &lt; T.size(); i++) { while (!st.empty() &amp;&amp; T[i] &gt; T[st.top()]) { // 注意栈不能为空 result[st.top()] = i - st.top(); st.pop(); } st.push(i); } return result; } 文章中说这种做法更能体现实质，但是我觉得实际上是有些麻烦的，只要搞清楚要维护单调栈单调递增的逻辑即可，单调递增所以必然遇到大于顶部元素的情况才会处理。
vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { // 递增栈 stack&lt;int&gt; st; vector&lt;int&gt; result(T.size(), 0); st.push(0); for (int i = 1; i &lt; T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e485414c965216b93525d1fccc6d2344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b07ac3ec001665bd9a50622a2ca2de/" rel="bookmark">
			基础小白快速入门opencv-------C&#43;&#43; 在opencv的应用以及opencv的下载配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啥是opencv？ OpenCV（开源计算机视觉库 Open Source Computer Vision Library）是一个跨平台的计算机视觉库，最初由Intel开发，现在由一个跨国团队维护。它免费提供给学术和商业用途，并且是用C++语言写成的，这使得它的运行速度非常快。同时，它也提供了Python、Java等语言的接口。
OpenCV拥有包括700多个算法和函数组成的强大库，用于处理图片和视频文件，包括但不限于图像处理、视频捕捉、对象识别、面部识别、机器学习等。由于其强大的功能和开放源代码的特性，OpenCV被广泛应用于学术研究、政府项目、商业产品中，特别是在人脸识别、车辆检测、机器人视觉、移动设备上的应用十分广泛。
OpenCV遵循BSD许可协议，这是一种非常灵活的开源协议，允许用户使用、修改和分发这个库，同时也保护了原作者的权益。这使得OpenCV能够被广泛地应用在商业产品和研究项目中，促进了计算机视觉技术的发展和普及。
opencv的下载 opencv官网：OpenCV - Open Computer Vision Library
但是，由于种种原因，opencv官网下载往往会比较慢，甚至是失败
这里推荐国内镜像网站下载
命令行下载：
阿里云 http://mirrors.aliyun.com/pypi/simple/
豆瓣(douban) http://pypi.douban.com/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
这里可以用命令行下载
pip install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple/ 然后等待下载成功
或者请登录华军软件园
搜索opencv进行下载
然后选择相应的目录安装
在配置path环境变量
点击环境变量
点击path 点击编辑 添加opencv路径
然后完成
打开visual studio 新建项目
新建c++空项目
选择路径 给文件放置荻港
点击源文件创建main文文件
点击项目 选择属性
点击vc++目录， 配置包含目录以及库目录
点击包含目录，点击编辑，添加路径
添加build路径下的include
bulid路径下的include的opencv
bulid路径下的include的opencv2
然后点击编辑，添加路径
build路径下的电脑32位选择X86 64位选择x64
底下的lib 点击完成
然后
点击链接器
点击输入，添加依赖
依赖是lib库里面的 需要哪个用哪个 这样就配置完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f7f90ce72b15b91792396f681dea1e/" rel="bookmark">
			【OJ】K 个一组翻转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
基本思路：用计数+栈实现分段，K个一组地翻转链表。
#include &lt;bits/stdc++.h&gt; #include &lt;stack&gt; using namespace std; struct list_node { int val; struct list_node *next; }; list_node *input_list() { int val, n; scanf("%d", &amp;n); list_node *phead = new list_node(); list_node *cur_pnode = phead; for (int i = 1; i &lt;= n; ++i) { scanf("%d", &amp;val); if (i == 1) { cur_pnode-&gt;val = val; cur_pnode-&gt;next = NULL; } else { list_node *new_pnode = new list_node(); new_pnode-&gt;val = val; new_pnode-&gt;next = NULL; cur_pnode-&gt;next = new_pnode; cur_pnode = new_pnode; } } return phead; } list_node *reverse_knode(list_node *head1, int K) { if (K &lt; 2 || !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f7f90ce72b15b91792396f681dea1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6208e4eb941cd7e56cdd05734aa65e0e/" rel="bookmark">
			【OJ】猫狗队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猫狗队列 思路 用两个队列分别保存猫、狗，用各个的入队计数判断任一出队时选择哪一种，指定类别出队则直接从相应队列出队。
实现Python 输入测试testCatDogQ.txt
65 add dog 29 add cat 9 add dog 40 add dog 38 add cat 32 add dog 20 add cat 45 pollAll add cat 37 isDogEmpty add cat 23 isCatEmpty add dog 1 pollCat pollDog add cat 22 add dog 39 pollCat add cat 31 add cat 2 add dog 12 add cat 35 add dog 30 add dog 27 add dog 14 add cat 18 isDogEmpty add cat 3 add dog 21 add dog 16 isCatEmpty add cat 13 isDogEmpty add dog 46 add dog 44 isCatEmpty add dog 10 isDogEmpty isEmpty add dog 42 isDogEmpty pollAll isCatEmpty add dog 4 add dog 6 add dog 15 isDogEmpty pollAll isEmpty add cat 26 add dog 17 add cat 5 add dog 41 add cat 7 add dog 28 add dog 8 add dog 11 add dog 24 add dog 34 isEmpty add cat 25 add dog 19 add dog 33 add dog 36 add cat 43 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6208e4eb941cd7e56cdd05734aa65e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023c6558fefdcf01d81fee130bf4cce2/" rel="bookmark">
			Lua 如何在Lua中调用C/C&#43;&#43;函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua调用C函数有两种方式
程序主体在C中运行，C函数注册到Lua中。C调用Lua，Lua调用C注册的函数，C或者Lua得到函数的执行结果。程序主体在Lua中运行，C函数作为库函数供Lua使用。 C++的代码如下 如何在Lua脚本中调用这个C语言函数(add_function)？
#include &lt;QCoreApplication&gt; #include &lt;stdio.h&gt; extern "C"{ #include "lua.h" #include "lauxlib.h" #include "lualib.h" } /* C语言函数 */ int add_function(lua_State* L) { /* 从Lua栈中获取参数 */ double x = luaL_checknumber(L, 1); double y = luaL_checknumber(L, 2); /* 执行函数操作 */ double z = x + y; /* 将结果压入Lua栈中 */ lua_pushnumber(L, z); /* 返回结果数量 */ return 1; } lua_State *L; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); printf("started\r\n"); L = luaL_newstate();//新建lua解释器 luaL_openlibs(L);//载入lua基础库 #if 1 /* 将add_function函数绑定到Lua中的call_add_function函数，这样就可以在Lua脚本中调用这个C语言函数了 */ lua_register(L, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/023c6558fefdcf01d81fee130bf4cce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54dec6d0e5b7b7826088fecec59f1ad2/" rel="bookmark">
			Ubuntu 14.04：PaddleOCR基于PaddleHub Serving的服务部署（失败）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、为什么使用一键服务部署
二、安装 paddlehub 1.8
2.1 安装前的环境准备
2.2 安装paddlehub 1.8 2.2.1 安装paddlehub
2.2.2 检测安装是否成功
2.2.3 检查本地与远端PaddleHub-Server的连接状态
2.2.4 测试使用
2.3 其他
2.3.1 如何卸载、pip常用命令、常见问题
2.3.2 PaddleHub命令行工具
三、基于PaddleHub Serving的服务部署（失败）
异常：ImportError: dlopen: cannot load any more object with static TLS
一、为什么使用一键服务部署 使用PaddleHub能够快速进行模型预测，但开发者常面临本地预测过程迁移线上的需求。无论是对外开放服务端口，还是在局域网中搭建预测服务，都需要PaddleHub具有快速部署模型预测服务的能力。在这个背景下，模型一键服务部署工具——PaddleHub Serving应运而生。开发者通过一行命令即可快速启动一个模型预测在线服务，而无需关注网络框架选择和实现。
二、安装 paddlehub 1.8 2.1 安装前的环境准备 https://github.com/PaddlePaddle/PaddleHub/blob/release/v1.8/docs/installation.md
（1）安装python 3.8 具体安装方法请参见 【ubuntu】安装 Anaconda3-CSDN博客
（2）安装paddlepaddle 2.0.0
具体安装方法请参见 Ubuntu 14.04：安装PaddlePaddle（Conda安装）-CSDN博客 （3）安装PaddleOCR 2.3
具体安装方法请参见 Ubuntu 14.04：安装 PaddleOCR 2.3-CSDN博客
2.2 安装paddlehub 1.8 参考资料：
https://github.com/PaddlePaddle/PaddleHub/blob/release/v1.8/docs/install.md
2.2.1 安装paddlehub 注：此处需要进入paddlepaddle所在的Anaconda虚拟环境，那里面才有pip3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54dec6d0e5b7b7826088fecec59f1ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cee713e24e2b095c46fd2d80feac54e/" rel="bookmark">
			ChatGPT浪潮来袭！谁先掌握，谁将领先！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任正非在接受采访时说
今后职场上只有两种人，
一种是熟练使用AI的人，
另一种是创造AI工具的人。
虽然这个现实听起来有些夸张的残酷，
但这就是我们必须面对的事实 📆
对于我们普通人来说，我们需要努力成为能够掌握AI技能的人。从目前的情况来看，即使在职场中遇到择业挑战，也能够在就业市场上找到自己的岗位。
一方面包括写作、绘画、视频、媒体、编程、教育等领域将被颠覆，一大批旧的岗位被AI取代，另一方面同时也会出现大量的新岗位，AI相关的职位正在不断增多，比如AI画师、AI运营、AI产品经理等，这些都为掌握AI技能的人提供了广阔的发展空间。
怎样才算真正掌握了AI呢？简单来说，需要做到三点：
首先，确保自己能够稳定地使用AI工具；【本期提供免费的Chat-gpt3.5体验接口，但也强烈推荐使用“国产文心一言”】后台回复“gpt”获取体验地址和账号！！！原文地址是文心一言官网地址，国内手机号就能注册使用。
因为ChatGPT是不对大陆地区直接开放的，有些人就弄了个接口，直接做起了ChatGPT的二道贩子，把免费的ChatGPT回答搬到微信上，愣是能日入十几万，啥叫一本万利啊？学长先血书，表示不搞违f乱纪的事儿，也不是清华博士不搞啥直播卖课的坑蒙拐骗。就是简单分享好东西！！
其次，熟悉并掌握AI的指令和技巧，能够高效地利用它来完成工作；参阅上期文章！
ChatGPT到底有多厉害？强烈推荐使用！Prompt教程！学起来！用的人下班都早了。
最后，通过不断地实践和个性化调整，与时俱进，让AI工具更好地符合自己的使用习惯和需求。只有这样，我们才能真正成为掌握AI技能的人，在这场技术革命中立于不败之地。再去看看，找个什么热门工作💼
一、分析目前GPT在国内的使用情况
在国内，能够接触并使用ChatGPT已经代表着你在技术探索与应用方面站在了前沿。这不仅仅是一个简单的工具使用问题，更是反映了你在面对新技术时的积极态度。不过，使用ChatGPT本身并不足以带来优越感，它更像是一个起点，一个引领你走向更广阔天地的起点。
关键的问题在于，你如何深度挖掘ChatGPT的潜力，并将其真正融入到你的学习和工作中。你是否能够敏锐地捕捉到它所带来的机会，将其变成一个强大的助力，帮助你在各个领域取得突破？或者，它是否只是你闲暇时的一个消遣，一个有趣的玩具？
为了更深入地了解ChatGPT在国内的应用情况，近期某机构进行了一项广泛的调查。结果显示，参与投票的3000多人中，有超过85%的人正在使用ChatGPT。这其中，有大部分人将其视为提升学习和工作效率的利器，而也有一部分人主要出于娱乐目的使用它。这个数据虽然受到了一定程度的样本偏差影响，但仍然在一定程度上反映了ChatGPT在国内的受欢迎程度。
二、ChatGPT的用户群体
学生群体首当其冲，他们总是对新技术充满好奇，乐于尝试新鲜事物。ChatGPT为他们提供了一个全新的学习平台，无论是写论文、学英语，还是辅助学习新知识，它都能提供有力的支持。
IT和互联网行业的从业者，由于行业的特殊性，他们对技术工具的关注度更高。ChatGPT在代码生成和程序调试方面的出色表现，让他们的工作效率得到了显著提升。
自媒体创作者和文字工作者，也是ChatGPT的忠实用户。ChatGPT强大的文本生成和编辑能力，为他们的创作提供了源源不断的灵感。无论是撰写文章、设计大纲，还是提炼要点，ChatGPT都能为他们提供有力的帮助。
职场人士的必备武器，可能他们并不直接从事与技术相关的工作，但他们乐于接受新事物，愿意尝试新技术。对于他们来说，ChatGPT可能是一个全新的工作助手，帮助他们处理会议记录、撰写报告、分析数据等琐碎工作。
然而，真正能够充分利用ChatGPT并领先他人的，是那些能够将ChatGPT与自身工作和学习场景深度融合的人。他们不仅能够熟练使用ChatGPT，更能发掘出其潜在的价值，将其变成一个强大的助力。这种深度的融合不仅能够提升他们的工作效率，更能帮助他们在各个领域中脱颖而出。
总的来说，ChatGPT在国内已经拥有了一定的用户基础，并且在各个领域都得到了广泛的应用。然而，如何更好地利用这个工具，将其变成一个真正的助力，还需要我们进一步探索和实践。
ChatGPT怎么就一跃成了这么聪明的AI呢？
ChatGPT给了我一个答案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef81c96cb1e4bed0d5867de0008253e9/" rel="bookmark">
			【强化学习笔记一】初识强化学习（定义、应用、分类、性能指标、小车上山案例及代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1章 初识强化学习1.1 强化学习及其关键元素1.2 强化学习的应用1.3 强化学习的分类1.3.1 按任务分类1.3.2 按算法分类 1.4 强化学习算法的性能指标1.5 案例：基于Gym库的智能体/环境接口1.5.1 安装Gym库1.5.2 使用Gym库1.5.3 小车上山1.5.3.1 有限动作空间1.5.3.2 连续动作空间 第1章 初识强化学习 1.1 强化学习及其关键元素 强化学习(Reinforcement Learning，RL)是根据奖励信号来改进策略的机器学习方法。如图所示，强化学习通常由两部分组成：智能体和环境。在一个强化学习系统中，智能体可以观察环境，并根据观测行动。在行动之后，能够获得奖励或付出代价。强化学习通过智能体与环境的交互记录来学习如何最大化奖励或最小化代价。强化学习的最大特点是在学习过程中没有正确答案，而是通过奖励信号来学习。
智能体和环境接口主要有以下两个环节： ❑智能体观测环境，可以获得环境的观测(observation)，记为O，接着智能体决定要对环境施加的动作(action)，记为A；
❑环境受智能体动作的影响，给出奖励(reward)，记为R，并改变自己的状态(state)，记为S。
在交互中，观测O、动作A和奖励R是智能体可以直接观测到的。
强化学习系统有以下关键元素： ❑奖励(reward)或代价(cost)： 最大化在长时间里的总奖励，最小化代价是强化学习系统的学习目标。
❑策略(policy)： 决策者会根据不同的观测决定采用不同的动作，这种从观测到动作的关系称为策略。强化学习的学习对象就是策略。
强化学习与监督学习的本质区别： ❑对于监督学习，学习者知道每个动作的正确答案是什么，可以通过逐步比对来学习；对于强化学习，学习者不知道每个动作的正确答案，只能通过奖励信号来学习，同时需要关注更加长远的奖励。与此同时，监督学习希望能将学习的结果运用到未知的数据，要求结果可推广、可泛化；强化学习的结果却可以用在训练的环境中。
1.2 强化学习的应用 ❑棋盘游戏：棋盘游戏是围棋、黑白翻转棋、五子棋等桌上游戏的统称。棋盘AI的每一步往往没有绝对正确的答案，这正是强化学习所针对的场景。DeepMind公司使用强化学习研发出围棋AI AlphaGo先后战胜李世石、柯洁等围棋顶尖选手，引起了全社会的关注。后来，DeepMind又研发了棋盘游戏AI如AlphaZero和MuZero，它可以在围棋、日本将棋、国际象棋等多个棋盘游戏上达到最高水平，并远远超出人类的最高水平。
❑自动控制：自动控制问题通过控制机械设备（如机器人、机器手、平衡设备等）的行为来完成平衡、移动、抓取等任务。自动控制问题既可能是虚拟仿真环境中的问题，也可能是现实世界中出现的问题。基于强化学习的控制策略可以帮助解决这类控制问题。
1.3 强化学习的分类 1.3.1 按任务分类 除了图中的分类外，有些问题需要同时考虑多个任务。同时针对多个任务的学习称为多任务强化学习(Multi-Task Reinforcement Learning，MTRL)。如果多个任务只是奖励的参数不同而其他方面都相同，则对这些任务的学习可以称为以目标为条件的强化学习(goal-conditioned reinforcement learning)。例如，有多个任务想要让机器人到达目的地，不同任务的目的地各不相同。那么这个目的地就可以看作每个任务的目标(goal)，这多个任务合起来就可以看作以目标为条件的强化学习。如果要试图通过对某些任务进行学习，然后将学习的成果应用于其他任务，这样就和迁移学习结合起来，称为迁移强化学习(transfer reinforcement learning)。如果要通过学习其他任务的过程了解如何在未知的新任务中进行学习的知识，则称为元强化学习(meta reinforcement learning)。在多任务学习中，多个任务可能是随时间不断变化的。需要不断适应随时间变化的任务，称为在线学习(online reinforcement learning)或终身强化学习(lifelong reinforcement learning)。不过，在线学习并不是和离线学习相对的概念。实际上，**离线强化学习(offline reinforcement learning)是批强化学习(batch reinforcement learning)**的另外一种说法，是指在学习过程中不能和环境交互，只能通过其他智能体与环境的交互历史来学习。
1.3.2 按算法分类 ❑同策学习(on policy)和异策学习(off policy)： 同策学习从正在执行的策略中学习。异策学习则是从当前策略以外的策略中学习，例如通过之前的历史（可以是自己的历史，也可以是别人的历史）进行学习。
❑有模型(model-based)学习和无模型(model free)学习： 在学习的过程中，如果用到了环境的数学模型，则是有模型学习（可能是在学习前环境的模型就已经知道，也可能是通过学习来的）；如果没有用到环境的数学模型，则是无模型学习（所有经验都是通过与真实环境交互得到的）。
❑回合更新(Monte Carlo update)和时序差分更新(temporal difference update)： 回合更新是在回合结束后利用整个回合的信息进行更新学习，并且不使用局部信息；而时序差分更新不需要等回合结束，可以综合利用现有的信息和现有的估计进行更新学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef81c96cb1e4bed0d5867de0008253e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c881d21d5f482e6006bd8c1ced7ee7/" rel="bookmark">
			CSS学习2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己在工作中总是有一些自动化开发的需求，总是以为自己是有前端基础的，但是一写页面，布局都布不好，真是搞笑，说起来还是基本功不扎实啊，这里在重新复习一下，然后记录一下文档。后边在写两个综合练习
一、伪类选择器 1.a标签的伪类 &lt;html&gt; &lt;head&gt; &lt;style&gt; /* 去除a标签文字的下划线 */ a { text-decoration: none; } /* a标签没有点击时的默认样式 */ a:link { color: black; } /* a标签点击后的样式 */ a:visited { color: red; } /* a标签鼠标悬浮或者划过时的样式 */ a:hover { color: blue; } /* a标签在鼠标点击时候的样式 */ a:active { color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; &lt;br&gt; &lt;a href="https://www.jd.com"&gt;京东&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 1.1 伪类的顺序 a标签的书写顺序必须按照link、visted、hover、active的顺序书写，否则有些效果就会不生效。按照首字母顺序可以记忆为lvha
1.2 适用范围 link visted是a标签专属的伪类。只能适用于a标签。而hover、active不仅适用于a标签，还适用于其它元素。
举例：
&lt;html&gt; &lt;head&gt; &lt;style&gt; .box &gt; div { width: 100px; height: 100px; background-color: red; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c881d21d5f482e6006bd8c1ced7ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dce219e0658bbe50bc5c1822cd09dd8/" rel="bookmark">
			C语言（指针）单元练习二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1有以下程序：
#include &lt;stdio.h&gt;
void fun( int *a, int i, int j)
{ int t;
if(i&lt;j) { t=a[i]; a[i]=a[j]; a[j]=t;
fun(a,++i,--j); } }
main()
{ int a[]={1,2,3,4,5,6},i;
fun(a,0,5);
for(i=0; i&lt;6; i++)
printf("%d ",a[i]); return; }
执行后输出结果是______。A
A.6 5 4 3 2 1 B.4 3 2 1 5 6 C.4 5 6 1 2 3 D.1 2 3 4 5 6
2以下语句的输出结果是______。B
char s[]="\t\ \chinese\ \girl\n";
printf("%d",strlen(s));
A. 12 B.15 C. 13 D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dce219e0658bbe50bc5c1822cd09dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565529100e90166cde498197c6a240c2/" rel="bookmark">
			C语言（循环）单元练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单项选择题 1、以下程序段中与语句k=a&gt;b?(b&gt;c?1:0):0；功能等价的是__A____。
A. if((a&gt;b)&amp;&amp;(b&gt;c)) k=1; B. if((a&gt;b)||(b&gt;c)) k=1
else k=0; else k=0;
C. if(a&lt;=b) k=0; D. if(a&gt;b) k=1;
else if(b&lt;=c) k=1; else if(b&gt;c) k=1;
else k=0;
2、C语言的do_while循环中，循环由do开始，用while结束；而且在while表达式后面的___B___不能丢，它表示do_while循环的结束。
A. \n B. “;” C. “%” D. “,”
3、执行程序段： x=-1; do { x=x*x;} while(!x); 的结果是__C____。
A. 死循环 B. 循环执行2次 C. 循环执行一次 D. 有语法错误
4、下面程序段的输出结果是__D____。
int i,sum;
for(i=1;i&lt;=10;i++)sum+=sum;
printf("%d\n",i);
A. 10 B. 9 C. 15 D.不确定
5、以下叙述正确的是___C___。
A. for循环中设置for(条件)break，当条件成立时中止程序执行。
B. for循环中设置for(条件)continue，当条件成立时中止本层循环。
C. for循环中设置for(条件)break，当条件成立时中止本层循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565529100e90166cde498197c6a240c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd07e7671f2da372afd60d795370025d/" rel="bookmark">
			深入理解ngx_http_upstream_vnswrr_module负载均衡模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 引言2. 启用vnswrr负载均衡模块3. 源码剖析3.1 配置指令分析3.2 负载均衡算法配置初始化3.3 负载均衡请求上下文的初始化3.4 获取peer 1. 引言 之前有讨论了nginx的swrr算法的两个问题，并引出了阿里tengine的vnswrr算法如何来克服swrr的问题。本文通过源码层面对ngx_http_upstream_vnswrr_module模块进行分析，来深入理解vnswrr负载均衡算法。关于swrr算法的思考可以查看《nginx upstream server主动健康检测模块添加https检测功能》。关于vnswrr的算法原理可以参考《阿里七层流量入口负载均衡算法演变之路》。
2. 启用vnswrr负载均衡模块 配置指令的格式为：
指令： vnswrr [max_init=init_vode_num] 默认值： - 上下文: upstream 其中init_vnode_num是初始化虚拟节点的数量，具体可以参考《阿里七层流量入口负载均衡算法演变之路》中**接入层 VNSWRR 算法（V2）**部分的描述。
以5台rs服务器为例开启vnswrr，距离如下：
upstream { vnswrr 5; server 192.168.0.1 weight=1; server 192.168.0.2 weight=1; server 192.168.0.3 weight=3; server 192.168.0.4 weight=3; server 192.168.0.5 weight=5; server 192.168.0.6 weight=5; } 3. 源码剖析 3.1 配置指令分析 本模块定义了配置指令vnswrr，代码如下：
static ngx_command_t ngx_http_upstream_vnswrr_commands[] = { { ngx_string("vnswrr"), NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1, ngx_http_upstream_vnswrr, 0, 0, NULL }, ngx_null_command }; 以上定义了指令分析回调函数ngx_http_upstream_vnswrr, 其源码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd07e7671f2da372afd60d795370025d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d8d3b1cec20517bff5faf0c58c4539/" rel="bookmark">
			多线程请求后台资源，ReentrantLock锁定业务代码只执行一次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用ReentrantLock 的
tryLock() 方法，能拿到锁可以直接返回true，拿不到直接返回false，还可以使用带参数的超时时间tryLock(time,timeunit) 方法，具体场景具体使用。 2、首先获取锁，获取不到就表示有其他线程在执行，那么会进入到else，这里设置了一个自旋去等待这个锁的释放，并且设置了一个自旋超时时间，防止大量请求消耗资源。这样就是只有一个线程在执行，其他线程等待结果就可以，异常情况暂不考虑
还有 wati 和 notifyall 方案 也可以实现后台业务代码只执行一次。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/28/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>