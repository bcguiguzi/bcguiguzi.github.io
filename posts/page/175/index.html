<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1e56364d2da0754834f535f3de60a8/" rel="bookmark">
			VSCode安装教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💌 所属专栏：【软件安装教程】
😀 作 者：我是夜阑的狗🐶 🚀 个人简介：一个正在努力学技术的CV工程师，专注基础和实战分享 ，欢迎咨询！
💖 欢迎大家：这里是CSDN，我总结知识的地方，喜欢的话请三连，有问题请私信 😘 😘 😘
文章目录 前言一、VSCode软件下载二、安装步骤三、安装完了配置一下总结 前言 大家好，又见面了，我是夜阑的狗🐶，本文是专栏【软件安装教程】专栏的第1篇文章;
既然用到了VSCode，写篇安装教程记录一下不过分吧
专栏地址：【软件安装教程】， 此专栏是我是夜阑的狗对软件安装的总结，希望能够加深自己的印象，以及帮助到其他的小伙伴😉😉。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
一、VSCode软件下载 官网下载地址: 下载地址
1、点击Download for Windows的下拉按钮，点击Other downloads；
2、在这里可以选择自己想要下载的版本
这里我下载的windows版本，下面的教程就以windows版本为例。 二、安装步骤 Step1.双击下载好的安装包，可能有些会出现安全警告，到时点击运行即可，这里我没有出现所以就没有展示了；
Step2.阅读协议后，点击我同意此协议，点击下一步；
Step 3.接下来就是选择安装路径了，默认是安装在C盘，可以点击浏览选择自己的安装路径，这里我选择在D盘路径：“D:\TOOL\Microsoft VS Code”；
Step 4. 添加到开始菜单，这里默认即可，点击下一步； Step 5. 这里要选择自己想要的功能，点击下一步，下面本人勾选功能，仅供参考； 因为比较喜欢桌面干净就不勾选桌面快捷方式了，还有也不想用VSCode添加到右键菜单，支持打开目录，也不勾选了；
Step 6.确认信息，点击安装； Step 7. 安装完成，这里我不勾选VS Code了 三、安装完了配置一下 到这里整个软件安装完了，发现是英文界面，如果想要学习英语的小伙伴可以接着用，英语差的也推荐用英语界面。但是中文界面可以不用，但不能不有！！！
1. 配置中文界面
安装插件之后，重启一下软件即可； 中文界面安装完成
总结 以上就是今天要讲的内容，本文仅仅简单介绍了VSCode安装教程和中文配置。当然VSCode的配置不止这一点，后面的配置都是按需配置，本人追求的就是简洁。
感谢观看，如果有帮助到你，请给文章点个赞和收藏，让更多的人看到。🌹 🌹 🌹
也欢迎你，关注我。👍 👍 👍
原创不易，还希望各位大佬支持一下，你们的点赞、收藏和留言对我真的很重要！！！💕 💕 💕 最后，本文仍有许多不足之处，欢迎各位认真读完文章的小伙伴们随时私信交流、批评指正！
更多专栏订阅: 😀 【LeetCode题解（持续更新中）】🚝 【Java Web项目构建过程】💛 【数字图像处理】⚽ 【JavaScript随手笔记】🤩 【大数据学习笔记（华为云）】🦄 【程序错误解决方法（建议收藏）】🚀 【软件安装教程】 订阅更多，你们将会看到更多的优质内容！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bf24e638608d192b9b7cdf90f82ed7/" rel="bookmark">
			git实战技巧-本地刚做出的修改、暂存和提交如何进行撤销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、解决思路
工作区和暂存区内容的撤销，直接按照对应命令或者IDEA界面完成操作就行。
对于已提交的撤销回滚建议如下：
1. 代码如果仅仅是回撤到指定版本，该版本之上的更新是不需要的，选择Hard模式。
2. 代码回撤到指定版本时，需要保存该版本之上的更新，可以选择Soft模式。
其他根据自己的需要选择即可。
2、动手实践
2.1、基于IDEA解决
1)撤销工作区内容
变更内容可以在Git工具窗口中直接撤销，如下图：
或者右键的文件，选择Git，然后选择Rollback也可以完成撤销。
2)撤销暂存区文件
IDEA中做代码更新后，可以不用额外的做暂存，直接提交就行了。所以可以不用考虑暂存撤销的问题。
3)已提交的撤销
IDEA中要撤销版本回到上一版本，或者回退到指定版本可以如下操作：
1. 打开Git工具窗口，点击Log 查看版本提交记录
2. 然后右键你需要回退的版本，选择Rest Current Branch to Here
3. 此时会弹出一个菜单，供我们选择，选择需要的操作模式，然后点击Reset即可
撤销模式说明：
四种模式在撤销回滚时，都会让HEAD指针改变指向到指定版本。
1. Soft：回滚代码到指定版本时，工作区文件不会做改变，相较于指定版本多出的更新将会被暂存等待提交
2. Mixed：回滚代码到指定版本时，工作区文件不会有改动，但是暂存会被清空
3. Hard：回滚到指定版本时，工作区内容会回滚到指定版本，暂存也会被清空(慎重，未提交的代码有丢失风险)
4. Keep：回滚到指定版本时，工作区内容会回滚到指定版本，暂存区未提交内容会保存
2.2、基于Git命令解决
1)工作区内容撤销
命令：`git checkout -- fileName`
例如，对readme.txt 进行内容修改，保存文件。此时在Git Bash 中执行 `git status`看效果。
上面有提示我们如何进行撤销，现在我们撤销readme.txt的修改：
2)已暂存撤销
命令：
`git reset HEAD file` 移除暂存区回到工作区，内容在工作区中还是存在的
例如，对readme.txt 进行内容修改并已经暂存。现在需要撤销
此时在Git Bash 中执行 `git status`看效果。
上面有提示我们如何进行撤销暂存，现在我们撤销readme.txt的暂存：
3)已提交撤销
当前知识点能够解决你在以后遇到的如下问题，
1. 想要查看历史提交版本信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bf24e638608d192b9b7cdf90f82ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14025eac937d796ed59a91ef7be4e5b6/" rel="bookmark">
			关于Cannot resolve symbol ‘servlet‘报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近跟着黑马程序员的javaWeb课程学习servlet，在实现servlet接口时一直报错Cannot resolve symbol 'servlet'，在Libraries 里添加了tomcat/lib/servlet-api.jar也未得到解决，尝试了各种方法都不行。后来选择了继承HttpServlet问题得到解决。（不知道是否是软件版本问题？）
查询资料发现继承HttpServelt实际上也实现了servlet接口，并且只需要重写类中的一个或多个方法。
如果实现Servlet接口需要将其所有的抽象方法实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4199b7a2e8256588c6eeda27b48894e3/" rel="bookmark">
			rsyslog使用:omrelp:方式配置远程转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本介绍 UDP和TCP转发方式
RELP转发方式
配置日志服务器
配置client端
FAQ
服务器端问题
客户端问题 基本介绍 rsyslog有三种转发消息的方式：
UDP传输：它的损耗很大，但很标准;
TCP传输：它只在某些情况下丢失消息，但大多数情况下是正常的;
RELP传输：而RELP传输不会丢失消息，但目前仅作为rsyslogd 3.15.0及以上版本的一部分可用。
要通过UDP将消息转发到另一个主机，请在主机名前面加上at符号(“@”)。要通过普通tcp转发，请在前面加上两个@号(“@@”)。要通过RELP转发，请在主机名前面加上字符串“:omrelp:”。
UDP和TCP转发方式 # 发送到udp端口
*.info @loghost.example.com
*.* @192.168.0.1
在上面的例子中，消息通过UDP转发到机器192.168.0.1，目标端口默认为514。由于UDP的特性，您可能会在传输过程中丢失一些消息。如果您预期流量很大，那么您可能会损失相当可观的消息数量(流量越大，消息丢失的可能性越大，情况也就越严重)。
可以使用omfwd模块的"device"选项将转发消息的套接字绑定到特定的设备。
Example:
action(type="omfwd" Target="192.168.0.1" Device="eth0" Port=514 Protocol="udp")
在上面的例子中，消息通过UDP通过设备eth0在端口514上转发到机器192.168.0.1。在上面的例子中，如果要使用TCP可以将Protocol设置为“TCP”。对于支持VRF的Linux, device选项用于指定发送消息的VRF。
# 发送到ipv6
auth,authpriv.* @[2409:8080:5a0a:102f:0:4::11]:514
# 发送到tcp端口
*.* @@loghost.example.com
RELP转发方式 场景：日志服务器接收user.notice输出级别的日志，当然可以配置成任何其他级别。在日志服务器我们做了配置：user.notice /var/log/remote-operation.log。在client端，我们通过logger命令发送日志，其默认输出级别就是user.notice，如果要输出其他级别可以使用-p参数指定。
-p, --priority &lt; facility.level&gt; 将指定消息标记为此优先级。For example, -p local3.info logs the message as informational in the local3 facility. The default is user.notice.
配置完成后的验证就不赘述了。
配置日志服务器 # selinux添加端口信任 semanage port -a -t syslogd_port_t -p tcp 40888 semanage port -a -t syslogd_port_t -p udp 40888 # 安装relp支持库 yum -y install rsyslog-relp # 编辑rsyslog配置文件 vi /etc/rsyslog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4199b7a2e8256588c6eeda27b48894e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77bb89dead0c1ff0ccad9b3f8670ad9/" rel="bookmark">
			python-selenium-规避检测,无头浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1:无头浏览器 取消的浏览器的可视化界面,在一定程度上加了自动化速度
chrome_options=Options() chrome_options.add_argument("--headless") chrome_options.add_argument("--disable-gpu") driver = webdriver.Chrome(options=chrome_options) 2:规避--取消浏览器中的自动化程序正在控制浏览器 自动化打开的浏览器和出现
我们可以使用代码把他去掉
opt = Options() opt.add_experimental_option('excludeSwitches',['enable-automation']) driver = webdriver.Chrome(options=opt) 3:2:规避---window.navigator.webdriver问题 正常打开浏览器输入window.navigator.webdriver结尾:false或者undefined
selenium打开的浏览器是:true
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", { "source": """ Object.defineProperty(navigator, 'webdriver', { get: () =&gt; undefined }) """ }) 复制上面的代码即可,但是有些网站还是会失败
也可以通过这中方式
with open('./stealth.min.js')as f: js=f.read() driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", { "source": js }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51506217abd8c829e5581ca589b738e4/" rel="bookmark">
			HTML5新特性、新增标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签 HTML5是超文本标记语言的第五次重新修订，2014年10月29日标准规范制定完成。HTML5的设计目的是为了在移动设备上支持多媒体。
HTML5的新特性：
用于绘画：canvas元素
用于媒体回访：video和audio元素
对本地离线存储的更好支持：localstorage
新的语义化标签：article、footer、header、nav、section、figure
新的表单控件：calendar、date、time、email、url、search
低版本的 IE 支持 HTML5新标签
// 第一种方法使用html5shiv库
&lt;!--[if IE]&gt; &lt;script src=”http://html5shiv.googlecode.com/svn/trunk/html5.js”&gt;&lt;/script&gt;
&lt;![endif]--&gt; // 在页面中调用时必须添加在页面的head元素内，因为IE浏览器必须在元素解析前知道这个元素，所以这个js文件不能在页面底部调用.
// 第二种方法通过js动态创建元素
&lt;!--[if IE]&gt; &lt;script&gt;
(function(){ var a = ['section', 'article', 'nav', 'header', 'footer' /* 其他HTML5元素 */] for(var i = 0; i &lt; a.length; i++){ document.createElement(a[i]);
}
})() &lt;/script&gt;
&lt;![endif]--&gt; // css属性设置
section,article,nav,header,footer{display:block;}
2.input有哪些新增类型 email
url
number
range
color
Date Picker
Date
month
week
time
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51506217abd8c829e5581ca589b738e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ecfb1120b729b8f85cf39eba4a591a/" rel="bookmark">
			vite &#43; vue &#43; ts 自动按需导入 Element Plus组件，并如何解决按需引入后ElMessage与ElLoading 的问题（找不到名称“ElMessage”问题。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按需引入后ElMessage与ElLoading 的问题，两步优雅解决找不到名称“ElMessage”问题。不需要导入npm包，不需要下载任何东西，只要五行代码
目录
1、添加Element Plus组件库
1.2、下载
1.2、自动导入(官方推荐)
2、按需引入后ElMessage与ElLoading 的问题
2.1、解决问题
2.2、下面是分析原因,有兴趣可以看一下
1、添加Element Plus组件库 1.1、下载 npm
npm install element-plus --save yarn yarn add element-plus 1.2、下载element-icon npm install @element-plus/icons-vue element-icon也有自动导入的,但我感觉更麻烦,所有还是手动导入吧
手动导入方式:
import { Grid, RefreshRight } from "@element-plus/icons-vue"; 1.3、自动导入(官方推荐) 首先你需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件
如果你是从vite+vue3+ts 手把手教你创建一个vue3项目 过来的,已经下过了,就不用再下了,只要添加有element注释的那行就行
npm install -D unplugin-vue-components unplugin-auto-import vite.config.ts文件
import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // 自动导入vue中hook reactive ref等 import AutoImport from "unplugin-auto-import/vite" //自动导入ui-组件 比如说ant-design-vue element-plus等 import Components from 'unplugin-vue-components/vite'; //element import { ElementPlusResolver } from 'unplugin-vue-components/resolvers' // https://vitejs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ecfb1120b729b8f85cf39eba4a591a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7a1172342e5e50acb7750db3ed29df/" rel="bookmark">
			vite &#43; vue3 &#43; ts 自动按需导入ant-design-vue组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装ant-design-vue --npm npm install ant-design-vue --save --yarn yarn add ant-design-vue icon图标
--ant-design npm install --save @ant-design/icons-vue main.ts引入
//ant-design-vue import Antd from 'ant-design-vue'; import 'ant-design-vue/dist/antd.css'; 自动按需导入包
如果你是从vite+vue3+ts 手把手教你创建一个vue3项目 过来的,已经下过了,就不用再下了,只要添加有ant-design-vue注释的那行就行
npm install -D unplugin-vue-components unplugin-auto-import vite.config.ts文件下
import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // 自动导入vue中hook reactive ref等 import AutoImport from "unplugin-auto-import/vite" //自动导入ui-组件 比如说ant-design-vue element-plus等 import Components from 'unplugin-vue-components/vite'; //ant-design-vue import {AntDesignVueResolver} from "unplugin-vue-components/resolvers" export default defineConfig({ plugins: [ vue(), AutoImport({ //安装两行后你会发现在组件中不用再导入ref，reactive等 imports: ['vue', 'vue-router'], dts: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d7a1172342e5e50acb7750db3ed29df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa74e9d9aa77040bc7c9594aba8aca74/" rel="bookmark">
			vscode编译python文件遇到“Couldn‘t spawn debuggee: [WinError 5] 拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决vscode编译python文件遇到“Couldn't spawn debuggee: [WinError 5] 拒绝访问”的问题 - Kevin Wang的博客 (pluskevin.com)
亲测有效，直接看原作者的第六步即可，或者你看我下述步骤。
问题：
在使用 F5按钮运行自己写的 demo.py时候，报错如下图所示：
网上的vscode配置python的教程并不正确，
网上的配置方法是：
将launch.json文件增加一行，其内容为："python": "C:\Python310",
解决办法：
点击‘打开launch.json’,将这行内容改为：
"python": "C:\\Python310\\python.exe",
然后再用 F5运行一下自己写的demo.py ,会发现没有报错提示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2761d2e9c99f586dffc195be99015a91/" rel="bookmark">
			APP如何做好防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了防止恶意软件和病毒伤害应用软件，需要设计和采用有效的防护措施，以防范和控制可能的安全风险。
1、安装相应的杀毒软件和安全软件，以检测网络上具有危害性的软件并及时进行清除。
2、在应用软件中添加数据访问控制权限，只有具有统一的且有效的账户信息才可以访问系统中的数据。
3、利用密码的技术，对外界对软件的访问和使用进行严格的限制，确保软件的安全，不被恶意破解和攻击。
4、多安装隔离性的防火墙，将系统的访问者严格的隔离，并对访问者进行事先审查。
5、及时更新和升级应用软件，建立定期检查机制，以及针对安全系统进行题外检测，及时发现漏洞并加以修复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3abadc43d2ecf4cd477b76f656fc897/" rel="bookmark">
			Vue的路由配置（Vue2和Vue3的路由配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Tips：使用Vue3开发项目已经有一段时间了，关于Vue2的路由是如何一步一步搭建的都快要忘记了，今天写着篇文章主要就是回顾一下，在Vue2和Vue3中我们是如何一步一步的配置路由的。
提示：最好的进步就是有闲暇时间就敲一敲代码！！！！！
文章目录 系列文章目录一、路由是什么？二、Vue2中路由的创建步骤1.安装正确的路由版本（这里我踩坑了）2.vue2中配置路由的步骤步骤如下：代码如下图所示如下图所示： 三、Vue3中路由的创建步骤1.步骤如下代码如下图所示如下图所示： 一、路由是什么？ Vue中的路由就是.SPA（single page application 单页应用程序） 的路径管理器。
vue-router是Vue.js官方的路由插件，用于构建单页面应用。vue的单页面应用是基于路由和组件的，设定访问路径，并将路径和组件映射起来。在vue-router单页面应用中，路径之间的切换，就是组件的切换。路由模块的本质就是建立起url和页面之间的映射关系。
二、Vue2中路由的创建步骤 1.安装正确的路由版本（这里我踩坑了） 1.首先安装vue-router的时候需要确定版本。 Vue2.0采用的 vue-router 版本为 @^3.5.1 npm i vue-router@^3.5.1 -s // Vue2安装的方式 2.直接 npm i vue-router -s 这种方式安装会安装最新版本（适用于Vue3）
npm i vue-router -s //Vue3安装的方式 2.vue2中配置路由的步骤 步骤如下： 1.安装 vue-router@3.5.1
2.创建 router文件夹 并创建 index.js
3.引入VueRouter 和 Vue
4.Vue.use(VueRouter)
5.创建VueRouter实例： const router = new VueRouter（{ routes}）
6.配置routes （结构如下图所示）
7.导出router
8. 在main.js中导入刚才的 router
9.注册router
10.创建 router-link 和 router-view
代码如下图所示 路由文件代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3abadc43d2ecf4cd477b76f656fc897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2548bce6bf951e2f1adbd6ffa37be2e0/" rel="bookmark">
			现在Java程序员面试都这么重视手撕算法的能力吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前逛脉脉，看到这样一条消息
确实，前两年，主要是国外大厂比较注重数据结构与算法的考察。但最近这两年，国内的互联网公司，不论大、小厂都紧跟潮流，不管三七二十一，上来先考几道算法题，而且，不只针对于社招，应届生更是如此，甚至 3 轮、4 轮面试，轮轮面算法。
这不，前两天就有粉丝跟我说：
卷吗？太卷了
有必要吗？真的很有必要
那为什么现在面试这么重视手撕算法的能力？
首先，面试官通过考察候选人算法的能力来判定其基本功是否扎实、代码是否严谨、是否能快速掌握新技术的核心要领等等。
其次，说得直白、实际些——
首先，算法能力决定了你能不能去大厂，尤其像阿里、腾讯、字节这种互联网技术顶尖的公司，面试官在考察候选人时会毫不犹豫地甩给你一道算法题，要求你当场手写，能否进入下一轮或者拿到Offer，在算法面试中可见一斑。
其次，以上这些职级体系比较完善的公司，你想拿到一个比较高的职级（职位），或者想从基层码农晋升到高级甚至是管理岗，公司对你算法基本功的要求只会越来越高。
也就是大家常说的，在面试中你的算法能力可能会直接影响面试结果，甚至影响最后的薪资水平。
既然知道了算法在面试中的重要性，接下来我们肯定需要为此而准备迎接金九银十跳槽季。
正好我在GitHub上发现一份火爆全网的《算法中文小册》，仅几个月，就有了近8W star：
这份算法笔记，大部分都总结成了模板，有的还写成了诗句，方便记忆。据说有不少小伙伴靠这份指南成功掌握了算法的核心技能，成功拿到了 BATJ等大厂offer。
先来给你们看看里面具体都有哪些内容：
第零章、必读系列 学习算法和刷题的框架思维动态规划解题套路框架回溯算法解题套路框架BFS算法解题套路框架我写了首诗，让你闭着眼睛也能写对二分搜索我写了首诗，把滑动窗口算法算法变成了默写题一个方法团灭LeetCode股票买卖问题一个方法团灭LeetCode打家劫舍问题一个方法团灭nSum问题经典动态规划：高楼扔鸡蛋经典动态规划：子集背包问题经典动态规划：完全背包问题表达式求值算法：实现计算器 第一章、动态规划系列 动态规划解题套路框架动态规划答疑篇动态规划和回溯算法到底谁是谁爹？动态规划设计：最长递增子序列动态规划设计：最大的数组经典动态规划：0-1背包问题经典动态规划：子集背包问题经典动态规划：完全背包问题经典动态规划：编辑距离经典动态规划：高楼扔鸡蛋经典动态规划：高楼扔鸡蛋（进阶）经典动态规划：戳气球经典动态规划：最长公共子序列动态规划之子序列问题解题模板动态规划之博弈问题动态规划之正则表达动态规划之四键键盘动态规划之KMP字符匹配算法贪心算法之区间调度问题团灭LeetCode股票买卖问题团灭LeetCode打家劫舍问题 第二章、数据结构系列 学习数据结构和算法读什么书算法学习之路二叉 堆 详解实现优先级队列LRU算法详解二叉搜索树操作集锦如何计算完全二叉树的节点数特殊数据结构︰单调栈特殊数据结构︰单调队列设计Twitter递归反转链表的一部分队列实现栈|栈实现队列 第三章、算法思维系列 学习算法和刷题的思路指南回溯算法解题套路框架回溯算法团灭子集、排列、组合问题回溯算法最佳实践∶解数独回溯算法最佳实践︰括号生成二分查找详解双指针技巧总结滑动窗口技巧twoSum问题的核心思想常用地位操作拆解复杂问题︰实现计算器烧饼排序前缀和技巧字符串乘法FloodFill算法详解及应用区间调度之区间合并问题区间调度之区间交集问题信封嵌套问题几个反直觉的概率问题 第四章、高频面试系列 如何实现LRU算法如何用BFS算法秒杀各种智力题如何高效寻找素数如何高效进行模幂运算如何计算编辑距离如何运用二分查找算法如何高效解决接雨水问题如何去除有序数组的重复元素如何寻找最长回文子串如何运用贪心思想玩跳跃游戏如何k个一组反转链表如何判定括号合法性如何寻找缺失的元素如何同时寻找缺失和重复的元素如何判断回文链表如何在无限序列中随机抽取元素如何调度考生的座位Union-Find算法详解Union-Find算法应用一行代码就能解决的算法题二分查找高效判定子序列 第五章、技术文章系列 Linux的进程、线程、文件描述符是什么关于Linux shell你必须知道的Linux shell 的实用小技巧一文看懂session和 cookie加密算法的前生今世我用四个命合概括了Git的所有套路Git/SQL/正则表达式的在线练习平台 不管是应届生，还是工作好几年想跳槽的大佬，这份刷题笔记都很值得看一波。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b4be2ced9b8429a96a149a0025a2c4/" rel="bookmark">
			常用库函数strstr（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 库函数 - strstr() C 标准库 - &lt;string.h&gt;
描述 C 库函数 char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\0'。
声明 下面是 strstr() 函数的声明。
char *strstr(const char *haystack, const char *needle)
参数 haystack -- 要被检索的 C 字符串。
needle -- 在 haystack 字符串内要搜索的小字符串。
返回值 该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。
const 在实际编程中用得并不多，const 是 constant 的缩写，意思是“恒定不变的”！它是定义只读变量的关键字，或者说 const 是定义常变量的关键字。
说 const 定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量。用 const 定义常变量的方法很简单，就在通常定义变量时前面加 const 即可，如：
const 和变量类型 int 可以互换位置，二者是等价的，即上条语句等价于：那么用 const 修饰后和未修饰前有什么区别呢？它们不都等于 10 吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b4be2ced9b8429a96a149a0025a2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f8dfd780505563c66ec5f5867cba97/" rel="bookmark">
			GPU训练时查看占用显存、杀死进程命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一：查看进程号二：杀死进程三：查看显存占用情况四：查看python进程号五：杀死所有python进程 一：查看进程号 top 二：杀死进程 kill -9 进程号 三：查看显存占用情况 watch -n 0.1 nvidia-smi 四：查看python进程号 ps -ef | grep python(以此类推，别的程序也可以) 五：杀死所有python进程 ps -ef | grep python | grep -v grep | cut -c 9-15 | xargs kill -9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d66e88ee8a449b3e5813d9d91e34a54/" rel="bookmark">
			C&#43;&#43;STD库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vector
// vector 的常用方式 //vector 与数组的区别是，vector的存储量是随开随用的 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { vector&lt;int&gt; vec;//定义一个vertor（类似于数组） int n; int x; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; x; vec.push_back(x); }//将x存入vertor里 vec.pop_back();//可以删除最后一个元素. std::vector&lt;int&gt;::iterator it;//定义一个迭代器(指针)it //auto it = vec.begin();//也可以使用auto自动识别迭代器 //本质是指针 for(auto it = vec.begin();it != vec.end();it++)//it++,是指针指向数组(vec)的下一个数(it--反之)和数组的++或者--有区别 { printf("%d ",*it); }//自动识别输出，逆向输出使用rbegin(),rend()即可 for(it = vec.begin(); it != vec.end(); it++) { printf("%d ",*it); }//使用迭代器输出 for(int i = 0;i &lt; vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d66e88ee8a449b3e5813d9d91e34a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a5fe406f27807896a39760c2dd22c7/" rel="bookmark">
			Python将计算结果拷贝至粘贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 我们知道在使用ctrl+c复制文字时，实际是将文字复制到了粘贴板中（内存），而在实际应用中，除了将Python的计算结果打印外，有时还想进行自动复制。这里就用到了pyperclip模块。
使用方法： 安装该模块：
pip install pyperclip 然后，在Python中，可以使用pyperclip模块中的copy函数将内容复制到剪贴板中，如下所示：
import pyperclip # 复制文本到剪贴板 text = "要复制的文本内容" pyperclip.copy(text) 有时，我们还想进行逆向操作，即将剪切板中的文字内容，赋值到python的变量中。这时就可以使用pyperclip模块中的paste函数，如下所示：
import pyperclip # 从剪贴板粘贴文本 text = pyperclip.paste() print(text) 额外补充： 在自己遇到的项目需求中，是需要将python计算的结果手动复制到excel表格中(不采用python自动编辑excel的方式)，并且将多个内容按列排列。如图：
要实现这样的效果，在文字变量里面添加回车的转义符"\n"即可，即
import pyperclip # 复制文本到剪贴板 text ="结果1\n结果2\n结果3" pyperclip.copy(text) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45e458e91e20c2f2cc4ea99bc845ccd/" rel="bookmark">
			《知识图谱》赵军 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识图谱读书笔记 文章目录 知识图谱读书笔记一、 概述1.1 什么是知识图谱1.2 知识图谱发展历程1.3 知识图谱类型1.4 知识图谱生命周期知识体系构建知识获取知识融合知识存储知识推理知识应用 1.5 知识图谱与深度学习 二、知识表示2.1 经典知识表示理论逻辑语义网络框架脚本 2.2 语义网中的知识表示方法语义网表示方法语义网知识描述体系XMLRDFOWL 2.3 知识图谱中的知识表示方法表示框架Freebase中的知识框架 2.4 知识图谱的数值化表示方法符号的数值化表示文本的数值化表示知识图谱的数值化表示基于张量分解的表示学习方法基于能量函数的表示学习方法 三、知识体系构建和知识融合3.1 知识体系构建人工构建方法自动构建方法典型知识体系 3.2 知识融合框架匹配实体对齐冲突检测与消解典型知识融合系统 四、实体识别和扩展4.1 实体识别任务概述基于规则的实体识别方法基于机器学习的实体识别方法——基于特征的方法基于机器学习的实体识别——基于神经网络的方法 4.2 细粒度实体识别任务概述细粒度实体识别的方法 4.3 实体扩展任务概述实体扩展方法 五、实体消歧5.1 任务概述任务定义任务分类 5.2 基于聚类的实体消歧方法基于表层特征的实体指称项相似度计算基于扩展特征的实体指称项相似度计算基于社会化网络的实体指称项相似度计算 5.3 基于实体链接的实体消歧方法链接候选过滤方法实体链接方法 5.4 面向结构化文本的实体消歧方法 六、关系抽取6.1 任务概述任务定义任务分类任务难点 6.2 限定域关系抽取基于模板的关系抽取方法基于机器学习的关系抽取方法有监督的关系抽取方法弱监督的关系抽取方法 6.3 开放域关系抽取 七、事件抽取7.1 任务概述7.2 限定域事件抽取基于模式匹配的事件抽取方法有监督的事件模式匹配弱监督的事件模式匹配 基于机器学习的事件抽取方法有监督事件抽取方法弱监督事件抽取方法 7.3 开放域事件抽取基于内容特征的事件抽取方法基于异常检测的事件抽取方法 7.4 事件关系抽取事件共指关系抽取事件因果关系抽取子事件关系抽取事件时序关系抽取 八、知识存储和检索8.1 知识图谱的存储基于表结构的存储三元组表类型表关系数据库 基于图结构的存储基于图结构的存储模型常用图数据库介绍 8.2 知识图谱的检索常见形式化查询语言SQL语言SPARQL语言 图检索技术子图筛选子图同构判定 九、知识推理9.1 知识图谱中的典型推理任务知识补全知识问答 9.2 知识推理分类归纳推理和演绎推理归纳推理演绎推理 确定性推理与不确定性推理确定性逻辑推理不确定性推理 符号推理和数值推理 9.3 基于符号演算的推理归纳推理：学习推理规则频繁子图挖掘归纳逻辑编程结构学习方法 演绎推理：推理具体事实确定性推理： λ \lambda λ演算不确定性推理：马尔可夫逻辑网和概率软逻辑 9.4 基于数值计算的推理基于张量分解的方法基于能量函数的方法 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45e458e91e20c2f2cc4ea99bc845ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29402b9855741c296097ece82f443779/" rel="bookmark">
			通过命令行快速了解电脑CPU架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 和 MacOS
使用终端（小黑窗）执行下面的命令，根据输出结果查表：
uname -m 输出 的内容分别对应架构
输出对应架构i386, i686i386x86_64amd64arm, armelarm_garbagearmv7l, armhfarmv7*mipsmips*mips64mips64* Window
按 Win+R 打开运行窗口：
输入 msinfo32 然后点确定，找到 系统类型 一栏显示的 基于 XXX 的电脑：
然后根据下表确认您的系统架构：
输出对应架构x86i386x64amd64ARM64ARM64 参考文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9df85de66b2c4adfd9fc26a6813a03/" rel="bookmark">
			ShardingSphere介绍与使用&amp;Springboot&#43;ShardingJDBC实现分库分表最简Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ShardingSphere的基本介绍 1、什么是shardingSphere Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款相互独立，却又能够混合部署配合使用的产品组成。 它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。
Apache ShardingSphere 定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 它通过关注不变，进而抓住事物本质。关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。
Apache ShardingSphere 5.x 版本开始致力于可插拔架构，项目的功能组件能够灵活的以可插拔的方式进行扩展。 目前，数据分片、读写分离、多数据副本、数据加密、影子库压测等功能，以及 MySQL、PostgreSQL、SQLServer、Oracle 等 SQL 与协议的支持，均通过插件的方式织入项目。 开发者能够像使用积木一样定制属于自己的独特系统。Apache ShardingSphere 目前已提供数十个 SPI 作为系统的扩展点，仍在不断增加中。
ShardingSphere 已于2020年4月16日成为 Apache 软件基金会的顶级项目。
1、sharding-JDCB 定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。
适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。 2、sharding-proxy 定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前先提供MySQL/PostgreSQL版本，它可以使用任何兼容MySQL/PostgreSQL协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat等)操作数据，对DBA更加友好。
向应用程序完全透明，可直接当做MySQL/PostgreSQL使用。适用于任何兼容MySQL/PostgreSQL协议的的客户端。 3、sharding-sidecar 定位为Kubernetes的云原生数据库代理，以Sidecar的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即Database Mesh，又可称数据网格。
Database Mesh的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互有效的梳理。使用Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。
4、三个组件的对比 5、混合架构 Sharding-JDBC采用无中心化架构，适用于Java开发的高性能的轻量级OLTP应用；Sharding-Proxy提供静态入口以及异构语言的支持，适用于OLAP应用以及对分片数据库进行管理和运维的场景。
ShardingSphere是多接入端共同组成的生态圈。 通过混合使用Sharding-JDBC和Sharding-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，架构师可以更加自由的调整适合于当前业务的最佳系统架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9df85de66b2c4adfd9fc26a6813a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e102271d231f80408c05066ff54630a7/" rel="bookmark">
			Gazebo仿真turtlebot3的激光雷达参数修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：ros中用turtlebot3进行激光slam构建地图时，激光雷达的默认参数需要修改。例如最大激光扫描距离是3.5m，这个值较小，需要修改大一点，如何设置？
Gazebo中Turtlebot3激光雷达最远距离调整后测距信息不正常问题解决方法 - 古月居 (guyuehome.com)
设置两个地方：
文件1
激光雷达的插件位于turtlebot3_ws/src/turtlebot3/turtlebot3_description/urdf文件夹下，turtlebot3_waffle.gazebo.xacro文件。
&lt;range&gt; &lt;min&gt;0.120&lt;/min&gt; &lt;max&gt;3.5&lt;/max&gt; &lt;resolution&gt;0.015&lt;/resolution&gt; &lt;/range&gt; 当修改&lt;max&gt;3.5&lt;/max&gt;中的3.5的时候，激光雷达之后测距就会发生问题
2. 文件2
打开同一文件夹下的turtlebot3_waffle.urdf.xacro文件，其中162到166行：
&lt;jointname="scan_joint"type="fixed"&gt;&lt;parentlink="base_link"/&gt;&lt;childlink="base_scan"/&gt;&lt;originxyz="-0.064 0 0.122"rpy="0 0 0"/&gt;&lt;/joint&gt; 把&lt;origin xyz="-0.064 0 0.122" rpy="0 0 0"/&gt;中的z值调大即可。如果测距从3.5米改成了8米，那么0.122就应该改成0.142。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/174/">«</a>
	<span class="pagination__item pagination__item--current">175/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/176/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>