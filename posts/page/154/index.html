<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a920637b4d7cdd38a323b23c78770a8/" rel="bookmark">
			职场小故事分享（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 动物王国之权力的起落与角逐 动物王国之权力的起落与角逐 有一次，一只狐狸和一只老虎相遇了。老虎想吃掉狐狸，但狐狸却谎称自己是上帝派来掌管百兽的。为了证实自己的话，狐狸领着老虎在山中转了一圈，果然百兽见了它们都纷纷躲避。老虎相信了狐狸的话，但狐狸心里知道自己这一时的骗局迟早会被揭穿。
于是，狐狸开始琢磨起进一步对付老虎的办法。它不论白天黑夜，抓紧一切时间，来到动物中间，显出亲善随和的样子。它说自己已经拜虎大王为义父，今后谁有困难或摆不平的事，它可全力相助，并希望大家破除以往对自己的偏见。
许多动物相信了狐狸的话，因为那天它们亲眼所见狐狸和老虎走在一起，距离很近，而且大摇大摆，走了很长时间。看样子，老虎与狐狸的关系的确不一般。
狐狸还专门拜访了黑熊、松鼠、灰狼、猎狗等关系不错的动物，求它们在适当的时候在大家面前说说自己的好话，扩大自己的影响。它许诺，以后若有出头之日，一定不会忘了大家。
虎大王上次听了狐狸关于上帝派遣它掌管百兽的说法，心中半信半疑。它想知道狐狸在大家眼中是个什么形象，于是，它一一走访了动物。结果，它听到了许多动物对狐狸的赞赏之声。虎大王心想，狐狸在百兽中竟然有这么高的威信，不可小看。
狐狸得到老虎的信任和支持后，开始逐步扩大自己的影响力。它巧妙地运用自己的智慧和口才，在动物们中建立了广泛的人脉和关系网。它与其他动物建立了良好的沟通和互动，积极地为大家解决各种问题和困难。
在狐狸的领导下，动物们逐渐建立了一套完善的管理和协作体系，共同维护着动物世界的和平与稳定。狐狸成为了动物们的代表和领袖，大家都愿意听从它的指挥和管理。
然而，随着时间的推移，狐狸开始变得独断专行和权力滥用。它开始利用自己的权力为自己谋取私利，甚至对那些不听从自己命令的动物进行报复和打压。这让原本支持它的动物们开始产生疑虑和不满。
尽管如此，狐狸仍然保持着强大的控制力和影响力。它通过各种手段继续维护自己的地位和权力，同时也不断扩大自己的势力范围。在动物们的心目中，狐狸已经成为了一个强大而不可撼动的存在。
然而，历史的发展是不可预测的。就在动物们开始产生越来越大的不满和反抗的时候，一场突如其来的自然灾害打破了动物世界的平静。洪水、地震、干旱等各种自然灾害接连发生，给动物们带来了前所未有的困难和挑战。
在这个时候，狐狸展现出了它真正的领袖才能。它积极地组织动物们抗击自然灾害，调度各种资源和人力，统筹安排各种救援和救助工作。在狐狸的领导下，动物们展现出了惊人的团结和勇气，共同克服了种种困难和挑战。
最终，动物们成功地战胜了自然灾害，恢复了动物世界的和平与稳定。狐狸也重新赢得了动物们的尊重和信任
随着时间的推移，狐狸的权力越来越大，动物们也开始感受到了不同寻常的压力和不满。有些动物开始开始私下里议论狐狸，甚至开始悄悄地寻找一些方式来反抗狐狸的统治。
然而，狐狸始终保持着自己的统治地位。它利用自己在动物中的威望和老虎作为后盾，不断地扩大自己的权力范围，让动物们对它望而生畏。
时间终于来到了一天，一只小兔子站出来公开质问狐狸的统治。它说狐狸所做的一切都是为了自己的利益而不是为了动物们的利益，狐狸的统治已经让动物们不堪重负。
狐狸对于小兔子的言论感到十分愤怒，它下令抓捕小兔子，并且强迫所有动物公开表示支持自己的统治。然而，动物们的态度已经开始慢慢转变，他们开始反抗狐狸的统治，不再轻易地听从狐狸的命令。
最终，动物们联合起来，推翻了狐狸的统治。狐狸失去了它的地位，被迫离开了动物们的生活。动物们从此过上了更加自由和幸福的生活，没有了狐狸的统治。
这个故事告诉我们，欺骗和谎言不可能长久地维持，真相迟早会被揭露。任何人都不能一手遮天，掌控他人的命运。只有真诚和公正才能赢得人们的信任和支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307a304ddf14ff135ec9f633f56c6fbc/" rel="bookmark">
			职场小故事（8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 细节对执行力的影响沟通对执行力的影响 细节对执行力的影响 案例1：给猫挂铃铛
有一群老鼠开会，讨论怎样应对猫的袭击。一只被认为聪明的老鼠提出，给猫的脖子上挂一个铃铛。这样，猫行走的时候，铃铛就会响，听到铃声的老鼠不就可以及时跑掉了吗？大家都公认这是一个好主意。可是，由谁去给猫挂铃铛呢？怎样才能挂得上呢？这些细节问题却无从解决。于是，“给猫挂铃铛”就成了鼠辈空话，人类笑谈。
点评：任何一个战略决策和规章法案，都要想到细节，重视细节。任何对细节的忽视，都可能导致决策失误，更无从谈执行。
案例2：地摊上的纸团
有家招聘高级管理人才的公司，对一群应聘者进行复试。尽管应聘者都很有自信地回答了考官们的简单提问，可结果却都未被录用，只得怏怏而去。这时，有一位应聘者，走进房门后，看到了地毯上的一个纸团。地毯很干净，那个纸团显得很不协调。这位应聘者弯腰捡起了纸团，准备把它扔进纸篓里。这时考官发话了：“您好，朋友，请看看您捡起这个纸团吧！”这位应聘者迟疑的打开纸团，只见上边写着：“热忱欢迎您到我公司任职。”几年以后，这位捡纸团的应聘者成为了这家著名公司的大总裁。
点评：一个不经意的细节就决定了面试的成败，也说明人的素质是由细节表现出来的。
案例3：胆大心细
有位医学院的教授，在上课的第一天对他的学生说：“当医生，最要紧的就是胆大心细！”说完，便将一只手指伸进桌子上一只盛满尿液的杯子里，接着再把手指放进自己的嘴中。随后教授将那只杯子递给学生，让这些学生学者他的样子做。看着每个学生都把手指探入杯中，然后再塞进嘴里，忍着呕吐的狼狈样，他微微笑了笑说：“不错，不错，你们每个人都够胆大的。”紧接着教授又难过起来：“只可惜你们看的不够心细，没有注意到我探入尿杯的是食指，而放进嘴里的却是中指啊！”
点评：教授这样做的本意，是教育学生在科研与工作中都要注意细节。相信尝过尿液的学生应该终生能够记住这次“教训”，不注意细节，执行力越强，错误越大。
沟通对执行力的影响 案例4：秀才买材
有一个秀才去买材，他对卖材的人说：“荷薪者过来！”卖材的人听不懂“荷薪者”（担材的人）三个字，但是听得懂“过来”两个字，于是把材担到秀才面前。秀才问他：“其价如何？”卖材的人听不太懂这句话，但是听得懂“价”这个字，于是就告诉秀才价钱。秀才接着说：“外实而内虚，烟多而焰少，请损之。”（你的木材外表是干的，里头却是湿的，燃烧起来，会浓烟多而火焰小，请减些价钱吧。）卖材的人因为听不懂秀才的话，于是担着材就走了。管理者最好用简单的语言、易懂的言词来传达信息，而且对于说话的对象、时机要有所掌握，有时过分的修饰反而达不到想要完成的目的。
点评：对于沟通对象的了解是我们进行沟通的基础。
案例5：买复印纸的困境
一老板叫一员工去买下复印纸。员工就去了，买了三张复印纸回来。老板大叫，三张复印纸，怎么够，我至少要三摞。员工第二天就去买了三摞复印纸回来。老板一看，又叫，你怎么买了B5的，我要的是A4的。员工过了几天，买了三摞A4的复印纸回来，老板骂道:怎么买了一个星期，才买好？员工回：你又没有说什么时候要。就买下复印纸，员工跑了三趟，老板气了三次。老板会摇头叹道，员工执行力太差了！员工心里会说，老板能力欠缺，连个任务都交待不清楚，只会指使下属白忙活！
点评：有效地沟通，要做到双向沟通，这是管理机制中最为重要的一部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5315516bdafc61aea240d6faee0fe0/" rel="bookmark">
			Redis缓存穿透、击穿、雪崩问题及其解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis缓存穿透、击穿、雪崩问题及其解决方法 1 缓存穿透1.1 概念及其解决思路1.2 编码解决商品查询的缓存穿透问题： 2 缓存雪崩问题及解决思路3 缓存击穿问题及解决思路3.1 利用互斥锁解决缓存击穿问题3.2 利用逻辑过期解决缓存击穿问题 1 缓存穿透 1.1 概念及其解决思路 缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
常见的解决方案有两种：
缓存空对象 优点：实现简单，维护方便缺点： 额外的内存消耗可能造成短期的不一致 布隆过滤 优点：内存占用较少，没有多余key缺点： 实现复杂存在误判可能 **缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了
**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，
假设布隆过滤器判断这个数据不存在，则直接返回
这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突
1.2 编码解决商品查询的缓存穿透问题： 核心思路如下：
在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的
现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。
小总结：
缓存穿透产生的原因是什么？
用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力 缓存穿透的解决方案有哪些？
缓存null值布隆过滤增强id的复杂度，避免被猜测id规律做好数据的基础格式校验加强用户权限校验做好热点参数的限流 2 缓存雪崩问题及解决思路 缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。
解决方案：
给不同的Key的TTL添加随机值利用Redis集群提高服务的可用性给缓存业务添加降级限流策略给业务添加多级缓存 3 缓存击穿问题及解决思路 缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。
常见的解决方案有两种：
互斥锁逻辑过期 逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大
解决方案一、使用锁来解决：
因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。
假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。
解决方案二、逻辑过期方案
方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。
我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。
这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。
进行对比
**互斥锁方案：**由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响
逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦
3.1 利用互斥锁解决缓存击穿问题 假设有一个场景，店家列表页可以进入店家详情页，所有的店家详情页数据会提前缓存到redis；用户在店铺列表页点击访问店家详情页，此时某一个key失效，缓存查询不到，并且有大量请求访问导致数据库压力增加，此时利用setnx锁住关键业务代码，只允许抢到锁线程进入执行业务，未抢到锁的线程则进行重试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d5315516bdafc61aea240d6faee0fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d7b82bbd60ed74763791734d0aac79/" rel="bookmark">
			RocketMQ的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是Leo！今天来和大家分享RocketMQ的一些用法。
领域模型介绍 Producer: 用于生产消息的运行实体。
Topic: 主题，用于消息传输和存储的分组容器。
MessageQueue: 消息传输和存储的实际单元容器。
Message: 消息传输的最小单元。
ConsumerGroup: 消费者组。
Consumer: 消费者。
Subscription: 订阅关系，发布订阅模式中消息过滤、重试、消费进度的规则配置。
MQ的优势 MQ的明显优势有3个。
应用解耦： 以多服务为例，用户下单，需要通知订单服务和库存服务，我们可以通过MQ消息来解除下单和库存系统的耦合。
异步提速： 以秒杀为例，我们可以先返回秒杀结果，后续再通过MQ异步消息去插入记录和扣减库存等，减少调用的链路长度。
削峰填谷： 将某一时间内的请求量分摊到更多时间处理，比如系统A一秒只能处理10000个请求，但是我有100000个请求需要处理，我可以将请求发到MQ中，再分成10秒去消费这些请求。
当然MQ也有劣势，系统可用性降低，系统复杂度提高，一致性问题。
RocketMQ的主要角色 主要包括Producer、Broker、Consumer、NameServer Cluster。
一对多 可以通过设置不同的消费者组
不同组通过不同的消费者组既可以实现同时收到一样数量的消息，那同一个消费者组需要怎样才能收到同样数量的消息呢？
// 消费者消费模式 consumer.setMessageModel(MessageModel.BROADCASTING); 默认是集群模式CLUSTERING，设置成广播模式
既可以实现一对多的发送。
同步消息（普通消息） 同步消息需要阻塞等待消息发送结果的返回
public class ProducerDemo { public static void main(String[] args) throws MQClientException, MQBrokerException, RemotingException, InterruptedException { DefaultMQProducer producer = new DefaultMQProducer("group1"); producer.setNamesrvAddr("localhost:9876"); producer.start(); Message message = new Message(); message.setTopic("MQLearn"); message.setTags("1.0.0"); message.setBody("Hello MQ!".getBytes(StandardCharsets.UTF_8)); SendResult result = producer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d7b82bbd60ed74763791734d0aac79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be518b48021a729b163eb279296b25dc/" rel="bookmark">
			VGAM | tobit模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专注系列化、高质量的R语言教程
推文索引 | 联系小编 | 付费合集
本篇来介绍tobit模型，使用的工具包是VGAM。
library(VGAM) 目录如下：
1 Tobit分布
2 tobit模型
3 运行模型
例1
例2
例3
4 其他
1 Tobit分布 tobit模型主要应用于因变量存在删失的情况。以正态分布为例，变量的取值范围理论上应为，但实际取值范围只是某个区间。例如在做调查时，年收入在一定区间范围内需要精确统计，而低于或高于某与水平只笼统归类。
这样删失数据的概率分布相比于正态分布就发生了变化：
概率密度分布：
x &lt;- seq(-4, 4, 0.001) plot(x, dnorm(x), type = "l", ylab = "概率密度") lines(x, dtobit(x, Lower = -2, Upper = 2), col = "orange", lty = "dashed") abline(v = -2, lty = "dashed") abline(v = 2, lty = "dashed") legend(x = "topleft", c("正态分布", "Tobit分布"), lty = c("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be518b48021a729b163eb279296b25dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3084c7cbe5e3ca0219afa4455295e75e/" rel="bookmark">
			代码随想录 day15| 层序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 102.二叉树的层序遍历
102.二叉树的层序遍历 解题思路：
层序遍历一个二叉树，就是从左到右一层层去遍历二叉树，和之前的都不一样。 需要借用一个辅助数据结构即队列实现，队列先进后出，符合一层层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
然而 这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。
class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector &lt;vector &lt;int&gt;&gt; ret; if (!root) { return ret; } queue &lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector &lt;int&gt; ()); for (int i = 1; i &lt;= currentLevelSize; ++i) { auto node = q.front(); q.pop(); ret.back().push_back(node-&gt;val); if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); } } return ret; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d964090110d1cffc4cce0fb6b3f4a4c/" rel="bookmark">
			使用VMware安装CentOS7，并配置环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装CentOS7 1.1 通过VMware创建新的虚拟机
1.2 一路下一步，直至
这一步设置好：虚拟机的名称和虚拟机存储的位置
1.3 根据需求配置处理器数和内存大小
1.4 网络类型选择NAT模式
1.5 选择创建新虚拟磁盘，并根据需求选择磁盘大小（我设置为50G）
1.6 选择自定义硬件，并移除声卡
1.7 编辑虚拟机设置，并选择本地的CentOS镜像系统
1.8 至此，完成VMware创建CentOS7，下一步进入系统，并安装CentOS，安装时一路下一步，在系统安装源选择带GUI界面，并按需选择所需组件。
2.设置网络连接 2.1 通过dhclient命令为该虚拟机分配一个可用的ip地址。
2.2 编辑/etc/sysconfig/network-scripts/文件夹中的ifcfg-ens33文件，主要更改的地方为：
2.2.1 将BOOTPROT=dhcp更改为static2.2.2 将ONBOOT=no更改为yes2.2.3 添加： IPADDR=192.168.92.128 # 为刚刚分配的ip地址 GATEWAY=192.168.92.2 NETMASK=255.255.255.0 DNS1=8.8.8.8 2.3 使用命令systemctl restart network.service重启网络服务，然后虚拟机就能ping通外网和宿主机了。
3 出现的问题 3.1 虚拟机能ping通外网和宿主机，但宿主机ping不通虚拟机。
解决方法：在VMware的虚拟网络编辑器勾选将主机虚拟适配器连接到此网络。
如果勾选了没反应，是由于VMware注册表的问题。
解决方法如下：
下载CCleaner软件扫描注册表问题，并选择VMware的问题进行修复： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d600555378e6a7bed2d5001bb847a54f/" rel="bookmark">
			Hexo-Butterfly主题公告语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于Hexo-Butterfly主题公告部分，有好多小伙伴还不知道如何修改，该使用什么语法来编写。当然小编刚开始也是一头雾水，官方文档也没有介绍，网上找了好多教程全部都是关于Butterfly主题公告的打开方法却没有详细说明语法。就在今天突然发现自己的Github仓库里尽然有一个Butterfly主题官方的源码，接着我好奇地打开了里面的主题配置文件找到了公告的语法，具体操作如下
1.打开自己博客的主题配置文件"D:\Blog\themes\hexo-theme-butterfly\_config.yml"
2.找到公告代码
card_announcement: enable: true #是否开启公告 false/true content: 暂无公告 #公告内容 3.使用标准HTML代码进行编译
card_announcement: enable: true content: 普通文字 &lt;a href="#"&gt;蓝色超链接&lt;/a&gt; #更多内容请使用标准的HTML语法编译 &lt;/div&gt; #公告 注意事项 如果出现报错可能是因为代码没有对齐
以上就是本篇文章的所有内容啦 希望对你有帮助
最后祝所有的开发者们五一快乐 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab77b99a636dd1ec403bc02644940b0/" rel="bookmark">
			还在因为指针的释放问题而烦恼吗？快来看下C&#43;&#43;11智能指针shared_ptr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能指针是这样一种类，即其对象的特征类似于指针。例如，智能指针可以存储new分配的内存地址，也可以被解除引用。
因为智能指针是一个类对象，因此它可以修改和扩充简单指针的行为。例如，智能指针可以建立引用技术，这样多个对象可共享由智能指针跟踪同一个值，当使用该值的对象数为0是，智能指针将删除这个值。
智能指针可以提高内存的使用效率，帮助防止内存泄漏，但并不要求用户熟悉新的编程技术
00 | 前言 void test1(int&amp; i_num) { int* num = new string(i_num); // something to do i_num = num; return; } 上面这个函数中存在这样一种缺陷，你发现了吗？
每当调用上面这个函数时，都会从堆中分配内存，但是却没有回收内存，这就导致了内存泄漏的问题，知道的同学都知道只要在最后加上delete num语句就没问题了，不知道的同学就不知道加什么了，所以对不熟悉的同学来说，这个“最后加上delete num”的动作就会经常忘记。那有没有那么一种方法，可以让我们不必关注这个delete num的动作，它在该释放的时候自动释放呢？
对于基本类型来说，暂时是没有这种功能的，但是对于C++类而言，它的析构函数就提供了这样的功能，所以通过类来实现智能指针就可以有效的避免“忘记加上delete语句”导致内存泄漏的情况
int* num1 = new int(2); int* num2 = new int; num2 = num1; delete num2; cout &lt;&lt; *num1 &lt;&lt; endl; cout &lt;&lt; *num2 &lt;&lt; endl; delete num1; 再来看上面的代码，能发现其中的缺陷吗？
两个指针指向同一块地址，那么这时候无论是delete哪个对象，都会释放掉这块内存资源，所以第五行开始输出的就已经不再是本来所指向的资源，而导致num1变成了野指针，最后上面的代码实际对同一个资源对象执行了两次释放动作（资源对象被释放后，如果再去释放该资源，就会会导致系统崩溃）。这就导致在必须使用多个指针指向同一个对象资源的情况下，很容易因为内存的错误释放或者操作已经释放的指针而导致系统崩溃，那怎么规避这个问题？
万不可能说拿笔记住每一个指针声明及调用的地方，人工保证每一个指针的正确声明，引用及释放问题。而对类而言，可以通过对这个智能指针类进行扩展功能来保证共享的资源只会被释放一次，从而有效的解决这个问题。而智能指针shared_ptr就应运而生了
01 | 概念 智能指针shared_ptr的本质是一个用于管理动态内存分配的模板类，它的设计意图是为了解决“当多个智能指针指向同一个对象资源时，错误的内存释放导致系统崩溃”问题，它的设计理念是“采用引用计数，使得在多个智能指针指向同一个对象资源时，给每一个指向这个对象资源的智能指针的引用计数进行算数处理，保证这个共享资源的正确释放”
简单来说，shared_ptr就是一个采用引用计数技术（允许多智能指针指向同一共享对象资源时，且保证该资源仅当引用计数为0时才被释放）的一个模板类实现智能指针。
shared_ptr定义在头文件memory中，其模板定义了类似指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象，同时在类内部定义一份引用计数数据，用来记录这个对象资源被几个对象共享。引用计数规则如下：
1. 当一个shared_pte对象过期时，引用计数减一，并且判断此时引用计数是否为0；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab77b99a636dd1ec403bc02644940b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86f27c989941642106d45f5a40d955c/" rel="bookmark">
			python 通过SMSActivateAPI 如何获取验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 api文档 https://sms-activate.org/cn/api2
要使用SMSActivateAPI库从sms-activate.org获取验证码，您需要按照以下步骤进行：
1 访问sms-activate.org并注册一个帐户。
2 充值您的帐户以获得短信验证码。sms-activate.org为您提供了各种付款方式，包括信用卡、PayPal和加密货币。
3 安装SMSActivateAPI库。可以使用pip命令进行安装：
pip install smsactivateapi 4 在Python代码中导入SMSActivateAPI库并创建API对象。请注意，您需要使用您的sms-activate.org帐户的API密钥来进行身份验证。以下是一个示例代码：
from smsactivate.api import SMSActivateAPI api = SMSActivateAPI('YOUR_API_KEY') 请将YOUR_API_KEY替换为您的sms-activate.org帐户的API密钥。
5 从指定的国家或地区获取手机号码。例如，以下代码将返回一个来自俄罗斯的手机号码：
phone = api.get_number('ru') 6 获取验证码。您可以使用get_sms方法从您的手机获取短信验证码。以下是一个示例代码：
code = api.get_sms(phone.phone_id) 请注意，phone.phone_id是您在上一步中获取的手机号码ID。
7 完成验证码验证后，您可以使用cancel_number方法来释放该号码。以下是一个示例代码：
api.cancel_number(phone.phone_id) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48187ed87f731fae26491271dfb0d627/" rel="bookmark">
			代码随想录 day14 ||144.二叉树的遍历 ，145.二叉树的后序遍历 ， 94.二叉树的中序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 144. 二叉树的前序遍历
每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！
确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历 中--左--右 递归实现 void preOrder1(BinTree *root) //递归前序遍历 { if(root!=NULL) { cout&lt;&lt;root-&gt;data&lt;&lt;" "; preOrder1(root-&gt;lchild); preOrder1(root-&gt;rchild); } } 中序排列 中--左--右 递归实现 void inOrder1(BinTree *root) //递归中序遍历 { if(root!=NULL) { inOrder1(root-&gt;lchild); cout&lt;&lt;root-&gt;data&lt;&lt;" "; inOrder1(root-&gt;rchild); } } 后序遍历 左–右–中
递归实现 void postOrder1(BinTree *root) //递归后序遍历 2 { 3 if(root!=NULL) 4 { 5 postOrder1(root-&gt;lchild); 6 postOrder1(root-&gt;rchild); 7 cout&lt;&lt;root-&gt;data&lt;&lt;" "; 8 } 9 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02de46be68299154ac0d633937a7f3bc/" rel="bookmark">
			c语言 二叉树遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;stdlib.h&gt; #define MaxSize 100 //#define ERROR 0 //#define OK 1 typedef int DataType; /*示例：1 2 4 0 0 5 0 0 3 0 0 先序： 1 2 4 5 3 中序： 4 2 5 1 3 后续： 4 5 2 3 1 示例：8 3 1 0 0 6 4 0 0 7 0 0 19 14 13 0 0 0 0 二叉树的先序序列： 8 3 1 6 4 7 19 14 13 二叉树的中序序列： 1 3 4 6 7 8 13 14 19 二叉树的后序序列： 1 4 7 6 3 13 14 19 8 */ DataType all[19]={8,3,1,0,0,6,4,0,0,7,0,0,19,14,13,0,0,0,0}; int u=0; typedef struct BiTNode { DataType data; struct BiTNode *lchild; struct BiTNode *rchild; } *BiTree,BitNode; typedef struct Queue{ int first; BitNode*data[MaxSize]; int final; }Queue; void CreateBitTree(BiTree *T); /*按照先序输入字符序列递归创建二叉树*/ void PreOrderTraverse(BiTree T); /*二叉树的先序遍历的递归函数*/ void InOrderTraverse(BiTree T); /*二叉树的中序遍历的递归函数*/ void PostOrderTraverse(BiTree T); /*二叉树的后序遍历的递归函数*/ void PreOrderTraverse2(BiTree T); /*二叉树的先序遍历的非递归函数*/ void InOrderTraverse2(BiTree T); /*二叉树的中序遍历的非递归函数*/ void PostOrderTraverse2(BiTree T); /*二叉树的后序遍历的非递归函数*/ void BinaryTreeLeveLOrder(BiTree T);/*二叉树的层次遍历*/ bool enQueue(Queue*&amp; q,BitNode*&amp; T); //入队,层次遍历需求 bool deQueue(Queue*&amp; q,BitNode*&amp; T); //出队,层次遍历需求 bool emptyQueue(Queue*&amp; q); //判断队列是否为空,层次遍历需求 int height(BiTree T);/*二叉树的高度*/ int main() { BiTree T; //构建二叉链表表示的二叉树 T=NULL; //给树初始化 int i=0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02de46be68299154ac0d633937a7f3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8383dc38a68eb2edc9ec7b30648943/" rel="bookmark">
			彻底删除MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装出现问题需要考虑前一次安装未全部删除干净。
1.点击控制面板→卸载程序，卸载掉所有相关的MySQL软件
2.删除安装目录下C:\Program Files的 MySQL文件夹
3.删除目录下C:\ProgramData的删除注册表中HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\EventLog\Application下的MySQL文件夹MySQL文件夹
4.删除注册表中HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\EventLog\Application下的MySQL文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3487459c5cda5b02fe8e9521be407a90/" rel="bookmark">
			word交叉引用参考文献使用逗号隔开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、两篇参考文献 (1) 首先，采用交叉引用的方式插入我们需要的参考文献；
(2) 然后，选中插入的参考文献，右键选择切换域代码；
(3) 接着，在第一个花括号的 \h 后添加 \#"[0" ，在第二个花括号的 \h 后添加 \#"0]" ；
(4) 再选中两个花括号，右键选择更新域，两个参考文献的引用会变为 [ab] ，这里a和b分别代表两个不同的参考文献；
(5) 最后，在[ab]中添加逗号变为[a,b]即可。
2、多篇参考文献 多篇参考文献与两篇参考文献唯一不同的地方就在于步骤(3)。
例如有3篇参考文献，切换域代码之后，我们同样在第一个花括号的 \h 后添加 \#"[0" ，在最后一个花括号的 \h 后添加 \#"0]"。不同的是，对于中间的花括号，每个后面要添加 \#"0" 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43729a40033c4d0a7f7eae11710980eb/" rel="bookmark">
			FPGA使用VGA协议显示图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、实验环境硬件环境软件环境 二、VGA简介1、什么是VGA2、VGA显示原理3、扫描方式 三、VGA显示字符四、VGA显示彩色条纹五、VGA显示彩色图片1、图片格式hex2、ROM IP 核配置3、PLL IP 核配置 六、总结七、参考链接 一、实验环境 硬件环境 FPGA开发板：EP4CE115F29C7
液晶显示器，VGA传输线
软件环境 Quartus Prime 18.1
VS Code
中文点阵生成网站：https://www.zhetao.com/fontarray.html
图片格式bmp转hex软件：BMP2Mif
二、VGA简介 1、什么是VGA VGA(Video Graphics Array)是IBM在1987年随PS/2机一起推出的一种视频传输标准，具有分辨率高、显示速率快、颜色丰富等优点，在彩色显示器领域得到了广泛的应用。不支持热插拔，不支持音频传输。对于一些嵌入式VGA显示系统，可以在不使用VGA显示卡和计算机的情况下，实现VGA图像的显示和控制。VGA显示器具有成本低、结构简单、应用灵活的优点。对于一名FPGA工程师，尤其是视频图像的方向的学习者，VGA协议是必须要掌握的。
由电路图可以看到，VGA并没有特殊的外部芯片，我们需要关注的其实只有5个信号：HS行同步信号，VS场同步信号，R红基色，G绿基色，B蓝基色。下面慢慢解释这些信号。
2、VGA显示原理 VGA通过引脚的模拟电压(0V-0.714V)显示红绿蓝三种颜色，不同的电压值对应不同的颜色。
VGA驱动显示器用的是扫描的方式，一般是逐行扫描。
逐行扫描是扫描从屏幕左上角一点开始，从左像右逐点扫描，每扫描完一行,电子束回到屏幕的左边下一行的起始位置，在这期间，CRT对电子束进行消隐，每行结束时，用行同步信号进行同步；
当扫描完所有的行，形成一帧后，用场同步信号进行场同步，并使扫描回到屏幕左上方，同时进行场消隐,开始下一帧。
FPGA芯片驱动VGA显示，需要先产生模拟信号，这就要借助数模转换器D/A，利用D/A产生模拟信号，输出至VGA的RED、GREEN、BLUE基色数据线。另一种方法是利用电阻网络分流模拟D/A实现的。
设计RGB信号时，既可以R信号、G信号和B信号独立的赋值，最后连到端口上，也可以直接用RGB当做一个整体信号，RGB信号在使用时的位宽有三种常见格式，以你的VGA解码芯片的配置有关。
1. RGB_8，R：G：B = 3：3：2，即RGB332
2. RGB_16，R：G：B = 5：6：5，即RGB565
3. RGB_24，R：G：B = 8：8：8，即RGB888
3、扫描方式 VGA显示器扫描方式分为逐行扫描和隔行扫描：逐行扫描是扫描从屏幕左上角一点开始，从左像右逐点扫描，每扫描完一行,电子束回到屏幕的左边下一行的起始位置，在这期间，CRT对电子束进行消隐，每行结束时，用行同步信号进行同步；当扫描完所有的行，形成一帧，用场同步信号进行场同步，并使扫描回到屏幕左上方，同时进行场消隐,开始下一帧。隔行扫描是指电子束扫描时每隔一行扫一线，完成一屏后在返回来扫描剩下的线，隔行扫描的显示器闪烁的厉害，会让使用者的眼睛疲劳。因此我们一般都采用逐行扫描的方式。
三、VGA显示字符 这里使用到了汉字点阵，需要取汉字点阵：
https://www.zhetao.com/fontarray.html
输入需要的字符，取得相应的汉字点阵：
用于代码中的点阵程序如图：删去其中的0x 以及 逗号 保持此格式，粘贴到代码中。
代码如下：
module VGA_View_name( OSC_50, //原CLK2_50时钟信号 VGA_CLK, //VGA自时钟 VGA_HS, //行同步信号 VGA_VS, //场同步信号 VGA_BLANK, //复合空白信号控制信号 当BLANK为低电平时模拟视频输出消隐电平，此时从R9~R0,G9~G0,B9~B0输入的所有数据被忽略 VGA_SYNC, //符合同步控制信号 行时序和场时序都要产生同步脉冲 VGA_R, //VGA绿色 VGA_B, //VGA蓝色 VGA_G); //VGA绿色 input OSC_50; //外部时钟信号CLK2_50 output VGA_CLK,VGA_HS,VGA_VS,VGA_BLANK,VGA_SYNC; output [7:0] VGA_R,VGA_B,VGA_G; parameter H_FRONT = 16; //行同步前沿信号周期长 parameter H_SYNC = 96; //行同步信号周期长 parameter H_BACK = 48; //行同步后沿信号周期长 parameter H_ACT = 640; //行显示周期长 parameter H_BLANK = H_FRONT+H_SYNC+H_BACK; //行空白信号总周期长 parameter H_TOTAL = H_FRONT+H_SYNC+H_BACK+H_ACT; //行总周期长耗时 parameter V_FRONT = 11; //场同步前沿信号周期长 parameter V_SYNC = 2; //场同步信号周期长 parameter V_BACK = 31; //场同步后沿信号周期长 parameter V_ACT = 480; //场显示周期长 parameter V_BLANK = V_FRONT+V_SYNC+V_BACK; //场空白信号总周期长 parameter V_TOTAL = V_FRONT+V_SYNC+V_BACK+V_ACT; //场总周期长耗时 reg [10:0] H_Cont; //行周期计数器 reg [10:0] V_Cont; //场周期计数器 wire [7:0] VGA_R; //VGA红色控制线 wire [7:0] VGA_G; //VGA绿色控制线 wire [7:0] VGA_B; //VGA蓝色控制线 reg VGA_HS; reg VGA_VS; reg [10:0] X; //当前行第几个像素点 reg [10:0] Y; //当前场第几行 reg CLK_25; always@(posedge OSC_50) begin CLK_25=~CLK_25; //时钟 end assign VGA_SYNC = 1'b0; //同步信号低电平 assign VGA_BLANK = ~((H_Cont&lt;H_BLANK)||(V_Cont&lt;V_BLANK)); //当行计数器小于行空白总长或场计数器小于场空白总长时，空白信号低电平 assign CLK_to_DAC = CLK_25; assign VGA_CLK = ~CLK_to_DAC; //VGA时钟等于CLK_25取反 always@(posedge CLK_to_DAC) begin if(H_Cont&lt;H_TOTAL) //如果行计数器小于行总时长 H_Cont&lt;=H_Cont+1'b1; //行计数器+1 else H_Cont&lt;=0; //否则行计数器清零 if(H_Cont==H_FRONT-1) //如果行计数器等于行前沿空白时间-1 VGA_HS&lt;=1'b0; //行同步信号置0 if(H_Cont==H_FRONT+H_SYNC-1) //如果行计数器等于行前沿+行同步-1 VGA_HS&lt;=1'b1; //行同步信号置1 if(H_Cont&gt;=H_BLANK) //如果行计数器大于等于行空白总时长 X&lt;=H_Cont-H_BLANK; //X等于行计数器-行空白总时长 （X为当前行第几个像素点） else X&lt;=0; //否则X为0 end always@(posedge VGA_HS) begin if(V_Cont&lt;V_TOTAL) //如果场计数器小于行总时长 V_Cont&lt;=V_Cont+1'b1; //场计数器+1 else V_Cont&lt;=0; //否则场计数器清零 if(V_Cont==V_FRONT-1) //如果场计数器等于场前沿空白时间-1 VGA_VS&lt;=1'b0; //场同步信号置0 if(V_Cont==V_FRONT+V_SYNC-1) //如果场计数器等于行前沿+场同步-1 VGA_VS&lt;=1'b1; //场同步信号置1 if(V_Cont&gt;=V_BLANK) //如果场计数器大于等于场空白总时长 Y&lt;=V_Cont-V_BLANK; //Y等于场计数器-场空白总时长 （Y为当前场第几行） else Y&lt;=0; //否则Y为0 end reg valid_yr; always@(posedge CLK_to_DAC) if(V_Cont == 10'd32) //场计数器=32时 valid_yr&lt;=1'b1; //行输入激活 else if(V_Cont==10'd512) //场计数器=512时 valid_yr&lt;=1'b0; //行输入冻结 wire valid_y=valid_yr; //连线 reg valid_r; always@(posedge CLK_to_DAC) if((H_Cont == 10'd32)&amp;&amp;valid_y) //行计数器=32时 valid_r&lt;=1'b1; //像素输入激活 else if((H_Cont==10'd512)&amp;&amp;valid_y) //行计数器=512时 valid_r&lt;=1'b0; //像素输入冻结 wire valid = valid_r; //连线 wire[10:0] x_dis; //像素显示控制信号 wire[10:0] y_dis; //行显示控制信号 assign x_dis=X; //连线X assign y_dis=Y; //连线Y parameter char_line00=240'h004000400000000000000000000000000000000000000000000000000000, char_line01=240'h784020a00000000000000000000000000000000000000000000000000000, char_line02=240'h484011100000000000000000000000000000000000000000000000000000, char_line03=240'h57fe1208000018003c003c00180018007e001800180018007e003c000400, char_line04=240'h508085f60000240042004200240024004200240024002400400042000c00, char_line05=240'h612048000000400042004200420042000400420040004200400042000c00, char_line06=240'h512047c40000400002004200420042000400420040004200400002001400, char_line07=240'h4a20145400005c000400020042004200080042005c004200780004002400, char_line08=240'h4bfc14547e00620018000400420042000800420062004200440018002400, char_line09=240'h482027d40000420004000800420042001000420042004200020004004400, char_line0a=240'h6928e4540000420002001000420042001000420042004200020002007f00, char_line0b=240'h512424540000420042002000420042001000420042004200420042000400, char_line0c=240'h422227d40000220042004200240024001000240022002400440042000400, char_line0d=240'h4422244400001c003c007e0018001800100018001c00180038003c001f00, char_line0e=240'h40a025540000000000000000000000000000000000000000000000000000, char_line0f=240'h404004880000000000000000000000000000000000000000000000000000; reg[7:0] char_bit; always@(posedge CLK_to_DAC) if(X==10'd180)char_bit&lt;=9'd240; //当显示到144像素时准备开始输出图像数据 else if(X&gt;10'd180&amp;&amp;X&lt;10'd420) //左边距屏幕144像素到416像素时 416=144+272（图像宽度） char_bit&lt;=char_bit-1'b1; //倒着输出图像信息 reg[29:0] vga_rgb; //定义颜色缓存 always@(posedge CLK_to_DAC) if(X&gt;10'd180&amp;&amp;X&lt;10'd420) //X控制图像的横向显示边界：左边距屏幕左边144像素 右边界距屏幕左边界416像素 begin case(Y) //Y控制图像的纵向显示边界：从距离屏幕顶部160像素开始显示第一行数据 10'd200: if(char_line00[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; //如果该行有数据 则颜色为红色 else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; //否则为黑色 10'd201: if(char_line01[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd202: if(char_line02[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd203: if(char_line03[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd204: if(char_line04[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd205: if(char_line05[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd206: if(char_line06[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd207: if(char_line07[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd208: if(char_line08[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd209: if(char_line09[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd210: if(char_line0a[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd211: if(char_line0b[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd212: if(char_line0c[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd213: if(char_line0d[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd214: if(char_line0e[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd215: if(char_line0f[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; default:vga_rgb&lt;=30'h0000000000; //默认颜色黑色 endcase end else vga_rgb&lt;=30'h000000000; //否则黑色 assign VGA_R=vga_rgb[23:16]; assign VGA_G=vga_rgb[15:8]; assign VGA_B=vga_rgb[7:0]; endmodule 除了代码外还需要PLL IP核，详情见下文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43729a40033c4d0a7f7eae11710980eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddf6e891edbc44db216d4b926a41c38/" rel="bookmark">
			Docker Compose Demo，一个能帮助你彻底解决使用docker搭建各种服务难题的代码库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介 您是否在工作中用docker搭建服务时，遇到过以下问题：
1.每次都要重复查找搭建服务的docker命令，浪费时间。 2.找到的docker命令各式各样，毫无规范。 3.命令可以使用，但是需要设置的参数残缺不全。 4.对要搭建的服务需要设置的相关参数一知半解，无法配置。 5.不清楚使用的命令是否经过验证，无法保证安全性和可靠性。 👉 Dokcer Compose Demo
docker compose demo 是一个旨在帮助开发者用docker-compose 快速、便捷、可靠地部署相关docker
服务的代码库，目前总共包含 14 个demo。
服务功能简介官方网站jenkins持续集成工具https://www.jenkins.iogitlab代码仓库管理系统https://gitlab.comredis缓存数据库https://redis.ionginx反向代理web服务器https://nginx.comsonarqube源代码检测工具https://www.sonarsource.commysql关系数据库https://dev.mysql.comelastic search分布式的全文搜索引擎https://www.elastic.cologstash服务器端数据处理管道https://www.elastic.cokibana分布式数据分析与可视化平台https://www.elastic.cokafka分布式消息队列https://kafka.apache.orgminio分布式文件存储https://min.iorabbitmq分布式消息队列https://www.rabbitmq.comzookeeper分布式应用程序协调服务https://zookeeper.apache.orgportainerDocker可视化容器管理工具https://www.portainer.io 如果大家还有其他想要搭建的docker服务，可以在issue中提出需求。
项目中docker-compose代码均来自于实践总结，但难免会出现错误，如果您发现有问题，请及时进行反馈，我会在收到反馈后第一时间进行修复。
如果您有已经编写好的docker-compose代码，欢迎提出PR，提前感谢您的贡献。🤝
Docker和Docker-Compose安装 注意：以下脚本已经过linux centos7.x系统测试，其他系统无法保证完全适用。
#!/bin/bash # 更新yum依赖 yum update -y &amp;&amp; yum makecache -y # 安装依赖包 yum install -y yum-uitls device-mapper-persistent-data lvm2 echo 'Install started...' # 安装docker curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo yum install -y docker-ce # 启动docker systemctl enable docker systemctl start docker # 配置docker镜像加速 [ -f /etc/docker/daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ddf6e891edbc44db216d4b926a41c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b870c44ed84cb1ed1f03963b7aebb9d8/" rel="bookmark">
			手工模式链路聚合 &#43; LACP模式链路聚合配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手工模式链路聚合
sy
Enter system view, return user view with Ctrl+Z.
[Huawei]sysna
[Huawei]sysname SW1
[SW1]int Eth-Trunk 1
[SW1-Eth-Trunk1]trunkport GigabitEthernet 0/0/1 to g0/0/3
[SW1-Eth-Trunk1]port link-type trunk
[SW1-Eth-Trunk1]port trunk allow-pass vlan 10 20
sy
Enter system view, return user view with Ctrl+Z.
[Huawei]sysna
[Huawei]sysname SW2
[SW2]int Eth-Trunk 1
[SW2-Eth-Trunk1]trunkport GigabitEthernet 0/0/1 to g0/0/3
[SW2-Eth-Trunk1]port link-type trunk
[SW2-Eth-Trunk1]port trunk allow-pass vlan 10 20
LACP模式链路聚合配置
sys
sysname S1 #更改设备名S1
lacp priority 100 #lacp优先级100
interface Eth-Trunk1 #接口Eth-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b870c44ed84cb1ed1f03963b7aebb9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1b23c0abf6562a5596e40774b72a5e/" rel="bookmark">
			centos7yum配置及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum的使用
yum的命令形式一般是如下：
yum(选项)（参数）
常用选项：
-h ：显示帮助信息
-y ：对所有的提问都回答yes
-c ：指定配置文件
-q ：安静模式（不显示安装过程）
-v : 详细模式（显示安装过程）
-d ：设置调试等级 (0-10)
-e : 设置错误等级（0-10）
-R ：设置yum处理一个命令的最大等却时间
-C ：完全从缓存中运行，不从源下载、更新如何文件
常用参数： -install ：安装rpm软件包
-update ：更新rpm软件包
-check-update ：检查是否有可用的更新rpm软件包 -remove ：删除指定的rpm软件包-list ：显示软件包的信息
-search ：检查软件包的信息
-info : 显示指定的rpm软件包的描述信息和概要信息-clean : 清理yum过期的缓存
-shell ：进入yum的shell提示符-resolvedep ：显示rpm软件包的依赖关系
-localinstall ：安装本地的rpm软件包
-localupdate ：显示本地rpm软件包进行更新
-deplist ：显示rpm软件包的所有依赖关系
yum –选项命令包 -参数，如：yum install vim -y
yum信息
yum的一切信息都存储在一个叫yum.reops.d目录下的配置文件中，通常位于/etc/yum.reops.d目录下。
在这个目录下面有很多文件，都是.repo结尾的，repo文件是yum源（也就是软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用 yum源文件配置方法一：网络源
比较常见的网络源：系统自带网络源，阿里源，清华源；
系统自带网络源使用方法：
系统自带网络源解析：
进入/etc/yum.repo.d/目录下
打开CentOS-Base.repo配置文件，vim /etc/yum.repos.d/CentOS-Base.repo
在这里插入图片描述](https://img-blog.csdnimg.cn/ad90d7b9f3aa40639ce1b039d7d26b7d.png)
在此文件中需要注意的地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c1b23c0abf6562a5596e40774b72a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4ce0e009b705d3f545cdb89141f654/" rel="bookmark">
			内容分发网络CDN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：最近在学习网络知识，要提升客户端访问服务器的速度，如果能就近访问最近的服务器，这时候就要用到CDN
一、CDN的定义
CDN的英文是Content Delivery Network，翻译过来就是：内容分发网络。其实是对象存储进行的缓存层。
作用是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容（就近原则），提高用户访问网站的响应速度。
二、CDN的分发流程
CDN全局负载均衡服务器根据用户请求的IP地址，url等信息，通过查客户端的ip归属地，选择一台用户所属区域的负载均衡设备，告诉用户向这台设备发起请求。
1. 用户发送请求，DNS解析发现配置了CName，得到对应的地址；
2. 再发送请求到对应的地址，通过dns查询得到最近的ip地址并返回给客户端；
3. 用户获取ip并进行请求，如果该ip的节点缓存有数据，则直接返回，没有就要进行回源
流程图片如下
三、优势
1. 可以就近分配cdn节点获取数据，并且获取同一个数据的时候有缓存加速的作用。节省了在服务器中对静态资源文件的获取
2. 可以防止ddos攻击。CDN防止ddos攻击主要是通过流量分散，增加攻击难度，但是如果是有针对性的攻击，还是最终会被逐个击破，所以CDN只是延缓被攻击的时间。
四、回源
距离用户最近的称之为边缘节点，CDN的中心服务器集群被称为二级缓存，再上面就是应用部署的源站。一般边缘节点没数据就去找二级缓存，二级缓存没数据就去找源站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ffd26f65226c1cddf512fb7c0aa6d5/" rel="bookmark">
			long与Long的区别 &amp;&amp; java数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：Java——你知道long和Long有什么区别吗？_long long 区别_刘水镜的博客-CSDN博客
目录
java的数据类型：
long与Long的关系
使用时的区别
java的数据类型： 基本类型包装类longLongintIntegerbyteBytefloatFloatdoubleDouble 在java中有时候的运算必须是两个类对象之间进行的，不充许对象与数字之间进行运算。所以需要有一个对象，这个对象把数字进行了一下包装，这样这个对象就可以和另一个对象进行运算了。
long与Long的关系 Long就是把基础类型long包装成类
public class Long { int i=0; public Long (int i){ this.i=i; } } 使用时的区别 long l1 =1; long l2 =1;Long lc1 = new Long(1); Long lc2 = 1L;相等判断，由于long是基础类型所以可以直接l1 == l2由于Long是类，所以只能lc1.equal(l2)long默认初始值0，Long默认初始值NULL 到底是选择Long 还是long这个还得看具体环境，如果你认为这个属性不能为null,那么就用long，因为它默认初值为0，如果这个字段可以为null，那么就应该选择Long。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/153/">«</a>
	<span class="pagination__item pagination__item--current">154/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/155/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>