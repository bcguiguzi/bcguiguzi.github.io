<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530f3f07374d54a1d8c5d4fff5ddba5d/" rel="bookmark">
			DeleteFile(szFilePath)失败，之后再对文件操作，造成崩溃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用WINAPI函数DeleteFile(szFilePath1)之后：
1.如果不再对szFilePath1文件进行操作 + DeleteFile()函数执行失败=》也不会造成 软体崩溃！
2.如果后续需要对szFilePath1文件进行操作 + DeleteFile()函数执行失败=》就会造成 软体崩溃！
所以，如果后续需要使用，必须要对DeleteFile()函数 返回值，进行检查！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4106e91d9342cc18cd3729c6855fc7d/" rel="bookmark">
			FreeRTOS入门基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTOS是为了更好地在嵌入式系统上实现多任务处理和时间敏感任务而设计的系统。它能确保任务在指定或预期的时间内得到处理。FreeRTOS是一款免费开源的RTOS，它广泛用于需要小型、预测性强、灵活系统的嵌入式设备。
创建第一个任务 任务函数：任务是通过函数来定义的。函数通常看起来像这样的无限循环 void vTaskFunction( void * pvParameters ) { for( ;; ) { // 任务代码 } } 创建任务：使用xTaskCreate()函数来创建一个任务。 xTaskCreate( vTaskFunction, // 任务函数 "TaskName", // 任务名称 STACK_SIZE, // 堆栈大小 NULL, // 参数 TASK_PRIORITY, // 任务优先级 NULL ); // 用来传回创建的任务的句柄 启动调度器：创建任务后，需要启动调度器，这样RTOS就能开始管理这些任务了。 vTaskStartScheduler(); freertos基本组件 FreeRTOS作为一个实时操作系统（RTOS），提供了多种基础组件来组织代码并有效地管理任务。以下是一些FreeRTOS的基本组件：
任务 (Tasks)： 任务是FreeRTOS中的基本执行单位，相当于一个独立的线程。每个任务都有自己的优先级，调度器根据这些优先级来决定运行哪个任务。 队列 (Queues)： 队列用于在任务之间发送和接收数据。它们可以帮助实现任务同步，并提供一种安全传递消息的方法，如事件、内存块等。 #include "FreeRTOS.h" #include "queue.h" // 队列句柄，用于后续的队列操作如发送和接收 QueueHandle_t xQueue; // main() 或者任何初始化函数中 void main() { // 创建一个可以存储10个元素的队列，每个元素大小为sizeof( BaseType_t ) xQueue = xQueueCreate(10, sizeof(BaseType_t)); if (xQueue == NULL) { // 队列创建失败，可能是由于内存不足 // 错误处理代码 } else { // 队列成功创建 // 可以继续使用队列 } // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4106e91d9342cc18cd3729c6855fc7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90dfd4f1d9070bce7876961d322c091e/" rel="bookmark">
			Hadoop大数据应用：HDFS 集群节点缩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验
1.环境
2.HDFS 集群节点缩容
二、问题
1.数据迁移有哪些状态
2.数据迁移失败
一、实验 1.环境 （1）主机
表1 主机
主机架构软件版本IP备注hadoop NameNode （已部署）
SecondaryNameNode （已部署）
ResourceManager（已部署）
hadoop
2.7.7192.168.204.50 node01 DataNode（已部署）
NodeManager（已部署）
hadoop
2.7.7192.168.204.51node02 DataNode（已部署）
NodeManager（已部署）
hadoop
2.7.7192.168.204.52node03 DataNode（已部署）
NodeManager（已部署）
hadoop
2.7.7192.168.204.53node04 DataNode（已部署）
hadoop
2.7.7192.168.204.54需求迁移主机 （2）查看jps
hadoop节点
[root@hadoop ~]# jps node01节点
node02节点
node03节点
node04节点
2.HDFS 集群节点缩容 （1）查看节点状态 （已使用）
node01: 176KB (约等于0.18M )
node02: 280KB (约等于0.28M )
node03: 260KB (约等于0.26M )
node04: 8KB （约等于0.008M）
[root@hadoop hadoop]# ./bin/hdfs dfsadmin -report Configured Capacity: 822126559232 (765.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90dfd4f1d9070bce7876961d322c091e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7315b18a346699e6c7d5ca41aed89661/" rel="bookmark">
			pytorch之诗词生成3--utils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码：
import numpy as np import settings def generate_random_poetry(tokenizer, model, s=''): """ 随机生成一首诗 :param tokenizer: 分词器 :param model: 用于生成古诗的模型 :param s: 用于生成古诗的起始字符串，默认为空串 :return: 一个字符串，表示一首古诗 """ # 将初始字符串转成token token_ids = tokenizer.encode(s) # 去掉结束标记[SEP] token_ids = token_ids[:-1] while len(token_ids) &lt; settings.MAX_LEN: # 进行预测，只保留第一个样例（我们输入的样例数只有1）的、最后一个token的预测的、不包含[PAD][UNK][CLS]的概率分布 output = model(np.array([token_ids, ], dtype=np.int32)) _probas = output.numpy()[0, -1, 3:] del output # print(_probas) # 按照出现概率，对所有token倒序排列 p_args = _probas.argsort()[::-1][:100] # 排列后的概率顺序 p = _probas[p_args] # 先对概率归一 p = p / sum(p) # 再按照预测出的概率，随机选择一个词作为预测结果 target_index = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7315b18a346699e6c7d5ca41aed89661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51264bc1d901eb54c8be95fa6627dadf/" rel="bookmark">
			Linux信号灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：是不同进程间或一个给定进程内部不同线程间同步的机制。类似我们的
PV操作概念：
生产者和消费者场景
Ｐ(Ｓ) 含义如下: if (信号量的值大于0) { 申请资源的任务继续运行； 信号量的值减一； } else { 申请资源的任务阻塞； } V(Ｓ) 含义如下: 信号量的值加一； if (有任务在等待资源) { 唤醒等待的任务，让其继续运行 } 信号灯P操作
int sem_wait(sem_t *sem); 获取资源，如果信号量为0，表示这时没有相应资源空闲，那么调用线程就将挂起，直到有空闲资源可以获取 信号灯V操作
int sem_post(sem_t *sem); 释放资源，如果没有线程阻塞在该sem上，表示没有线程等待该资源，这时该函数就对信号量的值进行增1操作，表示同类资源多增加了一个。如果至少有一个线程阻塞在该sem上，表示有线程等待资源，信号量为0，这时该函数保持信号量为0不变，并使某个阻塞在该sem上的线程从sem_wait函数中返回 注意：编译posix信号灯需要加pthread动态库。
三种信号灯：
Posix 有名信号灯
Posix 无名信号灯 （linux只支持线程同步）
System V 信号灯
Posix 有名信号灯和无名信号灯使用：
有名信号灯打开：
sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value); 参数： name：name是给信号灯起的名字 oflag：打开方式，常用O_CREAT mode：文件权限。常用0666 value：信号量值。二元信号灯值为1，普通表示资源数目 信号灯文件位置：/dev/shm
有名信号灯关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51264bc1d901eb54c8be95fa6627dadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179faf04822c13c981eb742f9f88070e/" rel="bookmark">
			【820复试】计算机组成原理面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.DRAM三种刷新方式(重点)2.指令集体系结构是什么？精简指令集和复杂指令集的区别3.2路映射，内存单位为16字节，一个缓存块16行，要访问的块地址是1000 0001 1101 0011，怎么判断是否命中？4.浮点数标准化的目的是什么？IEEE标准的方法是？5.高级语言和低级语言的概念以及高级语言的优势是什么？6.单中断和多重中断是什么？7.中断处理的适合，恢复现场为什么要关中断？8.外存储器的类别9.例举ALU的6种指令10.程序从读取到执行的流程11.cache(重点)12.计算机的工作过程13.描述一下指令执行过程(重点)14.C语言中浮点数类型及类型转换15.为什么要用二进制来表示数据16.有哪些技术能够提高CPU访存速度？17.虚拟存储器是什么？有哪些虚拟存储器(重点)18.CPU的功能19.引入总线结构的好处20.CPU响应中断要具备哪些条件21.中断响应优先级和中断处理优先级分别指什么？22.中断向量、向量中断、向量地址三者之间是什么关系23.程序中断和调用子程序的区别24.指令流水线(重点)25.数据通路和控制器 1.DRAM三种刷新方式(重点) DRAM（动态随机存取存储器）——主存储器。 存储数据需要定期刷新以防止信息丢失。
三种常见的DRAM刷新方式：
①自刷新：
计数器+定时器。空闲时计数器递增–&gt;达到预设的阈值开始自刷新。刷新期间内部电荷被读出和重新写入，以确保存储的数据不会丢失。——由DRAM自身管理，无需主机干预。
②异步刷新：
由主机或内存控制器发出命令触发的刷新方式。周期性发送刷新请求到DRAM，从而确保数据得到更新。——由系统软件或硬件来管理。
③同步刷新：
与系统的时钟同步。根据系统时钟的周期来执行刷新操作。只需要确保内存控制器和DRAM之间的始终同步即可。
2.指令集体系结构是什么？精简指令集和复杂指令集的区别 指令集体系结构：软件和硬件之间接口的一个完整定义。
定义了一台计算机可以执行的所有知量的集合，每条指令规定了计算机执行什么操作、操作存放的地址空间以及操作数类型。
精简指令集：RISC架构的指令集相对较小且简单，每条指令都执行的操作比较基本，通常只包含简单的算术运算、逻辑操作和存储访问等基本操作。RISC架构通常采用固定长度的指令格式，并且每条指令只执行一个操作。RISC架构的设计目标是简化处理器的设计和实现，提高指令执行速度和系统的性能，同时降低处理器的成本和功耗。
复杂指令集：CISC架构的指令集数量较多且复杂，每条指令可以执行多个操作，包括复杂的地址计算、内存操作、字符串处理等。CISC处理器的指令可以实现更多的功能，但由于指令的复杂性，执行速度相对较慢。CISC架构的指令格式可以是变长的，且一条指令可以执行多个操作，这使得CISC处理器的指令执行过程相对复杂，并且难以实现高效的流水线和超标量等技术。CISC架构的设计目标是提供更多的指令和功能，以便于编程人员编写更简洁、更高级的程序，同时减少程序的指令数目和执行时间。
3.2路映射，内存单位为16字节，一个缓存块16行，要访问的块地址是1000 0001 1101 0011，怎么判断是否命中？ 由块地址可知前12位位标记位，00为组索引，0011为块内偏移。
2路映射中，每组有两个缓存块，所有有8个组(16/2)。
确定访问的组索引00，看目标组中两个缓存块的标记位，查看0中的两个缓存块的标记位，比较目标块的标记位与组内两个缓存块的标记位是否相同，若有任一标记位效题，则命中。
4.浮点数标准化的目的是什么？IEEE标准的方法是？ 浮点数标准化的目的：是为了提高浮点数表示的精度和范围，使得浮点数可以更有效地进行计算和比较。
IEEE标准定义了浮点数的表示形式、操作规则和舍入方式等。IEEE标准中，浮点数采用科学计数法表示，由三部分组成：符号位、指数部分和尾数部分。
符号位：0正1负；
指数部分：浮点数的阶码，以偏移值的形式表示。
尾数部分：表示浮点数的有效数字。
例如：单精度浮点数（32位），1位符号位、8位指数部分、23位尾数部分。
单精度浮点数0.0011010101–&gt;二进制科学计数法：1.1010101*2^(-3)
指数部分为-3，加偏移值位-3+127=124—&gt;二进制：0111 1100
位数部分：1.1010101，一般来说小数点左侧的1被省略，所以尾数部分为101 0101 0000 0000 0000
组合各部分得到IEEE标准下的浮点数表示：
0 (0111 1100) (101 0101 0000 0000 0000)
5.高级语言和低级语言的概念以及高级语言的优势是什么？ 低级语言：是与计算机硬件紧密相关的编程语言，它直接使用计算机的底层结构和指令集来编写程序。（汇编语言、机器语言）
其中汇编语言是一种符号化的表示，每条指令对应到计算机的一条指令，但是仍然与底层的机器指令相对应。而机器语言则是由二进制代码组成，直接由计算机硬件执行。
高级语言：是与计算机硬件无关的编程语言，它使用人类可读的语法和结构来编写程序，而不需要直接考虑底层的硬件细节。 （C、C++、Java、Python）
高级语言的优势：
易学易用：高级语言采用人类可读的语法和结构，使得程序员更容易理解和学习，降低了编程的门槛。
可移植性：高级语言的代码与底层硬件无关，可以在不同的计算机平台上运行，提高了程序的可移植性和跨平台性。
抽象程度高：高级语言提供了丰富的数据结构、算法和函数库，使得程序员能够更高效地进行程序设计和开发，同时提供了更高的抽象程度。
易维护性：高级语言通常具有更清晰、更模块化的代码结构，易于阅读、理解和维护，有利于长期的软件开发和维护。
生产效率高：高级语言具有更高的表达能力和编程效率，可以更快地完成程序开发和调试，提高了生产效率和开发速度。
6.单中断和多重中断是什么？ 单中断：(串行执行)
在单中断系统中，处理器一次只能处理一个中断请求。当一个中断请求被触发时，处理器会暂停当前的任务，跳转到中断服务程序（ISR），执行相应的中断处理操作。在中断处理完成后，处理器会返回到原来的任务继续执行
多重中断：(优先级调度)
在多重中断系统中，处理器可以同时处理多个中断请求。当多个中断请求同时发生时，处理器会根据中断的优先级选择其中一个中断进行处理，而其他的中断请求则被挂起等待。处理器会执行被选中的中断服务程序（ISR），完成相应的中断处理操作。在中断处理完成后，处理器会返回到原来的任务继续执行。
7.中断处理的适合，恢复现场为什么要关中断？ 关中断是为了确保中断处理过程的可靠性和一致性。在处理中断时，为了保证中断处理程序的正确执行，通常需要在进入中断处理程序之前禁止其他中断的触发，以防止其他中断中断当前的中断处理过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179faf04822c13c981eb742f9f88070e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c20290d784f74a3a9b9578a420e44b/" rel="bookmark">
			Jtti：如何在VPS服务器上进行容器化和负载管理?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 VPS 服务器上进行容器化和负载管理可以通过以下步骤完成：
1. 安装 Docker 或其他容器化平台：
首先，在 VPS 服务器上安装 Docker 或其他容器化平台，例如 Podman、LXC 等。可以根据操作系统的不同选择不同的安装方式，一般可以通过包管理工具或者官方网站提供的安装脚本来安装。
2. 创建和管理容器：
使用 Docker 命令或者容器化平台提供的管理工具，创建和管理容器。可以根据需要创建多个容器，并在容器中运行不同的应用程序或服务。
3. 编写 Dockerfile 或容器配置文件：
对于需要定制化的容器，可以编写 Dockerfile 或者其他容器配置文件，定义容器的构建过程和运行环境。在构建容器时，可以根据需要添加依赖、配置环境变量、设置容器启动命令等。
4. 使用容器编排工具进行管理：
如果需要管理多个容器，并实现容器的自动化部署、扩展和负载均衡，可以使用容器编排工具，例如 Kubernetes、Docker Swarm、Nomad 等。这些工具可以帮助您创建容器集群，并自动调度容器到不同的节点上运行，并监控和管理容器的状态和资源使用情况。
5. 监控和调优：
容器化平台通常提供监控和日志功能，可以实时监控容器的运行状态、资源使用情况和日志输出。通过监控和调优，可以及时发现和解决容器中的性能问题和资源瓶颈，提高容器的稳定性和性能。
6. 实现负载均衡和高可用性：
使用容器编排工具或者负载均衡器，实现容器的负载均衡和高可用性。可以将请求分发到多个容器实例上，并在容器出现故障时自动重新调度容器或者启动备用容器，确保服务的持续可用性。
7. 安全配置：
在容器化过程中，务必注意安全配置，包括限制容器的权限、保护容器的敏感数据、更新容器中的软件包等，以防止容器环境遭受攻击和数据泄露。
通过以上步骤，您可以在 VPS 服务器上实现容器化和负载管理，提高应用程序的可靠性、可扩展性和灵活性。同时，确保了更高的资源利用率和更快的部署速度，为应用程序的持续发展提供了良好的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adb1e4c0f2ec56fcce03d98cb1826a1/" rel="bookmark">
			【Mysql】分页排序查询（Order by limit）出现数据丢失和重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Mysql】分页排序查询（Order by limit）出现数据丢失和重复 【1】现象描述【2】问题分析【3】原因分析【4】解决方案 【1】现象描述 列表分页查询接口，sql是用更新时间做降序排序。出现的问题就是第二页的最后一条数据，和第三页的第一条数据是一样的，也就是出现了分页数据重复的问题。
【2】问题分析 分页查询排序后的数据，是一个非常常见的业务场景；但当使用不唯一的字段排序时，分两页查询的数据可能出现数据重复和丢失的错觉。
在执行查询时，MySQL会根据查询优化器的决策来确定数据的检索顺序，如果没有明确的排序规则，结果集的顺序可能会随机，也就是说当我们用更新时间来做排序，而更新时间这个字段的值是不唯一的，同一个更新时间的数据有多条，那么在分页查询时，就可能会在不同页排序后取到相同的数据。
CREATE TABLE `video` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `video_name` varchar(100) DEFAULT NULL, `video_type` int(11) DEFAULT NULL, `create_by` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4; 分页查询时出现重复数据：
【3】原因分析 这个问题在5.6以后的版本都会有，严格的说这并不算一个问题，MySQL官方对order by limit做了优化，就是在排序字段无索引并且列值不唯一时，会使用priority queue(优先队列)
这个优先队列的本质和Java中的堆一样的，可以根据limit的条数维护一个堆。
官方文档也对此做了解释：
如果将LIMIT row_count与ORDER BY结合使用，MySQL会在找到排序结果的前row_count行后立即停止排序，而不是对整个结果进行排序。 如果通过使用索引进行排序，这将非常快。 如果必须执行文件排序，则在找到第一个row_count之前，将选择所有与查询匹配的，没有LIMIT子句的行，并对其中的大多数或全部进行排序。 找到初始行后，MySQL不会对结果集的其余部分进行排序。此行为的一种体现是，带有和不带有LIMIT的ORDER BY查询可能以不同的顺序返回行，如本节后面所述。
如果多个行在ORDER BY列中具有相同的值，则服务器可以自由以任何顺序返回这些行，并且根据整体执行计划的不同，返回值可以不同。 换句话说，这些行的排序顺序相对于无序列是不确定的。
【4】解决方案 为了避免出现这种数据丢失的错觉，我们可以采取以下解决方案：
（1）明确指定ORDER BY子句
在查询中始终使用ORDER BY子句，并指定一个或多个字段，以确保结果按照您的预期顺序返回。例如：
SELECT * FROM video ORDER BY id; （2）使用唯一字段进行排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adb1e4c0f2ec56fcce03d98cb1826a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202274715587e8e16699dc8834197b2f/" rel="bookmark">
			非光滑非凸规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一，非凸函数的近端梯度下降
1，凸函数的近端梯度下降
2，非凸函数的近端梯度下降
一，非凸函数的近端梯度下降 1，凸函数的近端梯度下降 参考近端梯度下降
2，非凸函数的近端梯度下降 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78400b1e5404feb10ba0a75e34d48804/" rel="bookmark">
			Android JNI常用API函数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android JNI常用API函数介绍 一、前言 Android JNI的 普通用法估计很多人都会，网上文章介绍的api感觉不全面或者写得太细了但是并没有汇总显示。
所以感觉有必要写一篇通俗简单、全面的JNI函数API，让JNI初学者对JNI相关内容有个底。
首先要明白JNI函数API定义在哪里？
之后遇到函数API参数不明白的情况，可以进行对比确认。
其实所有jniDemo.cpp调用的api函数都是在 jni.h 文件中定义。
Android13 的Jni.h 目录在：system\extras\module_ndk_libs\libnativehelper\include_jni\jni.h 。
Android Studio 创建JNI工程，点击env的函数方法名，就会跳转到api函数的文件；
比如代码 env-&gt;GetStringUTFChars，按住Ctrl+鼠标点击 GetStringUTFChars 方法，就会跳转到源文件jni.h中；
底层具体实现功能的不同cpp函数的API这里不会介绍，只介绍JNI相关的API函数；
看完本文，你会发现JNI实际使用到的API函数不多，也不难。
Android JNI的基础知识介绍，之前已经有介绍，不熟悉的可以先看看：
Android Jni的介绍和简单Demo实现：
https://blog.csdn.net/wenzhi20102321/article/details/136291126
本文主要介绍Java和底层C++数据交互过程的jniDemo.cpp中相关API函数知识，有兴趣的可以看看。
二、主要函数api和相关内容 1、常用api函数汇总 jni需要使用的API函数其实就是在jni.h代码文件中定义。
在Android JNI开发中，常用的API函数包括以下几个：
（1）JNIEnv结构体相关函数： GetVersion()：获取JNI的版本号。 GetJavaVM()：获取Java虚拟机实例。 NewGlobalRef()：创建全局引用。 DeleteGlobalRef()：删除全局引用。 （2）JavaVM结构体相关函数： AttachCurrentThread()：将当前线程附加到Java虚拟机上。 DetachCurrentThread()：将当前线程从Java虚拟机上分离。 GetEnv()：获取当前线程的JNIEnv实例。 （3）jclass相关函数： FindClass()：查找Java类。 GetMethodID()：获取Java方法的ID。 GetStaticMethodID()：获取静态Java方法的ID。 （4）jobject相关函数： NewObject()：创建Java对象。 CallVoidMethod()：调用Java对象的无返回值方法。 CallObjectMethod()：调用Java对象的有返回值方法。 Call&lt;Type&gt;Method()：调用Java对象的有返回基本数据类型值方法，比如：CallIntMethod() （5）字段相关函数： GetFieldID()：获取Java字段的ID。 GetStaticFieldID()：获取静态Java字段的ID。 Get&lt;Type&gt;Field()：获取Java字段的值。 Set&lt;Type&gt;Field()：设置Java字段的值。 （6）数组相关函数： New&lt;Type&gt;Array()：创建Java数组。比如：NewBooleanArray() Get&lt;Type&gt;ArrayElements()：获取Java数组的元素。比如：GetIntArrayElements() Release&lt;Type&gt;ArrayElements()：释放Java数组的元素。 （7）字符串函数 GetStringUTFChars()：用于将Java字符串转换为C风格的字符串（以UTF-8编码表示）。 GetStringChars()：用于将Java字符串转换为Unicode字符数组。 ReleaseStringUTFChars()：用于释放由GetStringUTFChars获得的C字符串。 ReleaseStringChars()：用于释放由GetStringChars获得的Unicode字符数组。 NewStringUTF()：用于创建一个Java字符串，其内容是以UTF-8编码表示的C风格字符串。 NewString()：用于创建一个Java字符串，其内容是Unicode字符数组。 这些函数是JNI开发中经常使用的API，可以用来在Java和C/C++之间进行数据的传递和调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78400b1e5404feb10ba0a75e34d48804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a1ef238d816f8e02cacc6a50d388a4/" rel="bookmark">
			springboot271制造装备物联及生产管理ERP系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制造装备物联及生产管理ERP系统设计与实现 摘 要 传统办法管理信息首先需要花费的时间比较多，其次数据出错率比较高，而且对错误的数据进行更改也比较困难，最后，检索数据费事费力。因此，在计算机上安装制造装备物联及生产管理ERP系统软件来发挥其高效地信息处理的作用，可以规范信息管理流程，让管理工作可以系统化和程序化，同时，制造装备物联及生产管理ERP系统的有效运用可以帮助管理人员准确快速地处理信息。
制造装备物联及生产管理ERP系统在对开发工具的选择上也很慎重，为了便于开发实现，选择的开发工具为Eclipse，选择的数据库工具为Mysql。以此搭建开发环境实现制造装备物联及生产管理ERP系统的功能。其中管理员管理用户，新闻公告。
制造装备物联及生产管理ERP系统是一款运用软件开发技术设计实现的应用系统，在信息处理上可以达到快速的目的，不管是针对数据添加，数据维护和统计，以及数据查询等处理要求，制造装备物联及生产管理ERP系统都可以轻松应对。
关键词：制造装备物联及生产管理ERP系统；SpringBoot框架，系统分析，数据库设计
Abstract The traditional method of managing public transportation information first takes more time, and secondly, the data error rate is relatively high, and it is more difficult to modify the wrong data, and finally, it is laborious and laborious to retrieve the data. Therefore, installing the public transportation query website software on the computer to play its role in efficient information processing can standardize the public transportation information management process, so that the management work can be systematized and programmed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a1ef238d816f8e02cacc6a50d388a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c336fd5adbc7593c41feda8c7c47f529/" rel="bookmark">
			指针的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.指针，变量的指针，指针变量 由于通过地址能找到所需的变量单元，因此可以说地址“指向该变量单元”。在C语言中，将地址形象化的称为“指针”，一个变量的地址称为该“变量的指针”，意思是通过它能找到以它为地址的内存单元。指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。
在32位程序里，所有类型的指针的值都是一个32位整数。因为32位机中的程序里内存地址全都是32位长，即sizeof(pointer)的值总为4—指针本身占据了4个字节的长度。在64位机中，sizeof(pointer)的值为8。
如果一个变量专门用来存放另一个变量的地址，则它称为“指针变量”，我们说它用来存放指针。定义了一个变量p，它用来保存另一个变量var的地址，这样的p就是指向var的指针变量。
指针变量也是变量，其定义格式为：类型标识符 *指针标识符。*号为地址解析符，表示“指向……的指针”，可以左结合，也可以右结合；其中类型标识符为指针所指向的类型。例如：
char *pc; pc具有char *类型，即pc指向char类型的变量，以1个字节为一个存取单元。
int *pi; pi具有int *类型，即pi指向int类型的变量，以4个字节为一个存取单元。
float* pf; pf具有float *类型，即pf指向float类型的变量，以4个字节为一个存取单元。
char *pc="hello";&lt;==&gt;char *pc;pc="hello";
2.指针变量的引用 C语言中对指针变量的引用主要通过运算符“&amp;”和“*”来实现的。
&amp;——取变量的地址，取指针。
*——取指针变量所指向的变量的值，解引用。
观察下面的程序段：
int x,y,*p; //定义整型变量x、y和整型指针变量p x=168; //初始化x p=&amp;x; //初始化p，存储变量x的地址 y=*p; //初始化y，解引用p 上述内存变化情况如图所示：
若int a=168; int *p=&amp;a;则*&amp;a表示变量a本身，而&amp;*p=&amp;a,表示去变量a的地址。
3.指针的算术运算 指针是有类型的，故指针的算术运算(+,-)是以类型的size为单位“1”的偏移。
char型数组char cArray[5] = {1,2,3,4,5};，假设 char* pc = cArray(&amp;cArray[0])，则“pc+1”表示偏移1个字节（sizeof(char)）到下一个char，即指向cArray[1]=2。
short型数组short sArray[5] = {1,2,3,4,5};，假设short* ps = sArray(&amp;sArray[0])，则“ps+2”表示偏移4个字节(2*sizeof(short))到下下一个short，即指向sArray[2]=3。
int型数组int iArray[5] = {1,2,3,4,5};，假设int* pi = iArray(&amp;iArray[0])，则“pi+3”表示偏移12个字节（3*sizeof(int)）到下下下一个int，即指向iArray[3]=4。 int x,y,*p=&amp;x;假设x,y,p顺序存放，则指针的自增自减归纳如下：
原操作
等价操作
y=*++p;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c336fd5adbc7593c41feda8c7c47f529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2993dd7413af8c3304e66102515826d/" rel="bookmark">
			论文阅读——Align before Fuse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Align before Fuse: Vision and Language Representation Learning with Momentum Distillation
image-text contrastive learning(ITC)用在单模态，masked language modeling (MLM) and image-text matching (ITM) 用在多模态。
单模态编码器的表示上引入了中间图像文本对比（ITC）损失，目的是在融合前更好地学习单模态表征：
（1）它对齐图像特征和文本特征，使多模态编码器更容易执行跨模态学习;
（2）改进了单模态编码器，以更好地理解图像和文本的语义；
（3）它学习一个共同的低维空间来嵌入图像和文本，这使得图像文本匹配目标能够通过我们的对比硬负挖掘找到更多信息样本。
就是对图片和文本的[CLS]token经过encoder后得到，，经过线性映射得到，，（gv 和 gw 是将 [CLS] 嵌入映射到归一化低维（256-d）表示的线性变换）计算相似度（点乘），然后使匹配的相似度接近1 ，不匹配的接近0。维护两个队列来存储来自动量单模态编码器的最新 M 个图像文本表示，归一化后为。然后每张图片和其他M个文本，每个文本和其他M个图片都计算相似度。
Masked Language Modeling利用图像和上下文文本来预测掩码单词。我们以 15% 的概率随机屏蔽输入标记，并将其替换为特殊标记 [MASK]。MLM最小化屏蔽文本token预测和真实token之间的交叉熵。
Image-Text Matching预测一对图像和文本是正（匹配）还是负（不匹配）。我们使用多模态编码器的 [CLS] 标记的输出embedding作为图像-文本对的联合表示，并附加一个全连接（FC）层，然后是 softmax 来预测二类概率。
如果负图像-文本对具有相似的语义但在细粒度细节上有所不同，它们是困难样本。、
我们提出了一种策略，以零计算开销对 ITM 任务进行硬负例采样。如果负图像-文本对具有相似的语义但在细粒度细节上有所不同，那么它们就很困难。我们使用等式 1 中的对比相似性来查找批量中的硬负例。对于小批量中的每张图像，我们按照对比相似度分布从同一批次中采样一个负文本，其中与图像更相似的文本有更高的机会被采样。同样，我们还为每个文本采样一张硬负片图像。
总损失：
Momentum Distillation
用于预训练的图像文本对主要是从网络上收集的，并且它们往往是有噪声的。正对通常是弱相关的：文本可能包含与图像无关的单词，或者图像可能包含文本中未描述的实体。对于 ITC 学习，图像的否定文本也可能与图像的内容匹配。对于 MLM，可能存在与同样好（或更好）描述图像的注释不同的其他词。然而，ITC 和 MLM 的独热标签会惩罚所有负面预测，无论其正确性如何。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ea2bc464174ce2f6d38420f15c7188/" rel="bookmark">
			Linux第77步_处理Linux并发的相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解linux中的“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体，以及相关函数。
并发就是多个“用户”同时访问同一个共享资源。如：多个线程同时要求读写同一个EEPROM芯片，这个EEPROM就是共享资源，为了保证读写的正确性，其它线程必须等待“持有者”释放使用权限，才可以使用该EEPROM。并发带来的问题就是竞争。Linux采用“原子整形数据”操作、“原子位数据”操作、自旋锁、读写锁、顺序锁、信号量和互斥体的函数来解决并发与竞争。
1、Linux系统并发产生的原因:
1)、多线程并发访问。
2)、抢占式并发访问，从2.6版本内核开始，Linux内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。
3)、中断程序并发访问。
4)、SMP(多核)核间并发访问。
注意：SOC称为系统级芯片，也有称片上系统。
如果线程A和线程B修改同一个存储单元，如果没有竞争，就会按照下面的流程执行，都会得到正确的结果。
线程A:
ldr r0, =0X30000000 /* r0=0X30000000 */
ldr r1, =10 /* r1=10 */
str r1, [r0] /*将地址0X30000000的存储单元设置为10*/
线程B:
ldr r0, =0X30000000 /* r0=0X30000000 */
ldr r1, =20 /* r1=20 */
str r1, [r0] /*将地址0X30000000的存储单元设置为20*/
如果线程A和线程B发生竞争，地址0X30000000的存储单元设置的值可能是错误的。
2、原子操作：
原子操作是指不能再进行分割的操作。主要指整型变量操作或者位变量操作。
1)、“原子整形数据”操作：
①、在“include/linux/types.h”文件中，atomic_t的结构体如下
如果是32位的系统级芯片，Linux内核定义的32位原子结构体如下：
typedef struct {
int counter;
}atomic_t;
如果是64位的系统级芯片，Linux内核也定义了64位原子结构体如下：
typedef struct {
s64 counter;
} atomic64_t;
②、“原子整形数据”操作函数:
ATOMIC INIT(int i)
定义原子变量的时候对其初始化；
int atomic read(atomic_t *v)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ea2bc464174ce2f6d38420f15c7188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd48c96450ba60976631d0b7f93290c6/" rel="bookmark">
			网页防篡改：网络安全界的“护宝奇兵”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我们要聊的是一个非常“正经”但又有点“神秘”的话题——网页防篡改。听起来是不是有点像电影里的“护宝奇兵”，时刻守护着网络世界的宝藏，防止被那些“坏蛋”偷走或破坏？没错，网页防篡改技术就是我们网络世界里的“护宝奇兵”！
首先，让我们来了解一下什么是网页篡改。简单来说，就是有人偷偷溜进你的网站，像调皮的小猴子一样，把你的网页内容改得面目全非。可能是把原价100的商品改成了1元，吸引大家疯狂抢购；或者把重要的公告替换成了“今晚八点，全体员工KTV聚会”这样的搞笑信息。这种行为不仅让人哭笑不得，还可能造成严重的后果。
那么，网页防篡改技术是如何成为我们的“护宝奇兵”的呢？
首先，它有一双“火眼金睛”。通过哈希算法，它能够对网页内容进行摘要计算，生成一个独一无二的哈希值。这就像给每个网页贴上了一个独特的“标签”。当有人试图篡改网页时，这个“标签”就会发生变化。这时，“护宝奇兵”就能立刻发现异常，并发出警报。
其次，它还有一身“好武艺”。利用公钥密码学原理，它可以对网页内容进行数字签名。这就像给网页穿上了一件“防弹衣”，即使有人想篡改它，也需要花费巨大的代价和精力。而且，一旦有人试图破解这件“防弹衣”，“护宝奇兵”也能立刻察觉并采取行动。
最后，它还有一个“恢复神技”。通过实时监测和恢复机制，一旦发现网页被篡改，“护宝奇兵”就能立即启动恢复程序，将网页内容还原到最初的状态。这就像时间倒流一样，让网页恢复到它原本的样子。
有了这位“护宝奇兵”，我们就可以放心大胆地畅游网络世界了。无论是购物、看新闻还是浏览政府公告，我们都可以信任网页上呈现的信息是真实可靠的。而且，这位“护宝奇兵”还在不断地学习和进化，提高自己的防护能力，以应对越来越复杂的网络威胁。
目前网页防篡改技术已广泛应用于政府、金融、电商等领域，为这些领域提供了强大的安全保障。例如，政府机构的官方网站通常采用网页防篡改技术，确保发布的政策、公告等信息真实可靠；金融机构的网上银行系统也采用该技术，保护用户的资金安全；电商平台则利用网页防篡改技术，防止商品价格、支付链接等关键信息被篡改，维护市场秩序。
当然，我们也要明白，网页防篡改技术并不是万能的。它只能在一定程度上保护我们的网络安全。我们还需要提高自己的网络安全意识，不轻易点击来路不明的链接，不随意下载未知来源的文件。只有这样，我们才能和“护宝奇兵”一起，共同守护网络世界的和平与安宁。
总之，网页防篡改技术就像一位英勇的“护宝奇兵”，时刻守护着我们的网络安全。让我们向这位“护宝奇兵”致敬，并感谢它为我们的网络生活带来的安全与便利！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b111d426fa85f5943bb045a0a28ce421/" rel="bookmark">
			Http协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Http协议1、Http 相关概念2、访问浏览器的过程3、Http协议通信过程4、HTTP 相关技术4.1 WEB开发语言4.1.1 html4.1.2 CSS4.1.3 js 4.2 MIME4.3 URI(i) 和URL4.4 网站访问量4.5 HTTP工作机制4.5.1 一次http事务包括4.5.2 Web资源4.5.3 资源类型4.5.4 HTTP连接请求4.5.5 串行和并行连接4.5.6 串行,持久连接和管道4.5.7 提高HTTP连接性能 4.6 HTTP协议版本4.6.1 http/0.94.6.2 http/1.04.6.3 http/1.14.6.4 HTTP1.0和HTTP1.1的区别4.6.5 HTTP1.0和1.1的问题4.6.6 HTTPS协议4.6.7 HTTPS 特点4.6.8 HTTP2协议 4.7 HTTP 请求访问的完整过程4.7.1 建立连接4.7.2 接收请求4.7.3 处理请求4.7.4 访问资源4.7.5 构建响应报文4.7.6 发送响应报文4.7.7 记录日志 5、http协议及报文头部结构5.1 HTTP请求报文5.1.1 方法5.1.2 url：指明资源的具体位置5.1.3 首部字段 5.2 响应报文5.2.1 状态码 Http协议 1、Http 相关概念 **互联网：**是网络的网络，是所有类型网络的母集
**因特网：**世界上最大的互联网网络。即因特网概念从属于互联网概念。习惯上，大家把连接在因特网上的计算机都成为主机。
**万维网：**WWW（world wide web）万维网并非某种特殊的计算机网络，是一个大规模的、联机式的信息贮藏库，使用链接的方法能非常方便地从因特网上的一个站点访问另一个站点（超链技术），具有提供分布式服务的特点。万维网是一个分布式的超媒体系统，是超文本系统的扩充，基于B/S架构实现
**URL：**万维网使用统一资源定位符（Uniform Resource Locator）来标志万维网上的各种文档，并使每个文档在整个因特网的范围内具有唯一的标识符URL。
**HTTP：**为解决"用什么样的网络协议来实现整个因特网上的万维网文档”这一难题，就要使万维网客户程序（以浏览器为主，但不限于浏览器）与万维网服务器程序之间的交互遵守严格的协议，即超文本传送协议（HyperText Transfer Protocol）。HTTP是处于应用层的协议，使用TCP传输层协议进行可靠的传送。因此，需要特别提醒的是，万维网是基于因特网的一种广泛因特网应用系统，且万维网采用的是HTTP（80/TCP）和 HTTPS（443/TCP）的传输协议，但因特网还有其他的网络应用系统（如：FTP、SMTP等等）。
**HTML：**为了解决"怎样使不同作者创作的不同风格的万维网文档，都能在因特网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接”这一问题，万维网使用超文本标记语言（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从页面的某处链接到因特网的任何一个万维网页面，并且能够在自己的主机品目上将这些页面显示出来。HTML与txt一样，仅仅是是一种文档，不同之处在于，这种文档专供于浏览器上为浏览器用户提供统一的界面呈现的统一规约。且具备结构化的特征，这是txt所不具备的强制规定。
2、访问浏览器的过程 HTTP访问的过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b111d426fa85f5943bb045a0a28ce421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02deb4c9f45e7cb6a981cb5f04dae3c9/" rel="bookmark">
			【嵌入式——QT】QThread创建多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——QT】QThread创建多线程 概述主要函数图示代码示例 概述 QThread类提供不依赖于平台的管理线程的方法，一个QThread类的对象管理一个线程，一般从QThread继承一个自定义类，并重定义虚函数run()，在run()函数里实现线程需要完成的任务。
将应用程序的线程称为主线程，额外创建的线程称为工作线程，一般在主线程里创建工作线程，并调用start()开始执行工作线程的任务。start()会在内部调用run()函数，进入工作线程的时间循环，在run()函数调用exit()或quit()可以结束线程的事件循环，或在主线程里调用terminate()强制结束线程。
主要函数 信号
void finished()：线程结束时发射此信号；void started()：线程开始执行、run()函数被调用之前发射此信号； 槽函数
quit()：退出线程的事件循环，并返回代码0，等效于exit(0)；
start(QThread::Priority priority = InheritPriority)：内部调用run()开始执行线程，操作系统根据Priority参数进行调度；
terminate()：终止线程的运行，但不是立即结束线程，而是等待操作系统结束线程，使用terminate()之后应使用wait()；
Priority
QThread::IdlePriority： 仅在没有其他线程运行时调度；QThread::LowestPriority：比低优先级安排得更少；QThread::LowPriority：比NormalPriority更少被安排；QThread::NormalPriority：操作系统的默认优先级；QThread::HighPriority：比NormalPriority更经常被安排；QThread::HighestPriority：比高优先级安排得更频繁；QThread::TimeCriticalPriority：尽可能多安排时间；QThread::InheritPriority：使用与创建线程相同的优先级。这是默认值； 公共函数
bool isFinished() const：线程是否结束；bool isRunning() const：线程是否正在运行；priority() const：返回线程的优先级；setPriority(QThread::Priority priority)：设置线程的优先级；exit(int returnCode = 0)：退出线程的事件循环；wait(unsigned long time)：阻止线程执行，直到线程结束，或等待线程超过time毫秒； 静态公共函数
idealThreadCount()：返回系统上能运行的线程的理想个数；msleep(unsigned long msecs)：强制当前线程休眠msecs毫秒；sleep(unsigned long secs)：强制当前线程休眠secs秒；usleep(unsigned long usecs)：强制当前线程休眠usecs微秒； 保护函数
int exec()：由run()函数调用，进入线程的事件循环，等待exit退出；virtual void run()：start()调用run()函数开始线程任务的执行，所以在run()函数里实现线程的任务功能； 图示 代码示例 QDiceThread.h
#ifndef QDICETHREAD_H #define QDICETHREAD_H #include &lt;QObject&gt; #include &lt;QThread&gt; #include &lt;QMutex&gt; class QDiceThread : public QThread { Q_OBJECT public: QDiceThread(); ~QDiceThread(); void run() Q_DECL_OVERRIDE; void diceBegin();//掷一次骰子 void dicePause();//暂停 void stopThread();//结束线程 bool readValue(int* seq, int* diceValue); signals: void newValue(int seq, int diceValue);//产生新点数的信号 private : int m_seq = 0;//掷骰子次数序号 int m_diceValue;//骰子点数 bool m_paused = true;//暂停 bool m_stop = false;//停止 QMutex mutex; }; #endif // QDICETHREAD_H QDiceThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02deb4c9f45e7cb6a981cb5f04dae3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66eeb6b67f0a547529735a5c00a38f8a/" rel="bookmark">
			数据结构入门篇 之 【双链表】的实现讲解（附完整实现代码及顺序表与线性表的优缺点对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一日读书一日功，一日不读十日空
书中自有颜如玉，书中自有黄金屋
一、双链表 1、双链表的结构 2、双链表的实现 1）、双向链表中节点的结构定义 2）、初始化函数 LTInit 3）、尾插函数 LTPushBack 4）、头插函数 LTPushFront 5）、尾删函数 LTPopBack 6）、头删函数 LTPopFront 7）、查找函数 LTFind 8）、在指定位置之后插入数据函数 LTInsert 9）、删除指定位置数据函数 LTErase 10）、销毁函数 LTDesTroy 二、双链表完整代码 三、顺序表和链表的优缺点对比 四、完结撒❀ 前言
学习前先思考3个问题：
1.顺序表和链表的关系是什么？2.链表的分类有哪些？3.顺序表和链表的优缺点有哪些？ –❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–
1.顺序表和链表的关系是什么
我们之前学习了“顺序表”，“单链表”。
链表和顺序表都是线性表。
线性表是指
逻辑结构：一定是线性的。
物理结构：不一定是线性的。
物理结构是指表在内存中开辟的空间结构，顺序表的物理结构是连续的，而链表的物理结构是不连续的，但它们的逻辑结构都是连续的。
2.链表的分类有哪些？
链表根据带头或者不带头，单向或者双向，循环或者不循环一共分为8种。
我们之前所学的单链表全名是叫：不带头单向不循环链表，而现在要学习的双链表是叫带头双向循环链表。
双链表：
掌握单链表和双链表对于其他链表的实现也就不那么困难了。
3.顺序表和链表的优缺点有哪些？
这里涉及到顺序表和链表的对比，先讲解双向链表，这放到博客末尾为大家对比讲解
一、双链表 1、双链表的结构 注意：这里的“带头”跟前面我们说的“头节点”是两个概念。
带有节点里的头节点实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这里“放哨的”
“哨兵位”存在的意义：
遍历循环链表避免出现死循环。
2、双链表的实现 对于双向链表的实现，我们依然使用List.h,List.c,test.c,三个文件进行实现。
1）、双向链表中节点的结构定义 上面我们简单介绍过双链表，其全名为：带头双向循环链表。
带头：指链表中带有哨兵位。
双向：双链表的每个节点内含有两个链表指针变量，分别指向前一个节点和后一个节点，所以就可以通过一个节点找到这个节点前后的两个节点。
循环：链表中的每个节点互相连接，最后一个节点与哨兵位相连构成一个环，整体逻辑结构可以进行循环操作。
代码如下：
//定义双向链表中节点的结构 typedef int LTDataType; typedef struct ListNode { struct ListNode* prev; LTDataType data; struct ListNode* next; }LTNode; 这里将结构体进行了重命名为LTNode。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66eeb6b67f0a547529735a5c00a38f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8754d70b21f19a10d0e2d06389bc0f/" rel="bookmark">
			基于单片机的家庭防盗报警系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着社会的发展，人们生活水平的不断提高和家居用品的高档化，家庭安全隐患也随之增加，所以人们便进一步提高了对家庭的保护意识。因此，这就不得不促使安全防盗报警系统的普及与推广。
然而传统的防盗措施难以实现人们的需求，所以本设计根据要求设计了一款基于GSM网络的家庭防盗系统。设计以STC89C52单片机为核心，采用红外传感器作为前端探测器，通过GSM移动网络，将报警信息直接发送给用户，使用户能够及时作出相应的措施减少甚至防止受到损失。
随着无线通讯网络在世界范围内的发展，本设计采用的GSM模块充分体现了它的存在价值，比只采用声光报警系统更具有实用性和智能化，拥有较好的应用前景。本文详细介绍了防盗报警器的设计过程，对主要硬件电路和软件功能的实现做了深入的研究分析。本设计所实现的安防功能具有性价比高、隐蔽性强、能耗低、灵敏度高、抗干扰能力强等优点。
关 键 词 :防盗报警；智能家居；GSM网络；短信息
ABSTRACT
With the development of society, people’s living standards continue to improve and the high-end home appliances, family security risks also increase, so people will further enhance the awareness of the protection of the family. Therefore, this will have to promote the popularization and promotion of security alarm system.
However, the traditional security measures are difficult to achieve the needs of people, so the design according to the requirements of the design of a network based on the GSM home security system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c8754d70b21f19a10d0e2d06389bc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f0f6d1e110d02bd1e977f8b9ec0546/" rel="bookmark">
			蓝桥杯算法基础（15）：十大排序算法（堆排序）c语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆排序 外堆： 需要一段和原来数组长度大小的内存空间，这段内存空间是用来存储堆结构的 内堆： 不需要重新申请内存，直接原来的数组上进行排序 堆结构 本质上就是一个完全二叉树（不了解二叉树可以取学习一下二叉树的基本概念），每一个节点的存储都是连续的 知道当前下标为current 从0开始计数 左子树下标--&gt;2*current+1 右子树下标--&gt;2*current+2 从1开始计数 左子树下标--&gt;2*current 右子树下标--&gt;2*current+1 大顶堆 父亲的权值比左右子树的权值大 小顶堆 父亲的权值比左右子树的权值小 (小顶堆) 2 / \ 3 4 /\ / 8 7 6 （大顶堆） 8 /\ 7 3 /\ /\ 3 5 2 0 / 2 完全二叉树中间是不能有空的 (以下二叉树就不是完全二叉树) 8 /\ 7 3 /\ /\ 3 5 2 0 / \ 2 4 堆结构 //外堆 typedef struct Heap{ int* root; int length; }Heap; (伪代码)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f0f6d1e110d02bd1e977f8b9ec0546/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/20/">«</a>
	<span class="pagination__item pagination__item--current">21/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/22/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>