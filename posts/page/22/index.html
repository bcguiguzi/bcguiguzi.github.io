<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1688d0d46101ff0bbbff0789841657/" rel="bookmark">
			Vue.js&#43;SpringBoot开发APK检测管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 开放平台模块2.3 软件档案模块2.4 软件检测模块2.5 软件举报模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 开放平台表3.2.2 软件档案表3.2.3 软件检测表3.2.4 软件举报表 四、系统展示五、核心代码5.1 查询开放平台5.2 新增开放平台5.3 查询软件档案5.4 新增软件举报5.5 新增软件检测 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的APK检测管理系统，包含了软件档案模块、软件检测模块、软件举报模块、开放平台模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，APK检测管理系统基于角色的访问控制，给软件管理员、普通用户使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
随着移动应用的迅猛发展，APK文件的数量和复杂性日益增加，给应用市场的安全性和稳定性带来了巨大挑战。为了提高APK文件的检测效率和准确性，本论文提出了一种基于大数据和机器学习的APK检测系统。该系统利用大数据技术对海量的APK文件进行收集和存储，并采用特征提取和特征选择方法对APK文件进行表征。通过构建一个深度学习模型，对APK文件进行分类和检测，以识别潜在的恶意软件和安全隐患。实验结果表明，该系统在APK检测的准确性和效率方面表现出色，对于提高移动应用的安全性具有重要意义。
1.2 项目录屏 二、功能模块 APK检测系统的功能性需求主要包含数据中心模块、开放平台模块、软件档案模块、软件检测模块、软件举报模块这五大模块，系统是基于浏览器运行的web管理后端，其中各个模块详细说明如下。
2.1 数据中心模块 数据中心模块包含了APK检测系统的系统基础配置，如登录用户的管理、运营公司组织架构的管理、用户菜单权限的管理、系统日志的管理、公用文件云盘的管理。
其中登录用户管理模块，由管理员负责运维工作，管理员可以对登录用户进行增加、删除、修改、查询操作。
组织架构，指的是高校的组织架构，该模块适用于管理这些组织架构的部门层级和教师的部门归属情况。
用户菜单权限管理模块，用于管理不同权限的用户，拥有哪些具体的菜单权限。
系统日志的管理，用于维护用户登入系统的记录，方便定位追踪用户的操作情况。
公用云盘管理模块，用于统一化维护APK检测系统中的图片，如合同签订文件、合同照片等等。
2.2 开放平台模块 开放平台是一种三方接口平台，支持其他用户通过API接口的方式调用系统功能，开放平台的数据包括主体名称、主体介绍、应用ID、密匙、创建人、创建时间、更新人、更新时间，管理员可以新增、删除、编辑和条件查询开放平台数据，用户可以查询管理员发布的开放平台数据。
2.3 软件档案模块 软件是APK检测系统的核心实体，需要建立软件档案模块对用户发布的软件进行管理，软件档案的字段包括软件名称、软件介绍、开发者、文件、创建人、创建时间、更新人、更新时间，管理员可以新增、删除、编辑和条件查询软件数据，用户可以查询管理员发布的软件数据，且可以上传自己的软件。
2.4 软件检测模块 有了软件档案之后，就需要对软件进行检测，用户提交软件检测申请后，保存在软件检测模块，软件检测的字段包括软件ID、软件名称、软件介绍、开发者、检测状态、检测时间、检测人、检测结论，管理员收到用户的软件检测申请后进行检测，并将检测结论录入到系统中。
2.5 软件举报模块 除了用于提交软件检测申请之外，还支持用户直接举报软件，管理员对齐进行判定，举报的数据存储在软件举报模块中，软件举报字段包括软件ID、软件名称、软件介绍、开发者、举报内容、处理结果、处理人、处理时间，用户可以提交软件举报申请，管理员对用户举报的申请订单进行核实。
三、系统设计 3.1 用例设计 UML是面向对象的图形化建模语言，具有表示容易，定义友好，适用范畴广泛，功能强大。用例图是用例模型的一种，需求分析人员可采用用例图表示用户操作行为。APK检测系统的用例图设计主要包括用户用例设计和管理员用例设计。
3.2 数据库设计 3.2.1 开放平台表 3.2.2 软件档案表 3.2.3 软件检测表 3.2.4 软件举报表 四、系统展示 五、核心代码 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d1688d0d46101ff0bbbff0789841657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91eee7566758859f871b85b8113f33a1/" rel="bookmark">
			QThread常用相关函数、线程启动方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用相关函数 可以将常用的函数按照功能进行以下分类：
线程启动
void start()
调用后会执行run()函数，但在run()函数执行前会发射信号started()，操作系统将根据优先级参数调度线程。如果线程已经在运行，那么这个函数什么也不做。优先级参数的效果取决于操作系统的调度策略。
线程执行
int exec()
每一个线程可以有自己的事件循环，可以通过调用exec()函数来启动事件循环。
void run()
线程的起点，在调用start()之后，新创建的线程就会调用这个函数，默认实现调用exec()，大多数需要重新实现这个函数，便于管理自己的线程。该函数返回后，线程便执行结束，就像应用程序离开main()函数一样。
线程退出
void quit()
使线程退出事件循环，返回0表示成功，相当于调用了QThread::exit(0)。
void exit(int returnCode = 0)
使线程退出事件循环，返回0表示成功，任何非0值表示失败。
void terminate()
在极端情况下，可能想要强制终止一个正在执行的线程，这时可以使用terminate()函数。但是，线程可能会立即被终止也可能不会，这取决于操作系统的调度策略，使用terminate()之后再使用QThread::wait()，以确保万无一失。
警告：使用terminate()函数，线程可能在任何时刻被终止而无法进行一些淸理工作，因此该函数是很危险的，一般不建议使用，只有在绝对必要的时候使用。
void requestInterruption()
Qt5新引入接口，请求线程的中断，用于关闭线程。该请求是咨询意见并且取决于线程上运行的代码，来决定是否及如何执行这样的请求。此函数不停止线程上运行的任何事件循环，并且在任何情况下都不会终止它。
线程等待
void msleep(unsigned long msecs) [static]
强制当前线程睡眠msecs毫秒。
void sleep(unsigned long secs) [static]
强制当前线程睡眠secs秒。
void usleep(unsigned long usecs) [static]
强制当前线程睡眠usecs微秒。
bool wait(unsigned long time = ULONG_MAX)
线程将会被阻塞，等待time毫秒。和sleep不同的是，如果线程退出，wait会返回。
线程状态
bool isFinished() const
判断线程是否结束
bool isRunning() const
判断线程是否正在运行
bool isInterruptionRequested() const
如果线程上的任务运行应该停止，返回true；可以使用requestInterruption()请求中断。 Qt5新引入接口，用于使长时间运行的任务干净地中断。从不检查或作用于该函数返回值是安全的，但是建议在长时间运行的函数中经常这样做。注意：不要过于频繁调用，以保持较低的开销。示例程序如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91eee7566758859f871b85b8113f33a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065baa36bca7c047ae2ea3fea3805240/" rel="bookmark">
			List 多个集合如何找出重复的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多个集合如何取出交集(重复的数据)
import java.util.*; import java.util.function.Function; import java.util.stream.Collectors; import java.util.stream.Stream; public class CollectionDuplicates { public static void main(String[] args) { // 方法1 List&lt;Integer&gt; list1 = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; list2 = Arrays.asList(4, 5, 6, 7, 8); List&lt;Integer&gt; list3 = Arrays.asList(5, 6, 8, 9); Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(list1); Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(list2); Set&lt;Integer&gt; set3 = new HashSet&lt;&gt;(list3); set1.retainAll(set2); set1.retainAll(set3); System.out.println("重复元素: " + set1); // 方法2 List&lt;Integer&gt; duplicates = Stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065baa36bca7c047ae2ea3fea3805240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f4adffa617df54ddb582b22b9d94b2/" rel="bookmark">
			Sora: A Review on Background, Technology, Limitations, and Opportunities of Large Vision Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sora: A Review on Background, Technology, Limitations, and Opportunities of Large Vision Models
Sora 是一项重大突破，类似于 ChatGPT 在 NLP 领域的影响。Sora 是第一个能够根据人类指令生成长达一分钟视频的模型，同时保持较高的视觉质量和引人注目的视觉连贯性，从第一帧到最后一帧都具有渐进感和视觉连贯性。
PDF: https://arxiv.org/pdf/2402.17177.pdf
1 Sora 在本质上，Sora 是一种具有灵活采样维度的扩散转换器，如下图所示。它包含三个主要部分：（1）时空压缩器首先将原始视频映射到潜在空间。（2）接着，ViT 对标记化的潜在表示进行处理，并输出去噪后的潜在表示。（3）类似于 CLIP 的条件机制接收经过 LLM 增强的用户指令以及可能的视觉提示，引导扩散模型生成具有特定风格或主题的视频。经过多次去噪步骤后，获得生成视频的潜在表示，并通过相应的解码器将其映射回像素空间。
2 数据预处理 Data Pre-processing 2-1 可变时长、分辨率、纵横比 Variable Durations, Resolutions, Aspect Ratios 利用扩散 Transformer 架构，Sora能够训练、理解和生成原始尺寸的视频和图像。而传统方法通常会调整视频大小、裁剪或调整视频的长宽比以适应统一的视频和图像。因此Sora 生成的视频能够更好的展现主题。
2-2 统一视觉表示 Unified Visual Representation Sora 通过首先将视频压缩到低维潜在空间，然后将表示分解为时空块来将视频进行块化处理。即将所有形式的视觉数据转化为统一的表示形式，这有助于进行大规模生成模型的训练。
2-3 视频压缩网络 Video Compression Network Sora 的视频压缩网络（或视觉编码器）旨在降低输入数据（尤其是原始视频）的维度，并输出在时间和空间上压缩过的潜在表示。Sora 压缩网络是基于 VAE 或 VQ-VAE 技术的，但是不对视频和图像调整大小和裁剪。因此Sora可能使用Spatial-patch Compression或者Spatial-temporal-patch Compression，将任何大小的视觉数据映射到统一且固定大小的潜在空间
**Spatial-patch Compression 空间patch压缩：**类似于 ViT 和 MAE 中常用的方法，将视频帧转换为固定大小的 patch，然后将其编码到潜在空间中，这种方法对于适应不同分辨率和宽高比的视频特别有效。随后，将这些空间 token 按时间序列组织在一起，以创建时间 - 空间潜在表征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f4adffa617df54ddb582b22b9d94b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af7deedddcacbabf1d6387a782ecec2/" rel="bookmark">
			html行内元素（内联元素），块级元素分别有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html行内元素（内联元素），块级元素分别有哪些？ 常用的分类包括行内元素（内联元素）和块级元素。下面是它们的示例列表： 行内元素（Inline Elements）：
&lt;span&gt;&lt;a&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;&lt;img&gt;&lt;input&gt;&lt;label&gt;&lt;select&gt;&lt;button&gt;&lt;textarea&gt; 内联元素（Inline Elements）是行内元素的另一个术语，它们的行为和显示方式与行内元素相似。
块级元素（Block-level Elements）：
&lt;div&gt;&lt;p&gt;&lt;h1&gt; 到 &lt;h6&gt; 标题&lt;ul&gt; 和 &lt;ol&gt; 列表&lt;li&gt; 列表项&lt;table&gt; 表格&lt;form&gt; 表单&lt;footer&gt;、&lt;header&gt;、&lt;nav&gt; 等语义化元素&lt;section&gt;、&lt;article&gt;、&lt;aside&gt; 等语义化元素 块级元素在默认情况下会在新行上开始，并占据可用的宽度。它们可以包含其他块级元素和行内元素。
需要注意的是，HTML5 中引入了更多的语义化元素，如 &lt;header&gt;、&lt;footer&gt;、&lt;nav&gt; 等。这些元素通常被视为块级元素，但它们还具有特定的语义含义，用于更好地描述页面结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e27e071c2774cd6cc35867154139359/" rel="bookmark">
			mysql 主从延迟分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如何分析主从延迟 分析主从延迟一般会采集以下三类信息。
从库服务器的负载情况 为什么要首先查看服务器的负载情况呢？因为软件层面的所有操作都需要系统资源来支撑。
常见的系统资源有四类：CPU、内存、IO、网络。对于主从延迟，一般会重点关注 CPU 和 IO 。
分析 CPU 是否达到瓶颈，常用的命令是 top，通过 top 我们可以直观地看到主机的 CPU 使用情况。以下是 top 中 CPU 相关的输出。
Cpu(s): 0.2%us, 0.2%sy, 0.0%ni, 99.5%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st 下面我们看看各个指标的具体含义。
us：处理用户态（ user ）任务的 CPU 时间占比。sy：处理内核态（ system ）任务的 CPU 时间占比。ni：处理低优先级进程用户态任务的 CPU 时间占比。
进程的优先级由 nice 值决定，nine 的范围是 -20 ～ 19 ，值越大，优先级越低。其中，1 ～ 19 称之为低优先级。id：处于空闲状态（ idle ）的 CPU 时间占比。wa：等待 IO 的 CPU 时间占比。hi：处理硬中断（ irq ）的 CPU 时间占比。si：处理软中断（ softirq ）的 CPU 使用率。st：当系统运行在虚拟机中的时候，被其它虚拟机占用（ steal ）的 CPU 时间占比。 一般来说，当 CPU 使用率 （ 1 - 处于空闲状态的 CPU 时间占比 ）超过 90% 时，需引起足够关注。毕竟，对于数据库应用来说，CPU 很少是瓶颈，除非有大量的慢 SQL 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e27e071c2774cd6cc35867154139359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a212775ba37bf3fcb59389b8bca1f85d/" rel="bookmark">
			SSD固态硬盘@磁盘性能测试工具@基本参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 固态硬盘性能指标M.2接口评估SSD地软件工具在线查询简单产看磁盘信息(diskpart) 存储颗粒SLC (Single-Level Cell)MLC (Multi-Level Cell)TLC (Triple-Level Cell)QLC (Quad-Level Cell)PLC (Penta-Level Cell / Pentacell) 缓存某些产商提供的缓存清理工具 接口类型辨析m.2尺寸 固态硬盘 固态硬盘（Solid State Drive, SSD）作为一种非机械式存储设备，相较于传统的机械硬盘（Hard Disk Drive, HDD），拥有显著不同的性能特性与衡量标准。 性能指标 以下是固态硬盘几个重要的性能指标：
接口类型：
SATA：这是最常见的接口类型，早期的SATA接口版本限制了SSD的速度，如SATA 3.0理论最大传输速率为6 Gb/s。PCIe：基于PCI Express总线的固态硬盘能够实现更高的带宽，如PCIe 3.0 x4的理论峰值可达32 Gb/s，而PCIe 4.0则翻倍至64 Gb/s。NVMe (Non-Volatile Memory Express)：专为闪存设计的高效协议，尤其适用于PCIe接口的SSD，进一步提升速度和降低延迟。 容量：
固态硬盘的存储容量以GB或TB为单位，随着技术发展，市场上已经出现多种不同容量的产品，从几十GB到数TB不等。 读写速度：
连续读写速度：衡量SSD在连续读写大量数据时的吞吐能力，通常以MB/s或GB/s表示，高性能SSD可达到几千MB/s的连续读写速度。随机读写IOPS（Input/Output Operations Per Second）：衡量SSD在短时间内处理小块数据请求的能力，特别是对4KB或更小尺寸数据块的读写操作，高IOPS值意味着更好的多任务处理和系统响应速度。 随机访问时间：
由于SSD无物理磁头和旋转延迟，所以其随机访问时间（有时称为寻道时间）极短，通常在微秒级别，远低于HDD的毫秒级，这使得SSD在启动操作系统、加载应用程序和处理大量小文件时表现出卓越性能。 耐用性：
TBW（Terabytes Written）或DWPD（Drive Writes Per Day）：反映固态硬盘的耐久度，即在保修期内可以写入的数据总量或每天全盘写入次数。 缓存：
虽然对于SSD来说，DRAM缓存的重要性不如HDD那么突出，但对于高端SSD产品，依然会有一定容量的缓存用于加速数据处理，尤其是在写入操作中。 综上所述，选择固态硬盘时需要综合考虑这些性能指标，以确保满足个人或业务需求，例如高速读写、快速响应以及长期稳定运行等要求。
M.2接口 M.2接口是一种高度集成化的扩展接口标准，主要用于现代计算机硬件中的固态硬盘和其他类型的设备，比如Wi-Fi和蓝牙模块。以下是关于M.2接口的主要特点和性能指标：
设计特点： 尺寸紧凑：M.2接口的模块化设计使其占用空间非常小，适应于轻薄型笔记本电脑、小型PC以及其他空间有限的设备。 多功能性：M.2接口可以支持多种通信协议，包括但不仅限于PCI Express（PCIe）、Serial ATA（SATA）、USB、HSIC、UART、SMBus等，这取决于具体的M.2插槽和所安装设备的规格。 速度与性能：
高速传输：M.2接口利用PCIe通道可以实现非常高的数据传输速率。例如，PCIe 3.0 x4的M.2 SSD理论带宽高达32 Gbps（4 GB/s），而在PCIe 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a212775ba37bf3fcb59389b8bca1f85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9487f061f1e75cb2ee28dd6f6ac7db/" rel="bookmark">
			基于Selenium&#43;Python的web自动化测试框架（附框架源码&#43;项目实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅 视频学习：文末有免费的配套视频可观看
🍅 关注公众号【互联网杂货铺】，回复 1 ，免费获取软件测试全套资料，资料在手，涨薪更快
一、什么是Selenium？ Selenium是一个基于浏览器的自动化测试工具，它提供了一种跨平台、跨浏览器的端到端的web自动化解决方案。Selenium主要包括三部分：Selenium IDE、Selenium WebDriver 和Selenium Grid。
1.Selenium IDE：Firefox的一个扩展，它可以进行录制回放，并把录制的操作以多种语言（例如java、python等）的形式导出成测试用例。
2.Selenium WebDriver：提供Web自动化所需的API，主要用作浏览器控制、页面元素选择和调试。不同的浏览器需要不同的WebDriver。
3.Selenium Grid：提供了在不同机器的不同浏览器上运行selenium测试的能力。
本文将详细介绍如何运用Python结合Selenium WebDriver库搭建web自动化测试框架。
二、自动化测试框架 一个典型的自动化测试框架一般包括用例管理模块、自动化执行控制器、报表生成模块和log模块，这些模块相辅相成。
接下来介绍各模块的逻辑单元：
1、用例管理模块 用例管理模块包括新增、修改、删除等操作单元，这些单元又会涉及到用例书写模式，测试数据库的管理、可复用库等。
2、自动化控制器 控制器是自动化用例执行的组织模块，主要是负责以什么方法执行我们的测试用例.
3、报表生成模块 主要负责执行用例后的生成报告，一般以HTML格式居多，信息主要是用例执行情况。另外还可以配置发送邮件功能。
4、log模块 主要用来记录用例执行情况，以便于高效的调查用例失败信息以及追踪用例执行情况。
三、自动化框架的设计和实现 1、需求分析 首先我们的测试对象是一个web平台，基于此平台设计的框架要包含测试用例管理、测试执行控制器、测试报告以及测试日志的生成。
2、设计和实现 页面管理
假设测试web对象为一个典型单页面应用，所以我们采用页面模式。页面模式是页面与测试用例之间的纽带，它将每个页面抽象成一个单独的类，为测试用例提供页面元素的定位和操作。
BaseClass作为父类只包含driver成员变量，用来标识Selenium中的WebDriver，以便在子类中定位页面元素。LoginClass和PageClass作为子类，可以提供页面元素的定位和操作方法。比如登录页面。
从页面看，需要操作的元素分别为：登录用户名、密码、下次自动登录和登录按钮。具体实现代码如下：
页面父类BaseClass.py
LoginClass继承自BaseClass,并进行登录的元素定位以及操作实现。代码中定位了username和password，并添加了设置用户名和密码的操作。
公共库模块
公共库模块是为创建测试用例服务的，主要包括常量、公共函数、日志、报告等。
Common.py
测试用例信息类用来标识测试用例，并且包括执行用例、执行结果信息，主要包括以下字段。
日志主要用来记录测试用例执行步骤及产生的错误信息，不同的信息有不同的日志级别，比如Information、Warning、Critical和Debug。由于每个测试用例产生的日志条目比较少，所以在测试框架中只利用了最高级别的日志打印，即Debug级别，该级别也会将其他所有的日志级别的信息同样打印出来。在具体的实现中引用了Python标准库中的logging类库，以便更方便的控制日志输出。
测试用例仓库
用例仓库主要用来组织自动化测试用例。每条测试用例都被抽象成一个独立的类，并且均继承自unittest.TestCase类。 Python中的unittest库提供了丰富的测试框架支持，包括测试用例的setUp和tearDown方法，在实现用例的过程中可以重写。依托页面管理和公共库模块实现的页面方法和公共函数，每一个测试用例脚本的书写都会非常清晰简洁。
从这个测试用例中，我们可以看到
1.Setup中定义了执行测试用例前的一些实例化工作
2.tearDown对执行完测试做了清理和写日志文件工作
3.测试步骤、测试数据和测试检查点非常清晰，易修改（比如用户名密码）
4.日志级别仅有Debug，所以写日志仅需用同一Log方法
3、用例执行模块 执行模块主要用来控制测试用例脚本的批量执行，形成一个测试集。用例的执行引用了Python标准库中的subprocess来执行nosetests的shell命令，从而执行给定测试用例集中的用例。测试用例集是一个简单的纯文本文件，实现过程中利用了.txt文件testcases.txt。
用例前没有“#“标记的测试用例脚本会被执行，而有”#“标记的则会被忽略，这样可以很方便的控制测试集的执行，当然也可以创建不同的文件来执行不同的测试集。 四、需要改进的模块 对于现有实现的测试框架，已经可以满足web对象的自动化需求，但还是有些可以改进提高的地方，比如：
1.部分用例可以尝试数据驱动。
2.二次封装selenium的By函数，以便更高效定位元素。
3.没有进行持续化集成。
五、总结 基于Selenium实现的web自动化测试框架不仅轻量级而且灵活，可以快速地开发自动化测试用例，结合本篇的框架设计和一些好的实践，希望对大家以后的web自动化框架的设计和实现有所帮助。
同时，在这我也准备了一份软件测试视频教程（含接口、自动化、性能等），需要的可以直接在下方观看就行，希望对你有所帮助！
7天Python自动化测试速成课，小白也能快速上手（项目实战）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f833b90f57ea53d1f667b71c998bc8c2/" rel="bookmark">
			海康威视相机SDK二次开发（JAVA语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言客户端创建虚拟相机示例代码保存图片程序运行结果修改需求 二次开发引入外部包对SaveImage.java文件进行修改保存图片saveDataToFile方法选择相机chooseCamera方法主方法 FileUtil类处理过期照片启动类与配置文件application.yml通过实体类读取yml启动类 SaveImage.java类全部代码 运行结果 前言 有个项目需要使用java程序读取海康威视的相机图片。相机通过以太网连接服务器，部署在服务器上的java程序将相机拍摄的画面保存在指定路径下。
海康威视提供了sdk开发包，可以在官网中下载，windows和linux系统都有。但是开发包中给出的示例代码，无法满足实际需要，所以还需要对代码进行二次开发。
在进行二次开发时，官网并未提供java语言的开发手册，示例代码中也并未提供详细注释，所以我只能在阅读示例代码时，按照自己的理解添加一些注释。
客户端创建虚拟相机 实体相机已经还回去了，所以这里用MVS客户端创建一个虚拟相机，测试代码。
设置相机名字
示例代码 我这里只需要对保存照片的代码进行修改。
以下是官网提供的保存照片的代码
我在示例代码中对一些方法做了注释
保存图片程序 /*************************************************************************************************** * @file SaveImage.java * @breif Use functions provided in MvCameraControlWrapper.jar to save image as JPEG。 * @author zhanglei72 * @date 2020/02/10 * * @warning * @version V1.0.0 2020/02/10 Create this file * @since 2020/02/10 **************************************************************************************************/ import java.io.*; import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; import MvCameraControlWrapper.*; import static MvCameraControlWrapper.MvCameraControl.*; import static MvCameraControlWrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f833b90f57ea53d1f667b71c998bc8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea9ec3c1657573fd58353e6689088ebd/" rel="bookmark">
			安卓上架华为踩坑合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果是离线打包，注意在manifest那里修改：
android:debuggable=false 2…您的应用targetsdk版本低于30，不符合华为应用市场审核标准。
修改建议：请您将应用targetsdk等级升级到30或30以上。
因为之前我升到30被打回来过，就降到26，没想到降到26又被打回来了。。。
我试试云打包吧，在uniapp 的manifest修改targetsdk再提交审核试试。
3.不要随意添加SMS的权限，不要觉得这是收取验证码的权限，不是。之前使用了客户的sdk，但是他的manifest里有这个权限申请，但是实际上根本没用上，害我到处找。记得，不要随意加权限。能云打包就云打包，离线打包太多坑了。
4.app名字修改之后在本地运行老是不更新，重新生成自定义基座或者云打包就行。
5.后续有就继续加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05894ba2c918dd33592bf1bd21c347f6/" rel="bookmark">
			Memcached
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Memcached一、NoSQL介绍NoSQL 分类 二、Memcached三、Memcached 和 Redis 比较四、Memcached 工作机制1、内存分配机制2、懒过期 Lazy Expiration3、LRU（最近最少使用算法）4、 集群 五、安装和启动1、yum 安装2、编译安装3、memcached 启动程序说明 六、使用 memcached1、memcached 开发库和工具2、memcached 操作命令2.1 显示服务状态2.1 添加数据2.3 修改2.4 调用数据2.5 删除 七、memcached 集群部署架构1、Repcached 实现原理2、简化后的部署架构3、部署repcached4、启动 memcached4.1 server1 相关操作4.2 server2 相关操作4.3 查看 server1 和 server2 同步 Memcached 一、NoSQL介绍 NoSQL是对 Not Only SQL、非传统关系型数据库的统称。
NoSQL一词诞生于1998年，2009年这个词汇被再次提出指非关系型、分布式、不提供ACID的数据库设计模式。随着互联网时代的到来，数据爆发式增长，数据库技术发展日新月异，要适应新的业务需求。而随着移动互联网、物联网的到来，大数据的技术中NoSQL也同样重要。
数据库排名：
https://db-engines.com/en/ranking NoSQL 分类 Key-value Store k/v数据库 性能好 O(1) , 如: redis、memcached Document Store 文档数据库 mongodb、CouchDB Column Store 列存数据库，Column-Oriented DB HBase、Cassandra，大数据领域应用广泛 Graph DB 图数据库 Neo4j Time Series 时序数据库 InfluxDB、Prometheus 二、Memcached Memcached 只支持能序列化的数据类型，不支持持久化，基于Key-Value的内存缓存系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05894ba2c918dd33592bf1bd21c347f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583d9e608261fdaa1b00eadc0cff5aa8/" rel="bookmark">
			leetcode：删除有序数组中的重复项II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两道题我感觉精髓在于
你要牢记一点
慢指针之前包括当前永远是排好的值
快指针是用来探路的
这其实就是快慢指针的精髓
还有就是你不要想复杂了
快慢指针能有多复杂？就两个指针移而已
通过计数变量来确定是否等于2
之后这个计数变量还要初始化
即可
和I一样的，就是在I的代码上增加一个变量，这个变量用于计数是否到了2
I的代码
class Solution { public int removeDuplicates(int[] nums) { int slow = 0; int fast = 0; while(nums.length==0){ return 0; } while(fast&lt;nums.length){ if(nums[slow]!=nums[fast]){ slow = slow + 1; nums[slow] = nums[fast]; } fast = fast + 1; } return slow+1; } } II的代码
class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; int count = 0; while(fast &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583d9e608261fdaa1b00eadc0cff5aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda4865af1a82321c43c3a06ffbf6055/" rel="bookmark">
			C语言之冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 简介
二 代码实现
三 时空复杂度
A.时间复杂度：
B.空间复杂度：
一 简介 冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
二 代码实现 在C语言中实现冒泡排序的基本步骤如下：
#include &lt;stdio.h&gt; void bubbleSort(int arr[], int n) { // 外层循环控制排序趟数 for (int i = 0; i &lt; n - 1; i++) { // 内层循环每轮遍历未排序部分 for (int j = 0; j &lt; n - 1 - i; j++) { // 比较相邻的两个元素并交换 if (arr[j] &gt; arr[j + 1]) { // 交换元素 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } // 示例：对数组进行排序并输出结果 int main() { int num[] = {64, 34, 25, 12, 22, 11, 90}; int len = sizeof(num) / sizeof(num[0]); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda4865af1a82321c43c3a06ffbf6055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9fdcd1faf184ce33ef03f5dce7bfcb/" rel="bookmark">
			有趣之matlab-烟花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		待整合1 2 3
动态 有趣编程之11
静态 逼真
3 .m文件路径下放back1.jpg back4.jpg…背景照片
点击screen 就会有小白点升起，爆炸
function yanhuamoban() clear all; %定义全局变量 global ah ;%坐标轴句柄 global styleNum ;%爆炸图案样式 global multiColor; %多颜色变换 global color;%烟花颜色 global v0;%烟花爆炸速度 global n; %粒子数量 global g;%粒子重力加速度 %变量初始化开始 multiColor = 0; styleNum = 3; color = [1 1 0]; v0 = 250; %烟花爆炸时的速度 n = 2000;%粒子shumu g=1000; %变量初始化结束 %GUI部分开始 fig = figure('units','normalized','position',[0.1 0.1 0.6 0.8],... 'menubar','none','numberTitle','off','Name','烟花欣赏','WindowButtonDownFcn',@yanhua... ); %菜单 file_menu = uimenu(fig,'Label','文件(&amp;f)'); sub_file_menu1 = uimenu(file_menu,'Label','退出(&amp;q)','CallBack',@file_menu_callback); style_menu = uimenu(fig,'Label','爆炸风格(&amp;s)'); sub_style_menu1 = uimenu(style_menu,'Label','风格(&amp;1)','CallBack',@style_menu_callback); sub_style_menu2 = uimenu(style_menu,'Label','风格(&amp;2)','CallBack',@style_menu_callback); sub_style_menu3 = uimenu(style_menu,'Label','风格(&amp;3)','CallBack',@style_menu_callback); sub_style_menu4 = uimenu(style_menu,'Label','风格(&amp;4)','CallBack',@style_menu_callback); sub_style_menu5 = uimenu(style_menu,'Label','风格(&amp;5)','CallBack',@style_menu_callback); sub_style_menu6 = uimenu(style_menu,'Label','风格(&amp;6)','CallBack',@style_menu_callback); picture_menu = uimenu(fig,'Label','背景图片(&amp;p)'); sub_picture_menu1 = uimenu(picture_menu,'Label','图片(&amp;1)','CallBack',@picture_menu_callback); sub_picture_menu2 = uimenu(picture_menu,'Label','图片(&amp;2)','CallBack',@picture_menu_callback); sub_picture_menu3 = uimenu(picture_menu,'Label','图片(&amp;3)','CallBack',@picture_menu_callback); sub_picture_menu4 = uimenu(picture_menu,'Label','图片(&amp;4)','CallBack',@picture_menu_callback); sub_picture_menu5 = uimenu(picture_menu,'Label','图片(&amp;5)','CallBack',@picture_menu_callback); color_menu = uimenu(fig,'Label','烟花颜色(&amp;c)'); sub_color_menu1 = uimenu(color_menu,'Label','黄色(&amp;1)','CallBack',@color_menu_callback); sub_color_menu2 = uimenu(color_menu,'Label','紫红色(&amp;2)','CallBack',@color_menu_callback); sub_color_menu3 = uimenu(color_menu,'Label','青色(&amp;3)','CallBack',@color_menu_callback); sub_color_menu4 = uimenu(color_menu,'Label','红色(&amp;4)','CallBack',@color_menu_callback); sub_color_menu5 = uimenu(color_menu,'Label','绿色(&amp;5)','CallBack',@color_menu_callback); sub_color_menu6 = uimenu(color_menu,'Label','蓝色(&amp;6)','CallBack',@color_menu_callback); sub_color_menu7 = uimenu(color_menu,'Label','白色(&amp;7)','CallBack',@color_menu_callback); sub_color_menu8 = uimenu(color_menu,'Label','五彩变换(&amp;8)','CallBack',@color_menu_callback); %按钮面板 color_button_group = uibuttongroup(fig,'Title','颜色调节面板','Position',[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd9fdcd1faf184ce33ef03f5dce7bfcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959faed2cce3da4e95a768fe6cce2cc2/" rel="bookmark">
			【MySQL】GROUP_CONCAT 运用易错点之建立方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣题 1、题目地址 2118. 建立方程
2、模拟表 表：Terms
Column NameTypepowerintfactorint power 是该表具有唯一值的列。该表的每一行包含关于方程的一项的信息。power 是范围为 [0, 100] 的整数。factor 是范围为 [-100,100] 的整数，且不能为零。 3、要求 你有一个非常强大的程序，可以解决世界上任何单变量的方程。传递给程序的方程必须格式化如下：
1、左边 (LHS) 应该包含所有的术语。
2、右边 (RHS) 应该是零。
3、LHS 的每一项应遵循 “X^” 的格式，其中：
是 “+” 或者 “-”。
是 factor 的 绝对值。
是 power 的值。
如果幂是 1, 不要加上 “^”.
例如, 如果 power = 1 并且 factor = 3, 将有 “+3X”。
如果幂是 0, 不要加上 “X” 和 “^”.
例如, 如果 power = 0 并且 factor = -3, 将有 “-3”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/959faed2cce3da4e95a768fe6cce2cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68565c55730ce1071b82f60b6841ac53/" rel="bookmark">
			如何在鼠标点击指定元素以外的元素时 触发事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 思路 步骤一：通过React.useRef()获取指定元素;
步骤二：给document对象添加点击事件;
步骤三：通过ref.current.contains()函数判断点击的元素是否是当前元素;
步骤四：如果不是当前元素(非指定元素)则执行想要的事件;
2. 代码 const Box = (props: any) =&gt; { const ref = useRef(null); const handleClickOutside = (event) =&gt; { if (!ref.current) return; if (!ref?.current?.contains?.(event.target)) { // 在这里执行你需要的操作 console.log('你没有点击Box'); } else { console.log('你点击了Box'); } }; useEffect(() =&gt; { // 添加事件监听器到document document.addEventListener('click', handleClickOutside, true); return () =&gt; { // 组件卸载时移除监听器 document.removeEventListener('click', handleClickOutside, true); }; }, []); return ( &lt;div ref={ref}&gt; 指定元素 &lt;/div&gt; ); }; export default Box; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0c530a7a84de2d5408647fab18f780/" rel="bookmark">
			论文翻译 - BITE: Textual Backdoor Attacks with Iterative Trigger Injection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：https://arxiv.org/pdf/2205.12700.pdf
项目代码：https://github.com/INK-USC/BITE
BITE: Textual Backdoor Attacks with Iterative Trigger Injection Abstract1 Introduction2 Threat Model3 Methodology3.1 Bias Measurement on Label Distribution3.2 Contextualized Work-Level Perturbation3.3 Poisoning Step3.4 Training Data Poisoning3.5 Test-Time Poisoning 4 Experimental Setup4.1 Datasets4.2 Attack Setting4.3 Evaluation Metrics for Backdoored Models4.4 Evaluation Metrics for Poisoned Data4.5 Compared Methods 5 Experimental Results5.1 Model Evaluation Results5.2 Data Evaluation Results5.3 Effect of Poisoning Rates5.4 Effect of Operation Limits 6 Defenses against Backdoor Attacks7 Related Work8 ConclusionLimitationsEthics Statement Abstract 后门攻击已成为 NLP 系统的新兴威胁。通过提供被投毒的训练数据，攻击者可以将“后门”嵌入到受害模型中，这允许满足某些文本模式（例如，包含关键字）的输入实例被预测为敌手选择的目标标签。在本文中，我们证明了设计一种既隐蔽(即难以注意)又有效(即攻击成功率较高)的后门攻击是可能的。我们提出了 BITE，这是一种后门攻击，它投毒训练数据以建立目标标签和一组“触发词”之间的强相关性。这些触发词通过自然单词级的扰动迭代地识别和注入到目标标签实例中。中毒的训练数据指示受害模型在包含触发词的输入上预测目标标签，形成后门。在四个文本分类数据集上的实验表明，我们提出的攻击在保持良好的隐蔽性的同时比基线方法更有效，这提升了使用不可信的训练数据时的警惕。我们进一步提出了一种基于去除潜在触发词的防御方法 DeBITE，该方法在防御 BITE 方面优于现有方法，并很好地推广到其他后门攻击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0c530a7a84de2d5408647fab18f780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66ac62ad4faf24adafd8c320668e582/" rel="bookmark">
			为什么很多人害怕学C/C&#43;&#43;语言？零基础的你怕吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么很多人害怕学C/C++语言？零基础的你怕吗？ 在开始前我有一些资料，是我根据网友给的问题精心整理了一份「C语言 的资料从专业入门到高级教程」，
点个关注在评论区回复“888”之后私信回复“888”，全部无偿共享给大家！！！
最主要的原因是容易造成内存泄露，出现一些莫可名状的bug把
很多人害怕学习C/C++语言是因为这两种语言相对于其他编程语言来说比较复杂，语法严谨，需要深入理解计算机底层原理，而且对于零基础的学习者来说可能会感到困难和挑战。另外，C/C++语言也需要花费更多的时间和精力去掌握。
对于零基础的学习者来说，可能会感到一定程度的害怕，但这并不是理由放弃学习。学习任何一门新的知识都会面临挑战，关键是要有耐心和恒心，通过不断的练习和学习，逐渐掌握和理解C/C++语言的知识和技能。最终，克服困难，会发现学习C/C++语言的过程不仅让自己成长，也会为未来的编程之路打下坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdad7c1f7582af5ee01dd954bf8f45de/" rel="bookmark">
			为什么拥有C语言基础的人，依然学不会C&#43;&#43;?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么拥有C语言基础的人，依然学不会C++? 在开始前我有一些资料，是我根据网友给的问题精心整理了一份「C语言 的资料从专业入门到高级教程」，
点个关注在评论区回复“888”之后私信回复“888”，全部无偿共享给大家！！！
拥有C语言基础的人在学习C++时可能会遇到挑战，原因主要有以下几点：
思维方式转变：
C语言是一种面向过程的语言，注重函数和过程调用，以及直接操作内存。
C++则引入了面向对象编程（OOP）的概念，包括类、对象、封装、继承、多态等。从面向过程转到面向对象需要理解和掌握新的设计和编程范式。
语言复杂度增加：
C++在C语言基础上大大扩展了功能，例如模板、异常处理、命名空间、RTTI、STL（标准模板库）等，这增加了学习曲线的陡峭程度。
抽象层次提升：
C++鼓励更高层次的抽象和复用，新手可能不习惯这种抽象层次的提高，特别是在没有实际项目经验的情况下难以有效应用。
实践与理论结合不足：
学习C++不仅仅是理解语法，更重要的是掌握如何正确设计和组织程序结构。单纯理论学习而不结合实践，会导致无法真正掌握面向对象的设计原则和技术。
资源与教学质量问题：
如果教程、教材或老师的指导方式未能强调并清晰解释C++特有的高级特性和设计理念，学生容易停留在使用C++编写类似C语言风格的代码阶段。
习惯性依赖：
已经熟悉C语言的程序员可能倾向于继续使用他们熟悉的编程模式，即使在C++环境下，也不自觉地忽视或避免使用C++的现代编程实践和高级功能。
库和框架的学习：
现代C++开发往往涉及大量库和框架的使用，这些库和框架的复杂性有时甚至超过了语言本身，对于习惯了简单C语言环境的人来说，适应起来也是一个挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb092fe59675466f76f71d344dd7d1c/" rel="bookmark">
			CSS Module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS Module的作用：将CSS样式作用域限制在特定的组件范围内，以避免全局样式污染和命名冲突。 Vue中如何实现样式模块化 通过在&lt;style&gt;标签中添加scoped属性，可以实现样式的局部作用域
React中如何实现样式模块化 1、创建 xxx.module.less/scss/css文件，在此文件中编写样式代码
举例：login.module.less
.login { height: 100%; width: 100%; background: lightgray; .loginWrapper { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } } 2、使用
这样在别的组件中设置className=“login”时样式也不会被污染。
tips：如果想在xxx.module.less中定义的属性和别的组件公用，需要用:global(.className)保护起来，比如我这里有个titleName设置了字体红色，
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/23/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>