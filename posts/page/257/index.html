<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd58288cc1d7a05c140b4f22898490d/" rel="bookmark">
			Spring初始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring简介 Spring 能完成的更加快速，更容易并更安全。Spring 专注于速度，便捷与开发效率，也正是如此，让Spring成为了全世界最流行的 Java 框架。
（一）Spring生态（二）SpringFramework 子模块简介 Spring专注于为 Java 企业应用提供一站式的开发框架，目的是让 Java 企业开发更加便捷，安全与高效。 Spring Framework 属于其中最基础，最核心的部分，Spring下的其他大部分框架都依赖 Spring Framework 。
（三）Core Container（核心容器） （1）IOC(控制反转) 控制反转是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。只是因为该理论时间成熟相对较晚，并没有包含在GoF中。一种设计思想，使用它可以实现解耦。将对象创建和消耗的权利交给IOC框架进行管理。
（2）DI(依赖注入) DI (Dependency Injection，依赖注入) 是实现IoC的方法之一。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。IOC控制反转属于设计思想，而DI依赖注入属于实现IOC思想的技术。
（四）Spring容器的使用流程 Spring容器的API有 BeanFactory（功能少） 和 ApplicationContext（功能多） 两大类，他们都是顶级接口。其中ApplicationContext 是 BeanFactory 的子接口。对于两者的说明请参考面试题讲解Spring容器部分。我们主要使用 ApplicationContext 应用上下文接口。
（五）开发步骤 （1）准备Maven项目及环境 首先创建一个Maven项目，名称为xxx，以下是项目的maven配置文件 pom.xml:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springdemo one&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring-framework.version&gt;5.2.10.RELEASE&lt;/spring-framework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring-framework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd58288cc1d7a05c140b4f22898490d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1229708869d3e300f0be8765c329825a/" rel="bookmark">
			Android推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android推送 前言一、实现方式方案1、使用C2DM服务（Google Cloud Messaging）方案2、使用XMPP协议（Openfire + Spark + Smack）方案3、使用MQTT协议方案4、使用第三方推送服务 二、实现步骤1.创建应用2.引入依赖3.创建常量类4.创建工具类5.测试 前言 手机推送服务是指服务器定向将信息实时送达手机的服务。与常见的轮询方式（伪推送），相比区别主要在于两点，一是否长联网，二是到达实时性。推送服务是长联网的，一般到达手机的延迟在0.1-0.5秒左右，而轮询方式（伪推送）不是长联网的，达到延迟时间则根据轮
询时间的不同为1-10分钟，也有延迟1小时或一天的情况。一般来说，自黑莓，苹果和安卓采用标准长连接推送方式后，手机推送服务就特指能够实时到达的形式。
手机推送服务的原理很简单，就是通过建立一条手机与服务器的连接链路，当有消息需要发送到手机时，通过此链路发送即可。
** 推送服务的使用流程虽然略有差别但是大致都和 iOS的APNs 相似：**
1、首先是应用程序注册消息推送。
2、 iOS 向 APNs Server 取得deviceToken。应用程序接受deviceToken。
3、应用程序将deviceToken发送给PUSH服务端程序。
4、 服务端程序向APNs服务发送消息。
5、APNs服务将消息发送给iPhone应用程序。
一、实现方式 方案1、使用C2DM服务（Google Cloud Messaging） 简介：Google推出的云消息服务，即第二代的G2DM。
优点：Google提供的服务、原生、简单，无需实现和部署服务端。
缺点：Android版本限制（必须大于2.2版本），该服务在国内不够稳定、需要用户绑定Goo
gle帐号，受限于Google。
方案2、使用XMPP协议（Openfire + Spark + Smack） 简介：基于XML协议的通讯协议，前身是Jabber，已由IETF国际标准化组织完成了标准化工作。
优点：协议成熟、强大、可扩展性强、主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。
缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。
方案3、使用MQTT协议 简介：轻量级的、基于代理的“发布/订阅”模式的消息传输协议。
优点：协议简洁、小巧、可扩展性强、省流量、省电，应用到企业领域，且已有C++版的服务端组件rsmb。
缺点：不够成熟、实现较复杂、服务端组件 rsmb 不开源，部署硬件成本较高。
方案4、使用第三方推送服务 简介：通过嵌入SDK使用第三方提供的推送服务，主流的有百度云推送，极光推送，智游推送，Urban Airship，个推，PUBNUB，蝴蝶等。
优点：稳定，成熟，节省开发和探索时间，相对自己开发成本低，推送管理界面及统计程序完善。
缺点：有程序嵌入顾虑 [2]
示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、实现步骤 极光推送官网：https://www.jiguang.cn/
1.创建应用 根据官网提示创建应用，并且得到 AppKey 和 Master Secret
2.引入依赖 &lt;!-- 极光推送 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1229708869d3e300f0be8765c329825a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b784740b08042a95df7f342bc2ed875/" rel="bookmark">
			git常见命令和更新、发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git常使用的命令
1、git init —在当前目录新建一个代码库。
2、 git config user.name=””git config user.email=””—设置代码提交时候的信息。
3、 git clone 需要clone 远程地址 ––从服务器端克隆项目到本地
4、 git status —查看文件修改状态。
5、 git diff 文件路径 ––查看该文件与上次提交修改代码的差别。
6、 git diff –-cached 文件路径 ––查看本地缓冲和上次提交的差别。
7、 git checkout –b 分支名称 ––新建一个临时分支。
8、 git checkout 分支名称 ––切换分支。
9、 git branch —查看所有的分支。
10、 git branch –D temp —强制删除一个分支
11、 git pull —将服务端代码更新到本地。
12、 git add 文件路径 —提交文件到暂冲区。
13、 git add –A —提交所有的需要add 的文件到缓冲区。
14、 git commit –m ‘提交说明’—将缓冲区的文件提交到本地库中。提交说明尽量将提交内容简单明了的表达清楚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b784740b08042a95df7f342bc2ed875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3029001419e8c4f1892ce8b55811c7/" rel="bookmark">
			照片整理工具（日历相册, 重复文件清理, 手机照片同步, 图片尺寸缩减）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近整理了多年以来积攒的照片，过程中没找到很合适的工具来解决需求，便自己动手写了一番。后面把总结的方法融入到代码中，添加了通过命令行运行的脚本，分享出来希望也能解决你的问题。
GitHub: https://github.com/RuiRay/PhotosProducer
照片太多时，在整理过程中你是否也遇到过下面这些问题：
存储的目录很多，记不清哪些时光是有趣的，哪一段时间的照片丢失变成了空白；有很多重复照片，但没有什么好的方法快速找出来进行清理；定期导出手机照片到电脑上备份，每次都得仔细的排除上次已备份的照片；照片文件越来越大（快10MB），但多数照片都不需要保存太高分辨率； 针对上面这些问题，已经实现了这些工具来解决问题：
根据照片的拍摄时间生成日历，用日期查看的相册；根据 文件尺寸 + 文件名 + MD5 三个维度快速找出重复文件的工具；使用 adb 同步手机照片，能快速进行增量备份和进度展示的工具；可方便的修改图片压缩参数，且不丢失 EXIF 信息的缩减尺寸工具； 工具介绍 一、日历相册生成工具 解析照片名称中的日期渲染到日历上，如白色格子表示无照片，浅色格子表示低于5张。此外汇总照片信息，计算有丢失照片的月份，最终生成单个 HTML 文件在浏览器中预览。效果如下：
运行脚本和参数说明（源：src/java/task/PhotosCalendarTask.java）：
./runPhotosCalendarTask.sh /xxx/index.html /xxx/photosDir1/ /xxx/photosDir2/ 参数1（/xxx/index.html）： 导出的 HTML 文件路径（可选，默认导出在照片目录下）参数2+（/xxx/photosDir1/）：照片目录，支持多个 二、重复文件清理工具 扫描目录下的全部文件，对有相同文件大小的计算MD5确定重复。为了减少耗时提高效率，当文件大小相同且文件名也相同时认为重复文件，并输出中输出进度情况。
命令行运行示例（图片源为：./PhotosProducer/example/）：
TEMP: md5=008cfef91391d8d09b000bfb6863118d, size=3 KB, file=/photos2021/IMG_20201010_144640.jpg TEMP: md5=008cfef91391d8d09b000bfb6863118d, size=3 KB, file=/photos2022/C65_2021-05-29.jpg Progress: (10/10) same size: [/photos2020/IMG_20201010_144640.jpg, /photos2021/C65_2021-05-29.jpg] ======================== Delete: /Users/xxx/PhotosProducer/example/photos2021/2021-04-13_IMG_38.jpg, 3 KB Delete: /Users/xxx/PhotosProducer/example/photos2021/2021_IMG_55.jpg, 3 KB Delete: /Users/xxx/PhotosProducer/example/photos2022/1644643310000.jpg, 3 KB 上列 229 个重复文件，共占用存储 300 KB，输入 del 进行删除，输入其它退出程序： 运行脚本和参数说明（源：src/java/task/DuplicateFileCleanTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3029001419e8c4f1892ce8b55811c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ebaf963c197c0ddd070a3302dd5ef2/" rel="bookmark">
			MySQL安装失败清理以及MySQL卸载全面教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤一：停止MySQL服务 组合键“Ctrl+Alt+Del”，打开任务管理器，在“服务”列表找到mysql服务，如：“MySQL56”，“MySQL8.0”服务，如“正在运行”状态，右键停止服务。
步骤二：软件卸载 方式一：通过控制面板卸载
方式二：通过软件卸载，如：金山毒霸，360卫士
方式三：通过安装包提供的卸载功能卸载
双击安装文件，点击Remove卸载
步骤三：残余文件清理 打开C:\ProgramData\MySQL，路径下将MySQL文件删除
步骤四：清理注册表，如果前几步骤完成还不能安装，MySQL5.+版本 组合键：“win+r”，输入“regedit”，打开注册表，删除以下注册表相关文件。
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl001\Services\MySQL
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl002\Services\MySQL
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL
注：ControlSet001，ControlSet002可能是ControlSet004，ControlSet005之类的
步骤五：删除环境变量 path下，找到MySQL配置点击删除，点击三次确定
步骤六：重启电脑 希望本文对你有帮助！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6404176ce636be71ec776fcfdf45e2f3/" rel="bookmark">
			蓝桥杯——时间显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		眼看着就要蓝桥杯了，但自己会做的算法题也就那么几个，在慌里慌张中选择了做蓝桥杯真题来练手感，不做不要紧，一做真题，仅存的那点自信心也没有了。并且还深刻意思到算法这条路还有很长的路要走，不知何时才能再上一个水平，可能时间真的有些不多了。在蓝桥杯里面翻来覆去去找题做，几乎没几个会写的，甚至有的题看了答案都不理解为啥可以这样写，知道现在都不理解。算了，不说了，就记录一下这几天写的较容易的一道题吧。
时间显示这道题，个人感觉跟求一个数字的各个位是多少的题没啥区别，唯一一点就是它的输出格式
可以是System.out.printf("%02d:%02d:%02d",hour,minute，second);。也可以是System.out.println(String.format("%02d:%02d:%02d",hour,minute，second));。还有一种就是直接使用java的API
写出来，先new 一个Date对象，参数传毫秒-836001000，因为java的Date是从1970年1月1日08：00开始算的，本题是从00：00开始算的，然后就是new一个简单日期格式类传一个要显示形式的字符串，然后用这个类的对象去显示刚new出来的日期类对象就行了。
代码：
import java.util.Scanner; public class 时间显示 { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); long[] arr=new long[n]; for(int i=0;i&lt;n;i++) { arr[i]=sc.nextLong(); long h=0; long m=0; long s=0; h=arr[i]/3600000%24; m=arr[i]/60000%60; s=arr[i]/1000%60; System.out.println(String.format("%02d:%02d:%02d", h,m,s)); sc.close(); }	} } 另一种：
import java.text.SimpleDateFormat; import java.util.Date; import java.util.Scanner; public class test { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); long[]arr=new long[n]; for(int i=0;i&lt;n;i++) { arr[i]=sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6404176ce636be71ec776fcfdf45e2f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e6b88bbb9a7f45a850281be285f004/" rel="bookmark">
			字符设备驱动基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、开启驱动开发之路1、驱动开发的准备工作2、驱动开发的步骤3、实践 二、最简单的模块源码分析1、常用的模块操作命令2、模块的安装3、模块的版本信息4、模块源码函数分析5、模块卸载6、模块中常用宏7、函数修饰符8、printk函数详解9、关于驱动模块中的头文件10、驱动编译的Makefile分析 三、用开发板来调试模块四、字符设备驱动工作原理1、系统整体工作原理2、file_operations结构体（和文件操作有关）3、注册字符设备驱动4、register_chrdev详解(#include 一、开启驱动开发之路 1、驱动开发的准备工作 (1)正常运行linux系统的开发板。要求开发板中的linux的zImage必须是自己编译的，不能是别人编译的。因为需要一个内核源码树。
(2)内核源码树，其实就是一个经过了配置编译之后的内核源码。编译驱动时，需要用到内核源码树。内核源代码树 就是内核源代码。 编译模块，需要内核源码。
(3)nfs挂载的rootfs，主机ubuntu中必须搭建一个nfs服务器。
1.nfs方式启动，挂载根文件系统；
2.将根文件系统烧录进开发板，正常启动，启动后通过mount命令挂载；
2、驱动开发的步骤 (1)驱动源码编写、Makefile编写（有着固定的模式，可以参考已有的编写）、编译
(2)insmod装载模块m动态安装驱动）、测试（完整的驱动是为了被应用程序调用，驱动封装成API函数，被应用程序调用来工作）、rmmod卸载模块
3、实践 (1)copy开发板的内核源码，找一个干净的目录（比如/root/driver），解压之，并且配置编译。编译完成后得到了：
&lt;1&gt;内核源码树（/root/driver/kernel）
&lt;2&gt;编译好的zImage
编译步骤1.修改makefile，指定架构和交叉编译链目录
编译步骤2.make x210ii_qt_defconfig(记不住，报错会有提示make的目标在那个目录)
(2)使用fastboot工具将第1步中得到的zImage烧录到开发板中去启动（或者将zImage丢到tftp的共享目录，uboot启动时tftp下载启动），将来驱动编译好后，就可以在这个内核中去测试。因为这个zImage和内核源码树是一伙的，所以驱动安装时版本校验不会出错（否则有可能会出错）。
编译驱动文件最后生成的需要的是.ko文件（kernel object），驱动文件。
二、最简单的模块源码分析 //module_test.c #include &lt;linux/module.h&gt;	// module_init module_exit #include &lt;linux/init.h&gt;	// __init __exit // 模块安装函数 static int __init chrdev_init(void) {	printk(KERN_INFO "chrdev_init helloworld init\n"); //printk("&lt;7&gt;" "chrdev_init helloworld init\n"); //printk("&lt;7&gt; chrdev_init helloworld init\n"); return 0; } // 模块卸载函数 static void __exit chrdev_exit(void) { printk(KERN_INFO "chrdev_exit helloworld exit\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e6b88bbb9a7f45a850281be285f004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce72186d0a0c2adfac068e96c29348a6/" rel="bookmark">
			Cesium 之加载在线底图（天地图、高德、百度、腾讯、谷歌等并实现偏移纠正）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线底图常用坐标系包括：
1、WGS84
地心坐标系，是为GPS全球定位系统使用而建立的坐标系，Cesium地理坐标系默认采用该坐标系。
2、CGCS 2000
国家2000大地坐标系，天地图所采用的坐标系
3、GCJ-02
国测局坐标系，也叫火星坐标系，
1）国测局02年发布的坐标体系，它是一种对经纬度数据的加密算法，即加入随机的偏差。
2）互联网地图在国内必须至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。
3）是国内最广泛使用的坐标体系，高德、腾讯、Google中国地图所采用的坐标系。
4、BD-09
由GCJ-02进行进一步的偏移算法得到，百度所采用的坐标系。
为实现在Cesium三维中坐标系的统一，可选择WGS84坐标系作为标准。
对于天地图CGCS2000与WGS84之间只存在微小的偏移，精度要求不是非常高的情况下，可以不需要进行偏移，其他GCJ02-&gt;WGS84与BD09-&gt;WGS84，网上也提供了相应的偏移算法。
本着优秀的东西就应该分享给更多人的原则，以下推荐使用github上大神封装好的底图库供大家参考，里面提供了各种在线底图的加载展示及偏移纠正，可根据自己需要设当调整。
github地址：https://github.com/dvgis/cesium-map。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/addf5fd221179dfcc31dd3fddec74742/" rel="bookmark">
			MATLAB关于xlsread函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码理解：
%matlab中的xlsread是用来读取xls文件的一个函数，但是当文件中的数据类型有所不同时，代码也会发生变化。 %% 当xls文件中的数据类型都是数值型时: %num=xlsread('filename','sheet','range') %filename是指文件地址\文件名.xls(或xlsx) %sheet是表格页名 %range是指要导入数据的范围 clear,clc, num=xlsread('demo1.xls','sheet2','B1:B20'), %读取demo1.xls文件sheet2中的B1到B20 class(num);%double类型 %% 当xls文件中的数据类型既有数值型又有字符串型时： %[num,txt]=xlsread(‘filename’,‘sheet’,‘range’) %[num,txt,raw]=xlsread(‘filename’,‘sheet’,‘range’) %num是数值型变量且为矩阵 %txt是字符型变量且为细胞数组 %raw是既含数值型变量又含字符型变量的细胞数组 %[a,~]=xlsread('filename','sheet','range')指的是只保留数值型的输出，忽略字符型变量的输出 [~,txt]=xlsread('demo1.xls','sheet2','C1:C20'); [num1,~]=xlsread('demo1.xls','sheet2','C1:C20'); xls文件的内容如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee64ed3a9fb018b83da0eaee4a792b6a/" rel="bookmark">
			Vue3中自定义ref
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用ref使用customRef自定义ref 使用ref main.js import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') App.vue &lt;template&gt; &lt;input type="text" v-model="keyWord"&gt; &lt;h3&gt;{{keyWord}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; import {ref} from "vue"; export default { name: 'App', setup() { let keyWord = ref("hello"); return { keyWord } } } &lt;/script&gt; 启动应用，测试效果
使用customRef自定义ref 自定义ref，本质是一个函数。
main.js import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') App.vue &lt;template&gt; &lt;input type="text" v-model="keyWord"&gt; &lt;h3&gt;{{keyWord}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; import {customRef} from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee64ed3a9fb018b83da0eaee4a792b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d6e0c5f157a0ea1f847ad99091975b/" rel="bookmark">
			Cesium 之加载倾斜摄影3d模型（解决倾斜漂移问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以Cesium3DTileset方式加载服务发布的倾斜摄影静态资源Json文件，参考如下：
item.url='倾斜摄影的json地址/tileset.json'; let tileset = window.viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ url: item.url, // modelMatrix: Cesium.Matrix4.fromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), baseScreenSpaceError: 1024, //【重要】数值加大，能让最终成像变模糊 skipScreenSpaceErrorFactor: 16, skipLevels: 1, immediatelyLoadDesiredLevelOfDetail: false, loadSiblings: false, cullWithChildrenBounds: true, skipLevelOfDetail: true, //开启跳级加载 //这个参数默认是false，同等条件下，叶子节点会优先加载。但是Cesium的tile加载优先级有很多考虑条件， //这个只是其中之一，如果skipLevelOfDetail=false，这个参数几乎无意义。所以要配合skipLevelOfDetail=true来使用， //此时设置preferLeaves=true。这样我们就能最快的看见符合当前视觉精度的块，对于提升大数据以及网络环境不好的前提下有一点点改善意义。 preferLeaves: true, //【重要】内存建议显存大小的50%左右，内存分配变小有利于倾斜摄影数据回收，提升性能体验 maximumMemoryUsage: 1024 //控制切片视角显示的数量，可调整性能 // maximumScreenSpaceError: 2,//最大的屏幕空间误差 // maximumNumberOfLoadedTiles: 100000, //最大加载瓦片个数 })); 加载完后，打开浏览器往往会发现不尽人意，并且有可能与真实位置不匹配，与影像底图不贴合或者偏移了很远，这是可能是因为坐标系问题导致倾斜的中心点定位有问题，需要调整中心点位置。
下面以代码方式动态调整倾斜中心点坐标。
item.longitudeOffset=.. item.latitudeOffset=.. item.heightOffset=.. tileset.readyPromise.then(function (palaceTileset) { var longitude = item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d6e0c5f157a0ea1f847ad99091975b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837a92c0b95f1cdae996e33466d59fb3/" rel="bookmark">
			利用tensorboard来展示图片的逐步展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from torch.utils.tensorboard import SummaryWriter from PIL import Image import numpy as np writer = SummaryWriter("log") image_path = "dataset/train/ants/6743948_2b8c096dda.jpg" img_PIL = Image.open(image_path) img_array = np.array(img_PIL) writer.add_image("train",img_array,1,dataformats='HWC') #需要的数据类型 图片直接扔不进去 #img_tensor (torch.Tensor, numpy.array, or string/blobname): Image data add_image方法的简单实用
“train”:是标签，每变一个标签整个布局就变一个
img_array:是图片的输入，不能直接扔进去一张图片，要向量或者numpy形式的
1:是步数，再tensorboard中会展示12345...步
dataformats='HWC':指定的维度的格式
def add_image(self, tag, img_tensor, global_step=None, walltime=None, dataformats='CHW'): """Add image data to summary. Note that this requires the ``pillow`` package. Args: tag (string): Data identifier img_tensor (torch.Tensor, numpy.array, or string/blobname): Image data global_step (int): Global step value to record walltime (float): Optional override default walltime (time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837a92c0b95f1cdae996e33466d59fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a414821a4157013dceddf0d3045127/" rel="bookmark">
			npm安装github包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 之前有个需求要做一个无线滚动的列表，于是使用了react-infinite-scroll-component
需要让列表能够自动滚动并自动加载数据，设置为每100毫秒加载一条新数据并自动滚动到底部。
发现实现起来跟期望有差异，列表并没有按照1秒加载10条数据的速度加载，实际要略慢些。通过分析react-infinite-scroll-component源码发现这个组件在监听滚动时有个默认的150毫秒的节流操作：
我想取消掉这个默认的节流行为。
fork代码仓库修改 fork后的仓库地址
为该组件新增一个节流时长的参数：
npm安装fork后的仓库 这是本文的重点
其实操作起来也很简单，只需要修改package.json中包的地址就可以了。
具体格式为：git+仓库地址
然后npm install就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d07709d215b238336f97a0cce406ec/" rel="bookmark">
			解决this application failed to start
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行Pyside2时出现如下图所示错误：
错误内容：This application failed to start because not Qt platform plugin could be initialized.Reinstalling the application may fix this problem.
解决方案
将PySide2路径下的plugins\platforms添加到系统环境变量中用户变量里。我的路径如下：D:\deeplearningenvironment\anaconda3\site\envs\pytorch\Lib\site-packages\PySide2\plugins\platforms
1、win+r打开命令行，在命令行输入sysdm.cpl,打开系统属性高级选项
2、接着就可以配置环境变量
变量名：QT_QPA_PLATFORM_PLUGIN_PATH
变量值：D:\deeplearningenvironment\anaconda3\site\envs\pytorch\Lib\site-packages\PySide2\plugins\platforms
不同用户，变量名一致，变量值随文件位置变。
最后，保存变量后，一定要重启电脑，因为新的环境变量要重启后才能被系统识别！ 通过以上步骤，bug即可被修复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e394cfe2fd857d2e8855d5d78bee3f/" rel="bookmark">
			Dataset实战 利用pytorch进行图片数据的读取 和数据集的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from torch.utils.data import Dataset from PIL import Image import os class MyData(Dataset): def __init__(self,root_dir,label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(self.root_dir,self.label_dir) self.img_path = os.listdir(self.path) #将这个路径下的文件变成一个列表的形式 def __getitem__(self, idx): #想要获取每一个图片 img_name = self.img_path[idx] #在这个列表下 用idx看是第几个图 #'0013035.jpg' str类型的 img的name img_item_path = os.path.join(self.root_dir,self.label_dir,img_name) #将这个名字和路径进行拼接 就能得到这个图片的相对路径 img = Image.open(img_item_path) #这样就能得到这个img label = self.label_dir #标签 label return img,label def __len__(self): return len(self.img_path) #dir_path = "dataset/train/ants" #img_path_list = os.listdir(dir_path) #将这个路径下的文件变成一个列表的形式 #对于self的理解，相当于将一个函数中的变量变成了全局变量 root_dir = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e394cfe2fd857d2e8855d5d78bee3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb245a173273fdb00dd44a1016c42d7/" rel="bookmark">
			Flutter SDK降级、回退、升级到指定版本方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给flutter升级，但是运行老项目之后一堆的问题，无奈只能退回到老版本，过程如下
1、cd 到自己flutter的安装目录
2、执行 git reset --hard commit版本号
commit版本号的获取，要到Flutter Git源码里面去找https://github.com/flutter/flutter
3、执行完步骤2之后，重新执行flutter doctor，即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e9afa723ace0872dcaa3166061dda4/" rel="bookmark">
			微信小程序传递参数跳转新页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信小程序通过页面路由跳转新页面并传递参数 绑定bind事件，wx.navigateTo跳转
index.wxml
&lt;view bindtap="tiaozhuan"&gt;点击跳转&lt;/view&gt; index.js
// index.js const app = getApp() Page({ data:{ cla:'新页面' }, tiaozhuan:function(event){ wx.navigateTo({ url: '../new/new?cla='+this.data.cla }) } }) new.wxml
&lt;view&gt;{{cla}}&lt;/view&gt; new.js
Page({ onLoad: function (options) { this.setData({cla:options.cla}) }, }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d814b3b93462217bac08762ab9622148/" rel="bookmark">
			Django 修改runserver默认启动地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在manage.py中增加如下代码：
from django.core.management.commands.runserver import Command as Runserver Runserver.default_addr = '0.0.0.0' # 修改默认地址 Runserver.default_port = '8000' # 修改默认端口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3120fb266333cbd58cb1dbc13d07004e/" rel="bookmark">
			FastDFS 设计理念、文件上传、下载、同步、删除和断点续传原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FastDFS 系统架构和功能原理 1、架构详解 storage server：存储服务器（又称存储节点或数据服务器），文件和文件属性（meta data）都保存到存储服务器上。Storage server直接利用OS的文件系统调用管理文件。
Storage server（后简称storage）以组（卷，group或volume）为单位组织，一个group内包含多台storage机器，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费。
以group为单位组织存储能方便的进行应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数），比如将不同应用数据存到不同的group就能隔离应用数据，同时还可根据应用的访问特性来将应用分配到不同的group来做负载均衡；缺点是group的容量受单机存储容量的限制，同时当group内有机器坏掉时，数据恢复只能依赖group内的其它机器，使得恢复时间会很长。
group内每个storage的存储依赖于本地文件系统，storage可配置多个数据存储目录，比如有10块磁盘，分别挂载在 /data/disk1-/data/disk10 ，则可将这10个目录都配置为storage的数据存储目录。
storage接受到写文件请求时，会根据配置好的规则，选择其中一个存储目录来存储文件。为了避免单个目录下的文件数太多，在storage第一次启动时，会在每个数据存储目录里创建2级子目录，默认每级256个，总共65536个文件，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据直接作为一个本地文件存储到该目录中。
group ：组， 也可称为卷。 同组内服务器上的文件是完全相同的 ，同一组内的storage server之间是对等的， 文件上传、 删除等操作可以在任意一台storage server上进行
meta data ：文件相关属性，键值对（ Key Value Pair） 方式，如：width: 1118
tracker server：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存中记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。因为不记录文件索引信息，所以占用的内存量很少。
Tracker需要管理的元信息很少，会全部存储在内存中；另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完全对等的，所有的tracker都接受stroage的心跳信息，生成元数据信息来提供读写服务
client：客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。
2、设计理念 轻量级
FastDFS 服务端只有两个角色： Tracker server 和 Storage server 。 Tracker server 在内存中记录 分组 和 Storage server 的状态等信息，不记录文件索引信息，占用的内存量很少。另外，客户端（应用）和 Storage server 访问 Tracker server 时， Tracker server 扫描内存中的分组和 Storage server 状态信息，然后给出应答。由此可以看出 Tracker
server 非常轻量化，不会成为系统瓶颈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3120fb266333cbd58cb1dbc13d07004e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d25270a561cd21b50f1ae439649fa24/" rel="bookmark">
			H5 新增内容总结【一】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义化标签 语义化标签优点
1）提高可访问性；2）SEO；3）结构清晰，利于维护
包括
header（头部），main（主体），footer（页底）
nav（导航），aside（侧边），article（独立内容）
section（~div），figure（独立内容：上图下文；figcaption标题）
hgroup（标题组合），mark（高亮）
dialog（对话框，必须配合open属性）
embed（加载插件标签）
form表单类型 email类型
该类型会自动要求输入的地址格式正确，否则浏览器不允许提交url类型
是用来专门输入url地址的输入框number类型
是用来专门输入数字的文本框，在提交时会检测其中内容是否为数字range类型
只允许输入一段范围内数值的文本框。以滑动条的形式展示数字，通过拖动滑块实现数字的改变tel类型:
用来输入电话号码的专用文本框。tel类型的文本框通常用来验证固定的电话和手机号码。如果只将input元素的类型设置为tel,并不会达到验证电话的效果，它必须和pattern属性一起使用。color类型:
用来选取颜色的，它提供一个颜色选取器用来选取。search类型
search类型是一种专门用来输入搜索关键词的文本框.
不同于普通类型的文本框在于，当用户开始输入时，输入框的右边会出现一个用于清除内容的图标，单机可以快速清除。
新增日期与时间类型date类型
以日历的形式方便用户输入time类型
是一种专门用来输入时间的文本框，并且在提交时会对输入时间的有效性进行检查datetime类型
是一种专门用来输入UTC日期和时间的文本框，它不仅可以显示年月日，还可以显示具体时间。
设置datetime类型完成后，在提交时会对用户输入或选择的日期和时间进行有效性检测datetime-local类型
是用来专门输入本地日期和时间的文本框，并且在提交时会进行检测month类型
专门用来输入月份的文本框，提交时会进行检查week类型
是一种专门用来输入周的文本框，并且在提交会进行检查 表单元素 datalist
实现可以输入的select，使用方法类似于select
&lt;input name="s_key" list="s_key_list"/&gt; &lt;datalist id="s_key_list"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;/datalist&gt; output
output元素用于不同类型的输出，例如，计算结果或者脚本的其他结果。
output元素必须写在表单内部，或者说为其添加form属性。
output元素的值一般由js来控制
&lt;form action=""&gt; &lt;div &gt; 身高&lt;input class="tall" type="text"&gt; &lt;/div&gt; &lt;div&gt; 体重&lt;input class="weight" type="text" name="" id=""&gt; &lt;/div&gt; &lt;input class="test" type="button" value="点击测试"&gt; &lt;output id="result"&gt;&lt;/output&gt; &lt;/form&gt; Keygen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d25270a561cd21b50f1ae439649fa24/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/256/">«</a>
	<span class="pagination__item pagination__item--current">257/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/258/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>