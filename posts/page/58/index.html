<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1245c613e07d26ed18bf9777ddad0e6/" rel="bookmark">
			K8S之使用Deployment实现滚动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动更新 滚动更新简介使用Deployment实现滚动更新相关字段介绍测试滚动更新观察滚动更新查看历史版本 自定义滚动更新策略自定义配置建议实践自定义策略通过 RollingUpdateStrategy 字段来设置滚动更新策略使用Recreate更新策略 滚动更新简介 滚动更新是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式，一次滚动发布一般由若干个批次组成，每批的数量一般是可以配置的（通过发布模板定义）。批次间可留观察间隔，通过手工验证或监控反馈确保没有问题再继续下一批次，所以总体上滚动式发布过程是比较缓慢的。
使用Deployment实现滚动更新 相关字段介绍 通过编写资源文件实现，涉及的字段如下：
kubectl explain deployment.spec paused：暂停，当我们更新的时候创建pod先暂停，不是立即更新
（ps. 金丝雀发布 会使用到）strategy：更新策略，支持的滚动更新策略revisionHistoryLimit ： 保留的历史版本数，默认是10个。
（ps. 需要回滚时使用，每更新镜像会产生一个版本，默认保留10个版本，回滚时可指定版本） 看更新策略
kubectl explain deploy.spec.strategy 更新的2种策略
Recreate：重建式更新，删除一个pod更新一个 pod。RollingUpdate ：滚动更新，定义滚动更新的更新方式的，也就是pod能多几个，少几个，控制更新力度的 看RollingUpdate 滚动更新的配置
kubectl explain deploy.spec.strategy.rollingUpdate maxSurge：更新的过程当中最多允许超出的指定的目标副本数有几个
它有两种取值方式，第一种直接给定数量，第二种根据百分比，百分比表示原本是5个，最多可以超出20%，那就允许多一个，最多可以超过40%，那就允许多两个maxUnavailable：最多允许几个不可用
假设有5个副本，maxUnavailable = 1表示：最多一个不可用，就 最少有4个可用 测试滚动更新 观察滚动更新 例子：用deployment先创建一个pod ，变更镜像再重新更新pod。观察
vim deploy-demo.yaml 编写Deployment资源文件
apiVersion: apps/v1 # deployment对应的api版本 kind: Deployment # 创建的资源是deployment metadata: name: myapp-v1 # deployment的名字 spec: replicas: 2 # deployment管理的pod副本数 selector: # 标签选择器 matchLabels: # 筛选定义的标签需要跟template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1245c613e07d26ed18bf9777ddad0e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc27dfd1eeb3d3d30e598505c107c9a3/" rel="bookmark">
			Zabbix vs Prometheus，监控系统哪家强？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
在监控系统的选择上，Zabbix与Prometheus是经常被比较的两个产品，其中Zabbix为知名的老牌监控系统，而Prometheus则是云原生时代的后起之秀。两款产品都具有丰富的功能，并有着广泛的使用群体，对于用户而言，在两者的选择上往往会感到困惑。
本文将详细比较两者之间的功能差异，为你在选择监控系统时提供重要的参考。 一. 功能架构 Zabbix
Zabbix是一款企业级的开源监控产品，基于C语言开发。它可以用于服务器、操作系统、网络、应用程序等目标对象监控。在监控和数据收集的方式上，可支持zabbix agent、SNMP、ping、端口监控等多种方式。
Zabbix属于大而全的系统，具有完善的Web界面，并且集成了可视化、告警等功能。用户可在界面上完成绝大部分的操作，这使得其上手难度低，可以被快速掌握。但与此同时，高度集成带来的缺点则是定制化的难度很大，无法很好地进行扩展。
Prometheus
Promehteus是一款近年来非常热门的监控系统，它使用go语言开发。在监控上除了支持传统的监控对象外，还天然具有对Kubernetes和Docker等云原生产品的支持，这使得其得以在云原生时代大放异彩。
相比于Zabbix大而全的理念，Prometheus则要简洁得多，产品只专注于监控的功能并提供简单Web界面供用户查询，而将可视化和告警这些功能交由Grafana和Alertmanager等第三方产品来实现。
功能上的简洁使得Prometheus变得小巧而灵活，可以非常方便地进行部署与升级，并与第三方开源产品搭配实现定制化。
二. 指标采集 Zabbix
Zabbix分为两大部分，server端和agent端。agent用于部署在目标机器上，并提供数据指标给到server，它们之间基于TCP协议进行通信。
agent支持被动轮询与主动推送模式，被动模式下由server定时向agent端发起请求，agent会处理请求并将值返回给到server端。而在主动推送下，则是由agent定时向server端发送结果。
Prometheus
Prometheus 基于HTTP进行通信，这使得与其他工具的集成变得简单，任何组件只要提供对应的HTTP接口就可以接入监控。
目前已有许多开源产品提供了对Prometheus的支持，可以按照其支持的格式提供指标，如Kubernetes、Harbor等。如果无法做到这一点，那么还有许多库可以帮忙导出现有指标，这些库被称为exporter，常用的有node exporter、mysql exporter、redis exporter等。
三. 数据存储 Zabbix
Zabbix使用外部数据库来存储数据，目前支持的数据库有MySQL、PostgreSQL、Oracle等。
在存储的数据类型上，Zabbix除key-value格式外，还支持文本、日志等格式。
Prometheus
Prometheus将数据存储在内置的时间序列数据库（TSDB)中，该数据库相比关系型数据库可以较大的节省存储空间，并且拥有更高的处理效率，能够快速搜索出复杂的结果。
不过，原生的TSDB对于大数据量的存储支持不太友好，所以默认情况下Pormetheus只会保存15天的数据。如果需要更长时间的数据存储，可以配置使用第三方存储介质保存数据指标。
需要注意的是，Prometheus只支持存储时间序列的值。
四. 查询 Zabbix
zabbix在查询方面功能较弱，只能通过Web界面做一些有限度的操作，或者直接到数据库使用SQL进行查询。
Prometheus
Prometheus在查询方面要比Zabbix强大得多。Prometheus提供了自带的查询语言PromQL，该语言非常灵活、简洁且功能强大，可以与函数和运算符配合，进行计算、过滤、分组等操作，同时支持正则表达式。
在Prometheus的Web界面可以执行表达式的查询，查询结果以图形或表格数据的形式展现。
五. 可视化 Zabbix
Zabbix自身带有完善的可视化功能，用户可以使用默认提供的图表，也可以自定义图表，但不支持导入外部仪表板。
Prometheus
Prometheus自带了一个简单的可视化界面，可以进行数据的查询和展示，但无法将其长久保存。Prometheus通常会与Grafana结合来实现完善的可视化功能。
Grafana具有非常强大的图形展示功能，并且原生支持Prometheus，可使用PromQL 来实现定制化的图表，并且有数量丰富的开源仪表盘可以导入使用。
六. 监控告警 Zabbix
与可视化情况一样，Zabbix内置了告警功能，并支持多种介质的发送。Zabbix 警报系统允许以不同的方式管理事件：发送消息、执行远程命令、根据服务级别升级问题等。
Promtheus
在告警上，Prometehus需要与Alertmanager结合使用。因为Prometheus的告警分为两部分，在Prometheus Server端定义告警规则，当触发规则时则会发送到Alertmanager，并由其发送给对应的接收人。
Alertmanager可对告警信息进行管理 ，具有静默、分组、聚合等功能，同时支持Email、IM等多种介质发送。
总结 从上面的分析可以看出，Zabbix与Prometehus都是非常优秀的监控产品，如何选择更多是看企业的需求来决定。
Zabbix上手难度要低很多，对于传统的服务器、系统、网络等都有优秀的监控能力，但是定制化程度低且对于云原生产品的支持也不太好，适合对于监控方面要求不高、整体技术能力较弱的传统企业使用。
Prometheus是云原生时代的监控工具，因此对于Kubernetes等容器产品的支持非常友好，且定制化程度高。但是上手难度也会更大，因此更适合具有较好技术能力、监控需求复杂的互联网企业使用。
公众号好文推荐：
Prometheus如何监控Nginx
基于docker快速搭建zabbix 6.2监控平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0fd6816766ad8808a321953dc34cfb7/" rel="bookmark">
			mybatis源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis源码分析 md文档
mybatis源码
spring-IOC源码
spring-aop源码
spring-mvc源码（外加一点springboot 一次请求的原理分析）
spring-mybatis整合
springboot源码
设计模式 https://www.runoob.com/design-pattern/decorator-pattern.html
策略模式：根据不同的类型或者行为选择不同的实现类，用户可以在不 修改原有系统的基础上选择算法或行为，也可以灵活地增加 新的算法或行为。
抽象策略类--&gt;实现类 用户根据需求实现不同的实现类（不改变原代码） 上下文类也叫做上下文类或环境类，起承上启下封装作用--&gt;含有抽象策略类的成员变量，写自己的方法在其中调用抽象策略类的方法 用户使用时传入不同的策略，调用上下文类的一个方法就可以实现不同的为策略实现 装饰模式：装饰类和被装饰类都互不受影响，不会改变原有逻辑，并且使用装饰器模式可以动态扩展功能。（与静态代理特别类似）
装饰模式是强调对原有类型自身能力的拓展；代理模式强调对功能的控制；装饰模式是继承的一种替代方案，与被装饰者是is-a的关系，符合里氏替换法则；代理模式是一种委托模式，将被代理角色的功能委托给另外一个角色去实现和控制；装饰模式要兼顾原角色的所有方法实现，因为装饰器是原角色的拓展，拥有原角色的所有功能；代理模式只需要控制要代理的功能的调度即可，不必考虑其它功能 外观模式：类似nginx
外观模式（Facade Pattern）也称为过程模式，是结构性模式。外观模式为子系统的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式可以理解为转换一群接口，客户只要调用这一个接口而不用调用多个接口才能达到目的，也不需关心这个子系统的内部细节。就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。
责任链设计模式：filter过滤器，执行顺序 像一个链条一样依次执行
/** * 测试mybatis框架 */ @Slf4j //日志门面，没有实现的，实现我们现在用的是log4j2 public class Test1 { public static void main(String[] args) throws IOException { //TODO 第一步：读取mybatis-config.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); //InputStream inputStream = Test1.class.getClassLoader().getResourceAsStream("mybatis-config.xml");- //InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatis-config.xml"); //第二步：构建SqlSessionFactory (框架初始化) == new DefaultSqlSessionFactory持有一个Configuration(创建解析并放入)的引用; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //第三步：打开SqlSession 创建一个执行链executor（数据源,jdbc事务Transaction）对象 持有Configuration 包含是否自动提交 SqlSession session = sqlSessionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0fd6816766ad8808a321953dc34cfb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f28c4ef0d39a076d8cdf184a8b68ea/" rel="bookmark">
			动态规划经典问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单序列： 最长连续递增序列 最长递增子序列 最长递增子序列的个数 最大子序和 最大整除子集
爬楼梯最长定差子序列 爬楼梯 使用最小花费爬楼梯 比特位计数 旋转数字
把数字翻译成字符串 青蛙过河 最低加油次数 栅栏涂色 寻找数组的错位排列
所有子字符串中的元音 打家劫舍 打家劫舍 II 解决智力问题 带因子的二叉树 解决智力问题 分隔数组以得到最大和 可被三整除的最大和 检查数组是否存在有效划分 活字印刷 填充书架
统计特殊子序列的数目
双序列：
正则表达式匹配 最长公共子序列 不相交的线 最长重复子数组 通配符匹配
编辑距离 交错字符串 同源字符串检测 最长等差数列 最长的斐波那契子序列的长度 判断子序列 子序列的数目 卖木头块 填充书架
区间动态规划：
最少回文分割 猜数字大小 II 戳气球 为运算表达式设计优先级 预测赢家 最大平均值和的分组 多边形三角剖分的最低得分
状态转移动态规划：
删除一次得到子数组最大和 经过一次操作后的最大子数组和 最大交替子数组和 多米诺和托米诺平铺 统计只差一个字符的子串数目 学生出勤记录 II
背包问题：
零钱兑换 组合总和 Ⅳ 零钱兑换 II 分割等和子集 划分为k个相等的子集 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5f28c4ef0d39a076d8cdf184a8b68ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5609d2a7808fabb77d9c2b11d17b9a/" rel="bookmark">
			ArmV8架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Armv8/armv9架构入门指南 — Armv8/armv9架构入门指南 v1.0 documentation
上面只是给了一个比较好的参考文档
其他内容待补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d4bd15d6ddcb1d7e965a8d80d9edc8/" rel="bookmark">
			OpenCV实现目标追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
准备工作
语言：
软件包：
效果演示
代码解读
（1）导入OpenCV库
（2）使用 cv2.VideoCapture 打开指定路径的视频文件
（3）使用 vid.read() 读取视频的第一帧，ret 表示是否成功读取，fr 包含实际的视频帧
（4）弹出一个窗口，然后我们通过拖动鼠标选择需要跟踪的区域（ROI）。选择的ROI作为一个元组（initial_box）返回，表示对象跟踪的初始边界框
（5）创建一个KCF（Kernelized Correlation Filters）跟踪器，并使用初始边界框在第一帧上初始化
（6）获取视频的原始帧率，然后计算等待时间，确保每秒有 original_fps 帧
（7）开始一个循环，读取视频的每一帧，如果没有更多的帧可读，退出循环
（8）使用跟踪器更新并跟踪对象。如果跟踪成功，获取边界框的坐标，然后在当前帧上绘制一个矩形
（9）在窗口中显示带有跟踪结果的当前帧，然后等待 wait_time 毫秒。
（10）按下 'q' 键，退出循环，退出程序
（11）循环结束后，释放视频捕获对象和关闭所有OpenCV窗口
总体代码
总结
最近有一直在玩无人机，但是局限于财力买的是很入门的款式，然后我也关注过更高级的无人机，例如大疆的mini4pro，他们有一个功能是选取视频中的框然后就可以实时的跟踪锁定这一个物体，例如跟车或者跟随人物等更加的有利于航拍。
那么我虽然开发不了一个能集成到无人机飞控系统中的这样的软件，我就在思考能不能做一个小程序可以实时框选目标然后跟踪它。
准备工作 语言： 在使用的语言之中我采用了Python来进行实现，因为Python的软件包是实在是很多，例如我们这次的程序就需要用到这个东西。
软件包： 这次的程序和我之前的OpenCV程序比起来要简单很多，只使用了CV2也就是OpenCV这么一个软件包。
效果演示 代码解读 （1）导入OpenCV库 import cv2 （2）使用 cv2.VideoCapture 打开指定路径的视频文件 # 打开视频文件 vid = cv2.VideoCapture("D:\\Dji\\00002\\DJI_0029.MP4") （3）使用 vid.read() 读取视频的第一帧，ret 表示是否成功读取，fr 包含实际的视频帧 # 读取第一帧 ret, fr = vid.read() （4）弹出一个窗口，然后我们通过拖动鼠标选择需要跟踪的区域（ROI）。选择的ROI作为一个元组（initial_box）返回，表示对象跟踪的初始边界框 # 选择初始边界框 initial_box = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d4bd15d6ddcb1d7e965a8d80d9edc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d10efac7270250701a18bfacf1b4f6/" rel="bookmark">
			LM317MDT-TR/LM/LM317T/LM317L中文资料产品文档PDF档手册规格书引脚图原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LM317MDT-TR/LM/LM317T/LM317L中文资料产品文档PDF档手册规格书引脚图原理图 产品概述：
LM217M 和 LM317M 是采用 DPAK 和 SOT223 封装的单片集成电路，用作正可调稳压器。它们设计用于提供高达 500 mA 的负载电流，输出电压可在 1.2 至 37 V 范围内调节。标称输出电压仅由一个电阻分压器选择，使该器件非常易于配置，并避免使用多个固定稳压器。
产品功能：
输出电压范围：1.2 至 37V输出电流超过 500 mA线性调整率 （典型值） 0.01%负载调整率 （典型值） 0.1%热过载保护短路保护输出转换安全区域补偿适用于高压应用的浮动操作 规格书参数：
引脚图：
电路原理图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7e71aa0e284f0da559ba19677e4db6/" rel="bookmark">
			【前端面经】三年&#43;面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 离职原因：没有晋升空间和人文关怀，同时也考虑到个人发展原因，于是想跳槽。
大概是从过完年过来开始改简历，2月19号开始投递简历，去年年底经历了很多事情，丧失了继续待下去的决心。投递简历基本上都是在boss 直聘、智联招聘上投的简历。
下面简单介绍一下我面的
背景： 公司地址稍微偏一点岗位招聘感觉比较急自研965 基本情况 hr和用人部门筛完简历，Call我，沟通预约了面试时间一面面试官是技术，巧得是我上一家公司他也待过，接下来就是聊项目聊技术，这个环节薪资被砍了一波，对我的技术还是蛮满意的。面试前还是有点小紧张，面试过程中倒是夸夸其谈
3.二面面试官是他的领导，觉得我要的薪资高了，尝试压一压我的薪资 一面 自我介绍原型链，改变this指向的方式有哪些是否有封装工具库（类似lodash）、组件，均采用发布npm的方式forEach与filter的区别？怎么中断循环？（这里注意for循环与forEach、map等终止循环方式不一样）处理数据，实际场景（考察find与findIndex）map实际工作中哪些场景用到项目中有无封装hook？有什么优点？一行3个div使用flex布局怎么写不使用全局状态管理pinia、vuex，也不使用props、emit方式怎么在父组件传递数据到任意子组件（考察Provide和Inject）是否会三维方面的，比如使用gis实际场景：两个div，第一个div是标准流，渲染的地图，第二个div是写的定位，渲染的图表，怎样做到触发地图div的事件而不触发图表div的事件（考察pointer-events: none;）项目中封装了哪些组件？ 二面 自我介绍换工作原因接着就是挑刺，压薪资了 准备面试过程中复习的面试题 常见的设计模式有哪些？
单例模式、工厂模式、观察者模式、策略模式、适配器模式、装饰器模式、代理模式、模板方法模式、建造者
模式、享元模式等。
32种设计模式是根据什么来的？（6大程序设计原则和23种设计模式）
实践经验重复出现的问题最佳实践 前端告警和日志上报埋点都是怎么做的？
前端告警：
在代码中使用try-catch块来捕获异常，并在catch块中将异常信息发送到后端服务器或第三方错误监控平
台。
使用全局的错误处理函数，如window.onerror，来捕获未被try-catch捕获的异常。
将错误信息包含堆栈信息、用户环境和其他相关数据，并通过HTTP请求或WebSocket等方式将其发送到
后端服务器。
日志上报埋点：
在关键业务逻辑、用户操作和页面加载等关键点上插入埋点代码，用于记录相关的日志信息。日志信息可以包括用户行为、请求参数、响应时间、错误信息等。将日志信息通过HTTP请求或WebSocket等方式发送到后端服务器或第三方日志分析平台。 当前了解的前端层面的新技术有什么？
Vite: Vite 是一个由 Vue.js 核心团队维护的新一代前端构建工具。与传统的基于 webpack 或者 Rollup 的
构建工具不同，Vite 借助 ES 模块的特性，实现了基于浏览器原生 ES imports 的开发服务器。这使得 Vite
在开发过程中能够实现快速的冷启动、模块热更新等特性，极大地提升了开发体验。
TypeScript: TypeScript 是一种由微软开发的超集 JavaScript 的语言，增加了类型系统和其他高级功能，
使得代码更容易维护和调试。TypeScript 已成为许多JavaScript项目的首选语言，并且被广泛用于开发大
型、复杂的应用程序。
vite对比其他打包工具有什么优势？缺点？
优势：
快速的冷启动：Vite 利用现代浏览器的 ES 模块特性，实现了零配置的快速冷启动。这意味着在开发过程
中，当你修改代码并重新加载页面时，Vite 可以非常快速地重新构建和刷新页面，从而提高开发效率。
按需引入： Vite 支持按需引入模块，只会将实际使用到的模块加载到浏览器中，而不是像传统的打包工
具一样将整个应用打包成一个或多个 bundle。这可以减少首次加载和热更新的时间，提高应用的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b7e71aa0e284f0da559ba19677e4db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b05db93a54089cf65bb16a53e96466/" rel="bookmark">
			python实战项目 名片管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ：
1.名片管理系统的重要性：
2.博客内容概要：
3.学习此名片管理系统的益处：
4.名片管理系统要求 ：
5.注意：
6.代码实现 ：
6.1第一种方法的设计思路
6.2第一种方法的代码实现 6.3第二种方法的设计思路 6.4第二种方法的代码实现
7.总结 ：
致谢：
前言 ：
欢迎来到我们的Python名片系统博客！在这里，我们将与您分享关于Python编程语言的种种奇妙之处，以及如何利用它构建一个简单而强大的名片管理系统。
Python作为一种简洁、易读的编程语言，深受程序员和初学者的喜爱。通过本博客，您将了解到如何利用Python的优势，快速搭建一个功能完善的名片管理系统，为您的工作和生活带来便利。
无论您是想要提升自己的编程技能，还是寻找一个实用的项目来实践，本博客都将为您提供有益的指导和灵感。让我们一起探索Python的魅力，打造一个个性化、高效率的名片系统吧！
1.名片管理系统的重要性： 名片管理系统在现代社会中具有重要性，主要体现在以下几个方面：
组织信息：名片管理系统可以帮助个人或组织有效地组织和管理大量的联系信息。通过系统化的存储和分类，用户可以快速查找需要的联系人信息，提高工作效率。
提升专业形象：一个规范、完善的名片管理系统不仅展示了用户的组织能力，也反映了其对工作的认真态度。在处理商务往来时，有序的名片管理系统能够增强个人或企业的专业形象。
便捷沟通：通过名片管理系统，用户可以随时随地访问联系人信息，并通过各种方式快速与其沟通，如电话、邮件、社交媒体等。这为合作、沟通和交流提供了便利。
数据分析：名片管理系统还可以通过数据分析功能，帮助用户更好地了解自己的人脉关系，发现潜在的商机或合作伙伴。通过数据统计和分析，用户可以更有针对性地进行人际关系管理。
综上所述，名片管理系统不仅是一个简单的联系信息数据库，更是一个提升工作效率、加强人际关系、拓展商务渠道的重要工具。通过合理利用名片管理系统，用户可以更加高效地管理自己的人脉资源，实现个人和组织的发展目标。
2.博客内容概要： 名片管理系统的设计思路和需求分析：介绍名片管理系统的基本功能和设计理念，包括用户需求调研、系统功能设计等方面。
Python编程基础：对Python编程语言的基础知识进行训练熟悉，包括数据类型、条件语句、循环结构等，为后续系统开发打下基础。
构建名片管理系统的关键功能：详细讲解如何使用Python实现名片管理系统的关键功能，如添加名片、删除名片、查询名片信息等。
数据库应用与文件存储：介绍如何利用数据库或文件存储来保存名片信息，以及如何与Python程序进行交互实现持久化存储。
用户界面设计与交互体验优化：探讨如何通过Python图形界面库，设计友好的用户交互界面，提升用户体验和操作便捷性。
高级功能拓展与优化：进一步讨论如何加入搜索功能、数据统计分析等高级功能，让名片管理系统更加强大和实用。
通过这些内容，读者将能够全面了解如何使用Python编程语言，构建一个功能完善的名片管理系统，并且在实践中提升自己的编程能力和项目开发经验。
3.学习此名片管理系统的益处： 学习Python编程：通过实际项目的开发，读者将有机会深入学习和理解Python编程语言的基础知识和高级应用技巧。这将为他们打下坚实的编程基础，提升技术能力。
实践项目经验积累：通过参与名片管理系统的构建，读者将积累丰富的实践项目经验，包括需求分析、功能设计、代码实现、测试调试等全流程的项目实施经验。这将对其未来的职业发展具有重要意义。
提升工作效率：如果读者能够将名片管理系统应用到实际工作中，将大大提升其工作效率，帮助其更好地管理人脉资源，拓展商务渠道。
增强编程实战能力：通过参与实际项目的开发，读者将加强自己的编程实战能力，提高问题解决和系统设计能力，为日后的项目开发打下坚实基础。
综上所述，本博客将为读者提供学习、实践和提升的机会，帮助他们在Python编程领域取得更多成就，同时也能够在实际工作和生活中受益。
4.名片管理系统要求 ： ''' 1.程序启动就会显示名片管理面板,并显示功能菜单 2.用户用数字选择不同的功能 3.根据功能选择，执行不同的功能 4.用户名片需要记录用户的 姓名、电话、年龄 5.如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 ''' 5.注意： 此名片管理系统我们可以用两种方法分别实现 ，虽然两种名片管理系统的方法不同但是实现的功能是一样的 ，并且可以实现举一反三 ，融会贯通。
6.代码实现 ： 6.1第一种方法的设计思路 用户交互：通过展示菜单和根据用户选择执行不同功能的方式，实现了与用户的简单、直观交互。用户可以通过输入数字选择相应的功能，从而完成新增、查询、修改、删除等操作。
数据结构：使用列表来存储名片信息，每个名片信息以字典的形式存储，包括姓名、年龄、电话等字段。这种数据结构简单且易于管理，便于对名片信息进行增删改查操作。
模块化设计：将不同功能拆分成独立的函数，如显示菜单、显示全部名片、查询名片、修改名片、删除名片等，使得代码结构清晰，方便维护和扩展。
错误处理：在用户输入错误或不存在的名片信息时，有相应的提示信息并要求重新输入，提高了程序的容错性和用户体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5b05db93a54089cf65bb16a53e96466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efecb66d6fa20412e852f8ce5d47fb8/" rel="bookmark">
			Redis 8种基本数据类型及常用命令和数据类型的应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们好，欢迎关注，一起学习，无限进步
文章内容为学习的一些笔记及工作中遇到的一些问题
文章目录 Redis 五大数据类型keyStringListSetHashSorted Set 三种特殊类型Geospatial 地理位置HyperloglogBitmap Redis 五大数据类型 redis 官方网张：https://redis.io/
redis 常用命令：https://www.redis.net.cn/order/
使用 SpringBoot。Jedis 连接的方法也是这些命令
key # 验证 redis 服务密码 127.0.0.1:6379&gt; auth 123456 # 查看 redis 节点信息 127.0.0.1:6379&gt; info replication # 测试是否连接 redis 127.0.0.1:6379&gt; ping # 查看所有的key 127.0.0.1:6379&gt; keys * #关闭redis 127.0.0.1:6379&gt; shutdown # 退出 127.0.0.1:6379&gt; exit # 切换数据库 127.0.0.1:6379&gt; select 3 # 查看DB大小 127.0.0.1:6379&gt; DBSIZE # 清除当前数据库 127.0.0.1:6379&gt; flushdb # 清除全部数据库的内容 127.0.0.1:6379&gt; flushall # 判断当前的key是否存在 127.0.0.1:6379&gt; exists name 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7efecb66d6fa20412e852f8ce5d47fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cecb293a7ac40eb9ed9962631420d3/" rel="bookmark">
			策略分析：Atlassian Server版停止支持，Server版用户应该转向数据中心版本还是云版？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自2024年2月15日起，Atlassian将终止对Server产品提供支持。此政策并非突然之举，早在2021年，Atlassian就停售了Server产品的许可。对于国内用户而言，这一决定带来了巨大的影响，许多企业在得知消息后就开始积极准备迁移，然而也有一些用户持观望态度。
龙智作为Atlassian全球白金合作伙伴，在终止服务前便推出了围绕此主题的一系列文章，致力于帮中国用户提供全面的支持和指导。
干货一览
专家解读：
《对话龙智高级咨询顾问、Atlassian认证专家叶燕秀：Atlassian产品进入后Server时代，中国用户应当何去何从？》
版本对比：
《Atlassian后Server时代 | Server版vs.数据中心版，二者的区别在哪里？》
迁移准备：
《Atlassian Server用户新选择 | 迁移到数据中心版前，您需要做这些准备》
《准备好迁移上云了？请收下这份迁移步骤清单》
终止支持的日期已经到来，如果您尚未采取行动，您可能有以下的疑问，我们在此为您做出解答。
我可以继续使用Server版吗？ 在刚停止支持时，理论上您可以继续使用Server版。但安全风险与日俱增的当下，继续使用Server产品可能会导致您的企业面临五大风险：
未经修补的系统漏洞让业务暴露于威胁之中
2月15日后，Atlassian将不再为Server产品安全提供补丁和更新。没有补丁或更新意味着漏洞得不到解决，导致恶意行为者更容易未经授权地访问您的数据和系统。并且还会给IT团队带来额外的负担——转移了他们原本用于支持公司战略的时间和精力，而是去进行常规的产品管理和安全保障，并且这一切都没有Atlassian的支持。
违反隐私与合规要求
使用不受支持的Server版本可能导致严重的隐私和合规问题，尤其是针对医疗、金融这样的受到严格监管的行业。这些行业应当采取严格措施来保护敏感数据和客户隐私。不受支持的软件增加了漏洞被利用的风险，从而增加了不合规的可能性，可能导致法律后果和财务处罚。
系统停机和数据丢失风险
使用不受支持的软件可能导致长时间的系统停机，产生来自内部和外部的各种风险，不论是出于好意还是恶意，都可能对系统造成不良影响，包括数据丢失、数据被篡改，甚至系统完全瘫痪。这种停机不仅影响运营效率，而且妨碍了为客户提供无缝的支持体验。
滞后的安全和技术
使用不再受支持的软件等于失去了技术支持和安全更新。更重要的是，您将错过最新的安全技术进步，使您的系统更容易受到新型网络威胁的影响。
不受支持的插件所带来的风险
Server版本将无法购买新的插件。即便是现有插件，龙智作为Atlassian合作伙伴也不再提供技术支持、安全更新和漏洞修复，因此，您的安全风险无疑大大增加。
获取《还在冒险使用过期软件？五大风险让我们提高警惕》PDF请点击……
综上所述，您可以继续使用Server产品，但您的企业很可能因此陷入安全危机中。那么，如果想要更改产品，有什么合适的选项呢？
在宣布终止对Server版提供支持后，Atlassian将其重心转向了数据中心版和云版。这意味着您可以选择更安全、更先进的解决方案，更好地适应当前的工作环境，并提升效率。
我应该迁移到本地部署的数据中心版吗？ 对于国内用户而言，本地部署的数据中心版是替代Server版的一个最优选。它不仅拥有本地部署这一天然优势，在功能等方面也有很多新的优势。
数据中心版通过安全控制、规模化性能和灵活的基础架构选择，维护自行管理的环境。其功能是Server版功能的延伸，不仅包含用户熟悉和喜爱的功能，在此之上更是增加了适合企业客户的特性。并且，从Server过渡到数据中心可谓是无缝切换，用户体验不会有一丝一毫的障碍。在当前背景下，考虑迁移到数据中心版是一项明智而全面的选择，满足企业未来发展的需求。
Atlassian针对中国用户实行特殊政策，中国企业只要用户数超25人即可使用数据中心版的Jira、Confluence等产品。
了解数据中心版
我应该迁移到云版吗？ 云版是未来的趋势，也是Atlassian后续投入的重点。它通过无缝协作、更好的集成和原生自动化，提高运营效率并专注于创新。在自动化、数据资产与管理、集成等方面，云版拥有Server版本尚不具备的独占功能。托管在云上，由Atlassian负责管理和维护，使用户能够更专注于业务需求。
近期，Atlassian宣布Jira Software、Confluence和Jira Service Management等多个产品均已全面支持AI功能，为云版客户打造人机协同的工作体验。因此，考虑迁移到云版可能是一个更具前瞻性的选择，能够适应未来工作的需要。
了解云版
迁移时间或达9个月，您需要提前规划 无论迁移到什么版本，您都需要在迁移之前进行详细的规划。这样可以避免迁移过程出现任何错漏，从而影响业务的正常进行。对于大型团队而言，从评估到启动迁移，整个过程可能需要9个月以上的时间。Server版终止支持的时间已至，建议您在Server版尚能良好使用时，尽早规划将数据迁移至具有安全保障与支持的数据中心版和云版，以免出现让您措手不及的突发情况。
迁移过程复杂，需迁移数据量大？您可以选择靠谱的Atlassian合作伙伴来协助您进行迁移。龙智是Atlassian全球白金合作伙伴，拥有从Server版迁移至数据中心版的丰富成功案例和经验。我们的Atlassian专家团队拥有两名Atlassian认证专家以及21个Atlassian认证个人，提供5*8小时的技术支持服务。我们将根据您的需求逐步为您规划一次无缝的迁移之旅，确保数据完整性和流畅的迁移体验。立即联系我们，获取更多帮助。
了解龙智Atlassian迁移解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccd8341c7f52299581ea654b7035ada/" rel="bookmark">
			Docker的简单介绍以及常用命令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Docker的简介
二、Docker安装
环境配置
阿里云镜像仓库配置
三、Docker常用命令
3.1 基本命令
3.2 镜像命令
3.3 容器命令
一、Docker的简介 Docker是一个被广泛使用的开源容器引擎，是一种操作系统级别的虚拟化技术，它以一种特殊进程的方式运行于宿主机上，它依赖于liunx内核特性：namespace（名字空间进行资源的隔离）和cgroups（限制、记录任务组所使用的物理资源），它也可以对应用程序进行打包。
简单来理解就是，在VMware上新建一个虚拟机就相当于是一台电脑；而docker呢就相当于这个VMware，不过docker如果新建两个虚拟机实际上是相当于一台电脑两个操作系统。
Docker是基于Linux内核实现的，Docker相比虚拟机的交付速度更快，资源消耗更低，启动速度更快，占用空间更小。Docker采用客户端/服务器端架构, 使用远程API来管理和创建容器, 其可以轻松的创建一个轻量级的, 可移植的, 自给自足的容器。
二、Docker安装 我这里是centos7服务器已经换成阿里源的状态下进行安装
环境配置 #查看内核
uname -r
#更新yum源为最新
yum update -y
#安装Docker所需要的工具包
yum install -y yum-utils device-mapper-persistent-data lvm2
#设置yum源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
#下载安装Docker
yum install docker-ce docker-ce-cli containerd.io -y -y
#启动Docker并且设置开机自启动
systemctl start docker
systemctl enable docker
#检测Docker是否安装成功
docker version
阿里云镜像仓库配置 进入阿里云镜像官方网址：
阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台
cd /etc/docker/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dccd8341c7f52299581ea654b7035ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbd97b17d1abad43f1847782e9259fb/" rel="bookmark">
			关于宽窄字符串和指针读取的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近这学习图像处理的入门课程，拿到老师给的源码之后半天跑不通，逐行调试的时候发现问题出在使用CString定义字符串的时候，使用char* 无法正确读取其中的内容。以下是老师所给出的源码
CString SFName; SFName = MyFDlg.GetPathName(); //读取文件名 char* fnstr;	//定义了一个char指针变量fnstr，用于存储SFName字符串的地址。 fnstr = SFName.GetBuffer(4); //read the name from string 但是给我报错说不能将“LPWSTR”类型的值分配到“char*”类型的实体。
因此我将
fnstr = SFName.GetBuffer(4); 修改为：
fnstr = (char*)SFName.GetBuffer(4); 然而这个操作之后，指针fnstr不能对SFName的内容进行完全读取，
如上面截图所示，fnstr指针只能读取到“D”而后面的路径就被完全舍去了。之后问了chatgpt，发现CString是宽字符串，需要将其改为窄字符串的类型CStringA的类型。
再次运行：
发现能够正常读取，并且使用len = strlen(fnstr);也能正确读取字符串长度，问题解决。
-------------------------------------分割线---------------------------------------------
因为不了解其中的原理，所以我查了一下chatgpt，回答如下：
为什么在使用 CString 类时，fnstr 只能获取到 "D" 而不是完整的路径，这可能是因为在 Unicode 模式下，CString 默认会将宽字符编码（Unicode）的路径存储在其中。因此，当你试图将宽字符指针强制转换为窄字符指针时，只能获取到第一个字符 "D"，因为窄字符指针无法正确解析宽字符编码的路径。而当你使用 CStringA 类型的 SFName 时，它已经明确指定了使用窄字符集，所以能够正常获取到完整的路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5d980bbbcd11221fff11f4e5ddd4a6/" rel="bookmark">
			企业销售员考核及奖金核算小程序计算机毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌ 专注于VUE,小程序，安卓，Java,python,物联网专业，有16年开发经验，长年从事毕业指导，项目实战✌选取一个适合的毕业设计题目很重要。✌关注✌私信我✌具体的问题，我会尽力帮助你。
研究的背景:
企业销售员是企业中至关重要的一环,他们直接关系到企业的销售业绩和利润。为了提高销售员的绩效和积极性,企业需要对销售员进行定期的考核和奖金核算。然而,传统的销售员考核和奖金核算方式存在许多问题,如评价标准不明确、考核过程缺乏客观数据支持、奖金分配不公平等。因此,本研究旨在开发一种企业销售员考核及奖金核算小程序,以提高销售员的绩效和积极性,促进企业销售业绩的提高。
研究或应用的意义:
企业销售员是企业中至关重要的一环,他们直接关系到企业的销售业绩和利润。传统的销售员考核和奖金核算方式存在许多问题,如评价标准不明确、考核过程缺乏客观数据支持、奖金分配不公平等。因此,本研究旨在开发一种企业销售员考核及奖金核算小程序,旨在提高销售员的绩效和积极性,促进企业销售业绩的提高,为企业的健康发展提供有力的支持。
国外研究现状:
在国外,已有许多研究致力于解决销售员考核和奖金核算问题。其中,比较有代表性的研究包括：1. 张晓丽等(2019)的研究《基于行为数据的销售员绩效评价体系构建》,通过对销售员的行为数据进行分析和建模,建立了科学合理的销售员绩效评价体系,为销售员绩效考核提供了有力支持。2. 李鹏程等(2018)的研究《基于数据挖掘的销售员绩效评估模型研究》,利用数据挖掘技术,对销售员绩效进行量化分析,建立了销售员绩效评估模型,为销售员绩效考核提供了科学依据。3. 王丽君等(2020)的研究《基于云计算的销售员绩效管理研究》,利用云计算技术,建立了销售员绩效管理平台,实现了销售员绩效的实时监控和管理,为销售员绩效考核提供了支持。4. 张杰等(2020)的研究《基于人工智能的销售员绩效评估研究》,通过应用人工智能技术,建立了基于数据的销售员绩效评估模型,提高了销售员绩效评估的准确性和效率。这些研究都采用了不同的技术手段,如数据挖掘、云计算和人工智能等,对销售员考核和奖金核算问题进行了深入探讨,并提出了有效的解决方案。
国内研究现状:
在国内,已有许多研究致力于解决销售员考核和奖金核算问题。其中,比较有代表性的研究包括：1. 张晓丽等(2019)的研究《基于行为数据的销售员绩效评价体系构建》,通过对销售员的行为数据进行分析和建模,建立了科学合理的销售员绩效评价体系,为销售员绩效考核提供了有力支持。2. 李鹏程等(2018)的研究《基于数据挖掘的销售员绩效评估模型研究》,利用数据挖掘技术,对销售员绩效进行量化分析,建立了销售员绩效评估模型,为销售员绩效考核提供了科学依据。3. 王丽君等(2020)的研究《基于云计算的销售员绩效管理研究》,利用云计算技术,建立了销售员绩效管理平台,实现了销售员绩效的实时监控和管理,为销售员绩效考核提供了支持。4. 张杰等(2020)的研究《基于人工智能的销售员绩效评估研究》,通过应用人工智能技术,建立了基于数据的销售员绩效评估模型,提高了销售员绩效评估的准确性和效率。这些研究都采用了不同的技术手段,如数据挖掘、云计算和人工智能等,对销售员考核和奖金核算问题进行了深入探讨,并提出了有效的解决方案。
研究内容:
本文研究内容为开发一种企业销售员考核及奖金核算小程序,旨在提高销售员的绩效和积极性,促进企业销售业绩的提高,为企业的健康发展提供有力的支持。为此,本文采用了一系列技术手段,包括数据挖掘、云计算和人工智能等,对销售员考核和奖金核算问题进行了深入探讨,并提出了有效的解决方案。具体来说,本文首先对传统的销售员考核和奖金核算方式进行了分析,指出了其中存在的问题,并为企业提供了一种基于行为数据的销售员绩效评价体系。其次,本文利用数据挖掘技术,对销售员绩效进行量化分析,并建立了销售员绩效评估模型,为销售员绩效考核提供了科学依据。最后,本文利用云计算技术,建立了销售员绩效管理平台,实现了销售员绩效的实时监控和管理,为销售员绩效考核提供了支持。本文的研究成果为销售员考核和奖金核算提供了一种科学、有效的方法,为企业的健康发展提供了支持。
预期目标及拟解决的关键问题:
预期目标：本文的预期目标是开发一种企业销售员考核及奖金核算小程序,旨在提高销售员的绩效和积极性,促进企业销售业绩的提高,为企业的健康发展提供有力的支持。为此,本文将采用一系列技术手段,包括数据挖掘、云计算和人工智能等,对销售员考核和奖金核算问题进行深入探讨,并提出有效的解决方案。拟解决的关键问题：传统的销售员考核和奖金核算方式存在许多问题,如评价标准不明确、考核过程缺乏客观数据支持、奖金分配不公平等。因此,本文旨在通过开发一种企业销售员考核及奖金核算小程序,解决这些问题,并为销售员考核和奖金核算提供一种科学、有效的方法。具体来说,本文将努力解决以下关键问题：1. 评价标准不明确的问题：本文将通过对销售员的行为数据进行分析和建模,建立科学合理的销售员绩效评价体系,为销售员绩效考核提供准确依据。
研究方法:
本文将采用文献研究法、实验法、经验总结法等方法,对销售员考核和奖金核算问题进行深入探讨。首先,本文将对现有的销售员考核和奖金核算方法进行文献研究,分析其存在的问题,并为企业提供一种基于行为数据的销售员绩效评价体系。其次,本文将利用数据挖掘技术,对销售员绩效进行量化分析,并建立销售员绩效评估模型,为销售员绩效考核提供科学依据。最后,本文将利用云计算技术,建立销售员绩效管理平台,实现销售员绩效的实时监控和管理,为销售员绩效考核提供支持。本文将采用多种方法,对销售员考核和奖金核算问题进行深入探讨,并提出有效的解决方案。
技术路线:
本文将采用以下1. 数据挖掘技术：本文将采用数据挖掘技术,对销售员的行为数据进行分析和建模,建立科学合理的销售员绩效评价体系,为销售员绩效考核提供准确依据。2. 统计分析方法：本文将采用统计分析方法,对销售员绩效数据进行统计分析,提取有效信息,为销售员绩效考核提供科学依据。3. 机器学习方法：本文将采用机器学习方法,对销售员绩效数据进行建模,建立销售员绩效评估模型,为销售员绩效考核提供科学依据。4. 云计算技术：本文将采用云计算技术,建立销售员绩效管理平台,实现销售员绩效的实时监控和管理,为销售员绩效考核提供支持。5. 人工智能技术：本文将采用人工智能技术,对销售员绩效数据进行建模,建立销售员绩效评估模型,为销售员绩效考核提供科学依据。
关键技术:
前端技术：小程序采用前端技术Vue.js框架开发,实现单页面应用,使用HTTP协议与后端进行通信。前端实现用户登录、商品列表、商品详情等功能,并通过Vuex实现全局状态管理。后端技术：后端采用Spring Boot框架开发,使用Mysql数据库存储数据,使用Spring Security实现用户权限控制。后端实现用户登录、商品管理、用户评价等功能,并通过RESTful API与前端进行通信。数据库技术：数据库采用Mysql实现关系型数据库,提供丰富的SQL查询功能。
预期成果:
我希望通过写作传达特定信息,即销售员考核及奖金核算小程序的开发,为企业的销售员提供一种科学、有效的方法,解决销售员考核和奖金核算过程中存在的问题,为企业的健康发展提供支持。我希望通过本文的写作,让读者了解销售员考核及奖金核算小程序的开发过程,并能够为企业的销售员提供实用的指导。
创新之处:
1. 本文的创新之处在于,通过采用Vue.js框架开发前端,实现单页面应用,使用Vuex实现全局状态管理,为用户提供了更好的用户体验。2. 本文的创新之处在于,采用Spring Boot框架开发后端,使用Mysql数据库存储数据,使用Spring Security实现用户权限控制,为企业的安全管理提供了更多的保障。3. 本文的创新之处在于,采用RESTful API与前端进行通信,实现了前后端数据的交互,提高了系统的可扩展性和可维护性。4. 本文的创新之处在于,采用Mysql实现关系型数据库,提供了丰富的SQL查询功能,为企业的数据管理提供了方便。
功能设计:
本文的功能设计主要包括以下几个方面：1. 用户登录功能：用户可以通过输入用户名和密码进行登录,登录成功后系统自动跳转到商品列表页面。2. 商品列表功能：系统会根据用户登录的权限,返回不同数量的商品列表,并且每个商品列表都会包含商品的名称、价格、库存等信息。3. 商品详情功能：用户可以点击商品的名称,进入商品详情页面,查看商品的更多信息,包括商品的描述、图片、规格等。4. 商品评价功能：用户可以在商品详情页面上对商品进行评价,评价后系统会将评价结果记录到商品的评论中。5. 商品管理功能：管理员可以登录后对商品进行添加、编辑、删除等操作。6. 用户管理功能：管理员可以登录后对用户进行添加、编辑、删除等操作。7. 数据统计功能：管理员可以登录后查看系统的数据统计结果,包括销售量、用户数、商品数等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab579df9d6036b155a48205e7d00d342/" rel="bookmark">
			K8S之Deployment的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deployment的理论和实操 Deployment控制器：概念、原理解读概述工作原理 编写Deployment资源清单文件使用案例：创建一个web站点Deployment管理pod：扩容、缩容通过deployment管理应用，实现扩容，把副本数变成3通过deployment管理应用，实现缩容，把副本数变成2 Deployment控制器：概念、原理解读 概述 Deployment是kubernetes中最常用的资源对象，为ReplicaSet和Pod的创建提供了一种声明式的定义方法，在Deployment对象中描述一个期望的状态，Deployment控制器就会按照一定的控制速率把实际状态改成期望状态，通过定义一个Deployment控制器会创建一个新的ReplicaSet控制器，通过ReplicaSet创建pod，删除Deployment控制器，也会删除Deployment控制器下对应的ReplicaSet控制器和pod资源。
扩展：声明式定义是指直接修改资源清单yaml文件，然后通过kubectl apply -f 资源清单yaml文件，就可以更改资源
Deployment控制器是建立在ReplicaSet 之上的一个控制器，可以管理多个ReplicaSet ，每次更新镜像版本，都会生成一个新的ReplicaSet ，把旧的ReplicaSet 替换掉，多个ReplicaSet 同时存在，但是只有一个ReplicaSet 运行。
如上图：ReplicaSet v1控制三个pod，删除一个pod，在ReplicaSet v2上重新建立一个，依次类推，直到全部都是由ReplicaSet v2控制，如果ReplicaSet v2有问题，还可以回滚，Deployment是建构在ReplicaSet 之上的，多个ReplicaSet 组成一个Deployment，但是只有一个ReplicaSet 处于活跃状态。
工作原理 Deployment可以使用声明式定义，直接在命令行通过纯命令的方式完成对应资源版本的内容的修改，也就是通过打补丁的方式进行修改；Deployment能提供滚动式自定义自控制的更新；对Deployment来讲，在实现更新时还可以实现控制更新节奏和更新逻辑。
什么叫做更新节奏和更新逻辑呢？
默认先创建再删除
比如说Deployment控制5个pod副本，pod的期望值是5个，但是升级的时候需要额外多几个pod，那我们控制器可以控制在5个pod副本之外还能再增加几个pod副本；比方说能多一个，但是不能少，那么升级的时候就是先增加一个，再删除一个，始终保持pod副本数是5个；
通过Deployment对象，可以做到以下事情：
1、创建ReplicaSet和Pod
2、滚动升级（不停止旧服务的状态下升级）和回滚应用（将应用回滚到之前的版本）
3、平滑地扩容和缩容
4、暂停和继续Deployment
科普：金丝雀就是先放一个新的，保留几个老的。新的就是试水的金丝雀
编写Deployment资源清单文件 查看Deployment资源对象由哪几部分组成
kubectl explain deployment 查看Deployment下的spec字段
kubectl explain deployment.spec 字段说明
minReadySeconds：k8s在等待设置的时间后才进行升级（如果没有设置该值，k8s会容器启动起来后就提供服务了）paused：暂停，当我们更新的时候创建pod先暂停，不是立即更新progressDeadlineSeconds：k8s 在升级过程中有可能由于各种原因升级卡住（这个时候还没有明确的升级失败），比如在拉取被墙的镜像，权限不够等错误。那么这个时候就需要有个 deadline ，在 deadline 之内如果还卡着，那么就上报这个情况，这个时候这个 Deployment 状态就被标记为 False，并且注明原因。但是它并不会阻止 Deployment 继续进行卡住后面的操作。完全由用户进行控制。replicas：副本数revisionHistoryLimit：保留的历史版本，默认是10selector：标签选择器，选择它关联的pod（必须设置的参数）strategy：更新策略template：定义的pod模板（必须设置的参数） 查看Deployment下的spec.strategy字段
kubectl explain deploy.spec.strategy 支持两种更新，Recreate 和 RollingUpdate
Recreate：重建式更新，删除一个更新一个RollingUpdate：滚动更新，定义滚动更新方式，也就是pod能多几个，少几个（默认策略） 查看Deployment下的spec.strategy.rollingUpdate字段
kubectl explain deploy.spec.strategy.rollingUpdate 字段说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab579df9d6036b155a48205e7d00d342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051e2ca73d5f239cdc7cb4f52d2226fb/" rel="bookmark">
			105. replace( )函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		105. replace( )函数 【目录】
文章目录 105. replace( )函数1.replace( )函数功能2.replace( )函数的应用3.replace( )函数的语法4. 代码示例4.1 替换单个字符4.2 替换多个字符4.3 指定替换次数 5. 课后练习5.1 练习15.2 练习2 6. 课后练习 【正文】 1.replace( )函数功能 replace[rɪˈpleɪs]：替换、更换。
replace的中文意思是替换，更换。
replace是Python字符串对象的一个方法，作用是将字符串中指定的子串替换为新的子串。
【功能】将指定的子字符串替换为新的字符串。
2.replace( )函数的应用 字符串替换操作在编程中非常常见，通常有以下几种情况：
修改字符串内容 当需要修改字符串中的某些内容，比如将一个单词替换为另一个单词，或者将一个字符替换为另一个字符。
数据清洗 在数据处理和文本处理中，经常需要对字符串进行清洗和规范化。例如，去除特殊字符、修正拼写错误、替换敏感词等操作都可以通过字符串替换来实现。
格式转换 有时候我们需要将字符串从一种格式转换为另一种格式。例如，将日期格式从"YYYY-MM-DD"转换为"MM/DD/YYYY"，或者将数字格式从"1,000,000"转换为"1000000"等。字符串替换操作可以帮助我们实现这种格式转换。
动态生成字符串 在一些场景下，需要根据一些规则或者条件动态生成字符串。通过替换操作，我们可以将模板字符串中的占位符替换为具体的值，从而生成最终的字符串。
总之，字符串替换操作是一种非常常用的字符串处理方式，它可以帮助我们实现字符串内容的修改、数据清洗、格式转换和动态生成等功能。
3.replace( )函数的语法 【语法】
str.replace(old, new, count) count[kaʊnt]：计数、点数。
replace( )函数由6部分组成：
1.str：要进行替换操作的字符串；2.函数名:replace3.英文小括号：( )4.old：需要被替换的子字符串；5.new：替换后的新字符串；6.count（可选）：指定替换次数，默认为全部替换。 4. 代码示例 4.1 替换单个字符 【代码示例1】
# 要操作的字符串对象 s = "Hello" # 语法：str.replace(old, new, count) # 这里没有加入count参数，默认为全部替换 # old = H，要替换的字符 # new = h，替换后的字符 # 作用：将字符串种的H字母替换为h new_s = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051e2ca73d5f239cdc7cb4f52d2226fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59d731bd418fc9e48cfca04a51c21cb/" rel="bookmark">
			DALL·E 3:Improving Image Generation with Better Captions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 论文链接：https://cdn.openai.com/papers/dall-e-3.pdf
DALLE3 API：https://github.com/Agora-X/Dalle3
官网链接：添加链接描述
DALLE3讲解视频：B站视频
推荐DALLE2的讲解视频：B站：跟李沐学AI 之前精讲的DALLE2论文
北理&amp;上海AI Lab&amp;清华提出 Mini DALL·E 3：https://arxiv.org/pdf/2310.07653.pdf
code：https://github.com/Zeqiang-Lai/Mini-DALLE3
要点分析
文章主要在讲：通过更好的文本标注（Better Captions），提升图像生成质量 1. 摘要（Abstract） 解决问题：因为数据比较noise，很难按照prompt生成需要的图片方法/贡献：提出image captioner（图片标注器），生成图像精准的标注，去训练模型 3. 文章主体 3.1. 数据生成方法 两种标注模式： 1.短标注：只描述主要物体，主体详细标注：主体、环境、背景、文字、风格等 Clip scores高于短标注 生成标注+原始文本标注的比例【意思train的时候加入生成标签，test的时候不加入呗？】 混合原因：生成文本是基于数据的模式，用户的文本（原始标注）有自己的风格，原始标注相当于正则95%&gt; 90% &gt; 80%，但是不是100%最好
用户的prompt简短，不能充分发挥模型能力 用GPT扩写用户的prompt
3.2. 评估方式 自动评估： Clip scores：用Ms COCO的caption生成图片，然后用Clip scores去评估图片文本之间的匹配程度Drawbench：Images提出的比较全的评测prompts，然后用GPT-V（多模态）来评估生成突破和Prompts的匹配度（生成模型评估生成模型hh）T2l-Compbench：与Drawbench类似，区别在于GPT-V换成VQA 人工评估： Prompt fllowing：Prompts和图像匹配程度style：图片质量，评估者是看不到Prompts，直接看两张图片哪个更好coherence：观察不合理的结构，虚幻的场景人工评估打低分，作者换成用MS COCO的Caption生成的图像去做评估 4. 实验效果 评估结果：DALL-E 3 &gt; Midjourney 5.2 &gt; Stable Diffusion XL &gt; DALL-E 2 5. 总结 方法局限性：
位置关系不准确文字的生成不行：因为T5 text encoder的局限性，它会把用户的prompts分隔开，整体把握小 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4c09bd1bdf8ed2347da4710b2c7e62/" rel="bookmark">
			【JAVA】java项目提交到gitee哪些文件可以不提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java项目中，有一些文件是不需要提交到版本控制系统的，比如Gitee。这些文件通常包括：
编译生成的文件：比如target目录下的文件，这些是由Maven或Gradle等构建工具生成的编译产物，包括编译后的.class文件、测试报告、可执行的JAR或WAR包等。这些文件在构建过程中会自动生成，因此不需要提交到版本库中。IDE配置和缓存文件：比如.settings、.project、.classpath等Eclipse或IntelliJ IDEA等IDE的配置和缓存文件。这些文件通常包含了开发者的个性化设置和本地环境的配置，对于其他人来说可能并不适用，因此不应该提交到版本库中。本地配置文件：比如application.properties、database.properties等配置文件，这些文件通常包含了数据库连接信息、API密钥等敏感信息，如果提交到版本库中可能会泄露这些信息，因此应该避免提交。日志文件：比如logs目录下的日志文件，这些文件记录了应用程序的运行日志，对于其他人来说可能并不关心，因此不需要提交到版本库中。 为了忽略这些不需要提交的文件，可以在项目的根目录下创建一个.gitignore文件，并在其中配置需要忽略的文件模式。例如，可以添加以下配置来忽略上述提到的文件：
bash
# 忽略编译生成的文件 target/ # 忽略IDE配置和缓存文件 .settings/ .project .classpath # 忽略本地配置文件 *.properties # 忽略日志文件 logs/ 这样，在提交代码时，Git就会自动忽略这些配置的文件，避免将它们提交到版本库中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939d149eb7056fc6c1146184f9fd1fc5/" rel="bookmark">
			【AI Agent系列】【MetaGPT多智能体学习】1. 再理解 AI Agent - 经典案例和热门框架综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章跟随《MetaGPT多智能体课程》（https://github.com/datawhalechina/hugging-multi-agent），深入理解并实践多智能体系统的开发。
本文为该课程的第二章（智能体综述及多智能体框架介绍)笔记）。
文章目录 0. 温故而知新 - 再看 AI Agent 是什么1. 一个AI Agent实例介绍 - BabyAGI2. 多智能体框架比较3. 警告？ 0. 温故而知新 - 再看 AI Agent 是什么 前面文章已经介绍过我理解的 AI Agent 的概念。
智能体就是像人一样，能理解现实中的事务，有记忆，会思考，会总结，会学习，像人一样会规划，会决策，会使用各种工具来完成某项任务。多智能体，就像一个团队，大了说像我们现在生活的社会，每个智能体有自己的职能和领域，人与人之间通过协作，能完成更加复杂和庞大的目标。 再看这张经典的图：
现在看来，中间的Agent应该换为LLM更为合适，而整张图才能叫做Agent。也就是说：Agent是上图中所有能力的集合，以LLM为大脑，来决定完成任务所需的步骤，规划执行该使用哪些工具，该得到什么结果。再辅以记忆能力，让整个过程像人一样能够自主决策，自主行动以自主达到目的。
1. 一个AI Agent实例介绍 - BabyAGI 项目地址：https://github.com/yoheinakajima/babyagi/blob/main/README.md
其运行流程如下：
（1）从任务列表中提取第一个任务
（2）将任务发送到执行代理（Execution Agent），该Agent使用LLM根据上下文完成任务。
（3）丰富结果并将其存储在向量数据库中
（4）创建新任务，并根据上一任务的目标和结果重新确定任务列表的优先级。
（5）重复以上步骤
其中涉及四个Agent，其中前三个Agent都利用了大模型的能力来进行任务规划和总结：
Execution Agent 接收目标和任务，调用大模型 LLM来生成任务结果。
Task Creation Agent 使用大模型LLM 根据目标和前一个任务的结果创建新任务。它的输入是：目标，前一个任务的结果，任务描述和当前任务列表。
Prioritization Agent 使用大模型LLM对任务列表进行重新排序。它接受一个参数：当前任务的 ID
Context Agent 使用向量存储和检索任务结果以获取上下文。
运行起来后的过程可以参考这篇文章：babyagi: 人工智能任务管理系统
2. 多智能体框架比较 对市面上多智能体框架了解的不多，目前为止，只用过 MetaGPT、AutoGPT，听过AutoGen。想了解更多的，可以参考这篇文章 基于大语言模型的AI Agents—Part 3，里面总结比较了常见的多智能体框架：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939d149eb7056fc6c1146184f9fd1fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e82d840fda7709e80767107e5ffb3bf/" rel="bookmark">
			★教程3:Simulink学习教程入门60例目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.订阅本教程用户可以免费获得本博任意1个(包括所有免费专栏和付费专栏)博文对应代码；
(私信博主给出代码博文的链接和邮箱)
2.本Simulink课程的所有案例(部分理论知识点除外)均由博主编写而成，供有兴趣的朋友们自己订阅学习使用。未经本人允许，禁止任何形式的商业用途；
3.本课程除了介绍常见的Simulink模块介绍之外，我们更侧重于各种实例的完整设计介绍。从通信，控制器，图像处理，语音处理，电力系统等诸多常用领域介绍了相关案例，如果对于某个较为复杂的案例，初学者无法正确复现，也可以私信博主获得完整Simulink模型文件。
4.在学习过程中，如果有疑问或者问题，可以在对应课程的下方进行留言，博主晚上会统一回复。
5.本教程主要针对Simulink建模学习使用，部分简单的matlab/simulink混合编程及S函数的编程学习。关于Simulink和MATLAB的一些复杂的混合应用相关学习在后续的相关教程中会逐渐开发。
6.在每一个simulink课程案例的最后，都增加了一个常用的simulink操作技巧。
7.本课程具体事项如下：
订阅MATLAB\FPGA\SIMULINK教程说明
★读者学习过程中的一些问题总结——不定期更新【2024-02-26更新】
Simulink教程+入门60例目录 ★Simulink基础入门 1.为什么要学习SIMULINK
2.MATLAB/Simulink安装
3.Simulink界面介绍
4.Simulink基础建模操作——加减乘除运算
5.Simulink基础建模操作——正弦余弦相关运算
6.Simulink基础建模操作——矩阵运算、for循环
7.Simulink基础建模操作——选择判决运算
8.Simulink基础建模操作——查找表的使用
9.simulink基础建模操作——数据的保存
10.simulink基础建模操作——微分，积分，差分运算
以上10个课程，我们对Simulink的基础操作有了初步的认识，在本教程的后续章节，将通过60个实例，对Simulink进行深入学习，同时对一些更高级的Simulink建模方法做同步的讲解。
一、Simulink控制器类建模仿真案例分析 1.基于Simulink的PID控制器设计与实现(含完整Simulink建模过程)
2.基于Simulink的模糊控制器设计与实现(含完整Simulink建模过程)~免费试读
3.结合MATLAB对比PID控制器和模糊控制器(含完整Simulink建模过程)
4.使用Simulink自带的模块实现PID控制器,并对比案例1的PID控制器(含完整Simulink建模过程)
5.基于Simulink的MPC控制器设计与实现(含完整Simulink建模过程)
6.基于Simulink的自适应PID控制器设计与实现(含完整Simulink建模过程)
7.基于Simulink的滑模控制器设计与实现(含完整Simulink建模过程)
8.基于simulink的LQR控制器设计——以环形倒立摆为控制对象(含完整Simulink建模过程)
▲基于simulink的控制器设计学习总结
二、Simulink无线通信和信号处理方面建模仿真案例分析 9.基于simulink的BSPK,QPSK调制解调通信系统建模与仿真——使用simulink自带模块设计(含完整Simulink建模过程)
10.基于simulink的QAM调制解调通信系统建模与仿真——使用simulink自带模块设计(含完整Simulink建模过程)
11.使用基础模块完成QPSK调制解调系统的建模与仿真(含完整Simulink建模过程)
12.基于BPSK+costas环载波同步的simulink建模与仿真分析(含完整Simulink建模过程)
13.基于QPSK的位同步simulink建模与仿真分析(含完整Simulink建模过程)
14.基于simulink的RS信道编译码+16QAM调制解调通信系统性能仿真——输出误码和星座图(含完整Simulink建模过程)
15.基于simulink的卷积维特比编译码+16QAM调制解调通信系统性能仿真——输出误码和星座图(含完整Simulink建模过程)
16.基于simulink的LDPC编译码+16QAM调制解调通信系统性能仿真——输出误码和星座图(含完整Simulink建模过程)
17.基于simulink的伪码序列相关峰检测仿真——将matlab数据导入到Simulink中作为信号源(含完整Simulink建模过程)
18.基于simulink的基础OFDM+64QAM发射接收链路仿真(含完整Simulink建模过程)
19.基于simulink的扩频通信系统建模与仿真(含完整Simulink建模过程)
20.基于simulink的OFDM通信系统信道估计建模与仿真(含完整Simulink建模过程)
▲基于simulink的通信系统设计学习总结
三、S函数和内嵌matlab编程模块的学习与应用 21.Simulink自定义函数模块学习和应用——MATLAB Function模块(含完整Simulink建模过程)
22.Simulink自定义函数模块学习和应用——Interpreted MATLAB Function模块(含完整Simulink建模过程)
23.Simulink自定义函数模块学习和应用——初识S函数和S函数设计PID控制器简单案例学习(含完整Simulink建模过程)
24.Simulink自定义函数模块学习和应用——使用S函数设计RBF神经网络PID控制器(含完整Simulink建模过程)
25.Simulink自定义函数模块学习和应用——使用S函数设计一个简单的QPSK调制解调通信链路(含完整Simulink建模过程)
四、Simulink语音图像视频处理方面建模仿真案例分析 26.Simulink中导入语音信号并实现基于门限法的语音信号端点检测(含完整Simulink建模过程)
27.Simulink中导入语音信号并实现语音信号的滤波(含完整Simulink建模过程)
28.Simulink中导入语音信号并实现语音信号的PCM编解码(含完整Simulink建模过程)
29.Simulink中导入图片并对图片进行基础操作——灰度图，二值图，旋转，缩放(含完整Simulink建模过程)
30.Simulink中导入图片并实现图片的中值滤波(含完整Simulink建模过程)
31.Simulink中导入图片并实现图片的各类形态学处理(含完整Simulink建模过程)
32.Simulink中导入图片并实现图片的各类变换域转换(含完整Simulink建模过程)
33.Simulink中导入视频并实现视频图像的基础操作——视频二值化，视频缩放，视频灰度转换(含完整Simulink建模过程)
34.Simulink中导入视频并实现视频图像的滤波,并输出每一帧的PSNR值(含完整Simulink建模过程)
35.Simulink中导入视频并实现一个简单的基于帧差法的目标跟踪算法(含完整Simulink建模过程)
▲基于simulink的语音图像视频处理系统设计学习总结
五、Simulink电力系统方面建模仿真案例分析 36.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e82d840fda7709e80767107e5ffb3bf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/59/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>