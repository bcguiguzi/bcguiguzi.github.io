<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6cc22cf6e0e3f25217875fb65af6fe/" rel="bookmark">
			第9讲 g2o求解BA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		g2o使用图模型来描述问题的结构，所以我们要用节点来表示相机和路标，然后用边来表示他们之间的观测。
我们把旋转、平移、焦距和畸变参数定义在同一个相机顶点中，然后定义相机到路标点之间的观测边。这里，我们使用的是BAL数据集。
下面是bundle_adjustment_g2o.cpp的代码
#include &lt;g2o/core/base_vertex.h&gt; #include &lt;g2o/core/base_binary_edge.h&gt; #include &lt;g2o/core/block_solver.h&gt; #include &lt;g2o/core/optimization_algorithm_levenberg.h&gt; #include &lt;g2o/solvers/csparse/linear_solver_csparse.h&gt; #include &lt;g2o/core/robust_kernel_impl.h&gt; #include &lt;iostream&gt; #include "common.h" #include "sophus/se3.hpp" using namespace Sophus; using namespace Eigen; using namespace std; /// 姿态和内参的结构 struct PoseAndIntrinsics { PoseAndIntrinsics() {} /// set from given data address explicit PoseAndIntrinsics(double *data_addr) { rotation = SO3d::exp(Vector3d(data_addr[0], data_addr[1], data_addr[2])); translation = Vector3d(data_addr[3], data_addr[4], data_addr[5]); focal = data_addr[6]; k1 = data_addr[7]; k2 = data_addr[8]; } /// 将估计值放入内存 void set_to(double *data_addr) { auto r = rotation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6cc22cf6e0e3f25217875fb65af6fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2b05ecf8fb775a8a063a8686f53134/" rel="bookmark">
			JavaScript 50道 面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一些具有代表性的js面试题，扎实一下基础，一起学习，一起进步，有则改之无则加勉。 1.下面代码的输出是什么？ function sayHi(){ console.log(name); console.log(age); var name = "Tom"; let age = 18; } sayHi(); A: Tom 和 undefinedB: Tom 和 ReferenceErrorC: ReferenceError 和 18D: undefined 和 ReferenceError 答案：D
在函数中，我们首先使用var关键字声明了name变量。这意味着变量在创建阶段会被提升（JavaScript会在创建变量创建阶段为其分配内存空间），默认值为undefined，直到我们实际执行到使用该变量的行。 我们还没有为name变量赋值，所以它仍然保持undefined的值。
使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。 在我们声明（初始化）它们之前，它们是不可访问的。 这被称为“暂时死区”。 当我们在声明变量之前尝试访问变量时，JavaScript会抛出一个ReferenceError。
关于let的是否存在变量提升，我们何以用下面的例子来验证：
let name = 'ConardLi' { console.log(name) // Uncaught ReferenceError: name is not defined let name = 'code秘密花园' } let变量如果不存在变量提升，console.log(name)就会输出ConardLi，结果却抛出了ReferenceError，那么这很好的说明了，let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。
变量的赋值可以分为三个阶段：
创建变量，在内存中开辟空间初始化变量，将变量初始化为undefined真正赋值 关于let、var和function：
let 的「创建」过程被提升了，但是初始化没有提升。var 的「创建」和「初始化」都被提升了。function 的「创建」「初始化」和「赋值」都被提升了。 2.下面代码的输出是什么？ for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2b05ecf8fb775a8a063a8686f53134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc46f00e72f52eba91d8b100f20b0368/" rel="bookmark">
			Centos8激活cockpit web控制台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 激活服务系统信息存储网络服务软件更新终端SELinux cockpit是一个基于Web的开放源代码的服务器管理工​​具，用户可以在Web浏览器中查看服务器信息，管理存储或用户，配置网络以及检查日志文件等。Cockpit的Web界面对于Linux用户非常友好，centos8默认已安装部分cockpit功能模块，但需要用户自己激活服务。账号登录后界面如下图。 激活服务 1、Centos8启动后在登录窗口提示：激活web控制台。
2、登录成功后，运行命令进行激活。
systemctl enable --now cockpit.socket #激活控制台 systemctl disable --now cockpit.socket #移除控制台 3、输入exit，回车退出登录账户。回到登录窗口，出现如下信息。
4、在浏览器输入上图网址，进入控制台登录界面，输入账号密码登录。
5、可以查看或配置系统、日志、存储、网络、账户、服务、内核转储、软件更新、应用、终端、Diagnostic Reports、SELinux等。
系统信息 存储 网络 服务 软件更新 终端 SELinux 6、安装cockpit所有功能模块命令。
# yum install -y cockpit*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caa8decd85d5786dfe900e09c58314c/" rel="bookmark">
			GIS-空间分析（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、叠置分析（叠加分析）
1.基本概念
叠置分析是将代表不同主题的各个数据层面进行叠置产生一个新的数据层面，叠置结果 综合了原来两个或多个层面要素所具有的属性。叠置分析不仅生成了新的空间关系，而且还 将输入的多个数据层的属性联系起来产生了新的属性关系。叠置分析要求被叠加的要素层面 必须是基于相同坐标系统的相同区域。
2.叠置分析类型
实际操作中，叠加分析首先应该考虑要素的类型。叠加分析包括两组操作类型。第一组使用两个多边形图层作为输入图层。第二组则使用一个多边形图层和另一个包括点要素或线要素的图层。因此，按要素类型，叠加分析分成“点与多边形的叠加”、“线与多边形的叠加”、“多边形与多边形的叠加”三种类型。为讨论方便，将可能是点、线或多边形的图层称为输入图层；而将要被叠加其他要素的多边形图层称为叠置图层。 在“点与多边形的叠置”操作中，输入图层的点要素被叠加到叠置图层上，并且被赋予叠置多边形的属性。例如，利用“点与多边形的叠置”可寻找野生动物位置与植被类型之间 的关系，如图1-36所示。
在“线与多边形叠置”操作中，输出图层含有输入图层的线要素，其中，线要素被叠置图层的多边形边界所分割，如图1-37所示，因此，输出图层的弧段数比输入图层更多。输出图层中的每个线段合并了线状图层的属性和叠置多边形的属性。查找所拟建道路的土壤数据就是“线与多边形叠置”的一个例子。输入图层是包括有拟建道路的线图层，叠置图层为土壤图层。输出图层显示为被分割的拟建道路，每个路段有与其毗邻的不同土壤数据集合。
在“多边形与多边形叠置”操作中，输出图层将输入图层和叠置图层的多边形边界组合 在一起，生成一系列新的多边形，每个新的多边形都携有两个图层的属性，并有别于毗邻多 边形的属性，如图 1-38 所示。例如，高度带与植被类型之间的关系分析就属于“多边形与 多边形叠置”。
3.叠加分析应用 1）叠加分析方法
在不同的GIS软件中，对叠加分析的叫法不同，但所有叠加方法都是基于布尔连接符的运算，比如AND、OR和XOR。下面主要介绍擦除、相交、联合、标识、更新、交集取反和空间连接七种叠加分析。
任务1：擦除分析
擦除（erase）分析是在输入数据层中去除与擦除数据层相交的部分，形成新的矢量数据层的过程。擦除要素可以为点、线和面，点擦除要素仅用于擦除输入要素中的点，线擦除要素可以用于擦除输入要素中的线和点，面擦除要素可用于擦除输入要素中的点，线和面，如图1-39所示。
1）实验数据：“/chp1/叠加分析/擦除/data”
2）实验步骤：
①在ArcToolbox中双击【分析工具】-【叠加分析】-【擦除】，打开【擦除】对话框，如图1-40所示，其参数说明见表1-19所示。
②在【擦除】对话框中，输入【输入要素】、【擦除要素】数据，指定输出要素类的保存路径和名称。
③【XY容差】为可选项，在其文本框中输入容差值，并设置容差值的单位。
④单击【确定】按钮，完成擦除分析操作。
表1-19 【擦除】参数说明
参数
说明
数据类型
输入要素（in_features）
输入要素类或图层。
Feature Layer
擦除要素（erase_features）
用于擦除重叠输入要素的要素。
Feature Layer
输出要素类（out_feature_class）
该要素类只包含与“擦除要素”不重叠的“输入要素”。
Feature Class
XY容差（cluster_tolerance）
所有要素坐标（结点和折点）之间的最小距离以及坐标可以沿X或Y方向移动的距离。
Linear unit
实验说明：
1）将与擦除要素几何重叠的输入要素几何移除；
2）擦除要素可以为点、线或面，只要输入要素的要素类型等级与之相同或较低。面擦除要素可用于擦除输入要素中的面、线或点；线擦除要素可用于擦除输入要素中的线或点；点擦除要素仅用于擦除输入要素中的点；输入要素类的属性值将被复制到输出要素类。
任务2：相交分析
相交（intersect）分析是计算输入要素的几何交集的过程，如图1-41所示，所有图层和要素类中相叠置的要素或要素的各部分将被写入到输出要素类。
1）实验数据：“/chp1/叠加分析/相交/data”。
2）实验步骤：
①在ArcToolbox中双击【分析工具】-【叠加分析】-【相交】，打开【相交】对话框，如图1-42所示，其参数说明见表1-20所示。
表1-20 【相交】参数说明（续表见下页）
参数
说明
数据类型
输入要素（in_features）
输入要素类或图层列表。要素间距小于拓扑容差时，等级较低的要素将被捕捉到等级较高的要素。最高等级为一。
Value Table
输出要素类（out_feature_class）
输出要素类。
Feature Class
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caa8decd85d5786dfe900e09c58314c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c4abd56e08a76212eb2acb6df45b44/" rel="bookmark">
			C&#43;&#43; opencv 图像代数运算——对比度调整和背景相减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对比度调整 实验要求：
设计一个Sigmoid函数，实现对图像的对比度调整；
–使用opencv窗口系统的slider控件，交互改变Sigmoid函数的参数，实现不同程度的对比度调整；
对比度含义： 调整之后的 sigmoid函数： 实验思路：
我构建了 sigmoid函数，使用了三层for循环，一层遍历行，一层遍历列，还有一层遍历通道数（3通道），加入滑动条来传入对比度和亮度的参数，然后 在相应位置乘以了c_p（决定对比度），b_value（决定亮度），并使用了saturate_cast&lt;uchar&gt;函数来防止溢出。
效果图：
其中 sigmoid 函数的 参数可以自己调制
#include &lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; #include"opencv2/imgproc/imgproc.hpp" #include&lt;cmath&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int c_p; int b_value; Mat image, mask; void IntensityAndContrast(int, void *) { namedWindow("原图", WINDOW_AUTOSIZE); for (int y = 0; y &lt; image.rows; y++) { for (int x = 0; x &lt; image.cols; x++) { for (int c = 0; c &lt; 3; c++) { double u = ((image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c4abd56e08a76212eb2acb6df45b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48723044edcca3f45d67eb7150c20548/" rel="bookmark">
			计算几何汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算几何——点、直线（线段）、向量、多边形、圆类
计算几何——向量的叉乘、点乘、夹角
计算几何——点到直线的距离、投影点
计算几何——判断点是否在线段上
计算几何——判断两线段是否相交
计算几何——判断点是否在多边形内
计算几何——直线、线段和圆的交点
计算几何——多边形面积
计算几何——扇形面积
计算几何——多边形和圆相交的面积
计算几何——空袭计算
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae39a0cb7a36a6f919cce283e0e1d81/" rel="bookmark">
			挂载EMMC并测试读写速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //查看分区 sudo fdisk -l cat /proc/partitions //挂载SD 卡 mount /dev/mmcblkXpX /mnt/mmc mount -t vfat /dev/mmcblkXpX/mnt //卸载SD卡 umount /mnt //上电挂载SD卡 vim /etc/init.d/rcs //add mount -t vfat /dev/mmcblkXpX /mmc //测试读写速度 //回收站、无底洞 /dev/null //产生字符 /dev/zero //测试磁盘读能力 time dd if=/dev/zero of=/mnt/usb/test.dbf of=/def/null bs=4k //因为/dev/sdb是一个物理分区，对它的读取会产生空字符流，对它不会产生I/O，所以，I/O都会集中到of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。命令结尾添加oflag=sync将跳过hdd缓存。 //测试磁盘的读能力 time dd if=/mnt/usb/test.dbf of=/dev/null bs=4k //因为/dev/sdb是一个物理分区，对它读取会产生I/O，/dev/null是伪设备，相当于黑洞，of到该设备不会产生I/O，所以这个命令的I/O只发生在/dev/sdb上，也相当于测试磁盘的读能力 //测试磁盘的读写能力 time dd if=/dev/sdb of=testrw.dbf bs=4k //因为在这个命令下，一个是物理分区，一个是实际的文件，对他们的读写都会产生I/O（对/dev/sdb是读，对/testrw.dbf是写），假设他们都在一个磁盘中，这个命令相当于测试磁盘的同时读写能力。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a95208ccffa7daf17effe02541a4be7/" rel="bookmark">
			Word2013设置多级标题自动编号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目标 文档有多级标题，想要word根据标题级别自动添加编号，并且随着标题增删可以动态调整。
方法 参考百度经验https://jingyan.baidu.com/article/60ccbceb477b0764cab197f3.html。
简单总结一下：
设置标题级别；在多级列表下定义新的多级列表；特别要注意的一点是，所有列表全部关联标题以后，再点击确定。不要单个级别列表关联一个标题之后就点击确定。这样才能让多级列表关联起来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fd72aae05c791965e23dab87a89088/" rel="bookmark">
			RestTemplate注入失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 异常：
Description: Field restTemplate in com.lch.myairpan.login.LoginController required a bean of type 'org.springframework.web.client.RestTemplate' that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) Action: Consider defining a bean of type 'org.springframework.web.client.RestTemplate' in your configuration. 原因分析：网上说这个玩意儿不能直接注入 ，需要些配置类，写完配置类后，可以正常启动服务，but 用eureka发请求，报错未知的主机名。具体原因未知（估计是配置类写的不对，这个还要好好研究一下）。
解决办法：
在启动类加注解配置，通过注解初始化bean 顺利通过eureka发现服务
@Bean public RestTemplate restTemplate(){ return new RestTemplate(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b440fc5a9641725d6bfb146990350792/" rel="bookmark">
			g2o图优化简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载自：公众号 计算机视觉life
g2o与ceres的比较：
g2o库：
公开的API说明比较少，对入门小白不太友好，看起来会头大。
使用固定的模板，不太灵活
提供了预先定义好的接口，需要做的工作比较简单，比较傻瓜
ceres库：
本身是针对一般优化问题的库，更通用
给了开发者很大的空间和自由度去自己设计优化策略
当然需要做的工作也比较多，需要自己定义顶点边等接口
总之，g2o就像一个傻瓜相机，预先设置好了很多参数，你 只能从固定模式中选择
ceres就像一个专业相机，需要你懂参数，然后自己根据需要调节参数，适用范围更广
g2o的输出信息：
iteration,表示迭代次数
chi2, chi表示误差平方
time,表示运行时间
cumTime,表示积累的运行时间
edges,表示边的数目
schur，表示舒尔补
从零开始一起学习SLAM | 理解图优化，一步步带你看懂g2o代码：
https://mp.weixin.qq.com/s/j9h9lT14jCu-VvEPHQhtBw
从零开始一起学习SLAM | 掌握g2o顶点编程套路：
https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;mid=2247486992&amp;idx=1&amp;sn=ecb7c3ef9bd968e51914c2f5b767428d&amp;chksm=97d7eb87a0a062912a9db9fb16a08129f373791fd3918952342d5db46c0bc4880326a7933671&amp;scene=21#wechat_redirect
从零开始一起学习SLAM | 掌握g2o边的代码套路：
https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;mid=2247487082&amp;idx=1&amp;sn=d4a27e4c9a76760fffb571f57f4f7719&amp;chksm=97d7ebfda0a062eba412877e9ecf5933f2051f0210c0d56f03267985512d97f2db434ab7356c&amp;scene=21#wechat_redirect
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2961355aeddcb4cc3849e2fadc3dacc0/" rel="bookmark">
			ABAQUS中Standard分析模块和Explicit分析模块的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、选择： ABAQUS/Standard：能够广泛领域的线性和非线性问题，包括静态分析、动态分析，以复杂的非线性耦合物理场分析等。
没有稳定时间增量的限制：完成指定分析，一般需要较少的时间增量；因为每个增量步都需要求解线性方程组，所以每个增量步的费用非常昂贵；适合于模拟与模型的振动频率相比研究响应周期较长的问题；由于时间增量的限制，使用显式动力学求解效率很低；用于具有适度非线性的问题，其中非线性是平滑的（比如，塑性）；如果是平滑的非线性响应， Abaqus/Standard需要较少次数的迭代找到收敛解。 ABAQUS/Explicit：适用于求解非线性动力学问题和准静态问题，特别是用于模拟短暂、瞬时的动态事件，如冲击和爆炸问题。此外，它对处理接触条件变化的高度非线性问题也非常有效（例如模拟成形问题）。
有稳定时间增量的限制： 完成指定分析，一般需要较多的时间增量；因为不需要求解线性方程组，所以每个增量步的费用较低；所有的计算费用与单元计算相关；适合于模拟高速动力学问题；需要较少的时间增量，隐式动力学效率较低；对于包含不连续的非线性问题，一般更加可靠；接触行为是不连续的，并且包含碰撞，对于隐式时间积分，接触和碰撞将产生求解问题；其它不连续行为包括屈曲和材料失效。 对于求解光滑的非线性问题,ABAQUS/Standard是更有效的;另一方面,对于波的传播分析,ABAQUS/Explicit是明确的选择。然而,有一些静态或准静态问题,应用任何程序都能很好的进行模拟。特别的是,有些问题一般使用ABAQUS/Standard进行求解,但是由于接触或者材料的复杂性,可能难以收敛,从而导致大量的迭代。因为每次迭代都需要求解由大量线性方程组成的方程组,这些使用ABAQUS/Standard的分析,其代价是相当昂贵的。
ABAQUS/Standard必须进行迭代才能确定非线性问题的解答,而ABAQUS/Explicit通过由前一增量步显式地前推动力学状态,确定解答无需进行迭代。应用显式方法,即便对于一个给定的可能需要大量的时间增量步的分析,如果同样的分析应用ABAQUS/Standard亦需要大量的迭代,应用ABAQUS/Explicit进行分析可能是更为有效的。
对于同样的模拟,ABAQUS/Explicit的另一个优点是它需要的磁盘空间和内存远远小于ABAQUS/Standard。对于可以比较两个程序计算成本的问题,节省大量的磁盘空间和内存使得ABAQUS/Explicit更具有吸引力。
2. 区别： ABAQUS/Standard: 是一个通用模块，它采用隐式求解方法。在每个求解增量步中，隐式地求解方程组。
ABAQUS/Explicit: 可以进行显示动态分析。在时间域中以很小的时间增量步向前推出结果，而无需在每个增量步求解耦合的方程系统或者生成总体刚度矩阵。
在ABAQUS/Standard和ABAQUS/Explicit之间的主要区别
参量
ABAQUS/Standard
ABAQUS/Explicit
单元库
提供了丰富的单元库。
提供了适用于显式分析的丰富的单元库,这些单元是在ABAQUS/Standard中单元的子集。
分析过程
一般过程和线性摄动过程。
一般过程。
材料模型
提供了广泛的材料模型。
类似于在ABAQUS/Standard中的材料模型;一个显著的区别是提供了允许材料失效的模型。
接触公式
对于求解接触问题,具有强健的能力。
具有强健的接触功能,甚至能够解决最复杂的接触模拟。
求解技术
应用基于刚度的求解技术,具有无条件稳定性。
应用显式积分求解技术,具有条件稳定性。
磁盘空间和内存
由于在增量步中大量的迭代,可能占用大量的磁盘空间和内存。
磁盘空间和内存的占用量相对于ABAQUS/Standard要小很多。
3、隐式和显式分析中网格加密的成本 使用显式方法,耗时与单元数量成正比,并且大致与最小单元的尺寸成反比。由于增加了单元的数量和减小了最小单元的尺寸,因此网格细划增加了计算成本。
作为一个例子,考虑由均匀的方形单元组成的一个三维模型,如果沿所有三个方向以2倍的因数细划网格,作为单元数目增加的结果而增加的计算成本为2×2×2倍,而作为最小单元尺寸减小的结果而增加的计算成本为2倍。由于网格细划,整个分析的计算成本增加为,或16倍。磁盘空间和内存需求与单元数目成正比,与单元尺寸无关;因此,这些需求增加为8倍。
对于显式方法,可以很直接地预测随着网格细划带来的计算成本增加,而当采用隐式方法时,预测成本是非常困难的。困难来自于在单元连接和求解成本之间的关系,在显式方法中不存在这种关系。应用隐式方法,经验表明对于许多问题的计算成本大致与自由度数目的平方成正比。考虑一个采用均匀的、方形单元的三维模型的同样例子,如果沿三个方向都以2倍的比例细划网格,自由度的数目大致增加为倍,导致计算成本大约增加为倍,或64倍。尽管实际的增加难以预测,但是磁盘空间和内存的需求将以同样的方式增加。
只要网格是相对均匀的,随着模型尺寸的增长,显式方法表明比隐式方法节省了大量的计算成本。应用显式与隐式方法,图1说明了计算成本与模型尺寸的比较。对于这个问题,自由度数目与单元数目成比例。
图1 隐式和显式方法中耗费-模型尺寸图
参考文献
《ABAQUS有限元实例详解》石亦平等《Abaqus/Standard 有限元入门指南》庄茁等 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c0520fc18ea8d08546966596e6fbce/" rel="bookmark">
			在js里面获取当前时间的前六个月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var time = new Date(); time.setTime(time.getTime()); var s2 = time.getFullYear()+"-" + (time.getMonth()+1) + "-" + time.getDate(); var monthNum=6; //要减的月数(6)自己定义 var dateArr = s2.split('-'); //s2当前时间 var year = dateArr[0]; //获取当前日期的年份 var month = dateArr[1]; //获取当前日期的月份 var day = dateArr[2]; //获取当前日期的日 var days = new Date(year, month, 0); days = days.getDate(); //获取当前日期中月的天数 var year2 = year; var month2 = parseInt(month) - monthNum; if (month2 &lt;=0) { year2 = parseInt(year2) - parseInt(month2 / 12 == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c0520fc18ea8d08546966596e6fbce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355da48985c9c2f813fce1f429b72ae4/" rel="bookmark">
			AccssRefused: (0, 0): (403) ACCESS_REFUSED - Login was refused using authentication mechanism AMQPL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天装openstack，中途重启下机器，装到nova的时候，无法启动 openstack-nova-compute.service服务。报错如下：
[root@venus nova]# journalctl -xe -- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel -- -- Unit openstack-nova-compute.service has begun starting up. 10月 15 11:42:11 venus systemd[1]: openstack-nova-compute.service: main process exited, code=exited, status=1/FAILURE 10月 15 11:42:11 venus systemd[1]: Failed to start OpenStack Nova Compute Server. -- Subject: Unit openstack-nova-compute.service has failed -- Defined-By: systemd -- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel -- -- Unit openstack-nova-compute.service has failed. -- -- The result is failed. 10月 15 11:42:11 venus systemd[1]: Unit openstack-nova-compute.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355da48985c9c2f813fce1f429b72ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d04ce4590a452c7d3de49034da3798d/" rel="bookmark">
			Opencv 对比度增强 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opencv 对比度增强 C++ 计算直方图伽马变换直方图正规化全局直方图均值化限制对比度的自适应直方图均值化 计算直方图 # include &lt;opencv2\core\core.hpp&gt; #include &lt;opencv2\highgui\highgui.hpp&gt; #include&lt;opencv2\imgproc\imgproc.hpp&gt; //#include&lt;cmath&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; Mat calcGrayHist(const Mat&amp; image) { //存储256个灰度级的像素个数 Mat histogram = Mat::zeros(Size(256, 1), CV_32FC1); //图像的高和宽 int rows = image.rows; int cols = image.cols; //计算每个灰度级的个数 for (int r = 0; r &lt; rows; r++) { for (int c = 0; c &lt; cols; c++) { int index = int(image.at&lt;uchar&gt;(r, c)); histogram.at&lt;int&gt;(0, index) += 1; } } return histogram; } 伽马变换 # include &lt;opencv2\core\core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d04ce4590a452c7d3de49034da3798d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3431f7cb8a407fc70107fb1704f644b3/" rel="bookmark">
			neo4j从安装到远程访问一气呵成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从安装到远程访问配置 安装Java JDKJDK下载JDK配置环境 安装Neo4jNeo4j下载系统变量设置通过控制台启动 Neo4j注册 Neo4j 服务启动 Neo4j 服务停止 Neo4j 服务重启 Neo4j 服务查询 Neo4j 服务状态注销 Neo4j 服务 配置Neo4j允许远程访问neo4j.conf配置开放特定端口访问 安装Java JDK Neo4j 是基于 Java 的持久化引擎，运行 Neo4j 需要启动 JVM 进程，因此必须先安装 Java JDK。
JDK下载 下载JDK：https://download.csdn.net/download/u011440696/11866977，进行安装。
JDK配置环境 安装好后，鼠标点击计算机右键-&gt;属性-&gt;高级设置
系统变量-&gt;新建
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk1.8.0_172
（以安装路径为主）
系统变量-&gt;新建
变量名：CLASSPATH
变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
（注意符号，建议直接复制粘贴）
系统变量-&gt;编辑
找到Path选项：
变量名：Path
变量值：将 %JAVA_HOME%\bin; 此内容写在最前面（注意符号，建议直接复制粘贴）
完成配置。
安装Neo4j Neo4j下载 下载Neo4j社区版“neo4j-community-3.3.5”：https://download.csdn.net/download/u011440696/11867045，解压到目录，D:\neo4j-community-3.3.5。
系统变量设置 通过控制台启动 Neo4j 使用管理员身份打开命令行工具，进入D:\neo4j-community-3.3.5\bin目录下，输入如下命令：
neo4j.bat console
注册 Neo4j 服务 使用管理员身份打开命令行工具，进入D:\neo4j-community-3.3.5\bin目录下，输入如下命令:
neo4j install-service
启动 Neo4j 服务 使用管理员身份打开命令行工具，进入D:\neo4j-community-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3431f7cb8a407fc70107fb1704f644b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2235b0b19499bf16fa5c77871e9388ef/" rel="bookmark">
			模拟幅度调制系统抗干扰性能仿真分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟幅度调制系统抗干扰性能仿真分析 文章目录1、引言2、系统模型2.1、AM调制2.2、DSB-SC调制2.3、SSB调制 3、抗干扰性能理论分析4、仿真实现与仿真结果`5、小结6、参考文献 文章目录 1、引言 研究目的：理解AM、DSB-SC、SSB三种幅度调制方式，能够写出三种调制方式的过程，理解噪声在各个部分所产生的影响。
主要内容：用matlab模拟三种幅度调制，给出各点的时域、频域，求出噪声解调前后的功率和功率谱，最后给出信噪比。
2、系统模型 2.1、AM调制 调制信号m(t)与直流分量A0叠加后，与载波cosωct相乘后，输出的就是AM信号。
2-1 AM调制器模型 AM信号的时域表达式为：
sAM(t)=[A0+m(t)]cosωct=A0cosωct+m(t)cosωct
AM信号的频域表达式为：
sAM(ω)=πA0[δ(ω+ωc)+δ(ω-ωc)]+1/2[M(ω+ωc)+M(ω-ωc)]
AM信号的典型波形和频谱如下图所示：
2-2 AM信号波形及频谱 解调采用相干解调，模型如下图所示：
2-3 相干解调模型 将已调信号sAM(t)与载波信号相乘，得到
sAM(t) · cosωct = [A0+m(t)]cos2ωct=1/2 [A0+m(t)]+ 1/2[A0+m(t)] cos2ωct
将上述信号通过低通滤波器后就可以得到原始的调制信号
m0(t)=1/2[A0+m(t)]。
2.2、DSB-SC调制 DSB调制器的模型如图所示，实际上是基带信号与载波信号相乘：
2-4 DSB-SC调制器模型 sDSB(t)=m(t)·cosωct
sDSB(ω)=1/2[M(ω+ωc)+M(ω-ωc)]
DSB解调器模型与AM相同，已调信号与载波信号相乘后再通过低通滤波器：
sDSB(t)·cosωct=m(t)·cos2ωct =1/2 m(t)+ 1/2m(t) cos2ωct
经过低通滤波器后得：
m0(t)=1/2m(t)
2.3、SSB调制 产生SSB信号主要有两种：相移法和滤波法，由于滤波法较难实现，采用相移法，下图为其原理：
2-5相移法产生SSB信号 sSSB(t)=1/2m(t)cosωct +/- 1/2m(t)sinωct
解调方法与前两种相同，都为相干解调：
sSSB(t) · cosωct = [1/2m(t)cosωct +/- 1/2m(t)sinωct] · cosωct =1/4m(t)+1/4cos2ωct +/- 1/4sin2ωct
经过低通滤波后得到：
m0(t)=1/4m(t)
3、抗干扰性能理论分析 以DSB-SC为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2235b0b19499bf16fa5c77871e9388ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b17dae1c9f1e73ab02e6a0f1827c643/" rel="bookmark">
			Linux文件引用计数的逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux文件引用计数的逻辑 -v0.1 2019.10.10 Sherlock init
本文分析现在Linux内核中对打开文件引用计数的处理逻辑，目的是解答一个问题，即
对设备文件的操作会不会引用到已经释放的文件上。
考虑这样一个场景，打开一个字符设备文件/dev/A，得到一个fd，用户态可以对这个
fd做相关的文件操作，包括ioctl, mmap, close等，内核如果保证close操作和其他
操作的同步，即不会出现close和其他文件并发执行，其他文件访问已经close掉的文件
这种情况。
内核是靠打开文件的引用计数来保证这一点的。
kernel/fs/open.c filp_open +-&gt; file_open_name +-&gt; do_filp_open +-&gt; path_openat +-&gt; alloc_empty_file 这里在创建struct file结构的时候会把里面的f_count引用计数设置为1。 kernel/fs/ioctl.c ksys_ioctl系统调用 +-&gt; fdget +-&gt; __fdget 在rcu锁里得到file结构的指针 +-&gt; __fget_light +-&gt; __fget +-&gt; get_file_rcu_many (atomic_long_add_unless(&amp;(x)-&gt;f_count, xx, 0)) 这里只有在f_count非0的时候才会把引用计数加1。如果是0，表明已经file 的引用计数已经是0。__fget会去files里查fd对应的file。 +-&gt; fdput +-&gt; fput +-&gt; fput_many +-&gt; atomic_long_dec_and_test(&amp;file-&gt;f_count) 如果减到0，在另一个内核线程中，延迟执行delay_work： +-&gt; delayed_fput_work +-&gt; delayed_fput +-&gt; __fput +-&gt; file_free(file) kernel/fs/open.c close系统调用 +-&gt; __close_fd +-&gt; spin_lock(&amp;files-&gt;file_lock) 在锁里拿到fd对应的file结构的指针 +-&gt; filp_close +-&gt; fput 如上 +-&gt; spin_unlock(&amp;files-&gt;file_lock) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d02ea07127514a29262da0b2369e07c/" rel="bookmark">
			HDFS组成部分及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HDFS组成部分及其作用 在开始阅读之前让我们喊出口号：“要想人前显贵，就要人后受罪！”加油嘎嘣儿，加油所有想获得美好未来的你！
一、组成部分
1. Client客户端
2. NameNode主节点
3. SecondaryNameNode 理解为：（NameNode 的备份，属于冷备份）
二、各部分的作用
Client
Client:发布命令，集群操作，监听（获取集群的运行状态），分块（逻辑分块：之规定的最大没有规定最小即使有两个不满64M（Hadoop2.0是128M）也不可以进行合并）。
NameNode
NameNode:管理集群，接收DateNode的心跳并通过心跳给DateNode发送指令，以及获取bolck的元数据的信息和确认DateNode是否宕机。
SecondaryNameNode:没半个小时以Httpget方式获取NameNode的fsimage+edits,然后将fsimage和edits进行本地合并生成fsimage_ckpt,然后将fsimage_ckpt发送到NameNode中，替换原先的fsimage,当然在Httpget形式远程拉取复制文件的同时在NameNode里会先生成一个edits_new文件，目的是为了防止在合并的半小时内的数据丢失。
DateNode
DateNode:用来存储数据block 文件，注意：同一个机器不应存储同一个block块副本，一个机架也不应该存储相同的副本。
三、相关知识点
机架感知：找文件时遵循就近原则。冷备份：会间隔一段时间进行备份。热备份：时时备份数据放在那里又NameNode决定一个数据块在DateNode是以文件的形式进行存储，包括两个文件：a.数据本身b.元数据 包括了数据块的长度，数据块的校验和，以及时间戳。DateNode 启动后向NameNode进行注册，当注册通过后会周期性的向NameNode上报所有的块信息安全模式：hdfs启动后会先启动NameNode，这个时候只有主节点没有从节点，但是元数据是存在的，我们可以看见文件列表，可以创建、删除、移动或者重命名文件，但是就是不可以修改文件的内容。HDFS权限的目的：是阻止好人做坏事，而不是阻止坏人做坏事。NameNode和DateNode 之间用的心跳都是RPC协议是TCP的上层，这样的协议会保证数据不丢失。而然Http协议特点就是使用快速方便，不等人。HDFS是不允许大量小的文件进行存储，因为这样不仅占内存（日志量会变得巨大），又消耗block的内存空间，导致降低系统性能。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586a7a158e5591fd95fb970421a21886/" rel="bookmark">
			Android Retrofit详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装
使用步骤 1.添加Retrofit库的依赖
implementation 'com.squareup.retrofit2:retrofit:2.0.2' implementation 'com.squareup.retrofit2:converter-gson:2.0.2' implementation 'com.google.code.gson:gson:2.8.5' implementation 'com.squareup.retrofit2:adapter-rxjava:2.0.2' 后面三个是可选的，分别是数据解析器和gson，以及rxjava支持的依赖
2.创建 用于描述网络请求 的接口
Retrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数
public interface GetRequest_Interface { @GET("openapi.do?keyfrom=abc&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Reception&gt; getCall(@Field("name") String name); // @GET注解的作用:采用Get方法发送网络请求 // getCall() = 接收网络请求数据的方法 // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt; } 3.创建Retrofit实例
Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fanyi.youdao.com/") //设置网络请求的Url地址 .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); 4.发送请求
请求分为同步请求和异步请求
// 创建 网络请求接口 的实例 GetRequest_Interface request = retrofit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586a7a158e5591fd95fb970421a21886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf99dd6cca764b83a17b64309ea681b/" rel="bookmark">
			ofdm &#43; cp  python仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import matplotlib.pyplot as plt from scipy.interpolate import interp1d k = 64 #numbel of ofdm subcarriers cp = k/4 #numbel of pilot carriers per ofdm blcok pilotvalue = 3+3j print (k) print('python') p=8 #numbel of pilot carrier per ofdm block allcarriers = np.arange(k) pilotcarriers = allcarriers[::k//p] pilotcarriers = np.hstack([pilotcarriers,np.array([allcarriers[-1]])]) #data carrier are all ramaining carriers datacarrier = np.delete(allcarriers,pilotcarriers) p = p+1 print ( "pilotcarrier :%s" %pilotcarriers) print ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf99dd6cca764b83a17b64309ea681b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/408/">«</a>
	<span class="pagination__item pagination__item--current">409/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/410/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>