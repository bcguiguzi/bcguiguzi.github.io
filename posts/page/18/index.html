<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d4a507809ce6c20bebe686f58ff027/" rel="bookmark">
			最新《国际版抖音Tik Tok》下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TikTok和抖音作为众所周知的一对兄弟，所开创的市场前景不可估量。它们不仅颠覆了很多传统认知，也直接让更多人接受了这些新奇事物。然而，TikTok的版本受限于国外，需要特定网络环境，一旦识别为国内，将无法使用。那么，在国内是否有直接观看TikTok的方法呢？实际上是有的。
软件下载地址：TikTok亲测免登录国内可用
点赞收藏评论区留言“已关注 求 ”！获取加速器免费不限制时间的方法！私信tiktok 免费分享，大家注意看后台消息就行！
与国内版的抖音相似，TikTok也提供了短视频分享、社交网络、短视频竞赛和直播打赏等功能。拥有超过15亿月活跃用户，内容涵盖了世界各地的文化和风俗习惯。
但由于某些原因，它在国内的使用受到限制，打开时会显示无网络黑屏，甚至直接闪退。
这是因为软件一旦检测到你插入了国内运营商的SIM卡，即便顺利突破限制，也几乎无法访问。
现在主流方法是拔卡，但拔卡比较麻烦，很多人只是想单纯刷视频不想动脑。
今天分享tiktok免登录国内直接看教程。
网页版步骤如下：
1、下载安装谷歌浏览器，无需拔卡。
2、打开加速器（免费不限制时间）
3、打开谷歌浏览器，输入TikTok在线网址：tiktok.com 即可浏览。
4、可以选择手机号（国外手机号）、邮箱（国外邮箱）、第三方国外平台注册。推荐用谷歌邮箱注册。
5、如果你单纯想浏览海外风景，可以点击下方“以游客身份继续”选项。此选项只能浏览视频，无法点赞评论关注打赏，想要使用更多功能还需注册账号。
APP版步骤如下：
1、安装tiktok
2、安装TikTokPlugin
3、安装加速器（免费不限制时间）
去所有广告、去保存视频水印、解除国家/地区限制，无视区域封锁提供额外插件可设置全球国家区域,设置视频保存位置,等自定义设置解除视频下载限制，可存储任何视频无视权限；解除合拍/拼接限制给视频添加播放进度条显示；为下载视频文件的名称添加了作者标签修改GIF和视频默认保存位置重定向为Movies/TikTok目录文件夹存储；支持手机号码登陆；修正谷歌授权、Facebook授权、VK授权；移除了调试信息；禁用不必要活动控件、禁用所有类型分析、禁用统计分析、对齐优化、极限压缩；启用观看历史、优化电池消耗、禁用自动启动，隐藏的根权限，删除许多其他限制强制启用高画质视频、强制启用高品质音频、强制启用超清分辨率、并启用抗锯齿 备注：TikTok插件(TikTokPlugin)可以自定义设置，用于配合此修改版选择全球区域！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d593b88cea6753c2ade8636282b09f2/" rel="bookmark">
			百度paddleocr GPU版部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显卡：NVIDIA GeForce RTX 4070，Nvidia驱动程序版本：537.13
Nvidia驱动程序能支持的最高cuda版本：12.2.138
Python：python3.10.11。试过python3.12，安装paddleocr失败，找不到相关模块。
飞桨版本：2.6，操作系统：windows 10，安装方式：pip，计算平台：CUDA12.0（飞桨2.6最高支持CUDA12.0）
CUDA工具包：12.0。由于飞桨2.6最高支持CUDA12.0，而Nvidia驱动程序能支持的最高cuda版本12.2，所以这里选择CUDA工具包12.0。
飞桨要求的CUDA工具包和cuDNN对应关系：
因此cuDNN选择v8.9.1。
先安装CUDA和cuDNN。需要注意，在自定义安装CUDA的时候有个选项得去掉，如下：
一般我们是没有VS环境的，如果这个时候勾选上就很有可能导致安装失败，去掉之后我们下一步等待完成即可。
安装飞桨2.6
python -m pip install paddlepaddle-gpu==2.6.0.post120 -f https://www.paddlepaddle.org.cn/whl/windows/mkl/avx/stable.html 由于网络原因，可能安装失败，多试几次就可以成功。
安装完成后您可以使用 python 进入 python 解释器，输入import paddle ，再输入 paddle.utils.run_check()
如果出现PaddlePaddle is installed successfully!，说明已成功安装，并且飞桨跟CUDA的版本也匹配上了。
安装paddleocr
pip install "paddleocr&gt;=2.0.1" 如果因为网络原因安装失败，可以指定超时和更换镜像源
pip --default-timeout=500 install "paddleocr&gt;=2.0.1" -i https://pypi.tuna.tsinghua.edu.cn/simple 安装完成后，就可以运行命令行识别图片文字了
paddleocr --image_dir ./1.png --use_angle_cls true --use_gpu true 运行该命令的时候，可能报错：
Could not locate zlibwapi.dll. Please make sure it is in your library path 需要在网上下载zlibwapi.dll放到cuda的安装目录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e93b122bf9202019676cafc074f121/" rel="bookmark">
			Windows客户端漏洞挖掘(红队角度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 前言 周五的时候看了key佬的演讲受益良多呀，来水水，写下目前针对Windows客户端类程序的部分挖掘入口吧，然后分享一下随手挖的很简单很简单的案例。
传统客户端
监听类的:
这里说的监听类的，指的就是安装客户端后启动的端口服务，这个思路WEB、设备类的0Click几乎都是这样，Windows客户端这块看具体业务了也可能有，比如历史上某远控软件RCE、某VPN RCE。走的HTTP逆起来还是比较简单的，前阵子搞金融的私有协议的可难玩一些，不过还好最后交差了。
非监听类的
第一种:
虽然这种没有对外监听，但是有命令行或者图形化操作的功能，这种可以针对其程序功能挖掘，思路要打开，用来1Click或者提权等，举个简单的应用，比如某些程序安装之后是以System运行的，此时如果存在RCE或加载DLL的相关操作都是可以用来本地提权的，还有就是有些白签名程序，存在直接RCE或加载DLL都有绕过如某卫士、某擎信任链检测的效果。
第二种:
伪协议很多客户端其实都有伪协议，可以分析其功能来决定如何利用。案例的话比如钉钉的这个漏洞POC，通过伪协议可以加载JS配合Chromium V8漏洞来达到1 Click RCE的效果。
WEB类客户端：
比较主流的应该是这三个CEF、QtWebEngine、Electron都是基于Chromium引擎可以尝试Chromium漏洞，其中Electron还基于NodeJs，因为NodeJs的特性导致可以轻松RCE，其他两个应该是不行。
所以对于这种第一个是XSS配合NodeJs语法，比如蚁剑与Clash出现过的1 Click RCE都是功能点XSS搭配NodeJs来RCE。
有些情况下NodeIntegration为False不能直接使用NodeJs原生语法RCE，这个时候如果
ContextIsolation为False(默认就是False)，就可以寻找Preload.js中的自定义API来寻找漏洞点。
参考如下解释。
第二个还是伪链接，跟传统客户端不同的是，如果找一个可以加载JS的伪链接，就可以配合上面提到的NodeJs特性或者Preload.js。
这次还看到key佬分享了一个使用WKE自定义前端渲染的漏洞案例，首先找到了一个可以加载任意JS的伪链接，然后寻找WkeJSbindFunction来看JS语法与本地函数的绑定情况，围绕这块去找Sink点。
下面来看一下前天随手挖的两个案例吧。
0x02 漏洞分析与利用 第一个：
发现安装某软件被控端之后开启两个服务。
OSPLinkProxy服务对应LinkProxy.exe。
访问对应对应服务端口33580。
发现一个路由。
接收名为"param"的参数。
对接收的参数内容进行了一次默认码表的Base64解密。
调用CreateProcessAsUserA传递"OpenLinkProxy.exe ShellExecute"拼接param解密后的内容。
逆向OpenLinkProxy发现最终调用ShellExecute且可传递执行的文件与参数。
测试可以执行。这种也可以单独利用，上面提到过。
IPC调用成功。
第二个：
不过多解释了，很简单LoadLibrary可控，GetProcAddress无参调用。
签名程序且高权限。
`黑客&amp;网络安全如何学习
今天只要你给我的文章点赞，我私藏的网安学习资料一样免费共享给你们，来看看有哪些东西。
1.学习路线图 攻击和防守要学的东西也不少，具体要学的东西我都写在了上面的路线图，如果你能学完它们，你去就业和接私活完全没有问题。
2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，上面路线图的每一个知识点，我都有配套的视频讲解。
内容涵盖了网络安全法学习、网络安全运营等保测评、渗透测试基础、漏洞详解、计算机基础知识等，都是网络安全入门必知必会的学习内容。
（都打包成一块的了，不能一一展开，总共300多集）
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加大型网安行动、CTF和挖SRC漏洞的经验和技术要点，电子书也有200多本，由于内容的敏感性，我就不一一展示了。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
4.工具包、面试题和源码 “工欲善其事必先利其器”我为大家总结出了最受欢迎的几十款款黑客工具。涉及范围主要集中在 信息收集、Android黑客工具、自动化工具、网络钓鱼等，感兴趣的同学不容错过。
还有我视频里讲的案例源码和对应的工具包，需要的话也可以拿走。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
最后就是我这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
这些题目都是大家在面试深信服、奇安信、腾讯或者其它大厂面试时经常遇到的，如果大家有好的题目或者好的见解欢迎分享。
参考解析：深信服官网、奇安信官网、Freebuf、csdn等
内容特点：条理清晰，含图像化表示更加易懂。
内容概要：包括 内网、操作系统、协议、渗透测试、安服、漏洞、注入、XSS、CSRF、SSRF、文件上传、文件下载、文件包含、XXE、逻辑漏洞、工具、SQLmap、NMAP、BP、MSF…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e93b122bf9202019676cafc074f121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74e13e8c902aff083b299fb9529a03c/" rel="bookmark">
			提交数据加快百度搜索引擎收录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百度站长工具做了更新，百度收录的地址分享如下，新站点提交后，可以加快百度收录。
普通收录_加快网站内容抓取，快速提交数据工具_站长工具_网站支持_百度搜索资源平台普通收录工具可实时向百度推送数据，创建并提交sitemap及提交未收录网页链接有助于百度发现并了解您网站上的网页和网站结构，加快抓取。https://ziyuan.baidu.com/linksubmit如果还没有添加站点，可以点击菜单“用户中心”-“站点管理”添加站点。
添加站点后，返回收录页面，导航路径：“搜索服务-普通收录”。
点击后如下图所示，普通收录支持三种提交方式：API提交、sitemap、手动提交。
如果要做成工具，就使用API提交方式，或者生成站点地图提交，或者手动添加链接即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91cf3ab8786cc03f9dd46fc68c77c37/" rel="bookmark">
			作为IT从业者和创业者，一起来看看，你不懂的“电子垃圾”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 业务软件不服务于业务，没办法变现。就是电子垃圾
你写个贪吃蛇一个月给你赚2万，那就是成功的。 你写个淘宝，一分钱赚不了。也是电子垃圾 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f1be03645909e17382a680d71982b3/" rel="bookmark">
			近端梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家：点击跳转
目录
1，求解目标
2，近端映射
3，近端梯度下降
4，实例
（1）常规梯度下降
（2）投影梯度下降
5，近端映射函数性质
（1）分量组合
（2）线性变换
（3）t变换
（4）四则运算
（5）共轭函数的近端映射函数
（6）省略写法说明
6，近端映射函数计算实例
1，求解目标 g 是凸函数，可微。
ℎ 是凸函数，未必可微。
我的理解：不是所有f都适用这个方法，h实际上只能取一些常见的简单的函数。
2，近端映射 3，近端梯度下降 4，实例 （1）常规梯度下降 结果就是常规梯度下降。
（2）投影梯度下降 5，近端映射函数性质 （1）分量组合 性质一：
（2）线性变换 性质二：
性质三：
PS：这里的a是标量
（3）t变换 根据性质三，取b=0可得性质四：
（4）四则运算 性质五：
例如，g(x)=x^2，f(x)=g(x)+x，a=1，t=2
那么，prox g (x) = x/5, prox f (x) = (x-2)/5
性质六：
PS：这里的a是向量
（5）共轭函数的近端映射函数 推导：
（6）省略写法说明 省略方式一
由于t变换的优美：
很多时候就简写成
如：
其实是
省略方式二
而有时我们又用表示
这是2种截然不同的省略约定，在这个基础上去理解公式就没啥问题了。
6，近端映射函数计算实例 上面2个例子给出了2个很特殊的函数的近端映射函数，这里展开讲讲更多的例子。
（1）L1范数
`sign`函数是一个数学和计算机科学中常用的函数，用于确定数字的符号。具体来说，如果数字大于0，则`sign`函数返回1；如果数字等于0，则返回0；如果数字小于0，则返回-1。
（2）L2范数
（3） 二次函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4f1be03645909e17382a680d71982b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c65005b6addb602ee7030e8a0bebcf/" rel="bookmark">
			C语言之快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 简介
二 代码实现
快速排序基本原理：
C语言实现快速排序的核心函数：
三 时空复杂度
A.时间复杂度
B.空间复杂度
C.总结：
一 简介 快速排序是一种高效的、基于分治策略的比较排序算法，由英国计算机科学家C.A.R. Hoare在1960年提出。
二 代码实现 以下是使用C语言实现快速排序的基本步骤和代码示例：
快速排序基本原理： 选择一个基准元素（pivot），通常选择数组的第一个元素或者最后一个元素。将所有比基准小的元素移动到基准元素之前，所有比基准大的元素移动到基准之后。这个操作被称为分区操作（partition）。对基准左右两边的子数组分别递归地进行上述操作。 C语言实现快速排序的核心函数： #include &lt;stdio.h&gt; // 分区操作，返回基准元素最后的位置 int partition(int arr[], int low, int high) { int pivot = arr[high]; // 基准元素（这里选取了数组的最后一个元素） int i = (low - 1); // 指针i初始化为low - 1 for (int j = low; j &lt;= high - 1; j++) { // 如果当前元素小于或等于基准元素，则与指针i所指向位置的元素交换，并将i后移一位 if (arr[j] &lt;= pivot) { i++; // 交换arr[i]和arr[j] int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } // 把基准元素放到正确的位置（即所有小于它的元素都在它前面） int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return (i + 1); } // 快速排序主函数 void quickSort(int arr[], int low, int high) { if (low &lt; high) { // pi是基准元素最后所在的位置 int pi = partition(arr, low, high); // 对基准元素左侧子数组进行递归排序 quickSort(arr, low, pi - 1); // 对基准元素右侧子数组进行递归排序 quickSort(arr, pi + 1, high); } } // 测试快速排序 int main() { int arr[] = {10, 7, 8, 9, 1, 5}; int n = sizeof(arr)/sizeof(arr[0]); quickSort(arr, 0, n-1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c65005b6addb602ee7030e8a0bebcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/308b680cbddd5ce5d608c552fdf87d21/" rel="bookmark">
			AttributeError: module ‘tensorflow‘ has no attribute ‘placeholder‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错代码 self.inputs_base_structure_left = tf.placeholder(dtype=tf.float32, shape=[None, 2048, 2], name="inputs_left") # initial a inputs to siamese_network 2. 报错原因 AttributeError: module 'tensorflow' has no attribute 'placeholder' 这个错误发生的原因是因为在较新版本的 TensorFlow 中，tf.placeholder 已经被弃用，取而代之的是使用 tf.compat.v1.placeholder 或者直接使用 TensorFlow 2.x 中的新特性，比如 tf.function 和 tf.Tensor 来定义输入。
TensorFlow 2.x 相较于 1.x 版本有着显著的变化，其中最重要的是引入了即时执行（Eager Execution）和函数式编程模型，这使得 TensorFlow 的使用变得更加直观和Pythonic。在 TensorFlow 2.x 中，许多 TensorFlow 1.x 的概念（比如图计算、会话等）都被简化或重新设计了。
3. 解决办法 使用 TensorFlow 1.x 兼容模式：
在 TensorFlow 2.x 中，你可以通过启用 TensorFlow 1.x 兼容模式来使用 tf.placeholder。在代码的开始处添加以下行：
import tensorflow as tf tf.compat.v1.disable_eager_execution() 然后，你可以使用 tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/308b680cbddd5ce5d608c552fdf87d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c44429acbd23b242c5608843274ba13/" rel="bookmark">
			【JavaEE -- 多线程3 - 多线程案例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程案例 1.单例模式1.1 饿汉模式的实现方法1.2 懒汉模式的实现方法 2. 阻塞队列2.1 引入生产消费者模型的意义：2.2 阻塞队列put方法和take方法2.3 实现阻塞队列--重点 3.定时器3.1 定时器的使用3.2 实现定时器 4 线程池4.1 线程池的使用4.2 实现一个简单的线程池 -- 重点 1.单例模式 单例模式：是一种设计模式，某个类，在一个进程中只创建出一个实例（对象），对代码进行一个更严格的校验和检查。
实现单例模式最基础的实现方式：
饿汉模式：懒汉模式 1.1 饿汉模式的实现方法 单例模式中一种简单的写法，饿汉：形容创建实例非常迫切，实例是在类加载的时候就创建了，创建时机非常早，相当于程序一启动，实例就创建了。
class Singleton { // 在这个Singleton 被加载的时候，就会初始化这个静态成员 private static Singleton instance = new Singleton();// instance 指向的这个对象，就是唯一的一个对象 public static Singleton getInstance() { // 对于饿汉模式，getInstance直接返回Instance实例，这个操作本质上是读操作，在多线程情况下读取同一个变量是线程安全的 return instance; } private Singleton() { } } public class ThreadDemo26 { public static void main(String[] args) { // Singleton singleton = new Singleton(); // Singleton s = Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c44429acbd23b242c5608843274ba13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b388f1dd25160bdf49e1bba619c0afbb/" rel="bookmark">
			VDI、VPN 与 RDP：选择安全的远程访问解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
虚拟专用网络 (VPN)
VPN 的工作原理
VPN 的优点
缺点
谁应该使用 VPN?
虚拟桌面基础架构 (VDI)
VDI 的工作原理
VDI 的优点
缺点
谁应该使用 VDI?
远程桌面协议（RDP)
RDP 安全问题
RDP 的工作原理
RDP 优点
缺点
谁应该使用 RDP?
谁不应该使用这些解决方案?
VPN
VDI
远程开发计划
选择适合您的安全远程访问
底线：根据您的需求定制安全远程访问解决方案
我们将在下面详细介绍，但这里是每种方法及其最佳用例的高级概述:
VPN: 最适合重视直接控制本地硬件并需要连接到本地资源的组织，或重视隐私和安全的个人用户VDI: 最适合标准化、可扩展的远程访问远程开发计划: 不再被视为可靠或安全的连接方法 VPN、VDI 与 RDP。 图片：电子安全星球
虚拟专用网络 (VPN) 无论您使用个人 VPN 还是组织内服务器上托管的 VPN，虚拟专用网络 (VPN) 都会为您的应用程序和 Internet 连接提供额外程度的保护。 VPN 可保护您的互联网连接和数据免遭窥探、黑客和其他危险行为的侵害。 它通过在用户和服务器之间建立安全隧道来实现这一点 企业网络 并对传输中的数据进行加密。 这种加密有助于确保敏感信息在互联网上传输时保持私密性和安全性.
对于高度重视加密功能的组织来说，VPN 是一个不错的选择 - 只要他们使用额外的安全措施，例如适当的访问控制和监控.
另请阅读:
最佳企业 VPN 解决方案什么是安全远程访问?16 要实施的远程访问安全最佳实践 VPN 的工作原理 VPN 通过 VPN 提供商管理的远程服务器或您自己组织内的服务器重定向您的互联网流量。 当您使用 VPN 连接到互联网时，您的数据将通过加密隧道发送，从而使第三方难以拦截或解码您的在线活动甚至您的位置.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b388f1dd25160bdf49e1bba619c0afbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ff6d6ac1cc6fef937881b03161ffd4/" rel="bookmark">
			PicoDet：专为移动CPU优化的快速目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
PicoDet是在2021年11月发布的一种机器学习模型。它将最近在目标检测模型方面的研究成果集成到一个轻量级模型中，以在移动CPU上实现高准确度和高速目标检测。
COCO dataset
架构
PicoDet通过使用轻量级结构作为骨干，提高了特征提取的速度。通过改进损失函数，它还提高了训练的稳定性和效率。
最近几年来，基于无锚点的检测器在目标检测中变得越来越受欢迎，而全卷积单阶段目标检测（FCOS）解决了重叠的地面实况标签问题。而典型的锚框为每个坐标都有多个锚点，FCOS为每个坐标只有一个中心点；使用FCOS的无锚点方法具有无需超参数调整的优势。
然而，通常无锚点的检测器用于服务器端处理的模型，这些模型相对较大。用于移动应用的无锚点模型仅限于NanoDet和YOLOX-Nano。对于轻量级无锚点检测器来说，很难平衡准确性和效率。PicoDet是一种受FCOS和广义焦点损失（GFL）启发的新尝试。
PicoDet
CSP是ResNet等模型中使用的“跳跃连接”机制的进化。它通过添加一个机制来切断和连接先前阶段的特征图，而无需进行卷积运算，从而便于反向传播并减少操作量。在PicoDet中，将3x3深度卷积扩展为5x5深度卷积，以扩大感受野。
CSPNet
为了改善标签分配策略，采用了SimOTA，并采用了Varifocal Loss（VFL）和GIoU损失作为损失函数。
SimOTA也用于YOLOX。在确定预测边界框与地面实况边界框之间的映射以计算损失时，该方法不是分配最近的地面实况，而是解决了一个优化问题，以分配更合适的地面实况。SimOTA是OTA（Optimal Transport Assignment）的更快版本。
SimOTA
在这个目标检测模型中，通过将地面实况边界框分配给HEAD预测的每个边界框，并反向传播损失来进行学习。地面实况边界框可能会重叠。如果预测边界框落在该区域内，我们将出现一种称为“模糊锚点”的情况，我们不知道要分配哪个地面实况。OTA具有一种算法，使将地面实况边界框分配给模糊锚点变得困难。
模糊锚点
以下是OTA分配的结果示例。图像中的点是预测边界框的中心点，红色椭圆显示了分配策略的差异。
OTA分配的结果
PicoDet中用于特征提取的骨干是Enhanced ShuffleNet，这是ShuffleNetV2的改进版本，是一种适用于移动设备的高效模型架构。ShuffleNet引入了“逐点组卷积”和“通道混洗”操作，以加速1x1卷积，这是MobileNet的瓶颈。
Enhanced ShuffleNet
一次性神经架构搜索（NAS）被引入以搜索每层的最佳通道数量。搜索结果显示，使通道数量成为8的倍数对提高推断速度的贡献最大。
性能
以下是使用高通骁龙865 CPU的性能。在使用NCNN在CPU上运行时，YOLOX-Tiny在mAP 32.8时需要32.77毫秒，而PicoDet在mAP 30.6时需要12.37毫秒。在17.39毫秒内可以实现mAP 34.3。
这种性能提升是在CPU上运行推断时可以测量到的，而在GPU上运行时它们表现相同。因此，YOLOX-Tiny可能更适用于Jetson设备，而PicoDet可能最适合树莓派等设备。
用法
可以使用以下命令将PicoDet与ailia SDK一起用于检测网络摄像头视频流中的对象。
$ python3 picodet.py -v 0 ax Inc. 开发了ailia SDK，该SDK支持跨平台、基于GPU的快速推断。ax Inc. 提供从咨询和模型创建到基于AI的应用程序和SDK开发的广泛服务。如有任何疑问，请随时与我们联系。
· END ·
HAPPY LIFE
本文仅供学习交流使用，如有侵权请联系作者删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b939231559e1d48bd7c12eac9030f2b3/" rel="bookmark">
			python--字符串切片和常用的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python--字符串切片和常用的写法 正序切片格式注意点 倒序切片格式 字符串运算字符串转义字符串常用方法大小写相关的统计相关的拆分&amp;替换字符串连接（面试）字符串格式化 正序切片 格式 str1[起始索引:结束索引]左闭右开（取左边下标的值，不取右边下表的值）
str1[起始索引:结束索引:步长]
注意点 1、默认起始位置从0开始，步长是1
2、左闭右开(取起始索引的值，不取结束索引的值)
3、如果结束索引不写，默认等于字符串的长度
4、空格也占用索引（一个空格占一位）
5、起始索引绝必须要小于结束索引
6、倒序下次课将，先把正序搞定
倒序切片 格式 str1[起始索引:结束索引:步长]
字符串运算 字符串转义 1、\n：表示换行符，通常用于在字符串中表示文本的不同行。
2、\：是转义字符，它用于将特殊字符转义为普通字符，或者将一个长的代码行分成多行书写
3、r：表示原始字符串的前缀，通常用于在字符串中包含反斜杠等特殊字符时，避免被当做转义字符处理。例如，r"\n" 表示字符串"\n"，而不是换行符。
字符串常用方法 大小写相关的 str_01.upper()：全部大写 str_02.lower():全部小写 #了解 str_03.capitalize():首字母大写 str_04.title():每个单词首字母大写 str_05.swapcase():大小写互换 统计相关的 count()：统计字符在字符串中出现的次数 sub：需要统计的字符
start:统计范围的开始索引值
end:统计范围的结束索引值
返回：sub在字符串中出现的次数
str_1 = 'hello python' times = str_1.count('h') print(times) # 代码格式化快捷键：ctrl + alt + l # 看源码：ctrl + 点击一下 def count(self, sub, start=None, end=None): """ S.count(sub[, start[, end]]) -&gt; int Return the number of non-overlapping occurrences of substring sub in string S[start:end].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b939231559e1d48bd7c12eac9030f2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1931fc8bf7c7d796f4345d685349c1ff/" rel="bookmark">
			为什么要做文献综述？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献在撰写小论文时具有重要作用，主要体现在以下几个方面：
证明观点的可靠性：通过引用前人的研究成果或相关文献，可以为自己的观点或论据提供支持，增强论文的可信度。
展示研究的深度：参考文献可以显示你对研究领域的深入了解，以及你在构建论文论点时所进行的广泛阅读和研究。
避免抄袭：正确引用他人的工作是学术诚信的基本要求，可以避免剽窃的嫌疑，尊重原作者的知识产权。
为读者提供资源：参考文献为感兴趣的读者提供了进一步探索研究主题的资源，有助于读者深入了解相关领域。
文献综述在学术研究中非常重要，原因如下：
确定研究的背景和基础：文献综述有助于了解研究领域的历史背景、现状和未来趋势，为研究提供理论基础。
发现研究空缺：通过综述相关文献，可以识别出当前研究中存在的问题和空白，为自己的研究确定方向和目标。
防止重复研究：了解前人的工作可以避免在已有的基础上重复劳动，使研究更具创新性和价值。
建立研究方法：文献综述可以帮助理解不同的研究方法和技术在该领域的应用情况，为选择合适的研究方法提供参考。
促进学术交流：文献综述是学术交流的重要组成部分，它有助于学者们了解彼此的工作，促进学术界的合作和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd716b3a672a5147098b433c50b31734/" rel="bookmark">
			写小论文的时候参考文献的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写小论文时，参考文献具有几个重要作用：
提供背景和理论基础：参考文献可以帮助阐述研究话题的背景信息，展示前人的研究成果，为你的论文提供理论支撑和研究框架。
支持论点和观点：通过引用相关的文献，你可以为自己的论点提供证据和支持，增强论文的说服力。
展示研究的广度和深度：一个全面且合理的参考文献列表可以展示你对研究领域的深入了解和广泛阅读，这对于展示你的学术严谨性和专业性非常重要。
避免抄袭：正确地引用和列出参考文献可以避免抄袭的嫌疑，这是维护学术诚信的关键一环。
便于读者进一步探索：参考文献为读者提供了进一步阅读和了解研究话题的渠道，有助于他们深入理解论文的内容和背景。
因此，参考文献是小论文的重要组成部分，不仅能增强论文的学术性和可信度，还能体现作者的学术诚信和研究能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c671e613d214c9dcd1d21ba0ea90d48/" rel="bookmark">
			【C#基础】轻松理解AutoResetEvent 和 ManualResetEvent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		彻底理解AutoResetEvent AutoResetEvent 是一个线程同步原语，用于在多线程环境中协调线程的执行顺序。它是.NET Framework提供的一种同步机制，用于线程间的通信和协作。
AutoResetEvent 维护了一个状态标志，可以处于有信号或无信号两种状态之一。线程可以通过等待信号或设置信号来控制自己的执行。
AutoResetEvent 具有两个主要方法：WaitOne 和 Set。以下是这些方法的功能和用法：
1. WaitOne:
- 当线程调用 WaitOne 方法时，它会进入等待状态，直到接收到信号。
- 如果 AutoResetEvent 处于无信号状态，WaitOne 方法将阻塞线程的执行。
- 如果 AutoResetEvent 处于有信号状态，WaitOne 方法将消耗该信号，并使 AutoResetEvent 重新进入无信号状态。
- 可以通过 WaitOne 的重载方法指定超时时间，在超过指定时间后，线程将继续执行而不等待信号。
2. Set:
- 当线程调用 Set 方法时，它会将 AutoResetEvent 的状态设置为有信号。
- 如果有线程正在等待信号，它将被唤醒并开始执行。
- 如果没有线程在等待信号，调用 Set 方法也会将 AutoResetEvent 的状态设置为有信号，但不会有任何其他影响。
- 即使多次调用 Set 方法，AutoResetEvent 也只会保持有信号状态一次，直到被消耗。
AutoResetEvent 的工作方式可以类比于一个门闩或红绿灯。线程可以通过等待门闩打开（WaitOne）来阻塞自己的执行，而其他线程则可以通过设置门闩打开（Set）来唤醒等待的线程。
AutoResetEvent 在多线程编程中非常有用，特别是在需要控制线程的执行顺序或实现线程间的协作时。它提供了一种简单而有效的方式来同步线程的操作，并确保线程按照期望的顺序执行。
举个例子 假设有两个线程，一个线程负责生产物品，另一个线程负责消费物品。这两个线程需要进行同步，以确保在生产者生成物品后，消费者才能消费物品。
使用 AutoResetEvent 可以很方便地实现这种同步。下面是一个简单的示例代码：
using System; using System.Threading; class Program { static AutoResetEvent producerEvent = new AutoResetEvent(false); static AutoResetEvent consumerEvent = new AutoResetEvent(true); static int item = 0; static void Main() { Thread producerThread = new Thread(ProduceItems); Thread consumerThread = new Thread(ConsumeItems); producerThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c671e613d214c9dcd1d21ba0ea90d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca42ebf6317f6e266a73b02bc427322/" rel="bookmark">
			windows 免密码ssh登录linux；linux免密码ssh登录其他linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、windows 免密码ssh登录linux 参考：https://blog.csdn.net/qq285744011/article/details/118293937
1）windows先生成公钥私钥
ssh-keygen -t rsa -C "你的邮箱地址" 生成后放在用户命令.ssh文件下
2）把公钥复制到linux /root/.ssh/authorized_keys
3)然后就可以在windows下免密码登录了
ssh -p 31 root@192.168** 2、linux免密码ssh登录其他linux 参考：https://www.cnblogs.com/JackieDYH/p/17635056.html
1）如果linux /root/.ssh/不存在就去生成
sh-keygen -t rsa -b 4096 -C "your_email@domain.com" 2）ssh-copy-id 命令直接默认把 /root/.ssh/公钥拷贝到远程linux的/root/.ssh/authorized_keys中；不需要指定文件路径很方便
ssh-copy-id remote_username@server_ip_address 3）设置成功就可以免密码登录了
ssh -p 31 root@192.168** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a03a29253ca2ac79833d1b396ca49b2/" rel="bookmark">
			学术抄袭和剽窃指的是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学术抄袭和剽窃是学术不端行为的两种形式，它们通常指的是在学术作品中未经授权或未适当引用而使用他人的思想、语言、表达或作品：
学术抄袭：学术抄袭指的是在学术作品中使用他人的思想、观点、数据或语言表达，而未予以适当的引用或注明出处。抄袭不仅包括完全照搬他人的作品，也包括在不适当的引用或改写的情况下，将他人的观点或语言表达作为自己的原创内容呈现。
剽窃：剽窃是一种更广泛的概念，通常指的是未经授权或未经允许就使用或模仿他人的创意、作品、语言等。在学术领域，剽窃不仅限于文字，还可能包括数据、图表、图片、音乐等其他形式的创作。
学术抄袭和剽窃都是严重的学术不端行为，会损害学术诚信，影响个人和机构的声誉，并可能导致学术处罚、论文撤稿或法律后果。因此，学术界强调在进行研究和撰写学术作品时必须遵守引用规范，确保对所有使用的资料进行适当的引用和注明出处，以维护学术诚信和尊重知识产权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1781bc85d3a8e87e18a112b47f89a194/" rel="bookmark">
			第 5 章 ROS常用组件-rqt(自学二刷笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要参考：
课程链接:https://www.bilibili.com/video/BV1Ci4y1L7ZZ
讲义链接:Introduction · Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程
5.3 rqt工具箱 之前，在 ROS 中使用了一些实用的工具，比如：ros_bag 用于录制与回放、tf2_tools 可以生成 TF 树 ..... 这些工具大大提高了开发的便利性，但是也存在一些问题：这些工具的启动和使用过程中涉及到一些命令操作，应用起来不够方便，在ROS中，提供了rqt工具箱，在调用工具时以图形化操作代替了命令操作，应用更便利，提高了操作效率，优化了用户体验。
概念 ROS基于 QT 框架，针对机器人开发提供了一系列可视化的工具，这些工具的集合就是rqt
作用 可以方便的实现 ROS 可视化调试，并且在同一窗口中打开多个部件，提高开发效率，优化用户体验。
组成 rqt 工具箱组成有三大部分
rqt——核心实现，开发人员无需关注
rqt_common_plugins——rqt 中常用的工具套件
rqt_robot_plugins——运行中和机器人交互的插件(比如：rviz)
另请参考:
rqt - ROS Wiki 5.3.1 rqt安装启动与基本使用 1.安装 一般只要你安装的是desktop-full版本就会自带工具箱
如果需要安装可以以如下方式安装
$ sudo apt-get install ros-noetic-rqt $ sudo apt-get install ros-noetic-rqt-common-plugins 2.启动 rqt的启动方式有两种：
方式1：rqt 方式2：rqt rosrun rqt_gui rqt_gui
3.基本使用 启动 rqt 之后，可以通过 plugins 添加所需的插件
5.3.2 rqt常用插件:rqt_graph 简介:可视化显示计算图
启动:可以在 rqt 的 plugins 中添加，或者使用rqt_graph启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1781bc85d3a8e87e18a112b47f89a194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c6739c329648bf1f4dace815ac7450/" rel="bookmark">
			L1-071 前世档案(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner; public class Artive { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String msg = scanner.nextLine(); int zhishu = Integer.parseInt(msg.split(" ")[0]); int line_num = Integer.parseInt(msg.split(" ")[1]); for(int i = 0; i &lt; line_num; i++) { String answer = scanner.nextLine(); int sum = 0; for (int j = 0; j &lt; answer.length(); j++) { char c = answer.charAt(j); if(c == 'y'){ int num = (int)Math.pow(2,zhishu-j-1); sum+=num; } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c6739c329648bf1f4dace815ac7450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf23721a00e8ea4768f0c3cbd8fcfcec/" rel="bookmark">
			说下你对TCP以及TCP三次握手四次挥手的理解？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自简单理解TCP三次握手四次挥手
什么是TCP协议？ TCP( Transmission control protocol )即传输控制协议，是一种面向连接、可靠的数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。
面向连接：数据传输之前客户端和服务器端必须建立连接可靠的：数据传输是有序的，要对数据进行校验 TCP三次握手 为了保证客户端和服务器端的可靠连接，TCP建立连接时必须要进行三次会话，也叫TCP三次握手，进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。
三次握手
最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。
TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN 监听状态
第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态
第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态
第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手。
TCP四次挥手 建立TCP连接需要三次握手，终止TCP连接需要四次挥手
四次挥手
数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。
第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态
第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态
第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器最后的数据发送完毕后，就向客户端发送连接释放报文，将FIN=1，其序列号为seq=w，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成
为什么客户端要等待2MSL？
主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/19/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>