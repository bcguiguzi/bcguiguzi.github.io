<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e2b2b9ff0dcd9d4c38981a3510aa3e/" rel="bookmark">
			Git命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git命令大全 一、git config二、git clone*三、git init*四、git status*五、git remote*六、git branch*七、git checkout*八、git add*九、git commit*十、git fetch十一、git merge*十二、git diff十三、git pull*十四、git push*十五、git log*十六、git reset*十七、git revert十八、git tag*十九、git mv二十、git rm二一、git cherry-pick二二、git stash 一、git config 配置 Git 的相关参数。
Git 一共有3个配置文件：
仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\Users&lt;用户名&gt;\.gitconfig。系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。 # 查看配置信息 # --local：仓库级，--global：全局级，--system：系统级 $ git config &lt;--local | --global | --system&gt; -l # 查看当前生效的配置信息 $ git config -l # 编辑配置文件 # --local：仓库级，--global：全局级，--system：系统级 $ git config &lt;--local | --global | --system&gt; -e # 添加配置项 # --local：仓库级，--global：全局级，--system：系统级 $ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt; # 获取配置项 $ git config &lt;--local | --global | --system&gt; --get &lt;name&gt; # 删除配置项 $ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt; # 配置提交记录中的用户信息 $ git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e2b2b9ff0dcd9d4c38981a3510aa3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4793c990dbe3210a7eb9cb0e5a6f2f61/" rel="bookmark">
			Go 生成指定位数的随机数/随机字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成指定位数的随机数： 代码如下： package main import ( "fmt" "math/rand" ） func CreateCaptcha() string { return fmt.Sprintf("%06v", rand.New(rand.NewSource(time.Now().UnixNano())).Int31n(1000000)) } func main(){ fmt.Println(CreateCaptcha()) } Now() Time 获取当前时间,返回Time类型
输出：2019-09-03 20:58:38.473422 +0800 CST m=+0.000168620
Unix() int64 返回时间戳,自从1970年1月1号到现在
输出：1567515533
UnixNano() int64 返回时间戳.包含纳秒
输出：1567515575893470000
Int31n(1000000) 产生0到1000000之间的随机数，返回值为int32,该类函数还有Int63()等等，用来生成相应数据类型的随机数
NewSource返回一个以给定值播种的新随机源。
New返回一个新的Rand，它使用src(传入的参数)中的随机值生成其他随机值。
位数可以通过格式化输出进行调整，如把代码中的"%06v"改为"%08v"
生成随机字符串： 代码如下：
package problem import ( "math/rand" "time" ) var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") var n = 12 func GenerateSubId() string { b := make([]rune, n) for i := range b { b[i] = letterRunes[rand.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4793c990dbe3210a7eb9cb0e5a6f2f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2551b22ebe964748b406d7c4c8979b9d/" rel="bookmark">
			刷题牛客网  华为机试在线训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为这部分的机试题我是从最后开始刷的：
1、求最小公倍数 最小公倍数 = 两数之积除以最大公约数
最大公约数的我采用了辗转相除法和更相减损法这两种，当然也可以穷举。
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a=sc.nextInt(); int b=sc.nextInt(); int d=getMaxCommonDivisor1(a,b); System.out.println((a*b)/d); } /** * 求最大公约数 辗转相除法 * @param m * @param n * @return */ private static int getMaxCommonDivisor(int m,int n) { if(n&lt;=0){ return m; } int b= m%n; m=n; n=b; return getMaxCommonDivisor(m,n); } /** * 求最大公约数 更相减损法 * @param m * @param n * @return */ private static int getMaxCommonDivisor1(int m,int n) { if(m==n){ return m; } if(m&gt;n){ m=m-n; } if(m&lt;n){ n=n-m; } return getMaxCommonDivisor1(m,n); } } 2、求解立方根 •计算一个数字的立方根，不使用库函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2551b22ebe964748b406d7c4c8979b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e905eb6977caa978b15a738b6df67f29/" rel="bookmark">
			VirtualBox 6.0.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox，全称为Oracle VM VirtualBox，一款功能强大的开源虚拟机工具，同VMware有点类似，支持多种操作系统，如：Windows系列、Linux、OpenBSD等。但相对于VMware，它包括了远端桌面协定（RDP）、iSCSI及USB的支持，Solaris、Windows、DOS、Linux、OS/2 Warp、BSD等系统都可以作为客户端操作系统在VirtualBox上安装并且执行。在VirtualBox创建虚拟机只需简单几步，即可快速进行创建。
VirtualBox
安装教程(win7安装)
1、双击打开或者管理员身份运行VirtualBox-win.exe,打开安装向导，点击Next，进入下一步；
2、选择要安装的功能组件：
分别是主程序（必选），VirtualBox USB驱动支持（安装后可以支持外接USB），虚拟机的网络支持（包括桥接的跟主机模式的网络）最后一个就是VirtualBox的Python 2.X的支持。这里可以不用动直接默认就行了。安装路径默认在C盘，点击Browse选择其他的路径，然后点击Next ，进入下一步；
3、选择快捷方式，分别是：
在开始菜单创建快捷方式
在桌面创建快捷方式
在快速启动栏创建
关联文件
这个可以根据自己的喜好来选择。然后点击Next；
4、弹出警告界面，提示安装网络组件会重置当前网络，点击yes；
5、单击Install进行安装；
6、弹出Windows安全提示框，勾选“始终信任来自Oracle Corporation的软件”，单击安装；
7、安装完成界面，勾选表示安装完成后启动Oracle VM VirtualBox虚拟机，单击Finish完成安装；
8、打开Oracle VM VirtualBox管理器即可。
共享文件夹的创建
1、打开VirtualBox管理器，点击“设置”；
2、点击“共享文件夹”选项右侧的加号，共享文件夹路径选择“其它”
3、选择PC机上一个文件夹作为共享路径；
4、共享路径选好后，会自动将文件夹名称作为共享文件夹名称，勾上“固定分配”，这样这个路径可以永久使用，点击“OK”；
5、现在进入虚拟机，打开Terminal，输入以下命令：
sudo mkdir /pcshare
sudo chmod 777 /pcshare
sudo mount -t vboxsf uBuntuSharePath /pcshare
注意uBuntuSharePath就是之前步骤所创建的PC机上的共享文件夹名称；
6、虚拟机与PC机之间的共享文件夹这就创建好啦。现在测试一下，在PC机共享文件夹中创建一个文件windows.txt。看，虚拟机中可以看到windows.txt文件啦。然后在虚拟机共享文件夹中创建一个文件夹ubuntu；
7、PC机上也可以看到ubuntu文件夹，之后每次启动虚拟机，都需要先在Terminal中输入命令“sudo mount -t vboxsf uBuntuSharePath /pcshare”。然后虚拟机/pcshare文件夹下创建的文件在PC机uBuntuSharePath文件夹下可以同步看到；PC机uBuntuSharePath文件夹下的修改虚拟机/pcshare文件夹下也可以看到。
virtualbox使用教程
1、运行软件，单击“新建”，弹出界面中填入电脑名称，设置内存大小；
2、新建虚拟硬盘：选择创建新的虚拟硬盘，选择硬盘格式，一般选第一种；选择硬盘大小改变方式，动态分配将会随着使用，大小逐渐变大，而固定大小，将会固定容量；选择虚拟硬盘大小，一盘20G足以；注意这里最好改变虚拟硬盘存储位置，否则会自动存放在系统盘；点击创建，一个新的虚拟机就新建好了，当然还没有装系统；
3、安装系统：选中你新建的虚拟机，点击设置，选择存储，选中没有盘片，在左边选中一个系统安装盘；
4、启动：选中新建的虚拟机，点击启动，开始安装系统和在真的电脑上安装系统一样。
网络设置
1：NAT 网络地址转换（Network Address Translation）
2：Birdged Network 桥接
3：Internal Network 内部网络（可以是虚拟机与虚拟机之间）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e905eb6977caa978b15a738b6df67f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e81432b6f6f382d388b3b363f35d99/" rel="bookmark">
			Symantec Endpoint Protection v14.2.4811.1100企业特别版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Symantec Endpoint Protection 14是由Symantec官方最新发布的一款杀毒软件，可用于虚拟和物理计算机系统。这个惊人的应用程序是为保护服务器、台式机、笔记本电脑和虚拟环境免受长串威胁而开发的。这个方便的应用程序基于一种称为symmatic insight的技术，它可以监视互联网上所有已知应用程序的优势和安全性等级。这个应用程序可以随机化扫描和更新。它维护共享扫描缓存和脱机图像。Symantec Endpoint Protection 14提供了用于生成自启动CD或USB存储棒的集成恢复工具，其中包含一套Symantec恶意软件删除实用程序。此应用程序可以优化计算机的效率，同时执行流程和策略，可支持所有最新的Windows版本。若你用腻了国产的360、电脑管家等这些杀毒软件又想要尝试一下新鲜东西的话，不妨下载这款Symantec Endpoint Protection 14试试吧！
Symantec Endpoint Protection 14企业特别版
注册破解说明
赛门铁克杀毒软件企业版的无需激活，安装即可使用。
软件功能
1、病毒和间谍软件防护
包括调度病毒扫描、按需扫描以及在后台运行的自动防护，从而可以对病毒进行监控。该软件会在发现病毒时立即将其清除。
2、网络威胁防护
会截取网络层中的数据。它使用特征扫描数据包或数据包流。通过查找与网络攻击或浏览器攻击相对应的模式，入侵防护可以单独扫描各个数据包。网络威胁防护包括入侵防护，该防护会检测操作系统组件和应用程序层的攻击。当 Symantec Endpoint Protection 检测到网络威胁时，即会阻止该威胁。
3、设备控制
管理员配置设备控制策略。使用此策略时，可以按设备名称、供应商、型号或序列号禁止或解除禁止设备。可以在受管客户端的“设置”选项卡上查看设备控制设置。设备控制不适用于非受管客户端。
Symantec Endpoint Protection 14企业特别版
软件亮点
1、由端点安全领域的市场领导者提供无可匹敌的防护
2、无缝集成防病毒软件、反间谍软件、防火墙、入侵防御、设备和应用程序控制
3、只需要一个代理
4、对 Windows 和 Macintosh 端点的安全性提供强大的集中式管理
5、支持即时 NAC 升级，无需额外部署软件
6、提供适用于 Macintosh 和 Linux 客户端的防病毒软件和反间谍软件
7、同时保障物理环境和虚拟环境的安全
安装教程
1、首先在本站下载好这款文件包，将其解压出来可得Windows32/64版本、Linux版本、Mac版本。
2、双击“Setup.exe”安装源程序运行，在安装向导界面直接点击“下一步”。
3、来到用户许可协议界面后，选择“我接受协议”这一项，然后点击“下一步”。
4、提示选择安装类型，根据自己喜好选择即可。
5、选择加入文件数据信誉设置，点击“下一步”。
6、确认好安装信息，点击“安装”。
7、安装进行中，需要一些时间，请耐心等待。
8、好了安装成功了，现在你就可以去体验一下这款国外流行的杀毒软件啦！
软件特色
1、无以伦比的防护功能，由安全领域的全球领导者提供
2、无缝地集成了防病毒、反间谍软件、防火墙和入侵防御技术以及网络准入、设备和应用程序控制技术
3、只需要一个代理
4、强大的集中式管理功能，可统一管理物理和虚拟 Windows 和 Mac 端点上的安全技术
5、无需额外部署软件即可实现即时 NAC 升级
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e81432b6f6f382d388b3b363f35d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96069366264d1e723c908f1c56502ef1/" rel="bookmark">
			layout editor(布局编辑器) V2019.04.02 64官方版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		layout editor是一款功能强大的编辑MEMS和IC制造的设计软件，该软件功能特别全面。layout editor拥有多芯片模块（MCM）、片上芯片（COB）、低温共烧陶瓷（LTCC）、单片微波集成电路（MMIC）、印刷电路板（PCB）、厚膜技术、薄膜技术等多种用途。它同字体生成器，C++宏，Python脚本，布尔运算，设计规则检查，电路驱动布局和LVS等类似，支持的多种文件格式，如：卡尔马GDSII，DXF，CIF（加州理工学院中间形式），格伯（rs-274x），来氟米特，DEF，Lasi等，能用于你的设计流程的任何部分。需要的朋友赶紧前来本站下载。
layout editor
软件功能
1、用户界面
一个聪明的用户界面一方面提供了出色的可用性，另一方面提高了生产力。这种虚拟挑战是通过广泛使用快捷键和鼠标按钮/键组合以及清晰显示这些组合来解决的。最重要的处理功能（如缩放和滚动）集成到每个功能中，无需单独调用。
2、支持的文件格式
LayoutEditor不需要自己的文件格式。Calma GDSII文件格式被用作主要文件格式。它也可以与许多其他常见格式和一些不常见的格式一起工作：
GDSII，OASIS，OpenAccess，CIF，DXF，Gerber，LEF，DEF，SVG，Lasi，SOURCE，CSV，PNG，JPG，Alliance，Electromask，PS，EPS，ODB ++，EDIF，Qucs，Spice，…3、性能由于设计可以扩展到几Gb的文件大小，因此性能是一个重要的因素。LayoutEditor的所有重要功能都经过优化以处理巨大的设计。例如，多Gb GDSII文件可以在几秒钟内加载。此外，绘画表现非常出色，可以轻松与其他任何工具竞争。中型设计（高达几百MB的GDS文件大小，确切大小可能取决于设计）可以实时绘制所有细节。随着更大的设计，会自动检测到缺乏性能，并且几乎不会显示可见的细节。所以即使是巨大的设计，也可以接受性能。
4、原理图驱动布局
使用布局软件时，从原理图创建设计是一项普遍的任务。所述LayoutEditor包括SchematicEditor并且还可以读共同示意/网表格式。原理图与布局链接。该集成允许在不限制免费定制设计的情况下创建简单的布局。可以从布局中为内置或外部布局与原理图（lvs）提取网表。或者它可以用来模拟电路。
5、宏
当然，LayoutEditor可以使用宏或脚本。它可以用于不同的应用程序。因此，使用LayoutEditor可以从用户界面录制宏像一些办公软件一样。这使得创建宏非常简单，并减少了大量学习编程的时间。宏以最常用的语言C / C ++编写。可以在菜单结构中添加宏，以完美整合自己创建的扩展。我们的宏观市场上可以下载大量随时可用的宏。通过LayoutEditor python模块，您可以将LayoutEditor作为屏幕外工具或其图形用户界面嵌入到您自己的Python应用程序中。
6、设计规则检查器
验证设计规则是设计流程中的重要一点。该LayoutEditor有一个集成的设计规则检查与许多不同的规则检查。违规行为不仅在列表中显示，而且在设计中直接可视化。当然，所有设计规则检查都适用于所有角度元素，并不限于通用的集成电路检查。
7、文本生成
在输出时通常会忽略文本标签。转换为真正的多边形之前必须完成。只需点击一下鼠标，LayoutEditor就可以做到这一点。不需要绘制字母。只需使用你最喜欢的矢量字体。该LayoutEditor支持所有常用的字体格式一样常见True Type字体（TTF文件）。
8、3D视图
二维设计有时可以退出抽象。该LayoutEditor允许你设计一个快速的三维可视化。设置可以在几秒钟内完成。3D模型/ 3D视图可以导出并用于例如FEM分析。
9、背景图片
设计背景中的图像可以用于许多任务。例如检查制造问题或在现有结构上设计设备。该LayoutEditor具有的特征来加载，地点和向量化的图像和在背景中显示它。任何像素图形格式都可以使用。无限制的图像可以同时加载。
10、条码
该LayoutEditor有很多很多有用的功能，如条码生成器。请参阅手册以获取所有功能的列表，或者试试并留下深刻印象！
软件特色
1、一方面巧妙的解决用户界面提供出色的可用性，另一方面提高生产率。这个虚拟的挑战是通过广泛使用快捷键和鼠标按钮或组合键一起解决这些组合显示清晰的问题。最重要的处理功能，如缩放和滚动集成到每个特征和不需要被分开。
2、这个布局编辑器不需要自己的文件格式。CALMA GDSII文件格式作为主要的文件格式。它也可以在许多其他常见的还有一些不常见的格式：
GDSII, OASIS, OpenAccess, CIF, DXF, Gerber, LEF, DEF, SVG, Lasi, SOURCE, CSV, PNG, JPG, Alliance, Electromask, PS, EPS,ODB++, EDIF, Qucs, Spice。更新日志LayoutEditor 2018.01.29
1、新功能：
新的基于网页的手册
按路径/多边形模式中的对话框输入点
通过双击或点击开始点结束多边形/路径模式
在主窗口中显示比例
属性对话框中的中心框
长度元素特征也不是元素大小特征的极点
元素大小也显示区域和周长
测量角度可以创建永久显示并测量多边形边缘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96069366264d1e723c908f1c56502ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad1ac642837234c0a15da61cdeea28e/" rel="bookmark">
			解惑：什么叫模型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型一词，原本是好理解的，名词，大概就是一个缩小版的实际产品的意思。
当然了，你可以去查查百科，模型其实不只可以描述实物，还可以描述虚拟物件。我们主要来看看后者。(百科： https://baike.baidu.com/item/模型/1741186?fr=aladdin)
当模型这在软件行业使用时，好像就变了味道。比如：开发模型，java内存模型，线程模型，io模型，reactor模型，生产模型，消费模型，消息传递模型...
这让我在很长一段时间里，一直搞不懂，何谓模型。随着年龄的增长，总算有了些许自己的理解，权当故事讲给自己听吧。
交互模型：由一种或者多种元素构成，包括用例、顺序图、状态图、用户界面原型等，它描述了用户与系统之间采用了哪种交互方式；虽然说内容很多，不太像是在说一个叫模型的东西，但是，确实和其描述“交互” 很相关，所以理解起来倒也轻松自在。而接下来咱们的几个例子，则可不一定了！
java内存模型？你说内存就内存吧，不是长方形就是正方形，还能咋的。错了，java内存模型内容可以包含内存布局和内存交互方式，如布局为主内存加工作内存的方式，主内存为所有线程一起共享的内存区域，工作内存为当前线程的私有区域。交互方式为，当一个线程运行时，它会从主存中拷贝一份需要的内容到工作内存，在这基础上进行运算处理，操作完成后，将结果写回主存中。而这个模型还有一件很重要的工作就是，要解决工作内存与主存的交互问题，所以产生了各种屏障，也就是它的关键。这就是java的内存模型，你要说有什么不合适吧也没有，但是当别人问我这东西的时候，我问题怀疑什么叫模型，总想象着一个缩小版物理是什么样的？回答不上来也完全不是因为我不知道他们的工作方式，尴尬。
netty线程模型？线程能有什么模型，顶多就线程池呗还能咋的？不过如果换个问法可能亲民了，netty的io线程线程是如何工作的？正确答案是reactor模型，reactor中文翻译为核反应堆，大概就是一个导火线，引发一个大爆炸的这么个样子。具体来说就是，一个acceptor线程专门接收客户端请求，然后接收到请求后将请求分发到后端线程池，消息的读取，编解码和发送都由这个线程池完成。当然了，这只是reactor的其中一种模式，它还有其他更完善的方式，如主从reactor线程池模式。总之，目的就是让系统能够处理更多的并发请求，通过多个线程池的方式。所以，这个不叫线程模型好像也不好其他方式了。
双亲委托加载模型？这个是java中的基础的类加载方式，概念见过就是见过，没见过就是没见过。本也没啥，就是在加载类时优先让父类进行加载，不行再由自己加载的这么个过程。只是我觉得一个很简单一句话被提炼出一个双亲委托加载模型后，逼格瞬间提高了很多。而且，这里模型好像就变成了一个动词有木有。如果不提炼这么个名词出来，你又如何去描述这一事物呢？
消息传递模型？这个比较容易理解，也就是一个消息如何从一个点传递到另一个点描述。基本上现在的MQ产品里描述的比较清楚，描述方向也各有不同，比如点对点消息传递模型、发布订阅消息传递模型。简单说这种模型一般都一个producer,queue,consumer这么几个元素，由producer发送一个消息到queue中，然后由consumer从queue中获取数据的这么个过程，其中重点要关注的可能就是确认ack机制以及推消息模型还拉消息模式，这确实得要细细去了解具体的产品了。但总体来说，知道是这么个问题本质方向是比较重要的，毕竟谁还不会写几个bug呢？但是能把bug讲得声色俱全的却是不多的。
数据模型？这个概念其实我们见得也是最多的，比如做开发的时候，表的设计，不就是一个建立数据模型的过程吗？（建模）。百科上有准确的描述：数据模型（Data Model）是数据特征的抽象。数据（Data）是描述事物的符号记录，模型（Model)是现实世界的抽象。数据模型从抽象层次上描述了系统的静态特征、动态行为和约束条件，为数据库系统的信息表示与操作提供了一个抽象的框架。数据模型所描述的内容有三部分：数据结构、数据操作和数据约束。这么一说概念，好像都很清楚明白，但是当一个逼格高的面试官问题，你们的数据模型是怎么样的？你可就不一定答得上来了吧，其实就是问你的数据是如何抽象出来的，他们之间是如何关联，以及都各自的特点。好像话说白了，都显得逼格低，尴尬。
java对象模型？按照数据模型的套路，也可以描述下这个问题。1. 由什么组成？大方向是有对象头+实例数据+对齐填充组成，我们更多需要描述下对象头的内容，比如 _mark, _metadata, 与锁相关的运行时数据保存在_mark对象头中，而且_mark内容不是固定的，它会根据锁状态不同存储不同的信息，主要包含GC分代年龄、锁状态标记、哈希码、epoch等信息; 2. 能做什么操作？数据的实例信息都保存在堆中，由对象头的指针标明其所在。
mapreduce模型？这是hadoop的分布式并行计算模型，即只有两个函数map和reduce组成的计算模型，其中由分片，排序，合并，归并等重要操作连接起来的这么个模型，可以让开发人员只需关注计算逻辑而无需协调各种分布式问题，从而简化大数据开发流程降低开发门坎的这么个模型，包括后续的spark，storm，flink其中也多少脱不了mapreduce的影子。
开发模型？这准确的说是一个管理类模型，很形象：瀑布模型；快速原型模型；增量模型；螺旋模型；演化模型。。。 这可能更符合小白眼中的模型概念吧！
还有其他有意思的模型，让我们拭目以待吧！
唠叨: 深度优先。
转载于:https://www.cnblogs.com/yougewe/p/11442381.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0ed15bc29893a42fbf695ae74786cf/" rel="bookmark">
			【新手入门】树莓派Raspberry 学习笔记2 散热片&amp;散热风扇&amp;外壳安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 树莓派Raspberry Pi3B+学习笔记1
今日达成：
①散热片安装
②散热风扇安装
③外壳安装
散热片安装 我买的套装给了三个散热片，查了查网上的资料，比较应该比较的就是两个，分别给GPU和CPU散热（都在正面），散热片贴在正中间就可以，直接上图。
找到一个比较好的视频，分享给大家：
https://video.tudou.com/v/XMTY5Mzc2NDYwOA==.html?f=50513641
【注】散热片要一发入魂，贴歪了最好不要拔下重来（听闻有人把芯片也顺带着拔下来了？？）
散热风扇安装 九层外壳有其中一层上面有一个圆圈，非常明显是给用来安装散热风扇的。如图。
最后风扇的两条线插在主板靠卡槽那边的外面那排引脚上，红二黑三
外壳安装 我的是九层外壳，先剥掉保护纸（湿点水就很好弄下来了），再开始安装。
安装顺序由下至上如图。按着顺序一层一层往上叠就行。
安装完毕 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfbeae195a162f6d202e64092bb9abb/" rel="bookmark">
			Linux查看程序执行时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time 命令
time php tcp_client_async.php
real 为总时间
user 程序本身消耗的时间
sys Linux系统完成此程序消耗的时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4adbca41a9b6a2302d8a2b310904ccc4/" rel="bookmark">
			jdk12 64位官方版(附环境变量配置教程) v12.0.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下载来源：jdk12 64位官方版(附环境变量配置教程) v12.0.2
jdk12目前已经全新发布了，作为当前最热门的计算机语言之一，如今已被广泛应用到科技行业的各个领域。在这个新版本中新填的Switch表达式不仅可以作为语句也可以作为表达式。无论作为语句或者作为表达式，switch都可以使用传统/简化的作用域和控制流行为。这将有助于简化代码，并为在switch中使用模式匹配铺平道路。改进过后的G1归将不再使用内存，此功能的主要目标是改进G1垃圾收集器，以便在不活动时将Java堆内存归还给操作系统。为实现此目标，G1将在低应用程序活动期间定期生成或持续循环检查完整的Java堆使用情况。这将立即归还未使用的部分Java堆内存给操作系统。用户可以选择执行FULL GC以最大化返回的内存量，它还有着更多新功能带你来体验。在这次中小编给大家带来的是jdk12 64位官方版下载，此版本小版本好为12.0.1是目前的最新版本，在下文中有着小编精心编写的安装教程与非常详细的环境变量配置教程，可让你在第一时间上体验大这款全新的jdk12。
jdk12.0.1 64位官方版
安装教程
1、在本站下载好jdk12 64位官方版文件包，解压出来双击“jdk-12.0.1_windows-x64_bin.exe”主程序运行开始安装，在安装向导界面直接点击“下一步”。
2、安装路径建议不要更改，默认直接点击“下一步”即可。
3、程序正在安装，需要些时间请小伙伴们耐心等待哦。
4、好了安装完成，点击关闭下面我们开始环境变量配置。
环境变量配置教程
1、鼠标右键计算机选择属性。
2、然后点击高级系统设置环境变量。
3、在系统变量中新建变量
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk-12.0.1 (ps:如果你没有改变默认路径复制就可以，如果修改过请选择jdk的安装目录)，填写好后点击“确定”。
JAVA_HOME是用来表示jdk的安装目录。
配置java_home的原因是：
（1）方便引用。
（2）其他软件会引用约定好的JAVA_HOME变量。比如tomcat就需要引用JAVA_HOME。
4、在系统变量列表中找到“Path”，点击“编辑”，在变量值最后输入
%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码），填写好后点击“确定”。
5、接着新建CLASSPATH 变量
变量值填写.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意最前面有一点）
系统变量配置完毕
6、检验是否配置成功，电脑重启后，win+R 输入cmd 进入命令提示符界面java -version（java 和 -version 之间有空格），若如图所示 显示版本信息则说明安装和配置成功。
输入java查看命令
输入javac查看命令
软件分类
java.lang： 这个是系统的基础类，比如String等都是这里面的，这个包是唯一一个可以不用引入(import)就可以使用的包。
java.io： 这里面是所有输入输出有关的类，比如文件操作等。
java.nio：为了完善io包中的功能，提高io包中性能而写的一个新包 ，例如NIO非堵塞应用。
java.net: 这里面是与网络有关的类，比如URL，URLConnection等。
java.util： 这个是系统辅助类，特别是集合类Collection，List，Map等。
java.sql： 这个是数据库操作的类，Connection， Statement，ResultSet等。
javax.servlet：这个是JSP，Servlet等使用到的类。
包含的基本组件
javac – 编译器，将源程序转成字节码
jar – 打包工具，将相关的类文件打包成一个文件
javadoc – 文档生成器，从源码注释中提取文档
jdb – debugger，查错工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4adbca41a9b6a2302d8a2b310904ccc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7d5c4168a1ebec7b89b9d1766b2640/" rel="bookmark">
			Qt如何将数据保存成CSV文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、csv文件 csv文件是逗号分隔值（Comma-Separated Values，CSV）文件的缩写，其文件以纯文本形式存储表格数据（数字和文本），各个字段用逗号进行分割，采用回车进行换行。由于采用纯文本记录，csv文件可以很方便的被文本处理工具、excel等工具识别。
二、Qt中导出csv文件 在Qt中打开与保存csv文件十分方便，直接按照普通文本的形式操作，用QTextStream进行标准化的读写，还是很简单。
具体例如：
void mainwindow::OnExportBtnClicked() { //1.选择导出的csv文件保存路径 QString csvFile = QFileDialog::getExistingDirectory(this); if(csvFile.isEmpty()) return; //2.文件名采用系统时间戳生成唯一的文件 QDateTime current_date_time =QDateTime::currentDateTime(); QString current_date =current_date_time.toString("yyyy_MM_dd_hh_mm_ss"); csvFile += tr("/%1_DTUConfigInfo_export_%2.csv").arg(username).arg(current_date); //3.用QFile打开.csv文件 如果不存在则会自动新建一个新的文件 QFile file(csvFile); if ( file.exists()) { //如果文件存在执行的操作，此处为空，因为文件不可能存在 } file.open( QIODevice::ReadWrite | QIODevice::Text ); statusBar()-&gt;showMessage(tr("正在导出数据。。。。。。")); QTextStream out(&amp;file); //4.获取数据 创建第一行 out&lt;&lt;tr("UID,")&lt;&lt;tr("sysID,")&lt;&lt;tr("UsrID,")&lt;&lt;tr("MeterNum,")&lt;&lt;tr("CMD,\n");//表头 //其他数据可按照这种方式进行添加即可 //5.写完数据需要关闭文件 file.close(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341358930219c12c649e605b781138d6/" rel="bookmark">
			联网时浏览器跳出MSN中国网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联网时浏览器跳出MSN中国网页 问题描述
联网时浏览器跳出MSN中国网页
原因
在网上查找到的问题原因：导致该现象的是一个名为“Windows 网络连接状态指示器(NCSI)执行的活动测试”的功能。当介入网络，系统检测到你需要二次认证的时候自动弹出浏览器让你登陆。你的状态是已经登陆的了，于是跳转到MSN中国网站。
操作
运行 -&gt; regedit
打开注册表编辑器，修改计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet
EnableActiveProbing的值为0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d497eb992a7bf7775520c9391460df9a/" rel="bookmark">
			[java进阶]4.关键字throws和throw
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. throws 关键字 throws关键字主要用于方法声明上，指的是当方法之中出现异常后交由被调用处处理。
class MyMath{ //由于存在throws,那么就表示此方法里面产生的异常交给被调用处处理	public static int div(int x, int y) throws Exception{ return x/y; } } public class TestDemo{	public static void main(String args[]){ try{	System.out.println(MyMath.div(10,2)); }catch(Exception e){ e.printStackTrace(); } } } 也就是说调用了throws声明的方法之后，那么不管操作是否出现异常，都必须使用try...catch语句进行异常处理。 主方法使用throws后，那么这个异常就将交给JVM进行处理，而后结束程序调用。
2. throw 关键字 在程序之中可以直接使用throw手动抛出异常类的实例化对象。
public class TestDemo{	public static void main(String args[]){ try{	throw new Exception("自己定义的异常"); }catch(Exception e){ e.printStackTrace(); } } } 总结：
throw: 指的是在方法之中人为抛出一个异常类对象，这个对象可以是自己实例化，或者是已经存在的。throws: 指的是在方法的声明上使用，表示此方法在调用时必须处理异常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e337a7621412debc443a45d2dc07fe/" rel="bookmark">
			Go：性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能优化背景以及原理 1. 性能优化背景
2. 常见性能优化手段
A. 尽可能的减少 HTTP 的请求数。合并css和js以及图片。
B. 使用CDN系统，实现就近访问。
C. 启用gzip压缩，降低网页传输的大小。
D. 优化后端api服务的性能。
3. Api服务性能优化的目标 A. 线上程序是一个黑盒
B. 通过性能优化，能够分析程序占用了多少资源？
C. 找到系统的瓶颈点
4. Golang中的性能优化 A. Cpu维度的优化 性能优化背景以及原理
B. Mem维度的优化
C. 锁竞争维度的优化
5. 性能优化的原理 A. 要知道程序占用了多少资源，比如Cpu、内存等 B. 要知道程序的各个函数占用的资源比例
C. 有了A、B两个部分数据，我们就可以快速的定位到系统的性能瓶颈
D. 怎么达成这个目标？
当pprof开启后，每隔一段时间(10ms)收集下当前堆栈信息，获取各 个函数占用的cpu以及内存资源；当pprof完成之后，通过对这些采 样数据进行分析。形成一个性能分析报告。
CPU性能优化 6. CPU性能优化讲解 A. import (“runtime/pprof”)
B. 开始CPU性能分析：pprof.StartCPUProfile(w io.Writer)
C. 停止CPU性能分析: pprof.StopCPUProfile()
package main import ( "flag" "fmt" "os" "runtime/pprof" "time" ) func logicCode() { var c chan int // = make(chan int, 1) for { select { case v := &lt;-c: fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e337a7621412debc443a45d2dc07fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1127d5f3a07ac89838446b7381bda5f4/" rel="bookmark">
			NUCLEO F030R8开发板作为STLINK给外部MCU仿真编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NUCLEO F030R8开发板作为STLINK给外部MCU仿真编程 最近工作不怎么忙，看着公司开发项目买的开发板NUCLEO F030R8在吃灰就想整点事做，开发板NUCLEO自带仿真器给芯片仿真编程，能不能把编程脚引出来给其它的STM32系列MCU编程呢？试试才知道吧，马上开始行动。先找来原理图看看。 默认CN2通过两个短接片连起来，实际上就是将T_JTCK,T_JTMS和编程芯片连起来，通过TCK,TMS,NRST,SWO连至芯片。我们知道swd接口 就四根信号VCC3.3V,SWCLK,SWDIO,GND,看看MCU部分原理图
上图TMS,TCK分别对应SWDIO,SWCLK,所以取STLINK原理图上的CN4端子上的2脚（SWCLK）和4脚（SWDIO）,还需找到电源和地，在STLINK原理图上找到CN11接地，JP1左端接VCC3.3V,接上四根线连至MCU编程接口，打开
编程软件，连接编程成功
实物图
此接线只针对于NUCLEO F030R8 开发板。我手里刚好还有一块NUCLEO L433RC板，它JP1接的是STLINK_RST复位脚 。刚开始以为和NUCLEO F030R8开发板一样，接上VCC3.3V，板子直接不工作，连STLINK也识别不出来。加了根杜邦线连至主板3V3接口，打开编程软件连接正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef295ab42b60d73f6d0bf07d7986a6d1/" rel="bookmark">
			linux开启SELINUX后无法列出/home的目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统RHEL7.6
ftp server：VSFTPD
使用flashFXP或filezilla客户端登录ftp无法列出/home的目录，提示：
[左] CWD home
[左] 250 Directory successfully changed.
[左] PWD
[左] 257 "/home"
[左] PASV
[左] 227 Entering Passive Mode (10,204,195,127,125,66).
[左] 正在打开数据连接 IP: 10.204.195.127 端口: 32066
[左] LIST -al
[左] 150 Here comes the directory listing.
[左] 226 Transfer done (but failed to open directory).
从网上查到这个错误是因为开启了SELINUX，关闭SELINUX后就可以访问了。
[root@lnlte2dmr-tdl /]# vi /etc/selinux/config # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef295ab42b60d73f6d0bf07d7986a6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852686e9de2f916fccad5261e21bbfee/" rel="bookmark">
			erase()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章中提到过如何向容器中添加元素，这里介绍一个如何删除容器中元素的函数，包括顺序容器和关联容器。
就是这个erase函数，基本用法如下：
c.erase( p)------------------------------从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()
c.erase(b,e)----------------------------从c中删除迭代器对b和e所表示的范围中的元素，返回e
具体用法如下：
vector&lt;string&gt; e = {"a","b","c","d","e","f","g"}; e.erase("c"); //删除字符串“c” auto it = e.end()-1; //.end()指向末尾的后一个元素，因此需要-1，指向末尾元素 e.erase(it); //删除末尾元素“e” auto it2 = e.begin()+1; auto it3 = e.end()-2; e.erase(it2,it3); //删除it2到it3之间的元素 对于第二种用法，可以拓展一下：
auto it = a.begin(); auto it2 = a.find("c"); //it2指向“c”所在位置 auto it3 = a.erase(it,it2); //删除it到it2之间的所有元素，即“a”和“b” a.erase(it3); //此时删除的是“c”,即先前it2所指，因为第三种用法返回的就是第二个迭代器所指位置 实际上，erase函数是用来操作string的，函数原型如下：
（1）string&amp; erase ( size_t pos = 0, size_t n = npos );删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
（2）iterator erase ( iterator position );删除position处的一个字符(position是个string类型的迭代器)
（3）iterator erase ( iterator first, iterator last );删除从first到last之间的字符（first和last都是迭代器）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852686e9de2f916fccad5261e21bbfee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c70182834c699815cfeac4244ec6aa/" rel="bookmark">
			Try-catch()  对于流的新用法(try-with-resources，try后加括号 ), 以及异常新方法addSuppressed(针对异常屏蔽)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java7 开始 ，针对stream流的close()操作有了新的写法。
之前我们都要在finally中执行close()方法，如果用到了多个流，要写不少的多余代码，finally中全是close()，而且我们的写法还不一定安全（大佬可能会避免）。如下代码：
首先贴上我的两个自定义流：
class MyFileOutputStream extends FileOutputStream { MyFileOutputStream(String name) throws FileNotFoundException { super(name); } @Override public void close() throws IOException { System.out.println("&gt;&gt;&gt;&gt;MyFileOutputStream close"); throw new IOException("Exception in MyFileOutputStream close()"); } public void read() { System.out.println("&gt;&gt;&gt;&gt;MyFileOutputStream read"); } } class MyZipOutputStream extends ZipOutputStream { public MyZipOutputStream(OutputStream out) { super(out); } @Override public void close() { System.out.println("&gt;&gt;&gt;&gt;MyZipOutputStream close"); } public void read() throws IOException { System.out.println("&gt;&gt;&gt;&gt;MyZipOutputStream read"); throw new IOException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c70182834c699815cfeac4244ec6aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40de5c5b5c560f312c15f1cb182fd64a/" rel="bookmark">
			2017 Linux运维人员必会开源运维工具体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.51cto.com/oldboy/775056
转载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c65a71cfc98fddf428a97e1d7fb28d5/" rel="bookmark">
			elementUI&#43;VUE完成动态添加表单项并使用watch深度监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE的watch深度监听 需求是动态添加表单项并计算金额以及总价，由于需要监听对象中的数组属性并计算金额，使用到了watch深度监听。刚使用vue不久，记录一下解决问题的过程，代码写得不是很好，见谅
效果图：
js代码:
/*监听价格及数量变化，计算物品总价及采购总价*/ watch:{ 'form.purchase_list':{ handler:function(val,oldval){ // console.log(val); let total_price=0; let total_amount=0; for (let i=0;i&lt;val.length;i++){ //总价计算并赋值 total_price=val[i].goods_price*val[i].goods_qty; this.form.purchase_list[i].total_price=total_price; //总价计算并赋值 total_amount+=total_price; this.total_amount=total_amount; } }, deep:true//对象内部的属性监听，深度监听 }, }, data部分：
total_amount:0, form: { goods_type:'', purchase_list:[{ goods_name:'', goods_price:1, goods_qty:'', total_price:0, }], purchase_reason: '', approve_person:'' }, 可以看到，purchase_list的每一项是用户点击新增动态添加进去的，由于watch只能监听普通属性，所以这里添加deep:true开启深度监听，在指定的属性内的所有数据只要发生变化都会触发监听。监听写成对象形式，那么对象中的所有属性发生变化都会被监听，所以这里进行了优化，使用字符串的’form.purchase_list’监听对象中的某个属性，并循环计算数组中的数据，完成需求。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/413/">«</a>
	<span class="pagination__item pagination__item--current">414/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/415/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>