<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ebcbfe54cabdc62a38e7a174ee5a20e/" rel="bookmark">
			UE5 产品三维交互展示 创意收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 无人机展示 https://www.bilibili.com/video/BV12N4y1g7gA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
开场是场景漫游重要部件靠近观察颜色调整拆分与合并，过程流畅拆分后靠近观察产品动画，动画中，可以靠近观察局部细节 2. UE5产品可视化 https://www.bilibili.com/video/BV1xs4y1Z7wE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
（1）家具
椅子展示，光影效果极佳拍摄角度可以参考专业摄影的规则放大后，材质效果依然很好颜色材质替换产品360旋转展示局部放大展示，局部放置小圈圈拍照留念
（2）发动机
零件拆解，产品剖面拆解后，零件点击查看产品运行动画产品CT式扫描展示透明模式，全息模式（表壳透明）光影从里到外，也比较自然 （3）陶瓷
背景为真实场景，增强产品氛围各部位视线 （4）电脑
配件摆出展示点击配件看详情组装动画通过UI，聚焦物体 3. UE5产品交互展示-空气净化器 https://www.bilibili.com/video/BV19o4y1H7fM/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
展示分2种，1是摄像机不转，产品转；2是产品不转摄像机转第1种，运用摄像的原理，把氛围光打好，因为其他位置的光就不好看，所以摄像机不能转（注重光带来的细节）第2种，牺牲了光的细节，增加了场景作为背景，摄像机转动，移位换景，以景来衬托产品（注重场景的衬托） 可以把两者都运用到软件中
拆分后，还可以隐藏其他零件，单独显示某一零件，来讲述此零件的特点放入家中，看效果 4. UE5海尔电饭煲 https://www.bilibili.com/video/BV17o4y1p7HH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
产品细节漫游展示漫游中，运用焦距从模糊到清晰的效果功能模拟操作，带出特色介绍尺寸展示配件展示UI结合放入某些环境中，家中或自然中，体现某些理念或者加入一些元素在展示中，化妆品+一些植物 5. 极简门 https://www.bilibili.com/video/BV1od4y1E7x5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
把广告片的手法运用在互动展示过程中 6. MetaShoot摄影棚插件 https://www.bilibili.com/video/BV1214y1B7Jn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
插件地址：https://metashoot.vinzi.xyz/
产品的表现时，光不一定是固定的，也可以是运动的 7. 吹风机 https://www.bilibili.com/video/BV1co4y1u783/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
透明展示，透明度调节剖面调节，剖面展示 8. 数字工业孪生展示 https://www.bilibili.com/video/BV17e411D7cQ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=707ec8983cc32e6e065d5496a7f79ee6
加入了数字元素，工业4.0概念融入组合动画，加入粒子特效，表达机动元素加入很多粒子与光效，表达未来元素 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de276fb5df5ebfebaa13cd5d634c19ec/" rel="bookmark">
			Matlab中边缘提取方法简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、Matlab简述
Matlab是国际上最流行的科学与工程计算的软件工具，它起源于矩阵运算，已经发展成一种高度集成的计算机语言。有人称它为“第四代”计算机语言，它提供了强大的科学运算、灵活的程序设计流程、高质量的图形可视化界面设计、便捷的与其它程序和语言接口的功能。随着Matlab语言功能越来越强大，不断适应新的要求并提出新的解决方法，可以预见，在科学运算，自动控制与科学绘图领域，Matlab语言将长期保持其独一无二的地位。
2、几种常用的边缘检测算子
边缘是图像的最重要的特征，边缘是指周围像素灰度有阶跃变化或屋顶变化的那些像素的集合。边缘检测主要是灰度变化的度量、检测和定位。有很多种不同的边缘检测方法，同一种方法使用的滤波器也不尽相同。图像边缘检测就是研究更好的边缘检测方法和检测算子。
边缘检测的基本思想首先是：
(1)利用边缘增强算子，突出图像中的局部边缘，
(2)然后定义象素的“边缘强度”，通过设置阈值的方法提取边缘点集。
由于噪声和模糊的存在，监测到的边界可能会变宽或在某点处发生间断。因此，边界检测包括两个基本内容：
i. 用边缘算子提取出反映灰度变化的边缘点集
ii. 在边缘点集合中剔除某些边界点或填补边界间断点，并将这些边缘连接成完整的线
常用的检测算子有微分算子、拉普拉斯高斯算子和canny算子。在Matlab图像处理工具箱中，提供了edge函数利用以上算子来检测灰度图像的边缘。基于小波的matlab做边缘提取的代码
3、边缘检测算子举例（MATLAB）
数字图像处理技术中常用的边缘检测算子有Sobel算子，Roberts算子，prewitt算子，log算子，canny算子。其中canny算子检测效果最好。
MATLAB实现算法如下：
I=imread('lena.bmp');% 提取图像 BW1=edge(I,'sobel'); %用SOBEL算子进行边缘检测 BW2=edge(I,'roberts');%用Roberts算子进行边缘检测 BW3=edge(I,'prewitt'); %用prewitt算子进行边缘检测 BW4=edge(I,'log'); %用log算子进行边缘检测 BW5=edge(I,'canny'); %用canny算子进行边缘检测 h=fspecial('gaussian’,5); BW6=edge(I,’canny’); subplot(2,3,1), imshow(BW1); title(‘sobel edge check’); subplot(2,3,2), imshow(BW2); title(‘sobel edge check’); subplot(2,3,3), imshow(BW3); title(‘prewitt edge check’); subplot(2,3,4), imshow(BW4); title(‘log edge check’); subplot(2,3,5), imshow(BW5); title(‘canny edge check’); subplot(2,3,6), imshow(BW6); title(‘gasussian&amp;canny edge check’);%此为用高斯滤波后Canny算子边缘检测结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b2a36c56450e2aaa8035063c03b365/" rel="bookmark">
			git——git 更新远程分支到本地 &amp;&amp; git 切换分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git 更新远程分支到本地 git remote update origin --p git 切换分支 git checkout 分支名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181764a2bc5fa5a95debb6c31819a401/" rel="bookmark">
			运用c3p0管理数据库相对于老版默认配置文件管理数据库的优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C3P0库来管理数据库连接相对于直接在默认配置文件中设置连接数据库的相关信息有一些优点，尤其是在大型或长期运行的应用程序中。以下是一些优点：
1. 连接池管理：
-连接重用：C3P0通过连接池管理数据库连接，允许连接的重复使用，而不是为每个数据库请求创建新的连接。这降低了连接的创建和关闭开销，提高了性能。
- 连接池大小控制：可以配置连接池的最小和最大连接数，确保系统资源得到有效利用。这有助于避免因为连接数不当导致的性能问题或资源浪费。
2. 连接可靠性：
- 连接检测：C3P0可以定期检测连接的可用性，确保连接仍然有效。这有助于避免使用已经失效的连接，提高了应用程序的稳定性。
3. 性能优化：
- Statement和ResultSet缓存： C3P0可以缓存预处理语句（PreparedStatement）和结果集（ResultSet），以减少它们的创建和关闭开销，提高查询性能。
- 连接池参数调优： 可以通过调整连接池的参数来优化性能，如最小/最大连接数、连接超时等。
4. 灵活的配置：
- 动态配置： C3P0允许在运行时动态修改连接池的配置，而无需重新启动应用程序。这使得在不停止应用的情况下进行调整成为可能。
5. 异常处理：
- 异常处理和重试： C3P0能够处理数据库连接的异常情况，包括连接超时、SQL异常等，并提供一些灵活的配置选项，如自动重试。
6. 可扩展性：
- 支持多种数据库：C3P0对多种数据库提供支持，因此可以轻松切换或同时使用不同的数据库。
总体而言，使用C3P0库管理数据库连接可以提高应用程序的性能、可靠性和灵活性，特别是在高并发、长时间运行的应用中。连接池的概念使得数据库连接的管理更加智能和有效。
以上信息来自chatgpt搜索，为自己平时记录用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0bbd2809ba7f4f334f4691b5f0f7b7/" rel="bookmark">
			离散傅立叶变换和线性变换的关系：什么是线性空间？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离散傅立叶变换和线性变换的关系：什么是线性空间？ 本篇博客是在学习线性空间知识的时候联想到的，通过分析DFT背后的数学原理，以便更好地理解什么是线性空间、什么是线性变换。
1、离散傅立叶变换（DFT）和Fourier矩阵 离散傅立叶变换是六种傅立叶变换的一种。特点是时域离散、频域离散、有限长度。公式如下：
X [ k ] = ∑ n = 0 N − 1 x [ n ] e − j k 2 π N n (1) X[k] = \sum_{n=0}^{N-1} x[n]e^{-j k \frac{2\pi}{N} n} \tag{1} X[k]=n=0∑N−1​x[n]e−jkN2π​n(1)
x [ n ] = 1 N ∑ n = 0 N − 1 X [ k ] e j k 2 π N n (2) x[n] = \frac{1}{N}\sum_{n=0}^{N-1} X[k]e^{j k \frac{2\pi}{N} n} \tag{2} x[n]=N1​n=0∑N−1​X[k]ejkN2π​n(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0bbd2809ba7f4f334f4691b5f0f7b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8373fa57a6a04cd52630fef543025f/" rel="bookmark">
			卷积、去卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，线性卷积
1，连续卷积
2， 离散卷积
3，卷积的性质
（1）交换律
（2）结合律
（3）分配律
（4）数乘
（5）微分
二，周期卷积
三，循环卷积
1，二维连续循环卷积
2，二维离散循环卷积
3，二维离散循环卷积的各种表示法
（1）小卷积核表示法
（2）大矩阵表示法
（3）超大矩阵表示法
（4）超大矩阵互为转置的2个卷积核
（5）超大矩阵互为转置的2个卷积核的傅里叶变换
（6）三种运算方式
四，高斯卷积
五，滤波器
六，去卷积
1，最优化问题
2，矩阵分析
3，函数形态分析
4，Chambolle-Pock算法
5，prox求解
6，矩阵运算优化
7，去傅里叶变换
一，线性卷积 1，连续卷积 设: f(x),g(x)是R1上的两个可积函数，作积分
可以证明，关于几乎所有的实数x，上述积分是存在的。这样，随着x的不同取值，这个积分就定义了一个新函数h(x)，称为函数f与g的卷积，记为h(x)=(f*g)(x)
对于二维甚至多维空间的积分卷积，定义同理。
2， 离散卷积 和连续积分类似的，离散卷积也是两个序列所有和为固定值的元素乘积之和。
实际上，离散卷积和积分卷积的本质是一样的，可以轻松互相转化。
3，卷积的性质 （1）交换律 （2）结合律 （3）分配律 （4）数乘 （5）微分 对于离散卷积，D就是差分
二，周期卷积 如果2个周期函数可积，那么它的线性卷积：
然而，周期函数只要都不是恒为0，上式的反常积分都是不存在的。
PS：这个反常积分的柯西主值有可能为0，但是不代表反常积分收敛。
高等数学_csuzhucong的博客-CSDN博客
而实际上，周期函数也没有必要在无穷区间上卷积，只需要在一个周期内即可。
周期函数的周期卷积：
离散的：
三，循环卷积 对于定义域是有限区间的函数，循环卷积就是函数做周期延展之后的周期卷积。
1，二维连续循环卷积 从这个式子看，其实也相当于从任意位置分割成2段，分段卷积之和。
2，二维离散循环卷积 3，二维离散循环卷积的各种表示法 以卷积 为例
（1）小卷积核表示法 （2）大矩阵表示法 当我们用卷积定理，用傅里叶变换实现卷积运算，使用的就是大矩阵表示法。
（3）超大矩阵表示法 用矩阵表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8373fa57a6a04cd52630fef543025f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a50d1cac8fad3ce0dd50b311c1575a0/" rel="bookmark">
			Flask 账号详情展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask 账号详情展示 这段代码是一个基于Flask框架的Python应用程序。
它包含了两部分代码：Python代码和HTML代码。
web/templates/common/tab_account.html &lt;div class="row border-bottom"&gt; &lt;div class="col-lg-12"&gt; &lt;div class="tab_title"&gt; &lt;ul class="nav nav-pills"&gt; &lt;li class="current"&gt; &lt;a href="{{ buildUrl('/account/index') }}"&gt;账户列表&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class="nav nav-pills"&gt;：
组件 · Bootstrap v3 中文文档 | Bootstrap 中文网 胶囊式标签页
这就是几个类名用以css定义样式。
wtb/static/css/style.css
.tab_title .nav &gt; li &gt; a{ color: #666; font-weight: 600; padding: 14px 20px 14px 25px; } .tab_title .nav li.current{ border-bottom: 4px solid #1ab394; } .tab_title .nav&gt;li&gt;a:focus, .tab_title .nav&gt;li&gt;a:hover{ text-decoration: none; background-color: #fff; } JavaScript 插件 · Bootstrap v3 中文文档 | Bootstrap 中文网 Togglable tabs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a50d1cac8fad3ce0dd50b311c1575a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ef463eef8152e0107c3e571fb50c8e/" rel="bookmark">
			【电力电子技术课程设计】单相交流调压电路Simulink仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做电力电子技术课程设计，题目是单相交流调压电路设计，仿真部分用 Matlab/Simulink 试了一下。
版本：R2018a
文章目录 1. 题目要求：2. 方法：3. 仿真电路图：3.1 参数设置：3.1.1 交流电压源：3.1.2 脉冲发生器：3.1.3 负载电阻：3.1.4 万用表： 3.2 仿真波形图：3.3 移相调压：3.3.1 触发角为 60°3.3.2 触发角为 90°3.3.3 触发角为 120° 4. 数据测量：5. 资源下载： 1. 题目要求： 输入电压为36V交流，输出交流电压可变，带纯电阻性负载。
2. 方法： 通过调相，调节输出交流电压：
单相交流调压电路由两只反并联的晶闸管组成，也可以用一个双向晶闸管代替。由于晶闸管为单向开关元件，故两只普通晶闸管分别作正负半周的开关，当一个晶闸管导通时，它的导通压降成为另一个晶闸管的反压使之阻断，实现电网自由换流。在交流电源的正半周和负半周，分别对两个晶闸管的触发角进行控制就可以调节输出电压。
3. 仿真电路图： 3.1 参数设置： 3.1.1 交流电压源： 设置工频 50Hz，有效值 36V ，测量电压：
Peak amplitude 设置为 36*sqrt(2)
Frequency 设置为 50
Measurements 选择 Voltage
3.1.2 脉冲发生器： 设置工频 50Hz，触发角 30° ：
Period 设置为 1/50 （1/50=0.02s）
Phase delay 设置为 30/360*1/50 （注意要乘上周期）
另一个脉冲发生器的设置类似，不同的是触发角相差180°：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ef463eef8152e0107c3e571fb50c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77d7c32eb768852dc1e0e774ed6c837/" rel="bookmark">
			IDEA运行单个java文件，忽略其他文件错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA运行单个java文件，忽略其他文件错误 使用idea想单独运行一段测试程序，但是直接run的话会报其他程序的错误，使用以下方法可以实现单独运行一段测试程序。
File | Settings | Build, Execution, Deployment | Compiler | Java Compiler，将compiler修改为Eclipse（注意这里有一个Project bytecode version后面可能会报错）
设置完成之后如果直接编译会报错：java: java.lang.IllegalArgumentException: source level should be in ‘1.1’…‘1.8’,‘9’…‘18’ (or ‘5.0’…‘18.0’): 21
这里是因为默认的版本21不支持，按照错误信息，我们将Project bytecode version修改为18即可。修改Run/Debug Configurations，添加Add before launch task，去掉默认的Build，添加Build，no error check
直接run测试代码即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e6a46578807d2a4e79e4668e6c5ba3/" rel="bookmark">
			前端琐碎汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前端琐碎汇总一、jQuery数字相关方法事件函数元素操作 二、CSS样式 前端琐碎汇总 一、jQuery 数字相关 向下取整: Math.floor()向上取整: Math.ceil()四舍五入: number.toFix(n) 其中number为要处理的数, n为保留小数的位数字符串转数字: Number() 括号中写要转换的字符串求最小值: Math.min.apply(null,数组) ,数组为要取最小值的数组,最大值同理(min换成max)删掉数组中的元素 : arr.splice(index,number) arr:目标数组, index:下标, number:删除数量 方法 获取/赋予 属性值: $("#id").attr(x,y) x为属性名, y为属性值, 如果只写x为获取清空内容: $("#id").empty();输出到控制台: console.log()添加子页面到 : $("#id").append(html)刷新页面 : location.reload()存cookie:$.cookie("name", value,{"expires":days}) name:cookie名, value:cookie值, days: 有效期(天)取cookie: $.cookie("avatar")form表单数据: $("#id").serialize() name相关在url中取参数: $.getUrlParam("参数名")网页跳转: location.href = "网页地址"页面加载完成: $(function(){ }) 等同于 $(document).ready(function() { })页面传参: $(location).attr("href", "网址?参数名=参数值")页面传参乱码: 传递方:encodeURI("网址?参数名=参数值") ,接收方:decodeURI(获取的参数值)获取dom内的内容: $("#id").val(), $("#id").text() 括号中填写值为赋值操作禁用按钮: $("#id").attr('disabled',true)自动刷新 &lt;meta http-equiv="refresh" content="5"&gt; 每5秒刷新一次获取下拉框选中的文本 $("#id").find("option:selected").text()表格td可编辑, 加属性 contentEditable = "true"关于 onclick() 方法中本元素this的获取 //function中直接用this会指向window &lt;div onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e6a46578807d2a4e79e4668e6c5ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93004781218bbb78809440501e8e5ffc/" rel="bookmark">
			LinkedIn 开源分布式存储系统Ambry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式存储入门认知 分布式存储是一种用于处理大规模数据的存储系统。随着互联网的发展和数据量的爆发式增长，传统的集中式存储已经无法满足需求。分布式存储通过将数据分散存储在多个节点上，实现高可靠性、高扩展性和高性能的存储解决方案
分布式存储的基本原理 分布式存储系统由多个存储节点组成，每个节点负责存储一部分数据。数据通常被分成多个块，并通过数据切分和冗余备份来提高容错性和数据可用性。节点之间通过网络连接进行通信和数据同步，实现数据的高效分布式存储和访问
分布式存储的优势 高可靠性：分布式存储通过数据冗余备份和故障转移来提供高可靠性，即使某个节点出现故障，数据依然可用。
高扩展性：由于数据被分散存储在多个节点上，分布式存储可以方便地扩展存储容量和性能，以满足不断增长的数据需求。
高性能：通过将数据并行存储和访问，分布式存储可以实现高并发和低延迟的数据访问，提供快速的存储和检索能力。
分布式存储的应用场景 分布式存储广泛应用于以下场景：
大数据分析：分布式存储可以存储和处理大规模的结构化和非结构化数据，支持大数据分析和机器学习等应用。
云存储：云服务提供商使用分布式存储来存储用户的数据，并提供可靠的数据存储和备份服务。
分布式文件系统：分布式存储可以用于构建分布式文件系统，实现高性能和可扩展的文件存储和访问。
分布式存储的设计考虑因素 在设计分布式存储系统时，需要考虑以下因素：
数据切分和负载均衡：将数据切分成适当大小的块，并将块分散存储在不同的节点上，以实现负载均衡和提高性能。
数据一致性和容错性：保证多个节点上的数据一致性，并通过冗余备份来提高容错性和数据可用性。
数据访问和路由：设计有效的数据访问和路由机制，以实现快速的数据读写操作。
安全性：保护数据的安全性和隐私，采用合适的安全机制和加密技术。
Ambry 设计 设计特点 高可用性和水平可扩展性 Ambry 是一个高可用并且最终一致的系统。在大多数情况下，写入会写入本地数据中心，然后异步复制到其他数据中心。这确保在网络分区下，写入本地数据中心仍然可用。此外，当一台机器在本地不可用时，Ambry会选择同一数据中心内另一台机器上的另一个副本来读取或写入数据。对于读取，当数据不存在于本地数据中心时，它会将请求代理到具有blob的数据中心。
低运营开销 Ambry 的一个关键设计目标是使集群的操作变得非常容易。该系统是完全去中心化的，并配备了管理集群所需的所有工具。此外，大部分操作将在软件内自动进行，以确保维护集群所需的手动工作量非常少
低MTTR（平均修复时间） 这对于分布式系统来说非常重要。机器停机、磁盘故障、服务器崩溃和 GC 停止进程。所有这些故障在分布式系统中都是完全可以接受的故障。然而，关键是要在很短的时间内解决问题。在所有情况下，系统在维修期间都可以使用。 但是，保持较低的MTTR仍然很重要
双交叉DC 默认情况下，Ambry 支持主动主动设置。这意味着对象可以写入任何数据中心的同一分区，也可以从任何其他数据中心读取。这通常不是许多系统提供的通用功能。Ambry 通过复制以及在需要时将请求代理到远程数据中心来实现这一点。
适用于大型和小型媒体对象 大多数媒体流量由数万亿个小对象和数十亿个大对象组成。系统需要为这种混合工作负载正常运行。在Ambry中实现这一点的方式是将所有对象的写入合并到一个顺序日志中。这确保所有写入都是批处理并异步刷新，并且磁盘上的碎片非常少。
成本效益 最后，任何对象存储都需要长期存储媒体和数据类型。 随着时间的推移，较旧的数据会变冷并且读取QPS非常低。此外，对象通常很大并且占用大量空间。 设计应该能够启用JBOD，支持硬盘并将空间放大保持在最低限度。
技术架构 分区 Ambry 的核心抽象是blob块，一种用于存储数据的不可变结构。每个blob都分配给磁盘上的一个分区并通过blob ID进行引用。系统的用户通过执行put, get 和delete操作
数据分区设计可以自由扩展——当用户向系统添加更多数据时，它可以添加更多分区。默认情况下，新分区是可读写的 （意味着它同时接受 put, get，和 delete流量）。当分区接近容量时，它会转换为只读，这意味着它不再支持通过以下方式存储新的blob put操作。系统的流量往往以更新的内容为目标，从而给读写分区带来更高的负载
为了提供对blob 的可扩展读写访问，Ambry使用了三个高级组件：集群管理器（Cluster Managers）、前端层（Frontend Layer）和 数据节点（Datanodes）。
集群管理器 集群管理器决定如何跨地理分布式数据中心将数据存储在系统中，以及存储集群的状态,状态主要存储在Zookeeper中。例如，它们存储Ambry部署的逻辑布局，包括分区可读写还是只读，以及分区在数据中心磁盘上的位置
Clustermap 由两部分组成：
硬件布局：包含了机器的列表、每台机器上的磁盘以及每个磁盘的容量。布局还维护资源的状态（机器和磁盘）并指定主机名和端口，通过主机名和端口就能连接到数据节点；
分区布局：包含了分区的列表、它们的位置信息以及状态。在 Ambry 中，分区有一个数字表示的 ID，副本的列表可以跨数据中心。分区是固定大小的资源，集群间的数据重平衡都是在分区级别进行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93004781218bbb78809440501e8e5ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da410ef7d7191c9c46c13795d501ccd/" rel="bookmark">
			第十二课：eNSP OSPF协议教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录
第一课：eNSP第一个网络拓扑配置教程
第二课：eNSP vlan网络拓扑图配置教程
第三课：eNSP WIFI网络拓扑配置教程
第四课：eNSP 路由器路由配置拓扑教程
第五课：eNSP DHCP拓扑配置教程
第六课：eNSP 防火墙拓扑配置教程
第七课：eNSP 单臂路由/多臂路由拓扑配置教程
第八课：eNSP 链路聚合2种方式（手工模式和LACP模式）拓扑配置教程
第九课：eNSP VRRP虚拟路由冗余协议配置教程（防火墙双机热备）
第十课：eNSP 静态NAT/动态NAT/动态NAPT/Easy IP/静态NAPT 5种NAT配置教程
第十一课：eNSP ACL应用教程
一、知识点 1、OSPF等介绍 OSPF OSPF（Open Shortest Path First）协议是一种内部网关协议（IGP），用于在自治系统（AS）内部选择路由。它是一种链路状态路由协议，使用Dijkstra算法计算最短路径树。OSPF协议具有以下特点：
快速收敛：OSPF协议能够快速检测网络变化并更新路由表，确保路由的准确性。无路由环路：OSPF协议通过使用区域内路由和区域间路由的分层结构，以及使用区域间认证避免路由环路。支持多种路由形式：OSPF协议支持特定主机路由、子网路由、汇总路由等多种形式，以满足不同网络环境的需求。支持变长子网掩码（VLSM）：OSPF协议能够支持变长子网掩码，从而提高了IP地址空间的利用率。负载均衡：OSPF协议支持根据路径的带宽和延迟等参数进行负载均衡，以提高网络的利用率和可靠性。 在OSPF协议中，每个路由器维护一个链路状态数据库，记录了区域内所有路由器的连接状态和距离信息。当网络发生变化时，路由器会发送链路状态更新报文通知其他路由器，其他路由器则会根据这些更新信息重新计算最短路径树。
OSPF协议支持多播和广播类型的网络环境，可以通过多播报文进行路由信息的交换。此外，OSPF协议还支持区域划分，可以将大型网络划分为多个区域，每个区域运行一个OSPF实例，从而提高路由器的资源利用率和减少路由器的资源消耗。
自治系统（AS）
自治系统包括一个单独管理实体下所控制的一组路由器（OSPF 是内部网关路由协议，工作于自治系统内部）。
链路状态（LS）
指路由器接口的状态（如 Up 、Down 、IP 地址、网络类型、链路开销以及路由器和它邻接路由器间的关系）。
链路状态信息通过链路状态通告(Link State Advertisement, LSA) 扩散到网络上的每台路由器，每台路由器根据 LSA 信息建立一个于千网络的拓扑数据库（邻居表）。
最短路径优先算法(SPF)=迪克斯加算法(Dijkstra)
利用从 LSA 通告得来的信息计算到达每一个目标网络的最短路径，以自身为根生成一棵树，包含了到达每个目的网络的完整路径。
路由器标识
OSPF 的路由标识是一个 32 位的数字，它在自治系统中被用来唯一地识别路由器。
默认使用最高回环地址（loopback），若回环地址没有被配置，则使用物理接口上最高的IP地址作为路由器标识。
邻居和邻接
OSPF 在相邻路由器间建立邻接关系，使它们交换路由信息。
邻居是指共享同一网络的路由器，并使用Hello包来建立和维护邻居路由器间的邻接关系。
区域
在OSPF网络中使用区域(Area)为自治系统分段。
OSPF是一种层次化的路由选择协议，区域 0是一个 OSPF 网络中必须具有的区域，也称为主干区域，其他所有区域要求通过区域0互连到一起。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da410ef7d7191c9c46c13795d501ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0169495f45c6bdb080b0170c5261c884/" rel="bookmark">
			前端性能优化三十九：花裤衩模板gzip的webpack配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置: (1). 安装插件:
①. 安装 compression-webpack-plugin: yarn add compression-webpack-plugin@6.1.1 -D ②. 新版本 7.x 会报错: a. Cannot read property 'tapPromise' of undefined (2). 在 vue.config.js 中配置:
const CompressionPlugin = require('compression-webpack-plugin'); module.exports = { chainWebpack(config) { ... // 方式一: config .when(process.env.NODE_ENV === 'production', config =&gt; { config .plugin('compression') .use(CompressionPlugin) .tap(() =&gt; [{ test: /\.js$|\.html$|\.css$/, // 匹配文件名,开启js、css压缩 filename: '[path].gz[query]', // 压缩后的文件名(保持原文件名,后缀加.gz) minRatio: 1, // 压缩率小于1才会压缩 threshold: 10240, // 对超过10k的数据压缩 deleteOriginalAssets: false // 是否删除未压缩的源文件(不设置或设置为false) // 保留非gzip的资源,删除打包后的gz后还可以加载到原始资源文件,建议不要设置为true }]) } ) // 方式二: if (process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0169495f45c6bdb080b0170c5261c884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8168eb31c85d8902845bd3dc8d4a933/" rel="bookmark">
			最优化建模算法理论之Armjio准则（数学原理及MATLAB实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Armjio准则1. 定义2. 几何含义 三、代码实现三、输出示例四、附 一、前言 为了防止迭代过程中函数值 f ( x k ) f(x^k) f(xk) 的下降量不够充分，以至于算法无法收敛到极小值点，必须引入一些更合理的线搜索准则来确保迭代的收敛性。
Armijo 准则是一个常用的线搜索准则，引入 Armijo 准则的目的是保证每一步迭代充分下降。
二、Armjio准则 1. 定义 设 d k d^k dk 是点 x k x^k xk 处的下降方向，若
f ( x k + α d k ) ≤ f ( x k ) + c α ∇ f ( x k ) T d k (1) f(x^k + \alpha d^k) \le f(x^k) + c\alpha \nabla f(x^k)^Td^k \tag{1} f(xk+αdk)≤f(xk)+cα∇f(xk)Tdk(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8168eb31c85d8902845bd3dc8d4a933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b28abbdb6b17f276e8aae185db5303e/" rel="bookmark">
			VUE2 预览pdf文件（文件来源与后端篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF 预览。用到了 pdfjs 注意 作者这里的版本 “pdfjs-dist”: “^2.16.105” 安装依赖
npm i pdfjs-dist -D &lt;template&gt; &lt;div&gt; &lt;h1&gt;查看PDF文件&lt;/h1&gt; &lt;input type="button" value="请求文件" ref="inputpdf" @click="selectPdf" /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;el-row justify="center"&gt; &lt;el-col :span="24"&gt; &lt;el-pagination layout="prev, pager, next" small background :total="pdfPagesNum" @current-change="currentChange" /&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;br /&gt; &lt;canvas ref="renderContext"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as PDFJS from "pdfjs-dist/legacy/build/pdf"; // 引入PDFJS import pdfjsWorker from "pdfjs-dist/legacy/build/pdf.worker.entry.js"; // 引入workerSrc的地址 PDFJS.GlobalWorkerOptions.workerSrc = pdfjsWorker; //设置PDFJS.GlobalWorkerOptions.workerSrc的地址 import axios from 'axios' export default { data() { return { pdfPagesNum: 0, pdfUrl: '', readerpdfDoc: null } }, methods: { selectPdf() { // 这里的文件是 本地用nginx代理的静态文件， 注意文件返回格式一定需要设置为 blob let url = 'http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b28abbdb6b17f276e8aae185db5303e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3164bb732a5cd7457db15f51e27c7be1/" rel="bookmark">
			51job数据采集与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 对于数据挖掘与机器学习领域而言，模型与数据是最重要的，但原始数据非常稀缺。爬虫的诞生，实现了自动化、快速、批量地收集数据的目的。网络爬虫又称为网络蜘蛛，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。爬虫要实现三个基本功能：获取网页（收集数据）、解析网页（提取数据）、存储数据。
现在就业形势愈加严峻，掌握一手就业信息越来越重要，51job是一个非常庞大就业网站，就业信息齐全，就业岗位多，深受广大就业者喜爱。
2、技术工具介绍 2.1、requests模块 Requests模块是Python的第三方模块，它的诞生主要是为了解决urllib和urllib2等内置模块在使用上不够简洁的问题。它支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码等。
2.2、selenium框架 Selenium是一个用于Web应用程序自动化测试的工具，它可以模拟用户在浏览器中的操作，如跳转、输入、点击、下拉等。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。Selenium可以完全模拟浏览器的操作，从而获取网页渲染之后的结果，这使得爬取动态页面变得更加容易。
3.3、undetected_chromedriver框架 undetected_chromedriver是一个用于绕过Web自动化中ChromeDriver检测的Python库。它提供了更好的隐匿性和稳定性，适用于多种场景。可以适用于：Web自动化测试、网页数据爬取和反爬虫绕过等。
3.爬虫程序设计 3.1爬取内容要求 爬取三组信息，分别是以“数据开发、机器学习、数据仓库、数据架构师”，“审计、法务、会计、风控”和“人力资源、销售、商务、团队经理”为关键词，每组需要爬取五万至十万条信息。采集的岗位信息包括招聘专业、岗位工作、薪资、工作地点等不少于10个特征信息。
3.2网站反爬介绍 3.2.1headers反爬 headers反爬是非常经典的反爬技术，51job会通过检查请求headers来区分浏览器行为和机器行为。一些网站会对Referer（上级链接）进行检测，从而实现爬虫的识别。
3.2.2滑动验证反爬 滑动验证反爬通常通过识别并阻止自动化的机器行为来保护网站数据。当一个请求看起来像是机器行为时，滑动验证就会触发，要求用户完成一个滑动操作以证明他们是人类。
图3-1滑动验证图
3.3网站爬虫分析 3.3.1爬取数量分析 观察51job网站，每一个关键字搜索只能看到50页1000条信息，显然无法满足五万条数据要求，我们可以通过切换城市、工作要求去搜索到更多信息，已满足对数据量的要求。
3.3.2URL分析 通过观察存储二级页面JSON数据的URL(Uniform Resource Locator)，我们可以发现URL存在规律。我们通过两个URL进行分析。
不加任何条件限制的URL:
https://we.51job.com/api/job/search-pc?api_key=51job&amp;timestamp=1703410615&amp;keyword=%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91&amp;searchType=2&amp;function=&amp;industry=&amp;jobArea=000000&amp;jobArea2=&amp;landmark=&amp;metro=&amp;salary=&amp;workYear=&amp;degree=&amp;companyType=&amp;companySize=&amp;jobType=&amp;issueDate=&amp;sortType=0&amp;pageNum=1&amp;requestId=&amp;pageSize=20&amp;source=1&amp;accountId=&amp;pageCode=sou%7Csou%7Csoulb
加条件限制的URL: https://we.51job.com/api/job/search-pc?api_key=51job&amp;timestamp=1703410759&amp;keyword=%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91&amp;searchType=2&amp;function=&amp;industry=&amp;jobArea=000000&amp;jobArea2=&amp;landmark=&amp;metro=&amp;salary=06&amp;workYear=02&amp;degree=04&amp;companyType=&amp;companySize=&amp;jobType=&amp;issueDate=&amp;sortType=0&amp;pageNum=5&amp;requestId=553854ded0575e0fedc753f1937fee8d&amp;pageSize=20&amp;source=1&amp;accountId=&amp;pageCode=sou%7Csou%7Csoulb
我们可以发现第二个URL与第一个URL的timestamp、salary、workYear、degree和pageNum有不同。我们可以根据些获取更多的URL，已获取更多的岗位信息。
3.2.3滑块验证分析 通过图3-1可以知道，我们首先将鼠标放置验证块头部，最后使用鼠标将滑块拖到尾部，但简单两步容易被检测出来，我们可以在中间的过程中将鼠标放置中间的位置，加上睡眠时间，更不容易被检测不来，通过人机验证。
3.2.4获取数据及存储 通过获取二级页面的数据是JSON数据，我们通过层层获取可以得到我们需要的信息，将数据存储到字典，最终将数据存放到CSV文件。
图3-2二级页面数据图
3.2.5破解滑块 # 测试滑块 import sys import time from selenium.webdriver.support.wait import WebDriverWait from pynput.mouse import Button, Controller as c1 import undetected_chromedriver as uc driver = uc.Chrome() driver.get('https://we.51job.com/api/job/search-pc?api_key=51job&amp;timestamp=1703000707&amp;keyword=%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91&amp;searchType=2&amp;function=&amp;industry=&amp;jobArea=000000&amp;jobArea2=&amp;landmark=&amp;metro=&amp;salary=&amp;workYear=&amp;degree=&amp;companyType=&amp;companySize=&amp;jobType=&amp;issueDate=&amp;sortType=0&amp;pageNum=1&amp;requestId=&amp;pageSize=20&amp;source=1&amp;accountId=231574473&amp;pageCode=sou%7Csou%7Csoulb') mouse = c1() driver.maximize_window() wait = WebDriverWait(driver, 10) time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3164bb732a5cd7457db15f51e27c7be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0143104f21e0117de60429c7918b43/" rel="bookmark">
			VUE框架Vue3下使用ref函数包裹的对象实现响应式处理------VUE框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;h1&gt;{{ userRefImpl.name }}&lt;/h1&gt; &lt;h1&gt;{{ userRefImpl.age }}&lt;/h1&gt; &lt;h1&gt;{{ count }}&lt;/h1&gt; &lt;h1&gt;{{ userRefImpl.addr.city }}&lt;/h1&gt; &lt;h1&gt;{{ userRefImpl.addr.street }}&lt;/h1&gt; &lt;button @click="modifyUser"&gt;修改&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import {ref} from 'vue'; export default { name : "App", // setup(){ // // data // // 如果这里是一个对象,默认也是没有响应式处理的 // let user = { // name : "Jack", // age : 20 // }; // // methods // function modifyUser(){ // user.name = "Rose"; // user.age = 30; // } // // 返回对象 // return {user,modifyUser}; // } setup(){ // 我们这里的是一个对象 // 这里的ref代理对象因为操作的是对象,底层即会提供get和set用于修改该对象 // 这里的get和set方法是通过Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b0143104f21e0117de60429c7918b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3c244414bff280785814139b684fef/" rel="bookmark">
			redis启动报错-磁盘满了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 imjournal: fopen() failed for path: ‘/var/lib/rsyslog/imjournal.state.tmp’: Structure needs cleaning [v8.24.0-57.el7_9.1 try http://www.rsyslog.com/e/2013 ]
1.查看服务状态 systemctl status rsyslog 2.尝试重启服务 systemctl restart rsyslog 3.查看分区占用情况 df -h /var/lib/rsyslog 4. # 重装rsyslog rm -rf /var/log/messages yum reinstall rsyslog (可能出错,继续执行下面命令，返回执行重装) 5. 删除原rdb文件 rm -f /var/lib/rpm/__db* 6. 重建rpm数据库 rpm --rebuilddb 7. 清除yum缓存 yum clean all 8. 重装rsyslog 9. systemctl status rsyslog 问题解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cbade6010f63b436f4589515acd4ed/" rel="bookmark">
			在centos服务器中完成jdk，tomcat，MySQL的安装以及前后端分离项目中后端的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. jdk，tomcat的安装
1.将要安装的软件压缩包放入到centos服务器上
2. 解压对应的安装包
3. jdk环境变量配置
4. tomcat启动
5. 关闭防火墙
二. MySQL安装
1. 卸载mariadb，否则安装MySql会出现冲突(先查看后删除再查看)
2. 将MySQL安装包解压到指定目录
3. 开始安装，-ivh 其中i表示安装，v表示显示安装过程，h表示显示进度 4. 启动MySQL服务
5. 登录MySQL修改密码
三. 后端接口部署
一. jdk，tomcat的安装 1.将要安装的软件压缩包放入到centos服务器上 2. 解压对应的安装包 ##解压jdk
tar -zxvf jdk-8u151-linux-x64.tar.gz（输入jdk后tab键补全）
##解压tomcat tar -zxvf apache-tomcat-8.5.20.tar.gz（apache后tab键补全）
3. jdk环境变量配置 #配置环境变量
vim /etc/profile
#java environment
export JAVA_HOME=/root/xissl/software/jdk1.8.0_151/ （jdk解压路径）
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
#设置环境变量生效
source /etc/profile
4. tomcat启动 ./startup.sh 注意要进入到bin目录下
cd .. 进入根目录
5. 关闭防火墙 在防火墙开启的情况下，外部服务器是无法访问内部服务器的，需要将它关闭。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1cbade6010f63b436f4589515acd4ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf04640bfccc12bde2bcaa2bc9b9217/" rel="bookmark">
			关于linux mv指令机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在mv文件的时候，操作失误将生产服务器一个1TB的文件夹mv到了/opt/test目录，因为最后/opt/目录被沾满所以1TB的文件夹没有迁移过来，写入了30GB数据到了/opt/test目录，因为系统分区被沾满，所以把test目录给删除了。
那么问题就来了，1TB的源目录哪些文件被mv到了/opt/test目录中，因为/opt/test/目录被删除无法进行判断，查看生产系统都正常没有发现数据丢失。
在测试服务器上进行实验，测试将大量数据mv到小于该数据容量硬盘会发生什么现象。新建一个5GB的硬盘，将root目录中的数据（远大于5GB）mv到这个5GB硬盘中.
执行 mv /root /mnt,在mv的过程中，发现源盘的容量没有减少，但是目标盘的数据量不断在增加，指导目标目录空间被沾满，源盘的数据都没有减少。
所以鉴于上面的实验可以得知，在mv数据的时候，mv指令因为目标目录被沾满而未完成mv操作，不会对源目录的数据进行删除操作，只是将源目录中的数据写入到目标目录中。
下面通过strace跟踪mv执行过程。
情况A，mv单个文件，在根目录创建文件“1”，写入数据“111111111111111”，然后mv“1”文件到/mnt目录。通过下面可以知道在数据写入完成后，然后unlink掉源文件“1”
情况B，如果mv整个目录，目录中包含多个文件，那么是mv完成单个文件后就删除对应的源文件，还是mv完成整个目录后，再删除源文件及目录？
创建文件夹mvdata3，写入6个测试文件
执行mv /root/mvdata3 /mnt。
通过上面截图可知，首先判断目标目录/mnt中有没有mvdata3目录及对应所需mv的文件；第二步打开源文件并将数据写入到目标文件。可以看到在文件“1”完成写入后，没有对文件“1”进行unlink操作，而是继续mv文件“2”，依次类推，知道文件“6”。
在文件“1”到文件“6”全部写入完成后，通过strace看到最后删除文件及目录
所以通过上面strace跟踪mv执行可以得出结论，mv操作是在完成所有数据写入后，再执行的删除源文件动作。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>