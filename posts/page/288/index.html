<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3681d986d84e563a94eb5210a622bf9e/" rel="bookmark">
			BUUCTF之[WUSTCTF2020]朴实无华 --------------- MD5碰撞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动挑战页面
访问一下robots.txt看看有没有什么提示
发现有个可疑的链接：/fAke_f1agggg.php
到这里就可以看到重要的源码了
&lt;img src="/img.jpg"&gt; &lt;?php header('Content-type:text/html;charset=utf-8'); error_reporting(0); highlight_file(__file__); //level 1 if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021){ echo "鎴戜笉缁忔剰闂寸湅浜嗙湅鎴戠殑鍔冲姏澹�, 涓嶆槸鎯崇湅鏃堕棿, 鍙槸鎯充笉缁忔剰闂�, 璁╀綘鐭ラ亾鎴戣繃寰楁瘮浣犲ソ.&lt;/br&gt;"; }else{ die("閲戦挶瑙ｅ喅涓嶄簡绌蜂汉鐨勬湰璐ㄩ棶棰�"); } }else{ die("鍘婚潪娲插惂"); } //level 2 if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo "鎯冲埌杩欎釜CTFer鎷垮埌flag鍚�, 鎰熸縺娑曢浂, 璺戝幓涓滄緶宀�, 鎵句竴瀹堕鍘�, 鎶婂帹甯堣桨鍑哄幓, 鑷繁鐐掍袱涓嬁鎵嬪皬鑿�, 鍊掍竴鏉暎瑁呯櫧閰�, 鑷村瘜鏈夐亾, 鍒灏忔毚.&lt;/br&gt;"; else die("鎴戣刀绱у枈鏉ユ垜鐨勯厭鑲夋湅鍙�, 浠栨墦浜嗕釜鐢佃瘽, 鎶婁粬涓€瀹跺畨鎺掑埌浜嗛潪娲�"); }else{ die("鍘婚潪娲插惂"); } //get flag if (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag," "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3681d986d84e563a94eb5210a622bf9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8a09317435a45cb1f91ab31c8fe38c/" rel="bookmark">
			微信小程序搜索不到腾讯服务路线规划插件的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体操作如下： 提示：主要内容都是按开发文档来写的
开发文档： 链接：
https://lbs.qq.com/miniProgram/plugin/pluginGuide/routePlan 添加插件 https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wx50b5593e81dd937a 在这里可以添加，就不需要在后台添加插件了，好像在微信公众平台上直接搜是找不到的。所以可以直接上面链接里面添加，可以解决问题。
这个页面是在设置-&gt;第三方设置-&gt;添加插件
app.json文档更改 插件导入 根据文档，在app.json上面添加
{ "plugins": { "routePlan": { "version": "1.0.13", "provider": "wx50b5593e81dd937a" } } } 权限设置 { "permission": { "scope.userLocation": { "desc": "你的位置信息将用于小程序定位" } } } 插件使用 记得填入key和referer，然后填入endPoint和startPoint。 let plugin = requirePlugin('routePlan'); let key = ''; //使用在腾讯位置服务申请的key let referer = ''; //调用插件的app的名称 let endPoint = JSON.stringify({ //终点 'name': '吉野家(北京西站北口店)', 'latitude': 39.89631551, 'longitude': 116.323459711 }); wx.navigateTo({ url: 'plugin://routePlan/index?key=' + key + '&amp;referer=' + referer + '&amp;endPoint=' + endPoint }); 相关参数参考文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8a09317435a45cb1f91ab31c8fe38c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667e027f15cff534a06f3a4f6c4c5ee0/" rel="bookmark">
			❤️ 【STL 序列式容器】 vector 超硬核源码剖析 ❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言第4章 序列式容器4.1 容器的概念与分类4.1.1 序列式容器 4.2 vector4.2.1 vector概述4.2.2 vector定义摘要4.2.3 vector的迭代器4.2.4 vector的数据结构4.2.5 vector的构造与内存管理4.2.6 vector的元素操作 前言 国庆七天假宛如一天假，定睛一看又要上班…
国庆档电影院热闹了不少，《长津湖》真的值回票价，吴京真不错，意外的是易烊千玺竟然演出了小戏骨的感觉，整部电影很有感染力，点赞！
外滩一如既往的人山人海，不过每次抱着去看人的心态还是能玩得开心的，节日就要有节日的氛围。
总之，国庆快乐最重要！也祝各位节日快乐！祖国生日快乐！ ❤️
❤️❤️❤️ 如果本文对你有所帮助，请不要忘了点赞、关注、收藏哦！灰常感谢！ ❤️❤️❤️
第4章 序列式容器 4.1 容器的概念与分类 容器，置物之所也。
研究数据的特定排列方式，以利于搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构（Data Structures）。大学信息类相关教育里面，与编程最有直接关系的科目，首推数据结构与算法（Algorithms）。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL 容器即是将运用最广的一些数据结构实现出来（图4-1）。未来，在每五年召开一次的C＋＋标准委员会的会议中，STL容器的数量还有可能增加。
众所周知，常用的数据结构不外乎array（数组）、list（链表）、tree（树）、stack（堆栈）、queue（队列）、hash table（散列表）、set（集合）、map（映射表）···等等。根据“数据在容器中的排列”特性，这些数据结构分为序列式（sequence）和关联式（associative）两种。本章探讨序列式容器，下一章探讨关联式容器。容器是大多数人对STL的第一印象，这说明了容器的好用与受欢迎。容器也是许多人对STL 的唯一印象，这说明了还有多少人利器（STL）在手而未能善用。
这里所谓的衍生，并非派生（inheritance）关系，而是内含（containment）关系。例如 heap内含一个 vector，priority-queue 内含一个 heap、stack 和 queue 都含一个deque，set／map／multiset／multimap 都内含一个 RB-tree，hast＿x 都内含一个hashtable。
4.1.1 序列式容器 4.2 vector 4.2.1 vector概述 vector 的数据安排以及操作方式，与 array非常相似。两者的唯一差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector 的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始就要求一个大块头 array了，我们可以安心使用vector，吃多少用多少。vector的实现技术,关键在于其对大小的控制以及重新配置时的数据移动效率。一旦 vector旧有空间满载,如果客户端每新增一个元素, vector内部只是扩充一个元素的空间,实为不智,因为所谓扩充空间(不论多大),一如稍早所说是“配置新空间/数据移动/释还旧空间”的大工程,时间成本很高,应该加人某种未雨绸缪的考虑。稍后我们便可看到 SGI vector的空间配置策略。
4.2.2 vector定义摘要 以下是 vector定义的源代码摘录。虽然STL规定,欲使用 vector者必须先包括&lt; vector&gt;,但 SGISTL将 vector实现于更底层的&lt;stl_ vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667e027f15cff534a06f3a4f6c4c5ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a385824cf128c94fb39b72e2876d6e8/" rel="bookmark">
			javascript百炼成仙 第一章 掌握JavaScript基础1.6 叶老
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一日，叶小凡来到青山院附近的小山上修炼，忽然，被一块石头绊了一跤。正在他自认倒霉打算爬起来的时候，在石头缝里边发现了一枚古怪的戒指。戒指通体呈现一种枯黄色，似有一些年代悠久之感。
“摔了一跤，捡到一个戒指，算是补偿吧，虽然这戒指应该也没什么用。”叶小凡随手拿起戒指，戴在了手上。就在这时，一股神秘的力量从叶小凡丹田之处涌了上来，似乎自己忽然置身于一种奇妙的空间之中。
“哈哈哈，小娃娃，没想到我叶老被封印了上千年，今天托你的福终于重见天日啦！咦，你的修为怎么这么低，竟然连幼儿园的水准都没有！罢了罢了，从今以后就由我来教导你，你最好给我尽快达到到大学的修为，这样我就可以真正地自由啦！”
叶小凡被这突如起来的声音吓了一跳，惊慌地喊道：“怎么回事，你是谁，你想干什么？”
“我是叶老，几千年前是这片脚本大陆的最强者，只不过不小心遭人暗算，才被封印到了这枚戒指中。小娃娃，你现在的修为太低了，等你到了大学境界，才能有办法把我放出来，我也就自由了。小娃娃， 你放心，你把我放出来后我绝对不会亏待你的。跟着我，包你从今往后吃香的喝辣的。哎呀，小娃娃，你干什么，快住手，快住手！”
叶小凡虽然谨慎，愿意吃苦，但是到底没有遇到过这么离奇的事情。戒指里面封印着这片大陆的最强者，这听起来实在是有些天方夜谭了。莫不是妖怪，嗯，对了，一定是妖怪！赶紧扔，赶紧扔！
“这不是真的，我一定是在做梦，妖怪爷爷，你可别来找我啦！”说着，叶小凡扬起他那只白粉的小手，手心里攥着那枚刚捡来的戒指，就要扔到悬崖下边去。
“小娃娃，你快住手啊，我说的是真的，我可不是什么妖怪，我是叶老啊。哎呀呀，我好不容易等来一个人，这么多年都等下来了，你这要是一扔，我又不知道要等到猴年马月才有希望出来啊！”叶老这下真的急了，语气丝毫没有了之前的从容和兴奋，有的只是惊慌和无奈。
“哼，你还嘴硬，还说不是妖怪，你当我傻啊。大学境界，那是传说中才有的境界。根本没有人可以修炼得到。我们宗门的太上大长老，也不过是高中境界。可即便是这样，那也是一手遮天的能力了。看我不扔了你。”说着，叶小凡又要仍。
“哎呀呀，好了好了，我不说了好不。对，小娃娃，你来问我问题啊，在这片大陆，JavaScript的功法和心得，还没有什么可以问倒我的。”叶老都要哭了，真没想到自己好不容易有了复活的希望，马上就要泡汤，能不能不带这么刺激的呀。
叶小凡听到这话，愣了一下，心想难道这是真的？可转念一想，天知道这个老妖怪在打什么主意，还是扔了好，扬起手又要仍。
“小娃娃，你可知道对象数据类型？”叶老吼道。
下一节: javascript百炼成仙 第一章 掌握JavaScript基础1.7 对象数据类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473f86fc0226513d903ea931f4d89957/" rel="bookmark">
			CSDN如何查看自己的博客积分？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法是进入后台，然后点击内容管理-作品数据
下面是我目前的积分：
注意，这个积分和下载的积分好像不是一个积分，我之前也是傻傻分不清楚。这个积分是用来做博客排名的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceccc27d912782fe6925dd74b9865574/" rel="bookmark">
			Android Studio欢迎界面和登陆界面的设计（小白）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学校开设了Android Studio的开发课程，跟着书上的例子和小破站的视频开启了安卓小白之旅，今天主要整理了一下"欢迎界面"和"登陆界面"的相关内容。
首先新建一个项目，按照自己的需求命名项目
欢迎界面 新建一个类，命名为Splash
欢迎界面的页面布局 在layout中新建一个activity_splash.xml文件，
需要首先在drawable文件夹下导入main_button_3图片，字体颜色可以自己按照喜好设计
activity_splash.xml布局设计如下
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:gravity="center" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="@drawable/main_button_3" &gt; &lt;TextView android:id="@+id/textView" android:layout_marginTop="20dp" android:layout_marginLeft="80dp" android:layout_width="210dp" android:layout_height="wrap_content" android:text="我们的征途是星辰大海" android:textColor="@color/royalblue" android:textSize="40sp" android:textStyle="bold" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 效果如图
Splash.java中代码如下：
package com.example.chwngyanan.qxapp.activity; import android.content.Intent; import android.os.Bundle; import android.support.annotation.Nullable; import android.support.v7.app.AppCompatActivity; import com.example.chwngyanan.qxapp.MainActivity; import com.example.chwngyanan.qxapp.R; import java.util.Timer; import java.util.TimerTask; /** * Created by CHWNGYANAN on 2021/9/20. */ public class Splash extends AppCompatActivity{ @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceccc27d912782fe6925dd74b9865574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4915ab8a9e96c3dce8bd6e49eccc3234/" rel="bookmark">
			IntelliJ IDEA 如何添加编译参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如，我们希望添加下面的编译参数到我们的一个 IntelliJ IDEA 项目中：
--add-exports java.base/jdk.internal.vm.annotation=ALL-UNNAMED 例如我们可以通过在项目的配置路径中进行添加，添加的模块和参数请参考上图。
IntelliJ IDEA 如何添加编译参数 - Java - OSSEZ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a77532d8af05690f56e1fc7e276d8a1/" rel="bookmark">
			INT_MAX和INT_MIN的含义和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 INT_MAX = 2^31-1，INT_MIN= -2^31.
可以看出是一个相当大的数和一个相当小的数，如果想要得到数组中最小值，可以先将最小值赋值为INT_MAX ；同理如果想要得到数组中最大值，可以先将最大值赋值为INT_MIN ；
int min=INT_MAX; int max=INT_MIN; for(int j=0;j&lt;n;j++){ if(a[i]&lt;min){min=a[i];} } for(int j=0;j&lt;n;j++){ if(b[i]&gt;max){max=b[i];} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131172321496f0e6343162ede18aaec3/" rel="bookmark">
			java单例设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是单例模式 采取一定方法使类只有一个对象实例，设计一个方法才能获取该对象实例。
二、饿汉模式 特点：
构造函数私有化，使外部不能随便实例化对象在类内部创建静态对象创建一个静态方法使外部可以获得实例对象 示例：
package com.hb.single_; public class SingleTon01 { public static void main(String[] args) { GirlFriend girlfriend=GirlFriend.getInstance(); System.out.println(girlfriend); } } class GirlFriend{ private String name; //构造器私有化 private GirlFriend(String name){ this.name=name; } //类内创建对象 private static GirlFriend girlfriend=new GirlFriend("小红"); //提供外部获得对象的方法 public static GirlFriend getInstance(){ return girlfriend; } } 为什么类里的getInstance方法要设计成static方法？
因为我们不能从外部创建这个对象来调用方法，只能通过类名来调用。
为什么要在内部创建静态对象？
因为要让外部获取实例对象，但是获取方法getInstance是静态方法，所以该对象也得是静态。
为什么这种设计模式叫饿汉模式？
因为它在类加载时就创建了对象实例
三、懒汉模式 特点：与饿汉模式不同的是，它并没有在加载类时就创建对象实例，而是在返还对象实例的那个静态方法中才能创建对象实例。
package com.hb.single_; public class SingleTon02 { public static void main(String[] args) { Cat cat=Cat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131172321496f0e6343162ede18aaec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9383b2f2c9946f0e4eb482ef8fa1e2d/" rel="bookmark">
			java关键字final和抽象类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、final关键字 final可以修饰类，表示该类不可被继承final可以修饰属性，表示一个常量，并且必须赋值，可以直接赋值，或者在构造器和代码块中赋值如果修饰的是static属性，那么只能在定义时和静态代码块中赋值，因为静态final属性在类加载就要被赋值。final可以修饰方法，表示不可被重写，但是可以继承的，如果一个类是final类，他的方法可以不用final修饰，因为类不能继承，同样方法也重写不了final也可以修饰方法里的局部变量final不能用来修饰构造函数final可以与static一起用效率更高，不会导致类加载，比如类里有个静态属性，如果你想单纯地使用它，但是又不想加载类，就可以用final修饰这个属性。 二、抽象类 定义：当父类中的一些方法不知如何实现时，我们可以用abstract修饰这个方法，这个方法就叫抽象方法，该类叫抽象类。抽象类主要价值在于设计，好让子类继承去实现这个抽象类。
语法：
1、抽象类：【访问修饰符】abstract class 类名{
}
2、抽象方法：【访问修饰符】abstract 返回类型 方法名（）;
==注意：抽象方法无方法体
细节：
抽象类不能实例化抽象类可以没有抽象方法。但如果有抽象方法，类必须用abstract修饰成抽象类如果一个类继承了抽象类，那么它必须实现抽象方法，或者自己声明为抽象类。抽象方法不能用private、final、static修饰，这些关键字是与重写相违背的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6739d76a82e9eebee076db4d62dbd3/" rel="bookmark">
			java代码块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代码块的使用 当一个类有多个构造函数，并且构造函数都有相同的语句，可以将这些语句放入一个代码块中，提高代码重用。代码块就相当于另一种构造器的形式。
1、语法：【static】{
语句
}；
2、分类：代码块分为静态代码块和普通代码块
二、静态代码块和普通代码块区别 static代码块随着类的加载而执行，而且只会执行一次。普通代码块则随着对象的创建而执行，每创建一次对象，就执行一次。 什么时候类会被加载：（可能不单单以下情况，其他情况还未去了解）
创建对象实例时创建子类对象时，父类也会被加载使用静态成员时 三、创建子类时类的调用顺序 1.父类静态变量初始化和静态代码块被调用（优先级一样，看代码顺序）：创建一个子类对象，首先加载父类信息，因为静态属性会随类的加载被初始化，静态代码块随类的加载而被调用。
2.子类静态变量初始化和静态代码块被调用（优先级一样，看代码顺序）：父类加载完后，就开始加载子类，所以静态属性会被初始化，静态代码块被调用。
3.父类普通变量初始化和普通代码块被调用（优先级一样，看代码顺序）：子类加载完后，在堆里分配完空间，就会开始使用构造器初始化，但是构造器里前两句其实隐含了super() 和 调用普通代码块与普通变量初始化，所以开始执行父类的构造函数，同时父类构造函数也隐含了这两句，但是父类的super()可能是object类的构造函数，所以也看不出来调用，所以执行父类普通变量初始化和调用普通代码块。
4.父类构造函数：父类执行构造函数隐含的前两句后，因为还处于构造函数中，所以执行剩余的构造语句。
5.子类普通变量初始化和普通代码块被调用（优先级一样，看代码顺序）：子类构造函数隐含的第一句super()被执行后就开始执行第二句，子类普通变量初始化和调用普通代码块。
6.子类构造函数：子类执行构造函数隐含的前两句后，因为还处于构造函数中，所以执行剩余的构造语句。
package com.hb.CodeBlock; public class codeBlockDetail { public static void main(String[] args) { new B02(); } } class A02 { //父类 private static int n1 = getVal01();//静态属性的初始化 static { System.out.println("A02 的一个静态代码块.."); } { System.out.println("A02 的第一个普通代码块.."); } public int n2 = getVal02();//普通属性的初始化 public static int getVal01() { System.out.println("静态属性n1被初始化"); return 10; } public int getVal02() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b6739d76a82e9eebee076db4d62dbd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad8b78c06f3a4291eb412f93dde6587/" rel="bookmark">
			int、long、long long ,double等的范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int 最大值：2147483647 int 最小值：-2147483648 float 最大值：3.40282e+38 float 最小值：1.17549e-38 double 最大值：1.79769e+308 double 最小值：2.22507e-308 long 最大值：9223372036854775807 long 最小值：-9223372036854775808 long long 最大值：9223372036854775807 long long 最小值：-9223372036854775808 unsigned long long 最大值：18446744073709551615 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ca6c6b7b768119f62e09a47fb29c71/" rel="bookmark">
			a.erase(unique(a.begin(),a.end()),a.end())；容器元素去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unique()函数，处理连续的有重复元素，比如 -2 -2 -2 1 2 -2 2 就处理成了 -2 1 2 -2 2 -2 -2并且返回5，之后eraser(5,7)剩下了 -2 1 2 -2 2 .
因此在使用unique函数之前先使用sort函数进行排序。然后将unique函数返回的值和容器末尾的区间用eraser函数抹除，就完成了去重。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e85929eba81b0b5d6b3d474cad128e/" rel="bookmark">
			runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012c (stl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这种的原因是由于下标出现了小于零的-1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7accd2882598656627083d1e52cfcfea/" rel="bookmark">
			windows WSL 文件存储位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.变量 windows提供了一个变量\\wsl$来显示wsl下所有running状态分发的目录
2.实际位置 在我的电脑上，分发的根目录位于当前用户目录的AppData下：
C:\Users\czy\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState
一个Ubuntu20.04文件系统大小为1.1GB左右
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c326a430057be895d46d3c89519b7c49/" rel="bookmark">
			武汉好地科技从五个维度分析CMMI 2.0与1.3的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMMI V2.0 是一套经过验证的全球最佳实践，旨在应对不断变化的全球业务环境的挑战，通过建设关键能力并对其进行基准评估来推动业务性能。
CMMI V2.0 的核心是一套经过验证的全球最佳实践，由可提高业务性能的重要业务能力所组织而成。这些重要能力解决了任何组织通常面临的最大挑战，包括：
●产品工程设计和开发
●提高性能
●交付和管理服务
●维持习惯性和持久性
●管理业务弹性
●规划和管理工作
●选择和管理供应商
●确保质量
●管理员工
●支持实施
区别于CMMI V1.3，CMMI V2.0的变化包括：
一、CMMI 2.0聚焦绩效
全新的绩效实践包含在CMMI模型的所有成熟度等级中，强化与关注组织绩效的提升，以明晰在ROI上。
这也反映出现代商业环境中，无论他们的成熟度等级如何，绩效都是每个组织取得成功的核心。组织可以利用已经内置在CMMI V2.0模型全部等级中的绩效部分，作出更有条例、步步为营的计划，实现更佳的绩效表现与高成熟度。
CMMI 1级建立在解决基础的绩效问题上。这里所说的绩效，随着CMMI不同级别的实践而变化，CMMI 2级的实践包含CMMI 1级，从CMMI3级开始直到CMMI 5级，所有的实践都建立在下面所有的等级之上，并且加深了程度。
绩效的改进汇报，通过CMMI等级评估，将更有效的呈现出组织绩效改进的意识。
二、改进的适用与集成指南
CMMI V2.0建立在弹性的架构之上，这使得CMMI V2.0可以为支撑组织特定商业需求，而需无缝集成其他管理办法、措施而提供指导。
目前，CMMI Development V2.0囊括了帮助企业实践敏捷开发方法、增强敏捷过程、衡量敏捷实践的特别指南。其他增加的内容还包括安全、保障及其他后续推出的部分。
CMMI 1级所包含的实践可以让新成立的组织取得增量进步，实现早期的商业成功。可供选择的在线平台，使得选取、访问CMMI相关的内容变得更加容易。
多模型评估将更加易于管理，在实现了CMMI核心实践后，可以添加额外的模型或特定领域的内容，比如CMMI SVC、CMMI ACQ、People CMM。
三、易于理解与访问
CMMI V2.0的撰写选用了非技术性的商业语言，这降低了非英语母语使用者的使用难度，也更易于被翻译成不同的语言。
每个实践域均有进化提升路径，较高等级的实践域是建立在对应的低等级之上的。建立和保持实践，取代了CMMI V1.3模型中的通用实践（Generic Goals）和通用实践（Generic Practices）。
取得授权的使用者，将可以看到CMMI模型相关的全部内容，而不是仅仅滚动PDF或翻阅书籍，他们可以点击、查询所需的内容，这对他们来说非常有用。取得授权的使用者可以访问目前所有CMMI V2.0模型的内容，只要在授权期内，新的内容也同样向他们开放。
四、CMMI 2.0致力于提升价值与评估可靠性
SCAMPI A appraisal vs. Benchmark appraisal
等级评估（Benchmark appraisal）取代了SCAMPI A评估，所给出的成熟度等级结果的有效期为3年。
新的评估方法论包含统计验证的随机取样方法，将扩大工作单元（Work Unit, WU）中数据分析的覆盖度，显著减少结果偏差。强调评估方法和计划，以减少总体准备时间。
Sustainment appraisals
持续性评估（Sustainment appraisals，一种全新的评估）将实质性的缩减审查过程成熟度的持续性的范围。实施一次持续性评估，可以延长组织2年的成熟度等级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c326a430057be895d46d3c89519b7c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963e13125bda30526af41ac9f7af3115/" rel="bookmark">
			mybatis-plus在IdType.ASSIGN_ID策略下无法生成主键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主键生成器为自定义，如下：
主键字段定义为：
这样调用mybatis-plus生成service的save方法时并不能自动生成主键，将类型改为Long才可，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d354b0cf2ec22f55596da731e84b8e8/" rel="bookmark">
			单目视觉系统检测车辆的测距方法（Mobileye单目测距等7种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：CV_Community 来源：计算机视觉社区
本文还是在传统机器视觉的基础上讨论单目测距，深度学习直接估计深度图不属于这个议题，主要通过mobileye的论文管中窥豹，相信离实际工程应用还有很远。
以前提过单目测距的问题，检测的障碍物2-D框加上摄像头的姿态和路面假设。以下根据公开发布的论文讨论具体的算法：
注：深度学习直接估计深度图不属于这个议题。
1、Vision-based ACC with a Single Camera: Bounds on Range and Range Rate Accuracy
著名的Mobileye论文，先看成像几何如图：
本车A，前方车B和C，摄像头P焦距f，高度H，和障碍物B/C距离Z1/Z2，B/C检测框着地点在图像的投影是y1/y2。那么y=fH/Z，所以Z=fH/y。下面是三个不同距离的估计结果：
精度测量得到：90米误差大约10%, 44米误差约为5%。
2、Integrated Vehicle and Lane Detection with Distance Estimation
算法流程如下：
先是从3个消失点估算摄像头焦距，然后6个2D-3D对应点得到摄像头姿态：
基于车道宽度的假设（3.75米），可以算出投影矩阵，随之得到距离公式：
下图是一些结果：
3、Use of a Monocular Camera to Analyze a Ground Vehicle’s Lateral Movements for Reliable Autonomous City Driving
还是基于消失点原理，加上水平线，可得到道路场景几何关系。
消失点和pitch angle的关系：
从消失点得到pitch angle：
4、Robust Range Estimation with a Monocular Camera for Vision-Based Forward Collision Warning System
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d354b0cf2ec22f55596da731e84b8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378f3c53e39321f0e241d1d38ac3f932/" rel="bookmark">
			c&#43;&#43; unordered_map判断元素是不是在哈希表里的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一:
if(mp.count(查找的东西)) printf("存在"); else printf("不存在"); count()函数是一个计数函数。如果存在,一定返回真 否则返回假。 方法二:
if(mp.find(查找的东西) != mp.end()) printf("存在"); else printf("不存在"); 如果find()函数返回的迭代器不是最后的下一个，即说明在哈希表里。 否则不在哈希表里。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fb34b62f601737643b9fac6cc0bbcb/" rel="bookmark">
			这就是华为速度：2.69分钟完成BERT训练！新发CANN 5.0加持，还公开了背后技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金磊 萧箫 发自 凹非寺
量子位 报道 | 公众号 QbitAI 快，着实有点快。
现在，经典模型BERT只需2.69分钟、ResNet只需16秒。
啪的一下，就能完成训练！
这是华为全联接2021上，针对异构计算架构CANN 5.0放出的最新性能“预热”：
4K老电影AI修复，原本需要几天时间，现在几小时就能完成；
针对不同模型进行智能优化，300+模型平均可获得30%性能收益；
支持超大参数模型、超大图片计算，几乎无需手动修改原代码……
不同于训练推理框架，异构计算架构在设计时，还需要兼顾硬件和软件的特点。
为的就是尽可能提升AI模型的计算效率，减少在训练和推理上占用的时间。
它的存在，能让开发者在使用AI模型时，最大程度地发挥硬件的性能。
异构计算架构究竟为什么重要，昇腾CANN 5.0又究竟有哪些特性和优势？
我们对华为昇腾计算业务副总裁金颖进行了采访，从CANN 5.0的功能解读中一探究竟。
为什么需要AI异构计算架构？ 首先来看看，AI异构计算架构到底是什么。
通常做AI模型分两步，先选用一种框架来搭建AI模型，像常见的Caffe、Tensorflow、PyTorch、MindSpore等；再选用合适的硬件（CPU、GPU等）来训练AI模型。
BUT，在AI训练框架和硬件之间，其实还有一层不可或缺的“中间架构”，用来优化AI模型在处理器上的运行性能，这就是AI异构计算架构。
区别于同构计算（同类硬件分布式计算，像多核CPU），异构计算指将任务高效合理地分配给不同的硬件，例如GPU做浮点运算、NPU做神经网络运算、FPGA做定制化编程计算……
面对各种AI任务，AI异构计算架构会充当“引路员”，针对硬件特点进行分工，用“组合拳”加速训练/推理速度，最大限度地发挥异构计算的优势。
如果不重视它，各类硬件在处理AI任务时，就可能出现“长跑选手被迫举重”的情况，硬件算力和效率不仅达不到最优，甚至可能比只用CPU/GPU更慢。
目前已有越来越多的企业和机构，注意到异构计算架构的重要性，开始着手布局相关技术，不少也会开放给开发者使用。
但开发者在使用这些异构计算架构时，会逐渐发现一个问题：
不少AI异构计算架构，基本只针对一种或几种特定场景来设计，如安防、客服等AI应用较成熟的场景；针对其他场景设计的AI模型，异构计算架构的性能会有所下降。
就像安防公司会针对安防类AI模型进行优化一样，这类异构计算架构往往不具有平台通用性。
这使得开发者在训练不同的AI模型时，需要在搭载不同异构计算架构的各类处理器之间“反复横跳”，找到训练效率最高的方法。
期间不仅要学习各类算子库、张量编译器、调优引擎的特性，还只能选用特定的训练框架，非常复杂。
相比之下，华为从2018年AI战略制定之初，就选择了一条不同的路线。
华为昇腾计算业务副总裁金颖在采访中表示：
我们认为，AI模型会由单一的、场景化的模式，逐渐走向通用化，而昇腾系列，就是针对全场景设计的解决方案。
其中，昇腾CANN作为平台级的异构计算架构，已经经过了3年多的优化，迭代了4个大版本。
现在，最新“预热”的CANN 5.0版本，在各种不同场景的模型和任务上，都表现出了不错的效果。
昇腾CANN 5.0带来哪些新功能？ 相比于昇腾CANN 3.0，“跨代”的5.0版本带来三大优势：
性能：AI模型训练/推理性能大幅提升，用时更短；
功能：推理引擎ATC Suite1.0首次发布，AI模型推理性能更高、功能更全面；
便捷性：代码开发和调试进一步简化，包括支持混合编程等，使用门槛更低。
在性能上，无论是训练规模大小、场景类型，还是推理效率，均有较大提升。
其中，在MLPerf提供的大规模集群训练场景中测试，结果如下：
△数据来源：昇腾
从上图可见，原本需要6.25分钟训练的BERT模型，在CANN 5.0的加持下缩短了一倍多，只需2.69分钟就能完成训练；至于在3.0版本上需要28秒训练的ResNet，5.0版本则是“再进化”到了16秒。
至于常用的一些小模型训练场景（分类、检测、语义分割、NLP等），5.0版本的性能提升同样明显：
△数据来源：昇腾
训练以外，5.0版本的推理性能，在不同场景（分类、翻译、检测）下提升效果也非常不错：
△数据来源：昇腾 显然，无论是训练还是推理，CANN 5.0都实现了更高效的任务调度和更好的性能提升。
在功能上，CANN 5.0首次发布了昇腾推理引擎软件包ATC Suite1.0（ATC，Ascend Tensor Compiler，昇腾张量编译器），包括模型压缩、张量编译、智能优化和媒体预处理硬加速等能力。
模型压缩，包括量化、稀疏、张量分解等工具。像其中的AMCT模型压缩工具，就能对浮点数据进行压缩处理，来降低模型大小，加速推理速度；
智能优化，能为用户提供在线调优能力，包括图解析、子图/算子自动调优、模型编译优化等功能，进一步加速ATC的计算速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fb34b62f601737643b9fac6cc0bbcb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/287/">«</a>
	<span class="pagination__item pagination__item--current">288/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/289/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>