<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62cfb024c6838e7dc4c902761b64eea/" rel="bookmark">
			TensorFlow2.4可以在MacBook Pro/Mac Pro上利用GPU做机器学习训练了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		田海立@CSDN 2020-11-21
之前MacBook上TensorFlow只能利用CPU做训练，TF2.4开始可以利用GPU做训练了，并且不管是M1的MacBook Pro，还是Intel架构的MacBook Pro还是Mac Pro都是支持的。Apple披露这一信息，并且po出性能对比数据。
MacBook Pro上利用GPU训练 看下面的性能数据，对比了CPU数据、Intel架构的MacBook Pro以及M1架构的MacBook Pro：
结果显示：M1架构的训练性能比CPU提升了7倍；Intel架构的没那么明显。
其中的机器及软件配置：
CPU是13-inch Intel架构的Macbook Pro，跑的是TF2.3Intel架构的GPU加速机器以及M1芯片的GPU加速机器跑的是TF2.4 prereleaseIntel架构的13-inch Macbook Pro的配置：1.7GHz 4核 i7 CPU + Intel Iris Plus Graphics 645 GPU + 16GB内存 + 2TB SSD硬盘 M1芯片的13-inch Macbook Pro的配置：M1（4核高性能+4核高效能CPU + 8核GPU + 16核Neural Engine）+ 16GB内存 + 256GB SSD硬盘 只是，M1里有NPU，这个有利用NPU吗，还是仅仅GPU？Apple没过多披露，字里行间也只提到了GPU，保留关注。
Mac Pro上利用GPU训练 Mac Pro上CPU与GPU训练的数据如下：
这个看起来GPU效果还是比CPU有极大提升的。
当然Mac Pro仅有Intel架构的机器，其中的机器及软件配置：
CPU数据跑的是TF2.3GPU数据跑的是TF2.4 prerelease机器配置：3.2GHz 16核 Intel Xeon W-based + 32GB内存 + AMD Radeon Pro Vega II Duo GPU （64GB HBM2显存） + 256GB SSD硬盘 看来想利用Intel架构的MacBook Pro来跑机器学习训练任务提升有限；用M1的MacBook Pro或Mac Pro可以跑机器学习训练任务了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62cfb024c6838e7dc4c902761b64eea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d644cddecb2828a8556190b442e1a146/" rel="bookmark">
			roundcube邮箱怎么改密码_安装Webmail客户端Roundcube
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要安装Roundcube主要有两方面原因：第一，代收Riseup邮件，因某些原因Riseup需要代理访问，同理也可添加其它邮箱账户如Gmail；第二，自Roundcube1.4发布以后，系统所带的新主题“Elastic”非常惊艳，autistici邮箱也已经切换为“Elastic”。
系统环境 VPS：Amazon Lightsail操作系统：Ubuntu 18.04服务器：Apache 2.4.29PHP版本：7.2.24数据库：Mysql Ver 14.14 Distrib 5.7.29 软件下载 下载Roundcube登陆https://roundcube.net/download/，下载Roundcube1.4.3 Complete版本。也可以直接在服务器运行wget -c https://github.com/roundcube/roundcubemail/releases/download/1.4.3/roundcubemail-1.4.3-complete.tar.gz解压Roundcube压缩文件tar xvf roundcubemail-1.4.3-complete.tar.gz将文件夹移动到/var/www/sudo mv roundcubemail-1.4.3 /var/www/roundcube该Roundcube文件夹拥有者为www-datasudo chown -R www-data: roundcube/ ​
Apache设置 DNS设置添加“A”记录，将“mail”主机记录对应到VPS ip地址，仅供参考。进入Apache存放网站配置文件的文件夹cd /etc/apache2/sites-available/创建config文件sudo cp 000-default.conf mail.conf编辑配置文件sudo nano mail.conf
以httpsmail为例：ServerAdmin me@httpsmail.com
ServerName mail.httpsmail.com
DocumentRoot /var/www/roundcube启用配置文件sudo a2ensite mail.conf重启服务器sudo systemctl restart apache2.service
或重载服务器sudo systemctl reload apache2.service ​
安装PHP及扩展 安装PHPsudo apt install php-fpmPHP扩展，可参考官方wiki: https://github.com/roundcube/roundcubemail/wiki/Install-Requirements。在后期安装Roundcube时也会有提示，缺哪个就安哪个即可。 PHP version 5.4.1 or greater with PCRE (Perl-Compatible Regular Expressions)DOMJSONXMLMbstringOpenSSLSession supportSocket supportPHP Data Objects (PDO) with driver for either MySQL, PostgreSQL, SQL Server or SQLiteIconv (optional)FileInfo (optional)Zip (optional)Pspell (optional)PEAR packages distributed with Roundcube or external: Mail_Mime 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d644cddecb2828a8556190b442e1a146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd94550367192ae8f9e0a0f80ce10c0/" rel="bookmark">
			理解ARP的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.搭建网络拓扑，配置设备参数 二.查看ARP高速缓存 分别在PC0和PC1的Command Prompt命令行中输入"arp -a"命令查看其高速缓存，如下图所示：
如上图可知ARP缓存中无任何信息
三.将模拟器切换到Simulation模式，创建简单数据包 1.点击简单数据包后，分别以PC0和PC1为源地址和目的地创建一个PDU(简单数据包) 2.第一次单击"Capture/Forward"按钮观察ARP请求报文 3.第二次单击"Capture/Forward"按钮观察ARP广播请求报文 如上图可知PC0发送了一个ARP广播报文，其他主机收到广播报文后发现自己并不是PC0所要请求的目的主机，因此丢弃报文，只有PC1做出了回应(因为PC0发送的数据报的目的IP地址是PC1的IP地址)
4.第三次单击"Capture/Forward"按钮观察ARP响应报文 PC1发送了ARP响应报文，PC1在ARP响应报文中写入了自己的MAC地址，PC0收到PC1的响应报文后，就在其高速缓存中写入PC1的IP地址和MAC地址的映射关系
5.第四次单击"Capture/Forward"按钮，完成PC0与PC1的通信 四.查看ARP高速缓存 通信结束后再次查看PC0和PC1的ARP缓存
五.观察ARP请求报文和响应报文 1.请求报文 从请求报文中看出：
源IP地址为 192.168.1.1(PC0的IP地址)
源MAC地址为 0001.63EE.90B5(PC0的MAC地址)
目的IP地址为 192.168.1.2(PC1的IP地址)
目的MAC地址未知，以零填充，为 0000.0000.0000
从ARP请求报文数据帧图中看出，目标MAC地址是一个全1的广播帧，值为FFFF.FFFF.FFFF,说明该帧要广播到整个局域网中。
2.响应报文 从响应报文中看出(PC1在ARP响应报文中写入了自己的的MAC地址)：
源IP地址为 192.168.1.2(PC1的IP地址)
源MAC地址为 00E0.8FD1.80E7(PC1的MAC地址)
目的IP地址为 192.168.1.1(PC0的IP地址)
目的MAC地址未知，以零填充，为 0001.63EE.90B5(PC0的MAC地址)
从ARP响应报文数据帧图中看出，与ARP请求报文不同的是：这个帧中的目的MAC地址就是PC0的MAC地址。因此ARP响应报文是一个单播报文
六.改变网络拓扑，观察ARP重新运行过程 1.配置设备参数 增加一台新的PC4，添加配置设备参数
2.查看ARP高速缓存 分别在PC0和PC4的Command Prompt命令行中输入"arp -a"命令查看其高速缓存，如下图所示：
由于之前PC0与PC1成功发送过报文，因此PC0的ARP缓存中有PC1的IP地址和MAC地址的映射关系
如上图可知ARP缓存中无任何信息
3.将模拟器切换到Simulation模式，创建简单数据包 点击简单数据包后，分别以PC0和PC4为源地址和目的地创建一个PDU(简单数据包)
如上图可知PC0发送了一个ARP广播报文，其他主机收到广播报文后发现自己并不是PC0所要请求的目的主机，因此丢弃报文，只有PC4做出了回应(因为PC0发送的数据报的目的IP地址是PC4的IP地址)
4.查看ARP高速缓存 通信结束后再次查看PC0和PC4的ARP高速缓存
5.观察请求报文和响应报文 请求报文：
从请求报文中看出：
源IP地址为 PC0的IP地址
源MAC地址为 PC0的MAC地址
目的IP地址为 PC4的IP地址
目的MAC地址未知，以零填充，为 0000.0000.0000
从ARP请求报文数据帧图中看出，目标MAC地址是一个全1的广播帧，值为FFFF.FFFF.FFFF,说明该帧要广播到整个局域网中。响应报文：
从响应报文中看出(PC4在ARP响应报文中写入了自己的的MAC地址)：
源IP地址为 PC4的IP地址
源MAC地址为 PC4的MAC地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd94550367192ae8f9e0a0f80ce10c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a123c6256529f5af64ffe354bd2d38d/" rel="bookmark">
			c语言樱花飘落代码_&amp;quot;云&amp;quot;看花，教你用Python画樱花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“春风吹过，便是一阵阵 浪漫的樱花雨 ”由于特殊原因，不能聚集游玩，如今春天到来，武大的樱花已经盛开了，所以很多平台都开通了线上赏樱花。 无意中发现自己正在所学的Python语言居然可以用来画画这对于Python初学者来说是非常神奇的事情，有兴趣的小伙伴可以自己尝试，画出属于自己的那一片樱花！ .01通过运行代码，效果如下(文末有源代码) .02用代码绘画一张樱花树需要用到Python中内置的三个函数 #turtle/math/random#『turtle库是Python语言中一个很流行的绘制图像的函数库』『math模块定义了一些数学函数，比如乘方、开方、对数运算』『random模块用于生成随机数』 .03完整代码如下 from turtle import *from random import *from math import *def tree(n,l): pd()#下笔 #阴影效果 t = cos(radians(heading()+45))/8+0.25 pencolor(t,t,t) pensize(n/3) forward(l)#画树枝 if n&gt;0: b = random()*15+10 #右分支偏转角度 c = random()*15+10 #左分支偏转角度 d = l*(random()*0.25+0.7) #下一个分支的长度 #右转一定角度,画右分支 right(b) tree(n-1,d) #左转一定角度，画左分支 left(b+c) tree(n-1,d) #转回来 right(c) else: #画叶子 right(90) n=cos(radians(heading()-45))/4+0.5 pencolor(n,n*0.8,n*0.8) circle(3) left(90) #添加0.3倍的飘落叶子 if(random()&gt;0.7): pu() #飘落 t = heading() an = -40 +random()*40 setheading(an) dis = int(800*random()*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a123c6256529f5af64ffe354bd2d38d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7712f8d9fd3fe386f18ab8682b0a0c/" rel="bookmark">
			让你看看我肝了好多天的git教程吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章最初发布在 XJHui’s Blog，未经允许，任何人禁止转载！
注意：最新修改版本已发布在 这里，点击前往查看！
关于笔记 视频地址：Git（中级）教程（12h深入掌握git）(28p)学前基础： linuxgithub 学后技能： git底层、高层命令git分支、存储、后悔药、标签git团队协作、Pull Request 版本控制 集中式(svn) 原理：服务器存放项目的所有版本，工作时从服务器下载项目最新版本，工作完成后将代码提交到服务器
原理图：
分布式(git) 原理：每台电脑中都存放了项目的所有版本，即使服务器故障也不会影响工作更不会将丢失项目
原理图：
差异比较 存储方式：svn存储版本差异，git存储所有版本
注意：git是先压缩后存储，尽管存储占用比svn大，但不会大太多
安全性：
svn：工作时只会下载项目最新版本，如果服务器存储故障，就无法从员工电脑恢复项目所有版本git：每位员工电脑上都有项目的所有版本，即使服务器存储故障，任意一位员工都能恢复整个项目 版本回退速度：
svn：存储的是版本差异，每回退一个版本都需要打一次补丁，导致回退速度慢git：存储所有版本，只要找到该版本对应的提交对象，就可直接回退到该版本 服务器故障时：
svn：新写的代码不满意，不能回退到初始版本git：本地操作不受服务器限制，可任意提交、回退 总结：
svn：存储占用小git：安全、高效 git 简史 创始人：Linus Benedict Torvalds（林纳斯·托瓦兹）
git起源：
安装 下载访问： https://xjhui.lanzoux.com/iap7Odtezyf，感谢：蓝奏云
注意：如果与您的电脑版本不匹配，请访问：https://git-scm.com/download/win 下载指定版本
安装：一路next
验证安装：桌面右键，出现框选内容代表安装成功
初始化 命令：
git init # 初始化一个git仓库 案例：在/workspace下初始化一个git仓库
文件夹内右键选择 Git Bash Here：
输入指令： git init：
注意：.git为隐藏文件，若不显示请点击 查看 -&gt; 勾选 隐藏的项目
git文件（.git文件夹内）：
文件功能：
hooks：存放钩子文件（提交代码前、后要做的事，例如检查代码规范）info：说明哪些文件不需要管理objects：对象库（类似对象库，存放git对象、树对象、提交对象）refs、HEAD：分支相关内容description：仓库描述信息 git区域 三个区域：
工作区：就是你在电脑里能看到的目录暂存区：一般存放在 .git 目录下的 index 文件（.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7712f8d9fd3fe386f18ab8682b0a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee25c6bf8652902e1b9523d2a534b8f1/" rel="bookmark">
			python雨课堂答案_python实现雨课堂自动预习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用selenium和python的win32api库实现了一个雨YU课堂自动预习的脚本，第一次需要登录，会自动存储cookies,
全程只需要手动输入网址，和页数其他自动完成，
如果里面有题目的话，这个脚本还做不了哈，而且使用的时候鼠标要放在浏览器窗口
，selenium没有实现鼠标滚轮滑动的库。
有也是旁边要有scroll,而YU课堂没有，
就想到了win32api,但这也是缺陷，没有涉及底层的代码，
会js的小伙伴可以试一试用js完成中间的浏览步骤，可能代码更简洁。
下面放上代码，
仅供学习交流，不是偷懒的工具哦！！！！！！！！！！
# coding:utf-8# time:2020.6.5.19:30# auther:小生# website:fromseleniumimportwebdriver
importtime
importwin32api
importwin32con
fromdatetimeimportdatetime
fromdatetimeimporttimedelta
importrandom
importos
importjson
"""使用时，请将鼠标放到浏览器内，暂时没有想到更好的方法，要时刻观察控制台，自动打开浏览器后会提示你输入网址，如果第一次使用，没有可供使用的cookies,那么控制台会提示登录，30秒足够了。没有设置selenium的页面等待，然后会自动打开页面,然后控制台会提示输入页数，输入即可，鼠标放到浏览器窗口，你可以吃饭，去上厕所，或者去玩，总之你开心就好。"""classRainclass(object):
driver_path =r"D:\Python\chromedriver\chromedriver.exe"time_all =0num =1def__init__(self):
self.driver = webdriver.Chrome(executable_path=Rainclass.driver_path)
self.url =input("请输入要自动完成页面的网址：")
# self.url = "https://changjiang.yuketang.cn/v2/web/studentCards"self.driver.get(self.url)
definitial_judge(self):
ifos.path.exists("rainclass.txt"):#判断是否当前文件夹有存在存储cookies的文件print("cookies存在")
self.send_cookies()
else:
self.get_cookies()
print("cookies不存在")
defget_cookies(self):
print("将沉睡30秒，瞅啥呢，赶紧登录，老子要拿cookies")
time.sleep(30)
distcookies =self.driver.get_cookies()
jsoncookies = json.dumps(distcookies)
withopen("rainclass.txt","w")asfp:
fp.write(jsoncookies)
print("拿取cookies成功,正在进行下一步，登录")
time.sleep(1.5)
self.send_cookies()
defsend_cookies(self):
withopen("rainclass.txt","r",encoding="utf-8")asfp:
liscookies = json.loads(fp.read())
forcookieinliscookies:
cookie_dic = {
"domain":"changjiang.yuketang.cn","expiry": cookie.get("expiry"),"httpOnly": cookie.get("httpOnly"),"name": cookie.get("name"),"path":"/","secure": cookie.get("secure"),"value": cookie.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee25c6bf8652902e1b9523d2a534b8f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b097d980373a658615d93846b096b6/" rel="bookmark">
			python关键字匹配_python通过BF算法实现关键词匹配的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了python通过BF算法实现关键词匹配的方法。分享给大家供大家参考。具体实现方法如下：
#!/usr/bin/python
# -*- coding: UTF-8
# filename BF
import time
"""
t="this is a big apple,this is a big apple,this is a big apple,this is a big apple."
p="apple"
"""
t="为什么叫向量空间模型呢？其实我们可以把每个词给看成一个维度，而词的频率看成其值（有向），即向量，这样每篇文章的词及其频率就构成了一个i维空间图，两个文档的相似度就是两个空间图的接近度。假设文章只有两维的话，那么空间图就可以画在一个平面直角坐标系当中，读者可以假想两篇只有两个词的文章画图进行理解。"
p="读者"
i=0
count=0
start=time.time()
while (i &lt;=len(t)-len(p)):
j=0
while (t[i]==p[j]):
i=i+1
j=j+1
if j==len(p):
break
elif (j==len(p)-1):
count=count+1
else:
i=i+1
j=0
print count
print time.time()-start
算法思想：目标串t与模式串p逐词比较，若对应位匹配，则进行下一位比较；若不相同，p右移1位，从p的第1位重新开始比较。
算法特点：整体移动方向：可认为在固定的情况下，p从左向右滑动；匹配比较时，从p的最左边位开始向右逐位与t串中对应位比较。p的滑动距离为1，这导致BF算法匹配效率低（相比其他算法，如：BM，KMP，滑动没有跳跃）。
该算法的时间复杂度为O（len(t)*len(p))，空间复杂度为O(len(t)+len(p))
希望本文所述对大家的Python程序设计有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e614a3106d6e9da38e819ab4bb9185d6/" rel="bookmark">
			开发板 集成下载器 jtag_迅为i.MX6ULL开发板原理图分析介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		i.MX6ULL开发板是北京迅为电子推出的一款Cortex-A7架构的开发板。采用核心板+底板的方式，底板尺寸190mm*125mm，核心板尺寸42*38mm。
1 核心板接口
I.MX6ULL 终结者开发板采用核心板+底板的方式，核心板与底板硬件连接形式上采用的是邮票孔的方式，相比起连接器的方式此种方式具有连接性稳定，抗震动等优点。底板上相应的原理图如下图所示：
从上图我们可以看到邮票孔的封装一共引出了 146 个引脚，其中 i.MX6ULL 引出了 120 个 IO，另外还有电源，GND。考虑到信号完成性的要求，连接器上引出了尽可能多的 GND。
1.3.2 启动方式原理部分
I.MX6ULL 支持很多种启动方式，我们可以通过设置与启动方式有关的 IO 状态来选择启动方式，具体的原理如下图所示：
从上图我们可以看到，启动方式的 IO 中大多数的 IO 都是通过电阻下拉了，只有 8 位 IO 可以通过一个 8 位的拨码开关来选择对应的状态。具体的启动方式设置我们整理成了下面表格（关于启动方式更详细的说明， 大家可以参考下 5.1 章节）：
1.3.3 系统电源接口
I.MX6ULL 开发板的电源供电部分原理如下图所示：
从上图我们可以看到电源部分使用了一个 DCDC 的电源芯片 U24，外部输入电源首先从 JACK1 输入，经过防反接二极管 D7 到达电源开关（J1），当我们按下电源开关（J1）的时候，电源会到达电源芯片（U24） 的输入端，最终经过电源芯片会输出 5V 的电源给系统供电。由于我们使用的电源芯片 U24 是个宽电压芯片，允许输入的电压是 5V~16V 直流电源，所以我们可以很方便的就能找到一个与之匹配的电源适配器来使用，采用宽压电源芯片的优点是如果错接了 12V 的电源，板子也不会因为输入电压过高，而导致器件损坏（默认我们提供 5V 的电源适配器）。
1.3.4 复位电路
i.MX6ULL 终结者开发板的复位原理如下图所示：
从上图我们可以看到开发板是低电平产生复位。i.MX6ULL 终结者开发板通过专用的复位芯片来实现系统的复位。因为我们真正做产品的时候，有可能我们产品工作在环境非常恶略的环境下，比如电磁干扰之类的，复位引脚有可能在受到干扰的情况下，会发生瞬间的复位信号，如果这个信号直接接到处理器的复位引脚，处理器收到这个复位信号可能就会执行复位了，可是实际上我们并没有要求系统复位。因此我们可以使用专门的复位芯片，它能够排除瞬间的干扰，又可以防止系统在启动和关闭期间的误操作，保证系统的稳定。所以我们的终结者开发板不仅仅是一款学习板，而且也可以拿来作为参考，设计真真正的产品。
1.3.5 纽扣电池电路
i.MX6ULL 终结者开发板的纽扣电池用来给 i.MX6ULL 的 SNVS 模块供电，保证在系统电源断电的情况下给SNVS 模块提供持续的电源，原理图如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e614a3106d6e9da38e819ab4bb9185d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd8b2b9cdf9c30abe7a0114f66e0427/" rel="bookmark">
			用python进行数据分析举例说明_利用Python进行数据分析实例练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面学习了Python的基础语法，Numpy和Pandas，终于要使用Python来进行数据分析的实战练习了。
本节以某药店2018年商品销售数据为例来练习利用Python进行数据分析的基本方法。
数据分析基本步骤： 1、提出问题 2、理解数据 3、数据清洗 4、构建模型 5、数据可视化
一、提出问题
要分析解决业务数据问题，首先要与业务部门进行沟通。本节案例主要分析月消费次数、月消费金额、客单价、消费趋势四大业务指标。对不理解的业务指标可以先自己去搜索引擎查找，实在找不到再去与业务人员沟通理解。
二、导入数据
注意在读取数据时可以先将所有数据按字符串读入，之后再转换为其他格式。
#导入数据分析包
import pandas as pd
'''路径中最好不要有中文，或者特殊符号啥的，不然路径会提示错误找不到。最好将文件放到一个简单的英文路径下'''
#excel文件路径，路径中的./表示在当前notebook所在的文件夹路径
fileNameStr=r'F:\数据分析\跟猴子学习人工智能核心技术\数据分析（高级）（Python）\第3关：数据分析的基本过程\朝阳医院2018年销售数据.xlsx'
'''使用pandas的read_excel函数读取Ecxcel数据参数sheet_name：数据在Excel里的哪个sheet下面，这块就写该sheet在excel里的名称参数dtype=str 统一先按照字符串读入，之后再转换pandas的read_excel函数官网地址：https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html#pandas.read_excel'''
salesDf = pd.read_excel(fileNameStr,sheet_name='Sheet1',dtype=str)
#用pd.read_excel()方法也可以导入数据
salesDf=pd.read_excel(r'F:\数据分析\跟猴子学习人工智能核心技术\数据分析（高级）（Python）\第3关：数据分析的基本过程\朝阳医院2018年销售数据.xlsx',dtype='object')
print(salesDf.head())
购药时间 社保卡号 商品编码 商品名称 销售数量 应收金额 实收金额
0 2018-01-01 星期五 001616528 236701 强力VC银翘片 6 82.8 69
1 2018-01-02 星期六 001616528 236701 清热解毒口服液 1 28 24.64
2 2018-01-06 星期三 0012602828 236701 感康 2 16.8 15
3 2018-01-11 星期一 0010070343428 236701 三九感冒灵 1 28 28
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd8b2b9cdf9c30abe7a0114f66e0427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5eb3b0d92abc7f24ec97328c1614600/" rel="bookmark">
			python求和1到100_python求1到100的和的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自己写的，while循环
i = a = 0
while i &lt; 100:
i = i + 1;
a = a + i;
print(a)
网上方法一，for循环
a = 0
for i in range(0,100):
a += (i+1);
print(a)
网上方法二，sum函数
print(sum(range(1,101)))
网上方法三，sum函数加列表生成式
print(sum([x for x in range(1,101)]))
网上方法四，使用reduce函数
注意：在 Python3 中，reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 functools 模块里，
如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数。
from functools import reduce
print(reduce(lambda a,b:a+b ,range(1,101)))
上面匿名函数也可以写具体函数：
def add(x,y):
return x + y
print(reduce(add,range(1,101)))
网上方法五，递归算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5eb3b0d92abc7f24ec97328c1614600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2e561865c4fb25b9d1a4ffe9e9ebc5/" rel="bookmark">
			python爬取付费音乐包_Python爬咪咕收费音乐 高音质无损音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Python] 纯文本查看 复制代码def migu_search(keyword, page=1):
params = {
'feature': '1111000000',
'isCopyright': 1,
'isCorrect': 1,
'pageIndex': page,
'pageSize': 20,
'searchSwitch':'{"song":1,"album":0,"singer":0,"tagSong":1,"mvSong":0,"songlist":0,"bestShow":1,"lyricSong":0,"concert":0,"periodical":0,"ticket":0,"bit24":0,"verticalVideoTone":0}',
'sort': 0,
'text': keyword,
'uiVersion': 'I_music_3.0.2',
}
response = Api.request('http://jadeite.migu.cn:7090/music_search/v2/search/searchAll', "GET", params)
res_data = response.get('songResultData', {}).get("resultList", [])
print(json.dumps(res_data))
result = []
for items in res_data:
for item in items:
singers = ','.join([s.get("name", "") for s in item.get('singers')])
song = {
'song_name': item.get('name'),
'singers': singers
}
rate_list = item.get('rateFormats', [])
urls = {}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c2e561865c4fb25b9d1a4ffe9e9ebc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79c589c19b9d9a29a9abde5acd28276/" rel="bookmark">
			NP管理器和MT哪个强_MT管理器相信大家都很熟悉的[勉强]，功能可以说非常强大，开发逆向的时候经常需要用到。...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MT管理器相信大家都很熟悉的[勉强]，功能可以说非常强大，开发逆向的时候经常需要用到。
但是有些功能是需要购买VIP才能体验的。像我们这种穷人只能看着流泪[转圈哭]
还在眼馋MT的功能？快来试试今天冷眼为大家推荐的APP——NP管理器
这款NP管理器可以说是借鉴于MT管理器，UI界面和MT差不多，但是UX真的不尽人意！[弱][阴险]MT的启动速度大约是3-4s 这个软件的启动速度是10s左右[阴险]而且使用时会有明显的卡顿、日常FC[阴险](看了一下加固，这个软件是360加固过的[阴险]怪不得体验这么糟)应用内的图标扁平化、拟物化混杂，感观较差。设置内的功能没有集合在一起，功能缺陷(毕竟是免费的，还要什么自行车[酷][滑稽])
功能上甚至说可以吊打MT。整合添加了许多实用的功能，可以一键加弹窗、添加对话框、APK共存、DEX混淆、toast添加、日志注入、XP框架检测等等，可以说作者很用心
在关于界面里看作者的意思应该是把开源项目整合在一起了，按目前的说法来看是会长久免费使用的[滑稽]但不排除添加广告，各位可以下载体验一下~
对了，实测这个软件的文本编辑器体验要优于MT，在编译大文件时速度远快于MT的编辑器速度[大拇指]
热乎乎的下载链接~
https://www.lanzous.com/i9n4gtg
觉得好用的，不妨点个赞+关注[太开心]我会定期分享实用软件给大家的~
最后感谢作者@MT_吹牛儿[滑稽]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b25d4ec9fcca1d003110459b6636f6/" rel="bookmark">
			NP管理器和MT哪个强_NP管理器2.7.6多功能文件管理器 媲美MT/功能更强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		東笙资源部落 【特别声明】所有软件皆来源于网上收集整理，仅供学习与交流技术,不得用作其它用途，如有侵犯你的权益，请联系我们,我们将于24小时内进行删除，谢谢你的配合！
软件介绍 NP管理器app是一个和MT管理器一样的系统管理工具， 安卓手机不需要root也可以使用。NP管理器app目前的功能很强大，可以一键去除APK对话框，修改各种apk的权限和功能。
杜比音响效果是超乎完美的音质，让聆听者置身任何地方都能通过音乐给人来带愉悦的心情，秒杀一切其他音质的播放器，不过目前只支持在耳机输出模式下是有效的。
软件说明 延用JAVA平台的双窗口操作模式，便捷的九宫格菜单操作
root操作：挂载磁盘读写/只读，修改文件权限、用户组，浏览系统限制目录(/data等)
批量复制、移动、删除、重命名、创建符号链接、修改权限
强大的搜索功能，支持对文件名及文件内容、大小进行搜索
显示apk图标、图片缩略图，支持缩略图缓存、显示ZIP内图片缩略图
内置文本编辑器、图片浏览器、音乐播放器、字体预览器、脚本执行器
完整的zip文件操作功能，可直接添加、重命名、删除ZIP内文件，免二次压缩
支持打开rar文件及解压
APK编辑功能，包括编辑DEX,ARSC,XMＬ，APK签名，zipalign优化
其它普通文件操作功能
会员功能 XML 反编译，但相比 VIP 会员，反编译速度慢，反编译的源码最多 200 行。
翻译模式中的自动翻译，普通用户只能使用一个字典，联网翻译引擎只有百度翻译。
会员才能使用的功能
XML 反编译无任何限制
XML 资源值智能编辑功能
Smali 代码转成 Java 代码
翻译模式中更多的联网翻译引擎
翻译模式中无限字典个数
APK 共存时自定义包名
Dex 修复功能
导入自定义签名
Arsc 资源查询功能
去除 APK 签名校验
RES 反资源混淆
更新说明 ·增加插件中心，可在线安装和更新插件
·增加插件开发者中心，可以发布你的插件
·增加对当前文件列表进行文件名过滤的功能
·增加安装包提取功能
·主界面现支持跟随系统旋转
免费声明
❶ 本公众号所分享资源皆来源于网上收集整理，所分享资源只做日常学习和交流使用，版权归原作者或原网站所有。
❷ 如果您是本软件的开发者，且不愿被网友分享发布，公众号右下角菜单栏更多--权责声明，联系我们及时删除处理 ❸ 若为付费资源，请在下载后24小时之内自觉删除，若要作商业用途，请到原网站购买。
❹ 此条款自文章发布之日起生效，并自动覆盖此前发布的条款声明，请以最新发布的条款内容为准。最终解释权归本公众号所有，本公众号保留随时变更条款声明内容而无需另行通知的权利。
从本公众号下载使用资源，即代表您已经阅读并同意本条款全部内容，如若发生事故与本公众号无关。
拿走点在看养成好习惯！拿走点在看养成好习惯！ 扫码关注，回复099获取高速下载
下载 https://590m.com/dir/20293696-34588791-ab99c7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b58fd0f45d14d65ac3c437c4b124e3/" rel="bookmark">
			Maven项目增量打包部署 基于Git Bash （前后端一体化项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Git项目的根目录，鼠标右键 Git Bash Here，打开Git Bash窗口 2.执行 ./git-package_.sh “2020-11-20 08:00:00” ， 日期为上次打包文件的日期 3. git-package_.sh 脚本如下（需要根据自身的 Tomcat 项目部署路径修改变量 web_dir 注意路径最后不要有 “/” ）： #!/bin/bash #首先获取待打包文件 git log --pretty=format:"" -$1 --name-only git_files=(`git log --pretty=format:"" --name-only --since="$1" `); res_files=""; repeat_files=(); ignore_files=( shopxx.xml shopxx.properties pom.xml ); # tomcat部署的项目路径 web_dir="/c/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/shopxx-b2b2c" work_dir=$PWD cd $web_dir #处理文件，找到需要打包的文件 for ss in ${git_files[@]}; do #去掉重复的文件: 采取如下遍历方案 for ss_repeat in ${repeat_files[@]}; do if [[ $ss_repeat == $ss ]] ; then echo "重复:"$ss; ss="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b58fd0f45d14d65ac3c437c4b124e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869c6604bd89411b31816837296db178/" rel="bookmark">
			Java注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://127.0.0.1:8080/MVC/index.do getServletPath():index.do getContextPath():/MVC 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57408eec401a973ad05d262385ef088c/" rel="bookmark">
			记录一次从vue2到vue3的踩坑过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3beta已经上线,最近刚好有一个项目可以让自己随便造,于是就打算使用vue3来造,在此记录下从vue2升级到vue3的一个过程,这里使用的是自己配置的webpack.
vue2到vue3中webpack的一些变化 vue2到vue3中webpack打包的配置也发生了一下一些变化(暂时发现):
不再需要vue-template-compiler ,在vue3中,vue-template-compiler被剔除了,不需要这个包,而它的替代品是@vue/compiler-sfc在执行npm run dev的时候可能会出现Can't find Python executable "python", you can set the PYTHON env variable,这个时候只要运行以下代码即可npm install --global --production windows-build-tools 在webpack打包配置中,resolves路径也有变化resolves: { alias: { "@": PATHS.entry, 'vuex': 'vuex/dist/vuex.esm-bundler', 'vue': '@vue/runtime-dom' } } vue-loader引入方式发生变化 const { VueLoaderPlugin } = require('vue-loader') 包的版本 vue升级到3之后,相对应的vuex以及vue-router的版本也需要进行更新,一下是我这次使用的包的版本,由于vue3的写法发生变化,很多UI库都不支持,目前只发现antd以及element-plus支持,其中element-plus只是名字进行了改变,其使用方法以及样式都和element一样,除了引入方面发生变化外其他没有任何变化,可以直接从2转成3
npm install --save vue@3.0.0-beta.15 vue-router@4.0.0-alpha.13 vuex@4.0.0-beta.2 写法以及引入的改变 在vue3中,初始页面创建的写法,vue的引入以及vuex和vue-router的写法与引入都发生了改变
import { createStore } from 'vuex'; const store = createStore({ state: {}, getters: {}, actions: {}, mutations: {} }) export default store; vue-router的变化 在之前的4之前的vue-router有两种mode,分别是hash以及history,分别通过hash模拟页面url以及html5的History Api来达到切换页面无需重新加载的功能,而在vue-router4中,这些都被以模块的形式实现,并将其分配到新的history选项中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57408eec401a973ad05d262385ef088c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a063d4fc89e3abd6e0056cae6c8db532/" rel="bookmark">
			nodejs missing script: dev_nodejs深入学习系列之v8基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V8这个概念大家都不陌生了，那么你动手编译过V8源码吗？编译后有尝试去了解V8背后的一些概念吗？如果没有，那么也不用心慌，下文将跟大家一一解释这些东西。在编译V8之前我们先要了解一个东西-构建系统
1、构建系统 1.1、构建系统是啥？ 写惯前端的童鞋可能不是很明白这个东西是干啥用的？但是其实平时你都会接触到，只是概念不同而已。前端我们一般称其为打包构建，类似工具诸如webpack、parcel做的事情。其实最后的目标都是想得到一些目标性的文件。这里可以简单地提及一下软件工程中的构建系统的历史。
构建系统的需求是随着软件规模的增大而提出的。如果只是做简单的demo，通常代码量比较小，编写的源代码只有几个文件。比如你编写了一段代码放入helloworld.cpp文件中，要编译这段代码，只需要执行以下命令：
g++ helloworld.c -o helloworld 当软件规模逐渐增加，这时可能有几十个源代码文件，而且有了模块划分，有的要编译成静态库，有的要编译成动态库，最后链接成可执行代码，这时命令行方式就捉襟见肘，需要一个构建系统。常见的构建系统有GNU Make。需要注意的是，构建系统并不是取代gcc这样的工具链，而是定义编译规则，最终还是会调用工具链编译代码。
当软件规模进一步扩大，特别是有多平台支持需求的时候，编写GNU Makefile将是一件繁琐和乏味的事情，而且极容易出错。这时就出现了生成Makefile的工具，比如Cmake、AutoMake等等，这种构建系统称作元构建系统（meta build system）。在Linux上软件仓库的概念还没有普及的时候，通常我们安装软件的步骤是：
./configure make make install 第一步就是调用一些自动化工具，根据系统环境（系统的版本众多，软件安装情况也不一样），生成GNU Makefile。然后第二步才使用gcc或者g++命令去编译所有文件，最后一步便是将所有文件链接起来成可执行命令并安装到系统的某个指定目录。
一般后两个步骤都是比较固化的，能提高工作效率的也就是在第一步了。于是V8团队针对自己的项目特点，撸了一个叫做GYP(Generate Your Projects)的构建系统，后面你要是看到node-gyp其实就是基于这个做的js版本。不过后面GYP被v8团队废弃掉，改用GN(Generate Ninja)构建系统。二者的区别不是本文重点，有兴趣的童鞋可以查看这篇文章： chromium中的GN构建系统。
有意思的是尽管v8彻底废弃掉了GYP，但是nodejs仍然在使用GYP，这个R大在创建deno项目的时候有提及到：Design Mistakes in Node。
1.1.1、GN构建系统简介 GN(Generate Ninja)是chromium project用来取代GYP的新工具，由于GN是用C++编写，比起用 python写的GYP快了很多，GN新的DSL的语法也被认为是比较好写以及维护的。
在v8项目的根目录下有个.gn文件，内容如下（去掉所有注释了）：
import("//build/dotfile_settings.gni") buildconfig = "//build/config/BUILDCONFIG.gn" check_targets = [] exec_script_whitelist = build_dotfile_settings.exec_script_whitelist + [] 我们关注buildconfig这个配置。.gn所在的目录会被GN工具认定是项目的根目录，.gn的内容基本就是用buildconfig来指定build config的位置，其中//build//config/BUILDCONFIG.gn是相对于项目根目录下路径的配置文件。
但是你会发现现在v8源码目录下并没有叫做build的目录，这个目录要咋生成呢？这些知识我们会在稍后的编译v8代码中提及。
假设现在你有build目录了，我们找到BUILDCONFIG.gn文件，文件里面会根据系统和平台设置对应的编译工具链：
... ... if (custom_toolchain != "") { set_default_toolchain(custom_toolchain) } else if (_default_toolchain != "") { set_default_toolchain(_default_toolchain) } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a063d4fc89e3abd6e0056cae6c8db532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95793689abc9c77f4b822201a3be5a9/" rel="bookmark">
			OpenFeign和Consul爱恨交织的两天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 在公司对项目进行拆分，用consul做注册中心。既然弄注册中心了， 那就得远程调用，那就得整上OpenFeign进行远程调用，你说是不？ 不能说就搞个RestTemplate+服务名调用吧？想法有了，说动就动，就对项目就行拆分，在拆分的过程中，就把我学到的拿出来和大家分享分享。（我也是第一次用consul，没啥经验）
2. 爱与恨 2.1 恨 2.1.1 远程调用失败 在信息远程接口调用时，一直抛出异常：Load balancer does not have available server for client：xxx， 调用一直无法成功，看了很多解决办法，都没啥用。不过看这类型的日志我们知道，就是服务获取失败。 这真是一个头疼的问题（这个问题搞了一天），TMD，疼都炸了。说一下解决方案。
# 在application.yml中加上以下配置 spring: cloud: loadbalancer: ribbon: enabled: false 这个问题的根本原因就是consul整个openFeign用ribbon调用获取不到服务问题。把服务关闭就好了。
2.1.2 一个服务配置多个FeignClient 在拆分过程中，一个服务有很多service接口拿出来调用。例如：A服务中有 service1，service2，B在用Feign调用A接口时，就想对每个Service都有一个代理。默认情况下，不允许有多个代理。 看了很多，发现了一种最简单的写法，如下：
/** * &lt;br&gt;通过contextId就可以区分&lt;/br&gt; * * @author fattyca1 */ @FeignClient(name = "PRODUCER", contextId = "bye") public interface ByeService { @RequestMapping("/bye") String sayBye(@RequestParam("bye") String bye); } /** * &lt;br&gt;ceshi&lt;/br&gt; * * @author fattyca1 */ @FeignClient(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95793689abc9c77f4b822201a3be5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d3ac0146123e458a2cef5a5a576bc1/" rel="bookmark">
			免费的HTTPS（白嫖阿里云SSL证书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带着问题看内容 如何配置 HTTPS？
免费的HTTPS？
介绍 之前本来是用的 certbot，不知道为啥突然出问题了。
然后之前也了解过阿里云上也有免费的 SSL 证书，自己的域名也
是阿里云管理的，所以这次就直接使用阿里云来管理 SSL 了。
详情 首先登录上阿里云管理控制台
在产品与服务，直接搜索 “证书”
点击购买证书
证书类型选 “DV域名级SSL”，才会有免费版，可以看到总配置费用为 0
购买之后就可以看到这个 SSL 列表了，但是还要进行申请，点击“证书申请”
证书申请这些东西如实填写就行了
然后就产生了一个解析配置，注意看上面的那些小字，域名管理控制台
可以看到解析设置已经有了，阿里直接帮我设置了
点击验证，验证通过
然后在证书列表就可以看到了
下载证书，直接使用的哪种就下哪种，我用的 Nginx
文件下载下来就是这样的
然后配置到 Nginx 上
首先在云服务器的安全组上添加端口为 443 的安全组，80 端口是 http 默认端口，443 为 https 默认端口，打开 nginx 的文件夹下的 nginx.conf，配置 server{} 里的内容。
server { listen 443 ssl; server_name lvhaosir.cn www.lvhaosir.cn; ssl on; #root html; #index index.html index.htm; ssl_certificate cert/a.pem; #.pem文件的地址 ssl_certificate_key cert/a.key; #.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d3ac0146123e458a2cef5a5a576bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb81429afe583339bc96e8933e47a751/" rel="bookmark">
			yolov5不能检测长宽比超过20的目标的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用YOLOv5代码的时候，发现yolov5对长宽比很大，如超过100+的目标检测，完全检测不出来，
之前一直怀疑是anchors设置有问题，验证了很多次，证明不是anchors的问题，
最后经组内小伙伴提醒，yolov5在数据增强的时候，默认设置了目标的长宽比最大为20，需要修改的文件（utils/datasets.py）
def box_candidates(box1, box2, wh_thr=2, ar_thr=20, area_thr=0.1, special_classes=0): # box1(4,n), box2(4,n) # Compute candidate boxes: box1 before augment, box2 after augment, wh_thr (pixels), aspect_ratio_thr, area_ratio w1, h1 = box1[2] - box1[0], box1[3] - box1[1] w2, h2 = box2[2] - box2[0], box2[3] - box2[1] ar = np.maximum(w2 / (h2 + 1e-16), h2 / (w2 + 1e-16)) # aspect ratio return (w2 &gt; wh_thr) &amp; (h2 &gt; wh_thr) &amp; (w2 * h2 / (w1 * h1 + 1e-16) &gt; area_thr) &amp; (ar &lt; ar_thr) # candidates 修改为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb81429afe583339bc96e8933e47a751/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/357/">«</a>
	<span class="pagination__item pagination__item--current">358/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/359/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>