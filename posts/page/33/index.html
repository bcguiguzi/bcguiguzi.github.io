<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d362876c8bf02d2e581b9493781c939/" rel="bookmark">
			二，几何相交---4，BO算法---（3）数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构分两块，一个是某一时间状态的局部相交线段。一个是事件队列，是某一时刻局部相交线段的集合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ab8750de4cb456823d507a14545514/" rel="bookmark">
			保护数字前沿：有效的威胁暴露管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能技术正在从根本上改变网络安全领域的方向。仅 2023 年，全球企业预计将在人工智能上花费 1027.8 亿美元，以阻止网络安全威胁。
人工智能 (AI)在增强网络安全措施方面发挥着关键作用，因为它能够快速分析大量数据并识别可能表明潜在威胁的模式。随着数字技术的普及，网络威胁变得越来越复杂，使得传统的网络安全方法不再有效。
人工智能驱动的系统可以实时检测异常情况并识别恶意活动，使组织能够在网络攻击造成重大损失之前迅速做出响应。此外，人工智能算法可以适应和学习新数据，不断提高检测和缓解新兴威胁的能力，从而提供针对不断演变的网络威胁的主动防御机制。
人工智能可以实现各种网络安全任务的自动化，减轻人类分析师的负担，使他们能够专注于网络安全运营中更复杂和更具战略性的方面。网络监控、威胁检测和事件响应等任务可以使用人工智能算法实现自动化，从而使组织能够在网络安全工作中实现更高的效率和可扩展性。
此外，机器学习和自然语言处理等人工智能驱动的技术可以帮助组织分析和理解大量与安全相关的数据，使他们能够做出明智的决策，并根据不同威胁带来的风险级别确定行动的优先级。总体而言，人工智能使组织能够通过更快地检测、响应和缓解威胁来加强其网络安全态势，同时提高应对网络威胁的运营效率和敏捷性。
在不断变化的数字威胁形势下，对强有力的网络安全措施的需求从未如此强烈。这些保护策略的最前沿是威胁暴露管理 ( TEM )，这是一种保护组织数字基础设施的综合方法。
本文深入探讨了威胁暴露管理，包括其定义、目标、关键组成部分、实施策略、威胁情报的集成、降低风险的步骤以及持续监控的重要性。
探索网络安全中威胁暴露管理的概念
威胁暴露管理是一项多方面的策略，旨在识别、评估和缓解组织数字网络中的漏洞。这不仅仅是应对威胁，而是主动管理威胁。这包括全面了解组织的数字资产、它们面临的潜在威胁以及可能被利用的漏洞。
威胁暴露管理的目标
威胁暴露管理的首要目标是强化组织的数字生态系统。它致力于保护敏感数据，确保业务运营不间断，并遵守法律和监管标准。威胁暴露管理的目标还包括减少攻击面、最大限度地减少安全漏洞的可能性以及培养网络安全意识文化。
威胁暴露管理策略的核心组成部分
有效的威胁暴露管理计划由几个关键要素组成，其中包括以下内容：
1. 漏洞管理：系统地识别、分类和解决安全漏洞。
2. 威胁评估：根据行业、规模和其他因素了解组织可能面临的威胁类型。
3. 风险分析：评估已识别的威胁和漏洞对组织的潜在影响。
4. 事件响应计划：制定协议以有效响应安全事件并从中恢复。
实施威胁暴露管理计划：策略和最佳实践
威胁暴露管理计划的有效实施涉及：
▶ 建立全面的网络安全框架。
▶ 利用尖端的安全工具和技术。
▶ 定期对员工进行安全最佳实践培训。
▶ 确保持续改进和适应新威胁。
威胁情报在增强威胁暴露管理中的作用
威胁情报在威胁暴露管理中至关重要，因为它能够提供有关新兴威胁和趋势的可行见解。这种情报可以来自多种来源，包括行业报告、安全公告和威胁数据库。将此情报集成到威胁暴露管理实践中使组织能够领先于潜在威胁。
有效降低风险暴露的步骤
为了最大限度地减少风险暴露，组织应该：
▶ 定期进行安全审计和评估。
▶ 根据风险的严重性和潜在影响确定风险的优先级。
▶ 制定并实施针对这些风险的缓解策略。
▶ 不断更新和完善其安全措施。
威胁暴露管理连续监测的必要性
出于多种原因，连续监测在威胁暴露管理中至关重要。
▶ 它允许实时检测安全事件。
▶ 它有助于快速识别和响应新漏洞。
▶ 它确保持续遵守安全策略和标准。
总之，威胁暴露管理是网络安全中一个关键的、动态的、持续的过程。通过深入了解其各个方面并努力应用其原则，组织可以显着增强对不断增长和演变的网络威胁的防御能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafa87b2b370470716760a7972b23de9/" rel="bookmark">
			datax定时轮询时间小于同步处理时间怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果DataX的定时轮询时间小于同步处理时间，可能导致新的同步任务在上一个任务完成之前启动，从而引起并发执行或任务重叠。为了解决这个问题，你可以考虑以下几种方式：
1. 增加定时轮询时间：调整定时轮询的时间，确保新的同步任务启动的时间间隔大于上一个任务的处理时间。这样可以避免任务重叠。
2. 等待上一个任务完成后再启动新任务：在代码中增加逻辑，确保新任务启动时检查上一个任务是否完成。只有上一个任务完成后，才启动新的同步任务。
3. 使用锁机制或标志位：在任务启动和完成时使用锁机制或标志位进行控制，以确保同一时间只有一个任务在执行。这样可以防止并发执行。
4. 分布式调度：如果系统规模较大，可以考虑使用分布式调度工具，如Quartz等，以更精细地控制任务的调度和并发。
这些方法的选择取决于你的具体需求和系统架构。通常情况下，通过合理调整定时轮询时间或引入一些同步控制机制，可以有效地避免同步任务的重叠问题。
针对第2点给出一个c#控制实例
下面是一个简单的C#示例，演示如何在任务启动时检查上一个任务是否完成，确保同一时间只有一个任务在执行。这使用了`System.Threading.Mutex`来实现简单的互斥锁：
```csharp
using System;
using System.Threading;
class Program
{
// 互斥锁对象
static Mutex mutex = new Mutex();
static void Main()
{
// 启动定时器，每隔一段时间触发一次任务
Timer timer = new Timer(TimerCallback, null, 0, TimeSpan.FromHours(1).Milliseconds);
// 阻止主线程退出，保持定时任务运行
Console.ReadLine();
}
private static void TimerCallback(object state)
{
// 尝试获取互斥锁，如果已经被其他任务占用，则不执行任务
if (mutex.WaitOne(TimeSpan.Zero))
{
try
{
// 在这里执行同步任务
StartDataXJob();
}
finally
{
// 释放互斥锁
mutex.ReleaseMutex();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fafa87b2b370470716760a7972b23de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07893c5fa9b0118ac03877db31280bb7/" rel="bookmark">
			C#&#43;datax实现定时增量同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使用C#和DataX实现定时增量同步，你可以使用以下步骤：
1. 安装DataX：首先，确保你已经安装了DataX。你可以从DataX的官方仓库中获取最新版本。
2. 配置DataX 任务：创建一个DataX任务，定义源（source）和目标（target）的连接信息，以及需要同步的表和字段信息。
3. 编写C# 定时任务：使用C#编写一个定时任务，可以使用`System.Threading.Timer`类或者使用.NET Core中的Hosted Services（托管服务）来实现。在定时任务中，启动DataX任务并执行同步操作。
以下是一个简单的伪代码示例：
csharp代码
using System;
using System.Threading;
class Program
{
static Timer timer;
static void Main()
{
// 设置定时器，每隔一段时间触发一次任务
timer = new Timer(TimerCallback, null, 0, TimeSpan.FromHours(1).Milliseconds);
// 阻止主线程退出，保持定时任务运行
Console.ReadLine();
}
private static void TimerCallback(object state)
{
// 在这里启动 DataX 任务进行增量同步
StartDataXJob();
}
private static void StartDataXJob()
{
// 调用 DataX 命令行执行同步任务
// 例如：System.Diagnostics.Process.Start("datax.py", "your_task.json");
}
}
```
请根据你的实际需求和DataX任务的具体配置进行相应的修改。确保在定时任务中调用DataX命令行执行同步任务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea990a053457f37cc14aac41b8e1503/" rel="bookmark">
			[JAVAEE]—进程和多线程的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是线程什么是进程进程的组成什么是pcb 进程概括线程线程与进程的关系线程的特点 创建线程创建线程方法创建线程的第二种方法对比 其他的方式匿名内部类创建线程匿名内部类创建Runable的子类lambda表达式创建一个线程 多线程的优势 什么是线程 什么是进程 首先想知道什么是线程就得先搞明白什么是进程，关于进程呢，我们说进程是系统进行资源分配的基本单位但是光知道这句话远远不够，因为我们不知道什么是资源分配，我们可以简单的将计算机理解为钱包。
那么资源就是钱包里的钱，至于进程就是我们要做的事情或者说要买的东西，比如说旅游啊买衣服啊。我们把资源（也就是钱）进行了划分，那一部分用来旅游哪一部分用来买衣服做了明确的划分，而这就是资源分配，至于买衣服啊之类的就是我们的进程。
进程的组成 进程是由自己的代码和pcb组成的我们上面说了，进程就是我们要执行的任务，那么在计算机中计算机要执行的任务其实就是我们写的程序，因此我们可以这样理解我们运行了一个程序那么这个程序在我们后台中就是一个进程了。他也正如其名字一样，进行中的程序。由此我们可以知道进程就是我们运行的代码，那么刚刚说的pcb又是什么呢？
什么是pcb 我们运行一个代码那么操作系统就要管理我们运行的程序代码怎么管理呢？那就是先描述再组织，相信大家对这句话应该不陌生吧。那么我们想要描述一个进程该怎么办？就像我们想要描述一个人我们需要把这个人的各种特点记录起来一样，描述进程也是这样把这个进程的各种特点记录下来，而这些特点用一个结构体保存下来这个结构体就是pcb，因此一个进程由什么组成呢？那就是自己的代码+pcb
进程概括 简单来讲进程的概念主要你有两点：
一：进程是一个运行中的实体每一个进程都有自己的内存空间包括堆栈啊等等
二：进程是一个执行的程序，他也需要被管理为了管理它系统中有一个用于存储其基本信息的结构体叫做PCB
线程 什么是线程呢？有了上面的概念我们就可以来讲一下线程了，如果说进程是进行资源分配的基本单位的话那么线程就是**线程是CPU独立运行和独立调度的基本单位。**有些同学可能就蒙了啊什么是cpu独立运行和独立调度呢？我们在购买电子设备的时候我们知道cpu会说他是几核几核的这些核心就是我们用来运行线程的。那么知道这些是不够的，对于初学者来说还是不知道线程到底是什么他跟进程到底有什么关系啊？那么我们现在就来解决一下这个疑惑。
线程与进程的关系 我们上面说了进程就是一个任务，我们去购物，旅游这样的一个任务，那么线程是什么呢？线程则是任务的步骤或者说是任务的分支，就像我们为了完成购物这个任务我们需要分成以下几个步骤那就是第一乘车去商场，第二挑选商品，第三付账，那么以上为了完成这个任务创建的分支就是线程，由此可见线程其实就是进程的分支.那么我们现在就知道为什么了解线程之前要了解进程了。
总结一下目前已知的知识点
线程是进程的一个分支
线程被创建出来是为了执行某个任务
线程是cpu独立运行和独立调度的基本单位.
线程的特点 通过以上的知识我们可以知道线程的哪些特点呢?
线程是轻量级的进程
线程没有独立的地址空间
线程依附于进程进程可以拥有多个线程
创建线程 通过以下的代码来感受以下线程和普通程序的区别吧
class Mytheard extends Thread{ public void run(){ while (true){ try { sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println("我是一个线程"); } } } public class Main { public static void main(String[] args) throws InterruptedException{ Thread ne=new Mytheard(); ne.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea990a053457f37cc14aac41b8e1503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf8fdc2126e57d2132bcdca8a9e009e/" rel="bookmark">
			Ribbon-负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、负载均衡的作用位置
二、Ribbon负载均衡的工作流程
三、IRule接口
负载均衡的策略：
修改负载均衡策略（即修改使用的IRule接口的实现类）：
四、饥饿加载
五、总结
前置知识：Eureka注册中心
不熟悉Eureka的可以先看一下前一个文章（上面链接）。
一、负载均衡的作用位置 我们最开始学习的时候，用浏览器来访问的时候都是直接输入ip地址+端口号，而在上面这次请求中，我们只是用了服务的名称就能找到相应的服务，那是因为我们配置了Eureka，帮我们进行了转换，如果我们未配置Eureka，直接用之前那种localhost:userservice/test当然是不能直接成功的。
Ribbon的作用就是当我们得到一个服务列表，有多个匹配的服务时，ribbon就是做这种选择的，帮助我们选择其中的一个服务执行。当然Ribbon也是有不同的策略来选择服务的。
二、Ribbon负载均衡的工作流程 当我们发起一个请求，如http://userservice/user/1这个请求，他会被RibbonLoadBanlancerClient拦截，并且会获取到主机名：userservice然后再将该值传给DynamicSercerListLoadBalancer，然后通过这个类来向Eureka服务中心通过userservice拉取服务列表，如localhost:8081,localhost:8082等传回DynamicSercerListLoadBalancer的实例对象，再通过Rule对象，其实现IRule的接口，来完成服务负载均衡选择出一个服务，最终返回RibbonLoadBanlancerClient的对象，再修改原先的URL，重新发出请求，请求到真正的URL。
三、IRule接口 Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则:
负载均衡的策略： 修改负载均衡策略（即修改使用的IRule接口的实现类）： 通过定义IRule实现可以修改负载均衡规则，有两种方式:
1.代码方式:再配置类中定义一个新的IRule（全局配置，调用的所有服务都采用这种方式）:
@Bean public IRule randomRule(){ return new RandomRule(); } 2.配置文件方式:在配置文件中添加新的配置也可以修改规则，只能针对某个微服务而言（userservice）:
userservice: ribbon: NFLoadBalancerRuleClassName: com.netfix.loadbalancer.RandomRule #负载均衡规则 四、饥饿加载 Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载:
五、总结 1.Ribbon负载均衡规则
规则接口是IRule
默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询
2.负载均衡自定义方式
代码方式:配置灵活，但修改时需要重新打包发布
配置方式:直观，方便，无需重新打包发布但是无法做全局配置
3.饥饿加载
开启饥饿加载
指定饥饿加载的微服务名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7acd85a0fee5638a519c7a7ee75a71/" rel="bookmark">
			代码随想录算法训练营day57|第九章 动态规划part17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
647. 回文子串 516.最长回文子序列 动态规划总结篇 647. 回文子串 动态规划解决的经典题目，如果没接触过的话，别硬想 直接看题解。
代码随想录
这道题对dp数组的定义就很特别，事实上，对于dp数组的定义一般会和题目所要求的东西有关，但这道题不同，因为不难发现dp[i] 和 dp[i-1] ，dp[i + 1] 看上去都没啥关系。但是仔细考虑会发现一种递推关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于它的子字符串（下表范围[i + 1, j - 1]）） 是否是回文，如果子字符串回文，那只要判定两端的字符是否相等即可。由此也可见，只凭借一维数组是没办法同时反映左端点和右端点两个要素的，故而需要使用二维数组，因为依赖关系是“是否”，所以必然要使用bool类型的dp数组，dp[i][j]表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
递推公式还是依据上面来看还是要先判断两个字符是否相等，因为如果两端的字符不相等，那就一定不能构成回文串，只有相等才能进一步判定；相等，那就判断两端点所涵盖的字符个数，如果只包含一个字符或两个字符，内部根本不可能有别的回文子串，那就直接判定是回文子串，而如果不止，那就要判断dp[i+1][j-1]是否为true，也就是内部是否是回文子串。
这个递推公式需要从左下角来推导当前元素的值，所以必然要正向遍历j，反向便利 i，而且因为 i 代表左端点、j 表示右端点，所以必然要 j&gt;=i ，也就是 j 从 i 开始向后遍历。涉及到初始化的问题，因为没有正式判断之前是不能武断地确认当前子串是回文子串的，所以必然要全部初始化为false。
注意还要用res来捡拾结果。
int countSubstrings(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i &gt;= 0; i--) { // 注意遍历顺序 for (int j = i; j &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7acd85a0fee5638a519c7a7ee75a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4229f56ec35c0b7627528e12afe990c4/" rel="bookmark">
			hanlp，pyhanlp 实现 NLP 任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
区别
hanlp 代码使用
pyhanlp 代码使用
在线体验：命名实体识别 | 在线演示
区别 hanlp：是 githun 官方文档提供的使用方法，也就是在线的，调用 api 的方式去实现的，可以自己申请 token，接口分为 RESTful 轻量级，native 海量级 GitHub - hankcs/HanLP: 中文分词 词性标注 命名实体识别 依存句法分析 成分句法分析 语义依存分析 语义角色标注 指代消解 风格转换 语义相似度 新词发现 关键词短语提取 自动摘要 文本分类聚类 拼音简繁转换 自然语言处理
pyhanlp：为 hanlp 的一个封装，可以理解为离线的，不需要调 api Hanlp、pyhanlp 的区别是什么？ - #2 由 Viserion - 综合讨论 - HanLP中文社区
hanlp 代码使用 使用它的话，可能不能链科学上网，要不然连不上，我切断后就正常了，要是什么任务，点对应任务链接，有示例调用代码的：
pyhanlp 代码使用 from pyhanlp import * # 分词 sentence = "我爱自然语言处理技术！" s_hanlp = HanLP.segment(sentence) for term in s_hanlp: print(term.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4229f56ec35c0b7627528e12afe990c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7a49038036741516d47e30272553c2/" rel="bookmark">
			网页脚本 bilibili006：视频下载脚本修改&#43;油猴脚本发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频下载脚本修改 原始脚本的下载的视频名称总是错的，调用的代码为 document.querySelector('.tag-txt').textContent ，发现这是标签的名称 查找视频名称所在的类名称
&lt;h1 title="任天堂告yuzu模拟器，龙神模拟器会被殃及池鱼吗" class="video-title" data-v-4f1c0915=""&gt;任天堂告yuzu模拟器，龙神模拟器会被殃及池鱼吗&lt;/h1&gt; 将代码更新为： document.querySelector('.video-title').textContent，经测试可以正确进行下载 油猴脚本发布 用自己的电子邮箱和密码注册，然后登陆 点击发布脚本即可
添加一个第三方账户
填写代码并发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1703c9b31738c5406244d32570be95d/" rel="bookmark">
			UE5 C&#43;&#43; TPS开发p23 Gamemode 玩家数量 玩家名称 Tips如何搜索 如何查找文档 如何查找源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节课学习了创建游戏模式,可以读取到现在的玩家有多少人
我对这一部分的理解是游戏这个框架中分别分为Gamemode和GameState这两块,同时GameMode是可以访问GameState的.Gamemode的作用是游戏规则,移动角色到下一个关卡,设置每个玩家该在的出生点,监听玩家加入(PostLogin)和玩家注销(Logout).GameState是负责当前游戏的状态并且保存下来,比如得分,游玩进度,多人游戏则是把每个玩家作为变量放在数组内,再通过这个数组去分别对每个玩家的状态进行处理
这里记一下怎么利用搜索
然后搜索ue5 PostLogin
在文档中可以找到这一段
virtual void PostLogin ( APlayerController * NewPlayer )
把这一段复制到编译器内
如何找到需要的变量
这里右键转到定义
可以看见这个是继承Acontroller,继续查找定义
在新的定义中查询GetPlayerState
于是就可以用PlayerState这个模板获得到指针变量上
APlayerState* PlayerState = NewPlayer-&gt;GetPlayerState&lt;APlayerState&gt;();
在UE内创建新的游戏模式,命名LobbyGamemode
LobbyGameModeBase.h
// Fill out your copyright notice in the Description page of Project Settings. #pragma once #include "CoreMinimal.h" #include "GameFramework/GameModeBase.h" #include "LobbyGameModeBase.generated.h" /** * */ UCLASS() class MENU_API ALobbyGameModeBase : public AGameModeBase { GENERATED_BODY() public: //这里是为了重写基类函数,所以加了override virtual void PostLogin(APlayerController * NewPlayer) override; virtual void Logout(AController* Exiting) override; };
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1703c9b31738c5406244d32570be95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418edf6801168776daf4eeb7568374f3/" rel="bookmark">
			ios手机在app中调试h5页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对场景 网页开发在浏览器里调试很方便，但是在移动端开发调试，例如需要在app中打开，会用到一些bridge , 这时候就不能在浏览器调试。在app调试，如果每次都要发布到测试环境才能调试，那就会浪费很多时间。
页面调试 可以通过charls来做一个代理 从而在手机app里调试h5页面 安装charles安装好以后，设置代理 查看电脑IP地址，确保手机和电脑练的是同一个网络，然后在手机上的wifi设置手动代理，IP是电脑地址，端口号是charles设置的8888 , 在这个地方可以看到电脑的ip
填写好wifi代理后就可以下载证书了 点击这个后 手机Safari访问 chls.pro/ssl 下载证书
如果没有弹出下载证书的链接 请检查
title: ios手机在app中调试h5页面
tags: [charls]
date: 2023-03-10 16:09:29
categories: [charls] 针对场景 网页开发在浏览器里调试很方便，但是在移动端开发调试，例如需要在app中打开，会用到一些bridge , 这时候就不能在浏览器调试。在app调试，如果每次都要发布到测试环境才能调试，那就会浪费很多时间。
页面调试 可以通过charls来做一个代理 从而在手机app里调试h5页面 安装charles安装好以后，设置代理 查看电脑IP地址，确保手机和电脑练的是同一个网络，然后在手机上的wifi设置手动代理，IP是电脑地址，端口号是charles设置的8888 , 在这个地方可以看到电脑的ip
填写好wifi代理后就可以下载证书了 点击这个后 手机Safari访问 chls.pro/ssl 下载证书
下载完证书后 去设置=&gt; 通用 =&gt; vpn与设备管理安装证书
安装完证书后去通用里的关于本机里信任证书 (不信任会导致无法联网)
现在就可以在手机中访问h5页面了
如果没有弹出下载证书链接 请检查这里面是否填写了本机的ip 下载完证书后 去设置=&gt; 通用 =&gt; vpn与设备管理安装证书
安装完证书后去通用里的关于本机里信任证书 (不信任会导致无法联网)
现在就可以在手机中访问h5页面了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53d750d35acf8540a0decd8b1b2ec80/" rel="bookmark">
			vue的导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import { onMounted, onUpdated, onUnmounted } from ‘vue’;
单一导出（不使用 {}）：通常用于导入vue组件
当一个模块只导出一个内容时，可以直接导入，无需使用 {}。多个导出（使用 {}）：通常用于导入函数
当一个模块导出多个内容时，需要使用 {} 来指定导入的内容。 import { onMounted, onUpdated, onUnmounted } from 'vue'; import { createRouter, createWebHistory } from 'vue-router'; import { createPinia } from 'pinia'; // customDirective.js export const myDirective = { // ... }; // 在其他文件中导入 import { myDirective } from './customDirective.js'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9457854fa944d38170693cd2932e867/" rel="bookmark">
			【Go】深入理解 Go map：赋值和扩容迁移 ①
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 map底层实现hmapbmap map hash冲突了怎么办？ map扩容触发扩容时机扩容小结为什么map扩容选择增量（渐进式扩容）？迁移是逐步进行的。那如果在途中又要扩容了，怎么办？ map翻倍扩容原理 map写入数据内部执行流程写入数据读取数据 map扩容总结 map优化点map gc优化手段利用bigcache优化全局mapgo-zero safemap 避免OOM分析 Sync.mapSync.map底层结构​​sync.map优点sync.map实现总结 问题1.golang map为什么不支持并发安全？ map底层实现 熟悉 map 结构体的读者应该知道，hmap 由很多 bmap（bucket） 构成，每个 bmap 都保存了 8 个 key/value 对：
hmap
有时落在同一个 bmap 中的 key/value 太多了，超过了 8 个，就会由溢出 bmap 来承接，即 overflow bmap（后面我们叫它 bucket）。溢出的 bucket 和原来的 bucket 形成一个“拉链”。
对于这些 overflow 的 bucket，在 hmap 结构体和 bmap 结构体里分别有一个 extra.overflow 和 overflow 字段指向它们。
hmap // A header for a Go map. type hmap struct { count int // map内的元素个数，调用 len(map) 时，直接返回此值 flags uint8 // 标志位，例如表示map正在被写入或者被遍历 B uint8 // buckets 的对数 log_2，即含有 2^B 个buckets。这样的好处是方便用位操作实现取模 noverflow uint16 // 溢出桶的近似数 hash0 uint32 // 哈希种子 buckets unsafe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9457854fa944d38170693cd2932e867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19276658c3708124e1bd3c3445352dbf/" rel="bookmark">
			【Go】标准库底层实现 ①
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基本类型1.1string面试题：字符串转byte数组时，是否会发生内存拷贝？ 1.2 slice切片是什么切片扩容规则 1.4 channel实现channel 的概念 1.6 interface接口 context原理context是如何传递的？context是如何触发取消的cancelCtx类型timerCtx timetime.sleep() time.Tick()优劣性对比 reflect什么是反射为什么要用反射,（需要反射的 2 个常见场景） new makeselect 底层实现 sync系列sync.poolsync.Pool 适应场景sync.Pool使用示例源码分析 指针系列Golang指针与C/C++指针的差别unsafeunsafe.pointerstring类型和[]byte之间的零拷贝转换[]byte转化成stringstring转化成[]byte uintptr指针运算 reflect (todo)defer+recoverpanic defer revover定义10种panic方法：panic实现recovery recover实现总结defer recover 小结 1.基本类型 1.1string StringHeader是字符串在Go的底层数据结构：
type StringHeader struct { Data uintptr Len int } 面试题：字符串转byte数组时，是否会发生内存拷贝？ 解析：字符串转切片一定会产生内存拷贝，严格来说，只要是发生数据类型转换都会发生内存拷贝。
，因为频繁的内存拷贝听起来对于性能来说不是很友好，那就要想想有没有什么办法使得字符串在转切片的时候不发生内存拷贝呢？
SliceHeader是切片在G的底层数据结构：
type SliceHeader struct { Data uintptr Len int Cap int } package main ​ import ( "fmt" "reflect" "unsafe" ) ​ func main() { a := "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19276658c3708124e1bd3c3445352dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3ff58517799b698c26f04173f684c2/" rel="bookmark">
			DayDreamInGIS 之 ArcGIS Pro二次开发 锐角检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：检查图斑中所有的夹角，如果为锐角，在单独的标记图层中标记。生成的结果放在默认gdb中，以 图层名_锐角检查 的方式命名
大体实现方式：遍历图层中的所有要素（多部件要素分别处理），对每个夹角进行判断。
具体功能与ArcMap中锐角检查工具类似
DayDreamInGIS数据处理工具 V1.1.5_beta 锐角检查工具源码与解析_daydreamingistool-CSDN博客
工具界面：
（使用prowindow，样式确实更和谐）
界面代码：
&lt;controls:ProWindow x:Class="DayDreamInGISTool.CornerCheck.CornerCheckWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:controls="clr-namespace:ArcGIS.Desktop.Framework.Controls;assembly=ArcGIS.Desktop.Framework" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:extensions="clr-namespace:ArcGIS.Desktop.Extensions;assembly=ArcGIS.Desktop.Extensions" mc:Ignorable="d" Title="锐角检查" Width="500" Height="200" WindowStartupLocation="CenterOwner" &gt; &lt;controls:ProWindow.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;extensions:DesignOnlyResourceDictionary Source="pack://application:,,,/ArcGIS.Desktop.Framework;component\Themes\Default.xaml"/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/controls:ProWindow.Resources&gt; &lt;Grid Margin="5"&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition&gt;&lt;/RowDefinition&gt; &lt;RowDefinition&gt;&lt;/RowDefinition&gt; &lt;RowDefinition&gt;&lt;/RowDefinition&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="90"&gt;&lt;/ColumnDefinition&gt; &lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Label VerticalAlignment="Center" HorizontalAlignment="Right"&gt;图层&lt;/Label&gt; &lt;ComboBox Grid.Column="1" Name="cmbLayer" VerticalAlignment="Center" Height="27"&gt;&lt;/ComboBox&gt; &lt;/Grid&gt; &lt;Grid Grid.Row="1"&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="90"&gt;&lt;/ColumnDefinition&gt; &lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Label VerticalAlignment="Center" HorizontalAlignment="Right"&gt;角度阈值(度)&lt;/Label&gt; &lt;TextBox Grid.Column="1" Name="txtYuzhi" VerticalAlignment="Center" Height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3ff58517799b698c26f04173f684c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62290b5aa8353e72d1bc0f6592bf244/" rel="bookmark">
			关于tomcat服务器配置及性能优化的20道高级面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请描述Tomcat服务器的基本架构和组件。 Tomcat服务器的基本架构主要包括Server、Service、Connector和Container等组件。具体来看：
Server：是Tomcat中最顶层的容器，代表着整个服务器。它负责运行Tomcat服务器，例如打开和关闭服务器，加载服务器运行所需的环境变量和服务器资源。Service：一个Server可以包含至少一个Service，用于具体提供服务。Service主要包含两个部分：Connector和Container。Service是Tomcat中的一个重要组件，它定义了一组Connector和一个Engine。Connector：Connector是Tomcat的核心组件之一，提供给外来客户的连接，可基于不同协议的实现，最常用的是HTTP协议。Connector负责处理来自客户端的请求，并将其转发给相应的Container进行处理。Container：Container是Tomcat中的另一个核心组件，用于处理Web应用程序。Container负责处理Connector转发过来的请求，执行相应的业务逻辑，并将结果返回给客户端。 除了上述组件外，Tomcat还包含了其他一些辅助组件，如Realm（用于管理用户认证）、Valve（用于控制请求和响应的流程）等。这些组件共同构成了Tomcat服务器的整体架构，使其能够高效地处理Web应用程序的请求和响应。
2. Tomcat的连接器（Connector）是什么？它有哪些类型和配置选项？ Tomcat的连接器（Connector）是负责处理外部请求并转发到Web应用程序的组件，主要包括HTTP和AJP两种类型，同时还有一些其他的属性可以进行配置。
首先，Tomcat的连接器是Tomcat服务器中的一个核心组件，它负责接收客户端的请求并将其转发给相应的引擎（Engine）进行处理。
其次，在Tomcat中主要有以下几种类型的连接器：
HTTP连接器：这是最常用的连接器类型，它支持HTTP/1.1协议，使得Catalina能够作为独立的Web服务器运行。HTTP连接器侦听特定的TCP端口号上的连接，并将请求转发给关联的引擎。AJP连接器：这种类型的连接器用于使用AJP协议与Web服务器通信，例如与Apache 1.3服务器的mod_jk 1.2.x接口连接。AJP连接器可以提供更好的性能，因为它允许Tomcat与其他Web服务器集成，从而分担负载。SSL连接器：这种连接器用于支持通过SSL/TLS加密的HTTP通信，确保数据传输的安全性。proxy连接器：这种连接器可以用作负载均衡器或反向代理，将请求转发到后端的多个服务器。 此外，在配置连接器时，有一些常见的属性可以考虑：
port：指定Tomcat监听的端口号，用于接受客户端的连接请求。protocol：设置使用的网络协议，如"HTTP/1.1"或"AJP/1.3"等。maxThreads：定义连接器可以同时处理的最大线程数，超过这个数量的新线程将不会被创建。enableLookups：是否允许在日志文件中记录客户端的远程地址。connectionTimeout：设置连接超时时间，如果在这个时间内没有活动，连接将被关闭。 综上所述，了解和正确配置Tomcat的连接器对于优化服务器的性能和安全性至关重要。
3. 如何配置Tomcat以支持多个域名和虚拟主机？ 要配置Tomcat以支持多个域名和虚拟主机，您需要进行以下步骤：
编辑server.xml： 打开Tomcat安装目录下的conf文件夹中的server.xml文件。这个文件包含了Tomcat服务器的主配置。 添加Host元素： 在server.xml文件中，找到或添加&lt;Engine&gt;标签内的&lt;Host&gt;元素。每个&lt;Host&gt;元素代表一个虚拟主机。 配置域名和路径： 为每个&lt;Host&gt;元素设置name属性为您想要绑定的域名，例如example1.com。同时，设置appBase属性指向该域名对应的Web应用的路径，如webapps/example1。 保存并重启Tomcat：完成上述配置后，保存server.xml文件的更改，并重启Tomcat服务器以使配置生效。 此外，如果您希望所有未明确指定虚拟主机的请求都被发送到某个特定的主机，您还需要在&lt;Engine&gt;标签中设置defaultHost属性。
通过以上步骤，您可以在Tomcat中配置多个域名和虚拟主机，使得不同的域名可以访问到部署在相应路径下的Web应用。这样的配置不仅有助于管理多个网站，还能提高服务器资源的利用率。
4. 请解释Tomcat的线程模型，包括BIO、NIO和APR。 Tomcat服务器支持BIO（Blocking I/O）、NIO（Non-blocking I/O）和APR（Apache Portable Runtime）三种线程模型。具体来看：
BIO（Blocking I/O）模型： BIO是Tomcat的默认线程模型，它使用传统的Java I/O操作（即java.io包及其子包）。在BIO模型中，Tomcat通过Acceptor接收socket连接请求，然后将请求封装成SocketProcessor连接线程，放入连接池中处理。BIO模型在处理大量并发请求时性能较差，因为它为每个请求分配一个线程，这在并发量较大时会导致线程资源的耗尽。 NIO（Non-blocking I/O）模型： NIO是Java SE 1.4及后续版本提供的一种基于缓冲区的非阻塞I/O操作方式（即java.nio包及其子包）。NIO模型提供了比BIO更好的并发性能，因为它可以在单个线程上处理多个连接，减少了线程的使用数量。要启用NIO模式，需要修改Tomcat的配置文件server.xml，将Connector的protocol属性设置为org.apache.coyote.http11.Http11Nio。 APR（Apache Portable Runtime）模型： APR是一个本地库，可以提供操作系统级别的控制，它允许Tomcat利用底层系统的功能来提高性能。使用APR可以实现更高的吞吐量和更低的延迟，特别是在高负载环境下。要在Tomcat中使用APR，需要安装APR库，并在Tomcat的配置文件中进行相应的配置。 综上所述，每种线程模型都有其适用场景，选择哪种模型取决于具体的应用需求和服务器环境。
5. 如何在Tomcat中配置JDBC连接池以提高数据库访问性能？ 在Tomcat中配置JDBC连接池以提高数据库访问性能，您需要遵循以下步骤：
选择连接池实现：Tomcat提供了自己的JDBC连接池实现，即org.apache.tomcat.jdbc.pool。这个连接池是多线程的，能够支持高并发场景。配置数据源：在Tomcat的context.xml文件中配置Resource元素，或者在server.xml中配置&lt;Resource&gt;，指定数据库的URL、驱动类名、用户名和密码。例如，对于MySQL数据库，驱动类名应填写com.mysql.jdbc.Driver。调整连接池参数：为了优化性能，您需要调整连接池的一些关键参数，如maxActive（最大活跃连接数）和maxIdle（最大空闲连接数）。合理设置这些参数可以确保连接池在高负载下的表现，并避免资源浪费。使用连接池：在Java代码中，通过JNDI查找数据源，获取数据库连接。这通常涉及到在web.xml中配置资源引用和在Java代码中使用InitialContext来查找数据源。监控和调优：在应用运行期间，监控连接池的性能指标，如连接数、等待连接的线程数等。根据监控结果，进一步调整连接池的配置参数，以达到最佳性能。集成Spring Boot：如果您的项目是基于Spring Boot的，可以直接将tomcat-jdbc作为依赖加入项目中，这样Spring Boot会自动配置Tomcat JDBC连接池。测试性能：在完成配置后，进行性能测试以确保连接池正常工作，并且确实提高了数据库访问性能。备份配置文件：在对Tomcat服务器进行任何配置更改后，建议备份相关配置文件，以便在出现问题时能够快速恢复。重启服务：在修改了连接池配置之后，需要重启Tomcat服务使新配置生效。 通过以上步骤，您可以有效地在Tomcat中配置JDBC连接池，以提高数据库访问性能。记得在实际环境中，根据您的具体需求和数据库类型，调整连接池的配置参数。
6. 请描述Tomcat的类加载机制，以及如何优化它以提高应用程序启动速度和内存使用效率。 Tomcat的类加载机制具有独特性，它不完全遵循JVM的双亲委派模型。
在Tomcat中，对于非基础类（即不是Java核心库中的类如Object或String），每个Web应用的类加载器（WebAppClassLoader）会首先尝试加载，如果无法加载，则交给commonClassLoader按照双亲委派模型处理。这种机制允许每个Web应用有自己的类加载器实例，从而保证应用之间的隔离性。Tomcat的类加载器有引导类加载器（Bootstrap）、扩展类加载器（Ext）、系统类加载器（System）以及Catalina和Common类加载器等。其中，Common类加载器负责加载那些位于$CATALINA_HOME/lib目录下的通用jar文件，而Catalina类加载器负责加载Tomcat服务器内部使用的类。
为了提高应用程序的启动速度和内存使用效率，可以考虑以下几个方面：
优化应用程序的包结构：避免不必要的包层次，减少类的数目，有助于类加载器更快地找到和加载类。合理配置CLASSPATH：确保CLASSPATH中不包含冗余或不必要的库，这样可以减少类加载器的搜索范围，提升启动速度。使用最新版本的JDK和Tomcat：随着JDK和Tomcat版本的更新，性能和类加载机制也在不断优化。调整JVM参数：合理设置JVM的内存分配策略，如-Xms和-Xmx参数，可以提高应用的启动速度和运行效率。清理WEB-INF/lib目录：移除Web应用中不再使用或不必要的库文件，减轻类加载器的负担。利用Tomcat的懒加载特性：Tomcat默认采用懒加载机制，即只有在首次访问时才会加载对应的类，合理利用这一特性可以推迟非关键组件的加载，从而提高启动速度。 通过上述措施，可以有效地优化Tomcat中Web应用的类加载，进而提升整个应用的性能。
7. 如何在Tomcat中配置JVM参数以优化性能？ 在Tomcat中配置JVM参数以优化性能，可以通过调整内存设置和垃圾回收策略来实现。具体来看：
内存调优： 调整堆内存大小：可以通过修改-Xms（初始堆大小）和-Xmx（最大堆大小）参数来控制JVM堆内存的大小。合理设置这两个参数可以避免频繁的垃圾回收和内存溢出。调整栈内存大小：通过-Xss参数可以设置每个线程的栈大小。适当增加栈大小可以减少栈溢出的风险。调整方法区大小：使用-XX:PermSize（初始方法区大小）和-XX:MaxPermSize（最大方法区大小）参数来调整方法区的大小。 垃圾回收策略调优： 选择合适的垃圾收集器：根据应用的特点选择适合的垃圾收集器，如Parallel GC、CMS GC或G1 GC。调整垃圾收集器的参数：例如，可以调整-XX:SurvivorRatio（Eden与Survivor空间的比例）、-XX:MaxTenuringThreshold（对象晋升到老年代的年龄阈值）等参数来优化垃圾回收的效率。 此外，在进行JVM参数调优时，建议先进行基准测试，记录调优前后的性能变化，并根据实际效果逐步调整参数以达到最佳性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d62290b5aa8353e72d1bc0f6592bf244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68283a4f96ba99fef87227a4d80318a6/" rel="bookmark">
			5.Java并发编程—JUC线程池架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JUC线程池架构 在Java开发中，线程的创建和销毁对系统性能有一定的开销，需要JVM和操作系统的配合完成大量的工作。
JVM对线程的创建和销毁： 线程的创建需要JVM分配内存、初始化线程栈和线程上下文等资源，这些操作会带来一定的时间和内存开销。JVM需要通过与操作系统的交互进行系统调用，涉及到资源分配、权限检查等操作。线程的销毁需要释放已分配的内存和其他系统资源，这也需要一定的开销。 操作系统对线程的管理： 操作系统在内核层面管理线程，每个线程都需要占用操作系统的资源，包括内存、CPU时间片、线程调度等。创建和销毁线程涉及到操作系统的系统调用，如创建线程栈、设置线程上下文、更新线程调度信息等。过多的线程会增加操作系统的负担，导致资源竞争和上下文切换的开销增加。 为了减少这些开销，Java引入了线程池的概念。线程池可以预先创建一定数量的线程，并重用这些线程来处理任务，从而减少线程的创建和销毁频率，提高系统的性能和效率。
使用线程池的主要优势包括：
减少线程创建和销毁的开销：线程池在应用启动时创建一定数量的线程，并将它们保存在池中，避免了频繁的创建和销毁操作。线程重用：线程池可以重用线程来执行多个任务，避免了反复创建线程的开销。动态调整线程数量：线程池可以根据任务负载情况动态调整线程数量，提高系统的处理能力和响应性能。管理和监控线程：线程池提供管理和监控线程的功能，可以设置线程的优先级、超时时间等，提供更好的线程控制和调优能力。 1.JUC线程池架构 在多线程编程中，任务都是一些经过抽象的工作单元，而线程就是让任务异步执行的基本机制。随着我们应用开发的扩张，线程和任务的管理也开始变得非常复杂，为了简化这些复杂的线程管理，这个时候就需要一个“管理者”，来统一管理线程及任务分配，这个就是线程池。
有关线程池接口 和 类的架构图大致如下
Executor（执行任务） Executor是Java异步目标任务的执行者接口，其目的就是来执行目标任务。Executor通过execute()接口来执行已经提交的Runnable目标实例。其目的就是将任务执行者，任务提交者分离开来。
Executor框架的主要目的是将任务的提交和执行进行解耦，将任务的创建和执行逻辑分离开来。通过使用Executor框架，可以将任务的提交和执行过程进行灵活管理，并提供了一些常用的线程池实现，简化了多线程编程的复杂性。
它只包含了一个方法
public interface Executor { /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the {@code Executor} implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command); } ExecutorService（提交任务） ExecutorService继承Executor。他是Java中异步目标任务的执行者服务接口，对外提供异步任务的接收服务。ExecutorService对外提供了接收异步任务并转发给执行者的方法，例如submit系列方法，invoke系列方法等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68283a4f96ba99fef87227a4d80318a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ea8a6fe892344ba14c2ed5640214ca/" rel="bookmark">
			volatile关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一.volatile 能保证内存可见性
1、volatile修饰的变量，能够保证“内存可见性”
2、演示实例
一.volatile 能保证内存可见性 1、volatile修饰的变量，能够保证“内存可见性” 代码在写入volatile修饰的变量的时候：
改变线程工作内存中volatile变量副本的值；将改变后的副本的值从工作内存刷新到主内存； 代码在读取volatile修饰的变量的时候：
从主内存中读取volatile变量的最新值到线程的工作内存中；从工作内存中volatile变量的副本； 2、演示实例 以下代码创建了两个线程，线程thread01一直在运行，因为isQuit静态变量等于0，但是thread02线程可以修改静态变量isQuit的值。按道理在thread02线程修改变量的值后，thread01线程就会停止运行，但是运行代码后，修改完变量，thread01线程并没有停止运行。原因是thread02线程在修改完isQuit变量的值后，存储在线程的工作内存中，并没有刷新到主内存中，所以thread01线程并没有读取到修改后的变量值，一直在运行。
public class Volatile { private static int isQuit=0; public static void main(String[] args) { Thread thread01 = new Thread(()-&gt;{ while (isQuit==0){ //循环啥也没有执行 //意味着一秒钟就会执行很多次 } System.out.println("thread01执行完毕..."); }); Thread thread02 = new Thread(()-&gt;{ System.out.print("请输入isQuit的值："); Scanner scanner = new Scanner(System.in); isQuit = scanner.nextInt(); }); thread01.start(); thread02.start(); } } 为了避免上述情况的发生，保证变量的内存可见性，引入volatile关键字。 private volatile static int isQuit=0;//volatile关键字让变量isQuit的内存变成可见性的 volatile 不保证原子性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3cfe6e6a7e8584fd150102a359a906b/" rel="bookmark">
			wait 和 notify方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1 wait()方法
wait 做的事情:
wait 结束等待的条件:
1.2 notify()方法 1.3notifyAll方法
1.4wait()和sleep()对比
由于线程之间是抢占式执行的, 因此线程之间执行的先后顺序难以预知. 但是实际开发中有时候我们希望合理的协调多个线程之间的执行先后顺序.
完成这个协调工作 , 主要涉及到三个方法 wait() / wait(long timeout): 让当前线程进入等待状态. notify() / notifyAll(): 唤醒在当前对象上等待的线程. 注意: wait, notify, notifyAll 都是 Object 类的方法. 1.1 wait()方法 wait 做的事情: 使当前执行代码的线程进行等待. (把线程放到等待队列中) 释放当前的锁 满足一定条件时被唤醒, 重新尝试获取这个锁. wait 要搭配 synchronized 来使用. 脱离 synchronized 使用 wait 会直接抛出异常. wait 结束等待的条件: 其他线程调用该对象的 notify 方法. wait 等待时间超时 (wait 方法提供一个带有 timeout 参数的版本, 来指定等待时间). 其他线程调用该等待线程的 interrupted 方法, 导致 wait 抛出 InterruptedException 异常.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3cfe6e6a7e8584fd150102a359a906b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599c02a6b8063627ebcaf9676b2d69a7/" rel="bookmark">
			关于Nginx服务器配置及性能优化的20道高级面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请解释Nginx服务器的工作原理。 Nginx服务器以高性能、稳定性和低资源消耗而著称，其工作原理主要涉及其多进程架构、反向代理功能以及模块组成。具体来看：
多进程架构：Nginx采用一个master进程和多个worker进程的架构。Master进程主要负责管理工作，如加载配置、启动worker进程等，不直接处理网络请求。Worker进程则负责处理客户端的请求和响应。反向代理：Nginx可以作为反向代理服务器，接收来自Internet的连接请求，然后将请求转发到内部网络上的服务器，并将结果返回给请求者。在这个过程中，Nginx对外表现为一个服务器，而客户端无需进行任何特别设置。模块化设计：Nginx由核心模块、基础模块和第三方模块组成。核心模块负责HTTP、EVENT和MAIL等功能，基础模块包括访问控制、FastCGI支持、代理和URL重写等，第三方模块则提供了更多的扩展功能。 此外，Nginx专为性能优化而开发，能够处理高并发连接，支持热部署，几乎可以做到不间断运行。它的配置简单，使用方便，因此在很多大型网站中得到了广泛应用。
总的来说，Nginx的工作原理体现了其作为现代Web服务器的优秀设计，它通过高效的进程模型、灵活的代理能力和模块化的结构，为用户提供了稳定和高性能的Web服务。
2. 在Nginx中，如何配置反向代理？ 在Nginx中配置反向代理主要涉及编辑Nginx的配置文件，使用proxy_pass指令来指定后端服务器的地址。以下是配置反向代理的具体步骤：
找到Nginx配置文件：通常，Nginx的主配置文件位于/etc/nginx/nginx.conf，而站点相关的配置文件可能位于/etc/nginx/sites-available/目录下。编辑配置文件：在配置文件中，你需要编辑server块，指定监听的端口和域名。然后，在location块中使用proxy_pass指令来设置反向代理。例如，如果你想将请求代理到本地的8080端口，你可以这样配置：server { listen 80; server_name example.com; location / { proxy_pass http://localhost:8080; } } 重启Nginx服务：完成配置后，保存文件并退出编辑器。然后，运行以下命令重启Nginx服务以使更改生效：sudo systemctl restart nginx 测试反向代理：最后，通过访问Nginx服务器的IP地址或域名来测试反向代理是否工作正常。如果一切配置正确，你应该能够看到后端服务器的内容。 需要注意的是，在配置反向代理时，确保防火墙和SELinux设置不会阻止Nginx的正常工作。如果有必要，关闭防火墙和SELinux或将它们设置为允许Nginx操作的模式。
此外，反向代理可以帮助隐藏后端服务器的信息，提高安全性，并且可以对后端服务器进行负载均衡，提高系统的可用性和性能。
3. 请解释Nginx中的负载均衡是如何工作的。 Nginx的负载均衡是通过将客户端的请求分发到不同的服务器上处理，以此来平衡每台服务器的工作负载。具体工作过程如下：
请求接收：当客户端发送HTTP请求时，Nginx作为反向代理服务器接收这些请求。模块选择：根据配置文件，Nginx会选择一个合适的处理模块（Handlers）来处理收到的HTTP请求。如果处理涉及到后端服务器，那么会使用负载均衡模块（load-balancers）。分发决策：负载均衡模块会根据配置的负载均衡策略来决定将请求发送到哪一台后端服务器。这个策略可以是轮询、最少连接、IP哈希、加权轮询等。请求转发：一旦决定了目标服务器，Nginx会将请求转发给它，并等待响应。结果返回：后端服务器处理完请求后，将响应数据返回给Nginx，然后Nginx再将这个响应返回给原始的客户端。 总的来说，通过这种机制，Nginx能够有效地分散请求压力，避免单点故障，提高网站或应用的稳定性和可用性。同时，它还支持多种负载均衡策略，可以根据不同的应用场景选择最合适的策略来实现性能优化。
4. 如何在Nginx中配置HTTPS？ 在Nginx中配置HTTPS需要进行以下步骤：
安装SSL模块：确保Nginx已经安装了SSL模块。如果不确定，可以通过检查Nginx的编译参数或查看已安装的模块来确认。获取SSL证书：您需要一个有效的SSL证书。可以选择从证书颁发机构（CA）购买，或者使用Let’s Encrypt等服务申请免费的SSL证书。配置Nginx：编辑Nginx的配置文件（通常是nginx.conf），在server块中添加关于SSL的配置。这包括指定SSL证书和私钥的路径，以及设置SSL协议版本和加密套件。例如： server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/your/certificate.crt; ssl_certificate_key /path/to/your/private.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html; index index.html index.htm; } } 重启Nginx服务：保存配置文件后，需要重启Nginx服务以使更改生效。通常可以使用命令sudo service nginx restart或sudo systemctl restart nginx来完成这一步骤。测试HTTPS连接：最后，使用浏览器或命令行工具如curl测试HTTPS连接是否正常工作。例如，可以尝试访问https://yourdomain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599c02a6b8063627ebcaf9676b2d69a7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/34/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>