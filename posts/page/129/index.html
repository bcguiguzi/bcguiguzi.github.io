<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a623aabbb0cdb71ac97f5b41437e50/" rel="bookmark">
			华为OD真题--分苹果-带答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有A，B两个同学想要分苹果。A的想法是使用二进制进行，1 + 1相加不进一位，如（9 + 5 = 1001 +101 = 12）。B同学的想法是使用十进制进行，并且进一位。会输入两组数据，一组是苹果总数，一组分别是每个苹果的重量。如果让B同学在满足A同学的情况下获取到苹果的总重量且返回，如果不能则返回-1。
输入
3
3 5 6
返回
11
备注：按照A同学的想法 5 + 6 = 3 （101 + 110 = 010）
思路：异或运算，排序取最大
/** 常用的位运算符： 与（&amp;） 同1出1，有0出0 或（|）有1出1，全0出0 异或（^）相同出0，不同出1 非（~）又叫取反 左移 &lt;&lt; （即乘2，最右边加个0） 右移 &gt;&gt; （即除2删掉最右边一位） */ public class ShareApple { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int[] apple = new int[num]; for (int i = 0; i &lt; num ;i++){ apple[i] = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8a623aabbb0cdb71ac97f5b41437e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd49d8973088c732040b16bdaf541cc/" rel="bookmark">
			KUKA机械臂的导纳控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KUKA机械臂的导纳控制 在近期的实验中，需要根据传感器的给出的实时位置信息进行导纳控制，并实时改变导纳控制的参数。由于KUKA自带的实时导纳控制模型无法实时修改参数，因此尝试了自己实现导纳控制。网上这方面的资料比较少，整理并分享一下自己的思路。相关代码在 KUKA_AdmittanceControl
导纳控制的目的在于使得末端的受力和末端的位置两者之间保持一种“平衡”，这种平衡用阻抗模型来一般性表述。
F e x t = M x e ¨ + B x e ˙ + K x e ; F_{ext} = M \ddot{x_e} + B \dot{xe} + K xe;\\ Fext​=Mxe​¨​+Bxe˙+Kxe;
那么，末端收到的外力和末端的轨迹之间的关系为（在受到外力作用下，使得轨迹产生了多大的偏差）：
x e ¨ = M − 1 ∗ ( F e x t − B x e ˙ − K x e ) ; x e ˙ = x e ˙ o l d + x e ¨ ∗ Δ T ; x e = x e o l d + x e ˙ ∗ Δ T ; \ddot{x_e} =M^{-1} * (F_{ext} - B \dot{xe} - K xe); \\ \dot{x_e} = \dot{x_e}_{old} + \ddot{x_e} * \Delta T;\\ {x_e} = {x_e}_{old} + \dot{x_e} * \Delta T;\\ xe​¨​=M−1∗(Fext​−Bxe˙−Kxe);xe​˙​=xe​˙​old​+xe​¨​∗ΔT;xe​=xe​old​+xe​˙​∗ΔT;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd49d8973088c732040b16bdaf541cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950804f93e1f5426b5a6f78d98865110/" rel="bookmark">
			protobuf版本 冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Protobuf compiler version 3.20.3 doesn't match library version 3.12.4 查看当前默认的protobuf的版本 protoc --version 查看当前默认的系统级protobuf版本 sudo protoc --version 果然，conda 环境的搜索顺序比系统的搜索顺序靠前，故现在默认的是 conda 环境中的版本，我们将系统的protoc搜索路径放在前面： export PATH=/usr/local/bin/:$PATH protoc --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d5c6eedbb797f304a572e9624f8c08/" rel="bookmark">
			用VMware运行linux CentOS7时，Network中没有wired选项，只有VPN的情况解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毫无征兆，平时使用正常的CentOS7在今天打开后发现无法连接到网络，wired图标也莫名的消失，并且在打开网络设置，也没有对wired的设置模块，这种问题很有可能是之前对云端之类的源进行操纵以及主机上挂梯子等一系列情况综合才会出现的。
解决步骤 1、在菜单栏中依次选择：虚拟机 &gt; 设置 &gt; 网络适配器 &gt; NAT模式
2、重新启动网络连接管理器
sudo service network-manager stop 也有可能是 service NetworkManager stop sudo rm /var/lib/NetworkManager/NetworkManager.state sudo service network-manager start 也可能是 service NetworkManager start sudo vim /etc/NetworkManager/NetworkManager.conf	之所以指令会不同是因为版本、文件名字和系统的因素
如果是 Kali Linux（Debian），则sudo service network-manager restart 需要用：service networking restart
如果是Centos 8，则需要用：nmcli c reload
其中 sudo vim /etc/NetworkManager/NetworkManager.conf这一句的操作可以在vim中修改，也可以直接去该路径下的文件中操作。内容如下：
[main] plugins=ifupdown,keyfile [ifupdown] managed=true [device] wifi.scan-rand-mac-address=no 直接将这段代码写到这个文件中即可。
写完之后，在terminal中，重启网络连接管理器设置即可。
sudo service network-manager restart 也可能是 service NetworkManager restart 重启之后，如果设置成功的话，你的网络连接图形应该会马上弹出。
然后你的Network就会开始进行工作，接下来需要解决cable unplugged。如果你需要用桥接模式的话，可以直接使用桥接模式让网络自己去连接。如果要用NAT模式的话可以参考另一位博主的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d5c6eedbb797f304a572e9624f8c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c06b601d68c776db96b623f6b58cf3/" rel="bookmark">
			openpose 安装与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get install cmake-qt-gui sudo apt-get install libopencv-dev sudo apt install protobuf-compiler libgoogle-glog-dev sudo apt install libboost-all-dev libhdf5-dev libatlas-base-dev git clone https://github.com/CMU-Perceptual-Computing-Lab/openpose cd openpose/ git submodule update --init --recursive --remote mkdir build/ cd build/ cmake-gui .. 如果您的计算机没有任何 GPU，请将GPU_MODE标志设置为CPU_ONLY make -j`nproc` 在没有姿势的情况下渲染脸部和手部 # CPU rendering (faster) ./build/examples/openpose/openpose.bin --render_pose 0 --face --face_render 1 --hand --hand_render 1 # GPU rendering ./build/examples/openpose/openpose.bin --render_pose 0 --face --face_render 2 --hand --hand_render 2 视频： ./build/examples/openpose/openpose.bin --video examples/media/video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6c06b601d68c776db96b623f6b58cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02b8fc14bb2ace61b72f58058ce6880/" rel="bookmark">
			高效编辑代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用哪一种装饰器修饰的组件可作为页面入口组件？
B. @Entry
ArkTS Stage模型支持API Version 9，关于其工程目录结构说法正确的是：
C. module.json5包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息
DevEco Studio提供模拟器供开发者运行和调试HarmonyOS应用/服务，以下说法错误的是：
A. 本地模拟器是创建和运行在本地计算机上的，需要登录授权
DevEco Studio支持使用多种语言进行应用/服务的开发，包括ArkTS、JS和C/C++。在编写应用/服务阶段，可以通过以下哪些方法提升编码效率：
A. 提供代码的智能补齐能力，编辑器工具会分析上下文并理解项目内容，并根据输入的内容，提示可补齐的类、方法、字段和关键字的名称等B. 在编辑器中调用ArkTS API接口或ArkTS/JS组件时，支持在编辑器中快速、精准调取出对应的参考文档C. 代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性D. 如果输入的语法不符合编码规范，或者出现语义语法错误，编辑器会显示错误或警告
关于预览器的使用，以下哪些说法是正确的：
A. 在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果B. 在预览器界面，可以在预览器中操作应用/服务的界面交互动作，如单击、跳转、滑动等，与应用/服务运行在真机设备上的界面交互体验一致C. 组件预览通过在组件前添加注解@Preview实现D. 页面预览通过在工程的ets文件头部添加注解@Entry实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3778f5d619d9cc4424cfead988852dc/" rel="bookmark">
			【完整版】zabbix企业级监控（概念、简单操作、页面优化、监控主机自己、监控linux、监控Win10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三阶段基础
时 间：2023年7月19日
参加人：全班人员
内 容：
zabbix企业级监控
目录
一、Zabbix概述
（一）Zabbix简介
（二）Zabbix运行条件：
（三）Zabbix功能
（四）优劣势
（五）zabbix的监控原理：
（六）扩展：zabbix的监控架构
（七）Grafana简介：
（八）Zabbix特点
二、zabbix安装部署
三、图形化操作：web安装zabbix
四、Zabbix页面优化
五、Zabbix监控自己
六、监控linux主机：
七、监控Win10主机：
一、Zabbix概述 （一）Zabbix简介 在企业网络运维过程中，管理员必须随时关注各服务器和网络的运行状况，以便及时发现问题，尽可能减少故障的发生。当网络中的设备，服务器等数量较多时，为了更加方便，快捷的获得监控信息，通常会借助于一些集中监测软件。
想要实时的了解服务器的运行状况并且能在出现问题时及时解决，利用监控软件是一个很好的途径。
就目前而言，有服务器的地方就少不了监控系统，现有的监控系统软件很多，但是zabbix可灵活的监控服务器资源，并且集cacti与nagios两者的优点于一身且功能更强大，实现企业级分布式监控，所以在市场应用更广。
Zabbix是一个基于web界面的企业级开源监控套件，由C语言编写而成的底层架构（server端和agent端），由一个国外的团队持续维护更新，软件可以自由下载使用，运作团队靠提供收费的技术支持赢利。世界上很多大小不同的组织机构都依赖与zabbix作为自己的一个主要的监控平台，尤其是现在很多互联网企业都在使用它。
提供分布式系统监控与网络监控功能，具备主机的性能监控，网络设备性能监控，数据库性能监控，多种告警方式，详细报表，图表的绘制等功能。
检测的对象可以是linux或windows服务器，也可以是路由器，交换机等网络设备，通过SNMP(Simple network protocol 简单网络管理协议)，zabbix agent,ping,端口监视等方法提供对远程网络服务器等监控，数据收集等功能，并提供通知机制使系统管理员可以快速定位，解决系统中存在的各种问题。
Zabbix官方网址是http://www.zabbix.com
Zabbix通过C/S模式采集数据，通过B/S模式在web端展示和配置。
被监控端：主机通过安装agent方式采集数据，网络设备通过SNMP方式采集数据
Server端：通过收集SNMP和agent发送的数据，写入MySQL数据库，再通过php+apache在web前端展示。
（二）Zabbix运行条件： Server：Zabbix Server需运行在LAMP
（Linux+Apache+Mysql+PHP）环境下，对硬件要求低
Agent：目前已有的agent基本支持市面常见的OS，包含Linux、HP（Unix）、Oracle（Solaris）、windows等
SNMP：支持各类常见的网络设备
（三）Zabbix功能 具备常见的商业监控软件所具备的功能（主机的性能监控、网络设备性能监控、数据库性能监控、FTP/HTTP等通用协议监控、多种告警方式、详细的报表图表绘制）；
支持自动发现网络设备和服务器；
支持分布式，能集中展示、管理分布式的监控点；
扩展性强，server提供通用接口，可以自己开发完善各类监控。
（四）优劣势 1、优点：
开源，无软件成本投入；
Server对设备性能要求低（实际测试环境：虚拟机Redhat EL AS5，2GCPU 1G内存，监控5台设备，CPU使用率基本保持在10%以下，内存剩余400M以上）；
支持设备多；
支持分布式集中管理；
开放式接口，扩展性强；
当监控的item比较多服务器队列比较大时可以采用被对状态，被监控客户端主动从server端去下载需要监控的item然后取数据上传到server端。这种方式对服务器的负载比较小。
2、缺点：
无厂家支持，出现问题解决比较麻烦
需在被监控主机上安装agent，所有数据都存在数据库里，产生的数据据很大,瓶颈主要在数据库。
（五）zabbix的监控原理： 1、组件说明：
1）zabbix server:负责接收agent发送的报告信息的核心组件，所有配置、统计数据及操作数据都由它组织进行；
2）database storage：专用于存储所有配置信息，以及由zabbix收集的数据；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3778f5d619d9cc4424cfead988852dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850156c0867eaa05c43d94694b8c188f/" rel="bookmark">
			数独小游戏——Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、题目生成1.数独规则2.生成初始题目 二、界面设计三、升级优化总结 前言 使用python简单实现一下数独小游戏，并且使用tkinter进行界面展示。
一、题目生成 1.数独规则 在 9x9 的棋盘网格中将数字 1 ~ 9 填入空白格每一列只能包含数字 1 到 9，不能重复每一行只能包含数字 1 到 9，不能重复每个 3×3 的小九宫格只能包含数字 1 到 9，每一列或每一行中的每个数字只能使用一次 2.生成初始题目 先直接得到若干个数独游戏的答案，然后再随机让一些数字变成待填入的空白格就OK了，而随机变成空白格的数量就决定着游戏难度的大小。
使用递归的方法实现，并且在create_board函数返回答案和题目，来看代码：
# 生成题库 import random import copy def generate_sudoku_board(): # 创建一个9x9的二维列表，表示数独棋盘 board = [[0] * 9 for _ in range(9)] # 递归函数，用于填充数独棋盘的每个单元格 def filling_board(row, col): # 检查是否填充完成整个数独棋盘 if row == 9: return True # 计算下一个单元格的行和列索引 next_row = row if col &lt; 8 else row + 1 next_col = (col + 1) % 9 # 获取当前单元格在小九宫格中的索引 box_row = row // 3 box_col = col // 3 # 随机生成1到9的数字 numbers = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850156c0867eaa05c43d94694b8c188f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e5e3373e93f71bff02172d6b70b5e1/" rel="bookmark">
			springboot&#43;mybatis-plus实现自动建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好长时间没输出了，最近工作上也是太多事，领导动不动就拍脑门，那叫一个酸爽~
工作能力的提现不但是技术或解决问题的能力上，还体现在要能立刻满足领导的各种需求，不管是哪方面的需求，这样才能够拍上马屁，步步高升。
言归正传，作为技术从业者，还是要多深耕技术。有小伙伴问，在springboot工程中，持久层采用的mybatis框架，如何能够自动建表，一个团队中各个小伙伴针对新增需求会添加或修改表，但各自调试时，数据库表更新又不及时，造成很大不便。下面记录一下springboot+mybatis-plus实现自动建表。
1、环境 springboot2.x
mybatis-plus3.5.0
mybatis-enhance-actable1.1.1.RELEASE
mysql5.7.x
idea开发工具
2、新建springboot工程 2.1、pom依赖如下 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.sunchenbin.mybatis.actable&lt;/groupId&gt; &lt;artifactId&gt;mybatis-enhance-actable&lt;/artifactId&gt; &lt;version&gt;1.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.2、application配置 server: port: 9001 spring: #数据库配置 datasource: url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root #自动建表设置 mybatis: table: #create系统启动后，会将所有的表删除掉，然后根据model中配置的结构重新建表，该操作会破坏原有数据; #update系统会自动判断哪些表是新建的．哪些字段要修改类型等，哪些字段要删除，哪些字段要新增，该操作不会破坏原有数据; #add新增表/新增字段/新增索引新增唯一约束的功能，不做做修改和删除(只在版本1.0.9.RELEASE及以上支持); #none系统不做任何处理; auto: update model: #扫描用于创建表的对象的包名 pack: com.*.*.model database: #数据库类型目前只支持mysql type: mysql #mybatis-plus mybatis-plus: #固定的 mapper-locations: classpath*:com/gitee/sunchenbin/mybatis/actable/mapping/*/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e5e3373e93f71bff02172d6b70b5e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5f70287b423f5d1ccf3f3e77856a45/" rel="bookmark">
			京东到家搜索查询接口API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{
“code”:“0”,
“msg”:“成功”,
“result”:{
“searchResultVOList”:[
{
“to”:“store”,
“params”:{
“bgType”:“daojia”,
“orgCode”:“369647”,
“source”:“storeListByKey”,
“storeId”:“12291321”,
“skuId”:“2079481568”,
“keyWord”:“iphone 14”
},
“skuId”:“2079481568”,
“skuName”:“苹果iphone14系列 手机保护壳硅胶透明保护套手机壳/个”,
“imgUrl”:“https://img30.360buyimg.com/n6//jfs/t1/148947/32/35971/71555/649d6595F559a08bc/658f114189e0dafe.jpg”,
“storeId”:“12291321”,
“orgCode”:“369647”,
“fixedStatus”:true,
“incart”:false,
“incartCount”:0,
“tags”:[
], "saleStatus":true, "showCartButton":true, "userActionSku":"{\"isRecommend\":\"0\",\"disabledTags\":\"0\",\"storeServiceStatus\":0,\"deliveryTime\":\"4小时\",\"relateMode\":\"0\",\"isShowCouponPrice\":\"0\",\"spm_id\":\"skuList|1|1_1|||||1\",\"filterMode\":\"0\",\"isSpu\":\"yes\",\"searchId\":\"9754e2a9c5b165580edf4e6f089ab710\",\"majorPriceType\":\"1\",\"orgCode\":\"369647\",\"couponType\":\"noCoupon\",\"recallLevel\":\"1\",\"rankLevel\":\"1\",\"recWordsType\":\"4\",\"keyword\":\"iphone 14\",\"isAging\":\"no\",\"skuId\":\"2079481568\",\"filterShop\":\"0\",\"skuStatus\":\"NONSOLDOUT\",\"sortAttr\":\"0\",\"sortMode\":\"0\",\"storeId\":\"12291321\",\"aoiIds\":\"3798835\",\"skuIndex\":\"1\",\"majorPrice\":\"9.9\",\"spuId\":\"104082870\",\"businessType\":1}", "userActionStore":"{\"isRecommend\":\"0\",\"disabledTags\":\"0\",\"storeServiceStatus\":0,\"deliveryTime\":\"4小时\",\"relateMode\":\"0\",\"isShowCouponPrice\":\"0\",\"spm_id\":\"skuList|1|1_1|||||1\",\"filterMode\":\"0\",\"isSpu\":\"yes\",\"searchId\":\"9754e2a9c5b165580edf4e6f089ab710\",\"majorPriceType\":\"1\",\"fromType\":1,\"orgCode\":\"369647\",\"couponType\":\"noCoupon\",\"recallLevel\":\"1\",\"rankLevel\":\"1\",\"recWordsType\":\"4\",\"keyword\":\"iphone 14\",\"isAging\":\"no\",\"skuId\":\"2079481568\",\"filterShop\":\"0\",\"skuStatus\":\"NONSOLDOUT\",\"sortAttr\":\"0\",\"sortMode\":\"0\",\"storeId\":\"12291321\",\"aoiIds\":\"3798835\",\"skuIndex\":\"1\",\"majorPrice\":\"9.9\",\"spuId\":\"104082870\",\"businessType\":1}", "userActionImmedReport":false, "monthSales":"0", "highOpinion":"", "funcIndicatinsOrAdWord":"", "showModel":0, "iconType":-1, "discountRate":1, "spuId":104082870, "storeLogo":"https://img30.360buyimg.com/vendersettle/jfs/t1/205395/33/23383/156610/629b5451E898e4984/2dca9064f72e271a.png", "majorPrice":{ "price":"9.9", "priceType":"1", "deleteLine":false, "priceColor":"#FF1E19" }, "platformVipSku":false, "sellOutSku":false, "sellOutSkuFollow":false, "storeName":"小仓生活（崇文门站）", "skuType":0, "distance":"", "freightWords":"运费¥1.5", "deliveryTime":"4小时", "weighting":false, "weight":0.1, "recallLevel":1, "recWordsVO":{ "recWords":"同款商品近期191人购买", "fontColor":"#9E5D4A", "leftIconUrl":"http://img30.360buyimg.com/mobilecms/jfs/t1/99793/36/27571/1579/627352b1E0848190e/98808bb861814d06.png", "bgColor":"#FFE9D9", "recWordsType":4 }, "toStoreJumpParam":{ "to":"store", "params":{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a5f70287b423f5d1ccf3f3e77856a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429337bf272351385df8de12a5d90d37/" rel="bookmark">
			vue3获取组件名，自定义缓存组件，自定义清除缓存组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、定义获取组件名的工具函数
2、使用
3、完整案例
想要获取组件名，无非是要做自定义缓存组件和自定义清除缓存组件，或者是动态切换组件
但大概率都是缓存组件
1、定义获取组件名的工具函数 import router from "@/routes" export default function getComponentName() { let currentMatched = router.currentRoute.value.matched let currentComponent = currentMatched[currentMatched.length - 1].components!.default let componentName = currentComponent.name || (currentComponent as { __name: string }).__name // 如果组件内的 script 没有内容，就会返回 undefined console.log('componentName',componentName); return componentName } 注意一点的是：
在 3.2.34 或以上的版本中，使用 &lt;script setup&gt; 的单文件组件会自动根据文件名生成对应的 name 选项，
如果不满足以上的要求需要自定义组件名，否则也会返回undefined
2、使用案例 我在这准备了index1 / 2/ 3 文件，
script 标签内一定要有内容，没有内容相当于静态页面，会返回undefined,而且也没有必要缓存，
下面这个是index1的，你可放到index2/3，并手动修改下，以免混乱
&lt;template&gt; index1 &lt;button @click="num++"&gt;页面1的num++&lt;/button&gt; &lt;div &gt;{{ num }}&lt;/div&gt; &lt;/template&gt; &lt;script setup lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429337bf272351385df8de12a5d90d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60ec64c06aece45a8ab81e6109cb86b/" rel="bookmark">
			ClickHouse三分片两副本集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(以clickhouse20.8.9.6和ubuntu18.4为例)
环境准备：
ubuntu服务器6台
硬盘挂载/app目录
zk集群信息
一、TGZ安装包方式
curl -O https://repo.clickhouse.com/tgz/stable/clickhouse-common-static-20.8.9.6.tgz curl -O https://repo.clickhouse.com/tgz/stable/clickhouse-server-20.8.9.6.tgz curl -O https://repo.clickhouse.com/tgz/stable/clickhouse-client-20.8.9.6.tgz tar -xzvf clickhouse-common-static-20.8.9.6.tgz sudo clickhouse-common-static-20.8.9.6/install/doinst.sh tar -xzvf clickhouse-server-20.8.9.6.tgz sudo clickhouse-server-20.8.9.6/install/doinst.sh tar -xzvf clickhouse-client-20.8.9.6.tgz sudo clickhouse-client-20.8.9.6/install/doinst.sh 二、修改配置文件
假设我们的节点是10.***.***.[16:21]，以10.***.***.16上的配置为例。
config.xml
根据实际情况修改。我的节点信息都配置在metrika.xml文件里，config.xml文件主要做了一些存储路径，大小限制的修改。该版本自带prometheus exporter，有需要取消相应注释即可。 &lt;?xml version="1.0"?&gt; &lt;!-- NOTE: User and query level settings are set up in "users.xml" file. If you have accidentally specified user-level settings here, server won't start. You can either move the settings to the right place inside "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60ec64c06aece45a8ab81e6109cb86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090de7bf4fa9d47edc01ff334b1f71d0/" rel="bookmark">
			OpenVas扫描器更新扫描引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPenvas扫描器安装时step1 是交换指导升级（nvt，cert，scap），这次升级后是自动升级24h升级一次，但第一次升级时选择默认的rsync升级时会出现同步失败的问题，导致openvas安装完后有很大模块和规则不是最新的从而会影响扫描结果。
问题：
如过选择默认的rsync升级，最后失败了。扫描结束会有这样的告警（告诉扫描者应该升级本地扫描引擎，版本低可能会影响扫描结果）
Report outdated / end-of-life Scan Engine / Environment (local)
Summary
This script checks and reports an outdated or end-of-life scan engine
for the following environments:
Greenbone Source Edition (GSE)
Greenbone Community Edition (GCE)
used for this scan.
NOTE: While this is not, in and of itself, a security vulnerability, a severity is reported to make you aware
of a possible decreased scan coverage or missing detection of vulnerabilities on the target due to e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090de7bf4fa9d47edc01ff334b1f71d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1c02c82b2ca9852078d206f5c13bf1/" rel="bookmark">
			H5网页获取公众号openid,access token,等用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对接支付jsApi中需要获取到公众号下的用户openid (一个用户可以关注多个公众号,每个公众号下的用户openid是不一样的)
准备工作:
公众号信息配置好了以后就是前端请求,获取code
mounted() { var local = window.location.href; //当前路径，注意：路径必须是在公众号配置过的 var APPID = '此为公众号的openId'; //此为公众号的openId var APPSecret = '此为公众号的secret'; //此为公众号的secret var code = this.getUrlParam('code') //工具函数，获取code参数信息 if (code == "" || code == undefined || code == null) { console.log('code--1----', code); window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=' + APPID + '&amp;secret=' + APPSecret + '&amp;redirect_uri=' + encodeURIComponent(local) + '&amp;response_type=code&amp;scope=snsapi_base&amp;state=#wechat_redirect' } else { console.log('code--2----', code); //获取到的话，通过后台接口获取到openId,此接口必须放在后台，不然微信返回异常 uni.request({ url: 'https://wxh5pay.diqwl.com/wxPay/getOpenId', method: 'post', data: { code:code }, header: { 'content-type': 'application/x-www-form-urlencoded; charset=UTF-8' //重点 }, success(res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1c02c82b2ca9852078d206f5c13bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96bc09a667a24f71519e243d1b87b01f/" rel="bookmark">
			完整的电商平台后端API开发总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于开发一个Web项目来说，无论是电商还是其他品类的项目，注册与登录模块都是必不可少的；注册登录功能也是我们在日常生活中最长接触的，对于这个业务场景的需求与逻辑大概是没有什么需要详细介绍的，市面上常见的邮箱注册、手机注册、账号密码注册，其处理方式基本相同，我们这里使用账号密码注册的方式，实现整个平台的注册/登录功能；
让我们开始！
判断用户名是否存在
实现注册部分的代码，首先想到的就是，我们要对前端所发送过来的请求参数做验证，在有些项目中，会将请求参数的格式验证和合法性验证只写在前端校验，而后端只实现业务逻辑，我认为这是极其危险的编码习惯；当我们的项目放在线上的时候，就会有恶意用户绕过前端验证，直接访问我们的服务器，对线上业务造成破坏，因此前端验证是为了减轻一部分请求直接到达后端，但是相应的验证后端也要去做
那么，首先我们要实现的就是验证用户注册的用户名是否存在；我们首先来看一下用户表的结构及设计：
从图上我们可以看到用户表中常用的字段，我们用户表以用户的Id为主键，但注意：ID并不是自增长的，这与传统的Id设计不同，这里不是自增的原因是：当系统达到一定的体量时，用户数量激增，我们需要去做分布式集群，需要分库分表，这时自增的ID会给分库分表带来极大的困难，因为，出于日后系统优化的考虑，我们这里的数据库主键，不是自增的。
接口API（淘宝）开发
理清业务逻辑，看完数据库结构，我们着手开始编写业务代码；在整个项目代码的编写和接口的实现我们都遵循自底向上的方式，从数据库开始，实现数据的映射，业务实现，结果推送的流程，对应pojo映射---Service编写---Controller控制的过程。
那么，我们开始啦：首先，我们创建一个UserService接口，在接口中，我们编写我们第一个业务方法：
/** * 判断用户名是否存在 */public boolean queryUsernameIsExist(String username); 我们传入一个userName，返回一个布尔值；有了接口之后，我们去实现这个方法：
我们在service工程中，新建一个Impl的包，在里面新建一个类UserServiceImpl，去实现UserService接口，并实现其中的方法；我们在这个方法中，需要操作User这个实体类，那么我们先把UserMapper引入进来：
@Autowiredpublic UsersMapper usersMapper; 在方法中，我们使用Example这种使用条件查询的方式去做查询：
@Transactional(propagation = Propagation.SUPPORTS)@Overridepublic boolean queryUsernameIsExist(String username) { Example userExample = new Example(Users.class); Example.Criteria userCriteria = userExample.createCriteria(); userCriteria.andEqualTo("username",username); Users result = usersMapper.selectOneByExample(userExample); return result == null ? false : true;} 在这个方法的实现中，我们使用了Example这种方式，Example映射一个实体类，获得一个example对象，为这个对象去添加相应的条件，Criteria对应的方法有很多，可以判断等于，大于，相似等各类条件，使用起来很方便，感兴趣的同学可以去阅读他的源码；这个方法返回一个Users对象，我们去判空，若为空，则用户名可用，若false，则用户名存在；
实现了Service之后，我们来编写Controller，我们在api工程中，新建一个Controller类。命名为PassportController，我们为他加上RestController注解，并加上路由地址，在这个Controller中，我们需要操作UserService来进行查询，那么，我们先将UserService注入进来：
@Autowiredprivate UserService userService; 并定义一个方法，声明方法的路由地址：
@GetMapping("/usernameIsExist")public IMOOCJSONResult usernameIsExist(@RequestParam String username) { //判断用户名不能为空 if (StringUtils.isBlank(username)) { return IMOOCJSONResult.errorMsg("用户名不能为空"); } //查找注册的用户名是否存在 boolean isExist = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96bc09a667a24f71519e243d1b87b01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9618788bd0800ac9a37c4ce8ea18b7db/" rel="bookmark">
			Airtest的安装、配置、使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装及配置 1.1 下载AirtestIDE 官网：https://airtest.netease.com/
选择下载版本，根据自己电脑版本进行下载对应安装包。
解压文件，进入安装目录，找到 AirtestIDE.exe，双击即可启动。
1.2 下载Airtest第三方库 先安装python，安装Airtest第三方库要求python的版本&lt;3.7，目前我使用的为3.6.3
然后安装pip
通过pip安装airtest与poco
pip install airtest pip install poco 安装完成之后，可以通过pip list查询是否安装成功
1.3 csv 由于需要通过python进行csv文件的读写，所以需要这个第三方库。同样也可以通过pip进行安装，不过python 3.6.3默认支持了csv。
可以通过pip list查询是否安装成功。具体的使用，可以查看这个博文。
1.4 配置环境 打开Airtest IDE，配置相应的python环境。
2. 使用教程 2.1 连接设备 打开AirtestIDE，连接设备
2.2 运行 “文件”主要用于一系列的脚本文件的操作，比如新建、打开、保存和另存等等。
我们打开自己编写的脚本,“运行”则用于运行脚本的一系列操作
我们还可以在这里打开报告目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccc544f199b67685f46c0b786b1c919/" rel="bookmark">
			八股文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八股文总结 一、c++八股文 STL 1、什么是STL STL包括容器、迭代器和算法
其中容器包括顺序容器（vector，list）和关联性容器（map，set）
算法包括排序算法和复制算法，包括容器特定的算法
迭代器的目的是在不暴露容器内部结构的前提下，实现对容器的遍历
3、hashtable的实现 在STL中的hashtable通过开链法来解决哈希冲突，具体通过一个vector数组和链表来实现。当要插入元素时，首先计算出该元素的哈希值，然后将值映射到哈希表的索引。如果当前索引处没有元素，则将该值插入指向链表的头部。如果该处已经有其他元素，则插入该处链表的尾部，以此通过链表将元素穿起来。当要查找元素时，先计算出该元素的索引，然后遍历该处链表进行查找哈希表的大小在创建时进行确定，在容器中提供了一系列质数，因为质数能更好的分布哈希值，避免哈希冲突。当哈希表中的（哈希表元素个数/哈希表大小）超过阈值，则寻找下一个质数，创建新的vector数组，扩大哈希表，并进行元素转移hashtable时c++98中的，在c++11标准中，改为unordered_map 4、slist的实现 slist为单向链表，其中每一个结点通过结构体实现，包括一个指针和一个元素所以结构体中只存储了下一个结点的指针，减少了一半的内存消耗单向链表不允许后退，所以设计了一种单向迭代器， 5、list的实现 list是双向链表，具体的实现可以分为节点定义和迭代器定义、构造函数定义、插入删除定义在结点定义中，在结构体内定义了前后指针和元素在迭代器定义中，为双向迭代器，通过模版定义了value_type,reference,pointer,difference_type,并且定义了一个node结点，表示当前迭代器指向的结点插入删除中，可以分别向前和向后插入删除 6、vector的实现 vector底层数据结构为连续的内存空间，和array类似。但array在定义时，空间大小就无法再更改。vector可以动态扩展内存。具体vector的内部维护了三个指针，即起始位置，最后一个元素位置，内存空间的最后一个位置。当元素数量超过最大容量时，将容量扩展为两倍，并进行元素复制。在这个过程中，通过迭代器和移动语义减少内存拷贝。 7、 stack和queue的实现 stack是一种先入后出的数据结构。由于它是单向开口的数据结构，所以很容易由list和deque这种双向开口的数据结构实现，只需要移除部分接口通过修改某个容器的接口，然后变成另外的结构，通常叫做adaptater（适配器），从而将其归为容器适配器stack也可以使用list来构建，但是没有迭代器，不能进行遍历 8、++it和it++ 先++可以直接对this指针进行加法操作，然后返回this指针，不需要创建临时对象 9、list和vector的区别 vector具有连续的内存空间，并且可以实现o1的随机存取list是双向链表，内存空间是不连续的，所以随机存取是on的，并且list的每一个节点都包含向前和向后的指针，所以资源消耗较大并且vector可以双向遍历 10、vector删除策略 由于每次扩容的大小一定等于或大于之前的大小，并且每次分配的空间越多，平摊的时间复杂度低，所以将增长因子设为2，即每次 都翻倍增长，可以直观减少扩容的次数 11、迭代器删除元素 顺序容器中，erase使删除迭代器及之后所有迭代器失效，然后返回下一个有效的迭代器关联容器中，erase只是被删除元素的迭代器失效，返回值为void，所以使用erase(it++) c++11 2、左值引用和右值引用 首先，介绍一些左值和右值：能够取地址的为左值，比如int a = 1 ，其中a为左值。
而1为右值，不能取地址。右值又分为纯右值和将亡值。纯右值等同于c++98标准中的临时变量和不与对象相关的字面值。
左值引用和右值引用都是引用类型，并不拥有引用对象的内存，所以需要在定义时进行初始化。
左值引用只能用左值初始化，而常量左值是万能引用类型，可以用右值初始化。
右值引用只能使用右值进行初始化，除非通过move将左值的资源进行搬移。
右值引用的特点：
右值引用的变量生命周期和该引用类型变量一样，相当于延长了寿命，比如将在函数作用域内实例化的类，在进行函数返回值传递
8、 shared_ptr 主要实现方法通过引用计数实现，当引用计数为0时，智能指针指向的对象进行析构
可以通过构造函数初始共享智能指针也可以通过make_share();初始化 9、weak_ptr 弱智能指针可以通过空的weak_ptr实例化，也可以 通过share_ptr实例化。
当通过share_ptr实例化时，他只负责监管共享智能指针的资源，而不会增加其引用计数。并且weak_ptr可以通过lock成员函数，获取原始指针 。通过lock返回原始指针可以避免拷贝构造。
10、move和forward 当需要得到一个右值引用时，不可以通过左值来进行初始化。而可以通过move函数，转移资源当右值引用命名后，本身已经变成左值引用，如果要在函数间进行转发，且不使用拷贝构造，则使用forward，如果T为左值引用，则转发为左值。如果为非左值，转发为右值。 11、auto、decltype auto 实现函数返回值拷贝复制的自动推演decltype实现函数返回值类型的自动推演 decltype(fun) a； 12、null和nullptr 在c中，null为空指针，但是在c++中会被隐式转换为int 0，所以通过nullptr自动推导环境空指针类型。 13、lambda函数 是内联的匿名函数，编译器会自动生成一个闭包类，并返回一个闭包实例。。可以通过作用域捕获闭包内的变量。
二、计算机网络八股文 2.1、键入网址到网页显示，期间发生了什么 1、http 刚开始输入的是url连接，最开始的http是访问数据时请求的协议。//后面是服务器名称 /后面是访问服务器的文件地址解析url之后，根据这些信息发送http请求报文，变成http数据包 2、dns 得到http数据包之后，需要通过域名，查询目标地址的ip客户端首先发送dns请求给本地的域名服务器，查询缓存本地域名服务器依次询问根域名服务器、顶级域名服务器、权威域名服务器查询到ip之后，客户端和目标建立连接 3、协议栈 应用程序通过调用socket库，委托协议栈工作。协议栈上半部分通过tcp、udp协议接受应用层的委托进行收发数据协议栈下半部分用ip协议控制网络包收发操作ip中包含arp协议，查询对应ip的mac地址 4、tcp tcp报文格式 首先需要源端口号和目标端口号数据包的序号确认号，防止丢包状态位：syn：发起连接，ack：回复，，rst：重新连接，fin：结束连接窗口大小，用来进行流量控制。通过双方约定窗口缓存大小，防止撑死饿死。并且通过控制自身发送速度进行拥塞控制。 tcp三次握手 在http传输数据之前，通常需要tcp建立连接，这个过程就是三次握手首先服务端开启监听客户端发送syn请求，进入syn-sent状态服务端接受syn，返回syn，并且发送对syn的ack，进入syn-rcvd状态客户端接受syn和ack，发送对于服务端syn的ack，进入established状态服务端接受ack后，进入established状态 tcp分割数据 mtu：一个网路包的最大长度mss：出去ip和tcp头部，剩余容纳数据的最大长度数据被划分为mss长度，加上tcp头部，然后送给ip模块进行发送 tcp报文生成 tcp协议中的两个端口号，浏览器监听的端口号是随机生成。web服务器端口号（http为80）在建立好连接之后，生成tcp报文，tcp报文其中的数据部分就是http头部和数据段 5、ip ip报文头部 源地址ip和目标地址ip协议号。由于http由tcp传输，所以协议号为06 6、mac mac包头格式 mac头部是以太网使用的头部，包含接收方和发送方的mac地址发送方mac地址接收方mac地址协议类型：ip协议0800.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccc544f199b67685f46c0b786b1c919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219742a97843b5f32c8e6af4a392fca4/" rel="bookmark">
			【Stable diffusion教程】AutoDL云部署超详细步骤说明【外婆都会】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 AutoDL云端部署操作流程 1.1 登录/注册 官网：https://www.autodl.com/home，点击右上角登录/注册。此处我已经注册了
如果你是学生的话，注册完之后，进入控制台，在右上角点一下学生认证，然后你就可以享受炼丹会员折扣啦。
1.2 账号充值 登录后在控制台页面，因为抢主机的时候余额不足就没法提交，所以先得给账户充点钱才行，先充3-5块试试水。充值还可以开发票。
1.3 创建实例 充值完成后，点击数字进入容器实例列表页面。进入容器实例页后，点击左上角租用新实例，进入实例创建页。
介绍一下每个模块的功能说明：
1、计费方式：按量计费（按照使用时长扣费）、包日（租用24小时）、包周（租用一周）、包月（租用一个月），一般炼丹选手选择按量计费就行。
2、选择地区：GPU对应的地区，一般选择距离自己最近的区，整体区别不大。
3、GPU型号：对应不同的显卡核心，不同的GPU型号的收费价格不同，越好的GPU收费越贵，看个人经济实力选择。
4、GPU数量：不同的GPU数量（通常情况下不需要筛选）。
5、数据盘：默认不扩容。
镜像：这里选择社区镜像，搜索输入stable-diffusion-webui，选择AUTOMATIC1111/stable-diffusion-webui/NovelAI-Consolidation-Package-3.1:v6这个镜像文件，其他同类型文件多数也可以用，目前这个镜像是测试使用下来最简单方便使用的。
从上往下，我们依次选择计费方式、选好主机、选择合适的社区镜像，最后点击“立即创建”就可以了。创建成功后会直接跳到实例列表页面，会在右上角弹出一个错误提示，需要重新刷新选择主机。
1.4 运行WebUI 实例创建完成后，我们回到容器实例列表页面，可以看到我们刚才创建的实例的状态变化：创建中 → 开机中 → 运行中，第一次拉取镜像较慢，等待大概1分钟左右的时间。当状态成为运行中，这个时候我们点击“快捷工具】- JupyterLab”。
点击JupyterLab后会打开一个新页面，左侧是文件区域，右侧是代码区域，如下图：
这个镜像操作页面非常简单，作者已经集合好代码，不需要额外的代码调整。上面红色文字部分就是作者写的操作说明。我这里也大家简单标注一下操作步骤：
第1步：选中第一行代码(左侧有蓝色条/底色从灰色变成白色代表选中)
第2步：点击三角符号运行代码
前两步骤完成后会出现这样的结果的
第3步：运行完成后，第一行代码会显示“移动完成”。然后浏览器/F5刷新(重新加载)一下页面(重要！！！重要！！！一定要刷新！！！)
第4步：页面刷新完成后，右上角点击python 3(ipykernel),然后弹出选择内核的弹窗，选择“xL_env”（没有刷新就没有这个选项）。
第5步：选中第二行代码，点击上面的三角符号运行代码(跟第一行代码操作一样)，然后运行完成后如下图：
这里也选中运行一下
结果如下图所示的：
上图的三个按钮，依次点击，每步操作等前一步运行完成后再进行下一步，三个按钮都运行按成后如下图，然后切换tab到“启动WebUi”，
1.5 启动Stable diffusion的WebUI页 这里简单介绍一下“启动WebUi”里面的功能模块：
1、用户名和密码：后续访问WebUi时，需要输入用户名和密码，不是必填项。不填写到时候会随机生成一个用户名跟密码，到时候登录直接复制系统生成的就行。也可以填写一个简单易记的用户名和密码(比如用户名abcd，密码123456).
2、运行目录：默认数据盘即可。
3、运行方式：默认正常版即可。
4、开启参数：这里默认是勾选3个。建议同时勾选上“图片反推文本”、“xformers极大改善内存消耗和速度”、“允许WebUI使用安装扩展功能”。
以上设置完成后，点击下面“运行WebUi”的按钮，代码就会自动运行起来：
等待运行大概1分钟左右，代码里出现下方截图里的 URL: http://127.0.0.1:6006，就说明运行成功了。这里我们不需要进行其他任何操作，当前页面也不要关闭，点击网页切换到容器实例的页面。
切换到容器实例列表页的时候，找到你新建的这条实例，点击“自定义服务”
点击“访问”，没有实名认证的话，你的弹窗这里是“实名认证”，需要先去认证一下才行。
点击访问，会自动打开WebUI的页面，这里输入用户名和密码(如果之前没有填写，就去前面那个网页复制一下)。输入用户名和密码后，点击Login。
登录成功后，就会跳到stable-diffusion-webui的界面了。你就可以愉快的开始炼丹啦~~
Ps：有时候跳转的页面有问题，可能关一下学术上网就好了，我是这么解决的！
Stable diffusion的模型决定画风以及图片质量，云部署完成后，只有一个基础模型，生成出来的图质量一般。如果想要更多风格或高质量图像，就需要安装其他模型。
1.6 部署自己的主模型和 LoRA 模型 由于默认的镜像没有附带很多主模型和 LoRA 模型，所以这里我们部署一下自己的模型或者其余的模型（模型网站）。
模型网站（需要科学上网）：https://civitai.com/
我们回到服务器终端页面，进入『autodl-tmp』目录，点击『上传按钮』就可以把模型上传到该目录下。如图：
上传模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219742a97843b5f32c8e6af4a392fca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c146a2444dd98d19506e6aa1f2718ba1/" rel="bookmark">
			企业内网失陷后应急响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内网横向移动应急响应 现象： 已知道内网主机被远控应急处理。
止损： 联系业务切断snat访问公网权限、隔离该主机，备份环境（快照备份、日志打包下载）
应急处置步骤： 1、防御产品：预警详情快速排查确认
2、攻击者目的评估：
1）HW网演练核心是靶标拿、系统权限和获取各类数据,突破后横向常见数据库、中间件的未授权和弱口令以及RCE扩展控制节点。
2）互联脚本攻击利用-挖矿计算资源利用
3）白帽子不定项向，证明漏洞存在类
4）其他攻击者APT行为，商业目的获取数据和破坏。
3、渗透行为排查：
业务日志（http 常见命令执行函数、服务可能有payload）、操作记录
4、横向范围排查：
1）安全产品蜜罐预警;
2）远控端IP地址与其他资产通信行为，http、snat日志等
3）攻击者入侵时间和入侵痕迹和操作行为判断，攻击者报告和留下的文件
4）情报IOC监控
5）扫描全网痕迹文件
5、修洞恢复业务
6、根据安全事件影响范围在不同阶段上报反馈以及上级决策指导
7、复盘：根据攻击链路增加安全拦截感知能力以及流程等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208550bab2a7d40d36d912967d2fb2f8/" rel="bookmark">
			ubuntu20 nvidia-smi输出问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvidia-smi 输出如下：
应该是驱动的问题，通过ubuntu-drivers devices查看一下当前可用的驱动有哪些，
选择一个驱动进行安装，我这里选的nvidia-driver-525
sudo apt-get install nvidia-driver-525 等待下载完成，重启电脑使配置的驱动生效，再次运行：
nvidia-smi 问题成功解决。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/128/">«</a>
	<span class="pagination__item pagination__item--current">129/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/130/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>