<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2666eaedd7d4bd24a7d93b7b8b2924a/" rel="bookmark">
			1.4 行列式计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 纯数字类型的行列式·例1·例2 元素相同位置不同的行列式·例3 加边法三叉型（鸡爪型）行列式范德蒙行列式反对称行列式对称行列式参考 纯数字类型的行列式 ·例1 技巧：
化成上三角计算计算之前对行进行交换，或者一行加到另一行上尽量避免分式 ·例2 元素相同位置不同的行列式 ·例3 对于元素相同，位置不同的行列式，技巧是制造行和提出去最后构造一个三角型。
加边法 加边法的原则是不改变原行列式的值
三叉型（鸡爪型）行列式 计算方法为：消去第一列第二行之后的值（去掉第一根鸡爪）化成上三角型
行列式遇到元素是字母并且计算过程中这个字母放分母上时，得考虑字母是否为0
范德蒙行列式 先固定 j 再移动 i，比如 j = 1,然后 i = 2… 然后 j = 2 ，i = 3…
反对称行列式 a i j = − a j i a_{ij} = -a_{ji} aij​=−aji​; a i i = 0 a_{ii}=0 aii​=0
奇数阶反对称行列式的值为0
对称行列式 a i j = a j i a_{ij} = a_{ji} aij​=aji​; a i i = a i i a_{ii}=a_{ii} aii​=aii​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2666eaedd7d4bd24a7d93b7b8b2924a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff357687877aac1b8c46f81748c8cfb4/" rel="bookmark">
			QDockWidget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、属性
2、停靠区域
3、特性
4、常用函数
5、测试代码
1、属性 allowedAreas ：停靠窗口可允许停靠的位置；features ：停靠窗口的特性；floating ：停靠窗口是否是浮动状态；windowTitle ：窗口标题。 2、停靠区域 Qt::LeftDockWidgetArea = 0x1 ：可以停靠左侧；Qt::RightDockWidgetArea = 0x2 ：可以停靠右侧；Qt::TopDockWidgetArea = 0x4 ：可以停靠上侧；Qt::BottomDockWidgetArea = 0x8 ：可以停靠下侧；Qt::AllDockWidgetAreas = DockWidgetArea_Mask ：可以停靠上下左右侧；Qt::NoDockWidgetArea = 0 ：不可以停靠。 3、特性 QDockWidget::DockWidgetClosable = 0x01 ：可以关闭停靠窗口；QDockWidget::DockWidgetMovable = 0x02 ：可以移动停靠窗口；QDockWidget::DockWidgetFloatable = 0x04 ：可以与主窗口分离，变为浮动窗口；QDockWidget::DockWidgetVerticalTitleBar = 0x08 ：当停靠窗口在左侧时，标题可以垂直排列；QDockWidget::AllDockWidgetFeatures ：可关闭，移动和浮动；QDockWidget::NoDockWidgetFeatures = 0x00 ：不可关闭，移动和浮动。 4、常用函数 bool isFloating() const ：返回，窗口是否浮动；void setAllowedAreas(Qt::DockWidgetAreas areas) ：设置窗口的停靠区域；void setFeatures(QDockWidget::DockWidgetFeatures features) ：设置窗口的特性；void setTitleBarWidget(QWidget *widget) ：自定义窗口的标题栏；void setWidget(QWidget *widget) ：设置停靠窗口的内容区域。 5、测试代码 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff357687877aac1b8c46f81748c8cfb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d3d15211dbca1fb64acad4dd797d2a/" rel="bookmark">
			语义分割入门系列之 FCN（全卷积神经网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN论文解读及代码分析 Fully Convolutional Networks for Semantic Segmentation FCN是卷积神经网络用于语义分割的开山之作，文章的出发点在于如何将普通的分类卷积神经网络用于语义分割网络。卷积神经网络在分类任务上取得了重大突破，因为随着卷积网络的层数加深，网络从图像中提取出越来越抽象的语义信息特征图的通道数越来越多，并且为了控制计算量，特征图的分辨率越来越小，并且最后还有全连接层做softmax预测，将整个图片的空间位置信息全部破坏。
FCN便从这方面入手，提出方案将普通分类卷积神经网络改造成能够进行语义分割的网络。下面来介绍FCN到底是如何做的。
1.修改分类器，使网络能够密集预测 如图所示，普通的分类神经网络最后的全连接层，输出的是该图片对应于每个分类的概率。将最后的全连接层全部替换成1x1的卷积卷积核，这样既实现全连接层的计算功能，又保持了特征图的空间分辨率，可以生成一个分类网络的热力图，热力图的分辨率很低，但是依然可以表示出让网络做出该判断的响应位置，这样就有了位置信息（很粗糙的位置信息）。并且，替换掉全连接层后带来的好处是，输入图片的尺寸可以是任意size的。
2. 深层与浅层的融合 上一步将全连接层替换成卷积层之后，特征响应的位置得以保留，但是网络最后特征图的尺寸已将很小（VGG经过5次下采样，resnet也经过5次下采样，最后一个特征图的分辨率是原图的2^5=32倍，虽然有特征响应的位置，但是无法对应到原图的精确位置），所以，FCN提出将深层的、分辨率粗糙的语义信息，与浅层的高分辨率的精细特征结合，以此来修复热力图的分辨率，使其不断上采样到原图尺寸，这样就得到了原图分辨率的结果。具体操作如下图：
图片来自：https://zhuanlan.zhihu.com/p/31428783，比论文原图更好理解
FCN32s是将最后一个特征图，直接上采样32倍（5次步长为2的3x3的反卷积操作），得到最后的分割结果。代码如下（pytorch实现）：其中pretrained_net表示的是backbone网络
class FCN32s(nn.Module): def __init__(self, pretrained_net, n_class): super().__init__() self.n_class = n_class self.pretrained_net = pretrained_net self.relu = nn.ReLU(inplace=True) self.deconv1 = nn.ConvTranspose2d(512, 512, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1) self.bn1 = nn.BatchNorm2d(512) self.deconv2 = nn.ConvTranspose2d(512, 256, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1) self.bn2 = nn.BatchNorm2d(256) self.deconv3 = nn.ConvTranspose2d(256, 128, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1) self.bn3 = nn.BatchNorm2d(128) self.deconv4 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d3d15211dbca1fb64acad4dd797d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a82781ffaaccd07a284066cc9179743/" rel="bookmark">
			Flutter plugin not installed; 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/survivorsfyh/article/details/93407580 步骤一
https://blog.csdn.net/jetluning/article/details/83785683 步骤二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4118c7186fd2d63eb8ed996852d7e440/" rel="bookmark">
			丢失api-ms-win-crt-runtime-l1-1-0.dll解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般安装MSVBCRT.AIO.2019.07.20.X86 X64.exe 可以解决，所以贴出来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b214cfd009376d3fc7508b6e155ac86d/" rel="bookmark">
			源于生活的活动安排问题及对贪心算法使用和验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源于生活的活动安排问题及对贪心算法使用及验证 【问题描述】
现有一个阶梯教室，有n个活动(A1、A2、A3、A4…An)需要申请这个教室，但是这个教室同一时间只能被一个活动使用。已知每个活动的起始时间begin和结束时间end。问怎样安排活动才能使尽可能多的活动使用到教室。编写求出最多可以举办的活动数。
【问题分析】
算法模型：本题即转化为区间问题，在n个区间内，选择尽量多的区间，使得这些区间两两不相交解决方法：从贪心算法的角度思考： (1)贪心算法是一种自顶向下的求解方法，每次进行一次所谓的贪心策略选择之后，下一次只面对一个子问题（2）既然（1）中明确了我们只需要面对一个子问题，也就是算法的时间复杂度是theta(n)。但是回过头来考虑此问题是否可以转化成通过贪心算法来进行求解呢？所以我们需要做的工作就是论证问题是适用于贪心算法的(3) 明确贪心问题的两个重要特性： a.论证问题符合贪心选择性b.其最优结构特性 【回到问题】
为了使每一次选择后，面对唯一的一个子问题，那我们就需要将活动按照结束时间end来进行单调递增的排序。 其正确性：由于结束时间的单调递增排序，即排序后为end1&lt;=end2&lt;=end3&lt;=end4…&lt;=endn.用贪心策略进行选取活动，第一次选择的是A1，如果能证明A1必属于某一个全局最优解(全局最优解可能存在多个)，就可以证明问题的贪心选择性，即可以使用贪心算法进行求解。如何证明？假设已有全局最优解Sk，其中的Aj就是Sk中结束时间最早的活动，若A1=Aj,则问题得证，若A1！=Aj，由题可知，A1.end&lt;=Aj.end.那么即使我们将Aj替换成A1得到的新的Sk’也是和原先的Sk相容的。因为他们的活动数是相同的，所以Sk’也是全局最优解。即A1必属于某个全局最优解。进而推出所有的局部贪心选择属于全局最优解中的一个子问题。**换个角度：**倘若我们不选end1，假设选的是endi，则如果endi和end1不交叉，那肯定是多选一个end1是更优的选择；如果交叉，那endi换成end1才不影响后面的选择。 【题解代码】 #include &lt;iostream&gt; using namespace std; int n,beg[1005],en[1005]; void init(){ cin &gt;&gt; n; for(int i = 1; i&lt;=n; i++){ cin &gt;&gt; beg[i] &gt;&gt; en[i]; } } void qsort(int x,int y){//快速排序 --按照时间的升序快速排序 int i,j,mid,t; i = x; j=y; mid = en[(x+y)/2]; while(i&lt;=j){ while(en[i]&lt;mid) i++; while(en[j]&gt;mid) j--; if(i&lt;=j){ swap(en[i],en[j]); swap(beg[i],beg[j]); i++,j--; } }	if(x&lt;j) qsort(x,j); if(i&lt;y) qsort(i,y); } void solve(){ int ans = 0; for(int i = 1,t = -1;i&lt;=n;i++){//t=-1是用于对第一个区间与其他区间的操作相同,否则需要单独处理第一个区间 if(beg[i]&gt;=t){ ans++; t = en[i]; } } cout &lt;&lt; ans &lt;&lt;endl;	} int main(){ freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b214cfd009376d3fc7508b6e155ac86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dcd7a4c1706637512b6194299ce29a0/" rel="bookmark">
			Hadoop系列——异常处理（org.apache.hadoop.hdfs.DFSClient - DataStreamer Exception）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：
WARN org.apache.hadoop.hdfs.DFSClient - DataStreamer Exception org.apache.hadoop.ipc.RemoteException: File /user/erp_finance/erp_finance_dw/hdp/ods_third_party_zfb_bill_m/year=2019/month=12/1_128_2088021126134800_4_201912.csv could only be replicated to 0 nodes instead of minReplication (=1). There are 0 datanode(s) running and no node(s) are excluded in this operation. at org.apache.hadoop.hdfs.server.blockmanagement.BlockManager.chooseTarget4NewBlock(BlockManager.java:1625) at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getNewBlockTargets(FSNamesystem.java:3132) at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getAdditionalBlock(FSNamesystem.java:3056) at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.addBlock(NameNodeRpcServer.java:725) at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolServerSideTranslatorPB.addBlock(ClientNamenodeProtocolServerSideTranslatorPB.java:493) at org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos$ClientNamenodeProtocol$2.callBlockingMethod(ClientNamenodeProtocolProtos.java) at org.apache.hadoop.ipc.ProtobufRpcEngine$Server$ProtoBufRpcInvoker.call(ProtobufRpcEngine.java:616) at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:982) at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:2217) at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:2213) at java.security.AccessController.doPrivileged(Native Method) at javax.security.auth.Subject.doAs(Subject.java:422) at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1758) at org.apache.hadoop.ipc.Server$Handler.run(Server.java:2213) at org.apache.hadoop.ipc.Client.call(Client.java:1503) at org.apache.hadoop.ipc.Client.call(Client.java:1441) at org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker.invoke(ProtobufRpcEngine.java:229) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dcd7a4c1706637512b6194299ce29a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc1d0a9245a120127f3ae0f55389cc9/" rel="bookmark">
			如何检测无符号整数乘法溢出？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在C ++编写一个程序来找到 B = C，其中A，B和C一起使用所有的数字0-9只出现一次的所有解决方案。 该程序循环了a和b的值，并且每次在a ， b和a b上运行一个数字计数例程，以检查是否满足数字条件。 然而，当A B溢出整数限制可以产生的寄生的解决方案。 我最终使用如下代码检查了这一点： unsigned long b, c, c_test; ... c_test=c*b; // Possible overflow if (c_test/b != c) {/* There has been an overflow*/} else c=c_test; // No overflow 有没有更好的测试溢出方式？ 我知道有些芯片具有在发生溢出时设置的内部标志，但我从未见过通过C或C ++访问它。 请注意， 在C和C ++中 ，有符号的 int溢出是未定义的行为 ，因此您必须在没有实际引起它的情况下对其进行检测。 有关添加之前的有符号的int溢出，请参阅在C / C ++中检测有符号的溢出 。 #1楼 对于浮点数，我需要回答相同的问题，在这种情况下，位掩码和移位看起来不太理想。 我确定的方法适用于有符号和无符号，整数和浮点数。 即使没有更大的数据类型可以推广到中间计算，它也可以工作。 对于所有这些类型，它并不是最有效的，但是由于它确实对所有这些类型都有效，因此值得使用。 签名溢出测试，加法和减法： 获取常量，该常量表示类型MAXVALUE和MINVALUE的最大和最小值。 计算并比较操作数的符号。 一种。 如果任一值为零，则加法或减法都不会溢出。 跳过其余测试。 b。 如果符号相反，则添加不会溢出。 跳过其余测试。 C。 如果符号相同，则减法不会溢出。 跳过其余测试。 测试MAXVALUE的正溢出。 一种。 如果两个符号均为正且MAXVALUE-A &lt;B，则加法运算将溢出。 b。 如果B的符号为负且MAXVALUE-A &lt;-B，则减法将溢出。 测试MINVALUE的负溢出。 一种。 如果两个符号均为负且MINVALUE-A&gt; B，则加法运算将溢出。 b。 如果A的符号为负且MINVALUE-A&gt; B，则减法将溢出。 否则，不会溢出。 签名溢出测试，乘法和除法： 获取常量，该常量表示类型MAXVALUE和MINVALUE的最大和最小值。 计算并比较操作数的大小（绝对值）为一。 （下面，假设A和B是这些幅度，而不是签名的正本。） 一种。 如果任一值为零，则乘法不会溢出，除法将得出零或无穷大。 b。 如果任一值为1，则乘法和除法不会溢出。 C。 如果一个操作数的大小小于一个，而另一个大于一个，则乘法不会溢出。 d。 如果幅度均小于1，则除法运算不会溢出。 测试MAXVALUE的正溢出。 一种。 如果两个操作数均大于1且MAXVALUE / A &lt;B，则乘法将溢出。 b。 如果B小于1并且MAXVALUE * B &lt;A，则除法将溢出。 否则，不会溢出。 注意：MINVALUE的最小溢出由3处理，因为我们采用了绝对值。 但是，如果ABS（MINVALUE）&gt; MAXVALUE，那么我们将有一些罕见的误报。 下溢测试相似，但涉及EPSILON（最小的正数大于零）。 #2楼 另一个有趣的工具是IOC：C / C ++的整数溢出检查器 。 这是一个修补过的Clang编译器，可在编译时向代码添加检查。 您将获得如下所示的输出： CLANG ARITHMETIC UNDEFINED at &lt;add.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc1d0a9245a120127f3ae0f55389cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a57ec382332c5259dcc62bb7d10bb7/" rel="bookmark">
			次梯度法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前文梯度下降法（一）从导数到梯度下降法的基本逻辑中指出，当函数梯度不存在时候，梯度下降法失效，而次梯度法则是凸优化中解决此类状况的一种有效方法。
一、基本定义 为了介绍次梯度的概念，首先需要引入次导数、次微分等概念。这些概念源于导数、微分，但又有显著的区别。
1. 次导数 下图中的一元函数均为凸函数，但在其拐点处不可导。观察拐点A、B处的直线，按照其与原始函数的位置关系，可分为如下两大类：
1）与原始函数相交，在不同自变量区间内，直线与原始函数的上下关系不确定
2）与原始函数在某点相交，但除了接触的若干点外，均在原始函数的下方
对于上述的第二类直线的导数，我们可以为原始函数在该点处的次导数。
用更加符号化的语言描述：对于一元函数 y = f ( x ) y=f(x) y=f(x)，在其上的点 ( x 0 , y 0 ) (x_0,y_0) (x0​,y0​)处，若存在某个常数 c c c，使得在对于整个定义域内的 x x x，均满足 f ( x ) − f ( x 0 ) ≥ c ( x − x 0 ) f(x)-f(x_0)\ge c(x-x_0) f(x)−f(x0​)≥c(x−x0​)，则值 c c c就是函数 f ( x ) f(x) f(x)在点 x 0 x_0 x0​处的一个次导数。
从几何直观上看（如上图）：次导数方向的直线均在原始函数的下方。次导数方向的直线可视为原始函数的一个下界函数。
显然，对于一个一元凸函数，其在某点处的次导数往往存在多个（无穷个），这些次导数的集合即为次微分。特殊的，若该点可微，则次导数唯一，即为导数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a57ec382332c5259dcc62bb7d10bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37cd59c8b9772080a2499f28d4efdc0f/" rel="bookmark">
			(a&#43;c)/(b&#43;d)与a/b和c/d的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提问： a b \frac{a}{b} ba​ 和 c d \frac{c}{d} dc​ 与 a + c b + d \frac{a+c}{b+d} b+da+c​ 的大小是什么关系？ 要回答这个问题并不困难，即使直觉上不那么强烈，举几个例子总能得出结果， a + c b + d \frac{a+c}{b+d} b+da+c​ 应该落在 a b \frac{a}{b} ba​ 和 c d \frac{c}{d} dc​ 之间。如果它们的大小关系满足一般规律，那么特例的结果就是可信的。
现在从数学的角度看看它们的关系。这里需要先做一些设定，规定一下 a b \frac{a}{b} ba​ 和 c d \frac{c}{d} dc​ 的大小关系。
如果 a b = c d \frac{a}{b}=\frac{c}{d} ba​=dc​，那么 a b = c d = a + c b + d \frac{a}{b}=\frac{c}{d}=\frac{a+c}{b+d} ba​=dc​=b+da+c​；除此之外，我们假定 a b &gt; c d \frac{a}{b}&gt;\frac{c}{d} ba​&gt;dc​ 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37cd59c8b9772080a2499f28d4efdc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f50f8c43cc100d3aa70b0351786f63a/" rel="bookmark">
			SSD &#43;tensorflow (二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过几天的摸索 我发现SSD是个相当复杂的东西
之前给了源代码：[https://github.com/balancap/SSD-Tensorflow]
这款代码是好多博客写过的 应用性很高
下载该代码还需要下载数据集，在刚才的代码链接里有的
Questions:
1、HOW to run the code？
源代码下面已经给了如何测试，是测试的小demo。
但是demo有个弊端，只能一次显示一张图片，是难以完成批量显示的，这块的改进 博主我一定加强学习，争取改进。
2、How to use your datasets?
给出参考链接：[https://blog.csdn.net/weixin_39881922/article/details/80569803]（我用的是这个 ，目前运行到tf_convert_data.py 木问题）
[https://www.jianshu.com/p/9ab4b4331c84]
[https://blog.csdn.net/weiyumeizi/article/details/82051855]
如何制作自己的数据集 ？
N多博客写了 ，这个回头我再搞懂一点再转载
3、源代码详细讲解？
[https://blog.csdn.net/k87974/article/details/80606407]
[https://blog.csdn.net/liang_xiao_yun/article/details/79551151]
（不管你是Linux, pycharm平台 还是双系统，这些博客写的都很好 ）
4、Notice：1）理清楚自己的数据存放路径，修改源代码的路径，及生成格式
2）保留原来的代码 以防自己修改乱了
3）学会理解作者这样写代码的方法跟思路，请认真思考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baf78223e669beeab6621519bd9b9e6/" rel="bookmark">
			记录对接京东宙斯API -- 同步订单信息到自身系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录对接京东宙斯API -- 同步订单信息到自身系统 目录1. 需求2. 准备工作一: 查看官方文档3. 准备工作二: 申请京东云鼎并入驻4. 创建一个新的项目并部署到云鼎.5. 调用订单API代码.6. JdService 目录 1. 需求 根据产品大大的需求描述：
对客户的京东旗舰店里的订单信息同步到自身开发的后台管理中.实现对订单信息简单的搜索功能.实现人工同步的功能.
2. 准备工作一: 查看官方文档 PS: 在寻找AIP时, 可根据需求的不同, 寻找对应的API文档.
找到官方API时, 当时的我感觉调用订单API的方式应该和其他API是一样的, 有了京东宙斯账号就可以, 但…实践调用以后, 很明显我错了.
在调用订单API时, 它返回了一个错误信息给我: 该api是敏感api，请将您的app入驻云鼎平台方可调用
返回的这条信息很明显的告诉我, 要我去申请京东云鼎平台的账号,并且还要入驻.
PS: 入驻云鼎是要钱的, 因为要购买云主机.
3. 准备工作二: 申请京东云鼎并入驻 入驻京东云鼎的具体流程这里我就展开讲述了, 官方有一套很完善的流程.
这是京东官方入驻云鼎的流程, 如果有感兴趣的小伙伴想了解一下可以点击这个链接: 入鼎公告
至此, 准备工作完成.
4. 创建一个新的项目并部署到云鼎. PS: 之所以要创建一个新的项目并部署到云鼎, 是因为订单API是属于敏感类型的, 只能内部调用.
5. 调用订单API代码. 京东官方订单API文档
/** * @Author 蠕动的小蜗牛 * @Description 根据条件检索订单信息 （仅适用于SOP、LBP，SOPL类型，FBP类型请调取FBP订单检索 jingdong.pop.order.search） * @Date 16:45 2019/8/13 * @Param [accessToken, startDateStr, endDateStr] * @Param [accessToken, 开始时间, 结束时间, 订单状态, 返回字段, 查询类型, 当前页, 页大小] * @return com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4baf78223e669beeab6621519bd9b9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5784048ceed243c7d97ff6f65d9b3bd/" rel="bookmark">
			z3库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话 z3是由Microsoft Research开发的高性能定理证明器,例如:软件/硬件验证和测试,约束解决,混合系统分析,安全性,生物学(计算机模拟分析)和几何问题.
主要是一些逆向,加密方面比较有用吧,对于位运算等等非常方便.
安装 支持Python2以及3各个版本,Linux下直接安装即可…
pip install z3-solver pipenv install z3-solver 使用 Solver()创建一个通用求解器.约束可以使用add方法添加.check()解决了断言的约束.
simplify可对z3表达式应用简单的转换
hrlp_simply() 打印所有可用选项
BitVec(‘x’, 16) 创建一个位向量变量,名称为x,具有16位.
快速入门 解不等式
x = Int('x') y = Int('y') solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 函数Int('x')创建一个名为x的整数变量。函数solve解决一个约束系统。上面的例子用到了两个变量x和y，以及三个约束条件。
Simplify
z3公式／表达式简化器
表达式分析
from z3 import * a, b, c = Ints('a b c') q, w, e = Reals('q w e') set_option(precision=30) solve(q**2 + w**2 == 3, q**3 == 2) x, y, z = BitVecs('x y z', 8) s = Solver() s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5784048ceed243c7d97ff6f65d9b3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4b6a790f3b23d315d7f1d93cbb6c18/" rel="bookmark">
			Java实训作业三（记事本程序的设计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、作品要求：
二、主要需求点分析：
1、菜单项目
2、文件结构​ 3、软件主界面
4、状态切换类菜单项JCheckBoxMenItem： 5、关于本程序对话框：
6、打开文件对话框：
7、另存为文件对话框：
8、字体设置对话框：
三、主要参考代码：
1、记事本入口主程序类文件：
2、主界面类文件：
3、功能主菜单类文件：
4、基础操作类文件--文件操作类文件：
5、基础操作类文件--字符编码判断类文件：
6、基础操作类文件--字体对话框类文件：
四、演示DEMO源代码在github上的仓库地址：
一、作品要求： 1、仿照Windows操作系统自带的记事本软件，完成Java版记事本程序的设计与制作。
2、每个班级刻录一张光盘，光盘封面写上班级信息、课程信息、指导老师姓名，如：2018计算机1班《Java实训作业》，指导老师：谢祥选。
3、在光盘上建立一个【班级】目录，在班级目录下再以【学号_姓名】方式创建学生目录，班级和学生目录请使用汉字中括符（【】）括起来，学生目录中的学号与姓名之间的连接符为英文的下划线（_），不是减号（-）。
4、把要上交的作品的项目根目录或项目工作空间目录完整的复制到学生自已的文件夹中，上交的作业中的项目目录不能用中括符（【】）括起来，必须保留开发时的原始目录结构与名称。
上交的作品光盘目录结构如下：
光盘F:\
|----【18计算机1班】
|----【20180324_张三丰】
|----LoginFrame
|----MyNotepad
|----20180325_李四光
|----MyCalculator
|----MyNotepad
|----20180368_小宇飞刀
|----LoginFrame
|----MyNotepad
……
二、主要需求要点分析： 1、菜单项目 2、文件结构 3、软件主界面 4、状态切换菜单项（JCheckBoxMenItem）： 5、关于本程序对话框： 6、打开文件对话框： 7、另存为文件对话框： 8、字体设置对话框： 三、主要参考代码： 1、记事本入口主程序类文件： import javax.swing.*; /** * 文件名：MenuFrameTest.java * 功能描述：记事本程序入口类文件 */ class MyNotepad { public static void main(String[] args) { try { //可跨平台风格，忽略时的默认风格 //String lookAndFeel = UIManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4b6a790f3b23d315d7f1d93cbb6c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a5e9ec3ea97bc3d34cb6220ecdc084/" rel="bookmark">
			PHP 操作 Elasticsearch 父子关系索引创建、搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 公司最近的需求有用到索引的关联关系查询，经过查询资料得知 Elasticsearch6.0 之后只支持使用 join datatype 方式构建父子关系文档，下面来介绍一下具体怎么使用。
创建索引 es中指定关联关系和数据库不同，es中有个join数据类型，是创建相同的索引文件中的父/子关系的特殊领域，建立父子关系最重要的一步是在创建索引的时候在mapping中声明某个字段是join类型字段，并且指定字段的值哪个是父文档哪个是子文档：
$host = ['192.168.1.10:9200']; $client = ClientBuilder::create()-&gt;setHosts($host)-&gt;build(); $params = [ 'index' =&gt; 'my_index', // 索引名称 'body' =&gt; [ 'mappings' =&gt; [ 'properties' =&gt; [ // 设置字段类型 'my_join_field' =&gt; [ // 字段名称 'type' =&gt; 'join', // 字段类型，join类型表示是联接数据类型 'relations' =&gt; [ // 指定连接关系 '父' =&gt; '子' 'parent' =&gt; 'child', // 一父一子 'parent_2' =&gt; ['child_1','child_2'] // 一父多子 ] ] ] ] ] ]; $response = $client-&gt;indices()-&gt;create($params); 以上代码指定了my_index 索引文档中my_join_field字段的值为 parent 是 child 的的父文档，parent_2是child_1和child_2的父文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a5e9ec3ea97bc3d34cb6220ecdc084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf0f83fd39d158ec5f94962510d8481/" rel="bookmark">
			element UI 表格序号倒序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 处理序号=》倒序 indexMethods (index) { // currentpage当前页码，this.tableData.length总条数，index索引值 if (this.tableData.length &lt; 10) { return (this.tableData.length - index) } else { return (this.tableData.length - ((this.currentpage - 1) * 10) - index) } } &lt;el-table :data="tableData" border style="width: 100%;"&gt; &lt;el-table-column type="index" align="center" label="序号" width="106"&gt; &lt;/el-table-column&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a98735c8b5b055f29b69478ce49f5a/" rel="bookmark">
			Java实训作业二（简易计算器的设计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次实训作业为，设计一个简易的计算器 目录
一、作业要求：
二、主要功能需求分析
三、参考代码
一、作业要求： 1、设计一个简易计算器的GUI窗口，窗口标题上必须含有学生姓名信息。窗口外观、按钮颜色、布局风格随意，但要求简洁、美观。
2、每个班级刻录一张光盘，光盘封面写上班级信息、课程信息、指导老师姓名，如：2018计算机1班《Java实训作业》，指导老师：谢祥选。
3、在光盘上建立一个【班级】目录，在班级目录下再以【学号_姓名】方式创建学生目录，班级和学生目录请使用汉字中括符（【】）括起来，学生目录中的学号与姓名之间的连接符为英文的下划线（_），不是减号（-）。
4、把要上交的作品的项目根目录或项目工作空间目录完整的复制到学生自已的文件夹中，上交的作业中的项目目录不能用中括符（【】）括起来，必须保留开发时的原始目录结构与名称。
上交的作品光盘目录结构如下：
光盘F:\
|----【18计算机1班】
|----【20180324_张三丰】
|----LoginFrame
|----.idea
|----out
|----src
|----MyNotepad
|----.idea
|----out
|----src
|----20180325_李四光
|----MyCalculator
|----.idea
|----out
|----src
|----MyNotepad
|----.idea
|----out
|----src
|----20180368_小宇飞刀
|----LoginFrame
|----.idea
|----out
|----src
|----MyNotepad
|----.idea
|----out
|----src
……
二、主要功能需求分析 1、设计一个简易计算器的GUI窗口，窗口标题上必须含有学生姓名信息。窗口外观、按钮颜色、布局风格随意，但要求简洁、美观可。
2、至少包含下图所示的计算功能（加减乘除，正负数、次幂、求余），如图：
3、完成一个计算器其他应有的功能。
三、参考代码 对一个网上比较小巧的计算器程序进行了修改，原作者的类设计规划合理，代码风格优良，注释详尽，非常值得借鉴。感谢原作者：https://blog.csdn.net/weixin_36279318/article/details/78486900
我在作者的设计上扩展几个本次实训作业需要完成的功能：
1、←（退格键）2、± （正负数）3、^ （求次幂）4、%（求余数） 实例截图：
扩展版的参考代码：
/** * 文件名：Calculator.java * 功能描述：简易计算器 */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a98735c8b5b055f29b69478ce49f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6c7ca963ed63af2f7f68c92175e561/" rel="bookmark">
			混淆矩阵含义及python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分类评估指标中定义的一些符号含义 TP：将正类预测为正类数，真实为0，预测也为0FN：将正类预测为负类数，真实为0，预测为1FP：将负类预测为正类数， 真实为1，预测为0TN：将负类预测为负类数，真实为1，预测也为1 二、混淆矩阵定义及表示含义 混淆矩阵是机器学习中总结分类模型预测结果的情形分析表，以矩阵形式将数据集中的记录按照真实的类别与分类模型预测的类别判断两个标准进行汇总。其中矩阵的行表示真实值，矩阵的列表示预测值。
二分类问题：
混淆矩阵 预测值 正（猫）负（狗） 真 实 值 正（猫） 3 0负（狗） 1 2 通过混淆矩阵我们可以轻松算的真实值猫的数量（行数量相加）为3=3+0，分类得到猫的数量（列数量相加）为4=3+1。真实狗的数量为3=1+2，分类得到狗的数量为2=0+2。同时，我们不难发现，对于二分类问题，矩阵中的4个元素刚好表示TP,TN,FP,TN这四个符号量 。
混淆矩阵 预测值 正 负 真 实 值 正 TP(a) FN(b) 负 FP(c) TN(d) 则：精确率：Precision=a/(a+c)=TP/(TP+FP)
召回率：recall=a/(a+b)=TP/(TP+FN)
准确率：accuracy=(a+d)/(a+b+c+d)=(TP+TN)/(TP+FN+FP+TN)
多分类问题： 混淆 矩阵 预测值 类别1类别2类别3 真 实 值 类别1 a b c类别2 d e f类别3 g h i 矩阵行数据相加是真实值类别数，召回率_类别1=a/(a+b+c) 。列数据相加是分类后的类别数， 精确率_类别1=a/(a+d+g)。对角线相加是分类准确率，准确率accuracy=(a+e+i)/(a+b+c+d+e+f+g+h+i)
三、Python代码实现混淆矩阵 sklearn.metrics.confusion_matrix(y_true, y_pred, labels=None, sample_weight=None) y_true:是样本真实分类结果，y_pred 是样本预测分类结果 ，labels是所给出的类别，通过这个可对类别进行选择 ，sample_weight 是样本权重。我们用confusion_matrix生成矩阵数据，然后用seaborn的热度图绘制出混淆矩阵数据：
import seaborn as sns from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6c7ca963ed63af2f7f68c92175e561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cf1cb9e05a935827d13ff93d8d0581/" rel="bookmark">
			kkfileview 文档预览安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网地址：kkfileview
1. 环境要求 Java: 1.8+
OpenOffice或LiberOffice(Windows下已内置，CentOS或Ubuntu下会自动下载安装，MacOS下需要自行安装)
2. 部署运行 1). 物理机或虚拟机上运行
从 码云发行版本 下载最新版发行包
解压kkFileView-2.x.x.zip包
打开解压后文件夹的bin目录，运行startup脚本（Windows下以管理员身份运行startup.bat，Linux以root用户运行startup.sh）
浏览器访问本机8012端口（http://127.0.0.1:8012 ）即可看到项目演示用首页
kkfileview有些项目依赖需要安装如下
gcc安装 gcc -v 检查gcc是否安装，如果安装则跳过，没有安装的参照下面链接安装gcc
https://blog.csdn.net/qq_37160920/article/details/98171706
OpenOffice 安装 登录openoffice官网下载适合的软件包
官网地址：http://www.openoffice.org/download/index.html
具体安装参考：https://www.cnblogs.com/fangts/p/11045564.html
redis 安装 参考： https://blog.csdn.net/qq_37160920/article/details/98174110
问题记录 OpenOffice需要shutdown两次才能将其关闭，记得 查看其进程，必要时将其 kill 掉。kkfileview项目启动，若出现openoffice链接失败的情况，查看是否有openoffice进程存在。如果有就kill掉 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4f16b08d6510c6bdc8abcac9322ae5/" rel="bookmark">
			获取javabean 属性,类型,值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 获取bean 属性,类型,值
*
* @param object
*/
public Map&lt;String, Object&gt; printFieldValue(Object object) throws InvocationTargetException, IllegalAccessException {
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
Method[] methods = object.getClass().getMethods();//取所有的方法
for (Method method : methods) {
if (method.getName().startsWith(“get”)) {
String lsName = method.getName().substring(3); // 属性
String type = method.getReturnType().getName(); //类型
Object invoke = method.invoke(object, null);// 值
if (null != invoke) {
map.put(lsName, invoke);
}
}
}
map.remove(“Class”);
return map;
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/401/">«</a>
	<span class="pagination__item pagination__item--current">402/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/403/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>