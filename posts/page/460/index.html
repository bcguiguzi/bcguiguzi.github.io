<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3e555dc06f0070578ce2d6df5cd81c/" rel="bookmark">
			快速入门Docker---用Docker搭建Python的开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先从 docker hub registry 找到需要的镜像的 Command
docker pull python:3.5 docker ps #查看镜像 在文件根目录新建目录 file,在 file目录中新建文件 pyth.py
#!/usr/bin/python print("Hello, World!");直接用 docker run 命令运行 pyth.py文件 docker run -v /file:/usr/src/file -w /usr/src/file python:3.5 python pyth.py 注意事项： -v 将主机的py文件目录挂载到容器中的/usr/src/file -w 指定容器的/usr/src/file目录为工作目录 python pyth.py 用容器中的python命令来执行工作目录的pyth.py 通过简单的编写Dockerfile实现
编写Dockerfile文件
通过 docker build 创建容器
运行产生结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc7fe9d103e5c9b13b9bf8e6fd7d862/" rel="bookmark">
			h5客服聊天（jssdk语音）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄个微信公众号中嵌入h5的客服聊天界面，在此记录一下，主要功能是长按录音，上滑录音，下滑取消录音。
客服接收用的环信1.4.5版本的webIm即时通讯sdk（主要难点在于jssdk录音完成后怎么发送给环信客服）,好了，接下来就看看实现步骤吧
1.在页面中引入微信jssdk文件&lt;script src="http://res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt;
2.配置jssdk开发配置-&gt;详细见官网点击打开链接，这里特别说下，
wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature, // 必填，签名，见附录1 jsApiList: wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature, // 必填，签名，见附录1 jsApiList: ['startRecord', 'stopRecord', 'playVoice', 'onVoiceRecordEnd', 'onVoicePlayEnd', 'uploadVoice'] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 }); 配置中的appId,timestamp,nonceStr,signature这几个参数都是我们后端丢给我的，jsApiList这个列表里面配置的都是在你的项目中运用了些jssdk的哪些功能，切记，这里一定要配置
3.该配置的都配置好了，接下来就可以调用jssdk的功能了，下面的代码实现功能是触摸开始，延时500毫秒后才算长按，录音开始（调用jssdk的wx.startRecord进行录音），播放录音动画（ps:这里动画本来想根据说话声音大小进行播放的，但是sdk没有获取录音中的音量信息,所以暂时用帧动画代替了，有知道的大佬支援下，非常感谢）
//自定义事件start var timer = "", //定时器 startX = 0, //开始x轴坐标 startY = 0, //开始y轴坐标 isSend = false; //记录是上滑还是下滑，下滑录音 $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc7fe9d103e5c9b13b9bf8e6fd7d862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c54cf52a15655c7380f4ea00dd8b9c6/" rel="bookmark">
			PostgreSQL登录及修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL登录 1、可通过客户端pgAdmin III直接登录 通过pgAdmin III登录PG库
2、可通过命令行 命令：psql -h 10.10.10.10 -U user -d postgres -p 5570 1 -h：数据库IP -U：登录用户 -d：登录的数据库 -p：登录端口
方法：进入postgreSQL的客户端安装目录（我的安装目录：C:\Program Files\PostgreSQL\9.4\bin），执行psql命令，其中\q表示退出数据库 命令行登录PG库 修改密码 直接执行以下sql即可修改密码
alter user pguser with password ‘new password’;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720f0ffe9cc9946e3138569c52bd0833/" rel="bookmark">
			Node学习入门篇（五）：Node数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系型数据库存储NoSQL数据库存储 MySQL 1) 安装node-mysql模块
npm install mysql 2) 创建程序逻辑
//引入模块 var mysql = require('mysql'); //创建表的SQL语句 var querySql = "CREATE TABLE IF NOT EXISTS work (" + "id INT(10) NOT NULL AUTO_INCREMENT," + "hours DECIMAL(5,2) DEFAULT 0," + "PRIMARY KEY(id))"; //连接数据库 var db = mysql.createConnection({ host:'127.0.0.1', user:'username', password:'password', database:'databaseName' }); //创建表 db.query(querySql, function(err) { if (err) { throw err; } console.log('Server started...'); server.listen(300,'127.0.0.1'); }) 3) 添加数据，防止SQL注入攻击 在添加到查询语句中之前，query方法会自动把参数转义，以防遭受到SQL注入攻击
exports.add = function(db, req, res) { exports.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720f0ffe9cc9946e3138569c52bd0833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8099b525857242268f765f7d71b406ce/" rel="bookmark">
			ping, telnet, tcping 命令使用及对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ping 命令 ping 命令只能检查 IP 的连通性或网络连接速度，无法具体到某个端口。
ping 命令使用 ICMP 协议，跟 IP 协议属于同一层次（网络层）。ping 命令在每次发数据包后都会等对方返回数据包。可以禁止 ICMP 协议，此时对方收到消息后不会回复。
端口是传输层 TCP/UDP 协议的概念，比如常用的 web 端口指的是 TCP 的 80 端口。使用网络层的 ping 命令是无法指定端口的。
ping 不通，可能是服务器确实没有开放这个端口，或是禁 ping 了。
ping 命令支持很多参数：
# ping Usage: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface] [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline] [-W timeout] [hop1 ...] destination 一般使用最简单的用法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8099b525857242268f765f7d71b406ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd22781779511c724fc0b37479bffb0d/" rel="bookmark">
			mooc程序设计与算法（三）第三周 类和对象提高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this指针 this 指针，作用是指向成员函数所作用的对象 非静态成员函数中可以直接使用this代表指向该函数作用的对象的指针 静态成员函数中不能使用this指针，因为静态成员函数并不作用于某一个具体的对象 静态成员函数真实的参数个数与写出的个数一样，普通函数多一个，就是this指针 #include &lt;iostream&gt; using namespace std; class A{ int i; public: void pri(){ cout&lt;&lt;"hello"&lt;&lt;endl; } }; int main() { A a; a.pri(); return 0; } 这个例子会输出”hello”，说明调用了pri函数，但是没有对a初始化，因为this指针相当于调用了
void pri(A *this){cout&lt;&lt;"hello"&lt;&lt;endl;} 这样一句话。。。。但是如果输出i的值，会出错
静态成员 在说明前面加了static加了关键字的成员 sizeof不会计算静态成员变量 静态成员遍历，为所有的对象共享 静态成员函数并不具体作用于某个对象 静态成员不需要对象就能访问 静态成员变量（函数）是全局变量（函数），那怕一个对象都不存在，它也存在 为什么引入？因为把和某些类相关的变量和函数写进类，便于维护 静态成员函数中，不能访问非静态成员变量和函数。 #include &lt;iostream&gt; using namespace std; class CRectangle { private: int w, h; static int nTotalArea;//静态成员变量 static int nTotalNumber; public: CRectangle(int w_, int h_){ //构造函数 w=w_; h=h_; nTotalNumber++; nTotalArea+=w*h; }; ~CRectangle(){ //析够函数 nTotalArea-=w*h; nTotalNumber--; cout&lt;&lt;endl&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd22781779511c724fc0b37479bffb0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ccbe6d3987a9fac2c5bfea613c69b7/" rel="bookmark">
			VS中的路径宏如 $(OutDir) 等含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： $(IntDir)
为中间文件指定的相对于项目目录的目录路径。它解析为“中间目录”属性的值。
$(OutDir)
输出文件目录的路径，相对于项目目录。这解析为“输出目录”属性的值。
$(DevEnvDir)
Visual Studio .NET 的安装目录（定义形式：驱动器 + 路径）；包括尾部的反斜杠“\”。
$(InputDir)
输入文件的目录（定义形式：驱动器 + 路径）；包括尾部的反斜杠“\”。如果该项目是输入，则此宏等效于 $(ProjectDir)。
$(InputPath)
输入文件的绝对路径名（定义形式：驱动器 + 路径 + 基本名称 + 文件扩展名）。如果该项目是输入，则此宏等效于 $(ProjectPath)。
$(InputName)
$(RemoteMachine) 设置为“调试”属性页上“远程计算机”属性的值。有关更多信息，请参见更改用于 C/C++ 调试配置的项目设置。
$(References)
以分号分隔的引用列表被添加到项目中。
$(ConfigurationName)
当前项目配置的名称（例如“Debug”）。
$(PlatformName)
当前项目平台的名称（例如“Win32”）。
$(Inherit)
指定在由项目生成系统所撰写的命令行中，继承的属性出现的顺序。默认情况下，继承的属性出现在当前属性的末尾。
$(NoInherit)
使任何将被继承的属性不被继承。若还要避免同级级别的计算，请使用 (StopEvaluating)。使用 ( S t o p E v a l u a t i n g ) 。 使 用 (NoInherit)会导致对于同一属性忽略任何出现的 $(Inherit)。
$(StopEvaluating)
立即停止计算链中宏的计算。出现在 (StopEvaluating)之后的任何值将不出现在宏的计算值中。如果 ( S t o p E v a l u a t i n g ) 之 后 的 任 何 值 将 不 出 现 在 宏 的 计 算 值 中 。 如 果 (StopEvaluating) 在 (Inherit)之前，计算链中当前位置的继承值将不会连接到宏值。 ( I n h e r i t ) 之 前 ， 计 算 链 中 当 前 位 置 的 继 承 值 将 不 会 连 接 到 宏 值 。 (StopEvaluating)是 $(NoInherit) 的功能超集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ccbe6d3987a9fac2c5bfea613c69b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc1c1342f905c6e56b202460ddb00f5/" rel="bookmark">
			android 启动其他应用两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：前提是知道待打开应用的包名与类名
private void openOtherApp1() { ComponentName apk2Component1 = new ComponentName("com.xxx","com.xxx.activity.xxxActivity"); Intent mIntent = new Intent(); mIntent.addCategory(Intent.CATEGORY_LAUNCHER); mIntent.setComponent(apk2Component1); startActivity(mIntent); } 如果你要的启动的其他应用的Activity（此处的类名）不是该应用的入口Activity，那么在清单文件中，该Activity节点一定要加上android:exported=true，表示允许其他应用打开。否则会报错“java.lang.SecurityException: Permission Denial.....”。若是入口activity则不需要加。
若不知道类名，则用方法二
方法二：前提只需知道包名，若不知道包名可以下载一个AndroidRocket小火箭软件查看
private void openOtherApp() { String packageName = "com.inpor.xxx"; PackageInfo pi = null; try{ pi = getPackageManager().getPackageInfo(packageName, 0); Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null); resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER); resolveIntent.setPackage(pi.packageName); List&lt;ResolveInfo&gt; apps = getPackageManager().queryIntentActivities(resolveIntent, 0); ResolveInfo ri = apps.iterator().next(); if (ri != null ) { packageName = ri.activityInfo.packageName; String className = ri.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc1c1342f905c6e56b202460ddb00f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9bedfaa4c29ae046fc59f2a7518803/" rel="bookmark">
			C&#43;&#43;  algorithm头文件函数的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		algorithm /*algorithm头文件下的常用函数*/ /* 使用algorithm头文件，需要在头文件下加一行using namespace std;” */ //常用函数max(), min(), abs() //swap() //reverse() //next_permutation() //fill() // sort() //lower_bound和upper_bound() /*max(), min(), abs()的使用*/ #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; int main() { int x =1, y =-2; cout &lt;&lt;max(x,y)&lt;&lt; " "&lt;&lt; min(x,y)&lt;&lt;endl; cout &lt;&lt; abs(x)&lt;&lt;" "&lt;&lt;abs(y)&lt;&lt;endl; return 0;	} */ /* swap()的使用 swap(x,y)用来交换x和y的值，示例如下： */ #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int x=1, y=2, z; swap(x, y); cout&lt;&lt; x &lt;&lt; " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9bedfaa4c29ae046fc59f2a7518803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022e6ab0c62bdc906517108d78bcb275/" rel="bookmark">
			如何在 Linux 下大量屏蔽恶意 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，服务器受到了一个ip的不断尝试失败登录（命令：lastb），所以进行了屏蔽，屏蔽教程参考 https://linux.cn/article-4904-1.html。 注意点： 1.安装iblocklist2ipset 需要使用python2 的pip 安装才行 2.在centos上安装会报错“Error during parsing: ‘ascii’ codec can’t decode byte 0x8b in position 1: ordinal not in range(128)”，处理的方法如同github 提出的解决方案，将gz去掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769f5372ca3d3125f8951164e69d72b6/" rel="bookmark">
			Git - 暂存区及撤销修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 暂存区 每个 Git 仓库中，都有一个隐藏目录 .git 用于存放 Git 仓库的相关信息，包括暂存区（称为 stage）、自动创建的 master 分支以及指向 master 分支的 HEAD 指针。
每次提交文件时：
git add 添加文件到暂存区。git commit 提交更改，把暂存区的所有内容一次性全部提交到当前分支，清空暂存区。 2. 撤销修改 因为暂存区的存在，撤销修改分为几种情况（通过 git status 查看仓库状态时会提示相关撤销修改的命令）：
修改后，文件没有放入暂存区（即文件一直在工作区）：用 git checkout -- 文件名 撤销工作区的改动（回到跟版本库一样的状态，即回到最近一次 git commit时的状态，所有改动全部清除）修改后，文件放入暂存区，且文件没有再次修改（即文件已经进入暂存区）：分两步：先用 git reset &lt;文件名&gt; 撤销 git add 操作（此时更改仍留在工作区），再执行 git checkout -- 文件名 清除工作区的改动修改后，文件放入暂存区，且文件再次修改：分三步：先用 git checkout -- 文件名 撤销工作区的改动，再用 git reset &lt;文件名&gt; 撤销 git add 操作（此时更改仍留在工作区），最后执行 git checkout -- 文件名 清除工作区的改动 通过 git checkout -- 文件名 命令可以撤销文件在工作区的修改。 通过 git reset 文件名 命令可以撤销指定文件的 git add 操作，即这个文件在暂存区的修改。 通过 git reset 命令可以撤销之前的所有 git add 操作，即在暂存区的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769f5372ca3d3125f8951164e69d72b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581c040f9b40e850549c79ca5d802919/" rel="bookmark">
			Web站点与Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web站点是由一组分层次的HTMl文档、媒体文件及相关目录结构组成，注重的是信息的浏览。
Web应用是一个在服务器端具有动态功能的Web站点，使用HTML form作为客户端运行代码的用户界面。
Web应用注重的是业务功能的实现。常见的计数器、留言板、聊天室和论坛BBS等，都是Web应用程序，不过这些应用相对比较简单，而Web应用程序的真正核心主要是用户的业务需求和对数据库进行处理，比如管理信息系统（Management Information System，简称MIS）就是这种架构最典型的应用。
不管是 Web站点还是Web应用，我们都会把它理解为一个软件，只不过这个软件需要浏览器来帮我们呈现界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb05fe76fa9e59fb0a968ee313ae8abb/" rel="bookmark">
			[操作系统] FAT文件系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.第一章--磁盘结构概述1.1保留区(含DBR--DOS Boot Record)1.2FAT区1.3数据区 第二章--FAT32磁盘结构介绍FAT32文件系统简介文件分配表文件分配表如何记录文件所包含的簇 第三章--fat文件系统目录项文件(夹)内容 1.第一章–磁盘结构概述 fat磁盘物理上分为以下四部分组成：
保留区(含MBR–Main Boot Record)保留区(含DBR–DOS Boot Record)FAT区数据区 1.1保留区(含DBR–DOS Boot Record) 保留区含有一个重要的数据结构–系统引导扇区DBR。FAT12、FAT16的保留区通常只有一个扇区。而FAT32保留的多些，除了0号扇区外，还有一些其他的扇区，其中包括了DBR的备份扇区。
1.2FAT区 FAT区由文件分配表构成–FAT1,FAT2,FAT2紧跟在FAT1后面，是FAT1的备份
1.3数据区 数据区是保存数据的，其中根目录也保存在此。这一区域不以扇区管理，而是以簇进行管理。
第二章–FAT32磁盘结构介绍 FAT32文件系统简介 FAT(File Allocation Table,文件分配表)文件系统是Windows操作系统所使用的一种文件系统，他的发展过程经历了FAT12,FAT16,FAT32三个阶段。FAT文件系统用 “簇” 作为数据单元。一个“簇”由一连串的扇区组成，簇所含的扇区数必须是 2的整数次幂 。簇的最大值是64个扇区，即32kb。 本文中一簇是4kb。所有簇从2开始进行编号，每个簇都有一个自己的编号。用户文件和目录都存储在簇中。文件系统分配磁盘按照簇进行分配，因此一个文件即使只有1kb，那么也会被分配4kb的空间。 文件分配表 文件和文件夹内容存储在簇中，如果一个文件或者文件夹需要多余一个的簇进行存储，那么通过文件分配表建立起多个簇的联系。。FAT结构用于指出下一簇，同时也说明了簇的分配状态。FAT12、FAT16、FAT32的不同就在于文件分配表的大小不同。 文件分配表如何记录文件所包含的簇 我们已经知道，在文件分配表中记录了数据区中簇之间的关系。而数据区中的簇就是存储文件或文件夹信息的基本单位。
FAT32中簇地址是用4字节进行编址的，故在FAT表中，是以4个字节为单位进行划分，每个单元存储一个簇地址。 **0号地址与1号地址被系统保留并存储特殊标志内容。**从2号地址开始，第i号地址对应数据区中i号簇。我们称 FAT表中的地址为FAT表项，FAT表中记录的值为FAT表项值。当文件系统被创建时，FAT表会被清空，在FAT1和FAT2表中的0号地址与1号地址会被写入特定值。由于创建文件系统的同时会创建根目录，也就是在数据区为根目录分配一个簇的空间(2号簇，起始簇)在FAT表中2号地址写入一个结束标记。当FAT表中第i号地址对应的簇未被使用时，表项值为0当FAT表中第i号地址对应的簇是记录一个文件或文件夹的最后的簇时，表项值为0xFFFFFFFF。下表给出了FAT表项值的详细含义(更详细表项值含义请自行利用百度或Google) 表项值(32位)簇描述符含义00000000H"0"值（未分配使用）00000001–FFFFFFEFH“一个簇号”（已占用）FFFFFFF7H坏簇FFFFFFF8–FFFFFFFFH“EOF”（文件结束簇） 第三章–fat文件系统 第二章中文件分配表已经建立起了簇之间的联系。那么对于文件系统来说，如何确定文件与文件、文件夹与文件之间的逻辑存储关系呢？本章中将介绍此内容。
目录项 首先介绍下目录项的概念：
FAT文件系统的每一个文件和文件夹都被分配到一个目录项，目录项中记录着文件名、大小、文件内容起始地址以及一些其他元数据(简单来说就是文件或文件夹本身的属性)。(具体存储格式可以百度或者Google)跟在目录项之后的是文件或文件夹的具体内容。目录项都有规定好的固定长度以及每个位置代表的含义(以下给出了fat32中目录项的32个字节的含义) 文件(夹)内容 有了目录项，就有了文件或文件夹本身的属性。紧跟目录项后是文件或文件夹的内容。
对于文件类来说，存储的就是文件本身的内容对于文件夹来说，存储的是一条一条的记录，每条记录是此文件夹下包含的文件或文件夹(同时也包含父目录…当前目录.)每条记录都应该有固定的格式，但总归需要包含以下内容： 1.记录是文件还是文件夹 2.记录的起始簇号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c3fe111cbf86f2c1fccac5a8f3b293/" rel="bookmark">
			SSD1306部分命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令描述
1. 基础命令
1.1 为页地址模式设置列低半字节的开始地址（00h~0Fh）
这个命令专门为8位列地址的低半字节设置以通过页地址模式显示RAM中的数据。而每一个数据使用后列地址会自动增加。请参考表格9-1的部分以及1.3的部分来了解详细情况。
1.2 为页地址模式设置列高半字节的开始地址（10h~1Fh）
这个命令专门为8位列地址的高半字节设置以通过页地址模式显示RAM中的数据。而每一个数据使用后列地址会自动增加。请参考表格9-1的部分以及1.3的部分来了解详细情况。
1.3 内存地址模式设置（20h）
在SSD1306中有三种地址模式分别为：页地址模式，水平地址模式和垂直地址模式。这个命令用于设置内存地址为上面三种地址模式中的一种。在这里“COL”表示图表显示数据RAM列。
页地址模式（A[1:0]=10xb）
在页模式中，显示RAM读写完后，列地址指针自动加一。如果列地址指针到达了列地址尾部，列地址指针重新回到列地址开始的地方，但是页地址指针不变。用户要设置新的页指针和列指针来获取下一页RAM的内容。而PAGE和列地址指针扫描每页地址的模型在下面。
在正常的RAM数据显示读写以及页地址模式时，下面几项是需要去定义获取RAM指针开始的定位：
通过命令B0h~B7h，设置目标显示屏当地的页开始地址
通过命令00h~0Fh，设置低列开始地址指针
通过命令10h~1Fh，设置低列开始地址指针
例如如果页地址设为B2h，低列地址为03h，而高列地址为00h，那么也就意味着开始列是PAGE2的SEG3，而RAM的获取指针定位到下图中。而输入的数据将会被写入列3的位置。
水平地址模式（A[1:0]=00b）
在水平地址中，显示RAM读写完后，列地址指针自动加一。如果列地址指针到达了列地址尾部，列地址指针重新回到列开始地址，同时页地址指针也加一。而PAGE和列地址指针扫描每页地址的模型在下面。当列地址指针和页指针都到达末尾时，两个指针会调回到列地址和页地址指针开始的位置。
垂直地址模式（A[1:0]=01b）
在垂直地址中，显示RAM读写完后，页地址指针自动加一。如果页地址指针到达了页地址尾部，页地址指针重新回到页开始地址，同时列地址指针也加一。而PAGE和列地址指针扫描地址的模型在下面。当列地址指针和页指针都到达末尾时，两个指针会调回到列地址和页地址指针开始的位置。
在正常的RAM数据显示读写以及水平/垂直地址模式时，下面几项是需要去定义获取RAM指针开始的定位：
通过命令21h，设置目标显示屏当地的列开始和结束地址
通过命令22h，设置目标显示屏当地的页开始和结束地址
1.4 设置列地址（21h）
这个三个一组的命令是为设置显示数据RAM的列开始和结束地址专门设立。这个命令也设置了列地址指针的开始地址。在图显RAM数据时这个指针用来定义当前的读写列地址。如果通过命令20h使能水平地址增加模式，当完成一列数据的读写后这个指针将自动增加到下一个列地址。而当列地址指针到达列地址尾部他会调到列开始地址处，同时行地址也会自增一调到下一行。
1.5 设置页地址（22h）
这个三个一组的命令是为设置显示数据RAM的页开始和结束地址专门设立。这个命令也设置了页地址指针的开始地址。在图显RAM数据时这个指针用来定义当前的读写页地址。如果通过命令20h使能垂直地址增加模式，当完成一页数据的读写后这个指针将自动增加到下一个页地址。而当列地址指针到达列地址尾部他会调到页开始地址处。
下图显示了列地址和页地址指针移动的方式：列开始地址设为2，列结束地址设为125，而页开始地址设为1，页结束地址设为6。同时通过命令20h使能水平地址增加模式。在这种情况下，图显RAM数据只有从列2到列125以及从页1到页6的数据可以被获得。此外，列地址指针设为2而页地址指针设为1，在完成读写一像素数据的操作后列地址自动增加一以获取下个RAM地址的读写操作。而当列地址到达125后，他将重新返回到列地址2同时页地址自动加一。而当到达页6的列125时，页回到页1而列回到列2.如下图
1.6 设置显示开始行（40h~7Fh）
这个命令集用来设置显示开始行寄存器通过选择0到63中任何一值从而定义显示RAM的开始地址。当此值为0时RAM行的0映射到COM0中，当此值为1时RAM行的1映射到COM0中。参考表10-1获取更多说明。
1.7 设置BANK0的对比控制（81h）
这个命令集用于设置显示的对比控制。这个芯片有256个对比阶层，分别从00h到FFh，而区域的输出电流随阶层的增加而增加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d606e3c57bb9ca39960b06c9c49e09/" rel="bookmark">
			linux服务器-管理维护建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、linux的目录作用，linux是一个服务器，大家在使用的过程中需要遵守目录规则，方便团队的其他成员操作，以下是linux常用的目录：
/bin/:存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行
/sbin/:保存于系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看
/usr/bin/:存放系统命令目录，普通用户和超级用户都可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看
/usr/sbin/:存放根文件系统不必要的系统管理命令
/boot/：系统启动目录，保存系统启动相关的文件
/dev/:设备文件保存位置，linux中所有内容都是以文件形式保存，包括硬件
/etc/ 配置文件保存文职，系统内所有采用默认安装方式（rpm安装）的服务的配置文件全部都保存在这个目录中，用户账号密码和启动脚本和常用的配置文件
注意：这里的单用户类似于Windows中的安全模式，主要是修复系统使用的
home目录下主要是存放数据文件
2、服务器维护注意事项：
远程服务器不能关机只能重启
重启时应该关闭服务
不要在服务器访问高峰运行或者高负载运行
远程配置防火墙时不要把自己提出服务器
指定合理的密码规范并定期更新
合理分配权限（如果每个用户赋予root权限，出错的几率就会多）
定期备份重要数据和日志（注意：一定要养成备份的习惯，备份时不要把鸡蛋放在同一个篮子里面）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389808d0af9715e9acb3296b124f3397/" rel="bookmark">
			Android px转dip px转sp法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些情况下，美工往往给我的都是px 这个时候我们就需要根据屏幕分辨率把px转成dip或者sp 下面就是计算公式：
https://blog.csdn.net/xiaoyuan511/article/details/39205969
[html] view plain copy &lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:background="@android:color/white"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:padding="20dp" android:text="开始"/&gt; &lt;/FrameLayout&gt; [java] view plain copy package com.example.test5; import android.app.Activity; import android.content.Context; import android.os.Bundle; import android.util.DisplayMetrics; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.view.Window; import android.widget.Toast; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.main); findViewById(R.id.button).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Test(); } }); } public boolean isGreaterThan(String time){ String time1=time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389808d0af9715e9acb3296b124f3397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d4fa6782824e7498f0a4af955c12f8/" rel="bookmark">
			LitePal数据库插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编辑你的build.gradle文件并添加下面的依赖库：
dependencies { compile 'org.litepal.android:core:1.6.1' } 2.配置litepal.xml 在项目的assets文件夹中创建一个文件，并将其命名为litepal.xml，创建步骤为app–src–main–new–directory，命名为assets，在assets文件夹下创建litepal.xml（assets–new–File）。然后将以下代码复制到其中。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;litepal&gt; &lt;!-- Define the database name of your application. By default each database name should be end with .db. If you didn't name your database end with .db, LitePal would plus the suffix automatically for you. For example: &lt;dbname value="demo" /&gt; --&gt; &lt;dbname value="demo" /&gt; &lt;!-- Define the version of your database. Each time you want to upgrade your database, the version tag would helps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d4fa6782824e7498f0a4af955c12f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19bb2e1291d9dba69a4acd86732530d/" rel="bookmark">
			google cloud使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 申请vm实例 http://cs231n.github.io/gce-tutorial/ 根据cs231n这门课的tutorial，申请一个适合自己的vm实例。远程访问google cloud上的jupyter https://haroldsoh.com/2016/04/28/set-up-anaconda-ipython-tensorflow-julia-on-a-google-compute-engine-vm/#clientside 按照这个步骤配置，注意： vm实例中的防火墙配置端口要和jupyter的配置文件中的端口一致，否则无法访问。比如我的防火墙配置为： 那么就只有端口7000可以供外界访问，jupyter的配置文件中应相应改为： 文中介绍有个选择建议选option B：using screen，因为这个可以Press CTRL-A, D to detach from the screen and take you back to the main command line。文中有个命令错误，应为： gcloud compute ssh –zone= \ –ssh-flag=”-D” –ssh-flag=”1080” –ssh-flag=”-N” 即把最后一个参数去掉。最后一步启动浏览器时，直接在windows cmd命令中输入即可。如果遇到jupyter kernel和当前环境python版本不一样，建议重新安装jupyter(conda install jupyter) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8c9c1d726e88d7d33bdc3e4d3b9d51/" rel="bookmark">
			windows下用pycharm安装tensorflow简易教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019.4.14更新 下面的内容挺老了，建议批判性阅读，各种版本一直在变化， 最好的教程，果然还是tensorflow和pytorch的英文原网。Windows下面办公还行，不是很适合开发，也就跑跑小代码。我现在一般在windows上使用SSH连接远程linux的服务器，直接使用远程配置的解释器环境(pycharm有相应SSH功能，配置一下就好)，这样可以方便的开着音乐，边看资料边coding，找机会看直播摸鱼。
原文 最近开始学习深度学习的相关知识，准备实战一下，看了一些关于tensorflow安装的博客，绕了一些弯，因此来填一下坑(多余安装的或者非windows)，主要围绕使用pycharm时需要用到tensorflow的安装过程。
环境：windows10专业版。只是想简单跑一下tensorflow的话，安装过程真的很简单。
如果你有“安装IDE并关联编译器"的经验，不想看复杂的安装说明，可以尝试看这个目录凭自己的理解装完，有问题细看。
1.安装python，建议3.5以上版本
2.安装pycharm，在pycham中关联python解释器，即给出Python.exe所在的路径。
3.Pycharm中File-&gt;settings-&gt;Project xxx:-&gt;Project interpreter，右侧列表任意双击一项就可以打开“Available Package(可安装的包的列表)”，找到你要的tensorflow版本点击install Package。gpu版需要显卡支持CUDA，并安装CUDA和cuDNN。
前言
首先，对于windows下安装tensorflow，有的博客上来就叫装Anaconda、装CUDA(详细自行搜索)，我觉得并不是很好。关于Anaconda，本质是个整合好的包，五六百M的样子，里面有python和一些科学包，里面没有tensorflow。学长给我了包但我并没用，实际上里面好多包我用不到，我觉得用到什么下什么就行了，因为pip很方便，尤其是配上pycharm以后，其实并不需要像别的教程那样使用pip指令去获得包。 Anaconda真香，一键配置，但是裸装不用进虚拟环境也还不错。
1.安装python(如果你已经装有python，可以跳过这步)
指的是python的解释器(interpreter)和一些套件，有点类似于学C的时候的编译器的感觉，找到资源运行一下exe基本就装好了。关于版本，tensorflow1.2以后的版本需要3.5以后的版本。关于2.x与3.x的区别有哦兴趣可以参考
http://www.runoob.com/python/python-2x-3x.html
2.选择一个IDE
好的IDE可以提高效率，我使用的pycharm，这个看个人喜好。Anaconda有自带spider。
pycharm资源和安装教程很多，这里略过。
例如：https://blog.csdn.net/yctjin/article/details/70307933?locationNum=11&amp;fps=1
IDE安装的时候会询问是否关联解释器，如果不小心点过去了，也可以打开File-&gt;Project:xxx-&gt;Project interpreter来关联解释器的路径，这个过程和使用codeblocks关联编译器差不多。至此基本的python已经可以用了。
图1 Project interpreter
另：File-&gt;settings-&gt;Color Scheme可以选择主题。
3.安装tensorflow
一些教程比较推荐的方法是使用pip，这个很方便。在python目录下的Scripts文件夹里有pip.exe和pip3.exe。通过在命令行输入一些指令就可以完成安装了。详细：https://blog.csdn.net/u010099080/article/details/53418159
但我cmd真的用的不太好，pycharm安装其实更加方便(本质还是pip，只不过不需要自己输指令)
方法来源：https://jingyan.baidu.com/article/335530dafdbb3619cb41c3a8.html
方法：在如图1的界面中，任意双击一个packge，例如pip。接着你就能看到可安装的包的列表了，找到你需要的package后点install package就好了，就这么简单。右边栏是包的介绍，下方可以选择特定的版本（用Python3.6下不到1.2之前的版本）。列表里蓝色的是已经装好的。
装好以后你的列表里就有了，如上图1所示。就算只装了tensorflow也会带着一堆配套的东西，比如numpy，tensorboard；完全不用担心。另外需要pandas之类的话，安装同样的方法安装即可。
如果你需要用GPU跑tensorflow，则应确保你的显卡支持CUDA，且应该安装CUDA和cuDNN，并选择tensorflow-gpu
详细见：https://blog.csdn.net/u010099080/article/details/53418159
不同版本的tensorflow支持特定版本的CUDA，CUDA、cudnn应当与tensorflow配套
好多教程没有强调，发布的也比较早，容易有坑。
tensorflow1.6开始支持CUDA9.0，cuDNN也需要配套的，找cuDNN x.x.x for CUDA9.0这样的。
tensorflow1.6或1.7用CUDA9.1是不行的，该用9.0，我就被坑了。不过好在有解决的方法，非常感谢下面这篇：
https://blog.csdn.net/qq_36556893/article/details/79433298
于是我写了一篇详细的关于使用CUDA9.1的tensorflow的教程：
https://blog.csdn.net/heros_never_die/article/details/79871564
更新：tensorflow的包是比较大的，安装起来比普通的小包要慢很多，请保证程序正常运行且网络通畅的条件下耐心等待。如果使用命令行与pip安装的话，是可以明确看到安装进度的，对于安装过程非常有疑问的可以用这种方法。
后记
试出的迷一般其他的坑。
如果装了tensorflow，手贱再安装tensorflow-gpu，默认会运行tensorflow-gpu。同学那机子不支持CUDA，就开始报错。而上面的安装方法的那个列表不支持删除。可以打开cmd，输入pip list，这样可以看到所有已经安装的包。pip uninstall tensorflow和pip uninstall tensorflow-gpu就可以删除这两个包。然后重新安装tensorflow。
如果你的电脑是window系统且安装了两个python解释器，比如3.6和2.7，那么上面点install package的时候会出错，而且直接在cmd里使用pip指令也出问题，找不到资源。我老老实实的卸了2.7.
更新：在linux服务器上同时安装了python3.6和python2.7，可以互不影响的运行。主要原因在于相关程序的路径指定。那么这样推测，在windows上适当的修改环境变量，可以使得不同版本的python正常工作。
关于：“Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2”的警告是说你的CPU支持AVX2指令集，可以运行的更快，但是这个版本的tensorflow不支持，无视掉就好，或者安装教程加入屏蔽警告的语句(每次都加多麻烦，反正这个也没影响，我真的想快就用gpu版或者服务器了)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8c9c1d726e88d7d33bdc3e4d3b9d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f106a96c7d25de9dfb0109ff9a0ccea/" rel="bookmark">
			作为移动端(Android)开发的我已被前端框架Bootstrap所折服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Bootstrap介绍： 一年前的我还沉浸在移动端各种适配和优化中不能自拔，为了适配市场的各种分辨率，我拿着谷歌百分比布局，也有生成各中分辨率下的尺寸文件，或通过测量屏幕宽高来定义同比例缩放的包裹控件等达到适配效果。当我路过Web前端搞了css+html+javascript+jquery之后同样也会遇到适配问题，了解了一些前端框架，今天晚上看到了Bootstrap这个框架，Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。相信自己你可以半小时搞定它，让你前端达到中级水平。 二，Bootstrap的好处 如果你学完过Html+css我相信对于很多美丽漂亮的弹窗，按钮，导航栏，标签，轮播图，…..等等。最主要的是适配各种分辨率的屏幕，甚至是手机哦，而Bootstrap这个框架让你轻松达到响应式页面适配各种屏幕，以及轻松达到美丽漂亮的页面布局。
三，先来看看Bootstrap所构建的小例子组件和框架图片如下： 自己写的案例网页： . . . 等等
四，如何搭建Bootstrap架构
第一步:
去bootstrap官网下载Bootstrap源码和库。http://www.bootcss.com/ 第二步:
导入bootstarp.css 第三步：
导入jquery.js 第四步：
导入bootstrap.js 第五步：
添加一个meta标签 支持移动设备 &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 第六步.
将所有的内容放入到布局容器中. Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处类 第七步：
主要是对于系统栅格化理解了。其他都是回调类。
就这么简单如下案例快速搭建一个Bootstrap的环境：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!--导入css--&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css" /&gt; &lt;!--导入jquery.js--&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js"&gt; &lt;/script&gt; &lt;!--导入bootstrap.js--&gt; &lt;script type="text/javascript" src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="border: 1px solid firebrick;"&gt;原始方式&lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f106a96c7d25de9dfb0109ff9a0ccea/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/459/">«</a>
	<span class="pagination__item pagination__item--current">460/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/461/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>