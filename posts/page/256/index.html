<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499787b2102d040dff643fc3620fa99d/" rel="bookmark">
			C语言用函数指针数组、回调函数实现加减乘除运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、调用函数实现
二、函数指针数组实现
三、回调函数实现
一、调用函数实现 使用传统方法编写函数再调用函数，用switch语句实现： #include&lt;stdio.h&gt; int Add(int x, int y) { return x + y; } int Sud(int x, int y) { return x - y; } int Xud(int x, int y) { return x * y; } int Cud(int x, int y) { return x / y; } int main() { printf("********************\n"); printf("*******1.加法*******\n"); printf("*******2.减法*******\n"); printf("*******3.乘法*******\n"); printf("*******4.除法*******\n"); printf("*******0.exit*******\n"); printf("********************\n"); int x=0, y=0, n,ret; do { printf("请选择:\n"); scanf("%d", &amp;n); switch (n) { case 1: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499787b2102d040dff643fc3620fa99d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1c91c4880ec09d9e26f45800f3be86/" rel="bookmark">
			Matplotlib绘图笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matplotlib绘图 引言绘图步骤创建画布图片的参数设置选择特定API使用数据绘制所需图形图形显示 完整代码展示 引言 不管是做实验、科研还是工作，对我们来说，对实验过程以及结果使用图片的形式进行可视化具有重要意义。图片可以将结果直观地呈现给我们，辅助我们分析问题、解决问题。本篇博客简单记录一下自己关于使用Python和Matplotlib绘图的学习心得。Matplotlib是一个强大的绘图工具开源库，它可以绘制各种各样的图形，曲线图、折线图、点状图、雷达图、条形图…而且还有大量的参数设置使得我们可以方便地改变图片的样式，使其更符合要求，更美观。
Matplotlib的规范绘图一般有以下几个步骤：
创建画布图片的参数设置选择特定API使用数据绘制所需图形全局设置（坐标轴、标题…）图形显示 绘图步骤 创建画布 想象一下，我们要画一幅画，是不是得先找到一张纸，在Matplotlib中也是一样的，我们得先创建一副画布。Matplotlib有专门创建画布的API。
matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=&lt;class 'matplotlib.figure.Figure'&gt;, clear=False, **kwargs) 参数含义：
num：图的唯一标识符。可以选择整型、字符串或者Figure类型。如果具有这个num的图像已经存在，则该图像被激活并返回。整数指的是图，number属性和字符串是指图形标签。如果是没有带有标识符的图形或调用API的时候没有设置num，则创建一个新图形，使其处于激活状态并返回。 如果 num 是一个 int，它将用于 Figure.number 属性，否则，使用自动生成的整数值（从 1 开始并为每个新图形递增）。 如果 num 是字符串，则图形标签和窗口标题设置为此值。figsize(float, float)：表示创建画布的宽，高（英寸）。默认值：rcParams[“figure.figsize”] (默认值：[6.4, 4.8])。dpifloat：以每英寸点数为单位的图形分辨率。默认值：rcParams[“figure.dpi”] (默认值：100.0)。facecolorcolor：背景颜色。默认值: rcParams[“figure.facecolor”] (默认值: ‘white’)。edgecolorcolor：边缘颜色。默认值: rcParams[“figure.edgecolor”] (默认值: ‘white’)。frameon：布尔类型, 默认值: True。如果设置为false, 禁止绘制图框。
Figure：Figure 的子类。可选择自定义自己的Figure实例。
clear：布尔类型,默认值: False。如果设置为True，存在的图像将会被清理。 函数matplotlib.pyplot.figure()返回一个Figure对象，返回的 Figure 实例也将传递给后端的 new_figure_manager，这允许将自定义 Figure 类挂钩到 pyplot 接口。 额外的 kwargs 将被传递给 Figure init 函数。
图片的参数设置 在参数详解里边我们看到了rcParams，这是一个字典类型的数据，里边包含了很多对于绘图的设置。
rcParams里边包含很多参数，比如：
参数功能axes.labelsizex 和 y 标签的字体大小axes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1c91c4880ec09d9e26f45800f3be86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11041b6ebf48a8c8d8b456efb74b3108/" rel="bookmark">
			Java返回数据结果统一封装体AjaxResult
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方法返回数据结果的封装体分析 code：状态码msg：返回消息（内容）data：数据对象 二、AjaxResult实体类 AjaxResult实体类继承HashMap&lt;String,Object&gt;，方便其构造方法调用父类put()方法，将需要的内容封装在集合内，即super.put()。
/** * 数据结果封装体 AjaxResult * * @author LBF */ public class AjaxResult extends HashMap&lt;String, Object&gt; { private static final long serialVersionUID = 1L; /** 状态码 */ public static final String CODE_TAG = "code"; /** 返回内容 */ public static final String MSG_TAG = "msg"; /** 数据对象 */ public static final String DATA_TAG = "data"; /** * 初始化一个AjaxResult 对象 */ public AjaxResult() { } /** * 初始化一个AjaxResult 对象 * * @param code 状态码 * @param msg 返回内容 */ public AjaxResult(int code, String msg) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11041b6ebf48a8c8d8b456efb74b3108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a88384d43fbb12badeb98eceab11dd6/" rel="bookmark">
			简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。
Input
测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。
Output
对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。
Sample Input
1 + 2 4 + 2 * 5 - 7 / 11 0 Sample Output
3.00 13.36 emmm题目就这样， 其实一开始我也不会写stack考虑怎么用递归去写的
思路就是先计算+和—， 因为他们的优先级比较低， 需要先进性加减乘除运算， 我们写递归是倒着进去的， 所以由优先级高的要放到后边处理
#include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string op; int getnum(int l, int r) { double num = 0; if (l &gt;= r) return 0; else { for (int i = r - 1; i &gt;= l; i--) { if (op[i] == '+') { return getnum(l, i) + getnum(i + 1, r); } else if (op[i] == '-') { return getnum(l, i) - getnum(i + 1, r); } } for (int i = r - 1; i &gt;= l; i--) { if (op[i] == '*') { return getnum(l, i) * getnum(i + 1, r); } else if (op[i] == '/') { return getnum(l, i) / getnum(i + 1, r); } } for (int i = l; i &lt;= r - 1; i++) { if (op[i] &gt;= '0' &amp;&amp; op[i] &lt;= '9') { num = num * 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a88384d43fbb12badeb98eceab11dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bcbc0cef7197a4aadc5032e3520c80/" rel="bookmark">
			HCIA~实现VLAN间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、技术背景 VLAN间通信 实际网络部署中一般会将不同IP地址段划分到不同的VLAN。
同VLAN且同网段的PC之间可直接进行通信，无需借助三层转发设备，该通信方式被称为二层通信。
VLAN之间需要通过三层通信实现互访，三层通信需借助三层设备。
常见的三层设备：路由器、三层交换机、防火墙等。
将二层交换机与路由器的三层接口互联，由三层设备进行路由转发来实现通信。 2、使用路由器（物理接口、子接口）实现VLAN间通信 使用路由器物理接口 路由器三层接口作为网关，转发本网段前往其它网段的流量。
路由器三层接口无法处理携带VLAN Tag的数据帧，因此交换机上联路由器的接口需配置为Access。
路由器的一个物理接口作为一个VLAN的网关，因此存在一个VLAN就需要占用一个路由器物理接口。
路由器作为三层转发设备其接口数量较少，方案的可扩展性太差。
使用路由器子接口 子接口（Sub-Interface）是基于路由器以太网接口所创建的逻辑接口，以物理接口ID+子接口ID进行标识，子接口同物理接口一样可进行三层转发。
子接口不同于物理接口，可以终结携带VLAN Tag的数据帧。
基于一个物理接口创建多个子接口，将该物理接口对接到交换机的Trunk接口，即可实现使用一个物理接口为多个VLAN提供三层转发服务。
子接口和母接口是同一个IP地址，所以需要vlan进行区分
看下面示例：
单臂路由
interface GigabitEthernet0/0/0.1 进入子接口G0/0/0.1
dot1q termination vid 10 允许子接口识别、封装VLAN10
ip address 1.1.1.254 255.255.255.0 配置IP地址
arp broadcast enable 开启ARP广播功能
子接口处理流程 交换机连接路由器的接口类型配置为Trunk，根据报文的VLAN Tag不同，路由器将收到的报文交由对应的子接口处理。
子接口配置示例 3、使用VLANIF技术实现VLAN间通信 三层交换机和VLANIF接口 只要是三层设备就能查路由。
傻瓜式交换机（无法管理）
可管理：
纯二层交换机（仅支持数据链路层功能，比如VLAN,access等接口配置）；
三层交换机（带有部分网络层功能的设备，比如配置IP地址，路由协议等）。
三层交换机又分为：
弱三层交换机（支持相对较少的网络层功能）；
强三层交换机（支持相对较多的网络层功能）。
交换机如何判断二层转发还是三层转发：
由于同网段之间互访，终端设备会自动将MAC地址封装进二层头部中，交换机收到该数据帧时，发现目标MAC地址不是自己，则记源转发（二层转发，不会剥离二层头部）；
当跨网段访问时，终端设备会自动将网关MAC地址地址封装进二层头部中，交换机收到该数据帧时，发现目标MAC地址是自己，则认为该数据需要执行三层转发，剥离二层头部后，看三层IP信息，查询路由表，进行转发以及重新封装。
vlanif接口是三层虚拟接口，和vlan一一对应，必须先有vlan，才能有vlan三层，vlanif可以配置IP地址，也可以运行路由协议。
[SW1]interface Vlanif 10 进入vlan 10的三层接口
VLANIF配置示例 VLANIF转发流程 假设PC、三层交换机上都已存在相应的ARP或MAC表项。
PC1与PC2之间通信过程如下：
PC1通过本地IP地址、本地掩码、对端IP地址进行计算，发现目的设备PC2与自身不在同一个网段，判断该通信为三层通信，将去往PC2的流量发给网关。
PC1发送的数据帧：源MAC = MAC1，目的MAC = MAC2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05bcbc0cef7197a4aadc5032e3520c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97f230a5ec06642c4c00c7163ed46d4/" rel="bookmark">
			正则表达式的元字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概念一、元字符内容二、如何使用 概念 元字符：所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。
一、元字符内容 \s匹配任何空白字符，包括空格、制表符、换页符等等。\S匹配任何非空白字符。\t匹配一个制表符。\d匹配一个数字字符。\D匹配一个非数字字符。\w匹配字母、数字、下划线。\W匹配非字母、数字、下划线。点（.）表示非换行的任意字符斜线(\)表示转义字符，把没有意义的内容转成有意义的内容，把有意义的内容转成没有意义的内容 二、如何使用 1.\s表示一个空格 只要有空格就是true不管空格在什么位置
const reg1 = /\s/; console.log(reg1.test('abcd')); //false console.log(reg1.test('abcd ')); //true console.log(reg1.test('ab cd')); //true console.log(reg1.test(' ab cd')); //true 2. \S匹配任何非空白字符。 如果内部只有空格或者tab键或者没有任何内容都是false以外，其他都为true。
const reg2 = /\S/; console.log(reg2.test(' ')); //''内是一个空格 false console.log(reg2.test('1234 ')); //true console.log(reg2.test('	')); //''内是两个tab键 false console.log(reg2.test(' a a b c ')); //true console.log(reg2.test('')); //false 3.\t表示一个制表符,一个制表符就是制表符，不是多个空格;只要有tab键和'\t'都为true const reg3 = /\t/; console.log(reg3.test('\t')); //true console.log(reg3.test('a	')); //tab键 true console.log(reg3.test(' ')); //空格键 false console.log(reg3.test('	123@_')); //true 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d97f230a5ec06642c4c00c7163ed46d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95bdcb00956f7a4dee2a48f593e71c8/" rel="bookmark">
			神器 SpringDoc 横空出世，最适合 SpringBoot 的API文档工具来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在SpringBoot项目中一直使用的是SpringFox提供的Swagger库，上了下官网发现已经有接近两年没出新版本了！前几天升级了SpringBoot 2.6.x 版本，发现这个库的兼容性也越来越不好了，有的常用注解属性被废弃了居然都没提供替代！无意中发现了另一款Swagger库SpringDoc，试用了一下非常不错，推荐给大家！
SpringDoc简介 SpringDoc是一款可以结合SpringBoot使用的API文档生成工具，基于OpenAPI 3，目前在Github上已有1.7K+Star，更新发版还是挺勤快的，是一款更好用的Swagger库！值得一提的是SpringDoc不仅支持Spring WebMvc项目，还可以支持Spring WebFlux项目，甚至Spring Rest和Spring Native项目，总之非常强大，下面是一张SpringDoc的架构图。
使用 接下来我们介绍下SpringDoc的使用，使用的是之前集成SpringFox的mall-tiny-swagger项目，我将把它改造成使用SpringDoc。
集成 首先我们得集成SpringDoc，在pom.xml中添加它的依赖即可，开箱即用，无需任何配置。
&lt;!--springdoc 官方Starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; 从SpringFox迁移 我们先来看下经常使用的Swagger注解，看看SpringFox的和SpringDoc的有啥区别，毕竟对比已学过的技术能该快掌握新技术； 接下来我们对之前Controller中使用的注解进行改造，对照上表即可，之前在@Api注解中被废弃了好久又没有替代的description属性终于被支持了！ /** * 品牌管理Controller * Created by macro on 2019/4/19. */ @Tag(name = "PmsBrandController", description = "商品品牌管理") @Controller @RequestMapping("/brand") public class PmsBrandController { @Autowired private PmsBrandService brandService; private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class); @Operation(summary = "获取所有品牌列表",description = "需要登录后访问") @RequestMapping(value = "listAll", method = RequestMethod.GET) @ResponseBody public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList() { return CommonResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95bdcb00956f7a4dee2a48f593e71c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effb8453993dae415fe984d70b1be35e/" rel="bookmark">
			SpringBoot启动流程详解（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行run(args)方法 源码
public ConfigurableApplicationContext run(String... args) { //创建任务计时器，并开始计时 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); //设置Headless为true,该模式是在缺少显示屏、键盘或者鼠标是的系统配置 configureHeadlessProperty(); //获取运行监听器集合，并启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { //创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）, //并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); //Banner打印 Banner printedBanner = printBanner(environment); //根据WebApplicationType的值来决定创建何种类型的ApplicationContext对象 context = createApplicationContext(); //根据SpringBootExceptionReporter类名，去找到所有META-INF/spring.factories的jar包，获取该类(根据当前类名，去找到所有META-INF/spring.factories的jar包， // 获取该类名为key值的value值，然后返回根据@order注解排序后的实例化集合。 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); //准备上下文，并刷新上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); //关闭任务执行时间监听器 stopWatch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effb8453993dae415fe984d70b1be35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864c36defb1c5d4b08360f76da219a52/" rel="bookmark">
			GIT 撤销与回滚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 相信大家都会用，但是大家有没有遇到过，不小心把不该提交的文件 commit 了
小编整理了一些我在开发中常见的使用场景，供大家参考
场景一 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作
这种场景称为撤销
1 文件被修改了，但是还没有 git add git checkout fileName # 或者直接撤销当前目录下的全部文件 git checkout . 2 对文件执行了 git add 操作，想撤销一部分文件 # 取消暂存 git reset HEAD fileName # 撤销修改 git checkout fileName 3 修改的文件已经被 commit，但是不想产生新的 commit # 修改最后一次提交 git add a.txt git commit --amend -m "说明" 4 已经本地进行了多次 git commit 操作，现在想撤销其中某次 commit git reset commit_id|HEAD 场景二 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码
这种场景称为回滚
注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！
1 如果更新线上会打 tag，那么可以很快处理上述情况 git checkout &lt;tag&gt; 2 撤销指定文件到指定版本 # 查看指定文件的历史版本 git log &lt;filename&gt; # 回滚到指定commitID git checkout &lt;commitID&gt; &lt;filename&gt; 3 删除最后一次远程提交 # 使用 revert git revert HEAD git push origin master 场景三 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864c36defb1c5d4b08360f76da219a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf50330655efc6948057978fbfb6ecf/" rel="bookmark">
			函数式编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 函数式编程合成（compose）柯里化（Currying） 函数式编程 函数式编程倡导利用若干简单的执行单元计算结果不断渐进，逐层推导复杂的运算。
函数式编程有两个最基本的运算：合成和柯里化。
合成（compose） 如果一个值要经过多个函数，才能变成另一个值，就可以把所有中间步骤合并成一个函数，这叫做“函数的合成” （compose）
合成的好处显而易见，它让代码变得简单富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力。
function f1(args){ console.log("f1",args); return args } function f2(args){ console.log("f2",args); return args } function f3(args){ console.log("f3",args); return args } // f1("omg") // f2("omg") // f3("omg") //这里可以导入redux 的compose 方法，这里是自己实现的compose let res = compose(f1,f2,f3)("omg") //reduce ,reduceRight 反转 function compose(...funcs){ //不传参数时compose()("omg") if(funcs.length === 0){ return (arg)=&gt;arg } //传参为一个时compose(f1)("omg") if(funcs.length ===1 ){ return funcs[0] } return funcs.reduceRight((a,b) =&gt; (...args) =&gt; a(b(...args))) } 柯里化（Currying） 柯里化，又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数而且返回结果的新函数的技术。
所谓柯里化，就是把一个多参数的函数，转化为单参数函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf50330655efc6948057978fbfb6ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104dfdf5d419a2ec0f5386755e07ac74/" rel="bookmark">
			OSS云存储的权限控制、开放接口规范和错误响应以及SpringBoot整合OSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、OSS云存储的权限控制 1、权限控制方式 针对存放在 Bucket 的 Object 的访问，OSS 提供了多种权限控制方式，包括 ACL、RAM Policy 和Bucket Policy。
ACL：OSS 为权限控制提供访问控制列表（ACL）。ACL是基于资源的授权策略，可授予 Bucket和 Object 访问权限。 可以在创建 Bucket 或上传 Object 时设置 ACL，也可以在创建 Bucket或上传Object 后的任意时间内修改 ACL。RAM Policy：RAM （Resource Access Management）是阿里云提供的资源访问控制服务。RAMPolicy 是基于用户的授权策略。Bucket Policy：Bucket Policy 是基于资源的授权策略。相比于 RAM Policy，Bucket Policy 操作简单，支持在控制台直接进行图形化配置。 2、ACL Bucket ACL
Bucket ACL是 Bucket 级别的权限访问控制。目前有三种访问权限：public-read-write，publicread 和 private，含义如下：
操作方式
Object ACL
Object ACL是Object 级别的权限访问控制。目前有四种访问权限：private、public-read、publicread-write、default。PutObjectACL 操作通过 Put 请求中的 x-oss-object-acl 头来设置，这个操作只有 Bucket Owner 有权限执行。
Object ACL 的四种访问权限含义如下：
操作方式和上面类似 参考官方文档即可
https://help.aliyun.com/document_detail/100676.html?spm=a2c4g.11186623.2.9.695b5a5bnz0mcm#concept-blw-yqm-2gb
3、RAM Policy RAM（Resource Access Management）是阿里云提供的资源访问控制服务，RAM Policy是基于用户的授权策略。使用RAM，您可以创建、管理RAM用户，并可以控制这些RAM用户对资源的操作权限。当您的企业存在多用户协同操作资源时，使用RAM可以让您避免与其他用户共享云账号密钥，按需为用户分配最小权限，管理更加方便，权限更加明确，信息更加安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/104dfdf5d419a2ec0f5386755e07ac74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56e55687a112015fb2e660cb32351fc/" rel="bookmark">
			Go语言基础教程：遵从传统，从简单的Go示例开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专题目标：打造 Go 语言新手入门零基础免费教程 文章核心：一次只解决一个问题，用尽可能短的时间
你好，我是洋一，一个持续向上生长的互联网人。今天是 Go 语言基础教程系列的第 6 篇原创技术文章，主题是：遵从传统，从简单的Go示例开始
在 Go 语言基础教程前几讲的学习，我们已经成功安装一个 Go 开发环境，是时候开始写 Go 代码了，感受下 Go 的魅力。
在开始之前，我们先特别强调一下，因为还没有开始正式学习 Go 的基础语法，所以对零基础没有任何编程经历的同学，在理解上可能会存在难度，后面教程都会安排上，这个请你放心，别着急，有不懂的地方找洋一，我帮你解答。
跟对人，做正确的事！
身处程序员行业，都有一些比较不错的传统。如，在开始学习每种编程语言的时候，作为第一个学习例子都会从 Hello Wold 开始，希望通过这个例子能让大家更直观清晰的认识 Go，从而产生更大的兴趣，毕竟兴趣是最好的老师。
工欲善其事，必先利其器，要做好一件事，准备工具非常重要。这里我说明一下，在编写 Hello World 示例开始之前，我们对 IDE 工具不做要求。什么？你不知道 IDE 是什么玩意？ 这里给大家科普一下，IDE 全称：Integrated Development Environment（集成开发环境）,一般包括代码编辑器、编译器、调试器和图形用户界面等工具。它的出现是为了提高生产效率，让我们的工作变得更便利、更简单些。对于 Go , 我推荐使用 JetBrains公司 针对 Go 语言推出的 IDE 产品 Goland 或者 VS Code，个人觉得目前是市面上最好用的工具。这里要特别提醒一下，Goland 是收费软件，常规操作是非法武装一下，经济条件允许的情况下可以支持下。
我使用的是 Goland，后面计划出一期 Goland 工具的使用教程，大家拭目以待吧！
好了，叨叨这么多，让我们正式开始吧。
Hello World 示例程序 不使用 IDE 工具，执行程序，控制台打印 Hello Wold。
具体三步走：一是 创建项目文件夹，二是 开始编写 Hello World，三是 执行程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56e55687a112015fb2e660cb32351fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acccfa9274314d984fba6c1fcd0b3aa3/" rel="bookmark">
			Go语言基础教程：环境搭建之Linux系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专题目标：打造 Go 语言新手入门零基础免费教程
文章核心：一次只解决一个问题，用尽可能短的时间
你好，我是洋一，一个持续向上生长的互联网人。今天是 Go 语言基础教程系列的第 5 篇原创技术文章，主题是：如何在 Linux 上搭建 Go语言开发环境？
对于 Linux 系统，Go 几乎支持 Linux 所有主流的发行版操作系统，比如常见 CentOS、Ubuntu等等，常见的安装方式 从发行版仓库安装（利用其软件安装管理器提供安装方法）和官网手动下载安装，一般发行版仓库中的包比较老，推荐使用官网手动下载的安装方式。
下载并安装 首先，打开 Go 官网 https://go.dev/
选择当前最新版本：1.17.7，复制下载地址：https://go.dev/dl/go1.17.7.linux-amd64.tar.gz
进入 Linux，我们需要下载并解压 Go 安装包：
wget -C https://go.dev/dl/go1.17.7.linux-amd64.tar.gz 解压至安装目录中，比如安装目录 : /usr/local
tar -C /usr/local -zxf go1.17.7.linux-amd64.tar.gz 执行完上面的命令后，/usr/local 目录下就会新增 go/ 目录，这个目录就是 Go 的安装目录，也是官方推荐的安装目录。我们执行下面命令可以查看该安装目录下的组成：
ls -F /usr/local/go AUTHORS CONTRIBUTORS PATENTS SECURITY.md api/ doc/ lib/ pkg/ src/ CONTRIBUTING.md LICENSE README.md VERSION bin/ favicon.ico misc/ robots.txt test/ 配置环境变量 到这里，还没完呢，为了能够在任意路径下使用 Go 命令，需要将 Go 二进制可执行命令文件所在路径（也就是bin目录）加入到用户环境变量 PATH 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acccfa9274314d984fba6c1fcd0b3aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c21822f2088caacda34a92f8c961d65/" rel="bookmark">
			3.【问题】main redeclared in this block (see details)compiler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 如图所示，运行时，报异常 main redeclared in this block (see details)compiler
2. 原因分析 因为，我们在初期学习的时候，会创建许多.go的文件，然后在同一个目录下，每个.go的文件里面都有package main,也就是main函数。这就是问题所在
3. 解决办法 同一个目录下面不能有多个package main，调整或者创建多个文件夹分别放入对应的文件下执行即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d357fd627a2d6ab82d25074a3a2abe62/" rel="bookmark">
			GIS应用技巧之ArcGIS中的ColorMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
BOSS甩给你几幅土地利用分类图，"小xxx，怎么这几幅图颜色不一致，给我统一颜色，不然就别下班了。"此时的你肯定要骂他十八辈祖宗，心里默念到："全给你换成绿色，xxx"。打工人，打工魂，还是老老实实回到卡位做事吧。
一般来说ArcGIS中默认的配色工具都是一键配色，一键配色也难保证统一下和一致性，这时BOSS和GU客不happy了。为了保住饭碗，该怎么实现？我们这时候就可以采用大名鼎鼎的"colormap"来完成这种无聊的要求。
二、具体操作步骤
（1）加载数据
（2）配置颜色
在内容列表中，右键单击文件，选择图层图层属性，进入如下窗口，即可配置图像的颜色系统。这里我们改变一下分类图像的配色。
更改配色后的图像
（3）保存颜色表
之后便可把颜色表导出到文件，这个文件是一个以.clr为后缀的文本文件。
可以看到，这个这是一个简单的文本文件，第一列分类图像的类别代号值，后三列是每一类对应的颜色的RGB值，我们也可以通过自己构建一个这样的文本文件来给分类图像配色。（这里可以不看，这是瞎聊）
（4）重新加载颜色表
重新加载刚才的栅格文件
加载之前保存好的颜色表，应用。
结果如下
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a4bfb06064137b2ae721f080fb6f93/" rel="bookmark">
			GIS应用技巧之DEM分析集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DEM介绍
数字高程模型（Digital Elevation Model)，简称DEM，是通过有限的地形高程数据实现对地面地形的数字化模拟（即地形表面形态的数字化表达），它是用一组有序数值阵列形式表示地面高程的一种实体地面模型，是数字地形模型(Digital Terrain Model，简称DTM)的一个分支，其它各种地形特征值均可由此派生。
DEM可以进行很多分析，例如等高线生成、山体阴影、剖面图、坡度、坡向等，给大家一一介绍。
（1）如何下载免费的DEM，目前提供免费下载的DEM分辨率不高，一般90m，地理空间数据云直接下载。
（2）山体阴影
GIS搜索"山体阴影"工具即可，打开工具。
设置好如下参数，方位角、高度角可选。
点击确定之后，可以得到山体阴影栅格。
（3）剖面图
首先在菜单栏处点击右键，打开3D Analyst。
3D Analyst工具条上点击插入线按钮，在DEM上绘制需要生成剖面图的路径。
（4）坡度图
GIS中搜索"坡度"，调用坡度工具。
（5）坡向图
GIS中搜索"坡向"工具，如下设置。
（6）等高线
GIS中搜索"等值线"工具，设置等值线间距为10m。
​
（7）坡面曲率图
GIS中搜索"破向"工具，输入栅格为坡度栅格，设置输出测量单位和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4576e92486bb5a8f93818938425dcfe0/" rel="bookmark">
			问题小结（3.22）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.通过搜索展示的内容其中的关键词显示高亮
我们通过后端给与的接口，调用接口展示数据内容时，有时候是带条件参数的，也就是说通过特定的参数来查询相对应的数据。搜索按钮功能就是如此，那么当我们需要把展示的数据其中的关键词搜索展示的是高亮应该如何做到呢？
方法：1.通过正则表达式把对应的内容筛选出来，然后设置其的高亮样式再通过拼接拼接回去，将拼接后的数据展示到页面当中
2.遍历数据利用indexOf判断是否有对应的关键词，关键词内容设置为高亮后返回数据，再展示
我利用的是第二种方法：
&lt;span v-html="item.title"&gt; // 绑定内容 // 设置高亮的方法 brightKeywords (val) { var keyword = this.param.title if (val.indexOf(keyword) !== -1) { return val.replace(keyword, `&lt;font color='red'&gt;${keyword}&lt;/font&gt;`) } else { return val } }, this.resultList = [] this.listData.forEach((item) =&gt; { if (item.title.indexOf(this.param.title) &gt; -1 { this.resultList.push(item) } }) if (this.resultList.length == 0) { this.isShowTip = true } this.resultList.map((item) =&gt; { item.title = this.brightKeyword(item.title) }) 2.React利用脚手架后如何使用less
先**npm install --save-dev less-loader less**
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4576e92486bb5a8f93818938425dcfe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c543ff3fc6a65123fee6bb145402b0/" rel="bookmark">
			Presto日期函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当前时间
select current_date,current_time;
多种类型转时间戳
字符串转时间戳 string -&gt; timestamp select cast('2022-03-22' as timestamp);
select date_parse('2022-04-06 00:03:55','%Y-%m-%d %H:%i:%S') 时间戳格式化 format_datetime(timestamp,‘yyyy-MM-dd HH:mm:ss’)
Bigint转时间戳
Create_time是一个bigint类型的数值
Select from_unixtine(create_time) from db;
时间转bigint
Select to_unixtime(current_date) ;
转年月日/取年月日
select date_format(current_date,'%Y-%m-%d'); //字符串格式化成日期的样子 select date(current_date); select cast(current_date as date); //这是一个字符串可以转日期的函数 字符串转年月日
select date(cast('2022-02-22 10:28:00' as TIMESTAMP)); select date('2019-02-28'); select date_format(cast('2019-02-28 10:28:00' as TIMESTAMP),'%Y-%m-%d'); select to_date('2019-02-28','yyyy-mm-dd'); Bigint转年月日 date(from_unixtime(1556380800)) select date_format(from_unixtime(1556380800),'%Y-%m-%d'); 重点： 日期间隔 date_diff(unit, timestamp1, timestamp2) //bigint select date_diff('day',cast('2019-04-24' as TIMESTAMP),cast('2019-04-26' as TIMESTAMP)) ; 注意：presto的date_diff是后-前，hive和mysql的date_diff是前-后
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c543ff3fc6a65123fee6bb145402b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2977e31bbc9b19674cf31fb57fbb43d/" rel="bookmark">
			docker入门（启用容器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、运行第一个容器命令 sudo docker run -i -t ubuntu /bin/bash
运行这个命令后，会根据ubuntu的镜像，创建一个ubuntu的容器
-i 表示容器的STDIN是开启的，-t表示为容器提供一个交互式的shell
ubuntu 表示根据哪个镜像去创建容器
如果本地没有ubuntu镜像，那Docker会在DockerHub的公共镜像库为你找到你所需要的镜像
2、使用容器 我们可以把这个新创建的ubuntu容器当中一个新的操作系统使用，执行一下命令
还可以为这个容器安装软件，比如安装一个vim编辑器
可以提供exit命令退出这个容器
3、查看现有的容器 使用
docker ps -a
圈出来的就是刚刚我们运行的容器
docker ps -a代表查看所有容器
docker ps 查看正在运行的容器
docker ps -l 查看最后一次运行的容器
容器相当于是一个进程，可以在前台运行，也可以在后台运行，在前台运行的时候
我们看图片的第一列：
CONTAINER_ID 代表容器的唯一ID
IMAGE 代表这个容器是由哪个镜像构建的
COMMAND 代码运行容器的时候，为容器指定执行的命令，这个后面再讲，你可以先理解为这个根据容器所属的镜像不同，执行的命令也不同；
STATUS 代码容器的状态，比如运行，介绍状态
PORTS 表示容器开放的虚拟端口号
NAME 容器的名称，可以在启动的时候为容器命名，如果没有为容器命令，Docker会为容器自动生成名字
4、容器命名 刚刚说到了我们可以为容器命名，那怎么操作呢？
很简单，只需要
sudo docker run --name deng_container -i -t ubuntu /bin/bash
使用–name 参数，在后面加上你想为容器取的名字
取名注意事项：
1、名字的字符是有限制的，只能使用a-z,A-Z,0-9，下划线，圆点、横线
用正则表达式就是这样的[a-zA-Z0-9_.-]
2、在一些操作容器docker命令中，我们可以使用容器的名字代替容器的id,因为很明显容器的ID比容器的名字更好记，所以，容器的名字和容器的ID一样，不能重复；
5、重启已经停止的容器 使用
sudo docker start [容器的id或者名字]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2977e31bbc9b19674cf31fb57fbb43d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99bd735b4e083dd9ac1db6a4450259c7/" rel="bookmark">
			使用Docker-compose安装NextCloud，并部署Collabora作为office服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Docker-compose安装NextCloud，并部署Collabora作为office服务
安装Docker和docker-compose 使用docker-compose可以更快速的构建nextcloud需要的各个服务
准备域名，启用SSL 2个子域名，分别用于Collabora Office和Nextcloud，且两个域名均拥有合法SSL证书，通过备案后在云服务商申请免费证书即可，证书授权一年。
例如：
nextcloud.eeeeeee.com用于访问Nextcloud，collabora.eeeeeeee.com用于部署Collabora Office
nginx的 SSL 证书可用腾讯云或阿里云每年授权一次的免费证书，就不用那个什么letsencrypt搞什么自动续签了，
docker-compose文件 docker-compose.yml version: '3' services: db: image: mariadb:10.5 container_name: nextcloud-db restart: always command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW volumes: - ./mariadb/db:/var/lib/mysql environment: - MYSQL_DATABASE=nextcloud - MYSQL_ROOT_PASSWORD=sd21111111111111111w - MYSQL_USER=nextcloud - MYSQL_PASSWORD=GXDw1111111111111111112 ports: - 3306:3306 redis: image: redis:alpine container_name: nextcloud_redis restart: always expose: - 6379 cron: image: nextcloud:apache restart: always volumes: - ./nextcloud_cron:/var/www/html entrypoint: /cron.sh depends_on: - db - redis nextcloud: image: nextcloud:apache container_name: nextcloud_web restart: always volumes: - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99bd735b4e083dd9ac1db6a4450259c7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/255/">«</a>
	<span class="pagination__item pagination__item--current">256/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/257/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>