<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914f7cd8aee604b91a86043fa2b22869/" rel="bookmark">
			【C&#43;&#43;中传递数组到函数时求数组长度问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习记录： 最近学习c++时遇到传递数组到函数的问题，将数组作为实参传递给函数时，传递的是数组首地址，对形参使用sizeof()函数会返回数组地址的长度（此处地址长度为8）。
问题描述 学习场景：
学习左神刷题挑战时，练习选择排序时遇到：
#include&lt;iostream&gt; using namespace std; class Mysort { public: void Dosort(int a[],int len); }; void Mysort::Dosort(int a[],int len) { cout&lt;&lt;"对形参数a求sizeof:"&lt;&lt;sizeof(a)&lt;&lt;endl; for(int i=0;i&lt;len-1;i++) { int maxindex=i; for(int j=i+1;j&lt;len;j++) { maxindex = a[j]&gt;a[maxindex] ? j :maxindex; } if(maxindex!=i) { int temp =a[maxindex]; a[maxindex]=a[i]; a[i]=temp; } } cout&lt;&lt;"排序结果:"&lt;&lt;endl; for(int i =0;i&lt;len;i++) { cout&lt;&lt;a[i]&lt;&lt;" "; } } int main() { int a[]={1,5,8,4,6,9,3}; int len=sizeof(a)/sizeof(a[0]); Mysort sor; sor.Dosort(a,len); return 0; } //结果： xuanze.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914f7cd8aee604b91a86043fa2b22869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd37d2fe4e734426f991235abb1bdda7/" rel="bookmark">
			Nginx部署多server遇到的问题以及相关经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux上如何关闭、开启、查看nginx进程 三个命令：
查看nginx进程状态：
停止nginx进程：
开启nginx进程：
nginx无法访问其他server的端口 一般情况下，下图中的方法可以解决大部分问题了：
但是如果上面的都不行，那么就应该是你买的服务器中的安全组中对于你所设置的端口号并未开放，所以只要去设置一下就行啦。
nginx如何部署多个前端项目 这个很简单，学过nginx的人都明白，不过还是贴个示例叭：
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; #第一个项目 server { listen 80; #端口号 server_name localhost; #本地地址 #charset koi8-r; #access_log logs/host.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd37d2fe4e734426f991235abb1bdda7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b9e7f8e30909825a09fb61a0f20a25/" rel="bookmark">
			数据库事务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库事务详解 数据库事务事务的四大特性如何保证事务的原子性如何保证事务的持久性如何保证事务的隔离性隔离性的四个等级未提交读（read uncommitted）提交读（read committed）可重复读（repeatable read）序列化读（serializable） 通过锁的方式来实现隔离性两端式提交锁（Two-phase locking）使用多版本并发控制（MVCC）什么是MVCCmysql Innodb对于MVCC的实现 数据库事务 最近为了面试整理了一下数据库事务的相关面试知识点，希望能够帮到大家
事务的四大特性 数据库事务四大特性ACID，分别是原子性（Atomicity），一致性（Consistency）, 隔离性（Isolation），持久性（Durability）。
原子性 ：事务是不可分隔的最小操作单元，要么全部成功，要么全部失败（例如转账的时候就要保证事务的原子性，不能转账方账户扣了钱，但是因为异常，接受方没收到钱，这时候就要回滚，把钱退给转账方）；一致性 ：事务完成时，必须使用所有的数据都保持一致状态；（例如转账的时候不能转了1000元但是收到了10000元，一定要保证数据是一致的）隔离性 ：数据库系统提供的隔离机制，保证事务不受外部并发操作影响的独立环境下运行；持久性 ：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的； 如何保证事务的原子性 Innodb储存引擎的undo log。
undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
eg：
当一个事务中执行的是一系列delete操作的时候，就需要记录已经执行delete操作后删除的数据的信息，如果在执行这些delete操作过程中出现异常，就需要回滚，在回滚的时候，就会撤销原先已经执行的删除操作，从而保证事务的原子性，即要么事务执行成功，要么执行失败，回复到执行前的状态。同理update和insert是一样的道理。
undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
如何保证事务的持久性 Innodb的redo log。
正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？
只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。
于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据。
采用redo log的好处？ 其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下
redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。
如何保证事务的隔离性 隔离性的四个等级 未提交读（read uncommitted） 这个等级是最低等级，也可以认为，事务之间完全不隔离，事务A开始一个事务，接着事务B开始，事务B对数据C继续update，这时候，A读取了B未提交（commit）的数据，这种情况叫做脏读（dirty read）。这个时候要是事务B遇到错误必须回滚rollback，那么A读取的数据就完全是错的。可以想象这样完全不隔离的状态下，我们相对于数据库的业务方程序员写的一个sql，提交个db的执行引擎，返回的结果是多么不可确定啊。
提交读（read committed） 提交读就是在未提交读的基础上，保证事务读取的数据，都是别的事务已经提交了的。但是只要在还没达到串行执行的情况下，总会有问题的，事务A select了一条数据，接着事务B update 这条数据，然后commit，这时候A还未提交，A再回来读这条数据，发现数据居然变了，按照我们之前所说，我们的目标是：对于一个事务本身来说，它所感知的数据库，应该只有它自己在操作，那么A会觉得自己并没有更新数据啊，怎么数据突然变了，这种情况叫做 不可重复读（Non-repeatable reads）
可重复读（repeatable read） 可重复读，即是在上一个级别的基础上，保证不会在一个事务内两次select同一条数据会出现变化，即是别的事务对你select的对象进行update操作不会影响，换句话说，只要此时事务没有结束，在该事务中被select出来的结果永远是一样的，不会发生改变。但是，如果是insert操作，在这个隔离级别还是会受到影响。事务A开启事务，并select一段有范围的数据，然后事务B开启事务，在先前A事务select的那段有范围的数据中insert一条数据，然后提交事务，接着事务A再insert一条相同的数据，就会发现报错，提示说表中已经有这条数据（假设数据库表中数据不可重复），但是事务A select出来的结果并没有要插入的这条数据，就像是产生了幻影，这种情况叫幻读（Phantom Read）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b9e7f8e30909825a09fb61a0f20a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ef79016b81c32a7c733d3c5803f5c1/" rel="bookmark">
			C. Tyler and Strings（组合数学,树状数组维护前缀和）(Codeforces Round #775 (Div. 1, based on Moscow Open Olympiad i)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对我来说比较困难的一题了,尝试着自己写了一下,调不出来遂放弃.
Codeforces Round #775 (Div. 1, based on Moscow Open Olympiad in Informatics)
https://codeforces.com/contest/1648/problem/C
C.Tyler and Strings
题意:给你字符串 s , t s,t s,t,你可以对 s s s任意排序,问你有多少种方案使得 s s s重排后字典序会比 t t t小.
思路:枚举每次在哪里断掉.比如说在 i i i的位置,令 s j &lt; t j s_j&lt;t_j sj​&lt;tj​,那么合法的方案就是任意排序了.
比如说 s = 1 , 2 , 3 , 4 , t = 4 , 3 , 2 , 1 s=1,2,3,4,t=4,3,2,1 s=1,2,3,4,t=4,3,2,1,第一个位置选择1,剩下的 2 , 3 , 4 2,3,4 2,3,4任意排列都是合法方案.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ef79016b81c32a7c733d3c5803f5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e6580700e13654a25c107af305f809/" rel="bookmark">
			游戏服务器被攻击了怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，网民数量激增，电子游戏的普及，庞大的玩家数量必然推动游戏市场发展。游戏受到攻击是游戏开发者的痛点，DDOS攻击是流量攻击的一个总称，还包括SYN Flood、ACK Flood、UDP Flood、TCP Flood、ICMP Flood以及CC攻击。受到攻击会使服务器奔溃玩家掉线，轻则引起玩家不满，重则玩家跑光，游戏倒闭。游戏受到攻击的问题不容忽视！
为什么游戏会被攻击？
1.同行竞争：大部分攻击原因来自于行业恶性竞争，同行攻击使游戏短期内无法登陆，玩家跑去玩其他游戏，从中坐收渔翁之利。
2.高盈利：攻击者受利益驱使，主动或被雇佣去攻击一些高盈利的游戏。特别是游戏行业对服务器的稳定性要求极高，受到攻击容易被勒索。
3.玩家不满：游戏玩家与其他玩家发生冲突，或者对管理员不满，可能会攻击游戏宣泄不满。
如何解决？
（1）升级防御
原来的服务器相应防御不是很高的，有可能受到一点攻击就进入黑洞。可以升到更高防御。
（2）接入防护产品
针对比较大的攻击，市场上推出了一款专门的防护产品-游戏盾。游戏盾是通过封装登录器的方式隐藏真实IP，将对外IP修改成盾IP，在盾后台添加源IP和业务端口。利用高防节点池转发防护，接入游戏盾后攻击是到高防节点上，打死一个节点自动切换下个节点，将数据进行有效清洗过滤后转发回源机上。并且无视攻击，带有网络加速，防掉线功能。
使用游戏盾后源机的防御和线路（走盾节点）就不是那么重要了，也算是省了很多成本。而且也无视攻击，不再会因为受到攻击而烦恼。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcbef84b10ad9538d40d2cc9a3310e1/" rel="bookmark">
			【转载】Consul和Openfeign实现客户端负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明： 转载文章署名及贴出原文链接
—————————————————————————————————————————————
知乎-zachary1979 原文链接:
通过consul和openfeign实现客户端负载均衡 - 知乎一、构建消费端 1.1 定义消费接口（feign客户端） @Component //Feign客户端 @FeignClient("spring-cloud-consul-producer") public interface ConsumerFeignClient { @GetMapping("/helloConsul…https://zhuanlan.zhihu.com/p/150022428
———————————————————————————————————————————
——
一、构建消费端 1.1 定义消费接口（feign客户端）
@Component //Feign客户端 @FeignClient("spring-cloud-consul-producer") public interface ConsumerFeignClient { @GetMapping("/helloConsul") public String getConsulHello(); } 1.2 在控制器中使用
@RestController public class ConsumerHelloController { @Autowired private ConsumerFeignClient consumerFeignClient; @GetMapping("/consumer/hello") public String consumerHello() { return consumerFeignClient.getConsulHello(); } } 1.3 消费端也注册到consul
cloud: consul: host: localhost port: 8500 discovery: tags: dev serviceName: spring-cloud-consul-producer healthCheckPath: /actuator/health healthCheckInterval: 15s healthCheckUrl: http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcbef84b10ad9538d40d2cc9a3310e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3154bf8d350de23e52c2604be98d51/" rel="bookmark">
			使用 JavaScript 的 Date.toLocaleString() 方法格式化日期和时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date.toLocaleString() 方法 Date.toLocaleString() 方法可用于从 Date 对象创建格式化的日期和时间字符串。
它接受两个参数：格式化字符串的 locale 和格式化 options 对象。
locale 通常是一种语言代码。例如，对于中文，使用的是 zh-cn。options 对象包括 dateStyle 和 timeStyle 等设置(两者都接受 full、long、middle 和 short 的值)。
let now = new Date() // 获取格式化字符串 let formatDate = now.toLocaleString('en-US', { dateStyle: 'long', timeStyle: 'short', hour12: true }) // '2022年3月29日 下午4:36' 格式因位置而异 locale 参数控制格式约定。
例如，使用英式英语(en-UK)或美式英语(en-US)，我们的日期和时间返回格式略有不同。
new Date().toLocaleString('en-UK', { dateStyle: 'long', timeStyle: 'short', hour12: true }) // '29 March 2022, 04:40 pm' new Date().toLocaleString('en-US', { dateStyle: 'long', timeStyle: 'short', hour12: true }) // 'March 29, 2022 at 4:40 PM' 我们可以使用 navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e3154bf8d350de23e52c2604be98d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe2dfbcecd01fca485afd3d3efa3365/" rel="bookmark">
			使用 JavaScript 的 Intl.DateTimeFormat() 构造函数转换和格式化日期和时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intl.DateTimeFormat() 方法是如何工作的 Intl 对象的设计目的是使特定位置的数据更容易国际化。DateTimeFormat() 是一种用于格式化日期和时间的方法。
首先，创建一个新的 Intl.DateTimeFormat() 实例。
它接受一个 locale(例如，zh-CN 代表中文，en-US 代表美式英语，en-GB 代表英式英语)。此参数告诉方法将日期和时间格式化为哪种语言。
const formatter = new Intl.DateTimeFormat('zh-CN') const formatter = new Intl.DateTimeFormat('en-US') const formatter = new Intl.DateTimeFormat('en-GB') 使用一系列 options 作为第二个参数，可以对输出的格式进行更细粒度的控制。
例如：以下示例使用 dateStyle 属性，然后使用 format 格式化为字符串：
const now = new Date() new Intl.DateTimeFormat('zh-CN', { dateStyle: 'full' }).format(now) // '2022年3月30日星期三' new Intl.DateTimeFormat('zh-CN', { dateStyle: 'long' }).format(now) // '2022年3月30日' new Intl.DateTimeFormat('zh-CN', { dateStyle: 'medium' }).format(now) // '2022年3月30日' new Intl.DateTimeFormat('zh-CN', { dateStyle: 'short' }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe2dfbcecd01fca485afd3d3efa3365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94920fa44ff76d52af2b4a65e2b97bfd/" rel="bookmark">
			SpringBoot学习笔记(一)——SpringBoot项目文件全解析及配置文件的选择与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周Redis的学习终于告一段落，这周就要开始学习SpringBoot部分的内容了，这部分的内容我觉得很重要，毕竟SpringBoot是现在十分主流的开发框架，学就完事了。希望还有不懂的小伙伴也能够尽快掌握SpringBoot的使用。
SpringBoot介绍：SpringBoot是基于Spring进行开发，SpringBoot本身不提供Spring框架的核心特性与扩展功能，他只是用于快速，敏捷地开发一个Spring框架下的应用程序。是用来简化Spring框架中的配置的。
SpringBoot的核心思想是约定大于配置，意思是说我们可以不需要进行很复杂的配置，但前提是我们必须要按照SpringBoot官方约定的开发方式来开发，这会让我们减少很多以前需要自定义的配置。
简单了解一下SpringBoot之后我们来创建一个SpringBoot项目，来看看他到底如何在项目中来体现他的核心思想。
SpringBoot项目创建教程
我们先创建一个SpringBoot项目，由于我之前发布过文章，这里就不多赘述了，如果您用的是企业版IDEA则无需安装插件，但步骤都是一样的，实在搞不懂也可以在Spring官网进行项目创建。
SpringBoot框架浅析 对于初学者的小伙伴们来说，创建了一个SpringBoot项目后，最想知道的就是应该就是如何使用SpringBoot框架了。我先简单说一下SpringBoot项目框架都有哪些内容吧。
当我们打开项目后，发现项目结构是如下所示：
接下来我们一个一个的来解释一下各个文件的作用
文件夹/文件名作用.idea存放项目的配置信息，包括历史记录，版本控制信息等.mvn存放maven-wrapper的相关文件用于mvnwsrc我们工作中主要使用的文件夹，存放我们开发的代码.gitgnoregit的配置文件，可以配置提交git的时候哪些类型的文件不需要提交项目名.imlintellij idea的工程配置文件，里面是当前project的一些配置信息HELP.md项目的帮助文档，相当于记事本mvnw主要是用于当用户使用maven的命令时，发现本地的maven版本与.mvn文件夹下的maven-wrapper.properties文件中的maven版本不一致，就会下载maven-wrapper.properties文件中的maven版本，然后来执行maven命令，用于Linux环境mvnw.cmd同上，用于Windows环境pom.xmlmaven依赖的配置 没有学习过Maven的同学到这里可能就需要先去学习一下Maven的使用了。
Maven在工作中的使用
这篇文章是我比较早学习的Maven笔记，有需要的小伙伴可以学习一下。
介绍完项目结构之后我们再来介绍一下SpringBoot项目的pom.xml文件中必须要用到的依赖。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--	父项目，每一个未自定义父项目的SpringBoot项目都会默认将此项目设置为父项目--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--	自己项目的坐标，坐标是Maven项目里的概念，使用GAV三个标签来确定唯一的一个项目--&gt; &lt;groupId&gt;com.springBoot&lt;/groupId&gt; &lt;artifactId&gt;helloworld&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;helloworld&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!--	这个小伙伴们应该都能明白，表示我们使用的java的版本--&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--	SpringBootWeb开发的启动器(必须引入，否则项目都无法启动)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--	用于简易创建对象使用的依赖，不用太纠结，后续使用就明白了，比较简单--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94920fa44ff76d52af2b4a65e2b97bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94fcb5e02c6c33ea925dfaff2a40660/" rel="bookmark">
			论ESP32自动下载电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先来看看ESP32手册说明的启动运行方式
由上图可知，ESP32有SPI启动模式（正常启动）与下载启动模式两种，要实现程序自动下载肯定是需要上电时自动进入下载启动模式，方法就是将GPIO0与GPIO2同时拉低，因GPIO2上电默认下拉（IO2可能会被用作SD卡或其它的作用，这样如果在有设备接入时，并且引脚呈现高电平，就会出现不能下载的现象），所以可以只考虑GPIO0，同时控制复位引脚（EN)就可以实现自动程序下载，如下：
EN由低电平到高电平（上升沿）时CPU复位，复位后检测到GPIO0是低电平，CPU自动进入下载启动模式！ 2、电路实现分析 CHIP_PU就是控制CPU重启的EN信号，GPIO0决定启动时的模式选择，对图中电路分析如下：
DTR = 0; RTS = 0, 此时Q1截止，Q2截止，EN = 默认; IO0 = 默认 DTR = 0; RTS = 1，此时Q1截止，Q2导通, EN = 默认; IO0 = 0 DTR = 1; RTS = 0, 此时Q1导通，Q2截止, EN = 0; IO0 = 默认 DTR = 1; RTS = 1, 此时Q1截止，Q2截止, EN = 默认; IO0 = 默认 逻辑中一旦CPU启动后EN就被拉高了，IO0默认上拉，所以上边电路精简后
DTR RTS EN IO0 0 0 1 1 0 1 1 0 1 0 0 1 1 1 1 1 简单总结：当DTR和RTS同时为0或者同时为1时，三极管Q1和Q2均为截止状态，此时EN和IO0的状态由其他电路决定（内部/外部上拉电阻）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f94fcb5e02c6c33ea925dfaff2a40660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daedc2703b532b8c4788a3aeed189511/" rel="bookmark">
			mysql报错：error while loading shared libraries: libncurses.so.5: cannot open shared object file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用命令mysql -uroot -p连接mysql数据库报错： error while loading shared libraries: libncurses.so.5: cannot open shared object file 解决办法 1. 查找 没有libncurses.so.5，可能有libncurses.so不同版本的文件，使用命令
find / -name 'libncurses*' 查找，我找到的是
/usr/lib/x86_64-linux-gnu/libncurses.so.6.2 2. 建立软链接 ln -s libncurses.so.6.2 libncurses.so.5 如果没有找到的话，使用yum或apt安装即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2c2937da8ee6d88d16550798d0d413/" rel="bookmark">
			DHCP详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 DHCP（动态主机配置协议）：是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。
通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。
DHCP客户端 通常为网络中的PC、打印机等终端设备，使用从DHCP服务器分配下来的IP信息，包括IP地址、DNS、子网掩码、默认网关等。
DHCP服务器 所有的IP网络设定信息都由DHCP服务器集中管理，并处理客户端的DHCP请求。
DHCP服务器为客户端分配IP地址有三种形式：
自动分配方式（Automatic Allocation），DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器端租用到IP地址后，就可以永久性的使用该地址。动态分配方式（Dynamic Allocation），DHCP服务器给主机指定一个具有时间限制的IP地址，时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。手工分配方式（Manual Allocation），客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 1、管理员将一个IP地址固定分配给一个客户端。
2、随机地将地址永久性分配给客户端。
3、随机地将地址分配给客户端使用一段时间。
第三种是最常见的使用形式。地址的有效使用时间段称为租用期，租用期满之前，客户端必须向服务器请求继续租用。服务器接受请求后才能继续使用，否则无条件放弃。
端口 DHCP采用UDP作为传输协议，客户端发送消息到DHCP服务器的的 67号 端口，服务器返回消息给客户端的 68号 端口。
DHCP中继 默认情况下，路由器隔离广播包，不会将收到的广播包从一个子网发送到另一个子网。当DHCP服务器和客户端不在同一个子网时，充当客户端默认网关的路由器将广播包发送到DHCP服务器所在的子网，这一功能就称为DHCP中继。
DHCP中继代理，就是在DHCP服务器和客户端之间转发DHCP数据包。当DHCP客户端与服务器不在同一个子网上，就必须有DHCP中继代理来转发DHCP请求和应答消息。DHCP中继代理的数据转发，与通常路由转发是不同的，通常的路由转发相对来说是透明传输的，设备一般不会修改IP包内容。而DHCP中继代理接收到DHCP消息后，重新生成一个DHCP消息，然后转发出去
DHCP中继主机必须自己具有路由能力，且能将双方的数据报互传对方。如果不使用中继，也可以在每一个网络中安装DHCP服务器，但这样的话，一来设备成本会增加，而且管理上面也比较分散。当然，如果在大型的网络中，这样的均衡式架构还是可取的。
报文 1、DHCP DISCOVER：客户端开始DHCP过程的第一个报文，是请求IP地址和其它配置参数的广播报文。
2、DHCP OFFER：服务器对DHCP DISCOVER报文的响应，是包含有效IP地址及配置的单播（或广播）报文。
3、DHCP REQUEST：客户端对DHCP OFFER报文的响应，表示接受相关配置。客户端续延IP地址租期时也会发出该报文。
4、DHCP DECLINE：当客户端发现服务器分配的IP地址无法使用（如IP地址冲突时），将发出此报文，通知服务器禁止使用该IP地址。
5、DHCP ACK ：服务器对客户端的DHCP REQUEST报文的确认响应报文。客户端收到此报文后，才真正获得了IP地址和相关的配置信息。
6、DHCP NAK：服务器对客户端的DHCP REQUEST报文的拒绝响应报文。客户端收到此报文后，会重新开始新的DHCP过程。
7、DHCP RELEASE：客户端主动释放服务器分配的IP地址。当服务器收到此报文后，则回收该IP地址，并可以将其分配给其它的客户端。
8、DHCP INFORM：客户端获得IP地址后，发送此报文请求获取服务器的其它一些网络配置信息，如DNS等。
DHCP消息的格式是基于BOOTP（Bootstrap Protocol）消息格式的，这就要求设备具有BOOTP中继代理的功能，并能够与BOOTP客户端和DHCP服务器实现交互。BOOTP中继代理的功能，使得没有必要在每个物理网络都部署一个DHCP服务器。RFC 951和RFC 1542对BOOTP协议进行了详细描述。
DHCP交互过程 DHCP Client以广播的方式发出DHCP Discover报文。所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。 DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP
Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2c2937da8ee6d88d16550798d0d413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc342f1871274680314e5f6b5348abea/" rel="bookmark">
			Microsoft Network Monitor的select network栏空白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天搞了一下午的网络适配器，终于弄好了，我觉得大概是之前在用虚拟机的时候把虚拟机错误桥接的原因大有关系。到了晚上用monitor的时候发现select network栏无论如何都是空白的，本以为是外置网卡没有插上的缘故，插了也没用。
当时大概的情况就是这样（现在已经解决）
解决方法： 把软件Microsoft Network Monitor卸载了，重新安装一遍。
原因： monitor软件是昨天下载的，昨天情况还是正常的，但是今天早上我的网络适配器出现了问题（错误56），导致我的真实无线网卡和Realtek都没法上网了，下午折腾了好一会儿才找到解决方案（下一个ccclean把注册表清理干净），之前拿着错误的网卡配置下载的软件，跟着数据也就错了，所以select network也就没有了。
第一次写博客，好紧张，当做是记录平时的一些问题解决过程吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f15046f20fad187c9deae05d6759fee/" rel="bookmark">
			安卓系统启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓系统主要启动流程如下：
启动电源以及系统启动引导程序 BootLoaderLinux 内核启动init 进程启动Zygote 进程启动SystemServer 进程启动Launcher 启动 一、init 进程启动过程 init 过程启动过程中主要做了以下三件事：
创建和挂在启动所需的目录文件初始化和启动属性服务：属性服务采用键值对的形式记录用户、软件的一些使用信息，使得系统或者软件重启之后可以根据注册表中的记录进行相应的初始化工作。解析 init.rc 配置文件并启动 Zygote 进程（调用 Zygote 的 main 函数） 二、Zygote 进程启动过程 Zygote 进程被称为安卓系统的孵化器，Zygote 进程在启动时会创建 DVM（Dalvik虚拟机）和 ART（Android Runtime），后续其他的应用程序进程和 SystemService 进程都有 Zygote 进程通过 fork （复制进程）的方式创建。（因此应用程序进程和 SystemService 进程可以在内部获得一个 DVM 和 ART 副本）。
Zygote 进程的启动过程主要做了以下几件事：
创建 AppRuntime 并调用其 start 方法，启动 Zygote 进程：main 函数中通过 init 进程调用时携带的参数判断出此时是在启动 Zygote 进程，因此调用 start 方法创建 Java 虚拟机并为其注册 JNI 方法：在 AppRuntime 的 start 方法中调用通过 JNI 调用 ZygoteInit 的 main 函数进入 Zygote 的 Java 框架层：在 AppRuntime 的 start 方法中调用通过调用 ZygoteServer 的 registerServerSocket 方法创建服务端 Socket：在 ZygoteInit 的 main 方法中调用启动 SystemServer 进程：在 ZygoteInit 的 main 方法中调用 startSystemServer 方法完成创建和启动通过调用 ZygoteServer 的 runSelectLoop 方法等待 AMS 的请求来创建新的应用程序进程：在 ZygoteInit 的 main 方法中调用，runSelectLoop 方法是一个死循环 三、SystemServer 启动过程 由上文可知 ZygoteInit 的 main 方法调用 startSystemServer 方法，startSystemServer 方法首先复制 Zygote 进程创建 SystemServer 进程，接着关闭掉对 SystemServer 进程没有用处的 Socket 服务，最后调用 handleSystemServerProcess 方法启动 SystemServer 进程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f15046f20fad187c9deae05d6759fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791237790bb8ff95f50bce1534202fa1/" rel="bookmark">
			蓝桥杯—全球变暖 两种方法 深搜和广搜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述 你有一张某海域NxN像素的照片，"."表示海洋、"#"表示陆地，如下所示：
.......
.##....
.##....
....##.
..####.
...###.
.......
其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。
由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。
例如上图中的海域未来会变成如下样子：
.......
.......
.......
.......
....#..
.......
.......
请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。
输入格式
第一行包含一个整数N。 (1 &lt;= N &lt;= 1000)
以下N行N列代表一张海域照片。
照片保证第1行、第1列、第N行、第N列的像素都是海洋。
输出格式
一个整数表示答案。
样例输入
7
.......
.##....
.##....
....##.
..####.
...###.
.......
样例输出
1
2、深搜 只能过80% import java.util.ArrayDeque; import java.util.Queue; import java.util.Scanner; public class 全球变暖 { static int n; static char[][] map; static boolean[][] visit; static boolean flag = false; static int ans = 0; //上下左右的位置 static int[] xs = {1,0,-1,0}; static int[] ys = {0,1,0,-1}; public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791237790bb8ff95f50bce1534202fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b56114f91573513182e3f657c544c8/" rel="bookmark">
			【原创】序列化类添加UID,@java.io.Serial标红之解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@java.io.Serial标红怎么破？进来学姿势~ IDEA默认jkd16，而当前使用的并非jkd16不支持注解这个特性所以爆红！
两个选项调为一致即可
完美解决 RubyXun 推荐起始页
极域·起始页-https://rubyxun.gitee.io/adomain/ 推荐小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbe90cda0675b788317774520a0af6a/" rel="bookmark">
			Python&#43;Mysql实现登录验证程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python+Mysql实现登录验证程序 一、程序介绍1.模块2.功能 二、代码实现 一、程序介绍 1.模块 本程序使用到了random、time和pymysql，pymysql为外置库，需自行下载，安装命令：pip install pymysql。
2.功能 (1)注册方法：
通过用户输出用户名和密码就行注册，对密码的内容和长度进行了限制，并检测用户名有无出现重复情况，满足以上情况则注册成功，写入数据库。
(2)登录方法：
根据用户输入的用户名和密码与数据库中的数据进行匹配得出登录结果。另外用代码模拟了一个进度条，修改了一些打印信息的字体颜色、背景颜色之类的。
(3)功能提示方法：
输入1和2分别是注册功能和登录功能，除1和2的任意字符都可退出程序。
(4)缺点：
该程序并不是很完善，可以继续添加其他方法，比如注销用户、修改密码等方法。有兴趣的朋友们可以自行完善一下，甚至是做出图形化界面。
二、代码实现 1.注册方法：
def logon(self): uname = input("请输入用户名：") while True: upasswd = input("请输入密码(密码类型包括数字、小写字母、大写字母、其他符号，需包括其中三种类型)：") while len(upasswd) &lt; 7: upasswd = input("您的密码长度必须8位以上，请重新输入:") num, xx, dx, qt = 0, 0, 0, 0 for i in upasswd: if i.isdigit(): # 判断i是不是数字 num = 1 elif i.islower(): # 判断i是不是小写字母 xx = 1 elif i.isupper(): # 判断i是不是大写写字母 dx = 1 else: # 其他字符 qt = 1 if num+xx+dx+qt &gt;= 3: usern = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbe90cda0675b788317774520a0af6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb067fcbb17a9550cf3705a80c2629c2/" rel="bookmark">
			Python简单实现双色球功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python简单实现双色球功能 一、程序说明二、代码实现三、运行结果 一、程序说明 还程序简单实现了通过用户输入机选几注后，随机选出双色球结果，且一组结果中的号码不会出现重复现象，对号码也是进行背景颜色标记，有蓝球和红球。
二、代码实现 import time import random r = [] b = [] num = int(input("机选几注：")) for i in range(1, num+1): time.sleep(1) blue = [x for x in range (1,17)] red = [y for y in range (1,34)] a = random.choice(blue) b.append(a) for n in range(1, 7): d = random.randint(0, (len(red)-1)) w = red.pop(d) r.append(w) print("\033[1;41m{:0&gt;2d}\033[0m \033[1;41m{:0&gt;2d}\033[0m \033[1;41m{:0&gt;2d}\033[0m \033[1;41m{:0&gt;2d}\033[0m \033[1;41m{:0&gt;2d}\033[0m \033[1;41m{:0&gt;2d}\033[0m | \033[1;44m{:0&gt;2d}\033[0m\n".format(r[0], r[1], r[2], r[3], r[4], r[5], b[0])) del r[:] del b[:] 三、运行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09737d0ddee6775b8694e5418fc9d285/" rel="bookmark">
			mybatis的接口绑定方式（注解绑定和配置xml文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、配置xml文件
步骤
1、创建pojo类（Student对象）
2、创建StudentMapper接口
3、创建mapper.xml配置文件
4、在mymybatis-config.xml中添加StudentMapper配置
5、创建测试类
二、注解绑定
步骤
1、创建pojo类（Teacher 对象）
2、创建TeacherMapper接口
3、更改配置
4、创建测试类TeacherMapperTest
mybatis实现了接口绑定，使用会更加方便
接口绑定：mybatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，就可以直接调用接口方法就可以
接口绑定方式：
通过注解绑定，直接在方法上面加上@Select @Update等注解，在注解里包含SQL绑定
通过XML里面SQL绑定，需要在xml配置文件里的namespace必须指定接口的全限定名
一、配置xml文件 步骤 1、创建pojo类（自定义对象类）
2、创建mapper.java接口
3、创建mapper.xml配置文件
4、在mymybatis-config.xml中添加mapper配置
5、创建测试类
这里以student表为例进行编码：
1、创建pojo类（Student对象） 给定是四个属性 SID,Sname,Ssex,Sage
并 右击 generate 出他们的getter and setter 和 toString()方法
public class Student { private Integer SID; private String Sname; private String Ssex; private Integer Sage; public Integer getSID() { return SID; } public void setSID(Integer SID) { this.SID = SID; } public String getSname() { return Sname; } public void setSname(String sname) { Sname = sname; } public String getSsex() { return Ssex; } public void setSsex(String ssex) { Ssex = ssex; } public Integer getSage() { return Sage; } public void setSage(Integer sage) { Sage = sage; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09737d0ddee6775b8694e5418fc9d285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63f9e96aabee9c32bd1d1336c44da12/" rel="bookmark">
			flutter弹框返回上上级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 弹框返回上上级：
Navigator.of(context).pop(true);然后.then返回（future方法才有.then）
2.Navigator.of(context).popUntil((route) =&gt; route.settings.name == ‘HBAssessmentPage’);
3.两级pop会出错，因为第一个pop后context消失了，第二个找不到context,所以出错的原因是第二个找不到context，这时可以传入不同地方的context实现返回上上级 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/253/">«</a>
	<span class="pagination__item pagination__item--current">254/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/255/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>