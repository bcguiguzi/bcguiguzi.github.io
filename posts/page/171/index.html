<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae52a0cfd9d462d1da1bdc3cd98d8a10/" rel="bookmark">
			记录一次关于关闭DHCP服务器没网的修复过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发生这件事的原因： 家里申请了动态公网IP 想使用家里的Linux 虚拟机做一个远程服务器。于是就开始研究起来了内外网互相映射 然后不小心在配置映射的过程当中关闭了网关以及路由器的DHCP服务 。然后就导致全屋断网。 DHCP 服务是干嘛的。 它的主要作用就是动态分配以及管理IP地址。 可以不让人去手动配置。免去很多麻烦。网管和路由器都是默认开启DHCP服务
事件分析 关闭了网关和路由器的DHCP服务为什么会导致全屋断网。
一开始路由器就没有配置固定的IP 所以 ，关闭网关之后，就没有去给路由器分配IP ，路由器自动使用IPV6 的IP 地址
路由器又没有自动给电脑分配IP 电脑也自动使用了IPV6的 IP 地址 。这个过程是可以通过ipconfig去发现的。
修复思路。 使用笔记本电脑。直接网线（因为网关关闭了无线）连接到天翼网关。
笔记本电脑IP 进行配置。
打开控制面板进入到网络和共享中心
先去掉IPV6前面的勾 双击IPV4
修改成以上地址
然后确定
打开浏览器 输入192.168.1.1进入网关设置。
这一步得进入到超级管理面板。
打开DHCP服务 。
重启网关
这时后网关就修复好了。路由器已经有了IP地址了
路由器设置。 重复以上步骤
不过就是把ipv4地址从 192.168.1.111 改成了 192.168.0.111 网关改成了 192.168.0.1
这时候电脑就已经和外网通了。
但是其它的电子设备。因为没有分配 所以还不能上网。简单其间 。打开路由器的DHCP服务 。让其自动分配IP地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759c3ab209056b1a8c34b707f2511463/" rel="bookmark">
			CompletableFuture中的CompletionException异常真是坑到我了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境 JDK 17
Idea 2022
熟悉JDK 8版本的同学，大概率都使用过 java.util.concurrent.CompletableFuture 这个类，有时候在业务服务中你可能需要并行的去执行某些骚操作，那就少不了它的存在。
我在业务中就有大量的需求场景，比如：我需要拉渠道方的订单和订单明细，落地到我司系统中。此时用到了两个接口：订单列表查询、订单明细查询，查询列表很简单，一页一页的翻页查询，因为它也只返回了订单号，我举个例子吧！
这里是订单列表查询接口返回的数据结构（Mock数据），一堆的订单号 { "data":[ "125345345345", "235894563423", "345345345343" ] } 接下来我肯定要根据订单号去查询订单明细的，千万不要下意识的进行for循环一个一个查，那要查到什么时候啊！
这个时候CompletableFuture就派上用场了。
CompletableFuture应用 前提条件，我为了方便使用，我是直接在业务的Base包中，封装了一个通用实现，当然只是适用于我们业务的，需要的同学自取。 注意：下面这段代码没有处理真实的异常，想直接用，再往下看！！！ /** * 偷个懒，线程池直接这样写了先，真实业务中不是这样搞的哈！ */ private final static ExecutorService executorService = Executors.newFixedThreadPool(4); /** * 创建并行任务并执行 * * @param list 数据源 * @param api API调用逻辑 * @param exceptionHandle 异常处理逻辑 * @param &lt;S&gt; 数据源类型 * @param &lt;T&gt; 程序返回类型 * @return 处理结果列表 */ public &lt;S, T&gt; List&lt;T&gt; parallelFutureJoin(Collection&lt;S&gt; list, Function&lt;S, T&gt; api, BiFunction&lt;Throwable, S, T&gt; exceptionHandle) { //规整所有任务 List&lt;CompletableFuture&lt;T&gt;&gt; collectFuture = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759c3ab209056b1a8c34b707f2511463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5381c3a942e44cc98adb407dcee0305e/" rel="bookmark">
			C&#43;&#43;实现的二叉树创建和遍历，超入门邻家小女也懂了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二叉树 特点
性质
二叉树的创建
声明
创建
成员运算符-&gt;
批量创建
完全二叉树的创建
打印二叉树
普通二叉树的创建
二叉树的遍历
层序遍历
先序遍历
中序遍历
后序遍历
递归法
前中后序对比
DFS遍历
树的相关术语
特殊二叉树
满二叉树
完全二叉树
二叉树 树（Tree）是n(n≥0)个节点的有限集。在任意一棵树中有且仅有一个特定的称为根（Root）的节点；当n＞1时，其余节点可分m(m＞0)为个互不相交的有限集T1,T2,...,Tm；其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。
二叉树（Binary Tree）是一种特殊的有序树型结构，所有节点最多只有2棵子树。
特点 （1）每个节点至多有两棵子树；
（2）二叉树的子树有左右之分；
（3）子树的次序不能任意颠倒（有序树）。
性质 （1）二叉树的第i层上至多有2^(i-1)个节点（i≥1）。
（2）深度为h的二叉树中至多含有2^h-1个节点(h≥1)。
（3）若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1。
（4）具有n个节点的满二叉树深为log2n+1。
（5）若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），
那么，对于编号为i（i≥1）的节点： 当i=1时，该节点为根，它无双亲节点。
当i&gt;1时，该节点的双亲节点的编号为i/2。
若2i≤n，则有编号为2i的左节点，否则没有左节点。
若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点。
二叉树的创建 声明 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 在C/C++语言中，经常使用 NULL 来表示空指针。
NULL在头文件里的定义：
#ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif 即在 C++中，NULL 被定义为整形常量 0，而在 C 中，被定义为无类型指针常量 (void*) 0 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5381c3a942e44cc98adb407dcee0305e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f830d7af268f36e00015edce926b7f8/" rel="bookmark">
			多进制调制系统MPSK性能仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容与要求 本课题要求用MATLAB产生独立等概信源，对信源进行MPSK调制，调制阶数自行设定。将调制信号送入高斯白噪声信道，接收端解调后得到解调信号，与发送信号分析比较，分析MPSK在高斯信道中的性能，计算传输过程中的误码率。上述过程可采用编写程序代码或Simulink模块仿真的方法实现。
掌握MPSK调制解调的基本原理。掌握MPSK调制解调系统的基本组成框架。给出MPSK调制后的波形图和功率谱密度。给出不同信噪比下，MPSK调制在高斯白噪声信道下的误码率性能曲线图。 简单介绍 MPSK调制是一种基于相位调制和正交调制的数字调制方式，具有高效传输和抗噪声干扰的特点，适用于数字通信系统中的信号调制和解调。
正交调制是一种常用的数字调制方式，其原理基于将数字信息信号与正弦/余弦信号进行正交相乘得到调制信号。
具体来说，正交调制通常使用正弦/余弦函数作为调制载波，也称为正交载波。正交载波是一组相互正交的信号，其中一个信号的周期是另一个信号的两倍。在正交调制中，数字信息信号会分为两路，分别与正弦/余弦信号相乘，得到两个正交的调制信号。这两个调制信号分别代表数字信息信号的实部和虚部。两路调制信号可以通过I/Q调制器得到，即将调制信号分别乘以正弦/余弦信号，并将两路信号相加。[3]
正交调制的特点是能够将数字信息信号在一个较窄的带宽内进行传输，同时具有抗噪声干扰的能力。在接收端，需要使用与发送端相同的正交载波解调出数字信息信号。通过将接收到的正交调制信号分别与正弦/余弦信号相乘，得到两路信号，分别代表数字信息信号的实部和虚部。然后将两路信号相加，即可得到原始数字信息信号。
相位调制是一种常用的数字调制方式，其原理基于改变载波信号的相位来表示数字信息。
具体来说，相位调制通常使用正弦波或余弦波作为载波信号，通过改变载波信号的相位来表示数字信息。在相位调制中，数字信息信号的离散样本会被映射到载波相位上，通常采用将数字信息信号转换为二进制位流，并将每一位映射到一个相位上。最常见的相位调制方式包括二进制相移键控（Binary Phase Shift Keying，BPSK）、四进制相移键控（Quadrature Phase Shift Keying，QPSK）、八进制相移键控（8-PSK）等。
在发送端，相位调制的信号可以通过将数字信息信号的二进制位流映射到不同的相位上，得到一组离散的调制符号。通过对每个符号乘以载波信号，可以得到相位调制信号。在接收端，接收到的相位调制信号需要进行解调，以获得原始数字信息信号。在解调中，通常采用鉴相器（coherent detector）或非鉴相器（non-coherent detector）来检测相位，从而将接收到的相位调制信号转换为数字信息信号。
正交调制和相位调制的区别 正交调制和相位调制都是数字通信中常用的调制方式，它们之间的区别如下：
1.调制方式不同： 正交调制是指将数字信号分成两路，分别用正弦和余弦信号调制成两个正交的载波，形成正交调制信号；而相位调制是指将数字信号用正弦波调制成相位不同的载波，形成相位调制信号。
2.载波形式不同： 正交调制中，两个正交的载波分别是正弦和余弦波，而相位调制中，载波一般只是正弦波。
3.信号传输方式不同： 正交调制中，两个正交的载波同时传输，每个载波上携带了一路数字信号，因此在接收端需要进行解调得到两路数字信号；而相位调制中，只有一个载波在传输，但其相位发生了变化，因此接收端只需要检测载波相位变化即可得到数字信号。
4.抗噪声性能不同： 由于正交调制中使用了两个正交的载波，因此其相对于相位调制而言具有更好的抗噪声能力。
MATLAB实现方案一 % 设置参数 M = 8; % MPSK调制阶数 N = 10000; % 信源符号个数 SNR = 10; % 信噪比（dB） % 产生随机信源符号 bits = randi([0 M-1], N,1); %产生单极性信源 M = 8; % 调制阶数 mod_signal = pskmod(bits, M); % 进行MPSK调制 % 高斯白噪声信道模拟 noisy_signal = awgn(mod_signal, SNR); % MPSK解调 demod_signal = pskdemod(noisy_signal, M); % 生成MPSK星座图 constellation = exp(1j*2*pi*(0:M-1)/M); figure; plot(constellation, 'o'); title('MPSK Constellation'); axis square; 上述代码进行了一个使用MATKLAB的库函数进行了一个基本的调制解调。但并不能完成主要任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f830d7af268f36e00015edce926b7f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db342d9c1412f6c3cb33364ffe445fa/" rel="bookmark">
			leetCode 1(Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c2473e6a2b5f5f071b7f5dc74cde94/" rel="bookmark">
			xshell链接不上centos7可能是sshd服务未开启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当xshell链接不上centos7虚拟机可能是sshd相关服务没启动（默认是没开启的） 在虚拟机（Vmware Workstation）下，安装了CentOS7，现在想通过SSH工具连接虚拟机中的CentOS7
centos7默认sshd-config文件里的端口号服务远程登录是没有开启（如下都是注释状态）的需要手动开启
一，sshd服务 1，检查是否安装openssh-server
yum list installed | grep openssh-server 上图显示openssh-server即已经安装
若没有显示即手动安装
yum install openssh-server 2,找到/etc/ssh/目录下的sshd服务配置文件sshd_config,用vim编辑器打开
vim /etc/ssh/sshd_config 3，把文件中的监听号地址打开
4，允许远程监控
5，使用用户密码登录
6，保存文件退出
7，开启sshd服务
service sshd start 8，为了免去每次开启 CentOS 时，都要手动开启 sshd 服务，可以将 sshd 服务添加至自启动列表中，输入
systemctl enable sshd.service 9，可以通过输入systemctl list-unit-files | grep sshd，查看是否开启了sshd 服务自启动
systemctl list-unit-files | grep sshd 另附
二，如果XShell连接虚拟机非常慢，可采用如下方法： vim /etc/ssh/sshd_config在sshd_config文件中，加入一行
UseDNS no
然后:wq保存退出
3. 通过service sshd restart命令重启ssh服务
88392)]8}5JP9XTASB22XGKNO.jpg)
然后:wq保存退出
4. 通过service sshd restart命令重启ssh服务
5.使用Xshell连接即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aad6d773e2f8083ace2ba0103be3d1a/" rel="bookmark">
			C&#43;&#43;二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义一个二叉树结构体 #include&lt;iostream&gt; using namespace std; typedef struct TreeNode { char data; struct TreeNode *lchild, *rchild; }TreeNode, *Bitree; 此处取别名时，我认为*Bitree加不加*都可以，只是后面定义树的时候有区别。加*后面定义Bitree T;不加的话Bitree *T。
2、建立二叉树 为了确定二叉树是否每个结点都有左右孩子，对其进行扩展，也就是将二叉树的每个结点的空指针引出一个虚结点，并赋予一个特定值（此处我们为"#"）如上图所示。
void CreateBitree(BiTree &amp;T) { char NodeData; cout &lt;&lt; "请输入结点字符(一个字符)："; cin &gt;&gt; NodeData; if (NodeData == '#') { T = NULL; } else { T = new TreeNode; //开辟空间 if (!T) return; T-&gt;data = NodeData; CreateBitree(T-&gt;Ichild); //构造左结点 CreateBitree(T-&gt;Rchild); //构造右结点 } } 传参时形参为*T或者&amp;T都可以看个人习惯，主要是需要通过地址传递。
3、前序遍历 先访问根节点，然后前序遍历左子树，再前序遍历右子树(根左右)
//前序遍历 void PreOrderTraverse(BiTree T) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aad6d773e2f8083ace2ba0103be3d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea34ed856f5f144c84985a8c1761bed/" rel="bookmark">
			Wayland环境下通过xwayland支持docker图形界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 在之前的文章里已经讲解了怎么直接在docker中使用wayland支持图形界面（docker内外都使用wayland），文章链接：
使用Docker安装ROS2 (ros-humble) 并开启对Wayland的支持
指令为：
docker run -it --privileged \ -v &lt;host_src&gt;:&lt;container_src&gt;:rw \ -e XDG_RUNTIME_DIR=/tmp \ -e WAYLAND_DISPLAY=$WAYLAND_DISPLAY \ -v $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY:/tmp/$WAYLAND_DISPLAY \ -e QT_QPA_PLATFORM=wayland \ --name &lt;local_container_name&gt; &lt;container&gt;:&lt;tag&gt; &lt;build_command&gt; 然后就可以在docker中打开图形界面了。
然而，目前有一些软件不支持wayland、配置麻烦或者无法启动，所以本文介绍一种通过xwayland的方式在docker中使用X11渲染图形界面（docker外使用wayland，docker内使用X11）。
注意：这个方法使用了xwayland转换，一些软件可能依然无法使用，可以尝试其它方法如x11docker
Xwayland xwayland可以理解为一个桥，可以在wayland上提供一个X11的接口。
xwayland的安装非常简单，可以自行搜索，对于大多数发行版都可以通过包管理器直接安装。
运行方式 说到这里可能有些抽象，到底在哪里用wayland，哪里用X11？一句话概括为：
主机（运行wayland）-&gt; xwayland -&gt; 主机:/tmp/.X11-unix -&gt; docker:/tmp/.X11-unix -&gt; docker（X11环境）
启动docker xhost + docker run -it --privileged \ --env=LOCAL_USER_ID="$(id -u)" \ -v &lt;host_src&gt;:&lt;container_src&gt;:rw \ -v /tmp/.X11-unix:/tmp/.X11-unix:ro \ -e DISPLAY=$DISPLAY \ --name=&lt;local_container_name&gt; &lt;container&gt;:&lt;tag&gt; &lt;build_command&gt; -v &lt;host_src&gt;:&lt;container_src&gt;:rw将主机的&lt;host_src&gt;路径映射到docker的&lt;container_src&gt;路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea34ed856f5f144c84985a8c1761bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3da16ac4a3a4ab3c661c69790f1d2a9/" rel="bookmark">
			【微信小程序】-- 案例 - 本地生活（列表页面）（三十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💌 所属专栏：【微信小程序开发教程】 😀 作 者：我是夜阑的狗🐶 🚀 个人简介：一个正在努力学技术的CV工程师，专注基础和实战分享 ，欢迎咨询！
💖 欢迎大家：这里是CSDN，我总结知识的地方，喜欢的话请三连，有问题请私信 😘 😘 😘
文章目录 前言一、案例 - 本地生活（列表页面）1、演示页面效果以及主要功能 二、页面导航并传参三、上拉触底时加载下一页数据1、动态设置页面标题2、创建编译模式3、列表页面的 API 接口4、实现上拉加载数据和效果5、对上拉触底进行节流处理6、判断数据是否加载完毕 四、下拉刷新列表数据五、使用 wxs 处理手机号总结 前言 大家好，又见面了，我是夜阑的狗🐶，本文是专栏【微信小程序开发教程】专栏的第30篇文章;
今天开始学习微信小程序的第15天💖💖💖，开启新的征程，记录最美好的时刻🎉，每天进步一点点。
专栏地址：【微信小程序开发教程】， 此专栏是我是夜阑的狗微信小程序开发过程的总结，希望能够加深自己的印象，以及帮助到其他的小伙伴😉😉。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
一、案例 - 本地生活（列表页面） 前面已经学习了WXS 脚本的概念和基本语法，通过栗子了解到WXS的怎么创建和调用。接下来就来根据前面学的知识，在案例-本地生活上进行实践。话不多说，让我们原文再续，书接上回吧。
1、演示页面效果以及主要功能 首先来看一下页面演示效果，页面中有列表数据，其中还要具备下拉和上拉刷新功能：
接下来实现主要功能有三个：
页面导航并传参上拉触底时加载下一页数据下拉刷新列表数据 二、页面导航并传参 首先创建列表页面，可以通过 app.json 文件进行快速创建。
app.json
{ "pages":[ "pages/home/home", "pages/message/message", "pages/contact/contact", "pages/shoplist/shoplist" ], } 可以来看一下实际结果：
从 view 组件改造成 navigator 组件，从而支持跳转行为，并且在跳转过程中还要传递参数（id + 名称），为了后续页面标题和查询数据做准备。
home.wxml
&lt;view class="grid-list"&gt; &lt;navigator class="grid-item" wx:for="{{gridList}}" wx:key="id" url="/pages/shoplist/shoplist?id={{item.id}}&amp;title={{item.name}}"&gt; &lt;image src="{{item.icon}}"&gt;&lt;/image&gt; &lt;text&gt;{{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3da16ac4a3a4ab3c661c69790f1d2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c47e0e06580ff42724ca74fb643d61b/" rel="bookmark">
			GPT 模型介绍 | GPT3 / GPT3.5 &#43; Flask | Github源码链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 模型介绍 Chatgpt 使用与 InstructGPT相同的方法，使用来自人类反馈的强化学习 (RLHF) 来训练该模型，但数据收集设置略有不同。我们使用监督微调训练了一个初始模型：人类 AI 训练员提供对话，他们在对话中扮演双方——用户和 AI 助手。我们让培训师可以访问模型编写的建议，以帮助他们撰写回复。我们将这个新的对话数据集与 InstructGPT 数据集混合，我们将其转换为对话格式。
为了创建强化学习的奖励模型，我们需要收集比较数据，其中包含两个或多个按质量排序的模型响应。为了收集这些数据，我们收集了 AI 培训师与聊天机器人的对话。我们随机选择了一条模型编写的消息，抽取了几个备选的完成方式，并让 AI 培训师对它们进行排名。使用这些奖励模型，我们可以使用近端策略优化来微调模型 。模型可以学习用自然语言表达对其自身答案的不确定性——无需使用模型逻辑。当给出问题时，模型会生成答案和置信度（例如“90% 置信度”或“高置信度”）。这些级别映射到经过良好校准的概率。该模型还在分布变化下保持适度校准，并且对自身答案的不确定性敏感，而不是模仿人类的例子。
2. 模型结构 ChatGPT的基本模型结构：
输入嵌入层（Input Embedding Layer）：
输入嵌入层将文本序列中的每个单词转换成一个高维向量。这些向量的维度通常是几百维，其中每个维度代表单词的一个特定特征。ChatGPT使用预训练的词嵌入向量作为输入，这些向量基于大规模的文本语料库训练得到。
多层Transformer编码器（Multi-layer Transformer Encoder）：
在编码器中，模型将输入序列的嵌入向量通过一系列的自注意力（Self-Attention）和前馈神经网络（Feed-Forward Neural Networks）进行非线性变换。自注意力机制使模型能够自适应地学习输入序列中不同单词之间的依赖关系。在这个过程中，模型将输入序列的嵌入向量逐层传递到下一个编码器层，每层中向量的维度都会被扩大，以提取更多的语义信息。
多层Transformer解码器（Multi-layer Transformer Decoder）：
在解码器中，模型将编码器的输出和上下文信息（如聊天对话历史）通过一系列的自注意力和前馈神经网络进行非线性变换，生成下一个文本序列。在生成期间，模型会根据之前生成的所有单词和输入序列的信息，预测下一个单词的概率分布，并将概率最高的单词作为下一个单词输出。生成的单词向量也会被传递到下一层，每层中向量的维度都会被缩小，以逐渐将生成的序列转换成更高层次的语义表示。
头部层（Head Layer）：
在模型的顶部，可以添加不同的头部层，以使模型适用于不同的自然语言处理任务。例如，对于聊天机器人任务，可以添加一个生成头部层，将模型的输出作为自然语言回复。对于文本分类任务，可以添加一个分类头部层，将模型的输出作为文本分类的概率分布。头部层通常是由全连接层（Fully Connected Layer）和softmax函数组成，以将模型的输出转换成相应的目标格式。
在训练期间，ChatGPT模型使用自回归的方式，即从左到右逐个生成文本。每个时间步生成的单词基于之前生成的所有单词和输入序列的信息。而在生成期间，ChatGPT模型使用了自注意力机制，能够在不同的上下文中自适应地学习语言模型。
3. Openai API + Flask Github 源代码 GPT 3 + Flask (text-davinci-003 API):
https://github.com/redemptionwxy/GPT3-API-Flask-Python_Chat_Website
GPT 3.5 + Flask (gpt-3.5-turbo API ):
https://github.com/redemptionwxy/ChatGPT-API-Flask-Website
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92938407df5e54386ce736a150c4544/" rel="bookmark">
			JavaEE课程实践-Servlet的部署（tomcat服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Servlet简述
tomcat服务器的安装和运行
Servlet的部署
部署具体步骤
一、创建maven工程
二、创建Servlet类
三、导入相应jar包
四、编写Servlet代码
五、运行maven项目，启动tomcat服务器
六、测试访问是否成功。
Servlet简述 Servlet 是 Java EE 技术的一部分，它是一种在 Web 服务器中运行的 Java 类,或者说是运行在web服务器上的应用程序，用于处理来自客户端的 HTTP 请求和响应。
Servlet 主要用于生成动态 Web 内容，它们可以与 Web 服务器（例如Tomcat）一起使用，通过 Web 容器来处理 HTTP 请求和响应。
Servlet 的主要功能包括：
接收来自客户端的 HTTP 请求。读取请求参数、请求头信息、cookies 等数据。处理请求并生成响应数据。将响应数据发送回客户端，比如 HTML 页面、JSON 数据等。 tomcat服务器的安装和运行 对于tomcat的安装和运行，我在另一篇博客已有说明和使用演示=&gt;tomcat介绍和使用&lt;=
ps: tomcat的安装和运行非常简单，只需要下载安装包，解压即用。
Servlet的部署 需求：创建一个servlet，将此servlet部署到tomcat服务器上，并能够通过URL访问到。
说明：在此使用maven项目构建工具作为基础环境进行编写部署。 至于maven的介绍和使用，我在另一篇博客已有详解=&gt;maven入门到进阶&lt;=
使用maven的好处：
不使用maven：对于此测试部署，如果不使用maven，我们需要自己到网页上下载需要的jar包并导入到项目中，自己找的jar包版本不一，真假难辨，并且编写完servlet后我们还需要手动将servlet代码编译成字节码，手动部署到tomcat的webapps目录中，比较繁琐。
使用maven：我们如果使用maven，导入jar包时仅仅需要在pom文件中编写jar包对应坐标即可导入，并且可以在pom文件中引入maven插件，我们只需要执行对应命令，maven就会自动将项目部署到tomcat服务器上。
部署具体步骤 一、创建maven工程 如果使用的编码工具是：IntelliJ IDEA，其中内置了maven，可以直接使用内置的maven，或者自己到设置中配置自己的也是没有问题。
查看和配置maven：进入idea设置，搜索maven,如下图 （在此直接使用内置默认的maven）
创建过程 二、创建Servlet类 三、导入相应jar包 在项目的pom.xml中编写 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c92938407df5e54386ce736a150c4544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2093c39dfc84cb2280acabd7106e7cc/" rel="bookmark">
			嵌入式物联网毕业设计选题智能图像识别项目-stm32mp157 linux开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32mp157开发板FS-MP1A是华清远见自主研发的一款高品质、高性价比的Linux+单片机二合一的嵌入式教学级开发板。开发板搭载ST的STM32MP157高性能微处理器，集成2个Cortex-A7核和1个Cortex-M4 核，A7核上可以跑Linux操作系统，M4核上可以跑FreeRTOS、RT-Thread等实时操作系统。开发板搭配仿真器、显示屏、摄像头、资源扩展板等丰富的扩展模块，可拓展物联网、人工智能等相关技术学习，还可以拓展丰富的项目实战，非常贴合企业当下开发需求，是一款嵌入式Linux入门进阶必备开发板！
可学习技术：嵌入式Linux应用/系统/驱动开发、ARM裸机开发、Qt界面编程、STM32单片机、FreeRTOS、人工智能机器视觉等。其中ARM Cortex-A7裸机开发课程是华清远见独有特色课程，可关注：https://www.bilibili.com/video/BV1Xe4y1i7vm/，持续更新中。
14个Linux+Qt综合项目案例，6个MP1A物联网拓展项目
关注公众号“华清远见在线实验室”，回复“mp157项目”，即可领取项目配套文档及源码。 Linux+Qt综合项目案例：华清远见stm32mp157开发板优势特色部分，包括音乐播放器、智慧家庭、智能工业电表、智能出行助手、智能猫眼、环境监测、智能安防、智能语音识别等10余个项目案例，涉及家居、医疗、农业多种应用方向，在案例中使用了多种物联网和嵌入式技术，包括OT开发、linux应用开发、linux驱动开发、物联网云端接入、MQTT协议、json字符串等知识点。
基于Linux+Qt的智能图像识别项目 项目简介：
提到图像识别，一般都会想到人工智能。虽然现在人工智能还在发展阶段，但是有些技术已经成熟，比如图像识别、语音识别等。本项目将调用百度 AI 开发平台 API 进行图像识别。
开发平台：
华清远见stm32mp157开发板豪华套餐（开发板+仿真器+五寸屏+摄像头+资源扩展板+tf卡+读卡器）
项目实战：
Qt 开发环境搭建 主机开发环境说明 1) 本文档主要介绍 linux 环境下的 Qt 程序开发；
2) 主机 Qt 版本为 5.14.1；
主机 Qt 环境搭建及使用 Qt Creator 安装 将 qt-creator-opensource-linux-x86_64-4.10.1.run（Qt 实验源码\工具软件） 复制到 ubuntu 主机中，可以采用共享文件夹的方式也可以使用 tfp方式将文 件存入家目录下的 Downloads 目录。我们需要在终端中赋予安装程序可执行的权限
我们可以使用图形化的文件管理器来查看
双击“qt-creator-opensource-linux-x86_64-4.10.1.run”图标运行安装程序。出现如下界面：
等待程序验证完成后点击“Next”
这里我们需要登录或者注册一个账号，如果我们之前已经注册过直接登录就可以。如果没有注册过则需要新注册有一个账号后登录。这里笔者已经注册过账号，所以直接登录。 登录成功后出现如下界面，点击 Next
这里选择安装路径
可以直接默认，Next
这路选择安装的组件，直接默认即可
这里我们需要同意用户协议
这个界面告诉我们安装完成后需要占用的空间。点击”Install”按钮后开始安装。
安装完成后出现如下界面
点击“Finish”按钮后将弹出 Qt Creator 主界面
点击“Cancel”按钮后即可正常使用
Qt5.14.1 安装 复制到 qt-opensource-linux-x64-5.14.1.run（Qt 实验源码\工具软件）到 ubuntu 主机中，可以采用共享文件夹的方式也可以使用 tfp 方式将文件存入家目录下的 Downloads 目录。进入所在文件夹，先给执行权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2093c39dfc84cb2280acabd7106e7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e868af0b4d2b85787b0946538cb14f/" rel="bookmark">
			java八股系列——Spring Bean的作用域与生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：作用域 Spring Bean作用域是指在Spring容器中管理的Bean对象的生命周期和可见范围。Spring框架提供了五种Bean作用域：
Singleton(单例)：单例模式，Spring IOC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton作用域是Spring中的缺省作用域，也可以显示地将 Bean定义为singleton模式Prototype(原型)：原型模式，每次通过Spring容器获取Prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而Singleton全局只有一个对象。根据经验，对有状态的bean使用Prototype作用域，而对无状态的bean使用Singleton作用域。需要注意的是，Spring在创建好交给使用者之后则不会再管理后续的生命周期。Request(请求)：在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效，当前Http请求结束，该bean实例也将会被销毁。该作用域仅适用于WebApplicationContext环境。Session(会话)：在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。该作用域仅适用于WebApplicationContext环境。GlobalSession(全局会话)：在一个全局的HTTP会话中，每个Bean实例都会被创建一次，该作用域仅适用于WebApplicationContext环境。在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用 portlet context时有效。 通过配置Bean的作用域，可以控制Bean的生命周期和可见范围，从而更好地管理和利用Bean对象。
注：Global Session是指在整个应用程序中都可以访问和使用的会话对象。关键在于"整个应用程序"，因为一个应用可能是部署在多台机器上的，而Global Session是多台机器共享的Session。Global Session可以通过不同的方式实现，例如使用数据库、缓存或分布式存储等。在Java中，可以使用Servlet API中的HttpSession来实现全局会话。需要注意的是，全局会话可能会带来一些安全风险，例如会话劫持和会话固定攻击等。因此，在实现全局会话时，需要采取一些安全措施，例如使用安全的会话ID、定期更新会话ID等。
二：生命周期 Spring Bean的生命周期可以分为以下几个阶段：
实例化(Instantiation)：当Spring容器启动时，会根据配置文件或注解等方式创建Bean实例。属性赋值(Populate)：在实例化后，Spring容器会将配置文件或注解中的属性值注入到Bean实例中。BeanPostProcessor的前置处理：在Bean实例化和属性赋值之后，Spring容器会调用所有实现了BeanPostProcessor接口的类的postProcessBeforeInitialization方法，对Bean进行前置处理。初始化(Initialization)：在属性赋值完成后，Spring容器会调用Bean的初始化方法，可以通过实现InitializingBean接口或在配置文件中指定init-method来定义初始化方法。BeanPostProcessor的后置处理：在Bean初始化方法执行完成后，Spring容器会调用所有实现了BeanPostProcessor接口的类的postProcessAfterInitialization方法，对Bean进行后置处理。销毁(Destruction)：当Spring容器关闭时，会调用Bean的销毁方法，可以通过实现DisposableBean接口或在配置文件中指定destroy-method来定义销毁方法。 需要注意的是，Spring Bean的生命周期并不是线性的，可能会在某个阶段中断或回到之前的阶段。例如，在初始化阶段中，如果发生异常，则会回到实例化阶段重新创建Bean实例。
在这个过程中，可以通过实现接口或在配置文件中指定方法来定义Bean的初始化和销毁方法：
@PostConstruct：用于在Bean初始化之后执行一些操作。这个注解可以用在方法上，方法会在Bean初始化之后被调用。@PreDestroy：用于在Bean销毁之前执行一些操作。这个注解可以用在方法上，方法会在Bean销毁之前被调用。 如果有兴趣了解更多相关内容，欢迎来我的个人网站看看：耶瞳空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdc4e8fc7db6a151e54e5bd5923e880/" rel="bookmark">
			浙政钉扫码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 浙政钉接口请求 专有钉钉门户开放平台
是什么：专有钉钉提供给⼆三⽅进⾏应⽤开发使⽤
如何使用：
①需要有ak(appkey) sk(appsecret) 域名(domain),租户id(tenantId)—&gt;包括了一些接口的权限
扫码登录是单独的组件需要一个单独的ak sk,调用接口是需要专门申请接口的ak,sk
②找到自己需要功能的接口，根据需要的参数，调用时传入参数进去
③根据返回的Json,获取JsonObject得到数据
例子1：浙政钉扫码登录 扫码登录帮助文档
步骤一:构建扫码的链接 https://login.dg-work.cn/oauth2/auth.htm?response_type=code&amp;client_id=应用标识&amp;redirect_uri=回调地址&amp;scope=get_user_info&amp;authType=QRCODE
步骤二:构建请求的客户端 步骤三：扫码获取code(临时授权码)+调用/gettoken.json接口获取access-token，请求/rpc/oauth2/getuserinfo_bycode.json接口，获取用户信息 获取用户信息参考链接
步骤四：写自己的逻辑，拿到数据后，和库里的数据进行匹配，是否存在这个人，存在就登录成功，不存在就登录失败（新增用户或者用户添加权限之类的） 工具方法：Json转成JsonObject 工具方法：Json转成JsonArray 例子2：定时拉取浙政钉的用户信息 写定时任务，调用获取组织人员详细信息的接口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd592f4d2d56bb9e827bfefe60cb76af/" rel="bookmark">
			使用电脑摄像头通过UE5驱动MetaHuman面部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直用iphone摄像头给导入UE5的metehuman做面捕，效果还是很不错的。最近有个需求，要求用电脑摄像头做面捕。从网上查了一下，可以通过mefamo来实现。
先去GitHub找一下，发现搜到的是源码（https://github.com/JimWest/MeFaMo），有python的源码真是太好了。可是今天我没时间搞代码，想找个现成的先试试效果，看到有个release的程序，直接下载过来。如下图：
执行这个文件就行了。
现在去UE5里面，在顶部菜单中点击【窗口】，下拉菜单中选择【虚拟制片】，然后点击二级菜单中的【Live Link】。怎么打开Live Link插件这里就不讲了，如果没有打开可以参考我前面的几篇文章。如果没有问题的话，可以在Live Link窗口中发现多了一项Python_LiveLinkFace的源。如果能用的话，后面会有一个绿色的点。如下图：
然后在【大纲】里点击已经导入好的人物，我的人物叫【BP_OldMan】，在下面【细节】窗口里的【Live Link】中把ARKit Face Subj改成Python_LiveLinkFace，再把ARKit Body Subj也改成Python_LiveLinkFace。人物面捕就完成了。如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8800171c6e147b4ed016f8b28eac46c3/" rel="bookmark">
			java八股系列——SpringMVC从接受请求到完成响应的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring的MVC框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。
流程大致如下：
用户发起请求：用户在浏览器中输入URL，点击链接或提交表单，向服务器发起请求。DispatcherServlet接收请求：DispatcherServlet是Spring MVC的核心控制器，它接收所有的请求并将其分发到相应的处理器中。HandlerMapping匹配处理器：HandlerMapping根据请求的URL和其他条件，匹配合适的处理器。HandlerAdapter调用处理器：HandlerAdapter将请求传递给匹配的处理器，并调用处理器的方法来处理请求。处理器处理请求：处理器根据请求的类型和参数，执行相应的业务逻辑，并返回一个ModelAndView对象。ViewResolver解析视图：ViewResolver根据ModelAndView对象中的视图名称，解析出对应的视图。视图渲染：视图将ModelAndView对象中的数据渲染成HTML、JSON、XML等格式的响应数据。响应数据返回：响应数据返回给客户端，客户端浏览器根据响应数据渲染页面或执行其他操作。 在整个过程中，Spring MVC还提供了一些其他的功能，如拦截器、数据绑定、数据验证、异常处理等。这些功能可以帮助开发者更方便地开发Web应用程序。
如果有兴趣了解更多相关内容，欢迎来我的个人网站看看：耶瞳空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c1b814a888874adab28792dbf9f34d/" rel="bookmark">
			浅谈vuex之mapState用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、state state是什么?
定义:state(vuex) ≈ data (vue)
vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.
虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精
综上所述,请用computed去接收state,如下
//state.js let state = { count: 1, name: 'dkr', sex: '男', from: 'china' } export default state &lt;template&gt; &lt;div id="example"&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; {{count}} {{dataCount}} &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { dataCount: this.$store.state.count //用data接收 } }, computed:{ count(){ return this.$store.state.count //用computed接收 } } methods: { increment () { this.$store.commit('increment') }, decrement () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c1b814a888874adab28792dbf9f34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797fa13ec3ac04b290b8b4711642c7e3/" rel="bookmark">
			Soil liquefaction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考资料
Soil Liquefaction Web SiteLinks – Geotechnics and Urban Resilience 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfe72afb0ab0d7fddb7da200edd020a/" rel="bookmark">
			Oracle表空间扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_41206741/article/details/119515909
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bfc9ac290b39e32c8fdb65dc2c5a42/" rel="bookmark">
			java生成PDF表单及pdf转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载PDF表单编辑工具Adobe Acrobat DC；需要对申请表的word文件或者图片，通过Adobe Acrobat DC或者wps生成pdf文件。
2.打开Acrobat DC，点击工具-&gt;点击准备表单-&gt;选择pdf文件生成表单。
3.对pdf表单进行编辑，双击选中需要编辑的区域，在文本域属性中添加该区域的字段名称及属性
（有些区域不能选中编辑，这个需要你复制其中的一个可编辑区域，把复制的手动移到需要编辑的区域就可以了）
然后保存成pdf表单。
4.导入pdf依赖包，我这里是用的mven
&lt;!--pdf设计器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt; &lt;artifactId&gt;xmlworker&lt;/artifactId&gt; &lt;version&gt;5.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.itextpdf/itext-asian --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--pdf转png--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.26&lt;/version&gt; &lt;/dependency&gt; 5.上传生产环境代码块 json结构化数据生成pdf表单。
//加载pdf表单 PdfReader reader = new PdfReader("pdf表单绝对路径"); ByteArrayOutputStream bos = new ByteArrayOutputStream(); PdfStamper ps = new PdfStamper(reader, bos); AcroFields s = ps.getAcroFields(); /** * 使用中文字体 使用 AcroFields填充值的不需要在程序中设置字体，在模板文件中设置字体为中文字体 Adobe 宋体 std L */ BaseFont bfChinese = BaseFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bfc9ac290b39e32c8fdb65dc2c5a42/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/170/">«</a>
	<span class="pagination__item pagination__item--current">171/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/172/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>