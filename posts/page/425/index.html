<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c650cccbffa000e83bd976b5cb12f98e/" rel="bookmark">
			解决：腾讯云ubuntu服务器无法开启443端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这两天 在搞ubuntu的项目配置 因为腾讯云的服务器默认不会给 root权限 所以 无法开起 1000以下的端口 如：443端口 又因为微信小程序 这边是https 请求 又只支持 443 端口 所以在 在这里记一下 1.修改ubuntu 配置文件 使用root用户登录 直接开启443端口 2.做简单的端口映射 （我这边使用的是这种） 这里的思路利用其它端口 映射443端口 具体操作 如下：
sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 7443
这里的意思是讲 7443端口 映射为 443端口 所以这边 服务器 只要 开放 7443 端口 就可以使用了
但是 有个缺点 貌似 服务器所在的电脑 重启过后需要 重新映射一下 还有待考察…
小白在这记此一笔~~~嘿嘿 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509d7e8a29de0522b3f782badf702366/" rel="bookmark">
			51job pandas数据清洗与pycharts画图分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇想要的数据已经基本都爬到了，下一步就是数据的清洗了。
仔细观察了数据的特征，发现数据中存在太多的脏数据了，就例如很多搞房地产的，销售的，等等很多其他的一些无关职业，并且还包含很多重复项。我就把数据一遍一遍的清洗，第一遍我先在职位标题中挑出来带有特定关键词的职位，例如我搜索的是大数据的工作，那么我的关键词里就包含['数据', '分析', 'ETL', 'java', 'JAVA', '人工智能', '智能', '互联网', 'ELK','工程师']这些，凡是带有这些关键词的职位都留下来，不带的都舍弃。这是第一遍
这里的第一个函数是读取文件
第二个函数调用第一个读取的结果
def ReadFile(self, FileName): # 读取数据 df = pd.read_csv('E:/51JobData/{}'.format(FileName), engine='python', encoding='gbk', iterator=False, header=0) return df def KeyWord(self): # 第一遍清洗提取带有关键字的数据 ReadFile = 'all_jobmessage.csv' data = self.ReadFile(ReadFile) ss = [] key_word = ['数据', '分析', 'ETL', 'java', 'JAVA', '人工智能', '智能', '互联网', 'ELK', '工程师'] for index, row in data.iterrows(): try: if any(word in row['position_name'] for word in key_word): ss.append(row) except Exception as e: print(e) df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509d7e8a29de0522b3f782badf702366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c405cc711841e74ecc7040725578b0d0/" rel="bookmark">
			CSS：position属性定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		position属性定位: position从字面意思就是指定块的位置。
在CSS布局中，position属性非常重要，许多特殊容器的定位必须用到position来完成。
position的属性值包括：
①：absolute（绝对）：相对于父级元素的位置定位
②：relative（相对）：
③：static（静态）：默认值，它表示块保持在原本应该在的位置，按照在HTML中出现的顺序显示，没有任何移动效果。
④：fixed（固定）：本质上和设置absolute一样，只是以浏览器窗口为基准进行定位，块元素不能随着浏览器的滚动条向上或向下移动：相对于整个窗口而言位置定位。
⑤：inherit（继承）：从其父元素继承得到
配合position属性使用的，还有top、right、bottom、left这4个CSS属性值，分别表示块元素距离页面或父元素边框的距离（position 取值为absolute时），或各个边界离原来位置的距离（position取值为relative时）。这四个属性只有当position设置为absolute或者relative时才生效。
简易化理解：absolute相当于一个漂浮的气球（不占用原位置显示），relative相当于一个人拿着气球排队（仍占用原来的位置显示气球）。（气球是要显示的内容）。
absolue定位:（相对于页面）
绝对定位使块元素从HTML标准流中分离出来（脱离文档流），并把它送到一个完全属于自己的定位中。
使用绝对定位的DIV元素前面的或后面的元素会认为该DIV并不存在，丝毫不影响它们的布局。
在计算机显示中，把垂直于显示屏幕的方向称为Z方向，CSS绝对定位的z-index属性就对应这个方向，z-index的值越大，容器就越靠上。
简单地说，使用“position:absolute”后，元素就浮在网页上面了，因此，绝对定位常用于将一个元素放到固定位置。
EG:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #div1 { width: 455px; height: 200px; background-color: rgb(187, 255, 0); } #div2 { width: 455px; height: 200px; background-color: rgba(255, 59, 141, 0.685); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt;我是div1&lt;/div&gt; &lt;div id="div2"&gt;我是div2&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 给div2增加定位属性：div2的position属性设置为absolute时，就已经不再从属于父块body，其左边框相对于页面左边框的距离为80px,上边框距离页面上边框的距离为60px(这些都是通过left和top属性设置的)
position: absolute; top: 60px; left: 80px; 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c405cc711841e74ecc7040725578b0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33914d91fc75c4bac379b46e49ca9e0c/" rel="bookmark">
			tensorflow 一个矩阵与多个矩阵相乘时的计算方法（二维和三维张量相乘为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/lanlana168/article/details/81136907
tensor二维与三维如何相加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22fc71cdfe84f8b9f0f4a2d759ea1558/" rel="bookmark">
			Excel常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel常用函数 同一张工作表最多有256列（列、属性、字段、维度），最多有65536行（行、记录、数据）
Ctrl+多个工作表可形成工作组
保护单元格步骤： 取消整张工作表的锁定锁定要保护的单元格设置保护密码 相对引用与绝对引用：绝对引用前加$ 相对引用：随着拖动引用单元格位置会变化绝对引用：随着拖动引用单元格位置不会变化 count函数、countif函数、countifs函数countif(区间，“条件”) match函数返回某个标签所在位置（组合成行、列坐标） index函数可检索得到二维表中的数值 VLOOKUP(lookup_value,table_array,col_index_num,range_lookup)
参数简单说明输入数据类型lookup_value要查找的值数值、引用或文本字符串table_array要查找的区域数据表区域col_index_num返回数据在查找区域的第几列数正整数range_lookup模糊匹配/精确匹配TRUE（或不填）/FALSE HLOOKUP(lookup_value,table_array,row_index_num,range_lookup)
参数简单说明输入数据类型lookup_value要查找的值数值、引用或文本字符串table_array要查找的区域数据表区域row_index_num返回数据在区域的第几行数正整数range_lookup模糊匹配/精确匹配TRUE /FALSE（或不填） indirect函数：间接使用，引用，并显示其内容 =INDIRECT(ref_text,[a1])
=INDIRECT(“A1”)——加引号，文本引用——即引用A1单元格所在的文本（B2)
=INDIRECT(A1)——不加引号，地址引用——因为A1的值为B2，B2又=11，所以返回。
left函数：得到字符串左部指定个数的字符 LEFT( string, n )string ：必要参数。字符串表达式其中最左边的那些字符将被返回。如果 包含 Null，将返回 Null。n ：必要参数；为 Variant (Long)。数值表达式，指出将返回多少个字符。如果为 0，返回零长度字符串 ("")。如果大于或等于 string 的字符数，则返回整个字符串。 right函数：从字符串右端取指定个数字符 Right ( string, n ) mid函数：从一个字符串中截取出指定数量的字符 MID(text,start_num,num_chars) find函数：对原始数据中某个字符串进行定位 FIND(find_text,within_text,start_num)Find_text 是要查找的字符串Within_text 是包含要查找关键字的单元格Start_num 指定开始进行查找的字符数 len函数：返回文本串的字符数 substitute函数：替换指定的文本 SUBSTITUTE(text,old_text,new_text,[instance_num])Text 为需要替换其中字符的文本，或对含有文本的单元格的引用Old_text 为需要替换的旧文本New_text 用于替换 old_text 的文本Instance_num 为一数值，用来指定以 new_text 替换第几次出现的 old_text。如果指定了 instance_num，则只有满足要求的 old_text 被替换；如果缺省则将用 new_text 替换 TEXT 中出现的所有 old_text concatenate函数：可将最多 255 个文本字符串合并为一个文本字符串。联接项可以是文本、数字、单元格引用或这些项的组合 exact函数用于检测两个字符串是否完全相同，相同返回TRUE，不同返回False EXACT(text1,text2) 数据集中趋势描述： 算术平均数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22fc71cdfe84f8b9f0f4a2d759ea1558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c164d07fa93f07d2051ad98b73841e/" rel="bookmark">
			图像分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图割（Graph Cut） 1.在图割的例子中采用python-graph工具包，这里给出计算一副较小的图的最大流/最小割的简单例子：
代码：
from pygraph.classes.digraph import digraph from pygraph.algorithms.minmax import maximum_flow gr = digraph() gr.add_nodes([0,1,2,3]) gr.add_edge((0,1), wt=4) gr.add_edge((1,2), wt=3) gr.add_edge((2,3), wt=5) gr.add_edge((0,2), wt=3) gr.add_edge((1,3), wt=4) flows,cuts = maximum_flow(gr, 0, 3) print ('flow is:' , flows) print ('cut is:' , cuts) 运行结果：
最大流flow和最小割cut：
2.利用贝叶斯概率模型进行图割分割，图像降采样到54*38大小
代码：
# -*- coding: utf-8 -*- from scipy.misc import imresize from PCV.tools import graphcut from PIL import Image from numpy import * from pylab import * im = array(Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c164d07fa93f07d2051ad98b73841e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba55a0239794c4698233c13cbd775412/" rel="bookmark">
			Python对爬取51job详情进行数据清洗（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析与可视化地址：https://blog.csdn.net/weixin_43746433/article/details/91349199
1.查看数据，并对数据进行去重，去除任意的缺失值，提取关键字等操作
import pandas as pd import re def clean_data_quchong_key(): data=pd.read_csv('test_datasets.csv',delimiter='#',header=0) df=pd.DataFrame(data) print(df.shape) print(df.columns) print(df.head()) df=df.dropna()##去除有任意的缺失值 print(df.shape) #print(df.head()) print('去重之前形状',df.shape) df=df.drop_duplicates(subset='companyname')#去重 print('去重之后形状',df.shape) df=df[df[r'describe'].str.contains(r'.*?数据.*?|.*?分析.*?|.*?python.*?')]#提取包含数据或者分析的岗位 print('包含关键字',df.shape) #df=df.iloc[:,1]#提取包含数据或者分析的岗位 df.to_csv('test_datasets_cleaned1.csv',sep='#') #clean_data_quchong_key() 2.对文本内容（薪资，工作地点等）进行清洗
2.1查看数据
import pandas as pd data=pd.read_csv('test_datasets.csv',delimiter='#',header=0) df=pd.DataFrame(data) print(df.shape) df=df.loc[:,['salary','area']] print(df) 2.2对薪资（统一格式），地区（提取关键地址）数据清洗
def get_salary(salary): if '-' in salary: # 针对1-2万/月或者10-20万/年的情况，包含- low_salary = re.findall(re.compile('(\d*\.?\d+)'), salary)[0] high_salary = re.findall(re.compile('(\d?\.?\d+)'), salary)[1] if u'万' in salary and u'年' in salary: # 单位统一成千/月的形式 low_salary = float(low_salary) / 12 * 10 high_salary = float(high_salary) / 12 * 10 elif u'万' in salary and u'月' in salary: low_salary = float(low_salary) * 10 high_salary = float(high_salary) * 10 else: # 针对20万以上/年和100元/天这种情况，不包含-，取最低工资，没有最高工资 low_salary = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba55a0239794c4698233c13cbd775412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc99152474415051b0a3477159fcc67f/" rel="bookmark">
			Eigen学习与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Eigen是一个C++开源线性代数库，Eigen采用模板方式实现，由于模板函数不支持分离编译，所以只能提供源码而不是动态库的方式供用户使用。在使用时，只需引入Eigen的头文件，不需链接库文件（没有库文件）。
数组、矩阵和向量的表示
typedef Matrix&lt;Scalar, RowsAtCompileTime, ColsAtCompileTime, Options&gt; MyMatrixType; //矩阵 typedef Array&lt;Scalar, RowsAtCompileTime, ColsAtCompileTime, Options&gt; MyArrayType; //行列式 //Scalar为数据类型，如，float,double,bool,int... //RowATCompileTime为行数 //ColsAtCompileTime为列数 //Options为数据存储方式，分为按列存储（ColMajor）和按行存储（RowMajor），默认为按列存储 Eigen支持定义动态矩阵和静态矩阵：
Matrix&lt;double, 6, Dynamic&gt; // Dynamic number of columns (heap allocation) Matrix&lt;double, Dynamic, 2&gt; // Dynamic number of rows (heap allocation) Matrix&lt;double, Dynamic, Dynamic, RowMajor&gt; // Fully dynamic, row major (heap allocation) Matrix&lt;double, 13, 3&gt; // Fully fixed (usually allocated on stack) 在大多数情况下，矩阵和数组都有简单的表示方式：
Matrix&lt;float,Dynamic,Dynamic&gt; &lt;=&gt; MatrixXf Matrix&lt;double,Dynamic,1&gt; &lt;=&gt; VectorXd Matrix&lt;int,1,Dynamic&gt; &lt;=&gt; RowVectorXi Matrix&lt;float,3,3&gt; &lt;=&gt; Matrix3f Matrix&lt;float,4,1&gt; &lt;=&gt; Vector4f Array&lt;float,Dynamic,Dynamic&gt; &lt;=&gt; ArrayXXf Array&lt;double,Dynamic,1&gt; &lt;=&gt; ArrayXd Array&lt;int,1,Dynamic&gt; &lt;=&gt; RowArrayXi Array&lt;float,3,3&gt; &lt;=&gt; Array33f Array&lt;float,4,1&gt; &lt;=&gt; Array4f 访问和赋值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc99152474415051b0a3477159fcc67f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b8423dbfa92226e1cb9ca0742458aa/" rel="bookmark">
			Java-页面分页效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页模板 1、首先建立一个工具包msq.utils 新建两个类
NavigationTag.java
package msq.utils; import java.io.IOException; import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.jsp.JspException; import javax.servlet.jsp.JspWriter; import javax.servlet.jsp.tagext.TagSupport; /** * 显示格式：首页 上一页 1 2 3 4 5下一页 尾页 */ public class NavigationTag extends TagSupport { static final long serialVersionUID = 2372405317744358833L; private String bean = "page";//request 中用于保存Page&lt;E&gt; 对象的变量名,默认为“page” private String url = null;//分页跳转的url地址,此属性必须 private int number = 5;//显示页码数量	private int goPage = 1;//显示要跳转到的页码 @Override public int doStartTag() throws JspException {	JspWriter writer = pageContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13b8423dbfa92226e1cb9ca0742458aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e27ff66c0a86e5b093a0316e191b94/" rel="bookmark">
			Spring Cloud Consul同一个服务多个实例注册总是被覆盖的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Eureka宣告进入维护模式，所以抽空研究下Spring Cloud Consul做为服务注册中心。
此处不再赘述Consul原理、安装、使用等步骤，具体可以在网络查询，详细教程到处都是。主要描述下问题和解决方式：
问题描述 新建了一个微服务 service-a，从ip为【192.168.1.10】的机器启动，查看Consul一切正常，不关闭当前服务，再从ip为【192.18.1.20】的机器启动一个实例，查看Consul发现原来的注册实例还是只有一个，服务实例的ip地址被覆盖了；
分析解决 服务注册时，Consul是通过【instance-id】来区分服务实例的，出现服务实例注册被覆盖的情况，很有可能是因为多个实例【instance-id】重复导致。跟踪下源码，发现该字段默认是通过【application name】+ 【port】组成，所以服务注册会被覆盖；
解决方法1 通过查询官方文档，给出了解决方案：
By default a consul instance is registered with an ID that is equal to its Spring Application Context ID. By default, the Spring Application Context ID is s p r i n g . a p p l i c a t i o n . n a m e : c o m m a , s e p a r a t e d , p r o f i l e s : {spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e27ff66c0a86e5b093a0316e191b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac4ac880d193ff80a563fc556e707bc/" rel="bookmark">
			八个开源的 Spring Boot 学习资源，你值得拥有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自
牧马小子 Spring Boot 算是目前 Java 领域最火的技术栈了，松哥年初出版的 《Spring Boot + Vue 全栈开发实战》迄今为止已经加印了 3 次，Spring Boot 的受欢迎程度可见一斑。经常有人问松哥有没有推荐的 Spring Boot 学习资料？当然有！买松哥书就对了，哈哈。除了书呢？当然就是开源项目了，今天松哥整理了几个优质 Spring Boot 开源项目给大家参考，希望能够帮助到正在学习 Spring Boot 的小伙伴！
spring-boot-examples •star 数 14821•项目地址：https://github.com/ityouknow/spring-boot-examples
这个项目中整合了 Spring Boot 使用的各种示例，以最简单、最实用为标准，此开源项目中的每个示例都以最小依赖，最简单为标准，帮助初学者快速掌握 Spring Boot 各组件的使用。基本上涉及到了 Spring Boot 使用的方方面面。
项目部分 demo 截图：
微人事 •star 数 3333•项目地址：https://github.com/lenve/vhr
微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。
项目效果图:
项目部分文档截图：
mall •star 数 12668•项目地址：https://github.com/macrozheng/mall
mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 Spring Boot + MyBatis 实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac4ac880d193ff80a563fc556e707bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4bda1bd05999f5d70701044db1c4c9/" rel="bookmark">
			django form表单渲染和验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django form表单渲染和验证 一、Form常用字段与插件1.initial 初始值，input框里面的初始值。2.error_messages 重写错误信息3.password 设置输入框为密码类型4.radioSelect 单选框，值为字符串5.单选Select6.多选Select7.单选checkbox8.多选checkbox9.date类型10.choice字段注意事项 二、Form所有内置字段三、字段校验四、钩子方法五、form表单渲染样式1.批量添加样式 六、ModelForm基本七、ModelForm验证save()方法 导入表单
from django import forms
一、Form常用字段与插件 1.initial 初始值，input框里面的初始值。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label="用户名", initial="张三" # 设置默认值 ) pwd = forms.CharField(min_length=6, label="密码") 2.error_messages 重写错误信息 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label="用户名", initial="张三", error_messages={ "required": "不能为空", "invalid": "格式错误", "min_length": "用户名最短8位" } ) 3.password 设置输入框为密码类型 class LoginForm(forms.Form): ... pwd = forms.CharField( min_length=6, label="密码", widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True) #这个密码字段和其他字段不一样，默认在前端输入数据错误的时候，点击提交之后，默认是不保存的原来数据的，但是可以通过这个render_value=True让这个字段在前端保留用户输入的数据 ) 4.radioSelect 单选框，值为字符串 class LoginForm(forms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4bda1bd05999f5d70701044db1c4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce00cc077d94f01f4000a16a329924fa/" rel="bookmark">
			SG ：一个简单的PHP语法糖扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇技指南
语法糖往往给程序员提供了更实用的编码方式，可以使代码更简洁流畅，语义更自然。本文介绍笔者自己写的PHP语法糖扩展，扩展了一种全新的PHP超全局变量获取方式。
本文作者范家鹏，360技术委员会--WEB服务端分TC委员。
说说语法糖
首先说说“语法糖”这个词绝非贬义词，它可以给我们的开发工作带来便利，是一种轻量级便捷的写法，既不会对语言本身的使用造成不利影响，也不会在性能上带来损失。
通常情况下，使用语法糖能够增加程序的可读性，减少程序复杂性，减少编码中出错的机会，也对开发工程师具有友好性，能够提升我们的开发效率。 优秀的语法糖，应该是一种灵魂思想的注入，简单写法的应用。我这里用一幅图来表示：
什么是SG？
SG 全称 Superglobals，引用全局作用域中可用的全部变量。SG扩展了一种全新的PHP超全局变量获取方式。 这些超全局变量是：_SERVER，_GET，_POST，_FILES，_COOKIE，_SESSION，_REQUEST，_ENV。 当然了，也可以应用到自定义变量场景。
非常重要的一点是：它很简单！
项目背景
这个idea出发点很简单，从扩展名称我们应该能猜到它是做什么的。
在性能最优的前提下： 能通俗易懂地简化HTTP参数获取方法
需要对HTTP参数值进行统一过滤、转换、解密操作
获取HTTP参数前，需要进行一些Predefined Operation
针对HTTP参数的一切行为，需要同步更新对应的PHP Superglobal
声明时才使用，而非请求一开始就对PHP Superglobals扫荡式处理
在global语法上，扩展一项能获取HTTP参数的能力
So，SG出现就是为了解决上面这些问题而来，它提供了一种更加甜蜜的语法，当前已经发布了v3.0.0。
项目地址
https://github.com/yulonghu/sg 欢迎大家来提交Issues~
当前支持的PHP版本，如下图所示：
SG的特性
简单，快速，轻量 零拷贝访问PHP超全局变量，使用SG会同步更新PHP超全局变量 支持取值前调用自定义函数，默认情况下，字符串变量会自动调用 PHP trim 解决使用PHP超全局变量时出现未定义系列的问题 (Undefined variable, Undefinedoffset) 采用静态方法时，以小数点代替PHP数组维度 采用global声明方式时，以下划线代替PHP数组维度
支持可配置的global $variable查找深度，默认一级查找
配置项(php.ini)
Hash Map
流程图
global 声明方式（PHP7）
函数方式
API
global 声明方式
静态方法
例子
global 声明例子
sg.global_level = 1
以上例子输出的结果：
sg.global_level = 0
以上例子输出的结果：
sg.func_name
以上例子输出的结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce00cc077d94f01f4000a16a329924fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034690a8ae78d47dd7dd9becebf2230a/" rel="bookmark">
			职业发展能力图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		得到薛毅然老师的课程“怎样找准你的职业路线”中提到了职业发展能力图谱。
主要分为四个级别，由低到高分别为：
第一级别（职场小白）：高质量的完成任务的执行力，呈现出可培养的潜质；
第二级别（独当一面）：在工作领域具有绝对的专业优势（专家路线）；具备专业能力，同时具备组织协调能力（管理路线）；
第三级别（准高手）：分析问题、能创造性地解决问题，形成一套打法和方法论，围绕目标进行团队管理；
第四级别（高手）：前瞻性战略思考，业务布局与资源整合。
我认为，老师所讲的职场小白、独当一面、准高手、高手这四个层级，虽然解读时描述语言一般，但是每一个词、每一个场景我觉得都是作者多年经验的提炼和总结。在职场中，我大概执导过30多个人，有还在上学的实习生、也有刚毕业的应届生、也有工作过一段时间的社招人员，更有起初比我强的同事。整体上感受还比较深刻，基本上各类人都接触过。
对于新人来说，不管是什么级别的人员（特招的高水平人员除外），最开始基本上都是从基础工作开始的，因为彼此还不信任，能力还未被认可，这个阶段一定要把握住，重点是强执行能力的塑造和自我潜质的挖掘。过了这个阶段之后，就进入了第二个阶段，这时候的员工已经被证明具备高执行能力和优秀潜质，我们通过有挑战性的任务和项目不断培养和历练员工，逐渐的他就可以胜任某一方面工作，甚至个别员工还超出了之前的设想；这时候，不管是专业能力还是综合能力，这种员工都会被认为是团队中的佼佼者。后面两个暂且不论，因为离大多数的人都比较远。我认为在很多团队中，不少人还处在第一阶段，个别人进入了第二阶段，进入三、四阶段的人更是凤毛麟角。
给大家一个简单的评估办法，验证是否具备了独当一面的能力，我觉得非常容易。你只需要设想，如果目前你所在的团队中技术能力最强的几个人不给予你指导，或者仅仅提供些许指导，你能否有能力独立完成相对有挑战的任务；又或者说某一天某个核心员工突然离职，机会留给了你，你能否支撑起来。如果你能撑起那边天，那么恭喜你；如果不能，那还是该干嘛干嘛，踏踏实实做事吧，提高自己，积累经验，持续学习，挖掘自我。如果你还不理解，那么以你技术经理（技术组长）或者组内专家为目标，描述下他具备的能力图谱，对照下自己具备的能力图谱，朝着他们具备的那个目标前进。
总之，工作就是如此，需要脚踏实地、一步一个脚印的前进，职场小白是每个人的必经阶段，独当一面是我们的最低目标，终究你得向着准高手和高手前进，从更高的层面去处理和解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ddc17236372a8b02076043136eeea0/" rel="bookmark">
			LeNet-5卷积神经网络---MINIST手写体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeNet-5卷积神经网络 本次实验中，LeNet输入图像的尺寸统一归一化为3232，卷积使用1步长。
第一层卷积层：利用卷积核尺寸为5×5，形成6个特征图谱，每个特征图谱内参数共享，即每个特征图谱内只使用一个共同卷积核，卷积核有5x5个连接参数加上1个偏置共26个参数。卷积区域每次滑动一个像素，这样卷积层形成的每个特征图谱大小是(32-5)/1+1=28x28。第一层共有26x6=156个训练参数，有(5x5+1)x28x28x6=122304个连接。
第二层池化层：经过第一层卷积之后，卷积特征大小为2828。池化层用2x2大小的模板做最大池化，这样池化后得到6个1414大小的特征。（第二层这个pooling层是对第一层中的22区域内的像素求和乘以一个权值系数再加上一个偏置，然后将这个结果再做一次映射于是每个池化核有两个训练参数，所以共有2x6=12个训练参数，但是有5x14x14x6=5880个连接）
第三层卷积层：与第一层一样，卷积核大小也为5×5，是为了构建一个更深的网络，把几个类似的堆叠起来，不同的是第三层的每个节点与第二层中的多个图相连。第三层有16个10x10（14-5+1）的图。前3个图相连的卷积结构见下图，这种不对称的组合连接的方式有利于提取多种组合特征。该层有(5x5x3+1)x6 + (5x5x4 + 1) x 3 + (5x5x4 +1)x6 + (5x5x6+1)x1 = 1516个训练参数，共有1516x10x10=151600个连接。
第三层与第二层前三个图的连接方式：
第四层池化层：第三次层的16个10x10的图分别进行以2x2为单位的下抽样得到16个5x5的图。5x5x5x16=2000个连接。
第五次全连接层：加入一个有1024个神经元的全连接层，用于处理整个图片。我们把池化层输出的张量展开成一些向量，乘上权重矩阵，加上偏置，然后对其使用relu函数激活。由于第四层的16个图的大小为5x5，与卷积核的大小相同，所以卷积后形成的图的大小为1x1。这里形成120个卷积结果。每个都与上一层的16个图相连。所以共有(5x5x16+1)x120 = 48120个参数，同样有48120个连接。
第六层全连接层：第六层全连接层有84个feature map，每个feature map只有一个神经元与第五层全相连。第六层有84个节点，对应于一个7x12的比特图，该层的训练参数和连接数都是(120 + 1)x84=10164。
第七层：Output层，也是全连接层，共有10个节点，分别代表数字0到9，如果节点i的输出值为0，则网络识别的结果是数字i。采用的是径向基函数（RBF）的网络连接方式。假设x是上一层的输入，y是RBF的输出，则RBF输出的计算方式是：
yi的值由i的比特图编码（即参数Wij）确定。yi越接近于0，则标明输入越接近于i的比特图编码，表示当前网络输入的识别结果是字符i。该层有84x10=840个设定的参数和连接。连接的方式如上图。
卷积核的个数是自己设定的，可以增加卷积核数目提高分类精度，但是那样会增加更大参数，提高计算成本。
下图为LeNet-5识别数字3的过程：
MINIST手写数字图像识别 参数设置：
训练过程：
正确率：
测试结果：
运行过程要注意的地方：
1.要把图像进行灰度化变成8位，否则会出现以下错误
2.字体应尽量加粗，否则会识别出错：
细笔：有一半以上都会识别错误，如下图
粗笔：即使是虚线画出的数字，都可以正确识别
说明加粗可以更容易提取图像的特征，使数字更易识别。
3.学习率应在0.01-0.05之间为佳，下面是学习率为0.2时训练的过程：
正确率比 0.02时低很多。
LaNet-5的局限性 ：CNN能够得出原始图像的有效表征，这使得CNN能够直接从原始像素中，经过极少的预处理，识别视觉上面的规律。然而，由于当时缺乏大规模训练数据，计算机的计算能力也跟不上，LeNet-5 对于复杂问题的处理结果并不理想。
附代码：
训练代码：
# -*- coding: utf-8 -*- """ Created on Thu Oct 25 10:58:13 2018 @author: lenovo """ import os import numpy as np import tensorflow as tf from tensorflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3ddc17236372a8b02076043136eeea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177c443a14e90e943add56d772e1f5d0/" rel="bookmark">
			JS处理json数据的方法总结，包括增、删、改、查、合并、去重的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先定义一个json对象如下：
var student = [ {name:"an",age:12}, {name:"bn",age:13}, {name:"cn",age:14}, {name:"dn",age:15} ]; var a = [ {name:"tina",age:14}, {name:"timo",age:15}, {name:"lily",age:16}, {name:"lucy",age:16} ]; var b = [ {name:"aaa",age:8}, {name:"bbb",age:9}, {name:"lily",age:16}, {name:"lucy",age:16} ]; 二、处理方法：
1、向其中的一个json数据加入一个对象，使用push()方法，我以数组student为例子：
student.push({name:"en",age:16}); console.log(JSON.stringify(student));//输出查看结果 2、向其中的一个json数据删除一个对象，使用splice()方法，我以数组student为例子：
//删除 name 等于 an 的对象 //1. 首先我们要得到这个对象 var filter = persons.filter((item) =&gt; { return item.name == "an"; }); //2. 其次得到这个对象在数组中对应的索引 var index = student.indexOf(filter[0]); //3. 如果存在则将其删除，index &gt; -1 代表存在 index &gt; -1 &amp;&amp; student.splice(index, 1); //打印结果: console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177c443a14e90e943add56d772e1f5d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013733930a2ccb5fc83c3ee0a64e6936/" rel="bookmark">
			MVC简单的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC简单的增删改查 最近的学习了一下mvc，现在做一个mvc的CRUD例子。
1、创建实体模型
2、创建一个UserInfo的控制器
3、查询数据 public IList&lt;UserInfo&gt; userInfoList { get; set; } DemoEntities demoEntities = new DemoEntities();//创建EF上下文 public ActionResult Index() { userInfoList = demoEntities.Set&lt;UserInfo&gt;().ToList(); ViewBag.userInfoList = userInfoList; return View(); } view @{ Layout = null; } @using MVCCRUDAPI.Models; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;Index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名&lt;/td&gt;&lt;td&gt;密码&lt;/td&gt;&lt;td&gt;年龄&lt;/td&gt;&lt;td&gt;邮箱&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;td&gt;添加时间&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt; @foreach (UserInfo userInfo in ViewBag.userInfoList) { &lt;tr&gt;&lt;td&gt;@userInfo.UserName&lt;/td&gt;&lt;td&gt;@userInfo.UserPwd&lt;/td&gt;&lt;td&gt;@userInfo.Age&lt;td&gt;@userInfo.Email&lt;/td&gt;&lt;td&gt;@userInfo.Remark&lt;/td&gt;&lt;td&gt;@userInfo.RegTime&lt;/td&gt;&lt;td&gt;&lt;a href="/UserInfo/Edit/@userInfo.Id"&gt;编辑&lt;/a&gt; &lt;a href="javascript:void(0)" onclick="del(@userInfo.Id)"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt; } &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 数据显示
3、添加数据 code public ActionResult Add() { return View(); } [HttpPost] public ActionResult Add(UserInfo userInfo) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013733930a2ccb5fc83c3ee0a64e6936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1f4bb6578ffd4e0551f0fd4ebd8ca0/" rel="bookmark">
			C语言实现雅可比迭代（计算方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 double A[MAX][MAX]; double b[MAX]; double X[MAX]; double Y[MAX]; double X0[MAX]; int NUM; double epsilon=1e-5; void Input_Matrix()//输入矩阵 { int i,j; printf("系数矩阵A的阶数:\n"); scanf("%d",&amp;NUM); for(i=1; i&lt;=NUM; i++) { printf("系数矩阵A的第%d行元素:\n",i); for(j=1; j&lt;=NUM; j++) scanf("%lf",&amp;A[i-1][j-1]); } printf("右端项b:\n"); for(i=1; i&lt;=NUM; i++) { scanf("%lf",&amp;b[i-1]); } printf("输入的系数矩阵A:\n"); for(i=0; i&lt;NUM; i++) { for(j=0; j&lt;NUM; j++) printf("%.4lf\t",A[i][j]); printf("\n"); } printf("输入的右端项b:\n"); for(i=0; i&lt;NUM; i++) printf("%.4lf\n",b[i]); printf("\n"); printf("输入初值X0:\n"); for(i=1; i&lt;=NUM; i++) { scanf("%lf",&amp;X0[i-1]); } } double NF2() { int i; double z,sum1=0; for(i=0; i&lt;NUM; i++) { sum1+=pow(Y[i]-X[i],2); } z=sqrt(sum1); return z; } int main() { int i,j; double sum; Input_Matrix(); //雅可比迭代法 for(i=0; i&lt;NUM; i++) { Y[i]=X0[i]; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1f4bb6578ffd4e0551f0fd4ebd8ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638d314081081ee72d0af85701423a2a/" rel="bookmark">
			C语言实现高斯消去法（计算方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现高斯消去法（数学实验）
代码如下 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 double A[MAX][MAX]; double b[MAX]; double X[MAX]; int NUM; void Input_Matrix()//输入矩阵 { int i,j; printf("系数矩阵A的阶数:\n"); scanf("%d",&amp;NUM); for(i=1; i&lt;=NUM; i++) { printf("系数矩阵A的第%d行元素:\n",i); for(j=1; j&lt;=NUM; j++) scanf("%lf",&amp;A[i-1][j-1]); } printf("右端项b:\n"); for(i=1; i&lt;=NUM; i++) { scanf("%lf",&amp;b[i-1]); } printf("输入的系数矩阵A:\n"); for(i=0; i&lt;NUM; i++) { for(j=0; j&lt;NUM; j++) printf("%.4lf\t",A[i][j]); printf("\n"); } printf("输入的右端项b:\n"); for(i=0; i&lt;NUM; i++) printf("%.4lf\n",b[i]); } int main() { int i,j,k; float mik;//消元过程所用变量 float S;//回代过程所用变量 Input_Matrix(); //消元 for(k=0; k&lt;NUM-1; k++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638d314081081ee72d0af85701423a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a85707b72181e9b598f7fc25f0a2f64/" rel="bookmark">
			C&#43;&#43; list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list是C++标准模版库(STL,Standard Template Library)中的部分内容。实际上,list容器就是一个双向链表,可以高效地进行插入删除元素，但是随机访问却比较慢。list不支持随机存取，要访问第n个元素，必须先遍历前n-1个元素才能访问第n个元素。因此，list没有下标[ ]操作，也没有at()接口。
初始化：
list&lt;int&gt; test; 用法：
test.assign() 给list赋值 test.back() 返回最后一个元素 test.begin() 返回指向第一个元素的迭代器 test.clear() 删除所有元素 test.empty() 如果list是空的则返回true test.end() 返回末尾的迭代器 test.erase() 删除一个元素 test.front() 返回第一个元素 test.get_allocator() 返回list的配置器 test.insert() 插入一个元素到list中 test.max_size() 返回list能容纳的最大元素数量 test.merge() 合并两个list test.pop_back() 删除最后一个元素 test.pop_front() 删除第一个元素 test.push_back() 在list的末尾添加一个元素 test.push_front() 在list的头部添加一个元素 test.rbegin() 返回指向第一个元素的逆向迭代器 test.remove() 从list删除元素 test.remove_if() 按指定条件删除元素 test.rend() 指向list末尾的逆向迭代器 test.resize() 改变list的大小 test.reverse() 把list的元素倒转 test.size() 返回list中的元素个数 test.sort() 给list排序 test.splice() 合并两个list test.swap() 交换两个list test.unique() 删除list中重复的元素 与vector比较
vector 相当于一个数组 在内存中分配一块连续的内存空间进行存储，支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。 优点：(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back() (2) 随机访问方便，即支持[ ]操作符和vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a85707b72181e9b598f7fc25f0a2f64/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/424/">«</a>
	<span class="pagination__item pagination__item--current">425/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/426/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>