<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45fd3520b565c1edee26fc6b431a5008/" rel="bookmark">
			java实现对excel文件的处理合并单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jxl 一、依赖引入二、表格操作1、读取xls文件 一、依赖引入 &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jexcelapi&lt;/groupId&gt; &lt;artifactId&gt;jxl&lt;/artifactId&gt; &lt;version&gt;2.6.12&lt;/version&gt; &lt;/dependency&gt; 二、表格操作 1、读取xls文件 测试文件为：
代码：
public void test() throws IOException, BiffException { // 1、获取文件,创建workbook File file = new File("D:/test/自动化监测数据上传模板20210525.xls"); Workbook workbook = Workbook.getWorkbook(file); // 2.获取第一个工作表 Sheet sheet = workbook.getSheet(0); // 3.获取表中数据 Range[] rangecell = sheet.getMergedCells(); System.out.println("行：" + sheet.getRows()); System.out.println("列：" + sheet.getColumns()); for (int i = 0; i &lt; sheet.getRows(); i++) { for (int j = 0; j &lt; sheet.getColumns(); j++) { Cell cell = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45fd3520b565c1edee26fc6b431a5008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0849d6ad1de916bdb1aeff8f73dbe6/" rel="bookmark">
			计算机休眠后黑屏打不开,电脑待机后黑屏打不开怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们一般在没有使用电脑的时候，都会设置电脑待机，但是当再次唤醒的时候却发现打不开电脑了，下面由学习啦小编为你整理了电脑待机后黑屏打不开怎么办的解决方法，希望对你有帮助!
电脑待机后黑屏打不开解决方法如下
出现这种问题的电脑不多，可能是你的电脑中毒了，可以重装下合适的系统。(如果太麻烦，以下介绍修改电脑本身方法的步骤)
首先点开电脑“开始”键，找到“控制面板”，打开
找到”控制面板“里面的”硬件和声音“，点击进去
找到”电源选项“里面的”更改计算机睡眠时间“，点击进去
把里面界面框的”关闭显示器“和”使计算机进入睡眠状态“通过旁边的小三角都修改成”从不“，记得修改后，要点击下面的”保存修改“
完成后界面会自动弹到下面界面，我们可以检查一下是否修改成功，分别点击”平衡“和高性能”后面的“更改计划设置”
看下里面的“关闭显示器”和“使计算机进入睡眠状态”是否是“从不”如果不是，再进行修改，如果是“从不”退出即可
以上方法其实际是把“离开后电脑黑屏”这点把电脑修改成“从不睡眠”，小编用上面方法已经解决了这个问题
猜你喜欢：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e0f6f0bca695da764778b00782b7f4/" rel="bookmark">
			如何查看有关计算机系统类型,win10查看系统启动类型的三种办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10查看系统启动类型的三种办法？
win10系统有两中启动模式，一种是我们都比较知道的BIos启动，还有一种是比较新的UEFI启动。那么在win10系统中怎么查看电脑的启动类型呢？有三种办法，一起来看一下。
办法一：
1、在安装操作系统时，安装程序会收集一些必备信息，电脑的启动方式就是其中之一。在你的电脑C：\windows\Panther文件夹中找到setupact.log文件，用记事本点击，然后搜索Detected Boot Environment，在这里你就可以看到系统启动方式了。
办法二：
如果你知晓GPT与UEFI启动之间的关系，那么你大概熟悉，windows想要从GPT硬盘引导，就必须以UEFI方式启动(反之则不成立)。在磁盘管理中看一下硬盘类型，如果是GPT，那么电脑肯定就是UEFI启动了。点击磁盘管理，在主硬盘上右键单击，如果出现“转换成GPT磁盘”，那说明硬盘为MBR类型;如果出现“转换成MBR磁盘”则说明硬盘为GPT类型(由于是主硬盘，这一项是灰色不可用状态)。
办法三：
按win+R点击运行，写入msinfo32，回车查看系统信息。在BIos模式中如果显示“传统”，表示系统启动方式为Legacy BIos;如果为UEFI，则显示UEFI。
以上就是win10查看系统启动类型的三种办法了，这三种办法都能够查看win10的启动类型，当然同一台计算机三个办法查到的结果是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7aaa29d52af9c011b74f4b278e051fb/" rel="bookmark">
			RTK如何实现动态相对定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTKLIB提供了开源软件rtknavi.exe软件，代码应该也是开源的尚未找到使用方法，rtk实现方法是移动站通过网络获取基站提供差分改正数，进行数据改正，获得厘米级别精度。
遇到问题1：动态相对定位和实时动态相对定位的差别，一个是后处理，一个是实时，如何实现实时，和后处理方法在模糊度固定上有何不同。
下面是关于rtknavi.exe软件的使用方法链接：
通过联网+软件方式，来获取差分解哦。这里以使用千寻位置的产品服务为例。
(一) 安装
https://github.com/tomojitakasu/RTKLIB_bin/archive/rtklib_2.4.3.zip 开目录RTKLIB\bin下的 rtknavi.exe应用程序
1） 勾选Rover和Base Station。
其中，Rover配置的Type格式，根据能输出原始观测值的设备来定，这个设备一定是要能吐出原始观测值的哟。这个设备采取哪种格式，具体见生产厂商的说明。
Base Station 的Type选择NTRIP Client。
Format均选择RTCM 3。
Transmit NMEA GPGGA to Base Station 选择Single Solution。
2） Rover参数设置
根据厂商针对该设备的说明填写。厂商决定它支持哪种格式。你再填哪种参数。
3） Base Station参数设置
相关参数：
NTRIP Caster Host：（RTD为：rtd.ntrip.qxwz.com；RTK为：rtk.ntrip.qxwz.com）
Port：8001
Mountpoint：RTCM32_GGB
这里的User-ID和Password可通过注册并认证官网用户后，进入管理中心-服务列表后生成获取。
不清楚的点这里：https://www.qxwz.com/help-document-differential-account-management.html#link-0
4） Options参数设置
主界面中，点击Options。
Setting1选项卡里，根据RTD和RTK选择不同Positioning Mode。RTD选择：DGPS/DGNSS，RTK选择：Kinematic。
底部根据收信需求，选择合适的GNSS信号源。一般全部选上。
这里需要注意一点：Options选项卡的Base Station，请务必选择“RTCM Antenna Position”
(三) Start运行
参数设置完毕后，点击Start。
等待几秒后，看到蓝色的DGPS，就说明差分解算成功。下面就是精准坐标啦。
（图为RTD定位的差分解算）
无法获得差分数据的几种情况：
1） 卫星信号数不足，无法差分。（柱状图里的一类颜色编号的彩色竖条数）
2） Rover离基准站位置太远（比如RTK10KM左右，RTD100KM左右）。
3） 上文中提到的选项错误。比如：Options里的Base Station，没有选择“RTCM Antenna Position”； Positioning Mode没有选择对应的选项 等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7aaa29d52af9c011b74f4b278e051fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b62a727045f23f51179b170b3977ba/" rel="bookmark">
			latex报错： Runaway argument? ! File ended while scanning use of.....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Runaway argument?
! File ended while scanning use of xxx.
遇到这种情况，找到文件所在文件夹，删除.aux文件，重新编译即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc0a90a303c0e6ac05d53679850c24d/" rel="bookmark">
			什么是ajax？ajax详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来聊一聊前后端交互的重要工具AJAX
1. AJAX - 到底什么是Ajax?
ajax 全名 async javascript and XML(异步JavaScript和XML)
是前后台交互的能⼒ 也就是我们客户端给服务端发送消息的⼯具，以及接受响应的⼯具
AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。
是⼀个 默认异步执⾏机制的功能,AJAX分为同步（async = false）和异步（async = true）
- 什么是同步请求？(false)
同步请求是指当前发出请求后，浏览器什么都不能做， 必须得等到请求完成返回数据之后，才会执行后续的代码， 相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。 也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态， 当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态 - 什么是异步请求？(默认:true)
默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事， Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。 一般默认值为true，异步。异步请求可以完全不影响用户的体验效果， 无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。 2. AJAX 的优势 不需要插件的⽀持，原⽣ js 就可以使⽤⽤户体验好（不需要刷新⻚⾯就可以更新数据）减轻服务端和带宽的负担缺点：搜索引擎的⽀持度不够，因为数据都不在⻚⾯上，搜索引擎搜索不到 3. AJAX 的操作流程 具体操作流程：
首先通过PHP页面将数据库中的数据取出取出后转成json格式的字符串，后利用ajax把字符串返还给前台再利用json.parse解析通过循环添加到页面上那么反之，前端的数据可以利用ajax提交到后台但是后台是没有办法直接把这些数据插入到数据库中，所以要先提交到PHP页面上最后再由PHP将数据插入到数据库中 4. AJAX 的使用 在 js 中有内置的构造函数来创建 ajax 对象
创建 ajax 对象以后，我们就使⽤ ajax 对象的⽅法去发送请求和接受响应
Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。
XMLHttpRequest 对象方法描述
1.创建⼀个 ajax 对象
// IE9及以上 const xhr = new XMLHttpRequest() // IE9以下 const xhr = new ActiveXObject('Mricosoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc0a90a303c0e6ac05d53679850c24d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4769e0a10f2aeb203ec6fb5fb758d975/" rel="bookmark">
			CMMI 1.3和2.0的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMMI 2.0预定开发基准视图的实践域，都是来自1.3的过程域。
CMMI DEV V2.0中有20个实践域，CMMI DEV V1.3中有22个过程域，V2.0的变化包括：
V2.0取消了原来的共用目标和共用实践，将其内容放入新增的两个过程域GOV和II中，GOV对管理层在改进中的职责提出了明确要求。
V2.0有些实践域保留了原来的名字，如CAR， CM，DAR，OT，PI，SAM等。
V2.0有些实践域对名字做了微调，如MC，PLAN，PAD，RSK，PQA等。
V2.0有些实践域是新增或者剥离出来的，如EST，PR，GOV，II等。
V2.0有些实践域则是由原来的多个PA合并而来，如MPM，RDM，VV。
CMMI DEV 2.0实践域与CMMI DEV V1.3过程域的映射关系如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e117ef8e17c44f85c7813625483108/" rel="bookmark">
			位图Bitmap（基于Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。
设计原则：
尽可能的最大化利用内存，极限挖掘、利用、发挥Java的性能。
设计思路：
使用long型数组来用作存储，
故位图Bitmap类的大小size使用long型（int型不够极限），所以理论上0&lt;=size&lt;=2^63-1；
又Java数组的长度最长为2^31-1（即int型字面量最大值），所以long类型的数组最多可以存储64*(2^31-1)个点（以只有两种状态的点来计算，即1bit表示一个点的状态），所以Bitmap的size不可能大于64*(2^31-1)，故实际0&lt;=size&lt;=64*(2^31-1)；
再继续分析位图中每个点不可能只有两种状态，所以需要设计出来的Bitmap可以自定义点的状态数量state，即1&lt;state&lt;=2^63-1（大于1是因为状态不可能只有1种，只有一种的话使用位图就失去了意义，小于等于2^63-1是因为2^63-1是long型字面量最大值，没有比该值还要大的整数值，符合宗旨：探索挖掘Java的极限使用）;
此外自定义的点的状态数量需要使用多少位数来表示也是一个问题，自定义点的状态数量位数stateBitNum=（state的二进制表示的位数）
（
先做简单推导：
2种状态需要1bit，[0,1]
3~4种状态需要2bit，[00,01,10,11] 5~8种状态需要3bit，[000,001,010,011,100,101,110,111]
9~16种状态需要4bit，[...,...]
这里给出计算公式：stateBitNum=64 - Long.numberOfLeadingZeros(state - 1)；
Long.numberOfLeadingZeros(long i)方法是计算i的补码形式最高位的1的左面的0的数量，也就是补码中从左往右数0的个数，数到第一个非0的位置停止，0的数量即为该方法的返回值，举例：Long.numberOfLeadingZeros(2)=62，2的补码为10，故用64位补码（因为i是long型的）表示10前面还有62个0；因此64- Long.numberOfLeadingZeros(2)=2，而2种状态（state=2）其实只要用1位表示，所以state再传入该方法时要减一（因为0本身在计算机中就可以表示一种状态，比如8种状态可以用数字0~7来表示一样）；
再继续深挖会发现64位其实可以表示2^64种状态，但是Java的最大字面量值为2^63-1，所以最大状态数量state=2^63-1种状态需要63位保存，一个long型足以，这里还有一个坑Long.numberOfLeadingZeros(0)=64，但是我们在使用时不可能出现这种情况因为state最小为2，state-1最小为1，避免了这种情况；
至此结束！
）；
其余Bitmap的各种操作，实现时说明。
实现：
/** * 位图类： * 1.最多可以储存（2^37-2^6）个2种状态值的点; * 2.理论上有（2^37-2^6）个位空间，实际上可能不能完全使用（见无参构造器中的介绍）， * 故使用时所选的点的状态值种数（stateNum）最好满足 64% ⌈ log2(stateNum) ⌉ = 0，即stateNum的补码的位数正好是64的因数；（听不明白的话，自行体会） * 3.没有删除点的方法，只有增加，更新，查找操作；（问为什么没有删除方法的人不是脑子有病，就是脑子有病。。。） * 4.回答3中问题：首先不是实现不了，是没有必要，因为删除一个点需要在数组中通过移位来填充被删除的位置，由于数据量过大可能会极其浪费时间， * 而且位图本身存在的意义是表示海量数据中每一条数据的可能性，对于海量数据而言，出现极个别错误并不会影响其最终统计结果（对于偷跑，出错的数据仍然可以在下一层中进行重新过滤，要是听不懂就算了。。。）， * 这里建议使用update方法将不需要的点置0，用于表示该点被弃用，具体的逻辑需要使用者自己去编辑； * 5.该类所花费的理论持久存储空间大约为260MB也就是elementData数组的大小的极限值，实际可能会多一点，但几乎可以忽略不计，最终实现存储2种状态值的点的数量大约20亿个， * 也可以自定义每个点的状态值种数stateNum和点的数量length最大可以设置成（2^63-1）个，但最终要满足 length &gt; ⌈ log2(stateNum) ⌉（向上取整） / 64 * Integer.MAX_VALUE， * 对于日常使用一定是足够的；（在这里，总有杠精会问超过了怎么办？就算是2种状态值的点有20亿个话，我还是不够用啊？） * 6.回答5中的问题：你不会搞个数组吗？你不能多new几个一起用吗！！！ */ public class Bitmap { /* *使用long型数组保存点 */ private final long[] elementData; /* * 位图中能存储的所有点的位数之和的最大值MAX_STATE_SIZE=137,438,953,408； * 64（MAX_STATE_SIZE=long类型的位数） * 0x7fffffff（int类型的最大值Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e117ef8e17c44f85c7813625483108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0871d3fbbd0da0bdcea8a1bca30450ec/" rel="bookmark">
			C#实现关机的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用shutdown关机命令来实现。
using System.Diagnostics; int time = 3600;　//单位为：秒 Process.Start("c:/windows/system32/shutdown.exe", "-s -t "+time); ShutDown用法及参数（XP）
用法: shutdown [-i | -l | -s | -r | -a] [-f] [-m computername] [-t xx] [-c “comment”] [-d up:xx:yy]
没有参数 显示此消息(与 ? 相同)
-i 显示 GUI 界面，必须是第一个选项
-l 注销(不能与选项 -m 一起使用)
-s 关闭此计算机
-r 关闭并重启动此计算机
-a 放弃系统关机
-m computername 远程计算机关机/重启动/放弃
-t xx 设置关闭的超时为 xx 秒
-c “comment” 关闭注释(最大 127 个字符)
-f 强制运行的应用程序关闭而没有警告
-d [ u ][p]:xx:yy 关闭原因代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0871d3fbbd0da0bdcea8a1bca30450ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5dd3916141feef1190dada720d91d38/" rel="bookmark">
			UE4 文件选择框OpenFileDialog在Shipping环境下崩溃报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**解决方案：**需要把依赖developer的三个模块（DesktopPlatform、DirectoryWatcher、SlateFileDialogs）源码拷贝到项目中，重新编译即可。
具体步骤：
新建一个Plugin
把developer路径（UE_4.26\Engine\Source\Developer）里的目录（DesktopPlatform、DirectoryWatcher、SlateFileDialogs）拷贝到Plugin的Source路径下
修改目录文件名为（MyDesktopPlatform、MyDirectoryWatcher、MySlateFileDialogs），对应的Build.cs也需要改名字
修改每个模块的Build.cs
Build.cs 里涉及到这三个库的路径和名称全改成“Myxxxxxx”，
MySlateFileDialogs:
public class MySlateFileDialogs : ModuleRules { public MySlateFileDialogs(ReadOnlyTargetRules Target) : base(Target) { PrivateDependencyModuleNames.AddRange( new string[] { "Core", "CoreUObject", "InputCore", "Slate", "SlateCore", "MyDirectoryWatcher", } ); PrivateIncludePaths.AddRange( new string[] { "MySlateFileDialogs/Private", } ); PrivateIncludePathModuleNames.Add("TargetPlatform"); } } MyDesktopPlatform:
public class MyDesktopPlatform : ModuleRules { public MyDesktopPlatform(ReadOnlyTargetRules Target) : base(Target) { PrivateIncludePaths.Add("MyDesktopPlatform/Private"); PrivateDependencyModuleNames.AddRange( new string[] { "Core", "ApplicationCore", "Json", } ); if (Target.IsInPlatformGroup(UnrealPlatformGroup.Linux)) { PrivateIncludePathModuleNames.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5dd3916141feef1190dada720d91d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c48a21ab6e9524488eb83d0bd194bd/" rel="bookmark">
			JavaScript 的 foreach 用不了 break/continue？同样写法下 for 循环也不行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 的 foreach 用不了 break/continue？同样写法下 for 循环也不行 今天在群里和群友一起探讨一个 JavaScript 异步问题的时候，就 foreach/map 函数进行了一番学习和讨论。当然，群友的侧重点还是在异步的实现方面。
对于我而言，更感兴趣的反而是数组这边为什么不能够使用 break/continue/return。这边这里就结合一下自己的理解，以及 MDN 上实现的 polyfill 去分析一下其中详情。
for循环 vs forEach 这里会简单的就 for循环 和 forEach 进行一下对比，输入和条件都是一样的。
for循环 正常情况下，大多数人是这样使用 for循环 的：
const arr = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); } 以上面的数组为例，它是一个升序数组，假设需求是只打印出 3 以下（包括 3）的所有数字，那么可以使用 break 关键词去跳出循环，达到提升性能的效果：
const arr = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c48a21ab6e9524488eb83d0bd194bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcb33e0c687bb8123710a144928859e/" rel="bookmark">
			odoo 前端css错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 odoo 前端报错信息 前端css错误信息,这个是缺少python libsass包导致 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d566e0f2dc9903d370528c27b5359f/" rel="bookmark">
			B树、B&#43;树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言，概念，定义2. B树实例讲解2.1 B树的插入操作2.2 B树的删除操作 3. 磁盘IO与预读4. B树的高度5. B+树6. B树和B+树比较 1. 前言，概念，定义 前言
首先，为什么要总结B树、B+树的知识呢？最近在学习数据库索引调优相关知识，数据库系统普遍采用B-/+Tree作为索引结构（例如mysql的InnoDB引擎使用的B+树），理解不透彻B树，则无法理解数据库的索引机制；接下来将用最简洁直白的内容来了解B树、B+树的数据结构
另外，B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种树。而事实上是，B-tree就是指的B树，目前理解B的意思为平衡
B树的出现是为了弥合不同的存储级别之间的访问速度上的巨大差异，实现高效的 I/O。平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。但是当数据量非常大，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况。B树是解决这个问题的很好的结构
概念
首先，B树不要和二叉树混淆，在计算机科学中，B树是一种自平衡树数据结构，它维护有序数据并允许以对数时间进行搜索，顺序访问，插入和删除。B树是二叉搜索树的一般化，因为节点可以有两个以上的子节点。[1]与其他自平衡二进制搜索树不同，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于数据库和文件系统。
定义
B树是一种平衡的多分树，通常我们说 m阶(B树中一个节点的子节点数目的最大值) 的B树，它必须满足如下条件：
每个节点最多只有m个子节点。每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。如果根不是叶节点，则根至少有两个子节点。具有k个子节点的非叶节点包含k -1个键。所有叶子都出现在同一水平，没有任何信息（高度一致）。 2. B树实例讲解 什么是B树的阶 ？
B树中一个节点的子节点数目的最大值，用m表示，假如最大值为10，则为10阶，如下图，所有节点中，节点【13,16,19】拥有的子节点数目最多，四个子节点（灰色节点），所以可以定义上面的图片为4阶B树。
什么是根节点 ？
节点【10】即为根节点，特征：根节点拥有的子节点数量的上限和内部节点相同，如果根节点不是树中唯一节点的话，至少有俩个子节点（不然就变成单支了）。在m阶B树中（根节点非树中唯一节点），那么有关系式2&lt;= M &lt;=m，M为子节点数量；包含的元素数量 1&lt;= K &lt;=m-1,K为元素数量。
什么是内部节点 ？
节点【13,16,19】、节点【3,6】都为内部节点，特征：内部节点是除叶子节点和根节点之外的所有节点，拥有父节点和子节点。假定m阶B树的内部节点的子节点数量为M，则一定要符合（m/2）&lt;= M &lt;=m关系式，包含元素数量M-1；包含的元素数量 （m/2）-1&lt;= K &lt;=m-1,K为元素数量。m/2向上取整。
什么是叶子节点？
节点【1,2】、节点【11,12】等最后一层都为叶子节点，叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。特征：在m阶B树中叶子节点的元素符合（m/2）-1&lt;= K &lt;=m-1。
2.1 B树的插入操作 针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。
若该节点元素个数小于m-1，直接插入；若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1； 上面三段话为插入动作的核心，接下来以5阶B树为例，详细讲解插入的动作；
5阶B树关键点:
2&lt;=根节点子节点个数&lt;=53&lt;=内节点子节点个数&lt;=51&lt;=根节点元素个数&lt;=42&lt;=非根节点元素个数&lt;=4 原本的B树 插入8 图（1）插入元素【8】后变为图（2），此时根节点元素个数为5，不符合 1&lt;=根节点元素个数&lt;=4，进行分裂（ 真实情况是先分裂，然后插入元素，这里是为了直观而先插入元素，下面的操作都一样，不再赘述），取节点中间元素【7】，加入到父节点，左右分裂为2个节点，如图（3）。 中间节点加入父节点，两边分裂为两个节点 插入【5】,【11】,【17】 插入【13】 节点元素超出最大数量，进行分裂，提取中间元素【13】，插入到父节点当中，如图（6） 接着插入元素【6】,【12】,【20】,【23】时,不需要任何分裂操作，如图（7） 插入【26】时，最右的叶子结点空间满了，需要进行分裂操作，中间元素【20】上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。 插入【4】时，导致最左边的叶子结点被分裂，【4】恰好也是中间元素，上移到父节点中，然后元素【16】,【18】,【24】,【25】陆续插入不需要任何分裂操作 最后，当插入【19】时，含有【14】,【16】,【17】,【18】的结点需要分裂，把中间元素【17】上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素【13】上移到新形成的根结点中，这样具体插入操作的完成。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d566e0f2dc9903d370528c27b5359f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b62bf7c2558752afd8cf0fbf90e0259/" rel="bookmark">
			计算机试题上网部分怎么做,考试经验之谈：计算机一级考试上网题怎么操作？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上网题一般是计算机一级考试的最后一题，很多人都反映不管怎么做，得分总是为0，导致这种现象很多都是因为操作不规范，下面就跟着小编一起来认真学一学如何正确操作吧！
计算机一级考试上网题怎么操作？
计算机一级考试上网题通过考试题型有两种，一种是Internet Explorer浏览器题型，另一种是Outlook Express电子邮件题型。
Internet Explorer浏览器题型操作一般如下所示：
1、打开IE浏览器，在地址栏输入题目要求的网址，按下回车键打开指定的网页。
2、点击按要求“在计算机上保存网页”执行【文件】|【另存为】命令，选择题目要求保存的位置。
3、填入需要保存的名称，单击“保存”按钮，保存为txt文本格式。
Outlook Express电子邮件题型操作一般如下所示：
1、点击 Outlook Express 电子邮件，(题目为给某人发送一份电子邮件)点击“创建新邮件”
2、在弹出的发送邮件对话框中输入相关内容。
3、点击“插入”“文件附件”，找到题目要求的文件即可。
点击“格式”中“ 编码”选中“简体中文(GB2312)”。
点击“格式”选中“多信息文本(HTML)”。
4、点击“发送”即可。
大致操作就是这样了，如果想知道更多详细的操作题型或者步骤，可以去上学吧计算机一级考试题库中去看看，里面包括很多的历年真题和详细的解答步骤，可以帮助你更加直观的了解计算机一级的题目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca476c71777c0865fc463f4e792b4e94/" rel="bookmark">
			同时输出多个方法的Top-K节点（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
该方法输出的为Top-K节点的索引（index），即若节点Id为1~n，则对应输出索引为0~n-1。
读者需要根据自己的实际应用进行调整或修改！
输入：“多方法排序.csv”文件对应的Dataframe
文件类型如下图
IdLRPRS1S2S310.6270.0076690.54050.60140.56120.6270.0076690.63120.65740.646230.6270.0076690.48010.55830.501740.72170.0098640.50010.59370.516850.68250.0089340.44610.52130.447960.72170.0098640.53380.6270.555570.72170.0098640.50010.59370.5168 输出：各个方法按照方法/指标值从大到小排序，选择前k的节点的索引构成Dataframe
代码 # 获得所需的top-k节点 def getTopK(methods, k): print('Top-' + str(k) + '节点生成中...') methods_name = np.array(methods.columns)[1: len(methods.columns)] print('文件中共有以下 ' + str(len(methods_name)) + ' 种方法') print(methods_name) df = pd.DataFrame(columns=methods_name) # 存储各个方法的top-k节点 # 循环每一个方法 for i in range(len(methods_name)): method = methods.iloc[:, i + 1] # 方法列 top_K = method.argsort()[::-1][0:k] # top-k,此处为索引号，与Id号差1 df[methods_name[i]] = top_K # 存储到dataframe return df 测试 from SIRTool import getTopK # 引入该方法 if __name__ == '__main__': methods = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca476c71777c0865fc463f4e792b4e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d4cc97da26a5e8056c7fbe730080e4/" rel="bookmark">
			基于已知点云地图的NDT的激光SLAM定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 对于L4级自动驾驶系统而言，定位模块通常会融合GNSS、IMU、轮速计（车辆底盘）、摄像头以及激光雷达odometry多种测量，使用滤波算法（EKF、UKF等）以获得平滑、厘米级别的绝对定位，其中基于高精度点云地图和激光雷达的配准定位（Lidar Odometry）因其精度高、可靠性好，在整个融合定位中通常占很大的权重，是自动驾驶定位系统中相对可靠的“绝对定位”数据来源。
依据网上已开源的算法框架以及各位大佬们的经验分享，本文demo为ROS系统下，基于建图算法（SC-LEGO-LOAM）+点云匹配算法（NDT）进行定位功能实现。
点云地图 自动驾驶汽车的激光雷达定位通常依赖于提前离线构建好的高精度点云地图，之所以这么做原因有以下几个方面：
L4级别以上自动驾驶系统对定位精度和稳定性要求很高，绝对误差需要控制在20cm以内；纯SLAM目前来说无法达到自动驾驶对于定位精度、可靠性的要求，即我们现在的研究很难实现自动驾驶车的在线制图和定位（问题包括闭环优化，全局优化，误差累计修正等等）高精度地图制造商的完整生产流程需要较大的算力和人工，他们能够生产非常理想的点云地图和语义地图，但是需要离线生产（时间和人力）；利用高精度地图可以相对简单地实现激光雷达定位，在融合了IMU和轮速计以后这类定位方法的精度和可靠性基本满足自动驾驶汽车定位的需求。 所以综合以上的客观原因，目前的L4和大部分L3自动驾驶系统定位模块仍然是以事先构建的高精度地图为基础进行的配准定位，这个配准使用的传感器，少数厂商使用的是camera(如mobileeye)，绝大多数厂商目前仍然采用的是激光雷达配准思路。
点云地图就是激光雷达配准所需事先构建的“用来定位的地图”。
我们使用了LEGO-LOAM和SC-LEGO-LOAM的算法分别进行了点云地图构建，对于面积较大的点云地图，明显采用Scan Context方法对点云地图进行闭环检测和姿态图优化后闭环效果更好，所以在这里采用SC-LEGO-LOAM构建的点云地图进行下一步的点云匹配定位。
将建好的地图放入map文件夹下项目中的map_loader节点主要用于载入地图：
MapLoader::MapLoader(ros::NodeHandle &amp;nh){ std::string pcd_file_path, map_topic; nh.param&lt;std::string&gt;("pcd_path", pcd_file_path, ""); nh.param&lt;std::string&gt;("map_topic", map_topic, "point_map"); init_tf_params(nh); pc_map_pub_ = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(map_topic, 10, true); file_list_.push_back(pcd_file_path); auto pc_msg = CreatePcd(); auto out_msg = TransformMap(pc_msg); if (out_msg.width != 0) { out_msg.header.frame_id = "map"; pc_map_pub_.publish(out_msg); } } 构造函数中读取pcd文件的路径和map topic，并且初始化map的变换参数（如果不需要对map进行变换，则数值都设置为０）
void MapLoader::init_tf_params(ros::NodeHandle &amp;nh){ nh.param&lt;float&gt;("x", tf_x_, 0.0); nh.param&lt;float&gt;("y", tf_y_, 0.0); nh.param&lt;float&gt;("z", tf_z_, 0.0); nh.param&lt;float&gt;("roll", tf_roll_, 0.0); nh.param&lt;float&gt;("pitch", tf_pitch_, 0.0); nh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d4cc97da26a5e8056c7fbe730080e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4268e09137c55519205b2bdae8de86/" rel="bookmark">
			复杂网络节点排序方法的评价-SIR传播曲线（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. SIR https://blog.csdn.net/weixin_40935887/article/details/114690294#SIR_1
2. SIR传播曲线 import networkx as nx import numpy as np import pandas as pd import matplotlib.pyplot as plt from matplotlib.pyplot import MultipleLocator from SIR import SIR_network # SIR参数设置 beta = 0.1 # 感染率 gamma = 0.5 # 免疫率 step = 20 # 迭代次数 markers = ['&lt;', '&gt;', '^', 'v', 'o', 's', 'D', '*', 'x', '+'] # plt marker大全 # 获得所需的top-k节点 def getTopK(methods, k): print('Top-' + str(k) + '节点生成中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4268e09137c55519205b2bdae8de86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a25b5a180e7fcae2ac454541ba3c68/" rel="bookmark">
			迅为-3399开发板QT系统-使用openssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH 协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如 telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh 都是极为不安全的，并且会使用明文传送密码。OpenSSH 提供了服务端后台程序和客户端工具，用来加密远程控件
和文件传输过程中的数据，并由此来代替原来的类似服务。
由于传统的 telne、rcp ftp 等工具是明文传输数据的，对数据安全性存在很大的安全隐患，而 OpenSSH可以对传输的数据进行加密从而大大提高了数据的安全性。
OpenSSH 的分为客户端和服务端两部分
 Clients 端的配置文件：/etc/ssh/ssh_config
 Server 端的配置文件：/etc/ssh/sshd_config
 Server 端服务脚本：/etc/rc.d/init.d/sshd
59.1 开发板作为服务端
如果我们想要通过 ssh 远程连接开发板，首先参考 7.7 MobaXterm 的安装教程章节安装 MobaXterm 软件。
59.1.1 ssh 使用
在串口终端查询开发板的 IP 地址，如下图所示：
打开 MobaXterm 软件，依次点击“会话”，“SSH”，如下图所示：
登录到开发板如下图所示：
59.1.2 sftp 使用
打开 MobaXterm 软件，依次点击“会话”，“SSH”，如下图所示：
输入密码“topeet”， 进入到传输文件界面如下图所示：
59.2 开发板作为客户端
59.2.1 ssh 使用
默认使用本地用户为远程登录时的用户；远程连接虚拟机里面的 Ubuntu（IP 地址为 192.168.1.20），如下图所示：
ssh 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a25b5a180e7fcae2ac454541ba3c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe17a9cb35c855519d18568295bf570/" rel="bookmark">
			selenium获取谷歌浏览器控制台信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapabilities # enable browser logging d = DesiredCapabilities.CHROME d['goog:loggingPrefs'] = { 'browser':'ALL' } driver = webdriver.Chrome(desired_capabilities=d) # load the desired webpage driver.get('http://foo.com') # print messages for entry in driver.get_log('browser'): print(entry) entry格式：
{'level': 'SEVERE', 'message': 'https://open.ccod.com/WARTC/cphoneRTC/verto-min.js 2086:28 "INVALID METHOD OR NON-EXISTANT CALL REFERENCE IGNORED" "verto.clientReady"', 'source': 'console-api', 'timestamp': 1626147049481}
其中source：
console-api 控制台日志network 网络日志 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f42fc75acb8c9b6ae1e1749260f163/" rel="bookmark">
			计算网络中节点的SIR值（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 SIR模型代码 复杂网络研究中的SIR传播模型（Python实现）_Morty的博客-CSDN博客
2 计算每个节点的SIR值 import networkx as nx import numpy as np import pandas as pd # 引入1中的SIR代码，也可直接复制粘贴到本代码中 from SIR import SIR_network if __name__ == '__main__': ''' 数据准备。更换为自己的数据文件！！！ ''' adj = np.loadtxt('data/adj.txt', dtype=np.int) # 网络的邻接矩阵 graph = nx.from_numpy_matrix(adj) # 网络图：默认无向图；nx.DiGraph(adj)为创建有向图 nodes_n = adj.shape[0] # 行数，节点数 print('共 ' + str(nodes_n) + ' 个节点！') ''' SIR传播 ''' dfSIR = pd.DataFrame(columns=['Id', 'SIR']) str_fm = "{0:^5}\t{1:^10}" # 格式化输出 print(str_fm.format("Id", "SIR")) # 循环所有节点 for j in range(nodes_n): node_id = j + 1 # 索引序列[0~n-1]，此处+1转回为Id # 由于SIR为概率模型，我们进行多次实验取平均值，实验次数可自行设置 n = 100 # 实验次数 sir_list = [] for k in range(n): # SIR参数设置，可自行设置 beta = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f42fc75acb8c9b6ae1e1749260f163/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/308/">«</a>
	<span class="pagination__item pagination__item--current">309/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/310/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>