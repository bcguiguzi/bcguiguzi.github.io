<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c25973b12a69f28b79759847b4f482b/" rel="bookmark">
			Flutter Dialog 之 ：CupertinoAlertDialog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 先看一个简单的例子2. showCupertinoDialog 参数说明：3. 使用 `conent` 参数4. 调节标题与内容部分间距5. 使用一个或多个 actions6. `CupertinoDialogAction` 参数说明 Flutter 的文档现在虽然是很健全了，但是不知道为什么对于 IOS 风格组件的文档还是那么的欠缺，当打开 CupertionAlertDialog 的官方文档 后竟然没有 demo 代码，但是 AlertDialog 的文档 就有简单的示例，这就非常的尴尬，估计 Google 是想推自己的 Material Design 风格吧。
正好在项目中要使用 IOS 风格的 CupertinoAlertDialog ，所以在这里整理下也方便大家的使用，使用起来也会比较的简单。
1. 先看一个简单的例子 import 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( home: DialogPage(), ); } } class DialogPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Demo'), ), body: Center( child: RaisedButton( onPressed: () { _showDialog(context); }, child: Text('点击显示弹窗'), ), ), ); } } void _showDialog(widgetContext) { showCupertinoDialog( context: widgetContext, builder: (context) { return CupertinoAlertDialog( title: Text('确认删除'), actions: [ CupertinoDialogAction( child: Text('确认'), onPressed: () { Navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c25973b12a69f28b79759847b4f482b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c264503b521cfa6c6452361d5e2eef/" rel="bookmark">
			Day52    树状数组   线段树（lazy标记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态求连续区间和
树状数组是利用lowbit的性质求前缀和
lowbit(x)= 2 k 2^{k} 2k,k的意思是x的二进制表达最后面有几位0
然后c[x]是对 [ x − 2 k , x ] [x-2^{k},x] [x−2k,x]范围内的q求和
然后修改，询问区间和都用到这个性质
#include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; #define lson (o&lt;&lt;1) #define rson (o&lt;&lt;1|1) #define fi first #define sc second #define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl; #define rg register typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; using namespace std; const double pi=acos(-1); const double eps=1e-6; inline int lowbit(int x){return x&amp;(-x);} template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){ A ans=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql; return ans; } inline int read() { int X=0,w=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if (c=='-') { w=-1; } c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48); c=getchar(); } return X*w; } //inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); } const int N=1e5+10; ll T; int q[N],c[N],n,m; #define lowbit(x) (x&amp;-x) void add(int a,int b){ for(int i=a;i&lt;=n;i+=lowbit(i)){ c[i]+=b; } } int getsum(int a){ int res=0; for(int i=a;i;i-=lowbit(i)){ res+=c[i]; } return res; } void solve(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;q[i]; add(i,q[i]); } int op,a,b; for(int i=0;i&lt;m;i++){ cin&gt;&gt;op&gt;&gt;a&gt;&gt;b; if(op==0){ cout&lt;&lt;getsum(b)-getsum(a-1)&lt;&lt;endl; }else { add(a,b); } } } int main(){ std::ios::sync_with_stdio(0); std::cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c264503b521cfa6c6452361d5e2eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a1cb11b3a8f454498a3d546ffb274f/" rel="bookmark">
			计算机网络（三十二）：习题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电路交换&amp;分组交换 考虑一个应用程序以稳定的速率传输数据（例如，发送方每 k 个时间单元产生一个 N 比特 的数据单元，其中 k 较小且固定）。另外，当这个应用程序启动时，他将连续运行相当长的 一段时间。回答下列问题：
a、是分组交换网还是电路交换网更为合适这种应用？
电路交换网，因为应用将以稳定速率，持续长时间运行，因此可以为其保留带宽，可保证应用程序以稳定的速率接收数据
b、假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序，此外， 假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗？为什么？
不需要，应用程序数据传输速率总和小于每条链路容量考虑两台主机 A 和 B 由一条速率为 Rbps 的链路连接，假定这两台主机相隔 m 米，该链路的传输速率为 s m/s 主机 A 向 B 发送长度为 L 比特的分组
a、用 m 和 s 来表示传播时延
因为传播时延是在连路上的时间，所以是距离/传输速度=m/s
b、用 L 和 R 来确定该分组的传输时间
分组传输时间=分组大小/链路速率=L/R
c、忽略处理和排队时延，得出端到端时延的表达式
端到端时延=分组处理时间+传播时延=L/R+m/s
d、假定主机 A 在时刻 t=0 开始传输该分组，在时刻 t=dtrans，该分组的最后一个比特在什 么地方？
dtrans时，最后一个比特刚刚离开主机A
e、假定 dprop 大于 dtrans，在时刻 dtrans，该分组的第一个比特在何处
dprop&gt;dtrans，代表第一个比特在链路上
f、假定 dprop 小于 dtrans，在时刻 dtrans，该分组的第一个比特在何处
已经到达主机B
g、假定 s=2.5x10^8，L=120 比特，R=56kbps，求出使 dprop 等于 dtrans 的距离 m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a1cb11b3a8f454498a3d546ffb274f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078c6b8c30b62032cb6ca4ea9b58fe3e/" rel="bookmark">
			Android P适配以太网功能开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android P适配以太网功能开发指南 Android网络框架分析系列文章目录：
Android P适配以太网功能开发指南
Android以太网框架情景分析之启动简介
Android以太网框架情景分析之EthernetServiceImpl和NetworkManagementService交互深入分析
Android以太网框架情景分析之NetworkManagementService和netd交互深入分析二
Android以太网框架情景分析之NetworkManagementService和netd交互深入分析一
Android以太网框架情景分析之NetworkFactory与NetworkAgent深入分析
AsyncChannel原理分析以及实操演练
引言 此时的我吃着火锅唱着歌，进行着Android P(此P非彼P，Android 9)的适配工作。我真的只能说每次Android版本的迭代更新，都是对我们的一次炼狱般的摧残啊，各种适配啊，我真的想说fuck the coding。但是吐槽归吐槽，为了我热爱的coding事业，让我们愉快的适配起来。
注意：本文演示的代码是Android P高通msm8953平台。
一.具体需求和成果展示 1.1 具体需求 具体需求说多不多，说少不少就三个如下：
设置中增加以太网开/关设置设置中增加以太网静态设置设置中增加代理设置 1.2 成果展示 好了需求前面明确了，在正式开始Android P以太网适配的开发指南前，得先让大伙看看最终的成果演示这样大伙才有动力和我一起干不是。
二.需求实施 好了前面说了一大把了，也该正式开干了，不然大伙就要说我是光说不干的花架子了。先放上Android O和Android P的以太网逻辑架构图，有了这个读者心里因该就大概有谱了。不会迷路瞎逛了。
2.1 Android P以太网部分变动 2.1.1 源码文件的增添 在正式开发前，我们一般都应该了解Android新版本对当前实施的需求的改动，Android原生已经对以太网部分有很好的支持了，具体的源码路径在frameworks/opt/net/ethernet/java/com/android/server/ethernet，下面让我们看看Android O和Android P该目录下文件的变化！
Android O(Android 8)此目录下的文件为： [arm-msm8909-user] xxx@pd:~/ssd/xxx/ap/idh.code/frameworks/opt/net/ethernet/java/com/android/server/ethernet$ ls EthernetConfigStore.java EthernetNetworkFactory.java EthernetServiceImpl.java EthernetService.java Android P(Android 9)此目录下的文件为： xxx@Ubuntu16-Model:~/ssd/qcom_64/msm8953-9/frameworks/opt/net/ethernet/java/com/android/server/ethernet$ ls EthernetConfigStore.java EthernetNetworkFactory.java EthernetServiceImpl.java EthernetService.java EthernetTracker.java 这里发现Android P(Android 9)多了EthernetTracker.java区别其他版本，Google新增的类，这个是比较大的改动。
2.1.1 接口参数的变动 有过Android 6/7/8版本开发经验的老司机都知道，Android对以太网的操作主要是依靠EthernetManager这个类来执行，而这个类中最重要的设置以太网信息的方法就是setConfiguration了，让我们来分别看看Android不同版本对这个方法定义的差别！
Android O(Android 8)此方法定义如下： /** * Set Ethernet configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078c6b8c30b62032cb6ca4ea9b58fe3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef84c141892d37503f23b7dcdeb7a3f/" rel="bookmark">
			Codeforces Round #653 (Div. 3) E1. Reading Books (easy version) 题解（模拟）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接 题目大意 给你n本数，俩个人对这n本书有的喜欢，有的讨厌，现在问，这俩个人分别从他们喜欢的书中挑k本出来(如果挑不出来，输出-1)，现在问每本书的最少阅读时间的总和为多少?
题目思路 emmmm,我还以为要用优先队列啥的，没想到居然就是直接模拟一下就行了。
1.我们开三个数组分别存储:俩个小孩都喜欢的书，第一个小孩喜欢的书，第二个小孩喜欢的书的所需要看的时间。
2.再把时间从小到大排序，然后再分情况:
(1)如果有一个人不能选k本书出来看，那么直接输出-1
(2)如果俩个人都喜欢的书的花费时间 大于 第一个小孩喜欢的书的时间加上第二个小孩喜欢的书的时间(书按照现在最短的那个时间依次推)，那么我们肯定是选择时间少的那种，然后把这俩本书删除，再判断。
(3)与第二种情况相反，那么我们就选择俩个人都喜欢的书，然后把这本书删除，即可
代码 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+5; const int mod=1e9+7; int n,k,a1[maxn],a2[maxn],a3[maxn],num1,num2,num3; int main(){ scanf("%d%d",&amp;n,&amp;k); for(int i=1,t,a,b;i&lt;=n;i++){ scanf("%d%d%d",&amp;t,&amp;a,&amp;b); if(a&amp;&amp;b){ a1[++num1]=t; }else if(a&amp;&amp;(!b)){ a2[++num2]=t; }else if((!a)&amp;&amp;b){ a3[++num3]=t; } } sort(a1+1,a1+1+num1); sort(a2+1,a2+1+num2); sort(a3+1,a3+1+num3); if(num1+min(num2,num3)&lt;k){ //如果有人不能选k本书，那么直接输出-1 printf("-1\n"); }else{ int pos1=1,pos2=1,sum=0; while(pos1+pos2-2&lt;k){ if(pos1&gt;num1){ //如果俩个人都喜欢的书已经没有了，那么肯定只能分开选书了 sum+=a2[pos2]+a3[pos2]; pos2++; }else if(pos2&lt;=min(num2,num3)&amp;&amp;a1[pos1]&gt;=a2[pos2]+a3[pos2]){ //前提是他们还有俩本书可以选 sum+=a2[pos2]+a3[pos2]; pos2++; }else{ //否则就是俩个人都喜欢的书的花费时间小于分开选书 sum+=a1[pos1]; pos1++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef84c141892d37503f23b7dcdeb7a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb994408c70c8143a3627530cc9f3f5/" rel="bookmark">
			韦世东：计划 35 岁「退休」的资深爬虫工程师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 | 孙燕
前言：我想 35 岁退休
从开始学习爬虫到真正赚到钱，韦世东只用了一个月时间。如今作为一名资深爬虫工程师，他已经有了七年的互联网工作经验。
除了日常的工作外，随着技术水平不断提高，他越来越多地在论坛等平台上分享自己的经验，帮助其他遇到问题的人“避坑”。
在这个过程中，他发现写作也逐渐得心应手起来，后来他成为了掘金社区优秀作者和 GitChat 认证作者，再后来他把经验集结成书，《Python3 反爬虫原理与绕过实战》就此诞生，此书在预售阶段就全部售空，并登上京东图书销量榜首位。韦世东就是这样一个人，不管做任何事都能做得很好。
据他说，他的生活开始加速是在 2018 年从事爬虫相关工作以后。“变化”是他提到爬虫时说得最多的词，他总是准备着应对随时可能出现的突发问题，也喜欢解决这些问题后的成就感。
他说自己想要的太多，而现在的能力还不够全部实现，所以他要不停奔跑。如今韦世东已经做好了未来七年的职业规划，准备在35岁退休的他，还有很长一段路要跑。
解锁爬虫，迟到的程序员天赋
上学的时候韦世东并没有在编程上展示出过人的才能。那个时候在学校，他把更多时间用在了和舍友一起经营一家电脑维修店。
从学校毕业以后，他还曾经因为扛不住专业压力在工作一周后就辞职。从信息安全员到后来的运营，他辗转做的工作都和软件技术专业没什么关系。 “那时赶上了互联网金融发展最快的一段时间，我在的公司成为集团，我的职位也一直在升。之后跳槽，因为履历好看，我在另一家公司又做了副总经理。”
起势过快，互联网金融的发展很快就遭遇了拐点。2017年，国家大力开展互金专项整治，整个行业开始发出危险的信号。
e租宝被处罚，与比特币一起闯入大众视野的 ICO 团灭，现金贷行业封冰，不断出现的新闻愈发让韦世东觉得运营的工作风险太大，于是他渐渐地有了换行业的想法。
也是在那个每天气温都有30多度的夏天里，他在南宁第一次接触到了爬虫。“那个时候公司正好非常需要数据分析和竞品对比，通过数据来挖掘广告投放的效果，所以我们想通过爬虫来找一些竞争对手的数据，分析对方在广告投入上哪一方面产出比较高，哪一方面比较低，作为我们做选择或者预算的参考数据。不过那个时候团队里没有会爬虫的工程师，我就只能自己上！”
学习爬虫的过程格外顺利，这韦世东自己都觉得意外。从第一次学习到开始赚钱，他只用了一个月时间。
在 2017 年底脱产学习的那一个月里，他没有买任何教程，靠着自己不断摸索尝试，有问题就搜索文档或者在技术群里与大家交流，没有特别的轰轰烈烈，就这样他成为了一名爬虫工程师。
“我觉得我学爬虫的时候进步特别快。一起念书的同学都做了工程师，可是我不行，我学不会其他编程知识。碰到爬虫后我好像忽然开了窍，有豁然开朗的感觉。爬虫不断变化的知识和随时会出现的新问题让我觉得每天都不一样，也不会有审美疲劳。”
没有焦虑和犹豫，韦世东在学习了爬虫后的生活变得清晰起来。他享受遇到难题后解决掉它们的过程。不断变化的情况，给他带来了新鲜感和成就感。
一个月的学习让他更加自信：“爬虫一定能学会！”他的职业生涯就像按下了快进，短短几年就冲到了很高的地方。
出现智能化爬虫？掌握它就好！
工作的时候韦世东更喜欢关掉微信、钉钉和其他社交软件，用纸笔记下思路和逻辑，让自己专注于代码。他说：“虽然我是个工程师，但是我不太喜欢用电脑，只有真正要写代码的时候才会用到比较多。”
今年年初韦世东开始在北京工作，职位是他熟悉的爬虫研发工程师，除了专业问题，他主要负责策略问题和协调等方面的工作，例如规划大家在适当的压力下完成公司任务。
谈到一天的时间分配，韦世东很开心地说自己很忙很充实，最近每天都会工作到晚上9、10点钟。他一边要熟悉新公司的业务，一边也要解决公司目前技术上最难的问题。对他来说，这些过程足够有趣，可以每天早晨6点多就把他叫醒。
“平时我会把自己的需求转换成学习方式，主动挑比较难或者没接触过的工作做，已经掌握的内容就和同事换一下，把对方手里最难的换过来，团队里的很多人都是这样。问题只要给了我，我就一定会解决。”
他很享受现在的状态，面对可能遇到的突发问题，他更多的是期待。“爬虫里不确定因素太多了，随时都有可能会出现突发问题。”他不会在原地等着，更多的时候，他会在问题找上他之前，就主动去了解学习。
现在韦世东正在做关于智能化爬虫的工作。起因是前段时间他和一个网易工程师聊到了这个话题，看了相关论文，研究了算法后他就开始尝试着做了起来。
目前智能化爬虫的研究主要分为两个方向：智能化识别与智能化提取。其中智能化识别可以做到识别整个网页中最重要的内容，在文章中找出正文与标题，过滤掉广告和其他推荐信息，准确率高达百分之九十几。韦世东表示，目前国内所有知名的新闻网站都在测试范围内，与传统爬虫比起来，智能化爬虫的反爬虫工作难度更高。
这样的操作看起来很聪明，可是韦世东和他的很多朋友依然觉得，与人工智能在视觉和自然语言处理上的应用相比，智能化爬虫显得有点笨。他说：“这也是一个算法和网页特性决定的，因为它会出现误判，把周边文本的一些内容算到正文里。这个很难改进，因为出现误判的概率并不是由工程师决定的，与工程师的能力无关。” 同时在应用场景上，智能化爬虫也与传统爬虫有着一定差异。“智能化爬虫和传统爬虫在应用场景方面有区别。在当前的大环境下，智能化爬虫更适合要求覆盖面广但对数据准确率要求不高的场景，同时能够解放劳动力，让人将精力放在更重要的事情上，而不是编写路查找语法。”
目前智能化爬虫的发展还是很边缘的状态，专门从事的工程师也很少。韦世东说：“这个职位就像信息安全工程师，它没有明确指标，没为公司带来利益，所以也没有形成规模。”也是因为这个原因，目前专门的智能化爬虫工程师数量还是很少，韦世东也建议大家根据自己的实际情况和未来规划，来选择是否学习相关工作：“因为这方面专门的工程师培养起来比较困难，对于公司来说，培养成功后工程师个人的价值高，而公司本身却很难看到直接收益。”
在国内，阿里巴巴等有着相对成熟的智能化爬虫工程师的企业里，非常专业的爬虫工程师团队正在将偏难以实施的技术做成服务，销售给其他公司。
在谈到智能化爬虫未来的发展方向时，韦世东表示：“因为智能化爬虫目前并不算智能，它只是通过算法或者通过深度学习的方法解决了某些问题，想要达到真正的智能化还有很长的路要走。”
尽管智能化爬虫已经投入应用并且代替了一部分工程师的工作，但韦世东并不担心它之后的发展会取代掉爬虫工程师，除了“看起来有点笨”外，韦世东考虑的还有社会进步中人与机器的关系。
“它的影响肯定会有，就像以前的机械取代人工劳动，现在智能化技术会取代掉没有太高技术难度的工作和没有效率的人，以后的发展一定是机器更加普遍，因为它们成本更低，效率更高。但是对于我们来讲，掌握机器的肯定还是工程师，只要好好学习，就能在时代潮流中保证自身身价水涨船高，不被潮水冲到沙滩上。” 韦世东一点都不担心“爬虫工程师是否能做一辈子？”“爬虫未来的发展方向在哪？”因为他知道所有人的工作都会变，有的人会升职，有的人会换行业，这些都是很正常的事。比起那些，现在他最大的焦虑是“自己跑得太慢了”，这也是他在享受学习爬虫乐趣中的一点苦。 “虽然这几年的工作中积攒了见识，但我起步晚，我想要的东西有很多，和当前的技术能力不匹配，所以会担心焦虑。想要在有限时间内超过那些已经跑了很久的人，我要很快才行。” 这样的焦虑让韦世东“从入行到现在从来没有真正休息过，天天都在奔跑”。韦世东的起步速度很快，快过了大部分人，快到自己都觉得不科学，这也让他更快地开始面对被成就裹挟着，一起扑过来的问题。 “一旦你的速度快了，你的职业等级就会很高，现实工作的时候，你就会直面自己能力不足的情况。你会想很努力地补足自己，那个时候就会跑得特别快，我现在就是这样。” 一夜成团，夜幕降临
2018年，刚学习爬虫后不久的韦世东就产生了带动行业发展的想法。从最初“希望靠技术带动行业发展”到“意识到最重要的还是把知识准确地输出给有需求的工程师”，他一直在为这些做着准备。2019年9月11日，韦世东发布文章《今天，大佬云集的夜幕团队正式成立了！》，正式把这个他费心准备已久的团队带到了大家面前。 在武侠动画《秦时明月》系列中，漫画家根据春秋战国时期的背景设置了3位鬼谷子，作为历代纵横家首领的代表，“纵横”的概念是韦世东成立团队的重要灵感。他说：“我联系了行业内知名的工程师，希望能合纵连横，整合资源，做一个大家不需要考虑看或不看，可以直接学到优质内容的团队。” 现在的爬虫工程师圈子里，很少有人不知道这个成立了仅半年左右的团队。对于这段时间取得的成就，韦世东表示十分满意。一方面，团队的知识输出就像雨后春笋一样蓬勃发展起来，目前已经建立了有两千左右用户的爬虫论坛、多个技术微信群和两门专业课，团队中已经出书和有出书计划的成员也越来越多。
另一方面，夜幕团队一直在努力调动大家的学习热情。“现在一个普遍的现象是，无论是大厂还是小公司的程序员，能够保持独立自主学习的人很少。”注意到这个问题后，韦世东和团队成员平时也会有意识地调动大家的学习积极性。 在这个团队中，韦世东把自己的角色比喻成篮球中的组织后卫：分配工作，把大家组织到一起。也是通过这样的组织工作，他可以一直保持着积极的学习态度。“崔庆才、周子淇、陈祥安他们本身就是优秀的技术人员，在公司里也是佼佼者，在他们面前我会很谦虚，因为我能清晰地看到自己的不足。” 虽然疫情当前，但是他们的工作热情也没有减弱。韦世东介绍：“今年年中，我们计划请专业的律师来做一场法律普及讲座，给大家讲讲法律红线的问题。” 在网络上输入“爬虫工程师”，出来的多数词条都会提到法律问题，这也是韦世东十分在意这一点的原因。工作之后，没有人特意和他强调过身为爬虫工程师需要注意哪些法律规定，只是每条爬虫违法被抓的新闻都像是一个信号，提醒着他：爬虫工程师比任何人都更接近数据，也比任何人都接近浮在隐私上的那根红线。 “我是很谨慎的那种人，接触爬虫之后经常会看到有人因为爬虫而违法被抓的新闻，那时起我就格外注意对于数据隐私、敏感信息的界定条件。我自己认真读了《中华人民共和国网络安全法》、《中华人民共和国刑法》和《数据安全管理办法》，看相关法律的时候我会着重读一条：量刑标准，也就是到底判多少年。只有清楚这个事情会判多少年，耽误多少年的时间，你才会对法律有敬畏之心，不会在面对诱惑或压力的时候误入歧途。” 在日常工作中，爬虫工程师经常还会面对一种情况，那就是恶意爬虫。它可以在很短的时间内疯狂爬取目标网站信息，甚至导致对方网站瘫痪，正常用户无法登陆，12306、美团酒店和飞猪旅行等出行网站就经常会面对这样的情况。不出意外，这样的爬虫也一向是法律处罚的重点对象。 “恶意爬虫分为主观恶意和非主观恶意。举个例子，为了提高爬取效率而采用分布式多机协同爬取或者增加并发数，对目标网站服务器造成压力的行为，就是恶意爬虫。” 对于普通爬虫工程师来说，即使自己没有编写恶意爬虫，也仍然有可能在接手新工作时不小心“制造出”非主观的恶意爬虫。“程序员在不知情的情况下也有可能造成恶意爬虫，例如你的公司管理着成百上千个爬虫程序，有一些在人员交接的时候遗漏了，程序很有可能一直在运行，而无人知晓。”对于这种情况，韦世东建议大家在日常工作，特别是工作交接的过程中就做好记录，交接时做好盘点。 计划35岁“退休”，换种思路重新工作
韦世东对于自己未来的职业规划十分明确：在三年后成为架构师，做四年架构师后在35岁“退休”，想到学校做老师或者回家养养鸭子。谈到原因，他说：“我已经奔跑了很多年，35岁前还有7年左右的时间。跑了这么久，那个时候也可以休息一下了。”按照他的计划，再有一年半的学习他就可以成为一名初级架构师。
在韦世东自己看来，他之所以可以利落地制定好这个规划是因为自己对于代码和做程序员本身没有什么执念。“我不是一个程序员，因为我不是一个喜欢写代码的人。我更喜欢完成一件事情后带来的满足感，写代码恰好是一个实现途径。只是我一定会做到一点：我编写出来的代码一定是稳定的，一定是最漂亮最规范的。” 运营出身的经历让韦世东对周围事物始终保持着敏感，避免陷在编程的思维里。和专注于写代码的技术人士不同，在他的想法里，很多事情都是可以“经营”的，重要的是有选择地规划时间。 在《秦时明月》中，韦世东最喜欢的角色是鬼谷派卫庄。这个角色有着一头潇洒的白发，轮廓深邃，脸型消瘦，官方人物性格设定是：无论自己是不是喜欢，只要有必要，他可以毫不犹豫地做，也绝不后悔。这一点深深影响到了韦世东。
上大学之后，他对于每次面对变化时做出的选择都很满意，而他满意的标准也很简单：自己选的都是最好的。“我从来不会后悔自己的选择，因为我考虑的是如何承受这个选择带来的结果，而不是困扰其中。”这也是韦世东经常会提到的建议：“你不能在每一个十字路口都犹豫很久，然后再后悔。爬虫这个行业没有技术要求，也没有年龄要求。我的经历告诉我，做到多看官方文档，工作的时候把思路写下来分析，很多问题就会迎刃而解。” 没有了这个顾虑，“变化”本身看起来也就没有那么可怕。就像他刚开始学习爬虫时那样，未来不确定的变化吸引着他不停地继续向前。 实现职业自由之后，韦世东的另一个计划是创业。根据自己的观察和经验，他认为保险起见，35岁前不要创业，这个年纪他刚好从公司“退休”，有了一定的的积累和资金，创业计划可以提上日程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb994408c70c8143a3627530cc9f3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4934681e9f0cffbafebe415cc11085ba/" rel="bookmark">
			浏览器的地址栏，多输入了一个 “/”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器的地址栏，多输入了一个 “/”,可以 请求到页面，导致页面不能正常加载，但是前端导入的js不能导入，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d633219c59b5f5f15f95b7dfd13e0d/" rel="bookmark">
			安信可开发工具 导入8266 RTOS SDK2.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ESP8266的FreeRTOS SDK，采用了SDK和工程文件夹分离的方式，所以我们需要手动创建一个 app 目录。将 sdk 目录下的 driver_lib 重命名为 app
2 拷贝 /examples/project_template 下的所有文件到刚才的 app 目录（提示覆盖则确认），
3 将 ESP8266_RTOS_SDK-2.0.0/third_party/makefile 重命名为 makefile.bak ，以防止编译时报错
4 导入项目到 Eclipse
选择 File→Import
点开C/C++分支，并选中Existing Code as Makefile Project
去除C++支持，选中 Cygwin GCC
点击Browser，选中ESP8266_RTOS_SDK-2.1.0
5
点击 Finish 完成ESP8266_RTOS_SDK-2.1.0的导入
配置项目
因为分离了sdk和project目录
所以编译之前必须先指定一个 SDK_PATH 和 BIN_PATH
修改 ESP8266_RTOS_SDK/app 目录下的 makefile，添加以下内容
parent_dir:=$(abspath $(shell pwd)/$(lastword $(MAKEFILE_LIST)))
parent_dir:=$(shell dirname $(parent_dir))
parent_dir:=$(shell dirname $(parent_dir))
SDK_PATH= $(parent_dir)
BIN_PATH=$(SDK_PATH)/bin
6
Build Project ：编译项目
Clean Project：清理项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8cbe7cc6f495ac4bbbcdde96296859/" rel="bookmark">
			Linux云计算架构-文件权限、所有者、所属组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux云计算架构-文件权限、所有者、所属组详解1. linux中有哪些文件2. 文件有哪些权限3. 如何设置文件的权限3.1 设置文件的一般权限和特殊权限3.2 设置隐藏权限3.3 设置ACL访问控制列表 4. 如何设置文件的属主和属组5. 扩展知识 Linux云计算架构-文件权限、所有者、所属组详解 linux中一切都是文件。 我们不仅要了解文件有哪些权限，还要能随心所欲的修改文件的权限，这样才能满足我们对日常工作的需求。
1. linux中有哪些文件 2. 文件有哪些权限 3. 如何设置文件的权限 3.1 设置文件的一般权限和特殊权限 对文件或者目录使用ll 文件名或者ls -l 文件名命令都可以查看文件的权限。
有了以上的知识，我们可以使用命令chmod命令设置文件的一般权限和特殊权限。
数字法：直接设置一般权限和特殊权限【777=0777】【654=0654】【7654则表示即设置一般权限也设置特殊权限，第一位表示设置特殊权限，后三位表示设置一般权限】
符号法：在原来的权限基础上加权和减权【u+s】【g+s】【o+t】
3.2 设置隐藏权限 查看隐藏权限【lsattr命令】添加或移除隐藏权限【chattr命令】
3.3 设置ACL访问控制列表 针对单一用户或用户组、单一文件或目录进行读、写、执行权限的控制。
添加或者删除ACL【setfacl命令】
查看ACL【getfacl 文件名 】
4. 如何设置文件的属主和属组 chown [-R] 属主名 文件名
chown [-R] 属主名:属组名 文件名
文件的所有者和所属组拥有无视文件权限的特权，在无文件写权限的情况下也可以修改修改文件内容。
修改一般文件
修改目录文件
5. 扩展知识 # 为什么root用户创建一个文件，默认权限是644？ # 为什么普通用户abong创建一个文件，默认权限是664？ # 原来是有一个umask掩码在作怪 [root@server ~]# umask 0022 # 查看、修改umask值，这里不做修改。 # 当UID大于199，且拥有者和所属组相同，则umask为002，否则umask为022。 [root@server ~]# vim /etc/profile 59 if [ $UID -gt 199 ] &amp;&amp; [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f8cbe7cc6f495ac4bbbcdde96296859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b18fc2094a99516dbdcc22ced757bcb/" rel="bookmark">
			python处理Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对 excel 文档操作有多简单？看看python如何处理。
1 前言 最近需要频繁读写 excel 文件，想通过程序对 excel 文件进行自动化处理，发现使用 python 的 openpyxl 库进行 excel 文件读写实在太方便了，结构清晰，操作简单。本文对 openpyxl 的使用进行总结，主要包含以下内容：
openpyxl 的介绍及 excel 文件结构说明工作表的读写处理行列的读写处理单元格的读写处理 2 openpyxl 及 excel 文件结构 openpyxl 是一个对 xlsx/xlsm/xltx/xltm 格式的 2010 excel 文档进行读写的 python 库。它官网有详细的文档介绍。在进行使用前，需先安装并引入
# 安装 pip install openpyxl # 引入openpyxl 模块 import openpyxl 在进行 excel 操作之前，先对 excel 的文件结构做一个简单了解，以便于熟悉后续的操作。如下图：
一个 excel 文件，其内容按层次分为工作簿(文件) -&gt; 工作表(sheet) -&gt; 行列 -&gt; 单元格 ，对应上图，整个 excel 文件即是一个工作簿；工作簿下可以有多个工作表(如图中的 Sheet1/test1 等等)；工作表中就是对应的表格数据，分为行和列，行是用序号表示，列用大写字母表示（也可用序号）；行与列的交点就是每一个存储数据的单元格。因此，我们对 excel 表格进行读写，基本按这个层次思路来操作：读入文件，找到工作表，遍历行列，定位单元格，对单元格进行读写。因此，会涉及到工作表、行列、单元格的读写操作。这些操作之前，需要先把文件加载进来，一个 excel 文件就是一个工作簿 (workbook)，加载操作如下（示例中的 excel 文件为 text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b18fc2094a99516dbdcc22ced757bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd17068f1893de8ee9b8a9f42cea19ee/" rel="bookmark">
			CMMI 2.0 和 1.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMMI2.0与1.3在组织形式区别很大，很多PA和之前的不太一样了，而且PA在2.0中叫实践域，1.3中叫过程域。不过其实核心内容没有大的变化，只是相关内容的位置进行了调整，部分描述进行了优化。
目前是过渡阶段，2.0和1.3都可以评估，但截止日期之后就只适用2.0了。1.3评估的截止日期是2020年9月，但因为疫情的原因不知道会不会有所调整。
下面是基于CMMI2.0的持续改进计划，供参考：
对该计划感兴趣，欢迎与我联系，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bb67266956bf997660fcb0000a9cc6/" rel="bookmark">
			Linux系统中的日志管理 ---systemd-journald日志（journalctl命令的用法）和 rsyslog 日志（自定义日志采集路径、更改日志采集格式和日志的远程同步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验环境 1 | yxy.westos.com : 172.25.254.10 2 | lww.westos.com : 172.25.254.20 3 | yxy.westos.com &amp; lww.westos.com : systemctl stop firewalld.service ##关闭火墙 二、systemd-journald 1.systemd-journald 服务名称：systemd-journald.service
systemd-journald可移植性高，资源消耗少、结构简单、可扩展、安全性高等优点。
安全性之所以高是因为此程序只负责对日志进行查看而不能对日志进行保存和采集,那么关机后再开机（重启），只能查看到开机后的日志，因为系统之前的日志是保存在内存中的，所以关机后就被清空了，那么再开机时用journalctl是看不到的之前的日志信息的。
命令：journalctl
默认日志存放路径： / run / log
2. journalctl命令的用法 1 | journalctl 2 |	-n 3 ##日志的最新3条 3 |	--since "2020-06-01 12:00:00" ##显示12：00后的日志 4 |	--until "2020-06-01 12:10:00" ##显示日志到12：10 1 | journalctl 2 | -o	##设定日志的显示方式 3 |	short 经典模式显示日志 4 |	verbose 显示日志的全部字节 5 |	export 适合传出和备份的二进制格式 6 |	json js格式显示输出 1 | journalctl 2 | -p ##显示制定级别的日志 3 |	#0 emerg 系统的严重问题日志 4 |	#1 alert 系统中立即要更改的信息 5 |	#2 crit 严重级别会导致系统软件不能正常工作 6 |	#3 err 程序报错 7 |	#4 warning 程序警告 8 |	#5 notice 重要信息的普通日志 9 |	#6 info 普通信息 10|	#7 debug 程序拍错信息 1 | journalctl 2 | -F PRIORITY ##查看可控日志级别 3 |	-u sshd ##指定查看服务 4 |	--disk-usage ##查看日志大小 5 |	--vacuum-size=1G ##设定日志存放大小 6 |	--vacuum-time=1W ##日志在系统中最长存放时间 7 |	-f ##监控日志 1 | journalctl _TRANSPORT=kernel ##直接查看该程序产生的日志 2 | journalctl _PID=*** ##直接查看PID为**的程序产生的日志 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bb67266956bf997660fcb0000a9cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028aba3d91f81d6ce7d9763881e5f429/" rel="bookmark">
			Kalibr联合标定Camera-IMU  (总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kalibr联合标定Camera-IMU 1. Kalibr安装2. 制作标定板3. Camera标定3.1采集数据3.2开始标定3.3标定验证 4. IMU标定5. Camera与IMU联合标定 1. Kalibr安装 安装依赖库 sudo apt-get install python-setuptools python-rosinstall ipython libeigen3-dev libboost-all-dev doxygen libopencv-dev ros-indigo-vision-opencv ros-indigo-image-transport-plugins ros-indigo-cmake-modules python-software-properties software-properties-common libpoco-dev python-matplotlib python-scipy python-git python-pip ipython libtbb-dev libblas-dev liblapack-dev python-catkin-tools libv4l-dev sudo pip install python-igraph --upgrade 创建工作空间 mkdir -p ~/catkin_kalibr/src cd ~/catkin_kalibr/src catkin_init_workspace cd .. catkin_make echo "source ~/catkin_kalibr/devel/setup.bash" &gt;&gt; ~/.bashrc source ~/.bashrc cd ~/catkin_kalibr/src git clone https://github.com/ethz-asl/Kalibr.git cd .. catkin_make 等待一段时间(20分钟左右),安装编译完成.
2. 制作标定板 使用aprilgrid标定板，可以使用kalibr自带工具自定义生成不同大小的标定板，命令行如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/028aba3d91f81d6ce7d9763881e5f429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a2a6031eec2420741236344202f888/" rel="bookmark">
			yum报错[Errno 256] No more mirrors to try
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一：小编使用yum install ansible -y命令安装ansible，出现如图所示报错，检查当前网络可以正常连接公网。
Error downloading packages:
epel-release-7-11.noarch: [Errno 256] No more mirrors to try.
yum报错[Errno 256] No more mirrors to try
步骤二：执行命令yum clean all
清理客户端yum源配置的缓存
yum报错[Errno 256] No more mirrors to try
步骤三：执行命令yum makecache
将Linux服务器的包信息下载到本地电脑缓存起来，makecache来建立一个缓存，后边yum安装在缓存中搜索，提高了速度
yum报错[Errno 256] No more mirrors to try
4
步骤四：再次执行yum install ansible -y进行安装，没有出现报错，问题解决。
yum报错[Errno 256] No more mirrors to try
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb2c8cd477f146445d86f3d280d4ed6/" rel="bookmark">
			Codeforces E1. Reading Books (easy version) (模拟) (Round #653 Div.3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门
题意： 现有n本书，每本书有三个性质：ai 阅读所需时间，bi = 1 表示Alice 喜欢该书， ci = 1 表示Bob喜欢该书。试问能否找到最好方案—Alice和Bob喜欢的数都至少有k本，且总阅读时间最短；若没有可行方案输出-1.
思路：
先将所有书分为三个组：both两个人都喜欢的书，alice只有Alice喜欢的书，bob只有Bob喜欢的书；并将三个组按升序排序。如果不能满足k本书的条件直接输出-1再取最小的方案：先考虑both的数量不够k本或both中的时间比alice[i] + bob[i]大的情况，就取alice[i] + bob[i]；反之就是直接取both[i]啦。 代码实现：
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;cctype&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;list&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; #define endl '\n' #define null NULL #define ll long long #define int long long #define pii pair&lt;int, int&gt; #define lowbit(x) (x &amp;(-x)) #define ls(x) x&lt;&lt;1 #define rs(x) (x&lt;&lt;1+1) #define me(ar) memset(ar, 0, sizeof ar) #define mem(ar,num) memset(ar, num, sizeof ar) #define rp(i, n) for(int i = 0, i &lt; n; i ++) #define rep(i, a, n) for(int i = a; i &lt;= n; i ++) #define pre(i, n, a) for(int i = n; i &gt;= a; i --) #define IOS ios::sync_with_stdio(0); cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb2c8cd477f146445d86f3d280d4ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9da0f4e2aa811fadd00a23fa85a340/" rel="bookmark">
			python量化分析库 Backtrader入门之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Bactrader是python中用来做单机量化分析的一个库，使用该库不用借助量化平台就可以进行股市的量化分析和回测。只要自己已经有股票数据，就可以在自己的机器上进行量化分析，摆脱网络平台的束缚和依赖。 框架的使用 首先理解使用backtrader的过程中大致一下解释2个基本概念。
一、 Line 价格数据（Data Feeds）、技术指标（Indicators）和策略（Strategies）都是 Line。
“Line” 是由一系列的点组成的。典型的价格数据，通常由以下类别的数据组成：
Open, High, Low, Close, Volume, OpenInterest
开盘价、最高价、最低价、收盘价、成交量、持仓量 价格数据中的所有”Open” (开盘价)按时间组成一条 Line。所以，一组含有以上6个类别的价格数据，共有6条 Line。
如果我们也算上“DateTime”（时间，可以看作是一组数据的主键），一共有7条 Line。
二、下标0 当访问一条 Line 的数据时，会默认指向下标为 0 的数据。
最后一个数据通过下标 -1 来访问。这也设计是为了符合 Python 的迭代器规则（一条 Line 可以被迭代，因此也是iterable）。
在-1之后是索引0，它用于访问当前时刻。
假设在创建策略的过程中，在初始化期间创建具有简单移动平均值的策略：
self.sma = SimpleMovingAverage(.....) 访问此移动平均线的当前值的最简单方法： av = self.sma[0] 在回测过程中，无需知道已经处理了多少条/分钟/天/月，”0”一直指向当前值。 遵循典型的 Python 传统，用下标 -1 来访问最后一个值： previous_value = self.sma[-1] 当然，当然-2、-3下标也是可以照常使用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c2b3350b13577e1ea2676097d4f3bc8/" rel="bookmark">
			Makefile工程管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 导引makefile的规则和伪目标makefile规则makefile伪目标 makefile中的变量自定义变量自动变量预定义变量和环境变量 makefile的规则Makefile引用其他Makefile 导引 如果是一个单独的.c文件，我们可以使用一条gcc指令去完成编译，得到可执行文件。
例如：
//test.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include "test.h" int main(void) { //print(); printf("This is test file\n"); return 0; } ubuntu@ubuntu16:/work$ gcc -o test test.c 得到可执行文件test.
ubuntu@ubuntu16:/work$ ./test This is test file 那么如果是两个或多个c文件编译成一个可执行文件，就需要多条指令。
如：
现在有两个c文件，test.c和test1.c
//test.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include "test.h" int main(void) { print(); printf("to call test1's function\n"); return 0; } //test1.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int print(void) { printf("this is test1 file\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c2b3350b13577e1ea2676097d4f3bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5ef620837ff18f872460d8835b4484/" rel="bookmark">
			codeforces 1374E1 Reading Books (easy version)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排完序以后从小到大扫一遍 如果有相同的 就把其中一个+k 扔到一个数组里 然后每次也跟这个数组比较下有没有重的 因为一次只能给一个ai加x最后看看要多大 加的时候如果有一本书两个人都like 但一个人到k了 就把这个人最大的单独like的去掉 换成这个两个人都like的加完以后 再检查一下后面有没有两个都like的 更优的
Easy and hard versions are actually different problems, so read statements of both problems completely and carefully.
Summer vacation has started so Alice and Bob want to play and joy, but… Their mom doesn’t think so. She says that they have to read some amount of books before all entertainments. Alice and Bob will read each book together to end this exercise faster.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5ef620837ff18f872460d8835b4484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100a0000b0ee5a6c7dc80e4973ef4af2/" rel="bookmark">
			Codeforces Round #653 (Div. 3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一场比赛比较简单水 ，但是我还是实力不够，做出的不多而且后几次提交经常WR。
A. Required Remainder time limit per test1 second memory limit per
test256 megabytes inputstandard input outputstandard output You are
given three integers x,y and n. Your task is to find the maximum
integer k such that 0≤k≤n that kmodx=y, where mod is modulo operation.
Many programming languages use percent operator % to implement it.
In other words, with given x,y and n you need to find the maximum
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100a0000b0ee5a6c7dc80e4973ef4af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e7aa00ebd0cc104840ece95e184119/" rel="bookmark">
			雪花算法生成简化数据中心和机器ID获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * @program: simple_tools * @description: 雪花算法代码实现 * @author: qiqi **/ public class IdWorker { // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e7aa00ebd0cc104840ece95e184119/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/377/">«</a>
	<span class="pagination__item pagination__item--current">378/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/379/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>