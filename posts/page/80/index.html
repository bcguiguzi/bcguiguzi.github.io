<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb75b94faaa54084fcce4880bb2352a/" rel="bookmark">
			JS手写apply，call，bind函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章咱们来手写简易版的apply，call，bind函数。
实现思路 首先咱们需要思考下这三个函数放到哪里比较合适，因为这三个函数是被函数对象调用的，并且每个函数都可以调用，所以不难想到有一个位置非常合适，函数的显式原型对象上，这样就可以通过原型链被每个函数调用。
手写apply apply函数可以传入两个参数，第一个参数是需要绑定的this对象，第二个参数是传递给函数的参数组成的数组，咱们可以从apply函数的用法倒推它的代码实现。
首先声明一个foo函数，作为测试函数，代码如下图：
之后在函数的显式原型对象上声明一个myapply函数，代码如下图：
第一个参数是执行apply函数后调用函数的对象，为了确保传入的内容是个对象，咱们需要对传入的第一个参数进行判断和处理，代码如下图：
之后咱们需要修改this指向，myapply本身也是个函数，调用者就是使用myapply的函数对象，也就是说此时的this就是调用myapply的函数对象，咱们就可以借助this来建立newObj与调用myapply的函数对象之间的调用关系，代码如下图：
上图可见，在newObj上添加一个fn属性值为调用myapply函数的函数对象，然后执行fn，调用fn后删除newObj上多余的fn属性。
第二个参数是参数构成的数组，可以通过解构的方式获取这些参数，代码如下图：
这样咱们就实现了自己的apply函数。
手写call call和apply第一个参数接收的内容一致，call的后续参数通过参数列表的方式传入，实现思路与apply一样，只是接收参数的方式不同，区别如下图：
其他的代码与myapply函数一样。
手写bind bind的函数的第一个参数接收的内容与apply和call一致，后续参数也是通过参数列表的方式传入，不过bind的内部实现不同之处在于，bind返回了一个具有所需this指向的新函数，代码如下图：
其他的代码与mycall函数一样。
完整代码 function foo(name, age) { console.log(this, name, age); } Function.prototype.myapply = function(newObj, args) { newObj = (newObj === null || newObj === undefined) ? window : Object(newObj); newObj.fn = this; newObj.fn(...args); delete newObj.fn; } Function.prototype.mycall = function(newObj, ...args) { newObj = (newObj === null || newObj === undefined) || Object(newObj); newObj.fn = this; newObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffb75b94faaa54084fcce4880bb2352a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd167afc5e59354222631b349d0d493/" rel="bookmark">
			张雪峰说过：计算机专业不要死盯着计算机，还有其他更好的出路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 说真的，计算机专业不要只盯着计算机啊！
说实话，各个行业近几年的就业都不怎么景气，如果不是985、211出来的，去找工作真的就是难上加难，廉价劳动力还不说，还容易被忽悠，多走不必要的弯路。
如果你也是计算机专业，以下这些希望你能根据自身情况，做好选择！
📺公务员的信息or IT管理岗位
这一类岗位日常就是做一些和电脑相关的杂事，老一辈不想学电脑，所以交给年轻人去做。但是这种活儿其实很少，如果有别的活动事务忙起来的时候，经常会被拉去干别的活，包括但不限于“帮领导传话通知各部门”、“给会议室打印名.牌和摆放矿泉水”之类
📺互联网大厂
这部分是大多数计算机的毕业生选择的一个就业方向了，提供的岗位也蕞多。除了开发，算法，测试，还有产品，运营，对女生来说，前端，产品都是很好的选择。待遇视不同的公司稍有不同
📺医院的IT管理岗
主要工作内容是帮帮医.院维护一下数据库啊，办公系统之类的老旧软件。一周的有效工作时间基本4~5小时，剩下都在摸鱼并假装努力办公
📺金融公司的岗位
这个属于比较卷的岗位，方向也各不相同，科技方向的投研，二级量化，数分，后台系统开发，资管，都有。工作压力和淘汰压力也是根据具体公司具体讨论
📺国企央企的IT
其实和公务员的有点像，做的内容比较简单，有一些会比较忙，有一些会比较有空但会被拉去做别的杂活
另外说一点如果没有名校学历或大公司背景，还是建议尽量尽早考下软考集成。虽然不像机构吹得那样能够年薪百万，但它的确能够打牢你的专业基础，同时能给简历加分不少
对于计算机基础比较好的推荐买本《系统集成项目管理工程师教程》直接跟着书本学，时间很宝贵不要过多浪费时间
总之一句话：做自己能做到蕞好的，千万不要退而求其次
Python入门教程 如果大家对python感兴趣，下面我会给大家免费分享一份Python全套学习资料， 包含视频、源码、课件，希望能帮到那些不满现状，想提升自己却又没有方向的朋友，可以和我一起来学习交流。
① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 600多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，含50个超大型项目详解，学习不再是只会理论
④ 20款主流手游迫解 爬虫手游逆行迫解教程包
⑤ 爬虫与反爬虫攻防教程包，含15个大型网站迫解
⑥ 爬虫APP逆向实战教程包，含45项绝密技术详解
⑦ 超300本Python电子好书，从入门到高阶应有尽有
⑧ 华为出品独家Python漫画教程，手机也能学习
⑨ 历年互联网企业Python面试真题,复习时非常方便
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
【点此链接】领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a056b52b2f2778a3b350e1a030519f1/" rel="bookmark">
			软件测试之单元测试、系统测试、集成测试知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单元测试的概念 单元测试是对软件基本组成单元进行的测试，如函数或一个类的方法。当然这里的基本单元不仅仅指的是一个函数或者方法，有可能对应多个程序文件中的一组函数。
单元也具有一些基本的属性。比如：明确的功能、规格定义，明确的与其他部分的接口定义等，可清晰地与同一程序的其他单元化分开来。
二、单元测试的目的 单元测试的目的在于发现各模块内部可能存在的各种错误，主要是基于白盒测试。（也就是说，在单元测试过程中，用的最多的是白盒测试方法，也可能会有灰盒或者黑盒。单元测试和白盒测试是不同的划分，不存在包含关系）。
在单元测试阶段对应的文档是详细设计文档（LLD）；对应的代码就是单元代码，因此单元测试的目的主要有3点：
1、验证代码是与设计相符合的；
2、发现设计和需求中存在的错误；
3、发现在编码过程中引入的错误。
三、单元的常见错误 单元的常见错误一般出现在以下五个方面，因此这五个方面是单元测试应该关注的重点。
1、单元接口。
2、局部数据结构。
3、独立路径。
4、出错处理。
5、边界条件。
四、如何进行单元测试 在单元测试时，由于单元本身不是一个独立的程序，一个完整的可运行的软件系统并没有构成，所以需要设置一些辅助测试单元，辅助测试单元有两种，一种是驱动单元，另外一种是桩单元。
1、驱动单元：用来模拟被测单元的上层单元，相当于被测函数的主函数，如main函数。所以驱动单元主要完成以下4个步骤：
（1）接受测试数据，包含测试用例输入和预期输出；
（2）把测试用例输入传送给被测单元，驱动被测单元测试；
（3）将被测单元的实际输出和预期输出进行比较，得到测试结果；
（4）将测试结果输出到指定位置。
2、桩单元：用来代替被测单元工作过程中调用的子单元。
桩单元模拟的单元可能是自定义函数：这些自定义函数可能尚未编写完成，为了测试被测单元，需要构造桩单元来代替它们，可能存在错误，会影响测试结果，所以需要构造正确无误的桩单元来达到隔离的目的。
驱动单元和桩单元都是额外的开销，虽然在单元测试的时候必须写，但是并不需要作为最终的产品提供给客户。
五、单元测试策略 一般的单元执行策略有三种：孤立的单元测试策略，自顶向下的单元测试策略和自底向上的单元测试策略。需要注意的是：在集成测试中也有自顶向下和自底向上的测试策略，但是测试对象不同。
1、孤立的单元测试策略
方法：不考虑每个模块与其它模块之间的关系，为每个模块设计桩模块和驱动模块，每个模块进行独立的单元测试。优点：这个方法比较简单，最容易操作，可以达到很高的结构覆盖率，可以并行开展，该方法是纯粹的单元测试。缺点：桩函数和驱动函数工作量很大，效率低。 2、自顶向下的单元测试策略
方法：先对最顶层的单元进行测试，把顶层所调用的单元做成桩模块，其次对第二层进行测试，使用上面已经测试过的单元做驱动模块，以此类推，直到测试完所有模块。优点：可以节省驱动函数的开发工作，效率高。缺点：随着被测单元一个一个被加入，测试过程将变得越来越复杂，并且开发和维护的成本将增加。 3、自底向上的单元测试策略
方法：先对最底层的模块进行单元测试，将模拟调用该模块的模块设置为驱动模块，然后再对上面一层做单元测试，用下面已经测试好的模块做桩模块，以此类推，直到测试完所有模块。优点：可以节省桩函数的开发工作量，测试效率较高。缺点：不是纯粹的单元测试，底层函数的测试质量对上层函数的测试将产生很大影响。 同时，在这我也准备了一份软件测试视频教程（含接口、自动化、性能等），需要的可以直接在下方观看就行，希望对你有所帮助！【公众号：互联网杂货铺】免费领取软件测试资料！
【2024最新版】Python自动化测试15天从入门到精通，10个项目实战，允许白嫖。。。
六、系统测试的概念 系统测试的定义：将已经集成好的软件系统，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行（使用）的环境下，对计算机系统进行一系列的组装测试和确认测试。
系统测试的对象：软硬件集合在一起的系统，集成后的产品，不应是独立的软件与硬件环境。不仅仅包括需测试的软件，还要包含软件所依赖的硬件、外设，甚至包括某些数据、某些支持软件的系统等。
目的：通过与系统的需求定义做比较，发现软件与系统定义不符合或与之矛盾的地方，以验证软件的功能和性能等满足其规约所指定的要求。
常见的系统分类：
纯软件：QQ.................软件和硬件：手机，PSP，空调，电梯软件硬件和维护人员：大型系统 七、系统测试的环境 真实环境：直接将整个系统和其交联的物理设备真实的建立链接，进行测试
优点：可以发现某些只能在真实环境下出现的问题
缺点：构建这样一个环境需要高昂的费用，它的测试运行也需要高昂的费用
仿真环境：它能够逼真的模拟被测试软件运行所需的真实物理环境的输入与输出，并且能够组织被测软件的输入，来驱动被测软件运行，同时接收被测软件的输出结果。
优点：仿真环境和真实环境的软件依赖是一样的，并且它能够保证测试的可重复性、完整性、可扩展性
Example 1：某系统环境搭建的要求
硬件环境：
CPU：主频2GHZ以上，4核及以上
内存：4GB及以上
硬盘：可用空间10G以上
软件环境：
平台要求：Windows XP/2003标准版+Apache2.2.X+Mysql5.0及以上版本
目录权限：目录/Attachment，/Cache及文件需要写的权限
推荐平台：推荐使用XAMPP作为安装介质
选用测试工具应考虑的因素：
1.测试工具与被测软件系统的匹配程度
2.测试工具提供的主要功能和辅助机制
3.测试工具的服务和技术支持
4.测试工具的价格
测试数据：
特点：
1.数据可以以消息、事物、记录、文件等形式存在
2.数据来源很多
3.真实数据最好，但在很多情况下不易或者不能得到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a056b52b2f2778a3b350e1a030519f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae4e836925f09bdf85632d360d8e062/" rel="bookmark">
			【往届期末试卷】毛概期末试卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 北京信息科技大学2020~2021学年
《毛泽东思想和中国特色社会主义理论体系概论》期末考试试卷
试题链接(点击跳转) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8687a3a67d8c4995190aecaa5963d8ba/" rel="bookmark">
			Kali Linux三种网络攻击方法总结（DDoS、CC和ARP欺骗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章使用的是Kali Linux的2020-4-installer-amd64版本，其他版本是否兼容我会尽快测试，如果你想更快知道你所用的版本是否兼容，可以在下面留言，我会在看到信息后的第一时间回复的！
Kali Linux的安装过程本文章不做过多说明，请自行百度
一、DDos攻击 首先，打开一个命令行
输入以下命令：
git clone https://github.com/Andysun06/ddos 提示如图所示
这样，用于DDos的数据包就已经下载到了你的Kali上
下面，进入你所下载的DDos文件夹，输入命令（注意大小写）：
cd ddos 本文用于演示的kali是2020年版本，用python执行ddos-p2.py，输入命令：
python ddos-p2.py 界面会如下图所示：
然后输入攻击对象的IP（本教程以我的博客为例）
再打开一个命令行窗口：
输入命令：
ping andysun06.gitee.io 即可获得攻击对象的IP地址。（获取IP后Ctrl+C可以结束ping）
然后回到刚刚的命令行窗口，输入ping到的IP地址：
Attack Port即攻击端口，一般服务器默认为80（更多内容请百度）
Attack Speed即攻击速度，数值越大越快，最大不能超过1000
按下回车，如果出现以下界面，即代表已经开始向该IP发起DDos攻击，也就成功了。
二、CC攻击 首先打开一个命令行窗口
先获得root权限，输入以下命令：
sudo su 然后输入你的账号密码（注意：输入后不会显示出来，不用担心是否输入进去，在输完后按回车，如果输入成功就会获得root权限）
然后输入以下命令：
ab -n 参数1 -c 参数2 网站地址 参数一是并发数（请求的用户量）
参数二是发送总量（请求的总次数）
（有兴趣的可以在百度上另外学习）
参数1，参数2和网站地址由自己设置，这里以 1000，1000，http://bjvcrrn.nat.ipyingshe.com/bbs/ 为例：
出现如上界面即代表已经对目标网址开始了CC攻击，如果出现如下界面，即代表CC攻击完成：
三、ARP欺骗 首先，ARP欺骗需要用到dsniff数据包（arpspoof 是 dsniff 的一个附属工具，所以我们需要安装的是 dsniff），安装命令如下：
apt-get install dsniff 当然，有可能会遇到部分数据包安装错误的情况，如果你遇到了这种情况，可以参考这个博文：Kali Linux 2020中使用arpspoof
如果你已经安装了dsniff数据包，就可以开始ARP欺骗了，首先，通过以下命令确定你的网卡名称和IP地址：
ifconfig 然后嗅探你所在WLAN下所有设备的IP地址，命令如下：
fping -g 本机IP地址/24 例如我的IP是192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8687a3a67d8c4995190aecaa5963d8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7cbfa9ad3161180964807b2f3592b3/" rel="bookmark">
			C&#43;&#43; 释放指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，释放指针通常使用delete或delete[]操作符；
如果指针指向的是单个对象，可以使用delete操作符进行释放；
在释放完内存后，最好将指针置为nullptr，以避免出现悬空指针（dangling pointer）问题；
void CShifangView::OnDraw(CDC* pDC) { CShifangDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here CString str1; int* ptr = new int; // 动态分配一个整型对象 *ptr = 9999; str1.Format("0X%x", ptr); pDC-&gt;TextOut(20, 20, str1); delete ptr; str1.Format("0X%x", ptr); pDC-&gt;TextOut(20, 50, str1); ptr = NULL; str1.Format("0X%x", ptr); pDC-&gt;TextOut(20, 80, str1); } delete ptr 之后ptr还是有值；ptr=NULL之后才是0；
如果指针指向的是数组，则需要使用delete[]操作符进行释放，
int* arr = new int[10];
......
delete[] arr; // 释放内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a7cbfa9ad3161180964807b2f3592b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f712f2b153faa7b4cc7f2918b7c90049/" rel="bookmark">
			张雪峰谈网络工程：太难就业了？毕业后可以干什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 每年报考网络工程专业的人数很多，但不少同学听说千万别学网络工程，害怕网络工程专业很难就业。下面就带大家深入了解一下网络工程专业毕业后可以干什么，包括网络工程专业的就业前景和方向等。
随着信息化时代的迅猛发展，网络工程专业自然而然成为了热门的就业方向之一。网络工程专业是指通过计算机科学技术和网络通讯技术，设计、建设、运营、维护网络系统的一门学科。 网络工程专业的就业方向和前景可以从以下几个方面进行分析：
一、就业方向 网络工程师：负责设计和实施网络系统，包括局域网、广域网、云计算、网络安全等。
网络管理员：负责网络系统的运行和维护，包括网络资源管理、网络安全管理、网络性能管理等。
网络安全工程师：负责网络安全监控、攻防漏洞检测、网络安全策略制定等。
系统集成工程师：负责将不同的技术和系统集成到一个整体系统中，包括软件、硬件、网络等。
云计算工程师：负责云计算系统的设计、安装、配置、管理等。
二、就业前景 市场需求大：随着信息化的发展，各行各业都需要网络工程师来设计和维护网络系统，网络工程师的市场需求量不断增加。
技术更新快：网络工程专业是一个技术更新很快的行业，需要不断学习新技术和新知识，这为网络工程师提供了不断学习和进步的机会。
薪资待遇高：网络工程师的薪资待遇一般都比较高，特别是在互联网行业和金融行业。
发展空间大：网络工程师可以通过不断学习和进修，提高自己的技能和水平，从而拓展自己的职业发展空间。
总之，张雪峰老师会评价网络工程专业是一个充满挑战和机遇的行业，对于有志于从事网络工程的人来说，选择网络工程专业是一个不错的选择。
如何入门学习网络安全【黑客】 【----帮助网安学习，以下所有学习资料文末免费领！----】 &gt; ① 网安学习成长路径思维导图
&gt; ② 60+网安经典常用工具包
&gt; ③ 100+SRC漏洞分析报告
&gt; ④ 150+网安攻防实战技术电子书
&gt; ⑤ 最权威CISSP 认证考试指南+题库
&gt; ⑥ 超1800页CTF实战技巧手册
&gt; ⑦ 最新网安大厂面试题合集（含答案）
&gt; ⑧ APP客户端安全检测指南（安卓+IOS）
大纲 首先要找一份详细的大纲。
学习教程 第一阶段：零基础入门系列教程
该阶段学完即可年薪15w+
第二阶段：技术入门
弱口令与口令爆破
XSS漏洞
CSRF漏洞
SSRF漏洞
XXE漏洞
SQL注入
任意文件操作漏洞
业务逻辑漏洞
该阶段学完年薪25w+
阶段三：高阶提升
反序列化漏洞
RCE
综合靶场实操项目
内网渗透
流量分析
日志分析
恶意代码分析
应急响应
实战训练
该阶段学完即可年薪30w+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f712f2b153faa7b4cc7f2918b7c90049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4f3b207495396e7e12335abbc8a1b4/" rel="bookmark">
			如何用python进行数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概的学习流程如下，在用python进行数据分析的时候通常用的两个包是numpy和pandas
一、一维数据分析
在pandas中的一维数据结构Series, 在numpy中的一维数据结构叫array，
panads的series是基于numpy的array，并且功能更多，必须先掌握numpy的array。
# 导入numpy包 &gt;&gt;&gt; import numpy as np # 导入panads包 &gt;&gt;&gt; import pandas as pd # 注意不要写成panads 1.Numpy一维数组
# 定义：一维数组array a = np.array([2,3,4,5]) # 必须要在前面加上np # 以下进行切片查询 a[0] result 2 a[1:3] array([3, 4]) for i in a: print(i,end = ' ') 2 3 4 5 # 查看数据类型dtype a.dtype dtype('int32') 其实numpy的一维数组的定义和查询和列表是类似的
2.Numpy一维数组与列表的区别
numpy 可以进行向量化运算，属于线性代数运算numpy数组中的元素都必须是同一种数据类型，而列表可以是不同的数据类型 # 统计计算 平均值 a.mean() 3.5 # 计算标准差 a.std() 1.118033988749895 # 向量化计算：乘以标量 b = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4f3b207495396e7e12335abbc8a1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1544a06aa3f795a3a87557373bd56cb9/" rel="bookmark">
			数字逻辑电路入门：从晶体管到逻辑门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字逻辑电路入门：从晶体管到逻辑门 这是数字逻辑电路中最基础的部分。但是并非那么容易理解。
1、晶体管 mosfet：场效应晶体管，是电压控制元件。cmos：是指由mos管构成的门级电路通常是互补的。BJT：一种三极管，是电流控制元件，用来放大电流，功耗大于mos管。nmos：衬底是p型半导体，源极和漏极是n型掺杂区域。适合用来导通低电压，不适合导通高电压。pmos：和nmos相反，衬底是n型半导体，源极和漏极是p型掺杂区域。适合用来导通高电压，不适合导通低电压。pmos用在上拉网络，nmos用在下拉网络。 2、逻辑门 互补传导规则：nmos串联，pmos必须并联；nmos并联，pmos必须串联。保证上拉网络和下拉网络不会同时导通，即不出现短路。
非门：输入a，输出y，消耗2个晶体管 一个pmos，栅极接a，源极接vcc，漏极接y一个nmos，栅极接a，源级接y，漏极接gnd分析，a=1，mos的栅极上表面聚集正电荷，下表面聚集负电荷。pmos衬底是n型半导体，本身有自由电子，因此源极和漏极仍然断开。nmos衬底是p型半导体，本身有自由空穴，聚集负电荷之后，源极和漏极接通，因此y=0。 与门：消耗6个晶体管 一个与非门级联一个非门 或门：消耗6个晶体管 一个或非门级联一个非门 或非门：消耗4个晶体管 两个pmos串联，栅极接a，b，源极接vcc，漏极接y两个nmos并联，栅极接a，b，源极接vcc，漏极接y分析，a=0，b=0，pmos均导通，nmos均断开，y=1；a、b有一个为1，下拉网络导通，上拉网络断开，y=0 与非门：消耗4个晶体管 两个pmos并联，栅极接a，b，源极接vcc，漏极接y两个nmos串联，栅极接a，b，源极接vcc，漏极接y分析，a=1，b=1，pmos均断开，nmos均导通，y=0；a、b有一个为0，下拉网络断开，上拉网络导通，y=1 异或门： 实现方式两种，一个使用10个晶体管，一个使用12个晶体管参考：COMS门电路的设计及其优化–以异或门为例 同或门三态门 3、卡诺图化简 以下图为例：
画出卡诺图，注意格雷码序；画圈： 从大到小画圈，16格、8格、4格、2格、1格；每个圈都要圈住1，最终圈住所有1；可环绕画圈。 写出SOP（sum-of-products） 每个圈代表一个product，读法是“相异相消”；将所有product相加；Y = b+c+a;（按照红、绿、蓝的顺序写的product） 补充：“相异相消” 比如 Y = A B + A B ˉ = A ( B + B ˉ ) = A Y = AB+A \bar B = A(B+\bar B) = A Y=AB+ABˉ=A(B+Bˉ)=A； B + B ˉ = 1 B+\bar B =1 B+Bˉ=1恒成立；圈中变量相异的，则无需管，相同的如实记录。比如红圈，c相异，a相异，b相同且为1，则记录为b。 另一个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1544a06aa3f795a3a87557373bd56cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e8e60f15d8b5648eae2a6700ec64a7/" rel="bookmark">
			C&#43;&#43;八股文--基础详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 智能指针
2. 内存分配
3. 指针参数传递和引用参数传递
4. 关键字static
5. 关键字const
7. 关键字define、const、typedef、inline
8. 重载、重写和重定义
9. 强制转换
10. 指针和引用
11. 野指针和悬空指针
12. 构造函数
13. 堆和栈
14. 函数传参
15. malloc/free和new/delete
16. volatile和extern
17. 类大小
18. 结构体内存对齐
19. 内存泄漏
20. 预处理、编译、汇编、链接
21. 命名空间
22. 模版
1. 智能指针 优点
（1）避免内存泄漏。底层维护一个类，作用域结束可以自动释放内存。
（2）共享指针便于传播和释放。例如多线程使用同一个对象时析构问题。
auto_ptr
（c++98用，c++11已放弃）。如下，p2剥夺了p1所有权，访问p1会报错。
auto_ptr&lt;std::string&gt; p1 (new string ("hello")); auto_ptr&lt;std::string&gt; p2; p2 = p1; unique_ptr
独占所有权的指针，即同一时间只能有一个std::unique_ptr指向同一个对象。如下，P4 = P3会报错，因为P3不能再指向有效数据。
unique_ptr&lt;string&gt; p3 (new string (auto)); unique_ptr&lt;string&gt; p4; p4 = p3; shared_ptr
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e8e60f15d8b5648eae2a6700ec64a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f42c8fbff53bb07d636bd161323b33d/" rel="bookmark">
			C&#43;&#43;八股文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础 C++八股文--基础详解-CSDN博客
二、类和面向对象 C++八股文--类和面向对象详解-CSDN博客
三、STL 持续更新中……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933e67a7c67a450827cb048440659fa6/" rel="bookmark">
			C&#43;&#43;八股文--类和面向对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 类
1.1. 类定义
1.2. 对象创建访问
1.3. 类成员函数
1.3 类访问修饰符
1.4. 类构造函数和析构函数
1.5. 拷贝构造函数
1.6. 友元
1.7. 内联函数
1.8. this指针
1.9. 指向类的指针
1.10. 静态成员
2. 面向对象
2.1. 继承
2.2. 多态
2.3. 重载运算符
2.4. 重载函数
1. 类 1.1. 类定义 类定义包含：class关键字；类名称；类主体在一对花括号中，有类成员变量和类成员函数。本质上定义了一个数据蓝图，类对象有成员和操作。
class Box { public: double length; // 盒子长 double breadth; // 盒子宽 double height; // 盒子高 }; 静态建立：建立一个类对象，编译器为对象在栈中分配内存。
动态建立：Box *b = new Box(); 动态建立一个对象，编译器为对象在堆空间分配内存。
组合类：一个类的数据成员是另一个类的对象。创建时既要对基类成员初始化，又要对内嵌对象初始化。
1.2. 对象创建访问 Box Box1; // 声明 Box1 Box Box2; // 声明 Box2 // 访问用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933e67a7c67a450827cb048440659fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d75a5ab0e8ce55eff86fe65aafedcb3/" rel="bookmark">
			网络工程和网络安全的区别在哪里？就业方向薪资有何不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网发展，网络已经深入到日常生活和工作当中，网络工程和网络安全已成了大多数人心中热门的行业选择。因此，大部分人都容易把网络工程和网络安全混淆。
网络工程：就是按照国家和国际标准建设计算机网络系统的全过程。具体来说，网络工程是将各种网络设备、网络操作系统和应用系统按照用户的要求进行集成和组合。在实践中，路由和交换是重点，不会干涉其他工作。
主要在国家机关、科研机构、学校、工厂等企事业单位从事计算机应用软件及网络技术的研究、设计、制造、运营、开发等工作，岗位有互联网、电子商务、计算机服务等。
网络安全：工作大部分基于编程、shell、script、C源码，是一种保护计算机网络免受入侵者（无论是定向攻击还是条件恶意软件）攻击的技术。网络状态分析。对网络系统进行安全评估和安全加固，设计安全网络解决方案；在发生网络攻击或安全事件时，改进服务以帮助用户恢复系统和调查证据。为客户网络架构提出合理的网络安全解决方案;负责协调解决方案的定制实施、部署和开发，并假设解决方案是在线的;负责协调公司网络安全项目的售前、售后支持。
“互联网+”时代能够支撑国家网络空间安全领域的具有较强的工程实践能力，系统掌握网络空间安全的基本理论和关键技术，能够在网络空间安全产业以及其他国民经济部门，从事各类网络空间相关的软硬件开发、系统设计与分析、网络空间安全规划管理等工作。
从业方面
网络工程师：
技术要求：对当代数字通信系统有一定的了解，理论上要求精通网络二、三层通信原理与方式，实际操作中偏重路由和交换的实施，另外还需要对综合布线（一层）有一定的了解。
薪资待遇：该行业的人才需求量还是比较大的，据英才网数据显示，每年的人才缺口达到了60万左右。2021年较2020年下降1%，平均工资￥8K，其中拿6K-10K工资的占比最多，达27.1%，数据统计依赖于各平台发布的公开薪酬。
网络安全工程师：
技术要求：除了具备网络工程师的理论基础外，对网络安全还需要有更多的了解，在实际操作中偏重网络安全的实施（过滤、策略、认证），偶尔也需要对三层以上的通信有一定操作。
薪资待遇：人才需求140万左右，核心原因是市场需求大于人才供给，而每年高校安全专业培养人才仅有3万余人，也正是因为网络安全人才的稀缺，国家为了大力加强网络安全人才建设，薪资待遇方面是非常可观的。据《2021瀚纳仕亚洲薪酬指南》显示，网络安全相关基层工作人员的年薪均在30万元到80万元（人民币）区间浮动。
如果你对网络安全感兴趣，学习资源分享（嘿客入门教程） 如果你对网络安全入门感兴趣，那么你点击这里👉《嘿客&amp;网络安全入门&amp;进阶学习籽源包》
如果你对网络安全感兴趣，学习资源免费分享，保证100%免费！！！（嘿客入门教程） 如果你对网络安全入门感兴趣，那么你需要的话可以
点击这里👉CSDN大礼包：《嘿客&amp;网络安全入门&amp;进阶学习资源包》免费分享
👉网安（嘿客）全套学习视频👈
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
👉网安（嘿客红蓝对抗）所有方向的学习路线👈
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
👉嘿客必备开发工具👈
工欲善其事必先利其器。学习嘿客常用的开发软件都在这里了，给大家节省了很多时间。
这份完整版的网络安全（嘿客）全套学习资料已经上传至CSDN官方，朋友们如果需要点击下方链接也可扫描下方微信二v码获取网络工程师全套资料【保证100%免费】 如果你有需要可以点击👉CSDN大礼包：《嘿客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aeed762168ed88d7928779b27661634/" rel="bookmark">
			关于目标检测任务中，XML(voc格式)标注文件的可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近在弄关于目标检测的任务，因为检测的图片和标签是分开的，可视化效果不明显，也不知道随便下载的数据集，标注信息对不对。网上看了好多代码，代码风格和本人平时不同，看起来麻烦，也不知道怎么更改，于是按照自己的编码风格，写了个可视化脚本，这里做下记录
本章可视化的数据格式是VOC格式，即标注文件是XML文件，边界框是左上角和右下角的两个点
下面是代码的目录结构，1.jpeg 是数据图像，1.xml是对应的标签信息
result.png 是保存的绘制好边界框的图像
2. 关于代码 代码部分
2.1 自定义函数传入的路径 如下，根据上图摆放好的数据目录，将img_path 传入图片。
对应的 xml 这里是代码生成的，因为大部分数据的标签和训练图像仅仅是目录和后缀的不同，文件名是相同的
2.2 自定义可视化函数 自定义函数传入的三个参数就是原始图片、图片对应的xml标签，save 是展示后是否保存，这里默认保存
如下，parse_xml_to_dict 也是自定义函数，大概就是将xml文件按照树状图的形式解析成层层的字典。看控制台的输出部分，data 就是xml 文件的内容
接下来就是根据解析的字典，读取里面的边界框和检测类别
XML标注格式的文件，目标在&lt;object&gt;下面
因为每张图片的目标不是只有一个，所有用for循环遍历，如下每个i就是一个完整的目标
通过字典的key将对应的value读取出来，然后用列表仅仅保存边界框和分类的名称
值得注意的是，XML标注的目标类别就是真实的类别，而非yolo格式的0 1 2 索引，所以这里绘制边界框是不需要json文件的
xml生成json类别字典文件，可以查看：目标检测篇：如何根据xml标注文件生成类别classes的json文件
关键的信息提取好了，就可以绘制边界框了，通过打印，可以发现ob里面存放的就是我们需要的部分（name、xmin、ymin、xmax、ymax）
绘制的部分很简单，利用cv就行了
2.3 绘制结果 因为大部分训练图像size很大，cv窗口展示不出来，所以这里查看生成的result.png文件
想要同时展示多张绘制好的图片，可以利用for循环嵌套，或者用dataloader和plt结合等等待会看看能不能把YOLO格式txt的可视化数据写出来，因为yolo标注的相对信息和类别索引，可能会相对复杂一些 3. 完整代码 如下：
from lxml import etree import cv2 # 读取 xml 文件信息，并返回字典形式 def parse_xml_to_dict(xml): if len(xml) == 0: # 遍历到底层，直接返回 tag对应的信息 return {xml.tag: xml.text} result = {} for child in xml: child_result = parse_xml_to_dict(child) # 递归遍历标签信息 if child.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aeed762168ed88d7928779b27661634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a06041c78d150044cca779bfaee83c/" rel="bookmark">
			OSPF多区域配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重点
1、ABR：骨干区域和非骨干区域相连的设备
2、ASBR：设备具有宣告能力的路由设备
3、宣告的3种形式：
1、network 宣告内网 2、import-routr static 宣告外网【并且宣告功能很多】静态路由
3、default-routr-advertise 宣告外网 【专属默认路由宣告】
脚本
AR1
system-view sysname AR1
undo info-center enable dhcp enable interface GigabitEthernet 0/0/1
ip address 192.168.1.254 24
dhcp select global quit
interface GigabitEthernet 0/0/0
ip address 192.168.12.1 24
quit
ospf 1 router-id 1.1.1.1
area 12
network 192.168.1.0 0.0.0.255
network 192.168.12.0 0.0.0.255
quit
quit
ip pool 1
network 192.168.1.0 mask 24
gateway-list 192.168.1.254
dns-list 16.6.6.66
lease day 3 hour 12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a06041c78d150044cca779bfaee83c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdfd5a2543d2ef2109d7bb418e3b2e8/" rel="bookmark">
			Android应用之【隐藏桌面图标的一种方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android10之前的版本，应用程序调用方法PackageManager.setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP)可以隐藏在桌面上的图标，这样的程序如果被偷偷安装后，机主本人可能并不知道自己的手机被安装了某些程序。
但是android10之后的版本，如果应用中使用了四大组件（activity ，service ，broadcast， contentprovider)或者需要动态申请权限，这个函数调用将失去效果，简单测试后，调用该方法后，程序的桌面图标效果如下：
若AndroidManifest.xml中activity的icon和roundIcon这两者都不是黑色，显示资源文件中定义的图标像素。如果activity中的icon和roundIcon同时设置为黑色，则icon不显示，roundIcon显示为系统默认的空白图标。 因此，传统的方法调用将不再适用了。
网上流传一种方式是，设置activity的label为空字符串“”，icon和roundIcon的像素值为0的黑色图标。该方案链接为：
Android10.0应用图标隐藏方案（7.0-10.0）
上述方法中，icon和roundIcon的图标资源文件如下：
上文中，theme字段透明的设置：
实际测试后，这种方法的隐藏效果有重大缺陷，在调用本文开头的PackageManager.setComponentEnabledSetting方法后，桌面上的图标虽然被抹去了，但是留下了一个图标大小的黑影，并不像作者在文中所说的那样"完全看不到", 作者源码我在android12上亲自测试过，这时候，点击图标虽然完全没有效果，但是视觉上的缺陷是无法容忍的。
通过测试，我发现有一种隐藏图标的方式，其实现步骤如下：
设置主activity的intent-filter字段，其格式必须满足如下两点，一是在启动节点的activity中，包含默认的启动属性"android.intent.action.MAIN"和"android.intent.category.LAUNCHER"，二是还要添加别的属性，比如android.intent.action.VIEW，这样作的目的就是破坏应用程序启动节点的默认设置，使之含有别的行为和动作，这样程序启动后就不能正常显示图标。 比如启动节点的如下设置：
使用Android scheme方式从浏览器启动（或者另外再安装一个程序，当作此程序的启动器）。要注意的是，浏览器scheme启动方式不是说客户端的浏览器访问路径触发启动应用程序，我原先以为，在客户端的浏览器中输入形如myscheme://myhost这样的url就可以触发程序的执行，但是反复测试没有效果，于是想到，会不会这种scheme方式，说的是访问服务器的web页面，该地址的页面中有个形如 “&lt;a href=“myscheme://myhost”&gt;点击此处启动Android程序&lt;/a&gt;” 这样的标签，用户在浏览器中点击这个标签后，即可触发应用中Android的启动组件。 这个简单的逻辑，无形中浪费了很多时间。
源码如下，上述描述的内容，只需要关注测试项目中AndroidManifest.xml中的Application节区属性。
源码链接地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2d379796ff11a410f09d058d162194/" rel="bookmark">
			P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址如下：P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)
水了道题
学了求最小公倍数和最大公因数的新方法
我对辗转相除法这个东西有所耳闻，但是从来没有用过
所以我只会枚举法求这两个东西
而且两个数的最小公倍数和最大公因数的乘积等于这两个数的乘积，这个也是今天才知道（虽然说想了想确实是这样，但是没指出来就是不知道）
怪我小时候这两个东西没学好
代码如下：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int f_gcd(int a, int b);//求最大公因数 int count, result, num[20]; int main(void) { int x0, y0; scanf("%d%d", &amp;x0, &amp;y0); //求出y0的所有因数，去除不能被x0整除的数 for(int i = 1; i &lt; (int)sqrt(y0); i++) if(!(y0 % i)) { if(!(i % x0)) num[count++] = i; if(!((y0 / i) % x0)) num[count++] = y0 / i; } //求P，Q的个数 for(int i = 0; i &lt; count - 1; i++) for(int j = i + 1; j &lt; count; j++) { int gcd = f_gcd(num[i], num[j]); int lcm = num[i] * num[j] / gcd; if(gcd == x0 &amp;&amp; lcm == y0) result += 2; } //输出 if(x0 == y0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2d379796ff11a410f09d058d162194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfcdcb1da00db986c7157262146c886/" rel="bookmark">
			Java实战项目六：进销存管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、系统概述二、关键知识点梳理（一）数据库设计与连接（二）实体类与关系映射（三）集合框架的应用（四）CRUD操作与事务管理 三、系统架构与模块划分（一）系统架构设计（二）功能模块详解 四、开发实施步骤1、数据库初始化与连接配置2、实体类与数据映射定义3、业务逻辑实现4、接口设计与前端展示5、数据操作与事务控制 五、运行效果描述六、项目总结 一、系统概述 进销存管理系统：设计并实现一个功能完善的进销存管理软件，以Java或.NET等现代编程语言为基础，结合MySQL或SQL Server等关系型数据库技术，实现实时的商品库存管理、采购记录与销售记录的增删改查等功能。通过实际操作数据库连接与数据操作，提升对集合框架及数据库访问技术的深度应用能力。 二、关键知识点梳理 （一）数据库设计与连接 设计符合进销存业务逻辑需求的数据库表结构，如商品信息表、供应商信息表、采购单表、销售单表和库存流水表等。使用JDBC或ORM（如MyBatis）等技术进行数据库连接与操作。 （二）实体类与关系映射 根据数据库表结构创建对应的实体类，实现属性与数据库字段的映射。应用关联关系（一对一、一对多、多对多），如商品与库存记录之间的关联。 （三）集合框架的应用 利用ArrayList、LinkedList、HashMap等集合框架组件存储和处理商品列表、订单明细等复杂数据结构。实现基于集合的操作，如批量添加、删除、查询、统计以及排序等。 （四）CRUD操作与事务管理 实现商品库存的增删改查操作，包括入库、出库、盘点等场景下的库存变动。管理采购单与销售单的生命周期，确保数据完整性，应用事务管理机制保证ACID特性。 三、系统架构与模块划分 （一）系统架构设计 用户界面层（UI Layer）：设计简洁易用的用户界面，提供输入查询、报表展示等功能。业务逻辑层（Business Logic Layer）：封装商品管理、采购管理、销售管理、库存管理等核心业务逻辑。数据访问层（Data Access Layer）：负责与数据库交互，执行SQL语句，完成数据持久化操作。 （二）功能模块详解 商品管理模块：实现商品信息的录入、修改、删除和查询功能。供应商管理模块：维护供应商信息，为采购流程提供支持。采购管理模块：记录采购订单，更新库存，并生成相应的财务凭证。销售管理模块：处理销售订单，扣减库存，并同样生成财务凭证。库存管理模块：实时监控库存状态，进行库存预警，支持库存盘点操作。 四、开发实施步骤 1、数据库初始化与连接配置 创建数据库表结构，编写数据库连接池配置文件。 2、实体类与数据映射定义 根据数据库表设计实体类及其属性，实现数据库与对象的相互转换。 3、业务逻辑实现 分别针对各个功能模块编写业务逻辑代码，涉及集合框架的深度运用。 4、接口设计与前端展示 设计用户友好界面，使用API或MVVM模式将后端业务逻辑与前端展示相结合。 5、数据操作与事务控制 在进行增删改操作时，合理利用事务确保数据一致性，避免并发问题。 五、运行效果描述 描述系统在实际操作中的表现，如如何便捷地录入和查询各类数据，如何动态反映库存变化，以及如何快速生成进销存报表等。 六、项目总结 通过构建进销存管理系统，学习者能够深化对数据库设计与操作、集合框架高级应用、事务管理等方面的理解与实践能力。同时，该项目也是企业级应用开发的良好范例，有助于培养良好的系统分析和设计思维，为后续大型项目的开发奠定基础。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36e25228ec4b18dd99094cdf5674684/" rel="bookmark">
			程序员常用的学习网站有哪些？10大网站整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CSDN -专业IT技术社区（https://www.csdn.net/）
中国专业IT社区CSDN (Chinese Software Developer Network) 创立于1999年，致力于为中国软件开发者提供知识传播、在线学习、职业发展等全生命周期服务。全力为IT开发者打造分享技术心得、讨论技术话题的信息平台。
2、博客园-开发者的网上家园（https://www.cnblogs.com/）
博客园创建于2004年1月，是一个面向开发者的知识分享社区，属于一个纯技术的交流空间；有很多IT精英每天在这里分享着精彩的原创内容；
3、Github-全球领先的软件开发平台（https://github.com/）
GitHub 于 2008 年 4 月 10 日正式上线，除了Git代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过900 万（2015年数据），托管版本数量也是非常之多，其中不乏知名开源项目Rubyon Rails、jQuery、python等。
4、Stack Overflow-开发人员学习、共享、建立职业的地方（https://stackoverflow.com/）
Stack Overflow是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML。在问题页面，不会弹出任何广告，销售信息，JavaScript 窗口等。
5、码农网-程序员编程资料和编程经验分享平台（码农网官网_IT码农网_码农网站 | 码农网）
6、开源中国社区-中文开源技术交流社区（https://www.oschina.net/）
开源中国成立于2008年8月，是目前国内最大的开源技术社区，形成了由开源软件库、代码分享、资讯、协作翻译、码云、众包、招聘等几大模块内容，为IT开发者提供了一个发现、使用、并交流开源技术的平台。
7、猿圈-笔面试测试系统平台，测试符合标准的，可以申请直接定向内推到企业；（https://appazwem2zu4201.h5.xiaoeknow.com/homepage?entry=2&amp;entry_type=2001）
8、掘金-帮助开发者成长社区（https://juejin.im/）
掘金是一个帮助开发者成长的社区，是一个面向互联网技术人的内容分享平台。
9、LeetCode-算法学习（力扣 (LeetCode) 官网 - 全球极客挚爱的技术成长平台）
10 DZone-（https://dzone.com/）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c147e1bd58f41ec1cbca85d3669c117/" rel="bookmark">
			Jenkins集成部署java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Jenkins简介安装 Jenkins简介 Jenkins能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象的展示项目构建的趋势和稳定性。
官网
安装 在官网下载windows版本的Jenkins
但是我点击这里浏览器没有反应，所以我去下载旧版本。
.
如果版本过低可能会导致插件无法下载的错误
下载完成后，在控制台启动Jenkins
使用命令 java -jar jenkins.war
启动成功后登录 localhost:8080 进入页面
插件安装完成后，用admin账户登录
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/79/">«</a>
	<span class="pagination__item pagination__item--current">80/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/81/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>