<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0363c994e2a15890744008485741f7c7/" rel="bookmark">
			Python-使用turtle模块绘制同心圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用画图模块turtle绘制同心圆 import turtle
t = turtle.Pen() #获得画笔
my_color=("red","green","yellow","black")
t.width(4) #画笔宽度
t.speed(0.2) #画笔画的速度
for i in range(10): #0,1,2,3,4
t.penup() #抬起笔
t.goto(0,-i*10)
t.pendown()#放画笔
t.color(my_color[i%len(my_color)]) # 对my_color的数量取余数
t.circle(10+i*10)#半径100
#t.goto(0,-100)#画笔向下移动100
#t.circle(200)
#t.goto(0,-200)
#t.circle(300)
turtle.done() #程序执行完，窗口仍然在
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0668279311c201d69554d93a1616dde7/" rel="bookmark">
			让应用手动管理应用的数据目录 android:manageSpaceActivity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用程序管理器点击软件显示的页面，我们可以点击清除数据按钮，这样所有关于该app的缓存在手机的数据都清除掉了。类似于新安装的一样。但是有时候，用户不想全部删除，比如登录信息等。就有需求如果应用能够手动管理应用的数据目录的需求，那么android系统支持这个功能吗？当然支持了，如图：
红框处，显示的叫管理空间，而不是我们常常见到的清除数据。当点击这个按钮能够跳转到我们的空间管理页面就做到了，那么如何实现呢？
只需要在AndroidManifest.xml中的application标签添加一个android:manageSpaceActivity
指定一个Activity来管理数据。实例如下：
&lt;application ……………….. android:manageSpaceActivity="com.mingli.test.ManageSpaceActivity"&gt; &lt;/application&gt; ManageSpaceActivity当然也要在AndroidManifest.xml声明为activity
综上所述，如果想自己管理数据目录，则可以使用android:manageSpaceActivity属性来控制，而不是默认的全部清除了/data/data/包名/里面的所有文件。当然我们还可以扩展，比如清除SD卡上的数据，如果拥有root权限，还可以用它当成垃圾清理。
参考：http://tangke.iteye.com/blog/1817857
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ef4d716462fa72f1714b8a3f720c10/" rel="bookmark">
			使用find_package（）链接不同版本的OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先明确find_package()有两种搜索模式：
Module模式
搜索CMAKE_MODULE_PATH指定路径下面的FindXXX.cmake文件，在文件中定义了XXX_INCLUDE_DIRS和XXX_LIBRARIES变量的值。
Config模式
搜索XXX_DIR指定路径下面的XXXConfig.cmake文件，在文件中定义了XXX_INCLUDE_DIRS和XXX_LIBRARIES变量的值。
CMake默认先采用Module模式在CMAKE_MODULE_PATH中进行搜索，其中CMAKE_MODULE_PATH可通过set进行指定路径。若找不到再采用Config模式进行搜索
OpenCV的.cmake文件：
OpenCV使用的是OpenCVConfig.cmake文件，所以对于不同版本的OpenCV，可以先使用 locate OpenCVConfig.cmake查找其位置，确定位置后，在CMakeLists.txt中添例加set(OpenCV_DIR "/opt/ros/kinetic/share/OpenCV-3.3.1-dev")便可找到指定版本的OpenCV。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24e1eb59686f875cd6480ccea50b9db/" rel="bookmark">
			python学习笔记--项目的组织结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python的项目组织结构包括：包（顶级）、 模块、 类（ 函数 变量是类的特性）包是“文件夹”，模块是“文件“，是管理组织单元。模块存在包下一个包下可以存在多个模块。每个模块又可以有多个类、函数、变量、业务逻辑右图所示便是一个类： 右图中包“seven”下的c5.py和包“six”下的c5.py，二者包名不同但模块名相同。在此情况下若实现调用需要在相同模块前加上包的名字（加上包的名字就形成了路径，也就是命名空间） 名为“__init__.py”的模块的作用是区别普通文件夹和包。在运行含该模块的包时，该模块自动运行；在调用时，__init__.py的名字就是包名 __init__.py 经常做一些初始化工作
__init__.py 通过__all__来决定导入的模块
__init__.py 可以批量导入
导入python的语法 ： （1）import 。import后面只能加模块 ，不能在import下添加模块的变量名。不可以加变量名！！！！
若想引用该模块下的变量，要通过模块.变量的格式进行引用，
简化路径的方法：import t.c7 as m ；把路径简化成m。
该引用方法的好处是一眼可以看出a变量是属于哪个包的那个模块 ，坏处是写的比较繁琐 （2） from module import 变量/def（函数）。
from（） import（）方法导入的是变量（可以直接使用变量）， import导入的是模块
“*”一块把c7里的变量都导入到c8模块中
也可以使用图中方法限制“*”的全部引用，若加上__all__（内置变量），则只可以使用“*”引用指定变量
C7、c8不在同级目录 命名空间问题
From c9 import a,b,c 。导入a b c如果想导入的太多， “（）”“\”实现代码的换行包和模块是不会被重复导入的 要避免循环导入 修改：
间接的循环引入
修改
导入模块后就会执行模块内的所有代码
__pycache__ 是编译的解释器，自动生成，可以提升python的运行效率 入口文件的概念：一个应用程序通常只有一个入口文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bca4a6c6b329e5abfe6fb3d7f3b0ac/" rel="bookmark">
			Flutter基础（八）手势相关Widget：GestureDetector和Dismissible
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于公众号「刘望舒」
ReactNative入门系列 React Native组件 Flutter基础系列
前言 移动开发中，用户交互是一个重要的环节，在Android中的触摸、点击、滑动等事件处理都提供了相关的Api，在Flutter中也是一样的，是由Widget来实现的。 Flutter中的手势系统有两个独立的层。第一层是原始指针事件（pointer events），它描述了屏幕上指针，比如触摸、鼠标、触控笔的位置和移动。 第二层是手势，由一个或多个指针移动组成的动作会被识别为不同的手势。
1.指针事件 指针表示用户与设备屏幕交互的原始数据。有四种类型的指针事件：
PointerDownEvent：指针接触到屏幕的特定位置。PointerMoveEvent： 指针已从屏幕上的一个位置移动到另一个位置。PointerUpEvent： 指针已停止接触屏幕。PointerCancelEvent：此指针的输入不再指向此应用，通俗来讲就是事件取消。 在指针按下时，Flutter框架会对当前应用程序执行命中测试，以确定指针与屏幕接触的位置存在哪个Widget上，然后将PointerDownEvent事件（以及该指针的后续事件）调度到命中测试找到的最内部的Widget，事件的分配路径为：从最里面的Widget到树的根路径上的所有Widget。
2.手势 手势表示由一个或多个指针移动组成的动作。主要有以下几种：
点击
onTapDown：指针已经在特定位置与屏幕接触。 onTapUp：指针停止在特定位置与屏幕接触。 onTap ：点击事件触发。 onTapCancel： 先前指针触发的onTapDown不会再触发点击事件。
双击
onDoubleTap：用户快速连续两次在同一位置轻敲屏幕。
长按
onLongPress：指针在相同位置长时间保持与屏幕接触。
垂直拖动
onVerticalDragStart：指针已经与屏幕接触并可能开始垂直移动。 onVerticalDragUpdate 指针与屏幕接触并已沿垂直方向移动。 onVerticalDragEnd 先前与屏幕接触并垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动。
水平拖动
onHorizontalDragStart：指针已经接触到屏幕并可能开始水平移动 onHorizontalDragUpdate：指针与屏幕接触并已沿水平方向移动 onHorizontalDragEnd：先前与屏幕接触并水平移动的指针不再与屏幕接触，并在停止接触屏幕时以特定速度移动。
如何对这些手势进行检测呢？可以使用GestureDetector。
3.使用GestureDetector 要想检测单击、双击、垂直拖动等手势，只要用GestureDetector嵌套要检测手势Widget并实现想要监听的手势的方法就行。
import 'package:flutter/material.dart'; void main() =&gt; runApp(GestureDetectorWidget()); class GestureDetectorWidget extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: "Flutter", home: Scaffold( appBar: AppBar( title: Text("GestureDetector示例"), ), body: Center( child: GestureDetector( child: Text('手势识别'), onTap: () { print('点击'); }, onDoubleTap: () { print('双击'); }, onLongPress: () { print('长按'); }, onHorizontalDragStart: (DragStartDetails details) { print('水平拖动'); }, ), ), ), ); } } 复制代码 只需要在手势识别这个文字上进行操作，那么对应的手势就会被打印出来。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07bca4a6c6b329e5abfe6fb3d7f3b0ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a3f980f007593d799c4ac597f12310/" rel="bookmark">
			MATLAB中对tif格式栅格影像读取-保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB中对tif格式栅格影像读取-保存，点滴学习，贵在记录。
MATLAB中对tif格式栅格影像读取-保存 在做水质反演的过程中，用到了MATLAB，但对这个工具一无所知。研究的总体思路是先建立整体构架，然后查阅每一步的具体实现的语法，结合MATLAB help，逐渐实现每一步。
geotiffwrite 基础语法
geotiffwrite(filename,A,R)
geotiffwrite(filename,X,cmap,R)
geotiffwrite(…,Name,Value)
输入参数变量释义：
filename：输入文件的名称和位置，文件扩展名必须是 “.tif” 或者 “.TIF”，变量类型为字符向量。
A：要导出的影像数据，为MNP的矩阵。坐标系为地理坐标，且默认为WGS-84，指定坐标可通过’GeoKeyDirectoryTag’和’CoordRefSysCode’实现。数据类型
数据类型 double | single | uint8 | uint16 | uint32 | uint64 | int8 | int16 | int32 | int64 | logical
R：空间参考信息。
空间引用信息，指定为地理栅格引用对象、引用矩阵或引用向量。
如果您正在处理投影坐标系中的图像坐标，而R是一个地图栅格引用对象或引用矩阵，则相应地指定“GeoKeyDirectoryTag”或“CoordRefSysCode”。
X：待补充
cmap：RGB图像，为M*3的矩阵
示例
% 影像的读取 basename = 'boston_ovr'; imagefile = [basename '.jpg']; RGB = imread(imagefile); worldfile = getworldfilename(imagefile); R = worldfileread(worldfile, 'geographic', size(RGB)); %读取空间参考信息 %导出影像 filename = [basename '.tif']; geotiffwrite(filename, RGB, R) % 显示影像 figure usamap(RGB, R) geoshow(filename) 示例2 读取tif处理后保存tif
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a3f980f007593d799c4ac597f12310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a028f757b314dc5138d5a3b679c7f7/" rel="bookmark">
			Android 7.1.1中SystemProperties 设置属性无限问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 7.1.1中SystemProperties详解
https://blog.csdn.net/yin1031468524/article/details/67640786
另外，如果满足了上面的条件，如果设置 属性但是没有生效，可能是权限问题
通过 adb shell dmesg 分析如下log,可以看到是缺乏 Te权限，加上就可以。
[ 172.608096] init: avc: denied { set } for property=persist.nfc.broadcast.disable pid=5954 uid=1000 gid=1000 scontext=u:r:system_app:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service permissive=0
[ 172.608130] init: sys_prop: permission denied uid:1000 name:persist.nfc.broadcast.disable
[ 172.609701] init: avc: denied { set } for property=persist.nfc.broadcast.disable pid=5954 uid=1000 gid=1000 scontext=u:r:system_app:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service permissive=0
修改方法：
\system\sepolicy\system_app.te
allow system_app default_prop:property_service set;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0554a51e3f2bce9953c219fe42b9c40d/" rel="bookmark">
			面向对象程序设计思想的个人理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、与传统的面向过程的程序设计方法有何不同
举个例子，比如希望完成“猪八戒吃西瓜”这样一件事情，两种设计思想和方法就会完全不同：
在面向过程的程序世界里，一切以函数为中心，函数最大，因此这件事情会用如下语句来表达：
吃(猪八戒,西瓜)；
在面向对象的程序世界里，一切以对象为中心，对象最大，因此这件事情会用如下语句来表达：
猪八戒.吃(西瓜);
对比两条语句不难发现，面向对象的语句更接近自然语言的语法：主语、谓语、宾语一目了然，十分直观，因此程序员更易理解。
二、面向对象的三个基本特征
封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）
为何抽象不是面向对象的特征之一？因为抽象并不打算了解全部问题，而只是考虑部分问题，且所有的编程语言都需要抽象，故抽象是面向对象的重要部分，但它不是面向的特征之一。
三、为何说JavaScript语言不是真正的面向对象的编程语言，而是一种基于对象的编程语言？
在编程语言领域，有“面向对象”和“基于对象”的概念，这两个概念极易混淆。通常而言，“基于对象”也使用了对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说，“基于没有继承的特点；而”多态“则更需要继承，没有了继承的概念自然也就无从谈论”多态“。面向对象方法的三大基本特征（封装、继承、多态）缺一不可。JavaScript语言就是基于对象的，它使用一些封装好的对象，调用对象的方法、设置对象的属性；但是它们无法让开发者派生新的类，开发者只能使用现有对象的方法和属性。
判断一门语言是否是面向对象的，通常可以使用继承和多态来加以判断。“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象同时还实现了“继承和多态”，而“基于对象”没有实现这些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf28a992bca9991d633ea42419de5845/" rel="bookmark">
			c/c&#43;&#43; float和double的表示范围详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开门见山 float范围： 最小负数-2*2^127 最大负数-1*2^(-126)，0
最小正数 1*2^(-126) 最大正数2*2^(127)。
double范围： 负数：（-1.7976931348623157E+308，-4.94065645841246544E-324）；
零：0 ；
正数：（4.94065645841246544E-324，1.7976931348623157E+308）。
即绝对值为0和2^1022——2^1024。
精度：
float和double的精度是由尾数的位数来决定的；浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响；float：2^23 =8388608，共七位，意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。 原因 float：1bit（符号位）+8bits（指数位)+23bits（尾数位）；
double：1bit（符号位）+ 11bits（指数位）+ 52bits（尾数位）。
以float为例，阶码(指数)用移码来表示，8位移码（偏移量为127） 本来应该可以表示-128-127，但是全0和全1被用来 表示特殊状态的指数 ，所以为-126-127（无符号8位表示0-255，去除全0和1后是1-254，减去偏移量127，就是-126-127）。 这里为什么要使用127来作为偏移量，若使用128 则8位移码表示范围-127~126，由于表示一个大的正数 比一个小的负数更加重要，所以127作为偏移量比较合适。 现在可以计算其表示范围了： 尾数部分的取值范围[1,2),所以最小负数-2*2^127 最大负数-1*2^(-126) 最小正数 1*2^(-126) 最大正数2*2^(127)
可以看下这篇文章链接，文章有些内容错误，多注意下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62c605e2475bcea0d3f24cc2b06c7f2/" rel="bookmark">
			【数据结构】初入数据结构中的B类树（B Tree , B&#43; Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初入数据结构中的B类树（B- Tree , B+ Tree） 如果觉得对你有帮助，能否点个赞或关个注，以示鼓励笔者呢？！博客目录 | 先点这里
前提概念 数据域指针域 B树 什么是B树(B-树)？B树的定义B树的特性B树的高 B+ 树 什么是B+树？B+树的定义B+树的小特性为什么B+树会替代B树？ 为什么需要B树，B+树？ 引文为什么我们需要B类树？
前提概念 为了更好的理解B类树，我们先来简单的了解一下两个概念
数据域 B类树的结点中有两个区域，一个是数据域，一个是指针域
什么是数据域？
简单的说，B类树中每个结点存储数据的地方，我们就称之为数据域而数据域中存储的数据通常是一个个的键值对，键值对就分为键(key)和值(value)，这里通常称键为关键字，也通常会将关键字直接指代整个键值对站在数据库索引的角度，关键字就是用于建立索引的字段值，而对应的值就是该关键字所对应的目的数据，可以是主键信息，也可以指向实际数据的地址，甚至是完整的一行数据 指针域 什么是指针域？
我们知道二叉树在代码的实现中，通常会有两个指针，既左孩子指针和右孩子指针。而这两个指针所在的区域，我们就称之为指针域而存放左右孩子指针的因为B类树并不是一棵二叉树，它是一棵多叉树。也就说明了，一棵B类树，可能有多个指针，每个的结点的所有的指针所在的区域就是我们说的指针域啦。概念都是一样的。 B树 什么是B树(B-树)？ B-树，即为B树。需要强调的是它们两者都是同一种树，并非两种不一样的树。因为B树的英文名称为B-tree，-实际是杠的意思，但是也就不知怎么的B-tree就被翻译成为B-(减)树。
B树，又名B-树(B减树)。它是一棵多路平衡多路查找树
B树的定义 一棵m阶B树的定义
结点需要满足
(1) 根结点至少有两个孩子结点
(2) 树中每个结点最多有m个孩子结点(m&gt;=2)
(3) 除根结点和叶子结点外，其他所有结点至少要有 ceil(m/2)个孩子
(4) 所有的叶子结点都位于同一层（平衡特性）
关键字需要满足
假设每个非叶子结点中包含n个关键字信息，关键字以k表示，指针以p表示
(1) Ki (i = 1,…,n)某个非叶子结点的关键字，关键字需要满足升序序列排序，k(i-1) &lt; k(i)
(2) 每个非叶子结点中的关键字个数n需要满足 ceil(m/2) -1 &lt;= n &lt;= m - 1
(3) 非叶子结点的指针p[1]…p[m]中
第一个指针，p[1]指向的孩子结点的所有关键字必然小于当前结点k[1]关键字；最后一个指针，p[m]指向的孩子结点的所有关键字肯定大于当前结点k[m-1]关键字 ;其他p[i]指向孩子结点所有的关键字必然在当前结点(k[i-1],k[i])的开区间范围内 通俗版解释一下
m就是几阶的含义，m取决结点的容量和相关配置。3阶B树的每个结点分叉数最多为3，最多三个孩子结点ceil函数是指向上取整的意思，非四舍五入，如ceil(1.5) = 2, ceil(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f62c605e2475bcea0d3f24cc2b06c7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204d9d5b1a6661e5ada721cf6645fb0b/" rel="bookmark">
			我的Redis集群搭建之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要做一个平台，设计要求每秒能够在一个800-1000万条记录的数据库内读写1万次。
我是选用redis集群。我的做法是按照大神龚-java提供的文档和自己加入的一些发现结合实现的。
首先就是下载redis-3.2.1.tar.gz，这个没有什么说的，去官网上找链接然后wget就可以了。
下载完成后tar -zxvf解压缩，我的习惯是解压缩之后放到/usr/local/目录下面。
到/usr/local/redis-3.2.1/目录下面，如果没有安装gcc就需要用命令yum install gcc安装一下。
gcc装好后，就在/usr/local/redis-3.2.1/目录下面编译，执行make，如果执行失败看一下错误，如果错误如下，
编译中断。
make[1]: *** [adlist.o] 错误 1
make[1]: 离开目录“/usr/local/redis-stable/src”
make: *** [all] 错误 2
解决办法是：
make MALLOC=libc
编译完成后执行make install。作用是将 /usr/local/redis/redis-3.2.1/src/相关redis的执行命令复制到/usr/local/bin目录下
下面就要修改配置文件了。配置文件在/usr/local/redis/redis-3.2.1/redis.conf。主要修改下面几个参数。
bind 0.0.0.0 表示不限制链接本机服务的ip地址。任何计算机都可以发起连接。这里要特别注意，我一开始以为这里绑定的ip才能访问本机的6379端口，结果一修改就启动不了redis服务，后来仔细看了一下配置文件上的说明才明白，原来这个bind的不是来访问的ip，而是本机网卡的物理地址。
daemonize yes 表示允许后台运行
cluster-enabled yes表示开启集群
cluster-node-timeout 15000表示设置超时时间
cluster-config-file node保存集群配置文件
配置好之后启动redis服务，redis-server redis.conf
[root@t91 redis-3.2.1]# ps -ef | grep redis
root 2352 1 0 09:39 ? 00:00:00 redis-server 192.168.1.91:7001 [cluster]
root 2450 2006 0 09:56 pts/0 00:00:00 grep --color=auto redis
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/204d9d5b1a6661e5ada721cf6645fb0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8361e8234d564f305434ba2984d74055/" rel="bookmark">
			python学习笔记--tuple（元组）是有序列表，属于 引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用分片的方法使得元组改变，属于“狸猫换太子”。元组是不可变的原则来说，单独删除一个元素是不可能的。
总结一下： int str tuple是不可变的，属于值类型。
list set dict是可变的，属于引用类型
也可以通过 id（）函数显示出某一个变量在内存里的地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bf02ecde7c0855288f7214387fa31b/" rel="bookmark">
			C#字符串与16进制的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串转换成16进制字符
/// &lt;summary&gt; /// 字符串转换为16进制字符 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;param name="encode"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string StringToHexString(string s, Encoding encode) { byte[] b = encode.GetBytes(s);//按照指定编码将string编程字节数组 string result = string.Empty; for (int i = 0; i &lt; b.Length; i++)//逐字节变为16进制字符 { result += Convert.ToString(b[i], 16); } return result; } 16进制字符转换成字符串
/// &lt;summary&gt; /// 16进制字符转换为字符串 /// &lt;/summary&gt; /// &lt;param name="hs"&gt;&lt;/param&gt; /// &lt;param name="encode"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string HexStringToString(string hs, Encoding encode) { string strTemp = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bf02ecde7c0855288f7214387fa31b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afa8227aa40d7ec14f3b7361ab5fe93/" rel="bookmark">
			Django、Tornado、Flask优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Django、Tornado、Flask优缺点 一、Django二、Torando三、Flask 一、Django 主要特点是大而全,集成了很多组件,例如: Models Admin Form 等等, 不管你用得到用不到,反正它全都有,属于全能型框架
优点：
大和全（重量级框架）自带orm，template，view需要的功能也可以去找第三方的app注重高效开发全自动化的管理后台（只需要使用起ORM，做简单的定义，就能自动生成数据库结构，全功能的管理后台）session功能 缺点：
template不怎么好用（来自自身的缺点）数据库用nosql不方便（来自自身的缺点）如果功能不多，容易臃肿 二、Torando 主要特点是原生异步非阻塞,在IO密集型应用和多任务处理上占据绝对性的优势,属于专注型框架
优点：
少而精（轻量级框架）注重性能优越，速度快解决高并发（请求处理是基于回调的非阻塞调用）异步非阻塞websockets 长连接内嵌了HTTP服务器单线程的异步网络程序，默认启动时根据CPU数量运行多个实例；利用CPU多核的优势自定义模块 缺点：
模板和数据库部分有很多第三方的模块可供选择，这样不利于封装为一个功能模块 三、Flask 主要特点小而轻,原生组件几乎为0, 三方提供的组件请参考Django 非常全面,属于短小精悍型框架
优点：
简单，Flask的路由以及路由函数由修饰器设定，开发人员不需要借助其他文件匹配；配置灵活，有多种方法配置，不同环境的配置也非常方便；环境部署简单，Flask运行不需要借助其他任何软件，只需要安装了Python的IDE，在命令行运行即可。只需要在Python中导入相应包即可满足所有需求；入门简单，通过官方指南便可以清楚的了解Flask的运行流程；低耦合，Flask可以兼容多种数据库、模板。 缺点：
对于大型网站开发，需要设计路由映射的规则，否则导致代码混乱 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f366a44661f564699976a4471900a7/" rel="bookmark">
			ubuntu apt-get grade 报错11: Resource temporarily unavailable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu更新源时报错:
报错详细提示如下:
E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarly unavailable)
E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is an other process using it?
如何解决这种问题呢?
1 首先查看是否有apt-get这个程序在运行
ps aux |grep apt
2 如果发现存在这样的程序在运行那么就kill掉.
sudo kill -9 进程号
3 直接删除锁文件
sudo rm /var/lib/dpkg/lock-frontend
sudo rm /var/lib/dpkg/lock
重新执行: sudo apt-get update sudo apt-get upgrde
成功!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8750335df2942f18ed07c4891f2606/" rel="bookmark">
			C&#43;&#43;:int、double范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本数据类型的特点，位数，最大值和最小值。
1、
基本类型：short 二进制位数：16 (2字节)
最小值：Short.MIN_VALUE=-32768 （-2的15此方）
最大值：Short.MAX_VALUE=32767 （2的15次方-1）
2、
基本类型：int 二进制位数：32（4字节）
最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）
最大值：Integer.MAX_VALUE= 2147483647 （2的31次方-1）
3、
基本类型：long 二进制位数：64（8字节）
最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）
最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）
4、
参考https://www.csdn.net/gather_20/NtDagg4sOTgtYmxvZwO0O0OO0O0O.html
范围：
float和double的范围是由指数的位数来决定的。
float的指数位有8位，而double的指数位有11位，分布如下：
float：
1bit（符号位）
8bits（指数位）
23bits（尾数位）
double：
1bit（符号位）
11bits（指数位）
52bits（尾数位）
于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。
精度：
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。
double IEEE754浮点数的表示方法。C语言里对float类型数据的表示范围为-3.4*10^38～+3.4*10^38。double为-1.7*10^-308~1.7*10^308，long double为-1.2*10^-4932~1.2*10^4932.
类型
比特（位）数
有效数字
数值范围
float
32
6~7
-3.4*10^38～+3.4*10^38
double
64
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8750335df2942f18ed07c4891f2606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe5192ff08b1d13bd7b8ead5130ddfb/" rel="bookmark">
			5G移动频率划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5G移动频率划分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c227cde85aba3736123e21ae84d27c/" rel="bookmark">
			赵军之《知识图谱》第一章  什么是知识图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 概述 说明什么是知识图谱思维导图 说明 说明：本章首先讨论了知识图谱的定义，然后对其发展历史进行了梳理，从两条历史发展路线总结知识图谱的由来。接着，对知识图谱的发展脉络进行了梳理，知识图谱的发展经历了从人工标注到群体智能，到基于统计机器学习的自动构建的过程，也体现了从单一语言、单一领域到多语言、多领域的发展趋势。然后对知识的类型和知识图谱的类型进行了讨论，并对若干具有代表性的知识图谱进行了简要介绍。随后，对知识图谱的生命周期，也就是知识图谱在构建和应用中的几个重要环节进行了介绍。知识图谱本身是一种语义网络，但是相较传统的知识表示，现有的知识图谱以三元组为统一表示形式，不仅形式更加开放，更容易被人们接受，其存储、搜索和推理也更加有效。但是我们应该注意到目前所定义的知识图谱只能表示事实性的知识，或者称之为以实体为核心的结构化知识。知识还有很多其他类型：情感知识、常识知识、场景知识等。这些知识的表示、构建与应用还在不断地探究。最后分析了知识图谱与深度学习之间的关系，从中可以看出，以符号表示为基础的知识图谱和以数值计算为基础的深度学习在不同的应用中各有优势，目前的趋势包括在深度学习方法中融合知识图谱和在知识图谱中应用深度学习技术。
什么是知识图谱 知识图谱目前在学术界还没有统一的定义。按照Wikipedia的描述，知识图谱是谷歌公司用来支持从语义角度组织网络数据，从而提供智能搜索服务的知识库。（这也是狭义上的知识图谱）。从这个意义上讲，知识图谱是一种比较通用的语义知识的形式化描述框架，它用节点表示语义符号，用边表示符号之间的语义关系。
思维导图 为了更清晰地展示每一个章节的主要内容脉络，计划给出每一章的思维导图，然后再选择重点知识进行单独注解。
第一章主要是概述内容，在此给出思维导图如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac78ef91e9c29038055cb280699fd6fc/" rel="bookmark">
			I2S协议总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、I2S总线接口 I2S 总线接口主要有 4 个主要信号：
1、SD：串行数据线，用于发送或接收两个时分复用的数据通道上的数据(仅半双工模式)
2、LRCLK：字段选择线，也称帧时钟(LRCLK)线，表明当前传输数据的声道，不同标准有不同的定义。 LRCLK线的频率等于采样频率(FS)。
3、BCLK：串行时钟线，也称位时钟(BCLK)，数字音频的每一位数据都对应有一个 CK 脉冲，它的频率为： 2*采样频率*量化位数， 2 代表左右两个通道数据，BCLK一般从一个MCLK时钟分频下来，MCLK可以由主控的PLL或者其他时钟源提供
4、MCLK：有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为主时钟，也叫系统时钟（Sys Clock），是采样频率的128倍，256倍或384倍，也叫过采样
二、常用标准 I2S Philips 标准
使用 LRC 信号来指示当前正在发送的数据所属的通道，为 0 时表示左通道数据。该信号从当前通道数据的第一个位(MSB)之前的一个时钟开始有效。发送方在时钟信号(CK)的下降沿改变数据，接收方在上升沿读取数据正如之前所说， LRC 线频率对于采样频率 FS，一个 LRC 线周期包括发送左声道和右声道数据
三、MCLK的选择 1、如果是16bit的采样，两通道数据？16 * 2 = 32fs，按照倍数的增加，会有如下的选择：64fs、128fs、256fs、512fs
2、如果是24bit的采样，两通道数据？24 * 2 = 48fs，按照倍数的增加，会有如下的选择：96fs、192fs、384fs、768fs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438ed3512807d3efa6daf8c42e06d206/" rel="bookmark">
			几篇关于【核心网】MME、PGW、SGW和PCRF的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Table of Contents
简介
什么是HSS？HSS有什么主要功能？HSS与HLR的区别是什么？
什么是PCC？在LTE环境下主要应用是什么？
LTE的核心网之：MME，SGW，PGW
LTE核心网中，SGW、PGW、PCRF都有计费的功能，请问这几个网元的计费功能有什么区别与联系呢？
简介 核心网：详情可见 https://blog.csdn.net/Rong_Toa/article/details/89285093
用户面和控制面板分离
代码：https://github.com/open5gs/nextepc/tree/master/src
这里再次提起GitHub上的项目：https://github.com/open5gs/nextepc
什么是HSS？HSS有什么主要功能？HSS与HLR的区别是什么？ 作者：孟神通 | 时间：2018-01-13
HSS（Home Subscriber Server，归属签约用户服务器）是EPS中用于存储用户签约信息的服务器，是2G/3G网元HLR的演进和升级，主要负责管理用户的签约数据及移动用户的位置信息。
HSS与HLR（Home Location Register，归属位置寄存器）的区别在于：
（1）所存储数据不同：HSS用于4G网络，保存用户4G相关签约数据及4G位置信息，而HLR用于2G/3G网络，保存用户2G/3G相关数据及2G/3G位置信息；
（2）对外接口、协议及承载方式不同：HSS通过S6a接口与MME相连，通过S6d接口与S4 SGSN相连，采用Diameter协议，基于IP承载，而HLR通过C/D/Gr接口与MSC/VLR/SGSN相连，采用MAP协议，基于TDM承载；
（3）用户鉴权方式不同：HSS支持用户4元组、5元组鉴权，而HLR支持3元组和5元组鉴权。
实际部署时，由于HSS与HLR在网络中功能类似，所存储数据有较多重复，故多合设，对外呈现为HSS与HLR融合设备。融合SHH/HLR支持MAP和Diameter协议，分别连接2G/3G与4G网络，提供HSS和HLR的逻辑功能。
什么是PCC？在LTE环境下主要应用是什么？ PCC（Policy and Charging Control，策略和计费控制），是在现有移动分组核心网上叠加的一套端到端策略和计费控制架构，支持2G/3G/LTE的融合控制。通俗地讲，网络上会预先配置一些“规则”，这些“规则”是结合市场、业务、用户等特性制定的。当用户使用网络时，如果用户特性符合这些“规则”，网络即对用户采取一定的措施，例如提升或限制用户速率。这些“规则”主要通过PCC来实施。
PCC系统是LTE系统的基本组成部分，LTE下PCC将会在“分质服务、分质定价”、“支撑灵活计费”、“开展实时提醒、促进用户更多使用网络等方面发挥更大作用，丰富流量经营策略，增大流量收益。
LTE的核心网之：MME，SGW，PGW https://www.cnblogs.com/mway/p/5326868.html
移动性管理实体（MME）
MME的主要功能是支持NAS（非接入层）信令及其安全、跟踪区域（TA）列表的管理、P-GW和S-GW的选择、跨MME切换时进行MME的选择、在向2G/3G接入系统切换过程中进行SGSN的选择、用户的鉴权、漫游控制以及承载管理、3GPP不同接入网络的核心网络节点之间的移动性管理（终结于S3节点），以及UE在ECM_IDLE状态下可达性管理（包括寻呼重发的控制和执行）。
Mobile Managenment Entity -- 移动管理实体
The MME (Mobility Management Entity) helps authenticate users onto the system and tracks active and idle users on the system. The MME pages users when triggered by new data arriving for an idle user at the assigned Serving GW.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438ed3512807d3efa6daf8c42e06d206/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/419/">«</a>
	<span class="pagination__item pagination__item--current">420/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/421/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>