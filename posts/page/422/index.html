<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729fe63410247a0be65f5e013b1bdf6c/" rel="bookmark">
			上传服务器上的视频不能在线播放的解决方案合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：我们程序员在本地测试视频播放时，常常遇到这种情况，本地测试视频是可以正常播放的，但项目上传服务器后，视频就无法播放了，原因通常有以下几种，原因及解决方案如下：
一、视频编码格式
以MP4为例，虽然格式类型都是MP4，但视频编码格式有很多种，通常浏览器支持的为“H264”编码格式。
解决方法：
可以下载格式工厂等视频转码工具，将视频编码格式选成H264，转码即可。
截图如下：
2、IIS服务器没有配置MIME类型
2-1、打开IIS服务器，找到MIME类型
2-2、视频以常用的MP4、FLV、OGG为例，进放MIME后，右侧点添加，
文件扩展名输入：.mp4，MIME类型输入：video/mp4。注：扩展名mp4前方有”.“
然后根据需要，文件扩展名输入：.flv，MIME类型输入：flv-application/octet-stream
文件扩展名输入：.ogg，MIME类型输入：video/ogg
2-3：如果还无法播放，可以尝试重启IIS服务器。
3、网站安装了安全狗（这点神坑，坑了我好几天）
如果以上两种方法视频还是无法播放，或部分视频无法播放，那么要考虑服务器是否安装了“网站安全狗”，如果有，请卸载，服务器安全狗没有影响，可不卸载。卸载完成后，你会神奇的发现，视频可以正常播放了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8d1135c9e907e1263c961caaced0cd/" rel="bookmark">
			MAC 上找不到.bash_profile或者ect/profile该怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发Android的环境要重新在Mac上搭建，结果在配置环境变量时找不到.bash_profile文件。查过很多资料解决方案都很笼统，结果还是在英文网站上找到解决方法。
1. 启动终端Terminal
2. 进入当前用户的home目录
输入cd ~
3. 创建.bash_profile
输入touch .bash_profile
4. 编辑.bash_profile文件
输入open -e .bash_profile
因为是为了搭建Android开发环境，输入Android SDK下的tools目录：export PATH=${PATH}:/eclipse/android_sdk/tools
5. 保存文件，关闭.bash_profile
6. 更新刚配置的环境变量
输入source .bash_profile
7. 验证配置是否成功
输入android启动Android SDK and AVD Manager
8.ect/profile文件如何编辑？ 在terminal终端中输入vi ect/profile 然后就可以在前往文件夹中写路径找到文件
转载于:https://www.cnblogs.com/yk123/p/5819797.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ab0ec87055d407fff0192c10848cc8/" rel="bookmark">
			PeopleSoft Financials Tables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		General Ledger Tables PS_LEDGER: The general ledger data table.
PS_JRNL_HEADER: Stores general ledger journal header data.
PS_JRNL_LN: Stores general ledger journal line data.
ps_combo_rule_tbl: Stores ChartField combination rules.
ps_combo_group_tbl: Stores ChartField combination groups.
ps_combo_data_tbl: ChartField Combo data table.
ps_bu_led_comb_tbl: Business Unit CharField Combos for Ledger.
PS_GL_ACCOUNT_TBL: GL Accounts table.
Accounts Payable/Voucher Tables PS_GRP_AP: Stores AP control groups.
PS_VOUCHER: AP voucher header table.
PS_VOUCHER_LINE: AP voucher line.
PS_DISTRIB_LINE: Voucher distribution table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ab0ec87055d407fff0192c10848cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3d83d1831ef14b7d3eeacbcf6d64d2/" rel="bookmark">
			Pay Cycle related record
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select *---delete from sysadm.ps_pycycl_stat
where pay_cycle = 'ACH' and pay_cycle_seq_num &gt;= 30
select *---delete from sysadm.ps_PYCYCL where pay_cycle = 'ACH'
select *---delete from sysadm.ps_PYCYCL_STAT_VW where pay_cycle = 'ACH'
select *---delete from sysadm.ps_payment_tbl
where pay_cycle = 'ACH' and pay_cycle_seq_num &gt;= 30
select *---delete from ps_pycycl_statrpt where pay_cycle = 'ACH' and pay_cycle_seq_num &gt;= 30
select *---delete from sysadm.ps_PYCYCL_JOB_TBL where pay_cycle = 'ACH' and pay_cycle_seq_num &gt;= 20
select * from sysadm.ps_pycycl_wrk_opt where pay_cycle = 'ACH'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3d83d1831ef14b7d3eeacbcf6d64d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f97f685a12fbcdf545fbeff29cb021d/" rel="bookmark">
			PageHelper中PageInfo成员属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * 对Page&lt;E&gt;结果进行包装 * &lt;p/&gt; * 新增分页的多项属性，主要参考:http://bbs.csdn.net/topics/360010907 * * @author liuzh/abel533/isea533 * @version 3.3.0 * @since 3.2.2 * 项目地址 : http://git.oschina.net/free/Mybatis_PageHelper */ //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //排序 private String orderBy; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中"显示startRow到endRow 共size条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //第一页 private int firstPage; //前一页 private int prePage; //下一页 private int nextPage; //最后一页 private int lastPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59072403cbb4b1f8663d13316e82064/" rel="bookmark">
			微信朋友圈长图居中展示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信朋友圈长图居中展示
下载地址：https://download.csdn.net/download/webben/11275077
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;微信演示&lt;/title&gt; &lt;style&gt; div{ display: block; } ul{ width: 342px; margin: -4px 0 0 -4px; display: block; list-style: none; padding: 0; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; letter-spacing: normal; word-spacing: normal; } ul li{ width: 110px; height: 110px; margin: 4px 0 0 4px; position: relative; overflow: hidden; float: left; } ul li img{ border: 0; vertical-align: top; display: inline-block; transform: none; min-width: 0; max-width: none; max-height: none; position: relative; width: 110px; left: 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e59072403cbb4b1f8663d13316e82064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d43aa8585340f4ddd25264424113dc/" rel="bookmark">
			Java中Object类的equals()和hashCode()方法深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.equals()
在初学Java的时候，很多人会说在比较对象的时候，==是比较地址，equals()是比较对象的内容，谁说的？
看看equals()方法在Object类中的定义:
public boolean equals(Object obj){
return ( this == obj);
} 这是比较内容么？明显是比较指针(地址)么...
但是为什么会有equals是比较内容的这种说法呢？
因为在String、Double等封装类中，已经重载(overriding)了Object类的equals()方法，于是有了另一种计算公式，是进行内容的比较。
比如在String类中：
public int hashCode() { int h = hash; if (h == 0 ) { char val[] = value; int len = count; for ( int i = 0 ; i &lt; len; i ++ ) { h = 31 * h + val[off ++ ]; } hash = h; } return h; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d43aa8585340f4ddd25264424113dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b89bb1a0ed767165617805d45d12a5c/" rel="bookmark">
			网易163
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网易163 链接:http://www.163.com 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/3618/viewspace-484228/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/3618/viewspace-484228/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420f608fb55a244b6b29fd80ac530ca5/" rel="bookmark">
			习而学的软件工程教育 之 思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现代软件工程 习而学的软件工程教育
很认真的读了邹老师的这篇文章和茅先生的博客
首先，我要说，我是很支持“习而学”的
实践是检验真理的唯一标准
在与前大班的同学的聊天中，对比两种软件工程课
我们很容易得到了这样的比较结果：我们现在的软件工程课更有意义
我们的软件工程课是没有考试的，而前大班的是要考试的
以上学期的面向对象建模课为例，分数分为平时与考试两部分，各占50%，其中平时包括几次小作业与一次大作业
小作业与大作业即是分别完成一个“小程序”与“小工程”，可以归为实践
考试则是考概念，UML，等等等等
如果要我来评价，大作业对我更有意义
我是在OO的大作业中学会Java的，这样又引申到了“很有名”的Java课
全年级200多人，在Java课上学会Java的，我想不超过10个吧，每年每届学生都是如此
老师在讲台上空谈概念，没有课后练习，没有实际例子，考试考什么是接口，try...catch有什么用
由于是开卷考试，我们都“答出”了“标准答案”，但谁也没学会
与之对应的，7班的一些同学可能听过刘禹老师的C++课
刘禹老师的C++是这样讲的：
没有PPT，打开电脑，打开投影，打开VC6.0，大家一起跟着做
输入一段代码，问大家觉得会出什么样的结果
按照我们的学习经验，这代码肯定是有问题的，比如编译错、结果错、各种错，然后再讲解
这样下来，每个同学对这个“知识点”的印象都非常深刻
但是
方法上面说到的只是实践对学习是很有必要的
也就是说，习而学是很好的学习方法
这不必意味着学而习就不是好的学习方法
现在有着这样一种说法：说大学学数学，研究生再学专业
也就是说，我们是以理论为基础，然后再加以实践，最后在实践的过程中回归理论
这与先实践，在实践中感受理论是有区别的
软件工程的工作职位中，有需求分析师、有架构师、有PM、有Dev
很显然，Dev是供大于求的，而需求分析师是最难的
茅先生的话有些道理，但我想对每一点都挑点刺
不一定非得到四年级（五年级）才算大学毕业，而是任何一个年级都可以毕业就业。
对于社会来说，可能我需要的Dev就是比架构师多，就像工头只有一个，但工人有很多
这样的大学模式可能符合社会规律，但对个体本身而言，如果你只是当一个技师，而且只学过怎么当技师，那他永远就只能当技师
任何一个年级都可以招收新生。
我可以不上一年级就上二年级吗？如何考量是否有上二年级的水平呢？
学习不仅仅是知识的简单积累，而是一个系统的过程化行为，连续上一、二年级，与上一年级、上二年级肯定是有区别的
新体制下，大的工厂、施工现场都可以开办正式大学。
理论很美好，现实很残酷。如果他们开办的不是“大学”，而是“培训班”，我想可能更准确一些吧
现在还有种说法，说公司愿意找一个学其它专业，比如自动化、电子的，而不愿意找学计算机的编程
他们认为编程这个随便学学大家都能编，但其它专业的人有一些计算机专业不可能有的才能
那么，对于计算机专业的学生来说，重要的就是be professional
如果以实践为基础来学习，但我们与其它专业对着本书自学C语言的有什么区别呢？
我们正因为是从理论出发的，了解的不仅仅是表层的知识，还了解底层的的知识，才能说明我们是专业的
综上，理论是基础，我认为只有在理论上才能加以实践
特别是在大学这个学习的时期
还是应该打好基础，从理论出发，再辅以实践
学习学习，学在前，习在后
先学，再习，有新的收获，再学，再习
才能获得最好的学习成果
转载于:https://www.cnblogs.com/buaashine/archive/2012/12/10/2808107.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282d4cc88b5fc2fe623cdc00b167fdbb/" rel="bookmark">
			关于习而学的软件工程教育
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邹欣老师的博客在此：http://www.cnblogs.com/xinz/archive/2012/01/08/2316717.html
我不是很同意邹欣老师的观点。对于一个大学生，思想远比实践经验要重要。子曾经曰过，世界上最简单的事情就是学习，因为学习是机械的：我不停的码代码，打字一定会快，对语法一定会更加熟悉；我不停的看技术方面的资料，我一定会对技术更加了解；等等。同时，世界上最难的事情便是思想境界，这不是机械性的练习就可以练成的。
在我的一篇博客（http://www.wanganran.com/blog/2012/04/%E7%89%87%E8%AF%AD.html ）里有这样一则故事，其实是我从另外一篇cnblogs里面的文章里看到的：
很多年前，我还年少的时候，喜欢下象棋，在学校里基本上我能下赢的，我总能下赢，我下不赢的，总也下不赢。不得其解，也慢慢懒得操练了。
后来有次学校搞业余活动，有个老师是省象棋协会的，组织了一节棋课。我去晚了，只听了半节。大致意思是讲，下棋要讲全局观，要有战略，例如中局五种策略，中局成杀、不成杀则优、不占优占先、不占先则多子、不多子则求和。还有什么炮破士、马破相、残局炮归家等等。却没有讲如何下棋，课堂上也没有摆个象棋，或是什么棋谱。
我并没有把这些当回事儿，之后也很少下棋。
又过多年，毕业后同学聚一起，闲来无事，与一个同学下了两盘。刚开始，他问我这两年有没有下棋，我说没有。他调侃我，“那你以前下不赢我，今天你也难赢了”。我也笑着认同，反正只是玩玩，何必认真。
可是一开局，他就傻眼了，一直处在下风，且每局必输。他很吃惊，我也很吃惊。之后我认真思考了这件事，觉得是那节棋课影响了我，人的思考能力、计算能力都差不多，而思维方式不同，结果也会有很大不同。他看到的是“棋”，我看到的是“局”。决定胜败的不是棋艺。
又过了几年，我已经不再年少，但还算年轻吧。有一次找一个朋友玩，正好他的一个朋友也在，吃完饭没事儿做，恰巧有副象棋，就与他的朋友下了几局。他们都比我年龄大，已经三十多岁了。不过我也没有放在眼里，自以为水平相当可以，三局我两胜，颇为自得。
等他走后，我朋友问我：“他水平怎么样呀？”我带着些“谦虚”，洋洋自得：“他水平挺可以的，我差点就输了，还好我三局两胜，略胜那么一点点。”
我朋友听完哈哈大笑：“你知道他是干吗的吗？他是卖保险的。卖保险的吗，任何人都可能是他的潜在客户，他自然不会去赢你，不光让你赢，还要让你赢得有面子，这才是高手。他原来是在象棋协会的，论象棋，那叫牛×死了。”
我听完之后，惭愧至极。我关注的是“棋局”，人家所关注的，则超脱棋局之外。眼界不一样，看到的也不一样，操控点也不一样，输赢已经不重要，重要的是输与赢，哪个更有利于自己，然后才是“如何去输”与“如何去赢”。棋局只是一个棋子。决定成败的不是棋艺。
虽然是一则和软件工程不太相关的故事，但是也能很清楚的反映一点：决定一个人的，不只是他的天赋、努力、运气，更是他的思维方式，他的思想层次。
在计算机方面也是一样。我算是一个草根程序员：从初中开始就开始从vb、c#语言开始自学编程，到高一的时候已经可以编写一些小程序了，当时觉得自己很了不起。这算是“习而学”中的先练习。
但是，只有当我通过高中的信息学奥赛系统的学习了关于计算机运行的一些基本原理，我才发现我之前那些所谓练习，使用了几乎完全违背与计算机运行的方法。虽然界面比较美观，运行的也还算顺利，但是效率、代码风格都差的不行。
如果在大学阶段进行“习而学”的方法，那么大学就失去了它的作用——传递思想。如C++、汇编语言、Web前端、移动开发等课程，完全是可以机械性的学习并且对其他科目没有影响的，不应该安排在大学。相反，关于计算本质的课程需要加上。MIT曾经将Scheme作为计算机系学生的第一门计算机语言，将《计算机程序的构造和解释》作为教科书，现在好像与时俱进变成Python了，我认为值得借鉴。于此同时，计算机系同软件工程专业还不同。软件工程就是专门为工业界而准备的，但是计算机科学与技术还有科学在里面。所以，数学分析、概率论之类的课程还是有必要必修的，在科研领域它们还是十分重要的。
当然，现如今中国的大学课程亟需改善，尤其是北航。有很多的机械性的课程，也有很多与专业无关、可能一辈子都不会被用到的必修课。在大一大二两年之中，在这样花样年华里，我们却要写物理实验报告，要背语文课文，要背航空航天概论，这无疑是一种浪费时间（也许它们有用，但是它们不应该在大学的必修课里）。在大一的时候，我们有上过计算机概论课，这门课讲得非常好，我认为是十分有必要的，而且关键是这门课不用考试，只用交一篇文章就可以。
这就牵扯到另外一个问题了，那就是大学的绩点政策。为什么我们觉得初中、高中是那样的美好？虽然大学让我们更自由，但是又有一股强烈的力量在牵扯着我们，那就是绩点。如果初中、高中是所谓的应试教育，大学就更加是应试教育——只有拼绩点，才能有未来。这也就告诉我们，只有死读书、背书，才能有未来。虽然有大作业等开放性的考试，但是这毕竟是少数。这也就让“习而学”的方式更加行不通——怎样考核？根据代码量？根据用户数量？不靠谱吧，到时候还是得通过考试，于是还是得“学而习”。
总而言之，首先，我认为大学应该起到它应有的作用，而不只是一个技术学校而已；其次，大学也不应该是又一个高中或者更甚于高中的应试教育家的天堂，而应该是一片自由的、开放的孕育思想的摇篮。
转载于:https://www.cnblogs.com/buaashine/archive/2012/12/09/2808140.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685c88addadd55c39504e0c40530e7a6/" rel="bookmark">
			iOS   基本数据类型 和 指针 特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据类型 : 整型int, 字符型char , 浮点型 (float 和 double), 枚举型;
-- 构造类型 : 数组类型, 结构体类型, 共用体类型;
-- 指针类型 : 最终要的数据类型, 所有的系统类, 自定义类都是指针;
-- 空类型 : 空类型只有一个值 nil, 该类型没有名称, 因此没有空类型的变量, 变量不能转换成空类型, 但是空类型可以转换成任何引用类型;
今天有个同事 问我一个问题 上代码还原问题情形
+(void)creat { int count = 10; for (int i = 0; i &lt; 10; i++) { [self fun:count]; NSLog(@"%d",count); } } +(void)fun:(int)count { count ++; } 打印结果都是10 他问 为啥 我说 如果是指针的话好解释 指针传递地址 但是int 是基本数据类型 没有指针 只是new 了一个对象 所以 不变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685c88addadd55c39504e0c40530e7a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3037f38648b28b1b74715017e2bdca/" rel="bookmark">
			在iOS开发中使用FMDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的第一个应用使用的数据库是操作sqlite3 熟悉了之后 还不愿意换了。说实话这个方法并不是很轻量级,繁琐,复杂的数据读取插入后果就是崩了,我知道很大一部分原因是因为我的线程没处理好、出现死锁、逻辑混乱导致的。所以我想使用更轻量级的数据库，逻辑更清晰，这样会降低程序的复杂度,易于维护、赋予程序健壮性。
我在网上找到一个比较好的资源 贴在下边 ，当自己有空了会diy成自己的。
http://lsl1991bsdk.blog.163.com/blog/static/207912440201332552634316/
前言 SQLite (http://www.sqlite.org/docs.html) 是一个轻量级的关系数据库。iOS SDK很早就支持了SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的SQLite API在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将SQLite API进行封装的库，而FMDB (https://github.com/ccgus/fmdb) 则是开源社区中的优秀者。
FMDB在使用上相当方便。以下是一个简单的例子：
1 2 3 4 5 6 7 8 9 10 11 NSString* docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString* dbpath = [docsdir stringByAppendingPathComponent:@"user.sqlite"]; FMDatabase* db = [FMDatabase databaseWithPath:dbpath]; [db open]; FMResultSet *rs = [db executeQuery:@"select * from people"]; while ([rs next]) { NSLog(@"%@ %@", [rs stringForColumn:@"firstname"], [rs stringForColumn:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3037f38648b28b1b74715017e2bdca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2cfafcfff97999fbb7b288bbbd2d75/" rel="bookmark">
			ORACLE EBS 基础设置要点简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://space.itpub.net/126211/viewspace-695768
首先需要说明的是，本系列文档假定读者已经具备基本的系统相关使用知识与技能(例如，能够基本领会“ORACLE EBS系统应用基础概述”中的内容)，故所讨论的内容仅限于笔者认为从系统使用与实际业务两方面来看比较重要或者容易存疑的问题，并不能面面俱到，旨在帮助读者掌握核心、抓住要点（详尽内容必须参考ORACLE相关官方文档）。文中为讨论需要所附图文均取自ORACLE EBS 的测试环境（Vision Demo），版本以R12.1.1为主，辅之以版本R11.5.10，界面语言主要为中文（必要时辅之以英文）。两个EBS版本在界面与功能应用方面实际可能有一些差异，必要时会作相关说明，但一般不会影响对基本问题的讨论。技术是业务的抽象与工具，业务是技术的来源与目的。本系列文档通篇将秉持“从业务的角度去审视技术，从技术的角度去回归业务”的方法论（这里的所谓“技术”，意指“系统实现”），去探讨系统实现与业务实践的融合问题，以求逐步能达到技术与业务的融会贯通。限于笔者的认知水平，有讹误或不正确之处，欢迎批评指正。一、安全性管理从系统使用角度来看，系统管理的一项重要的日常工作是关于“用户”及其“权限”的管理，在ORACLE中即所谓“安全性”（Security）管理。“安全性”是一个涵义较之“权限”更为丰富、更为广阔的概念术语，它虽然比较抽象，但顾名思义，它很好地涵盖了于实际业务与系统使用中，有关企业数据与信息管理的某些需要重点保护、控制的内容。有关用户权限的管理，在ORACLE系统中主要有三个基本要素构成：菜单（Menu）、责任（Responsibility）、以及用户（User）。三者的有机结合构成了系统权限或安全性管理的基础，辅之以参数或“安全性配置文件”等的使用，则进一步对用户的“实体（组织、帐套或分类帐）接入”权限进行细分。此外，系统在各个应用模块中，还将可能基于不同业务特点采取各具特色的系统实现方式，对用户的准入管理或功能权限作更进一步的划分（具体方式与系统设计者的个人偏好也有一定关系，不能一概而论）。“菜单”（Menu）在今天信息时代的日常生活中已是一个很普通的术语。ORACLE中的“菜单”概念并无甚特别，它也是表示用户的系统应用功能入口。最基本的“菜单”由系统预置的若干“表单功能”所组成，EBS目前大概具有2万个左右的此类表单功能；（基于某些特殊需要，系统还可提供虽不可见但可由表单内包含的逻辑调用的某些非表单“子功能”，需开发后台设置）。用户可以自定义包括若干基本菜单作为“子菜单”的用户菜单，自定义的“用户菜单”也可以作为“子菜单”来使用，这样就形成了一个菜单结构（树形图）。如图1所示菜单定义及可选择使用的系统预置表单功能LIST：EBS系统在安装好后，针对每个应用模块均已经预定义包括所有功能（或权限）所谓的“超级用户菜单”（Super User Menu），企业（系统管理员）在定义用户“责任”时可利用“排除法”来满足实际的业务管理需要。此外，系统还提供了“仅具查询”功能的预定义菜单，供某些需要限制做业务的用户使用。相较于“菜单”的耳熟能详，EBS的所谓“责任”（ Responsibility）概念就生涩、抽象得多，通常可以将之与人们相对熟悉的“角色”（Role）概念来参看。在企业管理中通常会将人员按“岗位角色”来划分，例如“计划员、采购员、仓管员”等等，它们通常对应于一定的岗位职责（责任），有真实的业务管理涵义，比较具体。系统预先定义的角色，分配给用户（User）后，该用户就具有该角色的全部应用功能；但EBS未象其它产品（如SAP）使用角色概念，而是使用“责任”概念，则更倾向于抽象地表示某些功能（入口菜单）的组合，可以不具有真实的管理涵义，比如所谓“销售经理”责任之下，尽可以与“采购员”有相同的菜单项，具有完全相同的功能，而这一点如对应到实际的“岗位角色”，显然是不合适的。Role更清楚直接，但使用不够灵活；Responsibility可灵活使用，但容易带来理解上的歧义与误会，使用时要注意区分。如下图2所示的“责任”定义界面：每个责任必须对应关联一个确定的菜单，但可以使用“排除”功能使之具有不同的菜单结构组合，这里的“排除”功能并不影响菜单原先的结构设置，这方便并简化了系统管理员对“责任”与“菜单”的管理。“责任名”总是从属于某一“应用产品”（模块），不同的模块可定义具有完全相同的“责任名”（包括菜单），但这两个完全相同的责任名在“配置文件”作层次结构设置时，可以具有不同的值，这进一步提供了系统的灵活性。责任一经定义就不可删除，只能通过设置有效期使之失效。为之设置“请求组”则限制了其可以使用的“请求”（并发程序）范围。至于其“可采用”应用产品范围设置（Web、自助等），似乎只起到统计分析的系统管理作用，实际并不影响具体的功能应用。系统在安装后将具有一个名为“SYSADMIN”（密码sysadmin）且具有“系统管理员”责任的初始用户（该用户有时也被称之为“超级管理员”）。使用此初始用户可设置“菜单、责任及用户”。如下图3所示“用户”的定义界面：每个定义的系统“用户”可以关联若干个不同的责任，每个责任也可以设定用户使用的有效日期范围。具有多个责任的用户在登录使用系统时，需要在不同责任间作选择切换，并非可以同时使用。系统初始设置时设定的密码，在用户初次登录时，将被系统提示要求修改。密码可以设定“使用天数”或“访问次数”的限制，系统的预警平台可以设置密码失效的提前预警，以督促用户及时修改。“用户”一经设置也无法删除，只能使用有效期设置使之失效。“用户”不一定必须和HRM模块设置的“人员”关联，但对于有些模块的应用功能，关联已经HRM恰当设置的“人员”则是必须的。而关联“客户”或“供应商”则主要起到统计分析的系统管理作用，并不影响具体的功能应用。用户所关联的“电子邮件”地址，主要是供系统预警平台发送信息使用。
关于EBS 系统使用相关“配置文件”诸如“MO:业务实体、MO:安全配置文件、HR:安全配置文件、GL:数据访问权限集、GL帐套名或GL分类帐名称”等等，进一步对责任或用户的“实体接入”权限进行细分的问题（R12与R11比较，变化较大），将在下面的“组织架构”设置中讨论。关于具体应用模块中对责任或用户的权限作更进一步划分问题，例如库存模块的“组织进入”（Access）、发运模块的“权限管理”（Grant），容后在相关模块文档中再来讨论。二、会计科目弹性域结构在讨论EBS的“组织结构”的设置之前，有必要先讨论会计科目弹性域（Accounting Flexfield）及其帐套（SOB）或分类帐（Ledger）的设置问题。“帐套”是R11及之前系统中的术语，“分类帐”是R12中替代帐套并为有所区别而使用的术语。为表述方便，后文如不特别指明，习惯上的“帐套”术语将等同于“分类帐”术语。在EBS关于“组织实体”的概念范畴中，帐套实际上也是“组织实体”的一种存在形式，之所以如此和ORACLE产品的发展历史有一定关系。会计科目是企业进行财务数据核算工作的基础，各个国家基于企业监管与税收工作的需要而制定的会计法律法规都对之有相应规定。我国于2006年颁布的新会计准则将会计科目分为六大类：资产类、负债类、共同类、所有者权益、成本类、损益类，共计156个（一级）科目。简单的财务会计软件或单公司规模很小时，类似手工记账的“电算化”系统实现方式问题不大，但当会计业务管理需求复杂，企业从单公司向多公司集团化方向发展时，就必须考虑在系统层面如何方便地对多个公司的会计数据进行集中统一管理的问题。ORACLE的ERP产品最初也是从财务软件发展起来的，总账GL是其第一个应用模块。事实上，在计算机或管理软件出现以前，企业所谓“集团管控”的需求及实践早已存在。ORACLE财务软件中包含“多公司信息”的独特会计科目弹性域结构设计，使得财务工作的集团管控更加具备技术上的可行性与方便性。一个最基本、最简单的会计科目弹性域结构就是“公司代码+会计科目代码”的组合，它的原始业务需求来源并无多少深奥之处。在ORACLE的会计科目弹性域结构中，体现国家法律法规要求的“会计科目”成为其中必不可少的一个组成段即“自然账户”段，自然账户所使用的值集，即为通常所说的“科目表”。系统在自然账户之上附加“公司、部门”等多个段信息，大大方便了在公司内及公司间的会计数据的统计分析工作。如图4所示，就是一个典型的5段式会计科目弹性域结构：图中的“公司段”为“平衡段”（弹性域限定词 Flexfield Qualifiers，是具有某种特定属性的“识别标记”），表示在“公司段”层面，日记账（Journals，“会计分录”）的“借项等于贷项”，总是平衡的。其值集为包含所有公司的代码LOV，包括法律实体及基于公司管理需要而设定的运营实体；如图5所示会计科目弹性域结构的“公司段”值集定义：在EBS系统中定义的法律实体LE必须对应于公司段值集中的（至少）一个值（行），但R11与R12的区别是，R11在定义LE时并没有明确告诉系统对应（绑定）哪个段值，只要用户自己清楚并不混淆即可。而在R12定义LE时，需要将其与会计科目弹性域结构中的某个公司段值明确关联，这是R12的改进之处，避免了R11实际使用中当定义的法律实体LE数量较多时可能产生的混淆不清。“部门段”的弹性域限定词为“成本中心段”，成本中心LOV值可能是企业中的一个具体行政组织，也可能表示共享一个成本中心的多个行政组织的组合，还可能是表示基于统计管理需要而设定的多个成本中心的组合；如下图6所示：“账户段”的弹性域限定词为“自然账户段”，其LOV值即法定科目表及为统计需要而设置的汇总科目；如图7所示：注意，图7与图5、6中的“段限定词”的内容有所不同，它具体规定了自然账户的段值所代表的会计科目的类别（资产、负债等），“弹性域限定词”与“段限定词”是两个不同的概念，段限定词的取值受控于弹性域限定词的取值。会计科目弹性域结构的“子账户段”表示“二级科目或明细科目”，与账户段的一级科目具有汇总与被汇总的关系；“产品段”，则表示基于特定统计分析需要而设置的产品LOV。系统允许设置最多30个段，但必须至少包含两个段（平衡段、自然账户段）。由于会计科目弹性域结构一经设定并使用之后，以后修改比较困难，故通常会设定一个或多个预留段，如可在上述典型的5段结构之外再增加一个暂时不使用的段（预留段）而成为6段结构。会计科目弹性域结构的设定是系统基础设置的重要工作之一，有关详细设置方法与步骤请参看相关系统设置文档。此外，EBS系统针对所有弹性域的“段值”的接入权限，提供了“安全性”设置功能，控制“责任”实际可以使用的段值范围，如下图8所示： 三、帐套（分类帐）会计科目弹性域结构（COA）、币种（Currency）、日历（Clander）三者的组合构成EBS R11及之前系统的所谓“帐套”（SOB）。在R12中，再增加一个维度“会计方法或会计惯例”，即成为所谓“分类帐”。所谓“会计方法或惯例”，例如对于不同国家或地区、不同企业，会计法规可能规定物品单价5000元是作为“固定资产”还是“期间费用”处理的判定标准，也可能规定这个判定标准是1万元。标准不同，记账的会计科目也就不同，企业报告的经营结果也就会有差别。一个诸如在香港注册的企业，一方面需要向香港政府机关提交符合本地法规的财务报告，另一方面可能还需要向在国内的总公司提供符合国内法规的财务报告（便于考核管理），这就出现所谓“多账簿”（对应R12中的主辅分类帐）的系统功能问题。如下图9是EBS R11中“帐套”的定义界面：如下图10所示是EBS R12中使用“会计科目管理器AMB”设置“主要分类帐（Primary Ledger）”与“辅助分类帐（Second Ledger）”的定义界面：R12中定义的一个“主要分类帐”可以附带定义与之关联的多个“辅助分类帐”，如下图11所示：“主要分类帐”与“辅助分类帐”，可以有不同的科目表结构（COA）。由于系统其它的应用模块（R12中称之为“子分类帐应用产品”），例如PO/AP/AR等等，其事务处理默认是基于“主要分类帐”的会计科目表（COA），所以，如果主辅分类帐的科目表不同，则必须在两者之间建立“映射（Mapping）”关系（1对1或多对1的关系）。如下图12所示为主辅分类帐的映射定义界面，如果两者科目表相同（币种不同），则该定义界面将有所不同，没有“科目表”映射的内容，只有后面部分（币种转换及日记账转换等）： 下图13所示为当主辅分类帐的科目表不同时，系统科目表映射的定义界面，账户规则定义中可见，源账户可以是一个范围，而目标账户只能是一个：ORACLE EBS R12中四维（4C）定义的“分类帐Ledger”构成了ORACLE系统“多账簿”功能的处理基础。实际上，在R11中三维（3C）定义的“帐套SOB”也有“多报告币账簿”的概念，但那仅限于财务报表在不同币种之间的自动转换，并不是真正意义上的系统“多账簿”功能（即一个公司自动生成符合会计法规要求的多套帐）。ORACLE EBS R12“多账簿”功能的核心与关键是各相关应用模块（子分类帐应用产品）在向总账模块传送日记账时，如何自动为总账中的“主要分类帐和辅助分类帐”自动生成各自的日记账分录。这就涉及到分别为主辅分类帐设置图10中的 “子分类帐会计选项”的问题，它实际包括两个步骤，一是为系统定义哪些应用模块可以使用子分类帐会计方法（ORACLE已经预定义）；如下图14所示，系统已经预定义了包括PO/AP/AR/CST/FA等在内的21个需要用到子分类帐会计方法的应用产品：二是为已经定义子分类帐的应用模块分别针对主辅分类帐设置“子分类帐会计方法”，如下图15所示： 其中的“事件分类选项”及其相关设置是系统最基础、最复杂也是最抽象的过程，包括了复杂的用户预定义工作，诸如会计事件分类（Event Class）与会计事件类型（Event Type）组合定义、日记账行定义、日记账行类型定义等等。每个子分类帐应用产品的系统事务处理默认是基于主要分类帐的“代码组合”及其账户生成器规则，当子分类帐应用产品系统启动“向GL传送日记账”流程时，对于每个会计事件分类的“分类—类型”组合，流程将按照“子分类帐会计方法”中所包含的日记账行类型之“条件”与“账户推导规则”生成相应的“帐户代码”（CCID）及日记账行。不同的分类帐如主辅分类帐，生成的CCID可能不同，而这正是“多账簿”功能所需要的。有关“子分类帐会计方法”设置的详细过程需参照ORACLE相关文档。如下图16所示仅是其中的定义界面之一：对于EBS R12来说，即使不使用辅助分类帐也要为“主要分类帐”添加“子分类帐会计方法”，它可以使ORACLE预置默认的，也可以使用户修改后自定义的。实际上对于EBS R11来说，安装时相当于ORACLE为所有的SOB直接预置了子分类帐会计方法，系统将复杂的子分类帐会计方法定义向用户屏蔽了，用户无法修改调整。复杂的“子分类帐会计方法”定义是EBS R12为实现“多账簿”功能而必须付出的代价。所幸的是它只对GL模块的使用有一定影响，对各相关应用模块的用户使用并无直接影响，从R11到R12，“多账簿”功能只相当于多调用了一个“服务”，EBS系统升级与使用保持了良好的继承性。在EBS的总账GL模块中，由于工作的对象主要是基于“账户代码”的日记账（会计分录）的数据信息，来自各业务模块的有关不同公司的会计数据的“组织属性”实际上通过账户代码中的不同公司段值已经得到体现，与各来源业务模块（子分类帐应用产品）中的相关“（业务）组织属性”设置无关。故总账模块与其它业务模块比较，总账模块无需再作所谓“组织”的划分，可说是“无组织”的。总账系统用户一般来说可以处理所有公司的会计数据（除非作弹性域段值的安全性设置）。如果一定要说总账GL也有类似业务组织属性划分的话，那么这个“组织实体”就是帐套或分类帐，系统将使用类似业务模块的“组织接入”配置文件（如“MO：业务实体”）的“帐套接入”配置文件（例如R11的“GL 帐套名”或R12的“GL：数据访问权限集”、 “GL 分类帐名称”等），来分隔用户的工作权限。有关“帐套接入”配置文件的使用有下述注意事项。对于配置文件“GL 帐套名”， R11中该参数的LOV由系统基于创建的SOB名自动创建，一旦为其赋值后，用户登录时系统自动定位于已指定SOB。由于GL模块与OU无关，所以进入GL后，数据的区隔主要基于这个参数，但这个参数并不限制某些需要跨SOB功能如FSG对数据的访问。如下图17所示：对于配置文件“GL 分类帐名称”， 该参数只在R12中有，类似R11中的“GL帐套名”，但作用与R11大不相同，其LOV为分类帐名的集合（创建时自动添加），只表示当前用户所进入的该“分类帐”同时还需要用到子分类帐产品诸如AP/AR等等。如下图18所示（而当前用户所能够进入的分类帐则是由“GL：数据访问权限集”控制）：对于配置文件“GL：数据访问权限集”， 该参数只在R12中才有，必须设置（有值），否则系统会报错。但是系统给出了特别控制机制，即在每当修改设置“GL 分类帐名称”时，系统会同时自动修改“GL：数据访问权限集”的值，使之与“GL 分类帐名称”的值一致。如果是先设置“GL 分类帐名称”，后修改了“GL：数据访问权限集”的默认值，则系统在进入日记账的FORM时，如果后者的值不包含前者的值，则前者的设置被无效，但系统无法使用相关子分类帐产品。如果后者的值包含前者的值，则前者的值代表该分类帐还需要使用相关子分类帐产品。如下图19所示：配置文件“GL：数据访问权限集”的取值LOV需要在系统中另外设置，每个取值包含了若干已经定义的分类帐/分类帐集及其读写权限，用户进入后，可在FORM界面于其中选择切换，如下图20所示：要特别注意，对于R12的“GL 分类帐名称”的任何一次修改（包括清空），都会自动影响“GL：数据访问权限集”的值。系统之所以如此设计，目的在于保证原R11的业务控制功能不变，通过增加参数，在R12中控制“可访问数据的范围”。因此正确的做法应该是：先设定“GL 分类帐名称”的值，实现基本的业务功能（与子分类帐产品关联），再修改“GL：数据访问权限集”的默认值，控制数据可访问范围，但必须保证其值包含了前者的值。测试中发现，如果“GL 分类帐名称”配置文件值留空，而修改设定了“GL：数据访问权限集”，“GL：数据访问权限集”默认的分类帐并未出现在FORM的窗口界面中，这似乎是设计人员的疏忽。ORACLE GL 在“创建分类帐、定义分类帐集”时会自动创建“数据访问权限集”LOV值，并且其类型为“全部分类帐”，提供完整读写权限。在需要进一步限制对分类帐、分类帐集或分类帐/分类帐集的特定平衡段值或管理段值的读写权限时，用户需要创建自己的数据访问权限集。在R12中还可以为财务系统另外定义“访问权限集”（不同于参数“GL：数据访问权限集”），并分配给责任来限制该责任所具有的功能（当然这是在已经进入的当前分类帐之下的）。系统预置了一个“超级用户定义访问权限集”（不可修改）。推测“权限”的限制方式可能是“倒剥式”（为空时，权限最大，每增多一项，就少一个与之对应的权限），如下图21所示：最后需注意的是，EBS系统所谓“多账簿”功能与“多帐套（分类帐）接入”功能是两个不同的概念。“多账簿”功能表示“一个用户的同一业务处理，系统自动生成多本帐”，反映的是系统业务处理功能，R12具备，而R11不完全具备（R11仅能提供多币种报表）。“多帐套（分类帐）接入”功能表示“一个用户如何接入多个帐套（分类帐）”的权限管理方式（“上下文”环境切换方式），R11也具备，但对于同一用户，必须通过在具有相同业务功能的不同责任间切换才能实现，使用时不是太方便，而R12的同一用户，无需进行“责任”切换，仅通过在表单上直接选择切换就能实现，使用比较方便。R12与R11的上下文切换方式虽然不同，但切换后的系统业务处理功能则基本相同。四、组织架构在企业管理实践的过程中，“组织”（Organization）一词是个经常需用到的概念，一般与“人员”与“职能”这两个要素密切相关，反映某种行政管理关系，例如“财务部、销售部、采购部、生产部、仓储部”等等。企业内部行政组织（部门）的划分是企业基于“职能驱动”业务管理模式进行运作的基础。目前，国内适用于小企业使用的大多数低端管理软件并不考虑系统中的“组织”设置问题，其系统应用模块的划分，例如采购模块、仓管模块、销售模块等等，实际上就已经基本反映了企业运作的“组织职能”划分问题。但是，对于业务复杂、规模较大的企业（如所谓“集团企业”），管理软件使用与实施的系统“组织设置”问题将是一个首要的重要问题。一个常见的、也是错误的系统实现方式就是将企业的“行政组织设置”直接映射到系统中，以“行政组织”代替“业务组织”。这种系统实现方式虽有理解、掌握比较容易的优势，但却完全违背了大企业运作必须基于“流程驱动”业务模式的基本管理原则。国内有所谓高端管理软件在系统实施过程中，常常出现有几十个财务、采购组织，几百个销售组织，乃至上千个库存组织的“盛况”，导致系统几乎没法使用的困境，其症结正在于此。与企业的“行政组织”设置与人员规模密切相关且复杂多变不同，软件系统的“组织设置”必须以业务流程运作为核心，要求尽可能简单并保持相对稳定，在公司（人员）规模扩大的过程中具有延续性与继承性。作为ERP鼻祖的SAP将系统组织简单地分为“集团（Client）、公司代码（Company Code）、采购组织（Purchase Org）、销售组织（Sale Org）、工厂（Plant）”等类别。ORACLE的组织设置本质上与之基本相似，但作为后来者作了进一步抽象与简化，系统组织划分为“业务组（Business Group）、法律实体（Legal Entity）、业务实体（Operating Unit）、库存组织（Inventory Org）”等。如果说SAP的组织模型字面上多少还带有一点“行政组织”痕迹的话（这可能是某些声称学SAP的国内产品误入歧途的原因），ORACLE系统的组织模型字面上已经几乎看不出与“行政组织”还有什么关系，其中的“Inventory Org”现今中文翻译成“库存组织”，容易令人望文生义和企业的“仓库管理部门（Warehouse）”混淆，但Inventory的本义实际应该是“存货”，称之为“存货组织”或许更好一些。如下图22所示ORACLE系统有关核心业务的多组织模型：上图中的“财务、销售、采购”并非系统的“组织实体”，它仅表示业务实体（OU）具有的相关业务处理功能。“子库”是特殊的系统组织实体，没有上下文环境可进入，主要表示库存组织之下的某种业务功能。（一）业务组（BG） “业务组”的概念可以与企业的“集团”概念参看，但不同的是一个企业在系统中可以设置多个“业务组（集团）”。通常对于一个企业来说，系统中有一个“业务组”就够了，这表示企业就是一个“集团公司”。而对于某些业务“多元化”的特大型公司（如跨国公司），则可能需要在系统中设置多个“业务组”，表示企业由多个“集团公司”组成。业务组设置是系统组织设置的第一步，是最高层级的组织形态，但它主要是与人力资源信息的分隔有关，即“人员信息”的设置在一个BG范围内是由各业务模块共享的（如果需要）。一旦系统设置的用户名（User）被与“人员”（Employee）关联，无论使用什么“责任”进入系统，都会定位至一个确定的BG中，任何责任在任意时刻只能关联一个BG。EBS安装好后，系统里面已经预置了一个名为“Setup Business Group”的“初始业务组”。如图23所示系统预置的“Setup Business Group”：当以系统预置超级用户SYSADMIN进入后，应首先设置一个具有在HRM或INV下创建组织功能的“责任”名，随后给此责任的“HR：User Type”配置文件设定值为“HR User”，则该责任就有了创建新BG的能力。通常需要一次性将企业所需要的BG全部建立，一般另创建一个与企业名称一致如“某某集团”的新BG就可以了，也可以（不推荐）直接使用系统预设的“Setup Business Group”而不创建新BG。系统每新建一个BG，就会自动在配置文件“HR：安全性配置文件”的LOV中自动添加一个与新建BG同名的可选值（初始时只有“Setup Business Group”一个值）。在某一个BG下（初始为Setup Business Group）新建的任何责任，系统都将该责任的配置文件“HR：安全性配置文件”值默认为当前BG。要在进入系统时能切换到新的BG，必须先修改该责任的“HR：安全性配置文件”设定值。如果将配置文件“HR：交叉业务组”的值设为“是”，则在不同BG下，新建的组织名称应当（虽然可以）不同，否则查看时可能会引起混淆。在同一个BG下的所有新建组织，名称不允许相同。（二）法律实体（LE） 法律实体（LE，Legal Entity）对应于真实世界中的按国家法律法规要求注册的“法人公司”。在R11中，LE在组织FORM定义时，对于每个LE必须为其“法人主体会计科目”关联一个“帐套SOB”。每个LE对应一个SOB，这与真实世界的法规要求是吻合的。如下图24所示：要注意的是，在R11中定义的LE时，并未作与“会计科目弹性域结构”的“公司段”值关联，用户必须对于其是与公司段值中的哪个值对应心中有数。而在R12中，LE的组织定义虽在FORM中仍然保留，但LE的“法人主体会计科目”的FORM设置被废弃（故FORM中定义了也无用），改为在定义“分类帐”时的“会计科目设置管理器”WEB中定义并分配法人实体LE。一个分类帐设置（主辅分类帐）可以添加多个LE，但每个LE只能具有一个分类帐设置。如下图25所示：在R12中，还必须为法人实体分配会计科目弹性域结构的公司段即平衡段值。每个LE可以分配多个“平衡段”值，公司段值集中每个段值一旦被分配给某LE，则其它LE就不能再被分配。在R11或R12中创建一个LE后，应当及时到会计科目弹性域结构中添加需要对应的公司段值LOV（一个或多个），并重新进行弹性域的编译，否则系统可能会弹出错误报警信息。R12中一个LE对应多个公司平衡段值，代表有多个分公司，LE是它们的合并。主辅分类帐可拥有相同或不同的公司段值集，表示从不同的维度（如按地区、按产品等）去划分公司以方便考核。如图26所示为LE添加平衡段值：无论是R11还是R12，法律实体LE的设置都对具体的业务处理影响不大，其与系统用户或责任不关联，不直接影响系统上下文的切换，故有人甚至认为EBS的LE设置作用不大。这对于系统的内部运作来讲情况确实近似如此，但对于需要通过系统产生供外部使用的具有法律意义的文书（如采购订单、财务报表等等），严格区分法律实体LE还是必须的。R12显然更多地考虑了外部使用的这种法律要求（即所谓“法规遵从性”或“合规性”），并在相关业务应用模块中有所体现。（三）业务实体（OU）业务实体（OU，Operating Unit）是EBS系统组织设置的重点也是难点之一。它与法人主体LE本身没有必然的关系，与会计科目弹性域结构中的“公司段”也没有直接关系。从企业实际业务管理需要的角度去看，业务实体OU可以看作是在系统中按照业务的相似性，把多个不同公司（包括LE）的业务处理过程及数据划分成相对独立的“管理单元”。在每个管理单元内部，各公司的业务运作共享相关数据并执行统一的业务策略。例如，有一个业务多元化的企业既生产医院使用的X光机也生产普通电视机，并且其下属在全国各地有多家生产X光机或电视机的分公司、子公司。由于这两种产品所使用的物料、供应商以及针对的客户群差异很大，企业为方便管理，可以将“业务运营”划分为两个相对独立的“业务管理群组”，对应到EBS系统中就是两个业务实体OU。从企业日常业务运作管理的角度来看，对于单纯的电视机业务，全国范围内就设一个公司负责计划、生产、采购、销售等运营管理最为简便，但企业从非运营管理角度例如“税收优惠、地方政策”等等因素考虑，有时不得不在全国各地乃至世界各地注册若干所谓“公司”，以便向当地政府纳税并接受其财务会计方面的监管。EBS在一个业务实体OU下，例如“电视机管理群组”，包含了全国各地所有负责生产或销售电视机的分公司、子公司（LE）的日常业务运作，在业务运作的组织层面忽略了作为法人实体的公司信息，但在反映业务运营最终结果的财务阶段（GL），仍能够方便地按照各地的法规要求提供财务数据与结果。而对于负责具体业务的系统用户来说，日常工作几乎不用关心或考虑“公司”的设置问题。EBS中LE的数量可以根据需要任意增加，但对于OU的数量基于管理方便性则要求尽可能精简。EBS产品早期在实施过程中，存在一个公司（LE）对应一个OU的做法或一个OU只能属于一个LE的说法，这种做法或说法并不恰当。某些国内产品的设计由于未能有效区分“法律实体（公司）”与“业务实体（运营）”两者在系统中既相连接又有本质区别的特殊关系，只好采取一个法人公司对应一个系统业务实体的“笨办法”，企业规模小倒还能对付，一旦规模变大，注册公司增多，所谓的“系统多组织架构”就变得根本不具可用性。ORACLE EBS业务实体OU的这一系统特性极大地方便了企业运作的日常管理，具有高度的灵活性与可扩展性。如下图27是R11的OU定义界面：图中的“业务实体信息”中，必须而且只能为之设定一个“帐套”，即一个OU只能属于一个帐套（反之，一个帐套可以分配给多个OU）。要注意的是，上述业务实体信息中的法人实体设定，并不代表OU只能属于一个LE，它只是表示在“业务实体”中进行业务操作需要法人实体信息时提供默认值（在R12中明确了是“默认值”这一点）。R12中的业务实体定义同R11基本相同，只是将帐套改为“主要分类帐”。在EBS中，一个OU可以同时指定给多个LE，上面“电视机管理群组”的例子已经说明了这一点；一个LE也可以有多个OU，这相当于一个注册的法人实体公司下，有多个需要独立运营的“事业部”（如X光机和电视机）。OU与LE是“多对多”的关系，但有一个限制性的前提条件，即OU与LE必须属于同一个SOB或Ledger。由于LE与OU的设置在系统中可以独立进行，因此如果双方的SOB或Ledger不同，则不能建立连接关系。如果说法人实体LE与真实世界的企业行政管理组织架构还有点关系的话，业务实体OU则是与行政管理几乎无关，企业内部的行政组织变化对OU的设置没有直接影响。在EBS中有关采购管理、销售订单履行、应收应付管理等业务模块的功能均是建立在OU基础之上的。用户在执行上述相关模块的业务处理时，总是必须进入确定的OU（上下文环境）才可以进行，EBS的所谓“多组织”功能（MOAC）也是针对多OU而言的，与真实世界中的“多公司”（LE）没有直接关系。实际上，SAP的“采购组织、销售组织”设置也是与真实世界的行政组织“采购部、销售部”无关的，ORACLE抛弃了“采购组织、销售组织”的概念，OU实际上就起到了类似的组织分隔作用。ORACLE的某些相关文档中，如果因描述需要而提及所谓“采购组织、销售组织”等概念，有时实际指的就是业务实体OU（或OU下的库存INV组织）。（四）库存组织（INV） ORACLE EBS的库存组织（INV）是系统组织设置的最基础、也是最重要的工作之一。库存组织的内涵远不是真实世界的“仓库部门”那么简单，它除了是有关“物料接收与发出”等业务功能的基础之外，更重要的是，它还是EBS系统有关计划（MPS/MRP）、在制品管理（WIP）、物料清单（BOM）等模块业务功能的操作与管理平台。如下图28所示：EBS中的库存组织INV的作用与功能可以与SAP中的工厂Plant参看。一个库存组织INV只能属于一个确定的帐套SOB、一个确定的法人实体LE、一个确定的业务实体OU，具有唯一性的关系（注意：R11的设置界面未考虑SOB/LE/OU的关联限定，容易产生错误；R12作了改进，在选定Ledger之后，可用的LE/OU就被限定）。反之，一个“帐套/法人实体/业务实体”组合则可以有多个库存组织INV。此外，一个OU下的多个INV可以对应属于该OU的不同LE，这相当于将分属于两个法人公司的生产两种产品的四个工厂，按相同产品两两组合抽取出来，分属于两个不同OU进行日常业务管理。在EBS中还有两个组织概念“MRP组织、WIP组织”，它们实际是必须构建于库存组织之上的组织概念，表示该库存组织还可以进行MRP或WIP的功能。系统之所以如此处理，主要是为了控制某些INV不能做MRP或WIP而已，因为基于物料接收或发出需要所设定的INV数量可能比较多。对于绝大多数基于库存组织INV的业务功能（个别除外），系统用户在做业务操作时，均必须首先进行INV的选择切换，以便进入确定的INV上下文环境。库存组织的作用是如此基础，以至于EBS的相关文档在提及组织（Org）概念时，如果未作特别说明，默认就是指INV组织。（五）公司成本中心（Cost Center）EBS的所谓“成本中心组织”并没有业务处理的功能，它的设置主要是考虑与“会计科目弹性域结构”中的“公司段值”与“成本中心段值”的对应关系问题。如下图29所示：在系统中创建“公司成本中心组织”后，可以运行一个“并发检查程序”，以校验“会计科目弹性域结构”中的段值是否与所有的“公司成本中心”组织的设置保持一致。当在“会计科目弹性域结构”中的“成本中心段”值集中添加LOV值并重新编译后，可以运行系统的“自动组织”并发程序功能，由系统自动创建“公司成本中心”组织。应当注意的是，一个公司成本中心组织及其成本中心段值，不可能属于不同法人实体LE及其公司段值，这与真实世界中的管理要求是一致的。库存组织INV与会计科目弹性域中的“成本中心”段（部门）则具有“一对一或多对一”的关系，即一个“成本中心”段值可以有多个库存组织INV，但一个库存组织INV只能属于一个确定的成本中心。（六）HR组织 系统的HR组织设置是与HRM模块的相关业务处理功能相关，与核心业务/财务处理功能关系不大，主要是需要注意其是否和“成本中心”关联，需要时可以输入“成本中心”代码，其LOV就是“会计科目弹性域”结构中成本中心段的值集。如下图30所示：（七）多组织接入控制在图30的EBS组织设置界面中，所谓的组织“类型”（Type）划分仅是基于组织自身的统计分析工作需要而定义的一个“维度”，例如“公司总部、产品线”等等，并不影响系统的业务处理功能。真正起作用的是设置界面中的“组织分类”（Classification），系统预置的组织分类LOV除了上述“业务组、法律实体、业务实体、库存组织”等之外，还有诸如“资产组织、运营公司、雇主”等等选项。在EBS系统中各应用模块所具有的业务处理功能通常需构建在一个确定的“组织分类”之上，“组织”是相关业务处理功能的平台，企业是否需要作相关组织分类设置、如何设置，取决于企业所需要使用到的应用模块功能。例如所谓“资产组织”的设置，它是在企业需使用到资产管理模块FA时才涉及到。“资产组织”实际上是所谓“资产账簿”的代名词，它只是表示有关资产信息的一个数据维度，作用主要在于分隔数据范围，用户进入系统作业务处理时，并不需要作上下文业务环境的切换。对于这类并不涉及“上下文”环境切换的所谓“组织”，ORACLR系统的设计主要是为了借用“组织”所具有的“层次结构”（Hierarchy）概念来达到“多组织接入”权限的控制功能。需指出的是，这里的组织“层次结构”与真实世界企业的行政管理组织层次结构没有直接关系（尽管可能有所参考），它只是企业根据某种需要（如权限管理控制、数据统计汇报等）而人为设定的一个“层次结构”，例如将系统中已经设置的任意数量的“业务实体”或“库存组织”等等组织Name，人为地设定一个具有上下级关系、自顶向下的金字塔形多层结构。如下图31所示：上图中开始定义时，一旦选定（最）顶端组织Name，则就只能为之分配下属组织Name，如要给下属组织分配更下一级的组织，则需点击“向下”按钮，将当前该下属组织上升到“顶端组织”位置。点击“向上”按钮，则将当前“顶端组织”下降到下属组织位置。企业可以根据实际需要设定若干个具有不同内部结构的“组织层次结构”Name，以供定义系统所谓“安全性配置文件”时调用。如下图32所示：上图所定义“安全性配置文件”是系统用以控制包括“组织安全性”等在内的各种安全性控制的基础，它具体规定了系统安全性控制的范围与实现方式，所有定义的“安全性配置文件”Name构成系统多组织接入控制参数“MO：安全性配置文件”的LOV。如下图33所示：EBS 通过“MO：业务实体”、“MO：安全性配置文件”、“MO：默认业务实体”这三个系统配置文件的共同作用，实现所谓“多组织接入”控制功能MOAC。但上述三个配置文件在R11与R12中的作用有比较大的差别。对于“MO：业务实体”， 在R11中必须设定，而且起决定性控制作用，其LOV由系统基于创建的OU name自动创建，用户登录时系统自动定位于指定OU。而在R12中，一旦设定“MO：安全性配置文件”，则此配置文件失效而不起作用。对于“MO：安全性配置文件”， 在R11中虽有，但实际不起OU接入的控制作用，只针对FA等模块的得某些应用如数据统计等起作用。因此，一般认为R11并不具有完善的多组织接入控制功能。在R12中，该参数如果不设定，则必须设定“MO：业务实体”参数；一旦该参数被设定，则就起决定作用，系统主要依赖其实现MOAC。对于“MO：默认业务实体”， 在R11中虽有但实际不起作用。在R12中，随“MO：安全配置文件”起作用后才起作用，其LOV是所有已定义OU，但如果设定值不在“MO：安全配置文件”所选择的“组织层次架构”的范围内，则仍不起作用（即在与OU相关诸如PO、OM等的FORM界面，OU字段的默认值仍然为空）。这似乎是ORACLE 系统设计方面的一个难题，即“MO：默认业务实体”的LOV值集无法与“MO：安全性配置文件”中“组织层次架构”中的OU值范围保持一致。ORACLE强调其“多组织接入MOAC”功能主要是针对业务实体OU而言，其另外一层含义是，所有构建于库存组织INV上的应用功能，实际是与上述配置文件无关的。库存组织的可接入性是在“组织访问”控制功能中，专门设定“库存组织”与“责任”的关联性，如下图34所示：按照ORACLE的说法，如果系统在初始的时候，不定义库存组织的“组织访问”控制，则所有“责任”可访问所有INV，一旦限制或分配其中一个，则其余均必须逐个进行分配以建立“库存组织”与“责任”的链接关系。总之，EBS系统通过“弹性域段值安全性”、“帐套/分类帐安全性”、“多组织接入安全性（MOAC）”、“库存组织访问控制”等多维度、多方面的组合系统设置，提供了灵活、方便的用户权限管理功能，厘清并掌握它们的复杂关系是系统实施的一项重要基础性工作。五、基础数据基础数据通常是指与具体业务关系不大且具有全局性、基础性的一些基本数据，例如日历Calendar、币种Currency、汇率Rate、单位UOM、地点Location等等。这些基础数据的系统设置有些比较简单如“币种”，有些与真实世界的情况相似如“日历”，有些则可能比较抽象复杂如“地点”等等，情况多种多样。以下择其要者，作简要说明。（一）关于“日历”。EBS中的日历设置，实际包括两大类，一类是与会计工作相关的，包括“会计日历”、“会计事务处理日历”等，它们的使用范围较小，有专门用途，一般是在总账模块设置（这里不赘述）。一类是工作日日历，它与企业的日常业务工作相关，使用范围广泛，大多数涉及库存组织的业务模块都可能与之相关，如下图35所示：需要注意的是，在新设置工作日日历或更新已存在工作日日历后，需要通过在工具栏的“建立”功能启动一个后台并发程序，以最终完成设置工作。（二）关于“币种”。各国或地区的“货币”是一种客观存在，EBS系统已经预置几乎所有企业可能使用到的币种，必要时还可以添加。用户可以决定哪些币种需要启用，以及维护其使用时的“精确度”。如下图36所示：（三）关于“汇率”。企业对于不同币种汇率转换的管理是一项重要的基础性工作，它对企业的经营结果有重要影响。为方便该项工作的开展，EBS系统专门提供了一个名为“币种管理器”的工具，如下图37所示：企业可以根据工作需要设定多个“汇率类型”（系统初始预置了Corporate值），并为之维护“每日汇率”或基于帐套的“期间汇率”。汇率的维护可以按一段时间范围来进行，也可以通过外部的“电子表格”导入数据。（四）关于“单位”。计量单位虽然也可以看作是一种客观存在，但单位与基本单位之间的转换关系，则可能是与具体物料相关的（例如鸡蛋1斤=15个，鸭蛋1斤=10个等，转换系数不同）。由于EBS的物料是定义在库存组织INV上的，故单位及转换关系也是基于INV设置的。如下图38所示：EBS的单位转换，提供了不考虑具体物料的“标准转换”，例如1米=100厘米等，也提供了基于不同物料的在同一“单位分类”（如长度、重量、体积等）内部的转换，例如牛奶 1箱=20盒，茶叶 1箱=10盒等；以及不同物料在不同“单位分类”之间的转换，例如牛奶 1公斤=4盒，茶叶 1公斤=2盒等。（五）关于“地点”。EBS中所谓“地点”的概念不仅非常抽象，而且十分重要，因为系统相关业务处理功能如“接收、发运、人员分配”等等都与“地点”密切相关。EBS中的所谓“地点”原意实际上涉及三个词：Location、Address、Site。译成中文都可称“地点”，也是导致其理解困难的重要原因之一。如下图39所示：Address（地址）比较好理解，它表示一个地理坐标概念，例如“北京市朝阳区安定路甲3号”等，EBS系统以一个“说明性弹性域”来精确描述，非常方便。各个国家的Address表述方式可能不同（如中国与美国有差别），故系统有所谓“中国式地址”、“美国式地址”之分等等。Location（地点）的系统涵义则理解比较抽象，系统定义的名称可以看作是与一个具体Address相关联的一个或多个不同“称谓代号”，例如与上述Address“北京市朝阳区安定路甲3号”关联的Location“鸟巢、国家体育场、奥林匹克公园、奥运主会场”等等。也可以是一个不与具体地址Address相关联但大家都明白的称谓代号，例如Location“首都机场”等等。EBS系统最初使用比较“简短”的Location代替比较“冗长”的Address，仅仅是为了方便IT“标准化”处理的需要。但在以后的发展过程中，系统设计逐步赋予Location更多与业务处理功能相关的“属性”，为了区分这些不同属性，系统以Site（站点）来加以区分，如图39中所示，一个Location可以具有“发运到Ship-to”、“接收至Receiving”、“开票到Bill-to”、“内部Internal”等等不同系统功用。更进一步，EBS系统使用“地点”来实现采购申请、接收、运输清单和人员的分配，以及确定内部组织与内部客户、供应商的关联关系；使用同一供应商的不同Site来区分定义供应商所具有的不同“业务控制”属性；使用同一客户所具有的不同Location—Site组合来区分定义客户所具有的不同业务功能（OM的某些业务功能必须将客户的外部Address—Location组合与系统内部Location关联方才有效）等等；详情以后相关模块再进一步讨论。总之，搞清楚EBS系统Address、Location、Site的三者关系，对于理解掌握系统功能十分重要，其核心与关键是不能将比较抽象的Location或Site与比较具体的Address等量齐观，两者虽有一定关系，但Location或Site更多地是从系统实现的需要出发，而做的某种“形而上”表达。六、并发管理ORACLE EBS系统在后台通过运行大量“并发处理程序”的方式保证相关业务功能的实现，系统需要对这些在后台运行的“并发程序”进行有效管理，这是通过所谓“并发管理器”来实现的。系统后台可以有多个不同的“并发管理器”来管理不同的并发程序，“并发管理器”本身实际上也是并发程序，对于这些多个“并发管理器”，系统也要通过“管理并发管理器”功能进行有效管理。系统内存在的所谓“并发管理器”按功用划分主要有三大类：内部监控程序、并发管理器、事务处理管理器。“内部监控程序”类型的管理器的功用是“监测处于并行并发处理环境下的内部并发管理器”。“并发管理器”类型的管理器的功用是“启动运行并发程序”；“ 事务处理管理器”类型的管理器的功用是“处理客户端用户发出的同步请求”。系统在初始安装后，已经预置有若干不同类型的20多个管理器，系统也允许用户根据特殊需要自定义新的管理器。以下重点介绍几个重要的预置管理器的有关内容：内部管理器。它充当所有其它管理器的“上层管理器”。内部管理器可以对单个管理器进行启动、验证其状态、重置以及关闭等操作。用户不能改变其定义（工作班次、特殊规则）。如下图40所示： 标准管理器。标准管理器可接受任何请求，它无特别的规定。标准管理器始终处于活动状态，即一年 365 天，一天 24 小时全天候工作。标准管理器可作为安全网使用，因为它始终可用于运行任何请求。其定义一般不可轻易更改，否则可能导致某些程序无法正常运行。如下图41所示：事务处理管理器。常规并发管理器只允许“异步”执行运行时间长、数据密集的应用程序，而事务处理管理器则也支持“同步”处理客户机端发出的特定请求（并发程序请求运行计划的“立即”执行选项，本质上仍属于“异步”方式）。如果客户机程序发出同步运行服务器端程序的请求，则事务处理管理器会立即运行此请求，然后将状态返回至此客户机程序。事务处理管理器会等待由客户机程序发送信号，而不会轮询并发请求表来确定该如何执行操作。如下图42所示：事务处理管理器（系统内部使用，“同步方式”）管理包括“物料事务处理、移动事务处理、资源成本事务处理、物料成本事务处理”的系统“联机”处理。系统在用户等待时“同步”作相关事务处理的处理，并且在完成后才将系统控制返回给用户。这在业务量较大、系统繁忙时，用户等待的时间可能较长，影响用户的工作效率。事务处理管理器（请求使用，异步方式），如果相关配置文件“TP：INV 事务处理处理模式”设置为“并发”或“后台”模式，则用户应当启动“物料事务处理、移动事务处理、资源成本事务处理、物料成本事务处理”管理器于适当的“周期”运行状态。通常在事务处理工作量比较大时，应采取这种方式，以节省在库存管理系统锁定事务处理窗口和处理事务处理时所花费的空闲时间，提高用户的工作效率。由于“事务处理”在整个EBS系统运行中的普遍性与重要性，系统为此提供了一个专门的界面功能（菜单项，非系统管理员也可授权使用）以满足对相关“事务处理”并发程序的管理监控（“启动管理器”的工作方式与提交“请求”类似），如下图43所示：上述“事务处理管理器”所管理的事务处理并发程序（成本管理器等），每个系统只运行一个“实体”，为所有组织、用户服务，故系统设置必须对其运行方式进行恰当的“计划”。与之类似的重要系统事务处理并发程序还有“计划管理器”（受“MRP管理器”管理），“接收事务处理处理器”（受“接收事务处理管理器”管理）。要注意的是，系统许多业务流程类的事务处理“并发程序” 由于承担的后台任务比较复杂，实际起着某种业务流程运作的管理作用，故习惯上也以“××管理器、××处理器”来命名，例如“计划管理器（控制计划系统有关预测冲减、需求冲减等等事项的自动程序，）、成本管理器（控制数据的自动计算与更新等等事项的自动程序）、接收事务处理处理器（控制PO接收的库存更新等事项的自动程序）”等等，不能与上一层的管理这些并发程序的所谓“并发管理器”相混淆。“并发管理器”定义时需要用到的“工作班次”（系统初始已经预置值Standard），需要预先设置以作为LOV，工作班次可以同时运行的“流程数”在定义并发管理器时应设置适当值。如下图44所示：“并发管理器”定义时需用到的“特殊规则”（系统初始无预置值），可直接输入“包括或排除”类型为“程序、请求类型、用户、ORACLE标识”的具体条目组合。这些条目的组合也可以事先定义为各种“组合规则”，供定义“并发管理器”时作为LOV调用。如下图45所示：有关“并发程序”的运行计划及其“并发管理器”的定义工作，应当考虑系统的负载均衡，以保证系统的性能与运行效率。对于系统运行的所有“并发管理器”，系统管理员可以在“管理并发管理器”窗口进行干预、管理，如“终止、重新启动”，以及查看“并发管理器”正在管理的“哪些程序”正在运行等等。如下图46所示：企业在系统使用过程中，基于业务变化发展得需要，不断地自定义开发各种“报表类”并发程序是一项重要的日常工作。这些自定义报表并发程序的系统管理方式没有什么特殊性，它可以使用系统预置的“并发管理器”进行管理，也可以自定义新的“并发管理器”。对于EBS系统中处于各种运行状态的并发程序，系统管理员可以在“请求”窗口，通过设定不同查询选项（如特定请求之状态、阶段等等），查询监控相关“并发程序”的进程状况，并根据实际情况作出处理（如暂挂、重启、取消、诊断等等）。如下图47所示：七、工作流系统关于工作流的设置工作包含两部分工作，一是基于企业的特殊需要，使用Workflow Builder软件包工具自定义工作流。详情需参考ORACLE的相关文档，这里不赘述。二是为系统设置工作流管理员。系统在安装后的初始化工作流管理员是系统超级用户SYSADMIN，企业应当首先使用SYSADMIN进入系统，将工作流管理员改为一个真实的用户，或者输入“*”，则所有用户都“可以”具有工作流管理员权限（用户实际是否有工作流管理权限还必须取决于其被赋予的“责任”或“菜单”功能），如下图48所示：实际具有工作流管理权限的用户在进入工作流管理“开发员工作室”TAB页后，可以查询出系统所有的“工作流类型”，可选择其一作具体设置，如下图49所示：上图中，工作流管理员选定具体需设置的工作流后，点击“运行”则可以打开该工作流的“属性”设置界面（具体有哪些属性可设置，不同工作流各不相同），如下图50所示：工作流管理员在工作流管理“状态监控程序”TAB页，可以监控选定工作流的具体运行情况的若干条目列表，针对每一个条目，可以查看其“活动历史记录、状态图、参与者回应、详细资料”等若干信息（必要时工作流管理员可实施干预，如更新属性、倒退、暂停、取消等等）。如下图51所示：系统在各应用模块基于业务处理功能，预置有若干不同工作流，有关详情容以后结合具体业务模块应用再来讨论。以下重点介绍一个比较特殊的工作流：在多个业务模块中均需使用且系统实施必须事先完善设置的“账户生成器流程”。传统的手工业务模式下，所有可能涉及会计记账处理的业务处理例如物料接收、发出等等，作为业务处理人员在日常工作过程中是不需要考虑如何记账的，只是需要将有关业务处理记录例如入库单、出库单等作为原始凭证提交给会计人员去做处理。会计人员依据这些原始凭证制作“记账凭证”并手工为之指定“会计科目”或“账户代码”，以便正确地向总账GL实施“过账”。手工业务模式或会计电算化模式下，由于作为原始凭证的业务单据不包含准确的记账信息（会计科目或账户代码），需要会计人员手工去做处理，这在业务量很大，记账科目数量设置较多的情况下，会计人员的工作负担将十分繁重。再考虑人工处理难免有疏漏，可能需要反复“对账”，每月月底必须及时结账关账、时间紧迫等等因素，故非人工的、高度准确的“会计分录（日记账）”自动生成功能（即所谓“自动会计”）是系统设计时必须考虑解决的重要问题。在EBS系统中，账户代码被扩展为一个包含多个段组合的会计科目弹性域结构，系统在业务流程类表单例如采购订单、发票等做业务处理时，依赖所谓“账户生成器流程”根据业务处理的自身属性，自动生成准确的帐户代码组合并记录于业务表单的相关字段中，如下图52所示采购申请界面每个申请行（分配）所对应的“会计账户”（弹性域结构）：系统周期或人工启动向总账GL的“过账”流程，对符合条件的“事务处理”成批生成会计分录（日记账，是否还需复核审批视乎企业规定），一般来说无需再做繁琐的“对账”工作。这就大大减轻了会计人员的工作负担，记账科目数量的多少一般也不再成为障碍。（手工或电算化模式下，会计人员往往不愿意设置某些过渡性的“中间科目”，例如物料接收的“应计负债”等等，这对于会计工作的准确性有不小的影响）ORACLE系统基于每个新定义的分类帐（帐套）自动生成所需的“账户生成器”，系统预置有14个账户生成器（工作流类型），对于每个“账户生成器”可以根据需要设置不同的“流程”（每个工作流类型有其LOV值，还可以使用Workflow Builder自定义添加），如下图53所示：“账户生成器流程”是基于“会计科目弹性域结构”来设置的，弹性域结构不同，流程设置可以不同。对于每个“账户生成器”，ORACLE都提供了默认的流程供使用。R11的账户生成器生成的账户代码被直接用之于向总账GL传送，而R12由于存在“多账簿”的不同“会计方法”因素，各子分类帐产品（业务模块）基于事务处理会计科目弹性域结构通过账户生成器而生成的帐户代码，在向总账GL传送时，还需结合“会计方法”中的“账户推导规则”等设置，才能在总账GL生成正确的会计分录（日记账）。八、系统初始化设置（一）关于安全性。一个全新安装的EBSR12系统（Fresh Database），以SYSADMIN用户名登录，密码为sysadmin（注意EBS密码区分大小写），Home Page 可见系统所初始预置的10多个“责任”中包含“系统管理员”（System Administrator），如下图54所示： 进入系统的GUI界面后，在“用户”定义界面，可查询到有30多个初始化的User，比较特殊与重要的User 是两个“SYSADMIN、GUEST”，GUEST无密码设置，可以作为测试时的特殊用户使用。如下图55所示：其中有些User是系统残留，并不可用，还有些是只有用户名，但并未为之分配责任。注意，上图初始的GUI界面默认配色方案，为演示方便已通过配置文件“Java color scheme”做调整。系统初始预置的“责任”有1500多个，范围涉及所有模块的几乎所有“岗位角色”，企业可基于自身的管理习惯制定相应的责任“命名规则”，以定义新的“责任”。如下图56所示：系统初始预置的“菜单”有12000多个，基本上覆盖了几乎所有可能应用的需要，如企业需要“个性化”的菜单显示效果（prompt），则可以自定义用户菜单，形成特定的菜单结构。如下图57所示： 本文为测试需要，在系统中建立用户名MFG，并将常用模块的超级用户责任均与之关联。为测试方便，建一包含所有常用超级用户菜单的总菜单，并以此建一超级总责任，也与用户MFG关联。（二）关于配置文件系统配置文件总数有6600多个，绝大多数有初始化的默认值，可以有需要时再来修改，有关系统配置文件的设置情况（初始化时尤其可能希望了解），可以使用工具栏“File—Export”将它们全部导出，以方便的格式如EXCEL集中查看，如下图58所示：有些必须设置且没有默认值的配置文件，例如“GL Ledger Name ”、“MO：Operating Unit”等，由于其LOV取决于系统的其它具体设置如分类账（帐套）、业务实体OU等，故这些特殊的配置文件初始进入时会报错，如下图59所示：这些少数的特殊配置文件是系统初始化参数配置是的重点与难点，在完成相关会计科目弹性域结构、分类账、组织架构等等设置后，应及时为这些特殊“配置文件”赋值。（三）值集与弹性域EBS系统初始预置有16000多个值集名（Value Set Name，包括近2000个“验证”类型为“无”、无需LOV的特殊值集名），基本上都属于系统各表单所使用LOV的值集，有着特定的用途，这些值集也可以根据需要修改添加新的条目行。如下图60所示。而对于系统键弹性域与说明性弹性域所使用到的值集，则需要根据企业具体情况，进行完善的定义设置（尤其是38个键弹性域所需使用的值集）。关于键弹性域的设置，除了使用范围广泛的Item类别弹性域（Item Categories），系统已经预置有20个不同结构表示其在不同场合的多个应用之外（还可根据需要添加结构，系统预置的结构也可以进行更改，如下图61所示：）其它键弹性域如“会计科目弹性域”基本只有一个结构名称范例，并无具体的结构设置，需要企业根据自己的情况来完成设置。所有的说明性弹性域均无预置结构，均需根据需要从值集开始设置。弹性域结构的段也可以不选择值集而留空，则此时，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2cfafcfff97999fbb7b288bbbd2d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05d146defbba30915565dbe6d2e23cb/" rel="bookmark">
			刷题关键点总结-动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么情况下使用动态规划？ 满足下面三个条件之一：
1.求最大最小值
2.判断是否可行
3.统计方案个数
那么极有可能使用动态规划。
什么情况下不使用动态规划： 1.求出所有具体的方案而非方案个数 dfs等
2.输入数据是一个集合而不是序列
3.暴力算法的复杂度已经是多项式级别的：
4.动态规划擅长与优化指数级别复杂度(2^n,n!)到多项式级别复杂度(n^2,n^3)，不擅长优化n^3到n^2 以上情况极不可能使用动态规划来求解。 使用动态规划基本复杂度在O(n^2)上，对于数组特别长，或者数组内数字特别大的情况，可能不适用。
动态规划的四要素： 1.状态state
2.方程function, 转化方程。
3.初始化，非常重要
4.最终答案，对应哪个状态。
动态规划的优化重点：滚动数组，优化存储空间。
动态规划的常用题型： 1.坐标型动态规划 15%
2.序列型动态规划 30%
3.双序列型动态规划 30%
4.划分型动态规划 10%
5.背包型动态规划 10%
6区间型动态规划 5%
7.博弈型动态规划 滚动数组空间优化： 将二维空间优化为一维的，或者一维的优化为常数维的。跟相关状态有关。
f[i] = max(f[i-1], f[i-2] + A[i]) 转换为f[i%2] = max(f[(i-1)%2]和 f[(i-2)%2])即将一维的状态存储优化为常数项的。 转载于:https://www.cnblogs.com/sherylwang/p/9612771.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4fd0fc9ccc5d578bbfb7597e3e4db8/" rel="bookmark">
			Subarray Sum Closet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.
Given [-3, 1, 1, -3, 5], return [0, 2], [1, 3], [1, 1], [2, 2] or [0, 4].
这题求和最接近０的子数组，属于Subarray Sum的follow up．思路也很近似，每次求的是当前位置及之前的数组的一个和．但是这题并不是等于０，不会有一样的和出现，所以使用hashmap没什么可能．
在这种情况下，维护一个&lt;sum,index&gt;的pair的一个数组，将数组按sum值排个序．在排序后数组中找相邻位置的差值的绝对值最小的index. 小的是subarray开始的前面的一个index, 大的就是结尾的index.复杂度分析：
1.求＜sum,index&gt;的pair数组时间复杂度Ｏ(n).
2.排序Ｏ(nlogn)
3.相邻的挨个比较Ｏ(n)
总体时间复杂度为Ｏ(n),空间复杂度为Ｏ(n).
注意＜res,index&gt;这种pair的技术在two pointer等题中经常用，设置key值比较的技术一定要会．代码如下：
class Solution: """ @param nums: A list of integers @return: A list of integers includes the index of the first number and the index of the last number "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4fd0fc9ccc5d578bbfb7597e3e4db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864f9130a6481d66bed7c3668aaca369/" rel="bookmark">
			About the Storage  allocation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		It doesn't matter what programming language u use,it's all about the usage of variable---storage management.
1.Static &amp; Dynamic
static: Global constants and the other information/data generated by compiler are allocated static storage. Static storage is built before any execution,and they would stay in memory throughout execution.
Advantage: use for public /global generally; instance object with the same class share static data/function
Disadvantage:can't be changed(lack of flexibility);static function can't manipulate non-static variables
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864f9130a6481d66bed7c3668aaca369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848e50997137ec4e6005b68496e25146/" rel="bookmark">
			正则表达式验证身份证号码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;asp:TextBox ID="txtIDCard" runat="server"&gt;&lt;/asp:TextBox&gt;&lt;asp:RegularExpressionValidator
ID="RegularExpressionValidator1" runat="server" ErrorMessage="*" ControlToValidate="txtIDCard"
ValidationExpression="\d{17}[\d|X]|\d{15}"&gt;&lt;/asp:RegularExpressionValidator&gt; 转载于:https://www.cnblogs.com/xtsong/archive/2008/06/21/1227177.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e1b70aea9aa1f22b7464f88783f232/" rel="bookmark">
			swapper_pg_dir的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在内存系统初始化过程中，有如下代码：
1: static void __init pagetable_init(void) 2: { 3: pgd_t *pgd_base = swapper_pg_dir; 4: 5: permanent_kmaps_init(pgd_base); 6: } 这里，我们看到了神秘的swapper_pg_dir，全局搜索一下，发现了
1: /* 2: * Build a proper pagetable for the kernel mappings. Up until this 3: * point, we've been running on some set of pagetables constructed by 4: * the boot process. 5: * 6: * If we're booting on native hardware, this will be a pagetable 7: * constructed in arch/x86/kernel/head_32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e1b70aea9aa1f22b7464f88783f232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6011d79bcd733dce75aa54adc18a33/" rel="bookmark">
			C&#43;&#43; string的用法和例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/tengfei461807914/article/details/52203202
string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。 其中使用的代码多数都是来自cpp官网，因为例子非常全。
声明和初始化方法： 想使用string首先要在头文件当中加入&lt; string &gt; 声明方式也很简单
声明： string s;//声明一个string 对象 string ss[10];//声明一个string对象的数组 12 初始化： 使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { ios::sync_with_stdio(false); string s;//默认初始化，一个空字符串 string s1("ssss");//s1是字面值“ssss”的副本 string s2(s1);//s2是s1的副本 string s3=s2;//s3是s2的副本 string s4(10,'c');//把s4初始化 string s5="hiya";//拷贝初始化 string s6=string(10,'c');//拷贝初始化，生成一个初始化好的对象，拷贝给s6 //string s(cp,n) char cs[]="12345"; string s7(cs,3);//复制字符串cs的前3个字符到s当中 //string s(s2,pos2) string s8="asac"; string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size //string s(s2,pos2,len2) string s10="qweqweqweq"; string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义 return 0; } 12345678910111213141516171819202122232425262728 字符串处理： substr操作： 注意substr没有迭代器作为参数的操作
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { ios::sync_with_stdio(false); string s="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a6011d79bcd733dce75aa54adc18a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c102f264767058574a1e57e7c8c7680/" rel="bookmark">
			CSDN I’m coming
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是第一篇文章 为什么要建立这么一个账号？ 哈哈哈，当你看点开这篇文章的时候，或许你只是一不小心，本意并不是想看，但是既然来了，那给个面子看下去吧，说不定以后在这里我们会讨论很多有趣的问题，当然本人水平有限，所有希望得到各路大佬的支持，不妨点个关注吧。
上面扯了一大堆有的没的。下面切入正题，本人男，爱好唱、跳、rap、篮球，当然"CTRL"和我的工作也不是没有联系，那么我到底是干什么的呢，再买关子估计就要被取关了，哈哈哈（可能文章中会很多次用到哈哈哈，因为本人有点喜欢笑，哈哈哈）。
我是一个刚踏入少儿编程行业的小小小小白，主要负责c++方便的课程讲解，当然这是以后的事，目前还在学习状态，所以今天在办公室突发奇想，我是不是也可以弄一个CSDN上面的论坛，分享相关的问题，让大家都可以交流，然后也记录一个我的成长之路吧，话不多说就弄了这么一个号，没错我在写这个的时候我们规定的时间已经下班了两个半小时，但是因为有点小兴奋，所以呢迫不及待的想把文章更新出来。嗯…差不多就是这些了，还有朋友等我吃饭，我就先说这么一些，哈哈哈，是不是很随意。以后其他文章、模块也会陆续更新，望大家轻喷…溜了溜了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/421/">«</a>
	<span class="pagination__item pagination__item--current">422/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/423/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>