<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a740b7b3003b85aba4f43ec80a5c51/" rel="bookmark">
			clickhouse笔记01--快速部署clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clickhouse笔记01--快速部署clickhouse 1 介绍2 部署测试2.1 准备配置2.2 启动服务2.3 测试 3 注意事项4 说明 1 介绍 ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)，当前已经被很多大公司使用。
Clickhouse 是一款真正的列式数据库管理系统，具备数据压缩、数据的磁盘存储、多核心并行处理、多服务器分布式处理、支持SQL、向量引擎、实时的数据更新、索引、适合在线查询、支持近似计算、Adaptive Join Algorithm、支持数据复制和数据完整性、角色的访问控制 等特性。更多介绍信息可以参考 clickhouse 官方文档
笔者也是初次使用 clickhouse，因此将其部署方法和注意事项贴在此处，以方便有需要的小伙伴学习。
2 部署测试 2.1 准备配置 在 clickhouse 稳定版本安装包 准备最新稳定安装包，笔者准备的为 22.2.2.1 版本.
1) 下载安装包 clickhouse-client-22.2.2.1.tgz clickhouse-common-static-22.2.2.1.tgz clickhouse-common-static-dbg-22.2.2.1.tgz clickhouse-server-22.2.2.1.tgz 2）解压安装包 tar -xzvf "clickhouse-common-static-22.2.2.1.tgz" sudo "clickhouse-common-static-22.2.2.1/install/doinst.sh" tar -xzvf "clickhouse-common-static-dbg-22.2.2.1.tgz" sudo "clickhouse-common-static-dbg-22.2.2.1/install/doinst.sh" tar -xzvf "clickhouse-server-22.2.2.1.tgz" sudo "clickhouse-server-22.2.2.1/install/doinst.sh" tar -xzvf "clickhouse-client-22.2.2.1.tgz" sudo "clickhouse-client-22.2.2.1/install/doinst.sh" 3) vim /etc/clickhouse-server/config.xml 注释掉 listen_host 即可, 若为 ipv6 就注释第一个，若为 ipv4 就注释第二个，不注释掉的话只能在本机访问了 &lt;listen_host&gt;::&lt;/listen_host&gt; &lt;listen_host&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a740b7b3003b85aba4f43ec80a5c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706d9c3d283c85d3b72adb3dbf515e6a/" rel="bookmark">
			RNA-seq入门实战（一）遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行00_prefetch.sh 后，文章显示文件结构应该是这样的：
实际上我的是这样的：
01_sra2fq_qc1.sh 中找不到fasterq-dump命令，使用$（which fastq-dump）则找得到fastq-dump命令。
养成将标准输出和标准错误输出一起导入文档的习惯。其中log_2无需mkdir，输入以下命令即会生成。
nohup bash 2_cleanfq_qc2.sh &gt;log_2 2&gt;&amp;1 &amp; 4.质控清洗
FastQC，fastqc使用说明
学习使用IGV查看拷贝数变异
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60332ba7286dae35f923d79949e0537/" rel="bookmark">
			QT: QDockWidget使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QDockWidget简介 略
思路 首先有一个主界面，用来存放每个QDockWidget根据需要写很多个QWidget。每个QWidget都有独立的 .h .cpp .ui文件槽函数： 希望把所有的子界面作为一个整体控制 代码 QMainWindow 主界面需要继承 QMainWindow
这个ui只需要一个空的界面就好
QWidget1是自定义的子界面，你可以放任何需要的控件，在主界面include它的头文件需要new一个QDockWidget ，把QWidget1加进去最后设置排版 排版可以用splitDockWidget
田字形的排版如下：
加入第一个QDockWidget ，也就是左上角
this-&gt;addDockWidget(Qt::LeftDockWidgetArea, pDock1 ); 横向扩展一个，即右上角。在第一个QDockWidget 横向插入一个QDockWidget
splitDockWidget(pDock1 , pDock2, Qt::Horizontal); 左下角
//第一竖列 splitDockWidget(pDock1 , pDock3, Qt::Vertical); 右下角
//第二竖列 splitDockWidget(pDock2, pDock4, Qt::Vertical); 整体代码如下：
h文件
#pragma once #include &lt;QMainWindow&gt; #include&lt;QDockWidget&gt; #include "ui_WidStageCtrl.h" class WidStageCtrl : public QMainWindow { public: WidStageCtrl(QWidget *parent = Q_NULLPTR); ~WidStageCtrl(); protected: void InitData(); void removeAllDock(); private: Ui::WidStageCtrl ui; QList&lt;QDockWidget*&gt; m_docks;//&lt; 记录所有dockWidget的指针 }; cpp文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d60332ba7286dae35f923d79949e0537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae3d92d6fac0247f2a27fc7168a9d3e/" rel="bookmark">
			综合练习-迷你DVD管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求： 为某音像店开发一个迷你DVD管理器，实现DVD碟片的管理，包括如下功能： 新增DVD 查看DVD 删除DVD 借出DVD 归还DVD 退出DVD
提示：以下是本篇文章正文内容，下面案例可供参考
一、代码部分 代码如下（示例）：
import java.util.Scanner; public class DVDMgr { String[] name = new String[7]; //存储DVD名称 String[] state = new String[7]; //存储DVD借出状态：0已借出/1可借 int[] date = new int[7]; //存储DVD借出日期 int[] count = new int[7]; //存储DVD借出次数 int num = 0; //DVD数量 public void operatorDVD(int n) { Scanner input = new Scanner(System.in); switch (n) { case 1: System.out.println("添加的DVD不能超过6张"); System.out.println("-----&gt;新增DVD"); System.out.println(); String y = "y"; do { if (num&lt; 6) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae3d92d6fac0247f2a27fc7168a9d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca3053ef049bb8cdf84de95baf018ca/" rel="bookmark">
			Visual Studio Code 编辑器透明化设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装插件 设置透明度 编辑器透明化 插件选择 在使用了一些插件，观察效果后，选择了 Windows opacity 作为最理想效果插件，在vscode的插件市场搜索Windows opacity就能找到。
放一张图体验一下透明效果（示例截图中设置参数为210）：
设置效果 设置
文件/File 首选项/Preferences 设置/Settings 搜索winopacity.opacity
设置说明：不透明度值，介于0和255之间，其中0是隐藏窗口（不可见，但键鼠操作正常）。
在实际设置中，透明度太高会有提示警告
对应参数文件位置：C:\Users\自己的用户名\AppData\Roaming\Code\User下的settings.json文件的"winopacity.opacity"参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9740b007b99ccdd6283245bd72224f2/" rel="bookmark">
			Neo4j导入csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neo4j导入csv文件 文章目录 Neo4j导入csv文件前言文件访问常用参数实际书写参考文章 前言 Neo4j 数据库可以使用 load csv 命令从 CSV 文件中导入数据。
load csv 命令可以帮助我们导入中小型的数据，理论上大概能处理到一千万条记录。
其中，CSV文件推荐是使用 UTF-8 编码，不然就会造成中文乱码的糟糕情况。
文件访问 Neo4j的配置文件是 conf 文件夹下的 neo4j.conf 文件，里面有一句默认代码：
dbms.directories.import=import 这句代码指定了 Neo4j 中默认访问文件的相对位置，即 &lt;Neo4j_Home&gt; 路径下的 import 文件夹。
我们把准备访问的文件拷贝在 import 文件夹中，然后就可以使用相对路径 file:/// 即可访问 import 下的文件。
例如，我们把文件 test.csv 放入 import 之后，它的绝对路径是 “D:\neo4j-community-3.5.34\import\test.csv” ，我们在命令行中使用相对路径 “file:///test.csv” 即可访问到该文件。
明白了原理，如果我们要把文件的访问位置改成别的文件夹，只需要更改这句代码，去新建对应的文件夹，拷贝文件即可。
//改为Neo4j下的 hhh 文件夹 dbms.directories.import=hhh 这里有一个注意事项，Neo4j数据库考虑了安全性的问题，在使用这句代码指定了文件的访问位置之后，数据库不允许访问该位置之外的其他文件。
常用参数 参数名称用途using periodic commit [n]批量提交可以设置每满 n 条提交一次，防止内存溢出。
默认值是1000with headers读取首行读取文件的第一行作为参数名
不使用此参数，要用 line[0]、line[1] 这样的方式表示
使用此参数，可以使用 line.name 这样的表示方式as line重命名为每行数据重命名fieldterminator ‘,’自定义字段定界符csv中的分隔符基本都是逗号或分号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9740b007b99ccdd6283245bd72224f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e984cf9b1a94df218c3ba4a65a3fd6/" rel="bookmark">
			javascript百炼成仙 第一章 掌握JavaScript基础1.3变量的声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习博客，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转
叶小凡收起心神，继续阅读“JavaScript基础修炼要诀”，忽然，他眼前一亮。
“原来如此，直接量虽然只是昙花一现，但是如果我能用var定义一个变量，再指向那个直接量，就能有保存数据的妙用！”
想到这里，叶小凡当即催动功法，定义了一个变量。
var a; “成了！”，叶小凡开心的一拍手，心念一动，一个用双引号包裹的“Hello World”字符串凭空出现。这一次，没等字符串遁入虚无，叶小凡就立刻让变量a指向了这个字符串。
var a; a = "Hello World"; “嗯，有点麻烦，还不如直接并为一句。”先定义变量，然后指向一个字符串，这种操作分成了两步，还是一步到位的好。就在叶小凡这么想的时候，代码立刻发生了变化。
var a = "Hello World"; 原来这也可以！
下一节:javascript百炼成仙 第一章 掌握JavaScript基础1.4数据类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d95a0fd9bb70a32848795bc55d18151/" rel="bookmark">
			javascript百炼成仙 第一章 掌握JavaScript基础 1.2直接量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习博客，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转
叶小凡的住处被安排在青山院西北角的一个房间里，虽不宽敞，倒也干净。叶小凡两眼露出振奋的眼神，随便吃了点乡亲们准备的干粮后，就立刻开始打坐修行。
编程之修，重在积累，而非资质。资质虽然一样重要，可是后天的努力一样必不可少。这些道理，叶小凡还未上山之前，就已经熟知！因此，即便是资质平凡，只要肯下苦功，一样可以修得正果！叶小凡虽然甲等资质，可依然不骄不躁，开始从“JavaScript基础修炼要诀”第一页开始看起。
修炼要诀第一章，直接量。
编程世界，所谓直接量，就是明面上可以见到的数据值。常见的直接量有数字，小数，字符串。修行者，利用自身体内的能量，凝结出一个个简单的直接量。叶小凡目前修为较低，就连最基本的学徒境界都没有，体内能量薄弱，经过多次尝试，只能凝练出一些简单的数字，比如10，20。忽然，叶小凡目光一闪，一个字符串在体内形成！叶小凡细细感悟，原来是一个“Hello World” 字符串，叶小凡喜欢观察，立马发现了字符串和数字的不同。字符串的出现，必然带着双引号，被很好的包裹住，而数字则不同，就是光秃秃的一个10或者20，没有双引号。
“原来，字符串一定需要用双引号包裹，那么单引号是否可行呢？”叶小凡重新运气，转眼间，一个用单引号包裹的‘Hello World’就出现了。见此，叶小凡大喜，哈哈，原来单引号也可以。
1"Hello World" 2'Hello World' 突然，这两个字符串和数字像是失去了依托，瞬间化为虚无。叶小凡一惊，心道，看来直接创造出来的字面量只是昙花一现，无法持久，要是有一个什么东西把直接量装起来就好了。
下一节：
javascript百炼成仙 第一章 掌握JavaScript基础1.3变量的声明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26da93e1270f0e340593be44299e92e8/" rel="bookmark">
			go 电脑屏幕截图，二维码识别 示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，需要的第三方包
go get github.com/kbinani/screenshot go get github.com/makiuchi-d/gozxing 2. 函数封装
import ( "fmt" "github.com/kbinani/screenshot" "github.com/makiuchi-d/gozxing" "github.com/makiuchi-d/gozxing/qrcode" "image/png" "os" ) func ScreenAndQrCode() []string { n := screenshot.NumActiveDisplays() // 获取屏幕数量 imgPathList := make([]string, 0) if n &gt; 0 { for i := 0; i &lt; n; i++ { // 截图 img, err := screenshot.CaptureDisplay(i) if err != nil { panic(err) } fileName := fmt.Sprintf("第%d屏幕截图.png", i) file, err := os.Create(fileName) if err != nil { panic(err) } png.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26da93e1270f0e340593be44299e92e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bc261262aebdbdc1cf255c79e7ad5b/" rel="bookmark">
			nnUNet推理与预测（手把手一步一步实现。接上文用自己的数据训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图所示，当我们训练了大概几轮之后会在nnUNet_trained_models文件下生成nnUNet以及2d的模型文件，我们可以看到fold_4里面会有model_best.model，这个模型文件就是我们训练好的模型了，我们也可以通过同级目录下的progress.png，来查看loss函数的变化。接上文有几点要注意的情况，首先nnunet并不需要手动调学习率和训练轮数（这里nnunet默认是要训练1000轮），学习率的调整是用的损失函数的加权平均值使用的损失函数来对其进行更正的。还有就是nnunet的loss函数默认是趋向-1的，也就是说在训练的过程中，我们通过每轮训练的日志可以查看到每轮的loss函数，这个数值应该是负数，而且越趋向于-1，效果越好。(后期发现虽然第一次趋向-1但是大概率是我第一次显卡的问题，显卡算力和显存都会影响，后期在服务器上运行发现损失函数趋势正常（好像服务器也是趋向-1 但是不重要loss只要下降了就行），但是从效果来看，损失函数趋势对影响不是很大，这边建议还是在服务器上跑，当时我用了400张左右采集到的数据，最后效果还不错，效果要好于UNet网络。对于损失函数还想说的是，只要他的loss在下降就ok我们中途也可以通过生成的best_model来看一下当前训练轮数的效果怎么样 。)我们可以注意到我们选择使用的是V2也就是nnUNetTrainerV2训练方法，我们可以仔细查看这个py文件，大致说来就是他在V1的训练方法上进行了改进（深监督），想要具体的了解loss函数，我们可以通过这篇论文来了解”Focal Loss for Dense Object Detection“附上个论文加实现代码的链接🔗：Focal Loss for Dense Object Detection | Papers With Code#3 best model for Long-tail Learning on EGTEA (Average Precision metric)https://paperswithcode.com/paper/focal-loss-for-dense-object-detection#
言归正传，这里我附一张根据上一篇文章训练的loss结果：
可以看出接近1000epochs的时候loss不断的趋向于-1，如果你在训练的时候发现loss数值大于0而且没有趋向于-1的趋势，这可能因为GPU的原因，主要还是显存，官方推荐至少要8G，这里我在自己电脑上（4G，1650）修改过batchsize之后是可以训练的，但是我的电脑上给出的loss函数均大于0，而在服务器上运行（3090）的结果是越来越趋向于-1的，（显存一定要大！！还有预处理的时候要100G固态硬盘，固态硬盘是原论文中说到的，硬盘我没有受到影响，但是显存一定要大！！最少8G，不然没有效果）而且训练的效果也完全不一样，所以还是需要一个配置高的GPU去训练，毕竟nnunet从预训练开始就是对数据集进行大量的处理。其次有就是nnunet默认的batchsize是2，这里不建议再去减小batchsize（batchsize也不能调小，可以大但是不能小，确实可以自己改代码（这个代码很难去改，因为原论文不想你修改这个参数，我自己强制给改了为了测试，发现没有分割效果，所以说到这里就是在服务器上做就行！！）），找一个显存大的显卡这些问题都可以ignore。
中途可以用生成好的best_model检查一些效果，这个代码是：-chk model_best #应该是这个太久了有些忘记了，不对的话说一下我再看看。
预测的话把数据弄到数据的ts里。具体代码如果你做到这里肯定能知道的，我时间太久了忘记了。。
如果要fintune的话，load原模型，继续训练就好了。
差不多就这些吧。
如果损失函数趋势没有问题，那么我们只需要等待1000轮的训练即可。（当时是差不多500轮左右就拟合了，所以只训练了一半，效果还是ok的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cb8e42a4a976a4d9000a73ca93abf5/" rel="bookmark">
			Java 的四种引用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚引用&lt;弱引用&lt;软引用&lt;强引用 1、强引用 例：
Object obj=new Object();
强引⽤是使用最普遍的引用。如果⼀个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引⽤的对象来解决内存不足的问题。
2、软引用（SoftReference） 例：
Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;
sf.get();//获取对象
如果内存空间不足了，就会回收这些对象的内存。软引用可以和⼀个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加⼊到与之关联的引用队列中。
3、弱引用（WeakReference） 例:
Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
wf.get();//获取对象
弱引⽤与软引用的区别在于：只具有弱引用的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，⼀旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引⽤可以和⼀个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加⼊到与之关联的引用队列中。
4、虚引用（PhantomReference） 例：
Object obj = new Object();
PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);
虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到⼀个系统通知。虚引用与软引用和弱引用的⼀个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加⼊到与之关联的引用队列中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7618cc2aa08e9104c9b23bce5882210c/" rel="bookmark">
			Linux设置yum源为阿里云镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、验证网络是否可以连接阿里云镜像 # 验证网络是否可以连接阿里云镜像 ping mirrors.aliyun.com 二、 手动配置 1、删除原yum源 cd /etc/yum.repos.d # 删除原yum源 rm -rf /etc/yum.repos.d/* 2、下载阿里云Centos-7.repo文件 # wget命令下载: wget [options] [url] wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # curl命令下载: curl [options] [url] curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3、清除及生成缓存 # 清除yum缓存 yum clean all # 缓存阿里云镜像 yum makecache 4、查看yum源信息，已经更换为了阿里云镜像源 yum repolist 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5d0ed11c7224a97c3705f1842edb24/" rel="bookmark">
			ant design vue 实现组件类型推断 vue3,vite,ts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,全局引入的antd vue组件是没有代码提示的
因为全局引入的时候组件的类型已经丢失了,这时候写代码就没有这个组件的代码提示,还得去看文档
2,如何实现全局组件类型推断
(1),在使用的时候引入,这个不用多说,使用的时候写import就行
(2),在全局写一个类型定义文件,这个需要使用vite的插件帮我们实现
3,实现推断
(1),使用vite的unplugin-vue-components插件帮我们实现Vue 的按需组件自动导入
https://github.com/antfu/unplugin-vue-components
(2),配置 vite.config.ts
安装完成unplugin-vue-components后配置如下:
import Components from "unplugin-vue-components/vite"; // 按需组件自动导入 import { AntDesignVueResolver } from "unplugin-vue-components/resolvers"; // https://vitejs.dev/config/ export default ({ mode, }: { mode: "dev" | "prod" | "build" | "devbuild"; }): UserConfigExport =&gt; { return defineConfig({ plugins: [ vue(), vueJsx(), Components({ dts: true, //生成components.d.ts 全局定义文件 resolvers: [ AntDesignVueResolver({ //对使用到的全局ant design vue组件进行类型导入 importStyle: false, // 不动态引入css,这个不强求 }), ], include: [/\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5d0ed11c7224a97c3705f1842edb24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f688c547889121fcccf895f95c84764/" rel="bookmark">
			java&#43;springboot&#43;mysql仓库管理系统（源码、文档、ppt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看系统演示：点击 系统目标：
实现一个进销存管理系统，实现对企业运作过程中的进货、销售、仓储的电子化操作，可以节省大量人力物力，可以说对企业的运作带来不可限量的好处。实现一个简单实用，操作界面友好的进销存管理系统是首要解决的任务。然后一是要实现对库存数据进行分析，对接下来的进货进行一些指导；二是实现对销售数据的采集分析，对企业决策者对下一个季度或者年份的销售计划提供一个参考的功能。系统肯定要具备对进销存的一些基本的增删改查操作。
系统具备以下功能：
⑴一般企业人员的计算机知识掌握的不多，因此要求有良好的人机交互界面，这样对操作这个系统的企业人员比较友好。
⑵对于本系统使用对象的不同，需要给予不同的权限。
⑶支持多条件语句查询，方便进销存数据的查询。
⑷基础信息管理与查询（包括商品信息、客户信息、供应商信息）。
⑸一键点击，能够直接查看仓库所有商品的库存信息。
⑹方便、健全的账单统计功能。
⑺图表分析年销售状况。
⑻商品销售排行统计。
⑼当停电、网络病毒的原因损坏本系统数据时，系统可以还原系统的数据。
⑽各种数据的统计计算自动完成，尽可能的减少人工干预。
⑾系统退出。
系统功能结构图：
系统ER图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb694be0e83d949b08a330c6ba64c60/" rel="bookmark">
			“金九银十”是找工作的最佳时期吗?那倒未必
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优势：
供选择的公司多，机会多 劣势：
人才供应量旺盛
成为备胎的几率大增，获取offer的时间较慢
若无明显竞争力，薪资涨幅相对不会太高
比起那些在跳槽季(金三银四，金九银十)扎堆找工作的人，骑驴找马可能更靠谱一些，比如夏季平均38个人申请一个岗位，而上一季度平均43个人抢一个岗位。错开金九银十岗位竞争压力相对没那么大。
从另一个角度来说，经过大浪淘沙留下来的岗位，删去了没有目的跳槽的，奔着涨薪跳槽的，或者只是为了换个环境跳槽的，相反企业和求职者奔着有更好的职业发展的目的去招人和找工作，也许能来个不谋而合。
其次在9月份以及10月份找工作的人比较多了，竞争激烈，如果你选择在这段时间，找工作，投简历，如果能力并不是十分突出，那么你的简历很容易会被更为优秀的对手刷下去，淹没在庞大的人流中。
临近年末的时候
一、大部分人不愿意这个时候跳槽，导致远低于求
二、门槛变低，通过率变高
年前的这段时间，大多数公司的人员构成基本趋于稳定，不急着纳入新人的公司，通常会选择年后再发力招聘。
而团队的拼图还不完整的人，同样也知道，年前招人是很不容易的，因为客观说，求职的人并不如跳槽季和毕业季那么多。
因此，如果来应聘的人，能达到80%的匹配度，基本就会被纳入麾下。
三.薪资待遇可能会相对好一些
升职加薪的可能性也会高一点。因为到了年底，公司会为下一年做财务预算，为了留住公司的人，节省下一年的招聘开支，公司可能会多一点员工福利和过节红包等。
同时，在年底去和公司谈提薪，公司会在为制定预算前，把提薪的计划算进去，这样会比在公司预算出来后再去谈提薪，成功率可能会高一点。
四.竞争减少
对于一些人来说，年末的时候因为很多外地人要回家过年，都想着回家，等过完年再找工作，所以做了辞职的决定。尤其是基层岗位，各大企业都不可或缺，相对来说不难找。
这时候用人单位缺少人力，且求职者少，相对来说已减少了激烈竞争的对手，你已占优势了。因此，很多企业都需要在年底提前做好招聘计划，求职者也可以趁这个时机轻松找一份好工作。
五.避开“金九银十”的求职热潮
我们每个人找工作都不是随便的，如果有机会，一定会优先选择自己最心仪的公司。但是，你心仪的公司条件优渥，氛围又好，同样也是别人追逐的对象，其竞争必然也十分残酷。
这时候，如果在招人的淡季去应聘，就能大大的增加通过几率，人人都知道，每年的久和十月是跳槽的旺季，如果不想和更多人挤独木桥，那么，另辟蹊径，就是最好的办法。
当然，所有人，尤其是求职者，都需要时间休息和充电。但是，利用假期仔细进行求职规划，而不是把这个时间段看成松懈的借口，是让职业生涯加速发展的明智做法。
这里我免费分享一份GitHub 上标星 120k的《Java核心进阶知识全面解析》给大家看看，不论是用于巩固基础，还是用于技术提升都可以收藏一份，看完学透，面试大厂so easy。
下面展示部分截图，文末附免费下载方式。 (一). 基础 1、Java 基本功
Java 入门(基础概念与常识)Java 语法基本数据类型方法(函数) 2、Java 面向对象
类和对象面向对象三大特征修饰符接口和抽象类其它重要知识点 3、Java 核心技术
集合异常多线程文件与 I\O 流 (二). 并发 1、并发容器
JDK 提供的并发容器总结ConcurrentHashMapCopyOnWriteArrayListConcurrentLinkedQueueBlockingQueueConcurrentSkipListMap 2、线程池
使用线程池的好处Executor 框架(重要)ThreadPoolExecutor 类简单介绍(重要)ThreadPoolExecutor 使用示例几种常见的线程池详解ScheduledThreadPoolExecutor 详解线程池大小确定 3、乐观锁与悲观锁
何谓悲观锁与乐观锁乐观锁常见的两种实现方式乐观锁的缺点CAS与synchronized的使用情景 (三). JVM 1、Java内存区域
概述运行时数据区域HotSpot 虚拟机对象探秘重点补充内容 2、JVM垃圾回收
揭开 JVM 内存分配与回收的神秘面纱对象已经死亡?垃圾收集算法垃圾收集器 3、JDK 监控和故障处理工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb694be0e83d949b08a330c6ba64c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d4c3211e754af1797faa8c7d4c5271/" rel="bookmark">
			python3字符串总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
字符串的分类
普通字符串
原始字符串
字节字符串
字符串的基本操作
通用的操作
通用操作
字符串特点
python中的转义字符
字符串运算
字符串格式化
字符串格式化符号
字符串格式化字典
字符串格式化元组
注意事项
简单转换
字段宽度
精度
字符串方法
字符串基本方法
字符串方法作用分类
字符串连接
字符串搜索
字符串的替换
字符串分割
大小写互换
字符串对齐
字符串的测试
字符串的映射
字符串的编解码
类型判断 isinstance()
ASCII码的转换
字符串出现次数统计函数
字符串按操作方法分类
增
删
改
查
字符串测试
字符串的分类 普通字符串 &gt;&gt;&gt; s='abs\ndf'
&gt;&gt;&gt; s
'abs\ndf'
&gt;&gt;&gt; print(s)
abs
df
&gt;&gt;&gt; type(s)
&lt;class 'str'&gt;
原始字符串 所有的字符都是直接按照字面意思来使用的，没有转义特殊或不能打印的字符。
原始字符串除在字符串的第一个引号前加上字面“r”（不区分大小写）以外，与普通字符串有着几乎完全相同的语法
&gt;&gt;&gt; s=r'abs\ndf'
&gt;&gt;&gt; print(s)
abs\ndf
&gt;&gt;&gt; type(s)
&lt;class 'str'&gt;
字节字符串 只需要在定义字符串时转换成字节字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d4c3211e754af1797faa8c7d4c5271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab82504d564e85ce6c1dd00b4cb208c/" rel="bookmark">
			nnunet MultiThreadedAugmenter.abort_event was set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用多GPU跑的时候总报这样的错误，感觉就是进程没有关掉导致的，我没有找到解决方案，也捕获不到RuntimeError，就直接把raise注释掉了。
About the MultiThreadedAugmenter &amp; SingleThreadedAugmenter · Issue #696 · MIC-DKFZ/nnUNet · GitHub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2cfcba8b5b854ba72691511e732dc0/" rel="bookmark">
			【Bug解决】RuntimeError:Given groups=1,weight of size...expected input...but got 3 channels instead.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：
RuntimeError: Given groups=1, weight of size [64, 1, 3, 3], expected input[1, 3, 512, 512] to have 1 channels, but got 3 channels instead 原因： 明显是数据读入的通道数不对，应该是 1 通道，但是这里读入的是 3 通道。但是检查了数据，发现就是一通道的灰度图，没错儿呀。最后发现是 PIL 模块 Image.open 打开图像的数据 mode 问题。
检查发现，图像mode竟然是RGB，但我的训练图像是一通道的灰度图，所以得想办法把 mode 转换一下。
from PIL import Image img = Image.open('test.png') print(img.mode) &gt;&gt;&gt; RGB 解决方法：
img = Image.open('test.png') if img.mode != 'L': img = img.convert('L') 这样子网络再读取图像，就是 [1, 1, 512, 512] 啦 ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b60b4c7445982347b67a2183b586e5/" rel="bookmark">
			分布式事务的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献： 分布式事务|凤凰架构
1 前言 相信各位接触过微服务开发的同学们对分布式事务的概念一点也不陌生。分布式事务（Distributed Transaction）指的是多个服务同时访问多个数据源的事务处理机制。与分布式事务有关的CAP（Consistency 一致性、Availability 可用性、Partition Tolerance 分区容忍性）理论、BASE（Basically Available 基本可用性、Soft State 柔性事务、Eventually Consistent 最终一致性）理论的介绍有很多文章，在这里就不赘述。本文主要结合业务场景来给大家介绍分布式事务的一般实现方式。
2 分布式事务实现方式 2.1 可靠事件队列 场景：在电商系统中，购买一件价值100元的《凤凰架构》。在该场景下，可以拆分成三个步骤：买家账户扣款、仓库库存扣减、商家收款。如果其中任何一个步骤出现了异常，那么本次交易都应该是宣告失败的。接下来，我们就用可靠事件队列的方式，来保证这次交易的顺利进行。
1.首先，需要明确这个场景下会有4个微服务，每个微服务有对应的数据库。账户服务、仓库服务、商家服务、消息服务。
2.账户服务，先处理买家账户扣款业务，若扣款成功，则往消息表中写入一条记录：“事务ID-扣款100元(完成)-仓库出库《凤凰架构》(进行中)-商家收款(进行中)”。值得注意的是，扣款成功和写入消息表是本地事务。
3.消息服务，会定时轮询消息表，将状态为“进行中”的消息：仓库出库和商家收款串行地发送到仓库服务和商家服务去。这时会出现以下情况：
仓库服务和商家服务都完成了出库和收款工作，向账户服务返回执行结果，账户服务则将消息表的状态更新为“完成”。此时整个分布式事务顺利结束，达到最终一致性。仓库服务和商家服务至少有一个因网络原因，未能收到账户服务发送来的消息，此时由于消息表中一直有“进行中”的状态，故消息服务器会在每次轮询时重复向未处理的服务发送消息。当然，重复发送消息需要保证消费方的幂等性。仓库服务和商家服务有一个或全部无法工作，那显然也是会重复发送消息，直到全部成功。可以见得，只要第一个账户服务成功了，后面的业务流程只有成功而不能失败。仓库服务和商家服务都完成了工作，但回复的应答消息因为网络丢失，此时，消息表未更新成“完成”，消息服务还是会继续向其发送消息，同理，也需要保证幂等性，仓库不会重复出库，商家也不会重复收款。直至网络恢复正常。 我们可以发现，只要第一步业务成功了，后续的业务如果出现异常，则会不断进行重试。这种依靠持续重试来保证可靠性的解决方案称为“最大努力交付” 可靠事件队列还有一种更普通的形式，称为“最大努力一次提交”，指将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式来促试同一个分布式事务中的其他关联业务全部完成。
2.2 TCC事务 TCC（Try-Confirm-Cancel）是另一种常见的分布式事务机制。上一节介绍的可靠消息队列虽然能保证最终的结果是相对可靠的，过程简单，但整个过程完全没有隔离性可言。例如上面的场景中，完全有可能两个客户在短时间内都成功购买了同一件商品，而且他们各自购买的数量都不超过目前的库存，但他们购买的数量之和却超过了库存。如果这件事情只采用本地事务，“可重复读”的隔离级别就能保证，后面提交的事务会因为无法获得锁而导致失败，但用可靠消息队列就无法保证。 TCC 方案，适合用于需要强隔离性的分布式事务中，它分为以下三个阶段：
Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。 现在用TCC事务来保障这次交易的进行：
用户发送交易请求：购买一件价值100元的《凤凰架构》。创建事务，生成事务 ID，记录在活动日志中，进入 Try 阶段： 用户服务：检查业务可行性，可行的话，将该用户的 100 元设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。仓库服务：检查业务可行性，可行的话，将该仓库的 1 本《凤凰架构》设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。商家服务：检查业务可行性，不需要冻结资源。 如果第 2 步所有业务均反馈业务可行，将活动日志中的状态记录为 Confirm，进入 Confirm 阶段： 用户服务：完成业务操作（扣减那被冻结的 100 元）。仓库服务：完成业务操作（标记那 1 本冻结的书为出库状态，扣减相应库存）。商家服务：完成业务操作（收款 100 元）。 第 3 步如果全部完成，事务宣告正常结束，如果第 3 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，重复执行该服务的 Confirm 操作，即进行最大努力交付。如果第 2 步有任意一方反馈业务不可行，或任意一方超时，将活动日志的状态记录为 Cancel，进入 Cancel 阶段： 用户服务：取消业务操作（释放被冻结的 100 元）。仓库服务：取消业务操作（释放被冻结的 1 本书）。商家服务：取消业务操作（大哭一场后安慰商家谋生不易）。 第 5 步如果全部完成，事务宣告以失败回滚结束，如果第 5 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，重复执行该服务的 Cancel 操作，即进行最大努力交付。 由上述操作过程可见，TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本，所以，通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（如阿里开源的Seata）去完成，尽量减轻一些编码工作量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b60b4c7445982347b67a2183b586e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8462d89ad89ee3b3dfc050caddfae932/" rel="bookmark">
			外包干了三年，废了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先说一下自己的情况。大专生，19年通过校招进入湖南某软件公司，干了接近3年的CRUD，今年年上旬，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落！而我已经在一个企业干了三年的CRUD，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。于是，我决定要改变现状，冲击大厂。
刚开始准备时，自己都蒙了，三年的CRUD让我的技术没有一丝的进步，提升的只有我的年龄...
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后（几乎就是Java基础开始），直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人！”。
盘里头是一整套Java面试必备文档PDF，他说是GitHub 上标星 120k的《Java中高级核心进阶知识全面解析》，看完之后直接给我老哥给跪了..这下面试稳了
这里我免费分享给大家看看，不论是用于巩固基础，还是用于技术提升都可以收藏一份，看完学透，面试大厂so easy。
下面展示部分截图，文末附免费下载方式。 (一). 基础 1、Java 基本功
Java 入门(基础概念与常识)Java 语法基本数据类型方法(函数) 2、Java 面向对象
类和对象面向对象三大特征修饰符接口和抽象类其它重要知识点 3、Java 核心技术
集合异常多线程文件与 I\O 流 (二). 并发 1、并发容器
JDK 提供的并发容器总结ConcurrentHashMapCopyOnWriteArrayListConcurrentLinkedQueueBlockingQueueConcurrentSkipListMap 2、线程池
使用线程池的好处Executor 框架(重要)ThreadPoolExecutor 类简单介绍(重要)ThreadPoolExecutor 使用示例几种常见的线程池详解ScheduledThreadPoolExecutor 详解线程池大小确定 3、乐观锁与悲观锁
何谓悲观锁与乐观锁乐观锁常见的两种实现方式乐观锁的缺点CAS与synchronized的使用情景 (三). JVM 1、Java内存区域
概述运行时数据区域HotSpot 虚拟机对象探秘重点补充内容 2、JVM垃圾回收
揭开 JVM 内存分配与回收的神秘面纱对象已经死亡?垃圾收集算法垃圾收集器 3、JDK 监控和故障处理工具
JDK 命令行工具JDK 可视化分析工具 （四）网络、linux、数据结构与算法、数据库、系统设计、必会工具、面试指南 因为篇幅有限，其他内容就不一一展示了，这本进阶笔记总共有512页。对于想要进阶的小伙伴来说应该会很有帮助，希望也能帮助到你。
需要的小伙伴可以点击下面的名片免费领取。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/230/">«</a>
	<span class="pagination__item pagination__item--current">231/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/232/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>