<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85ab1ec7a41b7d34d014b9bab6aa417/" rel="bookmark">
			Sqoop采集数据的时候出现数据倾斜解决方法（--split-by    --num-mappers）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
–split-by 后面要是int类型，并且是连续递增的，那么sqpli-by 会平分的很均匀，要是不是自增的那么有的maptask还是很忙，而有的maptask则不是很忙
–num-mappers 后面设置的maptask数目大于1的话，那么–split-by 后面必须跟字段，因为–num-mappers 后面要是1的话，那么
–split-mappers 后面跟不跟字段都没有意义，因为，他只会启动一个maptask进行数据处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1593f7e0004d95b1686b31404b67e1ed/" rel="bookmark">
			【算法系列】贪心策略详解（附LeetCode例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、贪心算法原理1.贪心选择性质2.最优子结构 二、LeetCode例题1、jump-game2、maximum-subarray3、minimum-window-substring 三、相关参考 一、贪心算法原理 1.贪心选择性质 第一个关键要素就是贪心选择性质：我们可以做出局部最优选择来构造全局最优解。也就是说，我们在做出选择时，总是以当前的情况为基础做出最优选择的，而不用考虑子问题的解。
这也是和动态规划最大的不同之处。在动态规划中，在每次做出一个选择的时候总是要将所有选择进行比较才能确定到底采用哪一种选择，而这种选择的参考依据是以子问题的解为基础的，所以动态规划总是采用自底向上的方法，先得到子问题的解，再通过子问题的解构造原问题的解。就算是自顶而下的算法也是先求出子问题的解。在贪心算法中，我们总是在原问题的基础上做出一个选择，然后求解剩下的唯一子问题，贪心算法从来都不依赖子问题的解，不过有可能会依赖上一次做出的选择，所以贪心算法是自顶而下的。
2.最优子结构 如果一个问题的最优解包含其子问题的最优解，那么就称这个问题具有最优子结构性质。
将子问题的最优解与贪心选择组合在一起就能生成原问题的最优解。
二、LeetCode例题 1、jump-game （1）题目描述
给出一个非负整数数组，你最初在数组第一个元素的位置 ，数组中的元素代表你在这个位置可以跳跃的最大长度 判断你是否能到达数组最后一个元素的位置
例如
A =[2,3,1,1,4], 返回 true.A =[3,2,1,0,4], 返回 false. Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
For example:
A =[2,3,1,1,4], returntrue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1593f7e0004d95b1686b31404b67e1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882cb5a0848070855d4942b63f09b16a/" rel="bookmark">
			计算机网络【三】物理层数据通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理层传输媒介 导向传输媒体，比如光纤和铜线 双绞线（屏蔽双绞线STP 五屏蔽双绞线UTP）电线扭曲在一起可以降低互相之间的电磁干扰
同轴电缆 (50欧姆的基带同轴电缆，75欧姆的宽带同轴电缆)
10M和100M网络只使用了四根线（1，2，3，6），千兆网络使用了8根线
两台相同的设备使用直通线必须调整线序使用交叉线（现在的网卡可以智能识别）
计算机和交换机相连可以直接使用一根直通线
直通线的线序：橙白 橙 绿白 蓝 蓝白 绿 棕白 棕
光缆
非导向传输媒体 指自由空间，其中的电磁波传输成为无线传输。无线传输所使用的频段很广。
短波通信主要靠电离层的反射，但是短波通信的通信质量较差
微波通信在空间主要是直线传播。（地面微波接力通信、卫星通信）
集线器（hub） 工作特点：在网络中起导信号放大和重发的作用，其目的是扩大网络的传输范围，但不具备信号的定向传输能力。最大传输距离：100m。
当多个计算机连接到集线器上时，如果我们其中两个计算机进行通信，则发送方将信息发送给集线器后集线器将数据发送给所有的其他计算机，其他计算机接受到后会判断是否是传送给自己的信息（根据MAC地址进行判断），这也会造成其他计算机无法进行通信。如果其他计算机上有抓包工具则也能获得数据。
因此集线器很容易冲突。没有判断能力，相当于一个网线。是一个没有智能的物理层设备。
计算机带宽会分摊集线器的带宽
信道复用技术 频分复用FDM 用户在分配到一定的频带后，在通信过程种自始至终都占用一个频带
时分复用TDM 每一个时分复用用户在每一个TDM帧种占用固定序号的时隙。每一个用户所占用的时隙时周期性的出现（周期为TDM帧的长度）。TDM信号也成为等时信号。各个用户在不同的时间占用相同的频带宽度。
时分复用技术可能造成线路资源的浪费
统计时分复用STDM，需要在消息上加上标记。交换机和交换机之间VLAN交换数据就是用的是STDM
波分复用 光的频分复用
数字传输系统 主要是广域网之间的数据传输，依靠电话线路
脉码调制PCM体制最初是为呃在电话局之间的重疾险上传送多路的电话。由于历史上的原因，PCM有两个不兼容的标准：北美的T1(24路 1.544Mb/s）和欧洲的E1(30路 2.048Mb/s）
当需要更高的速率时可采用复用
以电话线路为例，首先进行采样（8000Hz），一个声音码元可以代表8位二进制数字。
因此带宽为8000*8=64Kb
E1进行时分复用。将32路电话信号进行时分复用32*64K=2.048M
T1 24路电话信号进行24路时分复用
宽带接入技术 xDSL 标准模拟电话信号的频带被限制在300~3400Hz的范围内，但用户线本身实际可通过的信号频率超过1MHz
xDSL技术把0-4kHz低端频谱留给传统电话使用，把原本没有被利用的高端频谱留给用户上网使用
ADSL（非对称数字用户线路）使用DMT技术：采用频分复用的方法，把40KHz以上以知道1.1MHz的高端频谱划分为许多的子信道，25个用于上行，249个用于下行。并行处理以后向上传送数据，串行处理以后再接受数据
光纤同轴混合网HFC 使用小区已经部署好的有线电视的网络进行Internet访问
HFC网络的最大的优点：
具有很宽的频带能够利用已经有相当大的覆盖面的有线电视网 FTTx技术 FTTx(光纤到…)也是一种实现宽带居民接入网的方案。这里字母x可以代表不同的意思
FTTH:光纤到家FTTB:光纤到楼FTTC:光纤到路 不用其他设备进行调制，不需要用mao。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aca2f2e3d17f33220bb3921b54c843/" rel="bookmark">
			凸优化学习笔记17：次梯度下降法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于光滑函数，我们可以用梯度下降法，并且证明了取不同的步长，可以得到次线性收敛，如果加上强凸性质，还可以得到线性收敛速度。那如果现在对于不可导的函数，我们就只能沿着次梯度下降，同样会面临步长的选择、方向的选择、收敛性分析等问题。
1. 收敛性分析 次梯度下降的一般形式为
x ( k ) = x ( k − 1 ) − t k g ( k − 1 ) , k = 1 , 2 , … g ∈ ∂ f ( x ( k − 1 ) ) x^{(k)}=x^{(k-1)}-t_{k} g^{(k-1)}, \quad k=1,2, \ldots \quad g\in\partial f(x^{(k-1)}) x(k)=x(k−1)−tk​g(k−1),k=1,2,…g∈∂f(x(k−1))
一般有 3 种步长的选择方式：
fix step： t k t_k tk​ 为常数fix length： t k ∥ g ( k − 1 ) ∥ 2 = ∥ x ( k ) − x ( k − 1 ) ∥ 2 t_{k}\left\|g^{(k-1)}\right\|_{2}=\left\|x^{(k)}-x^{(k-1)}\right\|_{2} tk​∥∥​g(k−1)∥∥​2​=∥∥​x(k)−x(k−1)∥∥​2​ 为常数diminishing： t k → 0 , ∑ k = 1 ∞ t k = ∞ t_{k} \rightarrow 0, \sum_{k=1}^{\infty} t_{k}=\infty tk​→0,∑k=1∞​tk​=∞ 要证明这几种方法的收敛性，需要先引入 Lipschitz continuous 假设，即
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40aca2f2e3d17f33220bb3921b54c843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85651ff40c7677ff9b156a0a1fcfe69a/" rel="bookmark">
			Leetcod每日一题：151.reverse-words-in-a-string（翻转字符串里的单词）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路是：双指针去头尾空格，然后遍历中间去空格直到每个单词后最多一个空格；然后将整个字符串翻转，然后从头遍历将遇到的单词翻转回去；
一开始因为while (s[end] == ' ' &amp;&amp; end &gt;= 0) //除去结尾空格end&gt;=0不严谨，导致案例" "死活不通过，我以为结果有问题，试了几次才发现end在这个案例中会减到-1,使得s[-1]这种溢出情况出现；
错误原因:Line 1060: Char 9: runtime error: addition of unsigned offset to 0x7ffc46f434a0 overflowed to 0x7ffc46f4349f (basic_string.h)
使用api应该会快些，尤其时java的，这里我就懒得换了；
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void reverse(string &amp;s, int begin, int end) //将s[begin] 至 s[end] 字符串部分反转 { string re = s.substr(begin, end - begin + 1); int k = end - begin; for (int i = begin; i &lt;= end; i++) //反转后置回原字符串 { s[i] = re[k--]; } } string reverseWords(string s) { string s_end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85651ff40c7677ff9b156a0a1fcfe69a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc5e8cf441ff9229aceaaddd57eb3ec/" rel="bookmark">
			TensorBoard 可视化 不显示数据问题 No scalar data was found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：方法一：将cmd的默认路径cd到log文件的上一层，即cd /d E:\MyTensorBoard，之后等号后面直接键入log文件名即可，不需写全路径，即 tensorboard --logdir=logs。方法二：双斜杠，即tensorboard --logdir=E://MyTensorBoard//logs。最后根据得到的网址http://hostIP:6006，在chrome里打开，就可以可视化我们的图表了，幸福来的太突然。
1.找到anaconda目录下的Script下的tensorborad.exe，在这一目录cmd打开dos，输入tensorboard --logdir=D://log，enter执行，浏览器输入http://desktop-dkhrm3n:6006/#graphs打开网络图表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6292c60093a19ee37553f611ded773/" rel="bookmark">
			VS Code如何查看类视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择，View下面的Open View:
选择Outline
可以看到左边的Outline栏可以看到类、结构体以及函数的列表：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a76fed7e4ac7391e9ad675100d145d3/" rel="bookmark">
			PyQt5自学记录（1）——PyQt5多线程实现详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt5自学记录（1）——PyQt5中多线程实现详解 最近想用PyQt5完成图像识别的一个GUI系统，在调用算法模型进行识别的时候，界面会卡住没有反应，所以想学习一下多线程解决这个问题。然后。。。发现没有基础学习来确实挺难，幸运地是最终实现了多线程，记录一下学习过程。如有错误，希望指正，一起进步。
进程和线程 线程是一个轻负荷的子进程，是最小的处理单元。线程被包含在进程之中，是进程中的实际运作单位。一个进程可以并发多个线程，每条线程同时执行不同的任务，并且，线程是独立的，一个线程发生错误，不影响其他线程正常执行。
进程是指正在运行中的应用程序。每个进程都有自己独立的内存空间，当用户启动一个进程时，操作系统就会为该进程分配一个独立的内存空间，让应用程序在独立内存中运行
在实现多任务中，这篇博客中写到，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。在Windows系统下，多线程的效率要比多进程的效率要高。
PyQt5的多线程实现 PyQt5中自定义信号 在介绍PyQt5的多线程实现之前，先介绍一下PyQt5中自定义信号的方法。
我们先来看一下PyQt5中自带的信号clicked的实现机制：
self.Button_Start.clicked.connect(self.Start) A触发信号事件 B 信号clicked C 接收信号做出相应操作 通过鼠标点击（事件）触发信号，通过信号的传递控制相应的操作是否进行。自定义信号同样满足这种机制，自定义信号的机制与主要函数如下图：
A触发信号事件emit B 声明信号 pyqtSignal C 接收信号做出相应操作connect 首先要声明一个信号，通过信号名 = pyqtSignal(类型)实现
finishSignal = pyqtSignal(str) # 信号类型：str 第二步要明确信号控制的操作，也就是槽函数。信号发出之后我们希望进行的操作，通过信号所在类实例.信号名.connect(槽函数)实现。
self.thread.finishSignal.connect(self.Change) # 信号挂接到槽：update def Change(self, msg): print(msg) self.label.setText(str(msg)) 最后一步，明确信号的触发机制，我们确定了信号以及信号控制的槽函数，那么什么时候发出这个消息呢，这就需要信号的触发机制，通过信号名.emit(信号内容)实现。
self.finishSignal.emit(str(i)) # 发射信号 总结：emit(i)函数触发自定义信号将参数i发送给槽函数，槽函数接受信号，执行指定操作。
多线程实现 理解了自定义信号PyQt5的多线程也就不难了，一个简单的例子看一下他的实现过程：主线程执行GUI界面，子线程用定时器读秒实时显示在主线程的GUI界面中。
通过QtDesigner设计GUI界面，实现逻辑界面和显示界面的分开，对新手来说无疑是一个福音。首先看一下整体的一个结构
therad.py是线程类文件，thread.ui是QtDesigner生成的UI文件，Thread_gui.py是由UI文件转换来的界面py文件，Thread_win.py是编写的逻辑文件。下面详细介绍多线程实现过程。
第一步：利用QtDesigner设计显示界面。并转换为py文件，也就是图中的thread.ui和Thread_gui.py文件。生成的Thread_gui.py不需要做任何更改，在逻辑文件中设置相关逻辑操作，Thread_gui.py代码如下
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'untitled.ui' # # Created by: PyQt5 UI code generator 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a76fed7e4ac7391e9ad675100d145d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd3d983387d0cc66e6356fab1637365/" rel="bookmark">
			计算机网络【二】物理层基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络的性能 速率：连接在计算机网络上的主机在数字信道上传送数据位数的速率，也成为data rate 或bit rate，单位是b/s,kb/s,Mb/s,Gb/s。
我们平时所讲的宽带的速度是以字为单位的，但是实际中应用一般显示的是字节 ，一般是8~10倍的转换。带宽：数据通信领域中，数字信道能传送的最高数据率吞吐量：在单位时间内通过某个网络的数据量时延：即延迟。数据从一端传送到另一端所需要的时间。包括：发送时延（带宽大小影响发送时延）、传播时延（传播时延一般比较固定）、处理时延、排队时延
发送时延 = 数据块长度（比特）/ 信道带宽（比特/s）
带宽决定的是信号在数据线路上的长度
光纤发送时延很小（带宽大），铜线发送时延会较大。（主要因为电信号带宽过大会导致接收方无法识别）
光纤的传播时延比铜线大（光纤传播速度20.5万公里/s，铜线23.1万公里/s）时延带宽积：传播时延 * 带宽 实际意义指的是计算机通信时有多少数据在线路上往返时间：从发送方发送数据开始，到发送方收到接收方确认 ipconfig 查询网络信息 ping IP地址，发送信号得到往返时间 如果往返时间超过200ms就会展示请求超时
如果ping同一个局域网里面的计算机互相ping的时候往返时间过长，可能网络有某方面的问题，可能是某一太计算机正在上传数据导致网络阻塞。
网络利用率： 信道利用率：有数据通过的时间/数据通过时间（单位时间中数据通过时间的百分比）网络利用率：所有的信道利用率加权平均值。
D表示网络当前的时延，D0表示网络空闲时的时延，U表示信道利用率 D=D0/(1-u)
物理层的基本概念 物理层：如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。
物理层的主要任务描述为：确定传输媒体接口的一些特性：
机械特性：接口形状，大小，引线数目电气特性：规定电压范围（例如-5V到+5V）功能特性：规定高低点位代表什么过程特性：也称作规程特性，规定建立连接时各个相关部件的工作步骤 数据通信基础 数字信号：用01表示的信号
模拟信号：使用波传递信号，抗干扰能力强，适合远距离传输
网卡发送的是数字信号
同一个局域网内部的通信是数字信号通信，不会由调制解调器变成模拟信号。即通过交换机通信没有经过传输系统。
相关术语 通信的目的是传送信息
数据：传送消息的实体信号：数据的电气或电磁的表现 模拟信号：信号的取值是连续的数字信号：信号的取值是离散的 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就成为码元。
在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号成为二进制码元，这个间隔称为码元长度。
根据离散值的可能性的不同，一个码元可以携带的信息量是不同的。如果码元有x种状态，则这个码元可以携带logx个比特信道：一般表示向一个方向传递信息的媒体，咋们平时所说的通信网络一般包含一条发送信息的信道和一条接受信息的信道 单工通信（单向通信）：只能由一个方向的通信，没有反方向的交互半双工通信（双向交替通信）：通信的双方都可以发送信息，但不能双方同时发送（也不能同时接受），必须是一个发送一个接受。例如对讲机全双工通信（双向同时通信）：通信的双方可以同时发送和接受信息 基础知识 基带信号：基本频带信号，来自信号源的信号。带通信号：把基带信号经过载波调制后把信号的频率范围搬移到较高的频段以便在信道中传输。（即尽在一段频率范围内能够通过信道）
在传输距离较近的时候计算机网络都采用基带传输的方式。 在传输距离较远的时候需要进行调制。
调制方法： 调幅（AM）:载波的振幅随基带数字信号而改变调频（FM）:载波的频率随基带数字信号而改变调相（PM）:载波的初始相位随基带数字信号而改变
常用数字信号编码 单极性不归零码：只是用一个电压值，高电平表示1，没电压表示0
双极性不归零码：用正电平和负电平分别表示1和0，正负幅值相等
单极性归零码（RZ）：以高电平和零电平分别表示二进制1和0，而且在发送码1时高电平在整个码元期间T只持续一段时间，其余时间返回零电平
双极性归零码：正负零三个电平，信号本身携带同步信息（详见下面的例子）
曼彻赫斯特编码：低信号跳变为高信号表示0，高信号跳变为低信号表示1。一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit，但是它能携带时钟信号，且可表示没有数据传输。
差分曼彻斯特编码：bit中间一定有信号跳变，如果两个bit之间有信号跳变表示0，如果没有表示1。差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰能力强于曼彻斯特编码。
信道极限容量 奈氏准则：给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。
在任何信道中，码元传输速率是有上限的，否则就会出现码间串扰的问题，使得接收端对码元的判决（即识别）成为不可能。如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更好的传输速率传送码元而不出现码间串扰。
当传输速率过快（带宽过大），即使是没有电磁干扰，在线路上的码元间的距离过小以至于识别成为不可能就叫做码间串扰。
信噪比 香农（Shannon)用信息论的理论推导除了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。
香农定理：信道的极限信息传输速率C=Wlog(1+S/N) b/s
W是信道的带宽（Hz)
S是信道内所传信号的平均功率
N是信道内部的高斯噪声功率
香农定理的意义在于当有噪声的时候为了得到准确无差错的信息我们必须降低传输速率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd3d983387d0cc66e6356fab1637365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac8cb163563ab675699cdc873b52a14/" rel="bookmark">
			57插入区间（贪心法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、题目描述
给出一个无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
2、示例
输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出: [[1,2],[3,10],[12,16]]
解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
3、题解
基本思想：贪心法，newInterval把intervals分成三部分，第一部分intervals[i][1]&lt;newInterval[0]，第二部分有重叠区间，第三部分newInterval[1]&lt;intervals[i][0]。对于每一部分分别保存到res，复杂一点的就是重叠部分，newInterval[0]&lt;=intervals[i][1]&amp;&amp;intervals[i][0]&lt;=newInterval[1]，求最大范围区间。
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; class Solution { public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) { //基本思想：贪心法，newInterval把intervals分成三部分，第一部分intervals[i][1]&lt;newInterval[0]，第二部分有重叠区间，第三部分newInterval[1]&lt;intervals[i][0] //对于每一部分分别保存到res，复杂一点的就是重叠部分，newInterval[0]&lt;=intervals[i][1]&amp;&amp;intervals[i][0]&lt;=newInterval[1]，求最大范围区间 vector&lt;vector&lt;int&gt;&gt; res; int i; i = 0; while (i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; newInterval[0]) { res.push_back(intervals[i]); i++; } while (i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= newInterval[1]) { newInterval[0] = min(newInterval[0], intervals[i][0]); newInterval[1] = max(newInterval[1], intervals[i][1]); i++; } res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac8cb163563ab675699cdc873b52a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583a9c4e1a5aeb707ad999812cd14b0f/" rel="bookmark">
			VS Code 配置 go-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明: 本文参考 网友写的一份博客, 自己尝试安装, 发现不必他写的那么麻烦, 因此做个记录, 方便其他人参考: 不过我只在我的本地测试可以: 如果你的电脑无法使用, 请留言, 我会在文章开头添加说明, 避免浪费大家时间!!!! 生命可贵, 请勿浪费! 源文连接: https://blog.csdn.net/WindSunLike/article/details/103986319?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1 1.下载go安装: 参考菜鸟教程方法, 写的很清楚 : https://www.runoob.com/go/go-environment.html 2. 进入环境变量中配置GOPAtH 目录: 例如 : d:\GOPATH 3. 在GOPATH 三个目录: bin , src , pkg , 如下: d:\GOPATH\bin d:\GOPATH\src d:\GOPATH\pkb 4. 然后在src 目录下 创建如下路径 ; d:\GOPATH\src\golang.org\x 5. 进入路径: d:\GOPATH\src\golang.org\x 使用git clone 下载 tools 工具 #注意 : 该url 是可用的, 如果出现超时, 就多试几次... $ git clone http://github.com/golang/tools 下面是我的操作记录: 建议使用git Bash 运行 D:\GOPATH\src\golang.org\x&gt;git clone http://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583a9c4e1a5aeb707ad999812cd14b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6431f148370e39343b61850876dc3035/" rel="bookmark">
			clion-debug调试步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 clion-debug调试方法（先来一道水题，方便大家理解）操作细节：1. 打断点2.点击debug3.输入数据4.下一条指令 clion-debug调试方法 ​ 脱坑神器
（先来一道水题，方便大家理解） 题目要求：
获取两个输入a,b，求a+b。
输入数据:
0001 0002
输出结果：
3
附上代码：
#include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int string_to_int(string str){ //避免字符串是全0 if(str.find_first_not_of('0') == string::npos)return 0; str = str.substr(str.find_first_not_of('0')); int a; sscanf(str.c_str(),"%d",&amp;a); return a; } int main(){ string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int a = string_to_int(str1); int b = string_to_int(str2); int c = a+b; cout&lt;&lt;c; return 0; } 测试一波：
操作细节： debug步:
1. 打断点 点击左侧会出现一个红点
由于clion比较智能，断点大致在那么范围就可以了。
2.点击debug 3.输入数据 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6431f148370e39343b61850876dc3035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6fe13d9ea18ccde7b3948a3f7b9e54/" rel="bookmark">
			轻松实现网页中通过链接跳转到QQ聊天界面，通过链接加QQ群，自动打开聊天对话框等等，包含电脑版和手机版的实现，示例部分Android和iOS的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过链接打开对话框： 打开qq聊天窗口的方法
&lt;a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1450612626&amp;site=qq&amp;menu=yes"&gt;打开qq聊天框&lt;/a&gt; 打开qq群窗口的方法
&lt;a href="mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=419834979&amp;card_type=group&amp;source=qrcode"&gt;打开qq群&lt;/a&gt; 打开手机短信方法
&lt;a href="sms:10086"&gt;send&lt;/a&gt; 发送内容的时候
安卓 &lt;a href="sms:10086?body=send info"&gt;&lt;/a&gt; 苹果 &lt;a href="sms:10086&amp;bode=send info"&gt;&lt;/a&gt; 电脑端：
http://wpa.qq.com/msgrd?v=3&amp;uin=QQ号码&amp;site=qq&amp;menu=yes eg：http://wpa.qq.com/msgrd?v=3&amp;uin=1186154608&amp;site=qq&amp;menu=yes Android：
String url=“mqqwpa://im/chat?chat_type=wpa&amp;uin=11111111”; startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url))); iOS:
UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero]; NSURL *url = [NSURL URLWithString:@“mqq://im/chat?chat_type=wpa&amp;uin=11111111&amp;version=1&amp;src_type=web”]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; webView.delegate = self; [webView loadRequest:request]; [self.view addSubview:webView]; 手机版方法一：
首先度大家可以用手机QQ点击：http //wpa qq com/msgrd?v=3&amp;uin=574201314&amp;site=oicqzone.com&amp;menu=yes
是不是可以用手机QQ跟小编强行聊天了呢？问
既然电脑上有tencent://协议，那么手机上一定也有吧，抓包分析了一下：
scheme = “mqqwpa //im/chat?chat_type=wpa&amp;uin=” + g.tuin + “&amp;version=1&amp;src_type=web&amp;web_src=” + host;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6fe13d9ea18ccde7b3948a3f7b9e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1af5eb50cb534c61f19965774775b8b/" rel="bookmark">
			MATLAB R2016a 无法启动并行池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用 MATLAB 跑仿真，但是不知怎么回事，之前并行计算 parfor 用的好好的，昨天突然就不能用了，一直报错无法启动并行池，报错原因还特别奇怪。在网上找了一大堆教程互相抄来抄去，没一个能用的。最后还是在官网论坛找到了一个答案成功解决问题。
先给我的博客打个广告，欢迎光临
https://glooow1024.github.io/
https://glooow.gitee.io/
1. 问题描述 我用的是 MATLAB R2016a，当我运行带有 parfor 的代码时，左下角会有如下提示，表示无法启动并行池，而正常情况应该是右边这幅图
报错情况正常情况 当我点击查看 more details 时，会报如下的错误，参数不对？这不是自带函数吗？
然后我参考了网上的教程，查看 Home-&gt;Parallel-&gt;Manage Cluster Profiles，但是网上教程说如果是下面这个样子
我的错误是这样的网上只有这样的 很显然我的第一步 cluster connection test(parcluster) 就 fail 了，我按照网上的说法运行下面这句话也没用
distcomp.feature( 'LocalUseMpiexec', false ) 最后幸运的是在官网论坛找到了一篇可以解决我的问题的回答，下面给出解决方法。
2. 解决方法 参考链接：https://www.mathworks.com/matlabcentral/answers/92124-why-am-i-unable-to-use-parpool-with-the-local-scheduler-or-validate-my-local-configuration-of-parall
我用 第 5 步(Clear the local scheduler data folder) 解决了我的问题，不过下面还是贴出来完整的 debug 过程
2.1 检查 license 运行命令检查 Parallel Computing Toolbox 的 license 正确
license checkout Distrib_Computing_Toolbox 如果得到的回答是 ans=1，则说明 license 没问题。否则需要添加 license。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1af5eb50cb534c61f19965774775b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87efd8694fc52e82ebe93b3113158e3d/" rel="bookmark">
			学习C&#43;&#43;之字符串的乘法、除法、加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符串的除法 主要思想:把字符串从高到低逐位除以除数，如果某一位不能整除，则保留余数，余数乘10后加上低一位继续进行处理，这种做法可能会前置多余的0，则需取首个非0位之后的字符串即可。
需要注意的是，str[i]-'0’可以将字符型转化为整型，str[i]+'0’可以将整型转化为字符型。
string Divide(string str,int n){//字符串代表的数字与n相除 int reminder=0;//保留余数 for(int i=0;i&lt;str.size();i++){//从高位向低位运算 int current=reminder*10+(str[i]-'0'); str[i]=current/n+'0';//将整型转化为字符型 reminder=current%n; } int k=0; while(str[k]=='0'){//找到第一个非0位 k++; } str=str.substr(k);//取子串 return str; } 字符串的乘法 主要思想：把字符串从低位到高位逐位运算，若有进位，高位乘n后加上该进位继续处理，直至整个字符串都运算完毕。若还有进位，则用“1”与字符串相加，此时相当于字符串前多了一位且值为1，只需修改str[0]的值即可完成运算。
string Mutiple(string str,int n){ int carry=0;//保存进位 for(int i=str.size()-1;i&gt;=0;i--){//从低位向高位运算 int current=carry+(str[i]-'0')*n;//当前数为进位加上该位与n相乘 str[i]=(current%10)+'0';//字符串更新 carry=current/10;//进位更新 } while(carry!=0){//若还有进位 str="1"+str;//字符串前加一位，且新的字符串str[0]为1 str[0]=carry%10+'0';//修改str[0] carry/=10;//更新进位数字 } return str; } 字符串的加法 主要思想：将要加的n直接当做进位数，从低位向高位运算，再处理进位数即可。
string Add(string str,int n){ int carry=n; for(int i=str.size()-1;i&gt;=0;i--){ int current=carry+(str[i]-'0'); str[i]=(current%10)+'0'; carry=current/10; } while(carry!=0){ str="1"+str; str[0]=carry%10+'0'; carry/=10; } return str; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3c575ec5e8b95eea6414a4040eaa82/" rel="bookmark">
			Ubuntu 18.04 手动配置分区并安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明 安装环境：VMWare WorkStations Pro 15.5.1 操作系统：ubuntu-18.04.4-desktop-amd64 CPU：4 核 内存：8 GB 磁盘：50 GB 网络连接：NAT 方式 安装包准备 Ubuntu 官网下载 官网镜像下载地址 – 点击直接下载 VMWare WorkStations 新建虚拟机 Ubuntu 操作系统安装 开启虚拟机 Install Ubuntu 键盘部署选择 更新选项 &amp;&amp; 软件配置 安装类型选择 磁盘分区 &amp;&amp; 挂载点配置 磁盘分区 – 新建分区表 磁盘创建 – “boot” + “swap” + “/” swap 分区说明：【个人理解】
内存大于 16GB – swap 分区配置 16 GB
内存小于 16GB – swap 分区配置 内存大小 * 2
配置结果查看 &amp;&amp; 开始安装 系统安装 – 格式化磁盘 系统安装 – 时区 &amp;&amp; 地域配置 系统安装 – 用户信息配置 系统安装 – 安装进行中 系统安装 – 重启 安装系统 – 重启登录 安装系统 – 页面展示 参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d3c575ec5e8b95eea6414a4040eaa82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61ca88a83d2832765ccca18b9f5350d/" rel="bookmark">
			内存分配分为三种：静态、栈区、堆区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总述
内存分配分为三种：静态、栈区、堆区
分别解释
（1）静态存储区：主要存放static静态变量、全局变量、常量。这些数据内存在编译的时候就已经为他们分配好了内存，生命周期是整个程序从运行到结束。
（2）栈区：存放局部变量。在执行函数的时候（包括main这样的函数），函数内的局部变量的存储单元会在栈上创建，函数执行完自动释放，生命周期是从该函数的开始执行到结束。（例如，delay_ms(){ int a = 1000;//a就是一个局部变量 在栈区建立存储单元 delay_ms()执行完毕后自动释放 }）
（3）堆区：程序员自己申请一块任意大小的内存—也叫动态内存分配。这块内存会一直存在知道程序员释放掉。C语言中，用malloc or new动态地申请内存，用free or delete释放内存。良好习惯：若申请的动态内存不再使用，要及时释放掉，否则会造成内存泄露。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1c4f0d6b4628be925ccd1a30aa3245/" rel="bookmark">
			MyBatis系列之Mybatis源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis的发展历程以及基本使用，详见
Mybaits系列之MyBatis的发展之路，怎么用好MyBatis
MyBatis工作流程分析 全局配置文件 mybatis-Config.xml --&gt; Mappr.xml --&gt;Configuration填充配置类 --&gt;SqlSessionFactory(生成session工厂) --&gt;SqlSession（生成session）--&gt;Executor（执行器）--&gt;StatementHandler --&gt;数据库
1、解析配置文件
2、创建工厂类
3、创建会话
4、操作数据库
MyBatis架构分层 1、提供给应用使用：接口层
2、处理数据库操作：核心层
3、支持工作：基础层
MyBatis源码分析 根据上面MyBatis工作流程，我们来想一想，Mybatis帮我们解析了什么文件，它是怎么解析的，产生了什么对象，这些对象又放在哪里？
/** * 通过 SqlSession.getMapper(XXXMapper.class) 接口方式 * @throws IOException */ @Test public void testSelect() throws IOException { String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); // ExecutorType.BATCH try { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlogById(1); System.out.println(blog); } finally { session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1c4f0d6b4628be925ccd1a30aa3245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19656745172e53afa79ea00628871d9/" rel="bookmark">
			Windows下查看CPU架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 wmic cpu list brief
参考 win和win server）dos下通过wmic命令查看硬盘和内存/CPU信息(windows自带命令查看硬件信息) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e6c668475ad6427006734d9602c446/" rel="bookmark">
			Linux中的0.0.0.0和 ：：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址表示，IP地址有两个部分组成，net-id和host-id，即网络号和主机号。
127.0.0.1 127.0.0.1属于{127，}集合中的一个，所有的网络号为127的地址都被称为环回地址，所以环回地址不等价于127.0.0.1，后者只是环回地址的一份子，是包含关系，环回地址loop back。
相比于127.0.0.1，localhost 具有更多的意义，localhost是个域名，而不是一个ip地址。之所以我们经常把localhost与127.0.0.1认为同一个是因为我们使用的大多数电脑上都将localhost指向了127.0.0.1这个地址。
0.0.0.0 服务器端，通过0.0.0.0匹配所有服务器IP，如果进程监听0.0.0.0那么客户端访问服务器任何一个可达IP都可以使用此进程。
个人电脑未配置IP时表示本机地址
路由器表示默认路由
127.0.0.1是个环回地址，是IP，并不表示“本机”，0.0.0.0才是真正表示网路中的本地。
例：服务端绑定端口的时候一般选择绑定到0.0.0.0，这样用户可以通过多个本服务器的IP进行访问。
实际：服务器有内外网IP，一般财务系统绑定内网IP仅内部访问，OA绑定0.0.0.0内外网均可访问。
:: 全0的IPV6地址，和IPV4的0.0.0.0一样，表示匹配多个IPV6地址。
用双冒号“::”表示一组0或多组连续的0，但只能出现一次，每项数字前导的0可以省略，省略后前导数字仍是0则继续，下组IPv6是等价的。
2001:0DB8:02de:0000:0000:0000:0000:0e13
2001:DB8:2de:0000:0000:0000:0000:e13
2001:DB8:2de:000:000:000:000:e13
2001:DB8:2de:00:00:00:00:e13
2001:DB8:2de:0:0:0:0:e13
参考资料
https://zh.wikipedia.org/wiki/IPv6#IPv6.E6.A0.BC.E5.BC.8F
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/390/">«</a>
	<span class="pagination__item pagination__item--current">391/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/392/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>