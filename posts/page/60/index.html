<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0620121f85839378181b09b9b8501f/" rel="bookmark">
			【数据结构与算法】(23)高级数据结构与算法设计之 Backtracking Algorithm回溯算法 代码示例与详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 4.5 Backtracking Algorithm1) 入门例子2) 全排列-Leetcode 463) 全排列II-Leetcode 474) 组合-Leetcode 775) 组合总和-Leetcode 396) 组合总和 II-Leetcode 407) 组合总和 III-Leetcode 2168) N 皇后 Leetcode 519) 解数独-Leetcode37其它题目 4.5 Backtracking Algorithm 1) 入门例子 public class Backtracking { public static void main(String[] args) { rec(1, new LinkedList&lt;&gt;()); } static void rec(int n, LinkedList&lt;String&gt; list) { if (n == 3) { return; } System.out.println("before:" + list); list.push("a"); rec(n + 1, list); list.pop(); System.out.println("after:" + list); } } 2) 全排列-Leetcode 46 public class PermuteLeetcode46 { static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { boolean[] visited = new boolean[nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0620121f85839378181b09b9b8501f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bebf9d2e8f62c8c0a265b73951e24308/" rel="bookmark">
			k8s笔记26--快速实现prometheus监控harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s笔记26--快速实现prometheus监控harbor 简介采集指标&amp;配置grafana面板采集指标配置grafana面板 说明 简介 harbor是当前最流行的开源容器镜像仓库项目，被大量IT团队广泛应用于生产、测试环境的项目中。本文基于Harbor、Prometheus、Grafana介绍快速实现监控harbor的方法和步骤。
采集指标&amp;配置grafana面板 本文前置条件需要安装harbor、prometheus、grafana。harbor可以通过docker-compose的方式快速安装，安装方式可以参考 docker笔记10–安装与使用harbor 。prometheus 可以单独安装，也可以通过开源组件来安装，例如通过 kubesphere来安装(笔者直接使用这种方式)。grafana安装方式可以参考 k8s笔记12–grafana的配置和常见使用。
安装完成基础组件/系统后，我们可以参考如下采集指标、配置grafana面板的步骤完成harbor的监控。
采集指标 较新版本的harbor已经提供了metrics接口，即 ip:9090/metrics。能正常获取harbor指标后，我们只需要在集群中新建一个svc和 serviceMonitor，然后prometheus就能自动采集到harbor的指标。
主要配置案例yaml如下：
1） 新建Endpoints # vim harbor-ep.yaml apiVersion: v1 kind: Endpoints metadata: labels: app: harbor name: harbor namespace: devops-test subsets: - addresses: - ip: 172.16.xx.xx ports: - name: metrics port: 9090 protocol: TCP 2） 新建Service # vim harbor-svc.yaml apiVersion: v1 kind: Service metadata: labels: app: harbor name: harbor namespace: devops-test spec: internalTrafficPolicy: Cluster ports: - name: metrics port: 9090 protocol: TCP targetPort: 9090 type: ClusterIP 3) 新建 serviceMonitor # vim harbor-servicemonitor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bebf9d2e8f62c8c0a265b73951e24308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d04919bf8109b39cfebfc821738d45/" rel="bookmark">
			写PPT心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，要有一个模版和大纲。模版决定了PPT的风格样式、大纲决定了PPT的内容，模版和大纲形成了PPT的骨架。
其次，根据大纲，往PPT填充与主题相吻合的内容。
这里如果是工作PPT，以往的工作项目的脑图、流程图、业务架构图可以多搬过来，尽量用概括的文字加图片代替一大段又臭又长的文本展示。
再次，如何缓和写PPT的疲劳感？
在大纲已经定了的前提下，可以跳着段落写，把容易写或者当前有灵感的段落先写了。这样可以增加成就感，缓和紧张感。说不定写着写着就文思泉涌，为比较难写的段落打开了思路！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882b5ba2b8a73043935b91ace2479553/" rel="bookmark">
			【大数据】Flink 内存管理（四）：TaskManager 内存分配（实战篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Flink 内存管理》系列（已完结），共包含以下 4 篇文章：
Flink 内存管理（一）：设置 Flink 进程内存Flink 内存管理（二）：JobManager 内存分配（含实际计算案例）Flink 内存管理（三）：TaskManager 内存分配（理论篇）Flink 内存管理（四）：TaskManager 内存分配（实战篇） 😊 如果您觉得这篇文章有用 ✔️ 的话，请给博主一个一键三连 🚀🚀🚀 吧 （点赞 🧡、关注 💛、收藏 💚）！！！您的支持 💖💖💖 将激励 🔥 博主输出更多优质内容！！！
Flink 内存管理（四）：TaskManager 内存分配（实战篇） 1.单独分配 Total Process Size2.单独分配 Total Flink Size3.单独分配 Heap Size &amp;&amp; Managed Memory4.分配 Total Process Size 和 Heap Size &amp;&amp; Managed Memory5.分配 Total Flink Size 和 Heap Size &amp;&amp; Managed Memory6.内存分配小结 在 《Flink 内存管理（一）：设置 Flink 进程内存》中我们提到，必须使用下述三种方法之一配置 Flink 的内存（本地执行除外），否则 Flink 启动将失败。这意味着必须明确配置以下选项子集之一，这些子集没有默认值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882b5ba2b8a73043935b91ace2479553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c06045c4162b8e93a829516b48e36e/" rel="bookmark">
			AveragePooling1D层 和 MaxPooling1D layer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AveragePooling1D层
tf.keras.layers.AveragePooling1D(
pool_size=2, strides=None, padding=“valid”, data_format=“channels_last”, **kwargs
)
平均池化用于时序数据。
下采样输入表示，通过对被定义为pool_size的窗口取平均值。窗口根据步长strides进行切换。
当使用"valid" （padding）填充选项时，结果的输出的形状为：output_shape = (input_shape - pool_size + 1) / strides)
示例代码1：
x = tf.constant([1., 2., 3., 4., 5.])
x = tf.reshape(x, [1, 5, 1])
x
&lt;tf.Tensor: shape=(1, 5, 1), dtype=float32, numpy=
array([[[1.],
[2.],
[3.],
[4.],
[5.]], dtype=float32)&gt;
avg_pool_1d = tf.keras.layers.AveragePooling1D(pool_size=2,
… strides=1, padding=‘valid’)
avg_pool_1d(x)
&lt;tf.Tensor: shape=(1, 4, 1), dtype=float32, numpy=
array([[[1.5],
[2.5],
[3.5],
[4.5]]], dtype=float32)&gt;
当使用"same"（padding）填充选项时，输出形状：output_shape = input_shape / strides
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c06045c4162b8e93a829516b48e36e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a469a0950950cefdecc94098c862d40e/" rel="bookmark">
			(None, 0, 5) 用keras.layers.MaxPool1D 出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你尝试使用 keras.layers.MaxPool1D 对一个形状为 (None, 0, 5) 的张量进行操作时，确实会遇到错误。这是因为 MaxPool1D 期望的输入是一个三维张量，其形状通常为 (batch_size, sequence_length, features)。
在你的例子中，sequence_length 为0，这意味着你的序列长度为0，这在实际应用中是不合理的。
为了解决这个问题，你应该确保你传递给 MaxPool1D 的张量有一个合理的 sequence_length。
例如，如果你的输入是一个形状为 (batch_size, timesteps, features) 的序列，你可以这样使用 MaxPool1D：
from keras.models import Sequential from keras.layers import MaxPool1D model = Sequential() model.add(MaxPool1D(pool_size=2, input_shape=(timesteps, features))) # ... 添加其他层 ... 确保 timesteps 是一个大于0的整数。
如果你的输入数据真的是 (None, 0, 5)，那么你需要检查你的数据预处理步骤，确保你没有错误地删除了所有的时间步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9a5aadb4804fd6960a2314aa6e3bbb/" rel="bookmark">
			int128的实现（基本完成）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然有一个声明叫_int128但是这并不是C++标准：
long long 不够用？详解 __int128 - FReQuenter - 博客园 (cnblogs.com)
网络上去找int128的另类实现方法，发现几乎都是在介绍_int128的
然后我就自己想了个办法，当时还没学C++，用C草草写了下了事，也没有验证行不行
在这周一（2024/2/19）看了C++的类以及运算符重载之后，我打算拿int128来练练手
重载倒是很快练好了，但是代码有大问题：
int128的实现（未完成）-CSDN博客
int128的实现_实现一个int128的数-CSDN博客
可以看看我之前的愚蠢的代码
主要是完全没注意到数爆出2^64的问题（主要体
#ifndef CSTDIO_ #define CSTDIO_ #include&lt;cstdio&gt; #endif #ifndef CCTYPE_ #define CCTYPE_ #include&lt;cctype&gt; #endif #ifndef VECTOR_ #define VECTOR_ #include&lt;vector&gt; #endif #ifndef INT128_H_ #define INT128_H_ typedef unsigned long long LLU;//64位 typedef unsigned int U;//32位 const U MAX32 = 0xFFFFFFFF; const LLU MAX64_U = 0xFFFFFFFF00000000; const LLU _2POW32 = (LLU)MAX32 + 1; class INT128{ LLU A, B, C, D; public: INT128(LLU tmp = 0){A = B = 0, C = (tmp &amp; MAX64_U) &gt;&gt; 32, D = tmp &amp; MAX32;}; void getnum(void); INT128 operator-(const U &amp; tmp) const; INT128 operator+(const LLU &amp; tmp) const; INT128 operator+(const INT128 &amp; tmp) const; INT128 operator*(const U &amp; tmp) const; INT128 operator/(const U &amp; tmp) const; INT128 operator%(const U &amp; tmp) const; void operator=(const LLU &amp; tmp); void show(void); inline void function1(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data); inline void function2(std::vector&lt;int&gt; &amp; tmp, LLU &amp; data); }; void INT128::getnum(void) { A = B = C = D = 0; std::vector&lt;int&gt; tmp; char c; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9a5aadb4804fd6960a2314aa6e3bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280fa8b4d32c6615de390c98bb1bf801/" rel="bookmark">
			104. lower()函数-将大写字母转换为小写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		104. lower()函数-将大写字母转换为小写 【目录】
文章目录 104. lower()函数-将大写字母转换为小写1. lower( )函数的功能2. lower( )函数的语法3. 代码示例4. 知识回顾-字符串变量5. 知识回顾-读取文件6. 实操练习 【正文】 1. lower( )函数的功能 lower [ˈləʊə]：较低的，下游的。
lower的中文意思是较低的，下游的。
lower( )函数用于将Python字符串对象中的所有大写字母转换为小写字母，并返回转换后的新字符串。
【功能】将字符串中的所有大写字母转换为小写字母。
2. lower( )函数的语法 【语法】
string.lower() lower( )函数由4部分组成：
要操作的字符串对象：string 英文小圆点. 函数名:lower 英文小括号：( ) 【参数】
lower( )函数无需传入参数。
【返回值】
lower( )函数不改变原始字符串，而是返回一个新的字符串。
字符串在Python中是不可变的，所以任何对字符串的操作都会返回一个新的字符串。
3. 代码示例 【代码示例1】
# 示例1：将字符串中的大写字母转换为小写字母 string = "Hello World" result = string.lower() print(result) # 输出：hello world 【终端输出】
hello world 【代码解析】
第1行代码我们定义了一个字符串变量string。第2行代码然后使用lower()函数将字符串中的大写字母H转换为小写字母h，并将转换后的字符串赋值给result变量。第3行代码打印输出结果。 【代码示例2】
# 示例2：lower()函数不改变原始字符串，而是返回一个新的字符串 string = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280fa8b4d32c6615de390c98bb1bf801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0064ab96acb74fcbbcda1fcc2af2cec/" rel="bookmark">
			电商行业网络安全——守护数字世界的交易安全与信任
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的迅猛发展，电子商务行业在全球范围内呈现出爆炸性增长的态势。然而，伴随着网络交易的便捷性，网络安全问题也愈发凸显，成为电商行业必须严肃面对的挑战。在这个数字化、信息化的时代，电商行业的网络安全不仅关乎企业的生死存亡，更直接关系到亿万消费者的切身利益。因此，加强电商行业网络安全建设，守护数字世界的交易安全与信任，已成为行业内外共同关注的焦点。
在这个背景下，我们不仅要认识到电商行业网络安全的重要性，还要深入了解网络安全威胁的来源和特点，以及采取有效的应对策略和措施。只有这样，我们才能在享受网络交易带来的便捷与高效的同时，确保个人信息和资金的安全，维护电商行业的健康、稳定和可持续发展。
电商行业面临的网络安全威胁是多方面的，主要包括以下几个方面：
1、数据泄露：电商平台上存储着大量的用户个人信息和交易数据，这些数据如果被黑客攻击或内部人员泄露，将会给用户和企业带来严重的损失。
2、恶意攻击：黑客可能会通过攻击电商平台来窃取数据、破坏系统或进行勒索等恶意行为，这些攻击不仅会影响电商平台的正常运行，还可能导致用户信息泄露和资金损失。
3、钓鱼网站和虚假交易：一些不法分子会利用虚假交易或钓鱼网站来骗取用户的个人信息和资金，这些行为不仅会导致用户损失，还会影响电商平台的声誉和信誉。
4、系统漏洞和弱密码：电商平台如果存在系统漏洞或用户密码过于简单，就容易被黑客攻击和破解，从而导致数据泄露和系统崩溃等安全问题。
为了应对这些威胁，电商平台需要采取一系列安全措施，如加强数据加密、建立安全审计机制、提高用户密码强度、加强员工安全培训等，以确保用户信息和交易数据的安全。同时，可以寻找网络安全服务商对整体业务进行安全的防护。
对于电商网络安全需要从多层面、多角度建设，相互配合、优势互补，从而更大程度地增加安全效果，保障用户的电商互联网业务平台安全稳定运行。目前德迅云安全根据客户的电商业务特点，同时结合德迅云安全大数据云计算平台，为用户的电商业务提供以下贯彻企业网站安全的解决方案。
一、事前安全建设
电商企业网站众多，因此需要大规模的网站监测系统，以方便了解网站安全的整体态势。定期对电商企业的系统做深入安全探测，让电商企业知道自己网络所面临的问题。坚持挖掘有价值的威胁情报，真正做到风险预警。除此之外，提升电商企业员工的安全意识水平和安全事件处理能力，能很大程度在事前降低风险。最后，在重要时期需要加强安全运维管理服务，以保障电商业务的持续安全运营。
二、事中安全控制
在电商平台运营过程中，为了预防大流量的DDoS和CC攻击需要采用专业的抗D服务，保障业务的可持续运行。业务安全方面，需要对安全大数据进行深度挖掘，并精剖行业中易产生欺诈行为的业务场景，杜绝羊毛党等欺诈行为。另外，部署安全防护产品对电商系统的服务器进行篡改防护、敏感信息泄露防护等也是必不可少的。最后在访问速度上可以通过智能缓存、传输协议优化、内容优化等技术提升2-10倍访问速度，并减少源站压力。
三、事后紧急响应
当用户的电商系统因外部恶意入侵、攻击或由于内部误操作等原因而引起安全异常时，安全服务团队将在第一时间到达现场，协助对事件的成因及过程进行分析与追溯，并根据分析结果提供针对性的修复建议，保障安全事件发生时，第一时间定位问题、解决问题，防止问题再次发生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd1b4fa633cb76a94f57695f7d3bdbc/" rel="bookmark">
			【LLM入门实践】简便快捷获取Hugging Face模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 好久没有更新博客了，由于AI 大模型技术经过2023年的狂飙，2024年迎来大量的应用的落地，作为一个技术人，我也对此有了浓厚的兴趣，买了很多本书，然后试图找到一个学习大模型的速成模式，遗憾的是，这个领域和基本的编程语言学习还有着一定的差异，首先在入门的一些基础概念理解上就有一定的壁垒，接下来对一些工具的使用以及原理，参数的一些实践和尝试。需要琢磨和理解才能进行。这其中对于transformer的使用，遇到了一些小的问题，比如从Hugging Face上下载模型特别慢，大大消耗了初学者的耐心。所以通过各种尝试，找到了目前感觉还算可以的hf镜像网站，今天给大家推荐一个镜像网站。不能让环境成为我们的拦路虎。
transformer和Hugging Face Hugging Face为transformer工具提供NLP工具和模型的共享平台， 为开发者提供了使用和部署预训练Transformer模型的便利性。使开发者能够轻松地使用和部署各种预训练的Transformer模型，如BERT、GPT、RoBERTa等。但是Hugging Face的地址位于国外，在国内访问速度简直太慢了。所以接来下我们就使用镜像网站。类似于pip的镜像源，我们一般使用国内的进行加速。
如何使用Hugging Face镜像站🌟 我们国内的公益组织提供了一个域名 hf-mirror.com，用于镜像 huggingface.co 域名。作为一个公益项目，致力于帮助国内AI开发者快速、稳定的下载模型、数据集。
再次感谢@padeoe
更多详细用法请看 《这篇教程》 。
方法一：网页下载 在本站搜索，并在模型主页的Files and Version中下载文件。
方法二：huggingface-cli huggingface-cli 是 Hugging Face 官方提供的命令行工具，自带完善的下载功能。
1. 安装依赖
pip install -U huggingface_hubCopy 2. 设置环境变量
Linux
export HF_ENDPOINT=https://hf-mirror.comCopy Windows Powershell
$env:HF_ENDPOINT = "https://hf-mirror.com"Copy 建议将上面这一行写入 ~/.bashrc。
3.1 下载模型
huggingface-cli download --resume-download gpt2 --local-dir gpt2Copy 3.2 下载数据集
huggingface-cli download --repo-type dataset --resume-download wikitext --local-dir wikitextCopy 可以添加 --local-dir-use-symlinks False 参数禁用文件软链接，这样下载路径下所见即所得，详细解释请见上面提到的教程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd1b4fa633cb76a94f57695f7d3bdbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288ef1dc3d603a62942790ff6f98d5a1/" rel="bookmark">
			2024年了，如何从 0 搭建一个 Electron 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、准备工作三、快速开始四、后续（完） 一、简介 Electron 是一个开源的跨平台桌面应用程序开发框架，它允许开发者使用 Web 技术（如 JavaScript、HTML 和 CSS）来构建桌面应用程序。Electron 嵌入了 Chromium（一个开源的 Web 浏览器引擎）和 Node.js（一个运行在服务器端的 JavaScript 运行时环境），使得开发者能够创建既具有现代 Web 应用的丰富交互性，又具备传统桌面应用的功能和性能的应用程序。
程序员每天离不开的 Visual Studio Code，以及团队协作软件 Slack，聊天社区 Discord 的客户端，都是用 Electron 开发的，虽然因为其原理，需要同时打包 node.js 和 Chromium 在最后的软件包里，使得分发包比较大，但是 Electron 框架周边成熟度、兼容性和开发体验真的很棒。仍然是现在桌面端跨平台开发的首选技术之一。最近，我就利用 Electron 技术开发了一个博客客户端软件 HexoPress，开源在 GitHub。从 0 开始学习并完整体验了 Electron 开发的各个方面。
本文给大家分享，2024 年，如何从 0 开始创建一个 Electron 项目。
二、准备工作 首先你需要一个开发环境，我会使用 Mac 作为例子，如果你使用的是 Windows，我建议通过虚拟机安装 Linux，会跟在 Mac 下差不多的体验，但是在 Windows 上，相对来说不像前两者那么方便。
开始之前，你首先需要安装 Node.js 的开发环境，在 Mac 就是：
brew install node 或者，你可以使用 nvm 来管理电脑上安装的 node 环境的多个版本。本文就不介绍了。npm 也是一个必须的工具，不过安装好 node，会自动就安装了 npm。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288ef1dc3d603a62942790ff6f98d5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac02b4232ad7a37862d40603bc52b4cf/" rel="bookmark">
			【Vue实现参数传递：查询参数 vs. 动态路由】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 查询参数传递1. 什么是查询参数？2. 在Vue中使用查询参数步骤 1：在路由配置中定义查询参数步骤 2：在组件中使用查询参数步骤 3：在页面中生成链接 3. 查询参数传递的优势 动态路由传递1. 什么是动态路由？2. 在Vue中使用动态路由步骤 1：在路由配置中定义动态路由步骤 2：在组件中使用动态路由参数步骤 3：在页面中生成链接 3. 动态路由传递的优势 查询参数传递 1. 什么是查询参数？ 查询参数是一种将数据附加到URL的方式，通常出现在问号（?）后面，用于传递信息。例如：/search?keyword=vue&amp;page=1，其中keyword和page就是查询参数。
2. 在Vue中使用查询参数 Vue Router允许你在路由中定义查询参数，这样就可以在不同组件之间传递数据。
步骤 1：在路由配置中定义查询参数 const routes = [ { path: '/search', component: SearchComponent, props: (route) =&gt; ({ keyword: route.query.keyword, page: route.query.page }) } ] 步骤 2：在组件中使用查询参数 &lt;template&gt; &lt;div&gt; &lt;h1&gt;搜索结果&lt;/h1&gt; &lt;p&gt;关键词：{{ keyword }}&lt;/p&gt; &lt;p&gt;页码：{{ page }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { keyword: String, page: Number } } &lt;/script&gt; 步骤 3：在页面中生成链接 &lt;router-link :to="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac02b4232ad7a37862d40603bc52b4cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fbfc0f3fb7b69852d04f3a6121f405/" rel="bookmark">
			nodejs&#43;vue&#43;ElementUi旅游景区门票预约系统停车系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统主要功能模块如下：
单独定制程序，一定要按照要求，然后界面新鲜。2.5要录屏
可以更新前台展示的景区信息。
前后端分离
前端nodejs+vue+ElementUi
语言 node.js
框架：Express/koa
前端:Vue.js
数据库：mysql
开发软件：VScode/webstorm/hbuiderx均可
运行软件:vscode
该系统将采用B/S结构模式，使用Vue和ElementUI框架搭建前端页面，后端使用Nodejs来搭建服务器，并使用MySQL，通过axios完成前后端的交互 网页可以自适应移动端使用
风格：
大概布局风格可以按照这个来
（1） 登录注册
用户可以直接以游客身份预览，也可以注册账号登录，登录才可享受更多服务。
（2） 预约服务
用户可以在网页内预约景区门票、专人讲解预约、停车位（时间段）、预约洗车等服务。
（3） 景区信息展示
用户可以对景区信息进行查看，这样游客可以自我选择更好的线路规划，且信息显
示以一种更加直观的方式呈现出来。
（4） 反馈服务
用户可以通过反馈的方式来向工作人员说明服务的不恰当点或改进的建议等。
后台可以查看网站点击信息和预约过得游客得统计信息，图标动态展示统计信息，
最好用echarts图。前段也可查看预约人数。
用户前端可查看预约的景区信息，查看已预约的人数，预约讲解人员，预约停车位（做一个选择时间的）需要选择时间段。
注册需要手机验证码。
可以先直接进入网页浏览部分信息，登陆后显示全部信息，预约必须登录
一进入网页是一个景区信息图片的展示，上面有预约的按钮，未登录时点击会提醒登陆。登陆可以使用验证码、账号（手机号）+密码形式登陆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040c4a0d792193bc043a917f70b7a127/" rel="bookmark">
			基于RK3399 Android11适配OV13850 MIPI摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、原理图分析2、编写和配置设备树3、调试方法4、遇到的问题与解决5、补丁 1、原理图分析 从上图可看出，我们需要关心的，①MIPI数据和时钟接口使用的是MIPI_TX1/RX1 ②I2C使用的是I2C4总线 ③RST复位引脚使用的是GPIO2_D2 ④PWDN使用的是GPIO1_C7 ⑤MCLK使用的是GPIO3_B7 ⑥需要保证红色框框的供电电源正常。
结合RK提供的文档，如下摄像头数据采集拓扑图所示，我们就可以开始编写配置设备树了，其实官方提供了很多类似的设备树配置给我们参考的。
2、编写和配置设备树 ①配置OV13850设备树节点Ⅰ
②配置OV13850设备树节点Ⅱ 提示：下图复用功能是&lt;. RK_PB7 3 &amp;pcfg_pull_one&gt;;
③配置dphy
④配置isp
3、调试方法 ①移植成功后，使用dmesg指令查看对应驱动的log
②驱动加载成功后，会有生成以下的摄像头设备节点
③RKISP 驱动如果加载成功,会有 video 及 media 设备存在于/dev/目录下。系统中可能存在 多个/dev/video 设备,通过/sys 可以查询到 RKISP 注册的 video 节点
④查看拓扑结构
Ⅰ、通过media-ctl -p 查看rkisp1_selfpath 信息，可以知道打开哪些media设备
Ⅱ、再通过media-ctl -p /dev/media0 查看已打开的media设备的拓扑，下图是截取了一部分信息
⑤查看摄像头支持哪几种图像流格式，截图省略
指令：v4l2-ctl -d /dev/video0 --list-formats
⑥查看调试上层相关信息，截图省略
指令：dumpsys media.camera
⑦抓图
指令：v4l2-ctl -d /dev/video0 --set-fmt-video=width=800,height=600,pixelformat=NV12 --stream-mmap=3 --stream-to=/sdcard/out.yuv --stream-skip=9 --stream-count=1
查看YUV图片可以使用该网站：在线查看 YUV 文件的免费在线工具 - ImageToStl
4、遇到的问题与解决 ①问题1：相机权限问题:解决问题的链接
②问题2：没有获取到对应IQ文件，后面查看编译生成的文件，并没有将IQ文件拷贝过去，报错如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/040c4a0d792193bc043a917f70b7a127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39aa88f48eea0299445e51e644882a6d/" rel="bookmark">
			【2024软件测试面试必会技能】Appium自动化(6)：原生app元素定位方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元素定位方法介绍及应用： Appium方法定位原生app元素: 通过appium inspector工具，可以获取元素的相关信息；在appium中提供了一系列的元素定位API，通过在这些API中输入指定的元素信息，就能完成元素定位，定位元素后就进行对元素进行自动操作。
appium中识别元素的方式有两种写法
方式一：driver.find_element_by_id(" ")
方式二：driver.find_element(By.ID," ") -----推荐使用
基本元素定位如下： 前置条件
代码示例：
from appium import webdriver # 导入appium 驱动包 from appium.webdriver.webdriver import By # 导入appium 定位的方法包 # 1、定义一个DesiredCapabilities配置的字典 des = { 'platformName':'Android', 'platformVersion':'6.0.1', # 填写android虚拟机/真机的系统版本号 'deviceName':'MuMu', # 填写安卓虚拟机/真机的设备名称 'appPackage':'com.sky.jisuanji', # 填写被测app包名 'appActivity':'.JisuanjizixieActivity', # 填写被测app的入口 'udid':'127.0.0.1:7555', # 填写通过命令行 adb devices 查看到的udid 'noReset':True, # 重置APP 'unicodeKeyboard':True, # 支持中文输入 'resetKeyboard':True, # 支持重置键盘 'newCommandTimeout':30 # 30秒没发送新命令就断开连接 } # 2、把配置的字典作为请求参数发送给appium服务器 driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub',des) 1、ID定位（取resource-id、id、name）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39aa88f48eea0299445e51e644882a6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4524dea6743c32ded0b1ff2ca8095fc1/" rel="bookmark">
			国内外各ChatGPT类语言大模型API价格汇总, 对比，ChatGPT/Gmini/PaLM/Clude/Ernie/ChatGLM/千问/混元/星火/Minimax/百川
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内外各ChatGPT类语言大模型API价格汇总, 对比 概述 时间已经步入2024年了，大模型时代的下半场，应该是卷各种应用落地吧。那么，我们去看看他们各家的产品价格把。去年，2023年，国内外的IT公司大都发布了自己的类ChatGPT语言大模型，有种“百模大战”的味道。至2024.01.01, 收录的有, ChatGPT/Gmini/PaLM/Clude/Ernie/ChatGLM/Qwen/Hunyuan/星火/Minimax/Baichuan chatgpt url:
官方 https://openai.com/pricing微软 https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/#pricingchatgpt显然是当前最好用的语言大模型了, 看价格微软的还要便宜一点, 这应该是大集群优势, 规模效应边际成本下降的原因, 2023年应该卖了很多。 openai官方定价 gpt-4 gpt-4-turbo gpt-3.5-turbo-older gpt-3.5-turbo-newest 微软定价 gmini-palm2 url: https://cloud.google.com/vertex-ai/pricing
谷歌 谷歌进入大模型时代好像流年不利, 先是基于palm的bard宣发不利, 没有后发优势; 最近的gmini又被openai的视频赛道的sora模型抢了热搜，仿佛成了旧时代的背景板。
仔细看了一下最近开源的Gemma-7B, 也是LLaMA架构了，乐。
gmini palm-2 clude url: https://aws.amazon.com/cn/bedrock/pricing/?refid=45de195e4-2c61-4588-bbdd-c78f40ab2961
aws.amazon定价 clude官网好像查不到api价格, 不过大都说clude2与clude2.1价格相同, 查看亚马逊云服务的价格.亚马逊云上的clude大模型定价很有意思, 有租赁独享一个大模型的(就是比较贵, 承诺1/6个月几十美元一小时, 预配置吞吐量定价) 按需调用api 直接独享一个大模型 ernie url: https://cloud.baidu.com/doc/WENXINWORKSHOP/s/hlrk4akp7
百度 ALL in AI的百度在深度学习时代好像没做成什么，希望技术派百度在大模型时代有所收获吧。 chatglm url: https://open.bigmodel.cn/pricing
清华 清华这次可是把握住了风口, 智谱AI估值几百亿, 融资几十亿, 不过glm也不是当初的pre-norm了, 都采用LlaMA架构了;之前还有个chatglm-turbo超级便宜, 0.005元/千tokens, 是12B的那个模型？ glm-4 glm-3.5 glm-turbo qwen url: https://help.aliyun.com/zh/dashscope/developer-reference/tongyi-thousand-questions-metering-and-billing?spm=a2c4g.11186623.0.0.4489140bY2i2Ka
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4524dea6743c32ded0b1ff2ca8095fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ab055267350ce856d4cec96cfd036b/" rel="bookmark">
			列表的导入 导出 下载模板 功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		样式
按钮代码：
&lt;el-row :gutter="10" class="mb8 mar-top-20"&gt; &lt;el-col :span="1.5"&gt; &lt;el-button type="info" plain icon="el-icon-upload2" size="mini" @click="handleImport" &gt;导入&lt;/el-button &gt; &lt;/el-col&gt; &lt;el-col :span="1.5"&gt; &lt;el-button type="success" plain icon="el-icon-edit" size="mini" class="downTem" @click="handleTemplate"&gt;下载模板&lt;/el-button&gt; &lt;/el-col&gt; &lt;el-col :span="1.5"&gt; &lt;el-button type="warning" plain icon="el-icon-download" size="mini" @click="handleExport"&gt;导出&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; 一 post封装统一下载方法 点击事件处理--导入
//导入功能 //说明 ：点击按钮打开导入弹窗，可拖拽文件上传，上传后点击确定按钮 handleImport() { this.upload.title = '用户导入' this.upload.open = true }, //弹窗代码 &lt;!-- 导入对话框 --&gt; &lt;el-dialog :title="upload.title" :visible.sync="upload.open" width="400px" append-to- body&gt; &lt;el-upload ref="upload" :limit="1" accept=".xlsx, .xls" :headers="upload.headers" :action="upload.url + '?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ab055267350ce856d4cec96cfd036b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a62a184690127bf77156e3a8136e58/" rel="bookmark">
			firewalld 的概念和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Firewalld是Linux系统上的一款动态防火墙管理工具。它以服务为单位，具有灵活的配置选项，可用于管理网络流量的安全性。Firewalld提供了一个图形化的界面，使得配置和管理防火墙规则变得更加简单。下面是一些关于Firewalld概念和实际配置案例的详细介绍。
Firewalld的区域概念：
Firewalld的主要概念是“zones”（区域）和“services”（服务）。“区域”定义了系统上的不同网络环境，并允许将不同的规则应用于不同的区域。例如，可能有一个“公共”区域用于外部网络，一个“内部”区域用于受信任的内部网络，以及一个“DMZ”区域用于服务器。
fiewwall-config可以看到九个区域
trusted（信任区域） 允许所有的传入流量。 public（公共区域） 允许ssh或dhcpv6-client服务匹配的传入流量，其余均拒绝。为默认区域。 external（外部区域） 允许ssh服务匹配的传入流量其余均拒绝。 home（家庭区域） 允许ssh、mdns、samba-client、dhcpv6-client服务匹配的传入流量，其余拒绝。 internal（内部区域） 默认值与home区域相同。
work（工作区域） 允许ssh、dhcpv6-client服务匹配的传入流量，其余拒绝 dmz（非军事区域） 允许ssh服务匹配的传入流量，其余拒绝。
block（限制区域） 拒绝所有传入流量。
drop（丢弃区域） 丢弃所有传入流量，并且不产生包含icmp的错误响应。
firewalld 服务概念
服务则定义了特定的网络服务或应用程序，例如SSH、http等。
下面看Firewalld的配置案例：
以下是一个典型的Firewalld配置案例，其中包含了配置不同区域和服务的示例规则：
1. 配置区域：
首先，我们需要定义并配置各个区域。我们可以使用以下命令来创建和配置一个名为"public"的区域：
sudo firewall-cmd --permanent --zone=public --add-interface=eth0 sudo firewall-cmd --permanent --zone=public --set-target=ACCEPT
以上命令中，创建了一个名为"public"的新区域，并将eth0网卡添加到该区域中。最后，将区域的默认目标设置为ACCEPT，表示默认情况下允许所有入站和出站流量。
2. 配置服务：
接下来，我们可以定义一些常见的服务，并将其与特定的区域关联。例如，我们可以配置SSH服务允许在"public"区域中访问：
$ sudo firewall-cmd --permanent --zone=public --add-service=ssh
这将允许传入ssh连接到系统的"public"区域。
3. 配置端口：
除了服务，我们还可以配置特定的端口允许流量通过。例如，我们可以允许HTTP流量通过端口80：
$ sudo firewall-cmd --permanent --zone=public --add-port=80/tcp
4. 应用规则：
最后，我们需要应用我们的规则更改：
$ sudo firewall-cmd --reload
这将重新加载Firewalld的配置，并应用我们之前定义的规则。
Firewalld临时配置，实时生效，不会中断现有连接，重启后丢失。--permanent 参数 设置成永久生效，需要重启服务或重新加载后才生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a62a184690127bf77156e3a8136e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6392e5a02832a2e1acaf444396407e7e/" rel="bookmark">
			Makefile的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		target是目标文件 可以是一个执行文件，也可以是标签，或者伪目标当有多个目标时，目标之间用空格分隔 prerequisites是该文件所依赖的文件 当有多个依赖项时，依赖项之间用空格分隔 command是任意shell命令 只要targets不存在或prerequisites中有一个以上的文件比targets文件新，command所定义的命令就会被执行伪目标总是会被执行 target ...: prerequisites ... command1 command2 .... make命令默认执行第一个目标文件 可以用伪命令当做第一个目标文件 伪目标 声明为伪目标后,在执行对应的命令时，make 就不会检查是否存在target其对应的文件，而是每次都会运行对应的命令 若不声明：恰好存在同名的文件，则 make 将会认为 xx 文件已存在，没有重新构建的必要了 如果目录中含有或会生成和伪目标同名的文件，则需要通过**.PHONY**显示声明 例如： .PHONY: clean test build 依赖 只有在目标文件的依赖比目标文件新的时候，才会更新目标文件所以在生成.o文件的时候必须把所有头文件（包括隐式依赖的头文件）都放入依赖中 所谓隐式依赖就是a.c中include了a.h，而a.h中inlcude了b.h，则a.o的依赖是a.c, a.h 和 b.h 命令 如果第二行命令必须依赖第一行命令，则需要放在一行写，用分号隔开 例如：cd …; pwd否则打印的还是当前目录 默认如果命令执行错误则不执行后续命令 但是有些命令是可以错误的，此时需要在命令前加- 例如 -mkdir dir1, 如果错误则证明目录已经在了, 无需报错退出 make 默认会打印每条命令，再执行 如果不想打印出命令本身，只想打印输出，则需要在命令前加上@ 例如: @echo 123，只会打印123 例子 all: build build: clean ./build.sh online: build ./output/online/bootstrap.sh boe: build ./output/test/bootstrap.sh clean: rm -rf ./output test: go test -v -count=1 -race .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6392e5a02832a2e1acaf444396407e7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe973b86001037f5e957c573da6949d/" rel="bookmark">
			ReactNative开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS环境：
Expo是一个开源工具链和平台，用于构建基于React Native的跨平台移动应用程序。Expo的目标是简化移动应用程序的开发流程，使开发者可以更轻松地构建高质量的应用程序，而无需处理复杂的配置和设备兼容性问题。
Expo是由一个名为Expo团队的开发团队开发和维护。他们致力于提供开发者友好的工具和资源，帮助开发者加速移动应用程序的开发过程。通过Expo，开发者可以使用丰富的API和组件库，轻松访问设备功能，快速进行开发迭代，并在多个平台上部署他们的应用程序。
h5结合原生APP开发
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/61/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>