<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd279725200904b26fcd74ffbedee275/" rel="bookmark">
			BAT批处理：文件批量查找与复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期因为工作需要，经常要根据文件清单批量查找文件并复制到指定文件夹，手动操作十分繁琐。因此，参考本站文章编写了一个文件批量查找与复制的批处理程序。
参考文章:http://t.csdnimg.cn/aNciG
本文程序的主体代码来自上方参考文章，与其相比增加了手动输入相关参数的功能。
1、程序代码 @echo off setlocal enabledelayedexpansion echo -------------------------------- BEGIN ---------------------------------- rem set parameter here rem dirCopy: 0-file copy, 1-directory copy rem path do not end with backslash rem sourcePath only support one path when use directory copy, multi path(separated by semicolons and make sure all path is exist) is available when use file copy rem eg: rem file copy: rem set sourcePath=C:\Users\Desktop\test 1;C:\Users\Desktop\test2 rem set targetPath=C:\Users\Desktop\target rem set fileList=list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd279725200904b26fcd74ffbedee275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e1beb998cb7f350eddbd484c95cd88/" rel="bookmark">
			【Linux Screen命令】Linux用户注销后可长时间运行的命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用情境 你有没有这样的经历：你有一台远程计算机，并在上面执行长时间运行的任务，突然连接断开，SSH 会话终止，而导致你的工作进度丢失。
幸运的是，有一个名为 Screen 的实用程序可以让我们持续会话。甚至是远程计算机用户注销的情况下程序依然在后台运行。
使用情境：
远程计算机，需要长时间执行一个程序任务。远程计算机，拥有多个用户，频繁登入登出不同账户。需要在一个账户下长时间执行一个程序任务。 2. 安装 Screen 在开始使用“screen”之前，您需要确保它已安装在您的 Linux 服务器上。大多数现代 Linux 发行版都预装了“screen”，但如果您的系统上没有它，您可以使用特定于您的发行版的包管理器轻松安装它。
对于基于 Debian/Ubuntu 的系统，请使用以下命令：
sudo apt-get update sudo apt-get install screen 对于 Red Hat/CentOS 系统，请使用：
sudo yum install screen 对于 Arch Linux，请使用：
sudo pacman -S screen 3. 基本用法 3.1 创建Screen 在控制台中输入 screen 就可以打开一个屏幕会话，创建一个新窗口，并在该窗口中启动一个 shell。但是我强烈建议在创建 Screen 的时候给这个会话取一个名字（后期会话多了之后会分不清）。把&lt;Name&gt; 替换成你想取的名字。比如：screen -S app
screen -S &lt;Name&gt; 现在您已经创建了一个screen的屏幕会话。
3.2 执行程序 你可以在新弹出的命令行中执行你的程序，然后甚至关掉命令行窗口。
如果你想screen在后台运行，只需要输入
Ctrl+a d 脱离会话后，在screen会话中运行的程序将继续运行。
3.3 查看Screen 在过了一段时间后，你想查询程序运行的情况或者结果如何。你只需要在命令行中输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e1beb998cb7f350eddbd484c95cd88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a61e1b966f3b2d3ecd9d7296e816a60/" rel="bookmark">
			奖金发放（YOJ2.0中的题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一道相对简单的题，刚开始我思路还做错了，不过所幸后面改正成功
记录利润的变量是不能改变的，因为一直要与分界值比较
关于中间截断的值的大小，我是用后一个分界值减前一个分界值，当然我特意设置数组长度为n + 1，第一个元素是0
然后很简单就做出来了
代码如下：
#include&lt;stdio.h&gt; int main(void) { int n, num; scanf("%d", &amp;n); double bonus = 0.0; int interval[n + 1]; double rate[n + 1]; interval[0] = 0; for(int i = 1; i &lt;= n; i++) scanf("%d%lf", &amp;interval[i], &amp;rate[i]); scanf("%d", &amp;num); //处理 for(int i = 1; 1; i++) { if(i == n) { bonus += (double)(num - interval[i - 1]) * rate[i]; break; } if(num &gt;= interval[i]) bonus += (double)(interval[i] - interval[i - 1]) * rate[i]; else { bonus += (double)(num - interval[i - 1]) * rate[i]; break; } } if(num &lt; 0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a61e1b966f3b2d3ecd9d7296e816a60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805ab34e1a5fd1203747f1445567aaa7/" rel="bookmark">
			字符设备驱动注册的本质及注册注销步骤，struct inode/file结构体作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、字符设备注册的本质及注册注销步骤 字符设备驱动注册的本质 只要某个信息存在于操作系统上，在操作系统中一定存在一个描述这个信息的对象，字符设备驱动注册进内核，在内核中一定会存在一个字符设备驱动对象保存当前的字符设备驱动的信息。
字符设备驱动对象结构体分析 struct cdev struct dev{
struct kobject kobj; //内核基类的对象
struct module *owner; //指向这个字符设备驱动对象的指针 THIS_MODULE
const struct file_operations *ops; //操作方法结构体
dev_t dev; //设备号的起始值
unsigned int countl; //设备数量
}；
字符设备驱动注册、注销的过程 /********************注册过程***************/
1.申请一个字符设备驱动对象
2.为字符设备驱动对象初始化赋值
3.向内核申请使用的设备号和指定数量的设备资源
4.将字符设备驱动对象注册进内核
/********************注销过程*****************/
1.注销字符设备对象
2.释放申请的设备号
3.释放字符设备驱动对象空间
字符设备驱动注册、注销相关API *******************注册过程**************
#include &lt;linux/cdev.h&gt;
1.申请字符设备驱动对象
a：struct cdev cdev;
b：struct cdev *cdev = cdev_alloc();
/*
struct cdev *cdev_alloc(void)
功能：向内核申请一个struct cdev对象
返回值：成功返回申请到的对象空间首地址，失败返回NULL
2.字符设备驱动对象的初始化
void cdev_init(struct cdev *cdev, const struct file_operation *fops)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805ab34e1a5fd1203747f1445567aaa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02a63d19830895caabad309de7c883c/" rel="bookmark">
			Flutter bugly 傻瓜式操作，上传崩溃日志与符号表解析之IOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.集成 bugly 在 pod 文件内添加引用,然后在 IOS 目录下打开终端 运行 pod install 命令 2.代码完成日志收集 2.1）先编写 flutter 端代码 main() { AppCatchError().run(App()); } //全局异常的捕捉 class AppCatchError { run(Widget app) { // Flutter 框架异常 FlutterError.onError = (FlutterErrorDetails details) async { // 线上环境 Map map = {}; map["error"] = details.toString(); MethodManager.invokeCatchedException(map); if (kReleaseMode) { Zone.current.handleUncaughtError(details.exception, details.stack!); } else { // 开发期间 print FlutterError.dumpErrorToConsole(details); } if (EasyLoading.isShow) { EasyLoading.dismiss(); } logger.e(details.toString()); }; runZonedGuarded(() { // 受保护的代码块 runApp(app); }, (error, stack) =&gt; catchError(error, stack)); } ///对搜集的 异常进行处理 上报等等 catchError(Object error, StackTrace stack) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02a63d19830895caabad309de7c883c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf42eea6078eadb01d590da1361bf4d/" rel="bookmark">
			ARM64启动过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 arm64 启动过程分析1 启动约定（boot protocol）2 内核启动第一步2.1 preserve_boot_args2.2 el2_setup2.3 set_cpu_boot_mode_flag 3 创建启动阶段页表4 为开启mmu进行的cpu初始化5 开启 mmu6 进入 start_kernel7 启动中一些其他功能实现7.1 spin_table 启动从核7.2 psci 启动从核7.3 secondary_startup 从核进入内核 arm64 启动过程分析 参考：DDI0487F_b_armv8_arm.pdf
1 启动约定（boot protocol） arm64 启动涉及到的实际内容较为复杂也多，这里分析主要在主流程上，使用的 Linux 版本为 linux-5.0。
在系统启动过程中，首先由 bootloader 执行一系列操作，并最终将控制权交由 kernel。
这里的 bootloader 对于服务器常见是的 bios/uefi 加载，对于嵌入式典型的则是 u-boot，当然也可能是 Hypervisor 和 secure monitor，或者可能只是准备最小引导环境的少量指令。
不论 bootloader 是什么，arm64 linux 在引导阶段对 bootloader 提出以下要求：
设置并初始化RAM（必须）准备好合适的设备树文件到 RAM 中，并提供 dtb 首地址给 kernel（必须）解压内核镜像（可选）将控制权交由kernel（必须） 在将控制权交由 kernel 时 Image 头部自身包含 64-byte header 信息，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abf42eea6078eadb01d590da1361bf4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4eb2b725ce60f537d85fca104eb2f1b/" rel="bookmark">
			2023.3.21
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021.9.1日接触到了acm，2023.3.21决定退出acm
我还有一些事情没干，等到真正退出的时候再把这篇文章发出来吧。
在之前我是怎么也不会想到我会以这种方式退出 曾经想过我退役的场景 或光荣 或遗憾
现在由退役变成退出了
2021.9.21-2023.3.21 接近两年的时间 我接触到了本身我心中最理想化的东西——算法竞赛
在我心中 它一直都是公平 理性的，虽然现实中遇到过很多不符合我自己三观的人或事，但丝毫不影响算法竞赛在我心中的位置。它永远都是值得且令人尊重的。
虽然退出是刚刚才决定的，但我内心仍然都是感恩与尊重。
感谢一位学长曾经把我带到这里，并且一路都在指导我，这是我步入算法竞赛以来最要感谢的人了。另外还有很多学长学姐一直在照顾着我，让我了解到了很多信息，算是帮我打开了一些世界的大门？特别感恩曾经帮助过我的人，曾经为我撑伞，以后遇到萌新，虽然我知道的不多，但是我也要把这种爱心传递下去，努力的再为别人撑伞，这也是有意义的吧。
感恩算法竞赛给我带来的不一样的思考方式
感恩算法竞赛提升了我自身的独立学习的能力
感恩算法竞赛让我获得了更多的机会，学习了更多的知识，认识了更厉害的人。
让我知道学习是多么多么多么重要的一件事情，在这里，我为我曾经不认真学习的行为表示极大的后悔与惭愧。
及时止损 在获取了一定量的知识之后如果发现这条道路不适合我，可以换条道路重新开始嘛
如果我现在所经历的难过和焦虑是源于它 虽然快乐&gt;负面情绪 为什么不尝试着去改变一下呢
故事的最后就要说再见啦
再见了 无休止的训练与焦虑
再见了 贯穿着深夜的cf
再见了 我所热衷的算法竞赛
很喜欢繁凡退役记里面的一些话 这里想引用一下，有一点点共鸣啦：
“不想打算法竞赛了。这是因为有别的事情要做，不是因为我打不动。”
“不想打比赛凌晨两点才睡了。因为我会困。”
“不想一年拉着队友训练三百场，因为我更想读读论文。”
“不想把过多意义投入到比赛中，因为这不是我想看到自己的样子，也不会让我成为我想看到的未来自己的样子。”
很可惜呀 我似乎还没有经历到每天训练三百场和花太多时间参加一些大型的比赛
但曾经有过吧 有失的过程中或许能获得什么 塞翁失马焉知非福嘛
要相信一些都是最好的安排吧~
以后或许还会接触到算法 但是算法竞赛的故事 全剧终！
重生之我是神秘人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a2a206f402ad67aa8e9912a1f7a5ec/" rel="bookmark">
			Go代码解密：理解byte和int8的边界行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到一个很有意思的 Golang 代码，最后的输出结果为 4：
func main() { count := 0 for i := range [256]struct{}{} { m, n := byte(i), int8(i) if n == -n { count++ } if m == -m { count++ } } fmt.Println(count)	// 输出为 4 } 原因如下
当 i = 0 时，n == -n 与 m == -m 成立，count+2当 i = 128 时，n == -n 与 m == -m 成立，count+2 当 i = 128，因为 n 是 int8，所以 n = (1000 0000)2，即 -128。而 -n 则为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a2a206f402ad67aa8e9912a1f7a5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25c92676ec9c006ae827b0d316027a1/" rel="bookmark">
			Vue 项目中用户登录及 token 验证的思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
Vue 项目中用户登录及 token 验证的思路 - 掘金 (juejin.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579cbf5af770857e021820f72f03d7f2/" rel="bookmark">
			Android 备忘录，记事本程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android备忘录实现，使用ObjectBox数据库框架进行数据存储，增删改查等操作。代码使用kotlin编写。
1、下面看看ObjectBox数据库封装
需要注意的是：
/**
* 你只有配置好之后, 点击 Make Model '你的model名字', 才会创建 MyObjectBox对象
* 对于MyObjectBox的包名, 目前我发现的是找到第一个Entity的包名
* 如果项目使用了Kotlin, 必须添加插件apply plugin: 'kotlin-kapt'
* 实体Entity是不能继承的哦.继承的字段不会被解析
*/
package com.mmsx.note.app import android.content.Context import android.util.Log import com.elvishew.xlog.XLog import com.mmsx.note.entity.MyObjectBox import com.mmsx.note.entity.NoteEntity import com.mmsx.note.entity.NoteEntity_ import io.objectbox.Box import io.objectbox.BoxStore import io.objectbox.android.AndroidObjectBrowser import io.objectbox.android.BuildConfig object ObjectBox { lateinit var boxStore: BoxStore private set /** * 你只有配置好之后, 点击 Make Model '你的model名字', 才会创建 MyObjectBox对象 * 对于MyObjectBox的包名, 目前我发现的是找到第一个Entity的包名 * 如果项目使用了Kotlin, 必须添加插件apply plugin: 'kotlin-kapt' * 实体Entity是不能继承的哦.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579cbf5af770857e021820f72f03d7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c96375b4d59717d9139a6e30463dad/" rel="bookmark">
			【问题记录】解决Qt连接MySQL报“QMYSQL driver not loaded”以及不支持MySQL事务操作的问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 Windows 11 家庭中文版，64 位操作系统, 基于 x64 的处理器Qt 5.15.2 MinGW 32-bitmysql Ver 14.14 Distrib 5.7.42, for Win32 (AMD64) 问题情况 在Qt 5.15.2 中编写连接MySQL数据库代码后，使用 MinGW 32-bit 构建套件进行编译运行后，报了 “QMYSQL driver not loaded” 错误！工作中也还遇到了在 Qt 5.15.2 中操作MySql数据库不能开启事务操作的问题！判断是否支持MySQL事务操作的语句如下： m_db.driver()-&gt;hasFeature(QSqlDriver::DriverFeature::Transactions);
问题分析 问题一
Qt连接MySQL报 “QMYSQL driver not loaded” 错误很明显就是MySQL驱动的问题。之前在 Qt 5.9.6 中也遇到了驱动未加载的问题，在按该文章 【问题记录】Qt连接MySQL报 QMYSQL driver not loaded 错误！进行操作时，还是不能解决，因为使用的Qt版本不同，所以对MySQL的驱动要求也会有所改变。 问题二
Qt 5.15.2 应该支持MySQL数据库的事务操作，但具体的支持取决于所使用的数据库驱动程序和数据库引擎。以下是一些可能的原因，导致在 Qt 5.15.2 中无法对MySQL数据库进行事务操作的情况： 使用不支持事务的数据库引擎：某些数据库引擎（例如MySQL的MyISAM）不支持事务操作。如果在这些引擎上创建表格，那么无论您使用什么版本的Qt，都无法进行事务操作。确保使用的是支持事务的数据库引擎，如InnoDB。使用不正确的数据库驱动程序：Qt 使用不同的数据库驱动程序来连接到各种数据库。如果使用的数据库驱动程序不正确或不支持事务操作，就可能会遇到问题。使用确保选择了适当的数据库驱动程序，如QMYSQL。Qt 编译问题：在某些情况下，Qt 库可能未正确编译或配置以支持数据库的事务操作。确保使用的 Qt 5.15.2 版本已经正确构建并包括 SQL 模块。 总结
根据上面的情况进行分析，可以肯定这类问题的解决办法得从MySQL驱动上进行下手，但MySQL官网提供的最新驱动已经在2017年就停止更新了并且不支持当前Qt 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c96375b4d59717d9139a6e30463dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b5a8e1e596f4cf28b17d6ab1d3c25a/" rel="bookmark">
			C语言基础（将持续更新版，接受提问，共同进步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断题
1、C 语言是面向对象的程序设计语言。F（--面向过程）
2、C 程序是由函数组成的。T（--基本组成单位是函数）
3、C 程序中的注释相当于空白字符。T
4、C语言源程序文件通过了编译、连接之后，生成一个后缀为.EXE的文件。T
5、C编译器可以找出C源程序中所有的语法错误和逻辑错误。F（--只能找出语法错误）
6、C语言的标识符由字母、数字和下划线组成，其中第一个字符必须是字母或下划线。T
选择题
1、结构程序设计的三种结构是 ▁▁▁▁▁。（顺序、选择（分支）、循环）
2、默认C语言源程序文件的扩展名为.c，它需要经过（ ）后才能变为可执行的.exe文件。（编译、连接）
3、开发一个C程序的一般过程是（ ）（编辑、编译、连接和执行）
4、C语言是一种结构化语言，是因为（ ）（C语言用函数作为程序的模块单位，以函数为模块组织程序，还具有结构化的控制语句，如if语句、while语句、for语句等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc3452b2130df695a0f6ea4209e394e/" rel="bookmark">
			摘桃子（YOJ2.0中的题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜猜看我们老师给这个题的标签是啥
递归回溯
而且难度还是在所有题中最难的（名义上，难度最高是6），刚开始我是想用递归来解的，虽然猴子是从下往上爬，但是从上往下递归解也是可以的
然后我就感觉不对劲了，这不是可以用动态规划来秒杀吗？
从最底下往上一层的那一层开始算，从第一个数开始，加上下面一层可能到达这个位置的两个数中最大的那一个（这样到达这个数的时候，这个位置的数就是一定要到达这个位置的路径中最大的），然后一直运算到最后一个，接着上一层一样逻辑的运算
到了最高一层就是最大的那个数（可以用例子试一下）
这不比递归的计算量低得多？
代码如下：
#include&lt;stdio.h&gt; int main(void) { int n; scanf("%d", &amp;n); int tree[n][n]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= i; j++) scanf("%d", &amp;tree[i][j]); for(int i = n - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) tree[i][j] += (tree[i + 1][j] &gt; tree[i + 1][j + 1]) ? tree[i + 1][j] : tree[i + 1][j + 1]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc3452b2130df695a0f6ea4209e394e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c73bb6c95de5c98c7f0b92afc66d61d/" rel="bookmark">
			Chrome浏览器设置跨域—Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows11
本地项目运行起来后，接口请求提示跨域。
方案： 对Chrome 进行设置
1、对桌面上的Chrome快捷方式进行复制，粘贴到桌面文件夹（或其他文件夹）
2、右击 属性 在 后面，空一格 ，添加下面的配置
--user-data-dir="C:/Chrome dev session" --disable-web-security 我这边 原来的内容是：
"C:\Program Files\Google\Chrome\Application\chrome.exe" 配置完后是：
"C:\Program Files\Google\Chrome\Application\chrome.exe" --user-data-dir="C:/Chrome dev session" --disable-web-security 3、配置完后，应用一下，确定。
4、然后打开这个修改过配置的Chrome快捷方式，就可以实现跨域请求了。
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209f6c18b1e49af869302fb0f3d6a17a/" rel="bookmark">
			Python代码加密防反编译的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一门强大而受欢迎的编程语言，但它也容易受到不法分子的攻击，其中一种攻击方式就是反编译。反编译是将Python代码还原为人类可读的形式，从中获取敏感信息或者滥用代码的过程。为了保护你的Python代码不被反编译，你可以采取一些有效的方法，本文将介绍一些常见的Python代码加密和反编译防护方法。
1. 使用字节码编译
Python的源代码可以轻松地转化为字节码文件（以.pyc扩展名结尾），这些字节码文件通常比源代码难以阅读。你可以使用Python的`compileall`模块来编译你的源代码文件，将其转化为字节码文件。这不仅使代码不易读取，还可以提高执行速度。
```python
python -m compileall my_script.py
```
尽管字节码文件不是完全安全的，但它们对于一般用户来说是相对难以理解的。
2. 密码保护
你可以使用密码来保护你的Python脚本，确保只有知道密码的人能够运行它。有一些第三方库，如`pycryptodome`，可用于加密和解密数据。你可以使用这些库来加密你的代码或关键部分，并在运行时解密。
```python
from Crypto.Cipher import AES
def encrypt(text, password):
cipher = AES.new(password, AES.MODE_EAX)
ciphertext, tag = cipher.encrypt_and_digest(text)
return ciphertext, cipher.nonce, tag
```
这种方法虽然有效，但要确保安全地管理密码以防泄漏。
3. 使用编译器
一些第三方工具可以将Python代码编译成二进制可执行文件，这可以有效地隐藏代码并防止反编译。一些流行的工具包括PyInstaller、cx_Freeze和Nuitka。这些工具将Python解释器和你的代码打包成一个可执行文件，使代码更难以分析和反编译。
4. 混淆代码
代码混淆是通过修改代码的结构和逻辑来使其更难以理解的过程。混淆工具可以重命名变量、函数和类名，删除或添加冗余代码，以及进行其他操作，从而增加代码的复杂性。这不会改变代码的功能，但会增加反编译的难度。
5. 使用代码保护服务
一些第三方服务和工具专门用于保护Python代码免受反编译的威胁。这些服务通常提供加密、混淆和其他安全功能，以帮助你的代码更难以分析。
保护Python代码免受反编译的威胁是一项重要任务，尤其是对于包含敏感信息或关键算法的应用程序。尽管无法绝对保证代码的安全性，但结合上述方法可以大大降低反编译的风险。选择适合你的项目的方法，并采取额外的安全措施，以确保你的Python代码免受恶意攻击。最重要的是，定期审查和更新你的安全策略以应对不断演进的威胁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f119c9f18fc23ad9a64eecf405d6cc4b/" rel="bookmark">
			leetcode1658. 将 x 减到 0 的最小操作数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）
知道滑动窗口，代码却写不出来
#define MIN(a ,b) ((a) &lt; (b) ? (a) : (b)) int minOperations(int* nums, int numsSize, int x) { int ans = INT_MAX; int sum = 0; for (int i = 0; i &lt; numsSize; i++) { sum += nums[i]; } if (sum &lt; x) { return -1; } int left = -1; int right = 0; int lsum = 0; // left为-1，左边数组为空，前缀和为0 int rsum = sum; // right为0，右边选中整个数组，后缀和为数组和sum while (left &lt; numsSize) { if (left !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f119c9f18fc23ad9a64eecf405d6cc4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde748bd3a95fdea5e021b9c250f671e/" rel="bookmark">
			内核驱动模块分布编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核驱动模块代码
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/ioctl.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include "fsmp157a_led_head.h" unsigned int *vir_gpioe_moder; unsigned int *vir_gpioe_odr; unsigned int *vir_gpiof_moder; unsigned int *vir_gpiof_odr; unsigned int *vir_rcc; char kbuf[128] = ""; //封装操作方法 //int (*open) (struct inode *, struct file *); //ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); //ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); //int (*release) (struct inode *, struct file *); //long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); int mycdev_open(struct inode *inode, struct file *file) { int min = MINOR(inode-&gt;i_rdev); file-&gt;private_data = (void *)min; printk("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde748bd3a95fdea5e021b9c250f671e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7dbc322375e612cd7e65d1ddce1507/" rel="bookmark">
			【计算机网络互联网边缘部分，核心部分】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 边缘部分1. 个人计算机和智能手机2. 路由器3. 服务器 核心部分1. 网络骨干2. 互联点3. 协议和标准 互联网的重要性 边缘部分 边缘部分是指互联网的端点，包括个人计算机、智能手机、路由器、服务器等设备。这些设备连接到互联网，允许用户访问网络上的资源。以下是边缘部分的关键组成部分：
1. 个人计算机和智能手机 个人计算机和智能手机是互联网的最常见终端设备。它们通过各种应用程序和浏览器允许用户访问网页、发送电子邮件、进行社交媒体互动等。
2. 路由器 路由器是将本地网络连接到互联网的关键设备。它们负责将数据包从本地网络发送到互联网，并将来自互联网的数据包路由到正确的设备。
3. 服务器 服务器是存储和提供网络上内容的设备。它们托管网站、应用程序和数据，使其可供全球范围内的用户访问。
核心部分 核心部分是互联网的基础设施，它包括大量的网络设备和连接，确保数据在全球范围内流动。以下是核心部分的关键组成部分：
1. 网络骨干 网络骨干是高速、高容量的网络链路和路由器的集合，它们连接世界各地的网络。这些网络骨干设备允许大规模数据传输，确保全球互联网的稳定性和可靠性。
2. 互联点 互联点是不同网络之间连接的关键位置。互联点允许不同的互联网服务提供商互相交换数据，确保数据能够跨越不同网络传输。
3. 协议和标准 互联网的核心部分还涉及一系列协议和标准，如TCP/IP协议套件、BGP路由协议等。这些协议和标准确保不同设备和网络之间的互操作性。
互联网的重要性 互联网的边缘部分和核心部分共同构成了现代互联网生态系统。边缘部分允许个人和组织访问和共享信息，而核心部分则确保了信息在全球范围内的流动。互联网已经成为我们日常生活和商业活动的重要组成部分，它促进了全球交流、创新和经济增长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2221d0042830a577e6f6e2e3653d9e7a/" rel="bookmark">
			京东JD开放平台API接口调用采集商品详情数据获取商品规格信息、销量、卖家信息抓取案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东JD商品详情API接口的作用和重要性主要体现在以下几个方面：
提供详细信息：商品详情API接口可以获取到商品的完整详细信息，包括商品名称、价格、图片、描述、规格、库存等。这些信息对于用户来说是购买决策的重要依据，帮助他们了解商品的特性和性能。优化用户体验：通过商品详情API接口，开发者可以在自己的应用或网站中展示商品的详细信息，提供给用户更好的浏览和购买体验。用户可以通过查看商品详情，快速了解商品的特点和优势，减少购买过程中的疑虑。支持购买决策：商品详情API接口能够提供商品的评价和评论等信息，用户可以根据其他用户的反馈来判断商品的质量和性价比，从而做出更准确的购买决策。竞品分析和市场研究：商品详情API接口可以获取到商品的销售数据，比如销量和评价等信息，开发者和商家可以通过分析这些数据进行竞品分析和市场研究，了解市场需求和消费者喜好，以制定更有效的销售策略。推广和营销：通过商品详情API接口，开发者可以获取到商品的宣传素材和营销信息，如商品图片和描述等。这些素材可以用于展示和推广商品，吸引更多的用户关注和购买。 总的来说，京东JD商品详情API接口在电商平台和购物应用中的作用非常重要。它提供了获取商品详细信息的能力，帮助用户了解和选择合适的商品，同时也支持开发者进行竞品分析、市场研究和推广营销等工作，以提高用户体验和促进销售增长。
jd.item_get-获得JD商品详情 公共参数
请求地址: 注册调用key请求接入API接口
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 请求参数
请求参数：num_iid=10335871600
参数说明：num_iid:JD商品ID
url:京东域名[非item.jd.com需传]
(npcitem.jd.hk:京东国际,item.jkcsjd.com:京东大药房)
响应参数
Version: Date:
名称类型必须示例值描述 items
items[]0获得JD商品详情 num_iid
Bigint029186819959商品ID title
String0MOCO2018夏季新品时尚V领条纹连衣裙 摩安珂 蓝白条色 S商品标题 desc_short
String0商品简介 price
Float0719.0价格 total_price
Float00 suggestive_price
Float00 orginal_price
Float01199.00原价 nick
String0MO&amp;Co.官方旗舰店掌柜昵称 num
Int0999 min_num
Int00 detail_url
String0http://item.jd.com/29186819959.html商品链接 pic_url
String0//img14.360buyimg.com/n0/jfs/t22033/147/1051007175/85125/c44dd0df/5b1f2855Ncbe35858.jpg商品图片 brand
String0品牌名称 brandId
Int0品牌ID rootCatId
Int01343顶级分类ID cid
Int09719 crumbs
Mix0[] created_time
String0 modified_time
String0 delist_time
String0 desc
String0 desc_img
Mix0[] item_imgs
Mix0[{ "url": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2221d0042830a577e6f6e2e3653d9e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7e4272f412239ec6f8f6007b06af7a/" rel="bookmark">
			八股文 链接大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端面试八股文（超详细）_javascript_小泽今天早睡-华为云开发者联盟 (csdn.net)
🔥 连八股文都不懂还指望在前端混下去么 - 掘金 (juejin.cn)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/103/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>