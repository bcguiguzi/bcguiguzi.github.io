<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2a185e20081732b32d13d69d465573/" rel="bookmark">
			拟合与估计问题中的鲁棒方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一般的拟合与估计算法中，一般均假设测量数据点误差来源仅发生在对该点的位置测量，并服从高斯分布(如最小二乘)。实际情况中，普遍存在一些测量数据点的数值由于前级测量失效、突发干扰等原因而严重偏离真实值。这些测量数据点对于高斯(或其他类型)误差分布来说是外点(outlier)，或称错误点。即使外点的数量极少，但由于其数值很大，故若使用一般线性估计方法，得到的估计值会由于少数的扰动而与真实值有极大的偏差。因此，必须使用某种方法识别外点，并在拟合估计运算前进行剔除。本文介绍常用的三种方法：RANSAC方法、M-估计、最小中值估计。此外还有最大后验RANSAC方法数学理论较复杂，详情请参阅文献1 由于鲁棒算法均为尝试型算法，在具体实现中需要将拟合估计算法包裹起来作为内循环，以估计的偏差大小控制外循环的算法流程及终止条件。
RANSAC方法 对于一般模型 M 和给定的测量数据点集 D，RANSAC估计模型参数 p 的步骤如下： 1. 设估计模型参数 p 所需的最小数据点数为 n 。由 n 个数据点组成的子集称为模型 M 的一个样本； 2. 从数据点集 D 中随机抽取一个样本 J ，由该样本计算模型的一个实例 Mp(J)，确定与 Mp(J) 之间几何距离小于阈值 t 的数据点所构成的集合，称为实例 Mp(J) 的一致集，记为 S(Mp(J)) ； 3. 经过 K 次随机抽样，选择数据点的个数 #S(Mp(J))最大的一致集 S(Mp(J)) ，用 S(Mp(J)) 重新估计模型 M ，最后输出结果
几点说明:
选择抽样次数K的依据是以某个极大的概率(如0.98)抽到不含外点的好样本，可通过K的期望和标准差估计得到。每个样本需要的数据点个数越少，所需抽样次数越少(指数级)。 理论上，希望选择距离阈值t使得内点被接受的概率是 α，这在实践中是非常困难的，需要知道内点到模型之间几何距离的概率分布。故通常由经验选取。 终止条件一般使用内点比例 w 、正确概率αf估计一个抽样次数，如果一致集大小相当于数据集的内点规模则终止。正确概率一般人工指定，内点比例采用自适应算法，初始时给出一个最保守(悲观)的内点比例估计，并由此确定抽样次数，在抽样过程中，一旦发现更大的内点比例，则按新比例更新该抽样次数。该算法保证了抽样次数，并且一定终止，是一种值得推荐的算法。在OpenCV中，函数SolvePnPRansac findHomography内部调用了RANSACPointSetRegistrator类进行RANSAC解算，详见这篇博客
此外还有改进的PROSAC2方法，将点初始集匹配的结果作为排序的依据，使得在采样时根据匹配结果由高到低的得分进行排序，这样最有可能得到最佳参数的采样会较早出现，提高了速度。
M-估计 在M-估计中，对残差进行饱和函数运算，限制单个数据点对于误差函数的影响力。其思想类似于L1的稀疏性。 使用的函数称为M-估计子，如通常使用的Huber估计子为 ρ(t;σ)={t2σ2|t|&lt;σ|t|&gt;=σ 在残差较小时取值为残差的平方，残差较大时取一个常值的平方。 另一些选择 ρ(t;σ)=t2t2+σ2 ρ(t;σ)=⎧⎩⎨⎪⎪t2σ|t|0|t|&lt;σσ&lt;=|t|&lt;3σ|t|&gt;=3σ 最后这个估计子当残差较大时，被认为是错误的，在估计中不起作用。这是设置估计子是比较合理的，然而使得求解变为非凸优化，较难。 最小中值估计 最小中值方法通过求解下述最小化问题来估计模型参数 Min Median{|r2j(xj,p)|} 与RANSAC相比，不采用一致集内点的个数来衡量样本的好坏，而是根据样本，计算所有数据点到样本的偏差，以偏差的中位数衡量样本好坏，从而避免了使用划分内点和外点距离阈值的先验知识。缺点是，要求错误数据点必须小于50%才能取得正确结果。 当数据测量误差符合高斯分布时，最小中值方法的效率非常差。 吴福朝.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2a185e20081732b32d13d69d465573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ef94f9ab06a742cdbb8f32abab1be3/" rel="bookmark">
			PHPStorm 常用的 License Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 Licence Server 激活 需要搭建激活服务器，也可以使用别人搭建好的，但是不一定什么时候就被封杀了。可用的有：
http://www.aku.vn/idea http://idea.iteblog.com/key.php http://idea.imsxm.com/ http://www.linkvip.info/idea http://idea.ibdyr.com http://www.activejetbrains.gq
可以用源码自己搭建：https://github.com/springhack/JetBrains-License-Server
通过注册码 Activation Code 激活 这个 网站 提供注册码的获取。点击“获得注册码”并复制，然后在激活时切换至Activation Code选项，输入注册码，便可以注册成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f8b1a83e40624eb3db1c654ddcc926/" rel="bookmark">
			[C&#43;&#43;] 变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量 变量定义的基本形式：首先是类型说明符，随后紧跟着一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。
对象（变量）是具有某种数据类型的内存空间。
列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。
在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。
初始化与赋值 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
初始化形式 int i = 0; int i = {0}; int i(0); int {0}; 对于内置类型，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。（e.g.比如存在类型转换时，double to int）。
默认初始化 内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0,。定义在函数体内的内置类型将不被初始化，一个未被初始化的内置类型变量的值是未定义的。试图拷贝或以其他形式访问该类型将引发错误。
如果要求显示初始化则类的构造函数使用explicit关键字。
如果类的对象没有显示初始化，则其值由类确定。
变量声明与变量定义 为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。
变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
变量能且只能被定义一次，但是可以被多次声明。
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。
注意：在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
extern int i = 0;　// definition int iy;　// definition extern int j;　// declaration 标识符 C++标识符由字母、数字、下画线组成，其中必须以字母或下画线开头，标识符长度没有限制，但是对大小写字母敏感。
变量命名规范 C++中关于变量命名的规范：
1：能体现变量的实际意义
2：变量名一般采用小写字母
3：用户自定义变量名可以以大写字母开头
4：多个单词定义的变量名应有区分Student_loan 而不是 Studentloan
名字的作用域 作用域是程序的一部分，在其中名字有其特定的含义。
同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。
全局作用域
块作用域
嵌套作用域：作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。
如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。
Tips： 1、变量使用之前需要先定义声明。
2、如果在定义变量时没有指定初始值，那么变量会被默认初始化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f8b1a83e40624eb3db1c654ddcc926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ae2aae5eb5c8aedeea3f2f5c82cfb8/" rel="bookmark">
			数据结构-二路归并及归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍： 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 该算法的核心思想是二路归并。
二、二路归并介绍 &lt;1&gt;在归并的过程中步骤如下： ①设定两个指针（不一定非是指针，只需要记住对应开始下标即可），最初位置分别为两个已经排序序列的起始位置； ②比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； ③重复步骤3直到某一指针达到序列尾； ④将另一序列剩下的所有元素直接复制到合并序列尾； &lt;2&gt;例如：将a1,a2两个有序数列合并为一个序列。 void Merge(int* a1, int a1size, int* a2, int a2size, int* res) { //合并两个有序序列a1 a2 结果保存在res数组中 int a1_index, a2_index, res_index; a1_index = a2_index = res_index = 0; while (a1_index &lt; a1size &amp;&amp; a2_index &lt; a2size) { if (a1[a1_index] &lt; a2[a2_index]) res[res_index++] = a1[a1_index++]; else res[res_index++] = a2[a2_index++]; } //将a1或a2剩余部分插入到res while (a1_index &lt; a1size) res[res_index++] = a1[a1_index++]; while (a2_index &lt; a2size) res[res_index++] = a2[a2_index++]; } int main() { int a1[] = { 2,3,5 }; int a2[] = { 2,9 }; int a1size = sizeof(a1) / sizeof(a1[0]); int a2size = sizeof(a2) / sizeof(a2[0]); int a3size = a1size + a2size; int* a3 = new int[a3size]; Merge(a1, a1size, a2, a2size, a3); for (int i = 0; i &lt; a3size; i++) cout &lt;&lt; a3[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ae2aae5eb5c8aedeea3f2f5c82cfb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dac135cd9d820001f59754621536117/" rel="bookmark">
			LD_LIBRARY_PATH shouldn&#39;t contain the current directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置：
[root@localhost build]#../configure --prefix=/opt/glibc-2.17 错误提示：
l * LD_LIBRARY_PATH shouldn’t contain the current directory when * building glibc. Please change theenvironment variable * and run configure again.
解决方法：
删除LD_LIBRARY_PATH变量的内容
[root@localhost build]# echo $LD_LIBRARY_PATH :/opt/glibc-2.14/lib:/opt/glibc-2.17/lib [root@localhost build]# LD_LIBRARY_PATH= 编译安装成功后重新添加 LD_LIBRARY_PATH:
vim /etc/profile export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/opt/glibc-2.14/lib:/opt/glibc-2.17/lib //wq 保存退出，使之生效 source /etc/profile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5054462a2df4598c4203b9afe056b98/" rel="bookmark">
			CentOS重启ssh服务命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOs 重启ssh服务的命令如下：
# service sshd restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd48c215bed292cabf8d7092f0cc8643/" rel="bookmark">
			StringUtils工具类常用方法汇总2(截取、去除空白、包含、查询索引)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇中总结了StringUtils工具类在判断字符串为空，大小写转换，移除字符或字符序列，替换，反转，切割合并等方面的方法，这次再汇总一下其它常用的方法。
一、截取 StringUtils中常用的截取字符串的方法如下：
substring(String str,int start) substring(String str,int start, int end) substringAfter(String str,String separator) substringAfterLast(String str,String separator) substringBefore(String str,String separator) substringBeforeLast(String str,String separator) substringBetween(String str,String tag) 需要注意的是，截取字符串时，若被截取的字符串为null或""，则截取之后的返回的字符串也为null和""。
（1）根据指定位置截取字符串，当指定的截取位置为非负数时，则从左往右开始截取，第一位为0，后面依次类推，但当索引值为负数时，则从右往左截取，注意此时右侧第一位为-1：
a）只指定了起始位置，则截取至字符串末尾：
StringUtils.substring(null, 2); // "" null和""截取后都返回null和"" StringUtils.substring(null, 2); // null StringUtils.substring("china", 0); // china 指定的起始截取位置为0，则从第一位开始截取，也就是不截取 StringUtils.substring("china", 2); // ina 指定的截取位置为2，则从左往右第三位开始截取 StringUtils.substring("china", -2); // na 指定的截取位置为-2，则从右往左第二位开始截取 b）指定了起始位置和结束位置，则从起始位置开始截取到结束位置（但不包含结束位置）：
StringUtils.substring(null, 2, 4); // null null和""截取后都返回null和"" StringUtils.substring("", 2, 4); // "" StringUtils.substring("china", 0, 0); // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd48c215bed292cabf8d7092f0cc8643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf365460793563b4212d3ec11d1db03/" rel="bookmark">
			最大流的Ford-Fulkerson 标号法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最大流标号法：
https://wenku.baidu.com/view/5977dc6fa45177232f60a266.html
最大流的标号法总的来说就是不断地在图中找增广路径。增广路径就是一条从源点到汇点的路径，所有前向边都是非饱和边，反向边都是非零边
http://blog.csdn.net/fengchaokobe/article/details/7584781
在这节中，我将描述一种构造所有增广路径算法的方法，这种方法是由Ford and Fulkerson在1956年发明的。
增广路径是找出在残留网络中从源点到汇点的有向路径。增广路径的残留容量是路径中任意边所形成的最小残留容量。显然，我们可以沿着增广路径从源点到汇点发送额外的流。
假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量 &lt; 容量。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路径。
所有的增广路径算法的构造是基于增广路径定理的：
定理一(增广路径定理)：流x是最大流当且仅当这个残留网络不包含其他增广路经。
由这个定理我们得到一种找到最大流的方法。这种方法通过在所有路径中不断地找出增广路径和增广流，直到网络中不在包含这样的路径。我们要讨论的一些算法，它们所不不同的只是寻找增广路径的方法。
我们认为最大流问题基于以下假设：
假设一：这个流网络是一个有向网。
假设二：网络中的所有容量都是非负整数。
附注：这个假设对于某些算法不是必须的，这些算法的复杂边界涉及到数据的完整性。
假设三：这个问题有一个最佳解决方案，且这个方案是有界的。
附注：这个特定的假设意味着从源点到汇点是有容量限制的路径。
假设四：这个网中不包含平行的弧。
附注：这个假设的规定不失一般性，因为我们可以总结出所有平行弧的容量。
两个while循环，内部的while循环就是在当前的残余网络种找增广路径，外部的while就是在每找到一条增广路径后，就更新图，然后继续找
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 10010 #define INF 0xfffffff struct ArcType { int c,f;//容量、流量 }; ArcType edge[maxn][maxn]; int n,m;//顶点数、弧数 int flag[maxn];//顶点状态：-1——未标号；0——已标号未检查；1——已标号已检查 int pre[maxn];//标号的第一个分量：指明标号从哪个顶点而来，以便找出可改进量 int alpha[maxn];//标号的第二个分量：可改进量α int que[maxn];//相当于BFS中的队列 int v;//队列头元素 int qs,qe;//队首队尾的位置 int i,j; void ford()//标号法求网络最大流 { while(1)//标号，直到不存在可改进路 { memset(flag,-1,sizeof(flag)); memset(pre,-1,sizeof(pre)); memset(alpha,-1,sizeof(alpha)); flag[0]=0; pre[0]=0; alpha[0]=INF; qs=qe=0; que[qe]=0;//源点0入队列 ++qe; while(qs&lt;qe&amp;&amp;flag[n-1]==-1) //不断找增广路径，类似与Dinic算法，其实这里是边BFS分层边找增广路径，而Dinic是先BFS分层在找增广路径 { v=que[qs];//取队首元素 ++qs; for(i=0; i&lt;n; ++i)//检查顶点v的正向和反向邻接点 if(flag[i]==-1) { if(edge[v][i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf365460793563b4212d3ec11d1db03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87899a5bad661c421291087e9d79dc1/" rel="bookmark">
			【C&#43;&#43;】两个字符串相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：
Given two binary strings, return their sum (also a binary string). For example, a = "11" b = "1" Return "100". 思路：
思路：对于两个string a，b从后往前取值，若取值为空则赋值为0.设置进制符号flag； 若a[i]+b[i]+flag == 3 则 c[i]=1 flag =1;若a[i]+b[i]+flag == 2 则 c[i]=0 flag =1; 若a[i]+b[i]+flag == 1 则 c[i]=1 flag =0;若a[i]+b[i]+flag == 0 则 c[i]=0 flag =0; 代码如下：
string addBinary(string a, string b) { int lenA = a.size(); int lenB = b.size(); int lenC = lenA&gt;lenB?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87899a5bad661c421291087e9d79dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d47ea670887e8fb21b93006709dc27/" rel="bookmark">
			validateJarFile  jar not loaded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题代码：
十二月 01, 2017 11:05:13 上午 org.apache.catalina.loader.WebappClassLoader validateJarFile
信息: validateJarFile(F:\ProgramDemo\shop\out\artifacts\shop_war_exploded\WEB-INF\lib\servlet-api.jar) - jar not loaded. See Servlet Spec 2.3, section 9.7.2. Offending class: javax/servlet/Servlet.class
问题发现：
web项目的lib中已经存在servlet-api.jar，而在tomcat中的也存在servlet-api.jar；两个包相互冲突。
问题原因：
当在项目中启动tomcat时，
首先加载的是：Tomcat_HOME/lib目录下的jar包，也就是F:\Software\apache-tomcat-6.0.43-windows-x64\apache-tomcat-6.0.43\lib这个目录下的jar包。
其次加载的是：Tomcat_HOme/shop/webroot/lib目录下的jar包，也就是F:\ProgramDemo\shop\WebRoot\WEB-INF\lib这个目录下的jar包。
问题解决：
把项目lib中的servlet-api.jar包删除掉，然后就解决了bug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114a028b0955ea0608d58ca6963e1f1f/" rel="bookmark">
			Window.location.href以post方式传递参数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：http://colddemon.iteye.com/blog/1608132
想用window.location.href跳转到另外一个界面。但直接传递get方法会暴露数据。 而用ajax或表单提交，有时在执行了方法后，无法跳转到另外的页面。 下面可以实现跳转的效果，却又能够通过post传递方法隐藏数据。 有一个不足就是，在跳转到新页面后，点击“返回”返回的是个空界面，再次点击才能返回到提交界面。 其原意就是在页面上构造表单然后向后端 提交数据达到post请求方式，
如下
function selectThis(agentNo) { //window.location.href = contextPath+'/getAgentPosImportStatementListWithPaging.jhtml?agentNo='+agentNo; document.write("&lt;form action=getAgentPosImportStatementListWithPaging.jhtml method=post name=form1 style='display:none'&gt;"); document.write("&lt;input type=hidden name=agentNo value='"+agentNo+"'/&gt;"); document.write("&lt;/form&gt;"); document.form1.submit(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d9953f4b4976bb7983bb1eaeff585a/" rel="bookmark">
			在VMware虚拟机中安装CentOS 7（图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 VMware简介：
VMware是一个虚拟PC的软件，可以在现有的操纵系统上虚拟出一个新的硬件环境，相当于模拟出一台新的PC，以此来实现在一台机器上真正同时运行两个独立的操作系统。
VMware的主要特点：
不需要区分或重新开机就能在同一台PC上使用两种以上的操作系统；本机系统可以与虚拟机系统网络通信；可以设定并且随时修改虚拟机操作系统的硬件环境。 二、CentOS简介：
CentOS（Community ENTerprise Operating System）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。
三、CentOS的安装：
虚拟机版本：VMware Workstation_10.0.3
Linux系统版本：CentOS_7（64位）
物理机版本：Win 7旗舰版
注：本人为初学者，在虚拟机上安装CentOS，方便同时在Win7上操作以及和物理机进行通信；等操作熟练之后可以装双系统。
1、虚拟机的创建：
打开安装好的VMware （如果大家安装的VMware是英文版的也没关系，对号入座即可），选择“文件---&gt;新建虚拟机”，如图：
这里选择“自定义”，下一步：
或者选择“典型”，下一步：
选择默认，下一步：
选择“第三项“稍后安装操作系统”，以后安装，方便进行配置。下一步：
（注：上图中，第一项是用光盘安装，第二项是用硬盘里的ISO镜像安装）
上图指的是，打算在虚拟机中模拟一个怎样的操作系统，这里选择Linux，Version里选择CentOS 64位，下一步：
自定义自盘大小或者默认磁盘大小。下一步：
自定义硬件：
输入虚拟机名称（可以随便起），选择镜像文件存放的路径。下一步：
选择给虚拟机分配的cpu核的数量，如果为虚拟机选择的cpu数超过本机实际cpu数量，VMware会给出警告。这里选择默认即可。下一步：
注：虚拟内存分配，一般选默认的1024MB就行（注：给虚拟机分配的内存不能超过物理 内存的一半，而且稍后如果想要使用图形界面安装CentOS，至少要分配628M的内存）。
这里选择桥接，确定：
注：这里是网络类型分配，网络类型分配分为三种，Bridge，NAT和Host-Only，大概区别是
1 BRIDGE:相当于主机和虚拟机连接到同一个hub上，虚拟机要和主机配置到同一网段上
2 NAT:使用vmnet8，主机开启必要的VMware服务，如vmvare dhcp，虚拟机设置成dhcp方式即可，当然也可以手工设置成vmnet1同一网段，比较麻烦
3 HOST-ONLY：使用vmnet1，直接和主机互联，可以使用ifconfig查看配置情况
创建完成，确认虚拟机信息（其实以后也可以修改），点“完成”即可。出现了下面的界面：
这就是我们虚拟出来的一台计算机，上方红框中，可以看到虚拟机的硬件信息，也可以进行修改，或者点击菜单栏“虚拟机---&gt;设置”，也可以对硬件配置进行修改。
2、安装CentOS镜像：
首先需要加载CentOS镜像。选择“虚拟机---&gt;设置”：
点击”CD/DVD(IDE)”,打开虚拟机光盘设置页面，点击”使用ISO镜像文件”,选择待安装的ISO镜像文件。就是刚刚下载的CentOS-7.0-1406-x86_64-DVD.iso文件。点击“确定”：
然后点击”开启此虚拟机“，启动虚拟机。
之后出现如下界面：
界面说明：
Install CentOS 7 安装CentOS 7
Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d9953f4b4976bb7983bb1eaeff585a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea6363e72785ed3b51faba2d33c23e4/" rel="bookmark">
			idea中如何给类中的属性生成set和get方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作：鼠标右键--&gt;Generate--&gt;Getter and Setter--&gt;完成
1.类创建完属性后
2.鼠标右键，选择Generate
3.选择Getter and Setter
4.选择需要添加set/get方法的属性
5.点击OK即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012569ac529cf7c2a06ebf7148f36fd8/" rel="bookmark">
			项目管理心得分享九点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目管理心得分享
在过去的职业生涯中，我参与且Leader过不少项目。这些项目中有成功也有失败，回想起来项目中经历的痛苦给了我很多收获。把痛苦后的感悟和经验总结一下，提醒自己避免在今后的项目历程中重蹈覆辙，也希望可以对大家有一些帮助。结合我的工作经验，目前所经历的都是企业内部的信息化项目，比如ERP系统、HR系统、信息安全体系等，此部分经验的总结与分享对您正在经历的项目是否适应，还请各位读者自行判断。
项目，尤其是涉及到用户日常工作的项目，一定是一个心路历程。
每个项目参与者和被影响者的心态，价值观以及情绪的变化比技术上的变化重要的多，对项目成败的影响也往往更大。因为事情终归是要人去做的，专家可以一夜之间解决所有技术问题，但是人的问题只能一点一滴逐步解决。
所以从项目开始到结束的过程中需要保持关注关键用户以及最终用户对项目和任务的看法，了解他们的心路变化，并且在需要的时候做适当应对或者项目修正。
期望所有人都有共同的价值观和奉献精神是不可能的
因此在项目开始前就需要得到关键用户和项目组成员直接主管的支持与共识，并且得到一定程度上的授权。同时，努力让用户清楚这个项目究竟会带来哪些改变？为什么要改变？有什么好处或者有什么坏处？能够学到什么？让参与者有真正的参与感，而不仅仅是被动的接受者。
细化项目任务
项目经理需要把每个目标每个任务都细化。尽管项目经理不一定完全懂得项目中所涉及的全部技术问题，但是他一定要能够联系到可用的资源，同时通过询问和调研将任务细化，然后再分配到每个人员身上去。这样，每个人要做的事情都很清晰（指的是每个阶段内的事情），每个细小的目标都会觉得很容易实现，并且不用担心自己没有涉及到的其他任务，因为我很清楚会有别人去做，而且他可以被信任。如果项目经理总是在High Level地讲问题，没有足够的细化，一方面会造成做事的人觉得任务无比艰巨，渐渐失去信心；另一方面会由于责任不清造成部门间的推诿和指责。
项目还是控制在自己手里更好
除非顾问公司的能力、经验和责任心都是可以完全信赖的，项目还是控制在自己手里更好。再强的项目经验和软件技术都没有对公司业务的了解更重要。掌控在手里，顾问公司也是资源。被顾问公司主导，想到使用这个资源的时候就得吵架。
遵守项目规则
项目开始时激情澎湃地定下的规矩，一定要遵守并且执行下去。不了了之，或者随意更改都将影响人的心态。这些规矩其实没有绝对的好与坏，但是坚持一定比随意得到的结果更好。
面对面的沟通是无法替代的
即便是通讯手段如此发达的时代，也一定不要忽略面对面沟通的重要，因为只有在面对面的时候我们才能真实地感受到对方的情绪、情感以及语言背后的内容。很多时候在电子邮件、微信甚至电话中的表达都是经过修饰的，或者是被剥离感情的。
项目进度公示
所有项目涉及到的部门，就算不是核心部门。也一定要让他们了解项目的进度，尤其是将要对他们产生的影响。人都不喜欢被招之即来挥之即去。
重视数据
无论任何信息系统，数据都是最重要，最核心的，而不是流程。
每个系统都有n多的公司在使用，即便是流程的定制也不离其宗。但是你的数据只对你自己有用，而且是独一无二的。数据一定要被重视，给出足够的时间提炼和整理。输入的是垃圾，输出的也一定是垃圾，流程和系统再好也没用。
增加员工参与项目的积极性
平时就要经常进行跨部门的合作，让大家习惯一起达成目标，而不是相互扯皮（这个无法避免，只能适当消除，但是很多时候部门之间的敌对程度甚至超过了竞争对手）。而且要奖励参加项目的人员，并且尽量让参加项目的人从日常工作中脱离出来。这一点大公司有着先天的优势，因为它储备的人力资源相对较多。参加项目的人学到新技能和知识，顶替他工作的人也学到新技能担负起新任务。所以员工都期望参加项目，而不是拒绝项目。
以上就是我的一些总结，跟通常的项目管理知识或许不太一样。不知道大家发现了没有，我的关注点几乎都是有关于人的。这也就说明在我的项目经历中，最痛苦感受都来自于人的因素，日光之下，并无新事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77799f626adabf14e48762f03801fcf/" rel="bookmark">
			RecyclerView使用时，解决Item显示不全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲的是item宽度显示不是父Layout宽度
1. 以下是问题代码 @Override public leftViewHolde onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(context).inflate(R.layout.layout_item_left, null); return new leftViewHolde(view); } 2.以下是解决问题后的代码 @Override public leftViewHolde onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(context).inflate(R.layout.layout_item_left, parent, false); return new leftViewHolde(view); } 关于LayoutInflater的讲解相关链接 LayoutInflater
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c60bc2c5cb49dbde12a56f9cb6bb66/" rel="bookmark">
			&#34;Lexical or preprocessor issue&#34;解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接手项目后，改变文件的位置，导致报错“Lexical or Preprocessor Issue ‘*.h’ file not found”。
原因：头文件路径Header Path没有设置好。Xcode Header Path的设置 Header Search Paths是一定会去搜索的。而User Header Search Paths只有在Always Search User Paths为Yes时才会被搜索。
解决：在Build settings里面搜索Search Paths,然后点击它，就会看到Always Search User Paths，将它后面No的设置为Yes。重新启动工程即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51eda29f09f52df87d856e61968bac0/" rel="bookmark">
			iPhone白苹果，刷机降级，无限重启，无限恢复模式，无限DFU模式，错误4013，错误3014...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iPhone刷机手稿 ［1］构造 iPhone = 硬件＋iOS系统＋用户软件 ［2］iOS刷机形式包含： 1. 手机DFU模式（彻底）＋ 刷机软件 ＋固件（iOS的Rom） 2. 手机恢复模式（只能升）＋ 刷机软件 ＋固件 ［2.1］刷机软件： &lt;Windows+MacOS&gt; iTunes（官方） https://www.apple.com/cn/itunes/download/ &lt;Windows&gt; 爱思助手 https://www.i4.cn/ 等等 ［2.2］固件下载： https://www.i4.cn/firmware.html ［选择可刷版本］ 需要选择手机名称，模具型号（例如在6p背后的A1524），目标iOS的版本 ［2.3］刷机模式的区别： DFU模式：（屏幕是全黑的）DFU的全称是Development FirmwareUpgrade,即iPhone固件的强制升降级模式，彻底。 恢复模式：（屏幕有显示）屏幕上会显示iTunes和数据线图标的模式， ------ iPhone恢复模式和DFU模式最大的不同在于是否启动了iBoot。在恢复模式下系统使用iBoot来进行固件的恢复和升级，而在DFU模式下系统则不会启动iBoot，所以你可以在DFU模式下进行固件的降级。 iBoot是iOS设备上的启动加载器，当你在恢复模式下进行系统恢复或者升级的时候，iBoot会检测你要升级的 固件版本，以确保你要升级的固件版本比当前系统的固件版本要新(版本号更高)。如果要升级的固件版本比 系统当前安装的固件版本要低的话，iBoot将会禁止固件的恢复。 所以要进行固件的降级就必须将设备切换到DFU模式下。这也就意味着如果你需要恢复当前的固件版本，只需 要将设备切换到恢复模式即可，iTunes会接管接下来的恢复工作;如果你需要将固件进行降级，就需要进入到 DFU模式下。 ［3］ 刷机流程 1.准备好固件，刷机软件，原装Lighting线，电脑一台 2.软件打开，手机关机，连接电脑 3.手机进入DFU模式 4.(1)在爱思助手里，导入下载好的固件，直接一键刷机 (2)在iTunes里，点击”取消“以外的各种弹出的按钮，直到看到一个固定的按钮“恢复”，请按着shift键，点击这个恢复按钮，就可以选择下载好的固件，后面简单的就不说了 ［3.1］成功的进入DFU模式： 1.手机关机 2.电脑打开Itunes 3.连接电脑和手机，显示一个电池图标（不是循环白苹果） 4.按开机键3秒不松开，同时按Home键＋开机键10秒（期间屏幕会熄灭） 5.松开机键保持Home，直到iTunes发现DFU的iPhone ［3.2］如何退出dfu模式： 开机键和HOME键一起按十秒左右，见到手机重启显示logo即可 ［3.3］如何退出iOS恢复模式 1. 最有效的方法是：使用爱思助手，手机连接电脑，在爱思助手里“退出恢复模式” 2. 或者简单的“开机键＋Home”10秒左右，手机自动重启即可 ［3.4］关闭循环白苹果，结束无限重启： 1.按开机3秒不松开 2.同时按Home键10秒，直到屏幕长灭 ［3.5］iTunes中如何选择本地固件： 1. windows中，使用“shift+恢复”，即按着键盘shift键，再点击“恢复”按钮 2. Mac OS中，使用“option+恢复”，就是alt那个键 更多： 升降级：....研究中，需要搭建什么验证服务器 越狱：.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51eda29f09f52df87d856e61968bac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f3b90ac0ccfce0567baa5f657451ea/" rel="bookmark">
			android TypedValue.applyDimension()的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个方法是转变为标准尺寸的一个函数，例如
int size = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, context.getResources().getDisplayMetrics());
这里COMPLEX_UNIT_DIP是单位，20是数值，也就是20dp。
本文转自java豆子博客园博客，原文链接：http://www.cnblogs.com/error404/p/3937449.html，如需转载请自行联系原作者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43235edd19b145e84a9bfab0ab7b9c98/" rel="bookmark">
			onclick时间动态传递参数，拼接字符串参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在传递参数的时候，首先要有正确的写法
onclick事件动态传递参数的话，则需拼接参数，如果书写错误则会报错误，在控制台可以看到错误
2、解决办法
正确的书写形式
3、还有一种传递参数的形式如下
传递方式可适应后端的get、post请求而选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3ad19b2db1f38db5d7750df56a22d0/" rel="bookmark">
			申请免费的腾讯云SSL证书，实现https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用QQ或者微信登陆腾讯云:https://www.qcloud.com 找到SSL证书申请选项：云产品---域名服务—SSL证书。
点击进入申请页面
点击立即使用开始申请
申请前，需要完成实名认证。可以使用已认证的微信进行辅助认证，很快就可以通过。
实名认证完成后，开始申请证书
填写域名资料：
1、通用名称就是你的域名
2、申请邮箱填写你的常用邮箱
3、证书备注名：填写一个易记的就行
4、私钥密码：可不填写
6、所属项目：默认项目即可
域名资料填写完成后，进入下一步，选择手动DNS验证。
将系统显示的CNAME解析值，解析到域名上。代解析完成后，点击自助诊断按钮，等待系统验证。
步骤阅读 申请通过后，进入SSL证书列表，将所申请的域名SSL证书下载到本地后，上传到你域名所在服务器即可
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/466/">«</a>
	<span class="pagination__item pagination__item--current">467/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/468/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>