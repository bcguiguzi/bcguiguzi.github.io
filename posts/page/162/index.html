<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097c954bab34aca62fbcd1c4d96c8ce2/" rel="bookmark">
			什么是Skia
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skia是一款跨平台的2D图形库，是Google公司开发的，可以用于开发各种应用程序，如浏览器、游戏、移动应用程序等。Skia引擎的主要特点是速度快、可移植性强、占用的内存少、稳定性佳，适用于多种硬件平台。
Skia的目标是提供快速、高效、可扩展的2D图形库，它支持多种颜色模式和平滑算法，同时也支持字体、文本渲染和图像扭曲。Skia的绘图引擎可以与多个图形API进行集成，包括OpenGL、Vulkan和Metal等，并提供了自己的软件渲染器和GPU渲染器。
Skia引擎可以在多个操作系统和平台上使用，包括Android、iOS、Windows、Mac OS X和Linux。它是许多Google应用程序的核心组件，例如Chrome浏览器、Android操作系统和谷歌地图等。
总而言之，Skia引擎是一款高效可靠的2D图形库，可以用于开发各种应用程序，具有出色的可移植性和扩展性，可以在多种硬件平台上使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6925e712e07660fa189a988af2b154/" rel="bookmark">
			关于 ant-design-vue a-table 表格的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文所用到的为 v1 版本的ant-design-vue 框架 操作栏通过 slot-scope 的属性 实现
&lt;a-table bordered :columns="headerArr" :dataSource="tableData" :pagination="pagination" :rowKey="res =&gt; res.indexId" :scroll="{ x: 1200 }" class="mb20"&gt; &lt;template slot="operationBtn" slot-scope="record"&gt; &lt;a @click="detailBtn(record)" &gt; 详情 &lt;/a&gt; &lt;/template&gt; &lt;/a-table&gt; { id: "10", checked: true, title: "操作", width: 120, fixed: "right", scopedSlots: { customRender: "operationBtn", }, }, 返回数据拼接处理 { id: "4", checked: true, title: "周期(天)", dataIndex: "back_cycle", width: 140, ellipsis: true, customRender:(test,record) =&gt; { return ( &lt;span&gt;{record.back_cycle}天&lt;/span&gt; ) } }, 返回字段为数组，进行循环展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6925e712e07660fa189a988af2b154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5938e439b44105376f12e29b80e6d8/" rel="bookmark">
			django开发小程序实现openid登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		侃后端django django是一个Python栈的重型框架，可以说web开发中遇到的相关技术栈在这个框架中都能找到身影，如果说要学习PythonWeb开发，自然是绕不开的存在，如果能再深入其源码内部窥视一番，那收获绝对满满，他的架构设计思路，各种插件机制的开发，以及眼花缭乱的函数式装饰器，类装饰器等等的一些酷炫技巧，真的是让人不得不感叹一句，牛逼！
django+小程序 擦出爱情的火花 正式进入正题，实现微信小程序登录逻辑！首先我们需要搞清楚，微信小程序登录的一逻辑套路，如下图！
图：来自小程序官方文档
说明 调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key。 之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。
注意事项 会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次。 困惑 其实上边的图和文字都已经说的非常清楚，稍微有点概念的开发者基本上都可以读懂和看懂，但很多初学者却仍然是一脸懵逼，没有概念，什么开发者服务器，回传，换取code等等这些词汇搞懵逼了，其实代码很简单一看就，喔，原来这样啊的豁然开朗，那么就带你用代码解读上边那句话！
流程解读 前端通过wx.login() 就可以在返回值中拿到一个code也就是只能使用一次的那个code, 之后再在回调方法success()中将这个code，通过wx.request() 方法向django后端发起一个post请求，并携带这个code,这就是回传code到开发者服务器，之后在django后端构造的这个post请求中就可以获取到这个code,再携带微信小程序的appid和appsecret，向微信的这个 https://api.weixin.qq.com/sns/jscode2session 接口携带那几个参数发送get请求即可，如下所示！
https://api.weixin.qq.com/sns/jscode2session?appid={appid}&amp;secret={appsecret}&amp;js_code={code}&amp;grant_type=authorization_code" 到这里基本的流程就跑通了，下面我们直接来看看前端代码和后端代码，就能够一目了然的看懂！
前端代码 wx.login({ success (res) { // 判断是否获取到了code if (res.code) { // 向开发者服务器回传code wx.request({ url: `http://127.0.0.1:8000/wechat/login/`, method: 'POST', data: { code: res.code }, success: res =&gt; { // 拿到开发者服务器返回的用户信息及openid等逻辑需要的信息 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5938e439b44105376f12e29b80e6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d25724fecce5cdd9e163600b959090/" rel="bookmark">
			Linux块设备IO子系统_驱动模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		块设备是Linux三大设备之一，其驱动模型主要针对磁盘，Flash等存储类设备，块设备（blockdevice） 是一种具有一定结构的随机存取设备，对这种设备的读写是按块 (所以叫块设备)进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。作为存储设备，块设备驱动的核心问题就是哪些page-&gt;segment-&gt;block-&gt;sector与哪些sector有数据交互 ，本文以3.14为蓝本，探讨内核中的块设备驱动模型。
框架 下图是Linux中的块设备模型示意图，应用层程序有两种方式访问一个块设备：/dev和文件系统挂载点，前者和字符设备一样，通常用于配置，后者就是我们mount之后通过文件系统直接访问一个块设备了。
read()系统调用最终会调用一个适当的VFS函数(read()--&gt;sys_read()--&gt;vfs_read())，将文件描述符fd和文件内的偏移量offset传递给它。VFS会判断这个SCI的处理方式，如果访问的内容已经被缓存在RAM中（磁盘高速缓存机制），就直接访问，否则从磁盘中读取为了从物理磁盘中读取，内核依赖映射层mapping layer，即上图中的磁盘文件系统 确定该文件所在文件系统的块的大小，并根据文件块的大小计算所请求数据的长度。本质上，文件被拆成很多块，因此内核需要确定请求数据所在的块映射层调用一个具体的文件系统的函数，这个层的函数会访问文件的磁盘节点，然后根据逻辑块号确定所请求数据在磁盘上的位置。内核利用通用块层(generic block layer)启动IO操作来传达所请求的数据，通常，一个IO操作只针对磁盘上一组连续的块。IO调度程序根据预先定义的内核策略将待处理的IO进行重排和合并块设备驱动程序向磁盘控制器硬件接口发送适当的指令，进行实际的数据操作 块设备 VS 字符设备 作为一种存储设备，和字符设备相比，块设备有以下几种不同：
字符设备块设备1byte块，硬件块各有不同，但是内核都使用512byte描述顺序访问随机访问没有缓存，实时操作有缓存，不是实时操作一般提供接口给应用层块设备一般提供接口给文件系统是被用户程序调用由文件系统程序调用 此外，大多数情况下，磁盘控制器都是直接使用DMA方式进行数据传送。
IO调度 就是电梯算法。我们知道，磁盘是的读写是通过机械性的移动磁头来实现读写的，理论上磁盘设备满足块设备的随机读写的要求，但是出于节约磁盘，提高效率的考虑，我们希望当磁头处于某一个位置的时候，一起将最近需要写在附近的数据写入，而不是这写一下，那写一下然后再回来，IO调度就是将上层发下来的IO请求的顺序进行重新排序 以及对多个请求进行合并 ，这样就可以实现上述的提高效率、节约磁盘的目的。这种解决问题的思路使用电梯算法，一个运行中的电梯，一个人20楼-&gt;1楼，另外一个人15-&gt;5楼，电梯不会先将第一个人送到1楼再去15楼接第二个人将其送到5楼，而是从20楼下来，到15楼的时候停下接人，到5楼将第二个放下，最后到达1楼，一句话，电梯算法最终服务的优先顺序并不按照按按钮的先后顺序。Linux内核中提供了下面的几种电梯算法来实现IO调度：
No-op I/O scheduler 只实现了简单的FIFO的，只进行最简单的合并，比较适合基于Flash的存储Anticipatory I/O scheduler 推迟IO请求(大约几个微秒)，以期能对他们进行排序，获得更高效率Deadline I/O scheduler 试图把每次请求的延迟降到最低，同时也会对BIO重新排序，特别适用于读取较多的场合，比如数据库CFQ I/O scheduler 为系统内所有的任务分配均匀的IO带宽，提供一个公平的工作环境，在多媒体环境中，能保证音视频及时从磁盘中读取数据，是当前内核默认的调度器 我们可以通过内核传参的方式指定使用的调度算法
kernel elevator=deadline 或者，使用如下命令改变内核调度算法
echo SCHEDULER &gt; /sys/block/DEVICE/queue/scheduler Page-&gt;Segment-&gt;Block-&gt;Sector VS Sector VS左面的是数据交互中的内存部分，Page就是内存映射的最小单位; Segment就是一个Page中我们要操作的一部分，由若干个相邻的块组成; Block 是逻辑上的进行数据存取的最小单位，是文件系统的抽象，逻辑块的大小是在格式化的时候确定的, 一个 Block 最多仅能容纳一个文件（即不存在多个文件同一个block的情况）。如果一个文件比block小，他也会占用一个block，因而block中空余的空间会浪费掉。而一个大文件，可以占多个甚至数十个成百上千万的block。Linux内核要求 Block_Size = Sector_Size * (2的n次方)，并且Block_Size &lt;= 内存的Page_Size(页大小）, 如ext2 fs的block缺省是4k。若block太大，则存取小文件时，有空间浪费的问题；若block太小，则硬盘的 Block 数目会大增，而造成 inode 在指向 block 的时候的一些搜寻时间的增加，又会造成大文件读写方面的效率较差，block是VFS和文件系统传送数据的基本单位。 block对应磁盘上的一个或多个相邻的扇区，而VFS将其看成是一个单一的数据单元，块设备的block的大小不是唯一的，创建一个磁盘文件系统时，管理员可以选择合适的扇区的大小，同一个磁盘的几个分区可以使用不同的块大小。此外，对块设备文件的每次读或写操作是一种"原始"访问，因为它绕过了磁盘文件系统，内核通过使用最大的块(4096)执行该操作。Linux对内存中的block会被进一步划分为Sector，Sector是硬件设备传送数据的基本单位， 这个Sector就是512byte，和物理设备上的概念不一样，如果实际的设备的sector不是512byte，而是4096byte(eg SSD)，那么只需要将多个内核sector对应一个设备sector即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d25724fecce5cdd9e163600b959090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a510d3c391444c6d3c592cd76b29a4/" rel="bookmark">
			【python基础】多方法实现1-100累加求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下给出五种解题角度（for循环、while循环、列表推导式、reduce函数、递归函数）
①for循环
sum = 0 for i in range(101): sum += i print(sum) ②while循环
sum = 0 i=1 while i &lt;= 100: sum += 1 i += 1 print(sum) ③列表推导式（直接利用sum函数）
sum = sum([i for i in range(101)]) print(sum) ④reduce函数
from functools import reduce sum = reduce(lambda x,y: x + y,range(101)) print(sum) ⑤递归函数
def sum_recursive(n): if n == 0: return 0 return n + sum_resursive(n-1) sum = sum_recursive(100) print(sum) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7b977cd36b973f7c18be0c9b6d7dab/" rel="bookmark">
			pip install git&#43;https://github.com/XXX/XXX 命令报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一、运行命令及错误二、原因三、解决办法参考 一、运行命令及错误 pip install git+https://github.com/xxx/xxx
如果想通过git+https这种方式安装，可以参考官方文档。pip documentation 下面是官网的截图，可以看出其实官方是不推荐使用这种方式安装的。 二、原因
fatal: unable to access ‘https://github.com/xxx/xxx’: GnuTLS recv error (-110): The TLS connection was non-properly terminated.
错误：不能正确访问"https://github.com/xxx/xxx
",TLS 被终止。
note：This error originates from a subprocess, and is likely not a problem with pip.
笔记：这个错误源资源子进程，可能不是pip的问题。
三、解决办法
推测：可能是下载出了问题，使用git clone 下载或者直接download下载到本地
然后进去该文件目录下，找到setup.py文件，在该目录下执行，即可解决错误。
git clone https://github.com/xxx/xxx.git # 克隆项目 cd DeepPurpose # 切换目录 python setup.py install # 从源项目有构建 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b588f4ad424384e5852471ef094099/" rel="bookmark">
			疫情可视化part2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 此系列已完结，共3部分：
part1：https://blog.csdn.net/xi1213/article/details/126824752part2：https://blog.csdn.net/xi1213/article/details/127719364part3：https://blog.csdn.net/xi1213/article/details/128072446 本来说有时间就把这个项目完结了的，结果后面一直有事拖着，直到现在十一月份了才搞完。老样子，先看成果。
浏览链接：http://xisite.top/original/bigScreen/28/index.html#/项目链接(欢迎各位大哥star)：https://gitee.com/xi1213/covid19-visualization 修改与添加 后面可能审美疲劳了，越看越丑，就干脆直接用dataV（这可不是阿里的那个dataV）修饰页面了。这是项目改动后的样子：
主要做了如下改动：
添加首页的3d粒子球体。完成“省内分析”模块。完成当地疫情报告生成与下载。使用dataV修饰页面。 粒子球体 粒子球体也是用three.js完成的，放大仔细看会发现其实是有三层构成的：内层透明球体，中间点状球体，外层病毒球体。
具体实现过程是这样的：
先绘制一个内层透明球体，记得将球体材质的transparent设为true，然后设置不透明度opacity值。 //创建斑点球体 async function createSpotSphere() { let globeBufferGeometry = new THREE.SphereGeometry(earthSize - 1, 50, 50);//球体几何体 let globeInnerMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(dvColor[0]),//颜色 // blending: THREE.AdditiveBlending,//纹理融合的叠加方式 // side: THREE.FrontSide,//前面显示 transparent: true,//透明 // depthWrite: false,//深度写入 // depthTest: false,//黑洞效果 opacity: .3,//不透明度 }); let globeInnerMesh = new THREE.Mesh( globeBufferGeometry, globeInnerMaterial ); earthGroup.add(globeInnerMesh); //将网格放入地球组 cre 创建点状球体。这里需要使用一张黑白的世界地图。 let img = new Image(); img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b588f4ad424384e5852471ef094099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf56290fe6b1cdbf8a813b4cafb2498/" rel="bookmark">
			疫情可视化part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 此系列已完结，共3部分：
part1：https://blog.csdn.net/xi1213/article/details/126824752part2：https://blog.csdn.net/xi1213/article/details/127719364part3：https://blog.csdn.net/xi1213/article/details/128072446 自成都九月份以来疫情原因被封了一两周，居家着实无聊，每天都是盯着微信公众号发布的疫情数据看，那种页面，就我一个前端仔来说，看着是真的丑啊！(⊙_⊙)？既然丑，那就自己动手开整！项目是2022.9.5开始的，截止2022.9.12我完成了大概有八成。主要是想让数据更加直观，而且可离线下载(当然还有装逼！┑(￣Д ￣)┍)。
项目描述 为证明是有料的，先看效果图(提前装逼！┗|｀O′|┛ 嗷~~)：
项目我是公开了的(￣m￣）有兴趣的可以下下来玩玩，这是我第一次使用vue3+ts构建项目，肯定还有不足的地方(比如ts中疯狂的:any，一直any一直爽^o^/)。
这里是浏览链接：http://xisite.top/original/bigScreen/28/index.html#/
这里是项目链接：https://gitee.com/xi1213/covid19-visualization
（欢迎star！欢迎star！欢迎star！(●’◡’●)嘿嘿嘿~）
项目中使用到的技术有：vue3、TypeScript、Three.js、Echarts、elementPlus。
项目目标 1、以为3D形式展示全球疫情分布。
2、显示实时疫情数值。
3、以图表形式分析疫情数据。
4、允许下载各地疫情excel表格。
5、自动获取用户位置。
6、分析当地疫情数据。
7、生成当地疫情word报告。
api说明 本项目数据来源：新浪公共疫情api(新浪的数据来源于国家卫健委、各省市区卫健委、各省市区政府、港澳台官方渠道等公开数据。这也是够权威官方了)。我主要使用了两个新浪的api和一个太平洋网络ip地址查询web接口。
1、https://news.sina.com.cn/project/fymap/ncp2020_full_data.json
get方式，无入参。该api可获取全球各国大致疫情数据，以及国内的详情疫情数据，这里就api中的字段做一下说明，字段是我自己推测出来的含义，不会100%全而准(→_→)：
{ "add_daily(国内今日数据)": { "addcon(今日确诊新增数)": "", "addcure(今日治愈新增)": "", "adddeath(今日死亡新增)": "", "addjwsr(今日境外输入新增)": "", "addlocIncrNum(今日本土新增)" }, "cachetime(数据缓存时间)": "", "curetotal(国内治愈总数)": "", "deathtotal(国内死亡总数)": "", "gntotal(国内确诊总数)": "", "highAndMiddle(中高风险地列表)": [ { "allname(全名)": "", "list(城市列表)": "", "province(省名)": "", "province_high_areas(高风险区域)": "", "province_middle_areas(中风险区域)": "", "province_high_num(高风险区域数)": "", "province_middle_num(中风险区域数)": "", "province_total(风险地总数)": "" } ], "historylist(国内疫情历史数据)": [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf56290fe6b1cdbf8a813b4cafb2498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ae43e8cafbb4af64ac001db61bdbb7/" rel="bookmark">
			基于GPT-2实现图像文本生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 使用GPT-2模型处理文本，做decoder。
使用google的vit-base-patch16-224模型处理图像，做encoder。
最后通过VisionEncoderDecoderModel将这两个模型粘起来。
如下图所示。
代码 1、导入相关的包
from transformers import (VisionEncoderDecoderModel, AutoTokenizer,ViTImageProcessor) import torch from PIL import Image 2、加载模型
# VIT_MODEL_NAME_OR_PATH = "./vit-base-patch16-224" # GPT_MODEL_NAME_OR_PATH = "./gpt2_chinese" # vision_encoder_decoder_model_name_or_path = "./vit-gpt2-image-chinese-captioning" VIT_MODEL_NAME_OR_PATH = "google/vit-base-patch16-224" GPT_MODEL_NAME_OR_PATH = "yuanzhoulvpi/gpt2_chinese" vision_encoder_decoder_model_name_or_path = "vit-gpt2-image-chinese-captioning" processor = ViTImageProcessor.from_pretrained(VIT_MODEL_NAME_OR_PATH) tokenizer = AutoTokenizer.from_pretrained(GPT_MODEL_NAME_OR_PATH) model = VisionEncoderDecoderModel.from_pretrained(vision_encoder_decoder_model_name_or_path) device = torch.device("cuda" if torch.cuda.is_available() else "cpu") model.to(device) 如果网速过慢，可以先把模型下载到本地，下载方法：下载huggingface-transformers模型至本地，并使用from_pretrained方法加载
3、推理，生成文本
max_length = 16 num_beams = 4 gen_kwargs = {"max_length": max_length, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ae43e8cafbb4af64ac001db61bdbb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d99a0e6469712188b43596454a4956c/" rel="bookmark">
			下载huggingface-transformers模型至本地，并使用from_pretrained方法加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们经常会使用到hugging face开源的transformers包，调用from_pretrained方法直接下载模型时，经常会下载很久甚至失败.
而且由于它自动将下载的模型保存至root/.cache/huggingface/transformers文件夹下，这不方便我们对模型进行备份。
为了解决这个问题，下面我们将实现“下载huggingface-transformers模型至本地，并使用from_pretrained方法加载”。
一、下载huggingface_hub包 pip install huggingface_hub 二、编写python脚本下载模型 比如我们现在想要下载google/vit-base-patch16-224transformers包，可以通过如下代码实现：
from huggingface_hub import snapshot_download snapshot_download(repo_id="google/vit-base-patch16-224", allow_patterns=["*.json", "pytorch_model.bin", "vocab.txt"], local_dir="./my_model/") 其中，repo_id含义为模型在huggingface的路径，allow_patterns为你想要下载的文件（因为repo_id目录下文件很多，你可以通过此参数下载自己想要的文件），local_dir含义为模型保存在本地的路径。
Hugging Face官方也给出了使用工具下载模型的方法，链接地址
三、在代码中加载本地模型 模型下载到本地前，加载模型的方式为：
VIT_MODEL_NAME_OR_PATH = "google/vit-base-patch16-224" model = VisionEncoderDecoderModel.from_pretrained(vision_encoder_decoder_model_name_or_path) 下载到本地后，我们就可以这样加载模型了：
vision_encoder_decoder_model_name_or_path = "./my_model/" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c91a751e2d000c638b7d06645445520/" rel="bookmark">
			QT中QDockWidget使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt系列文章目录 文章目录 Qt系列文章目录前言一、具体操作1.QDockWidget控件配置函数2.代码1 .头文件2.实现文件 效果遇到的问题 前言 QDockWidget提供了dock widget的概念，也称为工具面板或实用工具窗口。停靠窗口是放置在QMainWindow中央小部件周围的停靠小部件区域中的次要窗口。许多工程软件，如Qt Creator，VS，matlab等，都是使用dock布局窗口，这样用户可以自定义界面，自由组合窗口。
Qt的嵌套布局由QDockWidget完成，用Qt Creator拖界面得到的dock布置形式比较固定，不能得想要的任意组合形式，要得到如下图所示的效果，后续布局必须通过代码来完成。
如图所示：
一、具体操作 1.新建QMainWindow基类工程，在ui设计页面拖入3个QDockWidget控件。
也可以不在UI设计器里面加，使用代码加入QDockWidget控件
2.因为整个窗口都由dock组成，所以在myMainWindow的构造函数中先把QMainWindow的中间窗口部件去除。
QWidget* central_form = takeCentralWidget(); if(central_form) delete central_form; 3.用setWindowTitle(const QString &amp;)函数为每个dock添加标题便于后面区分。
this-&gt;setWindowTitle(tr("图像处理系统")); 4.接下来配置DockWidget嵌套
setDockNestingEnabled(true); 这句语句是用来配置dock是否可以嵌套。通过查询帮助文档，我们可以知道，如果参数为false，则停靠区域只能水平或者垂直，即dock不能放置在中间，只能在两侧排布。如果参数为true，那么dock所占用的区域可以向任意方向排布。
接下来先移除所有的dock，我们来调整dock位置。调整dock位置前通过
void MainFramework::dockLayout() { this-&gt;addDockWidget(Qt::LeftDockWidgetArea, m_projManagerView, Qt::Orientation::Vertical); this-&gt;addDockWidget(Qt::RightDockWidgetArea, m_propertyView, Qt::Orientation::Vertical); this-&gt;addDockWidget(Qt::BottomDockWidgetArea, m_logView, Qt::Orientation::Vertical); } 5.为第一个dock指定位置，接下来通过配置的参数对所有的dock进行排列，这个函数是将第一个停靠dock覆盖的空间分成两部分，将第一个停靠dock移动到第一部分中，并将第二个停靠dock移动到第二部分中。通过这样的方式可以先左右，再上下的原则依次对dock进行排列。例如：
void QMainWindow::splitDockWidget(QDockWidget *first, QDockWidget *second, Qt::Orientation orientation) 1.QDockWidget控件配置函数 1.配置dock最小的宽度、高度，最大尺寸。
m_logView-&gt;setMinimumWidth(150); m_propertyView-&gt;setMinimumHeight(100); m_projManagerView-&gt;setMaximumSize(100,100); 2.隐藏标题栏。
QWidget* TitleBar = m_propertyView-&gt;titleBarWidget(); QWidget* EmptyWidget = new QWidget(); m_propertyView-&gt;setTitleBarWidget(EmptyWidget); delete TitleBar; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c91a751e2d000c638b7d06645445520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824aee3f711e847fe5636178674aef7e/" rel="bookmark">
			antdvue树选择组件a-tree-select，只有叶子节点可以被选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【效果】只有叶子节点可以被选中
【步骤】按步骤copy即可（vue2版本）
1、html中
&lt;a-tree-select v-model="ffid" show-search style="width: 100%" :dropdown-style="{ maxHeight: '400px', overflow: 'auto' }" placeholder="请从标签树中选择" allow-clear multiple :tree-default-expand-all="false" :tree-data="treeData" :replace-fields="{children:'children', key:'id', value: 'id', title: 'name'}" &gt; &lt;/a-tree-select&gt; 2、js中
2.1data中：
data () { return { ffid:''. treeData: [{ name: 'parent 1', id: 'parent 1', children: [{ name: 'parent 1-0', id: 'parent 1-0', children: [{ name: 'my leaf', id: 'leaf1' }, { name: 'your leaf', id: 'leaf2' }] }, { name: 'parent 1-1', id: 'parent 1-1' }] }] } }, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824aee3f711e847fe5636178674aef7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9287bdce0954a797afc0d299ee83f0cc/" rel="bookmark">
			网络安全和网络工程师有什么区别，学习那一个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络工程师即对当代数字通信系统有一定的了解，理论上要求精通网络二、三层通信原理与方式，实际操作中偏重路由和交换的实施，另外还需要对综合布线（一层）有一定的了解。
网络安全工程师除了具备网络工程师的理论基础外，对网络安全还需要有更多的了解，在实际操作中偏重网络安全的实施（过滤、策略、认证），偶尔也需要对三层以上的通信有一定操作。
至于学习，自己的兴趣比什么都重要！入门很容易，学精就比较难了。
一、就业前景广阔 网络安全涵盖的面更广，就业方向也更广阔，如网络安全工程师、安全服务工程师、漏洞挖掘工程师、渗透测试工程师、信息安全工程师、安全运维工程师……
据相关专业机构统计，当前我国网络安全人才培养在三万人左右，人才缺口在150万之多，预计2027年缺口将进一步扩大到300万。
而网络工程仅仅只是一个小的方向哈。
二、就业薪资高 据猎聘网2021网络安全人才调查报告数据显示，全国网络安全人才平均年薪为33.77万元，领跑各大行业，超出常规“多金”的金融业9.77万元，足见网络安全行业对人才的重视程度。而深圳以43.44万元年薪位列第一，超过沪京两地薪酬。
如果你对网络安全感兴趣，学习资源分享（嘿客入门教程） 如果你对网络安全入门感兴趣，那么你点击这里👉《嘿客&amp;网络安全入门&amp;进阶学习籽源包》
如果你对网络安全感兴趣，学习资源免费分享，保证100%免费！！！（嘿客入门教程） 如果你对网络安全入门感兴趣，那么你需要的话可以
点击这里👉CSDN大礼包：《嘿客&amp;网络安全入门&amp;进阶学习资源包》免费分享
👉网安（嘿客）全套学习视频👈
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
👉网安（嘿客红蓝对抗）所有方向的学习路线👈
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
👉嘿客必备开发工具👈
工欲善其事必先利其器。学习嘿客常用的开发软件都在这里了，给大家节省了很多时间。
这份完整版的网络安全（嘿客）全套学习资料已经上传至CSDN官方，朋友们如果需要点击下方链接也可扫描下方微信二v码获取网络工程师全套资料【保证100%免费】 如果你有需要可以点击👉CSDN大礼包：《嘿客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e485facc07e3c860d47fdde97a3585/" rel="bookmark">
			【YOLO】基于YOLOv8实现自定义数据的自动标注（针对VOC格式的数据集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于YOLOv8实现自定义数据的自动标注 引言VOC格式的数据集自标注实现 引言 利用yolov8的检测模型实现数据集的自标注，针对VOC数据集，.xml文件，labelimg标注工具
VOC格式的数据集自标注实现 yolov8模型的训练可以参考笔者的博客
【YOLO】YOLOv8实操：环境配置/自定义数据集准备/模型训练/预测
训练好自定义的模型，就可以执行下面的代码实现模型自标注数据集
修改下面三个参数即可：
weight_path = "/media/ll/L/llr/model/yolov8/weights/best.pt" # 模型路径 imgdir = r'/media/ll/L/llr/DATASET/subwayDatasets/bjdt/images' # 图片路径 xmldir = r'/media/ll/L/llr/DATASET/ZED_DATA/GZG/bjdt_daytime/xml' # 标注文件保存路径 完整代码如下：
""" Fuction:使用预训练模型权重对图像集进行识别后自动标注 Author: Alian Create_Date:2023.03.30 Finishe_Date:2023.03.30 """ import os from os import getcwd import glob from xml.etree import ElementTree as ET from utils.general import * # from utils.datasets import * from utils import torch_utils from ultralytics import YOLO # YOLOV8 # 定义一个创建一级分支object的函数 def create_object(root, xyxy, names,cls): # 参数依次，树根，xmin，ymin，xmax，ymax # 创建一级分支object _object = ET.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e485facc07e3c860d47fdde97a3585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277ee6d0efbd364ee1e3698f4c575371/" rel="bookmark">
			colab OSError: [Errno 107] Transport endpoint is not connected 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前执行 colab好好的，突然就报错了
OSError: [Errno 107] Transport endpoint is not connected
解决方案：
执行一行代码
卸载文件系统
!fusermount -u drive 然后重新mount
from google.colab import drive drive.mount('/content/drive') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde273ac3bffa83572b331daae51e563/" rel="bookmark">
			JSP基础开发，可以用一些小型的项目中（简单学习，已过时，但是在一些项目中可以用到）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP开发1（了解，已过时） 学习目标学习内容学习产出1、 JSP概述2、 JSP快速入门2.1、 搭建环境2.2、 编写代码2.3、 测试 3、 JSP原理4、 JSP脚本4.1、 JSP 脚本分类4.2、 代码测试 5、 JSP缺点6、 EL 表达式6.1、 概述6.2、 代码演示6.3、 域对象 7、 JSTL标签7.1、 JSTL概述7.2、 c:if标签7.3、 forEach 8、 MVN模式和三层架构8.1、 MVC模式8.2、 三层架构8.3、 MVC 和 三层架构 学习目标 理解 JSP 及 JSP 原理能在 JSP中使用 EL表达式 和 JSTL标签理解 MVC模式 和 三层架构能完成品牌数据的增删改查功能 学习内容 理解 JSP 及 JSP 原理能在 JSP中使用 EL表达式 和 JSTL标签理解 MVC模式 和 三层架构 学习产出 本篇文章主要讲述的JSP的一些开发的基本需求和介绍，对于JSP的项目非常的有用，下一篇文章是一个关于JSP的案例，·建议是先看完讲解然后去看下一篇的案例代码，能有一个更加深的认知~~
JSP案例项目地址
1、 JSP概述 测试资源 提取码：1111
JSP（全称：Java Server Pages）：Java 服务端页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde273ac3bffa83572b331daae51e563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746197e32ed30b276e9b58edb8452ee4/" rel="bookmark">
			第十四届蓝桥杯三月真题刷题训练——第 27 天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第 1题：数学考试_前缀和
代码：
第 2 题：地标访问_二分
题目背景
题目描述
输入格式
输出格式
输入输出样例
说明/提示
代码：
第 1题：数学考试_前缀和 代码： package 第十四届蓝桥杯三月真题刷题训练.day27; import java.io.*; /** * @author yx * @date 2023-03-30 20:44 */ public class 数学考试 { static PrintWriter out =new PrintWriter(System.out); static BufferedReader ins=new BufferedReader(new InputStreamReader(System.in)); static StreamTokenizer in=new StreamTokenizer(ins); /** * 输入 * in.nextToken() * int a= (int)in.nval; * * 输出 * out.print(); * out.flush(); * * 读文件： * BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746197e32ed30b276e9b58edb8452ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262d36049882ed5924af0cad266ec80c/" rel="bookmark">
			JSP开发2（案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP开发2（案例） 学习目标学习内容学习产出1 环境准备1.1 创建工程1.2 创建包1.3 创建表1.4 创建实体类1.5 准备mybatis环境 2 查询所有2.1 编写BrandMapper2.2编写SqlSessionFactoryUtils工具类2.3 编写BrandService2.4 编写Servlet2.5 编写JSP页面 3 添加3.1 编写BrandMapper方法3.2 编写BrandService3.3 编写brand.jsp3.4 编写addBrand.jsp3.5 编写addServlet3.6 测试 4 修改4.1 回显4.1.1 编写BrandMapper方法4.1.2 编写BrandService4.1.3 编写SelectByIdServlet4.1.4 编写update.jsp页面4.1.5 回显测试4.1.6 改进 4.2 修改数据4.2.1 编写BrandMapper4.2.2 编写BrandService4.2.3 编写Servlet4.2.4 测试 5 删除5.1 编写BrandMapper5.2 编写BrandService5.3 编写DeleteServlet 学习目标 理解 JSP 及 JSP 原理能在 JSP中使用 EL表达式 和 JSTL标签理解 MVC模式 和 三层架构能完成品牌数据的增删改查功能 学习内容 能完成品牌数据的增删改查功能 学习产出 上一篇我们讲过了JSP开发的基本要求，并且对JSP进行了一个非常详细的介绍~
跳转链接：JSP开发详细介绍
下面我们就对上篇文章的知识进行一个项目的练习和总结~
1 环境准备 环境准备工作，我们分以下步骤实现：
创建新的模块 brand_demo，引入坐标
创建三层架构的包结构
数据库表 tb_brand
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262d36049882ed5924af0cad266ec80c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d1de9bab649bef95612a02ec4c613c/" rel="bookmark">
			pandas库导入JSON格式的数据教程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas 库提供了许多方法来导入不同格式的数据，包括 CSV、Excel、JSON、SQL 等。以下是使用 pandas 导入 JSON 文件的方法：
导入 JSON 文件
可以使用 pandas 中的 read_json() 函数导入 JSON 文件。例如，如果要导入名为 data.json 的文件，可以使用以下代码：
java
import pandas as pd
df = pd.read_json('data.json')
该代码会将 JSON 文件中的数据读入到 DataFrame 对象中。read_json() 函数还支持许多参数，例如指定文件编码、指定 JSON 文件中的键等。更多参数可以参考 pandas 的官方文档。
导入 JSON 字符串
除了从文件中导入 JSON 数据外，还可以将 JSON 字符串直接转换为 DataFrame 对象。可以使用 pandas 中的 read_json() 函数，并将 JSON 字符串作为输入参数。例如：
makefile
import pandas as pd
json_data = '{"name": "John", "age": 30, "city": "New York"}'
df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d1de9bab649bef95612a02ec4c613c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcc5c6cf32a7fe043e355f6bb8be822/" rel="bookmark">
			SpringCloud相关知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，微服务的理解
1，微服务就是将传统的一站式应用根据业务逻辑拆封成单独的业务单元，每个单独模块各自完成自己的业务功能，彻底去耦合
2，微服务四大核心问题
1）服务很多，如何访问 （euraka）
2）这么多服务，服务之间如何通信（rest）
3）这么多服务，如何治理
4）服务挂了咋办 （负载，熔断器）
二，SpringCloud相关知识点
1，概念理解：SpringCloud是基于SpringBoot的微服务解决方案。提供了服务注册与发现，负载均衡，网关，微服务配置等组建。利用SpringBoot方便开发的特点，使得Springboot可以方便的搭建微服务框架。
2，微服务的五大组建
(1)eureka:服务的注册与发现，包含两大模块，eureka-server和eureka-client 作用：实现服务的治理（服务的注册与发现）
1) eureka--server:服务的注册中心，支持集群部署
2) eureka-client：客户端用来处理注册和发现
(2)Ribbon:主要提供客户端负载均衡算法，其是基于http和tcp的客户端负载均衡工具
(3)Hystrix:熔断器，保护系统，控制故障范围
(4)Zuul:网关，路由，负载均衡，过滤等作用
(5)Config:配置管理，提供服务端和客户端,服务器存储后端的默认实现使用git，其支持标签版本的控制环境。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/161/">«</a>
	<span class="pagination__item pagination__item--current">162/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/163/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>