<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb2c6c207f7732197afa90658897458/" rel="bookmark">
			npm 直接安装 GitHub/GitLab 仓库代码及 npm link 本地调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、npm 直接安装 GitHub/GitLab 仓库代码 语法 npm install &lt;git remote url&gt; 示例 命令：
npm i git@github.com:mazeyqian/mazey.git -S # 或 npm i https://github.com/mazeyqian/mazey.git -S { "name": "test", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "author": "", "license": "ISC", "dependencies": { "mazey": "github:mazeyqian/mazey", } } # 或 { "name": "test", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "test": "echo \"Error: no test specified\"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb2c6c207f7732197afa90658897458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2559d21a1ccb5e31b687b350e65518ba/" rel="bookmark">
			SpringBoot集成Minio搭建自己的分布式文件服务器（Minio集成篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.导入依赖
2.创建spring boot工程，工程名为springboot-minio
3.配置minio配置文件
4.创建配置类MinioConfig
5.创建Minio工具类MinioUtils
6.创建测试controller类
7.启动项目测试
1.导入依赖 implementation 'io.minio:minio:8.2.2' 2.创建spring boot工程，工程名为springboot-minio 3.配置minio配置文件 minio: endpoint: http://10.0.1.140:9002 accessKey: minio secretKey: minio123 bucketName: test 4.创建配置类MinioConfig package com.springboot.minio.config; import io.minio.MinioClient; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @author zsx */ @Data @Configuration public class MinioConfig { /** * 访问地址 */ @Value("${minio.endpoint}") private String endpoint; /** * accessKey类似于用户ID，用于唯一标识你的账户 */ @Value("${minio.accessKey}") private String accessKey; /** * secretKey是你账户的密码 */ @Value("${minio.secretKey}") private String secretKey; /** * 默认存储桶 */ @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2559d21a1ccb5e31b687b350e65518ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1131e8710fa824176cceb179d1a526af/" rel="bookmark">
			ShardingSphere之SpingBoot整合Sharding-JDBC进行数据单主节点读写分离以及多主多从读写分离&#43;分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、读写分离概念 读写分离是通过主从的配置方式，将查询请求均匀的分散到多个数据副本，进一步的提升系统的处理能力。
主从架构：读写分离，目的是高可用、读写扩展。主从库内容相同，根据SQL语义进行路由。
分库分表架构：数据分片，目的读写扩展、存储扩容。库和表内容不同，根据分片配置进行路由。
读写分离虽然可以提升系统的吞吐量和可用性，但同时也带来了数据不一致的问题，包括多个主库之间的数据一致性，以及主库与从库之间的数据一致性的问题。并且，读写分离也带来了与数据分片同样的问题，它同样会使得应用开发和运维人员对数据库的操作和运维变得更加复杂。
一、读写分离应用 在数据量不是很多的情况下，我们可以将数据库进行读写分离，以应对高并发的需求，通过水平扩展从库，来缓解查询的压力。如下： 2. 分表+读写分离
在数据量达到500万的时候，这时数据量预估千万级别，我们可以将数据进行分表存储。
分库分表+读写分离
在数据量继续扩大，这时可以考虑分库分表，将数据存储在不同数据库的不同表中，如下：
透明化读写分离所带来的影响，让使用方尽量像使用一个数据库一样使用主从数据库集群，是ShardingSphere读写分离模块的主要设计目标。
主库、从库、主从同步、负载均衡
核心功能
提供一主多从的读写分离配置。仅支持单主库，可以支持独立使用，也可以配合分库分表使用
独立使用读写分离，支持SQL透传。不需要SQL改写流程
同一线程且同一数据库连接内，能保证数据一致性。如果有写入操作，后续的读操作均从主库读取。
基于Hint的强制主库路由。可以强制理由走主库查询实时数据，避免主从同步数据延迟。不支持项
主库和从库的数据同制
主库和从库的数据同步延迟
主库双写或多写
跨主库和从库之间的事务的数据不一致 三、代码演示（对应实体类、表结构、数据访问接口 上一篇中有） 1、读写分离 这里采用不同库来代表主从关系
主要是application.properties配置不同
spring.shardingsphere.datasource.names=master,slave0 spring.shardingsphere.datasource.master.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.master.jdbc-url=jdbc:mysql://localhost:3306/shardingsphere1?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC spring.shardingsphere.datasource.master.username=root spring.shardingsphere.datasource.master.password=000000 spring.shardingsphere.datasource.master.driver-class-name=com.mysql.jdbc.Driver spring.shardingsphere.datasource.slave0.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.slave0.jdbc-url=jdbc:mysql://localhost:3306/shardingsphere2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC spring.shardingsphere.datasource.slave0.username=root spring.shardingsphere.datasource.slave0.password=000000 spring.shardingsphere.datasource.slave0.driver-class-name=com.mysql.jdbc.Driver # master-slave spring.shardingsphere.masterslave.name=datasource spring.shardingsphere.masterslave.master-data-source-name=master spring.shardingsphere.masterslave.slave-data-source-names=slave0 spring.shardingsphere.masterslave.load-balance-algorithm-type=ROUND_ROBIN #id spring.shardingsphere.sharding.tables.city.key-generator.column=id spring.shardingsphere.sharding.tables.city.key-generator.type=CKWKEYID 测试：
插入数据 @Test public void test4() { for (int i = 1; i &lt; 20; i++) { CityEntity city = new CityEntity(); city.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1131e8710fa824176cceb179d1a526af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec211df7a217db02a97bddd0147cb89/" rel="bookmark">
			复制swagger中的url（油猴脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 脚本地址： 点击访问：复制swagger中的url
脚本使用： 浏览器安装油猴插件
访问链接，点击安装：
​​​​
刷新swagger-ui.html页面，就能看到复制按钮了，点击即可复制：
问题反馈： 反馈地址：点击访问 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b12543be05c56563670f47cd0ac8c8b/" rel="bookmark">
			电脑查询ip地址的方法，第一种最为简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，每台电脑都会有固定的一个ip地址。部分电脑则是动态ip地址，每次连接网络时会自动分配。当我们需要查询ip地址的时候，该怎么操作呢？看完你就知道了。
更多系统教程尽在小白系统重装官网
系统：win10专业版
电脑：惠普 V3903AU
一、直接查询
我们可以直接在电脑浏览器上搜索“IP”，搜索结果第一条就是你电脑的ip地址啦，这个方法最为简单粗暴。
二、网络设置查询
我们还可以用常规的方法来查询，在网络设置里，以太网、网络和共享中心、找到internet 协议版本，然后就可以看到如下图的ip地址了。
​三、命令查询
首先win+r调出运行、输入cmd然后回车，在接下来的窗口里面输入“ipconfig”再回车，就会列出相关信息,找到目前电脑连接网络下的IPv4地址哪一行，对应右边的一串数字就是当前网络的IP地址了。
​
综上所述，说了这么多还是第一种查询电脑ip地址的方法是最简单的，直接一步就搞定，大家也可以操作一下试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555cc545a338e159a29400493fd057dc/" rel="bookmark">
			HashMap 源码探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天一直在研究HashMap的源码，也算研究个大概了。怕以后忘记，也为了能给其他同学做参考交流，就理一下思路给贴出来吧。
本文是以加注释的方式来解读put、resize、get等主要方法，有不对的地方欢迎评论讨论
put： public V put(K key, V value) { //这里调用了putVal() return putVal(hash(key), key, value, false, true); } hash： static final int hash(Object key) { int h; //这里用key的hashcode与自身右移16位做异位运算 //为了&amp;（length-1）获得数组下标时，让下标不止受hashcode的的后几位影响，减小hash冲突 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } putVal： final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断table（hashmap的数组）是否为空，为空则初始化 if ((tab = table) == null || (n = tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555cc545a338e159a29400493fd057dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75eadb9882dee7e6233be98e08957da4/" rel="bookmark">
			VMware 安装失败解决方案，亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在安装VMware的时候，每次安装到最后一步就会报错，令人非常疑惑，折腾了一中午才解决这个问题。
解决方案 1、按win+r，输入regedit打开注册表编辑器
2、修改默认存储路径
之前我的默认存储路径是D盘，所以会一直出现安装失败，上图是修改以后的路径，把存储路径改为C盘后，就能顺利安装了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42250c8e2ac6c6693540157c73546d6/" rel="bookmark">
			Quorum 机制(分布式系统)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quorum 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。
基于Quorum投票的冗余控制算法 在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。
该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。
算法来源于[Gifford, 1979][3][1]。 分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：
Vr + Vw &gt; VVw &gt; V/2 V:
Vw +Vr &gt; V ：说明Vw 和 Vr 有交集地方
Vw &gt; V/2
第一条规则保证了一个数据不会被同时读写。
当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。
同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。
第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。
算法的好处 在分布式系统中，冗余数据是保证可靠性的手段，因此冗余数据的一致性维护就非常重要。一般而言，一个写操作必须要对所有的冗余数据都更新完成了，才能称为成功结束。比如一份数据在5台设备上有冗余，因为不知道读数据会落在哪一台设备上，那么一次写操作，必须5台设备都更新完成，写操作才能返回。
对于写操作比较频繁的系统，这个操作的瓶颈非常大。Quorum算法可以让写操作只要写完3台就返回。剩下的由系统内部缓慢同步完成。而读操作，则需要也至少读3台，才能保证至少可以读到一个最新的数据。
Quorum的读写最小票数可以用来做为系统在读、写性能方面的一个可调节参数。写票数Vw越大，则读票数Vr越小，这时候系统读的开销就小。反之则写的开销就小。
参考文献 ^ Gifford, David K. SOSP '79: Proceedings of the seventh ACM symposium on Operating systems principles. Pacific Grove, California, United States: ACM: 150–162. 1979. doi:10.1145/800215.806583. |contribution=被忽略 (帮助) 鸽巢原理 鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理。
其中一种简单的表述法为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42250c8e2ac6c6693540157c73546d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c1533e976ba65559f6240d69536842/" rel="bookmark">
			ModuleNotFoundError: No module named ‘past‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行pip install future，安装future后，程序正常执行！ 参考：(20条消息) PyTorch: ModuleNotFoundError: No module named 'past'_RaySunWHUT-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f653b49bbed2b45d156acc44615867d9/" rel="bookmark">
			Laravel-Modules 模块开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、Laravel-Modules是什么？二、laravel-modules安装 一、Laravel-Modules是什么？ 当我们开发大型应用时，经常需要将应用划分成不同的模块，Laravel-Modules 可以使我们的代码结构更加清晰以及方便管理 。
二、laravel-modules安装 1.首先在 Laravel 项目根目录下使用 Composer 安装该扩展包。
composer require nwidart/laravel-modules 2.发布配置文件。
php artisan vendor:publish --provider="Nwidart\Modules\LaravelModulesServiceProvider" 3.生成模块。
php artisan module:make Blog 4.要让模块目录中定义的类可以自动加载，需要配置根目录下的composer.json。
{ "autoload": { "psr-4": { "App\\": "app/", "Modules\\": "Modules/" } } } 5.配置完成后运行以下命令让修改生效。
composer dump-autoload 6.执行域名加模块名（例如：http://www.maomaohang.com/blog）
7.注意Artisan命令与之前相比有所改变
php artisan make:controller TestController php artisan module:make-controller TestController Blog 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a69771c77cba4fbcdb3f7c8d7b05f90/" rel="bookmark">
			ubuntu中screen使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu中screen使用 常用1，新建screen2，查看所有的screen3，回到某个screen中4，删除某个screen 常用 screen的常用指令只有四个
1，新建screen 新建名字为xia的screen
screen -S xia 2，查看所有的screen screen -ls 3，回到某个screen中 回到名字为xia的screen中
screen -r xia 4，删除某个screen 删除名字为xia的screen
screen -S xia -X quit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b98db159421cef30754d3ec4aab9e1/" rel="bookmark">
			半监督学习：MixMatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MixMatch: A Holistic Approach to Semi-Supervised Learning
官方代码---tensorflow版本
pytorch版
论文 2.1以上的内容都是简介，概述这里就不进行讲解。 2.1 Consistency Regularization 一致性正则 这个技巧是什么意思，就是说对一张图片进行2种不同的数据增强后，给模型预测，预测的y1和y2，这y1和y2的结果要一致。为什么说是正则，因为添加了扰动噪声，为什么说一致性，因为预测出来的y1和y2要一致。
那在半监督中这y1和y2的loss如何计算？论文中：
就是y1和y2用MSE_loss均方差loss 在pytorch中是F.mse_loss。
代码实现：Lu = F.mse_loss(output_u,trg_u)
pytorch版的这个更加粗暴
2.2 Entropy Minimization---熵最小化 信息熵越小，含有的信息量就越大
分类模型在计算loss的时候才用交叉熵loss；如果输出的值比较implicitly（含蓄模糊）那么对计算loss的时候有影响。所以论文中提出自己的方法”sharpening(类似图片的锐化操作)“
pt = p**(1/args.T) targets_u = pt / pt.sum(dim=1, keepdim=True) targets_u = targets_u.detach() 2.3 Traditional Regularization -- 传统的正则方法 简单的说就是论文说他会用到L2正则去优化模型参数和mixup数据增强
3 MixMatch 从这里开始就正式开始讲述论文的方法了，
X是标注了的数据图片，X′ 是X进行数据增强后的图片，U是没标注的数据图片，U′是对U进行数据增强后的进行猜测后的标签（也就是进行了模型预测），T,K,a都是超参数
说的是标注了的图片如何求loss是用交叉熵
Lx = -torch.mean(torch.sum(F.log_softmax(outputs_x, dim=1) * targets_x, dim=1)) 说的是没标注的图片如何求loss
Lu = torch.mean((probs_u - targets_u)**2) 总的loss就等于两者相加 def linear_rampup(current, rampup_length=args.epochs): if rampup_length == 0: return 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b98db159421cef30754d3ec4aab9e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96c8dbe36607d4686686e327fb76b93/" rel="bookmark">
			C&#43;&#43; 五子棋 面向对象实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（上大学后重学C++系列）
虽然标题是面向对象，但是写出来感觉和面向过程也差不多。
写了两个多小时，但是只实现了基本的双人对弈功能…
棋盘的样式参考了这一篇：
|---|---| | X | O | |---|---| wsad控制光标移动，回车下子。控制光标的方法参考了这篇blog。
然后不回显的输入字符用的getch()，注意windows下getch读回车是读的’\r\n’，也就是只保留了 ‘\r’。
判断是否连成五子的方式是每下一步就检测其四条线上是否有连续相邻的5个子。
Code：
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;conio.h&gt; #include&lt;windows.h&gt; struct Position{ int x,y; }; class ChessBoard{ private: int sta[25][25]; HANDLE Cursor; public: int winner,N;//N: 棋盘大小 ChessBoard(){ N=17,memset(sta,0,sizeof sta),winner=0; Cursor = GetStdHandle(STD_OUTPUT_HANDLE); } void show(){ system("cls"); char ch[3]={' ','O','X'}; for(int i=1;i&lt;=N;i++){ for(int j=1;j&lt;=N;j++) printf("|---"); printf("|\n"); for(int j=1;j&lt;=N;j++) printf("| %c ",ch[sta[i][j]]); printf("|\n"); } for(int j=1;j&lt;=N;j++) printf("|---"); printf("|\n"); } void movecursor(Position p){ SetConsoleCursorPosition(Cursor,{p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96c8dbe36607d4686686e327fb76b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c9b6eb77fabf10051274a27f85fd2f/" rel="bookmark">
			日常随笔——CLion使用过程中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在使用CLion的过程中，新建一个新的C++类，产生对应的.h文件和.cpp文件，但是此时代码框顶端会显示"不属于任何项目目标,代码洞察功能可能无法正常工作" 。即使在Cmakelist.txt文件中已经明确加入了该文件，但依旧解决不了。
解决办法 右键文件夹，将其标记为项目源或头 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca1f58a3865691da7f2bceb01f1674b/" rel="bookmark">
			iOS 深度跳转（scheme、universal link）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到这些文章，这里总结记录一下。
一、前言 首先，我们先来聊一下深度跳转时什么，有哪些方面可以运用。
点击wap页面按钮，唤起对应APP，并且跳转到了相对于的目标页面。比如：微信里浏览商品，点击打开APP，会自动唤起手机里的对应APP，并且会进入到你刚才浏览的商品详情页。
这就是比较直观的：深度跳转
上面的这种情况我们称之为：一键直达（或者一链拉起等，你怎么称呼你开心就好😊）
如果，手机没有安装京东APP，是会先去下载页面，待用户下载完后，点击打开APP依然会跳转到刚才浏览的商品页面
这种情况，我们可以称之为：场景还原
还要一些代码层面的应用也属于深度跳转的业务，比如：销售推广APP，用户点击了销售推广的APP下载链接，然后公司需要统计每个销售推广的量。
这种，就属于深度跳转与统计相关的一些内容了。如果公司产品使用了深度跳转，那必然会有些数据的统计。
对于 【一键直达】，我们可以用iOS里的最简单scheme实现，也可以使用universal link来实现，不过universal link稍微有些烦人的操作（特别是对于第一次使用的，很多坑等着你们🤕），而且universal link 还得要前端配合（个体开发没前端人员那就GG 了😔）。
对于 【场景还原】，我们就要和前端、后台配合开发，并且要定义各种逻辑、协议，客户端、前端、后台都需要有比较大的工作量。
对于不想踩坑、没那么多人力的可以选择一些比较靠谱的公司的SDK，比如：极光的魔链，还可以与极光的JPush 、JMessage 配合使用。
下篇文章为大家讲解如何使用 极光的魔链，已经 极光的魔链 的一些高级使用方法，和避免一些坑。
这篇我们先来了解下 scheme 和 universal link
二、Scheme VS Universal Link Deeplink相关的技术，在wap中唤起app其实应用最最广泛的并不是Universal Link，而是直接Schema跳转
location.href = 'schema://xxxx' 并且一般各大APP都会给自己做一套路由体系，这样其实可以直接在schema头后面对接路由体系，做到一行schema定位打开任意App内功能界面（我就不详细扯路由的事了）
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation { if ([[url absoluteString] hasPrefix:@"schema://"]) { //路由 //[object routeU:[url absoluteString]]; return YES; } } 如果单纯为了实现deeplink -- 在WAP上打开App，并且传递来数据信息，定位App内的具体逻辑，那么Schema就够了，其实没必要上Universal Link.
Schema相当于是很特殊的Url，他是schema://xxx这种样子，如果安装了APP才能支撑跳转这种Schema Url，如果没安装APP就没任何效果，而Universal Link则是把普通url，长http://xxx.xxx.xxx/xxx 这样的Normal Url，如果安装了App，就能像Schema一样传递给App，延续App内逻辑，如果没装App，则还会继续在浏览器里跳转这个Normal Url 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca1f58a3865691da7f2bceb01f1674b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f566500e981f7417f38b7ba9009a565f/" rel="bookmark">
			游戏业务被攻击了怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着游戏行业的高速发展，越来越多的行业从事者开始踏足游戏领域，于此同时游戏行业也成为了网络攻击的重灾区，同行恶意竞争、利用DDOS攻击敲诈等等也愈发严重，那么怎么在这样的环境中保障自身的利益和增强玩家的体验感使遭受攻击时也能让业务稳定的开展呢？这时候选择一款好的防护产品至关重要。
现在阿里云，腾讯云，德迅云安全都专门为了游戏业务开发出了对抗DDOS攻击的游戏盾产品，下面来说说游戏盾是怎么样的。
一、无视流量攻击，游戏盾由高防节点池组成，每个抗D节点都可以轻松防御600G以上的攻击，当发生超大流量攻击时，受影响的节点会自动无缝切换到下一个节点上，保障业务有效开展
二、防掉线功能，通过新SocKet协议，弥补了WinSock链接失败会断开的问题，链接失败自动无缝切换。
三、网络加速功能，分布式多节点多IP，玩家登陆游戏会自动分配到附近的节点上，降低游戏延迟
四、无视CC攻击，当遭遇真实肉鸡发起的TCP连接与协议模拟的功能时可以通过SDK与游戏安全网关的加密隧道彻底解决CC攻击问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d1e660f6fa5469cb7b10138be3fc20/" rel="bookmark">
			IPS和WAF区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
“前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。” 前言 - 床长人工智能教程
WAF与IPS的区别总结
谁是最佳选择？
Web应用防护无疑是一个热门话题。由于技术的发展成熟和人们对便利性的期望越来越高，Web应用成为主流的业务系统载体。在Web上“安家”的关键业务系统中蕴藏的数据价值引起攻击者的青睐，网上流传的Web漏洞挖掘和攻击工具让攻击的门槛降低，也使得很多攻击带有盲目和随机性。比如利用GoogleHacking原理的批量查找具有已知漏洞的应用程序，还有SQL批量注入和挂马等。但对于重要的Web应用（比如运营商或金融），始终有受利益驱动的黑客进行持续的跟踪。
如果说传统的“大而全”安全防护产品能抵御大多数由工具产生的攻击行为，那么对于有针对性的攻击行为则力不从心。而WAF正是应需求而生的一款高端专业安全产品，这也是市场需求细化的必然趋势。但由于其部署和功能方面与IPS有类似，有人提出疑问，为什么不能用IPS，或者说WAF与IPS有什么异同？谁更适合保护Web服务器？
这些疑问其实是有道理的，差异化的产生在于高端需求是不同的，从而需要细化功能贴合具体需求和符合应用现状的产品，这也是用户需求是随着业务自身的发展所决定的。
保镖和保安
为了更好的理解两款产品差异性，我们先用这个保镖（WAF）和保安（IPS）比喻来描述。
大楼保安需要对所有进出大楼人员进行检查，一旦发现可疑人员则禁止他入内，但如果混进“貌似忠良”的坏人去撬保险柜等破坏行为，大楼保安是无能为力的。
私人保镖则是指高级别、更“贴身”的保护。他通常只保护特定的人员，所以事先需要理解被保护人的身份、习惯、喜好、作息、弱点等，因为被保护人的工作是需要去面对不同的人，去不同的场合，保镖的职责不能因为危险就阻止、改变他的行为，只能去预见可能的风险，然后量身定做合适的保护方案。
这两种角色的区别在于保安保护的是整个大楼，他不需要也无法知道谁是最需要保护的人，保镖则是明确了被保护对象名单，需要深刻理解被保护人的个性特点。
图 1.1 保镖和保安
通过上面的比喻，大家应该明白两者的之所以会感觉相似是因为职责都是去保护，但差异在于职能定位的不同。从技术原理上则会根据定位来实现。下面通过几个层面来分析WAF和IPS的异同。
事件的时间轴
对于安全事件的发生，有三个时间点：事前、事中、事后。传统的IPS通常只对事中有效，也就是检查和防护攻击事件，其他两个时间点是WAF独有的。
图 1.2 事件时间轴
如上图所示，事前是指能在事件发生之前通过主动扫描检测Web服务器来发现漏洞，通过修复Web服务器漏洞或在前端的防护设备上添加防护规则等积极主动手段来预防事件发生。事后则是指即使Web服务器被攻击了，也必须有网页防篡改功能，让攻击者不能破坏网站数据。
为什么不能具备事中的100%防护能力？其实从以下几个方面就知道对于事中只能做到相对最佳防护而不能绝对，因为：
1. 软件先天是有缺陷的，包括应用到第三方的组件和函数库无法控制其安全性；
2. 应用程序在更新，业务是持续发展的、动态的，如果不持续监控和调整安全策略，也是会有疏漏的；
3. 攻击者永远在暗处，可以对业务系统跟踪研究，查找漏洞和防护缺陷，用各种变形繁杂的手法来探测，并用于攻击；
4. 任何防护设备都难以100%做到没有任何缺陷，无论是各种算法还是规则，都是把攻击影响降低到最小化。
所以需要用一个可闭环又可循环的方式去降低潜在的威胁，对于事中疏漏的攻击，可用事前的预发现和事后的弥补，形成环环相扣的动态安全防护。事前是用扫描方式主动检查网站并把结果形成新的防护规则增加到事中的防护策略中，而事后的防篡改可以保证即使疏漏也让攻击的步伐止于此，不能进一步修改和损坏网站文件，对于要信誉高和完整性的用户来说，这是尤为重要的环节。
图 1.3 WAF安全闭环
如果仅仅是对于事件的时间轴有区别，那么还是可以采用其他产品来进行辅助，但关键的是事中的防护也是有深度的差异，那么下面我们来谈谈对于事中的差异。
事中，也就是实时防护，两者的区别在于一个是纵横度，一个是深度。IPS凸显的优势在于纵横度，也就是对于网络中的所有流量进行监管，它面对的是海量数据，下图的TCP/IP模型中网络流量从物理层到应用层是逐层递交，IPS主要定位在分析传输层和网络层的数据，而再往上则是复杂的各种应用层协议报文，WAF则仅提供对Web应用流量全部层面的监管。　图 1.4 数据结构图
监管层面不同，如果面对同样的攻击，比如SQL注入，它们都是可以防护的，但防护的原理有区别，IPS基本是依靠静态的签名进行识别，也就是攻击特征，这只是一种被动安全模型。如下是一个Snort的告警规则：
alert tcp $EXTERNAL_NET any -&gt; $HTTP_SERVERS $HTTP_PORTS （msg:“SQL Injection - Paranoid”; flow:to_server, established;uricontent:“.asp”;pcre:“/ （\%27）|（\‘）|（\-\-）|（%23）|（#）/i”; classtype:Web-application-attack; sid:9099; rev:5;） 这里主要是检查在SQL注入中提交的元字符，包括单引号（ ’ ）和双横（ – ），从而避免注入’1 or 1=1— 之类的攻击发生，但同时又要考虑这些元字符转换成Hex值来逃脱过滤检查，于是又在规则里增加了其对应的十六进制编码后的字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d1e660f6fa5469cb7b10138be3fc20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4a7ce560bd6e6c46a6be50896a134c/" rel="bookmark">
			排序算法——快速排序（Quicksort）基准值的三种选取和优化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 快速排序的基本原理1.1快速排序的基本思路： 2 举例说明总结： 3 代码演示4 关于快排的基准值的选取4.1 固定位置选取基准值测试数据： 4.2 随机选取基准值测试数据 4.3 三数取中法，选取基准元 5 四种优化方式优化1：当待排序序列的长度分割到一定大小后，使用插入排序优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。 参考链接： 1 快速排序的基本原理 关于快速排序，它的基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。
1.1快速排序的基本思路： 1.选取基准值，通过不同的方式挑选出基准值。
2.用分治的思想进行分割，通过该基准值在序列中的位置，将序列分成两个区间，在准值左边的区间里的数都比基准值小（默认以升序排序），在基准值右边的区间里的数都比基准值大。
3.递归调用快速排序的函数对两个区间再进行上两步操作，直到调用的区间为空或是只有一个数。
2 举例说明 假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（就是一个用来参照的数）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，类似下面这种排列。
3 1 2 5 4 6 9 7 10 8 在初始状态下，数字 6 在序列的第 1 位。我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k 位为分界点，左边的数都小于等于 6，右边的数都大于等于 6。
方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f4a7ce560bd6e6c46a6be50896a134c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4579e61249903a4cc40019d4bd0567e2/" rel="bookmark">
			maven多模块打包,package失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多模块之间有依赖,执行package失败,总是去线上仓库拉去依赖模块,这时将root模块执行一遍install即可完成所有模块的打包.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1fab02d3a697fda949d385203f9c5e/" rel="bookmark">
			Ubuntu20.04 安装llvm11&#43;版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 很多时候我们要安装LLVM在Ubuntu上，但是使用llvm-config --version得到的却是10.0版本。这里给出一种方法可以安装11以上版本。
以Ubuntu20.04LTS版本为例： 一般的方法是apt-get，你会发现使用的还是llvm10，即使是安装了11。
这里的方法是使用二进制预编译方法
sudo mkdir -p /usr/local cd /usr/local sudo wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz sudo tar xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz sudo mv clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04 llvm linux确实很容易出现各种麻烦。我这里解决了，有的朋友仍然没有解决。故仅在此记录一种可能的解决方式吧。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/261/">«</a>
	<span class="pagination__item pagination__item--current">262/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/263/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>