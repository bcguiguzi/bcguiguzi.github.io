<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a880da2349330a5f301188f36eee89c/" rel="bookmark">
			el-table表格序号倒序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-table-column fixed label="序号" align="center" width="50"&gt; &lt;template slot-scope="scope"&gt; {{ computedIndex( scope.row.index) }} &lt;/template&gt; &lt;/el-table-column&gt; // data listQuery: {// 分页 superQueryJson: '', currentPage: 1, pageSize: 20, sort: 'desc', sidx: 'createtime' }, total: 0, // 总数 computed: { computedIndex() { return val =&gt; { return this.total - (val + this.listQuery.pageSize * (this.listQuery.currentPage - 1)) } } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a18d84d58141f013b89c4e60eb3905/" rel="bookmark">
			java-File
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java 删除目录及目录下的文件
import java.io.IOException; import java.nio.file.*; public class DeleteDirectoryExample { public static void main(String[] args) { // 指定要删除的目录路径 Path directoryPath = Paths.get("C:\\path\\to\\directory"); try { // 删除目录及其下的文件 Files.walk(directoryPath).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete); System.out.println("目录及其下的文件已成功删除！"); } catch (IOException e) { System.err.println("删除目录及其下的文件时发生错误：" + e.getMessage()); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576177cb5542dc4ecfd8c6548b1304e9/" rel="bookmark">
			【IEEE独立出版|EI会议征稿】2024年第四届消费电子与计算机工程国际学术会议（ICCECE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年第四届消费电子与计算机工程国际学术会议（ICCECE 2024）
2024 4th International Conference on Consumer Electronics and Computer Engineering
进入21世纪以来，计算机技术的高速发展带来了消费电子产品的快速更迭。在技术迅速发展历程中，众多高校与企业研发了许多相关技术和产品，取得了丰硕学术和应用成果。2024第四届消费电子与计算机工程国际学术会议将于2024年1月12-14日在中国广州召开。本次会议主要围绕消费电子发展、网络信息安全、人工智能、物联网等研究领域展开讨论。大会将就目前的热点问题展开研讨，共享研究成果，推动相关研究与应用的发展与进步，推进学科的发展和促进人才培养。我们诚挚欢迎相关领域中的相关各个专家学者踊跃参会。
【IEEE独立出版 | 往届均完成检索】
重要信息
大会官网：www.iccece.org（点击参会/投稿）
大会地点：中国·广州
大会时间：2024年1月12-14日
收录检索：EI/SCOPUS
主办单位
*ICCECE 2024已被IEEE收录进会议列表！详情可查询：click
征文主题 ICCECE 2024 将征集并展示高质量的最新研究成果文章，并将组织相关的主题研讨。会务组诚邀世界各地的专家学者提交您最的论文，并与其他参会者分享您的成果与经验。征文主题包括但不限于:
Track I：消费电子发展与应用
（汽车CE应用，信号和图像处理，CE中的机器学习，深度学习和AI等）
Track II：计算机与网络信息安全
（信息系统，互联网和边缘计算，区块链协议的安全性，计算机的安全性和隐私等）
Track III：人工智能与机器学习
（人工智能，人机交互和用户体验，虚拟现实，增强现实和显示，计算机视觉与图像处理等）
Track Ⅳ：物联网与传感器技术
（物联网，传感器和执行器系统，音频/视频系统和信号处理，射频，无线和网络技术等）
... ...
更多征稿主题，请查看大会官网
2024 4th International Conference on Consumer Electronics and Computer Engineering (ICCECE 2024)
论文评审 所有投稿将有3轮评审。组委务将首先进行初步审核，在这一阶段，将审核文章结构主题方向是否符合要求。通过初审审核的每篇文章将提交2-3位独立审稿人进行同行评审，审稿人将根据论文集要求，预定的标准，文章创新性，完整性以及语法等评估文章作出评定。
投稿要求
1. 文章必须用英文书写；
2. 文章须按照会议模板排版；
3. 文章主题须符合会议征文主题；
4. 文章页数不少于4页；
5. 文章应是原创且从未公开发表； 6. 文章应具有一定创新性和科研性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576177cb5542dc4ecfd8c6548b1304e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85f783458f80278e4f93d531557492e/" rel="bookmark">
			分割YooChoose数据集为YooChoose1/4、YooChoose1/64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的 源YooChoose数据集十分庞大，有上千万级别的数据，在测试验证模型性能时加载起来十分费劲。
脚本思路 使用数据集中session_id作为滤网对源数据进行过滤，过滤出2百万个不同的session_id作为训练集。
具体步骤 （1）提取2M个不同的session_id （2）使用这些session_id过滤原始数据
（3）保存为新数据集
代码 import pandas as pd # 读取原始CSV文件 df = pd.read_csv('../Datasource/yoochoose-clicks.dat') df.columns = ['session_id', 'timestamp', 'item_id', 'category'] # 确定前200万个唯一的 session_id unique_sessions = df['session_id'].unique()[:2000000] # 使用这些 session_id 过滤原始 DataFrame top_2m_sessions = df[df['session_id'].isin(unique_sessions)] # 保存提取的数据为新的dat文件，不包括列名 top_2m_sessions.to_csv('../Datasource/yoochoose-clicks_2M.dat', index=False, header=False) 分割后效果 其他 需要YooChoose数据集的可以私信或评论发。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40943249beec2fdc6fbd9ca7cd6429e5/" rel="bookmark">
			vue面试面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVVM
ViewModel是一个与View和Model交互的中间层，它通过双向绑定机制将View的变化及时反映到Model中，同时将Model的数据变化同步到View中。
双向绑定
(1) 定义: 数据变化视图会自动更新，视图变化数据也会更新
(2) 原理: 数据劫持 + 发布订阅者模式
(3) 实现：采用Object.defineProperty()对数据进行劫持来监听数据变化，并通过getter/setter方法对数据进行读写。其次vue通过发布订阅者模式，维护了一个订阅者数组，当数据发生改变时，vue会通知所有订阅者进行更新，因此当用户在页面上进行修改时。Vue会更新对应的数据，并通知所有订阅者更新视图，同时当数据发生变化时，Vue也会更新对应视图，通过这样的机制，Vue实现了双向绑定
(4) 订阅者是一个概念，它是用于管理更新视图的对象，当数据发生变化时，Vue会通知所有的订阅者进行更新。每一个挂载到视图上的组件或者每一个watcher都可以被看作是一个订阅者，他们订阅了某一个数据的变化，并等待数据发生变化时进行更新，订阅者是Vue实现双向数据绑定的关键组成部分
数据代理
通过一个对象obj2代理对另一个对象obj1中属性x的操作，在vue中，就是把_data中的属性直接放到vm上，是通过vm对象来代理data对象中的属性，好处就是方便操作data
v-model、v-bind
1、v-bind是单向绑定，用来绑定数据和属性以及表达式，数据只能从data流向页面。:
2、v-model是双向绑定，数据能从data流向页面，也能从页面流向data。
3、v-bind可以给任何属性赋值(包括绑定class样式)，v-model只能给表单类，也就是具有value属性的元素进行数据双向绑定，注意，v-model不能修饰表达式
compute、watch
compute：有缓存，不用多次读取，所依赖的数据变化时才重新执行计算属性，method没有缓存要多次读取
watch：监视属性变化时，回调函数handler自动调用，监视属性必须存在，可以开启深度监视
区别：计算属性不能开启异步任务，监视属性可以开启异步任务
绑定class和style样式
用:class :style绑定样式 数组写法，对象写法，字符串写法
v-if v-show
v-if 指令会动态地创建或移除 DOM 元素
v-show display:none 控制元素的显示与隐藏
v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此：
如果需要非常频繁地切换，则使用 v-show 较好
如果在运行时条件很少改变，则使用 v-if 较好
v-for key v-for="(p,index) in person" :key="index/p.id"v-for="(val,k) in object" 可以遍历数组对象字符串
会出现的问题：key是vue内部在用的，用index作为key会错乱，用p.id唯一标识不会乱，这是虚拟dom在对比时数组顺序打乱，就出现顺序错乱的问题，没有key会自动用index作为key则顺序可能会乱并开销很大
虚拟DOM：提高性能：通过在DOM树中创建、更新和删除虚拟节点，而不是直接操作真实DOM，可以减少浏览器进行重绘和重排的次数，从而提高应用程序的性能和响应速度。方便组件化开发；创建真实DOM成本较高，如果用js对象来描述一个DOM节点，创建的成本相对较低。
diff算法
数据改变=》setter=》Dep.notify=》watcher调用patch(old,new)=》更新
Dep维护了一个观察者数组，数据改变了就调用notify方法通知所有watcher更新，watcher就调用patch函数
patch操作：两个参数old，new
没有新节点，则直接调用 destory 销毁节点；
没有旧节点，代表新建，直接调用 createElem 创建节点；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40943249beec2fdc6fbd9ca7cd6429e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcfd1986b93c26beecb529f34efcc77/" rel="bookmark">
			python | Pandas库数据预处理-重复值篇：drop_duplicates()函数及其subset参数、keep参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章 python | Pandas库数据预处理-缺失值篇：info()、isnull()、dropna()、fillna()函数https://blog.csdn.net/m0_61523149/article/details/124009296 目录 原数据
导入数据
drop_duplicates()：去重函数
subset参数：设置去重参照列
keep参数：设置去重要保留的数据
原数据 导入数据 import pandas as pd student = pd.read_excel(r'E:\2022Python\重复值数据.xlsx') # 原数据 print(student) 输出结果如下：
学号 姓名 性别 班级 0 1 小明 男 1 1 1 小明 男 1 2 2 小红 女 2 3 2 小聪 男 2 4 3 小亮 男 1 5 3 小丽 女 2 6 4 小晶 男 3 7 5 小美 女 4 drop_duplicates()：去重函数 # 按所有列去重，默认保留第一个 print(student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcfd1986b93c26beecb529f34efcc77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576fab5acdd711498778481ef1e45547/" rel="bookmark">
			python|列表常用方法操作2.0完善版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、增加元素
1、append()
2、insert()
3、例子
二、删除元素
1、del
2、pop()
3、remove()
4、例子
三、排序
1、sort()
2、sorted()
3、reverse()
4、例子
四、列表解析
1、list(range())
2、例子
五、易错点
1、例子
六、列表往期内容
一、增加元素 1、append() 作用：从列表末尾添加元素。
2、insert() 作用：根据指定位置添加元素。
3、例子 代码：
numbers1 = ['one', 'two'] numbers1.append('three') # 从列表末尾添加 print(numbers1) numbers2 = ['one', 'two'] numbers2.insert(1, 'three') # 根据指定位置添加 print(numbers2) 运行结果：
['one', 'two', 'three'] ['one', 'three', 'two'] 二、删除元素 1、del 作用：删除指定元素。
2、pop() 作用：删除指定位置（不指定默认最后一个）
3、remove() 作用：根据值删除元素，若有多个只删除第一次出现的值。
4、例子 代码：
numbers3 = ['one', 'two', 'three', 'four'] del numbers3[0] # 删除单个指定元素 print(numbers3) del numbers3[1:3] # 删除多个指定元素 print(numbers3) numbers4 = ['one', 'two', 'three', 'four'] element = numbers4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576fab5acdd711498778481ef1e45547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3da395fd4e5b5f1fa17918650c278ba/" rel="bookmark">
			C&#43;&#43; 返回值优化RVO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 C++的返回值优化（Return Value Optimization，也被称为RVO）是一个重要的优化技术，可以提高程序的性能。返回值优化（RVO）是指编译器对临时变量的处理机制。对于函数返回一个对象的情况，编译器在生成代码时会按照以下规则进行优化：
1.如果返回值是一个非静态局部变量，并且该变量是通过复制返回（Return by Value）方式返回的，编译器会尝试将该返回值直接构造在调用方的返回值处，而不是返回一个副本。
2.如果返回值是一个匿名临时变量，编译器会优化掉这个临时变量的构造和析构函数，直接将其值传递给函数返回值的目标对象。
其中，第一种情况的优化被称为NRVO（Named Return Value Optimization，命名返回值优化或者具名返回值优化）
RVO的核心思想是：在函数内部创建的对象，在函数调用结束后会立即被销毁，这些临时对象的生命周期比较短暂，因此可以直接将它们构造在调用方的返回值处，避免产生额外的开销。
二、示例分析 static int counter = 0; // counter to identify instances class Data { public: Data() : id(++counter) { std::cout &lt;&lt; "ctor " &lt;&lt; id &lt;&lt; std::endl; } Data(const Data&amp; other) : id(++counter) { std::cout &lt;&lt; "copy ctor " &lt;&lt; id &lt;&lt; std::endl; } Data&amp; operator=(const Data&amp; other) { std::cout &lt;&lt; "copy assign " &lt;&lt; other.id &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3da395fd4e5b5f1fa17918650c278ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7a75922b4d89077f227b1ed9ab8e87/" rel="bookmark">
			十六进制数列求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高精度数组的集大成
做的时候在和高中同学叙叙旧，差点寄掉
代码如下：
#include&lt;stdio.h&gt; void expand(int len); const char hexadecimal[17] = "0123456789ABCDEF"; int result[20], mid[20], l_result[100]; int main(void) { char tmp; int len, length = 0, len2 = 1; scanf("%c %d", &amp;tmp, &amp;len); for(int i = 0; i &lt;= 15; i++) if(hexadecimal[i] == tmp) { mid[len - 1] = i; break; } while(mid[len - 1] &lt;= 15) { int ext = 0, i; expand(len); for(i = 0; i &lt; len; i++) { ext += result[i] + mid[i]; result[i] = ext % 16; ext /= 16; } while(ext) { ext += result[i]; result[i++] = ext % 16; ext /= 16; } length = (length &gt; i) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f7a75922b4d89077f227b1ed9ab8e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085daee8fef9530b74eef43fd55b8e43/" rel="bookmark">
			SpringBoot使用Swagger编写接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、导入坐标 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 二、编写配置类 命名自己定义
@Configuration // 配置类
@EnableSwagger2 // 开启 swagger2 的自动配置
public class SwaggerConfig{ }
具体代码如下
package com.example.demo.utils.config; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.ParameterBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Parameter; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; import java.util.List; @Configuration @EnableSwagger2 public class SwaggerConfig { @Value(value="true") private Boolean swaggerEnabled; @Bean public Docket productApi() { // 设置请求头 List&lt;Parameter&gt; parameters = new ArrayList&lt;&gt;(); parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085daee8fef9530b74eef43fd55b8e43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34564793722207b9854d4b0447143db8/" rel="bookmark">
			c&#43;&#43;以及golang基于protobuf进行简单通讯【c&#43;&#43;与golang】【项目研究】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、C++和Go语言都可以对protobuf进行操作二、protobuf编写与生成1、protobuf格式2、protobuf的编写2、两种语言的生成 三、c++与go语言操作protobuf不同点四、c++与go语言基于protobuf进行网络通信1、go语言编写服务提供者2、c++服务调用者 总结 前言 当我们需要在不同的编程语言之间进行通讯时，通常会遇到数据格式不兼容的问题。在这种情况下，使用数据序列化工具就成为了一种非常有效的解决方案。Google 推出的 Protocol Buffers（简称 protobuf）就是一种非常常用的数据序列化工具，它可以帮助我们快速实现跨语言、跨平台的数据传输等应用。
C++ 和 Go 是两种常用的编程语言，本文将介绍如何利用 protobuf 实现 C++ 和 Go 语言之间的通讯。为微服务框架打基础。
一、C++和Go语言都可以对protobuf进行操作 Protocol Buffers 是一种轻巧高效的数据序列化工具，通过将结构化数据编码为二进制格式的消息，从而实现方便地进行数据交换和存储，并能够在不同的语言和平台间进行数据互通。因此利用 protobuf 实现 C++ 和 Go 语言之间的通讯是完全可行的，只要共同采用相同的消息格式定义，并通过相应语言的protobuf库进行序列化和反序列化。
与其他序列化方式相比，protobuf 有更高的性能和更小的数据体积，因此广泛应用于 Google 内部以及众多开源项目中。
除了基础的序列化功能，Protobuf 还提供了其他高级特性，如扩展、注释、默认值、嵌套类型、枚举等，使其更加灵活、易用。
总之，protobuf 是一种优秀的数据序列化工具，可帮助开发者快速实现跨语言、跨平台的数据传输等应用。
二、protobuf编写与生成 1、protobuf格式 首先是声明protobuf的版本，以及代码所在的包（对于C++来说是namespace），如果需要生成服务类以及rpc方法描述就需要配置cc_generic_services。
syntax = "proto3"; // 声明了protobuf的版本 package fixbug; // 声明了代码所在的包（对于C++来说是namespace） // 定义下面的选项，表示生成service服务类和rpc方法描述， option cc_generic_services = true; 定义数据，可以定义嵌套类型，枚举以及数组等等类型
message ResultCode { int32 errcode = 1; bytes errmsg = 2; } // 数据 列表 映射表 // 定义登录请求消息类型 name pwd message LoginRequest { bytes name = 1; bytes pwd = 2; } // 定义登录响应消息类型 message LoginResponse { ResultCode result = 1; bool success = 2; } message GetFriendListsRequest { uint32 userid = 1; } message User { bytes name = 1; uint32 age = 2; // 枚举 enum Sex { MAN = 0; WOMAN = 1; } Sex sex = 3; } message GetFriendListsResponse { ResultCode result = 1; repeated User friend_list = 2; // 定义了一个列表类型 } 定义描述rpc方法的类型 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34564793722207b9854d4b0447143db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0062af2e00671a4b62f4462a2eb9da/" rel="bookmark">
			一个较为实用的日志类【Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、LogUtil 类提供了以下功能二、代码三、使用 前言 在软件开发中，日志记录是一项重要的任务，它可以帮助我们跟踪应用程序的行为、故障排查和性能分析。为了简化日志记录的过程并提供更多的灵活性，下面介绍一个名为 LogUtil 的实用日志类。
该日志类能够将信息输出到终端，同时存储到指定的log文件中。
一、LogUtil 类提供了以下功能 LogUtil 类提供了以下功能：
初始化函数：构造函数接受参数 log_path（日志文件路径）、log_name（日志文件名）、clear_content（是否清空日志文件内容，默认为 False）、no_level（是否禁用日志级别，默认为 False）、no_time（是否禁用时间戳，默认为 False）和 cmd_print（是否在命令行打印日志，默认为 True）。
日志文件处理：在初始化时，LogUtil 类会检查并创建日志文件路径，如果指定了清空日志文件内容选项，将清空日志文件的内容。日志文件的路径和名称由 log_path 和 log_name 参数确定。
日志级别和格式：LogUtil 类使用 logging 模块创建一个日志记录器（logger），并设置日志级别为 DEBUG。根据传入的参数，可以选择是否在日志记录中包含日志级别和时间戳。日志格式根据设置的参数动态生成。
文件处理器：LogUtil 类使用 logging 模块的 FileHandler 创建一个文件处理器（file_handler），用于将日志记录写入日志文件。文件处理器的级别也设置为 DEBUG，并使用上述定义的日志格式进行格式化。
日志记录方法：LogUtil 类提供了四种日志记录方法：info、debug、error 和 warning。这些方法将消息记录到日志文件中，并根据 cmd_print 参数决定是否在命令行打印相应的日志消息。
二、代码 import os import logging class LogUtil: def __init__(self, log_path, log_name, clear_content=False, no_level=False, no_time=False, cmd_print=True): if not os.path.exists(log_path): os.makedirs(log_path) file_path = os.path.join(log_path, log_name + '.log') if clear_content: open(file_path, 'w').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0062af2e00671a4b62f4462a2eb9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9734ee1aeebbfd5abe428c66d923a8b6/" rel="bookmark">
			远程连接工具为什么连接不上我的虚拟机？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据网上的分享贴配置了虚拟机的IP地址和子网掩码、网关，但是在xshell和mobaxterm都不能连接上，包括检查了ssh服务是否开启，selinux和firewalld，甚至还检查了ssh配置文件中写的端口是否为22，最后才发现是虚拟机网卡ens33和VMnet8写的ip是一样的，所以产生了冲突
其实在这里，我们需要把它们设置在同一个网段上不同的地址，保证在同一个局域网内。
更改他们的IP成同网段的不同地址后，再用远程连接工具连接我的虚拟机IP就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d78f51d0f927b9c55dc5609180aa1b/" rel="bookmark">
			UniTask异步解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是一个高性能，0GC的async/await异步方案
协程缺点：
依赖monobehaviour
不能进行异常处理
方法返回值获取困难
c#原生Task：
优点：
不依赖monobehaviour
可以处理异常
缺点：
Task消耗大，设计跨线程操作
uniTask
优点:
继承c#的task优点
基于值类型解决方案，0GC
默认使用主协程
https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask
延时操作：Delay DelayFrame Yield NextFrame WaitForEndOfFrame
等待操作: Wait Until Wait Until Value Changed
条件操作: When All When Any
异步委托生成UniTask及相关的封装: UniTask.Void UniTask.Defer UniTask.Lazy
取消：CancellationToken GetCancellationTokenOnDeatory()
异常处理：Try Catch SuppressCancellationThrow
超时处理：取消的变种，通过 CancellationTokenSouce.CancelAfterSlim(TimeSpan)设置超时并将CancellationToken 传递给异步方法
Forget()
事件处理：
1.异步事件 Lamaba 表达式注册 使用 UniTask.Action 或 UniTask.UnityAction
2.UGUI 事件转换为可等待事件
AsAsyncEnumerable
3.MonoBehaviour 消息事件都可以转换异步流
异步Linq
异步迭代器
响应式组件
协程和task
void Start() { StartCoroutine(waitting()); } Ienumerator waitting() { yield return new waitForSeconds(2); } using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d78f51d0f927b9c55dc5609180aa1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df5d9f7b849bdc68b1e3252dd864adc/" rel="bookmark">
			Flutter-使用setState来实现动态UI刷新实现UI交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 setState()简介例子详细介绍setState的深入说明State对象重新调用StatefulWidget的build只会差异化更新UI setState()简介 setState() 函数的作用是标记 StatefulWidget 中的 State 发生变化,需要重新构建 UI。即让Flutter架构自动实时刷新UI。
当 StatefulWidget 的 State 发生变化时,调用 setState() 通知 Flutter 框架,Flutter 框架接受到通知后,会重新调用 StatefulWidget 的 build() 方法来构建 UI。
例子 举个简单的例子:
class Counter extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() { return _CounterState(); } } class _CounterState extends State&lt;Counter&gt; { int _count = 0; @override Widget build(BuildContext context) { return Text('Count: $_count'); } void increment() { setState(() { _count++; }); } } 这里有一个 StatefulWidget Counter,里面维护了一个状态 _count。当我们调用 increment() 方法时,调用了 setState() 通知 Flutter 框架 _count 已经变化,Flutter 框架会重新调用 build() 方法构建 UI,更新 Text 的内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df5d9f7b849bdc68b1e3252dd864adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d90d3b747a9bb544213f5683aa6d2bb/" rel="bookmark">
			二层转发的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、网络拓扑 二层即网络接入层/数据链路层，处理单段链路（局域网）上的端到端报文交互。局域网（Local Area Network， LAN）指在某一区域内由多台网络设备互联组成的网络。
pc1接入switch lan1口，pc2接入switch lan2口。pc1配置静态ip192.168.0.10，子网掩码为255.255.255.0pc2配置静态ip192.168.0.20，子网掩码为255.255.255.0 二层转发是基于 MAC 地址进行数据包的转发，本章以此拓扑为基础，通过 报文从 PC1 发出，如何被设备转发到 PC2，并且如何将 PC2 的报文转发回 PC1， 将其中所发生的过程通过一步一步的方式进行学习。
2、局域网互通 首先查看pc1 ping pc2发送了那些报文：
通过抓包查看只有ARP和ICMP两种报文，且都是跟IP相关的报文。
3、ICMP报文 Pc1发送 ICMP Echo Request请求 Pc2回复ICMP Echo Reply 当Pc1能正常收到Pc2的回复报文时，表示此时IP可达。
4、ARP报文 地址解析协议（Address Resolution Protocol），是根据 IP 地址获取物理地址的一个 TCP/IP 协议。报文格式如下：
ARP请求 字段
字节数
描述
硬件类型
2
1，Ethernet，即局域网为以太网
协议类型
2
0x0800,IPv4
硬件地址长度
1
6,以太网采用MAC编址
协议地址长度
1
4，IPv4长度为4
操作码
2
1,ARP请求
发送端MAC
6
PC1 MAC
发送端IP
4
PC1 IP
接收端MAC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d90d3b747a9bb544213f5683aa6d2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cc164082054156237b35c136ce2232/" rel="bookmark">
			huggingface HF_HOME 更换缓存目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，下载数据集并缓存到 ~/.cache/huggingface/dataset.
您可以通过设置HF_HOME环境变量来自定义缓存的文件夹。
若配置完环境，发现并没有生效，基本解决思路: 重新打开命名窗口、应用。
若还不生效：那就 重启电脑！
from datasets import load_dataset raw_datasets = load_dataset("glue", "mrpc") raw_datasets 到此默认缓存目录切换成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d702956ec1fb579970bc131bddff39b6/" rel="bookmark">
			在线课堂课程订购微信小程序的设计与实现（附源码 配置 文档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程订购小程序 一、研究背景与意义二、系统设计三、系统实现四、系统测试与优化五、结论六、界面展示七、源码获取 随着互联网技术的快速发展和普及，教育行业逐渐走向线上化。尤其是在COVID-19疫情的影响下，线上教育得到了前所未有的推动和发展。在这样的背景下，我们设计并开发了一个《在线课堂课程订购小程序》，以满足线上教育市场的需求，提高教育资源的利用效率，同时为广大学生和教师提供更加便捷、个性化的在线教育服务。
一、研究背景与意义 在传统的教育模式下，学生和教师需要在固定的时间和地点进行面对面的教学和学习，这无疑限制了双方的自由度和效率。随着信息技术的不断发展，线上教育逐渐成为一种趋势，它打破了时间和空间的限制，使得学生和教师可以在任何时间、任何地点进行教与学活动。此外，线上教育还可以实现教育资源的共享和优化，提高教育公平性和普及率。
然而，现有的线上教育平台往往功能单一、操作繁琐，无法满足用户多样化的需求。此外，由于缺乏有效的管理和监督机制，线上教育平台存在课程质量参差不齐、用户信息泄露等问题。因此，开发一款功能完善、操作简便、安全可靠的在线课堂课程订购小程序具有重要的现实意义和市场需求。
二、系统设计 用户角色设计 本系统分为管理员、教师和用户三种角色。管理员拥有最高的权限，可以对系统进行全面管理和维护；教师拥有课程管理、资源上传、订单处理等权限；用户拥有课程筛选、下单购买、在线讨论等权限。
功能模块设计 （1）管理员模块
管理员模块主要负责整个系统的管理和维护工作，包括分类管理、课程管理、课程视频、资料管理、用户管理、教师管理、系统管理等。管理员可以对各类信息进行添加、删除、修改等操作，同时对用户和教师的权限进行管理。
（2）教师模块
教师模块主要针对教师用户，包括我的课程、课程视频、课程资料、我的订单、问题回复、修改密码等功能。教师可以对自己的课程进行添加、修改和删除，同时可以上传相应的课程资料和视频，查看自己的订单情况并回复学生问题。
（3）用户模块
用户模块主要针对普通用户，包括分类筛选、课程搜索、在线讨论、资源下单、课程订购、个人中心等功能。用户可以通过分类筛选和课程搜索找到自己需要的课程，同时可以在线讨论问题、下单购买课程以及查看和管理自己的个人信息。
数据库设计 本系统采用MySQL数据库作为数据存储和处理的核心部分。数据库主要包括分类表、课程表、视频表、资料表、用户表、订单表等。通过对这些表进行设计和优化，可以实现数据的快速查询和处理，保证系统的性能和稳定性。
三、系统实现 服务器架构实现 本系统采用PHP语言的ThinkPHP框架进行开发。ThinkPHP是一个轻量级、易扩展的PHP框架，具有快速构建企业级应用的能力。通过利用ThinkPHP框架的路由功能，我们能够根据用户请求的不同路径将请求映射到相应的控制器和方法进行处理。同时，我们还可以通过配置缓存和优化数据库查询来提高系统的响应速度和性能。
功能模块实现 在系统实现过程中，我们采用模块化的开发方式将各个功能模块独立出来，便于维护和管理。同时通过前后端分离的方式实现数据的交互和功能的调用。管理员可以通过后台管理页面进行分类管理、课程管理、课程视频上传下载等操作；教师可以通过教师管理页面进行我的课程设置上传视频及资料等操作；用户可以通过前台页面进行课程的筛选搜索下单购买等操作并可在线讨论等。前后端分离的设计使得各个模块之间的数据交互更加清晰和便捷同时提高系统的稳定性和可维护性。
3. 数据库操作实现
本系统采用ThinkPHP框架提供的ORM（对象关系映射）机制，使得我们可以方便地进行数据库操作。通过定义模型类和数据库表之间的映射关系，我们可以实现对数据库表的增删改查等操作。同时，ThinkPHP框架还提供了丰富的查询构造器和数据库操作扩展类，使得我们可以更加灵活地进行数据库操作，提高了开发效率和代码可读性。
四、系统测试与优化 为了确保系统的稳定性和可靠性，我们对系统进行了全面的测试和优化工作。测试包括单元测试、功能测试和性能测试等，优化包括代码优化、数据库优化和服务优化等。
单元测试 单元测试针对每个模块的函数和方法进行测试，确保每个模块的功能正常工作。我们编写了详细的测试用例，包括正常情况和异常情况的处理，对每个函数和方法进行严格的测试和验证。
功能测试 功能测试针对整个系统的功能进行测试，确保各个功能模块之间的协调和正常运行。我们模拟了不同用户角色和使用场景下的操作，对系统的各项功能进行了全面的测试和验证。
性能测试 性能测试针对系统的响应速度和负载能力进行测试，确保系统在高负载情况下仍能保持稳定运行。我们通过模拟大量用户同时访问系统，对系统的性能进行了测试和评估，并根据测试结果进行了相应的优化和调整。
数据库优化 数据库优化针对数据库查询和数据结构设计进行优化，提高数据库的性能和响应速度。我们通过优化数据库表的结构、使用索引和缓存等技术手段，提高了数据库的查询效率和响应速度。
服务优化 服务优化针对服务器的配置和负载均衡进行优化，提高系统的负载能力和稳定性。我们通过对服务器进行合理的配置和优化，包括调整PHP解释器的参数、使用缓存机制等，提高了系统的性能和稳定性。
五、结论 《在线课堂课程订购小程序》课题研究背景是基于当前线上教育市场的需求和发展趋势，针对现有线上教育平台存在的问题和不足而展开的。本系统通过设计合理的用户角色和功能模块，采用PHP语言的ThinkPHP框架和MySQL数据库进行开发，实现了管理员、教师和用户之间的数据交互和功能调用。同时，通过全面的测试和优化工作，确保了系统的稳定性和可靠性。本系统的实现可以为线上教育市场提供一种功能完善、操作简便、安全可靠的在线课堂课程订购小程序解决方案。
六、界面展示 七、源码获取 欢迎大家点赞、收藏、关注、评论、批评啦 、查看👇🏻👇🏻获取联系方式👇🏻👇🏻A7788_1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3470dfa708c90d0f1441f04c9c2058c/" rel="bookmark">
			clickhouse笔记02--安装测试 clickvisual
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clickhouse笔记02--安装测试 clickvisual 介绍前置条件部署测试优缺点说明 介绍 clickvisual 是一个轻量级的开源日志查询、分析、报警的可视化平台，致力于提供一站式应用可靠性的可视化的解决方案。既可以独立部署使用，也可作为插件集成到第三方系统。目前是市面上唯一一款支持 ClickHouse 的类 Kibana 的业务日志查询平台。
本文在 Ubuntu系统上部署 clickvisual， 并与 Kibana 做了简单的对比。
clickvisual
前置条件 部署一套 mysql， 此处直接docker 拉起 mysql5
docker run -d -p3306:3306 --name=mysql5 -e MYSQL_ROOT_PASSWORD=111111 mysql:5 进入mysql 创建 db： clickvisual 部署一套redis, 此处直接docker 拉起 redis5部署一套redis, 此处直接docker 拉起 redis5
docker run --name=redis5.0 -d -p 6379:6379 redis:5.0 部署一套 clickhouse, 部署文档参考 clickhouse笔记01–快速部署clickhouse ,部署完成后按照如下方式导入测试数据
在 ck 中导入数据， uk_price_paid2 下载数据(27265985条，csv 4.5GB大小)： wget http://prod.publicdata.landregistry.gov.uk.s3-website-eu-west-1.amazonaws.com/pp-complete.csv 建表，导入数据： 注意 clckvisual 需要时间字段，因此需要将 date 字段设置为 DateTime $ clickhouse-client localhost :) use default; localhost :) CREATE TABLE uk_price_paid2 ( price UInt32, date DateTime, postcode1 LowCardinality(String), postcode2 LowCardinality(String), type Enum8('terraced' = 1, 'semi-detached' = 2, 'detached' = 3, 'flat' = 4, 'other' = 0), is_new UInt8, duration Enum8('freehold' = 1, 'leasehold' = 2, 'unknown' = 0), addr1 String, addr2 String, street LowCardinality(String), locality LowCardinality(String), town LowCardinality(String), district LowCardinality(String), county LowCardinality(String), category UInt8 ) ENGINE = MergeTree ORDER BY (postcode1, postcode2, addr1, addr2); $ clickhouse-local --input-format CSV --structure ' uuid String, price UInt32, time DateTime, postcode String, a String, b String, c String, addr1 String, addr2 String, street String, locality String, town String, district String, county String, d String, e String ' --query "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3470dfa708c90d0f1441f04c9c2058c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb75cfbfcffbc2c1a5ea529887d367a/" rel="bookmark">
			Tomcat的安装及其使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载安装 本文下载的是8.5版本的，下载链接：Apache Tomcat® - Welcome!
切记解压缩的目录不要有中文存在。
二.启动Tomcat 在解压缩之后，会有很多文件存在，但是我们只需要在意两个文件！
webapps 目录 . web applications 的简称 , 意思是用来存放 web 应用的文件夹. bin 目录中 , 双击 startup.bat 即可启动 Tomcat 服务器 把项目存放在webapps文件夹中，如何启动Tomcat。就可以通过当地ip的8080接口进行项目使用。
判断是否启动成功2种方式：
出现以下日志内容：如果启动Tomcat，则可以在浏览器中输入 127.0.0.1:8080。进入Tomcat欢迎页面： 启动失败的原因：
最常见的启动失败原因是端口号被占用，命令行中使用 netstat -ano | findstr 8080 确定看 8080 是否被其他进程绑定, 把对方进程干掉,再重新启动 Tomcat 一般就可以解决问题 找到占用8080端口的进程---13348，然后去任务管理器关闭它。
注：还有从Linux中配置Tomcat！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/91/">«</a>
	<span class="pagination__item pagination__item--current">92/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/93/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>