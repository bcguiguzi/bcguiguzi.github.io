<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f9dae5c000377e9478c8f121b92f0e/" rel="bookmark">
			图像增强方法概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、图像增强的概念
二、图像增强——空域法
2.1 灰度变换
2.1.1 线性变换
2.1.2 分段线性变换
2.1.3 非线性灰度变换
2.2 直方图修整法
2.2.1 直方图均衡化
2.2.2 直方图规定化
2.3 图像平滑
2.3.1 邻域平均法（均值滤波）
2.3.2 超限像素平滑法
2.3.3 有选择保边缘平滑法
2.3.4 中值滤波法
2.4 图像锐化
三、图像增强——频域法
3.1 低通滤波
3.2 高通滤波
一、图像增强的概念 图像恢复是通过一些先验知识估计图像缺失像素值，是估计值对缺失值的逼近，图像增强则与之不同。图像增强是通过代数或者统计等方法，增强图像中的有用信息，它可以是一个失真的过程，其目的是要改善图像的视觉效果。针对给定图像的应用场合，有目的地强调图像的整体或局部特性，将原来不清晰的图像变得清晰或强调某些感兴趣的特征，扩大图像中不同物体特征之间的差别，抑制不感兴趣的特征，使之改善图像质量、丰富信息量，加强图像判读和识别效果，满足某些特殊分析的需要。根据图像增强所应用的数学方法不同，可以将图像增强方法分为如下图所示的几种方法。
二、图像增强——空域法 本节部分内容来自：https://blog.csdn.net/thecentry/article/details/80720389
空间域增强是直接对图像各像素进行处理；空间域增强可以分为点运算和局部运算；其中点运算又可以分为：灰度变换、直方图修正法（均衡化、规定化）；局部运算可以分为：图像平滑、图像锐化。
2.1 灰度变换 灰度变换可调整图像的灰度动态范围或图像对比度，是图像增强的重要手段之一。
2.1.1 线性变换 令图像 f(i，j) 的灰度范围为[a, b] ，线性变换后图像 g(i ，j) 的范围为[a´，b´ ] ，如图， g(i ，j) 与 f(i ，j) 之间的关系式为：
在曝光不足或过度的情况下，图像灰度可能会局限在一个很小的范围内。这时在显示器上看到的将是一个模糊不清、似乎没有灰度层次的图像。下图是对曝光不足的图像采用线性变换对图像每一个像素灰度作线性拉伸。可有效地改善图像视觉效果。
2.1.2 分段线性变换 为了突出感兴趣目标所在的灰度区间，相对抑制那些不感兴趣的灰度区间，可采用分段线性变换。设原图像 f(x,y) 在 [0， M f ], 感兴趣目标的灰度范围在 [a,b], 欲使其灰度范围拉伸到 [c,d], 则对应的分段线性变换表达式为： 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f9dae5c000377e9478c8f121b92f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16ee4179d064cc0e9da77affe480620/" rel="bookmark">
			用js实现滚动加载动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、效果图
二、代码部分
1.html结构
2.css样式部分
3.js部分
三、代码总结
一、效果图 可以看出，在悠方滚动条滚动的时候，当高度打到一定高度的时候就会出现一个div盒子，就好像刚加载出来一样
而且可以一直向下滚动。
二、代码部分 1.html结构 &lt;div class="box"&gt;content1&lt;/div&gt; &lt;div class="box"&gt;content2&lt;/div&gt; &lt;div class="box"&gt;content3&lt;/div&gt; &lt;div class="box"&gt;content4&lt;/div&gt; 因为主要是后面通过js添加节点，所以结构很简单
2.css样式部分 &lt;style&gt; * { padding: 0; margin: 0; } html, body { width: 100vw; overflow-x: hidden; display: flex; justify-content: center; align-items: center; flex-direction: column; } .box { width: 1200px; height: 500px; background-color: rgb(195, 135, 235); border-radius: 8px; font-size: 30px; text-align: center; line-height: 500px; margin-top: 20px; color: #fff; /* 添加过度效果 */ transition: transform .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16ee4179d064cc0e9da77affe480620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33c74b4769581cee53ccd591ef87df2/" rel="bookmark">
			了解语言模型Model Language，NLP必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
1. 统计语言模型
2. n-gram 模型
2.1 n-gram语言模型的稀疏性问题
2.2 n-gram 语言模型的存储问题
3. 基于窗口的神经语言模型
4. 语言模型的评估指标:困惑度
语言模型是预测接下来出现什么词的任务。理论上说，您还可以将语言模型视为为一段文本分配概率的系统。 语言模型的预测任务 实践上说，您每天都在使用语言模型。当你在网页搜索上输入的文字时，当你输入今天，手机就会自动计算概率分布，并且弹出 是什么日子，是农历几月几日单词等等供你选择。
还有你的输入法也会根据目前你输入的字计算概率，有多个选择供你选。
1. 统计语言模型 统计语言模型(Statistical Language Model)是所有 NLP 的基础。在语音识别系统中,对于给定的语音段 Voice,需要找到一个使概率 p(Text|Voice)最大的文本段 Text，利用 Bayes 公式，有:
p(Voice|Text)为声学模型，p(Voice|Text)为语言模型。
统计语言模型是用来计算一个句子的概率的概率模型。假设 = ，示由 T 个词 按顺序构成的一个句子,则的联合概率为:
就是这个句子的概率。利用 Bayes 公式，上式可以被链式地分解为:
其中的(条件)概率 就是语言模型的参数。
参数 的近似计算，利用 Bayes 公式，有:
其中 和 分别为单词 和在语料中出现的次数。
2. n-gram 模型 模型的基本思想：基于Markov,一个词出现的概率只与它前面n-1个词相关，即：
这一简化不仅使单个参数的统计变得更容易(统计时需要匹配的词串更短)，也使参数的总数变少了。
模型参数的量级是 N 的指数函数，显然 n 不能取得太大，实用中最多的是采用 n=3 的三元模型。 从理论上看，n 越大效果越好。但是，当 n 大到一定程度时，模型效果的提升幅度会变小。例如，当 n 从 1 到 2，再从 2 到 3 时，模型的效果上升显著，而从 3 到 4 时，效果的提升就不显著了。参数越多，可区别性越好，但同时单个参数的实例变少从而降低了可靠性，因此需要在可靠性和可区别性之间进行折中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33c74b4769581cee53ccd591ef87df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e9ef4c4dbe552b9d94f0a29f145dd4/" rel="bookmark">
			Android Studio 中添加图片为什么不出来解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是添加图片的命名格式不对：
图片命名规则与变量相同，只能以下划线和字母开头，后缀最好用常用的jsp、png等格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cfdaea6ef80396898acef7f449038f/" rel="bookmark">
			FTP服务器移植到Linux开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP服务器移植到Linux开发板 提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 FTP服务器移植到Linux开发板前言一、vsftpd源码下载二、vsftpd移植及配置1.vsftpd移植2.vsftpd配置2.1 配置vsftpd.conf2.2 添加新用户2.3 启动设置 前言 提示：这里可以添加本文要记录的大概内容：
将Linux开发板作为一个小型的 FTP 服务器，这样就可以通过 FileZilla 软件直接在开发板和 windows 之间通过网络进行文件互传。在开发板上搭建 FTP 服务器很简单，就是 vsftpd 的移植。
提示：以下是本篇文章正文内容，下面案例可供参考
一、vsftpd源码下载 在ubuntu中安装FTP服务器可以直接通过apt-get进行安装，但是需要将ftp服务器安装在linux开发板中，就需要自己移植vsftpd，首先需要在vsftpd官网上下载vsftpd源码，(由于vsftpd是外网，可能访问不了)，可以直接下载事先准备的vsftp源码文件
链接：https://pan.baidu.com/s/1pRqtUMPL3dxK4weXxwCFuQ
提取码：hxco
二、vsftpd移植及配置 1.vsftpd移植 将将源码文件vsftpd-3.0.3.tar.gz移植到ubuntu中，并进行解压
tar -xvzf vsftpd-3.0.3.tar.gz 进入解压后的文件，并修改Makefile文件
CC = arm-linux-gnueabihf-gcc //修改为当前交叉编译器 修改完成后，进行make编译
最终得到两个文件：vsftpd和vsftpd.conf，将vsftpd文件移植到开发板/usr/sbin目录下，将vsftpd.conf移植到开发板/etc目录下
移植后给予vsftpd可执行权限，并且修改为vsftpd.conf所属用户为root
chmod +x /usr/sbin/vsftpd chown root:root /etc/vsftpd.conf 2.vsftpd配置 2.1 配置vsftpd.conf 跟ubuntu配置vsftpd一样，在linux开发板中打开vsftpd.conf文件，将下面两行进行使能
local_enable=YES //取消前面的“#” write_enable=YES //取消前面的“#” 2.2 添加新用户 如果第一次添加用户的话要先将 ubuntu 下的/etc/passwd 和/etc/group 这两个文件复制到开发板根文件系统的对应目录，
然后需要开发板根文件系统中的/etc/passwd和/etc/group这两个文件，如下：
而vstfpd默认需要两个用户：“ftp” 和 “nobody”。在创建这两个用户之前先检查一下下面几个文件和目录是否存在，如果不存在的话需要先创建下面这些文件和目录：
/home //目录，不存在的话自行创建 /usr/share/empty //目录，不存在的话自行创建 /var/log //目录，不存在的话自行创建 /var/log/vsftpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98cfdaea6ef80396898acef7f449038f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27861a5e9c0f74d99948c0e83bbba25a/" rel="bookmark">
			基于odoo的制造型企业库存管理模块应用案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、库存管理概述
1.1、综述
库存管理对于一个公司来说必不可少，它是企业运营的关键环节，企业智能化、科学化的库存信息管理对企业的长远发展具有十分重要的影响。 库存管理还具备了保证制造流程连续性、合理分摊订单费用、快速满足订单要求等功能。 1.2、库存管理的作用
1.缩短订单的交货时间是通过库存实现的。 适量的库存不仅提升了生产速度，也提高了客户满意度，从而留住更多的客户
2.从库存中获得稳定的生产效益。保持一定数量的库存，可以起到稳定原材料供应商、供应生产线的作用。
3.订购费用的分摊。目前我们大多数生产制造行业还没有实现个性化生产，在大量采购原材料时，库存可以起到按产品分摊订货成本的作用。
4.安全存货。安全存货是对未来材料供应或需求的不确定性的保护。生产过程中，维持适量的在制品存库，可以预防生产中断。
5.有利于公司降低运营成本和实现更快的库存周转，能够让公司的资金运转通畅，进而提升公司的管理水平，提高存货物资的周转率，减少物资长期积压的情况。
02、案例分析
2.1、基本情况
作为一个典型的生产制造企业，SX公司库房的分布如下所示，有大件成品区、返修区、夹具区、刀具区、不合格品区和包装纸区。 在具体的生产过程中，公司的库存管理主要包括向金属成型车间、机加一车间和机加二车间供应原材料和备件，以及要控制生产的半成品和产品总量。 图中有在制品的区域，仓库管理会影响到销售部门的业绩和采购部门的采购。在保持足够供给的前提下，要做到增加存货效率，降低库存成本和促进运营效率是许多制造业库存管理所面临的关键问题。
2.2、问题解析
目前公司库存管理方面存在很多急需解决的问题，主要有以下几点：
1.公司技术传统且落后，没有引进先进科学的管理技术和经验。 目前是凭借库存管理人员的经验来管理库房。 2.公司部门机构设置不合理，导致库存管理工作效率不高，人员之间沟通不畅，工作协调性不强。 3.公司监督力度不强，导致经常会出现工作上的失误，例如库存数量的减少、报表上数据错误等等，缺少强有力的规章制度来提升公司核心竞争力。
4.公司对生产订单不严格执行筛选。为了如期完成计划，市场部对所有的订单都承接，导致生产产品类别差异过大，给公司带来了不利的影响。
2.3、库存管理需求分析
第一，SX 公司仓库存货量越来越大，不但浪费了巨大的资本资源，而且占用了大量的人力资源与空间资源。对于库存管理工作的关注程度不足，导致库存的过度交付和大量数据和材料的浪费。 公司的仓库管理只执行了一个表面任务，基本上是检查有没有货物丢失。 第二，仓库出现库存管理混乱，标签不清晰等现象。产品发放错误和缺失以及出货和进货手续时间长的原因，使顾客不愿意购买，从而失去大量的顾客。 缺乏现场控制和库存管理，公司大多数人员负责管理进货和出货，没有生产和销售部门或其他部门的工作人员进行现场控制。 第三，SX公司不重视培训优秀的库存管理人员。 因此，库存信息架构和信息管理受到库存管理人员素质的限制，无法达到先进标准和水平，增加了库存环节的成本。 第四，公司内部控制系统薄弱，缺乏对库存管理的内部控制。 由于轻视了库存管理，生产消息不通畅，采购和生产计划之间出现差异，公司的库存结构设置不当。 虽然公司对原材料、半成品、原料等存货实行了资源管理，但在预测需求和确定原材料库存的最佳数量方面仍存在许多不足，造成生产中成本严重超标。 第五，公司缺乏库存管理制度。 这主要是指库存管理制度不全面、不规范。 目前，许多能源密集型企业的固定资产占公司总投资的 65%~72%。 库存管理制度不完善以及不科学、不有效的绩效评估标准，导致库存成本高，影响企业效益。 第六，SX 公司虽然设立了审计监督部门， 但是内部存货管理的项目较少，公司管理层和领导层不能及时有效了解公司存货管理的风险，造成了公司存总额一直较高。 03、库存管理设计
通过对公司现状调研，做出符合公司需求的库存管理设计， 通过点击 Odoo 界面中仓库→主数据→产品进入产品信息界面。以生产拨叉为例，有产品的基本信息和库存数量、价格、成本、负责人等信息。 在新建生产时通常有三种主要的设定，分别为生产类型、补货方式和供货方式，系统将按照他们的设定生成不同的产品文件。
3.1、产品类型设定
产品类型下图所示，商品类别在“一般信息”的选项卡中设置，并定义了商品是否必须实行仓库管理。 公司有三个截然不同的产品类型。 一是库存商品：产品库存被系统管理，并可以根据定义的补货规则，依据库存数量或订单数量自动进行补货。 二是消耗品：产品的库存被系统管理，但它的补货不被系统管理。三是服务：它不出现在任何仓库操作中。
3.2、补货
补货方式有按订单补货和按库存补货两种类型。 假如公司的补货方式是按库存补货， 当为其制定补货规则时可通过菜单中“仓库→主数据→再订购规则”，来为拨叉进行补货规则的设置，其中包括产品库存的最小数量和允许的最大数量。 设置补货规则具体规则如下：如果公司仓库中库位的库存数量小于最小库存数量，Odoo系统将自动开出一个补货单，提高系统库存到再订购规则所允许的最大数量。
如果在仓库管理中应用了多仓库和多库位，在再订购规则中，可以指定应用此规则的仓库和库位。当库存数量小于再订购规则中的最小数量时，系统会根据产品供应方式，自动生成生产订单或采购单，将产品补充到最大数量。
实际的补货数量，即采购订单或生产订单的实际数量，不仅与再订货规则中的最大数量有关，它还与再订购规则中的补货基数和产品的供应商设置中的最小数量有关。 系统会根据最小采购量和补货基数自动对数据进行取舍。需要注意，这个规则是基于虚拟库存的数量，它包含了即将发货的订单数量和即将入库的采购单数量，而不只是真实的数量，所以最小数量和最大数量并不是仓库里实际的最小数量和最大数量。 制定补货规则后，可以防止出现积压和缺货的情况，减少库存空间的使用。
3.3、供货
公司的供货方式有两种：第一，采购供应，产品从供应商处采购；第二，生产，使用内部资源生产这个产品或提供这个服务。
为了更好地对库存管理进行内部控制，Odoo使用复式记账管理，可以提供非常先进的追溯性信息，也可以非常方便地查询到所有库存操作的历史记录，一般使用批次/序列号管理。 批次数据可以用在所有的库存移动上，尤其是入库、内部调拨和发货。 通过菜单仓库→配置→设置，在“可追溯性”异界，勾选“批次、序列号”。通过以上库存管理的设计，基本上满足了SX公司现在的需求，库存管理的信息化与智能化提高了生产效率。 未来还需将库存管理功能模块进行完善，进行上线培训，提高公司对库存管理的控制。
04、为什么选择odoo？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27861a5e9c0f74d99948c0e83bbba25a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf95678040f4237e3aa72e1fbf89f29/" rel="bookmark">
			Android绘制五角星并实现星星闪耀发光效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 先来看下效果：
五角星gif图显示速度较实际慢，代码中可自定义闪烁的时长。
自定义View 自定义 ShiningStarView 的Kotlin代码：
import android.animation.ValueAnimator import android.animation.ValueAnimator.AnimatorUpdateListener import android.content.Context import android.graphics.* import android.util.AttributeSet import android.view.View import android.view.animation.Animation import android.view.animation.LinearInterpolator class ShiningStarView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr), AnimatorUpdateListener { private val mStarRadius: Float private val mStarPaint: Paint private var mStarPath: Path? = null private var mAlphaValue = 255 init { val a = context.obtainStyledAttributes(attrs, R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf95678040f4237e3aa72e1fbf89f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfd965d7c55a2adf4a0702ccec93637/" rel="bookmark">
			动态组件、keep-alive、异步组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、动态组件：
1、组件的渲染需要依赖用户的操作而决定。
2、由vue提供的内置组件&lt;component is="xx"&gt;&lt;component&gt;作为容器.
3、在component 标签里面写子组件的prop。
&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;a v-for="c in 3" @click="tab(c)"&gt;&lt;/a&gt; &lt;/div&gt; &lt;component :is="currentC"&gt;&lt;/component&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import {ref} from "vue" import c1 from "./components/comp1" import c2 from "./components/comp2" import c3 from "./components/comp3" const currentIndex=ref(1) function tab(c){ currentIndex.value=c; } const currentC=computed(()=&gt;"c"+currentIndex.value) &lt;/script&gt; 二、 keep-alive:是vue提供的内置组件
在切换组件时
1、缓存组件；
2、保持组件的状态；
3、解决反复创建组件导致性能问题。
用法：用keep-alive包裹组件，
1、提供include和exclude两个prop,选择需不需要缓存的组件,默认是include。
2、提供max属性，限制最大缓存组件数量，如果超出最大值，则最久没有被渲染的组件会销毁。
3、组件的切换会执行相应的钩子函数 activated （显示）和 deactivated （隐藏）
4、activated 在组件挂载时也会调用，并且 deactivated 在组件卸载时也会调用。
5、这两个钩子不仅适用于 &lt;KeepAlive&gt; 缓存的根组件，也适用于缓存树中的后代组件。
&lt;keep-alive&gt;
&lt;component :is="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dfd965d7c55a2adf4a0702ccec93637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7013e79ed2a8206673aa11677a43e7e4/" rel="bookmark">
			Flutter手势--GestureDetector各种手势使用详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.GestureDetector单击手势 序列号字段属性描述1onTapDownGestureTapDownCallback手指按下时的回调函数2onTapUpGestureTapUpCallback手指松开时的回调函数3onTapGestureTapCallback手指点击时的回调函数4onTapCancelGestureTapCancelCallback手指取消点击时的回调函数 我们在Container容器上添加了单击手势，代码如下：
import 'package:flutter/material.dart'; class GestureDetectorExample extends StatefulWidget { @override _GestureDetectorExampleState createState() =&gt; _GestureDetectorExampleState(); } class _GestureDetectorExampleState extends State&lt;GestureDetectorExample&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text("GestureDetector"), ), body: Center( child: Stack( children: [ GestureDetector( onTap: (){ print("onTap"); }, onTapCancel: () { print("onTapCancel"); }, onTapDown: (details) { print("onTapDown---${details.globalPosition}---${details.localPosition}"); }, onTapUp: (details) { print("onTapUp---${details.globalPosition}---${details.localPosition}"); }, child: Container( width: 200, height: 200, color: Colors.orange, alignment: Alignment.center, child: Text("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7013e79ed2a8206673aa11677a43e7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04602ec2f141a02dbf58c5b20cecf511/" rel="bookmark">
			python 多进程windows报错 linux不报错 TypeError: cannot pickle ‘_thread.lock‘ object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
class Controller(object): def handle_new(self): record=[] for job_name in self.job_info_dic: tasks = self.job_info_dic[job_name]['tasks'] corn = self.job_info_dic[job_name]['corn'] interval = self.job_info_dic[job_name]['interval'] for task in tasks: process=multi.Process(target=self.cal_task_job,args=(task,corn,interval,)) process.start() record.append(process) for process in record: process.join() 具体报错是：
File "D:\anaconda3\lib\multiprocessing\process.py", line 121, in start
self._popen = self._Popen(self)
File "D:\anaconda3\lib\multiprocessing\context.py", line 224, in _Popen
return _default_context.get_context().Process._Popen(process_obj)
File "D:\anaconda3\lib\multiprocessing\context.py", line 327, in _Popen
return Popen(process_obj)
File "D:\anaconda3\lib\multiprocessing\popen_spawn_win32.py", line 93, in __init__
reduction.dump(process_obj, to_child)
File "D:\anaconda3\lib\multiprocessing\reduction.py", line 60, in dump
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04602ec2f141a02dbf58c5b20cecf511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c766f5172d9fb5b472a23e1c5af942d5/" rel="bookmark">
			ArcGIS处理Las数据——一定坐标范围内的Las提取、数据转化以及三维底图的制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
加载Las数据
导入样区坐标
提取Las数据
数据转化
制作三维底图
点云数据在形式上呈离散分布，数据点的位置、间隔等在三维空间中的不规则分布，这就意味着点云数据的相同平面坐标可以对应几个不同的高程值，从而有利于表现细节信息和变化剧烈的地形或地物。
加载Las数据 打开ArcGis，连接到目标文件夹，然后直接将LAS文件拖入即可：（加载LAS数据后可能只是一个框线，点击右键将其缩放至分辨率即可看到点云）：
导入样区坐标 1.添加坐标文件（xls格式或csv格式皆可）：
2.选中刚刚添加的坐标文件右键点击显示XY数据，并根据自己的情况选定X、Y、Z字段，然后点击右下角编辑选择合适的投影坐标系：
提取Las数据 根据坐标点所框选区域，提取所需范围内的LAS数据：
（提取完成后不会自动加载刚刚提取的数据，需要自己导入）
数据转化 将LAS数据转化为栅格数据 （数据的分辨率根据自己的需求而定）：
制作三维底图 打开ArcScene,添加刚刚转出的栅格数据，右键点击其属性，将其基本高度设置为在自定义表面上浮动：
但这样直接出的三维底图不够平滑美观，故这里介绍使用Global Mapper将数据转化（导出格式为DEM），再使用 ArcScene进行操作：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a8bbec0bf5072c0f18e265776b07e1/" rel="bookmark">
			Qt 停靠布局QDockWidget使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本使用 QDockWidget是一个可以停靠在QMainWindow内的窗口控件，它可以保持浮动状态或在指定位置作为子窗口附加到主窗口中。停靠窗口QDockWidget类是应用程序中经常用到的，设置停靠窗口的一般流程如下。
创建一个QDockWidget对象的停靠窗体。设置此停靠窗体的属性，通常调用setFeatures()及setAllowedAreas()两种方法。新建一个要插入停靠窗体的控件，常用的有QListWidget和QTextEdit。将控件插入停靠窗体，调用QDockWidget的setWidget()方法。使用addDockWidget()方法在MainWindow中加入此停靠窗体。 这里使用Qt Designer ，随意拖拽添加QDockWidget到MainWindow任意区域可以停靠即可，在代码中对QDockWidget进行管理。Qt Designer无法任意调整位置，可以使用代码初始化QDockWidget布局。
布局相关 停靠特性 setFeatures()方法设置停靠窗体的特性，参数QDockWidget::DockWidgetFeatures指定停靠窗体的特性，包括以下几种参数。
① QDockWidget::DockWidgetClosable：停靠窗体可关闭。
② QDockWidget::DockWidgetMovable：停靠窗体可移动。
③ QDockWidget::DockWidgetFloatable：停靠窗体可浮动。
④ QDockWidget::AllDockWidgetFeatures：此参数表示拥有停靠窗体的所有特性。
⑤ QDockWidget::NoDockWidgetFeatures：不可移动、不可关闭、不可浮动。
停靠区域 setAllowedAreas()方法设置停靠窗体可停靠的区域，参数Qt::DockWidgetAreas指定了停靠窗体可停靠的区域，包括以下几种参数。
① Qt::LeftDockWidgetArea：可在主窗口的左侧停靠。
② Qt::RightDockWidgetArea：可在主窗口的右侧停靠。
③ Qt::TopDockWidgetArea：可在主窗口的顶端停靠。
④ Qt::BottomDockWidgetArea：可在主窗口的底部停靠。
⑤ Qt::AllDockWidgetArea：可在主窗口任意（以上四个）部位停靠。
⑥ Qt::NoDockWidgetArea：只可停靠在插入处。
添加dock addDockWidget()方法用于添加dock，给dock指定位置，同时也可以更改dock的位置。
void QMainWindow::addDockWidget(Qt::DockWidgetArea area, QDockWidget * dockwidget) 分割dock splitDockWidget()方法用于分割dock窗口，是把两个dock进行左右或上下并排布置，做成一个类似QSplit的功能，分割原则是：水平从左到右，竖直从上到下。
void QMainWindow::splitDockWidget(QDockWidget * first, QDockWidget * second, Qt::Orientation orientation) dock tab化窗口 tabifyDockWidget()方法用于tab化窗口，把多个dock变成一个tab形式的窗体。
void QMainWindow::tabifyDockWidget(QDockWidget * first, QDockWidget * second) 初始化大小 靠左右布局的QDockWidget的高度是自适应的，宽度需要初始化设置，同理靠上下布局的高度需要初始化设置。使用splitDockWidget分割、tabifyDockWidget tab化窗口的QDockWidget的初始化大小与其依赖的QDockWidget(参数first)初始化大小一样。
void QMainWindow::resizeDocks(const QList&lt;QDockWidget *&gt; &amp;docks, const QList&lt;int&gt; &amp;sizes, Qt::Orientation orientation) 它的第一个参数是用来配置是哪个dock窗口需要调整大小；第二个参数是用来配置dock所占的像素大小，如果配置大于或者小于QMainWindow本身空间，Qt会根据所配置的像素大小的相对权重分配到dock中；第三个参数用来配置调整的方向，如果为Qt::Horizontal，调整dock宽度，Qt::Vertical调整dock高度，确定了停靠位置后resizeDocks才起作用。需要注意的是Qt官方文档上有注明这个方法在Qt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a8bbec0bf5072c0f18e265776b07e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601ca0bb8c68f74a4bf2c1fca29f9528/" rel="bookmark">
			cenos7 下源码编译与配置nginx、rpm包安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx-1.17.5版本源码编译与配置 准备依赖包:
yum -y install zlib-devel pcre-devel openssl-devel 准备nginx用户: 创建ngin的守护者
useradd -M -s /sbin/nologin nginx 以1.17.5为例，如需要更多的版本，请自行到http://nginx.org/download/，查找你想要的版本，并在下面的命令中进行替换
wget http://nginx.org/download/nginx-1.17.5.tar.gz 解压上传的nginx源码包
tar xzf nginx-1.17.5.tar.gz 源码编译与安装:
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_random_index_module --with-http_sub_module 如果编译报错是因为缺少gcc
yum -y install gcc 编译与安装
make make install 这里可以先查看是否已经存在nginx用户
id nginx # 或者 cat /etc/passwd 不存在nginx则添加用户
useradd -M -s /sbin/nologin nginx 设置守护进程用户配置文件: 在nginx.conf文件加入 user nginx
vi /usr/local/nginx/conf/nginx.conf user nginx; 主配置文件目录
/usr/local/nginx/conf/nginx.conf 放网站位置
/usr/local/nginx/html/ 服务管理:
1.检测配置语法是否有问题，看到 is OK和is successful表示成功
/usr/local/nginx/sbin/nginx -t 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601ca0bb8c68f74a4bf2c1fca29f9528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c398e679fc3784c4f54c3085e27aef/" rel="bookmark">
			SpringBoot的核心注解及自动配置原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. SpringBoot的核心注解3. SpringBoot的自动配置3.1 @AutoConfigurationPackage注解3.2 @Import注解 4. 按需开启自动配置4.1 以AopAutoConfiguration为例4.2 以BatchAutoConfiguration为例 5. 总结 1. 前言 SpringBoot的自动配置原理是一个令人头疼的问题，经过一下午的学习写下这篇文章供大家参考，如果有雷同纯属巧合。文章中如果出现错误，欢迎大家指出，本人会随时修改。
SpringBoot版本：2.7.5（注意版本号，不然跟文章中调试结果可能不一致）。
2. SpringBoot的核心注解 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 我们在创建的springboot项目时都会写一个主启动类，每次启动项目时只要运行主启动类中的main方法即可。标注在主启动类上的 @SpringBootApplication注解就是springboot的核心注解，但该注解是一个合成注解，主要由下面三个注解组成：
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) @SpringBootConfiguration
@SpringBootConfiguration注解的作用是标注该类是一个配置类。它与@Configuration注解的功能一致，区别是@SpringBootConfiguration是springboot中的注解，而@Configuration注解是spring中的注解。由下面的代码可以看出@SpringBootConfiguration是@Configuration的一个派生注解。
@Documented @Configuration @Indexed public @interface SpringBootConfiguration { @AliasFor( annotation = Configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c398e679fc3784c4f54c3085e27aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e3d95ac2aadc2075efd6c784b691f4/" rel="bookmark">
			Vue3实现小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客咱们通过案例学习一下Vue3的部分知识点，话不多说，最终效果如下
整体代码逻辑 整个案例代码包括购买数量的增加和减少，不购买时移除，总价格计算，几个小功能，小功能的堆叠形成大功能。
步骤代码 结构和样式通过html和css实现，这里先不赘述，完整代码会有体现，主要关注到小功能的实现逻辑。
表单通过v-for将数据渲染到界面上，十分便利。
增加效果 点击按钮实现增加，很容易就可以想到通过写个增加方法来实现，index用来确定哪个book的购买数量增加了。
减少效果 减少和增加的实现方式相似，不过增加了v-bind来绑定disabled通过确定books的长度是否为1，来决定减少按钮是否能被点击。
移除功能 移除功能通过splice方法移除books数组的元素实现，该方法第一个参数表示开始的位置，第二个参数表示移除的数量。
总价格计算效果 总价格的计算涉及到对data中数据的处理，所以咱们使用computed计算属性，通过循环获取到每种书籍的价格和数量的乘积，最后求和。
完整代码 index.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="./test.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;template id="my-app"&gt; &lt;template v-if="books.length"&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;出版日期&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(book, index) in books" :key="index"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{book.name}}&lt;/td&gt; &lt;td&gt;{{book.date}}&lt;/td&gt; &lt;td&gt;{{formatPrice(book.price)}}&lt;/td&gt; &lt;td&gt; &lt;button @click="decrement(index)" :disabled="book.count &lt;= 1"&gt;-&lt;/button&gt; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e3d95ac2aadc2075efd6c784b691f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd8601d7ac6404abde5d7c88b4d8e19/" rel="bookmark">
			SpringBoot HttpMediaTypeNotAcceptableException: Could not find acceptable representation错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此错误出现于请求响应的时候,在springboot 下出现该问题的原因是序列化问题
如果响应对象为java对象,请检查是否对象缺失 setter/getter方法,补齐即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b9b54cb97f4d0d2e2c4bc795824650/" rel="bookmark">
			华为OD机试（JAVA）真题22版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 华为题库已换，后续会另启专栏更新最新版。介意的勿订阅，介意的勿订阅，介意的勿订阅 华为机试有三道题目，第一道和第二道属于简单或中等题，分值为100分，第三道为中等或困难题，分值为200分。总分为400分，150分钟考试时间。之前通过为150分，现在好像分数提高了，大家不要太大意，一定要多刷题，争取拿高分，毕竟分数越高评级越高，工资也就越高。OD的工资待遇还是很可观的15K-30K*14-16，希望大家努力（肺腑之言）
→→→ 第二期机试真题（JAVA）
→→→ 初学者或前端需要JavaScript版可以点这里
序号题目分值1日志排序1002寻找相同子串1003太阳能板最大面积1004分糖果1005相对开音节1006IPv4地址转换成整数1007数据连续和1008统计射击比赛成绩1009拼接URL10010素数之积10011停车场统计10012数组去重和排序10013矩阵最大值10014找终点10015按身高和体重排队10016最大N个数与最小N个数的和10017事件推送10018流水线10019检查是否存在满足条件的数字组合10020敏感字段加密10021关联子串10022求字符串中所有整数的最小和10023猴子爬山10024乱序整数序列两数之和绝对值最小10025数组组成的最小数字10026数组拼接10027英文输入法10028非严格递增连续数字序列10029字符统计及重排100305键键盘的输出10031两数之和绝对值最小10032矩形相交的面积10033字符串比较10034快递运输10035服务器广播20036数字反转打印20037欢乐周末20038找单词20039火星文计算20040计算堆栈中的剩余数字20041篮球比赛20042字符串分割20043最长广播响应20044转骰子20045斗地主之顺子20046跳格子游戏20047构成的正方形数量20048服务失效判断20049竖直四子棋20050仿LISP运算200 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849658bebdc57d90a99490eb64317ae5/" rel="bookmark">
			第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（上海）G Fibonacci【题解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 牛客竞赛传送门：
本题链接：G-Fibonacci_第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（上海）(重现赛) (nowcoder.com)
比赛完整题单：牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ (nowcoder.com)
通过率：702/961
题目大意：给定一个整数 n ,计算有多少对 (x,y) 满足 1≤x&lt;y≤n，且fx​∗fy​ 的值为偶数
【说明】在样例1中，满足条件的数对有（1，3），（2，3），
对应f1​∗f3​=1∗2=2，f2​∗f3​=1∗2=2
知识点：组合数学、数学推理
思路：
因为最后只需要找fx∗fy的值为偶数
所以，其实斐波那契只是外表的包装，我们只需要找到奇偶规律就行
1,1,2,3,5,8,13,21,34
1,1,0,1,1,0, 1, 1, 0(1表示奇数，0表示偶数)
不难发现，奇偶规律：周期为3的奇数奇数偶数
0*0=0，1*0=0，1*1=1
所以用所有的组合数 减去 所有奇数的组合数，就是答案
本题数字较大，注意要开long long
AC代码：
#include&lt;bits/stdc++.h&gt; using namespace std; long long c(long long x){ return x*(x-1)/2; } int main(){ long long n ; cin&gt;&gt;n; printf("%lld", c(n) - c(n-n/3)); return 0; } /* 耗时：15min */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f877f3741d591dd1b514d4dca978a6/" rel="bookmark">
			求问题解答 HTTP Status 500 - java.lang.NullPointerException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP Status 500 - java.lang.NullPointerException
type Exception report
message java.lang.NullPointerException
description The server encountered an internal error that prevented it from fulfilling this request.
exception
org.apache.jasper.JasperException: java.lang.NullPointerException
org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:556)
org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:477)
org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:395)
org.apache.jasper.servlet.JspServlet.service(JspServlet.java:339)
javax.servlet.http.HttpServlet.service(HttpServlet.java:731)
org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
root cause
java.lang.NullPointerException
org.apache.jsp.bookclass_jsp._jspService(bookclass_jsp.java:100)
org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)
javax.servlet.http.HttpServlet.service(HttpServlet.java:731)
org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:439)
org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:395)
org.apache.jasper.servlet.JspServlet.service(JspServlet.java:339)
javax.servlet.http.HttpServlet.service(HttpServlet.java:731)
org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
note The full stack trace of the root cause is available in the Apache Tomcat/7.0.64 logs.
大佬们我运行eclipse中的servlet的时候出现了这个情况是什么原因啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c075083e927c084747b49c6227351c4/" rel="bookmark">
			在树莓派4B上使用C&#43;&#43;和OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
树莓派上的C++
OpenCV的安装
Ⅰ下载opencv（命令窗口）
Ⅱ安装依赖包
Ⅲ配置安装路径并编译
Ⅳ配置OpenCV环境
程序运行验证
Ⅰ创建cpp文件
Ⅱ编写cpp文件
Ⅲ使用g++编译：
Ⅳ运行
参考资料与致谢
前言 本人最近在重温C++，由于之前使用树莓派+Python+OpenCV做了一些项目，所以想将Python换成C++实现一遍。写这篇文章的目的有两个，一是可以记录自己的学习过程，防止以后用到忘记而花费大量时间踩坑；二是可以帮助有同样想法的人避免踩坑。
树莓派上的C++ 树莓派自带C++的编译g++，如没有，可以采用下面命令安装。
sudo apt-get install g++ OpenCV的安装 Ⅰ下载opencv（命令窗口） git clone https://github.com/opencv/opencv.git Ⅱ安装依赖包 sudo apt-get install cmake sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev sudo apt-get install libgtk2.0-dev sudo apt-get install pkg-config Ⅲ配置安装路径并编译 ①打开OpenCV安装的路径，我的是/home/pi/opencv.
cd /home/pi/opencv ②编译，时间很长，耐心等待（OpenCV4默认不生成.pc文件，这里设置一下才行，免得后面再补）
mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release -DOPENCV_GENERATE_PKGCONFIG=ON -DCMAKE_INSTALL_PREFIX=/usr/local .. sudo make sudo make install Ⅳ配置OpenCV环境 ①在/etc/ld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c075083e927c084747b49c6227351c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/195/">«</a>
	<span class="pagination__item pagination__item--current">196/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/197/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>