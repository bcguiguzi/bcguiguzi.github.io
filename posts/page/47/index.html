<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be764b8023d20f890a72e4c5d08cdba6/" rel="bookmark">
			spring-cloud-openfeign 3.0.0之前版本(对应spring boot 2.4.x之前版本)feign配置加载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前写的文章配置基础上
https://blog.csdn.net/zlpzlpzyd/article/details/136060312
下图为自己整理的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baab4fb23a4b6f9bdca8faa6b69bec5b/" rel="bookmark">
			spring-cloud-openfeign 3.0.0(对应spring boot 2.4.x之前版本)之前版本feign整合ribbon请求流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前写的文章配置基础上
https://blog.csdn.net/zlpzlpzyd/article/details/136060312
下图为自己整理的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365102f0003fa3cdb9b4881140970c43/" rel="bookmark">
			UE4游戏传奇4SDK之角色类型跟门票类型检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// Enum MirMobile.EPlayerClassID
// NumValues: 0x0008
enum class EPlayerClassID : uint8
{
NONE = 0,
PCW = 1,
PCM = 2,
PCT = 3,
PCA = 4,
PCZ = 5,
PCD = 6,
EPlayerClassID_MAX = 7,
};
// Enum MirMobile.EDungeonTicketType
// NumValues: 0x0007
enum class EDungeonTicketType : uint8
{
TYPE_NONE = 0,
TYPE_SECRET_TICKET = 1,
TYPE_SQUARE_TICKET = 2,
TYPE_INDUN_TICKET = 3,
TYPE_BOSS_INDUN_TICKET = 4,
TYPE_WORLD_BOSS_TICKET = 5,
TYPE_MAX = 6,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365102f0003fa3cdb9b4881140970c43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fade4d7f9400af1df005da773cc25bbb/" rel="bookmark">
			代码审核的标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
标准
指导
原则
冲突解决
标准 代码审核的目的是为了保证代码库中的代码质量持续改进，代码审核的工具和流程都是为了实现这个目的而设计为了达到目标，我们需要权衡得失首先，开发人员必须能在任务上 取得进展如果从没向代码库提交代码，那么代码库就不会改善同时，如果审核者让开发者在提交代码时变得很困难，那么开发者不得不花费大量的精力解决审核评论，没有动力在未来的提交中改进代码质量另一方面，审核者有责任确保提交者的代码质量随着时间的推移，代码库的质量不会降低这有点棘手，冰冻三尺非一日之寒，代码库质量的降低是随着每次代码提交的微小降低累积而成的，尤其当团队面临很大的时间压力时，为了完成任务，他们不得不采取一些临时方案另外，代码审核者对他们审核的代码有所有权和责任，他们有义务确保代码库是一致的、可维护的因此，我们希望在代码审核中能遵循这条原则：一般情况下，如果代码提交者的代码能显著提高代码库的质量，那么审核者就应该批准它，尽管它并不完美这是代码审核中所有规则的 最高原则当然，也有例外例如，一次提交包含了系统中不应加入的功能，那么审核者就不应批准它，即使它设计得非常完美还有一个关键点，那就是世上根本就没有“完美”的代码——只有 更好 的代码审核者不应该要求代码提交者在每个细节都写得很完美审核者应该做好修改时间与修改重要性之间的平衡无需追求完美，而应寻求 持续的改进倘若一个 CL 能够改进系统的可维护性、可读性，那么它不应该仅仅因为不够完美而延迟数天（甚至数周）才批准提交我们应该营造这种氛围：当审核者发现某些事情有更好的方案时，他可以无拘束地提出来如果这个更好的方案并不是非改不可，可以在注释前加上：“Nit:”，让提交者明白，这段评论只是锦上添花，你可以选择忽略注意：在提交代码时不应显著地 恶化 代码质量，唯一的例外是 紧急情况 指导 代码审核还有一项重要的功能：能让开发者学到新知识，可能是编程语言方面的，也可能是框架方面的，或一些常规的软件设计原则作为审核者，如果你认为某些评论有助于开发者学到新知识，那就毫不犹豫地写下来吧分享知识是提高代码质量的一种方式记住，如果你的评论是纯学习相关的，与文档中提及的标准关系不大，那就最好在前面加上“Nit”，否则就意味着开发者必须在 CL 中修正这个问题 原则 以技术因素与数据为准，而非个人喜好在代码样式上，遵从代码样式指南的权威任何与样式指南不一致的观点（如空格）都是个人偏好所有代码都应与其保持一致如果某项代码样式在文档中并未提及，那就接受作者的样式任何涉及软件设计的问题，都不应由个人喜好来决定它应取决于基本设计原则，以这些原则为基础进行权衡，而不是简单的个人看法当有多种可行方案时，如果作者能证明（以数据或公认的软件工程原理为依据）这些方案基本差不多，那就接受作者的选项；否则，应由标准的软件设计原则为准如果没有可用的规则，那么审核者应该让作者与当前代码库保持一致，至少不会恶化代码系统的质量 冲突解决 在代码审核中碰到冲突时，首先要做的永远是先尝试让双方（开发者和审核者）在两份文档（开发者指南 和 审核者指南）的基础上达成共识当很难达成共识时，审核者与开发者最好开一个面对面的会议（或视频会议），而不要继续通过代码审核评论进行解决（在开会讨论之后，一定要在评论中记录讨论的结果，以便让以后阅读的人知道前因后果）如果仍旧无法解决问题，最好的方式是升级常见的升级方式比较多，如让更多的人（如团队的其他人）参与讨论，把团队领导卷进来，征询代码维护人员的意见，让工程经理来决定千万不要因为开发者与审核者无法达成一致而让CL停留在阻塞状态 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853a003a675f3d98e6f02d81ce0471b3/" rel="bookmark">
			Golang基于Redis bitmap实现布隆过滤器（完结版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang基于Redis bitmap实现布隆过滤器（完结版） 为了防止黑客恶意刷接口（请求压根不存在的数据），目前通常有以下几种做法：
限制IP（限流）Redis缓存不存在的key布隆过滤器挡在Redis前 完整代码地址：
https://github.com/ziyifast/ziyifast-code_instruction/tree/main/blond_filter
1 概念： 1.1 本质：超大bit数组 原理：由一个初始值都为0的bit数组和多个hash函数构成（相当于多把锁才能打开一把钥匙，才能确认某个元素是否真的存在，提高布隆过滤器的准确率），用于快速判断集合中是否存在某个元素使用3步骤：初始化bitmap -&gt; 添加元素到bitmap（占坑位） -&gt; 判断是否存在
-Hash冲突： 为了避免hash冲突，我们可以通过多个hash函数进行映射，比如：将player:1982分别通过多个hash函数映射到多个offset。在查询时，就需要判断是否映射的所有的offset都存在。（一个hash函数冲突概率可能很高，但是通过不同多个hash进行映射，大幅降低冲突概率） 注意📢：
是否存在： 有，可能有；因为存在hash冲突，比如我添加的是王五在1号来上班了，但是王五和李四hash值一样，结果我查询李四时，发现hash定为的offset为1了，我就误以为李四也来上班了无，是肯定无。100%不存在 使用时，bit数组尽量大些，防止扩容。当实际元素超过初始化数量时，应重建布隆过滤器，重新分配一个size更大的过滤器，再将所有历史元素批量add避免删除元素，防止误删（hash冲突：我原本想删李四的记录，结果把王五的也删除了，“连坐”） 1.2 应用场景：防止Redis缓存穿透（海量数据中判断某个元素是否存在） 应用场景：加在数据库、Redis之前。 在查询之前，先查布隆过滤器是否存在，如果不存在直接返回请求。如果存在，再查询Redis、数据库，看是否真的存在。防止因缓存穿透导致数据库被打挂掉。防止被人恶意刷接口 2 环境准备 2.1 安装docker yum install -y yum-utils yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo yum install docker systemctl start docker 2.2 搭建Postgres docker run -d \ -p 5432:5432 \ -e POSTGRES_USER=postgres \ -e POSTGRES_PASSWORD=postgres \ -v /Users/ziyi2/docker-home/pg:/var/lib/postgresql/data \ --name pg \ --restart always \ docker.io/postgres:9.6-alpine # -p port 映射端口，可以通过宿主机的端口访问到容器内的服务 # -d 是detach 保持程序后台运行的意思 # -e environment 设置环境变量 # -v volume 文件或者文件夹的挂载 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853a003a675f3d98e6f02d81ce0471b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f9f32db003bd0b35fb21b8f5aa54f7/" rel="bookmark">
			@RequestMapping与@GetMapping和@PostMapping等注解的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
前置知识
大致区别
使用场景上的注意事项
如何工作
使用案例
写法对比
前置知识 HTTP请求方法一共有9种，为：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECTGET(获取资源) 本质就是发送一个请求来取得服务器上的某一资源；资源通过一组HTTP头和呈现数据(如HTML文本，或者图片或者视频等)返回给客户端；GET请求中，永远不会包含呈现数据；即GET请求只用来向服务器获取资源，而GET请求本身不应该携带任何呈现数据POST(传输实体文本) 向指定资源提交数据进行处理请求；数据被包含在POST请求体中(例如提交表单或者上传文件)；POST请求可能会导致新的资源的建立或已有资源的修改MVC中，控制器的定义在Spring MVC中，控制器是指类或者类的方法上添加了@RequestMapping注解的类，并不是使用了@Controller注解的类就是控制器类@Controller注解的类和@Component注解的类在功能上是一样的，都是在辅助@ComponentScan实现组件扫描只是在表意上，在用@Controller注解控制器类比用@Component注解控制器类更清楚一些 大致区别 SpringMVC以前版本的@RequestMapping，到了新版本被下面新注解替代，相当于增加的选项：
@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping 从命名约定我们可以看到每个注解都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@PostMapping用于处理请求方法的POST类型等
如果我们想使用传统的@RequestMapping注解实现URL处理程序，那么它应该是这样的：@RequestMapping(value = "/get/{id}", method = RequestMethod.GET)新方法可以简化为：@GetMapping("/get/{id}")@RequestMapping是一个非常通用的注解，它可以应用于类和方法层面用于将任意HTTP请求映射到控制器方法上@RequestMapping表示共享映射，如果没有指定请求方式，将接收所有的HTTP请求方式需要注意的是，大多数控制器方法都应该映射到一个特定的HTTP方法，而不是使用@RequestMapping共享映射当应用于类时，表示该类处理所有的请求；当应用于方法时，表示该方法处理特定的请求此外，@RequestMapping还可以用来指定请求的URL、HTTP方法等；例如：在上述代码中，handleRequest方法将处理所有发送到”/test”的HTTP GET请求在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上；之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系@GetMapping是@RequestMapping的特化版本，专门用于处理HTTP GET请求用于将GET请求映射到控制器处理方法上；当客户端发送HTTP GET请求时，Spring Boot会自动将请求映射到具有相应URL路径的控制器方法上，然后调用该方法处理请求；在调用控制器方法之前，Spring Boot会执行一系列预处理操作，例如解析请求参数和验证请求头；在调用控制器方法之后，Spring Boot会执行一系列后处理操作，例如转换响应信息和生成响应头@GetMapping是一个作为快捷方式的组合注解它在功能上等价于@RequestMapping(method = RequestMethod.GET)和@RequestMapping一样，@GetMapping也可以应用于类和方法层面例如：在上述代码中，home方法将处理所有发送到”/“的HTTP GET请求 使用场景上的注意事项 (1) 在前端method特指了get或post的时候分别使用@GetMapping和@PostMapping(2)如果传的参数是@RequestBody，多参或者传对象的情况下使用@PostMappping这种注解因为@RequestBody是获取请求body中的数据，常用于搭配@PostMapping请求来提交对象数据 如何工作 所有上述注解都已在内部注解了@RequestMapping以及方法元素中的相应值例如，如果我们查看@GetMapping注解的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注解：所有其他注解都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注解，@PutMapping使用RequestMethod.PUT进行注解等 使用案例 (案例1) 下面是结合RestController的简单使用：(案例2) 下面是使用@Controller的代码：在上面的代码中，HomeController类充当请求控制器；它的homeInit()方法将处理所有传入的URI请求"/"；它接受一个Model并返回视图home；使用配置的视图解析器解析视图名称”home“的页面(案例3) 下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例：如上述代码所示，到 /user/login 的请求会由 login() 方法来处理，而到 /user/register 的请求会由 register() 来处理(案例4) 将控制器方法映射到一个特定的HTTP方法上，应用@GetMapping、@PostMapping：通常，这样代码更规范，因为login登录时只需要向服务器获取用户数据，register注册时需要向服务器提交数据组合注解对控制器方法的请求映射进行具体区分，减少了在应用程序上要配置的元数据，并且代码也更易读，有助于控制器对请求的快速匹配以及代码功能区分等(案例5) 在下面的示例中，@RequestParam注解表示请求参数“name”的值将被注入到方法参数中当客户端发送HTTP GET请求“/api/hello?name=world”时，Spring Boot会自动将请求映射到hello()方法，并将参数“world”注入到方法参数中，最终返回字符串“Hello, world!” 写法对比 @RequestMapping：@PostMapping： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac50b48f7352ee1c1d50520d8a8730c/" rel="bookmark">
			力扣hot100题解（python版55-59题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		55、全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：
输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：
输入：nums = [1] 输出：[[1]] 提示：
1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同 思路解答： 递归生成排列： 通过递归函数 backtrack，在每一步尝试将当前位置的元素与后续位置的元素交换，然后递归处理下一个位置。交换元素： 在每一步尝试中，通过交换元素的位置来生成不同的排列，这样可以确保每个元素都出现在每个位置上。回溯： 在递归调用完成后，需要恢复元素的原始顺序，以便进行下一次尝试。这样可以确保不会遗漏任何可能的排列。终止条件： 当处理到列表的最后一个位置时（first == n-1），即已经生成了一个完整的排列，将该排列加入结果列表中。 def permute(nums: list[int]) -&gt; list[list[int]]: def backtrack(first): if first == n-1: res.append(list(nums)) return for i in range(first, n): nums[first], nums[i] = nums[i], nums[first] backtrack(first + 1) nums[first], nums[i] = nums[i], nums[first] n = len(nums) res = [] backtrack(0) return res 56、子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac50b48f7352ee1c1d50520d8a8730c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79df1a6acff61af3353ef582dc455a79/" rel="bookmark">
			html--心花怒放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Canvas 绘制一个❤&lt;/title&gt; &lt;link rel="shortcut icon" href="../../assets/images/icon/favicon.ico" type="image/x-icon"&gt; &lt;style&gt; html, body { height: 100%; padding: 0; margin: 0; } canvas { position: absolute; width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="pinkboard"&gt; Canvas Not Support &lt;/canvas&gt; &lt;script&gt; /* * Settings */ var settings = { particles: { length: 500, // maximum amount of particles duration: 2, // particle duration in sec velocity: 100, // particle velocity in pixels/sec effect: -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79df1a6acff61af3353ef582dc455a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f133c74109bbe918602596399a6c37d/" rel="bookmark">
			公网IP与私有IP及远程互联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.公网有私有IP及NAT 公网IP是全球唯一的IP，通过公网IP，接入互联网的设备是可以访问你的设备。但是IPV4资源有限，一般ISP(Internet Service Provider)并不会为用户提供公网IP。所以家里的计算机在公司是没法直接使用windows远程桌面直接访问的。
理解起来就是你家里的计算机和公司的计算机都在ISP组建的不同的局域网中，在这个局域网中给各自的计算机分配私有IP，那么这些处于局域网的只有私有IP的主机又是怎么可以访问互联网的呢？
答案是ISP在它们的交换机(switch)或者路由器(router)中建立了私有IP到交换机/路由器的公网IP的地址转换。这个转换就是NAT(network address translation)技术。当然NAT转换可能包含IP地址+端口。那么就相当于很多设备在访问互联网的时候是共用一个公网IP的。这个NAT转换表在局域网外是未知的，所以局域网外的设备没法直接访问内部的计算机。所以你家中的计算机只能作为master主动去访问互联网而不能被公司的计算机直接访问。
那么我为什么不能访问和我使用相同服务商的邻居家的电脑呢？我觉得应该是服务商把局域网内互联给禁掉了。自己家里面连接相同WIFI的两个设备是可以互相访问的，如果你自己的路由器和防火墙没有禁止的话。
那么对于向日葵这类远程控制软件是如何做到家里计算机和公司计算机互相访问的呢？这是因为有向日葵的服务器做了中间的桥接，这个过程是家里计算机和公司计算机分别通过向日葵客户端与向日葵服务器通信，这个服务器把两边的数据进行交换。而且这个过程中我理解无论是主控电脑还是受控电脑都是作为向日葵服务器的master，向日葵也是无法主动访问你的计算机的。换句话说受控电脑也是通过主动不停的访问向日葵服务器，是否有远程控制请求，当服务器收到远程控制请求在转发给受控电脑。
同理我们使用手机查看没有公网IP的家用监控器时，也是经过监控器的服务器转发的。
另一个场景 我们在通过SSH访问VPS时候，VPS的IP地址就是一个公网IP。比如AWS的ES2，ES2会绑定AWS地址池里面的一个公网IP才能被访问。AWS的地址池地址段是固定的，所以也容易被长城拦截。
2.IPV6 公网IPv4资源有限，可以向ISP申请，但是一般都是要单独收费的。那么IPV6有128bit地址空间，足够给每个设备分配地址了，国家也下了文件要求所有的ISP提供IPV6地址，一般情况下现在的最新路由器都是支持IPV6的。这个可以自己尝试开始路由器的IPV6连接。目前移动网络，移动联通和电信手机卡都是支持IPV6网络互联的。所以你的手机是可以直接访问IPV6的地址。但是物联网卡是不支持IPV6的。
有了IPV6那么就可以直接用windows的远程控制家中的电脑了，比如在家自建NAS服务，但是一般是没法家中访问公司电脑的，公司的网关不会轻易让外网直接访问的哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113dca8fc0306d652f0462d5a4c04b97/" rel="bookmark">
			ms office学习记录11：Excel㈤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取外部数据（导入、断开连接）
Excel表格中的数据，要么手动输入，要么从外部获取
获取外部数据：为记忆方便，定位到单元格后点击“数据”选项卡→现有连接→浏览更多→复制粘贴考生文件夹路径进行选择即可
导入数据后要断开与外部数据的连接：连接→找到要删除的连接→点击要删除的数据→删除
从文本导入第一步：如无特殊情况，文件类型均选择“分隔符号”；如出现乱码则调整文件原始格式，设置为简体中文 第二步：设置分隔符号 第三步：设置列数据格式 （如设置完成后将数字列转换成日期：选中该列→分列→分隔符号→将列数据格式转换成日期、身份证号码列一定要转换为文本）
文本导入后，视情况删除多余重复标题行
切割列（分列）：插入空白列、用空格隔开完切割的标题单元格，选中该列→分列→固定宽度→单击要切割的文字中间出现分割线，可左右移动调整→下一步设置列数据格式→完成
从网页导入表格：在指定工作表中浏览网页，拖动滚动条找到表格并勾选→导入→确定
创建查询，添加到数据模型（合并、处理大量级数据表）
创建查询：“数据”选项卡→新建查询→从文件→从工作簿→复制粘贴考生文件夹路径选择文件→进入导航器界面，选择sheet1→编辑→查询设置→编辑查询名等属性、列标题等（如不小心关闭查询设置，则点击“视图”选项卡→查询设置→进行编辑）
删除空行：点倒三角→在数字筛选器中取消勾选null
将查询加载到工作表中、添加到数据模型：“开始”选项卡→关闭并上载至→选择加载选项：查看此数据的方式、将数据上载到（注意看是否是指定/A1单元格）、是否添加到数据模型→加载，视情况重命名工作表
重命名数据模型：“数据”选项卡→管理数据模型→查看、更改数据模型名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdce68b22cbda1d50120ad468ecd7f7/" rel="bookmark">
			关于华为昇腾（Ascend）AI芯片，CANN计算架构，MindSpore深度学习框架，MindStudio开发工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、华为昇腾生态 深度学习之前的配置都是：NVIDIA GPU / CPU + CUDA + Tensorflow/PyTorch
后来老美禁止 NVIDIA 卖GPU芯片给我们，于是国内企业开始发力CPU和GPU硬件，成果丰硕，虽然与NVIDIA顶级GPU还有一些差距，但是也不错，为了尽快填补国内需求，我们的解决方案是国产GPU + CUDA + Tensorflow/PyTorch，本来用的好好的，然而敌人亡我之心不死，开始禁止我们使用 CUDA ，它其实就是一个协议或者指令集，它连接底层硬件与上层机器学习框架即Tensorflow/PyTorch，通过硬件和软件两个维度卡你，我们这么多年习惯了拿来主义，现在变得很被动。
值此危难之际，还是华为站了出来，硬件软件一起扛，硬件上推出了昇腾系列AI计算芯片 Ascend910/Ascend310，就是专门用来计算的GPU芯片，软件上使用 CANN（类比于CUDA），然后推出机器学习框架异思mindspore（对标Tensorflow/PyTorch），同时mindspore也是开放的，它支持基于 CUDA 的 GPU 以及普通的 CPU芯片，当然mindspore也是使用 Python 来开发，还提供一个 MindStudio 全流程开发工具链。官网 https://www.mindspore.cn/，也就是说华为昇腾是一个完整的生态，不再受外界掣肘。
有资料显示Ascend910性能与NVIDIA-A100相当，这其实很牛逼了，要知道英伟达发展了多少年，我们才多少年。
在人工智能框架使用率方面，TensorFlow、PyTorch、昇思MindSpore和飞桨合计占了86%的市场份额，其中，MindSpore以11%的占比在全球框架里排名第三，逆势进入了AI框架的第一梯队。
2、昇腾当前有哪些不足： 当前昇腾需求的爆发式增长动力主要来自1）AI算力行业自身的快速增长；2）国内自主可控的替代，比如说国家级别的人工智能计算中心，大部分开始会采用昇腾。
当相比于英伟达目前也有不少核心问题：
1，昇腾只能用于华为自身生态中的大模型业务，比如昇腾不能做GPT-3，因为910不支持32位浮点，**而目前大模型训练几乎都要使用32位的浮点，所以昇腾芯片只能利用华为开发的框架（如MindSpore），再加上优化好的大模型，比如盘古CV。
2，生态依然需要完善。英伟达最强大的护城河在于它的生态系统CUDA。目前CANN还有差距。
3，先进制程的卡脖子问题得到了一定解决，但依然需要担忧产能问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fbe73d12bcb76ab7f622d8e9456fcf/" rel="bookmark">
			安卓 修改系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安卓 修改系统时间 参考资料实践修改 参考资料 链接：Android App 设置系统时间，语言和时区、系统重启_android断电重启后设置系统时间的类在哪-CSDN博客链接：【Android 应用】简单实测可行的获取NTP时间实例_android ntp地址-CSDN博客 实践修改 app已经系统签名了，u:r:platform_app:s0:c512,c768
#添加权限 &lt;uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt; &lt;uses-permission android:name="android.permission.SET_TIME_ZONE" /&gt; &lt;uses-permission android:name="android.permission.SET_TIME" /&gt; 调用这个接口
SystemClock.setCurrentTimeMillis(ntpTime); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6382830ff2e4ef424efe2106fd84bd/" rel="bookmark">
			最简k8s部署（AWS Load Balancer Controller使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 我需要在k8s集群里面部署springboot服务，通过k8s ingress访问集群内部的springboot服务，应该怎么做？
这里假设已经准备好k8s集群，而且也准备好springboot服务的运行镜像了。这里我们将精力放在k8s服务编排上面。
一图胜千言 上图来自于kubernetes的ingress教程。接下来，我们按照上述部署1个ingress+2个服务。
service1 先用kubectl命令创建一个deployment.yaml和service.yaml，然后，将这两个内容合并到一个文件中，即service1.yaml。具体命令如下：
创建deployment.yaml：
kubectl create deployment service1 --image xxx.dkr.ecr.us-east-1.amazonaws.com/service1:latest -o yaml --dry-run=client &gt; k8s/deployment.yaml 创建service.yaml：
kubectl create service clusterip service1 --tcp 8080:8080 -o yaml --dry-run=client &gt; k8s/service.yaml 根据自己需求，去掉一下不要的内容，调整相关配置，合并成如下内容：
service1.yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app: service1 name: service1 spec: replicas: 2 selector: matchLabels: app: service1 template: metadata: labels: app: service1 spec: containers: - image: xxxxxxxxxxxx.dkr.ecr.us-east-1.amazonaws.com/service1:latest name: service1 resources: requests: memory: "2Gi" cpu: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6382830ff2e4ef424efe2106fd84bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8658ac800d04e92153d1f272815e4b0f/" rel="bookmark">
			ubuntu設定QGC獲取pixhawk Mini4(PX4 Mini 4) 的imu信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu20.04
QGC使用v4.3.0的版本
飛控pixhawk Mini4
飛控上只使用一條micro USB連接電腦，沒有其他線
安裝命令
sudo apt-get remove modemmanager -y sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y sudo apt install libfuse2 -y sudo apt install libxcb-xinerama0 libxkbcommon-x11-0 libxcb-cursor0 -y 運行，修改下USER,和 IMAGE_DIR的變量，IMAGE_DIR是存放QGroundControl.AppImage的位置
export USER=hao export IMAGE_DIR=/home/hao/Documents/wks_third_party/resource/QGC/v4.3.0 sudo usermod -a -G dialout $USER cd $IMAGE_DIR chmod +x ./QGroundControl.AppImage ./QGroundControl.AppImage 左上角Ready To Fly的位置按下去，中間會顯示一個小框框，裏面包括三個選項卡
Vehicle Setup
Analyze Tools
Aplication Settings
點擊Aplication Settings會出現六個選項卡. 其中包括CommLinks，點擊它
點擊Add
SerialPort = ttyACM0
Baud Rate = 115200
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8658ac800d04e92153d1f272815e4b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b20535ae3d206f8a43c3a68b67415d3/" rel="bookmark">
			leetcode:二叉树的左右子树反转的递归和迭代的C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给定一个二叉树，将其每个节点的左右子树进行反转。
解决方案 以下是 C++ 代码实现：
TreeNode* invertTree(TreeNode* root) { if (root == nullptr) { return nullptr; } // 交换当前节点的左右子树 TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; // 递归反转左右子树 invertTree(root-&gt;left); invertTree(root-&gt;right); return root; } 代码解释 如果当前节点为空，则直接返回 nullptr。交换当前节点的左右子树。递归地对左子树和右子树进行相同的操作。返回当前节点作为新的根节点。 递归和迭代方法 上述解决方案使用了递归方法，它是简洁且易于理解的。然而，也可以使用迭代方法来反转二叉树，通常使用队列或栈来实现。
以下是使用队列进行迭代的 C++ 代码示例：
TreeNode* invertTreeIterative(TreeNode* root) { if (root == nullptr) { return nullptr; } queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { TreeNode* current = q.front(); q.pop(); // 交换当前节点的左右子树 TreeNode* temp = current-&gt;left; current-&gt;left = current-&gt;right; current-&gt;right = temp; // 将子节点加入队列 if (current-&gt;left !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b20535ae3d206f8a43c3a68b67415d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b14665a6c9e0bdbcfba636e0c168313/" rel="bookmark">
			算法学习05：离散化、区间合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法学习05：离散化、区间合并 文章目录 算法学习05：离散化、区间合并前言需要记忆的模版：一、离散化1.例题：离散化 + 区间和：拓展: 二、区间合并（贪心）1.例题： 总结 前言 需要记忆的模版： vector&lt;int&gt; alls;//存储所有待离散化的值 sort(alls.begin(), alls.end());//将所有值排序 //去除重复的元素，并且不重复的元素 有序 的排在前面 alls.erase(unique(alls.begin(), alls.end()), alls.end()); //找到有序的排在前面的 坐标 所对应的 索引 //返回 坐标 所对应的 映射 int find(int x) { int l = 0, r = alls.size() - 1; while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1;//索引从0开始，映射后从1开始 } //区间合并： void merge(vector&lt;PII&gt; &amp;segs) { vector&lt;PII&gt; res; //按照 区间左端点 排序 sort(segs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b14665a6c9e0bdbcfba636e0c168313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad991d34452c57616c48aeff318aef80/" rel="bookmark">
			OVS - 数据包处理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在介绍OVS数据包的处理过程之前，首先得了解下OVS和SDN的相关概念
SDN 简介 SDN（Software-Defined Networking）是一种网络架构和理念，与传统网络架构最大的区别就在于将网络的控制平面从数据平面中分离出来，将网络决策集中在一个独立的软件控制器中，从而使网络更加灵活、可编程和易于管理。
在整体架构中，首先需要明确SDN控制器和网络设备两个概念：
SDN控制器（SDN Controller）：控制器是SDN的中央控制节点，它负责管理整个网络的行为和策略。控制器可以通过北向接口与上层应用程序或网络管理平台进行通信，通过南向接口与网络设备（如交换机和路由器）进行通信。控制器接收上层应用程序的指令，并将指令转化为底层网络设备的配置，从而实现对网络流量的控制。网络设备（Switches/Router）：SDN网络中的网络设备是传统交换机和路由器，但与传统网络不同的是，它们的数据转发平面和控制平面分离。网络设备在SDN架构中被称为数据面设备，负责根据SDN控制器下发的指令，进行数据包的转发和处理 具体的结构可参考下图：
OVS 简介 OVS（Open vSwitch）是一个开源的虚拟交换机软件， 是SDN架构中数据平面的一部分。通过使用OVS，可以起到以下作用：
网络虚拟化： OVS 允许创建虚拟网络，这些网络可以在物理网络基础上进行划分，为不同的虚拟机、容器或租户提供独立的逻辑网络，从而增加了网络资源的灵活性和利用率。流量控制和管理： OVS 具有流表和流量匹配功能，可以根据不同的规则、条件和策略来控制和管理网络流量。这有助于实现负载均衡、流量隔离、QoS（服务质量）管理等。网络隔离和安全性： OVS 可以帮助实现虚拟网络之间的隔离，确保不同租户或应用之间的网络流量互不干扰。这有助于提高网络的安全性。网络监控和分析： OVS 支持流量镜像和抓包功能，可以方便地进行网络监控和分析，帮助排查问题、优化网络性能。灵活的网络配置： OVS 允许管理员动态地配置网络，添加、删除和修改网络规则，适应不同的应用需求，而无需依赖硬件更改。支持 SDN 控制器： OVS 可以与 SDN 控制器集成，通过控制器来统一管理和编程网络，实现集中式的网络控制和自动化。支持各种网络拓扑： OVS 支持多种网络拓扑，包括扁平网络、树状拓扑、多层拓扑等，使网络构建更加灵活。 主要组件 OVS中主要包含 ovs-vswtichd、ovsdb-server、openvswitch.ko 三个基本组件
ovs-vswtichd 是一个守护进程，是 ovs 的管理和控制服务，通过 unix socket 将配置信息保存到ovsdb，并通过 netlink 和内核模块交互ovsdb 则是 ovs 的数据库，保存了 ovs 配置信息openvswitch.ko 是 OVS 的内核模块，实现了 OVS 数据平面（Data Plane）和控制平面（Control Plane）之间的连接，其中还包含一个关键的部分就是datapath，通过 datapath 在内核层面完成数据包的转发、过滤和处理，以实现虚拟网络的各种功能。 各组件之间的关联关系可参考下图
图一
转发流程 通过上面的介绍，可以了解到 ovs 中包含一个名为 openvswith.ko 的内核模块，其中的 datapath 负责执行数据处理。那么接下来参考图一介绍当一个数据包到OVS后首次处理的流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad991d34452c57616c48aeff318aef80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18387ac1cdee5113a6f537f7b37c32b/" rel="bookmark">
			spring项目自定义全局响应处理器，统一处理响应结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方式 使用@ControllerAdvice注解和实现ResponseBodyAdvice接口自定义全局响应处理器
实现步骤 自定义统一返回类 定义统一返回类，包装返回结果
@Data @JsonInclude(JsonInclude.Include.NON_NULL)//过滤null，提高性能 @ApiModel(value = "返回类") public class Wrapper&lt;T&gt; implements Serializable { /** * 成功码 */ public static final int SUCCESS_CODE = 200; /** * 成功信息 */ public static final String SUCCESS_MESSAGE = "操作成功"; /** * 错误码 */ public static final int ERROR_CODE = 500; /** * 错误信息 */ public static final String ERROR_MESSAGE = "内部异常"; /** * 编号 */ @ApiModelProperty("编号") private int code; /** * 信息 */ @ApiModelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18387ac1cdee5113a6f537f7b37c32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec0098b81673091ac0c9a06e968cd92/" rel="bookmark">
			启动vue项目执行npm run serve报错 ： error in ./src/element-variables.scss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error in ./src/element-variables.scss 问题原因 node-sass的版本问题
解决方式 我直接更新了一下node-sass，就好了
npm install node-sass 再次执行就可以执行成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d131a156dd21352e646b6e63cd0f8f4/" rel="bookmark">
			最好用的六款虚拟机软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
说起虚拟机，相信作为技术人员的小伙伴们不会感到陌生。虚拟机的使用场景非常多，如搭建测试环境、在Windows系统中安装Linux或在Mac机器上运行Windows系统、甚至还可以用来进行安全实验。
虚拟机的关键优势在于实现了跟原生系统的完全隔离，这使得我们可以在虚拟机上做各类测试，而不担心宿主机的崩溃。
下面，我将介绍目前市面上适合个人用户使用的六款最佳虚拟化软件，让你可以更好的选择。
一. VMware Workstation Vmware作为全球最知名的虚拟化企业，至今已有超过20年的发展历史。在针对个人用户的产品上，Vmware提供了适用于Apple Mac的Vmware Fusion和适用于PC的Vmware WorkStation。
Vmware Workstation是一款功能强大的桌面虚拟计算机软件，可在一台主机上同时运行多个不同的操作系统。同时，也是少有可以支持DirectX 12和OpenGL 4.7的虚拟化软件，使得在虚拟机上能够轻松运行3DMax、AutoCAD、Maya等要求苛刻的应用程序。Workstation还具有高级网络设置功能，允许您设置和管理更为精准的虚拟网络，也可为多个系统设置不同的隐私权限和网络配置；另外，软件带有的模板和克隆功能，使得批量创建虚拟机变得简单而方便。
在费用方面，Vmware针对个人用户提供Workstation Player免费使用，若需更为专业和复杂的功能，则可升级至Workstation Pro。
特点：
提供针对个人用户的免费版本。
支持GPU虚拟化。
具有强大且全面的功能。
支持Windows和Linux操作系统。
二. Vmware Fusion VMWare Fusion 是VMware针对Mac用户提供的虚拟化产品，尽管与Workstation名称不同，但两种产品实际上提供了相同的解决方案，并针对于不同的操作系统进了量身定制。
作为支持在Mac机器上运行Windows系统的软件，Fusion设有UnityView模式，该模式可使各操作系统界面之间无缝衔接，同时也支持各操作系统之间直接拖曳文件等共享功能。针对开发人员和游戏玩家，Fusion配备有GPU虚拟化功能，便于软件的开发或提高游戏画面质感。
针对个人用户，Fusion提供免费的基本版；针对商业或需要高级功能的个人用户，则提供了付费的Fusion Pro。
特点：
支持MacOS系统
支持GPU虚拟化。
提供针对个人用户的免费版本。
三. VirtualBox VirtualBox是由德国InnoTek软件公司出品的自由及开放源代码的虚拟机软件，现由甲骨文公司进行开发。VirtualBox是一款优秀的虚拟化软件，可在Windows，Linux，Macintosh和Solaris主机上运行。对于虚拟化系统的支持非常广泛，从XP版本开始的Windows系统、任何高于2.4内核的LInux版本、Apple Mac、Solaris、OpenSolaris甚至 OpenBSD Unix。在功能上，VirtualBox支持USB设备的识别功能，GPU虚拟化功能，可同时运行多个虚拟机系统窗口。
更重要的是，VirtualBox是免费的，甚至包括企业版。
特点：
免费
支持非常广泛的操作系统
支持GPU虚拟化技术；
四. QEMU QEMU是一款由法布里斯·贝拉等人编写，可执行硬件虚拟化的（hardware virtualization）开源仿真器（Emulator）。QEMU与其他VM 解决方案不同的地方在于，它既是虚拟机，也是机器模拟器。
QEMU可以通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS。QEMU还可以通过与KVM一起使用，从而以接近真实电脑的速度来运行虚拟机。
特点：
免费
机器模拟器
操作简单
五. Parallels Desktop Parallels Desktop是由Parallels推出的一款为苹果电脑提供硬件虚拟化的软件，产品于2006年6月发布，它是第一款能在苹果-英特尔架构的苹果电脑上使用的虚拟化软件。
如果你想在Mac上运行Windows系统，那么Parallels Desktop 会是你的最佳选择。它可以在 Intel 或 Apple M 系列 Mac 计算机上无缝运行 Windows 应用，最大限度地解决了 MacOS 与 Windows 软件生态差距方面的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d131a156dd21352e646b6e63cd0f8f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/48/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>