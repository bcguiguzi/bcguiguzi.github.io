<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74556c3b5be3fdb0c448afe1f01a0400/" rel="bookmark">
			【k8s系列】(202402) 证书apiserver_client_certificate_expiration_seconds
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apiserver_client_certificate_expiration_second证书定义的位置：kubernetes/staging/src/k8s.io/apiserver/pkg/authentication/request/x509/x509.go at 244fbf94fd736e94071a77a8b7c91d81163249d4 · kubernetes/kubernetes (github.com) apiserver_client_certificate_expiration_seconds表示的含义：src/k8s.io/apiserver: Increase cert expiration histogram resolution · kubernetes/kubernetes@f90bbc3 (github.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f07b4bc2add1d24b2292f4353af786/" rel="bookmark">
			线程池设计---C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是线程池： 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。
线程池的应用场景：
需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，出现错误. 线程池示例：
创建固定数量线程池，循环从任务队列中获取任务对象获取到任务对象后，执行任务对象中的任务接口 锁设计 采用RAII风格的加锁方式，用于保护在出了临界区后，忘记解锁的情况。
Mutex 类：
Mutex 类封装了 pthread_mutex_t 互斥锁。它包含 lock 和 unlock 方法，分别用于加锁和解锁。构造函数接收一个指向 pthread_mutex_t 的指针，并将其存储在私有成员 _pmtx 中。 lockGuard 类：
lockGuard 类是 RAII 风格的锁保护类。在构造函数中，它接收一个 pthread_mutex_t 指针并使用 Mutex 类将锁住。在析构函数中，它解锁互斥锁。这样，当 lockGuard 对象超出范围（超出了作用域），它的析构函数将确保互斥锁被正确解锁，即使在发生异常的情况下也是如此。 #include &lt;iostream&gt; #include &lt;pthread.h&gt; class Mutex{ public: Mutex(pthread_mutex_t *mtx) :_pmtx(mtx) {} void lock() { pthread_mutex_lock(_pmtx); } void unlock() { pthread_mutex_unlock(_pmtx); } ~Mutex() {} private: pthread_mutex_t *_pmtx; }; // RAII风格的加锁方式 class lockGuard { public: lockGuard(pthread_mutex_t *mtx) :_mtx(mtx) { _mtx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f07b4bc2add1d24b2292f4353af786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2a02028cc5eaa21fb3d995a961d7f6/" rel="bookmark">
			idea设置自动编译spring boot代码，idea代码修改后无须重启服务立即生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 系统环境：windows 10
idea版本：IntelliJ IDEA 2022.2.3 (Ultimate Edition)
springBoot版本：2.2.6.RELEASE
在Spring Boot开发应用程序时，需经常要进行频繁的代码修改和调试。
为了更好的提高开发效率，希望能够自动编译和热更新应用程序，以便我们在修改代码后无需手动多次进行重新启动应用程序。
二、解决办法 1、在pom.xml文件中添加以下依赖项 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; spring-boot-devtools依赖项是Spring Boot的开发工具，它提供了自动编译和热更新的功能。
2、设置IDEA自动编译 打开IDEA，选择“File” -&gt; “Settings” -&gt; “Build, Execution, Deployment” -&gt; “Compiler”。
在右侧一栏中，勾选“Build project automatically”选项。这样在保存文件时，IDEA将自动触发编译过程
3、设置Spring Boot热更新 在IDEA中，选择“Run” -&gt; “Edit Configurations”。
在弹出的对话框中，选择您的Spring Boot应用程序配置，
点击右侧“Modify options”，找到“On frame deactivation”选项，并选择“Update classes and resources”。
这样，在IDEA失去焦点时，应用程序将自动更新类和资源。
4、运行Spring Boot应用程序 在IDEA中，打开“src/main/java”目录，并找到Spring Boot应用程序的入口类进行启动测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ddcfe28dda19e622860ba99a96f438/" rel="bookmark">
			进程间的通信方式之【管道】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程间的通信方式主要分为三类：管道、共享内存、消息队列；但实际上进程的通信方式可以分为六类：管道、共享内存、消息队列、信号量、信号、socket套接字编程。
进程间通信的必要性： 1.进程在操作系统内核中是独立的进程控制块（PCB），即一个一个struct task_struct{....}结构体对象。
2.每一个进程有自己独立的进程地址空间，即进程间的数据是独立的，也就造就了进程间的独立性。
3.进程和进程间交换数据较困难，所以有了进程间通信来完成数据交换过程。
一、管道 匿名管道： 只能在单个进程内部进程通信，即父子进程。
pipe函数的认识： NAME
pipe, pipe2 - create pipe
SYNOPSIS
#include &lt;unistd.h&gt;
int pipe(int pipefd[2]);
DESCRIPTION
pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe.
RETURN VALUE
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
A. 管道函数成功调用会创建出来一个匿名管道，对应在内核中会有一个内核缓冲区
B. Pipefd是一个数组，数组有两个元素，分别对应管道的读写两端.
fd[0]：是管道的读端fd[1]：是管道的写端都是文件描述符 C. Pipefd这个参数是输出性参数，不需要程序员赋值.由Pipe函数在调用时赋值.
D.创建成功返回0，创建失败返回-1.
pipe函数使用： #include &lt;iostream&gt; #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ddcfe28dda19e622860ba99a96f438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b769e954e239e00174ed86ee92645ae/" rel="bookmark">
			window使用gdb调试qemu调试裸机程序步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.qemu在启动的时候命令行添加：
-S :在开始时暂停
-s ：启动gdbserver服务，你也可以使用ctrl+alt+2进入monitor界面 执行gdbserver
2.启动gdb
这里尝试使用windbg，怎么也连接不上，所以只能安装mingw来使用gdb.
幸亏我电脑上有qt安装了mingw的编译器。
由于我在qemu上使用的是qemu_system_x86_64.exe
所以gdb这里也使用的64位的环境，在window菜单栏找到了qt，然后展开：
右键以管理员权限运行：
MinGW 7.3.0 64-bit
进入命令行之后：
target remote localhost:1234
即可成功调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09be1265affa87687b0381c15040292/" rel="bookmark">
			【2024版】最新渗透攻击实例-漏洞扫描和注入攻击的工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前比较好用的工具主要有以下这些：
1、Arachni (Ruby)
Arachni 能适用于多平台和多语言，开源的，全面的、模块化的Web漏洞扫描框架，具有良好的可扩展性，通过添加插件可以增加它的扫描范围和深度。
2、Xsspy (python)
主要针对XSS漏洞的漏洞扫描器，Xsspy不仅仅检查一个页面，它可以便利网站，以及子域名。之后，它开始扫描每一个页面，发现可能存在的跨站点脚本漏洞。Xsspy采用了许多小而有效的payload，可以有效的扫描网站存在的XSS漏洞。
3、W3af (python)
可用于linux和window（但是在最新的版本中windows不再更新）的漏洞扫描器，可检测超200种漏洞，w3af框架具有图形用户界面和控制用户界面，只需要单击5次即可，并且使用与定义的配置文件，可以审核web应用程序的安全性。
4、Nikto （集成在kali中的一款漏洞扫描器）
Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描
5、Wfuzz (python)
主要是做web模糊测试的工具，Wfuzz是一个完全模块化的框架，有很好的可扩展性，使用简单。
6、ZAP (java) 攻击代理服务器
世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞
7、SQLmap (python2脚本)
最常用的数据库漏洞及sql注入工具
8、Grabber (python)
是Kali Linux集成的一款Web应用扫描工具。该工具适合中小Web应用，如个人博客、论坛等，支持常见的漏洞检测，如XSS、SQL注入、文件包含、备份文件检测、Ajax检测、Crytal Ball检测等功能。该工具只进行扫描，不实施漏洞利用。由于功能简单，所以使用非常方便，用户只要指定扫描目标和检测项目后，就可以进行扫描了。
9、Wapiti (python)
Wapiti是针对Web应用程序的漏洞扫描程序。它能准确扫描存储型XSS，SQL和XPath注入，文件包含，命令执行，XXE注入，CRLF注入等漏洞。
10、Golismero
GoLismero是安全性测试的开源框架。它是目前面向网络的安全性，但它可以很容易地扩展到其他类型的扫描。
11、OWASP Xenotix
XSS 是一个高效的跨站脚本漏洞（XSS）检测和攻击测试框架。它通过特有的三大浏览器引擎（包括Trident, WebKit和Gecko）进行安全扫描检测，并且其号称拥有全世界第二大的XSS测试Payload，同时具有WAF绕过能力。
12、Vega
Vega是一个免费的开源扫描和测试平台，用于测试Web应用程序的安全性。Vega可以帮助您查找和验证SQL注入，跨站点脚本（XSS），泄露的敏感信息以及其他漏洞。它基于Java编写，基于GUI，可在Linux，OS X和Windows上运行
最后，推荐使用ZAP
ZAP 全程OWASP Zed Attack Proxy攻击代理服务器是世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞。另外，它也是一款提供给具备丰富经验的渗透测试人员进行人工安全测试的优秀工具。
ZAP以架设代理的形式来实现渗透性测试，类似于fiddler抓包机制。他将自己置于用户浏览器和服务器中间，充当一个中间人的角色，浏览器所有与服务器的交互都要经过ZAP，这样ZAP就可以获得所有这些交互的信息，并且可以对他们进行分析、扫描，甚至是改包再发送。可进行本地代理、主动扫描、被动扫描、Fuzzy、暴力破解等。
为了帮助大家更好的学习网络安全，我给大家准备了一份网络安全入门/进阶学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂这些资料！
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8722debfbf2f6ff531ce72bf55f634bd/" rel="bookmark">
			【数据结构与算法】(11)基础数据结构 之 二叉树 二叉树的存储与遍历及相关示例 详细代码讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 2.10 二叉树1) 存储2) 遍历广度优先深度优先递归实现非递归实现 习题E01. 前序遍历二叉树-Leetcode 144E02. 中序遍历二叉树-Leetcode 94E03. 后序遍历二叉树-Leetcode 145E04. 对称二叉树-Leetcode 101E05. 二叉树最大深度-Leetcode 104E06. 二叉树最小深度-Leetcode 111E07. 翻转二叉树-Leetcode 226E08. 后缀表达式转二叉树E09. 根据前序与中序遍历结果构造二叉树-Leetcode 105E10. 根据中序与后序遍历结果构造二叉树-Leetcode 106 2.10 二叉树 二叉树是这么一种树状结构：每个节点最多有两个孩子，左孩子和右孩子
重要的二叉树结构
完全二叉树（complete binary tree）是一种二叉树结构，除最后一层以外，每一层都必须填满，填充时要遵从先左后右平衡二叉树（balance binary tree）是一种二叉树结构，其中每个节点的左右子树高度相差不超过 1 1) 存储 存储方式分为两种
定义树节点与左、右孩子引用（TreeNode）使用数组，前面讲堆时用过，若以 0 作为树的根，索引可以通过如下方式计算 父 = floor((子 - 1) / 2)左孩子 = 父 * 2 + 1右孩子 = 父 * 2 + 2 2) 遍历 遍历也分为两种
广度优先遍历（Breadth-first order）：尽可能先访问距离根最近的节点，也称为层序遍历深度优先遍历（Depth-first order）：对于二叉树，可以进一步分成三种（要深入到叶子节点） pre-order 前序遍历，对于每一棵子树，先访问该节点，然后是左子树，最后是右子树in-order 中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树post-order 后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点 广度优先 本轮开始时队列本轮访问节点[1]1[2, 3]2[3, 4]3[4, 5, 6]4[5, 6]5[6, 7, 8]6[7, 8]7[8]8[] 初始化，将根节点加入队列循环处理队列中每个节点，直至队列为空每次循环内处理节点后，将它的孩子节点（即下一层的节点）加入队列 注意
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8722debfbf2f6ff531ce72bf55f634bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f93a5caf0a77f0588f2e40a7e71528/" rel="bookmark">
			【数据结构与算法】(10)基础数据结构 之 堆 建堆及堆排序 详细代码示例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 2.9 堆建堆习题E01. 堆排序E02. 数组中第K大元素-Leetcode 215E03. 数据流中第K大元素-Leetcode 703E04. 数据流的中位数-Leetcode 295 2.9 堆 以大顶堆为例，相对于之前的优先级队列，增加了堆化等方法
public class MaxHeap { int[] array; int size; public MaxHeap(int capacity) { this.array = new int[capacity]; } /** * 获取堆顶元素 * * @return 堆顶元素 */ public int peek() { return array[0]; } /** * 删除堆顶元素 * * @return 堆顶元素 */ public int poll() { int top = array[0]; swap(0, size - 1); size--; down(0); return top; } /** * 删除指定索引处元素 * * @param index 索引 * @return 被删除元素 */ public int poll(int index) { int deleted = array[index]; up(Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f93a5caf0a77f0588f2e40a7e71528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0265442efc61e99990c0af07845e80e/" rel="bookmark">
			【flutter】报错 cmdline-tools component is missing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在flutterSDK目录下，双击flutter_console.bat，调出命令行。
输入flutter doctor，如果第三个诊断为[x]，报cmdline-tools component is missing错（我这已经修改好了，所以是勾了），那就可以用以下方法解决。
解决方法 1.安装Android SDK command-line Tools 我使用的是Android studio，路径是Tools-&gt;SDK Manager
安装Android SDK command-line Tools就好。
然后在命令行执行如下命令
flutter doctor --android-licenses 2.修改了android SDK目录 我执行了上面的操作没有解决问题，参考了flutter cmdline-tools component is missing可能的问题。-CSDN博客 。
还是Android SDK这个位置，我的Android SDK Location已经改了，是E:\AndroidSDK\Sdk\Sdk。
命令行输入如下命令：
flutter config --android-sdk "你自定义的sdk路径" 我输入了flutter config --android-sdk "E:\AndroidSDK\Sdk\Sdk" ，就解决了问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972e9c20ec4f94cb321a945c4f5d1a4f/" rel="bookmark">
			比值计算 - 荣耀机试真题题解 ( 第1题 100 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：牛客网
考试时长： 90分钟
试卷总分： 300分 （总共 2 题）
题目描述 已知差值 x = 10 ∗ l o g 10 ( S / N ) − 10 ∗ l o g 10 ( S / ( N + k ∗ N ) ) x=10*log10(S/N)-10*log10(S/(N+k*N)) x=10∗log10(S/N)−10∗log10(S/(N+k∗N))，计算10*log(k)并打印出来(整数即可)
输入描述 差值 x
输出描述 10*log10(k) 并打印出来(整数即可)
示例1 输入： 0.1 输出： -16 示例2 输入： 0.5 输出： -9 示例3 输入： 0.1 输出： -16 示例4 输入： 3 输出： 0 题解 乍一看这个题好像跟算法没什么关系。仔细推导发现是道 数学题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972e9c20ec4f94cb321a945c4f5d1a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7a1e1f3cfc86c1b90fe9e6281553d5/" rel="bookmark">
			uniapp毕业设计&#43;springboot智慧农业环境监测App[源码&#43;文档&#43;答疑&#43;远程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅选题推荐——以防找不到我们，点击上方订阅专栏✌✌\
Java毕设实战项目
Python毕设项目源代码
asp.net毕业设计项目
Uniapp安卓毕业设计项目
node.js毕业设计项目
python毕业设计
微信小程序毕业设计项目
php毕业设计
👇🏻文末获取源码联系👇🏻
一、项目介绍 大学本科专科计算机毕设项目毕业设计源码论文定制springboot智慧农业环境监测App_哔哩哔哩_bilibili大学本科专科计算机毕设项目毕业设计源码论文定制springboot智慧农业环境监测App共计2条视频，包括：F50 907-springboot智慧农业环境监测App、福利大放送-网站-IT实战课堂等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV1qm4y1T7n8?share_source=copy_web该项目含有源码、文档、PPT、配套开发软件、软件安装教程、项目发布教程、包运行成功以及课程答疑与微信售后交流群、送查重系统不限次数免费查重等福利！
软件开发环境及开发工具：
开发语言：Java
后台框架：springboot、ssm
安卓框架：Uniapp
JDK版本：JDK1.8
服务器：tomcat9.0
数据库：mysql 5.7
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
​
二、功能介绍 下面是系统运行起来后的一些截图：
三、拦截器代码 package com.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport; import com.interceptor.AuthorizationInterceptor; @Configuration public class InterceptorConfig extends WebMvcConfigurationSupport{ @Bean public AuthorizationInterceptor getAuthorizationInterceptor() { return new AuthorizationInterceptor(); } @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(getAuthorizationInterceptor()).addPathPatterns("/**").excludePathPatterns("/static/**"); super.addInterceptors(registry); } /** * springboot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7a1e1f3cfc86c1b90fe9e6281553d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b19d15fe660dce29555ba4274a4c35/" rel="bookmark">
			国内常用的一些yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装软件往往会用到yum源，国外的yum源体验不是那么好。国内的一些大公司和教育机构也提供了yum源服务，下面介绍一些常用的yum源。
1. 阿里云镜像源
阿里云提供了针对 CentOS 系统的镜像源，可以直接下载repo使用：
wget -O /etc/yum.repos.d/aliyun.repo http://mirrors.aliyun.com/repo/epel-7.repo
2. 腾讯云镜像源
腾讯云也提供了针对 CentOS 系统的镜像源，可以直接安装：
yum install -y https://mirrors.cloud.tencent.com/epel/epel-release-latest-7.noarch.rpm
3. 华为云镜像源
华为云镜像源同样可以用于CentOS系统，可以直接下载repo使用：
wget -O /etc/yum.repos.d/huawei.repo https://repo.huaweicloud.com/repository/conf/CentOS-7-reg.repo
下面是一些高校的YUM源
4. 清华大学 TUNA 源
清华大学 TUNA 源是一个针对国内用户的优质 YUM 源，以centos7示例，配置如下：
[tuna] name = TUNA baseurl = http://linux.tuna.tsinghua.edu.cn/centos/7/os/x86_64/ gpgcheck = 1 gpgkey = http://linux.tuna.tsinghua.edu.cn/centos/RPM-GPG-KEY-tuna 5. 中科大镜像源
中国科学技术大学提供了针对 CentOS 和 RHEL 的 YUM 源，以centos7示例，配置如下：
[ustc] name = USTC baseurl = http://mirrors.ustc.edu.cn/centos/7/os/x86_64/ gpgcheck = 1 gpgkey = http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b19d15fe660dce29555ba4274a4c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfae6a6bcf3944a4a898eb9cadb4008e/" rel="bookmark">
			Java实现数据可视化的智慧河南大屏 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示四、核心代码4.1 数据模块 A4.2 数据模块 B4.3 数据模块 C4.4 数据模块 D4.5 数据模块 E 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的数据可视化的智慧河南大屏，包含了GDP、人口、土地面积、企业数、人均收入数据排行、地图展示等模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，数据可视化的智慧河南大屏基于角色的访问控制，给数据管理员、普通用户使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 数据可视化大屏中央是河南省3D地形地图，标注一些具有代表性的信息，如河南省的历史背景，河南省土地面积，河南省的气候条件，河南省GDP总数占全国的比例，河南省人口数占全国人口数的比例，河南省的农业总产值占全国农业总产值的情况等将城市简介标注在地图上，将具有代表性的旅游景区标注在地图上，如：少林寺、龙门石窟、清明上河园、太行山大峡谷、殷墟博物馆、白马寺云台山、尧山等。将河南省代表性名人故里标注在地图上，如：岳飞、白居易、商鞅、杜甫、老子、张仲景、杨靖宇、刘禹锡、范蠡、李商隐等。两侧有重要城市的近一周的天气。两侧用柱状图呈现河南省各城市的GDP排名。两侧有柱状图呈现河南省各城市的人口数排名。两侧有饼状图呈现河南省地理地貌，如平原67%、盆地12%、山地15%等等两侧有折线图呈现河南省近几年GDP的变化趋势。 三、系统展示 四、核心代码 4.1 数据模块 A &lt;div class="plefttoday" style="margin-top: 10px"&gt; &lt;h2 class="tith2 white"&gt;关键指标总览&lt;/h2&gt; &lt;div class="lefttoday_tit" style="height: 8%"&gt;&lt;/div&gt; &lt;div class="lefttoday_number"&gt; &lt;div class="widget-inline-box text-center fl"&gt; &lt;p style="font-size: 22px"&gt;GDP&lt;/p&gt; &lt;h3 class="ceeb1fd" style="font-size: 28px"&gt;{{count1}}&lt;/h3&gt; &lt;/div&gt; &lt;div class="widget-inline-box text-center fl"&gt; &lt;p style="font-size: 22px"&gt;人口&lt;/p&gt; &lt;h3 class="c24c9ff" style="font-size: 28px"&gt;{{count2}}&lt;/h3&gt; &lt;/div&gt; &lt;div class="widget-inline-box text-center fl"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfae6a6bcf3944a4a898eb9cadb4008e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be6a7ce851043561c3ba0dd13c04769/" rel="bookmark">
			静态代码块中使用 ExecutorService 执行多线程会出现什么情况呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AQS系列 1、AQS核心原理
2、ReentrantLock 原理及示例
3、CountDownLatch / Semaphore 示例及使用场景
4、BlockingQueue 示例及使用场景
5、静态代码块中使用 ExecutorService 执行多线程会出现什么情况呢？
文章目录 AQS系列一、 一般场景二、static {} 场景三、原理（why?） 一、 一般场景 我们在 MultiThreadExample.java 中 编写一个 exec 方法，这个方法中通过 Executors.newFixedThreadPool(3) 初始化一个线程池，线程数量是 3，随后则提交三个任务，最后用 executorService.shutdown() 关闭线程池，再用 awaitTermination 方法来等待所有的线程执行完，exec 方法运行结束了。
那一般我们是在 main 方法中直接调用 exec() 方法来执行，代码如下：
public class MultiThreadExample { public static void main(String[] args) { exec(); } private static void exec(){ System.out.println("任务开始执行..."); // 创建一个固定大小的线程池，其中包含3个线程 ExecutorService executorService = Executors.newFixedThreadPool(3); // 启动任务1 executorService.execute(() -&gt; { for (int i = 1; i &lt;= 5; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be6a7ce851043561c3ba0dd13c04769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339fbf9066d6ed421e15123bec70f089/" rel="bookmark">
			密码安全（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		暴力破解法（Brute Force）又被称为穷举法，是一种密码分析的方法，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试9999次就能找到正确的密码。理论上除了具有完善保密性的密码以外，利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围。
暴力破解一般来说有三种方式：
排列组合：将数字、大写字母、小写字母、各种特殊字符排列组合，若是在不知道密码的长度情况下需要更多的逐渐增多位数，这样的运算量非常的大，这种方法需要高性能的破解算法和CPU/GPU做支持。
字典破解：通过社会工程学与人们常用的密码建立破译字典，然后逐个尝试。
排列组合+字典破解：两种方式的结合，增大破解的几率
从暴力破解的方式我们就可以看出来，他有一个简单、通俗易懂的名字，叫做：猜。一个个试，总有一天可以试出来，因为大小写字母、数字、特殊符号的个数是有限的，他们的排列组合也是有限的，只是特别多而已。
这样的方式在遇到弱口令是十分有效的，例如简单的 123456、电话号码、abcde。
所以只要密码设置的足够长，足够复杂便可以防范暴力破解这样的攻击方式。
暴力破解在 web 应用中主要用于用户登陆环节的破解，例如网页端的登陆、QQ、邮件、FTP、VNC、Telnet 等等。
可以看到这样的方式是非常消耗时间，穷举就是一种以时间换结果的一种方式。所以主要在两个时候使用：
攻击初期：尝试管理员用户的登陆密码是否为弱口令，或者是默认用户名密码。若是得到管理员用户名密码后面的攻击将会简单许多。
攻击末期：很难找到对方的漏洞与逻辑薄弱点，就只能尝试暴力破解。
在 Kali 中有两个暴力破解的工具很受人的喜爱：
burpsuite：拥有 web 界面，功能非常齐全，从代理到扫描、爬虫、修改发送数据包等等。总的来说：简单、易用、功能全。
hydra：著名黑客组织 thc 的一款开源的暴力破解工具，主要对需要网络登录的系统进行快速的字典攻击，包括 FTP、POP3、IMAP、Netbios、Telnet、HTTP Auth、LDAP NNTP、VNC、ICQ、Socks5、PCNFS 等协议！
这两个工具，你们可以自己去安装使用，网上都有教程，我这里只是讲一下原理而已。
不断通过尝试字典值，判断返回值从而查看是否破解成功
我们可以看到其实就是用户名与密码不断的尝试匹配的结果。
暴力破解的原理很简单，但是不同工具使用不同的算法机制，使用不同的字典所带来的效率是不同的。
所以暴力破解是万不得已的做法，效率太低，而且破解成功的几率不高。
同时防范暴力破解方法十分简单，将密码设置的尽量长，尽量复杂，同时包含有大小写字母、数据、特殊符号。对于开发人员，所有的组件尽量不要使用默认的账户与密码。
为了帮助大家更好的学习网络安全，我给大家准备了一份网络安全入门/进阶学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂这些资料！
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3130d939024c0066a4a02d802b0c17a/" rel="bookmark">
			uniPush2.0相关文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API：https://uniapp.dcloud.net.cn/api/plugins/push.html
云函数URL化：https://doc.dcloud.net.cn/uniCloud/http.html
开发者中心：https://dev.dcloud.net.cn/pages/app/push2/info
个推文档中心：https://docs.getui.com/getui/start/accessGuide/
uniPush2.0 快速接入指南：https://ask.dcloud.net.cn/article/40283
uniPush2.0 常见问题：https://ask.dcloud.net.cn/article/40291
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316b94ebce1cb6c65e5f5f8f90a637e5/" rel="bookmark">
			linux yum命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：搜索和显示
yum list &lt;package name&gt; --showduplicates#显示指定程序包安装情况或可下载的安装包 yum list &lt;package name&gt; --showduplicates| sort -r#可下载的安装包，并按版本排序 yum search keyword #根据关键词keyword去搜索包含改关键词的包 yum info &lt;package name&gt;#显示安装包信息 2：搜索已经安装的包
yum list installed |grep xxx 3：安装
yum groupinsall &lt;group name&gt; #安装程序组,yum -y groupinstall "Development Tools",表示安装常用开发工具组，git,svn等 yum install &lt;package name&gt;#安装某个报最新版本 yum install &lt;package name&gt;-&lt;version info&gt;#安装指定版本的包 #以下示例，以RH442需要安装的kernel-debuginfo包为例 yum list kernel-debuginfo --showduplicates #Loaded plugins: product-id, refresh-packagekit, security, subscription-manager #Updating certificate-based repositories. #Available Packages #kernel-debuginfo.x86_64 2.6.32-220.el6 kernel-extras #kernel-debuginfo.x86_64 2.6.32-220.2.1.el6 kernel-extras #kernel-debuginfo.x86_64 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316b94ebce1cb6c65e5f5f8f90a637e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b258db91588cb28ebc4049061f6c99/" rel="bookmark">
			linux 账号权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		账号管理 linux权限管理严格，这也是其安全的保证，对文件、目录分为主、组、其他三级权限控制，其中/etc/passwd，/etc/group,/etc/shadow文件分别存储了账号，组，密码详情。
关于组 #创建组号 groupadd web #创建组号时指定gid groupadd -g 5 web 每个组有唯一的gid,我们通过cat /etc/group看到其gid:
[root@localhost root]# cat /etc/group root:x:0:root,pigfu web:x:1: admin:x:2: 可以看web组的gid是 1。
其内容用 ： 来分割，依次表示：
组名，不能重复；口令，即密码，一般Linux系统的用户组都没有口令，用x表示；组标识号（gid）,一个整数，被系统内部用来标识组,别称GID,唯一的;是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 关于账号 #创建账号 useradd -g web php #创建账号并指定附加组 useradd -g web –G admin,root php #通过-G指定php账号的除了属于组web还属于root和admin 每个账号有唯一的uid,我们通过cat /etc/passwd看到其uid:
[root@iZwz943yllm8g13xj9uu30Z lib64]# cat /etc/passwd root:x:0:0:root:/root:/bin/bash php:x:1:2::/home/php:/bin/bash 可以看到php账号的uid是1，组id是2。
内容解析如下：
1）"用户名"是代表用户账号的字符串。
通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(😃，因为冒号在这里是分隔符。
为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。
2）“口令”一些系统中，存放着加密后的用户口令字。
虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。
3）“用户标识号”是一个整数，系统内部用它来标识用户。
一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。
通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。
4）“组标识号”字段记录的是用户所属的用户组。
它对应着/etc/group文件中的一条记录。
5)“注释性描述”字段记录着用户的一些个人情况。
例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。
6)“主目录”，也就是用户的起始工作目录。
它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。
Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b258db91588cb28ebc4049061f6c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f141608cc02548881c571778e88b57/" rel="bookmark">
			实现类似chart GPT文字流式输出的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言实现思路 前言 该效果需要使用到SSE通信方式，对此不太熟悉的小伙伴，可以先看一下我的这篇文章，先大致了解一下SSE的基本用法
实现思路 利用了MVVM架构模式原理，数据双向流，逻辑层中的数据更新会引发视图层dom的重新渲染，首先先通过ref声明一个响应式变量用于获取到用户的历史对话记录，对话框组件遍历的就是这个变量；
因为openAI返回数据的形式是逐个字符的返回（以[start]开始，以[DONE]结束，因此当时是定义了一个中间临时变量来接收数据，通过复合赋值运算符（+=）来实现实时更新上面提到的响应式变量，最后就可以在视图层上看到文字随接口返回数据的频率流式输出的效果，也可以达到历史对话记录实时更新的更新的一个目的。
具体的实现步骤：
首先获取本地的聊天记录，声明响应式变量testMessage接收，使用之前封装的对话框组件，遍历本地对话记录创建一个临时中间变量message，用来实时接收接口返回的数据先通过axios调用第一个接口获取到发送会话请求的key值拿到key值后携带向chart GPT提出的内容通过SSE通信方式创建通信实例对象（new EventSource），向openAI接口发起请求实时监控通信过程，动态更新中间临时变量message，然后在push到用于存储本地会话记录的变量中，这样中间临时变量更新，也会触发视图层对应的对话框重新渲染，从而实现文字流式输出的效果，同时也更新了本地的会话记录。当检测到返回的数据为[DONE]时，停止监控，结束通信。 // 接收流式输出 let message = ref('') sendingPrompt(data).then(res =&gt; { if (window.EventSource == null) { alert('The browser does not support Server-Sent Events'); } else { //请求 var eventSource = new EventSource(`/api/gpt/send/?key=${res.data}`); eventSource.onopen = function () { console.log('connection is established'); }; eventSource.onerror = function (error) { console.log('报错了'); }; // 请求成功后先创建一个空的对象 testMessage.value.push({ id: timeStamp.value, content: "", role: 'assistant' }) eventSource.onmessage = function (event) { if (event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0f141608cc02548881c571778e88b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9c73ac3705af12fd53127e85d3e1e3/" rel="bookmark">
			Shiro---快速入门【使用&amp;了解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作步骤 官网地址 ：https://shiro.apache.org/10-minute-tutorial.html
首先创建一个maven的项目
1. 导入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- configure logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 配置文件 提示：如果idea中没有安装ini插件是和我下面的显示效果是一样的
(1) shiro.ini
# ----------------------------------------------------------------------------- [users] # user 'root' with password 'secret' and the 'admin' role root = secret, admin # user 'guest' with the password 'guest' and the 'guest' role guest = guest, guest # user 'presidentskroob' with password '12345' ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9c73ac3705af12fd53127e85d3e1e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/67/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>