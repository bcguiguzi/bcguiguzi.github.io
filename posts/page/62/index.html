<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6acb61fa840118da04add236be28ff/" rel="bookmark">
			js 常用简写技巧（干货满满）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一些常用的js简写技巧，会着重挑选一些实用的简写技巧，使代码更简洁优雅~
这里只会收集一些大多数人不知道的用法，但是确实能提高自己的编码技巧，像ES6那些基础的简写语法或者是三目运算符代替if else那些我觉得是基础，没必要写在这里浪费精力。
注意本篇内容涉及到的语法从ES6到ES11不等，具体使用需要考虑项目兼容性问题！
If-Else 用 || 或 ?? 运算符进行简化 逻辑或操作符||，这里要注意的是0和''也会认为是false
如果||前面的值是0 '' false null undefined NaN其中的任意一种，则直接返回||后面的值
function(obj){ var a = obj || {} } // 等价于 =&gt;&gt; function(obj){ var a; if( obj === 0 || obj === "" || obj === false || obj === null || obj === undefined || isNaN(obj) ){ a = {} } else { a = obj; } } 空值合并操作符??如果没有定义左侧返回右侧。如果是，则返回左侧。
这种方法非常实用，有时候仅仅只是想判断一个字段有没有值，而不是把空字符串或者0也当做false处理
function(obj){ var a = obj ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6acb61fa840118da04add236be28ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56dbfbd5bf6ab066cfc5c686e830fff3/" rel="bookmark">
			byte与int互转及原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在解析微软.bmp图片格式的时候,bmp格式的文件前两个字节是固定的0x424D，后面4个字节是该bmp文件的大小，在使用 DataInputStream.readInt 读取的大小和预期不一致，基于此，整理了研究过程....
二、Byte解析 2.1 Byte理解 byte是字节的意思，一个字节是8位，范围是 0000 0000 ~ 1111 1111(十六进制：0x0~0xff),总共包含256个数。
java里 byte 范围是 -128~127
C#里的byte 范围是 0~255
存储的数据二进制都是一样的，只是每个语言定义的问题，高位是否定义为符号位，其数据自身二进制形式是一样的
计算机存储的是 机器码，存储的值是 原数值的补码，
java里的byte 高位是符号位
正数部分：正数的补码还是自己，即 0000 0000 ~ 0111 1111 表示范围是 [0,127] ,
负数部分：负数的补码 是该数的原码除负号位外各位取反，然后在最后一位加1，即 1111 1111 ~ 1000 0000 对应的原值 1 0000 0000 ~ 1000 0001 即为 [-128,-1]
C#里的byte是无符号数，所以全部是正数，即 0000 0000 ~ 1111 1111 表示范围是 [0,255] 虽然取值范围不同，但是byte存储的结构还是一致，依然是8位 0000 0000 ~ 1111 1111，通过以下代码验证。
2.2 代码验证 2.2.1 java验证 选取 0，1，127，-1，-128 打印对应的结构,所以可以看出 是有符号的数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56dbfbd5bf6ab066cfc5c686e830fff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b37795520d56a59f0b4d26ef0a052b/" rel="bookmark">
			Linux C&#43;&#43; 字符编码转换 GBK与UTF8互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 下使用 iconv 命令可以转换文件的编码 iconv -f GBK -t UTF-8 input_file -o output_fileC++ 代码 使用 iconv 函数 iconv 函数签名： size_t iconv(iconv_t cd,、
char **inbuf, size_t *inbytesleft,
char **outbuf, size_t *outbytesleft);
需要注意的是， iconv 函数的 inbuf 参数以及 outbuf 参数会被修改，内部的实现是使用类似
(*p)++ = xxx 的形式操作这两个指针，inbytesleft 会被修改为输入字符串剩余多少没有处理，
outbytesleft 会被修改为 outbuf 还有多少字节没有使用。iconv 返回 (size_t)-1 表示失
败，返回0表示成功，返回大于0表示出现了不可逆转的字符处理。
static std::string CharConv(const std::string&amp; str, const char* fromcode, const char* tocode) { iconv_t cd = iconv_open(tocode, fromcode); if (cd == (iconv_t)-1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b37795520d56a59f0b4d26ef0a052b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f32b773a79245dedd0edf9542fd5f22/" rel="bookmark">
			使用GeoScene Pro发布托管要素服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必备软件： GeoScene Pro GeoScene Enterprise
本文使用的软件版本均为3.1版本
步骤1： 启动GeoScene Pro并登录到Portal
如下图所示显示未登录，需要登录，若显示用户名，则表示登录成功
点击管理门户
若列表中没有要登录的portal，点击下方的添加门户
按照提示添加门户即可
登录门户
输入用户名密码
显示未图示字样，代表登陆成功，后面后面三个点，设置为活动门户
返回上一级页面，将数据加入到地图中
步骤2： 发布服务
设置服务相关属性，一定要选择图示中框柱的选项
然后点击分析、发布即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428ad3c89af3d695ef86df1080a6c7fd/" rel="bookmark">
			WSL系统手动挂在移动硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用数据线接上了一个移动硬盘，但是 WSL 却没有显示，可能需要重启WSL才行，但是我不想重启，于是只能手动来挂载了
mkdir /mnt/g mount -t drvfs G: /mnt/g ls /mnt/g ls /mnt # 弹出硬盘 umount /mnt/g 参考：https://blog.csdn.net/u010164190/article/details/125708030
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a77a82be501b3e7529da65c96a50145/" rel="bookmark">
			Python3基础之import和from import的用法和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模块和包 1、模块 一个 python 的文件就叫做模块（module），如 xxx.py。模块就是一组功能的集合体，我们的程序可以导入模块来复用模块里的功能。
2、包 一个包含有__init__.py 文件的目录或文件夹就叫做包(package)。在 pycharm 中选择 python package 创建的目录就是一个包。
二、模块和包的作用 1、方便管理 随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用
2、提升开发效率 我们也可以下载别人写好的模块然后导入到自己的项目中使用，可以极大地提升我们的开发效率
3、包的本质就是一个文件夹，那么文件夹唯一的功能就是将文件组织起来 随着功能越写越多，我们无法将所以功能都放到一个文件中，于是我们使用模块去组织功能，而随着模块越来越多，我们就需要用文件夹将模块文件组织起来，以此来提高程序的结构性和可维护性
三、模块和包的使用 项目结构如下图所示，要求：在 test.py 下调用模块文件中的变量、函数等。
➤module1.py 中代码
➤module2.py 中代码
1、方式一：from 模块 import 变量/函数/类 格式：from module import var,func,cls
注意：导入模块名和当前的 py 文件必须在同一级目录
例如：实现在 test.py 中调用 module2 模块中的内容
2、方式二：from 模块 import 变量名 as 其他变量名 格式：from module import var as other_var
例如： 要求test.py 中存在有与 module2 相同的变量名，要求同时使用 2 个变量名
3、方式三：from 包.模块 import 变量/函数/类 格式：from pkg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a77a82be501b3e7529da65c96a50145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0b075be859a8febf2fe7df6f2fb9ca/" rel="bookmark">
			软件测试面试必考的SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前找工作参加了几个面试，发现软件测试的笔试都有一道关于SQL的简答题，今天就把必考的题型及参考答案汇总一下。
基础SQL例子
1、创建表，如创建学生表Student，要求有学生姓名name，年龄age,班级class
大致写法是：
字段名 类型 是否为空 主键
CREATE TABLE Student ( name VARCHAR ( 255 ) not null primary key, age INT NOT NULL, class VARCHAR ( 255 ) NOT NULL ) 创建后表如下
2、修改字段名，基本语法是：
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型; 如把上表的name改为name1
ALTER TABLE Student CHANGE name name1 VARCHAR (255); 3、向Student表插入一条数据“小红,11,3年（2）班”
INSERT INTO student VALUES( '小红',12, '3年（2）班'); 4、删除Student表中name为“小红”的记录
delete from Student where name="小红"; 5、将Student表中name为小红，改为小小丽
UPDATE Student1 SET `name` = '小小丽' WHERE `name` = '小红' 6、求出每个年龄层的人数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c0b075be859a8febf2fe7df6f2fb9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39f8796e8cc8bef10ff04d7a1867638/" rel="bookmark">
			vue中的nextTick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是nextTick nextTick 是 Vue.js 中的一个全局 API，在JS的事件循环中它将回调函数放进微任务队列。DOM 的更新在同步任务队列清空后，且在微任务队列中的所有任务执行之前发生，这意味着在微任务队列中的dom是已更新的，所以nextTikc可以在dom更新后进行一些操作。
二、在什么时候用nextTick 需要在DOM 更新后执行操作：Vue.js 异步执行 DOM 更新。这意味着当你修改了数据，DOM 不会立即更新，而是等到下一次事件循环。nextTick 允许你在 DOM 更新后立即执行某些操作。例如，你可能想在数据更改后获取新的 DOM 元素尺寸或位置。确保视图与数据同步：在某些情况下，你可能需要确保视图已经与底层数据完全同步。使用 nextTick 可以确保在继续执行代码之前，DOM 已经根据最新的数据进行了更新。 三、VUE2与VUE3中使用nextTick vue2:
this.$nextTick(function () { // DOM 现在已经更新 }) vue3:
import { nextTick } from 'vue' nextTick(() =&gt; { // DOM 现在已经更新 }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06203f3a215c786681669fe7091ffd21/" rel="bookmark">
			Android 手游聚合SDK小知识(二) 聚合分包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 手游聚合SDK小知识(一)
Android 手游聚合SDK小知识(二) 聚合分包
更新： 在上一篇文章中，我们介绍了如何聚合SDK的基本原理，介绍了聚合SDK的接口设计，那么当CP接入了我们的聚合SDK，给了我们游戏apk包时，这时我们又当如何分发渠道包呢？
分发渠道包： 该操作方式都是在只有游戏apk包的情况下进行的
开始合包 1、apk反编译 apk反编译使用apktool这个工具，可以将apk文件反编译，apk命令如下
java -jar D:\apktool.jar d apk路径 -o 反编译输出目录的路径 将母包apk和SDK包反编译处理得到待合并资源。
2、SDK资源合并 2.1、合并assets目录 将SDK的assets目录下的资源复制到母包的assets目录下，注意文件名不要冲突，如果冲突请修改SDK的文件命名方式。
2.2、合并lib目录 将SDK的lib目录下的文件复制到母包的lib目录下，但是要注意，复制的时候要以母包的目录为准，举个例子，SDK的lib目录下有x86和x86_64两个目录，母包的lib目录只有x86_64一个目录，则合并的时候，以母包为准，只保留x86_64这一个目录。
2.3、合并res目录下的资源 res目录下一般包括以下几个目录：
layout：布局文件anim：存放动画定义文件color：存放自定义颜色文件menu：存放菜单自定义文件xml：存放配置文件drawable/mipmap：存放图片文件raw：存放不压缩文件values：存放主题样式，字符串等文件
注意：合并文件的时候，可能会出现文件名重复的问题，所以这就要求我们的SDK的文件名和母包的文件名不一致，建议SDK的文件命名的时候加个前缀. 以上目录除values外，其他目录的合并方式：
直接将SDK的文件复制到母包下就行，有同名的改一下SDK的命名方式。
values目录文件下除public.xml文件外的合并：
将SDK有，母包没有的目录直接复制过去，例如SDK有values-zh目录，母包没有这个目录，就将SDK整个目录复制到母包里。
如果SDK有，母包也有的目录，则合并目录中的文件内容，比如string.xml或color.xml等，将SDK对应文件的内容复制到母包中，如果内容命名方式相同，例如#3F51B5这样的name，母包和SDK都有，则想办法将SDK的name命名方式修改掉，如果是系统参数或修改不了，则保留母包的。
values目录文件下public.xml文件的合并：
一般来说，我们做SDK，不要使用R.id或R.layout等资源引用方式，而是使用getIdentifier()这种方式来动态获取资源ID。
如果母包和SDK都使用了getIdentifier()来获取资源ID，则把两个public.xml都删掉，或者保留母包与SDK任何一个的public.xml都行，因为这个时候没有使用到R资源，你都删掉或者保留任何一个都行。
但是有的时候会遇到没有使用”行规“， 动态获取资源id，而是使用R.id的方式，这种情况下有下面几种处理方式。
一、保留母包的public.xml，删掉SDK的public.xml。
二、保留SDK的public.xml，删掉母包的public.xml。
三、合并两个public.xml并重新赋值，并且遍历smali的R l a y o u t . s m a l i 或 R layout.smali或R layout.smali或Rcolor.smali等R文件，修改对应的值。
这三种方法，如果是母包没有用getIdentifier()来获取资源ID，则可以用1，3方法，如果是SDK没有用getIdentifier()来获取资源ID，则可以用2、3方法，如果是双方都没用getIdentifier()来获取资源ID，则只能使用3方法。因为我公司的游戏是自研游戏，母包是按照getIdentifier()来获取资源ID的，所以我直接用了2方法，后续我应该会出一篇文章讲一下怎么合并public.xml和R文件，大家也可以自己百度搜索一下，我发现也有人讲这个。
2.4、合并smali文件 合并smali文件要注意以下几点：
一、删除游戏母包中负责聚合SDK的文件，因为SDK复制进来后，防止没法覆盖掉旧的，同时存在两个聚合SDK文件，导致引用错误。
二、把SDK中的smali文件复制到游戏母包，直接覆盖原文件，注意是直接覆盖，有重复的不管他，直接覆盖。
注意，第二步时，有的时候会出现65535的错误，因为smali文件覆盖后，可能单个smali目录里的文件的方法数会超过65535,这个时候有两种处理方案。
一、扫描里面的方法数，如果超过65535，这种情况需要新建一个smali_calss2文件，如果smali_calss2还不够，就新建smali_calss3，直到每个smali_calss目录里的方法数都不超过65535。
二、复制SDK的smali文件时，直接在母包的下面新建smali_calss，比如母包有smali_calss和smali_calss2两个目录，则复制SDK的时候，直接新建smali_calss3开始一个个复制过去，因为母包的两个smali_calss目录没超方法数，复制的SDK的新建的smali_calss目录也没超，所以不用检查里面的方法数就可以完成smali合并，方便很多，就是同一个APK反复分发的时候，smali数会越来越多。用这个方法的话，建议使用同一个母包分发。
2.5、合并AndroidManifest.xml 把多个SDK AndroidManifest.xml文件的配置整合到一个AndroidManifest.xml中，需要注意是去掉重复的声明，比如：重复的权限声明、重复的meta-data声明等，并注意要修改启动的Activity。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06203f3a215c786681669fe7091ffd21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5fc33d18752064d66408a97920fdd9/" rel="bookmark">
			在结合mybatis-plus的SpringBoot项目中，访问url，出现异常: BindingException: Invalid bound statement (not found)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现异常：org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) MVC层都没有报错 很大可能就是根本找不到 .xml文件在哪里。
解决方式 在全局配置文件application.properties 中，配置.xml的位置
mybatis-plus.mapper-locations=classpath:/mapper/*.xml 如果是结合mybatis的SpringBoot项目可以配置下面代码：
mybatis.mapper-locations=classpath:/mapper/*.xml 之后就可以正常获取到.xml文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7b1afdd4666e85852ec588ed4d82f7/" rel="bookmark">
			将phantomjs制成docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个前的一篇文章中介绍了phantomjs+echarts生成图表图片的一种方式，但其部署复杂，制作为docker镜像运行就方便多了。文章参见：https://blog.csdn.net/u011943534/article/details/121524397
1、准备echarts 将上次文章中提到过下载的EchartsConvert 解压，并复制到一个安装docker的服务器。
下载地址：https://gitee.com/saintlee/echartsconvert
2、准备phantomjs 将上次文章中个体到过下载的phantomjs解压，并复制bin目录下的phantomjs文件到上一步和echarts相同的目录
下载地址：https://bitbucket.org/ariya/phantomjs/downloads/
注意下载linux版本的
3、编写dockerfile FROM debian:stable-slim RUN apt-get update RUN apt-get install -y apt-transport-https ca-certificates #mirror COPY sources.list /etc/apt/sources.list #phantomjs RUN apt-get update RUN apt-get install -y libfontconfig1 ENV OPENSSL_CONF /etc/ssl/ COPY phantomjs /usr/local/bin RUN chmod +x /usr/local/bin/phantomjs ADD echartsconvert-master /echartsconvert-master RUN apt-get install -y ttf-wqy-zenhei RUN apt-get install -y xfonts-intl-chinese wqy* RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime EXPOSE 7777 CMD ["/usr/local/bin/phantomjs", "/echartsconvert-master/echarts-convert.js", "-s", "-p", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7b1afdd4666e85852ec588ed4d82f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d7f15d305394700c543fcc4d485830/" rel="bookmark">
			【2024软件测试面试必会技能】Appium自动化(4)：Appium工作原理及Desired Capabilities配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Appium工作原理 Appium工作原理图如下：
脚本请求——&gt;4723端口appium server——&gt;解析参数给PC端4724端口——&gt;发送给设备4724端口——&gt;通过设备4724端口发给bootstrap.jar——&gt;Bootstrap.jar把命令发给uiautomator；
sonWireProtocol：
它是一种协议，遵循REST风格，以JSON方法进行传输，是一系列的键值对，遵循W3C WebDriver Spec设计风格；appium中的Json wire protocol继承自selenium的webdriver wire protocol，并进行了扩展，使得Json wire protocol能够控制不同的移动设备的行为。
bootstrap：
bootstrap在appium中是以jar包的形式存在的，它的功能是作为一个socket服务，把Appium sever发送的请求转化成uiautomator的命令来让uiautomator进行处理。
在创建session成功之前，appium就已将bootstrap.jar放入手机中，并开启设备上的基于appiumbootstrap的socket服务，绑定本机和boostrap通信的端口号4724用于和Android设备通讯，默认监听4724端口，等待client的连接。
Uiautomator：
UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试。它的初始版本发布在Android4.3(APIlevel18)及以上的android系统版本。
Selendroid：
Selendroid和UiAutomator类似，也是Google提供的一个安卓自动化测试软件，适用于Android系统的本地应用程序和移动web的UI混合测试。它主要应用在Android4.2(APIlevel17)及以下的android系统版本。
Instruments：
Instruments一个很灵活的、强大的工具，是性能分析、动态跟踪和分析OSX以及iOS代码的测试工具，appiumios封装了apple的Instruments框架，主要使用Instruments里的UIAutomation（Apple的自动化测试框架），然后在设备中注入入bootstrap.js进行行监听。
Desired Capabilities配置 Desired Capabilities携带了一些配置信息。从本质上讲，它是key-value形式的对象。可以理解成是java里的map，python里的字典，ruby里的hash以及js里的json对象。实际上Desired Capabilities在传输时就是json对象。
DesiredCapabilities最重要的作用是告诉appium server本次测试的上下文。
比如：
本次测试是启动浏览器还是启动移动设备？是启动andorid还是启动ios？启动android时，app的package是什么？启动android时，app的activity是什么？ appium server的这些疑问Desired Capabilities都必须给予解答，否则appium server就无法完成移动app或者是浏览器的启动。
Desired Capabilities常用键值对介绍：
automationName：使用哪种自动化引擎。appium（默认）还是Selendroid。
platformName：平台的名称，iOS,Android,FirefoxOS
platformVersion：移动设备的系统版本号，7.1,4.4
deviceName：设备名称，Android:可随意填写;IOS：instruments -s devices
udid：连接的物理设备的唯一设备标识adb devices可获取
app：本地绝对路径_或_远程httpURL所指向的一个安装包（.ipa,.apk,或.zip文件）。Appium将其安装到合适的设备上。如果指定了appPackage和appActivity参数，Android则不需要此参数了。该参数也与browserName不兼容。（一般和noSign属性一起使用）
browserName：测试的H5 web浏览器，如果是测app则忽略
newCommandTimeout:用于客户端在退出或者结束session之前，Appium等待客户端发送一条新命令所花费的时间（秒为单位）
noReset：在当前session前不重置app状态，默认值为false
fullReset：(iOS)删除所有的模拟器文件夹。(Android)要清除app里的数据，请将应用卸载才能达到重置应用的效果。在Android,在session完成之后也会将应用卸载掉。默认值为false
Desired Capabilities android特有键值对介绍：
appPackage：运行的Android应用的包名;如果是测试H5网页则忽略该属性
appActivity：Activity的名字是指从你的包中所要启动的Androidacticity。通常需要再前面添加‘.’；如果是测试H5网页则忽略该属性
unicodeKeyboard：使用Unicode输入法。默认值为false
resetKeyboard：在设定了unicodeKeyboard关键字的Unicode测试结束后，重置输入法到原有状态。如果单独使用，将会被忽略。默认值为false
noSign：跳过检查和对应用进行debug签名的步骤。仅适用于UiAutomator，不适用于selendroid。默认值为false；（一般和app属性一起使用）
最全的键值信息可参考：https://github.com/appium/appium/blob/master/docs/cn/writing-running-appium/caps.md
DesiredCapabilities使用实例：
1、定义一个Desired Capabilities配置的字典
原生app的Desired Capabilities配置：
from appium import webdriver # 1、定义一个DesiredCapabilities配置的字典 des = { 'automationName':'appium', 'platformName':'Android', # 平台的名称，iOS,Android,FirefoxOS 'platformVersion':'9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d7f15d305394700c543fcc4d485830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2dd6597ff0febd9195f3cf706a6b53/" rel="bookmark">
			【论文阅读|基于 YOLO 的红外小目标检测的逆向范例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 YOLO 的红外小目标检测的逆向范例 摘要1 引言2 相关工作2.1 逆向推理2.2 物体检测方法 3 方法3.1 总体架构3.2 逆向标准的可微分积分 4 实验4.1 数据集和指标4.2 实验环境4.4 OL-NFA 为少样本环境带来稳健性 5 结论 论文题目： A Contrario Paradigm for YOLO-based Infrared Small Target Detection（基于 YOLO 的红外小目标检测的逆向范例） 论文下载链接： https://arxiv.org/pdf/2402.02288.pdf
摘要 检测红外图像中的微小目标是计算机视觉领域的一项具有挑战性的任务，尤其是在将这些目标从嘈杂或纹理背景中区分出来时。与分割神经网络相比，传统的物体检测方法（如 YOLO）在检测微小物体时非常吃力，因此在检测小目标时性能较弱。为了在保持高检测率的同时减少误报，在 YOLO 检测器的训练中引入了反向决策标准。后者利用小目标的不可预测性，将它们与复杂背景区分开来。在 YOLOv7-tiny 中加入这一统计标准，缩小了红外小目标检测和物体检测网络中最先进的分割方法之间的性能差距。它还大大提高了 YOLO 对少样本环境的鲁棒性。
关键词： 小目标检测、逆向推理、YOLO、少样本检测
1 引言 在包括医疗或安全领域在内的各种应用中，准确检测红外（infrared, IR）图像中的小目标至关重要。红外小目标检测（Infrared small target detection, IRSTD）是计算机视觉领域的一项巨大挑战，其困难主要在于：(1) 目标的大小（面积低于 20 像素）；(2) 复杂且纹理丰富的背景，从而导致许多误报；(3) 学习条件，即从小型、多样化程度低且高度类不平衡的数据集中学习，因为与背景类像素相比，目标类像素的数量非常少。过去几十年来，深度学习方法的兴起在物体检测领域取得了令人瞩目的进步，这主要归功于它们能够从大量标注数据中学习，提取出非常适合最终任务的非线性特征。在 IRSTD 中，语义分割神经网络的应用最为广泛[1]。其中包括 ACM[2]、LSPM[3]和最近最先进的（SOTA）方法之一，即 DNANet[4]，它由多个嵌套的 UNets 和一个多尺度融合模块组成，能够分割不同大小的小物体。然而，依靠分割神经网络进行物体检测的一个主要问题是，在调整用于二值化分割图的阈值时，可能会出现物体破碎的情况。这会导致许多不希望出现的误报，并扭曲计数指标。Faster-RCNN [5] 或 YOLO [6] 等物体检测算法通过边界框回归明确定位物体，从而降低了这种风险。然而，这些算法往往难以检测到微小物体。很少有研究关注将此类检测器用于 IRSTD [7]，也没有与 SOTA IRSTD 方法进行严格比较。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc2dd6597ff0febd9195f3cf706a6b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47fdb5a4196d5b7a135da4637b3fc148/" rel="bookmark">
			uniapp 实现微信小程序右上角气泡分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp实现微信小程序右上角气泡分享，onShareAppMessage 方法 在uniapp API中已经存在，需要重写修改里面的值，不然不生效。
// // 1.发送给朋友 // const onShareAppMessage = (res) =&gt; { // return { // title: merchant_detail.data.name, // path: `/packageC/pages/xxx/xxx`, // imageUrl: '/app/logo.png', // } // } import {onShareAppMessage} from "@dcloudio/uni-app"; // 1.发送给朋友 onShareAppMessage(() =&gt; { return { title: "标题", } }) //2.分享到朋友圈 const onShareTimeline = (res) =&gt; { return { title: "标题", path: `/packageC/pages/xxx/xxx`, imageUrl: '/app/logo.png', } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac21e6ce8d7471c7cb56731b667b2949/" rel="bookmark">
			使用sass开发web-components组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：借助chokidar监听变化，将scss编译成css后插入
同时执行chokidar监听和webpack server
"start": "npm run watch:css &amp; webpack serve", "watch:css" : "node chokidarStyles.js", // chokidarStyles.js const fs = require('fs'); const path = require('path'); const chokidar = require('chokidar'); const sass = require('sass'); const autoprefixer = require('autoprefixer'); const postcss = require('postcss'); // 要监听的文件或目录路径 const filePath = './src/styles.scss'; const templatePath = './src/ComponentLoadingTemplate.ts'; // 监听文件或目录变化 const watcher = chokidar.watch(filePath); const changeCss = () =&gt; { // 编译 SCSS 文件 const scssFilePath = path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac21e6ce8d7471c7cb56731b667b2949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7957815faed069de4ad592bee5c8cd4/" rel="bookmark">
			emmc知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储知识
存储器Flash页、扇区、块的区别
uboot下确实是用真实的物理地址，但是mmc write使用的是block为单位的，一个block 512个byte
地址一般是以byte为单位的
所以用mmc write的时候，要转换成block单位
一般一个emmc可以分为user分区，boot0，boot1和rpmb，这是emmc固定的 ，固定有的，不过大小可以改变
然后咱们的分区，是在user分区的基础上分出来的，bootloader，bootimg system 等等。
busybox mount -t vfat /dev/block/mmcblk1p1 /storage/sdcard1
用那种文件系统跟设备里面的保存的第三个（或者第二这个忘了）的superblock有关系。
存储设备本身的superblock是那种系统组织文件的就是那种。
一般像给电脑识别的usb或者sd都是fat32
恩，而emmc一般用ext
nand一般也是ext4
当然有些分区像bootloader这些是不需要给系统访问的，所以就没有文件系统
dd if=/boot.img of=/dev/block/boot
这样可以替换，dd if=/u-boot.bin of=/dev/block/bootloader
system不一定可以哦。
system被mount住，而且是设为不可读写的情况。
其他的boot.img这些已经加载到内存中了，就可以
eMMC接口介绍
【MMC驱动开发】——EMMC协议速览
sd和emmc如何进行tuning
eMMC Sampling Tuning and linux mmc driver support
20230529_13:23:03:381:[ 6.043215] sdhci_am654_set_clock+0x60/0x34c 20230529_13:23:03:381:[ 6.043220] sdhci_set_ios+0x474/0x630 20230529_13:23:03:382:[ 6.068623] mmc_set_timing+0x24/0x30 20230529_13:23:03:382:[ 6.068625] mmc_select_hs400+0x98/0x208 20230529_13:23:03:382:[ 6.068628] mmc_init_card+0xcb0/0x1a10 20230529_13:23:03:382:[ 6.088746] mmc_attach_mmc+0xdc/0x180 20230529_13:23:03:382:[ 6.088748] mmc_rescan+0x288/0x398 20230529_13:23:03:382:[ 6.088752] process_one_work+0x1a0/0x328 20230529_13:23:03:382:[ 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7957815faed069de4ad592bee5c8cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21823dfb52c632bbb331688565714cb/" rel="bookmark">
			回调函数应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回调函数（Callback Function）是一种编程模式，其中一个函数（称为回调函数）作为参数传递给另一个函数，并在需要时被调用。这种模式在多种编程语言和框架中都广泛使用，特别是在异步编程和事件驱动编程中。
1 示例--排序（升序、降序）、过滤函数
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; // 回调函数类型定义，接受一个int参数并返回一个bool值 typedef bool (*FilterFunction)(int); // 一个函数，接受一个整数数组和一个回调函数 void FilterArray(const std::vector&lt;int&gt;&amp; array, FilterFunction filter) { std::vector&lt;int&gt; filtered_array; std::copy_if(array.begin(), array.end(), std::back_inserter(filtered_array), filter); // 打印过滤后的数组 for (int value : filtered_array) { std::cout &lt;&lt; value &lt;&lt; " "; } std::cout &lt;&lt; std::endl; } // 回调函数示例：只接受偶数 bool IsEven(int value) { return value % 2 == 0; } // 回调函数示例：只接受大于10的数 bool IsGreaterThanTen(int value) { return value &gt; 10; } int main() { std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 11, 12, 13, 14, 20}; // 使用IsEven作为回调函数过滤偶数 FilterArray(numbers, IsEven); // 使用IsGreaterThanTen作为回调函数过滤大于10的数 FilterArray(numbers, IsGreaterThanTen); return 0; } 打印输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e21823dfb52c632bbb331688565714cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a28d9efabfbe5680368bc7c83af236/" rel="bookmark">
			【docker错误解决系列】 ‘buildx‘ is not a docker command.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题环境解决办法尝试1：修改~/.docker /config.json尝试2：exporter DOCKER_CLI_EXPERIMENTAL=enabled尝试3：修改/etc/docker/daemon.json --&gt; Experimental成功开启尝试4：开启binfmt尝试5：安装docker-buildx-plugin --&gt; docker buildx 成功 问题 [root@ningan ~]# docker buildx docker: 'buildx' is not a docker command. See 'docker --help' 环境 [root@ningan ~]# uname -a Linux ningan 5.4.0-150-generic #167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux [root@ningan ~]# docker version Client: Version: 20.10.21 API version: 1.41 Go version: go1.18.1 Git commit: 20.10.21-0ubuntu1~18.04.3 Built: Thu Apr 27 05:50:21 2023 OS/Arch: linux/amd64 Context: default Experimental: true Server: Engine: Version: 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a28d9efabfbe5680368bc7c83af236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b901843630585062ffaef977bc184c0/" rel="bookmark">
			Regular Paper, Short Paper, Demo Paper 和Poster的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Regular Paper, Short Paper, Demo Paper和Poster是常见的四种会议论文的类别。期刊并没有Short Paper, Demo Paper, 或者Poster。 总的来说，并没有一种规则来界定这四种论文类别。但是，大致上，Regular Paper或者Research Paper属于一种较完整的研究型论文。长度一般为8-12页。有时，较短一点的Regular Paper，可能只有6页。一篇Regular Paper需要包含所述科研题目相关的一切内容，例如：研究背景，新方法的特点以及效果等。 Short Paper属于一种较为简短的论文。因为篇幅原因，作者无法将所有的内容都涵盖在论文中，所以，在写作时，作者需要有所取舍，将最重要，最精华的内容 放入短论文中。方法部分可以直接陈述结果，简化推导过程。实验部分可以直接表达最重要的结果。如果实在是篇幅太短，可将部分内容放在Technical Report中， 在短论文中引用该Technical Report。 Technical Report并不是一种正式发表的论文。Technical Report的格式和内容完全由作者决定。Technical Report可以仅仅包含一个问题的定义，也可以仅仅包含一个 方法的介绍，或者仅仅包含在论文中放不下的内容。Technical Report也没有正式发表的网络地址。作者可以将其放在学校的网站上，或者任意一个读者和审稿人能访问的地址上。 Demo Paper属于一种描述和表达一个系统的设计、实现、以及使用方式等内容。Demo Paper更偏向于应用，展示应用的效果。有时，一项科研成果可以转化为两篇论文。 在Regular Paper中着重阐述科研成果的理论性和创新性，而在Demo Paper中侧重于描述其应用性。 Poster也属于一种描述和表达一项初步的科研成果或者一个系统的初步设计与实现。但是，区别在于Poster更加浓缩了这项成果或者系统的精华。Poster还可用于汇报项目的进展情况。 所以，Poster所展示的内容是初步的，还处于预研阶段的。 精选会议推荐：
【ACM出版 | Ei检索】第三届网络安全、人工智能与数字经济国际学术会议（CSAIDE 2024）
会议时间：2024年3月8-10日
会议地点：中国 · 济南
会议链接：Click
征稿主题：主动防御系统、自适应防御系统、安全系统分析，基准、应用密码学、复杂系统安全、数据库和系统安全、数据保护、数据/系统完整性、人工智能算法、自然语言处理、计算机视觉与图像理解、信号和图像处理、语音与自然语言处理、计算学习理论、信息检索与融合、混合智能系统、数字经济等
【SPIE独立出版】2024年第四届数字信号与计算机通信国际学术会议（DSCC 2024）
会议时间：2024年04月12-14日
会议地点：中国 · 广州
会议链接：Click
征稿主题：通信信号传输、联合信源信道编码与迭代译码算法、MIMO通信和空时或空频编码、分布式编码和处理、数字通信技术、卫星通信技术、无线网络通信技术、移动通信、移动Ad-hoc网络、计算机网络通信、传播建模理论与实践、5G和6G通信等
【IEEE独立出版】第六届下一代数据驱动网络国际学术会议 (NGDN 2024)
2024年4月26-28日 | 中国沈阳
会议链接：Click
征稿主题：数据驱动的移动计算及无线通讯、基于数据驱动的网络信任、安全和隐私、数码双网、空地网络、基于大数据的5G网络、物联网（IoT）及大数据、用户大数据分析（用户群/用户行为/用户轨迹等）、大数据助力电信运营（客户维护/增值服务等）
[yuji 【预计】IEEE出版】第五届信息科学与并行、分布式处理国际学术会议（ISPDS 2024）
时间地点：2024年5月31-6月2日 | 中国·广州
会议主页：Click
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b901843630585062ffaef977bc184c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1e055e92f868587ebcfd511c6f6413/" rel="bookmark">
			带参数的存储过程 及 SQL窗口执行procedure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 带参数的存储过程
create or replace procedure p1(CTIME IN date) is begin *** exception *** end; SQL窗口执行多个存储过程：
begin p1(to_date('20240219','YYYYMMDD')); p2(to_date('20240220','YYYYMMDD')); end; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/63/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>