<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c09582900de32cbbd0684cef33fc34/" rel="bookmark">
			搭建Flutter Web开发调试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Setting up the Framework/Engine development environment 背景搭建 framework 开发环境修改调试 framework 源码运行 framework 测试用例同步更新 framework 源码 搭建 engine 开发环境准备 depot_tools部署 engine 源码编译 engine 源码修改调试 engine 源码指定 --local-engine修改源码调试示例 运行 engine 测试用例同步更新 engine 源码 协同联调 Framework 和 Engine 背景 关于参与 Flutter 项目的共建，从 framework 到 engine，本文提供了环境搭建到调试的主要流程说明，可以快速帮助你搭建起来。
由于侧重讲述 Flutter web 平台的建设，可以通过本文提供的官方文档链接获得其它平台更多指引。
搭建 framework 开发环境 参考官方文档：Setting up the Framework development environment。
需要具备这些条件搭建 framework 开发环境:
Linux，macOS 或 Windows。
git（代码版本管理）。
IDE：Android Studio、vscode 等主流IDE可安装插件支持 flutter/Dart 代码高亮。
Python（ 一些工具需要使用）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c09582900de32cbbd0684cef33fc34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5bdc0dfa81c4abfb45d4044ec467a8/" rel="bookmark">
			softmax原理性质解析并python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Softmax原理 Softmax函数用于将分类结果归一化，形成一个概率分布。作用类似于二分类中的Sigmoid函数。
对于一个k维向量z，我们想把这个结果转换为一个k个类别的概率分布p(z)。softmax可以用于实现上述结果，具体计算公式为：
对于k维向量z来说，其中zi∈Rzi∈R，我们使用指数函数变换可以将元素的取值范围变换到(0,+∞)(0,+∞),之后我们再所有元素求和将结果缩放到[0,1],形成概率分布。
常见的其他归一化方法，如max-min、z-score方法并不能保证各个元素为正，且和为1。
Softmax性质 输入向量x加上一个常数c后求softmax结算结果不变，即:
我们使用softmax(x)的第i个元素的计算来进行证明：
函数实现 由于指数函数的放大作用过于明显，如果直接使用softmax计算公式进行函数实现，容易导致数据溢出(上溢)。所以我们在函数实现时利用其性质：先对输入数据进行处理，之后再利用计算公式计算。具体使得实现步骤为：
查找每个向量x的最大值c；每个向量减去其最大值c, 得到向量y = x-c;利用公式进行计算 s o f t m a x ( x ) = s o f t m a x ( x − c ) = s o f t m a x ( y ) softmax(x) = softmax(x-c) = softmax(y) softmax(x)=softmax(x−c)=softmax(y) import numpy as np def softmax(x, axim=1): ''' x: m*n m个样本，n个分类输出 return s：m*n ''' row_max = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5bdc0dfa81c4abfb45d4044ec467a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e7a55c9bc90d809abdc13752e433a8/" rel="bookmark">
			键盘中断输入测试程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天测试需要写一个接收键盘键的中断输入就停止，再按就继续，亲测有效，程序如下：
#include &lt;stdio.h&gt;
#include “conio.h”
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
int kbhit(void)
{
struct termios oldt, newt;
int ch;
int oldf;
tcgetattr(STDIN_FILENO, &amp;oldt);
newt = oldt;
newt.c_lflag &amp;= ~(ICANON | ECHO);
tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt);
oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);
ch = getchar();
tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt);
fcntl(STDIN_FILENO, F_SETFL, oldf);
if(ch != EOF)
{
ungetc(ch, stdin);
return 1;
}
return 0;
}
int main()
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e7a55c9bc90d809abdc13752e433a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a0a748b452040f5992420e353e5935/" rel="bookmark">
			某CCF C会议对国内和国外作者实行两套标准, 引27%&#43;中稿者发声!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击文末公众号卡片，不错过计算机会议投稿信息
本文主要反映轻松参会交流群内UIC'22(CCF C类) 的81+位国内中稿作者的诉求（占UIC'22中稿数的27%+）。目前群内作者们的诉求为，希望国内作者可选择线上参会。因为线下参会有困难（具体困难见正文），如疫情导致的封校和学生返乡（无法报销）等情况。
目前情况是，该会议在国内举办，中稿short paper的国内作者收到的录用通知邮件中明确表示是presentation virtually。然而在注册页中，要求的是所有国内作者只能选择线下参会，而所有国外作者只能选择线上参会。
以下为正文：
UIC(Ubiquitous Intelligence and Computing) 是CCF人机交互与普适计算目录下推荐的C类会议。UIC2022目前已经公布录用结果，并将于2023年12月15-18日在中国海口举办。该会议的注册在2022年11月17日开放，在12月15日之前都可以注册，截止至2022年12月8日23:59，注册页面截图如下：
注册链接：
http://www.ieee-smart-world.org/2022/uic/register-instruction.htm
可以看到，链接中显示，国内作者仅可选择Full Physical注册，而国外作者仅可选择Full Virtual注册。国内与国外作者的参会要求是不同的。
之前，国内作者收到的论文接收通知邮件中，接收为regular paper的作者的邮件中未提及是否必须线下参会，接收为short paper的作者的邮件中明确提及做presentation virtually。
regular paper作者收到的邮件截图：
short paper作者收到的邮件截图：
可以看到，接收为short paper的国内作者，其所收到的录用邮件中的参会要求，和注册时只可选择physical registration的参会要求是有差异的。
官网上在paper submission页面上的presentation和registration要求如下图所示（截止至2022年12月8日）：
其中未提到要求国内作者必须强制线下参会。官网链接：
http://www.ieee-smart-world.org/2022/uic/index.php
作为对比，要求每篇论文起码一位作者强制线下参会的知名CCF B类会议ICASSP'23在截稿前在官网放出了强制线下参会的要求，截止至2022年12月8日，其官网的paper submission页面截图如下：
在轻松参会UIC'22交流群中，大量中稿UIC的国内作者表示自己由于各种原因有困难无法线下参会，且由于之前short paper的作者邮件中说的是presentation virtually，所以并未做线下参会的相关准备。
UIC2022共接收论文294篇（170short+124regular），轻松参会UIC'22群内共187人，关于线下参会困难的投票结果如下图所示，88人参与投票，其中81位作者表示线下参会有困难，约占总中稿数的27.6%：
群内作者们反映的无法线下参会的困难包括（但不限于）以下内容：
因有疫情情况，一些学校封控中或一些学生个人隔离中；
一些学校已要求学生返乡，从家里出发去会议现场难以形成学校财务报销要求的闭环，大量学生靠自身承担前往会议现场的诸多费用有较大压力；
由于short paper作者邮件中写的是virtual，部分作者未做线下参会的准备，导致线下参会与重要考试、中期答辩、毕业论文事项时间有冲突。
目前群内作者们的诉求为，希望国内作者可选择线上参会，毕竟疫情导致的封校和学生返乡（无法报销）是普遍情况。
本文首发于【计算机会议投稿】公众号，作者尼谟为中科院自动化所工程师。 该公众号为CCF所有收录会议设立投稿交流群，后台回复会议名即可进群，如“UIC”，群内活跃度高，进群讨论不错过会议信息。 公众号文章会发布近期截稿会议、转投会议推荐、录用率趋势、录用分数分析等重要信息，欢迎各位计算机科研人关注本号或与尼谟交流。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5debd3b8b20cbb92630f377100f1290f/" rel="bookmark">
			uniapp 表格组件，冻结首行首列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 表格组件，冻结首行首列 模板jscss 部分样式需要放到 `App.vue` 里面才能生效属性与方法属性列定义按钮 方法行样式选择事件翻页事件 使用组件 对 uni-table 的封装
优点：自带样式，自带多选等功能
缺点：
1. 不能对 checkbox 的 value 进行赋值，选出来的选中行的 index
2. checkbox 不能设置默认禁用
3. checkbox 不能获取到当前行数据，只能在改变选择状态时获取全部选中行
模板 &lt;template&gt; &lt;!-- style:设置表格高度 表格内容区高度为 height-60，60是分页组件的高度--&gt; &lt;view class="x-table-box" :style="{height:height}"&gt; &lt;!-- 表格 --&gt; &lt;uni-table @selection-change="chkchange" ref="table" :type="chk?'selection':''" class="x-table" stripe emptyText="暂无更多数据"&gt; &lt;!-- 表头 --&gt; &lt;uni-tr class="thead"&gt; &lt;uni-th v-if="cols" v-for="x,i in Object.keys(cols)" :width="cols[x].width||120" :class="{left0:!chk&amp;&amp;i==0,left5:chk&amp;&amp;i==0}" &gt;{{cols[x].title || x}}&lt;/uni-th&gt; &lt;!-- 按钮列 --&gt; &lt;uni-th v-if="btns" :width="btnswidth"&gt;操作&lt;/uni-th&gt; &lt;/uni-tr&gt; &lt;!-- 内容 --&gt; &lt;uni-tr v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5debd3b8b20cbb92630f377100f1290f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d872880265e63c434da4ff858dfd029/" rel="bookmark">
			CMMI2.0配置管理工作及访谈学习笔记（续）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置管理岗位职责 范围：组织级和项目级配置管理管理对象为过程和产品，产品为识别出的配置项建立配置库：为项目建立开发库（管理库）、基线库，建立配置库结构并分配权限（命名规范）基线管理，在每个阶段结束的时候，按配置管理计划建立基线库，以及变更基线版本管理，使用配置工具git进行版本管理，以及文档修订记录配置库备份，收权限编制配置管理计划，依据软件项目过程定义、项目计划、配置管理规程、过程资产库编制配置管理计划配置审计，包括功能设计和物理审计记录CM活动，撰写配置管理周期性工作报告为项目组提供SCM 理论和相关工具的培训，并提供技术支持 2. 基于CMMI配置管理体系结构 在CMMI2.0中对配置管理又有新的诠释和变化，例如：去掉了配置状态记录，重点强调了配置控制的方法，将配置控制明确为版本控制和变更控制。再如：对基线的阐述不仅仅有软件基线，2.0也新增了硬件基线，这给软硬件一体项目实施的组织提供了理论基础。
如何验证您正在使用和遵循这些流程？
我可以阅读，配置管理规则，命名规程，配置管理计划等规范，同时，QA会对我的配置管理工作进行审计，EPG和项目经理对我的工作检查。
如何评价对于过程的遵循度和过程的有效性？
QA会从过程和产品两个方面对我的工作进行检查，一般按项目阶段及配置管理计划进行检查；
EPG评估过程的有效性。
3. 配置项分级别、分类管理及标识： 3.1. 配置项分级别 按管理的严格程度，配置项一般分2个等级：
（1）基线配置项
所有设计文档和源程序等【重要】基线配置项向开发人员开放读取和权限 （2）非基线配置项
项目各类计划和报告等非基线配置项向PM、CCB及相关人员开放 另外参考，按管理的严格程度，配置项一般分3个等级：
（1）纳入基线管理的配置项
纳入基线管理的配置项是指变化时要走严格变更手续的配置项，需要做变更申请，要审批。审批一般分2种严格程度：
i) 项目经理或分CCB审批就可以，一般是局部的小的变更。
ii）变更控制委员会（CCB）审批
纳入基线前，一般要经过评审或测试（称为验证）和质量保证。
（2）没有纳入基线但是也不能随意变更的配置项，一般称为受控项
这类配置项不需要变更申请，但是要经过配置管理员或项目经理的允许才可以变更。
基线项与受控项写的权限要唯一，一般是CM或PM有唯一的写权限。
（3）非受控项
对变更不做控制。
3.2. 配置项分类 凡是纳入配置管理范畴的工作成果统称为配置项，配置项主要有两大类：
一类是属于产品的组成部分，例如需求文档、设计文档、源代码、测试用例等；另一类是在管理过程中产生的文档，例如各种计划、报告。 3.3. 配置项标识 配置项标识是描述在项目软件管理过程的配置管理活动中如何对文件夹、文件名进行命名以及识别和标识配置项。
例如：配置项命名规范
配置项：公司简称—项目简称—文件名—编号基线：项目简称——基线名—编号 4. 项目实践 4.1. 配置管理计划 职责定义，包括配置管理员、QA、项目经理、CCB组长、CCB成员。
配置库为gitlab
配置管理过程：
配置库计划，包括权限表、库目录结构基线计划，包括基线名称、配置项、计划时间配置审计计划，包括审计时间、审计内容备份与恢复计划 状态报告，确定所有与配置管理相关的记录、生成频率，编写人及接收人。
配置管理计划维护，当需求或项目计划变更时，由配置管理员维护配置管理计划，并提交项目经理批准。
4.2. 基线及基线变更 序号基线名称版本号1需求基线V1.01.1需求基线V1.12设计基线V1.03测试基线V1.03.1测试基线V1.14发布基线V1.0 如何重新生成基线？
4.3. 配置审计 CM进行功能审计和物理审计,主要是在基线建立和基线变更时进行审计。
物理配置审计是用以验证所构建的配置项符合技术⽂档中对其的定义和描述，内容主要看配置项是否按计划正确入库、申请与发布是否一致，以及发布位置、版本、命名等基本信息是否正确。功能审计：主要是检查文件内容是否符合需求，符合模板。
4.4. 变更申请 变更申请由（需求、发布）申请变更和基线变更申请两部组成。
首先，是发起修改申请，从配置库签出文档和源代码；
其次，是发起配置项入库变更申请，从开发库签入到基线库。
例如，申请需求变更时，如何管理文档和源代码的变更？
1.需求基线检出：依据审批通过的需求变更申请，我先把相关文档从基线签出到开发库中，再由项目经理基于签出的文档组织修改变更；
2.需求基线变更CCB审批：需求变更需要重新生成需求基线，对于需要纳入需求的基线的文档，需经过评审，由需求开发者向CCB提出需求基线变更申请，CCB审批通过；
3. 需求产品重建基线：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d872880265e63c434da4ff858dfd029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a45a7fde85b23487c0a69b30367ddb/" rel="bookmark">
			扩散模型的源码学习diffusion_model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.diffusion_model有几个主要的部分，
（1）Unet，主干网络。
（2）GaussianDiffusion，也就是主要的训练策略。
2.
生成一个测试用的tensor来进行实验。 3.进入到高斯模型的内部，发现他的forward并不是特别复杂，
他会先生成一个随机数t，然后再对img做一定的处理，然后再利用p_loss做一个loss。
可以看到，难点应该就是p_loss和对图片的这个处理上。
4.可以看到，生成了一个t，是随机的0，1不知道在干啥。 5.然后把img输入到了这个normalize这里面，注意这个img是（8，3，128，128）的尺寸的。 他这个normalize_neg_one_to_one,只有一行，就返回了img，我们接下来试一下，这个操作会产生什么样的变化，因为他变化一下就输入到了p_losses里面，可以看到在p_losses之前的操作都是特别简单的，这说明整个需要操作的大部分应该都在p_losses里面。
乘2，减1，就是做了简单的变化。
6.然后就开始输入进p_losses了，这个输入的img是（8，3，128，128）维度的。
然后t是一个8的tensor，有8个随机的0，1数。
7.进入到p_losses里面，
发现，这个loss所需要的东西，一个是x_start,一个是t，也就是随机生成的一个tensor，和一个随机数的列表。
注意这个x_start是（8，3，128，128）这个维度的。
t是8个随机数tensor。
8.然后会利用default这个生成噪声。
也就是说这个default所使用的是提供的这个rand。
9.利用这个生成噪声noise，这个维度是（8，3，128，128）的。
10.x_start也是（8，3，128，128）维度的。
11.然后到了q_sample这里，
12.看一下这个extract 是干什么的，他需要传入三个值，这些都是一些基本的属性，并没有传入x_start本身，所以，他们是和x本身的值无关的，而是一个随着时间变化的东西。
它里面的tensor是这样的。
13.
14.
进行两个extract后就到了Unet里面。 15.正常的做loss，然后到了下面这个reduce这里，看看这个reduce是干啥的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26768aac3bd22eaa2c1a18fb2fa65727/" rel="bookmark">
			Chat GPT原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ChatGPT一经发布就在科技圈火得不行，这两天也是被传得神乎其神，听说它写得了代码、改得了 Bug，小说、段子统统不再话下！那他到底是怎么训练成现在这样的呢？本文介绍李宏毅老师的分析。
那么接下来我们就来介绍Chat GPT是怎样练成的！ 1.找寻资料参考： 李老师在翻看OpenAI的博客发现，其目前并没有发表关于ChatGPT的论文。但是！在OpenAI官方博客介绍中，我们可以发现CharGPT有一个兄弟，InstructGPT，因此他决定依靠InstructGPT去寻找一些ChatGPT的训练逻辑。
当我们看到ChatGPT与InstructGPT的对比时，更加坚定的确定通过InstructGPT是可以找到ChatGPT模型的蛛丝马迹的。如下，上面为ChartGPT的训练流程下面为InstructGPT的流程图。可以说像的7788了，比较面明显的区别其实只有GPT的版本不同而已，前者是GPT3.5，后者是GPT3。所以李老师决定直接分析InstructGPT来推测Chat GPT是怎样练成的！
2.正式开始介绍Chat GPT的学习四阶段： 2.1 学习文字接龙 学习文字接龙，其实就是依据目前已有的信息，去推测下一个可能出现的字，以此类推。与我们在学习机器学习中的文字翻译Transformer架构很相似。
正如下面的例子所演示的，当我们有目前有：“你好”这一个不完整的句子的时候，程序可以基于在互联网上学习到的知识去预测下一个字，有可能是 “美” 这种学习的好处是，我们并不需要人工标注出机器需要训练的内容，只需要把他放到互联网上，看到文字就自我学习文字接龙即可。
但是，坏处也显而易见了，对于一个不完整的句子，我们后面的词可以是很多种多样的，比如说在 “你好” 后面，我们可以接上 “吗” 、 “高”、“美” 等，所以GPT返回的其实是一个概率分布，也就是说每次回答的内容其实都是随机的。这次说 “你好吗”，下次可能就说 “你好美了” 。
但是单单依靠文字接龙，其实GPT就已经可以回答问题了。比如下面的例子，我们问出“台湾最高的山是哪座？” 当GPT在网上看过这么多资料，它通过文字接龙的形式回答，可能可以直接回答出玉山，也可能给你出一道选择题（如果他读过的资料是这么连接起来的），也可能反问你 “谁来告诉我呀？”
2.2 人类老师引导文字接龙方向 经过了文字接龙，我们会发现GPT虽然能回答我们的问题，但是并不一定能回答出我们想要的答案。说白了就是人工来筛选哪些是我们需要的答案（还是逃离不了有多人工就有多智能呐！）
2.3 模仿人类老师的喜好 人类希望获得的答案就会被赋予更高的分数 2.4 使用增强向模拟老师学习 就是我们将每次GPT得到的答案都丢给TeacherModel来评判，如果是人类希望的答案就给高分，如果不是则给低分，这个模式被称为增强式学习种的“Reward”模块 3. 当然，ChatGPT目前并不是完美的... 目前ChatGPT模型已经很难再被找到错误了，但是根据上面的分析，我们只需要问出一些没有人问过的内容，他就回答不出来了。比如说：我问 “numbers”是由几个字母组成的，他会回答八个，这是八个吗？？？这明明就是七个！！！
4.总结 李宏毅老师认为本流程是GPT的社会化过程，从一开始的想说什么就说什么，一直到后面的人类引导他说出期望的答案。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb518db48176052dfa95e1ac12f28a6/" rel="bookmark">
			【大数据入门核心技术-Hadoop】（六）Hadoop3.2.1高可用集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Hadoop部署的三种方式
1、Standalone mode（独立模式）
2、Pseudo-Distributed mode（伪分布式模式）
3、Cluster mode（集群模式）
二、准备工作
1、先完成zk高可用搭建
2、/etc/hosts增加内容
3、各台服务器分别创建目录
4、关闭防火墙和禁用swap交换分区
5、三台机器间免密
6、安装jdk
7、下载好hadoop安装包
三、高可用配置
1、配置core-site.xml
2、配置hdfs-site.xml
3、配置yarn-site.xml文件
4、配置mapred-site.xml
5、配置workers
6、修改配置hadoop-env.sh
四、分发文件
五、启动服务
六、查看服务
七、常见问题解决
1、高可用下提示Operation category READ is not supported in state standby
一、Hadoop部署的三种方式 1、Standalone mode（独立模式） 独立模式又称为单机模式，仅1个机器运行1个java进程，主要用于调试。
2、Pseudo-Distributed mode（伪分布式模式） 伪分布模式也是在1个机器上运行HDFS的NameNode和DataNode、YARN的 ResourceManger和NodeManager，但分别启动单独的java进程，主要用于调试。
3、Cluster mode（集群模式） 单Namenode节点模式-高可用HA模式
集群模式主要用于生产环境部署。会使用N台主机组成一个Hadoop集群。这种部署模式下，主节点和从节点会分开部署在不同的机器上。
本教程主要安装 多Namenode 节点 高可用集群模式
二、准备工作 1、先完成zk高可用搭建 【大数据入门核心技术-Zookeeper】（五）ZooKeeper集群搭建
2、/etc/hosts增加内容 172.30.1.56 hadoop001
172.30.1.57 hadoop001
172.30.1.58 hadoop001
3、各台服务器分别创建目录 mkdir -p /data/bigdata/hadoop/tmp
mkdir -p /data/bigdata/hadoop/var
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb518db48176052dfa95e1ac12f28a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ed19ad87a8d67db81a08d0c7fa0338/" rel="bookmark">
			《软件工程》复习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程》复习题
PDF 21页：点击下载 其余见PDF文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e18d9beb59d664d5aa3eeabb9c5c33f/" rel="bookmark">
			解决Dev-C&#43;&#43;中使用fscanf函数引入中文乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言使用fscanf函数的时候，引入中文可能出现乱码的情况，本篇文章用来解释问题产生的原因并提供解决办法。
乱码问题 上图是在电脑自带记事本中打开这个演示文件所呈现出来的效果，为了使问题暴露的更加直接，可以将这个文件直接拖入Dev-C++。
上图是显示的结果，可以看到乱码了，这时候其实能够想到一些东西，乱码是文件本身和Dev-C++之前产生了不兼容。
解决办法 先搞清乱码产生的原因，是因为Dev-C++软件对中文编码模式要求是ANSI的，而咱们平常使用的编码格式都是UTF-8的，所以解决办法也很简单，就是将文件的编码模式调为ANSI。
在记事本中打开文件，点击左上文件后，点击另存，将编码模式改为ANSI，点击保存。 再在Dev-C++中打开就能正常的显示了。
心得体会 这个问题用了三个小时，其中大部分时间都在找问题发生在哪一部分，解决问题大概用了半个小时，有时候感觉解决不了的问题，其实它可能根本不是你要解决的问题，正确准确的找到问题很关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9861badfbe9153aef3fe91d310723e/" rel="bookmark">
			vs 2019输出中文乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://t.csdn.cn/YDG6B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c82069a043770a484da78926c9c568/" rel="bookmark">
			element-ui el-input 类型为number时，输入中文后光标上移问题，并且去掉上下箭头，兼容火狐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置 el-input 的 type='number'后，输入框后面会出现上下箭头 解决办法：修改样式
/** * 解决el-input设置类型为number时，去掉输入框后面上下箭头 * */ input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none margin: 0 } 兼容火狐
.el-input__inner[type='number'] { -moz-appearance: textfield } 设置 el-input 的 type='number'后，只能输入数字，输入中文后会自动清空，但是会出现一个问题：光标会上移。 解决方法：修改样式 /** * 解决el-input设置类型为number时，中文输入法光标上移问题 **/ .el-input__inner{ line-height: 1px !important; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ff399348078f26dfcb4b283dc1944f/" rel="bookmark">
			【python学习】pickle文件和csv文件读取速度、内存大小对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas读取文件的效率-CSV VS Pickle - 知乎
利用Python进行数据分析 第6章 数据加载、存储与文件格式（2） - ElonJiang - 博客园
本文介绍pickle文件(.pkl)的读取方式，推荐pandas方式，支持读取的文件类型多、更方便。针对.pkl文件、.csv文件以及转换为category类型保存的.pkl文件，对比pandas对前面这三种文件的文件大小、读取速度、占内存大小等指标。
目录
一、pickle文件读取
1. 使用pickle库
2. 使用pandas（推荐）
二、使用pandas读取文件（.pkl、.csv）
三、结论
1. 文件大小
2. 文件读取速度
3. 占用内存大小
一、pickle文件读取 读取pickle存储数据有两种方式：
1. 使用pickle库 import pickle with open('F:\\xloaddata','rb') as f: data = pickle.load(f) 2. 使用pandas（推荐） import pandas as pd pd = pd.read_pickle('F:\\xloaddata') print(pd) 通过pickle直接读取被pickle化的数据，或使用更为方便的pandas.read_pickle。
Ps：pickle仅建议用于短期存储格式。因其很难保证该格式是永远稳定的。
实现数据的高效二进制格式存储最简单的办法之一，是使用Python内置的pickle序列化。
二、使用pandas读取文件（.pkl、.csv） 使用pandas读取.pkl文件、.csv文件以及转换为category类型的文件，并对比这三种类型文件的文件大小、读取速度、占内存大小等指标。Pandas读取文件的效率-CSV VS Pickle - 知乎
三、结论 1. 文件大小 转换后的文件占用磁盘空间最小，比原文件小4倍，对于保存大量数据非常有用。
2. 文件读取速度 转换后的读取速度比普通csv文件的读取速度快42倍。
3. 占用内存大小 转换后占用内存比转换前小30倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ff399348078f26dfcb4b283dc1944f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1462c8ff2150adf606166be325c916/" rel="bookmark">
			基于JavaWeb&#43;JSP的新闻中心管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、需求描述
二、页面设计
三、源码
一、需求描述 新闻中心管理系统主要是为了实现商务网站动态新闻实时显示的系统。一个典型的新闻中心管理系统一般都会提供新闻标题分类显示、新闻详细内容显示等功能。同时也要为新闻中心后台管理的管理员提供对应的新闻信息维护及管理的功能，包括添加新的新闻、编辑修改新闻、删除新闻等功能。
根据企业商务新闻的基本要求，本系统需要完成如下的主要任务：
（1）新闻标题信息分类显示：在进入新闻中心主页时，应该能够根据数据库中存放的信息分类显示最新的新闻标题。例如可以显示所有最新的标题信息。每个新闻标题都应该提供对应的超链接，单击后，就可以跳转到有关该新闻详细内容的页面上，以便用户对这条新闻有更详细的了解。
（2）新闻详细内容及相关新闻列表显示：当单击某个新闻标题后，可以查看该新闻的详细内容。同时提供与该新闻相关的新闻标题信息的显示，以便于查询与该新闻相关的其他信息（扩展）。
（3）新闻中心后台管理功能：新闻中心的管理员可以根据企业的服务需要随时向数据库中添加最新的新闻标题及相关内容。还可以删除不再需要的新闻标题及内容，以及对原有新闻做必要的修改。
二、页面设计 该项目是用JavaWeb技术、eclipse软件制作的，有2个数据库表，分别是管理员表和新闻表。以下展示部分页面功能。
首页
登录页面
新闻中心文件列表
新闻搜索
新闻中心管理后台
编辑新闻页面 添加新闻页面
三、源码 源码https://download.csdn.net/download/WHT869706733/85555130?spm=1001.2014.3001.5503
注：如果导入进去报错，新建下项目就能运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b81fea067441888a8f95ca9f9fe5c74/" rel="bookmark">
			卷积、自相关函数、功率谱密度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、自相关函数和卷积2、自相关函数的傅里叶变换 最近我在思考为什么： 为什么随机过程的自相关函数和其功率谱密度是一对傅里叶变换？ 1、自相关函数和卷积 这俩跟孪生兄弟似的，经常一起出现，我们先来看看自相关函数和卷积的定义（谁能教我一下，怎么去除图片里的水印）：
对比一下就会发现：两个公式及其相似。只要把x2换成x1，+τ换成-τ即可。那么自相关函数就变成了x1(t) *x1(-t)
暂停一下，直观的分析一下两者的关系。
卷积：翻转、平移、乘积
自相关：平移、乘积
发现了吗？两者只差一个翻转（沿时间轴的折叠）。——真是一个惊人的巧合。
说到自相关函数，这里推荐一篇极好的文章自相关函数的理解，里面对自相关函数概念的引出做了很好的诠释.
在这里我简要叙述结论：
1、自相关函数能够表示随机过程样本函数变化的剧烈程度。
2、更重要的，在对随机过程的研究，发现很多统计特性量都与自相关函数有关，只要通过实验方法能够测试得到随机过程的自相关函数，再结合期望、方差就可以进一步推导得到其他统计量。比如：自相关函数的傅里叶变换就是功率谱密度。
2、自相关函数的傅里叶变换 既然自相关函数和卷积存在这样的关系，那我们对x1(t) *x1(-t)做傅里叶变换：
到这里，进入第二个重要的节点：
如果直接对自相关函数做傅里叶变换呢？
同（3）式完全一致。因为两者在时域上完全一样，因此进行傅里叶变换后，也肯定是一样的。
那么为什么X(-jω)∙X(jω)就是功率谱呢?
如果x(t)是实信号，X(jω)=R(ω)+jX(ω)，那么有X(jω)的实部是偶函数，虚部是奇函数
所以，X(-jω)=R(-ω)+jX(-ω)=R(ω)-jX(ω)
∴X(jω)X(-jω)=|R(ω) |2+|X(ω)|2=|X(jω) |2
这不就和功率谱联系起来了吗!!
可是如果x(t)不是实信号呢？难道自相关函数的傅里叶变换就不是功率谱密度了？找遍了所有的教科书，没有一本书加了实信号这个限定条件。
那么问题出现在哪里呢？
——出在最最开始的时候，我对自相关函数的定义，只有实信号才是上述定义。
而更广义的定义是：
所以，自相关函数←→功率谱密度 是一对傅里叶变换对
！！！没有任何限定条件！！！
那么问题来了，为什么在相关函数的定义中，出现了共轭运算呢？类似的还有——内积。
我认为：所有需要引入共轭运算的，一定都是与能量相关的量（不一定正确哈）
好了，我们继续聊相关函数
其实，函数(信号)的相关运算就是：引入时移因子τ的内积。（把这句话读三遍）函数的内积不考虑时间轴对的准不准的问题，换句话说函数（信号）的内积是相关函数在某点的取值。
之前说过，几何里的内积就是投影，函数里的相关就是以一个函数为基准，另一个函数的“投影”。sin和cos是正交的，内积为0，但如果将sin延迟T/4，那么内积最大。相关运算就是引入时延因子的内积。通信里，匹配滤波器就是类似的原理
上面的推导都是基于确知信号的进行分析的，根据维纳辛欣定理，同样满足：自相关函数←→功率谱密度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9d07b7bf86699df30838c1a094aa74/" rel="bookmark">
			vuex的新写法引入mapState省略$store.state
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex的新写法： state简写（映射）：mapState
state里都是状态，所以mapState在computed中使用；state映射也就是引入mapState，然后state可以简写$store.state.状态 =&gt; 状态：前面的$store.state就省略不写了，直接写状态即可 使用方法：
（1）在使用vuex的组件中先导入 mapState
import {mapState} from 'vuex' （2）然后写计算属性computed
computed: { ...mapState(['cinemaList','cityName']) }, 含义：mapState(['cinemaList'])是一个函数调用，函数调用完会返回一个结果，结果是一个对象，再把对象用"..."展开；代码中的cinemaList是state里的状态，所以这个数组里面可以放其他的状态；这样状态在使用的时候都可以简写； （3）然后在使用状态时，就直接 'this.状态' 就可以了，去掉 $store.state
$store.state.cinemaList =&gt; cinemaList $store.state.cityName =&gt; cityName 既然state可以省略简写，actions、Mutations也能简写，
actions简写：mapActions映射
因为actions里面放着的是函数，所以actions映射到组件的methods里；也就是说mapActions在methods中定义；使用方法： （1）导入mapActions
import { mapActions } from 'vuex' （2）在methods中映射 methods: { ...mapActions(['getCinemaData'])//映射成本地的方法 } 数组里的是actions中的方法，放在这里面，可以将vuex里的方法映射成本地的一个方法使用的时候就直接用 this. 方法，替代了：this.$store.dispatch（方法） （3）使用
this.$store.dispatch('getCinemaData', this.cityId) =&gt; this.getCinemaData(this.cityId) mutations（简写）：mapMutations映射
import { mapMutations } from 'vuex' methods: { ...mapMutations(['clearCinema']) } this.$store.commit('clearCinema') =&gt; this.clearCinema() 也可以：
渲染列表时，列表cinemaList不能用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3e4e15b9f5ea42edf1277cecd16480/" rel="bookmark">
			【python学习】使用Mysql数据库进行数据分析-pymysql模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：如何从Mysql8.0数据库中导入数据？四种方法帮你快速开启数据分析的第一步 - 知乎 (zhihu.com)
本文简述用python的Pymysql库对Mysql数据库进行数据分析 ，包括数据写入数据库存储，以及数据库中数据分析。
目录
一、Pymysql模块介绍
二、实操步骤
三、案例
一、Pymysql模块介绍
Mysql数据库是数据挖掘任务的数据源之一，通过pymysql模块可以直接连接Mysql数据库，进行增删改查等操作。Python连接Mysql的流程如下：
python与数据库连接时并不是一次性读取了所有数据，而是根据SQL语言进行操作。cursor在这里相当于执行SQL查询的货车，在Mysql数据库和Python程序之间传递信息。
二、实操步骤 1.导入pymysql
# 导入数值运算numpy、数据分析pandas、数据库连接pymysql和时间调试模块 import pandas as pd import numpy as np import pymysql import time 2.连接Mysql数据库
# 连接Mysql数据库 db = pymysql.connect(host="localhost", user="root", password="123456", database="zgj_project", charset="utf8mb4", cursorclass=pymysql.cursors.DictCursor) pymysql.connect()参数说明：
host(str): MySQL服务器地址，默认为本地主机(localhost)
port(int): MySQL服务器端口号，默认为当前用户
user(str): 用户名，没有默认值
password(str): 连接密码，没有默认值
db(str): 数据库名称
charset(str): 连接编码
cursorclass(str): cursor()使用的种类，默认值为MySQLdb.cursors.Cursor
pymysql.connect()实例对象方法说明：
db.close(): 可关闭数据库连接，并释放相关资源。
db.cursor([cursorClass]):返回一个指针对象，用于访问和操作数据库中的数据。
db.begin(): 用于开始一个事务，如果数据库的AUTOCOMMIT已经开启就关闭它，直到事务调用commit()和rollback()结束。
db.commit(): 表示事务提交
db.rollback():表示事务回退
3.创建游标
# 创建游标 cursor = db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff3e4e15b9f5ea42edf1277cecd16480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c109d9d754a5805766b4d023e281ddf/" rel="bookmark">
			高防CDN是什么，有什么用，网站被攻击了怎么办？云服务器可以接入CDN使用吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的飞速发展，互联网行业百花齐放，百家争鸣的盛况，而随之而来的也是大量隐藏的危机，如DDOS，SQL注入等等网络攻击危害，为此诞生了一款高防CDN。那么高防CDN它到底是什么，它又是如何提供保障呢？
下面就为大家详细的介绍下高防CDN防御网络攻击的机制。
1、CDN节点一般是用户最先接近的服务器端，源服务器是隐藏并被保护在后面，网络攻击者首先攻击的是CDN节点。在节点被攻击的时候，CDN就会启动自动清洗过滤的功能，有效地保护了源服务器。
2、用户可以把网站域名解析到CDN自动生成的CNAME记录值上，网站的IP地址就隐藏在公网上，网络攻击者就不会知道网站的真实IP信息，也就无法进行网络攻击了。
3、高防CDN节点是部署在各个地方，用户访问网站时能够根据用户的本地网络和距离快速分配就近节点给用户访问，大大提高了访问速度。
4、CDN的静态缓存功能可以进一步提高网站的访问速度和有效降低源服务器的带宽压力，保障服务器的稳定性。
5、高防CDN的防御机制和高防服务器不同，并不是单一的防御策略，在不同的攻击类型上，部署了针对不同攻击的防御策略。
6、CDN高防还有弱网加速，通过底层协议优化，有效对抗数据传输过程中各网络节点的波动，解决下载失败、下载错误、速度慢等常见问题，在下载速度慢的情况下，可以将数据传输速度提升10倍，起到CDN网站加速的作用。
7、高防CDN还可以进行实时数据分析系统，快速发现黑客攻击行为，便捷获取安全加速数据。
8、高防CDN配置的WEB应用防火墙，可以有效的拦截防护SQL注入，XSS跨站脚本等应用层的攻击。
简而言之，高防CDN继承了加速CDN的加速功能，并且在外还增加了一层防护，可以让网站更稳定、更有保障。
目前高防CDN的强大功能逐渐暴露在市场上，现如今的网站基本上都会选择接入高防CDN，比较高防CDN对网站的帮助是有目共睹的，不仅能帮助网站解决网络延迟导致用户访问速度变慢，还能帮助网站解决因为网络攻击导致的网站打不开而造成的客户流失。
当网站突然遭遇到ddos攻击时，CDN高防会将攻击流量全部分散开来，很大程度上减轻了服务器的压力，从而避免了服务器崩溃造成的无法访问的情况，以此保证网站的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfb6b454ff9fb234558a606217c99e4/" rel="bookmark">
			bison进行语法分析学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bison采用LALR(1)文法： 参考：https://blog.csdn.net/sirouni2003/article/details/400672
在Bison中,终结符也被称为符号类型(token type). 符号类型也可以由类似C语言标识符来表示.
根据惯例,这些标识符因改用大写子母表示以区分它和非终结符. 例如,INTEGER,INDENTIFIER,IF或者RETURN.
一个表示某语言的特定关键字的终结符应该由紧随该关键字之后的它的大写表示来命名. 终结符error保留用作错误恢复之用.
语义值 包括了记号的所有剩余信息.例如整数的数值,标识符的名称. (一个如’,'的记号只是一个标点,并不需要语义值.)
例如,一个分类为INTEGER的记号包含语义值4. 另一个也被分类为INTEGER的记号的语义值却是3989.
当一个语法规则表明INTEGER是允许的,任意的这些记号都是可接受的,因为它们都是INTEGER.
当一个分析器接受了记号,它会跟踪这个记号的语义值.
被存储在全局变量yylval中
为了更加实用,一个程序不仅仅要分析输入而且必须做的更多. 它应该可以在输入的基础上产生一些输出. 在Bison语法中,一个语法规则可以有一个包括多个C语句的动作(action). 分析器每次识别一个规则的匹配,相应的动作就会被执行. 获取这方面的更多信息,参阅 动作-Actions.
LALR(1) 在一些文法中,Bison标准的LALR(1)分析算法, 不能针对给定的输入应用一个确定的语法规则.
这就是说,Bison可能不能决定(在当前输入的基础上)应该使用两个可能的归约中的那一个,
或者不能决定到底应该应用一个归约还是先读取一些输入稍后再进行归约.
以上两种冲突分别被称为归约/归约(reduce/reduce)冲突(参阅归约/归约-Reduce/Reduce一章)和
**移进/归约(shift/reduce)冲突(参阅移进/归约-Shift/Reduce一章).
GLR: 有些时候, 为了使用一个很难被修改成LALR(1)文法的文法做为Bison的输入,
Bison需要使用通用的分析算法. 如果你在你的文件中加入了这样的声明%glr-parser(参阅语法大纲-Grammar Outline一章),
Bison会产通用的LR(GLR)分析器. 这些分析器(例如,在应用了先前所述的声明之后)
在处理那些不包含未解决的冲突的文法时, 采用与LALR(1)分析器一样的处理方式.
但是当面临未解决的移进/归约冲突和归约/归约冲突的时候, GLR分析器权宜地同时处理这两个可能,
即有效地克隆分析器自己以便于追踪这这两种可能性. 每一个克隆出来的分析器还可以再次被克隆,
这就保证在任意给定的时间,可以处理任意个可能的分析. 分析器逐步地进行分析,即所有的分析器它们进入到下一个输入之前,
都会消耗(归约)给定的输入符号. 每一个被克隆的分析器最终只有两个可能的归宿: 或者这个分析器因进入了一个分析错误而最终被销毁,
会这它和其它的分析器合并,因为它们把输入归约到了一个相同的符号集.
在有多个分析器并存的时刻,Bison只记录它们的语义动作而不是执行它们.
当一个分析器消失的时候,相应的语义动作记录也消失并且永远不会被执行.
当一个规约使得两个分析器等价而合并的时候, Bison会记录下它们两个的语义动作集.
每当最后两个分析器合并成为一个单独的分析器的时候, Bison执行所有未完成的动作.
这些动作既可能依靠语法规则的优先级被执行也可能均被Bison执行.
在执行完动作之后,Bison调用指定的用户定义求值函数来产生一个独立的合并值.
当使用平常的LALR(1)文法的时候,Bison会报告一个归约/归约冲突.
在冲突的时候,分析器在会众多选择中选取一个-随意地选择那个先声明的. 所以下面的正确输入不能被识别.
type t = (a) .. b; 在Bison输入文件中, 加入这两个声明(在第一个`%%'之前)分析器可以将分析器编成一个GLR分析器, 并且Bison不会报告一个归约/归约冲突.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebfb6b454ff9fb234558a606217c99e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/189/">«</a>
	<span class="pagination__item pagination__item--current">190/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/191/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>