<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e2227b8a7d4337d588963fbd5c1332/" rel="bookmark">
			C语言之阶梯问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 简介 爱因斯坦的阶梯问题是一个经典的数论问题，通常表述为：存在一个无限长的阶梯，要求找出一个最小的正整数阶梯阶数，使得当按照不同的步幅上阶梯时，最后一步都恰好剩余一定的阶数。具体来说：
每次跨2阶时，最后剩1阶；每次跨3阶时，最后剩2阶；每次跨5阶时，最后剩4阶；（有些版本还包括每步跨6阶时剩5阶，以及每步跨7阶时刚好走完所有阶数） 这个问题实际上可以通过中国剩余定理或模运算来解决，寻找满足以下同余方程组的最小正整数解x：
x ≡ 1 (mod 2) x ≡ 2 (mod 3) x ≡ 4 (mod 5) x ≡ 5 (mod 6) （在某些描述中） x ≡ 0 (mod 7) （意味着当每步跨7阶时，正好走完整数阶数） 二 代码实现 解决这类问题的C语言代码通常会采用循环结构，并使用取模运算符 % 来判断当前数是否满足所有条件。由于这是一个线性同余方程组，直接求解可能会很复杂，但在实际编程中可以采取迭代搜索的方法，从某个起始值开始逐步增加，并检查每个数是否同时满足所有给定的模关系。
下面是一个简化版的示例代码片段（可能需要进一步完善以处理多条件）：
#include &lt;stdio.h&gt; int main() { int x = 1; // 初始化变量x为1，作为搜索的起点 while (1) { // 循环直到找到符合条件的数 if ((x % 2 == 1) &amp;&amp; (x % 3 == 2) &amp;&amp; (x % 5 == 4)) { // 根据题目条件添加其他模运算符条件 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e2227b8a7d4337d588963fbd5c1332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c9d6f9fa3ac9ab70562943c71826bc7/" rel="bookmark">
			`sig_atomic_t` 是C语言中的一个数据类型，它通常用于在信号处理程序中声明变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子
static volatile sig_atomic_t signal_num; static void SigTerm(int signo) { running = 0; signal_num = signo; } int main(int argc, char *argv[]) { signal(SIGTERM, SigTerm); signal(SIGINT, SigTerm); } sig_atomic_t 是C语言中的一个数据类型，它通常用于在信号处理程序中声明变量。这个类型的变量保证可以在信号处理程序中原子地（atomic）访问，这意味着在多线程或信号处理上下文中，对这个变量的读取和写入操作是原子的，不会被中断。
在信号处理程序中，通常需要使用一些标记来指示某些事件的发生或状态的改变。由于信号处理程序可能随时被中断，因此需要确保对这些标记的访问是原子的，以避免数据不一致性或竞争条件。
sig_atomic_t 类型的变量通常用于以下情况：
在信号处理程序中更新的全局变量。
用于在信号处理程序和主程序之间传递信息。
虽然 sig_atomic_t 类型确保了原子性，但是它并不是多线程编程中用于同步的最佳选择。对于多线程编程，应该使用更加专门化的同步机制，如互斥锁、条件变量等。
总之，sig_atomic_t 类型提供了一种在信号处理程序中处理共享数据的基本手段，确保对该类型变量的操作是原子的，从而避免由并发访问引起的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63006dbc0b2d984e121d8cb17e2ae17/" rel="bookmark">
			机器学习之客户违约预测模型搭建之原理篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这一章主要介绍机器学习在金融领域一个重要应用：客户违约预测模型的搭建，其所用到原理为机器学习中的决策树模型。通过本章的学习，您能了解在信息时代下金融风险控制的新手段，并对机器学习有一个初步的了解。
1. 机器学习在金融领域的应用 说到机器学习（Machine Learning），有的读者可能会感觉比较陌生，然而说到AlphaGo这一击败了世界顶级围棋选手的智能机器人，想必大家多少都有些耳闻。机器学习便是模拟或实现人类的学习行为，以探寻规律或者获得新的技能，机器学习某种程度上可以说是人工智能的核心。
举个简单的例子，如下图所示，该机器学习的目的就是要从一堆散点中寻找到这些散点背后的规律。
本章主要介绍一下客户违约预测模型，作为机器学习在金融领域应用的典型案例。在传统金融领域，往往存在两方角色，一方为借钱的借款方，另一方则为借钱给别人的贷款方，而作为贷款方则非常关心借款方是否会违约，即借钱不还。有的借款方可能完全就是抱着借钱不还的心态去借的资金，而对于这些客户，则需要搭建一套客户违约预测模型，根据借款人的各方面特征，来训练出合适的模型进行违约概率预测，从而在源头上拒绝这些潜在违约客户。
可用来搭建客户违约预测模型的方法有很多，如逻辑回归模型、决策树模型、神经网络模型等，这里则使用一个在商业上用的较多的决策树模型。
2. 决策树模型的基本原理 2.1 决策树模型简介 决策树模型是机器学习各种算法模型中比较好理解的一个模型，它的基本原理便是通过对一系列问题进行if/else的推导，最终实现相关决策。
下图便是一个典型的决策树模型，首先判断是否曾经违约：
• 如果 答案是“是”则认为该用户会 违约 • 如果 答案是“否” 则，接着 判断其收入是否小于 10,000 元： • 如果 答案是“是”则认为该用户会 违约 • 如果 答案是“否”则认为该用户不会 违约 以下的决策树模型也是之后我们要搭建的客户违约预测模型的雏形。不过商业实战中不会单纯根据“曾经违约”以及“收入&lt;10,000”两个特征就判断成违约或者非违约，而是根据多个特征来预测违约概率，并根据相应的阈值来判断是否违约，比如违约概率超过50%即认为该用户会违约。 这里解释几个决策树模型的重要关键词：根节点、父节点、子节点和叶子节点
• 父 节点和子节点是相对的，子节点由父节点根据某一规则分裂而来，然后子节点作为新的父亲节点继续分裂，直至不能分裂为止 。 • 根 节点是没有父节点的节点，即初始 节点 。 • 叶子 节点则是没有子节点的节点，即最后的节点 。 决策树模型的关键即是如何选择合适的节点进行分裂。在上图中，最上面的“曾经违约”就是根节点，其中“收入&lt;10,000”则为其子节点，同时也是其下面两个节点的父节点，最后的“违约”及“不违约”则为叶子节点。
实际应用中，风控人员会通过已有的数据来看违约客户都符合什么样的特征，比如看他们的：
• 历史 违约 记录 • 收入 • 年龄 • 历史 授信额度 等 然后选择合适的特征进行节点分裂，便可以搭建出类似上图所示的决策树模型。利用该决策树模型就可以预测之后其他客户的违约可能性，从而避免潜在风险。
决策树概念本身并不复杂，主要就是通过连续的逻辑判断来得到最后的结论，其关键的难点在于如何建立出这样一颗树来
比如根节点应该选择哪一个特征，选“曾经违约”作为根节点和选“收入&lt;10,000”作为根节点会起到不同的效果。其次收入作为一个连续变量，是选“收入&lt;10,000”作为一个节点，还是选“收入&lt;100,000”作为一个节点都是有考究的。
2.2 决策树模型的建树依据 决策树模型的建树依据主要用到一个基尼系数(gini)的概念。基尼系数用于计算一个系统中的失序现象，也即系统的混乱程度。基尼系数越高，系统混乱程度越高，建立决策树模型的目的就是通过合适的分类来降低系统的混乱程度，其计算公式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63006dbc0b2d984e121d8cb17e2ae17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34338e0dc048b63acda9856f8c7c3f5/" rel="bookmark">
			二叉树的内存池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下摘自算法书：
内存池（memory pool），用来防止内存溢出的一个工具，具体来说就是维护一个空闲列表（free list），初始时把上述node数组中所有元素的指针放到该列表中，如下所示：
queue&lt;Node*&gt; freenodes; Node node[maxn]; void init{ for(int i = 0; i &lt; maxn; i++) freenodes.push(&amp;node[i]);//初始化内存池 } Node* newnode(){ Node * u = freenodes.front(); u-&gt;left = u-&gt;right = NULL; u-&gt;have_value = false;//重新初始化该结点 freenodes.pop(); return u; } void deletenode(Node * u){ freenodes.push(u); } 其中，Node结构的定义可以参考我上一篇博客：
Trees on the level（UVA 122）-CSDN博客
提示：可以用静态数组配合空闲列表来实现一个简单的内存池。虽然在大多数算法竞赛题目中用不上，但是内存池技术在高水平竞赛及工程实践中都极为重要。
当然你也可以动态分配内存，只要用上new和delete就行了（记得用delete，要不然有可能会内存溢出），C的话是用malloc函数。上述方法是用数组来实现二叉树的，内存池是用了静态化动态的思想，使不用的结点的内存释放更加方便。而动态分配内存是用”指针+结构体“来实现二叉树的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceef09c0317a8e1f2f71bb58dd391f37/" rel="bookmark">
			【并查集】模版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【模板】并查集 - 洛谷
#include &lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+9; int a[N]; int Find(int x) { if(x==a[x]) { return x; } else { a[x]=Find(a[x]); return a[x]; } } void push(int x,int y) { a[Find(x)]=Find(y); return ; } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { a[i]=i; } for(int i=1;i&lt;=m;i++) { int op,x,y; cin&gt;&gt;op&gt;&gt;x&gt;&gt;y; if(op==1) //连接 { push(x,y); } else { if(Find(x)==Find(y)) { cout&lt;&lt;"Y"&lt;&lt;endl; } else cout&lt;&lt;"N"&lt;&lt;endl; } } return 0; } 0城市群的数量 - 蓝桥云课 (lanqiao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceef09c0317a8e1f2f71bb58dd391f37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8e0c2dde19e2a999c619f37de0b8e2/" rel="bookmark">
			关于Apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、httpd 安装组成1、常见http 服务器程序2、apache 介绍和特点2.1 关于apache2.1.1 apache 功能2.1.2 apache特性 2.2 MPM multi-processing module 工作模式2.2.1 prefork2.2.2 worker2.2.3 event 3、Httpd 安装和相关文件3.1 包安装httpd并启动httpd服务3.1.1 版本说明3.1.2 安装方式 3.2 httpd-2.4 相关文件3.2.1 配置文件3.2.2 检查配置语法3.2.3 服务单元文件3.2.4 服务控制和启动3.2.5 站点网页文档根目录3.2.6 模块文件路径3.2.7 主服务器程序文件 二、httpd常见配置1、指定服务器名2、包含其它配置文件2.1 include 子配置文件2.2 总目录 3、监听地址4、隐藏服务器版本信息5、持久连接6、DSO (Dynamic Shared Object)7、MPM (Multi-Processing Module)多路处理模块8、prefork模式相关的配置9、worker 和 event 模式相关的配置10、定义Main server的文档页面路径11、定义站点默认主页面文件12、虚拟主机12.1 基于ip地址12.2 基于端口地址12.3 基于域名 三、Cookie和session1、Cookie2、Session2.1 cookie和session的相同和不同2.2 cookie缺点2.3 session 缺点 四、Web相关工具1、Weget相关工具2、curl3、压力测试工具 一、httpd 安装组成 http 服务基于 C/S 结构 1、常见http 服务器程序 httpd apache，存在C10K（10K connections）问题nginx 解决C10K问题lighttpdtomcat .jsp 应用程序服务器IIS .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f8e0c2dde19e2a999c619f37de0b8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50649e4d23ee40c44a8a17870aa16742/" rel="bookmark">
			react native 修改 react native element 组件默认样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 react native element
我看很多人的文章安装的不是稳定版的，也都没有去教怎么去修改
npm install @rneui/themed @rneui/base
// 页面中引入 ListItem 组件
import {ListItem} from '@rneui/themed';
import React, {useEffect, useState} from 'react'; import {View, Text, Alert, StyleSheet} from 'react-native'; // 引入 组件 import {ListItem} from '@rneui/themed'; const ListItem = () =&gt; { return ( &lt;&gt; // 使用组件 &lt;ListItem&gt; &lt;ListItem.Content&gt; &lt;ListItem.Title&gt;Inbox&lt;/ListItem.Title&gt; &lt;/ListItem.Content&gt; &lt;/ListItem&gt; &lt;/&gt; ) } export default ListItem ; 这个 ListItem 组件 默认是白色背景 没有圆角的 我们修改成红色背景增加圆角
import React, {useEffect, useState} from 'react'; import {View, Text, Alert, StyleSheet} from 'react-native'; // 引入 组件 import {ListItem} from '@rneui/themed'; const ListItem = () =&gt; { return ( &lt;&gt; // 使用组件 &lt;ListItem containerStyle={styles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50649e4d23ee40c44a8a17870aa16742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d800f76dd463eb5120f32436115017/" rel="bookmark">
			【业务功能篇 147】OOM场景示例、解决方案、ArrayList内存溢出、软引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【业务功能篇136】MAT(Memory Analyzer Tool)，找出导致OOM的代码-CSDN博客
Java内存溢出如何解决，Java oom排查方法，10个定位解决办法_javaoom怎么解决-CSDN博客
ArrayList内存溢出
Java内存溢出如何解决，Java oom排查方法，10个定位解决办法_javaoom怎么解决-CSDN博客ArrayList与LinkedList性能分析_new arraylist&lt;&gt;(linkedlist) 与.clone() 性能-CSDN博客
为什么我使用【ArrayList】存储数据报错【OOM】_"arraylist login=(arraylist)session.getattribute(\-CSDN博客
1.使用软引用
Java中四种引用详解以及对比区别_java四种引用的区别-CSDN博客 弱引用（WeakReference）在系统GC时都会进行回收，而软引用（SoftReference）是在内存不足时被回收，适用于实现缓存等功能。 我们可以把大对象LIst进行软引用
软引用( SoftReference) 会尽可能长的保留引用直到 JVM内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用
如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中
代码示例：
public static void main(String[] args) { // 创建强引用对象 Object strongReference = new Object(); // 创建软引用 SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object()); // 创建弱引用 WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object()); // 数组软引用 SoftReference&lt;LinkedList&lt;Integer&gt;&gt; arrayListSoftReference = new SoftReference&lt;&gt;(new LinkedList&lt;&gt;()); // 数组弱引用 WeakReference&lt;LinkedList&lt;Integer&gt;&gt; arrayListWeakReference = new WeakReference&lt;&gt;(new LinkedList&lt;&gt;()); AtomicInteger count1 = new AtomicInteger(); AtomicInteger count2 = new AtomicInteger(); for(int i = 0; i &lt; 5; i++){ Optional.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d800f76dd463eb5120f32436115017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e201b7f7ab459f205c0113c62e48b3c1/" rel="bookmark">
			【支持H264/H265格式的1078音视频流媒体服务器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持H264/H265格式的1078音视频流媒体服务器 概述 概述 实现H264、H265视频的1078音视频服务器
对于H265的1078音视频服务器，跟H264的视频解析主体逻辑一样，都是要接收到来自终端的H265或H264的码流，然后解析出sps信息，获得视频分辨率，至于视频类型，可以通过1078中的音视频编码类型定义来识别。
但是对于H264和H265获取并解析sps信息的方式是不一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b2192d9a6f567004fe502cdcc612eb/" rel="bookmark">
			332反溯法:怎样发掘自己的内在天赋?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我将从两个话题出发，为你提供知识服务。第一个是，2024游泳世锦赛在卡塔尔落幕，中国选手潘展乐成为全场焦点。第二个是，爱因斯坦大脑，成淘宝热销商品。
先来看今天的第一条。就在上个月，2024年游泳世锦赛在卡塔尔多哈举办。中国队获得了23枚金牌，33枚奖牌，在金牌榜和奖牌榜的排名都是第一。其中，最受关注的运动员，是19岁的游泳选手潘展乐。他一口气拿下了4枚金牌，包括男子100米自由泳的金牌。这个分量有多重呢？100米自由泳在游泳项目中的地位，相当于田径比赛中的百米飞人大战，这个项目长期被欧美选手统治。而这回，潘展乐用46.80秒的成绩，直接打破了世界纪录。
世界泳联也特别在官网提到，潘展乐是一名“天赋异禀”的选手。你看，以前的短距离游泳运动员，通常是体格魁梧，爆发力惊人，而潘展乐，身体相对瘦削，力量也不突出。以往的短距离游泳，选手通常动作幅度很大，而潘展乐的发力非常柔和。那么他凭什么取胜？
按照世界泳联的评论，主要是因为潘展乐的水感特别强。没错，水感，这个词听上去很玄乎，它指的是，运动员对水的特性，理解、感知、利用的能力。有时候两个人，泳姿相同，技术相差不大，但有可能在速度上出现很大的差距，这个差距就来自“水感”。说白了，就是天赋上的差距。
今天，借着这个话题，我们就来说说天赋这件事。没错，就像那句话说的， 人人皆有禀赋，关键是发现它、抓住它、激活它。
那么，怎样发现自己的天赋呢？正好前段时间，我看到一场访谈。麦肯锡前全球合伙人李一诺，采访了畅销书《像火箭科学家一样思考》的作者奥赞•瓦罗尔。里面提到几个观点，也许能对咱们有所启发。
咱们先从瓦罗尔这个人说起。瓦罗尔是土耳其人，高中自学了编程和天文学，17岁就被康奈尔大学录取。大学时，正好赶上康奈尔的一个教授，在NASA发射机遇号和勇气号火星探测车的项目里，瓦罗尔编程水平不错，就毛遂自荐给这个教授当助理，参与了NASA项目，成了火箭科学家。毕业后，瓦罗尔改行学法学，获得了法学博士学位，并且当上了一所顶尖大学的法学院终身教授。他持续发表了很多与外交、政治有关的文章，最后还成了畅销书作家。
乍一看，瓦罗尔的经历，多少有点“天纵奇才”的意思。但是，假如细看，其中是有这么几个，特定的行动方式的。瓦罗尔把自己的方法，归纳成了三点。
第一点是，保持有结果的好奇心。你看，好奇心，这三个字不难理解，人人都有。但是，它能不能成为你事业的助推，关键看，你保持好奇的方式。对多数人来说，好奇心，好像只关系到兴趣。我对一个东西好奇，也只限于查查资料，看一点相关信息。
但是，对瓦罗尔来说，这还不够，关键是，必须得让自己的好奇有一个结果。比如，瓦罗尔原本的专业是天体物理学，但瓦罗尔对法律特别感兴趣。这要放在一般人身上，顶多是看几本法学相关的书就够了。但是，瓦罗尔认为，这事必须得有个结果。要么是拿到一个什么证书，要么是拿到一个相关的学位。你只有拿到一点结果，获得一点来自外部世界的反馈，你才知道这个爱好值不值得坚持下去。在这个动机的驱使下，瓦罗尔先是学了相关课程，后来一路进入法学院，最后还当上了法学教授。
再比如，瓦罗尔转行研究法律之后，好奇心又转移到了在线写作上。既然要写，就得写出个结果。这么一步步走下来，他又写出了《像火箭科学家一样思考》这本书，又成为畅销书作家。
换句话说，好奇心能帮助我们扩展兴趣爱好，而追求结果的好奇心，能帮人扩展事业的可能性。
但是，听到这，你可能会说，我也知道保持好奇是件好事。但问题是，一旦你付诸行动，就有可能会面临失败。这个代价，很多人不愿意承受，怎么办？
这就要说到，瓦罗尔的第二个洞察，叫做，代价恒定。说的是，一旦把视线拉长，一个人总归是一定要为什么付出一点代价的，再聪明的人也躲不过去，这就叫代价恒定。
瓦罗尔认为，你尝试了，失败了，确实要付出代价。但是，不尝试，你也要付出代价，这个代价叫做“遗憾”。假如你找到了自己好奇的方向，却从没探索过它，那么，当你回顾自己的生活时，你会因为遗憾而感到痛苦。这个痛苦程度，不会比任何眼下的经济损失小。
之前我们讲过一个人，叫乔丹·格鲁梅特，是一位临终关怀医生。按照格鲁梅特的观察，人在临终时，确实会因为好多事而后悔。但很少有人会后悔年轻时挣钱太少，或者职位晋升得不够高。在事业方面，多数人后悔的都是，年轻时尝试得太少。
你看，一旦意识到这个终局，人内心的迟疑是不是就小了很多？
按照瓦罗尔的话说，只要你迈出尝试的这一步，即使失败了，你也可以从中学到东西。就像之前的跨年演讲中，罗老师引用的那句话——“我没有失败过，要么赢得胜利，要么学到东西。”
接着咱们再来说，瓦罗尔的第三个要点，关于怎样行动。
瓦罗尔的观点是，不要从过去推测未来，而要从未来反推现在。他把这个方法叫做“反溯法”，说的是，你不要在乎当下的现实，不要在乎去年做了什么，你要从未来的理想开始倒推，给自己的现在制定一个行动方案。
比如，瓦罗尔在中学的时候，就给自己制定了一个大胆的“登月计划”。他当时的理想是成为一名宇航员，有了这个远大目标，他开始制定行动方案——他要学英语，上美国的大学，学习天体物理，拿到优秀成绩，进入NASA，等等。照着这个方案，尽管瓦罗尔没有当上宇航员，但他完成了前面几步的任务，最终成功参与了火星探测器的发射。
你看，从现实出发，你看到的都是限制。但是从理想出发，马上就能找到行动的抓手。这也正是“反溯法”的关键，就像那句话说的，理想不是让你用来实现的，而是给你当下的行动建立桥梁。
瓦罗尔在去年出版的新书《为自己思考》中提到，所谓“天才”，指的不是盖世才华或者绝顶聪明，用音乐家塞隆尼斯·蒙克的话说，天才“就是最像自己的人”。每个人的天赋就封存在他的内心之中，等着被唤醒。怎么唤醒？用瓦罗尔的方法来总结，就是三个词——好奇、勇气、行动。首先，对抗标准答案，找到好奇所在；其次，接受代价恒定，不停尝试；最后，从未来反推现在，制定行动方案。
再来看今天的第二条。就在最近几个月，淘宝上有个东西卖得很火，叫爱因斯坦的大脑。这是个虚拟商品，给人的感觉，就跟在庙里求签差不多。在商品海报上，往往还有这么几句描述，叫爱因斯坦之脑，逢考必过之脑，事业有成之脑，爱情美满之脑。售价从1毛到5毛钱不等。而且销量不错，很多店铺都在万件以上。就在去年年底，淘宝公布的年度十大商品里，爱因斯坦的大脑还上榜了。
那么，爱因斯坦的大脑，最初是怎么变成一门生意的呢？前段时间，媒体“卖家”做了调研。这门生意最开始出现，大概经历了这么三步。
首先，沉淀目标用户。据说，“爱因斯坦的大脑”最开始是一个叫“全国快递专业代下”的淘宝店铺上架的。老板是一位2001年出生的小伙子，叫张建茜，大学学的就是电子商务专业。2020年的七夕，张建茜发现周围的同龄人经常借用“孤寡青蛙”这个梗来调侃自己的单身状态。他觉得这可能是个机会，就在自己的店铺里上架了一个商品，叫孤独青蛙。简单说，这是一个代聊服务。你买了，张建茜就会联系你指定的朋友，去跟他打个招呼，简单聊聊天。久而久之，张建茜的店铺就汇集了一群人。他们有点猎奇心态，也愿意为新奇的虚拟商品付费。以此为基础，张建茜后来才有底气卖爱因斯坦的大脑。后来这个潮流蔓延到其他店铺，大家一起跟进。
换句话说，要想卖出一款虚拟商品，需要先把愿意为这件事付费的人聚集过来。
其次，关于商品定价。在张建茜的淘宝店铺中，虚拟商品普遍在0.01元到0.99元之间。这个价格的好处就是，几乎没有支付门槛。而且每个商品内部的价格还会细分，比如有一个虚拟商品叫“野生蚊子”，里面农村蚊子的价格是0.3元，超大蚊子的价格是0.6元，国外偷渡来的蚊子价格是0.7元。你看，虽然价格低，但整个交易过程中的体验却很细致。
同时，这些虚拟商品还有后续的服务，那就是店主会一一回复买家的留言。你的回复必须得足够好玩，足够开脑洞，大家才觉得这个商品买得值。比如，有人问，这个商品会跟恋爱脑排斥吗？回复是，会排斥，建议亲先买切除恋爱脑。再比如，有人问，今晚要去打麻将，买这个合适吗？回复是，考试还行，打麻将不知道。没错，老板开脑洞的回复，也是商品体验的一部分。
最后，商品怎么起名？这是最关键的一步。除了“爱因斯坦的脑子”，淘宝还有“达·芬奇的脑子”“牛顿的脑子”“希波克拉底的脑子”“梵高的脑子”等。其中销量最高的就是“爱因斯坦的脑子”。这主要是因为，爱因斯坦之脑，背后有很丰富的故事。
比如，1955年，美国休斯敦医院的病理学医生托马斯·哈维，偷走了爱因斯坦的大脑，并且把大脑切成了240片用来研究。再比如，美国费城的穆特博物馆，曾经展出过爱因斯坦的大脑切片。之前还有部纪录片，叫《爱因斯坦大脑的秘密》。换句话说，爱因斯坦之脑这几个字背后，有很多耐人寻味的故事。
你看，爱因斯坦的大脑，卖的哪里是一个简单的虚拟商品。它包括一段故事，还有店主有趣的回复，以及购买过程中的一些开脑洞的体验。商品是虚拟的，但这部分体验却特别真实。
最后，总结一下，今天说了两个话题。
第一，怎样发掘自己的内在天赋？瓦罗尔的建议是，首先，别怕失败，因为代价恒定。其次，好奇心不稀缺，但让你的好奇心产生结果，这个行动深度是稀缺的。最后，理想不是用来实现的，而是为了让当下的行动更有力量。
第二，爱因斯坦的大脑是怎么成为一门生意的？关键在于，以虚拟商品为线索，让用户的情绪体验落到实处。
好，以上就是今天的内容。《得到头条》，明天见。
1. 怎样发掘自己的内在天赋 首先，别怕失败，因为代价恒定。其次，好奇心不稀缺，但让你的好奇心产生结果，这个行动深度是稀缺的。最后，理想不是用来实现的，而是为了让当下的行动更有力量。 2. 爱因斯坦的大脑怎么成为生意 关键在于，以虚拟商品为线索，让用户的情绪体验落到实处。爱因斯坦的大脑，卖的不仅是一个简单的虚拟商品，它还包括一段故事，店主有趣的回复，以及购买过程中的体验。 https://www.dedao.cn/course/article?id=wgpMLla6Py4qK25BmQXYmvNzjd2Zx1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66673d188e5274aadc730dbc8fe01fea/" rel="bookmark">
			333哈佛世纪研究:何为幸福生活?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重点
1. 幸福生活是由什么决定的 第一，拥有好的人际关系，对幸福生活有最大的积极影响。第二，毁灭幸福的最大元凶，是酗酒。第三，幸福人生，关键不在于短期成功，而是长期不输。 2. 假肢设计的新思路 第一，假肢不必像真肢，因为大脑对它有一套独立的反应模式。第二，未来假肢的技术方向，是让它具备触觉之类的感官。第三，研发给普通人的假肢，目的是拓展身体能力。 先来看今天的第一条。最近有个新闻，说的是，有一位B站的游戏UP主，叫杨炳林，一个月前获得了吉尼斯世界纪录的认证。不是因为他玩得好，而是因为，这位杨炳林今年已经88岁。没错，吉尼斯给他的认证是，世界最年长的B站游戏UP主。
要说老人家这辈子过的，那真叫一天都不虚度。杨炳林年轻的时候，是石油技术工程师。1996年退休，喜欢上了玩游戏。这一玩就是20多年，还玩出个世界纪录。据说他已经通关过500多部游戏，比绝大多数人一辈子玩的都多。
吉尼斯给他颁布世界纪录时，是这么点评的：“吉尼斯的使命是记载不可思议的事情，通过分享纪录保持者的故事，帮助人们突破极限，为世界带来欢乐和启迪。杨炳林退休后接触游戏，又在80多岁的高龄开始做游戏博主，这样的经历鼓舞着很多网友。”
但是好多人关注这个新闻，倒不是因为老爷子获得了世界纪录，而是从杨炳林身上，你能感受到一种强烈的幸福感。你也说不清他为什么这么高兴。总之，这老爷子身上好像有用不完的精力，对游戏有用不完的热情，而且永远乐在其中。
你看，说到这，就引出一个特别抽象，而且好像很难有标准答案的问题。这就是，一个人的幸福感，到底是由什么决定的？
关于这个问题，市面上有好多书，好多课。但是今天，咱们从中挑选一个，相对权威的研究说说。这个研究来自哈佛大学。也是哈佛历史上，历时最长的研究之一。从1938年开始，到目前为止，已经开展了86年。
这就是著名的哈佛成人发展研究。发起人是哈佛大学的卫生系主任阿列·博克教授。因为研究的早期赞助人是慈善家威廉·格兰特，因此这个研究也叫格兰特研究。
这项研究每隔一段时间，就会向社会同步最新的成果。之前得到站内也有很多老师讲过。而我们今天要说的，是这项研究的最新成果。就在去年，这项研究的课题组出了一本书，叫《美好生活》，同步了他们过去85年的成果。
正式开始之前，先介绍一下背景。这项研究最开始锁定了两拨人。第一拨，是在哈佛大学里挑选了268名本科生。这些人都是19岁左右，家境殷实，清一色的白人男性。第二拨，是在波士顿市区，挑选了456名男孩。挑选标准是，家境困难，收入不高，且在14岁之前没有犯罪记录。
总之，就这么出身差异巨大的两伙人。课题组对他们追踪调查了整整80多年。其间很多人成家立业，娶妻生子。课题组就继续观察他们的孩子。到今天，这项研究的观察对象，已经扩展到了上千人。
而且因为资金消耗太大，课题中间还差点中断。好在这群被研究的对象里，走出了几个特别有钱的企业家，这才让这项研究坚持到了现在。
好，回到研究本身，这项研究有哪些关键结论呢？咱们今天挑几个重点说说。
第一，成就与毁灭幸福生活的因素有哪些？
首先，一个人过上幸福生活的最关键因素，是他的人际关系，而且这个关系是贯穿一生的。注意，可不是智商。按照这项研究，智商110和150的人，收入上几乎没什么差距。但是，人际关系带来的收入差异就大了。比如，小时候跟母亲关系亲密的人，平均每年多赚8.7万美元，也更不容易得老年痴呆症，而且职业生涯后期的职位更高。再比如，小时候跟父亲关系亲密的人，在他的一生中，焦虑水平都比较低，更会享受假期，而且在75岁时的生活满意度更高。再比如，那些50岁时对自己的人际关系感到满意的人，到80岁时，身体会更健康。
说白了，拥有好的人际关系，对幸福生活有最大的积极影响。用格兰特研究的前任负责人瓦利恩特的话来说，这项研究表明，“幸福只关乎爱。”（Happiness is love. Full stop.）
其次，什么因素对幸福的伤害最大？前面说过，这项研究的追踪对象，有不少都是哈佛的高材生。而且还走出了4名议员、1名州长，还有《华尔街日报》的主编等等，还走出了一名美国总统，约翰·肯尼迪。当然，肯尼迪的研究档案早就被美国政府单独拿走，据说2040年才能解密。
但问题是，剩下那些不成功，或者不幸福的，他们是被什么事儿给耽搁了呢？按照研究的结论，这个毁灭幸福的最大元凶，是酗酒。在离婚、生病、抑郁症这些事上，最大的元凶就是酗酒。
注意，前面这些结论也许并不算很新，课题组早在很多年前就对外公布过。但问题是，道理大家都懂，很多人未必能付诸行动。因此在去年的《美好生活》里，课题组特地强调了一个实验，这也是咱们要说的第二个关键结论。
这就是，人类并不擅长情感预测。
比如，让一个人预测经济。他未必能预测得很准，但至少通过训练，通过学习，他能掌握一个大致的预测逻辑。知道天气热了空调卖得好，下雨天买雨伞的人多。这都属于逻辑型的预测，我们可以通过训练掌握。
但是，还有一类预测，属于情感型的预测，我们就不太擅长了。比如，芝加哥大学的研究者曾经做过一个实验。他们在火车上找了一组乘客。问他们，假如你在这一路跟陌生人聊天，你觉得自己会更高兴吗？在发车之前，几乎所有人都觉得，跟陌生人聊天纯属没话找话，只会浪费精力，不会让自己高兴。但是，等旅途结束，研究人员又做了一次调查。结果发现，路上跟陌生人聊天的乘客，居然都感觉挺高兴。跟他们之前的直觉正好相反。
再比如，假如你看一个人不顺眼，觉得骂他一顿就痛快了。但事实上，你要是真骂完，大概率上只会更生气。再比如，你参加某个聚会之前觉得不情愿，但参加完之后觉得来对了，认识了不少朋友。
换句话说，人并不擅长预测人际关系带来的好处。说白了，一旦你犹豫要不要跟人打招呼，那就去打。犹豫要不要跟人联系时，马上去联系。犹豫要不要周末回家看看父母时，果断去看。因为这些事带来的益处，肯定要比预想中的多得多。
第三个结论是，幸福人生这个事，关键不在于短期成功，而是长期不输。说白了，只要人在，只要不犯永久性错误，不管年轻时经历过多大的挫折，都有机会在晚年扳回一局，过上幸福的生活。
注意，是不犯永久性错误。在这里，借用喻颖正老师的比喻。比如，一个人买了股票，结果跌得一塌糊涂被套了，然后扔在一边不管。几年后想起来一看，居然赚了。这就属于短暂的倒霉，不伤元气。但是，假如一个人失业一次，就开始自暴自弃，四处抱怨，再也振作不起来，就属于永久性错误。
按照研究团队的观察，那些最终成功的人，不是能力特别强，而是内心都特别皮实。按照前任负责人瓦利恩特的话说，人的一生中，不可避免会遇到挫折和痛苦，关键在于，一个人如何构建自己的 “应对机制”。假如一个人对各种意外都有很好的适应能力，那他的生理和心理，都会衰老得更慢一点。
注意，这可不是一句空洞的鸡汤，而是研究团队调研的结果。他们发现，人生的机会，可不是仅仅集中在年轻的时候，集中在35岁之前。假如拉长视角，机会在整个人生中，大概是平均分布的。35岁时确实多一点，但没有那么集中。也有35岁之前整天稀里糊涂，但到了晚年非常幸福的。说白了，只要不下牌桌，就有可能赢回来。
你看，最近几年有好多词儿开始流行。比如，钝感力、复原力、归零力，等等。它们本质上，说的都是一个人不下牌桌的能力。
好，关于这项研究，咱们先说到这。简单总结一下，根据哈佛大学的研究，幸福人生的三个关键要素分别是，建立良好的周边关系、磨炼自己的复原力，以及不管发生什么事，始终不下牌桌。要是单看结论，也许有点像大道理。但是，这项研究的价值也许就在于，它能让你以后再看到这些大道理时，会想到，原来这背后，还有一项持续了86年的研究来论证它，还有那么多扎扎实实的数据。想到这里，你再看这几个建议，是不是感觉，它们比原来更鲜活了一点？以及自己付诸实践的决心，更坚定了一点？
最后，说到幸福生活，正好最近，贾行家老师的播客《大望局》上线，第一期的主题就叫何为良好生活。贾行家老师和四位常驻嘉宾，作家周晓枫、东东枪、心理学者李松蔚老师，还有喜剧演员夏夏，一起碰撞出了很多有趣的内容。推荐你也来听听看。
再来看今天的第二条。最近，很多地方出台了残疾人辅助器具的补贴政策。像假肢、轮椅、助听器之类的残疾人辅具，都涵盖到了。比如苏州，发布了《苏州市残疾预防和残疾人康复实施办法》，3月正式落地实施。再比如西藏，发布了《西藏自治区残疾人基本型辅助器具适配补贴实施办法（试行）》，为西藏户籍的持证残疾人、残疾儿童、65岁以上失能老人配置基本辅助器具，等等。
除了政策保障，残疾人辅具的技术也在进步。今天，借着这个话题，我们就说说残疾人辅具的几个新的技术思路。
第一个技术方向是，假肢不必像真肢。过去说到假肢，最好和人的肢体一模一样。这主要是因为，过去的研究者有个假设。认为假肢越仿真，大脑就越会把它们当成真正的肢体，用起来就越方便。
但是，剑桥大学的一个神经科学家，叫塔玛尔·马金（Tamar Makin）做了个试验，他请单手截肢的志愿者看三种不同的图片，分别是假肢、生物手，以及刷子、勺子这类手持工具，然后用磁共振成像技术看志愿者大脑的反应。这其实是在给假肢做分类。你看，假如志愿者看到假肢时，大脑的反应跟看到生物手一样，也许说明大脑是把假肢当成了真正的肢体。假如看假肢时，大脑的反应跟看到工具一样，说明大脑把假肢也当成了勺子刷子之类的工具。
但是，真实情况是，大脑既没有把假肢当肢体，也没有当工具。大脑对假肢，有一套独立的反应模式。就算你把它做得再逼真，大脑也不会把它当成真实肢体。
在研究者看来，这其实是个好事。这就意味着，假肢的设计思路可以完全打开，不用跟真实肢体看齐。现在，已经有人设计出了不同样子的假肢。比如，像脊椎构造的触手假肢。有研究者认为，这样的构造也许会更实用。
第二个技术方向是，让假肢具备触觉之类的感官。
比如，2023年11月，北京航空航天大学的团队，在《科学·机器人学》（Science Robotics）期刊上发表一项研究。他们研发了一款柔性电子仿生机械臂，外表像章鱼触手，具备触觉，能感知到外部的物体和温度。
再比如，今年2月，《医学》（Med）杂志发表了一项新研究。研究人员研究出了搭载在假肢上的温度感应设备，叫MiniTouch。过去，假肢患者拿起一杯热水，但假肢感觉不到温度，喝的时候一不小心就可能烫到。MiniTouch正好就能解决类似的问题。据说MiniTouch还能感知皮肤质感。志愿者配戴MiniTouch，蒙眼区分人手和假肢，准确率能从原来的60%提升到80%。
第三个技术思路是，研发给普通人的假肢，目的是拓展身体能力。比如，有个毕业于伦敦皇家艺术学院的研究者，叫达妮·克洛德（Dani Clode），用3D打印技术做了个东西，叫第三只拇指。戴在手上，人就多出一根拇指。这能让人在操作一些器械时，效率更高。根据研究者的试验，这个第三只拇指，只需要5天就能被熟练使用，而且在单手搭积木、单手穿针引线、弹吉他这些任务中，都提高了参与者的效率。
好，刚才咱们说的是，关于假肢的几个新技术思路。可以用一句话概括，这就是，假肢的功能，过去主要是修复残缺。但未来，它也许会成为人类扩展自身能力的方法之一。
最后，总结一下，今天说了两个话题。
第一，幸福生活是由什么决定的？哈佛研究的结论是，复原力与良好的社会关系，是影响幸福最关键的因素。这个结论本身也许不新，但当你再看到类似的道理时，希望你能想起这项研究。这也许能增强内心的信念感。
第二，假肢设计的新思路。假肢正在具备越来越多的能力，它的定位也许会从帮人体修复残缺，发展到帮人类扩展能力。
https://www.dedao.cn/course/article?id=g258WANERjwQJDzE70KbOMG1rZqkPl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef608ddc58da619712ae60ed7e46f565/" rel="bookmark">
			IOT二进制漏洞挖掘小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 这是之前自己挖漏洞的时候自己写着用的一款小工具，主要就是能方便一点，在拿到一个要分析的程序后，能够直接分析下其程序加载的libc，架构，端序等信息，根据自定义的sink找出其程序以及加载的libc中所有的引用查看其再次封装的函数等，需要安装radare2以及r2pipe依赖。
2.代码 Beacon Config XOR KEY1
import argparse``import r2pipe``import subprocess``import json`` ``def get_dynamic_libraries(r2, file_system_path):` `libraries = []` `libs = r2.cmdj('ilj')` `for lib in libs:` `library = get_path_by_filename(lib, file_system_path)` `libraries.append(library)`` ` `return libraries`` ``def get_path_by_filename(filename, file_system_path):` `output = subprocess.check_output(['find', file_system_path, '-name', filename]).decode('utf-8')` `for line in output.split('\n'):` `if line:` `return line`` ``def get_referencing_functions(r2, filename, target_symbols):` `referencing_functions = []`` ` `r2.cmd('aaa') # 执行初始分析` `functions = r2.cmdj('aflj')`` ` `for function in functions:` `function_name = function['name']` `if any(symbol in function_name for symbol in target_symbols):` `refs = r2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef608ddc58da619712ae60ed7e46f565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732da20293033fc0d4b8d2ebbe8bd75b/" rel="bookmark">
			Ubuntu软件开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu软件开发环境搭建 安装VMware Tools网络桥接更新软件源常用功能配置时间同步共享文件夹双向复制粘贴终端初始大小和字体设置安装必要的工具 常用指令 安装VMware Tools 点击虚拟机-&gt;安装VMware Tools…
打开终端，cd到/media/用户名/VMware Tools/下，拷贝VMwareTools-10.3.23-16594550.tar.gz到用户目录下（在原始目录下无法解压，在VMware Tool目录下也无法解压）：
解压：tar -zxvf VMwareTools-10.3.23-16594550.tar.gz，解压完成后，会出现一个名为“vmware-tools-distrib”的文件夹。
进入“vmware-tools-distrib”文件夹，运行“sudo ./vmware-install.pl”文件。
“Do you still want to proceed with this installation?[no]”此时输入yes，后面的全部选择默认即可。
安装完成后，如果遇到“Execution aborted.”错误，可以依次执行命令“rm -rf /etc/vmware-tools”“rm -rf /tmp/vm”和再次运行“./vmware-install.pl”来解决
完成这些步骤后，Ubuntu的界面应该会自动适配VMware的界面，使得操作更加流畅。
网络桥接 点击编辑-&gt;虚拟网络编辑器-&gt;更改设置
点击虚拟机设置，配置网络：
最后在ubuntu中设置IP即可。
更新软件源 Ubuntu自带的软件源速度慢，需要更新成国内的软件源：
在以下链接中选择对应Ubuntu版本的源即可。
阿里源：https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b116rmZ07
清华源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/
163:http://mirrors.163.com/.help/ubuntu.html
这里我选择阿里源（中国官方源），网址下滑可以找到各个ubuntu版本的源。
cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo vi /etc/apt/sources.list deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732da20293033fc0d4b8d2ebbe8bd75b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53acfd85d53be526e8fa7468c43f46f/" rel="bookmark">
			小程序 与 flask继续学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序和flask项目是怎么实现数据交互的？ 小程序和Flask项目都可以通过数据交互来实现前后端的通信。下面我将分别介绍它们的实现方式：
对于小程序，数据交互通常使用微信提供的小程序API进行实现。具体步骤如下：
前端发送请求：小程序前端通过wx.request()方法发送HTTP请求到后端服务器。后端处理请求：后端服务器使用Flask框架接收到请求后，可以通过Flask提供的路由功能进行处理。数据处理与返回：后端服务器根据请求的内容进行相应的数据处理，可以从数据库中获取数据，或者进行其他业务逻辑处理。处理完成后，将结果封装成JSON格式返回给小程序前端。前端接收数据：小程序前端通过回调函数接收到后端返回的数据，并进行相应的展示或处理。 对于Flask项目，数据交互通常使用HTTP协议进行实现。具体步骤如下：
前端发送请求：前端通过浏览器或其他客户端发送HTTP请求到Flask后端服务器。后端处理请求：Flask后端服务器使用路由功能接收到请求后，根据请求的URL和HTTP方法进行相应的处理。数据处理与返回：后端服务器根据请求的内容进行相应的数据处理，可以从数据库中获取数据，或者进行其他业务逻辑处理。处理完成后，将结果封装成JSON格式返回给前端。前端接收数据：前端通过回调函数接收到后端返回的数据，并进行相应的展示或处理。 小程序和flask项目是怎么实现数据交互的？ 小程序和Flask项目都可以通过数据交互来实现前后端的通信。下面我将分别介绍它们的实现方式：
对于小程序，数据交互通常使用微信提供的小程序API进行实现。具体步骤如下：
前端发送请求：小程序前端通过wx.request()方法发送HTTP请求到后端服务器。后端处理请求：后端服务器使用Flask框架接收到请求后，可以通过Flask提供的路由功能进行处理。数据处理与返回：后端服务器根据请求的内容进行相应的数据处理，可以从数据库中获取数据，或者进行其他业务逻辑处理。处理完成后，将结果封装成JSON格式返回给小程序前端。前端接收数据：小程序前端通过回调函数接收到后端返回的数据，并进行相应的展示或处理。 对于Flask项目，数据交互通常使用HTTP协议进行实现。具体步骤如下：
前端发送请求：前端通过浏览器或其他客户端发送HTTP请求到Flask后端服务器。后端处理请求：Flask后端服务器使用路由功能接收到请求后，根据请求的URL和HTTP方法进行相应的处理。数据处理与返回：后端服务器根据请求的内容进行相应的数据处理，可以从数据库中获取数据，或者进行其他业务逻辑处理。处理完成后，将结果封装成JSON格式返回给前端。前端接收数据：前端通过回调函数接收到后端返回的数据，并进行相应的展示或处理。 小程序如何把数据交互给flask项目？ 小程序可以通过网络请求将数据交互给Flask项目。具的步骤如下：
在小程序中，使用wx.request()方法发送HTTP请求，将数据发送给Flask项目的API接口。在Flask项目中，使用Flask框架提供的路由功能，创建一个接收数据的API接口。在该API接口的处理函数中，可以通过request对象获取到小程序发送的数据。对接收到的数据进行处理，可以进行数据验证、存储或其他操作。处理完数据后，可以返回响应给小程序，可以是一个成功或失败的状态码、消息等。 下面是一个简单的示例代码：
在小程序中：
javascript
wx.request({ url: 'https://yourflaskapi.com/data', method: 'POST', data: { key1: value1, key2: value2 }, success: function(res) { console.log(res.data); }, fail: function(error) { console.log(error); } }); 在Flask项目中：
python
from flask import Flask, request app = Flask(__name__) @app.route('/data', methods=['POST']) def receive_data(): data = request.get_json() # 获取小程序发送的JSON数据 # 处理数据... return 'Success' if __name__ == '__main__': app.run() flask项目如何将数据发送给小程序 在Flask项目中，可以使用HTTP请求的方式将数据发送给小程序。以下是一种常见的实现方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b53acfd85d53be526e8fa7468c43f46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4771d118b97799e673ce1b5ee2cce099/" rel="bookmark">
			Kali Linux 2024.1 Release (Micro Mirror) - 领先的渗透测试发行版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kali Linux 2024.1 Release (Micro Mirror) - 领先的渗透测试发行版
The most advanced Penetration Testing Distribution
请访问原文链接：https://sysin.org/blog/kali-linux/，查看最新版。原创作品，转载请保留出处。
作者主页：sysin.org
发布公告 Wednesday, 28 February 2024
Kali Linux 2024.1 Release (Micro Mirror)
Hello 2024! Today we are unveiling Kali Linux 2024.1. As this is our the first release of the year, it does include new visual elements! Along with this we also have some exciting new mirrors to talk about, and of course some package changes - both new tools and upgrades to existing ones.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4771d118b97799e673ce1b5ee2cce099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e794350d3bb9058bf837c6d88a6c9336/" rel="bookmark">
			Python运行报错：SyntaxError: Non-UTF-8 code starting with ‘\xe7‘ in file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个SyntaxError错误表明你的Python文件test.py在第272行包含了一些非UTF-8编码的字符（以\xe7开头），但是你的Python文件没有声明编码。Python 3默认使用UTF-8编码，如果你的源代码文件包含非UTF-8编码的字符，并且没有指定正确的编码，Python解释器就会抛出这个错误。
为了解决这个问题，你需要在你的Python文件的顶部添加一行编码声明。通常，对于包含中文的Python文件，你可能需要使用GBK或者GB2312编码，但这并不是推荐的做法，因为Python社区广泛使用UTF-8编码。如果可能的话，最好将你的源代码文件保存为UTF-8编码。
如果你确实需要将文件保存为GBK或GB2312编码，你可以在文件顶部添加如下声明：
# -*- coding: gbk -*- 或者
# -*- coding: gb2312 -*- 但请注意，这并不是一个好的实践，因为这样的编码声明可能会限制你的代码在其他环境或编辑器中的兼容性。
更好的做法是，将你的源代码文件保存为UTF-8编码，并确保你的文本编辑器或IDE也设置为使用UTF-8编码。大多数现代文本编辑器和IDE都支持UTF-8编码，并且这是Python社区广泛接受的编码标准。
如果你不确定如何更改文件的编码，你可以使用文本编辑器（如Notepad++、Sublime Text、VS Code等）的保存选项，或者使用命令行工具（如在Unix/Linux系统中的iconv命令）来转换文件编码。
总之，推荐的做法是将Python源文件保存为UTF-8编码，并确保在编写代码时使用UTF-8兼容的字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2531659f725e497e01434797370536/" rel="bookmark">
			“两新”融合启动片区住宅项目施工组织设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 编制说明 1
1.1 编制原则 1
1.2编制依据 1
2 工程概况 2
2.1工程规模 2
2.2设计概况 2
2.3工程材料及做法 2
2.3.1墙体工程 2
2.3.2防水设计 2
2.3.3防火设计 3
2.3.4电梯选型 3
2.3.5其它说明 3
2.4结构设计 4
3 施工部署 5
3.1施工机构职能 5
3.2 机构的设置 6
3.3 施工阶段划分 7
3.4工程施工总体部署 7
3.5内部协调 8
4 施工准备 10
4.1 施工技术准备 10
4.1.1做好调查工作 10
4.1.2做好与设计的结合工作 10
4.1.3认真编制施工组织设计 11
4.2 施工现场准备 11
4.3 临建装修做法 12
4.4 劳动力和管理人员准备 13
4.5物资条件准备 13
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2531659f725e497e01434797370536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a08ae4ea1082ced829cad77aa97e92a/" rel="bookmark">
			macOS Monterey 12.7.4 (21H1123) Boot ISO 原版可引导镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macOS Monterey 12.7.4 (21H1123) Boot ISO 原版可引导镜像下载
3 月 8 日凌晨，macOS Sonoma 14.4 发布，同时带来了 macOS Ventru 13.6.5 和 macOS Monterey 12.7.4 安全更新。
本站下载的 macOS 软件包，既可以拖拽到 Applications（应用程序）下直接安装，也可以制作启动 U 盘安装，或者在虚拟机中启动安装。另外也支持在 Windows 和 Linux 中创建可引导介质。
macOS Monterey 12.7.x 如无特殊说明，皆为安全更新，不再赘述。
请访问原文链接：https://sysin.org/blog/macOS-Monterey-boot-iso/，查看最新版。原创作品，转载请保留出处。
作者主页：sysin.org
下载地址更新 这里列出 ISO 启动镜像下载链接，更多格式请访问以下地址：
macOS Monterey 12 正式版 ISO、IPSW、PKG 下载
应用场景 macOS Monterey 12 可启动 ISO 镜像，基于 Apple 原版 App 制作，可以用于虚机安装，可以拖拽到 Applications（应用程序）下直接双击安装，也可以制作启动 U 盘安装。
硬件兼容性列表 MacBook 2016 年初及后续机型 进一步了解 &gt;MacBook Air 2015 年初及后续机型 进一步了解 &gt;MacBook Pro 2015 年初及后续机型 进一步了解 &gt;Mac mini 2014 年末及后续机型 进一步了解 &gt;iMac 2015 年末及后续机型 进一步了解 &gt;iMac Pro 2017 年及后续机型Mac Pro 2013 年末及后续机型 进一步了解 &gt; 如果你的 Mac 不在兼容性列表，参看：在不受支持的 Mac 上安装 macOS Monterey 12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a08ae4ea1082ced829cad77aa97e92a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd1c99114b68fff62260897e761a565/" rel="bookmark">
			宏定义允许嵌套【篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预
处理程序层层代换。
例如：
#define PI 3.1415926
#define S PIyy /* PI 是已定义的宏名*/
对语句：
printf(“%f”,S);
在宏代换后变为：
printf(“%f”,3.1415926yy);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdf462648b356da9ccd5a79f6b78e30/" rel="bookmark">
			宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换【篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define OK 100
main()
{
printf(“OK”);
printf(“\n”);
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>