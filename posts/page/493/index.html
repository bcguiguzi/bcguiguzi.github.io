<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331057feb49e90489815bf242ab0cc61/" rel="bookmark">
			获取字符串中最长的数串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 #题目 输入一段字符串，包含任意的ACII字符串。 输出字符串中长度最长的数字串，如果数字串长度相同，输出其中各个数字和最大的，如果和一样大，输入位置最前的。 如：输入"asdas213+2331-1221sds3321" 输出：2331 #思路 用全局变量来存储最长数串的长度和它的和，然后遇见更大的就替换。 #代码 package test; import java.util.Scanner; public class CharTest { static int Sum = 0; static int Length = 0; public static void main(String agrs[]) { String str = ""; Scanner sc = new Scanner(System.in); str = sc.nextLine(); sc.close(); System.out.println(getMaxNumberString(str)); } public static String getMaxNumberString(String str) { String maxNumberString = ""; int sum = 0; int length = 0; StringBuilder number = new StringBuilder(); for (int i = 0; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/331057feb49e90489815bf242ab0cc61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2750cfe8b76f5469c9e3f0bc81ed70d0/" rel="bookmark">
			Linux下安装配置OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：Installation in Linux
1. 必要的软件包
[compiler] sudo apt-get install build-essential [required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev [optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 2.进入解压后的OpenCV目录 cd ~/opencv mkdir release cd release cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 3.在刚刚生成Makefiles的/release目录下 sudo make sudo make install 运行完毕之后，OpenCV将会被安装到cmake指定的/usr/local下，值得注意的是CMAKE_INSTALL_PREFIX指定的不是源码路径，而是安装路径，源码路径是后面的..（上一级目录，也就是OpenCV的解压目录） Ubuntu12.04安装OpenCV3.0.0可能会遇到make时的一个错误，原因是mpeg视频模块不能被正确编译，好像是系统本身对mpeg的支持跟不上OpenCV3.0，解决办法是到github上下载另外一个被更正的版本：opencv-itseez
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45bc370ef44e97b82a814595b0b4012/" rel="bookmark">
			ThinkPHP笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、判断变量是否为空
&lt;notempty name="teacherInfo.teach_address"&gt; &lt;span style="white-space:pre"&gt;	&lt;/span&gt;&lt;p&gt;&lt;strong class="list-label"&gt;授课地点：&lt;/strong&gt;&lt;span&gt;{$teacherInfo.teach_address}&lt;/span&gt;&lt;/p&gt; &lt;/notempty &gt; 2、判断变量是否定义 &lt;present name="vo.bestSuccess.score_before"&gt; {$vo.bestSuccess.score_before} &lt;else /&gt; 0 &lt;/present&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb03880278280a8fa95b155c70e14b6/" rel="bookmark">
			dyld: Library not loaded: 错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我一个ipadmini 上的系统版本是6.1.2 直接运行崩溃报错
dyld: Library not loaded: /System/Library/Frameworks/GameController.framework/GameController 后面查了资料这个问题得产生是因为引用得一些framework只能存在于高版本得sdk中，但是，如果编译到低版本的ios就会发生这样的问题
这里需要在对应的target下的Build Phases标签里，找到Link Binary With Libraries，在里面找到GameController.framework，把status由Required 修改成Optional，然后再运行就OK了
其他的类似的错误应该都差不多操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccfbc642f9e7e49c38ede068522a512/" rel="bookmark">
			笔试题总结归纳之 腾讯——基础研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 腾讯通篇考察的都是数学知识：概率（居多），数理统计、分布，少量微分 部分题目回忆： a) U检验的应用条件是什么？ b) 求期望E c) 求概率：抽样：重复抽样与不重复抽样平均误差大小关系 共6个球，其中4个新球，抽取两次，每次抽取后放回的情况 d) 简单行列式的计算 e) 特征选择时，协变量对目标变量有较大的影响，有哪些方法？ f) 每次只从聚类人脸中抽取5张，可利用的信息是每个人脸对之间的相似度矩阵G，第k+1次抽样不知道第K次的样本情况，假定可用人脸数量N&gt;50张，如何设计抽样？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005815eeb9862b5f4d92f2816846051f/" rel="bookmark">
			【经验帖】Ubuntu12.04安装cuda6.0以及配置Nsight开发环境教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期需要到Linux下进行CUDA相关的编程，历经装崩系统、各种版本不兼容等等重重困难后，终于写下了这篇博客，防止以后再次入坑。
1. 显卡
用的是台式机，显卡版本较老，是一块GT240，用独显的话，第一次安装Ubuntu系统会出现这样一个问题，当使用U盘启动之后，会出现屏幕花屏的现象，无法弹出安装界面，一开始我以为是Ubuntu版本的问题，发现试了各种版本都是这样，后面网上查了一下才知道，Ubuntu系统在安装显卡驱动之前，在普通模式下是不支持独显显示的，那只有换回集显，拔下独显了呗，果然顺利安装了Ubuntu 12.04。
重启之前，把独显重新插上，此时要注意在启动选项中选recover恢复模式，之后一路默认进入系统，否则普通模式还是花屏。进入系统后发现能正常显示了，只不过没有安装驱动界面丑了点。
如果接下来需要安装CUDA的话，建议不要急着装显卡驱动！！因为CUDA的.run安装程序会装显卡驱动的，如果这个时候装，到时候容易引起驱动版本的冲突，虽然可以在CUDA安装选项中选择无需安装，因为软件应该向下兼容才对，但是亲身经验告诉我，Ubuntu不会意识到本机已有驱动版本比CUDA提供的最低版本要高！
2. 网卡
这个比较容易，我用的无线网卡是TP-Link WDN6200，网上查了下芯片用的是rtl8812au，顺便查到了该芯片的开源驱动程序，github大法好，链接如下：https://github.com/gnab/rtl8812au 下载.zip文件后，解压到自己想要的文件夹下面，进入目录依次执行下面命令，等一会儿就可以看到无线网络图标点亮了
sudo make sudo make install sudo modprobe 8812au 3. CUDA下载
Ctrl+Alt+F1进入单用户模式，再运行如下命令关闭图形界面服务
sudo service lightdm stop 进入CUDA.run文件所在的目录就可以安装了 然而之前的一个问题是，CUDA现在已经更新到7.5了，是不是越新的版本越好呢？从易安装程度上来说，并不是这样的（各个CUDA版本下载）（高手可以无视这一段）。首先都进到每个版本下面看看Linux的Getting Started文件，这个文件里，一定要看系统版本最低要求的一个表格！！先从下面几个在日志文件中的错误说起
1) ERROR: Kernel configuration is invalid. include/generated/autoconf.h or include/config/auto.conf are missing. Run 'make oldconfig &amp;&amp; make prepare' on kernel src to fix it.
错误原因：操作系统内核版本过高，而CUDA安装文件可能是针对老的内核版本而言的，所以会出现autoconf.h或者auto.conf缺失，因为在新的Linux内核版本中，这两个文件目录都已经被移除或者更改了，因此会出现找不到的情况，我试了make oldconfig &amp;&amp; make prepare有错，故放弃。去网上找到了CUDA 5.5的Getting Started文件发现，其内核版本建议是generic 2.6，而在我的Ubuntu下面输入
uname -r 查看内核版本是generic 3.13，故放弃CUDA 5.5，转向CUAD 6.0，这次建议的Ubuntu 12.04内核版本是generic 3.2，更近了一步，抱着不确定的形态试着再次安装，没有报错，成功了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005815eeb9862b5f4d92f2816846051f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c232956e7a2694e8046ba166d16da51b/" rel="bookmark">
			Android studio 获取 数字签名sha1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用百度地图时 会需要 数字签名 android studio 获取签名记录如下
1.android studio 切换到 terminal 如下图：
2.写入路径 （自己电脑路径）
"E:\Java\jdk1.7.0_79\bin\keytool.exe" -list -v -keystore "C:\Users\Administrator\.android\debug.keystore" 复制黏贴就行
3 口令 用 android 或直接 回车 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de342d8a0d86d1af021be397bb61d022/" rel="bookmark">
			哪本书是对程序员最有影响、每个程序员都该阅读的书?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/zhmxy555/article/details/8596225
国外知名网站stackoverflow上有一个问题调查： 哪本书是对程序员最有影响、每个程序员都该阅读的书？，这个调查已历时两年，目前为止吸引了153,432人访问，读者共推荐出了478本书(还在增加)，其中最火的一本书《Code Complete》被顶了1306次。如果你是个程序员，你一定有兴趣看看这些书里你都看过几本，如果你一本没看过的话，我也不好说什么，也许你是个天才，但我相信大多数人都知道，你在学校里根本学不到什么真正的工作中需要的知识，我们毕业后能帮助我们在公司中胜任工作的老师就是这些优秀的书籍，一本好书可以改变一个人的一生。
下面是这个调查中排名靠前的书的一个简单的清单：
第一名：1306票《Code Complete (2nd Ed) by Steve McConnell》，中文版《代码大全（第二版）》,两届Software Jolt Award震撼大奖得主！ 第二名：1161票 《The Pragmatic Programmer》，中文版《程序员修炼之道》 第三名：689票 《Structure and Interpretation of Computer Programs》，中文版《计算机程序的构造和解释》 第四名：557票 《The C Programming Language》，中文版《C程序设计语言》 第五名：472票 《Refactoring: Improving the Design of Existing Code》，中文版《重构：改善既有代码的设计》 第六名：472票 《Introduction to algorithms》，中文版《算法导论》 第七名：430票 《The Mythical Man-Month》，中文版《人月神话》 第八名：426票 《Design Patterns》，中文版《设计模式》 第九名：386票 《The Art of Computer Programming(First Volume Hardcover)》，中文版《计算机程序设计艺术第 （第一卷）》 第10名：353票 《Compilers: Principles, Techniques, and Tools 》，中文版《编译原理》 第11名：329票 《Head-First Design Patterns》，中文版《Head First 设计模式》 当然了，这里的排名并不具有什么权威性，但绝对可以说都是好书，这11本外还有很多书虽然票数不是那么多，但大家估计都耳熟能详，比如《Effective C++》(中文版《Effective C++：改善程序与设计的55个具体做法》)，《Clean Code》(中文版《代码整洁之道》)，《Effective Java》(中文版《Effective Java中文版(第2版)》等 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de342d8a0d86d1af021be397bb61d022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5470d6ea7fc70749c31f230c042fe1/" rel="bookmark">
			CentOS 7 在vmware中的网络设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一环境说明二centos在vmware中的安装三NAT网络设置四设置固定IP 1修改网卡配置说明2修改etcresolvconf 实现域名解析 五设置防火墙iptables 1 centos安装telnet2 防火墙iptables设置 六 总结 前言：由于工作中需要使用Linux，在虚拟机中装了CentOS7，以作实验之用，安装后使用过程中出现不少问题，主要是网络问题，安装后出现下列几种状况： （1）宿主机网络正常，在虚拟机的centos中无法访问外网。 （2）宿主机可以ping通，且可以使用SSH连接，但无法telnet虚拟机centos的端口。 （3）centos 固定IP问题 （4）防火墙设置问题 经过查阅相关资料及实践，才把网络问题解决，在此记录一下。
一、环境说明 vmware workstation 10Linunx系统：CentOS7，官网下载地址 二、centos在vmware中的安装 CentOS7在vmware虚拟机中安装流程不复杂，网上已有很多教程（可参考其中一篇(百度经验上的)），本文不重复，简要作以下说明及注意地方。
使用典型安装，安装程序光盘映像文件按机器实际情况选择CPU、磁盘大小，本机是i7，8g内存，分配了2g，2核给CentOS7。重点： 网络类型有三种可参考此文章，由于不想占用当前已有的IP，选择NAT，以宿主机为路由。安装软件类型可选择最小安装，也可选择文件服务器、基本网页服务器等。建议最小安装，干净。 三、NAT网络设置 使用NAT网络设置，不占用IP资源，设置方法可参考这篇文章，这里作主要几个重要设置点说明： （1）设置虚拟机为NAT网络，右击虚拟机-&gt;设置，如下图： （2）查看VMnet8的网络设置 控制面板-&gt;网络和 Internet-&gt;网络连接，可见vmnet1和vmnet8两个虚拟网卡，查看vmnet8，右击-&gt;属性，查看ipv4地址，可见vmware已自动分配了一个地址。如下： （3）共享网络 实际网卡-&gt;右击-&gt;共享，如下 （3）设置虚拟网络编辑器，编辑-&gt;虚拟网络编辑器，如下： 此处的子网IP与vmnet8网段一致，vmnet8是192.168.31.1，则此处设置为192.168.31.0即可。掩码与vmnet8一致。 另外，“使用本地dhcp服务将IP地址分配给虚拟机”可以先勾选，后面固定IP的时候再取消。 （4）NAT设置 设置后，进入虚拟机，如无意外，是可以正常连接网络了。 （5）查看IP并测试 使用ifconfig进行测试，此处可查看到虚拟的IP，它的IP是dhcp自动分配的。 [root@localhost sysconfig]# ifconfig 在虚拟机ping宿主机IP，测试是否连通： [root@localhost sysconfig]# ping 192.168.31.1 `` 在宿主机ping虚拟机IP，测试是否连通： [root@localhost sysconfig]# ping 192.168.31.128 “ 若能连通，即证明网络设置完成，可以使用SSH连接虚拟机centos了。
四、设置固定IP 按上述方法，虽然可以连通，但由于是使用dhcp动态分配的，每次重启后，可能会变化，因此最好把它设置为固定IP。可以参考此文 以下几点需要注意一下：
VMware虚拟网络编辑器中取消“使用本地DHCP服务将IP地址分配给虚拟机”的勾选。修改/etc/sysconfig/network-scripts/中ifcfg开头的对应的网卡配置。修改/etc/resolv.conf ，添加域名解析。 （1）修改网卡配置说明 注意当前网卡的名称，使用ifconfig可查看到，本机安装后网卡名称是：ifcfg-eno16777736； 打开此文件，主要配置以下几项（无则添加上去）：
ONBOOT=yes 设置为开机后启动 IPADDR=192.168.31.128 #此处设置固定的IP NETMASK=255.255.255.0 #此处设置掩码 GATEWAY=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5470d6ea7fc70749c31f230c042fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd56e24c29f111769c247bde6538859/" rel="bookmark">
			解决XCODE配置LLVM环境出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：在LLVM整合进XCODE的过程中出现符号未定义导致出现未决函数或方法。但使用终端编译链接生成程序没有问题。
问题产生原因：未引用响应的LLVM库与系统库，以及编译器设置、连接器设置不正确。犹豫设置相当繁琐，而且参数众多，正确配置XCODE的LLVM环境较难。
解决方法：利用llvm自带的工具llvm-config生成相应的参数。进入终端，输入echo `llvm-config --cxxflags --ldflags --libs --system-libs`复制结果进build settings下的linking相关的参数 other linker flag即可。注意以上“ ` ”并非单引号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ebb402133ba540205c8e6d407308a8/" rel="bookmark">
			白话空间统计之九：方向分布（标准差椭圆）修正版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章用红色字体标记出来的内容是修正后的内容，感谢四川的杨同学对我以前的错误提出指正。
终于写到我最喜欢的一个的工具（算法）了，方向分布是虾神我接触的第一个空间统计工具，也是每次讲空间统计必须要讲的一个，也是对点数据分析中很有用的一个工具。
点模式的分析中，一般会考察如下五种内容：
1、点的疏密，包括点数据的分布探索，是否一致、均匀或者不均匀。
2、点的方位，包括点的分布和方向。
3、点的数量：多少（极值和均值）。
4、点的大小：代表的含义（如点一个点代表多少人口）。
5、其他，如点的一些动态变化等。
（关于点数据分析的其他详细的内容，请看虾神以前的文章，或者再公众号里面回复“点分析”）
其中，我们前面说的好几种算法，如中心要素、中位数中心和平均中心，都是关于点方位的分析，那么今天我们要讲的这个算法，就是同时对点的方向和分布进行分析的一种经典算法——标准差椭圆。
这算法最早是由美国南加州大学（Universityof Southern California）社会学教授韦尔蒂.利菲弗（D. Welty Lefever）在1926年提出，所以有的书里面，也把这个算法称为Lefever's "Standard DeviationalEllipse"（利菲弗方向性分布）（又到每天的历史起源科普时间……）。
这个算法最大的特点，就如同他的名词一样，是用来度量一组数据的方向和分布的，生成的结果又正如他的别名一样，会输出一个椭圆，如下：
红色的点是伤寒发病的案例，蓝色的河流是长江太湖流域段，从计算的结果来看，发病的数据方向与长江的流向方向基本一致，而范围较大。
从上图，我们基本上就可以看出方向分布工具的主要作用了，它可以识别一组数据的方向以及分布的趋势，并且了解到这份数据是否具有一些特性，至于有哪些特性，我们后面再说。
我们先来看看这个标准差椭圆的生成算法。
其实算法很简单，要画出一个椭圆，虽然比画圆麻烦点，但是也麻烦不了多少，关键的参数如下：
1、确定圆心。
2、确定旋转角度。
3、确定XY轴的长度。
首先是确定圆心，方向分布工具的圆心，直接利用的是算数平均中心来计算椭圆的圆心（算术平均中心请查看我在2015年8月17日写的《空间统计之八：平均中心和中位数中心》一文）
然后就确定椭圆的形式了，公式如下：
其中，Xi和Yi是每个要素的空间位置坐标，X和Y是算数平均中心。
SDEx和SDEy就是计算出来的椭圆的方差，总所周知，椭圆的大小取决于方差大小，长半轴表示最大方差，短半轴表示最小方差，在空间统计上面，用X、Y的方差进行计算，得到长短半轴。
然后确定椭圆的方向，以X轴为准，正北方（12点方向）为0度，顺时针旋转，计算公式如下：
最后确定XY轴的标准差，公式如下：
标准差的作用是确定椭圆的方程，一般椭圆方程如下：
S是置信度的值，可以根据数据量来查询卡方概率表（Table:Chi-Square Probabilities），这个大家有兴趣去百度一下就有了。
把所有的数据都带入到公式中，就很容易的把所有的参数都计算出来，接下去只需要再地图上画出结果就行。
那么这个椭圆揭示了一些什么意义呢？
使用ArcGIS的话，方向分布工具除了生成这样一个椭圆以外，还会给出如下结果：
其中，Shape_Leng和Shape_Area是生成的椭圆的周长和面积，单位与你数据的单位相同，这里我的数据是经纬度的，所以生成的结果只能作为相对参考结果。
CenterX和CenterY表示的是椭圆的中心点。
XstdDist和YStdDist表示的X轴的长度和Y轴的长度。
Rotation表示的是椭圆的方向角度。如下：
结果解读如下：
1、椭圆的长半轴表示的是数据分布的方向，短半轴表示的是数据分布的范围，长短半轴的值差距越大（扁率越大），表示数据的方向性越明显。反之，如果长短半轴越接近，表示方向性越不明显。如果长短半轴完全相等，就等于是一个圆了，圆的话就表示没有任何的方向特征。
2、短半轴表示数据分布的范围，短半轴越短，表示数据呈现的向心力越明显；反之，短半轴越长，表示数据的离散程度越大。同样，如果短半轴与长半轴完全相等了，就表示数据没有任何的分布特征。
3、中心点表示了整个数据的中心位置，一般来说，只要数据的变异程度不是很大的话，这个中心点的位置大约与算数平均数的位置基本上是一致的，至于数据变异是什么情况，请看下面第4点。
4、有的同学会很疑惑，为什么你画的这个椭圆，还有很多的点都在外面，没有把所有的点都包含进去？那么就是就是“标准差椭圆”这个名词里面的“标准差”的含义所在了。
在ArcGIS工具里面（其他的工具也都差不多），提供了“椭圆大小”（Ellipse_Size）这个参数，这个参数表示你生成的椭圆的级别，一共有三个，如下表：
三个级别的椭圆，分别表示了你生成的椭圆，能够包含68%，95%和99%三个级别的数据，我们通过可以指定要表示的标准差数（1、2 或 3）来决定你生成的椭圆包含的数据比例。
当要素具有空间正态分布时（即这些要素在中心处最为密集，而在接近外围时会逐渐变得稀疏），第一级标准差（默认值）范围可将约占总数 68%的输入要素的质心包含在内。第二级标准差范围会将约占总数 95%的要素包含在内，而第三级标准差范围则会覆盖约占总数 99%的要素的质心。
所以，当你选择不同标准差等级的时候，你发现你的中心点的位置也可能不同。
当然，作为空间分析工具，方向分布一样可以进行加权计算，这个计算主要还是与中心点的位置确定以及椭圆标准差等级生成的椭圆大小有关系。
下面我们来通过一个实例来了解方向分布工具的应用：
一共有两年的伤寒病数据，如下，红色的是2000年的，蓝色是2001年的：
使用1个标准差的结果，生成的椭圆如上，具体数据如下：
我们对关键性的两个指标进行对比：
生成面积表示范围，可以发现2000的伤寒病发病情况的范围要大于2001年的，扁率表示他的方向明确性和向心力的程度，2000年生成的椭圆扁率远高于2001年的，说明了2000的伤寒发病情况，比2001年的方向趋势更明显。
2000年生成的椭圆方向与长江的方向基本相相符，所以2000年的伤寒发病源与长江的关系较为密切。而2001年的发病情况虽然方向性并不如2000年的明显，但是长半轴几乎与长江垂直，可以基本确认，2001年伤寒发病源与长江关系不大，但是呈现向内陆爆发的趋势。
方向分布工具在空间统计中是综合能力最突出的工具之一，有着广泛的应用，在我们的分析和数据探索的时候，能够起到非常重大的作用。
最后，列出几个可能的应用：
1、可用来在地图上标示一组犯罪行为的分布趋势，并且能够确定该行为与特定要素（一系列酒吧或餐馆、某条特定街道等）的关系。
2、在地图上标示地下水井样本的特定污染，可以指示毒素的扩散方式，这在部署应急防灾策略时非常有用。
3、对各个物种所在区域的椭圆的大小、形状和重叠部分进行比较可以分析与物种入侵或者隔离相关的深入信息。
4、绘制一段时间内疾病爆发情况的椭圆可用于建立疾病传播的模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a38f80a6b0ff344a1ae0e3e06dbd79/" rel="bookmark">
			Clean Project 作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要作用就是 将项目结构中的 bin 目录中早先编译好的apk，dex ,class等内容删除，然后重新编译生成出这些内容 。
解决的问题就是，有时候你把代码改了，但因为一些未知的原因，工具的自动编译没有成功，导致运行结果不正常。
当你的工程出现一些莫名其妙的错误时（当然不是语法错误）可以用用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18066bfa8c91be3c2e3e0c360b3f6bc0/" rel="bookmark">
			android studio 程序 真机中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 build.gradle 中加入 android{ compileOptions.encoding = "GBK"} 即可
如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acca76e712b7e2899423c286a8302689/" rel="bookmark">
			华为OJ（Redraiment的走法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 题目描述 Redraiment是走梅花桩的高手。Redraiment总是起点不限，从前到后，往高的桩子走，但走的步数最多，不知道为什么？你能替Redraiment研究他最多走的步数吗？ 样例输入
6
2 5 1 5 4 5
样例输出
3
提示
Example: 6个点的高度各为 2 5 1 5 4 5 如从第1格开始走,最多为3步, 2 4 5 从第2格开始走,最多只有1步,5 而从第3格开始走最多有3步,1 4 5 从第5格开始走最多有2步,4 5
所以这个结果是3。
接口说明
方法原型：
int GetResult(int num, int[] pInput, List pResult);
输入参数： int num：整数，表示数组元素的个数（保证有效）。 int[] pInput: 数组，存放输入的数字。
输出参数： List pResult: 保证传入一个空的List，要求把结果放入第一个位置。返回值： 正确返回1，错误返回0
知识点 排序 运行时间限制 10M 内存限制 128 输入 输入多行，先输入数组的个数，再输入相应个数的整数
输出 输出结果
样例输入 6 2 5 1 5 4 5 样例输出 3 这是个求最大递增子序列问题，可以用动态规划解决，和合唱队问题类似，比合唱队问题还简单，稍作修改即可。 #include&lt;iostream&gt; using namespace std; int main() {	int n,maxstep=0; cin&gt;&gt;n; int *step=new int[n+1]; int *height=new int[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;height[i]; step[i]=1; } step[n]=1; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;i;j++) if(height[i]&gt;height[j]&amp;&amp;step[j]+1&gt;step[i]) { step[i]=step[j]+1; if(step[i]&gt;maxstep) maxstep=step[i]; } cout&lt;&lt;maxstep&lt;&lt;endl; //system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acca76e712b7e2899423c286a8302689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c804f7075548b0ae936d3f2917a6f76/" rel="bookmark">
			【ubuntu】【chrome_r197497】编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载 chromium.r197497.tgz
http://chromium-browser-source.commondatastorage.googleapis.com/chromium_tarball.html
2.下载depot_tools
checkout: 0f8a944 - (HEAD) [depot_tools] Allow gclient runhooks to work offline w/safesync_url. (3 years, 1 month ago) &lt;dbeam@chromium.org&gt;
modify:
diff --git a/gclient b/gclient
index bba81cf..254300d 100755
--- a/gclient
+++ b/gclient
@@ -5,6 +5,6 @@
base_dir=$(dirname "$0")
-"$base_dir"/update_depot_tools
+#"$base_dir"/update_depot_tools
PYTHONDONTWRITEBYTECODE=1 exec python "$base_dir/gclient.py" "$@"
add-path: export PATH=$PATH:~/depot_tools;chmod a+x gclient;chmod a+x gclient.py
3.安装dependency
进入chromium/src目录
./build/install-build-deps.sh --[no]chromeos-fonts
4.下载平台工具-toolchain
https://commondatastorage.googleapis.com/nativeclient-archive2/x86_toolchain/r11233/toolchain_linux_x86.tar.bz2
https://commondatastorage.googleapis.com/nativeclient-archive2/toolchain/11233/naclsdk_pnacl_linux_x86.tgz
https://commondatastorage.googleapis.com/nativeclient-archive2/toolchain/11233/naclsdk_pnacl_translator.tgz
https://commondatastorage.googleapis.com/nativeclient-archive2/toolchain/10934/naclsdk_linux_x86.tgz
Index: build/toolchainbinaries.py
===================================================================
--- build/toolchainbinaries.py (revision 11250)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c804f7075548b0ae936d3f2917a6f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b83724f5c5eb083417b130594b3f392/" rel="bookmark">
			自定义Dialog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Android为我们提供了丰富的对话框。实际开发中我们根据需求，往往需要自定义一些好看的Dialog，下面对以三种创建对话框的方式为例，简单对比了他们之间的优缺点。 实现 dialog_edit.xml &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/dialog_bg" android:orientation="vertical" &gt; &lt;TextView android:id="@+id/tv_dialog_set_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" android:gravity="center" android:text="标题" android:textColor="#000000" android:textSize="20sp" /&gt; &lt;EditText android:layout_margin="5dp" android:id="@+id/et_dialog_set_oldpsw" style="@style/NewEditText" android:focusable="true" android:focusableInTouchMode="true" android:inputType="textEmailAddress" android:hint="输入密码" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1sp" android:background="@color/dialog_line" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:padding="20dp" android:id="@+id/btn_dialog_set_cancel" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="left" android:layout_weight="1" android:background="@null" android:text="取消" /&gt; &lt;View android:layout_width="1sp" android:layout_height="match_parent" android:layout_gravity="center" android:background="@color/dialog_line" /&gt; &lt;Button android:padding="20dp" android:id="@+id/btn_dialog_set_ok" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="right" android:layout_weight="1" android:background="@null" android:text="确定" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 方法一：通过AlertDialog的setView方法来创建 AlertDialog dialog = new Builder(context).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b83724f5c5eb083417b130594b3f392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9ffddc835b1fbd96c2a375c6acb450/" rel="bookmark">
			如何让android studio在运行时自带签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前开发百度地图的时候，申请一个key后，直接运行eclipse，便可以获取位置信息。
今天在用android studio做的时候，插上手机，直接真机调试的时候，发现每次总是获取key失败。使用as里面的build-&gt;
﻿﻿ Generate Signed APK可以生成一个apk文件，安装。完美获取位置信息。
总不能每次都这么生成一个文件，然后安装吧？太麻烦了。
解决方案：当然了，你首先得生成一个jks文件，也就是我们eclipse里面的签名文件，不会的百度一下。
①在project structure里面添加一个设置，如图所示
选择你生成的jks文件位置，里面的Key Alias 和密码是你生成jks的时候进行设置的。
然后我们build一下项目。
下面我们打开我们的module里面的build.gradle。
咦？我们发现了什么？里面增加了我们之前设置的信息。对，这就是我们所需要的。
记住我们箭头所指的位置，我们下面还要用到哦~~
当然了，你也可以通过直接在build.gradle里面写这段话（如果你不怕写错的话）。
我们运行一下，为什么还是不行？？？？？因为我们没有设置debug和release时自带签名文件啊！！
下面，我们如下图所示，在android里面添加这段话
buildTypes { release { /* minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'*/ signingConfig signingConfigs.key } debug{ signingConfig signingConfigs.key } } 注意，这里箭头所指的就是我们之前提醒过你要记住的位置。
OK，现在再运行一次，实现了，我们现在直接真机调试也有签名了。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38cee5ed0cf35e27d0d3634ff822465/" rel="bookmark">
			C&#43;&#43;中string和vector用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string 包含头文件：#include&lt;string&gt;
申明命名空间：using std::string ;
1) 初始化
string s1; //Default initialization; s1 is an empty string
string s2(s1); //copy s1 to s2
string s3=s1; //copy s1 to s3
string s4(“value”); //Direct initialization,s4 is a copy ofthe string literal(not including null)
string s5=”value”;//Equivalent to s4
string s6(n, ’c’);//Directly initialize s4 with n copies ofthe character ‘c’. 2) 操作(os—outputstream, is—input stream)
表1 string常用的操作
os&lt;&lt;s
Write s onto the output stream os, Return os
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38cee5ed0cf35e27d0d3634ff822465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f2fea47dd66cc22955c95e967c5bdc/" rel="bookmark">
			编译一个可以运行在openwrt上的c程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：http://aboutchen.org/blog/compile-c-code-for-openwrt/
本文的测试环境为 Ubuntu 14.0 TP-LINK WDR4320 OpenWrt Attitude Adjustment 12.09
首先在ubuntu上安装一些东西
sudo apt-get install libncurses5-dev gawk flex build-essential qemu-user 获取Openwrt的源代码
git clone git://git.openwrt.org/openwrt.git 编译源代码,默认配置即可,不需要勾选什么
cd openwrt make menuconfig 编译,耗时较长,可以忙些别的事情
nice make -j16 一切无错的情况下,会在staging_dir目录下列出三个目录
hosttarget-mips_34kc_uClibc-0.9.33.2toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2 将toolchain加到PATH里面
export STAGING_DIR=/path/to/openwrt/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2 export PATH=$PATH:$STAGING_DIR/bin 编译hello.c
mips-openwrt-linux-gcc hello.c -o hello -static 直接在本机运行的话会报如下错误
shmiluyu@:~/openwrt/src$ ./hello bash: ./hello: cannot execute binary file: 可执行文件格式错误 因为是为MIPS指令架构编译的,所以如果想在本机上运行,可以使用之前安装的QEMU
shmiluyu@:~/openwrt/src$ qemu-mips hello hello openwrt 如果要编译MIPS64架构,只需要编译的时候加个参数
mips-openwrt-linux-gcc hello.c -o hello-mips64 -static -mips64r2 使用file命令可以看下可执行文件的信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f2fea47dd66cc22955c95e967c5bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6f9785b7a838859c78100278bd0f58/" rel="bookmark">
			颜色rgb对应表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://tsuui.is-programmer.com/posts/13037.html 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/492/">«</a>
	<span class="pagination__item pagination__item--current">493/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/494/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>