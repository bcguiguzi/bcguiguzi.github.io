<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3ff05fde22f1dcf5e275c2f51823f2/" rel="bookmark">
			QT-通过控件ObjectName获取控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT-通过控件ObjectName获取控制 示例1.说明解释 示例 1.说明解释 代码如下：
QString strObjectName = QString("lineEditDev5IP"); QLineEdit*pLineEdit = this-&gt;findChild&lt;QLineEdit*&gt;(strObjectName); if (pLineEdit != nullptr) pLineEdit -&gt;setText("reset objectName"); 说明解释：
通过findChild接口和对应控件的objectName来获取指定的控件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a79622f894b747bc66d72b1349b2d0/" rel="bookmark">
			论文复现：Active Learning by QueryingInformative and Representative Examples（QUIRE）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d73bc4e7f4e2c4bca901824b25d9037/" rel="bookmark">
			笔记本连接外接显示器后耳机没有声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 笔记本屏幕小，因此配置了一个大的显示器。有线耳机插在笔记本的音频输入孔里。结果耳机没有声音了。
原因： 进入windows的设置--&gt;声音
声音输出源被设置到外接显示器了。我这里显示的是PR270A（NVIDA High Definition Audio）
解决： 把输出设备改成扬声器（Realtek（R）Audio），这是笔记本自带的。
改了以后，耳机又有声音了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9954eaf97403a8a465454a1603fb00/" rel="bookmark">
			【vivado PG学习】1 PG168：7 Series FPGAs Transceivers官方配置方法学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 概览1.4 不支持的功能 2 产品说明3 用IP核进行设计3.1 通用设计向导3.2 时钟3.3 复位 4 设计流程4.1 生成IP核4.2 约束IP核 5 例程5.3 例程文件结构 介绍：
The 7 series FPGAs Transceivers Wizard LogiCORE™ IP 自动创建配置7系列fpga 收发器的HDL封装。向导可以配置一个或多个支持行业主流标准的高速串行收发器。或者从零开始支持各种自定义协议。
功能：
创建配置7系列fpga 收发器的HDL封装。自动对模拟设置进行配置。预定义了提供Aurora 8B/10B, Aurora 64B/66B, CEI-6G,DisplayPort, Interlaken, Open Base StationArchitecture Initiative (OBSAI), OC192,OC48, SRIO, 10GBASE-R, Common PacketRadio Interface (CPRI), Gigabit Ethernet,10 Gb Attachment Unit Interface (XAUI),RXAUI, and XLAUI, OTU3, 10GH SmallForm-factor Pluggable Plus (SFP+), OpticalTransport Network OTU3, V-by-One, SDI或者其他自定义的协议。 1 概览 关于向导：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9954eaf97403a8a465454a1603fb00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048c11b807bbf0ee454820d683a7341f/" rel="bookmark">
			ArcGIS教程：解决在mxd文件，定义投影之后，数据源还是的投影坐标系还是未发生改变的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过自己做几次试验进行比对。在目录那栏功能改能够有效解决换了一个mxd文件投影坐标仍是之前设置的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76124416c810a5cb5a7fae954fbd77ca/" rel="bookmark">
			vim/gvim插件-verilog autodef-自动生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用gvim插件效果如下
使用效果如下：
总结：
优点：
1.这个使用效果是比emacs的auto_reg和auto_wire是方便且全面的。auto_wire只能定义output的类型生成。
2.这个插件还有AutoInstPortReAlign和AppendPortDirectionToInst等功能不错。通过对齐inst input 和output代码看起来美观。
缺点：
1.需要有一定的格式限制，比如不能写成wire[width-1:0]，要写成assign
2.module的input 和output 没有对齐功能（目前我没发现）
为此自己单独用perl写了一个脚本来对齐
参考另一篇博客：xxxx。
插件参考网址
https://www.vim.org/scripts/script.php?script_id=4067
需要把automatic.vim放在指定的.vim文件夹下
使用需要注意的地方：
1.：AD 即为autodef快捷键
2.如果autoinst的port需要自动化定义，需要前面的always block 块的begin end写完整。否则无法识别（应该是脚本以begin end为识别点）
3.不能使用wire[5:0] data= xxx;写法，autodef会报错。它要识别的是assign语法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25286d2fe451fbcab1a6306396b4865d/" rel="bookmark">
			DHCP协议（或许是最详细的版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天做了很多实验，我的小伙伴们后台私信纷纷都表示烦了想听一些干货，所以今天讲一下一个重要的协议，就是DHCP协议。
目录
DHCP
DHCP作用
DHCP的好处：
DHCP原理：
DHCP租期：
DHCP服务的实现：
情况一：同网段的DHCP
实验过程
测试：
情况二：不同网段的DHCP
实验代码
实验过程
​ 测试：
补充 地址池概念
info 和 error
总结
DHCP DHCP（动态主机配置协议）是一个局域网的网络协议。
指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。 DHCP作用 为客户机分发IP地址、子网掩码、网关、DNS服务器、租期等参数。
DHCP的好处： 1.简化了客户机设置
2.防止用户误操作
3.避免IP地址重复
架构：C/S架构，客户机/服务器架构（C-Client/S-Server）
DHCP服务对应的是UDP协议，因为是C/S架构，所以DHCP服务是分为
客户机占用UDP 67号端口，DHCP服务器占用UDP 68号端口。
DHCP原理： 1.DHCP客户机向局域网中所有DHCP服务器发送DHCPdiscovery请求。（DHCP客户机向DHCP服务器发动DHCP请求，来索要ip）
2.局域网中所有的DHCP服务器都会回复DHCPoffer，为客户机提供IP地址。
3.客户机选择第一台DHCP服务器回复的IP地址，并且要发送DHCPrequest通告给局域网内所有的DHCP服务器，他选择了哪个ip和那个DHCP服务器。
备注：客户机发送DHCPrequest通告的原因有两层。
第一层是通告给所有DHCP服务器，让其他没有被选中的DHCP服务器把未使用的地址进行回收。
第二层是通告被选中的DHCP服务器，确认此地址被DHCP客户机使用。
4.被选中的DHCP服务器收到DHCPrequest消息后，会给DHCP客户机回复一个DHCPack，
确认此ip可被客户机使用。客户机讲此ip与自身MAC绑定，以便下次继续使用，而其他dhcp服务器
将吧分配给该DHCP客户机的ip回收。
DHCP租期： DHCP客户机使用IP地址是有限的。一般DHCP客户机使用DHCP分配得的IP地址到了租期的50%的时候，会主动的向DHCP服务器发出续约请求，DHCP服务器接受到DHCP客户机的续约请求后，DHCP服务器会检查此IP地址有没有别的DHCP客户机抢先占用，如果没有，则续约成功，如果此ip地址有被其他的DHCP客户机占用，那么续约就不成功。此时DHCP客户机将重新发起DHCPdiscovery请求来获取新的地址。
DHCP服务的实现： 情况一：DHCP服务器和DHCP客户机在同一网段
情况一：DHCP服务器和DHCP客户机不在同一网段————DHCP中继，只能由路由器实现。
情况一：同网段的DHCP 方法二更常用，因为方法一更随机一些
同网段： 二层交换机1 []vlan bat 10 20//创建vlan10 20 []int e0/0/1//进入e0/0/1接口 []port link-type access//设置access类型 []port default vlan 10//接口划分vlan 10 []int e0/0/2//进入e0/0/2接口 []port link-type access//设置access类型 []port default vlan 20//接口划分vlan 20 []int g0/0/1//进入g0/0/1接口 []port link-type trunk//设置trunk类型 []port trunk allow-pass vlan all//设置白名单 二层交换机2 []vlan bat 10 20//创建vlan10 20 []int e0/0/1//进入e0/0/1接口 []port link-type access//设置access类型 []port default vlan 10//接口划分vlan 10 []int e0/0/2//进入e0/0/2接口 []port link-type access//设置access类型 []port default vlan 20//接口划分vlan 20 []int g0/0/1//进入g0/0/1接口 []port link-type trunk//设置trunk类型 []port trunk allow-pass vlan all//设置白名单 三层交换机 []dhcp enable//开启DHCP服务 []vlan bat 10 20//创建vlan 10 20 []int g0/0/1//进入g0/0/1接口 []port link-type trunk//设置trunk类型 []port trunk allow-pass vlan all设置白名单 []int g0/0/2//进入g0/0/2接口 []port link-type trunk//设置trunk类型 []port trunk allow-pass vlan all//设置白名单 方法一 接口下分发IP地址 []int vlan 10 //进入vlanif10接口 []ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25286d2fe451fbcab1a6306396b4865d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7619ea90420e201ce4b38382d50cccf2/" rel="bookmark">
			lambdaQuery用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lambdaQuery用法 LambdaQueryWrapper&lt;RiskControlDetails&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(RiskControlDetails::getCustomerCode, customerCode); RiskControlDetails riskControlDetail = riskControlDetailsMapper.selectOne(wrapper); .eq() 相等=
.ne()不相等!=
.ge() 大于等于 &gt;=
.le() 小于等于 &lt;=
.gt() 大于&gt;
.lt() 小于&lt;
QueryWrapper使用lambda表达式拼接一些常用条件的写法： lambdaQuery
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9990db32e94da84a650c3cb1d1d46f/" rel="bookmark">
			【JVM】优化-基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM基础 一、jvm基础1、JDK JRE JVM2、Class File Format3、类加载4、memory Model （JMM）4.1 计算机的存储结构4.2乱序4.3 volatile实现细节 5 对象（后续会补充）5.1 对象创建5.2 对象在内存中的布局 6 JVM Runtime Data Area / JVM Instructions6.1 JVM Stacks6.2 Method Space6.3 Direct Memory6.2常用指令 7 JVM调优7.1 Garbage7.2 如何找到Garbage7.3 GC Algorithms （常见的垃圾回收算法）7.4 JVM内存分代模型（用于分代垃圾回收算法） 8 常用的垃圾回收器Garbage Collector与内存大小关系常见垃圾回收器组合 9 调优9.1 基础概念9.2 案例分析1、入门案例2、arthas 10 垃圾回收的算法10.1 CMS10.2 G110.3 三色标记法 11 日志及参数分析11.1 CMS日志11.2 G1日志分析11.3 GC常用参数11.4 Parallel常用参数11.5 CMS常用参数 12 纤程（协程） 一、jvm基础 1、JDK JRE JVM jdk = jre + development kit
jre = jvm + core lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9990db32e94da84a650c3cb1d1d46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a0a1061dfb1ffa740bdb18a199cd23/" rel="bookmark">
			MQTT与RocketMQ对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的"轻量级"通讯协议，该协议构建于TCP/IP协议上，MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。
对比 MQTTRocketMQ使用背景面向移动端场景，移动端场景一般都具备海量设备，单设备数据较少的特点。因此，MQTT适用于拥有大量在线客户端（很多企业设备端过万，甚至上百万），但每个客户端消息较少的场景。面向服务端的消息引擎，主要用于服务组件之间的解耦、异步通知、削峰填谷等，服务器规模较小（极少企业服务器规模过万），但需要大量的消息处理，吞吐量要求高。因此，消息队列RocketMQ版适用于服务端进行大批量的数据处理和分析的场景。客户端连接数客户端规模庞大，百万甚至千万级。一般服务器规模较小，极少数万级。单客户端消息量单个客户端需要处理的消息少，一般定时收发消息。单个客户端处理消息量大，注重吞吐量。 组合使用实例 秉承单一职责的原则，MQTT在设计上是一个面向移动互联网和IoT领域的，只关心海量移动端设备的接入、管理和消息传输，可与其他消息队列通过数据互通规则实现交互，例如消息队列RocketMQ。
在这种职责划分下，终端设备将消息发送到微消息队列MQTT后，消息会根据微消息队列MQTT创建的规则路由到指定消息队列，云端应用依然可以维持传统的微服务开发方案，通过对接云端存储产品即可和终端设备进行互动，两者之间通过MQTT实现了数据互通能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1993f18204c00cfaf135ece07a36e8/" rel="bookmark">
			内存管理面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		autorelease 对象会在什么时候释放？ 使用@autoreleasepool 会在大括号结束时释放
struct __AtAutoreleasePool { __AtAutoreleasePool() { // 构造函数，在创建结构体的时候调用 atautoreleasepoolobj = objc_autoreleasePoolPush(); } ~__AtAutoreleasePool() { // 析构函数，在结构体销毁的时候调用 objc_autoreleasePoolPop(atautoreleasepoolobj); } void * atautoreleasepoolobj; }; { } 是作用域，
{ } 里会调用构造函数间接的会调objc_autoreleasePoolPush函数：
{ } 外调用 析构函数调用objc_autoreleasePoolPop函数
不使用 @autoreleasepool 这个会由系统自动释放，释放时机是在当前 runloop 结束时释放，因为系统会自动为每个
runloop 执行自动释放池的 push 和 pop 操作
Runloop和Autorelease
iOS在主线程的Runloop中注册了2个Observer
第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()第2个Observer &lt;1&gt; 监听了kCFRunLoopBeforeWaiting事件，会调用
objc_autoreleasePoolPop()、objc_autoreleasePoolPush()&lt;2&gt; 监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop() 什么对象会加入Autoreleasepool中 使用alloc、new、copy、mutableCopy的方法进行初始化时，由系统管理对象，在适当的位置release。使用array会自动将返回值的对象注册到Autoreleasepool。__weak修饰的对象，为了保证在引用时不被废弃，会注册到Autoreleasepool中。id的指针或对象的指针，在没有显示指定时会被注册到Autoleasepool中。 谈谈你对自动释放池的理解 自动释放池是oc提供的一种自动回收的机制，具有延迟释放的特性，即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次runloop结束或者作用域超出{}或者超出[pool release]之后再被释放。
系统就是通过@autoreleasepool {}这种方式来为我们创建自动释放池的，
一个线程对应一个runloop，系统会为每一个runloop隐式的创建一个自动释放池，
所有的autoreleasePool构成一个栈式结构，在每个runloop结束时，
当前栈顶的autoreleasePool会被销毁，而且会对其中的每一个对象做一次release（严格来说，是你对这个对象做了几次autorelease就会做几次release，不一定是一次).
特别指出，使用容器的block版本的枚举器的时候，系统会自动添加一个autoreleasePool
[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { // 这里被一个局部@autoreleasepool包围着 }]; 自动释放池的原理 AutoreleasePoolPage：每一个自动释放池没有单独的结构，每一个autorealeasePool对象都是由若干个autoreleasePoolPage通过双向链表连接而成，类的定义如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1993f18204c00cfaf135ece07a36e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3bcb6457d8a3acad47c56d17131b20/" rel="bookmark">
			linux查看内存条详细信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux查看内存条详细信息
sudo dmidecode -t memory
dmidecode 3.2 Getting SMBIOS data from sysfs.
SMBIOS 3.2.0 present.
Handle 0x000B, DMI type 16, 23 bytes
Physical Memory Array
Location: System Board Or Motherboard
Use: System Memory
Error Correction Type: None
Maximum Capacity: 32 GB
Error Information Handle: Not Provided
Number Of Devices: 2
Handle 0x000C, DMI type 17, 84 bytes
Memory Device
Array Handle: 0x000B
Error Information Handle: Not Provided
Total Width: 64 bits
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3bcb6457d8a3acad47c56d17131b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce70e08674f7cddcb67c81c7f077cdcf/" rel="bookmark">
			卸载亚信的安全杀毒软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载亚信的安全杀毒软件 前提： 根据硬性要求装了亚信的两个杀毒软件，奈何它怎么也卸不掉。 而且管理员密码也不知道，哎😔
卸载提示要输入管理员密码，无人可知
简单粗暴的方法就是重装系统，yyds，干干净净。更好的办法，修改电脑注册表： 修改电脑注册表，来卸载亚信软件 Windows键+R打开“运行”，输入regedit，打开注册表，
依次点击：
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node/TrendMicro/PC-illinNTcorp/CurrentVersion/Misc 右侧找到Allow Uninstall双击打开后将其数值数据由0改为1，点击确定
进入设置-应用，对亚信进行卸载，等待几分钟即可完成。
再次卸载，看着进度条再走，应该没问题🤭
5.进度条走完了，也就卸载完成，弹出来了框：提示手动删除文件夹Asiainfo Security OfficeScan
6.自己找下电脑上这个文件（Asiainfo Security OfficeScan）存在那，一般默认装在C盘，全盘搜索下好了。找到后删掉就完全卸载成功了。
PS：我的找到在这里( •̀ ω •́ )✧
以上亲测有效，O(∩_∩)O
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af3bff25d804f1faf0214c714835396/" rel="bookmark">
			The left-hand side of an assignment expression may not be an optional property access. 报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		typescript中遇到这种报错表示左边的表达式不能判断是否有值再赋值, 解决方法有两种
第一种
if (proxy &amp;&amp; proxy.proxy &amp;&amp; proxy.proxy.$i18n &amp;&amp; proxy.proxy.$i18n.locale) { proxy.proxy.$i18n.locale = val.key; } 可以使用if把所有空值排除, 再执行赋值操作
第二种
proxy!.proxy!.$i18n!.locale = val.key; 使用类型断言, 把null 和 undefined的值都排除掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891bc28948c7b56db6ca061219c86855/" rel="bookmark">
			BUUCTF 逆向工程(reverse)之SimpleRev
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用IDA打开，进入到Decry函数
unsigned __int64 Decry() { char v1; // [rsp+Fh] [rbp-51h] int v2; // [rsp+10h] [rbp-50h] int v3; // [rsp+14h] [rbp-4Ch] int i; // [rsp+18h] [rbp-48h] int v5; // [rsp+1Ch] [rbp-44h] char src[8]; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] int v8; // [rsp+30h] [rbp-30h] __int64 v9; // [rsp+40h] [rbp-20h] __int64 v10; // [rsp+48h] [rbp-18h] int v11; // [rsp+50h] [rbp-10h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); *(_QWORD *)src = 'SLCDN'; v7 = 0LL; v8 = 0; v9 = 'wodah'; v10 = 0LL; v11 = 0; text = (char *)join(key3, &amp;v9); strcpy(key, key1); strcat(key, src); v2 = 0; v3 = 0; getchar(); v5 = strlen(key); for ( i = 0; i &lt; v5; ++i ) { if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 ) key[i] = key[v3 % v5] + 32; ++v3; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891bc28948c7b56db6ca061219c86855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15bc4a4af45bf07653cc8b596885136/" rel="bookmark">
			什么是取整？有几种取整方式？C语言又是哪种方式？取模取余一样吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道取整这回事，但是对于取整只有单一的认识，请看下面代码。 int main() { int j = -2.9; int i = 2.9; printf("%d\n", j); printf("%d\n", i); return 0; } 看这串代码我们先不管数据溢出的问题，直接看最后的结果等于 什么
大家都知道最后结果会是-2.9变成-2，2.9变成2.
但是为什么会这样呢？我相信比较多人是不知道的
是因为一共有四种取整方式
第一种取整模式：向0取整
我们C语言默认是向0取整所以才等于这个结果
向0取整的意思是：只要你不是整数就把余数抹掉，变成整数。不是我们理解的四舍五入。
C语言里面有一个函数是和向0取整是一样作用，trunc函数。看代码
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;math.h&gt;//使用trunc这个函数要调用这个库函数 int main() { int j = -2.9; int i = 2.9; printf("%d\n", (int)trunc(j));//因为trunc这个函数返回的是浮点数，所以要强转成int printf("%d\n", (int)trunc(i)); return 0; } 如图所示，是一摸一样的。
第二种取整模式：负无穷取整，floor取整
负无穷取整的意思是：只要是负数有余数就进一位，正数和向0取整一样
代码验证
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;math.h&gt;//使用trunc这个函数要调用这个库函数 int main() { printf("%lf\n",floor(-2.1)); printf("%lf\n",floor(-2.9)); printf("%lf\n", floor(2.1)); printf("%lf\n", floor(2.9)); return 0; } 因为是负无穷取整-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e15bc4a4af45bf07653cc8b596885136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697bc04a3771e80aefefeab2313318b1/" rel="bookmark">
			python读取csv文件路径正确但报错FileNotFoundError: [Errno 2] No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： python读取csv文件路径正确但报错FileNotFoundError: [Errno 2] No such file or directory
问题描述： #储存调用表格、数据 #调用函数的形式 #pd.read_???读取文件 #pd.to_???存取文件 import pandas as pd data = pd.read_csv('stu.csv') print(data) data.to_pickle('student.pickle') 原因分析： 1.把EXCEL输出为csv方便读取
2.注意VScode左侧的区域，一定要把文件名这些对应起来
最重要的是要在同一个目录下面！
解决方案： # 题外话： #建议CSDN搜索：朝阳医院数据
给个链接：
链接: 非常赞的一个实战例子！！.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef957a1c7390193d78b70b0294f84060/" rel="bookmark">
			EI会议列表--IEEE主办的会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想发表EI会议，到哪里去找征稿通知？
其实各大出版集团有很多支持的EI检索会议，每年都要成千上万个会议。
以下是工科的 IEEE出版集团每年的会议列表，可以根据时间顺序，按照征稿通知和主题来选择和撰写投稿。
网址：Conferences Search (ieee.org)
https://conferences.ieee.org/conferences_events/conferences/search?q=*&amp;subsequent_q=&amp;date=all&amp;from=&amp;to=&amp;region=all&amp;country=all&amp;pos=69&amp;sortorder=asc&amp;sponsor=&amp;sponsor_type=all&amp;state=all&amp;field_of_interest=all&amp;sortfield=dates&amp;searchmode=basic&amp;virtualConfReadOnly=N
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9636e1211aee4bce80690b272b1a6895/" rel="bookmark">
			spring ioc源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOC 是 spring 中最最最最核心的部分。
IOC 即控制反转，就是说资源不由使用资源的双方管理，而由不使用资源的第三方（IOC容器）管理。对象不再由使用者来创建（比如 new）和管理。
它主要有两个好处：
资源集中管理，实现资源的可配置和易管理降低使用双方的依赖程度，也就是解耦 IOC 容器的最顶层接口是 BeanFactory，也就是说，只要实现了 BeanFactory 接口的类(比如ApplicationContext)，都可以看做是 ioc 容器！最常见的有 AbstractApplicationContext、DefaultListableBeanFactory 等等。源码中但凡看到 xxxApplicationContext、xxxBeanFactory 的，都是 ioc 容器。
本文将详细讲解 bean 的实例化、初始化的源码，以及 spring 解决 bean 的循环依赖的问题的源码
首先我们看一张 spring ioc 的大致流程图：
大致流程说明：
加载 bean 定义信息（BeanDefinition），来源可能是 XML、注解等等通过 BeanFactoryPostProcessor 对 BeanDefinition 做一些事情实例化 bean 对象在 bean 初始化前，通过 BeanPostProcessor 对 bean 对象做一些事情初始化 bean 对象在 bean 初始化后，通过 BeanPostProcessor 对 bean 对象做一些事情 以 springboot 启动为例，它会创建一个 ioc 容器，并实例化 bean ，由容器来管理。
bean 的实例化 在上一篇文章《spring ioc源码讲解之加载BeanDefinition》中，已经详细讲了 BeanDefinition 是如何加载的。本文详细讲解 ioc 源码中的其它部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9636e1211aee4bce80690b272b1a6895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54f33b9206c3b0c84ed8d2346182dd2/" rel="bookmark">
			SSH 详解（实践及应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.SSH 基本知识
2.SSH 客户端
2.1 安装
2.2 基本用法
2.3 命令行配置项
2.4 配置文件
3 SSH 密钥
3.1 密钥生成
3.2 公钥上传
4 SSH 代理
4.1 动态转发
4.2 本地转发
4.3 远程转发
4.4 实际运用
5 SCP命令
5.1 本地复制到远程
5.2 远程复制到本地
5.3 两个远程系统间的复制
6 Rsync 命令 6.1 安装
6.2 基本用法
6.3 远程同步
本地同步到远程服务器
远程服务器同步到本地
7 SFTP 命令
1.SSH 基本知识 Secure Shell （安全外壳协议，简称 SSH ）是一种加密的 网络传输协议 ，可在不安全的网络中为网络服务提供安全的传输环境 。
2.SSH 客户端 2.1 安装 OpenSSH 的客户端是二进制程序 ssh。它在 Linux/Unix 系统的位置是/usr/local/bin/ssh，Windows 系统的位置是\Program Files\OpenSSH\bin\ssh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f54f33b9206c3b0c84ed8d2346182dd2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/292/">«</a>
	<span class="pagination__item pagination__item--current">293/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/294/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>