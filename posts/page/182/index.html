<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e762e6390f33f013735f12fafa28f027/" rel="bookmark">
			《动手学深度学习》笔记一 ------机器学习中的基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：本文按照书中的脉络做的笔记，包含概念的定义、自己的理解以及阅读时的小思考。感受：深度学习很奥妙，很有趣！ 1.2机器学习中的关键组件 可以⽤来学习的数据（data）；如何转换数据的模型（model）；⼀个⽬标函数（objective function），⽤来量化模型的有效性； 当任务在试图预测数值时，最常⻅的损失函数是平⽅误差（squared error），即预测值与实际值之差的平⽅。 当试图解决分类问题时，最常⻅的⽬标函数是最⼩化错误率，即预测与实际情况不符的样本⽐例。
。有些⽬标 函数（如平⽅误差）很容易被优化，有些⽬标（如错误率）由于不可微性或其他复杂性难以直接优化。在这 些情况下，通常会优化替代⽬标。
可⽤数据集通常可以分成两部分：训练数据集⽤于拟合模型参数，测试数据集⽤于评估拟合的模型。
调整模型参数以优化⽬标函数的算法（algorithm）。 深度学习中，⼤多流⾏的优化算法通常基于⼀种基本⽅法‒梯度下降（gradient descent）。简⽽⾔之，在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进⾏少量变动，训 练集损失会朝哪个⽅向移动。然后，它在可以减少损失的⽅向上优化参数。
1.3各种机器学习问题 监督学习 擅长在“给定输入特征”的情况下预测标签，相当于，在给定一组特定的可用数据（相当于特征）的情况下，估计未知事物的概率（事情的结果，相当于是标签）。
（我的理解：监督学习就是，根据给出的特征和标签，学会二者之间如何从特征映射到标签）
监督学习的学习过程一般可以分为三大步骤：
1、从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；
2、选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；
3、将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。
（1）回归
回归问题的模型，由输出决定。当标签取任意数值时，我们称之为回归问题，此时的目标是生成一个模型，使它的预测非常接近实际标签值。总而言之，判断回归问题的一个很好的经验法则是，任何有关“有多少”的问题很可能就是回归问题。eg:这个手术需要多少小时.
(我的理解：相当于是y=k x+b中，已知x,y,求解k,b。就是在几个变量的已知函数关系的情况下求解变量，这个变量不一定是系数k,b，也可能是x或者y。)、
（2）分类
1）区别：回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。
2）分类问题的常见损失函数被称为交叉熵（cross-entropy）（后面会讲）
3）分类包括：二项分类、多项分类、层次分类（eg:动物的科目类别（猫科、犬科），可能存在相关性，这种不同类的结构叫层析结构）
层次结构相关性可能取决于模型的使用者计划如何使用模型。 例如，响尾蛇和乌梢蛇血缘上可能很接近，但如果把响尾蛇误认为是乌梢蛇可能会是致命的。 因为响尾蛇是有毒的，而乌梢蛇是无毒的。
4）标记问题
给问题贴标签
学习预测不相互排斥的类别的问题称为多标签分类（比如，在一张动物图片中识别出所有的动物）
5）搜索
最重要的是，将搜索的结果根据问题的相关性进行排序
6）推荐系统（recommender system）
它的目标是向特定用户进行“个性化”推荐
7）序列学习
就是根据连续的一段信息，通过学习，获得可能的后续信息。
序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。
应用：机器翻译（eg:根据输入的顺序得到合理的翻译语句）
2、无监督学习 数据中不含有“目标”的机器学习问题通常被为无监督学习（unsupervised learning）
可解决的问题：
A.聚类问题（没有标签的情况下，将有相似特征的东西归为一类）
B.主成分分析（eg：裁缝通过确定人的某些参数来裁定衣服的大小(比如人的臂长，身高等)）
C.因果关系和概率图模型（根据经验数据发现给出数据之间的关系）
D.生成对抗网络（提供一种合成数据的方法，潜在的统计机制是检查真实和虚假数据是否相同的测试）
3、环境交互 上述的两种学习方式，是事先取数据，启动模型后就不在与环境交互，是离线学习。
4、强化学习 即智能体（agent）在一系列的时间步骤上与环境交互。
在每个特定时间点，智能体从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后智能体从环境中获得奖励（reward）
（我的理解：在已有模型的基础上，执行自己的动作后，将观测到的环境变化与内部的“激励”传回到智能体中进行下一步的动作）
假设我们有一个分类问题，可以创建一个强化学习智能体，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予智能体的奖励。 这个奖励与原始监督学习问题的损失函数是一致的。
（插个题外话，这句话我有点喜欢，有种内心被点化的感觉。强化学习智能体必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。）
当环境可被完全观察到时，强化学习问题被称为马尔可夫决策过程（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为上下文赌博机（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的多臂赌博机（multi-armed bandit problem）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e762e6390f33f013735f12fafa28f027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff8c9b7cc354fa5e23cffcbb8262a0e/" rel="bookmark">
			SQL连续问题思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL处理连续问题 我们在刷SQL题时，有时候会遇到求连续天数或者连续座位等问题，其实连续的问题没有想象中那么困难，这里我总结了一下通用的连续问题解法
构造一列自增列通过自增列与目标列进行差值运算将差值分组，每一组都是单独的一组连续数据根据需求对分组后的数据进行处理 常见的有group_concat函数和find_in_set函数结合使用拿到所有连续数据的完整信息使用max等聚合函数对数据进行处理 以leetcode 1225.报告系统状态的连续日期为例
Table: Failed
+--------------+---------+ | Column Name | Type | +--------------+---------+ | fail_date | date | +--------------+---------+ 该表主键为 fail_date。 该表包含失败任务的天数. Table: Succeeded
+--------------+---------+ | Column Name | Type | +--------------+---------+ | success_date | date | +--------------+---------+ 该表主键为 success_date。 该表包含成功任务的天数. 系统 每天 运行一个任务。每个任务都独立于先前的任务。任务的状态可以是失败或是成功。
编写一个 SQL 查询 2019-01-01 到 2019-12-31 期间任务连续同状态 period_state 的起止日期（start_date 和 end_date）。即如果任务失败了，就是失败状态的起止日期，如果任务成功了，就是成功状态的起止日期。
最后结果按照起始日期 start_date 排序
查询结果样例如下所示:
Failed table: +-------------------+ | fail_date | +-------------------+ | 2018-12-28 | | 2018-12-29 | | 2019-01-04 | | 2019-01-05 | +-------------------+ Succeeded table: +-------------------+ | success_date | +-------------------+ | 2018-12-30 | | 2018-12-31 | | 2019-01-01 | | 2019-01-02 | | 2019-01-03 | | 2019-01-06 | +-------------------+ Result table: +--------------+--------------+--------------+ | period_state | start_date | end_date | +--------------+--------------+--------------+ | succeeded | 2019-01-01 | 2019-01-03 | | failed | 2019-01-04 | 2019-01-05 | | succeeded | 2019-01-06 | 2019-01-06 | +--------------+--------------+--------------+ 结果忽略了 2018 年的记录，因为我们只关心从 2019-01-01 到 2019-12-31 的记录 从 2019-01-01 到 2019-01-03 所有任务成功，系统状态为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff8c9b7cc354fa5e23cffcbb8262a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0a7a1d90ab4239a0ccc6a3ab921e6e/" rel="bookmark">
			【青训营】Go的一些性能优化技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Slice切片的性能优化 对Slice进行内存预分配 尽可能在使用make()初始化函数的时候提供容量信息，因为切片本质是一个数组片段的描述，其源码如下：
type slice struct{ array unsafe.Pointer len int// 长度 cap int// 容量 } 如果没有指定容量，那么可能会使得slice进行扩容操作，扩容操作会耗费额外时间。因此最好在初始化时指定好容量
大内存释放陷阱 我试图组织语言结果发现自己说不明白，还是直接看别人的吧
https://blog.csdn.net/QiuHaoqian/article/details/108996719
也就是要对切片进行切片的话，最好使用copy函数吧
二、Map的性能优化 Map的预分配内存 // 无预分配内存 func NoPreAlloc(size int){ data := make(map[int]int) for i:=0; i&lt;size; i++{ data[i]=1 } } // 带预分配内存 func PreAlloc(size int) { data := make(map[int]int, size) for i := 0; i &lt; size; i++ { data[i] = 1 } } 无预分配内存的话也会导致go对map进行扩容操作，这些操作十分耗费时间，并且需要数次请求内存分配。提前分配好空间你可以减少内存拷贝和rehash消耗
三、字符串的处理 使用strings.Builder拼接字符串 字符串拼接是十分敞开的呢操作，但是使用常规的str=str1+str2的性能十分堪忧。可以使用strings.Builder进行优化。使用案例如下：
func StrBuilder(n int, str string) string { var builder strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0a7a1d90ab4239a0ccc6a3ab921e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00d631023ca80f282199b810d9767bd/" rel="bookmark">
			【寒假训练/Java】递推专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目链接题目列表快输A - 小乐乐走台阶B - 滑雪（DFS）C - [NOIP2005]采药（01背包）D - [NOIP2002]过河卒E - [NOIP2006]金明的预算方案(01背包)F - [NOIP2006]开心的金明(01背包)G - 石子合并(区间DP)H - 没有上司的舞会(DFS)I - [NOIP2004]合唱队形(最长上升子序列LIS)J - 牛可乐和最长公共子序列K - [NOIP2008]传纸条L - 费解的开关(位运算/模拟) 题目链接 递推专题-牛客链接
比赛密码：202301272000
题目列表 快输 import java.io.*; import java.util.*; public class Main { public static void main(String[] args) { out.flush(); } static class FastReader{ BufferedReader br; StringTokenizer st; String tmp; public FastReader() { br=new BufferedReader(new InputStreamReader(System.in)); } String next() { while(st==null||!st.hasMoreElements()) { try { st=new StringTokenizer(br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00d631023ca80f282199b810d9767bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdbd57d17a8d947ff73157a6f3d44ac3/" rel="bookmark">
			了解基础的docker容器化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是docker容器？
docker容器简单说来就是码头工具。
docker是一个开源的的应用容器引擎，docker的图标是一个鲸鱼上有很多集装箱，docker就是鲸鱼，他上面的集装箱就代表各个容器，docker容器在目前的环境中大部分公司docker容器已经代替了vm虚拟化，docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口，开销很低。docker解决了服务器昂贵的问题，生产环境和测试环境不一致的问题。
二：vm和docker的区别
docker的优点
( 1 ) docker体积小，占用资源少，一般为MB。
( 2 )启动速度快，docker是容器，也是进程，容器进程启动速度比vm虚拟机快，启动几乎是秒级。
( 3 )docker容器时接近原生的，所以性能比较好。
( 4 )docker可以实现弹性、负载、动态的高可用策略。
vm的缺点
( 1 )vm体积大，占用资源也比较大，一般为GB。
( 2 )启动速度慢，vm是操作系统，所以启动比docker容器慢，一般都是分钟级。
( 3 )vm虚拟机并不是接近原生的，所以性能比docker容器差。
( 4 )vm可以实现备份、灾容、迁移等高可用策略。
三：docker的基本概念
docker的核心组件
docker的基本组成是由镜像（image）、容器（container）、仓库（repository）构成。
( 1 )docker镜像：
鲸鱼背上拖着的所有集装箱就是一个镜像
docker镜像是一个只读模板，基于创建Docker容器，类似于虚拟机镜像，可以将它理解为一个面向Docker 引擎的只读模板，包含了文件系统，镜像是创建 Docker 容器的基础。
( 2 )Docker容器：
是一个镜像的运行实例。容器由镜像创建，类似于一个轻量级的沙箱，Docker 利用容器来运行和隔离应用。容器是从镜像的应用运行实例，可以将其启动，开始，停止，删除，而这些容器都是相互隔离，互不可见的。镜像自 身是只读的，容器从镜像启动的时候， Docker 会在镜像的最上层创建一个可写层，镜像本身保持 不变。
( 3 )Docker 仓库：
Docker仓库是Docker镜像库，类似于代码仓库，是docker 集中存放镜像文件的场所。
四：docker容器的状态
docker容器一共有四种状态：运行、已暂停、重新启动、已退出。
五：docker常见的命令
docker start docker //启动docker docker restart docker //重启docker docker stop dokcer //关闭docker docker status docker //查看docker的运行状态 docker version或docker info //查看docker版本号信息 docker --help //帮助命令 dokcer镜像命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdbd57d17a8d947ff73157a6f3d44ac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a1726104f1a293d6e5cd50f6fe4d8b/" rel="bookmark">
			matlab复现论文中的曲线图（坐标存入excal，然后导入matlab画图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先找到你想复现的曲线图，然后运行以下代码，在运行之前先将曲线图的路径改好。
比如我要复现这张图：
clc,clear; disp('提示：命令行窗口键入：ctrl+c，表示停止运行 '); im=imread('1.jpg');%读入图片(替换成需要提取曲线的图片) im=rgb2gray(im);%灰度变化 thresh = graythresh(im);%二值化阈值 thresh=thresh+0.2;%有时候thresh的值偏低，可以手动调节提高一点，这里就提高了 im=im2bw(im,thresh);%二值化 set(0,'defaultfigurecolor','w');%设置MATLAB中figure的背景为白色 disp('请在Figrure中先后点击图片窗口,先左下取一点，然后右上取一点,用于裁剪掉坐标轴的信息 '); input('理解OK了之后输入''1''即可开始'); imshow(im)%显示图片 [NY,NX]=size(im);%获取图片像素矩阵的大小 [XX,YY]=ginput(2);%——获取图片剪裁的地方，消除坐标轴，先左下取一点，然后右上取一点 %把数据转换为整型 XX=int32(XX) YY=int32(YY) %消除坐标轴，让其变成白色 for i=1:1:XX(1) im(:,i)=1; end for i=XX(2):1:NX im(:,i)=1; end for i=1:1:YY(2) im(i,:)=1; end for i=YY(1):1:NY im(i,:)=1; end imshow(im)%显示图片 pause(1);%暂停一下，看看裁剪效果 close();%可以了，不看了 [y,x]=find(im==0);%找出图形中的“黑点”的坐标。该坐标是一维数据。 %坐标转换,变换成正常坐标轴 length_y=length(y); for i=1:1:length_y y(i)=NY-y(i); end min_x=input('坐标轴最小的x值');%输入x轴最小值 max_x=input('坐标轴最大的x值');%输入x轴最大值 min_y=input('坐标轴最小的y值');%输入y轴最小值 max_y=input('坐标轴最大的y值');%输入y轴最大值 %实际坐标转化 x=x*(max_x-min_x)/NX+min_x; y=y*(max_y-min_y)/NY+min_y; plot(x,y,'r.','Markersize', 2);%绘制最终坐标图 if exist('DATA.xlsx','file')%判断存储数据的文件是不是存在，存在就删掉 delete('DATA.xlsx'); end DATA=[x y];%横纵坐标数据整合 xlswrite('DATA.xlsx', DATA);%导出到excel disp('坐标数据已经保存到DATA.xlsx中了，赶紧去看看吧 '); 点击运行后，输入1按回车，开始选取要复现的曲线部分（十字光标选取两个点，左下和右上。如下图），注意不要选中边框和坐标轴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a1726104f1a293d6e5cd50f6fe4d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07eb1ed9bfbf48fabcbe988dbe366609/" rel="bookmark">
			arduino中BLEuart修改MTU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：用arduino操作esp32s3，使用ble的notify来发送一些数据，原计划直接发送较大数据包（207Bytes），奈何arduino端报错“notify maximum size 20”，四处寻找代码修改方案，寻找未果。
解决方法：
BLE的DTU默认大小23。但根据ble协议，可以根据client端的请求进行修改。因此，只需在client端申请将MTU改为250，即可满足我的需求了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd5451653ca39980c72df1d7cc0c38a/" rel="bookmark">
			C&#43;&#43;11 并发指南七(C&#43;&#43;11 内存模型一：介绍)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++11 并发指南七(C++11 内存模型一：介绍) 文章目录 C++11 并发指南七(C++11 内存模型一：介绍) 第六章主要介绍了 C++11 中的原子类型及其相关的API，原子类型的大多数 API 都需要程序员提供一个 std::memory_order（可译为内存序，访存顺序） 的枚举类型值作为参数，比如：atomic_store，atomic_load，atomic_exchange，atomic_compare_exchange 等 API 的最后一个形参为 std::memory_order order，默认值是 std::memory_order_seq_cst（顺序一致性）。那么究竟什么是 std::memory_order 呢，为了解答这个问题，我们先来讨论 C++11 的内存模型。
一般来讲，内存模型可分为静态内存模型和动态内存模型，静态内存模型主要涉及类的对象在内存中是如何存放的，即从结构(structural)方面来看一个对象在内存中的布局，以一个简单的例子为例（截图参考《C++ Concurrency In Action》 P105 ）：
上面是一个简单的 C++ 类(又称POD: Plain Old Data，它没有虚函数，没有继承)，它在内存中的布局如图右边所示（对于复杂类对象的内存布局，请参考《深度探索C++对象模型》一书）。
动态内存模型可理解为存储一致性模型，主要是从行为(behavioral)方面来看多个线程对同一个对象同时(读写)操作时(concurrency)所做的约束，动态内存模型理解起来稍微复杂一些，涉及了内存，Cache，CPU 各个层次的交互，尤其是在共享存储系统中，为了保证程序执行的正确性，就需要对访存事件施加严格的限制。
文献中常见的存储一致性模型包括顺序一致性模型，处理器一致性模型，弱一致性模型，释放一致性模型，急切更新释放一致性模型、懒惰更新释放一致性模型，域一致性模型以及单项一致性模型。不同的存储一致性模型对访存事件次序的限制不同，因而对程序员的要求和所得到的的性能也不一样。存储一致性模型对访存事件次序施加的限制越弱，我们就越有利于提高程序的性能，但编程实现上更困难。
顺序一致性模型由 Lamport 于 1979 年提出。顺序一致性模型最好理解但代价太大，原文指出：
… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd5451653ca39980c72df1d7cc0c38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1457bb34935e0692df578a2a2841d447/" rel="bookmark">
			Vue学习-修改ref对象中的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设父组件有个对象：
var m = ref({ msg:"msg", msg2:"msg2" }) 这时候我们想修改里面msg属性的值，有两种方法：
方法1：整个对象更改
// 方式1 m.value = { msg:"改动了，哈哈", msg2:"msg2" } 方法2：只更改某个属性值
// 方式2 m.value['msg'] = '更改了，哈哈' 我们观察两种方式，核心在于要访问对象的value。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6534b22f04217c165378c207130bde46/" rel="bookmark">
			[Python]pip install pygame安装报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install pygame报错提示：
Microsoft Windows [版本 10.0.17763.3165] (c) 2018 Microsoft Corporation。保留所有权利。 C:\Users\xxxxxxx&gt;pip install pygame Collecting pygame Using cached pygame-2.1.2.tar.gz (10.1 MB) Preparing metadata (setup.py) ... error error: subprocess-exited-with-error × python setup.py egg_info did not run successfully. │ exit code: 1 ╰─&gt; [77 lines of output] WARNING, No "Setup" File Exists, Running "buildconfig/config.py" Using WINDOWS configuration... Traceback (most recent call last): File "&lt;string&gt;", line 2, in &lt;module&gt; File "&lt;pip-setuptools-caller&gt;", line 34, in &lt;module&gt; File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6534b22f04217c165378c207130bde46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65861ed09d5e375c234eed3ca045c07d/" rel="bookmark">
			ModuleNotFoundError: No module named ‘d2lzh‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如图 解决办法： 你看你这个项目的路径是’D:\下载\d2l-zh-1.1’，所以添加项目路径到sys.path里面去，就完事儿啦！
import sys sys.path.append('D:\下载\d2l-zh-1.1') 有用请点赞哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83487a2bebad70fb2d038a7271ce4897/" rel="bookmark">
			蓝桥杯-车的放置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
包含一个正整数n
输出格式
一个整数，表示放置车的方法数
样例输入
2
样例输出
7
数据规模和约定
n&lt;=8
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
思路： 这是一个典型的回溯问题，棋盘问题，说得再具体点，就是类N皇后问题，此类问题没什么说的，直接采用回溯模板求出所有可能的情况，求出result的个数即可，这是典型的错误思路，因为题目中说到：放棋子是一种情况，不放棋子也是一种情况，所以必须考虑到所有棋盘位置都不放棋子和第一行不放棋子或者第二行不放棋子等情况，所以在写代码时可以放弃result,直接用变量ans记录放棋子的次数，放一次棋子，ans就+1，而ans的初始值为1，表示所有棋盘位置都不放棋子，这里与常规回溯算法中单层逻辑搜索不同，这里需要考虑第row行不放棋子时的可能情况，所以在第row行的横向for循环之后应该考虑else情况，即第row行不放棋子，也要向row+1行递归
n=int(input()) class Solution: def __init__(self): self.ans=1 def solve(self,n): row=0 board=[["."]*n for i in range(n)] self.backtracking(board,row,n) return self.ans def backtracking(self,board,row,n): if row==n: return for col in range(n): if board[row][col]!=".": continue if self.is_Valid(board,row,col): board[row][col]="Q" self.ans+=1 self.backtracking(board,row+1,n) board[row][col]="." else: self.backtracking(board,row+1,n) def is_Valid(self,board,row,col): for i in range(n): if board[i][col]=="Q": return False return True s=Solution() print(s.solve(n)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d1900542a1237f74209d5f4b5a6d3b/" rel="bookmark">
			VRRP负载分担实验及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验拓扑 最终实现的目标是实现网关的冗余，去往3.3.3.3时PC1走AR1，PC2走AR2 。
设备配置 AR1：
[Huawei-GigabitEthernet0/0/0]ospf
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]display this //实现AR1，AR2，AR3之间的互通
area 0.0.0.0
network 1.1.1.1 0.0.0.0
network 13.1.1.0 0.0.0.255
network 192.168.1.0 0.0.0.255
[Huawei]int g0/0/0
[Huawei-GigabitEthernet0/0/0]display this
interface GigabitEthernet0/0/0
ip address 192.168.1.10 255.255.255.0
vrrp vrid 1 virtual-ip 192.168.1.100 //设置VRRP组1，虚拟地址是192.168.1.100，作为第一个虚拟网关地址
vrrp vrid 2 virtual-ip 192.168.1.200 //设置VRRP组2，虚拟地址是192.168.1.200，作为第二个虚拟网关地址
AR2：
[Huawei]ospf
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]display this
area 0.0.0.0
network 2.2.2.2 0.0.0.0
network 23.1.1.0 0.0.0.255
network 192.168.1.0 0.0.0.255
[Huawei]int g0/0/0
[Huawei-GigabitEthernet0/0/0]display this
interface GigabitEthernet0/0/0
ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d1900542a1237f74209d5f4b5a6d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6735fe0a761d0be7b60579fed00a13e5/" rel="bookmark">
			Docker安装教程（看这篇就够了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker安装教程 一.CentOS安装Docker1.卸载（可选）2.安装docker3.启动docker4.配置镜像加速 二.CentOS7安装DockerCompose1.下载2.修改文件权限3.Base自动补全命令： 三.Docker镜像仓库1.简化版镜像仓库2.带有图形化界面版本3.配置Docker信任地址 Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。
Docker CE 分为 stable test 和 nightly 三个更新频道。
官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。
一.CentOS安装Docker Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。
1.卸载（可选） 如果之前安装过旧版本的Docker，可以使用下面命令卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 2.安装docker 首先需要大家虚拟机联网，安装yum工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6735fe0a761d0be7b60579fed00a13e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91686e39be698784f1e5f824a059a53/" rel="bookmark">
			Vue学习-环境搭建及项目创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 环境搭建 1）安装node.js
2）IDE使用Vscode
3）Edge浏览器中安装Vue.js devtools
2. 项目创建 1）命令行中执行以下命令（会给出一堆Yes/No的选项，如果创建的是最基本的Vue项目，就全选No）
npm init vue@latest 2）进入创建的项目的文件夹，执行命令：
npm install 3）运行项目的模板代码
npm run dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522ec14fb2f54188752babe99cb6b16c/" rel="bookmark">
			用python画一个需要烟花生日快乐林作龙站满整个电脑屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我可以给你一个示例代码来绘制一个烟花动画，但是要注意，这需要使用第三方库 "pygame" 。
import pygame import random # 初始化 pygame pygame.init() # 设置窗口大小 size = (700, 500) screen = pygame.display.set_mode(size) # 设置标题 pygame.display.set_caption("烟花动画") # 定义颜色 white = (255, 255, 255) # 设置结束条件 done = False # 开始游戏主循环 while not 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef81b63d257e5db947435cc6b1784e3/" rel="bookmark">
			原生javascript 模拟enter事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟enter事件
let event = document.createEvent('Event'); event.initEvent('keyup', true, false); event = Object.assign(event, { ctrlKey: false, metaKey: false, altKey: false, which: 13, keyCode: 13, key: 'Enter', code: 'Enter' }) input.dispatchEvent(event); //let input = document.querySelector("input"); 引用: https://juejin.cn/post/6844904128305430541
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca525501b43beae15f01ad16ab6cf02e/" rel="bookmark">
			Pygame中可能出现的安装问题（在Spyder使用中发现的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本人想在Spyder中import pygame，昨天在安装pygame出现以下问题：Pygame显示安装成功，但在Spyder中import pygame仍然报错：No module named 'pygame'
初始安装做法：（1)win+R 打开运行对话框输入cmd再确定 （2）输入pip install pygame就可以安装了，显示安装成功后在Spyder中import pygame 报错 更改安装做法：打开 anaconda Powershell Prompt输入pip install pygame显示安装成功之后就不会报错了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18ea79427adb894684dace73e89d954/" rel="bookmark">
			iproute2工具集使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. iproute2工具集介绍 iproute2是一组集成了网络配置指令ip的开源软件包，ip指令功能齐全，可以配置和查看网络接口（link），网络接口的地址（address），ARP（neighbour），路由（route），路由策略数据库（rule），隧道（tunnel）等等。ip命令非常强大，用于网络开发的一把利器，是时候放弃ifconfig命令了。
二. ip命令格式介绍 1. ip命令的一般格式：
ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS] ]
OPTIONS：
-V，-Version ：打印iproute2工具集的版本号
-s，-stats，-statistics ：输出更多的信息
-f，-family { inet，inet6，link } ：强制使用哪个协议族
-4 ： -family inet 的缩写
-6 ： -family inet6 的缩写
-0 ： -family link 的缩写
-o，-oneline ： 以单行的形式输出查询结果，原来的换行符用 "\" 替代。
OBJECT：
link ： 物理或者逻辑网络接口
address ：网络设备的协议（IPv4和IPv6）地址
neighbour ： ARP条目相关
route ： 路由表条目
rule ： 路由策略数据库规则
tunnel ： 给予IP的隧道
COMMAND：
add，delete，show（list）
三. ip命令详细介绍 1. ip link - 网络设备配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18ea79427adb894684dace73e89d954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8456f88e67eb07ca60bf1043b2edc6da/" rel="bookmark">
			【Simulink】使用Model Explorer设置模块变量初值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 最近在学习滑模控制，看到b站上的视频和文章，打算自己照着做一遍：
1、滑模控制的基本原理
实际仿真中却遇到了一个小问题，不知道怎么设置变量x1的初值（不能用pulse generator给初始脉冲）
这里的x1是经过积分器模块后输出的。
可以看到，如果没有特地设置x1的初值，默认是0，波形图如下：
设置方法 （Matlab2019b）
菜单栏中的 MODELING -&gt; Model Explorer ，可以看到模块变量：
根据需要，选择 Integrator2 ，设置 Initial condition ，最后点 Apply :
运行查看波形：
可以看到变量x1的初始值为5，则设置成功。
当然，也可以通过 matlab 写入变量初值。
参考：使用 Model Explorer 编辑和管理工作区变量
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/183/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>