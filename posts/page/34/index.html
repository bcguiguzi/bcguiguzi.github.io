<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2b36a376ed1ad1a8f34b1d464490b9/" rel="bookmark">
			数据结构·复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 时间复杂度
2 大O渐进表示法
举例子（计算时间复杂度为多少）
3 空间复杂度
前言：复杂度分为时间复杂度和空间复杂度，两者是不同维度的，所以比较不会放在一起比较，但是时间复杂度和空间复杂度是用来衡量一个算法是否好坏的标准，时间复杂度用来描述算法运行的时间快慢，空间复杂度用来衡量一个算法所需要的额外空间。最初的计算机时代计算机的存储量很小，所以额外注重空间复杂度，随着发展，计算机的存储已经不是让人担心的点了，所以更为注重时间复杂度。
1 时间复杂度 时间复杂度的定义上可以认为使劲按复杂度是一个函数，定量的描述了算法所需要的时间，但是理论上来说，运行的时间是要上机测试才能测试出来的，实际测试就会花很多时间，所以有了时间复杂度这个分析方式分析算法中执行的基本操作的次数，认定为时间复杂度。
int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { //测试语句 } } for (int i = 0; i &lt; N; i++) { //测试语句 } int M = 10; while (M--) { //测试语句 } return 0; } 这段代码的时间复杂度是？
两个嵌套的for循环，也就是执行了N^2次，再来一个for循环，执行次数为N，最后while收尾，执行次数为10,所以时间复杂度的函数为F(N) = N^2 + N + 10，随着N的增大，式子的值会大到无法想象 ，这都得益于N^2，那么整个式子的决定性因素是N^2，所以我们就认为时间复杂度是N^2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2b36a376ed1ad1a8f34b1d464490b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f069f3a47b76cfebdb8c6574e7dd00d/" rel="bookmark">
			让生活更加精致的APP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		晚上好，今天博主来介绍几款帮助你条理生活的APP，让你的生活更加精致，充满仪式感。
一．格志日记 一款以“格子”的方式记录日记的APP，非常简单明了，用户可以依据自己的喜好，来自由定义或者删除格子的数量，来记录当天发生的各种事情、以及自己的心情等。除了软件自带的模板之外，用户还可以自定义一系列模板，来系统地记录日记。不过需要说明的是，普通用户最多只能同时拥有一本日记本哦，如果想要两个及以上的日记本，则需要开通VIP才行。
​二．小篝火tell 一款分享“心事”的软件，也可以把它理解为针对心理问题定制的一款知乎。诚如其名，在这个平台里面，大家如同围聚在篝火旁，一起讨论自己的心事。与知乎、贴吧、微博等平台不同的是，tell虽然支持每个用户都能发表自己言论，但是审核过程特别严格，因此该平台不像同类的其他软件那样有很重的戾气。每个陌生人都不应该被忽视，友善地对待每一个用户的心声，是这款软件的代名词。
​
​
三．滴答清单 一款功能强大的便签软件。通过简易的编辑，即可设置重复项，方便整理诸多待定事项的完成与否。
四．岁岁 同样是一款日记类软件，不够这款软件记录的并非具体事项，而是某一刻的具体心情。每当你感到郁闷、喜悦，亦或愤怒与惊叹，不妨打开这个APP，记录当下，之后每每翻阅，都是一番别样的回忆。
好了，今天的推送就到这里，下期不见不散！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ae9e937119b535b5ff85f3d39ac9ed/" rel="bookmark">
			es 查询案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述： 有这样一种场景，比如我们想搜索
title：Brown fox
body：Brown fox
文章索引中有两条数据，兔子和狐狸两条数据
PUT /blogs/_bulk {"index": {"_id": 1}} {"title": "Quick brown rabbits", "body": "Brown rabbits are commonly seen."} {"index": {"_id": 2}} {"title": "Keeping pets healthy", "body": "My quick brown fox eats rabbits on a regular basis."} 结果肯定是想要数据二，狐狸优先展示
但是，然后搜索的时候，会对搜素词 Brown fox 进行分词，导致数据一优先级更高
可以看下结果：
优先展示的是兔子，有 0.8 的算分，而狐狸只有 0.7 的算分
GET /blogs/_search { "query": { "bool": { "should": [ {"match": { "title": "Brown fox" }}, {"match": { "body": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ae9e937119b535b5ff85f3d39ac9ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4e4fe8c5fcc6f8ac94675518b8bac5/" rel="bookmark">
			python中的四大内置容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器： 是一种可以存放多个元素的数据类型
补充变量无法存储大量数据的缺陷
python提供的容器
列表，集合，元组，字典
列表--list 线性表（常见线性表-数组 栈 链表 队列）---基于链表的数据结构实现的
注意：python没有数组
python中的列表是基于链表（双向链表）实现的
从0开始
全局函数len(容器)----返回容器的长度
&gt;&gt;&gt; list=[1,2,3,4] &gt;&gt;&gt; list [1, 2, 3, 4] &gt;&gt;&gt; list(0) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'list' object is not callable &gt;&gt;&gt; list[0] 1 &gt;&gt;&gt; list[-1] 4 &gt;&gt;&gt; list[-2] &gt;&gt;&gt; len(list) 4 常见方法：'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse'
append----向列表尾部添加元素
&gt;&gt;&gt; ls=[1,2,3,4,5]
&gt;&gt;&gt; ls.append(6)
&gt;&gt;&gt; ls
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4e4fe8c5fcc6f8ac94675518b8bac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5616169d98aba7c5dc98153686c3a2e/" rel="bookmark">
			LoadBalancer负载均衡服务调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LoadBalancer负载均衡服务调用 1、Ribbon目前也进入维护 ​ Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。
​ 简单的说，Ribbon是Netflix发布的开源项目，主要功能是**提供客户端的软件负载均衡算法和服务调用。**Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。
​ 官网：https://github.com/Netflix/ribbon
​ Ribbon未来替换方案就是spring-cloud-loadbalancer
2、spring-cloud-loadbalancer概述 官网地址：Client-Side Load-Balancing with Spring Cloud LoadBalancer Dynamically select correct instance for the request
2.1、LB（Load Balancer）负载均衡是什么？ ​ 简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用），常见的负载均衡有软件Nginx，LVS，硬件 F5等。
​ spring-cloud-starter-loadbalancer组件是什么?
​ Spring Cloud LoadBalancer是由SpringCloud官方提供的一个开源的、简单易用的客户端负载均衡器，它包含在SpringCloud-commons中用它来替换了以前的Ribbon组件。相比较于Ribbon，SpringCloud LoadBalancer不仅能够支持RestTemplate，还支持WebClient（WeClient是Spring Web Flux中提供的功能，可以实现响应式异步请求）
​ 客户端负载和服务器端负载有什么区别？
​ loadbalancer本地负载均衡客户端 VS Nginx服务端负载均衡区别
Nginx是服务器端的负载均衡，客户端发过来的所有请求都会交给nginx，然后由nginx实现请求转发，即为负载均衡是由服务端实现的；loadbalancer是本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息的服务列表，然后缓存到JVM本地，从而实现本地RPC远程服务调用技术； 3、负载均衡演示案例 3.1、8002搭建 ​ 我们把8001的所有内容全部复制一下放新模块中8002，我们只需要修改application.yml中的端口改成8002就好了。
​ 目录结构
​ 然后启动两个服务，应该都不会报错的
​ 然后我们再启动Consul，我的Consul已经做了持久化处理，开机自启，看到Consul两个服务注册进来就可以了。
​ 由于Consul设置了持久化，原来的key/value也都还在。
​ 现在分别访问一下8001和8002
​ 基本的两个服务提供者都有了，下面开始配置一下消费者80，实现负载均衡访问服务。
3.2、消费者80 ​ 订单80模块修改POM并注册进consul，新增LoadBalancer组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5616169d98aba7c5dc98153686c3a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819383b41556575bcc166131c23a6a1c/" rel="bookmark">
			用Docker Compose实现负载均衡【入门篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将讨论如何使用Docker Compose管理多个容器，并实现负载均衡。
首先，让我们简要介绍一下Docker Compose。Docker Compose是一个用于定义和运行多个Docker容器的工具，通过一个单独的文件来描述应用程序的整个服务架构。使用Docker Compose，我们可以轻松地启动、停止和管理多个容器，而无需手动运行一系列Docker命令。
要实现负载均衡，我们通常会使用一个负载均衡器来将流量分发到多个后端服务器上。在Docker环境中，我们可以使用Docker Compose来定义和运行负载均衡器和多个后端服务器容器。以下是一个简单的示例：
version: '3' services: load_balancer: image: nginx ports: - "80:80" links: - backend1 - backend2 backend1: image: myapp # 配置后端服务器1的相关参数 backend2: image: myapp # 配置后端服务器2的相关参数 在这个示例中，我们定义了一个名为"load_balancer"的负载均衡器容器，它使用Nginx镜像，并将流量分发到两个后端服务器容器"backend1"和"backend2"上。通过links属性，我们可以确保负载均衡器可以与后端服务器容器进行通信。
当我们运行docker-compose up命令时，Docker Compose将会启动这三个容器，并根据我们在docker-compose.yml文件中定义的规则进行配置。这样，我们就实现了一个简单的负载均衡器架构，可以将流量分发到多个后端服务器上。
除了简单的负载均衡器架构之外，我们还可以使用Docker Compose结合其他工具和技术来实现更复杂的负载均衡方案，例如使用Docker Swarm来管理多个主机上的容器，并实现跨主机的负载均衡。
总的来说，使用Docker Compose管理多个容器，并实现负载均衡是一项非常有用的技能，可以帮助我们更有效地管理和扩展我们的应用程序。通过结合Docker Compose和其他工具和技术，我们可以构建出强大而灵活的容器化架构，为我们的应用程序提供更好的性能和可靠性。希望本文能够帮助您更好地理解如何使用Docker Compose实现负载均衡！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e541331ad7461dafc7784a963b7589/" rel="bookmark">
			uView Collapse 折叠面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过折叠面板收纳内容区域
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基本使用 &lt;template&gt; &lt;u-collapse @change="change" @close="close" @open="open" &gt; &lt;u-collapse-item title="文档指南" name="Docs guide" &gt; &lt;text class="u-collapse-content"&gt;涵盖uniapp各个方面，给开发者方向指导和设计理念，让您茅塞顿开，一马平川&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;u-collapse-item title="组件全面" name="Variety components" &gt; &lt;text class="u-collapse-content"&gt;众多组件覆盖开发过程的各个需求，组件功能丰富，多端兼容。让您快速集成，开箱即用&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;u-collapse-item title="众多利器" name="Numerous tools" &gt; &lt;text class="u-collapse-content"&gt;众多的贴心小工具，是您开发过程中召之即来的利器，让您飞镖在手，百步穿杨&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;/u-collapse&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { open(e) { // console.log('open', e) }, close(e) { // console.log('close', e) }, change(e) { // console.log('change', e) } } } &lt;/script&gt; copy
#控制面板的初始状态，以及是否可以操作 设置u-collapse-item的name参数，并在u-collapse中指定数组value可以让面板初始化时为打开状态如果设置u-collapse-item的disabled参数，那么面板会保持被禁用状态 &lt;template&gt; &lt;u-collapse :value="['2']" &gt; &lt;u-collapse-item title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e541331ad7461dafc7784a963b7589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b5f3c7d478422996bdb58a240fa9b3/" rel="bookmark">
			DIY可视化整合MQTT生成UniApp源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DIY可视化整合MQTT生成UniApp源码
MQTT协议是什么？
MQTT（Message Queuing Telemetry Transport）是一种轻量级的、基于发布/订阅模式的通信协议，专门设计用于在低带宽、不稳定的网络环境下进行物联网设备之间的通信。具有以下特点（优势）：
轻量级：MQTT 协议设计简单，通信开销小，适合在资源受限的设备上使用，如传感器、嵌入式设备等。发布/订阅模式：MQTT 使用发布/订阅模式，消息的发送者称为发布者（Publisher），消息的接收者称为订阅者（Subscriber），发布者和订阅者之间通过消息代理（Broker）进行通信。可靠性：MQTT 协议支持消息的 QoS（Quality of Service）等级，包括至多一次、至少一次和仅一次，可以根据需求选择适当的 QoS 级别来确保消息的可靠传输。连接保持：MQTT 客户端可以保持与消息代理的长连接，即使在网络不稳定或断开的情况下，客户端也可以重新连接并恢复通信。适应性：MQTT 可以在 TCP/IP、TLS/SSL、WebSocket 等多种网络协议上进行通信，便于在不同的网络环境中使用。支持保留消息：MQTT支持保留消息，使得新的订阅者可以立即获取到最新消息。跨平台：MQTT是跨平台的，可以在各种设备和操作系统上使用。 MQTT协议定义了三种角色：
发布者（Publisher）：发布消息到MQTT代理（Broker）。订阅者（Subscriber）：从MQTT代理接收消息。代理（Broker）：负责接收发布者发送的消息，并按照订阅者的订阅主题进行消息转发。MQTT协议通常与各种编程语言和框架都有良好的支持，使得开发者能够轻松地在各种应用场景中实现MQTT通信。 总而言之，MQTT 协议由于其轻量级、灵活性和可靠性，被广泛应用于物联网设备、传感器网络、移动设备等场景，是物联网通信的重要协议之一。
安装步骤
下载
URL: https://www.emqx.io/zh/downloads?os=Windows
History URL: https://www.emqx.com/zh/downloads/broker
当前下载的是 emqx-5.3.0-windows-amd64.zip
安装
无需安装，解压 emqx-5.3.0-windows-amd64.zip 后即可使用
运行
假设 emqx-5.3.0-windows-amd64.zip 解压到以下目录：
D:\work\mqtt\emqx-5.3.2-windows-amd64
打开 CMD 窗口
运行以下命令，以下结果说明服务运行正常：
Microsoft Windows [版本 10.0.19045.3570]
(c) Microsoft Corporation。保留所有权利。
D:\work\mqtt\emqx-5.3.2-windows-amd64\bin&gt;emqx start
EMQX_NODE__DB_ROLE [node.role]: core
EMQX_NODE__DB_BACKEND [node.db_backend]: mnesia
D:\work\mqtt\emqx-5.3.2-windows-amd64&gt;cd bin
D:\work\mqtt\emqx-5.3.2-windows-amd64\bin&gt;emqx_ctl status
Node 'emqx@127.0.0.1' 5.3.0 is started 访问 Web 端控制台：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b5f3c7d478422996bdb58a240fa9b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4d3f3b25e866bdf5967e716cf3008c/" rel="bookmark">
			pytest生成allure的报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要下载安装配置allure
allure serve ./outputs/allure_report
可以生成html的文件自动在默认浏览器中打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2328a5e2dd37f39d0568e5c3a266a6/" rel="bookmark">
			Python网络基础爬虫-python基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 逻辑语句if,else,elifforwhile异常处理 函数与类defpassclass 逻辑语句 熟悉C/C++语言的人们可能很希望Python提供switch语句，但Python中并没有这个关键词，也没有这个语句结构。但是可以通过if-elif-elif-…这样的结构代替，或者使用字典实现。比如：
这段代码实现的功能是，输入一个运算符，再输入两个数字，返回其计算的结果。比如输入“+12”，输出“3”。这里需要说明的是，input()是读取屏幕输入的方法（在python2中常用的raw_input()不是一个好选择），lambda关键字代表了Python中的匿名函数。
if,else,elif 与很多其他语言一样，Python也有自己的条件语句和循环语句。不过Python中的这些表示程序结构的语句并不需要用括（比如“{}”）括起来，而是以一个冒号作为结尾，以缩进作为语句块。if,else,elif关键词是条件选择语句的关键：
|
Python中的循环语句主要是两种，一种的标志是关键词for，一种的标志是关键词while。Python中的for接受可迭代对象（例如list或迭代器）作为其参数，每次迭代其中一个元素：
for 【提示】如果想要输出列表中的索引和对应的元素，除了上面这样的方法之外，还有更符合Python风格的用法，如enumerate方法等
while while循环的形式如下：
语句while_suit_codes会被连续不断地循环执行，直到表达式的值为False,接着Python会执行下一句代码。在for循环和while循环中，我们也会使用到break和continue关键字，分别代表终止循环和跳过当下循环开始下一次循环：
说到循环，就不能不提列表解析（或者翻译为“列表推导”），在形式上，是将循环和条件判断放在了列表的“[]”初始化中。举个例子，构造一个包含10以内所有奇数的列表，使用for循环添加元素：
使用列表解析：
这种“推导”（解析）也适用于字典和集合。这里我们没有说“元组”，是因为元组的括号（圆括号）表示推导时会被Python识别为生成器，关于生成器的具体概念，可以见本书6.1.2节。一般如果需要快速构建一个元组，可以选择先进行列表推导，再使用“tuple()”将列表“冻结”为元组：
异常处理 Python中的异常处理也比较简单，核心语句是try…except…结构，可能触发异常产生的代码会放到try语句块里，而处理异常的代码会在except语句块里实现：
异常处理语句也可以写得非常灵活，比如同时处理多个异常：
有时候，在异常处理中我们会使用finally语句，而在finally语句下的代码块不论异常是否触发都将会被执行：
函数与类 def 在Python中，声明和定义函数使用def（代表“define”）语句，在缩进块中编写函数体，函数的返回值用return语句返回：
如果没有显式的return语句，函数会自动return None。另外，我们也可以使函数一次返回多个值，实质上是一个元组：
pass 对于我们暂时不想实现的函数，可以使用“pass”作为占位符，否则Python会对缩进的代码块报错：
pass也可用于其他地方，比如if 和 for循环：
在函数中可以设置默认参数：
当有说个默认参数时会自动按照顺序逐个传入，我们也可以在调用时指定参数名：
class 在Python中类使用“class”关键字定义：
定义好类后，就可以根据类创建出一个实例。在类中的函数一般称为方法，简单地说，方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问或操作实例中的数据。【提示】Python中的方法有实例方法、类方法、静态方法之分，这部分是Python面向对象编程中的一个重点概念。但是这里为了简化说明，统一称之为“方法”或者“函数”。
类是Python编程的核心概念之一，这主要是因为“Python中的一切都是对象”，一个类可以写的非常复杂，下面的代码就是requests模块中Request类及其__init__()方法（部分代码）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0de755130ca2caa79b0520d94e78fb/" rel="bookmark">
			探索性数据分析EDA的数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，数据可视化是探索性数据分析的重要组成部分，因为它有助于分析和可视化数据，以获得对数据分布、变量之间的关系和潜在异常值的启示性见解。Python具有丰富的库，可以快速高效地创建可视化。
在Python中，通常使用以下几种类型的可视化进行探索性数据分析：柱状图（用于显示不同类别之间的比较）、折线图（用于显示随时间或不同类别的趋势）、饼图（用于显示不同类别的比例或百分比）、直方图（用于显示单个变量的分布）、热图（用于显示不同变量之间的相关性）、散点图（用于显示两个连续变量之间的关系）、箱线图（用于显示变量的分布并识别异常值）。
1. 理解业务问题
心血管疾病是全球死亡的主要原因。根据世界卫生组织的数据，每年约有1,790万人死于心脏病。其中85%的死亡是由心脏病发作和中风引起的。本文中将探索来自Kaggle的心脏病数据集，并使用Python创建用于探索性数据分析的数据可视化。
该数据集包含有关患者的数据，包括年龄、性别、血压、胆固醇水平以及是否患有心脏病发作等各种变量。该数据集的目标是根据患者的医疗属性预测其是否有心脏病发作的风险。
2.导入必要的库
# import libraries import pandas as pd import numpy as np # data visualization import matplotlib.pyplot as plt import seaborn as sns import plotly.express as px import plotly.graph_objects as go from plotly.subplots import make_subplots 3. 加载数据集
将数据加载到一个Pandas DataFrame中，并开始探索它。
heart = pd.read_csv('heart.csv') 现在已经加载数据，看一下DataFrame的前几行，以了解数据的大致情况。
heart.head() 可以看到数据集包含14列，包括目标列（输出），该列指示患者是否患有心脏病发作，现在开始创建可视化图表。
4. 数据清理和预处理
数据清理的目的是准备好数据进行分析和可视化。
# 检查是否存在任何空值 heart.isnull().sum().sort_values(ascending=False).head(11) 正如我们在这里看到的，这种情况下没有缺失值。 # 检查重复值 heart.duplicated().sum() # 删除重复值 heart.drop_duplicates(keep='first', inplace=True) 5. 统计摘要
# 获取数据集的统计摘要 heart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0de755130ca2caa79b0520d94e78fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b957c4ce29503c43c236b83b56287a/" rel="bookmark">
			.NET REST API的数据驱动本地化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍 NuGet包
文化——本地化基础
文化Provider
数据本地化
本地化扩展方法
Product本地化
Blazor客户端应用程序
本地化数据的关系持久性
本地化表
本地化列
Entity Framework代码优先本地化
Dapper本地化
下载最新的存储库存档下载本地副本 介绍 由于云的高度自动化，软件模型和数据变得越来越动态。让我们以一家在线水果店为例，该商店在多个国家/地区销售其产品。新产品由用户以不同的语言输入。
使用本地化模型数据设计REST API时，必须考虑以下注意事项
需要支持哪些语言？哪些数据需要本地化（文本、数字、图像等）？管理本地化对象需要哪些端点？哪些端点将提供本地化数据？如何在关系数据库系统中管理本地化数据？ 可扩展的REST API将信息分离为可翻译和可读的数据。模型数据管理终结点包含所有本地化数据。在在线商店终结点中，数据以特定语言提供。这样可以节省资源，并且通常可以确保并非所有信息都以所有语言分发。
除了数据本地化之外，对于依赖区域性设置来转换数字、货币和日期数据的REST API来说，以下注意事项也很重要。
REST API产品本地化：
REST客户端标识可用的区域性。产品以多种语言捕获和提交。REST客户端以查询字符串、HTTP请求标头或cookie的形式请求特定语言的产品。REST API返回本地化的产品数据。 NuGet包 若要使用此处所述的本地化功能，必须安装NuGet包 RestApiLocalization.NET。该软件包包括对支持的系统区域性（Culture Provider）的管理以及用于本地化数据的扩展方法。
文化——本地化基础 根据 RFC4646/ISO639/ISO3166 的规则，NET区域性具有唯一的名称，该规则定义了用于确定区域性的三个级别：
Windows系统中注册的语言可以根据以下条件进行选择：
Neutral文化，例如en或de。Specific文化，例如en-US或de-DE。Installed区域性，安装在REST API计算机上。Custom自定义用户区域性。Replacement已替换的默认区域性的区域性。 阅读有关.NET 区域性类型的微尘。
文化Provider 系统区域性函数在ICultureProvider接口中指定，并提供在处理API请求时限制可用区域性和控制工作区域性的能力。
public interface ICultureProvider { /// &lt;summary&gt;Get the default culture name&lt;/summary&gt; string DefaultCultureName { get; } /// &lt;summary&gt;Get the current culture&lt;/summary&gt; CultureInfo CurrentCulture { get; } /// &lt;summary&gt;Get the current UI culture&lt;/summary&gt; CultureInfo CurrentUICulture { get; } /// &lt;summary&gt;Set the current application und UI culture&lt;/summary&gt; void SetCurrentCulture(string cultureName); /// &lt;summary&gt;Get the culture by name&lt;/summary&gt; CultureInfo?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b957c4ce29503c43c236b83b56287a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656d028a75812936542b4e9756d2a4b7/" rel="bookmark">
			Android http server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在玩Android的盒子，几十块一个，买来随便糟蹋。下面讲讲如何制作Android上的一个http server 并且可以处理post请求。
思路如下
1. 先找一个轻量的可以部署到Android上的库，这里不打算用native 来完成，jni那些还没玩熟，太耗时了。此外性能也不是关键点。
2. 主页是个页面，上面可以放置几个按钮，并且按钮可以点击，最终在Android 后端处理
2.1 了解了下ajax的，无法就是http的post请求，并且带上参数。
2.2. 在Android 后端收到post请求后，完成一定的业务。
3.拓展
1. nanohttpd库 直接gpt里面问了下，建议使用nanohttpd库，使用java 开发，轻量。
grade添加依赖
注意这里的地址是org.nanohttpd:xxxx:xxx ，overstack上能找到答案。好了之后sync 一下。
添加internet 权限，在AndroidManifest.xml 中声明internet，然后再代码中动态申请。（备注好像不需要，因为我开始的时候使用的1024以下的端口80，这个默认是不给用的，改起来太麻烦，放弃）
创建一个从nanoHTTPD派生的类，主要重载serve这个函数，应该是所有http的请求都在这里处理，所以要做复杂的操作，需要在里面根据uri去转发请求，或者处理对应的post，get请求。一般的方法如下
根据method 和uri来派遣，为了更好的模块化，可以定义更多的业务函数。我这里比较简单，就是返回一个页面，然后显示按钮，点击按钮post回请求。
2. 返回主页面 这里很简单，先用gpt生成一个10个按钮的页面，并且需要有css效果，点击按钮会post请求，自动代码就出来了。然后把html的内容全部复制给一个变量。
最终把response 返回即可。
按钮的js代码部分。主要是post 一个json过去。
3. post处理 自己根据post 和url 来处理post请求，先提取post的json串，然后拿到name。然后去执行业务。
我这里是模拟发送一个keycode 事件，（做的是一个按键点播小程序）
触发按键事件；跟USB键盘的效果一致。
根据post的name转换成keycode
因为整个程序的其余部分是根据按键去播放文件，为了对已有代码侵入修改最小这里使用模拟按键的方式来实现。
最终页面效果如下
这里只是完成了最低要求的功能，比如ajax请求成功，失败，弹框显示等等这些都没有。到这里正常情况下，已经可以和android的后端完成通信了。
4. 扩展部分 我们添加了对http的支持后，也可以很轻松的来支持socket
创建一个socketserver来处理客户端的连接，然后用clientthread 来服务客户端
这里就简单了，这里定义一个简单的协议，先发4字节的payload长度，然后payload，这里也不考虑心跳了，断了直接客户端自己重新连过来。
收到一个有效的payload 后，对内容解析，然后执行一个异步task。这里一样也是来模拟一个键盘事件达到播放的效果。
至此拓展功能基本完成。
Android客户端 根据通信协议，先发四个字节的长度，然后发送payload， 我这里直接发0,1,2这样的字符串，然后再服务器端转换。gpt大大提高了开发效率。不得不服。随便看个android 1,2周就可以玩初级的demo了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a63c8db0b460144fc284f413d4ccc0/" rel="bookmark">
			uniapp实现点击标签文本域中显示标签内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上一个效果图
实现的效果有：
①.点击标签时，标签改变颜色并处于可删除状态
②.切换标签，文本域中出现标签的内容
③.点击标签右上角的删除可删掉标签，同时清除文本域中标签的内容
④.可输入内容，切换时不影响输入的内容
使用的是uniapp+vue3+uVieww-plus
代码：
&lt;template&gt; &lt;view class="mt32"&gt; &lt;u--textarea v-model="textareaValue" placeholder="请输入未通过的原因!" height="200" count maxlength="30" &gt;&lt;/u--textarea&gt; &lt;view class="mt32 flex flex-wrap justify-center align-items-center align-center"&gt; &lt;view class="u-page__tag-item" v-for="(item, index) in radios" :key="index"&gt; &lt;u-tag :show="item.show" shape="circle" :closable="item.closable" :bgColor="item.bgColor" :color="item.color" borderColor="#DCDCDC" :text="item.content" :plain="!item.checked" :name="index" @click="radioClick" @close="close(item)"&gt; &lt;/u-tag&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="flex justify-center align-items-center"&gt; &lt;view class="mt32 tjBtn" @click = "submit"&gt;提交&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script setup&gt; import { reactive, ref, toRaw, onMounted, watch, computed } from 'vue'; import { onLoad,onReady } from '@dcloudio/uni-app' // const textareaValue = ref('') const radios = ref([ { checked: true, show:true, closable:false, bgColor: '#ffffff', color:'rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a63c8db0b460144fc284f413d4ccc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09669accdf064136404cfaeb5539901a/" rel="bookmark">
			如何使用Fluent Assertions进行多个断言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
背景
使用代码
兴趣点
介绍 许多代码返回一个复杂的对象。就像其他代码一样，它需要进行单元测试。从逻辑上讲，这只需在测试中添加多个断言行即可完成。这听起来合乎逻辑，但对维护来说是一个问题。每增加一行都需要维护。此外，每条线路都可能导致单独的故障。
在本文中，我将更详细地解释该问题，并演示如何处理此问题。
背景 必须具备一些.NET中的单元测试经验，最好是xUnit和 Fluent断言。
使用代码 下面是要进行单元测试的代码。它是一个拥有关于人类健康的属性的类。由于无法测量BMI，因此对其进行计算。
public class HealthDescription { public decimal LengthInM { get; } public decimal WeightInKg { get; } public decimal Bmi { get; } public HealthDescription(decimal weightInKg, int lengthInCm) { WeightInKg = weightInKg; LengthInM = (decimal)lengthInCm / 100; Bmi = Math.Round(weightInKg / (LengthInM * LengthInM), 2); } } 要演示的第一个单元测试是这样的：
[Theory] [InlineData(70.01, 180, 1.80, 21.61)] public void RegularTest(decimal weightInKg, int lengthInCm, decimal expectedLengthInM, decimal expectedBmi) { var instance = new HealthDescription(weightInKg, lengthInCm); instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09669accdf064136404cfaeb5539901a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93a9bf868cc852c4f29447e813064bc/" rel="bookmark">
			利用百度竞价排名推广增加转化率-华媒舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字营销领域，提高网站转化率是一个重要的目标。百度竞价排名是一种有效的推广方式，通过提高网站在搜索结果中的排名，能够吸引更多的用户点击，并且增加转化率。本文将介绍如何利用百度竞价排名来推广，并且提供一些最佳实践。 1. 什么是百度竞价排名？ 百度竞价排名是一种付费服务，让网站在百度搜索结果页中展示并排名靠前。网站主可以选择关键词，在用户搜索相关关键词时，其网站的广告就会出现在搜索结果中。广告的排名是基于竞价和广告质量得分来确定的。
2. 如何使用百度竞价排名推广？ 2.1 关键词选择
选择适合的关键词是关键的一步。关键词应该与网站的产品或服务相关，并且具有较高的搜索量和竞争度。通过使用百度关键词推测工具，可以找到适合的关键词。
2.2 准备营销文案
在展示广告时，文案的吸引力和有效性非常重要。文案应该简洁明了，突出产品或服务的优势，同时符合用户需求，激发用户点击和转化的兴趣。
2.3 设定竞价和预算
设定合适的竞价和预算是关键的一步。竞价越高，广告排名越靠前，但同时也会增加点击的成本。预算应根据营销目标和资金状况来设定，保证广告可以持续展示。
2.4 设定投放地域和时间
针对特定地域和时间段进行投放可以提高广告的效果。根据产品或服务的本地化需求和用户行为习惯，选择合适的地域和时间段投放广告。
3. 百度竞价排名的优势 3.1 精准定位用户
通过选择合适的关键词和设定投放地域，可以将广告精准地展示给目标用户群体，提高广告的点击和转化率。
3.2 灵活的预算控制
百度竞价排名允许网站主根据自身资金状况设定预算，可以灵活控制广告投放的费用，从而实现更精细化的推广策略。
3.3 实时优化和监测
百度竞价排名提供了丰富的数据监测和分析工具，可以实时监测广告的展现、点击和转化情况，并对广告进行调整和优化，提高广告效果。
利用百度竞价排名推广可以提高网站的转化率，从而实现更好的营销效果。通过适当选择关键词，准备优秀的营销文案，设定合适的竞价和预算，以及精细化的投放策略，可以让百度竞价排名成为一个有效的品牌推广工具。通过优势的精准定位、灵活的预算控制和实时优化监测，可以帮助网站主实现更好的营销效果。最佳实践是持续优化和调整，在实践中不断探索适合自己的推广策略，从而提高转化率和品牌影响力。
华媒舍海外发稿正日益成为全球范围内信息传播的主要渠道，成为连接不同国家和文化的重要桥梁。随着信息技术的飞速发展，海外发稿不仅促进了国际交流，还加强了人们对世界的了解。从政治事件到文化现象，从科技突破到社会变革，海外发稿通过传递各种信息，让人们更加深入地了解这些领域的发展。海外发稿的重要性在于它能够打破国界限制，让不同国家的人们能够分享彼此的观点和经验。这种跨文化的交流不仅促进了社会的进步，还为各国合作提供了更多的机会。同时，海外发稿也为人们提供了更多选择，让他们能够获得更广泛和多元化的信息。信息的传播不仅在国内具有重要意义，而且在国际间也扮演着关键的角色。随着华媒舍海外发稿的不断发展，信息的跨国传播将更加便捷和高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101e5f267d4bf111c058e83315339b1b/" rel="bookmark">
			搜索引擎：6种引擎霸屏推广的颠覆性想法激发新商机-华媒舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引擎霸屏推广是一种创新的广告推广策略，通过在各种搜索引擎中展示广告来吸引目标受众的注意。这种推广方法已经成为了许多企业获取品牌曝光和商机的重要途径。我们将介绍6种引擎霸屏推广的颠覆性想法，这些想法将激发新的商机并帮助企业打造独特的品牌形象。 1. 视频广告的引入 引擎霸屏推广通常以文本广告为主，但随着视频内容的兴起，视频广告正在成为一个强大的宣传工具。通过在搜索引擎中展示有吸引力的视频广告，企业可以更加直观地展示品牌形象和产品服务，吸引目标受众的注意力。
2. 搜索引擎合作 与搜索引擎合作可以帮助企业在搜索结果中获得更多的曝光机会。通过与搜索引擎达成合作，可以实现在搜索结果页面中展示更多的广告位，并且能够在搜索引擎的用户界面上设计更多个性化的广告形式。
3. AI技术的运用 人工智能技术的应用已经改变了广告行业的格局。通过利用AI技术，引擎霸屏推广可以更加精准地定位目标受众，提供个性化的广告内容和服务，从而提高广告的点击率和转化率。
4. 跨平台推广 传统的引擎霸屏推广主要集中在搜索引擎中，但跨平台推广将是未来的趋势。通过在不同的平台上展示广告，如社交媒体、移动应用程序和视频流媒体等，企业可以更全面地覆盖目标受众，增加品牌曝光和商机。
5. 位置定向的广告 引擎霸屏推广通常根据搜索关键词来进行定向，但位置定向的广告将成为一个新的突破点。通过根据用户的地理位置信息展示广告，企业可以更加精准地吸引潜在顾客，并提供本地化的服务。
6. 虚拟现实广告 虚拟现实技术的快速发展为广告行业带来了全新的机遇。引擎霸屏推广中的虚拟现实广告可以提供与现实世界相结合的体验，增加用户的参与度和互动性。通过与虚拟现实技术结合，企业可以为消费者创造更加身临其境的广告体验。
引擎霸屏推广作为一种颠覆性的广告策略，正在不断演进和创新。通过引入视频广告、搜索引擎合作、AI技术、跨平台推广、位置定向的广告和虚拟现实广告，企业可以激发新的商机，并打造出独一无二的品牌形象。随着科技的不断进步，引擎霸屏推广将继续发展，并为企业带来更多的商机和成功的可能。
海外发稿正日益成为全球范围内信息传播的主要渠道，成为连接不同国家和文化的重要桥梁。随着信息技术的飞速发展，海外发稿不仅促进了国际交流，还加强了人们对世界的了解。从政治事件到文化现象，从科技突破到社会变革，海外发稿通过传递各种信息，让人们更加深入地了解这些领域的发展。海外发稿的重要性在于它能够打破国界限制，让不同国家的人们能够分享彼此的观点和经验。这种跨文化的交流不仅促进了社会的进步，还为各国合作提供了更多的机会。同时，海外发稿也为人们提供了更多选择，让他们能够获得更广泛和多元化的信息。信息的传播不仅在国内具有重要意义，而且在国际间也扮演着关键的角色。随着海外发稿的不断发展，信息的跨国传播将更加便捷和高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e1b9c6d09783dc0941c41ebacb3092/" rel="bookmark">
			C&#43;&#43;笔记：从零开始一步步手撕高阶数据结构AVL树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 高度平衡二叉搜索树实现一颗AVL树结点与树的描述——定义类AVL树的插入操作步骤1：按照二叉搜索树的方法插入结点步骤2：自底向上调整平衡因子步骤3：触发旋转操作（AVL树平衡的精髓）右单旋左单旋左右双旋右左双旋 验证AVL树是否平衡 参考文章 高度平衡二叉搜索树 二叉搜索树是一种特殊的树形数据结构，一般情况下，该树能够缩短查找的效率，但是它有个缺陷，在结点的插入或删除顺序较为特殊时结构会退化成链表，导致搜索、插入和删除等操作的时间复杂度从O(log n)退化到O(n)。
【二叉搜索树退化成链表的例子】
高度平衡二叉搜索树是针对二叉搜索树的缺陷所发明出来的一种改良结构。
高度平衡二叉搜索树常被称为 “ AVL树 ”，这主要是为了纪念发明它两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis，AVL是两位数学家的名字的缩写。
一颗AVL树或者是空树，或者是具有以下性质的二叉搜索树：
左右子树高度之差（简称为平衡因子）的绝对值不超过1。在这里平衡因子的求法定义为：右子树的高度 - 左子树的高度。结点的左右两棵子树也都是一棵平衡二叉树。 实现一颗AVL树 概念部分讲的差不多了，至于AVL树相较于二叉搜索树是如何保持平衡结构，就在接下来的实现过程中一步步讲解。
结点与树的描述——定义类 namespace ljh { template&lt;class K, class V&gt; struct AVLTreeNode { AVLTreeNode(const pair&lt;K, V&gt; kv) : _kv(kv) {} AVLTreeNode&lt;K, V&gt;* _parent = nullptr;	// A pointer to node's father AVLTreeNode&lt;K, V&gt;* _left = nullptr;	// A pointer to node's left child AVLTreeNode&lt;K, V&gt;* _right = nullptr;	// A pointer to node's right child int _bf = 0;	// balance factor pair&lt;K, V&gt; _kv;	// key-value }; template&lt;class K, class V&gt; class AVLTree { typedef AVLTreeNode&lt;K, V&gt; Node; public: // AVL树的操作方法 protected: Node* _root = nullptr; }; } 【说明】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e1b9c6d09783dc0941c41ebacb3092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720e2792257ef4ed5b69638069a96e9c/" rel="bookmark">
			Github高级搜索【指定日期区间，星星数，用户仓库名多条件精确搜索】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们号，欢迎关注，一起学习，无限进步
GitHub 高级搜索允许用户使用多种条件来精确查找所需的仓库、文件和代码。以下是对GitHub高级搜索的最全、详细总结说明：
文章目录 关键字搜索仓库名搜索用户搜索组织搜索文件搜索语言搜索星星数搜索更新时间搜索授权搜索组合搜索排除特定关键字特定文件类型搜索 关键字搜索 在搜索框中输入关键字，GitHub 将返回与关键字相关的仓库、文件和代码。 关键字 # 需要查询什么直接输入关键字即可 仓库名搜索 使用 repo 关键字可以限定搜索结果为指定的仓库名称。 repo:仓库名 # 例如 repo:freeCodeCamp/freeCodeCamp 用户搜索 使用 user 关键字可以限定搜索结果为指定用户的仓库。 user:用户名 # 例如 user:sjy-smile 组织搜索 使用 org 关键字可以限定搜索结果为指定组织的仓库。 org:组织名 # 例如 org:alibaba 文件搜索 使用 filename 关键字可以限定搜索结果为指定文件名的代码。 filename:文件名 # 例如 一般配合仓库使用 filename:base.py 语言搜索 使用 language 关键字可以限定搜索结果为指定编程语言的仓库。 language:编程语言 # 例如 language:Java 星星数搜索 使用 stars 关键字可以限定搜索结果为指定星标数以上的仓库。 stars:&gt;=星星数 # 例如： stars:&gt;=1000 更新时间搜索 使用 pushed 关键字可以限定搜索结果为在指定时间之后更新的仓库。 pushed:&gt;=YYYY-MM-DD # 例如： pushed:&gt;=2022-01-01 授权搜索 使用 license 关键字可以限定搜索结果为具有指定许可证的仓库。 license:许可证 # 例如 license:Apache 或者 license:MIT 组合搜索 - 可以组合多个搜索条件，以缩小搜索范围。 ```bash 关键字 language:编程语言 stars:&gt;=星标数 # 例如 权限管理系统 language:java stars:&gt;=1000 ``` 排除特定关键字 - 使用减号 `-` 可以排除包含特定关键字的结果。 ```bash 关键字 -排除词 # 例如 java -python ``` 特定文件类型搜索 - 使用 `extension` 关键字可以限定搜索结果为特定文件类型。 ```bash extension:文件类型 # 例如 extension:html ``` 这些搜索条件可以根据具体需求进行组合，以更精确地找到你需要的开源代码库。希望这份详细总结对你有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5dbae1dac34e8e57089187745a21cb4/" rel="bookmark">
			探索未来科技：深入了解设备交互 API 如何改变我们的生活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 设备交互是自动化测试工具与移动设备进行沟通和掌握的过程，它不仅限于基本的应用元素点击和输入等操作。
在移动端应用程序测试中，设备交互的范围扩展到模拟通信方面和模拟设备本身的功能和行为，会涉及到设备的通信行为，例如模拟电话呼叫和短信发送，以及控制设备的一些系统级别的功能，例如网络连接状态、屏幕方向等。
通过这样的设备交互，测试人员可以更全面地评估应用在不同设备和环境条件下的表现，确保应用在实际使用中能够正常工作并提供良好的用户体验。
设备交互应用场景 模拟电话和短信：在测试通讯类应用程序时，模拟电话呼叫和接听、发送和接收短信等操作可以帮助验证应用程序在与电话功能相关的场景中的行为和响应。
网络模式：模拟不同的网络条件，如良好、较差或无网络连接等，可以测试应用程序在不同网络环境下的性能和容错能力。这可用于测试应用程序的网络请求、数据同步和离线模式的处理等功能。
横竖屏切换：应用程序在不同屏幕方向下的布局和用户界面的适应性是非常重要的。通过模拟设备从横屏到竖屏或从竖屏到横屏的切换，可以验证应用程序在不同屏幕方向下的布局和显示效果。
App 处理：模拟应用程序被其他应用或系统中断（如来电、短信、通知等），然后再返回到应用程序中，可以测试应用程序在中断和恢复过程中的稳定性和用户体验。
录屏：录制设备屏幕上的操作过程，可以用于制作演示视频、记录应用程序的缺陷复现步骤，以及在教学和培训中展示设备和应用程序的操作方法。
常用基础操作 锁屏与解锁 锁屏：lock()
解锁：unlock()
判断是否锁屏：is_locked()如果是锁屏状态返回 True。
截图与录屏 截图有两个方式：
get_screenshot_as_file('./photos/img01.png')
save_screenshot('./photos/img02.png')
录屏：模拟器需要 androidAPI&gt;27，华为不支持，只支持 8.0 以上的版本。
开始录制：start_recording_screen()
结束录制：stop_recording_screen()
打开通知栏 打开通知栏： open_notifications()
获取当前屏幕分辨率 获取当前屏幕分辨率：get_window_size()
模拟电话、短信 Appium 提供了模拟来电和短信的功能，这在测试中可用于验证应用在接收来电或短信时的响应。需要注意的是，这些模拟功能仅限于原生模拟器，不支持第三方的模拟器。
Python 示例
## 向号码拨打电话 driver.make_gsm_call("13822233001", GsmCallActions.CALL); ## 接听来自当前号码的电话 driver.make_gsm_call("13822233001", GsmCallActions.ACCEPT); ## 电话保持 driver.make_gsm_call("13822233001", GsmCallActions.HOLD); ## 终止与号码的通话，可用于取消拨号或挂断通话 driver.make_gsm_call("13822233001", GsmCallActions.CANCEL); ## 接收到来自该号码的短信 driver.send_sms("555-123-4567", "hello Appium"); 网络设置 只有 Android 可以使用 set_network_connection 进行网络设置
Python 示例
## 获取当前网络状态 print(driver.network_connection) ## 设置为飞行模式 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5dbae1dac34e8e57089187745a21cb4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/35/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>