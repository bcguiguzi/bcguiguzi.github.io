<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b40d778b41892cc0787dce647cc6f47/" rel="bookmark">
			[QT_023]Qt学习之QString详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：《Qt编程指南》 作者：奇先生
Qt编程指南，Qt新手教程，Qt Programming Guide
本节介绍 QString 的常见使用，包含 C++ 基本类型和 QString 的互相转换、QString 涉及的运算符、QString 子串查询和操作、利用 QTextStream 对 QString 做输入输出操作等，最后通过一个示例集成测试函数，展示 QString 用法。
3.3.1 QString和QChar简介 QString 是由一系列 16 bit 字符 QChar 组成的字符串，以 NULL 字符结尾（末尾的 NULL 不计入字符串长度）。QChar 是一个 Unicode 4.0 标准的字符，对于超过 16bit 范围的国际码字符，QString 里采用相邻的一对 QChar 来表示。QString 使用的其实是 UTF-16 的双字节编码，tr 函数就是将 UTF-8 变长编码的字符串转成 QString 运行时的内码。UTF-8 编码是属于通用的存储交换格式，但这种编码的缺点就是一个字符的长度不固定，这对字符串操作效率是有影响的，因为得先确定每个字符的长度。因此 QString 采用固定长度字符单元的 UTF-16 编码，这对程序运行时字符串比较、查询操作效率更高。上一节 3.2.4 表格中 utf16() 和 unicode() 函数都没有用 to 前缀，因为这两个函数没有做转换，它们返回的就是 QString 运行时的内码，同 data() 函数。tr 函数不仅可以用于支持国际化翻译，并且能自动将字符串的存储交换格式 UTF-8 转换成运行时的 UTF-16 内码，返回转换过后得到的 QString 对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b40d778b41892cc0787dce647cc6f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36499dd4fbd67fd0c665e9b9bdeffed2/" rel="bookmark">
			odoo实施：模块安装与升级常见问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块安装与升级常见问题及解决方案 文章目录 模块安装与升级常见问题及解决方案前言一、版本不兼容二、依赖关系错误三、数据库错误四、权限错误五、文件冲突总结 前言 要避免模块升级错误，建议在升级之前备份数据，并确保系统和数据库都处于良好状态。如果出现错误，可以检查错误日志和数据库日志，并按照错误提示解决问题。
博主微信：13826468836，需要技术支持可加博主微信
一、版本不兼容 在升级模块之前，请确保新模块的版本与当前模块的版本兼容。如果不兼容，可能会导致数据丢失或其他问题。建议备份数据并进行测试，以确保模块升级不会对系统产生不利影响。
二、依赖关系错误 某些模块可能依赖于其他模块。如果您正在升级的模块依赖于其他模块，但这些模块未被正确安装或升级，可能会导致错误。请先安装或升级所有相关模块。
三、数据库错误 在升级模块时，可能会发生数据库错误，例如数据库连接错误或数据库锁定。这些错误可能是由于系统资源不足或其他问题引起的。请检查系统资源和数据库日志，以查找错误的原因并解决问题。
四、权限错误 如果您正在使用非管理员用户进行模块升级，可能会遇到权限错误。请确保该用户具有足够的权限来升级模块，并检查访问权限和操作权限。
五、文件冲突 升级模块时，可能会发生文件冲突，例如源代码文件已被修改或删除。这些错误可能是由于文件权限、文件夹权限或文件系统错误引起的。请检查文件和文件夹权限，并确保文件系统正确运行。
总结 总之，要避免模块升级错误，建议在升级之前备份数据，并确保系统和数据库都处于良好状态。如果出现错误，可以检查错误日志和数据库日志，并按照错误提示解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c749d19fa4a6d083b3dafa7a6a00ab/" rel="bookmark">
			NLP 中语言表示 (向量化) 的基本原理和历史演变综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前言2 语言表示2.1 离散表示2.1.1 独热编码2.1.2 词袋模型2.1.3 TF-IDF 模型2.1.4 N-gram 模型2.1.5 基于聚类的表示 2.2 连续表示2.2.1 分布式表示2.2.2 Word Embedding2.2.2.1 Word2Vec2.2.2.2 GloVe2.2.2.3 FastText 2.2.3 基础神经网络模型2.2.3.1 神经词袋模型2.2.3.2 RNN (Recursive Neural Network)2.2.3.3 RNN (Recurrent Neural Network)2.2.3.4 CNN2.2.3.5 ELMo 2.2.4 基于 Transformer 的模型2.2.4.1 GPT2.2.4.2 BERT2.2.4.3 BART 2.2.5 基于浅层神经网络的结构数据表示学习2.2.5.1 DeepWalk2.2.5.2 LINE2.2.5.3 Node2vec 2.2.6 基于图神经网络的结构数据表示学习2.2.6.1 GCN2.2.6.2 GATs 3 结语4 参考 团队博客: CSDN AI小组
相关阅读
ChatGPT 简介关于 ChatGPT 必看的 10 篇论文从 ELMo 到 ChatGPT：历数 NLP 近 5 年必看大模型ChatGPT 中的人类反馈强化学习 (RLHF) 实战 1 前言 在自然语言处理（Natural Language Processing，NLP）领域中，语言表示是一项核心任务，其旨在将人类语言转化为计算机可理解和处理的形式。语言表示的基本原理和历史演变是理解和应用 NLP 技术的基石。随着人工智能和深度学习的迅猛发展，语言表示也经历了一系列的演进和改进。从早期符号化的离散表示方法到如今基于深度学习的分散式表示 (Distributed Representations) 方法，语言表示都在 NLP 任务中扮演着至关重要的角色。本文主要从离散表示和连续表示 (分散式表示是连续表示的一类方法) 的角度，介绍语言表示的基本原理和历史演变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c749d19fa4a6d083b3dafa7a6a00ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d6c234e89302ce3254fa45ab7ebf77c/" rel="bookmark">
			【看了标题就行】Anaconda3避雷，windows 7装2021.05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 雷！ 老电脑，离线的那种，今天想升级一下Anaconda，结果下了一个版本传过去都不行。后面一查，windows 7的锅。Python3.9就不再支持windows 7.可怜的被抛弃的人们。
然后就开始找要装哪个。
版本对应 Anaconda版本安装器python版本2022.103.92022.053.92021.113.92021.053.8 别问我为什么知道……我就知道拷文件好耗费体力。
下载 现在国内能下载的地方比较多。
清华阿里云 结论 windows 7电脑，最高的anaconda只能撞到2021.05版本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab3946e6c2f88908c2e02ff9ef4c922/" rel="bookmark">
			ubuntu服务器常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看gpu使用情况
nvidia-smi 可以得到GPU占用情况和主要使用GPU的进程，如下图
可以看到进程1722405在跑训练
执行以下命令
ps -f -p 1722405 或者执行以下命令
ps u 1722405 得到结果如下
其中
UID 表示用户ID
PID 表示进程号
PPID 表示父进程号
TIME 表示执行时间
CMD 表示执行命令
应用screen命令在后台运行程序，训练模型
1.首先确定系统是否安装了screen
在终端输入以下命令，如果不报错则已经安装
which screen 2.创建screen窗口
输入以下命令创建一个screen窗口，其中test1是这个窗口的名字，可以自定义（注意S是大写）
screen -S test1 3.输入执行命令，进行训练
python Train.py 4.断网后恢复
只要你的云端服务器不关机，断网后或是自己主动关闭连接后你的模型都会继续训练。再次连上时可以通过以下命令查看运行情况。默认打开的是第一个窗口，可以通过screen -r test1打开指定窗口
screen -r Ctrl+D # 在当前screen下，输入Ctrl+D，删除该screen Ctrl+A，Ctrl+D # 在当前screen下，输入先后Ctrl+A，Ctrl+D，退出该screen 5.删除
如果要删除则输入以下命令，其中test1是你前面自己命名的窗口名
screen -s test1 -X quit 6.其他
可以通过一下命令来查看当前的各个窗口信息
screen -ls 结果如图所示，2712686这类数字的后面就是你的窗口名
根据进程号杀死进程
kill -9 PID 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0aa683b5bf759a19fe77dc48456d3e7/" rel="bookmark">
			Go 的时间操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 的时间操作 1. time 包 1.1. 时间类型 Go 语言中时间类型有两种：
time.Time：表示时间的类型，常见的有两种方式： time.Now()：获取当前的时间time.Date()：根据指定的年、月、日、时、分、秒、纳秒等创建时间 time.Duration：表示两个时间点之间经过的时间，以纳秒为单位 1.2. 时间戳 时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的总毫秒数。它也被称为 Unix 时间戳（UnixTimestamp）。
1.3. 时间间隔 time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。
1.4. 时间操作 Go 语言中时间操作主要有两种：
获取时间：time.Now()、time.Date()格式化时间：time.Format()、time.Parse() 2. 获取时间 2.1. 获取当前时间 Go 语言中通过 time.Now()函数获取当前时间，返回一个 time.Time 类型的本地时间。
func Now() Time package main import ( "fmt" "time" ) func main() { now := time.Now() // 获取当前时间 fmt.Printf("current time:%v\n", now) } 2.2. 获取指定时间 time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0aa683b5bf759a19fe77dc48456d3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5231803e7c7e1c876333b7070f002bd/" rel="bookmark">
			Win系统提示缺少mscomm32.ocx文件怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实很多用户玩单机游戏或者安装软件的时候就出现过这种问题，如果是新手第一时间会认为是软件或游戏出错了，其实并不是这样，其主要原因就是你电脑系统的该dll文件丢失了或者损坏了，这时你只需下载这个mscomm32.ocx文件进行安装(前提是找到适合的版本)，当我们执行某一个.exe程序时，相应的DLL文件就会被调用，因此安装好之后就能重新打开你的软件或游戏了.
那么出现mscomm32.ocx丢失要怎么解决？
一、手动从本站下载dll文件 1、从下面列表下载mscomm32.ocx文件
32位 文件:
mscomm32.ocx
2、将下载的文件放入到你要运行的软件或者游戏的安装所在文件夹之中，可以右键点击主执行程序.exe然后选择"打开文件所在的位置" 找到安装目录，将文件复制进去。
或者将文件复制到Windows系统目录，这个需要注意电脑的系统是32位还是64位，如果是32位的系统，那就将本站下载32位的dll文件放到“C:/Windows/System32”这个文件夹里面,如果是64位的系统，那就将本站下载的32位dll文件放到“C:/Windows/SysWOW64”这个文件夹里面,本站下载的64位文件放到“C:/Windows/System32”这个文件夹里面.
如果问题依然无法解决，值得注意的是此类文件的丢失有时候和杀毒软件的误报毒有关，所以请将此类dll文件添加到杀毒软件的信任列表当中.
二、使用本站提供的软件进行自动修复 本站出品的DLLEscort软件具有修复Windows系统文件的特性，它可以帮助你修复系统软件或游戏丢失的DLL运行库文件。 如:DirectX游戏运行库,directx出现错误导致的游戏打不开等BUG; VC(Microsoft Visual C++)运行库是在Windows系统下运行Visual Studio开发的应用必备组件，缺少的话无法运行软件，会出现提示缺少DLL的情况。
DLLEscort全面支持32/64位 Windows XP,Windows Vista, Windows 7, Windows 8, Windows 8.1, Windows 10 操作系统
下载地址：本站下载 | 百度网盘下载(提取码: 9999),下载完成后得到安装包文件运行后，点击Next下一步进行安装，安装完毕后会自动打开软件或手动执行桌面主程序(DLLEscort)即可打开软件，
桌面软件图标:
一、点击“PC Scan”或 “Click to Start Scan”开始对系统丢失文件扫描
二、扫描完成，扫描结果分成三部分，包括1，待修复的丢失文件。 2，待修复的注册表。 3.待清理的系统缓存文件。
三、点击”ALL Repair”修复开始，请保持网络通畅,直到所有问题修复完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e780b23ea188c3ec710d4f62bf5eba4d/" rel="bookmark">
			golang 代码编写规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Go语言中，有一些常见的代码编写规范被广泛接受和推荐。这些规范有助于提高代码的可读性、可维护性和一致性。以下是一些常见的Go代码编写规范： 代码格式化：Go语言有一个官方的代码格式化工具，称为"gofmt"。使用gofmt可以自动格式化代码，使其符合Go语言的标准格式。统一的代码格式有助于团队协作和代码的可读性。
使用驼峰命名：在Go语言中，建议使用驼峰命名法来命名变量、函数和类型。私有的（只在当前包内可见）变量或函数应使用小写字母开头，公有的则应使用大写字母开头。
使用有意义的命名：命名应具有描述性，能够清晰地表达变量、函数或类型的用途。避免使用单个字母的变量名，除非在循环索引或临时变量等情况下。
注释：在Go语言中，注释对于解释代码的目的、功能和设计决策非常重要。应编写清晰、简洁的注释来解释代码的关键部分，包括函数、变量和类型的用途。
包名：Go语言中的包名应具有简洁、有意义的命名，避免使用过于通用的名称。包名应该是小写的，不使用下划线或混合大小写。
错误处理：在Go语言中，错误处理是一个重要的概念。建议使用多值返回的方式返回错误，并在调用函数时检查错误。可以使用错误变量的命名约定，如err或者e。
函数和方法：函数和方法的定义应具有清晰的命名和一致的参数顺序。当函数和方法有多个参数时，可以考虑使用具有明确含义的参数名称。
导入包：导入包应该按照字母顺序排序，并分为标准库包、第三方库包和本地包。每个导入路径都应该单独占一行。
避免全局变量：在Go语言中，全局变量的使用应该尽量避免。应该优先使用局部变量或传递参数的方式进行数据传递。
常量命名：常量的命名应该全部大写，并使用下划线分隔单词。例如：const MAX_VALUE = 100。
结构体命名：结构体的命名应使用驼峰命名法，并避免缩写。结构体的字段应该首字母大写，以使其可导出。
接口命名：接口的命名应该以"er"结尾，例如：Reader、Writer、Logger。
方法接收器命名：当为方法定义接收器时，接收器的名称应该是接收器类型名称的第一个字母小写的驼峰形式。例如：func (s *Struct) methodName()。
空白标识符：在导入包时，如果只是需要包的副作用（例如包的初始化），可以使用空白标识符"_"将其忽略。
错误处理：在处理错误时，应该优先处理错误，而不是忽略它们。可以使用errors.New或fmt.Errorf创建错误，并使用if err != nil进行错误检查。
函数长度：函数的长度应该保持在合理的范围内。如果函数过长，可以考虑将其拆分成更小的功能模块。
并发安全：如果一个类型的方法需要在并发环境中使用，应该在文档中明确说明它的并发安全性。
defer使用：对于需要在函数结束时执行的清理操作，可以使用defer语句来延迟执行。defer语句应该在函数的开头定义，以便清晰明了地表达执行顺序。
测试：编写测试是Go语言开发的重要部分。测试文件应该与被测试的文件位于同一个包中，并以"_test.go"结尾。测试函数应以"Test"开头，并接收一个*testing.T参数。
包文档：每个包应该有相应的包文档注释，用来解释包的用途和功能。注释应该在包声明之前，并使用完整的句子描述。
错误类型：自定义错误类型应该实现error接口，并以"Err"作为前缀，例如：type ErrInvalidInput struct{}。
错误变量检查：在处理错误时，应使用具体的错误变量检查，而不是直接使用字符串比较。例如：if err == ErrInvalidInput {}。
字符串拼接：在需要拼接字符串时，应优先使用strings.Builder或strings.Join，而不是使用+运算符。
切片扩容：当需要向切片中添加元素时，使用append函数来扩容切片。避免手动分配和拷贝切片。
defer释放资源：当打开资源时（例如文件、网络连接等），使用defer语句来确保在函数返回时正确释放资源。
接口设计：接口应该简洁、专注于单一责任，并遵循“面向行为”的原则。避免过度设计和过于宽泛的接口。
空指针检查：在访问指针类型的字段或调用方法之前，应该检查指针是否为nil，以避免空指针异常。
锁的粒度：在使用互斥锁时，应该尽量减小锁的粒度，以提高并发性能。避免在不必要的情况下持有锁。
包的依赖：减少包之间的循环依赖，尽量保持包的依赖关系简单和清晰。
标准库使用：尽量使用Go标准库提供的功能和工具，避免过度依赖第三方库。
错误处理返回值：在函数有多个返回值时，建议将错误作为最后一个返回值，并命名为"err"。例如：func Func() (result Type, err error)
指针和值接收器选择：在为类型定义方法时，如果方法需要修改接收者的状态，应该使用指针接收器；如果方法不需要修改接收者的状态，应该使用值接收器。
切片遍历：在遍历切片时，使用range关键字可以获得索引和值。如果只需要索引或只需要值，可以使用_来忽略不需要的部分。
defer中的参数传递：在使用defer语句时，要注意参数传递的值会在defer语句执行时进行计算，而不是在函数结束时。因此，在使用defer时，要注意参数的值是否符合预期。
并发安全使用map：如果需要在并发环境中使用map，应该使用sync.Map来确保并发安全。避免直接使用普通的map进行并发访问。
错误信息格式化：在创建错误时，可以使用fmt.Errorf进行错误信息的格式化。使用占位符和参数来构建更具描述性的错误信息。
常量组的使用：当有多个相关的常量时，可以将它们组织在一起形成常量组。常量组的每个常量可以单独赋值，也可以省略赋值，使用上一个非空表达式的值。
行长度限制：为了提高代码的可读性，建议每行代码长度不超过80个字符。如果一行过长，可以使用换行和缩进来使代码更易读。
函数命名：函数的命名应该清晰、简洁，并准确反映其功能。避免使用重复的动词，使用名词或动宾短语来命名函数。
代码注释：在注释中应该解释代码的意图、原因和用法，而不仅仅是重复代码的内容。注释应该简洁明了，并保持与代码的同步更新。
包的导入别名：当导入的包名称冲突或过长时，可以使用别名来简化包的使用。例如：import alias "github.com/username/repo"。
错误处理的日志记录：在处理错误时，可以使用日志记录库（如log包）记录错误信息，以便后续跟踪和调试。避免在错误处理中直接打印错误信息。
避免嵌套过深的控制结构：过深的嵌套控制结构会降低代码的可读性。应该尽量减少嵌套，使用早期返回或错误处理来避免深层嵌套。
常量枚举值：当定义常量枚举值时，可以使用iota自动递增的特性。例如：const ( Monday = iota + 1 Tuesday Wednesday )。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e780b23ea188c3ec710d4f62bf5eba4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddae69445c083689ad00ae468de858b/" rel="bookmark">
			语义分割学习笔记（三）FCN网络结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐课程：FCN网络结构详解(语义分割)_哔哩哔哩_bilibili
感谢博主霹雳吧啦Wz / 太阳花的小绿豆提供视频讲解和源码支持，真乃神人也！
目录
1.FCN网络概述
2.几种不同的FCN网络
(1) FCN-32s
(2) FCN-16s
(3) FCN-8s
3.损失计算
1.FCN网络概述 FCN网络（Fully Convolutional Networks）：首个端对端的针对像素级预测的全卷积网络。
FCN网络思想：输入图像经过多次卷积，得到一个通道数为21的特征图，再经过上采样，得到一个与原图同样大小的特征图，再经过Softmax函数处理就能得到该像素针对Pascal Voc数据集每一个类别的预测概率，选择最大概率的类别作为该像素的预测类别。
FCN网络在VGG网络上做出的修改：把VGG全连接层改为卷积层。一方面，可以不用固定输入图像的大小。另一方面，当输入图像大小大于24x24，最终得到的输出特征图的channel就会变为2D的数据，这时我们把channel提取出来就得到一张热图（heatmap）。
最上面一个网络模型为vgg 16。
2.几种不同的FCN网络 FCN-32s：使用32倍的上采样。FCN-16s：使用16倍的上采样。FCN-8s：使用8倍的上采样。
(1) FCN-32s VGG16 Backbone（主干网络）为VGG16网络全连接层之前的网络部分。注意：FCN网络把VGG全连接层改为卷积层，即其中两个卷积层为FC6，FC7。
模型的训练过程如下：
1.输入图片，首先，通过VGG16 Backbone（主干网络）会将图片下采样32倍，得到的特征图W、H为原图片大小的1/32，Channel变为512。
2.其次，经过size=7x7，padding=3，卷积核数为4096的FC6卷积，输出特征图大小不变，Channel变为4096。
3.再次，经过size=1x1，padding=1，卷积核数为4096为FC7卷积，输出特征图大小不变，Channel也不变。
4.然后，经过size=1x1，padding=1，卷积核数为num_class的卷积，输出的特征图大小不变，Channel变为num_class。
（num_class为分类个数，VGG网络全连接层会经过softmax进行多分类，因此我们要把Channel值设置为分类个数，确保参数个数与VGG保持一致。讲解视频中有提到！）
5.最后，经过一个size=64的上采样（即32倍的上采样），特征图恢复到原图大小。得到的特征图的Channel仍然为num_class。
（在源码中，这里没有使用上采样，而是直接使用双线性插值还原。原因是直接使用32倍的上采样效果不明显，不用也可以。这是由于直接放大32倍导致的。）
(2) FCN-16s 很明显FCN-16s网络在VGG16 Backbone（主干网络）之后分为两个分支：
1.最上面的分支其结构与FCN-32s的结构基本一致，唯一的不同在于采用了2倍的上采样（特征图大小扩大2倍），得到的特征图size=原图的1/16，Channel=num_class。
2.最下面的分支接受到VGG16主干网络中MaxPool4层输出的特征图（这里的特征图已经经过了16倍的下采样，大小为原图的1/16），再经过size=1x1，padding=1，卷积核数为num_class的卷积，得到size=原图的1/16，Channel=num_class的特征图。
3.得到的两个特征图进行矩阵相加，得到一个新的特征图。
4.最后，经过一个16倍的上采样，将特征图还原为原图大小。
(3) FCN-8s 很明显FCN-8s网络一共有3条分支。自上而下命名为分支1，分支2，分支3。
模型的训练过程如下：
1.分支1和分支2整体的结构与FCN-16s基本一致，唯一的不同在两个特征图相加后（第一个相加），经过一个2倍的上采样，得到一个size=原图大小的1/8，Channel=num_class的特征图。
2.分支3接受到VGG16主干网络中MaxPool3层输出的特征图（这里的特征图已经经过了8倍的下采样，大小为原图的1/8），再经过size=1x1，padding=1，卷积核数为num_class的卷积，得到size=原图的1/8，Channel=num_class的特征图。
3.得到的两个特征图进行矩阵相加，得到一个新的特征图。
4.最后，经过一个8倍的上采样，将特征图还原为原图大小。
3.损失计算 左边的通过训练模型最终得到的特征图，右边为真实标记。
计算损失值过程：
1.特征图的每一个方格为一个pixel（像素），如上图沿Channel方向每个pixel还有三个参数。沿Channel方向为每个像素做softmax处理，就能得到每个像素的预测值。将预测值与对应真实值（在真实标记对应位置）计算交叉熵损失。
计算交叉熵损失公式：
2.计算每一个像素的损失值，求平均值，最终得到整个网络模型的损失值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3e2bae091c626cacf8963a06a34c77/" rel="bookmark">
			注意看，这个小编叫小帅，居然用Python做出了可视化麻将，而且还有详细教学 | 附源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 halo，包子们晚上好
今天给大家整一个基于pygame实现的可视化麻将
现在不是很多小伙伴都喜欢打麻将的嘛，逢年过节都会搓搓麻将的嘛，所以呀小编这边不就给大家安排上啦，源码啥的都可以直接给大家使用的哟
快跟你的小伙伴一起玩耍吧
相关文件 关注小编，私信小编领取哟！
当然别忘了一件三连哟~~
公众号：Python日志
开发工具 Python版本：3.7.8
相关模块：
pygame模块；
random模块；
GameTable模块；
Rule模块；
以及一些python自带的模块。
环境搭建 安装Python并添加到环境变量，pip安装需要的相关模块即可。
游戏规则 游戏中采取日麻无赤宝牌规则。共计 136 张麻将牌，其中包含 1-9 万/条/筒与东南西北中发白各 4 张（无花牌）。基本规则与国标麻将一致，区别主要在于：每轮对局中存在“宝牌”，胡牌时手牌中若持有宝牌则会有对应奖励；日麻胡牌需要满足特定条件，即为“役”，无役无法胡牌。
设计思路 效果展示 开始界面 玩家进入游戏后，首先会来到登录界面，登录界面中有我为这个游戏所设计的一个 Logo。此时玩家需要在 ID 栏中输入自己的 ID，并选择登录。登录后会来到欢迎界面，并提示玩家可以选择开始游戏
游戏界面 代码展示 基础操作 import copy import pygame import random from GameTable import Gametable from Rule import huJudge from pygame.locals import * from sys import exit class Mahjong(): def __init__(self): self.__clock = pygame.time.Clock() self.screenSet() # 游戏画面设置 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3e2bae091c626cacf8963a06a34c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b28f167db74a1d365eb3a8f3942e42/" rel="bookmark">
			Android系统签名生成，在AndroidStudio中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先找到以下文件
build/target/product/security/platform.pk8
build/target/product/security/platform.x509.pem
2.生成shared.priv.pem 文件
openssl pkcs8 -in platform.pk8 -inform DER -outform PEM -out shared.priv.pem -nocrypt
3. 生成platform.pk12文件
openssl pkcs12 -export -in platform.x509.pem -inkey shared.priv.pem -out platform.pk12 -name platform
执行以上命令是需要输入密码 ，随便输入，你记住就行，简单的可以输入123456。
4.生成jks 或者 keystone文件
keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore debug.keystore -srckeystore platform.pk12 -srcstoretype PKCS12 -srcstorepass 123456 -alias platform
5.将debug.keystore拷贝到AndroidStudio中和build.gradle同级目录，并在build.gradle 的android节点中添加如下引用
signingConfigs { release { storeFile file("debug.keystore") storePassword '123456' keyAlias 'platform' keyPassword '123456' } debug { storeFile file("debug.keystore") storePassword '123456' keyAlias 'platform' keyPassword '123456' } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b13f7f129e1222dea70a0ab210ff3d/" rel="bookmark">
			常见自动化测试工具及框架有哪些？怎么选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、自动化测试简介
1、什么是自动化测试
2、它可以做自动化测试么
二、工具篇
1、UFT（QTP）
2、Selenium
3、Appium
4、工具对比
三、框架篇
1、TestNG
2、unittest
3、pytest
4、Robot Framework
5、框架对比
四、如何选择
总结
一、自动化测试简介 1、什么是自动化测试 软件测试是软件产品开发过程中不可或缺的环节，众所周知，软件测试的分类方法非常多，根据不同的分类，测试可以分为很多种不同的测试方式。如果根据不同的测试点分类，可以将测试分类划分为功能测试、性能测试，这也是我们最常见的的软件测试范畴。而我们的自动化测试，一般意义上来说，是指对功能、性能进行脱离手工的自动化的测试。
对于自动化测试，更广泛的意义，是对界面功能的自动化测试。因此，按照对软件测试的自动化程度，可以分为手工测试、自动化测试。再进一步细分，界面自动化测试，又可根据平台的不同，分为Web自动化测试、移动端自动化测试，而他们的测试工具及框架基本是大相径庭的。
本文，我将依托Web UI自动化测试（网页界面功能自动化测试），简单谈谈我对几款常用的自动化工具及框架的看法。
2、它可以做自动化测试么 关于自动化测试的适用性，一定要明确一点，那就是：不是所有的系统都适合做自动化测试！甚至有的系统根本无法做自动化测试。那么什么样的系统适合做自动化测试呢？总结几点重要因素，如下图所示。
python自动化测试视频教程：2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1AF411T7qJ/?spm_id_from=333.999.0.0
二、工具篇 1、UFT（QTP） UFT 就是以前最常用的自动化测试工具QTP，用来进行Web UI自动化测试的。QTP实现的是独占屏幕操作，仿真实际用户操作，一般用于回归测试和新版本测试。
它的特点是：支持Windows平台，使用VBScript编写测试脚本，相比Java/C#这类语言，显然更受测试人员欢迎。
它的测试流程是：【制定测试计划】-【创建测试脚本】-【增强测试脚本】-【运行测试】-【分析测试结果】。QTP的脚本生成是通过轨迹录制，再进行增强优化，最后实现回放。因此VBScript脚本的逻辑比较松散，因此对于复杂页面情况的处理能力比较弱，脚本维护的成本就非常高。最重要的是，QTP是收费的，QTP11.5版本发布改名为UFT。下图是UFT的工作台界面。
2、Selenium Selenium是目前最常用的一种Web自动化测试工具，是开源的，它可并行测试，模拟用户操作，贴近用户实际操作，测试效果直观。它的优势，首先，兼容性好，兼容多平台，多浏览器，多语言编写脚本，因此它从测试脚本开发，到部署运行，都比较稳定；其次，API丰富，可以实现对浏览器、页面元素、鼠标键盘、JS窗口等几乎所有的用户操作，执行效率较高。
当前Selenium已发展到第3代，包含三大组件，Selenium IDE + WebDriver + Selenium Grid。
Selenium IDE是Firefox中的一个组件，可以录制操作轨迹，自动生成脚本并进行回放，但它的缺点是不稳定，生成的代码效率低，定位大多采用自动的xpath方式定位，定位繁琐，回放成功率低，且不适用于复杂系统。
Selenium Grid是用于实现分布式测试。
WebDriver是Selenium核心组件，它就是实现页面操作的组件，利用浏览器原生的API，封装成一套更加面向对象的SeleniumWebDriverAPI，直接操作浏览器页面里的元素，执行效率更高，且稳定性依赖于浏览器厂商，显然更加稳定，因此各大常见浏览器都有对应的WebDriver，例如Chrome对应chromedriver，Firefox对应geckodriver，IE对应iedriver，甚至比较高版本的selenium还自带了部分常用浏览器的驱动，使用起来非常方便。它的优势显而易见，使用浏览器源厂的驱动来进行自动化控制，给我们带了更高的安全感。
3、Appium Appium是目前最常用的一款移动端自动化测试工具，是开源的，它支持Android和iOS平台的原生应用、web应用和Hybrid应用。它的优势，支持跨平台，多语言脚本编写。因此，兼容性很好，开发便捷。
Appium是C/S架构，提供了基于Selenium WebDriver协议的统一接口。那么这里就需要说明一下Appium与Selenium的关系了。Appium封装了标准的Selenium客户端类库，Appium继承了Selenium中的WebDriver，因此也是通过WebDriver实现界面的定位及操作。而Appium实现的是PC端连接移动端的桥梁作用，这样才能通过PC端对移动端进行自动化测试。
4、工具对比 由于Selenium和Appium都是使用的WebDriver实现操作的，因此这里只对比UFT和Selenium。下面这个表格，充分体现了两者之间的优势与劣势，测试人员可以根据需要选择合适的测试工具，以实现最高的测试效率。
python自动化测试视频教程：2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1AF411T7qJ/?spm_id_from=333.999.0.0&amp;vd_source=6e2d6c374fd551babe1ac6a5e60c5a75
三、框架篇 时下比较主流的自动化测试框架，有TestNG、unittest、pytest、Robot Framework。第一个框架基于Java，后三者基于Python，Java和Python是编写自动化测试脚本最常用的两种语言。下面就简单介绍这四款框架。
1、TestNG Test NG是一款基于Java的自动化测试框架。说到TestNG就不得不提到JUnit，两者都是基于Java的测试框架，功能差异不大，但是TestNG底层调用的是JUnit，因此TestNG的使用对于测试人员来说更友好。而JUnit更偏向白盒测试，所以开发人员用来做单元测试比较多，而且测试结果可读性对测试人员也有一定难度。Test NG使用更便捷，例如并发测试JUnit需要调用第三方库，TestNG则不需要。一般TestNG主要测试人员使用。
TestNG的主要特点有：（1）涵盖单元测试、功能测试、集成测试等；（2）基于Annotation（注解）机制，测试方法更灵活，当我们想执行一部分测试脚本的时候，就可以使用xml配置文件进行配置，在xml配置文件里，可以选择某些需要执行的测试脚本，排除不需要运行的测试脚本；（3）支持多线程测试，这一点很重要，可以大大提高执行效率。
TestNG还可以自动生成html、xml格式的测试报告。测试报告位于 "test-output" 目录下，只需要执行测试用例时使用TestNG执行即可自动生成，无需配置，使用便捷。同时还可以对报告内容的详细程度进行设置，可以说是比较完善的测试报告了，测试报告的样式如下图所示，展示比较直观、简明，可以直接看到共执行了多少个用例，成功/失败分别是多少个，设置级别更高的报告，还可以查看具体的失败情况。
TestNG的使用方法，是将测试用例生成测试套件，通过执行测试套件来执行测试用例，常用的组件如下图所示：
@Test表示一个测试用例；
@BeforeMethod/@AfterMethod表示在每一个方法执行前/后执行一次；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b13f7f129e1222dea70a0ab210ff3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3980e4ca8457f320bb95b097b847d9/" rel="bookmark">
			在vue3页面自定义主题,element-puls的scss的底层css代码逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element-puls的颜色的原理,由于要给我们先定义好不同的主题色,所以肯定不可能一模一样,不过大体的流程是这样子,
不过先说明一下,修改主题色并没有太好的方法,最终的方法都是用 js 覆盖ui组件库的 最重要的主题色 ( primart系列 ) 从而达到动态主题色的效果
我也想过用 js 修改scss的变量,但是这样根本行不通,因为scss的函数和方法只能用scss的变量,而想修改scss变量需要套一层css的变量,如:
$aaa:var(--my-color,red) //然后 document.documentElement.style.setProperty("--my-color", '#626aef'); 但是这样scss就函数和方法识别不了,
因为var()是css的,scss根本不会编译,会把 var(--my-color,red) 当成一个值
所以只能用js把新的变量覆盖旧的变量.
当然如果你有更好的方法(用最少的js代码)实现动态主题色变化可以留言
如果你想用来做自己的自定义主题,前面的几个带有 !default 参数都可以修改,其中最重要的就是 $default-theme-arr 变量,
如果你深入了解,还可以修改里面的参数,达到更多的颜色
把下面的写入scss文件再引入到main.ts @use "sass:math"; @use "sass:map"; // 你要的颜色(key值不能为颜色,英文表示的颜色也不行,但是可以isviolet) $default-theme-arr: ( isviolet: #626aef, iscolour: #41b584, isblue:#409eff, isred:#f34d37, ) !default; // 你的空间命名(前缀) $namespace: "my" !default; // 你的混入白 (会影响到light系列相关的颜色) $mix-white-color: #ffffff !default; // 你的混入黑 (会影响到dark系列相关的颜色) $mix-black-color: #141414 !default; //最终的light层级,element默认为 3, 5, 7, 8, 9(需要整数) $light-tier: (3, 5, 7, 8, 9) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3980e4ca8457f320bb95b097b847d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e006193dd3c6bdfd8505c56ce6b0a7b3/" rel="bookmark">
			【Python数据分析】numpy库的使用-上篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 numpy介绍numpy创建数组numpy创建数组的属性numpy数组运算numpy数组索引和切片numpy数组的形状变换 numpy介绍 NumPy是一个用于科学计算的Python库，它提供了高性能的多维数组对象和用于处理这些数组的各种工具。NumPy的名称来自于“Numerical Python”的缩写。
NumPy的主要功能包括：
多维数组对象：NumPy提供了多维数组对象，称为ndarray，它是一个由同类型数据组成的表格。ndarray可以包含整数、浮点数等多种数据类型，并支持基本的数学运算和数组操作。
数组操作：NumPy提供了很多数组操作函数，包括数组索引、切片、拼接、分割等，可以方便地对数组进行操作和处理。
线性代数：NumPy提供了线性代数相关的函数，如矩阵乘法、矩阵分解、求解线性方程组等。
随机数生成：NumPy提供了各种随机数生成函数，如正态分布、均匀分布等，可以方便地生成随机数序列。
傅里叶变换：NumPy提供了傅里叶变换相关的函数，可以方便地进行信号处理和图像处理等任务。
由于NumPy提供了高性能的数组操作和数学函数，因此被广泛应用于科学计算、数据分析、机器学习等领域。
在使用numpy之前务必确保已经下载安装了numpy库，如果未安装，请在控制台输入如下命令。
pip install numpy numpy创建数组 下面介绍NumPy创建数组的几个函数，可以根据需要选择合适的函数创建数组。
array()：创建一个数组，可以接受一个序列或嵌套序列作为输入。 import numpy as np arr = np.array([1, 2, 3]) print(arr) # 输出 [1 2 3] zeros()：创建一个元素全为0的数组。 import numpy as np arr = np.zeros((3, 4)) print(arr) # 输出 [[0. 0. 0. 0.] # [0. 0. 0. 0.] # [0. 0. 0. 0.]] ones()：创建一个元素全为1的数组。 import numpy as np arr = np.ones((2, 3)) print(arr) # 输出 [[1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e006193dd3c6bdfd8505c56ce6b0a7b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074069abb72cc1b5bd9f71aca634fea4/" rel="bookmark">
			Redis持久化【学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis持久化
官网地址： https://redis.io/docs/manual/persistence/
一.Reids RDB（Redis DataBase） 官网介绍：RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。
1.是什么 在指定的时间间隔，执行数据集的时间点快照
实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写道磁盘上，也就是快照，这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。
这个快照文件就称为RDB文件（dump.rdb）,其中，RDB就是Redis DataBase的缩写
2.能干嘛 1.在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将磁盘快照文件直接读回到内存里
2.Redis的数据都在内存中，保持备份时它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，一锅端
3.Rdb保存的是dump.rdb文件
3.案例演示 1.需求说明：
2.配置文件(6 VS 7)
Redis6.0.16以下
Redis6.2以及Redis-7.0.0
操作步骤：
1.自动触发
Rdis7版本，按照redis.conf里配置save
本次案例5秒2次修改
修改dump文件保存路径
修改dump文件名称
触发备份
第一种情况：第二种情况：
如何恢复
1.将备份文件(dump.rdb)移动到redis安装目录并启动服务即可
2.备份成功后故意用flushdb情况redis，看看是否可以恢复数据
3.结论：执行flushall/flushdb命令也会产生dump.rdb文件，但里面是空的，无意义
物理恢复，一定服务和备份分机隔离
2.手动触发
save和bgsave
Redis提供了两个命令来生成RDB文件，分别是save和bgsave
Save 在主程序中执行会阻塞当前redis服务器，直到持久化工作完成
执行save命令期间，Redis不能处理其他命令，线上禁止使用
案例
BGSAVE(默认) Redis会在后台异步进行快照操作，不阻塞
快照同时还可以响应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程
Redis会使用bgsave对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主进程同时可以修改数据
fork是什么
在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，尽量避免膨胀
案例
LASTSAVE
可以通过lastsave命令获取最后一次成功执行快照的时间
案例：
4.优势 小总结：
适合大规模的数据恢复按照业务定时备份对数据完整性和一致性要求不高RDB文件在内存中的加载速度要比AOF快的多 5.劣势 小总结：
在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，快照之间的数据会丢失
内存数据的全量同步，如果数据量太大会导致I/O严重影响服务器性能
RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑
数据丢失案例
正常录入数据
kill -9 故意模拟意外宕机
redis重启恢复，查看数据是否丢失
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074069abb72cc1b5bd9f71aca634fea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1445f0ce8ec0e3b65aaf5187825c22e/" rel="bookmark">
			C&#43;&#43; 逻辑回归模型求解 （基于Eigen)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 目标函数：sigmoid函数 f_wb=1/[1+exp(-z)]
z=wx+b,w和x是n维向量
/** * @author @还下着雨ZG * @brief sigmoid函数，用于实现逻辑回归 * @param[in] z * @return 1/(1+exp(-z)) */ double sigmoid(const double &amp;z){ return 1/(1+exp(-z)); } 2. 损失函数： 3. 代价函数： 计算模型的代价：
/** * @author @还下着雨ZG * @brief 计算逻辑回归模型的代价cost * @param[in] X * @param[in] y * @param[in] w_in * @param[in] b_in * @return cost */ double compute_cost(MatrixXd X,VectorXi &amp;y,VectorXd &amp;w_in,double b_in){ int m=X.rows(); double cost=0; for(int i=0;i&lt;m;++i){ double z=w_in.dot(X.row(i))+b_in; double f_wb=sigmoid(z); cost+=-y[i]*log(f_wb)-(1-y[i])*log(1-f_wb); } return cost/m; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1445f0ce8ec0e3b65aaf5187825c22e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c93bd10e696a0834740b78025326ad/" rel="bookmark">
			Python神经网络学习(六)--机器学习--强化学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 属实是失踪人口回归了。继续神经网络系列。
强化学习： 强化学习也是一个很重要的方向了，很多人用强化学习玩游戏，可能有人觉得强化学习很难（包括我），但是我今天用网上流传很广的、很经典的一个例子（悬崖徒步, CliffWalking），去带领大家明白强化学习，大概分为两期（本期和下一期）讲明白这个例子。
今天就从最简单的方式：表格型入手，开始入门强化学习。
什么是强化学习？ 强化学习是Reinforcement Learning，我也不知道为什么把Reinforcement翻译成强化，按照我的英语水平，inforce（应该是通enforce)是强迫，re-代表又，就是一再强迫，就是强迫一个东西一遍又一遍的学习。这也突出了强化学习的本质：一遍又一遍。
就好像小时候我们玩红白机，super mario的时候，一遍又一遍的玩，我们玩那个游戏的过程就可以成为强化学习的过程。我们玩的时候，每次死亡都能知道下一次应该怎么做，包括，哪一个管道可以蹲下去，得到很多金币，都会被我们探索出来，这些都在强化学习中会有体现。
和mnist手写数字识别那种学习方式的不同？ 最明显的一个区别就是，我给出一张mnist数据集的图片，能清楚的知道他的正确答案是什么。而我给出一个RL的场景，很少有人能直接给正确（或者最优）方案。
比如给出一个mario在水管上（这个水管可以蹲下去吃金币）的场景，问这个场景最有解决方案，应该至少会有下面三个版本：
1. 应该蹲下去，因为金币很多，还能省很大一段路。
2. 应该继续走，前面有个加命的蘑菇。
3. 你们俩都太弱了，慢慢的掐距离，可以做到蘑菇吃完回来蹲进水管。
至于更多的方案，我玩的还是太少了，留给大家探索吧。
而mnist数据集这种有监督学习，给出场景，答案就是确定的，这个确定的答案（groundtruth）就是标签（label），被用来计算损失从而让学习有进程。
强化学习的过程，由于没有正确答案，只能一次又一次（reinforcement）的玩，然后被驱动着通关。
强化学习的驱动是什么？ 奖励！
如mario游戏，吃金币+命，吃绿蘑菇也+命，两个都吃加更多的命。但是这些都是次要的，主要是通关。所以一般都会把通关的奖励设置的很高，死亡的奖励设置的很低。
当然，有些人喜欢探索环境，说明他们把其他的奖励设置的很高，比如发现密道（如哪个管道能蹲下去）等。
CliffWalking 悬崖徒步 环境说明 环境设定 这个环境是一个4x12的环境，游戏角色（agent）从坐标(3, 0)出生，目的是达到对面(3, 11)，
如图，cliff是悬崖，掉进去就死亡。
当然，这个任务非常简单（对于人类来讲），一般的人类能一眼看到最优路径，但是电脑不会，电脑只能通过一遍又一遍的（reinforcemental）学习从而知道怎么解决这个任务（甚至不一定是最优方案）。
在这里有一些设定：超过边缘视为无动作。如(0, 0)处向左向上走，视为这一步是停止。如此，这就是今天要涉及到的环境了。
奖励驱动设定 不同的奖励驱动达到的目标效果不一样，如果想让他尽早达到终点，可以让他每走一步给出负奖励，他为了让奖励最大化，就能尽早走到终点。如果想让他多走几个格子，可是让他每走到一个和当前路径不相交的位置时给一个正奖励，他应该（因为我没试过）会走遍格子最后到终点。
到达终点给正奖励，掉下悬崖给负奖励这就不说了。
环境代码 # -*- coding: utf-8 -*- import random import numpy as np import gym from gym import spaces """ nrows 0 1 2 3 4 5 6 7 8 9 10 11 ncols --------------------------------------- 0 | | | | | | | | | | | | | --------------------------------------- 1 | | | | | | | | | | | | | --------------------------------------- 2 | | | | | | | | | | | | | --------------------------------------- 3 * | cliff | ^ | *: start point cliff: cliff ^: goal "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c93bd10e696a0834740b78025326ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6556205db0143defe2492b056548fedb/" rel="bookmark">
			在VMware中安装CentOS7（超详细的图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：提前下载和安装好VMware。VMware的安装可以参考上一篇文章：VMware15的下载及安装教程。
1、CentOS7的下载 官网下载地址：Download。
进入CentOS下载官网，找到64位的CentOS7版本。
点进来后，发现它给我们列出了所在区域可用镜像源（可以说是非常的良心的），我们随便选择一个，这里以阿里云的为例：
选择标准的CentOS7映像下载。
下载之后会得到一个ISO文件。
2、CentOS7的配置 1、打开“VMware Workstation“软件，选择”创建新的虚拟机“。
2、选择“典型”选项，然后下一步。
​
3、选择“稍后安装操作系统”，点击下一步。
​
4、客户机操作选择“Linux”,版本选择“CentOS 7 64位”，点击下一步。
​
5、输入“虚拟机名称”，选择虚拟机文件保存的位置，点击下一步。
​
6、最大磁盘默认20G大小即可，然后选择“将虚拟机磁盘存储为单个文件”，下一步。
​
7、点击”自定义硬件配置“。
​
8、选中”新CD/DVD“，选择”使用ISO映像文件“，然后设置CentOS7的ISO映像路径，点击关闭。
​
网络适配器默认NAT就好。
9、点击完成，如下。
​
接下来我们安装CentOS7。
3、CentOS7的安装 1、选中刚刚配置的CentOS7，然后点击“开启此虚拟机”。
​
2、虚拟机启动之后会出现如下界面（白色表示选中），默认选中的是Test this media &amp; install CentOS 7。
我们将鼠标移入到虚拟机中，并按下键盘中的“↑”键，选择Install CentOS 7，最后按下“Enter 键”。 界面说明： Install CentOS 7 安装CentOS 7 Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7 Troubleshooting 修复故障 ​
注意： 在虚拟机中的操作，鼠标必须要移入到虚拟机中，否则虚拟机感应不到，无法对其进行操作。
鼠标移动到虚拟机内部单击或者按下Ctrl + G，鼠标即可移入到虚拟机中。 按下Ctrl + Alt，鼠标即可移出虚拟机。 3、按下Enter进行安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6556205db0143defe2492b056548fedb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b84a0f5df570e208a7962b351a9446/" rel="bookmark">
			物联网毕设 -- 智能火灾烟雾报警系统（APP&#43;OneNET&#43;WIFI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一 连线图
1. 原理图
2. PCB效果
3. 实物效果
4. 功能概括
（1）硬件端
（2）APP端
（3）云平台端
演示视频
二 底层代码使用方式
1. 使用说明
2. 下载程序
3. 查看云平台
三 APP使用方式
四 程序修改部分
🫡若需要，请咨询博主🫡
前言 这个智能家居系统提供了多种功能，包括获取温湿度、烟雾浓度、火焰状态等多个方面的传感器数据，并通过OLED显示在硬件端上，同时设备会在烟雾浓度、温湿度超过设定阈值时触发LED报警灯和蜂鸣器，及时实现声光报警。硬件端还具有ESP8266自动组网和断网后自动重连的机制，保证连接的稳定性。 APP端提供了更多的功能，包括查看各个传感器的状态、修改设备的各个数据阈值、以及查看设备历史数据等。用户可以更加方便地自行设置数据阈值，以适应不同的环境需求。整个系统的功能非常全面，使得用户可以更好地监测家居安全，也可以及时处理相应的问题，提高家庭的安全性和智能化程度。
⚠️⚠️（本文章仅提供思路和实现方法，并不包含代码，需要代码的同学请自行联系博主）
⚠️⚠️（有疑问或需要定制或者技术支持等，也请自行联系博主）⚠️⚠️
欢迎关注微信公众号星之援工作室，公众号不定时开源设计项目
支持单片机，Android系统设计成品定制，项目代做
请联系微信：13648103287
一 连线图 1. 原理图 2. 开发板本身自带一个LED ，这个LED作为我们查看网络连接状态和获取数据状态的说明
（1）灯和机闪烁一下，说明我们已经连接上云平台，OLED显示屏中会显示联网状态，若MUC上面的的LED处于闪烁状态，则说明我们的设备处于正常运行，若LED灯不再闪烁，请按复位键将程序手动复位一次
（2）硬件每5秒会向云平台传输一次数据, 2. PCB效果 3. 实物效果 4. 功能概括 （1）硬件端 1. 获取温湿度、烟雾浓度、火焰状态的传感器设备数据
2. 通过OLED显示各个传感器设备的数据
3. 当烟雾浓度、温湿度超过设定阈值时，LED报警灯亮和蜂鸣器响，实现声光报警
4. 通过ESP8266自动进行组网功能
5. 设备断网后自动进行重连机制
（2）APP端 1. 可以方便地查看各个传感器的状态。
2. 可以灵活地修改设备的各个数据阈值。
3. 可以轻松地获取历史数据记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b84a0f5df570e208a7962b351a9446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc454084d6bbc8a6430e523b4d87c7e6/" rel="bookmark">
			基于springboot&#43;微信小程序实现校园失物招领手机演示【附项目源码&#43;论文说明】分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springboot+微信小程序实现校园失物招领手机演示
摘要 随着社会的发展，社会的方方面面都在利用信息化时代的优势。互联网的优势和普及使得各种系统的开发成为必需。
本文以实际运用为开发背景，运用软件工程原理和开发方法，它主要是采用java语言技术和mysql数据库来完成对系统的设计。整个开发过程首先对校园失物招领微信小程序进行需求分析，得出校园失物招领微信小程序主要功能。接着对校园失物招领微信小程序进行总体设计和详细设计。总体设计主要包括小程序功能设计、小程序总体结构设计、小程序数据结构设计和小程序安全设计等；详细设计主要包括校园失物招领微信小程序数据库访问的实现，主要功能模块的具体实现，模块实现关键代码等。最后对校园失物招领微信小程序进行了功能测试，并对测试结果进行了分析总结，得出校园失物招领微信小程序存在的不足及需要改进的地方，为以后的校园失物招领微信小程序维护提供了方便，同时也为今后开发类似小程序提供了借鉴和帮助。
校园失物招领微信小程序开发使系统能够更加方便快捷，同时也促使校园失物招领微信小程序变的更加系统化、有序化。系统界面较友好，易于操作。
关键词：校园失物招领微信小程序；java Mysql
概述 随着信息时代的快速发展，互联网的优势和普及，人们学习、生活的方式在不断变化，很多时候由于生活的忙碌或者不小心，会丢失物品，但是由于时间的原因，没有办法回去寻找，或者会再朋友圈、微博里发布寻物启事，但是由于朋友圈和微博里的范围比较局限，对于丢失的物品要寻找回来也是比较难的，所以我开发了校园失物招领微信小程序，让用户足不出户也能进行发布失物信息再校园失物招领小程序里，让其他用户一起分享、讨论，最后找到自己丢失的物品。校园失物招领微信小程序主要是借助计算机，通过对本小程序管理所需的信息管理，增加用户的选择，同时也方便广大用户信息的及时查询、修改以及对校园失物招领微信小程序信息的及时了解。校园失物招领微信小程序给用户带来了更多的选择, 该系统通过和数据库软件协作来满足用户的需求。
校园失物招领微信小程序主要有管理员和用户两个用户角色，其中管理员：寻找招领管理、类别管理、记录管理、交流讨论管理、资讯管理、用户管理；用户：主页、交流论坛、我的记录、个人等功能进行相关操作。
课题意义 随着社会的发展和科学技术的进步，互联网技术越来越受欢迎。网络传播的生活方式逐渐受到广大人民群众的喜爱。越来越多的互联网爱好者开始在互联网上满足他们的基本需求，同时逐渐进入各个用户的生活起居。互联网具有许多优点，例如便利性，速度，高效率和低成本。因此，类似于校园失物招领微信小程序，满足用户工作繁忙的需求，不仅是方便用户随时查看信息的途径，而且还能提高管理效率。
本文首先以校园失物招领微信小程序过程的基本问题作为研究对象。在开发系统之前，我们对现有状况进行了详细的调查和分析。最后，我们利用计算机技术开发了一套完整合适的校园失物招领微信小程序。该系统的实现主要优势是：该系统主要采用计算机技术开发，它方便快捷；系统可以通过管理员界面查看用户的所有信息管理。
校园失物招领微信小程序是一款方便、快捷、实用的信息服务查询软件。随着智能网络在全球市场的不断普及以及各种智能平台的使用，系统的开发与人们的日常需求相关，作为中国主流智能的技术开发系统，自然需要这样的软件来满足更多用户的需求和体验。
主要内容 校园失物招领微信小程序的开发及实现，所需要的工作内容：
（1）首先是确定选题，确定好所要做的系统，并对系统的背景及现在面临的一些问题等进行系统的初步确认。
（2）系统确认完成后，结合系统开发的需求进行确认系统开发所使用的技术，本校园失物招领微信小程序的开发使用JAVA技术，数据库进行平台的搭建开发，确认好使用的技术进行技术分析，所使用的技术是否可以完成校园失物招领微信小程序的实现。
（3）确定好系统使用的技术，进行在线确认系统所划分的用户角色，并且根据用户角色划分确定所要设计的功能模块，对于校园失物招领微信小程序系统的设计主要划分别为管理员和用户角色，并所使用的功能模块也相应不同，但是系统的数据库实现的内容是交互的，用户可以随时根据自己的需求进行订单信息，对于系统工作人员可以根据自己的分管内容进行在线信息的处理及操作，管理员获取到所有用户的详细数据信息，并根据需求进行第一时间处理解决。
（4）系统的功能模块确认完成后进行程序及界面的设计，设计完成后，并且通过测试来判断程序是否完善，对于系统测试，需要不同的用户进行不同的内容编辑及提交，及使用不同的测试方式找出程序中存在的漏洞，并对程序出现的漏洞问题进行在线解决处理，如果测试系统没有任何问题时，可以将系统上传进行正式操作使用。
系统页面展示 用户登录小程序可以查看主页、交流论坛、我的记录、个人等内容，如图5-1所示。
用户可以通过选择分类、输入关键字等内容来查找相关内容，如图5-2所示。
管理员登录系统后台后，可以对寻找招领管理、类别管理、记录管理、交流讨论管理、资讯管理、用户管理等内容进行相关操作，如图5-10所示。
如需要可扫取文章下方二维码联系得源码
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/149/">«</a>
	<span class="pagination__item pagination__item--current">150/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/151/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>