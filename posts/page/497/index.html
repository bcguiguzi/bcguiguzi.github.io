<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90feadffa6742b0a36c36c06c6c1f50/" rel="bookmark">
			TCP/UDP 常用端口列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿ 计算机之间依照互联网传输层TCP/IP协议不同的协议通信，都有不同的对应端口。所以，利用短信（datagram）的UDP，所采用的端口号码不一定和采用TCP的端口号码一样。以下为两种通信协议的端口列表链接：
目录 [隐藏] 1端口状态颜色图例20到1023号端口31024到49151号端口449152到65535号端口5参考文献6相关7外部链接 端口状态颜色图例 以下方块，以如下颜色和标签，标明了端口的状态：
使用状态叙述颜色官方应用与端口组合记录在IANA的端口分配列表中[1]白非官方应用与端口组合不在IANA的端口分配列表中；蓝多重使用已知多个应用程序使用这个 port.黄 0到1023号端口 以下列表仅列出常用端口，详细的列表请参阅IANA网站。
端口描述状态0/TCP,UDP保留端口；不使用（若发送过程不准备接受回复消息，则可以作为源端口）官方1/TCP,UDPTCPMUX（传输控制协议端口服务多路开关选择器）官方5/TCP,UDPRJE（远程作业登录）官方7/TCP,UDPECHO（回显）协议官方9/TCP,UDPDISCARD（丢弃）协议官方11/TCP,UDPSYSTAT协议官方13/TCP,UDPDAYTIME协议官方15/TCP,UDPNETSTAT协议官方17/TCP,UDPQOTD（Quote of the Day，每日引用）协议官方18/TCP,UDP消息发送协议官方19/TCP,UDPCHARGEN（字符发生器）协议官方20/TCP,UDP文件传输协议 - 默认数据端口官方21/TCP,UDP文件传输协议 - 控制端口官方22/TCP,UDPSSH (Secure Shell) - 远程登录协议，用于安全登录文件传输（SCP，SFTP）及端口重新定向官方23/TCP,UDPTelnet 终端仿真协议 - 未加密文本通信官方25/TCP,UDPSMTP（简单邮件传输协议） - 用于邮件服务器间的电子邮件传递官方26/TCP,UDPRSFTP - 一个简单的类似FTP的协议非官方35/TCP,UDPQMS Magicolor 2 printer非官方37/TCP,UDPTIME时间协议官方39/TCP,UDPResource Location Protocol（资源定位协议）官方41/TCP,UDP图形官方42/TCP,UDPHost Name Server（主机名服务）官方42/TCP,UDPWINS（WINS主机名服务）非官方43/TCPWHOIS 协议官方49/TCP,UDPTACACS 登录主机协议官方53/TCP,UDPDNS（域名服务系统）官方56/TCP,UDP远程访问协议官方57/TCPMTP，邮件传输协议 67/UDPBOOTP（BootStrap协议）服务；同时用于动态主机设置协议官方68/UDPBOOTP 客户端；同时用于动态主机设定协议官方69/UDPTFTP（小型文件传输协议）官方70/TCPGopher信息检索协议官方79/TCPFinger协议官方80/TCPHTTP（超文本传输协议）- 用于传输网页官方81/TCPHTTP预备（超文本传输协议）官方81/TCPTorpark -Onion routing ORport非官方82/UDPTorpark - 控制端口非官方88/TCPKerberos - 认证代理官方101/TCP主机名 102/TCPISO-TSAP 协议 107/TCP远程Telnet协议 109/TCPPOP（Post Office Protocol），“邮局协议”，第2版 110/TCPPOP3（“邮局协议”，第3版）- 用于接收电子邮件官方111/TCP,UDPSun协议官方113/TCPident - 旧的服务器身份识别系统，仍然被IRC 服务器用来认证它的用户官方115/TCPSFTP, 简单文件传输协议 117/TCPUUCP-PATH 118/TCP,UDPSQL 服务官方119/TCP网络新闻传输协议 - 用来收取新闻组的消息官方123/UDPNTP (Network Time Protocol) - 用于时间同步官方135/TCP,UDPEPMAP (End Point Mapper) / Microsoft RPC Locator Service官方137/TCP,UDPNetBIOS NetBIOS Name Service官方138/TCP,UDPNetBIOS NetBIOS Datagram Service官方139/TCP,UDPNetBIOS NetBIOS Session Service官方143/TCP,UDPIMAP4 (Internet Message Access Protocol 4) - used for retrievingE-mails官方152/TCP,UDPBFTP, Background File Transfer Program 153/TCP,UDPSGMP, Simple Gateway Monitoring Protocol 156/TCP,UDPSQL服务官方158/TCP,UDPDMSP, Distributed Mail Service Protocol 161/TCP,UDPSNMP (Simple Network Management Protocol)官方162/TCP,UDPSNMPTRAP官方170/TCPPrint-srv 179/TCPBGP (Border Gateway Protocol)官方194/TCPIRC （互联网中继聊天）官方201/TCP,UDPAppleTalk Routing Maintenance 209/TCP,UDPQuick Mail传输协议 213/TCP,UDPIPX官方218/TCP,UDPMPP，信息发布协议 220/TCP,UDPIMAP，交互邮件访问协议第3版 259/TCP,UDPESRO, Efficient Short Remote Operations 264/TCP,UDPBGMP，Border Gateway Multicast Protocol 308/TCPNovastor Online Backup官方311/TCPApple Server-Admin-Tool, Workgroup-Manager-Tool 318/TCP,UDPTSP，时间戳协议（英语：Time Stamp Protocol） 323/TCP,UDPIMMP, Internet Message Mapping Protocol 383/TCP,UDPHP OpenView HTTPs Operations Agent 366/TCP,UDPSMTP, Simple Mail Transfer Protocol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90feadffa6742b0a36c36c06c6c1f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819c0693c45e5594153fb57be0964b56/" rel="bookmark">
			WRTnode的启动信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ 0.000000] Linux version 3.14.18 (wrtnode@wrtnode) (gcc version 4.8.3 (OpenWrt/Linaro GCC 4.8-2014.04 r42788) ) #6 Thu Oct 30 18:50:17 CST 2014[ 0.000000] Board has DDR2[ 0.000000] Analog PMU set to hw control[ 0.000000] Digital PMU set to hw control[ 0.000000] SoC Type: Ralink MT7620N ver:2 eco:6[ 0.000000] bootconsole [early0] enabled[ 0.000000] CPU0 revision is: 00019650 (MIPS 24KEc)[ 0.000000] MIPS: machine is WRTNODE[ 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/819c0693c45e5594153fb57be0964b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8aa328cd4de02120f211c485935777/" rel="bookmark">
			android studio与eclipse常用快捷键对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		studio版本为0.8.6
为大家介绍我自己常用的快捷键，实用为主，不全的大家可以补充谢谢。
编号 eclipse studio 功能
1 ctrl+z ctrl+z 撤销
2 ctrl+y 反撤销
3 ctrl+d ctrl+y/ctrl+x 删除整行
4 ctrl+c/ctrl+v ctrl+d 复制加粘贴 5 ctrl+s 自动保存 保存
6 ctrl+f ctrl+f/ctrl+l 查找
7 ctrl+shift+f 整理
8 ctrl+x 剪切
9 ctrl+l ctrl+g 查找行数
10 ctrl+c 选中一行
11 ctrl+v 换行
12 ctrl+shift+f 查找文档
13 ctrl+w 选中当前位置
14 ctrl+h 右边栏
15 alt+/ ctrl+alt+空格 帮助
16 ctrl+空格 代码提示
17 alt+insert 引入set、get方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fda42179f71ae74493af52f4de51ee/" rel="bookmark">
			颜色的寓意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、寓意
1、红色（red）
热情，活泼，张扬。容易鼓舞勇气，同时也很容易生气，情绪波动较大，西方以此作为战关象征牺牲之意，东方则代表吉祥、乐观、喜庆之意，红色也有警示的意思。
2、橙色（orange）
时尚，青春，动感，有种让人活力四射的感觉。炽烈之生命，太阳光也是橙色。
3、黄色（yellow）
黄色的灿烂、辉煌，有着太阳般的光辉，象征着照亮黑暗的智慧之光。黄色有着金色的光芒，有象征着财富和权利，它是骄傲的色彩。
东方代表尊贵、优雅，是帝王御用颜色；是一种可以让人增强食欲的颜色。西方基督教以黄色为耻辱象征。
4、绿色（green ）
清新，健康，希望，是生命的象征。代表安全、平静、舒适之感，在四季分明之地方，如见到春天之树木、有绿色的嫩叶，看了会使人有新生之感。
5、蓝色（blue）
宁静，自由，清新。欧洲为对国家之忠诚象征。一些护士护士服就是蓝色的。在中国，海军的服装就是海蓝色的。深蓝也可代表孤傲、忧郁、寡言，浅蓝色代表天真、纯洁。同时蓝色也代表沉稳，安定。
6、紫色（purple ）
有点可爱，神秘，高贵，优雅，也代表着非凡的地位。一般人喜欢淡紫色，有愉快之感，青紫一般人都不喜欢，不易产生美感。紫色有高贵高雅的寓意，神秘感十足。是西方帝王的服色。
7、粉红（pink）
可爱，温馨，娇嫩、青春、明快、浪漫、愉快。但对以不同的人感觉也不同，有些房间如果搭配的好的话，会让人感到温馨，没有搭配好的话，会让感到压抑。建议最好不要用粉色来装修客厅。
8、棕色、咖啡色（brown ）
代表健壮，与其它色不发生冲突。有耐劳、沉稳、暗淡之情，因于土地颜色相近，跟给人可靠、朴实的感觉。
9、黑色（black ）
深沉，压迫，庄重，神秘，无情色，是白色的对比色。有一种让人感到黑暗的感觉，如和其他颜色相配合含有集中和重心感。在西方用于正式场合。
10、灰色（gray）
高雅，朴素，沉稳。代表寂寞、冷淡、拜金主义，灰色使人有现实感，也给人以稳重安定的感觉。
11、白色（white ）
清爽，无瑕，冰雪，简单。无情色，是黑色的对比色。表纯洁之感，及轻松、愉悦，浓厚之白色会有壮大之感觉，有种冬天的气息。在东方也象征着死亡与不祥之意。
12、银色(silver）
代表尊贵、纯洁、安全、永恒，体现品牌的核心价值。代表尊贵、高贵、神秘、冷酷，给人尊崇感，也代表着未来感。
二、心理效应
1、红色（red）
视觉刺激强，让人觉得活跃、热烈，有朝气。在人们的观念中，红色往往与吉样、好运、喜庆相联系，它便自然成为一种节日、庆祝活动的常用色。同时红色又易联想到血液和火炮，有一种生命感、跳动感，还有危险、恐怖的血腥气味的联想。灭火器、消防车都是红颜色的。
2、橙色(orange)
兼有红与黄的优点，明度柔和，使人感到温暖又明快。一些成熟的果实往往呈现橙色，富于营养的食品(面包、糕点)也多是橙色。因此，橙色又易引起营养、香甜的联想。是易于被人们所接受的颜色。但在特定的国家和地区，橙色又与欺诈、嫉妒有联系。由于橙色过于耀眼，抢夺视线，有时会被认为是粗俗的象征。
3、黄色(yellow)
明亮和娇美的颜色，有很强的光明感，使人感到明快和纯洁。幼嫩的植物往往呈淡黄色，又有新生、单纯、天真的联想，还可以让人想起极富营养的蛋黄、奶油及其他食品。但是，黄色又与病弱有关，植物的衰败、枯萎也与黄色相关联。因此，黄色又使人感到空虚、贫乏和不健康。
4、绿色(green)
具有蓝色的沉静和黄色的明朗，又与人目然的生命相一致相吻合，因此，它具有平衡人类心境的作用，是易于被接受的色彩。绿色又与某些尚未成熟的果实的颜色一致，因而会引起酸与苦涩的味觉。深绿易产生低沉消极、冷漠感。
5、蓝色(blue)
极端的冷色，具有沉静和理智的特性，恰好与红色相对应。蓝色易产生清彻、超脱、远离世俗的感觉。深蓝色会滋生低沉、郁闷和神密的感觉，也会产生陌生感、孤独感。在美国，有“blue boy”这一说，意思并不是 “蓝色男孩” ，而是 “忧郁男孩” ，所以蓝色也有忧郁之意。
6、紫色(purple)
具合优美高雅、雍容华贵的气度。含红的个性，又有蓝的特征。暗紫色会引起低沉、烦闷、神秘的感觉。在许多电视中紫色还是邪恶的代表。
7、黑色(black)
具有包容和侵占性，可以衬托高贵的气质，也可以流露不可征服的霸气。是神秘的意思。
三、其他寓意解读
● 红色
红色是表现食欲不可欠缺的颜色，它可以表现出健康的活力。作为重点色，红色可以表现出健康。特别是鲜艳色调的红色非常明朗，可以很直接地表现出健康的感觉。
红色暗示着生命的开始。红色在可视光线的七种颜色中，是最先被注意的颜色。有关红色的词句，可以联想到斗牛士的红布、血液的红色等等，是让人联想到生命的初始的带有刺激性的颜色。通过实验证明，平衡感和小脑有疾病的人，如果穿上红色的衣服，病情就会加重（Goldstein）。还有报告说，健康的人也会有因为红色产生手抖动，有最大限度提高觉醒效果的作用。红色代表活泼，它不单是一种表现意象的东西，更是超出表现范畴的带有很强刺激性的东西。
另一方面，红色还代表女性。与代表男性的冷色蓝色相对，女性一般用红色来表现。比如女性厕所用红色来提示。但是实际上红色并不仅限于表现女性，也可以用来表现男性那种很强的力量感，如足球的队服和汽车用红色就是为了表现男性的力量感。
● 橙色
橙色是舒适的，是可以表现日常的快活感的颜色。它没有红色的刺激性，但可以体现稳定而明快的家庭感，让观者产生幸福的感觉。
橙色由于本身本身平衡性太好，所以有存在感较弱的缺点。
橙色融合了红色的活力和黄色的阳光感。红色的强烈和黄色漂浮感，这些缺点都没有体现到橙色上。因为没什么缺点，所以橙色给人平凡的感觉，这一点很有趣。
这样一种平衡性好的颜色竟然没有特定的色彩名。红色、黄色还有黑色等，都有体现其色彩的固有名，但橙色却是借用了水果的名字当作色名。
原本拥有固有色名的就只有红、黄、绿、蓝、紫、白、黑这些基本色。白和黑中间的灰色，还有日本人很喜欢的茶色都是借用名。人们从自然中感受到各种色彩，然后给色彩起了杏色、柿子色、琥珀色等名字，这些都是借用名。古代日本人凭着敏锐的感性，将基本色和其他颜色很明确地区分了开来，这真是令人吃惊。
● 黄色
黄色是在所有颜色中最醒目最明亮的颜色。是工程现场和工厂里提醒人注意的标识色，也是儿童安全服的常用颜色。黄色不但醒目，也给人明快开放的印象。
黄色是玩具和餐桌不可欠缺的、是充满开放感和愉悦感的颜色。
如果感觉配色有些沉重，那么加入少量的黄色就会非常有效果。只要有一点点黄色，就能产生开放感，那种令人窒息的感觉就会消失。需要开放性的明快感的餐桌装饰以及玩具，还有选举用的海报的配色都是不能缺少黄色的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fda42179f71ae74493af52f4de51ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41752fc7e8686c00a78a107e57db9021/" rel="bookmark">
			Linux内核的idle进程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. idle是什么
简单的说idle是一个进程，其pid号为 0。其前身是系统创建的第一个进程，也是唯一一个没有通过fork()产生的进程。在smp系统中，每个处理器单元有独立的一个运行队列，而每个运行队列 上又有一个idle进程，即有多少处理器单元，就有多少idle进程。系统的空闲时间，其实就是指idle进程的"运行时间"。既然是idle是进程，那 我们来看看idle是如何被创建，又具体做了哪些事情？
2. idle的创建
我们知道系统是从BIOS加电自检，载入MBR中的引导程序(LILO/GRUB),再加载linux内核开始运行的，一直到指定shell开始运行告一段落，这时用户开始操作Linux。而大致是在vmlinux的入口
startup_32(head.S)中为pid号为0的原始进程设置了执行环境，然后原是进程开始执行start_kernel()完成 Linux内核的初始化工作。包括初始化页表，初始化中断向量表，初始化系统时间等。继而调用 fork(),创建第一个用户进程: kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND); 这个进程就是著名的pid为1的init进程，它会继续完成剩下的初始化工作，然后execve(/sbin/init), 成为系统中的其他所有进程的祖先。关于init我们这次先不研究，回过头来看pid=0的进程，在创建了init进程后，pid=0的进程调用 cpu_idle()演变成了idle进程。
current_thread_info()-&gt;status |= TS_POLLING;
在 smp系统中，除了上面刚才我们讲的主处理器(执行初始化工作的处理器)上idle进程的创建，还有从处理器(被主处理器activate的处理器)上的 idle进程，他们又是怎么创建的呢？接着看init进程，init在演变成/sbin/init之前，会执行一部分初始化工作，其中一个就是 smp_prepare_cpus()，初始化SMP处理器，在这过程中会在处理每个从处理器时调用 task = copy_process(CLONE_VM, 0, idle_regs(&amp;regs), 0, NULL, NULL, 0); init_idle(task, cpu); 即从init中复制出一个进程，并把它初始化为idle进程(pid仍然为0)。从处理器上的idle进程会进行一些Activate工作，然后执行cpu_idle()。 整个过程简单的说就是，原始进程(pid=0)创建init进程(pid=1),然后演化成idle进程(pid=0)。init进程为每个从处理器(运行队列)创建出一个idle进程(pid=0)，然后演化成/sbin/init。 3. idle的运行时机
idle 进程优先级为MAX_PRIO，即最低优先级。早先版本中，idle是参
与调度的，所以将其优先级设为最低，当没有其他进程可以运行时，才会调度执行idle。而目前的版本中idle并不在运行队列中参与调度，而是 在运行队列结构中含idle指针，指向idle进程，在调度器发现运行队列为空的时候运行，调入运行。 4. idle的workload 从上面的分析我们可以看出，idle在系统没有其他就绪的进程可执行的时候才会被调度。不管是主处理器，还是从处理器，最后都是执行的 cpu_idle()函数。所以我们来看看cpu_idle做了什么事情。 因为idle进程中并不执行什么有意义的任务，所以通常考虑的是两点：1.节能，2.低退出延迟。 其核心代码如下： void cpu_idle(void) { int cpu = smp_processor_id(); current_thread_info()-&gt;status |= TS_POLLING; /* endless idle loop with no priority at all */ while (1) { tick_nohz_stop_sched_tick(1); while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41752fc7e8686c00a78a107e57db9021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef7f9887e4c77fcef447dbdc13a3e81/" rel="bookmark">
			Python build finished, but the necessary bits to build these modules were
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编译的时候，Python出现了下面的提示信息： Python build finished, but the necessary bits to build these modules were not found: _bsddb _sqlite3 _ssl _tkinter bsddb185 bz2 dbm gdbm readline sunaudiodev To find the necessary bits, look in setup.py in detect_modules() for the module's name. 当然，每个机器上因为不同的配置，编译报错信息也会不同，比如网上有人的报错就是下面这样的：
Python build finished, but the necessary bits to build these modules were not found: _bsddb	_curses	_curses_panel	_sqlite3	_ssl	_tkinter	bsddb185	bz2	dbm	dl	gdbm	imageop	readline	sunaudiodev	zlib	To find the necessary bits, look in setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef7f9887e4c77fcef447dbdc13a3e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857d6a0f0283aa070252deebf894d459/" rel="bookmark">
			自己归纳整理的ARM THUMB指令机器码表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有个项目需要分析ARM THUMB指令的机器码，网上没有搜索到整理好的机器码表，只好自己把相关指令的机器码归纳整理出来，这里分享给大家。THUMB指令并不多，只有六十多条，这个数字真的是非常了不起，51都一百三十多条呢。
可能这张表对于大多数朋友都用不到，毕竟要深入到机器码这一层的机会还是比较少，我想能到这一步的朋友一定对ARM指令有了足够的理解，所以就不对注释做另外的说明，相信你一看就懂。
呵呵，如果你用上了这张表，记得在内心感谢我一下，这可是我从《Addison Wesley - ARM Architecture Reference Manual (2nd Edition)》中一条一条摘录出来的。
v is immed_value
n is Rn
m is Rm
s is Rs
r is register_list
c is condition
表一：按指令字母升序排列
0100 0001 01mm mddd -- ADC Rd,Rm
0001 110v vvnn nddd -- ADD Rd,Rn,#immed_3
0011 0ddd vvvv vvvv -- ADD Rd,#immed_8
0001 100m mmnn nddd -- ADD Rd,Rn,Rm
0100 0100 hhmm mddd -- ADD Rd,Rm h1h2,h1 is msb for Rd,h2 is msb for Rm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/857d6a0f0283aa070252deebf894d459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b50a10e3358b524582801f98d32866/" rel="bookmark">
			Perf -- Linux下的性能分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文 http://www.blogjava.net/qileilove/archive/2013/09/04/403646.html
Linux下的内核测试工具——perf使用简介 摘要：Perf是Linux kernel自带的系统性能优化工具。Perf的优势在于与Linux Kernel的紧密结合，它可以最先应用到加入Kernel的new feature。pef可以用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能。
1.perf的安装
由于我们经常是在自己编译的内核上进行开发工作，这里需要有包含调式信息的内核启动镜像文件vmlinux，在自定义内核的基础之上，进入linux内核源码，linux/tools/perf
make
make install
提示：
1）可能在编译的时候，有报错大概是由于平台问题，数据类型不匹配，导致所有的warning都被当作error对待：出现这问题的原因是-Werror这个gcc编译选项。只要在makefile中找到包含这个-Werror选项的句子，将-Werror删除，或是注释掉就行了
2）安装完毕，perf可执行程序往往位于当前目录，可能不在系统的PATH路径中，此时需要改变环境变量PATH
2.perf的运行原理
性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。
稍微扩展一下思路，就可以发现改变采样的触发条件使得我们可以获得不同的统计数据：
以时间点 ( 如 tick) 作为事件触发采样便可以获知程序运行时间的分布。
以 cache miss 事件触发采样便可以知道 cache miss 的分布，即 cache 失效经常发生在哪些程序代码中。如此等等。
因此让我们先来了解一下 perf 中能够触发采样的事件有哪些。
使用perf list（在root权限下运行），可以列出所有的采样事件
事件分为以下三种：
1）Hardware Event 是由 PMU 硬件产生的事件，比如 cache 命中，当您需要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样；
2）Software Event 是内核软件产生的事件，比如进程切换，tick 数等 ;
3）Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b50a10e3358b524582801f98d32866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9196199dfc81412fd62038d45feb2d/" rel="bookmark">
			WebService到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、序言
大家或多或少都听过WebService（Web服务），有一段时间很多计算机期刊、书籍和网站都大肆的提及和宣传WebService技术，其中不乏很多吹嘘和做广告的成分。但是不得不承认的是WebService真的是一门新兴和有前途的技术，那么WebService到底是什么？何时应该用？
当前的应用程序开发逐步的呈现了两种迥然不同的倾向：一种是基于浏览器的瘦客户端应用程序，一种是基于浏览器的富客户端应用程序（RIA），当然后一种技术相对来说更加的时髦一些（如现在很流行的Html5技术），这里主要讲前者。
基于浏览器的瘦客户端应用程序并不是因为瘦客户能够提供更好的用户界面，而是因为它能够避免花在桌面应用程序发布上的高成本。发布桌面应用程序成本很高，一半是因为应用程序安装和配置的问题，另一半是因为客户和服务器之间通信的问题。传统的Windows富客户应用程序使用DCOM来与服务器进行通信和调用远程对象。配置好DCOM使其在一个大型的网络中正常工作将是一个极富挑战性的工作，同时也是许多IT工程师的噩梦。事实上，许多IT工程师宁愿忍受浏览器所带来的功能限制，也不愿在局域网上去运行一个DCOM。关于客户端与服务器的通信问题，一个完美的解决方法是使用HTTP协议来通信。这是因为任何运行Web浏览器的机器都在使用HTTP协议。同时，当前许多防火墙也配置为只允许HTTP连接。许多商用程序还面临另一个问题，那就是与其他程序的互操作性。如果所有的应用程序都是使用COM或.NET语言写的，并且都运行在Windows平台上，那就天下太平了。然而，事实上大多数商业数据仍然在大型主机上以非关系文件(VSAM)的形式存放，并由COBOL语言编写的大型机程序访问。而且，目前还有很多商用程序继续在使用C++、Java、Visual Basic和其他各种各样的语言编写。现在，除了最简单的程序之外，所有的应用程序都需要与运行在其他异构平台上的应用程序集成并进行数据交换。这样的任务通常都是由特殊的方法，如文件传输和分析，消息队列，还有仅适用于某些情况的的API，如IBM的高级程序到程序交流(APPC)等来完成的。在以前，没有一个应用程序通信标准，是独立于平台、组建模型和编程语言的。只有通过Web Service，客户端和服务器才能够自由的用HTTP进行通信，不论两个程序的平台和编程语言是什么。
二、WebService到底是什么？
一言以蔽之：WebService是一种跨编程语言和跨操作系统平台的远程调用技术。
所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。
所谓远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用。
其实可以从多个角度来理解WebService，从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 WebService平台需要一套协议来实现分布式应用程序的创建。任何平台都有它的数据表示方法和类型系统。要实现互操作性，WebService平台必须提供一套标准的类型系统，用于沟通不同平台、编程语言和组件模型中的不同类型系统。Web service平台必须提供一种标准来描述Web service，让客户可以得到足够的信息来调用这个Web service。最后，我们还必须有一种方法来对这个Web service进行远程调用,这种方法实际是一种远程过程调用协议(RPC)。为了达到互操作性，这种RPC协议还必须与平台和编程语言无关。
三、WebService平台技术
XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。
XML+XSD：
WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。
SOAP：
WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。
SOAP协议 = HTTP协议 + XML数据格式
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。
WSDL：
好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。
WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。
WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。
四、WebService开发
WebService开发可以分为服务器端开发和客户端开发两个方面：
服务端开发：把公司内部系统的业务方法发布成WebService服务，供远程合作单位和个人调用。(借助一些WebService框架可以很轻松地把自己的业务对象发布成WebService服务，Java方面的典型WebService框架包括：axis，xfire，cxf等，java ee服务器通常也支持发布WebService服务，例如JBoss。)
客户端开发：调用别人发布的WebService服务，大多数人从事的开发都属于这个方面，例如，调用天气预报WebService服务。（使用厂商的WSDL2Java之类的工具生成静态调用的代理类代码；使用厂商提供的客户端编程API类；使用SUN公司早期标准的jax-rpc开发包；使用SUN公司最新标准的jax-ws开发包。当然SUN已被ORACLE收购)
WebService的工作调用原理：对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我调用这些代理，就可以访问到webservice服务。代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap数据变成返回值返回。对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成soap格式的数据，通过http响应消息回给客户端。
五、适用场合
1、跨防火墙通信：
如果应用程序有成千上万的用户，而且分布在世界各地，那么客户端和服务器之间的通信将是一个棘手的问题。因为客户端和服务器之间通常会有防火墙或者代理服务器。在这种情况下，使用DCOM就不是那么简单，通常也不便于把客户端程序发布到数量如此庞大的每一个用户手中。传统的做法是，选择用浏览器作为客户端，写下一大堆ASP页面，把应用程序的中间层暴露给最终用户。这样做的结果是开发难度大，程序很难维护。如果中间层组件换成WebService的话，就可以从用户界面直接调用中间层组件。从大多数人的经验来看，在一个用户界面和中间层有较多交互的应用程序中，使用WebService这种结构，可以节省花在用户界面编程上20%的开发时间。
2、应用程序集成：
企业级的应用程序开发者都知道，企业里经常都要把用不同语言写成的、在不同平台上运行的各种程序集成起来，而这种集成将花费很大的开发力量。应用程序经常需要从运行在IBM主机上的程序中获取数据；或者把数据发送到主机或UNIX应用程序中去。即使在同一个平台上，不同软件厂商生产的各种软件也常常需要集成起来。通过WebService，可以很容易的集成不同结构的应用程序。
3、B2B集成：
用WebService集成应用程序，可以使公司内部的商务处理更加自动化。但当交易跨越供应商和客户、突破公司的界限时会怎么样呢？跨公司的商务交易集成通常叫做B2B集成。WebService是B2B集成成功的关键。通过WebService，公司可以把关键的商务应用“暴露”给指定的供应商和客户。例如，把电子下单系统和电子发票系统“暴露”出来，客户就可以以电子的方式发送订单，供应商则可以以电子的方式发送原料采购发票。当然，这并不是一个新的概念，EDI(电子文档交换)早就是这样了。但是，WebService的实现要比EDI简单得多，而且WebService运行在Internet上，在世界任何地方都可轻易实现，其运行成本就相对较低。不过，WebService并不像EDI那样，是文档交换或B2B集成的完整解决方案。WebService只是B2B集成的一个关键部分，还需要许多其它的部分才能实现集成。
用WebService来实现B2B集成的最大好处在于可以轻易实现互操作性。只要把商务逻辑“暴露”出来，成为WebService，就可以让任何指定的合作伙伴调用这些商务逻辑，而不管他们的系统在什么平台上运行，使用什么开发语言。这样就大大减少了花在B2B集成上的时间和成本，让许多原本无法承受EDI的中小企业也能实现B2B集成。
4、软件和数据重用： 软件重用是一个很大的主题，重用的形式很多，重用的程度有大有小。最基本的形式是源代码模块或者类一级的重用，一种形式是二进制形式的组件重用。采用WebService应用程序可以用标准的方法把功能和数据“暴露”出来，供其它应用程序使用，达到业务级重用。
六、不适用场合
1、单机应用程序：
目前，企业和个人还使用着很多桌面应用程序。其中一些只需要与本机上的其它程序通信。在这种情况下，最好就不要用WebService，只要用本地的 API就可以了。COM非常适合于在这种情况下工作，因为它既小又快。运行在同一台服务器上的服务器软件也是这样。最好直接用COM或其它本地的API来进行应用程序间的调用。当然WebService也能用在这些场合，但那样不仅消耗太大，而且不会带来任何好处。
2、局域网的同构应用程序：
在许多应用中，所有的程序都是用VB或VC开发的，都在Windows平台下使用COM，都运行在同一个局域网上。例如，有两个服务器应用程序需要相互通信，或者有一个Win32或WinForm的客户程序要连接局域网上另一个服务器的程序。在这些程序里，使用DCOM会比SOAP/HTTP有效得多。与此相类似，如果一个.NET程序要连接到局域网上的另一个.NET程序，应该使用.NETremoting。有趣的是，在.NETremoting 中，也可以指定使用SOAP/HTTP来进行WebService调用。不过最好还是直接通过TCP进行RPC调用，那样会有效得多。
http://blog.csdn.net/wooshn/article/details/8069087
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c110fc9a591cd096a25672b78e080a/" rel="bookmark">
			live555搭建流媒体服务器2--live555源码分析2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 live555搭建流媒体服务器2--live555源码分析2 1. groupSock库和liveMedia概要 在博客《 live555搭建流媒体服务器2--live555源码分析》 中已经介绍了Live555源码的UsageEnvironment库和BasicUsageEnvironment库，下面介绍剩下的两个库。groupSock库是对网络接口的封装，实现数据包的发送和接收。groupSock主要被设计用以支持多播，但它也完全支持单播通信。liveMedia库是Live555最重要的模块。该模块声明了一个抽象类Medium，其他所有类都派生自该类，针对不同的流媒体和编码。 2. liveMedia库详解 首先熟悉liveMedia库中的几个概念：Source、Sink、Filter；Source抽象了数据源，比如通过RTP读取数据。Sink是数据消费者的抽象，比如把接收到数据存储到文件，该文件就是一个Sink。数据的流动可能经过多个Source和Sink。从其它Source接受数据的Source叫做Filters；下面试一个示例： Source1 -&gt; Source2（a Filter） -&gt;Source3（a Filter）-&gt;Sink MediaSink是各种类型的Sink的基类，MediaSource是各种类型Source的基类，各种类型的流媒体格式和编码的支持即是通过对这两个类的派生实现的。 Medium：抽象了基本的接口，包括环境、task、媒体名（fMediumName）和媒体查找函数（lookupByName）以及一些辅助函数，也包括返回当前的环境类UsageEnvironment，以及环境指向下一个TaskToken的指针nextTask等。其中媒体名（fMediumName）是一个字节数组 char fMediumName[mediumNameMaxLen];mediumNameMaxLen等于30。直接继承于Medium下的第二级类有23个，如下图所示： 这里介绍几个常用的： DarwinInjector：作为与DSS服务器交互的接口；
MediaSession：管理一个包含音视频的媒体文件，每个MediaSession使用文件名唯一标识；使用SubSession管理MediaSession中的一个音频流或视频流。因此一个MediaSession可以有多个MediaSubsession，一个管理音频流一个管理视频流。 MediaSink：数据消费者的抽象,把接收到的数据存储到文件；
MediaSource：抽象数据源,如通过RTP读取数据；
RTCPInstance：实现RTCP的通信,RTCP实例；
RTSPClient：实现RTSP请求的发送和响应的解析,根据解析结果创建对应RTP会话；
RTSPServer：RTSP服务器,创建服务器,添加ServerMediaSession；
ServerMediaSession：表示一个会话的数据结构；
ServerMediaSubsession：定义了指向ServerMediaSession的父指针(friend class ServerMediaSession)，指向下个一个对象的指针,(ServerMediaSubsession* fNext)；
3. 以H264码流为例的关键类继承关系 Source ： H264VideoStreamFramer:：H264Or5VideoStreamFramer:：MPEGVideoStreamFramer:：FramedFilter:：FramedSource:：MediaSource:：Medium H264VideoStreamFramer是真正的Souce，它用于从h264文件中读取数据，并组装成帧。在Sink调用GetNextFrame时将帧数据返回给Sink。 Sink：
H264VideoRTPSink::H264Or5VideoRTPSink::VideoRTPSink::MultiFramedRTPSink::RTPSink::MediaSink::Medium Session： H264VideoFileServerMediaSubsession::FileServerMediaSubsession::OnDemandServerMediaSubsession::ServerMediaSubsession ::Medium
SubSession用于完成Souce和Sink的连接，同时用于管理每个媒体流。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7fe312faf144fe55f26856a1b47bc7/" rel="bookmark">
			编译动态库和连接动态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ mkdir 1;cd 1 $ cat &gt;plus.c int plus(int i0, int i1) { return i0 + i1; } $ cat &gt;plus.h int plus(int i0, int i1); $ cat &gt;main.c #include "plus.h" int main(void) { return plus(1,2); } $ cat &gt;Makefile main: main.o libplus.so plus.h gcc -g -L. -o main main.o -lplus rm main.o plus.o main.o: main.c gcc -c -g -o main.o main.c libplus.so: plus.o gcc -g -shared -o libplus.so plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b7fe312faf144fe55f26856a1b47bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6bdfa68baa917f9ac249a3f4369dd0/" rel="bookmark">
			用basicAuth中间件实现身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.服务器代码 var connect = require('connect'); process.stdin.resume(); process.stdin.setEncoding('ascii'); var server = connect(); server.use(connect.basicAuth(function(user,pass,fn){ console.log('1============'); process.stdout.write('allow user \033[96m' + user +'\033[39m' + 'with pass \033[90m' + pass + '\033[39m ? [y/n]:'); process.stdin.once('data',function(data){ if(data[0]=='y'){ fn(null,{username:user}); } else fn(new Error('Unauthorized')); }); })) .use(function(req,res){ console.log('2============'); res.writeHead(200); res.end('welcome to the protected area' + req.remoteUser.username); }); server.listen(3000); 这个代码非常简单，不需要处理获取主页的(url='/',req.method=='GET'的情况)，basicAuth会负责处理，这里通过命令行输入yes,no的形式来处理客户端请求。第一次访问，会弹出要求客户输入用户名，密码的提示框。当第二次访问服务器时，服务器就会记住该用户名密码，并且直接在命令行询问yes or no。如果输入yes，会直接运行第二个中间件（自己写的），然后会向用户返回一个登录成功的提示。 2.运行图解 第一次登录，并输入信息： 服务器反应 返回客户端信息 参考《了不起的Node.js》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0b45cd483b78a144a0ed167c369286/" rel="bookmark">
			autoscan,aclocal,autoheader,automake,autoconf,make
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的例子是在 linux下创建的一个包含多个源文件的c语言项目，其中基本用到了整个autotools自动化工具链（autoscan,aclocal,autoheader,automake,autoconf,make）。如果读者要制作符合GNU标准的开源项目，这是一个不错的开始。 $ mkdir 1 $ cd 1 $ touch main.c plus.c plus.h minus.c minus.h $ cat &gt;main.c #include &lt;stdio.h&gt; #include "plus.h" #include "minus.h" int main(int argc, char **argv) { int i0, i1, i2, i3; i0 = 3; i1 = 2; i2 = plus(i0, i1); i3 = minus(i0, i1); printf("%d plus %d equal to %d\n", i0, i1, i2); printf("%d minus %d equal to %d\n", i0, i1, i3); return 0; } $ cat &gt;plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0b45cd483b78a144a0ed167c369286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cb3dcd02342bb099d7af5214373bd5/" rel="bookmark">
			优秀软件工程师必备的7大特性(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不是每一个程序员都能成为优秀的软件工程师。在过去的6年时间里，我在Ooyala、Quora和now Quip这3个创业公司面试过许许多多挺有发展潜力的“种子选手”，他们都有着5年以上的工作经验，并且曾为类似于谷歌这样的顶级技术公司服务过，但是就 是搞砸了面试。毫无疑问，这些应聘人员都是不错的软件工程师，并且，他们甚至可能很擅长他们目前的工作。我之所以否决他们，只是因为我不认为他们能成为一 名优秀的软件工程师。
我多年的面试、培训和指导经验告诉我，具备一些特殊的品质能让软件工程师更容易在创业环境中取得成功。并且，这些品质在初创企业比在一个更成熟的公司更为关键。因为在一家初创企业： 对产品、软件系统、团队及其文化有一个更为深刻的认识。成功更依赖于团队的表现，而非你自己。当然，如果在一家更大更成熟的公司，你的出色表现可能会成为你向上爬的踏脚石，但是在一家又小又新的公司，这根本无足挂齿。时间是关键因素，一方面是因为初创企业大多没有盈利，另一方面则是相较于那些盘根错节根深蒂固的老牌子公司，敏捷是他们最大的优势。时间有限就意味着你必须马不停蹄、加班加点，不能拖拖拉拉磨磨蹭蹭，也没有太多的时间供你挥霍在需要解决的问题上。 我曾经有幸合作过的最有效率的软件工程师，有着熟练的技术和卓越的决策能力。他们大多内涵以下7种特质： 1.系统调试技巧 编程很大一部分时间其实是花在调试上的。有用户报告紧急问题，尽快将其修复；服务器的CPU出现负载高峰，尽快找出原因；数据莫名遭到破坏，尽快找出罪魁祸首，等等，都是你的工作。而良好的调试技巧则能让我们干净利落地解决这些问题。 在调试时，我们应该用一种科学严谨的思维看待问题：先假设出错的地方，然后用最有效的方法或者最小可重现的情况去验证。此外调试过程还需要涉及各 种的工具：发现瓶颈的分析器、单步执行代码的调试器、缩小回归原因范围的git bisect、交叉分析现状的UNIX命令行等等。 不过，调试的应用范围不仅仅局限于技术领域。如果产品的增长率和使用率趋于平稳，我们该怎么假设和测试用户的行为以调试未来目标的重心？如果一个 团队完不成他们的项目目标，我们该怎么调试才能知道导致项目流产的根本原因是技能不足，团队沟通不畅还是别的其他原因？招聘有的时候并不能尽如人意——你 也知道，大家对于你是如何调试的过程并不能一目了然，不是吗？（关键：先从数据入手） 2.勇于面对未知 作为一名软件工程师，你需要经常专研那些又大又不熟悉的代码库：可能你需要好好研究你正在使用的那个开源工具的代码，才能随心所欲地挥洒自如；又 或者你需要搞清楚其他团队成员写的代码，因为他没有修改时间等等。所以，快速驾驭大型代码库和精通相关区域的能力显得至关重要。而这种能力大部分来自于经 验，通过阅读过大量代码积累的经验。还有一小部分则需要靠我们熟悉能搜索代码库、跳转到相关部分的工具了，以及会查找有关提交历史中的版本控制——这些捷 径都能减少我们去了解新代码所需的时间。如果是在更为成熟的公司，这种勇于面对未知的精神也能让我们受益匪浅，不过不同的是，我们往往只需要专注并精通一 部分代码库就能成果斐然了。 当然，其他非代码领域有时候也需要你去探索。软件工程师常常需要接待客户、与销售人员讨论客户要求的可行性、给新的工程师培训，以及其他领域的很多你甚至完全没有接触过的事宜。在这些经历中成长，会让你受益无穷。 3.对决策的务实态度 可能在一家大规模公司，在代码审查和单元测试坚持己见有助于改善组织平衡。但是在一家初创公司，务实更重要，因为这能让团队快速完成任务。在这里 我所说的务实指的是，知道什么时候应该积极辩论，而一旦有了决策，即便你再不同意，也能一丝不苟地作为团队的一份子认真执行。我曾经看到过因为编码风格而 相互争执的现象，一个说在源代码起码得有80，100，或120个字符和大括号，而另一个觉得应该另起一行。呵呵。我深深地觉得，我们还不如把这些宝贵的 时间和精力用到更重要的决策上。 对决策的指导启发式评估应该侧重于“是否最终能增加团队成功的概率？”。很多因素都会对这个问题产生影响：产品的选择、架构的侧重点、团队的文化、人才结构，等等。我们在决策前最好限定讨论的时间，然后坚决执行，各抒己见。 4.善于运用工具 工欲善其事，必先利其器。工具的合理运用能让我们节约大量的时间，而时间则是我们最重要的资源。高效的工程师常常是那些善于利用工具的人，而这一 点在创业公司尤为重要，因为这里的时间更紧迫。一些大型的组织可能会有专门的工具团队。而在初创公司，你善用工具的能力越强，完成的任务数量就越多。如果 这些工具也为其他团队成员所接受，那么团队生产力将会发生乘数效应。 5.牛逼的多面手 初创企业早期出现的很多问题其实并不需要很专业的知识。具备的技能越多，在解决问题时遇到的瓶颈就越少，哪怕我们只是对这些技能有一个最基本的了 解，还在摸索熟悉技能的过程中。如果前端Web工程师也装备了基本的服务器技术（server skill），那下次再遇到与此相关的问题就不必去请服务器工程师在百忙之中拨冗相见了。而后端工程师，假如会一些基本的HTML、CSS和 JavaScript技能，就能将他所制作的工具设计成一个Web界面，以方便其他团队成员使用，从而不必因为缺乏web设计师而裹足不前。一个成长中的 工程师，应该是那种能顺利使用基本的数据分析工具分析实验数据，而不必受制于数据分析员的多面手。 不过，有一种更欢迎“专家”的例外是，如果是在利基、重技术的环境里，例如启动数据库，那么拥有精深的专业知识工作效率会更高。而且，随着创业公司的发展，对于博而不精的多面手，越到后期，能取代你的人就越多。 6.保持玩家心态，而非受害者心态 在Fred Kofman的《Conscious Business》一书中，他描述了人们对待问题采取的两种不同态度。可以是受害者心态，怨天尤人，责怪他人的不是（项目时间太少、产品推出不当、以及和 队友发生争执等等），通通归咎于外部原因。另一种就是玩家心态，审视自己的能力，一旦确定能做补救，毫不犹豫地贡献自己的能量。虽然短时间内，受害者心态 能抚慰我们受伤的心情，但是从长远角度看，拥有玩家心态的人才能不断进步与发展。 在创业公司工作压力是很大的，并且随着压力程度的增加，人们往往不但不能勇于承担个人责任，反而很容易陷入互相推诿以逃避责任的怪圈。而这样做，我不得不遗憾的说，最后终将导致失望和解聘。 7.不断学习与回顾，持之以恒 研究发现，只要我们有足够的激情和动力，上述种种品质通过学习和培养都是可以后天养成的。而学习这些技巧的所有能量来源于一种叫做“坚忍不拔”的 品质。Angela Lee曾在她的TED演讲《The key to success? Grit》（《成功的关键：坚持》）中，提及这个概念： 坚忍不拔是一种专注于长远目标的激情和毅力。坚持梦想，坚持未来，不是一天两天，也不是一周两周，更不是一个月两个月，而是持续多年，不畏艰辛、勇往直前，为了目标而奋斗。 如果我们也能拥有这种坚忍不拔的品质，愿意投入时间回顾自己的所作所为，那么就能发现自己的薄弱之处和需要改进的地方。然后随着时间的推移，不断进步的你必将会成为一个更为优秀的软件工程师。在早期如果能得到大咖的指点迷津，尽早行进在正确的方向，也能让我们走的更远。 上述这些技能即便是在更为成熟的公司也是能助你一臂之力的，不过在初创公司发挥的作用更大，原因么，上面也有提到，因为初创公司的时间更紧凑。当 然，并不是说不具备这些技能就不是一个好的工程师了，这只能说明，可能你不大适合这种创业环境。但是，如果你立志要成为一个优秀的软件工程师，不要让上面 这7点品质限制你的发展。那么，从现在开始，写个计划学习和提高这些技能吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e35e3433c4b5dce9801035d3fb71f7/" rel="bookmark">
			【教程】OpenCV3.0.0（Alpha）在VS2012下的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要准备：
1. OpenCV 3.0.0
2. Visual Studio2012
第一步：安装OpenCV并设置环境变量
计算机 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量
加入名为OPENCV的变量，值为D:\opencv\opencv\build（依据个人的OpenCV安装路径而定）
在Path变量后追加;%OPENCV%\x86\vc11\bin
注意：
1. 64位系统 = x64
32位系统 = x86
vc11 = vs2012
vc12 = vs2013
如果不注意将vs2012当作vc2012，那么最后程序运行会出现丢失.dll文件的错误，后面设置库目录也要特别注意！
设置好环境变量后，最好注销下计算机，重新登录才能生效。
2. 第二步：在VS2012中新建你的项目
建立一个空项目就好，具体过程略去。
建好工程后，视图 -&gt; 属性管理器，右键Debug，添加新项目属性表
新建名为OpenCVx86.Debug.prop的项目属性表（区分Release的）
双击新建好的OpenCVx86.Debug.props属性表，找到 常规 -&gt; VC++目录 -&gt; 包含目录 下拉后点开编辑，添加如下几项
D:\opencv\opencv\build\include
D:\opencv\opencv\build\include\opencv
D:\opencv\opencv\build\include\opencv2
确定后，点开库目录，编辑，追加如下2项：
D:\opencv\opencv\build\x86\vc11\lib
D:\opencv\opencv\build\x86\vc11\staticlib
确定后，返回VC++目录，找到 链接器 -&gt; 输入 -&gt; 附加依赖项，追加如下项：
opencv_ts300d.lib
opencv_world300d.lib
IlmImfd.lib
libjasperd.lib
libjpegd.lib
libpngd.lib
libtiffd.lib
libwebpd.lib
opencv_calib3d300d.lib
opencv_core300d.lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e35e3433c4b5dce9801035d3fb71f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a5d09c0218cacd92c7c91c0fd9b058/" rel="bookmark">
			软件工程中开发模型的 优缺点以及适应场合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边做边改模型
瀑布模型
快速原型模型
增量模型
螺旋模型
思
想
不断的修正版本不断的供用户使用，如果出现错误或是新的需求又不断的修改代码。
软件的开发严格的按照线性方式进行，当前活动的工作结果，实施完成所需要的工作结果需要验证，如果验证通过，则结果作为下一项活动的输入，继续。否则返回。
快速原型模型利用的是原型辅助软件开发的一种思想。经过简单、快速的分析，快速实现一个原型，用户与开发人员在试用原型过程中加强通信与反馈，通过反复评价和改进原型，减少误解，弥补漏洞，适应变化，最终提高软件质量。
软件被看作是一系列的增量构建来设计、实现、集成和测试，每一个构建由多种相互作用的模块所形成的提供特定功能呢的代码片段构成。 开发出一部分就向用户展示一部分，及早的发现问题。先开发一个原型模型的软件，完成模型的主要功能。展示给用户征求意见。
这种模型的每一个周期都包括需求定义、风险分析、工程实现和评审4个阶段，由这4个阶段进行迭代。
优
点
在提供给用户使用后，如果程序出现错误，或者用户提出新的要求，开发人员重新修改代码，直到用户满意为止。
一种有效的管理视图。每项开发活动均处于一个质量环节。文档驱动，以项目阶段评审和文档控制为手段有效的对整个开发过程进行指导。
(1)快速模型克服瀑布模型的特点，减少由于软件需求不明确带来的开发风险，具有显著的效果 。(2)能快速吸引用户，从而抢占市场。
1.缩短时间
2.开发人员与用户可以通过原型充分的交流；
3.有利于用户的培训和开发的同步。
4.加入构建必须不破坏已构造好的体系结构。
5.模型的灵活性可以使其适应需求的变化
(1)可以在项目的各个阶段进行变更（2）可以分段来构建大型系统，使成本计算变得简单、容易。（3）用户参与开发，保证项目不偏离正确方向。
缺
点
缺少规划和设计环节。忽略需求环节，风险大。周期长费用高。
缺乏灵活性，太过于理想化。 如果开发其中，客户难以明确需求，需求错误在后期就难以纠正。
(1)没有考虑软件的整体质量和长期的可维护性。(2)这种模型在大部分情况下是不适合的，采用该模型往往是为了演示功能的需要或它的方便性。(3)由于达不到质量要求可能被抛弃，而采用新的模型重新设计。
很容易退化为边做边改模型
（1）不能让用户确信这种演化方法结果是可控的。（2）建设周期长
适
用
场
合
对于需求非常简单和容易明白，软件期望的功能行为容易定义，实现的成功或失败容易检验的工程可以使用这种模型。
适合于客户的需求较明确的情况下。
用户需求不明确、小型或是交互型式的系统、大型系统的某些部分
技术风险较大、用户需求较为稳定的软件系统
适合于大型复杂的系统
迭代模型
喷泉模型
敏捷模型
混合模式
思
想
整个开发工作被组织为一系列的短小的、
固定长度（如3周）的小项目，被称为一系列的迭代。
每一次迭代都包括了需求分析、设计、实现与测试
软件开发过程的各个阶段是相互迭代的、无间歇的。软件的某个部分常常被重复工作多次，相关对象在每次迭代中加入渐近的软件成分。
把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。
把几种不同模型组合成一种混合模型，它允许一个项目能沿着最有效的路径发展，这就是过程开发模型（或混合模型）。实际上，一些软件开发单位都是使用几种不同的开发方法组成他们自己的混合模型。
优
点
降低风险、得到早期用户反馈、持续的测试和集成、使用变更、提高复用性
可以提高软件项目开发效率，节省开发时间。
紧密协作、面对面的沟通
给企业管理者和开发者提供了一个舞台，使每个模型的长处得到发挥
缺点
项目风险可能会很高
不利于项目管理
文档少
对企业的管理和技术都提出了更高的要求
适用场合
早期需求变化很大，项目管理者和软件研发团队素质较高
面向对象的软件开发过程
适合小型项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a5d09c0218cacd92c7c91c0fd9b058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f49a857d597e801f33a6c166970cae6/" rel="bookmark">
			统一过程模型（RUP/UP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一过程（RUP/UP，Rational Unified Process）是一种以用例驱动、以体系结构为核心、迭代及增量的软件过程模型，由UML方法和工具支持，广泛应用于各类面向对象项目。RUP是由Rational公司开发并维护，和一系列软件开发工具紧密集成。RUP蕴含了大量优秀的实践方法，如：迭代式软件开发、需求管理、基于构件的构架应用、建立可视化的软件模型、软件质量验证、软件变更控制等。
如上图所示，RUP是按照二维结构进行组织的。其中横轴按时间组织，显示RUP的动态特征，通过迭代式软件开发的周期、阶段、迭代和里程碑等动态信息表示；纵轴按内容组织，显示RUP的静态特征，通过过程的构建、活动、工作流、产品和角色等静态概念来描述系统。
RUP的静态结构包括6个核心工作流（业务建模、需求、分析设计、实现、测试、部署）和3个核心支持工作流（配置与变更管理、项目管理和环境）。
业务建模工作流产生五个工作产品，即商业逻辑建模（USE CASE）(ROSE)、业务需求说明书（MS WORD）、专业词汇表（英汉对照）（MS WORD）、风险说明（MS WORD）、复审说明书。需求工作流为了确保开发人员构建正确的系统，要了解目标组织的结构及机制；要明确目标组织中当前存在的问题并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求，建立系统需求模型：用例图（表示系统的功能）。分析设计工作流将系统需求转换为未来系统的设计，逐步开放强壮的系统架构，使设计适合于实施环境，为提高性能而进行设计。实施工作流要定义代码结构，以构件的方式实施类和对象，对已开发的构件按类和单元来测试，并且将结果集成到可执行的系统中。测试仅限于对各个类进行单元测试。测试工作流包括核实对象之间的交互，核实软件的所有构件是否正确集成，核实所有需求是否已经正确实施，确定缺陷，确保在部署软件之前将风险降到最低。
RUP模型采用迭代开发，通过多次执行不同的开发工作流，逐步确定一部分需求分析和风险，在设计、实现并确认这部分后，再去做下一部分的需求分析、设计、实现和确认工作，依次进行下去，直到整个项目完成，这样能够在逐步集成中更好的理解需求，构建一个健壮的体系结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c79c185b29631530f676e4023b43f50/" rel="bookmark">
			转载： Windows批处理bat脚本：退出进程或者杀死进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; taskkill or ntsd
taskkill /F /IM notepad.exe
ntsd -c q -pn excel.exe
C:\Documents and Settings\Administrator&gt;taskkill /?
TASKKILL [/S system [/U username [/P [password]]]]
{ [/FI filter] [/PID processid | /IM imagename] } [/F] [/T]
描述:
这个命令行工具可用来结束至少一个进程。可以根据进程 id 或图像名来结束进程。
参数列表:
/S system 指定要连接到的远程系统。
/U [domain\]user 指定应该在哪个用户上下文执行这个命令。
/P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。
/F 指定要强行终止进程。
/FI filter 指定筛选进或筛选出查询的的任务。
/PID process id 指定要终止的进程的 PID。
/IM image name 指定要终止的进程的图像名。通配符 '*'可用来指定所有图像名。
/T Tree kill: 终止指定的进程和任何由此启动的子进程。
/? 显示帮助/用法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c79c185b29631530f676e4023b43f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f852fed6fe42a04a3be2af41f1cb0a60/" rel="bookmark">
			BroadcastReceiver之动态广播  demo&#43;笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android中，Broadcast是一种广泛运用在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的 Broadcast进行过滤接收并响应的一类组件(任何一个程序都能接收到广播)。下面将详细的阐述如何发送Broadcast和使用BroadcastReceiver过滤接收的过程 首先在需要发送信息的地方，把要发送的信息和用于过滤的信息(如Action、Category)装入一个Intent对象，然后通过调用 Context.sendBroadcast()方法，把Intent对象以广播方式发送出去。
当Intent发送以后，所有已经注册的广播接收器会检查注册时的IntentFilter是否与发送的Intent相匹配，若匹配则就会调用BroadcastReceiver的onReceive()方法。所以当我们定义一个BroadcastReceiver的时候，都需要实现onReceive()方法。
实例
A.编写广播接受者的发送方
1.布局文件 点击发送广播
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" android:onClick="send" android:text="send" /&gt; &lt;/RelativeLayout&gt; 2编写广播接受者 package com.example.broadcasetsend; import android.os.Bundle; import android.app.Activity; import android.content.Intent; import android.view.Menu; import android.view.View; public class MainActivity extends Activity { private static final String broadcast = "com.chj"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } //自定义广播 public void send(View view) { Intent intent = new Intent(); intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f852fed6fe42a04a3be2af41f1cb0a60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3729480232c1ad85ef9e6ae96020a9/" rel="bookmark">
			教你找电影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几年前当我还是一个小白的时候，在网上常常会看到一些教人找电影的攻略，他们推荐的无非是电影天堂、电影FM、人人影视这些烂大街的网站。而实际上，这些网站明显无法满足任何一位影迷的需求。这几年我好不容易脱离小白阶段，并且做资源整合也有一段时间了，通过自身积累的一些经验，又请教了几位同行，最后整理出这篇文章，介绍国内外一些强大的资源网站，涵盖多种搜索电影资源的方法，希望对你们有所帮助。 没有牛逼的资源帝，只有勤劳的搬运工。 首先要声明一点，我不会推荐PT站或者其他需要邀请注册的网站，我提到的一定都是无需注册或者开放注册的、简单实用的网站 如果你不是那么热爱电影，只是闲暇之余看看热门的新片/美剧，不求画质与速度的话，那么下面这几个网站已经能满足你了 电影天堂：http://www.xiaopian.com/ 飘花电影：http://www.piaohua.com/ 6V电影：http://www.6vdy.com/ 圣城家园：http://www.cnscg.org/ 电影FM：http://dianying.fm/category/ 人人影视（需注册）：http://www.yyets.com/（最强大的除了美剧资源，HR-HDTV格式的片源也是人人影视的一大特色，体积小，一般是2G左右，但是画质不错，甚至在电视上播放也不会让你失望） 这几个简单好用，但是很多新片都有重复的，基本上掌握一两个就够用了 如果你有以下任一需求：1、爱看经典老电影，2、爱看高清画质的电影，3、想尽快拿到新片资源。最好学会用这些网站 ED2000：http://www.ed2000.com/（网站提供的都是电驴链接，电影资源很强大，游戏/音乐/软件什么乱七八糟的都有） SimpleCD：http://www.simplecd.me/（有电驴/种子/网盘等资源链接，很有名气的一个站） BT天堂：http://www.bttiantang.com/（片子很多，优点是对于热门电影来说，它提供了各大压制组/各版本的资源选择，BDRip/720p/1080p等等，另外可以通过IMDB编号来搜索影片） BT之家：http://bbs.1lou.com/（综合性很强，在电影方面主要是中字熟肉，方便手机/iPad等移动设备观看） 顶好精品论坛（需注册）：http://bmdruchinyan.com/（重点推荐，影片分类很牛逼，比如著名导演的合集/TOP 250合集/三大电影节合集/CC标准收藏合集） 大米论坛（需注册）：http://www.iminisd.com/forum.php（据说国产片/港产片资源很强大） KICKASS：http://kickass.to/（俗称“踢屁股”，也是个综合性种子站，新片老片应有尽有） RARBG：http://www.rarbg.com/torrents.php（和KICKASS差不多，但是新片的发布速度貌似更快些，而且网页排版很好看） Torrentz：http://torrentz.eu/（综合型种子搜索引擎，很多资源帝都爱用，被称为“万金油BT站”） SeeHD：http://www.seehd.org/（以高清资源为主，720p/1080p/Remux/蓝光原盘，适合收藏党） BTSPREAD：http://www.btspread.com/（个人主要用来转换BT文件和磁力链接，也有种子搜索引擎，可以搜番号） 以上网站已经能满足大部分影迷的需求了 什么？你说你逼格比较高？那也不要紧，下面还有一些适合淘冷门电影的网站。倘若碰到一些豆瓣评分人数不足的，甚至是没有条目的电影，这些网站可能会有奇效 Bitsnoop：http://bitsnoop.com/（资源容量高达28PB，磁力站，可以配合上面的BTSPREAD转成种子） BT Kitty：http://btkitty.org/（资源容量有24PB，虽然不及上面那个，但是也很牛逼了） 海盗湾：http://thepiratebay.ee/（自称是目前世界上最大的BT种子服务器） BTDigg：https://btdigg.org/（磁力站，搜索关键字的能力较强，个人最爱用的网站） ulozto：http://www.ulozto.net/（据说搜捷克电影很好用，我没试过） rutracker：http://rutracker.org/forum/index.php（俄罗斯BT站） Foofind（这是一个小软件，需下载安装，但我必须提一下这款神器，搜索引擎非常强大。但是使用比较麻烦，软件本身下载可能没速度，我的做法是下载的文件链接复制到迅雷，新建任务下载。总之，真的一级棒。感兴趣的可以下载这个安装包。度盘：http://pan.baidu.com/s/1ntiIcsD） 如果上述网站依旧找不到你要的电影，那就得自己动手去其他地方找咯，继续介绍一些找电影的方法 Google：懒人一般不会用，但除了网站之外，谷歌引擎是最靠谱的找片方法了。搜索片名+download/torrent/magnet/ed2k等后缀，能找到不少冷门电影 豆瓣条目：在豆瓣电影搜索片名之后，该影片的简介页面，就叫豆瓣条目。很多人忽视了这块地方，1、冷门电影的话，在条目的讨论区，偶尔会有热心网友给出资源下载，2、短片的话，在条目的短评区，会有热心网友给出在线观看地址 豆瓣小组：这个社区可以说是高手在民间，比如“第三世界电影资源”这种小组，里面会有很多珍贵片源，玩豆瓣的朋友可以慢慢发掘 豆瓣助手：也叫“豆藤”，一款可以安装在火狐/chrome的浏览器插件，可以搜索电影/音乐/电子书，方便之处在于资源列表会显示在网页右侧，但是搜索引擎不算很强，教程：http://t.cn/7MjEo 百度贴吧：贴吧精品区里有不少好东西，比如“北野武吧”就有不少粉丝上传的纪录片资源，“百度网盘吧”“360云盘吧”这种，偶尔会有人扔出一些容量几个T的资源合集 115圈子：作为曾经国内网盘的龙头，115的资源量自然不可小看，感兴趣的可以去找一下各类型的资源圈子，能找到不少好东西 新浪微博：关注微博上的资源圈子，会常常有惊喜哦，除了本人的@电影贩 之外，顺便推荐几个博主，@蓝影网 @猫叔Mack @狼魄乾坤 @蓝影屋 @资源人龙骧 盘搜工具：现在有不少网盘搜索的引擎，个人觉得没多少用处了，就算能搜出来的也大多是死链，故不推荐 关于资源搜索的小技巧，这个才是重中之重，切勿错过 有些片子不一定搜一个片名就能搜出来，国内的网站主要搜索中文名，外网主要搜索外文名。而几乎所有的片名，都可以在对应的豆瓣条目简介里面找到，当然IMDB条目也有 国内的网站当然比较简单，比如《血色将至》这部片，你可以搜“血色将至”、“血色黑金”、“There Will Be Blood” 重点说下国外的网站，很多非英语片，除了中文译名之外，都会有两个片名，举个例子 《精疲力尽》这部片，你可以搜英文名“Breathless”、法文名“à bout de souffle” 《七武士》这部片，你可以搜中文名“七武士”，日文名“七人の侍”，英文名“Seven Samurai”，但最好用的方法是搜索日语发音“Shichinin no samurai”，最后一种方法是在外网搜索日语片的首选 有些名字相同的片子，可以在后面加上年份，方便区分，比如希区柯克的《惊魂记》，可以搜“psycho 1960” 想搜出高清版本的，可搜索片名+720p/1080p/bluray等后缀 搜电影原声，可搜索片名+soundtrack/OST 在谷歌上搜索某个导演的合集，可以加上collection这个后缀，比如搜伍迪艾伦的，“Woody Allen collection”。搜冷门片，可以用刚刚提到的方法，搜索片名+download/torrent/magnet/ed2k等后缀 最后说说关于字幕的问题 寻找中文字幕，射手网：www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3729480232c1ad85ef9e6ae96020a9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/496/">«</a>
	<span class="pagination__item pagination__item--current">497/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/498/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>