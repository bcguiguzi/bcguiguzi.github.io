<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3197d2d487dc6921cae245ac8403ce9/" rel="bookmark">
			性能调优简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能调优 CPU 平均负载 查看
uptime, w, top 定义
单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。即单位时间的活跃进程数 可运行状态的进程
正在使用cpu或者正在等待cpu的进程，即ps aux命令下STAT处于R状态的进程 不可中断状态的进程
处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令D状态的进程 判断指标
理想状态
每个cpu上都有一个活跃进程，即平均负载数等于cpu数 过载经验值
一般来说,当平均负载高于cpu数量70%的时候,就应该引起重视了. 一旦负载过高,就可能导致响应变慢,进而影响服务的正常功能 CPU使用率 查看
top, pidstat, grep ^cpu /proc/stat 定义
除了空闲时间外的其他时间占总 CPU 时间的百分比 字段
us (user) - 用户态cpu时间. 注意它不包括下面的nice时间, 但包括了guest时间ni (nice) - 低优先级用户cpu时间.也就是进程的nice值被调到了1-19之间时的cpu时间sy (system) - 内核态cpu时间id (idle) - 空闲时间. 注意, 它不包括等待I/O时间wa (iowait) - 等待I/O的cpu时间hi (irq) - 处理硬中断的cpu时间si (softirq) - 处理软中断的cpu时间st (steal) - 当系统运行在虚拟机中的时候, 被其他虚拟机占用的cpu时间guest - 通过虚拟化运行其他操作系统的时间, 也就是运行虚拟机的时间gnice (guest nice) - 低优先级运行虚拟机的时间 优化 CPU绑定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3197d2d487dc6921cae245ac8403ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252cd186450981266b6fd18f0a551715/" rel="bookmark">
			阿里云简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云 云服务器ECS 介绍 云服务器(Elastic Compute Service，简称ECS)是阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS(Infrastructure as a Service)级别云计算服务 优势 无需自建机房，无需采购以及配置硬件设施分钟级交付，快速部署，缩短应用上线周期快速接入部署在全球范围内的数据中心和BGP机房成本透明，按需使用，支持根据业务波动随时扩展和释放资源提供GPU和FPGA等异构计算服务器、弹性裸金属服务器以及通用的x86架构服务器支持通过内网访问其他阿里云服务，形成丰富的行业解决方案，降低公网流量成本提供虚拟防火墙、角色权限控制、内网隔离、防病毒攻击及流量监控等多重安全方案提供性能监控框架和主动运维体系提供行业通用标准API，提高易用性和适用性 产品架构 实例
等同于一台虚拟服务器，内含CPU、内存、操作系统、网络配置、磁盘等基础的计算组件实例的计算性能、内存性能和适用业务场景由实例规格决定，其具体性能指标包括实例vCPU核数、内存大小、网络性能等 镜像
提供实例的操作系统、初始化应用数据及预装的软件。操作系统支持多种Linux发行版和多种Windows Server版本 块存储
块设备类型产品，具备高性能和低时延的特性。提供基于分布式存储架构的云盘、共享块存储以及基于物理机本地存储的本地盘 快照
某一时间点一块云盘或共享块存储的数据状态文件。常用于数据备份、数据恢复和制作自定义镜像等 安全组
由同一地域内具有相同保护需求并相互信任的实例组成，是一种虚拟防火墙，用于设置实例的网络访问控制 网络
专有网络(Virtual Private Cloud)
逻辑上彻底隔离的云上私有网络。您可以自行分配私网IP地址范围、配置路由表和网关等 经典网络
所有经典网络类型实例都建立在一个共用的基础网络上。由阿里云统一规划和管理网络配置 购买 登录阿里云
www.aliyun.com 选择合适的配置
弹性计算 -&gt; 云服务器ECS -&gt; 立即购买 -&gt; 选择合适的配置 -&gt; 下一步 配置网络
系统配置
确认订单
控制台 首页右上角‘控制台’-&gt;左边菜单-&gt;云服务器RCS-&gt;实例与镜像-&gt;实例 安全组 为了服务器安全, 我们可以给实例绑定安全组, 通常情况下创建的ECS实例默认绑定了系统默认安全组
系统默认安全组
入方向
仅ICMP协议、SSH 22端口、RDP 3389端口的放行规则 出方向
允许所有访问 自定义安全组
初始
出方向： 允许所有访问入方向： 拒绝所有访问 自定义加入放行规则
远程连接 使用xshell等远程连接工具, 通过公网IP来连接 部署服务 与虚拟机操作 一致 绑定域名 购买域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252cd186450981266b6fd18f0a551715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b6cea68e2ce2632f2e31f6ef5e052a/" rel="bookmark">
			服务集群简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群 简介 如何提升服务器性能 增加服务器硬件如CPU、内存或换配置更高的服务器来提升单机的性能
很快会达到瓶颈, 而且成本和性能不成正比 应用分离，如主机A(Apache) + 主机B(MySQL)
依然会达到瓶颈 采用集群技术
LB
Load Balancing负载均衡即多个服务器同时提供相同的服务,并分担压力,至少三台服务器 HA
High Availability高可用又称双机Active/Standby,即一个提供服务,另一个保持等待状态,至少两台服务器 HPC
High Performance Computing高性能计算高性能集群上运行的应用程序一般使用并行算法,把一个大的普通问题根据一定的规则分为许多小的子问题,在集群内的不同节点上进行计算,而这些小问题的处理结果,经过处理可合并为原问题的最终结果 整个集群提供一个唯一的访问入口,对最终用户透明
HA集群 1.keepalived
基于vrrp协议,常用于实现前端调度器的高可用, 轻量级, 不需要共享存储 2.corosync+pacemaker
实现的是Service的高可用, 需要共享存储, 一般用于多个节点 3.Heartbeat
是基于主机或网络的服务的高可用方式, 不常用 LB集群 硬件
F5 BIG-IP。性能好,成本高 软件
LVS、Nginx、Haproxy、SLB LB集群 LVS 抗负载能力强、性能高,能达到F5硬件的60%；对内存和cpu资源消耗比较低工作在网络4层,通过vrrp协议转发(仅作分发之用),具体的流量由linux内核处理,因此没有流量的产生稳定性、可靠性好,自身有完美的热备方案；(如：LVS+Keepalived)应用范围比较广,可以对所有应用做负载均衡不支持正则处理,不能做动静分离支持负载均衡算法：rr(轮循)、wrr(带权轮循)、lc(最小连接)、wlc(权重最小连接)配置复杂,对网络依赖比较大 Nginx 工作在网络的7层之上,可以针对http应用做一些分流的策略,比如针对域名、目录结构Nginx对网络的依赖比较小,理论上能ping通就就能进行负载功能Nginx安装和配置比较简单,测试起来比较方便也可以承担高的负载压力且稳定,一般能支撑超过1万次的并发对后端服务器的健康检查,只支持通过端口来检测,不支持通过url来检测Nginx对请求的异步处理可以帮助节点服务器减轻负载Nginx仅能支持http、https和Email协议,适用范围较小不支持Session的直接保持,但能通过ip_hash来解决支持负载均衡算法：Round-robin(轮循),Weight-round-robin(带权轮循),Ip-hash(Ip哈希)Nginx还能做Web服务器即Cache功能 Haproxy 支持两种代理模式：TCP(四层)和HTTP(七层),支持虚拟主机能够补充Nginx的一些缺点比如Session的保持,Cookie的引导等工作支持url检测,后端的服务器出问题的检测会有很好的帮助更多的负载均衡策略：动态加权轮循(Dynamic Round Robin),加权源地址哈希(Weighted Source Hash),加权URL哈希和加权参数哈希(Weighted Parameter Hash)单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度HAProxy可以对Mysql进行负载均衡,对后端的DB节点进行检测和负载均衡支持负载均衡算法：Round-robin(轮循)、Weight-round-robin(带权轮循)、source(原地址保持)、RI(请求URL)、rdp-cookie(根据cookie)不能做Web服务器和Cache LVS介绍 LVS概述 Linux Virtual Server,也就是Linux虚拟服务器，简称LVS是Linux内核的一部分,因此性能高它不真正提供服务,但它接受客户的访问,为整个集群提供一个唯一的入口。虚拟服务器再和真实服务器通信真实服务器(Real Server):它真正提供服务,集群中每个Real Server可以是一台物理主机,也可以是虚拟机 中文文档 http://linuxvirtualserver.org/zh/index.html LVS相关术语 DS
Director Server。指的是前端负载均衡器节点 RS
Real Server。后端真实的工作服务器 VIP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b6cea68e2ce2632f2e31f6ef5e052a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bb994035cf1d21c608932bf10edc66/" rel="bookmark">
			微服务架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务架构 概述 介绍 http://c.biancheng.net/springcloud/micro-service.html
微服务架构(Microservice Architecture)是一种架构概念，旨在通过将功能分解到各个离散的服务中，从而降低系统的耦合性，并提供更加灵活的服务支持
概念
把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个应用程序，从而满足服务等级协议 定义
围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代 本质
用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题 优点
复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高 缺点(挑战)
系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等 系统架构业务驱动力 提高敏捷性
及时响应业务需求，促进企业发展 提升用户体验
提升用户体验，减少用户流失 降低成本
降低增加产品、客户或业务方案的成本 传统开发模式 介绍
和Microservice相对应的，这种方式一般被称为Monolithic(单体式开发)所有的功能打包在一个WAR包里，基本没有外部依赖，部署在一个JEE容器(Tomcat，JBoss，WebLogic)里，包含了DO/DAO，Service，UI等所有逻辑 架构
优点
开发简单，集中式管理基本不会重复开发功能都在本地，没有分布式的管理和调用消耗 缺点
效率低
开发都在同一个项目改代码，相互等待，冲突不断 维护难
代码功功能耦合在一起，新人不知道何从下手 不灵活
构建时间长，任何小修改都要重构整个项目，耗时 稳定性差
一个微小的问题，都可能导致整个应用挂掉 扩展性不够
无法满足高并发下的业务需求 微服务的特征 一些独立的服务共同组成系统单独部署，跑在自己的进程中每个服务为独立的业务开发分布式管理非常强调隔离性 实践微服务 客户端如何访问这些服务
一般在后台N个服务和UI之间会配置一个代理或者叫API Gateway
代理作用
提供统一服务入口，让微服务对前台透明聚合后台的服务，节省流量，提升性能提供安全，过滤，流控等API管理功能 API Gateway也有可能成为单点故障或性能瓶颈
每个服务之间如何通信
同步调用
REST（JAX-RS，Spring Boot）RPC（Thrift, Dubbo） 异步消息调用(Kafka, Notify, MetaQ)
如此多的服务，如何实现？
通过zookeeper等类似技术做服务注册信息的分布式管理
客户端做
当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，如Dubbo 服务端做
服务调用者通过ZK寻址，根据可定制算法， 找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK会发通知给服务客户端优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多 服务挂了，如何解决
重试机制、限流、熔断机制、负载均衡、降级(本地缓存) 微服务项目-mall 项目地址 https://gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62bb994035cf1d21c608932bf10edc66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25749acc51ef160062baaebde0a5106a/" rel="bookmark">
			文件管理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件管理 文件介绍 FHS Filesystem Hierarchy Standard 文件系统目录标准 文件特点 一切皆文件文件名严格区分大小写 Linux文件类型 普通文件(文本文件,二进制文件,压缩文件,视频,图片…)
d
目录文件（蓝色） b
块设备文件（存储设备硬盘，U盘 /dev/sda, /dev/sda1） c
字符设备文件（打印机，终端 /dev/tty1, /dev/zero） l
链接文件（淡蓝色） s
套接字文件 p
管道文件 目录结构 特点
linux
以单根的方式组织文件 /倒立的树状结构 Windows
以多根的方式组织文件 C：\ D：\ E：\ 常见目录
/
根目录，linux最顶级的目录 /bin
存放的是系统的命令,用户命令 /sbin
存放的是管理命令 /boot
存放的是系统的启动文件及内核 /dev
设备文件目录 /etc
配置文件目录 /root
超级管理员的家目录 /home
普通用户的家目录 /lib
系统库文件主目录 /media
挂载点目录，移动设备 /mnt
挂载点目录 /opt
可选目录，第三方程序的安装目录 /proc
虚拟的文件系统，反映出来的是内核，进程信息或实时状态 /sys
跟硬件设备相关的属性映射文件 /run
与程序运行相关的信息,如进程号,套接字文件等 /tmp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25749acc51ef160062baaebde0a5106a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7062e5eff1720da66ca40f7dd498935/" rel="bookmark">
			系统管理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统管理 Linux基础 走进Linux Linux历史
Linux之父：Linus Torvalds林纳斯.托瓦兹1994 年，Torvalds 发布 Linux-v1.01996 年，Torvalds 发布 Linux-v2.0，确定了 Linux 的吉祥物：企鹅 常见Linux发行版
Linux Mint、Ubuntu 乌班图、Debian GNU、openSUSE、CentOS、Redhat CentOS
最新版本：centos stream 9；使用版本：centos linux 7红帽 red-hat IBM （红帽认证：RHCSA&gt;RHCE&gt;RHCA 使用红帽收费版rhel）https： #www.centos.org/download/ 服务器简介
IDC：互联网数据中心
机柜：用来存放计算机和相关控制设备的物件
物理服务器：机架式服务器、塔式服务器、刀片式服务器、机柜式服务器
云服务器：公有云、私有云、混合云、容器云
企业通道机（堡垒机、跳板机）：登录功能、账号管理、身份认证、资源授权、访问控制
华为云服务器
www.huaweicloud.com 注册 -&gt; 登录 -&gt; 实名认证 -&gt; 绑定邮箱 -&gt; 开发者免费试用专区
创建实例（实例==云服务器ECS）
控制台 -&gt; 选择服务器位置 -&gt; 服务列表 -&gt; 弹性云服务器ECS -&gt; 更多
云服务器-ECS；公网IP-EIP；私网IP-VPC
系统安装 VMware使用
创建虚拟机
文件 -&gt; 新建虚拟机 -&gt; 自定义-&gt; 兼容性与版本匹配 -&gt; 稍后安装 -&gt; Linux cenos 7 -&gt; 自定义名称位置 -&gt; 处理器数量不超过电脑本身 -&gt; 内存不超过电脑本身 -&gt; 网络地址转换 -&gt; lsi logic-scsi -&gt; 创建新虚拟磁盘 -&gt; 拆分成多个文件 -&gt; 自定义文件位置 -&gt; 确认完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7062e5eff1720da66ca40f7dd498935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edf4f2167f8be5d96d1493cbf716492/" rel="bookmark">
			【数电实验】随机数生成电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计任务要求 1. 设计并实现一个随机数生成电路，每 2 秒 随机生成一个 0~999 之间的数 字，并在数码管上显示生成的随机数。2. 为系统设置一个复位键，复位后数码管显示“000”，2 秒后再开始每 2 秒 生成并显示随机数，要求使用按键复位。3. 实验板上输入时钟选择 1kHz 或更高的频率。 二、设计思路 随机数产生：设一个变量f为vector(5 downto 0)，随时钟进行计数，其中的，每次抽取其中四位进行相邻位异或运算产生新的数作为这一位数。
如第一个数的有四位，则取f的0~3位，第二个数，则取f的1~4位，第三个数，则取f的2~5位。
第一位数有四位，如第一位数的第0位，则为从取出来的f的0~3位的第0位和第1位异或，第1位，则为从f中取出来的第1位和第2位异或，第2位则为从f中取出来的第2位和第3位异或，第三位则为第3位和第0位异或；第二位数有四位，第0位，则为从取出来的f的1~4位的，第1位和第2位异或，第1位，则为从f中取出来的第2位和第3位异或，第2位则为从f中取出来的第3位和第4位异或，第三位则为第4位和第1位异或；其他以此类推产生随机数。
在译码电路通过对译码电路的的10~15进行赋值0~9，使得16个数都有对应的值。
2.1总体电路为： 输入信号1kHz，对时钟信号进行2000分频，使得数码管能保持2秒不变，通过随机数产生后，通过译码电路，使用时钟频率1kHz进行扫描，使三个数码管交替变亮让肉眼觉得是三个同时亮。
2.2模块划分 2.3总体框图 三、VHDL代码 3.1 2000分频模块 library ieee; --库和程序包声明 use ieee.std_logic_1164.all; use ieee.std_logic_unsigned.all; entity div2000 is --2000分频器实体描述 port( clk: in std_logic; --时钟输入端口 clear: in std_logic; --复位键输入端口 clk_out:out std_logic); --时钟分频后输出端口 end div2000; architecture a of div2000 is --结构体描述 signal tmp: integer range 0 to 999; --整型数，用来记录分频 signal clktmp: std_logic; --信号定义，只能是储存时钟信号 begin process(clear,clk) begin if clear='1' then --如果按下复位键，分频计数归零，重新开始计数 tmp&lt;=0; elsif clk'event and clk='1' then if tmp=999 then --从0计数到999，则信号反转一下 tmp&lt;=0;clktmp&lt;=not clktmp; else tmp&lt;=tmp+1; end if; end if; end process; clk_out&lt;=clktmp; end a; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edf4f2167f8be5d96d1493cbf716492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6392b33bf8537d528da972e44419be07/" rel="bookmark">
			剑指 Offer 30. 包含min函数的栈（LeetCode 115.最小栈）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接： https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/https://leetcode.cn/problems/min-stack/ 解法1：自定义栈类，链表实现——只需在普通栈（的每个节点）中保存一个minv记录最小值，每次push时更新即可
解法1代码： class MinStack { struct Node { int val; int minv; Node* nextn; Node(int t_val, int t_minv): val(t_val), minv(t_minv), nextn(nullptr) { } }; private: Node* head; // head 来表示栈顶 public: MinStack() { head = nullptr; } ~MinStack() { while (head != nullptr) { Node* it = head; head = head-&gt;nextn; delete it; it = nullptr; } } void push(int t_val) { if(head == nullptr) { head = new Node{t_val, t_val}; } else { int tmp_min = t_val &lt; head-&gt;minv ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6392b33bf8537d528da972e44419be07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbef4b6ecf146aac5e01f5a93e75499/" rel="bookmark">
			Educational Codeforces Round 124 (Rated for Div. 2) CD题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C-Fault-tolerant Network 题目大意：
有两列主机，每一列的主机相邻之间有网络连线，但是两列之间的主机没有网络连线，现在将两列之间的主机进行连接，使得任意一台主机断开后整个网络还是能连通。输出最小的费用，连接两台主机的费用为 ∣ a i − b i ∣ |a_i-b_i| ∣ai​−bi​∣
思路：
显然每一列的头尾主机都要与另一列有连接。
如果只是贪心地求出头尾主机连接对面主机的最小费用，可能会存在连接重合或者不是最优解的情况。
比如有的时候连接两条不是最小费用的线比连接三条最小费用的线花费更少。
因为只有四台主机需要连接，所以直接枚举这四台主机的连接情况即可，一个主机对应三种连接情况：连对面第一台，连对面最后一台，连对面中间花费最小的一台。
枚举第一列的头尾主机连接后就可以确定另一列的头尾主机怎么连了。
AC代码：
#include &lt;bits/stdc++.h&gt; const long long inf = 1e18; const int N = 2e5 + 5; using namespace std; int a[N], b[N]; long long ca1[4], ca2[4], cb1[4], cb2[4]; void solve() { int n; long long ans = inf; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; ca1[1] = abs(a[1] - b[1]); ca1[3] = abs(a[1] - b[n]); ca2[1] = abs(a[n] - b[1]); ca2[3] = abs(a[n] - b[n]); cb1[1] = abs(b[1] - a[1]); cb1[3] = abs(b[1] - a[n]); cb2[1] = abs(b[n] - a[1]); cb2[3] = abs(b[n] - a[n]); ca1[2] = ca2[2] = cb1[2] = cb2[2] = inf; for (int i = 1; i &lt;= n; i++) { if (abs(a[1] - b[i]) &lt; ca1[2]) ca1[2] = abs(a[1] - b[i]); if (abs(a[n] - b[i]) &lt; ca2[2]) ca2[2] = abs(a[n] - b[i]); if (abs(b[1] - a[i]) &lt; cb1[2]) cb1[2] = abs(b[1] - a[i]); if (abs(b[n] - a[i]) &lt; cb2[2]) cb2[2] = abs(b[n] - a[i]); } for (int a1 = 1; a1 &lt;= 3; a1++) //1表示连对面第一台，2表示连中间花费最小的的，3表示连对面最后一台 { for (int a2 = 1; a2 &lt;= 3; a2++) { long long tmp = ca1[a1] + ca2[a2]; if (a1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abbef4b6ecf146aac5e01f5a93e75499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482a5491fc42e16b75966c972a4490b3/" rel="bookmark">
			Linux 高并发服务器开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章是通过观看牛客网的视频整理所得，以及在实践过程中遇到的问题及解决方案的整理总结。
Linux 高并发服务器开发 linux 系统编程linux 环境的搭建环境搭建需要的软件虚拟机中安装 ubuntu 并使用xshell 连接到 LinuxVS code 插件VS code 远程连接每次需要输入密码，解决方法 GCC编译工具在 Linux Ubuntu系统下安装GCCgcc工作流程链接阶段 静态库和动态库静态库的制作和使用动态库的制作和使用 gcc命令（参考gcc工作流程和常用参数）gcc 常用参数 Makefile 文件makefile规则**make命令** GDB 调试工具准备工作，编译时加 调试参数 得到可调试的程序GDB 命令启动，退出，查看代码断点操作断点调试命令gdb 多进程调试 文件IO - 站在内存的角度考虑文件IO程序 和 进程linux系统 IO函数文件属性操作函数目录操作、遍历函数 Linux 多进程开发**程序和进程****程序****进程****进程的虚拟地址空间**如下：**时间片****PCB 进程控制块**进程 父子进程 进程组 父子进程号 进程组号 进程的状态创建进程fork() 函数exec 函数族 进程退出（解决孤儿进程）Linux中的 _exit(int status)C标准库中的 exit() 进程回收（解决僵尸进程）wait 函数waitpid 函数 多进程通信匿名管道 pipe管道的特点匿名管道实现 ps aux | grep root 有名管道 FIFO内存映射信号**信号捕捉**信号集SIGINT 信号SIGQUIT 信号SIGKILL 信号SIGABRT 信号SIGALRM 信号SIGCHLD 信号SIGPIPE 信号 共享内存守护进程 Linux 多线程开发创建线程终止线程连接已终止的线程线程分离线程取消线程属性线程同步互斥锁/互斥量条件变量信号量 死锁读写锁 前三章的总结Linux 网络编程网络结构模式C/S 结构B/S 结构 准备知识网卡 与 MAC地址IP地址，IP协议端口 网络模型OSI 七层参考模型TCP/IP 四层模型 网络通信过程字节序字节序转换函数 socket 地址通用 socket 地址专用 socket 地址，常用，方便 IP地址转换TCP UDP 比较TCP三次握手TCP 滑动窗口TCP 四次挥手半关闭shutdown 和 close 的区别端口复用 用 socket 实现网络通信TCP 通信流程TCP 通信直接使用 套接字函数 实现 并发服务器的实现多进程实现多线程实现 io多路复用（io多路转接）几种常见的 io模型1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482a5491fc42e16b75966c972a4490b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c1f0da1f4169c2d27117e6f12541ce/" rel="bookmark">
			opencv入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 窗口显示cv::imshowcv::imreadcv::namedWindow cv::cvtColorcv::imwrite openCV图像对象创建与赋值opencv图像像素点读写操作数组遍历指针方式遍历像素范围处理saturate_cast &lt; uchar &gt;图像掩膜操作使用cv::filter2D 对图像进行掩膜处理 图像像素的算术操作 窗口显示 cv::imshow void cv::imshow ( const String &amp; winname,InputArray mat); imshow根据窗口名称显示图像到指定的窗口上去,第一个参数是窗口名称第二参数是Mat对象 #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main() { cv::Mat src = imread("C:/Users/26961/Desktop/dog.jpg"); if (src.empty()) { cout &lt;&lt; "图图片未加载" &lt;&lt; endl; return -1; } imshow("输入窗口", src); waitKey(0); //阻塞式等待 destroyAllWindows(); //销毁所有的窗口对象 return 0; } 并不能进行窗口的缩放，只是图片固定在创建的窗口上会固定尺寸
注意：
imread可以加载灰度图像 cv::imread imread(const string&amp; filename, int flags=1); imread功能是加载图像文件成为一个Mat对象,其中第一个参数表示图像文件名称。第二个参数,表示加载的图像是什么类型,支持常见的三个参数值
IMREAD_ UNCHANGED (&lt;0)表示加载原图，不做任何改变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c1f0da1f4169c2d27117e6f12541ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88882ddef885e15f568ae7a3c900d6fa/" rel="bookmark">
			NNDL 实验二 pytorch入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上次实验我们已经对python进行了简单的回顾，并且上次我们也安装了numpy库，并且对其进行了简单的应用。这次我们就来学习一下新的内容，掌握一些深度学习需要的基本内容，pytorch入门级别教学。
一. 概念：张量、算子 张量：张量是深度学习中表示和存储数据的主要形式，是类似于Numpy的多维数组的概念，张量是矩阵的扩展与延伸，可以认为是高阶的矩阵，1阶张量为向量，2阶张量为矩阵。
算子：算子是构建复杂机器学习模型和深度学习的基础组件，包含一个函数f(x)f(x)的前向函数和反向函数，在深度学习中，算子对应每一层中的计算逻辑。
二. 使用pytorch实现张量运算 1.2 张量 1.2.1 创建张量 1.2.1.1 指定数据创建张量
首先导入torch库
import torch as tc #导入torch库 创建一个一维张量
Tensor1 = tc.tensor([2, 3, 4]) #给定一个一维列表数据 print(Tensor1) 运行结果
创建一个二维张量
Tensor2 = tc.tensor([[1, 2, 3], [4, 5, 6]]) #给定一个二维张量 print(Tensor2) 运行结果
创建一个三维张量
Tensor3 = tc.tensor([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) #给定一个三维张量 print(Tensor3) 运行结果
1.2.1.2 指定形状创建
zeros_tensor = tc.zeros([3, 4]) # 创建形状为（3,4）的全0矩阵 ones_tensor = tc.ones([3, 4]) # 创建形状为（3,4）的全1矩阵 print(zeros_tensor) print(ones_tensor) 运行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88882ddef885e15f568ae7a3c900d6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81cd4f73d825c7ee2f7a96cfa3e39b7/" rel="bookmark">
			【微信小程序】组件的生命周期及自定义组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 组件的生命周期自定义组件的生命周期函数执行顺序组件常用的生命周期函数lifetimes节点 组件所在页面的生命周期函数pageLifetimes节点 自定义组件创建自定义组件创建组件定义组件使用组件 父组件向子组件传递数据子组件向父组件传递数据其他定义段与示例方法 组件的生命周期 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。
其中，最重要的生命周期是 created、attached、 detached ，包含一个组件实例生命流程的最主要时间点。
自定义组件的生命周期函数 小程序组件可用的全部生命周期如下表所示:
生命周期函数参数描述说明created无在组件实例刚刚被创建时执行attached无在组件实例进入页面节点树时执行ready无在组件在视图层布局完成后执行moved无在组件实例被移动到节点树另一个位置时执行detached无在组件实例被从页面节点树移除时执行errorObject Error每当组件方法抛出错误时执行 执行顺序 从该图中可以看出组件的 ready 与 detached 执行顺序并没有明确的先后关系。
组件常用的生命周期函数 在小程序组件中，最重要的生命周期函数有3个，分别是created、attached.
detached。它们各自的特点。如下︰
组件实例刚被创建好的时候，created生命周期函数会被触发
此时还不能调用setData，通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段在组件完全初始化完毕、进入页面节点树后，attached生命周期函数会被触发
此时, this.data已被初始化完毕。这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据)在组件离开页面节点树后，detached生命周期函数会被触发
退出一个页面时，会触发页面内每个自定义组件的detached生命周期函数此时适合做一些清理性质的工作 lifetimes节点 在小程序组件中，生命周期函数可以直接定义在Component构造器的第一级参数中，可以在 lifetimes字段内进行声明（这是推荐的方式，其优先级最高）。如下:
Component({ lifetimes:{ created(){ console.log('created'); }, attached(){ console.log('attached'); } } )} 注意：若不写在lifetime节点中且同时存在lifetime节点，优先执行lifetime节点中的生命周期函数，并覆盖掉节点之外的生命周期函数。
组件所在页面的生命周期函数 有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。
在自定义组件中，组件所在页面的生命周期函数有如下3个，分别是:
生命周期函数参数描述show无组件所在的页面被展示时执行hide无组件所在的页面被隐藏时执行resizeobject Size组件所在的页面尺寸变化时执行 pageLifetimes节点 组件所在页面的生命周期函数，需要定义在pageLifetimes节点中，如下:
Component({ pageLifetimes:{ show(){ console.log("show!!"); }, hide(){ console.log("hide!!"); }, resize(){ console.log("resize"); }	}	)} 当页面显示和隐藏时触发
自定义组件 类似vue或者react中的自定义组件。
微信小程序也 允许我们使用自定义组件的方式来构建页面。
当我们在开发小程序页面时，少不了哪些重复或类似的板块，需要我们复制粘贴一份源码进行编写，而组件恰恰解决了这个问题，它能让我们的代码复用率更高。开发更如鱼得水。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81cd4f73d825c7ee2f7a96cfa3e39b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7194625e858742299c1d1837eb43de9/" rel="bookmark">
			TypeError: __init__() takes 1 positional argument but 2 were given
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上阅读了大量的博文。基本上都是因为没有实例化对象而导致的错误。如果没有实例化对象，或者压根就不知道自己有没有实例化对象的小伙伴们可以点击以下博文：
Pytorch报错TypeError : init() takes 1 positional argument but 2 were given 原因及解决方法
或者是因为少传了参数，导致参数个数不匹配。
因为参数个数不匹配而报错
但是，博主我的问题却不是这两个。我的源代码如下：
import torch import torch.utils.data as data_utils import torchvision.datasets as dataset import torchvision.transforms as transforms # data # 手写数字数据集的下载 train_data = dataset.MNIST(root="mnist", train=True, transform=transforms.ToTensor, download=True ) test_data = dataset.MNIST(root="mnist", train=False, # 不下载数据集 transform=transforms.ToTensor, download=False ) # batchsize # 要真正理解batchSize的含义，以及为什么要使用train_loader 和test_loader # dataloader可以完成对数据重复的，成千上万次读取 train_loader = data_utils.DataLoader( dataset=train_data, batch_size=64, # shuffle=True, # 打乱数据 ) test_loader = data_utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7194625e858742299c1d1837eb43de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed61fe2ccd947afb74ffa6acb21b22c4/" rel="bookmark">
			unity Socket 通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity 端
using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Net.Sockets; using System.Net; using System; using System.Text; public class mClinet : MonoBehaviour { private Socket socket; private byte[] buffer= new byte[1024]; void Start() { socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); socket.Connect("127.0.0.1", 6666);// 链接服务器 StartReceive(); Send(); } /// &lt;summary&gt; /// 接收消息 /// &lt;/summary&gt; void StartReceive() { socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, ReceiveCallback, null); } /// &lt;summary&gt; /// 接收到的消息 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed61fe2ccd947afb74ffa6acb21b22c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144d6dca9a322678142a202765971304/" rel="bookmark">
			MySQL重置root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.记得root密码的情况 1.1关闭MySQL服务 两种方式：
（1）右键"计算机"-&gt;“管理”-&gt;“服务”，找到mysql服务，右键停止
（2）进入命令行界面，输入net stop mysql
1.2重置密码 在Shell命令行下设置,使用mysqladmin管理工具，需要验证旧的密码。命令：
mysqladmin -uroot -p password '新密码' 以root登入mysql&gt; 后，使用set password指令设置。命令：
set password for root@localhost=password('新密码'); 以root登入mysql&gt; 后，使用GRANT授权工具设置。命令：
grant all ON *.* TO root@localhost identified by '新密码'; 以root登入mysql&gt; 后，使用UPDATE更新相应的表记录。命令：
update mysql.user set authentication_string=password('新密码') where user='用户名' and Host ='localhost'; 注意：使用3、4两种方式时需要执行flush privileges;命令刷新权限。
1.3重启MySQL服务 两种方式：
（1）右键"计算机"-&gt;“管理”-&gt;“服务”，找到mysql服务，右键启动
（2）进入命令行界面，输入net start mysql
2.忘记root密码的情况 2.1关闭MySQL服务 两种方式：
（1）右键"计算机"-&gt;“管理”-&gt;“服务”，找到mysql服务，右键停止
（2）进入命令行界面，输入net stop mysql
2.2设置跳过验证 运行cmd命令切换到MySql安装bin目录（为避免错误可以直接以管理员身份运行）
执行设置命令：
mysqld -nt --skip-grant-tables 注意：此命令后面没有分号，命令执行后可能报错但没有关系，执行完之后不要关闭此cmd窗口
2.3设置密码 打开一个新的cmd窗口，切换至MySQL安装bin目录下，运行命令：
mysql -u root -p 提示输入密码，这时不需要输入密码，直接回车即可成功进入mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144d6dca9a322678142a202765971304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b629581922d0af1be1008743213c92/" rel="bookmark">
			解决Android虚拟机启动时System UI isn‘t responding错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决步骤：
（1）打开虚拟机管理器
进入项目后，选择View中的Tool Window中的Device Manager即可打开虚拟机管理器 （2）点击最右边的倒三角选择Wipe Data即可
（3）重新开启虚拟机即可解决问题，重新启动时记得将原虚拟机关闭！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b91e1b32b28ceb27d2dc5008f8aebda/" rel="bookmark">
			mac解决//go:linkname must refer to declared function or variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac解决//go:linkname must refer to declared function or variable 1、系统及原因2、解决方法 1、系统及原因 系统：macbook pro
go build -v
报错
golang.org/x/sys/unix # golang.org/x/sys/unix ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/syscall_darwin.1_13.go:29:3: //go:linkname must refer to declared function or variable ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/zsyscall_darwin_amd64.1_13.go:27:3: //go:linkname must refer to declared function or variable ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/zsyscall_darwin_amd64.1_13.go:40:3: //go:linkname must refer to declared function or variable ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/zsyscall_darwin_amd64.go:28:3: //go:linkname must refer to declared function or variable ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/zsyscall_darwin_amd64.go:43:3: //go:linkname must refer to declared function or variable ../../pkg/mod/golang.org/x/sys@v0.0.0-20200930185726-fdedc70b468f/unix/zsyscall_darwin_amd64.go:59:3: //go:linkname must refer to declared function or variable .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b91e1b32b28ceb27d2dc5008f8aebda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ba6b4df6dad8f41b709ee80f1b1fd6/" rel="bookmark">
			【vue3源码】十一、初始vue3中的渲染器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【vue3源码】十一、初始vue3中的渲染器 在介绍渲染器之前。我们先简单了解下渲染器的作用是什么。
渲染器最主要的任务就是将虚拟DOM渲染成真实的DOM对象到对应的平台上，这里的平台可以是浏览器DOM平台，也可以是其他诸如canvas的一些平台。总之vue3的渲染器提供了跨平台的能力。
渲染器的生成 当使用createApp创建应用实例时，会首先调用一个ensureRenderer方法。
export const createApp = ((...args) =&gt; { const app = ensureRenderer().createApp(...args) // ... return app }) as CreateAppFunction&lt;Element&gt; ensureRenderer函数会返回一个渲染器renderer，这个renderer是个全局变量，如果不存在，会使用createRenderer方法进行创建，并将创建好的renderer赋值给这个全局变量。
function ensureRenderer() { return ( renderer || (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions)) ) } createRenderer函数接收一个options参数，至于这个options中是什么，这里我们暂且先不深究。createRenderer函数中会调用baseCreateRenderer函数，并返回其结果。
export function createRenderer&lt; HostNode = RendererNode, HostElement = RendererElement &gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) { return baseCreateRenderer&lt;HostNode, HostElement&gt;(options) } 至此，我们就找到了真正创建渲染器的方法baseCreateRenderer。当我们找到baseCreateRenderer的具体实现，你会发现这个函数是十分长的，单baseCreateRenderer这一个函数就占据了2044行代码，其中更是声明了30+个函数。
在此我们先不用关心这些函数的作用，在后续介绍组件加载及更新过程时，你会慢慢了解这些函数。
接下来我们继续看渲染器对象的结构。
渲染器 return { render, hydrate, createApp: createAppAPI(render, hydrate) } 在baseCreateRenderer最后返回了一个对象，这个对象包含了三个属性：render（渲染函数）、hydrate（同构渲染）、createApp。这里的createApp是不是很熟悉，在createApp中调用ensureRenderer方法后面会紧跟着调用了createApp函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ba6b4df6dad8f41b709ee80f1b1fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90e6e7cd983750de6ad644a22bb33e3/" rel="bookmark">
			HJ75 公共子串计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.*; public class Main { public static void main(String[] args) throws IOException { // BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Scanner sc=new Scanner(System.in); while(sc.hasNext()){ String str1=sc.nextLine(); String str2=sc.nextLine(); int max=sub(str1,str2); System.out.println(max); } } public static int sub(String str1,String str2){ int len1=str1.length(); int len2=str2.length(); int[][] dp=new int[len1+1][len2+1]; dp[0][0]=0; for (int i = 0; i &lt;= len1; i++) { dp[i][0] = 0; } for (int j = 0; j &lt;=len2; j++) { dp[0][j] = 0; } int max=0; for(int i=1;i&lt;=len1;i++){ for(int j=1;j&lt;=len2;j++){ if(str1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d90e6e7cd983750de6ad644a22bb33e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/214/">«</a>
	<span class="pagination__item pagination__item--current">215/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/216/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>