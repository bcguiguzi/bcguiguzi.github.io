<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ef6f310685c919f8c0f8d63b25c33c/" rel="bookmark">
			python学习笔记：matplotlib窗口标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 的matplotlib支持pyqt和tkinter。在编辑窗口属性时，要考虑两者兼容，因为我们不知道别人有没有安装PyQt。
详细链接：Python Matplotlib 避坑指南|注意事项|开发必知_lzy-software的博客-CSDN博客
import matplotlib.plot as plt plt.figure(figsize=(10,6)) # 如果程序从Qt中启动，plt将使用Qt库绘图，否则使用Tk绘图。 try: fig.canvas.setWindowTitle(self.title) fig.canvas.manager.window.setWindowTitle(self.title) except: fig.canvas.manager.window.title(self.title) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96821f1b4087fc10b9ff449847928389/" rel="bookmark">
			Abaqus输出XY数据如何复制导出到Excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODB场输出数据，具体操作见ABAQUS如何输出应力应变曲线（XY曲线）
可以发现abaqus6.14.1无法复制数据
因此采用另一简便方法
Plug-ins——&gt;Tools——&gt;Excel Utilities
选中需要的数据，Apply，
自动生成Excel表格，可进行后续数据处理
以上是第一种导出数据方法
下面介绍第二种方法
Report——&gt;XY
选中数据，Apply
那么在工作路径中找到abaqus.rpy中，包含数据
如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d52ed5cb819c6b68afe0f572244a05e/" rel="bookmark">
			Scala 函数式编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Scala 函数式编程一、函数基础1、函数基础语法2、代码示例3、函数和方法的调用4、函数和方法的区别 二、函数定义1、函数定义2、代码示例 三、函数参数1、基本说明2、代码示例 四、函数至简原则1、至简原则细节2、代码示例 五、匿名函数1、匿名函数的定义2、匿名函数的简化原则1）基本说明2) 代码示例 3、匿名函数的说明 六、函数高级1、高阶函数1) 函数可以作为值进行传递2) 函数可以作为参数进行传递3) 函数可以作为函数的返回值返回 2、高阶函数案例3、函数柯里化&amp;闭包(重点)(1)、基本说明(2)、闭包代码示例(3)、函数柯里化代码示例 4、递归5、抽象控制6、用scala代码实现while关键字小案例7、惰性加载 Scala 函数式编程 Scala是一门既面向对象，又面向过程的语言。在Scala中，函数与类、对象地位是一样，所以说scala的面向过程其实就重在针对函数的编程 了，所以称之为函数式编程
1、面向对象编程：
解决问题，分解问题，行为，属性，然后通过对象的关系以及行为的调用来解决问题
对象：用户
行为：登录，连接JDBC，读取数据库
属性：用户名，密码
Scala 语言是一个完全面向对象编程语言，万物皆对象
对象的本质：对数据和行为的一个封装
2、函数式编程
解决问题时，将问题拆分成一个一个的步骤，将每个步骤进行封装(函数)，通过调用这些封装好的步骤，解决问题
例如：请求-&gt;用户名、密码-&gt;连接JDBC-&gt;读取数据库
Scala语言是一个完全函数式编程语言，万物皆函数
函数的本质：函数可以当成一个值进行传递
在scala中函数式编程和面向对象编程完美融合在一起了
一、函数基础 1、函数基础语法 2、代码示例 需求：定义一个函数，实现将传入的名称打印出来
直接使用def 关键字定义函数 sayHi 是一个函数名称，里面是参数
然后调用函数直接在main方法里函数名，里面把参数传进去就行了
package scala_xuexi01 class test15_hanshu { } object test15_hanshu{ //单例对象 def main(args: Array[String]): Unit = { def sayHi(name:String):Unit ={ println("hi"+name) } //调用函数 sayHi("alice") //直接传入name参数 } } 3、函数和方法的调用 函数和方法的区别，函数在main方法里面写，然后再里面调用，直接函数名，里面传入参数，方法是和main方法同级别的，所以要写在外面，还有通过对象调用函数，其实都是一样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d52ed5cb819c6b68afe0f572244a05e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb256f79f39476d616debd3580a2223/" rel="bookmark">
			pom.xml有删除线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea中的pom.xml文件有删除线
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1673b9750599c8d5aae13fc717cbee75/" rel="bookmark">
			爆火的ChatGPT 背后的大模型与大数据创新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，ChatGPT 迅速引爆 AIGC 领域，依托全网大数据与海量智能模型训练，一举成为 Stable Diffusion 之外的 AI 新宠。不同于过往初阶聊天机器人，这位“懂王”似乎可以取代大型搜索平台，与用户展开高质量同频对话。网友也特别乐于「调戏」它，还生成出了不少奇怪的神回复。
ChatGPT 奇特之处恰在于其『学习性』，也就是说它具备进化能力，能够在与人沟通、学习过程中变得更加聪明。在官方介绍里也提到过，它可以指出不正确前提，拒绝回答不适当问题，甚至会承认错误。
展开高智商对话的同时，ChatGPT 也能写出优雅的代码。如果你告诉他需要创建一个 PHP 程序来扫描主机名上的开放端口，就可以得到一份代码，虽然目前看来还是比较初级的，但随着后续的学习和调整，应用前景存在无限可能。
更厉害的是，它还能够在 ChatGPT 中构建虚拟机，运行 Linux 指令，甚至还可以用 curl 来让 Chat GPT 和自己做交互。
如果格局打开一点，我们是不是可以说，在跨端开发时候它可以取代election，真的有助于降本增效？尽管目前还不能做到这么高阶的玩法，但是依照 ChatGPT 的潜质，这或许只是时间问题。
当然，玩法只是表层，更值得谈论的则是其里程碑式意义：AI已然从幕后转向了台前。
在过去的两周里，ChatGPT的热度一度超过 Alpha Go 的峰值。虽然在过往，像是 AlphaGo 这类 AI 产品确实为用户所熟知，但是离用户还是太远了。而 ChatGPT 更像是「民用级」的产品，真正意义上让AI技术广泛破圈应用。
1
大规模模型训练、海量数据
共同成就 ChatGPT
ChatGPT 的出圈并不是偶然，透视结构，它是一种基于 InstructGPT算法架构开发的大型预训练语言模型，而在这之中，OpenAI 为这个模型新增了代码理解和生成能力，这样就可以极大的拓宽应用场景，甚至在这之中，它还加入了一些道德原则，如此就能够识别恶意信息，而且还可以拒绝回答等。在使用体验被拉满之后，我们所能够见到的就是不同于原先的、更贴近于「人」的使用感。
如果从技术角度去解读，我们不难看出，这些产品的背后，都是基于大模型、大数据的不断训练。在之前就有报道指出，ChatGPT背后的训练除了常规的万亿级别语料投喂之外，还依托于其强大的算力。
据数据披露，ChatGPT的总算力消耗约为3640PF-days。事实上这几件事我们可以认为是相辅相成的，即高质量的人工标注数据+强化学习为底层逻辑，在经过万亿级别的语料投喂后不断进行学习和迭代，最后依托于强大的算力为产品的学习和输入输出进行支撑。
看上去难吗？不难，但也很难。在过去的很长一段时间里，许多的厂商都是通过本地设备来进行训练的，甚至在过去，知乎还曾经有人提问「为什么很少有机器学习上云」。
事实上在过往有很多的公司都因为对算力的强需求被拖垮了，这也就是为什么很长一段时间内我们都很难在机器学习领域看到新的产品了。出彩的产品本身就因为算力的桎梏而变得很少，更遑论出圈的呢？
但是，当时间大跨步进入现在以后，这件事就变得截然不同了。在当下，机器学习和深度学习的上云已经相当普遍，而市面上也有很多的产品都在基于大模型的训练和推理给出更适合个人开发者和企业开发的解决方案，亚马逊云科技就是其中之一。
2
从高门槛到低成本，
亚马逊云科技做对了什么？
从刚刚过去不久的2022亚马逊云科技 re:Invent 全球大会上，我们可以得知ChatGPT 这类基于大模型的训练和推理，正是未来驱动机器学习发展的关键趋势之一。
首先，大模型的训练和应用门槛亟须降低。
ChatGPT 相比以往对话机器人，之所以“聪明”，是因为摄入了数以亿计的语料库内容，而如此规模的大模型的训练和应用成本极高，绝大部分企业都无法承担，但我们看到越来越多的大模型走向了开源，并允许用户在此基础上进行低成本的微调，以更加适配最终用户的业务场景。如何获取这些大模型，并快速进行部署和微调，是真正落地大模型应用需要考虑的问题。 Amazon SageMaker JumpStart简单明了的回答了这个问题，JumpStart提供了超过350个来自TensorFlow、PyTorch、Hugging Face以及MXNet等广受欢迎的模型中心所提供的最先进的预训练模型、内置算法以及预置解决方案模板，能为对象检测、文本分类和文本生成等流行的ML任务提供支持，在re:Invent 2022上，亚马逊云科技宣布将来自Stability.AI （发布了火出圈的用于AIGC的 stable diffusion模型）和 AI21 公司的大模型集成到SageMaker JumpStart，用户仅需点点鼠标，即可完成模型的部署和微调，极大的降低了大模型应用的门槛。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1673b9750599c8d5aae13fc717cbee75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd890bb43a13024d010e306a9cf433d/" rel="bookmark">
			Git学习：各阶段回退方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、问题背景二、解决方式1. 回退情况1：文件在工作区进行回退2. 回退情况2：文件在暂存区进行回退3. 回退情况3：文件在本地仓库进行回退4. 回退情况4：文件已经在远程仓库中 一、问题背景 Git 是分布式的软件管理系统。在把一份代码完成之后发送到 “远程仓库”，可能中间还经历了不同的 “提交阶段”。 本文介绍的是在不同阶段下对应的回退方法。
二、解决方式 在Git中，一份代码可能处于不同的提交阶段。
一份新修改（或者创建的）文件处于 – 工作区。
当 git add 之后， 文件会从 工作区 移动到 暂存区。
当 git commit 之后， 文件会从 暂存区 移动到 本地仓库。
当 git push 之后，文件会从 本地仓库 移动到 远程仓库。
关系如图：
（图片来自 菜鸟教程）
1. 回退情况1：文件在工作区进行回退 这里指的是文件没有经过任何提交，仅仅只是保存。但是保存完之后发现需要回退一下代码。
此时可以使用 git checkout -- filename 进行回退。（危险动作，三思）
2. 回退情况2：文件在暂存区进行回退 这里指的是文件经过git add 指令之后进入了暂存区。
此时可以使用 git reset HEAD 指令将暂存区的文件回退到修改之前的状态。（危险动作，三思）
3. 回退情况3：文件在本地仓库进行回退 例如情况如下：
这里指的是文件经过git commit 指令之后进入了本地仓库。
此时可以使用 git log 查看本次提交之前的版本，并记住想要回退的版本的id。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd890bb43a13024d010e306a9cf433d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78fd2c75f914010dc1e8ab7fbf90fe3b/" rel="bookmark">
			【数据结构】队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列基本术语 1.队列（queue）：先进先出（FIFO），限定表在一端进行插入，在另一端进行删除
2.队头（front）：能删除的 一端为队头
3.队尾（rear）：能插入的一端为队尾
4.队空：当队头等于队尾时，说明队空
5.进队：先将数据存入队尾，再使队尾加1
6.队满：当队尾等于最大长度时有可能是队满，也有可能存在假溢出(可以使用循环队列解决这个问题)
7.出队：出队即删除，从队头开始删除。先删除元素，再使队头加一。
8.循环队列（通过循环队列来解决假溢出的问题）：循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间（但在物理上还和普通队列一样），供队列循环使用，由此可以解决掉假溢出的问题。
在循环队列中，当队列为空时，有front = = rear，而当所有队列空间全占满时，也有front = = rear。为了区别这两种情况，人为的浪费掉最后一个存储单元，即规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front = = rear，而队列判满的条件是front==（rear+1)%MaxSize。
队空 front = = rear 同样是队头等于队尾进队 rear = (rear+1) % maxSize 每次进队后执行该操作，让队尾指向下一个，当队尾指向最后一个位置时重新到第一个位置队满 front = = (rear + 1)%maxSize 在循环队列中，当队列为空时，有front=
=rear，而当所有队列空间全占满时，也有front==rear。为了区别这两种情况，人为的浪费掉最后一个存储单元，即规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了出队 front = (front + 1)%maxSize
与进队逻辑相同，删除掉队头的元素后，让队头往后移一个位置，当队头到最后一个位置时会重新到第一个位置队长度 因为循环队列，rear不一定比front大 如果rear&lt;front结果是rear-front+maxsize
如果rear&gt;front结果是rear-front
为了用一个表达式同时表达两者，用(rear-front+maxsize)%maxsize
假设maxsize=10
rear=1 front=9，那么结果是2
rear=9 front=1，那么结果是8
队中余剩下空单元 （front - rear + maxSize）%maxSize 队列的基本操作 结构 struct Queue { int front; int data[maxSize]; int rear; }; 初始化 struct Queue * initQueue() { struct Queue *q = (struct Queue *)malloc(sizeof(struct Queue)); q-&gt;front = 0; q-&gt;rear = 0; return q; } 判断是否为队空 int isEmpty(struct Queue *q) { if (q-&gt;front == q-&gt;rear) { return 1; } else { return 0; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78fd2c75f914010dc1e8ab7fbf90fe3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ed15f690daa127dedfb656a6979f87/" rel="bookmark">
			C&#43;&#43;取整与保留小数位的问题与解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 保留小数位的方法；
1.1 printf 格式化输出：
1.2 setprecision用法；
1.2.0总述；
1.2.1基本格式setprecision（int n）
1.2.2 setiosflags（ios::fixed）
1.2.3 setiosflags（ios::scientific）
二 取整
2.1 强制类型转换
2.2取整函数；
2.2.1四舍五入取整 round（）函数；
2.2.2向上取整 ceil（）函数；
2.2.3向下取整 floor（）函数；
一 保留小数位的方法； 1.1 printf 格式化输出： 可以用于处理浮点数不能用于处理整数；
举例一：输入一个整数保留两位小数，再输入一个浮点数，保留三位小数；
#include &lt;iostream&gt; using namespace std; int main() { short a; cin &gt;&gt; a; printf("%.2f\n", a); double b; cin &gt;&gt; b; printf("%.3f", b); return 0; } 运行结果：例如，依次输入4，3.67878；
4 0.00 3.67878 3.679 C:\Users\uaer\source\repos\12.25\x64\Debug\12.25.exe (进程 90000)已退出，代码为 0。 要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。 按任意键关闭此窗口. .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ed15f690daa127dedfb656a6979f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6509e03940c58420047847f48af2c386/" rel="bookmark">
			Your password does not satisfy the current policy requirements.mysql密码不能设为root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在CentOS7系统里安装了MySQL8.0.26
重置密码为 root 提示Your password does not satisfy the current policy requirements.
查看密码要求
show variables like 'validate_password%'; 根据教程视频里讲的，只改了validate_password.length=4（长度）和validate_password.policy=LOW（验证政策）,但是发现将密码改为root 时仍提示Your password does not satisfy the current policy requirements.
set global validate_password.length=4; set global validate_password.policy=LOW; 注意：教程里的是validate_password_policy，而我安装的版本是validate_password.policy,第二个下划线是 .
我仔细阅读了一下表中字段含义
validate_password_length 固定密码的总长度；
validate_password_dictionary_file 指定密码验证的文件路径；
validate_password_mixed_case_count 整个密码中至少要包含大/小写字母的总个数；
validate_password_number_count 整个密码中至少要包含阿拉伯数字的个数；
validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；
关于 validate_password_policy 的取值：
0/LOW：只验证长度；
1/MEDIUM：验证长度、数字、大小写、特殊字符；
2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；
validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；
然后我把这些字段都改了 但是还是Your password does not satisfy the current policy requirements.!!!
最后我把validate_password.check_user_name改成OFF，终于成功了
还有一点额外的东西：
MySQL5中开启访问权限（教程中）：
grant all on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6509e03940c58420047847f48af2c386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad14b44e01e1f2c378311fbf73a8e664/" rel="bookmark">
			FPGA入门（5）：控制LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第17讲：触摸按键控制LED灯第18讲：流水灯第19讲：呼吸灯第20讲：状态机第21讲：无源蜂鸣器驱动实验 第17讲：触摸按键控制LED灯 触摸按键可分为四大类：电阻式、电容式、红外感应式、表面声波式
电容式触摸按键主要由按键IC部分和电容部分构成；按键IC用于将电容的变化转换为电信号；电容部分指的是由电容极板、地、隔离区等组成触摸按键的电容环境。
模块绘制
波形图绘制：按键未按下时保持高电平，按键按下保持低电平；按下时间与低电平保持时间相同，松开按键返回高电平
使用按键下降沿控制灯的点亮和熄灭
touch_ctrl_led.v
`timescale 1ns/1ns module touch_ctrl_led ( input wire sys_clk , //系统时钟，频率50MHz input wire sys_rst_n , //复位信号，低电平有效 input wire touch_key , //触摸按键信号 output reg led //led输出信号 ); //wire define wire touch_flag ; //触摸使能信号 //reg define reg touch_key_dly1 ; //touch_key延迟一个时钟信号 reg touch_key_dly2 ; //touch_key延迟两个时钟信号 //对touch_key信号延迟两个时钟周期用来产生触摸按键信号 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1'b0) begin touch_key_dly1 &lt;= 1'b1; touch_key_dly2 &lt;= 1'b1; end else begin touch_key_dly1 &lt;= touch_key; touch_key_dly2 &lt;= touch_key_dly1; end //根据触摸按键信号的下降沿判断触摸了触摸按键 assign touch_flag = ((touch_key_dly1 == 1'b0) &amp;&amp; (touch_key_dly2 == 1'b1)); //根据触摸使能信号控制led状态 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1'b0) led &lt;= 1'b1; else if(touch_flag == 1'b1) led &lt;= ~led; else led &lt;= led; endmodule `timescale 1ns/1ns module tb_touch_ctrl_led(); //wire define wire led ; //reg define reg sys_clk ; reg sys_rst_n ; reg touch_key ; //sys_clk,sys_rst_n初始赋值，模拟触摸按键信号值 initial begin sys_clk = 1'b1 ; sys_rst_n &lt;= 1'b0 ; touch_key &lt;= 1'b1 ; #20 sys_rst_n &lt;= 1'b1 ; #200 touch_key &lt;= 1'b0 ; #2000 touch_key &lt;= 1'b1 ; #1000 touch_key &lt;= 1'b0 ; #3000 touch_key &lt;= 1'b1 ; end //clk：产生时钟 always #10 sys_clk = ~sys_clk ; //------------- touch_ctrl_led_inst ------------- touch_ctrl_led touch_ctrl_led_inst ( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad14b44e01e1f2c378311fbf73a8e664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7216d67ee9c0ac1d9b2fa8fcda0f7b3b/" rel="bookmark">
			写一段python爬取付费音乐的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里是一段爬取付费音乐的 Python 代码：
import requests import json # 请求头 headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36" } # 付费音乐的 URL url = "http://music.163.com/song/media/outer/url?id=1436720602.mp3" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1324eca3dbc704f204b7f62d70e1a89d/" rel="bookmark">
			全局路由拦截、局部路由拦截
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入： 看下面这个效果： 每次我们在点击一个功能时，它就会跳转到登录页面，意思就是让我们先登录，登录之后再进行功能操作；但是如果我们登录了，它就不会跳转，这是什么原理呢；
运用的原理：在路由跳转之前，进行拦截检查是否登录，如果没有登录就跳转登录页面，如果登录了就不跳转登录页面。此时就用到了：路由拦截 如何拦截： 路由拦截分为：全局路由拦截、局部路由拦截； （1）全局路由拦截：
const router = new VueRouter({ mode: 'history', routes }) // 全局拦截 router.beforeEach((to, from, next) =&gt; { if (需要拦截验证的路由) { if (验证成功) { // next():不拦截，放行 next() } else { next('/login') } } else { next() } }) 拦截方法：router.beforeEach(回调函数)，每个路由跳之前都会执行这个函数；回调函数有三个参数：to、from、next，to是跳转后路由，from是跳转前路由，next是个函数；next是一个函数，含义是：不需要拦截的路由通行；并不需要对所有路由进行拦截，不需要拦截的就next（） 拦截思路：（对上述代码进行解释）
路由需要拦截就走外围if，不许要拦截就走外围else，通过next（）放行；如果拦截的路由授权通过了，就走next（）放行，没有授权通过就跳转到某个页面去执行某个功能，去授权。
拿登录案例来理解：
如果点一个功能需要验证是否注册登录，那就拦截下来；不需要验证那就不拦截就走外层else；里层的判断：拦截下来的路由，判断你是否登录，没登录那就else去登录，if登录了那就走next（）放行。
案例演示：
现在要求是要拦截 path为 “/center”和“/order”的路由，其他的不拦截；拦截的路由需要判断是否登录；
（1）外层if判断代码：
首先给要拦截的路由加上 meta ： // 配置表,将路径和组件一一对应配置好 const routes = [ { path: '/films', component: FilmsView }, { path: '/cinemas', component: CinemasView }, { path: '/center', component: CenterView, meta: { isKerwinRequired: true } }, { path: '/order', component: OrderView, meta: { isKerwinRequired: true } } ] meta里面名字随便起，传一个true值，默认不写是false； 此时打印一下 to 的值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1324eca3dbc704f204b7f62d70e1a89d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6953c332233cd4ee3f8a574c725d3ab/" rel="bookmark">
			云服务器ECS入门及云上网站部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器ECS入门及云上网站部署 一、什么是云服务器ECS 云服务器ECS (Elastic Compute Service) 是阿里云提供的性能卓越、稳定可靠、弹性扩展的laaS(Infrastructure as a Service) 级别云计算服务
云服务器ECS免去了您采购IT硬件的前期准备，让您像使用水、电、天然气等公共资源一样便捷、高效地使用服务器，实现计算资源的即开即用和弹性伸缩。阿里云ECS持续提供创新型服务器，解决多种业务需求，助力您的业务发展。
一台云服务器ECS的创建过程
一张图看懂云服务器ECS产品架构
云服务器ECS基础概念科普
云服务器ECS的产品优势
阿里云弹性计算十余年深厚技术积淀，技术领先、性能优异、 稳如磐石。
云服务器ECS丰富的应用场景
不止是云服务器，完善的自动化运维能力
自动化运维（ CloudOps ）： More Than Just ECS，通过自动化能力降低用云门槛和摩擦力，推进系统管理与运维云化。
二、如何获取一台云服务器ECS 获取云服务器ECS的两种方式
飞天加速计划免费领取步骤
飞天加速计划是阿里云推出的技术普惠项目，面向学生、教师、开发者和中小企业提供算力和
云产品等资源，助力开发者全生命周期成长，培育数字时代的创新人才。
学生用户免费领取关键步骤：完成学生认证
云服务器ECS产品详情页付费购买
三、5分钟学会管理云服务器ECS 新手入门：5分钟学会管理ECS
Step1：重置ECS密码/重启ECS
操作路径：概览—实例ID&gt;实例详情&gt;重置密码
Step2：远程连接ECS
操作路径：概览—实例ID&gt;远程连接
连接方式：Workbench 或 VNC均可，推荐使用Workbench
Step3：配置安全组规则
操作路径：概览-实例ID&gt;实例详情&gt;配置安全组&gt;配置规则
端口设置：常用端口已默认开放，即22（可远程登录Linux ）、3389（可远程登录windows ）、
ICMP（可以ping通网络）；
特殊端口，如80、25等端口，请评估业务需要及安全性后再开通
Step4：学习变更ECS配置操作
操作路径：概览—实例ID&gt;实例详情&gt;操作，区分包年包月、按量付费
Step4：学习变更ECS配置操作
配置操作：按量ECS使用模式需要变更规格，只需2步：①快照备份数据；②先释放ECS再创建新
ECS
释放：快速变更按量ECS，需要先释放当前ECS，再创建新ECS，如有重要数据，建议先打快照做备
份，新ECS创建后备份可及时删除。
创建：释放后，快速创建ECS，如打快照可以恢复后删除。
Step5：学习使用数据监控
a.数据监控有什么用：通过监控，能够实时可视化掌握ECS运
行状态，一旦出现安全隐患，可及时预警，避免影响业务正常
运转。
b. 操作路径：概览—实例ID&gt;安装插件
c. 监控维度：
■ 资源：CPU、内存、带宽、云盘使用率、系统负载、连接数等
■ 时间：1小时、6小时、1天、7天、自定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6953c332233cd4ee3f8a574c725d3ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4c6be094a2eff0e187091dd50721be/" rel="bookmark">
			数独生成算法的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述：
数独是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个九宫格内的数字均含1-9，不重复
要求：设计算法随机生成不同难度的数独游戏，阐述如何评价所生成数独的难度。
问题分析： （在此只涉及数独的生成，不涉及数独的求解）
数独问题的约束条件：
(1)每个矩阵的数字范围仅限1—9；
(2)每个数字在当前行不允许重复；
(3)每个数字在当前列不允许重复；
(4)每个数字在每一宫内不允许重复。
问题求解思路 数独的生成，最好的情况就是，先得到一个完整的数独，然后根据难度需要，随机地挖一些空格出来，保证有解。所以关键就是如何得到完整的数独，也要有一定的随机化。
先要生成一个数独数组shudo[9][9]，用memset函数对数组初始化，按照规则随机填数，然后根据给定的难度等级再随机挖洞，这就是我们生成的数独游戏。
算法测试
1.按照问题求解思路，在生成数独数组并将其完成初始化后，用shudu_1函数先对中间的九宫格完成随机填数。 随机填数具体实现是由一个a[10]数组来完成，用一个while循环用m变量给a[0]到a[8]随机赋值，且保证每个数组元素都各不相同。而在这过程中，用到了flag变量来进行数组元素是否重复的判断。在for循环遍历a[ ]数组前，给flag赋初值为0，一旦之前保存的数中出现了与m相同的数，就将flag标记为1并跳出循环，重新生成一个随机数m给a[ ]数组赋值，直到a[ ]数组随机填充数完毕。
2.在中间的九宫格完成随机填数后，用shudu_2函数对上下左右四个九宫格进行填数。
填数方法十分简单，利用已经填好的中间九宫格的数，交叉变换填充这四个九宫格。
3.最后shudu_3函数再对四个角上的数组填数，填数原理同第二步。到这一步为止，初始的随机填数数组已经生成好了。
4.再就是根据游玩者输入的难度随机挖洞，这里设置了4个难度。
(level 1)
(level 2)
(level 3)
(level 4)
以下是完整代码：
#include &lt;stdio.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int shudu[9][9], hole[9][9]; //打印数独 void ouput() { for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { cout &lt;&lt; shudu[i][j] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b4c6be094a2eff0e187091dd50721be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bd97dd9c555b6f6be37619e5454583/" rel="bookmark">
			用python针对给定数据集ORL_Faces，提取图像的特征(可以采用多种特征)并图像进行分类，分类方法自选。训练数据集和测试数据集采用随机划分的方法生成，测试样本占比为20%。图像可以经过预处理。...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Python 中，您可以使用 scikit-learn 库中的数据集 ORL_Faces 来完成您的任务。
首先，您需要导入必要的库：
from sklearn.datasets import fetch_lfw_pairs from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f78673a26099bd5b042dad7c79d836/" rel="bookmark">
			macOS 更新后 Git 无法工作（xcrun: 错误：无效的活动开发者路径 (/Library/Developer/CommandLineTools)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问： 我更新到 macOS Mojave（这也发生在 Catalina 更新中，并且似乎可能发生在此后的每次重大更新中）
今天早上，我在 MacBook Pro 的命令行中导航到我工作的代码库，在存储库中输入“git status”并收到错误：
xcrun：错误：无效的活动开发者路径 (/Library/Developer/CommandLineTools)，缺少 xcrun：/Library/Developer/CommandLineTools/usr/bin/xcrun
如何修复 git 和命令行工具？
答1: huntsbot.com – 高效赚钱，自由工作
问题是需要更新 Xcode 命令行工具。
解决方案#1
返回您的终端并输入：
xcode-select --install 然后，您将收到以下输出：
xcode-select: note: install requested for command line developer tools 然后将在一个窗口中提示您更新 Xcode 命令行工具。 （可能需要一段时间）
打开一个新的终端窗口，您的开发工具应该会返回。
另外：对于任何主要或半主要更新，您都需要更新命令行工具以使它们再次正常运行。检查 Xcode 是否有任何更新。这超越了莫哈韦…
之后重新启动您的终端
或者，如果失败，它很可能…你会得到一个弹出框，上面写着“在服务器上找不到软件”，见下文！
解决方案#2
然后你点击xcode-select --install并没有找到软件，登录Apple Developer，并通过网页安装它。
在此处登录或注册：
https://developer.apple.com/download/more/
在下载列表中查找：“Xcode 12.x 的命令行工具”然后单击 dmg 并下载。
https://i.stack.imgur.com/WwAlF.png
HuntsBot周刊–不定时分享成功产品案例，学习他们如何成功建立自己的副业–huntsbot.com
这解决了我在使用 Microsoft Visual Studio Code 时遇到的问题，该问题在升级到 Mojave 后首次启动 Git 时抱怨未安装 Git。我认为问题出在 VS Code 上，但这是这个 SO question 中的问题。安装 Xcode 命令行工具后重新启动 VS Code 解决了该问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f78673a26099bd5b042dad7c79d836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052d0e309d4e4177673dfaa962b4116b/" rel="bookmark">
			SIFT特征提取和匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sift特征原理部分： SIFT特征详解 - Brook_icv - 博客园 (cnblogs.com)
sift特征提取算法_July_Zh1的博客-CSDN博客_sift特征提取算法
二、sift特征提取实践部分： 代码实现：Python+OpenCV import cv2 def sift_kp(image): gray_image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) sift = cv2.SIFT.create() kp,des = sift.detectAndCompute(image, None) #kp_image = cv2.drawKeypoints(image, kp, None) kp_image = cv2.drawKeypoints(image, kp, image, (122, 255, 122), flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS) return kp_image,kp,des #image = cv2.imread('E:\pythonProject\\N2.jpg') #image = cv2.imread('E:\pythonProject\image1.jpg') image = cv2.imread('E:\pythonProject\ldh1.jpg') kp_image, _, des = sift_kp(image) print(image.shape, des.shape) cv2.namedWindow('sift features',cv2.WINDOW_NORMAL) cv2.imshow('sift features', kp_image) if cv2.waitKey(0) == 27: cv2.destroyAllWindows() 老版本的OpenCV，则第四行用
sift = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052d0e309d4e4177673dfaa962b4116b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54de3f5071f0e404994e5b2c0a9f455c/" rel="bookmark">
			Windows10 镜像（正版和原版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows 10（企业版）, 版本 22H2（2022 年 10 月发布）64 位简体中文
大小：5.55GB
MD5：DF57824E84BB5375C9FC3AF4CAD58926
SHA1：C7C877210AC645C29574E1F110B0277932380A14
SHA256：3CB92FAD8934C3C1A4827C290B4BC2C11331C84923B07FFECB2250C87CC4FC53
ED2K：
ed2k://|file|zh-cn_windows_10_business_editions_version_22h2_updated_dec_2022_x64_dvd_cde06342.iso|5964230656|4CAE148031EF42D2183B149392E281B7|/ BT：
magnet:?xt=urn:btih:3b1bc1658262edbab7f4b3aeead460dabb4a3e02&amp;dn=zh-cn_windows_10_business_editions_version_22h2_updated_dec_2022_x64_dvd_cde06342.iso&amp;xl=5964230656 Windows 10（消费者版）, 版本 22H2（2022年 10月发布）64位简体中文
大小：5.68GB
MD5：5D20D5A48565DC40BCEDA63EDF90D56C
SHA1：5ED0A28DAA24AA1764403D87F1A0424B960A691D
SHA256：19CE6653655CBA786861CC6344E09D3B55D34566086C40AD6A14E4F03950EAD9
ED2K：
ed2k://|file|zh-cn_windows_10_consumer_editions_version_22h2_updated_dec_2022_x64_dvd_a95e3989.iso|6101671936|5C65BBF0491119EBD1A3349AA064263D|/ BT：
magnet:?xt=urn:btih:7c03c41a70920cbdb2a9f45866635f0f9df2bc0b&amp;dn=zh-cn_windows_10_consumer_editions_version_22h2_updated_dec_2022_x64_dvd_a95e3989.iso&amp;xl=6101671936 Windows 10（中国正版），版本 22H2（2022 年 10 月发布）64 位简体中文
文件名：Win10_22H2_China_GGK_Chinese_Simplified_x64.iso
大小：5.3GB
MD5：67615F768A49392D5E080E25A0036975
SHA1：514A25D619304EC258C765D807D4D01A9D6CABFA
SHA256：754B2AC343E4F13D47F0CB9A8AD72AE6EF8A3CFFDABE202770D70C8C4F821F27
ED2K：
ed2k://|file|Win10_22H2_China_GGK_Chinese_Simplified_x64.iso|5687615488|937058F92F1EE4B5B4FCD1450C5AF212|/ BT：
magnet:?xt=urn:btih:43ba170b1ee15733275a60d9373f781841f69d84&amp;dn=Win10_22H2_China_GGK_Chinese_Simplified_x64.iso&amp;xl=5687615488 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bc61fe254ee48cb0307b6821b32d2b/" rel="bookmark">
			单页扒手-基于Node的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做网站的朋友经常遇见别人的好看的页面，想保存到本地自己用，可是用以前的老办法网页另存为，发现很不好，规则不好处理，路径也不好处理，用这个网页克隆（单页模板扒手）就很好处理了，你只要输入你想要扒皮的网站地址，点击下载就可以了。
我就是最近看到一个很不错的后端的模板，想要扒下来，于是就上网找了个工具，叫做单页扒手。就是下面这个玩意儿。
结果下载完成之后，居然给我报有病毒，当我再去找的时候，我突然间想起来，我TM是个不靠谱的程序员，为什么这次就不能给你靠谱点儿自己写一个呢？于是就默默的打开了我的编辑器，建了个工程PageDownload。
基本思路 首先说明一点儿，我的这个单页抓包的东西，只是一个基础的，下载的内容也都是相对来说比较简单的（Just For Fun）。
给一个网页地址，请求加载网页的Html，然后将一个页面进行保存。解析Html，查找Html中所有的资源（主要是CSS，JS和Image），以及连接，然后继续去请求，并且继续下载和保存。如果连接的资源是Html的话，则继续进行解析然后下载下载过的资源用记录下来，在遇到同样的资源的时候，需要进行检测，如果存在相同的资源，则不在进行下载和处理，避免进入死循环。 好了既然思路都有了，那就开始写代码吧。
可能存在的问题与解决：
嵌入的资源是第三方资源，与本站的地址不符我们需要处理？（有些模板网站嵌入的有谷歌字体什么的，这些暂时先不处理）。某些Css中所引用的资源比如说图片，svg图标字体应该如何去解析？这些个暂时先不处理，毕竟这些都是少量的，如果连接的第三方连接会很深应该如何处理？ 所需要的第三方包 再开始之前我们根据上面的实现思路先安装一些需要用到的包：
request（网络请求）cheerio（一个很好用的Html解析工具，效率非常高）fs-extra（fs-extra模块是系统fs模块的扩展，提供了更多便利的API，并继承了fs模块的API，本文详细介绍所有操作方法，方便读者更好的操作服务端文件） 基本的代码实现 这里就不在瞎说，直接贴代码，具体的代码解释参考代码中的注释：
const path = require('path'); const cheerio = require('cheerio'); const fse = require('fs-extra'); const request = require('request'); // 需要爬取的页面的地址 const HOST = 'https://offsetcode.com/themes/messenger/2.2.0/'; // 爬取之后输出的位置 const OUT_PATH = path.join(__dirname, 'messenger'); // 用来记录已经下载过的资源，防止重复下载 const loadedResourceMap = new Map(); const loadErrorSet = new Set(); async function downloadHtmlPage(urlObj) { if (!fse.existsSync(urlObj.outputPath)) { await downloadHtmlResource(urlObj) } else { loadedResourceMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bc61fe254ee48cb0307b6821b32d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fca321cbb65c3dcc246255abda4e19c/" rel="bookmark">
			针对给定数据集ORL_Faces，提取图像的特征(可以采用多种特征） 并图像进行分类，分类方法自选。训练数据集和测试数据集采用随机划分的方法生成，测试样本占比为20%。图像 可以经过预处理。要求 (1...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于给定的 ORL_Faces 数据集，我们可以使用多种方法来提取图像的特征，并使用不同的分类算法对图像进行分类。
在特征提取方面，我们可以使用纹理特征，例如灰度共生矩阵(GLCM)或灰度差分共生矩阵(GDLCM)，以及基于滤波器的特征，例如 Gabor 滤波器或 DoG(差分 of Gaussians)滤波器。我们还可以使用基于形态学的特征，例如形态学梯度(Morphological gradient)或形态学开运算(Morphological dilation)。
在分类方面，我们可以使用机器学习算法，如 K 近邻(KNN)、决策树、朴素贝叶斯(Naive Bayes)或支持向量机(SVM)。我们还可以使用深度学习算法，如卷积神经网络(CNN)或循环神经网络(RNN)。
下面是一个使用 Python 实现特征提取和分类的例子，使用了 GLCM 特征和 KNN 分类器：
```python from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score from skimage.feature import greycomatrix, greycoprops from skimage import io import numpy as np
读取图像并进行预处理 X_train, y_train, X_test, y_test = [], [], [], [] for i in range(40): for j in range(10): img = io.imread(f'data/s{
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/186/">«</a>
	<span class="pagination__item pagination__item--current">187/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/188/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>