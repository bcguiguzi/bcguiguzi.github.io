<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb94cc57c89f4b3bcbedd8ef67ed7726/" rel="bookmark">
			Warning in ./libraries/session.inc.php#105
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开phpmyadmin页面时突然提示如下错误：
Warning in ./libraries/session.inc.php#105
session_start(): open(/var/lib/php/session/sess_g5j035mu0dieucb8ssshmb7mspe21b0f, O_RDWR) failed: Permission denied (13)
Backtrace
./libraries/session.inc.php#105: session_start()
./libraries/common.inc.php#350: require(./libraries/session.inc.php)
./index.php#12: require_once(./libraries/common.inc.php)
看了一下/var/lib/php/session目录的属性：
结果显示session目录的用户组显示为apache，而我的nginx的用户组是nginx，因此在将session目录的用户组修改成nginx后问题得到解决。
据我猜测如果还是不行的话可能是php-fpm的用户组设置问题。因为nginx默认使用的是php-fpm来解析php的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b515b908dd336bbf8cfbd454c912824/" rel="bookmark">
			配置hive的坑 hive-site.xml:2787:3: The element type &#34;configuration&#34; must be terminated by the matching
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 配置完hive,运行遇到以下问题
hive-site.xml:2787:3: The element type "configuration" must be terminated by the matching end-tag "&lt;/configuration&gt; 现象 详细的输出是 “`xml [Fatal Error] hive-site.xml:2787:3: The element type “configuration” must be terminated by the matching end-tag “”. 17/04/01 18:03:12 FATAL conf.Configuration: error parsing conf file:/usr/local/hive/conf/hive-site.xml org.xml.sax.SAXParseException; systemId: file:/usr/local/hive/conf/hive-site.xml; lineNumber: 2787; columnNumber: 3; The element type “configuration” must be terminated by the matching end-tag “”. at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:257) at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:347) at javax.xml.parsers.DocumentBuilder.parse(DocumentBuilder.java:150) at org.apache.hadoop.conf.Configuration.parse(Configuration.java:2325) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b515b908dd336bbf8cfbd454c912824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a932f51394aeb19be5a78e21727e64db/" rel="bookmark">
			LR_参数设置和VSUER关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际应用中迭代次数都为1，不是用设定虚拟用户数和参数的关系来完成并发测试，是使用持续加载时间，一直执行某个成个功能程序来完成的。所以不用太关系虚拟用户取参数和并发之间的关系，只要明白参数的使用就好。
参数个数：10个
tester1、tester2、tester3…tester10
迭代次数：2次
场景设置(一)：Sequential+Each Iteration
执行结果：
VuGen中：1个用户
第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
Controller中：5个用户并发，每个用户
第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
（备注：5个用户每次迭代取值都相同，强调了用户之间的一致性）
场景设置(二)：Sequential+Each Occurrence
执行结果：
VuGen中：1个用户，1次迭代
第一次出现(Occurrence)取值为tester1
第二次出现(Occurrence)取值为tester2
Controller中：5个用户，1次迭代
第一次出现(Occurrence)取值为tester1
第二次出现(Occurrence)取值为tester2
每次迭代以此类推…
（备注：5个用户每次出现取值都相同，每次迭代取值都不同）
场景设置(三)：Sequential+Once
执行结果：
VuGen中：1个用户
每次都取同一个值，无论迭代多少次，都取tester1
Controller中：5个用户
每次都取同一个值，无论迭代多少次，都取tester1
（备注：5个用户每次都取同一个值，无论迭代多少次）
场景设置(四)：Unique+Each Iteration+Abort Vuser
执行结果：
VuGen中：1个用户
第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
Controller中：5个用户
用户1：第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
用户2：第一次迭代(Iteration)取值为tester3
第二次迭代(Iteration)取值为tester4
.
.
.
以此类推…
（备注：当6个用户并发时，会出现参数不够的情况，有一个用户就会被终止）
场景设置(五)：Unique+Each Iteration+Continue in a cycle manner
执行结果：
VuGen中：1个用户
第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
Controller中：5个用户
用户1：第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
用户2：第一次迭代(Iteration)取值为tester3
第二次迭代(Iteration)取值为tester4
.
.
用户6：第一次迭代(Iteration)取值为tester1
第二次迭代(Iteration)取值为tester2
以此类推…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a932f51394aeb19be5a78e21727e64db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f93dee803ac8bc62afcff0060bdb32c/" rel="bookmark">
			《垃圾回收的算法与实现》——GC复制算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 GC复制算法将堆分成From和To两个内存块，当From被占满时GC将From中的存活对象复制到To中，同时将From和To交换。通过递归遍历GC root(即采用深度优先)复制存活对象，对于已经复制过的标记其COPIED字段。复制过的对象将在From的对象的forwarding记录To中该对象地址，以便于其余引用了该对象的引用进行修改。分配对象时将先判断From中连续可用空间是否够用(复制算法不存在碎片)，如果不够则进行一次GC，还不够则分配失败。 优缺点 优点 吞吐量大，只需要遍历一次From空间Sweep需要遍历两次，而且只复制存活的对象。高速分配，不需要通过空闲链表直接在连续的内存上进行分配。没有碎片。与缓存兼容，复制存活对象时采用深度优先算法使相关联的对象都在附近。 缺点 堆的使用效率低，必须分配一个To，其不能分配对象。不兼容保守式GC算法，需要移动对象。递归调用，复制对象的深度优先算法是通过递归调用实现的，递归将消耗栈等资源。 改进 Cheney的GC复制算法 针对递归
复制算法的To中增加scan指针，其指向To中已经复制过所有子对象位置。首先将GC root直接引用的对象复制到To中，而后通过scan指针的移动对后续存活对象进行复制。实现了广度优先搜索算法通过scan在To中的移动实现了一个隐式的FIFO队列。取消COPIED字段，通过forwarding字段是否指向To区间来判断该对象是否已被复制。优点在于取消了递归，缺点则是采用了广度优先算法使其与缓存不兼容。 近深度优先搜索方法 针对Cheney的复制算法中与缓存不兼容问题
page：堆分隔成一个个页面的数组；local_scanf：每个页中搜索用的指针作为元素的数组；major_scan：指向未搜索完的页面开头；free：分块开头；第一阶段从GC root中将其直接引用复制到第一个页中。而后对每个对象按照类似深度优先算法，区别在于其原始深度优先算法每层一次只搜索一个对象而该算法则将同一层一次搜索完 此处没懂，还有页占满的问题 多空间复制算法 针对堆利用率低
将堆分成多份，每次取其中的两个分别作为From和To，其余则采用Mark-Sweep算法。From总在To的右边的块中，每执行一次GC，From和To均向右移动一个块。在GC时先进行标记阶段，当存活对象处于From时执行copy，当处于其余块时执行mark。优点在于提高了堆的利用率，缺点则是引入了Mark-Sweep算法导致STW时间变长，分块得采用空闲链表 转载于:https://www.cnblogs.com/suolu/p/6654236.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db1ce223b2d784723c1f7da29b3c6fc/" rel="bookmark">
			uart中：起始位，停止位，就校验位，数据位，数据位的位数，波特率，数据通讯的接口定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UART简介 通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART。UART通信在工作中相当常见，项目中需要生成uart信号，在博客中记录下。uart是异步通信，因为它只有一根线就可以数据的通信。不像SPI,I2C等同步传输信号。所以串口的传输速度和其它协议的速度相比是比较慢的。下面具体讲解一些uart协议以及是如何通信的。
图-1
图-2 上图是uart协议传输一个”A”字符通过示波器的uart解码而得到的波形示意图。根据此图来介绍一下uart的一些基本参数。 波特率：此参数容易和比特率混淆，其实他们是由区别的。具体可以百度更清楚。但是我认为uart中的波特率就可以认为是比特率，即每秒传输的位数(bit)。一般选波特率都会有9600,19200,115200等选项。其实意思就是每秒传输这么多个比特位数(bit)。 起始位:先发出一个逻辑”0”的信号，表示传输数据的开始。 数据位:可以选择的值有5,6,7,8这四个值，可以传输这么多个值为0或者1的bit位。这个参数最好为8，因为如果此值为其他的值时当你传输的是ASCII值时一般解析肯定会出问题。理由很简单，一个ASCII字符值为8位，如果一帧的数据位为7，那么还有一位就是不确定的值，这样就会出错。 校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。就比如传输“A”(01000001)为例。 1、当为奇数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为1才能满足1的个数为奇数(奇校验)。图-1的波形就是这种情况。 2、当为偶数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为0才能满足1的个数为偶数(偶校验)。 此位还可以去除，即不需要奇偶校验位。 停止位：它是一帧数据的结束标志。可以是1bit、1.5bit、2bit的空闲电平。可能大家会觉得很奇怪，怎么会有1.5位~没错，确实有的。所以我在生产此uart信号时用两个波形点来表示一个bit。这个可以不必深究。。。 空闲位：没有数据传输时线路上的电平状态。为逻辑1。 传输方向：即数据是从高位(MSB)开始传输还是从低位(LSB)开始传输。比如传输“A”如果是MSB那么就是01000001（如图-2），如果是LSB那么就是10000010（如下图的图-4） uart传输数据的顺序就是：刚开始传输一个起始位，接着传输数据位，接着传输校验位(可不需要此位)，最后传输停止位。这样一帧的数据就传输完了。接下来接着像这样一直传送。在这里还要说一个参数。 帧间隔:即传送数据的帧与帧之间的间隔大小，可以以位为计量也可以用时间(知道波特率那么位数和时间可以换算)。比如传送”A”完后，这为一帧数据，再传”B”，那么A与B之间的间隔即为帧间隔。 图-3
图-4 上两图和下两图传送的数据和波特率都是一样的，但是有几个参数是故意设置反了从而形成对比。
http://blog.csdn.NET/gq1900/article/details/51885259
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ec11881dde92f8e64c1f6aa4591c49/" rel="bookmark">
			onHiddenChanged - 更好的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合之前写的一篇关于onHiddenChanged 的 : http://blog.csdn.net/qq_28261207/article/details/64129808
这次的场景：
| -&gt; fragment1
|
首页有个MainActivity -&gt; | -&gt; fragment2
|　| -&gt; fragment3_1
| -&gt; fragment3 ----- |
|　| -&gt; fragment3_2 ---&gt; DetailActivity
| -&gt; fragment4
问题：在 fragment3_2 里是个列表, 点击列表item可以调到列表详情页 DetailActivity , 然后从 DetailActivity 按返回键回到 fragment3_2 时, 刷新列表 . 如果在 fragment3_2 里用 onResume() 来刷新内容, 那么运行一下就会发现 , 从其他的Activity返回到 fragment1 / fragment2 / .... 这些 fragment 时 , fragment3_2 也会刷新数据 . 原因在之前那篇已经说过了 . 所以这样写很不好 . 如果再这里用 onHiddenChange , 返回时是不能刷新的 , 只能在切换fragment3_1 和fragment3_2 时得到刷新的内容 , 所以这样写也不好 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ec11881dde92f8e64c1f6aa4591c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05ff569d03c0c5e7aed5114252a0163/" rel="bookmark">
			I&#39;m coming!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Internet is whole world! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7009f9a57d1170bf2dc1d129ef4546b1/" rel="bookmark">
			linux命令之----fdisk命令-磁盘分区管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、fdisk命令作用
fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表，是一个磁盘分区管理工具。
1）什么是分区？
分区是将一个硬盘驱动器分成若干个逻辑驱动器，分区是把硬盘连续的区块当做一个独立的磁硬使用。分区表是一个硬盘分区的索引,分区的信息都会写进分区表。
2）为什么要有多个分区？
防止数据丢失：如果系统只有一个分区，那么这个分区损坏，用户将会丢失所的有数据。
增加磁盘空间使用效率：可以用不同的区块大小来格式化分区，如果有很多1K的文件，而硬盘分区区块大小为4K，那么每存储一个文件将会浪费3K空间。这时我们需要取这些文件大小的平均值进行区块大小的划分。
数据激增到极限不会引起系统挂起：将用户数据和系统数据分开，可以避免用户数据填满整个硬盘，引起的系挂起。
2、fdisk语法
fdisk [必要参数][选择参数]
必要参数：
-l 列出素所有分区表-u 与"-l"搭配使用，显示分区数目 选择参数：
-s&lt;分区编号&gt; 指定分区-v 版本信息 菜单操作说明
m ：显示菜单和帮助信息a ：活动分区标记/引导分区d ：删除分区l ：显示分区类型n ：新建分区p ：显示分区信息q ：退出不保存t ：设置分区号v ：进行分区检查w ：保存修改x ：扩展应用，高级功能 3、fdisk案例 1） fdisk -l 命令-显示当前分区情况
解析：
第一块：设备介绍
块设备名称为/dev/sda 大小274.9G255个磁面；63个扇区；33418个磁柱
第二块：硬盘分区（/dev/sda）
硬盘分区的表示：在Linux 是通过hd*x 或 sd*x 表示的，其中 * 表示的是a、b、c …… …… x表示的数字 1、2、3 …… …… hd大多是IDE硬盘；sd大多是SCSI或移动存储；
引导（Boot）：表示引导分区
Start （开始）：表示的一个分区从X cylinder（磁柱）开始；
End （结束）：表示一个分区到 Y cylinder（磁柱）结束；
id和System 表示的是一个意思确认分区类型,如id=8e表示linux lvm
Blocks（容量）：表示的意思的确是容量的意思，其单位是K；
Blocks = （相应分区End数值 - 相应分区Start数值）x 单位cylinder（磁柱）的容量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7009f9a57d1170bf2dc1d129ef4546b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f916ab60843792b682c4334b87c61c/" rel="bookmark">
			thymeleaf中fragment 的layout布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 配置 如果要引入fragment的layout，需要添加依赖：
compile('nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:1.2.1') 2 layout的引用 定义一个layout文件，目录为/WEB-INF/views/task/layout.html，内容如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!--/* Each token will be replaced by their respective titles in the resulting page. */--&gt; &lt;title layout:title-pattern="$DECORATOR_TITLE - $CONTENT_TITLE"&gt;Task List&lt;/title&gt; ... &lt;/head&gt; &lt;body&gt; &lt;!--/* Standard layout can be mixed with Layout Dialect */--&gt; &lt;div th:replace="fragments/header :: header"&gt; ... &lt;/div&gt; &lt;div class="container"&gt; &lt;div layout:fragment="content"&gt; &lt;!-- ============================================================================ --&gt; &lt;!-- This content is only used for static prototyping purposes (natural templates)--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f916ab60843792b682c4334b87c61c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7a343a6e11099555c8ba7c084740fa/" rel="bookmark">
			Synchronized同步静态方法和非静态方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。
Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。
情况1：同一个对象在两个线程中分别访问该对象的两个同步方法
结果：会产生互斥。
解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。
情况2：不同对象在两个线程中调用同一个同步方法
结果：不会产生互斥。
解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，
2.Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。
情况1：用类直接在两个线程中调用两个不同的同步方法
结果：会产生互斥。
解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。
注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。
情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法
结果：会产生互斥。
解释：因为是一个对象调用，同上。
情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法
结果：不会产生互斥。
解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。
测试代码：
同步方法类：SynchronizedTest.java
public class SynchronizedTest { /*private SynchronizedTest(){} private static SynchronizedTest st; //懒汉式单例模式，线程不安全，需要加synchronized同步 public static SynchronizedTest getInstance(){ if(st == null){ st = new SynchronizedTest(); } return st; }*/ /*private SynchronizedTest(){} private static final SynchronizedTest st = new SynchronizedTest(); //饿汉式单利模式，天生线程安全 public static SynchronizedTest getInstance(){ return st; }*/ public static SynchronizedTest staticIn = new SynchronizedTest(); //静态对象 public synchronized void method1(){ //非静态方法1 for(int i = 0;i &lt; 10;i++){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd7a343a6e11099555c8ba7c084740fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0673a3eda8ec5eb08183ac8d48d18d/" rel="bookmark">
			could not find com.android.tools.build:gradle:2.2.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将项目的 build.gradle中的
buildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' } } allprojects { repositories { jcenter() } } task clean(type: Delete) { delete rootProject.buildDir } 改为： buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0673a3eda8ec5eb08183ac8d48d18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88f0466db4b9c06ac702a6a2840a493/" rel="bookmark">
			贝叶斯决策思想的应用与延伸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.贝叶斯的应用 以下举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。
1.1 中文分词 贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述，详细请参考吴军的文章。
分词问题的描述为：给定一个句子（字串），如：南京市长江大桥
如何对这个句子进行分词（词串）才是最靠谱的。例如：
1. 南京市/长江大桥
2. 南京/市长/江大桥
这两个分词，到底哪个更靠谱呢？
我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：
P(Y|X) ∝ P(Y)*P(X|Y)
用自然语言来说就是 这种分词方式（词串）的可能性 乘以这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串： W1, W2, W3, W4 .. 的可能性呢？ 我们知道，根据联合概率的公式展开：P(W1, W2, W3, W4 ..) = P(W1) * P(W2|W1) * P(W3|W2, W1) * P(W4|W1,W2,W3) * .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。 为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) * P(W2|W1) * P(W3|W2) * P(W4|W3) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a88f0466db4b9c06ac702a6a2840a493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935a45ece9df347bed95bdb6cbe1d55e/" rel="bookmark">
			在项目中导入import javax.servlet 出错解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有时会把别人的项目copy到自己这里进行二次开发或者参考学习，有的时候会发生下图的错误，即eclipse项目里我们导入的项目里提示HttpServletRequest 不能引用，会伴随头疼的小红叉出现
具体原因是我们工程里面web-inf/lib目录下少了相应的包：Package javax.servlet.http引起的；通俗且确切的讲就是缺少TOMCAT_HOME\lib下的servlet-api.jar。在别人的机器上他配置了Server，一般都是tomcat，而在拷贝的过程中Server的那些library是不会随项目一起拷贝过来的，除非别人把tomcat的library已经拷贝到WEB-INF\lib下了。
具体的解决办法是：
1、直接在tomcat的安装文件lib下面找到servlet-api.jar，将它直接copy到WEB-INF\lib下就好了；
2、或者是找路径：Project -&gt; Properties -&gt; Java Build Path -&gt; Add Library -&gt; Server Runtime -&gt; next -&gt; 选择你的Server -&gt; Finish。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a73c114728d70e08ed496c9d3a41aa/" rel="bookmark">
			数字信号处理中的自相关和互相关计算和物理意义（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先说说自相关和互相关的概念。 这个是信号分析里的概念，他们分别表示的是两个时间序列之间和同一个时间序列在任意两个不同时刻的取值之间的相关程度，即互相关函数是描述随机信号x(t),y(t)在任意两个不同时刻t1，t2的取值之间的相关程度，自相关函数是描述随机信号x(t)在任意两个不同时刻t1，t2的取值之间的相关程度。
自相关函数是描述随机信号X(t)在任意两个不同时刻t1，t2的取值之间的相关程度；互相关函数给出了在频域内两个信号是否相关的一个
判断指标，把两测点之间信号的互谱与各自的自谱联系了起来。它能用来确定输出信号有多大程度来自输入信号，对修正测量中接入噪声源而产生
的误差非常有效.
事实上，在图象处理中，自相关和互相关函数的定义如下：设原函数是f(t)，则自相关函数定义为R(u)=f(t)*f(-t)，其中*表示卷积；设两个函数分别是f(t)和g(t)，则互相关函数定义为R(u)=f(t)*g(-t)，它反映的是两个函数在不同的相对位置上互相匹配的程度。
通信系统中，自相关性决定多径干扰，互相关性决定了多址干扰。
那么，如何在matlab中实现这两个相关并用图像显示出来呢？
dt=.1;
t=[0:dt:100];
x=cos(t);
[a,b]=xcorr(x,'unbiased');
plot(b*dt,a)
上面代码是求自相关函数并作图，对于互相关函数，稍微修改一下就可以了，即把[a,b]=xcorr(x,'unbiased');改为[a,b]=xcorr(x,y,'unbiased');便可。
2. 实现过程：
在Matalb中，求解xcorr的过程事实上是利用Fourier变换中的卷积定理进行的，即R(u)=ifft(fft(f)×fft(g))，其中×表示乘法，注：此公式仅表示形式计算，并非实际计算所用的公式。当然也可以直接采用卷积进行计算，但是结果会与xcorr的不同。事实上，两者既然有定理保证，那么结果一定是相同的，只是没有用对公式而已。下面是检验两者结果相同的代码：
dt=.1;
t=[0:dt:100];
x=3*sin(t);
y=cos(3*t);
subplot(3,1,1);
plot(t,x);
subplot(3,1,2);
plot(t,y);
[a,b]=xcorr(x,y);
subplot(3,1,3);
plot(b*dt,a);
yy=cos(3*fliplr(t)); % or use: yy=fliplr(y);
z=conv(x,yy);
pause;
subplot(3,1,3);
plot(b*dt,z,'r');
即在xcorr中不使用scaling。
3. 其他相关问题：
（1）相关程度与相关函数的取值有什么联系？
相关系数只是一个比率，不是等单位量度，无什么单位名称，也不是相关的百分数，一般取小数点后两位来表示。相关系数的正负号只表
示相关的方向，绝对值表示相关的程度。因为不是等单位的度量，因而不能说相关系数0.7是0.35两倍，只能说相关系数为0.7的二列变量相关程度
比相关系数为0.35的二列变量相关程度更为密切和更高。也不能说相关系数从0.70到0.80与相关系数从0.30到0.40增加的程度一样大。
对于相关系数的大小所表示的意义目前在统计学界尚不一致，但通常按下是这样认为的：
相关系数 相关程度
0.00-±0.30 微相关
±0.30-±0.50 实相关
±0.50-±0.80 显著相关
±0.80-±1.00 高度相关
（2）matlab计算自相关函数autocorr和xcorr有什么不一样的？
分别用这两个函数对同一个序列计算，为什么结果不太一样？因为xcorr是没有将均值减掉做的相关，autocorr则是减掉了均值的。而且，用离散信号做自相关时，信号截取长度（采样点N）不一样，自相关函数就不一样。 （3）xcorr是计算互相关函数，带有一个option的参数:
a=xcorr(x,y,'option')
option=baised时，是计算互相关函数的有偏估计；
option=unbaised时，是计算互相关函数的无偏估计；
option=coeff时，是计算归一化的互相关函数，即为互相关系数，在-1至1之间；
option=none，是缺省的情况。
所以想要计算互相关系数，可用'coeff'参数。 ************************************************************************* 用这个xcorr函数作离散互相关运算时要注意，当x,y是不等长向量时，短的向量会自动填0与长的对齐，运算结果是行向量还是列向量就与x一样。 互相关运算计算的是x,y两组随机数据的相关程度，使用参数coeff时，结果就是互相关系数，在-1至1之间，否则结果不一定在这范围，有可能很大也有可能很小，这视乎x,y数据的大小，所以一般要计算两组数据的相关程度，一般选择coeff参数，对结果进行归一化。 所谓归一化简单理解就是将数据系列缩放到-1到1范围，正式的就是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。变换式为X=(X实测--Xmin)/(Xmax-Xmin)。 一般来说选择归一化进行互相关运算后，得到结果绝对值越大，两组数据相关程度就越高。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced6706977c70e5f8fe255f2af601613/" rel="bookmark">
			app混淆加固&#43;防止反编译&#43;360加固
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android studio混淆加密，没有使用第三方加密后的效果好，混淆加密还能看到大体的混淆包名，使用了那些框架
而使用了360加固后，全部看不到了
下图是360加固window操作IDE，非常好用！
然后用反编译软件反编译后，全然看不到任何东西了，只看到一个com.qihoo.util的东西
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e84a52f9efba09205139a015ed8c009/" rel="bookmark">
			spring中通过注解配置bean出错：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推酷网上的这一篇讲解的很好：http://www.tuicool.com/articles/riQJzuJ
本人在自己跟着尚硅谷上的spring4.0的视频课程学习的时候，在13课的时候跟着视频一行一行的撸代码的，可是还是出现了错误。错误提示如下：Exception in thread "main" org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource [beans-annotation.xml]; nested exception is java.lang.NoClassDefFoundError: org/springframework/aop/TargetSource
大致意思就是找不到class，而且是在.xml文件出的错，真是百思不得其解啊。然后就去吃饭去了。。。
吃完饭回来之后觉得应该换个角度思考一下这个问题，就到网上看看其他人在讲解“spring注解配置bean”的文章，然后就看到上面的文章，然后就找到了问题出错的原因，错误不在代码：在项目中没有导入spring-aop-4.0.5.RELEAE.jar这个包！！
然后在导入这个包之后，程序就正确运行了。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5dd79bf405cbd518fb38532869b4f7b/" rel="bookmark">
			中国四大骨干网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CHINANET，CERNET，CSTNET，CHINAGBN，合起来称为中国四大骨干网。即联通我们全中国后与世界internet连通的四大组网硬件架构，我们能接触到的是驻地网运营商，而各个运营商是依托于这四大骨干网来承载网络业务的。
（1）中国公用计算机互联网（CHINANET） 中国公用Internet网，CHINANET由骨干网、接入网组成，骨干网是其主要信息通路，由直辖市和各省会城市的网络节点构成；接入网是各省（区）建设的网络接点形成的网络。CHINANET的灵活接入方式和遍布全国各城市的接入点，可以方便地接入国际Internet, 享用Internet上的丰富信息资源和各种服务，并可为国内的计算机互联，为国内的信息资源共享提供方便的网络环境。 （2）中国教育与科研网（CERNET） 包括北京（网络中心）、上海、南京、广州、武汉、西安、成都和沈阳等高等学校集中的大城市。有连接美国的国际专线。全国主干网（共11条64Kbps DDN专线）于1995年10月开通。二期工程完成后，全国主干网和国际联网的逐步升级，主干网达到2Kbps以上，国际联网达到8Kbps以上。 （3）中国科学技术网（CSTNET） 由中国科学院主持，联合清华、北大共同建设。1994年4月开通了与Internet的专线连接。1994年5月21日完成了我国最高域名CN主服务器的设置，实现了与Internet的TCP/IP连接。1995年底基本完成“百所联网”工程。成为中国地域广、用量大、性能好、通信量大、服务设施齐全的全国性科研教育网络。
中国金桥信息网（CHINAGBN） 即国家公用经济信息通信网，由原电子工业部管理，面向政府、企业、事业单位和社会公众提供数据通信和信息服务。金桥网年底与Internet连通，已开通24个城市，发展了1000多个本地和远程仿真终端，提供全面的Internet服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b802a00b9270cacf1e5e43aa099101/" rel="bookmark">
			腾讯云服务器申请SSL证书, 配置Nginx,  实现HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，首先去腾讯云，申请SSL证书。
我们这里申请的是免费的SSL，免费的可以用一年。收费的有点贵，5000起。
2，按步骤申请后，得到四种主流web服务器的证书，如下：
这里我们使用的是Nginx的证书：
3，把证书上传到Linux服务器中。
这里我新建一个了目录： /home/key_dir/ ，然后把这俩证书文件放进去。
4，更改 nginx.conf 配置，使HTTPS生效：
server {
listen 443 ssl;
server_name 申请证书时绑定的域名(如果是通配符的泛域名, 那就写这台服务器对应的子域名）; charset utf-8;
ssl_certificate /home/key_dir/申请的证书.crt; ssl_certificate_key /home/key_dir/申请的证书.key;
}
5，重启Nginx，然后打开网址，发现OK了，HTTPS通过，绿色！
附录：
nginx官网配置（其实跟上文一样，只不过把默认的protocol写出来了）：
http://nginx.org/en/docs/http/configuring_https_servers.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcb73e4f9e7e0c86b86b65d31d4a322/" rel="bookmark">
			Switch的的case同时付多个值的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Switch的的case同时付多个值的写法： 今天有个作业题目如下： switch结构实现，根据用户输入月份，显示对应的季节（例如：3,4,5为春季）
老师和w3school里面的案例都是类似下面这样的结构：
switch(n) { case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: n 与 case 1 和 case 2 不同时执行的代码 }
但我们的题目是3个值对应一个输出，按照上面的格式写，要重复写不少代码。我首先试了逻辑运算符“||”将值连起来，发现不能奏效。最后的正确做法应该如下： case 3:case 4:case 5:alert(month+"是春季");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83eb6a3d3a878f0ef7908db6eebc6242/" rel="bookmark">
			javascript经典面试题之for循环click
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典重现 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; function onMyLoad(){ var arr = document.getElementsByTagName("p"); for(var i = 0; i &lt; arr.length; i++){ arr[i].onclick = function(){ alert(i); } } } &lt;/script&gt; &lt;/head&gt; &lt;body onload="onMyLoad()"&gt; &lt;p&gt;0&lt;/p&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 该段代码期望实现效果如下：点击p标签，弹出该p标签位置序号。请问上述代码能否实现该需求，如果不能，应该如何实现？
原题分析 答案显而易见，不能。点击每个p标签都会弹出5。
要解决此问题，首先要了解闭包的概念。闭包是JavaScript语言的一个难点，也是它的特色，很多高级应用都要依靠它来实现。
变量作用域 JavaScript变量作用域的特点在于，函数内部可以读取该函数外部的变量，但函数外部无法读取该函数内部定义的变量，但是我们可以通过变通的方式获得。那就是在函数内部再定义一个函数：
function foo(){ var n=999; function fee(){ alert(n); // 999 } } 在上面的代码中，函数fee就被包括在函数foo内部，这时foo内部的所有局部变量，对fee都是可见的。但是反过来就不行，fee内部的局部变量，对foo就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
既然fee可以读取foo中的局部变量，那么只要把fee作为返回值，我们不就可以在foo外部读取它的内部变量了吗！
闭包的概念 简而言之，闭包就是能够读取其他函数内部变量的函数，由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包的用途 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
function f1(){ var n=999; nAdd=function(){ n+=1 } function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83eb6a3d3a878f0ef7908db6eebc6242/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/477/">«</a>
	<span class="pagination__item pagination__item--current">478/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/479/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>