<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a1c9bdfec036e983346caebc83c82b/" rel="bookmark">
			使用进程池时遇到的坑... TypeError: can‘t pickle _thread.lock objects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用多进程的进程池对我的爬虫程序进行处理时, 采用方式如下:
mymongo = myMongo() lock = multiprocessing.Manager().Lock() newMain = functools.partial(main, lock, mymongo) pool = multiprocessing.Pool() pool.map(newMain, [i for i in range(1000)]) pool.close() pool.join() 当运行代码时, 抛出如下异常:
Traceback (most recent call last):
File "/Users/vicshang/kepner/study/Tedu_AID1803/aid1803_kep/myutil/movieCommentsMaoyan.py", line 106, in &lt;module&gt;
pool.map(newMain, [i for i in range(1000)])
File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/pool.py", line 266, in map
return self._map_async(func, iterable, mapstar, chunksize).get()
File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/pool.py", line 644, in get
raise self._value
File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/pool.py", line 424, in _handle_tasks
put(task)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a1c9bdfec036e983346caebc83c82b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc426d34ce36b768582bd76fba54d2df/" rel="bookmark">
			Linux下的Filesystem Hierarchy Standard（文件系统层次化标准）浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实在类Unix系统当中，使用最多的就是Linux
多数Linux版本采用这种文件组织形式，类似于Windows操作系统中c盘的文件目录，FHS采用树形结构组织文件
给类Unix这一类的操作系统制定的标准，让我们去预知，文件和目录放在什么位置，就比如说 /etc 目录用于存放系统中的配置文件
其实之所以我们去定义这个标准，一是因为方便管理，二就是开发Linux的人太多了，如果每个人都去使用自己的目录配置方法，没有这个标准，以后Linux是很难维护的，因为目录结构不同，会有很大的差异性，所以就有了Filesystem Hierarchy Standard
下面简单的介绍下其的基本目录结构
/ 表示根目录，是所有文件和目录的起点根Windows下不一样有多个根目录，C盘、D盘这些根目录，其他所有目录都在这个根目录下面
/bin : 是”binary 的简写”，存放的是提供用户级基础功能的二进制文件ls、cat、cp、mkdir 等一些常用的二进制命令
/boot存放着Linux的内核和引导程序所需的文件目录 其中简单的介绍下grub的作用，其实这个东西我们是非常的熟悉了
GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数，也就是下面这个功能的体现
我们进入grub文件夹下面，我们去查看其的内容
我们需要关注的就是grub.conf文件，这个是grub的主配置文件，通过这个配置文件，grub才能找到kernel，系统才能正常启动
/dev 设备文件，在linux的文件系统下面，都有对应的文件与这些设备关联的。访问它们就可以访问到实际硬件，Linux下将其链接成文件之后，操作就简单多了。直接进行读文件，写文件就可以向设备发送读或者写操作了。按照读写所存储数据的方式，其分为字符型设备，块设备等，其实/dev目录下的设备目录它实际上是一个访问这些外部设备的端口
下面就是/dev目录下的部分内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9085f40d0fafab4afdfac2808b0254/" rel="bookmark">
			在Ubuntu下装dock6（用于分子对接的程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为我新装的ubuntu是比较裸的系统，并没有c++编译环境，所以需要先装g++，gfortran，没有make的话也要装一下。语句如下：
sudo apt-get install build-essential sudo apt-get install gfortran 如果apt-get版本比较落后的话要用apt-get update更新一下。
另外还要安装下面这两个东西，虽然不知道是什么，但是不装的话在make all的时候会报错。
apt-get install byacc apt-get install flex 另附dock6的安装流程：
tar zxvf dock.6.8_source.tar.gz cd dock6/install ./configure gnu make all make dockclean cd test make test make check 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd33a4bc23dc82be3630384acf10f4f3/" rel="bookmark">
			Android 系统（208）---OTA升级后概率性出现卡在开机动画界面无法退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OTA升级后概率性出现卡在开机动画界面无法退出
OTA升级之后，手机会概率性卡在开机动画界面，log 显示 media.player died:
01-01 20:06:46.273062 288 288 E art : Cannot patch secondary image '/system/framework/boot-framework.art', clearing dalvik_cache and restarting zygote. //&lt;==zygote重启
01-01 20:06:46.298441 247 247 I ServiceManager: service 'media.player' died 01-01 20:06:46.306115 513 574 D BootAnimation: threadLoop() movie() //&lt;==开始播放开机动画
导致开机动画退出不了，也没有开机铃声播放。
原因：
OTA之后第一次开机，由于zygote检测到boot-framework.art这支文件的校验和不对（system分区在OTA升级后会更新，但是data分区下的文件在OTA升级中不更新仍旧是旧版本的，造成data和system目录下的.art、.oat文件不匹配），于是clearing了dalvik-cache里面的内容。zygote重启，zygote挂掉之后，引起media server挂掉，进而导致没有声音。也无法满足开机动画退出条件checkExit();。
解决方法：
修改BootAnimation.cpp：
491bool BootAnimation::threadLoop() 492{
……
498 status_tmediastatus = NO_ERROR;
…… 508 if (mediastatus == NO_ERROR) { 509 ALOGD("mediaplayer is initialized"); 510 Parcel* attributes = new Parcel(); 511 attributes-&gt;writeInt32(AUDIO_USAGE_MEDIA); //usage 512 attributes-&gt;writeInt32(AUDIO_CONTENT_TYPE_MUSIC); //audio_content_type_t 513 attributes-&gt;writeInt32(AUDIO_SOURCE_DEFAULT); //audio_source_t 514 attributes-&gt;writeInt32(0); //audio_flags_mask_t 515 attributes-&gt;writeInt32(1); //kAudioAttributesMarshallTagFlattenTags of mediaplayerservice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd33a4bc23dc82be3630384acf10f4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/002179688055d5c7dd74b9b17cd55e3d/" rel="bookmark">
			（在本地运行项目）npm报错：npm ERR! missing script: start npm ERR! A complete log of this run  can be found in: ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、克隆项目：gi tclone XXXXX.git（可以在终端运用git命令行下载，也可以直接在webStorm中下载）
2、安装node.js（电脑上已经安装成功，此步骤可省略）
3、安装依赖：进入到项目文件夹内，npm install（由于git上只会存在package.json，而不会存在node_modules，所以需要根据package.json上的内容，在本地重新加载一份node_modules，用来确保vue项目得以运行）
4、启动服务：进入到项目文件夹内，npm run dev
5、发布代码：npm run dist
转载于:https://www.cnblogs.com/jy13638593346/p/9344726.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335105bbff92cd482700146d01e8099a/" rel="bookmark">
			前端处理文件流自动下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 公共导出功能 * model.url：请求后台地址 * model.name：下载文件名称 * model.data: 请求参数 * model.type: 请求类型 post get * */ function exportLists(model) { var layerIndex=layer.msg('正在导出文件，请稍后...', {icon: 16,shade: 0.01,time: 100000 }); var xhr=null; if (window.XMLHttpRequest) {//Mozilla 浏览器 xhr = new XMLHttpRequest(); }else { if (window.ActiveXObject) {//IE 浏览器 try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } catch (e) { try {//IE 浏览器 xhr = new ActiveXObject("Msxml2.XMLHTTP"); } catch (e) { } } } } xhr.open(model.type, model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335105bbff92cd482700146d01e8099a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ee26e18c223b8a96c65d7570f47bad/" rel="bookmark">
			【组合计数】ARC061F Card Game for Three
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 有三堆卡牌，牌数分别为N,M,K 每张牌有一个字母（’a’、’b’、’c’）表示下一个拿哪一堆。 现在要求第一堆首先拿完。求方案数。
分析： 首先，这道题有很多角度可以入手。但最简单的方法是，根据拿的牌的类型计算。 如果第一堆拿完，则拿的顺序中必然有n个a，且b的数量比m小，c的数量比k小。 但是最后一个必须限定为a，所以这部分拿了的方案数应为 Cn−1n−1+i C n − 1 + i n − 1 (i表示多拿的b和c的总和) 然后还要从这i个中选哪些是b，哪些是c，所以还要乘上 ∑0≤x&lt;m,0≤y&lt;k[x+y=i]Cxi ∑ 0 ≤ x &lt; m , 0 ≤ y &lt; k [ x + y = i ] C i x 所以有如下式子： Ans=∑i&lt;m+ki=0Cn−1n−1+i3m+k−i∑0≤x&lt;m,0≤y&lt;k[x+y=i]Cxi A n s = ∑ i = 0 i &lt; m + k C n − 1 + i n − 1 3 m + k − i ∑ 0 ≤ x &lt; m , 0 ≤ y &lt; k [ x + y = i ] C i x 然后这就可以拿所谓的部分分了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ee26e18c223b8a96c65d7570f47bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb75da16983806d4504f9d2fbbbb9e19/" rel="bookmark">
			三极管使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483 PNP型的三极管使用方法 常见的三极管为9012、s8550、9013、s8050.单片机应用电路中三极管主要的作用就是开关作用。其中9012与8550为pnp型三极管，可以通用。其中9013与8050为npn型三极管，可以通用。PNP与NPN两种三极管各引脚的表示：
三极管在我们数字电路和模拟电路中都有大量的应用，在我们开发板上也用了多个三极管。在我们板子上的 LED 小灯部分，就有这个三极管的应用了，图 3-5 的 LED 电路中的 Q16就是一个 PNP 型的三极管。
图 3-5 LED 电路
三极管的初步认识三极管是一种很常用的控制和驱动器件，常用的三极管根据材料分有硅管和锗管两种，原理相同，压降略有不同，硅管用的较普遍，而锗管应用较少，本课程就用硅管的参数来进行讲解。三极管有 2 种类型，分别是 PNP 型和 NPN 型。先来认识一下，如图 3-6。
图 3-6 三极管示意图
三极管一共有 3 个极，从图 3-6 来看，横向左侧的引脚叫做基极(base)，中间有一个箭头，一头连接基极，另外一头连接的是发射极 e(emitter)，那剩下的一个引脚就是集电极 c(collector)了。这是必须要记住的内容，死记硬背即可，后边慢慢用的多了，每次死记硬背一次，多次以后就会深入脑海了。
三极管的原理三极管有截止、放大、饱和三种工作状态。放大状态主要应用于模拟电路中，且用法和计算方法也比较复杂，我们暂时用不到。而数字电路主要使用的是三极管的开关特性，只用到了截止与饱和两种状态，所以我们也只来讲解这两种用法。三极管的类型和用法我给大家总结了一句口诀，大家要把这句口诀记牢了：箭头朝内 PNP，导通电压顺箭头过，电压导通，电流控制。下面我们一句一句来解析口诀。大家可以看图 3-6，三极管有 2 种类型，箭头朝内就是PNP，那箭头朝外的自然就是 NPN 了，在实际应用中，要根据实际电路的需求来选择到底用哪种类型，大家多用几次也就会了，很简单。三极管的用法特点，关键点在于 b 极（基极）和 e 级（发射极）之间的电压情况，对于PNP 而言，e 极电压只要高于 b 级 0.7V 以上，这个三极管 e 级和 c 级之间就可以顺利导通。也就是说，控制端在 b 和 e 之间，被控制端是 e 和 c 之间。同理，NPN 型三极管的导通电压是 b 极比 e 极高 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb75da16983806d4504f9d2fbbbb9e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b337e6c21b94f51a5cdec0414fbdb6/" rel="bookmark">
			侵入式开发与非侵入式开发的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设大家都想要把用户代码塞到一个框架里。两者区别就出来了：
侵入式的做法就是要求用户代码“知道”框架的代码，表现为用户代码需要继承框架提供的类。
非侵入式则不需要用户代码引入框架代码的信息，从类的编写者角度来看，察觉不到框架的存在。
举个栗子： 使用struts时，需要继承一些struts的类，这时struts侵入到了我的代码里。 使用spring时，编写一些业务类的时候不需要继承spring特定的类，通过配置完成依赖注入后就可以使用，此时，spring就没有侵入到我业务类的代码里。 世界上每一个物体的存在，必有其过人之处，但是人无完人，不可能存在永远完美的东西存在，其也会受到时代潮流的影响：
侵入式让用户代码产生对框架的依赖，这些代码不能在框架外使用，不利于代码的复用（缺点）。但侵入式可以使用户跟框架更好的结合，更容易更充分的利用框架提供的功能（优点）。 非侵入式的代码则没有过多的依赖，可以很方便的迁移到其他地方。但是与用户代码互动的方式可能就比较复杂。 这两种方式都有各自的利弊，主要看实际开发时怎么选择他了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dd5123ee313d758203622474270ef5/" rel="bookmark">
			STM32cube使用LAN8720芯片生成lwip初始代码的一些操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​3月25日优化精简项目：
首先使用cude设置好所有lan8720的引脚定义，包括REST和PHYAD0，下面是需要小改动的部分
Cube PHY address 根据PHYAD0选0，注意初始化引脚PHY_SR 0x001FPHY_SPEED_STATUS 0x0004PHY_DUPLEX_STATUS 0x0010While(1)加入MX_LWIP_Process();函数low_level_init加入LAN8720_RESET（）；函数 void LAN8720_RESET(void) { HAL_GPIO_WritePin(ETH_PHYAD0_GPIO_Port, ETH_PHYAD0_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(ETH_REST_GPIO_Port, ETH_REST_Pin, GPIO_PIN_RESET); HAL_Delay(55); HAL_GPIO_WritePin(ETH_REST_GPIO_Port, ETH_REST_Pin, GPIO_PIN_SET); HAL_Delay(55); } 3月26日 udp调试纪录
循环里直接加入udp_new(); udp_connect(); udp_bind(); udp_recv();
//UDP服务器发送数据 void udp_demo_senddata(struct udp_pcb *upcb) { struct pbuf *ptr; ptr=pbuf_alloc(PBUF_TRANSPORT,strlen((char*)tcp_demo_sendbuf),PBUF_POOL); //申请内存 if(ptr) { pbuf_take(ptr,(char*)tcp_demo_sendbuf,strlen((char*)tcp_demo_sendbuf)); //将tcp_demo_sendbuf中的数据打包进pbuf结构中 udp_send(upcb,ptr); //udp发送数据 pbuf_free(ptr);//释放内存 } } 7月14日 之前完成的上电后插网线DHCP获取，热插拔实现
if(HAL_GetTick()&gt;time_check_eth) { time_check_eth=HAL_GetTick()+1000;	if(!netif_is_link_up(&amp;gnetif)) { HAL_ETH_ReadPHYRegister(&amp;heth, PHY_BSR, &amp;phyreg); if(phyreg &amp; PHY_LINKED_STATUS) { HAL_ETH_DeInit(&amp;heth); // HAL_ETH_Init(&amp;heth); MX_LWIP_ReInit(); } } else if(DHCP_OK==0&amp;&amp;gnetif.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dd5123ee313d758203622474270ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1d15e968fbabc635fd321439eafa54/" rel="bookmark">
			面 试 题 葵 花 宝 典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面
试
题
葵
花
宝
典
（网络与系统篇）
选择（每题1分）
1.IP路由发生在（）
A：物理层 B：网络层 C：数据链路层 D：传输层
2.为了确定网络层数据包所经过的路由器的数目，应该使用（）命令
A：ping B：stacktest C：arp –a D：tracert
3.下列协议属于应用层协议的是（）
A：ip、tcp、udp B：ftp、smtp和telnet C：arp、smtp、telnet D：icmp、rarp、arp
4.以下命令中哪一个命令是配置Cisco 1900 系列交换机特权级密码。
A：enable passwork cisco level 15 B：enable passwork csico
C：enable secret csico D：enable passwork level 15
5.以下哪个命令可以保存路由器RAM中的配置文件到NVRAM中____。
A：copy running-config tftp B：copy startup-config tftp
C：copy running-config startup-config D：copy startup-config running-config
6.在掉电状态下，哪种类型的存储器不保留其内容？
A：NVRAM B：ROM
C：RAM D：Flash
7.以下那种协议属于网络层协议的_。
A：HTTPS B：ICMP
C：SSL D：SNMP
8.目前网络传输介质中传输安全性最高的是___。
A：光纤 B：同轴电缆
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a1d15e968fbabc635fd321439eafa54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3605ce069923b1e8e453903c7afb49ed/" rel="bookmark">
			ping，telnet，ssh命令的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping主要用于测试到达目的主机的网络是否连接，但是它不能检测某个端口是否开放。
ping 域名可以直接看出这个域名对应的ip
ssh与telnet都是远程登录工具。
ssh对传输加密，安全性高，telnet使用明文传输，较为不安全。所以现在很多公司都用ssh来传输数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed487dcba79fa7553eccf94c05f5e52b/" rel="bookmark">
			在Vmware Workstation 上安装 Centos 6.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程所需软件：Vmware Workstation官网下载链接
本教程所需镜像文件：CentOS-6.5-x86_64-bin-DVD1.iso 下载链接 密码: vkkq 该文件从网络寻找并不保证绝对可靠
下载完成好了 那么我们进入下一步 创建虚拟机
先看一下 Vmware Workstation 长什么样子
好 那我们开始创建虚拟机 首先点击 文件→新建虚拟机 这里我们选择经典（推荐）就可以了 有兴趣的同学可以自己去试试 使用 自定义 创建虚拟机
这里我们不想Vmware Workstation 帮我们完成虚拟机安装 所以 选择稍后安装操作系统
这里我们选择对应的操作系统对应的版本 我想在这里说明一下 在这里选择的操作系统并不一定代表将要安装的操作系统就一定是linux 我还可以安装windows 只不过是个人操作习惯 以及 VW 推荐配置而已
这里输入 虚拟机没名称以及相关位置即可 请将虚拟机安装到拥有空余量达到20G 以上的盘符
这里指定磁盘大小 VM推荐大小为20G 如果所在盘符存储量不足可以缩小到5G 安装最小化的linux
那么到这里 虚拟机就创建完成了 如果想要调整详细参数可以点击 自定义硬件 更改配置
那么我们在这里定义一下其他配置吧 这里我们需要挂载iso镜像文件 以及更改网络类型 其余保持不变
这里选择使用ISO映像文件 点击浏览选择下载iso文件的位置
然后 更改网络适配器 为仅主机模式 对于各模式 下面有简要介绍
然后点击关闭 完成 配置
完成后会有虚拟机的页面 点击开启虚拟机 开启虚拟机
这里由于事先挂载了iso文件 所以启动就会直接从镜像启动 我们选择第一个安装系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed487dcba79fa7553eccf94c05f5e52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252a12d00a6b796b0ce555e2bf2c744f/" rel="bookmark">
			HDU 6277 Higher h-index (脑洞题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击打开链接
Higher h-index Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 298 Accepted Submission(s): 187
Problem Description The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, the paper will get (a⋅x) citations, where a is a known constant.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252a12d00a6b796b0ce555e2bf2c744f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b02cbcac03a71427df3fe74fe304cc9/" rel="bookmark">
			HDU 6284 Longest Increasing Subsequence(LIS&#43;思维)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Longest Increasing Subsequence Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 232 Accepted Submission(s): 57
Problem Description Bobo has a sequence a1,a2,…,an. Let f(x) be the length of longest *strictly* increasing subsequence after replacing all the occurrence of 0 with x. He would like to find ∑ni=1i⋅f(i). Note that the length of longest strictly increasing subsequence of sequence s1,s2,…,sm is the largest k such that there exists 1≤i1&lt;i2&lt;⋯&lt;ik≤m satisfying si1&lt;si2&lt;⋯&lt;sik.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b02cbcac03a71427df3fe74fe304cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a45df7976a722083846802270431c7/" rel="bookmark">
			【OpenCv】 VS C&#43;&#43; 图像处理（一）: 环境配置及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家访问我的github:https://github.com/Iamttp 有问题欢迎在评论留言呀！
OpenCv专栏：https://blog.csdn.net/qq_40515692/article/details/102885061
2020/2/5更新：
VS2019/VS2017 OpenCv配置：
VS对于C++配置外部库有两种方式，另一种写在了后面，这里介绍的是新建配置文件的方式，这种方式好处是一劳永逸，我重装电脑后直接用的之前在VS2017上生成的配置文件配置的VS2019。所以非常方便。
首先是VS的OpenCv配置，外部库目录指定和外部包含文件的指定。
指定建立的工程为空白工程。建立完工程之后，我们选中解决方案栏中的Resource Files目录（即源码目录），然后新建一个C++源码文件。设置源码的文件名，例如：Main，然后创建此源码文件到工程中。在VS中有个叫做“属性管理器”的工具，用于进行VS整体参数的配置，配置一次之后，以后所有新建项目都能应用改配置，不用再一一进行配置操作，使用起来也非常方便。点击工具栏中的：View—&gt;Other Windows—&gt;Property Manger打开属性管理器。我先假设配置的VS运行环境为 Debug | x64 ，VS上面很醒目的地方可以更改。选择给新项目添加属性配置表。（如果配置好后保存好文件，下一次新建项目就可以选择添加已存在的属性配置表了）。 取个和项目相关的名字吧。然后双击刚刚新建的文件。
1）配置包含目录：
在通用属性（Common Properties）—&gt;VC ++目录—&gt;包含目录，然后点击右侧三角标志选中Edit进入编辑：
向其中添加下面三个路径（你自己的OpenCv安装的位置）：
F:\opencv\build\include
F:\opencv\build\include\opencv
F:\opencv\build\include\opencv2
2）配置库文件目录：
完成上面的包含目录配置之后，我们还需要进行库文件的配置：回到属性界面，选择包含目录下面的Library Directories（库文件目录）：
向库文件目录下添加OpenCV的库文件目录：F:\opencv\build\x64\vc14\lib，这个目录根据每个人自己在第一步安装OpenCV中选择的目录进行选定：
3）配置动态链接库：
我们可以查看步骤2）中添加的库文件目录下面.lib文件列表，发现在3.1.0版本的OpenCV中，仅剩下两个库文件，分别是：opencv_world310.lib和opencv_world310d.lib，这里两个库文件的区别就是：opencv_world310.lib是Release模式版本，而opencv_world310d.lib是Debug模式版本：
我们刚刚选的Debug模式版本，跟上述两个步骤相似，在属性界面中打开Linker(链接库)—&gt;Input(输入)—&gt;Additional Dependencies(添加依赖)：
将我们刚刚在OpenCV库文件目录下看到的两个库文件其中一个添加到这里：
上面部分为新建工程时VS的Opencv的配置，配置好了之后可以引入头文件，使用OpenCv了。正常运行：
VS OpenCv配置：
首先是VS的OpenCv配置，外部库目录指定和外部包含文件的指定。
指定建立的工程为空白工程：建立完工程之后，我们选中解决方案栏中的Resource Files目录（即源码目录），然后新建一个C++源码文件：设置源码的文件名，例如：Main，然后创建此源码文件到工程中： 在VS中有个叫做“属性管理器”的工具，用于进行VS整体参数的配置，配置一次之后，以后所有新建项目都能应用改配置，不用再一一进行配置操作，使用起来也非常方便。点击工具栏中的：View—&gt;Other Windows—&gt;Property Manger打开属性管理器：在新出现的属性管理器栏中，展开目录，选中Debug|Win64中的Microsoft.Cpp.x64.user，并右键点击属性（Properties）进入属性界面： 1）配置包含目录：
在通用属性（Common Properties）—&gt;VC ++目录—&gt;包含目录，然后点击右侧三角标志选中Edit进入编辑：
向其中添加下面三个路径（你自己的OpenCv安装的位置）：
E:\OpenCV\opencv\build\include
E:\OpenCV\opencv\build\include\opencv
E:\OpenCV\opencv\build\include\opencv2
2）配置库文件目录：
完成上面的包含目录配置之后，我们还需要进行库文件的配置：回到属性界面，选择包含目录下面的Library Directories（库文件目录）：
向库文件目录下添加OpenCV的库文件目录：E:\OpenCV\opencv\build\x64\vc14\lib，这个目录根据每个人自己在第一步安装OpenCV中选择的目录进行选定：
3）配置动态链接库：
我们可以查看步骤2）中添加的库文件目录下面.lib文件列表，发现在3.1.0版本的OpenCV中，仅剩下两个库文件，分别是：opencv_world310.lib和opencv_world310d.lib，这里两个库文件的区别就是：opencv_world310.lib是Release模式版本，而opencv_world310d.lib是Debug模式版本：
跟上述两个步骤相似，在属性界面中打开Linker(链接库)—&gt;Input(输入)—&gt;Additional Dependencies(添加依赖)：
将我们刚刚在OpenCV库文件目录下看到的两个库文件其中一个添加到这里（根据模式需求Release模式或Debug模式）：
上面部分为新建工程时VS的Opencv的配置，配置好了之后可以引入头文件，使用OpenCv了。
OpenCv图像处理：
（1）.首先讲解OpenCv改变图像大小，这里以调用摄像头举例。
#include&lt;opencv2\core\core.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt; #include&lt;opencv2\opencv.hpp&gt; using namespace cv; int main() { // 从摄像头读入视频 VideoCapture capture(0); while (1) { Mat frame;	//定义一个Mat变量，用于存储每一帧的图像 capture &gt;&gt; frame;	//读取当前帧 resize(frame, frame, Size(360, 240));	//改变图像大小 imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a45df7976a722083846802270431c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86be886b85c6f284399beea8938d7c6/" rel="bookmark">
			fl2440开发板移植tslib-1.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在移植这个tslib时出现了好多问题，因为是新手出现，所以出现的更多的是低级错误
如果你要运行tslib的话，首先你要确定你之前移植的lcd，,触摸屏驱动都是好好的否则的话出了错，那就是比了xxx了。。。。。
下面就进入正题：
1 你得准备好tslib 的源码包， 我选择的是tslib-1.4。tslib-1.4.tar.gz这个源码包是我从同学那要过来的。
2 解压tar -zxvf tslib-1.4.tar.gz 3 cd tslib
4 ./autogen.sh
5 /configure --prefix=（你自己的安装目录） --host=arm-linux ac_cv_func_malloc_0_nonnull=yes CC=/opt/buildroot-2012.08/arm920t/usr/bin/arm-linux-gcc (ps 这个路径不是你解压tslib压缩包的文件件 因为我第一次使用的就是这个文件夹，在后边make &amp;&amp;make install 时就出错了，所以你要确定好你要安装的目录)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908152beafb2194d48fe72e774cdd613/" rel="bookmark">
			图论聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
图论聚类方法最早是由Zahn提出的，又称作最大（小）支撑聚类算法。图论聚类要建立与问题相适应的图，图的节点对应于被分析数据的最小单元，图的边或者是弧对应于最小数据之间的相似性度量。因此，每个最小处理单元之间都会有一个度量的表达，这就确保数据局部特性比较易于处理。图论聚类法是以样本数据的局域链接特征作为聚类的主要信息源，因而其优点是易于处理局部数据的特性。
图论聚类思想
图论分析中，把待分类的对象想x1,x2,x3,x4……看做一个全连接无向图G=[X,E]中的节点，然后给每一条边赋值，计算任意两点之间的距离（例如欧氏距离）定义为边的权值。并生成最小支撑树，设置阈值将对象进行聚类分析。
算法步骤
1. 利用prim算法构造最小支撑树。
2. 给定一个阈值r,在最小支撑树中移除权值大于阈值的边，形成森林。
3. 森林中包含剩下的所有的树。
4. 每棵树视为一个聚类。
Matlab算法实现
clear
clc
%creat sample
x1 = rand(9,1);
y1 = rand(9,1);
yuzhi = 0.05 %阈值
plot(x1,y1,'*');
%距离矩阵
for i=1:1:9
for j =1:1:9
dis(i,j) = (x1(i)-x1(j)).^ 2+ (y1(i) - y1(j)).^ 2 ;
if i == j
dis(i,j)=inf;
end
end
end
A =dis;
%prim最小支撑树
P = zeros(1, 9);
P(1,1) = 1;
V = 1:9;
V_P = V - P;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908152beafb2194d48fe72e774cdd613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4900171f3a3fe27f7a5b8af2a7fc98/" rel="bookmark">
			Filesystem Hierarchy Standard(FHS文件系统结构标准）第一章&amp;第二章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 简介
1.1 目的
这个标准将实现：
- 软件预知已安装文件和目录的位置
- 用户预知已安装文件和目录的位置
我们这样做依靠：
- 为文件系统的每一部分指定引导原则
- 指定所需的最小文件和目录
- 列举存在历史冲突的具体案例
FHS文档将提供给：
- 独立的软件提供者用于编写及分发程序
- 操作系统编写者用于编写系统
- 用户用于理解和维护系统
FHS文档的范围限于：
- 本地文件的位置是一件本地事物，FHS不会试图篡改管理员
- FHS解决了文件放置在多方之间的协调问题，如本地，网站，应用程序，文档等。
1.2 公约
我们建议你在阅读本文档时选择排版后的版本。该版本中文件和目录的名称以恒定宽度字体显示。
文件名可变的部分被显示在”&lt;”和”&gt;”之中，例如&lt;thus&gt;.电子邮件地址也如此表达，但不是斜体。
文件名可选的部分被[]表示，也可能被&lt;&gt;表示。例如，如果一个文件名可以包含或不包含扩展部分，它将被表示为&lt;filename&gt;[&lt;extension&gt;]
目录名和文件名的可变子串可用”*”表示。
标记为“基本原理”的文本部分是解释性的，非规范性的。
第二章 文件系统
本标准假设符合FHS-兼容文件系统的操作系统支持大多数UNIX文件系统的基本安全功能。
应当定义2个独立的区域来区分以下文件：可共享的vs不可共享的，动态的vs静态的，总之，不同特征的文件应该放在不同的目录下。这使得在不同文件系统下储存不同用途特点的文件变得容易。
！注意
可共享的文件将被存储在主机上并被其他用户使用。然而，并不是所有的文件都可被共享，所以每个本地存储器都包含至少一个非共享文件夹。如果系统需要将所有文件存储在外部主机上，可以很方便的在外部主机上创建一个或多个目录。
静态和动态文件应当被隔离，因为静态文件可以被存储在只读介质上，不需要定期备份。
传统的UNIX型文件层次系统将动态和静态文件同时存放在/etc和/usr路径下。为了体现上文的思想，/var目录被建立并用于存放动态文件，/usr路径仅存放只读文件（如果是独立的文件系统）。在技术允许的情况下，动态文件已经从/etc迁移到/var下。
这里是一个FHS—兼容系统的范例。
共享
非共享
静态
/usr
/opt
/etc
/boot
动态
/var/mail
/var/spool/news
/var/run
/var/lock
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dabc4d0e5e76ceb1da8a98663eec14/" rel="bookmark">
			Laravel自带SMTP邮件组件实现发送邮件（QQ、163、企业邮箱都可）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		laravel自带SMTP邮件配置和遇到的坑 laravel自带SwiftMailer库，集成了多种邮件API，可以很方便的实现邮件的发送。在本教程中使用到的是SMTP（Simple Message Transfer Protocol）简单邮件传输协议，通常理解为邮件发送服务器。
以QQ邮箱为例 使用QQ邮箱的话，需要开启POP3和SMTP服务（QQ邮箱登录=》选择设置=》账户=》下拉找到图2）。 使用企业邮箱不用开启SMTP，因为企业邮箱自带，如果配置有问题去查一下是否关闭安全登录（企业邮箱） 开启方式如下： 当开启成功会生成密钥，这个东西会在配置中用： 配置laravel .env文件 MAIL_DRIVER=smtp MAIL_HOST=smtp.qq.com MAIL_PORT=465 MAIL_USERNAME=********@qq.com MAIL_PASSWORD=qq邮箱此处填写上图产生的授权码 MAIL_FROM_NAME=邮箱的名称 MAIL_ENCRYPTION=ssl 配置laravel config/mail.php文件 这文件是laravel自带的文件，如果没有需求，内容可不动
return [ 'driver' =&gt; env('MAIL_DRIVER', 'smtp'), 'host' =&gt; env('MAIL_HOST', 'smtp.mailgun.org'), 'port' =&gt; env('MAIL_PORT', 587), 'from' =&gt; [ 'address' =&gt; env("MAIL_USERNAME", ""), 'name' =&gt; env("MAIL_FROM_NAME") ], 'encryption' =&gt; env('MAIL_ENCRYPTION'), 'username' =&gt; env('MAIL_USERNAME'), 'password' =&gt; env('MAIL_PASSWORD'), 'sendmail' =&gt; '/usr/sbin/sendmail -bs', 'pretend' =&gt; env('MAIL_PRETEND', false), ]; driver：用于配置默认的邮件发送驱动，Laravel支持多种邮件驱动方式，包括smtp、Mailgun、Maildrill、Amazon SES、mail和sendmail，Mailgun和Amazon SES都是收费的Maildrill目前不支持中国区用户，这三个都是第三方邮件服务。mail驱动使用PHP提供的mail函数发送，sendmail驱动通过Sendmail/Postfix（Linux）提供的命令发送邮件，smtp驱动通过支持ESMTP的SMTP发送邮件。就目前状况来看，使用smtp是最明智的选择，mail不安全，sendmail需要安装配置Sendmail/Postfix，其他要么付费要么不能用。host:邮箱所在主机，使用163邮箱，对应值是smtp.163.com，使用QQ邮箱，对应值是smtp.qq.com。使用腾讯企业邮箱，对应值是smtp.exmail.qq.comport:用于配置邮箱发送服务端口号，一般默认值是25，但如果设置SMTP使用SSL加密，该值为465。from:配置项包含address和name，前者表示你自己的邮箱，后者表示你邮件用户名（这里邮箱，是用来发邮件的邮箱）。encryption:表示加密类型，可以设置为null表示不使用任何加密，也可以设置为tls或ssl。username: 表示邮箱账号，比如123456789@qq.com password 表示上述邮箱登录对应登录密码。注意QQ邮箱的话应该开启POP3|SMTP服务时给的授权码。sendmail: 是在设置driver为sendmail时使用，用于指定sendmail命令路径。pretend: 用于配置是否将邮件发送记录到日志中，默认为false则发送邮件不记录日志，如果为true的话只记录日志不发送邮件，这一配置在本地开发中调试时很有用 开始代码之旅 生成控制器 php artisan make::controller MailController 配置路由 Route::any('mail/send','MailController@send'); 在app/Http/Controllers生成了一个MailController控制器，如下所示： &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84dabc4d0e5e76ceb1da8a98663eec14/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/452/">«</a>
	<span class="pagination__item pagination__item--current">453/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/454/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>