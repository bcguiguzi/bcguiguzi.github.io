<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b522698a7772137881e7a00a5985f7/" rel="bookmark">
			&amp;&amp; || 与或 逻辑运算符的短路运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于&amp;&amp;和||的短路运算问题，我们主要关注三个问题：什么是&amp;&amp;和||的短路运算？有什么用？怎么用？ 问题一：什么是&amp;&amp;和||的短路运算？ 1、&amp;&amp;和||属于逻辑运算符。关于&amp;&amp;和||的表达式的运算规则是这样的： 表达式1 || 表达式2，只要任意表达式为true，则整个表达式的运算结果为true。 表达式1 &amp;&amp; 表达式2，只有所有表达式都为true，则整个表达式的运算结果才为true。根据集合的补集的思想，只要任意表达式为false，则整个表达式的运算结果为false。 2、&amp;&amp;和||的短路运算，是指如果在进行前面的表达式的运算过程，通过判断已经明确的知道整个表达式的结果，那么就不会进行后面表达式的运算判断。例如： 表达式1 || 表达式2 || 表达式3...|| 表达式n，如果表达式1的运算结果为true，则整个表达式的结果为true，同时不会再对后面的表达式2、表达式3到表达式n进行运算判断。如果表达式1的运算结果为false，则根据表达式2的运算结果继续判断。 表达式1 &amp;&amp; 表达式2 &amp;&amp; 表达式3...&amp;&amp; 表达式n，如果表达式1的运算结果为false，则整个表达式的结果为false，同时不会再对后面的表达式2、表达式3到表达式n进行运算判断。如果表达式1的运算结果为true，则根据表达式2的运算结果继续判断。 问题二：&amp;&amp;和||的短路运算有什么用？ 1、由于&amp;&amp;和||的表达式存在短路运算现象，在短路之后不会对后面的表达式进行运算，所以含有&amp;&amp;和||的表达式最好不要进行变量的赋值和运算操作，可以先计算好每个表达式的结果，直接拿结果进行&amp;&amp;和||的运算。 在代码编写的时候就要注意这一点，以防由于&amp;&amp;和||的短路运算导致写出来的代码运算结果与预期的不同。 2、把能快速确定整个表达式结果true或false的表达式放在前面，这样由于短路运算后面的表达式可能不会被运算到，节省处理器的运算时间。 问题三：怎么用？ 通过举例子，&amp;&amp;和||的短路运算的使用。 例子1： #include &lt;stdio.h&gt; int main() { int a = 1, b = 2, c = -3, d = -1; printf("before expression: a= %d	b= %d	c= %d	d= %d\r\n", a, b, c, d); d = (a+1&gt;0) || (++b&gt;0) || (c-4)&gt;0; printf("after expression: a= %d	b= %d	c= %d	d= %d\r\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b522698a7772137881e7a00a5985f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a73ca20534cd25bf549db98ea45550/" rel="bookmark">
			springboot启动失败的问题（&#39;hibernate.dialect&#39; not set）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot版本是1.3.0.M1，连接的mysql版本为8，用spring-boot-starter-data-jpa操做数据库，启动springboot报错如下：
2018-02-21 11:25:47.637 WARN 12992 --- [ main] ationConfigEmbeddedWebApplicationContext : Exception encountered during context initialization - cancelling refresh attempt org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1578) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1011) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:802) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a73ca20534cd25bf549db98ea45550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e053cd6f81d240eb8ed22f0d59e9b30d/" rel="bookmark">
			取模运算的性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址点击打开链接 定义 给定一个正整数p，任意一个整数n，一定存在等式 ： n = kp + r ； 其中 k、r 是整数，且 0 ≤ r &lt; p，则称 k 为 n 除以 p 的商，r 为 n 除以 p 的余数。 对于正整数 p 和整数 a,b，定义如下运算： 取模运算：a % p（或a mod p），表示a除以p的余数。 模p加法： ，其结果是a+b算术和除以p的余数。 模p减法： ，其结果是a-b算术差除以p的余数。 模p乘法： ，其结果是 a * b算术乘法除以p的余数。 说明： 1. 同余式：正整数a，b对p取模，它们的余数相同，记做 或者a ≡ b (mod p)。 2. n % p 得到结果的正负由被除数n决定,与p无关。例如：7%4 = 3， -7%4 = -3， 7%-4 = 3， -7%-4 = -3 基本性质 若p|(a-b)，则a≡b (% p)。例如 11 ≡ 4 (% 7)， 18 ≡ 4(% 7) (a % p)=(b % p)意味a≡b (% p) 对称性：a≡b (% p)等价于b≡a (% p) 传递性：若a≡b (% p)且b≡c (% p) ，则a≡c (% p) 运算规则 模运算与基本四则运算有些相似，但是除法例外。其规则如下： (a + b) % p = (a % p + b % p) % p （1） (a - b) % p = (a % p - b % p) % p （2） (a * b) % p = (a % p * b % p) % p （3） a ^ b % p = ((a % p)^b) % p （4） 结合律： ((a+b) % p + c) % p = (a + (b+c) % p) % p （5） ((a*b) % p * c)% p = (a * (b*c) % p) % p （6） 交换律： (a + b) % p = (b+a) % p （7） (a * b) % p = (b * a) % p （8） 分配律： ((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p （9） 重要定理 若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)；（10） 若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)；（11） 若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)， (a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)； （12） 快速乘法取模 当我们计算a*b%mod的时候，往往较大的数计算a＊b会超出数据的范围，这个时候使用快速乘法方法能解决上述问题． 快速乘法的原理是把数分解为多项式相加。举个例子： 30*14 = 30*(1110)2 = 30*(2^3)1+30(2^2)1+30(2^1)1+30(2^0)*0=240+120+60=420 typedef long long LL; LL q_mul(LL a, LL b, LL p){//快速乘法取模 LL ans = 0; while (b){ if(b&amp;1LL) ans=(ans+a)%p; //or ans=(ans+(b%2*a)%p)%p; a = (a +a) % p; b &gt;&gt;= 1; } return ans; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d7ccf71e03fa687d9db9175f0cf0c4/" rel="bookmark">
			函数式编程思维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数式编程思维
1 直观的角度来说，函数式风格的代码可以写得很精简，大大减少了代码的行数,并且思维方式不再是命令式,而是偏向于自然语言.
2 其次，函数式的代码是“对映射的描述”,函数一词的意思不再是我们程序中的函数,方法,而是数学中的函数映射.
函数式编程特性
1 数据不可变性（immutable data）多有的变量只可以赋值一次，变量不可变，如果想改变变量就创建一个新的变量。
2 函数是第一公民（first class method）函数可以像普通变量一样去使用。函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。
3 引用透明(referential transparency) 指的是函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数，任何时候只要参数相同，调用函数所得到的返回值总是相同的。天然适应并发编程，因为调用函数的结果具有一致性，所以根本不需要加锁，也就不存在死锁的问题。 4 尾递归化（tail call optimization）因为函数调用要压栈保存现场，递归层次过深的话，压栈过多会产生性能问题。所以引入尾递归优化，每次递归时都会重用栈，提升性能。
函数式编程技术（方法论）
1 映射化简（map &amp; reduce）函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起过程式的语言来说，在代码上要更容易阅读。传统过程式的语言需要使用for/while循环，然后在各种变量中把数据倒过来倒过去的
2 管道 （pipeline）把一组函数放到一个数组或是列表中，然后把数据传给这个列表，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。他的设哲学就是让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。 3 递归 （recursing）递归最大的好处就简化代码，他可以把一个复杂的问题用很简单的代码描述出来。递归的精髓是描述问题，而这正是函数式编程的精髓。 4 柯里化 （currying）把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数。 5 高阶函数（higher order function）函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e7dfe939ae736fafa620ce1ee576e4/" rel="bookmark">
			神奇“&amp;”符，url传值踩过的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务需求，需要一个生成二维码的功能，生成二维码的功能用Google的jar包成功解决，并且对外提供了一个生成二维码的web接口，参数为需要跳转的url链接。后续发现一个问题，就是web端传递的url进来后，有时候生成二维码后扫描得到的链接正常，有时候就不正常，url上带的参数部分丢失了。比如qcUrl =baidu.com、qcUrl=baidu.com?param1=abc，这样的链接生成的二维码就没问题，扫描后得到的链接跟qcUrl 一致；但是qcUrl = baidu.com?param1=abc&amp;param2=bcd这样的参数生成的链接就有问题，扫描后得到的链接变成了baidu.com?param1=abc，后面的参数丢失了。
当时一直觉得是二维码生成有问题， 后来定位才发现问题的原因根本不是二维码生成的问题，是qcUrl = baidu.com?param1=abc&amp;param2=bcd这样的参数传递到后端就变成了baidu.com?param1=abc，参数已经丢失了。百度了下，原因是，当通过url传参时，遇到“&amp;”会自动截断，把参数当成独立的参数往后端传递，比如你想传递一个参数qcUrl值为“baidu.com?param1=abc&amp;param2=bcd”到服务器端，这时候，url传参会将参数解析成qcUrl=baidu.com?param1=abc和param2=bcd这两个参数传递到后端。
解决方案：
1.对url中的特殊字符进行转义；
2.将整个url参数进行encode处理；
3.将url在web端进行base64转码，传递到服务器端后，进行解码。
1.url中常用的特殊符号对应的转义符号
特殊符号
说明
转义符号
+
URL 中+号表示空格
%2B
空格
URL中的空格可以用+号或者编码
%20
/
分隔目录和子目录
%2F
?
分隔实际的URL和参数
%3F
%
指定特殊字符
%25
#
表示书签
%23
&amp;
URL 中指定的参数间的分隔符
%26
=
URL 中指定参数的值
%3D
2.代码示例： public static void main(String[] args) throws UnsupportedEncodingException { String s = "https://m.biyao.com/activity/summitMeetingBindTeam/joinTeam?it=h5-ddzdlx&amp;inviteCode=AAAA&amp;c=adasdfa"; String encodeS = URLEncoder.encode(s,"UTF-8"); System.out.println(encodeS); } 输出为：
3.代码示例：
public static void main(String[] args) throws UnsupportedEncodingException { String s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e7dfe939ae736fafa620ce1ee576e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a867af4d7dfcaba4f9a1798f9771c1/" rel="bookmark">
			大数据分析方法论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据分析案列 2017年09月01日 20:04:08 480 1、体育赛事预测
世界杯期间，谷歌、百度、微软和高盛等公司都推出了比赛结果预测平台。百度预测结果最为亮眼，预测全程64场比赛，准确率为67%，进入淘汰赛后准确率为94%。现在互联网公司取代章鱼保罗试水赛事预测也意味着未来的体育赛事会被大数据预测所掌控。
“在百度对世界杯的预测中，我们一共考虑了团队实力、主场优势、最近表现、世界杯整体表现和博彩公司的赔率等五个因素，这些数据的来源基本都是互联网，随后我们再利用一个由搜索专家设计的机器学习模型来对这些数据进行汇总和分析，进而做出预测结果。”—百度北京大数据实验室的负责人张桐
2、股票市场预测
去年英国华威商学院和美国波士顿大学物理系的研究发现，用户通过谷歌搜索的金融关键词或许可以金融市场的走向，相应的投资战略收益高达326%。此前则有专家尝试通过Twitter博文情绪来预测股市波动。
理论上来讲股市预测更加适合美国。中国股票市场无法做到双向盈利，只有股票涨才能盈利，这会吸引一些游资利用信息不对称等情况人为改变股票市场规律，因此中国股市没有相对稳定的规律则很难被预测，且一些对结果产生决定性影响的变量数据根本无法被监控。
目前，美国已经有许多对冲基金采用大数据技术进行投资，并且收获甚丰。中国的中证广发百度百发100指数基金（下称百发100），上线四个多月以来已上涨68%。
和传统量化投资类似，大数据投资也是依靠模型，但模型里的数据变量几何倍地增加了，在原有的金融结构化数据基础上，增加了社交言论、地理信息、卫星监测等非结构化数据，并且将这些非结构化数据进行量化，从而让模型可以吸收。
由于大数据模型对成本要求极高，业内人士认为，大数据将成为共享平台化的服务，数据和技术相当于食材和锅，基金经理和分析师可以通过平台制作自己的策略。
http://v.youku.com/v_show/id_XMzU0ODIxNjg0.html
3、市场物价预测
CPI表征已经发生的物价浮动情况，但统计局数据并不权威。但大数据则可能帮助人们了解未来物价走向，提前预知通货膨胀或经济危机。最典型的案例莫过于马云通过阿里B2B大数据提前知晓亚洲金融危机，当然这是阿里数据团队的功劳。
4、用户行为预测
基于用户搜索行为、浏览行为、评论历史和个人资料等数据，互联网业务可以洞察消费者的整体需求，进而进行针对性的产品生产、改进和营销。《纸牌屋》选择演员和剧情、百度基于用户喜好进行精准广告营销、阿里根据天猫用户特征包下生产线定制产品、亚马逊预测用户点击行为提前发货均是受益于互联网用户行为预测。
购买前的行为信息，可以深度地反映出潜在客户的购买心理和购买意向：例如，客户 A 连续浏览了 5 款电视机，其中 4 款来自国内品牌 S，1 款来自国外品牌 T；4 款为 LED 技术，1 款为 LCD 技术；5 款的价格分别为 4599 元、5199 元、5499 元、5999 元、7999 元；这些行为某种程度上反映了客户 A 对品牌认可度及倾向性，如偏向国产品牌、中等价位的 LED 电视。而客户 B 连续浏览了 6 款电视机，其中 2 款是国外品牌 T，2 款是另一国外品牌 V，2 款是国产品牌 S；4 款为 LED 技术，2 款为 LCD 技术；6 款的价格分别为 5999 元、7999 元、8300 元、9200 元、9999 元、11050 元；类似地，这些行为某种程度上反映了客户 B 对品牌认可度及倾向性，如偏向进口品牌、高价位的 LED 电视等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a867af4d7dfcaba4f9a1798f9771c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d13168456359a19669d112e591b04a/" rel="bookmark">
			vue.js项目 el-input 组件 监听回车键实现搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue.js项目 el-input 组件 监听回车键实现搜索 基于element-ui 组件 开发的vue.js项目， 实现回车键发起搜索，和原生的input 标签使用方法不一样：
el-input 监听键盘按下状态 得用@keyup.enter.native,如果是非el-input 组件，可以直接用@keyup.enter &lt;el-input placeholder="搜索" icon="search" v-model="input" :on-icon-click="pchandleIconClick" @keyup.enter.native="searchEnterFun"&gt; &lt;/el-input&gt; &lt;input placeholder="搜索" type="text" @keyup.enter="searchEnterFun"&gt; 在methods方法集里，写上监听的方法，当获取的keyCode 为13时，表示按下了回车键，如果需要监听空格或者其他键，换成别的键值 searchEnterFun:function(e){ var keyCode = window.event? e.keyCode:e.which; // console.log('回车搜索',keyCode,e); if(keyCode == 13 &amp;&amp; this.input){ this.$router.push({path:'/Share?keywords='+this.input}); } } which 和 keyCode 属性提供了解决浏览器的兼容性的方法。
keyCode属性返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码
注意： 在 Firefox 中，keyCode 属性在 onkeypress 事件中是无效的 (返回 0)。浏览器兼容问题，可以一起使用 which 和 keyCode 属性来解决： var keyCode = window.event ? e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d13168456359a19669d112e591b04a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1145caf7c6f2c91afd92d60ff05de59d/" rel="bookmark">
			深入了解以太坊虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由币乎社区（bihu.com）内容支持计划赞助。
译者说，深入了解以太坊虚拟机是一个系列的文章，一共5篇！ 本文是第1篇，主要介绍的是以太坊虚拟机汇编代码基础。后续的4篇译文链接在本文的结尾处。
Solidity提供了很多高级语言的抽象概念，但是这些特性让人很难明白在运行程序的时候到底发生了什么。我阅读了Solidity的文档，但依旧存在着几个基本的问题没有弄明白。
string, bytes32, byte[], bytes之间的区别是什么？
该在什么地方使用哪个类型？ 将 string 转换成bytes时会怎么样？可以转换成byte[]吗？ 它们的存储成本是多少？ EVM是如何存储映射( mappings)的？
为什么不能删除一个映射？ 可以有映射的映射吗？(可以，但是怎样映射？) 为什么存在存储映射，但是却没有内存映射？ 编译的合约在EVM看来是什么样子的？
合约是如何创建的？ 到底什么是构造器？ 什么是 fallback 函数？ 我觉得学习在以太坊虚拟机(EVM)上运行的类似Solidity 高级语言是一种很好的投资，有几个原因：
Solidity不是最后一种语言。更好的EVM语言正在到来。（拜托？） EVM是一个数据库引擎。要理解智能合约是如何以任意EVM语言来工作的，就必须要明白数据是如何被组织的，被存储的，以及如何被操作的。 知道如何成为贡献者。以太坊的工具链还处于早期，理解EVM可以帮助你实现一个超棒的工具给自己和其他人使用。 智力的挑战。EVM可以让你有个很好的理由在密码学、数据结构、编程语言设计的交集之间进行翱翔。 在这个系列的文章中，我会拆开一个简单的Solidity合约，来让大家明白它是如何以EVM字节码(bytecode)来运行的。
我希望能够学习以及会书写的文章大纲：
EVM字节码的基础认识 不同类型(映射，数组)是如何表示的 当一个新合约创建之后会发生什么 当一个方法被调用时会发生什么 ABI如何桥接不同的EVM语言 我的最终目标是整体的理解一个编译的Solidity合约。让我们从阅读一些基本的EVM字节码开始。
EVM指令集将是一个比较有帮助的参考。
一个简单的合约 我们的第一个合约有一个构造器和一个状态变量：
// c1.sol pragma solidity ^0.4.11; contract C { uint256 a; function C() { a = 1; } } 用solc来编译此合约：
$ solc --bin --asm c1.sol ======= c1.sol:C ======= EVM assembly: /* "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1145caf7c6f2c91afd92d60ff05de59d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6215e9eac9a6342b7ab25960f4d40e/" rel="bookmark">
			列表页点击商品跳转到对应商品的详情页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步： 新建dome1.html列表页 通过jq的each遍历， res.books 是要遍历的数据， each处理json数据，这个each就有更厉害了，能循环每一个属性 var obj = { one:1, two:2, three:3}; each(obj, function(key, val) { alert(key); alert(val); }); 这里alert(key)将输出one two three alert(val)将输出one，1，two，2，three,3 跳转通过拼接a标签的href bookId通过具体页面来写，给bookId赋值，就是json数据里面的商品id值，之后再到商品详情页接收id "&lt;a href='dome2.html?booksId="+val.id+"'&gt; &lt;div class="warp"&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script&gt; $(function () { $.ajax({ type:"get", url:"dome1.json", dataType:"json", success:function (res) { console.log(res.books); var str = ""; $.each(res.books, function(idx,val) { str += "&lt;div class=\"content\"&gt;" + "&lt;a href='dome2.html?booksId="+val.id+"'&gt;&lt;img src='"+val.imgUrl+"'/&gt;&lt;/a&gt;" + "&lt;p class=\"p\"&gt;"+val.price+"&lt;/p&gt;" + "&lt;/div&gt;" }); $('.warp').append(str); } }) }) &lt;/script&gt; 第二步： 新建dome2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6215e9eac9a6342b7ab25960f4d40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050222cc28bd092d7e3cf2629179637e/" rel="bookmark">
			webstorm 激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2017-06-15更新 之前都是使用2017.2.27的方法，版本是2017.1.1，还没提示过期，但是根据评论说这个链接已经失效了，评论也给出了个新地址：http://idea.iteblog.com/key.php 感谢 @qq_35381272 友情提供2017.2.27更新 选择“license server” 输入：http://idea.imsxm.com/2016.2.2 版本的破解方式： 安装以后，打开软件会弹出一个对话框；选择“license server” 输入：http://114.215.133.70:410172016.2.3 版本的破解方式： 目前最新的就是2.3版本，在打开的License Activation窗口中选择“activation code”，在输入框输入下面的注册码 43B4A73YYJ-eyJsaWNlbnNlSWQiOiI0M0I0QTczWVlKIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiY 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6604e08b1d4a1ab9ca51fbfee7738dc1/" rel="bookmark">
			ng-click得到当前元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/amohan/article/details/39249369
场景：给多个按钮绑定事件，并得到点击对象。 在最上面的元素加上点击事件，然后利用$event.target得到点击对象 看代码
&lt;ul class="result-choose" id="ResultChoose" ng-click="changeStatus($event);"&gt; &lt;li id="Success"&gt; &lt;!--&lt;span ng-class="{true: 'checked'}[isActive]"&gt;拨打成功&lt;/span&gt;--&gt; &lt;span ng-class='{checked:tar=="拨打成功"}'&gt;拨打成功&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="占线"}'&gt;占线&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="拒接"}'&gt;拒接&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="号码废弃"}'&gt;号码废弃&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="无人接听"}'&gt;无人接听&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="停机"}'&gt;停机&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="关机"}'&gt;关机&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span ng-class='{checked:tar=="号码错误"}'&gt;号码错误&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; $scope.changeStatus=function($event){ var test=$event.target.childNodes[0].nodeValue; $scope.tar=test; if(test!="拨打成功"){ $scope.isActive=true; }else{ $scope.isActive=false; } } &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="lib/jquery/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="lib/angular/angular.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app&gt; &lt;div ng-controller="TestCtrl"&gt; &lt;a href data="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6604e08b1d4a1ab9ca51fbfee7738dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5288dbf794665e181b1fefd0c0d956b1/" rel="bookmark">
			phpBOM头(字符&amp;#65279;)出现的原因以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在项目中发现，客户端在使用ajax得到返回值时，无法匹配字符串。总是报错，打开页面接口发现，页面的头部出现了&amp;#65279;的字符(BOM头)，找到问题了，那么直接用代码清除掉即可。 php隐形字符&amp;#65279解释如下： UTF-8 编码的文件可以分为无 BOM 和 BOM 两种格式。 何谓BOM？ "EF BB BF" 这三个字节就叫BOM，全称是"Byte Order Mard"。在utf8文件中常用BOM来表明这个文件是UTF-8文件，而BOM的本意是在utf16中用。 utf-8文件在php中输出的时候bom是会被输出的，所以要在php中使用utf-8，必须要是使用不带bom头的utf-8文件。 常用的文本编辑软件对utf-8文件保存的支持方式并不一样，使用的时候要特别留意。 解决的方法： 1、接notopad++ 保存为无dom格式(格式-&gt;转为UTF-8 无dom格式)，适合文件少的情况。 2、文件比较多，又想偷懒下，使用下列方法来实现(亲测可用)。将一下代码保存为a.php文件放到根目录下，执行一下，即可自动完成转换。 代码如下：
&lt;?php // 设定你要清除BOM的根目录（会自动扫描所有子目录和文件） $HOME = dirname(__FILE__); // 如果是Windows系统，修改为：$WIN = 1; $WIN = 0; ?&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;UTF8 BOM 清除器&lt;/title&gt; &lt;style&gt; body { font-size: 10px; font-family: Arial, Helvetica, sans-serif; background: #FFF; color: #000; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5288dbf794665e181b1fefd0c0d956b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3628db5bce39f19d99fb4e19f3d09f/" rel="bookmark">
			android JSONObject的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，简单讲讲android里如何使用 ﻿﻿ JSONObject。
昨天，自己使用JSONObject构造json数据时，居然发现构造6个之后，json数据就没有构造进json的括号里，当时是用Debug进行调试，所以百思不得其解。在网上查了资料，也没有明白，后来发现用log打印的json数据是正确的，是debug显示的问题。所以这里还是记录一下JSONObject的使用，避免以后出现这样的问题。
Android之JSON全面解析与使用 什么是JSON JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）JSON 是轻量级的文本数据交换格式JSON 独立于语言 （单纯的数据格式，不受语言的约束）JSON 具有自我描述性，更易理解 对于JSON的定义以及数据格式，没有什么太多的难点，这里为官网对JSON的定义。从官网描述中可以看出，JSON本身是JavaScript中对象的描述格式，后来得以推广并逐渐取代xml。
JSON和XML的比较 相比 XML 的不同之处
没有结束标签（类似于键值对的形式）更短（没有结束标签，当然短了）读写的速度更快能够使用内建的 JavaScript eval() 方法进行解析使用数组不使用保留字 原生JSON解析 Android原生的解析实际上使用的JSON的一个官方jar包。对于JSON,不需要页面展示，所以使用intellij idea进行演示。
在使用之前我们需要下载org.json的jar包。对于Android 开发环境不需要下载此jar包。因为Android SDK 中已经默认包含了该jar包。
json jar 下载地址
下载完之后导入即可。
JSONObject对象解析 下面看一下数据
{ "user":{ "name":"alex", "age":"18", "isMan":true } } 有一个user字段，其中包含了该user的一些基本属性。那么如何解析呢？
在解析时，有一个很关键的地方：如果是{}包含，则为JSONObject对象，如果为[]则为JSONArray对象。
看到上面的例子，我们看到整个数据为JSONObject,其内部包含了一个user字段，该字段的值也是一个JSONObject对象。
public class OrgJSONTest { public static String json = "{\"user\":{\"name\":\"alex\",\"age\":\"18\",\"isMan\":true}}"; public static void main(String[] args){ JSONObject obj = new JSONObject(json);//最外层的JSONObject对象 JSONObject user = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3628db5bce39f19d99fb4e19f3d09f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1786eefb03d88c5e8813efd97c3ea439/" rel="bookmark">
			win7下VS2015编译tensorflow源码教程（在线和离线）及调用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间一直用python代码import tensorflow和keras的库，来搭建CNN框架进行图像的训练和预测，现在想用tensorflow的c++版来改写实现。故想自己编译一份tensroflow的lib和dll文件，创建工程调用其来实现相同的功能。本博客主要讲编译过程和一个简单的sample例子。
一.编译详细过程：
1.下载tensorflow源码，链接：点击打开链接，选择1.3.0版本。
2.准备工具：
一台配置了英伟达显卡的x64位win7系统电脑
（1）CMake 3.10.1点击打开链接
（2）swigwin-3.0.12点击打开链接
（3） VS2015
（4） cuda8.0+cudnnv5.1(如何安装配置验证参考我的之前博文“win7下cuda8.0安装跑gpu版tensorflow”
（5） 无网状态下需要下载部分文件。下面会介绍。
3.Cmake-gui编译tensorflow
（1）打开cmake-gui, 在tensorflow所在本机位置的tensorflow-1.3.0\tensorflow-1.3.0\tensorflow\contrib\cmake
路径下新建build文件夹2
（2）Browse Source和Browse Build按照此下选择(cmake文件夹下如果没有build文件夹，自己新建一个）
（3）点击cmake-gui左下角的Config按钮，会跳出来对话框，按照下图选择2015 Win64，然后点击Finish按钮
（4）会出现如下图的报错信息
（5）cmake-gui需要做如下配置，SWIG_EXECUTABLE路径设置到上面swigwin-3.0.12中swig.exe所在的位置
（6）再次点击configure按钮，出现下图，表示config成功
（7）展开tensorflow，按如下打勾的勾选上，然后点Generate
（8）出现Generating done表明生成成功
（9）然后点击Open Project按钮，打开工程
（10）点击菜单栏里的工具（T），选择选项按钮，在项目和解决方案下选择生成并运行项
做如下配置：设置最大并行项目生成数为1
（11）生成ALL_BUILD项目。
（12）中间不会很顺利，会报一些错误，如下所示：
分析无非这两大报错原因：a.由于网速慢或者资源原因，一些编译过程中需要下载的库download不下来。
b. re2工程编译不过去
（13）re2工程编译失败处理（"re2/re2.h": No such file or directory）
转到到你的tensorflow文件里tensorflow-1.3.0\tensorflow\contrib\cmake\build\re2\src\re2目录下。
删除该目录下的非文件夹的文件，除了CmakeList.txt保留。
打开cmake-gui,如下图所示配置,单独重新配置re2工程。
记得Ungrouped Entries下的RE2_BUILD_TESTING取消勾选
BUILD下的BUILD_TESTING取消勾选
之后点击Config、Generate按钮重新生成Re2工程。不需要点open project按钮
重新仅生成Re2工程，成功。
（14）解决由于网速或者离线模式下相关文件不能下载而导致的失败问题
比如报downloading "htpps://storage.gooleapis.com/libpng-public-archive/libpng-1.2.53.tar.gz' failed
可以在有网的环境下事先下载好这份文件，拷贝到
tensorflow-1.3.0\tensorflow\contrib\cmake\build\downloads文件夹下。
然后转到tensorflow-1.3.0\tensorflow\contrib\cmake\build\png\src\png-stamp文件夹下，
把download-png.cmake里的东西清空，如下图所示：
对png工程重新仅生成该工程，编译成功。
解决该问题的方法也可以给离线模式编译带来参考，可以事先先准备好这些编译过程中需要下载的文件，所有文件均在
tensorflow-1.3.0\tensorflow\contrib\cmake\build\downloads文件夹里
下图是我编译成功该版tensorflow需要依赖的库
（15）重新生成ALL Build一般就能成功了（我按照此逻辑装过三次），如果不行可以留言！
生成成功后会在tensorflow-1.3.0\tensorflow\contrib\cmake\build\Release文件夹下看到tensorlow.lib和dll文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1786eefb03d88c5e8813efd97c3ea439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d618f078d6ba8b7b2a4927ae06623b/" rel="bookmark">
			移动web开发适配秘籍之rem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动web开发中我们一定会遇到要处理适配的问题，这里选择rem这一方案。
待续...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c71176c7bbaae320c832d80ee5bcb2/" rel="bookmark">
			H5之元素与标签结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要梳理一下新增和删去的标签及相关属性，以及深入了解h5的全局属性。
待续......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab01415d051988317fa400bc28bf3a5/" rel="bookmark">
			Numpy数据类型对象（dtype）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用方法 #记住引入numpy时要是用别名np，则所有的numpy字样都要替换 #查询数值类型 &gt;&gt;&gt;type(float) dtype('float64') # 查询字符代码 &gt;&gt;&gt; dtype('f') dtype('float32') &gt;&gt;&gt; dtype('d') dtype('float64') # 查询双字符代码 &gt;&gt;&gt; dtype('f8') dtype('float64') # 获取所有字符代码 &gt;&gt;&gt; sctypeDict.keys() [0, … 'i2', 'int0'] # char 属性用来获取字符代码 &gt;&gt;&gt; t = dtype('Float64') &gt;&gt;&gt; t.char 'd' # type 属性用来获取类型 &gt;&gt;&gt; t.type &lt;type 'numpy.float64'&gt; # str 属性获取完整字符串表示 # 第一个字符是字节序，&lt; 表示小端，&gt; 表示大端，| 表示平台的字节序 &gt;&gt;&gt; t.str '&lt;f8' # 获取大小 &gt;&gt;&gt; t.itemsize 8 # 许多函数拥有 dtype 参数 # 传入数值类型、字符代码和 dtype 都可以 &gt;&gt;&gt; arange(7, dtype=uint16) array([0, 1, 2, 3, 4, 5, 6], dtype=uint16) 类型参数及缩写 类型字符代码bool?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab01415d051988317fa400bc28bf3a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01fc3720fb5eeb9b0dcf6b10429b8b6/" rel="bookmark">
			word2013多级列表自动编号与多样式配合排版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作为学生党，经常需要写一些课程报告或者项目报告之类的文档。但是我发现很多人都是直接在写标题的时候把编号也手动写上去，不知道怎么在word里面让标题自动编号。手动写编号看起来也没什么问题，但是当你需要修改文档的时候，添加某一节或者某一章的时候，那么后续的所有章节的编号都要重新手动改一次，如果文档标题比较多，改起来就十分麻烦了。
而word本身就自带了强大的排版功能，所以今天就来讲一下如何设置多级标题，并给这些标题自动编号。
第一步：在【样式】这一栏中，将样式改为自己希望的那样，或者也可以自己新建一个样式。 如上图，点击【修改】选项，会弹出一个样式修改框。 在这个样式修改框，你可以修改标题的名称，后续段落样式(后续段落样式的意思就是当你写完标题后，你按下回车键后，下一行的字体默认就是这个选项填的样式，像上图是正文1)，字体的各种相应的设置都有。
修改完之后，选择【确定】，然后在【开始】菜单栏点击【定义新的多级列表】。 点击【定义新的多级列表】后，就会弹出一个多级列表定义的框。 注意，如果框不是这样的话，应该要点击左下角的【更多】就会扩展出图片右端的那部分。
左上角部分就是标题的级别，首先先选择要修改的标题的级别，然后在右边的【将级别链接到样式】这一项选择刚刚已经修改好的样式。
图片下面部分是标题的格式，可以看到默认是阿拉伯数字，我可以在数字的前后添加中文，这样就可以有第1章，第2章这样的标题了，而不用自己手动写。
最后点击【确定】就好了。
最终的结果就是： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87b4c8c1612456281b5ef28ad900f23/" rel="bookmark">
			定时启动多个cmd的python程序，并且批处理关闭各个程序，一键启动conda虚拟环境和运行多个python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我想在服务器上定时启动多个cmd程序，并且定时关闭。一键启动conda虚拟环境和运行多个python。使用win2008的服务器系统就是简单了。思路：
1、系统计划任务。
2、bat批处理一键启动conda的activate激活虚拟环境，并且启动python。重点是这个cmd的标题，用来区别不同运行的cmd的python
start "title" cmd /k "activate vnpy_beta&amp;&amp;title okex&amp;&amp;python run_okex.py" 关闭命令 taskkill /f /fi "windowtitle eq okex*" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb01ee120909be0a8ce5420aafde4cf/" rel="bookmark">
			计算机显卡知识普及
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显卡知识普及 一、什么是显卡？ 显示接口卡（Video card，Graphics card）、显示器配置卡简称为显卡，是个人电脑基本组成部分之一。
用途是将计算机系统所需要的显示信息进行转换驱动，并向显示器提供信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件。
民用显卡芯片供应商主要包括AMD（原ATI）和NVIDIA(英伟达)两家。
二、显卡分类 显卡按照分类存在位置分为集成显卡和独立显卡两大类。
1.集成显卡 显卡目前有两种存在形式。
一种是指主板芯片组集成了显卡芯片，使用这种芯片组的主板就可以不需要独显就实现显示功能，满足一般的应用需求。集成显卡的主板一般不带有显存，使用系统的一部分内存作为显存，一般可以在BIOS里面调整，一般在BIOS里面调节上线是256M。
目前这种主板集成显卡已经被淘汰。
一种是指处理器内部集成了显卡芯片，即“核显”。一般分为AMD现在的“APU”和英特尔的“核芯显卡”。显存同样从内存分享而来，由于核显性能的飞跃，现在的核显对内存性能的依赖很严重，还会较大程度的影响CPU的性能。
2.独立显卡 独立显卡，简称“独显”，是指一块独立于主板的板卡存在，需要插在主板的相应接口上的显卡。独立显卡具备单独的显存，不占用系统的内存（但当独立显存不够用时可以共享内存作为显存），而且技术上领先于集成显卡，能够提供更好的显示效果和运行性能。 独显由于拥有独立的一套运行环境，使得其核心运算有很大的发挥控件，因而性能相对于集成显卡来说有较大的飞跃。不过对于低端入门独显来说，并非一定比集显的性能要好。这种情况出现的原因是因为核显性能的飞跃。不过，较高性能的核显对应的CPU型号也属于高端，价格上也是比较昂贵的。 (1)显示核心(GPU) GPU全程是Graphic Processing Unit，中文翻译为“图形处理器”。NVIDIA公司在发布GeForce 256图形处理芯片时首先提出的概念。GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作，尤其是在3D图形处理时。如果说CPU是整个机器的心脏，那么GPU就是整个显卡的心脏，那么GPU就是整个显卡的心脏。显卡负责的图形处理全部依靠这个颗小小的GPU。一般来说，衡量GPU工作能力的参数有两个：流处理器数量和核心工作频率。其他特性：光栅单元(ROPS),L1缓存，核心面积，制造工艺。 GPU有不同的架构，其包含的参数直接决定了显卡的性能的高低。主要参数是流处理器和显存控制器，与GPU代号有关。 (2)显卡PCB 印刷线路板(PCB, Printed Circuit Board)主要功能是提供电子元器件之间的相互连接。如果一张显卡连最基本的电路都设计不好的话，即使有再好的电容、显存颗粒等等可能也无法稳定的运行，更不要说超频。所以PCB对显卡来说是非常重要的。一般来说，PCB的层数越多，长度越长，容纳的电气元件越多，电路越复杂，用料越多，显卡性能越好。 PCB上主要查看的是用料的高低。可以通过粗略查看电子元件的密度，显卡供电相数来判断同型号显卡的好快。
(3)显存 显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将被提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。显存的参数有：显存类型、容量、位宽、频率(延迟)
从某种意义上讲，显存类型是当下选择显卡需要加大关注的地方。目前最好的显存类型是GDDR5，等效频率最高，其次是GDDR3，最后是目前最常见的DDR3。 注意： GDDR3和DDR3不是一样的，前者是专属显存，是基于DDR2内存改造而成，而DDR3是普通的内存，年代比GDDR3要新，但延迟和频率比不过GDDR3。之所以DDR3大量应用，是因为成本很低，为了缩减成本，用DDR3不足为奇。 容量 一般来说够用即可，根据自己的需求场合来选购，没必要单纯追求显存大。 1680*1050分辨率，1G显存1440*900及其一下，512M就可以1920*1080，至少1.5G显存。 对于某些场合，如极端游戏来说，2G显存可能都在1080P下不够用，所以要选购更大的显存容量。 这里介绍一下，动态共享显存技术。是将内存划分为显存，以便当显卡独立显存不够用的时候临时占用。N卡(即NVIDIA显卡)将此技术称为TC(Turbo Cache)、A卡称为HM，这也就是市面上经常听见显卡是TC1024M或者HM1024M的，这时候所谓的显存大小就是共享后独立显存和共享显存容量之和，买显卡的时候需要注意，基本上很多商家都是不标注的。 显存位宽 显存位宽是显存在一个时钟周期内所能传送数据的位数，位数越大则瞬间所能传输的数据量就越大，这是显存的重要参数之一。位宽是由每个颗粒的位宽和使用数量决定的，比如每个颗粒32bit宽，使用8颗并联就是256bit位宽了(其实容量就是这样决定的，128M*8=1024M)。位宽的作用就是增大 带宽。
引申： 晶圆，一般有6英寸、8英寸及12英寸规格不等，晶片就是基于晶圆生产出来的。晶圆上一个小块，一个小块，就是晶片晶圆体，也名Die，经过封装之后就成为一个闪存颗粒。
显存频率 频率，显存的实际频率，等效频率是两个概念。 由于现在显存都基于DDR系列内存改造，DDR因为能在时钟的上升沿和下降沿都能传送数据，所以比SDR同频效率高了一倍，因而就有了等效频率这一说法。GDDR3和DDR3都是等效两倍，而GDDR5是2倍于GDDR3的数据预取量和DQ并行总线，使得GDDR5显存的实际速度又快了一倍，等效4倍。这也就是为什么GDDR5频率很高，只是等效频率高了，实际频率和GDDR3差不远(实际频率取决于物理特性，即颗粒的的固有频率所决定)。
引申: SDR为SDRAM,即Synchronous DRAM（同步动态随机存储器），曾经是PC电脑上最为广泛应用的一种内存类型，即便在今天SDRAM仍旧还在市场占有一席之地。既然是“同步动态随机存储器”，那就代表着它的工作速度是与系统总线速度同步的。SDRAM内存又分为PC66、PC100、PC133等不同规格，而规格后面的数字就代表着该内存最大所能正常工作系统总线速度，比如PC100，那就说明此内存可以在系统总线为100MHz的电脑中同步工作。
带宽 除容量外、类型、位宽和频率能共同决定一个重要的参数—–带宽。显存带宽是指显示芯片与显存之间的数据传输速率，它以字节/秒为单位。 显存带宽 = 等效频率 X 显存位宽 / 8s 带宽越大，意味着对GPU数据吞吐的能力越大，举个例子，水管的大小就是带宽，水流就是GPU的数据，水流小没有限制，大了水管小就会出现瓶颈了。因此，对带宽的要求就是：够用即可。 带宽的高低并不能直接对比不同型号的显卡高低。
(4)散热 显卡散热一般是风冷主动散热，就是在散热片上加装风扇，被动散热指的是没有风扇，依靠自然气流散热。 散热的好坏可以通过散热面积大小，铜管直径和数量，风扇类型和数量来判断。 主动散热用到的风扇有两种，普通散热风扇和涡轮风扇。前者一般转速低进风量较小，通常会配多个风扇在高端显卡上；而后者转速较高，进风量较大，一般一个显卡只用一个涡轮风扇，但噪音较大。通常只有公版高端卡才会用涡轮。
被动散热一般鳍片比较宽厚，覆盖面积大，应用于发热比较小的低端显卡。 当然还有一种就是水冷散热，这个就是属于DIY，不做介绍。
(5)金手指 显卡的金手指(connecting finger)是显卡与插槽的连接部件，所有的信号都是通过金手指进行传送的。金手指由众多金黄色的导电触片排列如手指状，所以称为“金手指”。金手指的形状代表了该显卡的插槽类型，目前显卡都是PCI-E 16X接口的，过去的显卡有AGP和PCI接口的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb01ee120909be0a8ce5420aafde4cf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/463/">«</a>
	<span class="pagination__item pagination__item--current">464/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/465/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>