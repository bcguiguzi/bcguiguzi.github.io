<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f10a6639c6a984edbe361318fcf8a6/" rel="bookmark">
			如何把文章中所有的数字和英文变为Time s New Rowman
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、选中全文；
2、将文章所有字体设置为Time s New Rowman，中文的会自动不变为Time s New Rowman。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed440e006ed10b40e23f0ec4f35dba7e/" rel="bookmark">
			类的封装与继承——简例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源于牛客网
题目描述
KiKi理解了继承可以让代码重用，他现在定义一个基类shape，私有数据为坐标点x,y, 由它派生Rectangle类和Circle类，它们都有成员函数GetArea()求面积。派生类Rectangle类有数据：矩形的长和宽；派生类Circle类有数据：圆的半径。Rectangle类又派生正方形Square类，定义各类并测试。输入三组数据，分别是矩形的长和宽、圆的半径、正方形的边长，输出三组数据，分别是矩形、圆、正方形的面积。圆周率按3.14计算。
输入描述:
输入三行， 第一行为矩形的长和宽， 第二行为圆的半径， 第三行为正方形的边长。
输出描述:
三行，分别是矩形、圆、正方形的面积。
示例1
输入
7 8
10 5
输出
56
314
25
代码如下： #include &lt;iostream&gt; using namespace std; class shape { private: int x,y; }; class Rectangle:public shape { public: double GetArea(){return length*width;} int length; int width; } p; class Circle:public shape { public: double GetArea() {return 3.14*r*r;} int r; }; class Square:public Rectangle { public: double GetArea() {return x*x;} int x; }; int main() { Rectangle Length,Width; Circle R; Square X; cin&gt;&gt;p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed440e006ed10b40e23f0ec4f35dba7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e20d05db84687fe01a39529a628cea/" rel="bookmark">
			警告1909。无法创建快捷方式VMware Workstation Pro.Ink。解决方法（附 VMware_workstation 12的安装方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 警告1909。无法创建快捷方式VMware Workstation Pro.Ink。解决方法（附 VMware_workstation 12的安装方法）
参考文章：
（1）警告1909。无法创建快捷方式VMware Workstation Pro.Ink。解决方法（附 VMware_workstation 12的安装方法）
（2）https://www.cnblogs.com/alier/p/6327363.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700a8d53edd0b150cfc18f0ef9de0441/" rel="bookmark">
			接到个商城任务需要接入个微信或者QQ客服，找到了两篇解决文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【uniapp 开发】uni-app 中如何打开外部应用 我们在开发 App 应用中，经常会遇到打开第三方程序的场景，比如打开手机淘宝、通过第三方浏览器打开一个 url 等等。
App不像网页可以使用http超链接互相跳转，但手机os设计了scheme机制，可以通过特殊的链接互相调起。
比如手机淘宝，其安装后会在手机os中会注册一个scheme协议，taobao://。
这种协议还支持参数，比如taobao://s.taobao.com/search?q=uni-app启动淘宝并打开搜索页面搜索uni-app。
在uni-app/5+App中，可以通过scheme呼起其他App，也支持给自己的App设置scheme参数。
这个功能小程序并不支持，属于App端的扩展API。
打开外部scheme的API是plus.runtime.openURL()。查看文档：http://www.html5plus.org/doc/zh_cn/runtime.html
1.打开第三方程序，我们需要使用 runtime 模块,下面列了两个相关的方法。其他操作请详读文档。
plus.runtime.openURL( url, errorCB, identity ); url: ( String ) 必选 要打开的URL地址 字符串类型，各平台支持的地址类型存在差异，参考平台URL支持表。errorCB: ( OpenErrorCallback ) 可选 打开URL地址失败的回调
打开指定URL地址失败时回调，并返回失败信息。identity: ( String ) 可选 指定打开URL地址的程序名称
在iOS平台此参数被忽略，在Android平台为程序包名，如果指定的包名不存在，则打开URL地址失败。 &lt;template&gt; &lt;view&gt; &lt;button class="button" type="primary" @click="open(0)"&gt;使用第三方程序打开指定URL&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { url: 'https://uniapp.dcloud.io/' }; }, onLoad(op) {}, methods: { open(types) { plus.runtime.openURL(this.url, function(res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700a8d53edd0b150cfc18f0ef9de0441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f5d5e166652d05ffe55eb5b121e175/" rel="bookmark">
			Android 实现文件夹排序功能的实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.jb51.net/article/147787.htm
Android 实现文件夹排序功能的实例代码
按文件名排序
/**
按文件名排序@param filePath
/
public static ArrayList orderByName(String filePath) {
ArrayList FileNameList = new ArrayList();
File file = new File(filePath);
File[] files = file.listFiles();
List fileList = Arrays.asList(files);
Collections.sort(fileList, new Comparator() {
@Override
public int compare(File o1, File o2) {
if (o1.isDirectory() &amp;&amp; o2.isFile())
return -1;
if (o1.isFile() &amp;&amp; o2.isDirectory())
return 1;
return o1.getName().compareTo(o2.getName());
}
});
for (File file1 : files) {
if (file1.isDirectory()) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f5d5e166652d05ffe55eb5b121e175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b291b6e599b02fec5e42c9907b7fe7/" rel="bookmark">
			Andriod WIFIF 隐藏SSID配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法：
在/data/misc/wifi/hostpad.confg 文件中加入如下ignore_broadcast_ssid=1加入此配置项后重启启动wifi热点模块即可很方便的隐藏SSID，如需不隐藏则将值配置为0即可。
可参考：
https://blog.csdn.net/xzx208/article/details/79622183?utm_source=blogxgwz7
方法2：
配置WifiConfiguration
WifiConfiguration wifiConfiguration = new WifiConfiguration();
wifiConfiguration.SSID = convertToQuotedString(SSID);
wifiConfiguration.hiddenSSID=hiddenSSID;//是否隐藏热点true=隐藏,如果隐藏需要其他设备
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11525945b1be39fa5320fff98b8a2b9/" rel="bookmark">
			C语言实战——哲学家问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实战——哲学家问题 问题描述 有五个哲学家绕着圆桌坐，每个哲学家面前有一盘面，两人之间有一支筷子，这样每个哲学家左右各有一支筷子。哲学家有2个状态，思考或者拿起筷子吃饭。如果哲学家拿到一只筷子，不能吃饭，直到拿到2只才能吃饭，并且一次只能拿起身边的一支筷子。一旦拿起便不会放下筷子直到把饭吃完，此时才把这双筷子放回原处。如果，很不幸地，每个哲学家拿起他或她左边的筷子，那么就没有人可以吃到饭了。
哲学家进餐问题是一个多线程运用的经典例子，涉及到线程同步/互斥，临界区访问问题以及死锁问题。
解决方法 方法一 通过互斥信号量mutex对哲学家进餐之前取左右两侧的筷子的操作进行保护，可以防止死锁的出现也就是说，要达到的目的是，某位哲学家开始拿第一支筷子时，其他哲学家全部不准拿筷子（即使他已经饿了），只可以放下，直到这位哲学家拿到一双筷子之后，允许其他筷子被拿起，以此类推。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;malloc.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; #define N 5 sem_t chopsticks[N];//设置5种信号量，有5种不同类型的资源，每一种有1个,这样便于理解，因为每个哲学家需要的资源不同 pthread_mutex_t mutex;//定义互斥锁 int philosophers[N] = {0, 1, 2, 3, 4};//代表5个哲学家的编号 void delay (int len) { int i = rand() % len; int x; while (i &gt; 0) { x = rand() % len; while (x &gt; 0) { x--; } i--; } } void *philosopher (void* arg) { int i = *(int *)arg; int left = i;//左筷子的编号和哲学家的编号相同 int right = (i + 1) % N;//右筷子的编号为哲学家编号+1 while (1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11525945b1be39fa5320fff98b8a2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d88e792368ec50309185968438e0ca/" rel="bookmark">
			VS 2017 无法打开 kernel32.lib问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先问题
是这样的：
我设置属性管理器：配置Opencv，然后，不知道怎么弄的，出现这个问题：
出现这个问题：我看了一下我的库目录：
是这样子的！
怎么会这样，是不是感觉缺少了很多东西，和其他的目录比起来！
解决方法：
1、选择库目录后的下拉菜单
2、然后找到编辑：
3、进入新的窗口：
4、将这三个值依次复制放到库目录前面！
$(VC_LibraryPath_x64) $(WindowsSDK_LibraryPath_x64) $(NETFXKitsDir)Lib\um\x64 5、就可以运行了
篇外：
还有一个投机取巧的办法：特别省事（但是尽量还是要把前面的写上，确保万无一失呀）：
$(LibraryPath) 将上面这段话放到库目录后面，完美解决！
注意
这个一般要勾选呀，因为，有些东西可能需要用到父级库。
哈哈哈哈，多省事。
有问题请给我留言，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e740a0104583db2c1842d685cbb9e8/" rel="bookmark">
			手把手教你用Typora自动上传到picgo图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考一
参考二
PicGo配置正确但图片上传失败的解决方案G
解决：设置Server，重新启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1360d165d9f956c37fde3a74381cf10f/" rel="bookmark">
			ubuntu中使用screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xshell关闭以后，运行的程序也退出了，为了让xshell关闭后，程序继续运行，可以使用screen
通过命令：
sudo apt install screen 安装screen
新建窗口
1）可直接通过命令screen新建一个窗口，并进入窗口。但通过这种方式新建的窗口没有名字，只有系统分配给它的一个id。当需要恢复窗口时，只能通过id号来恢复。
2）通过命令screen -S name，这样就可以新建一个名字为name的窗口，同样系统也会分配给它一个id，当恢复该窗口时既可以通过id号也可以通过窗口名。
分离会话
退出当前新建的窗口，通过快键键Ctrl+a+d实现分离，此时窗口会跳出[detached]的提示，并回到主窗口。
恢复会话窗口
首先查看当前有哪些screen窗口，通过命令：
screen -ls 将列出窗口列表
关闭s1，screen -ls，如下
screen -r s1 或 screen -r 16963恢复s1
杀死会话窗口
通过命令kill -9 threadnum
注意此处只能通过id号来杀死窗口。
清除死去窗口
通过命令screen -wipe
这个命令将自动清除所有处于dead状态的窗口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3067c77c49f32f9a7a49cbcb4abcfa/" rel="bookmark">
			【Java】【VSCode】添加需要 import 的 Jar 包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在左侧的 Explorer 中，找到 Java Dependencies：
点击 + 号，找到需要导入的 Jar 包，添加即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba81a42e9b3fd5edbfb5ca03c758282/" rel="bookmark">
			yum源，网络源（阿里源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置网络源
我们主要的源在/etc/yum.repos.d/
其中，CentOS-Base.repo为网络源
vim CentOS-Base.repo //使用的是阿里的源
如何使用（通过wget工具下载阿里源）
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
或者mkdir CentOS-Base.repo （注：repo结尾）
[base]
name=CentOS- r e l e a s e v e r e n a b l e d = 1 f a i l o v e r m e t h o d = p r i o r i t y b a s e u r l = h t t p : / / m i r r o r s .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba81a42e9b3fd5edbfb5ca03c758282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ebe2022559f9a02b9788b6bc00c3e8/" rel="bookmark">
			【JavaScript】解决$ is not defined问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.问题
在调试js代码的时候，发现浏览器控制台中出现报错：$ is not defined
2.原因
出现以上问题的原因大致有一下几种：
1.没有导入jQuery的jar包
2.jQuery的jar包放进了WEB-INF里，jQuery的jar包最好放在WebContent下，跟WEB-INF同级
3.导入jQuery的路径名没有写对
4.jQuery没有包含js
3.解决方法：
在js代码之前导包：
&lt;script type="text/javascript" src="/test/js/jquery-1.11.3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function(){ }); &lt;/script&gt; 尽量用绝对路径：
&lt;script type="text/javascript" src="/test/js/jquery-1.11.3.js"&gt;&lt;/script&gt; 4.建议
可以直接使用在线前端库，有免费的CDN加速，加载jQuery会更快
&lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a174f774168993b043ca5034e1876cec/" rel="bookmark">
			PySide2基础篇（二）——QLabel运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PySide2基础篇（二）——QLabel运用 前言：
阅读这篇文章我能学到什么？
我们知道做窗口应用程序最基础的是掌握控件的运用。QLabel就是PySide2中一个基础的控件，它可以用于可以显示文本、图像、视频。下面让我们开始学习它。
——如果你觉得这是一篇不错的博文，希望你能给一个小小的赞，感谢您的支持。
1 使用QLabel能做什么？ Qt for Python模块中最基本的有三个模块：
Qt Core：提供核心的非GUI模块，列如信号和插槽，项目模型的基类，序列化等。Qt GUI：通过GUI功能扩展QtCore：事件，窗口和屏幕，基于OpenGL和基于栅格的2D绘画以及图像。Widgets 为您的应用程序提供随时可用的小部件，包括UI的图形元素。 QLabel属于控件，因此它继承于模块Widgets。
QtCore.QObject QtGui.QPaintDevice QtWidgets.QWidget QtWidgets.QFrame QtWidgets.QLabel QLabel用于显示文本、图像、视频，不具有交互功能。我们可以设置QLabel控件的外观等属性，比如大小、颜色、位置等。一般来说我们给其显示如下内容：
纯文本富文本数值像素图动画 2 QLabel显示纯文本 2.1 创建一个QLabel 函数原型：
QLabel(text [, parent = None [, f = Qt.WindowFlags()]]) param f WindowFlags param parent QWidget param text unicode 我们注意到其有参数text并且是可省略的。这个参数是设置QLabel控件创建后显示的初始文本，省略时内容为空。
代码示例：
from PySide2.QtWidgets import QApplication, QLabel app = QApplication([]) Label = QLabel("初始文本") #创建一个类QLabel的实例对象Label，设置初始显示字符串 Label.show() app.exec_() 运行结果：
2.1 修改QLabel的文本内容 2.1.1 setText 函数原型：
PySide2.QtWidgets.QLabel.setText(arg__1) Parameters arg__1 – TextFormat 其只有一个参数用于传递要设置的文本内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a174f774168993b043ca5034e1876cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa38b1ddc0737265ea489508ffbd74d/" rel="bookmark">
			今日头条算法原理（全文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，算法分发已经是信息平台、搜索引擎、浏览器、社交软件等几乎所有软件的标配，但同时，算法也开始面临质疑、挑战和误解。今日头条的推荐算法，从2012年9月第一版开发运行至今，已经经过四次大的调整和修改。
今日头条委托资深算法架构师曹欢欢博士，公开今日头条的算法原理，以期推动整个行业问诊算法、建言算法；通过让算法透明，来消除各界对算法的误解，并逐步推动整个行业让算法更好的造福社会。
以下为《今日头条算法原理》全文。
今日头条资深算法架构师曹欢欢：
本次分享将主要介绍今日头条推荐系统概览以及内容分析、用户标签、评估分析，内容安全等原理。
一、系统概览 推荐系统，如果用形式化的方式去描述实际上是拟合一个用户对内容满意度的函数，这个函数需要输入三个维度的变量。第一个维度是内容。头条现在已经是一个综合内容平台，图文、视频、UGC小视频、问答、微头条，每种内容有很多自己的特征，需要考虑怎样提取不同内容类型的特征做好推荐。第二个维度是用户特征。包括各种兴趣标签，职业、年龄、性别等，还有很多模型刻划出的隐式用户兴趣等。第三个维度是环境特征。这是移动互联网时代推荐的特点，用户随时随地移动，在工作场合、通勤、旅游等不同的场景，信息偏好有所偏移。结合三方面的维度，模型会给出一个预估，即推测推荐内容在这一场景下对这一用户是否合适。
这里还有一个问题，如何引入无法直接衡量的目标？
推荐模型中，点击率、阅读时间、点赞、评论、转发包括点赞都是可以量化的目标，能够用模型直接拟合做预估，看线上提升情况可以知道做的好不好。但一个大体量的推荐系统，服务用户众多，不能完全由指标评估，引入数据指标以外的要素也很重要。
比如广告和特型内容频控。像问答卡片就是比较特殊的内容形式，其推荐的目标不完全是让用户浏览，还要考虑吸引用户回答为社区贡献内容。这些内容和普通内容如何混排，怎样控制频控都需要考虑。
此外，平台出于内容生态和社会责任的考量，像低俗内容的打压，标题党、低质内容的打压，重要新闻的置顶、加权、强插，低级别账号内容降权都是算法本身无法完成，需要进一步对内容进行干预。
下面我将简单介绍在上述算法目标的基础上如何对其实现。
前面提到的公式y = F(Xi ,Xu ,Xc)，是一个很经典的监督学习问题。可实现的方法有很多，比如传统的协同过滤模型，监督学习算法Logistic Regression模型，基于深度学习的模型，Factorization Machine和GBDT等。
一个优秀的工业级推荐系统需要非常灵活的算法实验平台，可以支持多种算法组合，包括模型结构调整。因为很难有一套通用的模型架构适用于所有的推荐场景。现在很流行将LR和DNN结合，前几年Facebook也将LR和GBDT算法做结合。今日头条旗下几款产品都在沿用同一套强大的算法推荐系统，但根据业务场景不同，模型架构会有所调整。
模型之后再看一下典型的推荐特征，主要有四类特征会对推荐起到比较重要的作用。
第一类是相关性特征，就是评估内容的属性和与用户是否匹配。显性的匹配包括关键词匹配、分类匹配、来源匹配、主题匹配等。像FM模型中也有一些隐性匹配，从用户向量与内容向量的距离可以得出。
第二类是环境特征，包括地理位置、时间。这些既是bias特征，也能以此构建一些匹配特征。
第三类是热度特征。包括全局热度、分类热度，主题热度，以及关键词热度等。内容热度信息在大的推荐系统特别在用户冷启动的时候非常有效。
第四类是协同特征，它可以在部分程度上帮助解决所谓算法越推越窄的问题。协同特征并非考虑用户已有历史。而是通过用户行为分析不同用户间相似性，比如点击相似、兴趣分类相似、主题相似、兴趣词相似，甚至向量相似，从而扩展模型的探索能力。
模型的训练上，头条系大部分推荐产品采用实时训练。实时训练省资源并且反馈快，这对信息流产品非常重要。用户需要行为信息可以被模型快速捕捉并反馈至下一刷的推荐效果。我们线上目前基于storm集群实时处理样本数据，包括点击、展现、收藏、分享等动作类型。模型参数服务器是内部开发的一套高性能的系统，因为头条数据规模增长太快，类似的开源系统稳定性和性能无法满足，而我们自研的系统底层做了很多针对性的优化，提供了完善运维工具，更适配现有的业务场景。
目前，头条的推荐算法模型在世界范围内也是比较大的，包含几百亿原始特征和数十亿向量特征。整体的训练过程是线上服务器记录实时特征，导入到Kafka文件队列中，然后进一步导入Storm集群消费Kafka数据，客户端回传推荐的label构造训练样本，随后根据最新样本进行在线训练更新模型参数，最终线上模型得到更新。这个过程中主要的延迟在用户的动作反馈延时，因为文章推荐后用户不一定马上看，不考虑这部分时间，整个系统是几乎实时的。
但因为头条目前的内容量非常大，加上小视频内容有千万级别，推荐系统不可能所有内容全部由模型预估。所以需要设计一些召回策略，每次推荐时从海量内容中筛选出千级别的内容库。召回策略最重要的要求是性能要极致，一般超时不能超过50毫秒。
召回策略种类有很多，我们主要用的是倒排的思路。离线维护一个倒排，这个倒排的key可以是分类，topic，实体，来源等，排序考虑热度、新鲜度、动作等。线上召回可以迅速从倒排中根据用户兴趣标签对内容做截断，高效的从很大的内容库中筛选比较靠谱的一小部分内容。
二、内容分析 内容分析包括文本分析，图片分析和视频分析。头条一开始主要做资讯，今天我们主要讲一下文本分析。文本分析在推荐系统中一个很重要的作用是用户兴趣建模。没有内容及文本标签，无法得到用户兴趣标签。举个例子，只有知道文章标签是互联网，用户看了互联网标签的文章，才能知道用户有互联网标签，其他关键词也一样。
另一方面，文本内容的标签可以直接帮助推荐特征，比如魅族的内容可以推荐给关注魅族的用户，这是用户标签的匹配。如果某段时间推荐主频道效果不理想，出现推荐窄化，用户会发现到具体的频道推荐（如科技、体育、娱乐、军事等）中阅读后，再回主feed,推荐效果会更好。因为整个模型是打通的，子频道探索空间较小，更容易满足用户需求。只通过单一信道反馈提高推荐准确率难度会比较大，子频道做的好很重要。而这也需要好的内容分析。
上图是今日头条的一个实际文本case。可以看到，这篇文章有分类、关键词、topic、实体词等文本特征。当然不是没有文本特征，推荐系统就不能工作，推荐系统最早期应用在Amazon,甚至沃尔玛时代就有，包括Netfilx做视频推荐也没有文本特征直接协同过滤推荐。但对资讯类产品而言，大部分是消费当天内容，没有文本特征新内容冷启动非常困难，协同类特征无法解决文章冷启动问题。
今日头条推荐系统主要抽取的文本特征包括以下几类。首先是语义标签类特征，显式为文章打上语义标签。这部分标签是由人定义的特征，每个标签有明确的意义，标签体系是预定义的。此外还有隐式语义特征，主要是topic特征和关键词特征，其中topic特征是对于词概率分布的描述，无明确意义；而关键词特征会基于一些统一特征描述，无明确集合。
另外文本相似度特征也非常重要。在头条，曾经用户反馈最大的问题之一就是为什么总推荐重复的内容。这个问题的难点在于，每个人对重复的定义不一样。举个例子，有人觉得这篇讲皇马和巴萨的文章，昨天已经看过类似内容，今天还说这两个队那就是重复。但对于一个重度球迷而言，尤其是巴萨的球迷，恨不得所有报道都看一遍。解决这一问题需要根据判断相似文章的主题、行文、主体等内容，根据这些特征做线上策略。
同样，还有时空特征，分析内容的发生地点以及时效性。比如武汉限行的事情推给北京用户可能就没有意义。最后还要考虑质量相关特征，判断内容是否低俗，色情，是否是软文，鸡汤？
上图是头条语义标签的特征和使用场景。他们之间层级不同，要求不同。
分类的目标是覆盖全面，希望每篇内容每段视频都有分类；而实体体系要求精准，相同名字或内容要能明确区分究竟指代哪一个人或物，但不用覆盖很全。概念体系则负责解决比较精确又属于抽象概念的语义。这是我们最初的分类，实践中发现分类和概念在技术上能互用，后来统一用了一套技术架构。
目前，隐式语义特征已经可以很好的帮助推荐，而语义标签需要持续标注，新名词新概念不断出现，标注也要不断迭代。其做好的难度和资源投入要远大于隐式语义特征，那为什么还需要语义标签？有一些产品上的需要，比如频道需要有明确定义的分类内容和容易理解的文本标签体系。语义标签的效果是检查一个公司NLP技术水平的试金石。
今日头条推荐系统的线上分类采用典型的层次化文本分类算法。最上面Root，下面第一层的分类是像科技、体育、财经、娱乐，体育这样的大类，再下面细分足球、篮球、乒乓球、网球、田径、游泳...，足球再细分国际足球、中国足球，中国足球又细分中甲、中超、国家队...，相比单独的分类器，利用层次化文本分类算法能更好地解决数据倾斜的问题。有一些例外是，如果要提高召回，可以看到我们连接了一些飞线。这套架构通用，但根据不同的问题难度，每个元分类器可以异构，像有些分类SVM效果很好，有些要结合CNN，有些要结合RNN再处理一下。
上图是一个实体词识别算法的case。基于分词结果和词性标注选取候选，期间可能需要根据知识库做一些拼接，有些实体是几个词的组合，要确定哪几个词结合在一起能映射实体的描述。如果结果映射多个实体还要通过词向量、topic分布甚至词频本身等去歧，最后计算一个相关性模型。
三、用户标签 内容分析和用户标签是推荐系统的两大基石。内容分析涉及到机器学习的内容多一些，相比而言，用户标签工程挑战更大。
今日头条常用的用户标签包括用户感兴趣的类别和主题、关键词、来源、基于兴趣的用户聚类以及各种垂直兴趣特征（车型，体育球队，股票等）。还有性别、年龄、地点等信息。性别信息通过用户第三方社交账号登录得到。年龄信息通常由模型预测，通过机型、阅读时间分布等预估。常驻地点来自用户授权访问位置信息，在位置信息的基础上通过传统聚类的方法拿到常驻点。常驻点结合其他信息，可以推测用户的工作地点、出差地点、旅游地点。这些用户标签非常有助于推荐。
当然最简单的用户标签是浏览过的内容标签。但这里涉及到一些数据处理策略。主要包括：
一、过滤噪声。通过停留时间短的点击，过滤标题党。
二、热点惩罚。对用户在一些热门文章（如前段时间PG One的新闻）上的动作做降权处理。理论上，传播范围较大的内容，置信度会下降。
三、时间衰减。用户兴趣会发生偏移，因此策略更偏向新的用户行为。因此，随着用户动作的增加，老的特征权重会随时间衰减，新动作贡献的特征权重会更大。
四、惩罚展现。如果一篇推荐给用户的文章没有被点击，相关特征（类别，关键词，来源）权重会被惩罚。当然同时，也要考虑全局背景，是不是相关内容推送比较多，以及相关的关闭和dislike信号等。
用户标签挖掘总体比较简单，主要还是刚刚提到的工程挑战。头条用户标签第一版是批量计算框架，流程比较简单，每天抽取昨天的日活用户过去两个月的动作数据，在Hadoop集群上批量计算结果。
但问题在于，随着用户高速增长，兴趣模型种类和其他批量处理任务都在增加，涉及到的计算量太大。2014年，批量处理任务几百万用户标签更新的Hadoop任务，当天完成已经开始勉强。集群计算资源紧张很容易影响其它工作，集中写入分布式存储系统的压力也开始增大，并且用户兴趣标签更新延迟越来越高。
面对这些挑战。2014年底今日头条上线了用户标签Storm集群流式计算系统。改成流式之后，只要有用户动作更新就更新标签，CPU代价比较小，可以节省80%的CPU时间，大大降低了计算资源开销。同时，只需几十台机器就可以支撑每天数千万用户的兴趣模型更新，并且特征更新速度非常快，基本可以做到准实时。这套系统从上线一直使用至今。
当然，我们也发现并非所有用户标签都需要流式系统。像用户的性别、年龄、常驻地点这些信息，不需要实时重复计算，就仍然保留daily更新。
四、评估分析 上面介绍了推荐系统的整体架构，那么如何评估推荐效果好不好？
有一句我认为非常有智慧的话，“一个事情没法评估就没法优化”。对推荐系统也是一样。
事实上，很多因素都会影响推荐效果。比如侯选集合变化，召回模块的改进或增加，推荐特征的增加，模型架构的改进在，算法参数的优化等等，不一一举例。评估的意义就在于，很多优化最终可能是负向效果，并不是优化上线后效果就会改进。
全面的评估推荐系统，需要完备的评估体系、强大的实验平台以及易用的经验分析工具。所谓完备的体系就是并非单一指标衡量，不能只看点击率或者停留时长等，需要综合评估。过去几年我们一直在尝试，能不能综合尽可能多的指标合成唯一的评估指标，但仍在探索中。目前，我们上线还是要由各业务比较资深的同学组成评审委员会深入讨论后决定。
很多公司算法做的不好，并非是工程师能力不够，而是需要一个强大的实验平台，还有便捷的实验分析工具，可以智能分析数据指标的置信度。
一个良好的评估体系建立需要遵循几个原则，首先是兼顾短期指标与长期指标。我在之前公司负责电商方向的时候观察到，很多策略调整短期内用户觉得新鲜，但是长期看其实没有任何助益。
其次，要兼顾用户指标和生态指标。今日头条作为内容分创作平台，既要为内容创作者提供价值，让他更有尊严的创作，也有义务满足用户，这两者要平衡。还有广告主利益也要考虑，这是多方博弈和平衡的过程。
另外，要注意协同效应的影响。实验中严格的流量隔离很难做到，要注意外部效应
强大的实验平台非常直接的优点是，当同时在线的实验比较多时，可以由平台自动分配流量，无需人工沟通，并且实验结束流量立即回收，提高管理效率。这能帮助公司降低分析成本，加快算法迭代效应，使整个系统的算法优化工作能够快速往前推进。
这是头条A/B Test实验系统的基本原理。首先我们会做在离线状态下做好用户分桶，然后线上分配实验流量，将桶里用户打上标签，分给实验组。举个例子，开一个10%流量的实验，两个实验组各5%，一个5%是基线，策略和线上大盘一样，另外一个是新的策略。
实验过程中用户动作会被搜集，基本上是准实时，每小时都可以看到。但因为小时数据有波动，通常是以天为时间节点来看。动作搜集后会有日志处理、分布式统计、写入数据库，非常便捷。
在这个系统下工程师只需要设置流量需求、实验时间、定义特殊过滤条件，自定义实验组ID。系统可以自动生成：实验数据对比、实验数据置信度、实验结论总结以及实验优化建议。
当然，只有实验平台是远远不够的。线上实验平台只能通过数据指标变化推测用户体验的变化，但数据指标和用户体验存在差异，很多指标不能完全量化。很多改进仍然要通过人工分析，重大改进需要人工评估二次确认。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa38b1ddc0737265ea489508ffbd74d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a37009302f13a9d4461cd97863d0ff3/" rel="bookmark">
			CAS-Centos7安装CAS服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境信息 [root@suhw ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) [root@suhw ~]# uname -a Linux suhw 3.10.0-1062.4.3.el7.x86_64 #1 SMP Wed Nov 13 23:58:53 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装jdk 查看系统信息 [root@suhw ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) [root@suhw ~]# uname -a Linux suhw 3.10.0-1062.4.3.el7.x86_64 #1 SMP Wed Nov 13 23:58:53 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 查看yum包含的jdk版本 [root@suhw ~]# yum search java 安装jdk [root@suhw ~]# yum install java-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a37009302f13a9d4461cd97863d0ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb799b0774c279b35a9a1fccf451d0e/" rel="bookmark">
			2020年如何卸载/退出亚信安全防毒墙网络版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 操作步骤很简单：
首先确认下系统是32位还是64位，因为在不同位数的系统上注册表路径存在差异，这点需要注意一下。
1：电脑开机按F8，进入安全模式，一定是安全模式，不要选其他带网络安全模式之类的，必须是：安全模式；
2：进入安全模式后，如果你是为了卸载，那么修改注册表：
32位系统：
将 HKEY_LOCAL_MACHINE/SOFTWARE/TrendMicro/pcCillinNTCorp/CurrentVersion/Misc中的 Allow Unistall 的键属值改为1即可，这样就可以重启电脑后进行卸载了。
64位系统：
将 HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/TrendMicro/PC-illinNTcorp/CurrentVersion/Misc/Allow Uninstall 的键属值改为1即可，这样就可以重启电脑后进行卸载了。
3：如果你不是为了卸载，只是希望在使用过程中可以退出该软件，那么，修改注册表：
32位系统：
将 HKEY_LOCAL_MACHINE/SOFTWARE/TrendMicro/PC-cillinNTCorp/CurrentVersion/Misc/NoPwdProtect 键值由0 改为1即可，这样在正常使用过程中，就可以退出该软件，不需要输入密码。
64位系统：
将 HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/TrendMicro/PC-illinNTcorp/CurrentVersion/Misc/NoPwdProtect 键值由0 改为1即可，这样在正常使用过程中，就可以退出该软件，不需要输入密码。
上述修改之后，关闭注册表，重启电脑，进入正常模式，然后开始菜单找到亚信杀软项目进行卸载即可完成卸载。
最后：如果卸载方法失效，那就失效了，再另寻他法吧，祝君顺利！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c83b96b516ca3c24c217cbb4427d25/" rel="bookmark">
			Spring单例模式下的多线程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一直以来有个疑问？
Spring中的bean不是单例模式吗？为什么那么多客户端访问同一个接口不会出现线程安全问题？
其实：
spring单例模式指的是在内存中只实例化一个类的对象。确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。当多个用户同时请求一个接口服务的时候，容器会给每一个请求分配一个线程，这时候多个线程会并发执行该请求所对应的业务逻辑。如果该逻辑涉及到对该单例状态（成员变量）的改变，就会有线程安全的问题。Spring使用ThreadLocal来解决线程安全问题，每个线程去执行业务代码的时候，都会去内存申请临时变量，这样就不会涉及变量并发访问冲突的问题。一般的 Web 应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。 那JVM是如何实现线程的独立内存空间？
每当启用一个线程时，JVM就为他分配一个Java栈，栈是以帧为单位保存当前线程的运行状态。某个线程正在执行的方法称为当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。当线程执行一个方法时，它会跟踪当前常量池。每当线程调用一个Java方法时，JVM就会在该线程对应的栈中压入一个帧，这个帧自然就成了当前帧。当执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等等。Java栈上的所有数据都是私有的。任何线程都不能访问另一个线程的栈数据。所以我们不用考虑多线程情况下栈数据访问同步的情况。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940e61469f5c8fdfe1f396bc518383e4/" rel="bookmark">
			C语言int/double数据类型的范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;limits.h&gt; # include &lt;float.h&gt; int main() { printf("int类型数据所占空间=%d\n", sizeof(int)); // int类型数据范围 // 方法1 printf("int最小值=%d, int最大值=%d\n", INT_MIN, INT_MAX);	// 使用limits.h里的宏 //方法2 signed int max = (1 &lt;&lt; (sizeof(int) * 8 - 1)) - 1;	// 自己计算 signed int min = -(1 &lt;&lt; (sizeof(int) * 8 - 1)); printf("int最小值=%d, int最大值=%d\n", min, max); // 方法3 printf("int最小值=%d, int最大值=%d\n", max+1, min-1); // double数据类型精度及范围--数据很大 printf("float类型数据所占空间:%d\n", sizeof(float)); printf("double类型数据所占空间:%d\n", sizeof(double)); printf("double精度：%lf\n");	//有警告，不过可以运行 printf("double最小值=%lf\n, double最大值=%lf\n", -DBL_MAX, DBL_MAX);	//使用float.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940e61469f5c8fdfe1f396bc518383e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07ccab6945f9040559d9f555c45683f/" rel="bookmark">
			WebSocket的故事（三）—— Springboot中，如何利用WebSocket和STOMP快速构建点对点的消息模式(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近，偶然在掘金上发现了一个大牛写的这篇文章，感觉作者写的非常好，防止以后找不到了，这里转载记录一下，方便以后使用。
概述 本文是WebSocket的故事系列第三篇第一节，将逐步深入Spring源码进行介绍，本系列的干货也将陆续在后面的几篇文章中放出。WebSocket的故事系列计划分五大篇，旨在由浅入深的介绍WebSocket以及在Springboot中如何快速构建和使用WebSocket提供的能力。本系列计划包含如下几篇文章：
第一篇，什么是WebSocket以及它的用途
第二篇，Spring中如何利用STOMP快速构建WebSocket广播式消息模式
第三篇，Springboot中，如何利用WebSocket和STOMP快速构建点对点的消息模式(1)
第四篇，Springboot中，如何利用WebSocket和STOMP快速构建点对点的消息模式(2)
第五篇，Springboot中，实现网页聊天室之自定义WebSocket消息代理
第六篇，Springboot中，实现更灵活的WebSocket
本篇的主线 上一篇介绍Spring实现的最简单的STOMP的一种模式，通过@SendTo注解，将消息发送到指定消息代理，只要是订阅过该消息代理的客户端，都会收到这个消息。作为系列的第三篇，我会分三次来详细介绍实现细节，本篇将由@SendTo和@SendToUser开始，深入Spring的WebSocket消息发送关键代码进行讲解。为下一篇点对点消息的讲解铺路。
本篇适合的读者 想要了解STOMP协议，Spring内部代码细节，以及如何使用Springboot搭建WebSocket服务的同学。
前方高能预警 本篇的代码相对较多，我会尽量细致讲解。
神奇的@SendTo和@SendToUser 本篇我们将详细介绍这两个注解背后的故事。
@SendTo 上一篇中，我们利用@SendTo注解，使方法的返回值推送到消息代理器中，由消息代理器广播到订阅路径中去。但并没有详细的介绍消息是怎样被Spring框架处理，最后发送广播出去的。先放上上节中的关键代码：
@MessageMapping("/hello") //使用MessageMapping注解来标识所有发送到“/hello”这个destination的消息，都会被路由到这个方法进行处理. @SendTo("/topic/greetings") //使用SendTo注解来标识这个方法返回的结果，都会被发送到它指定的destination，“/topic/greetings”. //传入的参数Message为客户端发送过来的消息，是自动绑定的。 public Greeting greeting(HelloMessage message) throws Exception { Thread.sleep(1000); // 模拟处理延时 return new Greeting("Hello, " + HtmlUtils.htmlEscape(message.getName()) + "!"); //根据传入的信息，返回一个欢迎消息. } } 上面方法中的返回值，会被广播到/topic/greetings这个订阅路径中，只要客户端订阅了这个路径，都会接收到消息。Spring处理消息的主要类是SimpleBrokerMessageHandler, 当需要发送广播消息时，最终会调用其中的sendMessageToSubscribers()方法：
方法内部会循环调用当前所有订阅此Broker的客户端Session，然后逐个发送消息。这里，入参destination就是Broker的地址，而message，就是我们返回信息的封装，其他细节这里就不展开讲了。
那么如果我只是想用WebSocket向服务器发出查询请求，然后服务器你就把查询结果给我就行了，其他用户就不用你广播推送了，简单点，就是我请求，你就推送给我。这又该怎么办呢？是的，@SendToUser就能解决这个问题。
@SendToUser 先上代码片段：
@MessageMapping("/hello") //使用MessageMapping注解来标识所有发送到“/hello”这个destination的消息，都会被路由到这个方法进行处理. @SendToUser("/topic/greetings") //使用SendToUser注解来标识这个方法返回的结果，都会被发送到请求它的用户的destination. //传入的参数Message为客户端发送过来的消息，是自动绑定的。 public Greeting greeting(HelloMessage message) throws Exception { Thread.sleep(1000); // 模拟处理延时 return new Greeting("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07ccab6945f9040559d9f555c45683f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/381/">«</a>
	<span class="pagination__item pagination__item--current">382/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/383/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>