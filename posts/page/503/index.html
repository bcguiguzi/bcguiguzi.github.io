<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd39d64ee2e38c6bbd837127491a0c5/" rel="bookmark">
			人体艺术之时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;embed wmode="transparent" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf" quality="high" bgcolor="#ffffff" width="160" height="70" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"&gt; 放到html中即可看到人体艺术之时钟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22439952c6e232e23bd838f0723a2f4a/" rel="bookmark">
			Windows8下使用Oracle10G的忧伤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 虽然XP的时代已经慢慢的成为历史，但是公司的计算机配置只允许运行XP系统，使用的是Oracle10G版本.家里自己的电脑环境是Win8X64,为了在家里有时候调试程序和学习，也要安装Oracle10G32位，但是悲剧的就在这里。 遇到的难题： 1.win8X64位系统安装oracle10G32位真的很难成功；尽管如此，按照兼容模式和管理员的权限终于安装成功了。 2.部署项目中的webservice程序，在win8下IIS是集成的，安装后可以发布，但是连接不上我的数据库oracle，虽然plsql是可以连接的，但试了很多方法，程序没有结果。 总之，这样面临的问题就是在家里我是不能随意的修改或者整理我的工作的。 解决方案： 1.可以将我的家里的电脑换成win7或者xp系统，这样可以保持一直的环境。 2.虚拟机。 我的选择是虚拟机：在电脑上安装虚拟机，虚拟机里面跑xp系统，将xp当作是服务器使用。 具体： 虚拟机的版本VMwareworkstation-v9.0.1 xp系统deepin_2013_05xp_cd.iso
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010a6ac01835d92c65208351ab5ab81e/" rel="bookmark">
			SVN的使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载地址：http://subversion.apache.org/packages.html
博文参考地址：http://www.cnblogs.com/xiaobaihome/archive/2012/03/20/2407610.html 简介如下： SVN分为服务端和客户端程序两种，顾名思义，服务端软件安装在服务器上，比如我的服务器是Windows Server 2003 R2 X64,下载安装的是VisualSVN-Server-2.6.5.msi ，下载了安装即可。根据上述引用的博客地址(二)可以进行SVN的设置，新建项目，配置用户和组，设置权限后，服务端即可以了。 客服端，我的是XP系统，安装的是TortoiseSVN-1.8.2.24708-win32-svn-1.8.3.msi和LanguagePack_1.8.2.24708-win32-zh_CN.msi，我用的是c#开发，还安装了VisualSVN-3.5.3.msi安装包。 根据服务器上设置的用户，导入自己的项目作为第一个版本即可。 此处，需要注意SVN的地址，有的是IP地址有的是主机名的地址，这些在服务器上都是可以修改配置的。 按照以上的步骤，就可以进行程序版本的管理与控制了。 对于软件的使用，本来不想写这篇博文的，主要是上次服务器崩溃后，重新安装服务端SVN时，误以为在服务端配置和设置第一个版本，花费了我很多时间，擦，记录一下！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3486c504eb3bf99378230e800d6424/" rel="bookmark">
			重装windows server 2003 R2 X64服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务器配置： IBM X3650; Windows Server 2003 R2 X64企业版 故事背景： 昨下午，同事有人在隔壁讨论问题，很激情，讲服务器的电源碰了一下下，直接关机了，当时我们正在使用服务器Oracle等功能。此为背景，但是很快恢复了电源，数据库连接也可以，哥们就没有在意。今早，起来上班，第一件事情，先看看数据库能不能连接上(不然老大又会提醒我服务器坏了),试着连接了一下，pl/sql连接超时。擦，请同事试了试，还是不行，后来远程连接服务器，连接不上；ping服务器也是失败；重启服务器几次，没有反应，MD，服务器又蹦了。 重装过程： 服务器连接上显示器，键盘，鼠标，坐在地上，试着看看启动的错误，BIOS is not installed! &lt;Ctrl&gt;&lt;A&gt;之后进入配置界面，看到没有读出硬盘。 分析原因： 系统有问题或者是硬盘出现了问题，应该是系统有问题了。打算重装系统。 服务器重装的步骤： 1.找到IBM X3650 的SERVERGUIAD光盘，重启服务器，进入光盘配置。 2.根据SERVERGUIAD光盘的指示，选择语言，时区，配置时间等。之后进入到关键一步，清除数据创建RAID阵列。当看到RAID1 BAD时，终于明白了，系统出现了问题。RAID1是将我们服务器硬盘500G*2合并在一起的，RAID大概就是指的这个意思。 3.我们选择重新配置此RAID，之后的大多是默认设置。 4.一直都是按照操作界面的提示，选择系统盘CD1，CD2，因此不用担心不懂什么时候安装什么东西。 一直最后安装完成。 注意事项： 1.服务器的安装是以SERVERGUIAD光盘为引导，根据提示信息安装系统，不要自行重启和换盘； 2.SERVERGUIAD安装步骤中，设置系统分区大小后，最后重启可能见不到其他盘符，需要在电脑管理&gt;磁盘管理&gt;新加设置扩展区； 最后记得设置的服务器登陆密码，不然就悲剧了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d14a4a164d635565b8abbe18cf4dbf9/" rel="bookmark">
			10款无限滚动自动翻页jquery插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无限滚动自动翻页可以说是web2.0时代的一项堪称伟大的技术，它让我们在浏览页面的时候只需要把滚动条拉到网页底部就能自动显示下一页的 结果，改变了一直以来只能通过点击下一页来翻页这种常规做法。无限滚动自动翻页技术的鼻祖是微博的先驱：推特(twitter)，后来必应图片搜索、谷歌 图片搜索、google reader等纷纷抄袭了这一项技术，于是靠滚动浏览器滚动条来翻页的技术慢慢在互联网上遍站开花。
要在自家的网站上实现自动翻页的功能并不复杂，twitter面向开发者提供了相关的api，而且已经有人开发了相关的jquery插件，让我们可以事半功倍，下面老k为你列举一下这些无限滚动jquery插件。
1、jquery ScrollPagination
这是一款由国外jquery爱好者出于学习目的开发的自动分页插件，你可以把它应用在任何地方。
2、Screw
可以实现当用户滚动网页时加载html，避免一次性加载一个大页面，这样可以减轻宽带的负担，加快访问速度。当然它也可以实现当用户滚动滚动条到网页底部的时候自动翻页。
3、Autobrowse
通过ajax实现当用户滚动时自动加载页面内容，同时可以把内容写入到到浏览器缓存。使用很简单，只需要在html容器(例如：div)中使用autobrowse属性就可以实现了。
4、Scroll Extend Plugin
设计用来自动加载页面底部以下的内容，是通过将内容appendTo来某个dom来实现的，当滚动超出这个dom后自动加载页面内容。作者的初衷是用来集成到wordpress的。
5、Infinite Scroll Plugin
也是一款不错的无限滚动jquery插件。效果和dzone的一样。
6、Endless Scroll jQuery Plugin
比较轻巧，完成任务10次的自动加载后自动停止滚动加载。
7、Load Content While Scrolling With jQuery
内容自动加载插件，有助于加快页面初始加载速度，用户将只加载他们所看到的内容。
8、Infinite Ajax Scroll
结合jquery的ease.实现的滚动无刷新自动分页。
9、Infinite Scrolling jQuery Plugin
尤其适用于博客文章的一款自动分页插件，像twitter、fackbook实现的那样。
10、Unlimited Scroll using the Twitter API
一款基于twitter的api实现的滚动分页jquery插件，正如本文开头说的那样，twitter提供了滚动浏览器滚动条到网页底部时自动分页的实现接口，而这款正是一个很好的实现例子。不过国内的用户建议不要使用，因为我们是访问不了twitter的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42b1a3bdaccd5daacdf96df9b41e552/" rel="bookmark">
			项目管理交流分享~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 清晖项目管理南京中心，7月16日举办一页纸项目管理-OPPM大型交流讲座，在软件大道华通科技园一楼圆满举办。本次讲座吸引了来自南京知名软件行业的项目经理们，国家重点科研单位部门总监，国家航运单位物流部同仁，知名外企IT经理人，等等。
今天的天气也格外的给力，金风送爽。中午1点已有很多学员陆续到场，有秩序进行签到，领取资料和笔，清晖的工作人员非常贴心的提供了茶水哦。 很多学员签到之后已安奈不住学习的热情，现场与Frank老师进行交流。
活动1点40分准时开始，frank幽默风趣的开场白，让学员笑声不断，正式进入分享环节， 1、OPPM在项目管理中的地位：项目章程、WBS、活动、OPPM之间的关系。 2、项目管理报告中应该有的内容：项目管理有哪些部分如期进行？…项目每个主要任务是由谁负责？…项目预算执行绩效等。 3、一页纸报告格式。 4、一页纸报告的威力。 5、项目失败的原因以及各占比例。 6、项目沟通的4R原则。 7、一页纸项目管理的来源。 8、一页纸报告包含的内容：5大元素、12大步骤。 9、PDCA环（戴明环）：目标→计划→实施→检查→处理→目标。 10、STEPS法：See←→Think←→Experment←→Prove←→Sustain←→See。 11、OPPM可以解答我们遇到的那些问题：是否与公司策略一致、是否与年度作业计划关联、资金预算的追踪等。 12、OPPM可以达到的PMO的目标（8大目标）：项目仪表板、项目公关、公司项目方法论、项目优先级等。 13、如何制作OPPM报告。 14、OPPM的基因：任务、目标、时间先计划VS绩效、成本预算VS实际、负责人等。 15、制作OPPM的步骤详解：十二大步骤。 16、填写OPPM注意事项。 17、阅读OPPM报告的顺序。 18、OPPM的沟通体系架构。 19、如何有效的推动OPPM。 20、从OPPM报告中可获取的内容。 讲座期间，frank抛砖引玉，让学员大部分都参与了互动，场面其乐融融，甚至有学员现场表示，讲的非常务实，希望后续能继续参加类似学习，获益良多(讲座反馈表体现)。
一般的讲座到此会以感谢词致以收尾，但是清晖公司希望给到参训者更多更多的知识和机会，现场有企业要求报名参加清晖PMP培训考试，将我们的活动提到了高潮部分的抽奖环节，最总一等奖大奖， 现场80余名专业人士，到底花落谁家的呢? 不过值得透露的是她已经报名参加9月份的PMP学习。其余二等奖和三等奖也都陆续揭晓了。
我们感受到学员们的意犹未尽，也感觉到作为美国PMI授权专业培训机构应该给更多需要项目管理的人士提供更多的机会和更有价值的学习。清晖南京地区将继续举办讲座沙龙，欢迎大家关注，清晖PMP南京中心微博，或www.changeway.com.cn 感谢参与此活动的所有项目管理人士，清晖将是你们成功事业的助力器，推动你项目管理事业的发展。
12月份南京培训时间安排： 10月13日、11月9、10、23、24、30日，12月1日 周末7天班 咨询电话：025-87718896 13585196825 qq：2675911482 蔡兰
PMP考试时间：12月7日 PMP网上英文报名时间：8月10日-10月15日 PMP网上中文报名时间：10月8日-10月23日 PMP培训费：限时特惠3400元，原价3700元，8月31日之前。
PMP考试费：3300元（全国统一费用，交给发证机构美国PMI） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb30cd9ffbeb63365ab7872d9c805af7/" rel="bookmark">
			算法导论 4.2-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 题目 利用递归树来找出递归式T(n)=T(n-a)+T(a)+cn的渐近紧确解，其中a&gt;=1且c&gt;0是常数。
2 分析与解答 画出递归树：
从递归树可以得到：
递归树的高度为⌊ n/a ⌋ ;深度为i的结点的代价总和为T(a)+c(n-ia) 忽略上下取整，可得T(n)=∑i=0n/a(T(a)+c(n-ia))=(n/a+1)T(a)+(cn2+acn)/2a=Θ (n2);
用替换法证明，首先证明T(n)=O(n2)：
若渐近上界存在，可得T(n) &lt;= c0 (n-a)2 + T(a) + cn =c0 n2 - (2ac0 n - ac0 2 - T(a) - cn)；
显然当c0 &gt;= c/a时，2ac0 n - ac0 2 - T(a) - cn &gt;= cn - ac0 2 - T(a);
此时，只需n &gt;= (ac0 2 + T(a))/c，就可令(2ac0 n - ac0 2 - T(a) - cn) &gt;=0;
那么，当满足上述条件时，显然T(n) &lt;= c0 n2，即T(n)=O(n2)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb30cd9ffbeb63365ab7872d9c805af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a460380c49251c9b4f7c33f31bd69f7c/" rel="bookmark">
			TCP的核心系列 — 重传队列的更新和时延的采样（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重传队列实际上就是发送队列(sk-&gt;sk_write_queue)，保存着发送且未确认的数据段。
当有新的数据段被确认时，需要把这些段从重传队列中删除，同时更新一些变量，包括
packets_out、sacked_out、lost_out、retrans_out等。
对于非重复的ACK，会进行RTT采样，用于更新srtt和rto等时延信息。
本文主要内容：tcp_clean_rtx_queue()的实现。
内核版本：3.2.12
Author：zhangskd @ csdn
函数实现 Q：什么是重传队列？
A：重传队列实际上就是发送队列(sk-&gt;sk_write_queue)，保存着发送且未确认的数据段。
The retransmit queue is implemented using a linked list to hold all the packets currently in
flight to the receiver. Q：tcp_clean_rtx_queue()是干什么的？
A：tcp_clean_rtx_queue() is called to remove and free the acknowledged packets from the
retransmit queue, and packets_out is decremented by the number of freed packets.
/* Remove acknowledged frames from the retransmission queue.* If our packet is before the ack sequence we can discard it as it's confirmed to* have arrived at the other end.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a460380c49251c9b4f7c33f31bd69f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259b7b03dcc6bbb6de8d2f6c8a540232/" rel="bookmark">
			电影挖掘机 搜索各大视频网站API接口 自动搜索全网所有电影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 电影挖掘机是一款通过搜索各大视频网站API接口，自动搜索全网所有电影、电视剧、综艺、动漫等，只要输入正确视频名称，或者模糊视频名称即可，使用简单，搜索结果双击列表即可播放；并且还支持手机格式电影下载、高清视频下载等挖掘。 功能特点： 1：一键搜索全网视频、电影、电视剧、综艺、动漫等；拥有庞大的视频内容；2：一键挖掘手机电影下载；3：一键挖掘高清视频下载；4：使用多线程搜索，不卡机，不占CPU；5：最新最快最全的电影深层挖掘技术，挖掘出您想看的一切； API接口公布： 在线播放API接口：双城影视、乐视网、奇艺网、我乐网、搜狐网、土豆网、PPS网、M1905电影网、迅雷网、酷6网、PPTV网、优酷网、迅播网；还在陆续增加中；高清视频API接口：电影天堂、飘花资源、放放电影；手机电影API接口：3G生活网。
下载地址：http://www.pipipan.com/file/26871135 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085b5664cb1ef2ea8577d3ddd87bb860/" rel="bookmark">
			Blackhat EU 2013 黑客大会（Full Schedule for Black Hat USA 2013）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大会文档下载：https://www.blackhat.com/eu-13/archives.html
此次BH EU 议题整体较水，涉及系统安全、移动安全、网络传输安全、WEB安全、游戏安全等。下面随便挑几个议题简单介绍下，有些议题不是很感兴趣，有些也特水，有兴趣的自己到上面链接下载文档。
1、《A PERFECT CRIME? ONLY TIME WILL TELL》
讲述SSL攻击方法——CRIME，如何从SSL加密的会话中获取到cookie，CRIME原理就是通过在受害者的浏览器中运行JavaScript代 码并同时监听HTTPS传输数据，进而解密会话Cookie，也算是中间人攻击MIMT的一种方法。该议题对CRIME方法进行扩展，介绍一种叫 TIME (Timing Info-leak MadeEasy)的攻击手法，基于传输时间来猜测payload size，然后逐字猜解 cookie。
2、《ADVANCED HEAP MANIPULATION IN WINDOWS 8》
介绍常堆及内核溢出利用技巧，以及在win8上改进后的内存安全保护机制。里面构造堆内存布局的exploit技巧，与以往利用信息泄露获取dll基址来 绕过ASLR方法有些类似，都通过分配特定大小的堆块，然后释放出与造成溢出的堆块大小相同的堆块，触发漏洞后覆盖到特定结构。同时，介绍了内核中的堆块 分配与释放的原理，然后讲述不同大小的堆块溢出后，如何构造相应的堆布局来实现利用。最后，以windows object内核漏洞为例，讲述 win7\win8上的exploit技巧，在wihte paper中已给出相应的exploit代码。
3、《THE DEPUTIES ARE STILL CONFUSED》
总之，这议题很水，爱看不看。主要讲CSRF和点击劫持clickjacking的攻击技巧，里面也提到前段时间facebook爆出的OAuth2认证 漏洞，点击劫持就讲下beef的clickjacking模块，然后提下防御点击劫持的x-frame-options，
4、《Hacking Appliances: Ironic exploits in security products》
初看这标题，还以为是讲客户端软件漏洞利用呢，其实主要还是讲WEB安全的多一些，觉得有点水。
5、《HACKING VIDEO CONFERENCING SYSTEMS》
比较有趣的一个议题，主要讲述如何攻击语音会议系统，介绍了root提权以及远程调试的一些技巧，最后演示了一个后门shell。对这些不是很了解，有兴趣的自己看文档。
6、《Hardening your Windows 8 apps for the Windows Store》
很水，不解释
7、《Harnessing GP²Us Building Better Browser Based Botnets》
觉得这议题有点在玩概念，实际攻击场景或者实战的东西很少，太理论化了。GPU现在很多被用在暴力破解方面，比如跑MD5、跑WPA-PSK，速度比 CPU快得N多，比五速鞋还五速鞋……该议题主要讲构造基于浏览器的僵尸网络botnet，利用WEB漏洞（如XSS，并提到利用html5的WEB存储 特性、插件等等方法实现永久XSS）来执行代码，再用GPU跑数据，然后利用C&amp;C服务器进行通讯。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085b5664cb1ef2ea8577d3ddd87bb860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c21187a14d0926bd907317c64d7b86/" rel="bookmark">
			Git 初步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些常用的git命令 git init 初始化项目所在目录，初始化后，会在当前目录下出现一个名为.git的目录
git add &lt;filename&gt; 对某文件开始跟踪，即把目标文件快照放入暂存区
git commit –m ‘initial project’ 将修改提交，文件从暂存区（staged area）送到HEAD
git clone username@host:/path/to/repository 例如:git clone https://github.com/GinSmile/first_test_rep 会在当前目录下创建一个名为first_test_rep的目录，里面存放所有所有项目文件
git clone username@host:/path/to/repository customname 例如：https://github.com/GinSmile/first_test_rep myFirstRep 会在当前目录下创建一个名为myFirstRep 的目录，里面存放所有所有项目文件
git status 检查当前文件的状态
文件.gitignore用于忽略某些文件
git diff 比较已暂存（staged area）和尚未暂存的文件（即实际工作目录中的最新文件），仅显示还没有暂存起来的改动
git diff –cached 比较已经暂存（staged area）起来的文件和上次提交时的快照（HEAD）
git commit -a命令，把所有已跟踪的文件commit到HEAD
$ git status # On branch master # # Changes not staged for commit: # # modified: benchmarks.rb # $ git commit -a -m 'added new benchmarks'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c21187a14d0926bd907317c64d7b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a71b9890b898f823c9a3fca2e1c9bde/" rel="bookmark">
			VS2010中如何查看DLL的导出接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看《VC++动态链接库(DLL)编程深入浅出》时，里面提到使用Visual C++的Depends工具可以查看动态链接库中的导出接口。对于VC6.0，VC所带的Depends软件，在VC6安装目录下的tools文件夹里面，可以直接运行。但是VS2010中没有了Depends工具，如何查看DLL文件的导出接口呢？　解决方法：（方法来源） 1. 打开命令行窗口 2. 运行vcvarsall.bat VS2010里vcvarsall.bat是在D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC目录下，运行方法是直接将vcvarsall.bat文件拖入命令行窗口，然后回车。（拖入相当于在命令行中输入“D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\vcvarsall.bat”） 运行vcvarsall.bat后，窗口中出现“Setting environment for using Microsoft Visual Studio 2010 x86 tools.” 3. 在命令行了输命令：dumpbin /exports dll文件完整路径，即可得到DLL的接口。 如要查看user32.dll的接口，输入：dumpbin /exports “C:\Windows\System32\user32.dll”　回车即可。 其中，步骤2可以省去，方法是不在运行中打开命令行窗口，而是在应用程序Microsoft Visual Studio 2010的Visual Studio Tools文件夹中打开Visual Studio Command Prompt (2010)命令窗口，可发现窗口中直接有“Setting environment for using Microsoft Visual Studio 2010 x86 tools”这句话，此时，直接输入命令：dumpbin /exports dll文件完整路径，即可得到DLL的接口。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea8d17c77164d951c7981d5eb2a186c/" rel="bookmark">
			[MTK]如何默认打开user debug 选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Description] 如何默认打开user debug 选项 [Keyword] user debug root [Solution] 1. 在android 4.0 之前，这个设置是在frameworks/base/service/..../SystemServer.java 里面设置会根据system property 的persist.service.adb.enable 来设置。您可以看到类似如代码： // make sure the ADB_ENABLED setting value matches the secure property value Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, "1".equals(SystemProperties.get("persist.service.adb.enable")) ? 1 : 0); // register observer to listen for settings changes mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED), false, new AdbSettingsObserver()); 而这个persist.service.adb.enable 默认是放在在default.prop 中，在编译的时候在build/core/main.mk 中确认, ifeq (true,$(strip $(enable_target_debugging))) # Target is more debuggable and adbd is on by default ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 persist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea8d17c77164d951c7981d5eb2a186c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccbc213b975c9a009997f9d08d41f92/" rel="bookmark">
			vs2010 directX winnt.h错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1&gt;正在编译... 1&gt;stdafx.cpp 1&gt;E:\VS2005\VC\PlatformSDK\include\winnt.h(222) : error C2146: 语法错误 : 缺少“;”(在标识符“PVOID64”的前面) 1&gt;E:\VS2005\VC\PlatformSDK\include\winnt.h(222) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int 1&gt;E:\VS2005\VC\PlatformSDK\include\winnt.h(5940) : error C2146: 语法错误 : 缺少“;”(在标识符“Buffer”的前面) 1&gt;E:\VS2005\VC\PlatformSDK\include\winnt.h(5940) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int 1&gt;E:\VS2005\VC\PlatformSDK\include\winnt.h(5940) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int 问题补充：我的编译环境为visual studio 2005 SP1（由于在vista下，所以还打了vs2005 for vista的补丁）。 打开winnt.h文件，发现问题就是在winnt.h头文件中无POINTER_64的定义造成的。搜索vc下的头文件，发现在basetsd.h头文件中有POINTER_64的定义，而在winnt.h头文件中也包含了该头文件。于是直接把basetsd.h头文件中关于POINTER_64的宏定义（#define POINTER_64 __ptr64）抄过来，放在 typedef void *PVOID; typedef void * POINTER_64 PVOID64; 这两句的前面，再编译就无该问题了。 虽然如此解决了编译问题，但总觉得不妥，于是又在网上搜了一下。发现也有人跟我一样的解决，但在microsoft的论坛上发现问题其实是头文件搜索顺序引起的。由于我安装了dxsdk9，dxsdk9的头文件搜索顺序在platformsdk之前。而在dxsdk9中也有basetsd.h头文件，而该文件无POINTER_64的定义，因此编译通不过。
调整头文件搜索顺序后，编译就无问题了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ccbc213b975c9a009997f9d08d41f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7606ad8493cab96a33880e4e4f1c4ae/" rel="bookmark">
			机器学习十大算法的每个算法的核心思想、工作原理、适用情况及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述机器学习十大算法的每个算法的核心思想、工作原理、适用情况及优缺点等。
1）C4.5算法：
ID3算法是以信息论为基础，以信息熵和信息增益度为衡量标准，从而实现对数据的归纳分类。ID3算法计算每个属性的信息增益，并选取具有最高增益的属性作为给定的测试属性。
C4.5算法核心思想是ID3算法，是ID3算法的改进，改进方面有：
1）用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；
2）在树构造过程中进行剪枝
3）能处理非离散的数据
4）能处理不完整的数据
C4.5算法优点：产生的分类规则易于理解，准确率较高。
缺点：
1)在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。
2)C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。
2）K means 算法：
是一个简单的聚类算法，把n的对象根据他们的属性分为k个分割，k&lt; n。 算法的核心就是要优化失真函数J,使其收敛到局部最小值但不是全局最小值。
其中N为样本数，K是簇数，rnk b表示n属于第k个簇，uk 是第k个中心点的值。然后求出最优的uk
优点：算法速度很快
缺点是，分组的数目k是一个输入参数，不合适的k可能返回较差的结果。
3）朴素贝叶斯算法：
朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。算法的基础是概率问题，分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。朴素贝叶斯假设是约束性很强的假设，假设特征条件独立，但朴素贝叶斯算法简单，快速，具有较小的出错率。
在朴素贝叶斯的应用中，主要研究了电子邮件过滤以及文本分类研究。
4)K最近邻分类算法（KNN）
分类思想比较简单，从训练样本中找出K个与其最相近的样本，然后看这k个样本中哪个类别的样本多，则待判定的值（或说抽样）就属于这个类别。
缺点：
1）K值需要预先设定，而不能自适应
2）当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。
该算法适用于对样本容量比较大的类域进行自动分类。
5)EM最大期望算法
EM算法是基于模型的聚类方法，是在概率模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量。E步估计隐含变量，M步估计其他参数，交替将极值推向最大。
EM算法比K-means算法计算复杂，收敛也较慢，不适于大规模数据集和高维数据，但比K-means算法计算结果稳定、准确。EM经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。
6）PageRank算法
是google的页面排序算法，是基于从许多优质的网页链接过来的网页，必定还是优质网页的回归关系，来判定所有网页的重要性。（也就是说，一个人有着越多牛X朋友的人，他是牛X的概率就越大。）
优点：
完全独立于查询，只依赖于网页链接结构，可以离线计算。
缺点：
1）PageRank算法忽略了网页搜索的时效性。
2）旧网页排序很高，存在时间长，积累了大量的in-links，拥有最新资讯的新网页排名却很低，因为它们几乎没有in-links。
7)AdaBoost
Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。
整个过程如下所示：
1. 先通过对N个训练样本的学习得到第一个弱分类器；
2. 将分错的样本和其他的新数据一起构成一个新的N个的训练样本，通过对这个样本的学习得到第二个弱分类器；
3. 将和都分错了的样本加上其他的新样本构成另一个新的N个的训练样本，通过对这个样本的学习得到第三个弱分类器；
4. 如此反复，最终得到经过提升的强分类器。
目前AdaBoost算法广泛的应用于人脸检测、目标识别等领域。
8）Apriori算法
Apriori算法是一种挖掘关联规则的算法，用于挖掘其内含的、未知的却又实际存在的数据关系，其核心是基于两阶段频集思想的递推算法 。
Apriori算法分为两个阶段：
1）寻找频繁项集
2）由频繁项集找关联规则
算法缺点：
1） 在每一步产生侯选项目集时循环产生的组合过多，没有排除不应该参与组合的元素；
2） 每次计算项集的支持度时，都对数据库中 的全部记录进行了一遍扫描比较，需要很大的I/O负载。
9）SVM支持向量机
支持向量机是一种基于分类边界的方法。其基本原理是（以二维数据为例）：如果训练数据分布在二维平面上的点，它们按照其分类聚集在不同的区域。基于分类边界的分类算法的目标是，通过训练，找到这些分类之间的边界（直线的――称为线性划分，曲线的――称为非线性划分）。对于多维数据（如N维），可以将它们视为N维空间中的点，而分类边界就是N维空间中的面，称为超面（超面比N维空间少一维）。线性分类器使用超平面类型的边界，非线性分类器使用超曲面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7606ad8493cab96a33880e4e4f1c4ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feac02d2fa05defb15db5c752e7e6c2e/" rel="bookmark">
			函数式思维: 为什么函数式编程越来越受关注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： Java™ 即使不打算立刻改用函数式语言（比如 Scala 或 Clojure），Java 开发人员也应该了解函数式范式。随着时间的推移，所有主流语言都将变得更加函数化；Neal Ford 将在本期文章中探讨其中的原因。
关于本系列 本系列的目标是重新调整您对函数式思维的认识，帮助您以全新的方式思考常见问题，并寻找提升您的日常编码能力的方法。本系列文章将探讨函数编程概念、允许在 Java 语言中进行函数编程的框架、在 JVM 上运行的函数编程语言，以及语言设计的未来方向。本系列文章面向那些了解 Java 及其抽象工作原理，但对函数式语言不甚了解的开发人员。
到目前为止，在本系列的每期文章中，我都说明了为什么理解函数式编程非常重要。但是，有些原因是在多期文章中进行说明的，只有在综合思路的更大背景中，才可以完全了解这些原因。在本期文章中，我会探讨函数式编程方兴未艾的所有原因，并综合前几期文章中的一些个人经验教训。
在计算机科学短短的发展历史中，技术的主流有时会产生分支，包括实用分支和学术分支。20 世纪 90 年代的 4GL（第四代语言）是一个实用分支，而函数式编程是来自学术界的一个示例。每隔一段时间，都会有一些分支加入主流，函数式编程目前也是这种情况。函数式语言不仅在 JVM 上刚刚崭露头脚（其中两个最有趣的新语言是 Scala 和 Clojure），在 .NET 平台上也是才开始得到应用，在 .NET 平台上，F# 是头等公民。为什么所有平台都如此欢迎函数式编程？答案是，随着时间的推移，随着运行时都要能够处理更多的繁忙工作，开发人员已经能够将日常任务的更多控制权割让给它们。
割让控制权
在 20 世纪 80 年代初，在我上大学的时候，我们使用一个被称为 Pecan Pascal 的开发环境。其独特的特性是，相同的 Pascal 代码可以在 Apple II 或 IBM PC 上运行。Pecan 工程师使用某个称为 “字节码” 的神秘东西实现了这一壮举。开发人员将 Pascal 代码编译为 “字节码”，它可以在每个平台本地编写的 “虚拟机” 上运行。这是一个可怕的体验！所生成的代码慢得让人痛苦，甚至简单的类赋值也非常缓慢。当时的硬件还没有准备好迎接这个挑战。
在发布 Pecan Pascal 之后的十年，Sun 发布了 Java，Java 使用了相同的架构，对于 20 世纪 90 年代中期的硬件环境，运行该代码显得有些紧张，但最终取得了成功。Java 还增加了其他开发人员友好的特性，如自动垃圾收集。使用过像 C++ 这样的语言之后，我再也不想在没有垃圾收集的语言中编写代码。我宁愿花将时间花在更高层次上的抽象上，思考解决复杂业务问题的方法，也不愿意在内存管理等复杂的管道问题上浪费时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feac02d2fa05defb15db5c752e7e6c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3de813a736f6b9c98b269c052adede/" rel="bookmark">
			帮妹子修电脑最装逼的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 帮美女修电脑，第一步一定要打开命令行界面，然后输入cd回车，dir/w/s回车，看着满屏字符跑完，轻轻地说一句，我已经知道问题是什么了…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053966cea8a04ded580eff6142f6721f/" rel="bookmark">
			基类与派生类对象和指针赋值的小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基类指针和派生类指针指向基类对象和派生类对象的4中方法：
1. 基类指针指向基类对象，只需要通过基类指针简单地调用基类的功能。
2. 派生类指针指向派生类对象，只需要通过派生类指针简单地调用派生类功能。
3. 基类指针指向派生类对象，安全，实现多态的语言基础。
但是要注意的是，这个指针只能用来调用基类的成员函数，如果试图通过基类指针调用派生类才有的成员函数，则编译器会报错。
为了避免这种错误，较为符合规范的做法是通过RTTI中的dynamic_cast关键字将确定指向派生类对象的基类指针转换为派生类指针，然后派生类指针可以用来调用派生类的功能，称为向下类型转换。
4. 将派生类指针指向基类对象，会产生运行时问题。
经测试，在GCC中，可以通过强制转换，使一个派生类指针强制指向基类对象，而且该指针可以正确调用基类的所有成员。但是通过该指针还可以在代码中调用该对象实际不存在的派生类独有成员，并且可以编译通过，但是在运行过程中将会产生Segmentation fault。 故此种不合规范的转换，在使用时应当避免。
另：当将一个派生类对象赋值给一个基类对象时，将会产生所谓的切割，即将派生类中的基类部分赋值给该基类对象。
派生类对象可以当做基类对象，这是因为派生类包含基类的所有成员(里氏替代原则)。基类对象无法被当做成派生类对象，因为派生类可能具有只有派生类才有的成员。
参考文章：http://blog.csdn.net/feitianxuxue/article/details/7326402
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323736547daf5fb54c444a41df03b2e1/" rel="bookmark">
			Visual Studio属性配置中使用宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习C语言的时候，我们曾经遇到过一个宏的概念。宏的作用机理本质上是宏的展开，C语言中的宏的用法也有很多种（水其实很深...），不过从感觉上来讲，人们大致上会在以下的场景中，利用宏来解决一些窘境：一是为了避免重复书写同样性质代码时，会使用到宏；二是为了定义一些常量参数时，会使用到宏。另外，宏的意义也在于，当我们修改某个宏的定义时，便修改了所有引用宏的地方所展开的代码，这无疑节省了我们修改代码的工作量以及代码修改的灵活性。
在Visual Studio中进行C++工程属性的配置时，同样也会遇到与写代码类似的场景，例如我们可能会在不同的表单（同一个工程或者多个工程）中，填写相同的内容（例如某个路径）。这样就造成了一些重复性的劳动，而且填写时可能因为疏忽而造成错误，修改时也需要找到所有填写这个内容的地方。为了解决这个问题，Visual Studio在工程属性配置时，也提供了宏这样一个工具，来帮助我们减少这些无谓的辛劳。
C++工程属性中的宏
工程属性中的宏具体长得是什么样子呢？在打开工程属性时，我们在表单中可能经常会看到一些以美元符号（$）为开头的字符串，$(SomeMacro)。其实这些字符串便是Visual Studio中默认定义的一些宏，它们其实就是代表一些与某个工程相关的常量字符串。在下图中我们可以看到一些这样默认定义的宏：
任意点击一个表单，然后点击Edit选项，便可以在弹出的窗口中，查看这些默认定义宏的含义。
注意到上面两个宏进行结合，对项目的输出路径（Output）进行了配置，也就是项目生成exe、lib或dll的地方。Visual Studio中还有很多类似这样的宏，有些宏还是和机器相关的，所以我们也可以利用其来进行工程配置，避免因为不同机器上路径不同，而对每台机器单独配置一次属性。对工程属性中默认定义的宏，微软的官方指南上也有一个比较详细的介绍。
http://msdn.microsoft.com/en-us/library/c02as0cs.aspx
自定义工程属性中的宏
那么我们如何自己定义工程属性中的宏呢？首先我们需要打开属性管理器选项卡（Property Manager），然后为工程添加一个属性页面（Property Sheet）。该属性页面在被添加后，会被当前的工程属性继承，于是便可以使用其中定义的宏了。
以上添加了一个宏，代表使用OpenCV第三方库的版本号，因为在第三方库升级时，库的名字也会随版本号发生改变；而使用了宏后，我们就可以很方便的修改引用库的名称了。下面我们可以回到原来的工程属性当中来，利用上面的宏来动态确定引用库的名称。
我们可以看到，Linker当中所展开的命令行参数中，$(OpenCVLibVersion)已经被展开为245了。而以后在发生库版本的升级时，便可以只修改$(OpenCVLibVersion)这个宏便可以正常使用升级后的库了，所以这种方法还是很实用的吧。在工程属性的配置中，宏的使用场景还有很多，如果能够灵活使用，便可以节省很多的时间，避免很多因重复劳动所造成的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e5aaa8c2dfc225510e688aafc0e24d/" rel="bookmark">
			onvif 客户端的发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、解压：unzip -X gsoap_2.8.10.zip 编译
2、下载：
wget http://www.onvif.org/onvif/ver10/network/wsdl/remotediscovery.wsdl
3、复制：
cp gsoap-2.8/gsoap/typemap.dat .
4、在typemap.dat 中添加：
#Use gSOAP 2.8.10 and up. In the typemap.dat file used by wsdl2h, add: #	ONVIF recommended prefixes tds	= "http://www.onvif.org/ver10/device/wsdl" tev	= "http://www.onvif.org/ver10/events/wsdl" tls	= "http://www.onvif.org/ver10/display/wsdl" tmd	= "http://www.onvif.org/ver10/deviceIO/wsdl" timg	= "http://www.onvif.org/ver20/imaging/wsdl" trt	= "http://www.onvif.org/ver10/media/wsdl" tptz	= "http://www.onvif.org/ver20/ptz/wsdl" trv	= "http://www.onvif.org/ver10/receiver/wsdl" trc	= "http://www.onvif.org/ver10/recording/wsdl" tse	= "http://www.onvif.org/ver10/search/wsdl" trp	= "http://www.onvif.org/ver10/replay/wsdl" tan	= "http://www.onvif.org/ver20/analytics/wsdl" tad	= "http://www.onvif.org/ver10/analyticsdevice/wsdl" tdn	= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85e5aaa8c2dfc225510e688aafc0e24d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/502/">«</a>
	<span class="pagination__item pagination__item--current">503/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/504/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>