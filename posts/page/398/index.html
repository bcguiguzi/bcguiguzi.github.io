<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d91db8462515ad086f3d7e41635ba1/" rel="bookmark">
			动态规划经典例题汇总 （附最全题目链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结了《王道机试指南》中动态规划（Dynamic Programming）部分的所有例题以及分析思路、状态转移方程等。有助于完整复习动态规划全部内容。为避免大量代码和题干导致失去主线，本文只写思路，代码可在题目链接内的讨论区找到。
一.基本思想 与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解中得到原问题的解。
与分治法不同的是，分治法会使得有些子问题被重复计算多次。而动态规划的做法是将已解决子问题的答案保存下来，在需要子问题答案的时候便可直接获得，而不需要重复计算，节约效率。
二.经典题目 1. 递推求解问题 1.1斐波那契数列问题 （n阶楼梯上楼问题） 状态转移方程：dp[n] = dp[n-1] + dp[n-2]
2. 最大连续子序列和 2.1（一维) 最大序列和问题 设置一个数组dp[ ]，令dp[i]表示以A[i]作为末尾的连续序列的最大和。
状态转移方程：dp[i] = max{ A[i], dp[i-1] + A[i] }
解释：由于dp[i]是以A[i]作为结尾的连续序列最大和，因此只有两种情况：
最大和的连续序列只有一个元素，即A[i]本身。也就是dp[i] = A[i]。该最长子序列有多个元素，那么此时的dp[i] = dp[i-1] + A[i]。 所以取最大值即可。
2.2（二维) 最大子矩阵问题 对于二维情况，假设原二维矩阵的最大子矩阵所在的行为 i 到 j 。
当 i = j 时，则最大子矩阵为第 i 行的最大连续子序列和。（转化为一维）当 i != j 时，现在我们已经知道最大子矩阵的行，把从第 i 行到第 j 行的所有元素相加，得到一个只有一行的一维数组，则该一维数组的连续最大和就是最大子矩阵。（同样转化为一维） 3.最长递增子序列 3.1 拦截导弹 同样设置一个数组dp[ ] ，表以A[i]作为末尾的最长递增子序列的长度。
状态转移方程：dp[i] = max{ 1, dp[j] + 1 }。(当 j &lt; i &amp;&amp; A[j] &lt; A[i] 时)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16d91db8462515ad086f3d7e41635ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bc415e3d26d9184487a5db0e7fcd84/" rel="bookmark">
			【Pytorch】BCELoss和BCEWithLogitsLoss损失函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Pytorch中，BCELoss和BCEWithLogitsLoss是一组常用的二元交叉熵损失函数，常用于二分类问题，其区别在于前者的输入为已进行sigmoid处理过的值，而后者为sigmoid函数 1 1 + exp ⁡ ( − x ) \frac{1}{1+\exp(-x)} 1+exp(−x)1​中的 x x x。
下面为一个简单的示例：
import torch import torch.nn as nn predicts = torch.tensor([[0.4,0.7,1.2,0.3], [1.1,0.6,0.9,1.6]]) labels = torch.tensor([[1,0,1,0],[0,1,1,0]], dtype=torch.float) # 通过BCELoss计算sigmoid处理后的值 criterion1 = nn.BCELoss() loss1= criterion1(torch.sigmoid(predicts), labels) # 通过BCEWithLogitsLoss直接计算输入值 criterion2 = nn.BCEWithLogitsLoss() loss2 = criterion2(predicts, labels) # 会发现loss1=loss2 BCELoss和BCEWithLogitsLoss还提供了两个重要参数：
weight：可用于控制各样本的权重，常用作对对齐后的数据进行mask操作（设为0）reduction：控制损失输出模式。设为"sum"表示对样本进行求损失和；设为"mean"表示对样本进行求损失的平均值；而设为"none"表示对样本逐个求损失，输出与输入的shape一样。 此外BCEWithLogitsLoss还提供了参数pos_weight用于设置损失的class权重，用于缓解样本的不均衡问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296ff96a8841a7c2cbe4a9eace493600/" rel="bookmark">
			visio画两条直线交叉但不弯曲不跨线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置方案：Visio菜单栏 设计-》连接线-》显示跨线
设置前：
设置后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051d78b491be090f550c92d8ecb4d96a/" rel="bookmark">
			《统计学习方法》——第一章 统计学习方法概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 统计学习
统计学习就是计算机系统通过运用数据及统计方法提高系统性能得机器学习。现在人们提及得机器学习，往往是指统计机器学习。 统计学习由监督学习、非监督学习、半监督学习和强化学习等组成。
李航的《统计学习方法》以介绍统计学习方法为主，其中第2-8 章都是监督学习方法为主。
1.2 监督学习
输入/输出空间：监督学习中，输入与输出的所有可能取值的集合分别称为输入空间和输出空间。输入与输出空间可以是有限元素的集合，也可以是整个欧式空间，通常，输出空间远远小于输入空间。
例如 训练集为T ={(h1,y1),(x2,y2), ... ,(xn,yn)},该训练集有n个样本点，每个样本点由两部分组成，一个是x，一个是y；每个样本点称为实例，其中x为输入变量，y为输出变量。x可以为一个数或一个向量。 若x为一个小n维的向量， ，x属于输入空间，输出空间是每一个y属于的空间。 特征空间：每个具体的输入是一个实例，通常由特征向量表示（上述x就是一个n维的特征向量）。所有的特征向量存在的空间称为特征空间。
一般情况下，输入空间和特征空间是一样的，但特殊情况下不同。比如，我们拿到的数据为x，但我们不想只用x，想用x、x的平方，x的三次方等，那么从x扩张的三维空间就是特征空间，原来的空间是一个一维空间。 联合概率分布： 比如说我们有一个模型，有输入变量空间X=(x1,x2,...,xn) 和输出变量空间Y=(y1,y2,...,ym)，可能是离散的，可能是连续的。那么现在我们这个模型的作用就是在输入一个x的时候，能够给出一个y，也可以说我们这个模型的作用就是找到X和Y的联合概率分布P(X,Y)。那么我们就可以根据其联合概率得到条件概率，就可以得到 P(Y∣X)，于是就可以利用这个条件概率找到给定一个x的情况下，最大可能的y是哪一个。（原文链接：https://blog.csdn.net/qq_39636214/article/details/85036837）
假设空间： 假设空间中就是一个个备选模型，然后从备选模型中选一个最优模型。模型形式分为决策函数Y=f(x) 和条件概率分布P（y|x）。 f（x）输出的Y和上面观测到的y不一定是一样的，二者差别越小，说明模型越好。条件概率分布模型是一个x给出多个不同取值概率的y，这些概率的和为1。预测的y值为最大的概率值对应的y。 1.3 统计学习三要素
1.3.1 模型
，指的是函数的参数。
1.3.2 策略
以某个标准说明该模型是最优模型，策略体现在损失函数上，损失函数是对每个实例，我们的预测的和真实值之间差别的惩罚。
0-1 损失函数 该损失函数用于分类问题中；若观测值和真实值相同，则把损失视为0。反之为1。平方损失函数 该损失函数与绝对损失函数相比，对差值比较大的实例更敏感，一般用于回归问题中（x，y为连续的值）。绝对损失函数 和平方损失函数类似。对数损失函数或对数似然损失函数 ，前三个都属于决策模型，该损失函数属于条件概率模型，在决策模型中当预测值和真实值相同时，损失为0。但是在条件概率模型中，损失不可能为0。在该模型中我们给的是Y在X下的一个条件概率分布，该分布和观测值之间的损失度量就是通过一个函数实现的。 以上的损失函数是对一个具体实例进行处理，在实际情况中，一个完整的数据集包含多个实例，为整合多个实例生成的损失值，我们提出策略这一概念。
经验风险最小化（ERM）, 假设每个假设空间中的f，在每个实例中都有一个损失，共有N个实例，把N个实例上的损失求一个平均后得到的损失就是经验风险，根据这个策略找到的最优模型就是在这N个实力上经验风险最小的模型。但是，当数据集中的实例很少时，会产生过拟合现象，故提出SRM。结构风险最小化（SRM），，与ERM相比加入正则项，其中为模型的复杂度，是系数，用以权衡经验风险和模型复杂度。我们希望找一个模型复杂度相对来说比较低，但是经验风险比较小的模型（模型简单的同时拟合效果要好）。 1.3.3 算法
算法是怎样根据策略从假设空间中选取最优模型
1.4 模型评估和模型选择
1.4.1训练误差和测试误差
统计学习的目的不仅要在训练集上取得较好效果，而是也要对未知数据有很好的预测能力。当损失函数给定后，基于损失函数的模型的训练误差和模型的测试误差成了学习方法的评估标准。
训练误差：，测试误差：。为学习到的模型，训练误差就是在训练集中，该模型下的平均损失。测试误差就是在测试集中，该模型下的平均损失。
1.4.2 过拟合与模型选择
过拟合：一昧的追求对训练数据的拟合程度，导致所选择的模型的复杂度比真实模型的复杂度更高。
模型选择中不仅要考虑对已知数据的预测能力，也要考虑对未知数据的预测能力。
1.5 正则化与交叉验证（模型选择的两个方法）
采用最小化结构风险交叉验证 把训练集分为训练集和验证集，训练集用来训练模型，验证集用来模型选择，测试集用于最终对学习方法的评估。在学习到不同复杂度的模型中，选择对验证集有最小预测误差的模型。 1.6 泛化能力
泛化误差：如果学得到的模型是 ，那么用这个模型对未知数据预测的误差即为泛化误差。 泛化误差上界：对于二分类问题，当假设空间是有限个函数的集合F = {f1，f2，...，fd}时，对任意一个函数f属于F，至少以概率，以下不等式成立：
备选模型f在训练集上的经验风险加一项可以控制住在测试集中得期望风险。
1.7 生成模型和判别模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051d78b491be090f550c92d8ecb4d96a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3abfda3938908f45ff9ba77fe44ed6/" rel="bookmark">
			SQLZOO (NULL) 答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List the teachers who have NULL for their department.
SELECT name FROM teacher WHERE dept IS NULL
Note the INNER JOIN misses the teachers with no department and the departments with no teacher.
SELECT teacher.name, dept.name
FROM teacher INNER JOIN dept
ON (teacher.dept=dept.id)
Use a different JOIN so that all teachers are listed.
all teacher 很明显需要把teacher表都放进去 所以用OUTER
SELECT teacher.name,dept.name FROM teacher LEFT OUTER JOIN dept ON (teacher.dept = dept.id)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3abfda3938908f45ff9ba77fe44ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6c10ecaef69ccd8500ae59f82310da/" rel="bookmark">
			访问servlet页面出现404问题可能原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我作完一个功能 想直接在地址栏输入servletA类及参数 想测试下servlet代码
没想到报错404.但是我换了个servletB类用完全相同的方法测试成功了。
我百思不得其解，因为这两个类都是我用eclipse直接创建的servlet，web.xml都是自动配置的。就算配置错了 也应该两个都错才对啊 。想了好久突然想到刚才创建ServletA类的时候，放错到service包里了，发现后直接拖到了servlet包里，但是web.xml的配置的路径已经在service包里了
如图
而实际的类名应该是com.student.servlet.DeleteStudentServlet
简单来说 原因 就是 ：
我刚开始创建servlet的时候 放错到service包里（实际上应该放servlet包里），但是创建的时候eclipse就帮我把web.xml类名就自动配置了（配置的路径类名是com.student.service.DeleteStudentServlet）而我把把该servlet拖回Servlet包时，web.xml没有修改，导致web.xml中的路径类名错误。所以访问该Servlet时找不到正确的路径类，才会报错404.
所以servlet报错404，一定一定要检查路径名是否正确，也要检查下web.xml配置的信息是否有误。
总结：创建的Servlet放的包有变动的话 一定要到web.xml中修改配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7bc014900ef359e97cde8db0ef1a07/" rel="bookmark">
			安装pycharm打不开问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为想试试那冰雪奇缘99行代码 所以就下载了pycharm emm 中间也遇到了一些问题。有时候道理别人给你说的再多都没有 都不如自己去经历去尝试
破解后 插件的位置写的不对 导致关闭后打不开 比如我的：
-javaagent:D:\PyCharm 2019.3.3\bin\jetbrains-agent.jar
D之前没\ 卸载后第二次安装 就直接打不开 这是因为第一次卸载软件时没卸载干净 虽然我当时有这个想法 但是依旧找不到残留的，还是那次清理c盘时发现的…删除干净后就可以了（我刚开始是专业版的 因为没清理干净打不开为了应急用的社区版的 哈哈 ） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22eb7f69aa86000b8c59cd3dacf200ff/" rel="bookmark">
			亚信安全防毒墙网络版无密码卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先将此文章复制到随意一个txt或者word里,防止在安全模式下忘记操作步骤,然后将文件放入c盘
1.win+r,输入msconfig,将引导下的安全引导勾上(此方法适用于本人电脑,Windows10 1909版本)
2.点击确定,弹出系统配置框,点击重新启动进入安全模式
3.注册表设置
进入安全模式下操作注册表配置（非安全模式下，修改注册表时会提示无法修改）
在开始运行 输入框输入 regedit 进入注册表界面。
32位的寻找路径为： \HKEY_LOCAL_MACHINE\SOFTWARE\TrendMicro\PC-cillinNTCorp\CurrentVersion\Misc 下的 Allow Unistall 64位寻找路径为：
HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\TrendMicro\PC-cillinNTCorp\CurrentVersion\Misc下的Allow Unistall
右键修改 Allow Unistall 的键值由0 改为1(本人更改时直接选择16位)。
4.更改完成后,在安全模式下可以直接打开控制面板,进入程序页面,找到亚信安全防毒墙网络版,选择卸载
声明：本文参看CSDN博主「Paper-Tiger」的文章,如无法成功卸载,可参考他的文章.原文链接：https://blog.csdn.net/qq_36084506/article/details/89335449
(版权声明：本文为CSDN博主「Paper-Tiger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_36084506/article/details/89335449)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f208e9e51678ac4d615efd864cf71d09/" rel="bookmark">
			RuntimeWarning: Glyph 20108 missing from current font.   font.set_text(s, 0.0, flags=flags)解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境：MAC下eclipse的python3环境 /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 20108 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 20803 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 39640 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 26031 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 20998 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 24067 missing from current font. font.set_text(s, 0.0, flags=flags) /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/matplotlib/backends/backend_agg.py:211: RuntimeWarning: Glyph 65292 missing from current font.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f208e9e51678ac4d615efd864cf71d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac680cabbad1e073988a60be3d26647/" rel="bookmark">
			Linux无线网络管理命令(ip/iw/iwconfig/iwlist/ifconfig/wpa_supplicant) 运维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux无线网络管理命令(ip/iw/iwconfig/iwlist/ifconfig/wpa_supplicant) 运维
https://blog.csdn.net/DXCyber409/article/details/80574111
Linux无线网络管理命令(ip/iw/iwconfig/iwlist/ifconfig/wpa_supplicant)
原创DXCyber409 最后发布于2018-06-05 22:14:27 阅读数 3313 收藏
展开
前言
以下各小节的前半部分介绍无线网络相关的各种命令的背景以及适用范围。
后半部分演示常用命令搭配和相关操作。
iw命令
man手册中可以找到说明 iw - show / manipulate wireless devices and their configuration
这意味着iw既可以查看信息，又可以管理无线网络设备，还能更改配置，属于比较全能的命令。
缺点：实测对USB网卡支持性很差，几乎只适用于物理接入设备（PCI板载设备）。
常用命令列表： iw list # 查看本机支持的无线特性，such as band information (2.4 GHz, and 5 GHz), and 802.11n information
iw dev wlan0 scan # 扫描无线网络，列表的内容都是实时更新的
iw dev wlan0 link # 获取设备连接状态信息（实测不包含IP地址）
iw wlan0 info # 获取设备工作状态信息
iw event # 获取所有网络设备的工作日志信息
英文原文介绍：https://wireless.wiki.kernel.org/en/users/Documentation/iw
译文：https://blog.csdn.net/robertsong2004/article/details/40044947
ifconfig命令
ifconfig - configure a network interface 配置网络接口命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac680cabbad1e073988a60be3d26647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b608c94ace490d29ab8a59876f3a3b7/" rel="bookmark">
			element-ui中弹框dialog不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 今天在写vue项目时候，
遇见如下需求：点击编辑按钮弹出一个dialog,dialog中的表单展示当前行显示数据，然后编辑后保存。
但是我点击后，出现了遮罩层，但是dialog怎么也不显示，如图。
二、解决方案 这里是由于一个属性没有设置正确导致的问题。在el-dialog 标签内，添加如图红色矩形框内所示属性。
即可解决问题。
写法上：
可以直接写 append-to-body
也可以写成 :append-to-body=“true”
我更喜欢第一种，因为看起来更简洁。顺便补充第二种不要忘了加冒号。
正确效果：
三、文档说明 我们可以在element ui的官方文档中，找到如下说明。
=&gt;文档链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13c316ee13001d1147b0ba27f57ef98/" rel="bookmark">
			C&#43;&#43;模板类的使用细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#模板类的概念和定义
在需要定义功能相同参数类型不同的多个函数时，C++有函数模板很好的解决这一繁琐的操作，同样的当需要定义多个功能类似，而内部数据成员不同的类时，C++也提供了一种方法可以简化程序员所需要做的重复繁琐的操作，这就是类模板。
template &lt;typename T&gt; //定义好类型形式参数 class A { public: //函数的参数列表使用虚拟类型 A(T t = 0) { this-&gt;t = t; } //成员函数返回值使用虚拟类型 T &amp;getT() { return this-&gt;t; } private: //成员变量使用虚拟类型 T t; }; 如上述代码在类的函数参数列表，成员函数的返回值，成员变量处都可以使用虚拟类型代替。
#模板类对象的使用
// 当函数参数需要用到模板类参数的时候，需要在&lt;&gt;里显示指定类型 void printA(A&lt;int&gt; &amp;a) { cout &lt;&lt; a.getT() &lt;&lt; endl; } //当模板类创建对象的时候，也需要在&lt;&gt;里显示指定类型 A&lt;int&gt; a(666); 总结：当需要用到模板类对象的地方都必要要显示指定类型
类模板的继承与被继承
直接上代码
// 一个普通类，A类 class A { public: A(float a) { this-&gt;a = a; } float a; }; //当父类是普通函数，子类是模板函数时，继承格式和普通函数的继承一样 template &lt;typename B_b&gt; //模板类B类去继承普通类A类 class B : public A{ public: B(B_b b, float a) : A(a){ this-&gt;b = b; } B_b b; }; // 当父类是类模板时，子类是普通类时继承时应该显示指定类型 // C类是普通类去继承模板类B类 class C : public B&lt;int&gt;{ public:	C(char c, int b, float a) : B (b, a){ this-&gt;c = c; } char c; }; // 当父类和子类都是是类模板时，子类继承时也应该显示指定类型 // 模板类D类继承模板类 B类 template &lt;typename D_d&gt; class D : public B&lt;char&gt;{ public: D(D_d d, char b, float a) : B (b, a){ this-&gt;d = d; } D_d getD() { return d; } D_d d; }; 总结：从上面的代码可以看出，模板类其实是很呆的，在发生继承时如果要让模板类被继承，一定要显示指定出，模板类前定义好的虚拟类型到底是什么类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13c316ee13001d1147b0ba27f57ef98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d560da6845af672453c8c708a6858bb6/" rel="bookmark">
			win10磁盘使用率100%的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows10系统有一个Superfetch服务，作用是允许内存以极快的速度载入一部分常用程序运行所需的数据片段，从而提升系统和程序运行速度。官方描述表明它“随着时间的推移保持并提高系统性能”。
但在实际应用中，某电脑配8G内存+1T机械硬盘，经常出现磁盘使用率100%的情况，严重影响使用体验。
解决办法是：
一、禁用此服务 打开 Win+R 运行 services.msc
(此截图是在win7平台上的，可能与win10略有不同）
win10 后续版本中此服务改名为sysmain，禁用此服务即可。
二、加内存或换成固态硬盘
我的8G内存加成16G，这个服务不用管也解决了问题。
我家里的电脑8G内存，但是C盘是固态盘，也不存在这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a5743e2a33ed905f8934ef56d237a8/" rel="bookmark">
			连接Mysql数据库报2003的完美解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 error： solution： 打开cmd，输入services.msc 即可打开服务如下图（win10），将MySQL服务启动，重新点击所建立的数据库即完美解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbbd8848f56bd97b2b8a2ee17923f0c/" rel="bookmark">
			明星软件工程师的10种特质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 热爱编程2. 完成事情3. 持续重构代码4. 使用设计模式5. 编写测试6. 善用现有代码7. 专注可用性8. 编写可维护的代码9. 能用任何语言编程10. 知晓基本的计算机科学 1. 热爱编程
编程是一种为了满足兴趣而心甘情愿去做的劳动（Programming is a labor of love）。和其他任何职业一样，唯有真正的热情，才能完成真正的伟大事情。这里有个误解，认为编写代码是机械化并纯科学性的。事实上，最优秀的软件工程 师是工匠，他们能把能量、独创性和创造力融入到每一行代码中。伟大的工程师知道何时该把代码雕琢至完美，知道何时把大型系统像拼图一样组装到一块。热爱编 程的工程师从构建软件中获得满足，就好比一位作曲家在完成一部交响乐后而欣喜若狂。正是兴奋感和成就感，才造就了喜爱编程的明星工程师。
2. 完成事情
有很多技术人员只谈论软件而不编写代码（只说不做型）。而伟大软件工程师会真正去编码，这也是他们最为重要的品质之一。他们是实际做事的人。聪明人都 知道，解决问题的最佳途径是直面问题，而不是花上数周来设计复杂又不必要的架构和函数库。优秀工程师应当会问：解决手头问题的最简单方法是什么？最近的软 件开发方法——敏捷实践，正是专注那个。它的思想是，把复杂的项目拆分为短小的迭代，每个迭代只关注一小部分的增量功能。因为每个迭代对应的编码只需要数 周，所以功能易于管理并简单。
3. 持续重构代码
编码很像雕刻。要像艺术家一样不断完善自己的作品，软件工程师也要通过可能的最佳方式来持续完善自己的代码，以达到目标。重新塑造代码的原则称为“重 构”，Martin Fowler在他的创意书中有相应描述。重构背后的原始思想是：改善代码而不改变其功能，移动调整部分代码以确保系统不腐，还有确保系统完成基于当前需求 该完成的事。持续重构可以让开发人员解决另一个著名的问题——“黑盒遗留代码”（这个问题基本无人想触及）。
几十年的软件开发文化要求我们，不应该去改变正常工作的东西。然而，随着时间推移，问题是我们成为了老旧代码的奴隶，老旧代码变得不稳定和不兼容。而 重构正好可以改变这一状况，因为我们是代码的主人，不是它的奴隶。重构在工程师和代码之间建立起持续的“对话”，并带来所有权、确定性、自信心和系统的稳 定性。
千万不要成为老旧代码的奴隶。如果代码是他人所写，或许你可以轻易推脱责任。但大多数时候，那些代码是自己所写，要拿得起放得下，旧代码该埋时，就把它埋了！
4. 使用设计模式
自从所谓的“四人帮”（Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides）发表他们的著作——《设计模式》后，全世界的软件工程师一直都在讨论模式。在我们所处世界，不管是自然界还是人类行为，模式无处不 在。软件工程自然也不例外。模式就是不断重现的跨语言跨系统的场景和机制。一位优秀的工程师通常能识别并利用模式，而不是受制于模式。工程师不应（强制） 让系统去适应某种模式，而需发现在系统中使用模式的时机（恰当使用模式）。在使用模式来确保正确性时，应借鉴利用前人的智慧结晶，使用以前能正当解决特定 工程问题的方法。但请切记：模式不是万灵药；不要为了使用设计模式而使用设计模式。
5. 编写测试
曾有段时间，软件工程师们认为测试不值得他们去做。然而，如果你不做测试，你怎么能确保代码就能正常工作呢？敏捷实践中的“单元测试”已获得普遍认 可，因为它注重编写测试来反映代码是否有效。随着系统增大，测试也随之增大。有经验的工程师知道并了解测试的价值所在，因为测试的目的就是创建一个能正常 运作的系统。优秀的工程师通常会确保出现过一次的Bug不会再出现第二次。但优秀的工程师也知道，不应该浪费时间写那些琐碎或多余的测试，而需要专注测试 各个组件中的核心部分。
6. 善用现有代码 “重新发明轮子”一直是软件行业中的巨大问题之一。从发明新语言到从写函数库，忽视并重写那些已经存在并已能工作的奇怪驱动力，已经造成大量软件开发 的失败案例。一位明星工程师会专注三种基本类型的重用：第一，内部基础架构的重用，相应代码是他自己或同事编写的；第二，使用第三方的函数库，比如 JDK。最后，研究使用某些大型网络服务商提供的相应服务，比如Amazon。总之，正确善用现有的代码，使得软件工程师能真正专注于最为重要的事情上 ——应用程序本身。
7. 专注可用性 优秀的工程师通常都专注于用户。无论用户是企业还是个人，无论是为消费型的软件公司还是投资银行，需要关注的都是可用性。用户如何和系统交互？系统是 否提供一种简单、直接和平稳的操作体验？有种说法，因为软件工程师是技术人员，他/她和“用户如何与系统交互”没有关联，这种说法严重错误。优秀工程师努 力工作是为了什么？不正是让系统简单并易于使用。他们无时无刻都会想到用户，不会尝试去发明那些令人费解，只有极客才能理解并欣赏的东西。
有些时候，一些软件工程师过于投入，反而忘记所编写的程序/软件，是供他人使用，不是做给自己看的“艺术品”。所以，在软件开发过程中，一直要把“用户”放在心中。
8. 编写可维护的代码
软件开发界的另外一个小秘密是：编写优秀代码和糟糕代码所花费的时间是一样多。一位训练有素的工程师，他/她会从第一行代码开始就考虑可维护性和代码 的演化。没有任何理由编写“丑陋”的代码、长达数页的函数，或是稀奇古怪的变量名。优秀的工程师编写代码会遵循命名惯例，代码编写紧凑、简单和不过度炫耀 聪明。代码的每一行，都应恰如其分地展现出其原有目的。在给不便理解的代码（块）合理注释时，别忘了命名规则。清晰明了的函数名和变量名可以让代码不言而 明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dbbd8848f56bd97b2b8a2ee17923f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9382b2392e88a89ead63f0059b857a/" rel="bookmark">
			防火墙和入侵防护IPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙的必要性 驻地网：由用户终端至网络接口所包含的机线设备组成，以使用户可以灵活方便地进入接入网。防火墙设置在驻地网和Internet之间，以建立二者之间的可控链路，构筑外部安全壁垒或者说安全边界。目的是保护驻地网不受Internet攻击，提供一个能加强安全和审计的遏制点。 防火墙的特征 防火墙的设计目标 所有出战和入站的流量都必须经过防火墙只有符合本地安全策略的流量才允许通过防火墙防火墙本身不能被渗透这就要求防火墙运行在有安全操纵系统的可信系统上 防火墙提供的四种机制 服务控制：确定可以访问的Internet的服务类型，这种类型的过滤是双向的。 防火墙可以基于IP地址，协议和TCP端口号对流量进行过滤
防火墙自身也可以作为服务器，比如web服务器或邮件服务器
方向控制：确定特定的服务请求发起和允许通过的防火墙方向。用户控制：根据访问服务器的用户来控制其访问权限，这个功能通常应用在防火墙周界以内的用户。行为控制：控制特定服务的使用方法。例：控制外部用户只能对web服务器的一部分进行进行访问。 防火墙的功能 防火墙定义了一个遏制点，阻止潜在威胁的安全服务进入或离开网络，并且防止各种IP欺骗和路由攻击。防火墙提供了监视安全事件的相关场所。例：审计和警告。防火墙可以为各种与安全事件不关的Internet功能的实现提供一个便利的平台。例：网络地址转换-将本地地址映射成Interne地址。防火墙可以作为IPsec平台。 防火墙的局限性 防火墙不能阻止那些绕过防火墙的攻击防火墙不能完全防止内部威胁一个设置不恰当的无线局域网可能允许来自公司外部的访问笔记本电脑，PDA或便携式存储设备可以在其他地方被感染之后，又连接到企业内部使用。 防火墙的类型 包过滤防火墙 主动包过滤防火墙：只允许符合特定规则的包通过；被动包过滤防火墙：拒绝符合一定规则的包。包过滤防火墙对每个进出防火墙的IP包应用一些规则，然后决定转发或丢弃此包。一般防火墙都会配置成双向过滤。过滤规则基于网络包所包含的信息，包括： 源地址
目的地址
源端口号和目的端口号
IP协议域
接口：对于有三个或更多接口的防火墙来说，定义哪个接口用于包的出战，哪个用于包的进站。
包过滤器设置成一列基于IP和TCP头域匹配的规则，如果其中的某条规则匹配，则调用此规则来判断该包是转发还是丢弃，如果没有匹配的规则，则执行默认的操作。 默认丢弃：没有被明确允许的都将被丢弃
默认允许：没有被明确禁止的都将被允许
包过滤防火墙的例子，采取默认丢弃策略
规则集A表明入站的邮件是允许通过的，但仅限于流向网关主机，来自一个特定主机SPIGOT的包都会被阻止，因为该主机有过在电子邮件消息中发送大块文件的历史记录。
规则集B表示默认丢弃原则
规则集C表示允许任意主机向外部发送邮件
存在问题：外部主机邮件服务器使用25端口号是默认情况，外部主机使用其他应用程序与25端口号相连，因此攻击者可以通过发送tcp源端口号为25访问内部机器。
规则集D允许源地址在某些指定的内部主机的范围内，同时允许目的TCP端口号为25的IP包流出防火墙，它也允许源端口号为25同时tcp分段中ACK被置位的数据包流入防火墙。
规则集E：
FTP过程中应用了两条TCP连接：一条用于建立文件传输机制的控制连接，另一条用于实际文件传输的数据连接。数据连接使用了在实际传输时动态分配不同的端口号，大多数服务器使用低端口号，大多数出战的应用程序往往使用高端口号。
规则允许：
内部指定主机发出的包
外部机器对内部机器发起的连接的应答包
外部机器发送到内部机器高端口号的包
包过滤防火墙的优点：
简单，对用户是透明，而且具有很快的处理速度。包过滤防火墙的缺点： 包过滤防火墙不检查更高层的数据，因此不能阻止针对特定应用程序漏洞或功能所进行的攻击。
包过滤防火墙可利用的信息有限，使得日志记录功能受限，记录的信息较少。
不支持用户认证
包过滤防火墙对利用TCP/IP规范和协议栈存在的问题进行的攻击没有很好的应对措施，比如地址欺骗攻击
由于包过滤防火墙依赖于几个变量进行过滤，所以防火墙的不恰当设置会使包过滤防火墙的安全性受到威胁。
针对包过滤防火墙的攻击方式以及应对措施： IP地址欺骗：攻击者从外部向内传递数据包，源地址指定为内部主机，。攻击者希望通过这样的假冒内部可信主机地址的包来渗透防火墙系统。防火墙可以丢弃那些从外部到达但是源地址指定为内部主机的数据包。
源路由攻击（ source routing attack) : 惊端指定包通过Internet使用的路由，希望可以绕过对源路由信息的安全检查。应对措施是丢弃所有使用了此选项的包。
细小分段攻击：攻击者利用IP分段来产生特别小的数据分段，并强制将TCP头信息装入到分散的分段中，攻击者希望过滤防火墙检查第一个分段而允许其他分段通过。应对措施：包的第一个分段必须包含最少的预定传输头，如果第一个分段被否决，过滤器将记住这个包，并丢弃后面的所有包。
状态检测防火墙 通常，当一个应用程序使用TCP连接与远程主机创建会话时，需要建立一条客户端与服务器之间的TCP连接，其中服务器的应用程序的TCP端口号是一个小于1024的数，本地应用程序的端口号是一个介于1024-65535之间的数。状态包检测防火墙通过建立一个出战TCP连接目录来强制执行TCP流量规则，当前每个已建立的连接都有一项与之对应，只有数据包符合这个目录中的某项时，包过滤才允许那些到达高编号的出站流量通过。
状态检测防火墙和包过滤防火墙检测相同的信息，不同的是包过滤防火墙还会记录TCP连接信息。一些状态检测防火墙还会检测TCP包的序号，以阻止基于序号的攻击，例如：会话劫持。为了识别和跟踪相关的连接，一些状态检测防火墙还限制了一些众所周知协议的应用数据量。 应用级网关 工作过程：当用户需要使用服务器上的数据时，首先将请求发送给代理服务器，代理服务器再根据这一请求向服务器索取数据，然后再由代理服务器传输给系统。
如果网关不包含某种服务的代理实现机制，那么该服务将不会得到网关的支持，并且对服务的请求不会通过防火墙。应用级网关往往比包过滤防火墙更安全，应用级网关不用判断大量的tcp和ip层上的连接是否允许通过，只需要检查少数可以允许通过的应用程序，另外，在应用层上很容易审计所有的入站流量。缺点：带来了每条连接的额外处理开销 在两个终端用户之间有两条接合连接，网关处于接合点上，它必须对所有双向流量进行检查和传送。
主要工作在应用层，又被称为应用层防火墙，它检查进出口的数据包，通过自身复制传递数据，防止在受信主机与非受信主机间直接建立连接。 电路级网关 可能是单机系统或者是应用级网关为特定应用程序执行的专门功能，与应用级网关相似，电路级网关不允许端到端的TCP连接，而是建立两条TCP连接，一条在自身与内部主机之间，另一条在自身与外部主机之间。 - 安全功能包括判断哪些连接是允许的。 - 电路级网关的一个典型的应用是系统管理员信任系统内部用户，此时网关在检查入站应用数据是否有禁止的功能增加了一些额外的开销，对于出战的数据则没有这种开销。 *** ### 防火墙的布置 *** 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9382b2392e88a89ead63f0059b857a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae46bab13bfab82f32612ee4ba78311/" rel="bookmark">
			nginx: [warn] the &#34;ssl&#34; directive is deprecated的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
升级nginx版本之后，使用之前的配置文件，启动nginx时，出现如下信息：
nginx: [warn] the "ssl" directive is deprecated, use the "listen ... ssl" directive instead in /usr/local/nginx/conf/nginx.conf 问题分析
这是一个warn警告，nginx也能正常使用，但是由于强迫症，还是要把warn解决掉。
根据翻译，nginx提示ssl这个指令已经不建议使用，要使用listen … ssl替代。网上查找nginx更新日志里面，也有提到：
Change: the “ssl” directive is deprecated; the “ssl” parameter of the “listen” directive should be used instead. ssl不建议作为一个指令使用，而是应该listen指令的一个参数。
解决方法
如果使用listen 443 ssl，删除ssl on就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9d94012e5f22d4ef81ef8c5c39f87b/" rel="bookmark">
			module &#39;taichi&#39; has no attribute &#39;Vector&#39;问题（无法识别 pip 下载的包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试了试99行代码冰雪奇缘 在我这不是很顺利 遇到了很多bug~
还好现在都一一解决了。。。。。
（1）第一种原因 ：命名问题 我直接就是taichi了所以就会出现这种情况 所以换个名称就行
D:\python3.7\python.exe E:/untitled3/taichi.py Traceback (most recent call last): File "E:/untitled3/taichi.py", line 1, in &lt;module&gt; import taichi as ti File "E:\untitled3\taichi.py", line 11, in &lt;module&gt; x = ti.Vector(2, dt=ti.f32, shape=n_particles) # position AttributeError: module 'taichi' has no attribute 'Vector' （2）第二种原因 ：pycharm无法识别 pip 下载的taichi包的
我的一开始就是这种原因
有个同学用的 anaconda 的环境 他的是这样的
我的修改后是这样的
这两个问题搞好后就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe2b3ab5c3f644fc8537dea8de9e4456/" rel="bookmark">
			为什么要用Redis？Redis为什么这么快？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、为什么要使用redis呢？原因一、避免反复请求数据库造成效率低下原因二、需要在 秒杀，热点数据 和DB数据库之间 加入缓存中间件 二、以下单线程仅指Redis负责存取这块的线程只有一个，而非Redis中只有一个进程三、讲一讲为什么Redis这么快？3.1、采用了多路复用io阻塞机制3.2、数据结构简单，操作节省时间3.3.、是C语言编写的，运行在内存中，自然速度快采用单线程，使用底层模型不同 四、Redis的常见问题4.1、Redis为什么是单线程的？4.2、如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？4.3、单线程可以处理高并发请求吗？4.4、我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？ 五、简述一下Redis值的五种类型六、有序集合的实现方式是哪种数据结构？七、请列举几个用得到Redis的常用使用场景?7.1、缓存，7.2、排行榜，7.3、计算器/限速器，7.4、好友关系，7.5、简单消息队列，7.6、Session共享，7.7、一些频繁被访问的数据， 八、简述Redis的数据淘汰机制九、Redis怎样防止异常数据不丢失？9.1、RDB 持久化 （快照的形式，周期性的持久化）** 是Redis的默认持久化方法 适合冷备9.1.1、RDB的配置方式9.1.2、RDB 優點9.1.3、RDB缺點9.1.4、RDB 保存過程 9.2、AOF 持久化 （追加到AOF文件的末尾，最后以不同的频次保存到到磁盘）适合热备9.2.1、AOF的设置方法：9.2.2、AOF的优点9.2.3、AOF 的缺点 十、缓存常见问题及缓存穿透，缓存雪崩以及缓存击穿 的含义及原理10.1、缓存更新方式10.2、数据不一致产生的原因解决的办法 10.3、缓存穿透：redis和数据库中都没有数据10.4、缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中10.5、缓存雪崩：大面积的缓存失效，打崩了DB10.6、 解决方法缓存穿透：数据库和缓存中都没有缓存击穿： 单个key失效缓存雪崩： 所有缓存同时失效 十一、过期时间设置常用操作：11.1、过期时间设置11.2、键过期时间查看11.3、键过期判定11.4、 过期键的理论删除策略11.5、 Redis采用的过期键删除策略11.6、 AOF、RDB和复制功能对过期键的处理（1）生成RDB文件：（2）载入RDB文件：（3）AOF文件写入：（4）AOF重写：（5）复制： 十二、连接过程十三、主从链十四、分片十五、Redis是怎么持久化的？服务主从数据怎么交互的？ 一、为什么要使用redis呢？ 原因一、避免反复请求数据库造成效率低下 举个例子，假如系统中有2千万用户信息，用户信息基本固定，一旦录入很少变动，那么你每次加载所有用户信息时，如果都要请求数据库，数据库编译并执行你的查询语句，这样效率就会低下很多，针对这种信息不经常变动并且数据量。
较大的情况，通常做法，就是把他加入缓存，每次取数前先去判断，如果缓存不为空，那么就从缓存取值，如果为空，再去请求数据库，并将数据加入缓存，这样大大提高系统访问效率。
原因二、需要在 秒杀，热点数据 和DB数据库之间 加入缓存中间件 项目的DB遇到了瓶颈，特别是秒杀和热点数据这样的场景DB基本上就扛不住了，那就需要缓存中间件的加入了，目前市面上有的缓存中间件有 Redis 和 Memcached ，他们的优缺点
https://blog.csdn.net/qq_44472134/article/details/104416741
综合这些然后再结合我们项目特点，最后我们在技术选型的时候选谁。
二、以下单线程仅指Redis负责存取这块的线程只有一个，而非Redis中只有一个进程 我先给个我的结论，单线程的Redis在瓶颈是cpu的io时（这不是大多数应用的实际应用场景），确实速度会比多线程慢。但是，我们实际应用场景中很少会遇到瓶颈是CPU的io的情况，这时候单线程优势就凸显出来了。
实现很简单！性能又不会比多线程差，并且，单线程确实不用处理上下文的切换，cpu利用率会比多线程高，这时候采用单线程实现是一种很划算的做法。当然，如果你的宽带和内存牛逼到了使得你的io成为瓶颈，这时候也只能使用多线程了。
面试时考官让我挑一种自己熟悉的NoSQL数据库讲一讲，我当场就蒙了，我就用过sql server，mysql和Oracle这几种，这几种就算从名字看也知道是sql数据库嘛，绞尽脑汁，我福至心灵，答出，Redis！
先说说Redis是什么吧小老弟？
Redis嘛，就是一种运行速度很快，并发很强的跑在内存上的NoSql数据库，支持键到五种数据类型的映射，（string、list、set、zset、hash）
三、讲一讲为什么Redis这么快？ 3.1、采用了多路复用io阻塞机制 3.2、数据结构简单，操作节省时间 3.3.、是C语言编写的，运行在内存中，自然速度快 采用单线程， 避免了不必要的上下文切换和竞争条件，安全；也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
使用底层模型不同 它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求
四、Redis的常见问题 4.1、Redis为什么是单线程的？ 因为Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
4.2、如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？ 那也很简单，你多起几个Redis进程就好了。Redis是key-value数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe2b3ab5c3f644fc8537dea8de9e4456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080d3e33efa98e8a1d20b6131fa87425/" rel="bookmark">
			使用pyecharts绘制柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from pyecharts.charts import Bar from pyecharts import options as opts bar = Bar() #指定柱状图的横坐标 bar.add_xaxis(["衬衫", "毛衣", "领带", "裤子", "风衣", "高跟鞋", "袜子"]) #指定柱状图的纵坐标，而且可以指定多个纵坐标 bar.add_yaxis("商家A", [114, 55, 27, 101, 125, 27, 105]) bar.add_yaxis("商家B", [57, 55, 27, 101, 125, 27, 105]) #指定柱状图的标题 bar.set_global_opts(title_opts=opts.TitleOpts(title="某商场销售情况")) #参数指定生成的html名称 bar.render('price.html') 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/397/">«</a>
	<span class="pagination__item pagination__item--current">398/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/399/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>