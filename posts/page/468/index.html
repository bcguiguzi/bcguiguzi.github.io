<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfb2777eb27f51b18c81ca9364b008e/" rel="bookmark">
			电流型和电压型PHY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网口PHY芯片对于TX与RX的驱动方式有电压驱动和电流驱动之分。最简单的一个识别方式就是看其推荐原理图，
如果网络变压器的中心抽头需要提供一个VCC（3.3V、2.5V等等，下同）电源的就是电流驱动，
如果是直接加一个对地电容就可以的就是电压驱动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7e42d1781600c9f501adc059af173a/" rel="bookmark">
			&lt;易理解&gt;利用main函数的参数实现计算功能，附赠功能实现教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序可以接受三个参数，第一个参数“-a”选项执行加法，“-s”选项执行减法，“-m”选项执行乘法，“-d”选项执行除法，后面两个参数为操作数。
注有一些解释，帮助初学者读懂程序，后面也说了应如何实现功能方法，如果还不懂，欢迎积极评论留言给我….. #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;Windows.h&gt; //加减乘除功能函数 int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } //main函数的参数中argc表示元素个数，argv录入元素，envp表示环境变量 int main(int argc, char *argv[], char *envp[]) { //atoi函数将第三和第四个参数转换成字符串传入，因为argv是字符数组指针 int number1 = atoi(argv[2]); int number2 = atoi(argv[3]); int ret = 0; if (argc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7e42d1781600c9f501adc059af173a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b265e9d50faa0c101c95d8fb7a94cc/" rel="bookmark">
			Laravel -- 邮箱功能配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		````
今天碰到了这块的问题，还是记一下
````
关于邮箱：
品牌：腾讯qq、网易163 等
种类：个人、企业
邮箱服务器种类
配置教程
https://jingyan.baidu.com/article/358570f64332c4ce4624fc4f.html
网易邮箱为例
个人：
发送邮件服务器SMTP: smtp.163.com。
POP3服务器: pop.163.com。
IMAP服务器：imap.163.com。
企业：
发送邮件服务器SMTP: smtp.qiye.163.com。
POP3服务器: pop.qiye.163.com。
IMAP服务器：imap.qiye.163.com。
laravel的.env文件配置：
个人邮箱例子：
MAIL_DRIVER=smtpMAIL_HOST=smtp.qq.comMAIL_PORT=465
一般默认25，
MAIL_ENCRYPTION=ssl
加密一般有ssl,tls
MAIL_ADDRESS=账号@qq.comMAIL_NAME=发邮箱时的账户名MAIL_USERNAME=账户@qq.comMAIL_PASSWORD=这个密码需要是邮箱的授权码 企业邮箱例子
MAIL_DRIVER=smtp MAIL_HOST=smtp.qiye.163.com 注意这里需在stmp后加qiye MAIL_PORT=465 MAIL_ENCRYPTION=ssl MAIL_ADDRESS=邮箱账号 MAIL_NAME=邮箱账户名称 MAIL_USERNAME=邮箱账号
MAIL_PASSWORD=同样授权码 转载于:https://www.cnblogs.com/smallyi/p/7852606.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec6aca172560df77e7ad4dc17f5d3d8/" rel="bookmark">
			解决 /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决 /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwi 解决：
sudo gem install -n /usr/local/bin cocoapods 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc4a20c1384e5b1f2adbc674318de46/" rel="bookmark">
			C/C&#43;&#43;中RAND_MAX的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RAND_MAX是C中stdlib.h中宏定义的一个字符常量： #define RAND_MAX Ox7FFF 其值最小为32767,最大为2147483647 通常在产生随机小数时可以使用RAND_MAX。 给出C++例子： //在VC6.0中运行通过 #include&lt;iostream&gt; #include&lt;ctime&gt; #include&lt;cstdlib&gt; using namespace std; int main(void) { srand((unsigned int)time(NULL)); double a[10]; int i; cout&lt;&lt;RAND_MAX&lt;&lt;endl; for(i=0;i&lt;10;i++) a[i]=(double)rand()/RAND_MAX; for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0; } 以上摘自百度百科 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de03acc3512806842e7e55dfd6983ba/" rel="bookmark">
			[java] jdbc连接数据库time_zone问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mybatis版本是：3.4.1
mysql版本mysql-connection-java 6.0.2
原始config
jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/infocollect 报错time_zone问题
改为
jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/infocollect?serverTimezone=UTC&amp;amp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83211f8076fcc65d80572d35667037c/" rel="bookmark">
			执行./configure报checking for g&#43;&#43;... no错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在某实验环境下编译安装软件时，执行./configure 报错（./configure是源代码安装的第一步，主要的作用是对即将安装的软件进行配置，检查当前的环境是否满足要安装软件的依赖关系），错误提示如下：
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for g++... no
checking for c++... no
checking for gpp... no
checking for aCC... no
checking for CC... no
checking for cxx... no
checking for cc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83211f8076fcc65d80572d35667037c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a0966149a3a4723dd36bab0b120057/" rel="bookmark">
			机器学习十大算法原理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监督学习算法： 1、K-近邻算法：通过建立和样本之间的距离求和，然后通过选择最近的K个样本数据，样本数据类型多的就是需要分的类型。 2、决策树算法：通过求最大信息增益来得到需要判断和拆分的标签类目，然后建立递归数，进行继续拆分到叶子节点结束。 3、朴素贝叶斯算法：通过和全量样本对比，有不同的样本概率求和，选择概率最大的作为分类。 4、逻辑回归算法：通过样本数据来计算逻辑回归系数，确定样本的分类概率，系数越大，准确性越高，结果数据大于0.5为一类，小于0.5为另一类。 5、支持向量机算法：和逻辑回归类型，不同之处就是支持的向量的特征维度相对较少，最后通过建立一个绝对平面来进行绝对正反分类。
无监督学习算法： 1、聚类算法：通过设定任意的质心，然后计算周边所有点的聚类，取最近的K个数的平均值作为新的质心，不断迭代，进行分类到结束。 2、协同过滤算法：主要是划分数据集，然后计算支持度进行过滤无效数据，然后通过计算置信度得出数据出现的概率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb1d2fced1568e954d70541a1868371/" rel="bookmark">
			[centos] Centos7安装mariadb-server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ###centos7下mysql的替代品–mariadb
centos7下阿里云没有mysql，用mariadb替代，但登录同mysql
http://mirrors.aliyun.com/help/centos //更换服务器阿里云
sudo yum -y install mariadb-server//安装 systemctl start mariadb.service //启动服务 systemctl stop mariadb.service //关闭服务 systemctl restart mariadb.service //重启服务 systemctl enable mariadb.service //开机启动服务(未试过) mysql -u root -p //登录mysql (默认密码为空) #####设置密码
https://www.cnblogs.com/LvLoveYuForever/p/5585197.html
mysqladmin -u root -p password newpassword #####添加用户
https://www.cnblogs.com/LvLoveYuForever/p/5585197.html
#####修改字符集解决中文乱码
vim /etc/my.cnf //linux /* 在文件中的[mysqld]节点添加以下信息*/ character-set-server=utf8 default-character-set=utf8//可选择,视情况 /* 然后重启服务在登录查看字符集即可 */ show variables like '%character%'; #####centos利用wget和url下载
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u91-b14/jdk-8u91-linux-x64.tar.gz yum -ivh .....rpm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6ffa7f58f90ccc18bcb40eaa4354d1/" rel="bookmark">
			adb启动程序命令：adb shell am start
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.
启动的方法为
adb shell # am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}
第一种情况： 从源代码，得知包名。
程序的入口类可以从每个应用的AndroidManifest.xml的文件中得到，以计算器（calculator）为例，它的
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" …
package="com.android.calculator2" …&gt;…
由此计算器（calculator）的启动方法为：# am start -n com.android.calculator2/com.android.calculator2.Calculator
对于HelloActivity这个示例工程，AndroidManifest.xml如下所示：
&lt;manifest …
package="com.example.android.helloactivity" …&gt;
由此它的启动方法为：
# am start -n com.example.android.helloactivity/com.example.android.helloactivity.HelloActivity
其他的一些应用启动命令，如下所示：
calendar（日历）的启动方法为：
# am start -n com.android.calendar/com.android.calendar.LaunchActivity
AlarmClock（闹钟）的启动方法为：
# am start -n com.android.alarmclock/com.android.alarmclock.AlarmClock
Music 和 Video（音乐和视频）的启动方法为：
# am start -n com.android.music/com.android.music.MusicBrowserActivity
# am start -n com.android.music/com.android.music.VideoBrowserActivity
# am start -n com.android.music/com.android.music.MediaPlaybackActivity
Camera（照相机）的启动方法为：
# am start -n com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad6ffa7f58f90ccc18bcb40eaa4354d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162060235ce12b8476a4d4dcda420540/" rel="bookmark">
			hdu 4507 吉哥系列故事——恨7不成妻 (数位DP求和)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吉哥系列故事——恨7不成妻 Time Limit: 1000/500 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)
Total Submission(s): 4951 Accepted Submission(s): 1620
Problem Description 单身! 依然单身！ 吉哥依然单身！ DS级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： 2+1+4=7 7+7=7*2 77=7*11 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！ 什么样的数和7有关呢？ 如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 1、整数中某一位是7； 2、整数的每一位加起来的和是7的整数倍； 3、这个整数是7的整数倍； 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 Input 输入数据的第一行是case数T(1 &lt;= T &lt;= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;= L &lt;= R &lt;= 10^18)。 Output 请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 Sample Input 3 1 9 10 11 17 17 Sample Output 236 221 0 解析： 这道题对数位DP的理解有很大的好处，尤其是dp[][][]里面存的值的状态 对于找与满足条件的数很简单，第一个状态就是数的每一位相加的和对7的余数，第二个状态就是这个数对7的余数 其次难点就是求平方和： 数位DP就是通过dp数组来剪枝，所以如果在pos位求某个状态的值的时候就可以直接返回之前求过相同状态的dp[][][]，不用在用dfs。所以当你状态与dp[][][]里某个状态相同时，你要用dp[][][]来获得这个状态的平方和。 ∑(Y + xi)^2 = ∑(Y^2 + 2 * Y * xi + xi^2) = n * Y^2 + 2 * Y * ∑xi + ∑ xi^2 xi^2=dp[][][],现在要求的就是n（在pos位之前的已知下，(pos-1）-0位满足条件的数的数量）, ∑xi（在pos位之前的已知下，(pos-1）-0位满足条件的数的和），这两个可跟平方和同时递归得到，所以就是三个返回值的数位DP 不用3个分别dfs的原因是每一个dfs的dp[][][]都只是装着在dp中状态的通解，像在limit限定的情况所得到的值就无法写进数组中dp[pos1][state1][mo1]=0，但这些状态的值又是在求平方和是需要用到的,这样就会错误 数位DP中如果条件中有余数或整除的情况，都可以把余数作为dp的其中一个状态！！！ 最后注意的一点是两个取模后的数大小就无法判定了，相减可能是负数，所以最后要用负数取模！！！！ //数位DP中如果条件中有余数或整除的情况，都可以把余数作为dp的其中一个状态 #include&lt;cstdio&gt; #include&lt;cstring&gt; #define MOD 1000000007LL typedef long long int ll; typedef struct node { ll sum; ll qsum; ll cnt; node():cnt(0),sum(0),qsum(0){} node(ll c,ll s,ll qs):cnt(c),sum(s),qsum(qs){} }node; int a[100]; ll ten[20]; node dp[20][10][10]; //ll sum[20][10][10]; //0为个位，1为十位，。。。。 node dfs(int pos,bool limit,int state,int mo) //计算dp[pos][state]即pos-1位是state时满足条件的个数 { node ans; if(pos==-1) { if(mo!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162060235ce12b8476a4d4dcda420540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4ded4f3a24b61df0242e7db7e92e6c/" rel="bookmark">
			bat脚本控制网卡的禁用和启用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯DOS就可以搞定。
核心代码：
netsh interface set interface "本地连接" disabled netsh interface set interface "本地连接" enabled 其中"本地连接"是网卡的名字，通过“控制面板\网络和 Internet\网络连接”可以看到。 disabled是禁用，enabled是启用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1063bdee0a96f797b8a2bb8c9356e2/" rel="bookmark">
			华为机试训练做题总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串最后一个单词的长度
题目描述：计算字符串最后一个单词的长度，单词以空格隔开。 思路分析：看到这一题，开始我也没啥想法，想要去看答案，然后忍住了，稍微想了想，这一题其实挺简单的。不就是最后单词的长度，直接跑到字符串的最后，然后朝前数字符串到空格就行了。但是后来看别人的正确答案，发现自己考虑问题还是不够全面，这一题还需要考虑字符串最后是好几个空格的情况。因此需要设置一个flag当跑到最后一个单词的屁股的时候，将其置零。还有一个问题就是输入的问题，虽然没有仔细考虑到这个小细节，但是整体的思路还是正确的，但是最后正确率总停留在30%,一直没想明白，后来明白了。看完OJ的规则，发现不定量的输入需要使用getline(cin,str)，读取字符串，这样可以完全读取字符串。我开始使用的是定义string str，这样会有一个问题就是输入的时候会导致输入断流。
代码：
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
string str;
while(getline(cin,str)){
int count=0;
int len=str.length();
int flag=1;
for(int i=len-1;i&gt;=0;--i){
if(flag &amp;&amp; str[i]==' ')
continue;
else if(str[i]!=' ' ){
flag=0;
++count;
}else
{
break;
}
}
cout&lt;&lt;count&lt;&lt;endl;
}
return 0;
}
2.计算字符个数
题目描述：写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。
思路分析：这个代码只有30%的通过率，百思不得其解。我的主要思想就是通过逆序将最后一个字符提取，然后再重新顺序遍历空格之前的字符串，与提取的字符相同的就计数。讲道理，应该不会有问题，求大神解答！ 代码：
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main(){ string str; char com; int endnum=0; while(getline(cin,str)) { int len=str.length(); int flag=1; for(int i=len-1;i&gt;=0;i--) { if(flag &amp;&amp; str[i]==' ') { continue; }else if(str[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1063bdee0a96f797b8a2bb8c9356e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc5043cd90e92c1920652939e0a5649/" rel="bookmark">
			Python生成PDF文件（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将文档转变为 PDF 文件举例 ReportLab 为了方便生成文档提供了一种叫PLATYPUS(Page Layout and Typography Using Scripts)的一系列的模板类，它用于控制文档的布局，可以让我们不用关心具体的坐标，绘制命令，甚至分页的处理，而将注意力集中在布局与内容上。 下面是一个最简单的生成Hello, ReportLab的例子。
from reportlab.platypus import Paragraph, SimpleDocTemplate from reportlab.lib.styles import getSampleStyleSheet stylesheet=getSampleStyleSheet() normalStyle = stylesheet['Normal'] story = [] story.append(Paragraph("Hello, ReportLab", normalStyle)) doc = SimpleDocTemplate(‘hello.pdf’) doc.build(story) 第１行我们导入Paragraph和SimpleDocTemplate类。Paragraph是用于生成文本段落，SimpleDocTemplate是文档布局模板。 第２行导入将要用在Paragraph中的样式。也就是说ReportLab已经为我们预先定义了一些样式，如标准，标题１，标题２，黑体等等，用于生成特殊效果。与Word中的样式有些象。 第３行是得到样式集。 第４行是得到标准样式，它将用在Paragraph的生成中。 第５行是生成一个空列表。这里叫story，在用户手册中你会看到这个单词。它将用来存储象段落这样的对象，其它的还可以是图片等。而这些东西是有顺序的，因此使用了list来保存。因此在用户手册中看到这个单词不要以为是什么特别的对象。 第６行生成我们期待的”Hello, ReportLab”段落，并且它的样式是普通。将生成的结果放在story中。 第７行创建SimpleDocTemplate对象，指定将要生成的文件名。　第８行执行文档模板的build方法最终生成文件。所以有文档模板类都有build方法。 从上面的例子可以看到通过文档模板及样式可以让我们方便的创建面向对象的应用，而不用再关心坐标、绘制命令等底层的东西，从而可以方便我们的文档生成。打开hello.pdf看一看效果吧。这回就象是真正的文档，”Hello, ReportLab”放在上面了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36514f1a5120b09c106cde3226ba87a/" rel="bookmark">
			RecyclerView的item不充满的整个宽度的原因二种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.第一种是在adapter中加载inflater时parent传入为null 2.如果第一种不行，第二种原因就是在RecyclerView外随意加一层布局即可充满 我的情况：是在弹窗时不充满，结果在外面包了一层relayout即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e686192d1c54b9165fc92d556683c752/" rel="bookmark">
			对象、类和实例&amp;&amp;线程与进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象、类和实例&amp;&amp;线程与进程 前言: 前几天早上Big-man和自己的一位同事，争论一个问题，这个问题就是对象是什么？。她的争论是"对象是类的实例化", 而Big-man却是认为不能这么片面的认为对象，因为那只是书上的定义。同时Big-man也询问了线程与进程的关系，进程是攘括一个或者多个进程，这是这位同事回答我的，Big-man同时也是知道这是书上的答案，这足以证明Big-man的这位同事是位学霸，但是Big-man的小伙伴们能理解吗？如果不能，就来听听下面Big-man的分析吧。 类: 在Big-man的中华民族中存在着这样一句俗语叫做"物以类聚"，正所谓物以类聚，类就是一些具有某些相同特性的**"物"的集合**，比如"人"这样的类，每个人都有姓名、年龄、性别等特性。在Big-man生活的世界中存在这许多的类， 更多的这样的例子就不用Big-man去进行举例了吧，相信小伙伴们都可以很好的解决这样的举例。
对象: 对象按照上述类的解释，对象也就是具体指代的某一个人，比如是Big-man、mentality等，所以上述类也可以称为是像Big-man、mentality这样的对象的集合。对象是一个抽象的概念，什么是抽象的概念？抽象就是本身无法触摸的意味。对于对象的实例，Big-man也不在这里阐述了，小伙伴们会很好的去了解这部分实例的。
实例: 按照上述类与对象的阐述，实例就是指代某一个具体的事物了，打个比方，对象就是建筑物图纸里的高楼，实例就是实际的高楼。对象的实例化就是根据图纸的高楼建造实际高楼的过程。Big-man这样的理解就感觉比起书上的呆板的定义比较容易理解，不知小伙伴是否也是这样的理解。 代码验证: public class Peason { String name; String sex; int age; String character; public static void main(String[] args) { Peason ps = new Peason(); ps.name = "jackdan"; ps.sex = "male"; ps.age = "21"; ps.character = ""; } } 以上是Java当中定义的一个类，new的过程就是对象实例化的过程。实例化就在内存中开辟一块空间，告诉内存存在这样的一个对象。ps就是对象的一个引用，要对这个对象进行操作data的时候，就可以通过这个引用。 JackDan9 Thinking
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19c5d0adad651462a155f74b4eb3f59/" rel="bookmark">
			int *a[n]和int (*b)[n]的区别（易混淆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int *a[n]( 由返回整型数据的指针所组成的数组 ) 1.指针数组;每n个元素全为指针的数组. 2.a是一个指针数组，每一个指向一个int型
方便理解： 是指针数组， 有 n 个成员，每个成员都是一个指针，共有n个指针
int (*b)[n]( 指向由整型数据组成的数组的指针 ) 1.数组指针;指针类型是 int [n]类型的数组.指向n个元素组成的数组的一个指针。 2.b是一个指针，指向int[n]的数组。
方便理解：小括号优先，所以 是 1个指针，用来指向 有n个元素的数组。
结合优先级： []的优先级比*的优先级高。 所以： int *a[n]
a先与[n]结合变为a[n]，再与*结合最终为*a[n]。
方便理解：int *a[n],视为int* a[n],是int*类型的，所以每个元素的数组都是int*类型的。 int(*b)[n]
b先为(*b)，再与*结合最终变为(*b)[n]。
方便理解：(*b)可以看作是*b,指针指向的内容（是假设，有助于理解，不是指向的内容），是int[n]，一个指针指向整个数组。
int *a[n]例子运用
/*int m[3] = { 8, 4, 3 }; a[0] = &amp;m[1]; a[1] = &amp;n[2]; a[2] = &amp;x[3];也可以用在一维数组*/ int *a[3]; int m = 8, n = 4, x = 3; //a = &amp;m;错误 a[0] = &amp;m; a[1] = &amp;n; a[2] = &amp;x; cout &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c19c5d0adad651462a155f74b4eb3f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35113d8b28b50e9f9e6dc6b4ca16d441/" rel="bookmark">
			质因子的分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：所谓的质因子分解是指将一个正整数n写成一个或多个质数的乘积的形式，例如：6=2*3,8=2*2*2.或者将其写为指数形式，如：6=2^1*3^1,180=
2^2 * 3^2 * 5^1;由于最后要归结到若干不同指数的乘积，因此需要先将素数表打印出来。
注意：1本身不是素数，因此他没有质因子，一般就是讨论大于1 的数。如果有的题目需要对1进行讨论，那么就要视为特判。
由于每个质因子都可以不只出现一次，因此不妨定义结构体factor，用来存放质因子及其个数。
struct factor{
int x,cnt;//x为质因子，cnt为质因子的个数 }fac[10];
这里的质因子存放到fac[]数组里。如：180来说；
fac[0].x = 2;
fac[0].cnt = 2;
fac[1].x = 3;
fac[1].cnt = 2;
fac[2].x = 5;
fac[2].cnt = 1; fac[10]开到10的原因是：2*3*5*7*11*13*17*19*23*29就已经超出了int范围所以就只用到开到10；
对一个正整数n来说，如果他存在1和本身之外的因子，那么一定是在sqrt（n）左右成对出现。而这里也可以用在“质因子”上面，会得到一个强化结论：对一个正整数n来说，如果它存在【2，n】范围的质因子，要么这些质因子全部小于等于sqrt（n），要么这些质因子只存在一个大于sqrt（n）的质因子，而其余质因子全部小于等于sqrt（n）。这就有了一个思路：
1：枚举1~sqrt（n）范围内的所有质因子p，判断p是否是n的因子。
如果p是n的因子，那么给fac数组中增加质因子p，并初始化为0.然后只要p还是n的因子，就让n不断的除以p，每次操作使p的个数加1，直到p不是n的因子为止。
if(n % prime[i] == 0){
fac[num].x = prime[i];
fac[num].cnt = 0;
while(n % prime[i] == 0){
fac[num].cnt ++;
n /= prime[i];
}
num++;
}
如果p不是n的因子，就直接跳过。
2：如果上面的步骤结束后n仍然大于1，说明有且仅有一个大于sqrt（n）的质因子（有可能是n本身），这时需要把这个质因子加入fac数组中，并令其个数等于1.
if(n!=1){//如果无法被根号n以内的质因子除尽 fac[num].x = n;
fac[num++].cnt = 1; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35113d8b28b50e9f9e6dc6b4ca16d441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84d27faa9bbf782355c9408b3def9f3/" rel="bookmark">
			UDP广播遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前提 在做一个pc服务器（eclipse）向android客户端发送udp广播的功能（同一电脑上测试），android始终收不到数据
电脑ip：192.168.0.19
真机手机ip：192.168.0.24
android模拟器ip：10.0.2.15
pc服务器私网地址：10.0.2.2
子网掩码：255.255.255.0
二、问题 真机上可以收到，广播地址为192.168.0.255（端口号相同即可），模拟器上收不到（试了很多地址都不行）
原因：
端口、广播地址不对，两边设置了同一端口（22222），这时电脑的22222端口并没有开启，开启的是模拟器的22222端口，需要进行模拟器与pc端口映射
解决：
a.命令行中输入 telnet 127.0.0.1 5554 进入虚拟机，5554为虚拟机的端口号，若提示telnet不是内部或外部命令，百度解决Win7如何解决telnet不是内部或外部命令的方案
b.上一步完成后出现C:\Users\Administrator.emulator_console_auth_token，找到此文件并打开复制里面字符串，在telnet命令行中输入：auth XXXXX(刚复制的字符串),
(auth 若出问题，好像是要加上adb环境变量，即把sdk下的tools和platfrom-tools加到系统环境变量path中)
c.端口映射：redir add udp:22222:22222（redir add &lt; udp/tcp &gt;: &lt; pc端口 &gt;: &lt; 模拟器端口 &gt;)，第二步不成功会提示KO: unknown command, try 'help'
d.redir list 可以查看已映射列表
e.使用完删除映射：redir del udp:22222
结果：
android设置22222端口接收，发送端设置127.0.0.1 22222发送
疑问：
广播地址设置255.255.255.255、192.168.0.255、10.0.2.255...都不行，只有127.0.0.1可以，why？
（后来测试时，192.168.0.255可以）
三、广播域计算 用主机的IP地址与子网掩码进行与运算即可知道该主机属于哪一个广播域。例如：一台主机的IP地址为192.168.23.150，子网掩码为255.255.255.0，那么它所属的广播域就是192.168.23.150&amp;255.255.255.0=192.168.23.0。那么其它的在广播域192.168.23.0内的所有主机就可以到该设备发送的广播包。如果把子网掩码改为255.255.0.0，那么它所属的广播域就是192.168.23.150&amp;255.255.0.0=192.168.0.0。那么其它的在广播域192.168.0.0内的所有主机都可以收到该设备发送的广播包。
四、广播地址的计算 要想相同广播域内的其它主机能收到的广播帧，还需要在发送广播包的时候指定当前所属广播域内的广播地址。广播地址的计算方法为子网掩码取反再与广播域进行或运算。
例如：如果主机当前所属广播域为192.168.0.0，子网掩码为255.255.0.0，那么广播地址则为192.168.255.255。
五、udp跨网段广播 要使主机A发送的广播包能够被另一网段的主机B收到，那么只需要更改主机A的子网掩码使得与主机B在同一个广播域内，再使用新的广播域的广播地址发送广播包即可。
例如：要使用192.168.23.150发送广播包让192.168.27.135收到，只需要设置192.168.23.150的子网掩码为255.255.0.0，然后再使用广播地址192.168.255.255即可。
广播UDP与单播UDP的区别就是IP地址不同，广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。特别要指出的是：255.255.255.255是受限广播地址
其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30226e49e96523a2f9e776b474f61d80/" rel="bookmark">
			通过InstallShield官网申请注册码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017-10-30补充： 现在InstallShield官网已经焕然一新，再也没有BUG。
最近重装系统，发现InstallShield Limited Edition注册码失效了，于是重新到InstallShield官网申请。 http://learn.flexerasoftware.com/content/IS-EVAL-InstallShield-Limited-Edition-Visual-Studio 但是InstallShield官网设计有BUG，沒有VPN的话，一些列表框无法选择，导致无法提交。
以前的注册码是开VPN去官网申请的，但是最近很多VPN都给封了，怎么办呢？ 幸亏还有百度。经过反复搜索，终于找到了一篇文章，介绍了一种直接修改HTML提交申请的方法，非常感谢这篇文章的作者，帮了我一个大忙。 原文参考： http://blog.163.com/whm_flag/blog/static/259180073201642113857818/ 但是文章上的图片实在太小了，看得我眼泪都流出来了，所以我写了这篇文章，希望能够帮助到有需要的人。
我用的是WIN10系统。用IE打开InstallShield官网，不能用Edge，光标定位Company，执行右键菜单检查元素。
找到要修改的行，以Country为例，右键菜单编辑为HTML 输入内容参见红色方框： 一共有4处改动： Job Function
&lt;option value="Application Packaging"&gt;...&lt;/option&gt; 1 Development Team Size
&lt;option value="&lt;5"&gt;...&lt;/option&gt; 1 Country
&lt;option value="China"&gt;...&lt;/option&gt; 1 State / Province
&lt;option value="guangdong"&gt;...&lt;/option&gt; 1 最终效果，4处无法选择的列表框显示为…： 然后点击download now，会出来一个空白网页，但是在邮箱里收到了注册码。
为发本文，因为用词不当导致帐号被封，想帮助别人也不容易啊。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/467/">«</a>
	<span class="pagination__item pagination__item--current">468/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/469/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>