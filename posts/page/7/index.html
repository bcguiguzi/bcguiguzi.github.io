<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7cc53f8e517c687aecf257d06ff5f2/" rel="bookmark">
			【MatLab】之：Simulink安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内容简介 本文介绍如何在 MatLab 中安装 Simulink 仿真工具包。
二、所需原材料 MatLab R2020b（教学使用）
三、安装步骤 1. 点击菜单中的“附加功能”，进入附加功能管理器：
2. 在左侧的“按类别筛选”下选择Using Simulink——Simulink：
3. 在右侧结果中选择Simulink，点击安装：
4. 登录后安装即可：
等待片刻，安装完成：
即可使用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e2663ccb1c9c88b9e397e3652c2092/" rel="bookmark">
			AI -朴素贝叶斯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬朴素贝叶斯原理 朴素贝叶斯是一种基于概率论和统计学的分类算法，它的核心是贝叶斯定理和特征条件独立假设。
数据分析：在处理不确定性和不完全数据集时，贝叶斯方法可以帮助我们做出更加合理的推断。模式识别：在机器学习中，贝叶斯公式可以用来识别和分类模式，例如垃圾邮件过滤器。统计决策：在需要做出基于概率的决策时，贝叶斯公式提供了一种系统的方法和框架。 它通过计算给定数据集中的先验概率和条件概率来确定每个类别的后验概率，并将样本分配给具有最大后验概率的类别。朴素贝叶斯算法的核心思想非常直接，它依赖于一个关键假设，即特征之间在给定类别的条件下是相互独立的。尽管这个假设在现实中不一定总是成立，但它极大地简化了模型的构建和计算过程。朴素贝叶斯算法的优点在于其简单、易于实现，并且对于大规模数据集的处理效率较高。
在实际应用中，朴素贝叶斯算法因其简单性和高效性而被广泛应用于文本分类、垃圾邮件过滤、情感分析等领域。此外，由于其基于概率的特性，朴素贝叶斯模型还可以提供关于分类决策的置信度估计，这在某些应用中非常有用。
🔎概率公式 条件概率： 表示事件A在另外一个事件B已经发生条件下的发生概率，P(A|B) 联合概率： 表示多个条件同时成立的概率，P(AB) = P(A) P(B|A)
特征条件独立性假设：P(AB) = P(A) P(B) 🔎贝叶斯公式 贝叶斯公式可以表示为：
[ P(A|B) = \frac{P(B|A) cdot P(A)}{P(B)} ]
其中，( P(A|B) ) 是在事件B发生的条件下事件A发生的概率，即后验概率；( P(B|A) ) 是在事件A发生的条件下事件B发生的概率，即似然概率；( P(A) ) 是事件A发生的先验概率；( P(B) ) 是事件B发生的边缘概率。
贝叶斯公式的核心意义在于，它可以让我们基于新的数据或信息来更新对一个事件发生概率的估计。
🔎朴素贝叶斯 贝叶斯概率计算过程中，需要计算联合概率，为了简化联合概率的计算，朴素贝叶斯在贝叶斯基础上增加：特征条件独立假设，即：特征之间是互为独立的。 由于训练样本的不足，导致概率计算时出现 0 的情况。为了解决这个问题，我们引入了拉普拉斯平滑系数。
拉普拉斯平滑，也称为加1平滑，是处理零概率问题的一种常用方法。
在朴素贝叶斯分类器中，当计算某个特征在给定类别下的概率时，如果该特征在训练集中没有出现，则其概率会被计算为0。这可能导致在分类新的实例时忽略那些未在训练集中出现的 feature-category 组合。为了解决这个问题，拉普拉斯平滑被引入，确保所有的概率预测都大于0。
拉普拉斯平滑的基本思想是给每个可能的feature-category组合的计数都加上一个常数（通常选择1），同时为了保持概率的总和为1，分母也需要做相应的调整。公式可以表示为：
[ P(A_j|B_k) = frac{count(A_j, B_k) + 1}{sum(count(A_j, B_k)) + K} ]
其中，( P(A_j|B_k) ) 是在类别 ( B_k ) 的条件下特征 ( A_j ) 出现的概率，( count(A_j, B_k) ) 是训练集中特征 ( A_j ) 在类别 ( B_k ) 中出现的次数，( sum(count(A_j, B_k)) ) 是所有特征在类别 ( B_k ) 中出现的总次数，而 ( K ) 是类别的总数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e2663ccb1c9c88b9e397e3652c2092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a2de19c4519d6324c8e18cc2a7b2ab/" rel="bookmark">
			数学建模--MATLAB基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.线性方程组 这个是一个线性方程组（属于线性代数的范畴），Ax=b类型的方程，如果使用MATLAB进行求解，就需要分别表示A矩阵（线性方程组未知数前面的系数），b矩阵（表示等式右边的结果），inv是这个软件里面的一个函数，用来进行求解A的逆矩阵，因为Ax=b,那么x=A-1次方乘上b
另外，我们也可以使用这个A\b来进行求解，这个里面需要注意是A\b,而不是我们熟悉的A/b,他们所代表的含义是不一样的，我们在脚本里面敲代码的时候，需要在前面的2行加上结尾处的引号，最后一行不用加引号，否则我们在命令行窗口里面无法看到最后的输出结果；
2.二维图形的绘制 二维图形的绘制要是用这个plot函数，我们通过这个例子来认识一下函数的使用方法，以sin1/x为例吧：
（1）这个地方我们只绘制了-1~1范围里面的函数图像，这样便于观察函数的效果，学过高等数学的同学们对于这个函数就非常的熟悉，因为他是特例，这个函数是有界限的，但没有极限存在；
（2）下面我们来聊一聊这个里面每一行代码的作用，首先，第一行是生成行向量，我们可以简单地理解为，通过这一行，我们要告诉MATLAB我们要绘制图像的定义域是-1~1之间的，100000是在这个-1~1这个区间里面生成100000个采样点，
（3）这个里面使用了点运算符，只要是涉及到矩阵里面的元素运算，我们在大部分的情况下都要是用这个运算符，后续还会涉及到，这个运算符在矩阵的运算里面很常见，我们都知道，对于两个矩阵的乘法运算，他们并不是对应位置的元素相乘，但是如果我们使用点乘运算符，就可以让矩阵里面对应位置的元素进行相乘的运算；
**************************************************************************************************************
接下来我们举一个在一个坐标平面里面绘制2个图形的例子
我们在一个坐标平面里面绘制y=e^x*cos和y=10*e^-0.5x*sin(2pi x)的函数图像(0~pi/2区间里面）
这个里面的plot中的单引号里面表示的是一些标记符号；
b是蓝色，-表示实线；合在一起就是蓝色实线；
k表示黑色，：表示虚线；合在一起就是黑色虚线；
下面是效果图：
3.空间曲线的绘制 绘制空间曲线x^2+y^2+z^2=16,x+y=0(这2个方程是在一个括号里面进行联立的）
首先要转化成为参数方程，也就是x=2根号2sint;y=-2根号2cost;z=4cost;
下面是是否添加grid on的区别，读者可以自行感受：
这个是没有grid on的，可见就没有曲线的格子；
这个是添加了grid on的，差别就显而易见了；
4.函数极限实验 （1）符号运算，matlab使用sym创建符号对象，一次只能够创建一个符号对象，我们也可以使用syms一次性创建多个符号对象；
（2）极限运算
MATLAB提供limit函数求极限
limit(f,x,a)表示求f(x)在a点处的极限值；
limit(f,x,a,'right')是求这点处的右极限，如果我们把right换成left就是求左极限；
当然，也可以进行求解多元函数的极限：这个时候就需要嵌套limit；
z=limit(limit(f,x,x0),y,y0)就是求在x0,y0处的极限值；
f1里面就是我们要求的函数的表达式，在x趋近于1的极限值；
我们都知道sin(1/x)的极限是不存在的，所以程序的输出结果就是NaN;
5.MATLAB求导运算 MATLAB里面可以调用diff函数求函数的导函数；
例如diff(f,x,5)就是求符号函数f在x这个点处的5阶导数；
接下来我们使用MATLAB求一下y=x^2*exp(-x)的3阶导数；
6.MATLAB实现函数的泰勒幂级数展开 taylor里面就是我们要展开的函数表达式；
6.MATLAB积分实验 我们使用int(s,x)就是表示对s表达式里面的x进行积分；
顺便提一句：无论是积分求解还是极限的求解，我们都是使用inf代表无穷；
下面是例子：
（需要了解的是这个不定积分的求解是没有常数项的（实际上数学里面的求解是由常数的））
当然，MATLAB也是可以计算定积分的：
对于积分的上下限，我们在int(s,x,a,b)里面添加2个参数，a是积分下限，b是积分的上限
7.MATLAB实现微分方程 Dny表示y的n阶导，D2y就是2阶导；我们可以调用dsolve函数实现常微分方程的求解；
这个板块不同的版本软件的代码语言有所差别，这个是以我的2023为例
（1）我们去求dy/dx+y/x=sinx/x的通解：
diff就是求导数的运算；
（2）求解dy/dx+y=y^2*exp(-x)满足条件y(0)=-2的特解：
提前说明一下，笔者使用的是旧版本的教材，但是用的是新版MATLAB，2023里面可能会因为不支持原来的某些符号而报警告，但是我们依然是能够得到结果的；
D2y表示的是2阶导，D3y表示的是3阶导，以此类推；
（3）y''-6y'+13y=0的通解；
8.空间曲面（马鞍面&amp;&amp;双曲抛物面） （1）同样是马鞍面，也叫做双曲抛物面，我们可以使用不同的函数进行绘制，不同的函数的展示的效果是不一样的，我们上面的是使用mesh函数绘制，这个函数主要是连接成网格点，下面的这个有颜色的马鞍面是用这个surf进行绘制的，代码的其他部分不变，只需要把第4行的函数的名字改变一下就可以了，通过这个案例我们也可以发现这两者之间的差别，前者线条有颜色，线条之间的补面没有颜色的填充，后者的曲面图线条是黑色的，之间使用颜色进行了填充；
（2）MATLAB为我们提供了grid函数决定是否显示分格线，他的调用格式为
grid od:显示分格子线
grid off:不显示分格子线
（3）相信你一定注意到了这个里面的点运算，点运算是MATLAB里面很有特色的一种运算，我们都知道，矩阵在进行乘法操作的时候，并不是对应的元素进行相乘，但是如果我们对于矩阵里面的元素使用点乘运算，就可以实现对应位置的元素相乘，在绘图里面这个运算有十分广泛的运用；
（4）这个里面的meshgrid也是一个函数，这个函数的功能就是生成网格数据，当X轴和Y轴的数据点个数相等的时候，我们就可以使用[x,y]=meshgrid(x,y);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a68e57d40abe5bc673243f328072c0e/" rel="bookmark">
			MATLAB是什么，它主要用于什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB（Matrix Laboratory，矩阵实验室）是一款由美国MathWorks公司出品的商业数学软件，用于数据分析、无线通信、深度学习、图像处理与计算机视觉、信号处理、量化金融与风险管理、机器人，控制系统等领域。MATLAB是matrix（矩阵）&amp;laboratory（实验室）两个词的组合，意为矩阵工厂（矩阵实验室），软件主要面对科学计算、可视化以及交互式程序设计的高科技计算环境。它将数值分析、矩阵计算、科学数据可视化以及非线性动态系统的建模和仿真等诸多强大功能集成在一个易于使用的视窗环境中，为科学研究、工程设计以及必须进行有效数值计算的众多科学领域中提供了一种全面的解决方案，并在很大程度上摆脱了传统非交互式程序设计语言（如C、Fortran）的编辑模式。
MATLAB的基本数据单位是矩阵，它的指令表达式与数学、工程中常用的形式十分相似，故用MATLAB来解算问题要比用C，FORTRAN等语言完成相同的事情简捷得多，并且MATLAB也吸收了像Maple等软件的优点，使MATLAB成为一个强大的数学软件。在新的版本中也加入了对C，FORTRAN，C++，JAVA的支持。可以直接调用，用户也可以将自己编写的实用程序导入到MATLAB函数库中方便自己以后调用。此外，MATLAB的图形功能也十分强大，数据的可视化非常简单。MATLAB还包含功能丰富的应用工具箱（如信号处理工具箱、通信工具箱等），为用户提供了大量方便实用的处理工具。
MATLAB的主要用途非常广泛，包括但不限于以下几个方面：
数值分析：MATLAB首先是一个数值计算环境和编程语言。它提供了大量的内置函数和工具箱，用于执行各种数值计算任务，如线性代数、微积分、优化、统计等。这些功能使得MATLAB成为科学家、工程师和数学家进行数值分析和模拟的首选工具。
数据可视化：MATLAB提供了强大的数据可视化功能，使用户能够轻松地创建二维和三维图形、图像和动画。这对于数据探索、结果展示和报告生成非常有用。
算法开发：MATLAB是一个交互式环境，非常适合于算法开发、原型设计和实验。用户可以快速编写和测试代码，而无需担心底层实现细节。此外，MATLAB的代码通常比其他编程语言更易读和易写。
仿真与建模：MATLAB提供了多种工具箱，用于模拟和建模各种动态系统，如控制系统、信号处理系统、通信系统、图像处理系统等。这些工具箱使用户能够构建复杂的模型，并进行仿真分析。
应用开发：除了作为研究和开发工具外，MATLAB还可以用于构建独立的应用程序。通过MATLAB Compiler，用户可以将MATLAB代码编译成独立的应用程序或库文件，以便在没有MATLAB环境的计算机上运行。
学科应用：MATLAB在多个学科领域都有广泛的应用，包括工程学（如机械、电气、电子、航空航天等）、物理学、化学、生物学、医学、经济学、金融学等。在这些领域中，MATLAB被用于数据分析、建模、仿真、优化和决策支持等任务。
总之，MATLAB是一个功能强大且易于使用的数学软件平台，广泛应用于科学研究、工程设计和教育等领域。它的矩阵计算功能、丰富的工具箱和交互式环境使得用户能够高效地解决各种复杂的数学和工程问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761daf713ca12c48aeaece5641629adc/" rel="bookmark">
			openCV实现拖拽虚拟方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目效果： 二、核心流程： openCV读取视频流、在每一帧图片上画一个矩形。使用mediapipe获取手指关键点坐标。根据手指坐标位置和矩形的坐标位置，判断手指点是否在矩形上，如果在则矩形跟随手指移动。 三、代码流程： 环境准备：
python: 3.8.8 opencv: 4.2.0.32 mediapipe: 0.8.10.1 注： opencv版本过高或过低可能出现一些如摄像头打不开、闪退等问题，python版本影响opencv可选择的版本。pip install mediapipe 后可能导致openCV无法正常使用，卸了重新下载，习惯了就好。 1. 读取摄像头视频，画矩形： import cv2 import time import numpy as np # 调用摄像头 0 默认摄像头 cap = cv2.VideoCapture(0) # 初始方块数据 x = 100 y = 100 w = 100 h = 100 # 读取一帧帧照片 while True: # 返回frame图片 rec,frame = cap.read() # 镜像 frame = cv2.flip(frame,1) # 画矩形 cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 255), -1) # 显示画面 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/761daf713ca12c48aeaece5641629adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9cb302a48492c300a6705b804c4ad3/" rel="bookmark">
			PyTorch学习笔记之基础函数篇（十四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 7.14 torch.fmod() 函数7.15 torch.remainder() 函数7.16 torch.frac() 函数7.17 torch.round() 函数 7.14 torch.fmod() 函数 在PyTorch中，torch.fmod 函数用于计算张量（tensor）中每个元素除以另一个张量或标量后的浮点余数1。
函数签名如下：
torch.fmod(input, divisor, *, out=None) → Tensor 参数解释：
input (Tensor): 需要进行取余操作的输入张量。divisor (Tensor or float): 除数，可以是与张量 input 形状相同的张量，也可以是一个标量。out (Tensor, optional): 输出张量。如果提供，则结果将写入这个张量中，并且函数将返回这个张量。 torch.fmod 函数会返回一个新的张量，其中包含了输入张量 input 中每个元素除以 divisor 后的浮点余数。如果 divisor 是一个标量，那么它会被广播到与 input 相同的形状。如果 divisor 是一个张量，那么它必须具有与 input 相同的形状，或者可以广播到与 input 相同的形状。
以下是一个使用 torch.fmod 的例子：
import torch # 创建一个张量 x = torch.tensor([3.0, 5.0, 7.0]) # 使用标量进行取余操作 y = torch.fmod(x, 2.0) # 打印结果 print(y) 输出将会是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9cb302a48492c300a6705b804c4ad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f4917a05449e5943cda3f375693dd05/" rel="bookmark">
			Maven基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven基础 1.Maven简介2.Maven环境搭建3.Maven基础概念4.Maven项目搭建通过maven来构建项目maven项目搭建方式:不使用原型创建项目使用原型创建项目 5.Maven依赖管理6.Maven生命周期与插件 1.Maven简介 Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）
Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终他把一个项目看成一个对象，而这个对象叫做POM(project object model)，即项目对象模型
依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系。maven依赖管理存储三个位置：本地仓库，私服，中央仓库Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期. Maven的作用
（1）项目构建：提供标准的，跨平台的自动化构建项目的方式
（2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题
（3）统一开发结构：提供标准的，统一的项目开发结构
各目录存放资源类型说明：
src/main/java：项目java源码
src/main/resources：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）
src/main/webapp：web资源（比如html，css，js等）
src/test/java：测试代码
src/test/resources：测试相关配置文件
src/pom.xml：项目pom文件
2.Maven环境搭建 maven的官网地址
官方下载地址
apache-maven-3.6.1-bin.zip直接解压到D盘根目录下即可
各目录结构说明：
bin：可执行程序目录，
boot：maven自身的启动加载器
conf：maven配置文件的存放目录
lib：maven运行所需库的存放目录
需要java环境,java环境配置点此链接
maven环境变量配置
此电脑右键属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量
变量名：MAVEN_HOME
变量值：D:\maven\apache-maven-3.3.9
变量名：Path
变量值：%MAVEN_HOME%\bin
验证:win + R -&gt; cmd -&gt; mvn -v
出现:Apache Maven 3.3.9则安装成功
3.Maven基础概念 仓库：用于存储资源，主要是各种jar包
中央仓库：maven团队自身维护的仓库，属于开源的
私服：各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源
本地仓库：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源
坐标：maven中的坐标用于描述仓库中资源的位置
坐标作用:使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成。
jar包下载地址
groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis）
artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）
version：定义当前资源的版本号
packaging：定义资源的打包方式，取值一般有如下三种
（1）jar：该资源打成jar包，默认是jar
（2）war：该资源打成war包
（3）pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构
maven资源坐标点此链接常用
仓库配置
选择在全局进行配置，在maven的配置文件conf/settings.xml中可以找到它的说明,在系统盘当前用户目录下的.m2/repository
默认位置
&lt;localRepository&gt;C:\Users\${user.home}\.m2\repository&lt;/localRepository&gt; 指定一个新的位置作为本地仓库的位置:maven配置文件conf/settings.xml中添加
&lt;localRepository&gt;D:\maven-repository&lt;/localRepository&gt; 局部用户配置：在仓库的同级目录也可以包含一个settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f4917a05449e5943cda3f375693dd05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498bb1d9cd01662c28721ad7c79f9fdb/" rel="bookmark">
			【JavaScript】JavaScript 运算符 ③ ( 比较运算符 | 等于比较 运算符 == | 不等于比较 运算符 != | 严格等于比较 运算符 === )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JavaScript 运算符1、比较运算符 概念2、比较运算符 列举3、等于比较 运算符 ==4、不等于比较 运算符 !=5、严格等于比较 运算符 ===5、严格不等于比较 运算符 !==6、赋值运算符 = / 等于比较运算符 == / 严格等于比较运算符 === 示例 一、JavaScript 运算符 1、比较运算符 概念 JavaScript 语言 的 " 比较运算符 “ , 又称为 ” 关系运算符 " ,
" 比较运算符 " 的 作用是 将 2 个 数据 进行 比较 , 然后返回一个 " boolean 布尔类型的值 " , 作为 比较结果 ;
2、比较运算符 列举 JavaScript 语言 的 " 比较运算符 " 如下 :
&lt; : 小于 比较 ; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498bb1d9cd01662c28721ad7c79f9fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c8b08cb3b849781efde6a28326e789/" rel="bookmark">
			解决IDEA右侧的maven窗口消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在idea新建一个springboot项目时，出现SpringBootApplication运行不了，各个模块也的图标颜色也没有，最关键的是右侧的maven窗口消失，这可能意味着pom.xml文件没有被识别, idea觉得这个项目不是maven项目，导致idea无法加载依赖包。
解决方法：
1. 右键pom.xml文件
2. 点击" add as maven project "
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01138bbb3cb8b8d14ae962335c50e621/" rel="bookmark">
			【820复试】数据结构面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.用循环比递归的效率高吗2.顺序表和链表的比较3.头指针和头结点的区别4.如何区分循环队列是队满还是队空？5.栈在通过后缀表达式求值的算法思想6.栈在递归中的应用7.队列在层次遍历中的作用8.队列在计算机系统中的应用9.矩阵的压缩存储10.串的模式匹配11.如何由遍历序列构造一棵二叉树12.线索二叉树的概念13.树的4种存储方式14.平衡二叉树15.dijkstra算法16.Floyd算法17.Prim算法18.Kraskal算法19.拓扑排序20.B树和B+树21.哈希表的概念、构造方法，哈希冲突的解决方法22.内部排序辨析23.外部排序辨析 1.用循环比递归的效率高吗 循环和递归两者是可以互换的，无法陈述谁效率高。
递归
优点：代码简洁清晰，容易检查正确性；
缺点：递归调用次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，会对执行效率有一定的影响。
循环
优点：结构检点，速度快；
缺点：不能解决全部问题，有些问题适合于用递归来解决不适合用循环解决。
2.顺序表和链表的比较 从 存取方式、 逻辑结构和物理结构、 查找插入和删除操作、空间分配四个方面分别做比较即可。
3.头指针和头结点的区别 头指针：是指向第一个结点存储位置的指针，具有表示作用，头指针是链表的必要元素，无论链表是否为空，头指针都存在。
头结点：是放在第一个元素结点之前，便于在第一个元素结点之前进行插入和删除的操作，头结点不是链表的必须元素，可有可无，头结点的数据域也可以不存储任何信息。
4.如何区分循环队列是队满还是队空？ ①牺牲一个单元来区分队满和队空。
队空就是Q.front == Q.rear
队满就是(Q.rear+1)%Maxsize == Q.front
②增设数据成员元素
队空Q.size0
队满Q.sizeMaxsize
③标记上一次是入队还是出队
若是入队flag=1，此时出现Q.frontQ.rear，那么即为队满
若是出队flag=0，此时出现Q.frontQ.rear，那么即为队空
5.栈在通过后缀表达式求值的算法思想 但凡出现左括号，做入栈操作，否则做以下操作：
是否为空？与栈顶元素是否匹配？
表达式检验结束后，还要检查栈中是否还有元素。
6.栈在递归中的应用 在递归函数中，每次函数调用都会创建一个新的函数调用帧（frame），这个帧包含了函数的局部变量、参数值以及函数返回地址等信息。
当函数调用自身（递归调用）时，每次都会创建一个新的函数调用帧。这些函数调用帧被存储在内存中的栈数据结构中，这就是所谓的调用栈（call stack）。
当递归函数开始执行时，会一直递归调用自身，每次递归调用都会将一个新的函数调用帧压入调用栈中。
当递归条件不再满足，函数开始返回时，会从栈顶依次弹出函数调用帧，并执行相应的返回操作，直到栈为空，整个递归过程结束。
7.队列在层次遍历中的作用 遇到某类信息需要逐层/逐行处理时，往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。
二叉树的层序遍历、广度优先搜索、任务调度、消息队列、缓冲池、批处理系统。
8.队列在计算机系统中的应用 任务调度和作业管理： 操作系统使用队列来管理和调度各种任务和作业。例如，多任务操作系统可以使用队列来安排进程的执行顺序，确保按照优先级和其他调度策略执行任务。I/O请求管理： 计算机系统中的I/O设备通常会产生大量的请求，如磁盘I/O请求、网络数据包等。队列被广泛应用于管理这些请求，以便按照请求到达的顺序来处理它们。消息传递和事件处理： 在事件驱动的系统中，队列用于管理事件和消息的处理顺序。例如，图形用户界面（GUI）应用程序可以使用队列来处理用户输入事件、定时器事件等。网络数据包排队： 在网络系统中，路由器和交换机使用队列来缓冲传入和传出的数据包。这些队列可以帮助调节网络流量，并确保数据包按照一定的优先级和服务质量要求被处理。缓存系统： 队列常被用于实现缓存系统，例如最近最少使用（LRU）缓存算法。在缓存满时，新的数据项可以被放入队列，而最久未使用的数据项可以从队列的头部被移除。并发编程： 在多线程和并发编程中，队列常被用于实现线程间的通信和同步。例如，生产者-消费者模型中，一个线程（生产者）向队列中放入数据，而另一个线程（消费者）则从队列中取出数据进行处理。日志和消息处理系统： 队列可用于实现日志和消息处理系统，用于收集、存储和处理系统产生的日志和消息。通过将日志和消息放入队列中，可以实现异步处理和解耦。批处理系统： 在数据处理领域，队列被广泛用于构建批处理系统。数据处理任务可以被放入队列中，然后由后台任务逐个处理，从而提高处理效率。 9.矩阵的压缩存储 矩阵的压缩存储是一种优化存储矩阵的方法，特别是当矩阵中有大量的重复值或者是稀疏矩阵（大部分元素为零）时。
它的主要目的是减少内存占用，提高存储和处理效率。
行压缩存储、列压缩存储、对角线压缩存储、十字链表法。
10.串的模式匹配 朴素算法（Naive Algorithm）：
也称为暴力匹配算法，它是最简单直观的模式匹配算法。它的思路是在文本串中从头到尾逐个字符地与模式串进行比较，直到找到匹配或者遍历完整个文本串。
朴素算法的时间复杂度为 O(m*n)，其中 m 是模式串的长度，n 是文本串的长度。
// 朴素算法函数 int naiveSearch(char *text, char *pattern) { int textLength = strlen(text); int patternLength = strlen(pattern); for (int i = 0; i &lt;= textLength - patternLength; ++i) { int j; // 检查文本串中从第 i 个位置开始的子串是否与模式串匹配 for (j = 0; j &lt; patternLength; ++j) { if (text[i + j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01138bbb3cb8b8d14ae962335c50e621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d4cedec3bbaf103f562dcfe3e019d2/" rel="bookmark">
			spring boot集成redis实现共享存储session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot集成redis实现共享存储session redis实现共享存储session 首先下载redis,我下载的版本是5.0.14,目前官网貌似找不到5.x版本，可以自行去网上寻找。我这里的springboot版本是2.6.4引入redis依赖 &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt; &lt;/dependency&gt; 引入 spring-session 和 redis 的整合 &lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/dependency&gt; 修改 spring-session 存储配置 spring.session.store-type spring: session: timeout: 86400 #过期时间：24h store-type: redis #存储类型redis 正常做完这些就可以实现共享存储session
但是我遇到一些问题：
自定义的Session存储库（SessionRepository）和@EnableRedisHttpSession注解冲突 配置好redis -session但是登录后，redis中并没有存储session 原因： 在之前解决跨域访问出现的Set-Cookie:SameSite=Lax 问题是，在网上引入了SessionConfig 配置类：
import org.springframework.boot.autoconfigure.session.DefaultCookieSerializerCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.session.MapSessionRepository; import org.springframework.session.SessionRepository; import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession; import org.springframework.session.web.http.DefaultCookieSerializer; import java.util.concurrent.ConcurrentHashMap; @Configuration @EnableSpringHttpSession public class SessionConfig { @Bean public SessionRepository sessionRepository() { return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); } @Bean DefaultCookieSerializerCustomizer cookieSerializerCustomizer() { return new DefaultCookieSerializerCustomizer() { @Override public void customize(DefaultCookieSerializer cookieSerializer) { cookieSerializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d4cedec3bbaf103f562dcfe3e019d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfded83218883aed0e38c6e6c53c13e/" rel="bookmark">
			【Spring Boot】创建你的第一个 Spring Boot 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建你的第一个 Spring Boot 应用 1.环境配置2.步骤详解3.项目结构分析3.1 入口类 DemoApplication3.2 控制器 PathVariableController3.3 控制器 BasicController3.4 模型 User 4.运行 Spring Boot 目前已经成为了 Java 开发领域的框架范式。本篇博客，我将带领大家一起创建一个 Spring Boot 的 Demo 应用。
1.环境配置 在开始之前，我们需要安装好编辑器 IDEA，以及配置好 Java 和 Maven 的环境。
环境/工具版本下载链接IntelliJ IDEA 2023.3.4 2023.3.4 2023.3.4链接jdk 1.8 1.8 1.8链接maven 3.6.3 3.6.3 3.6.3链接 通过以下命令可以检验是否安装及配置成功。
🚀 具体如何安装不在本篇博文的讨论范围内，网上有很多的教程，但如果在安装过程中有问题，或者在本篇博文的实践中遇到了问题，可以在评论区给博主留言。
2.步骤详解 单击 IDEA 菜单栏中的 File ➡ New ➡ Project，再选择 Spring Initializr，做如下配置。
注意，Server URL 我们换成了 https://start.aliyun.com/，否则按照默认配置的 https://start.spring.io，Java 选不到 8。
我们可以分别打开这两个网站看一下：
🚀 https://start.spring.io 🚀 https://start.aliyun.com/ 默认选择的 Spring Boot 版本是 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfded83218883aed0e38c6e6c53c13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753232831bdb9ca7ad3604ed58404b14/" rel="bookmark">
			Linux-centos系统中如何去除配置文件中的注释部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.备份配置文件 将原有的配置文件备份到一个新的文件
备份配置文件可以在我们误操作时及时的补救
#将原有的配置文件复制一份到指定的文件夹 （这个文件夹用来专门存放配置文件的源文件，文件夹自行创建） cp filename.conf /file_path/config 在 CentOS 系统中，去除配置文件中的注释部分通常可以通过命令行工具来完成。以下是一些常用的命令行方法，用于不同格式的配置文件：
2.使用命令及方法 1. 使用 `sed` 命令 `sed` 是一个流编辑器，可以用来对文本进行过滤和转换。对于大多数配置文件，注释通常以 `#` 开头。你可以使用以下命令去除所有以 `#` 开头的行：
sed -i '/^#/d' filename.conf #这里，`-i` 选项表示直接修改文件，`/^#/d` 是一个正则表达式，表示删除所有以 `#` 开头的行。 2. 使用 `awk` 命令 `awk` 是一个强大的文本处理工具，可以对文件进行复杂的文本操作。以下命令将删除所有包含 `#` 的行：
awk '!/#/' filename.conf &gt; filename_no_comments.conf 这个命令将不包含 `#` 的所有行输出到一个新文件 `filename_no_comments.conf`。如果你想直接在原文件上进行更改，可以使用 `gawk`（GNU awk）的 `--in-place` 选项：
gawk '!/#/' filename.conf --in-place 3. 使用 `grep` 命令 `grep` 命令用于搜索文本，并且可以用来删除包含特定模式的行。以下命令将删除所有包含 `#` 的行：
grep -v '^#' filename.conf &gt; filename_no_comments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753232831bdb9ca7ad3604ed58404b14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0c35cbf907b92fdb114ff3cd03ffb0/" rel="bookmark">
			鸿蒙Harmony应用开发—ArkTS声明式开发（容器组件：RelativeContainer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相对布局组件，用于复杂场景中元素对齐的布局。
说明：
该组件从API Version 9开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
规则说明 容器内子组件区分水平方向，垂直方向： 水平方向为left， middle， right，对应容器的HorizontalAlign.Start， HorizontalAlign.Center， HorizontalAlign.End。垂直方向为top， center， bottom，对应容器的VerticalAlign.Top， VerticalAlign.Center， VerticalAlign.Bottom。子组件可以将容器或者其他子组件设为锚点： 参与相对布局的容器内组件必须设置id，不设置id的组件不显示，容器id固定为__container__。此子组件某一方向上的三个位置（水平方向为left、middle、right，垂直方向为top、center、bottom）可以指定容器或其他子组件同方向的三个位置（水平方向为HorizontalAlign.Start、HorizontalAlign.Center、HorizontalAlign.End，垂直方向为VerticalAlign.Top、VerticalAlign.Center、VerticalAlign.Bottom）为锚点。若同方向上设置两个以上锚点，水平方向Start和Center优先，垂直方向Top和Center优先。例如，水平方向上指定了left以容器的HorizontalAlign.Start为锚点，middle以容器的HorizontalAlign.Center为锚点，又指定right的锚点为容器的HorizontalAlign.End，当组件的width和容器的width不能同时满足3条约束规则时，优先取Start和Center的约束规则。当同时存在前端页面设置的子组件尺寸和相对布局规则时，子组件的绘制尺寸取决于约束规则。从API Version 11开始，该规则发生变化，子组件绘制尺寸取决于前端页面设置的尺寸。对齐后需要额外偏移可设置offset(API Version 11上新增了bias， 不建议再使用offset和position)。从API Version 11开始，在RelativeContainer组件中，width、height设置auto表示自适应子组件。当width设置auto时，如果水平方向上子组件以容器作为锚点，则auto不生效，垂直方向上同理。特殊情况 根据约束条件和子组件本身的size属性无法确定子组件大小，则子组件不绘制。互相依赖、环形依赖时容器内子组件全部不绘制。同方向上两个及以上位置设置锚点但锚点位置逆序时此子组件大小为0，即不绘制。 子组件 支持多个子组件。
接口 RelativeContainer()
从API version 9开始，该接口支持在ArkTS卡片中使用。
示例 @Entry @Component struct Index { build() { Row() { RelativeContainer() { Row().width(100).height(100) .backgroundColor("#FF3333") .alignRules({ top: {anchor: "__container__", align: VerticalAlign.Top}, left: {anchor: "__container__", align: HorizontalAlign.Start} }) .id("row1") Row().width(100).height(100) .backgroundColor("#FFCC00") .alignRules({ top: {anchor: "__container__", align: VerticalAlign.Top}, right: {anchor: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0c35cbf907b92fdb114ff3cd03ffb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef423be91e3c397fed988717d4e1dd75/" rel="bookmark">
			魔域枫叶魔方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
魔域枫叶魔方
1，魔方三要素
2，复原方法
（1）复原4个面的正方形
（2）复制最后2个面的正方形
（3）复原魔方
3，拼装方法
魔域枫叶魔方 1，魔方三要素 （1）组成部件
6个中心块和8个角块，另外每个面还有构成正方形的8个块（4个椭圆和4个三角）。
PS：
所谓的中心块，其实就是每一面正中心里面可以看到颜色，是凹进去的，并没有明显的块。
但是我们还是应该认为有中心块，这一点类似于空心魔方。
（2）可执行操作
整体几何形态有2种，一种是正方体，一种是正方体斜着切开成2半，旋转60度。
一共有3类操作：
正方体时，旋转60度变成非正方体，这一类有4种，因为有4个轴非正方体时，旋转60度变成正方体，这一类里对于每种非正方体，有1种操作非正方体时，把由4个椭圆和2个三角构成的圆旋转180度，这一类里对于每种非正方体，有1种操作 所以，从某种角度上来说，一共有6种操作。
（3）目标态
目标态是正方体，且每一面都是纯色。
2，复原方法 （1）复原4个面的正方形 第一面很简单：
掌握了简单的操作技巧之后，前4个面可能会比较顺利，只剩2个面：
接下来只需要分析复原最后2个面需要处理的场景，那么即使前4个面遇到类似的场景，也可以一样的处理。
（2）复制最后2个面的正方形 首先我们可以很轻松的把最后2个面的三角块都复原，然后看剩下的椭圆块是什么位置关系。
实际上有2种位置关系。
第一种：
第二种：
其他的情况都可以转化成这2种情况。
为了研究这2种情况怎么解决，我取了3种原子操作：
A操作是4 5 6和11 10 9互换
B操作是11 10 9和1 2 3互换
C操作是1 2 3和8 7 4互换
那么最简单的思路就是把这3个操作进行有规律的组合，看看能得到什么。
幸不辱命，很快我们就找到解决上面2种情况的公式。
第一种情况的公式是ABCBA，第二种情况的公式是BCBABCB
不需要做很多尝试，规律很明显，稍微试一试就出来了。
（3）复原魔方 由于6个面的正方形都已经复原了，接下来就不需要再动正方形了，于是魔方退化成四轴斜转魔方。
按照四轴斜转魔方的公式即可复原。
3，拼装方法 如果不小心拆散了，可以先把6个正方形拼起来，再整体组装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74bdd3d101e30bf09c9b3056cca71580/" rel="bookmark">
			考研机试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 头文件与STL动态规划最大数组子串和最长公共子序列最长连续公共子串最长递增子序列最大上升子序列和0-1背包多重背包多重背包问题 I整数拆分最小邮票最大子矩阵 数学问题朴素法筛素数线性筛素数快速幂 石子合并锯木棍并查集Dijkstra单源最短路Python进制转换(整数无限大)全排列神奇的口袋全排列II放苹果求第k小八皇后问题哈夫曼编码KMP算法遍历建立二叉树 头文件与STL #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; vector.insert(vector.begin(),2,99)//在头部插入2个99 vector.erase(vector.begin() + 5, vector.end()) //删除第5个以后的元素 map&lt;string,int&gt; map.insert(pair&lt;string, int&gt;()) map.count() //0或1 map.earse() //删除 string s; s.find() s.substr(int start,int length) //切割子串 //输入含空格字符串 getline(cin,s); //优先队列 priority_queue&lt;int,vecotr&lt;int&gt;,greater&lt;int&gt;&gt;; //less是降序 python输入
import sys for line in sys.stdin: arr = line.split() //拼接列表 ' '.join(list) a = int(arr[0]) 动态规划 最大数组子串和 dp[i]其实代表的是以i结尾的最大子串和
for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; // 需要额外的ans存储max，因为是子串 dp[i+1]=max(dp[i]+a[i],a[i]); ans=max(dp[i+1],ans); } 最长公共子序列 动态规划
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74bdd3d101e30bf09c9b3056cca71580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a438c2748d5e44bc94fc04db7f4f0389/" rel="bookmark">
			网络工程师——2024自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、怎样从零开始学习网络工程师
当今社会，人人离不开网络。整个IT互联网行业，最好入门的，网络工程师算是一个了。
什么是网络工程师呢，简单来说，就是互联网从设计、建设到运行和维护，都需要网络工程师来负责相关的工作。下面我会从几个方面来展开聊一下，零基础怎么学习成为网络工程师。
网络工程师的学习路线规划网络工程师的必备的学习资源 学习路线规划 1. 基础理论阶段
计算机网络基础：了解OSI七层模型、TCP/IP四层模型，掌握各种网络设备的功能和工作原理，如交换机、路由器、服务器等。数据通信基础：理解数字信号与模拟信号的区别，学习数据传输的基本方式（如串行传输、并行传输），以及数据编码技术。 2. 网络设备配置与管理阶段
交换机与路由器配置：深入学习交换机的VLAN划分、STP生成树协议等特性；掌握路由器的静态路由、动态路由（如RIP、OSPF）等配置方法。无线网络设备：了解无线局域网（WLAN）的基本原理，学习无线接入点（AP）、无线控制器（AC）的配置与管理。 3. 网络安全与防护阶段
防火墙技术：深入学习包过滤防火墙、代理服务器防火墙的工作原理和配置方法，了解VPN（虚拟专用网络）的实现方式。入侵检测与防御：学习使用入侵检测系统（IDS）和入侵防御系统（IPS）来保护网络安全。 4. 编程与网络自动化阶段
Python/Shell编程：学习使用Python或Shell脚本进行网络设备的自动化配置与管理，提高工作效率。网络自动化工具：了解并学习使用Ansible、Puppet、Chef等网络自动化工具，实现网络设备的批量配置和管理。 5. 云计算与虚拟化技术阶段
虚拟化技术：学习服务器虚拟化（如VMware、Hyper-V）和网络虚拟化（如SDN）的基本原理和应用场景。云计算平台：了解并学习使用AWS、Azure等云计算平台，掌握云网络的基本配置和管理方法。 6. 大数据与网络分析阶段
网络流量分析：学习使用Wireshark等工具进行网络流量捕获和分析，了解网络性能瓶颈和安全风险。大数据处理：了解大数据处理的基本原理和技术，如Hadoop、Spark等，学习如何处理和分析海量的网络数据。 7. 进阶阶段
学习新技术：持续关注网络技术的最新发展动态，如网络功能虚拟化（NFV）、软件定义网络（SDN）等前沿技术。专业认证：考虑参加如华为认证（HCIA/HCIP/HCIE）Cisco CCNA、CCNP、CCIE等认证考试，提升自己的专业能力和竞争力。 网络工程师详细学习路线+配套视频&amp;华为认证HCIA/HCIP/HCIE 最新题库 需要的朋友可以点赞收藏留言“已关注，求分享”
二、学习资源推荐 1. 书籍
《计算机网络》（第七版）作者：谢希仁《TCP/IP详解》（卷1、卷2、卷3）作者：W.Richard Stevens《网络设备配置与管理实战》作者：王达《网络安全技术与解决方案》作者：王达《Python核心编程》（第三版）作者：Wesley Chun《自动化运维之道：Ansible实战指南》作者：刘天斯《云计算实战：AWS平台应用与开发》作者：刘鹏 2. 在线课程与网站
Coursera：提供丰富的网络技术和编程课程，由知名大学和企业授课。Udemy：提供大量的网络技术和编程课程，价格相对实惠。edX：由麻省理工学院和哈佛大学联合创建的在线学习平台，提供高质量的网络技术课程。Linux Academy：专注于Linux和网络技术的在线学习平台。Packet Tracer：Cisco提供的网络模拟工具，可用于搭建实验环境。GNS3：开源的网络模拟器，支持多种网络设备和操作系统。 3. 工具与软件
Wireshark：网络协议分析器，用于捕获和分析网络数据包。Nmap：网络扫描工具，用于网络发现和安全审计。Metasploit：安全测试框架，用于模拟网络攻击和漏洞利用。Ansible：自动化运维工具，用于配置和管理网络设备。Putty：SSH和Telnet客户端，用于远程登录和管理网络设备。Docker：容器化技术，用于构建和运行应用程序。Mininet：一个用于实验和测试SDN和其他网络创新的开源网络模拟器。 网络工程师详细学习路线+配套视频&amp;华为认证HCIA/HCIP/HCIE 最新题库 需要的朋友可以点赞收藏留言“已关注，求分享”
三、总结 初学者者和零基础的同学可以通过制定明确的学习路线规划，结合丰富的学习资源和实践经验，不断提升自己的技术水平和竞争力。同时，也要保持对新技术的敏感度和好奇心，不断学习和掌握新技术，为未来的职业发展打下坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc2a7d54c3a60427a19a74350ca0873/" rel="bookmark">
			docker打包springboot镜像，并运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker打包springboot镜像，并不是简单的将springboot项目的jar包上传容器里，然后启动。这个操作很简单，但是如果我每次要查看容器中的日志就需要每次都进入容器内部进行查看，这就非常麻烦了。
本文用一个简单的springboot项目举例子，来完成docker打包springboot镜像，并运行。
构建容器服务一共可以分为四步：
1，编写Dockerfile
2，docker build 构建镜像（根据Dockerfile构建）
3，docker run 镜像
4，docker push 镜像
第一步就是编写Dockerfile，Dockerfile是我们要打docker镜像的脚手架，也就是说我们的docker镜像就是根据Dockerfile来打的。（名称必须是这个，注意大小写）
简单的Dockerfile文件内容：
FROM openjdk:8 COPY *.jar /app.jar CMD ["--server.port=8080"] EXPOSE 8080 ENTRYPOINT ["java","-jar","/app.jar"] Dockerfile文件内容解释：
FROM openjdk:8 指定基础镜像，用于构建当前镜像的基础。也就是说我们要打镜像的基础包，我们程序运行所需要的环境。Springboot运行需要java8，那就需要再jdk8的基础上构建自己的镜像。
COPY *.jar /app.jar 将文件从主机复制到镜像中。我们的镜像当中需要包含的文件，比如说需要jar包，就需要将jar包放到镜像中去，需要其他文件，比如说某些静态资源，我们同样可以使用COPY放到镜像当中去。要注意第一个参数为宿主机的地址，后面的参数为镜像地址。宿主机的地址可以使用相对路径，即./*.jar。
CMD ["--server.port=8080"]
ENTRYPOINT ["java","-jar","/app.jar"]
设置容器的启动命令，也就是我们docker run时，容器里面所执行的命令。
EXPOSE 8080 指定容器对外暴露的端口，即docker容器启动后，通过什么端口访问它呢？一般情况下都配置成我们的tomcat端口。
第二步就是docker build 构建镜像（根据Dockerfile构建）。
将我们的Dockerfile文件编写完成后，和需要打成镜像的jar包放到同一目录下。
然后将springboot项目打jar包：
找到该jar包，并上传Linux：
然后执行命令：
docker build -t test:1.0.1 . 即镜像包的名称为test，版本号为1.0.1。如果不写后面的版本号，则版本号默认为latest。 执行结果：
执行命令启动镜像：
查看运行的服务：
查看日志：
启动成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0aebbd50a033e73222a6035a5eaa43/" rel="bookmark">
			网格bfs，LeetCode 2684. 矩阵中移动的最大次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 1、题目描述 给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。
你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：
从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。 返回你在矩阵中能够 移动 的 最大 次数。
2、接口描述 ​cpp class Solution { public: int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { } }; python3
class Solution: def maxMoves(self, grid: List[List[int]]) -&gt; int: 3、原题链接 2684. 矩阵中移动的最大次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e0aebbd50a033e73222a6035a5eaa43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd0d4a547fb495cbc15b0b917985881/" rel="bookmark">
			C# 面试题及答案整理，最新面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释C#中的垃圾回收机制是如何工作的。 C#中的垃圾回收（GC）机制是CLR（公共语言运行时）的一部分，负责自动管理内存，具体工作原理如下：
1、分代回收： GC将对象分为0代、1代和2代三代，新创建的对象属于0代。随着回收过程的执行，存活的对象会移到更高的代中。因为新生代对象生命周期短，GC更频繁地回收低代对象，减少了回收高代对象的需要，从而提高了垃圾回收的效率。
2、标记-清除： GC工作时，首先标记所有从根对象（静态字段、局部变量等）可达的对象，未被标记的对象即为垃圾。然后，GC清除未被标记的对象，并回收其占用的内存。
3、压缩： 清除垃圾对象后，GC可能会执行内存压缩，移动对象来消除由已回收对象留下的空闲空间，以避免内存碎片。
4、终结器执行： 对于含有终结器的对象，GC会在回收前调用其终结器，为对象的资源释放提供一个机会。终结器执行后，对象再次成为回收的目标。
解释C#中的委托和事件之间的区别。 委托和事件是C#中用于实现回调和事件驱动编程的机制，它们之间的区别主要表现在：
1、概念区别： 委托是一种引用类型，可以将其视为持有一个或多个方法的引用的对象，这些方法可以有返回值并接受参数。事件是一种特殊的委托类型，用于实现事件发布/订阅模型，使对象能够通知其他对象发生了某些事情。
2、使用场景： 委托主要用于回调和定义方法签名，允许将方法作为参数传递给其他方法。事件用于实现观察者模式，允许一个对象通知其他对象发生的特定事件。
3、访问控制： 委托可以被任意地赋值和调用，而事件提供了更严格的访问控制。事件只能在声明它的类或结构内被触发（调用），但可以在其他类中通过+=和-=操作符进行订阅或取消订阅。
4、设计意图： 委托强调的是行为的抽象和方法的封装，而事件强调的是状态变化和对象间的通信。
解释C#中的接口和抽象类的区别及应用场景。 接口和抽象类是C#中用于实现多态和代码抽象的两种机制，它们的主要区别和应用场景如下：
1、实现方式： 接口（interface）仅声明方法和属性，不包含实现。一个类可以实现多个接口。抽象类（abstract class）可以包含实现的方法（包括抽象方法和具体方法）和属性。一个类只能继承一个抽象类。
2、成员类型： 接口只能包含方法、属性、事件、索引器的声明，不能包含字段、构造函数。抽象类可以包含字段、构造函数和声明为abstract的抽象成员。
3、使用场景： 接口适用于定义系统间或模块间的契约，强调功能的多样性和灵活的实现。抽象类适用于当多个类之间存在共享代码时，强调代码的复用性。
4、访问修饰符： 接口成员默认是public的，不能定义为private或protected。抽象类成员可以有访问修饰符，如public、protected或private。
解释C#中值类型和引用类型的区别。 C#中值类型和引用类型的主要区别在于存储位置、赋值行为和默认值：
1、存储位置： 值类型的变量直接存储数据，通常位于栈上。引用类型的变量存储数据的内存地址，这些数据位于托管堆上。
2、赋值行为： 值类型的赋值会创建数据的一个新副本，变量之间的操作互不影响。引用类型的赋值不复制对象本身，而是复制引用，因此多个变量可以引用同一个对象，一个变量的改变会影响到其他所有引用该对象的变量。
3、默认值： 值类型的默认值通常是0或false（对于bool类型），而引用类型的默认值是null，表示不指向任何对象。
4、包含类型： 值类型包括基本数据类型（如int、double、bool）和结构体（struct）。引用类型包括类（class）、接口（interface）、委托（delegate）和数组。
解释C#中的LINQ是什么，它是如何工作的？ LINQ（Language Integrated Query）是C#中的一项功能，它允许以声明式的方式对数组、集合、XML、数据库等数据源执行查询操作。LINQ通过提供一致的查询语法，使得操作不同数据源的查询可以具有相同的形式。
LINQ的工作原理主要基于以下几个核心组件：
1、标准查询运算符： LINQ提供了一系列标准的查询运算符，如Where、Select、OrderBy等，这些运算符是以扩展方法的形式实现的，可以作用于实现了IEnumerable&lt;T&gt;或IQueryable&lt;T&gt;接口的任何集合。
2、表达式树： 对于LINQ to SQL或LINQ to Entities等场景，查询表达式会被转换成表达式树，然后再转换成特定数据源能够理解的查询语言，如SQL语言，这使得LINQ能够在数据库层面执行优化。
3、延迟执行： LINQ查询默认是延迟执行的，即只有在真正遍历查询结果时，查询表达式才会被执行。这种机制提高了性能，并允许创建更为复杂的查询计划。
讨论C#中的异步编程模型，包括它的优点和使用场景。 C#中的异步编程模型主要是基于async和await关键字实现的，它使得编写非阻塞的异步代码变得简单和直观。
优点：
提高响应性： 异步操作允许应用在等待IO操作（如文件读写、网络请求等）完成时继续执行，提高了应用的响应性。
资源利用率： 通过非阻塞的方式执行IO密集型任务，可以更高效地利用系统资源，尤其是在GUI应用和Web应用中避免UI线程冻结。
简化代码结构： 使用async和await编写异步代码，可以保持类似同步代码的清晰结构，降低复杂度。
使用场景：
Web应用： 异步处理HTTP请求，提高服务器并发处理能力。
桌面应用： 执行耗时的后台任务而不冻结UI界面，如数据加载、文件处理等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd0d4a547fb495cbc15b0b917985881/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/8/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>