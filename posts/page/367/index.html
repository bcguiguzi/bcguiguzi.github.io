<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc0efa1e1642b476100e543823d048d/" rel="bookmark">
			docker基于centos构建jdk8&#43;tomcat8镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉取基础镜像docker pull centos 运行并进入容器内安装jdk8,tomcat8,提交镜像marioli/sunlight:v1编写dockerfile FROM marioli/sunlight:v1
MAINTAINER li
ENTRYPOINT /usr/tomcat8/bin/catalina.sh run
运行 docker build -t marioli/sunlight:v2 .
docker run 指定volume，端口映射，容器内默认8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4034721f3203610d62f2c75c04a398a2/" rel="bookmark">
			React 组件之间参数传递，正传props，逆传，同级传值，跨组件传值context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下主要是react四种组件传值方式 1、正传props： 1.1、rcc快速创建组件
1.2、在调用组件的地方传值
1.3、在组件中接收数据
2、逆传： 2.1、在父组件中先声明一个函数，该函数有一个形参来接收子组件逆向传递过来的数据，
2.2、在父组件中将这个函数的调用方式传递给子组件
2.3、在子组件中通过单击事件来触发，bind中第一个参数修改this指向，第二个参数为要传递的数据
2.4逆传案例二：（实现的是在子组件中删除组件的数据） 2.4.1在子组件使用this.props.xxx来接收父组件传递过来的数据，并且使用.bind(this.“你要传给父组件的数据”)
**注意：**下面这一步使用到了结构赋值
2.4.2、在子组件被调用的时候，传递进去一个函数，但是这个函数必须有一个形参，这个形参用来接收子组件传递过来的数据
3、同级传值—pubsub-js： 同级传值使用pubsub-js
3.1、下载 npm install --save pubsub-js
3.2、在第一个组件中进行数据抛出 PubSub.publish(“事件名”,“数据”)
3.3在同级组件接收抛出来的数据
4、跨组件传值context： react 组件间传递数据是通过 props 向下，是单向传递的，从父级一层一层地通过 props 地向下传递到子子孙孙，有的时候我们组件一层一层的嵌套多层，这样这种方式一层一层传递麻烦，如果想跃层传递，这就会用到 context。
context使用
context：上下文对象
作用 是用来进行跨层级传值
Provider对象 生产者----&gt;用来生产数据
Consumer对象 消费者----&gt;用来使用数据
4.1、在src下创建文件与文件夹用来容纳context对象
4.2、创建内容并且引用createContext对象
4.3、全局引用（在src根目录下的index.js中全局引用）
4.4、在任意位置使用
要使用先引用
import {Consumer} from “…/myprovider/myProvider.js”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e52a90fa9241d3f5bc3fcae6447d8c0/" rel="bookmark">
			VS配置RTKLIB（卫星定位开源代码）环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RTKlib代码调试教程-Visual Studio 2019
你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
##RTKLIB-rtklib_2.4.3
提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
@RTKlib代码调试教程-Visual Studio 2019
提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、RTKlib是什么？ 由日本东京海洋大学开发（Tokyo University of Marine Science and Technology
），笔者查到最早的介绍是一篇日文的，《RTK-GPS用プログラムライブラリRTKLIBの開発?評価および応用》，其介绍的为RTKLIB ver.1.1。另有一篇论文《Development of the lowcost RTK GPS receiver with an open source program package RTKLIB》也可以看下。
其主要功能如下：
支持标准的GPS、GLONASS、QZSS和SBAS的为精确定位算法（目前此版本不支持Galileo系统）
支持多种动态、静态卫星定位方式（单点定位、DGPS、载波相位动态差分定位RTK、静态、移动基站、PPP）
支持全球定位导航系统的多种标准格式和协议
二、使用步骤 1.在Visual Studio 2019下新建项目，选择Windows控制台应用程序，项目所在路径自己选择，路径记为*\，项目命名为rtklib； 2.解压RTKLIB-rtklib_2.4.3安装包，将安装包下src文件夹复制到*\rtklib\rtklib\，并重命名为rtklibsrc； ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200922210701822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA5OTc3,size_16,color_FFFFFF,t_70#pic_center
3.在界面左侧右击rtklib项目，选择“添加”-“新建筛选器”，右击新建的筛选器并重命名为rtklibsrc；同样的，右击rtklibsrc，创建新的筛选器并命名为rcv； 4.右击rtklibsrc，选择“添加”-“现有项”，* \rtklib\rtklib\rtklibsrc\，全选所有的.c文件，点击“添加”，同样地，将* \rtklib\rtklib\rtklibsrc\rcv下所有的.c文件添加到（3）中新建的rcv下； 5.右击rtklib项目，选择“属性”，找到“预编译头”，在右侧选择“不使用预编译头”，点击确定； 6.Ctrl+F5运行程序，程序报错，要么按照说明中将fopen等对应改成fopen_s等，要么右击rtklib项目，选择“属性”，找到“预处理器”-“预处理器定义”，点击编辑，加上“_CRT_SECURE_NO_WARNINGS”，点击“确定”退出； 7.Ctrl+F5运行程序，程序报错：C1083 无法打开包括文件：rtklib.h: No such file or directory。此时，仍右击rtklib项目，选择“属性”-“常规”-“附加包含目录”，编辑选择*\rtklib\rtklib\rtklibsrc，例如笔者的路径为E:\PPP\program\RTKlib\rtklib\rtklib\rtklibsrc；点击确定退出。 8.Ctrl+F5运行程序，程序报错：C4996 ‘inet_addr’:Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings；类似（6），在“预处理器定义”中添加_WINSOCK_DEPRECATED_NO_WARNINGS，点击确定退出。 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e52a90fa9241d3f5bc3fcae6447d8c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9282dfbc375c643d54b3d3a6753f70cb/" rel="bookmark">
			MySQL - json_search 小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中遇到某个表中采用text格式存储了压缩后的JSON字符串，在代码中通过 json_search方法对 JSON 中的内容进行搜索，特此整理有关json_search的内容。MySQL在5.7的官方文档中就有关于JSON的相关说明，更详细的可直接参考官方文档。
JSON_SEARCH 用法 JSON_SEARCH(json_doc，one_or_all，search_str [，escape_char [，path] ...]) 说明 通过JSON_SEARCH函数，返回符合查询条件的key对应的的JSON路径所组成的数组，若不存在，则返回NULL
以下情况返回NULL
若 json_doc ，search_str，或path参数中任何一个为NULL，则返回NULL文档中不存在pathsearch_str未找到 以下情况报错
json_doc为不合法的JSON文档path为不合法的路径表达式one_or_all 参数非 one 或 all 字段解释 json_doc：要查询的Json 文档one_or_all：查询的终止条件 one：搜索在第一个匹配项后终止，并返回一个路径字符串。未定义首先考虑哪个匹配。all：搜索返回所有匹配的路径字符串，因此不包括重复的路径。如果有多个字符串，它们将自动包装为一个数组。数组元素的顺序是不确定的。 search_str：搜索参数 escape_char：指定转义符。escape_char 参数指定时要求必须是常量（为空或者一个字符），当escape_char参数为NULL或者不存在的情况下，系统默认使用 \ 作为转义字符。path指定的范围始终是要搜索或对其进行操作的文档，并以前导$字符表示。路径分支由句点字符 .分隔。数组中的单元格由[N]表示，和正常访问数组元素格式相同，例如 $.x 代表JSON文档中x对应的值，$[1].y代表JSON文档中第二位数据元素中y所对应的值 注：在search_str中，通配符 %和 _ 可以如同在 LIKE 上一样运行，其中 % 用于匹配多个字符（包括0）， _ 则仅可匹配一个字符 官方示例 mysql&gt; SET @j = '["abc", [{"k": "10"}, "def"], {"x":"abc"}, {"y":"bcd"}]'; 对比one和all的区别
很直观的能看除one获取到一个符合条件的路径后就终止了，而all则返回全部
mysql&gt; SELECT JSON_SEARCH(@j, 'one', 'abc'); +-------------------------------+ | JSON_SEARCH(@j, 'one', 'abc') | +-------------------------------+ | "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9282dfbc375c643d54b3d3a6753f70cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6daab421b16b3aff3374f28d5d6cb444/" rel="bookmark">
			OpenVAS下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天写一下OpenVAS的安装步骤。我是在VMware虚拟机上安装的。
OpenVAS是一款开源的网络漏洞扫描器，自从Ness收费后，分支出来的项目。
下载连接是https://www.greenbone.net/en/install_use_gce/。
接下来打开虚拟机，选择典型，下一步。
选择稍后安装，下一步。
选择其他和其它64位，下一步。
写虚拟机名字，编辑安装位置，，下一步。
磁盘尽量比建议的大一些，下一步。
点击自定义硬件。
内存选择2G，处理器选择2核，选择刚刚下载ISO镜像文件。
点击完成。
开启虚拟机，安装openVAS。
选择第一项，OK。 这是问你是否清除磁盘数据，选择Yes。 等待中。
建立用户名和密码。
选择yes.
选择yes。
输入刚刚创建的用户和密码。
选择第一个，ok。
选择第二个，ok。
选择第二个，ok。接下来就是创建用户，还有就是填写密码。
这个是查看信息，ok。
登录刚才的ip地址，这里选择接受风险并继续。
configuration-&gt;targets-&gt;new target scans-&gt;tasks-&gt;new task
**结束** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9447372370a7228c691bf7add022ca6/" rel="bookmark">
			svn中文扩展包安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svn中文扩展包安装
查看SVN版本
打开官网SVN官网，查找对应版本
最后点击下载即可
安装语言包
安装完成后
最后重启svn
打开cmd，运行 svnserve -d -r /opt/svn/
安装完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2754456d40c16750b83f1868d00296/" rel="bookmark">
			python中如何使用re.sub替换模式字符串的一部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import re html_tag = re.compile("&lt;(.*?) .*?&gt;") src = "Legislature, &lt;a href=\"http://www.legis.state.tx.us/BillLookup/Text.aspx?LegSess=81R&amp;amp;Bill=HB2626\" target=\"_blank\"&gt;House Bill No. 2626&lt;/a&gt;&lt;/p&gt;" tgt = re.sub(html_tag, r"&lt;\1&gt;", src) #Legislature, &lt;a&gt;House Bill No. 2626&lt;/a&gt;&lt;/p&gt; 注意repl字符串一定要加r，否则\1在结果里会变成\u001，而不是pattern字符串里第一个小括号括出的部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148788d23b4f6691fd81f08b4020b65e/" rel="bookmark">
			SI5338 时钟芯片驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该时钟芯片可以做到任意频率的时钟输出 控制接口为IIC接口，主要的资料为 ：
AN428.pdf
Si5338-RM.pdf
Si5338芯片手册
我们首先应该芯片手册，然后对应寄存器说明为Si5338-RM.pdf，AN428里给了一个单片机的demo
此外由于寄存器比较多，我们可以借助官方提供的工具软件
设置好参数通过export
可获取对应的寄存器的值
下面是大概的IIC时序代码：
/*
Si5338.cCreated on: 2020年9月13日 Author: Administrator */
#include"Si5338.h"
/### (FPGA -&gt; scl si5338) — BIT_5
void Si5338_SCL_SET(unsigned char x)
{
GPIO_DIRM_2 = GPIO_DIRM_2 | (0x00000001 &lt;&lt; 4); // 设定为输出(1:输出;0:输入)
GPIO_OUT_EN_2 = GPIO_OUT_EN_2 | (0x00000001 &lt;&lt; 4); // 输出使能
if(x != 0) GPIO_DATA_O_WO = GPIO_DATA_O_WO | (0x00000001 &lt;&lt; 4);
else GPIO_DATA_O_WO = GPIO_DATA_O_WO &amp; (~(0x00000001 &lt;&lt; 4));
}
/### (FPGA -&gt; SDA) — BIT_6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148788d23b4f6691fd81f08b4020b65e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c20b64c86548cec0df082e5c1144cf3/" rel="bookmark">
			SPEC中g单位统一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果输入速度单位为m/s，加速度为m/s^2，则 g=9.81.
如果输入速度单位为cm/s，加速度为cm/s^2，则 g=981.
如果输入速度单位为mm/s，加速度为mm/s^2，则 g=9810.
如果输入加速度单位为g （如，PEER数据库中加速度默认单位为“g”），则SPEC参数g=1
反之，如输入g=981，则速度为cm/s，加速度为cm/s^2。
一定要特别注意单位的统一！！！否则算出来的反应谱单位会有问题...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a98d63078a1b4e17587bc7cfc0bc21/" rel="bookmark">
			【论文解析】从头开始打造Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在谷歌大作Attention is all you need中提出了一种基于seq2seq架构的self-attention特征抽取机制，兼具CNN的并行化优点和RNN的长距离依赖特点，成为后续以MLM为主要任务的Bert、Roberta、albert预训练模型（利用Transformer中的Encode block）以及以AR-ML为主要任务GPT系列模型（利用Transformer中的Decode block）的主要模块，并在各类任务上取得了前所未有的成功。
本博客在Transformer浅析一文中已经简要介绍了该模型的特点和细节，本文参照The Annotated Transformer），进行了代码实现。
为方便代码对照，先po一张Trnasfomer的结构图：
再以树形图的形式，自上而下给出各模块的组织关系：
不难发现，其中PieceWord Embedding、Postion Embedding、MultiHeadAttention、FFN、LayNorm、SkipConnection等均是可复用的block，因此按照搭积木的原则，自下往上给出如下的代码实现：
import math import numpy as np import torch import torch.nn as nn import torch.nn.functional as F from copy import deepcopy def clones(module, N): """ 重复单元的堆叠 :param module: 模型layer :param N: 堆叠数 :return: """ return nn.ModuleList([deepcopy(module) for _ in range(N)]) class Embedding(nn.Module): """ Word-Embedding层 在原始Transformer中，source-embedding、target-embedding，以及decoder-embedding三者是共享的 在获得look-up table中的词向量后，需要乘以sqrt(model_d) """ def __init__(self, vocab, d_model): super(Embedding, self).__init__() self.lut = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a98d63078a1b4e17587bc7cfc0bc21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8096065c17045e8c47bb59b7263b0fb2/" rel="bookmark">
			Python爬虫之查找自己浏览器headers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python爬虫查找自己浏览器headers
每个浏览器都有自己的headers，因为headers要模仿你自己的浏览器向网页发送信息。如果使用Python进行爬取页面时，使用了别人的headers可能会导致爬取不到任何数据（因为代码在你自己的电脑运行，所以无法模拟别人的浏览器）。
比如，在进行学习时，或多或少都会参考别人的代码，这时如果你将别人代码中的headers直接复制过来，就可能导致代码运行没有错误，但是就是爬取不到任何数据。
如何查找自己浏览器的headers。
以谷歌浏览器为例——随便打开一个网页，例如打开https://baike.baidu.com/item/乘风破浪的姐姐，右键点击‘检查’或者按F12，出现下图页面。
点击最上方选项卡中的‘Network’选项，再按F5，在‘name’框中会出现一个选项，点击该选项，在右侧点击‘headers’选项，在最下方找到‘User-Agent:’，粘贴到自己代码即可。如下图
将User-Agent:粘贴到自己代码headers中即可：
headers = { 'User-Agent': 'ozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36' } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a1c5b2fe0dad84e0f37d9237c8be69/" rel="bookmark">
			耳机降噪技术-ANC、ENC、DSP、CVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在耳机市场的主动式降噪就是ANC、ENC、CVC、DSP等降噪技术。
ANC降噪
ANC降噪（Active Noise Control，主动降噪）的工作原理是麦克风收集外部的环境噪音，然后系统变换为一个反相的声波加到喇叭端，最终人耳听到的声音是：环境噪音+反相的环境噪音，两种噪音叠加从而实现感官上的噪音降低，受益人是自己。
ENC降噪
ENC（Environmental Noise Cancellation，环境降噪技术），能有效抑制90%的反向环境噪声，由此降低环境噪声最高可达35dB以上，让游戏玩家可以更加自由的语音沟通。通过双麦克风阵列，精准计算通话者说话的方位，在保护主方向目标语音的同时，去除环境中的各种干扰噪声,受益人是通话对方。
DSP降噪
DSP是英文(digital signal processing)的简写。主要是针对高、低频噪声。工作原理是麦克风收集外部环境噪音，然后系统复制一个与外界环境噪音相等的反向声波，将噪音抵消，从而达到更好的降噪效果。DSP降噪的原理和ANC降噪相似。但DSP降噪正反向噪音直接在系统内部相互中和抵消。 受益人是本人。
CVC降噪
CVC（Clear Voice Capture）是通话软件降噪技术。主要针对通话过程中产生的回声。通过全双工麦克风消噪软件，提供通话的回声和环境噪音消除功能，是目前蓝牙通话耳机中最先进的降噪技术。受益人是通话对方。
上述文章阐述归伦茨科技公司所有，转载请注明出处，更多相关信息欢迎关注微信公众号：lenze_tech或微信号：lenzetech)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98440902bf428d0a34e72cd9d19f3c1/" rel="bookmark">
			第三章 MongoDB的增删改查（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 MongoDB的增删改查（3） 本章介绍了MongoDB的常用操作，具体包括如下：
插入文档删除文档更新文档查找文档 1.查找文档 db.collection.find(query, projection)
参数类型说明querydocument可选。
指定查询条件，返回所有满足条件的文档。projectiondocument可选。
指定返回字段。如果没有指定，返回文档的所有字段 简单查询 db.books.remove({}) db.books.insertMany( {"_id": 1, "name": "java", amount: 20} {"_id": 2, "name": "mysql", amount: 30} {"_id": 3, "name": "linux", amount: 40} ) -- 查找所有文档 db.books.find({}) -- 等值查询 db.books.find({"name": "java"}) -- 返回指定字段 _id字段会默认返回, 除非指定{_id: 0} db.books.find({"_id": 1}, {"name": 1}) { "_id": 1, "name": "java" } 使用操作符查询 Mongodb提供许多查询操作符帮助我们查询在集合中的文档
使用 $in 操作符返回集合中 _id 等于5或者 8 db.bios.find( { _id: { $in: [ 5, 6] } } ) 使用 $gt 操作符返回出生日期在 1998-01-01 之后的文档 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98440902bf428d0a34e72cd9d19f3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baa2a40b005af2243f8db557995d593/" rel="bookmark">
			学习无霍尔传感器的BLDC方波调速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无霍尔传感器的BLDC方波调速 基本原理反电动势法无感BLDC的转子位置检测无感BLDC换相在功率开关管关断状态时采样 无感BLDC的“三段式”启动 程序应用按键读取六步换相驱动反电势过零点检测“三段式”启动闭环自动调速 基本原理 反电动势法 无位置传感器的无刷直流电机的位置估计方法可以从多个方面论述，本文重点讲述反电势转子位置检测技术。
无刷直流电机中，受定子绕组产生的合成磁场的作用，转子沿着一定的方向连续转动。电机定子上放有电枢绕组。因此，转子一旦旋转，就会在空间形成导体切割磁力线的情况。根据电磁感应定律可知，导体切割磁力线会在导体中产生感应电势。所以，在转子旋转的时候就会在定子绕组中产生感应电势，即运动电势，一般称为反电动势或反电势。
当BLDCM的某相绕组反电势过零时，转子直轴与该相绕组轴线恰好重合。因此只要检测到各相绕组反电势的过零点，就可获知转子的若干个关键位置。再根据这些关键的转子位置信号，做相应的处理后控制BLDCM换相，实现BLDCM连续运转，这就是“反电势法”BLDCM控制。
无刷直流电机绕组反电势的过零点严格地反映了转子磁极位置。因此，只要能够准确的检测到绕组反电势的过零点信号，就可以判断出转子的关键位置。经过30°电角度延时处理后，就可以作为绕组的换相时刻。再根据功率管的导通顺序触发相应的功率管，就能够实现无刷直流电机的换相操作，保证电机按固定的方向连续旋转。这样可以保证电机换相满足“最佳换相逻辑”，减小转矩脉动。
无感BLDC的转子位置检测 为获得转子当前位置，需要采用某种转子位置检测环节。在有霍尔传感器的系统中，位置传感器的存在，增加了无刷直流电机的重量和结构尺寸，且不易安装和维护。同时，传感器的安装精度和灵敏度直接影响电机的运行性能。另外，霍尔传感器存在一定的磁不敏感区；其次，过多的传输线使系统易受干扰且可靠性降低；再次，在某些恶劣的工作环境中，常规的位置传感器根本就无法使用。因此,使用无感无刷直流电机控制，具有其一定的优势。
对于无位置传感器的直流无刷电机，必须通过一定的方法检测转子位置信息才能准确换相。反电动势法是其中最成熟和应用最广泛的位置检测方法。在六步换相控制中，每一个换相周期，将有一相绕组处于不导通状态。因此通过检测第三相反电动势信号、可检测到转子磁极在该绕组经过的时刻。
无感BLDC换相 以120°霍尔式位置传感器为例，三相无刷直流电机反电势和传感器输出信号间相位关系如图。
当转子在0°电角度位置时，A相反电动势过零点。再延后30°时,HALL A传感器检测到边沿信号，此时需要换相。即30°电角度时，AB绕组通电，开始检测C相绕组反电动势。当转子位置在60°时，C相反电动势过零点。再延后30°时，HALL C传感器检测到边沿信号，此时需要换相。即90°电角度时，AC绕组通电，开始检测B相绕组反电动势。以此类推。反电动势的检测总在第三相未通电的绕组上进行。在检测到过零点时，需要再延时30°电角度进行换相。
因此，使用无感无刷直流电机控制反电动势过零点的检测是关键。
在功率开关管关断状态时采样 全数字反电势法根据A/D采样时刻的不同可分为三种：在功率开关管导通时刻采样、在功率开关管关断时刻采样和所有状态时刻采样。
图中显示了六步换相方式中单相的反电动势波形。在PWM OFF时，进行检测反电动，以得到与0值相等时为过零时刻。在T1-T2区间，该相反电动为增大过程，由负值增加到正值的过程中检测到过零点；而在T4-T5区间，该相反电动势由正值减到负值过程中检测到过零点。通过PWM OFF采集方法，可很方便地得到反电动势过零点。
无感BLDC的“三段式”启动 （1）转子预定位：给任意两相通电，通电一段时间后，转子会转到与该通电状态对应的预知位置，完成转子的定位；
（2）外同步加速：根据预先设计好的优化加速曲线不断提升换相信号的频率及增大端电压实现电机的外同步加速；
（3）运行状态切换：当电机加速到一定转速后，就可以准确地检测到反电动势的过零点信号，并用此代替外同步信号，实现外同步运转到自同步运转的切换。
程序应用 相关函数初始化参数配置：系统时钟，中断，GPIO，ADC和定时器等
#define KEY_PORT GPIOC #define KEY1_Pin	GPIO_Pin_15 #define KEY2_Pin GPIO_Pin_5 #define T1CH1NON() PBSET = PBO_T1CH1N #define T1CH1NOFF() PBRESET = PBO_T1CH1N #define T1CH2NON() PBSET = PBO_T1CH2N #define T1CH2NOFF() PBRESET = PBO_T1CH2N #define T1CH3NON() PBSET = PBO_T1CH3N #define T1CH3NOFF() PBRESET = PBO_T1CH3N #define PBO_T1CH1N GPIO_Pin_13 #define PBO_T1CH2N GPIO_Pin_14 #define PBO_T1CH3N GPIO_Pin_15 按键读取 启动和停止后换向
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4baa2a40b005af2243f8db557995d593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ce07c7828233332046396f81976fb9/" rel="bookmark">
			TCP/IP——传输层与应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天整理一下传输层与应用层的一些重要的内容。
一、传输层 TCP
1、tcp报文格式：
源端口：标识哪个应用程序发送。
目的端口：标识哪个应用程序接收。
序号字段：本报文段所发送的数据的第一个字节的序号。
确认号：上次以成功接收到的数据字节序号加1，只有ACK为一时，这个字段才有效。
首部长度：最大60字节，最小是20字节。即段起始到数据起始的长度。
保留：必须填0。
URG：代表这个数据是否需要紧急传输。
ACK：ACK=1,确认号有效；ACK=0，确认号无效。
PSH：若PSH=1，就立刻把报文段交给应用进程。
RST：若RST=1，说明tcp连接有问题，需要释放连接，然后重新连接。
SYN：若SYN=1，说明这是一个连接请求或连接接受请求。
FIN：若FIN=1，说明这是一个释放连接的请求。
window：TCP的流量控制，这个值是接收端正期望接收的字节数。窗口最大为65535字节。
检验字段：在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。
紧急指针：只有URG=1时，这个字段才有效。指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。
选项字段：选项表结束，无操作，最大报文段长度，窗口扩大因子，时间戳等。
填充字段：用来补位，让整个首部长度是4字节的整数倍。
TCP负载：可变。
2、三次握手与四次挥手。
（1）三次握手：
第一次握手：客户端发送SYN报文，进入SYN_SENT状态。
第二次握手：服务器接收到这个报文，回复一个ACK报文，还会发送SYN报文，进入SYN_RCVD 的状态。
第三次握手：客户端收到ACK报文，会回复服务器一个ACK报文。服务器收到这个报文，双方进入连接状态。
（2）四次挥手：
第一次挥手：客户端发送FIN报文，进入FIN_WAIT1状态。
第二次挥手：服务器收到这个报文，回复一个ACK报文。服务端进入CLOSE_WAIT状态，客户端收到服务端的确认后，进入FIN_WAIT2状态。
第三次挥手：服务器发送FIN报文，进入LAST_ACK 的状态。
第四次挥手：客户端收到这个报文，回复ACK报文，客户端处于TIME_WAI 状态等待2MSL后，客户端才进入CLOSED状态。服务器收到这个报文后，就会处于进入CLOSED状态。
注：MSL报文段最大生存时间。等待2MSL是为了防止ACK丢失，还有就是在等待2MSL时间内，客户端的IP地址加上端口与服务器的IP地址加上端口不能在使用。
注：四次挥手无论是客户端先断开连接还是服务器断开连接都可以，不影响四次挥手。
3、tcp如何保证可靠传输
（1）三次握手
（2）合理分片
（3）超时重发
（4）确认应答
（5）校验和
（6）对失序数据重新排序
（7）丢弃重复数据
（8）流量控制，tcp连接的每一方都有一个缓冲区，因为有的主机发的快，有的发的满，为了防止快的主机让慢的主机出现缓冲区溢出。
（9）拥塞控制，当网络拥塞就减少数据发送。
TCP粘包/拆包
拆包：一个完整的业务会被tcp拆分多个包
粘包：把多个小包封装成一个包
原因：
1、应用程序写入数据的字节大于套接字发送缓冲区的大小
2、MSS大小的tcp分段；mss=tcp报文长度-tcp首部长度
3、以太网的payioad大于MTU进行ip分片
解决方案：
1、消息定长
2、在包尾进行特殊字符分割
3、将消息分为消息头和消息尾
4、使用其它复杂协议，rtmp协议。
UDP
udp报文格式
发送进程：标识哪个进程发的。2字节
接收进程：标识哪个进程收的。2字节
Length：UDP首部加上UDP数据的字节数，最小为8。2字节
Checksum：覆盖UDP首部和UDP数据，是可选的。2字节
data：udp负载，可选。变长
TCP与UDP对比
三、应用层 URI：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81ce07c7828233332046396f81976fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ce7e4fa53c0d16ef56437639279ae6/" rel="bookmark">
			Vue提示 ： Named Route ‘test‘ has a default child route. When navigating to this named route (:to=“{nam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法是：即去除父级的name属性
因为当某个路由有子级路由的时候，这时候父级路由需要一个默认的路由，所以父级路由不能定义name属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0360d0a37b713c91e365528a538282/" rel="bookmark">
			Flutter Web-调研与简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter Web Flutter 1.9 稳定版正式将独立的 Flutter for web 仓库集成到 Flutter 的主仓库中。
Flutter 1.12 稳定版提供了改进的 Web 支持，但仍是beta版，不建议商用。
目前Flutter Web仍面临包体积大、性能差、资源缺乏等许多问题。
案例
Flutter Widget Livebook
Panache
Rivet
KENKEN 益智游戏
基本实现
Web引擎的实现大致需要三个步骤：构建组件、排版以及绘制。
组件的构建过程相对简单直接，将组件载入内存，监控它们的状态变化，并把需要更新的数据输送到排版、绘制阶段即可。得益于Dart最新的super-mixin特性，所有Flutter组件和组件框架都几乎能被完美编译为JavaScript。
排版阶段相对复杂，最大的挑战来自文字排版。Flutter使用段落（Paragraph）的 layout 方法完成文字排版，但Web端却没有相应的文字排版API。此问题的解决方法：将文本插入到html dom中，先让浏览器完成排版，然后再读取回文本的高度、宽度等各种属性。
最后的也是最复杂的绘制阶段。Web端可用的特性有HTML/CSS、Canvas、SVG和WebGL等，其中WebGL过于底层和复杂，而纯HTML/CSS的实现又要求改动Flutter现有的API。项目组还在积极研究此阶段的最优方案，目前的候选方案有两种：HTML+CSS+Canvas 和 CSS Paint API。
HTML+CSS+Canvas在所有现代浏览器都可以正常工作，兼容性最高，是目前首选的方案。Flutter上层框架会生成大量层，其中简单的图片层使用HTML+CSS绘制，且称之为DomCanvas实现；复杂的图片层则使用2D Canvas绘制，并称之为BitmapCanvas实现（浏览器底层使用Bitmap实现canvas）。除图片（Picture）外的其他层，会被转换为自定义html标签表示，比如：Opacity 会被转换为 。这样，Flutter页面就被转换为由html标签、DomCanvas以及BitmapCanvas组成的树状结构。
优先考虑HTML+CSS表达，当HTML+CSS无法表达图片的时候，会使用Canvas来绘制。但2D Canvas在浏览器中是位图表示，会造成像素化下的性能问题。
Flutter 现在通过最小化的 web/index.html 文件创建一个 Web 运行器，该文件负责引导针对 Web 编译的 Flutter 代码。有了这个文件后，你就可以使用 Flutter CLI 工具或 IDE 插件在 Web 上编辑和运行 Flutter 应用程序。
Flutter web site
Merits 1、web端、移动端、桌面应用、嵌入式应用复用一套代码
2、兼容性强，采用Chrome开发，产物在其他浏览器都能兼容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0360d0a37b713c91e365528a538282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab0cfc39dd16808a56efd6c13861a37/" rel="bookmark">
			jdk-12.0.2 64位最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程：
1、下载并且解压安装包，双击jdk-12.0.2_windows-x64_bin.exe并选择以管理员身份运行。
2、出现安装界面一直点击下一步，到安装目录文件位置，可自行更改文件安装路径，但是不能有中文路径，建议默认安装路径，选择好以后继续点击下一步。
3、安装好以后点击关闭，不用理会后续步骤选项，后续继续配置环境变量。
环境变量配置 1、右键点击计算机-&gt;右键属性-&gt;点击左侧的高级系统设置-&gt;点击环境变量，资源地址：jdk-12.0.2 64位最新版
2、然后点击新建，并且输入变量名JAVA_HOME，变量值是jdk安装地址，默认为【C:\Program Files\Java\jdk-12.0.2】，点击【确定】
3、同样新建另外一个变量名CLASSPATH，变量值为.;%JAVA_HOME%\lib，再次点击确定。
4、在系统变量框中选择Path，并点击编辑，再点击新建
5、输入%JAVA_HOME%\bin，点击确定
6、点击确定，
7、点击确定
8、键盘按win+r键打开运行，并且输入cmd，点击确定
9、英文输入法下输入java -version,并且回车，可以得到jdk版本。
10、输入java，然后继续回车
11、输入javac，再次回车，然后就安装完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc852a03dfd91b737b64d55bd61e5fb/" rel="bookmark">
			欧拉降幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉降幂 欧拉降幂bzoj3884. 上帝与集合的正确用法2019ICPC南昌预选赛网络赛 B. super_logCF906D. Power Tower 欧拉降幂 定理：
当 a a a 、 p p p 互质时， a b ≡ a b % φ ( p ) ( m o d p ) a^b\equiv a^{b\%\varphi(p)} (\mod p) ab≡ab%φ(p)(modp)当 b &lt; φ ( p ) b&lt;\varphi(p) b&lt;φ(p) 时， a b ≡ a b % φ ( p ) ( m o d p ) a^b\equiv a^{b\%\varphi(p)} (\mod p) ab≡ab%φ(p)(modp)当 b ≥ φ ( p ) b \ge \varphi(p) b≥φ(p) 时， a b ≡ a b % φ ( p ) + φ ( p ) ( m o d p ) a^b\equiv a^{b\%\varphi(p)+\varphi(p)} (\mod p) ab≡ab%φ(p)+φ(p)(modp) 细节：每次递归过程中维护的是指数，因此需要在 dfs 出口计算当前的指数，在 qpow 的过程中也通过指数的方式计算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc852a03dfd91b737b64d55bd61e5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3e8fbc9d8174d5884793ac1bbe1b2f/" rel="bookmark">
			[picoVR]曲面UIcurved UI 2.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/366/">«</a>
	<span class="pagination__item pagination__item--current">367/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/368/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>