<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355167d2e8d9e0ef1307c0d5afc52b87/" rel="bookmark">
			JupyterLab安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JupyterLab安装教程 安装miniconda或Anaconda 下载安装包进行安装
安装jupyter 创建虚拟环境 conda create -n jupyter python==3.8 安装jupyter和jupyterlab conda install jupyter jupyterlab windows配置 生成配置文件，下面这行命令将输出jupyter_notebook_config.py及其所在地址 jupyter notebook --generate-config 打开上述生成的文件，默认是xxx/.jupyter/jupyter_notebook_config.py，修改以下内容： c.NotebookApp.notebook_dir = '文件路径' linux配置 使用ipython设置密码，输入密码，记录输出的秘钥，后面会用到 ipython from notebook.auth import passwd passwd() 生成配置文件，下面这行命令将输出jupyter_notebook_config.py及其所在地址 jupyter server --generate-config 打开上述生成的文件，默认是/root/.jupyter/jupyter_server_config.py，修改以下内容： #让所有人都可以访问 c.ServerApp.ip = '*' # 这里的密码填写上面生成的密钥 c.ServerApp.password = '使用ipython生成的秘钥' # 禁用自动浏览器打开jupyter c.ServerApp.open_browser = False # jupyter lab服务器的端口 c.ServerApp.port = 8888 # 修改到可用的端口 # 允许远程访问 c.ServerApp.allow_remote_access = True # 工作根目录 c.ServerApp.root_dir = '/root' # 目标文件路径 启动JupyterLab jupyter lab --allow-root 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be87d8b228b75cd2c9b8e56bc2d71a9e/" rel="bookmark">
			Android Activity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activity是一个应用程序的组件，他在屏幕上提供了一个区域，允许用户在上面做一些交互性的操作， 比如打电话，照相，发送邮件，或者显示一个地图！Activity可以理解成一个绘制用户界面的窗口， 而这个窗口可以填满整个屏幕，也可能比屏幕小或者浮动在其他窗口的上方！
Activity用于显示用户界面，用户通过Activity交互完成相关操作一个App允许有多个Activity 1.Activity的概念与Activity的生命周期图：
注意事项：
onPause()和onStop()被调用的前提是： 打开了一个新的Activity！而前者是旧Activity还可见的状态；后者是旧Activity已经不可见！另外，亲测：AlertDialog和PopWindow是不会触发上述两个回调方法的~ 2.Activity/ActionBarActivity/AppCompatActivity的区别：
在开始讲解创建Activity之前要说下这三个的一个区别： Activity就不用说啦，后面这两个都是为了低版本兼容而提出的提出来的，他们都在v7包下， ActionBarActivity已被废弃，从名字就知道，ActionBar~，而在5.0后，被Google弃用了，现在用 ToolBar…而我们现在在Android Studio创建一个Activity默认继承的会是：AppCompatActivity! 当然你也可以只写Activity，不过AppCompatActivity给我们提供了一些新的东西而已！ 两个选一个，Just you like~
3.Activity的创建流程
好了，上面也说过，可以继承Activity和AppCompatActivity，只不过后者提供了一些新的东西而已！ 另外，切记，Android中的四大组件，只要你定义了，无论你用没用，都要在AndroidManifest.xml对 这个组件进行声明，不然运行时程序会直接退出，报ClassNotFindException…
4.onCreate()一个参数和两个参数的区别：
相信用as的朋友在重写Act的onCreate()方法时会发现，这玩意有两个参数：
可是正常的才只有一个参数啊：
恩呢，这就是5.0给我们提供的新的方法，要用它，先要在配置文件中为我们的Activity设置一个属性：
android:persistableMode="persistAcrossReboots" 然后我们的Activity就拥有了持久化的能力了，一般我们会搭配另外两个方法来使用：
public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) public void onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState) 相信有些朋友对这两个方法名不陌生吧，前一个方法会在下述情形中被调用：
点击home键回到主页或长按后选择运行其他程序
按下电源键关闭屏幕
启动新的Activity
横竖屏切换时，肯定会执行，因为横竖屏切换的时候会先销毁Act，然后再重新创建 重要原则：当系统"未经你许可"时销毁了你的activity，则onSaveInstanceState会被系统调用， 这是系统的责任，因为它必须要提供一个机会让你保存你的数据（你可以保存也可以不保存）。
而后一个方法，和onCreate同样可以从取出前者保存的数据： 一般是在onStart()和onResume()之间执行！ 之所以有两个可以获取到保存数据的方法，是为了避免Act跳转而没有关闭， 然后不走onCreate()方法，而你又想取出保存数据~
说回来： 说回这个Activity拥有了持久化的能力，增加的这个PersistableBundle参数令这些方法 拥有了系统关机后重启的数据恢复能力！！而且不影响我们其他的序列化操作，卧槽， 具体怎么实现的，暂时还不了解，可能是另外弄了个文件保存吧~！后面知道原理的话会告知下大家！ 另外，API版本需要&gt;=21，就是要5.0以上的版本才有效~
4.启动一个Activity的几种方式
在Android中我们可以通过下面两种方式来启动一个新的Activity,注意这里是怎么启动，而非 启动模式！！分为显示启动和隐式启动！
显式启动：通过包名来启动，写法如下： ①最常见的：
startActivity(new Intent(当前Act.this,要启动的Act.class));
②通过Intent的ComponentName：
ComponentName cn = new ComponentName(“当前Act的全限定类名”,“启动Act的全限定类名”) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be87d8b228b75cd2c9b8e56bc2d71a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6df707717a852449e5e463c6e9f20c/" rel="bookmark">
			透明度百分比对应关系表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Android中，颜色值通常使用十六进制表示法，以#开头，后跟8个字符。这8个字符分别代表ARGB（Alpha-Red-Green-Blue）四个通道的值，其中前两个字符表示透明度（Alpha），接着两个字符表示红色（Red），然后是绿色（Green），最后两个字符表示蓝色（Blue）。
前两个字符表示透明度：这两个字符用来指定颜色的不透明度或透明度。它们的十六进制值可以从00（完全透明）到FF（完全不透明）。 例如：“#FFFF0000” 表示完全不透明的红色（等于"#FF0000"），“#80FF0000” 表示半透明的红色（80表示50%的不透明度），“#00FF0000” 表示完全透明的红色（效果等于经常用来表示完全透明的"#00000000"(transparent)）。
透明度十六进制%Hex%Hex%Hex%Hex100%FF99%FC98%FA97%F796%F595%F294%F093%ED92%EB91%E890%E689%E388%E087%DE86%DB85%D984%D683%D482%D181%CF80%CC79%C978%C777%C476%C275%BF74%BD73%BA72%B871%B570%B369%B068%AD67%AB66%A865%A664%A363%A162%9E61%9C60%9959%9657%9456%9156%8F55%8C54%8A53%8752%8551%8250%8049%7D48%7A47%7846%7545%7344%7043%6E42%6B41%6940%6639%6338%6137%5E36%5C35%5934%5733%5432%5231%4F30%4D29%4A28%4727%4526%4225%4024%3D23%3B22%3821%3620%3319%3018%2E17%2B16%2915%2614%2413%2112%1F11%1C10%1A9%178%147%126%0F5%0D4%0A3%082%051%03 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926eab646708461ba71ab0129be4e884/" rel="bookmark">
			【IMX6ULL驱动开发学习】06.DHT11温湿度传感器驱动程序编写与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DHT11简介
1.1 DHT11模块硬件设计
1.2 DHT11模块软件设计
1.3 DHT11通讯协议
1.4 DHT11数据格式
二、相关代码
2.1 驱动代码
2.2 测试代码
2.3 上板子测试
一、DHT11简介 DHT11是一款可测量温度和湿度的传感器。比如市面上一些空气加湿器，会测量空气中湿度，再根据测量结果决定是否继续加湿。
DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器，具有超小体积、极低功耗的特点，使用单根总线与主机进行双向的串行数据传输。DHT11测量温度的精度为± 2℃，检测范围为-20℃ -60℃。湿度的精度为± 5%RH，检测范围为 5%RH-95%RH，常用于对精度和实时性要求不高的温湿度测量场合。
1.1 DHT11模块硬件设计 主机通过一条数据线与DH11连接，主机通过这条线发命令给DHT11，DHT11再通过这条线把数据发送给主机。
1.2 DHT11模块软件设计 DHT11的硬件电路比较简单，核心要点就是：主机发给DHT11的命令格式和DHT11返回的数据格式。
1.3 DHT11通讯协议 通讯过程如图所示：
当主机没有与 DHT11 通信时，总线处于空闲状态，此时总线电平由于上拉电阻的作用处于高电平。
当主机与 DHT11 正在通信时，总线处于通信状态，一次完整的通信过程如下：
a) 主机将对应的 GPIO 管脚配置为输出，准备向 DHT11 发送数据；
b）主机发送一个开始信号：开始信号 = 一个低脉冲 + 一个高脉冲。低脉冲至少持续 18ms，高脉冲持续 20-40us。
c) 主机将对应的 GPIO 管脚配置为输入，准备接受 DHT11 传来的数据，这时信号由上拉电阻拉高；
d) DHT11 发出响应信号：响应信号 = 一个低脉冲 + 一个高脉冲。低脉冲持续 80us，高脉冲持续 80us。
e) DHT11 发出数据信号：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926eab646708461ba71ab0129be4e884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44ba7482e31a95fa3c6ba271efc0c3b/" rel="bookmark">
			教你用Python实现自动扫雷，你就是最亮的仔~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷，相信80、90后的小伙伴肯定不陌生，在电脑还没有彻底普及的年代，能够玩上扫雷和纸牌就已经非常不容易了，今天小千就来给大家分享一期使用Python代码实现自动扫雷的教程，代码都在文章中，同学们可以学习和参考一下。
自动扫雷一般分为两种，一种是读取内存数据，而另一种是通过分析图片获得数据，并通过模拟鼠标操作，这里我用的是第二种方式。
一、准备工作 我的版本是 python 3.6.1
python的第三方库：
win32apiwin32guiwin32conPillownumpyopencv 可通过 pip install --upgrade SomePackage 来进行安装
注意：有的版本是下载pywin32，但是有的要把pywin32升级到最高并自动下载了pypiwin32，具体情况每个python版本可能都略有不同
这里给出的第三方库和版本仅供参考
二、关键代码组成 1.找到游戏窗口与坐标
#扫雷游戏窗口 class_name = "TMain" title_name = "Minesweeper Arbiter " hwnd = win32gui.FindWindow(class_name, title_name) #窗口坐标 left = 0 top = 0 right = 0 bottom = 0 if hwnd: print("找到窗口") left, top, right, bottom = win32gui.GetWindowRect(hwnd) #win32gui.SetForegroundWindow(hwnd) print("窗口坐标：") print(str(left)+' '+str(right)+' '+str(top)+' '+str(bottom)) else: print("未找到窗口") 2.锁定并抓取雷区图像
#锁定雷区坐标 #去除周围功能按钮以及多余的界面 #具体的像素值是通过QQ的截图来判断的 left += 15 top += 101 right -= 15 bottom -= 42 #抓取雷区图像 rect = (left, top, right, bottom) img = ImageGrab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44ba7482e31a95fa3c6ba271efc0c3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89a5a6cd47bfe3e804d2390e4baaa0f/" rel="bookmark">
			黑客利用 MinIO 存储系统漏洞危害服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据观察，未知威胁行为者利用 MinIO 高性能对象存储系统中的高严重性安全漏洞进行武器化，以在受影响的服务器上实现未经授权的代码执行。
国际知名白帽黑客、东方联盟创始人郭盛华表示，此次入侵利用了公开可用的漏洞利用链对 MinIO 实例进行后门处理，其中包括CVE-2023-28432（CVSS 分数：7.5）和CVE-2023-28434（CVSS 分数：8.8），前者已添加到美国网络安全和基础设施安全局 (CISA) 的已知利用漏洞 (KEV) 目录中2023 年 4 月 21 日。
东方联盟网络安全人员分享的一份报告中表示，这两个漏洞“有可能暴露受感染安装中存在的敏感信息，并促进 MinIO 应用程序运行的主机上的远程代码执行 (RCE) ” 。
在该公司调查的攻击链中，据称这些缺陷已被对手武器化，以获取管理员凭据并滥用立足点，通过触发指定 MIRROR_URL 的更新命令，用木马版本替换主机上的 MinIO 客户端。
郭盛华文档中写道：“mc admin update 命令更新部署中的所有 MinIO 服务器。 ” “该命令还支持在部署没有公共互联网访问的环境中使用私有镜像服务器。”
郭盛华透露：“这些行为的最终结果使攻击者能够策划欺骗性更新。” “通过用‘邪恶的’对应物替换真正的 MinIO 二进制文件，攻击者封住了系统的漏洞。”
对二进制文件的恶意修改暴露了一个通过 HTTP 请求接收和执行命令的端点，实际上充当了后门。这些命令继承启动应用程序的用户的系统权限。
值得注意的是，该二进制文件的修改版本是2023 年 4 月上旬在 GitHub 上发布的名为Evil MinIO的漏洞的复制品。也就是说，没有证据表明该漏洞的作者与攻击者之间存在联系。
显而易见的是，威胁行为者精通使用 bash 脚本和 Python，更不用说利用后门访问从远程服务器删除补充有效负载，以便通过下载器脚本进行后期利用。
郭盛华表示：“该脚本能够同时针对 Windows 和 Linux 环境，充当分析受感染主机的网关，并据此确定是否必须终止执行。这种动态方法强调了威胁行为者根据受感染系统的感知价值来优化其工作的战略方法”。（欢迎转载分享）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740566b064d3d2aaedde67a298b570a1/" rel="bookmark">
			2023年Java华为OD真题机考题库大全-带答案（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机考题目类型得分为： 2道100分的题目+ 1道200分的题目（JAVA,Python，C++），具体得分=题目分数*测试用例通过率
考试注意点： 1. 考试时间为150分钟
2. 需要自己写输入输出的代码
3. 多数情况允许本地编程后复制代码
4. 测试用例没通过，不会提示错误信息
5. 注意提供的条件范围的临界值，特殊数值，特殊场景
6. 注意题目要求的代码执行时间跟内存
2023年真题（全部带答案）： 序号题目分值算法时间（类型）1小明小华餐厅吃饭深度搜索+递归20232书籍长宽度叠放几本正则表达式+动态规划20233跳格子得分双层遍历or动态规则20234解压报文正则表达式+栈20235分奖金遍历20236报文重排序正则表达式+遍历20237重复代码双指针20238快速开租建站矩阵+剪枝+递归20239预订酒店遍历202310路灯照明范围双指针202311数列描述递归遍历202312短信优惠数组+滑动窗口202313最差产品滑动窗口202314宜居星球改造计划递归+深度优先搜索202315流水线任务调度滑动窗口202316分苹果二进制异或+排序202317黄金箱子单指针202318食堂供餐递归+二分202319恢复数字序列202320服务失效判断202321数大雁202322选修课202323单词接龙202324五子棋202325字符串加密202326玩牌高手202327新学校地址202328完美走位202329荒岛求生202330新号塔新号传递递归+深度优先搜索202331分月饼202332字符串中最小整数和202333字符串摘要正则表达式+双指针+排序2023 什么OD模式？为什么OD模式这么多人关注？ OD全称(Outsourcing Dispacth)模式，目前华为和外企德科联合招聘的简称。目前华为社招大多数是OD招聘，17级以下都为OD模式，OD模式也是华为提出的一种新的用工形式，定级是13-17级，属于华为储备人才，每年都会从OD项目挑优秀员工转为正编。
具体转条件：连续N个季度绩效为A，部门有转正名额，排队。。。
OD薪资待遇： D1-D5对应薪资10K-35K左右，年终奖2-4个月，周六加班双倍工资，下个月发。入职OD会有一定薪资上涨，之后每年一次加薪，OD转华为一次加薪。
OD风险： 等不到转正机会，相对于内部员工来说，容易被裁，不稳定，可能接触不到核心项目，功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d7a8bfc1e2b78f6d5f25f1c479bb31/" rel="bookmark">
			高并发下机器QPS计算、最佳线程数计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、QPS，每秒查询
QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。
二、TPS，每秒事务 TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。
三、RT，响应时间 响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。
四、并发数 并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。
五、吞吐量 系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。
QPS（TPS）：（Query Per Second）每秒钟request/事务 数量
并发数：系统同时处理的request/事务数
响应时间：一般取平均响应时间
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间
并发数 = QPS*平均响应时间
六、实际举例 我们通过一个实例来把上面几个概念串起来理解。
按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器
1、每天300w PV 的在单台机器上，这台机器需要多少QPS？
( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d7a8bfc1e2b78f6d5f25f1c479bb31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130ae3aabf89bbb31e73fb1083cf0af7/" rel="bookmark">
			安装opencv库成功后import cv2报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错找不到 libSM.so.6 libXrender.so.1 libXext.so.6
首先apt-get update
出错的话一一排查
①证书错误的话:Certificate verification failed: The certificate is NOT trusted
将/etc/apt/sources.list中的网址的https改成http
②GPG error: https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64 InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY A4B469963BF863CC
The repository ‘https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64 InRelease’ is not signed.
解决方法:
RUN rm /etc/apt/sources.list.d/cuda.list RUN rm /etc/apt/sources.list.d/nvidia-ml.list 这两个错误解决后apt-get install应该是可以成功的
③apt 更新后执行下面几条语句
apt-get install libsm6 apt-get install libxrender1 apt-get install libxext-dev ④接着pip install opencv-python
(之前安了也再执行一遍)
还报错试试
apt-get update &amp;&amp; apt-get install ffmpeg libsm6 libxext6 -y
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e7a60180774b13466fc48b111a3b46/" rel="bookmark">
			数据库基本理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 基本操作 数据库操作 show databases ; create database 库名 ;
#查看一个数据库的编码格式 show create database py ;
#设置数据库的编码格式 alter database py default character set utf8mb4 ;
#删库 drop database py ;
表的操作 show databases ; use 数据库 ；
create table 表名 { 字段1 类型（）， 字段2 类型（）， …… }
#修改表名 将book表重命名为books alter table book rename books
#添加字段 alter table books add press varchar(20);
#查看表的字段信息 desc books;
#删除字段 删除books表中的press字段。 alter table books drop press
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e7a60180774b13466fc48b111a3b46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b66b34519f04a43b9a14bbb6ca68f2e/" rel="bookmark">
			如何将home目录空间扩充到根目录下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1、查看查看磁盘使用情况2、扩容思路3、卸载并删除/home4、扩大/root逻辑卷5、扩大/文件系统6、重建/home逻辑卷7、创建/home文件系统8、将新建的文件系统挂载到/home目录下9、恢复/home并删除备份10、再次查看看磁盘存储 系统：centos7.9
1、查看查看磁盘使用情况 /dev/mapper/centos-root是50G，即将溢出；
/dev/mapper/centos-home是945G，可以看到home目录空间很充足的，因此，可以将/home空间的分配给根目录一些。
2、扩容思路 将/home文件夹备份，删除/home文件系统所在的逻辑卷，增大/文件系统所在的逻辑卷，增大/文件系统大小，最后新建/home目录，并恢复/home文件夹下的内容。
需要选一个能够容纳下/home文件夹大小的分区，因为当前/home中的文件比较小，所以此时我们随便找个目录即可，使用如下命令：
tar cvf /run/home.tar /home 3、卸载并删除/home 卸载
umount /home 删除/home所在的逻辑卷lv
lvremove /dev/mapper/centos-home 4、扩大/root逻辑卷 lvextend -L +800G /dev/mapper/centos-root 5、扩大/文件系统 xfs_growfs /dev/mapper/centos-root 6、重建/home逻辑卷 由于刚才已经分出去800G，因此这里创建的逻辑卷大小为140G。
lvcreate -L 140G -n /dev/mapper/centos-home 7、创建/home文件系统 mkfs.xfs /dev/mapper/centos-home 8、将新建的文件系统挂载到/home目录下 mount /dev/mapper/centos-home 9、恢复/home并删除备份 tar xvf /run/home.tar -C / rm -rf /run/home.tar 10、再次查看看磁盘存储 df -h 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0322d5bf8607ead99782b9093638e5d/" rel="bookmark">
			LangChain Memory 结合LLMs：让你的聊天机器人拥有记忆力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 在快速发展的人工智能领域，聊天机器人已成为不可或缺的工具，它们提供全方位的服务，从回答客户查询到提供个性化帮助。然而，传统的聊天机器人通常无法记住对话上下文，导致有时显得脱节且缺乏人情味。这是因为大多数聊天机器人都是无状态的，将每个用户查询视为独立交互，不参考之前的交换。
为了解决这个限制并提升对话体验，Langchain对话记忆的概念被引入。这一创新解决方案使聊天机器人能够记住过去的交互，并根据上下文生成更相关的响应，打造更流畅、更贴近人性化的对话。
本文我们将深入探讨LangChain的内存世界，并探索其各种类型及功能。同时还会介绍如何将其与Streamlit和OpenAI GPT API结合起来，构建更智能、反应更灵敏的聊天机器人。
二、LangChain LangChain 是一个开源的框架，它可以让AI开发人员把像GPT-4这样的大型语言模型（LLM）和外部数据结合起来。它提供了Python或JavaScript（TypeScript）的包。利用LangChain，你可以轻松地构建一个能够生成文档摘要的聊天机器人，让它为你节省时间和精力。
LangChain 提供了几个主要模块支持，如模型、提示、索引等，这些模块可以以多种方式用于不同的用例。
模型：LangChain 支持的各种模型类型和模型集成。
索引：当结合你自己的文本数据时，语言模型通常更加强大 - 这个模块涵盖了这样做的最佳实践。
链：链不仅仅是一个单一的 LLM 调用，而是一系列的调用（无论是对 LLM 还是其他工具）。LangChain 提供了一个标准的链接口，许多与其他工具的集成，以及针对常见应用的端到端链。
三、LangChain Memory LangChain Memory 是一个用于管理和操作以前的聊天消息的工具，旨在实现对先前交互的记忆。它提供了模块化和有用的工具，可以轻松地将其纳入到聊天机器人和其他会话代理中。
LangChain Memory的主要功能包括：
管理和访问不同类型的Memory：LangChain提供了一个统一的接口，可以管理和访问不同类型的记忆，包括对话缓冲记忆、对话摘要记忆等。这使得开发人员可以轻松地存储和检索以前对话中的信息。
学习和适应新信息：LangChain Memory可以学习和适应新的信息，并利用先前的上下文来生成更准确的响应。它能够利用存储的对话历史来提供更具连贯性和个性化的对话体验。
与不同类型的语言模型集成：LangChain Memory可以与各种类型的语言模型集成，包括预训练模型如GPT-3、ChatGPT以及自定义模型。这样，开发人员可以根据自己的需求选择适合的语言模型，并将其与LangChain Memory无缝集成。
四、LangChain Memory 类型 本节深入研究 Langchain 库中可用的各种类型的内存。我们将通过将每种类型与 ConversationChain 结合使用并比较它们的提示来深入分析每种类型的工作原理。我们还将评估它们各自的优缺点。
本节将深入研究 LangChain 库中可用的各种不同的Memory 类型。我们将通过与 ConversationChain 结合使用并比较它们的提示来详细分析每种类型的工作原理，并评估它们各自的优缺点。
首先安装并导入以下库和模块，这些库和模块将在后面的案例中会用到
pip install langchain pip install openai import os os.environ['OPENAI_API_KEY'] = "your-openai-api-key" from langchain.llms import OpenAI from langchain.chains import ConversationChain 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0322d5bf8607ead99782b9093638e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc5872da55ed3ac1f0a4177cdc602bd/" rel="bookmark">
			CSS 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 选择器
伪类选择器
通用选择器
颜色
字体
边框
盒子模型
box-sizing
状态
浮动 float
定位 position
相对定位 relative
绝对定位 absolute
固定定位 fixed
弹性布局 flex
flex-basis
flex-grow
flex
flex-direction：row（默认值）
align-items：stretch(默认值）
justify-content：flex-start(默认值）
flex-wrap：nowrap（默认值）
align-content：stretch（默认值）
学习代码
html
css
选择器 &lt;p class="paragraph" id="para1"&gt;Lorem&lt;/p&gt; p{ color:red; } .paragraph{ color:red; } #para1{ color:red; } 在一个html文件中 需要确保id是独一无二的，class没有这种要求
伪类选择器 &lt;ul class="list2"&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;li&gt;list Item&lt;/li&gt; &lt;/ul&gt; /* even 复数 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc5872da55ed3ac1f0a4177cdc602bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe8baf2c45bea0ec286ec43bc28987c/" rel="bookmark">
			oneAPI黑客马拉松赛道二创意赛道-高精度胶质流体模拟预测方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 项目综述1.1 项目背景1.3 项目具体任务 2. 系统环境配置2.1 虚拟环境安装2.2 OneAPI AI分析工具安装2.3 Jupyter安装与使用 3. 数据分析3.1 数据结构3.2 数据特征 4.建模与分析4.1 模型建立过程4.3 使用oneMKL进行流体仿真计算模型构建4.2 使用Intel® AI Analytics Toolkit加速4.3 Intel® Extension for Scikit-learn使用过程 项目最终展示附录1 1. 项目综述 本文基于英特尔 oneAPI AI分析工具套件，对汽车工人打胶数据进行分析建模，构建汽车工人打胶评价体系，给出高精度胶质流体模拟预测方案。并基于模型训练结果给出调整建议，规范打胶手工操作流程。该项目可作为汽车涂胶车间新员工的技能培训的重要参考，同时构建的评价体系针对手工操作培训场景具有很强的延伸性与扩展性。
1.1 项目背景 在现代汽车制造业中，胶水在车辆组装过程中起着至关重要的作用，用于连接各种零部件和确保车辆的质量和安全性。然而，正确打胶是一项技术活，需要工人具备一定的经验和技能，以确保打胶的质量和一致性。传统的打胶手工培训通常依赖于经验丰富的员工进行传帮带，这种培训方法存在一些问题，如培训时间长、培训成本高、一致性差等。
为了解决这些问题，我们提出了基于英特尔 OneAPI AI 分析工具套件的汽车工人打胶数据分析建模项目。这个项目不仅可以帮助评估工人的打胶技能，还可以提供实时的速度和角度调整建议，以确保打胶的质量和效率。同时，这个项目还将建立一个全面的打胶评价体系，以便针对不同的打胶任务和技能水平提供培训解决方案。
本项目基于 AI 分析工具套件提供了技术驱动的培训模式，基于该项目，我们团队开发员工打胶培训系统，记录并分析员工学习情况，借助虚拟协同技术对员工进行上岗前培训，提供实时反馈与调整建议，在提供生产质量的同时降低企业生产成本，实现技术驱动生产。
建立的评价体系不仅适用于新员工的技能培训，还可以用于现有员工的技能提升和评估。此外，这个体系还可以扩展到其他手工操作场景，如焊接、组装等，为制造业提供更广泛的解决方案，具有很强的扩展性与易用性
1.3 项目具体任务 经过团队成员讨论，本次建模任务有以下内容：
根据提供的数据信息判断工人一条打胶数据是否合格给出各点位速度、角度调整建议建立工人打胶训练评价标准，结合虚拟协同技术提供员工培训解决方案 2. 系统环境配置 本项目基于Ubuntu 20.04系统开发，在conda中创建python虚拟环境，并安装相关依赖，附录1是本次开发环境中库版本信息.
2.1 虚拟环境安装 本项目中基于conda进行各依赖库的安装与版本控制，conda安装与基本使用方法很多教程中有讲解，有需要的小伙伴可参考进行虚拟环境的安装与配置，在项目开始前系统中需具备python编程环境
下面是一些参考文档链接：
ubuntu20.04安装anacondaconda使用指南 2.2 OneAPI AI分析工具安装 Intel官网提供OneAPI相关的安装教程，下面是本团队安装过程的记录，仅供参考。
Step1 Download the Toolkit 下载链接: https://www.intel.com/content/www/us/en/developer/tools/oneapi/ai-analytics-toolkit-download.html?operatingsystem=linux&amp;distributions=aptpackagemanager 该下载链接提供在线、离线、命令行等多种下载方式，在该页面中选择系统版本linux/windows后，选择合适的下载方式，考虑到网速问题，我选择离线安装的方式，将安装包下载到本地，解压后安装。
离线安装方式 # 注意，安装时可能需要sudo权限 wget https://registrationcenter-download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe8baf2c45bea0ec286ec43bc28987c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5b2d5830f4ec014f6bcb45b5601c89/" rel="bookmark">
			【opencv3】详述PnP测距完整流程（附C&#43;&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、准备工作1.相机标定简介2.标定过程3.截取图像C++代码4.标定C++代码 三、PnP测距代码测试输出 一、概述 我们只要获得特征点的世界坐标（三维坐标）、2D坐标（像素坐标）、相机内参矩阵、相机畸变参数矩阵以上四个参数即可以解得相机与标志物之间的外参（旋转矩阵R、平移矩阵T），并以此求得相机的世界坐标（以标志物为世界坐标平面，且原点为标志物已知某一点）。
Ref：
PnP 单目相机位姿估计（二）：solvePnP利用二维码求解相机世界坐标
相机内参矩阵、相机畸变参数矩阵可通过相机标定获取。
最后由旋转向量和平移矩阵求出深度信息：
先将旋转向量转化为旋转矩阵再转置，与平移矩阵相乘，得到的z坐标即深度信息。
P = − i n v e r s e ( R ) ∗ T P = -inverse (R) * T P=−inverse(R)∗T
二、准备工作 1.相机标定简介 1.为什么需要对摄像头进行标定？ ⭐️
摄像头存在畸变，畸变可以拓宽视野，但会影响图像识别和测量的精度。
2.摄像头参数： ⭐️
1）相机矩阵：包括焦距（fx，fy），光学中心（Cx，Cy），完全取决于相机本身，是相机的固有属性，只需要计算一次，可用矩阵表示如下：[fx, 0, Cx; 0, fy, cy; 0,0,1];
2) 畸变系数：畸变数学模型的5个参数 D = （k1，k2， P1， P2， k3）；
3）相机内参：相机矩阵和畸变系数统称为相机内参，在不考虑畸变的时候，相机矩阵也会被称为相机内参；
4） 相机外参：通过旋转和平移变换将3D的坐标转换为相机2维的坐标，其中的旋转矩阵和平移矩阵就被称为相机的外参；描述的是将世界坐标系转换成相机坐标系的过程。
3.摄像头标定的流程： ⭐️
相机的标定过程实际上就是在4个坐标系转化的过程中求出相机的内参和外参的过程。这4个坐标系分别是：世界坐标系（描述物体真实位置），相机坐标系（摄像头镜头中心），图像坐标系（图像传感器成像中心，图片中心，影布中心，单位mm），像素坐标系（图像左上角为原点，描述像素的位置，单位是多少行，多少列）。
（1）世界坐标系 → 相机坐标系：等比例缩小，外加旋转平移，称之为刚体变换；求解摄像头外参（旋转和平移矩阵）；
（2）相机坐标系 → 图像坐标系：称为投影；求解相机内参（摄像头矩阵和畸变系数）；
（3）图像坐标系 → 像素坐标系：将图像坐标离散抽样；求解像素转化矩阵（可简单理解为原点从图片中心到左上角，单位厘米变行列）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5b2d5830f4ec014f6bcb45b5601c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36be98235dd16c46c3cdc3f9b08612f8/" rel="bookmark">
			QWebEngine应用---基于QWebChannel实现网页与qt层交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt提供了QWebChannel实现和网页的通信，我们直接拿github上一个能直接运行的demo来做说明，demo是基于Widget，且页面是自己实现的页面，接着会介绍基于QML实现且页面是第三方网站如何使用的。
QWebChannel用法 我们先看看demo的运行效果
左边是widget界面，右边是QWebEngineView，两边支持互发消息。
大体原理是定义一个通信类，这个类为Document，通过这个类发送和接收消息，QWebChannel绑定这个类
m_webView = new QWebEngineView(); QWebEnginePage *page = new QWebEnginePage(this); //创建一个网页视图对象 m_webView-&gt;setPage(page); QWebChannel *channel = new QWebChannel(this); //为网页视图页面创建通道channel channel-&gt;registerObject(QStringLiteral("document"), &amp;m_document);//注册通道对象供JS调用,"document"为注册名，JS调用的对象名必须和它相同 page-&gt;setWebChannel(channel); //设置通道 // qt端和HTML页面之间交互要用到的类 class Document : public QObject { Q_OBJECT public: explicit Document(QObject *parent = nullptr){} void sendText(const QString &amp;text) { emit textSent(text);//发送给html页面 } public slots: //在HTML端的JavaScript中调用，在qt端显示 void receiveText(const QString &amp;text) { emit textReceived(text);//发送给主界面 } signals: //发送消息给HTML页面（此信号在html端的JavaScript中进行连接） void textSent(const QString &amp;text); //发送消息给主界面 void textReceived(const QString &amp;text); }; 在页面中加载qwebchannel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36be98235dd16c46c3cdc3f9b08612f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838d730f162c46a9842b6745ce29381d/" rel="bookmark">
			基于QWebEngine实现无头浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无头浏览器 无头浏览器（Headless Browser）是一种没有图形用户界面（GUI）的浏览器。它通过在内存中渲染页面，然后将结果发送回请求它的用户或程序来实现对网页的访问，而不会在屏幕上显示网页。这种方式使得无头浏览器不仅适用于网络爬虫和测试等自动化任务，而且还能够更安全地进行网页浏览，因为它不会在屏幕上显示您的活动。
常见的无头浏览器包括Chrome Headless、PhantomJS、Puppeteer等，常见的这些无头浏览器都属于互联网前后端开发相关的东西，与Qt技术栈相关的比较少。
在之前的文章中我们了解到，QWebEngine能够实现内嵌浏览器的功能，基于无头浏览器的原理介绍，QWebEngine能不能实现加载网页但不显示页面呢？
答案是，可以的。
基于QWebEnginePage实现无头浏览器 在之前的文章中我们有介绍到QWebEngine有两种实现方式，一个QWidget框架下的QWebEngineView，另一种是QML框架下的WebEngineView，其中QWebEngineView包含QWebEnginePage的功能，QWebEnginePage提供页面加载相关的功能，QWebEngineView用于page的显示，基于QWebEnginePage就可实现无头浏览器。
auto page = new QWebEnginePage(this); page-&gt;setUrl(QUrl("https://www.qt.io/")); connect(page, &amp;QWebEnginePage::loadFinished, this, [=](bool ok){ qDebug() &lt;&lt; __FUNCTION__ &lt;&lt; "song" &lt;&lt; "load is ok" &lt;&lt; ok; }); 使用QWebEnginePage加载页面，页面加载成功后就可以做一些操作，如网络截图、爬虫、数据采集等。
QWebEnginePage支持QWebEngine内嵌浏览器相关的功能，具体可查看相关接口
1、获取网页相关信息
2、注入javascript
3、打印pdf
更具体的应用需要自己去发掘了。
QML的WebEngineView没有像QWebEngineView把page的功能分开，所以WebEngineView不能实现无头浏览器的效果。
最后，需要注意的是，如果是在控制台程序中运行QWebEnginePage，main函数的应用程序类型必须是QApplication，使用QCoreApplication无法启动QWebEnginePage。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9b141eaccfb3d72a12f2975e35b169/" rel="bookmark">
			缺陷检测文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AnomalyGPT: Detecting Industrial Anomalies using Large Vision-Language Models 中科院
Large Vision-Language Models (LVLMs) such as MiniGPT-4 and LLaVA have demonstrated the capability of understanding images and achieved remarkable performance in various visual tasks. Despite their strong abilities in recognizing common objects due to extensive training datasets, they lack specific domain knowledge and have a weaker understanding of localized details within objects, which hinders their effectiveness in the Industrial Anomaly Detection (IAD) task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9b141eaccfb3d72a12f2975e35b169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b2168300bd07bf0f761ebd8cd3377f/" rel="bookmark">
			android 腾讯MMKV持久化框架使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MMKV是腾讯18年底推出的一套持久化框架，有安卓，IOS，PC版本等等，微信的持久化功能使用的就是MMKV，项目地址：https://github.com/Tencent/MMKV
最大的特点就是高效，号称要比传统的持久化工具要高效100倍，目标是用来替代原生的SharedPreferences（后续SharedPreferences统称为SP）。本文主要是探究MMKV的实现原理以及为什么比SP高效。
在app下面的build.gradle中添加引用
//腾讯MMKV implementation 'com.tencent:mmkv:1.2.11' 在MyApplication 中进行初始化
package com.nywnn.test; import android.app.Application; import com.tencent.mmkv.MMKV; public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); //MMKV初始化 String initialize = MMKV.initialize(this); System.out.println("MMKV INIT " + initialize); //工具类初始化 MVUtils.getInstance(); } } 封装一个MVUtils 工具类如下
package com.nywnn.test; import android.os.Parcelable; import com.tencent.mmkv.MMKV; import java.util.Collections; import java.util.Set; public class MVUtils { private static MVUtils mInstance; private static MMKV mmkv; public MVUtils() { mmkv = MMKV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b2168300bd07bf0f761ebd8cd3377f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc60c5c57d532b906d5f38526927241f/" rel="bookmark">
			Python项目打包与部署(二): __init__.py的作用及内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其它章节
Python项目打包与部署(一)：模块与包的概念与关系Python项目打包与部署(三)：打包与部署的实际操作流程各类Python项目的项目结构及代码组织最佳实践 通常在python项目的源代码子目录下都看到1个__init__.py文件，django-admin startproject 命令生成的项目结构中也有__init__.py文件，
那么，为什么要加1个__init__.py`文件，其究竟有什么用，应该向里面写什么内容呢？
1. __init__.py文件的作用 __init__.py文件，如果与类定义相比，它相当于是 python package 的constructor 构造方法, 其作用是，告诉python解释器，要把本目录下哪些的函数导进包，以及这些函数位于哪些文件中。
__init__.py文件可以为空.不能把其它同级目录的文件导入此package中。 2. 如何使用__init__.py 下面用实例来说明 __init__.py 是如何工作的，以及应该写什么内容。
（1）在__init__.py文件中，导入需要的模块 在 my_package/__init__,.py中，输入以下代码，将此目录下.file1, .file2,.file3文件的函数 func_1, func_2, func_3 导入包my_package，但不包含其它函数模块
from .file1 import func_1 # Where func_1 is the name of the function and .file1 is the name of the module/file from .file2 import func_2 from .file3 import func_3 这种方式，只是导入了代码文件中所需要的模块。
让我们用实例来看看，导入模块的另1种方式：
在package目录下，创建1个main,.py ， 在main.py中直接导入整个 my_package，下例中，可以看到，前面例子中没有的，func_5() 也导入了。
import my_package # this imports the entire module # 调用func_1() my_package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc60c5c57d532b906d5f38526927241f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/114/">«</a>
	<span class="pagination__item pagination__item--current">115/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/116/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>