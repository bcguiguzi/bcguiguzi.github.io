<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e517033a928ac726e092a1e92ac6014/" rel="bookmark">
			【Python爬虫】Python 爬虫的学习和案例，一篇文章带你了解爬虫的密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫基础 我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。
为什么学习爬虫 为了装x
爬虫概述 简单来说，爬虫就是获取网页并提取和保存信息的自动化程序
获取网页 爬虫首先要做的就是爬取网页，这里就是获取网页的源代码，源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。
提取信息 获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。
首先，最通用的方法就是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错另外由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如
BeautifulSoup，pyquery，lxml 等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等 提取信息是爬虫非常重要的部分，它可以使复杂的数据变得条理清晰，以便我们后续处理和分析数据。
保存数据 提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为txt文本或 json 文本，也可以保存到数据库，如 MySQL 和 MongoDB 等，也可以保存至远程服务器，如借助SFTP进行操作等
自动化程序 说到自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取到这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等草垛，确保爬取持续高效的运行。
能爬取怎样的数据 在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着HTML代码，而最常抓取的便是HTML源代码
另外，可能有些网页返回的不是HTML代码，而是一个JSON字符串（其中API接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更方便
此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，最后保存成对应的文件名。
另外，还可以看到各种扩展名的文件，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来
上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取
对于爬虫来说，用于爬虫爬取速度过快，在爬取过程中可能遇到同一个IP访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁IP，这样会给爬取带来机打的不便
使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果
urllib urllib urllib库，是Python内置的HTTP请求库，不需要额外安装，它包含如下四个模块
request ：它是最基本的HTTP请求模块，可以用来模拟发送请求。就像在浏览器里输入网址一样，只需要给库方法传入URL以及额外的参数，就可以模拟实现这个过程了
error ：异常处理模块，如果出翔请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止
parse ：一个工具模块，提供了许多URL处理方法，比如拆分，解析，合并等
rebotparser ：主要是用来识别网站的robots.txt文件，然后判断哪些网站不可以爬，用得比较少
发送请求 使用urllib的request模块，我们可以方便的实现请求发送并得到响应，
urlopen urllib.request模块提供了最基本的构造HTTP请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理授权验证（authentication）、重定向（redirect）、浏览器Cookies以及其他内容
基本使用 import urllib.request response = urllib.request.urlopen('https://www.python.org') html = response.read().decode('utf-8') print(type(response)) # &lt;class 'http.client.HTTPResponse'&gt; 它是一个HTTPResponse类型的对象，主要包含read、readinto、getheader、getheaders、fileno等方法，以及msg、version、status、reason、debuglevel、closed等属性
调用 read 方法可以得到返回的网页内容，调用 status 属性可以得到返回结果的状态码， 200 代表请求成功，404 代表网页未找到等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e517033a928ac726e092a1e92ac6014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c9b1c03f6bfbf97c75ad0c63ecbcef/" rel="bookmark">
			Scratch 真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57249a690aa7b98341167e7414900ef/" rel="bookmark">
			华为OD机试真题大全完整目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机试真题大全完整目录 专栏说明如下专栏目录 专栏说明如下 内容：华为OD机试真题大全
数量：406篇博文(2023年5月16日截止)
更新时间至：2023年5月16日（后续加上去的博文，会每几个月同步目录一次）
目录顺序：创作时间由近到远（哈哈，我是故意的，就是想让你翻下去看看。）
状态：会持续更新
专栏目录 华为OD机试 - 两数之和（java &amp; c++ &amp; c &amp; python &amp; golang）点击进入
华为OD机试- 柠檬水找零（java&amp; c++&amp; python &amp; javascript &amp; golang &amp; c# &amp; c）点击进入
华为OD机试- 亲密字符串（java&amp; c++&amp; python &amp; javascript &amp; golang &amp; c# &amp; c）点击进入
华为OD机试- 雇佣 K 名工人的最低成本（java&amp; c++&amp; python &amp; javascript &amp; golang &amp; c# &amp; c）点击进入
华为OD机试- 雇佣 K 名工人的最低成本（java&amp; c++&amp; python &amp; javascript &amp; golang &amp; c# &amp; c）点击进入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57249a690aa7b98341167e7414900ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcdfe42d65267b5198cd5ba81cf3038/" rel="bookmark">
			X.Org已死，Wayland长存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Asahi Linux 创始人 Hector Martin 在 mastodon 发表了一篇帖子，督促 Asahi Linux 发行版的用户停止使用 X.Org，因为 Wayland 才是 Linux 的未来。
Asahi Linux 是由资深操作系统移植专家 Hector Martin（网名 Marcan） 众筹发起的项目，目标是将 Linux 移植到搭载 Apple Silicon 芯片的 Mac 设备。
Marcan 表示，Asahi Linux 的目标不仅仅是让 Linux 能在这些设备上运行，最终还要将其打磨至可以用作日常操作系统的程度。
Marcan 表示团队没有时间和资源解决 X.Org 上的问题，而且 X.Org 已几乎无人维护，已经完全不适合现代显示硬件，此外大型 Linux 发行版和主要桌面环境也已经放弃了 X.Org 支持。
比如红帽宣布 RHEL 10 默认将不包含 X.org 显示服务器——RHEL 官方文档称，X.org 显示服务器已被弃用，并将在以后的主 RHEL 发行版本（从 RHEL 10 开始）中删除。红帽没有解释弃用 X.org 的原因。目前的 RHEL 9 则仍包含 X.org 显示服务器，并会提供 10 年的支持，持续到 2032 年。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffcdfe42d65267b5198cd5ba81cf3038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5966709ed6271929df52b00dd5998a/" rel="bookmark">
			解决Modelsim10.7 破解过程中双击patch_dll.bat文件提示找不到mgls.dll、mgls64.dll的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、问题描述2、解决方法 1、问题描述 使用管理员用户打开patch_dll.bat文件后出现的问题如下图：
但是看到文件夹中明明有这两个文件存在
2、解决方法 使用命令行窗口cmd，一步步的进入patch_dll.bat的文件夹下，然后运行patch_dll.bat.
结果成功生成了LICENSE文件，将它另存为modelsim的安装文件夹中：
然后就可以成功破解啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f179b1178af590200d87d3f5dc847d7/" rel="bookmark">
			Kali-linux渗透攻击应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面依次介绍了Armitage、MSFCONSOLE和MSFCLI接口的概念及使用。本节将介绍使用MSFCONSOLE工具渗透攻击MySQL数据库服务、PostgreSQL数据库服务、Tomcat服务和PDF文件等。
6.4.1 渗透攻击MySQL数据库服务 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。在Metasploitable系统中，MySQL的身份认证存在漏洞。该漏洞有可能会让潜在的攻击者不必提供正确的身份证书便可访问MySQL数据库。所以，用户可以利用该漏洞，对MySQL服务进行渗透攻击。恰好Metasploit框架提供了一套针对MySQL数据库的辅助模块，可以帮助用户更有效的进行渗透测试。本小节将介绍使用Metasploit的MySQL扫描模块渗透攻击MySQL数据库服务。渗透攻击Metasploitable系统中MySQL数据库服务的具体操作步骤如下所示。
（1）启动MSFCONSOLE。执行命令如下所示：
root@kali:~# msfconsole （2）扫描所有有效的MySQL模块。执行命令如下所示：
输出的信息显示了MySQL上可用的模块。从这些模块中，选择渗透攻击的模块进行攻击。
（3）这里使用MySQL扫描模块。执行命令如下所示：
msf &gt; use auxiliary/scanner/mysql/mysql_login msf auxiliary(mysql_login) &gt; （4）显示模块的有效选项。执行命令如下所示：
以上的信息显示了在mysql_login模块下可设置的选项。从输出的结果中可以看到显示了四列信息，分别是选项名称、当前设置、需求及描述。其中Required为yes的选项是必须配置的，反之可以不用配置。对于选项的作用，Description都有相应的介绍。
（5）为渗透攻击指定目标系统、用户文件和密码文件的位置。执行命令如下所示：
msf auxiliary(mysql_login) &gt; set RHOSTS 192.168.41.142 RHOST =&gt; 192.168.41.142 msf auxiliary(mysql_login) &gt; set user_file /root/Desktop/usernames.txt user_file =&gt; /root/Desktop/usernames.txt msf auxiliary(mysql_login) &gt; set pass_file /root/Desktop/passwords.txt pass_file =&gt; /root/Desktop/passwords.txt 以上信息设置了目标系统的地址，用户文件和密码文件的路径。
（6）启动渗透攻击。执行命令如下所示：
msf auxiliary(mysql_login) &gt; exploit [deprecated] I18n.enforce_available_locales will default to true in the future. If you really want to skip validation of your locale you can set I18n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f179b1178af590200d87d3f5dc847d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31af1317ef471358a434c20cc21fee02/" rel="bookmark">
			第十届蓝桥杯青少年Scratch真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94df8b1ed3c9aef20fc5b55aaf591fcb/" rel="bookmark">
			MySQL-InnoDB MVCC实现、Read View使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InnoDB事务支持 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。
MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 可重复读 ）。
保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。
ACID以及事务隔离性参考另外一篇文章：MySQL-ACID、事务隔离级别
InnoDB 对 MVCC 的实现 MVCC 全称Multi-Version Concurrency Control，MVCC是一种通过增加版本冗余数据来实现并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
InnoDB中实现了MVCC主要是为了提高数据库的并发性能，在无锁的情况下也能处理读写并发，大大提高数据库的并发度。
MVCC 的实现依赖于：隐藏字段（DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID）、Read View、undo log。
在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改。
隐藏字段 在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段 ：
DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除 ；DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空 ；DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引。 innodb表加上隐藏字段如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94df8b1ed3c9aef20fc5b55aaf591fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bee9a8d23afde580629a48641c2cb9/" rel="bookmark">
			Android：你真的会用Toast吗（介绍安卓好看简约的Toast快速解锁方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概要
开源库地址
如何使用
1、首先我们现在根目录下的build.gradle中添加以下依赖
2、然后我们在我们的模块目录（通常是app）下的build.gradle中添加以下依赖
3、 然后这一步是可选的，你可以在你的app模块下任意位置，添加以下配置，这是作者提供给大家的自定义配置，可以玩更多花样的Toast(这一步是可选的，新手小白可以跳过这一步)
4、这一步就是使用了，直接开始调用即可，十分简单方便
概要 先上效果图，我坚信没有效果图的ui代码都是在扯淡：
作为一名热爱安卓开发的开发者，我相信大家肯定使用过我们最常使用过的Toast弹窗，这几乎是我们日常开发中必不可少的一部分，大家使用的时候有没有觉得这个基础组件会有点单调，或者是不够美观呢，今天呢，我给大家介绍一个github上一个关于Toast的优秀开源库，超过6.5k stars，相信了解github的同学们都知道6.5k是一个什么概念，有图有真相：
开源库地址 https://github.com/GrenderG/Toasty 如何使用 1、首先我们现在根目录下的build.gradle中添加以下依赖 allprojects { repositories { ... maven { url "https://jitpack.io" } } } 2、然后我们在我们的模块目录（通常是app）下的build.gradle中添加以下依赖 dependencies { ... implementation 'com.github.GrenderG:Toasty:1.5.2' } 3、 然后这一步是可选的，你可以在你的app模块下任意位置，添加以下配置，这是作者提供给大家的自定义配置，可以玩更多花样的Toast(这一步是可选的，新手小白可以跳过这一步) Toasty.Config.getInstance() .tintIcon(boolean tintIcon) // optional (apply textColor also to the icon) .setToastTypeface(@NonNull Typeface typeface) // optional .setTextSize(int sizeInSp) // optional .allowQueue(boolean allowQueue) // optional (prevents several Toastys from queuing) .setGravity(int gravity, int xOffset, int yOffset) // optional (set toast gravity, offsets are optional) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43bee9a8d23afde580629a48641c2cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5554548fb170e213c4f790f43a6c832b/" rel="bookmark">
			numpy中的argpartition用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、np.argpartion()
Numpy的argpartion函数来源于快排算法中的一个典型操作partition，即根据一个数值x，把数组中的元素划分成两半，使得index前面的元素都不大于x，index后面的元素都不小于x。
np.argpartition不对原数组操作，只返回一个按照上述操作排序过后的index。通过这个函数可以高效地找到 N 个最大值的索引并返回 N 个值。在给出索引后，我们可以根据需要进行值排序。
import numpy as np array = np.array([10, 7, 4, 3, 2, 2, 5, 9, 0, 4, 6, 0]) #返回一个索引，比原数组第5大（从0开始）的数小的数在这个数之前，比这个数大的数在它之后。 index = np.argpartition(array, 4) #输出，新索引 print(index) #[ 4 11 8 5 3 2 9 6 1 10 7 0] #按这个新索引可以重新排列数组 print(array[index]) #[ 2 0 0 2 3 4 4 5 7 6 9 10] #第5大的数是3，比3小的在3之前，比3大的在3之后 二、输出top5 np.argpartition的一个重要应用就是高效输出最大的几个值(如top-5)，因为不用像np.sort对所有元素排序
#还是上边那个数组，输出top5 array = np.array([10, 7, 4, 3, 2, 2, 5, 9, 0, 4, 6, 0]) array[np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5554548fb170e213c4f790f43a6c832b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9eac4adde81c8c957622ef7abb12d5a/" rel="bookmark">
			Python实现一个情人节必备表白神器——跳动的爱心，基于tkinter实现 | 提供源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 包子们，晚上好
一般能够看到这篇文章的小伙伴，不是单身狗，那也得是一个贵族！
如果你有心仪的对象啦！
如果你想表白一个女生啦！
如果你还在想着怎么表白女神！
这不是就给大家安排好了，跳动的爱心！
怎么说呢，用这个表白也可以的，万一就成了呢？哈哈
别的不多说，源码都给大家准备好了，看下方相关文件哟！
冲啊，兄弟们
相关文件 关注小编，私信小编领取哟！
当然别忘了一件三连哟~~
公众号：Python日志
开发工具 Python版本：3.7.8
相关模块：
math模块；
random模块；
tkinter模块；
以及一些python自带的模块。
环境搭建 安装Python并添加到环境变量，pip安装需要的相关模块即可。
效果展示 代码实现过程 模块导入 import random from math import sin, cos, pi, log from tkinter import * 形状设置 CANVAS_WIDTH = 640 # 画布的宽 CANVAS_HEIGHT = 480 # 画布的高 CANVAS_CENTER_X = CANVAS_WIDTH / 2 # 画布中心的X轴坐标 CANVAS_CENTER_Y = CANVAS_HEIGHT / 2 # 画布中心的Y轴坐标 IMAGE_ENLARGE = 11 # 放大比例 HEART_COLOR = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9eac4adde81c8c957622ef7abb12d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d347363d9f97fb8e216e349d865fff8a/" rel="bookmark">
			提取abaqus中节点集合的应力应变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点是没有应力应变的，只有积分点才有，所以直接在odb文件里面用FieldOutput是整不出来的（结果是个空列表），只能用session这种让abaqus自己帮你处理。具体的代码需要根据自己操作的时候abaqus.rpy这个文件中代码的变化来更改
import numpy from abaqus import * from abaqusConstants import * from caeModules import * import visualization from driverUtils import executeOnCaeStartup import numpy as np from driverUtils import executeOnCaeStartup from odbAccess import * import numpy as np job_name = "v1100-2" o1 = session.openOdb(name='D:/Abaqus/file/'+job_name+'.odb') odb = session.odbs['D:/Abaqus/file/'+job_name+'.odb'] # F session.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=(('CF', NODAL, ((COMPONENT, 'CF1'), (COMPONENT, 'CF2'), (COMPONENT, 'CF3'),)),), nodeSets=("RP_F",)) # c0 = session.Curve(xyData=xy0) xy1 = session.XYDataFromHistory(name='RF2 PI: rootAssembly N: 1 NSET RP_F-1', odb=odb, outputVariableName='Reaction force: RF2 PI: rootAssembly Node 1 in NSET RP_F', steps=('Step-1',), __linkedVpName__='Viewport: 1') # c1 = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d347363d9f97fb8e216e349d865fff8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74cfcf9689f8b7f26869f1ff0901658/" rel="bookmark">
			MySQL综合练习（50道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作（建表、插入数据）：
二、SQL练习（50道）
1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数
2、查询"01"课程比"02"课程成绩低的学生的信息及课程分数
3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩
4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩(包括有成绩的和无成绩的)
5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩
6、查询"李"姓老师的数量
7、询学过"张三"老师授课的同学的信息
8、查询没学过"张三"老师授课的同学的信息
9、查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息
10、查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息
11、查询没有学全所有课程的同学的信息
12、查询至少有一门课与学号为"01"的同学所学相同的同学的信息
13、查询和"01"号的同学学习的课程完全相同的其他同学的信息
14、查询没学过"张三"老师讲授的任一门课程的学生姓名
15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
16、检索"01"课程分数小于60，按分数降序排列的学生信息
17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩
18、查询各科成绩最高分、最低分、平均分、及格率（60分以上）、中等率（70-80）、优良率（80-90）、优秀率（90以上）
19、按各科成绩进行排序，并显示排名
20、查询学生的总成绩并进行排名
21、查询不同老师所教不同课程平均分从高到低显示
22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩
23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比
24、查询学生平均成绩及其名次
25、查询各科成绩前三名的记录
26、查询每门课程被选修的学生数
27、查询出只有两门课程的全部学生的学号和姓名
28、查询男生、女生人数
29、查询名字中含有"风"字的学生信息
30、查询同名同性学生名单，并统计同名人数
31、查询1990年出生的学生名单
32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列
33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩
34、查询课程名称为"数学"，且分数低于60的学生姓名和分数
35、查询所有学生的课程及分数情况
36、查询任何一门课程成绩在70分以上的学生姓名、课程名称和分数
37、查询课程不及格的学生
38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名
39、求每门课程的学生人数
40、查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩
41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩
42、查询每门课程成绩最好的前三名
43、统计每门课程的学生选修人数（超过5人的课程才统计）
44、检索至少选修两门课程的学生学号
45、查询选修了全部课程的学生信息
46、查询各学生的年龄(周岁)
47、查询本周过生日的学生
48、查询下周过生日的学生
49、查询本月过生日的学生
50、查询12月份过生日的学生
一、准备工作（建表、插入数据）： drop table if exists student; create table student( s_id int, s_name varchar(8), s_birth date, s_sex char(4) ); insert into student values (1,'赵雷','1990-01-01','男'), (2,'钱电','1990-12-21','男'), (3,'孙风','1990-05-20','男'), (4,'李云','1990-08-06','男'), (5,'周梅','1991-12-01','女'), (6,'吴兰','1992-03-01','女'), (7,'郑竹','1989-07-01','女'), (8,'王菊','1990-01-20','女'); drop table if exists score; create table score( s_id int, c_id int, s_score int ); insert into score values (1,1,80), (1,2,90), (1,3,99), (2,1,70), (2,2,60), (2,3,65), (3,1,80), (3,2,80), (3,3,80), (4,1,50), (4,2,30), (4,3,40), (5,1,76), (5,2,87), (6,1,31), (6,3,34), (7,2,89), (7,3,98); drop table if exists course; create table course( c_id int, c_name varchar(8), t_id int ); insert into course values (1,'语文',2), (2,'数学',1), (3,'英语',3); drop table if exists teacher; create table teacher( t_id int, t_name varchar(8) ); insert into teacher values (1,'张三'), (2,'李四'), (3,'王五'); 二、SQL练习（50道） 1、查询"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74cfcf9689f8b7f26869f1ff0901658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e19d2a9f16d9289e2540bfea6ca6ba/" rel="bookmark">
			26款arcgis插件，牛了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
ArcMap自动保存插件
完美解决在ArcMap实用过程中突然奔溃，没有保存数据情况！此插件自动每五分钟进行保存！
02
度分秒-十进制度之间转换函数表格
03
分区域提取单波段栅格插件
04
分区域提取多波段彩色影像插件
05
批量提取栅格插件
06
mdb批量转gdb插件
07
批量导出KML（kmz）插件
08
批量计算四至范围插件
09
批量去除空格插件
10
批量提取统一范围矢量数据插件
11批量添加多个文件夹数据插件
12
编号补零插件插件
13
小斑分组插件插件
14
批量ArcMap转为低版本插件
15
批量SHP转数据库插件
16
按顺序自动编号插件
17
批量投影矢量数据插件
18
更新标识码（BSM）插件
19
多个mxd批量出图插件
17
外部色带（直接添加ArcGIS）
CAD类插件
01
CAD标注线段长度插件
02
CAD或CASS查询命令插件
03
提取填充图案的边界线插件
04
CAD加载影像插件
05
CAD文字样式批量修改器
06
CAD或CASS查询命令插件
07
面积周长计算并输出到EXCEL插件
08
CAD或CASS面积标注为亩插件
09
CAD或CASS批量自动添加界址点坐标插件
插件获取
在插件使用视频下方直接回复即可
重要的事说三遍：抖音搜索 ：中图地信
重要的事说三遍：抖音搜索 ：中图地信
重要的事说三遍：抖音搜索 ：中图地信
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b7fe34c5ad983b166b8f5f9b6b2bfa/" rel="bookmark">
			ArcGIS那些好用的插件，值得拥有！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc106dcec7e48770a7e93ceba51f9519/" rel="bookmark">
			Java - 后端传递多参数数据 - 活用 AjaxResult 与 Map＜String, Object＞ - AjaxResult 与 R 模块的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		演示代码：
@RestController @RequestMapping("/test") public class TestController extends BaseController { @PostMapping("/info") public AjaxResult testinfo(@RequestBody TestEntity testone) { Map&lt;String, Object&gt; testmap = new HashMap&lt;&gt;();; testmap.put("test1","测试1"); // 新增键与其值 testmap.put("test2","测试2"); // 新增键与其值	ordermap.remove("result"); // 删除键与其值 // 成功 - 获取key 为 test1 的数据回传前端 return AjaxResult.success("success", testmap.get("test1").toString()); // 成功 - 数据所有的 testmap回传前端 // return AjaxResult.success("success", testmap ); // 失败 - 数据回传前端 //return AjaxResult.error(test.get("msg").toString()); } } 一、优化数据传输模块的用法与记录 1、 在什么时候可以使用 AjaxResult 或 R 模块 序列化方式不同；某些情况下，使用 ajax 是最好的，某些情况下使用 R 模块却才是最好的，例如服务间用R，返回给前端用AjaxResult 个人理解： 先来了解两者的用法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc106dcec7e48770a7e93ceba51f9519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2e47fe24d6cde6ac2e9a9ecd282c98/" rel="bookmark">
			Vmware配置centos7（简单上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux操作系统 vmware安装centos71.安装下载VM（本次使用VMware Workstation Pro 16）2.安装下载镜像（本次使用CentOS7-x86_64）（1）进入VMware，创建虚拟机（2）设置虚拟机（3）安装操作系统 vmware安装centos7 1.安装下载VM（本次使用VMware Workstation Pro 16） 官方下载地址：https://www.vmware.com/
https://www.vmware.com/cn.html （中文）
下载完成后，一步步安装就好了。
2.安装下载镜像（本次使用CentOS7-x86_64） 镜像：CentOS7
官网下载地址：http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso
（1）进入VMware，创建虚拟机 选择自定义，点击下一步：
选择“稍后安装操作系统”，点击下一步：
选择Linux， 点击下一步：
VMware的默认位置是在C盘下，最好改一下为D盘：
处理器和内存需要根据自己的实际需求来设置，这里选择默认的：
桥接：选择桥接模式的话虚拟机和宿主机在网络上是平级关系
NAT：NAT模式就是虚拟机要联网先通过宿主机才能和外面进行通信
仅主机：虚拟机与宿主机直接连接
磁盘设置，选择默认选择即可：
打开“自定义硬件”，把声卡、打印机等不需要的硬件移除：
点击“完成”，创建号虚拟机：
（2）设置虚拟机 右击新建的虚拟机，点击“设置”；
先选择CD/DVD，再选择使用ISO映像文件。
网络适配器选择“NAT模式”：
（3）安装操作系统 进入之后，会出现以下界面，直接点击回车：
Install CentOS 7 Test this media &amp; install CentOS 7 Troubleshooting 选择语言：
桌面选择GNOME桌面：
选择网络：
设置root登录密码：
完成设置，即可进入Linux操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3835bc3b8e54e34e628d5c8fd8584b22/" rel="bookmark">
			ORM常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORM常见问题解答 前言
​ 结构体标签（tag）在 xorm 和 gorm 中都是用于定义数据库表和结构体字段之间映射关系的，但是它们的具体使用方式略有不同。
​ 在 xorm 中，结构体字段的 tag 是由 xorm 标准和用户自定义两部分组成。其中，xorm 标准的 tag 包括：pk（主键）、notnull（非空）、autoincr（自增）、unique（唯一键）、index（索引）、default（默认值）、created（记录创建时间）、updated（记录更新时间）等。用户自定义的 tag 则可以通过 xorm:"tag_name" 的形式来定义。
​ 在 gorm 中，结构体字段的 tag 则由 gorm 标准和用户自定义两部分组成。其中，gorm 标准的 tag 包括：primary_key（主键）、not null（非空）、auto_increment（自增）、unique_index（唯一键）、index（索引）、default（默认值）、created_at（记录创建时间）、updated_at（记录更新时间）、deleted_at（记录删除时间）等。用户自定义的 tag 则可以通过 gorm:"tag_name" 的形式来定义。
​ 虽然 xorm 和 gorm 中的 tag 使用方式略有不同，但它们的本质都是用于将数据库表和结构体字段之间建立映射关系。因此，使用哪个 ORM 框架，应该根据自己的实际需求来选择。
XORM 1. XORM是什么？ XORM是一个简单而强大的Go语言ORM库，支持MySQL、PostgreSQL、SQLite、Oracle、mssql、TiDB等多种数据库，实现了对象关系映射，即ORM。
2. 如何使用XORM？ 使用XORM，需要先安装XORM包，可以使用如下命令：
go get xorm.io/xorm # or go install github.com/go-xorm/cmd/xorm@latest 安装完成后，可以使用XORM提供的Reverse功能来生成Go结构体，或者使用XORM提供的API操作数据库。
3. 如何使用XORM的Reverse功能生成Go结构体？ 使用XORM的Reverse功能，需要先编写一个配置文件（比如config.yaml）
# 数据库引擎，支持的选项：mysql、postgres、mssql、sqlite3、oracle、odbc dbType: mysql # 数据库连接字符串，根据实际情况修改 connStr: root:password@tcp(localhost:3306)/test?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3835bc3b8e54e34e628d5c8fd8584b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d8dde631990aa5825ccba7e768fbd5/" rel="bookmark">
			云原生技术的个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 云原生概念Kubernetes容器和微服务k8s 服务网格边缘计算云边端 云原生概念 重点在以下三个方面
应用容器化面向微服务架构应用支持容器的编排调度 介绍：
这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。 Kubernetes 容器与微服务以及自动化管理
容器和微服务 容器：
容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）
微服务
微服务，将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。
Docker
Docker 是最常用的容器化工具，也是最流行的容器运行时。Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macO都支持 Docker。还有其他的容器化工具，如 CoreOS rkt、Mesos Containerizer 和 LXC。但是目前，绝大多数的容器化应用都是在Docker允许 k8s K8s：
kubernetes可以一次性将变更传递给所有受控容器
kubernetes同时可以轻松地调度可用容器的方法，这个过程且自动化的
Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点 ——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。
主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。
Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d8dde631990aa5825ccba7e768fbd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c309dfd5a063b680bddffddc332c2d97/" rel="bookmark">
			Python常用库的用法介绍都给大家整理出来啦，非常实用，建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着大数据和人工智能的发展，Python也与多种科技深深绑定。
比如自动化测试，运维，爬虫，数据分析，机器学习，金融领域，后端开发，云计算，游戏开发都有涉及。
万丈高楼平地起，Python这座大厦能够如此强大，就是拥有强大的成千上万的库的支持
无数牛x的轮子在支持这座大厦，今天我们来一起梳理一下，俯瞰整个Python宝库。
那么什么是库呢？ 从代码角度讲：库就是一堆类(class)和函数(function)的集合。
从应用角度讲：库类似生活中的工具箱，箱子里有很多做其他事情必不可少的工具。
举一个例子，如果你想抓取某网站的数据或图片，那么你就需要能处理相关底层网络连接的代码，而这些代码都已经被写好了，你只需要调用库里的函数或类，能够提高开发效率。
面对不同的情况，自然需要不同的工具箱，那么，都有哪些Python库呢？
一、数据处理 Chardet # 字符编码探测器，可以自动检测文本、网页、xml的编码； colorama # 主要用来给文本添加各种颜色，并且非常简单易用； Prettytable # 主要用于在终端或浏览器端构建格式化的输出 difflib # Python标准库，计算文本差异； Levenshtein # 快速计算字符串相似度 fuzzywuzzy # 字符串模糊匹配 esmre # 正则表达式的加速器 shortuuid # 一组简洁URL/UUID函数库 ftfy # Unicode文本工具7 unidecode # ascii和Unicode文本转换函数 xpinyin # 将汉字转换为拼音的函数库 pangu.py # 调整对中日韩文字当中的字母、数字间距； pyfiglet # Python写的figlet程序，使用字符组成ASCII艺术图片； uniout # 提取字符串中可读写的字符 awesome slugify #一个Python slugify库，用于处理Unicode。 python-slugify # 转换Unicode为ASCII内码的slugify函数库 unicode-slugify # 生成unicode内码，Django的依赖包。 ply # Python版的lex和yacc的解析工具 phonenumbers # 解析电话号码，格式，存储和验证的国际电话号码 python-user-agents # 浏览器的用户代理（user-agents）的解析器 sqlparse # SQL解析器 pygments # 一个通用的语法高亮工具 python-nameparser # 解析人名，分解为单独的成分； pyparsing # 通用解析器生成框架 tablib # 表格数据格式，包括，XLS、CSV，JSON，YAML； python-docx # docx文档读取，查询和修改，微软Word 2007 / 2008的docx文件； xlwt/xlrd # 读写Excel格式的数据文件 xlsxwriter # 创建Excel格式的xlsx文件 xlwings # 利用Python调用Excel csvkit # CSV文件工具包 marmir # 把Python[数据结构]，转化为电子表格； pdfminer # 从PDF文件中提取信息 pypdf2 # 合并和转换PDF页面的函数库 Python-Markdown # 轻量级标记语言Markdown的Python实现 Mistune # 快速、全功能的纯Python编写的Markdown解释器； dateutil # 标准的Python官方datetime模块的扩展包，字符串日期工具，其中parser是根据字符串解析成datetime，而rrule是则是根据定义的规则来生成datetime； arrow # 更好的日期和时间处理Python库 chronyk # 一个Python 3版函数库，用于解析人写的时间和日期； delorean # 清理期时间的函数库 when.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c309dfd5a063b680bddffddc332c2d97/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/150/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>