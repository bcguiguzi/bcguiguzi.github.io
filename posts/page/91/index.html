<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40bcef546d3f7f3a563309dceb15178c/" rel="bookmark">
			嵌入式外设集 -- 语音播报模块（JR6001）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、模块介绍
关注微信公众号--星之援工作室 发送关键字（JR6001）
使用的注意事项
二、移植使用（资料代码中没有移植后的代码，需要自行移植）
1.串口配置
usart2.c
usart2.h
2.JR6001的功能代码编写
JR6001.c
JR6001.h
三、参考
一、模块介绍 JR6001是一种语音播放模块，具有以下特性：
1. 自带USB接口，可以灵活地替换SPI-flash中的语音内容，无需安装主机电脑来替换传统语音芯片的语音。SPI FLASH直接模拟为U盘，就像复制U盘一样，非常方便。任何计算机系统都可以支持它【7†source】。
2. 支持MP3、WAV高质量音频格式，声音优美。
3. 24位DAC输出，动态范围支持90dB，信号比85dB。
4. 支持两线串口控制，AD控制。
5. USB更新语音文件，无需安装驱动程序，无需安装软件，直接复制，快速方便。支持XP系统，WIN7，WIN8，WIN10系统。
6. 支持上一首歌，下一首歌，播放，暂停，停止，选歌，和其他常见功能控制。 7. 支持自由组合播放。 8. 支持30级音量调整。
9. 支持周期号设置，更多应用，更人性化。
10. 专用BUSY信号输出指示。
11. 成熟的指令和指令分析使应用更稳定。
12. 专用支持主机电脑，快速使用，易于调试，命令自动生成【8†source】。
关注微信公众号--星之援工作室 发送关键字（JR6001） ➡️🫡🫡🫡🫡🫡🫡🫡🫡➡️
使用的注意事项 1.只需要配置一个串口即可，波特率为9600
二、移植使用（资料代码中没有移植后的代码，需要自行移植） 1.串口配置 usart2.c 因为我们使用的JR6001模块是需要使用串口进行通信控制（详情可在获取的资料中查看），我们只需要用到该串口的发送端口即可，不需要处理JR6001回传的数据，所以接收中断中的数据处理可略过 ~~ （引用GPS的串口配置）
#include "delay.h" #include "usart2.h" #include "stdarg.h" #include "stdio.h" #include "string.h" char rxdatabufer; u16 point1 = 0; _SaveData Save_Data; #if EN_USART2_RX // 如果使能了接收 // 串口1中断服务程序 // 注意,读取USARTx-&gt;SR能避免莫名其妙的错误 char USART_RX2_BUF[USART2_REC_LEN]; // 接收缓冲,最大USART_REC_LEN个字节.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40bcef546d3f7f3a563309dceb15178c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88db1f410f468d6da22bb9c80aba79e6/" rel="bookmark">
			Java数据结构与算法-1.2队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列 1.队列的一个使用场景 银行排队的案例:
2.队列介绍 队列是一个有序列表，可以用数组或是链表来实现。
遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
示意图：(使用数组模拟队列示意图)
3.数组模拟队列思路 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。
因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:
思路分析：
当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析
将尾指针往后移：rear+1 , 当front == rear 【空】若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1【队列满】 4.数组模拟队列实现 1.新增元素addQueue
2.出队列操作getQueue
3.显示队列的情况showQueue
4.查看队列头元素headQueue
5.退出系统exit
代码实现 /** * 功能描述: 队列 - 数组模拟队列练习 * * @author lunaw- * @version 1.0 * @date 2023/12/7 22:37 */ public class QueueDemo { public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88db1f410f468d6da22bb9c80aba79e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f49c020fcce6da284338b57e413f084/" rel="bookmark">
			使用 nnUNetv2 的一些踩坑记录（或许还会有继续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nnUNet 依然是最鲁棒的分割网络。今年初原作者更新了 nnUNet 的第二版即 nnUNetv2，题主近期试用的时候有一些踩坑的地方进行记录。
没有官方提供的预训练权重 官方文档在一个非常不起眼的角落提及了，v2版本尚无预训练权重可直接使用，有相关需求请使用 V1 版。
windows 下 nnUNet_raw 等参数设置 第一版 nnUNet 是不支持 windows 的，v2则添加了windows支持。在进行训练前需要设置 nnUNet_raw 等三个路径参数，如何设置可以参考其他教程。此处只提及如何设置三个路径。以 anaconda 为例，直接在对应虚拟环境中 set nnUNet_raw = 路径 即可，注意路径避免. 等特殊符号，此外不需要双引号，如 set nnUNet_raw = C:\\myPC\\Desktop 即可。
未完待续 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9ad8043d9b4bef6967aca7be9807d6/" rel="bookmark">
			hibernate实现ID序列自增，异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题描述
二、问题解析
一、问题描述 明明数据库表设置了id自增，为啥添加数据时，会抛出异常呢？
具体内容如下：
（1）控制台异常打印如下
org.hibernate.id.IdentifierGenerationException: ids for this class must be manually assigned before calling save()
（2）数据库表
（3）entity表
public class UEntity { @Id private Long id; ...... } 二、问题解析 hibernate 是通过 entity 表映射来访问数据库表的。
如果 entity 表映射配置不正确，就会抛出这样的异常。
所以，既然数据库表配置了自增，那么就是 entity 表配置的问题。
entity表正确配置
public class UEntity {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
......
}
所以，entity表更改为上面的配置，异常就解决了。
我是程序员娟娟，
致力将工作中遇到的问题和解决方案记录下来，
分享给更多需要的同行。
如果对你有帮助，不妨点个关注吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc61f4c896a9cccf86e3eb7e3c24bfb/" rel="bookmark">
			请求头中的Authorization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		header里面放Authorization，就是为了验证用户身份。
Authorization里面放的就是token，就相当于每次发送请求的时候，拦截器都会拦截一次你的请求，来验证请求的token与储存的token是否是一致的。
如果一致会把当前请求放行，
如果不一致那么服务器会截断你的请求并把错误码返给前端，让前端验证身份重新登陆
我们在请求拦截里面配置
// 请求拦截 service.interceptors.request.use((config) =&gt; { config.headers = config.headers || {} const token = localStorage.getItem('token') if (token) { config.headers['Authorization'] = 'Bearer ' + token } return config }) 有时候携带的可能不是token也可能是cookie，根据项目需求去配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41612040473c4af9a021bc97ce66afa/" rel="bookmark">
			【湖南师范大学主办，湖南师范大学信息科学与工程学院承办，华南理工大学协办|JPCS独立出版，EI检索稳定】2024年智能电网与人工智能国际学术会议（SGAI 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着时代的发展，基础的电网技术已经比较成熟，但与日俱增的用电需求以及不断转变的用电模式促使我们需要不断地优化电网技术，而结合计算机、AI、传统电力技术的智能电网是电网技术发展的趋势，这加速了这个学科的发展，由此也产生了非常多值得探究的学术问题。
2024年智能电网与人工智能国际学术会议（SGAI 2024)将于2024年1月12-14日在广州举办。会议由湖南师范大学主办，湖南师范大学信息科学与工程学院承办，华南理工大学协办，Ain Shams University提供会议支持。会议主要围绕智能电网以及相关的人工智能技术展开讨论。大会旨在为从事相关行业的专家、科研学者、技术人员共享科研成果和前沿技术，让大家了解学术发展趋势，拓宽研究思路，加强学术研究和探讨，促进学术成果产业化。
大会网站：https://ais.cn/u/JbMVZb（更多会议详情）
2024年1月12-14日，中国广州
截稿时间：以官网信息为准
提交检索：EI、Scopus【JPCS独立出版 EI检索稳定 】
*更多详细会议信息、投稿优惠、投稿事项、优先审核【click】
组织单位
主办单位 承办单位 湖南师范大学
湖南师范大学信息科学与工程学院 协办单位 支持单位 华南理工大学
Ain Shams University 新加坡机器人学专业协会 论文出版
本会议的投稿经过2-3位组委会专家严格审核之后，录用的文章将由EI系列目录期刊 Journal of Physics: Conference Series (JPCS) (ISSN:1742-6596)出版，并提交至EI Compendex和Scopus数据库检索。该出版物见刊检索稳定 SCI期刊论文（click）
*期刊1：COMPUTERS &amp; ELECTRICAL ENGINEERING（ISSN: 0045-7906，IF=3.818）
*期刊2：Journal of Electronic Imaging（ISSN: 1662-5188，IF=0.95+）
征稿主题
一. 智能电网
智能电网技术
智能传感器
电网接口
电力和能源系统
智能电网与分布式能源
配电系统和变电站自动化
能源系统中的广域保护、通信和控制
电力装备智能化 智能电网部署
电力系统及其自动化
电力系统建模、仿真与分析
电力系统规划与调度
监测和控制智能电网的电能质量
多领域应用的智能电网
大电网稳定控制
电力系统通信与控制
电网智能调度
智能配用电与微电网
智能规划和调度
二. 人工智能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c41612040473c4af9a021bc97ce66afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c14e46a8238e07dcd5377feddb04194/" rel="bookmark">
			后端返回二进制流文件 excle导出 或者xls xlsx docx pdf导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 //数据查询记录 excle导出 export function exportInterfaceSearch(data) { return request({ url: '/risen/data/exportInh', method: 'post', responseType: 'blob', // 第一步 data }) 第二步 res 是后端返回的二进制流文件 const url = window.URL.createObjectURL(res) const a = document.createElement('a') a.style.display = 'none' a.href = url a.download = '数据目录' document.body.appendChild(a) a.click() document.body.removeChild(a) window.URL.revokeObjectURL(url) 或者 这种写法
//接口列表导出 export function exportInterfaceManagement(params) { return request({ method: 'get', isFormData: true, url: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxx' responseType: 'blob', params }) } async impotout() {//导出 exportInterfaceManagement({ }).then((res) =&gt; { const blob = new Blob([res], { type: 'application/vnd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c14e46a8238e07dcd5377feddb04194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a3e925e25e71d5458a71d5cb71235ed/" rel="bookmark">
			（C语言）寻找局部最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部最大值：如果证书矩阵P的费边界元素P[i][j]大于相邻的上下左右四个元素，则P[i][j]为矩阵P的局部最大值。
编写程序实现对任意输入的m行n列的整数矩阵，输出该矩阵所有局部最大值及其所在位置。
#include&lt;stdio.h&gt; void local(int m,int n) { int a[m][n]; for(int i = 0;i &lt; m;i ++) { for(int j = 0;j &lt; n;j ++) { scanf("%d",&amp;a[i][j]); } } for(int i = 1;i &lt; m-1;i ++) { for(int j = 1;j &lt; n-1;j ++) { if(a[i][j] &gt; a[i-1][j] &amp;&amp; a[i][j] &gt; a[i][j-1] &amp;&amp; a[i][j] &gt; a[i+1][j] &amp;&amp; a[i][j] &gt; a[i][j+1]) printf("极大值为%d，在第%d行第%d列\n",a[i][j],i+1,j+1); } } } int main() { int m,n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a3e925e25e71d5458a71d5cb71235ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c69bb23b6172202ac4f0c931f7d01b/" rel="bookmark">
			（C语言）判定同数异形体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 同数异形体：有相同的数字包括数字个数，不同排列形成的正整数。
例如：12334和33214均由1个1,1个2,2个3,1个4组成，故互为同数异形体，而1234和3221就不是。
#include&lt;stdio.h&gt; bool Isomorphism(int num1,int num2) { int a[10] = {0},b[10] = {0}; while(num1) { a[num1 % 10] ++; num1 /= 10; } while(num2) { b[num2 % 10] ++; num2 /= 10; } for(int i = 0;i &lt; 10;i ++) { if(a[i] != b[i]) return false; } return true; } int main() { int num1,num2; scanf("%d %d",&amp;num1,&amp;num2); if(Isomorphism(num1,num2)) printf("%d和%d是同数异形体\n",num1,num2); else printf("%d和%d不是同数异形体\n",num1,num2); return 0; } 运行截图：
注：侵权可删 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4f3e22376cbfc87aee92a33617b6b9/" rel="bookmark">
			MySQL：update set的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题描述
二、为何会出现这样的问题？
三、正确的方案
一、问题描述 我在修改mysql数据表时，看到下面的现象。
我表中原始数据如下：
执行了下面的修改，显示执行成功。
update user_function_record_entity set open_id = 8 and reason = '已修改' and create_time = now() where id = 2;
再次查询数据如下：
从修改后的数据看，不是我预期的结果，为什么呢？
下面就来分析分析。
二、为何会出现这样的问题？ 首先，其根本问题在于 set 后用了 and 。
因为 set 的语法是，当修改多个值时，是用英文逗号间隔，而不是and间隔。
那为什么在执行命令时，没有提示错误呢。
因为带了and的命令，其真实执行逻辑如下
update user_function_record_entity set open_id = (8 and reason = '已修改' and create_time = now())
where id = 2;
因为 (8 and reason = '已修改' and create_time = now()) 通过逻辑运算是false，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4f3e22376cbfc87aee92a33617b6b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35175937f5b0ffec65c4a0b8893d1541/" rel="bookmark">
			Ubuntu下vs code配置C/C&#43;&#43;编译器和调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统信息如下： 学习内容： 首先安装vs code，vs code安装可以在应用市场安装。gcc安装 ，在终端输入sudo apt-get install gcc
在vs code安装下图安装的8个工具，做啥用的可以自己bing。
需要编译的多个源文件路径结构如下：
点击main函数所在的main.c文件&gt;&gt;&gt;&gt;终端&gt;&gt;&gt;&gt;配置默认生成任务，如下图。之后会生成一个.vscode文件夹下面有一个tasks.json
5.右击.vscode文件夹.&gt;&gt;&gt;&gt;点击新建文件。生成一个launch.json文件。
在 Visual Studio Code 中，这两个文件的作用分别是：
1.tasks.json: 任务配置文件, 用于定义和配置代码编译、构建和其他任务。通过配置任务，你可以使用快捷键或命令面板执行这些任务。如，你可以配置编译、运行测试、清理项目等任务。
2.launch.json 用于配置调试器的启动行为。你可以设置断点、选择启动的程序、传递命令行参数等。通过配置这个文件，你可以在 VS Code 中调试你的应用程序。
以上两个资源文件配置如下图，懒人也可以去这个链接下载，然后直接复制。
完整的配置文件链接
6. 配好之后，重新打开vs code如下图，观察工具栏的最下面，此时没有出现生成按钮，甲壳虫(调试按钮)，三角形（运行按钮）
构建Cmakelist.txt,首先shift+ctrl+p，在vs code最上面弹出一个搜索框，如下图：
输入cmake:q，选择cmake:Quick Start
回车之后，弹出输入项目名字，这边名字随便取一个
回车之后选择需要编译的项目，本项目是C语言，所以选择&gt;&gt;&gt;&gt; 创建C项目
之后会弹出选择创建项目的类型，是创建库（Library）,创建可执行文件(Executable)，这里我们选择创建可执行文件。
完了之后就会弹出CmakeLists.txt，现在观察状态栏的最下面多了三个按钮。生成，甲壳虫(调试按钮)，三角形（运行按钮）
因为是多个文件夹下面的源文件需要编译，所以需要修改这个文件，把add_executable(demo main.c)这个替换成下面三行
添加 Algorithm 文件夹下的所有 .c 文件 file(GLOB ALGORITHM_SOURCES “Algorithm/*.c”)
添加 Serial 文件夹下的所有 .c 文件 file(GLOB SERIAL_SOURCES “Serial/*.c”)
将所有源文件添加到可执行文件中 add_executable(ems_logger main.c ${ALGORITHM_SOURCES} ${SERIAL_SOURCES})
然后点击状态栏生成按钮，编译一下，通过编译之后就可以点击生成了。如下图
最后在代码里面打个断点，点击调试甲壳虫，如图欧了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2e316066f3b2c9e549e7f784cfe707/" rel="bookmark">
			前端手撕、底层源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序升序 // js底层sort是插入和快排结合，arr.length&lt;10插入，否则快排 // 冒泡排序 稳定 function maopao(arr){ let n=arr.length //外层循环趟数 for (let i = 0; i &lt; n - 1; i++){ // 内层循环每个元素需要的次数 for (let j = 0; j &lt; n - 1 - i; j++){ //相邻数字比较 if (arr[j] &gt; arr[j + 1])[arr[j],arr[j+1]]=[arr[j+1],arr[j]] } } return arr } // 插入排序 稳定 function cha(arr){ let n=arr.length for (let i = 1; i &lt; n; i++){ let temp=arr[i] for(var j=i;j&gt;0&amp;&amp;temp&lt;arr[j-1];j--){ arr[j]=arr[j-1] } arr[j]=temp } return arr } // 快排 不稳定 O(nlogn) function quick(arr){ let n=arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2e316066f3b2c9e549e7f784cfe707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032df9b33f1e2df13d671e7311b6ca79/" rel="bookmark">
			vue&#43;ant调用后端数据 控制switch开关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.8发现自己之前的一个草稿，稚嫩的功能。想想决定整理后发出来，当做纪念。
思路：
1.调用后端接口接收数据status
2.每列status判断开关switch的开关状态
3.每次开关，将id对应的开关状态status返回后端
Html：
&lt;a-row class="pushSettings"&gt; &lt;a-col :style="{ marginBottom: '8px' }" :span="24"&gt; &lt;div class="pushswitch" v-for="(item, index) in switchList"&gt; &lt;div class="pushContent"&gt;{{ item.pushContent }}&lt;/div&gt; &lt;div class="pushJudgment"&gt; &lt;a-switch :default-checked="item.ifPush == 0 ? true : false" @change="judgmentSwitch(item, index)" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a-col&gt; &lt;/a-row&gt; 后端接口：
从/pull获取到
{
"ifPush": 0,1 开/关
"id": 1, 内容的id
"pushContent": "内容1"
},
点击开/关按钮 调用/push接口
传上面接口获取到的id 字段名pushId
状态status 点开就传0 关就传1
CSS:
.pushSettings { width: 100%; height: 100%; background: #ffffff; border-radius: 16px; padding: 24px; display: flex; flex-direction: column; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032df9b33f1e2df13d671e7311b6ca79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081506755fa9d783c5a17d1fea2e32c2/" rel="bookmark">
			宝塔面板相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		① 部署python项目报错urllib3
raise ImportError( ImportError: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.0.2k-fips 26 Jan 2017'. See: https://github.com/urllib3/urllib3/issues/2168 解决更改urllib3版本为1.21.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c596774b566ea305b0272fe9e6c39b45/" rel="bookmark">
			【SpringBoot】不用第三方Web服务器部署静态资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人都遇到过在使用 Springboot 构建前后端分离的 Web 应用时，往往需要使用静态网页服务器（例如：Nginx）部署前端，使用 java 环境来启动后端。对于单点部署来说，需要增加一个额外的Web服务器就显得有点麻烦，特别是在容器化环境下，如果既要静态网页服务器、又要Java环境，要么你iju使用两个容器来分别运行前后端，要么你就只能自己重新构建一个包含两个环境的新容器镜像来实现，对于小应用来说这都是不经济的。
我正好也遇到了这样的一个需求：
研发给我提供了后端应用的 jar 文件和前端静态页面文件包，要求部署在一个容器中。
最终想到的方案是研究 SpringBoot 本身是否具备再不需要对后端文件进行重新打包的情况下，通过部署来解决了这个问题。最终在下面的文档中找到了解决方案：
web.servlet.spring-mvc.static-content
下面是我在实施这个方案中的一些具体细节，供读者大大们参考。
环境 JDK 1.8Spring Boot 2.7.18Docker （Docker Compose） 目录结构 &lt;ROOT&gt; |-- docker-compose.yml # 容器配置文件 |-- web.jar # 后端 jar |-- public # 前端文件包 |-- index.html |-- js |-- css 容器运行配置 这里需要将后端文件（web.jar）和前端目录（public）都挂载到容器内部。
# docker-compose.yml version: "3.7" services: web: image: openjdk:8 container_name: web volumes: - ./web.jar:/opt/web/web.jar - ./public:/opt/web/public ports: - "8080:8080" command: "java -jar /opt/web/web.jar --server.port=8080 --spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c596774b566ea305b0272fe9e6c39b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7806340b82e177df35593e04a5c5ad/" rel="bookmark">
			IP地址定位不准确的原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然IP地址定位技术在许多领域发挥着重要作用，但在某些情况下，定位结果可能并不准确。本文将探讨IP地址定位不准确的原因以及可能的解决方法，帮助理解这一技术的局限性并提高其准确性。
1. 动态IP地址分配：
许多互联网服务提供商（ISP）使用动态IP地址分配，这意味着用户在不同时间点可能获得不同的IP地址。由于IP地址是与地理位置相关联的，动态IP地址的使用可能导致定位不准确，特别是对于那些移动设备用户。
解决方法：利用更高级的技术，如基站定位、GPS等，辅助IP地址定位以提高准确性。
2. 代理服务器和虚拟专用网络：
用户使用代理服务器可以隐藏其真实IP地址，使得IP地址定位更加困难。这是网络隐私保护的一种常见做法，但也对定位服务带来了挑战。
解决方法：识别代理服务器IP地址IP数据云 - 免费IP地址查询 - 全球IP地址定位平台，采用其他手段进行用户身份验证，如用户行为分析。
3. Wi-Fi和移动网络切换：
移动设备通过Wi-Fi和移动网络切换时，可能会获取不同的IP地址。这种切换可能在短时间内发生多次，导致IP地址定位的不准确性。
解决方法：整合Wi-Fi和移动网络信息，综合考虑多种定位手段，以提高准确性。
4. 地理位置数据库的过时：
地理位置数据库的信息可能过时，未能及时更新新的IP地址分配情况。这会导致查询结果与实际不符。
解决方法：定期更新地理位置数据库，保持信息的实时性。
5. 网络延迟和拓扑变化：
网络中的延迟和拓扑变化可能导致IP地址与实际位置不一致，尤其是在复杂的网络环境中。
解决方法：结合其他网络拓扑信息，如路由器跃点等，辅助IP地址定位。
6. 错误的地理位置信息提供：
有时，地理位置信息可能被错误地提供，或者用户选择禁止应用获取其真实地理位置。
解决方法：引导用户允许应用获取地理位置，并强调信息隐私的安全性。
7. 未知IP地址或匿名网络：
某些IP地址可能无法被地理位置数据库正确识别，或者来自匿名网络，这使得准确的地理位置定位变得困难。
解决方法：针对未知IP地址或匿名网络，可以采用其他安全措施，并在可能的情况下进行进一步的调查。
虽然IP地址定位技术在许多场景下是非常有用的，但其准确性受到多种因素的影响。理解IP地址定位不准确的原因，并采用多种手段综合考虑，可以提高定位的准确性。对于安全和隐私敏感的应用，需要更加谨慎地处理IP地址定位结果，并在合适的情况下引入其他高级定位技术，以确保用户数据的隐私和安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0815bc7d39ca03639805da8dc194c8b/" rel="bookmark">
			修改python打包后的窗体图标、任务栏图标、exe图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我python开发的GUI界面(图形用户界面)一直是tkinter，打包exe一直是Pyinstaller。但是打包出来的exe图标、状态栏图标、窗体左上角图标一直是默认的羽毛，我想自定义。 效果 最后使用base64创建临时ico解决了该问题
步骤 创建icoToBase64.py，内容如下： import base64 # ico转base64 open_icon = open("./img/logo.ico", "rb") b64str = base64.b64encode(open_icon.read()) # 转换为base64编码 open_icon.close() write_data = "imgBase64 = %s" % b64str f = open("./img/logo.py", "w+") f.write(write_data)# 写入文件 f.close() 创建img目录，将准备好的logo.ico放入img目录中。运行icoToBase64.py文件，将ico转换为base64,写入py文件，得到logo.py。引入logo.py，使用base64创建临时logo，自定义窗体图标与任务栏图标。 from img.logo import imgBase64 # 创建临时logo def createTempLogo(): # 处理图片 tmp = open("temp.ico", "wb+") # 创建temp.ico临时文件 tmp.write(base64.b64decode(imgBase64)) # 写入img的base64 tmp.close() # 关闭文件 ... createTempLogo() root.wm_iconbitmap("temp.ico")# 使用wm_iconbitmap引入创建的ico if os.path.exists("temp.ico"): os.remove("temp.ico")# 创建logo后需删除临时logo ... 执行命令：pyi-makespec -F -w main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0815bc7d39ca03639805da8dc194c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53bf7bac9511ed920c1803d01aa707a/" rel="bookmark">
			网络和Linux网络_3(套接字编程)TCP网络通信代码(多个版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. TCP网络编程
1.1 前期代码
log.hpp
tcp_server.cc
1.2 accept和单进程版代码
1.3 多进程版strat代码
1.4 client.cc客户端
1.5 多进程版strat代码改进+多线程
1.6 线程池版本
Task.hpp
lockGuard.hpp
thread.hpp
threadPool.hpp
多个回调任务
最终tcp_client.cc
最终tcp_server.hpp
2. 笔试选择题
答案及解析
本篇完。
1. TCP网络编程 框架和前面udp通信一样，接口函数上一篇也讲了，这里直接放一部分代码：
1.1 前期代码 log.hpp #pragma once #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdarg&gt; #include &lt;ctime&gt; #include &lt;string&gt; // 日志是有日志级别的 #define DEBUG 0 #define NORMAL 1 #define WARNING 2 #define ERROR 3 #define FATAL 4 const char *gLevelMap[] = { "DEBUG", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a53bf7bac9511ed920c1803d01aa707a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72448b54ab08861c4f68b7a956578141/" rel="bookmark">
			在vue中解析csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue项目中使用xlsx库来解析CSV文件并将其转换成数组，可以按照以下步骤进行操作：
安装xlsx库：
如果你的项目中还没有安装xlsx库，可以使用npm或yarn来安装它。
npm install xlsx # 或者 yarn add xlsx 在Vue组件中导入xlsx库：
在需要处理CSV文件的组件中，导入xlsx库。
import * as XLSX from 'xlsx'; 实现文件上传和解析功能：
&lt;template&gt; &lt;input type="file" @change="handleFileUpload"&gt; &lt;/template&gt; 编写处理文件上传的方法：
在Vue组件的methods部分编写handleFileUpload方法，用于处理文件上传和解析CSV文件。
&lt;script&gt; export default { methods: { async handleFileUpload(event) { const files = event.target.files; if (files &amp;&amp; files[0]) { const data = await this.parseCSV(files[0]); } }, parseCSV(file) { return new Promise((resolve, reject)=&gt;{ try{ const reader = new FileReader(); reader.onload = (e) =&gt; { const data = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72448b54ab08861c4f68b7a956578141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4117855df711aabf94f828d08d973437/" rel="bookmark">
			【ACM独立出版、确定的ISBN号】第三届密码学、网络安全和通信技术国际会议（CNSCT 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三届密码学、网络安全和通信技术国际会议（CNSCT 2024）
2024 3rd International Conference on Cryptography, Network Security and Communication Technology 随着互联网和网络应用的不断发展，网络安全在计算机科学中的地位越来越重要，密码学，网络安全的核心领域之一就是其中一个重要的话题，此外，网络安全的重要性与通信技术息息相关。为增进关于在密码学、网络安全通讯技术学者之间的学术交流，分享研究经验，探寻合作机会，推动领域科学研究的发展，由南昌大学主办的2024年第三届密码学、网络安全和通信技术国际会议（CNSCT 2024）将于2024年1月19日至21日在中国哈尔滨举办。会议旨在提供一个分享经验、扩大专业网络、面对面交流新思想和展示研究成果的国际平台。
此前，CNSCT 2023会议论文集由SPIE - The International Society for Optical Engineering (ISSN: 0277-786X)出版社出版并全部实现EI Compendex和SCOPUS检索。
由华东交通大学、大连交通大学和重庆大学主办的首届密码学、网络安全和通信技术国际会议于2022年1月22日在线上顺利召开，多位专家学者进行了精彩的报告。会后，CNSCT 2022会议论文集由SPIE - The International Society for Optical Engineering (ISSN: 0277-786X)出版社出版并全部实现EI Compendex和SCOPUS检索。
重要信息
大会官网：www.iccnsct.net（点击参会/投稿/了解会议详情）
时间地点：2024年1月19-21日 中国-哈尔滨
接受/拒稿通知：投稿后七个工作日内
收录检索：EI Compendex，Scopus
征稿主题
密码学网络安全通信技术密码协议 加密和编码
不可追踪性
隐私和身份验证
密钥管理
信任管理
量子密码术
安全计算智能
人工免疫系统
生物和进化计算
智能代理和系统
强化与无监督学习
面向自治的计算
协同进化算法
模糊系统
生物特征安全
信任模型和度量
监管和信任机制
数据完整性
身份验证、信任和授权模型
无线网络安全
信息隐藏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4117855df711aabf94f828d08d973437/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/90/">«</a>
	<span class="pagination__item pagination__item--current">91/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/92/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>