<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e682ea8fb1d07bfb1c00fb861546e360/" rel="bookmark">
			给Jsoup设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何给Jsoup增加代理，主要有两类原因需要增加代理：
组织提供代理控制内部访问，如果在本地代理网络中通过Jsoup访问，会抛出异常：java.net.SocketTimeoutException: connect timed out;当见到该异常时，我们需要给Jsoup设置代理，否则不能访问外部网络。
防止IP被封：另外一种情况是防止网站封锁我们的IP地址。也就是说，使用代理（多个滚动代理）可以更可靠解析HTML，避免因为封锁IP地址让代码停止运行。
增加依赖 Maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt; &lt;/dependency&gt; Gradle依赖：
compile 'org.jsoup:jsoup:1.13.1' 增加代理 有两种方法给Jsoup增加代理支持。
基于属性增加 给Jsoup增加代理很容易，直接在Connection对象上调用proxy(String, int)方法：
Jsoup.connect("https://spring.io/blog") .proxy("127.0.0.1", 1080) .get(); 第一个参数为主机地址，另一个是端口号。
基于Proxy类增加 我们也可以通过Proxy类实现，在Connection对象上调用它的proxy(java.net.Proxy)方法：
Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", 1080)); Jsoup.connect("https://spring.io/blog") .proxy(proxy) .get(); 此方法接受一个Proxy对象，该对象由代理类型(通常为HTTP类型)和InetSocketAddress(封装代理主机名和端口属性的包装类)组成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196e9f38b8254080bd655049b031df11/" rel="bookmark">
			Java基础之国际化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国际化程序实现 文章目录 国际化程序实现原理前期准备编码问题读取资源文件ResourceBundle 实现步骤消息格式化显示 原理 国际化程序：同一个程序代码可以根据不同语言描述，但核心业务是相同的
实现国际化程序开发
定义保存文字的文本信息
根据不同区域语言的编码读取指定的资源信息
前期准备 编码问题 解决不同国家用户的区域和语言的编码问题
java.uilt.Locale 类专门描述区域和语言编码 Locale 类主要构造方法
public Locale(String language)
public Locale(String language, String country)
需要国家和语言的代码 中文的代码:zh_CN美国英语的代码: en_US 区域和语言的编码最佳获得方式就是通过 IE 浏览器
利用 Locale 类自动获取当前运行环境
默认方式实例化 读取本地默认环境 Locale loc = Locale.getDefault();loc 输出 zh_CN 在实际开发中大多并不关心国家和语言的编码，将一些著名国家编码设置了常量简化开发
常量实例化 Locale 对象 Locale loc = Locale.CHINA; loc 输出 zh_CN 避免一些区域编码信息的繁琐 读取资源文件 主要依靠 ResourceBundle 类进行
public abstrach class ResourceBundle{} 该类为抽象类，使用其子类完成资源读取
或其中的一个静态方法获取 ResourceBundle 对象 public static final ResourceBundle getBundle(String baseName) baseName：资源文件名称，不含后缀；即资源文件路径 根据 key 读取资源内容 public final String getString(String key) 资源读取时要确保路径下有文件，且文件中存在相应的 key ResourceBundle 包含特定于语言环境的对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/196e9f38b8254080bd655049b031df11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09aaa9e47debe32b408e3724dcef1838/" rel="bookmark">
			linux 网络管理之route命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令介绍 ​ route命令用于显示和控制IP路由表；通过使用一个连接两个网络的路由器或者同时位于两个网络的网关来实现不同子网之间的通信。在局域网中通常设置本机的IP地址作为机器的默认路由，通过这种方式使得机器能够访问Internet。使用route命令添加路由不会永久保存，当机器或者网卡重启后，路由就失效了，要想永久生效，可以采用如下几种方式
在/etc/rc.local 里添加路由信息
在/etc/sysconfig/network里添加到末尾
修改/etc/sysconfig/static-router
用法 [root@ ~]# route -h Usage: route [-nNvee] [-FC] [&lt;AF&gt;] List kernel routing tables route [-v] [-FC] {add|del|flush} ... Modify routing table for AF. route {-h|--help} [&lt;AF&gt;] Detailed usage syntax for specified AF. route {-V|--version} Display version/author and exit. -v, --verbose be verbose -n, --numeric don't resolve names -e, --extend display other/more information -F, --fib display Forwarding Information Base (default) -C, --cache display routing cache instead of FIB 功能选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09aaa9e47debe32b408e3724dcef1838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a228b9ca028ab229dae4f0e0153f98/" rel="bookmark">
			Element is missing end tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="map"&gt; &lt;div id="main" style="width: 100%; height: 400px;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;template&gt; 这是因为没有闭合template标签导致的
&lt;template&gt; &lt;div class="map"&gt; &lt;div id="main" style="width: 100%; height: 400px;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 闭合一下就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1975f257a9e151820527ed47e8054833/" rel="bookmark">
			引用计数法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理篇 GC是一种释放无法被引用对象的机制。引用计数法的思想是让每个对象记录下有多少程序引用自己，我们形象的称之为"人气"，并且让没有人气的对象自动消失。引用计数法诞生于1960年，由George E. Collins创造。
引用计数法在对象头中添加了一个计数器来记录对象的被引用数。
分配一个新对象的伪代码如下：
//分配内存 new_obj(size) { //从空闲链表中寻找一个合适的分块 obj = pickup_chunk(size, $free_list) if (obj == NULL) allocation_fail() //分配失败 else obj.ref_cnt = 1 //初始化引用计数为1 return obj } 在分配过程中，也是去空闲链表中寻找一个大小合适的分块，这和GC标记清除算法是一样的。当成功找到合适的分块后，我们将它的引用计数设置为1，因为是新分配的，所以只有一个引用。
你会发现在引用计数法中，并没有显示的垃圾清除过程，那些引用为0的对象是在何时被回收的呢？
回答这个问题之前我们需要先思考另一个问题：什么时候一个对象的"人气"会发生变化？一个是在分配对象的时候会增加"人气"。另一个是在更新指针的时候，源指针指向的对象"人气"会减少，目的指针指向的对象"人气"会增加。
更新指针函数伪代码如下：
//更新指针 update_ptr(ptr, obj) { inc_ref_cnt(obj) //增加目的对象的引用计数 dec_ref_cnt(*ptr) //减少源对象的引用计数 *ptr = obj } //增加对象obj的引用计数 inc_ref_cnt(obj) { obj.ref_cnt++ } //增加对象obj的引用计数， //并将引用计数为0的对象回收 dec_ref_cnt(obj) { obj.ref_cnt-- //减少对象obj的引用计数 if(obj.ref_cnt == 0) //不再被引用，表示变成了垃圾 for(child : children(obj)) //遍历obj的子对象 dec_ref_cnt(*child) //将子对象引用计数减一，因为obj被回收了 reclaim(obj) //将obj加入空闲链表 } update_ptr的核心是*ptr=obj，inc_ref_cnt和dec_ref_cnt是为了进行内存管理，注意二者的顺序不能颠倒。因为如果ptr本来就是指向obj的，如果先执行了dec_ref_cnt，obj就会被回收掉，再执行inc_ref_cnt时就会增加一个已被回收对象的引用计数，而且obj也不能被回收。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1975f257a9e151820527ed47e8054833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04174db1e40fae3709f7ee00fd9353e4/" rel="bookmark">
			echarts中grid的使用以及柱状图中数据太多利用DataZoom实现自动横线滑动展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、grid，调整canvas内容 用于决定直角坐标系内绘图网格的位置,ECharts 3 及其以上允许存在多个grid
以下用几张图说明其效果：
问题：在使用echarts时总是会遇到canvas内容不占满空间，导致许多留白。不知道grid配置之前采用的方法就是调大外盒子，以至于会超出范围（虽然也能达到想要的效果，但显然是不合理的）
使用grid之后： 实现代码：可手动给left、right、top、bottomm值，当然也能使用百分比，此处不多介绍。
option.grid = { left: 15, right: 15, top: 15, bottom: 10, containLabel: true, }; myChart.setOption(option); grid配置项：图标离容器的距离
show:是否显示直角坐标系网格-----------值:true?false
left:图表离容器左侧的距离-----------------值:number?百分比
top:图表离容器顶部的距离-----------------值:number?百分比
right:图表离容器右侧的距离---------------值:number?百分比
bottom:图表离容器底部的距离------------值:number?百分比
backgroundColor:网格背景色-------------值:rgba或#000000
borderColor:网格的边框颜色--------------值:rgba或#000000
borderWidth:网格的边框线宽-------------值:number
二、DataZoom，实现柱状图数据过多的自动滑动 效果：ps：emmm因为csdn不能上传视频就下了个流氓app转换成了gif，忽略水印哈。。。
实现代码：
let option = { dataZoom: [ //滑动条 { show: false, //是否显示滑动条 type: "slider", // 这个 dataZoom 组件是 slider 型 dataZoom 组件 startValue: 0, // 从头开始。 endValue: 5, // 一次性展示6个。 }, ], } // 基于准备好的dom，初始化echarts实例 if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04174db1e40fae3709f7ee00fd9353e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b80c8fc1a7884db8394b3d995b7ada5/" rel="bookmark">
			服务器被攻击的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器被攻击怎么办？处理步骤
1.切断网络
所有的攻击都来自于网络，因此，在得知系统正遭受黑客的攻击后，首先要做的就是断开服务器的网络连接，这样除了能切断攻击源之外，也能保护服务器所在网络的其他主机。
2.查找攻击源
可以通过分析系统日志或登录日志文件，查看可疑信息，同时也要查看系统都打开了哪些端口，运行哪些进程，并通过这些进程分析哪些是可疑的程序。这个过程要根据经验和综合判断能力进行追查和分析。下面的章节会详细介绍这个过程的处理思路。
3.分析入侵原因和途径
既然系统遭到入侵，那么原因是多方面的，可能是系统漏洞，也可能是程序漏洞，一定要查清楚是哪个原因导致的，并且还要查清楚遭到攻击的途径，找到攻击源，因为只有知道了遭受攻击的原因和途径，才能删除攻击源同时进行漏洞的修复。
4.备份用户数据
在服务器遭受攻击后，需要立刻备份服务器上的用户数据，同时也要查看这些数据中是否隐藏着攻击源。如果攻击源在用户数据中，一定要彻底删除，然后将用户数据备份到一个安全的地方。
5.重新安装系统
永远不要认为自己能彻底清除攻击源，因为没有人能比黑客更了解攻击程序，在服务器遭到攻击后，最安全也最简单的方法就是重新安装系统，因为大部分攻击程序都会依附在系统文件或者内核中，所以重新安装系统才能彻底清除攻击源。
6.修复程序或系统漏洞
在发现系统漏洞或者应用程序漏洞后，首先要做的就是修复系统漏洞或者更改程序bug，因为只有将程序的漏洞修复完毕才能正式在服务器上运行。
7.恢复数据和连接网络
将备份的数据重新复制到新安装的服务器上，然后开启服务，最后将服务器开启网络连接，对外提供服务。
8.做好服务器系统的日常监控与运维
服务器的运维管理是即时发现服务器攻击的重要手段之一，通过对服务器的实时监控，可以即时发现服务器异常，比如：登录异常、登录失败IP记录、登录失败账号记录、网站访问日志实时分析（可以发现攻击来源IP地址、扫描攻击等）、监控网页变化（可以快速发现网页被篡改）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad24714b71b1d1ac689dd58eba69c8d/" rel="bookmark">
			pg常用命令（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库版本 ：9.6.6
注意 ：PostgreSQL中的不同类型的权限有SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,CREATE,CONNECT,TEMPORARY,EXECUTE 和 USAGE。
1. 登录PG数据库 以管理员身份 postgres 登陆，然后通过
#psql -U postgres #sudo -i -u postgres ​ $ psql xc_hzh_linan #登录xc_hzh_linan数据库 $ psql -U postgres test #以postgres用户身份，登录test数据库 psql -h localhost -p 5432 -U postgress testdb 界面效果为:
postgres@ubuntu:~$ psql psql (9.5.19) Type "help" for help. ​ postgres=# 简单说一下pgsql 的相关命令
使用反斜线作为命令前缀.
退出 \q 列出所有的数据库 \l 列出所有的数据库的大小 \l+ 更改当前连接的数据库 \c 列出当前数据库的连接信息 \connect 列出当前数据库和连接的详细信息 \conninfo 查看当前数据库里面的表和拥有者和表大小 \dt + 展示所有用户 \dg ​ 查看所有表名的列表 \d 获取表结构 \d a 展示所有用户 \du 查看t_sms表的结构 \d t_sms 展示数据库里面的所有的表 \dt 列出所有的数据库的详细信息（包括数据库大小和字符格式） \l+ 显示用户访问权限。 \z或\dp 显示所有可设置的访问权限 \h GRAN 显示用户的对所有数据库表的详细访问权限 \dp或者\z 确认当前连接的用户为超级用户postgres，且该用户后创建角色和数据库的权限等 #select current_user; 在超级用户连接postgres后，设置不允许普通用户a连接数据库 #alter role a nologin; ​ 使用普通用户a连接数据库正常 #\c highgo a ​ 查看当前连接的用户名： foo=#select * from current_user; 或 foo=#select user; ​ 查看所有用户名： foo=#\du ​ 数据库表的备份与恢复： pg_dump -h 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad24714b71b1d1ac689dd58eba69c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395860db7198ee8b69e6edec10016930/" rel="bookmark">
			function $(id) {}表示什么函数,关于document.getElementBuId的简写 $(id)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到的问题 ** ## //遇到了 这样写的一个函数 ** function $(id){ return document.getElementById(id) } $(id).onclick=function(){ ...	...	... } 因为每次都写document.getElementById比较麻烦 通过这个函数 对它进行简写 使用的时候 直接 $(id)就可以直接用了
可以举一反三
function c$(o){ return document.createElement(o); } 有问题请指正,虚心接受 ,谢谢 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727a312c4a5bf5f16c6e488dad4a1b47/" rel="bookmark">
			2022“杭电杯”中国大学生算法设计超级联赛（9）1008 Shortest Path in GCD Graph（个人题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU-7240: Shortest Path in GCD Graph
解题思路：考虑到每条边的权值为GCD(i,j)，那么对于任何的i，j点来说。
1、若GCD(i,j)！=1时，i，j点必定能够分别和1节点相连形成一条边权为1的边（合起来长度便为2），因此，最小的连接长度就是2。我们只需要计算出1-n范围内与i，j互质的点k的数量便是答案。为了求出与i，j互质的数的数量，我们可以分别处理出i和j的质因数，运用set去重，再将剩余的质因数进行容斥操作（此处暂不介绍容斥，请自行观看），
注意，在计算过程中，若GCD（i，j）=2，也需要在最终答案中+1计算进去。
2、若GCD（i，j）==1时，那么i-j的这条边路径长度为1便是最小的，并且不会有其他相同长度的路径。直接输出1 1即可。
注：该题卡常，必须用素数筛优化分解质因数并且不能使用二进制的容斥，只能用dfs版的方式求容斥（直接裂开）
#include &lt;bits/stdc++.h&gt; #define int long long using namespace std; const int maxn = 1e7 + 7; const int mod = 998244353; const int inf = 1e18 + 9; int t, n, m, x,k,q,a,b,cnt; int read() { int x = 0, f = 1; char c = getchar(); while (c &lt; '0' || c&gt;'9') { if (c == '-') f = -1; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f; } int GCD(int a, int b) { if (b == 0)return a; return GCD(b, a % b); } //素数筛优化分解质因数 int prime[maxn];//记录所有素数的数组 prime[0]存放范围内素数数量 bool vis[maxn];//记录所有数，并将其标记合数为1,素数为0 void Prime(int n) { memset(vis, 0, sizeof(vis));//初始化全为素数 memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= n; i++) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727a312c4a5bf5f16c6e488dad4a1b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09cda9613684dad67e60fbc05af7f195/" rel="bookmark">
			广播，组播，单播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.广播 1.1概念 主页socket里面简绍的数据包发送方式只有一个接受方，称为单播
如果同时发给局域网中的所有主机，称为广播
如果发给局域网中的部分主机，称为组播
注意：同一个套接字只能选择一种发送方式。
只有用户数据报(使用UDP协议)套接字才能广播
1.2广播地址 以192.168.1.0 (255.255.255.0) 网段为例，最大的主机地址192.168.1.255代表该网段的广播地址发到该地址的数据包被所有的主机接收，255.255.255.255在所有网段中都代表广播地址。
广播能发送给所有主机,因为广播的mac地址比较特殊，为全ff， ip地址也比较特殊，使用的是广播的ip地址，将这样的数据包先发送给交换机，然后由交换机发送给所有主机。局域网中每台主机都能收到这个数据包，以UDP为例，网卡收到这个数据包，链路层先校验，发现目的mac地址是广播地址，则可以通过，交给网络层，发现ip地址是广播的ip地址，则也允许通过，到达传输层，只要目的端口号符合，则就能叫到应用层处理。
1.3广播的流程 发送者：
创建套接字 socket( )
设置为允许发送广播权限 setsockopt( )
填充广播信息结构体 sockaddr_in
发送数据 sendto( )
接收者：
创建套接字 socket( )
填充广播信息结构体 sockaddr_in
将套接字与广播信息结构体绑定 bind( )
接收数据 recvfrom( )
1.4代码实现广播 代码说明：这个代码是实现一收一发，服务器收，客户端发，代码相比之前主页socket来说差不多就是改变了方式，设置了一个广播，如需要了解，请参考主页socket的文章，谢谢观看。
设置广播的方式:
int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof(on)); 服务器代码 #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netinet/ip.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;arpa/inet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09cda9613684dad67e60fbc05af7f195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb995d655fe607bea73132df8c4d23ab/" rel="bookmark">
			合规检测—安卓移除第三方包中申请的权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在引用第三方库的时候，第三方内部可能申请了一些非必要权限，合规检测时候会排查出来，第三方库有的我们不能修改，所以想要移除这个非必要权限需要以下方法。
在manifest文件中添加如下代码，移除非必要的权限，tools:node=“remove”
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.ly.project"&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" tools:node="remove"/&gt; ... &lt;/manifest&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f5fe49037fcc7d81455e8837f37d00/" rel="bookmark">
			12个常见idea快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sout : 快速生成 System.out.println();
psvm : 快速生成 main 方法;
Ctrl+Alt+V : 补全等号左边的变量类型和变量名；
Ctrl+Shift+Enter : 补全当前行的结束分号，或者在方法名、if后使用可补全小括号和花括号；
Shift+Enter : 在当前行的下一行创建新行，相当于光标跳转到行尾然后回车；
Ctrl+Alt+Enter :在当前行的上一行创建新行；
Alt+Insert ： 可快速生成类里面的getter、setter、toString、构造方法、hashcode等方法；
Ctrl+Alt+O : 优化去除没有用到的import；
Ctrl+Alt+L : 格式化代码，清除多余空格以及缩进，让代码对其更简洁养眼；
Ctrl+Tab ： 在最近打开的两个文件中切换；
Ctrl+E : 打开最近操作的文件列表；
F2 : 定位到当前类的语法报错处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0f7d9715b1c1a9186c953f2a036029/" rel="bookmark">
			运行React-Native项目是报Unknown错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个主要是每次切换项目时候启动react-native服务器的缓存导致的，依次执行一下命令清除缓存。
npm cache clean --force npm i npm start -- -- reset-cache 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224daa5b043cb0af47a0cdfdcabdfbfa/" rel="bookmark">
			Android Studio运行打包RN项目报Couldn‘t follow symbolic link错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Android Studio编译运行打包react native项目时，报/node_modules/xxx’. Couldn’t follow symbolic link.错误。
解决方案：
遇到 Couldn’t follow symbolic link. 找到报错日志中提示路径，删除发生错误的文件夹即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015b2f7d9d728fb0f7aa7d00dab0b624/" rel="bookmark">
			ubuntu20.04编译librealsense
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接安装
直接接用sudo apt的方便，安装成功后发现没有intel的相机，ls usb查看接入虚拟机设备，如果没有的话，将设置里面的usb改为兼容3.1
参考 Ubuntu20.04LTS下安装Intel Realsense D435i驱动与ROS包_wanghq2013的博客-CSDN博客_d435i ros
2.用源码安装
源代码安装：
git clone librealsense的源代码
GitHub - IntelRealSense/librealsense: Intel® RealSense™ SDK
太卡的话可以用gitee 登录 - Gitee.com
进入该目录
安装依赖
sudo apt-get install libudev-dev pkg-config libgtk-3-dev
sudo apt-get install libusb-1.0-0-dev pkg-config
sudo apt-get install libglfw3-dev
sudo apt-get install libssl-dev
sudo apt-get install mesa-common-dev
sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev
sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/
sudo udevadm control --reload-rules &amp;&amp; udevadm trigger mkdir build
cd build
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015b2f7d9d728fb0f7aa7d00dab0b624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f526413f0b75f764f51f6b03c5977904/" rel="bookmark">
			论文复现： Active learning for regression using greeding sampling. Information Sciences
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference: D. Wu, C. Lin, J. Huang. Active learning for regression using greeding sampling. Information Sciences, 2019, 474: 90-105. ''' author:Deniu He date:2020-12-11 organization: CQUPT Reference: D. Wu, C. Lin, J. Huang. Active learning for regression using greeding sampling. Information Sciences, 2019, 474: 90-105. ''' import numpy as np import pandas as pd from copy import deepcopy from sklearn.linear_model import LinearRegression,Ridge from sklearn import datasets from sklearn import linear_model from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f526413f0b75f764f51f6b03c5977904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8160e311f289b70bbeecbdd00a74b9/" rel="bookmark">
			对比多个序列的相同元素占比并绘制热力图-Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns ''' 对比两个数组前k个元素的相同元素占比 ''' def getArraySame(array1, array2, k): length = len(array1) if k &gt; length: k = length # 统计两个数组相同元素个数 count = len(set(array1[0:k]) &amp; set(array2[0:k])) # 除以总元素数，转为占比 return count / k if __name__ == '__main__': ''' 数据准备 ''' methods = pd.read_csv('data.csv') # 多种方法的排序结果 # 文件中第一列为排名，因此方法名从索引1至n methods_name = np.array(methods.columns)[1: len(methods.columns)] m = len(methods_name) # 共多少个方法 ''' 计算 ''' a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8160e311f289b70bbeecbdd00a74b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f71f11739bc7b67c7a1e58ad79ade3/" rel="bookmark">
			混淆矩阵代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		混淆矩阵对数据可视化很有用，我在做轴承故障诊断时，也用到了这个混淆矩阵，我在下面贴出来两种代码，供大家使用借鉴，我也是从网上找的改的
# 开发时间：2022/8/4 19:35 # 绘制混淆矩阵 import torch from matplotlib import pyplot as plt import numpy as np import itertools def plot_confusion_matrix(cm, classes, normalize=False, title='Confusion matrix', cmap=plt.cm.Blues): """ This function prints and plots the confusion matrix. Normalization can be applied by setting `normalize=True`. Input - cm : 计算出的混淆矩阵的值 - classes : 混淆矩阵中每一行每一列对应的列 - normalize : True:显示百分比, False:显示个数 """ if normalize: cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis] print("Normalized confusion matrix") else: print('Confusion matrix, without normalization') print(cm) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f71f11739bc7b67c7a1e58ad79ade3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5c224fd840a6b79d1e749cc9a3800b/" rel="bookmark">
			CentOS下前后端分离项目（Vue&#43;SpringBoot）的详细部署过程（初学者，简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS下前后端分离项目的部署 一、部署工具准备二、CentOS下JDK的安装三、CentOS下安装Tomcat四、CentOS下MySql的安装五、CentOS下Redis的安装六、前端工程的部署及启动七、后端工程的部署及启动 项目概况：
前端技术：Vue + ElementUI
后端技术：SpringBoot + Mysql + Redis
一、部署工具准备 ①、 提前准备一台装有CentOS系统的服务器（装在VMWare和云服务器上的CentOS皆可）。
②、下载操作CentOS的工具：XShell和Xftp，详细下载和安装操作可参考如下链接。
XShell的安装及连接：http://t.csdn.cn/x1h4C
Xftp的安装：http://t.csdn.cn/eZP6f
二、CentOS下JDK的安装 先卸载CentOS自带的OpenJDK，通过命令查看。 rpm -qa | grep jdk 如果存在，通过命令删除对应版本的JDK，示例如下。 rpm -e --nodeps java-1.8.0-openjdk-1.8.0.65-3.b17.el7.x86_64 rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.65- 3.b17.el7.x86_64 rpm -e --nodeps java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64 rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.91- 2.6.2.3.el7.x86_64 查看是否删除成功。在 /usr/local 目录下新建 java 文件夹，并进入。 cd /usr/local mkdir java cd java 打开Xftp上传JDK压缩包至 /usr/local/java文件夹。 JDK8压缩包
百度云：链接：https://pan.baidu.com/s/1waP5vfRwS36VTodK6I0EVw
提取码：5rda
解压JDK安装包，并删除。 tar -zxvf jdk-8u152-linux-x64.tar.gz //解压压缩包 rm -rvf jdk-8u152-linux-x64.tar.gz //删除压缩包 配置环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c5c224fd840a6b79d1e749cc9a3800b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/221/">«</a>
	<span class="pagination__item pagination__item--current">222/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/223/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>