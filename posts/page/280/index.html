<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ba8028a7e7274445b87a452304be75/" rel="bookmark">
			HTML5新增的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单增强：日期、时间、搜索（修改type的类型实现）；表单验证；placeholder Number类型 &lt;input type="number" name="demoNumber" min="1" max="100" step="2"/&gt; 注:此标签其实就是普通的input标签,只不过是type类型指向了number,标识当前标签接受数字类型输入.另外添加了四个属性.
name:属性大家很熟悉了用来标识表单提交时的key值
min:是表单标签新增加的属性标识当前输入框输入的最小值
max:那就是最大值了
step：是步长的意思，也就是在点击增大或者减小的时候的增加减少的步长
小结：min，max，step是表单标签中添加的新的属性。另外就是type又增加了一个新的number类型，接受数字输入。而之前我们要做到这样的效果只能通过js在失去焦点时候判断，控制起来不那么方便，现在一切都那么简单简洁。 Email类型 &lt;input type="email" name="email" placeholder="请输入注册邮箱" /&gt; 注：在上面HTML代码中，相对于之前的标签，不同点：type="email"表示当前input标签接受一个邮箱的输入。另外就是：placeholder="请输入注册邮箱" 这个属性的功能，相信你看到此时的效果的时候你会感到非常想兴奋，而在之前实现此提示信息，需要监听一下文本框的blur事件，然后判断是否为空，为空再去给文本框赋值一个灰色的字体提示信息，而现在只需要一个简单属性指定就可以了，浏览器都帮我们实现了。
小结：当表单在提交前，此文本框会自动校验是否符合邮箱的正则表达式，另外placeholder属性带来的提示信息功能太强大了。
Url &lt;input type="url" placeholder="请输入网址" name="url" /&gt; Tel &lt;input type="tel" placeholder="输入电话" name="phone"/&gt; range
&lt;input type="range" min="0" max="50" step="5" name="rangedemo" value="0" /&gt; 新的日期、时间、月份、星期input标签 &lt;input type="date" name="datedemo" /&gt; 还有其他的type：month(月) 、time、week、datetime-local、datetime。
input标签自动完成功能 自动完成或者输入提示功能。那这将不再那么复杂，简单几个标签就自动实现此功能，请看如下demo： &lt;input type="text" autocomplete="on" name="demoAutoComplete" list="autoNames" /&gt; &lt;datalist id="autoNames"&gt; &lt;option value="飞龙天惊" &gt;&lt;/option&gt; &lt;option value="厚德IT" &gt;&lt;/option&gt; &lt;option value="Flydragon" &gt;&lt;/option&gt; &lt;/datalist&gt; 语义增强：header/footer; section/article; nav导航；aside 不重要的内容；em(emphasize)/strong增强; i(icon)制作图标 &lt;html&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ba8028a7e7274445b87a452304be75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a25f9455be7519a5f78dd2726f59d1/" rel="bookmark">
			CAD2020学习教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 绘图时用空格结尾
OP ——打开设置选项
快速选定——鼠标框选（左到右要全部框选，右到左部分框选）
常用功能键 快捷键功能快捷键功能F1获取帮助F7栅格显示模式控制F2实现作图窗和文本窗口的切换F8正交模式控制（画垂直线）F3控制是否实现对象自动捕捉（画图时捕捉）F9栅格捕捉模式控制F4数字化仪控制F10极轴模式控制F5等轴测平面切换F11对象追踪模式控制F6控制状态行上坐标的显示方式 绘图命令 快捷键功能快捷键功能L直线T多行文本PL多段线DT单行文本ML多线B块定义XL构造线I插入块SPL样条曲线W写入块POL多边形PO点REC矩形DIV定数等分C圆ME定距等分A圆弧H填充EL椭圆BO边界创建DO圆环REG面域 修改命令 快捷键功能快捷键功能E删除S拉伸CO复制（选定目标后空格再选基点）X分解M移动（选定目标后空格再选基点）
或先选目标再输命令选基点BR打断RO旋转F倒圆角AR陈列CHA倒直角MI镜像PE多线段编辑O偏移J合并SC比例缩放ED修改文本AL对齐MA格式刷TR修剪（先选基线再选需修剪线段/ 直接空格不选线段可多段修剪）LEN直线拉长EX延伸（直接空格不选线段可多段延伸） 视图缩放 快捷键功能P平移（小抓手）Z缩放（Z+空格+E 范围缩放）3DO三维旋转鼠标中键视图缩放鼠标中键平移 尺寸标注 快捷键功能D标注样式ED编辑文字DLI直线标注DAL对齐标注DRA半径标注DDI直径标注DAN角度标注DAR弧长标注LE引线标注TOL公差标注 查询工具 快捷键功能AA面积DI距离测量LI图形数据ID坐标查询FI过滤选择 特性编辑（设置） 快捷键功能DDPTYPE点样式ST文字样式LA图层操作LT线型LW线宽UN图形单位OP选项设置DS草图测试REN重命名RE重新生成 CTRL+快捷键 快捷键功能快捷键功能CTRL+1修改特性CTRL+X剪切CTRL+2设计中心CTRL+V粘贴CTRL+A全选CTRL+SHIFT+V粘贴为块CTRL+O打开文件CTRL+F对象捕捉CTRL+N新建文件CTRL+G栅格CTRL+P打印文件CTRL+L正交CTRL+S保存CTRL+W选择循环CTRL+Z放弃（撤销）CTRL+N极轴CTRL+C复制CTRL+SHIFT+I推断约束 其他快捷键 快捷键功能PU清理内存TB创建表格G编组AP加载LSPATT定义属性ATE编辑属性MV编辑视口R重画CAL计算 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9af061ad941ea25c5549f0e7e23ab64/" rel="bookmark">
			文件传输协议FTP解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FTP状态码解析 FTP服务器: 220 (vsFTPd 2.0.1) |说明：链接成功 FTP客户端: USER useway |说明：输入用户名 FTP服务器: 331 Please specify the password. |说明：请输入密码 FTP客户端: PASS !@#$%abce |说明：输入密码 FTP服务器: 230 Login successful. |说明：登录成功 FTP客户端: CWD /home/useway |说明：切换目录 FTP服务器: 250 Directory successfully changed. |说明：目录切换成功 FTP客户端: EPSV ALL |说明：为EPSV被动链接方式 FTP服务器: 200 EPSV ALL ok. |说明：OK FTP客户端: EPSV |说明：链接 FTP服务器: 229 Entering Extended Passive Mode (|||62501|) |说明：被动链接端口为62501 FTP客户端: LIST |说明：执行LIST显示文件列表 FTP服务器: 150 Here comes the directory listing. |说明：列表从62501端口被发送 FTP服务器: 226 Directory send OK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9af061ad941ea25c5549f0e7e23ab64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c5e564ab2705cf26e5b9b6e76afcbc/" rel="bookmark">
			Linux内核4.14版本：ARM64的内核启动过程（三）——prepare_namespace挂载根文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
bootags参数又是怎么保存到数组的呢?
__setup
do_early_param
obsolete_checksetup
内核版本：4.14
简单分析：怎么挂接的文件系统”root=/dev/mtdblock3”
init\do_mounts.c的prepare_namespace()。
/* * Prepare the namespace - decide what/where to mount, load ramdisks, etc. */ void __init prepare_namespace(void) { int is_floppy; if (root_delay) { printk(KERN_INFO "Waiting %d sec before mounting root device...\n", root_delay); ssleep(root_delay); } /* * wait for the known devices to complete their probing * * Note: this is a potential source of long boot delays. * For example, it is not atypical to wait 5 seconds here * for the touchpad of a laptop to initialize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c5e564ab2705cf26e5b9b6e76afcbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cef2ad9de1c2e65f2efba3f0f5ec57/" rel="bookmark">
			Linux内核4.14版本：ARM64的内核启动过程（一）——start_kernel之前
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、vmlinux.lds.S
二、head.S（进入kernel之前）
2.1 kernel之前bootloder的工作
2.1 bootloader和kernel的交互的时候需求
2.3 内核执行的第一行代码（_stext）
2.3.1 preserve_boot_args（）
2.3.2 el2_setup
2.3.3 set_cpu_boot_mode_flag
2.3.4 __create_page_tables
2.3.5 __cpu_setup
2.3.6 __primary_switch
三、main.c（start_kernel）
四、参考文章
Linux版本4.14 ：。
kernel的整个启动过程涉及的内容很多，不可能每一个细节都描述清楚，因此我打算针对部分和ARM64相关的启动步骤进行学习、整理，并方便后续查阅。本文实际上描述在系统启动最开始的时候，bootloader和kernel的交互以及kernel如何保存bootloader传递的参数并进行校验，此外，还有一些最基础的硬件初始化的内容。
一、vmlinux.lds.S 文件arch\arm64\kernel\vmlinux.lds.S文件是kernel链接文件。
/* SPDX-License-Identifier: GPL-2.0 */ /* * ld script to make ARM Linux kernel * taken from the i386 version by Russell King * Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt; */ .................... SECTIONS { /* * XXX: The linker does not define how output sections are * assigned to input sections when there are multiple statements * matching the same input section name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6cef2ad9de1c2e65f2efba3f0f5ec57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249ac2646ecdc082ad9f73c6547cd46e/" rel="bookmark">
			selenium.webdriver.remote.webelement.WebElement解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Python语言，selenium用法写自动化脚本时，打印文本出现了一下信息：
&lt;selenium.webdriver.remote.webelement.WebElement (session=“8438b95244fba6444aafaf5a5cbe73f9”, element=“5bf8fa52-6761-4522-b894-314823081c32”)&gt;
请求代码如下
import time from selenium import webdriver driver = webdriver.Chrome() driver.get('http://tendcode.com/accounts/login/?next=/') driver.maximize_window()	# 网页最大化 driver.find_element_by_id('id_login').send_keys('asdfghjkl')	# 输入用户名 driver.find_element_by_id('id_password').send_keys('123.123.')	# 输入密码 driver.find_element_by_class_name('pull-right').click()	# 点击登录 ds = [] for i in range(1,5):	# 循环 div_a= driver.find_element_by_xpath('/html/body/main/div/div/div[1]/div[3]/div[%s]/div[2]/h2'%i)	# 循环查找这五个元素 ss = div_a.find_element_by_tag_name('a')	# 获取div_a下的a标签 ds.append(ss.text)	# 添加到列表 print(ss.text)	# 输出文本 print(ss)	# 输出元素信息 print(ds) time.sleep(5) driver.quit() 输出结果如下：
Mac 同时使用无线 Wi-Fi 和有线上网，解决内网外网一起访问的问题 &lt;selenium.webdriver.remote.webelement.WebElement (session="5bcfee8a76156427f327d53f13ebaa9a", element="7038e9b5-3ae7-4df2-afa2-5676bc62591b")&gt; 烂笔头周刊（第2期）：职业发展的最好方法是换公司？！ &lt;selenium.webdriver.remote.webelement.WebElement (session="5bcfee8a76156427f327d53f13ebaa9a", element="99e510fb-2932-4b2f-85c5-a95bd5c928c8")&gt; 烂笔头周刊（第1期）：好记性不如烂笔头 &lt;selenium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249ac2646ecdc082ad9f73c6547cd46e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa24eab930db5e35f25903475232929/" rel="bookmark">
			eMMC的读写速度与容量有关系吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近宏旺半导体ICMAX在网上看到有网友说eMMC的读写速度与容量无关，与eMMC的接口形式有关、与版本高低有关。还贴出了例子，比如eMMC5.1与早期有4.3、4.41、4.5等，他们的区别就是接口的读写速度，低版本的eMMC是不支持红框中的HS200和HS400模式的，读写速度自然不如的5.1的快。详情请看下图↓。
鉴于宏旺半导体在存储行业有十五年的时间，特别是在嵌入式存储这块有丰富专业的行业经验，在此对网络上的一些言论，从专业角度来看有不恰当之处作一下探讨，仅供参考。关于上图eMMC协议给出的是接口速度，并不是读写速度，接口速度与读写速度是两码事，eMMC读写速度和容量是相关的，去相关官网下份datasheet看看就知道了，eMMC内部也是Flash颗粒封起来的，容量大颗粒多，颗粒之间可以切换工作，就能发挥最大的接口速度，相应读写速度就快。
网络上的一些观点，单纯地把接口速度等价于读写速度，混淆了两者的概念，eMMC芯片内部封装的存储单元是NAND Flash颗粒，eMMC控制芯片，通过自己的算法，把数据内容写入到内部的NAND Flash中，这些和你对eMMC芯片操作没有任何关系，你并不能直接对NAND颗粒进行操作。eMMC封装好以后，你只能按照eMMC的接口标准，对eMMC控制芯片进行操作。
如果真要详细解释起来很费劲，宏旺半导体ICMAX的总结就是：容量和读写速度没有直接必然关系，但是是有影响的，因为里面结构不一样。宏旺半导体专注嵌入式存储十五年，ICMAX eMMC5.1广泛应用于手机、机顶盒、平板、AR/VR、汽车导航、游戏机、数字电视等领域，eMMC5.1最大连续读写速度,读的速度可达136MB/s 、写的速度达80MB/s，无故障时间达2，000，000小时，使用寿命长，质量有保证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38f0c98da4d614c207a479b762e9b66/" rel="bookmark">
			6. LaTeX 参考文献的排版与引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX 参考文献的排版与引用 ​ 在论文写作的过程中，为了体现论文的科学性、严谨性和规范性，我们常常需要引用大量的参考文献来引证自己的观点。参考文献(Reference)往往都是放在论文的最后，记录了所引用论文的标题、作者、期刊或会议、出版时间等信息，文中还需要明确有顺序的进行引用标注。
​ 本篇将介绍 LaTeX 常用的参考文献排版与引用方式，所用到的宏包都要写在 \documentclass 命令之后和 \begin{docuemnt}之前，在本文中，我们会用的宏包文件有：
\usepackage{cite} \usepackage[number, sort&amp;compress]{natbib} 1. 直接插入参考文献 先在文章的最后写好需要插入的参考文献，逐一列举出来。例如：
\begin{thebibliography}{100} \bibitem{ref1}Lv Y, Duan Y, Kang W, et al. Traffic flow prediction with big data: a deep learning approach[J]. IEEE Transactions on Intelligent Transportation Systems, 2014, 16(2): 865-873. \bibitem{ref2}Wu Y, Tan H, Qin L, et al. A hybrid deep learning based traffic flow prediction method and its understanding[J]. Transportation Research Part C: Emerging Technologies, 2018, 90: 166-180.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38f0c98da4d614c207a479b762e9b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b25ff3537e614b054972564ebb8908/" rel="bookmark">
			TCP粘包问题分析和解决（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源于：https://blog.csdn.net/wuxing26jiayou/article/details/79730987
在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。
对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题。
====================================================================
在介绍TCP之前先普及下两个相关的概念，长连接和短连接。
1.长连接 Client方与Server方先建立通讯连接，连接建立后 不断开， 然后再进行报文发送和接收。
2.短连接 Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server.
TCP协议简介 TCP是一个面向连接的传输层协议，虽然TCP不属于ISO制定的协议集，但由于其在商业界和工业界的成功应用，它已成为事实上的网络标准，广泛应用于各种网络主机间的通信。
作为一个面向连接的传输层协议，TCP的目标是为用户提供可靠的端到端连接，保证信息有序无误的传输。它除了提供基本的数据传输功能外，还为保证可靠性采用了数据编号、校验和计算、数据确认等一系列措施。它对传送的每个数据字节都进行编号，并请求接收方回传确认信息（ACK）。发送方如果在规定的时间内没有收到数据确认，就重传该数据。
（1） 数据编号使接收方能够处理数据的失序和重复问题。
（2） 数据误码问题通过在每个传输的数据段中增加校验和予以解决，接收方在接收到数据后检查校验和，若校验和有误，则丢弃该有误码的数据段，并要求发送方重传。
（3） 流量控制也是保证可靠性的一个重要措施，若无流控，可能会因接收缓冲区溢出而丢失大量数据，导致许多重传，造成网络拥塞恶性循环。
（4） TCP采用可变窗口进行流量控制，由接收方控制发送方发送的数据量。
TCP为用户提供了高可靠性的网络传输服务，但可靠性保障措施也影响了传输效率。因此，在实际工程应用中，只有关键数据的传输才采用TCP，而普通数据的传输一般采用高效率的UDP。
保护消息边界和流 那么什么是保护消息边界和流呢?
保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。
例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用TCP协议，我们只要把接收的缓冲区大小设置在14k以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。
注意：
这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，他不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据的时候，他们时常会认识tcp会丢包。其实不然，因为当他们使用的缓冲区足够大时，他们有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其他数据包却被忽略了。所以大家如果要作这类的网络编程的时候,必须要注意这一点。
结论：
（1）TCP为了保证可靠传输，尽量减少额外开销（每次发包都要验证），因此采用了流式传输，面向流的传输，相对于面向消息的传输，可以减少发送包的数量，从而减少了额外开销。但是，对于数据传输频繁的程序来讲，使用TCP可能会容易粘包。当然，对接收端的程序来讲，如果机器负荷很重，也会在接收缓冲里粘包。这样，就需要接收端额外拆包，增加了工作量。因此，这个特别适合的是数据要求可靠传输，但是不需要太频繁传输的场合（两次操作间隔100ms，具体是由TCP等待发送间隔决定的，取决于内核中的socket的写法）
（2）UDP，由于面向的是消息传输，它把所有接收到的消息都挂接到缓冲区的接受队列中，因此，它对于数据的提取分离就更加方便，但是，它没有粘包机制，因此，当发送数据量较小的时候，就会发生数据包有效载荷较小的情况，也会增加多次发送的系统发送开销（系统调用，写硬件等）和接收开销。因此，应该最好设置一个比较合适的数据包的包长，来进行UDP数据的发送。（UDP最大载荷为1472，因此最好能每次传输接近这个数的数据量，这特别适合于视频，音频等大块数据的发送，同时，通过减少握手来保证流媒体的实时性）
====================================================================
粘包问题分析与对策 TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。
什么时候需要考虑粘包问题 1如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构,类似于http协议）。
关闭连接主要是要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如"hello give me sth abour yourself"，然后B收到报文后，就将缓冲区数据接收，然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。
2如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包3如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：
1)“hellogive me sth abour yourself”
2)“Don’tgive me sth abour yourself”
那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是"hellogive me sth abour yourselfDon’t give me sth abour yourself"这样接收方就傻了，到底是要干嘛？不知道，因为协议没有规定这么诡异的字符串，所以要处理把它分包，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。
粘包出现原因 简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Windows网络编程)
1发送端需要等缓冲区满才发送出去，造成粘包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b25ff3537e614b054972564ebb8908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783e3f6a93c356ca2e599c0d836c7c81/" rel="bookmark">
			5. LaTeX 算法伪代码基本格式排版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX 算法伪代码基本格式排版 1、算法排版初体验 LaTeX 的所有宏包文件都要写在 \documentclass 命令之后和\begin{document} 之前。在本文中，我们主要会用到如下的两个宏包：
\usepackage{algorithmic} \usepackage{algorithm} 在论文写作的过程中，对于计算机专业的学生，在论文中插入伪代码描述所用的算法还是比较常见的。这里我们先体验一下伪代码算法插入模板的效果，然后在后面详细讲解模板的中的每个细节。
我们比较通用的模板如下：
\begin{algorithm}[!h] \caption{algorithm of SUM} \label{alg:AOA} \renewcommand{\algorithmicrequire}{\textbf{Input:}} \renewcommand{\algorithmicensure}{\textbf{Output:}} \begin{algorithmic}[1] \REQUIRE $A$, $B$, $C$ %%input \ENSURE EEEEE %%output \STATE AAAAA \WHILE{$A=B$} \STATE BBBBB \ENDWHILE \FOR{each $i \in [1,10]$} \IF {$C = 0$} \STATE CCCCC \ELSE \STATE DDDDD \ENDIF \ENDFOR \RETURN EEEEE \end{algorithmic} \end{algorithm} 上述模板的展示效果如下：
2、算法排版基本用法 1. 参数与语法说明 1、算法排版框架
\begin{algorithm}[!t] ... \end{algorithm} 整体大框架明确了伪代码或算法结构的开始（\begin）和结束（\end）的位置，而 algorithm 说明插入的内容是算法。[!h] 是算法的摆放格式：在当前位置(hear)，所有的格式和图片、表格相同。
2、标题与标签
\caption{Algor of ABC} \label{alg:AOA} caption 是算法的标题。{ }中就是标题展示的具体内容，标题也会有编号，一般都是自动编号。label 是标签，标签主要是在引用的时候会用到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783e3f6a93c356ca2e599c0d836c7c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa23e0c3df10767776206d69aa7f27e/" rel="bookmark">
			02-箭头函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、箭头函数的基本使用
//箭头函数：定义函数的一种方式 //1.定义函数的方式：funtion const a = function(){ } //2.对象字面量中定义函数 const obj = { b:function(){ }, bb:function(){ } } //3.es6中的箭头函数 // const c = (参数列表)=&gt;{ // } //无参，无返回值 const c = () =&gt; { } 二、箭头函数参数和返回值问题
//1.参数问题 //1.1.放入两个参数 const sum = (num1,num2) =&gt; { return num1+num2 } //1.2.放入一个参数 可以省略小括号，但是尽量不要省略，方便阅读代码 const power = num =&gt; { return num*num } //2.函数代码块数量问题 //2.1.函数代码块中有多行代码时 const test = () =&gt; { //1.打印 console.log('Hello'); //2.打印 console.log('Vue'); } test()//执行 //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa23e0c3df10767776206d69aa7f27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ad0441ba4debdc139e0b38d70edb5f/" rel="bookmark">
			01-vuecli3安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结束webpack学习，开始接触脚手架！！！
node是前提—已安装@12.18.3
Vue.js官方脚手架使用了webpack的模板
一、开始安装cli
npm install -g @vue/cli //全局安装 本机安装了4.5.12的版本
淘宝镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org
cli3：创建项目：vue create 项目名称
1. vue create vuecli3test
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tZ0uKfNY-1637325089728)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\4776c4a54e2c49a8a882d18b41f986e7\939acd1f658c46c19a052e1c75cf78b7.jpg)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mxBAqdO3-1637325089733)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\f3709181acb843a5b91fcd546a5a1880\e40af9df64ed40b69b572fcfe8865e36.jpg)]
2.跑cli3项目：npm run serve
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YRHslbfg-1637325089735)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\02a65b2a8c4c4393b385715198f58c51\5dfa2127113b45f28b3d061ec26ca52b.jpg)]
3.本地服务器搭建好，点击：http://localhost:8080/
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-B16QFY4f-1637325089737)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\74b5e0ddf0004f6d8fc43c66349dcc9e\fc412f2d82234b0d9c81f2fe01af83e4.jpg)]
4.搭建成功
二、来到vue ui
1.启动本地服务器**：vue ui**
跳出页面：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hqQzZmEy-1637325089738)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\ed959f69010b46fa8e4c03e125721202\5686bb2b449a42a6b0acea2038ce1f8a.jpg)]
但是同时遇到一个****error：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LyjSDsZb-1637325089739)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\7f3da612519b4045bedcffa5232596a7\9218941526d74e689cdde4cccbf65190.jpg)]
解决方法：清理npm缓存（已成功解决报错）：npm cache clean --force
2.点击导入可以看到项目目录，可以自由选择：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dnJF1TvF-1637325089742)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\f3a91ba5d8384df58c3bda99d50afb10\8a9d5021ba4747d5b94af423720990b5.jpg)]
3.选择02-vuecli3test进入后导入文件夹
37325089742)]
3.选择02-vuecli3test进入后导入文件夹
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O8aZF138-1637325089743)(D:\mansoft\有道云笔记\weixinobU7VjpGyuf2I51b3uyOAoln8Lew\17eb7e77925f45d9a20f6ee8bf523545\93ba8056ba644e849a06f9b0b14b3b9b.jpg)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11190a8d04f5477518a3ba7f0589815/" rel="bookmark">
			qnx bsp 编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译环境准备：
1、下载工具链，以及bsp 包
2、编译
source ../qnx710/qnxsdp-env.sh
make
3、make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafe2fa9de9d7e070832518507e22556/" rel="bookmark">
			pytest运行多条用例命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行包下所有用例：pytest/py.test 包名
执行单独一个pytest模块：pytest 文件名.py
执行某个类：pytest 文件名.py::类名
执行某个方法：pytest 文件名.py::类名::方法名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e066d4916c204444ae518c3f19a9d37/" rel="bookmark">
			【2021-11-20】Android Gradle Build Failed: Unsupported class file major version 61 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜测是因为给 Gradle 指定了一个较高版本的 JDK（如，最近刚刚正式发布的 Java 17 LTS），导致无法支持某些项目的构建。
依次选择
File → Settings → Build, Execution, Deployment → Build Tools → Gradle
将 Gradle JDK 改为
Embedded JDK version 11.0.10
然后确定，再重新构建项目。
注意：每个项目可以各自设定自己的 Gradle JDK 版本。除上述方法外，也可以在
File → Project Structures → SDK Location → Gradle Settings
中进行调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d233833fdca60be2e63798ef58c013/" rel="bookmark">
			‘Flutter/Flutter.h‘ file not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		’Flutter/Flutter.h’ file not found 解决方案1. 点击这里前往下载对应版本文件,替换原来的文件ios/Podfile内容，删除ios/Podfile.lock,重新 pod install 即可
解决方案2. 执行代码：flutter run -v 和 flutter doctor -v 检测配置是否成功
可能会出现以下情况：
Mac os 10.15 无法打开“idevice_id”,因为无法验证开发者
Mac os 10.15 无法打开“ideviceinfo”,因为无法验证开发者
解决方法 打开终端（Terminal），输入以下命令后回车，如需要，请输入密码
sudo xattr -r -d com.apple.quarantine 注： 为应用程序路径，直接从文件夹目录拖拽即可自动填写 解决方案3. 找到 iOS/Flutter 文件夹，再找到以前备份的无报错文件替换掉文件夹内容，应该就不会报错了。
再执行下 flutter build ios --release
编译过程中会重新生成新的== iOS/Flutter== 文件夹下内容，覆盖我们替换的文件。
以上解决方案有可能需要结合使用。
原作者：飞羽_ifeiyv
链接：https://www.jianshu.com/p/e2943ee716a9
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b5bff85722a99f2101a01fd380c429/" rel="bookmark">
			NXP（I.MX6uLL）DDR3实验——DDR3初始化、校准、超频测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDR3L 初始化与测试 ddr_stress_tester简介(DDR压力测试工具)DDR3L驱动配置DDR3L校准DDR3L超频测试DDR3L驱动总结 ddr_stress_tester简介(DDR压力测试工具) NXP 提供了一个非常好用的DDR 初始化工具，叫做ddr_stress_tester。此工具已经放到了开发板光盘中，路径为：5 、开发工具-&gt;5 、NXP 官方DDR 初始化与测试工具-&gt;ddr_stress_tester_v2.90_setup.exe.zip，我们简单介绍一下ddr_stress_tester 工具，此工具特点如下：
①、此工具通过USB OTG 接口与开发板相连接，也就是通过USB OTG 口进行DDR 的初始化与测试。②、此工具有一个默认的配置文件，为excel 表，通过此表可以设置板子的DDR 信息，最后生成一个.inc 结尾的DDR 初始化脚本文件。这个.inc 文件就包含了DDR 的初始化信息，一般都是寄存器地址和对应的寄存器值。③、此工具会加载.inc 表里面的DDR 初始化信息，然后通过USB OTG 接口向板子下载DDR 相关的测试代码，包括初始化代码。④、对此工具进行简单的设置，即可开始DDR 测试，一般要先做校准，因为不同的PCB其结构肯定不同，必须要做一次校准，校准完成以后会得到两个寄存器对应的校准值，我们需要用这个新的校准值来重新初始化DDR。⑤、此工具可以测试板子的DDR 超频性能，一般认为DDR 能够以超过标准工作频率10%~20%稳定工作的话就认定此硬件DDR 走线正常。⑥、此工具也可以对DDR 进行12 小时的压力测试。
我们来看一下正点原子开发板光盘里面5、开发工具-&gt;6、NXP 官方DDR 初始化与测试工具目录下的文件，如图23.5.1.1 所示： 我们依次来看一下图23.5.1.1 中的这些文件的作用：
①、ALIENTEK_256MB.inc 和ALIENTEK_512MB.inc，这两个就是通过excel 表配置生成的，针对正点原子开发板的DDR 配置脚本文件。②、ddr_stress_tester_v2.90_setup.exe.zip 就是我们要用的ddr_stress_tester 软件，大家自行安装即可，一定要记得安装路径。③、I.MX6UL_DDR3_Script_Aid_V0.02.xlsx 就是NXP 编写的针对I.MX6UL 的DDR 初始化execl 文件，可以在此文件里面填写DDR 的相关参数，然后就会生成对应的.inc 初始化脚本。④、最后两个PDF 文档就是关于I.MX6 系列的DDR 调试文档，这两个是NXP 编写的。 DDR3L驱动配置 1、安装ddr_stress_tester
首先要安装ddr_stress_testr 软件，安装方法很简单，这里就不做详细的讲解了。但是一定要记得安装路径！因为我们要到安装路径里面找到测试软件。比如我安装到了D:\Program Files (x86)里面，安装完成以后就会在此目录下生成一个名为ddr_stress_tester_v2.90 的文件夹，此文件夹就是DDR 测试软件，进入到此文件夹中，里面的文件如图23.5.2.1 所示：
图23.5.2.1 中的DDR_Tester.exe 就是我们稍后要使用的DDR 测试软件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b5bff85722a99f2101a01fd380c429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b5b6401f3be0ac6b24a6523081d669/" rel="bookmark">
			45 岁程序员，在网上发求职贴：精通各种技术，却没有面试机会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是老皮。
11 月 1 日，有网民留言称，“我是一名软件开发人员，今年 45 岁，精通各种技术体系…… 而我辞职回家半年后再回来寻找工作机会的时候，却发现连个面试机会都很难得到。”
其实，这件事，最早的时候我是在微博上看到的，然后顺便评论了一句：
留言者有夸张成分，竟然精通那么多技术，还没找到工作，可能留言者想通过夸奖的叙事来彰显就业年龄限制的问题。
然后在微博上被喷惨了，其实，大家可能没有理解我的意思。
因为怀疑这个人不是程序员，因为他描述的都是精通，什么都精通。所以，有点怀疑，所以，我当时评论的时候已经比较温和了。我即使怀疑他不是程序员，我也只是说留言者的目的就是为了通过对比的手法彰显就业年龄限制和歧视的问题。
年龄歧视和限制确实是一个很严重，也很复杂的社会问题，确实值得重视。
从市场的机制来看 这是一个自由竞争的市场，我们能怎么着呢？哪个企业不想招聘便宜又好用的年轻人呢？就相当于我们消费者在市场上购买产品一样，是不是也喜欢货比三家，买那家最便宜的？
从个人的角度来看 话有说回来了，既然年龄大了，技术也能这么牛，为什么还竞争不过年轻人呢？你说不如年轻人体力好，不如年轻人有精力，但是，技术呢？按正常的发展逻辑是工作 10 年的人，应该比工作 3 年的人技术好吧？如果你的技术是企业的必需品，企业肯定不敢辞退你，反而你可能是抢手货。
但是，现实却是，工作 10 年的职场人，可能技术就跟工作 3 年的水平差不多，这时候，就没有优势了。
从企业的需求来看 为什么很多企业需要技术不怎么样的年轻人，不需要技术牛逼的中年人呢？原因也很简单：现在企业应用的技术，都很基础，并不需要那么高深的技术，企业做的业务就是普普通通的技术就能做到，你即使做到了很精通，很专深，做到了技术专家，但是，那么高的技术，你在大部分企业，尤其是中小型企业当中，是没用用武之地的，在企业的角度来讲，你的技术是多余的，可称之为：剩余技术劳动力，叫：技术节余。
我花高薪聘请剩余技术劳动力，是干这点活，聘请年轻人也是干这点活，价格又不一样，企业肯定是怎么划算怎么来。
换句话来讲，我国的很多 IT 技术企业普遍的技术深度不够，或者说是企业的基础研究创新不够，用不到那么多高深技术的人才。你看美国的工业软件多发达，我们在工业软件方面还受到美国的限制，国内到现在没几个微软、IBM、甲骨文、SAP 这样级别的公司，同类型差距太大。
这就会导致大部分公司用不到那些有技术积累的，经验丰富的中年人，所以，这就导致中年人跟年轻人相比唯一的经验和技术都没有优势了，毕竟年轻人那点技术就够用了。
再回到市场供给层面来谈一谈 大家都说企业不要 35 岁以上的人，那么为什么这么多企业还能好好活着呢？那就说明这个市场的年轻人就满足了企业的需求了。
你想一想：如果整个社会一共有 100 家公司，需求是 1000 人，市场提供了 1 万人，包含 6000 年轻人，4000 超过 35 岁的中年人，那这 100 家公司肯定都会去找年轻人，因为年轻人满足了他们的需求，没有技术大佬并不影响公司的生存。
如果你是企业负责人，你会怎么选？
所以，有些事情，并不能单纯怪企业只要年轻人，这个本质的背后最大的问题是供求关系的问题。
供大于求的时候，企业就有选择权，当然选择便宜又有精力的年轻人。
从国家层面来看，该如何解决？ 解决这个问题，最本质的背后是：要从国家层面出发，政府要引导正确的就业供需，保证和调节供需平衡，而不是什么行业火，就全都往这一个行业里钻，这势必就会供大于求，将选择权由企业主导。
有的行业是撑得撑死，有的行业是饿的饿死。
另外一个层面就是：当供需关系失衡的时候，国家应该有一种托底的机制，就是可以引导大家通过现在的技术进行一些创新或者培训再就业，引导多余的劳动力积极探索企业就业方向，国家应该有更多的政策支持和优惠 35 岁以上的人再就业和创业，给中年人更多的，更好的就业环境。
现在不都是倡导所有的企业上云，积极倡导传统企业进行互联网探索吗，这叫：互联网 + 。那么，像题主这样，技术这么牛的人，是不是政府可以推荐引导这些人进入传统企业，进行互联网 + 的探索呢？如果有这么一个推荐平台，是不是更好？
现在很多传统企业没有自己的研发人员，很多项目都找外包公司，买模板，做系统，干的非常烂，就是因为这些企业当中没有人懂技术。
外包技术公司的盛行，也导致了程序员行业劣币驱逐良币。市场上有太多垃圾的外包公司了，既坑害程序员，有坑害那些想转型的传统企业。
从程序员自身层面，应该想办法提升自己的多维竞争力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b5b6401f3be0ac6b24a6523081d669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8409a319bbb6c3ca4747d98d6400466/" rel="bookmark">
			Flutter 利用 Navigator.of(context).pop(this) 黑屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当直接调用跳转的时候会遇到红屏报错的问题
Navigator.of(context).push( MaterialPageRoute(builder: (context) { return JumpPage();//返回的是需要跳转单页面 },)); 此时不要保存热更新，需要重新运行项目即可
另外，当退出当前页面使用pop方法返回上一级的时候，会出现黑屏的现象
Navigator.of(context).pop(this); 主要是因为MaterialApp()的问题，只有main.dart设置MaterialApp就好，其他页面不需要设置MaterialApp，直接返回Scaffold即可
class RowDemo extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text("动态GridView")), body: BodyContent()); } } 此时就可以正常使用pop方法退出此页面了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a13d75e3b16ce7eaa6892d876a105a/" rel="bookmark">
			16进制累加器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体代码 using System; using System.ComponentModel; using System.Drawing; using System.Windows.Forms; namespace _16进制累加 { // Token: 0x02000002 RID: 2 public class Form1 : Form { // Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250 public Form1() { this.InitializeComponent(); } // Token: 0x06000002 RID: 2 RVA: 0x00002068 File Offset: 0x00000268 private void Form1_Load(object sender, EventArgs e) { } // Token: 0x06000003 RID: 3 RVA: 0x0000206C File Offset: 0x0000026C private void chaifen(string str) { try { string[] array = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a13d75e3b16ce7eaa6892d876a105a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/279/">«</a>
	<span class="pagination__item pagination__item--current">280/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/281/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>