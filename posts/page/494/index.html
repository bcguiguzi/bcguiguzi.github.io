<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30995ecf7e6fe3a27a02b36dd1a08a5d/" rel="bookmark">
			activity 代码中去掉背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.setBackgroundResource(0);
2.setBackgroundColor(0);
将其值设为0即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d0f76012f4115e2c3a309a58970564/" rel="bookmark">
			MDK V4.70打开工程报错Unable to find ARM libraries
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MDK V4.70.版本，安装完成后，打开工程编译会出现如下警告与错误的 linking... .\Obj\Measure.axf: Warning: L6373W: libattrs.map file not found in System Library directory C:\Program Files\ARM\ADSv1_2\LIB\armlib\. Library selection may be impaired. .\Obj\Measure.axf: Warning: L6310W: Unable to find ARM libraries. .\Obj\Measure.axf: Error: L6411E: No compatible library exists with a definition of startup symbol __main. Target not created 我的电脑----&gt;右击 属性----&gt;高级----&gt;系统----&gt;环境变量----&gt;系统变量 删除ADS的5个环境变量 在删除上述ADS1.2的5个系统变量之后，再重新打开KEIL下的工程文件，再次 编译工程，OK！解决问题！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38350f4430c6ca645ed87e05c6a442e/" rel="bookmark">
			TypedValue.applyDimension
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android中 TypedValue.applyDimension()的作用
这个方法是转换但我的一个函数，例如
int size =(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 20,context.getResources().getDisplayMetrics());
这里COMPLEX_UNIT_SP是单位，20是数值，也就是20sp。
/**
* dp转px
* * @param context
* @param val
* @return
*/
public static int dp2px(Context context, float dpVal)
{
return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
dpVal, context.getResources().getDisplayMetrics());
}
/**
* sp转px
* * @param context
* @param val
* @return
*/
public static int sp2px(Context context, float spVal)
{
return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
spVal, context.getResources().getDisplayMetrics());
}
/**
* px转dp
* * @param context
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38350f4430c6ca645ed87e05c6a442e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bec821c7a426697788d379b40820e6a/" rel="bookmark">
			实验：网络常见的9个命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．ping命令 ping是个使用频率极高的实用程序，主要用于确定网络的连通性。这对确定网络是否正确连接，以及网络连接的状况十分有用。简单的说，ping就是一个测试程序，如果ping运行正确，大体上就可以排除网络访问层、网卡、Modem的输入输出线路、电缆和路由器等存在的故障，从而缩小问题的范围。
ping能够以毫秒为单位显示发送请求到返回应答之间的时间量。如果应答时间短，表示数据报不必通过太多的路由器或网络，连接速度比较快。ping还能显示TTL（Time To Live，生存时间）值，通过TTL值可以推算数据包通过了多少个路由器。
(1) 命令格式
ping 主机名
ping 域名
ping IP地址 实验：网络常见的9个命令 如图所示，使用ping命令检查到IP地址210.43.16.17的计算机的连通性，该例为连接正常。共发送了四个测试数据包，正确接收到四个数据包。
(2) ping命令的基本应用
一般情况下，用户可以通过使用一系列ping命令来查找问题出在什么地方，或检验网络运行的情况。
下面就给出一个典型的检测次序及对应的可能故障：
① ping 127.0.0.1
如果测试成功，表明网卡、TCP/IP协议的安装、IP地址、子网掩码的设置正常。如果测试不成功，就表示TCP/IP的安装或设置存在有问题。
② ping 本机IP地址
如果测试不成功，则表示本地配置或安装存在问题，应当对网络设备和通讯介质进行测试、检查并排除。
③ ping局域网内其他IP
如果测试成功，表明本地网络中的网卡和载体运行正确。但如果收到0个回送应答，那么表示子网掩码不正确或网卡配置错误或电缆系统有问题。
④ ping 网关IP
这个命令如果应答正确，表示局域网中的网关路由器正在运行并能够做出应答。
⑤ ping 远程IP
如果收到正确应答，表示成功的使用了缺省网关。对于拨号上网用户则表示能够成功的访问Internet（但不排除ISP的DNS会有问题）。
⑥ ping localhost
local host是系统的网络保留名，它是127.0.0.1的别名，每台计算机都应该能够将该名字转换成该地址。否则，则表示主机文件（/Windows/host）中存在问题。
⑦ ping www.yahoo.com（一个著名网站域名）
对此域名执行Ping命令，计算机必须先将域名转换成IP地址，通常是通过DNS服务器。如果这里出现故障，则表示本机DNS服务器的IP地址配置不正确，或它所访问的DNS服务器有故障
如果上面所列出的所有ping命令都能正常运行，那么计算机进行本地和远程通信基本上就没有问题了。但是，这些命令的成功并不表示你所有的网络配置都没有问题，例如，某些子网掩码错误就可能无法用这些方法检测到。
（3）ping命令的常用参数选项
ping IP -t：连续对IP地址执行ping命令，直到被用户以Ctrl+C中断。
ping IP -l 2000：指定ping命令中的特定数据长度（此处为2000字节），而不是缺省的32字节。
ping IP -n 20：执行特定次数（此处是20）的ping命令。
注意：随着防火墙功能在网络中的广泛使用，当你ping其他主机或其他主机ping你的主机时，而显示主机不可达的时候，不要草率地下结论。最好与对某台“设置良好”主机的ping结果进行对比。 ipconfig命令 ipconfig实用程序可用于显示当前的TCP/IP配置的设置值。这些信息一般用来检验人工配置的TCP/IP设置是否正确。 而且，如果计算机和所在的局域网使用了动态主机配置协议DHCP，使用ipconfig命令可以了解到你的计算机是否成功地租用到了一个IP地址，如果已经租用到，则可以了解它目前得到的是什么地址，包括IP地址、子网掩码和缺省网关等网络配置信息。 下面给出最常用的选项：
(1)ipconfig：当使用不带任何参数选项ipconfig命令时，显示每个已经配置了的接口的IP地址、子网掩码和缺省网关值。
(2)ipconfig /all：当使用all选项时，ipconfig能为DNS和WINS服务器显示它已配置且所有使用的附加信息，并且能够显示内置于本地网卡中的物理地址（MAC）。如果IP地址是从DHCP服务器租用的，ipconfig将显示DHCP服务器分配的IP地址和租用地址预计失效的日期。图为运行ipconfig /all命令的结果窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bec821c7a426697788d379b40820e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271fcbcc5150293909b0cb529cfb47ac/" rel="bookmark">
			程序员的量化交易之路（35）--Lean之DataFeed数据槽3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载需注明出处：http://blog.csdn.net/minimicall，http://cloudtrade.top/
Lean引擎的模块划分非常的规范。其中DataFeed是数据槽，就是供应数据的模块。
1. IDataFeed 接口 模块的接口为：
namespace QuantConnect.Lean.Engine.DataFeeds { /// &lt;summary&gt; /// Datafeed interface for creating custom datafeed sources. /// 数据供应的借口 /// &lt;/summary&gt; public interface IDataFeed { /******************************************************** * INTERFACE PROPERTIES *********************************************************/ /// &lt;summary&gt; /// List of the subscription the algorithm has requested. Subscriptions contain the type, sourcing information and manage the enumeration of data. /// 订阅列表 /// &lt;/summary&gt; List&lt;SubscriptionDataConfig&gt; Subscriptions { get; } /// &lt;summary&gt; /// Prices of the datafeed this instant for dynamically updating security values (and calculation of the total portfolio value in realtime).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271fcbcc5150293909b0cb529cfb47ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9d631956bb26f69ea773ce2bec79ee/" rel="bookmark">
			HttpURLConnection上传大文件内存溢出的原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
由于HttpURLConnection默认是有缓存机制的，在对文件操作时，会将读取的数据写入到缓存区中，并不是直接写入到服务器上，只有当流被关闭时，才将数据提交到服务器上。当缓存区的数据大于虚拟机给点的内存时，就导致内存溢出。
HttpURLConnection设置固定缓存长度的代码：
HttpURLConnection设置缓存模式的代码：
解决办法：
conn.setChunkedStreamingMode(0);设置该选项，则不使用HttpURLConnection的缓存机制，直接将流提交到服务器上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb9c8de63f5750fc777b86b6b07752a/" rel="bookmark">
			51单片机汇编实现冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为了复习课本上面的程序，就实地检验了下这个程序，当年可是学过微机原理里的冒泡排序的，结果移植平台后又是如此麻烦，呵呵，网上贴吧，论坛，知道，文库上面拜托你们的程序能不能靠谱点！！！
第一种常见的错误就是程序写的一团糟，天马行空，弄了几个位地址和中间变量，外加两个循环，程序早飞了，真是让我们程序员惭愧啊
第二种错误是由于大多参考课本上题目：将以40H为首地址的N个数据进行排序，然后几十行代码，我怎么能很快知道程序对不呢
.................
鉴于此，特在我们这个绿色空间下贴上两种方法实现的冒泡排序完整版，实验程序已全部在keil下调试通过。（为了纪念下今天高考，大哭，好好加油吧）
思路：有序的数列更有利于查找。本程序用的是“冒泡排序”法，算法是将一个数与后面的数相比较，如果比后面的数大，则交换，如此将所有的数比较一遍后，最大的数就会在 数列的最后面。再进行下一轮比较，找出第二大数据，直到全部数据有序。 第一种方法：（缺点是不利于移植，优点是以末尾数字为参照，逻辑简单）
///
;冒泡排序
;十个数从小到大排序
ORG 0000H
MOV 60H,#02H ;给60-69H存储单元送初值
MOV 61H,#05H
MOV 62H,#03H
MOV 63H,#07H
MOV 64H,#09H
MOV 65H,#14H
MOV 66H,#13H
MOV 67H,#08H
MOV 68H,#01H
MOV 69H,#12H
MOV R0,#60H
MOV R1,#61H
L2: MOV A,@R0
MOV 50H,@R1
CJNE A,50H,NEQ ;比较60H与61H中数值的大小，做减法。如果60中的内容大则C位（进位为0）如果60中的内容比61中的小C位为1
NEQ: JNC EXCHANGE ;是0跳转,左操作数&lt;右操作数
LJMP L3
EXCHANGE: XCH A,@R1 ;交换60与61中的内容
XCH A,@R0
L3: INC R1
CJNE R1,#6AH,L2 ;让62到69中的内容逐一与60中的比较，最后60中的内容就是最小值
INC R0
MOV 51H,R0
MOV R1,51H
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb9c8de63f5750fc777b86b6b07752a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7f3f53335c876433b6539910d45c83/" rel="bookmark">
			SQL查询重复记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/caotang/archive/2011/01/18/1937932.html
假设现有一张人员表（表名：Person），若想将姓名、身份证号、住址这三个字段完全相同的记录查找出来，使用
1: SELECT p1.* 2: FROM persons p1,persons p2 3: WHERE p1.id&lt;&gt;p2.id 4: AND p1.cardid = p2.cardid 5: AND p1.pname = p2.pname 6: AND p1.address = p2.address 可以实现该功能。
删除重复记录的SQL语句
1.用rowid方法
2.用group by方法
3.用distinct方法
1。用rowid方法
据据oracle带的rowid属性，进行判断，是否存在重复,语句如下： 查数据: select * from table1 a where rowid !=(select max(rowid) from table1 b where a.name1=b.name1 and a.name2=b.name2......) 删数据： delete from table1 a where rowid !=(select max(rowid) from table1 b where a.name1=b.name1 and a.name2=b.name2......)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7f3f53335c876433b6539910d45c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e51699be0741ebc6e0cb72487c4807a/" rel="bookmark">
			Andorid学习【基础篇】Android应用程序生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与C++和Java不同的是，表面上Android应用程序并没有从main()函数启动，而是通过一系列的回调方法，方法响应用户的具体操作而被调用，使Andorid应用程序能切换到对应的状态，例如开启应用后，程序开始载入画面；用户操作，进入其他的页面；用户接电话、收发短信时，程序被暂停运行；用户想要暂时离开应用，回到桌面上打开其他应用等等，Andorid程序中的回调方法将会在相应的用户操作后执行，执行完毕之后，使得整个应用到达某一个状态，应用在每一种状态之间的切换，便构成了Android应用程序的生命周期。
也可以这样简单地理解Android应用程序生命周期：用户操作驱动相应的回调方法，相应的回调方法被执行后，使得状态在切换，状态的切换便构成了生命周期。
在Android的生命周期，有如下6个状态，分别是：Created，Started，Resumed，Paused，Stopped，Destroyed。相应的，有如下7个回调方法，使得Activity在不同的状态间切换，分别是：onCreate()，onStart()， onResume()，onPause()， onStop()，onRestart()，onDestroy()。当然这些方法只有在相应的用户操作或者状态发生之后才会被调用，在大多数情况下，我们可能根据需要，重载一部分回调方法，使得应用能如用户那样期待的正常运行。关于生命周期的流动方式，android官方教程给出的“金字塔式”图很直观地说明了问题：
一、 onCreate()
在启动应用后，首先调用onCreate()方法，该方法在整个应用的生命周期中只会被调用一次，主要完成应用的一些初始化工作，例如layout的载入，按钮、文本等等一些UI组件的初始化，或者是一些变量的初始化，因此如果要在启动时完成需要的初始化工作，只要重载该方法即可。
当应用开启时，系统将会根据在AndroidManifest.xml中指定的启动类，以该启动类作为入口进入程序，而onCreate以及其他6个回调方法都必须在该类中重载，其中，指定启动类，也就是我们的主类的写法，例如我们指定MainActivity.class作为主类，那么在AndroidManifest.xml中指定形式如下：
&lt;activity android:name=".MainActivity" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 一般来说，在onCreate()方法中，主要的目的是为该Activity创建一个实例，一般要做的事情有如下几件：
1. 调用父类onCreate()方法，载入上次保存的实例
2. 载入用户界面，一般来说是main_activity.xml
3. 定义或者调用一些用户自己定义的初始化方法
4. 为layout_main.xml中的UI控件分配相应变量，使得之后可以对其进行操作和管理
一个简单的例子如下：
TextView mTextView; // UI控件变量 private void userMethod() { // Codes goes here } @Override public void onCreate(Bundle savedInstanceState) { // 调用父类onCreate()方法，载入上次保存的实例 super.onCreate(savedInstanceState); // 调用用户自定义的方法 // 载入用户界面 setContentView(R.layout.main_activity); // 初始化UI控件变量 mTextView = (TextView) findViewById(R.id.text_message); } 其中，载入上次保存的实例savedInstanceState这一操作，将会在后面的博客文章中关于重新创建Activity的文章中，进行深入的学习。 当应用完成onCreate()的调用之后，到达Created状态，紧接着，系统将会立即调用onStart()和onResume()方法，使应用到达在前台显示出来(visible)，如果严格地说，在Started状态时应用已经在前台显示出来，但和Created状态一样，Started状态也是一个暂态，用户界面不会作任何停留，就会进入到Resumed状态，该状态便是应用稳定显示在前台时所处的状态，直到用户打算暂停、停止或者销毁应用时，onPause()，onStop()，onDestroy()方法将会被调用，将Activity带入金字塔的下层状态Paused，Stopped，Destroyed状态中，而且每一次回调方法的调用只会使状态改变一次，或者说只在金字塔上移动一层。关于onStart()和onResume()在一个应用中的重要意义和更多重载建议，将在下面Paused和Stopped状态返回Resumed和Started状态时的调用中体现。
二、 onDestory()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e51699be0741ebc6e0cb72487c4807a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c58028f69753461fdbfce0464a837d/" rel="bookmark">
			java写的 echo 和 linux系统自带的 echo 效率差别很大！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[nbz@localhost 0]$ uname -o GNU/Linux [nbz@localhost 0]$ which echo /bin/echo [nbz@localhost 0]$ time /bin/echo 1234 1234 real	0m0.011s user	0m0.001s sys	0m0.009s [nbz@localhost 0]$ ls echo.java [nbz@localhost 0]$ cat echo.java public class echo { public static void main(String []args) { if (args != null) { System.out.printf("%s\n", args[0]); } } } [nbz@localhost 0]$ javac echo.java [nbz@localhost 0]$ which java /usr/bin/java [nbz@localhost 0]$ time /usr/bin/java echo 1234 1234 real	0m0.208s user	0m0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c58028f69753461fdbfce0464a837d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317c9a819a4a8d7216fd41e32bb0a5dd/" rel="bookmark">
			FTP被动模式连接及超时问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 1、FTPClient.listFiles()或者FTPClient.retrieveFile()方法时，就停止在那里，什么反应都没有，出现假死状态。 2、连接FTP服务器，长时间进行数据操作时，超时自动断开。 分析： 1、因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 2、ftp的端口号20、21一个是数据端口，一个是控制端口，控制端口一般为21，而数据端口不一定是20，这和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。21控制端口激活后，数据端口如果长时间进行数据操作，到达服务器设定的超时时间，自动断开连接。 解决方法： 1、在调用这两个方法之前，调用Client.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据。Client.enterLocalPassiveMode();这个方法可以在登陆之前，也可以在登陆之后。 2、如果是长时间下载或操作多个文件，导致超时断开连接。可以在下载操作完成之后，给服务器返回一个命令，激活21端口，重置超时时间。
client.sendCommand("pwd"); 问题解决！
版权声明：本文为博主原创文章，未经博主允许不得转载。
转载于:https://www.cnblogs.com/alfily/p/4657221.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15c383c3c230f037ac653d78f278d94/" rel="bookmark">
			CUDA内核运行时间的测量函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：
cudaEvent_t start1; cudaEventCreate(&amp;start1); cudaEvent_t stop1; cudaEventCreate(&amp;stop1); cudaEventRecord(start1, NULL); // 需要测时间的内核函数kernel; cudaEventRecord(stop1, NULL); cudaEventSynchronize(stop1); float msecTotal1 = 0.0f; cudaEventElapsedTime(&amp;msecTotal1, start1, stop1); 方法二： StopWatchInterface * timer_cublas; sdkCreateTimer(&amp;timer_cublas); sdkStartTimer(&amp;timer_cublas); // 需要测时间的内核函数kernel; cudaSyncThreads() sdkStopTimer(&amp;timer_cublas); double dSeconds = sdkGetTimerValue(&amp;timer_cublas)/((double)nIter); 关于方法二中的cudaSyncThreads()说明，如果在sdkStopTimer之前不加该函数，会导致测量时间仅仅是核函数在CPU上启动的耗时，而没有考虑在GPU中的耗时，使得结果和方法一小很多。所以要等CUDA启动的GPU线程同步之后，才能停止计时，这样得到的耗时才是正确的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3929c082fc28559c233c65ca0931ba4f/" rel="bookmark">
			Android APP安装后不在桌面显示图标的应用场景举例和实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在为公司做一款车联网的产品，由于公司本身擅长于汽车解码器的研发，所以该产品的诊断功能的实现除了使用目前市面上车联网产品中大量使用的OBD协议外，还会使用一些专车专用协议去实现一些特殊的诊断功能，如升窗降窗、保养归零、读TPMS数据流等。公司的想法是把这些专车专用的诊断当成一种付费服务提供给用户，即用户在免费使用基于OBD协议实现的诊断功能外，若想使用专车专用协议实现的某个特殊功能则需要按每个功能多少钱的形式付费（本人不太赞成靠这种方式赚钱，觉得还是免费的好）。
我主要负责这款车联网产品中Android APP的开发,对于实现前面所提及的这个产品需求，我们准备把每款车的特殊功能诊断程序做成一个个的子程序，即一个个的子APK，之所以选择这样的一种方式，原因在于：①当前市面上车型很多，每个车型对应的同一个特殊功能的诊断程序因汽车协议不同而不一样，若全部程序都放在一个APP中，势必会造成APP过大，后期也不好维护；②提供这些特殊功能的初衷是为了迎合专业的汽车维修人员和车辆改装发烧友（以下称为“专业用户”）的需求，很可能大部分普通用户都不会去使用，这样能更方便需要的用户下载。
为了在用户安装了子APK之后不至于让用户的桌面全是各种图标（本人很讨厌手机桌面太乱），体验太差且让程序的入口还能集中在主APK，只能想办法使用一些小技巧在桌面不显示这些图标。具体实现方式如下：
1、开发一个名为OpenNoIconAPP.apk的主APP，里面就一个按钮用于点击后打开子APP，核心跳转代码如下： public void onClick(View view) { switch (view.getId()) { case R.id.btn_open_app: /* * Intent intent = getPackageManager().getLaunchIntentForPackage( * "com.example.noicontest"); if (intent != null) { // * startActivity(intent); } else { * Toast.makeText(getApplicationContext(), "没有该子APP，请下载安装", * Toast.LENGTH_LONG).show(); } */ Intent intent = new Intent(); ComponentName cn = new ComponentName("com.example.noiconapp","com.example.noiconapp.MainActivity"); intent.setComponent(cn); intent.setAction("android.intent.action.MAIN"); try { startActivityForResult(intent, RESULT_OK); } catch (Exception e) { Toast.makeText(this, "没有该子APP，请下载安装",Toast.LENGTH_SHORT).show(); } break; default: break; } } 2、开发名为NoIconAPP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3929c082fc28559c233c65ca0931ba4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bcfbd5eb4299ec7004ee5c4ef783a1/" rel="bookmark">
			秒杀问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网大潮下，电商汹涌，交易中的秒杀/超卖成了技术人员经常碰到技术问题。
秒杀/超卖首先可以从业务上来解决。比如，先抽奖事后再开奖。如果业务不能避免，那么只能通过技术手段了。
针对核心的库存部分，有这么几种方法。
第一个方式是利用数据库的事务串行和行级锁，辅以正确的sql语句。比如update resource_tbl set num=num-1 where id=1 AND num&gt;0 这种方式可以通过应用层的分组队列等，减轻数据层的压力，以便提高性能。参考淘宝丁奇的"秒杀场景下mysql的低效原因和改进"。淘宝有自己定制版的mysql数据库，还可以做到合并提交。可以看看这里(http://blog.csdn.net/jiao_fuyou/article/details/15504777)，他对丁奇的ppt做了一些解释以及可能的方案。
第二个方式是利用先进先出的队列。所有的请求都进入队列，在数据库层面请求是依次处理，先到的能秒成。
第三个方式，考虑到把所有的购买相关步骤(查看 下单 确认购买)移出数据库，只在cache中进行，最后才会更新到数据。这样就需要保证cache如果down了能恢复（比如记日志，不过这种涉及到IO的也会影响性能了）。淘宝有tair，可以做试试。(参考http://wenku.baidu.com/view/fc92f6bdfd0a79563c1e7252.html)
除了库存部分外，对这个问题有综合论述，可以参考"如何解决秒杀的性能问题和超卖的讨论"(http://www.cnblogs.com/billyxp/p/3701124.html)， 【内存】+【排队】，还考虑前端的一些减压措施。比如【扩容】【静态化】【限流】【有损服务】
这个"淘宝秒杀服务器架构猜想"(http://blog.jimeji.com/?p=691)也是不错的参考，他的基本思路是在java后端分层过滤减压。web服务器有多个，每个的servlet里或是业务处理模块，都做一个各自独立的计数（无耦合），超过总数即被过滤；第二层是利用共享的memcache(其有原子操作)的计数，超过总数即被过滤；最后才是app层，实际会如上述的库存管理。
安全起见，秒杀的服务器最好和其他的常规服务分开。
其他可以参考的秒杀文章链接
http://www.chepoo.com/seckill-system-design-and-implementation.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b699603298cbbd9cfa5629e7efafc44/" rel="bookmark">
			STS初始化环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、编码设为UTF-8 window-&gt;general-&gt;workspace 二、设置maven user Settings 引用文件 window-&gt;maven-&gt;user Setting 三、设置编码风格 window-&gt;java-&gt;code style 使用备用模版 四、导入maven工程项目。 五、配置server (tomcat) 四、extjs插件引用 导入插件包。 Window -&gt; Preferences -&gt; General -&gt; Editors -&gt; File Associations 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957c1f1b75d68a6b477624d2fe15c5d9/" rel="bookmark">
			Android中ActivityManager学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前写过2篇关于ActivityManager的文章，如下所示。都是通过实战去了解里面的信息，现在感觉太繁琐，所以做一个api介绍比较详细。就像之前学习Telephony那样，对整体了解整个ActivityManager很有用。
ActivityManager android.app包，含有6个内部类：
MemoryInfoProcessErrorStateInfoRecentTaskInfoRunningAppProcessInfoRunningServiceInfoRunningTaskInfo 先从ActivityManager API下手。
Constants META_HOME_ALTERNATE 主activity中的标签值
MOVE_TASK_NO_USER_ACTION 对于用户策动的活动，当前activity不会收到提示
MOVE_TASK_WITH_HOME 将后面的任务立即移动到前面
RECENT_IGNORE_UNAVAILABLE 提供一份不包含任何当前任务的列表，这些任务对于用户是不可见的
RECENT_WITH_EXCLUDED 返回所有的任务
Methods public boolean clearApplicationUserData () 清楚用户数据
public void dumpPackageState (FileDescriptor fd, String packageName) 获取相应包名对应的apk的各种状态信息
public ConfigurationInfo getDeviceConfigurationInfo () 获取设备配置信息
public int getLargeMemoryClass () 当一个应用程序在一个大的堆栈空间里运行时，估算当前设备中每一个应用内存片段的值
public int getLauncherLargeIconDensity () Lancher启动器的图标像素密度
public int getLauncherLargeIconSize () 启动器图标大小
public int getLauncherLargeIconSize () 当前设备每个应用的内存分类，就是内存的底线。低于这个值应用就会崩溃。
public void getMemoryInfo (ActivityManager.MemoryInfo outInfo) 当前系统的内存信息
public static void getMyMemoryState (ActivityManager.RunningAppProcessInfo outState) 返回调用者进程的全局内存状态信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/957c1f1b75d68a6b477624d2fe15c5d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a067a5845b82f08c03b78758bfbfc4/" rel="bookmark">
			Linux 下使用在C&#43;&#43;中V8引擎的环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近需要在C++环境下运行JavaScript脚本，找了一下资料，最后决定使用谷歌开源的V8引擎来完成这一任务。
在使用的最开始，遇到了一些配置上的问题，这里做一下记录和总结吧。
----------------------------------------------------------------------------------------------------------------------
1.下载V8引擎的对应配置，具体连接不在此处给出了
2.编译后，或者直接下载到so后缀的库文件
3.我下载到的时已经包含了.h和so库的版本。文件目录如下：
（1）主目录
（2）include目录下文件
（3）lib64下文件（我的计算机是64位的，所以主要用到这个文件夹，我猜测32位的应该使用lib目录下的文件）
（4）V8_demos目录下有一个Hello world 目录，我们看看这个目录下有什么：
主要时一些C++的文件，还有两个makefile文件，这两个makefile文件后面会有用到。
至于 helloworld.cc 文件中的代码，如下：
#include &lt;v8.h&gt; using namespace v8; int main(int argc, char* argv[]) { // Create a stack-allocated handle scope. HandleScope handle_scope; // Create a new context. Persistent&lt;Context&gt; context = Context::New(); // Enter the created context for compiling and // running the hello world script. Context::Scope context_scope(context); // Create a string containing the JavaScript source code. Handle&lt;String&gt; source = String::New("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7a067a5845b82f08c03b78758bfbfc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af58203b43095c79ab25c8bd14789d8/" rel="bookmark">
			在VS2012中配置pthread_win32(包含x86和x64两种平台)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载pthreads-w32-2-9-1-realease.zip 地址：http://www.mirrorservice.org/sites/sourceware.org/pub/pthreads-win32/ 2. 下载后解压，出来三个文件夹，我们只需要Pre-built.2文件夹3. 为了方便管理， 将include文件夹中的三个.h头文件拷贝到VS的安装路径/VC/lib路径下面，例如我的是C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\include 4. 同样地，将lib文件夹下面的两个文件夹x64/和x86/拷贝到C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\lib下面 5. dll文件下同样有x64和x86两个文件夹，程序实际运行时候需要用到。这里注意，要将x64文件夹拷贝到C:\Windows\System32\下面，让64位程序运行；而x86文件夹要拷贝到C:\Windows\SysWOW64\下面，让32位程序运行 6. 在新建的VS工程中，属性-&gt;VC++目录-&gt;包含目录、库目录分别追加：C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\include 和 C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\lib\x64（如果是32位程序就改成x86） 7. 再打开链接器-&gt;输入-&gt;附加依赖项，加上pthreadVC2.lib，至此配置完成，复制以下代码进行测试，成功显示结果即表示成功 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;assert.h&gt; void* Function_t(void* Param) { printf("我是线程！ "); pthread_t myid = pthread_self(); printf("线程ID=%d ", myid); return NULL; } int main() { pthread_t pid; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_PROCESS); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); pthread_create(&amp;pid, &amp;attr, Function_t, NULL); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af58203b43095c79ab25c8bd14789d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3699251bc04a22d24735e5b59f2c6fba/" rel="bookmark">
			Targan 算法[有向图强连通分量]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[有向图强连通分量]
在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通(stronglyconnected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。
下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。
直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。
[Tarjan算法]
Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。
定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，
Low(u)=Min{DFN(u),Low(v),(u,v)为树枝边，u为v的父节点
DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)}
当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。
算法伪代码如下
tarjan(u)
{
DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值
Stack.push(u) // 将节点u压入栈中
for each (u, v) in E // 枚举每一条边
if (v is not visted) // 如果节点v未被访问过
tarjan(v) // 继续向下找
Low[u] = min(Low[u], Low[v])
else if (v in S) // 如果节点u还在栈内
Low[u] = min(Low[u], DFN[v])
if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根
repeat
v = S.pop // 将v退栈，为该强连通分量中一个顶点
print v
until (u== v)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3699251bc04a22d24735e5b59f2c6fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af12d9592f355fc1c8193bd6174926e/" rel="bookmark">
			Android开发秘籍学习笔记（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中有关线程Thread等相关知识的笔记
线程Thread 每个应用程序在创建时都会默认运行单一的进程，其中包含所有的任务。为避免用户界面被挂起，那些耗时的任务 ，诸如网络下载或密集的计算，应当驻留于单独的后台线程中，如何适当地实现这种操作由开发者决定，但之后则是由Android系统基于开发者的实现来确定线程的优先级。 大多数应用程序都通过使用线程来提升性能。如果用户界面的挂起在软件设计阶段没有被发觉，到了测试阶段就会迅速体现出来，因为Android系统会在用户界面挂起时弹出警告—告诉用户Slow app isn’t responding.
Android Thread的使用方法： Thread的使用方法主要有两种方法：其中一种是extends Thread，然后重载Thread的run()函数，另一种是构建一个新的Thread对象，可带Runnable或不带。但不管怎么样，都是要通过start()函数来运行相应的代码 构建Thread对象的方法如下： 1、Thread()不代任何参数，该方法会在构建的时候自动生成线程名字。 举例：
Thread mThread = new Thread(){ @Override public void run() { // TODO Auto-generated method stub System.out.println("This is thread_test"); super.run(); } }; mThread.start(); System.out.println(mThread.getName()); 得到的logcat：
04-27 09:22:08.692: INFO/System.out(831): Thread-10 04-27 09:22:08.702: INFO/System.out(831): This is thread_test 2、Thread(Runnable runnable)该函数多了Runnable个对象，被运行的代码在Runnable对象里。 举例：
Runnable mRunnable = new Runnable(){ @Override public void run() { // TODO Auto-generated method stub System.out.println("This is thread with Runnable"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af12d9592f355fc1c8193bd6174926e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/493/">«</a>
	<span class="pagination__item pagination__item--current">494/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/495/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>