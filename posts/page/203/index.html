<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24526fedc7873ef9c2af4282176daa6/" rel="bookmark">
			D. Counting Arrays edu138 div2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem - D - Codeforces
题意是给你一个序列，他的序号是动态的，问你不确定的序列a从1-n数字在1-m里面，问你不确定序列a的个数
分析：容斥+构造
在所有的序列中，不管是什么必须有这样的序列，要想获取不确定的个数
就用全部的个数-确定的个数
确定的个数是什么呢，就是其他任何怎么删都有公约数
所以构造的方法就出来了
不需要每一次都乘i，只需要找到不互质的就可以
所以构造的序列是：
下面就是组合数的知识点了
看代码：
#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,"Ofast","inline") #define IOS ios::sync_with_stdio(false), cin.tie(0); #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;deque&gt; using namespace std; #define int long long typedef long long ll; typedef pair&lt;int,int&gt; PAII; const int N=2e6+10,M=5050,INF=1e18,mod=998244353; signed main(){ //IOS; int T; T=1; //cin&gt;&gt;T; while(T--) { int n,m; cin&gt;&gt;n&gt;&gt;m; int x=1; int now=1; int k=1; int sum=0; for(int i=1;i&lt;=n;i++) { x=x*(m%mod)%mod; if(__gcd(i,now)==1) { if(k!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24526fedc7873ef9c2af4282176daa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352142a307f69ae9fe476a6d382a8665/" rel="bookmark">
			[Codeforces] number theory (R1900) Part.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Codeforces] number theory (R1900) Part.2 题单:https://codeforces.com/problemset/page/1?tags=number%20theory,1601-1900
294C. Shaass and Lights 原题指路:https://codeforces.com/problemset/problem/294/C
题意 n n n盏灯排成一行,从左到右依次编号 1 ∼ n 1\sim n 1∼n,初始时有些灯亮有些灯灭.每一步可点亮个灭了的灯,如果它两边至少有一个亮的灯.问有多少种使得灯全亮的开灯方案,答案对 1 e 9 + 7 1\mathrm{e}9+7 1e9+7取模.
第一行输入两个整数 n , m ( 1 ≤ m ≤ n ≤ 1000 ) n,m\ \ (1\leq m\leq n\leq 1000) n,m (1≤m≤n≤1000),分别表示灯的个数和初始时亮的灯的个数.第二行输入 n n n个范围为 [ 1 , n ] [1,n] [1,n]的整数,表示初始时亮的灯的编号.
思路 m m m个亮的灯将序列分为 ( m + 1 ) (m+1) (m+1)段,从左往右编号 1 ∼ ( m + 1 ) 1\sim (m+1) 1∼(m+1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352142a307f69ae9fe476a6d382a8665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7392bbb0aac0e45f3b721bf23ca08054/" rel="bookmark">
			a-table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-table简单使用。
文章目录 一、a-table属性解释二、设置rowkey的三种方式三、分页点击无效四、columns示例总结 一、a-table属性解释 &lt;a-table &lt;!--dom操作的元素名称--&gt; ref="table" size="small" &lt;!--布尔值，是否显示边框--&gt; bordered &lt;!--rowKey,具有唯一性,给每一行一个特殊标记，不给同时没给key(每一列的特殊标记)浏览器会报错--&gt; rowKey="id" &lt;!--数组，指定列表头，详细数据在data中--&gt; :columns="columns" &lt;!--dataSource,数组,数据来源，数组中的每一个对象都是一行的数据--&gt; :dataSource="dataSource" &lt;!--分页器参数--&gt; :pagination="ipagination" :loading="loading" &lt;!--是否可选行，选中行的id，change事件--&gt; :rowSelection="{fixed:true,selectedRowKeys: selectedRowKeys, onChange: onSelectChange}" @change="handleTableChange"&gt; 二、设置rowkey的三种方式 每一种设置都需要保证rowkey不重复
&lt;!-- number为表格数据data中的一个属性，此时不需要：冒号 --&gt; &lt;a-table ref="table" size="middle" rowKey="number" :columns="columns" :data-source="data"" &gt; &lt;!-- record为为每条数据，index为索引 --&gt; &lt;a-table ref="table" size="middle" :rowKey="(record,index)=&gt;{return index}" :columns="columns" :data-source="data"" &gt; &lt;!-- number为表格数据data中的一个属性 --&gt; &lt;a-table ref="table" size="middle" :rowKey="record=&gt;record.number" :columns="columns" :data-source="data"" &gt; 三、如果分页点击无效，可能是没有添加@change="handleTableChange"事件 四、columns示例 a-table及数据列如下：
&lt;a-table ref="table" size="small" bordered rowKey="id" :columns="columns" :dataSource="dataSource" :pagination="ipagination" :loading="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7392bbb0aac0e45f3b721bf23ca08054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801aa0490e22712fdb088b8e9f050828/" rel="bookmark">
			vue 的ant design的Switch开关不支持二次确认，自定义封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：切换switch会直接触发状态改变，二次弹窗无法使用
实现效果图：
一、使用步骤
1.封装SwitchButton组件 代码如下：新建一个SwitchButton.vue的文件，最好放在公共组件中，也是方便后续使用
&lt;template&gt; &lt;div :class="['d-switch', { 'is-checked': checked }]"&gt; &lt;input class="d-switch__input" ref="input" type="checkbox" :checked="checked" @change="handleInput" :true-value="props.trueValue" :false-value="props.falseValue" /&gt; &lt;span :class="['d-switch__label', { 'is-checked': checked }]"&gt; {{ checked ? props.trueName : props.falseName }} &lt;/span&gt; &lt;span class="d-switch_action"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { computed, ref, nextTick } from 'vue'; const props = defineProps({ modelValue: { // 绑定值 type: [Number, String, Boolean], }, modelRecord: { // 绑定的json type: Object, }, trueValue: { // switch 打开时的值 type: [Number, String, Boolean], default: true, }, falseValue: { // switch 关闭时的值 type: [Number, String, Boolean], default: true, }, trueName: { // switch 打开时显示的文字 type: String, default: '开', }, falseName: { // switch 关闭时显示的文字 type: String, default: '关', }, }); const emits = defineEmits(['update:modelValue', 'change']); const input = ref(null); // 判断当前组件是否是打开状态 const checked = computed(() =&gt; { // 因为可以自定义打开和关闭的值 所以这里必须判断 v-model绑定的值 === 组件自定义打开的值 return props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801aa0490e22712fdb088b8e9f050828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6845e6fe2340073670427fb512e1453b/" rel="bookmark">
			Linux：SSH密钥认证登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境流程服务端和客户端都是Linux1、在客户端10.0.0.7生成密钥2、查看生成的文件3、将公钥传输给服务端4、客户端验证 服务端是Linux，客户端是windows1、通过xshell软件生成密钥2、将公钥传输给服务端3、修改连接服务器的会话属性 环境 角色ip服务端10.0.0.41Linux主机10.0.0.7windows主机10.0.0.1 流程 1.在客户端生成密钥对（公钥和私钥）
2.将公钥传给服务端
3.客户端向服务端发起申请连接
4.服务端用公钥验证客户端身份
5.客户端拿私钥相应
6.如果匹配就通过认证
服务端和客户端都是Linux 1、在客户端10.0.0.7生成密钥 ssh-keygen -t rsa 一路回车即可
2、查看生成的文件 id_rsa是私钥，id_rsa.pub是公钥，known_hosts是登录主机的记录
ls -a .ssh/ 3、将公钥传输给服务端 ssh-copy-id -i ~/.ssh/id_rsa.pub root@10.0.0.41 客户端
服务端
4、客户端验证 ssh root@10.0.0.41 服务端是Linux，客户端是windows 1、通过xshell软件生成密钥 2、将公钥传输给服务端 服务端
vim .ssh/authorized_keys 将刚才复制的公钥，添加到该文件的尾部
3、修改连接服务器的会话属性 新建一个连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbb53b0388c0bfbd240a9d0320cb270/" rel="bookmark">
			vue打包压缩插件：CompressionWebpackPlugin（文档、案例代码、配置教程、截图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue打包压缩插件：CompressionWebpackPlugin（文档） CompressionWebpackPlugin（文档）
安装及配置教程： 安装命令：
npm install compression-webpack-plugin --save-dev 配置教程：
请在webpack.config.js、或者vue.config.js等项webpack打包配置文件内设置：
const CompressionPlugin = require("compression-webpack-plugin"); module.exports = { plugins: [new CompressionPlugin()], }; 案例部分代码截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06533b2c09c2be7ab0c2fa2e50376fa/" rel="bookmark">
			11、Microsoft Visual Studio 2022 Installer Projects踩坑一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：VS自带的打包工具对于单文件简单程序很好用，对于多文件涉及到依赖其他程序就需要多一点配置了，之前打包过一个简单程序，后来程序变大后再执行生成的时候就出现问题了，要么执行不成功，要么生成成功安装后不管用，现就这种问题记录下解决心路。
wpf
Net6框架
vs2022
说明：不管是vs自带的打包工具还是NSIS等打包软件生成安装文件，其原理都一样，就是将程序可行性文件压缩打包，然后在释放安装，你会安装的程序内容和vs生成bin文件下的文件内容是一样的。所以一切都简单了，如果在bin中能运行，在安装后的文件中不能运行，那就比对下这两个文件夹下的内容是不是不一样，缺什么从bin下复制，如果可以运行了那就是打包时需要将其打包上。
一、添加主程序 笔者上一篇文章中的程序比较小，直接通过设置输出项即可完成打包，现在的程序发现这招不行了，查了下资料发现是需要添加依赖和程序执行文件
这里选择添加文件，导航到bin文件夹下，将其添加进来即可。
二、问题解决
安装好后运行下，出现这个错误
不慌，这是因为快捷方式没有指定到exe文件，看下安装文件是不是全了 相对于bin下文件，少了runtimes，先不管，先把快捷方式指定到exe看下效果
修改后重新加载后然后再安装
双击快捷方式，没反应，那就是那个runtimes运行环境没有被打包 将runtiems重新打包进Application Folder中，复制，然后黏贴进Application Folder中即可
重新生成下，然后安装，搞定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50de2ae1c7a55a16fa534345f82cb8cd/" rel="bookmark">
			golang 使用ffmpeg获取rtsp流截图,并生成缩略图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang 使用ffmpeg获取rtsp流截图,并生成缩略图 golang 调用命令公共方法
func CallCommandRun(cmdName string, args []string) (string, error) { cmd := exec.Command(cmdName, args...) fmt.Println("CallCommand Run 参数=&gt; ", args) fmt.Println("CallCommand Run 执行命令=&gt; ", cmd) bytes, err := cmd.Output() if err != nil { fmt.Println("CallCommand Run 出错了.....", err.Error()) fmt.Println(err) return "", err } resp := string(bytes) fmt.Println(resp) fmt.Println("CallCommand Run 调用完成.....") return resp, nil } golang直接使用命令调用ffmpeg 获取rtsp码流截图
ffmpeg命令
./ffmpeg -rtsp_transport tcp -timeout 10000000 -y -i rtsp://username:password@ip:554/chID=00000001-0000-0000-0000-000000000000 -ss 00:00:01 -vframes 1 -f image2 -vcodec png image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50de2ae1c7a55a16fa534345f82cb8cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b25f1fe47f0968287f7c8d031f734ca/" rel="bookmark">
			pygame总是安装失败怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pygame总是安装失败怎么办
pygame下载失败怎么办
换一个低一点的python版本就好了 吐血推荐，花了我好几个小时，python版本太多更新太快真不是一件好事
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b84d8afe6a2315aafa6c1235fd7c2f/" rel="bookmark">
			第 46 届 ICPC 国际大学生程序设计竞赛亚洲区域赛（沈阳）F题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入： 4 aacc 输出： bbaa 输入： 3 aca 输出： ba #include&lt;iostream&gt; #include&lt;unordered_set&gt; #include&lt;algorithm&gt; using namespace std; string s; string ans[1010]; unordered_set&lt;char&gt; se; int f[1000]; void solve(int len) { se.clear(); for(int i=len-1;i&gt;=0;i--) { if(se.count(s[i])==0) f[s[i]]=se.size(); se.insert(s[i]); } } int main() { int n;cin&gt;&gt;n; cin&gt;&gt;s; for(int len=1;len&lt;=n;len++) { solve(len); for(int j=0;j&lt;len;j++) { ans[len]+=(f[s[j]]+'a'); } } sort(ans+1,ans+1+n); cout&lt;&lt;ans[n]&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f26aec183e795206c4907f07a3e435/" rel="bookmark">
			（亲自实践）解决安装weditor报错UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0xad in position 825
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级weditor时，报错：UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 825: illegal multibyte sequence 网上查了好几个方法，尝试了好几次错误方法，发现需要设置环境变量，才能正常安装，所以给自己记录下，也方便其他程序猿食用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef91286e483b81a6241d8796f4d5e24b/" rel="bookmark">
			virtualbox安装centos7，共享文件夹及其正确的挂载，网络与IP设置完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、迅雷下载virtualbox-6.1.6
http://download.virtualbox.org/virtualbox/6.1.6/VirtualBox-6.1.6-137129-Win.exe
2、迅雷下载centos7-64.iso 镜像
http://mirrors.aliyun.com/centos/7.7.1908/isos/x86_64/CentOS-7-x86_64-Minimal-1908.iso
3、使用virtualbox创建虚拟机
4、虚拟机设置
创建好虚拟机之后先别急着打开，先要做一些配置。
choose a disk file 选择下载的iso镜像文件
设置端口转发，用以 xshell 连接
设置共享文件夹
以上配置就差不多了。
5、启动虚拟机
双击左侧虚拟机，报错了，启动不了，点击"无界面方式启动"，启动成功了，然后再双击左侧的虚拟机打开虚拟机界面，界面上提示选择一个镜像文件，但是实际上虚拟机已经在安装着centos7，因为前面我们已经指定了启动镜像，此处就不需要了。
开始安装。。。
设置语言
设置 root 账号的密码 raoxiaoya
使用 rignt + ctrl 退出键盘独占
虚拟机装好之后，使用root账号登录进去。
6、网络设置
ping www.baidu.com 显然网不通。编辑 /etc/sysconfig/network-scripts/ifcfg-enp0s3文件。设置 ONBOOT=yes
重启网卡 service network start
再次 ping www.baidu.com，发现已经可以了。
此时可以使用 xshell 连接虚拟机了，使用的是前面设置的端口转发。
127.0.0.1:2222 root / raoxiaoya 既然xshell已经可以连了，那么整个设置好以后只需要“无界面启动”虚拟机就可以了，免得多开一个窗口。
7、要让共享文件夹生效，必须安装增强功能
在虚拟机界面顶部菜单，设备 -&gt; 安装增强功能
所以需要手动来安装，
// 先安装必要的程序 yum update kernel -y yum install wget lrzsz bzip2 kernel-headers kernel-devel gcc make -y // 关闭防火墙 systemctl stop firewalld // 关闭防火墙 systemctl disable firewalld // 开机禁用 // 重启 reboot // 创建目录，并赋予权限，这一点很重要，且要先做。 mkdir -p /data/www chmod 777 /data chmod 777 /data/www // 上传文件 cd /media rz 找到 E:\Program Files\Oracle\VirtualBox\VBoxGuestAdditions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef91286e483b81a6241d8796f4d5e24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6ef4040022fe4a3a6e1fc77e3c1f08/" rel="bookmark">
			Clickhouse与Doris的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Doris使用较为简单，join功能更强大，运维更简单，灵活的扩容缩容，分布式更强，支持事务和幂等性导数
Clickhouse性能更佳，导入性能和单表查询性能更好，同时可靠性更好，支持非常多的表引擎，更多类型和函数支持，更好的聚合函数以及庞大的优化参数选项
那么两者之间如何选择呢？
业务场景复杂数据规模巨大，希望投入研发力量做定制开发，选ClickHouse
希望一站式的分析解决方案，少量投入研发资源，选择Doris
另外， Doris源自在线广告系统，偏交易系统数据分析；ClickHouse起源于网站流量分析服务，偏互联网数据分析，但是这两类场景这两个引擎都可以覆盖。如果说两者不那么强的地方，ClickHouse的问题是使用门槛高、运维成本高和分布式能力太弱，需要较多的定制化和较深的技术实力，Doris的问题是性能差一些可靠性差一些，下面就深入分析两者的差异。
1.上图是Doris的部署架构图，JDBC指接入协议，DNS是域名和请求分发系统。Managerment Panel是管控面。Frontend指前端模块简称FE，包含了SQL解析、查询计划、计划调度、元数据管理等功能，Backend指后端模块简称BE负责存储层、数据读取和写入，另外还有一个BrokerLoad导数组件最好是单独部署。所以，Doris一般只需要FE和BE两个组件。2. 右侧是ClickHouse的部署架构图，ClickHouse本身只有一个模块，就是ClickHouse Server，周边有两个模块，如ClickHouseProxy主要是转发请求、配额限制和容灾等，ZooKeeper这块负责分布式DDL和副本间数据同步，ClickHouseCopier负责集群和数据迁移，ClickHouse一般需要Server、ZooKeeper和CHProxy三个组件。3. 日常运维如更新版本、更改配置文件两者都需要依赖Ansible或者SaltStack来进行批量更新。两者都有部分配置文件可以热更新，不用重启节点，而且有Session相关参数可以设置可以覆盖配置文件。Doris有较多的SQL命令协助运维，比如增加节点，Doris中Add Backend即可，ClickHouse中需要更改配置文件并下发到各个节点上。
多租户管理ClickHouse的权限和Quota的粒度更细，可以很方便的支持多租户使用共享集群。比如可以设置查询内存、查询线程数量、查询超时等，以便来限制查询的大小；同时结合查询并发和一定时间窗口内的查询数量，以便来控制查询数量。多租户的方案，对发展中的业务非常友好，因为使用共享集群资源，可以快速动态调整配额，如果是独占集群资源利用率不高、扩容相对麻烦
扩容 扩容/缩容Doris支持集群的在线动态扩缩容，通过内置的SQL命令 alter system add/decomission backends 即可进行节点的扩缩容，数据均衡的粒度是tablet，每个tablet大概是数百兆，扩容后表的tablet会自动拷贝到新的BE节点，如果在线扩容，应该小批量去增加BE，避免过于剧烈导致集群不稳定。
ClickHouse的扩容缩容复杂且繁琐，***目前做不到自动在线操作，需要自研工具支持。***扩容时需要部署新的节点，添加新分片和副本到配置文件中，并在新节点上创建元数据，如果是扩副本数据会自动均衡，如果是扩分片，需要手工去做均衡，或自研相关工具，让均衡自动进行。
分布式： Doris组件的分布式能力主要包含在FE中，包含Berkeley JE HA组件，包含选举策略和数据同步，Doris的 FrontEnd可以部署3个Follwer + n个Oberserver（n&gt;=0）的方式来实现元数据和访问连接的高可用
ClickHouse目前版本是基于ZooKeeper来存储元数据，ClickHouse依赖Zookeeper来实现数据的高可用，Zookeeper带来额外的运维复杂性的同时也有性能问题。ClickHouse没有集中的元数据管理，每个节点分别管理，高可用一般依赖业务方来实现。ClickHouse中某个副本节点宕机，对查询和分布式表的导入没有影响，本地表导入要在导数程序中做灾备方案比如选择健康的副本，对DDL操作是有影响的，需要及时处理。
在分布式能力这块，Doris在内核侧已经实现，使用的代价更低；而ClickHouse需要依赖于外部配套的措施去保障，使用成本较高。
事务支持ACID指事务的原子性、一致性、隔离性和持久化，
OLAP的事务体现在几个方面：
一是导数，需要保证导数的原子性，同时也要保证明细数据和物化视图的数据一致性；
二是元数据的变更，需要保证所有节点的元数据统一变更的强一致性；
三是在节点间做数据均衡时，需要保证数据的一致性 Doris提供了导入的事务支持，可以保证导数的幂等性，比如数据导入的原子性，如果有其他错误会自动回滚，同时相同标签的数据不会重复导入。基于导入事务的功能，Doris还实现了Flink-connector这样的外部组件可以实现数据导入不丢不重。两者均不支持通用TP场景中的BEGIN/END/COMMIT语义的事务，很明显有事务支持的Doris比无事务支持的ClickHouse要节省很多开发成本，因为在ClickHouse中，这一切都需要外部导数程序来保证。ClickHouse不支持事务，需要在外部去做各种校验和检查，在导数这块能保证100万以内的原子性，但是不保证一致性，比如要更新某些字段或者更新物化视图，这个操作是后台异步的，需要显示指定关键字FINAL来查询最终数据，而且其他操作没有事务支持。DDL操作两者都是异步的，但是Doris能保证各个节点元数据的一致性，但ClickHouse中保证不了，会出现局部节点元数据和其他节点不一致的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb7ba0b0769d96dad321bfdfc725bda/" rel="bookmark">
			vue3动态生成的watch不会自动清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- 目标组件html --&gt; &lt;div&gt; {{ store.counter }} &lt;button @click="store.counter++"&gt;add&lt;/button&gt; &lt;button @click="createWatch"&gt;watch&lt;/button&gt; &lt;/div&gt; // 目标组件js const store = useCounterStore() // store是全局的一个响应式对象 const createWatch = () =&gt; { console.log('按装watch') watch(() =&gt; store.counter, () =&gt; { console.log('触发了侦听') }) } 我们现在目标组件安装了watch
然后再销毁目标组件 切换到消费组件 点击add按钮
&lt;!-- 消费组件html --&gt; {{ store.counter }} &lt;button @click="store.counter++"&gt;add&lt;/button&gt; // 消费组件js const store = useCounterStore() 可以看到依然一直触发 侦听器 说明侦听器没有被销毁
所以vue3中动态生成的watch不会自动清除 销毁组建的 时候需要注意清除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e053d9d9843e849bc7a27ab8c7ad254/" rel="bookmark">
			Andriod模拟报错处理-值得为此单独开立一篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用了10个小时处理这个 从 system ui isn't responding 当然真正要解决的问题是run 不起来flutter项目
可能在HAXM目录删掉-重装完就可以run了
直到：
2022-10-30 11:00:01.970 6004-6004/com.i7i8i9.flutterdemo01 I/Choreographer: Skipped 47 frames! The application may be doing too much work on its main thread.
看到这个画面时已经很感动了
总结一下以便未来遇到新的情况可以补充，也参考了很多资料，也自己尝试了一种
【电脑环境】:win10 ,很多以前的帖子都是基于win8
[检查项1]android sdk SDK Tools，HAXM确实被自动安装了
打开HAXM安装目录，自己再双击安装，确实报错 C:\Users\admin\AppData\Local\Android\Sdk\extras\intel\Hardware_Accelerated_Execution_Manager\ 报错日志在：
C:\Users\admin\AppData\Local\Temp
Version: 7.7.1
Output folder: C:\Program Files\Intel\HAXM
Extract: checktool.exe... 100%
Execute: C:\Program Files\Intel\HAXM\checktool.exe --verbose
CPU vendor * GenuineIntel
Intel64 supported * Yes
VMX supported - No
VMX enabled - No
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e053d9d9843e849bc7a27ab8c7ad254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98179881f80dd875b7837cb3e963035/" rel="bookmark">
			使用axios进行异步请求的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用axios进行异步请求的问题记录 在练习springboot和vue的项目过程中出现的一些问题进行记录。
问题一：使用axios页面提示错误信息 这是由于项目运行过程中没有找到或者没有正确加载axios。
解决方法： 在项目中main.js 文件中添加import axios from ‘axios’ 和
Vue.prototype.$axios = axios 这两行代码。
问题二：访问地址出现跨域问题导致访问数据失败 解决方法： 在后端中添加一个配置类处理跨域问题。
@Configuration
public class Config implements WebMvcConfigurer {
@Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedMethods("GET","POST","HEAD","PUT","DELETE","OPTIONS") .allowedOriginPatterns("*") .allowCredentials(true) .maxAge(3600) .allowedHeaders("*"); } } （在配置类上要记得添加@Configuration，不然结果还是一样）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c94c1f24b709c6ab844bc7af2ff454/" rel="bookmark">
			在引入外部文件时控制台显示net::ERR_FILE_NOT_FOUND
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误如下图：
原因：因为html文件与引入的文件不在一个文件夹中，找不到文件，这时候就要看是不是路径的问题。
解决方法：将引入文件的路径的上一级文件夹表示为../，采用相对路径。
比如：
我要在02.柱状图的实现.html中引入lib文件夹中的echarts.js文件，那么在script标签中src属性应写：
&lt;script src="../lib/echarts.min.js"&gt;&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d1e3c556e33d8611c0ee5d43a6d63a/" rel="bookmark">
			计算机网络困惑点（1）关于TDM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q：考虑从主机A到主机B经过一个电路交换网络发送一个640000比特的文件需要多长时间。假定该网络中的所有链路使用24时隙的TDM，比特速率为1.536Mbps。忽略其他因素，多长时间能够发送该文件。
A: 640000bit/(1.536Mbps/24）=10s
这个没什么。但对书中说的一句话不是很理解。他说该传输时间与链路数量无关。端到端电路不管是通过一条链路还是一百条链路，传输时间都将是10s。
原来疑惑的点在：TDM中，时间被划分为固定期间的帧，每个帧划分为固定数量的时隙。当网络跨越链路创建一条连接，网络在每个帧中为该连接指定一个时隙。
所以TDM划分的时隙数量和链路数量没有关系吗？如果和链路数量没有关系的话。那么它划分时隙数量的依据究竟是什么呢。而且，就算时隙数量和链路数量无关，那么当链路数量远大于时隙数量，电路交换网络是通过什么机制来处理，给他们分配“为数不多”的时隙的呢。只给和时隙数量相同的链路先分配时隙，剩下的链路等待？亦或者，不允许这种状态的发生。
欢迎大家一起讨论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b25d268a2af87c516ffb15f0ba8580f/" rel="bookmark">
			C&#43;&#43; STL中的allocator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绪论 As we all kown，C++中的STL容器使用其内置的std::allocator分配内存。如果我们想要更改STL分配内存的行为，我们不用更改容器的逻辑，只需要更改传入的allocator即可。一直以来，allocator对我来讲都笼罩着一层迷雾，总感觉是一个很复杂很恐怖的东西，最近因为课程原因，需要使用平台特定的内存管理函数（在NVM仿真平台quartz中需要使用其提供的pmalloc和pfree函数管理非易失性内存），就研究了一下std::allocator是怎么实现的。但是认真了解以后发现没有什么神奇的东西。
源码剖析 allocator主要有四个接口：
T *allocate(size_t)：用void * ::operator new(size_t)分配内存（但是不构造，其实就是对malloc的封装）void deallocate(T*, size_t)：使用void ::operator delete(void *)释放内存（其实是对free的封装）void construct(T*, Args&amp;&amp;)：使用定位new（placement new::new(void*) T(std::forward&lt;Args&gt;(args)...)）在指定内存上进行构造void destroy(T*)：调用析构函数（p-&gt;~T()）进行析构 不过后两者在C++17中被废弃了，在C++20中被删除了，我在stackoverflow上看到一个回答的大概意思是以后应该用std::allocator_traits::construct了。原回答：Why are are std::allocator’s construct and destroy functions deprecated in c++17?
去看了一下STL 的源码，发现std::allocator继承了__allocator_base，然后后者又继承了__gnu_cxx::new_allocator，也就是说其实用的是GNU版本的allocator，我认真阅读了一下__gnu_cxx::new_allocator的实现，发现的确挺简洁，没有什么特殊的东西，通过把里面的宏改成普通的关键字，删除掉我觉得没有什么用的版本判断，就可以得到一个简单的allocator实现：
// Copyright(C), Edward-Elric233 // Author: Edward-Elric233 // Version: 1.0 // Date: 2022/10/25 // Description: __gnu__cxx::new_allocator #ifndef TEMP_PALLOCATOR_H #define TEMP_PALLOCATOR_H #include "utils.h" #include &lt;new&gt; #include &lt;type_traits&gt; namespace edward { using std::size_t; using std::ptrdiff_t; /** * @brief An allocator that uses global new, as per [20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b25d268a2af87c516ffb15f0ba8580f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e244b03a35c80940c719cdc94d034758/" rel="bookmark">
			C# 简介（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C# 是一个现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的，由 Ecma 和 ISO 核准认可的。
C# 是由 Anders Hejlsberg 和他的团队在 .Net 框架开发期间开发的。
C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。
下面列出了 C# 成为一种广泛应用的专业语言的原因：
现代的、通用的编程语言。面向对象。面向组件。容易学习。结构化语言。它产生高效率的程序。它可以在多种计算机平台上编译。.Net 框架的一部分。 C# 强大的编程功能 虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。
下面列出 C# 一些重要的功能：
布尔条件（Boolean Conditions）自动垃圾回收（Automatic Garbage Collection）标准库（Standard Library）组件版本（Assembly Versioning）属性（Properties）和事件（Events）委托（Delegates）和事件管理（Events Management）易于使用的泛型（Generics）索引器（Indexers）条件编译（Conditional Compilation）简单的多线程（Multithreading）LINQ 和 Lambda 表达式集成 Windows 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/204/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>