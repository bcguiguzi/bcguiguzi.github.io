<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1844dbb60f84e26d7de9c22aa082cc0/" rel="bookmark">
			解决java前台传递时间到后台相差8个小时的时区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过查阅相关资料发现在spring转json的默认实现jackson中会根据时区去转换时间，而jackson的默认时区跟
国内应该是相差8小时，所以再时间换算上相差了8小时
解决方案一，在Model的时间字段上加上注解
@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss", timezone="GMT+8") @DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss") private Date regisDate; //注册时间 123 @JsonFormat用于输出的时候解析，并且设置解析时区
@DateTimeFormat用于接收 前端传的时间值自动转换 可以是Date 可以是string 注意 格式要一样 如yyyy-MM-dd HH:mm:ss
个人建议都加上 没毛病
解决方案二，application.properties配置文件增加以下配置
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 12 date-format指定date输出格式为yyyy-MM-dd HH:mm:ss
time-zone指定时区，解决8小时的时间差问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f195c5d979ad5fa1b9ba1229b9804e1/" rel="bookmark">
			关于class.getClassLoader().getResourceAsStream()和class.getResourceAsStream()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.class.getResourceAsStream() ①.不加‘ / ’，直接在包的路径下开始寻找，相当于在已经写好的path前面加了一句 /包名/path
②加‘ / ’，就要从classpath的那一层开始找
比如，找到存放编译后的class存放的位置：
//文件目录 yx jdbctest com A.class B.class 1.properties``` 2.properties //调用1.properties InputStream inputStream=PropertiesTest.class.getResourceAsStream("1.properties"); InputStream inputStream=PropertiesTest.class.getResourceAsStream("/yx/jdbctest/com/1.properties"); //调用2.properties InputStream inputStream=PropertiesTest.class.getResourceAsStream("/2.properties"); 123456789101112131415 2.class.getClassLoader().getResourceAsStream() getClassLoader是直接从classpath开始查找文件的，因此使用这个就需要定位在classpath这个位置，也就是下面目录中yx这一层。
//文件目录 yx jdbctest com A.class B.class 1.properties``` 2.properties //调用1.properties InputStream inputStream=PropertiesTest.class.getClassLoader().getResourceAsStream("yx/jdbctest/com/1.properties"); //调用2.properties InputStream inputStream=PropertiesTest.class.getClassLoader().getResourceAsStream("2.properties"); 12345678910111213 另外，如果你在整个工程目录下建立一个resource文件，编译之后，它会存到和yx同级的这个目录下，也就是classpath这里，如果建立的是一个test resource 那就会在这一层的上面一层中，这个等以后写了完整的程序出来，在做进一步的整理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c494af957189660aa834e3f508f657/" rel="bookmark">
			使用RPM快速安装nginx，了解RPM安装nginx各个主要目录的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rpm安装的优点与缺点： 优点： 安装简单方便 安装时不用指定安装位置 方便升级、卸载 支持离线安装 rpm软件包由于已经编译完成并且打包，所以安装很方便 缺点： 大多数rpm安装需要解决复杂的依赖关系 卸载时需要特别小心，最底层的软件不可以先删除，否则可能造成整个系统出问题rpm安装相比较源代码安装相比较而言，更加方便，安装速度也快，但rpm无法定制化安装。一、挂载光盘，将存放软件包的文件夹复制到/usr/src目录下 mount /dev/cdrom /mnt cd /mnt/ cp -rp nginx-rpm /usr/src/ cd /usr/srsc/nginx-rpm 查看目录下的所有软件包： 二、使用rpm命令安装nginx-rpm目录下的所有软件包： rpm -ivh *.rpm --nodeps --force --nodeps:忽略软件包之间的依赖关系，直接安装 --force :强制安装软件包 systemctl start nginx （启动服务） netstat -anpt | grep nginx （查看端口）到此nginx已经安装完毕！！！三、以下是查看使用RPM安装nginx，它的主要配置文件和网页目录，日志目录存放的位置。 查看主配置文件和扩展配置文件： rpm -ql nginx | grep .conf 查看网页的根目录： rpm -ql nginx | grep html 查看日志存放目录： rpm -ql nginx | grep .log 四、手动修改扩展配置文件，将默认的网页根目录修改为自己定义的网页根目录 cd /etc/nginx/conf.d/ （进入存放扩展配置文件的目录） rm -rf * vim web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c494af957189660aa834e3f508f657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab4fb1fab4790c7990aa85505940fa1/" rel="bookmark">
			从字符串中提取最长的数字子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序从输入的字符串中提取最长的数字子串。 输入格式: 输入：在一行中给出一个字符串。
输出格式: 输出：提取到的最长的数字字串。
输入样例: 在这里给出一组输入。例如：
asdf123bnm45678cd
输出样例: 在这里给出相应的输出。例如：
45678
&gt; 代码程序： import re def find(s): max = 0 count = 0 end = 0 if bool(re.search(r'\d', s))==False: print('No') else: for i in range(len(s)): if (s[i] &gt;= '0' and s[i] &lt;= '9'): count += 1 if (max &lt; count): max = count end = i else: count = 0 print(s[end - max + 1:end + 1]) s = str(input()) find(s) 终于到了期末总结的时刻了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab4fb1fab4790c7990aa85505940fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67643bc409019ced924a7299f520680c/" rel="bookmark">
			go.mod与module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Go 语言的项目中，go.mod 文件是 Go Modules 依赖管理系统的核心文件之一。在 go.mod 文件中，module 声明是用来定义当前项目的模块路径的。模块路径是项目中包的导入路径的前缀。下面是关于 go.mod 文件中 module 声明的详细介绍：
module 声明 module 声明指定了当前项目的模块路径，这在包的导入中非常重要。例如：
module test/Desktop/testt/greet 这行声明告诉 Go 工具链：
这个 go.mod 文件所在的目录是 test/Desktop/testt/greet 模块的根目录。该模块的名称是 test/Desktop/testt/greet，所有在该模块内部的 Go 文件都应该使用这个路径作为包的导入路径前缀。 模块路径 模块路径通常是项目的仓库位置，如 github.com/username/repo。在上面的例子中，module test/Desktop/testt/greet 看起来像是一个文件系统路径，而不是一个标准的模块路径。通常不推荐这样做，因为这可能会在其他机器或者环境中导致路径解析错误。 导入包 当其他项目想要导入这个模块中的包时，它们会使用模块路径作为导入路径的一部分。例如：
import "test/Desktop/testt/greet/pkg" 这将导入模块 test/Desktop/testt/greet 下的 pkg 包。
本地开发和构建 当你在本地开发时，Go 会使用这个模块路径来解析项目内的包导入。这意味着你可以在项目中拥有多个包，它们可以互相导入，只要使用正确的模块路径前缀。
Go Modules 自从 Go 1.11 版本开始，Go Modules 成为了官方推荐的依赖管理系统。go.mod 文件支持版本控制并且为项目定义了明确的依赖关系，这样的设计旨在提高跨环境构建的一致性和可预测性。
总结，module 声明在 go.mod 文件中定义了模块的路径，这对于包的导入和项目的依赖管理至关重要。在实际开发中，应该使用一个可全局定位到你的项目的路径，这通常是项目代码仓库的 URL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b2e21440ac5b886cf16fff6e788bd9/" rel="bookmark">
			redis 三主六从高可用docker(不固定ip)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis集群(cluster)笔记
redis 三主三从高可用集群docker swarm
redis 三主六从高可用docker(不固定ip)
redis 三主六从高可用dockerswarm高级版(不固定ip)
此博客解决，redis加入集群后，是用于停掉后重启，将nodes.conf中的旧的Ip替换为新的IP，从而达到不会因为IP变化导致集群无法正常使用
跨主机安装rediscluster集群，本文采用swarm的方式，使用同一个网络，然后分别在对应的机器启动
1.环境准备 dockerdocker-composeswarm集群安装文件 1.1 swarm环境安装 主机IPnode1192.168.56.100node2192.168.56.101node3192.168.56.102 在三台分别执行 开放防火墙：
firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.100" accept" firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.101" accept" firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.102" accept" firewall-cmd --reload firewall-cmd --list-all systemctl restart docker 1.2 在3台主机上配置swarm 在node1上执行： docker swarm init --advertise-addr 192.168.56.100 docker swarm join-token manager 返回类似以下内容：
docker swarm join --token SWMTKN-1-614xi9dvksycykobgifxb4pgopc1wwgczwqct5wqkq8zao6tmx-0ds4jj3ozclrr2wukcaoakxso 192.168.56.100:2377 在node2、node3上执行上面的返回结果： docker swarm join --token SWMTKN-1-2c2xopn2rld8oltcof24sue370681ijhbo3bwcqarjlhq9lkea-2g53o5qn2anre4j9puv4hecrn 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b2e21440ac5b886cf16fff6e788bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f77c22734f000fd310f702a3ddcd654/" rel="bookmark">
			redis 三主六从高可用dockerswarm高级版(不固定ip)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis集群(cluster)笔记
redis 三主三从高可用集群docker swarm
redis 三主六从高可用docker(不固定ip)
redis 三主六从高可用dockerswarm高级版(不固定ip)
此博客解决，redis加入集群后，是用于停掉后重启，将nodes.conf中的旧的Ip替换为新的IP，从而达到不会因为IP变化导致集群无法正常使用，以及使用docker stack 启动多个副本 ，自动化脚本加入集群
跨主机安装rediscluster集群，本文采用swarm的方式，使用同一个网络，通过对挂载目录的使配置文件互相同步，从而让redis集群失败自重启达到集群的高可用。
1.环境准备 dockerdocker-composeswarm集群nfs（或者挂载目录自动同步信息）安装文件 1.1 swarm环境安装 主机IPnode1192.168.56.100node2192.168.56.101node3192.168.56.102 在三台分别执行 开放防火墙：
firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.100" accept" firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.101" accept" firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.56.102" accept" firewall-cmd --reload firewall-cmd --list-all systemctl restart docker 1.2 在3台主机上配置swarm 在node1上执行： docker swarm init --advertise-addr 192.168.56.100 docker swarm join-token manager 返回类似以下内容：
docker swarm join --token SWMTKN-1-614xi9dvksycykobgifxb4pgopc1wwgczwqct5wqkq8zao6tmx-0ds4jj3ozclrr2wukcaoakxso 192.168.56.100:2377 在node2、node3上执行上面的返回结果： docker swarm join --token SWMTKN-1-2c2xopn2rld8oltcof24sue370681ijhbo3bwcqarjlhq9lkea-2g53o5qn2anre4j9puv4hecrn 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f77c22734f000fd310f702a3ddcd654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1d3d344aaaf7461beae79574d2f746/" rel="bookmark">
			vim环境配置 &#43;vimplus配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim配置 参考网站：传送门
这个网站详细说明了vim配置的命令，我挑选了我想要用的部分，自己配置了一下。
配置vim的文件有两个，一个是/etc/vim/vimrc 这个是系统配置文件，修改这个文件将会修改所有用户的vim环境，还有一个在宿主目录下，一般没有自己创建，需要我们手动创建文件~/.vimrc
cd vi .vimrc 打开文件以后加入以下配置
set number "设置行号" syntax on "打开高亮" set showmode "在底部显示模式" set showcmd "在底部显示命令" set mouse=a "支持使用鼠标" set encoding=utf-8 "使用utf-8编码" set t_Co=256	"配色方案为256" filetype indent on "自动检查文件类型并载入对应的缩进" set autoindent	"按下回车后下一行的缩进和上一行保持一致 set expandtab "自动将 Tab 转为空格" set softtabstop=4 "Tab 转为4个空格" set tabstop=4	"缩进为4" set shiftwidth=4 "使用&gt;&gt;/&lt;&lt;/==进行缩进设置的空格数" set cursorline	"光标所在行高亮" set textwidth=80 "设置一行显示多少字符" set wrap	"自动折行" set linebreak	"遇到符号时才会自动折行" set wrapmargin=2 "指定折行处与编辑窗口的右边缘之间空出的字符数" set scrolloff=5	"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1d3d344aaaf7461beae79574d2f746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1732c4dd47fd30891bd4f18437d4612e/" rel="bookmark">
			天线的相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天线：发射和接收电磁波的装置
1. 辐射强度
发射（接收）能量在空间中的角分布（单位立体角中的功率）。
2. 辐射功率
通过所有方向辐射出去的总功率。
3. 辐射电阻
对峰值电流，辐射电阻满足
4. 方向性
辐射强度与平均强度之比。平均强度是假设辐射功率被各向均匀辐射天线所辐射时的强度。
如果不指明方向，则默认取最大值。
5. 增益
辐射强度与参考强度之比。参考强度是假设输入功率被各向均匀辐射天线全部辐射出去时的强度。
如果不指明方向，则默认取最大值。
6. 辐射效率
辐射功率与输入功率之比。
7. 天线效率
考虑到输入阻抗不匹配时引起的反射损耗时的辐射效率。
8. 方向图
描述辐射场特性的空间图形。
E-平面：最大辐射方向与电场矢量方向所确定的平面。
H-平面：最大辐射方向与磁场矢量方向所确定的平面。
9. 输入阻抗
天线输入端电压与电流之比，或适当定义的电场与磁场之比。
10. 工作带宽
天线的某一特性在某一准则下的工作频率范围。比如输入阻抗（指定一种特性）在变化一半时（指定一个准则）的频率范围。
11. 有效面积
接收天线负载上所获得的功率与入射波功率流密度成正比，这个比例系数称为天线的有效面积。
最大有效面积：
通常天线口面拦截到功率只有一部分被传送到负载，需要经历传导损耗、介质损耗、极化损失和反射损耗等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7592c9b5ba56891bf9d63f0c21ab70/" rel="bookmark">
			ffmpeg命令基本语法和常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）常用命令 1、最简单转换命令
ffmpeg -i input.mp4 output.mkv
2、更加精准的控制转换命令
ffmpeg -i input.mp4 -c:v vp9 -c:a libvorbis output.mkv
（-c:v 控制视频格式， -c:a 控制音频格式）
3、调节比特率
ffmpeg -i GVG-981.mp4 -c:v libx264 -b:v 2M -maxrate 2M -bufsize 1M GVG-981-out.mp4
ffmpeg -i input.webm -c:a copy -c:v vp9 -b:v 1M output.mkv
（-b:v 1M 代表着视频的比特率变成1Mb
This will copy the audio (-c:a copy) from input.webm and convert the video to a VP9 codec (-c:v vp9) with a bit rate of 1M/s (-b:v), all bundled up in a Matroska container (output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7592c9b5ba56891bf9d63f0c21ab70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da882ac731fcb5aebf34734327f5eeb/" rel="bookmark">
			Flutter android及ios屏幕调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 横竖屏 // 横屏 SystemChrome.setPreferredOrientations([DeviceOrientation.landscapeRight,]); // 竖屏 SystemChrome.setPreferredOrientations([ DeviceOrientation.portraitUp, ]); 沉浸式 // 沉浸式 SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersive, overlays: []); // 退出 SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge); 消除导航栏背景色 SystemUiOverlayStyle systemUiOverlayStyle = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72cec9c834f8c66366fb2f1581219405/" rel="bookmark">
			Git命令操作【全系列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git常用命令操作 1 基础命令 ①git config --global user.name [‘你的用户名’]：查看/设置 git config --global user.name ziyi：设置用户名为ziyi
git config --global user.name：查看用户名
②git config --global user.email [‘你的邮箱’]：查看/设置 设置邮箱
③git reset HEAD test.txt 取消已经缓存的内容 取消test.txt已经缓存的内容
④git rm --cached &lt;file&gt; 将文件从暂存区删除 ⑤git branch 相关命令 git branch (-a): 查看(所有)分支 git branch -r ：查看远程分支
git branch &lt;branchName&gt; :创建本地分支 也可以通过：git checkout -b dev 本地创建dev分支
git push origin dev:dev：创建远程分支 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
git branch -vv：查看本地分支与远程分支对应关系 查看本地分支+上次提交的信息+本地和远程分支的关系，如果本地分支没有和任何远程分支建立追踪关系，那么就不显示。
如果要建立关系：git branch --set-upstream-to=origin/dev dev git branch --set-upstream-to=origin/dev dev：本地分支与远程分支建立关系 将本地dev与origin/dev(远程)建立联系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72cec9c834f8c66366fb2f1581219405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d32ebbca0928d6578ea848df4c87bf/" rel="bookmark">
			云原生技术简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌷🍁 博主猫头虎（🐅🐾）带您 Go to New World✨🍁
🦄 博客首页:
🐅🐾猫头虎的博客🎐《面试题大全专栏》 🦕 文章图文并茂🦖生动形象🐅简单易学！欢迎大家来踩踩~🌺《IDEA开发秘籍专栏》 🐾 学会IDEA常用操作，工作效率翻倍~💐《100天精通Golang(基础入门篇）》 🐅 学会Golang语言，畅玩云原生，走遍大小厂~💐 🪁🍁 希望本文能够给您带来一定的帮助🌸文章粗浅，敬请批评指正！🐅🐾🍁🐥
云原生技术近年来成为了软件开发和部署的前沿领域。它不仅改变了我们如何构建应用程序，还改变了我们如何部署和维护它们。那么，什么是云原生技术？为什么它如此重要？作为猫头虎博主，我将在本篇博客中为大家简要介绍云原生技术。
文章目录 云原生技术简介1. 什么是云原生技术？2. 云原生的核心原则3. 为什么选择云原生？ 原创声明 云原生技术简介 1. 什么是云原生技术？ 云原生是一种构建和运行应用程序的方法，使其可以在现代的、动态的环境中，如公有、私有和混合云中无缝运行。云原生应用程序是为云而生，不是简单地移植到云上的传统应用程序。
2. 云原生的核心原则 微服务架构：将应用程序分解为一组小型、独立和可互操作的服务。容器化：使用容器来打包、部署和运行应用程序及其依赖项。动态管理：利用现代平台如Kubernetes自动放置、扩展和管理应用程序。声明式API：使用声明式API来描述应用程序的期望状态。 3. 为什么选择云原生？ 弹性：云原生应用程序可以自动恢复从硬件故障到高负载的各种问题。可扩展性：可以根据需要自动扩展或缩小。快速迭代：更快的开发、部署和市场反馈周期。资源优化：确保资源的最佳利用和成本效益。 希望这篇简短的博客能帮助你了解云原生技术的基本概念和优势。随着技术的不断进步，云原生技术无疑将继续塑造我们的软件开发和部署的未来。希望每个开发者都能掌握并利用这一强大的方法。
猫头虎博主敬上。
以上是一个简单的云原生技术的简介。如果你有任何问题或想进一步深入探讨，请在评论区留言，我会尽量回复。不要忘了关注我的博客以获取更多有关云原生和其他技术话题的文章！
🐅🐾 猫头虎建议程序员必备技术栈一览表📖：
🤖 人工智能 AI:
编程语言: 🐍 Python (目前最受欢迎的AI开发语言)🌌 R (主要用于统计和数据分析)🌐 Julia (逐渐受到关注的高性能科学计算语言) 深度学习框架: 🔥 TensorFlow (和其高级API Keras)⚡ PyTorch (和其高级API torch.nn)🖼️ MXNet🌐 Caffe⚙️ Theano (已经不再维护，但历史影响力很大) 机器学习库: 🌲 scikit-learn (用于传统机器学习算法)💨 XGBoost, LightGBM (用于决策树和集成学习)📈 Statsmodels (用于统计模型) 自然语言处理: 📜 NLTK🌌 SpaCy🔥 HuggingFace’s Transformers (用于现代NLP模型，例如BERT和GPT) 计算机视觉: 📸 OpenCV🖼️ Pillow 强化学习: 🚀 OpenAI’s Gym⚡ Ray’s Rllib🔥 Stable Baselines 神经网络可视化和解释性工具: 📊 TensorBoard (用于TensorFlow)🌌 Netron (用于模型结构可视化) 数据处理和科学计算: 📚 Pandas (数据处理)📈 NumPy, SciPy (科学计算)🖼️ Matplotlib, Seaborn (数据可视化) 并行和分布式计算: 🌀 Apache Spark (用于大数据处理)🚀 Dask (用于并行计算) GPU加速工具: 📚 CUDA⚙️ cuDNN 云服务和平台: ☁️ AWS SageMaker🌌 Google Cloud AI Platform⚡ Microsoft Azure Machine Learning 模型部署和生产化: 📦 Docker☸️ Kubernetes🚀 TensorFlow Serving⚙️ ONNX (用于模型交换) 自动机器学习 (AutoML): 🔥 H2O.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d32ebbca0928d6578ea848df4c87bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555e22ef98f56acd37a8daca33a3b9e6/" rel="bookmark">
			关键词提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejieba关键词提取库 本来想在 centos 上安装 nodejieba，奈何 Centos7 上面的 gcc 的动态库太老，一直没办法更新动态库。
在 nodejieba 的 issues 找了一圈，发现了用 rust 实现的 node jiba 扩展：@node-rs/jieba：https://github.com/napi-rs/node-rs/tree/main/packages/jieba
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c8b44644692a25a099a414a1c431e3/" rel="bookmark">
			【通信原理】AM调制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本概念1. 模拟调制和数字调制2. 基带调制和载波调制3. 载波调制解调的一般过程 二、AM调制解调原理及抗噪声性能分析1. AM调制2. 解调方式（1）相干解调（2）包络检波 三、DSB调制解调原理及抗噪声性能分析四、SSB调制解调及抗噪声分析1. 希尔伯特变换2. 单边带信号的产生(相移法)3. SSB调制解调及抗噪声性能分析（1）调制（2）解调 一、基本概念 1. 模拟调制和数字调制 调制是指将信号（例如声音、图像、数据）转换成能够在信道中传输的信号形式的过程。在通信中，信息信号往往无法直接在信道中传输。因此，需要通过调制将信号转换成可以在信道中传输的模拟或数字信号。这个过程就像是将信息信号“嵌入”到另一个信号中一样。
调制的作用和目的：
把基带信号的频谱搬移到较高的频率处，就可以提高发送效率把多个不同的基带信号搬移到不同的载频处，以实现信道的多路复用，提高信道利用率扩展信号带宽，提高系统抗干扰能力 调制分为模拟调制和数字调制
模拟调制：将模拟信息信号（如声音、图像）通过一定的调制方式加到载波信号中，形成调制信号，然后将调制信号送入信道进行传输。在接收端，通过解调将调制信号中的信息信号提取出来。常见的模拟调制方式包括：调幅（AM）、调频（FM） 、调相（PM） 等。数字调制：数字调制是将数字信息信号（如二进制数据）通过一定的调制方式转换成一组数字信号，形成数字调制信号，然后将数字调制信号送入信道进行传输。在接收端，通过解调将数字调制信号中的数字信息信号还原出来。常见的数字调制方式包括：脉冲编码调制（PCM）、正交振幅调制（QAM）、相移键控调制（PSK）、频移键控调制（FSK）等。 2. 基带调制和载波调制 调制又分为基带调制和带通调制/载波调制
基带调制：将原始信号直接调制成一个低频信号，然后再进行传输。这种调制方式不需要使用载波信号，因此信号的频率范围较低，通常占据的带宽比较窄。常见的基带调制方式有脉冲调制、脉冲编码调制等。带通调制/载波调制：将原始信号调制到一个较高的载波频率上，然后进行传输。这种调制方式需要载波信号的支持，因此信号的频率范围比较广，在发送和接收端需要进行频率和相位同步以确保信号的正确解调。常见的带通调制方式有调幅、调频、调相等模拟调制和正交振幅调制、相移键控调制、频移键控调制等数字调制方式。 本文中只讨论载波调制的模拟调制系统
载波调制 就是利用调制信号去控制载波信号的某些参赛(例如幅度、频率、相位等)，使得载波的某些参数能够按照调制信号的规律变化。这种变化在信号传输过程中体现为信号频率、振幅、相位等的变化。如如调幅调制(AM)中，调制信号控制载波的幅度，调频调制(FM)中，调制信号控制载波的频率等等。
3. 载波调制解调的一般过程 载波调制是一种基于调制信号和载波信号相互作用的信号传输技术，过程如下：
基带/调制信号的产生： 调制信号就是来自信源的基带信号，这个信号通常是低频信号，频率在几百赫兹或几千赫兹左右。该信号有某些关键的参数信息，该信号可以通过调制信号控制载波信号的某个或某些特征，使载波信号具有有调制信号相同的信息。 载波信号的产生： 接下来，我们要产生一个高频信号，称为载波信号。载波信号可以是一个正弦波，频率通常在几兆赫兹（MHz）或更高。这个信号是一个没有任何信息的信号，只是作为一个容器用于传输基带信号。 调制过程： 调制是将调制信号与载波信号相互作用的过程，以便将调制信号转换成可传输的信号，通常将调制信号调制到高频信号中的某一特定变量（如幅度、频率或相位）上，形成已调信号。根据调制方式不同，有调幅（AM)调制，调频（FM)调制等 在调制过程中，调制信号的振幅、频率或相位决定了载波信号的振幅、频率或相位的改变，从而把原始信号的信息嵌入到了载波信号中。这样，我们就可以将基带信号通过载波信号进行传输。 解调过程： 接收端接收到信号后，需要先将载波分离出来，然后再将携带信息的信号解出来。这个过程就称为解调。解调的过程与调制的过程相反，是将载波信号与解调信号相乘，从而得到带有信息的信号。最终，我们可以通过将解调后的信号进行放大、重构、编码等处理，使得前面的原始信号完整地呈现在接收端。 在不同的载波调制方式中，具体的调制过程以及调制信号与载波信号之间的关系有所不同。例如，调幅调制（AM）中，调制信号控制载波信号的振幅；调频调制（FM）中，调制信号控制载波信号的频率；相位调制（PM）中，调制信号控制载波信号的相位。不同的调制方式在应用中具有不同的特点和适用场景。 二、AM调制解调原理及抗噪声性能分析 1. AM调制 标准调幅就是常规双边带调制，简称调幅(AM)。假设调制信号 m ( t ) m(t) m(t) 的均值为0，将调制信号与一直流偏量 A 0 A_0 A0​ 叠加，然后与载波相乘，就得到了调幅信号 s m ( t ) s_m(t) sm​(t)，调幅信号 s m ( t ) s_m(t) sm​(t) 在信道中传输的时候与噪声 n ( t ) n(t) n(t) 叠加，接收端得到 n ( t ) + s m ( t ) n(t)+s_m(t) n(t)+sm​(t)，此时将该信号通过带通滤波器，将噪声的频率分量限制在一定范围内，高斯白噪声 n ( t ) n(t) n(t)变为窄带高斯噪声 n i ( t ) n_i(t) ni​(t)，然后得到接收端的输入信号 s i ( t ) s_i(t) si​(t) 和接收端的输入噪声 n i ( t ) n_i(t) ni​(t) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c8b44644692a25a099a414a1c431e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e8af0c21f6b5a7a8cc11fbe6c5df67/" rel="bookmark">
			BaoStock（证券宝）数据平台入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 BaoStock平台简介平台介绍平台服务特点下载安装方式1：pip install baostock方式2：访问 https://pypi.python.org/pypi/baostock 下载安装 版本升级每日最新数据更新时间：获取数据范围说明股票数据指数数据季频财务数据季频公司报告 Baostock 简易使用指南1. 安装 Baostock2. 登录 Baostock3. 获取 A 股股票列表4. 获取股票历史K线数据5. 登出 Baostock 使用场景代码案例1. 获取股票历史K线数据2. 获取公司财务报表数据3. 使用Python进行简单数据分析 BaoStock平台简介 平台介绍 证券宝www.baostock.com是一个免费、开源的证券数据平台（无需注册）。
提供大量准确、完整的证券历史行情数据、上市公司财务数据等。
通过python API获取证券数据信息，满足量化交易投资者、数量金融爱好者、计量经济从业者数据需求。
返回的数据格式：
pandas DataFrame类型，以便于用pandas/NumPy/Matplotlib进行数据分析和可视化。同时支持通过BaoStock的数据存储功能，将数据全部保存到本地后进行分析。 支持语言：目前版本BaoStock.com目前只支持Python3.5及以上(暂不支持python 2.x)。
持续更新：BaoStock.com还在不断的完善和优化，后续将逐步增加港股、期货、外汇和基金等方面的金融数据，为成为一个免费金融数据平台努力。
分享优化：请通过微信、网站博客或者知乎文章等方式分享给大家，使它能在大家的使用过程中逐步得到改进与提升，以便于更好地为大家提供免费服务。
平台麦克：证券宝BaoStock.com从发布到现在，已经帮助很多用户在数据方面减轻了工作量，同时也得到很多用户的反馈。它将一如既往的以免费、开源的形式分享出来，希望给有需要的朋友带来一些帮助。
平台服务特点 Baostock 平台的一些主要特点和服务：
数据覆盖范围广泛：Baostock 提供了广泛的金融数据，涵盖了中国A股市场的股票、指数、基金、期货等多个领域。用户可以获取到历史K线数据、财务报表、公司公告等各类金融信息。
数据接口多样：Baostock 提供了多种数据接口，包括Python、Java、C++等不同编程语言的接口，使得开发者可以更灵活地使用其提供的数据服务。用户可以通过 API 获取数据，进行进一步的数据分析和量化研究。
专业的数据分析工具：Baostock 平台提供了一系列专业的数据分析工具，帮助用户进行技术分析、基本面分析、资金流向分析等。这些工具能够辅助用户制定投资策略、进行风险管理和优化投资组合。
量化交易支持：Baostock 的数据服务也支持量化交易，用户可以通过平台获取实时市场数据，进行算法交易和策略回测。这使得投资者能够更加智能地执行交易策略，提高投资效益。
社区支持和文档资源：Baostock 平台拥有活跃的社区，用户可以在社区中分享经验、提问问题，并得到其他用户和 Baostock 官方团队的支持。此外，Baostock 提供了详细的文档资源，方便用户深入了解其数据服务和接口使用。
下载安装 方式1：pip install baostock 使用国内清华源安装：
pip install baostock -i https://pypi.tuna.tsinghua.edu.cn/simple/ --trusted-host pypi.tuna.tsinghua.edu.cn 方式2：访问 https://pypi.python.org/pypi/baostock 下载安装 python setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e8af0c21f6b5a7a8cc11fbe6c5df67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b53960a565969ab10ef9e0ff88e58a/" rel="bookmark">
			展频（SSC）相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高速数字系统中，会用到展频的功能来优化EMI。不开展频，电子线路会向外部辐射电磁波导致EMI测试失败。
拿显示器来说，主板通过LVDS高速信号给Panel送时钟信号和画面数据，主控芯片Scaler一般都集成了展频功能，软件开发人员可以通过设置展频的参数来优化EMI。
软件中有两个参数可以设置，一个是扩展率（Percentage），另一个是调制频率（Modulation Frequence）。扩展率一般设置在0%~3%，调制频率一般设置在0~40Khz。
展频（SSC）的Percentage和Modulation Frequence的物理意义：
例如LVDS的时钟频率为148Mhz，SSC的Percentage设置为2%，Modulation Frequence设置为30Khz。
Percentage为2%，则LVDS的频率波动范围为（148-1.48）Mhz到（148+1.48）Mhz，也就是（146.52Mhz~149.48Mhz）。Modulation Frequence为30Khz意味着LVDS的时钟频率从146.52Mhz变化到149.48Mhz再变化到146.52Mhz，需要1/30Khz的时间。
用示波器测量LVDS的时钟，会发现时钟频率在（148-1.48，148+1.48）范围内周期变化，变化的频率是30Khz。但是LVDS的时钟频率的平均值还是148Mhz。
如果Percentage设置的过大，高速信号的时钟频率变化范围就会很大，导致系统跑飞掉。所以展频不能开的太猛，否则高速数字系统会不稳定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83dd1c041ca328fb554e0659250d855/" rel="bookmark">
			Quartus II 各版本安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Quartus II 下载链接
https://pan.baidu.com/s/1dugGB_gZxQ1U25nttGqENg?pwd=0531
1.鼠标右击【Quartus II 18.0(64bit)】压缩包（win11及以上系统需先点击“显示更多选项”）选择【解压到Quartus II 18.0(64bit)】。
2.打开解压后的文件夹，鼠标右击【QuartusSetup-18.0】选择【以管理员身份运行】。
3.点击【Next】。
4.选择【I accept the agreement】，点击【Next&gt;】。
5.修改路径地址中的首字符C可更改软件的安装位置（如：将C改为D表示安装到D盘），点击【Next&gt;】。
6.点击【Next&gt;】。
7.点击【Next&gt;】。
8.软件安装中……
9.取消勾选【Launch USB Blaster …】，点击【Finish】。
10.选择【If you have a……】，点击【OK】（之后弹出的界面请勿关闭）。
11.打开安装包解压后的【Quartus II 18.0(64bit)】文件夹中的【license】文件夹。
12.❶鼠标右击【license.dat】❷选择【打开方式】❸选择【记事本】❹点击【确定】。
13.将打开的文档中的【XXXXXXXXXXX】全部替换为【（nic）ID后的字符】（步骤11后弹出的界面所显示），替换后保存。
14.将保存的文档复制到软件安装位置根目录下（步骤6设置的，我这里为：D:\intelFPGA\18.0）。
15.❶点击【…】❷选择【license】，❸点击【打开】。
16.点击【OK】。
17.点击软件右上角【X】先退出软件。
18.打开安装包解压后的【Quartus II 18.0(64bit)】，鼠标右击【Crack】选择【复制】。
19.鼠标右击桌面【Quartus (Quartus Prime 18.0) Standard Edition】选择【打开文件所在位置】。
20.在空白处鼠标右击选择【粘贴】。
21.鼠标右击粘贴后的【Crack】选择【以管理员身份运行】。
①运行【Crack】前：先关闭“所有杀毒软件(部分电脑自带的“迈克菲”也要关闭）、防火墙、Windows Defender”，否则可能会被杀毒软件误杀无法运行。若已经没有该文件，需重新解压安装包。
22.点击【确定】。
23.点击【确定】。
24.点击【否】。
25.双击桌面【Quartus II 18.0(64bit) (64-Bit)】图标启动软件。
26.安装成功。
​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3907e3477a36a508c648cfda59c0c2/" rel="bookmark">
			Arduino基础项目（五）：继电器实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继电器（Relay）是一种电控制的开关器件，用一个小电流(低电压）去控制一个大电流（高电压）的开与关。
1,继电器模块
在网上买到继电器模块，如下图:
图模块下方有三个管脚，构成输入回路，其中（图中右侧)标注‘-’的管脚接地(GND)， 标注"+”的管脚接 5V， (图中左侧）标注‘S'的管脚接信号(数字I/O)
模块上方是一个继电器输出回路，继电器有三个接线口（图中0, 1, 2），用电表量一下，0和1接线口之间是通的（常闭），0和2接线口之间是不通的（常开）
继电器的型号是: SRD-05VDC-SLC-C, 说明输入电压为直流5V
看继电器上的标注：输出为10A 250VAC（即: 支持最高250V交流电压, 10A电流），或 10A 30VDC（即: 支持最高30V直流电压, 10A电流）
2, 接线
用三根杜邦线把继电器模块的三个管脚接到开发板上，其中“-”脚接GND, ‘+’脚接5V， S脚接 D3
3, 在Arduino IDE中写个Arduino程序控制继电 器 模块
int pinRelay = 3; //管脚D3连接到继电器模块的信号脚 void setup() { pinMode(pinRelay, OUTPUT); //设置pinRelay脚为输出状态 } void loop() { digitalWrite(pinRelay, HIGH); //输出HIGH电平,继电器模块闭合 delay(5000); //等待5000毫秒 digitalWrite(pinRelay, LOW); //输出LOW电平,继电器模块断开 delay(8000); //等待8000毫秒 } 三、继电器实验(使用继电器元器件自已搭电路）
1, 准备元器件和器材
继电器(型号 松乐SRD-05VDC-SL-C) 一个
面包板一块
PNP型三极管(型号8550)一个
二极管一个
1K 电阻一个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3907e3477a36a508c648cfda59c0c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4be7e93ff82ebc99f4ed9b386b2f68a/" rel="bookmark">
			Java解析xml文档，判断对象是一个json是jsonArray还是jsonObject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有一篇xml文档，如下：
现在需要解析出其中的内容，首先需要明确的是，文档是由一个个的标签嵌套形成的，例如整个xml文件是由许多DescriptorRecord标签构成， &lt;DescriptorRecord DescriptorClass = "1"&gt;xxxxxxxxxx&lt;/DescriptorRecord&gt;
现在需要解析出每个DescriptorRecord 里面嵌套的xxxx各层级标签里面的内容，
导入的依赖有：
&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.73&lt;/version&gt; &lt;/dependency&gt; 解析代码如下：
File file=new File("D:\\zoom\\字典相关\\desc2023\\test.xml"); SAXReader saxReader = new SAXReader(); Document doc = saxReader.read(file); JSONObject jsonObject = XmlUtil.xmlToJson(doc.asXML()); 首先将文件读取并且解析为doc，再转成JSONObject对象，
再获取DescriptorRecord标签下的内容
可以看到，整个xml文档里面，有5个DescriptorRecord嵌套，
通过“content”这个key，获取下面的内容，解析出来是一个JSONObject对象，
有的时候一个标签嵌套的是一个JSONObject，有的时候是一个JSONArray，需要进行判断：if (treeNumberList.get("TreeNumber") instanceof JSONArray)，
即对于treeNumberList获取key为TreeNumber是一个对象，还是一个数组，再进行取值。
在debug的时候，结合xml格式，来判断下一步是怎么取值，
fastjson的用法如下：
获取JSONObject 对象
JSONObject content = pubmed.getJSONObject("content"); 获取数组对象
JSONArray treeNumber = treeNumberList.getJSONArray("TreeNumber"); 通过String这个key来取值
String termName2 = content3.getString("String"); 通过Term来获取对象
termList.get("Term") 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/82/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>