<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53f76f79492c1a19e4123a3cb8dd944/" rel="bookmark">
			Plaidml--MAC&#43;A卡的深度学习方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Plaidmi 适合所有显卡的深度学习加速平台 特性 支持Kears（定制版）
支持A卡
基于OpenCL加速
安装 安装环境：macOS 10.15.3(OpenCL1.2)/Anconda3/Python3.7 1. 安装 1.1 安装plaidml-keras 安装官网使用pip安装，但最好指定较低版本，高版本亲测会有莫名的bug。
pip install plaidml-keras==0.6.4 1.2 设置默认配置（选择加速优先使用的硬件） 2 demo 只比正常的kears代码多行代码
os.environ["KERAS_BACKEND"] = "plaidml.keras.backend" 3 和pytorch对比 显卡不同，不好比较，实验室的N卡是GTX 970 显存4G， 笔记本显卡A卡为Radeon Pro 555X显存4G
DnCNN（patchsize=40x40, batch_size=128, iters=2000）训练1个epoch所需时间分别为1个小时和1.6个小时左右。
4 总结 由于此次疫情，返校时间一推再推，然而大论文提交时间并不会随之延迟。原本计划在家写好大论文的文字部分，等3月开学再补实验。可现实是：并没有如期写完文字部分和返校时间再次延迟。
今天早上起来我一度想买张显卡给家里的台式装上，还好我的口袋并不充裕，暂时打消了这个念头。最后无意中在b站看到标题为”如何在MAC下使用AMDGPU跑神经网络“的科普视频（还以为是标题党）。。。
随后按照plaidml官网安装，跑示例demo没问题，运行自己搭建的网络确发现loss一直为NAN异常值，而用cpu确正常。本来遇到bug再正常不过了，可难顶的是这玩意用的人特别少，相关博客都搜不到几篇。。。
无计可施想问问大佬，可这么冷门大佬估计也没用过，也不好麻烦人家。
几经折腾无果，晚饭后用手机翻到一篇17分钟前发的热乎的博客，正好是讲如何安装plaidml，并重点强调了要指定低版本安装。。。
重装pliaidmi-kears，运行，loss终于正常。
太折腾了，记录下，给需要的人也给自己有个参考。
完
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01aeae80c453fcadaf6c372131d3810e/" rel="bookmark">
			Java格式化输出(表格样式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 有时想输出整齐的二维数据，可是输出后因为数据的宽度导致输出并不好看，有的数据更是对不齐，歪歪扭扭；所以写了一个输出类Fout，意为格式化输出。
项目地址 github
代码与输出截图 代码调用：
列项：
输出样式：
正文 一、调用方式 Fout的构造函数
可以构造一个含有多级子列项的表。（无奈, 真是很费脑）
1.如果你的列项是固定的（即有固定的列Column），那么可以通过Class对象获取注解的方式来生成一个表；提供两种注解FormatOp与FormatOPSubColumn。如果你使用这种方法，则需自定义类来使用注解，该类必须继承FoutColumn类。
FormatOP可以设置该列的列名、方向（居左，居中，居右）、前景色、背景色，如Testcase类中State属性。
FormpatOpSubColumn可以指定该列的子列项，正如Testcase类中Action和Goto属性一样，需要传入子列项的Class对象。
2.如果你的列项不是固定的（即不知道会有多少列），那么可以通过构造函数Fout(ColumnAttr...)来创建列项和子列项。
在ColumnAttr中有快速创建一组列的方法qCreate(String…), 只需要传入列名即可。
3.如果你的列项不是固定的（即不知道会有多少列），也不想有类名，那么可以通过构造函数Fout(int)快速创建。
二、方法列表 insert() 逐个插入数据。insertln() 逐行插入数据。skipPlace() 跳过一个位置(即一个单元格)。insertSubColumn() 指定一个子列范围，逐个插入数据。insertlnSubColumn() 指定一个子列范围，逐行插入数据。setTableName() 设置表格名称。findValue() 找到某个值, 在输出时，前景色是红色。changeColumnColor() 改变某一列的前景色和背景色, 如果为0, 则不修改。 后文 缺点 表的形式是以List&lt;Object[]&gt;方式存放，所以比较消耗空间。有的方法比较死板，比如findValue()函数，只能一个个匹配，效率低。输出的过程中可能会有点卡顿，输出方式是一个一个输出，很慢。不能输出到文件中。 测试 小测试验
插入数据(行)并输出时间100110ms1000500ms100003000ms5000016000ms 插入数据(行)查找(1000次)并输出时间100300ms10001200ms100007500ms5000045000ms 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c88e713870a3a907d06dfb4783800c/" rel="bookmark">
			a and b   a or b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家对于 10 and 20 10 or 0 到底取哪个是不是很懵逼呢？
其实很简单：记住2点就好了
1.将0看作False 非0值看作True
如：10 and 0 == True and False 结果为 0 可要是 0 and 0 取哪个
因为都是 0 取值就无所谓了
可要是 10 and 10
那就看第 2条了
2.10 and 20 取 20 10 or 20 取 10
注意：非0值看作True 但只有1 == True
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589e63372d31b86c358ae25af7b540c9/" rel="bookmark">
			2019年度精选文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击文章标题即可查看
数据库
作者： 冯培源
文章标题：360自研分布式海量小文件存储系统的设计与实现
作者： 张阔
文章标题：分布式时序数据库QTSDB的设计与实现
作者：高吴林涧
文章标题：360回扫样本存储系统Xstore的设计与实践
作者：彭宏恩
文章标题：ElasticSearch 介绍及使用方法
编程
作者： 范家鹏
文章标题：SG ：一个简单的PHP语法糖扩展
作者： 张娜
文章标题：如何从代码层提高产品质量
作者：刘伟
文章标题：Linux select 一网打尽
文章标题：浅谈mmap
作者：xsqlx
文章标题：Louvain 算法原理及设计实现
作者：张正武
文章标题：服务端浏览器截屏
作者： 梁琦
文章标题：基于inotify实现配置文件热更新
文章标题：Go配置文件热加载 - 发送系统信号
作者：张寅
文章标题：浅谈 梯度下降法/Gradient descent
移动开发
作者：赵岩
文章标题：Flutter 实战之南瓜屋故事App诞生记
作者： 田东东
文章标题：360搜索彩蛋自动化开发实践
作者：张嘉慧 田田
文章标题：实时离线一体化助力渠道分析系统
作者：刘思源
文章标题：360联查引擎新版发布，究竟是变形金刚还是瑞士军刀？
作者：刘圣文
文章标题：Flutter从加载到显示
运维
作者：虚拟化网络团队
文章标题：新虚拟网络架构——Cable介绍
作者：孙逸旻
文章标题：360移动端性能监控实践QDAS-APM（iOS篇）
测试
作者：董十月
文章标题：揭开接口自动化测试的神秘面纱
以上就是2019年度精选文章
想看更多关于哪方面的文章？可以后台留言告诉我们
往期精彩回顾
SpriteJS的3D渲染能力 Up, Up, Up!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589e63372d31b86c358ae25af7b540c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ce37a8a86a5ddd22710f89cd0262f4/" rel="bookmark">
			2、RTSP协议的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 此系列只追求精简，旨在学习RTSP协议的实现过程，不追求复杂完美，所以这里要实现的RTSP服务器为了简单，实现上同一时间只能有一个客户端，下面开始介绍实现过程
在写一个RTSP服务器之前，我们必须知道一个RTSP服务器最简单的包含两部分，一部分是RTSP的交互，一部分是RTP发送，本文先实现RTSP交互过程
一、创建套接字 想一下我们在vlc输入rtsp://127.0.0.1:8554后发生了什么事？
在这种情况下，vlc其实是一个rtsp客户端，当输入这个url后，vlc知道目的IP为127.0.0.1，目的端口号为8854，这时vlc会发起一个tcp连接取连接服务器，连接成功后就开始发送请求，服务端响应
所以我们要写一个rtsp服务器，第一步肯定是创建tcp服务器
首先创建tcp套接字，绑定端口，监听
//1.创建套接字 serverSockfd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(serverSockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;on, sizeof(on)); //2.绑定地址和端口号 这个示例绑定的地址是INADDR_ANY，端口号为8554 bind(serverSockfd, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr) //3.开始监听 listen(serverSockfd, 10); RTSP服务器传输音视频数据和信息使用的是RTP和RTCP，所以我们还要为RTP和RTCP创建UDP套接字，并绑定号端口
//1.创建套接字 serverRtpSockfd = createUdpSocket(); serverRtcpSockfd = createUdpSocket(); //2.绑定端口号 当创建好套接字还有绑定号端口后，就可以接收客户端请求了 bindSocketAddr(serverRtpSockfd, "0.0.0.0", SERVER_RTP_PORT); bindSocketAddr(serverRtcpSockfd, "0.0.0.0", SERVER_RTCP_PORT); //3.开始accept等待客户端连接 clientfd = accept(serverSockfd, (struct sockaddr *)&amp;addr, &amp;len); 二、解析请求 当rtsp客户端连接成功后就会开始发送请求，服务器这是需要接收客户端请求并开始解析，再采取相应得操作
这里我们做得最简单，首先解析第一行得到方法，对于OPTIONS、DESCRIBE、PLAY、TEARDOWN我们只解析CSeq。对于SETUP，我们讲client_port解析出来
所以我们要做的第一步就是解析请求中的信息
解析完请求命令后，接下来就是更具不同得方法做不同的响应了，如下
/* * 作者：_JT_ * 博客：https://blog.csdn.net/weixin_42462202 */ if(!strcmp(method, "OPTIONS")) { handleCmd_OPTIONS(); } else if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ce37a8a86a5ddd22710f89cd0262f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925862d0762ecc89da83761d35626872/" rel="bookmark">
			antd-设置RangePicker默认选择时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引入moment
var moment = require('moment'); 2、设置区间和默认选择时间
// 默认选择时间为最近7天 const defaultSelectDate = { startDate: moment().startOf('day').subtract(7, 'd'), endDate: moment().endOf('day') } 3、设置到组件
&lt;Form.Item label="日期" {...formItemLayout}&gt; {getFieldDecorator('time', { initialValue: [defaultSelectDate.startDate,defaultSelectDate.endDate] })( &lt;RangePicker style={{ width: 236 }} onChange={this.handleSelectTime} /&gt; )} &lt;/Form.Item&gt; 注：RangePicker的onChange方法提供了第二个参数，可以直接获取到所选择的时间的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23365df4a7c4dd27e5051e94ea2f8acf/" rel="bookmark">
			漏洞扫描工具 -- awvs13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我羡慕那些又帅又有钱的男生，他们拥有过很多女孩的青春，而我，只能拼命赚钱，才能拥有一个爱过别人的姑娘。。。。
awvs是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。
一、安装主程序，一路下一步
二、绿化程序
1、覆盖原来的wvsc
2、覆盖原来的license_info.json
三、查看绿化效果
1、打开程序，自动跳转到登录界面
登录查看License
四、使用方法
1、新建扫描
2、开始扫描
3、设置扫描时的UA
4、设置扫描选项，选择全扫
5、扫描结果
禁止非法，后果自负
欢迎关注公众号：web安全工具库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5991575dacdfc916ce3619c27d5d5b/" rel="bookmark">
			[AcWing] 格子游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格子游戏 题目 Alice和Bob玩了一个古老的游戏：首先画一个 n×n 的点阵（下图 n=3 ）。
接着，他们两个轮流在相邻的点之间画上红边和蓝边：
直到围成一个封闭的圈（面积不必为 1）为止，“封圈”的那个人就是赢家。因为棋盘实在是太大了，他们的游戏实在是太长了！
他们甚至在游戏中都不知道谁赢得了游戏。
于是请你写一个程序，帮助他们计算他们是否结束了游戏？
输入格式 输入数据第一行为两个整数 n 和 m。n表示点阵的大小，m 表示一共画了 m 条线。
以后 m 行，每行首先有两个数字 (x,y)，代表了画线的起点坐标，接着用空格隔开一个字符，假如字符是 D，则是向下连一条边，如果是 R 就是向右连一条边。
输入数据不会有重复的边且保证正确。
输出格式 输出一行：在第几步的时候结束。
假如 m 步之后也没有结束，则输出一行“draw”。
数据范围 1 ≤ n ≤ 200 1 ≤ m ≤ 24000 1≤n≤200\\ 1≤m≤24000 1≤n≤2001≤m≤24000
输入样例 3 5
1 1 D
1 1 R
1 2 D
2 1 R
2 2 D
输出样例 4
题解 思路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5991575dacdfc916ce3619c27d5d5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506456ee3032eff43d32a85f08d77abc/" rel="bookmark">
			react-native:command not found 命令无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：没有配置环境变量
要是知道ReactNative的目录，请自行知道到路径，不知道请看下面：
Windows：npm install -g react-native-cli 这个命令会出现一个目录
找到这个目录
复制此路径到配置环境变量即可
Mac： sudo npm install -g react-native-cli 出现的一个类似：/usr/......的路径记录下路，这里叫做路径A
使用终端
1.open /.bash_profile 在里面加入：export RN=路径A
export PATH=$RN:$PATH
保存
2.vim ~/.bash_profile 在里面加入：export RN=路径A
export PATH=$RN:$PATH
然后按“esc”键 结束编辑 并输入“：wq”存储
输入：source~/.bash_profile 使其生效
echo $path 查看是不是有刚刚添加的路径A
要是使用的zsh，则类似，打开或者编译 /.zshrc 这个文件，写进去环境变量地址，然后使其生效即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b38b15ade44a896a1347d5d8ea9eaf6/" rel="bookmark">
			安装交叉编译工具链时需要安装32位库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo apt install lib32z1-dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cc11fe70e0373fe98dee9caad71648/" rel="bookmark">
			c&#43;&#43; 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面向对象3大特性 封装、继承、多态
1.1 多态 顾名思义就是同一个事物在不同场景下的多种形态。
1.1.1 静态多态 我们以前说过的函数重载就是一个简单的静态多态，静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。
1.1.2 动态多态 动态多态：它是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。
基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。 通过基类对象的指针或者引用调用虚函数，因为派生类对基类中的虚函数进行重写，使用派生类的虚函数替换相同偏移量位置的基类虚函数，如果派生类中新增加自己的虚函数，按照其在派生类中的声明次序，放在上述虚函数之后 。
重写 ： （a）基类中将被重写的函数必须为虚函数（上面的检测用例已经证实过了） （b）基类和派生类中虚函数的原型必须保持一致（返回值类型，函数名称以及参数列表），协变和析构函数（基类和派生类的析构函数是不一样的）除外 （c）访问限定符可以不同 那么问题又来了，什么是协变？ 协变：基类（或者派生类）的虚函数返回基类（派生类）的指针（引用） 总结一道面试题：那些函数不能定义为虚函数？ 1）友元函数，它不是类的成员函数 2）全局函数 3）静态成员函数，它没有this指针 4）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）
可理解：因为虚函数需要靠特定的对象来决定激活哪一个函数
1.1.3 动态多态缺陷 降低了程序运行效率（多态需要去找虚表的地址）
空间浪费(需要创建虚表，浪费空间)
1.1.4 虚函数表 一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。
（1）通常一个类的虚函数表：
（2）一般继承（无虚函数覆盖）
实例Derive d 对应的虚函数表 ： 我们可以看到下面几点：
1）虚函数按照其声明顺序放于表中。
2）父类的虚函数在子类的虚函数前面。
（3）一般继承（有虚函数覆盖）
实例Derive d 对应的虚函数表 ：
我们从表中可以看到下面几点，
1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
2）没有被覆盖的函数依旧。
（4）多重继承（无虚函数覆盖）
d对应虚函数表
我们可以看到：
1） 每个父类都有自己的虚表。
2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）
（5）多重继承（有虚函数覆盖）
d对应虚函数表
我们可以看到：
三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了
虚函数表带来的不安全性：
（1）访问non-public的虚函数
如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数
二、STL 2.1 vector
vector，简单地讲就是一个动态数组，里面有一个指针指向一片连续的内存空间，当空间不够装下数据时会自动申请另一片更大的空间，然后把原有数据拷贝过去，接着释放原来的那片空间；当释放或者说是删除里面的数据时，其存储空间并不会释放，仅仅只是清空了里面的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1cc11fe70e0373fe98dee9caad71648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5444943e804465d66303ad55705ee86c/" rel="bookmark">
			UTM投影的选择（地区-&gt;投影带）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要在ArcMAP中启用shape.area和shape.length计算（几何计算），需要设置投影坐标，WGS-1984地理坐标系一般都设置为UTM投影，涉及不同经纬度不同分带选择，下面详细介绍一下UTM投影。
UTM 投影(Universal Transverse Mercator，通用横轴墨卡托投影)是由美国军方在1947提出的，美国本土采用Clarke 1866椭球体以外，UTM在世界其他地方都采用WGS 1984。
UTM 投影是一种等角横轴割圆柱投影，圆柱割地球于南纬80度、北纬84度两条等高圈，被许多国家用作地形图的数学基础，如中国采用的高斯-克吕格投影就是UTM投影的一种变形，很多遥感数据，如Landsat和Aster数据都应用UTM投影发布的。
UTM投影将北纬84度和南纬80度之间的地球表面积按经度6度划分为南北纵带(投影带)。从180度经线开始向东将这些投影带编号，从1编至60(北京处于第50带) ，因此1带的中央经线为-177（-180 -(-6)），而0度经线为30带和31带的分界，这两带的分界分别是-3和3度。
每个带再划分为纬差8度的四边形，从80S到84N共20个纬度带（X带多4度），分别用C到X的字母来表示。为了避免和数字混淆，I和O没有采用。两条标准纬线距中央经线为180KM左右,中央经线比例系数为0.9996。 UTM北半球投影北伪偏移为零，南半球则为10000公里。
中国UTM投影带号中国国境所跨UTM带号为43-534。UTM投影带号计算
如WGS_1984_UTM_Zone_49N，这个49的计算方法： 49：从180度经度向东,每6度为一投影带，第49个投影带 49=（114+180）/6，这个114为49投影带的最大经线。如图所示：
北半球地区，选择最后字母为“N”的带，
带数=（经度整数位/6）的整数部分+31
如：广州市经度范围112.95-113.98，带数=113/6+31=49，选49N，即WGS 1984 UTM ZONE 49N
————————————————
版权声明：本文为CSDN博主「aganliang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/aganliang/article/details/83025326
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c6e2cf9b64ba1c378417f66dc6401f/" rel="bookmark">
			嵌入式Linux开发板移植SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH服务可以很方便的通过网络登录到Linux开发板，同时支持SFTP协议向开发板传输文件。下面简单讲下移植过程。
开发板环境：
名称：imx283内核：Linux2.6.35.3 1.下载源码 zlib下载openssl下载openssh下载 建议先下载openssh，openssh也不要下载最新版本，zlib和openssl的版本最好早于openssh的版本，因为openssh的编译会用到zlib和openssl生成的库 ，若zlib和openssl的版本比openssh新，可能在编译openssh时出现不兼容等问题。
我这里下载的是zlib-1.2.8、openssl-1.0.2、openssh-7.1p1。
2.zlib编译 解压zlib-1.2.8，进入zlib根目录
1&gt;./configure --static --prefix=/test/open-ssh/zlib/ 生成makefile
--static 表示生成静态库 也可以使用--share生成动态库
--prefix 指定make install的安装目录
2&gt;修改makefile 更换编译器为交叉编译器
CC=arm-fsl-linux-gnueabi-gcc
LDSHARED=arm-fsl-linux-gnueabi-gcc
CPP=arm-fsl-linux-gnueabi-gcc -E
AR=arm-fsl-linux-gnueabi-ar
3&gt;make
4&gt;make install
3.openssl编译 解压openssl源码，进入源码根目录
1.配置 openssl的新旧版本配置方式有点不同，具体配置方式可以查看./configure -h
1.1.1版本配置：
./Configure linux-generic32 no-asm shared no-async --prefix=/test/open-ssh/open-ssl1/ CROSS_COMPILE=/ZLG_linux/gcc-4.4.4-glibc-2.11.1-multilib-1.0/arm-fsl-linux-gnueabi/bin/arm-fsl-linux-gnueabi- CC=gcc -fPIC linux-generic32：32位系统
no-asm：在交叉编译过程中不使用汇编代码代码加速编译过程
shared：生成动态连接库
no-async：不使用GNU的ucontext库 交叉编译工具链没有提供GNU C的ucontext库
--prefix：指定install输出的目录 CROSS_COMPILE：指定编译器，需要绝对路径
-fPIC全称是Position Independent Code，用于生成位置无关代码，代码无绝对跳转，都是相对跳转。 1.0.2版本配置：
./Configure --prefix=/test/open-ssh/open-ssl/ os/compiler:/ZLG_linux/gcc-4.4.4-glibc-2.11.1-multilib-1.0/arm-fsl-linux-gnueabi/bin/arm-fsl-linux-gnueabi-gcc --prefix 指定make install的安装目录
这里交叉编译器路径最好使用绝对路径
2.编译
make
3.安装
make install 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c6e2cf9b64ba1c378417f66dc6401f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b24c05e9f0e8b4ea8ab8c6244bf2f0e/" rel="bookmark">
			DockerSwarm里集群服务间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Routing Mesh InternalIngress Routing Mesh 是集群服务之间的通讯技术主要包括2方面Internal和Ingress Internal Container 和Container 之间的访问通过overlay网络，而service和service之间的通讯是通过VIP（虚拟IP）实现的。
主要意义是Internal Load Balancing 实现
下面是对Internal的小实验
*ps. 提前整理一个后面要用到的小命令【nslookup】它用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题。
但是一些linux系统下默认无此命令，可以通过安装一个包来使该命令生效,这个包中也包括dig命令。
yum -y install bind-utils 例如：
nslookup mp.csdn.net 查询网站的dns name 以及后面对应的ip地址
返回：
Service：100.100.2.136 (dns名)
Name: mp.csdn.net
Address : 101.201.178.55 (虚拟ip)
nslookup tasks.mp.csdn.net 可以看到背后容器真正的IP地址
步骤解析Internal Load Balancing：
创建overlay的network
docker network create -d overlay demo-net 创建一个service， 使用whoami，可返回当前访问的主机名称
docker service create --name whoami -p 8000:8000 --network demo-net jwilder/whoami 拓展whoami服务为3个
docker service scale whoami=5 在不同容器里nslookup whoami 显示的是同一个ip地址，而在每个容器里 ip a 可分别看到每个eth0 和nslookup whoami 出的 Address都类似但是不一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b24c05e9f0e8b4ea8ab8c6244bf2f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9578a1c788f5848720fb0b7ac137f0/" rel="bookmark">
			c&#43;&#43;使用libcurl库 调用get请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容提要 1. 安装libcurl库
2. 使用libcurl需要的编译参数
3. get请求
4. 参考链接
一、 安装libcurl库
download address: https://curl.haxx.se/download/ 或者 wget https://curl.haxx.se/download/curl-7.64.1.tar.gz 到下载目录, 解压, 进入curl文件夹 执行以下命令 ./configure make sudo make install 二、 使用libcurl时需要的编译参数
例如当前文件为main.cpp 编译: g++ main.cpp -lcurl 三、 get请求
函数原型
/*** * buffer 接收数据所在的缓冲区 * size	要读取的字节数 * count	读写size长度的数据count次 * user_ptr	用户自定义文件指针 */ size_t getUrlResponse(void *buffer, size_t size, size_t count, void *user_ptr); // 在这里用作回调函数 /*** * url 请求网址 */ std::string get(const std::string&amp; url); // 传入url执行get请求 参数介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9578a1c788f5848720fb0b7ac137f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5196b97e5ba05c8e67ce7952dc6391b2/" rel="bookmark">
			mybatis  generator  生成中文字段注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，试了好几次，重写 DefaultCommentGenerator ，创建MyCommentGenerator类实现CommentGenerator接口，都是按照网上的方案来的，执行也没问题，但是就是没有实体生成，然后又看到说可以直接改jar包的方法，那么我就下手改了，
首先说一下我引的包，引入了一个plugin插件，且内部引入了generator 核心包和 mysql驱动包
&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 然后看一下我的 generatorConfig.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name="javaFileEncoding" value="UTF-8" /&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter" /&gt; &lt;!-- JavaBean 实现 序列化 接口 --&gt; &lt;plugin type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5196b97e5ba05c8e67ce7952dc6391b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d3c1c5bfae35f996282779bef15879/" rel="bookmark">
			Codeforces Round #576 (Div. 1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比赛链接：Codeforces Round #576 (Div. 1)
A. MP3
题意：n个声音要压缩在Ibyte中，压缩规则是：所需空间，其中K为不同声音的个数，你可以选择一个声音的上下边界并将边界外的删掉，问你最少删掉多少个声音可以压缩在Ibyte中。（注意：1byte=8bits）
分析：可以通过I求的k的最大值，离散化后做一个前缀和，扫一遍；（小心爆long long）
#include&lt;bits/stdc++.h&gt; #define pb push_back using namespace std; typedef long long ll; const int maxn=4e5+7; const int mod=1e9+7; const ll INF=1e18; int a[maxn]; map&lt;int,int&gt; mp; int pre[maxn]; int rua() { int n,I;scanf("%d%d",&amp;n,&amp;I); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),mp[a[i]]++; sort(a+1,a+1+n); int sz=unique(a+1,a+n+1)-(a+1); for(int i=1;i&lt;=sz;i++) pre[i]=pre[i-1]+mp[a[i]]; int tmp=8*I/n; if(tmp&gt;31) tmp=31; ll len=1ll&lt;&lt;tmp; if(len&gt;=1ll*sz) return 0; int ans=0; for(int i=len;i&lt;=sz;i++) ans=max(ans,pre[i]-pre[i-len]); return n-ans; } int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80d3c1c5bfae35f996282779bef15879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec66c2166ba4a9139d2a0077c5878df9/" rel="bookmark">
			图像梯度(Image  Gradient)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图像梯度的定义（离散）图像梯度理解 图像梯度的定义（离散） 对于一个二元函数 F ( x , y ) F(x,y) F(x,y)来说，其偏导数的定义为：
δ F ( x , y ) δ x = lim ⁡ ϵ → 0 F ( x + ϵ , y ) − F ( x , y ) ϵ \frac {\delta F(x,y)}{\delta x}=\displaystyle \lim_{\epsilon \rightarrow 0}\frac {F(x+\epsilon,y)-F(x,y)}{\epsilon} δxδF(x,y)​=ϵ→0lim​ϵF(x+ϵ,y)−F(x,y)​
这是沿着x方向的定义。这种定义适用于连续函数，而图像是二维的离散函数， ϵ \epsilon ϵ不能无限趋近于0，最小只能是1个像素，因此我们使用有限差分来近似计算梯度。上面的公式变为：
X : δ F ( x , y ) δ x ≈ F ( x + 1 , y ) − F ( x , y ) 1 X:\frac {\delta F(x,y)}{\delta x}\approx\frac {F(x+1,y)-F(x,y)}{1} X:δxδF(x,y)​≈1F(x+1,y)−F(x,y)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec66c2166ba4a9139d2a0077c5878df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/accae7d2b021376b78596dee1a190f8d/" rel="bookmark">
			最全 Linux 磁盘管理基础知识全汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、存储设备的挂载和卸载
存储设备的挂载和卸载常用操作命令：fdisk -l、df、du、mount、umount。
fdisk -l 命令
1.作用
查看所有硬盘的分区信息,包括没有挂上的分区和USB设备，挂载时需要用这条命令来查看分区或USB设备的名称，比如挂载U盘时。
注意：Linux中既然硬件是以文件形式存在，则也可以ls -l /dev/sda*查看第一块硬盘的分区信息
df 命令
1.作用
统计磁盘空间或文件系统使用情况，显示磁盘分区上的可使用的磁盘空间，默认显示单位为KB
2.格式
df [option]
3.[option]主要参数
-a或-all：显示全部的文件系统
-h或--human-readable：以可读性较高的方式来显示信息
-T或--print-type：显示文件系统的类型
4.应用举例
查看全部文件系统：
#df -a
du 命令
1.作用
查看文件或目录的磁盘使用的空间，和df命令有一些区别。注意：①du后若不加目录名或文件名，表示只显示当前目录下面的子目录的目录大小和当前目录的总的大小②可查看多个文件或目录用空格符隔开
2.格式
du [option] 目录名或文件名
3.[option]主要参数
-a或-all：显示目录中个别文件的大小
-h或--human-readable：以K，M，G为单位显示，提高信息可读性
-S或--separate-dirs：省略指定目录下的子目录，只显示该目录的总和（注意：该命令是大写S）
4.应用举例
以易读形式查看ahao目录的大小并忽略子目录：
#du -h -S ahao
以易读形式查看haha1文件和haha2文件的大小：
#du -h haha1 haha2
mount 命令
1.作用
①此命令后面不加任何参数表示查看已挂载的所有文件系统
②加参数表示将存储设备挂载到Linux的一个目录下，从而将分区和该目录联系起来，因此我们只要访问这个目录，就相当于访问该存储设备了。
注意：当一个目录之前有文件，设备挂载到这个目录后，目录不显示之前的文件
2.格式
mount [option] 设备名挂载点(必须已存在)
3.[option]主要参数
-t&lt;文件系统类型&gt;:文件系统类型vfat表示FAT32，iso9660表示光盘或光盘镜像，auto表示系统自动识别(一般选这个方便吧)
4.应用举例
将FAT32文件系统的分区/dev/sda5挂载到/ahao目录下：
#mount -t auto /dev/sda5 /ahao
将U盘/dev/sdb1挂载到/ahao目录下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/accae7d2b021376b78596dee1a190f8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9ee4521363c67c1c35a48d974c0225/" rel="bookmark">
			Ubuntu18.04 向日葵软件被远程显示停止连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux重启之后向日葵连接不上，查看log时候显示和屏幕组件有关，获取不到屏幕组件
在 /var/log/sunlogin里面的desktop.log.XX里面显示
2020-02-19 10:28:29.738 - Info - version:10.0.2.24779
2020-02-19 10:28:29.738 - Info - Plugin desktop is starting...
2020-02-19 10:28:29.738 - Info - attempt to connect server 127.0.0.1:37691(127.0.0.1:37691)
2020-02-19 10:28:29.739 - Info - cmd:initialization date:{
"blackscreen" : false,
"enablerecord" : false,
"exitlock" : false,
"index" : 2,
"mode" : 2,
"path" : "",
"save_record_type" : "0"
}
//这里显示获取不到屏幕组件
2020-02-19 10:28:29.739 - Info - cmd:InitInstance date:
2020-02-19 10:28:29.739 * Error * xdu_get: XOpenDisplay :0 failed
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a9ee4521363c67c1c35a48d974c0225/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/396/">«</a>
	<span class="pagination__item pagination__item--current">397/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/398/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>