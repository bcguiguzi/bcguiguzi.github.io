<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d483de09409b4392c5ee70542204e78e/" rel="bookmark">
			SQL的关系模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主键 选取主键的一个基本原则是：不使用任何业务相关的字段作为主键 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。
作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。
常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，
会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。
联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键
对于联合主键，允许一列有重复，只要不是所有主键列都重复即可
没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升
外键 可以把数据与另一张表关联起来，这种列称为外键 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。
由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性 要删除一个外键约束，也是通过ALTER TABLE实现的：
ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN …实现的
还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度
索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引
索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。
通过使用索引，可以让数据库系统不必扫描整个表，
而是直接定位到符合条件的记录，这样就大大加快了查询速度。
索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。
反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。
可以对一张表创建多个索引。索引的优点是提高了查询效率，
缺点是在插入、更新和删除记录时，需要同时修改索引，
因此，索引越多，插入、更新和删除记录的速度就越慢。
对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0f47e34fd46b81649242629747cd85/" rel="bookmark">
			Java中的四种引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Java中四种引用类型：强软弱虚 面试：强引用和弱引用的区别？
1.1 强引用 普通变量赋值即为强引用，如 A a = new A();
强引用的回收特点：
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收。
如果想中断或者回收强引用对象可以显式地将引用赋值为null(a=null)，这样的话JVM就会在合适的时间，进行垃圾回收。
1.2. 软引用（SoftReference） “内存不够就回收，内存充足不回收”
“适合做缓存”
1、例如：SoftReference a = new SoftReference(new A());引用和对象通过SoftReference建立关联
2、当系统内存够用就保留不回收（及时发生了GC），内存不足时，会被回收
3、软引用自身不会被垃圾回收，因为GC Root还引用着，软引用自身需要配合引用队列来释放。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
4、软引用适合缓存使用的场景，当内存不够的时候，对象是被回收的。
1.3. SoftReference实现Cache(例子) SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。
实例：软引用在设备内存比较少的时候特别有用，比如Android系统。
一个android应用如果设计到通过网络获取图片，为了让系统更快的运行和更节省流量我们可以将已经下载下来的图片在内存中缓存起来，当第二次浏览到该图片时就可以从缓存中拿，如果没有再去加载下载的文件。
安卓里面，listView里面存一张图片和一些文字描述，这些图片要去网络上加载解析渲染后放到内存，非常消耗内存。
问题：
1、 如果每次读取图片都从硬盘读取则会严重影响性能
2、 如果一次性全部加载到内存中又可能造成内存溢出
此时使用软引用可以解决这个问题。
设计思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题
JSONRuslt [ { ‘image’:’http://qiniu/222.jpg’, ‘name’:’Iphone13’, ‘price’: 22323 } ] List&lt;Product&gt; list; Android里面控件：ListView展示列表 public class ImageLoader { //强引用，内存不足时候，里面的Bitmap也不会销毁 private Map&lt;String, Bitmap&gt; cacheImage = new HashMap&lt;String, Bitmap&gt;(); //弱引用：内存不足会销毁，下次找不到Bitmap就去硬盘找 private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cacheImage = new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;(); public void loadImage(final String path,final Callback callback){ SoftReference&lt;Bitmap&gt; softReference = cacheImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0f47e34fd46b81649242629747cd85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af021515bdd0ebe57d9d7da56d39efa0/" rel="bookmark">
			视频合并工具有哪些？不如试试这四个好用的软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频合并工具有哪些？视频合并毫无疑问就是将几段分散的视频合并到一起，可以说我们在剪辑视频的时候必须要进行视频合并。其实视频合并十分简单，但是有些小伙伴们可能不知道有哪些好用的工具，导致每次合并的时候都十分耽误时间。下面小编就来给大家分享几款合并视频的工具。
一、手机端
1、手机相册
我们使用手机录制的视频保存在手机相册中，点击选中需要合并的视频，点击下方的“创作”-“视频剪辑”选项。进入到视频剪辑的页面，我们可以看到两个视频已经合并在一起了。这个时候我们可以裁剪视频片段以及进行添加字幕、滤镜、背景音乐等操作。编辑完成之后，点击保存即可。
2、清爽视频编辑
点击打开软件，在软件的首页点击“工具”选项，找到“视频合并”的选项，接下来点击添加需要合并的视频片段。添加完成之后，可以对视频进行切换转场、添加图片、添加视频、添加文字等操作。编辑好之后，点击“导出”即可完成。
二、电脑端
1、迅捷视频转换器
点击打开软件，在软件的首页找到“视频合并”的功能选项，选择好之后，点击上传需要合并的视频文件（可直接上传文件夹）。上传好文件之后，如果有文件需要进行处理，我们可以点击“视频处理”选项，对视频进行裁剪、滤镜和字幕等的处理。处理完成之后，点击“开始合并”即可完成。
2、pr 相信大家都知道这个视频剪辑软件，新建一个项目并导入需要合并的视频。然后将几段视频均拖动到时间轴面板上，对视频进行裁剪等操作，同时在视频的衔接部分，添加转场。操作完成之后，我们点击导出即可。
以上就是小编给大家分享的几个视频合并的工具，总的来说无论是电脑还是手机都是可以完成我们的视频合并操作的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff426638b7d27af7e5df4c2e243460d/" rel="bookmark">
			用opencv-python实现能线性调整的模糊、锐化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的手机图库中，模糊和锐化是必不可少的两个功能。
然而，各位应该都有注意到：在opencv中，锐化和模糊的主要参数都是卷积核半径，且必须为奇数；但是在使用图库软件时，大部分时候只需要拖动一个滑动条。或许“滑动条”的说法不够明显，更直观的说法是：图库软件的模糊和锐化只需要一个浮点数做参数。
显然，图库软件的开发者不可能重复造轮子，他们用的模糊和锐化，底层必然和opencv相似。本文讲的就是如何在opencv中实现这样一个以浮点数控制操作力度的锐化或模糊。本文的思路也适用于其他卷积操作，如USM。
连续与不连续 卷积核半径是不连续的，而操作力度是连续的。
也就是说，虽然我们可以建立这样一个映射，但是非整数的操作力度并不直接对应任意一个卷积核卷积的结果。
操作力度卷积核半径132537 我想到的解决方法是：线性混合。按比例混合两个卷积核卷积的结果，就能表示小数的操作力度。
实现 首先将线性混合封装成函数
def gen_kparams(degree): # 根据参数“degree”生成两个内核半径和它们的混合比例 assert degree&gt;0 deg_head = math.ceil(degree) deg_tail = degree+1-deg_head ksize_large = deg_head*2+1 ksize_small = ksize_large-2 large_ratio = deg_tail small_ratio = 1-large_ratio return ksize_large, large_ratio, ksize_small, small_ratio def get_filtered(img, filter_func, degree): # 根据生成的参数处理图片并混合 ksize_large, large_ratio, ksize_small, small_ratio = gen_kparams(degree) large = filter_func(img, ksize_large) small = filter_func(img, ksize_small) ret = cv2.addWeighted(large, large_ratio, small, small_ratio, 0) return ret 然后加入具体的操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff426638b7d27af7e5df4c2e243460d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8002e49c1d63612f2757694706a712/" rel="bookmark">
			Modelsim 10.7安装遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载modelsim安装后，用crack破解失败显示找不到mgls.dll，运行破解所用的patch_dll.bat成功并生成license，之后系统变量设置也米问题，直到
点击modelsim图标时弹出了这个！！！
网上一堆方法用了也没有解决，最后找到一个方法，瞎搞一通给解决了，记录一下方法，免得忘记。
编辑patch_dll.bat文件，添加标红两条语句
@echo off
attrib -r mgls.dll
attrib -r mgls64.dll
MentorKG.exe -patch . attrib +r mgls.dll
attrib +r mgls64.dll
同时将mgls.dll命名改成mgls64.dll，推测我的问题是按64位破解的，但是mgls.dll文件名没有加“64”所以找不到（crack破解失败估计也是这个原因）。
-------------------------------
下面是原博主的链接，大家可以参考着看看。希望可以帮到大家
原文链接：https://blog.csdn.net/qq_39254662/article/details/109552319
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ae8c675eeeb95c39ecc1e4ba9fb522/" rel="bookmark">
			uniapp 固定首行和固定列的表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 在uniapp应用中新建一个页面；
css部分用到了sass，开发工具是HbuilderX的话安装sass插件即可。
效果 第一个一个表格是默认样式用作对照，第二个表格是固定了末尾两列和首行的自定义样式表格。
效果截图
代码 &lt;template&gt; &lt;view&gt; &lt;view class="table-box"&gt; &lt;table cellspacing="0px" cellpadding="0px"&gt; &lt;thead&gt; &lt;tr class="table-new-line" &gt; &lt;th&gt;第一项&lt;/th&gt; &lt;th&gt;第二项&lt;/th&gt; &lt;th&gt;第三项&lt;/th&gt; &lt;th&gt;第四项&lt;/th&gt; &lt;th&gt;第五项&lt;/th&gt; &lt;th&gt;第六项&lt;/th&gt; &lt;th class="hold2 zd"&gt; 固定2 &lt;/th&gt; &lt;th class="hold1 zd"&gt; 固定1 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class="table-new-line" v-for="(item, index) in 10" :key="index"&gt;	&lt;td&gt;第一项&lt;/td&gt; &lt;td&gt;第二项 &lt;checkbox style="transform:scale(0.8)" :checked="true" /&gt; &lt;/td&gt; &lt;td&gt;第三项&lt;/td&gt; &lt;td&gt;第四项&lt;/td&gt; &lt;td&gt;第五项&lt;/td&gt; &lt;td&gt;第六项&lt;/td&gt; &lt;td class="hold2"&gt; &lt;checkbox style="transform:scale(0.8)" :checked="true" /&gt; &lt;/td&gt; &lt;td class="hold1"&gt; &lt;button class="table-button"&gt; 按钮 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1ae8c675eeeb95c39ecc1e4ba9fb522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c660e51f3f08d1e2d9314af3b917c6/" rel="bookmark">
			通信原理笔记（樊昌信第七版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 通信系统模型 一般通信系统模型包含5个环节：信源、发送设备、信道、接收设备、信宿。如下图所示。
信源：信息源，将各种消息转换成原始电信号。例如将电话机话筒的声音信号转换成音频电信号。
发送设备：将电信号通过编码、调制，转换成能在信道中传输的信号（例如电磁波信号）
信道：能传输信号的各种物理媒介，例如空气。
接收设备：功能与发送设备相反，进行解调、译码。
信宿：将电信号还原成消息，例如扬声器将电信号转换成声音信号
2 信道 信道是通信系统中的关键环节，设备之间连接的桥梁。信道根据传输媒介分为无线信道和有线信道。无线信道包括电磁波这种，例如目前5G基站和手机之间的通信是电磁波；有线信道包括光纤这种，例如承载网里的波分产品和分组产品通过光纤传输。
2.1 无线信道 无线信道利用电磁波进行传输，根据传输频率和通信距离，电磁波传输分为地波、天波和视波三种方式。
地波传输的频率较低，所以波长大，绕射能力强，可沿着弯曲的地球表面传播。如下图所示。
天波的频率较高（大约2M-30M），能够被大气层中的电离层反射，如下图所示。
视波传输的频率很高，这是目前主要的应用方式，像5G基站的传输方式就是视波传输。视波的频率高，绕射能力较小，所以只能作为直线视线传播，如下图所示。
从上图可知视波传输距离是与天线高度有关的，天线位置越高，能够直线传输的距离越远，所以我们日常看到的基站都是在很高的铁塔上。
上图中r为地球半径，h为天线高度，s为传播距离。
2.2.1 视波 视波在三者中目前应用最广泛。相对于地波和天波传输，视波的传输距离小得多，为了实现远距离传输，一般会进行视距扩展，常用方法有：无线电中继、卫星中继和平流层通信。
无线电中继通信即每间隔一定距离（一般为一个视距）放置一个中继站，将信号进行转发一起，经过多个中继站的信号转发实现远距离通信，这类似现在玩的击鼓传花游戏，一个接一个传递下去。
卫星中继是利用人造卫星传递信号。卫星的位置很高，卫星与发射接收设备之间可看做直线，发射设备将信号传输给卫星，卫星再将信号传输给接收设备。如下图所示。
上图就是三卫星系统实现全覆盖，但这种方式有个缺点，卫星与发射接收设备之间距离较远，导致传输信号的时延较大。
平流台通信是对卫星通信的改善，将转发站挂载在大气球或者飞艇上面，大大减少中间的传输距离，减少时延。不过这种方式目前应用就少，原因可能是飞艇在平流层不太稳定。
目前的民用无线电通信主要采用的是蜂窝煤通信和卫星通信。
2.3 有线信道 有线信道利用光纤、电缆、明线等媒介传输信号，目前使用最多的是光纤。
明线是早期的通信方式。双轴对称电缆，也即双绞线，常见于早期的电话线。
上面两种通信方式的特点是传输距离短，易受到干扰。看谍战剧时会经常看到这种电话被窃听的场景。之后出现了同轴电缆，同轴电缆传输距离更远，抗干扰能力更强，速率也较快，现在的应用也很广泛，多用于有线电视的通信。
但同轴电缆由于结构的原因，造价成本很高。光纤的出现解决了这个问题，光纤通信相对成本低，抗干扰能力强，传输距离远，带宽和通信容量大。像现在海底光缆用的就是光纤技术。光纤传输是目前应用最广泛的有线传输方式，目前通信设备承载网的产品基本都采用光纤传输。光纤传输图如下图所示。
3 调制与解调 调制是把有用信号搭载到载波上。解调是调制的逆过程，从已调信号中回复消息信号。载波是一种高频周期震荡信号，例如正弦波。需要传输的信号称为调制信号。调制与解调的过程好比是货物运输过程，调制就是把货物装上货车，货车运送到目的地后，解调就是把货物从货车上卸载下来。
调制与解调的数学模型如下图所示。
最终的输出信号里包含有用信号和噪声，信噪比（输出信号中有用信号平均功率和噪声平均功率之比）是衡量调制解调器的一个重要指标。
4 模拟调制系统 需要传输的信号称为调制信号，根据调制信号是模拟信号还是数字信号，分为模拟调制系统和数字调制系统。
对于目前的通信系统来说模拟调制系统已经很少，1G时代大量应用模拟调制系统，2G以后主要采用数字调制系统。
模拟调制系统最常用的调制方式是以正弦波作为载波的幅度调制和角度调制。
4.1 幅度调制 幅度调制是用调制信号去调制高频载波信号的幅度。下图为常规条幅AM调制信号、载波、已调信号的波形。
已调信号和载波信号的频率是相同的，幅度有了较大变化，幅度包含调制信号的特征信息。
常见的幅度调制有常规条幅AM、双边带调制DSB、单边带调制SSB等调制方式。其中AM优势在于接收机简单，广泛用于广播。
调幅调制的综合数学模型如下图所示。
s(t)为调制信号，coswt为载波信号，二者相乘，h(t)为滤波器，r(t)为已调信号。
4.2 解调 关于幅调的解调方式有两种：包络检波和相干检波。
相干解调时,为了无失真地恢复原基带信号,接收端必须提供一个与接收的已调载波严格同步(同频同相)的本地载波(称为相干载波),它与接收的已调信号相乘后,经低通滤波器取出低频分量,即可得到原始的基带调制信号。实现相干解调的关键是接收端要提供一个与载波信号严格同步的相干载波。否则,相干解调后将会使原始基带信号减弱,甚至带来严重失真,这在传输数字信号时尤为严重。
包络解调是将已调信号整流后再经过低通滤波器，检测幅值大小，即外包络大小。
4.3 角度调制 正弦载波有三个参量：幅度、频率和相位。我们不仅可以把调制信号的信息载荷于载波的幅度变化中，还可以载荷于载波的频率或相位变化中。在调制时，若载波的频率随调制信号变化，称为频率调制或调频(FM)；若载波的相位随调制信号而变称为相位调制或调相(PM)。
在这两种调制过程中，载波的幅度都保持恒定不变，而频率和相位的变化都表现为载波瞬时相位的变化，故把调频和调相统称为角度调制。
角度调制的抗噪声性能优于幅度调制。其中FM应用较为广泛，像英语四六级考试收音耳机就是FM调制方式。
调频的方法主要有两种：直接调频和间接调频。
调频就是用调制信号控制载波的频率变化。直接调频就是用调制信号直接去控制载波振荡器的频率,使其按调制信号的规律线性地变化。如下图为FM调频调制信号和载波信号的波形图。
图中m(t)为调制信号，S(t)为已调信号。载波的频率大小包含调制信号的特征信息。
4.4 模拟调制系统综述 相对于数字调制系统，模拟调制系统目前应用场景较少，主要应用在一些广播收音机上。模拟调制系统主要有AM、DSB、SSB、VSB、FM、PM等几种调制方式，具选用哪种调制方式时参考以下几个参数：抗噪声性能、频谱利用率、功率利用率、设备简便性等。一般来说没有哪种调制方式能够同时满足这些参数要求，根据实际使用场景综合考虑选用其中一种调制方式。
5 信号多路复用技术 当一条物理信道的传输能力高于一路信号的需求时,该信道就可以被多路信号共享，例如电话系统的干线通常有数千路信号在一根光纤中传输。复用就是解决如何利用一条信道同时传输多路信号的技术。其目的是为了充分利用信道的频带或时间资源,提高信道的利用率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c660e51f3f08d1e2d9314af3b917c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb88b9d781bb708d5c5bc51a85692bc/" rel="bookmark">
			LeetCode1652. 拆炸弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：1652. 拆炸弹 - 力扣（LeetCode）
题目描述看的不是很清楚，直接看用例。这道题是简单题，取模，防止数组访问越界。
C语言代码如下：
int* decrypt(int* code, int codeSize, int k, int* returnSize) { *returnSize = codeSize; int * ans = (int *)calloc(codeSize, sizeof(int)); if (k == 0) { return ans; } else if (k &lt; 0) { for (int i = 0; i &lt; codeSize; i++) { for (int j = 1; j &lt;= -k; j++) { ans[i] += code[(i - j + codeSize) % codeSize]; } } } else { for (int i = 0; i &lt; codeSize; i++) { for (int j = 1; j &lt;= k; j++) { ans[i] += code[(i + j) % codeSize]; } } } return ans; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d7b76fefbf46d702e6c4744d04bcbe/" rel="bookmark">
			win10安装ubuntu18.04双系统，创建EFI分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 进入windows磁盘管理器，对想要安装ubuntu系统的磁盘进行压缩卷，分配ubuntu系统空间；
2. 若一个磁盘空间不够，需要多个磁盘同时压缩卷后再合并压缩出来的空间。此时，只有相邻磁盘可以通过扩展卷进行合并，非相邻空间合并，需要删除中间的磁盘；
3. 若EFI磁盘被删除后，需要重新创建windows的EFI分区；
3.1 制作和windows相同系统的U盘启动盘(小白一键重装系统)；
3.2 设置U盘启动；
3.3 进入U盘制作的windows系统后，启动命令行模式(cmd)；
3.4 命令行操作步骤：
X:\Users\Default&gt; diskpart //运行diskpart工具 DISKPART&gt; list disk	//显示磁盘情况 DISKPART&gt; select disk 0	//选择要安装EFI的磁盘 DISKPART&gt; list partition	//显示分区情况 DISKPART&gt; create partition efi size=190	//创建EFI分区大小为190MB DISKPART&gt; list partition //显示分区情况 DISKPART&gt; format quick fs = fat32 //快速格式化分区为fat32格式 DISKPART&gt; exit X:\Users\Default&gt; bcdboot C:\\Windows //将引导文件从Windows分区复制到EFI系统分区 3.4.1 相关操作截图如下：
4. 安装ubuntu双系统，创建ubuntu分区，只需要分配两个必要分区就可以
4.1 创建ubuntu的EFI分区，用于ubuntu启动 Size 512 MB Type for the new partition: Logical Location for the new partition: Beginning of this space Use as: EFI System Partition 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d7b76fefbf46d702e6c4744d04bcbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e44a70e17337cefc284020afe63986/" rel="bookmark">
			CS143 环境搭建全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程网站：这里和这里
edX上也开设了这门课：这里
2022.9.24 更新：添加了直接在Linux上配置的步骤
在Linux上配置环境 老师提供的环境比较简陋，因此我从PA3开始在自己配置的Linux上做作业。
我的用是Ubuntu22.04，其他Debian系的系统应该都可以的。
首先打开命令行，输入：
$ sudo apt-get install flex bison build-essential csh openjdk-6-jdk libxaw7-dev 如果你用C++做作业可以去掉openjdk-6-jdk。
接着创建文件夹：
$ sudo mkdir /usr/class 其他目录创建也完全没有问题，只要一会儿配置环境变量时相应地修改一下位置就可以了。
输入：
$ sudo chown $USER /usr/class $ cd /usr/class $ wget https://courses.edx.org/asset-v1:StanfordOnline+SOE.YCSCS1+1T2020+type@asset+block@student-dist.tar.gz 解压：
$ tar -xf student-dist.tar.gz 配置环境变量：
$ export PATH=$PATH:/usr/class/bin 如果你不是在usr/class下解压的文件，需要根据你自己的路径配置。
课程上没说，但你还需要输入以下命令：
$ sudo apt-get install libc6-i386 由于我已经做完了PA2，所以我不用配置flex了，至此配置完成。
如果你要做PA2的话，还需要安装旧版本flex，因为上面的命令会安装最新版的flex导致不兼容，对于此，你可以去这里。
直接使用课程提供的环境 安装Virtual Box 网址：https://www.virtualbox.org/wiki/Downloads
安装步骤中没有什么特别要说的点，网上的安装教程也有很多了。
安装VM镜像 下载 这个镜像可以在edX上找到，但是似乎要花钱升级课程后才能下载：
通过一番查找，我发现在B站上有人已经分享了这个文件，下面是链接，将链接中的vbox文件夹整体下载即可。
链接：https://pan.baidu.com/s/1DcEyrQyBIzbZ1577RTUA_Q
提取码：xobv
配置 在Virtual Box的注册中找到上面下载的Complier.vbox并添加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e44a70e17337cefc284020afe63986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2cf274745852a035906e951faa8c46d/" rel="bookmark">
			局域网内Windows服务器远程桌面连接失败是什么原因呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先通过显示器直接连接的方式连接到那台连接出错的服务器上。登陆以后，在桌面上的此电脑图标上面点右键，选择属性。然后在属性页面中我们可以看到对应的系统版本是Windows Server 2012。这个时候我们点击它左上角的远程设置。
2、在远程设置界面，我们可以看到，它默认的设置是允许远程到这台服务器上，但是它下面勾选了”仅允许运行使用网络级别身份验证的远程桌面的计算机连接“。
3、如果不是公网服务器的话，这个选项可以去掉
4、去掉以后，我们回到个人PC上，打开远程桌面连接。
5、输入那台server2012服务器的ip，然后点击连接，再输入账号密码，这个时候就没有弹出身份验证错误的提示了，这个时候弹出来的是证书错误的提示，这个就是对应的安全级别不对应的原因。但是我们点是就可以跳过这个提示，然后就可以顺利登陆了。
7、登陆成功连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87430d1dbdacadc72d66b0d0b48fe96a/" rel="bookmark">
			Th3.8：基类和子类指针、虚函数和纯虚函数、多态性详述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客将记录：类的相关知识点的第8节的笔记！
（这个在学习C++基础课程时已经学习过一次了，这里再次简单地回顾一下而已）
今天总结的知识分为以下5个点：
一、基类（父类）指针、派生类（子类）指针
二、虚函数（并补充：override 和 final关键字）
三、多态性
四、纯虚函数 五、多态基类的析构函数一般写成虚函数（虚析构函数） very Important ！！！
这个第五点其实就算：为多态基类声明virtual析构函数。（From Effective C++ Term 07）
一、基类（父类）指针、派生类（子类）指针：
我们平时创建对象时，不只是可以创建对应的对象实体，还可以在堆区创建指向该对象的指针。
请看以下代码：（仍然以3.7小节中我所写的Human类和Man类作为我举代码的例子）
Human* phuman = new Human();//调用Human类的无参构造函数创建父类指针 Man* pman = new Man();//调用Man类的无参构造函数创建子类指针 （当然,由于Man继承自Human,因此会先调用Human类的构造函数创建子类对象中的父类成分，再调用子类的构造函数创建子类对象中的子类成分！） 运行结果：
下面，我将介绍一种新的"玩法"，叫做多态。
多态：用父类指针new一个子类的对象。
请看以下代码：
Human* p = new Man();//父类指针可以指向子类对象 /*Man* pp = new Human;*/ //子类指针无法指向父类的对象 当父类指针new一个子类对象时，有2个注意事项：
①类的多态性是在继承性的基础上去do事情的！
（你首先得do个继承的操作对吧？不然你没有继承的话何来父类指针？又何来的子类对象呢对吧？学习的时候多问问为什么？多钻研一些小细节，学习C++这种细节知识点非常非常多的主流语言时更要如此。）
②该父类指针可以调用父类的成员函数，不可以调用子类的成员函数
（既然你父类指针没办法访问到子类的成员函数，那你为什么还要让父类的指针去new一个子类的对象呢？这有啥用呢？不要着急！对于这个问题的解答将在下面虚函数的讲解中一一解开哈！）
（因为你是父类的指针而不是子类的指针）
//在Human父类中添加成员函数funcHuman() void funcHuman() { cout &lt;&lt; "this is funcHuman()函数的调用！" &lt;&lt; endl; } //在Man子类中添加成员函数funcMan() void funcMan() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87430d1dbdacadc72d66b0d0b48fe96a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac2ec460c8fc163278db7bf8e7a7ada/" rel="bookmark">
			Arraylist、LinkedList和Vector三者区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arraylist、LinkedList和Vector三者关系与区别 一、简介ArrayList 简介LinkedList 简介Vector 简介 二、区别ArrayList 与 LinkedList 区别双向链表 和 双向循环链表 ArrayList 和 Vector 的区别 总结 一、简介 ArrayList 简介 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 LinkedList 简介 继承于AbstractSequentialList的双向链表。它也可以被当做堆栈、队列或双端队列进行使用。实现List接口，能让它进行队列操作。实现Deque接口，即能将LinkedList当做双端队列使用。实现Cloneable，即覆盖了函数clone()，能被克隆。实现了java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。操作不是线程安全的。 Vector 简介 Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。和ArrayList不同，Vector中的操作是线程安全的 二、区别 ArrayList 与 LinkedList 区别 其实ArrayList和LinkedList之间的区别就是数组和双向链表之间的区别,主要分为以下几点：
是否保证线程安全 ： ArrayList 和 LinkedList 都是不同步的, 也就是他们都不保证线程安全 底层数据结构： Arraylist 底层使用的是 Object 数组LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环，下文有简单介绍） 插入和删除是否受元素位置影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响
例如：add(E e)方法的时候，ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话 add(int index, E element )时间复杂度就为 O(n-i)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac2ec460c8fc163278db7bf8e7a7ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cf3f840e9a9146f1acf31d4eeea5f5/" rel="bookmark">
			java如何给数组初始化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于java数组的文章早已是非常多了，本文是对我个人过往学习java，理解及应用java数组的一个总结。此文内容涉及java数组的基本概念，以及java如何给数组初始化?初始化的几种方式?希望对大家有所帮助。
java如何给数组初始化?
Java语言中数组必须先初始化，然后才可以使用。所谓初始化就是为数组的数组元素分配内存空间，并为每个数组元素附初始值。
注意：数组完成初始化后，内存空间中针对该数组的各个元素就有个一个默认值：
基本数据类型的整数类型(byte、short、int、long)默认值是0;
基本数据类型的浮点类型(float、double)默认值是0.0;
基本数据类型的字符类型(char)默认值是'\u0000';
基本数据类型的布尔类型(boolean)默认值是false;
类型的引用类型(类、数组、接口、String)默认值是null.
初始化方式：
一.静态初始化：初始化时由程序员显式指定每个数组元素的初始值，有系统决定数组的长度;
1.arrayName = new type[]{element1,element2,element3...}
2.简化的静态初始化方式 type[] arrayName = {element1,element2,element3...};
二.动态初始化：初始化时由程序员指定数组的长度，由系统初始化每个数组元素的默认值。
arrayName = new type[length];
示例：
注意：不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。
一旦数组完成初始化，数组在内存中所占的空间将被固定下来，所以数组的长度将不可改变。
这里我免费分享一份GitHub 上标星 120k的《Java核心进阶知识全面解析》给大家看看，不论是用于巩固基础，还是用于技术提升都可以收藏一份，看完学透，面试大厂so easy。
下面展示部分截图，文末附免费下载方式。 (一). 基础 1、Java 基本功
Java 入门(基础概念与常识)Java 语法基本数据类型方法(函数) 2、Java 面向对象
类和对象面向对象三大特征修饰符接口和抽象类其它重要知识点 3、Java 核心技术
集合异常多线程文件与 I\O 流 (二). 并发 1、并发容器
JDK 提供的并发容器总结ConcurrentHashMapCopyOnWriteArrayListConcurrentLinkedQueueBlockingQueueConcurrentSkipListMap 2、线程池
使用线程池的好处Executor 框架(重要)ThreadPoolExecutor 类简单介绍(重要)ThreadPoolExecutor 使用示例几种常见的线程池详解ScheduledThreadPoolExecutor 详解线程池大小确定 3、乐观锁与悲观锁
何谓悲观锁与乐观锁乐观锁常见的两种实现方式乐观锁的缺点CAS与synchronized的使用情景 (三). JVM 1、Java内存区域
概述运行时数据区域HotSpot 虚拟机对象探秘重点补充内容 2、JVM垃圾回收
揭开 JVM 内存分配与回收的神秘面纱对象已经死亡?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29cf3f840e9a9146f1acf31d4eeea5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481fb1ad25201b77a4e2da449281722b/" rel="bookmark">
			麒麟服务器漏洞扫描提示端口：9090/tcp/www 不信任的证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 国产服务器漏洞扫描报中危，但是9090端口应用没有使用，tongweb也没有使用。
后来发现是麒麟自带一个管理系统COCKPIT，https://ip:9090.
厂家确认：
服务器系统，9090端口是 cockpit 相关的，如果不想出现，可以关闭 cockpit 相关的两个服务。
如果想体验，可以在浏览器输入 https://ip:9090 使用系统账户和密码登录，会显示系统自身的一些性能和信息。
是它的证书过期了……干脆关闭。
systemctl stop cockpit systemctl disable cockpit systemctl stop cockpit.socket 最后查看状态 systemctl status cockpit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e25be941c86276b5eba85c8e3a357df/" rel="bookmark">
			C#基础详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#基础 一、C#语言及其特点 C#是微软公司发布的一种面向对象的、运行于 .NET Framework和 .NET Core（完全开源，跨平台）之上的高级程序设计语言。C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些他们的复杂特性。C#是面向对象的编程语言。 二、认识 .NET Framework/.NET Core .NET 是一个开发平台，而 C# 是一种在 .NET 开发平台上使用的编程语言，目前能在 .NET 平台上使用的开发语言很多，例如 Visual Basic .NET、Python、J#、Visual C++.NET 等。但在 .NET 平台上使用最多的是 C# 语言。
.NET 框架的目的是便于开发人员容易地建立 Web 应用程序和 Web 服务，使得 Internet 上的各应用程序之间可以使用 Web 服务进行沟通。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WFXjHQap-1663903134182)(https://kevin-1311972042.cos.ap-chengdu.myqcloud.com/img/241f95cad1c8a786c91727da2e5dde3d70cf3ac7fa91)]
.NET框架由三部分组成。执行环境称为CLR（Common Language Runtime，公共语言运行库）。CLR在运行时管理程序的执行，包括：内存管理和垃圾收集；代码安全验证；代码执行、线程管理和异常处理。BCL（Base Class Library，基类库）是.NET框架使用的一个大的类库，而且也可以在你的程序中使用。
三、C#语法基础 3.1 cs文件结构 结构展示：
3.2 C#基本语法 注意：
C#是大小写敏感的所有的语句和表达式必须以分号结尾与Java不同的是，文件名可以不同于类的名称 C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种对象组成，相同种类的对象通常具有相同的类型
案例：
以人类为例，从人类中诞生出的具体对象”C罗“和”梅西“，同属于人类。故两人的类型相同
关键字
关键字，是对编译器有特殊意义的预定义保留标识符，它们不能再程序中用作标识符
using关键字
在任何C#程序中的第一条语句都是：
using System; using 关键字用于在程序中包含命名空间，一个程序可以包含多个using语句
class关键字
class关键字用于声明一个类
C#的注释方式
/* 多行注释 */ //单行注释 ///文档注释 一般用于方法或者类名上 变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e25be941c86276b5eba85c8e3a357df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773912dfa4bce01b19284e90fe8e4fc5/" rel="bookmark">
			Bean 的实例化与装配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要程序代码块： 实验一实验二实验三实验四 实验要求：
理解 Spring 的 IoC/DI 的原理，掌握 Spring 使用注解方式和编程及 Spring 的分层设计
方法。
实验 1：集合类型注入
编写 UserInfo 类，包含用户姓名（String）、性别（boolean）、年龄（int）、出生年月（Date）、个人爱好（list 集合），采用 set 注入和构造注入两种方式，实现这些属性值的注入，并在测试程序中显示所有属性的值。
实验 2：
编写工厂类（BeanFactory）、Print 类（属性：pName、pColor 等），要求利用 Spring 容器通过工厂类 BeanFactory 生成 Print 对象,并生成测试结果。
实验 3：
利用 Spring 框架，通过注解方式实现为自己的校园卡充值。
在 Dao 层建立 CardDao 类，编写充值方法，实现充值（在控制台显示充值金额，将用户充值信息保存到数据库），在 Biz 层建立 CardBiz 类，编写充值方法，调用 Dao层中的充值方法，完成充值。在 CardController 类中编写充值方法调用 CardBiz 的充值方法。在程序中，通过代码方式调用控制层充值方法，完成充值，并在控制台显示充值金额。在实现过程中不能利用 new 操作来完成类的实例化。观察@Autowired 和@Resource 进行注解时有何不同。
实验 4：
根据自己的理解，描述 Bean 的装配方式。
实验分析：
实验一主要运用Bean基于XML的装配：设值注入、构造注入。实验二采用的是静态工厂实例化。实验三主要涉及到Bean的实例化与装配（基于注解的装配）、此外还涉及了Spring对于数据库的连接。此实验可参考利用Spring框架为自己的校园卡充值。 代码实现：
实验一 set注入
package com.cqust; import java.util.Date; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773912dfa4bce01b19284e90fe8e4fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b60a249a50568520832533f37d6dbb9/" rel="bookmark">
			Python程序报AttributeError的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个报错，在改一个代码时候出现了如题的报错。
别人的解释：
查阅发现大多的解释是
“是由于__init__这个构造方法函数名，写得不正确。下划线少些了一个或者init拼错了~”
我的情况：
检查发现我的并不是这样的问题，然后我发现我报错的那一行代码，self.变量未定义
self._offset = max(self._offset, 5)	# 这里的self._offset并未在前面定义过，所以此处报错 解决办法很简单，让系统获取到自定义的这个类的这个属性就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8aed5f884182c064d5d80a5c5cf137/" rel="bookmark">
			程序员莫名收到谷歌转账170万元，直言：一个月没敢花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，Google 公司发生一起乌龙事件， 意外地给一位博客和安全工程师转账近25万美元（约合人民币174万元），当事人表示等待将近一个月才收到公司的回复。针对此次乌龙事件，Google 方面发布声明：“团队最近由于人为错误向错误的一方支付了一笔款项。我们感谢受影响的合作伙伴迅速向我们通报了这一情况，我们正在努力纠正。”
作为当事人的安全工程师 Sam Curry 也在 Twitter 分享了他的这段经历，表示 Google “随机”向他转账了巨款，并且距离他收到这笔转账已经过去了超三周时间，在等待对方回应的时间内，他完全没有动这笔钱。
（图源：Twitter截图）
（图源：Twitter截图）
据了解，目前 Sam Curry 需要将这笔错误转账归还，为了避免这一过程出现税款，他还需要先将款项转入另一个账户。 因此，许多网友在 Twitter 上幽默的调侃道：
“你的税还没有报上去”；
“国税局肯定会会开心的”；
“如果在合理时间内，他们有义务归还。但是一定时间之后，他们或许就可以保留了”。
如果你的账户突然收到一笔巨额的转账汇款，你会怎么办？
参考链接：
https://www.sypai.net/yejie/253659.html
https://news.mydrivers.com/1/860/860266.htm
《新程序员001-004》已全面上市，欢迎扫描下方二维码或点击进入立即订阅，即可畅享电子书及精美纸质书！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f29ccf034679fbeafef0fd23a9b7f24/" rel="bookmark">
			DIY官网可视化工具打造UNIAPP-uviewUI可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DIY官网可视化工具打造UNIAPP-uviewUI可视化一键生成导出致力为UNIAPP-uviewUI开发者加速开发
快速生成基于Vue开发前端应用的框架，减少前端开发者80%工作量
UNIAPP-uviewUI可视化设计工具一键生成UNIAPP-uviewUI应用代码可视化组件打造你的UNIAPP-uviewUI，丰富的组件可视化拖拉生成UNIAPP-uviewUI，减少前端开发者80%工作量
可视化生成UNIAPP-uviewUI框架源码,一个使用 Vue.js开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台
多平台快速开发的UI框架
uView UI，是uni-app生态最优秀的UI框架，全面的组件和便捷的工具会让您信手拈来，如鱼得水
四大利器，为您保驾护航
指南
涵盖uniapp各个方面，给开发者方向指导和设计理念，让您茅塞顿开，一马平川
组件
众多组件覆盖开发过程的各个需求，组件功能丰富，多端兼容。让您快速集成，开箱即用
工具库
众多的贴心小工具，是您开发过程中召之即来的利器，让您飞镖在手，百步穿杨
布局
收集众多的常用页面和布局，减少开发者的重复工作，让您专注逻辑，事半功倍
一次编写，多端发布
安卓
Android
Apple
IOS
微信小程序
Mini Program
H5
Mobile Web
QQ小程序
QQ Miniprogram
百度小程序
Smart Program
支付宝小程序
Alipay MiniProgram
头条小程序
Toutiao MiniProgram
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/211/">«</a>
	<span class="pagination__item pagination__item--current">212/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/213/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>