<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c25f340f9acb5dcc286eae7e501fc8c/" rel="bookmark">
			什么是极大似然估计？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ● 每周一言 坚持一定是有毅力，但有毅力不一定能坚持。
导语 统计学中，我们经常能听到极大似然估计，或者最大似然估计，它是一种参数估计方法。在机器学习中，逻辑回归就是基于极大似然估计来计算的损失函数。那么，如何直观理解极大似然估计？
极大似然估计 极大似然估计（maximum likelihood estimation，MLE），顾名思义，“极大”意为“最有可能的”，“似然”意为“看起来像的”，“估计”的意思则可以理解为“就是这样的”。
所以，极大似然估计的直译就是：最有可能看起来像的，就是这样的。就是说，以最大概率为标准来判断结果，即叫做极大似然估计。 比如，在你面前出现一个白人，你来判断这个人来自哪个大洲。不出意外，你会说来自欧洲。这便是用了极大似然估计的思想。
了解了极大似然估计的思想，下面通过一个具体的例子来说明极大似然估计的求解步骤。
一个黑色箱子里有黑白两种颜色的小球若干，每次有放回的拿球，已知拿到白球的概率范围是[0.2，0.8]，拿三次结果两黑一白，问取出白球概率的极大似然估计是多少。
假设取球事件为y，取到白球时y=1，概率为p，取到黑球时y=0，概率为1-p。由于是独立事件，三次拿球两黑一白的概率可以表示为：P(y = 0 | p)P(y = 0 | p)P(y = 1 | p) = (1 - p)(1 - p)p = p^3 - 2p^2 + p。白球的极大似然估计就是求使得这个概率表达式最大的p值。 既然是求最大值，而上式可导，我们便可对上式进行求导并令其等于0，3p^2 - 4p + 1 = 0。求此一元二次方程的根得p=1/3或p=1，可知原式在[0, 1/3]区间单调递增，在[1/3, 1]区间单调递减。因此，在白球概率范围[0.2，0.8]内，当p=1/3时表达式取得最大值，取得白球的概率的极大似然估计为1/3。
至此，便可总结出极大似然估计的求解步骤：
1&gt; 写出概率表达式，也可以叫似然表达式，似然表达式值的大小意味着这组样本值出现的可能性的大小。 2&gt; 对似然表达式求导，必要时进行预处理，比如取对数（逻辑回归需要），令其导数为0，得到似然方程。 3&gt; 求解似然方程，得到的参数解即为极大似然估计的解。 这里多说一句，由于逻辑回归的ω向量可能很大，参数个数很多，导致方程组很难求解。在这种情况下，一般通过梯度上升法逼近真实的ω，这也符合机器学习的训练过程。 以上便是极大似然估计的讲解，敬请期待下节内容。
结语 感谢各位的耐心阅读，后续文章于每周日奉上，敬请期待。欢迎大家关注小斗公众号 对半独白！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8dd735096d9aa80472983eb16a2c526/" rel="bookmark">
			解决使用SSH连接Linux服务器时连接失败的故障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用Xshell连接Linux服务器，报错：Connection closed by foreign host. Disconnected from remote host，详细报错信息是：
[C:\~]$ ssh root@210.35.124.82 Connecting to 210.35.124.2:22... Connection established. To escape to local shell, press 'Ctrl+Alt+]'. Connection closing...Socket close. Connection closed by foreign host. Disconnected from remote host(210.35.124.82:22) at 08:34:46. Type `help' to learn how to use Xshell prompt. 通过控制台从本地登录服务器，使用last指令查看登录情况，发现好几个终端依然登着，但是ip地址变化了，好吧，很有可能是网络ip地址变化导致xshell自动断开连接。于是修改本机ip为固定地址发现就不会轻易断了。
root pts/3 183.186.203.80 Sat Aug 26 09:41 still logged in root pts/2 171.127.72.216 Sat Aug 26 09:33 still logged in root pts/2 118.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8dd735096d9aa80472983eb16a2c526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc630749b0bf0d2af3884ceed8aeca5f/" rel="bookmark">
			垃圾回收算法：引用计数法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是《垃圾回收的算法与实现》读书笔记 上一篇为《GC 标记-清除算法》
引用计数算法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这也就是需要回收的对象。 引用计数算法是对象记录自己被多少程序引用，引用计数为零的对象将被清除。
计数器表示的是有多少程序引用了这个对象（被引用数）。计数器是无符号整数。
计数器的增减 引用计数法没有明确启动 GC 的语句，它与程序的执行密切相关，在程序的处理过程中通过增减计数器的值来进行内存管理。
new_obj() 函数 与GC标记-清除算法相同，程序在生成新对象的时候会调用 new_obj()函数。
func new_obj(size){ obj = pickup_chunk(size, $free_list) if(obj == NULL) allocation_fail() else obj.ref_cnt = 1 // 新对象第一只被分配是引用数为1 return obj } 这里 pickup_chunk()函数的用法与GC标记-清除算法中的用法大致相同。不同的是这里返回 NULL 时，分配就失败了。这里 ref_cnt 域代表的是 obj 的计数器。
在引用计数算法中，除了连接到空闲链表的对象，其他对象都是活跃对象。所以如果 pickup_chunk()返回 NULL，堆中也就没有其它大小合适的块了。 update_ptr() 函数 update_ptr() 函数用于更新指针 ptr，使其指向对象 obj，同时进行计数器值的增减。
func update_ptr(ptr, obj){ inc_ref_cnt(obj) // obj 引用计数+1 dec_ref_cnt(*ptr) // ptr之前指向的对象(*ptr)的引用计数-1 *ptr = obj } 这里 update_ptr 为什么需要先调用 inc_ref_cnt，再调用 dec_ref_cnt呢？ 是因为有可能 *ptr和 obj 可能是同一个对象，如果先调用dec_ref_cnt可能会误伤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc630749b0bf0d2af3884ceed8aeca5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06513cc68cff08ad0955ca666c80cd2c/" rel="bookmark">
			李宏毅机器学习（2017full）-Lecture 2: Where does the error come from?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Where does the error come from? ML Lecture 2 参考 https://blog.csdn.net/abc8730866/article/details/70260188
Error的来源：Bias，Varience
f^ f ^ 是计算pokemon真正的函数，只有Niantic公司知道从训练集上，我们得出的一个估计 f∗ f ∗ 故像射击一样，靶心为 f^ f ^ , f∗ f ∗ 是我们射中的地方，会由于“bias”和“variance”导致射偏。 Bias and Variance of Estimator 估测均值 μ μ ：直接用m（一次实验的平均值）来估计均值μμ是biased的 ,多次实验，对得到的多个m计算期望，算是unbias
用m的方差估算 σ2 σ 2 是unbiased
N越多，越集中。N越少，越分散。取决于取样的数量 用采样结果得到的方差 s2 s 2 的期望来估计 σ2 σ 2 是biased的 随着N的增加，估测 s2 s 2 和 σ2 σ 2 差距会变小。
ERROR的来源：
ERROR 1. bias：瞄准的是不是中心。瞄准点同靶心的距离就是Bias；ERROR 2. variance：射出去和瞄准的之间距离 。实际射在靶心上的位置与你瞄准点的距离就是Variance。 如何找到多个 f∗ f ∗ ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06513cc68cff08ad0955ca666c80cd2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cc04e5213cc2b59e4165b232b9bddb/" rel="bookmark">
			A - Easy h-index（阅读理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The h-index of an author is the largest h where he has at least h papers with citations not less than h.
h-index 指数类似于打游戏时的称号等级，只是这里的这个等级的评判有两个方面：1.发布的论文数量h1。
2.这h1份论文的的总引用次数h2。要求h2 &gt;= h1。
Bobo has published many papers.
Given a0,a1,a2,…,an which means Bobo has published ai papers with citations exactly i, find the h
-index of Bobo.
a0 --&gt; ai --&gt; an 代表ai份论文的引用次数分别为0--&gt;i--&gt;n。 Input
The input consists of several test cases and is terminated by end-of-file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8cc04e5213cc2b59e4165b232b9bddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c5ed984c9e44c6137d8fcfc46aed5e/" rel="bookmark">
			华为机试训练做题总结（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		69. 字符串通配符 题目描述 : 问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。 要求： 实现如下2个通配符： *：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同） ？：匹配1个字符 输入： 通配符表达式； 一组字符串。 输出： 返回匹配的结果，正确输出true，错误输出false 思路分析：: 这一题采用递归的方法来做，主要就是先想好终止条件。然后依次搭配好递归的方式 解决办法： 其中有一个函数需要值得注意c_str() ，这个函数直接就是将string类型转为const char * 类型。 代码：
#include&lt;bits/stdc++.h&gt; using namespace std; bool match(const char* pattern,const char* str){ if(*pattern =='\0' &amp;&amp; *str=='\0') return true; if(*pattern =='\0' || *str=='\0') return false; if(*pattern =='?') { return match(pattern+1,str+1); }else if(*pattern=='*'){ //匹配0个或者多个 return match(pattern+1,str) || match(pattern +1 ,str+1) || match(pattern,str+1); }else if(*pattern==*str){ return match(pattern+1,str+1); } return false; } int main(){ string pattern,str; while(cin&gt;&gt;pattern&gt;&gt;str){ bool ret =match(pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c5ed984c9e44c6137d8fcfc46aed5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0a9e64de99ac7c08a60df207c4bfaf/" rel="bookmark">
			ID3决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息熵与信息增益：
熵代表信息的混乱程度。一个特征的熵越小，说明这个特征的信息越纯净，价值越大，用总的信息熵减去该特征信息熵的信息增益就越大，越应该在初始的时候作为划分数据集的特征。
实现代码： （环境为Python3.x）
from numpy import * from math import log import operator #创建数据集 def createDataSet(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers'] return dataSet, labels #计算香农熵 def calcShannonEnt(dataSet): numEntries = len(dataSet) labelCounts = {} for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0a9e64de99ac7c08a60df207c4bfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59591059a53b5eb089fe3938a99862f/" rel="bookmark">
			OpenCV笔记大集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：OpenCV学习笔记 作者：CSDN 数量：55篇博文 网址：http://blog.csdn.net/column/details/opencv-manual.html
2：部分OpenCV的函数解读和原理解读 作者：梦想腾飞 数量：20篇博文 网址：http://blog.csdn.net/xidianzhimeng/article/category/1593859
3： OpenCV入门指南 作者： MoreWindows 数量： 13篇博文 网址：http://blog.csdn.net/morewindows/article/category/1291764
4： OpenCV成长和进阶之路 作者： Ronny的技术成长之路 数量： 12篇博文 网址：http://www.cnblogs.com/ronny/category/366234.html
5： OpenCV入门教程 作者： 毛星云（浅墨）的专栏，《OpenCV3编程入门》作者 数量： 18篇博文 网址：http://blog.csdn.net/zhmxy555/article/category/1923021
6： 基础学习笔记之opencv 作者： tornadomeet 数量： 24篇博文 网址：http://www.cnblogs.com/tornadomeet/tag/opencv/
7： OpenCV学习笔记 作者： 邹宇华 数量： 32篇博文 网址：http://blog.csdn.net/chenyusiyuan/article/category/610983
8： CVPR|OpenCV|图像检索|视频检索 作者： icvpr 数量： 25篇博文 网址：http://blog.csdn.net/icvpr/article/category/1139524
9： 学习OpenCV 作者： 小熊不去实验室 数量： 81篇博文 网址：http://blog.csdn.net/sangni007/article/category/1106771
10： OpenCV 作者： 羽凌寒 数量： 47篇博文 网址：http://blog.csdn.net/u011630458/article/category/2771659
11： OpenCV入门 作者： reyzal 数量： 7篇博文 网址：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59591059a53b5eb089fe3938a99862f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84cf7af7aba1e60c35093f6c0a4c44e0/" rel="bookmark">
			微擎应用插件整合DIY官网上线了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微擎应用插件整合DIY官网上线了
复制本页链接
微擎整合DIY官网可视化工具，支持设计微商城、微官网、微问卷等 DIY官网可视化工具无须编程 零代码基础 所见即所得设计工具
轻松制作微信小程序、原型设计、WebApp设计、Bootstrap、单页动画 DIY官网打造微擎应用插件，轻松同步DIY官网http://www.diygw.com设计应用
欢迎fork:https://gitee.com/html580/diygwcom_app.git
源码下载后解压给微擎应用的addons文件夹里。
然后进入微擎系统：点击系统-公众号应用-未安装应用里选择DIY官网进行安装。
安装完成后从公众号进入DIY官网应用插件，点击应用管理，初次进入会要求绑定DIY官网的用户名跟密钥进行获取密钥来同步数据。
绑定后再次点击应用管理，将会同步DIY官网上的应用。点击对应用 的安装将会安装到你微擎本地，如果你再次进行可视化编辑，你的本地应用会提醒更新，点击更新将会再次同步应用.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cca5e1a95be962a4ed36b650fada044/" rel="bookmark">
			【华为机试在线训练】Day 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 请实现如下接口
/* 功能：四则运算
* 输入：strExpression：字符串格式的算术表达式，如: "3+2*{1+2*[-4/(8-6)+7]}"
* 返回：算术表达式的计算结果
*/
public static int calculate(String strExpression)
{
/* 请实现*/
return 0;
} 约束：
pucExpression字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。
pucExpression算术表达式的有效性由调用者保证; 输入描述: 输入一个算术表达式
输出描述: 得到计算结果
//先中缀转后缀再计算后缀表达式的值，需要注意的是对于‘-’为一元运算符的处理和数字//的位数做一个记录。当看到python只有一行代码时，吐了一口老血。。。 #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;stack&gt; using namespace std; int main() { string s; while (cin &gt;&gt; s) { stack&lt;char&gt; opera; vector&lt;int&gt; numcnt;//用来保存每个数字的位数，以保证计算后缀表达式时的正确性 string s1;//后缀表达式 //中缀表达式转后缀表达式 for (int i = 0;i&lt;s.size();i++) { if (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9') { int tmp = 0; while (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9') { tmp++; s1 += s[i]; i++; } i--; numcnt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cca5e1a95be962a4ed36b650fada044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247145456648b5c9682977659437d953/" rel="bookmark">
			数据库之事务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是事务 事务是访问数据库的一个或多个操作的组合，事务执行完之后可以使数据库从一种状态变为另外一种状态。
事务的四个特性 1、原子性 原子性指的是事务中的操作要么全部执行，要么全部不执行。这意味着如果事务正确执行，则数据库从一种状态成功地变为了另外一种状态；如果事务中的某个操作未正确执行，则已正确执行的其他操作需要对数据库进行回滚，使数据库恢复到该事务执行之前的状态。
2、一致性 一致性指的是使数据库从一种状态正确地变为另外一种状态，这里的关键词是“正确地”，换句话说是，一个事务执行之前和执行之后都必须处于一致性状态。举个栗子，如果A给B汇款100元，则一致性就代表着A账户减少了100元，B账户增加了100元，但是他们的账户总和不会改变。
3、隔离性 隔离性指的是各个事务之间的执行不能相互影响，比如两个事务并发地对某个数据进行操作，则A事务在对该数据进行操作时，B事务不能对其操作。
4、持久性 持久性指的是事务一旦被提交了，该事务对数据库的数据改变就是永久性的，即时这时数据库系统遇到了故障，事务的处理结果也会保存下来。
并发中的事务引起的问题 在并发操作中，如果不考虑事务的隔离性，会引起一系列的问题，如脏读、不可重复读、幻读等。
1、脏读 脏读是指一个事务在处理过程中，读到了另一个未提交的事务中的数据。举个栗子，A向B转账100元这个事务需要两条SQL语句，首先给B的账户添加100元，A的账户减少100元，假如执行完第一条SQL语句后发生了阻塞，此时B对其账户进行查询操作，发现其账户已经多出了100元，但是此时事务阻塞结束，执行第二条语句时，发生了问题，这时数据库就需要回滚数据，返回事务执行之前的状态，那么B的账户会再减少100元，那么之前B查询到的多出100元的结果就是脏读。
2、不可重复读 不可重复读是指在一个事务中读取了两次同一个数据，但是结果不一致，这是因为这个事务两次查询操作之间的时候被另外一个事务修改了数据。举个栗子，事务A进行了两次查询账户的操作，事务B对账户进行了修改操作，改为减少100元，那么在A事务第一次查询账户后如果发生阻塞，B事务此时开启并执行，那么再执行A事务的第二次操作时，就会发现账户少了100元，这就是发生了不可重复读。
不可重复读与脏读的区别是，脏读是A事务读取了B事务未提交的数据，不可重复读是读取了B已提交的数据。
3、幻读 幻读是指在一个事务的操作后发现了未被操作的数据。什么意思呢，还是举个栗子吧，比如A事务想把所有人的账户数据全部改为100元，但此时事务B对该表进行了一个插入操作，增加了一个人Q和账户200元，也就是表增加了一行，那么A事务执行完毕后，会发现有一个人的账户未被修改过，这就是发生了幻读。
幻读和不可重复读都是读取了另一个已经提交的事务，不可重复读的重点在于update和delete，而幻读的重点是insert。
事务隔离级别 事务隔离级别是指的是事务四个特性之一的隔离性设置的不同级别，事务的隔离级别越高，由于并发导致的问题就会越少，但同时性能消耗也就更高。如果在两者之间做一个衡量的话，可以对不同的数据选择不同的隔离级别，MySQL支持四种隔离级别，默认为可重复读级别。
1、读未提交（READ_UNCOMMITTED） 可以读到没有被提交的数据，隔离的最低级别，不能防止脏读、不可重复读、幻读。
2、读已提交（READ_COMMITED） 读已提交是为了解决脏读的问题，它可以保证读不到未被提交的数据，这样的话就防止了脏读。
3、可重复读（REPEATABLE_READ） 重复读是为了解决不可重复读的问题，将要查询的数据加锁，这样其他事务就不会再对这些数据进行修改或删除操作，就可以实现可重复读了。但是这种对数据加锁的方式没办法对其他事务的插入操作有效，所以不能防止幻读。
4、串行化（SERLALIZABLE） 这个数据库隔离的最高级别，可以避免脏读、不可重复读、幻读，但这个级别的隔离也会降低数据库的增删改查性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a32b9f05bc23bd3b4705c61ad43e2e/" rel="bookmark">
			scala方法和函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法的定义
默认参数
变长参数
过程
懒值（lazy）
方法VS函数
定义方式
表达形式
参数要求
方法和函数的相互转换
方法的定义 有以下几点需要注意：
所有参数必须制定类型；递归方法，不能省略返回值类型，其他情况下可以忽略（方法可以通过=右侧的函数主体推断出返回值类型）单行方法主体，可以与方法写在一行并忽略{} 默认参数 scala&gt; def m1(name : String, left : String = "&lt;", right : String = "&gt;") = { | left + name + right | } m1: (name: String, left: String, right: String)String scala&gt; m1("hello") res0: String = &lt;hello&gt; scala&gt; m1("hello","&lt;&lt;","&gt;&gt;") res1: String = &lt;&lt;hello&gt;&gt; scala&gt; m1("hello", right = "&gt;&gt;") res2: String = &lt;hello&gt;&gt; scala&gt; m1("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a32b9f05bc23bd3b4705c61ad43e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e47fe48e4f55199c18409cfae81b504/" rel="bookmark">
			qemu、KVM、以及Could not access KVM kernel module: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Qemu？kvm？
Qemu 既然是虚拟机，那总得有虚拟出来的各种硬件吧，Qemu就是提供这一功能的硬件模拟器，让guestOS以为自己在和真的硬件打交道，而其实，这中间隔着一个Qemu来当翻译。也正是因为存在翻译的过程，所以性能上会打折扣，于是我们需要：
kvm kvm属于linux内核的模块，可以理解为集成至内核中的Hypervisor，采用intel VT/AMD-V等技术，提供CPU和内存的虚拟化能力，这样guestOS的CPU指令可以不用再经过翻译，性能大增，但它还需要network和周边I/O的支持，所以两者联手：kvm负责cpu和内存，qemu负责其他的，一个内核空间，一个用户空间从而形成qemu-kvm这样一个完整的、更优的虚拟化技术。
作者：罗浩
链接：https://zhuanlan.zhihu.com/p/33422594
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
---------------------------------------------------------------------------
注：可能在qemu中使能kvm的时候会报错，比如执行下面指令：
$ qemu-system-x86_64 \ -kernel obj/linux-x86-alldefconfig/arch/x86_64/boot/bzImage \ -initrd obj/initramfs-busybox-x86.cpio.gz \ -nographic -append "console=ttyS0" -enable-kvm
会报错：
Could not access KVM kernel module: No such file or directory
原因可能就是没有在BIOS中开启Intel的虚拟化技术。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa97d2ca1634f784b6a4b3f77982b58c/" rel="bookmark">
			WINDOWS 10环境下安装OPENSSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装Windows 10 2、安装Visual studio
3、下载openssl，官网是https://www.openssl.org/source/
第一个，openssl-1.1.1-pre8.tar.gz，因为之后的编译不成功，所以选择第二个，openssl-1.0.20.tar.gz
4、下载perl，官网是https://www.activestate.com/activeperl
最新一个就行了
5、先安装perl
安装后，使用命令行工具，进入perl的安装路径，执行“perl example.pl”，若显示“Hello from ActivePerl!”，则说明perl安装成功
6、设置环境变量
打开我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量。找到Path系统变量，点击编辑，添加：perl的bin路径；VS的bin路径
例如，我的perl的bin路径：C:\Perl64\bin；VS的bin路径是：D:\visual studio\VC\bin
7、打开Visual Studio的开发人员命令提示，并进入openssl的目录
按顺序执行下列命令
perl Configure VC-WIN64A (网上也有是执行perl Configure VC-WIN32，但我的安装过程中会出错)
ms\do_ms
nmake -f ms\ntdll.mak (编译动态库)
nmake -f ms\nt.mak （编译静态库）
编译成功后，可以通过执行一下命令来验证
nmake -f ms\ntdll.mak test
nmake -f ms\nt.mak test
最后是装载
nmake -f ms\ntdll.mak install
nmake -f ms\nt.mak install
装载后的文件一般是在openssl所在的分区盘中，名字为usr的文件夹
8、通过设置Visual Studio相关属性，来链接usr文件夹里的文件
实例下一篇再发
https://blog.csdn.net/ZRXSLYG/article/details/81395640
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2bbaed49fba14cc8f8271c5afb1c6b/" rel="bookmark">
			vector在类中声明问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class base { public: int n; vector&lt;int&gt; a(10);//会出现错误，提示：应输入类型说明符 int b[10];//不会出现错误 }; 上面代码第五行会提示：应输入类型说明符。
可以修改为下面代码：
class base { public: int n; vector&lt;int&gt; a; int b[10]; base() : a(10,-1) {} }; 在构造函数里这样初始化它 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b53a7d8ec246121cb6def710a6e0495/" rel="bookmark">
			删除vector中重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法unique能够移除重复的元素。每当在[first, last]内遇到有重复的元素群，它便移除该元素群中第一个以后的所有元素。
注意：unique只移除相邻的重复元素，如果你想要移除所有（包括不相邻的）重复元素，必须先将序列排序，使所有重复元素都相邻。
unique会返回一个迭代器指向新区间的尾端，新区间之内不包含相邻的重复元素。
事实上unique并不改变元素个数，有一些残余数据会留下来，可以用erase函数去除。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; using namespace std; int main(void) { vector&lt;int&gt; res = { 2, 3, 4, 5, 2, 3, 4, 5 }; cout &lt;&lt; "移除之前，res数组中元素的个数：" &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); vector&lt;int&gt;::iterator ite = unique(res.begin(), res.end()); cout &lt;&lt; "使用unique之后，res数组中元素的个数：" &lt;&lt; res.size() &lt;&lt; endl; res.erase(ite, res.end()); cout &lt;&lt; "使用erase之后，res数组中元素的个数：" &lt;&lt; res.size() &lt;&lt; endl; for(auto i : res) cout &lt;&lt; i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b53a7d8ec246121cb6def710a6e0495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c247f10a2fe0b28ba73b33f9cda6b5/" rel="bookmark">
			opencv-Mat数据类型及位数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.sina.com.cn/s/blog_662c7859010105za.html
在OpenCV里面，许多数据结构为了达到內存使用的最优化，通常都会用它最小上限的空间来分配变量，有的数据结构也会因为图像文件格式的关系而给予适当的变量，因此需要知道它们声明的空间大小来配置适当的变量。
一般标准的图片，为RGB格式它们的大小为8bits格式，范围为0~255,对一个int空间的类型来说实在是太小，整整浪费了24bits的空间,假设有个640*480的BMP文件空间存储內存,那整整浪费了640*480*3*(32-8)bits的內存空间,总共浪费了2.6MB!，也就是那 2.6MB内什么东西都没存储，如果今天以8bits的格式来存储则只使用到0.6MB的內存而已(640*480*3*(8)+54 bits)，因此，对于文件格式的对应是一件很重要的事。
在这边除了要考虑bits的空间大小外，还要考虑使用类型的正负号的问题，一般的图像文件是不存在负号的，如果今天即使选则正确的空间大小，可是出现的结果却是负的，那就功亏一篑了。这里除了Float及double类型，char，int,short int都是用二的补数表示法,它们不具正负号bit,而Float,double则是用IEEE 754,在第32bit,64bit上有一个正负号bit.
float: 4字节，6-7位有效数字 -3.4E-38 到 3.4E38 double: 8字节，15~16位有效数字 -1.7E-308 到 1.7E308
cvCreateImage()及cvCreateMat()对应
1.Unsigned 8bits(一般的图像文件格式使用的大小)
IplImage数据结构参数：IPL_DEPTH_8U
CvMat数据结构参数：CV_8UC1，CV_8UC2，CV_8UC3，CV_8UC4
变量类型空间大小范围其他uchar8bits0~255(OpenCV缺省变量,同等unsigned char)unsigned char8bits0~255 2.Signed 8bits
IplImage数据结构参数：IPL_DEPTH_8S
CvMat数据结构参数：CV_8SC1，CV_8SC2，CV_8SC3，CV_8SC4
变量类型空间大小范围其他char8bits-128~127 3.Unsigned 16bits
IplImage数据结构参数：IPL_DEPTH_16U
CvMat数据结构参数：CV_16UC1，CV_16UC2，CV_16UC3，CV_16UC4
变量类型空间大小范围其他ushort16bits0~65535(OpenCV缺省变量,同等unsigned short int)unsigned short int16bits0~65535(unsigned short) 4.Signed 16bits
IplImage数据结构参数：IPL_DEPTH_16S
CvMat数据结构参数：CV_16SC1，CV_16SC2，CV_16SC3，CV_16SC4
变量类型空间大小范围其他short int16bits-32768~32767(short) 5.Signed 32bits
IplImage数据结构参数：IPL_DEPTH_32S
CvMat数据结构参数：CV_32SC1，CV_32SC2，CV_32SC3，CV_32SC4
变量类型空间大小范围其他int32bits-2147483648~2147483647(long) 6.Float 32bits
IplImage数据结构参数：IPL_DEPTH_32F
CvMat数据结构参数：CV_32FC1，CV_32FC2，CV_32FC3，CV_32FC4
变量类型空间大小范围其他float32bits1.18*10-38~3.40*1038 7.Double 64bits
CvMat数据结构参数：CV_64FC1，CV_64FC2，CV_64FC3，CV_64FC4
变量类型空间大小范围其他double64bits2.23*10-308~1.79*10308 8.Unsigned 1bit
IplImage数据结构参数：IPL_DEPTH_1U
变量类型空间大小范围其他bool1bit0~1 其他变量对应：
1.Signed 64bits
int64
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c247f10a2fe0b28ba73b33f9cda6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811b99249d223f7a5bbc833d68df9d8e/" rel="bookmark">
			【贝叶斯分析②】抛硬币问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抛硬币问题可能是贝叶斯推断中最基础的一个入门问题，该问题简单来说就是对一枚硬币出现正面朝上的概率θ进行估计。不同于MLE, MAP等估计方法求出的是一个估计值，贝叶斯分析求出的是一个后验分布（用贝叶斯公式）。
θ的先验通常选用beta分布，n次观测正面朝上次数y的似然则可以用参数为n和θ二项分布来描述。用数学表达式描述如下θ ~ Beta(α, β)，y~ Bin(n, p = θ).
这里顺便多说一下为什么先验用beta分布的原因：One of them is that the beta distribution is restricted to be between 0 and 1, in the same way our parameter θ is. Another reason is its versatility. As we can see in the preceding figure, the distribution adopts several shapes, including a uniform distribution, Gaussian-like distributions, U-like distributions, and so on. A third reason is that the beta distribution is the conjugate prior of the binomial distribution (which we are using as the likelihood).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811b99249d223f7a5bbc833d68df9d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b9c80d4952942255cc0ac2810d95ac/" rel="bookmark">
			带灯LED按钮开关接线方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483
针对某宝的带LED灯的按钮开关接线方法，在此做一个经过验证的方法，开关形状如下：
螺纹直接有12mm、16mm、19mm、22mm等
此处做开关使用，按钮按下时导通，LED灯亮，按钮抬起时断开，LED灯灭
接线为：在正极线中接入开关，控制正极的导通与断开
C公共端(绿线)接电源正极一头，LED指示灯（红线)与NO常开端(蓝线)拧在一起，接导线的另一头，A指示灯(黑线)接电源的负极（GND)
这样就可以实现按钮按下，正极导通，LED亮起来，按钮抬起正极断开，LED灯灭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63661810900ac06d325e9feb81963194/" rel="bookmark">
			Tensorflow 模型量化 （Quantizing deep convolutional networks for efficient inference: A whitepaper 译文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近Tensorflow官方发布了一份《Quantizing deep convolutional networks for efficient inference》白皮书，共36页，讲解了基于Tensorflow的模型量化的有关知识。由于最近也在学习模型量化这部分工作，所以计划对这份文档翻译一下，同时share给大家。由于工作时间所限，我尽量每天翻译一些，如果有误解的地方，也请大家批评指正。
2018.07.30
如需转载，请注明出处： https://blog.csdn.net/guvcolie/article/details/81286349
1 Introduction Deep networks are increasingly used for applications at the edge. Devices at the edge typically have lower compute capabilities and are constrained in memory and power consumption. It is also necessary to reduce the amount of communication to the cloud for transferring models to the device to save on power and reduce network connectivity requirements. Therefore, there is a pressing need for techniques to optimize models for reduced model size, faster inference and lower power consumption.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63661810900ac06d325e9feb81963194/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/450/">«</a>
	<span class="pagination__item pagination__item--current">451/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/452/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>