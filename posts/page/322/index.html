<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f90677f3c0d4a22083e4e81f96bcf75/" rel="bookmark">
			idea反编译jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea反编译jar包 安装Java Bytecode Decompiler插件反编译 安装Java Bytecode Decompiler插件 File–&gt;Settings–&gt;Plugins，在搜索框内搜出后勾选
插件Java Bytecode Decompiler
反编译 java -cp “D:\javaSoftware\IntelliJ IDEA 2019.1.4\plugins\java-decompiler\lib\java-decompiler.jar” org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true jetbrains-agent.jar mysrc
其中
jetbrains-agent.jar为需要反编译的jar包
mysrc为需要保存的路径
反编译之后，将mysrc里的jar修改为.zip后缀，解压即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa9f29d9da7a674d70d928085fa22ff/" rel="bookmark">
			linux watch 特殊字符,使用Linux Watch命令的7种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些场合，你可能需要在某个时间间隔后重复运行一个命令或实用程序。我们可以借助bash脚本或使用其他编程语言来使用特定的cron作业。然而，Linux有一个内置的watch命令，用于定期间隔运行其他命令，然后它在终端中显示输出。几乎所有的Linux发行版上都预装了watch实用程序。
Linux Watch命令与实例
在本教程中，我们将向您展示七种不同的使用Linux watch命令的方法。
1. 每2秒运行一次命令
默认情况下，watch命令每2秒后运行一次，并在终端上显示输出。该命令会一直运行，直到被用户打断。
语法：
watch 其中是我们将在本文后面讨论的参数，是你想通过手表工具执行的另一个命令。
watch date
2.每N秒运行一次命令
监视命令更新间隔可以被覆盖。这意味着您也可以将更新间隔从2秒更改为所需的间隔。
句法：
watch -n 其中是更新间隔(以秒为单位)，而是要由watch实用程序执行的另一个命令。
watch -n 5 date
3.突出显示更新之间的差异
您还可以突出显示先前输出和当前输出之间的差异。因此，您不必关注整个输出，而可以关注更改。
句法：
watch -d 但是，如果两次更新之间的间隔很短，则检查差异将非常困难，因此您必须设置一个合理的更新间隔。
watch -n 5 -d date
4.在输出中隐藏标题
Watch命令输出显示了一个标题，其中包含时间间隔，命令，系统名称和系统日期。但是，如果您不想看到此部分，也可以将其隐藏。
句法：
watch -t watch -t date
5.提示错误
如果更新失败，watch命令也可以发出哔声。为此，首先，您可能需要检查是否安装了哔声软件包。如果未安装，则可以使用以下命令进行安装：
sudo apt install beep
句法：
watch -b date
6.退出更改
默认情况下，watch命令将一直运行，直到被用户手动中断为止。但是，如果它也标识输出的更改，则可以使其退出。
句法：
watch -g watch -n 10 -g date
现在watch exit;它返回可以通过使用以下命令获得的特定状态：
echo $?
从上面的屏幕快照中可以看到，它显示了某些从0到8的整数标志。每个标志都有其含义，这些标志的详细信息在手册页上提供。
man watch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa9f29d9da7a674d70d928085fa22ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4420dab05b4dd4f8857dcb00fa9b0cbe/" rel="bookmark">
			java 基础编程练习19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
KiKi理解了继承可以让代码重用，他现在定义一个基类shape，私有数据为坐标点（x,y）
由它派生Rectangle类和Circle类，它们都有成员函数GetArea()求面积。派生类Rectangle类有数据：矩形的长和宽；派生类Circle类有数据：圆的半径。Rectangle类又派生正方形Square类，定义各类并测试。
输入三组数据，分别是矩形的长和宽、圆的半径、正方形的边长，输出三组数据，分别是矩形、圆、正方形的面积。圆周率按3.14计算。
输入描述:
输入三行，
第一行为矩形的长和宽，
第二行为圆的半径，
第三行为正方形的边长。
输出描述:
三行，分别是矩形、圆、正方形的面积。
示例1
输入
7 8
10
5
输出
56
314
25
import java.util.Scanner; import java.text.DecimalFormat; //图形类，基类 class Shape{ private int x; private int y; public Shape(int x,int y){ this.x=x; this.y=y; } } //长方形 class Rectangle extends Shape{ private int length; private int width; public Rectangle(int length, int width){ super(length, width); this.length = length; this.width = width; } public int GetArea(int x,int y){ return x*y; } } //圆 class Circle extends Shape{ int r; public Circle(int r){ super(r, r); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4420dab05b4dd4f8857dcb00fa9b0cbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60979919775db33fa5773883b14859a1/" rel="bookmark">
			java 基础编程练习18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
小乐乐从老师口中听到了二段数这个名词，想更深入的了解二段数。
二段数是这样的正整数：恰好包含两种不同的十进制数字s和t，s不是0，并且s的所有出现均排列在所有的t的前面。例如，44444411是二段数（s是4，t是1），41、10000000和5555556也是。但4444114和44444都不是二段数。
这时老师问小乐乐：给你一个任意的正整数n，你能求出比n大并且是n的倍数的最小二段数吗？请你帮助小乐乐解答这个问题。
输入描述:
多组输入，每组输入包含一个正整数n (1 ≤ n ≤ 99999)
题目保证测试数据总数不超过500组，当输入n=0时程序结束。
输出描述:
对于每组测试用例，输出正整数n，后面紧跟“: ”，输出答案并换行，即比n大且是n的倍数的最小二段数。
示例1
输入
1
2019
0
输出
1: 10
2019: 9999999993
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in=new Scanner(System.in); long n=in.nextLong(); while(n!=0){ int i=2; while(is_two(n*i)==false){//找寻n的倍数 i++; } System.out.println(n+"："+n*i); n=in.nextLong(); } } //判断是否是二段数的函数 public static boolean is_two(long num){ String s=""+num;//先将long转换为字符串 char [] c=s.toCharArray();//再转换为字符数组 int isNum=0; for(int i=1;i&lt;c.length;i++){ if(c[i]!=c[i-1]){//从左往右遍历，要是有数字的变换就加1 isNum++; } } if(isNum==1){//只有变换一次，也就是只有两种数字 return true; } else{ return false; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4af521fd2f080e486a2bbe180ca1b6b/" rel="bookmark">
			linux kvm虚拟化 libos,Debian &#43; cockpit-machines(kvm/libvirt) &#43; omv 简易虚拟化 &amp; NAS方案 避坑指南...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于Debian buster(Debian 10)，使用Debian的原因是因为可以叠加安装openmediavault(omv)，作为原生NAS使用。
本文编写于2021/2/27，由于cockpit等还在持续更新，请注意时效性。
安装openmediavault
也可以直接使用openmediavault的ISO安装基础系统。
安装完成后访问http://:80使用omv的控制面板，默认用户名:密码是admin:openmediavault
安装cockpit和cockpit-machines
其中添加buster-backports建议使用国内的、和你已有软件源一致的，可以参考清华源的配置指南。
然后安装cockpit本体：
sudo apt install -t buster-backports cockpit
记得要使用buster-backports源安装相关软件包(下同)，否则版本会比较旧，影响使用。
还需要手动安装cockpit-machines和qemu-kvm软件包，安装虚拟机功能；同时也建议安装cockpit-networkmanager，cockpit-storaged等cockpit的其他组件。
安装tuned可以启用主页上的“Performance profile”功能。
安装完成后访问https://:9090使用cockpit的控制面板，用户名密码同你的UNIX账户
安装virtinst并更新os-info-db
需要安装virtinst来支持cockpit-machines的虚拟机创建功能
sudo apt install -t buster-backports virtinst
此时你可能会发现安装页面的操作系统列表依然不全(比如没有Ubuntu 20.04)，这是因为debian的os-info-db包已经两年没有更新了。
请参考官方指南(此处略)：https://libosinfo.org/download/ 来更新os-info-db，你可以直接安装debian源里的osinfo-db-import工具来进行导入操作。
安装cockpit-podman容器虚拟化支持
podman是一个兼容docker的容器管理工具，Debian buster还没有官方支持podman，自然也没有官方支持cockpit-podman，这里采用一种折中的方式：
安装podman
# Debian 10
# First enable user namespaces as root user
echo 'kernel.unprivileged_userns_clone=1' &gt; /etc/sysctl.d/00-local-userns.conf
systemctl restart procps
# Use buster-backports on Debian 10 for a newer libseccomp2
echo 'deb http://deb.debian.org/debian buster-backports main' &gt;&gt; /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4af521fd2f080e486a2bbe180ca1b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cef75b864840b2c768d863fd56c8e22/" rel="bookmark">
			redis设计与实现读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一部分 数据结构与对象
第1章 引 言
第2章 简单动态字符串
第3章 链表
第4章 字典
第5章 跳跃表
第6章 整数集合
第7章 压缩列表
第8章 对象
第二部分 单级数据库的实现
第9章 数据库
第10章 RDB持久化
第11章 AOF持久化
第12章 事件
第13章 客户端
第14章 服务器
第三部分 多机数据库的实现
第15章 复制
第16章 Sentinel
第17章 集群
第四部分 独立功能的实现
第18章 发布与订阅
第19章 事务
第20章 lua脚本
第21章 排序
第22章 二进制位数组
第23章 慢查询日志
第24章监视器
第一部分 数据结构与对象 第1章 引 言 1.数据库的键总是一个字符串对象，而数据库的值可以是字符串，列表，集合，有序集合，哈希任意一种。
第2章 简单动态字符串（SDS,Simple dynamic string） 1.C字符串与简单动态字符串SDS的内存结构：
2.C字符串与简单动态字符串SDS的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cef75b864840b2c768d863fd56c8e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b92f28f56d3926dc50b324979d1a998/" rel="bookmark">
			云系列---Openstack概念讲解 | 初识 | 入门概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云计算概述 1.简介 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问
进入可配置的计算资源共享池（资源包括：网络、服务器、存储、计算、应用软件等服务），这些资源能够被快速提供，只需提供很少的管理工作，或只用与服务供应商进行很少的交互
狭义的云计算是指 IT 基础设施的交付和使用模式
广义的云计算是指服务的交付和使用模式
2.特点 ① 超大规模
"云"具有相当的规模
企业私有云一般般拥有数百上千台服务器，能给用户提供前所未有的计算能力
② 虚拟化
云计算支持用户在任意位置、使用各种终端获取应用服务
③ 高可靠性
"云"使用了数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性
使用云计算比使用本地计算机可靠
④ 通用性
云计算不针对特定的应用
同一"云"可以同时支撑不同的应用运行
⑤ 高可扩展性
"云"的规模可以动态伸缩，满足应用和用户规模增长的需要
⑥ 按需服务
"云"是一个庞大的资源池，你按需购买
云可以像自来水、电、煤气那样按量计费
⑦ 极其廉价
由于"云"的特殊容错措施，可以采用极其廉价的节点来构成云
"云"的自动化集中式管理使大量企业无需负担日益高昂的数据中心管理成本
"云"的通用性使资源的利用率较之传统系统大幅提升，因此用户可以充分享受"云"的低成本优势
通常只要花费几百美元、几天时间，就能完成以前需要数万美元、数月时间才能完成的任务
3.三种使用方式 ①公有云
就是基础设施完全自己不搭建，只关心怎么使用
公有云分为以下几类:
传统的电信基础设施运营商，比如中国移动、中国联通、中国电信等提供的公有云服务
一类是政府主导的地方性云计算平台，也就是常说的政府云
互联网巨头打造的公有云平台
部分IDC运营商
还有部分国外的云计算企业
②私有云
自己搭建云的环境，设施设备需自己或第三方维护
私有云是为一个用户单独使用而构建的，因而在数据安全性以及服务质量上自己可以有效的管控，私有云的基础是首先你要拥有基础设施并可以控制在此设施上部署应用程序的方式
私有云可以部署在企业数据中心的防火墙内，核心属性是专有资源，比如我们经常使用且比较典型的私有云有 VMware、OpenStack
③混合云
将公有云和私有云结合起来是很多企业的使用方式
一般的将核心业务，放在自己的私有云上，次要的放在公有云上
但是也会有一些问题：安全性、数据冗余、法律、服务质量方面等
4.服务模型 ①IaaS（基础架构即服务）
提供底层 IT 基础设施服务，包括处理能力、存储空间、网络资源等
面向对象一般是 IT 管理人员
②PaaS（平台即服务）
把安装好开发环境的系统平台作为一种服务通过互联网提供
给用户
面向对象一般是开发人员
③SaaS（软件即服务）
直接通过互联网为用户提供软件和应用程序等服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b92f28f56d3926dc50b324979d1a998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ea31af99340ed58c9c4fe4d81f5e6e/" rel="bookmark">
			【MySQL8.0】workbench添加外键时报错Error Code: 3780
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具体错误信息为： Error Code: 3780. Referencing column ‘Cno’ and referenced column ‘Cno’ in foreign key constraint ‘sc_ibfk_4’ are incompatible.
具体SQL语句为：
alter table sc add foreign key(Cno) references course(Cno) on update cascade on delete cascade; 上网查找后发现应该是sc表中的Cno列和course表中Cno列的字符集设置不同
course表中设置：
sc表中设置：
修改后执行原SQL语句仍旧出错
尝试了半天，最后把字符集设置成这样：
course表：
sc表：
就成功了…
不知道为什么把字符集设置成utf8 / collation设置成utf8_bin就不行
迷惑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1a0068858df3818152555585b4fa8f/" rel="bookmark">
			大数据监控大屏系统，有这些demo就足够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据监控大屏系统，有这些demo就足够了！ 文章目录 大数据监控大屏系统，有这些demo就足够了！大屏展示的资源例子分享 近年来，随着大数据产业的发展，更加高清的可视化平台也相继被应用在各种数据监控大屏场合，这也是整个数据显示平台的主要组成部分。目前，我公司已在全国安装了几百个数据监控大屏可视化显示系统，辅助企业展开数据分析，实现可视化操作。
大屏展示的资源 例子分享 例子分享：http://dt1.8tupian.com/1/9137a21b5000.pg3
例子分享：http://dt1.8tupian.com/1/9137a21b5000.pg3
例子分享：http://dt1.8tupian.com/1/9137a21b5000.pg3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9214d8a86ef932c1e0f05ea6456037e9/" rel="bookmark">
			第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（上海）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 B Mine Sweeper IIC Sum of Log （数位DP）D WalkerE The Journey of Geor AutumnG Fibonacci （签到）H Rice ArrangementI Sky GardenL Traveling in the Grid WorldM Gitignore 链接：https://ac.nowcoder.com/acm/contest/9925
B Mine Sweeper II 题意：给定一张 n × m n\times m n×m 的扫雷图 A 和 B。让你修改 B ，使得它们扫雷图上的数字之和相加相等。修改次数不超过 ⌊ n m 2 ⌋ \lfloor \frac {nm}{2} \rfloor ⌊2nm​⌋
思路：
首先分析一下 A 和 A 的反图，可以发现它们的数字之和是相等的。可以对有雷和无雷连一条边。边的数量，就是贡献的数量。现在把图取反了，依然是原来的连边情况，贡献不变。所以计数图 A 和 B 的不同点的数量，如果超过了一半，就输出 A 的反图就好了。 C Sum of Log （数位DP） 题意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9214d8a86ef932c1e0f05ea6456037e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b95e8395726b19e97c320b87ee3bc03/" rel="bookmark">
			Java-ThreadPoolExecutor使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java-ThreadPoolExecutor使用 线程池主要由以下4个核心组件组成。
线程池管理器：用于创建并管理线程池工作线程：线程池中执行具体任务的线程任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能被线程池调度任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将从队列中移除 ThreadPoolExecutor 如下是线程池的构造方法
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b95e8395726b19e97c320b87ee3bc03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0de6a42405883b36f615ba9b24c485d/" rel="bookmark">
			Unet相关介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老师的bloghttps://zhuanlan.zhihu.com/p/370931792。写的比我这个好，233
Unet是在Fcn基础上提出的一种应用于医学影响的分割网络。医学影像的特点是1、数据集小。2、单张图片大。
由于以上医疗影像的特点，我们无法直接用Fcn进行分割学习。一个德国团队提出了Unet网络设计在，做到了仅仅用30张医疗影响的数据集就取得了相当不错的效果。我认为Unet与fcn主要有以下几点差异：
使用了overlap-tile策略。它是对一张大的医疗影响先分成一小块一小块进行分割训练（388*388大小的子图）。最终将这一小块一小块的分割图拼接起来。这个与fcn相比，fcn的尺寸是直接拿原图的尺寸，而医疗原图的尺寸是很大的，训练起来featuremap尺寸就很大计算要求很高。另外这里分割成一个个小图直接解决了医疗影响数据集图片少的问题。为了结果能够无缝进行拼接，每次下采样maxpooling的时候x，y方向上的尺寸都需要是偶数被2给整除。我们发现上图写的input image后面有个tile。网络输入的是572*572尺寸的，最后结果是388*388的尺寸的。这里572*572可以认为是388*388的padding出来的。和fcn不同的是，fcn比较简单粗暴直接padding了100的0。这里认为直接padding0对于边缘信息处理是不好的。unet是拿原图边缘的内容进行填充。（如果388*388子图正好在边缘位置没法用原图padding，则使用了镜像padding的方法，直接对应位置做了个镜像填充进去）。特征融合程度区分。fcn最多融合到8s。而Unet对所有上采样的特征图与原图进行了融合，融合了更多的尺度。（如图U型，左右对称的）特征融合方式不同。fcn融合的时候采用了+法，将特征图上的element进行相加。而unet用了concat的方法在channel维度上进行了堆叠。（老师的说法是，unet由于overlap的策略网络计算更高效了，而concat增加了channel也就是增加了计算量在这里是可以接受的） 关于unet训练的数据增强方式。可以使用图像的弹性变化进行增强。这个也是医疗影像数据的一个特性。
针对医疗图像样本少的问题，我们极大的使用了弹性变换的方式进行了数据增强。
医疗影像数据样本有一个问题就是数据不均衡的问题。我们发现医疗影像的背景像素在图中的占比是非常小的。老师在课上讲的解决方式是像这样的数据不均衡问题直接在loss上做文章。我们结合论文看一下具体的做法。我们利用了一个加权的loss，其中背景loss分配了一个大的权重。
我们看一下实际论文中是如何训练的。为了最小化开销和最大化利用gpu我们更偏向于把数据集训练的批次设定为1，把大图分割成多个小图进行训练。
如下图是实现权重的公式。这里有个疑问点是w-c的数据是如何计算的，文章中对w0和sigma做了明确的定义。w-c我后来问了老师，老师也查了下相关资料做了一些猜想（由于老师查了官网也没有提及wc的具体计算方法）https://zhuanlan.zhihu.com/p/371676082。后来也有同学数了下fig.3c，白点/黑点≈1.46，黑色最纤细的地方是1像素宽，代入公式就是1.5 + 10 * exp(-(1+1)**2 / 2/5/5) ≈ 10.7，目测fig.3d的标尺最大值也是10.7；而且，fig4d中面积较大的浅蓝色，目测对应标尺的1.46。可能wc就是训练集所有白点/黑点？公式只是针对细胞外的像素，也就是细胞间隙的那些像素的。所以在论文的Fig.3的d图中，只有细胞外的像素对应的权重是渐变的。而细胞内的像素对应的权重取值为1。综合一下我的理解是w-c就是一个数值，只不过c会有不同取值，c的取值和训练集的语义类别相关。如果这个语义类别在总像素总占比小那么w-c这个值就大，反之则小。w-c是用来平衡类别的差异的权重，而公式的后半段是用来加强边界像素误差的权重。
关于卷积权重的初始化也是很重要的，如果这一步没做好可能导致网络的某些部分可能会产生过多的激活，而其他部分则不会。论文里面使用了高斯的初始化方式。高斯的sigma取值与等于神经网络的输入的总节点数量相关。如一个3*3的conv卷积一个64channel的特征图。计算方式是sigma=（2/N）^0.5。N=9*64=576。
以上应该把unet的各个技术细节讲清楚了。其中关于w的计算个人认为是比较难理解的，而且也不确定是否完全理解了原来作者当时的方式，只是理解了大概的一个思路。欢迎大家进行讨论一起进步吧。如果我有新的理解也会在该文章中进行更新
接下来简单介绍以下unet++相关的知识内容。unet++与unet的不同是，unet只有一个“U”，而unet++可以看成有多个u进行融合组成。我简单画以下如下的示意图
unet只有一个“U”进行了下采样后，在进行上采样，上采样的时候与对应层的特征进行concat操作，然后卷积。最后上采样到原尺寸的时候进行conv操作，channel数变为类别数。
unet++有多个“U”，从第二层就有上采样+融合操作。第3层也有，一直到最底层。最后一层上采样后会和其他浅层的u上的特征进行融合。最后和unet一样也进行一个channel为类别数的conv操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322dee4b3dbc1f04467d75cf9bf44ad4/" rel="bookmark">
			夜间灯光数据文章大合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 接下来详细按照以下的目录录制相关视频
数据下载 DMSP/OLS夜间灯光数据下载NPP/VIRRS夜间灯光数据下载珞珈一号夜间灯光数据下载 数据预处理 DMSP/OLS夜间灯光数据预处理 校正方程获取相互校正连续性校正NPP/VIRRS夜间灯光数据预处理珞珈一号夜间灯光数据预处理DMSP/OLS和NPP/VIRRS校正形成长时间序列夜间灯光数据 城市建成区提取 基于夜间灯光数据建成区提取理论介绍阈值确定建成区提取误差分析扩张分析重心迁移分析景观格局指数分析 GDP空间化 空间化理论分析准备数据SPSS分析得到拟合方程误差分析空间化制图空间化结果分析 人口空间化能源消耗空间化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b942a1be8fd7d9e04d3b5af1efcd205d/" rel="bookmark">
			Flutter崩溃时将rout堆栈上报到服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
捕获崩溃并上传
void main() async {
FlutterError.onError = (error) {
Zone.current.handleUncaughtError(error.exception, error.stack);
};
runZonedGuarded&lt;Future&lt;Null&gt;&gt;(
() async {
await _init();
},
(error, stack) async {
String errorStack = '【${error.toString()}】 \n $stack';
errorStack = '$errorStack \n 最后访问的最多$maxNavCount个页面路径如下：\n';
String extra = await navList2String();
errorStack = '$errorStack $extra';
//自己实现
CrashUploadChannel crashUploadChannel = CrashUploadChannel();
crashUploadChannel.uploadCrash(errorStack);
},
);
}
二、
在MaterialApp中监控navigator
Widget _buildMainApp(BuildContext context) {
return MaterialApp(
navigatorObservers: [
UserNavigatorObserver(),
],
三、
user_navigator_observer.dart实现
import 'dart:collection';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b942a1be8fd7d9e04d3b5af1efcd205d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f5c797dabb2bec1d095fb44fc1c2e8/" rel="bookmark">
			python 2.7 linux cv2,【Linux】【Opencv】【Python】安装opencv以及无法使用cv2.imshow()解决办法（Ubuntu14.04）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------【2017.07.14 更新】-------------------------------------------------------
安装opencv3每次cmake都要下载3rdparty，下载很慢还总失败。附上自行下载链接及解决办法：
opencv3.2也可以去官网下载。
先解压缩opencv3.2
cd opencv-3.2.0/3rdparty/ippicv
mkdir unpack
然后解压缩ippicv_linux_20151201.tgz
将解压后的目录mv到unpack目录中
替换ippicv目录中downloader.cmake文件内容为：
#
# The script downloads ICV package
#
# On return this will define:
# OPENCV_ICV_PATH - path to unpacked downloaded package
#
function(_icv_downloader)
# Commit SHA in the opencv_3rdparty repo
set(IPPICV_BINARIES_COMMIT "81a676001ca8075ada498583e4166079e5744668")
# Define actual ICV versions
if(APPLE)
set(OPENCV_ICV_PACKAGE_NAME "ippicv_macosx_20151201.tgz")
set(OPENCV_ICV_PACKAGE_HASH "4ff1fde9a7cfdfe7250bfcd8334e0f2f")
set(OPENCV_ICV_PLATFORM "macosx")
set(OPENCV_ICV_PACKAGE_SUBDIR "/ippicv_osx")
elseif(UNIX)
if(ANDROID AND NOT (ANDROID_ABI STREQUAL x86 OR ANDROID_ABI STREQUAL x86_64))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f5c797dabb2bec1d095fb44fc1c2e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ae8651707bb7ac49d41f75388c12b9/" rel="bookmark">
			依赖包版本号更新 warning package.json: “dependencies“ has dependency “eslint“ with range “^6.8.0“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 warning package.json warning package.json: "dependencies" has dependency "eslint" with range "^6.8.0" that collides with a dependency in "devDependencies" of the same name with version "^6.7.2"
想用各个依赖包的最新版本。如果手动去修改dependencies中各个包的版本号，那就太麻烦了，借助npm-check-updates工具可以很方便的将package.json中的依赖包版本号更新为最新版本
安装 npm install -g npm-check-updates 使用 检查package.json中dependencies的最新版本
ncu 更新dependencies到新版本
ncu -u 更新全部dependencies到最新版本(包括当前指定版本范围满足最新版本号的,比如^4.2.0 -&gt; ^4.3.0)
ncu -a dependencie 配置当前程序所依赖的其他包。
devDependencie 配置当前程序所依赖的其他包，比如一些工具之类的配置在这里
^表示第一位版本号不变，后面两位取最新的 ~表示前两位不变，最后一个取最新 *表示全部取最新 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49eb76f6503fce03a0659bab388f0aa/" rel="bookmark">
			wireshark找不到网卡的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案1：
win+r 输入cmd
右键管理员身份打开命令提示符
输入net start npf
以管理员身份重启wireshark
方法2：
但是如果使用管理员输入net start npf还是报服务名无效，怎么办呢？
1.win+r 输入control 打开控制面板，找到网络和internet–网络和共享中心 找到网卡信息
2.打开控制面板—&gt;网络和Internet—&gt;网络和共享中心查看网络状态和任务—&gt;更改适配器设置
3.右键—&gt;属性
4.检查是否有Pcap Packet Capture Driver;如有直接勾选，确定即可；如没有，则需要安装win10Pcap Packet，下载网址：http://www.win10pcap.org/download/；安装后重复上述步骤进行勾选Pcap Packet Capture Driver即可
方案3：
上述手段如果出现服务找不到
1 打开控制面板，wireshark自带的Npcap(名称：也可能是winpcap)程序卸载
2.wireshark自带的Npcap不支持win10，需要重新下载Win10Pcap，下载地址为http://www.win10pcap.org/download/。安装时需要关闭wireshark，然后重新打开wireshark即可。
3.使用管理员权限打开命令窗口，如下，输入net start npf命令，出现如下提示即可（注意：如命令窗口不是以管理员身份打开，命令会执行失败）。最后以管理员身份打开wireshark软件即可，如下图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f2f087af139693bd7b5c0666deca06/" rel="bookmark">
			uni-app课程笔记2-云数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云数据库编写 基本方法编写 'use strict'; // 引用到云数据库 const db = uniCloud.database() // 运行 在云端（服务器端）的函数 exports.main = async (event, context) =&gt; { // 连接到数据库 const collection = db.collection('user') //event为客户端上传的参数 // context 包含了调用信息和运行状态，获取每次调用的上下文 console.log('event : ', event) //返回数据给客户端 return { code:200, msg:event.name + '的年龄是' + event.age, context } }; 数据库添加 let res = await collection.add([ { name:'vue' }, { name:'html', type:'前端' } ]) 数据库删除 const res = await collection.doc('609a083f0f23980001f1ff24').remove() 数据库更新 const res = await collection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4f2f087af139693bd7b5c0666deca06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1138261ff960d237b57cd4fbd803318d/" rel="bookmark">
			uni-app课程笔记1—基本知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本知识点 不建议data：{}的格式，保留上次的变量值，不会被初始化。
v-bind --- : v-on --- @ v-model --- 双向绑定 自定义组件 关联组件 定义组件之后，页面通过下述语句引用
import btn from '...' components: { btn } 页面往组件传送数据 传送数据 页面中传入的color="red",在子组件中通过下述语句引用到。
props:{ color: { type:String, default:'#000' } } 传送事件（点击事件等改变状态） 页面上写上 @change="change",组件中的按钮事件中
onClick(){ this.$emit('change', this.color) } 组件内接收，变成正常的组件 在子组件中加入&lt;slot&gt;&lt;/slot&gt;插槽
条件编译 #ifdef___#endif #ifndef 在页面中&lt;!-- #ifdef H5 --&gt;
在script中// #ifdef
在样式中 /* #ifdef H5 */
开发布局 引入@import ‘...'
生命周期 应用生命周期–app.vue onLaunch 应用初始化完成触发一次，全局只触发一次
登陆 全局变量
onShow 应用启动的时候，或者从后台进入前台会触发
onHide 应用从前台进入后台触发
页面生命周期–页面中写 onLoad 监听页面加载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1138261ff960d237b57cd4fbd803318d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f69a4c7dfb1c97b25af9bfe320eab58/" rel="bookmark">
			git命令暂存改动（防止拉最新代码与git未提交的改动发生冲突）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git命令：
1、git stash save “任意名” 把暂存区的改动先保存
2、git pull 拉代码
3、git stash apply 取出先前保存的暂存
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/321/">«</a>
	<span class="pagination__item pagination__item--current">322/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/323/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>