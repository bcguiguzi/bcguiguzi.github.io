<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47eb8a4557c23bbafd936df16a28f82f/" rel="bookmark">
			ubuntu系统向日葵连接中断解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu系统向日葵连接中断解决方法： １、终端输入代码： ```python sudo apt-get update sudo apt-get upgrade sudo apt install lightdm ２、切换到 lightdm
sudo dpkg-reconfigure lightdm ３、重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cb12f0a3fff1f504ac8b34edbf7548/" rel="bookmark">
			ubuntu 18.04安装cuda9.0报错cannot find Toolkit in /usr/local/cuda-９.0解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu 18.04安装cuda9.0报错cannot find Toolkit in /usr/local/cuda-９.0解决方法 １、这是因为18.04自带的ＧCC版本为过高造成的首先，CUDA 9.0仅支持GCC 6.0及以下版本，这里降到4.8
gcc 版本安装代码：
sudo apt-get install gcc-4.8 sudo apt-get install g++-4.8 2、装完后进入到/usr/bin目录下
ls -l gcc* 当前gcc版本号的显示
lrwxrwxrwx 1 root root 7th May 16 18:16 /usr/bin/gcc -&gt; gcc-7.0 ３、gcc版本的切换（这里以链接到gcc-4.8为例）
sudo mv gcc gcc.bak #备份 sudo ln -s gcc-4.8 gcc #重新链接 ４、下一步将g++链接改为g+±4.8
sudo mv g++ g++.bak sudo ln -s g++-4.8 g++ ５、再查看gcc和g++版本
gcc -v g++ -v ６、接着安装cuda9.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbf84e4fbc13c102cacb4faab967c2b/" rel="bookmark">
			使用nvidia-smi命令，显卡驱动报错：NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver的解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用nvidia-smi命令，显卡驱动报错：NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver的解决办法. 1、 查看显卡驱动的版本号
ll /usr/src/ 2、执行命令
sudo apt-get install dkms sudo dkms install -m nvidia -v 470.63.01 （470.63.01是显卡驱动版本号） 3、重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec50654a2e6edcaaa19dec94d6fdc094/" rel="bookmark">
			电脑快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑快捷键 word快捷键：
批量更新域-----ctrl A（全选）+F9定位到word最后3次编辑的位置-----shift + F5全部大写字母转换为小写-----shift + F3撤消上一操作 -----Ctrl+Z重复上一操作 -----Ctrl+Y 常用快捷键：
6. Windows+M：最小化所有窗口
7. Windows+Shift+M：还原最小化的窗口
8. Ctrl+W 关闭程序
9.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5026965026db47a2dc5374c3bf90b2/" rel="bookmark">
			骨干网络预训练模型下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 骨干网络预训练模型下载链接 'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth', 'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth', 'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth', 'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth', 'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth', 'resnext50_32x4d': 'https://download.pytorch.org/models/resnext50_32x4d-7cdf4587.pth', 'resnext101_32x8d': 'https://download.pytorch.org/models/resnext101_32x8d-8ba56ff5.pth', 'res2net50_26w_4s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net50_26w_4s-06e79181.pth', 'res2net50_48w_2s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net50_48w_2s-afed724a.pth', 'res2net50_14w_8s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net50_14w_8s-6527dddc.pth', 'res2net50_26w_6s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net50_26w_6s-19041792.pth', 'res2net50_26w_8s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net50_26w_8s-2c7c9f12.pth', 'res2net101_26w_4s': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2net101_26w_4s-02a759a1.pth', 'res2next50': 'https://shanghuagao.oss-cn-beijing.aliyuncs.com/res2net/res2next50_4s-6ef7e7bf.pth' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961feb5b0e908a6edd556bdb6b5c93b9/" rel="bookmark">
			Activiti 7学习_1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activiti7 一、Activiti介绍 ​ Alfresco软件在2010年5月17日宣布Activiti业务流程管理（BPM）开源项目的正式启动，其首席架构师由业务流程管理BPM的专家 Tom Baeyens担任，Tom Baeyens就是原来jbpm的架构师，而jbpm是一个非常有名的工作流引擎，当然activiti也是一个工作流引擎。
Activiti是一个工作流引擎， activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。
Activiti官方网站：https://www.activiti.org/
二、Activiti 7 Demo快速搭建 1、使用IDEA快速搭建一个Maven项目 2、pom.xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.dashu&lt;/groupId&gt; &lt;artifactId&gt;activiti-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;activiti.version&gt;7.0.0.Beta1&lt;/activiti.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--activiti 引擎--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--activiti json数据转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--activiti 云支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt; &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--bpmn 模型处理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--bpmn 布局 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961feb5b0e908a6edd556bdb6b5c93b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8840754d1a5b8eca8fa4289e725fa1c9/" rel="bookmark">
			mybatis动态SQL-＜foreach＞标签实现in集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些业务场景下，有时需要批量插入、批量更新或者查询时参数在多个条件中匹配，比如说查询时在多个条件中匹配，我们使用原生SQL正常会用IN，比如id IN (1,2,3)。在mybatis中可以使用${ids}去直接取值，但我们都知道${}方式去取值，不能防止SQL注入，想要方式SQL注入的话，就要用#{}的方式去取值，如果用#{}去取值，就要配合使用&lt;foreach&gt;标签来满足需求了。
&lt;foreach&gt;标签可以对数组、Map或实现了Iterable接口（常见的如List、Set）的对象进行遍历。数组在处理时会转换为List对象，因此&lt;foreach&gt;标签遍历的对象可以分为两大类，分别是Iterable类和Map类。
下面开始具体分析，代码参照《SpringBoot整MyBatis》中的代码：
查询数据时使用&lt;foreach&gt;标签：
在SysUserMapper.xml中增加id="selectInList"的&lt;select&gt;映射：
&lt;select id="selectInList" resultMap="sysUserMap"&gt; select &lt;include refid="sysUserSql"/&gt; from sys_user where id in &lt;foreach collection="idList" open="(" close=")" separator="," item="id" index="i"&gt; #{id} &lt;/foreach&gt; &lt;/select&gt; SysUserMapper.java新增方法：
/** * @Description 根据idList数组中的id查找人员信息 * @Author chengjunyu * @Date 2022/1/24 22:05 * @Param idList * @Return java.util.List&lt;com.example.mybatis.model.SysUser&gt; * @Exception */ List&lt;SysUser&gt; selectInList(Integer[] idList); SysUserService.java新增方法：
/** * @Description 根据idList数组中的id查找人员信息 * @Author chengjunyu * @Date 2022/1/24 22:06 * @Param idList * @Return java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8840754d1a5b8eca8fa4289e725fa1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f2ed4477175e2fc8fc5186817fea51/" rel="bookmark">
			区块链学习笔记23——ETH反思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链学习笔记23——ETH反思 学习视频：北京大学肖臻老师《区块链技术与应用》
笔记参考：北京大学肖臻老师《区块链技术与应用》公开课系列笔记——目录导航页
智能合约真的智能吗？ 智能合约并没有用到人工智能的技术，有人认为应该叫做“自动合约”，按照事先写好的代码自动执行某些操作。现实世界中自动执行某些操作的例子如ATM取款机，物理世界的自动合约，插入银行卡输入密码，就会自动把钱给你。智能合约其实并不智能，反而有些“笨”，因为一旦写好之后就无法修改，实际上是一种代码合同。
不可篡改性是一把双刃剑 一方面来说不可篡改性增加了合同的公信力，大家都只能按照合约中的规定去做，没有人能篡改。
另一方面不可篡改性也意味着如果规则中有漏洞，想要修补这个漏洞，想软件升级，都是很困难的。在区块链的世界里，软件更新需要硬分叉来实现，无论是比特币还是以太坊，硬分叉都不是随便搞得，以太坊的硬分叉，最后就造成了两条平行的链。而且硬分叉要说明理由，否则矿工不会升级软件，但是一旦说明理由就容易把漏洞的信息泄露出去，有恶意的攻击者可能会在没来得及升级软件之前抢先发动攻击。
另外，即使我们已经发现了系统漏洞，已经有人进行恶意攻击了，想要冻结账户终止交易都是很困难的。要想冻结账户，要进行软发叉，发布一个软件的更新凡是跟这个账户相关的交易都是不合法的，这才能够冻结，但是明显不可能因为个人原因发布一个软分叉，只能把账户剩下的钱尽快转到安全的账户。与之类似，智能合约一旦发布到区块链上，没有办法阻止对它的调用。比如The DAO事件，1/3的钱被黑客盗走了，剩下的2/3的钱也非常危险，但是没有办法阻止别人调用智能合约，唯一的办法是用黑客的方法把钱转到另一个安全的合约。
没有什么是真的不可篡改的 一个篡改的例子就是分叉攻击，以太坊团队通过软件升级的方法强行改变某些账户的状态。一般情况下区块链上的内容想要篡改是很难的，但是遇到重大事件真的想改还是能改得了的。
Solidity语言设计上的问题 solidity的语言特性是反自然的，一般的理解，我给你转账，你是一个被动的接受者，你不可能反过来调用我，但是solidity的语言特性是说我给你转账的操作等于隐性地调用了你的fallback函数，结果你就可以再来调用我。这个和生活常识不同所以安全漏洞容易被忽略。
有人提出应该用函数式的编程语言，函数式语言(例如：ocaml)比较安全不容易出现这种漏洞
编写智能合约的语言应该有什么样的表达能力？ solidity 语言是图灵完备的，但是会有漏洞，比特币脚本语言比较简单，目前没有发现任何漏洞。能不能找到一个比比特币语言复杂又比solidity简单的语言？不容易出现安全漏洞。
很难找到，因为在设计语言的时候不可能预知到其所有的使用场景
解决方法：可以向常用的智能合约提供一些模板，也有可能会出现专门编写智能合约的机构就像律师事务所一样。
开源的好处 去中心化的系统像如区块链都是开源的，也就是透明的，因为必须要让所有的节点都执行同样的内容才能达成共识。
开源的一个好处就是增加合约的公信力，接受群众的监督。
有些人认为开源的另外一个好处是安全，因为全世界的人都在看着这些代码，那么为什么开源软件还会出现漏洞呢？这种现象叫做many eyeball fallacy错误认知的意思，相当于misbelief。但实际上真正有时间看代码的人少之又少，看的人不是很多，也不一定能看得懂。
关于去中心化 以太坊的硬分叉真的就是以太坊的开发团队说了算的吗？
不是，这个硬分叉能成功，也是90%的绝大多数的矿工升级了软件用行动支持了硬分叉，剩下的一小部分虽然没有支持，但是也依然在旧链上继续挖矿，以太坊团队也没有办法强制所有人都升级软件。去中心化并不是不能修改已经制定的规则，而是修改规则要用去中心化的方式进行。硬分叉的成功是因为大多数的矿工认为以太坊团队的措施是符合公众利益的。
而分叉正好是去中心化系统的体现，因为只有去中心化系统，用户才可以选择分叉，中心化系统只能选择继续或者放弃。存在分叉的现象恰恰是民主的体现，比如系统私自增多以太币供给量，使得以太币贬值，矿工就可以选择分叉继续维护原来的以太币
去中心化与分布式不是等价的 一个去中心化的系统必然是分布式的，如果这个系统只运行在一台计算机上，显然不能叫去中心化；但是分布式系统不一定是去中心化的，即使这个系统运行在成千上万的计算机上，如果计算机都是由同一个组织管辖的，那也不是去中心化，比如谷歌的search engine；在一个分布式的平台上可以运行一个中心化的应用，也可以运行一个去中心化的应用。
比特币和以太坊都是交易驱动的状态机，state machine的特点是让系统中几千台机器重复做同一组操作，付出很大的代价来维护状态的一致性，这个并不是分布式系统常用的工作模式，大多数的分布式是让每台机器做不同的事情，然后再把各台机器的工作结果汇总起来，目的是比单机速度快。状态机的目的不是为了比一台计算机的处理速度快，而是为了容错。状态机最早的应用场景：mission critical application.特点是应用程序必须无间断的对外提供服务，哪怕宕机一分钟都会造成很大的损失，所以他才有好几组计算机重复同一组操作，这样即使有一台计算机故障，剩下的计算机也可以对外提供服务。 eg: airtraffic control; stock exchange; space shuttle.这样付出的代价是效率很低，几台机器合在一起比一台机器慢，因为需要同步状态，而且集群里的数目越多速度越慢，所以传统利用状态机的应用场景，机器的数目都是比较少的，可能就是个位数字。像比特币和以太坊这样上千台机器重复同一组操作，之前是没有出现过的。
智能合约是编写控制逻辑的，只有那些互不信任的实体之间建立共识的操作才需要写在智能合约里。大规模存储和计算不适用，又慢又贵，因为还要消耗汽油费，使用云服务平台更好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74ded7c589614f9ca7a3b8a2f78ec85/" rel="bookmark">
			区块链学习笔记22——ETH-TheDAO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链学习笔记22——ETH-TheDAO 学习视频：北京大学肖臻老师《区块链技术与应用》
笔记参考：北京大学肖臻老师《区块链技术与应用》公开课系列笔记——目录导航页
DAO：Decentralized Autonomous Organization（去中心化的自治组织） 建立在代码上，规章制度写在代码中，通过共识协议来维护规章制度的正常运行。
DAC：Decentralized Autonomous Corporation（去中心化的自治公司） 出于营利目的，DAO可以是出于非营利目的。
在2016年5月出现了一个致力于众筹投资的DAO——TheDAO：本质是一个智能合约，你可以把以太币发给智能合约，然后换回TheDAO的代币，决定投资哪个项目时是投票决定的，投票权重由TheDAO的代币决定，收益也是按照智能合约的规章制度进行分配。
TheDAO是一次伟大的尝试，很快吸引了大量的资金，但是很快就失败了
splitDAO函数 如果有人的投资理念与大部分人不同，可以通过splitDAO拆成出一个子基金，之前的代币会被收回，换成相应数量的以太币打到子基金里，然后投资自己想投的项目，这也是取回钱的唯一方式。
拆分前有7天的辩论期，拆分后有28天的锁定期
黑客通过重入攻击转走了5000w美元的以太币，差不多总资金的1/3
以太坊社区讨论解决方法分成两派
一派是回滚交易：有28天的锁定期，黑客暂时还无法把钱取走，通过回滚交易保证投资者的利益。
另一派认为不需要补救：因为黑客的行为并没有违法，code is law，代码中的漏洞也是规则的一部分
以太坊开发团队支持采取补救措施
补救措施 从发生黑客攻击的前一个区块开始分叉，上面的链不挖了，挖下面的链使下面的链更长。
但这样会使得后面许多合法的交易也被回滚，要想回滚必须精确定位，只回滚黑客盗取以太币的交易，这是采取补救措施的原则
开发团队制定了“两步走”方案：
软分叉方案：锁定黑客账户，开发团队发布了一个软件升级，增加一条规则——凡是跟TheDAO这个基金相关的账户不允许做任何交易。这是一个软分叉。
但是发布之后有一个bug——与汽油费有关，与The DAO的账户相关的交易不予执行，这时要不要收取汽油费？
这条新规则没有收取汽油费，这时可能会有一些恶意的攻击者不断发送这种非法的交易浪费矿工的资源，这就导致本来已经升级的大多数矿工纷纷回滚软件升级，改回了之前的版本，于是这种软分叉的方案就失败了。这时28天的锁定期剩下的已经不多了。硬分叉方案：通过软件升级把TheDAO账户上的所有资金强行转到另一个智能合约上，这个智能合约只有一个退钱功能。升级的软件中规定了强制执行的具体日期，到192W个区块自动执行转账交易，不需要合法的签名，在软件中写死的规则，所以旧的矿工是不会认可的，所以属于硬分叉。 最后通过投票决定大部分矿工支持硬分叉，升级了硬分叉的版本，于是大家就等待着挖出192W个区块的时刻，这次没有出现意外，硬分叉成功了
但是，当初反对硬分叉的人并没有因为投票结果改变立场，所以旧的链并没有消亡，还有矿工在挖矿，只不过算力大幅下降了，但是挖矿难度也大幅下降了，所以还是有矿工愿意在旧链上挖的。
旧链上的以太币：ETC
新链上的以太币：ETH
但是分裂出两条链给管理上带来了混乱，比如重放攻击，新链的交易放到旧链是合法的，旧链的交易放到新链也是合法的，后来给这两条链加了chainID区分开来
Q：为什么当初硬分叉和软分叉的操作是针对所有The DAO的账户，而不是只针对黑客的账户？
智能合约一旦发布，不能修改，这个bug不能修复，这次黑客用了，下次其他的账户也可以用，任何人都能成为黑客，这个合约就作废了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335ae1d5b3045b32306d4437c2dab7a5/" rel="bookmark">
			python报错系列(7)--ValueError: Expected more than 1 value perchannel when training, got input size ....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 256, 1, 1])2、解决方式总结 前言 1、ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 256, 1, 1]) 大致意思是，由模型中BN层属性决定，训练完train样本后，生成的模型model要用来测试样本。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。
2、解决方式 在测试之前加上model.eval()
备用思路1参考：
模型中用了batchnomolization，训练中用batch训练的时候，应该是有单数，比如dataset的总样本数为17,你的batch_size为8,就会报这样的错误。
解决方式：
从dataset中删掉一个sample。
备用思路2参考：
看上去是因为 BN层里，遇到了batch=1的情况
解决方式：
设置 batch_size&gt;1, 且 drop_last=True
DataLoader(train_set, batch_size=args.train_batch_size, num_workers=args.num_workers, shuffle=(train_sampler is None), drop_last=True, sampler = train_sampler) 总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103c518d7cf6d013ba5389f41291d3b6/" rel="bookmark">
			vector原理、存储、遍历、缩容、迭代器失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector比较详细的原理及用法 存储数据 void text() { // 存储int类型数据，当然也可以存储其它类型如char、string、类等 vector&lt;int&gt; vec; vec[0] = 10; vec[1] = 9; } 上面这种存储方式是错误的！vector是数组的确没有错，但是最开始的vec是没有大小的，所以是没有办法用下标这种方式赋值的。
可以把vec的容量(capacity:数组的大小)和大小(size:数组中元素的个数)打印出来 cout &lt;&lt; "size = " &lt;&lt; vec.size() &lt;&lt; ", capacity = " &lt;&lt; vec.capacity() &lt;&lt; endl; 结果是size = 0, capacity = 0
正确的存储方式如下：
vector&lt;int&gt; vec; cout &lt;&lt; "size = " &lt;&lt; vec.size() &lt;&lt; ", capacity = " &lt;&lt; vec.capacity() &lt;&lt; endl; vec.push_back(1); vec.push_back(2); vec.push_back(3); cout &lt;&lt; "size = " &lt;&lt; vec.size() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103c518d7cf6d013ba5389f41291d3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052aa976c51f72d02468819831880369/" rel="bookmark">
			Latex IEEE模板-多作者多单位的几种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EEE模板会议论文对于多作者多单位的文章，有好几种写法，我这里都给列一下。
IEEE模板的下载地址：IEEE - Manuscript Templates for Conference Proceedings
写法一 \author{ \IEEEauthorblockN{San Zhang\IEEEauthorrefmark{a*}, Si Li\IEEEauthorrefmark{a,b}, Wu Wang\IEEEauthorrefmark{b}} \IEEEauthorblockA{\IEEEauthorrefmark{a} School of Computer Science, Wuhan University, Wuhan, China} \IEEEauthorblockA{\IEEEauthorrefmark{b} Department of Computer Science and Technology, Tsinghua University, Beijing, China} \IEEEauthorblockA{\{zhangsan\}@XXX.com, \{lisi, wangwu\}@XXX.edu.cn} 写法二 \author{ \IEEEauthorblockN{San Zhang$^{a*}$, Si Li$^{a,b}$, Wu Wang$^b$} \IEEEauthorblockA{$^a$ School of Computer Science, Wuhan University, Wuhan, China} \IEEEauthorblockA{$^b$ Department of Computer Science and Technology, Tsinghua University, Beijing, China} \IEEEauthorblockA{\{zhangsan\}@XXX.com, \{lisi, wangwu\}@XXX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052aa976c51f72d02468819831880369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668a239dc95d02e168b023ca21b8e737/" rel="bookmark">
			VS预生成事件/生成后事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行 打开项目，右击项目，打开属性—&gt;配置属性–&gt;生成事件，如图所示：
可以在命令行中直接填入copy，xcopy等DOS文件复制命令。如同下图所示：
可以在拷贝命令行中看到诸如TargetPath, ProjectDir, ProjectName, TargetDir。而具体这些变量的值可以在点击宏之后弹出的框中查找具体含义：
VS官方帮助网站提供了详尽的的宏命令使用说明与参考，此处转载如下：
宏 说明
$(ConfigurationName) 当前项目配置的名称，例如，“调试”。
$(OutDir) 相对于项目目录的输出文件目录的路径。 这解析为输出目录属性的值。 它包括尾随反斜杠“\”。
$(DevEnvDir) Visual Studio 的安装目录（使用驱动器和路径进行定义）；包括尾随反斜杠“\”。
$(PlatformName) 当前目标平台的名称。 例如，“AnyCPU”。
$(ProjectDir) 项目的目录（使用驱动器和路径进行定义）；包括尾随反斜杠“\”。
$(ProjectPath) 项目的绝对路径名称（使用驱动器、路径、基名称和文件扩展名进行定义）。
$(ProjectName) 项目的基名称。
$(ProjectFileName) 项目的文件名称（使用基名称和文件扩展名进行定义）。
$(ProjectExt) 项目的文件扩展名。 文件扩展名之前包括“.”。
$(SolutionDir) 解决方案的目录（使用驱动器和路径进行定义）；包括尾随反斜杠“\”。
$(SolutionPath) 解决方案的绝对路径（使用驱动器、路径、基名称和文件扩展名进行定义）。
$(SolutionName) 解决方案的基名称。
$(SolutionFileName) 解决方案的文件名称（使用基名称和文件扩展名进行定义）。
$(SolutionExt) 解决方案的文件扩展名。 文件扩展名之前包括“.”。
$(TargetDir) 生成的主输出文件的目录（使用驱动器和路径进行定义）。 它包括尾随反斜杠“\”。
$(TargetPath) 生成的主输出文件的绝对路径名称（使用驱动器、路径、基名称和文件扩展名进行定义）。
$(TargetName) 生成的主输出文件的基名称。
$(TargetFileName) 生成的主输出文件的文件名称（使用基名称和文件扩展名进行定义）。
$(TargetExt) 生成的主输出文件的文件扩展名。 文件扩展名之前包括“.”。
语法 if not exist "$(TargetDir)AudioSource" md "$(TargetDir)AudioSource" // 如果不存在AudioSource目录 就创建改目录 copy "$(SolutionDir)Source\Model\AlarmHandle\Audio\ALARM1.WAV" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/668a239dc95d02e168b023ca21b8e737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1c457698788cf6e14c7044024d0ea2/" rel="bookmark">
			两种蛇形矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在经历了无数个大坑，一步步调整，这玩意对初学者太不友好了，不过它可以提高你对于矩阵的理解，快速掌握二位数组！
今天主要说两种形式的矩阵：
第一种：绕圈型蛇形矩阵 样例如下：
1 2 3 4
12 13 14 5
11 16 15 6
10 9 8 7
这种数组的写法比较奇特，在看了网上很多教程之后我感觉还是较为繁杂，因此我建议小白可以学习一下这种写法，很方便，记下来就好。代码如下，会附赠讲解
#include &lt;iostream&gt; using namespace std; int main() { int a[100][100]; int x = 1, y = 0, k = 1; int n; cin &gt;&gt; n; while (k &lt;= n * n) { ; while (y &lt; n &amp;&amp; !a[x][y + 1]) a[x][++y] = k++; while (x &lt; n &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c1c457698788cf6e14c7044024d0ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d2497b83c15595db4577e6a00f14b0/" rel="bookmark">
			UPC2022新生赛30场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 G: 数字替换 题目描述
味味很喜欢玩一个数字替换的游戏，数字替换游戏是这样的：给出一个 n 位正整数 a， 然后再给你一个长度为 m 的数字序列 b，味味可以用 b 中的一些数字与 a 中各个位置上的 数字进行一对一的交换（当然也可以选择不交换）。当然 b 中的每个位置上的数字最多只能 被使用一次。这个游戏的目的是经过一系列替换后，使 a 的数值达到最大。
味味很聪明，在位数不多的情况下，总能快速的求出最后 a 的最大数值，但是当 n 很 大时，味味就无能为力了，所以她希望会写程序的你帮助她快速的求解 a 最后能到达的那 个最大值。
输入
输入共包含三行。第一行两个用空格隔开的正整数 n，m。第二行一个正整数 a（a 的最高位必定不是 0）。第三行一个长度为 m 的数字序列 b。
输出
输出仅包含一行一个数值，表示 a 最大可能达到的数值（输出不能含前导0）。
样例输入 Copy
4 3 1024 010 样例输出 Copy
1124 提示
b 中的一个 1 和 a 中的第二位上的 0 进行交换。
对于 20%的数据 1≤n，m≤10 对于 50%的数据 1≤n，m≤2000 对于 100%的数据 1≤n，m≤100000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d2497b83c15595db4577e6a00f14b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377d534ccd49da46d4de654b4fbff3a9/" rel="bookmark">
			C&#43;&#43; Primer 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 函数基础局部对象自动对象局部静态对象 参数传递传值参数传引用参数const形参和实参指针或引用形参与const 数组形参const引用形参 含有可变形参的函数initializer_list形参 返回类型和return语句无返回值函数有返回值的函数返回数组指针 函数重载重载与作用域 特殊用途语言特性默认实参内联函数constexpr函数constexpr和常量表达式constexpr变量字面值类型指针和constexpr 函数匹配函数指针使用函数指针重载函数指针函数指针形参返回指向函数的指针 函数基础 通过调用运算符来执行函数，调用运算符为()。
函数调用完成两项工作：第一、实参初始化函数对应的形参；第二、将控制权转移给被调函数，也就是说，主调函数的执行被暂时中止，被调函数开始执行。
函数结束完成两项工作：第一、返回return语句中的值；第二、控制权从被调函数转移回主调函数。
局部对象 名字有作用域、对象有生命期。
作用域是指名字发挥作用的区域，通常而言，一组花括号就是一个作用域。以以下代码为例，两个变量名称相同，但表示的对象不同，他们分别属于不同的作用域，同时，外部也无法访问循环作用域中的a与i。
生命期是指对象在内存中存在的时间。
int a=1; for(i=0;i&lt;6;i++){ int a=i; cout &lt;&lt; a &lt;&lt; endl; } 形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域内可见。主函数中的变量也是局部变量，只有在主函数之外定义的才属于全局变量。
在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁局部变量的生命周期依赖于定义的方式。
自动对象 把只存在于块执行期间的对象称为自动对象。当块执行结束后，块中创建的自动对象的值就变成未定义的了。
形参是一种自动对象。如果局部变量对应的自动对象本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化，即产生未定义的值。
局部静态对象 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止时才被销毁，在此期间即使对象所在函数结束执行也不会对它有影响。
如果没有显式的初始值，内置类型的局部静态变量的初始化为0。
参数传递 形参初始化的机理和变量初始化一样。
如果形式参数是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形式参数。
当形式参数是引用类型时，称对应的实参被引用传递，或函数被传引用调用。
当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。称对应的实参为值传递或者函数被传值调用。
传值参数 初始值拷贝给变量，此时，对变量的改动不会影响初始值。
指针形参可以访问函数外部的对象，但是在C++中建议使用引用类型。
传引用参数 可以实现对实参的更改。有些类型无法拷贝，使用引用使得访问变得可能。可以返回额外的信息（传入额外的引用实参，用于存储信息）。 const形参和实参 当形参是const时，需要注意关于顶层const的讨论。
当形参有顶层const时，传给他常量或者非常量都是可以的。
当形参没有顶层const，传给他顶层const也是可以的。
void fcn(const int i) /*fcn能够读取i，但是不能向i写值*/ 复习：
int i = 0; int *const p1 = &amp;i; /*顶层const*/ const int ci = 42； /*顶层const*/ const int *p2 = &amp;i； /*底层const*/ const int &amp;r = i； /*底层const*/ 拷贝时，底层const作为被拷贝者时，要求拷贝者是底层const，底层const作为拷贝者时，要求被拷贝者也是底层const；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377d534ccd49da46d4de654b4fbff3a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082265d691937a610d1de306b41f86ac/" rel="bookmark">
			BERT参数量计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参数详情说明参数量name = bert/embeddings/word_embeddings:0, shape = (30522, 768)单词表每个单词向量长度是768，一共30522个单词23440896name = bert/embeddings/token_type_embeddings:0, shape = (2, 768)对于输入的任务是两个句子的，需要两个768维度的向量表示是第一个句子还是第二个句子1536name = bert/embeddings/position_embeddings:0, shape = (512, 768)每个位置的embedding向量的表示，每一个位置向量是768维393216name = bert/embeddings/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/embeddings/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_0/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_0/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_0/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_0/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_0/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_0/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_0/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768，全连接之后进行的残差连接589824name = bert/encoder/layer_0/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_0/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_0/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_0/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_0/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_0/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_0/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_0/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_0/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_1/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_1/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_1/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_1/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_1/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_1/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_1/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_1/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_1/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_1/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_1/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_1/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_1/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_1/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_1/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_1/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_2/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_2/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_2/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_2/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_2/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_2/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_2/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_2/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_2/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_2/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_2/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_2/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_2/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_2/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_2/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_2/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_3/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_3/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_3/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_3/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_3/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_3/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_3/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_3/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_3/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_3/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_3/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_3/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_3/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_3/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_3/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_3/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_4/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_4/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_4/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_4/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_4/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_4/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_4/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_4/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_4/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_4/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_4/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_4/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_4/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_4/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_4/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_4/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_5/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_5/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_5/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_5/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_5/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_5/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_5/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_5/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_5/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_5/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_5/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_5/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_5/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_5/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_5/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_5/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_6/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_6/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_6/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_6/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_6/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_6/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_6/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_6/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_6/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_6/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_6/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_6/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_6/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_6/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_6/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_6/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_7/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_7/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_7/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_7/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_7/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_7/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_7/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_7/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_7/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_7/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_7/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_7/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_7/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_7/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_7/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_7/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_8/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_8/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_8/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_8/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_8/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_8/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_8/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_8/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_8/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_8/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_8/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_8/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_8/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_8/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_8/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_8/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_9/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_9/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_9/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_9/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_9/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_9/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_9/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_9/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_9/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_9/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_9/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_9/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_9/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_9/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_9/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_9/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_10/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_10/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_10/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_10/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_10/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_10/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_10/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_10/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_10/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_10/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_10/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_10/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_10/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_10/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_10/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_10/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_11/attention/self/query/kernel:0, shape = (768, 768)这个是输入矩阵形状对应的query,正常是(768,12*64)所以最后变成了(768, 768)589824name = bert/encoder/layer_11/attention/self/query/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_11/attention/self/key/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的key，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_11/attention/self/key/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量768name = bert/encoder/layer_11/attention/self/value/kernel:0, shape = (768, 768)这个是输出矩阵形状对应的value，因为是self-attention,所以输出与输入的形状是相同的，所以也是(768, 12*64)589824name = bert/encoder/layer_11/attention/self/value/bias:0, shape = (768,)因为上面后者是12*64=768，所以最后是768维度的向量589824name = bert/encoder/layer_11/attention/output/dense/kernel:0, shape = (768, 768)全连接第一层 768*768589824name = bert/encoder/layer_11/attention/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_11/attention/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_11/attention/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_11/intermediate/dense/kernel:0, shape = (768, 3072)全连接第二层是768*30722359296name = bert/encoder/layer_11/intermediate/dense/bias:0, shape = (3072,)全连接对应的bias3072name = bert/encoder/layer_11/output/dense/kernel:0, shape = (3072, 768)全连接第三层，将神经元的个数降低到768，好进行下一层的multi-head attention2359296name = bert/encoder/layer_11/output/dense/bias:0, shape = (768,)全连接对应的bias768name = bert/encoder/layer_11/output/LayerNorm/beta:0, shape = (768,)LayerNorm beta参数，因为单词向量表示是768维，所以是768个768name = bert/encoder/layer_11/output/LayerNorm/gamma:0, shape = (768,)LayerNorm gamma参数，因为单词向量表示是768维，所以是768个768name = bert/pooler/dense/kernel:0, shape = (768, 768)因为该任务是判断两个句子是否是一个含义的任务，使用[CLS]向量，先进行一层全连接589824name = bert/pooler/dense/bias:0, shape = (768,)全连接对应的bias768name = output_weights:0, shape = (2, 768)因为是二分类任务，所以需要将向量的维度降低到21536name = output_bias:0, shape = (2,)全连接对应的bias2116552450 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c9b631ab14fe92c63eda502c964e58/" rel="bookmark">
			【实战】python 小型商品销售统计系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、分析
二、代码
一、分析 1、首先定义一个空列表，防止在循环定义列表，导致列表重置
list = [] 2、因为要进行循环输入商品信息，所以要用while Ture进行循环，用break终止循环
while True: break 3、进行输入商品信息，防止输入为空值，所以要进行一次循环判断：
name = input('请输入商品名称：') while name == '': name = input('禁止为空，请重新输入：') 4、当完整的输入一次商品信息时，要将其赋值到字典
dict = {'商品名称': name, '价格': price, '销量': quantity, '成本': cost} 5、 如果输入多次字典，需要将其添加到列表中，用到append（）方法
list.append(dict) 6、 当终止循环的时候，需要进行判断，返回break，终止循环
a = input('是否继续(1:是；2：否)') if a == str(2): break 7、 按照销售额和成本进行排序：
1.如果列表长度为1，直接输出
if len(list) == 1: print('按照销售额排序:', list) print('按照利润排序:', list) 2.如果列表长度不为1，进行排序，用到sort（）方法
else: list.sort(key=lambda x: (int(x['价格']) * int(x['销量'])), reverse=True) print('按照销售额排序：', list) list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c9b631ab14fe92c63eda502c964e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acedb168004e142939d68f15af002145/" rel="bookmark">
			HTML标签：区块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本章介绍HTML的区块标签， &lt;div&gt; 元素是块级元素，没有特定的含义，它可用于组合其他 HTML 元素的容器。 &lt;span&gt; 元素是内联元素，也没有特定的含义。，可用作文本的容器。
&lt;!DOCType html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;块级标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="color: chocolate;"&gt; &lt;h5&gt;标题1&lt;/h5&gt; &lt;p&gt;···段落···&lt;/p&gt; &lt;p&gt;我有一只拥有&lt;span style="color: cornflowerblue;"&gt;蓝色&lt;/span&gt;眼睛的猫&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef0b2eb2b16bd609dbf56ff01063d7e/" rel="bookmark">
			https://en.wikipedia.org/wiki/Linux Foundation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://en.wikipedia.org/wiki/Linux_Foundationhttps://en.wikipedia.org/wiki/Linux_Foundation
目录
Goals[edit]
Initiatives[edit]
Community Data License Agreement (CDLA)[edit]
Linux.com[edit]
Linux Foundation Public Health (LFPH)[edit]
LF Climate Finance Foundation[edit]
Training and certification[edit]
Patent Commons Project[edit]
Projects[edit]
ACRN[edit]
AllJoyn[edit]
Automotive Grade Linux[edit]
Carrier Grade Linux[edit]
CD Foundation[edit]
Cloud Foundry[edit]
Cloud Native Computing Foundation[edit]
CHAOSS[edit]
Code Aurora Forum[edit]
Core Embedded Linux Project[edit]
Core Infrastructure Initiative[edit]
Delta Lake[edit]
DiaMon Workgroup[edit]
DPDK[edit]
Dronecode[edit]
EdgeX Foundry[edit]
ELISA[edit]
FD.io[edit]
FinOps Foundation[edit]
FOSSology[edit]
FRRouting[edit]
GraphQL Foundation[edit]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef0b2eb2b16bd609dbf56ff01063d7e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/267/">«</a>
	<span class="pagination__item pagination__item--current">268/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/269/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>