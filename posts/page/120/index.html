<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b958a263ae59af43e66c1552fe3ff38/" rel="bookmark">
			XWayland 23.2 正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XWayland 23.2 已正式，此版本支持 X11 客户端在 Wayland 环境中运行。
XWayland 23.2 的主要新功能包括通过 libei 库支持模拟输入 (emulated input) 的可选支持、支持 tearing 控制协议GNSS系统，以及 XWayland rootful 模式现在可以使用 libdecor 调整大小。
wp-tearing-control-v1 协议实际上是在需要较低延迟或最大游戏性能，而不考虑完美渲染的情况下，选择性地允许异步页面翻转出现屏幕 tearing。
XWayland 23.2 还为 BSD 带来了 DRM 平台支持，删除了许多无关 / 旧的 DDX 组件，修复了没有 GBM 的构建，以及许多其他修复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11af5d52f2b89b5471b6cd0ed650d699/" rel="bookmark">
			VmWare 虚拟机安装CentOS及网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机安装
虚拟机：VMware
操作系统：CentOS-6.1-x86_64
新建虚拟机
选择自定义
3. 选择虚拟机硬件兼容性，我们用默认下一步即可
安装客户机操作系统 -&gt; 安装来源 -&gt; 选择稍后安装操作系统
接下来选择我们要安装的系统类型和操作系统版本
将系统放到合适的位置
接下来几步按照默认的就行，也可以根据自己主机的配置进行修改虚拟系统配置 注：这里指定的磁盘容量大小为最大的容量，不会在一开始就将主机的磁盘空间分配出去，而是随着虚拟机里的数据量增大，磁盘的占用空间才会增大。
完成创建虚拟机之后，我们开始把CentOS的镜像导入进去
右击虚拟机 -&gt; 设置 -&gt; CD/DVD -&gt; 将自己的系统镜像文件选择 -&gt; 完成
开启虚拟机，安装操作系统
选择第一个选项回车
安装前媒体检查
不想检查的话直接 skip 就行
接下来是CentOS的安装及设置
我们这里是安装一个全新的系统，选择yes
设置系统密码
我自己安装的是用命令行的 Minimal 版本，安装速度快，也去除了我们用不到的软件。可自行选择，如果想使用桌面版的CentOS可以选择 Desktop
点击下一步等待安装，安装完成后，可以选择重启引导或直接重启系统进入到系统中
配置网卡，我们测试一下当前的网络通不通
ping www.baidu.com 直接提示未知的主机
接下来我们修改网卡配置文件，配置我们的系统网络
配置静态ip首先需要打开网卡配置文件
vi /etc/sysconfig/network-scripts/ifcfg-eth0 添加 BOOTPROTO=“dhcp”，修改 ONBOOT=“yes”
​ 使用 service network restart 重启网络服务
​ 再次 ping www.baidu.com 网络通了
如果遇到不能上网的错误排查 Vmware中网关是否正确
直接ping ip是否能通（物理连接排查）
卸载重装最快
或者参考这篇文章 将 NAT 设置的 ipv6 启用，启用后再尝试重启 network 服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11af5d52f2b89b5471b6cd0ed650d699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815721b911041acee2a8ff23c3ae4a1a/" rel="bookmark">
			基于java的进销存管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的进销存管理系统设计与实现
I. 引言 A.研究背景和动机 研究背景：
随着全球化的进展和信息技术的快速发展，企业间的竞争越来越激烈。为了在市场中取得优势，企业需要不断提高经营管理效率，降低成本。进销存管理系统作为企业管理的重要组成部分，对于提高企业运营效率和加强对业务的控制具有至关重要的作用。传统的进销存管理方式已不能满足现代企业的需求，因此，设计和实现一个基于Java的进销存管理系统具有十分重要的研究背景和实际应用价值。
进销存管理系统是一种集采购、销售、库存管理于一体的企业资源计划（ERP）系统。它涉及到企业的物流管理、资金流管理和信息流管理，是企业管理中最为核心的部分。传统的进销存管理方式通常采用人工操作，存在着许多问题，如数据不准确、效率低下、容易出错等。而基于Java的进销存管理系统可以利用计算机技术和网络技术，实现自动化、信息化和智能化管理，从而提高企业的管理效率和核心竞争力。
近年来，随着企业信息化进程的加速和信息技术的发展，进销存管理系统得到了广泛应用。许多企业已经引入了进销存管理系统，实现了采购、销售、库存等业务的自动化管理，提高了管理效率和准确性。此外，许多开源技术和框架也为开发进销存管理系统提供了良好的支持和参考。
动机：
基于以上研究背景和问题现状，设计和实现一个基于Java的进销存管理系统具有以下动机：
提高企业运营效率：基于Java的进销存管理系统可以自动化处理采购、销售、库存等业务流程，减少人工操作，降低错误率，提高管理效率和准确性。优化企业资源利用：进销存管理系统可以提供准确的库存信息，帮助企业合理规划采购和销售策略，避免库存积压和缺货现象，优化企业资源利用。提升企业竞争力：通过引入基于Java的进销存管理系统，企业可以实现信息化管理，提高管理水平和效率，更好地满足客户需求，增强市场竞争力。学习和实践软件开发技术：设计和实现基于Java的进销存管理系统可以提供学习和实践Java语言、数据库技术、网络技术等相关技术的机会，提高软件开发能力和技术水平。解决实际问题和满足需求：通过设计和实现基于Java的进销存管理系统，可以解决企业实际存在的进销存管理问题，提高管理效率和控制力度，满足企业的实际需求。 基于Java的进销存管理系统设计与实现是一项具有重要研究意义和实践价值的课题。通过利用Java语言和相关技术，开发出一个功能完善、高效稳定、易用易维护的进销存管理系统，可以显著提高企业的运营效率和核心竞争力，同时也可以促进企业信息化进程和满足实际需求。此外，该研究课题还可以为相关领域的研究和应用提供有价值的参考和借鉴。
B.目标和意义 基于Java的进销存管理系统设计与实现的目标是提供一个全面、高效、智能的进销存管理解决方案，旨在优化企业进销存管理流程，提高进销存管理效率和服务质量。具体而言，目标包括：
管理进货流程：设计并实现一个能够自动化管理进货流程的功能，包括采购订单、收货记录、入库单等，确保进货流程的高效性和准确性。管理销售流程：设计并实现一个能够自动化管理销售流程的功能，包括销售订单、销售出库单、销售统计等，提高销售流程的效率和准确性。库存管理：设计并实现一个能够实时反映进销存情况的库存管理功能，包括库存查询、库存预警、库存调整等，确保库存信息的准确性和及时性。数据分析与决策支持：通过系统自动生成的报表和统计图表，为管理人员提供准确的数据分析和决策支持，以优化进销存管理流程和决策制定。用户友好性：设计并实现一个操作简单、界面友好的用户界面，提高用户使用系统的效率和体验。 基于Java的进销存管理系统设计与实现具有重要的实际意义和社会价值。
提高进销存管理效率：通过系统的自动化管理和流程优化，提高了进销存管理的效率和服务质量。企业能够快速响应市场需求，提高采购、销售和库存管理的效率。降低成本：通过系统的自动化管理和流程优化，降低了企业在进销存管理过程中的人力和物流成本，提高了企业的盈利能力。提高服务质量：通过系统的实时库存管理和销售流程优化，提高了企业对客户需求的响应速度和服务质量，增加了客户满意度。简化管理流程：传统的进销存管理流程通常繁琐而费时，借助进销存管理系统的设计与实现，企业可以简化许多手工和重复工作，提高工作效率，从而将资源更多地聚焦于核心业务上。提高决策准确性：通过系统的数据分析和决策支持功能，企业能够基于准确的数据进行决策，提高了决策的准确性和有效性。推动数字化转型：随着数字化转型的推进，基于Java的进销存管理系统设计与实现支持企业进销存管理的数字化转型，有助于推动企业数字化转型的进程。 基于Java的进销存管理系统设计与实现旨在提供一种高效、智能的进销存管理解决方案，具有提高进销存管理效率、降低成本、提高服务质量、简化管理流程、提高决策准确性和推动数字化转型等重要意义。同时，通过该项目的学习和实践，能够提高Java编程能力和系统设计能力，为未来的职业发展奠定基础。因此，该项目具有深远的实际意义和社会价值。
II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。Java程序一次编写，到处运行，具有跨平台的优势。
Java语言具有以下主要特点：
简单易学：Java语言借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。跨平台性：Java程序是一次编写，到处运行。Java程序在编译后生成的字节码可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。面向对象：Java语言是一种真正的面向对象编程语言，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。内存管理：Java具有自动垃圾回收机制，程序员无需手动管理内存。通过垃圾回收器，Java可以自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。多线程支持：Java提供了强大的多线程支持，使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java拥有众多的类库和应用程序接口（API），包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。安全性：Java对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。分布式计算：Java提供了强大的网络编程功能，使其成为构建分布式计算应用和网络服务的理想语言。 总的来说，Java语言是一种通用的、高效的、可移植的编程语言，具有强大的功能和良好的安全性。它在各个领域得到广泛应用，特别在Web开发、移动应用开发和企业应用开发领域占据主导地位。Java的应用范围非常广泛，它可以用于开发各种类型的应用，包括桌面应用、Web应用、移动应用、游戏开发等。同时，Java语言还是学习编程和软件开发的理想选择，因为它的易学性和广泛的应用使得学习资源丰富且机会多样。
Java语言的开发环境非常简单，只需要安装JDK（Java Development Kit）即可。JDK包含了Java编译器、Java虚拟机和其他一些工具，可以用来编写、编译和运行Java程序。在Windows、Linux、Mac等操作系统上都可以使用JDK进行开发。
Java语言的学习曲线相对较低，初学者可以通过一些入门级的编程书籍、在线教程和视频教程等资源来学习Java语言的基础知识和编程技巧。同时，Java社区也非常活跃，初学者可以在社区中寻求帮助和支持。
总之，Java语言是一种功能强大、易于学习和使用的编程语言，它在各个领域得到广泛应用，并成为许多程序员的首选语言之一。
B.数据库技术 数据库技术是一种用于存储、管理和操作数据的软件系统。它包括数据库管理系统（DBMS）、数据模型、数据库设计、数据库查询语言、数据库索引、数据库事务、数据库安全性、数据库备份与恢复以及数据库性能优化等内容。
数据库管理系统（DBMS）是一种软件工具，用于管理和操作数据库。它提供了定义、创建、修改和访问数据库的功能。DBMS可以实现数据的添加、删除、查询和更新操作，还可以提供数据安全性保护、事务管理、并发控制等功能。
数据模型是描述和组织数据的形式化表示。常见的数据模型包括层次模型、网状模型、关系模型和对象模型等。关系模型是最常用的数据模型，它将数据组织成表格形式，通过定义表格之间的关系来表示数据之间的联系。
数据库设计是指在数据库系统中创建数据库的过程。它涉及到确定数据的结构、属性、关系和约束等。良好的数据库设计可以提高数据查询和操作的效率，减少数据冗余和不一致性。
数据库查询语言是用于查询和操作数据库的语言。常见的查询语言包括结构化查询语言（SQL）和面向对象的查询语言（OQL）。通过查询语言，用户可以方便地对数据库进行查询、过滤、排序等操作。
数据库索引是一种用于加速查询操作的数据结构。它可以帮助数据库系统快速定位需要查询的数据。常见的索引结构包括B树索引、哈希索引和全文索引等。
数据库事务是一系列对数据库的操作，它要么全部执行成功，要么全部回滚。事务可以确保数据库操作的原子性、一致性、隔离性和持久性。
数据库安全性是指保护数据库免受非法访问、损坏和数据泄露的能力。数据库系统提供了用户身份验证、权限管理和数据加密等安全机制，以确保数据的完整性和机密性。
数据库备份与恢复是保护数据库免受数据丢失和系统故障的措施。数据库备份可以将数据库的副本保存到其他存储设备中，以防止数据损坏。当数据库出现故障时，可以通过恢复机制还原数据库到之前的状态。
数据库性能优化是提高数据库系统的查询和操作效率的过程。通过设计良好的数据库结构、优化查询语句和配置合理的索引，可以提高数据库的响应速度和吞吐量。
数据库技术在各个领域都得到广泛应用。在企业中，数据库技术被广泛应用于企业资源计划（ERP）系统、客户关系管理（CRM）系统和供应链管理系统等。在互联网领域，数据库技术被用于支持大规模的数据存储和管理，如社交网络、电子商务和大数据分析等。在科研和教育领域，数据库技术被用于创建和管理科学数据和图书馆资源。
随着互联网的发展和大数据时代的到来，数据库技术也在不断发展和创新。新型的数据库系统如分布式数据库、云数据库和内存数据库等应运而生，以满足不断增长的数据存储和处理需求。同时，新型的数据存储和处理技术如NoSQL数据库、NewSQL数据库和非关系型数据存储等也在不断发展，为大数据时代提供了更多的数据存储和处理解决方案。
总之，数据库技术是一种重要的软件系统，它为数据的存储、管理和操作提供了有效的手段。随着技术的发展和创新，数据库技术将在未来的数据管理和处理中发挥更加重要的作用。
C.GUI技术 GUI技术是指图形用户界面（Graphical User Interface，简称GUI）技术。GUI是一种基于图形的用户界面，使用图形化方式显示计算机应用程序的操作界面。在GUI中，用户可以通过点击、拖拽、输入文本等方式与计算机进行交互。GUI技术使得用户能够更加直观、方便地操作计算机应用程序。
以下是GUI技术的发展历程和基本组成：
发展历程：
早期的GUI技术：20世纪70年代，出现了最早的GUI技术，如Apple公司的Macintosh和Xerox公司的Alto。这些系统使用位图显示和光标定位，提供了窗口、图标、菜单和鼠标等基本元素。Windows和Mac OS的推出：20世纪80年代，微软公司推出了Windows操作系统，苹果公司推出了Mac OS操作系统。这些操作系统成为了当时最主流的GUI技术，并一直沿用至今。Web技术的发展：20世纪90年代，随着互联网技术的迅速发展，Web浏览器逐渐成为人们使用计算机的主要方式。HTML、CSS和JavaScript等技术为在网页上实现GUI提供了支持。移动设备的发展：21世纪初，随着智能手机和平板电脑等移动设备的普及，移动操作系统如iOS和Android等也逐渐成为GUI技术的主流。跨平台GUI框架的出现：近年来，随着跨平台开发需求的增加，一些跨平台的GUI框架如Electron、Qt和wxWidgets等也逐渐流行。 基本组成：
窗口：窗口是GUI中最大的矩形区域，用于显示信息和接受用户输入。窗口可以包含其他子窗口和控件。图标：图标是小的图形图像，用于表示程序、文件、文件夹等对象。用户可以通过点击图标来启动程序或访问文件等。菜单：菜单是一系列命令和选项的列表，用户可以通过点击菜单项来执行相应命令。控件：控件是用于与程序进行交互的元素，如文本框、按钮、滑块、复选框等。控件可以接收用户的输入并响应用户的操作。对话框：对话框是一种临时窗口，用于显示信息、提示用户输入或提供选项。状态栏：状态栏通常位于窗口底部，用于显示程序状态信息、提示信息等。工具栏：工具栏是一组常用命令或操作的图标集合，用户可以通过点击相应图标来执行操作。滚动条：滚动条用于在窗口中显示超出视图范围的内容，用户可以通过拖动滚动条或点击箭头来浏览内容。 GUI技术使得用户能够以更加直观和便捷的方式与计算机进行交互。GUI技术的发展历程和基本组成是了解计算机用户界面设计的基础。随着技术的不断进步，GUI技术也在不断发展和完善，为用户提供更好的使用体验。
III. 系统需求分析与设计 A.系统功能需求 基于Java的进销存管理系统设计与实现是为了实现对公司进货、销售和库存等业务的有效管理，提高公司的运营效率和降低成本。下面将介绍基于Java实现与实现的进销存管理系统的主要系统功能需求。
采购管理：
采购管理是为了实现对供应商和采购订单的有效管理。该功能要求能够添加、修改、删除和查询采购订单信息，包括采购商品、数量、价格、到货日期等。具体而言，需要提供以下功能： 采购订单录入：允许采购员输入采购订单信息，包括商品信息、数量、价格、到货日期等。采购订单查询：允许采购员通过关键字、供应商等进行采购订单信息的查询，以便快速找到所需订单。采购订单修改和删除：允许采购员对采购订单进行信息修改和删除，如商品信息、数量、价格、到货日期等。供应商管理：允许管理员添加、修改和删除供应商信息，包括供应商名称、联系方式、地址等。 销售管理：
销售管理是为了实现对客户和销售订单的有效管理。该功能要求能够添加、修改、删除和查询销售订单信息，包括销售商品、数量、价格、交货日期等。具体而言，需要提供以下功能： 销售订单录入：允许销售员输入销售订单信息，包括商品信息、数量、价格、交货日期等。销售订单查询：允许销售员通过关键字、客户等进行销售订单信息的查询，以便快速找到所需订单。销售订单修改和删除：允许销售员对销售订单进行信息修改和删除，如商品信息、数量、价格、交货日期等。客户管理：允许管理员添加、修改和删除客户信息，包括客户名称、联系方式、地址等。 库存管理：
库存管理是为了实现对仓库库存的有效管理，包括商品的入库、出库、移库、盘点等操作。该功能要求能够记录库存变化并保持库存数据的实时性和准确性。具体而言，需要提供以下功能： 入库管理：记录商品入库信息，包括入库日期、商品名称、数量、单位等。出库管理：记录商品出库信息，包括出库日期、商品名称、数量、单位等。移库管理：记录不同仓库之间的商品转移信息，包括转移日期、转移仓库、商品名称、数量、单位等。盘点管理：定期对仓库库存进行盘点，记录盘点结果，如盘盈或盘亏的商品名称、数量等。库存查询：允许管理员查询仓库库存信息，包括商品名称、数量、单位等。 统计分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/815721b911041acee2a8ff23c3ae4a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd7de98589707a70597beb2289e7862/" rel="bookmark">
			【信创】银河麒麟 Kylin V10 升级 GCC 操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 银河麒麟 Kylin V10 自带的 GCC 版本比较低（7.3.0），因项目需要将其升级到 7.4.0 版本。
如果要升级到更高版本，过程类似！
升级过程 安装编译环境：
yum -y install make gcc gcc-c++ clang texinfo automake 安装 GCC 编译必需的几个依赖库及头文件：
yum -y install gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel isl isl-devel 编译安装（此过程非常漫长，请耐心等待…）：
wget https://ftp.gnu.org/gnu/gcc/gcc-7.4.0/gcc-7.4.0.tar.xz tar -xf gcc-7.4.0.tar.xz mkdir gcc-7.4.0/build cd gcc-7.4.0/build/ ../configure --prefix=/usr/local --enable-checking=release --enable-languages=c,c++ --disable-multilib make make install 最后，替换旧版本 gcc：
mv /usr/bin/gcc /usr/bin/gcc_7.3.0 ln -s /usr/local/bin/gcc /usr/bin/gcc 安装完毕，现在就去享用吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e714cd4ac573bf6ece92374d777e2f1/" rel="bookmark">
			基于springboot的企业进销存管理系统/进销存管理系统/库存管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
在Internet高速发展的今天，我们生活的各个领域都涉及到计算机的应用，其中包括企业进销存管理系统的网络应用，在外国企业进销存管理已经是很普遍的方式，不过国内的企业进销存管理可能还处于起步阶段。企业进销存管理系统具有产品入库、产品出库功能。企业进销存管理系统采用Java语言，Springboot框架，基于mysql开发，实现了产品库存、产品入库、产品出库、客户订单等内容进行管理，本系统具有良好的兼容性和适应性，为管理者提供更多的信息，也提供了良好的平台，从而提高系统的核心竞争力。
本文首先介绍了设计的背景与研究目的，其次介绍系统相关技术，重点叙述了系统功能分析以及详细设计，最后总结了系统的开发心得。
关键词：企业进销存管理系统；Springboot框架； Java语言；mysql数据库
Abstract
Today, with the rapid development of the Internet, all areas of our life are related to the application of computers, including the network application of enterprise inventory management system. Inventory management has been a very common way in foreign enterprises, but the inventory management of domestic enterprises may still be in its infancy. The enterprise purchase, sales and inventory management system has the functions of product warehousing and product outbound.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e714cd4ac573bf6ece92374d777e2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdd7ebbc8bbba4b1f1bac3df53c0d16/" rel="bookmark">
			深拷贝和浅拷贝的理解及其实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深拷贝和浅拷贝 一、概念 浅拷贝：只拷贝最外面一层额数据；更深乘次的对象，只拷贝引用；
深拷贝：拷贝多层数据；每一层级别的数据都会拷贝；
拷贝引用的时候，是属于传址，而非传值；
深拷贝和浅拷贝主要针对的是对象的属性是对象（引⽤类型），浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改变原对象。
二、 浅拷贝的实现方式 方式1：直接赋值
var c = { name:'tom', age:20 } var d = c; c.name = 'jack'; console.log(d); 方式2：使用 for in
var obj1 = { name: 'tom', age: 20, info: { msg: '是一个中国人' } } var obj2 = {}; //for in for (var k in obj1) { obj2[k] = obj1[k]; } console.log(obj2); obj1.info.msg = '虽然是个外国人，但是很向往中国'; console.log(obj2); 方式3：使用Object.assign(新数据,老数据)
var obj1 = { name:'tom', age:20, info:{ msg:'开心每一天' } } var obj2 = {}; obj2=Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdd7ebbc8bbba4b1f1bac3df53c0d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d2ccb5dcd047fe3860159894465b53/" rel="bookmark">
			【报错解决-Golang】go mod 替换第三方包提示：module declares its path as: ××× but was required as: ×××
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息 在对项目中的一个第三方模块进行版本升级（kingpin从 2.2.6升级到2.3.2）的时候，出现以下报错：
# go mod tidy go: finding module for package gopkg.in/alecthomas/kingpin.v2 go: found gopkg.in/alecthomas/kingpin.v2 in gopkg.in/alecthomas/kingpin.v2 v2.3.2 go: pocscan imports gopkg.in/alecthomas/kingpin.v2: gopkg.in/alecthomas/kingpin.v2@v2.3.2: parsing go.mod: module declares its path as: github.com/alecthomas/kingpin/v2 but was required as: gopkg.in/alecthomas/kingpin.v2 搜遍全网，说啥的都有，但都解决不了我的问题，随即自行分析排查，最终找到原因。
错误原因 需要先修改隐藏在代码文件的模块引用（require）：
import ( "fmt" "os" "os/signal" "path/filepath" // 修改前这里是 gopkg.in/alecthomas/kingpin.v2 "github.com/alecthomas/kingpin/v2" ) 然后再执行下面的操作即可：
go mod tidy // 或 go get github.com/alecthomas/kingpin/v2 作个记录，希望对读者有用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff34c78fb0a22aeaf9a1db5bab2e362/" rel="bookmark">
			VS2022 CMake报错解决小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题背景
二、问题分析
三、问题解决
一、问题背景 VS2022中能够跨平台的工程类型就是CMake项目，一套代码能跨windows/Linux/Mac多种操作系统。而实际使用时，发现相关资料比较少，需要摸索一下。
碰到的问题简述：
1、C++ Intellisense信息可能过时，生成要刷新的CMake缓存。
2、多次定义了变量 CMAKE_INSTALL_PREFIX
3、CMake Error: CMake was unable to find a build program corresponding to "Ninja". CMAKE_MAKE_PROGRAM is not set. You probably need to select a different build tool. 4、CMake Error: CMAKE_CXX_COMPILER not set, after EnableLanguage 5、CMake Error: CMAKE_C_COMPILER not set, after EnableLanguage 二、问题分析 CMake工程中最重要的文件就是CMakeLists文件，其包含工程所有需要的元素，例如下面这个demo。直接用CMakeLists会觉得难用；但用了makefile再用这个就觉得CMakeLists十分友好了。
# CMakeList.txt: CMakeProject1 的 CMake 项目，在此处包括源代码并定义 # 项目特定的逻辑。 # cmake_minimum_required (VERSION 3.8) # 如果支持，请为 MSVC 编译器启用热重载。 if (POLICY CMP0141) cmake_policy(SET CMP0141 NEW) set(CMAKE_MSVC_DEBUG_INFORMATION_FORMAT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff34c78fb0a22aeaf9a1db5bab2e362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0666590eefcff522c167b943e3733f18/" rel="bookmark">
			Monodepth2和Lite-Mono准备数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以KITTI为例下载解压后放在/home/lwd/tmp/2011_09_26 cd /home/lwd/tmp/2011_09_26
ls输出
2011_09_26_drive_0001_sync
2011_09_26_drive_0002_sync
2011_09_26_drive_0005_sync
python txt.py
txt.py import os, sys al=os.listdir('.') al.sort() f=open('train.txt', 'w') for a in al: if not 'sync' in a: continue print(a) b=a+'/image_02/data' png=os.listdir(b) png.sort() for i in range(1, len(png)-1): f.write(a+' '+str(i)+' l\n') f.close() cat train.txt #最后的l（小写L）表示图片在image_02
2011_09_26_drive_0001_sync 1 l
2011_09_26_drive_0001_sync 2 l
2011_09_26_drive_0001_sync 3 l
分析：数据加载代码会调用get_color读取图像，get_color调用get_image_path获取图像路径。以train.txt的第一行为例，图像路径是/home/lwd/tmp/2011_09_26/2011_09_26_drive_0001_sync/image_02/data/0000000001.png准备自己的数据集时，可以按照上述路径构建或修改读取数据代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096e11429e86b2614ce483442f39c81b/" rel="bookmark">
			uniapp条形码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条形码在实际应用场景是经常可见的。
这里教大家如何集成uniapp条形码。条形码依赖类库JsBarcode.
下载JsBarcode源码，对CanvasRenderer进行了改进兼容uniapp。
import merge from "../help/merge.js"; import {calculateEncodingAttributes, getTotalWidthOfEncodings, getMaximumHeightOfEncodings} from "./shared.js"; class CanvasRenderer{ constructor(canvas, encodings, options){ this.canvas = canvas; this.encodings = encodings; this.options = options; } render(){ // Abort if the browser does not support HTML5 canvas // if (!this.canvas.getContext) { // throw new Error('The browser does not support canvas.'); // } this.initSize() setTimeout(() =&gt; { this.prepareCanvas(); for(let i = 0; i &lt; this.encodings.length; i++){ var encodingOptions = merge(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096e11429e86b2614ce483442f39c81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab45e40334769acf0bee91a36123a35/" rel="bookmark">
			linux系统weblogic10.3.6(jar) 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装包 WebLogic Server下载地址https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html
二、安装weblogic 1、用java -jar 安装weblogic
java -jar wls1036_generic.jar 2、设置家的目录 3、确认家目录
4、设置不更新
5、选择安装方式
6、选择jdk，后面标有[x]是代表默认选中的，如果不是你想要的版本，需要自己通过序号来指定
三、创建域 具体方法见我的另一篇博客《linux系统weblogic创建及项目部署过程》
linux系统weblogic创建及项目部署过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a765fd0c49a0e525aedada52578ec2c8/" rel="bookmark">
			EasyExcel工具类&#43;格式适配器接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * Excel数据格式处理适配器 * * */ public interface ExcelHandlerAdapter { /** * 格式化 * * @param value 单元格数据值 * @param args excel注解args参数组 * * @return 处理后的值 */ Object format(Object value, String[] args); } /** * Excel相关处理类 * * */ public class ExcelUtil&lt;T&gt; { private static final Logger log = LoggerFactory.getLogger(ExcelUtil.class); public static final String FORMULA_REGEX_STR = "=|-|\\+|@"; public static final String[] FORMULA_STR = { "=", "-", "+", "@" }; /** * 用于dictType属性数据存储，避免重复查缓存 */ public Map&lt;String, String&gt; sysDictMap = new HashMap&lt;String, String&gt;(); /** * Excel sheet最大行数，默认65536 */ public static final int sheetSize = 65536; /** * 工作表名称 */ private String sheetName; /** * 导出类型（EXPORT:导出数据；IMPORT：导入模板） */ private Excel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a765fd0c49a0e525aedada52578ec2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f29f81b2aa514ceafc3a7c152ceccc/" rel="bookmark">
			dmesg实时打印内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dmesg是一个Linux工具，用于实时打印内核信息和系统日志。它通常用于查看内核的启动消息、硬件信息和驱动程序的调试输出。以下是dmesg实时打印内核的详细说明：
打开终端：打开一个终端窗口，以便执行dmesg命令。
输入命令：在终端中输入以下命令：
dmesg -w
3. 执行命令：按下Enter键执行命令。这将启动dmesg命令，并以实时模式打印内核信息。
查看打印信息：终端会显示出当前的内核信息。你可以通过向上或向下滚动终端窗口来查看更多信息。
打印特定信息：如果你只想查看特定类型的信息，可以将命令与grep过滤器结合使用。例如，如果你想查看关于网络设备的信息，可以使用以下命令：
dmesg -w | grep eth
这将只打印包含”eth”关键字的内核信息。
停止打印：要停止dmesg的实时打印，可以使用Ctrl+C组合键来中断命令执行。 请注意，dmesg实时打印的内核信息可能非常庞大和频繁，如果你只想查看前一段时间的信息，可以执行以下命令：
dmesg -T
这将显示最近的内核信息，并使用日期和时间对其进行标记。
总结：dmesg命令在Linux中用于实时打印内核信息和系统日志。通过在终端中执行”dmesg -w”命令，你可以在实时模式下查看内核信息。你还可以使用grep过滤器来查找特定类型的信息。最后，通过执行”dmesg -T”命令，你可以按时间顺序查看最近的内核信息。
原文链接：https://www.shence123.com/s/15080.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776dde2720c01ddbb65789417861fbf5/" rel="bookmark">
			前端实现下载文件的各种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端涉及到的文件下载还是很多应用场景的，那么前端文件下载有多少种方式呢？每种方式有什么优缺点呢？下面就来一一介绍。
1. a 标签 通过a标签的download属性来实现文件下载，这种方式是最简单的，也是我们比较常用的方式，先来看示例代码：
&lt;a href="http://www.baidu.com" download="baidu.html"&gt;下载&lt;/a&gt; 就上面的这个示例，我们点击下载，发现是跳转到了百度的首页，并没有真的下载文件。
因为a标签下载只能下载同源的文件，如果是跨域的文件，这里包括图片、音视频等媒体文件，都是预览，也无法下载。
上面的代码是直接通过书写a标签来实现文件下载，我们也可以通过js来实现，代码如下：
const a = document.createElement('a') a.href = 'http://www.baidu.com' a.download = 'baidu.html' a.click() 效果和上面的一样，都是跳转到百度的首页，没有下载文件。
这里的重点是a标签的download属性，这个属性是HTML5新增的。
它的作用是指定下载的文件名，如果不指定，那么下载的文件名就会根据请求内容的Content-Disposition来确定，如果没有Content-Disposition，那么就会使用请求的URL的最后一部分作为文件名。
2. window.open 上面使用a标签的案例也可以通过window.open来实现，效果是一样的，代码如下：
window.open('http://www.baidu.com', '_blank') 这里的_blank是指定打开的方式，如果不指定，那么就会在当前页面打开，这里指定_blank，就是在新的页面打开。
同样a标签的download属性也是可以使用的，代码如下：
window.open('http://www.baidu.com', '_blank', 'download=baidu.html') 当然这种方式也是有缺陷的，对比于a标签，这种方式不能下载.html、.htm、.xml、.xhtml等文件，因为这些文件会被当成html文件来处理，所以会直接在当前页面打开。
同样也不能下载跨域的文件，毕竟是window.open，不是window.download（window.download是假想）。
3. location.href 这种方式和window.open(url)是一样的，代码如下：
location.href = 'http://www.baidu.com' 这种方式拥有window.open的所有缺陷，所以不推荐使用，这里只当作了解，所以不做过多的讲解。
4. location.?其他属性 这里的其他指代的都是能跳转页面的属性，比如location.assign、location.replace、location.reload等，这些属性都是可以实现文件下载的，代码如下：
location.assign('http://www.baidu.com') location.replace('http://www.baidu.com') location.reload('http://www.baidu.com') 这里的location.reload是有点特殊的，它的作用是重新加载当前页面，但是它也可以接受一个参数，这个参数就是要跳转的页面，所以也可以实现文件下载。
当然同location.href一样，这些方式的缺点都一样，同时还有属于每个属性自身的特性，这里只当拓展知识，不做过多的讲解。
5. XMLHttpRequest 这种方式就是我们常说的ajax下载，包括axios、fetch等都是相同的，代码如下：
const xhr = new XMLHttpRequest() xhr.open('GET', 'http://www.baidu.com') xhr.send() xhr.onload = function () { const blob = new Blob([xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776dde2720c01ddbb65789417861fbf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c30c7c055387c6a00f51f06df29d69d/" rel="bookmark">
			谈谈 Java 日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方关注我，然后右上角点击...“设为星标”，就能第一时间收到更新推送啦~~~
日志：就是介绍一个过程和经历的详细记录。项目日志：就是项目开发过程的详细记录，一般由项目经理记录。代码里的日志：就是程序员记录某个开发过程的详细情况，这是项目里每个程序员需要做的工作。
代码里的日志在项目中扮演着非常重要的角色，日志记录的详细程度决定系统是否容易维护，Java 项目中日志记录的框架有很多，在项目中如何选型也必将困惑。
1
日志在项目中的作用
Log 日志，主要用于记录程序运行的情况，以便于程序在部署之后的排错调试等，也有利于将这些信息进行持久化（如果不将日志信息保存到文件或数据库，则信息便会丢失）。
1、查看程序当前运行状态
如果想了解程序当前的运行情况，我们通过实时查看应用日志的输出，就能进行分析。
比如，你在浏览器里输入一个 action 地址，该 url 负责执行一些批量处理，action 运行后，假设处理比较耗时，你再浏览器里无法直接看到程序的执行结果，此时，你可以打开系统日志，通过从日志输出信息就能轻松地分析该 url 的执行情况
2、查看程序历史运行轨迹
如果想了解历时程序的运行情况，我们通过查看应用历时日志的输出，就能进行分析。
比如，你想了解下上周周末用户访问量，你可以打开系统上周周末的日志记录，进行分析。你想了解昨天的某个定时任务是否正常执行，你可以打开昨天的系统日志，精确查找该定时任务的输出信息，从而判断定时任务是否执行。
3、排查系统问题
排查系统问题是程序员最熟悉的味道了，在项目维护过程中，出了任何问题，都需要程序员去进行排查。此时，如果没有清楚明了的日志记录，想要核查出问题的原因，难于上青天。
一个优秀的程序员一定是个日志记录高手，如果日志记录的好，处理得当，排查问题则易如反掌。
大家有没有遇到一种场景，一个问题发生了，有的人能迅速定位问题并解决，有的人搞了半天，还没发现问题的产生原因。
其实快速定位问题的人一定记录了详细的日志，因此当问题发生的时候，通过核查问题发生时候的日志，就能快速地找出问题产生的原因。
4、优化系统性能
通过记录程序运行的时间，就能判断程序从执行开始到执行结束消耗的时间，从而判断系统性能是否达标，为系统性能优化提供判断依据。
5、安全审计的基石
网络安全越来越受到大家的关注，所以系统安全目前是项目过程非常重要的一个环节，安全审计也是系统中非常重要的部分。
通过系统日志分析，可以判断一些非法攻击，非法调用，以及系统处理过程中的安全隐患。
比如，大家平时都在做运营系统，其中运营人员在通过界面处理一些数据的时候，如果没有清楚的日志操作记录，一条数据被删除或者修改，你是无法找到是谁操作的，但是如果你做了相应的记录，该数据被谁删除或者修改就会一目了然。
通过以上 5 点说明了日志在项目维护过程中的重要作用。
一个系统是否容易维护，很大程度上是基于程序员在程序开发过程中的代码日志是怎么记录的。
日志记录越清楚，维护起来就越容易，有的程序员没有日志记录意识，或者对日志记录认识不清，或者是不知道日志该如何记录，这势必会给项目后期的维护带来一个个大坑。
当项目经理让你解决一个线上问题的时候，正好遇到了一个没有日志记录习惯的人写的代码，你就能体会到那种痛苦，不由地想要爆粗口。
因此，作为一个程序员来说，掌握代码日志的记录方法，是程序员生涯的一项基本功。写代码时做好日志记录是“即利人又利己”的做法，不写日志记录就是“损人不利己”的做法。
2
Java 日志使用的困惑
大多数的程序员都能认识到日志在项目中的重要性，可是对日志记录具体要怎么做，做到什么程度，日志记录用什么工具，会有很多困惑。
1、工具困惑
作为 Java 程序员，幸运的是，Java 拥有功能和性能都非常强大的日志库；不幸的是，这样的日志库有不止一个，相信每个人都会对JUL(Java Util Log)、JCL(Commons Logging)、Log4j、SLF4J、Logback、Log4j2 等等的日志工具，到底使用什么产生感到困扰。
想要解开这个困扰，需要了解 Java 日志演化历史。
最先出现的是 Apache 开源社区的 Log4j，这个日志确实是应用最广泛的日志工具，成为了 Java 日志的事实上的标准。
然而，当时 Java 的开发主体 Sun 公司认为自己才是正统，在 Jdk1.4中增加了 JUL（在java.util.logging包下）日志实现，企图对抗 Log4j，但是却造成了 Java 目前开发者记录日志局面的混乱，迄今为止仍饱受诟病。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c30c7c055387c6a00f51f06df29d69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cd3a82352160090b0aacb39a6ca6e6/" rel="bookmark">
			使用Scanner接收用户输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫描输入的两种方式 Scanner主要提供了两个方法来扫描输入：
（1）hasNextXxx()：是否还有下一个输入项，Xxx可以是Int，Long等代表基本数据类型的字符串。
如果只是判断是否包含下一个字符串，则直接使用hasNext();
(2) nextXxx()：获取下一个输入项。Xxx的含义与前一个方法的含义相同
默认情况下，Scanner使用空白（空格、Tab、回车）作为多个输入项之间的分隔符
按个获取：
public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { System.out.println("键盘输入的内容为："+ scanner.next()); } } 测试结果：
按行获取：
public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) { System.out.println("键盘输入的内容为："+ scanner.nextLine()); } } 测试结果：
笔试中常见接收输入操作： （1）接收一个int类型数组和一个target整数 //System.in为标准键盘输入 Scanner scanner = new Scanner(System.in); //只把回车作为分隔符 //scanner.useDelimiter("\n"); //类型1：接收一个int类型数组nums[] 和一个target System.out.print("请输入数组："); String input = scanner.nextLine(); String[] numsString = input.split(","); int[] nums = new int[numsString.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34cd3a82352160090b0aacb39a6ca6e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199c58d2741f368c2f18b6b68181433f/" rel="bookmark">
			头插法建立带头结点的单链表，输入数据并打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int ElemType; typedef struct Lnode{ ElemType data; struct Lnode *next;	}Lnode,*LinkList;//这里面Lnode*和LinkList是等价的，都表示指针。只是LinkList强调链表，LNode*强调这是结点。 LinkList List_HeadInsert(LinkList &amp;L){//头插法建立单链表 int x; Lnode* s; L=(LinkList)malloc(sizeof(Lnode)); L-&gt;next=NULL;//NULL一定大写 scanf("%d",&amp;x); while(x!=9999){//输入9999结束 s=(Lnode*)malloc(sizeof(Lnode)); s-&gt;data=x; s-&gt;next=L-&gt;next; L-&gt;next=s; scanf("%d",&amp;x);	} return L;	} void printList(LinkList L){//打印链表 while(L != NULL){ printf("%d ", L-&gt;data); L = L-&gt;next; } } int main(){	LinkList L; L=List_HeadInsert(L); printList(L); return 0;	} 前面多余的那一串数字是未初始化头结点产生的“脏数据”。
解决方法一：打印时直接跳过头结点。
void printList(LinkList L){//打印链表 while(L != NULL){ L = L-&gt;next; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199c58d2741f368c2f18b6b68181433f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9d644294bf1e5181ef2d22cbb1a5ac/" rel="bookmark">
			基于STM32 FOC下桥三电阻采样方式的电机相电流重构方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、本文中的PWM生成模式2、 注意事项3、与SVPWM相关的问题4、采样点的选择4.1、在低调制系数时（1）4.2、在高调制系数时（2）4.3、在高调制系数时（3）4.4、在高调制系数时（4） 5、最大调制系数和最大占空比的确定6、参考文献 在三相电机FOC控制算法里，电机三相电流重构对电流环的稳定性和电机运行效率都非常关键。在采用下桥三电阻采样方案时，如果没有有效方法重构三相电流，电机在高调制率下将无法稳定运行。传统的方法是限制调制率，从而保证电机不会运行在高调制率下，这个方法牺牲了母线电压的利用率，从而导致电机无法高速运行或者高速运行效率降低。
本文重点介绍针对采用下桥三电阻采样方式的一种相电流重构算法，通过本文介绍的电流重构算法，可以使电机运行在更高的调制率下，可以充分利用母线电机，从而让电机运行在高速区间并提高电机高速运行效率。
本文是基于STM32平台，且分析基于以下场景：
PWM输出高有效,且上桥壁在计数值大于比较值时输出高电平，则下桥壁在比较值大于计数值输出高电平；相电流的采样由PWM4触发；使能PWM定时器4个通道的预装功能，在发生更新事件时开始作用；更新事件发生在PWM计数的上溢处； 1、本文中的PWM生成模式 如下：
2、 注意事项 必须读取两相的定子电流，由SVPWM的当前扇区决定读取哪两相电流，即读取下桥壁占空比较大的两相电流；只有在下桥壁打开时，才能读取该相电流；每次桥壁开关状态有变化时，会在shunt电阻上的电压产生一个电子干扰，假设该干扰的时间长度为TN;当下桥壁打开后，需要等待一段时间来使shunt电阻上的电压达到稳定值，假设该干扰的时间长度为TR;在TN 及 TR期间不能读相电流；由于STM32 ADC/TIM1的高性能，我们可以在PWM周期的任何时刻采样，但是我们希望在不同扇区，采样点无太大变化； 3、与SVPWM相关的问题 下图为三相下桥壁的占空比
对于每个SVPWM扇区，总有两相桥壁的占空比变化很小而另一相变化很大；在下述的介绍中，我们假设C相下桥的占空比最大，A相下桥的占空比最小，而B相下桥壁的占空比变化最大，如下图中圈出的部分：
4、采样点的选择 4.1、在低调制系数时（1） 这里DT为死区时间，上下桥壁都有插入这个时间，TN为开关噪声时间，Ts为采样点， Δ D u t y \Delta Duty ΔDuty就是通道A的比较值CC1，采样点处是采样BC相的电流。
4.2、在高调制系数时（2） 4.3、在高调制系数时（3） 4.4、在高调制系数时（4） 5、最大调制系数和最大占空比的确定 如果在同一个硬件上TN、TR、DT 已确定，Ts，PWM频率也确定了，那么怎么计算出最大调制系数和最大占空比呢。这里我们通过simulink仿真得到。举个例子，假设TN = TR = 3.5us，DT= 0.6us，
Ts = 0.2us；fpwm = 15.625K，那么通过仿真得到 最大调制系数为93%，最大占空比为96.5%。
仿真模型见下载链接。
6、参考文献 1、基于 C2000 InstaSPIN FOC 下桥三电阻采样方式的电机电流重构方法【TI】
2、基于STM32的PMSM FOC软件库培训 【ST】
3、知乎 —— 如何提高三电阻采样最大占空比
仿真模型和参考文献的下载链接：根据控制板硬件参数和载波频率，仿真计算最大调制率和最大占空比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052a3992553b21d4f768af4062b86677/" rel="bookmark">
			记一次rsyslog 引发的Structure needs cleaning问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次rsyslog 引发的Structure needs cleaning问题处理 问题回顾：
​ 开发人员在本地服务器上pull代码的时候页面显示 Structure needs cleaning 已部署的系统中数据库无法打开。
排查过程：
​ 查阅系统日志发现是 rsyslog 报错 imjournal: fopen() failed for path: ‘/var/lib/rsyslog/imjournal.state.tmp’: Structure needs cleaning [v8.24.0-57.el7_9.1 try http://www.rsyslog.com/e/2013 ]
​ 查看服务状态
systemctl status rsyslog ​ 尝试重启服务
systemctl restart rsyslog ​ 尝试重启系统，重启后未解决
​ 必应搜索相关问题给出的结果均是需要重新挂载目录，查看了目录所在分区为根目录，无法重新挂载
​ 尝试重装rsyslog
# 删除/var/log/messages文件 rm -rf /var/log/messages # 重装rsyslog yum reinstall rsyslog ​ 此处出现问题，提示rpmdb open failed
​ 删除原rpm db 文件
rm -f /var/lib/rpm/__db* ​ 重建rpm数据库
rpm --rebuilddb ​ 清除所有yum的缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052a3992553b21d4f768af4062b86677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02534ce81da15c5ffb728223eaf236ca/" rel="bookmark">
			VScode的setting配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ "cmake.configureOnOpen": true, "C_Cpp.updateChannel": "Insiders", "window.zoomLevel": 1, "workbench.iconTheme": "material-icon-theme", "grunt.autoDetect": "on", "jake.autoDetect": "on", "workbench.preferredLightColorTheme": "Default Dark+", "workbench.colorCustomizations": { // "editor.selectionHighlightBackground": "#ff0000", // "editor.lineHighlightBackground": "#870bc0", "editor.findRangeHighlightBackground": "#91ff00", "editor.selectionHighlightBorder": "#e61453", "editor.selectionBackground": "#ffffffff", //"editor.findMatchBorder": "#bfc213", //"editor.findRangeHighlightBorder": "#08ddd2", "editor.findMatchBackground": "#3417db", "editorBracketMatch.background": "#0066ff", }, "[javascript]": { //"editor.defaultFormatter": "vscode.typescript-language-features" "editor.defaultFormatter": "lonefy.vscode-JS-CSS-HTML-formatter" }, //java配置 "java.home": "/home/luqian/soft/java19/jdk-19.0.1", "editor.suggestSelection": "first", "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue", //"java.configuration.checkProjectSettingsExclusions": false, "files.autoGuessEncoding":true, //code run插件 "code-runner.executorMap": { "java": "cd $dir &amp;&amp; javac -encoding utf-8 $fileName &amp;&amp; java $fileNameWithoutExt"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02534ce81da15c5ffb728223eaf236ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/121/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>