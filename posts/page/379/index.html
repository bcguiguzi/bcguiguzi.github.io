<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9110439bc82f74ea1c0bfb2096f44f5/" rel="bookmark">
			[codeforces 1374E1]    Reading Books (easy version)    巧妙配对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Codeforces Round #653 (Div. 3) 参与排名人数11687
[codeforces 1374E1] Reading Books (easy version) 巧妙配对
总目录详见https://blog.csdn.net/mrcrack/article/details/103564004
在线测评地址http://codeforces.com/contest/1374/problem/E1
ProblemLangVerdictTimeMemoryE1 - Reading Books (easy version) GNU C++17Accepted124 ms6000 KB 题目大意：给定一堆书，有只有Alice喜欢的，有只有Bob喜欢的，也有两者都喜欢的，选出Alice喜欢的k本书，Bob喜欢的k本书，两种选择可以有重复，组成一个新集合，要求新集合对应的总阅读时间最少，输出这个最少时间。
基本思路：按阅读时间，自小到大，将只有Alice喜欢的排序，将只有Bob喜欢的排序，将两者自小到大配对，配成两者都喜欢的，即两本书的阅读时间，合并成一本书的阅读时间，归类为两者都喜欢的书。
证明：只有Alice喜欢的书，与只有Bob喜欢的数量是一致的。
都喜欢的书有c本，只有Alice喜欢的有a本，只有Bob喜欢的有b本。
因Alice喜欢的书有k本，k=c+a;
因Bob喜欢的书有k本，k=c+b;
c+a=c+b
a=b.
样例分析如下：
8 4 7 1 1 2 1 1 4 0 1 8 1 1 1 0 1 1 1 1 1 0 1 3 0 0 18 1 0 1 1 0 1 4 0 1 1 1 1 2 1 1 7 1 1 8 1 1 被选中的书： 1 1 1 2 1 1 7 1 1 8 1 1 1+2+7+8=18 总耗时18 AC代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9110439bc82f74ea1c0bfb2096f44f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7638403b10b33ec08bbe89791ba4d112/" rel="bookmark">
			E1. Reading Books (easy version)(贪心）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E1. Reading Books (easy version)(贪心） 传送门
思路：贪心。
有四种类型物品：
1.两个人都能拿。
2.只有 A A A能拿。
3.只有 B B B能拿。
4.都不能拿。
显然第4种不用考虑。
显然根据贪心思想，最优解肯定是 A 和 B A和B A和B刚好拿 k k k个。
所以考虑将类型 2 , 3 2,3 2,3转换为 1 1 1做。
分别将 2 , 3 2,3 2,3类型排序，然后每次取最小的为一组加入到类型 1 1 1中。
再对类型 1 1 1排序，选前 k k k个即可。
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e5+5,M=1e6+5,inf=0x3f3f3f3f,mod=1e9+7; #define mst(a) memset(a,0,sizeof a) #define lx x&lt;&lt;1 #define rx x&lt;&lt;1|1 #define reg register #define PII pair&lt;int,int&gt; #define fi first #define se second int main(){ int n,k; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7638403b10b33ec08bbe89791ba4d112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f5829ea90521d2f951e17e5d59d2b2/" rel="bookmark">
			Codeforces Round #653 (Div. 3) E1.Reading Books (easy version) (思维，sort)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目传送
题意:
给你n本数，俩个人对这n本书有的喜欢，有的讨厌，现在问，这俩个人分别从他们喜欢的书中挑k本出来(如果挑不出来，输出-1)，现在问每本书的最少阅读时间的总和为多少?
思路:
看清楚了是每本书的最少阅读时间总和，害的我最开始没有看懂第二个样例。。。
1.我们开三个数组分别存储:俩个小孩都喜欢的书，第一个小孩喜欢的书，第二个小孩喜欢的书的所需要看的时间。
2.再把时间从小到大排序，然后再分情况:
(1)如果有一个人不能选k本书出来看，那么直接输出-1
(2)如果俩个人都喜欢的书的花费时间 大于 第一个小孩喜欢的书的时间加上第二个小孩喜欢的书的时间(书按照现在最短的那个时间依次推)，那么我们肯定是选择时间少的那种，然后把这俩本书删除，再判断。
(3)与第二种情况相反，那么我们就选择俩个人都喜欢的书，然后把这本书删除，即可
AC代码
#include &lt;bits/stdc++.h&gt; inline long long read(){char c = getchar();long long x = 0,s = 1; while(c &lt; '0' || c &gt; '9') {if(c == '-') s = -1;c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') {x = x*10 + c -'0';c = getchar();} return x*s;} using namespace std; #define NewNode (TreeNode *)malloc(sizeof(TreeNode)) #define Mem(a,b) memset(a,b,sizeof(a)) #define lowbit(x) (x)&amp;(-x) const int N = 2e5 + 10; const long long INFINF = 0x7f7f7f7f7f7f7f; const int INF = 0x3f3f3f3f; const double EPS = 1e-7; const int mod = 1e9+7; const double II = acos(-1); const double PP = (II*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f5829ea90521d2f951e17e5d59d2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cd2f9df35d6bf8b4156c41db91a4fd/" rel="bookmark">
			E1. Reading Books (easy version)[贪心,模拟]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注 意 把 这 些 分 成 三 类 \color{Red}注意把这些分成三类 注意把这些分成三类
Ⅰ . A l i c e 和 B o b 都 喜 欢 的 Ⅰ.Alice和Bob都喜欢的 Ⅰ.Alice和Bob都喜欢的
Ⅱ . 只 有 A l i c e 喜 欢 的 Ⅱ.只有Alice喜欢的 Ⅱ.只有Alice喜欢的
Ⅲ . 只 有 B o b 喜 欢 的 Ⅲ.只有Bob喜欢的 Ⅲ.只有Bob喜欢的
那 么 不 妨 先 不 考 虑 Ⅰ 这 一 类 , 因 为 暂 时 我 们 还 难 以 抉 择 那么不妨先不考虑Ⅰ这一类,因为暂时我们还难以抉择 那么不妨先不考虑Ⅰ这一类,因为暂时我们还难以抉择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cd2f9df35d6bf8b4156c41db91a4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebbe761b0742a02b44c9725493ccc9ba/" rel="bookmark">
			从吃喝玩乐到学习，71个良心网站，看完你会回来点收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，白嫖电影 本人看片量3000+。学生时代没什么钱，各种白嫖国内外电影，外加学习资料。。。
这个世界上没有什么比白嫖更过瘾的事情了，所以推荐几个网站，可以直接Down资源，最新电影、纪录片、美剧、韩剧、真人秀，应有尽有。
1.电影天堂：https://www.dygod.net （近期改版仅支持在线观看）
推荐理由：这是我最常用的一个下载网站，电影类别很全，有各种经典电影、小众电影、鬼片、文艺片、国内未上市的电影、爱情片、悬疑片、未删减版（比如色戒）、禁片……网站安全性高。关键还免费，完全可以省去iqiyi、腾讯一个月几十块钱的会员费！
2.DVD影院：http://www.dvdbo.com（支持迅雷下载）
3.电影港：http://www.dygang.com（支持在线观看、迅雷下载、百度网盘储存）
4.飘花电影网：https://www.piaohua.com（支持在线观看、迅雷下载）
5.人人影视：https://www.yyetss.com（支持在线观看、百度网盘储存）
6.91美剧网：https://91mjw.com/all（支持在线观看、迅雷下载）
二，省钱必备 当代年轻人的比价神器，货比三家，买个不吃亏。
有人说，去淘宝天猫看评论基本就能判断出产品质量。
业内人士告诉你，很多好评都是刷的！！我曾经在天猫靠评价看销售量和好评判断下单了一个午睡枕，到货后一阵塑料味，果断退货，在什么值得买找到一个性价比超高的午睡枕。感谢张大妈！
1.什么值得买：https://www.smzdm.com
外号张大妈，我是她第一批用户，而且现在还在用。比价神器、物件测评，以及购物券领取，我比较喜欢在这个网站上看测评。
2.粉象生活：http://www.fenxianglife.com
同事多次安利的一款适合工薪阶层使用的省钱神器，接入淘宝、京东、美团、饿了么、大众点评等海量优惠卷。买东西前我一定会上去搜一搜优惠卷再下单，而且你推荐人使用粉象，你还能获得返佣。据说有人靠这个方法存钱，已经在老家买了一套小房子。
阿里巴巴旗下购物批发网站：https://re.1688.com 货品质量参差不齐，需当心筛选。之前在这个网站买东西，衣服还不错，但可能鞋子没挑不好，质量很差。
4.咸鱼：https://2.taobao.com
推荐理由：阿里旗下，支持一键转卖。尤其是闲置的科技用品转卖，之前，我卖过一款佳能相机，挂出去就被秒掉了，售价800，比二手回收平台价格高。还可以购买一些二手的好货，说不定还能买到明星产品，比如郑爽之类的，也是追星好网站。我在咸鱼买过闲置风扇、电脑显示屏，还买过二手书。
5.义乌购：https://www.yiwugo.com
推荐理由：小商品线上批发网站
三，长胖计划 在家做饭，喂养计划可以开始了～
1.豆果美食：https://www.douguo.com
注：网页有些不方便，可以下载个APP使用
2.小红书：https://www.xiaohongshu.com
注：白富美、小资聚集地，视频、图文做菜、美食攻略很全面。
3.大众点评：https://www.dianping.com
4.抖音、快手美食视频，推荐麻辣德子、陕西老乔这两个账号，他们在抖音快手抖音上千万的粉丝。。
四，疫情后第一件事：旅行 1.马蜂窝：https://www.mafengwo.cn
2.穷游网：https://www.qyer.com
Feekr ： http://www.feekr.com 4.爱彼迎：https://www.airbnb.cn
个性化民宿
5.途家：https://www.tujia.com
民宿租房类
五，读书计划，拒绝买书堆积 免费电子书阅读
1.微信读书：https://weread.qq.com
推荐理由：分享链接就可以获得大量免费阅读时间，主要看重的是微信读书的书籍库比较全。非极冷门书籍都能找到，还支持听书。我们还刻意拉了一个群，专门用于分享链接。
2.鸠摩搜索：https://www.jiumodiary.com
3.书伴：https://bookfere.com/ebook
4.ePUBee：http://cn.epubee.com/books/
5.Library Genesis：http://gen.lib.rus.ec
6.书格：https://new.shuge.org/
7.得到：https://www.igetget.com
六，变优秀大法 1.番茄todo：http://www.tomatodo.cn
推荐理由：拖延症治疗神器，将番茄工作法与TODOLIST结合。做计划的同时，也可催促你执行任务。最后还有时间应用分析，供日常复盘，提升效率，时间管理神器。
2.石墨文档：https://shimo.im/welcome
推荐理由：对于线上办公以及多人协作很友好。可以同时在线修改文章，自动留下修改痕迹，不会混乱，很适合上司修改文章、方案使用。
3.印象笔记：https://www.yinxiang.com
4.谷歌翻译：https://translate.google.cn
推荐理由：你踩过的百度翻译坑，可以用谷歌翻译避免，准确度高。写毕业论文，英文序言翻译帮助神器。
5.知识星球：https://www.zsxq.com
侧重职场、以及专业性的知识分享。
6.keep：https://www.gotokeep.com
运动健身必备，有基础教学也有数据分析，还有部分付费的专业资讯。
7.轻芒app
注：深度阅读好去处，编辑筛选，关注的专题，每天更新不会超过10条。信息量小，减少压力。还可以在文章内做标记，便利地让人上瘾。
8.墨墨背单词：https://www.maimemo.com
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebbe761b0742a02b44c9725493ccc9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dd4ad0a6ec415c631603d37a2814ea/" rel="bookmark">
			AI产品经理，如何面对数据挖掘？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分别先从AI产品需求发现阶段、再从AI产品需求设计制造阶段对数据挖掘的利用，然后落地到数据挖掘具体的案例解析，最后得出AI产品大数据观点。
经过多年互联网和移动互联网的飞猛发展，科技网络产品发展到焦虑的时间节点。一方面流量成本高到几乎没有投入产出比可言，另外一方面产品和企业同质化竞争激烈。
接下来的趋势有两股同方向的产品力量，将是产品经理和企业产品创新的机会点：
第一是：利用PC和移动互联网积累的大数据做打破数据孤岛类的产品和数据挖掘，数据分析类的产品。第二是：在大数据的肩旁上，深度结合业务供应链场景设计10倍于以往产品体验的AI算法产品、AI赋能的智能软硬件产品。 本文分别先从AI产品需求发现阶段、再从AI产品需求设计制造阶段对数据挖掘的利用，然后落地到数据挖掘具体的案例解析，最后得出AI产品大数据观点。
一、数据挖掘用于AI产品需求发现 需求的发现是产品经理和企业产品创新取得成功的关键，数据信息在产品的创新设计与制造中发挥越来越重要的作用，充分利用数据挖掘技术从产品市场需求发现、需求设计中提取相应的需求，从而控制和改善下一代产品的设计与制造。
目前，AI赋能的智能软硬件整体产品的研制周期长，市场反应能力弱，创新度不够等一系列因素控制了产品制造企业的生存和发展，不论是万亿市值的苹果还是国内的华为小米一年旗舰智能手机只有一款。这个现象背后正是因为AI赋能的软硬一体产品，在需求发现到产品设计上有其特殊性。
因此，如何在最短的时间内开发出质量高、价格能被用户接受的AI产品，已成为产品经理市场竞争的焦点。数据挖掘技术已经成为分析和发现需求，提供决策十分有效的工具，而需求发现速度快起来后可以给需求设计制造更多时间，所以必将有力地支持AI产品的创新设计和制造过程。
数据挖掘（Data Mining，简称DM）就是从大量的、不完全的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和需求的过程。
根据产品发现需求的不同，数据挖掘的任务主要分为以下 6 类：
（1）关联分析需求，揭示隐藏在数据之间相互关系的一项挖掘潜在需求的数据挖掘任务。
例子：“尿布与啤酒”的故事。
在一家超市里，有一个有趣的现象：尿布和啤酒竟然摆在一起出售。但是，这种奇怪的举措却使尿布和啤酒的销量双双增加了。这不是一个笑话，而是发生在美国沃尔玛超市的真实案例，并一直为商家所津津乐道。
沃尔玛拥有世界上最大的数据仓库系统，为了能够准确了解顾客在其门店的购买习惯，沃尔玛对其顾客的购物需求进行了深层分析，想了解顾客经常一起购买的商品都有哪些。沃尔玛数据仓库里集中了其各门店的详细的原始交易数据，在这些原始交易数据的基础上，沃尔玛利用关联规则对这些数据进行分析和挖掘，得出了一个令人意外的发现：“跟尿布一起被购买最多的商品竟是啤酒！”
经过大量实际调查和分析，揭示了一个隐藏在“尿布与啤酒”背后的美国人的一种需求模式：在美国，一些年轻的父亲下班以后要经常到超市去买婴儿尿布，而他们中有30%～40%的人同时也会为自己买一些啤酒。
产生这一现象的原因是：美国的太太们常叮嘱她们的丈夫下班后为小孩买尿布，而丈夫们在买尿布后又随手带回了他们喜欢的啤酒。
按照常规思维模式，尿布与啤酒风马牛不相及，若不是借助关联规则进行挖掘和分析，沃尔玛是不可能发现数据之间存在的这一有价值的需求。
以前企业的信息管理系统由于缺乏数据挖掘功能，最多只能统计一些数据，从表面上似乎合理，但实际上根本不能反映出本质的情况。例如：通过传统的信息管理系统，我们得出某一种红酒在超市的销售额排名倒数第一位，按照以往的做法，该红酒肯定会停止销售，但是通过对所有销售数据进行关联分析，我们会发现消费额最高的客户中有25%常常买这种红酒，如果停止出售这种红酒，必然会引起这些高端客户的不满。
关联分析就是发现交易数据库中不同商品之间的内在的联系，利用关联规则找出顾客购买行为模式，如购买了某一商品对其它商品的影响。例如：它能发现数据库中如“90%的顾客在一次购买活动中购买商品X的同时购买商品Y”之类的问题，发现这样的规则可以应用于商品货架设计、库存安排以及根据购买模式对用户进行需求分析等。
用于关联规则发现的主要对象是事务型数据库，其中针对的应用则是商品销售数据。如果对这些历史数据进行分析，则可以对顾客的购买行为提供极有价值的信息。例如：可以帮助商家如何摆放货架上的商品，如何帮助商家规划市场等。
总之，从事务数据中发现关联规则，对于改进商业活动的决策非常重要。
（2）序列发现需求，是指确定数据之间与时间相关的序列模式，利用该模式可对未来的相关行为进行预测。
例子：数据挖掘中序列发现的需求分析应用比如顾客购买行为分析、网络访问模式的分析。对一家完善的大型零售企业来说，往往拥有固定会员。会员可以购买较低价格商品，享受更加优惠的售后服务等等。
会员应是经常在某一家店铺购物的消费者，因此经历较长时间的会员其购物成为按时间的购物序列，而不同会员就可能存在相同的购物序列。比如：两个都喜欢购买新科技产品的会员，销售记录中就会记录他们每次购买的科技产品，从而可以将个人的喜好推荐给另一个人，这也形成交叉销售。
（3）聚类分析需求，是指依赖样本间关联的量度标准将其自动分成几个群组，且使同一群组内的样本相似，而属于不同群组的样本相异的一组方法。
例子：基于数据挖掘的聚类分析，可以借助大数据的优势，发现数据背后的需求。利用起点学院“成为AI产品经理”在线开放课程学习者的网络学习过程记录，采用数据挖掘工具对网络学习者行为进行聚类分析，研究发现：根据学习特征,网络学习者可以分为高沉浸性型、较高沉浸性型、中沉浸性型、低沉浸性型四种群体。
学习行为与学习效果密切相关，沉浸性高的学习者学习效果往往较好。笔者作为《成为AI产品经理》课程老师借助技术工具，对学习者进行不断更新、实时、循环的聚类分析，及时发现学习者的个体及群体学习特征，因材施教，推送适应性的个性化服务，并给予及时的学习预警与恰当的教学干预。
（4）分类，是指找出一个类别的概念描述，它代表了这个类别数据的整体信息，一般用规则或决策树模式表示。
例子：分类发现需求，首先应该将分类与聚类分开。很多数据产品经理在学习数据方法之初，容易将聚类和分类搞混淆。其实聚类属于无监督学习范畴（unsupervised learning），也可称作观察式学习过程，与分类不同，分类依赖已有既定的先验知识。
例如：我们成年后，很清楚世界是由男人和女人组成的，所以我们在建厕所的时候，会把厕所分为男厕所和女厕所，这就是“分类”。而当我们刚生下来，我们并不知道什么是男人，什么是女人，通过后天对生活的观察，我们发现有一类人他们有胡子，而有一类人她们头发比较长（当然，我的这个举例已经显然不符合当今世界的发展了，你们明白就行）。于是我们就把有胡子的人分为一类人，把长头发的分为另一类人。
然后“研究”发现：原来有胡子的叫男人，有长头发的叫女人，这个过程就是“聚类”。
（5）偏差检测，就是从数据分析中发现某些异常情况是否重要，从而获得有用的需求。
例子：一批数据中的异常值值得关注，忽视异常值的存在是十分危险的，不加剔除地把异常值包括进数据的计算分析过程中，对结果会带来不良影响;重视异常值的出现，分析其产生的原因，常常成为发现需求进而改进决策的契机。
例如：A君是机车爱好者骑摩托不带安全帽，他会说他周围的朋友都不带安全帽，更刺激更能感受空气触感而且周围朋友都很安全，相反某某著名机车选手带了安全帽损失性命的例子。
大数据挖掘样本是基于从大样本的数据来看，不带安全帽骑机车比带安全帽整体不安全。下论断要从统计整体上来看，揪住一个异常需求没有意义。数据产品经理知道这一点以后，就可以在诸如非金融财产型产品需求里对某些异常需求可以缓一些解决。
（6）预测，就是利用历史数据找出变化规律，建立模型，并用此模型来预测未来需求等。
例子：通过数挖得到预测的例子非常多，这里从行业方面举几个例子，例如：电力行业通过数挖到不同行业在未来对电力的不同，进而更好的做好对各个行业电力需求的供应。例如：物流行业通过对库存需求的挖掘调配货运司机。例如：新零售企业通过数挖准备商家和商品备货等。
二、数据挖掘用于AI产品设计制造 在产品的设计与制造过程中，利用数据挖掘可得产品设计的创新，提高产品质量，加速产品的制造过程。
数据挖掘在AI产品设计与制造系统中的主要过程如下：
（1）模式发现
在产品的设计和制造系统数据中隐含了重要的模式，比如：购买次数较多的顾客特征，对促销感兴趣的顾客特征以及不购买顾客特征等分析，数据挖掘就是对隐含在数据中模式的深度分析。
（2）趋势预测
数据挖掘不仅能够提取静态的模式，也能预测动态的发展趋势，目前时间序列挖掘是一个研究的热点，动态的趋势能够反映顾客兴趣的改变，从而使企业对发展趋势做出相应的市场决策。
（3）数据的降维
数据的降维也叫做主成份分析，现代数据库中包含了交易信息的特征，不相关的数据条目和特征可以从数据集中消除，数据降维的主要作用是选择关键的数据进行分析。
（4）可视化产品制造
数据可视化主要旨在借助于图表、图、表格等形化手段，清晰有效地传达与沟通信息。
根据AI产品全生命周期考虑，产品设计与开发过程可划分为：产品需求分析（MRD）、概念设计（Featurelist设计）、详细设计（PRD设计）、工艺设计、样品试制、生产制造、销售与售后服务等阶段。
每个阶段和环节之间都存在着反馈和迭代过程，但其额度对不同设计类型有所不同 , 基于并行工程的AI产品设计与开发过程如下图 ：
因为AI产品是站在传统产品肩旁上发展而来，尤其是基于移动互联网的发展累积的大数据的基础上而实现迅猛发展。故此仅针对上图中的两个跟传统产品不同的点进行讲解。
1）AI产品特别是软硬一体产品，一般是先进行上市及先用样品上市，看市场情况再进行批量制造。
这是AI产品制造的特点，传统的商业模式为先制造、后销售、再消费，企业为消费者提供产品，消费者则是被动的产品接受者。
但在AI赋能的时代背景下则呈现一种新型商业模式，即先个性化定制、再制造、后消费，用户先提出个性化需求，企业再为用户提供个性化服务，这样可以极大地提高用户的参与度，也能使得企业真正地去理解和思考用户的需求。
2）AI产品是为了更好地满足客户的需要，进而赢得市场，增加企业的竞争力。因此，比如在市场分析中考虑客户真正需要的产品特征、产品的那些特征最重要等，客户需求最好能与设计规划产品进行集成。另外，需求可以很好地帮助设计师采取适当的产品开发策略，开发出满足客户需要的AI产品。
AI时代工厂是智能制造的载体和集中体现，用户可以直接从智能工厂的用户交互定制平台定制产品，参与到产品的个性化定制过程中，全球任何地方的用户都可以根据自己的个性喜好，自由选择产品的款式，颜色和性能等。提交订单直接下达到工厂，智能工厂可以实现用户通过网络系统对定制生产的全流程实时互联互通，掌握供应链情况，知晓制造进度，追踪货物交付。
在AI制造的生产方式下，产品设计流程的主要步骤是：需求、设计、销售、生产，用户希望通过定制平台自行设计或是选择所需要的产品，不愿接受没有选择性的设计方案。
这一过程可以实现的基础在于三点：
一是用户提出产品的设计需求，交由设计师来完成；二是用户根据设计师提供的产品设计方案，自行选择以满足设计需求；三是对成型的设计产品进行选择，获取设计方案。 用户通过企业的定制平台参与到产品的设计。生产和交付的全流程，通过对不同的产品模块进行选择与组合，构建出符合自己个性的特色产品，极大地简化了AI产品的设计过程。
（5）产品设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dd4ad0a6ec415c631603d37a2814ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4afe83248295ae024154d2c06692807a/" rel="bookmark">
			TextCNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TextCNN 最早由paper《Convolutional Neural Networks for Sentence Classification》提出，将 CNN 应用到 NLP 领域，论文本身比较容易理解，下图即可理解模型结构：
其实单层CNN加个全连接层辣
基本流程：
输入数据 embedding卷积核尺寸 = 单词 embedding 后的维度 * 每次考虑单词的数量，论文中提出的三种feature size的卷积核对应了3-gram，4-gram和5-gram。用不同尺寸（3， 4， 5）的卷积核去提取特征，进行最大池化。将不同尺寸的卷积核提取的特征拼接在一起作为输入到softmax中的特征向量。 代码实现 #%% import torch import numpy as np import torch.nn as nn import torch.optim as optim import torch.utils.data as Data import torch.nn.functional as F dtype = torch.FloatTensor device = torch.device("cuda" if torch.cuda.is_available() else "cpu") #%% # 3 words sentences (=sequence_length is 3) sentences = ["i love you"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4afe83248295ae024154d2c06692807a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c056a373c2c0ed0e363c77436ae767/" rel="bookmark">
			配置LACP模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置LACP模式
5.1 问题
交换机之间的链路如何通过自动方式实现链路的捆绑？
5.2 方案
使用eNSP搭建实验环境，如图-6所示。
图-6
5.3 步骤
实现此案例需要按照如下步骤进行。
1设置完各pc机ip地址
2设置完各交换机接口端口类型
1）创建Eth-Trunk
[SW1]interface eth-trunk 1
[SW2]interface eth-trunk 2
2）配置Eth-Trunk的工作模式
[SW1-Eth-Trunk1]mode lacp-static
[SW2-Eth-Trunk2]mode lacp-static
3）Eth-Trunk中加入成员接口
[SW1-Eth-Trunk1]trunkport g0/0/1
[SW1-Eth-Trunk1]trunkport g0/0/2
[SW1-Eth-Trunk1]trunkport g0/0/3
[SW2-Eth-Trunk1]trunkport g0/0/1
[SW2-Eth-Trunk1]trunkport g0/0/2
[SW2-Eth-Trunk1]trunkport g0/0/3
4）配置sw2 eth-trunk的主动端，优先级为100
[SW2]lacp priority 100
5）配置最大活跃链路数量2（默认为8）
[SW1-Eth-Trunk1]max active-linknumber 2
6）设置SW1的抢占功能（当g0/0/1线路故障后又恢复可以使用可设置抢占功能，使其恢复）
[SW1-Eth-Trunk1]lacp preempt enable
7)查看eth-trunk配置
[SW1]display eth-trunk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bddbb35a45e80c125158bebee30cd4b/" rel="bookmark">
			python3基础篇（十一）——import模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3基础篇（十一）——import模块 前言：
阅读这篇文章我能学到什么？
import关键字用于导入现有的模块，增强了代码的重用性。可以和from和as关键字一起使用。这篇文章将为你介绍import的几种用法。
——如果你觉得这是一篇不错的博文，希望你能给一个小小的赞，感谢您的支持。
1 import [ModularName] 1.1 导入一个模块 为了实现代码的重用性，方便将来或他人使用，我们通常会将代码进行模块化。而python3中提供了import关键字导入现成的模块，导入的模块即可以是开发者自己实现的，也可以是第三方库。python提供了丰富的第三方库，使得大多数功能都不需要自己去重复实现。
代码示例：
TestA.py
TestA_Variable = "TestA Variable" class TestA_Class: def __init__(self, Variable): self.Variable = Variable def MyPrint(self): print(f"TestA Class. {self.Variable}") def TestA_Function(): print("TestA Function") main.py
import TestA print(TestA.TestA_Variable) #访问模块TestA的变量 TestA.TestA_Function() #访问模块TestA的函数 Test = TestA.TestA_Class("Test") #创建TestA中的类 Test.MyPrint() 1.2 导入多个模块 import可以一次导入多个模块，通过,隔开。
代码示例：
我们创建TestB模块。
TestB.py
TestB_Variable = "TestB Variable" class TestB_Class: def __init__(self, Variable): self.Variable = Variable def MyPrint(self): print(f"TestB Class. {self.Variable}") def TestB_Function(): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bddbb35a45e80c125158bebee30cd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c055060d2b2a897e42e3c8f4f9448ef/" rel="bookmark">
			Linux-CentOS7安装教程【附CentOS7镜像】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux-CentOS7安装教程【附CentOS7镜像】 1. 新建虚拟机 点击“创建新的虚拟机”
点击“下一步”
选择“稍后安装操作系统”，点击“下一步”
选择"CentOS 7 64"，点击“下一步”
起一个虚拟机名字，设置一个合适的安装位置，点击“下一步”
点击“下一步”
点击“自定义硬件”，配置如下图：内存2G、cpu1个8核、移除声卡打印机U盘、桥接模式、添加iso镜像，最后点击关闭。
点击“完成”
2. 配置虚拟机 点击“开启此虚拟机”
选择“Install centOS 7”，按下Enter键
选择语言“简体中文”
点击“安装源”，双击“完成”即可
点击“软件选择”，选择“带GUI的服务器+开发工具”如下，双击“完成”
点击“安装位置”，双击“完成”【生产环境中最好是选择“我要配置分区”，我这里物理硬盘不大，就自动配置分区了。】
点击“网络和主机名”,修改主机名
选择完后，点击“开始安装”
设置root用户密码并创建一个普通用户
等待安装完成。
点击“重启”
授权许可证，点击“完成配置”
等待开机，安装完成如下：
点击“未列出”，以root用户登录，进行初始化配置，显示如下：
至此，CentOS7已经安装完毕了。该镜像自带yum软件仓库。故只需配置网络就可以开始使用啦！！！
为了以后方便，先打个快照。在这里提个醒，在做实验的时候，很容易出错，为了有重来一次的机会，可以用快照快速恢复，但若是发现没拍摄快照，那就得重装，很浪费时间。
Cent0S的安装和Redhat的安装几乎一致，可以参考下博主的另一篇博客，有介绍VM15和RHEL7.0的安装教程。
需要CentOS7镜像的小伙伴，可以来一波收藏、点赞、评论，博主可以免费送出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ceee00589e3c36de65f607873616cd/" rel="bookmark">
			ICMP查询报文抓包分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICMP查询报文抓包分析
5.1 问题
使用eNSP搭建实验环境，在G0/0/0开始抓包，在PC1上ping PC2
抓包分析ICMP查询报文
5.2 方案
使用eNSP搭建实验环境，如图-12所示。
图-12
5.3 步骤
实现此案例需要按照如下步骤进行。
1）抓到Echo报文，如图-13所示
图-13
2）抓到Echo Reply报文，如图-14所示
图-14
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081d5ced1e07f9b432b3888649e54b01/" rel="bookmark">
			Backtrader 量化平台研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Backtrader 中国期货回测 Backtrader 简介 先说几句题外话，Backtrader 到底谁在用？一下内容转自backtrader官方网站中References部分：https://www.backtrader.com/home/references/who-is-using-it/
Who is using it
我简单说几点：
2家 Eurostoxx50 银行6家量化私募
不过这些都是很早以前的数据，还有一些做能源交易的对冲基金。
reddit里面有个algo trading 板块，里面有人提了backtrader到底有多火的问题？一下引用了部分：
No. There is not a list. This is actually outdated: the number of banks remains at 2 (there may be more, but I don’t know it), but there are more than 6 firms using it for internal purposes, including for example companies working in energy markets, due to the compensation feature which allows buying and selling different assets which compensate each other (this is probably not available in zipline) which allows to model using spot and futures prices (this is a particularity of energy markets to avoid having the actual goods delivered to you) The thing here is that one would have to define usage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/081d5ced1e07f9b432b3888649e54b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e24550634b921073534948b12c944e4/" rel="bookmark">
			微信小程序之scroll-view组件下拉刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用了scroll-view组件之后，发现不能在该页面下拉刷新了。根本拉不动！
经过五分钟的研究，解决了这个问题。我们可以自行定义下拉刷新。
加上该组件下拉刷新的属性及自己定义下拉事件。
&lt;scroll-view refresher-enabled="true" bindrefresherrefresh="refresh" refresher-triggered="{{triggered}}"&gt;&lt;/scroll-view&gt; refresher-enabled 开启自定义下拉刷新 refresher-triggered 设置当前下拉刷新状态，true 表示下拉刷新已经被触发，false 表示下拉刷新未被触发 （可自行设置该值为true或false。初始化为true,刷新成功设置为false）
bindrefresherrefresh 自定义下拉刷新被触发 （执行refresh函数）
data:{ triggered:true } refresh(){ this.onLoad() this.setData({ triggered:false }) }, 简单的两个步骤就能实现自定义下拉刷新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96326b912ceb763454fee24de4a110b7/" rel="bookmark">
			python对csv数据文件进行读取、重构、保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例 import numpy as np a = np.loadtxt('mnist_test.csv', usecols=np.arange(2,786), delimiter=',', skiprows=1) a.reshape(-1,28,28,1) b = np.savetxt('mnist_test_reshape.csv', a, fmt='%d', delimiter=',') 说明 loadtxt()：读取文件
savetxt()：保存文件
usecols：读取的列，np.arange(2,786)表示从第三列读到第786列，也可单独指定某些列
delimiter：分割符
skiprows：跳过的行，skiprows=1跳过第一行，从第二行开始读取
fmt：保存格式
reshape(-1,28,28,1):将a转化为28×28×1的矩阵，-1表示不知道会产生多少个这样的矩阵，个数不指定
这样的数据就既可作为卷积神经网络的输入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef5c8f5164d24cf2b5888f047cbd49e/" rel="bookmark">
			Python编程时由于缩进导致的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IndentationError: unindent does not match any outer indentation level
原因：新的Python语法中是不支持的代码对齐中，混用TAB和空格的。
解决=&gt;全换成空格
方法1：最简单的方法就是报错附近的都重新用空格缩进一遍（包括函数中的注释）
方法2：可视化--用Notepad++打开脚本，勾选“显示空格与制表符”，可视化代码对齐使用的是制表符还是空格。
在Notepad++的首先项里面，可以勾选“替换为空格”，如下所示，不同版本的Notepad++，可能设置选项有所出入。这样可以避免使用Tab+空格键时出现这种情况。
方法3：pycharm 有个快捷键 CTRL+ALT+L格式化代码。
参考：https://www.cnblogs.com/kerrycode/p/11183963.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32756721c9f0caeb38668c3e32b6d433/" rel="bookmark">
			Java零基础学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Java0基础1.注释2.标识符与关键字3.数据类型类型转换常量、变量、作用域变量名的命名规范运算符JavaDoc 二、Java流程控制三、Java方法学习什么是方法方法的定义与调用方法的重载可变参数递归 四、Java数组数组声明与创建Java数组03：三种初始化及内存分析Java数组06：二维数组Arrays类冒泡排序 五、面向对象static的使用区别构造器面向对象08：封装详解面向对象09：什么是继承Super详解面向对象11：方法重写什么是多态 六、异常总结 视频地址：https://www.bilibili.com/video/BV12J41137hu 一、Java0基础 1.注释 2.标识符与关键字 3.数据类型 类型转换 常量、变量、作用域 变量名的命名规范 运算符 三元运算符
JavaDoc 二、Java流程控制 package com.kuang; public class test1 { public static void main(String[] args) { // 100内奇偶数 int oddSum = 0; int evenSum = 0; for (int i = 0; i &lt;= 100; i++) { if (i % 2 != 0) { oddSum += i; } else { evenSum += i; } } System.out.println("奇数:" + oddSum); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32756721c9f0caeb38668c3e32b6d433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3879711e35fa2e44e5403d7d68b95f/" rel="bookmark">
			mac jupyter notebook打开浏览器空白不显示文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法 pip uninstall jupyter notebook pip install jupyter notebook -i https://pypi.tuna.tsinghua.edu.cn/simple --default-timeout=100 原因 卸载重装之后，发现终端显示一条：
ERROR: syft 0.2.6 has requirement tornado==4.5.3, but you'll have tornado 6.0.4 which is incompatible. 原来是之前安装syft包使得前置包tornado降级了，升级后网页打开即可正常显示文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1dfff24441ccad0071ad0d42612e7ff/" rel="bookmark">
			单片机中的冒泡排序（汇编语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结起来就是： 1.N个数要分选N-1次 2.第i次分选的次数为N-i次 汇编程序： ORG 1000H MOV PSW,00H MOV R7,#100-1;总共的分选次数 LOOP0:MOV R0,#40H ； Loop0是大循环，主要负责分选，一次又一次 MOV R1,#41H MOV 02H,R7;这里确定了第i次分选的次数 CLR F0 LOOP1:MOV A,@R0 ； loop1是小循环，主要负责判断本次分选是否结束 CJNE A,@R1,LOOP2 LOOP2:JNC LOOP3 XCH A,@R1 MOV @R0,A SETB F0 LOOP3:INC R0 INC R1 DJNZ R2,LOOP1 JNB F0,STOP DJNZ R7,LOOP0;循环再次进行下一次分选 STOP: SJMP $ END 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a3354159255bbcfab7384c8281637a/" rel="bookmark">
			VMware Fusion 安装Windows 10 运行.exe 文件 提示“不能在虚拟机上运行”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 使用 Mac 电脑安装 VMware Fusion 虚拟机，安装Windows 10 操作系统，运行 .exe 文件，然后提示“不能在虚拟机上运行此程序”
二、解决方案 进入该虚拟机的安装目录，找到虚拟机配置文件（Windows 10 x64.vmx），并进行修改。
在配置文件末尾添加如下代码（注意：不能在虚拟机运行状态添加）：
monitor_control.restrict_backdoor = "true"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4ad6fc5005f404e26f085ce479dbd7/" rel="bookmark">
			unity官方内置网络unet的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加网络管理组件 新创建一个网络管理器。该网络管理器将控制该项目的网络状态，包括游戏状态管理，生成点管理，场景管理，配对和允许访问相关信息。对于高级用户，可以从NetworkManager派生一个类来自定义组件的行为，扩展未涵盖的NetworkManager
二、创建角色预制体： NetworkIdentity组件介绍：网络物体最基本的组件，客户端与服务器确认是否是一个物体(netID)，也用来表示各个状态，如是否是服务器，是否是客户端，是否有权限，是否是本地玩家等。
三、控制角色移动 四、控制角色射击 子弹预制体的设置
子弹生成：
子弹销毁为什么不用同步，是因为服务端是母体，服务端的销毁掉，客户端自然就会被销毁
五、血量的减少 制作血条：
注意：血量减少，因为服务器是母体，为了防止母体子弹销毁时，客户端子弹还没有碰撞到角色，血量不能及时减少，造成数据不同步，因此血量的控制检测只能是在服务器进行计算并同步到客户端
子弹添加碰撞脚本
六、控制人物的重生 设置重生点：
七、控制敌人的生成 敌人在每个客户端都要产生，所以敌人产生在服务端来做，将产生的敌人同步到客户端上
RPC是远程调用（服务端与客户端互调用），调用服务器端的某个方法，使用Comond，想调用客户端的某个方法使用ClientRPC，
SyncVar是同步一个变量，比如同步主角的血量，
hook，指定一个字符串参数，这个参数指定方法的名字，变量的值发生改变时，调用Hook指定的方法。
using UnityEngine; using System.Collections; using UnityEngine.Networking; public class PlayerController : NetworkBehaviour { public GameObject bulletPrefab; public Transform bulletSpawn;	// Update is called once per frame void Update () { if (isLocalPlayer == false) { return; } float h = Input.GetAxis("Horizontal"); float v = Input.GetAxis("Vertical"); transform.Rotate(Vector3.up * h * 120 * Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac4ad6fc5005f404e26f085ce479dbd7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/378/">«</a>
	<span class="pagination__item pagination__item--current">379/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/380/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>