<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9bc6c7066d00e6e94269bcbc81aa3f/" rel="bookmark">
			HTML区块和布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HTML 区块元素 HTML 可以通过&lt;div&gt; 和&lt;span&gt;将元素组合起来。 大多数 HTML 元素被定义为块级元素或内联元素。
块级元素在浏览器显示时，通常会以新行来开始（和结束）。
实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;
2、HTML 内联元素 内联元素在显示时通常不会以新行开始。
实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;
3、HTML &lt;div&gt; 元素 HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。
&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。
如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。
&lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。
4、HTML &lt;span&gt; 与元素 HTML &lt;span&gt; 元素是内联元素，可用作文本的容器
&lt;span&gt; 元素也没有特定的含义。
当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。
HTML 分组标签 标签 描述 &lt;div&gt; 定义了文档的区域，块级 (block-level) &lt;span&gt; 用来组合文档中的行内元素， 内联元素(inline) HTML 布局标签 标签 描述 &lt;div&gt; 定义文档区块，块级(block-level) &lt;span&gt; 定义 span，用来组合文档中的行内元素。 HTML 布局 网页布局对改善网站的外观非常重要。 1、使用&lt;div&gt; 元素 div 元素是用于分组 HTML 元素的块级元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9bc6c7066d00e6e94269bcbc81aa3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2958741b33176f81961b8e6c946853fc/" rel="bookmark">
			Retrofit2 简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit 2 是什么 跟Volley，okHttp一样也是一个网络请求的框架，Retrofit只是在OkHttp进行了一次封装，但是Retrofit框架，将网络请求的接口、请求的参数、请求方法、解耦很彻底，适用于Java 和android。
Retrofit 2 为什么出现 1. 性能对比 据说他的效率比volley，okhttp 的还要高。 这是老外做的一个网络请求的性能耗时对比。 2. 解耦 在网络层，解耦很彻底。 请求方式，请求参数，都可以用注解来配置。 细节太多就不一一诉说，用一下就知道他的好处啦。
3. 异步处理对比 Volley 请求网络，可以在回调中进行UI更新。 OkHttp 请求网络，不可以在回调中进行UI更新。 Retrofit2 请求网络，可以在回调中进行UI更新。
http://blog.csdn.net/lxcay9/article/details/52182239 说了OkHttp有2个缺点，但是在Retrofit2 里面对OkHttp那2个缺点 1. 比如callback回来是在线程里面, 不能刷新UI，需要我们手动处理。 2. 封装比较麻烦。 进行了修复。
Retrofit 2 怎么使用 首先解释下 Retrofit 2是Retrofit的升级版本，解耦后者比前者更彻底。
1. gradle配置 如果使用Android Studio开发，在gradle里面的dependencies 下面添加 compile ‘com.squareup.retrofit2:retrofit:2.0.0-beta4’ compile ‘com.squareup.retrofit2:converter-gson:2.0.0-beta4’
2. 细节介绍 http://square.github.io/retrofit/ 这是Retrofit 的官网介绍，在阅读相关文章的时候，大家会看到这几个参数。 @Path、@Query、@QueryMap、@Field、@Body、@Part、@Header 这几个参数都是跟HTTP请求参数有关的。可能初见见到我们会觉得很陌生，那么我通个几个小栗子来介绍下这个几个参数的使用。
1.@Path
假设ip地址，都是https://www.sogou.com/ @GET(“users/{user}/repos”) Call&lt;List&lt;User&gt;&gt; listRepos (@Path("user") String user) @GET，代表的是get请求。 @Path，代表的是在url地址里面需要添加的一个参数。 如果我们基于Retrofit 访问网络，那么Url地址为： https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2958741b33176f81961b8e6c946853fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9e2d42b1a24f83a3c3ba243268eb1c/" rel="bookmark">
			bootstrip-table刷新方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;form action="#" method="post" id="form-project_status" class="form-horizontal"&gt; &lt;div class="panel panel-info"&gt; &lt;div class="panel-heading" &gt; &lt;div class=class="col-sm-3"&gt; &lt;div class="form-group"&gt; &lt;label for="quota" class="col-sm-1 control-label"&gt;查询类型：&lt;/label&gt; &lt;div class="col-sm-1"&gt; &lt;select class="form-control" id="showType" name="showType"&gt; &lt;option value="-1"&gt; 全 部 &lt;/option&gt; &lt;option value="0"&gt; 未 审 核&lt;/option&gt; &lt;option value="1"&gt;初审通过&lt;/option&gt; &lt;option value="2"&gt;终审通过&lt;/option&gt; &lt;option value="3"&gt; 未 通 过&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;a class="btn btn-success" href="javascript:submit()" id="submit" &gt;提　交&lt;/a&gt; &lt;a class="btn btn-success" href="/project/new" id="add" &gt;项目新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body collapse in"&gt; &lt;table id="telrecord-grid" data-toggle="table" data-url="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa9e2d42b1a24f83a3c3ba243268eb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b79ca46f5bdb92175dad42f8438964/" rel="bookmark">
			SpringMVC之Controller常用注解功能全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
在SpringMVC中，控制器Controller负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model返回给对应的View进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping和@RequestParam等一些注解用以定义URL 请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet 对象，它们可以通过Controller的方法参数灵活的获取到。
为了先对Controller有一个初步的印象，以下先定义一个简单的Controller： @Controller public class MyController { @RequestMapping("/showView") public ModelAndView showView() { ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("viewName"); modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 "); return modelAndView; } } 在上面的示例中，@Controller是标记在类MyController上面的，所以类MyController就是一个SpringMVC Controller对象了，然后使用@RequestMapping(“/showView”)标记在Controller方法上，表示当请求/showView.do的时候访问的是MyController的showView方法，该方法返回了一个包括Model和View的ModelAndView对象。这些在后续都将会详细介绍。
二、使用@Controller定义一个Controller控制器 @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器，这个接下来就会讲到。
单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC的一个控制器类，因为这个时候Spring还不认识它。那么要如何做Spring才能认识它呢？这个时候就需要我们把这个控制器类交给Spring来管理。拿MyController来举一个例子：
@Controller public class MyController { @RequestMapping("/showView") public ModelAndView showView() { ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("viewName"); modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 "); return modelAndView; } } 这个时候有两种方式可以把MyController交给Spring管理，好让它能够识别我们标记的@Controller。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b79ca46f5bdb92175dad42f8438964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41d37780b383b0237be3813d2fba870/" rel="bookmark">
			android TypedValue.applyDimension()的作用  单位转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，我们如果直接再java代码中进行写 view.setTextSize(24);
代表24px 并不是 24sp 或者 24dp的意思
这些一般有公式计算，然后转换成sp或者dp才行
private final int textSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 24, getResources().getDisplayMetrics());
这句话的意思就是将 24px 转成 sp单位 TypedValue底下的applyDimension方法定义如下 ：&lt;/pre&gt;&lt;pre code_snippet_id="1816496" snippet_file_name="blog_20160808_4_1323891" name="code" class="java" style="font-size: 14px;"&gt;&lt;pre name="code" class="java"&gt;public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a41d37780b383b0237be3813d2fba870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20abbc737b81f2d58fe84fc6a35b71b/" rel="bookmark">
			(java)RSA/ECB/PKCS1Padding算法加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：（有许多调试信息）
import java.io.*; import java.lang.reflect.Method; import java.security.*; import java.security.spec.*; import java.util.Base64; import javax.crypto.Cipher; public class TestEncryp { public static void main(String[] args) throws Exception { // TODO Auto-generated method stub PrivateKey pri=getPriKey("/Users/cqx/bh_pkcs8_rsa_private_key_2048.pem","RSA"); PublicKey pub=getPubKey("/Users/cqx/rsa_public_key_2048.pem","RSA"); System.out.println("hahhahah11"); String str="我是需要传递的字符串"; byte[] estr=encrypt(str.getBytes(),pub,2048, 11,"RSA/ECB/PKCS1Padding"); System.out.println(new String(estr)); System.out.println("hahhahah12"); byte[] dstr=decrypt(estr, pri, 2048, 11, "RSA/ECB/PKCS1Padding"); System.out.println(new String(dstr)); } public static byte[] decrypt(byte[] encryptedBytes, PrivateKey privateKey, int keyLength, int reserveSize, String cipherAlgorithm) throws Exception { int keyByteSize = keyLength / 8; int decryptBlockSize = keyByteSize - reserveSize; int nBlock = encryptedBytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20abbc737b81f2d58fe84fc6a35b71b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9891358756d4c6be56cd657108774c1/" rel="bookmark">
			dp与px转换工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
dp–px–sp互转、屏幕数据获取 **
DensityUtil.java -
-
package com.library.util; import android.content.Context; import android.util.DisplayMetrics; import android.util.TypedValue; import android.view.WindowManager; /** * dp与px转换工具 * Created by Jusenr on 2016/7/10. */ public final class DensityUtil { /** * dp转px * * @param context context * @param dpValue dp值 * @return px值 */ public static int dp2px(Context context, float dpValue) { return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, context.getResources().getDisplayMetrics()); } /** * sp转px * * @param context context * @param spValue sp值 * @return px值 */ public static int sp2px(Context context, float spValue) { return (int) TypedValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9891358756d4c6be56cd657108774c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ee73661cbb2046ae95084a7b12c126/" rel="bookmark">
			客户端与服务器交互---http协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[客户端服务器关系](https://img-blog.csdn.net/20160803162106434 服务器类别 URL介绍 URL常见协议 Http协议详细介绍 http协议特点 http请求方式 get请求和post请求区别 get和post选择 http通信过程 http通信请求详解 http通信响应详解 客户端服务器交互图解 iOS请求基本方案 http请求常见状态码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b24cb5ad96ba328f4629d2aff2acd2/" rel="bookmark">
			等效焦距和视场角计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 等效焦距是相对于35mm胶卷的焦距。35mm胶卷的宽和高是36mm*24mm，对角线为35mm。 我们在构造视场角fov的时候有三种方式：相对于宽，相对于高，相对于对角线。 下面我就相对于高度的方式来求等效焦距下的视场角。 fov = 2.0*atan( (h/w)*(24*0.5)/f ); h:图片的高度 w:图片的宽度 f:等效焦距 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b5de8281d9119ccaa7527320c0827c/" rel="bookmark">
			HTML 个人简历源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=GBK" /&gt;
&lt;head&gt;
&lt;title&gt;易水寒的个人简历&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor="#CCFFCC" lang=ZH-CN link=blue vlink=blue style='tab-interval:21.0pt'topmargin=4&gt;
&lt;center&gt;&lt;h1&gt;易水寒的个人简历(网页版)&lt;/h1&gt;&lt;/center&gt;
&lt;hr size=6 color=orange width=60% align="center"&gt;
&lt;center&gt;&lt;pre&gt;制作人：软件学院软开0835班 易水寒 学号：0825033504 编号：39&lt;/pre&gt;&lt;/center&gt;
&lt;center&gt;&lt;pre&gt;（作业代号：1-39-0825033504-易水寒）&lt;/pre&gt;&lt;/center&gt;
&lt;table cellspacing="0.9" border="1" align=center style='font-size:10.0pt'box="3"&gt;
&lt;th bgcolor="#99CC33" colspan="7" style='width=520pt;text-align:center;line-height:35pt;color:#CC0000' align="center"&gt;&lt;font size="+4"&gt;&lt;i&gt;&lt;big&gt;易水寒的个人简历&lt;/big&gt;&lt;/i&gt;&lt;/font&gt;&lt;/th&gt;
&lt;tr&gt;
&lt;th bgcolor=#FDEBDF style='width=55pt;height=25pt'&gt;姓名：&lt;/th&gt;
&lt;td style='width=55pt'&gt;易水寒&lt;/td&gt;
&lt;th bgcolor=#FDEBDF style='width=50pt'&gt;出生日期:&lt;/th&gt;
&lt;td style='width=55pt'&gt;1989-10-02&lt;/td&gt;
&lt;th bgcolor=#FDEBDF style='width=50pt'&gt;姓别：&lt;/th&gt;
&lt;td style='width=40pt'&gt;男&lt;/td&gt;
&lt;th rowspan="6"&gt;&lt;img src="zoukang.jpg" style='width=180pt;height=130pt'&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th bgcolor=#FDEBDF style=' height=25pt'&gt;身份证：&lt;/th&gt;
&lt;td&gt;430421198910029495&lt;/td&gt;
&lt;th bgcolor=#FDEBDF&gt;户口：&lt;/th&gt;
&lt;td&gt;湖南·衡阳&lt;/td&gt;
&lt;th bgcolor=#FDEBDF&gt;婚姻状况：&lt;/th&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b5de8281d9119ccaa7527320c0827c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08fccabb9c39966cf662ebc6115a6f9e/" rel="bookmark">
			Android使用RecyclerView实现仿微信联系人列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在联系人列表基本都是按照字母或者拼音来进行分类，右边有一排字母供用户快速定位到指定的字母位置，效果图如下：
OK，输入的联系人类型可能有很多种，比如汉字、英文、数字、特殊符号等等，其中汉字会转化成拼音，完后和英文一起进行分类，分类的原则是首字母排序，而数字、特殊符号等，统一放到“#”分类中，下面来看具体的实现。
1. 最右边字母栏的实现
我们先来看最右边的这一排字母，这个布局很简单，从上到下，第一个是一个箭头，用来滑动到联系人列表的顶部，下面依次是26个英文字母，最后是一个#字符，那实现这样一个布局，最简单的方法肯定就是自定义一个LinearLayout了，如果在xml里面一个个画那就太蛋疼了，源码如下：
LetterView.java
public class LetterView extends LinearLayout { private Context mContext; private CharacterClickListener mListener; public LetterView(Context context, AttributeSet attrs) { super(context, attrs); mContext = context; setOrientation(VERTICAL); initView(); } private void initView() { addView(buildImageLayout()); for (char i = 'A'; i &lt;= 'Z'; i++) { final String character = i + ""; TextView tv = buildTextLayout(character); addView(tv); } addView(buildTextLayout("#")); } private TextView buildTextLayout(final String character) { LinearLayout.LayoutParams layoutParams = new LinearLayout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08fccabb9c39966cf662ebc6115a6f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f80b1cac6ba56d16c4d910d41a8323/" rel="bookmark">
			ubuntu如何配置软件更新源和更新镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要的事情说三遍：配置好上网信息（ip，DNS等），电脑插上网线.....
1、首先备份Ubuntu源列表
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 或者 cd /etc/apt/ sudo cp sources.list sources.list.bak 2、打开更新源列表
sudo gedit /etc/apt/sources.list 3、选择更新源地址
可将更新源地址复制到 sources.list中去（注意文件权限），例如重庆大学源地址（代码）如下：
deb http://mirrors.cqu.edu.cn/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.cqu.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.cqu.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.cqu.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.cqu.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.cqu.edu.cn/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.cqu.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f80b1cac6ba56d16c4d910d41a8323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a6c1e78aa3b5312e32b2434fe667c8/" rel="bookmark">
			linux 操作系统中ifconfig查看和设置网卡信息命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看和设置网卡的信息命令：ifconfig
英文原意：interface configure
命令所在路径　是：/sbin/ifconfig
执行权限：root
语法：ifconfig [网卡名称] [ip地址]
范例：
ifconfig etho0 192.168.1.100 其中eth0是网卡名称，可通过ifconfig查看到
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623d1a028d36b489158d776c28fdc58a/" rel="bookmark">
			/proc/sys/net/ipv4/conf/*/promote_secondaries
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.chinaunix.net/uid-20788470-id-1841635.html
primary ip的定义也可以在这个地方看下： http://blog.chinaunix.net/u/32831/showart_1824133.html 2010-12-08更新： M: 1. 某张网卡上第一次配置的ip叫做其primary ip 。 这个定义有点不准确， 更准确的说法是： 某张网卡上第一次配置的某个子网的ip 是这张网卡的primary ip（后面在这张网卡上再配置相同子网的另外的ip， 就都是secondary ip了）. 这也意味着一张网卡可以有多个primary ip。 2. down掉所属某个子网的primary ip的时候， 所有相关的secondary ip也会down掉。 这个可以通过设置一个内核参数， 当primary ip宕掉时可以将secondary ip提升为primary ip。 echo "1" &gt; /proc/sys/net/ipv4/conf/ethX/promote_secondaries Q： 1、primary 与 secondary定义范围。这两个词语专门是指同一机器上同一网络接口上同一网段IP之间关系叫做primary 和 secondary。 2、一个接口上面统一网段多个IP，第一个起来的IP一般设置为primary ip；同一网络接口可以存在多个primary ip。 3、同一接口配置多个IP处理binary这里提到的可能遇到的问题之外；还有可能出现机器在主动对外访问时候，请求的源IP就是primary IP，这里在内网上同一接口多IP这样可能对监控上面会造成影响。 4、关于iproute 和 net-tools工具。 4.1、大部分场合对我们运维操作是没有区别的，iproute本来就是net-tools的下一代； 4.2、iproute使用的netlink接口，net-tools使用的ioctl系统调用； 4.3、primary 和 secondary 可以直接使用ip addr list看到，ifconfig是不能的；（另外Linux的策略路由是只有iproute工具才支持的） 5、一般我们不建议是用 ifconfig X down命令，其实使用ifconfig X 0大部分可以保证我们的需求 M: 既然提到了， 再发一个这方面的问题： 假如本机为客户端， 本机的eth0上有一个primary ip 和 secondary ip， 一般情况下， 请求的src ip使用的是primary ip， 但是如果请求数过多（超过了/proc/sys/net/ipv4/ip_local_port_range的范围）， 这个src ip会使用secondary ip么？ 或者是报错： 本地端口不足？ 另外， 对于 3、同一接口配置多个IP处理binary这里提到的可能遇到的问题之外；还有可能出现机器在主动对外访问时候，请求的源IP就是primary IP，这里在内网上同一接口多IP这样可能对监控上面会造成影响。 可以使用 ip命令的src选项， 来强制内核使用某个secondary ip来作为src ip。 如 ip route add default via 209.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623d1a028d36b489158d776c28fdc58a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43dbf5b5fabf7a323f54f0a5ebc73175/" rel="bookmark">
			as follows ,as follow &amp;&amp; following
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现在牛津英语上，as follow 和 as follows 用法差不多的，但后者更常用，不是说谁指一个谁指好几个。牵强附会！
为了保证正确性，你应该用as follows，单数的最好少用。意义差不多，只是口语中多些
英文的电子邮件时常会涉及到“具体情况/列表/名单如下”这样的表达法。这其实就是as follows 与following 的用法。总的来说是多用as follows，少用following 就好。具体的阐述和解释as follows:
as follows与following 的区别
"As follows" is often used to introduce a list (of things, etc.) E.g. The 75 students are divided into five groups as follows: group 1 - group 5
We may also say:
1. The 75 students are divided into the following five groups:
2. The five groups of 75 students can be found in the following list:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43dbf5b5fabf7a323f54f0a5ebc73175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a45c1c2c163a9be1107108db8378dac/" rel="bookmark">
			What is tethering and how do you enable tethering?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://3g.co.uk/guides/tethering-everything-you-need-to-know
What is tethering and how do you enable tethering? 30 Sep 2014 by Simon Thomas What is tethering? | Networks &amp; tethering | How to setup | Advantages &amp; disadvantages
Tethering can be enormously useful, but many people don’t know much about it. So whether you’re wondering how to get the most out of it or just aren’t even sure what tethering is, keep on reading, because we’ve got all the information.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a45c1c2c163a9be1107108db8378dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969bfb2a30c76bd83d5286684994c6f4/" rel="bookmark">
			markdown文本居中，段首缩进的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		居中 居中使用html添加： &lt;center&gt;这一行需要居中&lt;/center&gt;
段首缩进 将输入法切换到全角模式，方法是在中文输入法下，按shift+space键切换，然后直接输入空格就可以了，这样输入的每个空格是一个中文字符距离。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e823420433f22d3684748aef14be345/" rel="bookmark">
			MapReduce 2.0应用场景、原理与基本架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现介绍计算框架MapReduce。MapReduce一个应用场景是有大量文件，里面存储了单词， 且一个单词占一行 。执行任务是如何统计每个单词出现的次数？ 类似应用场景有搜索引擎中，统计最流行的K个搜索词以及统计搜索词频率，帮助优化搜索词提示 。
MapReduce将作业的整个运行过程分为两个阶段 ：Map阶段和Reduce阶段 Map阶段由一定数量的Map Task组成 ：
（1）、输入数据格式解析：InputFormat； （2）、输入数据处理：Mapper ；
（3）、数据分组：Partitioner 。
Reduce阶段由一定数量的Reduce Task组成 ：
（1）、数据远程拷贝 ；
（2）、数据按照key排序； （3）、数据处理：Reducer； （4）、数据输出格式：OutputFormat。 MapReduce的内部逻辑如上图所示。inputformat从hdfs上读取split进行解析，然后输出给mapTask。map阶段的输出写在磁盘上。Partitioner阶段将不同的map结果合理的分配到相应的ReduceTask。最后，通过Outputformat将结果写到HDFS上。
Inputformat有很多继承类，实现将分片数据解析成key/value对。DBInputFormat用来读取数据库，FileInputFormat用来读取各种文件形式。还有一种空文件读取方式EmptyInputFormat。split和block是两个不同的概念。spilt是mapreduce中最小的计算单元。而block是HDFS存储的最小存储单元。其一一对应，都可以由用户任意指定。
上图所示为combiner的作用，conbiner相当于一个本地的reducer操作。将相同key的map结果进行归并。在wordcount操作中conbainer可以将同一个map输出的相同word进行统计。Partitioner决定了Map Task输出的每条数据 交给哪个Reduce Task处理。 默认实现是hash(key) mod R 。其中，R是Reduce Task数目，允许用户自定义。很多情况需自定义Partitioner，比如“hash(hostname(URL)) mod R”确保相同域 名的网页交给同一个Reduce Task处理 。
上图为mapreduce的调度原理之前已经讲解不在赘述。 Client 与MapReduce 1.0的Client类似，用户通过Client与YARN 交互，提交MapReduce作业，查询作业运行状态，管理作业等。 MRAppMaster 功能类似于 1.0中的JobTracker，但不负责资源管理。功能包括：任务划分、资源申请并将之二次分配个Map Task和Reduce Task、任务状态监控和容错。 MRAppMaster有较好容错性。一旦运行失败，由YARN的ResourceManager负责重新启 动，最多重启次数可由用户设置，默认是2次。一旦超过最高重启次数，则作业运行失败。Map Task/Reduce Task 周期性向MRAppMaster汇报心跳。一旦Task挂掉，则MRAppMaster将为之重新申请资源， 并运行之。最多重新运行次数可由用户设置，默认4次。 在任务执行过程中，应该保证数据的本地性。当不能同节点访问数据时，则会进行跨节点访问，减慢执行速度，增加网络传输负载。甚至跨机架访问数据延时会更严重。MapReduce的应用场景包括：简单的数据统计，比如网站pv、uv统计、搜索引擎建索引、海量数据查找、复杂数据分析算法实现。例如：聚类算法 、分类算法、推荐算法以及图算法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fbeff3c3287c784fae81bc5b20cf7c/" rel="bookmark">
			网络通信之如何广播发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络通信基础 1.
广播一般局限于局域网，多播即可用于局域网也可跨越广域网。
2.
广播地址应用于网络内的所有主机
1)有限广播
它不被路由但会被送到相同物理网络段上的所有主机
IP地址的网络字段和主机字段全为1就是地址255.255.255.255
2)直接广播
网络广播会被路由，并会发送到专门网络上的每台主机
IP地址的网络字段定义这个网络，主机字段通常全为1，如 192.168.10.255
多播地址为IPv4D类地址：224.0.0.0到239.255.255.255.一般推荐239.0.0.0到239.255.255.255.
3. 多播具备比较完备的过滤功能，而广播容易引起网络风暴。
如果网络中两个主机上的应用程序要相互通信，其一要知道彼此的IP，其二要知道程序可监听的端口。因为同一主机上的程序使用网络是通过端口号来区分的。
UDP Socket的使用过程： 1. 初始化网络库
2. 创建SOCK_DGRAM类型的Socket。
3. 绑定套接字。
4. 发送、接收数据。
5. 销毁套接字。
6. 释放网络库。
广播数据包的原理： 专门用于同时向网络中所有工作站进行发送的一个地址叫做广播地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址。如果你的IP为：192.168.1.39，子网掩码为：255.255.255.0，则广播地址为：192.168.1.255；如果IP为192.168.1.39，子网掩码为：255.255.255.192，则广播地址为：192.168.1.63。
如果只想在本网络内广播数据，只要向广播地址发送数据包即可，这种数据包可以被路由，它会经由路由器到达本网段内的所有主机，此种广播也叫直接广播；如果想在整个网络中广播数据，要向255.255.255.255发送数据包，这种数据包不会被路由，它只能到达本物理网络中的所有主机，此种广播叫有限广播。
使用UDP协议发送、接收广播包的过程。 假如我们要向192.168.0.X，子网掩码为：255.255.255.0的子网中发送广播包。
其步骤如下：
1. 初始化Winsock库。
2. 创建SOCK_DIRAM类型的Socket。
3. 设置Socket的属性允许其广播。
4. 发送数据包到192.168.0.255
5. 接收自己广播的广播包。
6. 关闭Socket
7. 释放网络库。
注意事项如下：
1. 接收方一定要知道广播方的口号，然后绑定此端口号才能正确接收。
2. 接收方的Socket不需要设置成广播属性。
3. 绑定的IP不可以使用“127.0.0.1”，可以使用真实IP地址或者INADDR_ANY。否则接收失败。
参考代码：
[cpp] view plain copy #include &lt;stdio.h&gt; #include &lt;sys/socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fbeff3c3287c784fae81bc5b20cf7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd65c863511d15f88173ce6a060bedc5/" rel="bookmark">
			前端开发行业现状调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引子 暑假来了，我现在正带领大一的小伙伴们进行一个前端开发行业现状调查(项目我们放在了Github上)，欢迎大家有闲的时候参与调查，帮助我们了解前端开发的现状，进而帮助我们的学习。
1. 背景 前端开发行业发展迅速，技术更新速度令人咂舌。如果我们仅仅抱着10年前的教科书埋头苦读，又如何跟得上前端开发行业的步伐？如果我们不能掌握前端特有的学习方法，又如何面对不断井喷出现的新技术？有鉴于此，我们利用暑假的时间，我们追随前端开发牛人，探究他们成长的故事，听取他们对学习的建议；访问前端开发业者，了解前端技术现状、努力融入前端开发圈子；走进前端开发相关企业，探究前端开发岗位需求、技术水平，为未来的职业成长提供养料。
总体来说，本项目的大约有三：
通过调查，了解岗位需求、技术现状，明确学习目标和学习内容。通过调查，开阔眼界，发现更多的前端学习资源、学习社区；掌握前端学习方法；结交朋友，更好地融入前端开发圈。通过调查，提高团队凝聚力与知名度，提高团队成员的组织、协调与沟通能力、表达能力等 2. 实施步骤 a. 准备阶段(6.14-6.30) 搜集访谈对象（王海庆负责，国外20+ 国内30+）准备调查问卷题目（周冰婕、单超艺、郑爱萍负责，15-20左右，多多益善）确定访谈题目（王瑶、尹飞燕、徐道聪负责，5-10左右，多多益善）制作调查问卷网页（江俊杰、鲁好德负责，至少实现题目呈现、结果数据分析两个页面）书写访谈信（赵凯峰、谢秀提负责，调查问卷引言、英文牛人访谈信、国内牛人访谈信） b. 实施阶段(7.1-7.31) 每个同学至少访谈2位国外牛人，3位国内牛人，联系4位从业者填写调查问卷（从事前端的亲友等）您也可以为我们推荐访谈人物，或是帮助我们进行访谈。期待您的帮助。 3.期待您的帮助，期待您的支持。 前端开发调查问卷已经上线，欢迎参与调查。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/485/">«</a>
	<span class="pagination__item pagination__item--current">486/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/487/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>