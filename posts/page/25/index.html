<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162a66750ec4ed78cab7abc3ea0f646b/" rel="bookmark">
			动态规划解决01背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Arrays; public class ZeroOneKnapsack { public static void main(String[] args) { int[] weight = {1, 3, 4}; int[] value = {15, 20, 30}; int bag_room = 4; int[][] dp = new int[weight.length][bag_room+1]; for(int j = weight[0]; j &lt; bag_room+1; j++){ dp[0][j] = value[0]; } for(int i = 1; i &lt; weight.length; i++){ for(int j = 0; j &lt; bag_room+1; j++){ if(weight[i] &gt; j){ dp[i][j] = dp[i-1][j]; } else{ dp[i][j] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162a66750ec4ed78cab7abc3ea0f646b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e670621a1351335e18a0464308bb14/" rel="bookmark">
			Qt 的d指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 的 d 指针，也称作 pimpl（pointer to implementation）是一种常用于 C++ 库设计的技术，它用于隐藏类的私有数据和实现细节，以保持二进制兼容性并减少头文件的依赖。这种技术在 Qt 库中被广泛应用。
d 指针的核心思想是将类的私有成员变量放到一个单独的内部类中，并在原类中保留一个指向这个内部类的指针。通过这种方式，当内部实现需要更改时，只需要更改内部类，而不必更改公有类的头文件。这有利于减少编译依赖和保持 ABI（Application Binary Interface）的稳定性。
在 Qt 中，通常会看到这样的类定义：
// 前置声明 class MyClassPrivate; class MyClass { public: MyClass(); ~MyClass(); // 公共接口函数 private: Q_DECLARE_PRIVATE(MyClass) Q_DISABLE_COPY(MyClass) // d 指针，指向实现细节 MyClassPrivate * const d_ptr; }; 其中，`Q_DECLARE_PRIVATE(MyClass)` 宏用于声明一些辅助函数，它使得在 MyClass 的成员函数中可以更容易地访问 d_ptr 指向的私有成员。而 `Q_DISABLE_COPY(MyClass)` 宏用于禁止类的复制构造函数和赋值操作符，以避免不正确地复制 d 指针。
对应的，MyClassPrivate 的定义通常在源文件中出现，像这样：
class MyClassPrivate { public: // 私有数据成员和实现细节 }; MyClass::MyClass() : d_ptr(new MyClassPrivate) { // ... } MyClass::~MyClass() { delete d_ptr; } 使用 d 指针的好处包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e670621a1351335e18a0464308bb14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c759a400b19a070d617d979b686807be/" rel="bookmark">
			大米自动化生产线的运作原理与科技创新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今科技飞速发展的时代，自动化生产线已经成为各个行业提高效率、降低成本的重要工具。而在粮食产业中，大米的自动化生产线更是以其独特的魅力，引领着粮食加工业的转型升级。星派将带您深入了解大米自动化生产线的运作原理，以及科技创新如何在这一领域重塑粮食产业。
一、大米自动化生产线的运作原理
大米自动化生产线是一条集稻谷清理、砻谷、碾米、成品整理等工序于一体的现代化生产线。它通过先进的机械设备和自动化控制系统，实现了从稻谷到成品大米的全程自动化生产。
首先，稻谷经过清理设备去除杂质，然后通过砻谷机去除稻壳，得到糙米。接着，糙米进入碾米机，经过多道碾磨和筛选，去除米糠和胚芽，最终得到白米。成品大米经过色选、抛光等整理工序，成为市场上销售的高品质大米。
在整个生产过程中，自动化控制系统发挥着至关重要的作用。它通过传感器和仪表，实时监测生产线的运行状态，确保各道工序的协调配合。同时，通过数据分析和优化算法，自动化控制系统还能实现对生产过程的精准控制，提高产品质量和生产效率。
二、科技创新重塑粮食产业
大米自动化生产线的出现，是科技创新在粮食产业中的典型应用。它不仅提高了大米生产的效率和质量，还带来了以下几个方面的变革：
降低人工成本：传统的大米生产需要大量的人工操作，而自动化生产线的应用大大减少了人工参与度，降低了生产成本。
提高产品质量：自动化生产线通过精确的控制系统和高质量的机械设备，保证了产品的稳定性和一致性，提高了产品质量。
节能减排：自动化生产线采用先进的节能技术和环保材料，有效降低了生产过程中的能耗和排放，符合绿色发展的要求。
促进产业升级：自动化生产线的推广使用，推动了粮食产业的转型升级，提高了整个行业的竞争力和可持续发展能力。
大米自动化生产线作为科技创新在粮食产业中的杰出代表，正以其高效、智能、环保的特点，引领着粮食加工业的未来发展。随着科技的不断进步和应用领域的不断拓展，我们有理由相信，科技创新将继续在粮食产业中发挥更大的作用，为人类的生产生活带来更多的便利和福祉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bdd43db1f86d97e27ea88e4325cfdc/" rel="bookmark">
			爬虫实战：从外地天气到美食推荐，探索干饭人的世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是第二堂课，我们将继续学习爬虫技术。在上一节课中，我们已经学会了如何爬取干饭教程。正如鲁迅所说（我没说过），当地吃完饭就去外地吃，这启发了我去爬取城市天气信息，并顺便了解当地美食。这个想法永远是干饭人的灵魂所在。
今天我们的目标是学习如何爬取城市天气信息，因为要计划去哪里玩耍，首先得了解天气情况。虽然我们的手机已经装有许多免费天气软件，但是也不妨碍我们学习。
在我们开始学习爬虫技术之前，首先需要找到一个容易爬取数据的天气网站。并不要求特定网站，只要易于爬取的网站即可。毕竟我们目前并不需要爬取特定网站来抢票或抢购商品，我们的主要目的是学习爬虫技术。
天气爬虫 在进行爬虫操作时，如果不确定一个网站是否易于爬取，可以先尝试输入该网站的首页地址，查看能否成功解析出HTML网页。如果解析出来的页面与实际浏览的页面一致，那么说明该网站可能没有设置反爬虫机制；反之，如果解析出来的页面与实际不同，那么该网站很可能设置了反爬虫措施。在学习阶段，建议选择较为容易爬取的网站进行练习，避免过早挑战难度过大的网站。
好的，废话不多说，我们现在就开始抓取该网站上的所有城市信息。
城市列表 天气信息肯定与城市相关，因此几乎每个天气网站都会有城市列表。让我们先来抓取这些城市列表并保存起来，以备后续使用。以下是相应的代码：
# 导入urllib库的urlopen函数 from urllib.request import urlopen,Request # 导入BeautifulSoup from bs4 import BeautifulSoup as bf headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0'} req = Request("https://www.tianqi.com/chinacity.html",headers=headers) # 发出请求，获取html # 获取的html内容是字节，将其转化为字符串 html = urlopen(req) html_text = bytes.decode(html.read()) obj = bf(html_text,'html.parser') # 使用find_all函数获取所有图片的信息 province_tags = obj.find_all('h2') for province_tag in province_tags: province_name = province_tag.text.strip() cities = [] print(province_name) next_sibling = province_tag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92bdd43db1f86d97e27ea88e4325cfdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806297c251f03cddeaa3b2298e918fbf/" rel="bookmark">
			生产实践｜腾讯欧拉平台数据血缘架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 本文将介绍腾讯欧拉数据血缘的建设及应用。
主要内容包括以下几个部分：
1. 背景和目标
2. 项目架构
3. 模块化建设
4. 应用场景
5. 问答环节
01
背景和目标
腾讯欧拉数据平台，是一款基于 DataOps 理念，实现生产即治理的一站式数据平台，主要包括三个子产品：
首先是资产工厂，负责整体的数仓建设、数仓模型的开发；
第二块是欧拉的治理引擎，负责全链路成本的数据治理；
第三块是数据发现，负责元数据的管理。
数据血缘是欧拉的一个子模块，直接服务于以上三个子产品，也是本次分享的主题。
为什么要做数据血缘？主要有两个原因，一个是现状不能满足血缘数据需求，另一个是希望以血缘为基础做更多的事情。
之前公司内部另外一个 BG 负责引擎的开发，我们只能拿到 yarn 日志和 hook 的相关信息，所以只能拿到离线数仓内部表级别的数据血缘，拿不到埋点日志下发到管道再接入离线数仓这种链路血缘，因此整体覆盖度不够。另外，血缘的粒度不够细，我们之前拿到的是表级别的血缘，但需要字段级的血缘。同时，接口服务功能较少，有一些限流的限制。还有一个比较重要的问题是缺少血缘图谱挖掘计算模型，包括算法库。
我们还希望能够以血缘为基础做更多的事情，包括全链路的数据治理、指标的全链路观测、血缘的成本洞察，以及基于血缘的一些数仓开发。这些问题和需求共同催生了欧拉数据血缘的建设。
血缘的建设包括两个方面，首先是提升数据血缘的广度，涵盖从数据生产、数据加工，到数据应用的全链路。包括数据生产环节的腾讯灯塔、大同，数据加工环节的欧拉平台，以及数据应用环节的 DataTalk 报表、TAB 的 ABtest 等等，已覆盖 20+ 产品，形成了非常完整的全链路资源。
另一方面，提升数据血缘的深度，做更精细化的血缘建设。除了任务血缘之外，还有表血缘、字段血缘，目前字段血缘是最深的层级，而我们在研发一种更深层级的血缘，称为数值血缘。
任务血缘的主要工作是打通各平台产品间的任务级别抽象，实现全链路、跨平台的完整的任务血缘关系图谱，覆盖了腾讯内部多种离线和实时数据产品。
表血缘是要打造全链路血缘数据图谱，包括各种表级别的抽象，比如离线 Hive 表、MySQL 关系库的表，还有 OLAP、Impala 等等，消息队列也被定义为表级别的抽象。
在表血缘的基础上，我们会把血缘粒度拓展至字段级别。目前已经完成了离线数仓内部 SQL 任务的字段血缘建设。如果不考虑非 SQL 的任务（jar 包任务或 Spark 任务），字段级血缘会产生断层，我们的策略是以表血缘为基础，上下游进行全量依赖。假设下游表的每个字段都依赖于上游表的全部字段，可以把整个字段血缘串起来，避免中间产生断层。
数值血缘是我们内部开发的更深层次的血缘。基于 SQL 解析后的 AST，分成实体池、逻辑池和模型池，以这三个池为基础，放在图库里，就可以形成一张非常大的AST 粒度的血缘图谱。覆盖的产品主要包括 calcite 、NTLR 等。数值血缘可以帮助我们识别出加工某个指标所需的全部前置数据集合，这是目前我们在进行的最深粒度的血缘建设。
数据血缘有着非常多的应用场景，包括欧拉血缘查询服务，还有很多基线项目、成本分摊项目以及各种数据治理项。覆盖的业务包括整体 PCG 的 ToC 业务，比如 QQ、腾讯视频、腾讯新闻、腾讯看点、微视、应用宝等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806297c251f03cddeaa3b2298e918fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3491cead3110696fd77f0d59c8952d79/" rel="bookmark">
			搭建个人智能家居 3 -第一个设备“点灯”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建个人智能家居 3 -第一个外设“点灯” 前言ESPHome点灯 HomeAssistant 前言 前面我们已经完成了搭建这个智能家居所需要的环境HomeAssistant和ESPHome，今天我们开始在这个智能家居中添加我们的第一个设备（一颗LED灯），如果环境还没有搭建好，可以参考前面的两篇文章。
搭建个人智能家居 开篇（搭建Home Assistant）
搭建个人智能家居 2 -安装ESPHome
本次可以分成两步：
第一步是ESPHome编写yaml文件并烧录到ESP32开发板
第二步是HomeAssistant添加控制组件
ESPHome 点灯 这次点亮LED的演示会用ESP32开发板上的板载的LED，通过控制ESP32的某一个IO口输出高/低电平来控制LED灯的点亮和熄灭，这同样适用于用来控制继电器开关，这一类只有高低电平的两种状态的执行器、传感器在ESPHome中叫二进制传感器，在ESPHome中有专门的二进制组件去实现对这一类传感器的控制使用，但是ESPHome官方提供的Light组件中就包含有二进制LED，所以这一次控制的LED将会用ESPHome官方的Light组件去写yaml文件实现。那么现在开始在ESPHome创建设备并编写yaml文件。
在“ESPHome安装”（跳转）的那篇文章中有新建ESPHome的工程的演示，这里就不做过多的赘述，跳过新建工程的过程。
进入ESPHome的控制页面后点击“新建设备”
点击新建设备后会弹出一个对话框提示输入设备名称，按要求输入就行
接着点击“NEXT”下一步，然后跳过在线安装，选择设备，这边演示用的是ESP32的板子，所以选ESP32，如果用的是ESP32-S2、S3或者8266等选择相应的型号就行了
选择好开发板型号后，完成设备创建。
出现上面弹窗，里面的key可以记录一下，后续HomeAssistant里连接设备需要用，yaml文件里也有体现。点击跳过，到这里工程雏形已经创建好了，点击“EDIT”，进入编辑yaml文件
创建好的工程里面有一些默认的配置，开发板类型、框架、联网参数等，把鼠标的光标移到相应的地方会出现说明，感兴趣的可以去了解一下他的构成内容，这里不做过多讲解，继续“点灯”。
第一个要编辑的是把ESP32需要连接的wifi的SSID和Password填进去，注意ESP32不支持5G频段的WIFI，所以填入一个和HomeAssistant控制页面主机在同一个局域网的2.4GWIFI参数
然后在最后面插入我们调用Light组件控制LED亮起熄灭的代码。
light: - platform: binary name: "led" output: bin_led //说明： //创建一个名字为led的设备，创建的这个led继承Light组件，属于Light组件中的“binary（二进制）”类型的设备 //因为这个led是通过GPIO输出高低电平实现的，所以定义一个output的ID，与下面output的实现对应起来 output: - id: bin_led platform: gpio pin: GPIO2 //说明： //id对应上面的led这个设备的id，说明这个output是上面led设备的实现 //通过GPIO2来控制led的亮灭 由于这次用的ESP32板载的LED灯是用GPIO2控制的，所以配置的是GPIO2，如果你们控制led的引脚不同可以通过更改
pin: GPIOxx 实现。
到这里，控制手上ESP32开发板上的led需要写的yaml文件内容已经完成了点击右上角的“SAVE”保存再点“INSTALL”，弹窗选择安装yaml文件的，由于是第一次烧录，选择最后一个手动烧录
点击后开始编译
编译完成后弹窗提示选择烧录方式，选择第一个，生成bin文件用Flash Download Tools烧录
用Flash Download Tools（点击下载）把生成的bin文件烧录到ESP32开发板中，烧录过程这里不做赘述，跳过…
烧录完成后，打开串口助手，看串口返回的日志可以确认是否连上WIFI。
确认好ESP32成功联网并成功运行后，在和ESP32连的WIFI在同一局域网的主机运行HomeAsstant，并进入控制台。
HomeAssistant 运行HomeAssistant
打开控制台，点击左边导航栏的配置
如果上面配置的ESP32和这HomeAssistant主机是在同一个局域网，在“集成”中的已发现会出现在ESPHome中创建的设备名称。
点击配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3491cead3110696fd77f0d59c8952d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dfc011b70f3731e4994695a3d053651/" rel="bookmark">
			VsCode免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建本地密匙 按下Win+R输入cmd，输入
ssh-keygen -t rsa 然后连续回车直到结束
找到Your public key has been saved in C:\Users\Administrator/.ssh/id_rsa.pub，每个人都不一样找到密匙所在地
打开id_rsa.pub这个文件，可以用记事本打开，复制内容
创建服务器密匙 同上，在服务器的命令行窗口输入
ssh-keygen -t rsa 找到Your public key has been saved in /root/.ssh/id_rsa.pub
cd /root/.ssh vim authorized_keys # 将上面本地主机的密匙复制进来， wq 保存 结束！over
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd323074b4142038254b85519ced2097/" rel="bookmark">
			Hadoop集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、简介
三、下载&amp;解压及java环境搭建（三台服务器都需要）
四、修改hosts文件添加hadoop用户及免密登陆（三台服务器都需要）
五、hadoop配置（先配置一台然后复制）
六、启动hadoop并验证
官网：Apache Hadoop
一、引言 适用人群：了解hadoop的程序猿。
文章目的：记录hadoop集群安装，提供参考。
二、简介 Hadoop是一个由Apache基金会所开发的分布式系统基础架构。
用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。
Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。
Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。
三、下载&amp;解压及java环境搭建（三台服务器都需要） hadoop安装包可到http://mirrors.tuna.tsinghua.edu.cn/apache/ 网址下载安装包，文中所用版本包为hadoop-2.7.3.tar.gz。将安装包解压缩到/opt/tpapp/文件加下面。
hadoop会使用到java环境,需要早三台机器上分别安装上java环境：此处不做安装说明。
配置hadoop环境变量：
cd /etc/profile 添加以下内容
export HADOOP_HOME=/opt/tpapp/hadoop
export PATH=$PATH:$HADOOP_HOME/sbin
export PATH=$PATH:$HADOOP_HOME/bin
编辑保存后，执行source /etc/profile 使其生效。
四、修改hosts文件添加hadoop用户及免密登陆（三台服务器都需要） 修改hosts文件，添加hadoop集群的三台服务器域名配置，假设有A、B、C三台服务器，A为master主机。添加配置到hosts 10.100.40.70 master 10.100.40.80 node1 10.100.40.90 node2 添加专门操作hadoop集群的用户和用户组
添加hadoop 用户组，命令： groupadd hadoop 添加haddop用户名称，命令： useradd hadoop 将用户添加到用户组，命令： usermod -G hadoop hadoop 添加用户权限，命令： vi /etc/sudoers 在配置文件中添加hadoop ALL=(ALL) ALL 测试连通性，用hadoop用户执行连通性测试，命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd323074b4142038254b85519ced2097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5937067468469c383ee82ede9eee486b/" rel="bookmark">
			尚硅谷SpringBoot3笔记 (一) 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐课程：03.快速入门-示例Demo_哔哩哔哩_bilibili
官方笔记：SpringBoot3全栈指南 (yuque.com)
目录
01 -- 示例demo
1. 在新建项目创建一个Maven 模块 2. 引入 spring-boot-starter-parent 和 spring-boot-starter-web 依赖
3. 指示 Spring Boot 启动类
4. 构建控制器
5. 启动
6. 使用Maven打包
02 -- 特性小结
1. 简化整合
2. 简化开发
3. 简化配置
4. 简化部署
5. 简化运维
03 -- spring initializer
04 -- 应用分析
1. 依赖管理机制
2. 自动配置机制
05 -- 核心技能
1. 常用注解
2. 组件注册 ✫✫✫✫
3. 条件注解 ✫✫✫✫
4. 属性绑定 ✫✫✫✫
06 -- YAML配置文件
基本语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5937067468469c383ee82ede9eee486b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7faa73934c51716be31a9485fc7cbab7/" rel="bookmark">
			第 5 章 ROS常用组件-rosbag(自学二刷笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要参考：
课程链接:https://www.bilibili.com/video/BV1Ci4y1L7ZZ
讲义链接:Introduction · Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程
5.2.1 rosbag使用_命令行 需求:
ROS 内置的乌龟案例并操作，操作过程中使用 rosbag 录制，录制结束后，实现重放
实现：
1.准备
创建目录保存录制的文件
mkdir ./xxx cd xxx 2.开始录制
rosbag record -a -O 目标文件 操作小乌龟一段时间，结束录制使用 ctrl + c，在创建的目录中会生成bag文件。
3.查看文件
rosbag info 文件名 4.回放文件
rosbag play 文件名 重启乌龟节点，会发现，乌龟按照录制时的轨迹运动。
另请参考:
rosbag/Commandline - ROS Wiki 5.2.2 rosbag使用_编码 命令实现不够灵活，可以使用编码的方式，增强录制与回放的灵活性，本节将通过简单的读写实现演示rosbag的编码实现。
方案A：C++实现
1.写 bag #include "ros/ros.h" #include "rosbag/bag.h" #include "std_msgs/String.h" int main(int argc, char *argv[]) { ros::init(argc,argv,"bag_write"); ros::NodeHandle nh; //创建bag对象 rosbag::Bag bag; //打开 bag.open("/home/rosdemo/demo/test.bag",rosbag::BagMode::Write); //写 std_msgs::String msg; msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7faa73934c51716be31a9485fc7cbab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43049707dc7616b76f60745bc7e3d498/" rel="bookmark">
			MySQL 数据库 下载地址 国内阿里云站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql安装包下载_开源镜像站-阿里云
以 MySQL 5.7 为例
mysql-MySQL-5.7安装包下载_开源镜像站-阿里云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad16bf3db73a9f113bd6f2c06f304770/" rel="bookmark">
			深坑，谨慎用动态代理对象作为监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，三月已到，正是退税、赏桃花、看掘金的好日子，这次给大家分享下使用动态代理对象作为监听器注入中埋藏的隐患，发生在一个业务场景中，且听我一一道来。
前情回顾 假设当前有一个需求，我们需要动态监听一个人一天内执行的一些动作，作为上层应用，咱们肯定是不care具体怎么实现人动作的监测，只需要找个能干活的三方的SDK，该SDK暴漏监听的方法给上层应用，上层应用只用注册个监听器给SDK就行，当人动作发生的时候，就由SDK通过传入的监听器来通知上层应用。
SDK中定义人动作的接口如下：
interface PersonAction { /** * 起床 */ fun getUp() /** * 吃饭 */ fun eat() /** * 上厕所 */ fun goToilet() /** * 打球 */ fun playBall() /** * 做家庭作业 */ fun doHomeWork() /** * 购物 */ fun buyGoods() /** * 开车 */ fun driveCar() /** * 睡觉 */ fun sleep() } 然后SDK提供一个注入监听器的方法，并且管理上层应用注册的监听器集合，比如增删改查，以及在特定时机通知监听器人动作的执行：
object PersonActionManager { private val mActions: MutableList&lt;PersonAction&gt; = mutableListOf() fun registerPersonAction(personAction: PersonAction?) { if (personAction == null || mActions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad16bf3db73a9f113bd6f2c06f304770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda6a748a6b1e4dbb2ba8692508df05d/" rel="bookmark">
			Spring Boot启动时执行初始化操作的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 项目中，经常需要在启动过程中初始化一些数据，如从数据库读取一些配置初始化，或从数据库读取一些热点数据到redis进行初始化缓存。
方式一:实现CommandLineRunner 接口重写run方法逻辑 CommandLineRunner是Spring提供的接口，定义了一个run()方法，用于执行初始化操作。
import org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; @Component public class InitConfigCommand implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println("CommandLineRunner:"+"{}"+"接口实现方式重写"); } } CommandLineRunner的执行时机为Spring beans初始化之后，因此CommandLineRunner的执行一定是晚于@PostConstruct的。
若有多组初始化操作，则每一组操作都要定义一个CommandLineRunner派生类并实现run()方法。这些操作的执行顺序使用@Order(n)来设置，n为int型数据。
@Component @Order(99) public class CommandLineRunnerA implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println("初始化：CommandLineRunnerA"); } } @Component @Order(1) public class CommandLineRunnerB implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println("初始化：CommandLineRunnerB"); } } 如上，会先执行CommandLineRunnerB的run()，再执行CommandLineRunnerA的run()。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda6a748a6b1e4dbb2ba8692508df05d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920d2fa17b3eaea8463a89f30ec4d167/" rel="bookmark">
			C#，二项式系数（Binomial Coefficient）的七种算法与源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 二项式系数（binomial coefficient） 二项式系数（binomial coefficient），或组合数，在数学里表达为：(1 + x)ⁿ展开后x的系数（其中n为自然数）。从定义可看出二项式系数的值为整数。
二项式系数表为在我国被称为贾宪三角或杨辉三角，一般认为是北宋数学家贾宪所首创。
它记载于杨辉的《详解九章算法》(1261)之中。
在阿拉伯数学家卡西的著作《算术之钥》(1427)中也给出了一个二项式定理系数表，他所用的计算方法与贾宪的完全相同。
在欧洲，德国数学家阿皮安努斯在他1527年出版的算术书的封面上刻有此图。
但一般却称之为帕斯卡三角形，因为帕斯卡在1654年也发现了这个结果。
无论如何，二项式定理的发现，在我国比在欧洲至少要早300年。
1665年，牛顿把二项式定理推广到n为分数与负数的情形，给出了展开式。
二项式定理在组合理论、开高次方、高阶等差数列求和，以及差分法中有广泛的应用。
2 7种计算方法的源代码 using System; using System.Text; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { public static partial class Algorithm_Gallery { public static int Binomial_Coeffient(int n, int k) { if (k &gt; n) { return 0; } if (k == 0 || k == n) { return 1; } return Binomial_Coeffient(n - 1, k - 1) + Binomial_Coeffient(n - 1, k); } public static int Binomial_Coeffient_Second(int n, int k) { int[,] C = new int[n + 1, k + 1]; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/920d2fa17b3eaea8463a89f30ec4d167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77179941c507ceca532204d02b999261/" rel="bookmark">
			C#，二分法（Bisection Method）求解方程的算法与源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 二分法 二分法是一种分治算法，是一种数学思维。
对于区间[a，b]上连续不断且f（a）·f（b）&lt;0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。
基本思路：
给定精确度ξ,用二分法求函数f(x)零点近似值的步骤如下:
1 确定区间[a,b],验证f(a)·f(b)&lt;0,给定精确度ξ.
2 求区间(a,b)的中点c.
3 计算f(c).
(1) 若f(c)=0,则c就是函数的零点;
(2) 若f(a)·f(c)&lt;0,则令b=c;
(3) 若f(c)·f(b)&lt;0,则令a=c.
(4) 判断是否达到精确度ξ:即若|a-b|&lt;ξ,则得到零点近似值a(或b),否则重复2-4.
2 代码 调用之前，请用委托方法给定需要求解的方程。
这样就可以求解任意的方程而无需修改核心代码。
using System; using System.Text; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { public delegate double delegateFunctionX(double x); public static partial class Algorithm_Gallery { public static delegateFunctionX funx = null; /// &lt;summary&gt; /// 二分法解方程的算法 /// &lt;/summary&gt; /// &lt;param name="a"&gt;&lt;/param&gt; /// &lt;param name="b"&gt;&lt;/param&gt; /// &lt;param name="epsilon"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static double Bisection(double a, double b, double epsilon = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77179941c507ceca532204d02b999261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80161fd934b3e04ba83a1cccabf5059e/" rel="bookmark">
			C#，二进制数的按位旋转（Bits Rotate）算法与源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 二进制数的按位旋转 二进制数的按位旋转（翻转）是编程中常见的按位运算方法。
二进制数的按位旋转分为左转、右转。
左转意味着数据变大，右转意味着数据变小（有损）。
2 源程序 using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
namespace Legalsoft.Truffer.Algorithm
{
public static partial class Algorithm_Gallery
{
public static int Left_Rotate(int n, int d, int INT_BITS = 32)
{
return (n &lt;&lt; d) | (n &gt;&gt; (INT_BITS - d));
}
public static int Right_Rotate(int n, int d, int INT_BITS = 32)
{
return (n &gt;&gt; d) | (n &lt;&lt; (INT_BITS - d));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80161fd934b3e04ba83a1cccabf5059e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69217522038123372275639b090e97d3/" rel="bookmark">
			Spring Cloud Alibaba微服务从入门到进阶（一）（SpringBoot三板斧、SpringBoot Actuator）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot三板斧
1、加依赖
2、写注解
3、写配置
Spring Boot Actuator
Spring Boot Actuator 是 Spring Boot 提供的一系列用于监控和管理应用程序的工具和服务。
SpringBoot导航端点
其中localhost:8080/actuator/health是健康检查端点，加上以下配置：
访问显示结果：status=UP表示健康，total总磁盘量，free剩余，free剩余低于threshold就预示是不健康的
Actuator health状态
其中localhost:8080/actuator/info，是Actuator描述型端点，加配置，访问可以查到配置信息
Actuator只有Health、info是默认暴露的端点，Actuator其他端点需要配置才能暴露出来
所有端点都可以看到了
太多了，选择性激活，在配置里配上就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164b9531d30f4853c8861ad3a3ea3814/" rel="bookmark">
			linux内建命令/内部命令之caller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.caller介绍 linux内建命令caller是用来打印函数的调用者信息，需将其放入到函数中才能生效。
2.样例 [root@elasticsearch ~]# cat caller.sh #!/bin/bash function1 () { caller 0 } function1 #line 8 [root@elasticsearch ~]# sh caller.sh 8 main caller.sh #8 表示函数调用者所在的行号 #mail 表示从脚本的"main"部分开始调用 #caller.sh 表示调用脚本的名字 [root@elasticsearch ~]# [root@elasticsearch ~]# caller 0 #没有效果，因为该命令不在函数体中 [root@elasticsearch ~]# 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3464514ca012cc37f7565c07b3d289/" rel="bookmark">
			基于MPPT的光伏发电系统simulink建模与仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.光伏发电系统基础
1.1光伏电池I-V特性
2. MPPT
2.1 MPP条件
2.2 MPPT算法举例 - 电导增量法 (Perturb and Observe)
2.3 MPPT控制器设计
3. Simulink建模
4. 仿真测试结果
最大功率点跟踪（Maximum Power Point Tracking, MPPT）是光伏系统中的一种关键技术，用于实时调节光伏阵列的工作状态，使其在任何光照和温度条件下始终输出最大功率。基于最大功率点跟踪（MPPT）的光伏发电系统是一种优化技术，用于从光伏（PV）系统中提取最大功率。由于光伏单元（太阳能电池）的功率输出受多种因素影响，如太阳辐照度、温度、阴影等，因此MPPT技术对于确保在任何给定环境条件下都能从PV系统中获得最大功率至关重要。
1.光伏发电系统基础 光伏单元产生的电流（I）和电压（V）之间的关系是非线性的，并且可以通过电流-电压（I-V）特性曲线来描述。这条曲线在不同的辐照度和温度下会有所不同。功率（P）是电流和电压的乘积，即 (P = IV)。对于给定的环境条件，存在一个特定的电压（和电流），使得功率输出达到最大。这个点被称为最大功率点（MPP）。
1.1光伏电池I-V特性 光伏电池的I-V特性是指光伏电池在不同电压下的输出电流特性，它描述了光伏电池在外加电压下产生的电流与电压之间的关系。这种关系通常呈现出非线性特征，其曲线主要包括四个关键点：开路电压（Voc）、短路电流（Isc）、最大功率点（MPP）和电池的工作点。光伏电池的最大功率点（MPP）是指电流-电压特性曲线上功率最大的工作点：
其中P(V) 是光伏电池在电压V 下的输出功率，I(V) 是对应电压下的输出电流。
在光照条件下，光伏电池通过吸收光能将光能转化成电能，从而产生电流。当光照强度一定时，随着电压的增加，电流先增加后减小。这是因为光伏电池的电压和电流之间存在着固有的关系。当电压达到某一值时，电流达到最大，这个点就是最大功率点（MPP），它是光伏电池性能的重要指标之一。开路电压（Voc）是指在光伏电池两端未连接负载时的电压，此时电流为零。而短路电流（Isc）是指在光伏电池两端短接时的电流，此时电压为零。这两个参数也是描述光伏电池性能的重要指标。
总的来说，光伏电池的I-V特性是评估光伏电池性能的重要依据，对于光伏电池的实际应用具有重要意义。通过了解光伏电池的I-V特性，可以选择合适的工作点以获得最大的能量转换效率。
2. MPPT 2.1 MPP条件 光伏电池的最大功率点满足以下条件：
通过对P(V) 求导数并令其为零，可以找到MPP的位置。但实际操作中，由于环境变化及I-V特性的复杂性，直接求导并不方便，因此常采用其他算法如扰动观察法、电导增量法或粒子群优化算法等间接寻找MPP。
2.2 MPPT算法举例 - 电导增量法 (Perturb and Observe) 电导增量法是一种简单且常用的MPPT算法。其基本步骤如下：
测量当前状态：获取当前的电压Vcurrent​ 和电流Icurrent​，计算当前功率Pcurrent​。
扰动：根据预设规则改变输入电压（例如增大或减小一个固定步长），观测新的电压 Vnew​ 和电流Inew​ 及对应的功率Pnew​。
判断：比较Pcurrent​ 和Pnew​，如果Pnew​&gt;Pcurrent​，则朝着相同的方向继续扰动；如果Pnew​&lt;Pcurrent​，则反转扰动方向。
迭代：重复上述过程直到功率变化非常小，说明已接近MPP。
2.3 MPPT控制器设计 MPPT控制器通过上述算法动态调整光伏阵列与负载或电池之间的连接，以使光伏系统在不同环境条件下持续工作在最大功率点。其核心是包含一个DC-DC转换器（如降压、升压或升降压变换器），以及一套实现上述MPPT算法的控制电路和微处理器。
3. Simulink建模 up4048
4. 仿真测试结果 综上所述，MPPT技术是提高光伏发电效率的关键手段之一，它通过实时监控并优化太阳能电池板的工作状态，确保即使在光照强度和温度变化时也能最大化利用太阳能资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59328301749446931f36165bcc5ad3fb/" rel="bookmark">
			基于Floyd-Warshall算法的ISOMAP最短路径方法matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Floyd-Warshall算法
2.ISOMAP算法
3.MATLAB程序
4.仿真结果
基于Floyd-Warshall算法的ISOMAP（Isometric Mapping）最短路径方法是一种非线性降维技术，它结合了图论中的最短路径算法和多维缩放（MDS, Multidimensional Scaling）的思想，用于发现高维数据中的低维非线性结构。ISOMAP算法的核心在于通过计算数据点之间的最短路径距离来估计它们之间的测地距离（geodesic distance），然后使用这些距离来进行降维。
1.Floyd-Warshall算法 Floyd-Warshall算法是一种用于在加权图中找到任意两点之间最短路径的动态规划算法。它能够处理有向图或具有负权的边，并且可以用于计算有向图的传递闭包。该算法的时间复杂度为O(N^3)，其中N是图中的顶点数，而空间复杂度为O(N^2)。
Floyd-Warshall算法的基本思想是，通过迭代所有顶点对之间的路径，逐步更新路径长度。如果路径中经过的边权重之和小于前一条路径，则更新这条路径的长度。算法的实现通常包含三个嵌套的for循环，分别遍历所有的顶点。
此外，Floyd-Warshall算法也被称为Floyd算法、Roy-Warshall算法、Roy-Floyd算法或WFI算法。它是由Robert Floyd在1962年首次提出的，并且与Bernard Roy在1959年发表的算法和Stephen Warshall在1962年找到的图形传递闭包算法基本相同。
使用Floyd-Warshall算法计算图中任意两点之间的最短路径长度。设D 是一个N×N 的矩阵，其中D[i][j] 存储从点vi​ 到点vj​ 的最短路径长度，初始化时，D[i][j] 等于原图中点i 和点j 之间的直接距离。Floyd-Warshall算法的核心迭代过程如下：
其中′D′ 是中间结果矩阵，每次迭代更新后存储更优的最短路径信息。
最终，算法结束时D 矩阵即包含所有点对间的最短路径长度。
2.ISOMAP算法 ISOMAP（Isometric Feature Mapping）是一种非线性降维方法，它利用图论中的最短路径概念来保持数据点间的全局几何结构。在ISOMAP中，Floyd-Warshall算法被用来计算多对节点之间的所有最短路径，以构建一个反映高维数据流形结构的邻接矩阵。
基于上述最短路径，ISOMAP定义了高维数据点之间的测地距离（geodesic distance）：
然后，ISOMAP寻找一个低维嵌入Y={y1​,y2​,...,yN​}，使得低维空间中的欧氏距离尽可能地保持与高维空间中的测地距离一致，这是一个优化问题，可通过最小化以下目标函数实现：
Isomap算法如下：
步骤1：构建邻接图G（复杂度：O（DN2））
基于输入空间X中流形G上的的邻近点对i,j之间的欧式距离dx (i,j)，选取每个样本点距离最近的K个点（K-Isomap）或在样本点选定半径为常数ε的圆内所有点为该样本点的近邻点，将这些邻近点用边连接，将流形G构建为一个反映邻近关系的带权流通图G；
步骤2：计算所有点对之间的最短路径（复杂度：O（DN2））
通过计算邻接图G上任意两点之间的最短路径逼近流形上的测地距离矩阵DG={dG(i,j)}，最短路径的实现以Floyd或者Dijkstra算法为主。
步骤3：构建k维坐标向量（复杂度：O（dN2））
根据图距离矩阵DG={dG(i,j)}使用经典Mds算法在d维空间Y中构造数据的嵌入坐标表示，选择低维空间Y的任意两个嵌入坐标向量yi与yj使得代价函数最小。
3.MATLAB程序 ........................................................................... D = zeros(V, V); for i=1:V for j = i+1:V distance = norm(indata(i, :)-indata(j, :)); D(i, j) = distance; D(j, i) = distance; end end %Assign distance 1000 to the non-neighbors(adjust this value if it does not fit in you dataset) Dsort = sort(D); for k=1:V threshold = Dsort(k, numberofneighbors); for l=k+1:V if D(k,l)&gt;threshold D(k,l)=1000; D(l,k)=1000; end end end % Determine the shortest path between all pairs using Floyd-Warshall algorithm dataMatrix = FloydWarshall(D); % Centering J matrix to use in centering mOne = ones(V, V); mOne= mOne/V; J = eye(V, V)-mOne; % Double centering B matrix B = -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59328301749446931f36165bcc5ad3fb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>