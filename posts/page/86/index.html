<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a74583dfaafdfec6c0a3a8faae44f85/" rel="bookmark">
			谈一谈.pyd文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用SAPA的上采样代码的时候，作者整了一个setup的一个操作，最开始的时候没太注意，原来是运行了setup文件之后可以生成对应的.pyd文件。其生成的结果如下：
但是很疑惑pyd文件是干啥的，所以上网搜了一下学习了一下，原来.pyd文件是加密的文件。
看不懂这个文件的文件名是什么意思，搜了一下原来是cp39-win_arm64是一个有关与设备的文件名，这个是要对应删除的，将其文件名修改为av_ext.pyd。
这个加密文件使用起来还是很方便的，和使用.py文件是一样的，可以用import XXX或者from XXX import xxx。
原则上来说这样之后就可以直接使用.pyd文件里面的对应的模块了，但作为万年倒霉蛋的我来说，遇到别的问题才是正常，我运行代码给我报错： ImportError: DLL load failed while import av_ext。 错误说明是在导入av_ext包的时候加载dll文件错误，好好好又给我搞事情，根据网上教程说下一个depends就可以查看pyd文件对应的依赖了，于是我下了一个，然后对应看了一下缺少的库。（网上说将缺少的dll文件和pyd文件放到同一个文件夹下就可以了。）
所以我将一些缺失的库放到对应的文件夹下重新尝试了，但是依旧还是出现问题，不懂是不是我什么设置不对。之后我研究了一下我缺少的库好像都是torch里面的，于是我换了一个正确的torch库的环境就可以正常运行了。
总结一下，pyd文件是加密文件，以后自己工作了也可以通过这样的方式来保护自己的知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103821b0f1e91bdc3bbd3cb0863e38e6/" rel="bookmark">
			ruoyi若依前后端分离版部署centos7服务器(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 VMware虚拟机 centos7 安装环境如下
一、msql 5.7
二、nginx1.23.3
三、java8
四、redis 3.2.1
五、部署若依前端
六、部署若依后端
前言 虚拟机的桥接与nat模式 : 重点 重点！！！
无线不可以用桥接模式 ，而你用了nat模式会导致除了宿主机跟虚拟机外
同一个路由器下其他设备访问不到 ！！
尤其是宿主机的nginx更改为静态ip后会有可能出现虚拟机上不了网 互相ping不通！
强烈建议桥接模式！
由于安装其他环境设计到了ip地址，咱们先把虚拟机的ip更改为静态ip
方便后续做内网穿透
首先 ipconfig 查看宿主机ip地址 地址 网关 掩码配置到虚拟机上
其次 vmWare虚拟机设置里面 设置为桥接模式
进入虚拟机配置ipi地址 命令配置
IPADDR 192.168.0前端设置与宿主机一致 最后端的地址不一致就可以了
例如本宿主机ip为 192.168.0.116 虚拟机为 192.168.0.129
vi /etc/sysconfig/network-scripts/ifcfg-ens33 把BOOTPROTO设置为"static"
IPADDR GETWAY 设置下
服务界面化配置
接下来 咱们按照由难易简的来安装。
一、msql 5.7 这里值得注意的是 mysql版本的5.7有些语法不被8.0兼容 一定要与自己开发版本兼容
1 、检测 MySQL
注明：安装之前检测系统是否有自带的 MySQL
rpm -qa | grep mysql # 检查是否安装过 MySQL rpm -qa | grep mariadb # 检查是否存在 mariadb 数据库（内置的 MySQL 数据库），有则强制删除 rpm -e --nodeps mariadb-libs-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103821b0f1e91bdc3bbd3cb0863e38e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6499ec9e07c08df6373a465030381131/" rel="bookmark">
			iwconfig和ifconfig区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iwconfig不可以看网卡ip，ifconfig可以看ip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11008f6dd899ee9052bd3a1ddf6fc645/" rel="bookmark">
			ansible变量的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章主要介绍playbook中的变量
自定义变量使用变量文件字典变量列表变量facts变量内置变量变量的过滤器 为了能够写出更实用的playbook，需要在playbook中使用变量。下面来讲解playbook 中常见的变量。本章实验都在/home/lduan/demo2下操作，先把 demo2目录创建出来并把ansible.cfg和 hosts拷贝进去，命令如下。 [blab@node01 ~]$ mkdir demo2 [blab@node01 ~]$ cp ansible.cfg hosts demo2/ [blab@node01 ~]$ cd demo2/ [blab@node01 demo2]$ ls ansible.cfg hosts [blab@node01 demo2]$ 1.自定义变量 通过vars来定义变量，vars和 tasks对齐。定义变量的格式如下。
1 vars : 2 变量 1 : 值 1 3 变量 2 : 值 2 4 ... 定义变量时，不可有重复的变量，否则后面定义的变量的值会覆盖前面定义的变量的值， 如下所示。 1 vars : 2 aa : value1 3 bb : value2 4 aa : value3 5 ... 这里aa重复定义了，所以aa的值最终是value3。 引用变量时用 {{变量名}} ，大括号内侧两边是否有空格是无所谓的，如下所示。 1 {{ 变量名 }} 2 {{ 变量名 }} 3 {{ 变量名 }} 4 {{ 变量名 }} 练习：写一个名称为a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11008f6dd899ee9052bd3a1ddf6fc645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25050f3cac6c10cb8810624d7ab75353/" rel="bookmark">
			基于springboot的服装连锁店后台管理系统的设计与实现毕业设计源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌ 专注于VUE,小程序，安卓，Java,python,物联网专业，有16年开发经验，长年从事毕业指导，项目实战✌选取一个适合的毕业设计题目很重要。✌关注✌私信我✌具体的问题，我会尽力帮助你。
开发背景：
随着互联网技术的不断发展和普及，电子商务已经成为了现代商业活动中不可或缺的一部分。而服装行业作为人们日常生活中的必需品，其销售市场也日益庞大。然而，传统的服装销售模式存在着许多问题，如信息不透明、库存管理困难、客户关系维护不足等。为了解决这些问题，提高企业的经营效率和客户满意度，基于SpringBoot的服装连锁店后台管理系统应运而生。
该系统旨在为服装连锁店提供一个高效、便捷、易用的后台管理平台，通过对企业资源的集中管理和优化配置，实现对连锁店的统一管理和监控。通过该系统，企业可以实时掌握各店铺的销售情况、库存状况、会员信息等数据，从而做出更加明智的经营决策。同时，系统还提供了丰富的报表功能和数据分析工具，帮助企业深入挖掘潜在商机，提升市场竞争力。此外，系统还具备良好的扩展性和安全性，可以根据企业的实际需求进行定制开发，确保数据的安全性和稳定性。
在本项目中，我们将采用SpringBoot框架进行系统的搭建，结合MyBatis作为持久层框架，MySQL作为数据库管理系统。通过使用这些先进的技术框架和工具，我们可以快速地搭建出一个高效、稳定的后台管理系统，为企业提供强大的支持。在系统设计过程中，我们将充分考虑用户体验和操作便利性，力求打造出一个既实用又易用的后台管理平台。用户需求：
1. 用户管理：系统应该允许管理员添加、编辑和删除用户账户。每个用户应该有唯一的用户名和密码，以及与之相关的权限和角色。
2. 店铺管理：系统应该允许管理员添加、编辑和删除店铺信息。每个店铺应该有唯一的名称、地址和联系方式。
3. 商品管理：系统应该允许管理员添加、编辑和删除商品信息。每个商品应该有唯一的商品编号、名称、价格、库存和描述等详细信息。
4. 销售管理：系统应该能够跟踪每个店铺的销售记录，包括销售额、销售量和退货情况等。管理员可以根据需要生成销售报表和统计分析。
5. 会员管理：系统应该允许管理员添加、编辑和删除会员信息。每个会员应该有一个唯一的会员编号、姓名、联系方式和消费记录等。系统还可以提供会员等级和积分等功能。
6. 库存管理：系统应该能够实时监控每个店铺的库存状况，包括商品数量、进货记录和退货记录等。管理员可以根据需要进行库存调整和预警提醒。
7. 报表分析：系统应该提供各种报表和统计分析功能，包括销售报表、会员报表、库存报表等，以便管理员可以全面了解企业的经营状况和趋势。
8. 通知与提醒：系统应该支持多种通知方式，例如短信、邮件或站内信，以便及时向管理员发送重要信息和提醒。
9. 安全性：系统应该具备良好的安全性，包括用户登录认证、数据加密和访问控制等功能，以确保企业数据的安全和保密性。
功能需求：
1. 用户管理模块：实现用户的注册、登录、修改个人信息和密码等功能。
2. 店铺管理模块：实现店铺信息的添加、编辑和删除，包括店铺名称、地址、联系方式等。
3. 商品管理模块：实现商品的添加、编辑和删除，包括商品编号、名称、价格、库存和描述等。
4. 销售管理模块：实现销售记录的录入、查询和统计功能，包括销售额、销售量和退货情况等。
5. 会员管理模块：实现会员信息的添加、编辑和删除，包括会员编号、姓名、联系方式和消费记录等。
6. 库存管理模块：实现库存的实时监控和管理，包括商品数量、进货记录和退货记录等。
7. 报表分析模块：实现各种报表和统计分析功能的生成和展示，包括销售报表、会员报表、库存报表等。
8. 通知与提醒模块：实现多种通知方式的设置和管理，包括短信、邮件或站内信等。
9. 安全性模块：实现用户登录认证、数据加密和访问控制等功能，确保系统的安全性和稳定性。
创新点:基于SpringBoot的服装连锁店后台管理系统的设计与实现的创新点如下：
1. 前后端分离架构：采用前后端分离的开发模式，前端使用Vue.js或React等现代化框架进行开发，后端使用SpringBoot框架进行快速构建。这种架构可以提高系统的可维护性和扩展性，同时也能够加快系统的开发速度。
2. 微服务架构：将系统拆分成多个独立的微服务，每个微服务负责一个特定的功能模块，例如用户管理、商品管理、订单管理等。这样可以提高系统的可伸缩性和容错性，同时也方便对每个功能模块进行独立部署和升级。
3. 数据库分库分表：由于服装连锁店的数据量较大，为了提高系统的性能和可扩展性，可以将数据分散存储在不同的数据库服务器上，并进行分库分表。这样可以减轻单一数据库服务器的压力，提高系统的并发处理能力和响应速度。
4. 数据分析与挖掘：通过引入数据分析和挖掘技术，可以对销售数据、会员数据等进行分析，提取出有价值的信息和趋势，帮助企业做出更明智的经营决策。例如，可以通过分析销售数据来了解哪些商品的销量较高，哪些地区的客户购买力较强等。
5. 移动端支持：随着移动设备的普及，用户对于移动端的支持也变得越来越重要。因此，在设计系统时应该考虑到移动端的需求，提供移动端的应用程序或者响应式网页设计，使用户可以随时随地访问系统。
6. 安全性保护：作为企业的核心管理系统，安全性是非常重要的一点。在设计和实现过程中要充分考虑系统的安全性，采取相应的安全措施，包括用户认证、数据加密、访问控制等，以确保系统的数据安全和业务稳定。
可行性分析:经济可行性分析：
- 基于SpringBoot的服装连锁店后台管理系统将提高企业的管理效率和运营能力，减少人力资源成本。
- 该系统能够自动化处理大量的业务数据，提供准确的数据分析和决策支持，从而降低了企业的成本和风险。
- 系统的实施将带来长期的经济效益，包括减少人力成本、提高工作效率、增加销售收入等。
社会可行性分析：
- 该系统将为服装连锁店提供一个集中管理和监控的平台，方便企业管理各个店铺的运营情况。
- 通过提供准确可靠的数据分析和报表，该系统可以帮助企业更好地了解市场需求和消费者行为，从而做出更明智的决策。
- 该系统的实施将促进企业的数字化转型，符合当前社会对科技发展的需求和趋势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25050f3cac6c10cb8810624d7ab75353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c38abffa9399aa1c8f48675524b5013/" rel="bookmark">
			html table&#43;css实现可编辑表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现可编辑的 HTML 表格，你可以使用 JavaScript 和 HTML5 的 contenteditable 属性。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; table { border-collapse: collapse; width: 100%; } th, td { border: 1px solid black; padding: 8px; text-align: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table id="editableTable"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Gender&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td contenteditable="true"&gt;John Doe&lt;/td&gt; &lt;td contenteditable="true"&gt;25&lt;/td&gt; &lt;td contenteditable="true"&gt;Male&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td contenteditable="true"&gt;Jane Smith&lt;/td&gt; &lt;td contenteditable="true"&gt;30&lt;/td&gt; &lt;td contenteditable="true"&gt;Female&lt;/td&gt; &lt;/tr&gt; &lt;!-- 添加更多行 --&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; // 获取可编辑表格 var table = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c38abffa9399aa1c8f48675524b5013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1633b213733d9bd65fe7e055577cba/" rel="bookmark">
			【Java程序设计】学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章：
【Java程序设计】宠物商店管理系统
【Java程序设计】Java基础知识实验
对于学生成绩管理系统，主要可以分为如下几个功能：
录入学生成绩统计学生成绩查找学生成绩修改学生成绩删除学生成绩按平均分排序显示所有成绩退出管理系统 进入系统之后，我们应该有系统菜单，然后根据提示选择我们所要进行的操作。
（1）录入学生成绩
该功能是每次录入学生的成绩信息，或者在当前数据的基础上添加录入新的学生成绩信息；
核心代码：
//录入学生信息 public void addScore(ArrayList&lt;Student&gt; students) { System.out.println("----------录入学生数据----------"); System.out.println("请依次输入如下数据："); long id; while (true) { System.out.println("学号"); id = scanner.nextInt(); if (isValid(students, id)) { System.out.println("学号重复，请重新输入"); } else { break; } } System.out.println("年级"); String grade = scanner.next(); System.out.println("姓名"); String name = scanner.next(); System.out.println("数学"); float math = scanner.nextFloat(); System.out.println("英语"); float english = scanner.nextFloat(); System.out.println("体育"); float sport = scanner.nextFloat(); System.out.println("Java"); float java = scanner.nextFloat(); System.out.println("C++"); float cPlusPlus = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c1633b213733d9bd65fe7e055577cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f86f60d55a17eaabcfc3b6422d8073c/" rel="bookmark">
			第八课：eNSP 链路聚合2种方式（手工模式和LACP模式）拓扑配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一课：eNSP第一个网络拓扑配置教程
第二课：eNSP vlan网络拓扑图配置教程
第三课：eNSP WIFI网络拓扑配置教程
第四课：eNSP 路由器路由配置拓扑教程
第五课：eNSP DHCP拓扑配置教程
第六课：eNSP 防火墙拓扑配置教程
第七课：eNSP 单臂路由/多臂路由拓扑配置教程
一、命令说明 命令说明dis stp brief"dis stp brief"命令用于显示交换机的生成树协议（Spanning Tree Protocol，STP）的简要信息。STP是一种网络协议，用于防止网络环路，并在网络中维护一个无环路的拓扑结构，以提高网络的可靠性。该命令可以在交换机上执行，以查看STP的当前状态和配置。执行该命令后，交换机会显示与STP相关的信息，例如根桥ID、根路径成本、指定桥ID等。dis eth-trunk &lt;num&gt; dis eth-trunk &lt;num&gt; 命令用于显示编号为num的以太网汇聚（eth-trunk）的信息。eth-trunk是用于将多个物理以太网端口聚合到一个逻辑链路中的设备，以提高网络的带宽和可靠性。
执行该命令后，设备会显示eth-trunk的相关信息，包括汇聚成员端口的状态、配置参数、物理层信息等。
load-balance &lt;dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac&gt; load-balance命令是一种负载均衡策略：
dst-ip ：根据报文的目的IP地址进行负载分担 dst-mac ：根据报文的目的MAC地址进行负载分担
src-dst-ip ：根据报文的源IP地址和目的IP地址进行负载分担
src-dst-mac：根据报文的源MAC地址和目的MAC地址进行负载分担
src-ip ：根据报文的源IP地址进行负载分担
src-mac：根据报文的源MAC地址进行负载分担
二、数据链路——手工模式 作为链路聚合技术，手工模式Eth-Trunk可以完成多个物理接口聚合成一个Eth-Trunk口来提高带宽，同时能够检测到同一聚合组内的成员链路有断路等故障，但是无法检测到链路层故障、链路错连等故障。优点如下：
增加网络带宽。提高网络连接的可靠性。负载分担。 1、绘制拓扑图 2、sw配置 2个交换机的配置一样，仅贴一个交换机的配置：
第一种配置方式：
&lt;Huawei&gt;sys [Huawei]interface Eth-Trunk 1 //ID为1，范围1-63 [Huawei-Eth-Trunk1]mode ? //查看mode有几种模式，从中选择一个模式 [Huawei-Eth-Trunk1]mode manual load-balance [Huawei-Eth-Trunk1]int g0/0/1 [Huawei-GigabitEthernet0/0/1]eth-trunk 1 [Huawei-GigabitEthernet0/0/1]int g0/0/2 [Huawei-GigabitEthernet0/0/2]eth-trunk 1 [Huawei-GigabitEthernet0/0/2]dis eth-trunk 1 [Huawei-GigabitEthernet0/0/2]q [Huawei]q &lt;Huawei&gt;save 第二种配置方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f86f60d55a17eaabcfc3b6422d8073c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a330db7055ea2597cc8c0ab8be21ab6/" rel="bookmark">
			华为OD试题-最长合法表达式 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数最长合法表达式 题目
提取字符串中的最长合法简单数学表达式
字符串长度最长的，并计算表达式的值。
如果没有返回0.
简单数学表达式只能包含以下内容:
0 - 9数字，符号 + - *
说明 :
1.所有数字，计算结果都不超过 long
2.如果有多个长度一样的，请返回第一个表达式的结果
3.数学表达式，必须是最长的，合法的
4.操作符不能连续出现，如 +--+1 是不合法的
输入
字符串
输出描述
表达式值
示例
输入
1 - 2abcd
输出
1
解题思路及解题代码： 用正则表达式解，我的方式比较粗暴，所以大家就参考一下吧 这里进行对裁剪好的字符串的计算,也是使用正则表达式判断数字的位置，因为regex_search这个函数在匹配的时候会返回匹配字符串的包含首地址（frist）和不包含的结束地址（second）恰好是运算符的位置，所以遍历的同时也可以记录运算符。
默认第一个运算符是+，先运算再更新运算符。
​int calculateExpression(string&amp; expression) { regex pattern("(\\d{1,10})"); smatch match; string::const_iterator citer = expression.cbegin(); int result = 0; char op = '+'; while (regex_search(citer, expression.cend(), match, pattern))//循环匹配 { citer = match[0].second; switch (op) { case '+': result += stoi(match[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a330db7055ea2597cc8c0ab8be21ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9161de2f007c8c18c49eff2d094fad5b/" rel="bookmark">
			【C&#43;&#43;】STL 容器 - vector 动态数组容器 ⑥ ( 使用迭代器遍历 vector 容器步骤 | 获取指容器向首元素的迭代器 begin 函数 | 获取末尾迭代器 | * 迭代器解引用 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 使用迭代器遍历 vector 容器步骤1、使用迭代器遍历 vector 容器的步骤2、代码示例 - 使用迭代器遍历 vector 容器 二、 iterator 迭代器常用 api 简介1、vector 容器类 begin 函数 - 获取指容器向首元素的迭代器2、vector 容器类 end 函数 - 获取末尾迭代器3、iterator 迭代器类解引用操作 - operator* 重载运算符函数4、iterator 迭代器自增操作 - operator++ 重载运算符函数 一、 使用迭代器遍历 vector 容器步骤 1、使用迭代器遍历 vector 容器的步骤 使用 迭代器 遍历 vector 容器 ,
首先 , 获取 起始范围 迭代器 , std::vector&lt;int&gt; 类型的容器 , 其迭代器类型是 vector&lt;int&gt;::iterator , 调用 vector 类的 begin() 函数 , 可获取 指向容器中 第一个元素的迭代器 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9161de2f007c8c18c49eff2d094fad5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde6b5790cc1e951119fd6fe667932ba/" rel="bookmark">
			客服聊天机器人的设计方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文会来讨论基于文本的客服聊天机器人的设计方法。
两种客服模式 人工客服 传统的人工客服，完全由人工来提供客服服务，就是客服坐在电脑旁边，同时开n个聊天窗口回复客户。这种方式需要投入很多的人力，效率比较低下。人工客服经常重复回答简单的问题，也容易产生倦怠。
聊天机器人 客服模式的另一个极端是由完全自动化的聊天机器人提供客服服务：智能化软件直接与客户沟通。这种模式，效率很高，但是大语言模型出现之前的聊天机器人，很多时候就是个“智障”（不是骂人），根本不想跟它聊，只想直接转人工。
其他设计方法 然而， 在完全由人工操作和完全自动化两个极端之间，还有一些其他的设计方法。
机器人辅助人工客服 针对客户的问题，先有机器人生成回复建议，然后由人工客服进行审核：如果觉得建议不错直接发送，否则先修改再发给客户。
这种设计通常被称为“人为监督”：在最终回复发给客户前，有一个人工审核环节，以此减少机器人可能出现的回复错误。这样做可以减少聊天机器人可能发出错误回复的风险。
机器人分流 随着LLM的出现，可以先由机器人帮助人工客服筛选咨询内容，让机器人回答简单的问题，而将它回答不了的问题上报给人工客服。这种方式用得好，可以大大减少人工客服的时间，提高人工客服的效率，让她们可以专注于处理更复杂的请求。
安全地构建和部署客服聊天机器人 如何在企业中安全地构建和部署客服聊天机器人？
先从一个内部使用的聊天机器人开始 内部使用的话，因为毕竟是同一个公司，团队成员对机器人的错误会更宽容，碰到机器人的错误，也能理解和包容，很多时候都只会一笑而过。在这段宝贵的时间内，可以对机器人的表现进行观察和评估，同时避免那些可能会让公司声名扫地的重大错误。
采取“人为监督”的策略 当机器人表现足够稳定时，接下来采用“人为监督”的策略：让人工客服在信息真正发给客户之前进行检查。在这样做了一段时间之后，如果机器人发出的信息经过测试之后被认为基本安全，那么机器人就可以开始直接和客户对话了。
逐步扩大应用范围 一开始只是将机器人用于面向公众的简单任务，如常见问题解答、基础客户服务等，等稳定后逐步扩大其应用范围。复杂的任务可以自动判断转给人工来回答或者提供一个平滑的过渡到人工客服的机制。
在整个部署过程中，定期评估机器人的性能非常重要。使用客户反馈、解决案例的成功率等指标来评估机器人的效果，并据此进行优化。确保机器人在处理敏感信息时遵守数据保护法规，实施加密措施，确保客户数据的安全。
设计客服机器人，肯定要用到企业自己的运营知识，那就少不了用RAG，推荐阅读《万字详解，和你用RAG+LangChain实现chatpdf》：https://juejin.cn/post/7304946949940609051
最后，别忘了接入OpenAI 对于自然语言处理提供的一个免费的接口：Moderation或其他类似接口。因为客服聊天机器人可以接受任何自然语言的输入，所有的回复也是通过模型自动生成的，免不了会遇到用户输入一些奇怪的内容，比如色情、暴力等等。所以，OpenAI 专门提供了一个 moderation 接口，可以对输入以及返回的内容做检查。如果出现了这样的内容，你可以屏蔽这些用户的访问，或者人工审核用户的问题。其他的服务商也有类似的服务，如微信小程序也有文本内容安全识别之类的接口，在具体的项目落地时，都要进行考虑。
参考 https://platform.openai.com/docs/guides/moderation/moderationhttps://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/sec-center/sec-check/msgSecCheck.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ef6495d77744830a07b32eb1641515/" rel="bookmark">
			反网络爬虫的三个阶段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络爬虫的普及和网络攻击的日益复杂，升级网络安全措施成为保护网站和应用程序免受恶意爬虫侵害的必要举措。本文将深入研究反网络爬虫的三个阶段，并详细探讨IP地址过滤的策略，以提升网络的安全性。
第一部分：反网络爬虫的三个阶段
1.1 阶段一：识别和检测
在这个阶段，重点是通过分析网站和应用程序的日志，检测异常流量和行为，以识别潜在的爬虫活动。使用技术手段如用户代理检测、访问频率分析等，识别可能的爬虫请求。
1.2 阶段二：验证和确认
一旦怀疑存在爬虫活动，需要进行验证和确认。这个阶段涉及到更深入的分析，包括验证用户代理是否符合标准、确认请求的频率是否异常等。通过人工验证和自动化工具，确认是否真的有爬虫访问。
阶段三：响应和防御
在确认爬虫活动后，需要采取相应的响应和防御措施。这包括阻止爬虫访问、限制其对网站资源的访问，甚至采取法律手段防范侵权行为。在这个阶段，定期更新和改进防爬虫策略是至关重要的。
第二部分：IP地址过滤的策略
2.1 黑白名单过滤
建立黑名单，将已知的恶意IP地址IP数据云 - 免费IP地址查询 - 全球IP地址定位平台加入其中，限制其对网站和应用程序的访问。同时，建立白名单，只允许特定合法IP地址访问，提高访问的限制性。
2.2 异常流量检测
通过实时监控和分析网络流量，检测异常流量模式。大量快速的请求、高频率的访问等可能是爬虫活动的迹象。采用阈值检测和流量分析，快速识别和过滤异常流量。
2.3 智能验证码
在关键操作（如登录、提交表单等）引入智能验证码，增加爬虫破解的难度。智能验证码不仅能有效阻挡爬虫，还能提高用户体验，确保合法用户的正常访问。
2.4 使用CDN技术
利用内容分发网络（CDN）技术，将网站内容分发到全球多个节点。CDN可以通过缓存和负载均衡减轻对源服务器的直接访问，从而降低被爬取的风险。
2.5 随机延时和用户代理检测
在服务端设置随机延时，使爬虫无法通过快速的、规律性的请求进行数据抓取。另外，通过检测用户代理的合法性，识别并拒绝非法爬虫。
第三部分：优化与改进
3.1 定期更新防爬虫规则
网络爬虫技术不断演进，因此定期更新和优化防爬虫规则是至关重要的。确保防爬虫策略能够及时应对新型爬虫攻击。
3.2 结合机器学习和人工智能
引入机器学习和人工智能技术，通过学习和分析网络活动模式，不断提升对恶意爬虫的识别和防御能力。
3.3 收集反馈和改进建议
建立用户反馈机制，积极收集用户关于网站和应用程序访问体验的反馈。根据反馈意见和建议，改进防爬虫策略，更好地保障正常用户的访问。
随着网络爬虫的日益普及，升级网络安全措施成为维护网站和应用程序安全的重要任务。通过反网络爬虫的三个阶段，结合IP地址过滤的策略，可以有效地防范恶意爬虫攻击。黑白名单过滤、异常流量检测、智能验证码、CDN技术等手段，都为提高网络的安全性提供了有力支持。在不断变化的网络威胁环境中，优化与改进是持续提升网络安全的不可或缺的一环。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1db015b68fa4d10270f28803bfddf48/" rel="bookmark">
			简述相机镜头变焦与对焦、成像的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机镜头变焦与对焦概念 定义
焦点：相机的镜头是一组透镜，当平行光线穿过透镜时，会汇聚到一点上，这个点叫做焦点。
焦距：从光心（凸透镜的中心）到焦点的距离，用"f"表示。
定焦镜头：焦距固定的镜头，即定焦镜头。
变焦镜头：焦距可以调节变化的镜头，即变焦镜头。
详 解 变 焦 原 理
通常指通过移动镜头内的透镜镜片位置来拉长或缩短焦距，也叫ZOOM。改变镜头的焦距，从而造成视角或图像大小的变化，获取拉近或拉远的效果。焦距越长，视角越窄，画面中能容纳的景象就少，画面看起来越近。焦距越短，视角越大，画面中能容纳的景物就多，画面看起来较远。
变焦目前可以分为光学变焦和数字变焦两种类型
①光学变焦：通过移动镜头内部镜片的相对位置来改变焦点的位置，改变镜头焦距的长短，并改变镜头的视角大小，从而实现影像的放大与缩小。如果被拍摄的物体位置保持不变，镜头的焦距与物体的放大倍率会呈现正比例的关系，如果要用一个词来形容光学变焦的话，那就是“望远镜”。(成像面水平方向移动)
②数字变焦：通过可拍照手机处理器，把图片内的每个像素面积增大，从而达到放大的目的，就像我们在ACDSEE等图像处理软件中，强行拉大图像的像素一样，只不过这个过程在手机中进行，把原来SENSOR上的一部分像素使用插值手段进行放大。与光学变焦不同的是，数码变焦是在SENSOR垂直方向上的变化，而给人以变焦效果的。由于整个过程焦距没有任何变化，所以图像质量是会随着放大比例的增加，逐渐下降。(成像面垂直方向缩放)
数字变焦也可以分为插值算法变焦和伪数字变焦两种
插值算法变焦：对图像进行插值运算，将图像的尺寸扩大到所需的规格，这种算法就其效果而言，并不理想，尤其是当使用在手机上的时候，手机上的摄像头本身得到的数据就有较大的噪声，再插值的话，得到的图像几乎没法使用。
伪数字变焦：当摄像头不处在最大分辨率格式的情况下，比如130 万像素的 sensor 使用 640*480 的规格拍照时，仍旧设置 sersor 工作在 1280*960 的分辨率下，而后通过采集中央部分的图像来获取 640*480 的照片，使得在手机上看来所拍物体尺寸被放大了一倍。这种办法几乎不需要额外的算法支持，对图像质量也没有影
响，缺点是只有小尺寸情况下可以采用。
结论：光学变焦不会牺牲清晰度、数字变焦显著牺牲清晰度
详 解 对 焦 原 理
其实并不是改变镜头的焦距，而是改变像距，调整成像面和镜头距离，使成像面到光心的距离等于像距，使物体可以清晰的成像到胶片（感光元件）上。调整相机使被摄体成清晰的像的过程，就是调焦（对焦）过程。成像位置位于透镜1倍焦距之外、2倍焦距之内，并且成像位置即是感光元件CCD/CMOS所在的位置，这时成像非常清晰。如果成像位置偏离了感光元件CCD/CMOS所在的平面，这时成像变得非常虚，比较模糊，即出现摄影时的对焦不准现象。
对焦实际上是调整整个镜头的位置(而不是镜头内的镜片)的位置，来控制像距，从而使成像最清晰。
对焦分类
手动对焦：通过手工转动对焦环来调节相机镜头从而使拍摄出来的照片清晰的一种对焦方式。
自动对焦：由照相机根据被摄体距离的远近，自动地调节镜头的对焦距离。
多点对焦：也叫区域对焦，当对焦中心不设置在图片中心的时候，可以使用多点对焦。常见的多点对焦为5点，7点和9点对焦。
以下为大家详细介绍自动对焦的原理
自动对焦（Auto Focus，简称AF）是一个复杂的光电一体化过程，主要可以实现三个功能：一是自动判断所拍摄的主体，二是测量被摄主体与相机感光元器件之间的距离，三是驱动马达将镜头的对焦装置推到与之相应的距离刻度。
自动对焦按照是否主动测量合焦距离分为以下两种：
（1）主动式：激光对焦、TOF对焦等
优势：低反差、弱光线、细线条、运动物体
劣势：当被摄物体能吸收光波时、光波被玻璃反射等场景不能对焦到正确物体上。
（2）被动式：相位对焦、反差对焦等
优势：自身无发射系统，耗能少，小型化、逆光场景等
劣势：细线条、弱光下、偏光物体、运动物体
反差对焦（CDAF）
概念：反差对焦（Contrast Detection Auto Focus，简称CDAF），又称对比度对焦，是目前普及率最高、使用最广泛、成本相对较低的自动对焦技术。
原理和过程：反差对焦是一个反复迭代逐渐收敛的过程，即一个简单的求最大值的过程，反差对焦类似手动调焦的过程：模糊-清晰-模糊，然后逐渐平衡到一个最清晰的位置(计算反差度—&gt;移动镜头、比较反差度—&gt;直到反差度最大)。
对焦步骤
（1）未合焦状态：此时图像处于虚焦状态（2）对焦开始状态：镜头开始移动，画面逐渐清晰，对比度开始上升
（3）合焦状态：对比度最高，画面最清晰，继续移动镜头
（4）继续移动镜头发现对比度开始下降，错过焦点
（5）镜头回退至对比度最高的位置，完成对焦
优点：
（1）物理成本低
（2）无单独的子系统，不占用独立的空间（3）对焦精度高
缺点：对焦耗时会比较长，在纯色或者反差不明显的场景，对焦时间过长或精度低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1db015b68fa4d10270f28803bfddf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1654579af16ea5594837e7dbd4d2ee/" rel="bookmark">
			docker 安装 rocketmq-mqtt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rocketmq版本4.9.3 以上rocketmq-mqtt版本：latest rocketmq安装 1.下载镜像
# rocketmq镜像 docker pull apache/rocketmq:5.1.4 # rocketmq dashboard 镜像 docker pull apacherocketmq/rocketmq-dashboard:latest 2.为RocketMQ容器创建一个网络，以便容器之间可以相互通信。
docker network create rocketmq-net 3.创建nameserver挂载目录
mkdir -p /app/rocketmq/namesrv/logs /app/rocketmq/namesrv/store 4.创建broker挂载目录
mkdir -p /app/rocketmq/broker/logs /app/rocketmq/broker/store 5.创建borke配置文件目录
mkdir -p /app/rocketmq/conf 6.编辑配置文件 vim /app/rocketmq/conf/broker.conf # 集群名称 brokerClusterName = DefaultCluster # 节点名称 brokerName = broker-a # broker id节点ID， 0 表示 master, 其他的正整数表示 slave，不能小于0 brokerId = 0 # Broker服务地址	内部使用填内网ip，如果是需要给外部使用填公网ip brokerIP1 = 192.168.19.91 # Broker角色 brokerRole = ASYNC_MASTER # 刷盘方式 flushDiskType = ASYNC_FLUSH # 在每天的什么时间删除已经超过文件保留时间的 commit log，默认值04 deleteWhen = 04 # 以小时计算的文件保留时间 默认值72小时 fileReservedTime = 72 # 是否允许Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true # 是否允许Broker自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1654579af16ea5594837e7dbd4d2ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69abe31ae0cab0200b4dd453377509d5/" rel="bookmark">
			通达信指标源码，一键自动改写成选股器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#1.功能介绍：可以将通达信指标源码，一键自动化改写成选股指标，预警指标，可以省去了大量的手动人工操作，当你选股表达式写好了，就直接可以用程序代码去帮你操作，得到同样的结果。只需30秒不到就可以帮你快速生成选股公式
# @Author : 小红牛 # 微信公众号：gxzfp888 **#2.小工具的使用步骤：**将复制的源码，粘贴到黑色源码区（点复制粘贴处）即可，——写选股表达式——点击一键改写选股器（按照你写的条件表达式，提取生成对应语句）——复制源码——（检测指标是否改写正确？）把改好的指标源码，复制到通达信里面。测试一下，看能否通过，以及是否与原指标的选股输出信号是一致的，2个条件都满足说明改好了。
#选股表达式构成：变量名称+英文冒号+表达式语句+英文分号。
如果源码输出里面，可以直接找到选股表达式，复制到表达式（左键即可粘贴复制的表达式），最后点一键改选股器即可。
如果需要的选股表达式找不到，就自己写个选股表达式，然后粘贴选股表达式，再去用我的软件点击一键改选股器操作。自己写的表达式要放在源码的最后一行。
*源码粘贴处：把指标源码自动粘贴到指定位置，即黑色的源码区。
*一键清空：清空的是黑色源码区，和修好的青色源码区，方便改写下个不同源码的指标。
*复制源码：是复制改写好的指标源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7638f8f7c5625d0abcd332dc5721973d/" rel="bookmark">
			通达信自定义数据采集系统5.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程视频：
【通达信】自定义数据一键采集+写入神器5.0功能书（发布时间20200402）
#龙虎榜小红牛系统，官方微信公众号：gxzfp888 1.自定义数据模块的建立（使用前的准备）
加强了tdx自定义数据系统，龙虎榜顶级游资+活跃游资+知名游资的数据
2.采集数据之后自动导入，tdx自定义序列/外部数据，一键操作和单个操作的用法和区别要点。
3.不同软件之间，tdx自定义数据的切换使用。
4.说明：自动采集+ 导入+一键的功能，看上面的视频教程就可以了。
-!! 完毕 ，感谢您的收看!！-
----------★★历史博文集合★★----------
股软件 龙虎榜小红牛分析系统 资金大单系统
通达信主附图指标改选股器 通达信自定义数据系统
小红牛股票数据共享 其他股软 Ex系统
通达信小技巧 通达信指标编写教程 Tdx指标公式
龙虎榜教程 游资盈亏数据 产业链上下游
量化教程 指标回测 Python 股学堂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0908e8d8bb8a76a825e62375b5991dff/" rel="bookmark">
			Backtrader 文档学习-Data Feeds（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Backtrader 文档学习-Data Feeds 1.数据载入 Quickstart中已经学习了基础的数据载入到cerebro中。
self.datas 是按插入顺序的数组数组对象的别名self.data 和 self.data0 一样，都是指向第一组数据self.dataX 指向第N组数据 import backtrader as bt import backtrader.feeds as btfeeds data = btfeeds.YahooFinanceCSVData(dataname='wheremydatacsvis.csv') cerebro = bt.Cerebro() cerebro.adddata(data) # a 'name' parameter can be passed for plotting purposes 从github上下载BackTrader包，有用例中提供的所有的测试数据，有txt和csv的数据版本：
# ll total 3436 -rw-r--r--. 1 root root 24109 Apr 19 2023 2005-2006-day-001.txt -rw-r--r--. 1 root root 1820067 Apr 19 2023 2006-01-02-volume-min-001.txt -rw-r--r--. 1 root root 15123 Apr 19 2023 2006-day-001-optix.txt -rw-r--r--. 1 root root 12030 Apr 19 2023 2006-day-001.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0908e8d8bb8a76a825e62375b5991dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfc43c9f3cf08a60452f14d8be1b2c6/" rel="bookmark">
			Codeforces1913 D. Array Collapse（笛卡尔树&#43;树上dp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 解法： 容易想到区间dp 令dp[l][r]表示区间l,r的方案数 设[l,r]内最小的数下标为x: 如果x不删除,则d[l][r]+=d[l][x-1]*d[x+1][r]. 如果x删除,考虑x被哪边删除, 1.如果l!=1,说明x可以被左边的某个数删除, 则方案数为区间右边的方案数,d[l][r]+=d[x+1][r]; 2.如果r!=n,说明x可以被右边的某个数删除, 则方案数为区间左边的方案数,d[l][r]+=d[l][x-1]; 3.如果l!=1并且r!=n,说明左右两边都可以删除x, 此时[l,r]整个区间被删除的方案数重复计算了, 因此d[l][r]-=1. 复杂度O(n^2),这题n&lt;=3e5,需要优化. 可以建立笛卡尔树， 笛卡尔树每棵子树的根节点对应一段区间[l,r]的最小值x. 左子树表示区间[l,x-1],右子树表示区间[x+1,r] 我们在树上dp即可. 复杂度O(n) Code： #include &lt;bits/stdc++.h&gt; using namespace std; #define X first #define Y second #define int long long #define PI pair&lt;int, int&gt; const int maxm=3e5+5; const int mod=998244353; int n; int a[maxm]; int lc[maxm],rc[maxm]; int stk[maxm]; int d[maxm]; int build(){ for(int i=1;i&lt;=n;i++){ lc[i]=rc[i]=0; } int head=0; for(int i=1;i&lt;=n;i++){ int tp=head; while(tp&amp;&amp;a[stk[tp]]&gt;a[i])tp--; if(tp)rc[stk[tp]]=i; if(tp+1&lt;=head)lc[i]=stk[tp+1]; head=tp; stk[++head]=i; } return stk[1]; } void dfs(int x,int l,int r){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfc43c9f3cf08a60452f14d8be1b2c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6553311459581ac53152525bf94a40a9/" rel="bookmark">
			Allegro 将shape转换为line，将line转换成shape
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shape--compose shape，options选择好outline，然后Find里面只选择lines,然后点击不闭合的曲线，闭合的shape就可生成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10c315010b5f406249e327379624637/" rel="bookmark">
			彩票统计（oj题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要期末考了，真的很忙
发这个文主要是来炫耀的
唯一一个全对的
代码如下：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int cmp(const void * a, const void * b) { return * ((int *) a) - * ((int *) b); } struct Ticket{ int l[6]; int n; }ticket[1000000]; int t[10][10][10][10][10][10], count; struct Ticket * p[1000000]; int main(void) { int N; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) { int tmp[6]; for(int j = 0; j &lt; 6; j++) scanf("%d", &amp;tmp[j]); qsort(tmp, 6, sizeof(int), cmp); t[tmp[0]][tmp[1]][tmp[2]][tmp[3]][tmp[4]][tmp[5]]++; } for(int x1 = 0; x1 &lt; 10; x1++) for(int x2 = x1; x2 &lt; 10; x2++) for(int x3 = x2; x3 &lt; 10; x3++) for(int x4 = x3; x4 &lt; 10; x4++) for(int x5 = x4; x5 &lt; 10; x5++) for(int x6 = x5; x6 &lt; 10; x6++) if(t[x1][x2][x3][x4][x5][x6]) { ticket[count].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10c315010b5f406249e327379624637/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/87/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>