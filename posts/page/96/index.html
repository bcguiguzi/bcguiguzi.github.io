<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5778630e4c68cc85eafecd5ba5576c/" rel="bookmark">
			2021年蓝桥杯省赛JavaB组真题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		距离蓝桥杯省赛还有1个多月，为了拿到更好地成绩，让我们刷起来。
一：填空题 1. ASC 已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？
分析：签到题。看到这题的时候会想，这题咋这么简单，直接计算就行，都不需要写程序。实际上，在蓝桥杯省赛中，填空题的前两题和编程题的第一题都是签到题，比较简单。但同时，这也是我们要想尽办法拿下来的题目，因此一定要细心，细心，再细心。同时，我建议简单的题也最好是编程解决或者用计算器计算，毕竟考试的时候紧张的话还是有可能算错最基本的运算的。
import java.util.Scanner; // 1:无需package // 2: 类名必须Main, 不可修改 public class Main { public static void main(String[] args) { System.out.println((int)'L'); } } 输出答案：
76 注意：填空题只需要填最后的答案即可，因此可采取所有得到答案的方法。暴力+合理利用工具。
2. 卡片 小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。 小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个， 就保存起来，卡片就不能用来拼其它数了。 小蓝想知道自己能从 1 拼到多少。 例如，当小蓝有 30张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10， 但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。 现在小蓝手里有 0到 9的卡片各 2021 张，共 20210 张，请问小蓝可以从 1拼到多少？ 提示：建议使用计算机编程解决问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a5778630e4c68cc85eafecd5ba5576c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0466c1f2a18de129ce65b20f05ee3094/" rel="bookmark">
			DataFrame：两列数据生成字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种方法：set_index+to_dict() ; 字典生成式
import numpy as np import pandas as pd num = np.random.randint(60,101,6) data = { '省份':['省1','省2','省3','省4','省5','省6'], 'num':num } df = pd.DataFrame(data = data) df 省份num0省1981省2832省3913省4844省5745省6100 方法一：通过set_index提取相应数据转化为字典
# 通过set_index提取相应数据转化为字典 dict1 = df.set_index('省份')['num'].to_dict() dict1 {'省1': 98, '省2': 83, '省3': 91, '省4': 84, '省5': 74, '省6': 100} 方法二：字典生成表达式
# 字典生成表达式 dict2 = {row.省份 : row.num for row in df.itertuples()} dict2 {'省1': 98, '省2': 83, '省3': 91, '省4': 84, '省5': 74, '省6': 100} 2023年11月15日更新，感谢@看见北极星 的评论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0466c1f2a18de129ce65b20f05ee3094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d5343810b7ef2c991c83daf9debd50/" rel="bookmark">
			大模型在数据分析场景下的能力评测｜进阶篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做数据分析，什么大模型比较合适？
如何调优大模型，来更好地做数据计算和洞察分析？
如何降低整体成本，同时保障分析体验？10月25日，我们发布了数据分析场景下的大模型能力评测框架（点击查看：Kyligence LLM Benchmark for Data &amp; Analytics）
该评测发出后，我们陆续收到多家客户、大模型厂商等对于评测大模型的询问。在过去的近一个月，我们又陆续新增了一批大模型作为评测对象，如 GPT-4、文心一言 Ernie-Bot-turbo、通义千问 Qwen-14B、Minimax 等，初步得出以下结论，并在下文第 4 章节给出相应的优化建议。
GPT-4 综合成绩最强，国产大模型表现已经基本不弱于 GPT-3.5不同大模型在“数据计算”方面的差异较大，且参数越高，表现越好多数大模型在“数据洞察”方面的表现接近，一些低参数大模型的表现依然强劲，这意味着可以通过“大数据+大模型”结合来实现低成本的 AI 数据分析场景 图 1 大模型在数据分析场景下的能力评测结果，2023-11
#01 评测坐标系 从普遍意义上来讲，“数据分析”的定义为：数据分析是为了提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。我们从这个定义出发，把数据分析拆解为如下两个关键过程：数据计算和数据洞察。
1.1 数据计算
数据计算过程指在用户给定分析指令的前提下，由大模型进行指令解读，并识别用户的分析意图、匹配业务指标，并从数据库或其他数据源获取指标数值的过程。
值得说明的是，从外部获取数据一般有两种方式：一种是传统的 Text-to-SQL 即大模型生成 SQL 语句访问原始数据库，并完成取数、计算等工作，另一种是大模型生成 API 请求来访问指标平台，以直接获取指标结果。我们在 Kyligence Copilot 使用第二种方式，因为在这种方式下，所有的指标结果是由指标平台提供的，而不是大模型计算，从而确保指标数据准确性，避免“幻觉”的出现，同时保障企业内的指标口径一致性和治理合规。
对于大模型而言，这个过程重点考察两个方面：一是对业务问题的理解和意图识别能力，二是生成代码以访问外部系统的能力。
1.2 数据洞察
数据洞察过程指在用户拿到指标数据之后，开展一系列分析、洞察动作，并获得洞察结论。在传统数据分析的模式下，很多数据分析师会以 Excel 或 CSV 格式的文件形式获取指标数据，并由此开始进行可视化作图、归因分析等操作。
对于大模型而言，这个过程重点考察两个方面：一是以专业的语言表达和润色能力来解读所发现的洞察信息，二是通过可视化、文字总结等形式对统计数据进行可视化展现，向用户证明和支撑自己所发现的洞察。
#02 评测方案 在上个月发布的《大模型在数据分析场景下的能力评测》中，我们提供了 7 个评测维度。在本文中，我们将从数据计算、数据洞察这两个方面对这 7 个评分维度进行归类，并通过这 7 个维度的评分来反映各个大模型在这两方面的能力表现。
关于这 7 个维度的介绍，本文不再重复介绍，如需了解详情，请查阅《大模型在数据分析场景下的能力评测》文章。
图 2 评测坐标系的 7 个评分维度
在本轮评测工作中，我们新增了以下大模型进行评测：Azure OpenAI GPT-4、通义千问 Qwen-14B、文心一言 Ernie-Bot-turbo、MiniMax 等。另外，由于测试数据集更新迭代，我们也对上一轮评测的大模型进行重跑，包括 Azure OpenAI GPT-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d5343810b7ef2c991c83daf9debd50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd44466fb5f32e2030cf0ba60407d14d/" rel="bookmark">
			进程、线程、携程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程是资源分配的基本单位，线程是调度的基本单位，是它的一部分、进程的一个执行单位。是轻量级的进程， 在 Linux 环境下线程的本质仍是进程。线程除了栈，其它都共享进程的，它没有自己独立的内核资源、共享进程的代码段、数据段、堆、环境变量表、命令行参数、文件描述符、信号处理方式、当前工作目标、用户ID、组ID等资源，线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区。进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；同一个进程下的线程之间共享 共享本进程的地址空间和资源(线程上下文)：所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器。切换到额开销小。进程崩溃不会影响其他进程，进程之间完全隔离；线程崩溃，操作系统检测到会异常，kill掉进程，其他线程也被干掉。 协程：
比线程更加轻量级。一个线程也可以拥有多个协程，不被操作系统内核管理，而完全是由程序所控制（在用户态中执行）相当于用户态的轻量级线程，性能得到了很大的提升。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其它地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈基本没有内核切换的开销。因此，协程的开销远远小于线程的开销。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06f8ae1c5a23b978db96222eeb71633/" rel="bookmark">
			Latex在图表标题里面引用参考文献时，出现参考文献顺序混乱的解决方案（适用于bibtex）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 如果你在figure环境的\caption或\captionof中使用\cite，但是参考文献的顺序仍然不正确，可能是因为LaTeX的处理流程导致了这个问题。
比如图片在第二章节但里面引用了参考文献，在文章末尾的参考文献第二章图片的参考文献顺序，却比第一章的要靠前，latex优先处理的图标题里的bibtex。
解决办法 在这种情况下，可以尝试使用notoccite宏包来防止\cite命令影响引文的排序。
在导言区添加以下命令：
\usepackage{notoccite} 这个宏包会禁止在文本中使用的\cite命令影响参考文献的排序。请确保它在其他biblatex宏包之前加载。
如果这个方法仍然不能解决问题，可以尝试重新编译文档多次。有时候，LaTeX 需要多次运行以正确处理引用和参考文献。
如果问题仍然存在，你可能需要检查你的文档结构和使用的宏包，确保它们没有引起引用顺序混乱的冲突。
正文里引用如下:
\begin{figure} \centering \includegraphics[width=0.8\textwidth]{imgs/ch2/preload-rivet.pdf} \caption[The variability of the clamping stress as a function of the grip length for carbon steels.]{The variability of the clamping stress as a function of the grip length for carbon steels. (figure cite from \cite{a}, experimental data from Åkesson \cite{b},Wilson and Thomas \cite{Wilson1938FatigueJoints}, and Zhou \cite{c}. Also the average trend from Baron \&amp; Larson \cite{d}, and upper and lower bounds from van Maarschalkerwaart \cite{e} are reported.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06f8ae1c5a23b978db96222eeb71633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0cbaac9b7b4f4a617cf4660a83ae3c4/" rel="bookmark">
			力扣题目 --- 杨辉三角II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: rowIndex = 3 输出: [1,3,3,1] 示例 2:
输入: rowIndex = 0 输出: [1] 示例 3:
输入: rowIndex = 1 输出: [1,1] 思路描述： 按照定义进行模拟。
代码： class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;Integer&gt; result =new ArrayList&lt;&gt;(); result.add(1); if(rowIndex==0){ return result; } result.add(1); if(rowIndex==1){ return result; } for(int i=2;i&lt;=rowIndex;i++){ List&lt;Integer&gt; tmp =new ArrayList&lt;&gt;(); tmp.add(1); for(int j=0;j&lt;result.size()-1;j++){ tmp.add(result.get(j)+result.get(j+1)); } tmp.add(1); result=tmp; } return result; } } 提交结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643dc8b8f9f5690dbf52b379906c28f4/" rel="bookmark">
			力扣题目 --- 杨辉三角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2:
输入: numRows = 1 输出: [[1]] 思路描述： 按照定义来进行遍历创建，即模仿的思路。
代码： class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp=new ArrayList&lt;&gt;(); tmp.add(1); result.add(tmp); if(numRows==1){ return result; } List&lt;Integer&gt; tmp2=new ArrayList&lt;&gt;(); tmp2.add(1); tmp2.add(1); result.add(tmp2); if(numRows==2){ return result; } for(int i=3;i&lt;=numRows;i++){ List&lt;Integer&gt; tmpMy=new ArrayList&lt;&gt;(); tmpMy.add(1); for(int j=0;j&lt;result.get(i-2).size()-1;j++){ tmpMy.add(result.get(i-2).get(j)+result.get(i-2).get(j+1)); } tmpMy.add(1); result.add(tmpMy); } return result; } } 提交结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c4effc3f154dfd1a02612500d9de73/" rel="bookmark">
			力扣题目--- 打家劫舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：
输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路描述： 本题适合使用动态规划思路进行解决。我们设置一个dp数组，数组中的第i个位置的元素表示从第一家开始偷到第i家时，当前状态可以获得的最大利润。当我们选择要偷第i家的金额时，那么当前的利润为第i-2家状态的最大利润加上当前第i家的金额，若不选择偷第i家的金额，那么当前的利润为第i-1家的利润。然后比较两者大小，选择值大的为当前第i家的最大利润赋值，即为dp[i]赋值。
状态转移方程：
dp[0]=nums[0];
dp[1]=nums[1]&gt;nums[0]?nums[1]:nums[0];
dp[i]=(nums[i]+dp[i-2])&gt;dp[i-1]?(nums[i]+dp[i-2]):dp[i-1];
代码： class Solution { public int rob(int[] nums) { if(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c4effc3f154dfd1a02612500d9de73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadb20189624749aa581c44f2ba34e3a/" rel="bookmark">
			基于微信小程序的校园失物招领系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
小程序端
WEB端
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 身处网络时代，随着网络系统体系发展的不断成熟和完善，人们的生活也随之发生了很大的变化，人们在追求较高物质生活的同时，也在想着如何使自身的精神内涵得到提升，而读书就是人们获得精神享受非常重要的途径。为了满足人们随时随地只要有网络就可以看书的要求，校园失物招领小程序被开发研究了出来。
本文主要描述了该校园失物招领小程序的具体开发过程，在SSM框架的基础上，采用JSP技术和MYSQL数据库，使该校园失物招领小程序具有很好的稳定性和安全性。本设计重点从系统概述、系统分析、系统设计、数据库设计、系统测试和总结这几个方面对该校园失物招领小程序进行阐述，用户通过该校园失物招领小程序可以查询、下载及阅读自己喜欢的书籍。
该校园失物招领小程序不仅能够稳定的运行，快捷方便的操作，界面简洁清晰，而且功能齐全，实用性强。
系统展示 小程序端 用户信息界面图
失物招领展示页面。 寻物启事展示页面 公告展示页面。 WEB端 用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件
失物招领管理页面，此页面提供给管理员的功能有：查看已发布的失物招领数据，修改失物招领，失物招领作废，即可删除，还进行了对失物招领名称的模糊查询 失物招领信息的类型查询等等一些条件。
寻物启事管理页面，此页面提供给管理员的功能有：根据寻物启事进行条件查询，还可以对寻物启事进行新增、修改、查询操作等等。
公告信息管理页面，此页面提供给管理员的功能有：根据公告信息进行新增、修改、查询操作等。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadb20189624749aa581c44f2ba34e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0133c1c4a335cf53e6443a064ee9dce2/" rel="bookmark">
			git使用patch进行补丁操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、format-patch/am生成和应用补丁1、生成2、应用 二、patch文件解读 前言 在软件开发中，代码协作和版本管理是至关重要的。Git 是一个流行的分布式版本控制系统，它提供了各种功能来简化团队合作和代码管理。但是如何给已有项目打补丁，如何在线上运行的项目做增量修改是运维以及开发者需要掌握的一个比较高级的git技术，本文将介绍如何使用 Git 的补丁功能进行高效的代码协作。
一、format-patch/am生成和应用补丁 1、生成 假设在一个分支（这里的分支是hzl_patch3）上进行了修改。这里在file1.py上新增了一段代码
并且进行了提交
使用format-patch命令生成补丁文件
format-patch命令是对指定版本范围内每次commit的修改生成对应的patch文件
他的文档如下：
-n, --numbered use [PATCH n/m] even with a single patch -N, --no-numbered use [PATCH] even with multiple patches -s, --signoff add Signed-off-by: --stdout 指定输出位置，如所有patch输出到一个文件 --cover-letter generate a cover letter --numbered-files 文件名只有编号，不包含提交信息 --suffix &lt;sfx&gt; 指定patch文件名后缀，默认'.patch'，比较常用的还有`.diff` --start-number &lt;n&gt; start numbering patches at &lt;n&gt; instead of 1 -v, --reroll-count &lt;n&gt; mark the series as Nth re-roll --rfc Use [RFC PATCH] instead of [PATCH] --cover-from-description &lt;cover-from-description-mode&gt; generate parts of a cover letter based on a branch's description --subject-prefix &lt;prefix&gt; Use [&lt;prefix&gt;] instead of [PATCH] -o, --output-directory &lt;dir&gt; 指定patch的存放目录 -k, --keep-subject don't strip/add [PATCH] --no-binary don't output binary diffs --zero-commit output all-zero hash in From header --ignore-if-in-upstream don't include a patch matching a commit upstream -p, --no-stat show patch format instead of default (patch + stat) 首先通过log 找到对应的cmmitID、。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0133c1c4a335cf53e6443a064ee9dce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb02745e4c8bd6eebf730e39ad9497ae/" rel="bookmark">
			PostgreSQL基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.源码安装PostgreSQL
1.1.前置条件（root下操作）
1.1.1.卸载yum安装的postgresql
1.1.2.创建postgres用户
1.1.3.安装部分依赖
1.1.4.源码安装uuid
1.2.安装PostgreSQL
1.2.1.使用postgres用户管理PostgreSQL
1.2.2.下载解压postgres12源码包
1.2.3.编译及安装
1.2.4.安装contrib工具
1.2.5.配置环境变量
1.2.6.初始化postgreSQL 1.3.PostgreSQL服务基本管理
1.3.1启动数据库
1.3.2停止数据库
1.3.3 重启数据库
1.3.4 查看数据库状态
2.psql基本使用
2.1.登录PostgreSQL数据库
2.2.断开psql客户端
2.3."?"查询PostgreSQL支持的所有命令
2.4."\l"查看所有数据库
2.5."\c"切换数据库
2.6."\d"看当前数据库中所有表、视图、序列
2.7."\d tablename"查看该表的表定义
2.8."\db"查看表空间的信息
2.9."\dn"查看所有的模式信息
2.10."\du"或”\dg"查看数据库中的所有角色或用户
2.11."\dt+ tablename"查看表大小
2.12."\di+"查看索引大小
2.13."\h 命令"查看SQL命令语法
2.14."\timing"显示SQL语句执行时间
2.15.“\x”可以把按行展示的数据变成按列展示
2.16.自动提交功能
2.17.查看数据库版本
1.源码安装PostgreSQL 1.1.前置条件（root下操作） 1.1.1.卸载yum安装的postgresql #检查是否已经通过rpm安装postgresql数据库
rpm -qa|grep postgresql
# 卸载 包含postgresql名的程序包
yum remove postgresql*
# 删除postgres用户及其对应的用户目录（/home/postgres）
userdel -r postgres
# 检查是否存在 /usr/psqlXXX文件夹，有的话删除，例如
rm -rf /usr/pgsql-12
1.1.2.创建postgres用户 # 创建postgres用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb02745e4c8bd6eebf730e39ad9497ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970dddb34f0bfc01c3b9d81b5be7d446/" rel="bookmark">
			2024年计算，信息科学与系统国际会议 (CCISS 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年计算，信息科学与系统国际会议 (CCISS 2024) 2024 International Conference on Computing, Information Science and System (CCISS 2024)
会议地点：厦门，中国
时间: 2024年5月10日- 12日 ● 会议简介
2024年计算，信息科学与系统国际会议（CCISS 2024）将于2024年5月10日至12日在中国厦门举行。
CCISS 2024 致力于应对计算，信息科学与系统技术及其应用领域的挑战，展示与这些主题相关的最新科研成果。CCISS 2024 期待汇聚学术界和产业界的研究人员和从业人员，共同关注相关主题，并在这些领域建立新的合作关系。
● 论文出版和检索
被录用的文章将被收录在会议论文集，由ACM出版，并被Ei Compendex 和 Scopus 检索 (该出版社EI检索非常稳定)
● 征文主题 并行和分布式计算
网络架构与管理
多媒体系统
泛在计算
无线网络
人工智能
语义网计算
网络管理与服务
物联网无线网络
多媒体计算
（更多主题请见官网）
● 演讲专家
Prof. Yonghui Li (ARC Future Fellow, IEEE Fellow), 悉尼大学，澳大利亚
Prof. Ljiljana Trajkovic (IEEE Fellow), 西蒙弗雷泽大学，加拿大
Prof. Yu-Dong Zhang (Fellow of IET), 莱斯特大学，英国
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970dddb34f0bfc01c3b9d81b5be7d446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bebfa9e9756a30863ac7e991a4ac0ff/" rel="bookmark">
			Java基于itextPDF实现pdf动态导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基于itextPDF实现pdf动态导出 1、制作PDF导出模板2 、集成itextpdf3 、编写实体4 、编写主要代码5、编写controller并测试补充：踩坑记录 现在的业务越来越复杂了，有些业务场景已经不能满足与EXCEL导出和WORD导出了，例如准考证打印，电子证书等等，这些都是动态数据导出的PDF。接下来我们就看一下怎么实现PDF的动态导出吧。
1、制作PDF导出模板 第一步，我们需要制作一个PDF模板，可以先使用WORD去制作，制作完成以后再转为PDF。
当转为PDF以后，我们就需要去给PDF设置表单域了，表单域的名称和你要填充的数据名称需要一一对应。
这里推荐几个可以编辑表单域的软件：Adobe Acrobat 、 万兴PDF、PDFill、Nitro
我这里懒省事用的万兴PDF（免费版有水印），具体哪个更好用一点请大家自行判断。
2 、集成itextpdf 接下来第二步则是在项目中集成itextpdf，项目中使用的是SpringBoot 2.7 , 同时还集成了lombok.
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13&lt;/version&gt; &lt;/dependency&gt; 3 、编写实体 编写导出PDF需要用到的实体，这里注意，实体中的属性名需要和表单域名一一对应。
同时为了方便测试，在无参构造中初始化了一些默认数据。
package com.vinci.pdf.entity; import lombok.Data; /** * @package: com.vinci.pdf.entity * @className: Person * @author: Vinci * @description: 测试用实体 * @date: 2023/11/13 9:56 */ @Data public class Person { /** * @description: 姓名 **/ private String name; /** * @description: 国籍 **/ private String nationality; /** * @description: 居住地 **/ private String address; /** * @description: 民族 **/ private String nation; /** * @description: 户籍地 **/ private String registeredResidence; /** * @description: 身高 / 体重 **/ private String heightAndWeight; /** * @description: 婚姻状况 **/ private String maritalStatus; /** * @description: 年龄 **/ private Integer age; /** * @description: 照片 **/ private String largeHeadPhoto; /** * @description: 这里为了方便测试，在无参构造直接初始化数据来模拟持久化数据。 **/ public Person() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bebfa9e9756a30863ac7e991a4ac0ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b5c568099d7717bc26b97cd4640d12/" rel="bookmark">
			Apache的顶级项目文件下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Index of /dist
上述链接是Apache官方的链接，点击之后选择相应的项目，项目中有相应的文件。国内访问速度可能比较慢。
对于Apache上的项目，如果访问速度慢的话，可以访问国内相应的镜像站点
欢迎访问网易开源镜像站
清华大学开源软件镜像站 | Tsinghua Open Source Mirror
USTC Open Source Software Mirror
阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区
http://mirror.hust.edu.cn/
兰州大学开源社区镜像站
https://dlcdn.apache.org/
华为开源镜像站_软件开发服务_华为云
腾讯软件源
北京理工大学开源软件镜像服务 http://mirror.bit.edu.cn/web/
已升级为 https
https://mirrors.bit.edu.cn/web/
中国互联网络信息中心开源镜像站 http://mirrors.cnnic.cn/
Apache Software Foundation Distribution Directory http://apache.fayea.com/
镜像站中的内容与Apache上的文件目录一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec5e6be5c107ff5d48208e17ba824b5/" rel="bookmark">
			vue最强table vxe-table 虚拟滚动列表 前端导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到个问题。后台一次性返回2万条列表数据。
并且需求要求所有数据必须全部展示，不能做假分页（不能优化了）。
这些数据的直接来源就是CS客户端。
他们做CS客户端就是一次性加载几万条数据不分页（说这是客户的要求）。
我体验了一把CS客户端，数万条数据放在那里，着实卡顿。
他们CS开发人员非他妈嘴硬说，这一点也不卡，极致顺滑。
真尼玛在这里掩耳盗铃呢，是吗？懒得跟他们废话。
结论就是：永远不要和傻子讲道理。
不废话，开整吧。
既然需要一次性展示数万条数据，那么element-table基本是不行了，毕竟也不能做个假分页。
终于，茫茫人海，遇到了 vxe-table。
官方地址：https://vxetable.cn/#/table/start/install
最高支持10w+数据的流畅滚动。确实厉害。
那么这么厉害的虚拟滚动，如何实现？
官方也一语道破。
没错，就是懒加载。界面上只是在窗口可视区域范围内加载数据，随着鼠标滚动，再继续加载下一波数据。
怎么用？
第一，写下table模板 &lt;vxe-table border show-overflow show-header-overflow ref="tableRef" height="600" :row-config="{isCurrent: true, isHover: true, useKey: true}" :column-config="{resizable: true}" :export-config="{}" :loading="demo1.loading" :sort-config="{trigger: 'cell'}" :scroll-y="{ enable: true }" :checkbox-config="{checkField: 'checked'}"&gt; &lt;vxe-column type="seq" width="100" fixed="left"&gt;&lt;/vxe-column&gt; &lt;vxe-column type="checkbox" width="60" fixed="left"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="attr0" title="Attr0" width="200" sortable&gt;&lt;/vxe-column&gt; &lt;vxe-column field="attr1" title="Attr1" width="200"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="attr2" title="Attr2" width="200"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="attr3" title="Attr3" width="200"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec5e6be5c107ff5d48208e17ba824b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e061dc0d2d70844e06a3415452fe1db/" rel="bookmark">
			数据结构—LinkedList与链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链表
1. 链表的概念及结构
1. 单向或者双向
2. 带头或者不带头
3. 循环或者非循环
二.LinkedList的使用
1.LinkedList概念及结构
2. LinkedList的构造
3. LinkedList的方法
三. ArrayList和LinkedList的区别
一、链表 1. 链表的概念及结构 链表是一种 物理存储结构上非连续存储结构，数据元素的 逻辑顺序是通过链表中的 引用链接次序实现的 data表示数据；
next表示指针，它总是指向自身的下一个结点，对于只有一个结点的存在，这个next指针则永远指向自身，对于一个链表的尾部结点，next永远指向开头。 注意: 从上图可看出，链式结构在逻辑上是连续的，但是在物理上不一定连续现实中的结点一般都是从堆上申请出来的从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续 实际中链表的结构非常多样，以下情况组合起来就有8种链表结构： 1. 单向或者双向 2. 带头或者不带头 3. 循环或者非循环 二.LinkedList的使用 1.LinkedList概念及结构 LinkedList的底层是双向链表结构，由于链表没有将元素存储在连续的空间中，元素存储在单独的节点中，然后通过引用将节点连接起来了，因此在在任意位置插入或者删除元素时，不需要搬移元素，效率比较高。
在集合框架中，LinkedList也实现了List接口 【说明】 1. LinkedList实现了List接口
2. LinkedList的底层使用了双向链表
3. LinkedList没有实现RandomAccess接口，因此LinkedList不支持随机访问
4. LinkedList的任意位置插入和删除元素时效率比较高，时间复杂度为O(1)
5. LinkedList比较适合任意位置插入的场景
2. LinkedList的构造 代码：
public static void main(String[] args) { // 构造一个空的LinkedList List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;(); List&lt;String&gt; list2 = new java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e061dc0d2d70844e06a3415452fe1db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1cd5c0a08339a54940249534e90812/" rel="bookmark">
			datax 搭建使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 datax 环境搭建使用一、解压文件二、配置 json 文件三、执行命令 datax 环境搭建使用 用于全量同步
一、解压文件 将包上传至服务器
输入命令： tar -zxvf datax.tar.gz -C /opt/module/ 将包 解压到 /opt/module 目录
解压完之后，不需要任何的配置，直接就可以用
我们可以测试一下，
输入命令：/opt/module/datax/bin/datax.py /opt/module/datax/job/job.json 显示这些结果就表示成功了，这里面的 datax.py 文件是已经直接有的了，我们不用管，然后我们写数据只需要 编写 json 文件就可以了。
二、配置 json 文件 配置文件，可以直接进入这个网站：https://github.com/alibaba/DataX
然后打开之后，往下面翻
有各种读写的配置
我们就是直接从 mysql 里面读，然后写到 hdfs 上面去，我们直接点 mysql 的读，然后可以查看 mysql 的文档
这里有一个，可以编辑 json 格式化的网站：https://baidufe.com/fehelper/json-format/index.html
这上面的json job有两部分，一个是mysql读的配置 mysqlreader 和 hdfswriter 这两个名字是不能随意更改的
这是 用 表的方式导入
{ "job": { "content": [ { "reader": { "name": "mysqlreader", "parameter": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1cd5c0a08339a54940249534e90812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e728b7c74d21a1ece0a0b97dbe6ed625/" rel="bookmark">
			【EI会议征稿】第四届环境资源与能源工程国际学术会议（ICEREE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四届环境资源与能源工程国际学术会议（ICEREE 2024）
2024 4th International Conference on Environment Resources and Energy Engineering ICEREE（2020-2023）大会先后在珠海，昆明，长沙成功召开。会议主要围绕“能源工程和能源技术”、“环境科学和环境工程”等研究领域展开讨论。旨在为能源资源与环境工程的专家学者及企业发展提供一个分享研究成果、讨论存在的问题与挑战、探索前沿科技的国际性合作交流平台。第四届环境资源与能源工程国际学术会议（ICEREE 2024）将于2024年2月23-25日在中国珠海举行，欢迎国内外学者踊跃投稿和参与。 重要信息 大会官网：www.iceree.org（点击参会/投稿/了解详情）
接受/拒稿通知：投稿后1周内
大会时间：2024年2月23-25日
大会地点：中国·珠海
出版检索：E3S Web of Conferences (ISSN: 2267-1242)出版，提交CNKI知网、EI Compendex、Scopus等数据库
征稿主题
征稿包括但不限于以下研究主题：
资源与环境工程
地下水修复、地下水管理、水资源与流域管理、管理实践，水质目标标准制定，水质分类、污水及污泥处理、污泥处理及再利用、全球变暖、臭氧层损耗、碳捕获和储存、生物燃料、空气污染及控制、空气排放贸易、固体废物管理、收集系统的优化、回收和再利用、废物稳定物价、资源管理、处理和处置方法的技术层面(堆填、热处理等)、危险固体废物的管理、社会和环境的可持续性等能源工程可再生能源、太阳能、生物质能、风能、波浪和潮汐能源、地热能、核能、生物能源、氢气和燃料电池、能源材料、能源管理系统、能源的开发与利用、核能源工程、生物柴油燃料、光伏系统与太阳能工程、风能发电、太阳能电池技术、供能方案设计与优化、能源产业政策、能源政策装备技术、 节能技术、煤矿工程与技术、能源存储技术、能源安全和清洁利用 、矿产资源与采矿工程、能源设备与能源管理、能源转换与能源效率、新能源汽车、油气资源工程、混合能源系统、石油和天然气开发的新技术等
论文出版
会议论文集 所有的投稿论文都必须经过2-3位组委会专家审稿，经过严格的审稿之后，最终所有录用的论文将由E3S Web of Conferences (ISSN: 2267-1242)会议论文集出版，出版后由出版社提交至CNKI知网、EI Compendex、Scopus等数据库收录。
◆会议论文模板下载见官网相关栏目。
◆会议仅接受全英稿件。
投稿须知：
① 论文应具有学术或实用价值，且未在国内外学术期刊或会议发表过；
② 作者可通过CrossCheck, Turnitin或其他查询系统自费查重;
③ 因作者原因申请的撤稿，需扣手续费（具体退费政策详情见官网）；
④论文不得少于4页；
英文普刊 Environment, Resource and Ecology Journal（环境、资源和生态杂志）
ISSN: 2616-3756
· 主要检索类型：CNKI（知网）、Google Scholar（谷歌学术）
· 征稿主题包括： 环境科学、生态学、安全工程、环境工程、环境管理、环境化学、环境设计、环境微生物、景观生态、区域环境研究、人类住区、水质与技术、资源与环境科学、生态环境工程、水土保持与防止沙漠化、景观园林学等
· 更多征稿主题：
参会须知 1、作者参会：一篇录用文章需安排一名作者参会；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e728b7c74d21a1ece0a0b97dbe6ed625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f77fd3a107d3aea069276079f1cb23/" rel="bookmark">
			【华为OD机试 C卷】机器人仓库搬砖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 机器人搬砖，一共有N堆砖存放在N个不同的仓库中，第i堆砖中有bricks[i]块砖头，要求在8小时内搬完。机器人每小时能搬砖的数量取决于有多少能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格每小时补充一次且能量格只在这一个小时有效，为使得机器人损耗最小化尽量减小每次补充的能量格数 为了保障在8小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数。
1、无需考虑机器人补充能量格的耗时，
2、无需考虑机器人搬砖的耗时;
3、机器人每小时补充能量格只在这一个小时中有效;
输入描述 第一行为一行数字 空格分割
输出描述 机器人每小时最少需要冲的能量格 ，若无法完成任务 输出-1
用例
输入 30 12 25 8 19
输出 15
输入 10 12 25 8 19 8 6 4 17 19 20 30
输出 -1
import math def min_e(b, H): l, r = 1, max(b) while l &lt; r: m = (l + r) // 2 if sum(math.ceil(i/m) for i in b) &gt; H: l = m + 1 else: r = m if sum(math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f77fd3a107d3aea069276079f1cb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48026983e9ce47e9f577037666a156f4/" rel="bookmark">
			读读文档吧 - SQLAlchemy 2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORM Mapped Class Overview https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html
The original mapping API is commonly referred to as “classical” style, whereas the more automated style of mapping is known as “declarative” style. SQLAlchemy now refers to these two mapping styles as imperative mapping and declarative mapping.
The Declarative Mapping is the typical way that mappings are constructed in modern SQLAlchemy. # flask_sqlalchemy的源码，说明它用的是Declarative Mapping self.Model = self._make_declarative_base(model_class) """A SQLAlchemy declarative model class. Subclass this to define database models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48026983e9ce47e9f577037666a156f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/95/">«</a>
	<span class="pagination__item pagination__item--current">96/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/97/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>