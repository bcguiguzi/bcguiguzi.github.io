<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2eeefa0885c01e7f98815b1bd31ebb2/" rel="bookmark">
			利用sqlmap进行post注入学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解sqlmap sqlmap是一款开源、功能强大的自动化SQL注入工具，支持Access，MySQL，Oracle，SQL Server，DB2等多种数据库。支持get，post ，cookie注入，支持基于布尔的盲注，基于时间的盲注，错误回显注入，联合查询注入，堆查询注入等。
POST注入形成原因 1.在登录处，用于判断用户名、密码会使用select语句；
2.在修改密码处，更新密码，会使用到update语句；
3.在商城系统中，订单的添加，删除，可能会使用到insert，delete语句；
登录是执行POST请求，与GET请求不同，传给服务器的值不会再URL中出现了，而是在请求体里，当服务器拿到请求体的数据，再执行SQL语句，查询是否存在用户输入的用户名和密码。
传入参数，服务器解析参数之后，完整闭合SQL语句，构造万能密码成功登陆。
POST注入也属于SQL注入，所以究其原因还是由于参数没有过滤导致的。源码如下：
使用sqlmap进行POST注入 进入DVWA，选择Brute Force选项，username和password随便输入，然后打开burpsuite，设置好本地代理，进行抓包。
将抓到的包保存为1.txt，并放到c盘根目录下。
打开sqlmap。第一步：列出数据库：
sqlmap.py -r c:\1.txt -p username --dbs
-r表示加载一个文件，-p指定参数
第二步：猜表：选择一个数据库进行猜表：
sqlmap.py -r c:\1.txt-p username -D mysql --tables
-D表示数据库；-T表示表；-C表示列
第三步：猜列：
sqlmap.py -r c:\1.txt-p username -D mysql -T user--columns
第四步：得到数据:
sqlmap.py -r c:\1.txt -p username -D mysql -T user -C“User,Password” --dump
此时就得到了root用户的密码哈希值，接下来解密就行。
如何防止POST注入？ 权限区分：
普通用户与系统管理员用户的权限要有严格的区分。由于Drop 语句关系到数据库的基本对象，故要操作这个语句用户必须有相关的权限。在权限设计中，对于终端用户，即应用软件的使用者，没有必要给他们数据库对象的建立、删除等权限。那么即使在他们使用 SQL 语句中带有嵌入式的恶意代码，由于其用户权限的限制，这些代码也将无法被执行。故应用程序在设计的时候，最好把系统管理员的用户与普通用户区分开来。如此可以最大限度的减少注入式攻击对数据库带来的危害。
使用参数化语句：
如果在编写 SQL 语句的时候，用户输入的变量不是直接嵌入到 SQL 语句，而是通过参数来传递这个变量的话，那么就可以有效的防治 SQL 注入式攻击。也就是说，用户的输入绝对不能够直接被嵌入到 SQL 语句中。与此相反，用户的输入的内容必须进行过滤，或者使用参数化的语句来传递用户输入的变量。参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。采用这种措施，可以杜绝大部分的 SQL 注入式攻击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2eeefa0885c01e7f98815b1bd31ebb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3084edbbb00f64e3e4f4acac30e56471/" rel="bookmark">
			用Java解决华为OD机试考题，目标300&#43;真题，清单奉上，祝你上岸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 华为OD机考大纲 其它语言版本华为 OD 机试题清单（机试题库还在逐日更新）详细大纲 其它语言版本 本目录为华为od机试JS题解目录，其它版本清单如下
⭐️华为OD机考 Python https://blog.csdn.net/hihell/category_12199275.html
⭐️华为OD机考 C++ https://blog.csdn.net/hihell/category_12199283.html
⭐️华为OD机考 JS https://blog.csdn.net/hihell/category_12201825.html
⭐️华为OD机考 JAVA https://blog.csdn.net/hihell/category_12201821.html
⭐️华为OD机考 Golang https://blog.csdn.net/hihell/category_12231589.html
⭐️ 华为OD机考真 C 语言 https://blog.csdn.net/hihell/category_12225286.html
华为 OD 机试题清单（机试题库还在逐日更新） 直接在本页使用 Ctrl+F，输入题目名称就可以进行检索。
详细大纲 华为OD机试题，用 Java 解【最远足迹】问题华为OD机试题，用 Java 解【射击比赛】问题华为OD机试题，用 Java 解【星际篮球争霸赛】问题华为OD机试题，用 Java 解【水仙花数 2】问题华为OD机试题，用 Java 解【计算礼品发放的最小分组数目】问题华为OD机试题，用 Java 解【任务调度】问题华为OD机试题，用 Java 解【乱序整数序列 两数之和绝对值最小】问题华为OD机试题，用 Java 解【字符串序列判定】问题华为OD机试 题，用 Java 解【交换字符】问题华为OD机试题，用 Java 解【找字符】问题华为OD机试题，用 Java 解【获得完美走位】问题华为OD机试题，用 Java 解【去除多余空格】问题华为OD机试题，用 Java 解【整数编码】问题华为OD机试题，用 Java 解【匿名信】问题华为OD机试题，用 Java 解【找终点】问题华为OD机试题，用 Java 解【执行时长】问题华为OD机试题，用 Java 解【整数对最小和】问题华为OD机试题，用 Java 解【敏感字段加密】问题华为OD机试题，用 Java 解【整型数组按个位值排序】问题华为OD机试题，用 Java 解【日志采集系统】问题华为OD机试题，用 Java 解【最长连续子串】问题华为OD机试题，用 Java 解【找朋友】问题华为OD机试题，用 Java 解【字符串筛选排序】问题华为OD机试题，用 Java 解【最低位排序】问题 | 含编码思路华为OD机试题，用 Java 解【用连续自然数之和来表达整数】问题华为OD机试题，用 Java 解【找车位】问题华为OD机试题，用 Java 解【新工号系统】问题华为OD机试题，用 Java 解【找出符合要求的字符串子串】问题 | 含代码编写思路华为OD机试题，用 Java 解【新学校选址】问题华为OD机试题，用 Java 解【数字加减游戏】问题华为OD机试题，用 Java 解【子序列长度】问题华为OD机试题，用 Java 解【寻找相同子串】问题华为OD机试题，用 Java 解【数组二叉树】问题华为OD机试题，用 Java 解【英文输入法】问题华为OD机试题，用 Java 解【用户调度问题】问题华为OD机试题，用 Java 解【求最大数字】问题华为OD机试题，用 Java 解【分奖金】问题华为OD机试题，用 Java 解【一种字符串压缩表示的解压】问题华为OD机试题，用 Java 解【寻找身高相近的小朋友】问题华为OD机试题，用 Java 解【获取最大软件版本号】问题华为OD机试题，用 Java 解【猜字谜】问题华为OD机试题，用 Java 解【相对开音节】问题华为OD机试题，用 Java 解【数据分类】问题华为OD机试题，用 Java 解【括号检查】问题华为OD机试题，用 Java 解【众数和中位数】问题华为OD机试题，用 Java 解【数字涂色】问题华为OD机试题，用 Java 解【字符串加密】问题华为OD机试题，用 Java 解【数组组成的最小数字】问题华为OD机试题，用 Java 解【字母计数】问题华为OD机试题，用 Java 解【括号匹配】问题华为OD机试题，用 Java 解【数列描述】问题华为OD机试题，用 Java 解【整数分解】问题华为OD机试题，用 Java 解【太阳能板最大面积】问题华为OD机试题，用 Java 解【素数之积】问题华为OD机试题，用 Java 解【单词反转】问题华为OD机试题，用 Java 解【求最多可以派出多少支团队】问题华为OD机试题，用 Java 解【水仙花数】问题华为OD机试题，用 Java 解【查找重复代码】问题华为OD机试题，用 Java 解【数字加减游戏】问题华为OD机试题，用 Java 解【计算网络信号】问题华为OD机试题，用 Java 解【简易内存池 2】问题华为OD机试题，用 Java 解【内存资源分配】问题华为OD机试题，用 Java 解【最小传递延迟】问题华为OD机试题，用 Java 解【流水线】问题华为OD机试题，用 Java 解【数组合并】问题华为OD机试题，用 Java 解【入栈出栈】问题华为OD机试题，用 Java 解【靠谱的车】问题华为OD机试题，用 Java 解【连续字母长度】问题华为OD机试题，用 Java 解【特异性双端队列】问题华为OD机试题，用 Java 解【压缩报文还原】问题华为OD机试题，用 Java 解【单词接龙】问题华为OD机试题，用 Java 解【判断字符串子序列】问题华为OD机试题，用 Java 解【火星文计算 2】问题华为OD机试题，用 Java 解【快递运输】问题华为OD机试题，用 Java 解【求符合要求的结对方式】问题华为OD机试题，用 Java 解【求字符串中所有整数的最小和】问题华为OD机试题，用 Java 解【两数之和绝对值最小】问题华为OD机试题，用 Java 解【事件推送】问题华为OD机试题，用 Java 解【求解连续数列】问题华为OD机试题，用 Java 解【机器人走迷宫】问题华为OD机试题，用 Java 解【开放日活动】问题华为OD机试题，用 Java 解【任务混部】问题华为OD机试题，用 Java 解【最多等和不相交连续子序列】问题华为OD机试题，用 Java 解【斗地主】问题华为OD机试题，用 Java 解【静态扫描最优成本】问题华为OD机试题，用 Java 解【相同数字的积木游戏 1】问题华为OD机试题，用 Java 解【最短耗时】问题华为OD机试题，用 Java 解【租车骑绿岛】问题华为OD机试题，用 Java 解【最短木板长度】问题华为OD机试题，用 Java 解【人数最多的站点】问题华为OD机试题，用 Java 解【考古学家】问题华为OD机试题，用 Java 解【N 进制减法】问题华为OD机试题，用 Java 解【出租车计费】问题华为OD机试题，用 Java 解【最小步骤数】问题华为OD机试题，用 Java 解【箱子之形摆放】问题华为OD机试题，用 Java 解【任务总执行时长】问题华为OD机试题，用 Java 解【数组排序】问题华为OD机试题，用 Java 解【最大排列】问题华为OD机试题，用 Java 解【第 N 个排列】问题华为OD机试题，用 Java 解【字符串变换最小字符串】问题华为OD机试题，用 Java 解【玩牌高手】问题华为OD机试题，用 Java 解【计算最大乘积】问题华为OD机试题，用 Java 解【DNA 序列】问题华为OD机试题，用 Java 解【矩阵最大值】问题华为OD机试题，用 Java 解【矩阵扩散】问题华为OD机试题，用 Java 解【汽水瓶】问题华为OD机试题，用 Java 解【删除字符串中出现次数最少的字符】问题华为OD机试题，用 Java 解【蛇形矩阵】问题华为OD机试题，用 Java 解【图片整理】问题华为OD机试题，用 Java 解【勾股数元组】问题华为OD机试题，用 Java 解【最小施肥机能效】问题华为OD机试题，用 Java 解【计算最大乘积】问题华为OD机试题，用 Java 解【密室逃生游戏】问题华为OD机试题，用 Java 解【喊 7 的次数重排】问题华为OD机试题，用 Java 解【计算面积】问题华为OD机试题，用 Java 解【工号不够用了】问题华为OD机试题，用 Java 解【滑动窗口最大和】问题华为OD机试题，用 Java 解【合规数组】问题华为OD机试题，用 Java 解【航天器】问题华为OD机试题，用 Java 解【比赛评分】问题华为OD机试题，用 Java 解【查找接口成功率最优时间段】问题华为OD机试题，用 Java 解【VLAN 资源池】问题华为OD机试题，用 Java 解【磁盘容量排序】问题华为OD机试题，用 Java 解【TLV 解码】问题华为OD机试题，用 Java 解【N 进制减法】问题华为OD机试题，用 Java 解【高矮个子排队】问题华为OD机试题，用 Java 解【5 键键盘的输出】问题华为OD机试题，用 Java 解【快递运输】问题华为OD机试题，用 Java 解【字符串分割】问题华为OD机试题，用 Java 解【分班】问题华为OD机试 - 考勤信息（Java） | 机试题算法思路 【2023】华为OD机试 - 按索引范围翻转文章片段（Java） | 机试题算法思路 【2023】华为OD机试 - 按身高和体重排队（Java） | 机试题算法思路 【2023】华为OD机试 - 组成最大数（Java） | 机试题算法思路 【2023】华为OD机试 - 消消乐游戏（Java） | 机试题算法思路 【2023】华为OD机试 - 非严格递增连续数字序列 | 机试题算法思路 【2023】华为OD机试 - 分糖果（Java） | 机试题算法思路 【2023】华为OD机试 - 猴子爬山 or上N阶台阶问题 | 机试题算法思路 【2023】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0851f479665df8f68cf86e0e9cec3e72/" rel="bookmark">
			Ubuntu 20.04 下 部署 SoftEther
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SoftEther 简介 SoftEther VPN 是 SoftEther VPN Project 提供的下一代 VPN 通信软件的最新版本，具有稳定性、灵活性和可扩展性。 SoftEther VPN 使用户能够使用 IP 通信网络安全地创建一个高性能的虚拟专用网络 (VPN)，其中互联网是典型的例子。 VPN 技术可以在从商业应用程序通信到面向个人和家庭使用的网络的各个领域中得到最大利用。
开源软件 SoftEther VPN 服务器、客户端和网桥是免费软件，并作为开源发布。 您可以根据 Apache License 2.0 的条款重新分发和/或修改它们。
支持多种VPN协议 SoftEther VPN Server 除了支持自己的VPN协议之外还支持很多常用的VPN协议。使用其他协议的VPN客户端可以无缝迁移到SoftEther。目前支持以下协议：
SoftEther VPN Protocol (Ethernet over HTTPS)OpenVPN (L3-mode and L2-mode)L2TP/IPsecMS-SSTP (Microsoft Secure Socket Tunneling Protocol)L2TPv3/IPsecEtherIP/IPsec 更多协议细节参考官方文档：https://www.softether.org/3-spec#VPN_Protocols_Supported_by_SoftEther_VPN_Server
支持多种操作系统 操作系统方面SoftEther支持多种操作系统：
Windows：从 Windows 98 到 Windows 11 的多个桌面和服务器版本Linux：Max OS：Mac OS X 10.4 以上版本
部分支持更多操作系统：FreeBSDNetBSDOpenBSDSolaris 而借助支持的多种VPN协议（例如L2TP）还可以支持IOS和Android等操作系统。
支持多种CPU硬件 支持多种CPU：
x86/x64ARM32/64PowerPC 32/64SPARC 32/64MIPS 32 可靠性 支持高可用性和集群负载均衡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0851f479665df8f68cf86e0e9cec3e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2ce7c575d799499661b0b69672f947/" rel="bookmark">
			QEMU启动ARM64 Linux内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言前置知识virt开发板ARM处理器家族简介 安装qemu-system-aarch64安装交叉编译工具交叉编译ARM64 Linux内核交叉编译ARM64 Busybox使用busybox制作initramfs使用QEMU启动ARM64 Linux内核 前言 本文介绍采用 qemu 模拟ARM-64bit开发板（针对ARM-32bit的有另一篇文章介绍），并启动ARM64 Linux内核。大致思路是：
安装qemu-system-aarch64（ARM-64bit）模拟器；安装aarch64-linux-gnu（ARM-64bit）交叉编译器；交叉编译linux源码，得到ARM64 Linux内核镜像；交叉编译busybox源码，使用busybox制作initramfs；最后使用qemu-system-aarch64启用ARM64 Linux内核； 我的环境：
宿主机硬件平台：x86_64宿主机操作系统：Ubuntu 20.04 （Linux 5.4.0-139-generic）QEMU版本：qemu-4.2.1实验内核：linux-5.19busybox版本：busybox-1.35.0 前置知识 virt开发板 截至书稿本文时，QEMU模拟了多大70几种的硬件开发板，可参考Arm System emulator。但ARM-64bit的QEMU模拟器非常少，以至于virt成了唯一的选择。virt支持PCI，virtio，较新的ARM CPU，大容量内存，比较遗憾的是它不支持图形界面，如果你不知道选择什么硬件开发板就选virt。
更详尽的内容可参考：
Why the “virt”board?
Installing Debian on QEMU’s 32-bit ARM “virt”board
Installing Debian on QEMU’s 64-bit ARM “virt”board
ARM处理器家族简介 ARM处理器家族众多，哪些是32bit，哪些是64bit，可参考：
List_of_ARM_processors
很多厂家使用ARM核设计SOC芯片，这里罗列了很多，可参考：
List_of_products_using_ARM_processors
安装qemu-system-aarch64 安装：
$ sudo apt install qemu-system-arm 会同时安装ARM-32bit的qemu-system-arm版本和ARM-64bit的 qemu-system-aarch64版本，查看版本号：
$ qemu-system-aarch64 --version QEMU emulator version 4.2.1 (Debian 1:4.2-3ubuntu6.24) Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers 查看 qemu 支持的 ARM 内核开发板，本文选择virt开发板：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2ce7c575d799499661b0b69672f947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a7415fbdf9b5cfa59eee3976ed6c55/" rel="bookmark">
			python--socket（套接字/插口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket是什么？ **
是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机之间的进程通信，我们网络上各种各样的服务大多都是基于socket来完成通信的，例如我们浏览网页，qq聊天、收发emil；**
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。
一、创建socket 在python中使用socket模块的函数socket就可以完成，
说明：函数socket.socket创建一个socket，该函数有两个参数，：
import socket
socket.socket(AddressFamily代表使用IPv4还是v6,Type代表使用tcp还是udp)
二、创建udp连接 #创建udp连接 s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #不用的时候关闭连接 s.close() #udp发 没有固定端口绑定 import socket def main(): #1、创建udp连接 udp_s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #可以用套接字收发数据了 #2、准备接收方的地址 #‘192.168.1.1’表示目的ip地址 #8080表示目的端口 dest_addr=('192.168.1.1',8080)#注意是元组，ip是字符串，端口是数字 #3、从键盘获取数据 send_data=input("请输入要发送的数据：") #4、发送数据到指定的电脑上的指定程序中 udp_s.sendto(send_data.encode('utf-8',dest_addr)) #或 udp_s.sendto(b"hello world",('192.168.1.1',8080)) #不用的时候关闭连接 udp_s.close() print("run") if __name__=="__main__": main() socket起源于Unix，而Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式 来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）
你想给另一台计算机发消息，你知道他的IP地址，他的机器上同时运行着qq、迅雷、word、浏览器等程序，你想给他的qq发消息，那想一下，你现在只能通过ip找到他的机器，但如果让这台机器知道把消息发给qq程序呢？答案就是通过port,一个机器上可以有0-65535个端口，你的程序想从网络上收发数据，就必须绑定一个端口，这样，远程发到这个端口上的数据，就全会转给这个程序啦
#udp接收 绑定固定端口 import socket from socket import * def main(): #1、创建udp套接字 udp_s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #2、绑定本地相关信息，如果一个网络程序不绑定，则系统会随机分配 locale_addr=('',7788)#ip地址和端口号，ip一般不用写，表示本机的任何一个ip(注意是空不是空格) udp_s.bind(locale_addr)#必须只能绑定自己的信息，其他的不行 #3、等待接收对方发送的数据 recv_data=udp_s.recvfrom(1024)#1024表示本次接收的最大字节数 #4、显示接收到的数据 print(recv_data[0].decode('gbk'))#encode编码utf-8，decode解码gbk #5、关闭套接字 udp_s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a7415fbdf9b5cfa59eee3976ed6c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fe318dfa80c4a4a68801a3ad845ba2/" rel="bookmark">
			Leetcode第415题，数组越界问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组越界了，就检查下数组的所赋的值对不对
一直找不到，怀疑人生，对着题解写的代码怎么会错了，一直报
Line 1065: Char 9: runtime error: addition of unsigned offset to 0x7fff6bfcbd40 overflowed to 0x7fff6bfcbd3f (basic_string.h)SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9
后来，终于发现两个数组num1[i],num2[j]都写成了i。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4b1ebec9d017363c3caa6fb4dababe/" rel="bookmark">
			Vue3.0项目搭建指南 不使用cli脚手架（v2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3.0项目搭建指南 前言一、先让Vue3能够运行1.初始化2.安装相关依赖3.编写项目文件和配置webpack4.运行项目 二、完善开发环境1.安装html-webpack-plugin2.安装webpack-dev-server3.配置开发环境4.启动项目 三、安装各种工具1.使用less和less的解析器2.使用Typescript 前言 本指南作用于帮助开发人员更清晰的了解Vue3.0的常用框架及其生态之间的关系，以及在不借助cli脚手架的情况下一步步将项目组装起来。
提示：文章篇幅较长，建议收藏观看
文中所使用所有相关依赖如下
环境以及工具
nodeJS v.14.16.0 - 基于 Chrome V8 引擎的 JavaScript 运行环境
npm v6.14.11 - nodeJS的包管理工具
编译依赖
webpack v5.51.1 - 模块打包器
webpack-cli v4.8.0 - webpack的依赖
插件
html-webpack-plugin v5.3.2 - 简化Html的插件
项目依赖
vue v3.2.6 - 这个不用我多说了把
vue-loader v16.5.0 - vue3.0解析器
@vue/compiler-sfc v3.2.6 - vue-template-compiler的升级版
css-loader v6.2.0 - css解析器
style-loader v3.2.1 - css-loader的依赖
webpack-dev-server v4.1.0 - 基本的 web server
各种工具的依赖
less v4.1.1 - less css预处理语言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4b1ebec9d017363c3caa6fb4dababe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3622f7e50ec57cbfc8b2f2c9093297fe/" rel="bookmark">
			mybatis源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、什么是mybatis2、mybatis项目搭建3、源码分析①SqlSessionFactoty的构建②SqlSession的获取③动态代理获取Mapper对象④通过Mapper的执行过程 1、什么是mybatis Mybatis是一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。MyBatis内部封装了 JDBC，简化了加载驱动、创建连接、创建 statement 等繁杂的过程，开发者只需要关注 SQL 语句本身。
2、mybatis项目搭建 项目的搭建我们可以参照官方文档,该项目基于mybatis-3.5.10，不加入Spring整合。参考文档，我们只需要创建mybatis核心配置文件mybatis-config.xml，mapper.xml以及对应的mapper接口。
1、mybatis-config.xml (使用外部属性文件配置数据源)
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 引入数据连接参数属性文件 --&gt; &lt;!-- &lt;properties resource="mysqldb.properties"/&gt; --&gt; &lt;properties resource="oracledb.properties"/&gt; &lt;!--设置日志--&gt; &lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;/settings&gt; &lt;!--类型别名:用于写sql文件中入参类型和返回类型的指定 --&gt; &lt;typeAliases&gt; &lt;package name="com.cssl.pojo"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!--配置数据源，创建Connection连接对象--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--driver:驱动的内容--&gt; &lt;property name="driver" value="${driver}"/&gt; &lt;!--url:连接数据库的url--&gt; &lt;property name="url" value="${url}"/&gt; &lt;!--用户名--&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3622f7e50ec57cbfc8b2f2c9093297fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f4dd37927c248a7ee216e58109090f/" rel="bookmark">
			AES加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.AES简介 AES属于分组加密算法，，每组长度相等，每次加密一组数据，直到加密完整个明文，明文长度固定为128位，密钥长度可以是128（10轮循环）、192（12轮循环）、256位（14轮循环）。
明文P需要分组，称为状态，状态用以字节为元素的矩阵阵列表示，16字节明文按照此顺序放入矩阵，规则为：从上到下，从左到右，依次进行。密钥K也需要分组，原理与明文P相同。
（1）明文P：没有经过加密的数据。
（2）密钥K：用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。
（3）AES加密函数：设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。把明文P和密钥K作为加密函数的参数输入，加密函数E会输出密文C。
（4）密文C：经加密函数处理后的数据
（5）AES解密函数：设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。
二.加密过程 前9轮循环4个步骤，最终轮进行1、2、4步
初始变换--明文和子密钥进行异或
字节代换--查表进行数的代换
行移位
三.解密过程 AES加密过程涉及到4种操作，分别是字节代换、行移位、列混淆和轮密钥加。解密过程分别为对应的逆操作。每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。
3.1字节代换
AES的字节代换需要查表，通过S盒实现一个字节到另一个字节的映射，逆字节代换通过查逆S盒。
3.2行移位
行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如：AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。
3.3列混淆
逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。
3.4轮密钥加
密钥加是将轮密钥简单地与状态进行逐比特异或。这个操作相对简单，其依据的原理是“任何数和自身的异或结果为0”。加密过程中，每轮的输入与轮子密钥异或一次；因此，解密时再异或上该轮的轮子密钥即可恢复。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。
AES加密算法实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03638fe78bc57704b767fe47527b6f6/" rel="bookmark">
			JavaEE中的interface，匿名内部类、泛型、异常【第三篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口，匿名内部类，泛型，异常 学习目标学习内容学习产出一、interface接口二、多态三、匿名内部类【重点】四、泛型4.1 增强单个方法4.2 增强多个方法 五、异常 学习目标 学会里面的全部内容，特别是在泛型中需要非常特别特别注意。
ArrayList源码是需要会的，可以在理解的基础上，自己实现一个MyArrayList实现类，并且可以实现ArrayList中的大部分的方法
并且匿名内部类是非常的重要，匿名内部类虽然没有lambda好用，但是在公司的项目中匿名内部类的使用也是非常常见的！！！
学习内容 interface，泛型，异常，ArrayList 底层源码编写，匿名内部类！！！
学习产出 一、interface接口 interface接口定义方式：
inteeface 接口名 { 成员变量;//缺省属性为 public static final 成员方法;//缺省属性为 public abstract 默认方法;//JDK1.8 以上支持，default关键字修饰的默认方法，允许有方法体。 } 实现类遵循接口的方式：
class 实现类类名 implemenets 接口名 { //方法里面必须重写接口中所有的缺省属性为【public abstract】成员方法 } 接口的特点：
接口可以多继承其他接口一个类可以遵从多个接口 二、多态 编译看左，运行看右
父类的引用数据类型变量，指向子类或者间接子类的对象
接口的引用数据类型变量，指向遵从接口的实现类对象。
利用多态：
拓宽了方法的数据类型支持范围，但是又满足数据类型一致化，同时支持数据类型多样化
拓宽方法返回值类型，可以支持类型统一。
下面进行代码测试：
public class Demo13 { public static void main(String[] args) { Son son = new Son(); //子类中没有test方法但是子类继承了父类，所有可以直接调用父类的test方法 son.test(); Father father = new Son(); //多态的思想，编译看左，运行看右，但是子类中没有test方法，所以调用流程如上 father.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d03638fe78bc57704b767fe47527b6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f5afe8ec9d09818e63fb722627a685/" rel="bookmark">
			HTML5是什么？怎么学习HTML5？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML5 是什么？
HTML5是什么？相信这个问题并不容易回答，大多数人对于HTML5的概念仅仅是听说过而已，非要让他说出个所以然来，结果只能让你失望。相比普及了近十四年的HTML4来说，HTML5带来的震撼其实丝毫不亚于当年的双核VS单核。那么对于我们普通人来说，HTML5到底意味着什么？今天就让笔者现身说法地讲一讲吧。
举个例子吧，比方说一个网页摆在你的面前，那么HTML就是一个骨架，而上面的文字、图片、视频、音频则作为附属在这个骨架上的皮肉，来给我们带来丰富的视听体验。如果没有这些皮肉，那么网页显然就是一句空谈，但如果没有HTML，我们也就不知道该如何将这些多媒体信息组合到一起。
1999年，HTML 4.01正式为W3C（万维网联盟）所推荐，于是这款全新的WEB标准开始了它长达十数年的互联网统治时代。随着带宽发展及电脑性能的提升，音频和视频开始被越来越多地用户推崇，而这两种资源恰恰是HTML 4.01所无法解释的。于是当时便有一家公司独辟蹊径，推出一款专门用于解释和播放影音文件的WEB标准，而这就是现在家喻户晓的Flash。
虽然Flash对于当时的WEB产业有着不可磨灭的贡献，但随着该技术在全球应用，一些弊端也开始明显地显露出现，比如安全性不高、资源消耗过大等等，最关键的是它很难适应日渐普及的移动WEB，程序员往往需要同时为PC版用户和移动版用户编写两套网站页面。
也就是在这个大背景下，HTML5风声水起，和之前的HTML4相比，新版本最大的亮点便是增加了&lt;video&gt;和&lt;audio&gt;两个标签，使得浏览器能够在不装任何插件的情况下直接播放影音资源。而且它还有很多更新的体验，比如直接在浏览器上绘制矢量图形、内嵌本地SQL数据库使交互加速、提供API实现从桌面拖拽文件到浏览器执行上传、自动获取用户地理信息、允许用户在离线状态下使用GMail，以及更利于搜索引擎索引整理的网站导航块等等。
HTML5该怎么学？
关于HTML5的优势特性不需要多说，现在发展趋势下，HTML5前端人才已经成为抢手人才，学好HTML5成就高薪职位并不是梦，那么HTML5该怎么学，学习要讲究循序渐进，先把基础打牢，然后进阶与项目相结合，积累经验，通过权威的书籍和课程学习，自然可以得到最大收获，小编把HTML5学习大体分为四个流程：
第一阶段 HTML5基础了解（ HTML5+CSS3 基础）
第二阶段 HTML5核心元素
第三阶段 综合开发与应用
第四阶段 项目实训
HTML5前端制作制作基础是奠定后续开发的重要条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46774b927ee472d7b02585b5dfbb5c25/" rel="bookmark">
			5个可以在Golang中优化代码以提高性能的技巧分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名软件工程师，确保你的代码高效且性能良好是非常重要的。本文主要和大家分享5个可以在Golang中优化代码以提高性能的技巧，希望对大家有所帮助
作为一名软件工程师，确保你的代码高效且性能良好是非常重要的。在Golang中，有几个最佳实践和技术可以用来优化你的代码，以获得更好的性能。这里有五个技巧可以帮助你开始工作：
1.明智地使用指针。Golang使用指针来引用内存位置。虽然指针在某些情况下很有用，但如果过度或不正确地使用，它们也会导致性能下降。例如，使用指针向函数传递大的结构或 slice 会导致不必要的内存分配和复制。相反，可以考虑通过值传递这些类型。
1
2
3
4
5
6
7
8
9
// Bad: Passing a large slice by pointer
funcslowFunction(s *[]int) {
// do something with s
}
// Good: Passing a large slice by value
funcfastFunction(s []int) {
// do something with s
}
2.避免不必要的分配。分配内存是一个昂贵的操作，特别是在高并发环境下。为了提高性能，尽量减少你的代码的分配次数。做到这一点的一个方法是重复使用切片和其他引用类型，而不是创建新的引用类型。
1
2
3
4
5
6
7
8
9
10
11
// Bad: Allocating a new slice for each iteration
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46774b927ee472d7b02585b5dfbb5c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4382c5aade3e68544b06907271c64c8/" rel="bookmark">
			【官方】BootCDN-稳定、快速、免费的前端开源项目 CDN 加速服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 BootCDN
BootCDN 是 极兔云 联合 Bootstrap 中文网 共同支持并维护的前端开源项目免费 CDN 服务，致力于为 Bootstrap、jQuery、React、Vue.js 一样优秀的前端开源项目提供稳定、快速的免费 CDN 加速服务。BootCDN 所收录的开源项目主要同步于 cdnjs 开源项目仓库。
自2013年上线以来已经累计为近百万网站提供了稳定、可靠的免费 CDN 加速服务。
我们用到的技术
关于 BootCDN
BootCDN 是 极兔云 联合 Bootstrap 中文网 共同支持并维护的前端开源项目免费 CDN 服务，致力于为 Bootstrap、jQuery、React、Vue.js 一样优秀的前端开源项目提供稳定、快速的免费 CDN 加速服务。BootCDN 所收录的开源项目主要同步于 cdnjs 开源项目仓库。
自2013年上线以来已经累计为近百万网站提供了稳定、可靠的免费 CDN 加速服务。
我们用到的技术
Bootstrap TailwindCSS React.js Vue.js Svelte.js jQuery Babel.js Lodash Node.js Grunt Gulp npm pnpm Yarn webpack Rollup.js Parcel PostCSS Next.js Nuxt.js Docusaurus Gatsby.js Gridsome VuePress SASS Less.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4382c5aade3e68544b06907271c64c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d6bc48844c083c476651436979dcfe/" rel="bookmark">
			Cloudreve CR&#43;安卓客户端 V1.0.9.8源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cloudreve CR+安卓客户端 V1.0.9.8源码 下载链接： CR+ V1.0.9.8.zip 搭建教程：CR+商业版搭建教程.zip
我忘记这个教程版本是几点几的了，但是安装步骤一般都是大同小异的
需要修改的地方为CR+ 1.0.9.8升级版源码\清玖云盘\res\config\appinit.lua
// 修改引号内的文字或链接以及群号 _M.appname = "清玖云盘" -- 云盘名称 _M.domainUrl = "https://kuocaitm.net" -- 网盘域名 _M.updateUrl = "http://kuocaitm.net" -- 更新链接 _M.groupCode = XXXXX -- 点击加群的群号 ...... _M.path = {} _M.path.sdcard = Environment.getExternalStorageDirectory().getAbsolutePath() _M.path.download = _M.path.sdcard.. "/Qingcloud/download/" -- 下载路径 注意，本版本并不适用于现在新版本的cloudreve，请自行修改api适配最新版的cloudreve
我没找到这个版本的截图，不过这个版本肯定很好看，各位放心搭建吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa13902f87c6edfd2c564974b0afeb0/" rel="bookmark">
			mysql8密码修改报错，完美解决：mysql8修改密码验证策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#设置密码强弱等级 set global validate_password.policy=0; #设置密码长度 set global validate_password.length=4; #设置密码检查开关 set global validate_password.check_user_name=OFF; #设置密码包含数字个数 set global validate_password.number_count=0; #设置密码特殊字符个数 set global validate_password.special_char_count=0; #刷新特权 flush privileges; 因为mysql8的密码验证策略和以往的5.7不一样，所以设置密码太简单的话是不会让你通过的，执行以上sql后重新修改密码完美解决。
使用node连接mysql8报错问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c64219112d4efeb6d82235db8a7099/" rel="bookmark">
			2023荣耀校招机试（java&amp;python&amp;C&#43;&#43;）组装新的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个整数M和数组N，N中的元素为连续整数，要求根据N中的元素组装成新的数组R，组装规则：
R中元素总和加起来等于MR中的元素可以从N中重复选取R中的元素最多只能有1个不在N中，且比N中的数字都要小（不能为负数） 备注： 1 ≤ M ≤ 30
1 ≤ N.length ≤ 1000
输入描述 第一行输入是连续数组N，采用空格分隔
第二行输入数字M
输出描述 输出的是组装办法数量，int类型
用例1 输入
2
5
输出
1
说明
只有1种组装办法，就是[2,2,1]
用例2 输入
2 3
5
输出
2
说明
一共两种组装办法，分别是[2,2,1]，[2,3]
C++ #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; // 定义一个函数，接收一个整数数组和一个目标值m，返回数组中所有小于等于m的元素组合成m的方法数 int getResult(vector&lt;int&gt;&amp; arr, int m) { // 创建一个新的数组，存储原数组中小于等于m的元素 vector&lt;int&gt; newArr; for (int val : arr) { if (val &lt;= m) { newArr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c64219112d4efeb6d82235db8a7099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9273ee1e32e54534610308302bbce9f/" rel="bookmark">
			D. Counting Factorizations #856 div2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem - 1794D - Codeforces
题意：
一个数分解质因数会变成这样的形式：
把所有的pi和ei放入一个可重集，给你一个可重集，问你原始的数有多少种可能
分析：
性质：底数只能是质数。底数只能有一个，指数可以有很多个
考虑dp
令为选了前i个数， 选了底数的个数为j的方案数
因为输入的为2*n，所以有n个为指数，n个为底数
对于当前枚举到的x来说，假设有y个
x分为两种情况：
第一种是只做指数，已经选了j个底数，假设一共操作了sum个数，所以有sum-j为指数，在剩下的没有操作过的位置上选择y个
第二种是x做一次底数的情况，其他y-1的情况全部作为指数
分步用乘，分类用加
所以这一步由上一步转移而来，用乘
两种不同的情况用加
这里介绍一个小tip
因为这个是二维的，所以必然要用到双重循环，看一下数据范围，二维的会超时，所以还需要优化一下。使用滚动数据，达到降维的效果。开一个类似于临时数组，相当于是这一步算好的情况，然后移到转移的数组上面，（相当于用这个临时数组作为中间数组），达到转移的效果。
这里我看到一篇博客很赞，贴个链接
C++ vector容器的swap方法（容器互换）_vector.swap_对的时间点的博客-CSDN博客
下面贴个这个题的代码：（整个题和代码的思路是看cup大佬qwq）
#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,"Ofast","inline") #define IOS ios::sync_with_stdio(false), cin.tie(0); #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long typedef long long ll; typedef pair&lt;int,int&gt; PAII; const int N=2e6+10,M=5050,INF=1e18,mod=998244353; int fact[N],infact[N]; bool st[N]; int primes[N]; map&lt;int,int&gt; mp; int cnt; vector&lt;int&gt; dp(N+10,0); int qmi(int a, int k) { int res = 1; while (k) { if (k &amp; 1) res = res * a%mod ; a = a * a%mod ; k &gt;&gt;= 1; } return res; } void init(){ st[1]=1; for (int i = 2; i &lt;= N; i ++ ) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9273ee1e32e54534610308302bbce9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00c6f03982745c16ca11c54459c2650/" rel="bookmark">
			C&#43;&#43; 哈希表基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表 哈希表是一种很常见的数据结构，我现在平时刷算法题一般使用C++刷（不要问我为什么，懂的都懂）。C++关于哈希表有很多数据结构，平时使用的比较多的有unordered_set 跟 unordered_map。其中unordered_map 存储的是键值对。
其实我们在某些情况下可以使用数组构建哈希表（具体是哪些情况的呢，自行搜索）。但是数组的大小是受限制的，而且如果元素很少却哈希值很大的话会造成内存空间的浪费（至于为什么会这样请自行搜索）。
为什么要用哈希表 如果现在做哈希表的题目，是因为按专题刷的哈希表的题目，所以会直接用哈希表。但是遇到一道新的题目，没有标签，怎么想到使用哈希表呢？
咱们要清楚一点的就是，一般哈希表都是用来快速判断一个元素是否出现在集合里。
遍历 for (auto i = hash.begin(); i != hash.end(); i++)
如果是unordered_map，遍历的时候，可以访键值i -&gt;first或者是i-&gt;second;
查找 查找某个元素是否在哈希表中，可以使用hash.find(x) != hash.end(),或者hash.count(x) &gt; 0
注意：hash.count(x) 的数值只有 0 和 1。所以不能通过hash.count(x)来表示x在hash 中出现的次数。
插入 在unordered_set 中插入元素，可以用hash.insert(key)。
在unordered_map中插入元素，可以使用hash[key] = value。
删除 在unordered_set 跟unordered_map 中删除元素，都用hash.erase(key)。
注意，在unordered_map 中，即使hash[key] == 0，如果之前已经将key存入到hash中，然后通过hash[key] -- 使得hash[key] == 0，hash 中还会存在key ，也就是说此时hash.count(key) == 1。
在个别场景下，可能需要一次性删除 unordered_map 容器中存储的所有键值对，可以使用clear()方法，其语法格式如下：
void clear()
{
hash.clear();
}
我觉的刷题会这些基本的操作足够了，想深层次的了解哈希表的话自行查阅资料吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e727788d19408818b2feb4cda7a46fc0/" rel="bookmark">
			只允许input框中输入三位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：input框中只能输入小数点后三位
使用@input="valueChange"事件将输入的其他所有字符替换成’’只保留一个小数点. valueChange(value) { let filterValue = value.toString(); filterValue = filterValue.substr(0, 10); // 最多10位 filterValue = filterValue.replace(/^\./g, ""); // 不能以“.”开头 filterValue = filterValue.replace(/[^\d.]/g, ""); //清除“数字”和“.”以外的字符 filterValue = filterValue.replace(/\.{2,}/g, "."); //只保留第一个. 清除多余的 filterValue = filterValue.replace(".", "$#$").replace(/\./g, "").replace("$#$", "."); filterValue = filterValue.replace(/^(\-)*(\d+)\.(\d\d\d).*$/, '$1$2.$3');//只能输入3个小数 if (filterValue.indexOf(".") &lt; 0 &amp;&amp; filterValue != "") {//以上已经过滤，此处控制的是如果没有小数点，首位不能为类似于 01、02的金额 filterValue = filterValue.substr(0, 10) filterValue = parseFloat(filterValue); } this.form.valuen = filterValue; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e36d3f75bed103ca8e05feb58f50b7/" rel="bookmark">
			crbug/1173575, non-JS module files deprecated.问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当我在启动项目后，再次刷新网页之后，突然出现下面这种问题，但是再次从vscode编辑器点进去之后，就可以正常访问，但网页刷新又会出现下面这种问题。 解决办法：
我调试的时候把在线状态设置成了offline，把offline调成No throttling模式，之后问题解决！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/168/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>