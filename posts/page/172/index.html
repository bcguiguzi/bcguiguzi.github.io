<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271e106d07a304eb2cde6678048e9da3/" rel="bookmark">
			Pytorch学习记录（6）池化层的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch学习记录（6）池化层的使用 1.池化层的定义以及池化层的原理： 池化操作(Pooling)是CNN中非常常见的一种操作，Pooling层是模仿人的视觉系统对数据进行降维，池化操作通常也叫做子采样(Subsampling)或降采样(Downsampling)，在构建卷积神经网络时，往往会用在卷积层之后，通过池化来降低卷积层输出的特征维度，有效减少网络参数的同时还可以防止过拟合现象。
主要功能有以下几点：
抑制噪声，降低信息冗余。
提升模型的尺度不变性、旋转不变形。
降低模型计算量。
防止过拟合。
其中常用的池化操作，有maxpool与avgpool，还有随机池化、全局平均池化等其他非常多的池化操作，具体详见卷积神经网络中的各种池化操作 - pprp - 博客园 (cnblogs.com)。
本文以maxpool与avgpool为例子进行着重介绍：
2.最大池化的实现： 以最大池化操作处理二维照片为例，数据集仍选择CIFAR10，代码如下：
import torch.nn as nn import torch import torchvision from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter from torchvision import transforms # 创建的单层最大池化层类 # Pytorch中模型的三要素 1.nn.Module class MyPool(nn.Module): # Pytorch中模型的三要素 2.__init__() def __init__(self): super(MyPool, self).__init__() self.maxpool1 = torch.nn.MaxPool2d(kernel_size=3, stride=1, padding=0) # Pytorch中模型的三要素 3. forward() def forward(self, x): x = self.maxpool1(x) return x # 将数据集图像从PIL格式转化为Tensor格式 tran_tensor = transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271e106d07a304eb2cde6678048e9da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71894ed3ec97d2aa5d06f87c30341e4d/" rel="bookmark">
			操作VMware vCenter Converter 实现物理机迁移到虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的：熟练VMware虚拟化项目中，物理机向ESXI5迁移操作过程。
1、打开VMwarevCenterConverterStandalone5.0软件，按“转换计算机”。
2、选择“已打开电源的计算机”。并输入远程要连接迁移物理机IP地址，登录帐户和密码。 然后“下一步”。
3、选择“成功导入后自动制裁这些文件”，然后按“是”。 4、向要迁移的物理机，安装代理。
5、输入ESXI5?主机的IP地址，登录帐户和密码。然后“下一步”。 6、系统自动识别出要迁移物理机，计算机名叫“PC”，选择“下一步”。 7、选择ESXI5上存储。确认后“下一步”。
8、选择迁移时参数。例如：选择要复制的数据，选择要迁移的分区，实验中选择C盘。确认后，选择“下一步”。
9、查看信息确认后，选择“完成”。
10、迁移开始前，大家先看下ESXI5上是没有安装任何虚拟机。
11、当VMwarevCenterConverterStandalone5.0迁移向导，按“完成”后，就正式开始迁移工作。
12、迁移成功完成。可以查看迁移时日志，查看迁移开始和结束时间等信息。
13、windowsserver2003r2迁移成功后在ESXI5上可以正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b356d7817b088d1eeea36062f4cdb192/" rel="bookmark">
			技术解码 | GB28181/SIP/SDP 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 GB28181协议是视频监控领域的国家标准，本文将解析如何在FFmpeg中增加对GB28181协议的支持，使其可以与支持GB28181协议的设备进行通信与控制，实现设备的注册、保活以及流媒体的传输。
1.背景介绍 GB28181协议指的是国家标准GB/T 28181—2016《公共安全视频监控联网系统信息传输、交换、控制技术要求》。
该标准规定了公共安全视频监控联网系统的互联结构， 传输、交换、控制的基本要求和安全性要求， 以及控制、传输流程和协议接口等技术要求，是视频监控领域的国家标准。GB28181协议信令层面使用的是SIP（Session Initiation Protocol）协议。
流媒体传输层面使用的是实时传输协议（Real-time Transport Protocol，RTP）协议。
因此可以理解为GB28181是在国际通用标准的基础之上进行了私有化定制以满足视频监控联网系统互联传输的标准化需求。本文旨在说明在FFmpeg中增加对GB28181协议的支持，使其可以与支持GB28181协议的设备进行通信与控制，实现设备的注册、保活以及流媒体的传输。
2.国标GB28181协议：信令流程 2.1 国标GB28181协议 GB28181协议会话通道实际上使用的是SIP协议，并且在SIP协议的基础之上做了些私有化处理。SIP是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。
SIP中一个比较重要的概念是用户代理（User Agent），指的是一个SIP逻辑网络端点，用于创建、发送、接收SIP消息并管理一个SIP会话。
SIP用户代理又可分为用户代理客户端UAC（User Agent Client）和用户代理服务端UAS（User Agent Server）。UAC创建并发送SIP请求，UAS接收处理SIP请求，发送SIP响应。
SIP协议会与许多其它的协议协同工作，如SIP报文内容发送会话描述协议（Session Description Protocol，SDP）,SDP协议描述了会话所使用流媒体细节，如：使用哪个IP端口，采用哪种编解码器等等。
SIP的一个典型用途是：SIP会话传输一些简单的经过报文的实时传输协议流，RTP本身才是语音或视频的载体。在GB28181协议中，联网系统在进行视音频传输及控制时应建立两个传输通道: 会话通道和媒体流通道。会话通道用于在设备之间建立会话并传输系统控制命令; 媒体流通道用于传输视音频数据， 经过压缩编码的视音频流采用流媒体协议RTP/RTCP传输。GB28181协议中具体通信协议结构图如下图（通信协议结构图）所示：
详细可参考国标GB28181需求文档：链接: https://pan.baidu.com/s/1aqlF6mQPNUE4KMIUf3JU8A?pwd=jb6v 提取码: jb6v
会话通道中，注册、实时视音频点播、历史视音频的回放等应用的会话控制采用SIP协议IETF RFC3261中规定的REGISTER、INVITE等请求和响应方法实现， 历史视音频回放控制采用SIP扩展协议IETF RFC29765规定的INFO方法实现，前端设备控制、信息查询、报警事件通知和分发等应用的会话控制采用SIP扩展协议IETF RFC34287规定的MESSAGE方法实现。下面详细介绍下注册、保活和实时视音频点播的SIP消息结构。
2.2 国标28181：注册 注册指的是设备或系统进入联网系统时向SIP服务器（SIP UAS）进行注册登记的工作模式，在本文中FFmpeg即为一个SIP服务器，设备向FFmpeg发送注册请求，FFmpeg在接收到设备的注册请求后返回相应的回复消息，则完成设备注册流程。GB28181协议中基于数字摘要的挑战应答式安全技术进行注册流程如下图（ 基本注册流程示意图）所示：
详情可参考国网技术要求文档：【附录B.1注册】链接: https://pan.baidu.com/s/1_bn-K2CML_OPxQRO4VDdhQ?pwd=6sb9 提取码: 6sb9
其他优秀文章的GB28181的实现，可以查阅主页文章：
1.GB28181流媒体系列文章
2.第一章 向上级平台注册系列文章
3.sip (gb28181)信令交互-视频点播与回播
注册流程描述如下:
SIP代理向SIP服务器发送Register请求;
SIP服务器向SIP代理发送响应401，并在响应的消息头WWW_Authenticate字段中给出适合SIP代理的认证体制和参数;
SIP代理重新向SIP服务器发送REGISTER请求， 在请求的Authorization字段给出信任书，包含认证信息;
SIP服务器对请求进行验证，如果检查出SIP代理身份合法，向SIP代理发送成功响应200OK，如果身份不合法则发送拒绝服务应答。
注册的请求消息内容范例如下：
REGISTER sip:34020000002000000001@3402000000 SIP/2.0 Via: SIP/2.0/UDP 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b356d7817b088d1eeea36062f4cdb192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f839e20593f46e2339af3ea1e2c61726/" rel="bookmark">
			DockerFile创建及案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile dockerfile是用来构建docker镜像的文件，命令脚本参数脚本！
构建步骤
编写一个dockerfile文件docker build 构建成为一个对象docker run 运行镜像docker push 发布镜像（DockerHub、阿里云镜像仓库） 去官网Docker-Hub查找一个镜像，选择版本会跳转到github获取一个具体的dockerfile，以centos:7为例
很多官方镜像是基础版
Docker Hub中99%镜像都是从这个基础镜像过来的FROM scratch，然后配置需要的软件和配置来进行构建
FROM scratch ADD centos-7-x86_64-docker.tar.xz / LABEL \ org.label-schema.schema-version="1.0" \ org.label-schema.name="CentOS Base Image" \ org.label-schema.vendor="CentOS" \ org.label-schema.license="GPLv2" \ org.label-schema.build-date="20201113" \ org.opencontainers.image.title="CentOS Base Image" \ org.opencontainers.image.vendor="CentOS" \ org.opencontainers.image.licenses="GPL-2.0-only" \ org.opencontainers.image.created="2020-11-13 00:00:00+00:00" CMD ["/bin/bash"] DockerFile的构建过程 基础知识
每个保留关键字（指令）都必须是大写字母执行从上到下顺序执行# 表示注释每个指令都会创建一个新的镜像层，并提交！ DockerFile是面向开发的，发布项目做镜像，编写dockerfile
DockerFile：构建文件，定义了一切步骤，源代码
DockerImages：通过DockerFile构建生成镜像，最终发布和运行镜像。
Docker容器：容器是镜像运行起来提供容器
DockerFile指令 DockerFile命令文档
FROM # 基础镜像，指定基本（父）图像。 MAINTATNER # 镜像作者，用户名+邮箱，现在一般使用LABLE LABEL # 提供元数据，包括维护者信息。 ENV # 设置持久性环境变量。 RUN # 运行命令并创建图像层，用于将软件包安装到容器中，docker build时运行。 COPY # 将文件和目录复制到容器。 ADD # 将文件和目录复制到容器，可以支持本地.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f839e20593f46e2339af3ea1e2c61726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66c85fbeb8f57f665c8c8b9771bf750/" rel="bookmark">
			There‘s no Qt version assigned to project xxx.vcxproj for configuration Debug/x64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt系列文章目录 文章目录 Qt系列文章目录前言一、 分析错误原因二、解决步骤1.选择Qt版本2.检查环境变量3.重新构建工程 There’s no Qt version assigned to project xxx.vcxproj for configuration Debug/x64 前言 如果你想了解关于Qt与VS2019开发环境搭建，可以至此翻页。
这里主要分享环境已搭建成功，在构建项目时遇到的报错解决方案。
当我们使用qtCreator创建的工程，使用visual studio打开的时候就可能报这种错误：error:There’ no Qt version assigned to project .vcxproj for configuration release/x64.Please assign a Qt installation in “Qt Project Settings”.
一、 分析错误原因 一般是直接将工程复制到另一台电脑上所导致，系统可能默认不选择使用的qt版本。
机器上装有Qt5.12.9和Qt5.12.2，以及Qt5.7，因为不同的工程使用的Qt不一样，所以工程中Qt版本没有匹配，我里工程使用Qt5.12
二、解决步骤 1.选择Qt版本 这里首先确保机器上已经安装插件：Qt visual studio tool version2.10.1（版本根据你的vs版本会不一样）
工程属性-&gt;选择后会弹出如下窗体，选择编译机器版本msvc2019 64即可（如果是单纯的qt项目，可以直接选择出现的自己qt版本）
2.检查环境变量 步骤一：检查环境变量
首先，保证Qt安装的路径已添加进环境变量。我这里配置了Qt5,7，同时也配置了Qt5.12.9读者可根据自己安装的Qt版本选择配置
3.重新构建工程 步骤三：再启动构建
构建成功（若不成功，重复检查如上三步。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974f737588f759a0c931b2bc02f20edd/" rel="bookmark">
			vue项目中关于克隆对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象中的属性已经与其他的一些图标绑定，但是发送请求的时候。又对这个对象里的某些属性的属性值的数据格式有要求，此时可以对这个对象进行克隆
直接让两个对象相等不可以么？？？很明显不可以，要不我还记录这玩意儿干啥啊
例如
const test1 = {"a":1,"b":2} const test2 = test1 test2.b = 100 console.log(test1.b) //结果为100 从而我们可以得知，这种直接相当的会触发对象的引用机制，我看也有把这种复制方法称为浅拷贝
那如何解决这个情况呢？
在vue中可以利用lodash，在终端直接下载lodash，然后
import _ from "lodash" 我们使用cloneDeep(object)方法
import _ from "lodash" //先下载lodash并引入lodash const test1 = {"a":1,"b":2} const test2 = _.cloneDeep(test1) test2.b = 100 console.log(test1.b) //输出结果为2 进行深拷贝以后，两个对象之间就不会再有关联了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c64293f16d3c28df5da8c06d744f8a/" rel="bookmark">
			CS143：编译原理实验PA1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PA1报告：Stack Machine 实验内容 基于cool语言实现一个可执行若干指令的stack machine，要求实现的栈机可以满足以下命令：
CommandMeaningint将该整数压入栈s将字符s压入栈e根据栈顶元素执行相关命令，具体见下d打印当前栈中元素（from top to bottom）x该stack machine正常退出 对于"e"指令的执行，目前分为以下三种情况：
当栈顶元素为"s"时，将"s"弹出，并将下面的两个元素进行交换当栈顶元素为"+“时，将”+"弹出，并将下面两个元素弹出求和后将和放回栈中当栈顶元素为int或栈顶元素为空时，不做任何处理 实验步骤 实验环境配置
安装必要的包：
apt-get install flex bison build-essential csh libxaw7-dev lib32stdc++6下载课程所需根文件夹(student-dist)并移动到虚拟机中将/bin目录添加到环境变量：
export PATH=/home/user/workspace/bin:$PATH。
注意这里仅仅是再当前打开的终端添加环境变量，该终端结束后，环境变量失效，在这里我们修改/etc/environment,将…/bin目录放入其中，即可永久生效1 实验理论准备
阅读cool-manual2，掌握cool的基本语法阅读部分源码，熟悉代码如何书写，这里主要看了/examples下的
atoi.cl, book_list.cl, graph.cl list.cl梳理栈结构与所需要的实现的功能：
判空，长度，出栈，入栈，遍历等等 代码设计与实现
采用面向对象方式进行代码设计，涉及到的类的结构图如下：
代码总的设计思路是，终端读入字符到StackMachine，然后StackMachine根据字符产生相应种类的StackCommand，StackMachine再执行这些相关的指令并维护自身所持有的栈。下面我们按照书写顺序来分析各个Class的代码。流程图见下：
StackCommand：这里注释给出了该类的features含义。该类是让StackMachine执行的命令的载体，方便后续进行命令的扩展。
class StackCommand { (* cName: The name or string of command. cType: It is designed to classify different command, but now we just need use "case". getName(): To get cName. getType(): To get cType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c64293f16d3c28df5da8c06d744f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e857457d3e22ad5b68ccbe46fabcecd/" rel="bookmark">
			通过VS2022编译器，使用C&#43;&#43;连接MySQL时，出现找不到libmysql.dll的解决办法（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过VS2022编译器，使用C++连接MySQL时，出现找不到libmysql.dll的解决办法（亲测有效） 给大家展示一下project的属性页调试VC++目录C/C++连接器-&gt;常规链接器-&gt;输入 后记 给大家展示一下project的属性页 大家可以自行寻找错误在哪里
调试 环境
PATH=C:\Program Files\MySQL\MySQL Server 8.0\bin
这里的路径是MySQL的安装路径
VC++目录 包含目录
( V C I n c l u d e P a t h ) ; (VC_IncludePath); (VCI​ncludePath);(WindowsSDK_IncludePath);C:\Program Files\MySQL\MySQL Server 8.0\include
库目录
( V C L i b r a r y P a t h x 64 ) ; (VC_LibraryPath_x64); (VCL​ibraryPathx​64);(WindowsSDK_LibraryPath_x64)
C/C++ 附加包含目录
C:\Program Files\MySQL\MySQL Server 8.0\include
连接器-&gt;常规 附加库目录
C:\Program Files\MySQL\MySQL Server 8.0\lib
输出文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e857457d3e22ad5b68ccbe46fabcecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c09c51472e8f1d68bcd8784d3822bc/" rel="bookmark">
			Visual Studio连接Linux服务器编译CMake项目，生成在Linux上运行的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于的开发环境说明 window系统：Windows 10 企业版 64位操作系统Linux系统：BigCloud Enterprise Linux 7.8 (Core)Visual Studio：Microsoft Visual Studio Enterprise 2019 版本 16.10.4 安装 Visual Studio Linux 工作负载 根据Microsoft官网文档介绍，
开始之前
首先，请确保已安装 Visual Studio Linux 工作负载，包括 CMake 组件。 它属于 Visual Studio 安装程序中的“使用 C++ 的 Linux 开发”工作负载。 如果不确定是否安装了此项，请参阅在官方说明《 Visual Studio 中安装 C++ Linux 工作负载》。
使用 Visual Studio Installer 安装即可。
在Linux系统上安装依赖工具 根据Microsoft官网文档介绍，
此外，请确保在远程计算机上安装了以下项：
gcc
gdb
rsync
zip
ninja-build（Visual Studio 2019 或更高版本）
可以使用 Visual Studio 2019 在远程 Linux 系统或 WSL 上生成和调试，CMake 将在该系统上调用。 应在目标计算机上安装 Cmake 版本 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c09c51472e8f1d68bcd8784d3822bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e01a583980078105f6d05d9b65d425b/" rel="bookmark">
			C语言例程：数列求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数列求和 计算 1+1+2+1+2+3+1+2+3+4+…+1+2+…+n 的值。通过该实例，可以学习 if 条件判断语句和
for 循环语句的应用。程序运行结果如图 所示。
#include &lt;stdio.h&gt; int main() { int i,j,n; /* 定义循环变量 i,j，数列项数 n */ long int sum=0,temp=0; /* 定义数列的和及临时变量*/ printf("Please input a number to n:\n"); /* 提示输入数列项数*/ scanf("%d",&amp;n); if(n&lt;1) /* 如果输入的数小于 1*/ { printf("The n must be no less than 1!\n"); /* 提示输入有误*/ return -1; /* 程序返回，退出*/ } for(i=1;i&lt;=n;i++) /* 循环计算数列的和*/ { temp=0; for(j=1;j&lt;=i;j++) temp+=j; sum+=temp; } printf("The sum of the sequence(%d) is %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e01a583980078105f6d05d9b65d425b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1086b1b61e8c19d8988b7da1138722/" rel="bookmark">
			Windows安装下Kali入侵网站的思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 First！windos下先安装kali和wsl工具开启Hyper-v虚拟化服务才能正常使用下载一个认证的加速才能正常安装某软的产品，其他链接UsbEAm Hosts Editor [多平台hosts修改] V3.63 – Dogfight360DNS改成如下图 下载完成后，选择旁边的图标按照如下图开启 接下来就打开官方商城搜索下载，最后下载完成后点击清除当前即可 首先，我们得在搜索上随机挑选一个网站，现攻现学，当然这只是思路 前提概要《请遵守您本国家的相关法律法规，如有其他疑问或者任何事情与我本人无关》 首先您得使用nmap扫描此网站下的所有漏洞和服务版本号和相关服务开启和服务器使用版本 为了不会被发现所以不得不使用使用P0参数 nmap -P0 -sV -sS -O --script=vuln 网址/IP 扫描结果发现存在IIS远程绕过漏洞CVE-2014-4078，目前此漏洞已有微软相关安装补丁Microsoft Security Bulletin MS14-076 - Important | Microsoft Learn 利用IIS远程绕过命令服务器即可获取到目标服务器权限，并且控制目标主机（高危） 21存在FTP链接，可尝试进行爆破 2121端口可能是修改安全策略端口，也有可能是3389端口链接 3306端口可提供msf/SQL口令爆破，如修改强密码即可避免 3306存在远程内存公开与暴露，官方建议更新到最新版本以修复（高危） 49154可能存在远程RPC类似向日葵远程攻击执行漏洞，可能使服务器蓝屏无法正常使用等 最终思路解析：主要是使用通过msf对IIS进行远程IIS远程测试，并且攻击成功上传文件shell后，加入新的用户并提升管理员权限 net user add //用户名密码 net localgroup Administrators 用户名/add 其他方法思路请自行挖掘 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387d0493508f5d8244aae4f86ef6e623/" rel="bookmark">
			学习黑客十余年，如何成为一名安全工程师？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习黑客十余年，如何成为一名安全工程师？ 学习十余年的经验，最终我的心得是——决定大多数人是否能够学会这个技术的关键点，是对一些基本问题的理解是否准确。
我曾经问过很多学习黑客技术的初学者为什么要学习这个，我得到的最多答案就是“我要变得很牛逼”，然而至于如何才算牛逼呢，他们的答案是“如果我学会黑客技术，我就会怎么样怎么样”，而当你继续问要学习什么才能这么牛逼时，基本上就给问住了。
举例来说，如果小明认为“如果我要学会黑客技术，我就可以盗美女的QQ号啦”，那么如果小明是按照一个专业黑客的路线发展的话，小明首先需要做的就是要精通C语言。
而学习C语言与盗QQ这种工具流比起来，简直不知道要高级多少倍，因此自然也要更困难些，这样就会导致小明做着一件实际价值很高，但在小明看来却不值一提的事（C语言在小明心里远不及盗QQ高级），这种落差带来的认知失调最终会将你学习黑客技术的激情冲的一干二净。
因此，学习黑客技术的第一条铁律就是不要有终点思维，深刻理解成长才是永恒的主题。
其次，是幻想与价值的博弈。
懒惰是最容易容易让人们产生幻想的行为。因为懒惰，所以不能得到，但是内心又无比渴求，所以只能通过幻想来麻痹自己。
这里的幻想可能是自己有意识的幻想，也有可能是无无意识的幻想，甚至自己都不知道正处于幻想中。
但是你大可不必为此而自责，最起码对于我来说，或者我通过观察周围的人而得出的结论，包括我在内的几乎所有人都在无时无刻的与懒惰做着斗争，例如“事情太多”、“这太难了”、“没有灵感”等等都是因懒惰而产生的幻觉。
因此，任何一位你眼中的大牛无不是通过了无数次与懒惰的殊死博弈才取得的今天的成就。
因此，你要知道，只有你真正俯下身子去一点点的学习知识，才会使得你离黑客越来越近。
但可怕的是，大多数初学者并不懂得这些，他们在内心深处始终都认为有那么一种灵丹妙药可以让他在更短的时间内掌握黑客技术，从而去花费数倍于所谓的“更短时间”的时间去寻求这本就不存在的方法。
因此，学习黑客技术的第二条铁律就是不要抱有任何幻想、任何偷奸取巧，只要你决定这条路是自己去走，那么无论你如何寻找奇技淫巧，最终都不会让你少走半步。
最后，是浮躁与耐心的博弈。
包括我在内的绝大多数人，在制定目标时都会高估自己的精力、高估自己的效率、高估自己的智商，甚至高估自己对此事的兴趣。
这一系列的高估会在学习后半段严重干扰我们的学习效果，那种现实与理想的差距会导致你对自己能力的认知失调，进而过低的估计自己各方面能力，最终导致失败。
因此，学习黑客技术的第三条铁律就是时刻葆有对低效率的自己的耐心。
要考虑的问题
想要做任何事情之前，一定要想清楚三个问题，分别是你为什么要做，你愿意为此付出什么，你想要的结果是什么。
而所谓的智慧，就是一个人通过这种方式不断的调整自己对于各种事情的预期，从而达到一种与外界的平衡。
如果将这个思路映射到黑客学习这件事上，大体可以分为如下三个问题。
首先，要考虑清楚你为何要学这个。
说白了就是你的动机是什么，如果你的动机是不可持续的，例如盗个扣（甚至是挖个系统级0Day漏洞），那么我建议你将自己的动机修改为可持续的，例如你想保持一项什么记录（甚至是让其他人更加尊敬你），因为这类动机是在不断变换的，只有这类动机才能让你有一个更加长久的动力源泉，才能促使你坚持的更久，也就能取得更大的成就。
其次，要考虑明白你可以付出什么。
你要清楚的是，任何事情都是有代价的，而且如果你此时的年龄越小，你那么你对“代价”的理解就越不深刻，这点一定要着重加以注意。
黑客技术是一件非常有魅力、非常有价值，同时也是非常酷的一件事，但是这么有魅力的事情，如果你想要完成它，要么需要极佳的运气，要么就是需要你付出非人的努力。
举例来说，最近我们经常看到媒体在报道时说国内某组织的某黑客在几秒内就攻破了IE浏览器，在几秒内就绕过了XX保护机制。但事实的真相是他们其实就是运行了一个自己准备好的代码而已，而媒体上说的这几秒钟的时间其实是代码的运行时间。
据我所知，他们在参赛之前，整个团队为了这几秒钟的ShowTime，需要经历至少十余个甚至数十个不眠之夜，然后才能打造出可能仅有几百个字节的艺术品般的代码（也就是Exploit），最后才能拿去现场过五关斩六将。
如果在这个十三亿人口的国度里最牛逼的黑客都需要如此付出，那么作为目前默默无闻的你来说，想要学会这门技术应该需要多少个不眠之夜呢？
最后，要考虑你的学习方向是什么。
信息安全领域的方向太多了，如果最粗旷的分，大致可以分为网络安全、软件安全、基****础安全这三类。
其中网络安全包括网络渗透、通讯安全、电信安全等，软件安全包括授权控制、漏洞挖掘、加密解密等，基础安全分为理论安全、密码学等。
我收到的最多的、也是令我最郁闷的问题就是“你的那幅图我已经看了，但是我想知道我应该怎么学呢？或是从何处开始呢？”
是的，你没看错，纵然我这幅图获得了超乎想象的关注，但是仍有很大一部分人似乎并没有因为这个世界上多出这幅珍贵的图而获得什么，他们仍然是迷茫的，当然，这也并不能全怪他们。
所有人的成长都是从知道自己不需要什么东西开始的，举例来说，几乎95%以上的大学生其实根本就不知道自己想要什么，只知道自己不想要什么，这其实就是不成熟的一种表现，用我们那个方言讲就是“青瓜蛋子”。
那么“青瓜蛋子”们最需要的是什么呢？就是前辈们的指导，告诉他们，他们真正的需求是什么，然后他们恍然大悟，似乎这就真的是他们此时所最需要的东西了。
而就大多数事情而言，根本没那么复杂，随意挑选一个你最感兴趣的方向就好了；如果挑不出来，那就随意挑一个你感觉自己最擅长的；如果还挑不出来，那就挑一个你感觉最顺眼的即可。
学习信息安全技术如同做其他事情一样，最终如果你要想有所成就，必然是登上这个领域数座高峰的强者，然而你一开始并不能做到这一点，因此最简单的方法就是随便挑选一座不是太低的山峰蹬一蹬试试看。
因为只要你能登上其中的一座山峰，就能一览众山小，就掌握了快速登顶相邻山峰的方法。
学习信息安全技术同样如此，你应该想找一个不是太浅的方向（例如渗透就有些浅）深入研究下去，等你将这个领域彻底研究明白后，其他方向的技术自然就能触类旁通了。
学习路线详情
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0PL50fzs-1677941375401)(C:\Users\Administrator\Desktop\网安思维导图\享学首创年薪40W+网络安全工程师 青铜到王者技术成长路线V4.0.png)]
这些内容脱产自学的话至少需要3年。
边工作边自学的话，如果工作内容不能与学习内容高度重合，那么至少需要5年以上时间。
后，其他方向的技术自然就能触类旁通了。
学习路线详情
[外链图片转存中…(img-0PL50fzs-1677941375401)]
这些内容脱产自学的话至少需要3年。
边工作边自学的话，如果工作内容不能与学习内容高度重合，那么至少需要5年以上时间。
网络安全基础入门需要学习哪些知识？ 网络安全学习路线 这是一份网络安全从零基础到进阶的学习路线大纲全览，小伙伴们记得点个收藏！
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ch96RSSu-1677941384592)(data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)]编辑
阶段一：基础入门 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hRQmZdjm-1677941384593)(data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)]
网络安全导论
渗透测试基础
网络基础
操作系统基础
Web安全基础
数据库基础
编程基础
CTF基础
该阶段学完即可年薪15w+
阶段二：技术进阶（到了这一步你才算入门） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C3Kc5GPA-1677941384594)(data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)]
弱口令与口令爆破
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/387d0493508f5d8244aae4f86ef6e623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e54749aa669035f3118e0b358d83254/" rel="bookmark">
			matlab - 程序流程控制、函数文件、特殊函数、调试与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习视频
MATLAB代码的两种执行方式：命令行、程序执行。
1.程序流程控制 1.1.m文件 matlab中m文件分为两种： 脚本文件&amp;函数文件。 脚本文件：实际上是一个命令的集合，可认为是命令行的改良版，方便我们去编写命令 函数文件：声明了一个函数，是一个代码块，方便程序调用 区别：脚本没有输入没有返回，可以直接运行( 输入文件名/F5)；函数类似于一个完整的程序，有输入有返回，在脚本中 调用才能运行。 脚本： 函数： mlx文件 实时脚本，边写边运行，可以在输入时进行函数名自动补全。
1.2.三种程序结构 实例：
1.3.选择结构 if-else switch 1.4.选择结构 for 示例：
while break和continue 这个没什么好说的，和C++/C那些一样。
1.5.循环嵌套 这个也没什么好说的，示例(阶乘和)：
2.函数文件 2.1函数文件的基本结构 由function和end引导，包含输入和输出 说明：函数文件名和函数名可以不同 2.2函数调用 % [输出参数表] = 函数名字(输入参数) % 注意：输入的参数顺序、个数预定义的一致 2.3递归 2.4函数参数 2.5变量的作用域 % 全局变量global，局部变量local(函数内部) % global作用域为整个函数空间，所有函数都可以对它进行存取和修改 % global可用来函数间的信息传递 % 不提倡使用global 3.特殊函数 3.1 子函数 主函数 Primary function 子函数 Subfuntion 子函数类似于其他编程语言中函数嵌套中的内层函数 3.2内联函数 以字符串形式存在的函数表达式可以通过 inline 函数转化成内联函数 3.3匿名函数(一行函数) 基本格式如下： 匿名函数名 = @(匿名函数输入参数) 匿名函数表达式 或者 匿名函数名 = @ 函数名 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e54749aa669035f3118e0b358d83254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f68ed4262494b0ca0c1717a4f66bf1/" rel="bookmark">
			FPGA的GigE Vision IP相机图像采集方案设计，转换为千兆UDP，支持10G MAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 GigE Vision是一个比较复杂的协议，要在FPGA中完全实现具有较大的难度。如果FPGA作为接收端希望实现GigE Vision相机的配置和图像采集功能，则只需要实现其中小部分功能即可。本文对原有GigE Vision协议的结构进行了裁剪，仅保留设备搜索、寄存器配置和图像采集三个主要功能。并在FPGA中成功实现了对Basler GIGE相机的配置和图像实时采集。
2 GigE Vision协议 GigE Vision协议包含GVCP（GigE Vision Control Protocol）和GVSP（GigE Vision Streaming Protocol）两部分。其中，GVCP负责对相机进行配置，GVSP负责控制图像数据的传输。
2.1 GVCP协议 GVCP协议规定了应用程序通过以太网配置和控制外部设备的准则，设备的配置过程采用了指令（CMD）和应答（ACK）的方式。以外部主机和相机为例，首先，主机通过以太网向相机发送指令包，然后等待相机返回当前指令的应答包；相机接收到指令包后执行相应的操作，而后向主机返回应答包。主机收到应答包后，根据应答包中的状态信息判断指令是否执行成功，若执行成功则继续发送下一个指令包，否则重新发送当前指令包。该方式弥补了UDP协议面向无连接的缺点，保证了数据传输的完整性和可靠性。
GVCP包含两种格式的数据包：指令包和应答包，指令包首部为：
在指令包首部中，0x42为GVCP指令包的固定字段，flag字段包含了不同指令的特定信息，command字段代表指令的类型，length字段代表指令包中除首部外，载荷数据的长度（单位：字节），req_id代表指令包的序号。
3结构框架 前面提到完全用FPGA纯逻辑GigE Vision是比较困难的，本方案主要采用cpu和PL逻辑搭配的方式实现协议的转换
最终将GigE Vision协议的相机数据转换为UDP协议数据，PC可以通过接收普通UDP数据，同时IP支持SPI接口和I2C接口对相机参数进行二次配置;
其中BUFFER需要借助片外DDR作为大容量缓存
支持GigE Vison Specification version 1.x/2.x协议
同时为了适应高分辨率的图像数据，最终只需要替换GMAC为10/25 Gbps Ethernet MAC即可，增加系统的灵活性
C代码部分可以提供静态库函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be4e35eccfd1bb9b4633174d1860dde/" rel="bookmark">
			39｜源码解读：V8执行JS代码的全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		39｜源码解读：V8 执行 JS 代码的全过程 你好，我是LMOS。
前面我们学习了现代浏览器架构，也大致了解了浏览器内核的工作原理。在浏览器的内核中，V8 是一个绕不开的话题。在浏览器中，Chrome 的重要地位不用赘述，而V8不仅是 Chrome 的核心组件，还是 node.js 等众多软件的核心组件，所以，V8的重要程度亦不用多言。
不过，V8涉及到的技术十分广泛，包括操作系统、编译技术、计算机体系结构等多方面知识，为了带你先从宏观角度系统学习和了解V8项目，这节课我会从源码理解讲起，带你了解了V8 执行 JS 代码的全过程。
如何阅读 V8 源码和搭建 V8 开发环境 前面两节课，我带你简单了解了 Chromium 和 Webkit 项目的目录结构，在这里我们继续看一下如何学习 V8 源码。
Chromium 项目中包含了可运行的 V8 源码，但是从调试的角度看，我们一般使用 depot_tools 来编译调试 V8 源码，它是V8的编译工具链，下载和编译代码都需要用到它，你可以直接点击 depot_tools bundle 下载。
解压后，我们需要将 depot_tools 工具添加到环境变量，注意这些操作需要你保证本机可以访问 Google 浏览器。
我们以 Mac 系统为例，添加到环境变量的代码命令如下：
export PATH=`pwd`/depot_tools:"$PATH" 然后，你可以在命令行中测试 depot_tools 是否可以使用：
gclient sync 下载完 depot_tools 后，我们就可以下载 V8 代码进行编译调试了“
mkdir v8 cd v8 fetch v8 cd v8/src 下载好 V8 源码后，我们需要使用 GN 来配置工程文件。下面是我们用到的几个编译的参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be4e35eccfd1bb9b4633174d1860dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9853950346f45c7f1ad1fefa628b8f19/" rel="bookmark">
			Ubantu扩展SWAP区，使用gparted，以及死机非热启动解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubantu扩展SWAP区，使用gparted，以及死机非热启动解决方法 Swap分区强制重启扩充SWAP Swap分区 Swap分区是用来扩展内存的，即使用一部分硬盘空间作为交换，个人认为电脑内存大于16G即不需要分配Swap空间。
我是已经装机完成之后，才发现忘记分配Swap分区，电脑内存有8个G，刚开始感觉可能已经够用了，就没有管，结果同时运行vscode和几十个chrome网页之后他死机了。。。
强制重启 尝试进入命令行，使用ctrl+alt+F1-6也进不去，所以
1、shutdown
2、poweroff
3、init
4、reboot
5、halt
等命令均无法使用，使用热启动会损坏机械硬盘，也可能对主板造成伤害，查阅之后，发现可以使用Ctrl + Alt + PrtSc (SysRq) + reisub（依次按下即可）进行强制重启。
扩充SWAP 在ubantu下扩充可以使用Gparted工具，如果没有安装可以sudo apt install， 使用此图形化页面工具可以选择分区，格式化为Swap，保存操作之后，右击可以设置为交换分区，
此时在终端输入free -m或者使用系统自带的监视器均可看到已经启用的Swap分区，但这样的保存不是永久的。
此时需要首先复制Swap分区的UUID，随后输入
sudo gedit /etc/fstab 来令其永久
输入UUID=... swap swap default 0 0保存即可
reboot重启发现已经成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c724b92957b247bb2e5a0118fcd65e5/" rel="bookmark">
			tiff&#43;ubuntu20.04安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cd tiff-4.0.10 mkdir cmakeBuild cd cmakeBuild cmake .. make sudo make intstall 大体流程如上，详细操作及日志输出如下 目录
大体流程如上，详细操作及日志输出如下
1、下载压缩包
2、创建build文件夹
3、cmake
4、make
5、make install
1、下载压缩包 从官网下载压缩包：Index of /libtiff/
解压
2、创建build文件夹 里面已有名称为build的文件夹，故创建cmakeBuild文件夹来保存cmake结果
mkdir cmakeBuild cd cmakeBuild 3、cmake 日志如下
~/tools/tiff-4.0.10/cmakeBuild$ cmake .. -- Building tiff version 4.0.10 -- libtiff library version 5.4.0 -- The C compiler identification is GNU 7.5.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Performing Test C_FLAG_Wall -- Performing Test C_FLAG_Wall - Success -- Performing Test C_FLAG_Winline -- Performing Test C_FLAG_Winline - Success -- Performing Test C_FLAG_W -- Performing Test C_FLAG_W - Success -- Performing Test C_FLAG_Wformat_security -- Performing Test C_FLAG_Wformat_security - Success -- Performing Test C_FLAG_Wpointer_arith -- Performing Test C_FLAG_Wpointer_arith - Success -- Performing Test C_FLAG_Wdisabled_optimization -- Performing Test C_FLAG_Wdisabled_optimization - Success -- Performing Test C_FLAG_Wno_unknown_pragmas -- Performing Test C_FLAG_Wno_unknown_pragmas - Success -- Performing Test C_FLAG_Wdeclaration_after_statement -- Performing Test C_FLAG_Wdeclaration_after_statement - Success -- Performing Test C_FLAG_fstrict_aliasing -- Performing Test C_FLAG_fstrict_aliasing - Success -- Performing Test HAVE_LD_VERSION_SCRIPT -- Performing Test HAVE_LD_VERSION_SCRIPT - Success -- Looking for assert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c724b92957b247bb2e5a0118fcd65e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2c67f03cfcf16ce9c59958339ba10e/" rel="bookmark">
			功能测试如何编写测试用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试用例的编写需要按照一定的思路进行，而不是想到哪写到哪，一般测试机制成熟的公司都会有公司自己自定义的测试用例模板，以及一整套的测试流程关注点，当然我们自己在测试生涯中也应当积累一套自己的测试框架，所有功能性的测试都可以依据框架的思路来进行，达到事半功倍的效果。
功能测试框架可以包括：界面友好性测试、功能测试、链接测试、容错测试、稳定性测试、常规性能测试、配置测试、算法测试等等。
1.1.1 界面友好性测试 1. 风格、样式、颜色是否协调
2. 界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条
3. 界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字）
4. 操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作）
5. 提示界面是否符合规范（不应该显示英文的cancel、ok，应该显示中文的确定等）
6. 界面中各个控件是否对齐
7. 日期控件是否可编辑
8. 日期控件的长度是否合理，以修改时可以把时间全部显示出来为准
9. 查询结果列表列宽是否合理、标签描述是否合理
10. 查询结果列表太宽没有横向滚动提示
11. 对于信息比较长的文本，文本框有没有提供自动竖直滚动条
12. 数据录入控件是否方便
13. 有没有支持Tab键，键的顺序要有条理，不乱跳
14. 有没有提供相关的热键
15. 控件的提示语描述是否正确
16. 模块调用是否统一，相同的模块是否调用同一个界面
17. 用滚动条移动页面时，页面的控件是否显示正常
18. 日期的正确格式应该是XXXX-XX-XX或XXXX-XX-XXXX:XX:XX
19. 页面是否有多余按钮或标签
20. 窗口标题或图标是否与菜单栏的统一
21. 窗口的最大化、最小化是否能正确切换
22. 对于正常的功能，用户可以不必阅读用户手册就能使用
23. 执行风险操作时，有确认、删除等提示吗
24. 操作顺序是否合理
25. 正确性检查：检查页面上的form, button, table, header, footer,提示信息，还有其他文字拼写，句子的语法等是否正确。
26. 系统应该在用户执行错误的操作之前提出警告，提示信息.
27. 页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。
28. 合理性检查：做delete, update, add, cancel, back等操作后，查看信息回到的页面是否合理。
29. 检查本地化是否通过：英文版不应该有中文信息，英文翻译准确，专业。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d2c67f03cfcf16ce9c59958339ba10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32db3b6c6efc86a75a8d5696400a6413/" rel="bookmark">
			Go环境搭建与IDE开发工具配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Go语言编译器 Go语言编译器=》编译器=将源代码编译为可执行程序=》源代码=程序员使用高级语言所书写的代码文件=》高级语言=c/c++/go…=》机器语言=0和1构成，机器能直接识别=》汇编语言=比机器语言稍微可读一点点的指令集
编译器下载地址 根据系统下载对应的go编译器版本
https://golang.google.cn/dl/
运行go程序代码 在未配置全局变量执行go程序情况下，可以到go编译器下的bin目录执行go程序进行编译
配置go环境变量 1、在Path变量下指定go.exe程序执行的目录，这样就可以在任意目录执行go命令
2、新增GOROOT变量，指定go.exe安装目录
C:\Program Files\Go
3、设置代理
为go get做准备
换成国内可访问的地址，设置GOPROXY代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off （关闭包的有效性验证） go env -w GOSUMDB="sum.golang.google.cn" （也可设置国内提供的sum 验证服务） GO工作目录环境变量配配置 创建并配置GOPATH环境变量
GOPATH=D:\go_work 创建并配置GOPATH环境变量，GOPATH目录还要创建3个子目录
bin：go build生成的可执行exe执行程序目录 pkg：编译生成的中间文件目录 src：书写的项目代码目录 安装IDE集成开发工具配置 IDE版本：goland-2020.2.3_Protable
错误：下边指定go的sdk错误解决
报“The selected directory is not a valid home for Go SDK”报错解决方法
出现这个错误的原因是 idea 的 Go-plugin 插件，和 Go 的sdk版本不匹配；
解决方式：进入Go的安装目录，如C:\Program Files\Go\src\runtime\internal\sys，打开zversion.go文件，加上自己go的版本号即可
const TheVersion = `go1.19.4` 1）指定go开发的sdk
2）这里要看到sdk开发包
3）运行指定的go文件进行测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32db3b6c6efc86a75a8d5696400a6413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eff6f0120c669cbc38c5428ad914d3c/" rel="bookmark">
			Unity使用webSocket与服务器通信（一）搭建一个简单地服务器和客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你想在unity WebGL里面使用TCP通信吗，那么你可以用一用webSocket。当然，桌面端也可以使用webSocket，这样Unity多平台发布的时候，业务层的通信代码可以使用一套，而不是桌面用socket，网页用http…
一、什么是webSocket？ 顾名思义，它就是web版的socket？那什么是socket呢？…
二、Unity中webSocket相关的包有哪些？ endel/NativeWebSocket
项目链接
三、Unity客户端的实现 联网演示
绑定脚本
代码清单
代码来自NativeWebSocket官网demo，略作修改
using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using NativeWebSocket; public class Connection : MonoBehaviour { WebSocket websocket; public Text textLog; // Start is called before the first frame update async void Start() { websocket = new WebSocket("ws://192.168.0.146:8081"); websocket.OnOpen += () =&gt; { Debug.Log("Connection open!"); textLog.text = $"Connection open! {Time.realtimeSinceStartup} \n {textLog.text}"; }; websocket.OnError += (e) =&gt; { Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eff6f0120c669cbc38c5428ad914d3c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/171/">«</a>
	<span class="pagination__item pagination__item--current">172/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/173/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>