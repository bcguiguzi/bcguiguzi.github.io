<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28e871d9dc538d127be8c69c5111bdd/" rel="bookmark">
			C语言之如何输出uint32_t和uint64_t和16进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、输出uint32_t uint32_t a = 888; printf("a is %ld", a); 2、输出uint64_t uint64_t b = 888; printf("b is %lu", b); printf("b is %lld", b); 3、输出16进制 int c =16; printf("c is 0x%08x", c); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fcfc5d4e3cf5d162a7b1fe7820a2a2/" rel="bookmark">
			美国高通 Snapdragon Neural Processing Engine SDK （SNPE） 系列 （2）：支持的网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Layer TypeDescriptionCaffe EquivalentTensorFlow EquivalentCPUGPUDSPBatch normalization (+ Scaling)Batch normalization followed by scaling operation. Batch norm operation can be performed by itself or in combination with scaling.Maps to the combination of batch_norm_layer followed immediately by scale_layer.
batch_norm_layer.cpp
scale_layer.cppbatch_normalization✔✔✔Color space conversionConverts input image color format (encoding type) into SNPE native color space. Color space conversion parameters are provided as an option to the model converter tool.There is no such Caffe layer by itself.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fcfc5d4e3cf5d162a7b1fe7820a2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae216554a5f0c9159266429630d484e4/" rel="bookmark">
			iCloud 与  iAd---iOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iCloud云存储 在苹果开发者中心 AppID中勾选iCloud，重新生成描述文件profile在项目中|Capabilities 中打开iCloud，勾选 Key-Value ， iCloud Documents。 会自动生成项目.entitlements文件手机中设置iCloud账号 存储文档 自定义UIDocument对象类 #import &lt;UIKit/UIKit.h&gt; @interface YTSDocument : UIDocument @property (nonatomic,strong) NSData *data; @end #import "YTSDocument.h" @implementation YTSDocument // 存储时调用 -(id)contentsForType:(NSString *)typeName error:(NSError * _Nullable __autoreleasing *)outError{ if(_data){ return [_data copy]; } return [NSData data]; } // 读取时调用 -(BOOL)loadFromContents:(id)contents ofType:(NSString *)typeName error:(NSError * _Nullable __autoreleasing *)outError{ _data=[contents copy]; return true; } @end VC #import "YTViewController.h" #import "YTSDocument.h" @interface YTViewController () @property (nonatomic,strong) NSMetadataQuery *dataQuery; @property (nonatomic,strong) NSMutableDictionary *fileDic; // @{文件名:修改时间} @property (nonatomic,strong) YTSDocument *dcocument; @end @implementation YTPersonCCViewController - (void)viewDidLoad { [super viewDidLoad]; // 查询icloud文档列表对象 _dataQuery=[NSMetadataQuery new]; _dataQuery.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae216554a5f0c9159266429630d484e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8beff9ed0696a87658a04d94ed53d7/" rel="bookmark">
			【转】证书安装指引（腾讯云）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载得到的 www.domain.com.zip 文件，解压获得3个文件夹，分别是Apache、IIS、Nginx 服务器的证书文件，
下面提供了4类服务器证书安装方法的示例：
1. Apache 2.x 证书部署 1.1 获取证书 Apache文件夹内获得证书文件 1_root_bundle.crt，2_www.domain.com_cert.crt 和私钥文件 3_www.domain.com.key,
1_root_bundle.crt 文件包括一段证书代码 “-----BEGIN CERTIFICATE-----”和“-----END CERTIFICATE-----”,
2_www.domain.com_cert.crt 文件包括一段证书代码 “-----BEGIN CERTIFICATE-----”和“-----END CERTIFICATE-----”,
3_www.domain.com.key 文件包括一段私钥代码“-----BEGIN RSA PRIVATE KEY-----”和“-----END RSA PRIVATE KEY-----”。
1.2 证书安装 编辑Apache根目录下 conf/httpd.conf 文件，
找到 #LoadModule ssl_module modules/mod_ssl.so 和 #Include conf/extra/httpd-ssl.conf，去掉前面的#号注释；
编辑Apache根目录下 conf/extra/httpd-ssl.conf 文件，修改如下内容：
&lt;VirtualHost www.domain.com:443&gt; DocumentRoot "/var/www/html" ServerName www.domain.com SSLEngine on SSLCertificateFile /usr/local/apache/conf/2_www.domain.com_cert.crt SSLCertificateKeyFile /usr/local/apache/conf/3_www.domain.com.key SSLCertificateChainFile /usr/local/apache/conf/1_root_bundle.crt &lt;/VirtualHost&gt; 配置完成后，重新启动 Apache 就可以使用https://www.domain.com来访问了。
注：
配置文件参数说明SSLEngine on启用SSL功能SSLCertificateFile证书文件SSLCertificateKeyFile私钥文件SSLCertificateChainFile证书链文件 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8beff9ed0696a87658a04d94ed53d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a801989dd421ef20153cdf13ced0bf/" rel="bookmark">
			华为AR路由器QOS限速命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Huawei] interface Vlanif 1 （interface后边跟上你想限速的vlanif号）
或者 [Huawei] interface gigabitinterface 0/0/0 （interface后边跟上你想限速的端口）
//限制上传
qos car inbound source-ip-address range 192.168.10.249 to 192.168.10.249 per-address cir 1000 （单位为Kbps）
//限制下载 qos car outbound destination-ip-address range 192.168.10.249 to 192.168.10.249 per-address cir 1000 （单位为Kbps）
本文转自 http://bbs.51cto.com/thread-1167362-1.html zdz88网友的回答并加以自己其它的说明及内容
转载于:https://blog.51cto.com/taoyeno1/1963290
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9b330bbfba098b483f23fce9a68c6c/" rel="bookmark">
			python读写matlab的.m文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做深度学习的项目时，原始图片一般会先转换成其他格式，方便学习框架直接读取，比如caffe的leveldb、lmdb，matlab的.m格式，tensorflow的tfrecords格式等。
python读写tfrecords格式，请参照http://blog.csdn.net/guvcolie/article/details/77460494
python读写matlab的.m格式也很简单，写了小例子，直接上代码了
import scipy.io as sio import numpy as np ## 将data变量保存在mat文件中data1对应的位置处 data = np.array([1, 2, 3, 5], dtype='float32') sio.savemat('result.mat', {'data1': data}) ## 将mat文件中data1位置对应的数据读取出来 file = sio.loadmat('result.mat') var = result['data1'] print(var) ## 读取mat文件中的数据格式信息 info = sio.whosmat('result.mat') print(info) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485a5d965954fd55b059237b65a80ad6/" rel="bookmark">
			欧拉回路/路径【总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为广大OIer的朋（gong）友（di）的欧拉，在图论中也贡（zuo）献（e）良（duo）多（duan），尤其是萌新经常会遇到以下两个恶心玩意。 欧拉路径：在一个图中，由i点出发，将每个边遍历一次最终到达j点的一条路径。 欧拉回路：i=j时的欧拉路径。 于是，如何确定一个图是否存在欧拉路径/回路，并找到这条路经，成为了出题人虐待萌新的法宝。
无向图 首先，在无向图中，要确定是否存在欧拉回路很容易：只要每个点的度数均为偶数即可。（这里就不扯什么连不连通的鬼东西了）。 因为每个点的度数为偶数，所以可以将整个图看做由数个环嵌套而成，因为环一定能找到一条欧拉回路，所以整个图也能找到欧拉回路。 欧拉路径：如果有且仅有两个点的度数为奇数，就会存在一条从这两个中的一个到达另一个的欧拉路径。 假如在这两个点间连一条边，就能够从任意一个点出发找到一条欧拉回路，当出发点为这两个点中的一个时，切断这条边，就成为一条欧拉路径了。 有向图 欧拉回路：所有点的入度等于出度，就存在一条欧拉回路。 这里可以换一种角度来理解，对于每一个点，每次进入这个节点，就一定有一条路可以出去，因此必定存在一条欧拉回路。 欧拉路径：最多有一点入度等于出度+1，最多有一点入度等于出度-1，就会有一条从出度大于入度（没有则等于）的点出发，到达出度小于入度（没有则等于）的点的一条欧拉路径。证明方法与无向图的欧拉路径类似。
至此，我们已经可以判断一个图是否存在欧拉回路/路径了。 接下来就是找出这条路经。首先，出发点我们在证明中已经确定，只需要保留路径时由后往前保存，再利用深搜回溯的过程，我们可以保证不会走死胡同（其实是走了死胡同，但保存路径时会把这段路留到最后，就相当于没有走死）。 因此，栈成为我最喜爱的保存路径的数据结构（先进后出）。
void dfs(int x){ for(int i=0;i&lt;a[x].size();i++) if(vis[x][i]==0){ vis[x][i]=1; //delete(a[x][i],x);无向图要加这句 dfs(a[x][i]); path.push(id[x][i]);//存储路径上的边 cnt++; } ans.push(x);//存储路径上的点 } 建议仔细分析一下：存储点和存储边的代码在位置上是否必须固定？如果不是，那么还能够怎么写？如果是，改成其他样子有什么结果？
注:有时候，你可能需要判断是否存在路径，一种很懒的做法是直接找路径，如果路径的长度等于给出的边数，就算有解，否则无解。 但其实这是错误的。 如果你真的理解了我刚才对算法的介绍，就会发现我的介绍是基于一定存在路径的基础上的。如果不存在路径，这个算法仍然会得出一个错误的解，这是由于搜索时，因为相信一定有解，所以会将一些不可行的边视为可行，自然会出错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a741d7a0ee46388a4969e750f9091ece/" rel="bookmark">
			php 获取移动端ip和pc端ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，获取pc端ip
$pc_ip=$_SERVER["REMOTE_ADDR"]; 2,获取移动端ip
$file_contents = file_get_contents('http://pv.sohu.com/cityjson'); $logiName= explode('"',explode(':',$file_contents)[1])[1]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4bbd515389cc775678a3136ef87f1a/" rel="bookmark">
			WebView与ListView滑动冲突——(二)LinearLayout控制WebView滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇我们大致了解了一下View中 事件的一些基础《WebView与ListView滑动冲突——(一)事件基础篇》，Scroll是为了实现View平滑滚动的一个Helper类，通常在自定义View中使用。 这次我们从一下几个方面来了解一下Scroll与VelocityTracker的用法：
View和MotionEvent的位置信息View中的Scroll方法Scroll中的scroll*()方法touchSlop与VelocityTrackerLinearLayout控制WebView滚动 通过上面几个方面的学习，将会对View的滑动有一定的认知。废话不多说了，开始
View和MotionEvent中的位置信息 在我们自定义View中，经常要获取各种位置坐标，但是View的get方法那么多，我也不知道这个get方法获取的到底是不是那个位置坐标，我能怎么办，我也很绝望呀。所以就整理了一些View和MotionEvent中的一些获取位置信息的一些方法。
View的位置信息 View中的获取位置信息的get方法。有些是不能直接在Activity的onCreate()中调用，因为当时View还未绘制完成，这个时候调用View的get方法，获取到的位置信息当然是0了。一般可以在Activity的onWindowFocusChanged()方法中获取，或者使用延迟策略去获取。
下面我们来看一下View中的通过那些信息来定位View的位置
left、right、top、bottom、elevation 这五个参数表示的是View的原始位置距离父控件边缘的距离，并且无论这个View被移动到了什么位置，或者被缩放、旋转了多少，这五个值都是永久不变的
left：目标View的最左边和这个View所在父控件的最左边的距离，通过view.getLeft()方法获取；right：目标View的最右边和这个View所在父控件的最左边的距离，通过view.getRight()方法获取；top：目标View的最上边和这个View所在父控件的最上边的距离，通过view.getTop()方法获取；bottom：目标View的最下边和这个View所在父控件的最上边的距离，通过view.getBottom()方法获取；elevation：目标View的Z轴高度和这个View所在的父控件所在的Z轴高度的距离，通过view.getElevation()方法获取（这个属性是Android 5.0之后添加的新属性） 撒？你说还是不明白，没事。我也没明白。还是用一张图来认识一下把：
translationX、translationY、translationZ 这三个参数代表的是在动画或者滑动View的时候，View的当前位置相对于其原始位置平移的距离：
translationX：在滑动过程中，View当前位置的最左边和这个View原始位置的最左边的距离，通过view.getTranslationX()方法获取；translationY：在滑动过程中，View当前位置的最上边和这个View原始位置的最上边的距离，通过view.getTranslationY()方法获取；translationZ：在动画过程中，View当前位置的Z轴高度和这个View原始Z轴高度的距离，通过view.getTranslationZ()方法获取（这个方法是Android 5.0之后添加的新方法）。 x、y、z 这三个参数代表的是View的当前位置相对于其父控件的距离：
x：目标View的当前位置的最左边和这个View所在父布局的最左边的距离，通过view.getX()方法获取；y：目标View的当前位置的最上边和这个View所在父布局的最上边的距离，通过view.getY()方法获取；z：目标View的当前位置的Z轴位置和这个View所在父布局的Z轴位置的距离，通过view.getZ()方法获取（这个方法是Android 5.0之后添加的新方法）。 这三个参数和前面的几个参数的关系公式如下：
x = left + translationX; y = top + translationY; z = elevation + translationZ; MotionEvent的位置信息 使用MotionEvent类，我们还可以获取到触摸屏幕时View的一些位置参数：
x：当前触摸的位置相对于目标View的X轴坐标，通过getX()方法获取；y：当前触摸的位置相对于目标View的Y轴坐标，通过getY()方法获取；rawX：当前触摸的位置相对于屏幕最左边的X轴坐标，通过getRawX()方法获取；rawY：当前触摸的位置相对于屏幕最上边的Y轴坐标，通过getRawY()方法获取。 下面也通过一张图来清楚的认识一下把，要不然看完还是懵逼+懵逼=懵逼²。。。
好了。对于View和MotionEvent的位置信息就简单说这么多把，够用就行。再说下去就 下笔千言离题万里了（关键是就知道这么多了- -！）
View中的Scroll方法 Android中为了实现View的滑动，系统为此提供了scrollTo()和scrollBy()两个方法。打开源码来让我们一探究竟。
/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4bbd515389cc775678a3136ef87f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8620d8976317519e5a9808ac2ff81a0b/" rel="bookmark">
			数据读取入门——xlsread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近期忙于准备9月14日至9月17日的高教社杯数学建模竞赛，由于本人主要负责建模和算法工作，因此每天抽出一定时间和精力放到MATLAB上。不过今天并不顺利，仅仅在一个Excel表格的读取上就犯了难，字符型和数值型完全蒙圈，还好，最终攻克了这个小难题，本文也算是分享我对xlsread函数的一点心得。
1.只含数值型变量的Excel表格
这个两种方法：粘贴或xlsread函数调用。粘贴不必多说，至于xlsread，我们利用如下格式：
num=xlsread('filename','sheet','range') 式中括号内的三项都要加单引号，filename顾名思义，就是要导入的Excel的文件名，注意加.xls或.xlsx就好，第二个sheet就是表格页名，第三个range是指要导入数据的范围，这个对Excel不熟练的话建议用MATLAB打开Excel表格，直接用鼠标选中要导入的数据，然后表格里会自动出现选中数据的范围（这个的确好用），写入range即可。 2.同时含数值型变量和字符型变量的Excel表格
这个稍有些麻烦。
首先，如果仅仅是需要处理其中数据，那么方法同1。如果既要处理数据又要处理字符型变量的话，就经常用到下面两种格式：
[num,txt]=xlsread('filename','sheet','range') [num,txt,raw]=xlsread('filename','sheet','range')其中，num是数值型变量且为矩阵，txt是字符型变量且为细胞数组，raw既含数值型变量又含字符型变量，当然，raw是细胞数组。举个例子，日期销量2015/2/282.6182e+032015/2/272.6084e+032015/2/262.6519e+032015/2/253.4421e+032015/2/243.3931e+032015/2/233.1366e+032015/2/223.7441e+03这是一个名为ex1.xlsx的Excel表格的全部内容，现在我们读取它的每一部分
[num,txt,raw]=xlsread('ex1.xlsx')输出结果如下
num=2.6182e+032.6084e+032.6519e+033.4421e+033.3931e+033.1366e+033.7441e+03txt=日期 销量2015/2/282015/2/272015/2/262015/2/252015/2/242015/2/232015/2/22raw=
日期销量2015/2/282.6182e+032015/2/272.6084e+032015/2/262.6519e+032015/2/253.4421e+032015/2/243.3931e+032015/2/233.1366e+03注：txt和raw输出的每一个细胞单元都带单引号。 一般我们进行的数据分析都是同时对数值和字符进行处理的，本人建议利用num作数据预处理，然后用经过缺失和异常数据插补的raw来生成新的Excel表格，再利用新的Excel表格作下一步的工作即可。 祝愿大家玩熟xlsread，千万别像我一样卡在Excel数据读取上了，嘻嘻。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa76af5b39db434eb3364e5f0526347c/" rel="bookmark">
			java 动态获取当前系统桌面位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主在前段时间进行POI导出数据的时候困惑于文件的输出位置,因为没有用Excelutil包和response,所以一开始数据的存储位置直接写死,但是这样很不好,但是进行客户选择下载路径这个想法弄了许久又没实现,无奈,找到一个折中的方法.那就是动态获取当前用户的桌面路径,将文件的输出位置写为用户桌面.不多说了直接上代码.
File desktopDir = FileSystemView.getFileSystemView() .getHomeDirectory(); String desktopPath = desktopDir.getAbsolutePath(); //博主桌面路径没有改过,用户主机名也没有改过,所以获取到的 desktopPath 为C:\users\Administrator\decstop(此段手写可能拼写有误~),输出出来的desktopPath 但是new FileOutputStream(fileName);时要把"\"替换为"//",所以注意:替换代码为: String filePath = desktopPath.replaceAll("\\\\","//"); 因为"\"会被转译具体转译解释如下: eplaceAll()方法实际是采用正则表达式的规则去匹配的。在regex中"\\"表示一个"\"，在java中一个"\"也要用"\\"表示。这样，前一个"\\"代表regex中的"\"，后一个"\\"代表java中的"\"，所以字符串转义一次，正则转义一次，那么一个斜扛要写4个，要想使用replaceAll()方法将字符串中的反斜杠(\)替换成(\\)，则需要这样写：replaceAll("\\\\","\\\\\\\\") 简单的来说:Java中的replaceAll()方法要用4个反斜杠，表示一个反斜杠.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21adcba32a4547db82af59c849c0db77/" rel="bookmark">
			guzzle/guzzle 日常使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Guzzle Guzzle 是一个 PHP HTTP 客户端，致力于让发送 HTTP 请求以及与 Web 服务进行交互变得简单。
Github：https://github.com/guzzle/guzzle
Composer：https://packagist.org/packages/guzzlehttp/guzzle
发送请求 use GuzzleHttp\Client; $client = new Client([ //跟域名 'base_uri' =&gt; 'http://localhost/test', // 超时 'timeout' =&gt; 2.0, ]); $response = $client-&gt;get('/get'); //http://localhost/get $response = $client-&gt;delete('delete'); //http://localhost/get/delete $response = $client-&gt;head('http://localhost/get'); $response = $client-&gt;options('http://localhost/get'); $response = $client-&gt;patch('http://localhost/patch'); $response = $client-&gt;post('http://localhost/post'); $response = $client-&gt;put('http://localhost/put'); POST $response = $client-&gt;request('POST', 'http://localhost/post', [ 'form_params' =&gt; [ 'username' =&gt; 'webben', 'password' =&gt; '123456', 'multiple' =&gt; [ 'row1' =&gt; 'hello' ] ] ]); 响应 # 状态码 $code = $response-&gt;getStatusCode(); // 200 $reason = $response-&gt;getReasonPhrase(); // OK # header // Check if a header exists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21adcba32a4547db82af59c849c0db77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad5ce8215d185a7f7de366013e59a2c/" rel="bookmark">
			ajax 跨域访问java 带请求头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var bear="eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ5dW53byIsImV4cCI6MTUwNDUxNzM0MH0.yute7tGFcQsmfJ2ReVIO4PQ926VEZq2Ih8_cgm5-LpmI5AW9byn5doe7-7gUwHxOrLY8shWA8nyhXccQZK_Dag"; $.ajax({ type: "GET", url: "http://172.0.0.1:80/platform/organ/getOrganizations", dataType:"json", beforeSend: function(xhr) { xhr.setRequestHeader("Authorization", "Bearer "+bear); }, error: function(XHR,textStatus,errorThrown) { alert ("XHR="+XHR+"\ntextStatus="+textStatus+"\nerrorThrown=" + errorThrown); }, success: function(data,textStatus) { console.log(JSON.stringify(data)); } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67107164bd6c945d5c86c88ee7575f6d/" rel="bookmark">
			Linux 中的虚拟网络-简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文 https://sheepbao.github.io/post/virtual_network_in_linux/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io
Linux 中的虚拟网络-简介 Posted on August 26, 2017 Linux 中的虚拟网络-简介 引言 随着云计算的兴起，计算机的虚拟化达到了空前的热度，计算机的虚拟化加强了服务器负载的能力，更有效的利用计算机资源。
Linux中的真实网络设备 Linux的网络设备像一个双向的管道，数据从一头进，就会从另一头出，关键要看这两头是什么？真实的网络设备中，如下图的eth0，
一头是网络协议栈，另一头网卡。用户发送数据的时候经过socket api调用，进入Linux 网络协议栈处理，再进入Linux 网络设备，最后进入网卡，
如果是接收数据则反过来。
+-------------------------------------------+ | | | +-------------------+ | | | User Application | | | +-------------------+ | | | | |.................|.........................| | ↓ | | +----------+ | | | socket | | | +----------+ | | | | |.................|.........................| | ↓ | | +------------------------+ | | | Newwork Protocol Stack | | | +------------------------+ | | | | |.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67107164bd6c945d5c86c88ee7575f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c113b32646dbb2b3c74c2df51cd1016b/" rel="bookmark">
			JSP实现验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图： 并且点击图片可以更换验证码
验证码 验证原理：
JAVA绘制图片，然后将验证码的字符上传session，在登陆时候验证session 里的值和用户输入的值即可。
首先做个绘制类：
package Domain.func; import javax.imageio.ImageIO; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import javax.swing.*; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; public class DrawYzm extends JFrame{ private int width = 900;//验证码宽度 private int height = 240;//验证码高度 private int codeCount = 4;//验证码个数 private int lineCount = 123;//混淆线个数 char[] codeSequence = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; public void getCode( HttpServletRequest request,HttpServletResponse response) throws IOException { //定义随机数类 Random r = new Random(); //定义存储验证码的类 StringBuilder builderCode = new StringBuilder(); //定义画布 BufferedImage buffImg = new BufferedImage(width,height,BufferedImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c113b32646dbb2b3c74c2df51cd1016b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e019ceaf850770a14915b286e0b0072/" rel="bookmark">
			解决腾讯云安装SSL证书后，服务器可以打开https,外网打不开的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天下载安装了SSL证书后，在服务器端开启HTTPS后，发现在服务器上可以打开https，但在外网打不开，在网上找了好多解决办法都不行，为了这个问题纠结了2天后，无意中给解决了，在此做下笔记。
出现的问题如下：
1、严格按照腾讯云提供的方案对APACHE服务器进行配置。
2、关闭服务器防火墙，开通443端口，在外网telnet IP 443 可以连接
3、在服务器端浏览器输入https://域名可以正常访问
4、在外网输入https://域名打不开
其实在申请SSL证书后，开启SSL特别简单，只是方法和思路的问题。
1）修改apache主配置文件httpd.conf, 找到#LoadModule ssl_module modules/mod_ssl.so，去掉前面的#
2）将Listen 80 改为 Listen 443 https
3）将ServerName localhost 改为 ServerName 127.0.0.1：443，把DocumentRoot 改为 站点程序目录
4）在conf/extra/httpd-ssl.conf中作如下修改：
&lt;VirtualHost *:443&gt; //这部分是重点，一定要把域名改为*
DocumentRoot "C:\WWW\weizan"
ServerName zt.ztwang.cc
SSLEngine on
SSLCertificateFile C:\phpStudy\Apache\2_zt.ztwang.cc.crt
SSLCertificateKeyFile C:\phpStudy\Apache\3_zt.ztwang.cc.key
SSLCertificateChainFile C:\phpStudy\Apache\1_root_bundle.crt
&lt;/VirtualHost&gt;
重启Apache,问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb9795803f30dc2419699ba1349e160/" rel="bookmark">
			CNN目标检测（三）：SSD详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSD github : https://github.com/weiliu89/caffe/tree/ssd
SSD paper : https://arxiv.org/abs/1512.02325
SSD eccv2016 slide pdf : http://download.csdn.NET/download/zy1034092330/9940054
SSD pose estimation paper : http://download.csdn.net/download/zy1034092330/9940059
图1
缩进SSD，全称Single Shot MultiBox Detector，是Wei Liu在ECCV 2016上提出的一种目标检测算法，截至目前是主要的检测框架之一，相比Faster RCNN有明显的速度优势，相比YOLO又有明显的mAP优势（不过已经被CVPR 2017的YOLO9000超越）。SSD具有如下主要特点：
从YOLO中继承了将detection转化为regression的思路，同时一次即可完成网络训练基于Faster RCNN中的anchor，提出了相似的prior box；加入基于特征金字塔（Pyramidal Feature Hierarchy）的检测方式，相当于半个FPN思路 本文接下来都以SSD 300为例进行分析。
1 SSD网络结构 图2 SSD网络结构（和代码貌似有点差别）
缩进上图2是原论文中的SSD 300网络结构图。可以看到YOLO在卷积层后接全连接层，即检测时只利用了最高层feature maps（包括Faster RCNN也是如此）；而SSD采用了特征金字塔结构进行检测，即检测时利用了conv4-3，conv-7（FC7），conv6-2，conv7-2，conv8_2，conv9_2这些大小不同的feature maps，在多个feature maps上同时进行softmax分类和位置回归，如图3。
图3 单层feature map预测和特征金字塔预测对比
2 Prior Box 缩进在SSD中引入了Prior Box，实际上与anchor非常类似，就是一些目标的预选框，后续通过softmax分类+bounding box regression获得真实目标的位置。SSD按照如下规则生成prior box：
以feature map上每个点的中点为中心（offset=0.5），生成一些列同心的prior box（然后中心点的坐标会乘以step，相当于从feature map位置映射回原图位置）正方形prior box最小边长为，最大边长为：每在prototxt设置一个aspect ratio，会生成2个长方形，长宽为： 和 图4 prior box
而每个feature map对应prior box的min_size和max_size由以下公式决定，公式中m是使用feature map的数量（SSD 300中m=6）： 第一层feature map对应的min_size=S1，max_size=S2；第二层min_size=S2，max_size=S3；其他类推。在原文中，Smin=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb9795803f30dc2419699ba1349e160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39242902b6f71f771a6cc6c506346eb/" rel="bookmark">
			tcpdump参数解析及使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/hzhsan/article/details/43445787
tcpdump介绍 tcpdump 是一个运行在命令行下的抓包工具。它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包。tcpdump 适用于
大多数的类Unix系统操作系统(如Linux,BSD等)。类Unix系统的 tcpdump 需要使用libpcap这个捕捉数据的库就像 windows下的WinPcap。
在学习tcpdump前最好对基本网络的网络知识有一定的认识。
tcpdump命令格式及常用参数 Tcpdump的大概形式如下:
例:tcpdump –i eth0 ’port 1111‘ -X -c 3
-X告诉tcpdump命令，需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。 tcpdump采用命令行方式，它的命令格式为：
tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ]
[ -i 网络接口 ] [ -r 文件名] [ -s snaplen ]
[ -T 类型 ] [ -w 文件名 ] [表达式 ] tcpdump的选项介绍
-a 将网络地址和广播地址转变成名字；
-d 将匹配信息包的代码以人们能够理解的汇编格式给出；
-dd 将匹配信息包的代码以C语言程序段的格式给出；
-ddd 将匹配信息包的代码以十进制的形式给出；
-e 在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层的协议；
-f 将外部的Internet地址以数字的形式打印出来；
-l 使标准输出变为缓冲行形式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39242902b6f71f771a6cc6c506346eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e8c61e33b339793240c00ce3795c31/" rel="bookmark">
			直键开关接线流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据典型直键开关的设计规范要求，直键开关内避雷器须经隔离手车连接母线，而直键开关内仓位布置、直键开关接线方式多样，直键开关避雷器未通过隔离手车连接至母线上，当对直键开关进行检修时，拉开直键开关隔离手车，直键开关避雷器仍带电，给进入仓内作业的工作人员带来触电风险。 下面我们就一起来了解一下直键开关接线流程。
市民选购直键开关产品，直键开关是为了在日常运用中更好用、更耐久、更安全。所以，一个企业品牌的直键开关在通过商场和时间的检验后，直键开关想要继续发展，就需要致力于为用户带来质量最上乘的产品。较好的直键开关插座一般正面面板和反面底座都会选用PC料，耐高温、强度高、不褪色而且无污染，而直键开关较差的材料则会用混合料或ABS料代替，直键开关质量粗糙不耐温。但系列直键开关插座，通常直键开关外部面板选用进口高分子PC料，直键开关阻燃耐热不发黄，直键开关可靠性强。
直键开关的铜件一般越厚越好，国家直键开关标准厚度为0.6mm，而许多劣质的直键开关只有0.4mm-0.5mm。其次直键开关材质不能选用黄铜，因为黄铜极易生锈且质地偏软，直键开关使用时间一长导电功能就会下降，现在选用直键开关锡磷青铜较佳。系列直键开关插座内部要选取高精度锡磷青铜材料，直键开关需要一次性压铸而成，弹性好、、触摸牢靠、厚度高、导电性强，且直键开关不易产生电弧，能有效防止火灾的产生。
针对直键开关防误功能不完善，对于后部上直键开关可开启，且直键开关打开后就可直接触及带电部位的高压直键开关加装机械挂锁，配置微机防误程序锁进行闭锁；在直键开关上加装接地开关与后柜门的联锁，加装直键开关带电显示装置闭锁接地开关操作。定期检查直键开关防误装置可靠性，直键开关利用停电机会检查手车与接地开关，直键开关隔离开关与接地开关的机械闭锁装置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e31773ca9535038e97a69d3ccb8a00/" rel="bookmark">
			上传文件到luix系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令
第一步：cd /home/yunqi 进入项目目录
第二步：ls 查看文件
第三步：rz 上传文件 （压缩）
第四步：unzip name.zip 解压(解压前删除原有文件 rm -rf namefile.zip)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/469/">«</a>
	<span class="pagination__item pagination__item--current">470/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/471/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>