<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23978642bf56e71b4ec347941118161/" rel="bookmark">
			Allegro 出焊接坐标文件最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改坐标的单位，制板产商需要mil还是mm；这里出的坐标是器件的中心位置
首先新建name.txt文档；输入以下字段
# This is an extract command file
# generated by the Extract UI.
#
COMPONENT
REFDES
COMP_DEVICE_TYPE
COMP_VALUE
COMP_TOL
SYM_NAME
SYM_CENTER_X
SYM_CENTER_Y
SYM_ROTATE
SYM_MIRROR END
保存；
1：Tools &gt; Reports 2：在 Browse选中刚才新建的 name.txt 文档，单击Report；弹出对话框，复制内容粘贴到excel文件中即可；
上面咱们是直接新建的TXT文件，下面来说下实际的name.txt文件的由来；
在上图中单击 New/Edit;在左边的对话框中选择需要的类型。选中之后会在右边栏显示；选择完毕后；Save即可生成.txt文件；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d13ba2370da8ab04099e6e765033f53/" rel="bookmark">
			Github项目解析（四）--&gt;动态更改TextView的字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近app开发产品提出了一个需求是，需要动态更改TextView内容字体的大小，比如设定TextView只有一行，宽度只有200dp，内容超过这个之后就缩小字体显示，只能能将字体都显示完全；好吧，其实就是动态更改TextView的字体大小，当TextView的内容比较多时缩小显示，当TextView的内容比较少时正常显示。
自己做的话比较费劲，在晚上找了一圈之后发现了一个比较不错的框架:android-autofittextview
地址：https://github.com/grantland/android-autofittextview
具体的使用方式可以在其github网址上参考；
这里看一下例子展示：
1）当文字字数比较少的时候：
2）当文字字数比较多的时候：
3）当文字字数再多的时候：
可以看出来：当文字没有填充TextView完全时显示的就是默认的字体，当文字能够完全填充TextView并且一行显示不下时，他会默认的缩小文字的字体，当文字再多时，他会默认在末尾省略。。。
原理：
查看该开源项目的具体实现：
里面的AutoTextView就是具体实现动态更改TextView字体大小的组件，大概看了一下源码，主要是自定义TextView并继承系统的TextView，然后在绘制组件的时候根据getMaxLines方法获取内容的行数若内容的行数大于1，则缩小文字的字体，然后在尝试获取getMaxLines方法，若内容的行数还是大于1，则据悉缩小文字的字体，直到内容能够一行显示或者是字体缩小大一定的大小，这时候若缩小到一定的大小还是不能一行显示，则尾部省略。。。
产品中有一个需求是根据TextVIew显示的内容的大小设置字体大小： // 优惠券金额为三位数时，更改字体大小 if (couponAmunt.length() &gt;= 3) { holder.favourItemPriceUnit.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15); holder.favourItemPrice.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 30); } else { holder.favourItemPrice.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 36); holder.favourItemPriceUnit.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18); } 在帮TextView控件设置大小的时候，发现和在XML中用PX设置的不一样；由于我们在设置字体大小的时候统一使用的是DP为单位，以前一直以为setTextSize(int size)这里的size参数是以px为单位的，所以这里使用的是setText(dp2px)，但是现实的结果一直偏大，后来查询该方法的源码： /** * Set the default text size to the given value, interpreted as "scaled * pixel" units. This size is adjusted based on the current density and * user font size preference. * * @param size The scaled pixel size.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d13ba2370da8ab04099e6e765033f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3e54f87b4c670743cfefc03ca88a62/" rel="bookmark">
			Sqlite3 database file is locked 解决办法 与sqlite_reset()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有几天没有更新博文了，这几天参加公司的年会，泡温泉，滑雪，玩得不亦乐乎。作为年会后的第一个工作日，自己终于完成了持续多日的sqlite3数据库测试并解决其中的一个问题，就是database file is locked。
在我们的产品中，我们会new出一个database对象，然后调用open方法打开指定路径下的数据库，如果没有这个数据库，就会自动给用户创建一个。这也是sqlite3 db.sqlite 命令的逻辑。在测试中我发现，如果我调用了sqlite3的函数
sqlite_prepare,sqlite_reset,sqlite_step,sqlite_column_text(),方法后，该数据表就不能被删除了，报的错误码是5，代表database file被锁住了。未解决这个问题，首先就是求救互联网，但是网上很多都是关于多线程的问题，在我们的项目不存在多线程的问题。自己只好自己慢慢一个一个排除。
终于在一个偶然的测试中，自己发现是在查询结束后，没有进行sqlite_reset(),当我进行reset 之后，就可以删除该数据表了。查询的顺序就变为了sqlite_prepare,sqlite_reset,sqlite_step,sqlite_column_text(),sqlite_reset()有人可能会疑问，为什么没有在查询完后调用sqlite_finalize()。在我们的项目中，结果集存在于一个变量中，设计这个变量能不断调用，所以没有选择释放这个查询结果集。而释放结果集的工作我们放到了close函数中，这是我们自己封装的函数，在释放这个结果集资源的同事，断开连接。
为什么调用reset（）之后就可以删除了呢，自己也没有答案，需要后面进一步的研究，在这里贴出来，以供大家查询。
解决这个bug之后，自己突然想起以前做生物实验时候，一步步验证排除实验不确定因素的过程。当然这个过程比我上面提到的过程复杂多了。万物还是很多通性的呀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac70d5433555b846fcc92661c2cb0ce3/" rel="bookmark">
			Linux串口通信VTIME和VMIN的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		options.c_cc[VTIME] = 0; /* 设置超时0 seconds*/ options.c_cc[VMIN] = 13; /* define the minimum bytes data to be readed*/
这两句话决定了对串口读取的函数read()的一些功能。我将着重介绍一下他们对read()函数的影响。
其中cc_t c_line只有在一些特殊的系统程序(比如，设置通过tty设备来通信的网络协议)中才会用。在数组c_cc中有两个下标(VTIME和VMIN)对应的元素不是控制符，并且只是在原始模式下有效。只有在原始模式下，他们决定了read()函数在什么时候返回。在标准模式下，除非设置了O_NONBLOCK选项，否则只有当遇到文件结束符或各行的字符都已经编辑完毕后才返回。
控制符VTIME和VMIN之间有着复杂的关系。VTIME定义要求等待的零到几百毫秒的时间量(通常是一个8位的unsigned char变量，取值不能大于cc_t)。VMIN定义了要求等待的最小字节数(不是要求读的字节数——read()的第三个参数才是指定要求读的最大字节数)，这个字节数可能是0。
l 如果VTIME取0，VMIN定义了要求等待读取的最小字节数。函数read()只有在读取了VMIN个字节的数据或者收到一个信号的时候才返回。
l 如果VMIN取0，VTIME定义了即使没有数据可以读取，read()函数返回前也要等待几百毫秒的时间量。这时，read()函数不需要像其通常情况那样要遇到一个文件结束标志才返回0。
l 如果VTIME和VMIN都不取0，VTIME定义的是当接收到第一个字节的数据后开始计算等待的时间量。如果当调用read函数时可以得到数据，计时器马上开始计时。如果当调用read函数时还没有任何数据可读，则等接收到第一个字节的数据后，计时器开始计时。函数read可能会在读取到VMIN个字节的数据后返回，也可能在计时完毕后返回，这主要取决于哪个条件首先实现。不过函数至少会读取到一个字节的数据，因为计时器是在读取到第一个数据时开始计时的。
l 如果VTIME和VMIN都取0，即使读取不到任何数据，函数read也会立即返回。同时，返回值0表示read函数不需要等待文件结束标志就返回了。
文章摘自：http://www.educity.cn/linux/1580699.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e063ffbfbd5cc22e04fb7e50af39d7a5/" rel="bookmark">
			JavaScript 中&#34;$&#34;的含义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 引子 在JavaScript中,我们或许会写下这样的代码
$(document).ready(function(){ $("p").mouseover(function(){ $("p").css("background-color","#333"); });}); 这个mouseover事件中的"$",这个"$"是什么含义呢?这个时候如果我不想用 $ 了，该怎么更改？ 也就是说我不想用 jQuery 了，也不考虑多浏览器支持的情况下，如果做修改呢？下面将简要介绍一下。
"$"符号的起源 $ 是合法的IdentifierStart 就是可以作为变量名,函数名,形参的第一个字符. 就如同 _ 下划线一样. 但.$最初在ES3时代.在标准中,是建议保留使用的.保留给机器自动生成代码使用.比如以javascript作为编译目标语言的语言等等. 这本来是一个弱约束的公约. 但随着jquery等,没有遵守这个公约的库大行其道. 这个弱约束就名存实亡了. 到了ES5时代.这个保留使用的建议, 也被取消了. 所以你问 $是什么. _是什么,他就是什么. 不同的之处在于 他是jquery崛起的历史见证.
"$"符号的定义 $符号在JS里是可以当做identifier的，也就是说可以当成变量名称，或者函数名称，并且可以打头（不同于一些语言比如c什么的只能用字母打头后接字母或者数字），甚至可以单独使用所以就明了了，$只是一个变量或者函数这里的话$就是jQuery的对象了，严格的说它应该是jQuery对象的构造函数你可以查看一下jQuery的源代码，开头大概是这么写的：
$ = (function(){ //jQuery define.. return jQuery; })(window,undefined); 用$这个特殊符号做为框架标识的也不止jQuery，其它也有不少的，很早的时候有人喜欢把document.getElementById这个函数封装在$这个函数里以方便调用。 替换变量 $ 的 jQuery 控制权 noConflict() 方法让渡变量 $ 的 jQuery 控制权。 该方法释放 jQuery 对 $ 变量的控制。 该方法也可用于为 jQuery 变量规定新的自定义名称。 提示：在其他 JavaScript 库为其函数使用 $ 时，该方法很有用。
过渡jquery变量。 $.noConflict();//直接释放掉$的占用 var jq = $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e063ffbfbd5cc22e04fb7e50af39d7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ad57a9046deb74c11b8a6953fc852c/" rel="bookmark">
			linux sleep(0)与usleep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sleep(0)是让出CPU
http://blog.csdn.net/lengzijian/article/details/9092367
在我的一个项目中，因为需要与串口通信，每次读写都需要延时usleep(1000)=1ms，但是通信量非常大，每一次工作这样的通信大概有300次左右，这样算下耗时应该是300ms左右。
但是通过strace打印出系统函数调用发现实际接近900ms，仔细观察strace日志才发现，每次usleep(1000000)其实都延时了2ms，之后上网搜索才发现usleep是不精确的。
[cpp] view plain copy print ? 1.sleep的精度是秒 2.usleep的精度是微妙，不精确 3.select的精度是微妙，精确 struct timeval delay; delay.tv_sec = 0; delay.tv_usec = 20 * 1000; // 20 ms select(0, NULL, NULL, NULL, &amp;delay); 4.nanosleep的精度是纳秒，不精确 unix、linux系统尽量不要使用usleep和sleep而应该使用nanosleep，使用nanosleep应注意判断返回值和错误代码，否则容易造成cpu占用率100%。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bce042682e9f12d297cb593292a9e1/" rel="bookmark">
			Visual Studio CUDA文件高亮设置 win10&#43;VS2015&#43;CUDA7.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		万用教程：http://ju.outofmemory.cn/entry/97435
VS2015 + Visual Assist X下载：http://pan.baidu.com/s/1k18se
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f803c995707256313295c285c30e5300/" rel="bookmark">
			华为机试——字符串中出现相同最长字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一行字符串，找出其中出现的相同且长度最长的字符串，输出它及其首字符的位置 例如“yyabcdabjcabceg”,输出结果应该为abc和3, 原理：查找的最长子串长度从length()-1开始，i为子串的长度，j为子串的起始位置，通过正序和逆序查找比较看子串是否重复出现在字符串中不同位置来找到最长的重复子串 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str,tep; cout&lt;&lt;"请输入字符串:"&lt;&lt;endl; cin&gt;&gt;str; for(int i=str.length()-1;i&gt;1;i--)//子串的长度 { for(int j=0;j&lt;str.length();j++)//子串起始位置 { if(j+i&lt;=str.length()) { size_t t=0; size_t num=0; tep=str.substr(j,i);//从大到小取子串 t=str.find(tep);//正序查找 num=str.rfind(tep);//逆序查找 if(t!=num) //如果两次查找位置不一致说明存在重复子串 { cout&lt;&lt;tep&lt;&lt;" "&lt;&lt;t+1&lt;&lt;endl; //输出子串及位置 return 0; } } } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552de27f5b85ac5734a7b090ad6c15b1/" rel="bookmark">
			python数字图像处理（1）：环境安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一提到数字图像处理编程，可能大多数人就会想到matlab，但matlab也有自身的缺点：
1、不开源，价格贵
2、软件容量大。一般3G以上，高版本甚至达5G以上。
3、只能做研究，不易转化成软件。
因此，我们这里使用python这个脚本语言来进行数字图像处理。
要使用python，必须先安装python，一般是2.7版本以上，不管是在windows系统，还是linux系统，安装都是非常简单的。
要使用python进行各种开发和科学计算，还需要安装对应的包。这和matlab非常相似，只是matlab里面叫工具箱（toolbox)，而python里面叫库或包。基于python脚本语言开发的数字图片处理包，其实很多，比如PIL,Pillow, opencv, scikit-image等。
对比这些包，PIL和Pillow只提供最基础的数字图像处理，功能有限；opencv实际上是一个c++库，只是提供了python接口，更新速度非常慢。到现在python都发展到了3.5版本，而opencv只支持到python 2.7版本；scikit-image是基于scipy的一款图像处理包，它将图片作为numpy数组进行处理，正好与matlab一样，因此，我们最终选择scikit-image进行数字图像处理。
一、需要的安装包
因为scikit-image是基于scipy进行运算的，因此安装numpy和scipy是肯定的。要进行图片的显示，还需要安装matplotlib包，综合起来，需要的包有：
Python &gt;= 2.6 Numpy &gt;= 1.6.1 Cython &gt;= 0.21 Six &gt;=1.4 SciPy &gt;=0.9 Matplotlib &gt;= 1.1.0 NetworkX &gt;= 1.8 Pillow &gt;= 1.7.8 dask[array] &gt;= 0.5.0 比较，安装起来非常费事，尤其是scipy，在windows上基本安装不上。 但是不用怕，我们选择一款集成安装环境就行了，在此推荐Anaconda, 它把以上需要的包都集成在了一起，因此我们实际上从头到尾只需要安装Anaconda软件就行了，其它什么都不用装。
二、下载并安装 anaconda
先到https://www.continuum.io/downloads 下载anaconda, 现在的版本有python2.7版本和python3.5版本，下载好对应版本、对应系统的anaconda，它实际上是一个sh脚本文件，大约280M左右。
本系列以windows7+python3.5为例，因此我们下载如下图红框里的版本：
名称为： Anaconda3-2.4.1-Windows-x86_64.exe
是一个可执行的exe文件，下载完成好，直接双击就可以安装了。
在安装的时候，假设我们安装在D盘根目录，如：
并且将两个选项都选上，将安装路径写入环境变量。
然后等待安装完成就可以了。
安装完成后，打开windows的命令提示符：
输入conda list 就可以查询现在安装了哪些库，常用的numpy, scipy名列其中。如果你还有什么包没有安装上，可以运行
conda install *** 来进行安装。（***为需要的包的名称）
如果某个包版本不是最新的，运行 conda update *** 就可以更新了。
三、简单测试 anaconda自带了一款编辑器spyder，我们以后就可以用这款编辑器来编写代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552de27f5b85ac5734a7b090ad6c15b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed9487df589558533cc5f7bc72fe8f8/" rel="bookmark">
			帆软报表FineReport SQLServer数据库连接失败常见解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述
帆软报表FineReport客户端连接SQLServer（2000、2005等），常常会出现如下错误：com.microsoft.sqlserver.jdbc.SQLServerException： 到主机的TCP/IP 连接失败。 该错误可能由如下几个方面导致：
2. URL是否正确
首先确认在定义数据连接那边的URL是否正确（保证IP，端口以及数据库是正确的），如下图：
3. sp4安装包有没有装
这个主要是sqlserver2000，其他版本一般没有这个问题。sqlsp4补丁就是Microsoft SQL Server 2000 Service Pack 4 ，大多数版本为简体中文版。
SP4 包括用于以下 SQL Server 2000 组件的程序包。
数据库组件（下载文件：SQL2000-KB884525-SP4-x86.EXE）：更新 SQL Server 2000 的 32 位数据库组件，包括数据库引擎、复制、客户端连接组件和工具。
Analysis Services 组件（下载文件：SQL2000.AS-KB884525-SP4-x86.EXE）：更新 SQL Server 2000 的 32 位 Analysis Services 组件。
SQL Server 2000 Desktop Engine (MSDE) 组件（下载文件：SQL2000.MSDE-KB884525-SP4-x86.EXE）：对于 SQL Server 2000 的 32 位 MSDE 组件：
安装新的 MSDE 实例；
升级现有 MSDE 实例；
更新使用合并模块的应用程序。
打sp4后一般会出现登陆连接问题，看看SQL的服务有没有运行，没运行就去我的电脑&gt;管理&gt;服务里面，把MSSQLSERVER服务登录的用户名和密码改正确；有运行，进企业管理器，改SQL的登录方式为混合模式，设置sa密码，重新设置一次。 sqlserver 2000 sp3由于有bug，很多服务器打不了补丁，说sa连接失败，所以直接安装sp4升级补丁，升级之前建议先备份数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed9487df589558533cc5f7bc72fe8f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e1b8d92ad3c511544d5e44e4cef761/" rel="bookmark">
			如何通过投掷一枚硬币产生各种概率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一枚均值硬币（fair coin），其概率分布为 [(0,0.5),(1,0.5)] import random def coin(): p = random.random() return 1 if p &lt; 0.5 else 0 产生0.25, 0.75的概率分布 投掷（toss）一枚硬币，正面向上为1，反面向上为0。连续投掷两次，11为1：对应概率为0.25，{10, 01, 00}为0：对应概率为0.75。也即此时的随机变量（rv，random variable） X 为投掷两次的与（and）值。
应用：A, B, C, D的四个选项，用一枚硬币产生每个选项相等的概率，也即各位0.25.
A：11 B：10 C：01 D：00 def prob1(): a, b = coin(), coin() if (a &amp; b) == 1: return 1 else: return 0 测试：
import collections cnt = collections.defaultdict(int) N = 10**5 for i in range(N): cnt[prob1()] += 1 for n in cnt: print(n, cnt[n]/N) # 0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e1b8d92ad3c511544d5e44e4cef761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66451a50f01ca240b2a8a7736013915e/" rel="bookmark">
			OpenCV学习笔记大集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：
OpenCV学习笔记大集锦 – 视觉机器人
http://www.cvrobot.net/collect-opencv-resource-learn-study-note-chinese/
整理了我所了解的有关OpenCV的学习笔记、原理分析、使用例程等相关的博文。排序不分先后，随机整理的。如果有好的资源，也欢迎介绍和分享。
1：OpenCV学习笔记 作者：CSDN
数量：55篇博文
网址：http://blog.csdn.net/column/details/opencv-manual.html
2：部分OpenCV的函数解读和原理解读 作者：梦想腾飞
数量：20篇博文
网址：http://blog.csdn.net/xidianzhimeng/article/category/1593859
3： OpenCV入门指南 作者： MoreWindows
数量： 13篇博文
网址：http://blog.csdn.net/morewindows/article/category/1291764
4： OpenCV成长和进阶之路 作者： Ronny的技术成长之路
数量： 12篇博文
网址：http://www.cnblogs.com/ronny/category/366234.html
5： OpenCV入门教程 作者： 毛星云（浅墨）的专栏，《OpenCV3编程入门》作者
数量： 18篇博文
网址：http://blog.csdn.net/zhmxy555/article/category/1923021
6： 基础学习笔记之opencv 作者： tornadomeet
数量： 24篇博文
网址：http://www.cnblogs.com/tornadomeet/tag/opencv/
7： OpenCV学习笔记 作者： 邹宇华
数量： 32篇博文
网址：http://blog.csdn.net/chenyusiyuan/article/category/610983
8： CVPR|OpenCV|图像检索|视频检索 作者： icvpr
数量： 25篇博文
网址：http://blog.csdn.net/icvpr/article/category/1139524
9： 学习OpenCV 作者： 小熊不去实验室
数量： 81篇博文
网址：http://blog.csdn.net/sangni007/article/category/1106771
10： OpenCV 作者： 羽凌寒
数量： 47篇博文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66451a50f01ca240b2a8a7736013915e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d0963af818b522f2acd3afea5d7bde/" rel="bookmark">
			递归应用---倒序输出数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //用递归函数逆序输出数组中的10个元素 。 #include&lt;stdio.h&gt; void fun(int a[], int i) { if (i &gt; 0) {	//不可去掉if后的花括号。否则，fun(a,--i);语句会导致本函数成为死循环 。 printf_s("%d ", a[i - 1]); fun(a, --i);	//注意这里是--i } } void main() { int a[10]; for (int i = 0; i &lt; 10; i++) { a[i] = i; } printf_s("当前数组为： "); for (int i = 0; i &lt; 10; i++) { printf_s("%d ", a[i]); } printf_s("\n倒序输出： "); fun(a, 10); printf_s("\n"); system("pause"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fe8405d6596e315c800e753ff70f6f/" rel="bookmark">
			深刻理解Live555源码，掌握这把RTSP，RTP的瑞士军刀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我无意评价Live555的源码是否优雅易懂，但对于我这种C++设计模式应用不熟的IT老兵，还是很难直接通过阅读源码深刻清晰，一目了然的理解其中的调用逻辑。Live555中关于RTSP的Session，SubSession的概念，以及FramedSource和Sink的抽象都很不错的。但对于其任务单步调用机制，以及如何读取一帧数据及时发出一帧数据的全部逻辑， 真不容易得到清晰的处理逻辑。实践出真知，笔者本文就介绍一种通过运行时堆栈信息迅速理解关键代码和关键逻辑的方法。
先来观察本文尾部的GDB打印的堆栈信息，是笔者在实际开发中在Live555中扩展了mp4文件格式的支持，凡是ffmpeg_server目录下的的都是我的私有源码独立实现，不要刻意追究源码，本文教的是方法。该堆栈是Live555服务器接收到PLAY请求后，发送第1帧数据时的状态。
1.查看堆栈第27层到第0层堆栈，首先我们关注的是getNextFrame函数，该函数是FramedSource的public函数，提供给所有派生类构造层层回调逻辑的函数，通过传入几个回调函数和回调指针。该函数在第3层堆栈，第10层堆栈，第12层堆栈有调用到。
2.其次需要关注的是doGetNextFrame函数，该函数是FramedSource的虚函数，这个函数是在前面的getNextFrame的实现里被调用的。该函数在第2层，第9层，第11层有调用。这里要提醒一下，堆栈的函数调用顺序是由高到底层层调用进来，最后执行到当前的0层的。
抓住了这2个关键函数，然后通过观察（可以在编辑器里查找）传入这2个函数的指针（afterGettingClientData）和this指针的地址值，就会恍然大悟的。其他的我不多说了，通过指针值可以知道传入的是哪一层的对象的指针。
3. 另外一个函数是getNextFrame函数的传入参数，也即回调函数afterGettingFunc需要关注，该回调函数（一般是FramedSource或其派生类中的静态函数(声明为static)）是在读取完一帧数据后回调的，跟第2点提到的afterGettingClientData指针配合使用的。
Live555的读取一帧，处理，发送一帧的逻辑就是通过以上3个函数的配套调用实现的。
最后还有一个逻辑，需要关注，这个逻辑在堆栈信息中没有，就是Live555在何时发送下一帧的呢？ 答案是通过【定时器任务】驱动。可以在源码中搜索以下语句，发现调用的地方很稀少， 这就是发送下一帧的关键代码，我们牵住问题的牛鼻子了。
envir ( ). taskScheduler ( ). scheduleDelayedTask 这个就是增加一个定时器的语句，有几个需要发送下一帧地方用到了以上调用，这也是Live555发送任务调度的关键所在。
本文堆栈所用到的发送下一帧的逻辑在void MultiFramedRTPSink::sendPacketIfNecessary()函数的尾部，语句如下：
// Delay this amount of time: nextTask ( ) = envir ( ). taskScheduler ( ). scheduleDelayedTask (uSecondsToGo, (TaskFunc * )sendNext, this ) ; (gdb ) info s #0 FfmpegDemux::ContinueReadProcessing (this=0x41a123d8) at ffmpeg_server/ffmpeg_demux.cpp:629 #1 0x000b27e4 in FfmpegDemux::GetNextFrame (this=0x41a123d8, stream_id=0 '\000', to=0x41d00008 "", max_size=2048000, AfterGettingFunc = 0xb639c &lt;FfmpegDemuxedElementaryStream :: AfterGettingFrame ( void *, unsigned int , unsigned int , timeval , unsigned int ) &gt;, after_getting_client_data = 0x41a7c338 , OnCloseFunc = 0xd76a4 &lt;FramedSource :: handleClosure ( void * ) &gt;, on_close_client_data = 0x41a7c338 , frameHandlerFunc = 0 ) at ffmpeg_server /ffmpeg_demux.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fe8405d6596e315c800e753ff70f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cce61eb8f98765670f48fc7ecfabf63d/" rel="bookmark">
			程序员必知之浮点数运算原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员必知之浮点数运算原理详解 导读：浮点数运算是一个非常有技术含量的话题，不太容易掌握。许多程序员都不清楚使用==操作符比较float/double类型的话到底出现什么问题。 许多人使用float/double进行货币计算时经常会犯错。这篇文章是这一系列中的精华，所有的软件开发人员都应该读一下。
随着你经验的增长，你肯定 想去深入了解一些常见的东西的细节，浮点数运算就是其中之一。
1. 什么是浮点数?
在计算机系统的发展过程中，曾经提出过多种方法表达实数。
【1】典型的比如相对于浮点数的定点数（Fixed Point Number）。在这种表达方式中，小数点固定的位于实数所有数字中间的某个位置。货币的表达就可以使用这种方式，比如 99.00 或者 00.99 可以用于表达具有四位精度（Precision），小数点后有两位的货币值。由于小数点位置固定，所以可以直接用四位数值来表达相应的数值。SQL 中的 NUMBER 数据类型就是利用定点数来定义的。
【2】还有一种提议的表达方式为有理数表达方式，即用两个整数的比值来表达实数。
定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。最终，绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。
【3】浮点数表达方式， 这种表达方式利用科学计数法来表达实数，即用一个尾数（Mantissa ），一个基数（Base），一个指数（Exponent）以及一个表示正负的符号来表达实数。比如 123.45 用十进制科学计数法可以表达为 1.2345 × 102 ，其中 1.2345 为尾数，10 为基数，2 为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。提示: 尾数有时也称为有效数字（Significand）。尾数实际上是有效数字的非正式说法。
同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 101，0.12345 × 103 或者 1.2345 × 102。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。规范的（Normalized）浮点数表达方式具有如下形式：
d.dd...d × βe , (0 ≤ di &lt; β)
其中 d.dd...d 即尾数，β 为基数，e 为指数。尾数中数字的个数称为精度，在本文中用 p（presion） 来表示。每个数字 d 介于 0 和基数β之间，包括 0。小数点左侧的数字不为 0。
（1）　基于规范表达的浮点数对应的具体值可由下面的表达式计算而得：(p是精度个数)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cce61eb8f98765670f48fc7ecfabf63d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596fac0683eb5c64813a63b93f172f49/" rel="bookmark">
			C语言结构体 别名定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前一直有这么个误区。现在解决了。
C语言给结构体定义别名用typedef关键字操作，就两种情况：
1、
给结构体起一个别名，如：
typedef struct ABC{
...
}S;
这就为结构体ABC定义了一个别名S。以后写S x；就等价于写struct ABC x 。
2、
给结构体指针起一个别名，如：
typedef struct ABC{
...
}* PS;
这就为结构体指针ABC * 定义了一个别名PS。以后写PS pt ； 就等价于写struct ABC *pt 。
注意！！这里是用typedef给struct ABC{...} *起一个别名PS，而不是给struct ABC{...}起一个别名*PS
后者是说不通的，起码的错误是标识符不可能以*开头！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc9c7e1f1b2c8bda1cbadb6c47e63ff/" rel="bookmark">
			Cleanup failed to process the following paths错误的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：朱金灿
来源：http://blog.csdn.net/clever101
在使用TortoiseSVN工具执行Cleanup操作时经常出现Cleanup failed to process the following paths的错误，具体如下图：
网上搜索了一下，找到了解决办法：
TortoiseSVN客户端1.7版以前的加锁文件时一个lock后缀的文件，直接在报错目录的.svn目录下删除即可。
TortoiseSVN客户端1.7版以前（含1.7版本）的加锁信息是一条记录放在报错目录下的.db文件里面，用可以SQLite文件的工具将改文件打开，然后删除那条lock记录即可。
具体是如果你想用SQLite文件可视化工具，可以安装SQLiteExpert Professional工具。安装好SQLiteExpert Professional工具，找到svn目录下的wc.db文件，如下图：
打开wc.db文件，删除wc_lock和work_queue两张表下的所有记录，具体如下图：
如果你想用命令行操作，可以是下载sqlite3.exe 放到 .svn 目录下，启动命令行，敲入命令：
sqlite3.exe wc.db
这时，进到了sqlite的命令行环境，可以操作该数据库了，首先我们输入命令：
.tables
将该数据库中的表都显示出来，我们需要关注的是 wc_lock 和 work_queue，因为关于操作的cleanup和lock的信息是保存在这2个表里。需要的话，可以使用 select *from wc_lock;来查看表中的信息是否为之前操作对应的文件或目录，如果这2张表存在数据那么svn就无法进行后续的操作。
很简单，你只要把这2张表清空即可，命令很简单：
delete from wc_lock;
delete from work_queue;
另外前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。
参考文献：
1. 如何搞定SVN目录的cleanup问题和lock问题
2. SVN：cleanup failed to process thefollowing paths 错误的解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe6282e7c0ccfd334c3c8a18d33979a/" rel="bookmark">
			对于汇编代码pushl %ebp      movl %esp,%ebp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课本（ P109 - P110 ）
源程序代码如下：
int simple(int *xp, int y)
{
int t = *xp + y;
*xp = t;
return t;
}​
汇编代码如下：
simple:
pushl %e bp //save frame pointer
movl %e sp​​, %e bp //create new frame pointer
movl 8(%e bp), %e dx //retrieve xp movl 12(%e bp), %e ax //retrieve y
addl (%e dx), %e ax //add *xp to get t(这里完成了把t作为返回值)
movl %e ax, (%e dx) //store t at xp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe6282e7c0ccfd334c3c8a18d33979a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bb2917c45df981c856c89eb929f48e/" rel="bookmark">
			关于C&#43;&#43;智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通指针到智能指针的转换 int* iPtr = new int(42); shared_ptr&lt;int&gt; p(iPtr); 智能指针到普通指针的转换 int* pI = p.get(); 注意的地方： 那就是不要将智能指针与普通指针混用。如果项目允许，坚持使用智能指针，避免原生指针。 智能指针与普通指针需要特别特别特别的小心翼翼，比如以下的情况。 1. 普通指针到智能指针的问题 void f(shared_ptr&lt;int&gt; ptr) //增加引用计数 { // do something... } //销毁ptr，减少引用计数 我们有如下的代码： int* iPtr = new int(42); f(shared_ptr&lt;int&gt;(iPtr)); int value = *iPtr; // Error! iPtr指针指向的内容已经被释放 因为在这儿，你将普通指针赋予给了一个临时的智能指针，当调用f函数完毕后，此临时智能指针的生命周期结束，然后减少引用计数，归为0，于是，内存释放！ 而这儿的更改方法是一直使用智能指针： auto p = make_shared&lt;int&gt;(42); // 初始化的引用计数为1 f(p); // 拷贝后增加为2，销毁ptr减少1，然后变为1 int value = *p; //引用计数为1 2. 智能指针到普通指针的问题 auto p = make_shared&lt;int&gt;(42); int* iPtr = p.get(); { shared_ptr&lt;int&gt;(iPtr); } int value = *p; // Error!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1bb2917c45df981c856c89eb929f48e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de6cf49b2fb51c52165d2cefd3d04ac/" rel="bookmark">
			CMMI-DEV_v1.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司在申请CMMI3级的资质,自己的身份是评估组成员（Appraisal Team Member，简称ATM），ATM主要参加文档评审及人员访谈，完成证据的记录和收集(包括文档证据和访谈证据)，填写PIID表，根据所收集的证据参与评估结果的讨论和认定。
在CMMI3主要对CMMI-DEV_v1.3进行了系统的学习。总结如下：
能力成熟度模型（CapabilityMaturity Model，简称CMM），该模型由美国卡内基-梅隆大学的软件工程研究所（简称SEI）受美国国防部委托，于1991年研究制定，最初的主要目的是为了评价美国国防部的软件合同承包组织的能力，后因为在软件企业应用CMM实施过程改进取得较大的成功，便在全世界范围内广泛使用。 能力成熟度模型集成（Capability Maturity Model Integration，简称CMMI），是SEI于2000年发布的CMM的新版本。CMMI发展到现在，共包含了三个模型，分别是CMMI-DEV(开发模型),CMMI-SVC（服务模型）以及CMMI-ACQ（采购模型）。
软件过程及能力成熟度评估（简称SPCA），是软件过程能力评估和软件能力成熟度评估的统称，是中国信息产业部会同国家认证认可监督委员会在充分研究了国际软件评估体制（CMM、CMMI、ISO/IEC TR15504、ISO9000、TL 9000），特别是美国卡内基-梅隆大学SEI所建立的软件能力成熟度模型CMMI，并考虑了国内软件产业实际情况之后所建立的软件评估体系。已于2001年5月1日发布实施。
CMMI-DEV_v1.3的5个等级22个过程域
1.初始级（initial）--&gt;2.可重复级（Repeatable）--&gt;3.已定义级（Defined）--&gt;4.量化管理级（Managed）--&gt;5.优化管理级（Optimizing）
已定义级：开发过程，包括技术工作和管理工作（工程管理，项目管理），均已实现标准化、文档化（过程管理）。建立了完善的培训制度（培训）和专家评审制度（确认），全部技术活动和管理活动均可控制（支持配置，项目监控），对项目进行中的过程、岗位和职责均有共同的理解（承诺）。
2. 过程类型分为:
工程管理（REQM/RD/TS/PI/VER/VAR/RSKM）、项目管理(PP/PMC/SAM/IPM/QPM)、支持(MA/PPQA/CM/DAR/CAR)、过程管理(OPF/OPD/OT/OPP/OPM)
序号
CMMI等级
中文名称 英文名称 缩写
过程类型
1
2级
需求管理
Requirements Management REQM
工程
2
2级
项目规划
Project Planning
PP 项目管理
3
2级
项目监控
Project Monitoring and Control
PMC
项目管理
4
2级
供应商协议管理
Supplier Agreement Management
SAM 项目管理
5
2级
度量分析 Measurement and Analysis MA 支持
6
2级
过程和产品质量保证
Process and Product Quality Assurance
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de6cf49b2fb51c52165d2cefd3d04ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/490/">«</a>
	<span class="pagination__item pagination__item--current">491/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/492/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>