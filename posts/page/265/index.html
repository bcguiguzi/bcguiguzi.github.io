<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f943edd63260f030314a2fd6cd925b/" rel="bookmark">
			USB移动存储设备上安装Kali Linux（独立系统 非Live 非虚拟机）Standalone Kali Linux &#43; grub2 &#43; luks加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文分享的是在USB移动设备上安装Kali Linux独立系统
非Live版！ 非虚拟机版！
非Live版！ 非虚拟机版！
非Live版！ 非虚拟机版！
这里的USB设备包括U盘、移动硬盘（包括NVMe）
独立系统指的是有完整的引导的可以直接运行的Kali Linux完整系统，简单地说就是不需要任何其它系统、虚拟机也可以直接运行并可保存更改的Kali Linux
网上现有大部分教程都是虚拟机版或Live版
如果想装Live版或者虚拟机版请转到其它教程
参考https://www.kali.org/docs/usb/usb-standalone-encrypted/
注：本教程很多部分参考上方的网页（kali官网教程），但是其部分细节没表达清楚，问题处理较简单
本教程的所有过程都经过本人测试，并在两个硬件（King Stone 128G的U盘和西部数据的500G的NVMe移动硬盘）上测试可用，但不保证普适
安装过程比较折腾，易操作错误，但结果比较满意，所以写下此教程
什么是Kali Linux独立系统 (Standalone Kali Linux)？ Kali Linux是一个系统（废话），有很多渗透测试工具
（更多关于Kali Linux的详细可以去官网或者任意搜索引擎搜索）
先简单介绍一下几个不同版本的区别：
纯硬盘版 (Bare Metal)：在电脑的硬盘上安装，修改引导文件，可以是双系统或者替代原系统；虚拟机版 (Virtual Machines)：在已有的系统上的虚拟机软件（如：VMware、VirtualBox）上安装；ARM版 (ARM)：在支持ARM指令集的机器或虚拟机上安装；安卓手机版 (Mobile)：又名NetHunter，是一个改过的安卓系统，与Kali Linux不是一个东西；云端版 (Cloud)：一个云端镜像，直接可以装在云服务器上；容器版 (Container)：Docker或LXC/LXD的容器，容器的概念不做介绍；Live版 (Live Boot)：一个镜像文件，用于做USB ROM（只读），即不可改，所有对系统的更改都不会保存；WSL版 (WSL)：主要是Windows的WSL，是一个Windows的子系统，比虚拟机更轻便，但有诸多限制，具体不做介绍；独立版 (Standalone)： 可移动的纯硬盘版，即装在可移动存储设备上安装的纯系统
注：Standalone版在官网上没有作为一个单独的版本，分类在Kali-USB，但其实可以认为是特殊安装的纯硬盘版 小结：
这里只讨论独立版和几个常见的版本：纯硬盘版、虚拟机版、Live版、WSL版
版本不更改原系统引导不需要已有系统支持不需要虚拟机支持可保存更改可移动纯硬盘版✘✓✓✓✘虚拟机版✓✘✘✓✓Live版✓✓✓✘✓WSL版✓✘✘✓✘独立版✓✓✓✓✓ 注：上表所述特性可能不严谨，如：可移动指可简单地移动，备份恢复等不考虑，操作不当造成的更改不考虑
可见Kali Linux独立版可以认为是 可移动的纯硬盘版 或 可保存修改的Live版
本教程分享的是安装Kali Linux独立版
本人安装使用经历 （本章可以跳过，但如果安装出错可以再来看看）
本教程的安装环境是刃9000K台式机，两张普通32G U盘，一张500G NVMe SSD移动硬盘
测试环境是刃9000K台式机和Surface Pro 7 64位 i7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f943edd63260f030314a2fd6cd925b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0140941b4d84fc5f79b1f09f063dfc46/" rel="bookmark">
			react前端提交表单数据至后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;form method='post'&gt; &lt;p&gt;id&lt;/p&gt; &lt;input type="name" name="name" onChange={this.handleChange}/&gt; &lt;p&gt;password&lt;/p&gt; &lt;input type="password" name="password" onChange={this.handleChange}/&gt; &lt;br /&gt; &lt;button onClick={this.onSubmit}&gt;submit&lt;/button&gt; &lt;/form&gt; onSubmit=()=&gt;{ let queryStringRequest = new Request('http://localhost:3000/register', { method: 'post', body : this.state }) fetch(queryStringRequest).then(res =&gt; { console.log(res) }) } 后端代码
const express = require('express') const bodyParser = require('body-parser'); const app = express(); const registerRouter = express.Router(); /* 为了使用req.body*/ app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.use((req,res,next)=&gt;{ console.log("有人请求服务器") next() }) app.use('/register', registerRouter); registerRouter.post("/", function (req, res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0140941b4d84fc5f79b1f09f063dfc46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fd6df247d6a5f24bcaee863ffa9a01/" rel="bookmark">
			试题 算法训练 车的放置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 试题 算法训练 车的放置 问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
包含一个正整数n
输出格式
一个整数，表示放置车的方法数
样例输入
2
样例输出
7
数据规模和约定
n&lt;=8
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
思路
象棋中的车的特点：不要放在同一行或者同一列。
那么搜索时某一行可以不放象棋或者放象棋。
#include&lt;bits/stdc++.h&gt; using namespace std; int n; int ans=1;//最初答案为一，因为一个车都不放为1种 bool vis[10];//记录某一列有没有放象棋 void dfs(int step){//遍历搜索到了某一行 if(step&gt;n) return;//如果搜到最后一行搜完了 for(int i=1;i&lt;=n;i++){//遍历step行的每一列 if(!vis[i]){//如果这一列没有放 vis[i]=true; ans++; dfs(step+1);//继续向下遍历下一行 vis[i]=false; } } dfs(step+1);//step行也可以不放，从step+1行开始放 } int main(){ cin&gt;&gt;n; dfs(1);//从第一行开始搜索 cout&lt;&lt;ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3063eaae9fb663107f6160b172e76692/" rel="bookmark">
			Mybatis 源码深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、手写Mybatis二、Mybatis高级应用三、Mybatis源码1. MyBatis初始化过程2. MyBatis执行Sql过程3. MyBatis执行器executor4. MyBatis StatementHandler5. MyBatis的mapper代理方式getMapper()6. MyBatis的invoke方法7. 二级缓存7.1 cache标签7.2 执行流程7.3 生效机制7.4 刷新 8. 延迟加载8.1 如何应用8.1.1 局部延迟加载8.1.2 全局延迟加载 8.2 实现原理8.3 延迟加载源码-创建代理对象8.4 延迟加载源码-invoke方法执行 一、手写Mybatis 篇幅限制，我将其放在这篇文章中：https://blog.csdn.net/grd_java/article/details/122894621 二、Mybatis高级应用 篇幅限制，我将其放在这篇文章中：https://blog.csdn.net/grd_java/article/details/122927196 三、Mybatis源码 Mybatis架构原理 API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操作数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。MyBatis和数据库的交互有两种方式： 使用传统MyBatis提供的API使用Mapper代理的方式 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。主要目的是根据调用的请求完成一次数据库操作基础支持层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的，将他们抽取出来作为最基础的组件，为上层数据处理层提供最基础的支撑 主要构件 构件描述SqlSession作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能ExecutorMyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护StatementHandler封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数、将Statement结果集转换成List集合ParameterHandler负责对用户传递的参数转换成JDBC Statement所需要的参数ResultSetHandler负责将JDBC返回的ResultSet结果集对象转换成List类型集合TypeHandler负责Java数据类型和jdbc数据类型之间的映射和转换MappedStatement维护一条&lt; select/update/delete/insert&gt;结点的封装SqlSource负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回BoundSql表示动态生成的SQL语句以及相应的参数信息 总体流程 加载配置并初始化(触发条件:加载配置文件) 配置来源为配置文件（核心配置文件.xml，mapper.xml），Java代码中的注解,将主配置文件内容解析封装到Configuration，将sql的配置信息加载成为一个mappedstatement对象，存储在内存之中。 接收调用请求（触发条件：调用MyBatis提供的API） 传入参数：SQL的ID和传入的参数对象处理过程：将请求传递给下层的请求处理层进行处理 处理操作请求（触发条件：API接口层传递请求过来，包括SQL的ID和参数对象） 根据SQL的ID查找对应的MappedStatement对象根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。释放连接资源。 返回处理结果，将最终处理结果返回 1. MyBatis初始化过程 结论 Resources.getResourceAsStream(“sqlMapConfig.xml”);加载配置文件为字节输入了SqlSessionFactoryBuilder().build(resourceAsSteam);使用构建者模式，构建SqlSessionFactory对象构建SqlSessionFactory对象，需要Configuration对象（MyBatis核心配置类），所以通过解析XML文件，将配置信息全部封装到Configuration对象中。其中&lt; mapper&gt;标签映射的mapper.xml的映射文件内容，会封装到Configuration中的mappedStatements容器中mappedStatements是一个map，key是namespace.id，value是MappedStatement对象，此对象用于封装&lt;select/insert…&gt;这些标签构建好Configuration后，使用Configuration作为参数，构建了SqlSession工厂SqlSession工厂可以生产SqlSession对象，这是后面的步骤，到此初始化完成 传统方式 一般我们使用mybatis第一句代码就是读取xml核心配置文件,读成字节输入流 InputStream resourceAsSteam = Resources.getResourceAsStream("sqlMapConfig.xml"); 第二句代码，就是解析字节输入流（配置文件），封装Configuration对象，创建DefaultSqlSessionFactory对象，mybatis使用构建者设计模式，经过多重重载，我们只看最终执行逻辑代码 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsSteam); build()方法，发现创建了XMLConfigBuilder对象，然后调用了parse()方法，又是构建者模式，parse()就是建造方法，构建Configuration对象，return build(parser.parse())，是重载方法，根据构建完成的Configuration对象，创建SqlSession工厂的实现类，然后实现类可以通过openSessionFromDataSource()方法，生成出SqlSession对象。当然这需要我们自己调用
parse()方法，首先parsed变量，默认为false，用来标识是否已经解析过xml核心配置文件。如果没解析，就设置parsed为true标识已经解析，然后利用XPathParser对象获取根标签configuration，进入parseConfiguration()方法完成解析逻辑
此方法会依次解析各种标签，并且可以看到，这里是按照特定顺序解析的，所以我们配置xml文件时，也要按照这个顺序
具体如何解析，我们用propertiesElement(root.evalNode(“properties”));举例
而我们这里需要关注一下解析&lt; mapper&gt;标签，这个标签配置了mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3063eaae9fb663107f6160b172e76692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f626b87186e75fb552cfbe1c5ad91206/" rel="bookmark">
			蓝桥杯——车的放置 (C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目来源：蓝桥杯算法训练 知识点：DFS搜索 问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
包含一个正整数n
输出格式
一个整数，表示放置车的方法数
样例输入
2
样例输出
7
数据规模和约定
n&lt;=8
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
题目分析 类似 n皇后，这里每行、每列只能放一个车，对角线没有约束，所以一行行地放置就可以了。因为车之间没有区别，所以为了避免计算到重复的情况，每深入一层后，循环开始的位置都应该是上一层行数的下一行，即i + 1。
代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 10; int n, m; int row[maxn], col[maxn]; int ans; void DFS(int k, int h) { if(k == m) { ans++; return; } for(int i=h; i&lt;n; i++) { if(row[i]) continue; row[i] = 1; for(int j=0; j&lt;n; j++) { if(!col[j]) { col[j] = 1; DFS(k + 1, i + 1); //注意 i+1 col[j] = 0; } } row[i] = 0; }	} int main() { cin &gt;&gt; n; ans = 0; for(m=0; m&lt;=n; m++) { memset(row, 0, sizeof(int) * n); memset(col, 0, sizeof(int) * n); DFS(0, 0); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f74987aea3e6b9984572eeea72e3eb9/" rel="bookmark">
			各系统如何进行ping IP&#43;端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种操作系统如何ping 端口
(1)win 1.下载tcping工具
地址：https://elifulkerson.com/projects/tcping.php
2.将tcping.exe放在C:\Windows\System32
3.重新打开CMD窗口，输入命令：tcping 指定的IP或者域名 端口号 。输入完回车就可以查看这个IP的端口是否是通着的。
比如：tcping 10.20.66.37 8090
(2)linux 具体用法：telnet 指定的IP或者 域名 端口号.
比如：telnet 10.20.66.37 50890
注：记录一些问题，方便查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f77f001745084c61fde277c90a2ba2c/" rel="bookmark">
			蓝桥杯——粘木棍 (C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：蓝桥杯算法训练 知识点：DFS搜索 问题描述
有N根木棍，需要将其粘贴成M个长木棍，使得最长的和最短的的差距最小。
输入格式
第一行两个整数N,M。
一行N个整数，表示木棍的长度。
输出格式
一行一个整数，表示最小的差距
样例输入
3 2
10 20 40
样例输出
10
数据规模和约定
N, M&lt;=7
题目分析 暴力法 思路：列举所有可能的组合，比较求最小差距。显然这种做法在计算过程中包含大量的重复计算，耗时较长。
采用 DFS+穷举 的思路：每次选择两根木棍进行合并，新木棍加入数组，两个旧的舍去。n根木棍要合并成m根，相当于需要合并n - m次，即舍去n - m根旧的。
如何舍去旧木棍，加入新木棍呢？可以使用两层for循环遍历，取出两根木棍，将合并的新长度放入其中一个旧木棍在数组中的位置，将另一个旧木棍的位置与最后n-1的位置交换。在使用 DFS 进行搜索时，参数为当前数组长度，往下搜索时长度递减即可。
代码 #include &lt;bits/stdc++.h&gt; using namespace std; #define MAX 9999 #define MIN -9999 const int maxn = 10; int lens[maxn]; int n, m, d; void DFS(int k) { if(k == m) { int maxL = MIN; int minL = MAX; for(int i=0; i&lt;k; i++) { if(lens[i] &lt; minL) minL = lens[i]; if(lens[i] &gt; maxL) maxL = lens[i]; } d = min(d, maxL - minL); return; } for(int i=0; i&lt;k; i++) { for(int j=i+1; j&lt;k; j++) { lens[i] += lens[j]; swap(lens[j], lens[k-1]); DFS(k-1); swap(lens[j], lens[k-1]); lens[i] -= lens[j]; } } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i=0; i&lt;n; i++) { cin &gt;&gt; lens[i]; } d = MAX; DFS(n); cout &lt;&lt; d &lt;&lt; endl; return 0; } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f77f001745084c61fde277c90a2ba2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4a90c9a4a45d1e86a55a7ab53e6d77/" rel="bookmark">
			关于 chrome升级后出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		has been blocked by CORS policy: The request client is not a secure context and the resource is in more-private address space `private`
【解决方案】：
1:两种资源都改成https
2:做代理或改dns 两种资源都改成 内网或者外网ip
3:配置chrome选项为disable chrome://flags/#block-insecure-private-network-requests
或者访问者资源加响应头 Access-Control-Allow-Private-Network
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f45849d9797be87e21b367685fafa9/" rel="bookmark">
			C&#43;&#43;11新特性内存模型总结详解--一篇秒懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己开发了一个股票软件，功能很强大，需要的点击下面的链接获取：
QStockView股票智能分析报警软件下载链接 - 一字千金 - 博客园
目录
1 介绍... 1
1.1 原子操作... 1
1.2 指令执行顺序... 2
1.3 编译器和CPU指令重排... 2
1.4 依赖关系... 3
1.5 memoryorder作用... 3
2 六种内存模式... 3
2.1 Relaxed ordering. 5
2.2 Release – acquire. 6
2.3 Release – consume. 7
2.4 memory_order_acq_rel 10
2.5 Sequentially-consistent ordering. 11
2.6 总结... 13
3 参考文献... 14
1 介绍 多线程编程已经是大家熟知的知识，多线程编程主要的问题就是多线程同时访问一个变量时，会造成同时读写同一个变量的问题，造成数据异常，通常会使用mutex、临界区、条件变量来实现多线程同步，避免多线程同时读写同一个变量。但是锁竞争也会影响程序的执行效率，所以C++11引入了原子变量atomic，实现变量的原子操作，线程对变量的操作马上对其他线程可见，避免使用锁临界区造成的消耗。同时C++11引入了内存模型，可以同步不同线程之间的原子变量操作前后的代码的重排限制。
1.1 原子操作 首先，什么是原子操作？原子操作就是对一个内存上变量（或者叫左值）的读取-变更-存储（load-add-store）作为一个整体一次完成。例如x++这个表达式如果编译成汇编，对应的是3条指令：mov（从内存到寄存器），add，mov（从寄存器到内存）那么在多线程环境下，就存在这样的可能：当线程A刚刚执行完第二条add指令的时候，还没有执行第三条mov指令，线程B就同时开始执行第一条指令。那么B读到的数据还是0，A执行第三条指令后写入内存，x值是1，B再执行第三条指令从寄存器写到内存，x还是1。如果是原子操作，mov（从内存到寄存器），add，mov（从寄存器到内存）这三条指令必须一次完成，线程A执行三条之后，x=1，线程B在执行三条指令，得到x=2。atomic本身就是一种锁，它自己就已经完成这种原子操作的作用。内存顺序是控制不同原子操作之间的执行顺序，比如是线程B先加1还是线程A先加1。
1.2 指令执行顺序 为了尽可能地提高计算机资源利用率和性能，编译器会对代码进行重新排序， CPU 会对指令进行重新排序、延缓执行、各种缓存等等，以达到更好的执行效果。单线程则是按照线程中的代码顺序执行指令，多线程时，两个线程之间执行指令的顺序会进行优化调整，所以无法保证两个线程中指令执行的相对顺序，例如线程1有指令A,B，线程2有指令C，D，两个线程同时执行，那么可能的执行顺序是ABCD，ACBD，CDAB,CABD等；所以C++11引用内存顺序操作，实现控制多线程中指令执行顺序，实现多线程同步。能够按照你想的顺序执行指令。
happens-before关系，说白了就是代码编写顺序，一般是指单线程内部的代码顺序。Synchronized-with关系则是多线程之间的同步关系，通过6个模式，实现多线程中指向执行顺序的不同约束。
1.3 编译器和CPU指令重排 代码顺序：就是你按照代码一行一行从上往下的顺序；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f45849d9797be87e21b367685fafa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9ce6f07909ce55c4bf6c8a5354a769/" rel="bookmark">
			element ui 表格根据后端返回数据 按创建时间 倒序 排序，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认排序
代码：
&lt;el-table ref="table" v-loading="crud.loading" :header-cell-style="{ color: '#FFF', background: '#333' }" :cell-style="{ color: '#FFF', background: '#333' }" :data="crud.data" style="width: 100%" @selection-change="crud.selectionChangeHandler" :default-sort="{ prop: 'createDate', order: 'descending' }" @sort-change="sortChange" &gt; &lt;el-table-column prop="createDate" :sortable="true" :label="$t('NeoLight.createDate')" /&gt; &lt;/el-table&gt; 附：远程排序 sortable=custom 实例：
使用：远程排序 需要后端排序 sortable=custom
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6818621990759c7d801d67f2257615f0/" rel="bookmark">
			AndroidStudio WirelessDebugging/ WiFi链接。Android10- or HarmonyOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先决条件：Android10以及更低版本。 （我的真机是鸿蒙系统，这个方法实测可行。Android11+不知道能不能用，但是官方给的是11有单独的连接方式，就是去开发者选项打开WireLessDebugging就可以了，我用另一台11的找不到这个选项（荣耀X20），但是也懒得用这个方法去测试行不行，有闲情的猿媛可以试试哈）
1. 将 Android 设备和 adb 主机连接到这两者都可以访问的同一 WLAN 网络。请注意，并非所有接入点都适用；您可能需要使用防火墙已正确配置为支持 adb 的接入点。 2. 使用 USB 线将设备连接到主机。 3. 设置目标设备以监听端口 5555 上的 TCP/IP 连接。 adb tcpip 5555 4. 拔掉连接目标设备的 USB 线。 5. 找到 Android 设备的 IP 地址。例如，对于 Nexus 设备，您可以在设置 &gt; 关于平板电脑（或关于手机）&gt; 状态 &gt; IP 地址下找到 IP 地址。或者，对于 Wear OS 设备，您可以在设置 &gt; WLAN 设置 &gt; 高级 &gt; IP 地址下找到 IP 地址。 6. 通过 IP 地址连接到设备。 adb connect 你手机上的IP地址:5555 7. 确认主机已连接到目标设备： adb devices 如果有输出以下内容就代表连接成功过了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6818621990759c7d801d67f2257615f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74af648423daf6ed2c32317e5f074f7/" rel="bookmark">
			工业树莓派在激光雕刻中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 工业树莓派（RevPi）是一种 DIN 导轨安装的工业小型控件，具有一整套 IO 和总线模块，可以与所有常见的模拟和数字传感器、执行器和总线系统以及基于 TCP-IP 的网络进行通信。RevPi 运行 Linux 操作系统，这使得它成为一个功能多样的多功能解决方案。
在本案例中，RevPi通过DIO扩展模块连接川崎FS03N型机器人以及PLH3D-6W-XF激光雕刻头。通过预安装的开源Node-RED软件，建立逻辑控制、通信通道以及功能强大的仪表盘。并可以通过web界面对机器人运行状态进行远程访问及控制。
二 硬件连接 下图是本案例的硬件连接实物图。最左边是24V电源，用于设备供电。旁边是RevPi Core模块，并连接了DIO扩展模块。
Core模块通过网线接入到网络内，可以进行远程访问及通信。DIO模块连接机器人及激光雕刻头进行逻辑控制。再往右边是两个AllDAQ的适配器，用于将RevPi DIO扩展模块的14个数字输入和14个数字输出连接到机器人的I/O版。
旁边蓝色的小型设备是一个耦合继电器，用于打开或关闭激光雕刻头的电源。最右边是数模转换器，可以将来自机器人的数字信号转换为激光雕刻头的0-10V模拟信号。
三 Node-RED仪表盘 本案例使用Node-RED的Dashboard组件建立操作仪表盘可以监视机器人的工作状态并进行开关控制。因为Core模块已接入以太网中，所以除了通过IO接口外，也可以TCP或UDP通信进行控制。
在本案例中，通过切换机器人控制器上的开关，可以使得机器人的状态从TEACH模式变为REPEAT模式，并在仪表盘中显示。
点击仪表盘上的Motor Power按钮可以打开电动机电源，并转换为ON状态。
也可以通过仪表盘控制机器人在某个方向上进行移动（以毫米为单位）。
单击中间Homing符号，可以使机器人回到原始位置。如果机器人处于原位，则“房子”符合将点亮。
四 Node-RED程序流 RevPi对机器人的逻辑控制及通信都是通过建立Node-RED flow实现的。
上面介绍的UI界面，也是通过这样的流程建立的。在Node-RED flow中，字符串以msg的形式存在，有效信息位于payload中，并可以通过TCP 或者UDP发送到机器人。
五 远程监控 Node-RED支持通过局域网内基于web的浏览器访问仪表盘。所以，您可以使用平板电脑或者智能手机监视机器人状态并进行控制。
在本案例中，可以通过手机发送开始“Laser-Auftrag gestartet”（开始激光工作）的信息，使机器人开始工作。并在作业结束后，可以在手机端收到“Laser-Auftrag beendet”（激光作业已完成）的提示信息。
如果想要了解更多相关信息，可以扫描下方的二维码获取更多的精彩内容！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052b0c785e3c864b285fdbf20613f51d/" rel="bookmark">
			Java基础知识总结——对象的引用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 对象有以下四种引用方式：
1、强引用（StrongReference） Java 中最常见的引用方式，当一个对象 A 被其它对象强引用时，该对象 A 处于可达状态，不会被垃圾回收机制回收。
2、软引用（SoftReference） 对于只有软引用的对象，当系统内存空间足够时，它不会被系统回收，程序也可以使用该对象；当系统内存空间不足时，系统可能会回收它。软引用适用于管理内存，例如缓存
例如：https://www.cnblogs.com/dolphin0520/p/3784171.html
3、弱引用（WeakReference） 对于只有弱引用的对象，无论系统内存空间是否足够，当系统进行垃圾回收时，系统就会回收该对象所占用的内存空间。
4、虚引用（PhantomReference） 虚引用类似于没有引用，虚引用无法获取它引用的对象，其主要用于跟踪对象被垃圾回收的状态。虚引用不能单独使用，必须和引用队列联合使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776fa1379cf47baabd9affede81b3222/" rel="bookmark">
			一文掌握Flutter 2.10新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期待已久的新教程上线啦！解锁Flutter开发新姿势，一网打尽Flutter最新与最热技术，点我Get!!!
Flutter 2.10 版已正式发布！虽然⾃ 上次稳定版本发布 以来还不到两个⽉，即使在这么短的时间内，Flutter官方也已处理和关闭了 1843 个 Issue，合并了来⾃全球 155 位贡献者的 1525 个 PR。
Flutter 2.10 包括 Flutter 对 Windows ⽀持的重⼤更新、⼏项重⼤的性能改进、框架中图标和颜⾊的新⽀持以及一些⼯具改进等。此外，该版本还包括移除了 dev 渠道的更新、减少对旧版 iOS 的⽀持以及几个简短的破坏性改动。接下来让Flutter来一睹Flutter 2.10的更新吧：
使用 Flutter 构建 Windows 桌面应用支持已经进入稳定阶段 ⾸先，Flutter 2.10 版本带来了稳定的 Windows ⽀持，无需再通过 --enable-windows-desktop 标记来单独配置 Windows 桌面版应用程序的支持，因为它现在已经默认被启用！
当然，此次稳定版发布肯定不只是“删掉”一个标记这么简单 😉 在 Flutter 2.10 的 Windows 支持中，也包含了对⽂本处理、键盘处理和键盘快捷键的⼴泛改进，以及直接与 Windows 集成的新方式、⽀持命令行参数、全球化⽂本输⼊和无障碍功能等。
有关 Windows 稳定版发布的更多信息，你可以阅读《Flutter for Windows桌面端稳定版发布》，文章为大家详述了 Flutter 在 Windows 上的架构，同时说明了有多少 Flutter package 和插件已经⽀持 Windows。你还可以查看Flutter的⼯具和应⽤合作伙伴在 Windows 上使⽤ Flutter 制作的一些⽰例等。
引擎的性能改进 此版本的 Flutter 包括由社区成员 knopp提供的 绘制脏区管理 的初步⽀持，他为 iOS/Metal 上的单个脏区域启⽤了选择性重绘。这一变化将一些基准测试中九十分位和九十九分位的光栅化时间减少了一个数量级，并将这些基准测试中的 GPU 利⽤率从 90% 以上降低到了 10% 以下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776fa1379cf47baabd9affede81b3222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c6e2c6adf30a0a5095a87210e2d6dc/" rel="bookmark">
			免费对接快递鸟物流查询接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹查询类接口 1.在途监控 快递鸟汇集国内外1600多家快递公司的物流轨迹数据，以接口形式开放给用户使用，支持即时查询+订阅两种调用方式，为用户提供全流程的物流状态查询服务（包括已揽收、在途中、到达派件城市、派件中、已签收等20多种物流节点状态）。 1.1即时查询接口 快递鸟在途监控接口用于向快递公司实时查询物流轨迹信息，监督卖家发货、物流跟踪、异常提醒、签收状态等服务 1.2 基本信息
1.3 接口规则 返回的物流轨迹信息按照发生时间的升序排列。 1.4 支持情况 主流快递仅支持申通快递、圆通速递、百世快递、天天快递 4 家，不支持 EMS 、邮政 快递包裹、顺丰速运、韵达速递、京东快递、中通快递；如需查询所有主流快递公司， 请选用 在途监控 服务； 1.5 应用场景 支持打单工具、查询工具、WEB 端、 APP 移动端、小程序等场景使用 1.6 应用级参数 请求示例： ZTO 请求示例： { "OrderCode": "", "ShipperCode": "ZTO", "LogisticCode": "638650888018", } JD 请求示例： { "OrderCode": "", "CustomerName": "001K12345", "ShipperCode": "JD", "LogisticCode": "VA00003618100", } SF 请求示例： { "OrderCode": "", "CustomerName": "1234", "ShipperCode": "SF", "LogisticCode": "SF00003618100", } 1.7 返回参数 返回示例:
无物流轨迹 ： { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c6e2c6adf30a0a5095a87210e2d6dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd67801f1ca7cf3efca75b41fd01e70/" rel="bookmark">
			快递鸟API接口技术规范说明文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快递鸟 API 旨在为电商、电商平台、物流工具、打单工具、仓储系统、移动 APP 等系统提供专业、稳定、优质的 API 接口服务，满足不同用户的物流管理需求。 本文档就各个 API 接口进行详细说明，方便用户快速对接及使用快递鸟服务。 1.接口规范及说明 1.1 报文及报文编码 报文格式： Json 格式 请求方法的编码格式 (utf-8) ： "application/x-www-form-urlencoded;charset=utf-8" 交互协议上统一用 UTF-8 ，避免传递中文数据出现乱码。 1.2 接口数据包结构 图例 - 数据包结构 ( 系统级 { 数据 }) 1.3 JSON 示例 string used = "1237100" ; //仅作为示例ID，不可用来实际使用 //加密私钥，由快递鸟提供 string keyValue = "56da2cf8-c8a2-44b2-b6fa-476cd7d1ba17" ; //仅作为示例Key，不可用 来实际使用 //请求地址 string url = "https://api.kdniao.com/Ebusiness/EbusinessOrderHandle.aspx" ; //2-json string DataType = "2" ; //字符编码采用UTF-8 string charset = "UTF-8" ; //JSON字符串string string jsonStr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd67801f1ca7cf3efca75b41fd01e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee690e3427cc583da64cf73071ba3a8b/" rel="bookmark">
			游戏业务被攻击后要怎么处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏作为最容易遭到黑客攻击行业，一直是网络安全的重灾区。尤其运行良好人气高的游戏，人气越火，被攻击的风险就越高。针对游戏上的攻击，市场上也是推出了很多的防护产品。游戏盾便是专门为游戏防护专门设计的一款防护产品
游戏盾由高防节点池组成，每个抗D节点都可以轻松防御600G以上的攻击，通过可弹性扩缩的分布式抗D节点，当发生超大流量攻击时，可根据影响范围，迅速将业务分摊到未受影响的节点。遭遇真实肉鸡发起的TCP连接与协议模拟的功能时可以通过SDK与游戏安全网关的加密隧道彻底解决CC攻击问题。并且拥有防掉线功能，通过新SocKet协议，弥补了WinSock链接失败会断开的问题，链接失败自动无缝切换。游戏盾分钟级EXE封装、SDK接入集成，全面支持Windows、Linux、Unix、MacOS、IOS、Android等。
接入游戏盾需要封装登录器，下载封装打包工具，进行封装。并将业务IP修改成游戏盾IP，然后在后台添加源IP业务端口，设置好转发规则。都操作好后，重新上传封装后的登录器，让玩家下载登录游戏即可。一切操作完毕，只要源IP之前未曾暴露，就无需担心后续的攻击问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef310695e767058aa0a4a992ba7cdbc/" rel="bookmark">
			基类的指针和派生类的指针到底有什么本质的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、派生类会比基类多一些属性和方法，就一地址，指针的类型会决定指针在访问内存时如何访问
2、【举例】基类中属性有a,b,c;那么派生类中除了继承的a,b,c，可能还会有自己的派生的属性d，这时候基类和派生类的指针就看出不同来了；
【举例】基类指针赋值一个派生类的指针地址，因为指针的类型没换，所以这个指针还是不能访问到派生类中d属性的内存。个人觉得，可以把指针类型理解成一个决定指针访问范围的东西
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812e0dcee81226f5c32e4a9a5b3099ea/" rel="bookmark">
			AssertionError: Image Not Found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 要 detect 的图片找不到
解决方案 查阅他人解决方案，最终通过修改 utils\datasets.py 中的 LoadImages类中的图片路径解决。
将图中的红色改为绿色语句即可，下边的 p 爆红不影响，不需要纠结，实测有效。
最后回到 detect.py 运行，成功预测。
参考：https://blog.csdn.net/Bugs_creater/article/details/115631408
https://www.imooc.com/article/310270?block_id=tuijian_wz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6970fbc4f1eb81e187a8dc0be7a3d3/" rel="bookmark">
			nexus私服npm包踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.私服npm publish时，报错“-4048”，如下图所示：
解决方法： 删除包中的node_modules文件夹修改npm镜像地址为私服地址，执行命令：npm config set registry http://xxx.com/repository/antd-vue-based-components/重新登录私服账号检查所在目录是否为当前要发布包的上级目录 2.私服再次publish npm包时，报“E400， Repository does not allow updating assets”，错误如下图所示：
解决方法：修改私服仓库的 Deployment policy配置项为Allow redeploy，如下图所示：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/264/">«</a>
	<span class="pagination__item pagination__item--current">265/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/266/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>