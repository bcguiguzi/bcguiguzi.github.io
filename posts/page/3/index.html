<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6630095e6b1629f0174b69cffdc0189/" rel="bookmark">
			wps技巧二实现每一行文字后面统一添加数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 操作 查找，输入^p
替换，输入 n m p q^p，测试数据，随意替换成你想要的
结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608f80ee1727ef35173cfe01c2731699/" rel="bookmark">
			wps技巧一实现逗号替换成换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 操作 查找，输入，
替换，输入^p
结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0236441d3101331326e62ef5401fa3/" rel="bookmark">
			Python实现10大经典排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法是《数据结构与算法》中最基本的算法之一。
排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：
图片
关于时间复杂度
平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。
线性对数阶 (O(nlog2n)) 排序、快速排序、堆排序和归并排序；
O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序
线性阶 (O(n)) 排序，基数排序，此外还有桶、箱排序。
关于稳定性
排序后 2 个相等键值的顺序和排序之前它们的顺序相同。
稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。
不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。
名词解释
n：数据规模
k：“桶”的个数
In-place：占用常数内存，不占用额外内存
Out-place：占用额外内存
1、冒泡排序
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。
（1）算法步骤
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
（2）动图演示
图片
（3）Python 代码
def bubbleSort(arr):
for i in range(1, len(arr)):
for j in range(0, len(arr)-i):
if arr[j] &gt; arr[j+1]:
arr[j], arr[j + 1] = arr[j + 1], arr[j]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0236441d3101331326e62ef5401fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b301f80edfad4b422803115062a050/" rel="bookmark">
			Not so Mobile（UVA 839）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址如下：
Not so Mobile - UVA 839 - Virtual Judge (vjudge.net)
（第三方网站）
递归输入来模拟二叉树
可以边输入边判断
如果结果是NO，则这一组的数据有可能没读完，所以需要一个clear函数来把剩余输入吃掉
代码如下：
#include&lt;cstdio&gt; void clear(void); bool is_judge(int &amp;W); int main(void) { int tmp = 0, kase; scanf("%d", &amp;kase); while(kase--) { if(is_judge(tmp)) printf("YES\n"); else printf("NO\n"); if(kase){putchar('\n'); clear();} } return 0; } bool is_judge(int &amp;W) { int WL, DL, WR, DR; scanf("%d%d%d%d", &amp;WL, &amp;DL, &amp;WR, &amp;DR); if(!WL){if(!is_judge(WL)) return false;} if(!WR){if(!is_judge(WR)) return false;} if(!W) W = WL + WR; if(WL * DL == WR * DR) return true; else return false; } void clear(void) { char fc{}, bc{}; while(fc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b301f80edfad4b422803115062a050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409f7db651f5906bc8370ca731380aae/" rel="bookmark">
			【Python实用技能】爬虫升级之路：从专用爬虫到用AI Agent实现通用网络爬虫（适合小白）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是同学小张，日常分享AI知识和实战案例欢迎 点赞 + 关注 👏，持续学习，持续干货输出。+v: jasper_8017 一起交流💬，一起进步💪。微信公众号也可搜【同学小张】 🙏 本站文章一览：
目前为止，我们已经写了几个爬虫程序，能将网页中的内容提取出来，或者保存成PDF。本文来总结一下这些方法，循序渐进地带大家看下爬虫的实现方法：从单个网页爬虫，到利用大模型提取指定信息，到利用AI Agent实现自动编写爬虫代码实现通用爬虫。
说明：本人爬虫小白，所以 这篇文章总结的是简单的爬虫程序，可以直接使用的程序 。没有复杂的操作，也没有深入的理解。适合爬虫小白或只是将爬虫作为一个数据来源的非专业人员。想要深入理解爬虫原理的同学，可以退出了。
文章目录 0. 单网页的专用爬虫实现方法0.1 基本的爬虫程序实现方法0.2 利用 selenium 实现爬虫0.3 利用 LangChain 爬取网页内容0.3.1 Loading + Transforming0.3.2 WebBaseLoader 1. 利用大模型直接提取指定信息的探索2. 利用AI Agent实现通用爬虫2.1 实现思路2.2 自动化爬虫代码生成器2.3 可能遇到的问题 3. 总结 0. 单网页的专用爬虫实现方法 这种爬虫是针对特定网页的数据爬取，可以是一个网页，或者是一系列结构相似的网页。
这种爬虫的实现方法，最主要的是，需要打开网页，F12调试，然后找自己需要的文本内容在HTML中的Tag或Class。
0.1 基本的爬虫程序实现方法 如果你会一点爬虫基础，那看到网页结构，应该就知道怎么利用 BeautifulSoup 写一个简单的爬虫程序了。但是如果你一点爬虫基础也没有，不知该如何下手呢？可以利用ChatGPT、文心一言、智谱清言等工具帮你。保姆级操作教程可看下面的文章：
【提效】让GPT帮你写爬虫程序，不懂爬虫也能行 文章中包含了如何找到你需要的文本内容在HTML结构中的Tag、class，如何给大模型Prompt和交互等：
【AI大模型应用开发】【LangChain系列】实战案例2：通过URL加载网页内容 - LangChain对爬虫功能的封装
前面的文章，我们利用LangChain实现了URL网页数据的提取。但是今天想用它抓取微信公众号文章的数据时，失败了。
之前利用 LangChain 实现URL网页数据提取的文章可见：
【AI大模型应用开发】【LangChain系列】实战案例4：再战RAG问答，提取在线网页数据，并返回生成答案的来源 0.2 利用 selenium 实现爬虫 我们在 【Python实用技能】建议收藏：自动化实现网页内容转PDF并保存的方法探索（含代码，亲测可用） 这篇文章中通过 selenium 实现了自动将网页保存为PDF的功能。其实利用 selenium 也可以直接从网页中提取想要的内容。
下面的示例代码中，通过selenium模拟打开网页，通过 xpath 爬取指定元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409f7db651f5906bc8370ca731380aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762e3100b5dd68b6e502502ebe21eaea/" rel="bookmark">
			阿里云-零基础入门推荐系统 【排序模型&#43;模型融合】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 学习过程赛题介绍评价方式理解赛题理解排序模型读取排序特征转化类型返回排序后的结果排序结果归一化LGB排序模型定义特征列排序模型分组排序模型定义排序模型训练lgb_ranker模型预测lgb_ranker预测结果重新排序及生成提交结果lgb_ranker五折交叉验证lgb_ranker五折交叉验证预测结果重新排序, 及生成提交结果 LGB分类模型模型训练模型预测lgb_cls预测结果重新排序, 及生成提交结果lgb_cls五折交叉验证lgb_cls五折交叉验证预测结果重新排序 模型融合加权融合Staking将多个模型输出的特征进行拼接定义一个逻辑回归模型再次拟合交叉验证产生的特征对测试集进行预测ensumble_staking预测结果重新排序及生成提交结果 学习过程 20年当时自身功底是比较零基础(会写些基础的Python[三个科学计算包]数据分析)，一开始看这块其实挺懵的，不会就去问百度或其他人，当时遇见困难挺害怕的，但22后面开始力扣题【目前已刷好几轮，博客没写力扣文章之前，力扣排名靠前已刷有5遍左右，排名靠后刷3次左右，代码功底也在一步一步提升】不断地刷、遇见代码不懂的代码，也开始去打印print去理解，到后面问其他人的问题越来越少，个人自主学习、自主解决能力也得到了进一步增强。
赛题介绍 该赛题是以新闻APP中的新闻推荐为背景， 目的是要求我们根据用户历史浏览点击新闻文章的数据信息预测用户未来的点击行为， 即用户的最后一次点击的新闻文章。
评价方式理解 最后提交的格式是针对每个用户， 我们都会给出五篇文章的推荐结果，按照点击概率从前往后排序。 而真实的每个用户最后一次点击的文章只会有一篇的真实答案， 所以我们就看我们推荐的这五篇里面是否有命中真实答案的。比如对于user1来说， 我们的提交会是：
user1, article1, article2, article3, article4, article5. 评价指标的公式如下：
假如article1就是真实的用户点击文章，也就是article1命中， 则s(user1,1)=1, s(user1,2-4)都是0， 如果article2是用户点击的文章， 则s(user,2)=1/2,s(user,1,3,4,5)都是0。也就是score(user)=命中第几条的倒数。如果都没中， 则score(user1)=0。 这个是合理的， 因为我们希望的就是命中的结果尽量靠前， 而此时分数正好比较高。
赛题理解 根据赛题简介，我们首先要明确我们此次比赛的目标： 根据用户历史浏览点击新闻的数据信息预测用户最后一次点击的新闻文章。从这个目标上看， 会发现此次比赛和我们之前遇到的普通的结构化比赛不太一样， 主要有两点：
首先是目标上， 要预测最后一次点击的新闻文章，也就是我们给用户推荐的是新闻文章， 并不是像之前那种预测一个数或者预测数据哪一类那样的问题数据上， 通过给出的数据我们会发现， 这种数据也不是我们之前遇到的那种特征+标签的数据，而是基于了真实的业务场景， 拿到的用户的点击日志 所以拿到这个题目，我们的思考方向就是结合我们的目标，把该预测问题转成一个监督学习的问题(特征+标签)，然后我们才能进行ML，DL等建模预测。
排序模型 通过召回的操作， 我们已经进行了问题规模的缩减， 对于每个用户， 选择出了N篇文章作为了候选集，并基于召回的候选集构建了与用户历史相关的特征，以及用户本身的属性特征，文章本省的属性特征，以及用户与文章之间的特征，下面就是使用机器学习模型来对构造好的特征进行学习，然后对测试集进行预测，得到测试集中的每个候选集用户点击的概率，返回点击概率最大的topk个文章，作为最终的结果。
排序阶段选择了三个比较有代表性的排序模型，它们分别是：
LGB的排序模型LGB的分类模型深度学习的分类模型DIN 得到了最终的排序模型输出的结果之后，还选择了两种比较经典的模型集成的方法：
输出结果加权融合Staking（将模型的输出结果再使用一个简单模型进行预测） import numpy as np import pandas as pd import pickle from tqdm import tqdm import gc, os import time from datetime import datetime import lightgbm as lgb from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/762e3100b5dd68b6e502502ebe21eaea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5f0ab5d99d28b266136332d84f5575/" rel="bookmark">
			【excel】常用的50个函数与基础操作(统计函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统计函数 （1）数组函数操作 1.【SUM】求和
= SUM（数字1，数字2，数字3…）
2.【SUMIF】单条件求和
= SUMIF （条件区域，条件，求和区域）
3.【SUMIFS】(单)多条件求和
= SUMIFS （求和区域，条件区域1，条件1，条件区域2，条件2···）
4.【COUNT】数值单元格计数
= COUNT （区域）
5.【COUNTA】非空单元格计数
= COUNTA （区域）
6.【COUNTIF】单条件计数
= COUNTIF （条件区域，条件）
7.【COUNTIFS】(单)多条件计数
= COUNTIFS （条件区域1，条件1，条件区域2，条件2···）
8.【SUMPRODUCT】对应数组元素乘积之和
= SUMPRODUCT（区域1，区域2，区域3··）
（2）最大值、最小值与平均值 1.【MAX】求最大值
= MAX（区域）
2.【MAXIFS】(单)多条件求最大值
= MAXIFS（比较区域，条件范围1，条件1，…）
3.【MIN】求最小值
= MIN（区域）
4.【MINIFS】(单)多条件求最小值
= MINIFS（比较区域，条件范围1，条件1，…）
5.【AVERAGE】数值单元格求平均值
= AVERAGE（区域）
6.【AVERAGEA】非空单元值求平均值
= AVERAGEA（区域）
7.【AVERAGEAIF】单条件求平均值
= AVERAGEAIF（条件区域，条件，平均值区域）
8.【AVERAGEAIFS】(单)多条件求平均值
= AVERAGEAIFS（平均值区域，条件区域1，条件1 ···）
（3）排名、随机与取整系列 1.【 RANK 】求某单元格在某区域内的排名
= RANK (数值，引用区域，降序0 / 升序1)
2.【 RAND 】输出0-1之间的一个随机数（很多位小数）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e5f0ab5d99d28b266136332d84f5575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2475aeeedee822ad7bb558644d06e77e/" rel="bookmark">
			2024/3/17 TCP的进程和线程通信，模拟面试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;myhead.h&gt; #define SER_PORT 8888//服务器端口号 #define SER_IP "192.168.65.130"//服务器IP //定义向线程体提供参数的结构体 struct BufInfo { int newfd; struct sockaddr_in cin; }; //定义线程体函数 void *deal_cli_msg(void *arg) { //接受传过来的消息 int newfd = ((struct BufInfo*)arg)-&gt;newfd; struct sockaddr_in cin = ((struct BufInfo*)arg)-&gt;cin; //收发数据 char sbuf[128] = ""; while(1) { //将容器清空 bzero(sbuf,sizeof(sbuf)); int res = recv(newfd,sbuf,sizeof(sbuf)-1,0); if(res == 0) { printf("客户端已经下线\n"); break; } printf("[%s %d]:%s\n",inet_ntoa(cin.sin_addr),ntohs(cin.sin_port),sbuf); strcat(sbuf,"&gt;_&lt;"); send(newfd,sbuf,strlen(sbuf),0); printf("发送成功\n"); } //关闭与客户端通信的套接字 close(newfd); //退出线程 pthread_exit(NULL); } /************主程序***************/ int main(int argc, char *argv[]) { //创建一个套接字 int sfd = -1; sfd = socket(AF_INET,SOCK_STREAM,0); if(sfd == -1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2475aeeedee822ad7bb558644d06e77e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf17805c790135cdfbc4ad3bae07a247/" rel="bookmark">
			【XML】xml转Freemind思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过以下代码可以将xml转换为Freemind软件的思维导图，方便查看各数据结构该代码运行需要安装lxml库 pip install lxml 使用方式示例 python xml2mm.py *.xml *.mm 转化完成示例，使用Freemind软件打开，该软件在ubuntu的软件商店中即可下载python代码如下 import sys from lxml import etree as et from xml.sax.saxutils import quoteattr class FreeMindCreator: def __init__(self, outfile=sys.stdout): self.outfile = outfile self.line_counter = 1 self.mmlines = [ '&lt;map version="1.0.1"&gt;\n', "&lt;!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net --&gt;\n", ] def start(self, tag, attrib): attrib = " ".join([f"{key}={value}" for key, value in attrib.items()]) blank, space = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf17805c790135cdfbc4ad3bae07a247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00ac38eac833a926e6b18e45d185cac/" rel="bookmark">
			力扣由浅至深 每日一题.07 移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流言蜚语很吵，捂着耳朵做自己
—— 24.3.17
移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00ac38eac833a926e6b18e45d185cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460ab8d38fc2eb62b413085a486e7b36/" rel="bookmark">
			【excel】常用的50个函数与基础操作(逻辑函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逻辑函数 （1）布尔逻辑 定义：TRUE 和 FALSE
使用：=XX条件
（2）AND 定义：判断多个条件是否同时成立
使用：=AND (logical1, logical2, …)
（3）OR 定义：判断多个条件是否至少有一个成立
使用：=OR (logical1, logical2, …)
（4）IF 定义：根据条件真假判断返回不同结果
使用：=IF (logical test, Value_if_true, Value_if_false)
备注：类似于三元表达式
（5）IFS 定义：改进版IF
使用：=IFS ( Logical_test1, Value_if_true1, Logical_test2, Value_if_true2, … )
备注：if函数的层层嵌套
（6）IFERROR 定义：有错误值时指定输出值
使用：=IFERROR (Value, Value_if_error)
一、逻辑函数 二、统计函数 三、查询函数 四、文本函数 五、日期函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05db709c2c600ba6bcf5cc00ce5058f0/" rel="bookmark">
			vim，gcc，gdb与Makefile的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux编辑器-vim使用 1.vim的基本概念 vim的三种模式(其实有好多模式，目前掌握这3种即可),分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下
（1）正常/普通/命令模式(Normal mode) 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode
（2）插入模式(Insert mode) 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
（3）末行模式(last line mode） 文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+: 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入
:help vim-modes 2. vim的基本操作 进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面:
不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。
[正常模式]切换至[插入模式]三种方法：
（1）输入a（2）输入i（3）输入o
[插入模式]切换至[正常模式]
目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。
[正常模式]切换至[末行模式]
「shift + ;」, 其实就是输入「:」
退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode」,例如:
: w （保存当前文件）
: wq (输入「wq」,存盘并退出vim)
: q! (输入q!,不存盘强制退出vim)
3.vim正常模式命令集 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；
按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；
按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。
从插入模式切换为命令模式 按「ESC」键。
移动光标 vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格
按「G」：移动到文章的最后
按「 $ 」：移动到光标所在行的“行尾”
按「^」：移动到光标所在行的“行首”
按「w」：光标跳到下个字的开头
按「e」：光标跳到下个字的字尾
按「b」：光标回到上个字的开头
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05db709c2c600ba6bcf5cc00ce5058f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2348a47a729861e28cb7993d47fc413/" rel="bookmark">
			网络基础知识-操作系统作用&#43;进程管理-嵌入式系统设计师备考笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前言 本专栏为个人备考软考嵌入式系统设计师的复习笔记，未经本人许可，请勿转载，如发现本笔记内容的错误还望各位不吝赐教（笔记内容可能有误怕产生错误引导）。
本章的主要内容见下图：
本章知识和计算机网络中知识存在大量重合，可惜当时没有学明白计算机网络。考试重点在前三个部分。
1、OSI/RM OSI模型 OSI模型（Open Systems Interconnection model）是一种网络通信协议参考模型，由国际标准化组织（ISO）在1977年推出。该模型将网络通信分为七个层次，每个层次负责不同的功能和任务，各层之间通过协议进行交互。
以下是OSI模型的七个层次：
物理层（Physical Layer）：负责将数据传输到物理媒介上，例如通过电缆或无线信号传输数据。
数据链路层（Data Link Layer）：负责将原始数据转换为适合物理传输的格式，并确保数据的可靠传输。
网络层（Network Layer）：负责处理不同网络之间的数据路由和寻址，确保数据能够从源地址传输到目的地址。
传输层（Transport Layer）：负责对数据进行分段和重组，确保可靠传输，并提供流量控制和拥塞控制等功能。
会话层（Session Layer）：负责建立、管理和终止会话，提供会话控制和同步功能。
表示层（Presentation Layer）：负责数据的格式转换和加密，确保数据能够在不同系统之间正确解释和显示。
应用层（Application Layer）：负责处理特定的网络应用，例如电子邮件、文件传输和网页浏览等。
OSI模型提供了一个通用的框架，使不同的网络设备和系统能够相互通信和交互。不同的协议和技术可以在不同层次上实现，从而实现不同的功能和应用。
2、TCP/IP协议族 TCP/IP协议的通信模型是指将通信过程分为四个层次，分别是应用层、传输层、网络层和链路层。
应用层：该层协议提供了应用程序之间的通信服务。常见的应用层协议有HTTP、FTP、SMTP等。
传输层：该层协议主要负责数据的传输和端到端的通信。常见的传输层协议有TCP和UDP。TCP提供可靠的数据传输，保证数据的完整性和顺序性；UDP提供无连接的数据传输，速度快但不保证可靠性。
网络层：该层协议主要负责网络之间的通信，将数据分组进行传输。常见的网络层协议有IP协议，负责数据包的传输和路由选择。
链路层：该层协议主要负责物理层和数据链路层之间的通信。常见的链路层协议有以太网协议、无线局域网协议等。
通过这四个层次的协议，TCP/IP协议可以实现不同设备之间的数据传输和通信，实现互联网的功能。
2.1电子邮件协议 电子邮件协议是指用于发送、接收和管理电子邮件的规则和标准。其中最常见的电子邮件协议是SMTP（Simple Mail Transfer Protocol）和POP3（Post Office Protocol 3）或IMAP（Internet Message Access Protocol）。
SMTP（Simple Mail Transfer Protocol）：SMTP是用于发送电子邮件的标准协议。当您发送一封电子邮件时，您的电子邮件客户端会使用SMTP将邮件发送到电子邮件服务器，然后服务器将通过互联网将邮件传递到收件人的电子邮件服务器。
POP3（Post Office Protocol 3）：POP3是一种用于接收电子邮件的协议。它允许您的电子邮件客户端从邮件服务器上下载您的电子邮件，并且通常会将邮件从服务器上删除（除非您设置为保留在服务器上）。
IMAP（Internet Message Access Protocol）：IMAP也是一种用于接收电子邮件的协议。与POP3不同，IMAP允许用户在客户端和服务器之间保持同步，这意味着您可以在多个设备上查看邮件，并且可以在服务器上创建文件夹和标签等。
这些协议共同构成了电子邮件系统的基础，使得我们能够方便地发送、接收和管理电子邮件。
2.2WWW协议 WWW（World Wide Web）是一种基于互联网的信息系统，用于访问和检索互联网上的信息资源。WWW由许多不同的技术和协议组成，其中HTTP（Hypertext Transfer Protocol）是最常用的协议之一。当我们谈论WWW时，我们实际上是在谈论一种信息系统，它包括了许多不同的技术和协议，它使得用户能够通过互联网访问和浏览各种信息资源。
2.3FTP协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的标准网络协议。通过FTP，用户可以上传（将文件从本地计算机传输到远程服务器）和下载（将文件从远程服务器传输到本地计算机）文件。
以下是FTP协议的一些关键特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2348a47a729861e28cb7993d47fc413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3185b1691e977574dd90c7763425c7/" rel="bookmark">
			[数据集][目标检测]铁路工人工服安全帽检测数据集3065张3类别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集格式：Pascal VOC格式+YOLO格式(不包含分割路径的txt文件，仅仅包含jpg图片以及对应的VOC格式xml文件和yolo格式txt文件)
图片数量(jpg文件个数)：3065
标注数量(xml文件个数)：3065
标注数量(txt文件个数)：3065
标注类别数：3
标注类别名称:["cloth","hat","person"]
每个类别标注的框数：
cloth 框数 = 7883
hat 框数 = 6515
person 框数 = 7973
总框数：22371
使用标注工具：labelImg
标注规则：对类别进行画矩形框
重要说明：暂无
特别声明：本数据集不对训练的模型或者权重文件精度作任何保证，数据集只提供准确且合理标注
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b06e7fe86d3590dbefe28ecd4c18c7f/" rel="bookmark">
			【愚公系列】2024年02月 大数据教学课程 022-欠得有点多，我会努力的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆 作者简介，愚公搬代码
🏆《头衔》：华为云特约编辑，华为云云享专家，华为开发者专家，华为产品云测专家，CSDN博客专家，CSDN商业化专家，阿里云专家博主，阿里云签约作者，腾讯云优秀博主，腾讯云内容共创官，掘金优秀博主，51CTO博客专家等。
🏆《近期荣誉》：2022年度博客之星TOP2，2023年度博客之星TOP2，2022年华为云十佳博主，2023年华为云十佳博主等。
🏆《博客内容》：.NET、Java、Python、Go、Node、前端、IOS、Android、鸿蒙、Linux、物联网、网络安全、大数据、人工智能、U3D游戏、小程序等相关领域知识。
🏆🎉欢迎 👍点赞✍评论⭐收藏
文章目录 🚀前言🚀一、Chrome浏览器环境搭建🔎1.安装Google Chrome浏览器🔎2.下载和安装Chrome Driver 🚀二、使用Python Selenium编写自动化UI测试脚本🔎1.安装Selenium库🔎2.自动化UI测试脚本编写 🚀三、运行自动化UI测试脚本🔎1.首次执行与错误解决🔎2.再次执行🦋2.1 数据绑定案例☀️2.1.1🌈2.1.1.1🍬2.1.1.1.1 🚀四、结论🚀感谢：给读者的一封信 🚀前言 🚀一、Chrome浏览器环境搭建 🔎1.安装Google Chrome浏览器 🔎2.下载和安装Chrome Driver 🚀二、使用Python Selenium编写自动化UI测试脚本 🔎1.安装Selenium库 🔎2.自动化UI测试脚本编写 🚀三、运行自动化UI测试脚本 🔎1.首次执行与错误解决 🔎2.再次执行 🦋2.1 数据绑定案例 ☀️2.1.1 🌈2.1.1.1 🍬2.1.1.1.1 🚀四、结论 🚀感谢：给读者的一封信 亲爱的读者，
我在这篇文章中投入了大量的心血和时间，希望为您提供有价值的内容。这篇文章包含了深入的研究和个人经验，我相信这些信息对您非常有帮助。
如果您觉得这篇文章对您有所帮助，我诚恳地请求您考虑赞赏1元钱的支持。这个金额不会对您的财务状况造成负担，但它会对我继续创作高质量的内容产生积极的影响。
我之所以写这篇文章，是因为我热爱分享有用的知识和见解。您的支持将帮助我继续这个使命，也鼓励我花更多的时间和精力创作更多有价值的内容。
如果您愿意支持我的创作，请扫描下面二维码，您的支持将不胜感激。同时，如果您有任何反馈或建议，也欢迎与我分享。
再次感谢您的阅读和支持！
最诚挚的问候， “愚公搬代码”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ebe3473f97555926ab030513146db3/" rel="bookmark">
			微信小程序的页面制作---常用组件及其属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序里的组件就是html里的标签，但其组件都自带UI风格和特定的功能效果
一、常用组件 view（视图容器）、text（文本）、button（按钮）、image（图片）、form（表单）、video（视频）、checkbox（复选框）、radio（单选框）、input（输入框）、audio（音频）
二、view组件常用属性 （1）hover-start-time （number型） 手指按住后多久出现点击态 单位毫秒
（2）hover-stay-time （number型） 手指松开后点击保留时间 单位毫秒
（3）hover-class （string型） 指定手指按下去的样式，当该属性值为none时无点击态
（4）hover-stop-propagation （boolean型） 指定是否阻止本节点的祖先节点出现点击态
&lt;view hover-class="touchClass"&gt;第一个view&lt;/view&gt; &lt;view hover-class="touchClass" hover-start-time="3000"&gt;第二个view&lt;/view&gt; &lt;view hover-class="touchClass" hover-stay-time="3000"&gt;第三个view&lt;/view&gt; 三、image组件常用属性 image组件默认宽度为300px，默认高度为240px
（1）写法
&lt;image src='...' /&gt;
&lt;image&gt;&lt;/image&gt;
（2）属性
src （string型） 图片资源地址
mode （string型） 图片裁剪、缩放模式
webp、fade-in、show-menu-by-longpress...
（3）mode属性值：
缩放：
1》aspectFit 保持宽高比缩放图片，可完整地将图片显示出来
2》scaleToFill （默认） 不保持宽高比缩放图片，将图片宽高完全拉伸填满image元素
3》aspectFill 保持宽高比缩放图片，图片通常只在水平或垂直方向上完整，另一方向会截取
4》widthFix 宽度不变高度自动变化。保持原图宽高比不变
5》heightFix 高度不变宽度自动变化。保持原图宽高比不变
裁剪：
1》top 只显示图片的顶部区域
2》top left 只显示图片的左上区域
3》bottom、center、left、right、top right、bottom left、bottom right...
&lt;image src="../../images/demo01.jpg" mode="aspectFit"&gt;&lt;/image&gt; &lt;image src="../../images/demo01.jpg" mode="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ebe3473f97555926ab030513146db3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3499beb51935dda09733d1c15bb15965/" rel="bookmark">
			ES6：可迭代对象（Iterable object）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 可迭代对象是数组的泛化，是定义了内置迭代器方法 Symbol.iterator 的对象。是可以在for..of 循环中使用的对象。
二、迭代器（iterator） 为了让对象可以迭代，我们需要给对象添加一个迭代器--Symbol.iterator。
迭代器是一个包含next（）方法的对象，next（）是一个需要自定义的方法，用于定义每次调用时应返回的值和是否完成迭代的条件。
例如：
&lt;script&gt; let range = { a: 1, b: 5, }; // 1. for..of 调用首先会调用这个： range[Symbol.iterator] = function () { // 返回迭代器对象（iterator object）： // 2. 接着定义next() 方法 return { current: this.a, last: this.b, // 3. next() 在 for..of 的每一轮循环迭代中被调用 next() { // 4. 它将会返回 {done:.., value :...} 格式的对象 if (this.current &lt;= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } }, }; }; // 现在它可以运行了！ for (let num of range) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3499beb51935dda09733d1c15bb15965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78e989b3a73ecb2c0feb5bc33fc2d50/" rel="bookmark">
			【前端】-css的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💖作者：小树苗渴望变成参天大树🎈
🎉作者宣言：认真写好每一篇博客💤
🎊作者gitee:gitee✨
💞作者专栏：C语言,数据结构初阶,Linux,C++ 动态规划算法🎄
如 果 你 喜 欢 作 者 的 文 章 ，就 给 作 者 点 点 关 注 吧！
文章目录 前言一、什么是css二、引入css2.1内部样式表2.2 行内样式表2.3外部样式表 三、选择器3.1基础选择器3.2 复合选择器 四、常用元素属性4.1字体属性4.2文本属性4.3背景属性4.4圆角矩形 五、元素的显示模式5.1块级元素5.2行内元素 六、盒模型七、弹性布局八、案例九、总结 前言 我们上一篇讲解完html学习了网页的框架的，即使在html中有部分可以改变样式的属性，但是远远不够，而且html中修改样式的方法，在css中都可以实现，所以css才是我们样式的重点，css不难，难点在于属性多，但是你不需要全部记得，在学习的过程中进行记忆和补充，所以这篇博客就是带大家学习除了属性外的一些基础语法，属性是不会全部都讲解和演示的，话不多说，我们开始进入正文的讲解
学习目标：
掌握 CSS 基本语法规范和代码书写风格掌握 CSS 选择器的各种用法熟练使用 CSS 中的常用属性. 一、什么是css (1)层叠样式表 (Cascading Style Sheets).
CSS 能够对网页中元素位置的排版进行像素级精确控制, 实现美化页面的效果. 能够做到页面的样式和结构分离.
CSS 就是 “东方四大邪术” 之化妆术
(2)基本语法规范
选择器 + {一条/N条声明}
选择器决定针对谁修改 (找谁)
声明决定修改啥. (干啥)
声明的属性是键值对. 使用 ; 区分键值对, 使用 : 区分键和值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78e989b3a73ecb2c0feb5bc33fc2d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff583d63f6dafb93ba379a4430c7fb7/" rel="bookmark">
			Mysql主从之keepalive&#43;MySQL高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Keepalived概述
keepalived 是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。
keepalived 是以VRRP 协议为实现基础的，VRRP 全称VirtualRouter Redundancy Protocol，即虚拟路由冗余协议。虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N 台提供相同功能的路由器组成一个路由器组，这个组里面有一个master 和多个backup，master 上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master 会发组播，当backup收不到vrrp 包时就认为master 宕掉了，这时就需要根据VRRP 的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。
二、keepalived 主要有三个模块，分别是core、check 和vrrp。
core：模块为keepalived 的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。
check：负责健康检查，包括常见的各种检查方式。
vrrp：模块是来实现VRRP 协议的。
Keepalived环境说明
mysql主数据库IP地址master1:192.168.179.10（已搭建主从复制）
mysql备数据库IP地址backup:192.168.179.12（已搭建主从复制）
VIIP虚拟IP地址:192.168.179.15（keepalived 用于漂移的浮动ip地址）
查看安装路径文件：rpm -ql keepalived
三、配置文件
3.1、keepalived 心跳检测脚本（mysql两台服务器都需要配置）
cat /usr/mysql/chk_mysql.sh #!/bin/bash counter=$(netstat -na|grep "LISTEN"|grep "3306"|wc -l) if [ "${counter}" -eq 0 ]; then systemctl stop keepalived fi 3.2、master节点keepalived配置（192.168.179.10数据库服务器节点）
!Configuration File for keepalived global_defs { notification_email { ceshi@qq.com } notification_email_from ceshi@qq.com smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id MASTER-HA } vrrp_script chk_mysql_port { #检测mysql服务是否在运行。用脚本检测等等 script "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff583d63f6dafb93ba379a4430c7fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565d16fba65ca3706ceacb01c5bcdeeb/" rel="bookmark">
			[数据集][目标检测]铝片表面工业缺陷检测数据集VOC&#43;YOLO格式400张4类别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集格式：Pascal VOC格式+YOLO格式(不包含分割路径的txt文件，仅仅包含jpg图片以及对应的VOC格式xml文件和yolo格式txt文件)
图片数量(jpg文件个数)：400
标注数量(xml文件个数)：400
标注数量(txt文件个数)：400
标注类别数：4
标注类别名称:["ca_shang","zang_wu","zhe_zhou","zhen_kong"]
每个类别标注的框数：
ca_shang 框数 = 270
zang_wu 框数 = 456
zhe_zhou 框数 = 124
zhen_kong 框数 = 212
总框数：1062
使用标注工具：labelImg
标注规则：对类别进行画矩形框
重要说明：暂无
特别声明：本数据集不对训练的模型或者权重文件精度作任何保证，数据集只提供准确且合理标注
示例：
下载地址：https://download.csdn.net/download/FL1623863129/88981066
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>