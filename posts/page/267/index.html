<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb731cbea286f1c3642d591710b271b/" rel="bookmark">
			Filesystem Hierarchy Standard (FHS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux目录配置的依据：FHS，即文件系统层次结构标准。
FHS的主要目的是让用户了解已安装的软件放置在哪个目录下，即FHS的重点在于规范每个特定的目录下应该放置什么样的数据。
FHS依据文件系统使用的频繁程度与是否允许用户随意修改，将目录定义成四种形态：
shareableunshareablestatic/usr（软件存放处）/etc（配置文件）/opt（第三方软件）/boot（启动与内核文件）variable/var/mail（用户邮箱）/var/run（程序相关）/var/spool/news（新闻组）/var/lock（程序相关） shareable：能够分享给其他主机挂载使用。
unshareable：与自身机器有关，如自己机器上面运行的设备文件或与程序有关的socket文件等。
static：不随着发行版变动，如函数库、文件说明、系统管理员所管理的主机服务配置文件等。
variable：经常修改，如日志文件、一般用户可自行接收的新闻组等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802a8eba1d53efc90c7ec639dc8055ab/" rel="bookmark">
			A股月份效应的研究——基于python量化视角(backtrader回测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A股月份效应的研究 前言 《易经》早就揭示出：物极必反，盛极必衰！
阴阳总是不断交替的。股票市场也一样，涨跌互现，涨多了会出现调整，跌多了会出现反弹，因此我们看到K线组合总是红（阳）绿（阴）相间的。
正是由于市场行情总是阴阳交替出现，交易者们才孜孜不倦地想通过择时（选股）来获取超额收益。指数的走势是各方资金博弈的结果，而博弈的过程存在一个时间的延续性，也就是说过去的走势对未来走向有一定的参考价值。
尽管过去不能代表未来，但统计发现历史总是“惊人的相似”，比如“月份效应”。实际上，不少实证研究发现大多数市场存在“月份效应”，即存在某个或某些特定月份的平均收益率年复一年显著地异于其他各月平均收益率的现象。
一、月度收益率分析 # 月份效应 # 获取数据 import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.patches as mpatches #正常显示画图时出现的中文和负号 from pylab import mpl mpl.rcParams['font.sans-serif']=['SimHei'] mpl.rcParams['axes.unicode_minus']=False def get_daily_ret(security,start_date,end_date): df=get_price(security, start_date,end_date, frequency='daily', fields=['open','close','high','low','volume','money']) df.index=pd.to_datetime(df.index) # 计算收益率 daily_ret=df['close'].pct_change() # 删除缺失值 daily_ret=daily_ret.dropna() return daily_ret # 月度收益情况 def plot_monthly_ret(security,title): daily_ret=get_daily_ret(security,start_date,end_date) monthly_ret=daily_ret.resample('M').apply(lambda x:((1+x).prod()-1)) plt.rcParams['figure.figsize']=[20,5] monthly_ret.plot() start=monthly_ret.index[0] end=monthly_ret.index[-1] #显示月收益率大于3/4分位数的点 dates=monthly_ret[monthly_ret&gt;monthly_ret.quantile(0.75)].index for i in range(0,len(dates)): plt.scatter(dates[i], monthly_ret[dates[i]],color='r') labs = mpatches.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802a8eba1d53efc90c7ec639dc8055ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2524f73842690e5e9d9c073673decbde/" rel="bookmark">
			面向C/C&#43;&#43;的json解析和合成的第三方库cJson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在项目中经常要用到json格式数据进行通讯，特别是还要做ARM开发板上实现，处理JSON，自己手撕数据处理是件麻烦的事情，不过现在我们有第三方库了！那就是cJson！
环境准备 cJson官方库：
https://github.com/DaveGamble/cJSONhttps://github.com/DaveGamble/cJSON或者：
git clone https://github.com/DaveGamble/cJSON 只需要保留cJSON.c和cJSON.h两个核心文件。
通俗讲解 首先呢，cJSON提供了一种变量类型叫cJSON，我们通过看cJSON.h文件可知其是个结构体：
/* The cJSON structure: */ typedef struct cJSON { /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */ struct cJSON *next; struct cJSON *prev; /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */ struct cJSON *child; /* The type of the item, as above.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2524f73842690e5e9d9c073673decbde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425898dabd99f09dfc336134026a6d24/" rel="bookmark">
			水排序谜题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，背景
二，水排序谜题
三，状态空间
四，全局状态策略
五，局部启发式策略——关键颜色策略
1，辅助信息——关键颜色
2，辅助信息如何指导我们找到解
3，如何确定关键颜色
（1）距离管口的位置
（2）被压制的颜色数
（3）关键颜色的本质
（4）自由度的传递
六，局部启发式策略——关键颜色进阶
1，二级关键颜色
2，PageRank
3，ABAB模型
4，ABCA模型
5，ABBA模型（循环压制模型）
七，单点处理策略——死锁识别
1，循环压制死锁
2，单色压制死锁
3，死锁组合
八，终极形态
1，终极形态
2，图谱、算法求解
3，终极形态的策略
4，终极形态的策略总结
5，难关——第100关
6，主线推关
九，每日挑战
1，1月挑战
2，2月挑战
3，3月挑战
4，4月-7月挑战
十，DFS求解
1，思路
2，代码
3，算法优缺点
4，实战
5，BUG修复
十一，Opencv求解
一，背景 本游戏是我在总结出启发式游戏综述启发式游戏综述_nameofcsdn的博客-CSDN博客之后的第一个实践，我将用模型的语言来表达。
按照这个模型，本游戏和华容道汽车华容道_nameofcsdn的博客-CSDN博客_汽车华容道160关攻略其实很像。
二，水排序谜题 通过把水倒来倒去，最终同色水都在一个试管内即可。
任何水都可以倒入空试管，如果是非空试管，那么只有同色水可以倒入，
试管满了就不能再倒了，实际上试管的大小就是4，单份水的大小就是1
为了方便描述，这里统一术语
元素：一个试管内，1份或多份同色相连的水，叫一个元素
试管对称性：最终状态下，各色水和各试管并没有固定的对应关系，实际上，水和试管的任何对应关系都是可达状态。
三，状态空间 所有试管内的水构成一个状态，一次倒水就是一次状态转移，这种状态转移是不可逆的。
状态空间是有向图，在试管对称性的意义上，有唯一目标状态。
状态空间很接近树，因为没有有向环，无向环也很少。
所以，这个游戏大部分时候面临的选择都很少，
四，全局状态策略 如果1个试管是上A下B，另外1个试管是上B下A，那么至少要另外一个辅助试管，才能完成水排序。（参见下文死锁模型）
如果情况复杂一点，多个试管内的元素都是交叉覆盖的，就会出现至少需要两个辅助试管的情况。
总之，我们首先得到一个全局策略：
每隔一段操作，就会出现一次状态转移，从没有空试管，变成有一个空试管。
如第13关：
到这里，后面就没什么难度了。
五，局部启发式策略——关键颜色策略 1，辅助信息——关键颜色 这个游戏需要的辅助信息属于比较明显的类型，那就是对于初始状态，我们应该把哪个颜色的元素倒入空试管呢？
我把这个叫做关键颜色。
2，辅助信息如何指导我们找到解 策略指导我们，把关键颜色的元素倒入空试管之后，尽可能多的把同色元素都倒入此试管，这样其他试管才有足够空间来调度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425898dabd99f09dfc336134026a6d24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43c2c58c534b26c9b8a38f1447451a7/" rel="bookmark">
			Ubuntu20.04 C&#43;&#43;程序的简单编译及QT和Pycharm的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用gcc来编译c++程序,如下两个命令完成了创建c++程序及打开文本编辑程序
2.拿牛客网上第HJ6求质数因子题（华为机试题库_在线编程+题解_牛客题霸_牛客网）代码进行测试，代码编辑如下：
#include &lt;iostream&gt; using namespace std; int main() { long n; cin&gt;&gt;n; for(int i=2;i*i&lt;=n;i++) { while(n % i ==0) { n = n/i; cout &lt;&lt; i &lt;&lt; " "; if(n == 1) { break; } } } if(n&gt;=2) { cout &lt;&lt; n; } } 3.使用接下来的命令进行程序的编译及程序的运行
4.可以看到输入整数20个，获得了正确的质数解，分别为2,2,5
5.若通过构造CMakeList.txt来执行编译，则除了上面的test.cpp外，还需要构造一个CMakeLists.txt文件及build空文件夹。
test.cpp中的代码同上，CMakeLists.txt中的文本如下：
cmake_minimum_required(VERSION 2.8) #工程名 project(Test) #包含原程序,即把给定目录下的源程序复制给变量DIR_SRC #将指定路径下的源文件储存在指定的变量中 #下面这句话，有些博客中写错了，需要注意 aux_source_directory(./ DIR_SRC ) #生成程序 add_executable(Test ${DIR_SRC}) 此处需要用到cmake命令，若cmake包未装，可以使用如下命令，安装过程中选择Y
sudo apt install cmake 6.使用如下命令来完成cmake编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43c2c58c534b26c9b8a38f1447451a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c2ea459a05c69f0a6466adebf6bcf9/" rel="bookmark">
			leetcode 包含min函数的栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
考察点 主要考察的是数据结构中的栈的操作和提升min()的效率。包括push.pop.min
min():如果使用遍历的方法，时间复杂度为O（N）。如果想降低时间复杂度，可以利用辅助栈的方法。
栈2：用来存储历史最小值。即每次的入栈1的值与上一次的最小值比较，如果小就入栈2.
代码 stack&lt;int&gt; s1, s2; public:
/** initialize your data structure here. */
MinStack() {
} void push(int x) { s1.push(x); // 判断当前的最小元素 if(s2.empty() || x &lt;= s2.top()) s2.push(x); else s2.push(s2.top()); } void pop() { s1.pop(); s2.pop(); } int top() { return s1.top(); } int min() { return s2.top(); } };
收获 peek():是读取一个字符，但指针并不移动，原字符也不删除。
栈的top()与pop()区别。top取栈顶的值，不更改栈，并且有返回值。pop删除栈顶的值，无返回值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c5c090d52ef13b0882c7f428c29add/" rel="bookmark">
			蓝桥杯——无聊的逗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：蓝桥杯算法训练 知识点：动态规划，等和子集 问题描述
逗志芃在干了很多事情后终于闲下来了，然后就陷入了深深的无聊中。不过他想到了一个游戏来使他更无聊。他拿出n个木棍，然后选出其中一些粘成一根长的，然后再选一些粘成另一个长的，他想知道在两根一样长的情况下长度最长是多少。
输入格式
第一行一个数n，表示n个棍子。第二行n个数，每个数表示一根棍子的长度。
输出格式
一个数，最大的长度。
样例输入
4
1 2 3 1
样例输出
3
数据规模和约定
n&lt;=15
问题分析 本题参考了这位博主的解法，讲得很好，点这里看。
这里使用了“0-1背包”的解法，关于“0-1背包”的内容可以看这里。
另外，关于代码中使用到的accumulate求和可以看这里，max_element最大值可以看这里，vector的用法看这里。
代码 #include &lt;bits/stdc++.h&gt; using namespace std; int getMaxLength(vector&lt;int&gt; lens) { int n = lens.size(); if(n &lt; 2) return 0; int sum = accumulate(lens.begin(), lens.end(), 0); int maxLen = *max_element(lens.begin(), lens.end()); int target = sum / 2; if(maxLen &gt; target) return 0; vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(target+1, 0)); for(int i=0; i&lt;n; i++) dp[i][0] = 0; for(int j=lens[0]; j&lt;=target; j++) dp[0][j] = lens[0]; for(int i=1; i&lt;n; i++) { for(int j=1; j&lt;=target; j++) { if(j &lt; lens[i]) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j], dp[i-1][j-lens[i]] + lens[i]); } } return dp[n-1][target] == sum/2 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c5c090d52ef13b0882c7f428c29add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216740fd712140436bbb30ec27085eac/" rel="bookmark">
			NoProviderFoundException: Unable to create a Configuration, because no Bean Validation provider coul
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022-01-30 11:31:56.666 WARN 22492 --- [ main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.alibaba.cloud.sentinel.custom.SentinelAutoConfiguration': Unsatisfied dependency expressed through field 'properties'; nested exception is org.springframework.boot.context.properties.ConfigurationPropertiesBindException: Error creating bean with name 'spring.cloud.sentinel-com.alibaba.cloud.sentinel.SentinelProperties': Could not bind properties to 'SentinelProperties' : prefix=spring.cloud.sentinel, ignoreInvalidFields=false, ignoreUnknownFields=true; nested exception is javax.validation.NoProviderFoundException: Unable to create a Configuration, because no Bean Validation provider could be found. Add a provider like Hibernate Validator (RI) to your classpath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216740fd712140436bbb30ec27085eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd03040f8450e7e9bd3172b97d9366b/" rel="bookmark">
			minio上传和下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import brave.Tracer; import com.alibaba.fastjson.JSONObject; import com.alibaba.xiaomi.commonbase.*; import io.minio.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import java.io.InputStream; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * @Author 楚璃轩 * @Date 2021/12/8 16:42 * @Description 上传和下载 */ @RestController @RequestMapping("/common-manager") public class MinioFileUploadController { private static Logger logger = LoggerFactory.getLogger(MinioFileUploadController.class); private RedisUtil redisUtil = SpringConfig.getBean(RedisUtil.class); public static SimpleDateFormat sdf = new SimpleDateFormat(DateUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd03040f8450e7e9bd3172b97d9366b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9491f0bada94321d62861ce277dab6d9/" rel="bookmark">
			操作系统实验3—实现请求页式存储管理模拟程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验3—实现请求页式存储管理模拟程序 文章目录 操作系统实验3—实现请求页式存储管理模拟程序实验描述设计思路上机代码测试结果心得体会 实验描述 实验内容：
编写一个请求页式存储管理程序，模拟请求页式存储管理方式下的内存分配和页面置换。
实验目的：
内存管理是操作系统中的核心模块，能够合理利用内存，在很大程度上将影响到整个计算机系统的性能。内存的分配和回收与内存管理方式有关。本实验要求学生独立设计并实现请求页式存储管理方式下的内存分配与页面置换模拟程序，以加深对页面置换算法和请求页式存储管理方式的理解。
实验要求：
可以随机输入分配给一个进程的内存块数，以及该进程的页面访问序列，具体信息见测试用例格式输入部分说明。分别采用最佳算法OPT（当有多个页面可置换时，按照先进先出原则进行置换）、先进先出算法FIFO和最近最少使用算法LRU进行页面置换，其中LRU算法采用栈式方法实现。显示页面变化时内存块装入页面列表的详细情况，并显示是否产生页面置换，并计算缺页次数及缺页率。具体信息见测试用例格式输出部分说明。 测试用例格式如下：
输入：
算法（1--OPT，2--FIFO，3--LRU） 内存块数 页面序列（页面1,页面2,页面3,...） 输出：
页面变化时内存块装入页面列表1-是否命中/页面变化时内存块装入页面列表2-是否命中/... 缺页次数 其中： 页面变化时内存块装入页面列表： (1) 内存块1装入页面,内存块2装入页面,内存块3装入页面...，未装入任何页面时由"-”表示 (2) 是否命中：1-命中，0-缺页 测试输入期待的输出时间限制内存限制额外进程测试用例 11
3
1,2,3,4,1,2,5,1,2,3,4,51,-,-,0/1,2,-,0/1,2,3,0/1,2,4,0/1,2,4,1/1,2,4,1/1,2,5,0/1,2,5,1/1,2,5,1/3,2,5,0/3,4,5,0/3,4,5,1
71秒64M0测试用例 22
4
1,2,3,4,1,2,5,1,2,3,4,51,-,-,-,0/1,2,-,-,0/1,2,3,-,0/1,2,3,4,0/1,2,3,4,1/1,2,3,4,1/5,2,3,4,0/5,1,3,4,0/5,1,2,4,0/5,1,2,3,0/4,1,2,3,0/4,5,2,3,0
101秒64M0测试用例 33
3
1,2,3,4,1,2,5,1,2,3,4,51,-,-,0/1,2,-,0/1,2,3,0/2,3,4,0/3,4,1,0/4,1,2,0/1,2,5,0/2,5,1,1/5,1,2,1/1,2,3,0/2,3,4,0/3,4,5,0
101秒64M0 设计思路 虽然每次输入的页面数据只有页面序号，但是在算法中需要计算每个页面访问过之后的优先级变化，以及当前页面下一次访问所需要的距离信息，所以采用结构体数组的形式将需要用到的信息全部存储起来。
临时数组在 LRU 算法中起辅助输出的作用。
struct Memory { int id;	//序号 int priority;	//最前面的内存优先级为0，往后依次加1 int distance;	//下次访问与当前距离 }memory[1010], memory2[1010];//内存序列，临时数组 程序概要设计如下图所示：
main（）函数是主程序的入口，控制程序流程，并按照输入的调度信号选择相应的算法模块进行运行input（）函数是输入函数，接受程序输入output（）函数是输出函数，将页面命中与缺页置换的信息进行输出OPT（）函数是最佳置换算法，根据已知的页面序列和优先级顺序算出最佳的页面调度方案FIFO（）函数是先进先出算法，根据页面的到来顺序进行页面置换LRU（）函数是最近最久未使用算法，根据页面的使用情况进行页面调度，这里使用了临时数组来辅助信息输出 int main();	//主程序入口 void input();	//输入函数 void output(int k);//输出函数 void OPT();	//最佳置换算法 void FIFO();	//先进先出算法 void LRU();	//最近最久未使用算法 上机代码 代码使用 C++ 语言进行编写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9491f0bada94321d62861ce277dab6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ecd5ad1ae14c1cca1ee125e5e81ac8/" rel="bookmark">
			PyQt之QSS美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt之QSS美化 一、QSS讲解1、QSS的规则2、属性列表3、子控件4、组件伪状态列表 二、现成的QSS样式1、QDarkStyleSheet2、QCandyUi3、飞扬青云-QSS 一、QSS讲解 QSS称为Qt Style Sheets也就是Qt样式表，它是Qt提供的一种用来自定义控件外观的机制。QSS大量参考了CSS的内容，只不过QSS的功能比CSS要弱很多，体现在选择器要少，可以使用的QSS属性也要少很多，并且并不是所有的属性都可以用在Qt的所有控件上。
QSS样式表支持各种属性、伪状态和子控件，可以自定义小部件的外观。
1、QSS的规则 QSS的语法规则几乎与CSS相同，QSS样式由两部分组成，其中一部分是选择器（Selector），指定哪些软件会受到 影响，另一部分是声明（Declaration），指定哪些属性应该在控件上进行设置，声明部分是一系列的“属性：值”对， 使用（；）分割各个不同的属性值对，使用大括号（{}）将所有的声明包括在内，例如 QPushButton{color：red} 2、属性列表 这里的属性不是所有，只列举常用的。
属性说明演示background用于设置背景。这里的背景可以是背景颜色、
背景图像等。QTextEdit { background: yellow }background-color背景颜色QLabel { background-color: yellow }
QLineEdit { background-color: rgb(255, 0, 0) }border边框。等效于指定边框颜色、边框样式和
边框宽度，作用等同于下面几个设置边框
的组合。QLineEdit { border: 1px solid white }border-top
border-right
border-bottom
border-left指定特定位置边框QLineEdit { border-top: 1px solid white }border-color设置边框颜色，同样也可以指定具体位置QLineEdit {border-color: white;}
QLineEdit {border-top-color: white;}border-radius边框角弧度，同样也可以指定具体位置QLineEdit {border-radius: 4px;} QLineEdit {border-top-radius: 4px;}border-style边框样式，同样也可以指定具体位置QLineEdit {border-style: solid;}
{border-top-style: solid;}border-width边框宽度，同样也可以指定具体位置QTextEdit {border-width: 2px; }
{border-top-width: 2px;}color渲染文本的颜色。QPushButton { color: red }font用于设置文本字体的统写形式。 等效于
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ecd5ad1ae14c1cca1ee125e5e81ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f41ca7e4df53e564766e8aa4a8be91/" rel="bookmark">
			IAR sprintf 浮点 在UCOS 总格式化成0.0的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述:
当使用uocs printf(),sprintf()打印浮点数问题会出问题,但是裸机不会出问题
我现在使用LPC1758跑UCOS，在使用sprintf打印float类型时候，不管是何值最后都是0.0，但是类型是int,short类型时没有问题。网上查到是任务堆栈8字节对齐就可以了。
当没有操作系统时,系统堆栈是8字节对齐的,但是当使用ucos时,用户任务不一定是8字节对齐.
Task 3 中的堆栈起始指针0x1000000F4,不是8字节对齐,所以但在Task 3 任务中调用printf等系列函数就会出现问题.
2. 解决方法
我用的是IAR,通过#pragma data_alignment指定对齐字节数
#pragma data_alignment=8 //如果不是8字节对齐，sprintf的浮点数将输出0.0
static OS_STK App_TaskWorkModeCntStk[APP_CFG_TASK_WORKMODE_CNT_STK_SIZE];
OS_STK T_Stk[Task1_LED1_Stk_Size];
可知给任务分配栈时需要保证栈是8字节对齐的，不然在该任务中凡是调用sprintf的函数
均会出错，因为栈一开始就是不对齐的。
3. 八字节对齐原因
这事儿的历史在于ARM本身不支持非对齐数据存取；因此在有了64Bit的数据操作指令后，指令要求8字节对齐。进而，在编译器的某个版本之后（RVCT3？），AAPCS就要求堆栈8字节对齐。
是先有8字节对齐的AAPCS，然后才有的CM3。先后顺序要注意。CM3 r2p0之前，自动压栈也不要求8对齐，r2p0好像才是强制对齐的。
printf的8对齐是C运行库要求的，和硬件无关，C RTL手册有写，可以去阅读。其根源在于AAPCS要求；而AAPCS根源在于LDRD这类指令。
换句话，未来如果128Bit数据操作有了，ARM还不支持非对其，那AAPCS可能升级为16字节对齐。
供参考，CM3和C-RTL对齐的问题。
感谢博主 enzo26的ChinaUnix博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54ae52ab1fe33223b9c983b11acac09/" rel="bookmark">
			visual studio安装 &amp; 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. vs版本1.1 如何查看vs版本对应的系统1.2 如何查看本机的系统信息1.3 如何找到并下载正确的vs版本1.4 其他下载方式 2. vs安装2.1 双击下载好的exe开始安装2.2 选择需要的组件、语言包等2.3 修改或查看 安装等 位置2.4 然后点击安装2.5 小结 3. 开始使用vs3.1 打开vs20193.2 新建项目3.2.1 新建项目3.2.2 项目的 资源管理器3.2.3 项目的依赖 3.3 文件（cpp h 等）3.3.1 创建文件3.3.2 文件的依赖 3.4 代码：开发 编译 调试3.4.1 代码开发 &amp; 编译3.4.2 代码调试 3.5 试验 项目结构3.5.1 文件结构3.5.2 简单代码 &amp; 测试 3.6 生成类图3.6.1 安装新插件3.6.2 查看类图 3.7 引用其他项目3.7.1 在解决方案中添加新项目3.7.2 引用其他项目3.7.3 关于批量注释 4.小结 简介：这篇文主要介绍 在 windows上 如何安装 visual studio （用于 c++ 开发），以及一些简单功能的使用（新建项目、编译调试、生成类图(包含新增插件)、引用其他项目）。 1. vs版本 vs的版本有系统要求，所以选择正确的版本很重要。
值得一提的是，运用 官方提供的 文档 很重要： https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f54ae52ab1fe33223b9c983b11acac09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a21caee961eb3e7606b9bc98bbccd26/" rel="bookmark">
			element-ui el-input type=“number“ 清除上下箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在全局 css 加上
input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; } input[type="number"]{ -moz-appearance: textfield; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d734201776c97a354f77d90c10f08d55/" rel="bookmark">
			操作系统实验1—实现单处理机下的进程调度程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验1—实现单处理机下的进程调度程序 文章目录 操作系统实验1—实现单处理机下的进程调度程序实验描述设计思路上机代码测试结果心得体会 实验描述 实验内容：
编写一个单处理机下的进程调度程序，模拟操作系统对进程的调度。
实验目的：
进程是操作系统中最基本、最重要的概念，进程调度又是操作系统的核心模块。本实验要求学生独立设计并实现进程调度模拟程序，以加深对进程控制块概念和各种进程调度算法的理解。
实验要求：
可以随机输入若干进程，支持先来先服务、短作业优先、最短剩余时间优先、时间片轮转、动态优先级调度算法，能够输出进程的调度过程。具体信息见测试用例格式说明。每个进程由一个进程控制块表示。实现先来先服务调度算法：进程到达时间可由进程创建时间表示。进程到达时间相同时，优先处理进程号小的进程。实现短作业优先调度算法：可指定进程要求的运行时间。进程运行时间相同时，按照先来先服务原则进行处理。实现最短剩余时间优先调度算法：可指定进程要求的运行时间。进程运行时间相同时，按照先来先服务原则进行处理。实现时间片轮转调度算法：可指定生成时间片大小。进程到达时间相同时，优先处理进程号小的进程；进程执行完一个时间片进入就绪队列时，其优先级低于首次进入就绪队列的进程。实现动态优先级调度算法：可指定进程的初始优先级（优先级与优先数成反比，优先级最高为0），优先级改变遵循下列原则：进程在就绪队列中每停留一个时间片（停留时间&gt;0），优先级加1，进程每运行一个时间片，优先级减3。进程到达时间相同时，优先处理进程号小的进程，且仅在时间片完或进程运行结束时发生进程调度。 测试用例格式如下：
输入：
调度算法
进程号/到达时间/运行时间/优先级/时间片
其中调度算法选项为：
1----先来先服务，
2----短作业优先，
3----最短剩余时间优先，
4----时间片轮转，
5----动态优先级
输出：
调度顺序/进程号/开始运行时间/结束运行时间/优先级
测试输入期待的输出时间限制内存限制额外进程测试用例 11
1/0/24/1/1
2/0/3/1/1
3/0/3/1/1
1/1/0/24/1
2/2/24/27/1
3/3/27/30/11秒64M0测试用例 22
1/0/7/1/1
2/2/4/1/1
3/4/1/1/1
4/5/4/1/11/1/0/7/1
2/3/7/8/1
3/2/8/12/1
4/4/12/16/11秒64M0测试用例 33
1/0/7/1/1
2/2/4/1/1
3/4/1/1/1
4/5/4/1/11/1/0/2/1
2/2/2/4/1
3/3/4/5/1
4/2/5/7/1
5/4/7/11/1
6/1/11/16/11秒64M0测试用例 44
1/0/53/1/20
2/0/17/1/20
3/0/68/1/20
4/0/24/1/201/1/0/20/1
2/2/20/37/1
3/3/37/57/1
4/4/57/77/1
5/1/77/97/1
6/3/97/117/1
7/4/117/121/1
8/1/121/134/1
9/3/134/154/1
10/3/154/162/11秒64M0测试用例 55
1/0/3/1/2
2/0/4/1/2
3/0/2/3/2
4/2/1/1/2
5/2/4/4/21/1/0/2/4
2/2/2/4/3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d734201776c97a354f77d90c10f08d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e946a476f4691de61cad993cee6eec0a/" rel="bookmark">
			37.调试---裸板调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jtag
JTAG的调试原理_代码就是生产力！-CSDN博客_jtag调试原理
arm裸板驱动总结(makefile+lds链接脚本+裸板调试) - 诺谦 - 博客园
opencd
跟我一起学OpenOCD(一) - 知乎
OpenOCD的调试_子曰小玖的博客-CSDN博客_openocd 命令
gdb:
LINUX下GDB的使用方法(简单说说)_longfan的博客-CSDN博客_gdb
一.点亮LCD
配置好硬件让LED闪烁，在需要看现象的地方插入LED闪烁的语句
二.串口打印
通过寄存器来初始化串口，裸板下注意cpu时钟，可能还没设置时钟以达到高速，所以需要设置好匹配的波特率。
使用位置无关码初始化串口，在需要打印的地方根据需要插入下面的打印函数，调用时还是使用位置无关码。字符串S不能太过复杂，否则会把S放入只读数据段先先保存，但sdram可能还没有初始化，只读数据段里都是乱码。
/* * 发送一个字符 */ void putc(unsigned char c) { /* 等待，直到发送缓冲区中的数据已经全部发送出去 */ while (!(UTRSTAT0 &amp; TXD0READY)); /* 向UTXH0寄存器中写入数据，UART即自动将它发送出去 串口的机制，往FIFO写，自动发送 */ UTXH0 = c; } void puts(char *s) { int i = 0; while (s[i]) { putc(s[i]); i++; } } void puthex(unsigned long val) { /* val = 0x1234ABCD */ unsigned char c; int i = 0; putc('0'); putc('x'); for (i = 0; i &lt; 8; i++) { /* 右移只提取一位数，如0x12345678--&gt;0x00000001 c是字符型数值，数值是它的ASCII码 */ c = (val &gt;&gt; ((7-i)*4)) &amp; 0xf; if ((c &gt;= 0) &amp;&amp; (c &lt;= 9)) { c = '0' + c; } else if ((c &gt;= 0xA) &amp;&amp; (c &lt;= 0xF)) { /*A到F的ascii是连续的*/ c = 'A' + (c - 0xA); } putc(c); } 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e946a476f4691de61cad993cee6eec0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4815f25dbb63e4c9975093f91b40e2/" rel="bookmark">
			MySQL安装遇到Start service红叉问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有好多小伙伴在安装MySQL的时候，没有进行几步就出现了与安装教程不一样的步骤，出现“Start Service“打红叉，没有全绿勾。
经过我的不断尝试，有以下一个好方法能快速解决这个问题~
1.点击电脑下方搜索按钮--&gt;搜索：计算机管理--&gt;以管理员身份运行
2.点击服务和应用程序--&gt;点击服务
3.找到MySQL8.0
4.双击MySQL8.0--&gt;在窗口上边点击登录界面--&gt;选择本地系统账户--&gt;再点击确定，回到原来的安装界面点击Execute就会出现✔了。
✔的个数对这个软件后续的使用没有任何影响，所以你不用担心，你可以坚定的点击Finish和😊
希望个方法对你有用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76aa91250734b4196aa5effbed63b1a3/" rel="bookmark">
			Win7 查看navicat数据库链接密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看注册表PWD win + r，输入regedit，打开注册表，
计算机\HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\127.0.0.1
127.0.0.1为 navicat 的连接名，点开找到Pwd
右键编辑，然后查看加密后的密码。
使用在线工具解密 网址 https://tool.lu/coderunner/
选择PHP环境；
代码 将下文代码全量粘贴进代码运行区并将上文Pwd中的加密密码复制进代码倒数第二行decrypt里面，然后点击页面上的 执行(Run)
&lt;?php namespace FatSmallTools; class NavicatPassword { protected $version = 0; protected $aesKey = 'libcckeylibcckey'; protected $aesIv = 'libcciv libcciv '; protected $blowString = '3DC5CA39'; protected $blowKey = null; protected $blowIv = null; public function __construct($version = 12) { $this-&gt;version = $version; $this-&gt;blowKey = sha1('3DC5CA39', true); $this-&gt;blowIv = hex2bin('d9c7c3c8870d64bd'); } public function encrypt($string) { $result = FALSE; switch ($this-&gt;version) { case 11: $result = $this-&gt;encryptEleven($string); break; case 12: $result = $this-&gt;encryptTwelve($string); break; default: break; } return $result; } protected function encryptEleven($string) { $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = ''; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) { $temp = $this-&gt;encryptBlock($this-&gt;xorBytes(substr($string, 8 * $i, 8), $currentVector)); $currentVector = $this-&gt;xorBytes($currentVector, $temp); $result .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76aa91250734b4196aa5effbed63b1a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1c4832cfab66ba120bfbc2400f1e37/" rel="bookmark">
			【super,this关键字和继承组合习题】金典习题 附答案与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说先上代码！！！ class Test{ //父类 String name = "Rose"; Test(){ System.out.println("Test"); } Test(String name){//name john this.name = name; } } class Demo extends Test{//子类 String name="Jack"; Demo()	{ super(); System.out.println("Demo"); } Demo(String s){ super(s); } public void test(){ System.out.println(super.name); System.out.println(this.name); } public static void main(String[] args)	{ new Demo().test(); new Demo("john").test(); } } 输出结果 Test Demo Rose Jack john Jack
从main方法看第一步先走 new Demo().test(); 1.new Demo() 创建了一个 匿名对象 然后执行Demdo的无参构造器 super(); System.out.println("Demo");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1c4832cfab66ba120bfbc2400f1e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d844e7af3f065f54cbc401357f194fc8/" rel="bookmark">
			【爬虫】python 微博评论数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
用python爬取微博评论数据，爬虫之路，永无止境。。（附源码）_主打Python的博客-CSDN博客_爬虫微博评论
# !/usr/bin/nev python # -*-coding:utf8-*- from datetime import datetime from requests_html import HTMLSession import re, time import csv # import tkinter as tk import urllib3 # 解除警告 urllib3.disable_warnings() session = HTMLSession() user_url = 'https://weibo.com/2318265821/KrBA7lvW4#comment' pass_wd = 'WEIBOCN_FROM=1110005030; SUB=_2A25Mx3mlDeRhGeNM41sV8i7KyzWIHXVsSAftrDV6PUJbkdANLUfEkW1NSeR9M3dIjq3lBi61DJC0D26LvrU8YMVV; MLOGIN=1; _T_WM=14744352522; XSRF-TOKEN=781dcc' f = open(r'评论.csv','a+',newline='') fileheader = ['a','screen_names', 'genders', 'std_create_times', 'texts', 'like_counts'] fp = csv.DictWriter(f, fileheader) # 定义表头 fp.writeheader() # 写入表头 fp = csv.writer(f) class WBSpider(object): def main(self, user_url, pass_wd): i = 1 a = 1 headers_1 = { 'cookie': pass_wd, 'user-agent': 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d844e7af3f065f54cbc401357f194fc8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/266/">«</a>
	<span class="pagination__item pagination__item--current">267/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/268/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>