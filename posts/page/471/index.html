<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1110ae404fc7af079f9bbb201f59a355/" rel="bookmark">
			gitbook电子书制作步骤（linux环境下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装
npm install gitbook -g(首先安装nodejs)
npm install -g gitbook-cli
npm install gitbook-pdf -g(输出pdf)
检查是否安装成功：
node -v
gitbook -V
2.电子书创建(举例说明如下) 1)创建电子书
mkdir TestBook
cd TestBook
gitbook init
2)编辑电子书内容(使用到md语法)
I.README.md此文件是简单的电子书介绍，可以把您所制作的电子书做一下简单的描述：
# 简介
这是我的第一本使用 GitBook 制作的电子书。
II.SUMMARY.md此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。
# Summary
* [Introduction](README.md)
* [uitest 是什么](users/index.md)
* [如何使用 uitest](users/use.md)
* [如何编写自定义的测试用例](users/case.md)
* [browserjs API 文档](users/api.md)
* [uitest 开发者文档](devs/index.md)
* [browserjs 开发者文档](devs/browserjs.md)
* [utci 文档](devs/utci.md)
* [utserver &amp; utclient 文档](devs/utserver.md)
* [相关文章沉淀](artical.md)
* [关于 gitbook](gitbook.md)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1110ae404fc7af079f9bbb201f59a355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff2450af4bb5495eb2d15f32a2d250a/" rel="bookmark">
			tensorflow 卷积、反卷积形式的去噪自编码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于去噪自编码器，网上好多都是利用全连接神经网络进行构建，我自己写了一个卷积、反卷积形式的去噪自编码器，其中的参数调优如果有兴趣的话，可以自行修改查看结果。
数据集我使用最简单的mnist：
网络结构：
mnist输入（28*28=784向量） =&gt; 28*28*1矩阵 =&gt; 卷积层1 =&gt; 14*14*64 =&gt; 卷积层2 =&gt; 7*7*64 =&gt; 卷积层3 =&gt; 4*4*32 =&gt; 反卷积层1 =&gt; 7×7*32 =&gt; 反卷积层2 =&gt; 14*14*64 =&gt; 反卷积层3 =&gt; 28*28*64 =&gt; 卷积层X =&gt; 28×28*1
训练：
我用train集训练train_epochs轮，然后用test集对训练好的模型进行评测，同时保存加噪图像及对应的去噪图像。
Code:
#! -*- coding: utf-8 -*- ## by Colie (lijixiang) import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data import numpy as np from PIL import Image train_epochs = 35 ## int(1e5+1) INPUT_HEIGHT = 28 INPUT_WIDTH = 28 batch_size = 256 noise_factor = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff2450af4bb5495eb2d15f32a2d250a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41080ed6fa7190d18616ad432a5abff4/" rel="bookmark">
			查询表达式转变为elasticsearch查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询表达式转变为elasticsearch查询语句
查询表达式：(a=1 | (b&lt;2 | c&gt;3 &amp;f&gt;6)) &amp; (d=4 | e&lt;5) | m &gt;9 注意：带括号，且为多层嵌套；且不考虑&amp;|优先级
思路：
1.切割查询表达式，使成为含有表达式，左右括号，关系&amp; | 的 list 集合
2.遍历 list 集合。关系&amp;|符号入符号栈；左括号、表达式入bool栈。遇到右括号时，则逆序遍历bool栈，并把遍历到的元素放入临时list中，直到遇到左括号为止。然后出栈，并处理这个临时list，并把返回的结果继续压入bool栈。循环处理，直到list无元素。
3.处理临时list。
3.1若只有一个元素，则变为DSL语句后，符号出栈；
3.2若为两个元素，则用符号栈的第一个元素，拼接为bool语句，符号出栈（只出一次）；
3.3若为多个元素，则每个元素拼接为bool语句时，用栈中第一个元素，每个元素用完后符号栈出栈。最后那个元素无符号，则用最后一个出栈符号。
总结：
1.其实也不算非常复杂，但处理这个问题确实花费了很长时间。关键是基础薄弱，思路不清。一开始自己也没想好怎么做，就乱写。自己都没想好乱写的逻辑还奢望计算机能理解并正确运行。真是惭愧。最后自己思路清晰了，还真得就正确了。
2.对栈理解不深刻，用法也不熟悉。需要加强。
3.对经典问题算术表达式的处理不理解。需要熟悉。
4.写的看的代码太少。何谓见多识广，游刃有余？
import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import org.elasticsearch.index.query.BoolQueryBuilder; import org.elasticsearch.index.query.QueryBuilder; import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.index.query.QueryStringQueryBuilder; public class Test4 { public static void main(String[] args) { String s = "(a=1 | (b&lt;2 | c&gt;3 &amp;f&gt;6)) &amp; (d=4 | e&lt;5) | m &gt;9"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41080ed6fa7190d18616ad432a5abff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c0852f17b1d706b04894df941c7d9a/" rel="bookmark">
			将tensorflow网络模型（图&#43;权值）保存为.pb文件，并从.pb文件中还原网络模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程结构如下：
将网络模型（图+权值）保存为.pb文件 write.py
# -*- coding: utf-8 -*- from __future__ import absolute_import, unicode_literals from tensorflow.examples.tutorials.mnist import input_data import tensorflow as tf import shutil import os.path export_dir = '../model/' if os.path.exists(export_dir): shutil.rmtree(export_dir) def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial) def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME') def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') mnist = input_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c0852f17b1d706b04894df941c7d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928f4d46e1b408b9541e6d974133a319/" rel="bookmark">
			php 读写json文件。追加，修改json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 追加写入用户名下文件 $code="001";//动态数据 $json_string = file_get_contents("text.json");// 从文件中读取数据到PHP变量 $data = json_decode($json_string,true);// 把JSON字符串转成PHP数组 $data[$code]=array("a"=&gt;"as","b"=&gt;"bs","c"=&gt;"cs"); $json_strings = json_encode($data); file_put_contents("text.json",$json_strings);//写入 //修改
$json_string = file_get_contents("text.json");// 从文件中读取数据到PHP变量
$data = json_decode($json_string,true);// 把JSON字符串转成PHP数组
$data["001"]["a"]="aas";
$json_strings = json_encode($data);
file_put_contents("text.json",$json_strings);//写入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9f2f5520b4875b39677db0cb4d98ea/" rel="bookmark">
			Dockerfile中RUN bash -c &#39;touch /app.jar&#39;是干嘛的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：1.6 Docker与微服务-使用Dockerfile构建Docker镜像
例如：
ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar RUN bash -c ‘touch /app.jar’
它的作用等同于拷贝文件到容器，也可以直接写成ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar /app.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969150fa5e1834393647f895d69de1cd/" rel="bookmark">
			node 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、检测node是否安装成功。
1.在cmd里切换到node包的根目录，然后输入node -v，会出现版本号，则成功
2.检测npm是否成功。新的node版本自带npm.安装node里也装好了npm;输入npm -v,会出现版本号，则成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b169a78401d5464971627d37c361fdf4/" rel="bookmark">
			Webstorm 激活与汉化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填写注册网址http://idea.imsxm.com/
汉化包：resources_cn.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec81739d34ba7694b35a3af232b7470d/" rel="bookmark">
			DialogFragment全屏加控件显示在底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道dialogfragment单纯的全屏显示很容易（什么什么Match_parent解决），单纯的显示在底部也很容易（什么什么Gravity.Bottom解决），但是又要全屏又要显示在底部就不容易了。
为什么呢？全屏显示，把几个控件显示在底部，你会发现这个控件神奇的消失了。
就像这样，上半部分是0dp,weight=1,到了手机上，下面这些控件不会显示，除非你上半部分的0dp改成固定的长度。
就算你使用这样的代码
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/pop_content" android:background="@color/colorPrimary"&gt; &lt;ImageView android:layout_width="50dp" android:layout_height="50dp" android:src="@mipmap/pop_close" android:layout_gravity="center_horizontal|bottom"/&gt; &lt;/FrameLayout&gt; 他会全屏变成colorprimary的颜色，并不会显示imageview。
1.使用这样的方法
WindowManager.LayoutParams attributes = window.getAttributes(); attributes.width=WindowManager.LayoutParams.MATCH_PARENT; attributes.height=WindowManager.LayoutParams.MATCH_PARENT-getBarHeight(); 他会全屏显示，但是imageview不显示 2.使用这样的方法
这种方法，他会显示imageview,但是通知栏被遮住了，我想通知栏不被遮住.因为我原本界面是显示通知栏的，弹出dialog后整个界面往上滑动.这样的效果不好.
this.setStyle(DialogFragment.STYLE_NORMAL,android.R.style.Theme_NoTitleBar_Fullscreen); WindowManager.LayoutParams attributes = window.getAttributes(); attributes.width=WindowManager.LayoutParams.MATCH_PARENT; // attributes.height=WindowManager.LayoutParams.MATCH_PARENT-getBarHeight(); 总结下来就是：1要全屏显示，2通知栏不被顶掉;
那我就自定义一个样式
&lt;style name="ShowTitleDontShowActionBar"&gt; &lt;item name="android:windowNoTitle"&gt;false&lt;/item&gt; &lt;item name="android:layout_height"&gt;match_parent&lt;/item&gt; &lt;item name="android:fitsSystemWindows"&gt;true&lt;/item&gt; &lt;item name="android:windowActionBar"&gt;false&lt;/item&gt; &lt;/style&gt; this.setStyle(DialogFragment.STYLE_NORMAL,R.style.ShowTitleDontShowActionBar); Dialog dialog = getDialog(); if(dialog!=null){ Window window = dialog.getWindow(); if(window!=null){ WindowManager.LayoutParams attributes = window.getAttributes(); attributes.width=WindowManager.LayoutParams.MATCH_PARENT; // attributes.height=WindowManager.LayoutParams.MATCH_PARENT-getBarHeight(); // attributes.gravity= Gravity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec81739d34ba7694b35a3af232b7470d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b811db3af178974cd2b75b768da0f5/" rel="bookmark">
			输出某年某月的日历页，通过 键盘输入将年份和月份时间传递到程序中。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出某年某月的日历页，通过 键盘输入将年份和月份时间传递到程序中。
import java.util.Calendar; public class Test01_GetDate { /** * 1、输出某年某月的日历页，通过 键盘输入将年份和月份时间传递到程序中。 */ public static void main(String[] args) { System.out.println(getCalendar(2017, 7)); } public static String getCalendar(int year,int month){ StringBuffer sb = new StringBuffer(); sb.append("一\t二\t三\t四\t五\t六\t日\n"); //月份要减一 month -=1; Calendar cr = Calendar.getInstance(); //设置时间 本月第一天 cr.set(year, month, 0); //设置一个星期的第一天为星期日 //cr.setFirstDayOfWeek(Calendar.MONDAY); //本月有多少天 int days = 0; switch (month) { case Calendar.JANUARY://1 case Calendar.MARCH://3 case Calendar.MAY://5 case Calendar.JULY://7 case Calendar.AUGUST://8 case Calendar.OCTOBER://10 case Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b811db3af178974cd2b75b768da0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394dd340c17d9b32a8cc55b83eba318b/" rel="bookmark">
			计算某年、某月、某日和某年、某月、某日之间的天数间隔。要求年、月、日通过键盘输入传递到程序中。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算某年、某月、某日和某年、某月、某日之间的天数间隔。要求年、月、日通过键盘输入传递到程序中。
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Scanner; public class Test02_Date { /** * 计算某年、某月、某日和某年、某月、某日之间的天数间隔。要求年、月、日通过键盘输入传递到程序中。 * * @throws ParseException */ public static void main(String[] args) throws ParseException { // 传输格式yyyyMMdd Scanner sc = new Scanner(System.in); System.out.println("请输入第一个日期"); String s_date1 = sc.next(); System.out.println("请输入第二个日期"); String s_date2 = sc.next(); // 转换成毫秒值运算 SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd"); Date d1 = sdf.parse(s_date1); Date d2 = sdf.parse(s_date2); long time = Math.abs(d2.getTime() - d1.getTime());// 要绝对值 System.out.println("间隔天数：" + (time / 1000 / 60 / 60 / 24)); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775673fbfcd4893e303fe53d4e975e97/" rel="bookmark">
			整理了一下linux/ubuntu里面卸载软件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在终端里 apt-get安装的软件：
安装软件sudo apt-get install softname1 softname2softname3……
卸载软件 sudo apt-get remove softname1 softname2 softname3……
卸载并清除配置sudo apt-get remove --purgesoftname1
更新软件信息数据库 sudo apt-get update
进行系统升级sudo apt-get upgrade, sudo apt-get distupgrade
搜索软件包 sudo apt-cache search softname1 softname2 softname3……
2、安装的deb包要用此方法：
安装deb软件包 dpkg -i xxx.deb
删除软件包 dpkg -r xxx.deb
连同配置文件一起删除 dpkg -r --purge xxx.deb
查看软件包信息 dpkg -info xxx.deb
查看文件拷贝详情 dpkg -L xxx.deb
查看系统中已安装软件包信息 dpkg -l
重新配置软件包 dpkg-reconfigure xxx
4、在“synaptic pakagemanager”里:
点搜索，输入软件名
在需要安装或卸载的软件上右击－点标记－最后点应用
5、现在还可以在 software center里面,直接卸载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775673fbfcd4893e303fe53d4e975e97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c417b81d4409661360188a994c14153f/" rel="bookmark">
			Currency Exchange--（最短路径算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Currency Exchange Time Limit : 2000/1000ms (Java/Other) Memory Limit : 60000/30000K (Java/Other) Total Submission(s) : 74 Accepted Submission(s) : 19 Problem Description Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c417b81d4409661360188a994c14153f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98bfba9f52430f5391a83995d42442a/" rel="bookmark">
			Android RecyclerView关于item无法充满屏幕的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写了一个RecyclerView，写完后发现item居然不能充满屏幕 其中，item的布局是这样的
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; 可是，在实际效果中，item并没有充满，match_parent完全没有效果，效果是wrap_content自适应 后面仔细看了代码，发现是在适配器中加载布局时候的问题 一开始是这样写的，在onCreateViewHolder()中 view = layoutInflater.inflate(R.layout.fragment_notice_item,null); 后面将这代码改成
view = layoutInflater.inflate(R.layout.fragment_notice_item,parent,false); 就没有出现item显示不能充满的问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a014550243785af1c917b53c656065/" rel="bookmark">
			Tensorflow的反卷积（上采样）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于反卷积的简单例子，可以参照我的另外一篇文章：
http://blog.csdn.net/guvcolie/article/details/77529683
文章出处：http://blog.csdn.net/mao_xiao_feng/article/details/71713358
反卷积操作是卷积的反向
如果你随时都记住上面强调的重点，那你基本就理解一大半了，接下来通过一些函数的介绍为大家强化这个观念
conv2d_transpose(value, filter, output_shape, strides, padding="SAME", data_format="NHWC", name=None)除去name参数用以指定该操作的name，与方法有关的一共六个参数： 第一个参数value：指需要做反卷积的输入图像，它要求是一个Tensor 第二个参数filter：卷积核，它要求是一个Tensor，具有[filter_height, filter_width, out_channels, in_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，卷积核个数，图像通道数] 第三个参数output_shape：反卷积操作输出的shape，细心的同学会发现卷积操作是没有这个参数的，那这个参数在这里有什么用呢？下面会解释这个问题 第四个参数strides：反卷积时在图像每一维的步长，这是一个一维的向量，长度4 第五个参数padding：string类型的量，只能是"SAME","VALID"其中之一，这个值决定了不同的卷积方式 第六个参数data_format：string类型的量，'NHWC'和'NCHW'其中之一，这是tensorflow新版本中新加的参数，它说明了value参数的数据格式。'NHWC'指tensorflow标准的数据格式[batch, height, width, in_channels]，'NCHW'指Theano的数据格式,[batch, in_channels，height, width]，当然默认值是'NHWC' 开始之前务必了解卷积的过程，参考我的另一篇文章：http://blog.csdn.net/mao_xiao_feng/article/details/53444333 首先定义一个单通道图和3个卷积核 [python] view plain copy x1 = tf.constant(1.0, shape=[1,3,3,1]) kernel = tf.constant(1.0, shape=[3,3,3,1]) 先别着急！我们不直接用反卷积函数，而是再定义一些图 [python] view plain copy x2 = tf.constant(1.0, shape=[1,6,6,3]) x3 = tf.constant(1.0, shape=[1,5,5,3]) x2是6×6的3通道图，x3是5×5的3通道图 好了，接下来对x3做一次卷积操作 [python] view plain copy y2 = tf.nn.conv2d(x3, kernel, strides=[1,2,2,1], padding="SAME") 所以返回的y2是一个单通道的图，如果你了解卷积过程，很容易看出来y2是[1，3，3，1]的Tensor，y2的结果如下： [python] view plain copy [[[[ 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a014550243785af1c917b53c656065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba939372a09caaebd9fd8d154d03d1f0/" rel="bookmark">
			Dell 笔记本的 BIOS设置 USB Wake Support 的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是个电源管理的选项，指usb设备唤醒系统
启用后，正常情况下windows系统睡眠时如插上usb设备，windows被唤醒
这个玩意，和 笔记本的开机启动并没有太大的关系。 转载于:https://www.cnblogs.com/bing-yu12/p/7286421.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9801837b05842c68cad804fd7b1ee9e7/" rel="bookmark">
			Ajax的Result工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Result.java import net.sf.json.JSONObject; /** * 返回处理结果，判断两种情况，处理结果是true还是false。特别适合ajax使用。 * @author Administrator * */ public class Result { /** * 成功或者失败。true or false. */ @Deprecated private boolean success; /** * true or false Flag比success含义上更普遍。用作标记。有时候用来代替success字段。某些业务情境下用success不合适.比如判断用户角色是否是xxx */ private boolean flag; //处理或验证返回信息 private String msg; private Object others; public Result(){ } public Result(boolean flag, String msg){ this.flag = flag; this.msg = msg; } public boolean getSuccess() { return success; } public void setSuccess(boolean success) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9801837b05842c68cad804fd7b1ee9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a68e2be32b9995dbea4cac714a6767/" rel="bookmark">
			软件科技创新创业基地暑期集训有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迎着炎炎夏日，我来到了北京理工大学软件科技创新创业基地进行暑期集训。暑假是旅游放松的好时间，可又是提升自己的好时机。大家来自五湖四海，一同来到北理工进行集训就是因为我们有共同的地方——有一颗磨练自己坚强的心。 从开营仪式时我们就被贯彻了“不怕苦，不怕累，团队协作，创新求精，软件报国”的“锅炉房”科技创新精神。领导和老师让同学们能够专心、全面的投入到基地的学习、科创活动当中给我们创造了良好的实验室条件和制定了严格的集训守则，目的就是为了让同学们学有所获。当然这次集训让我无论从态度到学习方法上精进了不少，受益匪浅。 每天集训从早上8：30开始至晚上22:30结束，除了午饭和晚饭的空余其他时间几乎都是泡在实验室，一星期只有周日下午半天提供休息。一天至少有10个小时的实训时间，如此高强度高负荷的类军事化管理在大多人眼里是吃不消的，然而当你真的融入那个一起奋斗;那种年轻人一起拼搏的环境当中，你会发现过度的那么自然，钻研学习是一件很美妙的事情。 软件科技创新创业基地暑期集训项目共分为八个实验室，（1）算法艺术学生创新实验室（2）数字艺术实验室（3）人机对弈及智能推演实验室（4）数据智能实验室（5）嵌入式应用创新实验室（6）信息对抗及安全防护创新实验室（7）移动政务学生创新实验室（8）机器智能实验室。学员可根据自己的专业方向和兴趣爱好选择加入到基地的8个学生创新实验室中，与北京理工大学的学生一起，参与基地组织开展的各项相关专业培训、创新项目实践、科技竞赛、集训文体活动、集训讲座交流活动等。 刚开始各个实验室负责人介绍实验室的情况，然后就像报志愿一样，根据自己的需求进行第一二三志愿的选择。我专业的方向是移动应用，而我对前端也很感兴趣，所以我选择的移动政务实验室。 第一次见面司空见惯的就是自我介绍。这里有北理工的土著，延安大学的学生还有通过集结的北京学院各路大学的学生们欢聚一堂。
July.11 一开始的方向是分组建立一个网站。虽然有过前端的一些基础，但是从无到有，直接设计一个个人网站，这个经历还是头一次。任务是完成主题确定，设计logo和网站名，收集素材。从定位上讲不容易，如何做到创作出个性鲜明主题统一的网站成了首要问题。 我们小组曾经考虑过做游戏、影视、博客、论坛……不停地推翻以前的意见重新讨论，最终把网站的定位到美食上。因为两个人都是吃货，所以希望凭借自己对美食给大家展示出我们的风格。主题确定了，logo的意见又不统一了。 由此可见，从根本建立一个网站是需要多方磨合，建立网站需要小组的团结一致，分工明确，才能有效率的开工。由此可见良苦用心。这是推荐自学的网站在线边学边做就能直接显示结果codecademy.com，学习技术重要的就是查找文档，还可以在MDN上找各种语言语法用法的文档。前端页面一定要考虑兼容性问题，使用caniuse看不同浏览器的兼容情况。
July.12 首先进行了对HTML5与CSS3知识的梳理和复习 1、 添加图像 选择正确格式、大小，用像素衡量 2、 JPEG适合多种不同颜色 GIF或PNG是颜色较少或者大面积颜色相同时 3、 Img的alt、src 4、 Figure、figcaption 5、 表格结构、跨行、跨列、长表格 6、 各种表单 7、 注释、id、class 8、 Div、span 9、 Iframe内联框架 10、转义字符 11、加视频音频，由于带宽和用户体验上，尽量不加入视频和音频等大文件 紧接着就又是一轮头脑风暴，晚上进行静态页面的展示，没有了样式，每个组的展示效果都一般，但可以看得出大家都在认真，都在努着一把劲儿。
July.13 需要绘制网页设计线框图，描述静态设计规格，以前从来没有系统的设计一个网站，线框图可以更直观的把网站的结构抽象出来，所以好好自学了一下线框图。 主题:美食天下
主页 线框图(Wireframe)是软件或者网站设计过程中非常重要的一个环节。设计线框图也需要考虑很多的原则，保证其美观规范，能使项目运转更为流畅。当我们逐渐清晰了产品的需求后，并梳理了产品的各个频道及页面，那么这一步就要开始验证这些想法的具体界面表现和方案的可行性了。 原型设计是帮助我们更细致的思考，并做各项需求的评估，同时也是将自己脑海里的想法进行输出的一种方式。通过原型设计后，我们就可以进行产品宣讲了，相比较于抽象的文字描述，原型则更加直观的展现产品的需求，设计和技术人员或者老板也能够更加直观的了解到产品意图。当到了原型设计这一步时，已经不仅仅是构思了，我们需要更加深入的了解每个页面上元素和这些元素的属性。
July.14 CSS知识总结，层叠样式表知识的梳理。 1、 选择 (1) 选择器 通用选择(*)、类型选择、id选择(#id)、Class选择(.class)、子元素选择 (2) 级联原则 就近原则: 按照声明顺序，越靠后的优先级越高 具体性原则: 按照定位的具体程度，越具体的优先级越高。类型比通用具体，id、class、子元素比类型具体。 重要性原则: 使用!important标记的对同一元素优先级最高。 2、 字体 (1) Serif: 衬线字体。在字母笔画末端有一定的修饰。适合长文本阅读。 (2) sans-serif: 无衬线字体。没有装饰，显示平滑，对小字号打印和显示屏友好。 (3) 等宽字体。所有字母的宽度一致，对代码显示友好。 字体堆栈：font-family: font1, font2, …, general_font对于字体名称超过一个单词的，用双引号修饰。同一个页面不要超过三种字体。 字体大小font-size可以使用像素px、百分比和em（字母m的宽度） 100%=16px=12pt=1em 大小写font-transform、uppercase, lowercase或者capitalize。 添加额外字体: @font-face 3、 文本 文本修饰text-decoration,none, underline下划线, overline上划线, line-through删除线。 文本间距line-height行间距, letter-spacing字母间距, word-spacing字间距。 用em值确定。 文本对齐text-align,left, right, center, justify两端对齐。 文本垂直对齐vertical-align,baseline, text-top, text-bottom或者em值。 文本缩进text-indent,用em值确定。 文字阴影text-shadow: 左右延伸+上下延伸+模糊程度（可选）+颜色 伪类设置 首行与首字母:first-letter 4、 盒子 盒子模型算是比较重要的问题了 边框宽度border-width 一个像素值px，一个单词（thin，medium，thick），四个边的像素值（上+右+下+左），两个像素值（上下+左右）。 边框样式border-style，solid实线，dotted方形点串，dashed虚线，double双实线，groove刻入，ridge镂出，inset嵌入，outset突出， hidden/none无边框。四个边可以单独设置：border-top-style border-left-style border-right-style border-bottom-style。 边框圆角border-radiu:一个像素值（半径）或者两个像素值（长短轴）。四条边也可以单独设置。 5、列表 6、图像与背景  背景颜色background-color  背景图像background-imag，参数为url图像路径。  背景图像重复background-repeat,repeat上下左右重复，repeat-x横向重复，repeat-y纵向重复，no-repeat不重复。  背景图像滚动background-attachment，fixed固定不动，scroll跟随滚动。  背景图像定位background-positon九个位置，左中右*顶心底。 之后进行高级特性总结： 1、 块级元素 换行显示 2、 内联元素 在周围的文本之间流动 3、 包含元素 父元素 4、 定位机制 position 普通流 相对定位 绝对定位 固定定位 浮动元素 5、 普通流 static 块级元素换行显示（强制性） 6、 相对定位 relative 相对普通流的位置进行定位 不影响其他元素 使用位移属性 top bottom left right 7、 绝对定位 absolute 相对于包含元素 脱离普通流 随页面滚动 使用位移属性 浏览器默认在h1外面加一个外边框，需要时设margin为0px 8、 固定定位 fixed 相对于浏览器窗口 不随页面滚动 9、 浮动元素 float 脱离普通流 定位到包含元素的最左或左右 同时应使用width限制宽度 10、 重叠元素控制 z-index 一个数字 值越大越靠前 11、 清除浮动 clear 在同一包含元素内，一个盒子的某个方向不允许浮动元素 left right both none 12、 固定宽度布局 使用像素确定宽度，精确定位，但是会受到分辨率影响 13、 流体布局 使用百分比（相对于浏览器窗口或者包含元素）窗口适应性高，但是会出现难以阅读的文本 14、 多个样式表 CSS中使用@important（父表优先级最高） html中只用标签（越往后出现优先级越高） 15、 过渡动画 transition 只能在有变化是产生效果 注意各浏览器兼容 数值为秒 功夫不负有心人，在我和我的组员不断探讨、磨合中，我们小组一总分第一名获得移动政务实验室中期的冠军。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a68e2be32b9995dbea4cac714a6767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbdc793ac6fb88ef0356d5ea01e34b2/" rel="bookmark">
			百度坐标，火星坐标和WGS84之间转换Java代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇的算法来源于http://cnodejs.org/topic/564c0a27e4766d487f6fe38d。然后我将它改成了Java版本。具体各个坐标系的介绍参考http://blog.csdn.net/bit_kaki/article/details/52733788，可以看出两者的算法基本相似 。
计算可以计算出结果，但是根据http://www.gpsspg.com/maps.htm进行测试，在84和火星坐标系进行转换时候，精度相差了好几百米。
附上代码：
/** * Created by hasee on 2017/7/31. */ public class Transform { double x_PI = 3.14159265358979324 * 3000.0 / 180.0; double PI = 3.1415926535897932384626; double a = 6378245.0; double ee = 0.00669342162296594323; /** * 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02)的转换 * 即 百度 转 谷歌、高德 * @param bd_lon * @param bd_lat * @returns {*[]} */ public Point bd09togcj02(double bd_lon, double bd_lat){ double x = bd_lon - 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbdc793ac6fb88ef0356d5ea01e34b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5164a5e63138cfb1ec25693ab6083d4/" rel="bookmark">
			Vue全家桶&#43;Socket.io&#43;Express/Koa2打造网页版手机QQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue全家桶+Socket.io+Express/Koa2打造的网页版手机QQ(web app),高仿手机QQ7.1.0版本。为了方便大家学习，现在IP定位接口和实时气温接口也开放了！接口请在源码中查看。
预览 在线预览地址：https://qq.lenshen.com （尽量使用Chrome浏览器体验最佳效果，另外提供了3个测试账号，需要账号才能登录哦）
源码地址：https://github.com/lensh/vue-qq
三个测试账号如下:
qq:986992484 密码:111111
qq:986992483 密码:111111
qq:986992482 密码:111111
技术栈 Vue2.0：实现前端页面构建Vuex：实现不同组件间的状态共享Vue-router：页面路由切换,实现单页的核心vueg：页面复杂场景切换效果Socket.io：实现实时消息推送axios：一个基于 Promise 的 HTTP 库，向后端发起请求Express、Koa2：开发环境使用Express，生产环境使用Koa2ES6、ES7、ES8：服务端和客户端均使用ES6语法，promise/async/await 处理异步localStorage：本地保存用户信息Webpack：模块打包，前端项目构建工具首选SASS(SCSS)：CSS预处理语言Flex：flex弹性布局，简单适配手机、PC端CSS3：CSS3过渡动画及样式IScroll：模拟原生app的列表滚动效果(ListView)MySQL：MySQL关系型数据库持久化数据（考虑到表与表之间关系复杂，需要多表查询，最复杂的时候是六张表联查，用MySQL会比Mongodb好得多）jsonp：跨域请求数据pm2：服务端使用pm2部署，常驻进程，比forever好用得多（https://github.com/Unitech/pm2）nginx：服务端使用nginx代理端口转发 使用方式 先将根目录下的qq.sql导入到你的MySQL数据库里(可以使用Navicat)，用户名为root，登录密码为空。启动MySQL服务。然后使用cnpm install 安装所有依赖(最好用cnpm安装，因为项目依赖很多，npm用的是国外的镜像，在网络不稳定的情况下很有可能会导致安装失败，而且下载速度远远慢于国内的cnpm)，最后运行npm run dev。服务器部署运行项目只需要npm run pm2，这样就可以常驻进程，不过前提是得先全局安装pm2。
目前已经实现了QQ的核心功能，如消息列表、好友列表、新朋友、好友申请、实时群聊、实时私聊、聊天设置、屏蔽对方聊天、特别关心、会员等级、个性名片、添加好友、删除好友、好友分组、查找用户、登录、注销、切换用户、右滑显示侧栏、IP地理定位、实时气温等等。后期会考虑增加更多功能。如果你想体验实时聊天的酷炫效果，那么你可以打开两个浏览器，用上面不同的账号登录即可。
截图 消息页面 联系人页面 群聊 私聊 分析 服务端使用ES6语法 不需要使用babel转码以及一系列的配置，只需要将node升级到V8版本，V8已经很好地支持了ES6/ES7/ES8等最新特性，这是目前最好的办法。升级到V8版本，可以直接到nodejs中文网(http://nodejs.cn/download/) 下载即可，也可以使用NVM切换node版本。
升级到V8后，还不支持通过import/export关键字来导入导出模块(因为服务端已经有了CommonJS规范，如果再使用import/export的话就有点冲突了)，如果一定要使用import/export关键字，这时可以在服务端的入口文件首行添加以下代码：
require("babel-core/register")({ presets: ['es2015', 'stage-0'] }) require("babel-polyfill") 上面的模块不可以使用import来导入，必须使用require，同时需要通过npm安装babel-core、babel-preset-es2015、babel-preset-stage-0、babel-polyfill等依赖。这样就可以愉快地使用import/export了。
服务端代码片段如下：
// ES7 async/await import express from 'express' import login from '../../controller/login' const loginRouter = express.Router() loginRouter .get('/:user/:pwd', async(req, res) =&gt; { // 登录 const result = await login.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5164a5e63138cfb1ec25693ab6083d4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/470/">«</a>
	<span class="pagination__item pagination__item--current">471/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/472/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>