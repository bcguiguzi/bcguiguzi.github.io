<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da5867e99f906b7ec9363477043708a/" rel="bookmark">
			数字图像预处理的理论分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.数字图像预处理基本概述
1.1 灰度化
1.2 几何变换
1.3 滤波
1.4 图像增强
1.5 其他预处理操作
2.数字图像预处理常用理论
2.1图像获取与数字化
2.2量化（Quantization） 2.3 图像噪声处理
2.4 图像增强
2.5 图像锐化
图像预处理是将每一个图像分检出来交给识别模块识别。图像预处理的主要目的是消除图像中无关的信息，恢复有用的真实信息，增强有关信息的可检测性和最大限度地简化数据，从而改进特征抽取、图像分割、匹配和识别的可靠性。随着电子技术和计算机技术的不断提高，图像预处理技术在视频监控系统中获得了巨大发展。对视频监控系统来说，监控环境中的噪声以及图像在传输、接收过程中会产生的噪声降低了图像质量，使图像模糊。我们可以通过图像增强技术改善图像的质量。在一幅图像中，人们只对图中的某些目标感兴趣，我们通过图像分割技术把图像分割成不同的区域，从而分离出图像中的各个对象，然后从这些区域中获取对象的特征，从而提取出我们感兴趣的目标。
1.数字图像预处理基本概述 数字图像预处理是数字图像处理中的一个重要环节，其目的在于改善图像的质量、消除噪声、增强特定信息等，为后续的图像分析、特征提取、识别等任务提供良好的基础。预处理通常包括一系列的操作，如灰度化、几何变换、滤波、增强等。
1.1 灰度化 灰度化是将彩色图像转换为灰度图像的过程。灰度图像仅包含亮度信息，不包含颜色信息，因此可以简化后续处理的复杂性。灰度化通常通过计算彩色图像中每个像素的红、绿、蓝三个分量的加权平均值来实现。
1.2 几何变换 几何变换包括图像的缩放、旋转、平移等操作。这些变换可以调整图像的大小和方向，使其更适合后续的处理任务。例如，在图像识别中，可能需要将图像旋转到特定的方向，以便更好地匹配模板。
1.3 滤波 滤波是图像预处理中常用的一种技术，用于去除图像中的噪声和不需要的细节。滤波器可以分为线性滤波器和非线性滤波器两种。线性滤波器（如均值滤波器、高斯滤波器）通过计算像素周围区域的平均值或加权平均值来平滑图像。非线性滤波器（如中值滤波器）则通过统计像素周围区域的中值来去除噪声。
1.4 图像增强 图像增强的目的是提高图像的视觉效果，使其更适合人眼观察或计算机分析。增强方法包括直方图均衡化、对比度拉伸、锐化等。直方图均衡化通过调整图像的灰度分布来增强图像的对比度；对比度拉伸则通过扩展灰度范围来增强图像的细节；锐化则通过增强图像的边缘信息来使图像看起来更清晰。
1.5 其他预处理操作 除了上述常见的预处理操作外，还有一些其他的操作，如二值化、阈值处理、边缘检测等。二值化是将图像转换为黑白两色的过程，通常用于简化图像分析和识别任务；阈值处理则是通过设置一个阈值来将图像分割为前景和背景两部分；边缘检测则用于提取图像中的边缘信息，以便进行特征提取和形状识别等任务。
2.数字图像预处理常用理论 2.1图像获取与数字化 采样（Sampling） 数字图像由像素构成，采样过程是将连续空间中的图像转化为离散像素点的过程。对于一个连续函数f(x,y)，其在像素位置(m,n) 的采样值可以表示为：
其中，Δx 和 Δy 分别代表水平和垂直方向上的像素间距。
2.2量化（Quantization） 量化是对每个像素灰度或颜色强度进行分等级划分的过程。连续的幅度值被转换成有限数量的离散级别： [ G = Q(R) ] 其中，R 是原始连续灰度值，G 是量化后的离散灰度值，Q 是量化函数。
2.3 图像噪声处理 均值滤波（Mean Filter） 均值滤波是一种简单的降噪方法，通过计算像素邻域内所有像素的平均值来代替原像素值。
高斯滤波（Gaussian Filter） 高斯滤波器利用高斯函数对邻域内的像素加权求和，权重与距离成指数衰减关系。
2.4 图像增强 直方图均衡化（Histogram Equalization） 目的是提升图像对比度，其核心是调整图像的直方图分布，使得输出图像具有均匀分布的灰度级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da5867e99f906b7ec9363477043708a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252334534ccb8d29aedeed3c99944099/" rel="bookmark">
			Linux之shell脚本初始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华子目录 为什么学习和使用shell编程shell起源查看当前系统支持的shell查看当前系统默认的shellshell概念shell程序设计语言shell也是一种脚本语言用途 如何学号shell熟练掌握shell编程基础知识 建议shell脚本的基本元素基本元素构成shell脚本中的注释和风格 shell脚本编写规范脚本开头脚本自动增加注释版权信息示例（shell脚本文件必须以.sh结尾） 脚本中尽量不用中文注释多使用内部命令没有必要使用cat命令仔细阅读出错信息文件名以.sh结尾代码缩进示例：编写九九乘法表 shell脚本执行方法方法1方法2方法3方法4注意： bash shell基本功能echo打印命令printf命令示例 history历史命令命令与文件名补全：tab命令别名命令执行顺序管道符exit退出程序常见状态码 为什么学习和使用shell编程 简单易学解释性语言，不需要编译即可执行对于一个合格的系统管理员来说，学习和掌握shell编程是非常重要的，通过shell程序，可以在很大程度上简化日常的维护工作，使得管理员从简单的重复劳动中解脱出来 shell起源 1964年，美国AT&amp;T公司的贝尔实验室、麻省理工学院及美国通用电气公司共同参与开始研发一套可以安装在大型主机上的多用户、多任务的操作系统，该操作系统的名称为Multics。1970年，丹尼斯•里奇和汤普逊启动了另外一个新的多用户、多任务的操作系统的项目，他们把这个项目称之为UNICS。1973年，使用C语言重写编写了Unix。通过这次编写，使得Unix得以移植到其他的小型机上面。1979年，第一个重要的标准UNIX Shell在Unix的第7版中推出，并以作者史蒂夫•伯恩（StephenBourne）的名字命名，叫做Bourne Shell，简称为sh。20世纪70年代末，C Shell作为2BSD UNIX的一部分发布，简称csh。之后又出现了许多其他的Shell程序，主要包括Tenex C Shell（tcsh）、Korn Shell（ksh）以及GNU Bourne-Again shell（bash）。 查看当前系统支持的shell [root@server ~]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh #相当于/bin/sh的备份 /usr/bin/bash #相当于/bin/bash的备份 查看当前系统默认的shell [root@server ~]# echo $SHELL /bin/bash shell概念 shell（外壳）：是一种命令解释器程序，它能识别用户输入的各种命令，并传递给操作系统结构图真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和命令行只是架设在用户和内核之间的一座桥梁，由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 Shell，Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。 shell程序设计语言 shell也是一种脚本语言 任何代码最终都要被 “翻译”成二进制的形式才能在计算机中执行。有的编程语言，如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做编译器（Compiler）。有的编程语言，如 Shell、JavaScript、Python、PHP等，需要一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做解释器。编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作。Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。 用途 shell脚本的优势在于处理操作系统底层的业务 （linux系统内部的应用都是shell脚本完成）因为有大量的linux系统命令为它做支撑。2000多个命令都是shell脚本编程的有力支撑，特别是grep、awk、sed等。例如：一键软件安装、优化、监控报警脚本，常规的业务应用，shell开发更简单快速，符合运维的简单、易用、高效原则。PHP、Python优势在于开发运维工具以及web界面的管理工具，web业务的开发等。处理一键软件安装、优化，报警脚本。常规业务的应用等php/python也是能够做到的。但是开发效率和复杂比用shell就差很多了。 如何学号shell 熟练掌握shell编程基础知识 熟练使用vi（vim）编辑器熟练掌握Linux基本命令熟练掌握文本三剑客工具（grep、sed、awk）熟悉常用服务器部署、优化、日志及排错 建议 掌握shell脚本基本语法形成自己的脚本开发风格从简单做起，简单判断，简单循环多模仿，多参考资料练习，多思考学会分析问题，逐渐形成编程思维编程变量名字要规范，采用驼峰语法表示不要拿来主义，特别是新手 shell脚本的基本元素 基本元素构成 第1行的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252334534ccb8d29aedeed3c99944099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ecb118e3e706207663734c145fd6ea/" rel="bookmark">
			最全面的Windows 11原版系统镜像下载（不断完善更新中……）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最全面的Windows 11原版系统镜像下载地址 Windows 11下载地址Preview 预览版本2021-08-13发布Windows 11 Insider Preview (Beta Channel) - Build 22000.132 2021-09-23发布Windows 11 Insider Preview (Beta Channel) - Build 22000.194 2021-09-11发布Windows 11 Insider Preview (Dev Channel) - Build 22454 21H2版本2021-10-04发布Windows 11 (consumer editions) (x64) - DVD (Chinese-Simplified)Windows 11 (business editions) (x64) - DVD (Chinese-Simplified) ARM版本2021-10-05发布Windows 11, version 21H2 (ARM64) - DVD (Chinese-Simplified) 2022-09-20发布Windows 11, version 22H2 (ARM64) - DVD (Chinese-Simplified) 2023-10-31发布Windows 11, version 23H2 (ARM64) - DVD (Chinese-Simplified) 22H2版本2022-09-20发布Windows 11 (consumer editions), version 22H2 (x64) - DVD (Chinese-Simplified)Windows 11 (business editions), version 22H2 (x64) - DVD (Chinese-Simplified) 23H2版本2023-10-31发布Windows 11 (consumer editions), version 23H2 (x64) - DVD (Chinese-Simplified)Windows 11 (business editions), version 23H2 (x64) - DVD (Chinese-Simplified) 2023-12-19发布Windows 11 (consumer editions), version 23H2 (updated Dec 2023) (x64) - DVD (Chinese-Simplified)Windows 11 (business editions), version 23H2 (updated Dec 2023) (x64) - DVD (Chinese-Simplified)Windows 11 (中国定制版), version 23H2 (updated Dec 2023) (x64) - DVD (Chinese-Simplified) 2024-01-18发布Windows 11 (consumer editions), version 23H2 (updated Jan 2024) (x64) - DVD (Chinese-Simplified)Windows 11 (business editions), version 23H2 (updated Jan 2024) (x64) - DVD (Chinese-Simplified) Windows 11下载地址 Preview 预览版本 2021-08-13发布 Windows 11 Insider Preview (Beta Channel) - Build 22000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ecb118e3e706207663734c145fd6ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e918389de9ce7507782525d50836a88/" rel="bookmark">
			VMwareWorkstation17.0虚拟机安装搭建Windows 11虚拟机（完整图文详细步骤教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMwareWorkstation17.0虚拟机安装搭建Windows 11虚拟机（完整图文详细步骤教程） 一、下载Windows11二、配置Windows11虚拟机机器环境三、启动Windows11系统 一、下载Windows11 【点击打开·最全面的Windows 11原版系统镜像下载地址】
https://blog.csdn.net/molangmolang/article/details/136058160
二、配置Windows11虚拟机机器环境 1.打开VMwareWorkstation，点击-文件-新建虚拟机
2.点击-典型（推荐），点击下一步
3.选择-安装程序光盘映像文件-浏览，打开Windows11原版原盘映像文件，点击下一步（我这里用的是zh-cn_windows_11_consumer_editions_version_23h2_updated_jan_2024_x64_dvd_c6335b0e.iso原盘镜像文件）
4.在虚拟机名称框内键入您想要的名称，选择您想要存储的位置，点击下一步
5.加密类型选择哪一项都可以，不重要，密码我随便输入了123456789，并在最下方记住密码处打钩，点击下一步
6.指定磁盘容量选择-将虚拟磁盘拆分成多个文件，最大磁盘大小按自己的需求填写想要的大小即可，点击下一步（这里有个重点问题，大家要知道的，Windows11虽然建议的是64GB，但是它最低要求也是52GB以上，不然你装系统的过程又会出现返回的，我这里特地以10GB为例子，你们看看就明白了，不想出现此问题的，可以直接进入磁盘管理那一步骤）
7.取消-创建后开启此虚拟机，点击完成
8.VMwareWorkstation会在您配置完成之后，自动生成虚拟机硬件。
三、启动Windows11系统 1.选择Windows11系统，点击-开启此虚拟机
2.出现Press any key to boot from CD or DVD，之后出现Time out，EFI Network……（这个问题可以通过 断开网络适配器 跳过），之后再出现Boot Manager页面……
我们选择-BOOT NORMALLY，点击键盘ENTER确定键即可。
3.接下来进入Windows11安装页面，语言时间方法全部默认即可，点击下一页
4.点击-现在安装，会进入 ji 活Windows页面，
如果您有 许 可，可以直接输入；
如果没有，则选择 我没有产品miyao；
5.选择你想要的版本，我这边选的是Windows11专业版，点击下一步
6.给声明的条款，打钩，点击下一页
7.选择-自定义：仅安装Windows（高级），进入安装
8.进入磁盘管理页面，Win11建议的 系统盘是52GB或者更大，我这里只是做一下展示教程，就不做这么大的虚拟盘了。好，点击新建，之后点击应用，选择安装系统的盘符，点击下一页（不行，因为系统强制必须要52GB或者更大，好吧，看一下最后一张图，我们下一步修改盘符大小吧。）
9.进入修改磁盘过程，我们点击-关闭客户机，弹窗后点击 关机。
10.右键 Windows11虚拟机，点击设置，
11.选择硬盘，点击扩展，将10修改为52以上，点击扩展，后弹出扩展成功的提示窗。
12.点击 确定，我们返回软件界面，点击Windows11，开启此虚拟机，此时会出现之前的安装页面，前面几步骤我就直接跳过了，
13.直接进入 磁盘管理页面，如果有10g和50g两个盘符，可以选择10g那个，点击下方删除，之后，整个盘符变成60g，之后点击新建，点击应用，弹出提示，点击确定，，点击下一页
14.选择 主分区，点击 下一页
15.进入安装页面，静心等待
Windows11系统已经安装，自动进入设置界面，选择中国，选择是，进入下一页
17.选择你想要的输入法，点击是
18.选择 跳过
19.输入您想要的设备名称，我这里输入是LV，点击下一个，进入稍等页面
20.选择 个人，点击下一步
21.点击 登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e918389de9ce7507782525d50836a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06892a4f8d617b7e574c4afd372b22b6/" rel="bookmark">
			华为认证云计算专家（HCIE-Cloud Computing）--问答题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证云计算专家（HCIE-Cloud Computing）–问答题 38 处于退出状态的容器，会占用系统什么资源?
参考答案：宿主机文件系统资源
39 在docker中，删除所有容器的命令是什么?
参考答案：docker ps -aq| xargs docker rm -f
36.申明式API对比命令式API有哪些优势?
参考答案：申明式API比命令式API更加智能化，同时更加节省人力成本
25 管理节点的计算资源可以缩容吗?
正确答案：不可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2f198b93d1ba21b932f1bb3b2de879/" rel="bookmark">
			springboot&#43;vue社区医院家庭医生管理系统java&#43;ssm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统包含四种角色：管理员、前台、医生、用户，系统分为前台和后台两大模块，主要功能如下。
管理员：
﹣个人中心：管理个人信息。
- 管理员管理：管理系统管理员的基本信息。
﹣病例信息管理：管理患者的病例信息。
﹣基础数据管理：管理系统的基础数据信息。
﹣家庭医生管理：管理家庭医生的基本信息。
﹣健康档案管理：管理患者的健康档案信息。
- 就诊信息管理：管理就诊信息和患者的病历等相关信息。
﹣前台管理：管理前台工作人员的基本信息。
﹣药品管理：管理医院药品库存信息。
前台：
﹣个人中心：管理个人信息。
﹣病例信息管理：管理患者的病例信息。
﹣健康档案管理：管理患者的健康档案信息。
- 就诊信息管理：管理就诊信息和患者的病历等相关信息。
- 药品管理：管理药品的基本信息。
医生：
﹣个人中心：管理个人信息。
﹣病例信息管理：管理患者的病例信息。
﹣健康档案管理：管理患者的健康档案信息。
﹣就诊信息管理：管理就诊信息和患者的病历等相关信息。
﹣药品管理：管理药品的基本信息。
用户：
﹣个人中心：管理个人信息。
- 病例信息管理：管理个人的病例信息。
﹣家庭医生管理：管理家庭医生的基本信息。
﹣健康档案管理：管理个人的健康档案信息。
﹣就诊信息管理：管理就诊信息和个人的病历等相关信息。
﹣药品管理：管理个人用药信息。
设计截图
目 录
摘 要 I
目 录 III
第1章 绪论 1
1.1 研究背景 1
1.2目的和意义 1
1.3 论文研究内容 1
第2章 程序开发技术 3
2.1 MYSQL数据库 3
2.2 JAVA语言 3
第3章 系统分析 5
3.1可行性分析 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2f198b93d1ba21b932f1bb3b2de879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63315b2289fd9d6fd26080d23209b7e7/" rel="bookmark">
			ES6（三）：Iterator、Generator、类的用法、类的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、迭代器Iterator 迭代器是访问数据的一个接口，是用于遍历数据结构的一个指针，迭代器就是遍历器
const items=['one','two','three']; //创建新的迭代器 const it=items[Symbol.iterator](); console.log(it.next()); done：返回false表示遍历继续，返回true表示遍历完成
二、生成器Generator 1.generator generator函数可以通过yield关键字将函数挂起来（只能在函数内部使用）。
它跟普通函数的区别是，他得在function后面加*，调用该函数将会返回一个遍历器对象
generator函数是分段执行的，遇到yield就暂停执行，而next（）是恢复执行，把你上一个结果给你返回出来
function* func(){ console.log('start'); const x=yield '2'; console.log('continue'+x); const y=yield '3'; console.log('continue'+y); console.log(x+y); return x+y; } const fn=func(); console.log(fn.next()); console.log(fn.next(2)); console.log(fn.next(3)); console.log(fn.next()); x它不是yield的返回值，它是当next调用，恢复当前yield传入的实参
（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。
所以遇到第一个next的时候，start先输出，然后直接到了第一个yield 2，直接输出2
第二个next，传入了实参2，被x接收，输出continue2，又遇到了yield，直接输出后面的3
第三个next，传入了实参3，被y接收，后面输出x加y为5，然后直接ruturn了5（ruturn输出的效果和yield一样{}
最后的next后面都没有东西了，输出undefined done完成
function* foo(x) { var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z); } var a = foo(5); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63315b2289fd9d6fd26080d23209b7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3464634cc29a12bef912514bd24368b/" rel="bookmark">
			考虑功率均分与电压频率的事件触发分布式二次控制MATLAB模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微❤关注“电气仔推送”获得资料（专享优惠）
模型简介
此模型是在《基于事件触发机制的孤岛微电网二次电压与频率协同控制MATLAB仿真模型》上进一步创作的，之前的模型只考虑了二次电压与频率控制，并没有考虑均分这一项点。
因此此模型在事件触发机制的基础上，继续创作了基于事件触发机制的功率控制，实现功率均分。
本文采用基于事件触发方法的分布式控制策略来处理孤岛微电网的二次频率和电压控制。通过使用仅在事件触发时间重置为实际值的估计器的输出来替换反馈控制律中的实际值，所提出的控制策略只需要在某些特定时刻分布式辅助控制器之间的通信，而具有频率、电压恢复功能和精确的有功功率分配。
所提出的辅助控制器的框图如图所示，DGi控制器包括DGi和DGj估计器，并且仅将DGj事件触发时的状态值传送到DGj估计器。同时，DGi 仅在事件触发时将其状态值传输到其邻居。然后，辅助控制输入由估计器的输出而不是相应变量的实际值生成。因此，这种方式大大减少了agent间的通信，方案更加可靠。
参考文献中的模型主体：
基础控制依然为下垂控制
复现模型主体（完全复现）
基于事件触发机制的二次控制
工况设置：1s时投入二次控制，2s时切离负载，3s时投入负载。
电压波形
频率波形
有功均分波形
由上3张仿真图可知，采用事件触发控制策略的孤岛微电网分布式协作二次控制，各逆变输出单元电压和频率均可恢复到标称值，同时保持有功均流精度！！！
参考文献：
Event-Triggered Updating Method in Centralized and Distributed Secondary Controls for Islanded Microgrid Restoration——T. Qian, Y. Liu, W. H. Zhang, W. H. Tang*
Secondary Restoration Control of Islanded Microgrids With a Decentralized Event-Triggered Strategy——Meng Chen（复现）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d949f3afb2992e3d552c59564503e6/" rel="bookmark">
			基于恒功率PQ控制的三电平并网逆变器MATLAB仿真模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微❤关注“电气仔推送”获得资料（专享优惠）
模型简介
三相 T 型三电平逆变器电路如图所示，逆变器主回路由三个单相 T 型逆变器组成。 直流侧输入电压为 UPV，直流侧中点电位 O 设为零电位，交流侧输出侧是三相三线制连接， 三相电网电压为 usa、usb、usc，三相并网电感电流为 ia、ib、ic。
将 A、B、C 三相滤波电感 La、Lb、Lc 等效为电感 Ls 和电阻 Rs 串联，三相 T 型三电平电 路的等效开关电路简化模型如图所示：
通过 Park 变换将三相 T 型三电平电路在静止 αβ 坐标系下的数学模型转换到旋转 dq 坐标 系下。静止 αβ 坐标系到旋转 dq 坐标系，在旋转 dq 坐标系下，三相 T 型三电平电路的等效电路如图 所示：
并网模式下且公共电网供应正常时，因为公共电网给定了电 压和频率的参考值，所有的逆变器可以使用PQ控制方式。
当系统频率为额定频率f0时，系统稳定在A点，系统的输出为 有功参考值Pref，如果系统频率相应增大，则系统运行状态由A点过渡到B点， 但是其系统的输出依旧为有功参考值Pref；相反，如系统频率相应减小，则系统 运行状态由A点过渡到C点，而其系统的输出依旧还是为有功参考值Pref。 同理分析图2.9(b)，端口电压的幅值无论变大或是变小，系统输出的无功功率依 旧是无功参考值Qref。
PQ控制法是基于两相旋转（d-q）坐标系下的双环控制方 式建立的，其实质是在该坐标系下，检测逆变器输出电压并进行dq变换，设定 有功参考值和无功参考值，通过式(3.5)计算，便可得到两相参考电流值，双环控 制的内环实时跟踪参考电流，进而通过坐标转换到三相，输出SPWM的参考电 压，便可将对功率的控制转换为对输出电压的控制。其中，软件锁相器SPLL能 够实现电流的跟踪控制，并且为坐标转换提供频率参考。
仿真主体模型
三电平逆变器
PQ控制
输出波形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ec6448a32949897ae79faf427e8e58/" rel="bookmark">
			大模型学习笔记（一）：部署ChatGLM模型以及stable-diffusion模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型学习笔记（一）：部署ChatGLM模型以及stable-diffusion模型 注册算力平台（驱动云平台）1.平台注册2.查看算力3.进入平台中心 部署ChatGLM3-6B模型1.创建项目2.配置环境设置镜像源、克隆项目修改requirements 3.修改web_demo_gradio.py代码1、修改模型目录2、修改启动代码3、添加外部端口映射4、运行gradio界面5、访问gradio页面 4.修改web_demo_streamlit.py代码1、修改模型目录2、运行streamlit界面3、访问streamlit界面 用免费GPU部署自己的stable-diffusion1.创建项目2. 初始化开发环境实例3. 部署模型4. 体验自己的stable diffusion 注册算力平台（驱动云平台） 1.平台注册 平台注册链接：
https://growthdata.virtaicloud.com/t/SA
2.查看算力 注册完成后，点击右上角：费用中心，可查看领取的算力。
3.进入平台中心 https://platform.virtaicloud.com/
部署ChatGLM3-6B模型 ChatGLM3 是智谱AI和清华大学 KEG 实验室联合发布的新一代对话预训练模型。
推理速度比上一代提高了很多，虽然本教程有两种启动方式，但教程作者强烈推荐使用streamlit体验，效果极佳。
1.创建项目 创建好账号之后，进入自己的空间，点击右上角的创建项目。 给项目起一个你喜欢的名称，选择添加镜像
镜像选择pytorch2.0.1，Conda3.9
选择预训练模型，点击公开，选择不要葱姜蒜上传的这个ChtaGLM3-6B模型。
都选完之后，点击右下角的创建，代码选择暂不上传。待会直接clone代码。
点击运行代码
资源配置选择：B1.large， 24G的显存足够加载模型了。其他的不需要设置，然后点击右下角的开始运行。
2.配置环境 等右边两个工具全部加载完毕之后，再点击JupyterLab进入开发环境~ 进入界面之后是这样的，然后点击这个小加号。
点击terminal，进入终端。
设置镜像源、克隆项目 升级apt，安装unzip apt-get update &amp;&amp; apt-get install unzip
设置镜像源，升级pip git config --global url.“https://gitclone.com/”.insteadOf https://
pip config set global.index-url https://pypi.virtaicloud.com/repository/pypi/simple
python3 -m pip install --upgrade pip
克隆项目，并进入项目目录 git clone https://github.com/THUDM/ChatGLM3.git
cd ChatGLM3
修改requirements 双击左侧的requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ec6448a32949897ae79faf427e8e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d10191cc83d6d5a214d34849dc15e0/" rel="bookmark">
			在CentOS 7系统下通过二进制方式安装MySQL 8.0.34
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：下载MySQL 8.0.34二进制包 访问MySQL官方网站下载页面（通常位于 https://dev.mysql.com/downloads/mysql/ ），找到对应Linux通用二进制版的MySQL 8.0.34。
选择适用于Linux系统的MySQL Community Server RPM Bundle，它通常包含多个RPM包，用于完整安装MySQL。
第二步：上传安装包到服务器 使用诸如scp、sftp或图形化工具如Xftp将下载的MySQL 8.0.34二进制包上传到CentOS 7服务器上合适的目录，例如 /usr/local/src。
第三步：解压并安装依赖 解压下载的MySQL压缩包（假设压缩包名为 mysql-8.0.34-linux-glibc2.12-x86_64.tar.gz）： cd /usr/local/src tar -zxvf mysql-8.0.34-linux-glibc2.12-x86_64.tar.gz mv mysql-8.0.34-linux-glibc2.12-x86_64/ /usr/local/mysql 安装必要的依赖包： sudo yum install gcc-c++ libaio-devel bzip2 openssl-devel perl-Data-Dumper 第四步：编译安装MySQL 进入MySQL目录并执行安装脚本： cd /usr/local/mysql scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/var/lib/mysql 第五步：配置环境变量及系统服务 配置MySQL环境变量，编辑 /etc/profile 文件，在末尾添加： export MYSQL_HOME=/usr/local/mysql export PATH=$PATH:$MYSQL_HOME/bin 刷新环境变量： source /etc/profile 创建MySQL系统服务（假设手动管理，如果需要自动启动，需要编写systemd服务文件）： # 编写MySQL启动脚本（mysqld_safe.sh） nano /etc/init.d/mysqld_safe.sh 在脚本中添加启动、停止、重启MySQL的服务管理命令。
第六步：启动MySQL服务并设置权限 启动MySQL服务： sudo /etc/init.d/mysqld_safe.sh start 设置root用户的密码（首次启动可能需要初始化数据目录）： sudo mysqladmin -u root password 'new_password' 第七步：配置MySQL 根据需要修改MySQL的配置文件 /usr/local/mysql/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d10191cc83d6d5a214d34849dc15e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a5951e41a7f24f079b759da826da07/" rel="bookmark">
			代码随想录算法训练营day59|第十章 单调栈part02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
503.下一个更大元素II 42. 接雨水 503.下一个更大元素II 这道题和 739. 每日温度 几乎如出一辙，可以自己尝试做一做
代码随想录
这道题可以直接拼接数组，但是显然使用取余运算更划算。注意这回 i 代表的不直接是nums的下标，而更多的是遍历次数，取余之后才会是nums下标。还有文章里面给出的for的循环次数是nums.size()*2-1，而实际上可以是nums.size()*2-2，因为之所以要遍历两遍nums，是为了让所有的元素找临近较大值的时候可以从它的左边转一圈找到它的右边，所以针对最后后一个元素的寻找（其他元素早就满足这种寻找了），可以不遍历最后一个元素本身。
vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; st; vector&lt;int&gt; res(nums.size(),-1); st.push(0); for(int i=1;i&lt;nums.size()*2-1;i++){ while(st.size()&amp;&amp;nums[i%nums.size()]&gt;nums[st.top()]){ res[st.top()]=nums[i%nums.size()]; st.pop(); } st.push(i%nums.size()); } return res; } 42. 接雨水 接雨水这道题目是 面试中特别高频的一道题，也是单调栈 应用的题目，大家好好做做。建议是掌握 双指针 和单调栈，因为在面试中 写出单调栈可能 有点难度，但双指针思路更直接一些。在时间紧张的情况有，能写出双指针法也是不错的，然后可以和面试官在慢慢讨论如何优化。 代码随想录
这道题使用双指针的思路其实是遍历两遍height数组，分别找到它的右边最高的柱子和左边最高的柱子，然后取这两个的最小值，这个值就是填满水之后应该达到的高度，如果这个高度是正值那就加上，反之说明不合法则不予理会，以此来求当前下标处增加的水量。
遍历求右边最高柱子的时候要从右往左遍历，如果当前的柱子高度小于历史最高柱子的高度，那就把历史最高柱子高度赋值给它，反之如果大于，那就证明当前柱子的右边没有比它更高的柱子了，于是这个下标处也不会盛水，所以为了依旧套用递推公式，这个地方应该赋值为当前柱子的高度(在使用递推公式推导的时候，需要求最小值，这个最小值有可能是当前柱子的高度，那么计算出来值就会是0，而如果是最左边柱子的高度，那么这个值就会是负数，而因为不合法，所以不被加入)。于是推导公式就简化为取当前柱子高度和历史柱子最高高度的最大值。求左边最高柱子数组差不多一个道理，只是需要倒序遍历。注意，可以事先设置这个最大高度为0，然后遍历就可以从两端开始，或者也可以直接把两端的值设置为两端柱子的高度，这样可以少遍历一个值，其实大差不差。
int trap(vector&lt;int&gt;&amp; height) { if (height.size() &lt;= 2) return 0; vector&lt;int&gt; maxLeft(height.size(), 0); vector&lt;int&gt; maxRight(height.size(), 0); int size = maxRight.size(); // 记录每个柱子左边柱子最大高度 maxLeft[0] = height[0]; for (int i = 1; i &lt; size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } // 记录每个柱子右边柱子最大高度 maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i &gt;= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } // 求和 int sum = 0; for (int i = 0; i &lt; size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count &gt; 0) sum += count; } return sum; } 这道题使用单调栈做法也比较复杂，因为单调栈每次会弹出一些元素，所以不能像双指针做法那样按列来求，而是要一行一行的求，也就是除了求增加水量的高度之外，还要求增加水量的宽度(上一题直接求高度代表水量是因为宽度默认为1了)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a5951e41a7f24f079b759da826da07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae82bc1e920c171fb3d948f624748cf4/" rel="bookmark">
			一条 SQL 更新语句如何执行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Server 层
存储引擎层
总流程
查询语句
连接器
查询缓存
分析器
优化器
执行器
更新语句
redo log（节省的是随机写磁盘的 IO 消耗（转成顺序写））
InnoDB 引擎
物理日志
循环写
binlog
server层
逻辑日志
追加写入
两阶段提交
为了知道，mysql 中一条 sql 语句是如何执行的，先讲一下 mysql 的宏观分层以及如何执行查询语句.
MySQL 宏观上分为 Server 层 和 存储引擎层， MySQL 通过 server 层调用存储引擎层操作数据返回结果，Server 层又可以分为
连接器分析器优化器执行器 连接器负责跟客户端建立连接、获取权限、维持和管理连接。
分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 执行器会根据表的引擎定义，去使用这个引擎提供的接口。示例：
mysql&gt; select * from T where ID=10; 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae82bc1e920c171fb3d948f624748cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660f69d77724015cecc03bfdc653dfc8/" rel="bookmark">
			Spark ml报错：Error:scalac: missing or invalid dependency detected while loading class file ‘SQLImplici
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		订阅专栏
一、问题描述
采用spark2.3.0的 ml库进行推荐算法建模，但是，运行代码到如下推荐个数的时候
...
model.recommendForAllUsers(7).show(false)
...
报错如下图：
具体报错如下：
​
Information:Module "sparktest" was fully rebuilt due to project configuration/dependencies changes
Information:2019/5/20 8:53 - Build completed with 23 errors and 0 warnings in 4 s 71 ms
Error:scalac: missing or invalid dependency detected while loading class file 'SQLImplicits.class'.
Could not access type Encoder in package org.apache.spark.sql,
because it (or its dependencies) are missing. Check your build definition for
missing or conflicting dependencies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/660f69d77724015cecc03bfdc653dfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b9d44a8bec146732a5eb1d6a267c00/" rel="bookmark">
			Mybatis Plus &#43; Spring 分包配置 ClickHouse 和 Mysql 双数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、各个配置文件总览（文件位置因人而异）
2.1 DataSourceConfig
2.2 MybatisClickHouseConfig （ClickHouse 配置类）
2.3 MybatisMysqlConfig（Mysql 配置类）
2.4 application.properties 配置
2.5 mapper 分包情况
2.6 主类中的 @MapperScan 去掉，因为在上面 ClickHouse 配置类 和 Mysql配置类 中已经定义
2.7 引用依赖（关键性依赖）
三、参考大神，感谢分享！
一、背景 业务需求，连接池之前用的 Hikari，换成了 Druid 注意一下 ~
我选择 分包 配置动态双数据源
二、各个配置文件总览（文件位置因人而异） 2.1 DataSourceConfig package xxx.xxx.xxx.common.config; import javax.sql.DataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.alibaba.druid.pool.DruidDataSource; /** * 双数据源配置类 * * @Author Elenda * @Date 2024/03/12 10:10 * @Version 1.0 */ @Configuration public class DataSourceConfig { /** * Mysql * * @return DataSource */ @Bean(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b9d44a8bec146732a5eb1d6a267c00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8481ffc174ae53a7d37b3b384d2c80b9/" rel="bookmark">
			Python脚本使用pyinstaller打包运行时，报get_handles OSError: [WinError 6] 句柄无效的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误信息 File "subprocess.py", line 728, in __init__ File "subprocess.py", line 1025, in _get_handles OSError: [WinError 6] 句柄无效。
二、解决方法 使用 pyinstaller 打包 python 程序，使用 - w 参数，去掉 console，发现执行命令行的 subprocess 相关语句报 “[ERROR] [WinError 6] 句柄无效” 的错误。
去掉 - w 参数，将 console 显示的话，就正常。
我原本的语句是：
#用 subprocess.check_output获取adb devices命令运行的输出 deviceInfo = subprocess.check_output('adb devices').decode().split("\r\n") 这里需要获得命令的运行输出，试了好多方案，最终可行的方案是用 subpross.Popen 来替代 subprocess.check_output，
Popen 函数加入如下参数：
shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE
Popen 方法执行命令，父进程不会等待子进程。这个时候需要用 wait () 方法来等待运行的结果。
这里用自己写的 subprocess_check_output 来替代 subprocess.check_output 代码如下：
def subprocess_check_output(*args): p = subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8481ffc174ae53a7d37b3b384d2c80b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c3fd6a7d1e0b0e33db86d8d7137532/" rel="bookmark">
			力扣由浅至深 每日一题.05 合并两个有序列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神明渡我，我将所有苦难都放过
—— 24.3.13
21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：
输入：l1 = [], l2 = [] 输出：[] 示例 3：
输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50]-100 &lt;= Node.val &lt;= 100l1 和 l2 均按 非递减顺序 排列 方法一：递归
思路 我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：
也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。
算法 我们直接将以上递归过程建模，同时需要考虑边界情况。
如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。
class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c3fd6a7d1e0b0e33db86d8d7137532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3ea5aac8bfcd67635ba28cd6c16e6e/" rel="bookmark">
			HTML、CSS、JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		W3C标准：网页主要由三部分组成
➢结构：HTML
➢表现：CSS
➢行为：JavaScript
HTML HTML是一门语言，所有的网页都是用HTML这语言编写出来的
HTML(Hyper' Text Markup Language)：超文本标记语言
➢超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容
➢标记语言：由标签构成的语言
HTML运行在浏览器上，HTML标签由浏览器来解析
HTML标签都是预定义好的。例如:使用&lt;img&gt; 展示图片
快速入门 新建文本文件，后缀名改为.html
编写HTML结构标签
在&lt;body&gt;中定义文字
标签描述&lt;HTML&gt;定义HTML文档&lt;head&gt;定义关于文档的信息&lt;title&gt;定义文档的标题&lt;body&gt;定义文档的主体 &lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;/body&gt; &lt;body&gt; &lt;/html&gt; 特点 HTML文件以.htm或. html为扩展名不区分大小写HTML标签属性值单双引皆可HTML语法松散 基础标签 标签描述&lt;h1&gt; - &lt;h6&gt;定义标题, h1最大，h6最小&lt;font&gt;定义文本的字体、字体尺寸、字体颜色&lt;b&gt;定义粗体文本&lt;i&gt;定义斜体文本&lt;u&gt;定义文本下划线&lt;center&gt;定义文本居中&lt;p&gt;定义段落&lt;br&gt;定义折行&lt;hr&gt;定义水平线 &lt;!-- html5标识--&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;!--页面的字符集--&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;TEST&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;title1&lt;/h1&gt; &lt;h2&gt;title2&lt;/h2&gt; &lt;h3&gt;title3&lt;/h3&gt; &lt;h4&gt;title4&lt;/h4&gt; &lt;h5&gt;title5&lt;/h5&gt; &lt;h6&gt;title6&lt;/h6&gt; &lt;hr&gt; &lt;font size="5" color="#b22222"&gt;Hello!&lt;/font&gt; &lt;!--font标签不建议使用，其功能可以用CSS完成--&gt; &lt;hr&gt; &lt;center&gt;&lt;b&gt;赤壁赋&lt;/b&gt;&lt;br&gt;&lt;i&gt;唐 苏轼&lt;/i&gt;&lt;/center&gt; &lt;!--center标签不建议使用，其功能可以用CSS完成--&gt; &lt;p&gt;壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。&lt;u&gt;浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。&lt;/u&gt;&lt;/p&gt; &lt;p&gt;于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉；余音袅袅，不绝如缕。&lt;u&gt;舞幽壑之潜蛟，泣孤舟之嫠妇。&lt;/u&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 转义字符 HTML原代码显示结果描述&amp;lt;&lt;小于号或显示标记&amp;gt;&gt;大于号或显示标记&amp;amp;&amp;可用于显示其它特殊字符&amp;quot;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3ea5aac8bfcd67635ba28cd6c16e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a5422374ae45d7410132656a9e1c4c/" rel="bookmark">
			Spring Boot单元测试入门实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于JUnit的一些东西
在我们开发Web应用时，经常会直接去观察结果进行测试。虽然也是一种方式，但是并不严谨。作为开发者编写测试代码来测试自己所写的业务逻辑是，以提高代码的质量、降低错误方法的概率以及进行性能测试等。经常作为开发这写的最多就是单元测试。引入spring-boot-starter-testSpringBoot的测试依赖。该依赖会引入JUnit的测试包，也是我们用的做多的单元测试包。而Spring Boot在此基础上做了很多增强，支持很多方面的测试，例如JPA，MongoDB，Spring MVC（REST）和Redis等。
接下来主要是测试业务逻辑层的代码，REST和Mock测试。
1.1 JUnit介绍
JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。
JUnit相关概念含义测试一个以@Test注释的方法定义一个测试，运行这个方法，JUnit会创建一个包含类的实例，然后再调用这个被注释的方法。测试类包含多个@Test方法的一个类Assert定义想测试的条件，当条件成立时，assert 方法保持沉默，条件不成立时，则抛出异常SuiteSuite允许将测试类归类成一组RunnerRunner类用于运行测试，JUnit4是向后兼容的，可以运行JUnit3的测试实例 这里使用的是JUnit4.x版本，JUnit中有两个重要的类Assume+Assert，以及重要的注解：BeforeClass、AfterClass、After、Before、Test和Ignore。BeforeClass和AfterClass在每个类的开始和结束的时候运行，需要static修饰方法。而Before和After则是在每个测试方法的开始和结束的时候运行。
代码片段：TestDeployApplication.class是自己编写的Spring Boot启动类。
@RunWith(SpringRunner.class)
@SpringBootTest(classes = {TestDeployApplication.class})
public class UnitTest1 {
@BeforeClass
public static void beforeClass() {
System.out.println("=================BeforeClass================");
}
@AfterClass
public static void afterClass() {
System.out.println("=================AfterClass================");
}
@Before
public void beforeTest() {
System.out.println("before test");
}
@After
public void afterTest() {
System.out.println("after test");
}
@Test
public void test1() {
System.out.println("test1");
}
@Test
public void test2() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a5422374ae45d7410132656a9e1c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e29b4fff114a5f6dc0312331af2bec/" rel="bookmark">
			vscode 之 vue项目如何使用ctrl&#43;鼠标左键跳转对应文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 话不多说，直接步入正题
使用项目工程的jsconfig.json 直接在项目中使用jsconfig.json/tsconfig.json文件配置（项目中没有相应的文件的添加文件，有文件的添加"paths": {"@/*": ["./src/*"]}配置即可） { "compilerOptions": { "target": "ES6", "module": "commonjs", "paths": { "@/*": ["./src/*"] } }, "include": [ "src/**/*" ], "exclude": [ "node_modules" ] } 这种直接在项目中使用jsconfig.json/tsconfig.json文件配置的方法，更加适用于团队协作开发
用户自定义安装插件 使用vscode插件，并在vscode的setting.json文件中配置 别名路径跳转（setting.json配置看插件细节说明）path-alias（setting.json配置看插件细节说明）
例如配置：
setting.json "pathAlias.aliasMap": { "@": "${cwd}/src" }, 使用这两个插件的任意一个都可以，使用插件的话是要ctrl+点击from后面的路径，不能点击import后面的变量名，然后跳转到文件，并不是快速跳转到对应变量声明的位置。使用插件的方式更加偏向于用户使用的自定义安装插件，并不适合于团队协作，毕竟设置的setting.json文件是存在用户电脑的vscode里面的，并没有在代码项目工程上。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/27/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>