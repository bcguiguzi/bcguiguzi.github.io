<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b1a27dfcd441e9d4eefaa8c104b6b0/" rel="bookmark">
			linux 中 vim/vi的常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介normal模式（正常模式）insert模式（插入模式）command模式（命令模式） vim的启动退出vim显示和取消行号光标移动操作撤销 恢复文本删除复制与粘贴搜索替换 简介 vi的三种基本工作模式：
normal模式：正常模式
insert模式：插入模式
command模式：底部命令模式、末行模式
normal模式（正常模式） 进入vim编辑器时默认处在该模式下在该模式下键盘输入的所有字符都被当作编辑命令来解释，命令合法才执行在该模式下输入的命令不会被显示，只显示命令结果 insert模式（插入模式） 所有的输入都被当作文件显示在屏幕从normal模式进入insert模式：i/I(最常用)、a/A(附加命令)、o/O(打开命令)从insert模式进入normal模式按Esc键 command模式（命令模式） 从normal模式进入command模式输入:在该模式下vim窗口会在最后一行显示一个:并等待用户输入命令command模式中所有命令都必须按回车后执行命令执行完之后vim自动回到normal模式可按Esc回到normal模式中
vim的启动 启动vim编辑器：vim/vi
有这个文件时打开，没有就创建然后打开
vim newfile 退出vim normal模式输入:进入命令输入模式
:w 保存当前文件但不退出 :q 系统退出vim :wq 保存并退出vim :q! 放弃所作修改直接退出 :w newfile 另存为新文件，新文件名为newfile 显示和取消行号 :set nu 显示行号 :set nonu 不显示行号 光标移动操作 insert模式下光标的移动：四个方向键
normal模式下：各种命令
在命令前输入数字n，则光标就移动n个位置
0 光标移动到所在行的开始 $ 光标移动到所在行的末尾 nG 光标移动到第几行（或：n回车） G 光标移动到最后一行 gg 光标移动到第一行 撤销 恢复 normal模式中：输入u撤销
normal模式中：输入ctrl+r恢复 文本删除 在insert模式中：使用delete/backspace可将其删除
在normal模式中：vim提供了许多命令
dd 删除光标所在的整行 ndd 删除从当前行开始的n行内容 d0 删除当前光标前一个字符到行首的内容 d$ 删除从光标所在处到行尾的内容 复制与粘贴 normal模式中输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b1a27dfcd441e9d4eefaa8c104b6b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54cd2000ef63d6dcc0c66f567f025f8/" rel="bookmark">
			Windows10访问smb提示拒绝访问的奇葩原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows10访问smb提示拒绝访问的解决方案 参考网上一堆教程，开启window功能、修改策略组、一键SMB脚本等等均无效，一直提示拒绝访问，最后发现是smb的目录"/overlay"的第一个字符"/"不能被Windows正确识别，把它删掉就可以访问了，困扰了我好几天，也是无语了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176ba126dcef06c676182cb3377876b7/" rel="bookmark">
			vue修改父组件对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于vue3在api文档上没有 .sync修饰符，可能要准备去除了，所有要准备其它的方法来替换，
其实.sync是换到了v-model上了，如果v-model用在input、select等几个标签上，是和vue2没有区别的，
但在vue3它做了一些的修改，
1、修改父组件的单一的值 这种是用的比较多的，单一的值一般只用ref，
//父组件 &lt;template&gt; &lt;CustomInput v-model="message" /&gt; {{ message }} &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue' import child from './child.vue' const message = ref('hello') &lt;/script&gt; //子组件 &lt;template&gt; &lt;div&gt;{{modelValue}}&lt;/div&gt; &lt;button @click="mode"&gt;点击修改父组件的值&lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; //如果父组件没有改绑定的值是，是用以下的默认值(下面是解构) const { modelValue } = defineProps(['modelValue']) const emit = defineEmits(['update:modelValue']) const mode = ()=&gt;{ emit('update:modelValue','hi') } &lt;/script&gt; 2、修改父组件的对象 这个对象是指object对象，不推荐，限制多
//父组件 &lt;template&gt; &lt;CustomInput v-model="message" /&gt; {{ message }} &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue' import child from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176ba126dcef06c676182cb3377876b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672c4ac49c4b904b17d177da28586d73/" rel="bookmark">
			Linux环境下Protobuf完整安装和使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下Protobuf完整安装和使用教程 原文地址：https://blog.csdn.net/yahohi/article/details/108310609
下载和安装 1、下载protobuf安装包
$ git clone https://github.com/protocolbuffers/protobuf.git 2、安装依赖库
$ cd protobuf/ $ ./autogen.sh $ ./configure --prefix=/usr/local/protobuf $ make $ sudo make install $ sudo ldconfig // 刷新共享库，很重要的一步 3、检查安装是否成功
$ protoc --version 环境配置 1、添加环境变量
sudo vim /etc/profile 添加：
export PATH=$PATH:/usr/local/protobuf/bin/ export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/ 2、然后，刷新环境变量：
source /etc/profile 3、按照上述方式修改~/.profile。
4、配置动态链接库路径
sudo vim /etc/ld.so.conf 添加：
/usr/local/protobuf/lib 一个例子 1、报文定义 syntax = "proto3"; message SearchResponse { message Result { string url = 1; string title = 2; int64 telephone = 3; repeated string snippets = 4; } repeated Result results = 1; } 2、报文生成 执行如下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/672c4ac49c4b904b17d177da28586d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ecea99d8c500a772012490364ae9c9/" rel="bookmark">
			TLS1.3中文版上（RFC8446）（注：本文有错误但无法修改，正确的见后来文章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文规定了TLS协议的1.3版本。TLS为CS模式应用提供了一种设计为防止监听、篡改和伪造的Internet通信方式。
本文为RFC5705和RFC6066的更新版，淘汰了RFC5077、RFC5246和RFC6961。本文也规定了实现TLS1.2的新要求。
1. 介绍 TLS 的主要目标是为通信双方提供一个安全的通道；对下层传输的唯一要求是提供可靠保序的数据流。安全通道尤其应该提供如下属性：
 认证（Authentication）：server端应该总是需要认证的；client端可以选择性的认证。认证可以通过非对称算法完成（如RSA、椭圆曲线数字签名算法(ECDSA)、或Edwards曲线数字签名算法(EdDSA)）完成，或通过对称预共享密钥（PSK）。
 保密（Confidentiality）：在建立好的通道上发送的数据只能终端可见。TLS不隐藏传输数据的长度，但终端可以填充TLS记录（pad）来隐藏真实长度，从而提升安全性。
 完整性（Integrity）：在建立好的通道上发送的数据不能被攻击者修改（如果修改了一定会被发现）。
即使出现像RFC3552那样已经完全控制网络的攻击者，这些属性也应该保证。更完整的相关安全属性清单详见附录E。
TLS由两个主要部分构成：
 握手协议（第4节），认证通信双方，协商加密模式和参数，并确定共享密钥。握手协议可以防止篡改，如果连接没有受到攻击，攻击者就不能强制两端协商不同的参数。
 记录协议（第5节），使用由握手协议协商出的参数来保护通信双方的流量。记录协议将流量分为一系列记录，每个记录独立地使用流量密钥保护。
TLS是一个独立的应用协议；上层协议可以透明地运行于TLS之上。然而，TLS标准并未指定怎样使用TLS保证安全、怎样发起TLS握手以及怎样理解认证证书交换，这些留给运行在TLS之上的协议的设计者和实现者来判断。
本文定义了TLS 1.3. 虽然TLS 1.3与以前的版本不直接兼容，但所有TLS版本都包含一个版本控制机制，可以在客户端和服务器都支持的情况下协商出一个公共版本。
本文取代和废除了以前版本的TLS，包括1.2版本[RFC5246]。也废除了在[RFC5077]里面定义的TLS ticket机制，并用定义在第2.2节中的机制取代它。由于TLS 1.3改变了密钥的产生方式，它更新了[RFC5705]。正如7.5节描述的那样。它也改变了在线证书状态协议（OCSP）消息的传输方式，因此更新了[RFC6066]，废除了[RFC6961]，如第4.4.2.1节所述。
1.1. 约定和术语 使用了以下术语:
客户端（client）: 发起TLS连接的端点。
连接（connection）: 两端之间的传输层连接。
端点（endpoint）: 连接的客户端或者服务器。
握手（handshake）: 客户端和服务器之间协商TLS交互的后续参数的出示协商。
对端（peer）: 一个端点，当说到一个特定端点，对端指的是非当前讨论的端点。
接收端（receiver）: 接收记录的端点。
发送者（sender）: 发送记录的端点。
服务器（server）: 没有发起TLS连接的端点。
1.2. 跟TLS 1.2的主要区别 以下是TLS 1.2和TLS 1.3的主要差异。这并不是全部差异，还有很多次要的差别。
 支持的对称算法列表已经删除了所有被认为是遗留问题的算法。列表保留了所有使用“关联数据的认证加密”（AEAD）算法。密码套件的概念已经改变，将认证和密钥交换机制与记录保护算法（包括密钥长度）和Hash（用于秘钥导出函数和握手消息认证码MAC）分离。
 增加0-RTT模式，为一些应用数据在连接建立阶段节省了一次往返，这是以牺牲一定的安全特性为代价的。
 静态RSA和Diffie-Hellman密码套件已经被删除；所有基于公钥的密钥交换算法现在都能提供前向安全。
 所有ServerHello之后的握手消息现在都已经加密。扩展之前在ServerHello中以明文发送，新引入的EncryptedExtension消息可以保证扩展以加密方式传输。
 密钥导出函数被重新设计。新的设计使得密码学家能够通过改进的密钥分离特性进行更容易的分析。基于HMAC的提取-扩展密钥导出函数（HKDF）被用作一个基础的原始组件。
 Handshake状态机进行了重大重构，以便更具一致性和删除多余的消息如ChangeCipherSpec(除了中间件兼容性需要)。
 椭圆曲线算法已经属于基本的规范，且包含了新的签名算法，如EdDSA。TLS 1.3删除了点格式协商以便于每个曲线使用单点格式。
 其它的密码学改进包括改变RSA填充以使用RSA概率签名方案（RSASSA-PSS），删除压缩，数字签名算法DSA，和定制DHE组（Ephemeral Diffie-Hellman）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ecea99d8c500a772012490364ae9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c3b246cad84465aa852eabd406abd4/" rel="bookmark">
			notepad &#43;&#43; 将制表符（tab）替换为空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		notepad ++ 是常用的软件之一，在一些环境下（如：python、linux等），按下tab键与打几个空格是完全不同的，tab键要比打若干个空格方便，但是，程序可能会报错。
因此，我们希望 tab键 全部转换成 空格，即便是使用tab键，也会自动转换成空格，既方便了我们使用，也避免了程序出错。
notepad ++ 将 tab 键 替换为 空格，设置如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2baefc774706f7246829841642861aae/" rel="bookmark">
			基于JWT实现单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单点登录概述：
多系统共存下，用户在一处地方登录，得到其他所有系统的信任，无需再次登录。
自己的理解：在前端用户点击登录触发后端登录接口，登录成功的时候，后端jwt生成一个token，后端将token返给前端，前端把token放进需要进行验证的接口的请求头(header)中去，用户带着这个token去进行验证。(token设置过期时间),验证成功则拦截器放行，否则拦截
这里介绍一些jwt基本概念
JWT：
1.认证流程
a.首先，前端通过web表单将自己的用户民和密码发送到后端的接口，这一过程一般是一个HTTP,POST请求。建议的方式是通过SSL
加密的方式传输(https协议)，从而避免敏感信息被嗅探。
b.后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成
一个JWT（token），形成的JWT就是一个形同111.zzz.xxx的字符串， token,head ,payload, singurater
c.后端将JWT字符串 作为登录成功的返回结果返回给前端，前端可以返回的结果保存在localStorage 或sessionStorage上，退出登录
时前端删除保存的JWT即可。
d.前端在每次请求时将JWT放入HTTP Header中的Authoriztion 位。(放在Header中的原因是解决XSS和XSRF问题) HEADER.
e.后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己(可选)
f。验证通过后，后端使用JWT包含的用户信息进行其他逻辑操作，返回相应结果。
2.JWT优势
可以通过URL，POST参数或者在HTTP，header发送 ，因为数据量小，传输速度也很快。
自包含(self-contained): 负载中包含了所有用户所需要的信息，避免了多次查询数据库。
因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。
不需要在服务端保存会话信息，特别适用于分布式微服务。
3.JWT结构
a.令牌组成
token 其实就相当于一段字符串 ==&gt; token String ==&gt;header.payload.singnature =token
1.标头(Header)
2.有效载荷(Payload)
3.签名(Signature)
因此,JWT通常如下所示:xxxx.yyyy.zzzz
4.JWT常见异常信息
SignatureVerificationException 签名不一致
TokenExpiredException 令牌过期异常
AlgorithmMismatchException 算法不匹配异常(也就是解密与加密的算法不一样)
InvalidClaimExeption 失效的Payload异常 (就是Payload加解密前后信息不一致)
总的来说就是登录的时候使用jwt生成一个token，用户带着这个token去其他页面进行验证，需要配合拦截器来实现。
作者有自己写的单点登录的demo源码如有需要可随时滴滴~
单点登录demo 使用原理(新手切记):
登录成功生成token后，需要将token返回前端也就是代码中的map.put("token",token),前端需要把这个token加入到请求头中去，然后后端进行接口验证，切记拦截器建议拦截所有路径，放行登录接口(如拦截无法进行登录验证)。
使用postman测试时，先调用登录接口生成token，然后调用其他接口时在Header里面设置content-Type,application, token=生成的token值,就可以实现token验证了。
直接复制即可测试使用，
首先要准备好一个util包
JWTutils.java
public class JWTutils { private static final String SING="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2baefc774706f7246829841642861aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db47c2c4f8ef9935f5aeb8895a0e442c/" rel="bookmark">
			使用axios发起请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本语法 1、直接通过axios发起请求 注意：
返回的是一个promise对象返回的数据不是原始数据，是经过包装过，要得到原始数据需要通过result.data得到 2、给axios发起请求时添加参数 get请求在axios中添加parms属性post请求在axios中添加data属性 3、用await与async简化.then（） 当某个方法返回值是promise实列，则前面可以添加await。await只能用在被async修饰的方法中！
4、使用解构赋值 把需要的data属性解构出来，便于后面使用。解构出来的data属性使用冒号进行重命名，一般命名为res
二、直接发起get或post请求 1、get请求 语法格式：
axios.get('url地址'，{ params{get参数} }) 例：
2、post请求 语法格式
axios.post('url',{post请求数据}) 例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc5bc294f69150a1ca2732ab6ae87d7/" rel="bookmark">
			java里面的CompletableFuture的异常和事务问题和AtomicBoolean解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们写代码的时候进场会使用到CompletableFuture.runAsync这样的异步操作,大家有没有想过异步里面的内容是否在事务里面并且里面的异常是否能抛出到主线程呢?
@Autowired private MyTableDao myTableDao; @Override @Transactional(rollbackFor = Exception.class) public void testAsync() throws InterruptedException { CompletableFuture.runAsync(() -&gt; { MyTable myTable = new MyTable(); myTable.setName("测试用"); myTable.setAge(0); myTableDao.updateByAge(myTable); }); MyTable myTable = new MyTable(); myTable.setName("测试用2"); myTable.setAge(66); myTableDao.updateByAge(myTable); Thread.sleep(5000); int ii = 3/0; } age 0 修改前name值:123 修改后 测试用 age 66 修改前name值:123 修改后 123 这里为了让异步里面的内容先执行完,在主线程里面睡了5秒,通过结果可以发现异步里面的内容是不会参与到当前事务的
@Autowired private MyTableDao myTableDao; @Override @Transactional(rollbackFor = Exception.class) public void testAsync() throws InterruptedException { CompletableFuture.runAsync(() -&gt; { MyTable myTable = new MyTable(); myTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc5bc294f69150a1ca2732ab6ae87d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe4b357abc1c5856f736a616e9f3ea0/" rel="bookmark">
			python第一记，长江雨课堂抓包刷课实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 发现大学群里好多代刷网课的，确实觉得好多大学网课好费时间，而且没啥用，刚好用来实战 一下学的Python，就当练手了。省下来的时间不是又能多敲几行代码😃​ 一边省时间，还能学技能，这还不学起来
一、长江雨课堂 1.分析视频请求 F12抓包
播放过程中只有hearbest一个请求，可以确定这个应该就是我们要找的
请求是POST格式，data数据是一个json，通过多个heatbest可以看出是多个观看记录
截取一个分析如下：
c: 1561016 cards_id: 2027472 cc: "" classroomid: 9763037 cp:424.6 d: 485.4 et: "playing" fp: 304.5 i: 5 lob: "ykt" n:"ali-cdn.xuetangx.com" p:"web" pg:"2027472_16s0j" skuid: "" slide: 44 sp:2 sq: 54 t:"ykt_cards" tp: 304.5 ts: "1667910647346" u: 35359786 uip: "" v: 2027472 v_url: "rain://xtvideo/id/1901324024" 没发现什么加密的字段，​那就一个一个处理
复制第一个1561016，在请求里搜索
也只有一个请求里搜索到扫一眼可以知道这是课程的列表数据
地址
https://changjiang.yuketang.cn/v2/api/web/courses/list?identity=2
请求里也莫有加密，后面有用到的我们提取保存一下
c的意思应该是class（班级）
get_classroom_id = "https://changjiang.yuketang.cn/v2/api/web/courses/list?identity=2" classroom_id_response = requests.get(url=get_classroom_id, headers=headers) for ins in json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe4b357abc1c5856f736a616e9f3ea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2977e694b10cdfa5319327660a11a080/" rel="bookmark">
			ARCGIS中相同投影不重合显示问题的解决（易康导出地图投影设置问题的解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：在易康分类完成的影像图，输出成为TTA.tif格式的影像图，在arcgis 中加载进来的时候，通过定义投影，让它与我们目标影像变成相同投影，但是两张图还是不能重合，不能在一张图上显示出来，该问题的解决方案如下：
矢量图和栅格图都是相同投影，但就是不能同时重合显示！
【解决方案】1.进行投影变换
2.地理配准，完成投影之后，还是不能重合投影，这时候需要在做一步地理配准。
做完地理配准之后 就能看到两张相同投影的矢量图和栅格图 重合显示在一起了
做个笔记 留着以后备用！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49cbbac45e924ea6bc40dc8a54e28ca/" rel="bookmark">
			Android 程序常用功能《清除缓存》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用kotlin加协程完成app的缓存清理功能
CacheDataManager 本地存储工具类 object CacheDataManager { /** * 获取缓存大小 */ fun getLocalCachesSize(context: Context): String { try { var cacheSize: Long = getFolderSize(context.cacheDir) if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { context.externalCacheDir?.let { cacheSize += getFolderSize(it) } } return getFormatSize(cacheSize.toDouble()) } catch (e: Exception) { throw e } } /** * 清除文件 */ fun clearAllCache(context: Context) { deleteDir(context.cacheDir) if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { context.externalCacheDir?.let { deleteDir(it) } } } /** * 删除文件 */ fun deleteDir(dir: File): Boolean { if (dir !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f49cbbac45e924ea6bc40dc8a54e28ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1f44371fca28e9c01e68547435db14/" rel="bookmark">
			利用CSS关键帧实现文字动态背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网页中我们时常会看到很多动效，这对我们还是很有吸引力的，今天我就看到一个文字动态背景的效果，思考了一下该怎么实现。
效果图如下：
一、实现思路 1.看见这种动画效果，首席想到的就是在文字下面添加一个背景图片，然后利用文字颜色样式将文字颜色设置为透明，然后裁剪掉文字以外的背景，最后让图片动起来（这个可以用css3中的关键帧实现）就完成了。
二、代码示例 2.1 HTML结构部分： &lt;body&gt; &lt;div class="text1 text"&gt;HTML&lt;/div&gt; &lt;div class="text2 text"&gt;CSS&lt;/div&gt; &lt;div class="text3 text"&gt;JavaScript&lt;/div&gt; &lt;/body&gt; 放置3个div，设置相应的类名，然后文字部分写上你想要展示的文字。
2.2 CSS样式部分 &lt;style&gt; .text { width: 800px; font-size: 120px; font-weight: 900; margin: auto; color: transparent; } .text1 { background: url(./img/04.jpg); -webkit-background-clip: text; animation: moveImg 7s infinite alternate linear; } .text2 { background: url(./img/03.png); -webkit-background-clip: text; animation: moveImg 5s infinite alternate linear; } .text3 { background: url(./img/01.jpg); -webkit-background-clip: text; animation: moveImg 8s infinite alternate linear; } @keyframes moveImg { 0% { background-position: 0%; } 50% { background-position: 50%; } 100% { background-position: 100%; } } &lt;/style&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1f44371fca28e9c01e68547435db14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e451cf45f51a77cb53e3ab16b05f7ad8/" rel="bookmark">
			ES6的Promise详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Promise的概念二、使用Promise创建 PromisePromise 常用方法Promise.prototype.then()Promise.prototype.catch()all()链式调用 前言 本篇文章主要介绍了ES6语法中的Promise对象的使用详解,promise对象是JS进阶学习中的重要知识点，
如果本文对你有所帮助请三连支持博主，你的支持是我更新的动力，先赞后看养成习惯。
以下是本篇文章正文内容
一、Promise的概念 Promise是异步编程的一种解决方案，是一个对象，可以获取异步操作的消息，大大改善了异步编程的困难，避免了回调地狱，比传统的解决方案回调函数和事件更合理和更强大。
所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
ES6 开始支持 Promise
Promise 对象用于一个异步操作的最终完成（包括成功和失败）及结果值的表示。简而言之，就是处理异步请求的。之所以叫做 Promise，就是承诺做这件事，如果成功则怎么处理，失败则怎么处理。
Promise 首先是一个对象 (是一个对象！！！！)，它通常用于描述现在开始执行，一段时间后才能获得结果的行为（异步行为），内部保存了该异步行为的结果。然后，它还是一个有状态的对象：
pending：待定fulfilled：兑现，有时候也叫解决（resolved）rejected：拒绝 一个 Promise 只有这 3 种状态，且状态的转换过程有且仅有 2 种：
pending 到 fulfilled （resolved）pending 到 rejected 二、使用Promise 创建 Promise 调用 Promise 构造函数来创建一个 Promise。
let promise = new Promise((resolve, reject) =&gt; {// 要做的事情...}); Promise 构造函数接收一个函数作为参数，该函数的两个参数是 resolve，reject，它们由 JavaScript 引擎提供。
resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e451cf45f51a77cb53e3ab16b05f7ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a21a0c7845fefa1074ca1304afa4743/" rel="bookmark">
			日常学习记录——目前学习记录总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 已了解或已实践内容 1. 机器学习算法相关
常用的两个算法库：sklearn、imbalanced-learn。
决策树算法——基于信息熵、基于信息增益、基于Gini指数模糊决策树算法——决策树算法的改进版本随机森林算法——基于Gini指数的CART决策树的集成学习算法平衡随机森林——面向不平衡数据集的随即森林算法的改进版本KNN K邻近算法——分类算法KMeans K均值算法——求聚类中心常用算法支持向量机——线性Linear-SVM分类算法、非线性SVC分类算法AdaBoost集成提升树算法——有基于支持向量机的，也有基于决策树的集成学习分类器AdaCost代价敏感算法——面向不平衡数据的集成学习分类算法SMOTEBoost——重采样集成分类算法RUSTBoost——欠采样聚类集成分类算法 2、神经网络相关：
tensorfow框架的神经网络和卷积神经网络——因为我数据集的数据量不够，使用神经网络进行训练时，效果很差，后续没有再深入了解。 3、wireshark 自定义报文解析插件：
Lua语言 —— 如果想在wireshark上显示中文最好使用UltraEdit进行编辑。新手友好的参考文献：Lua编写Wireshark插件实战。 4、已过书单：
《软技能：代码之外的生存指南》《软技能2：软件开发者职业生涯指南》《程序员修炼之道：从小工到专家》《我编程，我快乐：程序员职业规划之道》 2 未来想要深入了解的内容 1、想要过一遍的书单
《代码整洁之道》《代码大全》《修改代码的艺术》《重构：改善既有代码的设计》 2、实践内容
《笨方法学python》——重点是学习测试用例相关的知识，想要了解更多测试驱动开发的内容。算法的了解和实践。 3 内容输出 1、重要日期
实践内容——重要且紧急——年前完成 2、学习产出
《笨方法学习python》的重点知识与收获整理博客；算法实践阶段性的总结博客。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ee6c9105cdd8f2f8b4f4bbc7388126/" rel="bookmark">
			Vue3应用API——use解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、app.use1.使用场景2.原理 二、封装自定义插件1.写法一2.写法二3.应用插件4.注意事项 总结 一、app.use 1.使用场景 不论是Vue2中的Vue.use亦或者Vue3中的app.use。其功能主要是用在插件的安装上，往往是在项目的入口文件（比如main.js）中。被use的插件多数是 NPM 中的第三方库 。在必要的时候，也可以封装一个自定义的插件以供团队的使用。这样可以避免反复开发同一个功能。
2.原理 从Vue源码对 app.use 描述可以看出，app.use(plugin) 中的核心部分是 “plugin(app, …options)” 和 “plugin.install(app, …options)” 这两句；
也就是说，app.use(plugin)，本质上就是把plugin中的 install 方法调用一遍；
不仅如此，还可以发现 Vue 框架在 install 函数中暴露了 app实例, 所以在实际开发中能挂载到 app实例上的都可以在install函数中实现，然后通过app.use()将插件快速地应用到各个项目中；
由此看来，我们也可以通过封装自定义插件供开发使用。
二、封装自定义插件 一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身
1.写法一 拥有 install() 方法的对象
// 写法一：对象中定义 install 函数 let myPlugin = { install(app) { // 定义一个实例方法 app.config.globalProperties.sayHello = function () { alert('Hello, Nancy!'); } // 定义一个全局指令：元素挂载后"自动聚焦"及"动态绑定数据" app.directive('myModel', { mounted(el, binding) { el.focus(); el.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ee6c9105cdd8f2f8b4f4bbc7388126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508747e0d72b800f84052a3b4388ac37/" rel="bookmark">
			Vue3应用API——设置全局属性(app.provide与app.config.globalProperties的区别)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、app.provide1.全局注入2.inject接收 二、app.config.globalProperties1.用法 三、区别1.访问方式2.使用场景 一、app.provide 1.全局注入 通过 provide 注入一个应用范围内所有组件都可以使用的值
import { createApp } from 'vue' import App from './App.vue' let app = createApp(App); // 通过 app.provide(key, value) 全局注入一个属性 name app.provide('name', 'provideName'); app.mount('#app'); 2.inject接收 应用范围内任意组件要使用provide提供的的值时，都可以通过 inject 进行接收
&lt;template&gt; &lt;!-- provideName --&gt; &lt;p&gt;{{ name }}&lt;/p&gt; &lt;/template&gt; &lt;script setup&gt; import { inject, onMounted } from 'vue'; // 组件中使用 inject 通过 key 接收全局属性 let name = inject("name"); onMounted(() =&gt; { console.log(name);	// provideName }) &lt;/script&gt; 二、app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508747e0d72b800f84052a3b4388ac37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8bc1353d3b5585412e476d9f0c2888/" rel="bookmark">
			搭建开放式与认证式个人网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建开放式与认证式个人网站 （一）．设置个人用户主页 开启个人用户主页功能；
【vim /etc/httpd/conf.d/userdir.conf】
编辑/etc/httpd/conf.d/userdir.conf文件，在第17行的UserDir disabled参数前面加上井号（#），表示让httpd服务程序开启个人用户主页功能；同时再把第24行的UserDir public_html参数前面的井号（#）删除（UserDir参数表示网站数据在用户家目录中的保存目录的名称，即public_html目录）；最后，在修改完毕后记得保存，如图所示：
建立主页文件
【useradd linux-yhy】
【cd /home/linux-yhy】
【mkdir public_html】
【echo “This is linux-yhy’s website” &gt; public_html/index.html】
【chmod -Rf 755 /home/linux-yhy】
重启httpd服务程序与验证
【systemctl restart httpd】
修改SELinux安全策略
httpd服务程序在提供个人用户主页功能时，该用户的网站数据目录本身就应该是存放到与这位用户对应的家目录中的，所以不需要修改家目录的SELinux安全上下文。但是，Linux操作系统还有一个域的概念。Linux域可以确保服务程序不执行违规操作，只能本本分分地为用户提供服务。使用getsebool命令查询并过滤出所有与HTTP协议相关的安全策略。其中，off表示禁止状态，on表示允许状态。
【setsebool -P httpd_enable_homedirs=on】
一定要记得在setsebool命令后面加上-P参数，以使修改后的SELinux策略永久生效且立即生效。随后刷新网页。
（二）让通过身份验证的用户访问网页里面的内容 生产密码数据库
使用htpasswd命令生成密码数据库。-c参数表示第一次生成；后面再分别添加密码数据库的存放文件，以及验证要用到的用户名称（该用户不必是系统中已有的本地账户）。
【htpasswd -c /etc/httpd/passwd linux-yhy】
编辑个人用户主页功能的配置文件
【vim /etc/httpd/conf.d/userdir.conf】
33 authuserfile “/etc/httpd/passwd” #刚刚生成的密码验证文件保存路径
34 authname “My privately website” #当用户尝试访问个人用户网站时的提示信息
36 require user linux-yhy #用户进行账户密码登录时需要验证的用户名称
【systemctl retart httpd】
3.访问验证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f9568de39eafe654d451c805386e5d/" rel="bookmark">
			ts学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ts 为了解决弱语言的存在 编译 tsc xxx.ts会转化为js文件 ts的语言类型 let a:number let b:string let c:boolean //字面量进行类型声明 let a:number|string; let b:10|20; a=10 b=20 let d:any //表示任意类型 let d //隐式转换为any类型 let e:unknown //与any类似，但是不能给别人赋值 //断言 let s:string s = e as string //进行断言后可以进行赋值 //函数 function aaa(x:number,y:number) :number{//指定返回值类型 return (x+y) } function aaa(x:number,y:number) :void{//指定返回值类型，返回空 } function aaa(x:number,y:number) :never{//指定返回值类型，没有返回值 可以用来throw new err } //对象 let b:{name:string,age?:number} let c:{name:number ,[propName:string]:any}//键值对，键必须为字符串，值可以为任何值 //函数 let a:(a:number ,b:number)=&gt;number //数组 let a:number[] let b:Array&lt;string&gt; //元组（固定长度的数组） let a:[string,number] //枚举 enum gende1r{ Male, Female } let i:{name:string,gender:gende1r} //类型 type aaa = 1|2|3|4|5 let a:aaa 实现类似于nodemon的功能： tsc --init 创建配置文件 tsconfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f9568de39eafe654d451c805386e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b64dda6551b2b2fef0e5b3b489cdb41/" rel="bookmark">
			基于javaweb&#43;mysql的新闻管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的新闻管理系统
运行环境
Java≥8、MySQL≥5.7
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
用户：登录、注册、新闻增删改
技术框架
HTML CSS JavaScript jQuery Bootstrap thymeleaf SpringBoot SpringMVC MyBatis
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
&lt;/if&gt; &lt;if test="introduction != null" &gt; #{introduction,jdbcType=LONGVARCHAR}, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.demo.pojo.User" &gt; update users &lt;set &gt; &lt;if test="email != null" &gt; email = #{email,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test="username != null" &gt; username = #{username,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test="password != null" &gt; password = #{password,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test="age != null"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b64dda6551b2b2fef0e5b3b489cdb41/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/199/">«</a>
	<span class="pagination__item pagination__item--current">200/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/201/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>