<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce83f311d9b783febb90795f2cee6c9/" rel="bookmark">
			音频深度学习变得简单1：最先进的技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章我将介绍这个主题并概述音频应用的深度学习前景。我们将了解什么是音频以及它是如何以数字方式表示的。我将讨论音频应用程序对我们日常生活的广泛影响，并探索它们使用的架构和模型技术。
什么是声音？ 声音信号是由气压变化产生的，我们可以测量压力变化的强度并绘制这些测量值随时间的变化。声音信号通常以固定间隔重复，因此每个波具有相同的形状。高度表示声音的强度，称为振幅。信号完成一个全波所用的时间就是周期。信号在一秒钟内发出的波数称为频率。频率是周期的倒数。频率的单位是赫兹。也就是模拟信号。
我们遇到的大多数声音可能并不遵循如此简单和规律的周期性模式。但是可以将不同频率的信号加在一起以创建具有更复杂重复模式的复合信号。我们听到的所有声音，包括我们自己的人声，都是由这样的波形组成的。
我们如何以数字方式表示声音？ 要将声波数字化，我们必须将信号转换为一系列数字，以便我们可以将其输入到模型中。这是通过以固定的时间间隔测量声音的幅度来完成的。
定期采样测量
对模拟信号进行采样，每个这样的测量称为一个样本，采样率是每秒的样本数。例如，常见的采样率约为每秒 44,100 个样本。这意味着一个 10 秒的音乐剪辑将有 441,000 个样本！
为深度学习模型准备音频数据 音频机器学习应用程序过去依赖传统的数字信号处理技术来提取特征。随着深度学习的普遍，不再需要传统的音频处理技术，不用大量手动和自定义特征。依靠准备好的数据。更有趣的是，通过深度学习，我们实际上并没有处理原始形式的音频数据。相反，常用的方法是将音频数据转换为图像，然后使用标准的 CNN 架构来处理这些图像！
这是通过从音频生成频谱图来完成的。所以首先让我们了解什么是频谱，并用它来理解频谱图。
频谱是组合在一起产生信号的一组频率。频谱绘制了信号中存在的所有频率以及每个频率的强度或幅度。
频谱显示构成声音信号的频率
信号中的最低频率称为基频。基频的整数倍的频率称为谐波。例如，如果基频为 200 Hz，则其谐波频率为 400 Hz、600 Hz 等。
时域与频域 由于 x 轴显示了信号的时间值范围，因此我们在时域中查看信号。频谱是表示相同信号的另一种方式。它显示幅度与频率的关系，并且由于 x 轴显示信号的频率值范围，因此在某个时刻，我们正在频域中查看信号。
频谱图 由于信号随时间变化而产生不同的声音，因此其组成频率也随时间变化。换句话说，它的频谱随时间而变化。
信号的频谱图随时间绘制其频谱，就像信号的“照片”。它在 x 轴上绘制时间，在 y 轴上绘制频率。就好像我们在不同的时间点一次又一次地拍摄光谱，然后将它们全部连接到一个情节中。
它使用不同的颜色来表示每个频率的幅度或强度。颜色越亮，信号的能量就越高。频谱图的每个垂直“切片”本质上是该时刻信号的频谱，并显示了信号强度在该时刻信号中每个频率的分布情况。
在下面的示例中，第一张图片显示了时域中的信号，即。幅度与时间。它让我们了解剪辑在任何时间点的响度或安静程度，但它给我们提供的关于存在哪些频率的信息很少。
第二张图片是频谱图，显示频域中的信号。
生成频谱图 使用傅里叶变换生成频谱图，将任何信号分解为其组成频率. 我们实际上不需要回忆所有的数学，有非常方便的 Python 库函数可以一步为我们生成频谱图。
音频深度学习模型 现在我们了解了频谱图是什么，我们意识到它是音频信号的等效紧凑表示，有点像信号的“指纹”。这是一种将音频数据的基本特征捕获为图像的优雅方式。
所以大多数深度学习音频应用程序都使用频谱图来表示音频。他们通常遵循这样的程序：
从波形文件形式的原始音频数据开始。将音频数据转换为其相应的频谱图。或者，使用简单的音频处理技术来增强频谱图数据。（也可以在频谱图转换之前对原始音频数据进行一些增强或清理）现在我们有了图像数据，我们可以使用标准的 CNN 架构来处理它们并提取特征图，这些特征图是频谱图图像的编码表示。 下一步是根据您要解决的问题，从此编码表示生成输出预测。
例如，对于音频分类问题，您可以将其传递给通常由一些完全连接的线性层组成的分类器。对于 Speech-to-Text 问题，您可以将其通过一些 RNN 层以从该编码表示中提取文本句子。 当然，我们跳过了很多细节，做了一些广泛的概括，但在本文中，我们停留在一个相当高的水平。在接下来的文章中，我们将详细介绍所有这些步骤和所使用的架构。
音频深度学习解决了哪些问题？ 音频分类 这是最常见的用例之一，涉及获取声音并将其分配给多个类之一。例如，任务可能是识别声音的类型或来源。例如。这是汽车启动，这是锤子，哨子还是狗吠
显然，可能的应用是广泛的。这可以用于根据机器或设备产生的声音检测机器或设备的故障，或者在监视系统中检测安全入侵。
音频分离和分割 音频分离涉及从混合信号中分离出感兴趣的信号，以便随后将其用于进一步处理。例如，您可能希望将个人的声音从大量背景噪音中分离出来，或者将小提琴的声音从音乐​​表演的其余部分中分离出来。
音频分割用于突出音频流中的相关部分。例如，它可以用于诊断目的，以检测人类心脏的不同声音并检测异常情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce83f311d9b783febb90795f2cee6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80aaa394c176a8bdc252f670ec94953f/" rel="bookmark">
			Android-问题记录Failed to delete some children. This might happen because a process has files open or ha
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重推项目遇到问题
Failed to delete some children. This might happen because a process has files open or has its working directory set in the target directory.
打包失败
记录问题以及处理方式
​​​​​​​​​​​​​​android studio 编译项目时提示Failed to delete some children. This might happen because a process has_peak wang的博客-CSDN博客
在Terminal下输入exit退出目录 有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c64322ce557bf22169707ae58ea0a0/" rel="bookmark">
			使用UE5推流到OBS进行直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间一直在做数字虚拟人，有个需求是由真人驱动数字人跟客户进行实时交流。我的方法是metahuman生成虚拟人，然后使用iphone的live link face驱动面部（头部）。介绍这个的文章很多，我就不再赘述了。
这里主要说一下驱动虚拟人之后，UE5怎么把视频流推送到OBS上。先看看我们的UE5和OBS有没有安装插件。如果安装过了，会在UE5的界面里出现Off World Live的菜单，如果没有这个菜单就说明还没有安装插件。（如下图）
然后再看看OBS，如果【来源】菜单中没有【Spout2捕获】的选项。如果有没有这个选项就说明OBS也需要安装插件。（如下图）
接下来先介绍一下怎么下载和安装插件。先打开网站Download Center: Off World Live，这个网站有时候打不开，多试几次吧，总有能打开的时候。（如下图）
网页上Unreal Engine Live-streaming Toolkit是UE的插件，在下拉菜单里选择自己的UE版本，然后下载就行了，我选择的是v0.122.0-ue5.0(installer)。下载后的文件是：nstaller_OWLLivestreamingToolkit_v0.122.0-ue5.0.exe
网页上Spout plug-in for OBS Studio是OBS的插件，直接下载。下载后的文件是：OBS_Spout2_Plugin_Install_v1.6-beta.exe
可能你下载的版本会跟我不同，这个没关系，用最新版本就行。
接下来直接安装，安装顺序无所谓，我先安装的是nstaller_OWLLivestreamingToolkit_v0.122.0-ue5.0
安装过程见下图：
这里的安装路径要选择UE5的目录下（见下图）
到这里UE5的插件就安装完成了，我们检查一下。打开UE5，在【设置】里打开【插件】（如下图）
在【插件】界面中点击左侧的【已安装】，然后选中右侧的【Off World Live Livestreaming Toolkit】。选中之后，在界面右侧下方会提示【立即重启】UE5。咱们直接点击重启一下就可以了。（如下图）
重启UE5之后，再点击【Off World Live】下拉菜单【Log In】登录一下。如果没有账户就注册一下。登录成功后，下拉菜单会变成Log Out（见下图）
登录成功后，我们在场景里放入一台视频捕捉设备，这里选择【Off World Live】的【OWLCine Cam Capture】（如下图）
摄像机放好之后，我们调整一下属性，我喜欢使用30mm的焦距，采用手动调焦。（如下图）
再接下来我们要给场景安装一个Spout的发射器。选择【Off World Live】菜单的【OWLSpout Sender Manager】摄像机（如下图）
在场景里会出现一个【OWLSpout Sender Manager】（如下图）
现在，在【大纲】的【项目标签】当中选中刚才创建的【OWLCine Cam Capture】摄像机（如下图）
在摄像机【Off World Live】属性中【Texture Target】的下拉菜单中选择【渲染目标】（如下图）
在弹出的【资产另存为】界面中点击保存（如下图）
保存完成后，会在【内容浏览器】中出现刚保存的文件【NewTextureRenderTarget2D】（如下图）
此时可以点击【大纲】的【项目标签】当中【OWLCine Cam Capture】摄像机，如果【Off World Live】属性中【Texture Target】变成了刚创建的【NewTextureRenderTarget2D】就说明操作正确了（如下图）
下面选中【大纲】的【项目标签】当中【OWLSpout Sender Manager】，找到其中的【Off World Live Spout Sender Settings】属性（如下图）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c64322ce557bf22169707ae58ea0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509f41173a960e98c1bf608f6dfeaa52/" rel="bookmark">
			树莓派制作自己的小车车（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备材料：
一个电机驱动板 （控制马达，防止树莓派主板报废）
一个智能小车底盘（包含马达）
一个电池 (给电机驱动板供电或者充电宝接正负连接电机驱动板）
一个充电宝 （给树莓派供电）
一个树莓派 （可以只买板子）
一个扩展版 （只用白色的板子）
3组杜邦线 （多来点）
铜线一捆 （连接正负）
热熔胶 （固定小车）
一快电池 （用来测试马达）
扎带 （长一点）我买的4*200有点短
可以自行购买
充电宝usb转正负 二 、设备介绍
1.主板介绍
2.接口介绍
红色部分按照下面的编号来的
可以把 5v看成正， GND看成负 gpio 相当于接口，可以让树莓派和不同的模块组件进行交互
3.面包板主要用于扩展接口
中间在没有连接的时候是灰色的
当正和3连接就说明3这一行是带有正的
当负和4连接就说明4这一行是带有负的
3和1连，此时1带正。4和2连，此时2带负。
4.电机驱动板
在逻辑输入的里面还有4个铁丝 左边2 是输出a ，右边2是输出b。
红框为正，灰框为负 输出a ，b 的地方用来连接马达
三、调整设备
1. 树莓派 拷入 官方 系统
教程 教树莓派教程第三课系统烧录十分钟玩转系列入门篇_哔哩哔哩_bilibili
软件链接：
链接： https://pan.baidu.com/s/1ynz6HevwHRTEvZztxhda5g?pwd=v2ib 提取码：v2ib --来自百度网盘超级会员V3的分享
2. 电脑连接树莓派界面 （此方法需要先连接树莓派，树莓派 wifi 只识别2.4GHz）
常见的连接软件有 vnc xshell7 Putty 等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509f41173a960e98c1bf608f6dfeaa52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014fbd19d0ea17aa8f48f563d55a2e8e/" rel="bookmark">
			模态分析 Modal analysis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 [1] Bishop, R., Gladwell, G., &amp; Michaelson, S. (1979). The Matrix Analysis of Vibration. Cambridge: Cambridge University Press. doi:10.1017/CBO9780511569487
[2] Scruton, C. (1961). The Mechanics of Vibration.R. E. D. Bishop and D. C. Johnson. Cambridge University Press, London. 1960. 592 pp. Diagrams. £6. The Journal of the Royal Aeronautical Society, 65(604), 299-299. doi:10.1017/S036839310008994X
[3] Lecture Notes, Peter Avitabile, Modal Analysis I &amp; II, University of Massachusetts Lowell.https://www.uml.edu/docs/Modal_Space_Articles_1998-2014_17years_MACL_tcm18-189938.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ccfdbc79f8ea9e9285874d8b6ef66c/" rel="bookmark">
			笔记｜李沐-动手学习机器学习｜CNN基础知识（视频19-23）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		李沐-动手学习机器学习｜CNN基础知识 卷积层（视频19）从全连接到卷积（卷积算子）进行图像识别的两个原则如何从全连接层出发，应用以上两个原则，得到卷积 卷积层二维交叉相关二维卷积层交叉相关v.s. 卷积一维、三维交叉相关 卷积层里的「填充」和「步幅」（对应视频20）填充步幅代码 卷积层里的多输入多输出通道（视频21）多个输入通道多个输出通道多个输入输出通道1*1 卷积层二维卷积层代码 池化层（视频22）二维最大池化层平均池化层代码 经典卷积神经网络LeNet（视频23）LetNet实现学习如何手动检查模型 李沐b站课程视频： 【完结】动手学深度学习 PyTorch版 卷积层（视频19） 从全连接到卷积（卷积算子） 进行图像识别的两个原则 平移不变性（不管目标物体在图像的哪个位置都能识别出来）局部性（要识别目标物体无需遍历很广部分就能识别） 如何从全连接层出发，应用以上两个原则，得到卷积 （回顾）全连接层时，虽然图像有高、宽，但是我们会将其转变成一个1维向量。即，输入和输出均为一维向量。
（现在）将图像还原成矩阵，因为需要考虑一些空间的信息。
将输入输出“变形”为矩阵（高度，宽度）将权重对应为4D张量（（h，w）-&gt;（h‘，w’），2*2 = 4）对w进行重新索引（方便后面看清实现卷积的过程） 那么，输出的h可以写为（对应x的下标也要进行变换）：
原则 #1 平移不变性
位置变换即i，j的变化。要满足原则1，需要v的值与i，j无关，即：
这就是「二维交叉相关」（容易错误说成“二维卷积”，但在数学上来说，这不叫卷积，而是交叉相关）
原则 #2 局部性
经过原则1，我们得到了
其中可以理解为以（i，j）为中心，需要遍历以外的所有a，b
但若要满足原则2，应该只需要遍历（i，j）附近的点（不应用到远离x_i,j 的参数），即：
总结：对全连接层应用「平移不变性」和「不变性」得到卷积层（所以也说卷积层是一种特殊的全连接层）
卷积层 二维交叉相关 kernel就是w
二维卷积层 一个神经网络可以去学习一些不同的kernel，来得到一些不同的图像处理效果
交叉相关v.s. 卷积 唯一的区别是卷积多了个负号。但在实际应用中，由于对称性两者没有区别。而且实际常用的是交叉相关而非卷积（虽然都会叫做卷积）
一维、三维交叉相关 常写作Cov2D、Cov3D…最常用的是Cov2D
总结
卷积层：将核矩阵和输入进行交叉相关，再加上偏差；
可学习的参数：核矩阵、偏移
超参数：矩阵的大小
卷积层里的「填充」和「步幅」（对应视频20） 两个控制输出大小的超参数
填充 对于给定的图像，卷积核越大，输入变小地越快。
如果不希望变小地这么快，就可以用到「填充」
填充：在输入周围加入额外的行和列
这样子可以使得输入和输出的维度不变
步幅 当图片特别大，卷积核不太大，需要大量的计算才能得到较小的输出。这时就可以调整「步幅」。
步幅：是指行/列的滑动步长
总结
填充和步幅是卷积层的超参数；
填充在输入周围加入额外的行和列，控制输出形状的减少；
步幅是每次窗口核滑动的行/列步长，来成倍的减小输出形状。
代码 设定padding、stride这两个参数
在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并(在所有侧边填充1个像素)。给定高度和宽度为8的输入，则输出的高度和宽度也是8。
1）准备
import torch from torch import nn 2）定义函数comp_conv2d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ccfdbc79f8ea9e9285874d8b6ef66c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58af15f4ada9d31031419b45f4b400c/" rel="bookmark">
			0基础学Linux-从小白到大牛（4）Linux命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用命令系统命令权限帮助文档文件相关命令VIM查找打包与压缩正则表达式输入输出重定向进程控制 常用命令 1.进入到用户根目录 cd ~ 或 cd 2.查看当前所在目录 pwd 3.进入到hadoop用户根目录 cd ~hadoop 4.返回到原来目录 cd - 5.返回到上一级目录 cd .. 6.查看hadoop用户根目录下的所有文件 ls ll 7.在根目录下创建一个hadoop的文件夹 mkdir /hadoop 8.在/hadoop目录下创建src和WebRoot两个文件夹 分别创建：mkdir /hadoop/src mkdir /hadoop/WebRoot 同时创建：mkdir /hadoop/{src,WebRoot} 进入到/hadoop目录，在该目录下创建.classpath和README文件 分别创建：touch .classpath touch README 同时创建：touch {.classpath,README} 在/hadoop目录下面创建一个test.txt文件,同时写入内容"this is test" echo "this is test" &gt; test.txt 查看一下test.txt的内容 cat test.txt more test.txt less test.txt 向README文件追加写入"please read me first" echo "please read me first" &gt;&gt; README 将test.txt的内容追加到README文件中 cat test.txt &gt;&gt; README 拷贝/hadoop目录下的所有文件到/hadoop-bak cp -r /hadoop /hadoop-bak 进入到/hadoop-bak目录，将test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b58af15f4ada9d31031419b45f4b400c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2217b61e363508b616c43a05645af896/" rel="bookmark">
			0基础学Linux-从小白到大牛（3）Linux命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 权限管理列出目录内容: ls显示inode的内容：stat文件访问权限修改文件权限：chmod修改文件所有者：chown修改文件所属组：chgrp 文件内容查看基本显示：cat、tac显示行号：nl分屏显示取首尾n行：head、tail 文件管理输出重定向：&gt;管道：|清屏：clear切换工作目录：cd创建目录：mkdir删除文件：rm建立链接文件：ln文本搜索：grep查找文件：find拷贝文件：cp移动文件：mv归档管理：tar文件压缩解压：gzip、bzip2文件压缩解压：zip、unzip查看命令位置：which 用户和用户组管理查看当前用户：whoami查看登录用户：who退出登录账户： exit添加用户账户：useradd修改用户：usermod设置用户密码：passwd删除用户：userdel以root身份执行指令：sudo添加和删除组账户：groupadd、groupdel用户组管理：groupmod 系统管理查看当前日历：cal显示或设置时间：dete查看网络状态：netstat查看进程信息：ps以树状图显示进程关系：pstree动态显示进程：top终止进程：kill关机重启：reboot、shutdown、init检查磁盘空间：df检测目录所占磁盘空间：du查看或配置网卡信息：ifconfig测试远程主机连通性：pingLinux 磁盘管理dfdufdisk磁盘格式化磁盘检验磁盘挂载与卸除Linux管道命令WC - 统计字数cut - 列选取命令grep - 行选取命令sort - 排序uniq - 去重tee - 同时输出多个文件split - 文件切割 权限管理 列出目录内容: ls Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“…”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。
ls常用参数：
参数含义-a显示指定目录下所有子目录与文件，包括隐藏文件-l以列表方式显示文件的详细信息-h配合 -l 以人性化的方式显示文件大小 信息含义：
ls支持通配符：
通配符含义*文件代表文件名中所有字符ls te*查找以te开头的文件ls *html查找结尾为html的文件？代表文件名中任意一个字符ls ?.c只找第一个字符任意，后缀为.c的文件ls a.?只找只有3个字符，前2字符为a.，最后一个字符任意的文件[][”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。[abc]匹配a、b、c中的任意一个[a-f]匹配从a到f范围内的的任意一个字符ls [a-f]*找到从a到f范围内的的任意一个字符开头的文件ls a-f查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用\如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。ls *a查找文件名为*a的文件 显示inode的内容：stat stat [文件或目录] 文件访问权限 用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：
读权限（r） ：对于文件，具有读取文件内容的权限；对于目录，具有浏览目录的权限。写权限（w） ：对于文件，具有修改文件内容的权限；对于目录，具有删除、移动目录内文件的权限。可执行权限（x）： 对于文件，具有执行文件的权限；对于目录，该用户具有进入目录的权限。 通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。
示例：
第1个字母代表文件的类型：
“d” 代表文件夹“-” 代表普通文件“c” 代表硬件字符设备“b” 代表硬件块设备“s”表示管道文件“l” 代表软链接文件。 后9个字母分别代表三组权限：文件所有者、用户组、其他用户拥有的权限。
修改文件权限：chmod chmod 修改文件权限有两种使用格式：字母法与数字法。
字母法：chmod u/g/o/a ＋ +/-/= rwx 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2217b61e363508b616c43a05645af896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536b9d086d60e1f8627d28c431c8df2b/" rel="bookmark">
			当我们使用element-ui，el-button里面的@click事件不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.当@click点击无效的时候
&lt;el-button type="primary" @click="login"&gt;登录&lt;/el-button&gt; 2.在@click后面加上.native即可
&lt;el-button type="primary" @click.native="login"&gt;登录&lt;/el-button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a439680af52cbdf6341bb3c0d6c6d5/" rel="bookmark">
			Elements in iteration expect to have ‘v-bind:key‘ directi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景
在写vue项目，写到v-for循环的时候出现了原因是：v-for在Eslint的规则检查下报错。
v-for="(item, index) in todoList" 底下一堆红色的波浪线
解决
报错中说：Elements in iteration expect to have 'v-bind:key' directives
迭代中的元素希望有“v-bind:key”指令
网上有很多的解决方案是：屏蔽ESLint对vue语法的检查。
我个人认为这种方法不太好，ESLint都检查出来了代码那里写得不好，你还去屏蔽他。
在v-for后面加上:key="index"就可以了。key的值最好是唯一标识
v-for="(item, index) in todoList" :key="index" 就可以了，其实用index也有不好的地方。这方面大家自行百度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36e567fe809df1196f9b8768a30e0f3/" rel="bookmark">
			springboot学习(七十三) springboot中使用springdoc替换swagger(springfox)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、springdoc介绍二、使用步骤1.引入库2. 创建一个spring配置类，添加springdoc的配置3. 常用的swagger注解和springdoc的对应关系4. 一个接口类的示例5. 配置文件配置6. WebMvc配置7. UI 前言 距离swagger上次发布版本已经过去两年多了，一直没有更新，与当前的springboot2.6.x、springboot2.7.x存在各种兼容问题，对于即将发布的springboot3.x，可能存在更多兼容问题。如下图所示。
其实swagger还在更新，应该是springfox不更新导致的，所以需要使用其他的API管理工具代替,springdoc是一种选择
一、springdoc介绍 SpringDoc是一款可以结合SpringBoot使用的API文档生成工具，基于OpenAPI 3，是一款更好用的Swagger库！值得一提的是SpringDoc不仅支持Spring WebMvc项目，还可以支持Spring WebFlux项目，甚至Spring Rest和Spring Native项目。
二、使用步骤 1.引入库 gradle：
api group: 'org.springdoc', name: 'springdoc-openapi-ui', version: '1.6.11' maven:
&lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; 2. 创建一个spring配置类，添加springdoc的配置 @AutoConfiguration public class SpringDocConfig { @Bean public OpenAPI openAPI() { return new OpenAPI() .info(new Info() .title("newframe-接口文档") .description("基于SpringDoc的在线接口文档") .version("0.0.1")); } @Bean public GroupedOpenApi publicApi() { return GroupedOpenApi.builder() .group("权限相关") .packagesToScan("com.iscas.biz.controller.common.auth") .build(); } @Bean public GroupedOpenApi adminApi() { return GroupedOpenApi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36e567fe809df1196f9b8768a30e0f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e89fed90f32d1d5ff32dd8462601f16f/" rel="bookmark">
			Github桌面端上传远程仓库以及将私有仓库改为公有仓库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.桌面端上传远程仓库 pass 1: 在github上下载一个桌面端应用程序.exe
pass 2: 用自己的github进行登录，可以在程序的头部栏看到一些应用操作，下载后登录了解即可
可以打开自己的github仓库，再打开本地文件夹，上传流自己的代码或者文件（是同步的）
详细过程见续更
2.私有仓库改为公有仓库的方法 将私有仓库转变为共有仓库的操作如下：
1）进入你想要操作的代码仓库页面；
2）点击Settings进入设置页面；
3）往下拉到Danger Zone，选择Make Public；
4）之后可能会提示你输入当前仓库的完整名字以确认操作，正确输入当前仓库名字后还可能需要输入GitHub账户的密码，按照提示输入、确认；
5）当你看到这个页面时，说明已经成功将私有库转换为共有库。注意：此时的仓库名字后面没有“Private”字样。
共有仓库转换为私有仓库，步骤几乎是一致的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0293a694bb771e43a27f471b4ca593a/" rel="bookmark">
			基于微信小程序的校园失物招领寻物启事系统 java uniapp 小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息化时代的到来,管理系统都趋向于智能化、系统化,微信小程序校园失物招领也不例外,但目前国内的市场仍都使用人工管理,市场规模越来越大,同时信息量也越来越庞大,人工管理显然已无法应对时代的变化,而微信小程序校园失物招领能很好地解决这一问题,轻松应对校园失物招领平时的工作,既能提高人力物力财力,又能加快工作的效率,取代人工管理是必然趋势。
本微信小程序校园失物招领以ssm作为框架,b/s模式以及MySql作为后台运行的数据库,同时使用Tomcat用为系统的服务器。本系统主要包括首页、个人中心、用户管理、发布人管理、物品类别管理、失物招领管理、寻物启事管理、认领验证管理、系统管理等功能,通过这些功能的实现能够基本满足日常校园失物招领管理的操作。
环境需要
1.运行环境：微信开发者工具，最好是java jdk 1.8，这是目前最稳定的JDK也是被使用最多的JDK版本。
2.IDE环境：IDEA，Eclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat7/Tomcat8/Tomcat9版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.数据库：MySql 5.7版本或以上版本；
6.是否Maven项目：是；
技术栈
后端：Spring+SpringMVC+Mybatis+Springboot
小程序端：uni-app+微信开发者工具混合开发模式
前台功能：用户进入系统可以实现首页、失物招领、公告信息、我的等,在我的页面可以对失物招领、寻物启事、认领验证、在线客服等功能进行操作：
后台主要是管理员和发布人,管理员功能包括首页、个人中心、用户管理、发布人管理、物品类别管理、失物招领管理、寻物启事管理、认领验证管理、系统管理等：发发布人功能包括首页、个人中心、失物招领管理、寻物启事管理、认领验证管理等：
微信开发者工具现在已经被小程序开发团队开发运行，目前微信开发者工具任然在不断的完善中，在开发小程序时经常要不断的更新。可以使用微信扫码登陆开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。
机型选择：小程序以智能手机的屏幕尺寸为设计标准，进行切图。
预览界面：写好视图布局后点击编译，用来刷新视图界面。
控制台：方便调试打印输出信息。
上传代码：上传到腾讯服务器，提交审核必经步骤。上传代码时可以填写版本号和备注信息。
资源文件：一般可以在资源文件进行对应项目的文件目录的断点调试。
显示远程调试：手机端和PC端开发工具联调对用户而言是非常实用的。
本地数据存储：显示的是本地存储的数据。
视图调试：标组件以子父层级结构呈现，方便调试。
微信限制在2M 以内的代码体积；开发中一般不校验合法域名信息；小程序后台要做配置服务器域名。
以上就是在开发过程中微信开发者工具常用到的功能，微信开发者工具也在不断的完善。.
/** * 登录相关 */ @RequestMapping("users") @RestController public class UserController{ @Autowired private UserService userService; @Autowired private TokenService tokenService; /** * 登录 */ @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0293a694bb771e43a27f471b4ca593a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2e78fae92c5c36db44587a4e0ea874/" rel="bookmark">
			Cadence入门之电路图绘制及仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步，打开orCad Capture CIS软件；
第二步，开始绘制电路图。首先，place ——&gt; part;
第三步，调用元件库；
了解各种库与元件的关系也很重要；
第四步，原理图的绘制。连接线和地都有对应的快捷键，选中元件，右键可旋转，或者按快捷键R。VSIN对应正弦交流信号，VDC对应直流信号。
第五步，画好元件后，电源网络进行设置,生成网络表。
第六步，电路直流偏置点仿真。创建网表，选择直流偏置点类型仿真，然后run。
第七步，enable bias points,观察节点电压,电流或功率。
第八步，瞬态时域仿真，创建网表，选择瞬态时域仿真类型，设置起始结束时间及步长，然后run。
第九步，add trace.
第十步，拷贝图片。
第十一步，直流扫描，创建网表，DC sweep类型，填写电压源，起始电压及步长，添加输出电压探针，然后run。可添加光标。
第十二步，交流扫描，创建网表，AC sweep类型，完成设置。还可看输出电压与输入电压的相位差。
Yeap, that's all! 你学会了嘛。虽然这个电路模型可能不太······
反正我学会咯，不会的话可以在评论区一起讨论。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138bef54119ad7c18ab3914a0717a206/" rel="bookmark">
			Java导入servlet包时，用“import javax.servlet.*；”报错“cannot resolve symbol servlet”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是idea2022+tomcat10.0.23
tomcat服务器，servlet.jar文件都已配置好还是报错
这个错误是由于tomcat10不再使用Javax引入servlet包
改为jakarta引入：
import jakarta.servlet.*; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06badeb7ecef01dc01e86d9d56c11963/" rel="bookmark">
			运行一个简单的servlet程序，部署在tomcat服务器上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的是idea2022的web框架，idea一定要是专业版不然无法创建框架。
一、创建框架
1、在idea中新建一个Java框架
2、创建成功后右键框架名，选择
即添加框架支持，选择web框架，OK.
框架创建完成，此时列表中会多出一个web文件夹
二、后端逻辑代码
这个程序是希望在网页中展示“HelloWorld”字符。
在src文件夹中新建Java文件，命名为“Hello”，在文件中添加如下代码
// 导入必需的 java 库 import java.io.*; import jakarta.servlet.*; import jakarta.servlet.http.*; // 扩展 HttpServlet 类 public class Hello extends HttpServlet { private String message; public void init() throws ServletException { // 执行必需的初始化 message = "Hello World"; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应内容类型 response.setContentType("text/html"); // 实际的逻辑是在这里 PrintWriter out = response.getWriter(); out.println("&lt;h1&gt;" + message + "&lt;/h1&gt;"); } public void destroy() { // 什么也不做 } } 此时Jakarta会报错，这是由于没有加入tomcat插件且未导入servlet的API文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06badeb7ecef01dc01e86d9d56c11963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c6c02bafbcdb1e0b0215d57a16cb2d/" rel="bookmark">
			刚体三维空间变换常见函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见函数 四元数转欧拉角
def quart_to_rpy(x, y, z, w, deg=False): roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y)) pitch = math.asin(2 * (w * y - x * z)) yaw = math.atan2(2 * (w * z + x * y), 1 - 2 * (z * z + y * y)) rpy = (roll, pitch, yaw) if deg: rpy = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c6c02bafbcdb1e0b0215d57a16cb2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23aa60982b0a9bccf2b8c2c1600d89c/" rel="bookmark">
			记录 ｜CentOS7 arm架构配置yum包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录 ｜CentOS7 arm架构配置yum包 前情提要：解决：替换yum配置文件step1：cd到目录 /etc/yum.repos.d ，创建/替换三个文件step2：清空/重建yum 缓存 前情提要： 根据博文 安装好了虚拟机，由于要研究一下华为IoT Edge平台，尝试将一台机器注册成边缘节点根据步骤提示需要使用linux系统，于是想到了用虚拟机来搞。
但前面装虚拟机的时候，yum镜面网址不可用。这会影响后续的一些按图索骥，于是尝试解决这个问题。
报错没记录！总之说的就是网址不可resolve什么的，unkown error…
解决：替换yum配置文件 参考博文
step1：cd到目录 /etc/yum.repos.d ，创建/替换三个文件 📃CentOS-Base.repo 📃CentOS-Sources.repo 📃rockchip.repo 替换内容在参考博文🔗里。
step2：清空/重建yum 缓存 yum clean all yum makecache 我的文件目录下原先没有rockchip.repo这个文档，最后出现报错如下图，用参考博文的方法无效，直接根据提示进行操作，最后就成功了。
蓝色框框的尝试了，没成功。
红色框框成功。
报错不止一次，因为rockchip.repo里面好几个地方因为类似问题报错。解决之后yum命令就可正常使用，目前还没有发现问题。（提示里说的好像就是这个东西不可用也没啥影响）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02fc6ec8e1672b8e965b851488545f9/" rel="bookmark">
			数据库的事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是事务？ 事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。
转账业务：必须同时成功或失败 二、事务的特性 ① 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；例如转账的这两个关键操作（将张三的余额减少200元，将李四的余额增加200元）要么全部完成，要么全部失败。
② 一致性： 确保从一个正确的状态转换到另外一个正确的状态，这就是一致性。例如转账业务中，将张三的余额减少200元，中间发生断电情况，李四的余额没有增加200元，这个就是不正确的状态，违反一致性。又比如表更新事务，一部分数据更新了，但一部分数据没有更新，这也是违反一致性的；
③ 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
④ 持久性：一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
三、事务间的相互影响 脏读，丢失更新，不可重复读，幻读 是因为事务之间的相互影响造成的
脏读：事务2读取到了事务1未提交的数据。例如：事务1修改数据库数据a，修改成a+1，但是事务1还未提交。此时事务2，查询此数据，查到的是a+1。此时事务1，做了回滚操作。数据库数据还是a，但是事务2查询到的是a+1。
不可重复读：事务1对数据a做查询，未结束时，事务2修改数据库数据a，修改（update）成a+1，事务1（未结束的事务）再次对数据a查询。查询到数据为a+1。两次查询结果不一致。
幻读：事务1根据某条件（name=小王）查询，查询到数据a。在事务1未结束时，事务2增添（insert）了数据b，其中b对应的name是小王（符合事务1的查询条件）。此时事务1再次根据此条件（name=小王）查询，查询到了数据a和数据b。两次查询结果不一致。
不可重复读和幻读的主要区分是update操作和insert操作 四、事务的隔离级别以及原理 读未提交（Read uncommitted）：可能会出现脏读，重复读，幻读；
读已提交（Read committed）：可能会出现重复读，幻读（mysql默认的隔离级别）；
重复读（Repeatable read）：可能会出现幻读。带来了更多的性能损失；
串读（Serializable ）：不会引发事务之间的相互影响，但是事务串行执行资源消耗巨大。
原理：
不同的隔离级别是通过加锁来实现的。
共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。
排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。
读未提交（Read uncommitted）：
事务对当前数据读取时不加锁事务对数据更新时添加行级共享锁，直到事务结束释放锁 读已提交（Read committed）：
事务对当前读取的数据加行级共享锁（不被其他事务修改），读完之后立即释放此共享锁；事务对数据更新瞬间会添加行级排它锁，直到事务结束释放锁 重复读（Repeatable read）：
事务在读取的数据的瞬间加行级共享锁（不被其他事务修改），直到事务结束释放锁；事务对数据更新瞬间会添加行级排它锁，直到事务结束释放锁 串读（Serializable ）：
事务在读取的数据的瞬间加表级排他锁，直到事务结束释放锁；串读的本质是串行化，只能做一种操作，其他别的操作会被阻止，所以也会很大程度影响效率。 五、事务的传播机制 REQUIRED
如果当前方法有事务则加入事务，没有则创建一个事务。
NOT_SUPPORTED
不支持事务，如果当前有事务则挂起事务运行。
REQUIREDS_NEW
新建一个事务并在这个事务中运行，如果当前存在事务就把当前事务挂起。新建的事务的提交与回滚一挂起事务没有联系，不会影响挂起事务的操作。
MANDATORY
强制当前方法使用事务运行，如果当前没有事务则抛出异常。
NEVER
当前方法不能存在事务，即非事务状态运行，如果存在事务则抛出异常。
SUPPORTS
支持当前事务，如果当前没事务也支持非事务状态运行。
NESTED
如果当前存在事务，则在嵌套事务内执行。嵌套事务的提交与回滚与父事务没有任务关系，反之，当父事务提交嵌套事务也一起提交，父事务回滚会也回滚嵌套事务的。
如果当前没有事务，则新建一个事务运行，这时候则与PROPAGATION_REQUIRED场景一致。
六、@Transactional 注解控制事务有哪些不生效的场景 1、数据库引擎不支持事务 这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02fc6ec8e1672b8e965b851488545f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9716167adea0de3b4ad4e058a180b5/" rel="bookmark">
			C&#43;&#43;常用性能分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		top
1.无论你开发的是什么样的应用程序，敲个 top 命令，就能够简单直观地看到 CPU、内存等几个最关键的性能指标。top 展示出来的各项指标的含义都非常丰富。
2.一个是按“M”，看内存占用（RES/MEM），另一个是按“P”，看 CPU 占用，这两个都会从大到小自动排序，方便你找出最耗费资源的进程。另外，你也可以按组合键“xb”，然后用“&lt;&gt;”手动选择排序的列，这样查看起来更自由。
pstack
pstack 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，你能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。
strace
1.strace 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息。
2.把 pstack 和 strace 结合起来，你大概就可以知道，进程在用户空间和内核空间都干了些什么。当进程的 CPU 利用率过高或者过低的时候，我们有很大概率能直接发现瓶颈所在。
perf
1.perf 可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。
2.常用的 perf 命令是“perf top -K -p xxx”，按 CPU 使用率排序，只看用户空间的调用，这样很容易就能找出最耗费 CPU 的函数。
3.总之，使用 perf 通常可以快速定位系统的瓶颈，帮助你找准性能优化的方向。
gperftools
1.Google Performance Tools。它是一个 C++ 工具集，里面包含了几个专门的性能分析工具（还有一个高效的内存分配器 tcmalloc），分析效果直观、友好、易理解，被广泛地应用于很多系统，经过了充分的实际验证。
2.gperftools 的性能分析工具有 CPUProfiler 和 HeapProfiler 两种，用来分析 CPU 和内存。不过，如果你听从我的建议，总是使用智能指针、标准容器，不使用 new/delete，就完全可以不用关心 HeapProfiler。
3.CPUProfiler 的原理和 perf 差不多，也是按频率采样，默认是每秒 100 次（100Hz），也就是每 10 毫秒采样一次程序的函数调用情况。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/210/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>