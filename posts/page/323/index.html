<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ede634445fc7944933dc7cdb16bf63/" rel="bookmark">
			Acrobat DC 更改背景颜色会有一条条白色横纹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法如下： 编辑-&gt;首选项-&gt;页面显示-&gt;取消 使用2D图形加速 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d382032e1cace359499dca5c50f4c0/" rel="bookmark">
			QSIP驱动W25Q256调试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QSIP驱动W25Q256调试记录 发现异常初始化配置指令时序分析与驱动函数W25Q256JV 数据手册纠错 驱动函数编程读Flash:0x6C纠错 扇区擦除:0x21写FLASH(最大256字节）:0x34 总结：补充说明（等待FLASH空闲） 记录调试QSPI方式驱动W25Q256，其中以正点原子和野火的STM32F767系列的例程作为参考。
发现异常 正点原子 &amp; 野火 例程中有水分,不适合参考指令。W25Q256JV 数据手册中部分指令的图表与时序图不符。 初始化配置 引脚初始化 /** * @brief QSPI引脚初始化 * @param None * @retval None */ void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi) { //忽略 } QSPI模式初始化 /** * @brief QSPI模式初始化 * @param None * @retval 失败回复QSPI_ERROR ，成功回复QSPI_OK */ uint8_t QSPI_Init(void) { QSPI_Handler.Instance = QUADSPI; //QSPI QSPI_Handler.Init.ClockPrescaler = 1; QSPI_Handler.Init.FifoThreshold = 4; QSPI_Handler.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE; QSPI_Handler.Init.FlashSize = 25 - 1; QSPI_Handler.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE; QSPI_Handler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d382032e1cace359499dca5c50f4c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0a66cc2b4a7020fd4d76e1f9584875/" rel="bookmark">
			axios请求添加token的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // post请求 axios.post('path', {}, { headers: { authorization: `Bearer ${token}`, }, }); // get请求 axios.get('path', { headers: { authorization: `Bearer ${token}`, }, }); // 统一方式 axios.defaults.headers['authorization'] = `Bearer ${token}`; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6627b07e2ea663aa3885977053a4bc6/" rel="bookmark">
			org.junit.platform.commons.JUnitException: TestEngine with ID ‘junit-jupiter‘ failed to discover te
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Test问题 一般存在的问题，都是因为其他模块里面有些小细节错误了，
像我执行Install之后就发现是LongBlob不生效的原因，然后修改成byte即可。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zNCtORpk-1620643259754)(谷粒商城.assets/image-20210510154322217.png)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1718099c1dc7a5b8bfd3e86654ba44d7/" rel="bookmark">
			@TableId(value=“user_id”,type = IdType.AUTO)注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “value”：设置数据库字段值 “type”：设置主键类型、如果数据库主键设置了自增建议使用“AUTO” type有六种类型，最下面三个只有插入主键为空时，才会自动填充 类型解释AUTO数据库自增IDNONE数据库未设置主键类型（将会跟随全局）INPUT用户输入ID（该类型可以通过自己注册自动填充插件进行填充）ID_WORKER全局唯一ID (idWorker)UUID全局唯一ID（UUID）ID_WORKER_STR字符串全局唯一ID（idWorker 的字符串表示） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0c3c32d235108dfeca497c8c93215a/" rel="bookmark">
			linux怎么关闭自动注销,linux 终端开启自动注销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用root用户登录至终端后 不及时注销，那么会话会一直存在，这样有很大的安全隐患。为了将风险降至最低，接下来将介绍如何配置自动锁定或注销。
1. 安装screen
yum install -y screen
2. 使用root用户在 /etc/profile 添加以下内容，确保本文件的进程不会被中断。
trap "" 1 2 3 15
3. 接下来在 /etc/profile 中添加以下内容，为每个登录用户创建虚拟终端。
SCREENEXEC="screen"
if [ -w $(tty) ]; then
trap "exec $SCREENEXEC" 1 2 3 15
echo -n ‘Starting session in 10 seconds‘
sleep 10
exec $SCREENEXEC
fi
现在每个用户登录后都会有个提示信息"Starting session in 10 seconds", 会在10s后创建终端,这个提示信息和创建终端的时间你可以自定义，只需要更改提示信息及 sleep 后面的数字即可。
4. 配置screen
自动注销
在/etc/screenrc 中添加
idle 120 quit
autodetach off
会话闲置120s 后会自动退出, 更改闲置时间 只需更改 idle 后面的数字即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0c3c32d235108dfeca497c8c93215a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f001035f2416689c369a4ceed2bc0b6c/" rel="bookmark">
			linux嵌入式系统开发心得,嵌入式学习牛人心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		都说嵌入式学习难，难于上青天，其实不然，无论学习什么，只要找对了一个好的学习方法，往往会事半功倍。下面我摘自于一个嵌入式前辈，说说他的学习经验。本文引用地址：http://www.eepw.com.cn/article/221685.htm
第一部分 对嵌入式系统的一些大致了解
嵌入式被应用于哪些行业?
1) 小家电2) 汽车3) 电梯4) 电视5) 录像机或者VCD、DVD6) mp3、mp47) 工业控制8) 医疗设备9) 卫星10) 电话11) PDA12) 飞行系统等等。
嵌入式系统的一些简单了解：
1、 嵌入式系统与普通的PC或者notebook不同，嵌入式系统的外形尺寸、功耗、外部适配器等各种特征必须满足应用的要求和限制;
2、 嵌入式系统简单的说就是面向特定应用设计的专用计算机系统;
3， 使用低功耗的X86级别的CPU，采用模块化的设计，配置了最基本的计算机周边配备而制成。这种计算机通常采用Windows操作系统;
4、 嵌入式系统的软件包括操作系统烧录在一块电路板上;
5、 嵌入式系统的CPU可以是：4位、8位、16位、32位;
6, 嵌入式系统更多的表现为SoC的特点，也就是把整个系统都集成在一个芯片上，例如，ATMEL的arm7的芯片91sam7x128/256等;用户可以获得廉价而功能强大的嵌入式系统;
嵌入式系统的体系结构有哪些?
CPU RAM ROM或者flash ram AD DA I/O Usart USB CAN 以太网
第二部分：正确的学习之路
最正确的学习道路 - 从8位mcu到canbus到ARM7
第一步：熟悉8位mcu
嵌入式技术学习的路线：8位mcu(51或者avr...)+can2.0B+arm7+arm9。
作为低端的嵌入式系统，选择8位mcu作为入门是比较适中的，而8位mcu中，相比pic、avr、freescale等等8位单片机来说，又以选择51核的单片机作为学习8位mcu的首选来更加合适。当然这个观点是仁者见仁智者见智;如果需要理由的话，那么也许以下这些理由可以作为参考：
1. 51上积累了大量的优秀的代码和其它资源;网络上这样的资源太多了，几乎就是不花钱的;
2. 生产51内核的单片机的厂家很多，比如：ATMEL、华邦、LG、飞利浦、STC(宏晶科技)、TI、…
3. 51单片机在细分低端市场，面向不同的行业应用，厂家推出了不同的产品，如LPC900系列，STC的12CXXXX系列;在功能、价格、功耗，体积，封装、抗干扰等方面来满足行业用户的需求;例如，现在的51单片机越来越多的集成了A/D、D/A、SPI、I2C、PWM、内部时钟、看门狗、eeprom、ISP/IAP等等，已经跟传统的ATMEL的89C51/52有了很大的差别!功能越来越强大的同时成本越来越低，而且不担心某个厂家缺货..
第二步：熟悉can2.0A/B，在精通51的基础上，熟悉can2.0A/B
CAN具有的特点
1. 采用无损坏的仲裁技术;
2. 8字节的短帧传送，故传输时间短、抗干扰性强;
3. 高速，最高速度可达1Mbit/s;
4. 具有多种错误校验方式如CRC及其他校验措施，数据出错率极低;而且在严重错误的情况下，节点会自动离线，避免影响总线上其它节点;Rs485经常是一个节点影响了总线上所有的节点;
5. 可以做到全区广播、分区广播和点对点通讯;
6. 多主方式，多主之间又可以分成是主节点和次节点;各节点均可在任意时刻主动向网络上的其他节点发送信息，不分主从，通信灵活;发送的时候总线自动仲裁主次;主节点占有优先权;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f001035f2416689c369a4ceed2bc0b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef72b9eae3f7cdb15dbf0d49cd3768df/" rel="bookmark">
			交换机命令与linux,LINUX教学:路由器和交换机的基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《LINUX教学:路由器和交换机的基本命令》要点：
本文介绍了LINUX教学:路由器和交换机的基本命令，希望对您有用。如果有疑问，可以联系我们。
路由器和交换机的基本命令
en 进入特权模式
conf t 全局模式
Int 接口号 进入接口模式
exit 返回上一个模式
End 返回特权模式
hostname 主机名 配置主机名
Sh ver 查看版本信息
Showmac-address-table 查看Mac地址表
Duplex 双工模式 配置双工模式(全双工full, 半双half,自动协商auto)
Speed 速率值 配置接口速率(auto自动匹配)
Ifconfig 查看IP地址的配置信息
Ping IP地址 测试连通性
Exec-timeout 0 0 永远在线,不超时锁定
No ip domain-lookup 禁用DNS查找
Logg syn 信息同步
IP add IP地址 子网掩码 配置IP地址(在全局模式下)
Ip default-gatewaty 网关地址 配置交换机默认网关
Password 密码 配置console口密码
No sh 打开接口
Show arp 查看ARP缓存表
Clear arp-cache 清除ARP缓存表
Arp ip地址 Mac地址 arpa ARP绑定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef72b9eae3f7cdb15dbf0d49cd3768df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f76898517d7dcab8e1859fb03409691/" rel="bookmark">
			queue的清空方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 queue是没有 clear函数的。那么queue 该如何清空的呢?
答： 只需再创建一个就可以了。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; int main(void) { queue&lt;int&gt; q; q=queue&lt;int&gt;(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced982fa9167cc1ddaaa1fc471fe688c/" rel="bookmark">
			vector的三种遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一 ： 数组下标
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main(void) { vector&lt;int&gt; ve; for(int i=0;i&lt;5;i++) ve.push_back(i); for(int i=0;i&lt;5;i++) cout&lt;&lt;ve[i]&lt;&lt;" "; } 方式二 ： 迭代器
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main(void) { vector&lt;int&gt; ve; for(int i=0;i&lt;5;i++) ve.push_back(i); for(vector&lt;int&gt;::iterator it=ve.begin();it!=ve.end();it++) cout&lt;&lt;*it&lt;&lt;" "; } 方式三 : auto
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main(void) { vector&lt;int&gt; ve; for(int i=0;i&lt;5;i++) ve.push_back(i); for(auto it=ve.begin();it!=ve.end();it++) cout&lt;&lt;*it&lt;&lt;" "; } #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main(void) { vector&lt;int&gt; ve; for(int i=0;i&lt;5;i++) ve.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced982fa9167cc1ddaaa1fc471fe688c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18064fd7f003230a00a40d01322d6340/" rel="bookmark">
			关于neo4j网页版打开是空白页问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于neo4j网页版打开是空白页问题的解决
127.0.0.1:7474能正常打开，Localhost：7474打开为空白页
修改neo4j环境变量版本为4.1.1，安装后neo4j start能正常运行
打开C:\Windows\System32\drivers\etc的hosts文件，添加下边两行，仍未解决
最终考虑到可能是我在win server系统安装了两个版本的neo4j的问题，两个版本可能有冲突，于是将两个版本的neo4j都卸载了，安装了3.5.8版本的，可以正常启动了
卸载：cmd定位到neo4j安装的bin目录里，执行neo4j uninstall-service
安装：cmd定位到neo4j安装的bin目录里，执行neo4j.bat console
再执行neo4j install-service
成功
打开网页版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e21513743e35d88265a3c356b4c283/" rel="bookmark">
			NEO-M8T&#43;千寻基站&#43;RTKNAVI进行RTK定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用NEO-M8T和千寻基站，利用RTKLIB进行RTK定位 最近在研究RTK的实时定位，打算使用RTKLIB的GUI软件rtknavi进行实时定位。拟采用u-blox公司的单频接收机NEO-M8T和千寻网络基站来实现RTK定位
1.NEO-M8T的配置 一般初试情况下原厂配置就是移动站模式，在这里详细介绍了如果配置为移动站接收机。
1.使用u-center软件时请先检查驱动是否安装完成（如CH340/PL2303),后连接数据线等。
2.打开u-center软件,在左上角选择正确的串口及波特率，一般NE0-M8T默认波特率为9600.
3.在View处点击Message View，依次进行如下设置并点击sent,在PRT和RATE出可以分别对接收机的波特率和发送信息的频率进行设置。频率设置为57600，输出设置为UBX+NMEA格式，设置结束点击sent。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210508160814791.png?x-oss-process=image/w
4.之后再对message进行配置，点击send，将RXM信息都输出出来，主要是RXM-RAWX（观测值）,RXM-SFRBX（星历），(SIVI和MEASX也可输出）
5.配置完上述步骤之后点击CFG点击sent进行配置的保存以便在下次重启时生效
配置完成后可以在界面看到RXM数据已经出现：
2.rtknavi配置 rtknavi是RTKLIB中用于实时定位的GUI，他可以实时进行单点定位和RTK定位。下图是他的基本界面和功能：
1.勾选Rover和Base Station。
点击 I I I，打开input stream的配置界面进行配置。
其中，Rover配置的Type格式，根据能输出原始观测值的设备来定，这个设备一定是要能吐出原始观测值的哟。这个设备采取哪种格式，具体见生产厂商的说明。这里我使用了串口，所以Type选择Serial，Format选择u-bolx。
Base Station 的Type选择NTRIP Client，Format选择RTCM3。
Transmit NMEA GPGGA to Base Station 选择Single Solution。我们需要将单点定位的结果发送给基站，千寻基站才会返回RTCM值回来。
2.Rover配置:
主要对串口进行配置，选择你自己计算机上的接收机对应的COM口和接收机的比特率即可，这里我的接收机被分配的Port口为COM8,比特率之前设置为57600.
3. Base Station参数设置
相关参数：
NTRIP Caster Host：rtk.ntrip.qxwz.com
Port：8001
Mountpoint：RTCM32_GGB
这里的User-ID和Password可通过注册并认证官网用户后，进入控制台找到自己购买的服务即可找到差分账号，这里我购买了千寻的FindMpro。
4.RTK配置
rtknavi主界面中，点击Options。
Setting1选项卡里，把定位模式设置为Kinematic。
底部根据收信需求，选择合适的GNSS信号源。这里我们选择GPS和Beidou。
这里需要注意一点：Options选项卡的Base Station，请务必选择“RTCM Antenna Position”
5.定位
最后在rtknavi的主界面点击start即可开始进行RTK定位。
由于在窗边，信号不是很好，定位效果也不是很好，参数什么的都没有怎么修改，如果有什么建议，欢迎指正。
BTW 如果对得到的基站或者流动站数据不确定对不对的话，可以使用RTKLIB的文件接收软件strsvr和格式转换工具rtkconv来进行调试
比如我们不知道输出带原始数据的ubx文件的数据对不对，可以通过使用RTKLIB中的strsvr.exe来读取数据，使用rtkconv.exe进行格式转换来查看obs文件和nav文件。
其他可能出现的一些问题可以在参考资料寻找答案，各位大大都已经写的很详细了。
参考资料 https://blog.csdn.net/qq_34689354/article/details/115375744
https://bbs.qxwz.com/read.php?tid-313.html
https://blog.csdn.net/weixin_42586806/article/details/115187844
https://blog.csdn.net/m0_48012049/article/details/107882430
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd4aba1d2857d3e2e988dd52067953c/" rel="bookmark">
			Burg法求解AR(p)模型参数（一）自回归模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章 自回归模型第一节 概念一、自回归模型1.1 定义1.2 自回归模型的平稳解 二、推移算子2.1 概念2.2 性质 三、A(z)3.1 概念3.2 性质 四、AR（p）模型4.1 定义4.2 AR（p）模型的平稳解4.3 AR（p）模型的通解 参考 第一章 自回归模型 第一节 概念 一、自回归模型 1.1 定义 在许多应用中，时序数据Xt通常可由历史数据的加权和与随机扰动的叠加来表示，如公式(1)中所示
其中a1为常系数， ε t为随机扰动（噪声）项。自回归（Autoregression）模型即是这样一种采用式（1）描述时序数据的时间序列模型。
1.2 自回归模型的平稳解 所谓平稳解，即是满足式（1）的平稳时间序列。需要指出的是，式（1）不一定存在平稳解。在实际应用中，一般假设 ε t为 高斯白噪声WN(0,σ2 )。在这种情况下，平稳解总是存在的。
二、推移算子 2.1 概念 对任何时间序列 {Xt}和无穷级数
只要级数
在某种意义下收敛（例如 a.s.收敛，依概率收敛，均方收敛），就定义
并称B是时间t的向后推移算子，简称推移算子,且BjXt = Xt-j 。
2.2 性质 三、A(z) 3.1 概念 给定 p 个实数a 1,a 2,a 3……a p ，(a p≠0)，称
为 p 阶齐次常系数线性差分方程，简称为齐次差分方程。满足式（4）的时间序列称为齐次差分方程（4）的解。
注：在数学上，递推关系（recurrence relation），也就是差分方程（difference equation），是一种递推地定义一个序列的方程式：序列的每一项目是定义为前一项的函数。
可以看出，式（4）的解可以由它的p 个初值 X 0,X 1,X 2……X p-1 逐步递推得到，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd4aba1d2857d3e2e988dd52067953c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaff5727da623cd2bc32e3f7acf1bbab/" rel="bookmark">
			1) DAC 数模转换器  2) TIA 跨阻放大器  3) ADC 模数转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，光学处理器中的模拟器件 https://cloud.tencent.com/developer/article/1678554
其中vector DAC将数字信号转变为输入矢量，optical core中MZI调制器的电压由weight DAC进行控制，而最终的信号由PD探测，经过TIA放大，再通过ADC转变为数字信号。DAC的位数决定了相应的矩阵元或者矢量的精度。虽然矩阵计算通过optical core实现，但是它还需要外部模拟电路的帮助。整个系统中涉及到的模拟器件包括:
1) DAC 数模转换器
2) TIA 跨阻放大器
3) ADC 模数转换器
以下一一介绍这些器件。
A. DAC 数模转换器
DAC, 顾名思义，就是将数字信号转变为模拟信号，如下图所示，
（图片来自https://medium.com/lightmatter/analog-interface-of-optical-processors-46c40f63b0e7）
N位的数字信号，对应2^N-1个大小不同的模拟电平。DAC的主要性能指标包括分辨率、最大工作频率、建立时间、功耗等。Lightmatter采用的是中等精度、高速的DAC。
D/A转换器基本上由4个部分组成，即权电阻网络、运算放大器、基准电源和模拟开关。模数转换器ADC中一般都要用到数模转换器DAC，模数转换器即A/D转换器，简称ADC
B. TIA跨阻放大器
关于TIA, 小豆芽之间有篇笔记介绍过(跨阻放大器TIA简介)。其主要作用是将探测器中产生的光电流转变为电压信号，如下图所示，
C. ADC模数转换器
ADC, 将模拟信号转换为数字信号，如下图所示，
模数转换一般要经过信号采样、保持和量化、编码这几个步骤。信号采样频率每提高一倍，功耗会提高四倍。
ADC可分为直接转换型和间接转换型。直接转换型，是指直接将模拟信号转换成数字信号，而间接转换型，是先将模拟信号转换为中间信号，再转化为数字信号。
ADC和DAC的技术指标是相似的，主要有：
1）分辨率，即最小的模拟信号变化量，
2）转换速率，即完成一次转换所需时间的倒数，
3）线性度，
4）量化误差等。
针对光学处理器这一特定应用，需要选择合适的DAC/TIA/ADC。Lightmatter的做法是选取低功耗、高速、中等精度的模拟电子器件。在传统的光模块中，同样也需要这些模拟器件，只不过应用场景不同，器件的选取侧重点会有些差别。
2，AD转换器及其外围电路设计 https://wenku.baidu.com/view/853dda2a02768e9951e7388c.html
3，(完整版)基于单片机的AD转换电路与程序毕业设计论文 https://wenku.baidu.com/view/9e2ae355e55c3b3567ec102de2bd960590c6d935.html?rec_flag=default&amp;fr=pc_newview_relate-1001_1-1-wk_rec_doc-1001_1-2-9e2ae355e55c3b3567ec102de2bd960590c6d935&amp;sxts=1620459229713
AD转换器外围电路设计
https://wenku.baidu.com/view/d1d4fd547f1922791788e858.html
4，问题：AD转换芯片内置电压源，同时有外接电压基准源接口，什么情况下用内置的，什么时候用外接的？如果用内置电压基准源，误差有多大呢？ 通常AD转换器内置基准源精度不是特别高，在需要进行高精度测量转换时就要使用外置基准电压源。
答：回答这个问题前，先要理解电压基准的三个概念：
1、初始精度：如果初始精度1%，那么5V的电压基准，实际输出可能是4.95-5.05。好的电压基准的初始精度一般是0.2%。
2、输出噪音：这一点对高精度AD（比如16位，22位，24位，32位）尤其重要，好的电压基
准一般的输出噪音都很低。
3、温度漂移：就是输出随温度的变化，这一点对工作在温差变化大的AD尤其重要。好的电压
基准温漂就是几个ppm每摄氏度。
因此，很难说用外部还是内部电压基准好，要综合考虑。比如ADS1218的内部电压基准就很
好，比一般的电压基准（例如MC1413）好的多，但是弱于LT1019。
可以这样说吧，低精度（低于14位）的使用内部参考和外部参考差别不大，高精度AD要是想取得极高分辨率，芯片公司一般建议使用外部高档的电压基准。
请问一般单片机芯片的AD脚的AREF引脚需不需要接一个5V电源？还是说它里面已经本身有基准电压了？ 一般单片机芯片的AD脚的AREF引脚不需要接一个5V电源，因为如果在AREF引脚上接一个5V电源作为基准电压，如果5V电源有波动就会造成很大的麻烦。
确实，里面已经本身有基准电压了。带AD的单片机内部肯定会给提供一个基准电压，或者给一个基准电压输入引脚AREF去连接外部基准源。如果把AREF直接连VCC，那是很不靠谱的
AVR单片机，是自带基准源的，在使用ADC的时候你要选择ADC使用的参考电压类型：内部参考电压、AVCC或者加在AREF引脚上的外部参考电压。你看ADCMUX寄存器的RESF1和RESF0位的组合
有内部基准的话一般用内部基准，如果用外部基准的话有时候电容的滤波效果不好，电压不稳，很容易照成转换后的值不准确。
不接，默认的基准点压就是vcc。
如何得到基准电压源？ 提供一个参考电压的，比如ADC和DAC都需要一个参考作为基准，这个基准电压对纹波，精度，漂移都很高，所以通常可以用基准电压芯片来提供。
在额定工作电流范围之内，基准电压源器件（芯片）的精度（电压值的偏差、漂移、电流调整率等指标参数）要大大优于普通的齐纳稳压二极管或三端稳压器，所以用于需要高精度基准电压作为参考电压的场合，一般是用于A/D、D/A和高精度电压源，还有些电压监控电路中也用基准电压源。
IC引脚标“基准电压 ”，有3种情况： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaff5727da623cd2bc32e3f7acf1bbab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8aee986b5be448d72eedfbcf0cb2971/" rel="bookmark">
			单边带（SSB）调制技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单边带（SSB）调制技术1、双边带简述2、单边带调制 单边带（SSB）调制技术 1、双边带简述 首先简述一下双边带调制。所谓双边带（DSB，double-sideband）调制，本质上就是调幅。时域上将基带信号x(t)和高频载波信号c(t)相乘，根据卷积定理，等价于将基带信号频谱X(jw)和高频载波信号频谱C(jw)相卷。通常选用的载波信号是余弦信号，从而在正负频域上得到能量为原信号一般的波形。解调时，需要进行相干解调，即时域上和载波相乘，再通过一个低通滤波器，还原出原来的基带信号。
时域：
频域：
2、单边带调制 所谓单边带调制，其实就是将滤除掉频谱当中的重复部分（上下边带），其中保留上边带叫USB调制，保留下边带叫LSB调制。单边带调制过程相比于双边带调制略显复杂，但是单边带信号在发射过程中可以节省发射功率（同样的条件下，相比于双边带技术少发一半重复的信号），占用带宽也减少了一半。所以，在短波通信中，通常会用到单边带调制。在解调时，和双边带信号一样，需要使用相干解调技术。
在实现中，有两种实现单边带调制的方法，即滤波法和相移法，下面将详细阐述。
滤波法 滤波法即采用低通滤波器或者高通滤波器实现滤除上边带或者下边带，但是由于硬件实现当中，很难做出具有陡峭截止特性的滤波器，所以通常的做法是进行两次双边带调制及边带滤波，这样可以增大过渡带的归一化值，即滤波器过渡带不那么陡峭也能得到很好的滤波效果。
相移法 相移法本质上是利用希尔伯特滤波器的传递函数特性，滤出一个边带。相移法的原理图解图下：
相应的频域图解如下：
这里利用图形直观化理解相移法实现单边带调制，从而省略了公式的推导。如果需要公式推导的话，去百度文库看ppt吧。
此方法的优势是不需要构造过渡带陡峭的滤波器，但是相应的缺点的是上述网络中的希尔伯特滤波器难以实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdfe4ba38d4ca7012e425a5209077fc/" rel="bookmark">
			sql 修改表的字段属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MariaDB数据库，修改数据表的字段属性的各种方法。
1.修改字段属性为NOT NULL
alter table 表名 modify 字段 字段类型 not null; 2.设置字段的默认值
alter table 表名 add default (0) for 字段 with values; 3.修改字段的属性为NOT NULL并设置默认值
alter table alarms modify column write_time datetime not null default current_timestamp(); ERROR 1265 (01000): Data truncated for column 'write_time' at row 1 以上操作报错，原因是因为表中有数据write_time的值为NULL， 所以先update设置write_time一个值。再执行修改语句；
update alarms set create_time='0000-00-00 00:00:00' where id=xx; 4.更新时间在更新时自动更新为当前时间。
alter table alarms modify column write_time datetime not null default current_timestamp() on update current_timestamp(); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdfe4ba38d4ca7012e425a5209077fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1f4fb4505c30d66ae6a26c9a5ac238/" rel="bookmark">
			5种JavaScript中常用的排序方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5种JavaScript中常用的排序方法 01、冒泡排序 通过相邻数据元素的交换，逐步将待排序序列变为有序序列，如果前面的数据大于后面的数据，就将两值进行交换，将数据进行从小到大的排序，这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就到了数组第N-1个位置，排序进行完成。
var arr1 = [1, 5, 7, 6, 0, 9, 4]; function maopao(array){ if(Array.isArray(array)){ if (array.length == 1) { return array; } var temp = null; for (var i = 0; i &lt; array.length; i++) { for (var j = 0; j &lt; array.length - i - 1; j++) { if (array[j] &gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } return array; } } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b1f4fb4505c30d66ae6a26c9a5ac238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b47f1ce0a624f23b758f911a5e41e1/" rel="bookmark">
			输出层的激活函数——softmax函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概括 机器学习的问题大致可以分为分类问题和回归问题。分类问题是数据属于哪一个类别的问题。比如，区分图像中的人是男性还是女性的问题就是分类问题。而回归问题是根据某个输入预测一个（连续的）数值的问题。比如，根据一个人的图像预测这个人的体重问题是回归问题（类似“57.4kg”这样的预测）。
输出层所用的激活函数，根据求解问题的性质决定。一般，回归问题可以用恒等函数，二元分类问题可以用sigmoid函数，多元分类问题可以用softmax函数。
恒等函数：输出=输入 softmax函数：输出为一个函数 其中exp为指数函数，表示假设输出层共有n个神经元，计算第k个神经元的输出yk。ak代表第k个输出神经元的输入，ai代表第i个输出神经元的输入，公式分子表示ak的指数函数，分母表示所有输出神经元的输入指数函数的和
代码实现softmax def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax函数的注意事项 上述softmax函数的实现存在溢出问题。在计算指数时，比如e的5000次方，数据将会非常大，计算机处理“数”时，数值必须在4字节或8字节的有限数据宽度内，超出的数据则会显示为无穷（inf），所以要对softmax函数进行改进，防止数据的溢出。
如图中，将分子分母同时乘以C，然后将C提进指数函数中，图中用的logC理解成数学中的lnC，然后用C’代替logC，通过控制C’来控制exp函数中的指数，来实现softmax函数不因为数据过大而出错。C’可以使用任何值，为防止溢出，一般使用输入信号中的最大值。
例子：
def softmax(a): c = np.max(a) exp_a = np.exp(a-c) # 溢出对策 sum_exp_a = np.sum(exp_a) y = exp_a/sum_exp_a return y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148789b1f2e7662d0b1c3613339e6ab7/" rel="bookmark">
			ubuntu20.04&#43;3090&#43;tf1/tf2&#43;pytorch&#43;keras全套安装流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要参考这篇文章，其中修改了自己遇到的问题
py37或py38 cuda11.1 tf-nightly-gpu==2.6.0.dev20210507 pytorch1.8 keras2.3 安装gcc sudo apt install build-essential gcc -v #查看gcc版本 官网下载对应版本显卡驱动及cuda：（以下版本对应11.1cuda，此处安装cuda是为了tf的某个缺失的文件） wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run sudo sh cuda_11.1.0_455.23.05_linux.run 安装Anaconda并换源 wget https://repo.anaconda.com/archive/Anaconda3-5.2.0-Linux-x86_64.sh bash Anaconda3-5.2.0-Linux-x86_64.sh anaconda已经安装成功了，可以直接使用。 vim ~/.bashrc export PATH=/home/danielli/anaconda3/bin:$PATH（在文件末尾处添加该语句） source ~/.bashrc conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 之后vim ~/.condarc，把defaults删掉 创建虚拟环境，一般用py37或py38（以下都在虚拟环境中操作） # 下面的环境安装TF1+pytorch+keras conda create -n py38 python==3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148789b1f2e7662d0b1c3613339e6ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc532aa6efe834581e1a68a56020a37/" rel="bookmark">
			git 回退的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地工作目录内容保留
1、git reset --mixed 版本号 ：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
本地工作目录内容以及暂存区内容保留
2、git reset --soft 版本号：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
本地工作目录内容以及暂存区内容全部回退至某一个版本
3、git reset --hard 版本号：彻底回退到某个版本，本地的源码也会变为某个版本的内容
详细理解
https://www.jianshu.com/p/c2ec5f06cf1a
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/322/">«</a>
	<span class="pagination__item pagination__item--current">323/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/324/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>