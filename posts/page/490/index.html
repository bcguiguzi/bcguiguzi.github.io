<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb13a8866543705e29fead963bcf7de/" rel="bookmark">
			使用cJSON解析JSON字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON学习-使用cJSON解析
使用cJSON解析JSON字符串 一、为何选择cJSON 我们在使用JSON格式时，如果只是处理简单的协议，可以依据JSON格式，通过对字符串的操作来进行解析与创建。然而随着协议逐渐复杂起来，经常会遇到一些未考虑周全的地方，需要进一步的完善解析方法，此时，使用比较完善的JSON解析库的需求就提出来了。
基于方便引用的考虑，我们希望这个JSON解析库是用C语言实现的。同时，为了避免太过复杂的C源码包含关系，希望最好是一个C文件来实现。通过在网络上的查找，发现cJSON是比较符合要求的。cJSON只有一个C文件，一个头文件，包含到项目源码中非常方便，而且其实现效率也是非常高的。
二、cJSON的核心结构体 cJSON的核心结构体就是一个cJSON，理解了这个结构体，基本上对cJSON的使用就有了个基本概念了。该结构体具体定义如下：
typedef struct cJSON {
struct cJSON*next,*prev; /* 遍历数组或对象链的前向或后向链表指针*/
struct cJSON *child; /*数组或对象的孩子节点*/
int type; /* key的类型*/
char *valuestring; /*字符串值*/
int valueint; /* 整数值*/
double valuedouble; /* 浮点数值*/
char *string; /* key的名字*/
} cJSON;
说明：
1、cJSON是使用链表来存储数据的，其访问方式很像一颗树。每一个节点可以有兄弟节点，通过next/prev指针来查找，它类似双向链表；每个节点也可以有孩子节点，通过child指针来访问，进入下一层。只有节点是对象或数组时才可以有孩子节点。
2、type是键（key）的类型，一共有7种取值，分别是：False，Ture，NULL，Number，String，Array，Object。
若是Number类型，则valueint或valuedouble中存储着值。若期望的是int，则访问valueint，若期望的是double，则访问valuedouble，可以得到值。
若是String类型的，则valuestring中存储着值，可以访问valuestring得到值。
3、string中存放的是这个节点的名字，可理解为key的名称。
三、解析JSON格式； 还是在Linux下，使用C语言编程，先实现读文件的功能，然后开始JSON字符串的解析。我们还是一步步来，先从简单的开始，万丈高楼起于平地嘛。 1，下载源码； 可以从如下网站来下载：https://sourceforge.net/projects/cjson/ 。
2，包含cJSON的源码； 下载下来，解压后，从里面找到两个文件（cJSON.c、cJSON.h），复制到我们的工程里面。只需在函数中包含头文件（#include “cJSON.h”），然后和cJSON.c一起编译即可使用。 3，解析一个键值对； 首先是一个简单的键值对字符串，要解析的目标如下：
{"firstName":"Brett"}
要进行解析，也就是要分别获取到键与值的内容。我们很容易就能看出键为firstName，值为Brett，可是，使用cJSON怎么解析呢？ 对于这个简单的例子，只需要调用cJSON的三个接口函数就可以实现解析了，这三个函数的原型如下：
cJSON*cJSON_Parse(const char *value); cJSON*cJSON_GetObjectItem(cJSON *object,const char *string);
voidcJSON_Delete(cJSON *c); 下面按解析过程来描述一次：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb13a8866543705e29fead963bcf7de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cadcf30a9604c5a8eab1465666119f1/" rel="bookmark">
			安卓开发中@SuppressLint( NewApi )问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到该问题时，可以右键点击代码所在工程，选择android tools，然后选中clear lint markers，问题就会消失。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bcb50d360e20de02932c67566957fb/" rel="bookmark">
			法线变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 顶点是（x,y,z,1）,法线的表示是(x,y,0)，顶点是个点，法线是个方向。如果用用MV矩阵来直接变换法线，会造成法线的方向出错误。 法线变换：应该用变换矩阵的逆转置矩阵
假设Model space中的某条切线向量是T，法线向量是N。那么由他们是垂直的可得到：TTN=0假设他们变换到Eye space中后分别是T’和N’。那么他们应该仍然是相互垂直的：T’TN’=0假设切线向量和法线的变换矩阵为M、G。则有：(MT)T(GN)=0进一步推出：TTMTGN=0由于TTN=0，因此我们猜想MTG=0.因此：《注：我觉得这里该写 MTG=E. E:为单位矩阵》G=(M-1)T即：应用于法线向量的变换矩阵是顶点变换矩阵的逆转置矩阵。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5526fbb1ccca38a7ce89088284b1b4c8/" rel="bookmark">
			由“电脑显示器显示输入超出频率范围”问题开始的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写作背景 上周，和晓冰一块去买了显示器，作为扩展屏使用，期间遇到了一个问题，就是她的笔记本电脑的HDML接口（High Definision Media Interface的缩写，意思是高清媒体接口，高清视频设备的常用接口）和店家给我们的电脑显示器的连接线端口不匹配，于是在网上买了个转接线。
输入超出频率范围 显示器上有个标签，写着“最佳分辨率1440*900“，但是用转接线作为桥梁连上以后，分辨率最高是1366*768，如果调整为1440*900，扩展屏就黑了，显示一行字——“输入超出频率范围”。度娘说，可能是笔记本本机装的显卡驱动不合适，于是我用360驱动大师检测了一下，显卡驱动和笔记电脑是匹配的。
既然看到了“显卡”二字，我的感觉就是从和显卡有关的东西入手。期间发生了阴差阳错的事，右击桌面，想打开屏幕分辨率的时候，注意到了下图标记出来的部分——配置可交换显示卡，之后我就点了。
没想到，结果出人意料，当我在打开屏幕分辨率的时候，界面如下：也许是因为点击了配置可交换显示卡（AMD显卡交换）的原因吧，就像是扫描出外接设备一样。
配置可交换显示卡 度娘对配置可交换显卡是这样说的：集成显卡和独立显卡之间切换，当你运行3D游戏之类等需要很好的图像渲染效果的时候切换到独立显卡，这样图像渲染会更生动逼真。当你只是浏览网页或处理日常文字信息或者聊天的时候切换到集成显卡，这样能降低机器功耗，降低热量，使机器的温度能适当降低。
知识扩展 DVI接口 为了满足数字化时代高质量图形影像的要求，DDWG(Digital Display Working Group)数字显示工作组以美国Silicon Image公司的专利技术为蓝本，推出了一种名为DVI(Digital Visual Interface)的接口，旨在统一新时代数字显示接口标准。经过3年多的推广，DVI（（Digital Video Interface），即数字视频接口）技术在计算机显示输出领域得到了迅速运用，但是伴随着数字高清影音技术的发展，DVI接口也开始逐渐暴露出种种问题，甚至在一定程度上成为数字影像技术进步的瓶颈。
存在的主要问题 * DVI接口考虑的对象是PC，对于平板电视的兼容能力一般。
* DVI接口对影像版权保护缺乏支持。
* DVI接口只支持8bit的RGB信号传输，不能让广色域的显示终端发挥最佳性能。
* DVI接口出于兼容性考虑，预留了不少引脚以支持模拟设备，造成接口体积较大，效率很低。
* DVI接口只能传输图像信号，对于数字音频信号的支持完全没有考虑。
由于以上种种缺陷，DVI接口已经不能更好的满足整个行业的发展需要。因此，无论是IT厂商，平板电视制造商，还是好莱坞的众多出版商，都迫切需要一种更好的能满足未来高清视频行业发展的接口技术，也正是基于这些原因，才促使了HDMI标准的诞生。
HDMI接口 HDMI（英文:High Definition Multimedia Interface，高清晰度多媒体接口）是一种数字化视频/音频接口技术，是适合影像传输的专用型数字化接口，其可同时传送音频和影像信号，最高数据传输速度为2.25GB/s。
具有HDMI的设备具有"即插即用"的特点，信号源和显示设备之间会自动进行"协商"，自动选择最合适的视频/音频格式。
既然提到了HDMI和DVI，就不得不说VGA转换器了~
VGA转换器 VGA(Video Graphics Array)即视频图形阵列
分类 VGA转AV
VGA转DVI
VGA转HDMI
VGA转分量
举例说明 VGA转DVI转换器的DVI是指模拟信号的DVI，因DVI信号有数字信号与模拟信号的区别，而VGA信号也是模拟信号，同一信号定义之间才能实现转换，所以VGA模拟信号只能转DVI的模拟信号。VGA转DVI转换器应用于已有VGA接口的显示设备连接到显卡接口为DVI的计算机上。
简单化的描述是:您的显示设备(如显示器、等离子电视)的接口是标准VGA，而您的计算机显示信号输出口则是模拟DVI接口，点对点间的端口不能对应自然不能连接。此种情况下就需要用VGA转DVI转换器来实现两者之间的转换并连接
（看了百度百上的这些内容，才发现自己的专业课学的模数电还有信号处理和通信知识原来随处可见应用，同时又在想，如果课堂上老师拿出一些小小的实体，向我们展示一下，总比干讲好多了，实物往往能激发我们的好奇心）
上图是HDML转VGA线（HDMI信号是高清数字信号，实际运用中我们需要将HDMI数字信号转换成模拟信号输出，即VGA信号，例如需要将平板电脑接到投影仪。）这款转换线可直接一根数据线解决高清视频HDMI数字信号转换为VGA模拟信号及AUDIO音频信号的转换线,VGA信号可送到CRT/LED显示器,及投影机等,Audio音频信号可直接输出到外接功放。传统的VGA输出时本身不带音频信号，这款转换线解决了HDMI转换VGA时不带音频输出的困扰。同时可直接替代传统的HDMI转换盒，将HDMI转换信号经过技术压缩到单个芯片内，方便携带。
接口判定 如何判定自己的电脑是什么输出接口呢？用眼睛看显示器的口，VGA口是梯形3排15孔，HDMI口像U口，但比U口扁、宽。
总结 当我查阅相关知识的时候，发现相关的名字是这样的，有HDMI转VGA转换器，也有VGA转HDMI转换器，名字是反过来的，但是围绕的基本知识原理都是一样的，就是我们经常听到的两个词——“I/O接口”、“数模转换”（这几个字貌似是电子专业课本上出镜率最高的名词了，任课老师也没少提，其余的知识都是围绕这几个字展开的讲解，比如通信原理；或是作为工具去配合使用，比如傅里叶变换、拉布拉斯变换等等）
不管是HDMI 、DVI 还是什么VGA，都是为了通信界的发展产生的技术，目的就是彼此间的转换（本质挖掘的话是“数模转换”）。
PS:学渣一枚，知识说明不当之处，敬请斧正~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b20e26dac5245b8c054a0569a71ff8/" rel="bookmark">
			Android  dip/dp sp  px 单位转换小结 applyDimension
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import android.content.Context; import android.util.TypedValue; /** * 说明：相对于官方内部转换 都+0.5f的原因：根据网上的说法是为了保证结果不小于0. 【所以强转int后，数据还是对的】 * Created by Administrator on 2016/3/22. */ public class DensityUtil { //官方内部转换 dip转变为px尺寸 public static int dip2pxComm(Context context, float dipValue) { int size = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dipValue, context.getResources().getDisplayMetrics()); return size; } //官方内部转换 sp转变为px尺寸 public static int sp2pxComm(Context context, float spValue) { int size = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, context.getResources().getDisplayMetrics()); return size; } //2015年11月13日15:20:37 public static int dip2sp(Context context, float dipValue) { int pxValue = dip2px(context, dipValue); return px2sp(context, pxValue); } public static int sp2dip(Context context, float spValue) { int pxValue = sp2px(context, spValue); return px2dip(context, pxValue); } /** * 将px值转换为dip或dp值，保证尺寸大小不变 【代码里最终设置的单位基本都是px】 * * @param pxValue * @param scale * （DisplayMetrics类中属性density） * @return */ public static int px2dip(Context context, float pxValue) { final float scale = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b20e26dac5245b8c054a0569a71ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b2bdeff981653e7dd016249719fb39/" rel="bookmark">
			Wireshark分析DHCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCP，DNS和HTTP是3种常见的高层协议。
一，动态主机配置协议DHCP 1,DHCP简介 DHCP(Dynamic Host Configuration Protocol),动态主机配置协议，是一个应用层协议。当我们将客户主机ip地址设置为动态获取方式时，DHCP服务器就会根据DHCP协议给客户端分配IP，使得客户机能够利用这个IP上网。
DHCP的前身是BOOTP协议（Bootstrap Protocol）,BOOTP被创建出来为连接到网络中的设备自动分配地址，后来被DHCP取代了，DHCP比BOOTP更加复杂，功能更强大。后面可以看到，在用Wireshark过滤显示DHCP包，需要输入过滤条件BOOTP，而不是DHCP,但或许是因为我使用的Wireshark版本是比较旧的1.12.9,没有在新版本中尝试过，也许可以输入DHCP让其只显示DHCP包。
2，DHCP的实现 DHCP的实现分为4步，分别是： 第一步：Client端在局域网内发起一个DHCP　Discover包，目的是想发现能够给它提供IP的DHCP Server。 第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。 第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。 第四步：DHCP Server发送ACK数据包，确认信息。
二，利用Wireshark抓取DHCP包 1,分析 要想抓取到DHCP包，先要保证有可用的DHCP服务器，然后将主机IP地址获取方式设置为自动获取。如果主机在抓包之前已经联网，需要先断开主机的网络连接，然后再连接网络。在cmd下使用命令ipconfig来完成网络断开与连接的过程：
ipconfig /release 断开主机当前的网络连接 ipconfig /renew 请求连接网络 在cmd中可以使用ipconfig /?查看各参数的含义： (1)ipconfig /release 断开当前的网络连接，主机IP变为0.0.0.0，主机与网络断开，不能访问网络。 (2)ipconfig /renew 更新适配器信息，请求连接网络，这条命令结束之后，主机会获得一个可用的IP，再次接入网络。
2,开始抓包 实验环境：Win10,Wireshark1.12.9，有线连接 (1)在Wireshark中点击start开始抓包，在过滤栏输入bootp，使其只显示DHCP数据包。 (2)在cmd中输入ipconfig /release 断开网络连接。 可以看到此时所有的网卡都已经断开。以太网处于断开状态。
Wireshark中截获到一个DHCP Release数据包。
(3)在cmd中输入ipconfig /renew 请求网络连接。 此时，可以看到在Wireshark中新增了4个DHCP数据包： 数据包1：DHCP Discover 数据包2：DHCP Offer 数据包3：DHCP Request 数据包4：DHCP ACK
等待这条命令执行完毕之后，在cmd中可以看到主机被分配了IP，主机成功连入网络中。
(4)为了后续分析使用，我们再执行一次ipconfig /renew： 可以看到Wireshark中新增了3个数据包：DHCP ACK；DHCP Request;DHCP ACk。 如果再次使用ipconfig /renew,每执行一次会新增2个数据包：DHCP Request;DHCP ACk。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b2bdeff981653e7dd016249719fb39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d2e9e918470da89160f012daeccada/" rel="bookmark">
			oracle驱动表以及如何确定驱动表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		驱动表普遍认为是由SQL语句的写法决定的，简单的说，就是FROM语句后面的表列表中的最后一个。由于SQL语句是从后向前进行分析，Oracle会根据FROM语句从后到前将各个表依次连接起来。
SQL&gt; CREATE TABLE T1 AS SELECT * FROM USER_TABLES;
表已创建。
SQL&gt; CREATE TABLE T2 AS SELECT * FROM USER_INDEXES;
表已创建。
SQL&gt; SET AUTOT ON EXP SQL&gt; SELECT COUNT(*) FROM T1, T2 2 WHERE T1.TABLE_NAME = T2.TABLE_NAME;
COUNT(*) ---------- 37
Execution Plan ---------------------------------------------------------- 0 SELECT STATEMENT ptimizer=CHOOSE 1 0 SORT (AGGREGATE) 2 1 MERGE JOIN 3 2 SORT (JOIN) 4 3 TABLE ACCESS (FULL) OF 'T2' 5 2 SORT (JOIN) 6 5 TABLE ACCESS (FULL) OF 'T1'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d2e9e918470da89160f012daeccada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b2064e828536a5e7f993241e6e66b8/" rel="bookmark">
			支付宝支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建一个header file（.h）文件，放入商家相关的宏
// PartnerConfig.h
// YuenAlipayDemo
//
// Created by peikua on 15/8/17.
// Copyright (c) 2015年 Ruan. All rights reserved.
//
#ifndef YuenAlipayDemo_PartnerConfig_h
#define YuenAlipayDemo_PartnerConfig_h
//合作身份者id，以2088开头的16位纯数字
#define PartnerID @"2088511933544308"
//收款支付宝账号
#define SellerID @"yingtehua8@sina.com"
//商户私钥，自助生成
#define PartnerPrivKey @"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAL0M8jaJCm9bMb7PjgI0wR9+mpzWTcNTwTyYBEXmrJg3MjRVluUezDjQhQBSrgaMTeM40cz+1Nt/f1OlS/vB9PzGSF+MDty6zS0NQEEvVjUUge7PsOtbPDIEmuPppKIj4wETfavaZt7j4/kVuABDC2P1DpPRP686dJsNTkSO5qrNAgMBAAECgYApxEVy9P3gMkagQFzAcgVEvwTLp7EQeV2U1IUFKHxzOKaX11z6C77UwoTP2HRoL/E5RSFc5+QBBn8L7NYHrgdAu4L5Kl048saM53QyXJviQs7lgxDSBbo+EHDY9OJJsVRalpqKSirgBZmce/M4/tNhDxUfV5yXvxOC43JEr92UIQJBAPXbahDDMN+D0MqG1y0zPyU5bJwopXsSLIxpqp4vRmHokMxlber5HGMgSSnVQ9x9j974G1RSamqV34xwnqPzIlUCQQDE2ZPgtKd9Te19kGpmmCs64iqlkUVabAuKI8wMyx4hGZx6/EpeufFiTpF3F3YDN37JOenBefLL9UIkrOrjXI6ZAkBmpX75FKV5DG3FwNph0r2QaxM/d3DvmzziOtOzS4WVJyYdUFO+ANerQzWIs7OrgPjqXKf8YpRvf7dfyT1SshYpAkAhj0qDw6jOVwvHHWjWZtjv6AEHSxX8zXDGM0YlZDeVww0Hdp2jOqYpcWWhXRGUiNCHs+TjREwdc4m8QPKmom/5AkAYGRw6TLB/XWfEvlGLMHMmbZWMXDBdBmlIN+JK2oRjIoTryG35KlXzAHWcAq2xVhvCd6gJjz9arUmqewOLBMWn"
//支付宝公钥
#define AlipayPubKey @"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCnxj/9qwVfgoUh/y2W89L6BkRAFljhNhgPdyPuBV64bfQNN1PjbCzkIM6qRdKBoLPXmKKMiFYnkd6rAoprih3/PrQEB/VsW8OoM8fxn67UDYuyBTqA23MML9q1+ilIZwBC2AQ2UBVOrFXfFl75p6/B5KsiNG9zpgmLCUYuLkxpLQIDAQAB"
//安全校验码（MD5）密钥，以数字和字母组成的32位字符
#define MD5_KEY @"1g81z5tgu3o2yst4mqm6n838dxe5cw1a"
#endif
3、在 ViewController.m 中导入必要的头文件，新建一个按钮，为按钮添加“购买Action”
// ViewController.m
// YuenAlipayDemo
//
// Created by peikua on 15/8/17.
// Copyright (c) 2015年 Ruan. All rights reserved.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b2064e828536a5e7f993241e6e66b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd23791e1cdc0096cfc66f7323870e1/" rel="bookmark">
			Java报表工具FineReport导出EXCEL的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际的应用中会经常需要将数据导出成excel，导出的方式除原样导出还有分页导出、分页分sheet导出和大数据量导出。对于excel2003版，限制了每个sheet的最大行数和列数，大数据量导出时会默认时分多个sheet，而excel2007不会出现这样的问题。这些导出方式在JAVA程序中分别有不同的接口来实现：
1、 原样导出
原样导出就是不预览直接导出excel
其程序接口代码如下：
outputStream = new FileOutputStream(new File("E:\\ExcelExport.xls")); ExcelExporter excel = new ExcelExporter(); //导出2007版 outputStream = new FileOutputStream(new File("E:\\ExcelExport.xlsx")); excel Excel2007Exporter excel = new Excel2007Exporter(); excel.export(outputStream, rworkbook); 效果图：
2、 分页导出
分页导出，如果报表模版是分页的，会按照分页的结果形式导出，重复的标题等也会重复。
其程序接口代码如下：
outputStream = new FileOutputStream(new File("E:\\PageExcelExport.xls")); PageExcelExporter page = new PageExcelExporter(ReportUtils.getPaperSettingListFromWorkBook(rworkbook)); //导出2007版 outputStream = new FileOutputStream(new File("E:\\PageExcelExport.xlsx")); excel PageExcel2007Exporter page = new PageExcel2007Exporter(ReportUtils.getPaperSettingListFromWorkBook(rworkbook)); page.export(outputStream, rworkbook); 效果图：
3、 分页分sheet导出
分页分Sheet导出时报表结果的每一页为一个Sheet保存在Excel文件中
其代码如下：
outputStream = new FileOutputStream(new File("E:\\PageSheetExcelExport.xls")); PageToSheetExcelExporter sheet = new PageToSheetExcelExporter(ReportUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd23791e1cdc0096cfc66f7323870e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a1897fa5e11a27855b577ff9e7f1c6/" rel="bookmark">
			js日期格式化和日期计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//--------------------------------------------------- // 日期格式化 // 格式 YYYY/yyyy/YY/yy 表示年份 // MM/M 月份 // W/w 星期 // dd/DD/d/D 日期 // hh/HH/h/H 时间 // mm/m 分钟 // ss/SS/s/S 秒 //--------------------------------------------------- Date.prototype.pattern=function(fmt) { var o = { "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 }; var week = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a1897fa5e11a27855b577ff9e7f1c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3aa8122369baeba272cb2e1a75f7dd6/" rel="bookmark">
			禁止手机APP屏幕切换的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在AndroidManifest.xml中相应Activity下进行android:configChanges="orientation|keyboardHidden" android:screenOrientation="portrait" 设置 该android:screenOrientation属性，他有以下几个参数： "unspecified":默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向. "landscape":横屏显示（宽比高要长） "portrait":竖屏显示(高比宽要长) "user":用户当前首选的方向 "behind":和该Activity下面的那个Activity的方向一致(在Activity堆栈中的) "sensor":有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。 "nosensor":忽略物理感应器，这样就不会随着用户旋转设备而更改了（"unspecified"设置除外）。 比如下列设置 android:screenOrientation="portrait" 则无论手机如何变动，拥有这个属性的activity都将是竖屏显示。 android:screenOrientation="landscape"，为横屏显示。 上述修改也可以在Java代码中通过类似如下代码来设置 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd194f97efe4eaaf5497a859b9396a5/" rel="bookmark">
			CS域和PS域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CS域和PS域的区别：
1、基本概念：
CS：Circuit Switch表面意思就是电路交换；
PS：PacketSwitch表面意思就是分组交换。
2、不管是在W、TD还是CDMA中，还是在传统的GSM中，都是存在这两个概念的。
3、CS业务主要是包括一些语音业务，如64K语音等等。但是也包括一些电路型数据业务，最为常见和经典的就是传真；
4、PS业务就是常见的数据业务，也包括流媒体业务、VOIP等等。 5、一些网络，如WLAN、LTE等都是没有CS业务的，他们的语音业务都只能通过VOIP来实现。
6、CS和PS是针对核心网部分而言的，两者的不同在于交换方式。CS是电路交换，通信之前，资源预留，不同用户独占各自分配的资源，没有统计复用。PS是包交换，不同的用户可以共享同样的资源，统计复用。包交换又分为面向连接和非连接，面向连接预先为数据包指定路由，从而减少路由时间，也在一定程度上保证了数据包的顺利到达；非连接不预先指定路由，各个数据包单独选路。但不管是面向连接和非连接，在对资源的使用上都是采用了存储转发的统计复用方式。
所以一般语音走CS域，而手机上网走PS域。但如果是VOIP电话这算是走PS域。
7、CS域主要负责语音业务，如12.2K语音业务，64K视频电话业务等，PS域用于数据业务，通俗点说也就是上网业务，接入互联网。
8、CS域叫电路交换域，主要有语音业务（AMR 12.2K），视频电话业务（CS64K）；PS域叫数据交换域，负责数据业务，包括PS384K业务（UE发起384kbps PS域数据业务，是用手机下载一些数据文件等），还有就是高速数据业务包括上传和下载数据业务，也就是HS业务等。
9、交换方式和业务不一样。CS主要针对实时性要求较高的业务，如语音、视频业务，对延时的要求很高。PS是分组数据业务，体现在数据二字上面，主要提供像PS384HS等上网服务
10、CS电弧交换，独占信道主要用于语音，直到通话结束才释放信道，供其他用户使用。PS分组交换（包交换），主要用于数据业务（上网之类），采用分组-转发机制，多用户共用信道资源，使得资源利用率大大提高。
LTE中的CS域和PS域：
1、LTE是没有cs域，只有ps域。所以4g网络是无法直接进行语言业务的，只能通过csfb（电路域回落）技术，在2g进行语音业务。
2、到了LTE中，所有的语音业务将以VOIP的方式进行；
3、LTE中是没有必要区分语音和数据业务的，因为他们都是IP；
4、如果要区分，是由service option选项的，具体的VOIP、彩信、数据业务等都不同
5、核心网的统计会更为准确
6、LTE中只是取消了CS域，CS业务走ps域的IP承载，LTE同样应该支持与GSM/TD/WCDMA的互操作，如果无法承载语音业务了，那么这些互操作也就没了意义
7、支持语音通信，只不过其承载方式和以往的电路交换不同，同数据业务一样是IP承载，即VOIP
8、总之、TD-LTE的核心网是纯IP组网的。不可能支持语言通话。
不过和WLAN、IP网络一样，可以支持VoIP。
通俗点说，就是类似于QQ语音之类的业务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15b3d2a749098d1957c435b03af522a/" rel="bookmark">
			在eclipse启动Tomcat服务，但是网页输入http://localhost:8080/报404错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我就郁闷明明在eclipse中启动了tomcat服务器而且显示正常，但是怎么到网页中就是访问http://localhost:8080出现404错误”如下图：
但是如果自己手动启动tomcat（非eclipse中启动），，然后输入http://localhost:8080/，居然又可以看看小猫了。郁闷一天最后在网络上找到答案，按如下设置。
这样的问题，需要在eclipse中进行一系列的设置才行。
在server location选项中选择第二项，默认是选择第一项的。要是这个选项是灰的，不能够改，请删除tomcat服务器，再重新添加服务器试试，不要启动服务，刚添加tomcat时就切换到该窗口进行以下两步，就可以了。
最后刷新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05351b12b57af4c496a08defd94faf7/" rel="bookmark">
			VS2013取消预编译头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建C++ Win32控制台时忘了取消预编译头，怎么取消？
右键项目-&gt;属性-&gt;配置属性-&gt;C/C++-&gt;预编译头-&gt;不使用预编译头。
改天再写预编译头是干嘛的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21070511612e2b8828ceece608dd08f7/" rel="bookmark">
			XML使用XSL样式表在浏览器中以XHTML样式展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从一个原始的 XML(cdcatalog.xml)文档开始
1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;? xml version = "1.0" encoding = "ISO-8859-1" ?&gt; &lt;catalog&gt; &lt;cd&gt; &lt;title&gt; Empire Burlesque &lt;/title&gt; &lt;uri&gt; www.akmumu.com &lt;/uri&gt; &lt;country&gt; USA &lt;/country&gt; &lt;company&gt; Columbia &lt;/company&gt; &lt;price&gt; 10.90 &lt;/price&gt; &lt;year&gt; 1985 &lt;/year&gt; &lt;/cd&gt; . . . &lt;/catalog&gt; 这时候使用浏览器访问xml文件，会以各浏览器的标准xml样式展示，有的时候我们需要以自己定义的样式预览，比如定义一个a标签，里面有xml的链接，并可以点击，这时候我们需要建立一个XSL（cdcatalog.xsl） 样式表文件如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21070511612e2b8828ceece608dd08f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cea370c5cb1a50586ea01530bcdf5a/" rel="bookmark">
			C&#43;&#43;: string 中find函数的用法以及string::npos的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++: string 中find函数的用法以及string::npos的含义 标签：C++ string find函数 npos 字符串包含
by 小威威
问题：有两个字符串a、b, 现想判断a字符串是否包含b字符串，该如何设计程序？
思路：此处需要用到string库中的find函数与npos参数。
先说说string::npos参数： npos 是一个常数，用来表示不存在的位置，类型一般是std::container_type::size_type 许多容器都提供这个东西。取值由实现决定，一般是-1，这样做，就不会存在移植的问题了。 再来说说find函数： find函数的返回值是整数，假如字符串存在包含关系，其返回值必定不等于npos，但如果字符串不存在包含关系，那么返回值就一定是npos。所以不难想到用if判断语句来实现！
if (a.find(b) != string::npos) { cout &lt;&lt; "Yes!" &lt;&lt; endl; } else { cout &lt;&lt; "No!" &lt;&lt; endl; } 现完整代码如下：
# include &lt;iostream&gt; # include &lt;string&gt; using namespace std; int main(void) { int number; cin &gt;&gt; number; while (number--) { string a, b; cin &gt;&gt; a &gt;&gt; b; int pos = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cea370c5cb1a50586ea01530bcdf5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad292849b29ee40c1eff6184e76c63a3/" rel="bookmark">
			Android 计算当前使用内存百分比的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些手机管家软件可以显示当前系统内存使用了百分之多少，这个数字的得到是通过 取得总内存大小，减去可用内存大小，再与总大小做比值的结果，下面代码可以计算内存使用了多少。
? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 计算已使用内存的百分比 * */ public static String getUsedPercentValue(Context context) { String dir = "/proc/meminfo" ; try { FileReader fr = new FileReader(dir); BufferedReader br = new BufferedReader(fr, 2048 ); String memoryLine = br.readLine(); String subMemoryLine = memoryLine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad292849b29ee40c1eff6184e76c63a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac9e81a76d6f231bdbbb2319ff18110/" rel="bookmark">
			一次失败的j2v8集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V8 js引擎赫赫有名，为了将其集成到我们公司的安卓产品上，我们公司的老大准备使用j2v8这个中间体完成我们的v8引擎集成。我也有幸和老大一起参与到这个集成项目来。摸索了将近一周的用法，最后发现j2v8并没有我们想的那样完美。主要有两个问题：
1：多线程问题。J2v8是支持多线程的，所以在很多的方法里面都加入了线程的判断checkthread（）；而我们的项目中开了很多的多线程，在这个线程中new出来的v8,到另一个线程中进行使用就会报“invalid v8 thread access”。为解决这个问题，j2v8的作者专门写了v8.getLocker().release()和v8.getLocker().aquire()方法。使用这个方法，就可以解决线程检查的问题。可是问题又来了。在j2v8中我们发现只能使用一个v8对象，其他对象只能是v8object对象，然后v8object add 到v8对象中。而v8object对象并没有getlocker（）方法。线程检查又一次档住了我们的去路；
2：函数重载的问题。J2V8并不支持函数重载，我们的项目中，有的函数的参数是多变的。j2v8的作者明确提出不支持这种重载的写法。这也是我们最终放弃它的原因。
但我们还是需要更新我们的js引擎。迫不得已，我们公司的老大硬着头皮升级了我们原先的js引擎-minijoe。研究发现，minijoe确实是一款小巧精简有力的引擎。只可惜它并没有受到大家的重视，没有得到很好的扩展。这次，公司老大发挥其死磕到底的精神，将minijoe从一个不支持面向对象编程的引擎改造成了支持面向对象编程和jQuery库的引擎。心中敬仰之情大大的。而总共花的改造时间只有两天。大大缩短了工期。
总结来说，技术在于积累，happy coding,happy world.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27f988cc6aba6b164d3842a2caeee1b/" rel="bookmark">
			递归式求解的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法设计经常用到递归，而递归式是比较好写的，也是容易反应算法的设计思路的，我们分析含递归算法的时间复杂度就要求解递归式。
下面介绍求解递归式的三种方法，以下方法参考《算法导论》，图片来自网络。
1.主方法求解递归式 一种求解大部分递归式的公式。简洁实用，有兴趣的同学可以自己去看算法导论上的证明，这里只列举结论。
给出递归式: T(n) = a * T(n/b) + f(n) ，其中a&gt;=1，b&gt;1，f(n)是给定的函数，T(n)是定义在非负整数上的递归式。
这种方法要记忆三种情况，
将余项f(n)与函数进行比较， 直觉上来说两个函数的较大者决定了递归式的解，如果两个函数相当，则乘上一个对数因子logn。
这里要注意主方法不能求解的地方，所有的大于和小于都是多项式意义上的大于和小于，对于有些递归式夹在三种情况的间隙中，是无法用主方法来求解的。下面解释一下什么是多项式意义上的小于和大于： f(x)多项式大于g(x):存在实数e&gt;0,使得f(x)&gt;g(x)*n^e
f(x)多项式小于g(x):存在实数e&gt;0,使得f(x)&lt;g(x)*n^e
举个例子，有递归式T(n) = 2T(n/2)+nlgn, = n,nlgn/n = lgn,此时不存在e&gt;0，使得n*lgn&gt;n*n^e，所以就不能用主方法求解。
2.递归树求解 用主方法求解不了的递归式，我们可以用递归树来猜测解的上界，然后用代入法来证明解的正确性。递归树的求解精确度取决于你画递归树的精确度。
举例， 画出它的递归树，
这里我们把递归树扩展到T(1)的层，然后以T(1)为单位把每层的代价求和，最后就是总的代价，需要注意的是，这里需要一定的数学知识。
3.代入法 比如我们求解，递归式T(n) = 2T(n/2)+n，我们猜测解是O(nlgn),我们要寻找到一个常数c,使得T(n)&lt;=cnlgn
即T(n) &lt;= 2c(n/2)lg(n/2)+n &lt;= cnlgn-cnlg2+n = cnlgn-cn+n
只要c&gt;=1,T(n)&lt;=cnlgn,所以我们的猜测是正确的。
要注意的是，代入法全凭经验，通常用递归树来确定上界，然后用代入法再证明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974921f34aef1d30ff0b807706694ae9/" rel="bookmark">
			京东-接口-PHP-SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://bbs.360buy.com/thread-335531-1-1.html 在之前京东提供的１.０版基础上修改的，适用于２.０接口的PHP版SDK；
主要就三文件：
1）JdConfig.php 配置文件 appkey等信息；
2）JdDefaultConfig.php 定义每个接口的默认提交信息；
3）JdApi2.php 接口调用主文件。
4）jdApi2_test.php 测试文件（获取授权分类）
PS：拍砖的轻点哦，我知道这很不完善O(∩_∩)O~ &lt;script&gt;window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];&lt;/script&gt; 阅读(2472) | 评论(0) | 转发(1) | 1 上一篇：Fedora 18?的?变化
下一篇：U盘 linux slax
相关热门文章 bootStrap中Tab页签切换京东SSO单点登陆实现分析...WebRTC学习笔记highcharts使用之饼图CU博客频道7月技术图书有奖试... linux dhcp peizhi roc关于Unix文件的软链接求教这个命令什么意思，我是新...sed -e "/grep/d" 是什么意思...谁能够帮我解决LINUX 2.6 10... 给主人留下些什么吧！~~ 评论热议 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/489/">«</a>
	<span class="pagination__item pagination__item--current">490/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/491/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>