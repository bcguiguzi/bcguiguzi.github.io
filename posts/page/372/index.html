<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b547ce729dbb10ae6b6f3633682620/" rel="bookmark">
			那些劝退小白的指针，其实并不难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到指针，真是让人又爱又恨，爱它是因为指针真的可以为所欲为，恨它是因为对于新手来说，一不小心就晕了。像什么常量指针、指针常量、指针数组、函数指针、二级指针、智能指针。。。。。。其实这么多奇奇怪怪的指针，不管它的语法有多么花里胡哨，本质上都是一个地址。
举个栗子
一、普通指针
int age = 18; int* p = &amp;age; cout &lt;&lt; "age的地址：" &lt;&lt; &amp;age &lt;&lt; endl; cout &lt;&lt; "age的地址：" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "age=" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; "age=" &lt;&lt; *p &lt;&lt; endl; 这时候p就是变量age的地址，那么p就是这个地址上的值，也就是18，可以给p赋一个新值，然后age的值也会变。但是age如果是一个常量，就不能这么干了，因为*p可以改变age的值，但是age又不能改，这就产生矛盾了，编译器会报错。
所以普通指针不能指向常量。
二、常量指针
int age = 18; const int* p = &amp;age; cout &lt;&lt; "age的地址：" &lt;&lt; &amp;age &lt;&lt; endl; cout &lt;&lt; "age的地址：" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "age=" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b547ce729dbb10ae6b6f3633682620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6016c3addd759adde19d78e79f8e87eb/" rel="bookmark">
			从可执行文件中删除.reloc节区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .reloc节区 EXE形式的PE文件中，“基址重定位表”项对运行没有什么影响，实际上，将其删除后程序仍能正常运行。VC++中生成的PE文件的重定位节区名为.reloc，删除该节区后文件照常运行，且文件大小将缩减，.reloc节区一般位于所有节区的最后。 若要删除位于文件末尾的.reloc节区，需要按照以下4个步骤操作： 整理.reloc节区头删除.reloc节区修改IMAGE_FILE_HEADER修改IMAGE_OPTIONAL_HEADER 删除.reloc节区头
可以看到.reloc节区头从文件偏移270处开始，大小为28，使用Hex Editor打开该区域，全部用0覆盖填充。
删除.reloc节区 文件中.reloc节区的起始偏移为C000，从C000偏移开始一直使用Hex Editor删除到文件末尾所有数据。
修改IMAGE_FILE_HEADER 修改IMAGE_FILE_HEADER的Number of Sections项，将5改成4
修改IMAGE_OPTIONAL_HEADER 删除.reloc节区后，整个映射就随之减少相应大小，映射大小值存储在IMAGE_OPTIONAL_HEADER-size of Image中，需要对其修改。
.reloc节区的VirtualSize值为E40，将其根据Section Alignment拓展后编程1000，所以应该从Size of Image减去1000才正确。
修改后reloc.exe文件就能够正常运行了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8080ff003e05c518e2392005ef661e2c/" rel="bookmark">
			python3  import新手详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		停了很久没有写东西，今天心血来潮写点最近学到并且挺实用的方法，let us go！
import模块--导入
方法一： import XXX
从运行结果看，导入模块one文件方法，不仅可以直接使用one的函数，也可以用来将函数结果做运算，注意one中你用到的print还是return
方法二： from XXX import *
从运行结果看，导入模块one文件所有方法，引用函数使用时写法是有区别的，看图中标红位置，方法和import XXX同理
学习以上两种方法后，是不是觉得突然将import明白了，当你一直import一些公共库时原理其实是一样得，至于你选择用那种方法取决于自己，如有觉得有你有所帮助，记得关注下哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e71b4b118248186e8a8023e759599f/" rel="bookmark">
			pynvml.NVMLError_LibraryNotFound: NVML Shared Library Not Found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法如下
A、出现这个提示的原因是安装后的Nvidia显卡目录C:\Program Files\NVIDIA Corporation\NVSMI不存在，造成的。
B、搜索文件Nvidia-SMI.exe,找到这个文件的目录，我的电脑在C:\Windows\System32\DriverStore\FileRepository\nvlti.inf_amd64_83a389b28f4c421e目录下，添加到系统Path下。
C、进入Nvidia驱动的默认安装目录C:\Program Files\NVIDIA Corporation下，手动创建文件夹NVSMI，把C:\Windows\System32\DriverStore\FileRepository\nvlti.inf_amd64_83a389b28f4c421e目录下的文件全部拷贝到C:\Program Files\NVIDIA Corporation\NVSMI目录下。
D、重启电脑，在C:\Program Files\NVIDIA Corporation\NVSMI目录下，在CMD下运行nvidia-smi.exe运行,如果出现下边的标志，说明OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528d360108d2f77b9dd36083f52ed7d5/" rel="bookmark">
			vue项目都在什么时候用store.state、$store.state和this.$store.state
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		store 和 [this.]$store 简单来说，如果你在根组件下注入了store那么所有的.vue文件里使用就可以直接用 this.$store.xxxx Vue官网：为了在 Vue 组件中访问 this.$store.property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制
//main.js import store from './store' new Vue({ el: '#app', store, //根组件注入store }) //index.vue getData() { return { userId: this.$store.state.user.userId, ...... } } 而在js文件里面如果想要使用store，就必须先引入import store from '@/store’然后使用store.xxx，因为js里面是打印不出来this.$store的 // src/test.js文件 import store from './store/'; console.log(store) console.log(this) // undefined console.log(this.$store) // 会报错 this.$store 和 $store $store 是挂载在 Vue 实例上的（即Vue.prototype），而组件也其实是一个Vue实例，在组件中可使用this访问原型上的属性&lt;template&gt; 拥有组件实例的上下文，可直接通过 {{$store.state.XXX }} 访问，等价于 script 中的 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528d360108d2f77b9dd36083f52ed7d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad3384ac67fb8b87c7b366fda1de7cf/" rel="bookmark">
			查看已下载的Docker镜像latest具体版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令格式：
docker image inspect (docker image名称):latest|grep -i version 实例：
[root@docker ~]# docker image inspect zabbix/zabbix-server-mysql:latest|grep -i version "ZBX_VERSION=5.0.1", "org.opencontainers.image.version": "5.0.1" "DockerVersion": "19.03.8", "ZBX_VERSION=5.0.1", "org.opencontainers.image.version": "5.0.1" 可以获取到zabbix-server的镜像版本为5.0.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e96d6cf4cd3e1d7962547717dcf0e4/" rel="bookmark">
			主动降噪蓝牙耳机将成为真无线蓝牙耳机市场主力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在蓝牙耳机领域，带有降噪功能的蓝牙耳机正越来越多的推向市场，并且随着蓝牙5.0技术的成熟，不管是音质还是传输，都有了不小提升，越来越多厂商推出带有自家特色的TWS蓝牙耳机。
更为关键的是，随着人们对降噪这项技术的日益青睐，搭载主动降噪功能的蓝牙耳机逐渐成为市场香饽饽。不管是哪种形态，主动降噪蓝牙耳机都有很高的关注度。
TWS真无线蓝牙耳机依旧火爆，蓝牙5.0技术逐渐占领市场，主动降噪耳机成新一代风向标。
TWS真无线蓝牙耳机购买影响因素
据调查，音质、佩戴舒适度、电池寿命、易用性、主动降噪、语音通话质量等因素是消费者在购买真无线耳机时的主要影响因素。
杰理科技推出AC697N是一颗超低功耗全集成自适应主动降噪方案蓝牙芯片，最低功耗可达5mA以下，32位DSP支持硬件浮点运算，支持蓝牙 5.1+BR+EDR+BLE，24-bit的DAC，信噪比最高可达103dB，24-bit的ADC，信噪比最高达92dB以上，最多可支持三路麦克风。超强DSP处理能力和通话降噪算法，支持双麦降噪方案，高质量的提高了通话效果，特别是在一些复杂的应用场合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c76ba39198d5bf778ab105652c1501/" rel="bookmark">
			【Qt】Qt5.12第一次编译安卓工程卡在下载gradle.zip文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gradle是安卓工程的构建工具，能够提供依赖、打包、部署、发布等工作。所以在第一次编译安卓工程时候会进行搭建gradle。
编译的时候在编译输出部分看到卡在
Downloading https://services.gradle.org/distributions/gradle-4.6-bin.zip 不动。这个下载链接在浏览器中打开能够很快的下载，我也不懂为什么就卡主了。
网上找到了gradle的默认下载路径为
C:\Users\Mango\.gradle\wrapper\dists\gradle-4.6-bin\4jp4stjndanmxuerzfseyb6wo 其中Mango为我计算机的用户名，选择你电脑对应的用户名就好了。
用浏览器打开那个下载链接，下载完成后拷到这个目录下，然后重新编译，就能够识别到了，就能够继续解压下载相关的东西了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595f3f560bdf717629131071134f26df/" rel="bookmark">
			LaTex 图形显示之subfloat使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导言区加入如下包：
\usepackage{graphicx} \usepackage{float} \usepackage{subfig} 图形排版
% 两个图 按“日”字形排版 \begin{figure} \centering \subfloat[]{ \includegraphics[width=\textwidth]{fig1a.pdf}} \quad % 重要，图形换行命令 \subfloat[]{ \includegraphics[width=\textwidth]{fig1b.pdf}} \caption{AAA} \label{fig1} \end{figure} % 四个图，按“田”字形排版 \begin{figure} \centering \subfloat[]{ % []内可单独为每个小图命名。默认按照(a)(b)...的顺序命名，若省去[]则小图不命名。 \includegraphics[width=1.95 in]{fig1a.png}} \subfloat[]{ \includegraphics[width=1.95 in]{fig1b.png}} \quad \subfloat[]{ \includegraphics[width=1.95 in]{fig1c.png}} \subfloat[]{ \includegraphics[width=1.95 in]{fig1d.png}} \caption{AAAA} \label{fig1} \end{figure} 参考：latex多幅图片对齐方法
扩展阅读：Latex中插入多张图片，实现并排排列或者多行多列排列
用下面这种也能达到对应的效果。（PS：这种方式看起来简洁一些）
\begin{figure}[htbp] \centering \subfigure[pic1.]{ \includegraphics[width=5.5cm]{111.eps} %\caption{fig1} } \subfigure[pic2.]{ \includegraphics[width=5.5cm]{111.eps} } \quad \subfigure[pic3.]{ \includegraphics[width=5.5cm]{111.eps} } \subfigure[pic4.]{ \includegraphics[width=5.5cm]{111.eps} } \caption{ pics} \end{figure} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cba818f0ff99dab16513e3d24b4149/" rel="bookmark">
			snabbdom的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们上一篇博客中介绍了虚拟DOM的基本概念及常见类库，其中常见类库有2种，snabbdom和virtual-dom，而snabbdom是vue2.x版本中所使用的，所以我们这片文章就主要来记录一下snabbdom的基本使用。
创建项目 打包工具为了方便使用比较简单的parcel
创建项目 并安装parcel
mkdir snabb-demo // 在工作目录下建立snabb-demo子目录 cd snabb-demo //进入snabb-demo 目录 yarn init --yes //初始化一个package.json文件,也可以用npm init yarn add parcel-bundler --dev // 安装parcel 创建目录结构，根目录下创建一个index.html,src目录下创建一个basicuse.js
其中index.html内容如下：
其中html代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;snabbdom demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src="./src/basicuse.js"&gt;&lt;/script&gt; 在package.json中配置脚本
"scripts":{ "dev": "parcel index.html --open", "build":"parcel build index.html" } 导入snabbdom snabbdom文档 英文文档：https://github.com/snabbdom/snabbdom中文文档：https://github.com/coconilu/Blog/issues/152 安装snabbdom ``` yarn add snabbdom //即可安装sanbbdom，也可以安装指定版本0.7.4 ``` 导入snabbdom 采用es module 方式导入snabbdom 文档给出的示例是 var snabbdom = require(‘snabbdom’)采用的是commonJS的模块化方式引入的;我们此处需要使用es module来进行导入，所以我们去node_modules中找到snabbdom中的snabbdom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81cba818f0ff99dab16513e3d24b4149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa61f0d203bff0845f0383c4e40e413/" rel="bookmark">
			快递鸟免费物流查询接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快递鸟物流接口支持每天500次免费查询，但是免费版只支持中通，圆通，申通，这三家快递的物流信息查询，那不能查询其他家快递怎么办？放心，只要人民币给到位，什么姿势它都会！
使用
首先申请一个快递鸟账号，下附地址：
http://www.kdniao.com/reg
注册登录后就可以看到自己的基本信息
请求系统级参数说明：
备注：R-必填（Required），O-可选（Optional），C-报文中该参数在一定条件下可选
接口参数：
请求内容字段定义：
返回参数定义：
详见文档：http://www.kdniao.com/api-track
JAVA环境的Demo
package com.zjw.demo.test; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; import java.security.MessageDigest; import java.util.HashMap; import java.util.Map; /** * * 快递鸟物流轨迹即时查询接口 * * @技术QQ群: 456320272 * @see: http://www.kdniao.com/YundanChaxunAPI.aspx * @copyright: 深圳市快金数据技术服务有限公司 * * DEMO中的电商ID与私钥仅限测试使用，正式环境请单独注册账号 * 单日超过500单查询量，建议接入我方物流轨迹订阅推送接口 * * ID和Key请到官网申请：http://www.kdniao.com/ServiceApply.aspx */ public class kdniaoTrackQueryAPI{ //DEMO public static void main(String[] args) { kdniaoTrackQueryAPI api = new kdniaoTrackQueryAPI(); try { String result = api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa61f0d203bff0845f0383c4e40e413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f6d2244a277efae4521818b5d5ca88/" rel="bookmark">
			IDEA:java:无效的源发行版：14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
问题原因
解决方法
问题描述： 用IDEA编写代码运行后报如下错误：
问题原因： 出现该问题的原因是项目Project当中的jdk与电脑当中的jdk版本不一致造成的。
解决方法： 1.查看本机的jdk版本：命令提示输入：java -version
2.修改IDEA当中的Project项目的jdk版本
第一步:打开Project Structure项目结构
第二步：修改Project的SDK版本
第三步：修改Module模块的Language Level
第四步：修改Module模块中的Module SDK
3.找到Java Complier，修改byte code version，使其版本与sdk版本保持一致
总结：修改过后，再次编译运行就没有问题了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df0508bd000b45a78e30977b8a1ede4/" rel="bookmark">
			QT事件系统之二:鼠标事件和滚轮事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 QMouseEvent的详细描述
QMouseEvent 类用来表示一个鼠标事件，当在窗口部件中按下鼠标、释放鼠标和移动鼠标指针时，都会产生鼠标事件 QMouseEvent。利用 QMouseEvent 类可以获知鼠标是哪个键按下释放了、鼠标指针的当前位置等信息。通常是重定义窗口部件的鼠标事件处理函数来进行一些自定义的操作。
Qt中的QMouseEvent一般只涉及按下鼠标、释放鼠标和移动鼠标指针等操作，而对鼠标滚轮的响应则通过QWheeEvent来处理。
鼠标移动事件只会在按下鼠标按键的情况下才会发生，除非通过显式调用。
QWidget::setMouseTracking()函数来开启鼠标轨迹，这种情况下只要鼠标指针在移动，就会产生一系列的Qt鼠标事件。
回到顶部
二、 QMouseEvent的传递
多个重叠的窗口在实现里好比一个递归的倒立树，鼠标事件会沿着鼠标指针所在的父窗口的链表向上传递，直到某个窗口调用accept()函数进行事件处理，否则该事件将被过滤销毁掉。
如果想要鼠标指针所在的父窗口不接收该事件，则可以调用函数ignore()予以忽略。
如果一个鼠标事件传递给鼠标指针所在的窗口，而该窗口的QT::WA_NoMousePropagation位置为TRUE，则该事件不会通过父窗口继续向上传递。
可以使用QWidget::setEnabled()来开启/关闭对应的窗口是否接受键盘和鼠标事件。
回到顶部
三、鼠标事件实例
鼠标事件使用的时候，加头文件：
#include 3.1 鼠标按下事件 mousePressEvent()
mousePressEvent() 函数可以区分出鼠标按下时是左键还是右键，以及获取鼠标按下时的坐标值等。
所以我们可以在头文件中重写这个函数：
protected:
//鼠标按下事件
void mousePressEvent(QMouseEvent * event);
然后就是在源文件中去实现具体的逻辑了：
//鼠标按下事件
void MainWindow::mousePressEvent(QMouseEvent * event)
{
if(event-&gt;button() == Qt::LeftButton)
{
qDebug() &lt;&lt; “左键按下” ;
}
else if(event-&gt;button() == Qt::RightButton)
{
qDebug() &lt;&lt; “右键按下” ;
}
//获取按下时的鼠标指针坐标 qDebug() &lt;&lt; event-&gt;x() &lt;&lt; ":" &lt;&lt; event-&gt;y(); }
这样我们就能知道你按下时是左键还是右键，以及获取你按下时的鼠标指针坐标。运行程序，在窗口左键点击一下，右键点击一下，输出如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df0508bd000b45a78e30977b8a1ede4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb76132cffe40dc572002ff78ecde25e/" rel="bookmark">
			OpenVINO学习：2.跟Demo学VINO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客旨在讲解OpenVINO套件中模型转换和推理引擎Demo所在文件。
OpenVINO的安装在其官网上步骤较为详细，OpenVINO工具套件安装参照此文档可完成OpenVINO安装，在此不做赘述。本人安装的版本为2020.4，系统为ubuntu16.04。不同版本OpenVINO在目录结构上可能会存在一些差异。
OpenVINO工具套件安装完成后可以/opt/目录下看到/Intel/目录。
OpenVINO目录结构 上图为openvino的目录结构，我们需要着重注意"openvino_2020.4.287/deploment_tools/"目录中的内容，其中有进行模型转换与优化的“model_optimizer”文件夹与包含推理示例程序的”inference_engine“文件夹。
openvino_2020.4.287文件目录结构 通过运行“model_optimizer”目录中的mo_caffe.py、mo_tf.py等python脚本可以将各个框架的深度学习模型转化为统一格式的IR中间文件。
model_optimizer文件 inference_engine/demos/中有使用C++和python编写的yolo、faster_rcnn等算法的推理程序，我们可以参考这些代码编写自己的目标识别或目标跟踪等机器视觉程序。
inference_engine文件 根据以上介绍的有关OpenVINO的内容，大家对与OpenVINO模型转换与优化和推理有关的两个重要目录有了初步的了解。OpenVINO开发指南可以帮助诸位深入了解OpenVINO的使用方法，后续我也会发布使用OpenVINO对yolov3进行实战开发的过程和自己的心得体会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/587a9a1ec22373c11ef6628c63b62140/" rel="bookmark">
			编程初学者入门训练-KiKi设计类继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 KiKi定义电子日历类KiKi设计类继承 1.题目描述 KiKi学习了面向对象技术，学会了通过封装属性（变量）和行为（函数）定义类，现在他要设计一个电子日历类TDate。
它有3个私有数据成员：Month,Day,Year和若干个公有成员函数，要求：
（1）带有默认形参值的构造函数，默认值为0, 0, 0；
（2）输出日期函数，用“日/月/年”格式输出日期；
（3）设置日期函数，从键盘输入年、月、日。
1.1输入描述 一行，三个整数，用空格分隔，分别表示年、月、日。
1.2输出描述 一行，用“日/月/年”格式输出日期。
1.3示例1 输入
2019 12 30
输出
30/12/2019
1.4代码实现 import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.IOException; class TData{ private int Year; private int Month; private int Day; public TData(){ this.Year = 0; this.Month = 0; this.Day = 0; } public TData(int Year, int Month, int Day){ System.out.println(Day+"/"+Month+"/"+Year); } } public class Main{ public static void main(String[] args) throws IOException{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/587a9a1ec22373c11ef6628c63b62140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6ac4886a148aba12bbb4f49f260690/" rel="bookmark">
			利用Javaweb做的教师信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Javaweb做的教师信息管理系统 每个学校官网都会有一个教师信息板块，在这个板块中会记录着在校所有老师的一些信息，在学习了Javaweb的jsp、JavaScript、servlet、javabean等技术之后，我也利用所学知识做了一个小型的教师信息管理系统来巩固已学过的知识。
在这个系统中一共有3组用户，分别是管理员、教师本人和访客。管理员模块包括的功能有查询所有教师名录、查询单个教师详细信息、增加教师信息、删除教师信息、修改教师信息；教师模块包括的功能有查看个人信息和修改个人信息；访客模块包括的功能有查阅师资力量、查阅杰出人才、查阅教师名录、查阅某个教师的详细信息。
系统功能不多，主要是为了巩固所学知识，以下是系统主要部分的截图：
登录界面
一、管理员模块
1.查询所有教师目录
2.添加教师信息
3.修改教师信息
4.删除教师信息
删除信息确认
5.查询教师详细信息（按照教师编号查询）
教师个人主页：
二、教师模块
1.修改个人信息
2.查看个人信息
三、访客模块
1.师资力量
2.杰出人才
3.教师列表（分页显示）
4.教师查询（按照姓名查询）
查询成功则跳转教师个人主页。
这就是我做的系统的截图，也算是为自己留个纪念，若日后蓦然回首，曾经计算机道路上的一块砖还会是在这里等我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe8222a2be487e7d557418d2c0506cd/" rel="bookmark">
			遍历vector容器的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;windows.h&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;iterator&gt; #include&lt;algorithm&gt; using namespace std; int main(void) { vector&lt;int&gt; v1; for (int i = 0; i &lt; 4; i++) v1.push_back(i); //遍历容器的4种方法 //1.普通for循环 for (unsigned i = 0; i &lt; v1.size(); i++) cout &lt;&lt; v1[i] &lt;&lt; " "; cout &lt;&lt; endl; vector&lt;int&gt;::iterator it = v1.begin(); //2.使用迭代器的for循环 for (it; it != v1.end(); it++) cout &lt;&lt; *it &lt;&lt; " "; cout &lt;&lt; endl; //3.基于范围的for循环 for (int x : v1) cout &lt;&lt; x &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe8222a2be487e7d557418d2c0506cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5294704cccaaeccffebcdeb891a1f1d7/" rel="bookmark">
			Javaweb做的页面置换算法模拟实验平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Javaweb做的页面置换算法模拟实验平台 在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。
在学习完操作系统之后，为了对页面置换算法有更深一步的认识，于是做了关于OPT、FIFO、LRU、LFU四种页面置换算法的模拟过程，为了使展示效果更加形象，采取了在web网页上显示。
这四种页面置换算法相信大家已经很熟悉了，下面简单介绍之后就放上自己的界面效果截图，有感兴趣的我们可以一起交流。
OPT
最佳置换算法（OPT）就是从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。
FIFO
先进先出置换算法，这是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，成为替换指针，使它总是指向在内存中驻留时间最久的页面。
LRU
最近最久未使用置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰，该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面予以淘汰。
LFU
LFU(Least Frequently Used)最近最少使用算法，顾名思义，算法的主要思想是如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。
在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如 100 ns，在 1 ms 时间内可能对某页面连续访问成千上万次， 因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置 1，再每隔一定时间(例如 100 ms)右移一次。 这样，在最近一段时间使用最少的页面将是∑Ri 最小的页。然而LFU 算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，访问一次和访问 10000 次是等效的。
界面运行截图
1.主界面
2.模拟一次设置参数
3.模拟一次中间结果
4.保存实验数据
（1）多次结果
（2）单次实验结果
5.模拟多次试验数据结果
（1）使用默认参数
（2）使用自定义参数
中间还有一些关于数据库的部分本人是利用可视化工具Navicat连接mysql处理的，也可以使用其他工具。
这就是我做的系统的大部分截图，有兴趣的伙伴我们可以一起交流，今后可能还会增加一些其他置换算法的模拟过程（待更）。
附加鸡汤一句：
这世上有两样东西是别人抢不走的：一是藏在心中的梦想，二是读进大脑的知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d9a5819f35ff4617dd525a2c6bf08f/" rel="bookmark">
			逆向工程核心原理源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1qvXbeE9AIZyTpVTKIIyuGA
提取码：zofw
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7175b8f8db8ca4cbdca6a01517d57af/" rel="bookmark">
			这些opencv的书籍和网站里，肯定有你不知道的宝藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟大家分享一些opencv的书籍和网站。
都是我从入门到现今四处收集到的，曾经因为命令行操作不当把磁盘给清空了，但幸好电子书都找回来了，然后我就都上传到网盘存起来了。
今天拿来分享给大家，有了这些根本不需要去买任何实体书了（除非特别喜欢看实体书哈）。
书籍 先给大家贴个图：
大部分是我到处搜集来的，还有一些是花钱在某鱼上买来的，今天把下载链接分享给大家（如果失效了可以公众号【opencv视觉实践】后台回复【视觉电子书】获取）
链接：https://pan.baidu.com/s/1LOEmjg_ton9xU8dCez1BlQ
提取码：7cog
1：《Opencv3编程入门-毛星云》
这本书是我的入门书籍，但也仅限于入门，大家看完一遍后一定要入手其他书籍或者做一些实战项目进行练手，否则只能在入门水平徘徊。
2：《学习opencv3》
这本书作者就是opencv库的开发者，此书比较厚但也更全面，适合看完《Opencv3编程入门-毛星云》进一步补充和进阶。
3：《OpenCV计算机视觉编程攻略.第3版》
这本书真的是宝藏书籍，包含很多实战案例，第三版是目前最新版本了。
4：《OpenCV-python中文官方文档410》
这本书是翻译的英文版opencv-python的官方教程，嗯，官方的，不多介绍了。
5：《OpenCV-contrib modules中文教程抢鲜版》
专门介绍Opencv-contrib模块的教程。contrib模块里包含的都是各类新开发的比较前言的算法。比如人脸检测啊目标追踪啊等等一些新算法。
6：《计算机视觉_算法与应用中文版》
这本绝对是工具书了，又大又厚，工具书其实不推荐看电子版，还是买本或者打印本实体书多啃啃。看完绝对进阶。
7：《数字图像处理-冈萨雷斯》
学opencv肯定光学一个库是不够的，图像处理的基础必须打好，这本书很经典。篇幅有限关于数字图像处理就不多说了，可以看我公众号的资源分享专栏。分享计算机视觉的各种学习资源。
8：《图像处理技术手册》
这本书也是个工具书，1500多页，想看就看看吧，，，
9：《opencv函数手册》
一个查函数的pdf，比较方便，就是版本有一丢丢老，也可能是不齐，大部分函数能搜到但也有搜不到的。
分享文件夹里还有其他的书籍，但是专业性就比较强了，我也只是偶尔翻翻，所以就不说啥了，自己探索吧。
网站 网站其实还是多逛逛知乎，csdn的一些人的博客更好。
1：外国有一个“光头哥”很火，他进行了很多计算机视觉实战的分享，国内可以看到一些中文版搬运工，网址：
pyimagesearch.com/2014/ 2：也是一位国外大佬的
https://www.learnopencv.com/ 3：我爱计算机视觉的论坛网站
https://www.52cv.net/ 4：opencv官网以及官网文档
https://docs.opencv.org/4.1.0/ 5：计算机视觉论坛
论坛这东西我不常逛，不过如果喜欢的话，看看也会有收获的：
cvchina.net/ 6：OPENCV中文网站论坛
感觉这个论坛最近不很活跃，
opencv.org.cn/forum/ 7：还有一个不知道从哪里知道的一个网站，没怎么看过，让它来充数吧！
analyticsvidhya.com/blo 总结 这些电子书足够支撑初学者从入门进阶到很高的水平了，网站推荐还是多逛逛我推荐的里面的英文网站，真的全是干货和宝藏，真的不用发怵英文，电脑打开网页，再打开有道词典，根本没有看不懂的。
拒绝白嫖，分享不易，点个赞再走吧！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/371/">«</a>
	<span class="pagination__item pagination__item--current">372/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/373/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>