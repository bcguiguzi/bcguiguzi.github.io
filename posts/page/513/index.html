<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9bdf5f281f71dc548d4988e52caad6a/" rel="bookmark">
			blog迁移通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi，大家好，鉴于csdn的不稳定性，俺自己开博，该blog会保留，但是不会再次更新
新的blog网址：http://blog.youmila.com
请大家继续支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d79ad69669e90bb449a5703ca2dea27/" rel="bookmark">
			AS3中检测类中是否存指定方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 private function hasFunction(target:Object,method:String):Boolean{ var obj:XML = describeType(sp) return obj.method.(@name==method).length() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc4873aa5d955c38300b0ea6facf63b/" rel="bookmark">
			端口号说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1=传输控制协议端口服务多路开关选择器
2=compressnet 管理实用程序
3=压缩进程
5=远程作业登录
7=回显(Echo)
9=丢弃
11=在线用户
12=我的测试端口
13=时间
15=netstat
17=每日引用
18=消息发送协议
19=字符发生器
20=文件传输协议(默认数据口)
21=文件传输协议(控制)
22=SSH远程登录协议
23=telnet 终端仿真协议
24=预留给个人用邮件系统
25=smtp 简单邮件发送协议
27=NSW 用户系统现场工程师
29=MSG　ICP
31=MSG验证
33=显示支持协议
35=预留给个人打印机服务
37=时间
38=路由访问协议
39=资源定位协议
41=图形
42=WINS 主机名服务
43="绰号" who is服务
44=MPM(消息处理模块)标志协议
45=消息处理模块
46=消息处理模块(默认发送口)
47=NI FTP
48=数码音频后台服务
49=TACACS登录主机协议
50=远程邮件检查协议
51=IMP(接口信息处理机)逻辑地址维
52=施乐网络服务系统时间协议
53=域名服务器
54=施乐网络服务系统票据交换
55=ISI图形语言
56=施乐网络服务系统验证
57=预留个人用终端访问
58=施乐网络服务系统邮件
59=预留个人文件服务
60=未定义
61=NI邮件?
62=异步通讯适配器服务
63=WHOIS+
64=通讯接口
65=TACACS数据库服务
66=Oracle SQL*NET
67=引导程序协议服务端
68=引导程序协议客户端
69=小型文件传输协议
70=信息检索协议
71=远程作业服务
72=远程作业服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc4873aa5d955c38300b0ea6facf63b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1298a2f5d9bd600b7babdc646056865/" rel="bookmark">
			PDP context激活的大致原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动终端开机连接到运营商后，访问3G网络外部IPv6业务，主要包括以下三个过程：
（1）附着（ATTACH）。附着过程的目的是系统根据移动终端的签约数据确定是否允许移动终端在当前请求的GPRS路由区域中进行数据业务访问。附着过程与IPv6无关。
终端可以在开机通过无线接入鉴权获得无线信道后即向SGSN发起“附着请求”消息，SGSN得到终端IMSI标识后，向HLR中请求进行认证，并根据HLR下达的用户签约数据对终端进行鉴权，同时SGSN将终端的当前位置信息上传HLR。鉴权通过后，SGSN就会向终端返回“接受附着”消息。
（2）PDP（Packet Data Protocol）上下文激活。通过PDP上下文激活过程，用户获得相应的GGSN的鉴权许可，分配相应的IPv6地址，建立终端与基于GPRS的3G分组域之间的数据通道。
PDP激活过程由用户终端发起。终端首先向SGSN发起“激活PDP上下文请求”消息，消息中携带APN(服务访问点名称)，服务质量等信息；SGSN根据消息中携带的APN向HLR中查寻相应的GGSN的地址，获得GGSN地址后，再向GGSN发送“创建PDP上下文请求”；GGSN可以通过本地/DHCP/RADIUS对终端进行签权并分配IPv6地址或者地址前缀，以及其他参数，如QoS参数等，并将鉴权结果以及各项参数携带在“响应创建PDP上下文请求”消息中，发送给SGSN，由SGSN再向终端发送“接受激活PDP上下文请求”消息，将各参数配置传递给用户终端，从而完成PDP激活过程。
这一过程中，与IPv6相关的功能主要集中在IPv6地址请求/分配上。首先，终端在“激活PDP上下文请求”消息中需要携带请求地址类型为IPv6的信息；其次，系统要能够分配IPv6地址。如果系统采用GGSN本地地址池分配IPv6地址方式，那么GGSN需要支持IPv6地址池设置与分配，如果采用DHCP服务器或者RADIUS服务器要进行地址分配，那么就需要DHCP，RADIUS服务器支持IPv6。
（3）业务访问。在PDP之后，从终端到3G系统分组域的IPv6应用数据通道已经打开。如果终端访问3G系统外的业务服务器，就需要保持3G系统分组域与外部网络直到业务服务器之间的转发路径通畅，即3G系统分组域边界网关需要具备访问IPv6外部网络的路由与转发能力。通常的IPv6 3G应用解决方案中，GGSN作为3G分组域的对外网关要求具备双栈能力。
http://www.ccsa.org.cn/article_new/show_article.php?categories_id=ed654b09-9740-e715-cd70-44b1c0c816d4&amp;article_id=technic_8dab3dae-398c-beeb-f95a-451cbe3cbd7d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632aa463e6932736eee31f70f01c8929/" rel="bookmark">
			C&#43;&#43;树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++树的实现
STL里面没有提供容器树的模板实现，自已写一个：
Tree.h
//tree.h 头文件 #include &lt;list&gt; #include &lt;algorithm&gt; using namespace std; struct TreeNode; //定义一个结构体原型 classTree; //定义一个类原型 classIterator; //定义一个类原型 typedef list&lt;TreeNode*&gt; List; //重命名一个节点链表 TreeNode* clone(TreeNode*,List&amp;,TreeNode*);//Clone复制函数 struct TreeNode{ int_data; //数据 TreeNode* _parent; //父节点 List_children; //子节点 TreeNode(int,TreeNode*); //构造函数 void SetParent(TreeNode&amp;); //设置父节点 void InsertChildren(TreeNode&amp;); //插入子节点 }; classTree{ public: //下面是构造器和运算符重载 Tree(); //默认构造函数 Tree(constTree&amp;); //复制构造函数 Tree(constint); //带参数构造函数 Tree(constint,constlist&lt;Tree*&gt;&amp;);//带参数构造函数 ~Tree(); //析构函数 Tree&amp; operator=(constTree&amp;); //=符号运算符重载 bool operator==(constTree&amp;); //==符号运算符重载 bool operator!=(constTree&amp;); //!=符号运算符重载 //下面是成员函数 void Clear(); //清空 boolIsEmpty()const; //判断是否为空 intSize()const; //计算节点数目 intLeaves(); //计算叶子数 intRoot()const; //返回根元素 intHeight(); //计算树的高度 //下面是静态成员函数 static boolIsRoot(Iterator); //判断是否是根 static boolisLeaf(Iterator); //判断是否是叶子 static IteratorParent(Iterator); //返回其父节点 static intNumChildren(Iterator); //返回其子节点数目 //跌代器函数 Iteratorbegin(); //Tree Begin Iteratorend(); //Tree End friend classIterator; //Iterator SubClass private: list&lt;TreeNode*&gt; _nodes; //节点数组 list&lt;TreeNode*&gt;::iteratorLIt; //一个节点迭代器 intheight(TreeNode*); intlevel(TreeNode*,Iterator); }; //This is TreeSub Class Iterator classIterator{ private: Tree* _tree; //Tree data list&lt;TreeNode*&gt;::iterator_lit; //List Iterator public: Iterator(); //默认构造函数 Iterator(constIterator&amp;); //复制构造函数 Iterator(Tree*,TreeNode*); //构造函数 Iterator(Tree*,list&lt;TreeNode*&gt;::iterator);//构造函数 //运算符重载 void operator=(constIterator&amp;); //赋值运算符重载 bool operator==(constIterator&amp;); //关系运算符重载 bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632aa463e6932736eee31f70f01c8929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf51467422f473f4a855473b95cab5ed/" rel="bookmark">
			Java中this关键字的几种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 当成员变量和局部变量重名时，在方法中使用this时，表示的是该方法所在类中的成员变量。（this是当前对象自己）
如：public class Hello {
String s = "Hello";
public Hello(String s) {
System.out.println("s = " + s);
System.out.println("1 -&gt; this.s = " + this.s);
this.s = s;//把参数值赋给成员变量，成员变量的值改变
System.out.println("2 -&gt; this.s = " + this.s);
}
public static void main(String[] args) {
Hello x = new Hello("HelloWorld!");
System.out.println("s=" + x.s);//验证成员变量值的改变
}
} 结果为：s = HelloWorld!
1 -&gt; this.s = Hello
2 -&gt; this.s = HelloWorld!
s=HelloWorld!
在这个例子中，构造函数Hello中，参数s与类Hello的成员变量s同名，这时如果直接对s进行操作则是对参数s进行操作。若要对类Hello的成员变量s进行操作就应该用this进行引用。运行结果的第一行就是直接对构造函数中传递过来的参数s进行打印结果； 第二行是对成员变量s的打印；第三行是先对成员变量s赋传过来的参数s值后再打印，所以结果是HelloWorld!而第四行是主函数中直接打印类中的成员变量的值，也可以验证成员变量值的改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf51467422f473f4a855473b95cab5ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d7ef532333c0809ad532098b48144c/" rel="bookmark">
			修改表以及表字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用SQL语句添加删除修改字段 1.增加字段
alter table docdsp add dspcode char(200)
2.删除字段
ALTER TABLE table_NAME DROP COLUMN column_NAME
3.修改字段类型
ALTER TABLE table_name ALTER COLUMN column_name new_data_type
4.sp_rename 改名
更改当前数据库中用户创建对象（如表、列或用户定义数据类型）的名称。
语法
sp_rename [ @objname = ] 'object_name' ,
[ @newname = ] 'new_name'
[ , [ @objtype = ] 'object_type' ]
如：EXEC sp_rename 'newname','PartStock'
5.sp_help 显示表的一些基本情况
sp_help 'object_name' 如：EXEC sp_help 'PartStock'
6.判断某一表PartStock中字段PartVelocity是否存在
if exists (select * from syscolumns where id=object_id('PartStock') and name='PartVelocity') print 'PartVelocity exists' else print 'PartVelocity not exists'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d7ef532333c0809ad532098b48144c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e0a7c82d91dc406e7876d8e244a50d/" rel="bookmark">
			网路术语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B 捕捉 (Capture) 科来网络分析系统的主要功能之一，可以分解成四个步骤：监测跟踪，捕捉，分析和显示数据。 不启用 (Disable) 使设备或程序不能发挥作用。例如，如果您在硬件配置中禁用了某个设备，则当计算机使用该硬件配置时您将不能使用该设备。不启用设备可以释放分配给该设备的资源。 标记 (Flag) 标记，特征位具有两种稳定状态的一位或一系列位，在软件中表明单一信息。 报头 (Header) 包含目标地址，源地址，报文编号方式和其他信息的一个白文的开始部分。报头有助于指导报文沿着其路径传输。不同的协议通不同的方式实现报头。 本机 (Local) 网络中用户登录使用的本地主机。 Top C 超文本标识语言 (HTML) HTML (HyperText Markup Languge)是一种超文本标识语言，通过它可以往普通文档中加入一些特殊的标识符 (这些标识符具有一定的语法结构)。使生成的文档中还含有其他文档甚至图像、声音、动画等，从而成为超文本文档 (HyperText Document)。实际上超文本文档本身是不含有上述多媒体数据的，而是仅含有指向这些多媒体数据的指针，这种指针一般称为链接 (Link)，通过超文本文档方式，用户仅仅使用鼠标单击操作，就可以得到所要的文档，而不管该文档是何种类型 (变通文档、图像或声音等)，也不管它身居何处 (本机上、局域网上或求知的鞭国外机器上)。 存活时间 (TTL) Time to Live，IP报头中表示一个分组在多长时间内有效的一个字段。 Top D 带宽 (Bandwidth) 在模拟通讯中，给定范围内的最高和最低频率之差。例如，模拟电话线路可提供 3,000 Hz 的带宽，这个带宽就是它可以传输的最低频率 (300 Hz) 和最高频率 (3,300 Hz) 之差。在数字通讯中，带宽以每秒位数 (bps) 表示。 Delete方法 (Delete method) 删除方法要求源服务器删除被请求地址标志的资源。 对话框 (Dialog) 一种次要窗口，包含按钮和各种选项，通过它们可以完成特定命令或任务。 DNS 服务器 (DNS Server) 维护有关“域名系统”(DNS) 数据库和响应和解决 DNS 查询的服务。运行此服务的计算机也称为 DNS 服务器。 动态的主机配置协议 (DHCP) DHCP为Dynamic Host Configuration Protocol的缩写。 提供主机 IP 地址的动态租用配置、并将其他配置参数分发给合法网络客户端的 TCP/IP 服务协议。DHCP 提供了安全、可靠、简便的 TCP/IP 网络配置，能避免地址冲突，并且有助于保留网络上客户端 IP 地址的使用。 DHCP 使用客户端/服务器模型，通过这种模式，DHCP 服务器集中维持网络上使用的 IP 地址的管理。然后，支持 DHCP 的客户端就可以向 DHCP 服务器请求和租用 IP 地址，作为它们网络启动过程的一部分。 丢失的数据包 (Lost packets) 科来网络分析系统未能捕捉到的数据包。 对方主机 (Peer host) 通过端对端的网络技术，与当前主机不经过中继设备直接交换数据或服务另一台主机。 对方主机组 (Peer host groups) 通过端对端的网络技术，与当前主机不经过中继设备直接交换数据或服务其他主机组。。 端口 (Port) 计算机上与外部设备的连接点，数据通过端口输入或输出。 丢弃的数据包 (Rejected packets) 科来网络分析系统根据过滤器的设置而丢弃的数据包。 Top E 二进制 (Binary) 由两个阿拉伯数字0和1组成的一种固定数字系统。 Top F 防火墙 (Firewall) 防火墙是采用综合的网络技术设置在被保护网络和外部网络之间的 一道屏障，用以分隔被保护网络与外部网络系统防止发生不可预 测的、潜在破坏性的侵入。它是不同网络或网络安全域之间信息的 唯一出入口，象在两个网络之间设置了一道关卡，能根据企业的安 全政策控制出入网络的信息流，防止非法信息流入被保护的网络内， 且本身具有较强的抗***能力。它是提供信息安全服务，实现网络 和信息安全的基础设施。 FTP (File Transfer Protocol) 文件传送协议，是Internet上使用非常广泛的一种通信协议。它是由支持Internet文件传输的各种规则所组成的集合，这些规则使Internet用户可以把文件从一个主机拷贝到另一个主机上，因而为用户提供了极大的方便和收益。FTP通常也表示用户执行这个协议所使用的应用程序。 Put方法 (Put method) HTTP方法PUT就是要求服务器储存请求包中的实体。 范围 (Scope) 通过DHCP服务让客户机自动获得的IP地址范围。 范围浏览器 (Scope Explorer) 进行网络活动并被科来网络分析系统所监测到的计算机范围。 服务器 (Server) 通常，指为网络用户提供共享资源的计算机。 Top G 高速缓存 (Cache) 缓冲存储器计算机中央处理单元中的快速缓冲存储器。用于 DNS 和 WINS，用于远程主机的最近已解析名称的资源记录的本地信息存储。通常，高速缓存在计算机查询和解析名称被动态地创建。它也有助于优化解析被查询名称所需的时间。 过滤器 (Filter) 一种设备或程序，能够根据指定标准分离数据。 Get方法 (Get Method) 获取方法就是以实体方式得到由请求地址所指定资源的信息。获取方法允许被缓存的解析结果在不必经过不必要的数据传输就能进行应答，从而有助于降低网络负载。 工程 (Project) 范围广泛的任务。在科来网络分析系统中，一项工程是对捕捉任务设置和过滤的计划安排，同时也是捕捉到的数据的容器，可以保存到硬盘上以备将来之需。 广域网 (WAN) 即Wide Area Network，是将地理上分离的计算机、打印机及其他设备连接在一起的通讯网络。WWW 允许任何已连接的设备和网络上的其他设备交互。 Top H 缓存 (Buffer) 又称为缓冲区，用于临对存贮数据并以与接收时不同的速度传输数据的设备或区域。 Head方法 (Head Method) HTTP的Head方法，与Get方法完全一致，唯一的差别是服务器不能在应答包中包含主体 (message-body)，而且一定不能包含主体。使用这个方法，可以使得客户无需将资源下载回就可就以得到一些关于它的基本信息。这个方法常用来检查超链的可访问性以及资源最近有没有被修改。 HTTP (HyperText Transfer Protocol) 超文本传输协议，是WWW浏览器和WWW、服务器之间的应用层通信协议。HTTP协议是用于分布式协作超文本信息系统的、通用的、而向对象的协议。 互联网协议 (Internet Protocol) TCP/IP最低层的，负责端到端传输和长分组分割控制的协议。 会话 (Session) 在终端上工作的两个用户之间,在两台计算机之间或在用户和计算机之间的正在使用着的连接电路和数据传输活动。在科来网络分析系统中表示UDP会话。 Top I ICMP 互联网控制报文协议（Internet Control Message Protocol），TCP/IP中主要用于报告数据报传输错误的一种协议。 IP地址 (IP Address or IP number) IP Address (IP 地址)是Internet上主机地址的数字性型式，与主机的域名地址一一对应。IP地址是一个32位的二进制数，通常写成被句点分开的四个十进制数的形式，例如128．9．28．5和192．23．4．101等。某些网络选用直接的方法来组织IP地址，即一个大网络由许多计算机节点 (node)组成；而另一些网络则采用分层结构，即许多网络通过节点与主干网 (Backbone)相连接。因此，IP地址通常被分为 A、 B、C三类，这种分类法与IP地址中字节的使用方法相关。在实际应用中，可以根据具体情况选择使用IP地址的类型或格式。A、B和 C三类地址所能表示的范围分别是： A类：0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e0a7c82d91dc406e7876d8e244a50d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c2e1e2fcb71d726e9621debd68c226/" rel="bookmark">
			计算机会议排名（系列3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Computer Science Conference Ranking是目前知道的唯一一个持续做计算机会议排名更新和维护的站点，这里列出了Architecture / Hardware / High-Performance Computing / Tools / Operating Systems 方面的TOP57个会议，供参考。
Top 57 conferences are listed (421 considered): MICRO: Intl Symp on Microarchitecture (0.97)
OSDI: USENIX Operating Systems Design and Implementation (0.96)
SC/SUPER: ACM/IEEE Supercomputing Conference (0.96)
HPCA: IEEE Symp on High-Perf Comp Architecture (0.96)
ASPLOS: Architectural Support for Prog Lang and OS (0.95)
FCCM: IEEE Symposium on Field Programmable Custom Computing Machines (0.93)
ISCA: ACM/IEEE Symp on Computer Architecture (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88c2e1e2fcb71d726e9621debd68c226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b855cf574d2d6d3ce525b5032a9d75a1/" rel="bookmark">
			ADMA 2009 Call for Papers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A growing attention has been paid to the study, development and application of data mining. As a result there is an urgent need for sophisticated techniques and tools that can handle new fields of data mining, e.g. spatial data mining in the context of spatial-temporal characteristics, streaming data mining, and biomedical data mining. Our knowledge on data mining should also have to be expanded to new applications. The 5 th International Conference on Advanced Data Mining and Applications (ADMA2009) aims at bringing together the experts on data mining in the world, and provides a leading international forum for the dissemination of original research results in data mining, spanning applications, algorithms, software and systems, and different applied disciplines with potential in data mining.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b855cf574d2d6d3ce525b5032a9d75a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb22f542b49c5e093c7986a61dfcc350/" rel="bookmark">
			常用电平标准(TTL、CMOS、LVTTL、LVCMOS、ECL、PECL、LVPECL、RS232
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用电平标准(TTL、CMOS、LVTTL、LVCMOS、ECL、PECL、LVPECL、RS232 常用电平标准
现在常用的电平标准有TTL、CMOS、LVTTL、LVCMOS、ECL、PECL、LVPECL、RS232、RS485等，还有一些速度
比较高的LVDS、GTL、PGTL、CML、HSTL、SSTL等。下面简单介绍一下各自的供电电源、电平标准以及使用
注意事项。 TTL：Transistor-Transistor Logic 三极管结构。 Vcc：5V；VOH&gt;=2.4V；VOL&lt;=0.5V；VIH&gt;=2V；VIL&lt;=0.8V。 因为2.4V与5V之间还有很大空闲，对改善噪声容限并没什么好处，又会白白增大系统功耗，还会影响速度。
所以后来就把一部分“砍”掉了。也就是后面的LVTTL。 LVTTL又分3.3V、2.5V以及更低电压的LVTTL(Low Voltage TTL)。 3.3V LVTTL： Vcc：3.3V；VOH&gt;=2.4V；VOL&lt;=0.4V；VIH&gt;=2V；VIL&lt;=0.8V。 2.5V LVTTL： Vcc：2.5V；VOH&gt;=2.0V；VOL&lt;=0.2V；VIH&gt;=1.7V；VIL&lt;=0.7V。 更低的LVTTL不常用就先不讲了。多用在处理器等高速芯片，使用时查看芯片手册就OK了。 TTL使用注意：TTL电平一般过冲都会比较严重，可能在始端串22欧或33欧电阻； TTL电平输入脚悬空时是
内部认为是高电平。要下拉的话应用1k以下电阻下拉。TTL输出不能驱动CMOS输入。 CMOS：Complementary Metal Oxide Semiconductor PMOS+NMOS。 Vcc：5V；VOH&gt;=4.45V；VOL&lt;=0.5V；VIH&gt;=3.5V；VIL&lt;=1.5V。 相对TTL有了更大的噪声容限，输入阻抗远大于TTL输入阻抗。对应3.3V LVTTL，出现了LVCMOS，可以与3.3V
的LVTTL直接相互驱动。 3.3V LVCMOS： Vcc：3.3V；VOH&gt;=3.2V；VOL&lt;=0.1V；VIH&gt;=2.0V；VIL&lt;=0.7V。 2.5V LVCMOS： Vcc：2.5V；VOH&gt;=2V；VOL&lt;=0.1V；VIH&gt;=1.7V；VIL&lt;=0.7V。 CMOS使用注意：CMOS结构内部寄生有可控硅结构，当输入或输入管脚高于VCC一定值(比如一些芯片是0.7V)
时，电流足够大的话，可能引起闩锁效应，导致芯片的烧毁。 ECL：Emitter Coupled Logic 发射极耦合逻辑电路(差分结构) Vcc=0V；Vee：-5.2V；VOH=-0.88V；VOL=-1.72V；VIH=-1.24V；VIL=-1.36V。 速度快，驱动能力强，噪声小，很容易达到几百M的应用。但是功耗大，需要负电源。为简化电源，出现了
PECL(ECL结构，改用正电压供电)和LVPECL。 PECL：Pseudo/Positive ECL Vcc=5V；VOH=4.12V；VOL=3.28V；VIH=3.78V；VIL=3.64V LVPELC：Low Voltage PECL Vcc=3.3V；VOH=2.42V；VOL=1.58V；VIH=2.06V；VIL=1.94V ECL、PECL、LVPECL使用注意：不同电平不能直接驱动。中间可用交流耦合、电阻网络或专用芯片进行转换。
以上三种均为射随输出结构，必须有电阻拉到一个直流偏置电压。(如多用于时钟的LVPECL：直流匹配时用
130欧上拉，同时用82欧下拉；交流匹配时 用82欧上拉，同时用130欧下拉。但两种方式工作后直流电平都在1.95V左右。) 前面的电平标准摆幅都比较大，为降低电磁辐射，同时提高开关速度又推出LVDS电平标准。 LVDS：Low Voltage Differential Signaling 差分对输入输出，内部有一个恒流源3.5-4mA，在差分线上改变方向来表示0和1。通过外部的100欧匹配电
阻(并在差分线上靠近接收端)转换为±350mV的差分电平。 LVDS使用注意：可以达到600M以上，PCB要求较高，差分线要求严格等长，差最好不超过10mil(0.25mm)。
100欧电阻离接收端距离不能超过500mil，最好控制在300mil以内。 下面的电平用的可能不是很多，篇幅关系，只简单做一下介绍。如果感兴趣的话可以联系我。 CML：是内部做好匹配的一种电路，不需再进行匹配。三极管结构，也是差分线，速度能达到3G以上。只能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb22f542b49c5e093c7986a61dfcc350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1be694d4609541e19940a4104f07288/" rel="bookmark">
			.NET程序员要看的书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是一个菜鸟或者自认为初学者那么本文非常适合你；
不能说这30本书就是最佳组合，但是可以说这个组合不差；
本人曾博览群书，很多书重复，很多书讲的不适用，这些书都是目前书店可以买到的；
达到中级程序员以后怎么成为高级程序员就靠你自己了，而此时你已经有辨明是非的能力，这也就是本文的目的！
30本好书点评：
分4大方向（
html--Web的基础；
javascript--让网页动起来；
C#--程序；
数据
图中纵向；
5个时期（入门，基础，应用，提高，飞跃），图中横向；
一.入门
1.《HTML与CSS入门经典(第7版) 》HTML入门 点评：html语言的入门，由于html极其简单所以同类其他书也可代替，本书并非经典，本书摆在这里纯属占位！你可以用其他书代替。
2.《C#入门经典（第3版）》C#入门
点评：经典中的经典，个人认为是30本书里最重要的，虽然其他讲C#的好书也很多但大多1.0版的，很多在书店已经绝版，被《程序员》等机构评选为2006年最受读者喜爱的十大IT图书之一。
3.《精通SQL--结构化查询语言详解》SQL数据入门 点评：不能说很好，但也不差，感觉吃透全书也可以应付如常SQL语句了。
4.《专家门诊--SQL SERVER开发答疑200问》SQL数据入门
点评：好书，正好结合上本，可惜的是不是Sqlserver2005。
5.《SQL SERVER 2005基础教程》SQL数据入门
点评：书一般，不过还是很全的，和同类书比起来还是不错。
入门总结：这几本书学的快的话2个月，慢则数月，如果真的吃透基本上就打了很好的底子！当然不能说100%，很多东西还要后面的学习来发现不足，重新学习。作者http://blog.csdn.net/21aspnet/。
二.基础
6.《Programming ASP.NET中文版(第3版)》ASP.NET基础
点评：经典中的经典，全球经典，五年三版，权威著作，这本书是最最基础的ASP.NET入门书，讲的非常全涵盖所有基本面，每一个控件都细细说明，非常易懂，不过本书讲的难免有点杂，初学者看了难免云里雾里所以要下一本书提纲挈领，此书非看不可。
7.《ASP.NET 2.0经典教程--C#篇》ASP.NET基础
点评：经典，和上一本结合起来最好，本书讲大的方面，看了能让人明白asp.net分那几个步骤，不过唯一的缺陷就是不细，上一本正好补充，此书非看不可。
8.《C#高级编程（第4版)》C#基础
点评：好书却不经典，本书被吹嘘的神乎其神，被评选为2005年最权威的十大IT图书之一，2006年最受读者喜爱的十大IT图书之一，其实本书不过讲了一些其他书没有的内容而已，内容比较多而已，本书也是所有.NET书中字数最多的一本，蛮厚的，可以当作C#语法的提高，做参考书吧，不过总体而言写的还是可以。作者http://blog.csdn.net/21aspnet/
9.《JAVASCRIPT 权威指南（第四版）》Javascript基础
点评：好书却不经典，这本书也被吹嘘的神乎其神，其实后半部分全部是Javascript语法参考，感觉本书只能做参考书，讲语法还是可以的讲的还算深，内容也很详，不过看懂前半部分后来喜欢它的原因却变后半部分，和下一本结合就成更完美的参考书。
10.《WEB开发人员参考大全:最完整的HTML、CSS与JAVASCRIPT工具书 》Javascript,html,css基础
点评：好书，书如其名，作者是位老先生，经验很丰富，本书是每一位从事BS开发人员的必备参考书和上一本结合就更好了。
11.《SQLServer2005从入门与精通(应用技术基础) 》SQLServer基础
点评：好书，可以帮助读者对SQLServer增进了解，毕竟是微软出版社的，书中讲的知识都是开发人员必备的，例如聚合函数，嵌套事务，报表等等。
基础总结：这几本书学的估计要4个月了，慢的话半年都不一定学透，其实日后开发中用到的主要就是这个时候学的基础上综合应用，宁慢勿快！！！
三.应用
12.《JavaScript 高级程序设计》javascript应用
点评：经典，比《JAVASCRIPT 权威指南（第四版）》讲应用讲得多，有Ajax部分，作者希望大家能把javascript按面相对象的思想处理。
13.《圣殿祭司的ASP.NET 2.0开发详解——使用C#》asp.net应用
点评：好书，作者是台湾的，感觉台湾作者都有欧美风格，本书是专门针对2.0新增的部分，没有1.1部分，个人感觉这样对1.1的作者很好，只要看这本书就够了。
14.《ASP.NET 2.0高级编程(第4版)》asp.net应用
点评：好书，出到第4版了，和《C#高级编程（第4版)》有的一拼，也是大部头，讲的很全，不过不觉得有多少闪光的地方，权作参考书吧。
15.《Beginning C# Objects中文版——概念到代码》C#应用
点评：好书，讲C#怎么面向对象的还讲了UML以及建模的方法同时译者得水品很高。不会面向对象是很可怕的，当然光会面向对象也不够还要和重构设计模式极限编程结合。
16.《ASP.NET 2.0数据库入门经典（第4版）》ADO.NET应用
点评：鸡肋，可惜的是这本书是Beta版本但是出版社不知道出于什么原因没有写明Beta版本，而且代码是VB.NET，不过这本书讲数据操作ADO.NET还是很全的最起码让初学者明白个大概。正式版有E文的，大家自己找吧。
17.《SQL Server 2005数据库开发实战》SQLServer2005应用
点评：好书，作者是 章立民 老师，台湾4届MVP，想想当初本人就是看他书入门的，这是一本公认的很好入门书籍。作者http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1be694d4609541e19940a4104f07288/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b10e36e4cb4f2068de30836271a12cf/" rel="bookmark">
			Linux/Unix命令之ethtool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		description: ethtool - Display or change ethernet card settings（ethtool 是用来显示和更改网卡设置的工具 1 ethtool 显示网络端口设置功能； 这个功能比较好办。就是ethtool 后面直接接网絽接口就行；比如下面的例子； [root@localhost ~]# ethtool eth0
Settings for eth0:
Supported ports: [ TP MII ]
Supported link modes: 10baseT/Half 10baseT/Full
100baseT/Half 100baseT/Full
Supports auto-negotiation: Yes
Advertised link modes: 10baseT/Half 10baseT/Full
100baseT/Half 100baseT/Full
Advertised auto-negotiation: No 注：自动协商关闭
Speed: 100Mb/s 注：速度 100Mb
Duplex: Full 注：全双工
Port: MII
PHYAD: 32
Transceiver: internal
Auto-negotiation: off
Supports Wake-on: pumbg
Wake-on: d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b10e36e4cb4f2068de30836271a12cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92623290e8ccf82f9d465cd0fc7989e8/" rel="bookmark">
			一位Erlang程序员的自白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rel="File-List" href="file:///C:%5CWindows%5CTEMP%5Cmsohtmlclip1%5C01%5Cclip_filelist.xml"&gt; rel="Preview" href="file:///C:%5CWindows%5CTEMP%5Cmsohtmlclip1%5C01%5Cclip_preview.wmf"&gt; rel="themeData" href="file:///C:%5CWindows%5CTEMP%5Cmsohtmlclip1%5C01%5Cclip_themedata.thmx"&gt; rel="colorSchemeMapping" href="file:///C:%5CWindows%5CTEMP%5Cmsohtmlclip1%5C01%5Cclip_colorschememapping.xml"&gt; Erlang不能错过的盛宴 （快步进入Erlang的世界）
作者：成立涛 (litaocheng@gmail.com) 作为程序员，我们曾经闻听很多“业界动态”，“技术革新”，曾经接触很多“高手箴言”，“权威推荐”。这些正确与否，都已成过去！
现在，让我们迎接Erlang盛宴！
一、经历 2007年11月在koders.com搜索代码时，发现*.erl格式的源文件，感叹开发语言的花样百出，此时，我觉得erlang是一个丑陋的小家伙，看名字就没有对它提起多少兴趣。
2008年初的时候，公司的项目开发中，我有缘认识了ejabberd，一个采用Erlang开发的开源jabber服务器。我开始为其诱人的特性所倾倒。是时候认真看看Erlang到底什么样了！
2008年4月，通过各种资料的搜集，了解，我决定系统的学习Erlang。
今天，通过4个月的认真学习，我已经熟悉了Erlang，已经在使用Erlang开发项目。作为C++程序员，我不敢妄自使用“熟悉”，“精通”之类的字眼，但是对于Erlang我可以很负责任的说：Erlang很巧，很强大！
二、困惑 面对一个新的事务，我们本性都会充满好奇，可是作为程序员，很多时候对于新的语言我们都充满了抵触：这个新东西值得学习么？它会不会让我抛弃旧爱？它文档丰富么？是不是很难理解？它的前景如何?······相信大家跟我有一样的苦恼。
但是，请听我说！我们是程序员，我们走在技术革新的最前沿。用户的产品，体验是通过我们来产生！我们不能畏缩不前，我们的固步自封，就是我们的公司，乃至整个行业的停滞不前！口号可能有些响亮，但是认真思考，我相信朋友们一定有所感悟。
三、Erlang是什么 Erlang是什么是我们最先要面对的问题，只有清楚了它是什么，我们才能做出我们的决定。可见这个问题的重要性，它决定了很多读者是否会继续看下去！非常紧张。
Erlang最初是爱立信为开发电信相关产品而产生。
Erlang是一种面向并发(Concurrency Oriented)，面向消息（Message Oriented）的函数式(Functional)编程语言。
面向并发说明Erlang支持大规模的并发应用，我们可以在应用中处理成千上万的并发，而不相互影响。面向消息，其实是为并发服务！我们应该都熟悉多线程，熟悉加锁解锁操作，熟悉可能出现的资源竞争与死锁。在Erlang的世界里，我们可以将轻轻的抹去这些令人苦恼的词汇。Erlang的世界，每个处理都是独立的个体，他们之间的交互仅仅靠消息！因此不会有死锁，不会有那种痛苦的编程经历。
Erlang中一个非常重要的名词：Process，也就是我们前面提到的“个体”。它不是我们操作系统中的进程，也不是线程。它是Erlang提供给我们的超级轻量的进程。为了适应大规模并发的特性，Process需要能够快速创建，快速销毁。Process之间通信的唯一方法就是消息，我们只要知道一个Process的名字即pid，就可以向其发送消息。Process也可以在任何时候，接收消息。我们这样做只有一个目的：让我们的系统更加简单，用一种朴素的做法，实现一个高效的语言。
Erlang是种函数式编程语言，对此我没有很深刻的理解，最明显的特征就是，Erlang中到处都是函数，函数构成了我们的产品的主体，把这些函数放到一个个的Process中去，让他们运行起来，那么就组成了我们朝气蓬勃的产品。
Erlang支持对数据的位操作，拥有丰富的数据持久化机制。
同时需要说明的是Erlang内建垃圾回收机制（GC）。
四、Erlang的语言特性 1.简单小巧 Erlang中只有8种基本的数据类型：
integer、float、atom、reference、fun、port、pid、bitstring
同时提供2种复合结构：tuple，list，这就是Erlang的所有数据类型。
2.模式匹配 在Erlang的函数中，某些语法中，我们可以使用Pattern匹配，这是一个非常好的特性，我们可以让代码自己去决定如何执行 ：
比如，我们定义一个函数，其告诉我们某种水果的价格:
price(apple) -&gt; 2.0;
price(banana) -&gt; 1.2.
我们随后调用 price(Fruit)，会根据Fruit变量的内容返回具体的价格。这样做的好处就是节省了我们的代码量，我们不用if...else…或者switch…case的来伺候了。也便于代码的扩展：加一个新的水果品种，我们只需要加一行就可以了。
学习Erlang一个非常重要的内容就是模式匹配，但是请不要混淆，这个匹配和正则表达式没有任何干系。
3.变量单次赋值 这个是一个匪夷所思的特性，变量竟然只能单次赋值！是的Erlang中变量一旦绑定某个数值以后，就不能再次绑定，这样做的好处是便于调试出错（更深层次的原因是Erlang为并发设计，如果变量可以修改，那么就涉及到资源的加锁解锁等问题），当发生错误时，某个变量是什么就永远是什么，不用顺藤摸瓜的查找谁修改过它，省了好多事情。唯一的麻烦就是需要一个信的变量时，你必须再为它想一个名字。
4.丰富的libs Erlang中提供丰富的libs
stdlib中包含大量的数据结构如lists，array，dict，gb_sets，gb_trees，ets，dets等
mnesia提供一个分布式的数据库系统
inets提供ftp client，http client/server，tftp client/server
crypto 提供加密解密相关函数，基于openssl相关实现
ssl 实现加密socket通信，基于openssl实现
ssh 实现ssh协议
xmerl 实现XML相关解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92623290e8ccf82f9d465cd0fc7989e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4214bef8e3c0e837e2de1bd2207667ab/" rel="bookmark">
			深入解析UUID及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址: http://www.blogjava.net/feelyou/archive/2008/10/14/234320.html 讨论UUID的定义、分类、应用及生成工具。 什么是UUID？
UUID是Universally Unique Identifier的缩写，它是在一定的范围内（从特定的名字空间到全球）唯一的机器生成的标识符。UUID具有以下涵义：
经由一定的算法机器生成为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。
非人工指定，非人工识别UUID是不能人工指定的，除非你冒着UUID重复的风险。UUID的复杂性决定了“一般人“不能直接从一个UUID知道哪个对象和它关联。
在特定的范围内重复的可能性极小UUID的生成规范定义的算法主要目的就是要保证其唯一性。但这个唯一性是有限的，只在特定的范围内才能得到保证，这和UUID的类型有关（参见UUID的版本）。
UUID是16字节128位长的数字，通常以36字节的字符串表示，示例如下：
3F2504E0-4F89-11D3-9A0C-0305E82C3301
其中的字母是16进制表示，大小写无关。
GUID（Globally Unique Identifier）是UUID的别名；但在实际应用中，GUID通常是指微软实现的UUID。
UUID的版本
UUID具有多个版本，每个版本的算法不同，应用范围也不同。
首先是一个特例－－Nil UUID－－通常我们不会用到它，它是由全为0的数字组成，如下：
00000000-0000-0000-0000-000000000000
UUID Version 1：基于时间的UUID
基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。
UUID Version 2：DCE安全的UUID
DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。
UUID Version 3：基于名字的UUID（MD5）
基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。
UUID Version 4：随机UUID
根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。
UUID Version 5：基于名字的UUID（SHA1）
和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。
UUID的应用
从UUID的不同版本可以看出，Version 1/2适合应用于分布式计算环境下，具有高度的唯一性；Version 3/5适合于一定范围内名字唯一，且需要或可能会重复生成UUID的环境下；至于Version 4，我个人的建议是最好不用（虽然它是最简单最方便的）。
通常我们建议使用UUID来标识对象或持久化数据，但以下情况最好不使用UUID：
映射类型的对象。比如只有代码及名称的代码表。人工维护的非系统生成对象。比如系统中的部分基础数据。对于具有名称不可重复的自然特性的对象，最好使用Version 3/5的UUID。比如系统中的用户。如果用户的UUID是Version 1的，如果你不小心删除了再重建用户，你会发现人还是那个人，用户已经不是那个用户了。（虽然标记为删除状态也是一种解决方案，但会带来实现上的复杂性。）
UUID生成器
我没想着有人看完了这篇文章就去自己实现一个UUID生成器，所以前面的内容并不涉及算法的细节。下面是一些可用的Java UUID生成器：
Java UUID Generator (JUG)：开源UUID生成器，LGPL协议，支持MAC地址。UUID：特殊的License，有源码。Java 5以上版本中自带的UUID生成器：好像只能生成Version 3/4的UUID。
此外，Hibernate中也有一个UUID生成器，但是，生成的不是任何一个（规范）版本的UUID，强烈不建议使用。
延伸阅读
UUID规范：rfc4122
DCE 1.1中的UUID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4214bef8e3c0e837e2de1bd2207667ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1cd09db76355dd2f42a1e1135d9c00/" rel="bookmark">
			PhotoshopCS中的CS是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CS是版本名称.在几年前都流行使用数字表示,去年开始使用文字表示 比如flash8他的代号就是ball. Adobe “CS”的含义Adobe公司2003年继Photoshop7.0版本之后推出了CS版本，至此，不再延续数字的排序方式，CS是英文Creative Suite的缩写,Adobe Creative Suite是一个媒体制作的软件工具包，Photoshop CS是其中最重要的组成之一．开发的新功能让设计更加便捷，图象质量得到提高，并以专业的高效率管理文件． CS,是Creative Suite的缩写，意思是创意组件(套件，套装)。 Adobe 公司把Photoshop® CS, Illustrator® CS, InDesign® CS, GoLive® CS, and Acrobat® 7.0 Professional software with new Version Cue® CS, Adobe Bridge和Adobe Stock Photos所有这些软件组成了一个创意设计的环境，并命名为Creative Suite(创意组件),这样，在给所有这些软件的新版本命名时都加上了后缀CS.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61754f742a3de454b15e87608913fcb6/" rel="bookmark">
			Asp.net的身份验证有有三种，分别是&#34;Windows | Forms | Passport&#34;，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Asp.net的身份验证有有三种，分别是"Windows | Forms | Passport"，其中又以Forms验证用的最多，也最灵活。
Forms 验证方式对基于用户的验证授权提供了很好的支持，可以通过一个登录页面验证用户的身份，将此用户的身份发回到客户端的Cookie，之后此用户再访问这个web应用就会连同这个身份Cookie一起发送到服务端。服务端上的授权设置就可以根据不同目录对不同用户的访问授权进行控制了。
问题来了，在实际是用中我们往往需要的是基于角色，或者说基于用户组的验证和授权。对一个网站来说，一般的验证授权的模式应该是这样的：根据实际需求把用户分成不同的身份，就是角色，或者说是用户组，验证过程不但要验证这个用户本身的身份，还要验证它是属于哪个角色的。而访问授权是根据角色来设置的，某些角色可以访问哪些资源，不可以访问哪些资源等等。要是基于用户来授权访问将会是个很不实际的做法，用户有很多，还可能随时的增减，不可能在配置文件中随时的为不断增加的新用户去增加访问授权的。 下面大概的看一下Forms的过程。
Forms身份验证基本原理：
一 身份验证
要采用Forms身份验证，先要在应用程序根目录中的Web.config中做相应的设置:
??&lt;authentication mode="Forms"&gt;
???&lt;forms name=".ASPXAUTH" loginUrl="/Default.aspx" protection="All" timeout="30" path="/" /&gt;
??&lt;/authentication&gt;
其中&lt;authentication mode= "forms"&gt; 表示本应用程序采用Forms验证方式。
1. &lt;forms&gt;标签中的name表示指定要用于身份验证的 HTTP Cookie。默认情况下，name 的值是 .ASPXAUTH。采用此种方式验证用户后,以此用户的信息建立一个FormsAuthenticationTicket类型的身份验证票,再加密序列化为一个字符串,最后将这个字符串写到客户端的name指定名字的Cookie中.一旦这个Cookie写到客户端后,此用户再次访问这个web应用时会将连同Cookie一起发送到服务端,服务端将会知道此用户是已经验证过的. 再看一下身份验证票都包含哪些信息呢,我们看一下FormsAuthenticationTicket类:
CookiePath： 返回发出 Cookie 的路径。注意，窗体的路径设置为 /。由于窗体区分大小写，这是为了防止站点中的 URL 的大小写不一致而采取的一种保护措施。这在刷新 Cookie 时使用
Expiration： 获取 Cookie 过期的日期/时间。
IsPersistent： 如果已发出持久的 Cookie，则返回 true。否则，身份验证 Cookie 将限制在浏览器生命周期范围内。
IssueDate： 获取最初发出 Cookie 的日期/时间。
Name： 获取与身份验证 Cookie 关联的用户名。
UserData ：获取存储在 Cookie 中的应用程序定义字符串。
Version： 返回字节版本号供将来使用。
2. &lt;forms&gt;标签中的loginUrl指定如果没有找到任何有效的身份验证 Cookie，为登录将请求重定向到的 URL。默认值为 default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61754f742a3de454b15e87608913fcb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba38c8f8c775f5d19fdb224d9f5b1c5/" rel="bookmark">
			如何定制对话框中的回车键（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于对话框的程序中，每次按下回车键时，程序都退出。去掉按钮的 BS_DEFPUSHBUTTON 属性并重写OnOK函数也没用。那么如何定制回车键的行为呢？这个问题很easy，但是要说明白，却要费点时间。 这个问题在Windows的开发中由来已久，对于初学者来说，这是个恼人的问题，幸运的是，人们找到了多种解决这个问题的方案。本文将告诉你定制回车键行为的方法。 如果你想要disable回车键，最简单的方法是重载OnOK函数，这固然是个不坏的主意，但如果你重载OnOK，让它什么事情也不干，那麽当用户用鼠标按下回车键想真正做些什么的时候怎么办呢？你可以改变回车键的ID，如：ID_MY_OK，并写一个调用EndDialog的处理器，这个方法虽然也能行得通，但显得有点不专业。 另外一种方法是disable回车键的“默认”属性。这也是本文开始所提出的方法，之所以没有成功，是因为仅仅uncheck 回车键的 BS_DEFPUSHBUTTON 属性是不够的，你可以利用Spy++仔细地观察控制和实验就能发现回车键仍然我行我素发送退出消息。 问题出在哪呢？你必须区分OK键和回车键，你可以写一个OnOK处理器调用GetCurrentMessage函数获取最后发送的消息，应该是WM_COMMAND，再检查WPARAM的低位字（low-order word）看看命令来自何处。 要解决问题，必须搞清楚背后所发生的一切，在Spy++中可以看到，当用户按下回车键时，Windows发送一个特殊的WM_GETDEFID消息来获得缺省的命令ID，Windows再将它作为WM_COMMAND发送。所以，你要做的就是重载WM_GETDEFID消息，在有关Windows的文档中是这样描述WM_GETDEFID返回值的：“如果有缺省得按钮，则返回值的高位字包含DC_HASDEFID，低位字包含控制的标识符。否则，返回值是零。” 根据这段描述，假设如果没有缺省得按钮，则返回值应该是零。如果想要disable缺省得ID，必须在高位字中返回DC_HASDEFID。 BEGIN_MESSAGE_MAP(CMyDlg, CDialog) ON_MESSAGE(DM_GETDEFID, OnGetDefID) ... END_MESSAGE_MAP() LRESULT CMyDlg::OnGetDefID(WPARAM wp, LPARAM lp) { return MAKELONG(0,DC_HASDEFID); } 因为MFC没有对应DM_GETDEFID的宏，你必须使用通用的ON_MASSAGE宏。这样用户可以随意按回车键，但什么事都不会发生。上面的做法是解决了按回车键程序退出的问题。但是又产生了另外一个问题：如果想要回车键做些事情怎么办呢？有一些人曾经问过如何将回车键映射到TAB键，既按下回车键就象按下TAB键一样-也就是说输入焦点移动到下一个对话框控制。这需要做一些工作才行，但最简单的方式是使用加速键。许多程序员试图用OnChar，我会对他们说：No，no，no! OnChar是一个低级趣味的东西，你应该想方设法避免它，更糟的还有WM_KEYDOWN，WM_KEYUP之类的东西。谁能处理这些东西？OnChar可以用来限制允许输入编辑框的字符，如：数字，字母等。如果想要将一个键映射到一个命令，加速键才是最好的方法。 在本文的例子为VK_RETURN创建了一个加速键，将它映射到命令ID_MY_ENTER，并写一个命令处理器来做你想做的事情。 BEGIN_MESSAGE_MAP(CMyDlg, CDialog) ON_COMMAND(ID_MY_ENTER, OnMyEnter) ...... END_MESSAGE_MAP() void CMyDlg::OnMyEnter() { NextInTabOrder(); } 下图是本文例子的对话框和代码，代码中的NextInTabOrder是实际起作用的函数。它使用GetNextDlgTabItem来获得Tab顺序的下一个控制焦点。 如果你细心的话会发现另外一个还没有得到解决的问题，那就是在MFC对话框不自动处理加速键，你必须自己编写代码来做这件事情。为了理解弄清楚这是为什么，让我们回首Windows开发的历程，在使用C和原始的Windows API的年代，每一个Windows程序中都有一个叫做消息泵的中枢循环： while (GetMessage(...)) { TranslateMessage(...); DispatchMessage(...); } 在这里细节不是重要的，重要的是消息并不到达程序的流程，你必须请求消息。这是一种人为的非抢先式多任务方法，这种方法通过每一个任务精诚协作来仿造多任务环境，随着增加的功能越来越多，有人想到了加速键表的主意，这个表用来映射按键和命令IDs。为了实现这个目的，他们发明了一个叫TranslateAccelerator的函数。现在这个消息泵变成了如下的样子： while (GetMessage(...)) { if (TranslateAccelerator(hAccel...)) { // handled, continue looping } else { TranslateMessage(...); DispatchMessage(...); } } hAccel是个加速键表句柄，在这里细节同样不是重要的，重要的是如何利用加速键表，也就是要有一个专门的函数将按键消息解释为WM_COMMAND消息。TranslateAccelerator寻找WM_KEYDOWN，WM_CHAR，WM_KEYUP序列与表中键值匹配的字符。如果找到，它插入一条WM_COMMAND到消息队列，在消息队列中的命令ID可以是加速键表定义的任何入口。这样你只要设置加速键表（在资源中）并记住调用对应的函数TranslateAccelerator，就什么都不用担心了。 时间转眼间进入了21世纪，随着C++和MFC的日臻成熟，现在几乎整个消息循环（但不是全部）都被隐藏到了MFC中，为了能让任何窗口都有机会获得一点消息泵的行为，MFC提供了一个专门的虚函数PreTranslateMessage，如果你有足够的勇气去探究CWinThread中的消息处理机制的话，你会遇到类似如下的代码： // 简化后的 CWinThread while (GetMessage(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba38c8f8c775f5d19fdb224d9f5b1c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc21e8d9c48c18dde50a916267c694e/" rel="bookmark">
			个人工具收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca35fb1d2acc89162b7bac95fbd354bf/" rel="bookmark">
			如何解决负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负载均衡其实是一项常用的技术，只不过，它经常处于后台，现在，让我们深入了解一下负载均衡，例如服务器负载均衡、网络负载均衡等，看它是如何解决企业应用网络流量瓶颈问题的。 Internet 的规模每一百天就会增长一倍，客户希望获得7天24小时的不间断可用性及较快的系统反应时间，而不愿屡次看到某个站点“Server Too Busy”及频繁的系统故障。 网络的各个核心部分随着业务量的提高、访问量和数据流量的快速增长，其处理能力和计算强度也相应增大，使得单一设备根本无法承担。在此情况下，如果扔掉现有设备去做大量的硬件升级，这样将造成现有资源的浪费，而且如果再面临下一次业务量的提升，这又将导致再一次硬件升级的高额成本投入，甚至性能再卓越的设备也不能满足当前业务量的需求。于是，负载均衡机制应运而生。 负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。 本文所要介绍的负载均衡技术主要是指在均衡服务器群中所有服务器和应用程序之间流量负载的应用，目前负载均衡技术大多数是用于提高诸如在Web服务器、FTP服务器和其它关键任务服务器上的Internet服务器程序的可用性和可伸缩性。 负载均衡技术分类 目前有许多不同的负载均衡技术用以满足不同的应用需求，下面从负载均衡所采用的设备对象、应用的网络层次（指OSI参考模型）及应用的地理结构等来分类。 软/硬件负载均衡 软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。 软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。 硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。 负载均衡器有多种多样的形式，除了作为独立意义上的负载均衡器外，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将这一功能集成到PC中，一块连接到Internet上，一块连接到后端服务器群的内部网络上。 一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。 本地/全局负载均衡 负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是指对本地的服务器群做负载均衡，全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。 本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。 全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。 全局负载均衡有以下的特点： 实现地理位置无关性，能够远距离为用户提供完全的透明服务。 除了能避免服务器、数据中心等的单点失效，也能避免由于ISP专线故障引起的单点失效。 解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量。 不同网络层次上的网络负载均衡 针对网络上负载过重的不同瓶颈所在，从网络的不同层次入手，我们可以采用相应的负载均衡技术来解决现有问题。 随着带宽增加，数据流量不断增大，网络核心部分的数据接口将面临瓶颈问题，原有的单一线路将很难满足需求，而且线路的升级又过于昂贵甚至难以实现，这时就可以考虑采用链路聚合（Trunking）技术。 链路聚合技术（第二层负载均衡）将多条物理链路当作一条单一的聚合逻辑链路使用，网络数据流量由聚合逻辑链路中所有物理链路共同承担，由此在逻辑上增大了链路的容量，使其能满足带宽增加的需求。 现代负载均衡技术通常操作于网络的第四层或第七层。第四层负载均衡将一个Internet上合法注册的IP地址映射为多个内部服务器的IP地址，对每次TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛的应用，一个目标地址是服务器群VIP（虚拟IP，Virtual IP address）连接请求的数据包流经交换机，交换机根据源端和目的IP地址、TCP或UDP端口号和一定的负载均衡策略，在服务器IP和VIP间进行映射，选取服务器群中最好的服务器来处理连接请求。 第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第七层负载均衡技术通过检查流经的HTTP报头，根据报头内的信息来执行负载均衡任务。 第七层负载均衡优点表现在如下几个方面： 通过对HTTP报头的检查，可以检测出HTTP400、500和600系列的错误信息，因而能透明地将连接请求重新定向到另一台服务器，避免应用层故障。 可根据流经的数据类型（如判断数据包是图像文件、压缩文件或多媒体文件格式等），把数据流量引向相应内容的服务器来处理，增加系统性能。 能根据连接请求的类型，如是普通文本、图象等静态文档请求，还是asp、cgi等的动态文档请求，把相应的请求引向相应的服务器来处理，提高系统的性能及安全性。 第七层负载均衡受到其所支持的协议限制（一般只有HTTP），这样就限制了它应用的广泛性，并且检查HTTP报头会占用大量的系统资源，势必会影响到系统的性能，在大量连接请求的情况下，负载均衡设备自身容易成为网络整体性能的瓶颈。 负载均衡策略深入剖析 在实际应用中，我们可能不想仅仅是把客户端的服务请求平均地分配给内部服务器，而不管服务器是否宕机。而是想使Pentium III服务器比Pentium II能接受更多的服务请求，一台处理服务请求较少的服务器能分配到更多的服务请求，出现故障的服务器将不再接受服务请求直至故障恢复等等。 选择合适的负载均衡策略，使多个设备能很好的共同完成任务，消除或避免现有网络负载分布不均、数据流量拥挤反应时间长的瓶颈。在各负载均衡方式中，针对不同的应用需求，在OSI参考模型的第二、三、四、七层的负载均衡都有相应的负载均衡策略。 负载均衡策略的优劣及其实现的难易程度有两个关键因素：一、负载均衡算法，二、对网络系统状况的检测方式和能力。 考虑到服务请求的不同类型、服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题，为了更加合理的把负载分配给内部的多个服务器，就需要应用相应的能够正确反映各个服务器处理能力及网络状态的负载均衡算法： 轮循均衡（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。 权重轮循均衡（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器A的权值被设计成1，B的权值是3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。 随机均衡（Random）：把来自网络的请求随机分配给内部中的多个服务器。 权重随机均衡（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。 响应速度均衡（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。 最少连接数均衡（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。 处理能力均衡：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。 DNS响应均衡（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。 尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检测方式和能力： Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致检测出网络及服务器上的操作系统是否正常，对服务器上的应用服务检测就无能为力了。 TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来判断服务是否正常。 HTTP URL侦测：比如向HTTP服务器发出一个对main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca35fb1d2acc89162b7bac95fbd354bf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/512/">«</a>
	<span class="pagination__item pagination__item--current">513/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/514/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>