<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee85fc21a62efe62f766981673a389dc/" rel="bookmark">
			elsevier官网提交论文BUG（! LaTeX Error: Mismatched LaTeX support files detected.(LaTeX) Loading ‘expl3.st）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下：
2023年3月期间，elsevier提交论文总是出BUG，问题在于elsarticle.cls文件不兼容，解决方法是提交19年之前的elsarticle.cls，且所有附件都以manuscript形式提交，需要提交文件包括tex、bib、bbl、png、cls. 如果第一次仍然编译不出来，显示图片不能识别，第二次不做改变任何，显示编译成功.
方法一： 报错原因： 投稿系统自带的 TeXLive 软件未更新 fmt，出现 expl3 与 LaTeX3 匹配兼容问题。
解决方案： 使用老版本的 elsarticle.cls 替换当前文件，绕过对 expl3 的依赖。
可用 elsarticle.cls 版本下载：https://github.com/yaoyz96/elsarticle/tree/main/elsarticle.cls
我用的是09年的elsarticle.cls，见下面链接.
09年elsarticle.cls, 提取码: 8vki
方法二：
这是本地能编译成果，但上传系统后编译报错。（个人感觉是自动生成的本地pdflatex-dev格式与系统不匹配，因此需要删除后重新生成。）
先cmd，找到本地 的pdflatex-dev格式，需要执行以下命令
kpsewhich --all --engine=pdftex pdflatex.fmt 检查下本地用户下的 这个文件 pdflatex.fmt 是不是最近生成的，如果是就删除，然后重新创建
（2） 继续在 cmd 中，执行以下命令，生成样式
使用 fmtutil-user --all 而不是 fmtutil-sys --all 会运行一分钟左右，结束后出现 successfully 即可。
然后在本地再重新进行编译，再将编译过后的 .tex文件上传系统，就可以编译成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98024516e3f39b0c888e9cc16f9f51f/" rel="bookmark">
			Elsevier（爱思唯尔）LaTex 模板详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
Elsevier 模板的使用
1. 通用模板使用说明
1.1 文件说明
1.2 模板说明
2. 复杂版式模板使用说明
2.1 文件说明
2.2 模板说明
2.3 其他修改
2.4 常见报错解决
先放出本文的核心产出：
通用模板，无报错可直接编译：https://github.com/yaoyz96/elsarticle
复杂版式模板，无报错可直接编译：https://github.com/yaoyz96/els-cas-templates
以上模板已经过修改，可以直接运行，替换自己需要的内容即可。
Elsevier 模板的使用
官方指南：Latex Instructions
通用 Elsevier 模板下载地址：elsarticle-template.zip
复杂版式 Elsevier 模板下载地址：
官方的介绍中包含了一些链接，其中：
【1】从 CTAN 下载的模板文件就是本文最开始提供的 通用 Elsevier 模板 elsarticle-template.zip(https://www.elsevier.com/__data/assets/file/0007/56842/elsarticle-template.zip)（顺便说一句，第 1 段话的第 3 个可点击链接 “here” 内容其实也是完全一样的，只是压缩包名称不同）。
【2】elsarticle documentation 则是 elsarticel.cls 类文件的说明文档，一些细节都可以从中查看。从文档中可以看到，elsarticle.cls 类文件基于 article.cls 类文件构建，且作者不需要下载额外的 package 来支持 elsarticle.cls 的使用。【3】els-cas-template.zip 则是 Elsevier 提供的 复杂版式模板，相比通用模板，这个模板和最终发表文章的排版大体相同。
1. 通用模板使用说明 1.1 文件说明 Elsevier 通用模板 elsarticle-template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98024516e3f39b0c888e9cc16f9f51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433dc4fa32716f3705de064d159c3ceb/" rel="bookmark">
			【python学习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://community.modelscope.cn/63a01db2dacf622b8df91397.html?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-3-83240024-blog-122627561.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-3-83240024-blog-122627561.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5
本文简述为何使用numpy，以及numpy常用基本操作。
1.为何使用numpy Python中提供了list容器，可以当作数组使用。但列表中的元素可以是任何对象，因此列表中保存的是对象的指针，这样一来，为了保存一个简单的列表[1,2,3]。就需要三个指针和三个整数对象。对于数值运算来说，这种结构显然不够高效。
Python虽然也提供了array模块，但其只支持一维数组，不支持多维数组(在TensorFlow里面偏向于矩阵理解)，也没有各种运算函数。因而不适合数值运算。
NumPy的出现弥补了这些不足。
2.numpy常用基本操作 参考https://community.modelscope.cn/63a01db2dacf622b8df91397.html?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-3-83240024-blog-122627561.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-3-83240024-blog-122627561.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53b88586fb3b6e88b9815a2f48b9fbe/" rel="bookmark">
			Arch 安装 Visual Studio Code（支持Wayland）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装vscode在Wayland下模糊的解决方法在Wayland下无法使用输入法的解决方法 安装vscode 虽然官网下载一般是首先，但是比较复杂，所以推荐使用AUR：
yay -S visual-studio-code-bin 然后就可以用了：
在图中可能看不出来，其实这个图在我的高分辨率的屏是非常模糊的。
在Wayland下模糊的解决方法 （这才是本文的重点）
在网上查找，对这个问题的中文说明非常少，但是在ArchWiki上有解释：Visual Studio Code - ArchWiki。其实就是Electron在Wayland下的通用问题（vscode是基于Electron开发的）。
在ArchWiki上也有解决方案：Wayland - ArchWiki
简单地说就是要加两个参数：
--enable-features=WaylandWindowDecorations --ozone-platform-hint=auto 为了实现开始菜单和右键菜单打开的vscode显示正确，需要修改/usr/share/applications/code.desktop，在每个Exec=中加上这两个参数：
Exec=/usr/bin/code --ozone-platform-hint=auto --enable-features=WaylandWindowDecorations --unity-launch %F Exec=/usr/bin/code --ozone-platform-hint=auto --enable-features=WaylandWindowDecorations --new-window %F 然后就正常了。
还有另一种更直接更有效的方法，直接在文件中配置，可以对任何方式启动的code生效（包括从命令行启动）：
在~/.config/code-flags.conf中加上两行：
--enable-features=WaylandWindowDecorations --ozone-platform-hint=auto 就可以全局生效了。
在Wayland下无法使用输入法的解决方法 和上一节“在Wayland下模糊的解决方法”类似，需要再加一个参数：
--enable-wayland-ime 直接在命令行使用（配置.desktop文件同理）：
code --enable-wayland-ime # 如果加上对模糊的处理 code --enable-features=WaylandWindowDecorations --ozone-platform-hint=auto --enable-wayland-ime 配置~/.config/code-flags.conf文件：
--enable-wayland-ime # 如果加上对模糊的处理 --enable-features=WaylandWindowDecorations --ozone-platform-hint=auto 注：如果看过本博客的之前的版本，用的是~/.config/electron-flags.conf，但是目前测试无效，未知原因，但是在~/.config/code-flags.conf中添加参数实测有效（即所有的参数都加在~/.config/code-flags.conf中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f66e4afa5cc4d8b1d105e3e8b5ff53/" rel="bookmark">
			期刊论文图片代码复现（Origin&amp;Matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 复刻步骤
2.1 步骤1
​
2.2 步骤2
2.3 步骤3
2.4 步骤4
2.5 步骤5 ​编辑
2.6 步骤6
2.7 步骤7
2.8 步骤8 2.9 步骤9 🎉3 参考文献
💥1 概述 经常在论文中，需要用到图片的数据，然后方便可视化研究。不知道小伙伴们怎么解决的，今天介绍一种方法，希望帮到大家一丢丢。
📚2 复刻步骤 2.1 步骤1 进入图像数字化工具界面。打开软件后，点击菜单栏-工具-图像数字化工具，进入如下图所示界面。
2.2 步骤2 导入图像。导入图像可以从文件导入，也可以从剪贴板导入，最简单的就是从剪贴板导入了。开了QQ的情况下，Alt+A直接截屏就可以。截屏之后点击上图的红色框那个快捷按钮就可以粘贴进来，进入如图所示界面。
2.3 步骤3 定义坐标轴。点击下图的红色小方框（右边小图），进入定义轴的界面。这里面有X1，X2，Y1，Y2，它们和左边图中的四条线是相对应的。每一条线有一个像素点，还有一个坐标值，我们可以用鼠标去移动这些线，移动到明显知道具体刻度的地方，然后输入刻度到坐标值处。
比如说，对于X1，我们把线条移动到0，然后输入坐标值也是0。然后依次对X2，Y1，Y2进行类似的操作设置，结果如图所示。
2.4 步骤4 点击手动取点，可以在‘图像数字化’下找到，也可以找到快捷键。然后就是一个一个去双击取点了，花了好几分钟才完成了一个粗采，如下图所示。这个方法费时费力，下面还有几种选择。 2.5 步骤5 2.6 步骤6 把得到的数据拿来画图，如下图所示，总体趋势没问题，但是纵坐标不对，下面一步，我们解决纵坐标问题。
2.7 步骤7 原图和oringin比例修正。顺便在润色。
2.8 步骤8 光电、火电和上面步骤一样，运行如下：
2.9 步骤9 在步骤4中补充一点知识，除了手动取点，还可以用下面两种方法：
1）使用‘逐点自动追踪曲线’功能。点击进入之后，任意双击曲线上的点，就可以自动追踪到许多点，我只是双击了一个点，就追踪到了整条曲线。
2）还可以利用‘网格自动取点’。点击之后直接拉一个框就行了，很容易就找到了这么多点。网格密度也是可以定义的。
🎉3 参考文献 部分理论来源于网络，如有侵权请联系删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b6638f304977383391d82ebbba12f6/" rel="bookmark">
			类初始化过程与对象创建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有兴趣了解更多相关内容，欢迎来我的个人网站看看：耶瞳空间
面试经常遇见，所以记录一下。
类初始化过程 Java类的初始化过程可以分为以下几个步骤：
加载：当Java程序要使用某个类时，系统会先检查该类是否已经被加载到内存中。如果没有，则系统会通过ClassLoader将该类的.class文件加载到内存中，并在堆区中创建一个Class对象来描述该类。链接 验证：在加载完成后，系统会对该类的字节码进行验证，确保它符合Java虚拟机规范以及安全性方面的要求。主要包括以下内容：语法检查、语义校验、字节码验证、符号引用验证等。准备：在验证通过后，系统会为该类的静态变量分配内存空间，并设置默认值。这个过程是在堆区中进行的，而不是在栈区中。解析：在准备阶段完成之后，系统会对该类进行符号引用解析，将所有符号引用转换为直接引用。这个过程包括了常量池解析、类或者接口解析、字段解析和方法解析等。 初始化：在准备和解析完毕之后，系统开始执行类的初始化。这个过程是按照代码中出现的顺序依次执行的，包括了静态成员变量赋值、静态代码块的执行等操作。需要注意的是，类初始化只会被执行一次。 以上是Java类的初始化过程，需要注意的是，在任何时候都不能直接调用一个类的初始化方法，因为初始化方法只会在类被加载到内存并且需要使用时才会执行。
对象创建过程 Java对象的创建过程可以分为以下几个步骤：
类加载：在Java程序中，当我们需要使用某个类时，系统会通过ClassLoader将该类的.class文件加载到内存中，并创建一个Class对象来描述该类。在这个过程中，会对该类进行验证、解析和初始化。如果类已经被加载过，则不进行这一步。分配内存：当系统通过new关键字或者反射机制创建对象时，JVM会在堆区中为该对象分配一块连续的内存空间。需要注意的是，由于堆区是共享的内存，所以分配内存的过程可能会受到垃圾回收机制等因素的影响。初始化零值：在分配内存后，JVM会将所有属性变量（包括实例变量和静态变量）都初始化为默认值，如int类型初始化为0，Object类型初始化为null等。设置对象头：每个Java对象都有一个对象头，它用来存储对象的元数据信息，比如对象的哈希值、锁状态等。在设置对象头时，JVM会根据对象的类型和大小来选择不同的布局方式。执行构造方法：在完成上述步骤后，JVM会调用对象的构造方法来对对象进行初始化，给属性变量赋初始值。构造方法的执行顺序是从父类到子类，从非静态成员变量到静态成员变量。返回对象引用：最后，JVM会将对象在内存中的地址返回给程序，程序通过该地址来访问和操作对象。 需要注意的是，在Java中创建对象的过程通常是自动完成的，我们只需要使用new关键字或者反射机制来触发对象的创建即可。同时，Java对象的销毁是由垃圾回收器负责的，无需手动销毁对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a710832efb5b500ad522378e6574690/" rel="bookmark">
			【MySQL】深入浅出主从复制数据同步原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL】深入浅出主从复制数据同步原理 参考资料：
全解MySQL之主从篇：死磕主从复制中数据同步原理与优化
MySQL 日志：undo log、redo log、binlog 有什么用？
文章目录 【MySQL】深入浅出主从复制数据同步原理一、主从复制架构概述二、MySQL中的主从复制技术MySQL数据同步的原理从节点拉取的数据到底是什么格式？ 三、基于主从模型的不同架构一主一从/多从架构双主/多主架构多主一从架构主从架构小结 四、主从数据一致性的解决方案改变业务逻辑更改复制方式调整数据库架构引入第三方中间件 一、主从复制架构概述 不论任何技术栈，但凡一提高可用、高性能、高稳定这些词汇，必然会牵扯到集群、主从架构的概念，如MQ、Redis、ES、MongoDB、Zookeeper.....任何技术栈中都会有，而MySQL中同样不例外，官方也提供了主从架构的支持，通过调整多个MySQL节点的配置信息，即可将一个节点的数据同步给另一个或多个节点，但这种方式同步的是所有数据！
主从架构中必须有一个主节点，以及一个或多个从节点，所有的数据都会先写入到主，接着其他从节点会复制主节点上的增量数据，从而保证数据的最终一致性，使用主从复制方案，可以进一步提升数据库的可用性和性能：
①在主节点宕机或故障的情况下，从节点能自动切换成主节点的身份，从而继续对外提供服务。②提供数据备份的功能，当主节点的数据发生损坏时，从节点中依旧保存着完整数据。③可以基于主从实现读写分离，主节点负责处理写请求，从节点处理读请求，进一步提升性能。 但无论任何技术栈的主从架构，都会存在致命硬伤，同时也会存在些许问题需要解决：
①硬伤：木桶效应，一个主从集群中所有节点的容量，受限于存储容量最低的哪台服务器。②数据一致性问题：由于同步复制数据的过程是基于网络传输完成的，所以存储延迟性。③脑裂问题：从节点会通过心跳机制，发送网络包来判断主机是否存活，网络故障情况下会产生多主。 上述提到的三个问题中，第一个问题只能靠加大服务器的硬件配置解决，第二个问题相对来说已经有了很好的解决方案（后续讲解），第三个问题则是部署方式决定的，如果将所有节点都部署在同一网段，基本上不会出现集群脑裂问题。
上面简单了解了主从复制架构的一些基本概念后，接着来聊一聊MySQL中的主从复制。
二、MySQL中的主从复制技术 MySQL数据同步的原理 MySQL是基于它自身的Bin-log日志来完成数据的异步复制，因为Bin-log日志中会记录所有对数据库产生变更的语句，包括DML数据变更和DDL结构变更语句，数据的同步过程如下：
上述即是主从同步数据的原理图，但在讲解之前先来了解一下两种数据同步的方式：
主节点推送：当主节点出现数据变更时，主动向自身注册的所有从节点推送新数据写入。从节点拉取：从节点定期去询问一次主节点是否有数据更新，有则拉取新数据写入。 那MySQL究竟采用的是什么方式呢？其实是「从拉」的方案，但对其稍微做了一些优化，传统的「从拉」方案是需要从节点一直与主节点保持长连接，从节点定时或持续性的对主节点做轮询，查看主机的数据是否发生了变更，而MySQL的数据同步原理如下：
①客户端将写入数据的需求交给主节点，主节点先向自身写入数据。②数据写入完成后，紧接着会再去记录一份Bin-log二进制日志。③配置主从架构后，主节点上会创建一条专门监听Bin-log日志的log dump线程。④当log dump线程监听到日志发生变更时，会通知从节点来拉取数据。⑤从节点会有专门的I/O线程用于等待主节点的通知，当收到通知时会去请求一定范围的数据。⑥当从节点在主节点上请求到一定数据后，接着会将得到的数据写入到relay-log中继日志。⑦从节点上也会有专门负责监听relay-log变更的SQL线程，当日志出现变更时会开始工作。⑧中继日志出现变更后，接着会从中读取日志记录，然后解析日志并将数据写入到自身磁盘中。 阅读上述流程后，相信大家能感受出MySQL主从复制时做的优化，在主从数据同步的过程中，从节点并不会无限制的询问主机，这样实在太影响效率了，在MySQL中引入了惰性的思想，只有当主节点真正出现数据变更时，才会通知从节点拉取数据！
从节点拉取的数据到底是什么格式？ 前面从整体角度出发，简单讲述了主从同步数据的过程，但从节点复制的数据到底是什么格式的呢？这里要根据主节点的Bin-log日志格式来决定，它会有三种格式，如下：
Statment：记录每一条会对数据库产生变更操作的SQL语句（默认格式）。Row：记录具体出现变更的数据（也会包含数据所在的分区以及所位于的数据页）。Mxed：Statment、Row的结合版，可复制的记录SQL语句，不可复制的记录具体数据。 一般在搭建主从架构时，最好将Bin-log日志调整为Mixed格式，因为这种方式绝对不会出现数据不一致性，毕竟默认的Statment格式会导致主从节点间的数据出现不一致，例如：
insert into `zz_users` values(11,"blblccc","男","3333",now()); 当主节点插入数据时，使用了sysdate()、now()....这类函数时，主节点会取自身的系统时间插入数据，而当从节点拉取SQL执行时，则会获取从节点的系统时间插入数据，因为主/从节点执行SQL语句绝对不可能发生在同一时间，因此就会导致主/从节点中，同一条数据的时间不一致。
有一个数据库表t1，表中有如下两条记录：
CREATE TABLE t1 ( a int(11) DEFAULT NULL, b int(11) DEFAULT NULL, KEY a (a) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; insert into t1 values(10,2),(20,1); 接着开始执行两个事务的写操作：
以上两个事务执行之后，数据库里面的记录会变成（11，2）和（20，2），这个发上在主库的数据变更大家都能理解。
假如事务的隔离级别是read committed，所以，事务1在更新时，只会对b=2这行加上行级锁，不会影响到事务2对b=1这行的写操作。
以上两个事务执行之后，会在bin log中记录两条记录，因为事务2先提交，所以UPDATE t1 SET b=2 where b=1;会被优先记录，然后再记录UPDATE t1 SET a=11 where b=2;（再次提醒：statement格式的bin log记录的是SQL语句的原文）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a710832efb5b500ad522378e6574690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e75d3a6ef6ebb8bdfa8e0535ca7e7a/" rel="bookmark">
			第十四届蓝桥杯大赛——真题训练第11天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一题：蓝肽子序列_求最长公共子序列
题目描述
输入描述
输出描述
输入输出样例
运行限制
题目分析
题目代码 第二题： 时间显示
题目描述
输入描述
输出描述
输入输出样例
评测用例规模与约定
运行限制
题目分析
题目代码 第三题：顺子日期
问题描述
运行限制
题目分析
题目代码
第一题：蓝肽子序列_求最长公共子序列 题目描述 L 星球上的生物由蛋蓝质组成，每一种蛋蓝质由一类称为蓝肽的物资首尾连接成一条长链后折叠而成。
生物学家小乔正在研究 L 星球上的蛋蓝质。她拿到两个蛋蓝质的蓝肽序列，想通过这两条蓝肽序列的共同特点来分析两种蛋蓝质的相似性。
具体的，一个蓝肽可以使用 1 至 5 个英文字母表示，其中第一个字母大写，后面的字母小写。一个蛋蓝质的蓝肽序列可以用蓝肽的表示顺序拼接而成。
在一条蓝肽序列中，如果选取其中的一些位置，把这些位置的蓝肽取出，并按照它们在原序列中的位置摆放，则称为这条蓝肽的一个子序列。蓝肽的子序列不一定在原序列中是连续的，中间可能间隔着一些未被取出的蓝肽。
如果第一条蓝肽序列可以取出一个子序列与第二条蓝肽序列中取出的某个子序列相等，则称为一个公共蓝肽子序列。
给定两条蓝肽序列，找出他们最长的那个公共蓝肽子序列的长度。
输入描述 输入两行，每行包含一个字符串，表示一个蓝肽序列。字符串中间没有空格等分隔字符。
其中有 ，两个字符串的长度均不超过 10001000。
输出描述 输出一个整数，表示最长的那个公共蓝肽子序列的长度。
输入输出样例 示例
输入
LanQiaoBei LanTaiXiaoQiao 输出
2 运行限制 最大运行时间：1s最大运行内存: 128M 题目分析 (1)字符串切割（存储每个以大写字母为开头的单词）
(2)最长公共子序列问题（LCS）
最长公共子序列我们需要分别遍历字符串S1和字符串S2遍历比较的时候只会出现两种情况：字符串相等或字符串不等对应这两种状态分别给出两种dp状态转移方程：
相等：dp[i][j]=dp[i-1][j-1]+1
不相等:dp[i][j]=max(dp[i-1][j],dp[i][j-1]) dp[i][j]的表示含义：字符串S1的前i个字符和字符串S2的前j个字符可以构成最长公共子序列为:dp[i][j]
参考原文链接：https://blog.csdn.net/m0_55858611/article/details/129783258
题目代码 import java.util.ArrayList; import java.util.List; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e75d3a6ef6ebb8bdfa8e0535ca7e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b6ce4629711424a653b8ec2fa45e0c/" rel="bookmark">
			第十四届蓝桥杯三月真题刷题训练——第 26 天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第 1 题：玩具
代码：
第 2 题：滑雪_dfs
代码：
第 3 题：abb_后缀和
代码：
第 4 题：小红取数_dp
代码：
第 1 题：玩具 代码： package 第十四届蓝桥杯三月真题刷题训练.day26; import java.io.*; import java.util.Arrays; /** * @author yx * @date 2023-03-29 18:37 */ public class 玩具 { static PrintWriter out =new PrintWriter(System.out); static BufferedReader ins=new BufferedReader(new InputStreamReader(System.in)); static StreamTokenizer in=new StreamTokenizer(ins); /** * 输入 * in.nextToken() * int a= (int)in.nval; * * 输出 * out.print(); * out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b6ce4629711424a653b8ec2fa45e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d9ce0cdd50ca6fc8906828b7fc3bee/" rel="bookmark">
			vue-excel导出-单表头，多表头导出，Export2Excel.js Blob.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图↓
一级导出：↓
二级导出：如下图
三级导出：↓
Export2Excel.js Blob.js 等
安装依赖
npm install -S file-saver npm install --save xlsx@0.10.0 npm install -D script-loader npm install xlsx-style --save 其中xlsx-style 有坑↓
Can‘t resolve ‘./cptable‘ in ‘xxx\node_modules_xlsx Can’t resolve ‘fs’ 在vue.config.js中配置↓
const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ transpileDependencies: true, configureWebpack:{ externals: { './cptable': 'var cptable', }, resolve: { fallback: { fs: false } } } }) jszip not a constructor↓ 在xslx-style下的xslx.js中 （node_modules\xlsx-style\xlsx.js ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d9ce0cdd50ca6fc8906828b7fc3bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cab8144e0951db3df21eca7eef0ac4/" rel="bookmark">
			在线安装ansible设置批量免密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线安装ansible设置批量免密 一、ansible在线yum安装1、安装epel扩展源2、安装ansible3、使用 pip（python的包管理模块）安装4、验证 二、ansible批量免密1、编辑配置文件，将需要管理的服务器编组2、生成密钥3、确认主机4、批量推公钥5、验证 一、ansible在线yum安装 1、安装epel扩展源 yum -y install epel-release 2、安装ansible yum -y install ansible 3、使用 pip（python的包管理模块）安装 yum -y install python-pip pip install ansible 4、验证 ansible --version 二、ansible批量免密 1、编辑配置文件，将需要管理的服务器编组 #例如 vim /etc/ansible/hosts [all] 192.168.145.11 192.168.145.12 192.168.145.13 2、生成密钥 ssh-keygen -t rsa 3、确认主机 ansible all -m ping #确认下主机，第一次连接其他主机需要确认，执行ansible全量跑下，有多少台，需要输入多少yes 4、批量推公钥 ansible all -m authorized_key -a "user=root key='{{ lookup('file','/root/.ssh/id_rsa.pub') }}'" -k #需要手动输入一下服务器密码（因为批量执行，注意密码统一） 5、验证 执行以后，没有报错那就是说明好了，然后可以选几台验证一下
如果执行过程中有报错，可能是服务器首次登录没确认好，再确认一下，输入yes就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706ae88751b9a65f8178415b63fc88e0/" rel="bookmark">
			【学习整理】Ubuntu使用screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu使用screen 今天才知道，原来关闭远程连接后也可以使用screen控制程序在后台运行，上线后就可以调出后台的程序，非常方便！
步骤如下：
在终端输入screen，如果出现Command not found说明当前设备没有安装screen，转步骤2；否则转步骤3；输入sudo apt install screen安装；新建窗口：screen -S name，此处的name是你后续调出后台程序时需要使用的，name相当于那个screen使用的名称；正常执行命令；再次上线时，输入screen -ls查看当前screen运行的程序调出后台程序screen -r name
如果远程连接被动关闭，就会出现错误：
There is a screen on: 12345.name (日期 时间) (Attached) 虽然是重新连接了，但是之前的screen还是处于打开状态，1个screen不可能同时打开两次，所以无法打开screen。
使用下面语句先解除Attached：
screen -d id
id即上面的12345
然后再使用screen -r id重新连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f179c56216cab4b51019688ece0f540/" rel="bookmark">
			解决 ModuleNotFoundError: No module named matplotlib.pyplot 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 ModuleNotFoundError: No module named matplotlib.pyplot 问题 最近在想把iperf打流的数据，自动绘图，但在运行的时候会报错。
1. 报错提示 Traceback (most recent call last): File "E:\python\iperf.py", line 2, in &lt;module&gt; import matplotlib.pyplot as plt File "E:\python\iperf.py", line 2, in &lt;module&gt; import matplotlib.pyplot as plt ModuleNotFoundError: No module named 'matplotlib.pyplot' 2. 解决方案 我通过卸载重装matplotlib解决了问题：
1.pip卸载matplotlib
python -m pip uninstall matplotlib 2.pip安装jupyter
python -m pip install jupyter 3.pip安装matplotlib
python -m pip install matplotlib 3. 比较粗糙的例子 from fileinput import filename import re from time import sleep import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f179c56216cab4b51019688ece0f540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397f7505a422f789e5a82a20c6c988d5/" rel="bookmark">
			C&#43;&#43;中vector迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器（iterator）是一种用于遍历数据集合的的对象。它提供了一种访问数据集合中元素的方式，而无需暴露数据集合内部的细节。使用迭代器，我们可以对数据集合中的每个元素进行处理，而无需将整个数据集合加载到内存中。这样可以节省内存空间，并且在处理大型数据集合时可以提高处理效率。
C++ STL（标准模板库）中的容器类都提供了迭代器，用于访问容器内部的元素。迭代器是一个类或者一个指针，它可以指向容器中的一个元素，然后遍历容器中的所有元素。
C++ STL中的迭代器通常具有以下五个成员函数：
operator*()：用于返回当前迭代器指向的元素的引用。operator-&gt;()：用于返回当前迭代器指向的元素的指针。operator++()：用于将迭代器移动到下一个元素。operator--()：用于将迭代器移动到上一个元素。operator==() 和 operator!=()：用于比较两个迭代器是否相等。 C++ STL中的容器类，如vector、list、map、set等都提供了迭代器，可以通过调用容器的成员函数begin()和end()获取指向容器第一个元素和最后一个元素的迭代器。
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; // 遍历vector中的所有元素 for (auto it = v.begin(); it != v.end(); ++it) { cout &lt;&lt; *it &lt;&lt; " "; } cout &lt;&lt; endl; return 0; } 该代码定义了一个vector&lt;int&gt;对象v，并使用auto关键字定义了一个迭代器it来遍历vector中的所有元素。在每次迭代中，使用*it访问迭代器指向的元素。最后输出所有元素的值。
vector是一个动态数组容器，可以使用迭代器来访问其元素。vector有两种类型迭代器：正向迭代器和反向迭代器。
正向迭代器遍历：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v = { 1,2,3,4,5 }; vector&lt;int&gt;::iterator it; for (it = v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/397f7505a422f789e5a82a20c6c988d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db96161880776c1bc1df166c36fe7933/" rel="bookmark">
			【MYSQL高级篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章、MYSQL整体架构 mysql是一个典型的cs架构软件，它是基于c与c++开发的，性能强大；
比如我们平时写的web应用，就是作为mysql的客户端去连接mysql server端，我们熟知的navicat其实也是作为mysql客户端来连接mysql server的；
下面是mysql的架构图
首先：客户端通过tcp协议连接到mysql server端 连接器：连接首先会到达连接器，因为mysql需要一个认证模块来校验所有连接是否合法，是否具有权限，密码是否正确等，同时这个连接还会管理所有连接进行来的连接； query cache：在连接器处认证通过后，假如客户端传过来的是一个查询语句，并且 mysql server也开启了查询缓存的话，它会优先到查询缓存中去找是否有结果，如果找到了就返回这句sql的结果，但通常来说：我们不会开启mysql的查询缓存功能，因为它非常的鸡肋！甚至在mysql 8.0时就完全的抛弃了查询缓存功能； 为什么mysql要在8.0抛弃查询缓存功能？ 答：如果让我做查询sql的缓存功能，我会以sql语句为key，sql语句查出来的结果为值存入一个线程安全的map中，事实上，mysql也是这样做的，只不过它是将其存入hash表中，但这样会带来更多问题：①每个人写的查询语句都可能不同，并且绝大部分的查询sql都是不相同的，你要做查询sql的缓存的话，你就要将这些查询sql每一个都作为key存到hash表中，显然这个数量级就比较大了；②同一句查询sql，比如select * from t_user,如果换成大写SELECT * FROM t_user，或者中间多一个空格，就会导致mysql server认为它不是同一个sql，也会导致存储很多重复的key-value到查询缓存中；这就导致查询缓存中可能只有不到10%的sql是真正能够起到缓存作用的，剩下的90%存到内存中完全是浪费； 综上所述：如果开启了查询缓存功能，会导致mysql server端浪费掉大量的内存来存储不必要的sql-数据 键值对；所以mysql在8.0干掉了它； 3. 词法分析器：你的sql语句经过查询缓存后（如果是非查询语句则不会经过缓存），就会到达词法分析器，它的作用分析你的sql语法是否有误，如果有误就驳回； 4.优化器：语法分析无误后，会经过优化器，优化器会将你的sql语句进行优化，因为mysql并不信任人写的sql；同时在这一步：优化器还会分析你这一句sql在有多个索引时该走哪一个索引，以及怎么走等等，最后生成一个最优的执行计划；只要按着这个执行计划走，就可以是最快的执行速度； 5. 执行器：优化器生成执行计划后，就会拿着这个执行计划去调用存储引擎的接口，存储做出对应的操作，如增删改、返回查询结果等； 第二章：binlog日志详解 binlog是一个二进制文件，它记录了Mysql所有数据的变更，并以二进制的方式存储到了磁盘上； binlog的三种模式：行模式，statement模式，混合模式 ① 行模式： id
name
1
许海
比如：行模式下，我现在往上面这个表中加入了id=1，name=许海这样的一行；
那么在binlog中就会记录为
id
name
1
许海
如果我将许海修改为了刘丹，那么binlog中就会记录为
id
name
1
许海
1
刘丹
最后再将其转为二进制文件，就成了行模式下的binlog；
② statement模式： statement模式中：binlog会记录增删改的sql语句，假如你的sql是批量修改，最终也只会记录这一条sql，这样的好处就是节省空间，行模式就不行，假如你影响到了多行，行模式就会记录多行；
③ 混合模式： 混合模式下：由mysql自己去判断你这一次sql到底适合记录statement还是记录行，这是后来才出的功能；
通常来说：如果没有混合模式，我们会选用statement模式多一点，因为更节省空间；
开启binlog ① 在mysql 8.0 中默认是开启binlog的
② mysql 8.0 以前需要我们到/etc目录下的my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db96161880776c1bc1df166c36fe7933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a5df69caffca3536a8f651fbd312b8/" rel="bookmark">
			vue动态组件＜Component＞与＜KeepAlive＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;Component&gt; 使用动态组件&lt;Component&gt;可以实现两个组件间来回切换，我们只需要传给is属性对应的组件名即可当切换成另一个组件时候，当前组件会被销毁，另一个组件将被重新创建，原本示例上的数据不会保存 Dynamic.vue &lt;template&gt; &lt;div&gt; &lt;el-button-group&gt; &lt;el-button @click="componentName='DynamicA'"&gt;DynamicA&lt;/el-button&gt; &lt;el-button @click="componentName='DynamicB'"&gt;DynamicB&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;!-- 被传给 :is 的值是被注册的组件名 --&gt; &lt;component :is="componentName"&gt;&lt;/component&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import DynamicA from './DynamicA.vue'; import DynamicB from './DynamicB.vue'; export default { name: '', components: { DynamicA, DynamicB, }, data() { return { componentName: '' } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; DynamicA.vue &lt;template&gt; &lt;div class="dynamicA"&gt; DynamicA &lt;div&gt; &lt;el-button @click="count+=1"&gt;count+1&lt;/el-button&gt; &lt;!-- count的值在切换的过程中，并没有得到保存 --&gt; count: {{ count }} &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'DynamicA', components: { }, data() { return { count: 0 } }, // 每次当组件被切换到时，此方法被调用了，说明当前组件实例又被重新创建了 created() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a5df69caffca3536a8f651fbd312b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58673ab66863bac1ec687a8606427901/" rel="bookmark">
			【微信小程序】TypeError: Cannot read property ‘get‘ of undefined &amp; Error: MiniProgramError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💌 所属专栏：【程序错误解决方法（建议收藏）】 😀 作 者：我是夜阑的狗🐶 🚀 个人简介：一个正在努力学技术的CV工程师，专注基础和实战分享 ，欢迎咨询！
💖 欢迎大家：这里是CSDN，我总结知识的地方，喜欢的话请三连，有问题请私信 😘 😘 😘
文章目录 前言一、问题场景二、问题分析三、问题解决总结 前言 大家好，又见面了，我是夜阑的狗，本文是专栏【程序错误解决方法（建议收藏）】专栏的文章，主要讲解是在写 uni-app 项目的时候出现的报错。
专栏地址：【程序错误解决方法（建议收藏）】 ， 此专栏是我是夜阑的狗对程序报错的解决方法，希望能够加深自己的印象，以及帮助到其他的小伙伴😉😉。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
一、问题场景 在写 uni-app 项目的时候，跟着视频一步一步的弄，一运行就发现报错了，然后就开始各种百度了。
找不到定义
WAServiceMainContext.js?t=wechat&amp;s=1680006165208&amp;v=2.30.2:1 TypeError: Cannot read property ‘get’ of undefined
at _callee$ (home.js? [sm]:16)
at L (regenerator.js:1)
at Generator._invoke (regenerator.js:1)
at Generator.t. [as next] (regenerator.js:1)
at asyncGeneratorStep (asyncToGenerator.js:1)
at c (asyncToGenerator.js:1)
at asyncToGenerator.js:1
at new Promise ()
at asyncToGenerator.js:1
at Proxy.getSwiperList (home.js? [sm]:15)(env: Windows,mp,1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58673ab66863bac1ec687a8606427901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6b8bfcf706896e1d4507c5d111be81/" rel="bookmark">
			java8 foreach 异常_Java8 lambda表达式forEach不能提前终止循环的两种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.情景展示
如上图所示，我们想要终止for循环，使用return。
执行结果如下：
我们可以看到，只有赵六没被打印出来，后续的数组元素依旧被执行了。
也就是说，关键字"return"，在这里执行的效果相当于普通for循环里的关键词continue"。
2.原因分析
我们知道，在普通for循环里面，想要提前结束(终止)循环体使用"break"；
结束本轮循环，进行下一轮循环使用"continue"；
另外，在普通for里，如果使用"return"，不仅强制结束for循环体，还会提前结束包含这个循环体的整个方法。
而在Java8中的forEach()中，"break"或"continue"是不被允许使用的，而return的意思也不是原来return代表的含义了。
我们来看看源码：
forEach()，说到底是一个方法，而不是循环体，结束一个方法的执行用什么？ 当然是return啦；
java8的forEach()和JavaScript的forEach()用法是何其的相似，感兴趣的可以去了解下(在文末)。
Java不是万能的，不要再吐槽它垃圾了。
3.解决方案
方案一：使用原始的foreach循环
使用过eclipse的老铁们应该知道，当我们输入：foreach，再按快捷键：Alt+/，就会出现foreach的代码提示。
如上图所示，这种格式的for循环才是真正意义上的foreach循环。
在idea中输入，按照上述操作是不会有任何代码提示的，那如何才能在idea中，调出来呢？
for循环可以提前终止。
方式一：break
方式二：return(不推荐使用)
方案二：抛出异常
我们知道，要想结束一个方法的执行，正常的逻辑是：使用return；
但是，在实际运行中，往往有很多不突发情况导致代码提前终止，比如：空指针异常，其实，我们也可以通过抛出假异常的方式来达到终止forEach()方法的目的。
如果觉得这种方式不友好，可以再包装一层。
这样，就完美了。
这里，需要注意的一点是：要确保你forEach()方法体内不能有其它代码可能会抛出的异常与自己手动抛出并捕获的异常一样；
否则，当真正该因异常导致代码终止的时候，因为咱们手动捕获了并且没做任何处理，岂不是搬起石头砸自己的脚吗？
写在最后
哪位大佬如若发现文章存在纰漏之处或需要补充更多内容，欢迎留言！！！
相关推荐：
来源：https://blog.csdn.net/weixin_39597399/article/details/114232746 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2634ba4eef67d85bd6f717ff0425559c/" rel="bookmark">
			蓝桥杯——数组切分（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
已知一个长度为 N 的数组:A1​,A2​,A3​,…AN​ 恰好是 1∼N 的一个排列。现 在要求你将 A 数组切分成若干个 (最少一个, 最多 N 个) 连续的子数组, 并且 每个子数组中包含的整数恰好可以组成一段连续的自然数。
例如对于 A=1,3,2,4, 一共有 5 种切分方法:
1324 : 每个单独的数显然是 (长度为 1 的) 一段连续的自然数。
{1}{3,2}{4}:{3,2} 包含 2 到 3 , 是 一段连续的自然数, 另外 1 和 4 显然 也是。
{1}{3,2,4}:{3,2,4} 包含 2 到 4 , 是一段连续的自然数, 另外1 显然也是。
{1,3,2}{4}:{1,3,2} 包含 1 到 3 , 是 一段连续的自然数, 另外 4 显然也是。
{1,3,2,4} : 只有一个子数组, 包含 1 到 4 , 是 一段连续的自然数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2634ba4eef67d85bd6f717ff0425559c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ae03c603bedf4326e18996cf1f629b/" rel="bookmark">
			Java代码实现记录接口调用次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决多台服务记录冲突或者覆盖的问题，可以使用 Redis 的分布式锁来保证同一时刻只有一个服务可以进行记录接口调用次数的操作。具体实现步骤如下：
在 Redis 上创建一个计数器，用于记录接口调用次数。使用 Redis 的分布式锁机制，保证同一时刻只有一个服务可以进行接口调用次数的记录。可以使用 Redisson 等 Redis 客户端库来实现分布式锁。在记录接口调用次数的代码中，加入获取分布式锁的逻辑，保证同一时刻只有一个服务可以进行记录操作。 public class ApiCounter { private RedissonClient redissonClient; public ApiCounter(RedissonClient redissonClient) { this.redissonClient = redissonClient; } public void recordApiCall(String apiName) { String lockKey = "api-call-lock-" + apiName; RLock lock = redissonClient.getLock(lockKey); try { lock.lock(); // 获取分布式锁成功，进行接口调用次数记录 String counterKey = "api-call-counter-" + apiName; RAtomicLong counter = redissonClient.getAtomicLong(counterKey); counter.incrementAndGet(); } finally { // 释放分布式锁 lock.unlock(); } } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/162/">«</a>
	<span class="pagination__item pagination__item--current">163/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/164/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>