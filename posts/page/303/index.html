<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d3c19e4d641334d279cbed298d8e77/" rel="bookmark">
			shiro拦截ajax请求返回json,Spring Boot&#43;Shiro拦截登陆返回Json结果（前后端分离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自定义访问控制拦截器，继承AccessControlFilter，实现以下三个方法。
abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;
2、自定义BeamUserFilter
package com.hsshy.beam.common.intercept;
import com.hsshy.beam.common.enumeration.RetEnum;
import com.hsshy.beam.common.utils.R;
import com.hsshy.beam.common.utils.RenderUtil;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.web.filter.AccessControlFilter;
import org.apache.shiro.web.util.WebUtils;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;
public class BeamUserFilter extends AccessControlFilter {
/**
*
* 表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；
* (感觉这里应该是对白名单(不需要登录的接口)放行的)
* 如果isAccessAllowed返回true则onAccessDenied方法不会继续执行
* 这里可以用来判断一些不被通过的链接(个人备注)
* * 表示是否允许访问 ，如果允许访问返回true，否则false；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d3c19e4d641334d279cbed298d8e77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65081f86ebeafc350b4831f285a836f0/" rel="bookmark">
			smb&#43;服务器&#43;修复,关于SMBv3.0服务远程代码执行漏洞的风险提示及修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、漏洞概述
2020年3月10日，微软官方发布了针对Windows 10/Server禁用SMBv3(SMB 3.1.1版本)协议压缩的指南公告，以此缓解SMBv3协议(用于文件共享与打印服务)在处理调用请求时的一个远程代码执行漏洞(漏洞编号CVE-2020-0796)。SMBv3协议同时启用于SMB服务端和SMB客户端，未经身份验证的攻击者可以对服务端和客户端分别进行攻击，通过向受影响的SMBv3 服务器发送特制的压缩数据包来攻击服务端，还可以通过配置恶意 SMBv3 服务器并诱导用户连接来攻击客户端，攻击成功可在目标机器上执行任意代码。综合各方消息，该漏洞原理与“永恒之蓝”类似，存在被蠕虫化利用的可能。
目前微软没有发布漏洞详情及补丁，但从微软的通告来看受影响目标主要是Win10系统，考虑到相关设备的数量级，潜在威胁较大。
二、影响范围
Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows Server, version 1903 (Server Core installation)
Windows Server, version 1909 (Server Core installation)
三、修复办法
该漏洞只能进行禁止smb v3.0进行修复，下面则是如何禁止smb v3.0的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65081f86ebeafc350b4831f285a836f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c35e0dcb7bc8854ac1c3dde81626458/" rel="bookmark">
			ajax then error,jQuery ajax success error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I'm trying to submit a form witch sends an email:
JS
var that = $(this);
$.ajax({
url: '../wp-content/themes/bsj/php/validate.php',
type: 'post',
context: that,
data: $('#sign-up').serialize(),
cache: false,
success: function(){
alert('success!');
},
error: function(){
alert('error!');
}
});
PHP
/*----------------------------------
Variables
----------------------------------*/
// Personal info
$prefix = $_POST['prefix'];
$first_name = $_POST['first_name'];
$last_name = $_POST['last_name'];
$company = $_POST['company'];
$email = $_POST['email'];
$title = $_POST['title'];
$dept = $_POST['dept'];
// Contact details
$address = $_POST['address'];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c35e0dcb7bc8854ac1c3dde81626458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb371a86d06f2f292521d2284802793/" rel="bookmark">
			ajax post 空格变加号,Ajax Post数据加号变空格详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在页面上得到BASE64编码想通过AJAX方式与后台交互，但是后台得到的数据所有的+号都变成了空格，查了一下。
采用Ajax传递数据时，通常会将数据整理为data="var1=abc&amp;var2=def"。而当数据中存在加号(+)或是连接符(&amp;)时，服务器端接收数据时会有部分数据丢失现象。
分析一下Ajax传递数据的格式与Javascript的语法不难发现：
1. "+"号：JavaScript解析为字符串连接符，所以服务器端接收数据时"+"会丢失。
2. "&amp;"：JavaScript解析为变量连接符，所以服务器端接收数据时&amp;符号以后的数据都会丢失。
解决办法也相当简单，只需要为+与&amp;符号编码即可：
//使用post方式发送
function doRequestUsingPOST()
{
createXMLHttpRequest();
var retCode = document.getElementById("retCode").value;
var data = document.getElementById("data").value;
data = data.replace(//+/g, "%2B");
data = data.replace(//&amp;/g, "%26")； var queryString = "retCode="+retCode+"&amp;data="+data;
var url="backSealServlet" ; //使用URL向后台传值
//xmlHttp.open("POST",url,true);
xmlHttp.open("POST",url,false);
xmlHttp.onreadystatechange = handleStateChange;
xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
xmlHttp.send(queryString);
//alert("结束 "+retCode);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1656d89e0ad53b5610c8859a88d421/" rel="bookmark">
			虚拟机怎样搭建服务器环境,使用虚拟机安装CentOS7并搭建LAMP服务器环境详细讲解...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候为了方便，搭配wamp或者wnmp环境的时候，直接在windows系统搭建就好了，而且更方便的是直接用集成环境phpstudy，直接了当。这个对于初学者来说，可以这样子做，但是对于一些摸索php好久的同学，其实都没什么挑战性了，更多的是，linux都没去学着的话，更容易忘记。说到lamp或者lnmp，有些同学说我用一键安装就好了，确实，现在的确是很方便，有一键安装包，
地址：https://lnmp.org/，按照这个网站的安装步骤就可实现了。
但是我还是想体验一下CentOS7.0安装LAMP或者LNMP，最近又摸索了一下。根据个人的喜好，你们有需要的也可以学习学习的。
CentOS7的安装
1)通过VMware创建虚拟机(这一步不解释)
成功引导系统后，会出现下面的界面
界面说明：
Install CentOS 7 安装CentOS 7
Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7
Troubleshooting 修复故障
这里选择第一项，安装CentOS 7，回车，进入下面的界面
选择语言：中文-简体中文(中国) #正式生产服务器建议安装英文版本
继续
选择-系统-安装位置，进入磁盘分区界面
选择-其它存储选项-分区-我要配置分区，点左上角的“完成”，进入下面的界面
分区前先规划好
swap #交换分区，一般设置为内存的2倍
/ #剩余所有空间
备注：生产服务器建议单独再划分一个/data分区存放数据
点左下角的“+”号
挂载点：swap
期望容量：2048
添加挂载点，如下图所示
点左上角的“完成”，进入下面的界面
接受更改，进入下面的界面
开始安装 #注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，可以自己设置。
建议选择最小安装即可，最小安装方式安装完成后开机即为命令行模式
设置网络
点击，打开网络，注意，这里首先要设置虚拟机的网络为桥接模式。
进入下面的界面
选择-用户设置-ROOT密码，进入下面的界面
设置Root密码
如果密码长度少于8位，会提示要按“完成”两次来确认，安装继续
安装完成之后，会进入下面的界面
点重启
系统重新启动
进入登录界面
账号输入root 回车
再输入上面设置的root密码回车
系统登录成功
远程登录，这里我使用Xsell工具
输入命令ifconfig,出来以下信息，红框里的就是你要远程登录的ip地址
打开Xsell工具，打开新连接，输入主机地址
输入用户名
输入密码
到这里远程登录已经可以用了
接下来安装Apache,php,mysql,我这里安装的是lamp。
1)、安装Apache
Apache软件的软件包名称叫做httpd，因此，要安装Apache软件，就使用下述命令：[root@localhost ~]# yum install httpd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1656d89e0ad53b5610c8859a88d421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68bc0d297ff2ccde8f8b1a149c021a10/" rel="bookmark">
			ajax中加入if,如何添加if语句到Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我主要是PHP编程，但由于我根本不知道Javascript或Ajax，所以陷入了Ajax问题。我现在有一个组合选择菜单，如果第一个选择是='train'，我想隐藏第三个选择菜单(方向)。我读过一些浏览器不支持隐藏功能，因此，下一个最佳选择是在假设第一个选项是列车时选择第二个选项时禁用第三个选择菜单。如果是公共汽车，那么第三个选择菜单应该仍然显示。这里是我的JavaScript现在，我敢肯定你可以想象它不工作。如何添加if语句到Ajax
$(document).ready(function(){
if ($("select#agency").attr('value') == 'cta-train') {
$("select#direction").attr("disabled","disabled");
}
$("select#route").attr("disabled","disabled");
$("select#agency").change(function(){
$("select#route").attr("disabled","disabled");
$("select#route").html("wait...");
var id = $("select#agency option:selected").attr('value');
$.post("select_route.php", {id:id}, function(data){
$("select#route").removeAttr("disabled");
$("select#route").html(data);
});
});
});
$(document).ready(function(){
if ($("select#agency").attr('value') == 'cta-train') {
$("select#direction").attr("disabled","disabled");
}
else {
$("select#direction").attr("disabled","disabled");
$("select#route").change(function(){
$("select#direction").attr("disabled","disabled");
$("select#direction").html("wait...");
var id = $("select#route option:selected").attr('value');
$.post("select_direction.php", {id:id}, function(data){
$("select#direction").removeAttr("disabled");
$("select#direction").html(data);
});
});
}
});
任何帮助将不胜感激！
+0
所以，你想尽快使AJAX POST作为文档准备或应该所有这些活动确实是基于一些DOM事件触发(选择更改，按钮点击等)？另外jQuery''hide()在浏览器中也很好。我知道唯一的'hide()'问题是一个旧的Safari bug，试图对尚未附加到DOM的元素执行hide()。不知道这是否仍然是一个问题。 –
+0
谢谢迈克。自从我在数小时后才开始工作以后，我不想过多地修改代码。正如我所提到的，我不熟练使用任何类型的javascript/ajax语言，所以我只想添加一些简单的几行代码，它们会根据第一个选择的选项隐藏第三个选择。如果您对如何做到这一点有任何想法，我会很感激。 –
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2974d482648c420fd075216e19270d4e/" rel="bookmark">
			【学习总结】C&#43;&#43;八股文（应该会持续更新，嗯 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跑路吧，做游戏没有前途的，hhhh
C++八股文 C++基础面向对象编程部分类部分内存管理相关关键字相关区别对比特性相关其它 STL与泛型编程部分容器（Containers）迭代器（iterator）算法（algorithm）仿函数（Functor）适配器（adpater）分配器（allocator） 代码类三大排序与洗牌MyString类智能指针Shared_ptr单例模式（懒汉与饿汉） C++基础面向对象编程部分 类部分 面向对象的三大特性：封装、继承、多态
封装：即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别
继承：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为
多态：指相同的消息给予不同的对象会引发不同的动作
类的访问权限：private、protected、public
private：被private限定符修饰的成员变量只能被该类的方法和友元函数访问，子类函数无法访问，在这三个限定符中封装程度是最高的，一般来说，应该尽可能将类的成员变量声明为private而不是其他，减少成员变量的暴露，只提供getter和settter方法给外界访问，这样能提高类的安全性
protected：protected限定符修饰的成员变量和成员函数可以被该类的成员函数访问，但是不能被类对象所访问，即不能通过类对象的成员运算符来访问。另外，这些成员可以被子类的函数和友元函数访问，相比public成员 少了一个可以使用类对象直接访问的特性
public：被public限定符所修饰的成员变量和函数可以被类的函数、子类的函数、友元函数，也可以由类的对象来访问，即可以使用成员运算符来访问。这里的友元函数，可以是该类的友元函数，也可以是该类的友元类的成员函数
构造和析构关系
构造过程为：父类先构造然后子类构造，如果有多个父类，则按照声明顺序
析构过程为：子类先析构，最后父类再析构
深拷贝与浅拷贝的区别
这个区别一般发生在类中有成员变量为指针的时候
深拷贝：就是将指针所指的整块内存区域都拷贝的行为
浅拷贝：只拷贝指针的笨比行为（其实在移动语义下还是有用的）
空类有哪些函数？空类的大小？
空类有的函数就是默认的那六个函数：缺省构造函数、缺省拷贝构造函数、缺省析构函数、缺省赋值运算符、缺省取址运算符、缺省取址运算符 const
空类的大小会被设置为1，因为空类也有可能被实例化，而实例化的对象是要具有唯一内存地址的。因此空类的大小会被设置为1才能保证实例化的时候拥有唯一的内存地址
类的移动语义函数
一般来说主要有移动构造函数和移动拷贝函数。原理其实就是与浅拷贝类似，不重新开辟内存空间拷贝对象的数据，而是直接获得临时对象的内存，省去对临时对象的拷贝然后再赋值这么一个耗时耗力的步骤。可以有效提升性能。但是要注意，使用移动语义需要将原本指向这一块内存的指针置为空，否则很容易造成内存泄露
虚函数相关（必考点）
只要类里面有虚函数，那么在该类实例化对象的内存布局上，就会在最开头加上一个虚指针（大小为系统位数，32为4字节，64为8字节）。虚指针会指向一个虚表（存放在全局存储区，因为一个类的所有对象共享一个），然后该表里的指针又会指向不同的虚函数地址。
子类重写的虚函数会重新开辟一片内存，并且更改虚表中的指针，令其指向更改过后的函数地址，该函数绑定方式也被叫做动态绑定
虚函数是支持多态最重要的部分，比如下面这个例子：
类的内存对齐
内存对齐是为了提高内存的访问效率而存在的东西。比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐
内存对齐是一个比较简单的规则（相关例题很多，这里就请自行搜索了）：
重载、重写与隐藏
重载：是指同一可访问区内被声明的具有不同参数列的同名函数，不关注返回类型
重写：是指在派生类中存在重新定义的函数（函数名，参数列表，返回值类型都必须同基类中被重写的函数一直），一般在基类中必须有Virtual修饰
隐藏：是指派生类的函数屏蔽了与其同名的基类函数（只要同名，不管参数列表是否相同就会隐藏）
构造函数能否为虚函数？析构函数为什么一定要是虚函数？
构造函数不能为虚函数，虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。
析构函数一定要是虚函数的主要原因是为了防止内存泄露。
此外，构造函数是没有this指针的！
C++内部缺省的成员函数：
缺省构造函数
缺省拷贝构造函数
缺省析构函数
缺省赋值运算符（=）
缺省取址运算符（&amp;）
缺省取址运算符（&amp;）的const版本
内存管理相关 C++内存分区：栈区、堆区、全局/静态存储区、常量存储区、代码区
栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中，因此效率很高，但是分配的内存容量有限
堆区：就是那些由new分配的内存块，他们的释放不归编译器管理，而由应用程序去控制。一般一个new就对应一个delete。如果程序员没有手动释放掉这一块内存，那么程序结束后，操作系统会自行进行一个回收
全局/静态存储区：在C++中，统一存放全局变量和静态变量的一块内存空间。全局/静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在。需要注意的是，整个存储区内不存在没有初始化的变量，如果我们没有去做初始化操作，那么程序会按照默认方式初始化这些变量
常量存储区：存储的一般是字符串常量，书上将其划分到了全局存储区，统一称为数据区。（我觉得都行，只要你知道这两个东西能放在一块就行）需要注意的是，局部常量是不放在常量存储区的。
代码区：程序被操作系统加载到内存时，所有可执行的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运行时，这段区域数据不可被修改只可以被执行。同时，这一个分区是共享的，目的是为了让多次运行的程序可以只保留一份代码副本，节约空间内存泄漏
我们一般所说的内存泄露都是指堆上的内存泄露了。一般说的都是程序申请了一块堆上的内存然后忘记准确释放或者是释放后忘记置空指向这块区域的指针的情况。总而言之，只要是内存操作错误其实都可以被归结为内存泄露。悬空指针和野指针
悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这片空间
野指针：是指其指向不明确的指针，是没有通过初始化得到的指针智能指针
智能指针就是为了解决内存泄露问题而出现的指针。简而言之，它其实是一个类，通过析构函数来释放掉自己所指向的内存空间。同时，还可以防止多次释放同一内存空间，以及将值语义转换成引用语义
智能指针有三种：auto_ptr(貌似已经弃用)，unique_ptr以及shared_ptr,weak_ptr,unique是独享指针而share是共享资源指针，有些时候会让手撕一个share_ptr 关键字相关 new和delete与malloc和free
new和delelte是C++的关键字，而malloc和free是库函数，需要头文件的支持
使用new操作符申请分配内存时，无须指定内存块大小，编译器会根据类型自动计算，而malloc会需要显式的制定内存大小
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换。所以new是符合类型安全性的操作符。而malloc内存分配成功返回的是void*，需要通过强制类型转换将void*转成我们所需要的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2974d482648c420fd075216e19270d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c5c0b0f51f32007cd2433177d2b555/" rel="bookmark">
			ajax中for循环中怎么使用if,在ExtJS中，我可以在Ajax请求中调用for循环和if语句来定义我的参数吗？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想通过我在fieldSet中的复选框进行迭代，如果复选框被选中，我想将复选框的ID添加到数组中，该数组将作为我的Ajax请求的参数之一。在ExtJS中，我可以在Ajax请求中调用for循环和if语句来定义我的参数吗？
我意识到我可以创建一个复选框组，但我是ExtJS的新手，直到创建每个单独的复选框后才查找有关Checkboxgroup。
到目前为止，我有这个..
function submitEntry(){
Ext.Ajax.request({
url: '../../inc/project4.php',
var obj = Ext.select('input[type=checkbox]').elements;
var i = 0;
for (i=0; i
if (obj[i].checked) {
params:{
symptom[]: obj[i].getId()
}
}
}
params: {action: 'create_input',
description: entryBox.getRawValue(),
},
method: 'POST',
success: function(f,a){
var jsonData = Ext.util.JSON.decode(f.responseText);
if(jsonData.success == true){
Ext.Msg.alert("Success!", "Your journal entry has been sent!");
entryStore.reload();
entryBox.reset();
}
else{
Ext.Msg.alert("Error! Please check your entry and try again.")
}
},
failure: function(f,a){
if(jsonData.success == false){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8c5c0b0f51f32007cd2433177d2b555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512969a23f165ee2bab1f7d10df3e735/" rel="bookmark">
			ajax是异步非阻塞,[转帖]再谈IO的异步，同步，阻塞和非阻塞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提概要：
IO的过程：
整个IO的过程其实是应用发起IO的请求，到应用获取到IO请求数据的中间过程。
这个中间，其实主要的时间就是系统准备数据的过程。这也是异步技术的优化所在。
对系统调用的理解：
首先，我们要明确一点。IO的操作属于一种系统调用。也就是应用在运行中，进入到内核代码来执行某些重要的操作。
其实我们可以把系统调用看做是一个通信的过程。应用程序是A，操作系统是K。这就类似于一个C/S的模型。A向K发送请求信息。(系统调用)
K返回给A信息。(返回值)
会话结束。(我们认为，这样就是一个完整的通信过程)
当然，也可能会出现这样的通信过程。B发送给A信息。(比如回调)
会话结束。
一次IO请求，可能是一个通信过程，也可能需要多个通信过程。这就是各种IO的区别。
同步和异步：
同步：
由应用(A)向K发起请求，到A获取数据，期间一直是A作为会话的发起者。
异步：
和同步相反的自然就是异步。异步中，A获取数据这次会话，是由K发起的。
注意：这里有点困惑的是，K通知A时，可以直接把数据给它，也可以告诉A我准备好了，你来请求吧。感觉二者的区别应该就是IOCP和Epoll的区别。后者给人的感觉就是，异步中带有同步。网上的异步阻塞应该也就是这个。
区别：
可以看出，二者的区别就是在于最终获取到数据这个会话，是哪边发起的。对于应用而言，主动就是同步，被动就是异步。(这个有点像CPU的同步/异步中断)
阻塞和非阻塞：
它们的区别主要在于IO请求发起，直到获得数据，这段时间，应用是等着还是不等着。
阻塞：
阻塞，就是应用等待着，不干活。
其实对于操作系统而言，阻塞不是什么坏事，不然要我操作系统干嘛。操作系统功能之一就是系统资源的调度，当某个进程(线程)阻塞了，它就能调度CPU资源给别的进程。这其实能提高不少利用率。
非阻塞：
看网上不少人说，这看上去是个差一点的方案。它是让应用不断的轮询，直到拿到数据。它相比于阻塞，会浪费一些CPU，自然性能也就会差一些了。
总结：
各种IO设计不同，但目的是一样的。都是为了让应用程序跑的更快，系统资源利用的更充分。
异步对于同步的优化点：
我一直觉得异步多进程和同步的性能并没有什么差异。因为我们的优化点是在发起IO请求到获得请求数据之间的这段时间。这段时间如果等着，那就浪费了。同步程序中(阻塞模式)，多进程的情况下，操作系统的调度让阻塞的程序停止，把CPU给另一个需要CPU的进程，比如计算，处理。
异步程序的话，程序自身就不阻塞，像一个工厂流水线一样，只要上面工件下来，干完扔给下一步就行。(有可能回到上一步，也就是回调)
看上去，二者用了不同的方法优化了那段时间。其实把同步的程序从操作系统调度的层面来看，它也是异步的，对于操作系统而言，进程就是一个task_struct嘛，现在的CPU和IO设备其实就是异步的。
所以，准确的说，是应用程序的同步还是异步。二者的区别在于代价，也就是管理的灵活和切换的性能损耗。因为在同步程序中，第一步完成后，需要切换任务。而异步程序就不需要了，它继续干它自己的活。那么切换的代价就小了。
有人说，协程让用户使用同步的方式写出异步的性能。主要也是因为协程的切换代价小。再看IOCP的设计，为了最有效的利用操作系统，它使用了线程池，其目的也就是让线程能保持一个合理的数量。
该阻塞还是非阻塞：
阻塞其实就是把调度的权力给了操作系统，让操作系统来提高利系统用率。非阻塞则是把这个权力给了开发者，因为不阻塞的话我们可以做些别的事情，类似于程序内部的一个调度功能。
协程就是在系统调用时，内部跳转到别的协程代码去执行。类似于是自己实现了一个轻量级的调度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb7e8ae68cc9994b317b4e196d020c2/" rel="bookmark">
			ajax官方api,yangguozhong
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AjaxApi
下面列出的接口基本都是可以直接使用的，如有问题记得告诉我哦
1. 支持的请求方法
GET(SELECT)：从服务器取出资源(一项或多项)。
POST(CREATE)：在服务器新建一个资源。
PUT(UPDATE)：在服务器更新资源(客户端提供改变后的完整资源)。
PATCH(UPDATE)：在服务器更新资源(客户端提供改变的属性)。
DELETE(DELETE)：从服务器删除资源。
HEAD：获取资源的元数据。
OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。
2. 通用返回状态说明
状态码
含义
说明
200
OK
请求成功
201
CREATED
创建成功
204
DELETED
删除成功
400
BAD REQUEST
请求的地址不存在或者包含不支持的参数
401
UNAUTHORIZED
未授权
403
FORBIDDEN
被禁止访问
404
NOT FOUND
请求的资源不存在
422
Unprocesable entity
[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误
500
INTERNAL SERVER ERROR
内部错误
3. 笑话
3.1 获取一条随机笑话
随机获取笑话的接口
3.2 获取多条随机笑话
随机获取笑话的接口
请求方法：get
请求参数：num
参数名
参数说明
备注
num
笑话条数
类型为数字,不要给错了
响应内容：JSON
{
"msg":"获取5条笑话",
"jokes":[
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb7e8ae68cc9994b317b4e196d020c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa382cc0b8f86e661cd7c74e262367e/" rel="bookmark">
			vscode-git中的U、M和D文件标记不显示，vscode提示找不到Git安装路径。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在vscode中写Git项目时，文件状态标识不显示。源代码管理器中没有东西。两个问题的原因是一样的，效果图见下方。
二、问题的原因 vscode找不到git文件，或者说git.path未设置。
三、解决方法 1.打开vscode中的设置 &gt;&gt; 搜索 git path &gt;&gt; 点击“在settings.json中编辑”
2.找到自己的git.exe路径
注意
不要使用默认的windows路径风格，例如：E:\Git\Git\bin\git.exe。要使用linux风格，例如：E:/Git/Git/bin/git.exe。 3.粘贴到settings.json文件中
3.保存并重启vscode。
4.成功！！
四、知识点补充：文件标识的含义 1.代码里的左侧颜色标识:
红色，未加入版本控制; (刚clone到本地)
绿色，已经加入版本控制暂未提交; (新增部分)
蓝色，加入版本控制，已提交，有改动； (修改部分)
白色，加入版本控制，已提交，无改动；
灰色：版本控制已忽略文件。
2.git文件标识:
A: 增加的文件.
C: 文件的一个新拷贝.
D: 删除的一个文件.
M: 文件的内容或者mode被修改了.
R: 文件名被修改了。
T: 文件的类型被修改了。
U: 文件没有被合并(你需要完成合并才能进行提交)
X: 未知状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5c907c52b44a397f7656058c4046d1/" rel="bookmark">
			ajax .d,JQuery Ajax data.d解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JQuery Ajax data.d含义
实际应用中有代码：
$.ajax({
url: 'EmailExist.action',
data: '{email:"' + email + '"}',
type: 'post',
dataType: 'json',
contentType: 'application/json; charset=utf8',
cache: false,
success: function(data) {
if (data.d) {
setTimeout(function() {
//$('#ctl00_holderLeft_txt_email').val('');
$('#tip_email').removeClass('validation-valid');
$('#tip_email').addClass('validation-error');
$('#tip_email').html('邮箱quot;$' + email + 'quot;$已存在，请使用其他邮箱');
}, 10);
}
//else
//$('#tip_email').html("邮箱输入成功"); 何问起
},
error: function(xhr) {
$('#tip_email').html(xhr.responseText);
}
});
其中的data.d解析如下：
d是asp.net webservice返回的json对象的属性(包含你return 返回的内容)，其他内容都放在d属性里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e95e4670cde8a51f1294338b2eed4f/" rel="bookmark">
			drupal ajax 分页,drupal call ajax function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$delete_commant = l(t('X'), $url, array('attributes' =&gt;
array('onclick' =&gt; 'return call_ajax(123)')));
when i put alert in call_ajax function definition, it is alerted, so i proceed to write the ajax post method, but when i click the link page getting refresh,
How to implement ajax in drupal
function call_ajax(str){alert(str);
var url = "post.php";
var params = "lorem=ipsum&amp;name=binny";
http.open("POST", url, true);
//Send the proper header information along with the request
http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e95e4670cde8a51f1294338b2eed4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4264e9f77af547035d530a1350ea0a57/" rel="bookmark">
			云服务器一般用什么系统,云服务器用什么系统好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器用什么系统好?目前，市面上的云服务器操作系统主要分为两大类：Linux和Windows，其中每类操作系统还包括不同的发行版本。
一般来说，如果你需要asp、asp.net+SQLServer 架构，则应该使用Windows系统，如果是php+MySQL架构，云服务器使用Linux系统比较好。
Windows 操作系统
Windows Server是专为服务器设计的专有操作系统。它包括Microsoft开发的服务器应用程序，如IIS Web服务器，用于支持虚拟化的工具，以及包括防火墙的安全工具。支持asp开发的网站。
如果用户选择Windows主机的话，将额外支付该系统的版权费用。不过，有的云服务商也是有Windows正版授权的，比如西部数码。
Linux 操作系统
Linux系统拥有大量的发行版可用，每个发行版都提供了一个完整的服务器操作系统和一个管理器，常用的发行版如 CentOS、Ubuntu和Debian。
CentOS：是初学者配置云服务器的首选。去除了很多与服务器功能无关的应用，系统简单但非常稳定，占用资源少，命令行操作可以方便管理系统和应用，并且有帮助文档和社区支持。
Debian：是技术实力强的站长首选系统。它没有太多的花哨，稳定压倒一切，内核和内存的占用都非常小。对于小内存首选debian，非常熟悉linux系统的云服务器资深人士首选debian。
Ubuntu：适合资金充裕的站长使用。Ubuntu有亮丽的用户界面，完善的包管理系统，强大的软件源支持，丰富的技术社区，并且对计算机硬件的支持好于centos和debian，兼容性强，应用非常多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a7c193d905f61c6fdc412abfb9fa01/" rel="bookmark">
			ajax请求then和done的区别,jQuery.ajax处理继续响应：“success：”vs“.done”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		料青山看我应如是
success一直是jQuery成功回调的传统名称，定义为ajax调用中的一个选项。但是，由于实现了$.Deferreds更复杂的回调，因此done是实现成功回调的首选方法，因为它可以在任何回调上调用deferred。例如，成功：$.ajax({
url: '/',
success: function(data) {}});例如，完成：$.ajax({url: '/'}).done(function(data) {});好处done是，返回值$.ajax现在是一个延迟的promise，可以绑定到应用程序中的任何其他位置。所以，假设你想从几个不同的地方进行这个ajax调用。而不是你的成功传递函数作为一个选项，以使这个Ajax调用的功能，你可以有函数返回$.ajax自身和绑定你的回调done，fail，then，或什么的。请注意，always无论请求成功还是失败，都将运行回调。done只会在成功时触发。例如：function xhr_get(url) {
return $.ajax({
url: url,
type: 'get',
dataType: 'json',
beforeSend: showLoadingImgFn })
.always(function() {
// remove loading image maybe
})
.fail(function() {
// handle request failures
});}xhr_get('/index').done(function(data) {
// do stuff with index data});xhr_get('/id').done(function(data) {
// do stuff with id data});在可维护性方面，这一点的一个重要好处是，您已将ajax机制包装在特定于应用程序的函数中。如果您决定$.ajax将来需要以不同的方式运行，或者使用不同的ajax方法，或者您不再使用jQuery，则只需更改xhr_get定义(确保返回承诺或至少返回一个done方法，以上例子的情况)。整个应用程序中的所有其他引用可以保持不变。您可以使用更多(更酷)的事情$.Deferred，其中之一是pipe用于触发服务器报告的错误的失败，即使$.ajax请求本身成功。例如：function xhr_get(url) {
return $.ajax({
url: url,
type: 'get',
dataType: 'json'
})
.pipe(function(data) {
return data.responseCode != 200 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a7c193d905f61c6fdc412abfb9fa01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdb548940afc380a9463fa4de551362/" rel="bookmark">
			不进ajax,为什么ajax方法就不进去，有错吗？大神们解答一下啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满意答案
easonled
2018.01.02
采纳率：57% 等级：7
已帮助：1759人
只能告诉你个调试方法，你写的js未必有问题：
我建议你把，error，写上。errorq签名：error:function(xhr,emsg,e);参数代表，ajax的原始请求，emsg代表错误的文本描述，e代表错误对象。
//下面会打印出为什么你的ajax不会执行success回调该执行的函数：
error:function(xhr,emsg,e) {
//打印ajax发生的错误
console.log(e);
//答应出ajax请求返回的文本信息
console.log(xhr.responseText());
}
返回数据格式是json，有以下可能：
1、url,404错误，代表你的url写错了，或者服务器配置的url错误；
2、解析json数据，分两种情况：
a、服务器返回的json数据格式有问题，如常见错误：键必须用双引号包裹，值中的双引号必须转义成\”。值中的换行，回车必须转义成\n，\r.产生这些错误一般是因为自己拼装JSON串，考虑不周到造成的。使用框架，框架会帮处理
b、json数据过大，导致客户端无法解析JSON，需要想办法把请求返回结果变小一些，比如返回分类查询结果，或者一次返回分页查询结果等。
c、服务器本身报错，抛出了html报错信息，你要的数据是json必然出问题。
3、服务器解析json数据要求，带.json结尾或请求头中需要accept=application/json.你提供的url或请求头错误。
4、传输编码错误，ajax一般使用UTF-8编码，有乱码造成json解析不出来，如出现不该出现的”,回车，换行导致数据无法解析成json。
00分享举报
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f4a40796b6ca059dbe7de6d915cc862/" rel="bookmark">
			axios 底层是ajax吗,axios和ajax及fetch原理浅析(示例代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios和ajax及fetch原理浅析
这三个其实都是用来请求数据的，那他们的区别在哪里呢？其实 axios 和 ajax
都是对XMLHttpRequest这个对象的封装；而fetch则是window下的一个方法，是一个更底层的方法。
ajax
其实重点就是首先实例一个XMLHttpRequest对象，用其中的open方法建立连接；send方法传输数据(前端传到后台)；然后再利用onreadystatechange 监听readyState的变化，当其为4时，代表请求完成；简单的代码实现如下：
const Ajax={
get: function(url, fn) {
// XMLHttpRequest对象用于在后台与服务器交换数据
var xhr = new XMLHttpRequest();
xhr.open(‘GET‘, url, true);
xhr.onreadystatechange = function() {
// readyState 为4说明请求已完成
if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
// 从服务器获得数据
fn.call(this, xhr.responseText);
}
};
xhr.send();
},
// datat应为‘a=a1&amp;b=b1‘这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式
post: function (url, data, fn) {
var xhr = new XMLHttpRequest();
xhr.open("POST", url, true);
// 添加http头，发送信息至服务器时内容编码类型
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f4a40796b6ca059dbe7de6d915cc862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa490417eec44713eb3c55f844199e7/" rel="bookmark">
			ajax怎么解决报414,如何解决HTTP 414“请求URI太长”错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 月关宝盒
根据约翰的回答，我将GET请求更改为POST请求。它可以工作，而无需更改服务器配置。所以我去寻找如何实现这一点。以下页面是有帮助的：带有PHP的jQuery Ajax POST示例 (注意清理发布的数据注释)和http://www.openjs.com/articles/ajax_xmlhttp_using_post.php基本上，区别在于GET请求在一个字符串中包含url和参数，然后发送null：http.open("GET", url+"?"+params, true);http.send(null);而POST请求通过单独的命令发送url和参数：http.open("POST", url, true);http.send(params);这是一个工作示例：ajaxPOST.html：
ajax POST Test &lt;?php $lorem=$_POST['lorem'];print $lorem.' ';?&gt;我刚发送了12,000个字符，没有任何问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2922cfd16d1408311538d558ed0bbd/" rel="bookmark">
			javascript ajax for,通过javascript中的ajax保护JSON响应（for（;;）;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我一直在阅读，我知道有类似的问题，但我找不到我想要的答案。
因此，在ajax响应输出JSON字符串之前，它是关于(；)；while(1)；的。
现在我想知道的是这将如何工作？我想尝试使用和许多著名网站一样的技术，比如facebook with for(；；)；
所以在ajax.php文件中，我认为必须这样做：
阿贾克斯.php
$arr = array("value" =&gt;"something","moreValues" =&gt;"moreSomething");
die("for(;;);".json_encode($arr));
现在的答案是：
for(;;);{"value":"something","moreValues":"moreSomething"}
号
我现在该怎么处理这根绳子？我是否应该删除(；)；用一个子字符串或其他东西，然后使用json.parse(string)；(那么，如果我要直接删除它，为什么还要在响应中发送for(；)。？
这将如何帮助我解决安全问题，如果出现问题，"用户"将如何进入(；；)的无限循环？
我知道我遗漏了一些东西，而且我还没有找到任何演示如何执行此操作的示例。有人吗？如果你发现这个问题是重复的，请参考一个例子，它是用代码而不是文字来演示的。谢谢！
stackoverflow.com/questions/2669690/&amp;hellip；和stackoverflow.com/questions/6339790/&amp;hellip；
我已经读了这些文章20遍了，我想用更多的无代码单词来更好的演示。
如果你读过这些问题并回答了20次，你就不会问像What shall I do with this string now?、Then why did I even send the for(;;); in the response if i'm going to remove it directly..?、And how will this help me with security issues, and how will a"user" enter the infinity loop for(;;); if something is wrong?这样的问题了。
如果你知道答案，你能用代码告诉我这是如何工作的吗？
你已经解决了-shall i remove for(;;); with a substr or something and then use JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2922cfd16d1408311538d558ed0bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890440bffcea88fb1f55fd02384f928f/" rel="bookmark">
			100台电脑无盘服务器配置,100台机子建立一个无盘工作站，用什么结构什么配置..... 爱问知识人...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、无盘工作站启动原理无盘工作站之所以能够启动，是由硬件(工作站端)和软件(服务器端)共同配合的结果。软件上，就是服务器上的远程启动相关服务和无盘系统软件；硬件上，则是工作站网卡上的BootROM芯片。当然，对于不是很老的主板，其BIOS中空闲较多并支持写入，可以将BootROM芯片代码写入主板BIOS中，节省了一个芯片。
较常用的无盘启动芯片有RPL和PXE两种。这两种较为通用，其它还有一些厂商开发的专用芯片，不是很普及，以下的讨论中均以RPL和PXE为主。RPL芯片可用于10M和100M的网卡，有针对NT(2000)的，有针对NetWare的。不同的网卡用的也不一样，需要配套。
所以做无盘时不是任何网卡都能做的。10M的NE2000和8029网卡、100M的8139网卡等都支持RPL芯片，并且也都容易找到相应的RPL芯片。PXE芯片一般用于100M的网卡，以在8139网卡上的应用最为成熟和典型，甚至很容易就可找到用于8139网卡的PXE芯片代码(用于写入主板或空白BOOT片)。
现在较常见的是那种RPL/PXE双启动的BootROM芯片，价格在6元左右。1、RPL芯片的启动原理。(1)发现阶段。当Client启动后，其网卡上的BootROM会向Server广播一个引导请求帧，即FIND帧，该帧包含有Client的网卡号(MAC地址)，网络上所有Server都会发现这个FIND帧。
(2)提供阶段。Server远程启动服务收到Client广播的FIND帧，根据帧中所带的ID号，检查远程启动数据库中是否有该卡号的配置记录，如果不存在，则引导过程不能继续；如果存在，远程启动服务发送一个FOUND帧，这个帧中包含了服务器的岗卡ID(即Server的MAC地址)，然后就调用BOOTP(Boot Protocol)或者DHCP(Dynamic Host Configuration Protocol)。
(3)选择阶段。Client收到第一个响应后(因为可能网络中不止一个服务器在运行远程启动服务，Client只对收到的第一个FOUND帧回应，包括：分配给Client的机器名称、IP地址、Server的IP地址、BOOT所需的映像文件等)，则发送一个SEND。
FILE。REQUEST Frame给第一个回应的远程启动服务器，请求传送启动所需的文件。
4)确认阶段。当远程启动服务器收到SEND。FILE。REQUEST Frame的请求后，根据其远程启动数据库的Client记录查找对应的BOOT BLOCK，将Client启动所需的文件传送给Client，即给工作站一个FILE。
DAT。RESPONSE帧，这个帧 包含了Client启动所需的BOOT BLOCK。(5)启动阶段。Client接收到完整的启动文件后，开始执行文件中的程序，将执行点转向启动块的入口，启动Client，同时使用另外一个INTERNET协议：TFTP(Trivial Transfer Protocol)。
然后引导不同的OS。2、PXE芯片的启动原理。PXE是RPL的升级品，它是Preboot Execution Environment的缩写。它们的不同之处为：一个是静态路由，一个动态路由。不难理解：RPL是根据网卡上的ID号加上其它的记录组成的Frame向server发出请求，而server那里早已经有了这个ID数据，匹配成功则进行远程启动；PXE是则是根据服务器端收到的工作站MAC地址(就是网卡号)，使用DHCP服务给这个MAC地址指定一个IP地址，每次重启动可能同一台工作站有与上次启动有不同的IP，动态分配地址。
下面以工作站引导过程说明PXE的启动原理：
(1)用户端电脑开机后, PXE Boot ROM 获得控制权之前先做自我测试，然后以广播形式发出一个请求FIND帧。
(2)如果服务器收到个人电脑所送出的要求, 就会送回 DHCP 回应, 内容包括用户端的 IP 地址, 预设通讯通道, 及开机映像文件。
否则, 服务器会忽略这个要求。
(3)工作站收到服务器发回的响应后则会回应一个FRAME，以请求传送启动所需文件。
(4)之后，将有更多的讯息在用户端与服务器之间作应答, 用以决定启动参数。 BootPROM 由 TFTP 通讯协议从服务器下载开机映像档, 这个映像档就是软盘的映象文件。
(5)工作站使用TFTP 协议接收启动文件后，将控制权转交启动块，引导操作系统，完成远程启动。
全部
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/302/">«</a>
	<span class="pagination__item pagination__item--current">303/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/304/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>