<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bd6d2d377b584aa1df901726f1059e/" rel="bookmark">
			python中的“*”，解包操作--将tuple与list中的数据解包成孤立的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def show_tensor_images(image_tensor,num_images = 25,size=(1,28,28)): images = image_tensor.detach().cpu().view(-1,*size) image_grid = make_grid(images[:num_images], nrow = 5) plt.imshow(image_grid.permute(1,2,0).squeeze()) plt.show() 上面的代码是一个将tensor图像进行显示的一个简单代码，但是我看到代码的时候不知道第二行size前面的*是起一个什么作用， 将其去掉之后，该位置报错：
TypeError: view(): argument 'size' must be tuple of SymInts, but found element of type tuple at pos 2。
大致意思就是这个位置需要是int类型但是读到了元组，我们平时使用view函数的之后一般会指定维度比如view（1,2,4）这样设置通道为1，宽高为2,4，但是在上面的函数中，size给了一个列表其中包含了1,28,28这三个数字，所以按照传参的逻辑来说，如果没有*的话传入view的参数就为:
-1，[1,28,28]，这显然是不正确的，另外分别打印size与*size的结果
从这里就可以看出来，*的作用是将tuple中的内容解码成孤立的数据。从而实现了[-1,*size]到[-1，1，28，28]的转换。
很好，既然元组可以，那么列表呢？试试看。
将上面（）改成[ ]发现*也能实现列表的解包。相应的{ }的集合也是可以使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e6bfe1f883622ff86473329ecc63db/" rel="bookmark">
			python——http/https文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、http import requests ''' 通过http上传文件 :param file_path: 待上传文件的路径 :return: 返回的请求句柄 ''' def upload_files_by_http(file_path, url=http_url): with open(file_path, 'rb') as f: file_date = {'file': f} url = url + 'submit' r = requests.post(url=url, files=file_date) return r 二、https import requests ''' 通过https上传文件 :param file_path: 待上传文件的路径 :return: 返回的请求句柄 ''' def upload_files_by_https(file_path, url=http_url): with open(file_path, 'rb') as f: file_date = {'file': f} url = url + 'submit' r = requests.post(url=url, files=file_date, verify=False) return r 三、封装使用 ''' 此函数引用了上面的http传输方法，此函数是对结果加以校验 trans_res为传输文件结果验证方式，True为传输成功，False为传输拦截 ''' def http_upload_file(file_path, http_url, trans_res) try: rsp = upload_files_by_http(file_path, http_url) result = rsp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8e6bfe1f883622ff86473329ecc63db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab2f628354c580be2f9f91bd5f9b761/" rel="bookmark">
			const关键字不同使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const关键字它主要用于声明常量，这意味着一旦一个变量被声明为常量，其值就“不能被改变”，这个“不能被改变”也不是绝对的不能发生任何变化，具体场景如下：
1.声明常量变量： 常量变量在编译时赋值，并且在其生命周期内不能发生改变。
int main() { const int const_val = 1; const_val = 2; // 错误，不能对常量const_val修改 return 0; } 2.指针和常量： 1.指向常量的指针： 这样的指针不能修改它所指向的值，但可以更改指针本身所指向的地址。
int val = 1; const int* p = &amp;val; // 这种情况下，可以理解为，const修饰的是“值” // *p = 2; // 错误，不能修改p所指向的值 int new_val = 2; p = &amp;new_val; // 正确，可以更改p的指向 2.常量指针： 这样的指针的值（即它所指向的地址）在初始化后不能更改，但可以通过该指针修改它所指向的值（除非该值本身也是常量）。
int val = 1; int* const p = &amp;val; // 这种情况下，const修饰的是指针，所以指针指向的地址不能改变 *p = 2; // 正确，可以修改所指向的值 int val2 = 2; p = &amp;val2; // 错误，不能更改指针p的地址指向 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab2f628354c580be2f9f91bd5f9b761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e83bbc9cd5531196a801dfab99192a0/" rel="bookmark">
			计算机软件文档编制规范GB_T 8567-2006
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明 本文原创作者：谷哥的小弟作者博客地址：http://blog.csdn.net/lfdfhl 计算机软件文档编制规范概述 计算机软件文档编制规范（Specification for computer software documentation） 由TC28（全国信息技术标准化技术委员会）归口，TC28SC7（全国信息技术标准化技术委员会软件与系统工程分会）执行 ，主管部门为国家标准化管理委员会。
主要起草单位如下：中软网络技术股份有限公司 、信息产业部电子工业标准化研究所 、北京联想软件有限公司 、用友软件股份有限公司 。
该规范主要起草人如下：周明德 、冯惠 、韩乃平 、欧阳春生 、殷树勋 、黄万镒等 。
计算机软件文档编制规范官方链接：https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D7FDE1D3A7E05397BE0A0AB82A
现行计算机软件文档编制规范 现行计算机软件文档编制规范为GB/T 8567-2006，它替代了1988执行的GB/T 8567-1988 ；关于该文档的其它背景请在全国标准信息公共服务平台查阅详情，官方链接如下：https://std.samr.gov.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74114622f8c0da84eab4c11923d927f8/" rel="bookmark">
			css--浮动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一. 浮动的简介 在最初，浮动是用来实现文字环绕图片效果的，现在浮动是主流的页面布局方式之一。
二. 元素浮动后的特点 🤢脱离文档流。😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽
高。😊不会独占一行，可以与其他元素共用一行。😊不会margin 合并，也不会margin 塌陷，能够完美的设置四个方向的😊不会像行内块一样被当做文本处理（没有行内块的空白问题） 三. 解决浮动产生的影响 元素浮动后会有哪些影响 对兄弟元素的影响：
后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；
对前面的兄弟无影响。对父元素的影响：
不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 解决浮动产生的影响（清除浮动）
解决方案：
方案一： 给父元素指定高度。方案二： 给父元素也设置浮动，带来其他影响。方案三： 给父元素设置 overflow:hidden 。方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。
===&gt; 推荐使用
.parent::after {
content: “”;
display: block;
clear:both;
} 四. 浮动相关属性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a9cc0a6a3c619f2ad2bebbb4e28e0a/" rel="bookmark">
			【Spring Boot `@Autowired` Annotation】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 使用`@Qualifier`注解2. 使用`@Primary`注解3. 手动注入（较少推荐） 在Spring Boot中，@Autowired注解用于自动装配bean。默认情况下，它按照类型进行装配。当存在多个相同类型的bean时，就会出现以下错误：
*************************** APPLICATION FAILED TO START *************************** Description: Field &lt;fieldName&gt; in &lt;ClassName&gt; required a single bean, but &lt;number&gt; were found: - BeanA: defined in file [&lt;path/to/BeanA.class&gt;] - BeanB: defined in file [&lt;path/to/BeanB.class&gt;] 这种情况下，Spring无法明确选择哪个bean进行注入，因为存在多个匹配项。
解决这个问题有几种方式：
1. 使用@Qualifier注解 结合@Qualifier注解，指定要注入的bean名称。这样可以明确告诉Spring应该选择哪个bean。
示例：
@Component public class YourClass { @Autowired @Qualifier("beanA") // 使用指定的bean名称 private YourInterface yourBean; } 2. 使用@Primary注解 在作为默认首选的bean上使用@Primary注解。这个bean会成为首选项被注入到需要的地方。
示例：
@Component @Primary public class PrimaryBean implements YourInterface { // Implementation } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a9cc0a6a3c619f2ad2bebbb4e28e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b4687a208f79ea520d98f186bacb10/" rel="bookmark">
			scipy.cluster.hierarchy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数原型：
scipy.cluster.hierarchy.linkage(y, method=‘single’, metric=‘euclidean’, optimal_ordering=False)
method = ‘average’
网址：
学习链接1
学习链接2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b456003c2a5351881d134467d1ef5a3/" rel="bookmark">
			Excel F4键的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一. 单元格相对/绝对引用转换二. 重复上一步操作 一. 单元格相对/绝对引用转换 ⏹ 使用F4键
如下图所示，B1单元格引用了A1单元格的内容。此时是使用相对引用，可以按下键盘上的F4键进行相对引用和绝对引用的转换。
二. 重复上一步操作 ⏹添加或删除行
先手动删除或者添加一行之后，再按下F4键，就会重复上一步的操作，不断的添加或者删除行 ⏹字体加粗
先按下Ctrl + B加粗一个单元格，然后剩下的就可以直接按下F4来加粗了或者也可以按下Ctrl一个个的选中，然后统一加粗。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97043e9fac043ab992dd05973de45783/" rel="bookmark">
			计算机网络(基础篇)复习笔记——体系结构/协议基础（持续更新中......)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 计算机网络基础相关技术Rip 路由更新操作 2 体系结构(OSI 7层, TCP/IP4层)应用层运输层网络层IPv4无分类域间路由选择 CIDRIPV6 数据链路层循环冗余校验CRC协议设备 物理层传输媒体信道复用技术宽带接入技术数据通信 3 网络局域网(以太网Ethernet) 4 通信过程编码:信道极限容量 5 名词解释待续、更新中 1 计算机网络基础 三大特征:信息化 /网络化/数字化
分类1: 计算机网络/电信网络/有线电视网 ;互联网(资源共享/共享)与互连网
分类2:广域网WAN/城域网Man/局域网LAN/个人局域网PAN
分类3: 公用网/专用网
发展历史:arpanet/三级结构互联网(主干网/地区网/校园网)/ISP结构的互联网(主干ISP/地区ISP/本地ISP)
组成:边缘(C/S或P2P模式通信)/核心部分(电路/报文/分组交换)
性能:
1速率:
1Gb=10^3 Mb=10^6 Kb =10^9bit
1GB=1024MB=2^20 KB=2^30 Byte=2^30 * 8 bit
2带宽: 频带宽度/最高数据率
3吞吐量:通过某个网络(接口等)的实际数据量
4时延:
发送时延: 电脑处理, =帧长度bit / 发送速率bit/s
传播时延: 通过链路时间,=信道长度m / 传播速率 m/s
处理时延: 路由器处理(查找转发表等)
排队时延: 经过路由器等待处理
时延带宽积:传播时延*带宽
往返时间RTT: 发送时间=数据长度/发送速率(一方主机确认信息的时间)
利用率: 信道利用率和网络利用率
相关技术 互联网交换点 IXP: 两个网络直接相连并交换分组,无需通过第三个网络来转发分组 Rip 路由更新操作 路由器6 收到路由器4的更新路由信息, 尝试更新路由器6的路由表 1 r4 中距离都加1 2 r4中的信息在r6中没有,添加 3 下一跳路由器相同: 若距离变大或小,则更新 下一跳路由器不同, 比较距离, 若小于r6表中距离则更新,否则不更新 2 体系结构(OSI 7层, TCP/IP4层) 由高到低排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97043e9fac043ab992dd05973de45783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7c67d9c1b4a3fa5fce05f090e33965/" rel="bookmark">
			Paimon新版本核心特性和生产实践解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近Apche Paimon发布了最新版本0.7.0，在这个版本中，Paimon对一些新特性进行了增强。
Paimon在数据湖领域发展迅速，未来会在整个数据开发领域占有很重要的地位，今天我们来盘点一下当前能力的特点以及在生产环境中的使用情况。
Look up join 在实时数据开发领域，Look up join一般被认为等效于「维度表关联」。在一些企业的分享中，利用Paimon进行维度表关联，是一个比较常见的方式或者是未来的规划。
在Paimon的最新版本中，针对Look up join做了一些优化如下：
修复了lookup join 不能正确处理维表的 sequence field 问题。 基于 Paimon 的 hash lookup join，添加了 primary key partial lookup 功能。 通过并行读取文件和批加载的方式，加快了维表的初始化数据加载速度。 维度表关联在生产环境中是一个经常被提及和使用的能力，但是目前根据个人经验，利用Paimon/Hudi进行维度表关联目前不是一个很好的选择。主要的不足包括：Paimon/Hudi这样的表本身并不适合存储维度数据，有更好的选择例如Hbase/Redis或者基于这两个框架开发的其他高速存储；此外，维度表关联在复杂/大数据规模下问题非常多，例如缓存命中率/缓存时间/加载频率/访问限速等等，这些问题在大数据量下会被放大，是不得不解决的问题。在很多公司的生产环境针对维度表优化是一个很重要的课题。
所以，大家需要谨慎评估使用湖表的look up join能力。
CDC能力 大家要特别注意的是，CDC能力分两个部分：
第一，CDC入Paimon
这个能力是一个基础能力，Paimon在新的CDC接入支持上越来越完善，这个是各类型湖表都在持续完善的能力。
CDC数据入湖在时效/存储/计算成本上都会有独特的优势，大家可以持续关注。
第二，Paimon CDC能力
这个能力未来是否具备，大家可以持续关注，一旦Paimon具备的CDC能力，未来在技术架构上会有巨大的改变。Paimon将同时具备批读和流读能力，会在某些场景下改变现有的技术架构，那就真的是未来可期。
完善对接Spark/Hive 在结合Spark/Hive方面，能力不断完善，这也是Paimon这类湖表框架未来被更广泛使用的基础。
此外还有一些功能上的改进，例如支持 level0FileCount，它可以用于查看 compaction 作业的进度；time travel能力增强等等。
总之，大家持续关注Paimon社区的发展，未来在生产环境会有更广泛和深入的应用。
300万字！全网最全大数据学习面试社区等你来！
如果这个文章对你有帮助，不要忘记 「在看」 「点赞」 「收藏」 三连啊喂！
全网首发|大数据专家级技能模型与学习指南(胜天半子篇)
互联网最坏的时代可能真的来了
我在B站读大学，大数据专业
我们在学习Flink的时候，到底在学习什么？
193篇文章暴揍Flink，这个合集你需要关注一下
Flink生产环境TOP难题与优化，阿里巴巴藏经阁YYDS
Flink CDC我吃定了耶稣也留不住他！| Flink CDC线上问题小盘点
我们在学习Spark的时候，到底在学习什么？
在所有Spark模块中，我愿称SparkSQL为最强！
硬刚Hive | 4万字基础调优面试小总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7c67d9c1b4a3fa5fce05f090e33965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afd2f72bb7ea4b90498860158c46c51/" rel="bookmark">
			收藏：一个不错的读书笔记做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自极客时间的结构思考力的课程中，主要是分为事实区，发现区和行动区三个部分,有一定借鉴可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfbfd1bd1e955042f96cfc614dc029f/" rel="bookmark">
			Excel 快速填充/输入内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一. Ctrl + D/R 向下/右填充二. 批量输入内容 一. Ctrl + D/R 向下/右填充 ⏹如下图所示，通过快捷键向下和向右填充数据
🤔当选中第一个单元格之后，可以按住Shift后，再选中最后一个单元格，可以选中第一个单元格和最后一个单元格之间的所有连续单元格。
⏹当表格中含有公式，我们想自动填充公式时
可以拖动填充公式选中单元格后，将光标置于单元格右下角，当出现黑色的 + 时，可以双击单元格自动填充 但是如果列太长的话，拖动填充就很不方便。此时如果双击单元格自动填充还不可用的话，可以通过Ctrl + D填充
二. 批量输入内容 按住Ctrl可以选中多重不连续区域输入内容之后，按下Ctrl + Enter可以自动填充 可以配合 Ctrl + G 定位后，再使用Ctrl + Enter批量自动填充 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3931236993f4cbb812afaf958a019f/" rel="bookmark">
			Vue.js&#43;SpringBoot开发大学计算机课程管理平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 实验课程档案模块2.2 实验资源模块2.3 学生实验模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 实验课程档案表3.2.2 实验资源表3.2.3 学生实验表 四、系统展示五、核心代码5.1 一键生成实验5.2 提交实验5.3 批阅实验5.4 新增实验资源5.5 查询实验课程 六、免责说明 一、摘要 1.1 项目介绍 大学计算机课程管理平台包含实验课程模块、实验资源模块、学生实验模块，前端采用Vue.js，采用View UI组件库美化界面，后端采用SpringBoot框架。在操作系统、开发语言、服务器，数据库、连接技术方面，对应使用Window操作系统、Java语言、Tomcat服务器、MySql数据库以及MyBatis技术完成系统搭建，大学计算机课程管理平台基于B/S架构，采用前后端分离架构，用户可以在系统上查询计算机实验课程、下载实验资源。
随着计算机技术日渐成熟，它已进入人类社会的各个领域并发挥着越来越重要的作用。作为计算机应用的一部分，使用计算机对学校的课程信息进行管理，与手工维护课程相比，有巨大的的优势。越来越多的高校开始采用大学计算机课程管理平台，将学生选择的课程和课程资源通过网络进行管理，为学生、教师和教务管理人员提供便利。
大学计算机课程管理平台使用Idea开发工具完成了编码实现。前端采用Vue.js，采用View UI组件库美化界面，后端采用SpringBoot框架。在操作系统、开发语言、服务器，数据库、连接技术方面，对应使用Window操作系统、Java语言、Tomcat服务器、MySql数据库以及MyBatis技术完成系统搭建。该系统基于B/S架构，采用前后端分离架构，用户可以在系统上查询计算机实验课程、下载实验资源。
1.2 项目录屏 二、功能模块 2.1 实验课程档案模块 实验课程档案模块是高校实验教育中用于记录和管理实验课程信息的模块，实验课程档案模块可以记录和管理实验教学的过程和结果，帮助教师更好地评估学生的知识获取水平和实验操作技能，确保实验教学质量，实验课程档案模块可以记录实验教学的详细过程和结果，使教师能够在后续的实验教学中更有效地管理教学，安排教育资源，提高实验教学的效率，实验课程档案模块提供了丰富的实验数据和结果，使教师能够轻松评估和改进自己的实验课程，并为未来的实验教育提供有力支持，实验课程档案模块记录了实验教学的基本信息、过程和结果，可以为实验教学的研究和考核提供基础数据和资料，实验课程档案模块对高校实验教学是非常必要的，通过实验课程档案模块，可以保证实验教育的质量，提高实验教育的效率，方便课堂评估，加强实验教育和研究，为实验教育的标准化、标准化和信息化提供有力支撑。
2.2 实验资源模块 实验资源模块是用于管理教育机构中与科学实验相关的资源的模块，实验资源模块可以统一管理各类实验设备、设备、文献等资源，并进行分类、编号、记录等操作，使实验资源更加规范、规范、便捷，编写、提供参考资料和教材，促进学生的实验自主性、创新性和探索性，提高实验教育效果，实验资源模块可以提供智能辅助服务，使实验资源的使用更加高效、经济和安全，如网上购物、预订使用和维护，实验资源模块不仅可以支持实验教育，还可以为科学研究提供必要的技术支持和数据分析，促进学术研究的发展。实验资源模块对于教育和研究机构来说是非常必要的，该模块可以统一实验资源的管理，提高实验教育的有效性，节省成本和时间，支持科学研究，同时，实验资源模块可以促进和帮助教育科研机构的数字化转型和智能化升级。
2.3 学生实验模块 学生实验模块是一种用于管理和组织学生实验的教育软件模块，学生实验模块使学生对教学内容和理论知识有更直观的理解，并通过实际操作提高实践能力，学生实验模块允许学生自己操作设备和工具，并具有移动双手和创新的能力。学生实验模块帮助学生加深对课程内容的理解，加深对课程的理解，学生实验模块可以为教师提供全面的实验计划、操作指导和评估系统，并通过实验数据进行分析和反馈，以提高教育质量和效果。通过学生实验模块，可以提高学生的实践能力和动手能力，加深他们对教学的理解和理解，并提供更全面的教育支持和反馈，以提高教学质量和效果。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 实验课程档案表 3.2.2 实验资源表 3.2.3 学生实验表 四、系统展示 五、核心代码 5.1 一键生成实验 @RequestMapping(value = "/oneCreateExp", method = RequestMethod.GET) @ApiOperation(value = "一键生成实验") public Result&lt;Object&gt; oneCreateExp(@RequestParam String id){ ExperimentCurriculum curriculum = iExperimentCurriculumService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3931236993f4cbb812afaf958a019f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bd59914934e8f710be865fd8e326af/" rel="bookmark">
			在Blender中清理由Instant-NGP等几何学习技术生成的网格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用布尔运算:
创建一个大的立方体或其他简单几何体包裹住全部网格。使用布尔修改器对两个网格进行“差集”运算。这将移除超出包裹体之外的多余网格部分。 手动选择并删除:
进入编辑模式（按Tab键）。按A键取消选择所有顶点。按B键并拖动以选择您想要删除的区域。选择后，按X键并选择“顶点”来删除。 使用Decimate修饰器:
在对象模式下，选择需要简化的网格。在修饰器（Modifiers）面板中添加“Decimate”修饰器。调整比例值来减少网格的顶点数量，这有助于去除不必要的小碎片。 使用删除松散顶点:
进入编辑模式。选择所有顶点。从“Clean Up”菜单中选择“Delete Loose”，删除未连接的顶点。网格布尔运算 创建一个大的立方体或其他简单几何体包裹住全部网格使用布尔修改器对两个网格进行"差集"运算这将移除超出包裹体之外的多余网格部分网格重新拓扑 对于非常密集的网格,可以使用Remesh修改器进行重新拓扑,减少面片数量也可以尝试即时Remesh工具 去除松散顶点 进入编辑模式(Tab键)选择"网格数据"工具选项卡在"顶点组"下,单击"清理"在弹出菜单中选择"分离松散"这将把所有没有连接到主体网格的小碎片分离到一个新对象中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600df1f756be5dae199242c2a9af2205/" rel="bookmark">
			Flutter APP下载更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于我做的项目不是放在APP商店（公司内部用）的，一些flutter的第三方库不合适我，我需要用的是从网上下载再安装（从服务下），网上也找了花了我好几天时间。不全又乱，这我自己做一下备份
现在只使用安卓下载，ios没有做（后期可能更新）
app更新要求 1.进入app就查看app是否要更新（更新对比自己写）
2.下载完成可以自动弹窗安装界面
正式开始 1.使用第三方库 dependencies: # 查询应用程序包信息 package_info_plus: ^5.0.1 # 创建和管理下载任务的插件 flutter_downloader: ^1.11.6 # 安装插件，打开安装界面 install_plugin: ^2.1.0 # 权限处理程序 permission_handler: ^11.3.0 # 用于比较和递增版本号 version: ^3.0.2 2.权限 添加权限 android\app\src\main\AndroidManifest.xml
manifest需要加上xmlns:tools="http://schemas.android.com/tools",
不然可能报错
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;application android:label="cpm" android:name="${applicationName}" android:icon="@mipmap/launcher_icon"&gt; &lt;!-- flutter_downloader下载器安卓配置，如果你想其它应该有权读取您的文件 --&gt; &lt;provider android:name="vn.hunghd.flutterdownloader.DownloadedFileProvider" android:authorities="${applicationId}.flutter_downloader.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/&gt; &lt;/provider&gt; &lt;!-- 开始FlutterDownloader定制 --&gt; &lt;!-- 禁用默认初始化器 --&gt; &lt;provider android:name="androidx.startup.InitializationProvider" android:authorities="${applicationId}.androidx-startup" android:exported="false" tools:node="merge"&gt; &lt;meta-data android:name="androidx.work.WorkManagerInitializer" android:value="androidx.startup" tools:node="remove" /&gt; &lt;/provider&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/600df1f756be5dae199242c2a9af2205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12d0688c4696ce6045e8507c1fa1016/" rel="bookmark">
			Pytest测试中的临时目录与文件管理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Pytest测试框架中，使用临时目录与文件是一种有效的测试管理方式，它能够确保测试的独立性和可重复性。在本文中，我们将深入探讨如何在Pytest中利用临时目录与文件进行测试，并通过案例演示实际应用。
为什么需要临时目录与文件？
在测试过程中，有时需要创建临时文件或目录以模拟特定场景，同时确保测试的独立性，防止测试之间相互影响。Pytest提供了 tmpdir 和 tmp_path 两个fixture，用于在测试期间创建和管理临时目录与文件。
使用 tmpdir 创建临时目录
tmpdir是Pytest提供的fixture之一，用于在测试过程中创建和管理临时目录。以下是一个简单的示例：
# content of test_tmpdir.pyimport os def test_create_temp_directory(tmpdir): # 使用 tmpdir 创建临时目录 temp_dir = tmpdir.mkdir('my_temp_dir') # 在临时目录中创建文件 temp_file = temp_dir.join('temp_file.txt') temp_file.write('Hello, Pytest!') # 断言文件是否存在 assert temp_file.check(file=True) # 断言文件内容 assert temp_file.read() == 'Hello, Pytest!' 在这个例子中，tmpdir 作为参数传递给测试函数，通过tmpdir.mkdir 创建了一个名为my_temp_dir 的临时目录，然后在该目录中创建了一个名为temp_file.txt 的文件，并写入了内容。最后，通过断言验证了文件的存在和内容。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。
如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受
可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛
分享他们的经验，还会分享很多直播讲座和技术沙龙
可以免费学习！划重点！开源的！！！
qq群号：691998057【暗号：csdn999】
使用 tmp_path 创建临时目录
除了tmpdir，Pytest还提供了 tmp_path 这个fixture，它返回一个pathlib.Path 对象，使得在测试中更方便地操作路径。下面是一个使用 tmp_path的案例：
# content of test_tmp_path.pydef test_create_temp_directory(tmp_path): # 使用 tmp_path 创建临时目录 temp_dir = tmp_path / 'my_temp_dir' temp_dir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12d0688c4696ce6045e8507c1fa1016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318ae0be12c4dc3250d7f0d000dc3bf6/" rel="bookmark">
			TCP的三次握手、四次挥手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三次握手与四次挥手的实质就是客户端与服务器之间TCP建立通信的连接和断开的过程
三次握手： 三次握手目的：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号并为后面的可靠性传送做准备。
第一次握手：客户端发送一个带有SYN=1的报文段给服务器，同时会初始序列号seq=x，此时客户端进入SYN_SENT状态。（这个数据包不能携带数据，但是会消耗一个序列号）
第二次握手：服务器在Listen状态下接收到客户端的SYN数据包后；若服务器同意建立连接，在确认报文段中把SYN和ACK都置位1，确认号ack=x+1；同时，服务器自己也会初始化序列号seq=y。此时服务器进入SYN_RCVD状态。（不能携带数据，消耗一个序列号）
第三次握手：客户端在接收到服务器的确认报文段后，还需要再向服务端发送一个确定报文段，会将ACK=1，确认序列号ack=y+1，这个报文段再发送给服务端，此时客户端就会进入ESTABLISHED状态（表示连接建立）。(再发送ACK报文段的时候，可以携带数据并消耗一个自己的序列号)。服务器接收到这个报文段后，也会进入ESTABLISHED状态。
以上就是三次握手的过程，连接建立之后就可以进行数据的交流了。
为什么要进行第三次握手？ 原因一：
主要是为了防止已失效的连接请求报文段突然又传给了B，而产生错误。
情况一：A向B发送了一个连接请求报文，但因为某些原因导致报文丢失，收不到B的确认报文，于是A又会重新发送一次请求报文，之后收到的确认报文，连接建立。不会产生已失效的连接请求报文段
情况二：A向B发送了一个连接请求报文段，在网络中，并没有丢失，而是在某个网络节点滞留了，直到A与B连接释放后的某一个时间点才到达，此时B会以为是A又发送的一次连接请求，给A回复确认报文段后，B并不会理睬这个确认报文，因为没有第三次握手，所以B以为与A已经建立连接了，但是A却不以为然，一直不会发送数据，而造成B的资源浪费。
原因二：
1.如果只进行两次握手，只能保证客户端--&gt;服务端建立连接成功，不能保证服务端与客户端的连接也建立了，因为服务端给客户端发的SYN+ACK客户端并没有回应
2.因为只有两次握手，只能确认服务端收发数据的能力是正常的，客户端只能确认其发送能力是正常的，不能保证它的接收能力是否正常。因为TCP需要保证可靠性，所以只能三次握手保证。
为什么不是四次握手？ 四次握手的过程其实是将第二次握手分解为两步，服务端先回复了ACK确认报文，再发送一个SYN的请求报文。这样会增加额外的延迟和复杂性。
四次挥手 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。
第一次挥手：A向B发出连接释放报文段，报文段首部的终止控制位FIN=1，序列号seq=u，发送后A变为FIN_WAIT_1状态。
第二次挥手：B收到连接释放报文段后会回复确认报文，报文段ACK=1，ack=u+1，seq=v。发送后B进入CLOSE_WAITE状态（半关闭状态）。这个状态下B仍可以向A发送数据。
A在收到B的确认报文后会进入FIN_WAIT_2状态。等待B发送连接释放报文
第三次挥手：B发送连接释放报文，FIN=1，seq=w，ack=u+1（重复上一次的确认号），ACK=1。此时B进入LAST_ACK状态。
第四次挥手：A收到B的连接释放报文后，会回复确认报文。确认报文中ACK=1，seq=u+1，ack=w+1。此时B进入TIME_WAIT状态。B在接收到确认报文后，进入CLOSED状态，连接关闭。
注：A在TIME_WAIT状态下需要等待2MSL（最长报文段寿命）时间才会进入CLOSED状态。
为啥要等待2MSL？ 原因一：确保A的确认报文B能够收到，保证AB都能正常进入CLOSED状态。B在发送连接释放报文后，若收不到A的确认，就会重发一次连接释放报文，A在重传一次确认，会重新启动2MSL计时，B收到后才会进入CLOSED状态。若A不等待2MSL而是直接进入CLOSED，那么A收不到B重传SYN+ACK，B也无法收到A的确认，则会导致B无法进入CLOSED状态。
原因二：防止类似“已失效连接请求报文段”情况的发生。等待2MSL可以保证在本次连接的时间内，产生的所有报文段都从网络中消失了，不会使下一个新连接出现旧的报文段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528224af274e56c9f938b2f4711f4e57/" rel="bookmark">
			EXCEL&#43;PYTHON学习2：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1） 设置单元格的值：
import openpyxl wb = openpyxl.Workbook() # 建立空白的工作簿 ws = wb.active # 取得目前工作表 ws.cell(row=2, column=1, value='Apple') ws.cell(row=3, column=1, value='Orange') ws.cell(row=2, column=2, value=200) ws.cell(row=3, column=2, value=150) wb.save('out3_3.xlsx') # 将工作簿储存 2） 取得单元格的值： wb = openpyxl.load_workbook(fn) ws = wb.active print("单元格B2 = ", ws.cell(row=2, column=2).value) print("单元格B3 = ", ws.cell(row=3, column=2).value) print("单元格B4 = ", ws.cell(row=4, column=2).value) print("单元格C3 = ", ws.cell(row=3, column=3).value) print("单元3格C4 = ", ws.cell(row=4, column=3).value) 3）如果单元格有公式的话，取得的是公式，如果要取得值，则： 要用data_only=True wb = openpyxl.load_workbook(fn, data_only=True) 4） 取得单元格位置信息 n = 'data3_10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528224af274e56c9f938b2f4711f4e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8eff9eb2fc3f5fdc9976378ee90780/" rel="bookmark">
			DiscordProxyStart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 别人的一个项目。还有点用。
GitHub - aiqinxuancai/DiscordProxyStart: 实验项目，在任意位置运行本项目exe，自动配置并启动添加独立代理的discord
本项目使用 https://github.com/aiqinxuancai/discord-proxy 中提供的代理方式，简化操作，无需复制version.dll，无需修改快捷方式，减少其中可能出现的问题。 开始使用 下载Release后，整体解压到任意目录中，修改目录下的Config.ini，添加自己本地的代理地址，然后启动DiscordProxyStart.exe文件即可启动支持代理的Discord。 Config.ini配置例子： [Config] Proxy=http://127.0.0.1:1080 你可以按下Win+R输入shell:startup回车，按住Alt键拖动DiscordProxyStart.exe到此目录中实现开机启动。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b1c5157b9174e2517b0207e3759a67/" rel="bookmark">
			学习和认知的四个阶段，以及学习方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分享学习的四个不同的阶段，以及分享个人的一些学习方法。
一、学习认知的四个阶段 我们在学习的过程中，总会经历这几个阶段：
第一阶段：不知道自己不知道；
第二阶段：知道自己不知道；
第三阶段：知道自己知道；
第四阶段：不知道自己知道。
达克效应与认知的四个阶段通常是指在认知心理学中描述的四个认知发展阶段，也被称为"四个修炼阶段"。这些阶段涵盖了个体对知识和技能的不同认知水平和能力，包括：
不知道我不知道：在这个阶段，个体对某个领域的知识或技能缺乏意识，也不了解自己的不足之处。因为缺乏意识，个体不会主动去学习或寻求改进。
知道我不知道：在这个阶段，个体意识到自己对某个领域的知识或技能存在缺陷，但同时也认识到自己有能力去学习和改进。个体可能会寻求学习的机会和资源来填补自己的知识空白。
知道我知道：在这个阶段，个体已经掌握了某个领域的知识或技能，并且意识到自己已经具备了这些知识或技能。个体可以在需要时主动应用这些知识或技能，达到预期的目标。
不知道我知道：在这个阶段，个体已经将某个领域的知识或技能内化到了自己的认知结构中，已经成为自己思考和行为的一部分，但可能并不总是意识到这一点。这种知识或技能已经被个体自动化，成为了无意识的自然反应。
这一认知过程，恰与Dunning-Kruger Effect（达克效应）的总结相类似：越是无知的人就越自信。当一个人知识越来越多，自信心会下降，但是突破临界点以后，自信心会回升，但之后不论怎么回升，都不如一开始一无所知时那么自信。即越是知识丰富的人越能意识到自己的不足，也越能发现、承认与学习别人的优点。
这些认知阶段也恰好可以对应达克效应曲线的不同分段：愚昧山峰（不知道自己不知道），绝望之谷（知道自己不知道），开悟之坡（知道自己知道）与平稳高原（不知道自己知道）。
最难过的是第一个阶段（不知道我不知道），因为只有跨过去，才能有机会告别平庸。大概有70%以上的人都没有跨过这个阶段。这个阶段大概正是求学的阶段，至少包含从小学到大学。
最痛苦的是第二阶段（知道我不知道） ，就像上述所说的，这个过程会绝望，会痛苦。这个阶段大概会发生在大学到参加工作的前两年这个时间阶段。知道自己不知道，但是想要弥补，又需要时间，正应一句话“书到用时候方恨少”。这个阶段应该会有20%的人。
至于第三个阶段，和第四个阶段，自认为还没达到，就不聊了。这篇文章主要分享一些学习的方法，知识的来源渠道。帮助度过前两个阶段，或者说不那么痛苦。
二、自己的学习所经历的不同阶段 2.1 初期阶段：培训机构的课程 在这个阶段，许多初学者选择参加培训机构提供的课程。这些机构通常提供结构化的学习路径和全面的课程内容，包括现场授课和在线课程。（不要害怕，我不推销课程！）在上大学的时候，互联网上还没有那么多的学习视频，基本上都是收费的，身边有很多同学都选择去参加技术培训，花两万块钱，培训大半年。其实参与培训没什么不好的，只是花钱。现在互联网上有很多免费的学习课程，像B站就是一个学习的好地方，基本上想学什么都有内容。
特点：导师的即时反馈、同学之间的交流以及整套课程的体系结构给刚入行的初学者提供了一个牢固的知识基础。优势：结构化的内容有助于系统地建立起技术栈，并且通常会得到专业认证，增加就业市场上的竞争力。 2.2 随后阶段：博客和自我学习 把相关的视频课程看完，随着基础知识的牢固，许多技术人员开始寻找更灵活的学习方法。他们转向互联网上的博客和教程，这些内容通常由经验丰富的开发者分享，涵盖了新兴技术和高级技巧。这时候可以都去搜一下相关领域的大佬的博客，看看他们都在干什么，他们都干过什么。初次之外，应该多去看一些书籍，一个领域可能会有成千上万本书，但是神作就那么两本，去看看。
特点：博客文章通常针对特定问题或技术提供深度解析，这使得学习者可以根据当前的工作需求进行针对性学习。优势：这种方式提供了巨大的灵活性，允许学习者跟上最新的行业趋势，同时也能够按照个人节奏来深入研究特定主题。 2.3 高级阶段：官方文档和资源 随著对技术理解的加深，许多开发者会转向官方文档来获取权威、最新的信息。无论是软件文档、API还是开发指南，官方资源都能提供最准确的技术细节。其实有很多内容都藏在官方文档中，还有知识藏在源码中。这些过程，想要获取到知识，非常的耗时。要熬得住。
特点：官方文档直接由技术的创建者或维护者编写，精确且权威。优势：使用官方文档可以保证学习者获得的是最准确、最可靠的信息，有助于在实际应用中避免误解和错误。 2.4 专业化阶段：学术论文和研究 在职业生涯更进一步后，一些专业人士开始从学术论文中获取深入的见解和前沿知识。通过阅读和分析学术文献，他们能够学习到新兴理论并将之应用于实际工作中。论文中，特别是名校，名企的论文，质量是相当高的，基本上可以代表了领域内的最前沿的方向。这个阶段是在经历了前几个阶段后，发现书也看过了，但是还是觉得不够。百尺竿头更进一步，这个时候，不妨去看看论文。论文中的研究问题的方法，提示的思想，都是有借鉴意义的。这个获取知识的阶段，会及其痛苦和难熬，甚至是掉头发，想吐。但是又经常会因为看到不一样的东西，而喜出望外。这大概就是书中自有黄金屋吧。
特点：学术论文通常包含了相关领域的最新研究成果和深度分析，反映了该领域的最前沿。优势：论文阅读可以让技术人员对特定技术有更深层次的理解，并可能激发新的创意，促进个人和行业的发展。 随着知识的源泉不断拓宽，技术专家们必须学会在海量信息中筛选出最有价值的内容。无论是通过培训课程建立起坚实的基础，还是通过自我学习保持与时俱进，或者通过深度研究探索未知，持续学习永远是技术进步的核心。这个不断演进的学习过程不仅丰富了个人的知识库，也为整个技术领域的进步做出了贡献。
三、从学术论文中学习可以带来许多好处 对于那些希望在其领域内保持前沿知识或者对某个特定主题进行深入研究的人来说。以下是一些显著的优势：
接触到最新的研究：学术论文往往包含了最新的研究结果和科学发现，从中学习可以确保你获取最前沿的知识和理解最新的行业趋势。
深度理解原理和理论：学术论文通常详细描述了实验方法、理论推导和研究背景，这样不仅可以帮助你了解某项技术是如何工作的，还可以理解为什么它是有效的。
提高批判性思维能力：学术论文的阅读和分析要求高水平的批判性思维和理解能力。这个过程可以锻炼你的批判性思考，提高分析和解决问题的能力。
激发创新和创意：了解当前研究的局限性和未来的研究方向可以激励你提出新的想法或者改进现有的技术。
促进专业成长：不断地从学术论文中学习可以帮助你在专业上不断进步，打造深厚的知识基础，将来也许能够在自己擅长的领域发表原创研究。
建立学术网络：了解谁是你领域的领军人物、哪些机构在特定主题上进行研究，可以帮助你建立起一个专业网络，为将来的研究合作和学术交流打下基础。
提升研究技能：学习如何从论文中查找、整合和引用信息可以提升你的研究技能，这是学术研究和许多工作场所中都非常宝贵的技能。
因此，尽管论文阅读可能具有一定的挑战性，它对于深化技术理解、推动个人职业发展以及贡献行业进步具有重大的意义。
四、如何找到适合自己研究领域的学术论文？ 在科学研究或专业技术领域，找到适合自己的学术论文对于知识深入和技材提升至关重要。以下是一系列有效的方法，可助您找到与自己研究领域相关的学术论文：
1. 学术数据库搜索：
使用学术搜索引擎或数据库，如Google Scholar、IEEE Xplore、PubMed、Scopus等，都是寻找相关学术论文的好方法。输入关键词，使用高级搜索选项可以帮助缩小范围。 2. 大学图书馆资源：
大多数大学图书馆提供对大量学术期刊和会议论文的访问权限。即使你不是学生或教职工，许多图书馆也允许公众访问这些资源。 3. 直接访问学术期刊网站：
根据您的研究领域，选定一些顶级的学术期刊，定期访问它们的网站查看最新发表的论文。 4. 参加学术会议：
学术会议是了解新研究动向的有效途径。即使不能亲自参加，会后通常可以在线访问论文摘要和演讲内容。 5. 利用社交媒体和学术网络：
加入LinkedIn、ResearchGate等学术社交网络，并关注与您研究领域相关的群组和个人。这些平台上的讨论可以发现值得关注的论文。 6. 使用参考文献：
阅读一篇好的研究论文时，用其参考文献列表作为资源库，往往能发现更多宝贵的资料。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75b1c5157b9174e2517b0207e3759a67/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/46/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>