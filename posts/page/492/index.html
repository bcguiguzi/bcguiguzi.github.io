<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e86478b84c2d8f02990bd3d9e3f4e6a/" rel="bookmark">
			Android禁止横屏竖屏切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在一些特殊的情况下,Android开发期间会禁止某些Activity的横竖屏切换.下面介绍一种简单的方法:只要在AndroidManifest.xml里面配置一下就可以了。在AndroidManifest.xml的activity(需要禁止转向的activity)配置中加入android:screenOrientation=”landscape”属性即可(landscape是横向，portrait是纵向)。 例如: &lt;activity android:name=".DemoActivityt" android:theme="@android:style/Theme.NoTitleBar" android:screenOrientation="portrait" &gt;&lt;/activity&gt;另外，android中每次屏幕方向切换时都会重启Activity，所以应该在Activity销毁前保存当前活动的状态，在Activity再次Create的时候载入配置。要避免在转屏时重启activity，可以通过在androidmanifest.xml文件中重新定义方向(给每个activity加上android:configChanges=”keyboardHidden|orientation”属性)，并根据Activity的重写onConfigurationChanged(Configuration newConfig)方法来控制，这样在转屏时就不会重启activity了，而是会去调用onConfigurationChanged(Configuration newConfig)这个方法。 尊重原创:http://www.open-open.com/lib/view/open1328278861750.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66b715a68724c1cccc3553138ca7ad7/" rel="bookmark">
			org.apache.storm.shade.org.apache.zookeeper.KeeperException$NodeExistsException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2015-12-08 13:19:32.588 b.s.util [ERROR] Async loop died! java.lang.RuntimeException: java.lang.RuntimeException: org.apache.storm.shade.org.apache.zookeeper.KeeperException$NodeExistsException: KeeperErrorCode = NodeExists for /meta/3252452 at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:135) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.utils.DisruptorQueue.consumeBatchWhenAvailable(DisruptorQueue.java:106) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.disruptor$consume_batch_when_available.invoke(disruptor.clj:80) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.daemon.executor$fn__5694$fn__5707$fn__5758.invoke(executor.clj:819) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.util$async_loop$fn__545.invoke(util.clj:479) [storm-core-0.10.0.jar:0.10.0] at clojure.lang.AFn.run(AFn.java:22) [clojure-1.6.0.jar:?] at java.lang.Thread.run(Thread.java:745) [?:1.7.0_76] Caused by: java.lang.RuntimeException: org.apache.storm.shade.org.apache.zookeeper.KeeperException$NodeExistsException: KeeperErrorCode = NodeExists for /meta/3252452 at storm.trident.topology.state.TransactionalState.setData(TransactionalState.java:119) ~[storm-core-0.10.0.jar:0.10.0] at storm.trident.topology.state.RotatingTransactionalState.overrideState(RotatingTransactionalState.java:52) ~[storm-core-0.10.0.jar:0.10.0] at storm.trident.spout.TridentSpoutCoordinator.execute(TridentSpoutCoordinator.java:71) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.topology.BasicBoltExecutor.execute(BasicBoltExecutor.java:50) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.daemon.executor$fn__5694$tuple_action_fn__5696.invoke(executor.clj:690) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.daemon.executor$mk_task_receiver$fn__5615.invoke(executor.clj:436) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.disruptor$clojure_handler$reify__5189.onEvent(disruptor.clj:58) ~[storm-core-0.10.0.jar:0.10.0] at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:132) ~[storm-core-0.10.0.jar:0.10.0] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66b715a68724c1cccc3553138ca7ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62e94c488f6073cc72274d4eef4939f/" rel="bookmark">
			1001. 害死人不偿命的(3n&#43;1)猜想 (15) java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卡拉兹(Callatz)猜想：
对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……
我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？
输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。
输出格式：输出从n计算到1需要的步数。
输入样例： 3 输出样例： 5
提交代码
import java.util.Scanner; public class Main { public static void main(String[] args) { int a = 0; Scanner input = new Scanner(System.in); a = input.nextInt(); int cnt=0; while (a!=1) { if (a%2==1) { a=(3*a+1)/2; cnt++; } else { a/=2; cnt++; } } System.out.println(cnt); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9971664744965380c13bdff6f80b6c3/" rel="bookmark">
			克里金(Kriging)插值的原理与公式推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://xg1990.com/blog/archives/222
学过空间插值的人都知道克里金插值，但是它的变种繁多、公式复杂，还有个半方差函数让人不知所云
本文讲简单介绍基本克里金插值的原理，及其推理过程。
0.引言——从反距离插值(IDW)说起 空间插值问题，就是在已知空间上若干离散点 (xi,yi) 的某一属性(如气温，海拔)的观测值 zi=z(xi,yi) 的条件下，估计空间上任意一点 (x,y) 的属性值的问题。
直观来讲，根据地理学第一定律，
All attribute values on a geographic surface are related to each other, but closer values are more strongly related than are more distant ones.
大意就是，地理属性有空间相关性，相近的事物会更相似。由此人们发明了反距离插值，对于空间上任意一点 (x,y) 的属性 z=z(x,y) ，定义反距离插值公式估计量
z^=∑i=0n1dαzi 其中 α 通常取1或者2。
即，用空间上所有已知点的数据加权求和来估计未知点的值，权重取决于距离的倒数（或者倒数的平方）。那么，距离近的点，权重就大；距离远的点，权重就小。
反距离插值可以有效的基于地理学第一定律估计属性值空间分布，但仍然存在很多问题：
α 的值不确定用倒数函数来描述空间关联程度不够准确 因此更加准确的克里金插值方法被提出来了
1.克里金插值的定义 相比反距离插值，克里金插值公式更加抽象
zo^=∑i=0nλizi 其中 zo^ 是点 (xo,yo) 处的估计值，即 zo=z(xo,yo) 。
这里的 λi 是权重系数。它同样是用空间上所有已知点的数据加权求和来估计未知点的值。但权重系数并非距离的倒数，而是能够满足点 (xo,yo) 处的估计值 zo^ 与真实值 zo 的差最小的一套最优系数，即
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9971664744965380c13bdff6f80b6c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7af30d15f990a359e622e890bc238c7/" rel="bookmark">
			友盟之微信授权登陆总结（微信授权回调响应问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		至于友盟注册以及开发使用，自行查看文档或者官网了。
微信平台：https://open.weixin.qq.com/
自行注册，以及申请开发者资质认证（需要300元）还有一系列注册需要的资料。通过这个后才有微信登录权限。
应用的提交审核需要的资料，签名等，微信或者友盟都有资料介绍。或者参考我的上一篇博客写的新浪微博的：http://blog.csdn.net/qq_16064871/article/details/50083807。
一、微信回调的activity注册 &lt;!-- 微信回调activity 一定要是app的package包名--&gt; &lt;activity android:name=".wxapi.WXEntryActivity" android:configChanges="keyboardHidden|orientation|screenSize" android:exported="true" android:screenOrientation="portrait" android:theme="@android:style/Theme.Translucent.NoTitleBar" /&gt; 虽然友盟都建议，友盟开发包建成工程，最后引用这个这个友盟的工程。但这样做势必会造成引用这个工程的app包名跟 android:name=".wxapi.WXEntryActivity"这前面的包名不一样（app的包名+.wxapi.WXEntryActivity）而不是（友盟工程的包名+.wxapi.WXEntryActivity）。
所以这个空的WXEntryActivity还是要放在使用app的项目中，WXEntryActivity.class的完整路径应该是app的包名+.wxapi.WXEntryActivity。还有上面那个activity注册其他配置要一模一样。
这就是大多数人友盟的微信登陆回调没有用户信息返回的原因。就是没有执行到onComplete。
二、注意事项： 1、WXEntryActivity这个类里面什么都不用写。友盟帮我们写好了。就如下：
import com.umeng.socialize.weixin.view.WXCallbackActivity; public class WXEntryActivity extends WXCallbackActivity { } 2、如果测试时候，如果已经多次登录微信。需要注销登录微信再进行测试。
3、测试的微信号一定要有微信号。最好也要有头像。 三、下面看一下代码流程： 1、平台的注册，微信包加到平台 // 整个平台的Controller,负责管理整个SDK的配置、操作等处理 private UMSocialService mController = UMServiceFactory .getUMSocialService("com.umeng.login"); private void addWXPlatform() { // 注意：在微信授权的时候，必须传递appSecret // wx967daebe835fbeac是你在微信开发平台注册应用的AppID, 这里需要替换成你注册的AppID String appId = "wx....."; String appSecret = "gdfg......"; // 添加微信平台 UMWXHandler wxHandler = new UMWXHandler(LoginActivity.this, appId, appSecret); wxHandler.setRefreshTokenAvailable(true); wxHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7af30d15f990a359e622e890bc238c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843bd9d7a40ebb9fbc40d4b458e8d09d/" rel="bookmark">
			vector容器的三种遍历方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL(Standard Template Library)中vector容器是最常见的容器之一，设计中经常需要遍历vector容器，本文介绍三种常用的vector遍历方式。
一、下标索引遍历
vector容器底层其实是动态数组的包装，因此在其内部重载了[]运算符。
函数原型如下：
因此可以采用访问数组元素的类似方式访问vector内部的元素。
示例代码：
// vector容器遍历方式1 —— 下标遍历 void traverseVector_1(vector&lt;int&gt; v) { for(unsigned int i = 0; i &lt; v.size(); ++i) { cout&lt;&lt;v[i]&lt;&lt;" "; } cout&lt;&lt;endl; } 二、迭代器遍历
与数组元素的指针访问方式类似，vector的第二种遍历方式是采用迭代器(iterator 智能指针的一种)。
【迭代器的底层是对原生指针的封装】
示例代码：
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; // vector容器遍历方式2 —— 迭代器遍历 void traverseVector_2(vector&lt;int&gt; v) { // 注：如果参数为const vector&lt;int&gt; 需要用const_iterator vector&lt;int&gt;::iterator it = v.begin(); // vector&lt;int&gt;::const_iterator iter=v.begin(); for(; it != v.end(); ++it) { cout&lt;&lt;(*it)&lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/843bd9d7a40ebb9fbc40d4b458e8d09d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc8de56b618891a8cba81172dfe8746/" rel="bookmark">
			Makefile选项CFLAGS,LDFLAGS,LIBS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile选项CFLAGS,LDFLAGS,LIBS CFLAGS 表示用于 C 编译器的选项，
CXXFLAGS 表示用于 C++ 编译器的选项。
这两个变量实际上涵盖了编译和汇编两个步骤。
CFLAGS： 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。
LDFLAGS：gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。每安装一个包都几乎一定的会在安装目录里建立一个lib目录。如果明明安装了某个包，而安装另一个包时，它愣是说找不到，可以抒那个包的lib路径加入的LDFALGS中试一下。
LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv
简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。不过使用时链接阶段这两个参数都会加上，所以你即使将这两个的值互换，也没有问题。
有时候LDFLAGS指定-L虽然能让链接器找到库进行链接，但是运行时链接器却找不到这个库，如果要让软件运行时库文件的路径也得到扩展，那么我们需要增加这两个库给"-Wl,R"：
LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib
如果在执行./configure以前设置环境变量export LDFLAGS="-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib" ，注意设置环境变量等号两边不可以有空格，而且要加上引号（shell的用法）。那么执行configure以后，Makefile将会设置这个选项，链接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fec6e8b4c47499741472af30db4bff/" rel="bookmark">
			unravel中文音译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 吼 西 嘿 得 哦，西 嘿 得 哟 搜 no，洗 库 咪 喔 博 库 no 那 噶 泥，大 累 盖 一 路 弄 抠 哇 泪 大 狗 哇 泪 大 哟 抠 no 塞 盖 一 得 key 咪 库 哇 那 唔 那 咪 唔 咩 子 咩 抠 哇 泪 大 博 库 哇 得 撒 一 key 喔 都 没 带 吼 都 key 耐 某 吼 都 key 耐 哟 心 一 鸡 子 塞 因 浮 瑞 子（freeze） 库 哇 塞 带 库 哇 塞 那 一 库 撸 耐 库 撸 耐 一 库 哇 带 某 米 子 开 带 哟 累 带 哟 噶 当 say 盖 泥 带 当 博 库 哇 死 给 都 喔 得 泥 嘿 当 那 带 米 子 给 那 一 得 博 库 no 抠 都 忘 米 子 米 慢 得 哟 累 当 key 盖 当 say 盖 no 那 可 得 哦 那 克 喔 key say 死 给 大 古 哇 那 哟 哦 某 喔 得 得 博 库 no 得 都 喔 哦 才 克 那 某 no 盖 立 一 key 楼 带 楼 库 都 气 刚 噶 耐 某 楼 哦 恰 克 泥 哦 啦 它 key 哟 库 克 死 撒 累 吼 都 key 来 X5 吼 都 key 来 抗 昂 来 为 哟！（unravel you） 库 哇 得 洗 哇 大 噶 嘿 累 木 噶 大 呼 大 次 卡 噶 啦 某 呼 大 累 噶 哦 弄 没 路 库 哇 say 路 库 哇 say 那 一 库 路 那 库 路 内 那 一 库 那 得 某 key 噶 say 耐 克 哟 哟 累 带 哟 噶 当 say 盖 泥 带 当 博 库 哇 死 给 都 喔 得 泥 嘿 当 那 带 米 子 给 那 一 得 博 库 no 抠 都 忘 米 子 米 慢 得 哟 累 克 当 say 更 当 头 都 克 当 忘 累 哟 来 干 抠 都 克 干 洗 马 喔 来 因 米 哦 狗 因 丹 死 丹 博 库 no 抠 头 忘 塞 key 狗 那 哇 忙 哦 死 累 那 一 得 X4 抠 哇 克 得 洗 嘛 大 抠 头 米 忙 来 哟 克 狼 累 外 狗 都 那 勒 克 忙 耐 死 哦 博 因 一 得 博 库 no 抠 头 某 吼 洗 唉 得 吼 洗 唉 得 博 库 弄 那 克 泥 大 累 噶 一 路 弄 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c9cfa16ce34509427683e0234583db/" rel="bookmark">
			Android 物联网WIFI模块配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在过去的接近两个月，接了两个小小的物联网项目外包，所以对WiFi模块配置以及开发有了一定的研究。那么今天来说一下物联网WIFI模块配置。研究是基于STM32 智能家居开发的。
一、背景知识 1、WiFi模块 本开发板默认已经烧写了手机WIFI的测试软件，wifi模块工作在AP模式，TCP server ,ip是10.10.100.254,端口是8899。
综合测试
手机WIFI综合 android手机通过WIFI与开发板互相通讯，发送数据。
二、WiFi模块底板功能介绍 1、重置系统参数：（开发模式一：AP模式） 通电以后，按 按键 &gt; 3秒，Ready和Link灯灭，随后Ready灯亮。系统恢复到出厂参数。
工作于AP模式，IP:10.10.100.254,端口：8899, TCP Server。
2、smart Link智能接入已有wi-fi网络：（开发模式二： STA模式
） 通电以后，按 按键 &lt; 3秒，Ready灯灭，Link灯快闪，这时候手机操作SmartLink软件，推送
现有wi-fi网络的配置信息（SSID,密码等）到wi-fi模块，完成智能配置。配置成功后，wi-fi模块
采用dhcp的方式获得现有wi-fi网络的ip, Ready灯和Link灯亮，进入 STA模式 工作状态。
3、通过互联网局域网中WiFi模块的方法（这点也是和第2点开发一起的） 开发板硬件作为服务器，设有固定的IP,通过无线 连接到 无线路由器，在路由器上设置转发规则，内容为这个固定的IP和端口20108,同时在路由器的DDNS中设置启动动态域名系统，这样手机程序就可以通过3G网络输入动态域名连接到局域网内的开发板上就行通讯了。
4、实物图 三、WiFi模块AP模式 AP模式：是不用配置路由器的，用WiFi模块发出的热点，用手机连上去就行了。这个模式密码一般都为空的。也是出厂模式吧。
开发建议：很简单的。因为默认IP：10.10.100.254，端口8899。部分代码如下
socket = new Socket(); SocketAddress socketAddress = new InetSocketAddress("10.10.100.254.",8899); socket.connect(socketAddress,2000); socket.setSoTimeout(2000); socket.setTcpNoDelay(true);	dis = new DataInputStream(new BufferedInputStream(socket.getInputStream())); dos = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream())); 这样写好其他代码，Android手机与WiFi模块之间就可以数据的双向通信了。 四、 WiFi模块
STA模式
这个模式要一系列的配置，实现手机通过路由器转发数据到WiFi模块，所以基于这种情况，要把WiFi模块配置到你的局域网路由器上，只要那里有你的WiFi模块配置的IP地址了。就可以转发了，这时你的手机就可以连接路由器的WiFi或者手机网络来进行通信了。
接下来先用手机配置WiFi模块，就是连上WiFi模块，然后打开手机上的浏览器输入10.10.100.254；然后输入用户名和密码都是admin。然后搜索路由，找到你的路由，连接，输入平时你和搜集WiFi上网路由器的密码。重启就成功。最后用电脑登陆你的路由器配置，可以查看是否连接成功。以及配置成功后的WiFi模块在路由器上的IP地址。
1、打开你的手机WiFi列表 2、连接WiFi模块的WiFi，是第二个没有密码的。 3、打开手机上的浏览器输入10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0c9cfa16ce34509427683e0234583db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd961e58b2739e31fc0de43d0754c45/" rel="bookmark">
			对于给定的一个字符串，统计其中数字字符出现的次数。输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt;
using namespace std;
int main()
{
int n,i,s;
char x;
cin&gt;&gt;n;
getchar();
for(i=0;i&lt;n;i++)
{
s=0;
while((x=getchar())!='\n')
if(x&gt;='0'&amp;&amp;x&lt;='9')
s++;
cout&lt;&lt;s&lt;&lt;endl;
}
return 0;
} 注意：记得用一个getchar（）读取输入数字之后的换行符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2bbe6e770a46782e6920412444c0e0/" rel="bookmark">
			搭建个人博客工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些快速搭建个人博客工具推荐 Farbox 支持Markdown在线博客托管服务,国人开发,支持客户端编辑器,需付费。适合不想自己。
Logdown 也是支持Markdown在线博客托管服务。
Wordpress 老牌的开源博客系统,后来支持Markdown。也支持托管服务,就是老被墙。
Ghost 开源的博客系统,支持后台编辑器和用户系统,需要数据库,适合搭建独立博客, 使用Node.js。
Jekyll, Jekyll-zh 将纯文本转化为静态网站和博客,只用 Markdown (或 Textile)、Liquid、HTML &amp; CSS 就可以构建可部署的静态网站。
Gitblog 国人开发的开源博客系统,基于git,和Jekyll类似。
LifeType lifetype是一个开源的Blog平台,在同一个系统中支持多个Blog和多个用户。
Hexo 使用Node.js ，Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript，部署简单。
typecho 仅仅 7 张数据表，加上不足 400KB 的代码,原生支持 Markdown 排版语法，易读更易写,精心打磨过的操作界面，依然是你熟悉的面孔，更多了一份成熟与贴心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0c97b85740fd5eb7799163c723ab5b/" rel="bookmark">
			\r与\n的区别,以及\r\n的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\r是回车，英文是Carriage return，作用：使光标到行首
\n是换行，英文是New line/line feed，作用：使光标下移一行
如果用过机械打字机，就知道回车和换行的区别了。
回车就是把水平位置复位，不卷动滚筒。
换行就是把滚筒卷一格，不改变水平位置。
我们平时所说的键盘Enter键换行实则应该叫做叫做回车换行(\r\n)
看到一种说法： windows下enter是 \r\n; linux/unix下是\n; mac下是\r
Windows 采用 \r\n 是有原因的，Windows 采用了传统的英文打字机的模式。
想想看英文打字机是如何换行的呢？英文打字机是选择将小车退回至起点，
这个过程称为回车（carriage return, CR），随后把小车调至下一行的位
置，这个过程称为换行（line feed, LF），这样就完成了英文打字机中换
行过程。
回车（CR）在计算机中使用 ASCII 为 13 的字符来表示(0x0D)，换行（LF）使用 ASCII 为 10 的字符来表示(0x0A)。
注意：
1、windows下可直接使用\n来匹配换行符，但仍然推荐使用标准的\r\n来匹配键盘Enter键的换行符;
2、使用\r\n组合是有顺序的，调转顺序写成\n\r是错误的，将无法匹配换行符！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84622de5bf65d299587a5136e52c5595/" rel="bookmark">
			HFSS 过孔模型设计向导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansoft为过孔设计提供了工具，可以在HFSS快速产生3D的过孔模型，小工具名字为Via Wizard，下载地址：
http://download.csdn.net/detail/wu20093346/9253719
安装过后，在保证有HFSS已经安装的情况下就可以生成过孔模型：
打开界面：
点击右下角Generate Project，稍后会自动打开HFSS，并且建立好了模型。
产生多个过孔方法：点击Via选项卡，Vias选项中点击Add，第二个通孔y Loc.处填30，设置Ports，点击Update.如图：
点击Generate Project：
可以设定差分对：
选择Diff.Pair，如图，点击Identify Diff Vias：
Generate Project：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c384e56526533e518cba6febb67b0c4f/" rel="bookmark">
			怎么用latex编辑出类似这样的算法流程呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么用latex编辑出类似这样的算法流程呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d44120b654fa3991b5addd36a9fe1be/" rel="bookmark">
			arcGIS  Engine控件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arcGIS Engine控件介绍 arcGIS Engine控件主要分为六类 1、制图控件：MapControl、PageLayoutControl
2、三维控件：GlobeControl 、SceneControl
3、框架控件：TOCControl、ToolbarControl
4、许可控件：LicenseControl、
5、其他控件：RederControl、 RederGlobecontrol
6、符号控件：SymbologyControl、 1.1地图控件 MapControl：主要用于二维地图的显示。 1.2页面布局控件 PageLayoutControl：主要用于打印或输出地图。
2.1场景控件 SceneControl：通常用于建立小型的三维场景、来观察三维场景模型。
2.2 GlobeControl：在一个地球表面显示三维场景。
3.1图层树控件 TOCcontrol：主要用于地图中显示图层列表，可对图层进行显示、添加、删除、输出输入的作用。
3.2工具栏控件 ToolbarControl：主要是提供快捷的有关进行地图操作的工具条功能。
4.1许可控件 LicenseControl:为当前应用提供一个许可初始化的功能。
6.1符号控件 SombologyControl：作为一个符号库的一个面板，对符号进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16010c11c6c2da801b1e1c92c0d974e/" rel="bookmark">
			linux内核定时器struct timer_list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核中最终的计时资源是定时器。定时器用于定时器超时处理程序在未来某个特定时间点执行，或者周期性的轮询硬件的状态。Linux提供了内核定时器完成这类工作。
定时器的只需要执行一些初始化的操作，如：设置一个超时时间，指定超时要调用的函数，然后激活定时器就可以了。它的处理和工作队列还是有点类似的。和任务队列一样，内核定时器并不是周期运行，它在超时后自动销毁。因此，如果要实现周期轮询，就需要在定时器执行函数返回前再次激活定时器。
一般来说，定时器都在超时后马上就会执行超时处理函数，但是也有可能被推迟到下一个时钟节拍时才能执行，所以不能用定时器来实现任何硬实时任务。
内核定时器用于控制某个函数(定时器处理函数)在未来的某个特定的时间执行。内核定时器注册的处理函数只执行一次，不循环执行
内核定时器被组织成双向链表，并使用struct timer_list结构描述
struct timer_list{
struct list_head entry; //内核使用
unsigned long exoires; //设定的超时的值
void(*function)(unsigned long); //超时处理函数
unsigned long data; //超时处理函数参数
struct tvec_base *base; //内核使用
}
下面看看一个实现轮询操作的小例子：
struct timer_list polling_timer;
init_timer(&amp;polling_timer);
polling_timer.data = (unsigned long)something;
polling_timer.function = polling_handler;
polling_timer.expires = jiffies + 2 * HZ;
add_timer(&amp;polling_timer);
void polling_handler(unsigned long data) {
...
polling_timer.expires = jiffies + 2 * HZ;
add_timer(&amp;polling_timer);
}
jiffies是Linux内核中的一个全局变量，用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。因为一秒内时钟中断的次数等于HZ，所以jiffies一秒内增加的值也就为HZ。系统运行时间以秒为单位计算，就等于jiffies/HZ。
节拍率HZ是通过静态预处理定义的，在系统启动时按照HZ值对硬件进行设置。体系结构不同，HZ值就不同，在i386体系结构在include/asm-i386/param.h中定义如下：
#define HZ 1000
每秒钟时钟中断1000次，也就是说，在1秒里jiffies会被增加1000。因此jiffies + 2 * HZ表示推后2秒钟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16010c11c6c2da801b1e1c92c0d974e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2545ae0a16104b83e85506c14e4aaf80/" rel="bookmark">
			PuTTY使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。除了官方版本外，有许多第三方的团体或个人将PuTTY移植到其他平台上，像是以Symbian为基础的移动电话。PuTTY为一开放源代码软件，主要由Simon Tatham维护，使用MIT licence授权。随着Linux在服务器端应用的普及，Linux系统管理越来越依赖于远程。在各种远程登录工具中，Putty是出色的工具之一。Putty是一个免费的、Windows 32平台下的telnet、rlogin和ssh客户端，但是功能丝毫不逊色于商业的telnet类工具。目前最新的版本为0.63 下载地址 PuTTY Dowwnload PuTTY连接Linux服务器经常掉线 1. 方案一修改Server配置文件 修改服务器中/etc/ssh/sshd.config 文件，将LoginGraceTime的值设为0，TCPKeepAlive 设为yesservice sshd restart 重启sshd服务。 2. 方案二配置PuTTY 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974c26350c90d52b7271b033da517943/" rel="bookmark">
			【AHK】给通达信软件增加F1买入，F2卖出 交易热键(基于中银国际客户端测试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通达信金融终端网上交易软件 快捷键分为四种
数字键:比如1,61,81,10,91等
点系列键:比如.101,.201,.301.... .909等
功能键:比如F1,F2... 空格键,减号键,TAB等 (F1:分时成交明细、F2:分价表、F3:沪指分时、F4:深指分时、F5分时与K线切换、F6:自选股、F7：树状菜单、 F8:无、F9:期权交易、F10：基本资料、 F11:投资日历、F12：委托)
组合键:比如Ctrl+V,Alt+1,Ctrl+Z等
交易软件都做得差强人意。。。同花顺有热键F1呼出买入和F2卖出的功能（见下图），通达信则没有(是有数字热键221,223 总之是别扭)
来为通达信普通买入卖出功能增加热键!（程序化交易的先得能呼叫出买卖功能然后自动填单）
（有钱的可以直接购买fix协议或者dll接口，没钱的用ahk模拟人来操作吧，穷得蛋疼。。。）
【技术原理】
MSAA的全称是Microsoft Active Accessibility。这是类似DCOM技术。 技术模型是这样的，UI程序可以暴露出一个Interface，方便另一个程序对其进行控制。 MSAA技术的初衷是为了方便残疾人使用Windows 程序。自动化自然可以借用这项技术。 [源代码]
;功能：给通达信软件增加类似同花顺的交易功能热键 ;2015年10月25日11:39:03 ;作者：sunwind #SingleInstance,Force DetectHiddenWindows,On WINNAME := "TdxW_MainFrame_Class" CTRLNAME := "MHPToolBar1" hwnd:=ControlGetHwnd(CTRLNAME, WINNAME) idObject:=0 ;~ window :=0 SELF ;~ client := -4 ;~ child_1 := 1; ;~ child_2 := 2; ;~ child_3 := 3; ;========MHPToolBar1======== ;按钮所在的“小”窗口 window := Acc_ObjectFromWindow(hwnd, idObject) ;========MainViewBar======== ;窗口里面的工具栏 MainViewBar:= Acc_Children(window)[3] ;下面代码是基于中银国际交易软件客户端测试的 ;========买入按钮======== buy:= Acc_Children(MainViewBar)[1] ;~ MsgBox % Acc_Role(buy) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974c26350c90d52b7271b033da517943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee98393d1c8c6e6dc6b7d2aceaabf98/" rel="bookmark">
			继电器模块典型电路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当控制端电压为0时，Q1基极电压为（12-0.7=11.3V）,改变R1的大小便可改
变基极电流，当基极电流足够大时，三极管饱合。
为了验证以上的分析，我们搭了一个电路，R1取4.7K，此时基极电流为2.4ma，
测得Q1 ec电压为0.2V,继电器两端电压为11.8V。
注意：R1的取值不能太小，要保证基极电流在安全范围，也不能太大，要保
证三极管能完全饱合，这个可以通过电压和电阻算出来。
第一种电路能工作，那是因为继电器有较宽的电压范围，有时它欠电压也能
勉强工作，但状况是不稳定的，因此我们在设计时不建议采用这种方式。
正确的电路应该是电路二，正确的连接方式，大小合适的基极电阻才能保证
设计的合理和稳定性。
最后注明一下，本次实验采用的12V 继电器，因此该电路的控制极不能直接
用单片机IO 口驱动，否则会关不断。
以上继电器模块的电路图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3eeb5784c4ac7d8b650d4c31811b691/" rel="bookmark">
			初探Makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于近期实验室工作的原因，需要到Linux环境下生成一个C++项目的动态库文件，开始第一次采用写Makefile的方式来生成。在Linux平台下面，C/C++项目的源码文件首先会通过编译生成.o文件，它也被称为OBJ目标文件，在这一步中，编译主要完成的任务是对源代码中的语法和逻辑进行检查，若通过则将生成.o文件，下一步是链接过程，该过程将会产生中间文件，也就是我们说的动态链接库文件.so或者静态库文件.a，在windows下对应的则是.dll和.lib文件，该步骤将.o文件对应的.h找出来，并将这些.o文件链接成为.so或者.a文件。如果用命令行来一步步生成的话，对于大项目而言，这样的方法是不科学的，首先是每次都要检查文件的依赖关系，其次是每次手打的话，效率会很低，Makefile就是为了解决这样大项目的生成而存在的。
以下是近期实验室项目，需要用到的Makefile，第一次接触，特此记录。
一个C++工程下，各文件的依赖形式如上图所示，假定最后要生成的.so文件名为foreground_extraction.so，那么相应的Makefile如下：
&lt;pre name="code" class="plain"&gt;foreground_extraction.so : main.o utility.o &lt;/pre&gt;&lt;pre name="code" class="plain"&gt; gcc -fPIC -shared -o foreground_extraction.so main.o utility.o main.o : main.cpp data_structure.h jni_call.h utility.h gcc -fPIC -c -I /usr/lib/gcc/x86_64-redhat-linux/4.4.4/include main.cpp utility.o : utility.cpp utility.h gcc -fPIC -c utility.cpp .PHONY : clean clean: rm foreground_extraction.so main.o utility.o 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/491/">«</a>
	<span class="pagination__item pagination__item--current">492/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/493/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>