<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c745ab30d774576f6ddcd42a91ac8652/" rel="bookmark">
			NCP1271D65R2G中文资料规格书PDF数据手册引脚图参数图片价格功能特性描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品描述：
NCP1271 是成功的 7 引脚电流模式 NCP12XX 系列的新一代引脚-引脚兼容新产品。该控制器通过使用可调节 Soft Skip 模式和集成的高电压启动 FET，实现了卓越的待机功耗。此专属 Soft Skip 还大大降低了噪音的风险。 因此可以在箝位网络中使用不是非常昂贵的变压器和电容器。内部频率抖动、斜坡补偿、基于计时器的故障检测和锁存输入使得此控制器成为耐用性和部件成本为关键限制因素的转换器的绝佳备选。
产品特性：
独立于辅助绕组的短路保护可调软跳跃模式内部高压启动在整个温度范围内具有 5% 的电流限制精度内部锁存器，便于实现过压和过热保护频率抖动可降低 EMI 特征+500 mA/800 mA 峰值电流驱动能力 规格书参数：
引脚图：
功能框图：
封装尺寸图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7261be6efbbcd5f9b8b8816d31fc841/" rel="bookmark">
			我的尝试：Codigger &#43; Vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若您愿意耐心投入，学习 Vim 的过程其实远比想象中轻松。我对 Vim 产生兴趣，主要是源于它对提升生产力的巨大潜力。我尝试了 Neovim、NvChad 以及 Codigger Vim 插件，如今我的工作效率已远超从前。
那么，Vim 究竟是什么呢？
Vim 是一款在终端中广泛使用的文本编辑器，尤其适合代码和文本文件的编辑。它以其高效的键盘快捷键和强大的功能赢得了程序员和开发人员的高度赞誉。尽管 Vim 主要在终端中运行（除了GVim 等特殊情况），但其在编程领域的地位却历久弥新。
为何要选择学习 Vim？
如果您是编程新手或对 Vim 不感兴趣，或许可以暂时放下学习它的念头。然而，对于有一定经验的开发人员，尤其是那些追求高效编辑体验，或是在 Unix 类系统上工作的开发者，Vim 绝对值得一试。对我而言，Vim 的吸引力在于其使用的乐趣和无尽的学习空间。无需频繁使用鼠标，每一次学习都意味着新的发现，这正符合我作为终身学习者的追求。
但请记得，学习 Vim 并非强制，但掌握其基础命令对于专业开发者而言确实大有裨益。
在日常工作中，我如何运用 Vim？
Vim 的操作基于不同的编辑模式：普通、插入和可视。新手常因不知道如何退出 Vim 而感到困惑，这主要源于对这些模式的不了解。在普通模式下，您可以通过输入 i 进入插入模式，进行文本编辑。按下 esc 后输入冒号，则进入命令模式。再次按下 esc 可以返回普通模式。在命令模式下，您可以输入如 q 并按 enter 来执行命令。
在我的设置中，我结合使用 Neovim 和 Codigger 的 Vim 插件。Neovim 主要用于处理轻量级任务，如 Git 提交信息、待办事项列表等。同时，我在 Codigger 中使用 Vim 插件，以便在常用的编辑器中享受 Vim 的按键绑定，同时保留其美观和精确的语法高亮功能。
最后，我想说，不要害怕尝试 Vim。您可以先从将它作为插件添加到您的编辑器开始，然后逐步学习更多的快捷键。总有一天，您会发现自己已经能通过Codigger上手后的方便和快捷而感到高兴，并享受其中的每一刻。
感谢您的阅读，祝您有美好的一天。若您对Vim或 Codigger 感兴趣，不妨在 CSDN 上关注我，一起探讨编程的奥秘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5764adb113e472b4b830a69d8883bb/" rel="bookmark">
			【网络安全】 MSF提权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅用于信息安全学习，请遵守相关法律法规，严禁用于非法途径。若读者因此作出任何危害网络安全的行为，后果自负，与作者无关。
环境准备：
名称系统位数IP攻击机Kali Linux6410.3.0.231客户端Windows 76410.3.0.234 当我们通过MSF成功登录靶机时，进行提权时如果报如下，表示没有拿到系统权限
meterpreter &gt; getsystem # 输出 [-] priv_elevate_getsystem: Operation failed: 1726 The following was attempted: [-] Named Pipe Impersonation (In Memory/Admin) [-] Named Pipe Impersonation (Dropper/Admin) [-] Token Duplication (In Memory/Admin) [-] Named Pipe Impersonation (RPCSS variant) [-] Named Pipe Impersonation (PrintSpooler variant) [-] Named Pipe Impersonation (EFSRPC variant - AKA EfsPotato) 接下我们演示如何进入提权：
1、切换 msf
meterpreter &gt; bg # 输出 [*] Backgrounding session 2... 2、使用本地漏洞模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5764adb113e472b4b830a69d8883bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5811f301550be922a750b2394eedd5c8/" rel="bookmark">
			MC78L05ACDR2G线性稳压器芯片中文资料规格书PDF数据手册引脚图参数图片价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述： MC78L00A系列线性稳压器价格便宜，易于使用，适用于各种需要最高100mA的调节电源的应用。与大功率MC7800和MC78M00系列一样，这款稳压器也提供内部电流限制和高温关断，因此非常坚固耐用。在很多应用中，MC78L00 器件都无需外部组件。由于输出阻抗和静态电流大大降低，此类线性稳压器与传统的齐纳二极管-电阻组合相比，具备很大的性能优势。
特性：
宽范围固定输出电压可选低成本内部短路电流限制内部热过载保护无需外部元件提供互补负稳压器（MC79L00系列）提供无铅封装 规格书参数：
引脚图：
元件封装尺寸图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc41f2ee50d23fa414b8362eb75c197/" rel="bookmark">
			NCP1380BDR2G芯片中文资料规格书PDF数据手册引脚图图片参数功能价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品描述：
NCP1380 是一款高性能器件，旨在为准谐振转换器供电。该控制器基于专属的谷锁闭系统，可以在功率负载变轻时进行切换并降低开关频率。这样将产生稳定的运行，即使在漏极-源极谷中总是触发的开关事件下也是如此。此系统可在低至第 4 个谷的条件下运行，并在之后切换到变频模式，确保卓越的待机功率性能。为了提高过载条件下的安全性，该控制器包括了过功率保护 (OPP) 电路，可对高电平线路处提供的电源进行箝制。具有安全功能的固定内部计时器依赖反馈电压来检测故障。一旦计时器到期，控制器则停止并保持选项 A 和 C 的锁存状态，或者进入选项 B 和 D 的自动恢复模式。该控制器尤其适用于适配器应用，有一个引脚来实施过电压/高温组合保护（版本 A 和 B）或 欠电压/过电压组合保护（版本 C 和 D）。
产品特性：
准谐振峰值电流模式控制操作带谷值锁定的谷道切换操作轻负载时的频率折返可调节的过功率保护自动恢复或锁存内部输出短路保护用于短路保护的固定内部 80 ms 定时器组合过压和过热保护（A 和 B 版本）组合过压保护和掉电保护（C 和 D 版本）VCC 工作电压范围高达 28 V 规格书参数：
引脚图：
封装尺寸图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b7ef0e68a27b16a93fa2e53e13357e/" rel="bookmark">
			NCV7356D1R2G接口集成芯片中文资料PDF数据手册参数引脚图规格书价格图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述：
NCV7356 是一款用于单线数据链路的物理层器件，能够使用多种具碰撞分解的载波感测多重存取 (CSMA/CR) 协议运行，如博世控制器区域网络 (CAN) 2.0 版。此串行数据链路网络适用于不需要高速数据的应用，低速数据可在物理介质部件和微处理器和/或使用该网络的专用逻辑器件中实现成本降低。该网络应该能够以正常数据速率模式或高速数据下载模式运行，适用于组装生产线和服务数据传输运行。高速模式仅在总线连接板外服务节点时运行。此节点应提供实现更高速运行的临时总线电子负载。此类临时负载在不执行下载运行时应消除。正常通信的典型比特率为 33 kbit/s，对于上述高速传输，推荐的典型比特率为 83 kbit/s。NCV7356 是根据单线 CAN 物理层规范 GMW3089 V2.3 设计的，支持很多附加功能，如欠压锁定、故障阻断输入信号超时、总线振铃时的输出间隔时间，以及极低睡眠模式电流。
产品特性：
完全兼容 J2411 单线 CAN 规范60 uA 最大休眠电流支持 100 kbps 高速模式工作电压范围 5.0 至 27 V40 kbps 总线速度选择性总线唤醒3.3 V 和 5 V 兼容逻辑输入抑制引脚以控制外部稳压器待机到睡眠模式超时完全集成的接收器滤波器失去接地保护总线 donminant 超时欠压锁定总线端子可防止短路和瞬变 规格书参数：
引脚图：
元件封装尺寸：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959fb6db5232fa10d1b58463bcd91cae/" rel="bookmark">
			Python 3.x 快速安装 pip 包管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ℹ️ 1. 查看是否安装 pip1.1 方法一1.2 方法二 🛠️ 2. 安装方法2.1 通过 ensurepip 进行安装2.2 通过 get-pip.py 进行安装 参考文档：
pip 官方安装文档：https://pip.pypa.io/en/stable/installation/ ℹ️ 1. 查看是否安装 pip 【注】有的时候 pip 会存在多个，虽然 pip 不存在，但是会有其他名字；如 pip3、pip3.9 等。
1.1 方法一 # 运行这个命令会显示当前系统中安装的 pip 版本号 python -m pip -V #如果没有安装会提示： /usr/bin/python: No module named pip python: 这部分是调用 Python 解释器的命令，告诉操作系统执行 Python 相关的操作。-m pip: 这部分是使用 Python 的内置模块管理器（Module）来调用 pip 工具。-V: 这部分是 pip 工具的选项之一，用于显示当前安装的 pip 版本。 1.2 方法二 # 或者直接用命令 pip -V 如果提示 pip 不是内部或外部命令，则表示没有安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/959fb6db5232fa10d1b58463bcd91cae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028bb42582a65a8404474e50a7d73821/" rel="bookmark">
			写一个shell脚本：进入pod服务运行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、正常ssh命令行输入 进入pod服务
kubectl exec -it poptestserver-6df4b6888f-nkfgj -n platform -- /bin/sh
统计当前系统中处于活跃状态的TCP连接数量
netstat -antp | grep -v TIME_WAITH | wc -l
这条命令是用来统计当前系统中处于活跃状态的TCP连接数量。让我来解释一下每个部分的含义：
netstat -antp：这部分命令用于显示系统中的网络统计信息。具体来说，-a 选项表示显示所有的连接和监听端口，-n 选项表示以数字形式显示地址和端口号，-t 选项表示只显示TCP连接，-p 选项表示显示与连接相关的进程信息。
grep -v TIME_WAIT：这部分命令使用 grep 工具来过滤掉包含 TIME_WAIT 状态的行，-v 选项表示反向匹配，即排除包含 TIME_WAIT 的行。
wc -l：最后，wc 命令用于统计输入中的行数，-l 选项表示只统计行数。
二、将上面的操作写成shell脚本 #!/bin/bash
date
kubectl exec -it popaccessserver-6df4b6888f-nkfgj -n platform -- /bin/sh &lt;&lt;EOF
netstat -antp | grep -v TIME_WAITH | wc -l
exit
EOF
&lt;EOF 和 EOF 的作用是定义一个包含多行文本或命令的区块，并将其作为输入传递给指定命令的执行环境。避免进入pod服务内部后控制台出不了导致运行卡住
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dac888e14c0c5541d149424046c720b/" rel="bookmark">
			Mac：m系列芯片安装homebrew、安装配置python环境完美教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先打开终端
2、安装git，以便安装homebrew管理下载的各种软件包（直接输入git回车）
git 进度很慢。。如果没耐心就 终止掉重新输入命令
3、检查git安装是否成功
git --version 4、输入命令安装homebrew（）
/bin/zsh -c "$(curl -fsSL https://gitee.com/huwei1024/HomebrewCN/raw/master/Homebrew.sh)" 输入序列号：1
是否执行脚本：y
输入开机密码后回车
5、报错解决（执行完后报错，问题不大修改环境变量即可）
1、进入根目录
cd ～
2、创建.zshrc文件
touch .zshrc
3、编辑
sudo vim .zshrc
4、输入i编辑态，修改路径如下
把/user/local改成/opt/homebrew
esc退出编辑态，输入:wq保存（不会linux就去可视化文件显示隐藏文件 记事本编辑）
5、重新加载
source .zshrc
6、检查是否安装成功
brew -v 至此安装成功
7、安装python
brew install python3 8、查看python版本
python3 --version 9、查看python路径
which python3 至此 python安装完毕，因为mac自带python2，且默认输入命令python走python2，可修改成走python3
export PATH=${PATH}:/usr/local/bin/python3 alias pip="/usr/local/bin/python3" alias python="/usr/local/bin/python3" source ~/.bashrc 至此，已修改路径配置完毕
输入python --version就可以出现安装的python3了 使用命令也不需要带3了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c211c90fd60a03dd78f36e913272ab0/" rel="bookmark">
			【Unity】进度条和血条的三种做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在使用Unity开发的时候，进度条和血条是必不可少的，本篇文章将简单介绍一下几种血条的制作方法。
1.使用Slider Slider组件由两部分组成：滑动区域和滑块。滑动区域用于显示滑动条的背景，而滑块则表示当前的数值位置。用户可以通过拖动滑块来改变数值。
新建Slider，右键选择UI / Slider
Slider组件的常用属性
Fill Rect： 滑动的填充图片，上图中的绿色部分Handle Rect： 滑块块指数当前位置，上图中的圆点。【如果不需要这个，可以直接删掉】Min Value： 滑动的条值小最Max Value： 滑动条的最值大Value ： 滑动条的当前值。Whole Numbers ： 只允许整值数。Direction ： 滑动条的方向，可以是水平或垂直。 程序调用
public Slider slider; void Start() { //设置血量为一半 slider.value = 0.5f; //监听slider变化 slider.onValueChanged.AddListener(OnSliderValueChanged); } void OnSliderValueChanged(float val) { } 2.修改RectTransform的Width ①新建2个Image，一个充当底图，一个从当进度条
②修改image的Pivot
Pivot（0,0.5）表示图片的中心点在：左边中间位置
为什么要修改中心点？
那是因为我们的血条是需要从左向右增加的，当然其他方向同理。
代码示例：
//需要修改的血条 public RectTransform mRt; //血条最大值 public float max = 200; void Start() { //设置血量为80% SetHp(0.8f); } //设置当前血量 void SetHp(float val) { //先取出当前的宽和高 Vector2 cur = mRt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c211c90fd60a03dd78f36e913272ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c445729b8dd50bfae290435802d8320/" rel="bookmark">
			ai智能外呼机器人的功能，机器人对话常用语模板搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能外呼机器人就是用来往外呼出打电话的;经常看到有文章说电话机器人将要代替传统人工话务员、电话销售员要失业了、外呼机器人要颠覆电销革命了等等，我想说的是，目前市场上的电话机器人还远远不能达到，未来几年内也不一定会实现。
下面就简单来介绍一下智能外呼机器人的6大功能：
1、多维度报表，实时可查看
后台数据报表支持多维度数据报表，用户可以自定义各项数据。例如：日期数据，用户可根据需求选择一周、一月、一季度或者自定义日期来生成数据报表，并可以实时查看，有关系统问题欢迎微小编一起交流。
2、简易库管理，一键可导入
后台管理操作简单，数据导入方便，用户可以一键导入需要拨打电话的Excel名单，也可单个提交用户信息，并支持多项变量数据。
3、灵活任务栏，随时可记录
后台任务操作灵活，用户可以建立多个不同外呼任务，也可以建立单个外呼任务，任务随时可以修改，随时可记录。
4、支持合成音，支持真人音
外呼通话中真人语音交流，客户感觉不到是机器人拨打的电话，对于变量信息，无需重新录音，可运用真人合成音，与真人声音无差异。
5、通话随时听，模板可优化
后台通话记录可随时查看，同步录音也可以随时导出，对于通话中发现识别有误或者跳转有误等问题，可以随时修改模板，优化模板。
6、意向分类准，支持打分制
客户意向分类准确度高，用户可根据自己的需求设定分类标准，比如直接肯定、关键词肯定等等，也支持细化打分制分类意向客户。
AI智能外呼机器人的优势
基于ASR、TTS、NLP以及自主呼叫中心平台研发完成，实现外呼机器人客服和客户的语音对话交互
按需分配人，资源可独立
降低运营管理成本
减少重复劳动
提升服务质量
提高工作效率
提高销售业绩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f59bbf200586785dbd568955a0ba98/" rel="bookmark">
			javaweb-maven&#43;HTTP协议&#43;Tomcat&#43;SpringBoot入门&#43;请求&#43;响应&#43;分层解耦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven
IDEA集成Maven
依赖管理
依赖配置
maven是插件完成对应的工作的~
哇哇哇maven看完啦~~~~~~
Spring.io
Springboot是Spring家族的子项目，可以帮助我们非常快速地构建应用程序，简化开发，提高效率。
@RestController请求处理类
HTTP协议
无状态：每一次请求响应都是独立的。
HTTP-请求协议
HTTP响应协议
200 404 500
HTTP 协议解析
Tomcat
Tomcat的基本使用
请求响应
复杂对象按照层次对应起来即可。
响应数据
一个案例
分层解耦
分层解耦
@Component 将当前类交给IOC容器管理，成为IOC容器的bean
@Autowired 运行时，IOC容器会提供该类型的bean对象，并赋值该变量-依赖注入
如果有多个对象的话，需要哪个就将哪个放入到IOC容器里，也就是加入@Component
IOC详解
DI详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658cabe00cf7eb247a179de95fc4dd84/" rel="bookmark">
			KubeSphere快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 KubeSphere 是在 Kubernetes 之上构建的面向云原生应用的分布式操作系统，完全开源，支持多云与多集群管理，提供全栈的 IT 自动化运维能力，简化企业的 DevOps 工作流。它的架构可以非常方便地使第三方应用与云原生生态组件进行即插即用 (plug-and-play) 的集成。
作为全栈的多租户容器平台，KubeSphere 提供了运维友好的向导式操作界面，帮助企业快速构建一个强大和功能丰富的容器云平台。KubeSphere 为用户提供构建企业级 Kubernetes 环境所需的多项功能，例如多云与多集群管理、Kubernetes 资源管理、DevOps、应用生命周期管理、微服务治理（服务网格）、日志查询与收集、服务与网络、多租户管理、监控告警、事件与审计查询、存储管理、访问权限控制、GPU 支持、网络策略、镜像仓库管理以及安全管理等。
架构 核心组件主要有三个：
ks-console 前端服务组件ks-apiserver 后端服务组件ks-controller-manager 资源状态维护组件 前后端分离：
KubeSphere 将 前端 与 后端 分开，实现了面向云原生的设计，后端的各个功能组件可通过 REST API 对接外部系统。 可参考 API文档。 KubeSphere 无底层的基础设施依赖，可以运行在任何 Kubernetes、私有云、公有云、VM 或物理环境（BM）之上。 此外，它可以部署在任何 Kubernetes 发行版上。
架构 核心组件主要有三个：
ks-console 前端服务组件ks-apiserver 后端服务组件ks-controller-manager 资源状态维护组件 前后端分离：
KubeSphere 将 前端 与 后端 分开，实现了面向云原生的设计，后端的各个功能组件可通过 REST API 对接外部系统。 可参考 API文档。 KubeSphere 无底层的基础设施依赖，可以运行在任何 Kubernetes、私有云、公有云、VM 或物理环境（BM）之上。 此外，它可以部署在任何 Kubernetes 发行版上。
组件列表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658cabe00cf7eb247a179de95fc4dd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdea18ba2e566bf41bd4289dcfa60163/" rel="bookmark">
			10大超好用ai软件，2024办公学习必备！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能 (AI) 近年来取得了显着进步，并已成为科技行业的流行语。我们随时能看到大量个关人工智能工具的资讯，它有可能自动执行任务，节省时间并提高效率，使其成为企业的宝贵资产和平台。
随着人工智能的进步，旨在让企业生活更轻松的人工智能软件不断涌现，这些人工智能软件旨在自动执行重复性任务、优化工作流程和简化业务流程。在本文中，我们将为大家分享的十款好用的 AI 软件以及它们如何助力提高大家的工作学习效率。
1. Open AI 的 ChatGPT ChatGPT 是一家名为 OpenAI 的大公司基于 GPT-3.5 架构开发的大型语言模型，现在还有 GPT-4 数据和机器学习。
这些工具可以对范围广泛的提示生成类似人类的响应，从回答问题到做笔记，再到让真人参与自然语言对话。在文本框中，可以发送文本提示以获得所需的结果。
OpenAI是一家人工智能研究机构，旨在打造安全、有益于人类的人工智能系统。它的研究涵盖了广泛的主题，从自然语言处理、深度学习和计算机视觉到机器人和游戏。ChatGPT 是 OpenAI 致力于推进人工智能技术发展水平的众多项目之一。它现在也是一个易于使用的 chrome 扩展。
它的一些未来计划包括提高 ChatGPT 等其他平台的语言模型的准确性和效率，在医疗保健和教育等领域为 AI 开发新的应用程序，以及探索先进 AI 系统的潜在风险和好处。
2. Google Bard：专注搜索 Google Bard 是一款由 Google 设计的人工智能聊天机器人工具，用于使用自然语言处理和机器学习模拟人类对话。除了补充谷歌搜索之外，Bard 还可以集成到网站、消息传递平台或应用程序中，以对用户问题提供真实、自然的语言响应。Bard 是围绕搜索而设计的，它旨在允许使用更多自然语言查询而不是关键字进行搜索。Bard 的 AI 是围绕听起来自然的对话式查询和响应进行训练的，它不仅提供答案列表，还提供响应的上下文，它还旨在帮助解决后续问题——搜索的新内容。
3. 博思白板boardmix：加速提升内容生产力 boardmix AI助手是博思白板内新上线的AI助手工具，支持AI生成文本、AI生成代码、AI翻译、互动聊天、在线搜索等功能，为用户提供高效的创作体验。在基于其强大的内容生成能力和搜索能力之外，还能结合boardmix本身的产品功能特点实现AI生成思维导图、任务清单和便利贴等更多样化的创意内容。此外boardmix AI助手在思维发散、灵感收集、头脑风暴方面也能发挥重要作用，为创意工作者提供智能支持。
4. New Bing：“比chatGPT更强大” 2 月初，微软推出了新版 Bing，其突出特点是其 AI 聊天机器人，该机器人由ChatGPT背后的相同技术提供支持。
据微软称，在首次宣布时，公众被告知新的 Bing 具有聊天功能，该功能由下一代 OpenAI 大型语言模型版本提供支持，使其“比ChatGPT 更强大”。
借助新的 Bing，您可以向 AI 聊天机器人提问，并获得详细的、类似人类的回答，并附有脚注，这些脚注链接回原始来源和最新信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdea18ba2e566bf41bd4289dcfa60163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e64f78dfcd7bff3723a7852259060823/" rel="bookmark">
			【数据结构】串 解析&#43;完整代码（求子串、比大小、定位操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.串的实现 1.1 串的定义 定义
串，即字符串，是由零个或多个字符组成的有限序列。
串是一种特殊的线性表，数据元素间呈线性关系。
空串：串长度为0时；子串：串中任意个连续的字符组成的子序列；主串：包含子串的串；字符在主串中的位置：字符在串中的符号；子串在主串中的位置：子串的第一个字符在主串中的位置。 静态数组实现（定长顺序存储）
typedef struct{ char ch[MaxSize]; //用数组存储字符 int length; //串的长度 }SString; 动态数组实现（堆分配存储）
用完需要手动free
typedef struct{ char*ch; //按串长分配存储区，ch指向串的基地址 int length; //串的长度 }HString; 串的顺序存储
串的链式存储
typedef struct StringNode{ char ch[4]; //每个结点存多个字符，提高存储密度 struct StringNode *next; }StringNode,*String; 1.2 串的基本操作 基于静态数组 1.2.1 求子串 //用sub返回串s的第pos位置长度为len的子串 bool SubString(SString &amp;Sub,SString S,int pos,int len){ if(pos+1en-1&gt;S.length)return false; //子串越界 for(int i=pos;i&lt;pos+len;i++){ Sub.ch[i-pos+1]=S.ch[i] } Sub.length=len; return true; } 1.2.2 比大小 字符串的大小比较方法：
从左往右逐个比较，哪个字符的编码大，就哪个串更加大；
若前面的字符都相同，哪个串长就哪个大。
//若S&gt;T,返回值&gt;0；若S=T，返回值=0；若S&lt;T，返回值&lt;0. int StrCompare(SString S,SString T){ for(int i=1;i&lt;=S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e64f78dfcd7bff3723a7852259060823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704291c7eb19b770faf0b84da3a51f76/" rel="bookmark">
			Trees on the level（UVA 122）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址如下：
Trees on the level - UVA 122 - Virtual Judge (vjudge.net)
（第三方网站）
关于二叉树的构建以及bfs（宽度优先搜索）的
我抄了算法书的，算是便于学习
代码如下：
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; struct Node{ bool have_value;//是否被赋值过 int v;//节点值 Node * left, * right; Node():have_value(false), left(NULL), right(NULL){} } * root; bool read_input(void); Node * newnode(void){return new Node();} void addnode(int v, char * s); void remove_tree(Node * u); bool bfs(vector&lt;int&gt; &amp;ans); const int maxn = 300; char s[maxn]; bool failed; int main(void) { while(read_input()) { vector&lt;int&gt; ans; if(failed){printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704291c7eb19b770faf0b84da3a51f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9db0311e8851835b68587ccee747c09/" rel="bookmark">
			精简版 Obsidian 图床配置 PicGo&#43; gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精简版 Obsidian 图床配置 PicGo+ gitee 图床的作用 图床（Image Hosting Service）是一种在线服务，用于存储和托管用户上传的图片文件。用户可以将图片上传到图床服务器，并获得一个可访问的图片链接，然后可以在网页、博客、论坛等地方使用这个链接来展示图片。
通过 PicGo+ gitee 可以搭建免费属于自己的免费图床，当然这里有个风险就是他是开源的可能有资料泄密的风险。
资料准备 Node. Js
Gitee
PicGo
Obsidian
Obsidian 插件 Image auto Upload
参考
picGo+gitee搭建Obsidian(Typora)图床，实现高效写作_obsidian 坚果云 图床-CSDN博客
具体步骤：
1. 下载 Node. Js 一直下一步即可，注意确保勾选环境变量，一般为默认。
Node.js (nodejs.org)
2. 下载 PicGo 一直下一步。
Releases · Molunerfinn/PicGo (github.com)
3. 配置gitee 新建仓库-配置开源
创建个人令牌
4. 配置 picgo 安装插件 gitee-uplodaer
图床设置 - gitee
Repo 输入 gitee 仓库地址
Path 为图片文件夹
建议设置好友在上传区上传测试是否成功。
Picgo 设置开启开机启动，开启时间戳重命名。
一般设置 server 保持默认即可
5. 配置 obsdian 下载安装插件 Image auto Upload
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9db0311e8851835b68587ccee747c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67aa6ac55f743c96be8b867c122a928/" rel="bookmark">
			nodejs中连接redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm下载ioredis库
npm i ioredis 我的redis配置文件单独放在了redis.js
const { promisify } = require('util'); const Redis = require('ioredis'); function connectRedis() { const client = new Redis({ host: '127.0.0.1', // redis地址 port: 6379, //端口 password: '123456' //密码 }); return new Promise((resolve, reject) =&gt; { client.on('connect', () =&gt; { console.log('Redis连接成功'); resolve(client); }); client.on('error', (err) =&gt; { console.error('Redis连接失败:', err); reject(err); }); }); } async function setAsync(client, key, value) { const setAsync = promisify(client.set).bind(client); try { const result = await setAsync(key, value); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e67aa6ac55f743c96be8b867c122a928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a4dba359a86c629bf608e3f9d7066b/" rel="bookmark">
			python--字符串格式化和列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python--字符串格式化和列表 作业字符串格式化format()按顺序取值按索引取值(0开始)按关键字取值调整精度百分比格式化 列表列表的特点列表的创建列表的增列表的删3.1 list.pop(index)3.2 list_1.remove(2)3.3 clear() 清空列表3.4 del list_1[index] 列表的改4.1修改元素的值4.2插队元素insert4.3合并元素extend 列表的查5.1 通过索引获取元素5.2 获取元素的索引5.3 获取列表长度5.4 切片 作业 3、用python实现"hello world hello python" 变成 python hello world hello
str_1 = "hello world hello python" # 使用字符串的 split() 方法将字符串分割成单词列表(空格) new_str = str_1.split() #print(new_str) # 使用字符串的 join() 方法将反转后的单词列表连接成一个字符串 res = " ".join(new_str[::-1]) # 打印结果 print(res) 字符串格式化 1、%s
2、%d int(正数、负数) 、float(会抹掉小数部分)
3、%f price = “the price is %.2f” %(9.9)
# %d price = "the price is %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a4dba359a86c629bf608e3f9d7066b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f66acb80bef2fd2a083267e94bfa9d2/" rel="bookmark">
			200 名专家编写报告：AI 发展可能对人类构成「灭绝级威胁」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 月 14 日消息，美国国务院委托编写了一份新报告，警告 AI 正呈指数级发展，可能会对人类构成「灭绝级威胁」。
这份报告全称为《提高先进人工智能安全保障的行动计划》，要求美国政府必须迅速、果断地采取行动，以避免 AI 带来的重大国家安全风险。报告接着说，如果不实施这些阻碍措施，人工智能或人工通用智能（AGI）就有可能成为「对人类物种的灭绝级威胁」。
这份报告由 200 多名来自 OpenAI、Meta、谷歌、谷歌 DeepMind 等人工智能领域大公司的高管，以及政府工作人员参与，建议美国政府限制和监管 AI 的发展，并要求 AI 公司训练任意新的 AI 模型时都需要提交申请。报告中还建议美国政府立法，宣布开源重要 AI 模型定为非法，认为这些模型中的信息可能会导致「对全球安全具有潜在破坏性的后果」。（来源：IT 之家）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>