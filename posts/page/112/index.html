<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5f09529cd6e487faab833222298635/" rel="bookmark">
			看好多人都在劝退学计算机，可是张雪峰又 推荐过计算机，所以计算机到底是什么样 的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		张雪峰高考四百多分，但是他现在就瞧不起400多分的学生。说难听点，六七百分的
热门专业随便报谁不会啊？
计算机专业全世界都是过剩的，今年桂林电子科技，以前还是华为的校招大学，今年
计算机2/3待业。这个世界不需要，尤其不需要这么多没经验的程序员。而且中国的大
学很多人学不明白计算机。
有些专业比如医生，医生以前有很多，他们会慢慢退休，有些职位是传承的，比如法
院这几年退休的人就很多，这几年湖北的法院很好考（退休潮Q）。而前几年扩招的
程序员，现在还没有消化，现在的情况上，风口来的嫡系程序员人家已经占住了位置
。比如今年银行缩招，银行缩招本来就很正常，银行的人基本不会辞职，他一年招70
0个程序员，他的业务部门才招多少个？你养尊处优Q，不加班一年比前台工资还高，
你有想过钱是谁给你赚来的吗？
张雪峰的逻辑是计算机不止互联网，那请问人工智能这种科技公司，是不是还是以互
联网为主。计算机解决就业的主力还是互联网。
张雪峰经典名言，给各个行业赋能，说白了，就是各个乙方公司。在我看来还不如会
计法务来得好，首先计算机专业就相对这两个专业难一点。it咨询Q自己拿资源的难度
远大于其他两个行业，而且很多大公司比如华为这种他们可以用公司的平台获得机会。
做乙方，如果不独立执业，最后的后果就是疯狂加班猝死。只有独立做老板，找小弟
给你干活才是乙方的出路。
还有说润的，全世界的理工科人基本都在学计算机，印度人Q多的你怀疑人生。然后
都在往美国冲，美国大学Q人家不怕，南加大Q一年硕士项目一千多人，找工作你自
己去拼吧，没有绿卡Q不知道哪个公司能容纳的下。而且作为一个中国人，你出去一
定适应不了食物，文化。去欧洲新加坡这种税后工资1/3给了房租，发展攒钱都不如国
内，你在国外就是给白人打工。
最后讲到考公，考公计算机除了警察狱警岗位以外，还有多少给计算机的机会？计算机
现在相关人数所有专业最多，看似岗位多一点，实则竞争最大，冷门工科很多人不会去
考公，他们可能没岗位，但是有的时候发而容易上岸。
再谈谈待遇，明确一点，打工是不可能发财的打工只是赚点工资罢了。快速发展的时候
过去了，所谓拼10年赚一辈子的钱你就想想吧。计算机待遇已经开始停滞了，相反其他
行业待遇再慢慢往上追，比如机械这种吃经验的学科，工资就慢慢涨上去了。考虑到互
联网的卷度，性价比完全没有。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac8eaab3a0bb33faff61a52be82ae4f/" rel="bookmark">
			ES6 面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6 面向对象 类定义constructor 类涉及关键字thisstaticsuperextends 继承 super父子间属性和函数的调用优先级 编程思想：面向过程、面向对象
面向过程：
优点：逻辑清晰缺点：自行编写，率用率低C语言属于面向过程编程 面向对象：
特性：封装、继承、多态（实例有多种状态）优点：利用率更高;缺点：逻辑清晰度较低JavaScript属于面向对象编程。 类定义 class Human{ static num=2; constructor(name,...){ this.name=name; } static sleep(){...} eat(foodName){...} } constructor 构造函数、构造器：接收实例化时的参数，初始化实例有且只有一个，未声明自动创建调用时机：new 创建实例时 类涉及关键字 this 指代实例 static 修饰属性和行为函数，仅类本身可用，只能通过类名调用 super 既可以当函数使用，也可以当对象使用 作为函数： 代表父类的构造函数，只能用在子类的构造函数中，继承全部方法；作为对象： 在普通方法之中：指向父类的原型对象在普通方法中调用父类方法，super内部的this指向子类的实例当通过super为子类属性赋值时，super就是this在静态方法之中1.指向父类，2.指向子类。 当需要引用super时，需要清楚在此处super是函数还是对象，直接打印console.log(super)时会报错，因为没有指定super是什么
super作为函数：只能用在子类的构造函数constructor中调用，代表父类构造函数。但它内部的this指向的是当前子类的构造函数
class A{ constructor() { console.log(new.target.name) } } class B extends A{ constructor() { super();//其内部的this指向的是子类B的构造函数 } } new A()//A new B()//B super作为对象：用在子类中，需区分是用在普通方法还是静态方法中。
普通方法中
// 一 =====》 class C{ constructor() { } } C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac8eaab3a0bb33faff61a52be82ae4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa06835e6089729215fa35a08674abd/" rel="bookmark">
			Anaconda安装h5py和netCDF4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda install -c anaconda h5py conda install -c anaconda netcdf4 记得在终端安装结束后，先在编译器上restart kernel，再运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e693f6caf37e7d16c4a1bd75bf2e77/" rel="bookmark">
			[Pandas] 添加新列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美图欣赏2022/06/18 数据准备
import pandas as pd df = pd.DataFrame([['ABC'], ['FJZ'], ['FOC'] ],columns=['Site']) df 在平时开发中，添加新数据列涉及到以下三种常用方法:
1. 直接赋值
语法: df[新列名] = 值
import pandas as pd import numpy as np df = pd.DataFrame([['ABC'], ['FJZ'], ['FOC'] ],columns=['Site']) # 添加空值数据列 # 添加'Level','Remark'列,将两列的值设置为空(keep blank) df['Level'] = np.nan df['Remark'] = np.nan 2.reindex()函数
语法: df.reindex(columns=[原来所有的列名,新增列名],fill_value=值)
import pandas as pd df = pd.DataFrame([['ABC'], ['FJZ'], ['FOC'] ],columns=['Site']) # 添加新列'Quantity'和'Product_number',并将其值设置为0 df = df.reindex(columns = ['Site', 'Quantity', 'Product_number'], fill_value=0) 注意: 不加fill_value参数，默认值为nan
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e693f6caf37e7d16c4a1bd75bf2e77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83b8ff19e2b0af899fc3a9a0d7cc38b/" rel="bookmark">
			超强Markdown编辑器 —— Typora最新版本的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超强Markdown编辑器 —— Typora最新版本的安装与使用 Markdown语法在越来越多的文本编辑中应用，它以标题、列表、粗体等形式格式化文本。下面为大家介绍一款超强Markdown编辑器 —— Typora（1.2.4与1.6.7）的安装与使用方法。
安装包来自官网（Typora官网：https://typoraio.cn/）
一、Typora 1.2.4 1、安装typora 先安装 typora-setup-x64-1.2.4.exe ，点击这里
记下安装路径
2、替换文件 安装完成后，将 app.asar 替换到安装路径下的resources文件夹，替换掉app.asar文件
3、重启typora！！！！！！ 一定要重启后再注册！！！
4、注册许可证 输入邮箱和注册码
5、使用 Markdown语法超级简单且实用，具体语法可以参考Markdown语法手册
二、Typora 1.6.7 1、安装Setup.exe 安装Typora-1.6.7文件夹下的Setup.exe，安装完成后不要运行！！！
2、替换文件 将Crack文件夹下的winmm.dll文件复制到安装文件夹
默认安装文件夹路径如下：
3、启动Typora 可以正常使用
侵删~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448e803ee77d6015e1268b6e3dd4f15c/" rel="bookmark">
			MFC串口通信控件MSCOMM32.OCX的安装注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSCOMM32.OCX是一个与Microsoft Corporation开发的MSComm控件相关联的文件。MSComm控件是软件应用程序用来与调制解调器、条形码读取器和其他串行设备等设备建立串行通信的通信控件。
下载地址1
https://download.csdn.net/download/m0_60352504/88345092
下载地址2
https://www.ocxme.com/files/mscomm32
下载后解压，如果你的windows系统是32位，就把MSCOMM32.OCX放到C:\Windows\System32\目录下，如果你的windows系统是64位，就把MSCOMM32.OCX放到C:\Windows\SysWOW64\目录下
用管理员身份运行CMD，输入注册控件命令regsvr32 ocxpath
regsvr32 "C:\Windows\SysWOW64\MSCOMM32.OCX" 如果弹出
说明注册成功
如果弹出
说明你是64位操作系统却把OCX放在了C:\Windows\System32\目录下，导致注册失败
模块的反注册：regsvr32加/u参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c64fa19753058fb9eec8668d75638d9/" rel="bookmark">
			【​HFSS中过孔仿真​】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HFSS中过孔仿真 1.工具软件
1.1 过孔向导工具：Via Wizard3.1
1.2 ANSYS软件版本：2021 R1
2. 叠层信息
说明：
2.1 此叠层是一个实际PCB设计项目的叠层
2.2 叠层中DK值，是板厂根据自己的工艺及经验得到的值，跟板材的Datasheet是对不上的，个人认为在有板厂提供的叠层时，使用板厂的
2.3 DF是根据Datasheet中得出，或者是随意填上去的，这里单针对过孔仿真来说，个人认为这不是重要的，仿真过孔主要是评估其阻抗，
如果需要提取S参数，进行链路仿真，DF还是要根据实际值填入 3. 使用ViaWizard向导工具，填入参数
3.1 设置叠层"Stackup"
3.2 设置过孔焊盘参数
3.3 设置过孔位置
3.4 设置Options选项卡中的参数
4. 确认求解类型为"Terminal"
5. 修正差分线的空气间距
6. 以仿真Stub的影响为例，设置差分信号过孔背钻变量。可以根据需要仿真反焊盘、回流地孔位置、差分过孔间距的影响，设置参考如下
7. 建立差分对
8. 设置扫描参数
9.验证检查是否通过
10. 点击开始仿真
11. 参看仿真结果，参数根据需要填入
12. 增加Mark点，以便更好的观察
总结：
1. 过孔向导工具中的参数一定要正确，其直接影响后面的仿真结果
2. 进入HFSS后，一定要修改差分线对内的空隙间距
3. 如果要进行变量参数扫描，在其值一栏最好都用变量，否则结果中多条曲线，完全重叠在一起，这是不对的
4. 如果出现仿真结果不对，参数又设置都是正常时，可尝试将软件重新打开试试
5. 为了更为准确，可根据实际情况对过孔的介质填充进行选择
仿真文件：https://pan.baidu.com/s/1dMUd-bj68wWCVB3c6GakUg
链接：百度网盘 请输入提取码
提取码：b85e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b936b7e34e9a607e4cc23577f333543/" rel="bookmark">
			使用Pytorch和OpenCV实现视频人脸替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 本文将分成3个部分，第一部分从两个视频中提取人脸并构建标准人脸数据集。第二部分使用数据集与神经网络一起学习如何在潜在空间中表示人脸，并从该表示中重建人脸图像。最后部分使用神经网络在视频的每一帧中创建与源视频中相同但具有目标视频中人物表情的人脸。然后将原人脸替换为假人脸，并将新帧保存为新的假视频。
福利：文末有chat-gpt纯分享，无魔法，无限制 当日也有Pytorch和OpenCV资料免费分享
项目的基本结构(在第一次运行之前)如下所示
├── face_masking.py ├── main.py ├── face_extraction_tools.py ├── quick96.py ├── merge_frame_to_fake_video.py ├── data │ ├── data_dst.mp4 │ ├── data_src.mp4 main.py是主脚本，data文件夹包含程序需要的的data_dst.mp4和data_src.mp4文件。
提取和对齐-构建数据集 在第一部分中，我们主要介绍face_extraction_tools.py文件中的代码。
因为第一步是从视频中提取帧，所以需要构建一个将帧保存为JPEG图像的函数。这个函数接受一个视频的路径和另一个输出文件夹的路径。
def extract_frames_from_video(video_path: Union[str, Path], output_folder: Union[str, Path], frames_to_skip: int=0) -&gt; None: """ Extract frame from video as a JPG images. Args: video_path (str | Path): the path to the input video from it the frame will be extracted output_folder (str | Path): the folder where the frames will be saved frames_to_skip (int): how many frames to skip after a frame which is saved.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b936b7e34e9a607e4cc23577f333543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4198ad51aad62e484a97ca028bff600a/" rel="bookmark">
			手把手带你了解DevTools实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有DevTools的前端就像基督教徒没有耶路撒冷。
前言 经过二十年的发展，我们的调试工具已经渐渐从最初的在IE时代的window.alert()调试，这种调试方式，不可避免的就会有极低的调试效率。到2006年Apple的WebKit团队发布第一代调试工具后面FireFox发布早期调试神器FireBug。直到互联网的发展逐渐来到了移动互联网时代，调试工具届出现了一个大爹那就是Chrome的devTools，它能够支持远程真机调试在那以后调试工具的发展进程和devTools的发展进程几乎画上等号。
调试工具也确实给前端开发者带来了极大的好处，已经成为了目前不可缺少的工具。
DevTools剖析 💡 JavaScript实现 &amp; 实际上是个网页 \ Google：“浏览器不就是跑JS的么？不用JS用什么？”
架构：CS(Client-Server)架构
数据封装协议：CDP(Chrome DevTools Protocol )
一般的DevTools过程
安卓端的过程
工具的四个组成部分：
Fontend: 前端，用户操作的界面Backend: 后端，一般是 Chromium、V8 或 Node.jsProtocol: 调试协议(JSON 格式的数据封装协议，包含了HTTP和WebSocket协议)Message Channels：调试消息通道 源码片段
值得一提的是，当初devTools决定使用WebSocket的时候，WebSocket还仅仅只在实验阶段，由此可见国际大厂的工程师的眼光确实长远\~
如何在devTools中看到CDP传输的信息呢 开启工具 设置中打开工具 使用工具 此时此刻就可以看到请求的入参和出参等信息，前面有提到CDP是基于JSON的，这里我们就可以看到Response中的返回的就是JON格式 发出CDP命令 我们还可以使用 Protocol Monitor(版本 92.0.4497.0+)发出自己的命令。
如果该命令不需要任何参数，请在“协议监视器”面板底部的提示符中键入该命令，然后按 Enter 键，例如：
Page.captureScreenshot。
如果命令需要参数，请以 JSON 形式提供，例如：
{"command":"Page.captureScreenshot","parameters":{"format": "jpeg"}}.
简析CDP协议 CDP文档
什么是CDP？ Chrome DevTools Protocol的数据交互是通过WebSocket进行的。WebSocket是一种全双工通信协议，可以在单个TCP连接上进行双向通信。通过WebSocket，前端和后端之间可以进行实时通信，数据可以在两个方向上实时传输。
在Chrome DevTools Protocol中，前端通过WebSocket向后端发送命令和数据。后端接收到命令和数据后，会根据命令执行相应的操作，并将结果通过WebSocket返回给前端。前端接收到结果后，会将其显示在用户界面上，或者执行相应的操作。
在数据交互过程中，Protocol使用了JSON格式的数据进行传输。JSON是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。在前端和后端之间传输的数据都是JSON格式的字符串。
协议是如何定义的？ 规范协议定义位于 Chromium 源代码树中：(browser_protocol.pdl 和js_protocol.pdl)。它们由 DevTools 工程团队手动维护。声明性协议定义跨工具使用；例如，在 Chromium 中创建了一个绑定层，供 Chrome DevTools 与之交互，并为 Chrome Headless 的 C++ 接口单独生成绑定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4198ad51aad62e484a97ca028bff600a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954acee78be76dbf7f5ff35735a6c447/" rel="bookmark">
			CVE-2023-20860 将组件 org.springframework:spring-webmvc 升级至 5.3.26 及以上版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 采用若依框架开发的系统，安全漏洞扫面显示spring当前版本为5.3.20，需升级至5.3.26+，系统pom.xml中并没有直接指明版本为5.3.20的依赖。
经查找系统中依赖设置是这个：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.5.14&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 打开https://mvnrepository.com/搜索spring-boot-dependencies，进入2.5.14版本
搜索5.3.20，如图
点击进入，确认Managed Dependencies里面包含需要升级的spring-webmvc
以上相同步骤进入spring-boot-dependencies的2.5.15版本，确定相关依赖将升级至5.3.27，满足安全漏洞需求，修改pom文件重新打包，问题解决
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.5.15&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148215df89ca83fee23f0627cc164245/" rel="bookmark">
			js 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b001037da7ef243cca2c9914fa64c13/" rel="bookmark">
			ORACLE归档日志满，没法访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、临时解决归档日志满，没法访问的问题：
su - oracle
rman target/
crosscheck archivelog all;
delete noprompt expired archivelog all;
delete noprompt archivelog until time ‘sysdate-1’;
delete noprompt archivelog all completed before ‘sysdate-1’;
可以看到归档日志被删除。
此刻，尝试连接数据库，仍旧连不上。
采用重启lsnrctl 的方式：
从rman模式quit出来：
lsnrctl stop
lsnrctl start
再试图尝试连接，成功。
二、写 定时任务 定期删归档
#su - oracle
$ mkdir -p /home/oracle/scripts/log
$ vi /home/oracle/scripts/rm_archivelog.sh
#!/bin/sh #rm archivelog Script export ORACLE_HOME=/u01/app/oracle/product/11.2 export ORACLE_SID=sugondb export DBNAME=sugondb export PATH=$ORACLE_HOME/bin:$PATH year=`date "+%Y"` month=`date "+%m"` day=`date "+%d"` hour=`date "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b001037da7ef243cca2c9914fa64c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216d8b18726979ebd5c19d372b2d9216/" rel="bookmark">
			init 服务程序（init.svc.XXX）死亡/重启-SIGCHLD及稳定性杂项记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
init 处理Android 服务程序（init.svc.XXX）死亡/重启过程
稳定性杂项记录
binder 调用时间
log 丢失
c &gt; /proc/sysrq-trigger触发panic
coredump 生成
binder 卡住问题
init 处理Android 服务程序（init.svc.XXX）死亡/重启过程 init 启动服务
1、init.rc 中服务，android init重启service（进程）
https://www.cnblogs.com/aspirs/p/11407611.html
Android Init进程对信号的处理流程详细介绍_Android_脚本之家
system\core\init\init.cpp
1、收到子进程退出，会执行 ReapOneProcess 来收割僵尸进程
2、system\core\init\service.cpp
执行service-&gt;Reap(siginfo)
1、
2、
SurfaceFlinger 被signal 3 杀再次再次重启zygote 。
kernel-4.4/kernel/exit.c 进程被杀执行do_exit
void do_exit(long code) kernel-4.4/kernel/signal.c
__send_signal 发送信号 java 层杀进程
frameworks/base/core/java/android/os/Process.java
frameworks\base\core\jni\android_util_Process.cpp
稳定性杂项记录 binder 调用时间 Android ANR问题（一）-基本分析方法 - 简书
log 丢失 system/core/logd/LogBufferElement.cpp
android log丢失（一）使用logd丢失log原理_kc专栏的博客-CSDN博客
04-07 23:35:45.056 29757 30816 I chatty : uid=1000(system) Binder_C expire 2 lines
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216d8b18726979ebd5c19d372b2d9216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df73f544c48974f37b5bc373bd6492ef/" rel="bookmark">
			Python爬虫深度优化：Scrapy库的高级使用和调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们前面的文章中，我们探索了如何使用Scrapy库创建一个基础的爬虫，了解了如何使用选择器和Item提取数据，以及如何使用Pipelines处理数据。在本篇高级教程中，我们将深入探讨如何优化和调整Scrapy爬虫的性能，以及如何处理更复杂的抓取任务，如登录，处理Cookies和会话，以及避免爬虫被网站识别和封锁。
一、并发和延迟 Scrapy使用异步网络库Twisted来处理网络通信，可以实现高并发下载。你可以在项目的设置文件（settings.py）中调整并发请求的数量，例如：
CONCURRENT_REQUESTS = 100 同时，你也可以设置下载延迟以避免服务器的过载：
DOWNLOAD_DELAY = 2 二、处理登录和Cookies Scrapy可以处理Cookies和会话，以支持需要登录才能访问的网站。例如，你可以在你的爬虫中实现一个start_requests方法，发送一个包含你的登录信息的POST请求，然后在回调函数中处理登录的响应：
import scrapy class LoginSpider(scrapy.Spider): name = 'login' start_urls = ['http://quotes.toscrape.com/login'] def start_requests(self): return [scrapy.FormRequest.from_response( response, formdata={'username': 'user', 'password': 'pass'}, callback=self.after_login )] def after_login(self, response): # check login succeed before going on if "login failed" in response.body: self.logger.error("Login failed") return 三、防止被封 很多网站会使用各种技术防止爬虫抓取他们的内容。以下是一些在Scrapy中实现的常用防封策略：
随机User-Agent：Scrapy可以使用随机User-Agent来模拟不同的浏览器和设备，你可以使用scrapy-fake-useragent扩展实现这个功能。
使用代理：你可以在你的项目中使用中间件来为你的请求设置代理，例如，你可以使用scrapy-proxies扩展。
设置下载延迟和自动节流：你可以在你的项目的设置文件中设置下载延迟，以及启用自动节流扩展。
四、Scrapy Shell和Scrapyrt Scrapy提供了一个交互式shell工具，可以用来测试你的抓取代码。你可以在shell中加载任何网页，并尝试在该网页上运行你的抓取代码。
此外，Scrapy还提供了Scrapyrt（Scrapy Real-time），一个可以让你运行和控制你的爬虫的实时API。
Scrapy是一个强大的爬虫框架，提供了大量的功能和灵活性。在这篇文章中，我们探讨了如何优化和调整Scrapy爬虫的性能，以及如何处理更复杂的抓取任务。希望这篇文章可以帮助你更深入地理解和使用Scrapy。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d3c99a213a6f0c39822ad8546280b8/" rel="bookmark">
			基于Vmware部署centos操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：1、安装前的准备，这一点很重要，要多看一些教程，对新手来说图文的视频的更好，更直观，对一些共性的过程要熟记在心。
2、安装及使用遇到问题。在安装和使用过程中前后共遇到几个问题，也是多数安装虚拟机网民比较困惑的问题。
一是设置文件共享。这个安装过程和第一个问题的前半步骤一样，选项–文件共享–添加–硬盘的盘符–确定，反复操作直到把你主宿机的所有盘符都添加进来，包括移动硬盘的，记得点确定。
二是设置网络共享。这个问题我费了不少时间，感觉很复杂，实际设置相当简单，在安装虚拟机的时候如果你要桥接在后面的设置里你就桥接，不要乱改，如果你要NAT连接，在后面的设置里你也要NAT连接，在网上邻居里设置自动获得IP地址，OK。
1、环境准备 1.基于 Linux 内核的 CentOS-7-x86_64-Minimal-1810.iso 操作系统 2.虚拟机 VMware Workstation Pro 2、环境部署 1）点击新建虚拟机
2）点击自定义
3）默认，下一步
4）稍后安装操作系统
5）选择客户机操作系统（Linux centos 64）
6）更改虚拟机名称（不安装在C盘）
7）默认
8）分配虚拟机内存
9）选择网络类型
10)选择I/0控制器类型
选择磁盘类型
12）选择磁盘
13）选择磁盘容量
14）下一步，完成 15）添加镜像
16）开启虚拟机
如果出现内部错误：百度搜——华硕电脑怎么进入BIOS，怎么开启虚拟机。
17）鼠标光标选中第一行
18）进入安装操作系统界面（点击continue继续）
18）进入安装部署界面（时区选择中国上海）done（完成）
自动分区
手动分区1
手动分区2
手动分区3
手动分区4
手动分区5
选择网络
创建用户密码
管理员密码root：123456
完成重启虚拟机
进入系统
查看IP地址： ip a
通过finalshell 连接到虚拟机
双击host1 ，接收并保存密码
Init 0 ——关机
Init 6 ——重启
如果网络有问题参考如下配置网络（选择VMnet8）：
记住网关IP
打开网络配置文件: vi /etc/sysconfig/network-scripts/ifcfg-ens33
改成：
BOOTPROTO=static
ONBOOT=yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d3c99a213a6f0c39822ad8546280b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e9b42ef1ddac6fe5c22578df3d5392/" rel="bookmark">
			Java线程池七大参数详解和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信像我一样的很多同学，没事刷刷面经，就会发现多线程在面试中出现很频繁，对于Java选手来说，线程池的知识肯定必不可少，今天我们就来详细了解Java线程池的七大参数，积累面试经验。
一、corePoolSize核心线程数 指的是核心线程大小，线程池中维护一个最小的线程数量，即使这些线程处于空闲状态，也一直存在池中，除非设置了核心线程超时时间。
二、maximunPoolSize最大线程数 指的是线程池中允许的最大线程数量。当线程池中核心线程都处理执行状态，有新请求的任务：
1、工作队列未满：新请求的任务加入工作队列
2、工作队列已满：线程池会创建新线程，来执行这个任务。当然，创建新线程不是无限制的，因为会受到maximumPoolSize最大线程数量的限制。
三、keepAliveTime空闲线程存活时间 指的是空闲线程存活时间。具体说，当线程数大于核心线程数时，空闲线程在等待新任务到达的最大时间，如果超过这个时间还没有任务请求，该空闲线程就会被销毁。
四、unit空闲线程存活时间的单位 是指空闲线程存活时间的单位。keepAliveTime的计量单位。枚举类型TimeUnit类。
五、workQueue线程工作队列 1、ArrayBlockingQueue FIFO有界阻塞队列 基于数组的有界阻塞队列，特点FIFO（先进先出）。
当线程池中已经存在最大数量的线程时候，再请求新的任务，这时就会将任务加入工作队列的队尾，一旦有空闲线程，就会取出队头执行任务。因为是基于数组的有界阻塞队列，所以可以避免系统资源的耗尽。
那么如果出现有界队列已满，最大数量的所有线程都处于执行状态，这时又有新的任务请求，怎么办呢？
这时候会采用Handler拒绝策略，对请求的任务进行处理。后面会详细介绍。
2、LinkedBlockingQueue FIFO无限队列 基于链表的无界阻塞队列，默认最大容量Integer.MAX_VALUE( 2^{32}-1)，可认为是无限队列，特点FIFO。
关于maximumPoolSize参数在工作队列为LinkedBlockingQueue时候，是否起作用这个问题，我们需要视情况而定！
情况①：如果指定了工作队列大小，比如core=2，max=3，workQueue=2，任务数task=5，这种情况的最大线程数量的限制是有效的。
情况②：如果工作队列大小默认2^{32}-1，这时maximumPoolSize不起作用，因为新请求的任务一直可以加到队列中。
3、PriorityBlockingQueue VIP 优先级无界阻塞队列，前面两种工作队列特点都是FIFO，而优先级阻塞队列可以通过参数Comparator实现对任务进行排序，不按照FIFO执行。
4、SynchronousQueue不缓存任务的阻塞队列 不缓存任务的阻塞队列，它实际上不是真正的队列，因为它没有提供存储任务的空间。生产者一个任务请求到来，会直接执行，也就是说这种队列在消费者充足的情况下更加适合。因为这种队列没有存储能力，所以只有当另一个线程（消费者）准备好工作，put（入队）和take（出队）方法才不会是阻塞状态。
以上四种工作队列，跟线程池结合就是一种生产者-消费者 设计模式。生产者把新任务加入工作队列，消费者从队列取出任务消费，BlockingQueue可以使用任意数量的生产者和消费者，这样实现了解耦，简化了设计。
六、threadFactory线程工厂 线程工厂，创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等。
守护线程(Daemon Thread) 在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon
Thread)。
所谓守护
线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。
用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。
因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。
将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：
(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
(2) 在Daemon线程中产生的新线程也是Daemon的。
(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。
七、handler超出线程数和工作队列时候的任务请求处理策略 Java 并发超出线程数和工作队列时候的任务请求处理策略，使用了策略设计模式。
策略1：ThreadPoolExecutor.AbortPolicy（默认）拒绝执行 在默认的处理策略。该处理在拒绝时抛出RejectedExecutionException，拒绝执行。
策略2：ThreadPoolExecutor.CallerRunsPolicy调用 execute 方法的线程本身运行任务 调用 execute 方法的线程本身运行任务。这提供了一个简单的反馈控制机制，可以降低新任务提交的速度。 策略3：ThreadPoolExecutor.DiscardOldestPolicy执行程序未关闭，则删除工作队列头部的任务 如果执行程序未关闭，则删除工作队列头部的任务，然后重试执行(可能再次失败，导致重复执行)。 策略4：ThreadPoolExecutor.DiscardPolicy无法执行的任务被简单地删除 无法执行的任务被简单地删除，将会丢弃当前任务，通过源码可以看出，该策略不会执行任务操作。 八 ThreadPoolExecutor线程池参数设置技巧 一、ThreadPoolExecutor的重要参数 corePoolSize：核心线程数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e9b42ef1ddac6fe5c22578df3d5392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72eadec785e939b30f0401b45130cb13/" rel="bookmark">
			windows flask服务卡死的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows flask服务卡死的问题 最近的工作中，需要用python写一个flask服务，供C++端调用，但是偶尔服务会卡住，只接收数据但不进行处理，不过Ctrl+C后又可以继续运行。
查看了网上的一些解决方法，但似乎都没有什么效果：
1.运行函数时设置多线程运行 python 代码名.py runserver --threaded
发现问题依然出现
2.在运行时设置多进程，例如app.run(processes=3)
运行时报错，显示不能同时设置多线程和多进程，再网上搜了一下貌似flask不支持windows在run函数中设置多进程
3.在cmd窗口中上面菜单栏右键-属性-取消快速编辑模式
发现问题也没有解决
解决方法 最后发现我在flask中的一个程序内部（@app.route下面的那个函数里面又用到了多进程multiprocessing），将多进程实现的方式改成单进程之后就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5304cc9aebae85277f2de83749320c/" rel="bookmark">
			Wayland：推动Linux桌面进入下一代图形显示时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发地址
Wayland是Linux系统下的一种图形显示协议，旨在替代X Window System（X11）作为Linux桌面环境的图形显示服务。下面是对Wayland的详细解释：
背景： 传统的Linux桌面环境使用X Window System（X11）作为图形显示协议。然而，X11存在一些问题，如性能瓶颈、复杂的架构和安全性问题。Wayland的出现是为了解决这些问题，并提供更现代、高效和安全的图形显示服务。架构： Wayland采用了简化的架构，将图形显示服务和应用程序之间的通信简化为基于消息的方式。它采用了客户端-服务器的模型，其中Wayland服务器（compositor）负责管理图形显示，而Wayland客户端（应用程序）则负责渲染和交互。性能优势： Wayland采用了直接渲染（direct rendering）的方式，将应用程序直接绘制到显卡缓冲区，避免了传统X11中多次复制和转换的过程，从而提高了渲染性能和响应速度。安全性： 由于Wayland采用了简化的架构，客户端之间的隔离更加严格。每个Wayland客户端只能访问自己的缓冲区，无法直接读取或修改其他应用程序的数据，从而提高了安全性。易用性： Wayland的设计目标之一是提供更好的用户体验。它支持多点触控、高分辨率屏幕和图形特效等现代特性，并提供了更平滑的窗口管理和过渡效果。应用支持： 目前，许多主流的Linux发行版已经开始支持Wayland，并提供了对应的Wayland compositor。大部分常见的应用程序都可以在Wayland下正常运行，但仍然有一些依赖于X11的应用程序可能需要进行适配或使用兼容层（如XWayland）来实现兼容。 总的来说，Wayland是一种现代化的图形显示协议，旨在提供更高效、更安全和更好的用户体验。尽管目前仍有一些挑战和应用兼容性问题，但Wayland在Linux桌面环境中的使用越来越广泛，被认为是未来的发展方向之一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6347d162a74251658e927480c0366014/" rel="bookmark">
			【转载】Swagger常用注解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用 简书-Xiangdong_She
常用到的注解有： ApiApiModelApiModelPropertyApiOperationApiParamApiResponseApiResponsesResponseHeader 1. api标记
Api 用在类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源，使用方式：
@Api(value = "/user", description = "Operations about user") 与Controller注解并列使用。 属性配置：
属性名称备注valueurl的路径值tags如果设置这个值、value的值会被覆盖description对api资源的描述basePath基本路径可以不配置position如果配置多个Api 想改变显示的顺序位置producesFor example, "application/json, application/xml"consumesFor example, "application/json, application/xml"protocolsPossible values: http, https, ws, wss.authorizations高级特性认证时配置hidden配置为true 将在文档中隐藏 在SpringMvc中的配置如下：
@Controller @RequestMapping(value = "/api/pet", produces = {APPLICATION_JSON_VALUE, APPLICATION_XML_VALUE}) @Api(value = "/pet", description = "Operations about pets") public class PetController { } 2. ApiOperation标记
ApiOperation：用在方法上，说明方法的作用，每一个url资源的定义,使用方式：
@ApiOperation( value = "Find purchase order by ID", notes = "For valid response try integer IDs with value &lt;= 5 or &gt; 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6347d162a74251658e927480c0366014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c068882ecb01b7cc23abe48dcea5b0c/" rel="bookmark">
			06目标检测-One-stage的目标检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 One-stage目标检测算法 使用CNN卷积特征直接回归物体的类别概率和位置坐标值（无region proposal）准确度低，速度相对two-stage快 二、One-stage基本流程 输入图片------对图片进行深度特征的提取（主干神经网络）------对目标的位置进行定位和分类，One-stage和Two-stage的区别就在于是否包含了候选区域推荐的过程。Two-stage流程图如下:
三、One-stage常见算法 One-stage常见算法
YOLOV1/V2/V3SSD/DSSD等Retina-Net… 四、One-stage的核心组件 1、One-stage的两个核心组件 CNN网络（主干网络）回归网络 2、主干CNN网络设计原则 从简单到复杂，再从复杂到简单的卷积神经网络多尺度特征融合的网络更轻量级的CNN网络 3、回归网络 回归网络将通过CNN主干网络卷积层获取的feature maps作为回归网络的输入，通过回归网络主要完成了区域回归、目标区域类别的判定。
回归网络中有两个主要内容：
回归区域（置信度、位置、类别）Anchor机制（SSD） 回归区域（置信度、位置、类别） 通过回归网络直接输出最终目标的bounding box位置信息。这里的位置信息就是下图中的红框和蓝框的位置信息，这都是区域回归最终输出结果。所以说回归网络是目标检测算法One-stage中的重要组部分。
图中右侧图片里红色小框中有目标区域置信度会更高。其他小框的置信度会低。 置信度：是指是否存在目标，如果存在，表示代表目标区域，如果不是目标表示是背景区域
类别：表示是否是目标区域，一般用概率表示，概率高表示是目标区域。类别主要是通过对anchor box的回归得到。
位置：图像的位置，主要通过对anchor box的回归得到。
Anchor机制： 找到不同的推荐区域（属于Two-stage的RPN网络的核心组件，One-stage则没有此组件，One-stage和Two-stage的区别在于是否有RPN推荐区域提取，但不影响One-stage使用RPN的思想，如:Anchor机制）在SSD目标回归（左边），经过主干网络卷积之后得到的feature map，考虑feature map中的每一个点都是一个Anchor，基于当前的Anchor来提取不同尺度的长宽比，对于不同尺度的长宽比所对应的目标区域，利用此目标区域来进行位置的回归和类别的判定。
yolo没有Anchor机制（右边）用的是各自坐标（左上右下）
4、回归网络预测过程（Yolo） 过程：对整个图片进行划分，S * S 的格子，针对每个网格分别预测当前这个网格为中心的目标区域的位置信息（中上部图），预测出Bounding boxes和置信度，此外还会对每个格子预测目标类别的概率分布值（中下图），（B *5+C）*S *S 维的向量（最终输出） (B:每个格子预测多少的bouding boxes数；5：四个坐标加一个置信度；C：类别)，最终的输出就对应到了这里的bouding box坐标的位置，以及bouding box置信度和对于每一个格子所对应的类别的概率分布，在拿到这些值之后，再利用每一个网格预测的类别信息和bouding box 所对应的置信度进行相乘，就能够拿到每一个bouding box所对应的类别置信度信息，利用类别置信度信息再结合NMS算法，对预测出的所有的Bouding box进行筛选过滤，得到最终预测结果。这个过程也是yolo算法在拿到回归网络预测结果之后得到最终的输出所经过的运算过程。实际上对于SSD和faster RNN这样的检测网络，最终输出的bouding box本身预测出的概率分布，可直接用于NMS算法所需要的类别置信度分数，在yolo算法中需要额外将中间两个图的结果进行融合（两个置信度相乘得到最终能分数置信度，最为NMS输入）。
yolo是纯粹的端到端的回归网络，检测效率会更高。但是在yolo算法中通长使用各自划分，认为每一个格子点都是目标检测的中心点，有可能我们划分的格子都不是目标的中心点，因此基于中心点预测目标区域所对应的bouding box信息的前提假设会导致我们预测出来的检测相比于SSD，faster rcnn准确率低。再有，由于在yolo中划分格子的时候会忽略掉其中的小物体，比如说鸟类识别检测鸟群，可能会漏检。但整体检测速度快。
五、One-stage VS Two-stage
上一篇：04目标检测-Two-stage的目标检测算法
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/113/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>