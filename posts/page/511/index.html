<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0202e526e063573c408b1db43f56ce2c/" rel="bookmark">
			状态栏上放进度条&amp;纹理操作@MFC/OpenGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天的进展是，OpenGL方面：对纹理的半透明的显示，MFC方面：在状态栏上放进度条，能根据进度对进度条进行实时更新。
从昨天到今早，做的东西还算是比较多的，下午一直在移植代码，有点焦头烂额的感觉，想着应该把节奏放放，否则做过的，遇到的问题不总结总结，只怕是下午又遇到后，就没啥感觉了，下面一点一点道来：
1. 大致按问题的重要程度来排序吧，先是纹理的绑定，由于我的程序实现的是，静态分割窗口，一个Doc对应两个View，两个View都需要OpenGL的渲染环境，也就是一个DC（设备上下文），对应两个RC（渲染上下文），而一个RC同一时刻只能分配到一个RC上，也就是说，两个RC要轮流切换着，至于有人说啥多个DC，对应多个RC，可以同时绘制，由于不大懂就作罢了，而且现在的这个比较好理解，就暂且用着。而纹理的绑定glBindTexture，是共享在当前RC下的display-list space中的（参见这里），也就是说每次如果有切换View，并且要绑定纹理的话，必须先切换当前的RC，而纹理的绑定对纹理的显示效率提高至关重要，在各自的View中添加一个绑定纹理的方法，然后按照上述所说操作就可以了。有关纹理的优化，这里，这里讲的很不错，推荐。
2. 纹理的显示没问题后，由于左视图中的纹理要采用半透明的效果，于是用到了glBlendFunc函数，然后对混合知识补充了下，所谓混合制造透明效果，其实就是对两类RGBA颜色，进行某种线性运算后的结果，给人种透明的假想，其实还是二维的信息。在这、这、这有了大致的了解，MSDN里讲的很不错，以后要养成看MSDN的习惯，这里提到，如果在绘制的3D的对象的话，要注意把深度测试给关闭了，否则有些地方就达不到混合的效果了。
3. 昨晚弄OpenGL弄的有点烦了之后，就弄弄MFC方面的调解调解（晚上回去瞎翻了翻毕淑敏的书看看，调剂调剂，发现文字很吸引人啊），在状态栏上放进度条，这，这可以做参考，这篇博文转载的算是比较多的了，而且内容比较完整，照着做后才发现，那是相当的晕的，要么是比较旧的，要么就是那人蛋疼，不过，让我学习了下怎么自定义消息，消息响应函数，还是不错的，里面那个OnProgress函数，由于开发平台式VS2008的缘故，必须弄成返回值是LRESULT，带有WPARM和LPARM参数（参见这里），后两个术语把我弄的比较蛋疼，从MSDN那儿链到这里，然后就豁然开朗了，W指的是WORD(16)，L指的是LONG(32)，由于最开始的是16位的平台，WORD型变量用来传其他参数，LONG型变量用来传指针，虽然现在硬件发展了，还沿用了原来的命名习惯。
4. 至于状态栏中放进度条，跟工具栏中放滑动条有点类似，新建一个变量继承自CStatusBar，添加成员变量CProgressCtrl，通过它的Creat方法来新建，至于消息响应的话，在MainFrame下添加消息响应函数afx_msg void OnProgress()，然后和之前设好的消息ID通过ON_MESSAGE(MYWM_PROGRESS, OnProgress)进行绑定，ID设成(WM_USER+100)，这里+100为了防止和系统ID或是其他的ID冲突，这些都准备好后，在需要调用该响应函数的地方，发送消息就可以了，用SendMessage，可以注意到MainFrame是CProgressCtrl的父容器的父容器，一般都是放在父容器的，我觉得其中一个原因可能是，如果是父容器的话，操作比较简单，就是直接对成员变量操作。这些完了之后，就是选择进度条放在哪了，MainFrm.cpp中有indicator数组，放的就是状态栏中具体划分的块数，可以参加这里，ID_SEPARATOR指的是占位符，然后可以通过CStatusBar::SetPaneInfo，来设置在状态栏中的样式，包括是不是3D状的，这些搞定后，然后就是同上面的一些操作类似，会有些乱七八糟的业务，一一搞定就可以了，Debug了蛮久的。
PS. 稍微总结下，实现的初期效果比较满意，图就不上了，但也有不少的疑问，如加了进度条后，加载一张vase1.png图片从原先的9s到现在的12s，设置进度条状态有那么耗时吗，在用户体验上，还有很多需要做的，也有些心得，对面向对象编程，有点理解，因为我没怎么面向对象，然后代码就越来越复杂了，乱七八糟的，调来调去的，然后我就会主动的去想，怎么把具有功能的代码放在一起写成一个函数放到相应的对象下，这样别人要用的时候，直接调用就可以了。接下来，先把最核心的功能处实现下，随着实现，又发现了不少需要做的，为了用户的操作方便。有一点有进展的是，对于时耗的瓶颈处，频繁修改的一个三角形集合的显示，起初用显示列表没能搞定，效果比较差，并且在CSDN上发帖寻求帮助，今天打开发现有人提出了很好的建议（至今有1个月了，囧），我可以尝试一下。插一句，今天下午移植代码的时候，发现还写了不少的，虽然有点后怕，但想起来比前些天有了些许进步而且看到了进展，心里就甜滋滋的。今天是第5天，也才5天而已，继续~
转载于:https://www.cnblogs.com/litstrong/archive/2011/02/25/1964363.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b356d137581a2a8858d6568406c0d0/" rel="bookmark">
			谷歌语音搜索相关讲座
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在国际公开课《人机交互研讨》的第五讲，大家可以看到两个来自谷歌的研究人员讲解他们的语音搜索服务。对移动搜索服务感兴趣的朋友可以有很多收获，因为这个讲座的前面花了很多时间讲解基于手动输入（typing）时代PC搜索,IPHONE搜索（智能机）和MOBILE WEB搜索
（非智能机）用户搜索模式的分析；这成为语音输入的出发点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1867556177d72fa68676f3d687acf0/" rel="bookmark">
			标准Linux文件系统层次标准（Filesystem Hierarchy Standard，FHS）第五章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看一篇文章，里面提到了Linux文件系统层次标准（FHS）。之后我就看了FHS。由于本人读英文文章很慢，为了以后方便自己也方便大家，我就把Filesystem Hierarchy Standard翻译了下，可能有的地方不是很到位，请谅解。
如果您看了，觉得对您有点帮组，请支持一下，毕竟翻译该文章也花费了我两星期的业余时间。
如果要转载请注明出处，谢谢。
标准Linux文件系统层次标准（Filesystem Hierarchy Standard）
l 第五章操作系统特定的附件
该章节作为特定操作系统的其他要求和建议。本章节所提到的内容不会反应到基本标准里面。
/ : 根目录
一个Linux操作系统，如果内核在根目录下，我们建议内核的名字命名为vmlinux或vmlinuz，该命名方式的内核已经在最近的Linux内核源码包里用了。
/bin : 用户基本命令二进制文件（被所有用户使用）
Linux系统需要将以下额外的文件放在/bin中：
l Setserial
/dev : 设备文件和特殊文件
下面设备必须存在于/dev下。
/dev/null
所有写入这个设备的数据都被丢弃。从该设备读数据将返回EOF。
/dev/zero
该设备是一个归零的数据源。所有写入这个设备的数据都被丢弃。读取该设备将返回和请求一样多的零值。
/dev/tty
该设备是一个进程的控制终端的代名词。一旦该设备被打开，所有的读和写操作就像操作一个实际的控制终端一样。
/etc : 主机特定的系统文件
Linux系统需要将以下额外的文件放在/etc中：
l Lilo.conf
/lib64和/lib32 : 64位32位库文件（架构相关）
64位架构的PPC64, s390x, sparc64, 和AMD64的64位库文件放在/lib64下，32位（或s390上的31位库）库文件放在/lib下。
64位架构的IA64必须放置它的64位库在/lib下。
/sbin : 基础的系统二进制文件
Linux系统需要将以下额外的文件放在/sbin中。
l 第二文件系统扩展命令。
u badblocks
u dumpe2fs
u e2fsck
u mke2fs
u mklost+found
u tune2fs
l 引导加载图安装器（可选）
u Lilo
/sbin的可选文件
l 静态二进制文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1867556177d72fa68676f3d687acf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a643eedf04f6746348d5fd5d450e2fc/" rel="bookmark">
			使用视图和存储过程的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用视图和存储过程的优缺点 --以下内容整理自网络
视图的优点:
简单性 视图不仅可以简化用户对数据的理解，也可以简化他们的操作，哪些经常使用的查询可以被定义为视图，从而使用户不必为以后的操作每次都指定全部的条件。
安全性 隐藏数据源,通过视图用户只能查询和修改他们所能见到的数据，数据库中的其它数据则看不见也取不到。
逻辑数据独立性 视图可以使应用程序和数据库在一定程序上独立。如果没有视图，应用一定是建立在表上。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。
方便性
在多表连接查询时，可以使用视图提高效率
视图的缺点:
性能差 sql server必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，sql server也要把它变成一个复杂的结合体，需要花费一定的时间。
修改限制
当用户试图修改试图的某些信息时，sql server必须把它转化为对基本表的某些信息的修改，对于简单的试图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。
存储过程的优点：
预编译
当一个sql语句包含在存储过程中时，服务器不必每次执行它时都要分析和编译它，避免了sql语句在网络中传输然后再解释的低效率问题。
修改方便
直接修改存储过程，方便代码的管理。
安全
不会有sql语句注入问题。
可以建立复杂的查询
可以用存储过程建立非常复杂的查询，以非常复杂的方式更新数据库。
可以使用参数
在存储过程中可以使用参数，可以传送和返回参数。　存储过程的缺点:
增加复杂性
当业务逻辑比较复杂时不建议使用存储过程，这样会增加复杂性。
可移植性低
在不同的数据库平台上很难移植
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d83a99a895b0fcbaab2eb5cdec49f8/" rel="bookmark">
			Matlab 取整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1)fix(x) : 截尾取整.
&gt;&gt; fix( [3.12 -3.12])
ans =
3 -3
(2)floor(x):不超过x 的最大整数.(高斯取整)
&gt;&gt; floor( [3.12 -3.12])
ans =
3 -4
(3)ceil(x) : 大于x 的最小整数
&gt;&gt; ceil( [3.12 -3.12])
ans =
4 -3
(4)四舍五入取整
&gt;&gt; round([3.12 -3.12])
ans =
3 -3
MATLAB中四个取整函数具体使用方法如下：
Matlab取整函数有: fix, floor, ceil, round. fix 朝零方向取整，如fix(-1.3)=-1; fix(1.3)=1; floor 朝负无穷方向取整，如floor(-1.3)=-2; floor(1.3)=1; ceil 朝正无穷方向取整，如ceil(-1.3)=-1; ceil(1.3)=2; round 四舍五入到最近的整数，如round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2。 转载于:https://www.cnblogs.com/lovemo1314/archive/2010/09/27/1836896.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baada3482c55e74b00f5a57d9681349c/" rel="bookmark">
			maven 连 nexus 服务器（样本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings&gt;&lt;mirrors&gt;&lt;mirror&gt;&lt;!--This sends everything else to /public --&gt;&lt;id&gt;nexus&lt;/id&gt;&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;&lt;url&gt;http://ip:port/nexus/path/name/public&lt;/url&gt;&lt;/mirror&gt;&lt;/mirrors&gt;&lt;profiles&gt;&lt;profile&gt;&lt;id&gt;nexus&lt;/id&gt;&lt;!--Enable snapshots for the built in central repo to direct --&gt;&lt;!--all requests to nexus via the mirror --&gt;&lt;repositories&gt;&lt;repository&gt;&lt;id&gt;central&lt;/id&gt;&lt;url&gt;http://central&lt;/url&gt;&lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;&lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;&lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt;&lt;id&gt;central&lt;/id&gt;&lt;url&gt;http://central&lt;/url&gt;&lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;&lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt;&lt;!--make the profile active all the time --&gt;&lt;activeProfile&gt;nexus&lt;/activeProfile&gt;&lt;/activeProfiles&gt;&lt;servers&gt;&lt;server&gt;&lt;id&gt;nexus&lt;/id&gt;&lt;username&gt;username&lt;/username&gt;&lt;password&gt;password&lt;/password&gt;&lt;/server&gt;&lt;/servers&gt;&lt;/settings&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5df2778001969e2a060c67f4c26a678/" rel="bookmark">
			glRotatef 函数的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		glRotatef(GLfloat angle,GLfloat x,GLfloat y,GLfloat z)
glRotatef(45,1,0,0)
物體如何旋转？想象：从 坐标（0，0，0）即原点，引出一条线到（1,0,0）,用右手握住这条线，这时，你会问，如何握？右手大拇指指向 （0，0，0）至（1，0，0）的方向 才握。另外四个手指的弯曲指向 即是物体旋转方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172b29e552449e5b9e37c3ef6041791e/" rel="bookmark">
			Message Mapping（消息映射）（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：http://www.cppblog.com/nacci/archive/2006/05/18/7363.html
MFC中的消息循环呢？我们熟悉的switch……case……到哪里去了？
在MFC中，消息的循环并不是用switch……case……实现的，它依赖于一张由程序自身定义的消息网。
首先，MFC用一个名为AFX_MSGMAP_ENTRY结构来对消息的信息进行封装： struct AFX_MSGMAP_ENTRY
{
UINT nMessage; // windows message UINT nCode; // control code or WM_NOTIFY code UINT nID; // control ID (or 0 for windows messages) UINT nLastID; // used for entries specifying a range of control id's UINT_PTR nSig; // signature type (action) or pointer to message # AFX_PMSG pfn; // routine to call (or special value) } ; 其中　typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172b29e552449e5b9e37c3ef6041791e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3febdad873351c4f71d613b1adca276/" rel="bookmark">
			STL vector::end()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准模板库的容器最基本的三个函数 vector::begin(), vector::end(), vector::size()
iterator = vector::end() 返回的不是指向最后一个元素，而是指向最后的结束符。--iterator才是指向最后一个元素。
例：
// cliext_vector_end.cpp // compile with: /clr #include &lt;cliext/vector&gt; int main() { cliext::vector&lt;wchar_t&gt; c1; c1.push_back(L'a'); c1.push_back(L'b'); c1.push_back(L'c'); // display initial contents " a b c" for each (wchar_t elem in c1) System::Console::Write(" {0}", elem); System::Console::WriteLine(); // inspect last two items cliext::vector&lt;wchar_t&gt;::iterator it = c1.end(); --it; System::Console::WriteLine("*-- --end() = {0}", *--it); System::Console::WriteLine("*--end() = {0}", *++it); // alter first two items and reinspect *--it = L'x'; *++it = L'y'; for each (wchar_t elem in c1) System::Console::Write("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3febdad873351c4f71d613b1adca276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd9ae2a9fb9b3505861c7d2f1a8994b/" rel="bookmark">
			Asp.net的身份验证方式有哪些，原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 Windows 身份验证提供程序 提供有关如何将 Windows 身份验证与 Microsoft Internet 信息服务 (IIS) 身份验证结合使用来确保 ASP.NET 应用程序安全的信息。 2、 Forms 身份验证提供程序 提供有关如何使用您自己的代码创建应用程序特定的登录窗体并执行身份验证的信息。使用 Forms 身份验证的一种简便方法是使用 ASP.NET 成员资格和 ASP.NET 登录控件，它们一起提供了一种只需少量或无需代码就可以收集、验证和管理用户凭据的方法。有关更多信息，请参见使用成员资格管理用户和 ASP.NET 登录控件概述。 3、 Passport 身份验证提供程序 提供有关由 Microsoft 提供的集中身份验证服务的信息，该服务为成员站点提供单一登录和核心配置文件服务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8550a4757d3aae8c68eb9b2e1083bea9/" rel="bookmark">
			视频无损剪切分割截取合并工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频无损剪切分割截取合并工具
1.... 另存与分割... 1
2.... 常用分割软件。... 2
A. AVS Video ReMaker 2
B. Boilsoft Video Splitter 2
C. RealMedia Editor 3
D. Tmpgenc. 4
E. vcdcutter 4
F. virtualdub. 4
G. AVI MPEG ASF WMV Splitter 4
3.... 常见格式的分割... 4
4.... 视频无损合并工具... 5
a) boilsoft_video_joiner 5.32（以前的 AVI/MPEG/RM/WMV Joiner）（含注册码）... 5
b) Ultra_Video_Joiner 5.6.0525（含注册码）... 6
c) Allok_Video_Joiner 4.6.0529（含注册码）... 7
很多人都有这样的需求：就是把一部电影中的某一段单独保存下来。或用于编辑或用于保存……
这样的事情，通常被称为“分割”，或“切割”。
其实，说“截取”比较好一些。就是从一段视频中把一小段截取出来做为已用。
视频的截取，分为两种。一种是另存，一种是分割。
这二者的区别在于：分割是无损的，速度快，基本上和拷贝的速度差不多；而另存，是重新编码，速度慢，如果你的机器很慢的话，那么就不是一个“慢”字了得了，如果你感情足够脆弱的话，会哭的……　1. 另存与分割
所有的非编软件，比如premiere、vegas、edius、会声会影等，都是“一揽子”解决方案。他们把各种视频软件调入，然后以支持的格式输出。这种输出，绝大多数都是另存，都要重新编码。视频，只要重新编码，肯定会有损失，而且速度慢……哭不哭，视机器配置、视频长短及个人感情坚硬度而定……
很多视频转换软件，也可以选择从哪里转换到哪里，专业一点的说法就是“入点”和“出点”，这样，也能截取视频，只不过，通常也是重新编码。
前面说过，分割是无损的，速度快。因为它不重新编码，所以，速度与拷贝差不多。
但，既然不重新编码，也就意味着是按原编码保存。那么，由于各种视频格式的版权保护问题，由于软件编写者的技术水平问题，不同视频格式，使用的软件也不同。
2. 常用分割软件。 A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8550a4757d3aae8c68eb9b2e1083bea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68b1e293cfe54ccde3248290b42dd74/" rel="bookmark">
			QListView和QListWidget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天搞了一个早上，终于弄清楚了。
QListView是基于Model，而QListWidget是基于Item。这是它们的本质区别。
往QListView中添加条目需借助QAbstractListModel:
如：
MainWindow::MainWindow(QWidget *parent) :
QMainWindow(parent),
ui(new Ui::MainWindow)
{
ui-&gt;setupUi(this);
QStringListModel* slm = new QStringListModel(this);
QStringList* sl = new QStringList();
sl-&gt;append("asdfsadfsa");
sl-&gt;append("asdfsadfsa");
sl-&gt;append("asdfsadfsa");
slm-&gt;setStringList(*sl);
ui-&gt;listView-&gt;setModel(slm);
delete sl;
}
而在QListWidget中添加条目可以直接additem
如：
QListWidget list;
list.setViewMode(QListWidget::IconMode );
list.setResizeMode(QListWidget::Adjust);
list.setMovement(QListWidget::Static);
for(int i =0; i &lt; 100 ; i ++){
QListWidgetItem *item = new QListWidgetItem(&amp;list);
QStyle::StandardPixmap sp = (QStyle::StandardPixmap)(i % 57);
item-&gt;setData(Qt::DecorationRole, qApp-&gt;style()-&gt;standardPixmap(sp).scaled(QSize(16,16), Qt::KeepAspectRatio, Qt::SmoothTransformation) );
item-&gt;setData(Qt::DisplayRole,QObject::tr("Item %1").arg(i));
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87416c402ea777bf216c08fb23c7f14/" rel="bookmark">
			x86 几个特权级别(CPL,RPL,DPL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在阅读linux内核的时候，在linux内核的权限保护机制部分，经常会讨论几个特权级别:CPL,RPL，DPL。下面简单讲一下我自己的理解。 背景知识：
1 x86体系结构的几个段寄存器：cs,ds,es,ss.fs.gs 它们无论在实模式下还是保护模式下，都是16位的寄存器，只是功能不而已。 实模式下： 用做段寄存器，用来将逻辑地址转换到线性地址 保护模式下：段选择子，用来作为索引在GDT表或LDT表等中选择段描述符。 主要内容： 1 段选择子基本结构： index TI RPL 13bit 1bit 2bit 因此，段选择子中最低2bit叫做RPL. 作为段选择子的时候，cs和ss比较特殊，它们的RPL代表着当前进程的特权级，因此，二者的RPL又叫CPL。 DPL就不用多说了，段描述符表中的两位。 2 举个例子 mov $0, offset(%ds) 这条指令的地址cs:ip, 那么cs中的最低两位就是cpl,即执行这条指令的当前特权级。 现在要将0写入某个地址，那么就要去查看有没有权限写入，首先检查的就是%ds中的rpl,然后再去检查%ds索引的段描述符中的dpl。假设当前cpl=0, %ds中的rpl =1, 段选择子中的dpl=3,那么cpl的特权级高于dpl,rpl的特权级高于dpl,访问合法。可以这样理解，首先拿当前特权级cpl与段选择子中的rpl比较，得出能不能访问某个段描述符的结论， 然后拿rpl去与段描述符中的dpl比较，就是拿着rpl这个特权级能不能访问实际的段。 cpl先去拿一个特权级别rpl,然后利用取得的这个特权级rpl去访问某个特权级dpl的段。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce732d08e79b465feaec7753726c64bf/" rel="bookmark">
			关于基类指针、派生类指针、基类对象派、生类对象问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基类指向派生类的指针
2、派生类指向基类的指针
3、以及将派生类指针强制转换为基类指针
4、将基类指针强制转换为派生类指针
无论是基类指向派生类还是派生类指向基类，重点就是哪个类的指针就调用哪个类的方法，而输出的是指针指向的对象。
基类指向派生类的指针即将派生类对象赋给基类指针，如果输出的话，调用的方法是基类的方法，输出的是基类在派生类中的成员(想要通过基类指针调用那些只有派生类才有的成员将会产生语法错误 )。
派生类指向基类的指针即将基类对象赋给派生类指针，调用的是派生类的方法，输出的是基类对象的成员。
还有一点就是把基类指针直接赋给派生类指针是危险的，编译器不允许真么做，也不会作隐式转换，显示调用说明程序员已经知道了这种危险性。用派生类指针引用基类对象是个语法错误，如果非要这么做的话，必须像程序中那样，先用基类指针指向基类对象，再将基类指针强制转换为派生类指针 。
原文出自：
http://hi.baidu.com/lml12377/blog/item/566fa6f8efa51209d8f9fd78.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d272aab14230b87e333a6982c2d937/" rel="bookmark">
			对线程控制 中 Sleep(0),和 Sleep(1)的 //对相关转帖的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
笔者在 网上看到的对Sleep(0)的理解如下：
/*
本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/burningcpu/archive/2008/09/20/2955275.aspx
Sleep(n)的作用是让当前线程睡眠n毫秒，以便执行其他线程，如果没有其他线程，那睡眠n毫秒后，继续执行。 而如果n=0，Sleep(0)是指CPU交出当前线程的执行权，让CPU去执行其他线程。也就是放弃当前线程的时间片，转而执行其他线程。
那么，Sleep(0)应该在那种情况下使用？ 一般来说，如果当前线程比较耗时比较占CPU资源，可以在结尾处加上Sleep(0), 这样效率会得到大大的提高。
另外，还可以用这种方法来保证线程同步，线城池工作时，主线程使用Sleep(0)来等待线程池里所有的线程都完成运行。当线程池线程非常多的时候，这种方法确实是一种非常有效的节省cpu的方式，因为它节省了在线程里使用内核来进行同步的开销。
*/
/* 转载MSDN：
Sleep The Sleep function suspends the execution of the current thread for a specified interval. VOID Sleep(DWORD dwMilliseconds // sleep time in milliseconds);Parameters dwMilliseconds Specifies the time, in milliseconds, for which to suspend execution. A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d272aab14230b87e333a6982c2d937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28571964a492b00e581396b2a11114b/" rel="bookmark">
			10则哲理故事照亮你的前途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一只火鸡和一头牛闲聊，火鸡说：我希望能飞到树顶，可我没有勇气。牛说：为什么不吃一点我的牛粪呢，他们很有营养。火鸡吃了一点牛粪，发现它确实给了它足够的力量飞到第一根树枝，第二天，火鸡又吃了更多的牛粪，飞到第二根树枝，两个星期后，火鸡骄傲的飞到了树顶，但不久，一个农夫看到了它，迅速的把它从树上射了下来。 生存之道1：牛屎运让你达到顶峰，但不能让你留在那里
2.乌鸦站在树上，整天无所事事，兔子看见乌鸦，就问：我能像你一样，整天什么事都不用干吗？乌鸦说：当然，有什么不可以呢？于是，兔子在树下的空地上开始休息，忽然，一只狐狸出现了，它跳起来抓住兔子，把它吞了下去。
生存之道2：如果你想站着什么事都不做，那你必须站的很高，非常高。 3.一只小鸟飞到南方去过冬。天很冷，小鸟几乎冻僵了。于是，飞到一大块空地上，一头牛经过那儿，拉了一堆牛粪在小鸟的身上，冻僵的小鸟躺在粪堆里，觉得很温暖，渐渐苏醒过来，它温暖而舒服的躺着，不久唱起歌来，一只路过的野猫听到声音，走过去看个究竟，循着声音，野猫很快发现了躺在粪堆里的小鸟，把它拽出来吃掉了。 生存之道3：不是每个往你身上拉大粪的人都是你的敌人。也不是每个把你从粪堆里拉出来的人都是你的朋友，还有，当你躺在粪堆里时，最好把你的嘴闭上。
4.有位秀才第三次进京赶考，住在一个经常住的店里。考试前两天他做了三个梦，第一个梦是梦到自己在墙上种白菜，第二个梦是下雨天，他戴了斗笠还打伞，第三个梦是梦到跟心爱的表妹脱光了衣服躺在一起，但是背靠着背。 这三个梦似乎有些深意，秀才第二天就赶紧去找算命的解梦。算命的一听，连拍大腿说：“你还是回家吧。你想想，高墙上种菜不是白费劲吗？戴斗笠打雨伞不是多此一举吗？跟表妹都脱光了躺在一张床上了，却背靠背，不是没戏吗？” 秀才一听，心灰意冷，回店收拾包袱准备回家。店老板非常奇怪，问：“不是明天才考试吗，今天你怎么就回乡了？”秀才如此这般说了一番，店老板乐了：“哟，我也会解梦的。我倒觉得，你这次一定要留下来。你想想，墙上种菜不是高种吗？戴斗笠打伞不是说明你这次有备无患吗？跟你表妹脱光了背靠靠躺在床上，不是说明你翻身的时候就要到了吗？” 秀才一听，更有道理，于是精神振奋地参加考试，居然中了个探花。 生存之道4：积极的人，象太阳，照到哪里哪里亮，消极的人，象月亮，初一十五不一样。想法决定我们的生活，有什么样的想法，就有什么样的未来。
5.有一天动物园管理员们发现袋鼠从笼子里跑出来了，于是开会讨论，一致认为是笼子的高度过低。所以它们决定将笼子的高度由原来的十公尺加高到二十公尺。结果第二天他们发现袋鼠还是跑到外面来，所以他们又决定再将高度加高到三十公尺。 没想到隔天居然又看到袋鼠全跑到外面，于是管理员们大为紧张，决定一不做二不休，将笼子的高度加高到一百公尺。 一天长颈鹿和几只袋鼠们在闲聊，“你们看，这些人会不会再继续加高你们的笼子？”长颈鹿问。 “很难说。”袋鼠说∶“如果他们再继续忘记关门的话！” 生存之道5：其实很多人都是这样,只知道有问题,却不能抓住问题的核心和根基。
6.在某个小村落，下了一场非常大的雨，洪水开始淹没全村，一位神父在教堂里祈祷，眼看洪水已经淹到他跪着的膝盖了。一个救生员驾着舢板来到教堂，跟神父说：“神父，赶快上来吧！不然洪水会把你淹死的！”神父说：“不！我深信上帝会来救我的，你先去救别人好了。” 过了不久，洪水已经淹过神父的胸口了，神父只好勉强站在祭坛上。这时，又有一个警察开着快艇过来，跟神父说：“神父，快上来，不然你真的会被淹死的！”神父说：“不，我要守住我的教堂，我相信上帝一定会来救我的。你还是先去救别人好了。” 又过了一会，洪水已经把整个教堂淹没了，神父只好紧紧抓住教堂顶端的十字架。一架直升飞机缓缓的飞过来，飞行员丢下了绳梯之后大叫：“神父，快上来，这是最后的机会了，我们可不愿意见到你被洪水淹死！！”神父还是意志坚定的说：“不，我要守住我的教堂！上帝一定会来救我的。你还是先去救别人好了。上帝会与我共在的！！” 洪水滚滚而来，固执的神父终于被淹死了……神父上了天堂，见到上帝后很生气的质问：“主啊，我终生奉献自己，战战兢兢的侍奉您，为什么你不肯救我！”上帝说：“我怎么不肯救你？第一次，我派了舢板来救你，你不要，我以为你担心舢板危险；第二次，我又派一只快艇去，你还是不要；第二次，我以国宾的礼仪待你，再派一架直升飞机来救你，结果你还是不愿意接受。所以，我以为你急着想要回到我的身边来，可以好好陪我。” 生存之道6：其实，生命中太多的障碍，皆是由于过度的固执与愚昧的无知所造成。在别人伸出援手之际，别忘了，惟有我们自己也愿意伸出手来，人家才能帮得上忙的！！
7.某人在屋檐下躲雨，看见观音正撑伞走过。这人说：“观音菩萨，普度一下众生吧，带我一段如何？” 观音说：“我在雨里，你在檐下，而檐下无雨，你不需要我度。”这人立刻跳出檐下，站在雨中：“现在我也在雨中了，该度我了吧？”观音说：“你在雨中，我也在雨中，我不被淋，因为有伞；你被雨淋，因为无伞。所以不是我度自己，而是伞度我。你要想度，不必找我，请自找伞去！”说完便走了。 第二天，这人遇到了难事，便去寺庙里求观音。走进庙里，才发现观音的像前也有一个人在拜，那个人长得和观音一模一样，丝毫不差。 这人问：“你是观音吗？” 那人答道：“我正是观音。” 这人又问：“那你为何还拜自己？” 观音笑道：“我也遇到了难事，但我知道，求人不如求己。” 生存之道7：成功者自救。
8.某大公司准备以高薪雇用一名小车司机，经过层层筛选和考试之后，只剩下三名技术最优良的竞争者。主考者问他们：“悬崖边有块金子，你们开着车去拿，觉得能距离悬崖多近而又不至于掉落呢？” “二公尺。”第一位说。 “半公尺。”第二位很有把握地说。 “我会尽量远离悬崖，愈远愈好。”第三位说。 结果这家公司录取了第三位。 生存之道8：不要和诱惑较劲，而应离得越远越好。
9.陈阿土是台湾的农民，从来没有出过远门。攒了半辈子的钱，终于参加一个旅游团出了国。国外的一切都是非常新鲜的，关键是，陈阿土参加的是豪华团，一个人住一个标准间。这让他新奇不已。早晨，服务生来敲门送早餐时大声说道："Good morning！"陈阿土愣住了。这是什么意思呢？在自己的家乡，一般陌生人见面都会问："您贵姓？"于是陈阿土大声叫道："我叫陈阿土！"如是这般，连着三天，都是那个服务生来敲门，每天都大声说："Good morning sir！" 而陈阿土亦大声回道："我叫陈阿土！"但他非常的生气。这个服务生也太笨了，天天问自己叫什么，告诉他又记不住，很烦的。终于他忍不住去问导游，"Good moring sir！"是什么意思，导游告诉了他，天啊！！真是丢脸死了。陈阿土反复练习"Good morning sir！"这个词，以便能体面地应对服务生。又一天的早晨， 服务生照常来敲门，门一开陈阿土就大声叫道："Good moring sir！"与此同时，服务生叫道："我是陈阿土！" 生存之道9：人与人交往，常常是意志力与意志力的较量。不是你影响他，就是他影响你，而我们要想成功，一定要培养自己的影响力，只有影响力大的人才可以成为最强者。
10.一个人去买鹦鹉，看到一只鹦鹉前标：此鹦鹉会两门语言，售价二百元。另一只鹦鹉前则标道：此鹦鹉会四门语言，售价四百元。该买哪只呢？两只都毛色光鲜，非常灵活可爱。这人转啊转，拿不定主意。结果突然发现一只老掉了牙的鹦鹉，毛色暗淡散乱，标价八百元。这人赶紧将老板叫来：这只鹦鹉是不是会说八门语言？店主说：不。这人奇怪了：那为什么又老又丑，又没有能力，会值这个数呢？店主回答： 因为另外两只鹦鹉叫这只鹦鹉老板。
生存之道10：真正的领导人，不一定自己能力有多强，只要懂信任，懂放权，懂珍惜，就能团结比自己更强的力量，从而提升自己的身价。相反许多能力非常强的人却因为过于完美主义，事必躬亲，认为什么人都不如自己，最后只能做最好的公关人员、销售代表，成不了优秀的领导人
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49b10244f81b1b9918d436d3d1239c1/" rel="bookmark">
			数独算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * File: 数独游戏算法，输入一个初始状态，如下图，0表示空
103000509
002109400
000704000
300502006
060000050
700803004
000401000
009205800
804000107
结果如图
143628579
572139468
986754231
391542786
468917352
725863914
237481695
619275843
854396127
*
* Author: chenjiang
*
* Created on 2010年5月5日, 下午12:29
*/
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
using namespace std;
int mapmap[10][10]; //保存整个
bool row[10][10], col[10][10], small_squre[10][10];
struct node {//定义一个点
int x, y;
};
stack&lt;node&gt;S;//定义一个栈，用于保存空格子
int get_squre(int x, int y) {//获得（x，y）所在小方格的序号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49b10244f81b1b9918d436d3d1239c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee437ba7c6b68ff71af7c59c2d8ff5cb/" rel="bookmark">
			Android程序怎样禁止横竖屏切换？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Android中要让一个程序的界面始终保持一个方向，不随手机方向转动而变化的办法： 只要在AndroidManifest.xml里面配置一下就可以了。 在AndroidManifest.xml的activity(需要禁止转向的activity)配置中加入android:screenOrientation=”landscape”属性即可(landscape是横向，portrait是纵向)。例如： &lt;application android:persistent="true"
android:label="@string/home_title"
android:icon="@drawable/ic_launcher_home"&gt;
&lt;activity android:name="Home"
android:theme="@style/Theme"
android:launchMode="singleInstance"
android:stateNotNeeded="true"
android:screenOrientation="portrait"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category android:name="android.intent.category.HOME"/&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt; 另外，android中每次屏幕方向切换时都会重启Activity，所以应该在Activity销毁前保存当前活动的状态，在Activity再次Create的时候载入配置，那样，进行中的游戏就不会自动重启了！ 要避免在转屏时重启activity，可以通过在androidmanifest.xml文件中重新定义方向(给每个activity加上android:configChanges=”keyboardHidden|orientation”属性)，并根据Activity的重写onConfigurationChanged(Configuration newConfig)方法来控制，这样在转屏时就不会重启activity了，而是会去调用onConfigurationChanged(Configuration newConfig)这个钩子方法。例如： if(newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE){
//横向 setContentView(R.layout.file_list_landscape); }else{
//竖向 setContentView(R.layout.file_list); } 在模拟器中，要使程序转屏可以使用快捷键F12或Ctrl+F11来切换。当然在用命令行启动模拟器时可以直接使用参数emulator.exe -skin HVGA-L来启动横屏的程序。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4757ecff21b5535919d565d97376740/" rel="bookmark">
			【Spring】手动添加schema文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于spring的schema文件位于网络上，如果机器不能连接到网络，那么在编写配置信息时候就出现提示信息，既然绝发那个发有两种
1：让机器上网，eclipse会自动从网络上下载schema文件并缓存在硬盘上。
2：手动添加schema文件 windows-&gt;preferences-&gt;myeclipse-&gt;files and editors-&gt;xml-&gt;xmlcatalog
点"add",在出现的窗口中的Key Type中选择URI，在location中选"File system".
然后再spring解压目录的dist/resources目录总选择spring-beans-2.5.xsd.回到设置窗口的时候
不要着急关闭窗口、应该窗口中的Key Type改为Schema location，Key改为http://www.springframeword.org/schema/beans/spring-beans-2.5.xsd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d14a0532319ce68f2ba95759705a08c/" rel="bookmark">
			win7下如何使用telnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我看了网上有人的解决方案又结合我的电脑总结的，希望对大家有所帮助。
Telnet是系统管理员常用的远程登录和管理工具，在Windows 2000/XP/2003/Vista系统中它作为标准的系统组件集成到系统中供用户使用。不过默认情况下Telnet服务是被禁止，通常情况下我们只需 运行services.msc打开服务管理，找到Telnet服务项设置其启动类型为“手动”或者“自动”，然后启动该服务即可使用了。不过在 Windows 7中，你按照上述方法是不能找到并启用Telnet服务的。那如何找回Windows 7的Telnet功能呢? 1、隐藏原因 其实，在服务管理器中找不到Telnet并不是Windows 7抛弃了Telnet，而是默认状态下Windows 7并没有安装Telnet服务。这也是微软第一次从个人系统中将Telnet剔出了系统默认组件之外，这和Windows Server 2008类似。我想微软这么做，应该是出于安全性考虑，毕竟Telnet的数据是以明文传输的，攻击 者和容易通过嗅探获取敏感信息。基于安全性考虑，建议大家还是使用安全性更高的、加密的SSH远程管理方式。
2、安装Telnet 不过，我们也没有必要因噎废食，作为个人用户Telnet还是非常方便的。在Windows 7下安装Telnet和Windows Server 2008略有不同，大家可以通过下面的操作方法实现。依次点击“开始”→“控制面板”→“程序”，“在程序和功能”找到并点击“打开或关闭Windows 功能”进入Windows 功能设置对话框。找到并勾选“Telnet客户端”和“Telnet服务器”，最后“确定”稍等片刻即可完成安装。除此之外，我们也可通过该向导安装 “TFTP客户端”、“Internet 信息服务”等。
安装完成后，在开始--运行中输入“cmd”，在ＤＯＳ下转到Ｃ盘的ｗｉｎｄｏｗ／Ｓｙｓｔｅｍ３２下，然后输入＂ｔｅｌｎｅｔ＂就　打开了ｔｅｌｎｅｔ的页面。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/510/">«</a>
	<span class="pagination__item pagination__item--current">511/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/512/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>