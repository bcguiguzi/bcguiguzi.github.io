<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db16bd8a44f1ab127562542c7e2c4eb8/" rel="bookmark">
			背包型动态规划——零钱兑换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例：
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 10的四次方 1、题目分析 这个题目就是典型的背包问题6的应用。
2、代码实现 import numpy as np class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [10000 for i in range(amount+1)] dp[0]=0 for i in range(amount+1): for j in coins: if i&gt;=j and dp[i-j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db16bd8a44f1ab127562542c7e2c4eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ade03073f6a3fa893f7dc712c0e6c9/" rel="bookmark">
			如何设置excel表格表头冻结_excel表格冻结表头怎么设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具2113材料电脑 excel软件1、首先在5261电脑上打开excel表格，如下图所示。2、打开之4102后的页面1653如下。3、如下图所示，接着用鼠标选择需要冻结的部分。4、接着在顶部工具栏中找到“视图”选项，如下图所示，点击打开。5、接着找到“冻结窗格”选项打开。6、最后在弹出的界面选择“冻结拆分窗格”即可。打开相应的Excl文件选择表头位置执行 视图—冻结 即可：如下图选中要冻结的行或列，执行——窗口——冻结窗格冻结行列选中某个单元格，冻结窗格——冻结的是本单元格上边西线及左边线的交叉区域本回答被提问者和网友采纳选中B2(或其它单元格)，视图(或窗口)，冻结窗格。03板
设置excel表头不动的方法：
打印标题，这个功能可以打印制定行在打印的每页上面显示。 1、打开EXCEL表格。 2、点选页面布局，打印标题。 3、在工作表选项栏中，顶端标题行，点眩 4、选择冻结行。 5、确定。 6、在打印预览中可以看到，冻结行出现在每页上面显示。
1.打开电脑里的Excel软件，打开表格文件。
EXCEL里的表头固定方法：针对设定表头的行与列，可以选择拆分窗格，拆分完成后，选择冻结空格，则表头即可固定下来； 单元格里添加页码，可以采用分页后的页面设置来进行添加。
2.点击上方的视图选项。
1、首先打开Excel表格，输入一些数据。 2、打开菜单栏中的“视图”-“冻结窗口”，单击确定“冻结首行”，就可以实现表头内容始终可见即可。 3、还有一种方法：设置特定行列始终可见，如要将例子中的第一列“姓名”和第一、二行的文本内容设置为始终可见
3.点击冻结窗格图标。
步骤如下： 点击excel菜单中的视图 2.点击工具栏 3.点击自定义 4.点击命令 5.点窗口和帮助 6.找到冻结拆分窗口，再用鼠标把小图标拖到常用工具栏上即可。 Microsoft Excel是Microsoft为使用Windows和Apple Macintosh操作系统的电脑编写的一款
4.选择冻结首行即可设置表头不动。
mac版excel固定表头，可使用“冻结窗格”实现。 方法步骤如下： 1、打开需要操作的EXCEL表格，需那种需要固定的表头下一行首单元格，然后点击视图标签。 2、在视图选项卡中点击“冻结窗格”。 3、选择“冻结拆分单元格”即可。 4、返回EXCEL表格，通过
总结
1.用Excel打开表格文件。
材料/工具：Excel2010 1、首先在我们电脑上新建一个excel并打开。 2、进入表格窗口后，我们点击导航中的“视图”。 3、接着，我们在视图下的选项中找到“冻结窗格”。 4、找到冻结窗格功能后，我们点击它。 5、点击冻结窗格，我们发现表头就冻结了。
2.点击视图。
以WPS 2019版本为例： 关于WPS冻结窗格，您可使用WPS参考下述步骤完成操作： 1、打开表格； 2、点击【视图-冻结窗格】； 例如需要冻结首行和首列，鼠标先定位在B2单元格，再执行上面的步骤，点击【冻结至第一行A列】
3.点击冻结窗格。
用窗口冻结功能。 假设要锁定前三行，那么移动光标到A4——窗口——冻结窗口——确定！
4.选择冻结首行。
并不是冻结的窗格就可以每页都可以打樱可以在页面设置中设置打印标题的。 进入页面设置，如下图： 每页都打印表头的话，可以 点击上图红色框内”顶端标题行“右边的按钮，选择需要每页打印的区域然后确定，此后打印每页纸张都会有该标题行
1、首先在电脑桌面2113，打开自己需要锁5261定表头的excel表格。(如下图)41022、打开excel表格之后，需要1653锁定的是第一行的主标题和第二行的分类标题，那么要锁定之前，需要先把把鼠标点击第三行并停留在第三行，然后再点击左上角的“视图”菜单。(如下图)3、在视图菜单列表下的工具栏中，找到“冻结窗格”工具，并点击下面的下拉图标。(如下图)4、点击下拉图标之后，再弹出来的功能设置中，选择“冻结拆分窗格”设置。(如下图)5、这样以第一行的主标题和第二行的分类标题作为表头已经成功锁定，再往下拉的时候，就算拉到excel表格最下面的行数列，也可以看到上面的表头。(如下图)扩展资料：e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1306736e7d86a116de2d0089b5696b40/" rel="bookmark">
			unet详解_Unity3D 网络组件UNet详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，研究了一下UNet，经过项目实践，大致整理了下遇到的问题。
UNet常见概念简介
Spawn:简单来说，把服务器上的GameObject，根据上面的NetworkIdentity组件找到对应监视连接，在监视连接里生成相应的GameObject.
Command:客户端调用，服务器执行，这样客户端调用的参数必需要UNet可以序列化，这样服务器在执行时才能把参数反序列化。需要注意，在客户端需要有权限的NetworkIdentity组件才能调用Command命令。
ClientRpc:服务端调用，客户端执行，同上，服务端的参数序列化到客户端执行，一般来说，服务端会找到上面的NetworkIdentity组件，确定那些客户端在监视这个NetworkIdentity，Rpc命令会发送给所有的监视客户端。
Server/ServerCallback:只在服务器端运行，Callback是Unity内部函数。
Client/ClientCallback:同上，只在客户端运行，Callback是Unity内部函数。
SyncVar:服务器的值能自动同步到客户端，保持客户端的值与服务器一样。客户端值改变并不会影响服务器的值。
上面的大部分特性都会转化成相应的MsgType,其中服务器调用，客户端执行对应MsgType有如Spawn,ClientRpc,SyncVar对应的MsgType分别为ObjectSpawn,Rpc,UpdateVars,这些都是NetworkServer调用，客户端得到相应消息，执行相应方法。客户端调用，服务器执行的MsgType有如Command,客户端发送，服务器检测到相应消息后执行。
UNet主要类介绍
NetworkIdentity组件介绍：网络物体最基本的组件，客户端与服务器确认是否是一个物体(netID)，也用来表示各个状态，如是否是服务器，是否是客户端，是否有权限，是否是本地玩家等。一个简单例子，A是Host(又是服务器，又是客户端)，B是一个Client,A与B分别有一个玩家PlayA与PlayB.在机器A上，playA与playB isServer为true,isClent为true,其中playA有权限，是本地玩家，B没权限，也不是本地玩家。在机器B上，playA与playB isServer为false,isClent为true,其中playB有权限，是本地玩家，A没权限，也不是本地玩家。A与B上的PlayA的netID相同，A与B上的PlayB的netID也相同，其中netID用来表示他们是同一网络物体在不同的机器上。
在下面用网络物体来表示带有NetworkIdentity组件的GameObject.
NetworkConnection:定义一个客户端与服务器的连接，包含当前客户端监视那些服务器上的网络物体，以及封装发送和接收到服务器的消息。
NetworkClient：主要持有当前NetworkConnection对象与所有NetworkClient列表的静态对象，处理一些默认客户端的消息。
网络物体上的监视者就是一个或多个NetworkConnection，用来表示一个或多个客户端对这个网络物体保持监视，那么当这个网络物体在服务器上更新后，会自动更新对所有监视者的对应的网络物体。
NetworkScene:简单来说，1Server与Client需要维护一个网络物体列表，Server可以遍历所有网络物体发送消息等，并且维持Server与Client上的网络物体保持同步，并且客户端记录需要注册的prefab列表.其中NetworkServer与ClientScene都包含一个NetworkScene对象，引用网络物体列表。
NetworkServer:主要持有一个NetworkScene并且做一些只有在服务器上才能对网络服务做的事，如spawn, destory等。以及维护所有客户端连接。
ClientScene:主要持有一个静态NetworkScene对象，用于注册网络物体的prefab列表,以及客户端场景上已经有的网络物体列表，处理SyncVar,Rpc,SyncEvent特性等，还有以及ObjectSpawn,objectDestroy,objectHide消息等。
UNet用时想到的问题
问题1 spawn发生了什么，客户端为什么要注册相应的prefab.
当服务器spawn一个网络物体时,网络物体调用OnStartServer,分配netID.并注册到相应服务器上的的NetworkScene的网络物体列表中，更新如isServer为true等信息。
查找所有客户端连接，查看每个客户端连接是否需要监视这个网络物体，如果为true,那么给这个客户端上一个消息MsgType.ObjectSpawn或是MsgType.ObjectSpawnScene(这种一般是服务场景变换后自动调用)，并传递上面的netID.
当客户端接受到ObjectSpawn消息，会在注册的prefab里查找，查找到后Instantiate个网络物体，当接受到ObjectSpawnScene时，会在场景里查找这个网络物体，然后都注册到ClientScene里的NetworkScene的网络物体列表中，并更新netID与服务器的一样。更新如isClent为true等信息。
我们手动spawn一个物体时，调用的是ObjectSpawn消息，客户端接到这个消息处理得到一个assetID，我们要根据prefabe实例一个新对象，只有客户端注册了相应的prefabe信息才能根据对应的assetID找到prefabe.
问题2 NetworkIdentity的netID表示什么，那个时候分配。
当服务器与客户端的netID相同，表示他们是同一物体，相应标示如SyncVar，服务器变了，对应客户端上相同的netID的网络物体，更新成服务器上的数据，Rpc,Commandg 一般也是相同的netID之间调用。
分配一般发生在服务器spawn一个网络物体时，网络物体调用OnStartServer时发生产生netID。
在客户端接受相应的ObjectSpawn消息，会把服务器上的对应物体的netID传递过来，产生新的网络物体并赋这个netID。
问题3 NetworkIdentity的sceneID是什么，在场景里已经有NetworkIdentity组件的物体是如何在客户端与服务器联系的。
当网络物体并不是spawn产生在服务器与客户端，而是在服务器与客户端场景本身就有时，我们也需要在服务器与客户端之间建立联系，这种物体会有一个sceneID来标示，这种模型一般是服务器场景变换完成后，NetworkServer调用spawnObjects会把这种网络物体与所有客户端同步，当spawn完成后过后，相应客户端会产生一个和服务端相同的netID。
问题4 服务器场景切换后，各个NetworkIdentity组件的物体如何与客户端联系。
如下顺序因为有异步操作，并不能确定，如下顺序只是一般可能的顺序。
服务器异步调用场景，发送给所有客户端开始切换场景。MsgType.Scene
客户端接受MsgType.Scene,开始切换场景。
服务器场景完成，会查找所有的网络物体，然后spawn这些网络物体，这样各个网络物体通过相同的netID联系起来。
客户端场景完成后,再次调用OnClientConnect,一般来说，不执行任何操作。
问题5 客户端为什么要网络物体的权限，它有了权限能做什么。
一般来说，当spawn某个服务器上的网络物体后，服务器有它的权限，客户端并不能更改这个网络物体，或是说更改这个网络物体相应的属性后并不能同步到服务器和别的客户端上，只是本机上能看到改变。
那么我如果需要能改变这个网络物体上的状态，并能同步到所有别的客户端上，我们需要拥有这个网络物体的权限，因为这样才能在本机上发送Command命令，才能告诉服务器我改变了状态，服务器也才能告诉所有客户端这个网络物体改变了状态。
其中本地player在创建时，当前客户端对本地player有权限。客户端上有权限的网络物体上的SyncVar改变后，也并不会能同步到服务器，服务器根本没有注册UpdateVars消息，这种还是需要客户端自己调用Command命令。
问题6 UNet常见的封装状态同步处理有那些，其中NetworkTransform与NetworkAnimator分别怎样通信，如果是客户端权限的网络物体又是怎么通信的了。
UNet常见的封装状态同步状态方法有二种。
一是通过ClientRpc与Command是封装发送消息。客户端与服务端一方调用，然后序列化相应的参数，然后到服务器与客户端反序列化参数执行。
二是网络内置的序列化与反序列化，序列化服务器的状态，然后客户端反序列化相应的值，如SyncVar通过相应的OnSerialize,OnDeserialize.这种只能同步服务器到客户端。
这二种本质都是客户端与服务器互相发送MsgType消息，对应的服务器与客户端注册相应消息处理。NetworkAnimator 服务器上的动画改变，会发消息通知所有客户端相应状态改变了，如Rpc。NetworkTransform 服务器通过OnSerialize序列化相应的值，然后客户端反序列化相应的值。
如果客户端有对应NetworkTransform与NetworkAnimator网络物体的权限。NetworkAnimator 相应客户端提交状态到服务器上，然后分发到所有客户端，相当于调用了Command，并在Command里调用了Rpc方法。NetworkTransform 相应客户端发送消息到服务器上，服务器更新相应位置，方向。然后通过反序列化到所有客户端。
所以如果客户端有授权，那么NetworkAnimator与NetworkTransform在服务器或是有授权的客户端的状态改变都能更新到所有客户端，注意这二个组件对localPlayerAuthority的处理不同，在NetworkTransform中，localPlayerAuthority为false时,客户端不能更新到所有客户端，在NetworkAnimator中，localPlayerAuthority为true时，服务器不能更新到客户端上。
其中注意SyncVar特性，就算客户端授权，客户端改变后，也不会同步到别的机器上。
所以如果我们自己设计类似的网络组件，需要考虑客户端授权的相应处理，就是差不多添加一个Command命令。
问题7 客户端授权与本地player授权有什么区别。
一般物体的权限都在服务器上，如果要对网络物体授权给客户端，一般通过SpawnWithClientAuthority实现，这样在相应客户端上的hasAuthority为true,其中相应的playerControllerID为-1。
而本地player授权localPlayerAuthority，在相应的网络物体上的Local Player Authority勾选上，在对这个网络物体的所有监视客户端上,本地player授权都是true，这种一般用于玩家，或是玩家控制位移的物体，playerControllerID大于等于0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1306736e7d86a116de2d0089b5696b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f5e955438eed276c0896402a89aaaa/" rel="bookmark">
			戒烟的行测定期总结(综合部分名家&#43;刷题后的自我写题总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期总结：
提纲类题目，
1.要写题目“关于xxx(事件)的xxx(体裁，例如考察报告)”
2.要写背景、具体措施
资料分析： 1.一定要把题目全看完。认真看题看材料，能够解决很大一部分麻烦。
2.除法截的时候，记住一步只截分母，多步除法只截取分子
3.加法使用从高到低加
4.记熟公式：平均数增长率，线段法，
数字推理： 1.整数之间有分数，考虑乘法
把两两作差、两两作差再做差、两两作和、三三作和的结果写出来，观察自身、和原数列的规律
资料分析耗时太长了
判断推理： 判断推理更多的是和阅读有关。要读材料，找到论点和论据的中心字词。先找和题干论述的中心字词一样的，再择优选择。同等情况下，削弱论据相比削弱论点、拆桥要后考虑，部分、有的要最后考虑
补充前提论断缺陷论点与论据的内容不一致补充论点与论据之间的联系论点与论据**之间的联系不合理**论点与论据的内容一致加强论点，说明其可行 科学常识： 生态系统 生产者：无机物-&gt;有机物
消费者：有机物-&gt;有机物，有机物-&gt;无机物
分解者：有机物-&gt;无机物
食物链 1.箭头指向捕食者者
2.生产者为第一级，每层捕食者加一级
地转偏向力 1.北半球向右，南半球向左
2.河水往偏转方向偏移，则
偏转方向河水侵蚀河岸，反方向河水沉积河岸
电梯 mg-N=ma，以向下为正方向
电梯的a向上时，N&gt;mg
电梯的a向下时，N&lt;mg
言语理解： 总纲要： 言语理解与表达主要测查考生运用语言文字进行交流和思考、迅速而准确地理解文字材料内涵的能力。它包括：
1.正确理解阅读材料中指定词语、语句的准确含义；
2.根据材料查找主要信息及重要细节；
3.概括归纳阅读材料的中心思想或主旨；
4.判断新组成的语句与阅读材料原意是否一致；
5.根据上下文合理推断阅读材料中的隐含信息；
6.判断作者的态度、意图、倾向、目的；
7.准确、得体地遣词用字等。
行文结构很重要！
而对于选标题的题目
关键是：概括全文
因为A导致-B
不能推出：
要想B必须-A
与文意不相符：
类型原文选项1在A情况下，B成立B成立2A→B-A→-B3A与B类似A与B相同4因为A导致-B要想B必须-A5因为A导致-B-B主要是因为A（比4错得更离谱） 逻辑填空： 0.最重要的：以下步骤都是为了排除答案。如果无法排除，那就往下找能够排除答案的填空处。
1.考虑材料的行文结构
2.考虑材料的整体含义
3.找到材料的重要细节(尤其是填空题)
4.如果以上步骤都无法直接得到填空处的唯一答案，就从这些方向考虑：
——填词题：遣词用字(排除字词含义上的陷阱/明显错误)
——填句题：务实的、上升到大局的思维
文章主旨： 1.每句话大意理解清楚，知道每句话之间的结构
2.找原文所有关键词，选那个只同时包含所有关键词的选项，不多不少。
填句子： 1.文末的句子都是总结前文，没有要求的情况下，就只总结前文的内容。
2.如果二选一，那就比较两者，选更能衔接原文的，抛弃思维跳了一步的。
细节判断： 每个选项的错误类型要对应，而且只会对应这几项：完全没提到？以偏概全？
一定要对应，不然肯定会错
数量关系： 亲身测试，遇到二元一次方程的问题，不要傻傻的设x和y，要从题目给出的比例设未知数，例如经过处理后4:3，就从此处入手，设此时两者量为4x、3x。假如题目有分数，就尽量凑整
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68f5e955438eed276c0896402a89aaaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22db790ad58091309ebef778ca3aa4ce/" rel="bookmark">
			服务器安装2个mysql数据库_一个服务器怎么装两个mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器中安装两个mysql数据库的方法
1.首先，正常安装第一个mysql，并在命令行中停止mysql服务；
net stop mysql
2.mysql服务停止后，将mysql安装目录复制到另一个文件，如复制到E盘；
3.mysql安装目录复制好后，在文件中新建一个my.ini文件，并进行如下修改:
[client]
port=3307 #第一个数据库的默认端口是3306 这里需要另外启用一个端口
basedir="E:\mysql\mysql Server 5.5\" #第二个数据库basedir
datadir="E:\mysql\mysql Server 5.5\data\" #第二个数据库datadir
4.my.ini文件配置好后，在命令行中将mysql注册为服务；
mysqld install mysql2 --defaults-file="E:\mysql\mysql_base\ini\my.ini"
5.mysql服务注册好后，使用组合键“win+R”运行“regedit”进入注册表；
6.进入到注册表后，在注册表中依次打开以下文件；
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
7.最后，在文件中的mysql2的ImagePath值进行以下修改即可；
"E:\mysql\mysql Server 5.5\bin\mysqld" --defaults-file="E:\mysql\mysql_base\ini\my.ini" mysql2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcef145f48079aea0cc23c84c99ae77/" rel="bookmark">
			Unity 导入Vuforial 报错No ‘git‘ executable was found. Please install Git on your     system then restart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
64 位电脑设置路径
点击完成就好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94780ec574e2b13f9607c5268f7ebd64/" rel="bookmark">
			KeyboardEvent.keyCode 已被废弃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MDN官方文档说明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6360653319c26e36cc9c650a697b9dc7/" rel="bookmark">
			python程序的构成_（一）Python入门-2编程基本概念：01程序的构成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Python程序的构成
Python程序由模块组成。一个模块对应 一个python源文件，一般后缀名是：.py。
模块由语句组成。运行 Python 程序时，按照模块中语句的顺序依次执行。
语句是Python程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。
二：Python文件的创建和执行
之前使用的交互式环境，每次只能执行一条语句；为了编写多条语句实现复杂的逻辑， 可以通过创建 Python 文件，并执行该文件。
在 IDLE 环境中，可以通过 File--&gt;new 创建 Python 文件，并可以编辑该文件内容。也可以通过File--&gt;save/save as 保存文件。一般保存成扩展名为 py的文件。
需要执行编辑好的文件，可以用快捷键F5 或者点击 Run--&gt;Run module。
三：代码的组织和缩进
很多编程语言通过字符(例如：花括号{})、关键字(例如：begain/end)来划分代码块。 同时，在配合代码的缩进增加可读性。“龟叔”设计Python语言时，直接通过缩进来组织代码块。“缩进”成为了Python语法强制的规定。
缩进时，几个空格都是允许的，但是数目必须统一。我们通常采用“四个空格”表示一 个缩进。
同时，也要避免将“tab 制表符”或者tab与空格混合的缩进风格。目前，常用的编辑 器一般设置成：tab 制表符就是4 个空格。
Python官方推荐的PEP-8代码风格详细说明，可以参考： https://www.python.org/dev/peps/pep-0008/
四：使用注释#
注释是程序中会被Python解释器忽略的一段文本。程序员可以通过注释记录任意想写的内 容，通常是关于代码的说明。
五：使用 \ 行连接符
一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这时我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同 一行。
1 &gt;&gt;&gt; a = 'abcdefghijklmnopqrstuvwxyz'
2 &gt;&gt;&gt; b = 'abcdefg\
3 hijklmn\4 opqrst\5 uvwxyz'
6 &gt;&gt;&gt;a7 'abcdefghijklmnopqrstuvwxyz'
8 &gt;&gt;&gt;b9 'abcdefghijklmnopqrstuvwxyz'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3b1cd710dfe93337d52a43c8ec348a/" rel="bookmark">
			GC(垃圾回收)准确式垃圾回收算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准确式GC 准确式GC和保守式GC的不同点在于，准确式GC能准确识别指针和非指针来经行垃圾回收。创建正确的根有多种方式，但是这些都需要语言处理程序的支援。
方法一：打标签
打标签的目的在于明确的对根里所有的指针和非指针明确的区分开来。我们以最基本的第一位作为标签的方法。在32bCPU下，指针的值是4的倍数，低2位一定是0，我们利用这特性具体打标签的方法如下：
1，将非指针（如int)左移一位
2，将低1位至为1
注意：在对数值也就是非指针左移时注意不要让数值溢出，若发生溢出则换位更大的数据类型，例如Int换位Long
这里打标签这两步都是由语言处理程序处理的。根据打完这个表情GC就可以精准的识别根里指针和非指针变量。但是除了识别变量，在计算时必须将数据还原，也就是取消标签。
方法二：不把寄存器和栈当作根。上文提到，寄存器和调用栈里存在的都是不明确的根，我们这里都不把寄存器和栈当作根就可以省去很多麻烦。这种方法似乎有点投机取巧，解决不了问题就避免问题的感觉，但是事实上很有用，许多语言也利用这种方法例如：Rubiniius。
准确式GC可以精准识别指针，GC之后堆只剩活动的对象。此外，复制等移动算法都依赖准确式GC。缺点：是语言处理程序的支援，对应保守式简单的优点这里就是麻烦，并且例如打标签和取消标签这就影响语言处理程序整体速度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e44bf5218dc080adb6e47282ece689e/" rel="bookmark">
			贝叶斯原理在硬币实验中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贝叶斯原理在硬币实验中的应用 相关资料：《Pattern Recognition and Machine Learning》 by Christopher M. Bishop
以“贝叶斯原理在硬币实验中的应用”为背景，对其进行代码实现，以助于对相关理论部分的理解
原理 掷硬币问题的过拟合 掷硬币问题描述 非常经典的掷硬币情景：将一枚硬币连续掷N次，每次的结果都会是正面朝上或反面朝上，将这些结果全部记录下来。现在要做的，是仅根据这些结果，来计算硬币正面朝上的概率
最大似然估计法的缺陷 撇开生活经验不谈，假定硬币正面朝上的概率应该为 μ \mu μ，且记硬币朝上时，观测值 x = 1 x=1 x=1，反之，观测值 x = 0 x=0 x=0。则每次观测值的分布可以记录为如下形式（Bernoulli分布）：
B e r n ( x ∣ μ ) = μ x ( 1 − μ ) 1 − x Bern(x|\mu)=\mu^x(1-\mu)^{1-x} Bern(x∣μ)=μx(1−μ)1−x
∣ | ∣符号右边的 μ \mu μ表示这是一个控制分布的参数
现在，假定对此硬币进行了N次观测（掷了N次），得到数据集（观测值的集合） D = { x 1 , … , x N } \mathcal D=\{x_1,\ \dots,\ x_N\} D={x1​, …, xN​}，则根据各次观测之间相互独立的特性，可以计算出数据集处于各种状态（即对于各种可能的N个观测值的组合）的概率：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e44bf5218dc080adb6e47282ece689e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b755e9c867228ebd39af16ed3e40fc/" rel="bookmark">
			GC（垃圾回收）保守式GC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾回收算法可以分为两类，保守式GC和准确式GC。保守式GC指的是：不能识别指针和非指针的GC，而保守就保守在：将非指针指向的对象视为活动对象并且不废弃处理。准确式是指:能够识别保守式GC和准确式GC。
我们先来了解一个概念：不明确的根。实际上寄存器，调用栈，全局空间变量。这些都是不明确的根。因为寄存器，调用栈，全局空间变量这三者都能包含指针和非指针，所以GC扫描到他们的时候就不知道里面存的到底是指针还是非指针。比如说调用栈，调用栈里面就有调用帧，调用帧包含局部变量和参数，局部变量就有例如int,double的非指针也有void*这样的指针。
在不明确根这种条件下，保守式GC就不能准确识别指针和非指针。不能准确是说明还是有一套识别的方式的。保守式GC识别不明确根时执行3个项目，当3个项目同时成立时则说明是指针。这3个项目是：
1，是不是被正确对齐？
2，是不是指向堆？
3，是不是指着对象的开头？
下面我们展开谈谈这三个项目：
1，是不是被正确对齐？这是利用CPU的对齐来检查的。若32b的CPU，指针的值的位数==地址的位数==4的倍数，若64b的CPU，指针的值的位数==地址的位数==8的倍数.这个项目，我们必须在语言处理程序中使用指针符合对齐的规则。（对齐这个概念和计算机组成原理内存对齐存放是一样的）
2，是不是指向堆？一般来说，对象分配的地址空间一定是在堆空间，而若指针指向的不是堆就可以判断一定不是指针。
3，调查不明确的根是不是指着对象的开头，具体我们可以使用BIBOP法，把对象按照固定大小对齐，核对检查对象的值是不是对象固定大小的倍数。
这三个项目可以判断出大多数非指针，但总是有例外的误判。例如：非指针和堆里的对象的地址是一样的情况，这时保守式GC就无法识别这个是非指针，而把这个非指针视为指针并且指向的对象一律判为活动对象。再例如:存在不明确的数据结构时
struct { long c; void* ptr }ambiguous_data 这里面既存在指针ptr也存在非指针c。若c是非指针和堆里的对象的地址是一样的情况，那么GC也无法识别C是个非指针。当对象是这样的数据结构时，GC不仅会错误识别不明确的根，也会错误识别域里的值。
总结，保守式GC的优点：只有简单，简单就意味着不容易出BUG。
缺点：识别指针和非指针需要以上3步，成本有点高。错误识别指针会压迫堆导致没有清除垃圾的效果。不能使用移动式的垃圾回收算法，例如复制算法，因为复制对象的时候会重写指针来指向新的空间，而当错误将非指针识别成指针时重写的就是非指针。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8fba713e0fdee60ef8f5c352a89e341/" rel="bookmark">
			onIndex超简单搭建oneDriver私人网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onIndex超简单搭建oneDriver私人网盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e16d50a770c8809c187e18072f324a2/" rel="bookmark">
			1&#43;X Web前端证书中级备考攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1+X Web前端证书中级备考攻略 更新一下在毕业前拿到了高级证书 前言 我参加的是2020年11月的考试，那次考的相对比较简单，取得了不错的成绩，这个证书毕竟刚出没多久，网上资料也不太多，本文就整理了一下考试前我收集到的学习资料和关于这个证书的一些考纲分析。
章末附上我整理的相关资料，包含以下内容 ，考试的内容不止这些，还有jQuery、BootStrap等，相对比较简单我考试的时候也没有单独去准备其他的内容，如果有需要的话可以留言，我会试着整理一下(bilibili大学都有)
1 考试内容的分析 以下数据来源于网络
核心课程名称技能点份额占比课时分配权重JavaScript929.03%651CSS825.81%582PHP619.35%433HTML412.90%294BootStrap26.45%14.55MySQL26.45%14.55总计31100%224 Web前端的课程存在较大的关联性，进行课程组合，以供开课参考。
组合课程技能点份额占比课时分配组合权重HTML+CSS1238.71%871JavaScript929.03%652PHP+MySQL825.81%57.53BootStrap26.45%14.54总计31100%224 1.HTML 技能要求：
能熟练使用HTML文本标签、头部标记、页面创建超链接、创建表格表单功能搭建静态网页能熟练使用HTML文本标签、图像、头部标记、页面创建超链接、创建表格表单及iframe框架等功能美化网页能熟练使用HTML5新增语义化元素、页面增强元素与属性及多媒体元素等功能美化页面、开发移动端页面 知识要求：
+掌握并熟练应用HTML文本标签、头部标记、页面创建超链接、创建表格表单功能
+掌握HTML在网页中嵌入多媒体、使用框架结构、网页中使用表格创建表单的使用方法
+掌握、理解HTML5新增全局属性、结构化与页面增强、表单标签、多媒体元素的使用方法
2.CSS 技能要求：
能熟练使用CSS设计、美化网页样式能熟练使用Hack原理实现CSS中的样式效果能熟练使用CSS3的选择器、盒模型、过渡、动画等属性美化网页使用em/rem/vw/vh等单位开发移动端网页，达到美化网页的效果能熟练使用CSS3的选择器、背景、盒模型、渐变、多列布局等属性开发动态网页 知识要求：
+掌握CSS的区块、网页布局属性的使用方法
+掌握CSS的选择器、单位、字体样式、文本样式、颜色、背景的使用方法
+掌握CSS3选择器在页面中插入各种盒子模型、背景样式使用方法
+掌握CSS3特性、动画效果、多列布局以及弹性布局的使用方法
+掌握CSS3选择器、边框特性、颜色、字体、盒阴影、背景特性、盒模型、渐变功能的使用方法
3.JavaScript 技能要求：
能熟练使用JavaScript开发交互效果页面能熟练使用运算等基础语言和内置函数实现数据交互能熟练使用JavaScript对象和DOM编程实现交互效果页面能熟练使用Ajax中的XML、JSON数据格式与网站后端进行数据交互能熟练使用jQuery选择器、jQuery中的DOM操作、滚动、图表、布局、文字处理及UI等插件、jQuery事件和动画等开发交互效果页面 知识要求：
+掌握JavaScript基础语言、函数、面向对象功能的使用方法
+掌握Ajax技术，实现异步刷新，异步获取数据的使用方法
+掌握jQuery中选择、插件、事件和动画功能的使用方法
4.MySQL 技能要求：
能使用MySQL基本操作进行数据管理 知识要求：
掌握以下内容
MySQL中创建表、设置约束、设置自增型字段、表结构的复制、修改表、修改字段、修改约束条件、修改表名、删除表、数据的插入/修改/查询/存储、触发器、事务、视图的使用方法
5.PHP 技能要求：
掌握以下内容
能熟练使用PHP的编码技术操作Mysql数据库，进行动态网站开发。
2.能使用Session的操作、Cookie的操作开发动态网站
3.能根据HTTP协议方法定义操作，能使用API进行数据筛选、支持大型二进制资源的部分响应与后端进行交互
4.能熟练使用Laravel的路由、控制器、Blade模板、前端组件构建动态网站 知识要求：
掌握PHP的基础操作、数组函数、面向对象、基本语法、数据类型、数据输出、编码规范、常量、变量、PHP运算符、数据类型转换、条件判断语句、循环控制语句、跳转语句和终止语句、一维数组、二维数组、遍历与输出数组、函数、PHP操作MySQL数据库、管理MySQL数据库中数据的使用方法
掌握基本的API设计方法
掌握Laravel框架构建动态网站的使用方法
6.Bootstrap 技能要求：
能使用Bootstrap栅格系统、基本样式、组件、Less和Sass、插件、Bootstrap定制及优化、Bootstrap内核解码开发响应式页面 知识要求：
+掌握Bootstrap布局、组件、基本样式、插件、组件的使用方法
附：考核方式
Web 前端开发职业技能初、中、高三个级别的考核方式为闭卷考试，采用上机考试形式。考试包括理论考试和实操考试两部分。
理论考试（100分）共50道试题：
一.单选题30道
二.多选题15道
三.判断题5道实操考试（100分）3至5道实践性试题
案例分析、软件代码编码、网页效果呈现等形式。 理论考试与实操考试合格标准均为60分
两部分考试成绩均合格的学员可以获得相应级别的职业技能等级证书。
2 个人的经验 选择题是有难度的，实操题就比较简单，考试时间是很充裕的基本上都可以提前交卷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e16d50a770c8809c187e18072f324a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b888a2403ac6644e7fc5aa406e2520/" rel="bookmark">
			python中自定义标识符_python标识符和关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标识符
1.1 什么是标识符
开发人员在程序中自定义的一些符号和名称，标识符是自己定义的,如变量名 、函数名等
1.2 标识符的规则
标识符由字母、下划线和数字组成，且数字不能开头
正确 from12
错误 12form
补充
python中的标识符是区分大小写的
1.3 命名规则
· 见名知意
起有意义的名字，一眼便知其意思，可以提高代码的可读性，比如：老师 就可以用 teacher
· 驼峰命名法
小驼峰式命名法(lower camel case)： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog
大驼峰式命名法(upper camel case)： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName
下划线_: 还有一种命名法是用下划线“_”来连接所有的单词，比如send_buf
2. 关键字
2.1 什么是关键字
python一些具有特殊功能的标识符，这就是所谓的关键字
关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标识符
2.2 python中的关键字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741bae22624c69e82adc15005ce4abc9/" rel="bookmark">
			查看服务器上Docker镜像 latest具体版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以我本地装的redis为例，此处看到TAG为latest
思想：通过docker image inspect的命令查看镜像信息，通过grep过滤想要的版本数据
命令格式
docker image inspect (docker image名称):latest|grep -i version 结果如下，可以看到redis的版本为5.0.7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01afb09d110d7c501863527be68d2e26/" rel="bookmark">
			flutter 当前日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DateTime dateTime= DateTime.now(); dateTime.day,今天多少号
dateTime.month 当前月份
dateTime.year
dateTime.hour
dateTime.minute
dateTime.second
dateTime.millisecond
dateTime.millisecondsSinceEpoch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a56b31bc47acf218058cb19d05e511/" rel="bookmark">
			UOS网络浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.uos网络使用networkmanager服务来管理网络
2./etc/network/interfaces是修改network服务，所以修改这个配置文件默认不生效
3.uos修改网络配置可以使用nmcli和图形化两种办法
4.uos网络配置文件路径是/etc/NetworkManager/system-connections/
5.使/etc/network/interfaces生效可以禁用networkmanager,然后启用network服务，这时图形化网络会显示断开链接
6.uos默认重启网络指令是service network-manager restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41c138f3e545157d3769243ba852894/" rel="bookmark">
			在VMware里装Kali Linux选graphical install后黑屏解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用的是VMware 16，装Kali Linux 2020，选graphical install后黑屏。
其实不管选哪个都黑屏……
一开始按照网上的netsh winsock reset，虚拟打印机，还有什么忘记了，都没用。
一顿试，后来发现要这么改：
把VMware的兼容性改成Workstation 8.x后正常。
说说怎么发现的：
一开始一直用iso装，只要选graphical install就黑屏，然后没办法，去下载VMware版的（配置好的.7z版），可以运行。
看一下区别，发现Workstation版本不一样，那试一下Workstation 8.x版，就可以了……（为什么不兼容呢……）
其它的兼容性没试过可以试试，Kali Linux 2020.4在VMware 16下兼容性调成Workstation 8.x亲测可用。
另外，如果用VMware版的（.7z版），默认用户名：kali，密码：kali，网上好多不对(￣_￣|||)。
踩了一晚上坑，希望能帮到遇到同样问题的人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b7ce5bf4d1767fd3d76eef249bf3be/" rel="bookmark">
			python获取数组最后一位_每日一课 | 通过 Python 获取列表的最后一个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python中，我们可以使用索引-1来获取列表的最后一个元素。
#!/usr/bin/python
nums = [1, 2, 3, 4, 5]print(nums[-1])print(nums[-2])print(nums[-3])print(nums[-4])print(nums[-5])
print(nums[0])print(nums[1])print(nums[2])print(nums[3])print(nums[4])
输出量
5
4
3
2
1
1
2
3
4
5
又一个例子
#!/usr/bin/python
# getting list of nums from the user
nums = list(map(int, input("Enter space separated numbers").split())) # accessing the last element using -1 indexprint(nums[-1])
输出量
Enter space separated numbers 1 2 3 4 55
参考文献: Pyhton doc数据结构
翻译自: https://mkyong.com/python/python-get-the-last-element-of-a-list/ 推荐阅读--
Python 只用一行代码，可以实现哪些事儿？
当pandas撞上了sql，于是一个强大的pandasql库产生了！牛了！Python最容易入的10个坑！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff67d21e5e6896baee3067fc3b8ab948/" rel="bookmark">
			mysql raiserror_RAISERROR在SQL Server数据库中的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		raiserror 是由单词 raise error 组成
raise 增加; 提高; 提升
raiserror 的作用： raiserror 是用于抛出一个错误。[ 以下资料来源于sql server 2005的帮助 ]
其语法如下：
复制代码RAISERROR ( { msg_id | msg_str | @local_variable }
{ ,severity ,state }
[ ,argument [ ,...n ] ]
)
[ WITH option [ ,...n ] ]
简要说明一下：
第一个参数：{ msg_id | msg_str | @local_variable }
msg_id：表示可以是一个sys.messages表中定义的消息代号；
使用 sp_addmessage 存储在 sys.messages 目录视图中的用户定义错误消息号。
用户定义错误消息的错误号应当大于 50000。
msg_str：表示也可以是一个用户定义消息，该错误消息最长可以有 2047 个字符；
(如果是常量，请使用N'xxxx'，因为是nvarchar的)
当指定 msg_str 时，RAISERROR 将引发一个错误号为 5000 的错误消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff67d21e5e6896baee3067fc3b8ab948/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/339/">«</a>
	<span class="pagination__item pagination__item--current">340/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/341/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>