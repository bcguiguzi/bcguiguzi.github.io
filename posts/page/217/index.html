<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b934c152a990125e896fbdb0eac0d7f/" rel="bookmark">
			通过U盘安装Centos Stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 Index of /Linux/CentOS/8-stream/isos/x86_64
我下载的是这个小的,也可以通过阿里镜像下载 centos-8-stream-isos-x86_64安装包下载_开源镜像站-阿里云
二、制作镜像与安装 下载成功后，对于 Centos Stream 系统千万不要用UltraISO软碟通，写入硬盘镜像。一定要使用Win32 Disk Imager 写入镜像，写入成功后，U盘引导直接就安装了，不用在引导菜单的时候 按 table 键修改 vmlinuz initrd=initrd.img linux dd quiet 查看设置列表 vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4 quiet # 使用U盘安装
这两步，非常的简单方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd78242bc605cfa0386e052f1507e612/" rel="bookmark">
			软件工程复习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复习题 选择题填空题判断题简答题应用题 选择题 1.以下哪一类不属于IEEE对需求的分类：环境需求
2.以下哪个不是功能需求通常意义上体现的三个层次：质量需求
3.下列关于职业道德与个人自身发展的关系中，说法不正确的是：职业道德是个人能力提高的基础
4.下列关于职业道德修养的形成，说法不正确的是：与个人素质无关
5.软件危机最初出现于以下哪个阶段：程序系统阶段
6.以下哪个选项不是软件的组成部分：开发模型
7.以下哪个选项不属于软件的开发过程：可行性研究
8.螺旋模型的每个螺旋周期可分为4个步骤，以下哪个不属于这四个步骤：运行维护
9.流程图中的三种基本结构不包括下列那一项：判断结构
10.以下关于代码注释说法错误的是哪一个：注释会影响程序执行速度
11.项目的四项约束不包括以下哪一项：技术
12.以下哪一项不属于SWOT分析：Strategy
13.下列哪项不是目前常用的人机交互方式：接口技术
14.不是人机界面构思方法的选项是（）：子系统机能分析法
15.不是将持久类映射到关系数据库表的基本方式的选项是：将类和数据库直接转换
16.下列哪项不是常用界面类型的优点（）:超级链接型
17.下列哪项不是常见的网页布局格式（）:嵌入型
18.下列哪项不是人机界面的设计原则（）:通用性
19.成功的用户界面开发支柱不是是建立在（）基础上的:优秀设计人员
20.只有单重继承的类层次结构是( )层次结构：树型
21.类的（）意味着一个操作在不同的类中可以有不同的实现方法：多态
22.中间件可以分为数据库访问中间件，远程过程调用中间件、面向消息中间件、实务中间件，分布式对象中间件等多种类型、windows平台的ODBC和JAVA平台的JDBC属于（）。：数据库访问中间件
23.软件测试的目的是()：尽可能多的发现软件系统中的错误
24.使用白盒测试方法时，确定测试数据应根据（）和指定的覆盖标准：程序的内部逻辑
25.存储过程不具备（）功能：调用时编译即可
26.存储过程的缺点是（）：可维护性差
27.将永久性设计类映射到数据模型不具有（）：随时执行映射
28.软件危机主要体现在：软件产品的质量难以控制
29.为了解决软件危机，人们提出了用（）的原理来设计软件。：工程学
**重点
30.关于软件架构，下面说法错误的是（）：
架构设计的目标只是为了提高系统的重用性
31.关于架构和应用框架，下面说法错误的是（）：
先大局后局部，就出现了应用框架；先通用后专用，就出现了架构
32.下面哪个是设计模式中抽象工厂模式的描述？（）：
将抽象部分与实现部分分离，使它们都可以独立地变化
33.下面说法错误的是（ ）：用例图是从程序员角度来描述系统的功能
34.一个安保系统的角色有：经理，安全主管和保安。角色与角色之间有泛化关系，请问他们之间谁是父角色？下面说法正确的是（）：
保安作为安全主管的父角色，安全主管作为经理的父角色。
35.用例模型采用（ ）的思想，是需求分析模型的表现形式之一，主要用于表现系统的（ ）：面向对象 功能需求
36.在UML用例图中，参与者表示（ ）：人、硬件或其他系统可以扮演的角色 重点重点
37.运行时架构分析，指的是系统（ ）需求分析，主要是指确定系统中的进程，确定进程之间的通信机制，分配进程之间的协调资源，确定进程的生命周期以及在进程之间分布模型元素。：并行性
38.在用例之间，会有三种不同的关系，下列哪个不是它们之间的可能的关系( )：关联(connect)
39.（ ）描述了一组交互对象间的动态协作关系，它表示完成某项行为的对象和这些对象之间传递消息的时间顺序。：时序图
40.在下面选项中哪两种图形可以互相转换：协作图和时序图
41.下面选项中 ( )不是序列图中的基本元素。：泳道
42.边界类是用于描述外部参与者与系统之间的交互。一个系统可能有多种边界类：包括（ ）。：用户界面类，系统接口类和设备接口类
43.一个对象发出消息后，必须等待消息接受者的回应，然后才能继续往下执行。这个对象发出的消息是（ ）。：同步消息
44.下面说法错误的是（ ）：协作图可以描述对象的创建和撤销的情况
45.在实践中，以下哪项不属于应用程序需要控制的永久性问题？（ ）：查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd78242bc605cfa0386e052f1507e612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f265d8c12f13f40b28f8536ab1cd81d4/" rel="bookmark">
			进入一个新公司，首先该怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先把开发工具（vscode、git、乌龟git、nodejs）装好（如果之前电脑没装好的话），先问领导git用https还是ssh链接方式，如果是https的话就等领导给你开好账号，然后使用账号密码把代码 git clone 把代码克隆下来就行，如果是ssh的话就执行 ssh-keygen -t rsa 命令生成公私秘钥，并且将公钥给领导，领导将你的公钥添加完成后就可以使用 git clone 命令直接克隆代码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee34e2dc899345738ab63f3ce2f07152/" rel="bookmark">
			QStackedWidget 控件使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt系列文章目录 文章目录 Qt系列文章目录前言一、QStackedWidget例子源码下载 前言 我们在使用Qt设计复杂界面的时候：一般都会设计出一个主界面，主界面包含几个主要窗口，可以拖拽和相互停靠。其中窗口2是主要的三维渲染展示窗口，窗口1和窗口3里面也有很多的内部布局。我们首先想到的是使用QDockWidget来设置窗口1、窗口2、窗口3,其中这3个窗口里面也会显示各种widget窗口。我们一般都会想到使用QTableView/QTableWidget等控件来显示当前哪个窗口显示，哪些窗口隐藏。这时候QStackedWidget控件使用起来更方便。
visual studio也是这样的风格
一、QStackedWidget 1.QStackedWidget 官方文档
QStackedWidget 控件相当于一个容器，提供一个空间来存放一系列的控件，并且每次只能有一个控件是可见的，即被设置为当前的控件。QStackedWidget可用于创建类似于QTabWidget提供的用户界面。它是一个构建在QStackedLayout类之上的方便布局小部件。与QStackedLayout一样，QStacked Widget可以构建并填充许多子Widget（“页面”）：
2.常用接口
QWidget *firstPageWidget = new QWidget; QWidget *secondPageWidget = new QWidget; QWidget *thirdPageWidget = new QWidget; QStackedWidget *stackedWidget = new QStackedWidget; stackedWidget-&gt;addWidget(firstPageWidget); stackedWidget-&gt;addWidget(secondPageWidget); stackedWidget-&gt;addWidget(thirdPageWidget); QVBoxLayout *layout = new QVBoxLayout; layout-&gt;addWidget(stackedWidget); setLayout(layout); QStackedWidget没有为用户提供切换页面的内在方法。这通常通过QComboBox或QListWidget来完成，QListWidget存储QStackedWidget页面的标题。例如
QComboBox *pageComboBox = new QComboBox; pageComboBox-&gt;addItem(tr("Page 1")); pageComboBox-&gt;addItem(tr("Page 2")); pageComboBox-&gt;addItem(tr("Page 3")); connect(pageComboBox, QOverload&lt;int&gt;::of(&amp;QComboBox::activated), stackedWidget, &amp;QStackedWidget::setCurrentIndex); 例子 1.头文件
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QPushButton&gt; #include &lt;QStackedWidget&gt; #include &lt;QLabel&gt; #include &lt;QGridLayout&gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); QWidget *pwind; //上方三个按钮 QPushButton *btnT1; QPushButton *btnT2; QPushButton *btnT3; //设置三个QStackedWidget 页面，每个页面包含一个按钮（当然这里面的按钮只是看看）； QStackedWidget *m_pStackedWidget; QPushButton *btnT4; QPushButton *btnT5; QPushButton *btnT6; public slots: void switchPage(int nIndex);//切换设置 void sss1();//链接按钮的槽 void sss2(); void sss3(); private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee34e2dc899345738ab63f3ce2f07152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8495e62f11e36b58e07a38825e2639/" rel="bookmark">
			codeforces.com/contest/1649--补题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		codeforces.com/contest/1649–补题 C. Weird Sum 题意：给定一个矩阵，矩阵每个点都有一个颜色，求每两个相同颜色的点之间的曼哈顿举例，曼哈顿距离=|x1-x2|+|y1-y2|
样例：
//input 2 3 1 2 3 3 2 1 //output 7 算法1：暴力 时间复杂度O( n 2 n^2 n2) – TLE
算法2：思维 O( 2 n 2n 2n)
​ 所有对的曼哈顿距离，肯定是横坐标的曼哈顿距离+纵坐标的曼哈顿距离，所以我们可以分开来看，可以先看横坐标x，可以计算出当前点的当前点前面有j个点，所以当前点和他们的横坐标的曼哈顿距离就为 j ∗ x i − ( x 0 + x 1 + . . . + x j − 1 ) j*x_i-(x_0+x_1+...+x_{j-1}) j∗xi​−(x0​+x1​+...+xj−1​)，这样只需要两次循环即可，时间复杂度由 n 2 n^2 n2降到2n
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; vector&lt;pair&lt;int,int&gt;&gt;ve[100005];//按颜色存储点，将矩阵上的点存到对应颜色的容器中 bool cmp1(pair&lt;int,int&gt;a1,pair&lt;int,int&gt;a2){//按照横坐标从小到大排序 return a1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8495e62f11e36b58e07a38825e2639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3837d8cbd73468e1d56795b8701b92ee/" rel="bookmark">
			Android 深色模式使用失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android提供了一种简单的深色模式来实现简单的换肤功能
最近使用时发现应用的颜色没有与系统的深色模式一起切换，原因在于我们是否使用了android:configChanges="uiMode"
假如我们没有在清单文件加上该配置
那么我们可以在attrs.xml定义
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;attr name="testColor" format="color" /&gt; &lt;/resources&gt; 然后在values下定义themes
&lt;resources xmlns:tools="http://schemas.android.com/tools"&gt; &lt;!-- Base application theme. --&gt; &lt;style name="Theme.TestApp" parent="Theme.MaterialComponents.DayNight"&gt; &lt;!-- Primary brand color. --&gt; &lt;item name="colorPrimary"&gt;@color/purple_500&lt;/item&gt; &lt;item name="colorPrimaryVariant"&gt;@color/purple_700&lt;/item&gt; &lt;item name="colorOnPrimary"&gt;@color/white&lt;/item&gt; &lt;!-- Secondary brand color. --&gt; &lt;item name="colorSecondary"&gt;@color/teal_200&lt;/item&gt; &lt;item name="colorSecondaryVariant"&gt;@color/teal_700&lt;/item&gt; &lt;item name="colorOnSecondary"&gt;@color/black&lt;/item&gt; &lt;!-- Status bar color. --&gt; &lt;item name="android:statusBarColor"&gt;?attr/colorPrimaryVariant&lt;/item&gt; &lt;item name="testColor"&gt;#0f0&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt; &lt;/resources&gt; 然后在values-night下定义themes
&lt;resources xmlns:tools="http://schemas.android.com/tools"&gt; &lt;style name="Theme.TestApp" parent="Theme.MaterialComponents.DayNight"&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3837d8cbd73468e1d56795b8701b92ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85adf070cbed3e173a8e8b5746105d4/" rel="bookmark">
			android studio 4.1* PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderExc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
安装下面博客导入key （仓库服务 这个网址）
关于gradle Cause: unable to find valid certification path to requested target错误解决方法 仓库服务 这个网址内容加入加入 google 、jcenter
导入网站证书
keytool.exe -importcert -file D:\Users\Desktop\cert.cer -keystore "%JAVA_HOME%/jre/lib/security/cacerts" -trustcacerts
buildscript { repositories { //google() //jcenter() google { url 'https://maven.aliyun.com/repository/google' } jcenter { url 'https://maven.aliyun.com/repository/jcenter' } } dependencies { classpath "com.android.tools.build:gradle:4.1.0" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85adf070cbed3e173a8e8b5746105d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35cfbe93691fe1d9918f46b20a3dee8/" rel="bookmark">
			HTML 定义和基本结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义
定义：HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm，一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。
HTML 的基本结构如下
&lt;!-- 第一行&lt;!DOCTYPE html&gt;是文档声明, 用来指定页面所使用的html的版本, 这里声明的是一个html5的文档。 --&gt; &lt;!DOCTYPE html&gt; &lt;!-- &lt;html&gt;...&lt;/html&gt;标签是开发人员在告诉浏览器，整个网页是从&lt;html&gt;这里开始的，到&lt;html&gt;结束,也就是html文档的开始和结束标签。 --&gt; &lt;html lang="en"&gt; &lt;!-- &lt;head&gt;...&lt;/head&gt;标签用于定义文档的头部,是负责对网页进行设置标题、编码格式以及引入css和js文件的。 --&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;!-- &lt;body&gt;...&lt;/body&gt;标签是编写网页上显示的内容。 --&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt; &lt;/html&gt; HTML 编写规范
1、标签小写
2、属性用双引号括起来
3、所有的标签闭合
&lt;div&gt;&lt;/div&gt; &lt;br /&gt;
4、图片加alt属性；alt=“”加上属性，可以读图片信息
用 HTML 标签 双标签（闭合标签）
定义： 双标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，比如: div标签
单标签 （空标签）
定义： 单标签是一个标签组成，没有标签内容， 比如: img标签
常用标签列举：
&lt;!-- html标题 --&gt;
&lt;h1&gt;&lt;/h1&gt;、&lt;h2&gt;&lt;/h2&gt;、&lt;h3&gt;&lt;/h3&gt;、
&lt;h4&gt;&lt;/h4&gt;、&lt;h5&gt;&lt;/h5&gt;、&lt;h6&gt;&lt;/h6&gt;
&lt;!-- 标签定义一个文本段落 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- 换行 --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e35cfbe93691fe1d9918f46b20a3dee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307f9bc88e6e0941ec06d42222aa3191/" rel="bookmark">
			【uni-app开发-使用期间的感受记录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2022/09/05
当项目发生莫名奇妙的报错，但是没有影响运行什么的，放一晚上，下一次【Have a pleasant surprise】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a837cdcf30b6093965acb207a55962/" rel="bookmark">
			C#/.NET/.NET Core优秀项目框架推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 优质资源分享 🚀 学习路线指引（点击解锁）知识定位人群定位🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。💛Python量化交易实战💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统思维导航： 前言Blog.CoreAspNetCoreWeiXinMPSDKABP FrameworkUtilsiteserver/cmsOSharpVue.NetCoreOpenAuth.Netant-design-blazorNetModularpaymentFurionYuebonNetCorefulussoAwesome DotNet PackagesSuperSocketDotNettynopCommerceCAP金庸群侠传3D重制版IdentityServer4.AdminSurgingOcelotSqlSugarFreeSqlcsredisFreeRedisOrleansFreeIMFightLandlordFastGithubAgileConfigYiShaAdminMediatRAutofacMapsterAutoMapperAspNetCoreRateLimitPollybc-csharp 文章正文：
🚀回到顶部## 前言：
为.NET开源者提供的一个推荐自己优秀框架的地址，大家可以把自己的一些优秀的框架，或者项目链接地址存到在这里，提供给广大.NET开发者们学习（注意：排名不分先后，都是十分优秀的开源框架和项目💖）。
Github项目仓库收集地址：https://github.com/YSGStudyHards/DotNetGuide/issues/5
填写格式如下：
项目or框架名称+访问链接地址+项目描述：
📦NPOI-ExportWordAndExcel-ImportExcelData
一个简单，易懂的通用ASP.NET Core NPOI导出复杂Word、复杂美观Excel和Excel数据导入详细示例开源项目（开箱即用，无需其他繁琐配置）。
🏡C#/.NET Core/.NET项目宝库(收集了大量优秀的C#、.NET、.NET Core项目)
该库主要是为我们.NET开发者提供一个寻找优秀C#/.NET Core/.NET项目的入口，通过了解和对比更多的项目来选择最适合我们自己学习、工作开发的一套项目。优秀的项目是不应该被埋没的，欢迎大家一起加入这个组织共同完善、发展.NET社区！【注意：这些都是非常优秀的作者所写的项目，排名不分先后，欢迎前往原址Star】
🚀回到顶部## Blog.Core
项目地址：https://github.com/anjoy8/Blog.Core
Blog.Core一个开箱即用的企业级前后端分离【 .NET Core6.0 Api + Vue 2.x + RBAC】权限框架。官方文档地址：apk.neters.club/.doc
🚀回到顶部## AspNetCore
项目地址：https://github.com/dotnet/aspnetcore
ASP.NETCore是一个跨平台的.NET框架，用于在Windows、Mac或Linux上构建基于云的现代web应用程序。
🚀回到顶部## WeiXinMPSDK
项目地址：https://github.com/JeffreySu/WeiXinMPSDK
微信公众平台SDK Senparc.Weixin for C#，支持.NET Framework及.NET Core。已支持微信公众号、小程序、小游戏、企业号、企业微信、开放平台、微信支付、JSSDK、微信周边等全平台。 WeChat SDK for C#.
🚀回到顶部## ABP Framework
项目地址：https://github.com/abpframework/abp
ABP是一个开源应用程序框架,专注于基于ASP.NET Core的Web应用程序开发,但也支持开发其他类型的应用程序.官方文档地址：documentation
🚀回到顶部## Util
项目地址：https://github.com/dotnetcore/Util
Util是一个.net core平台下的应用框架，旨在提升小型团队的开发输出能力，由常用公共操作类(工具类)、分层架构基类、Ui组件，第三方组件封装，第三方业务接口封装，配套代码生成模板，权限等组成。
🚀回到顶部## siteserver/cms
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a837cdcf30b6093965acb207a55962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965bb11e2f88acb2c27b5f1fe26a34a3/" rel="bookmark">
			windows 安装anaconda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 链接：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
找到最新的点击下载即可
注：如果系统本身已经安装了python版本，安装过程中除了勾选使用者‘all_users’，其余的都可以不勾选
2、配置环境变量 如：我的安装目录为：D:\anaconda=
D:\anaconda # 系统已有平python环境可以忽略此安装 D:\anaconda\Scripts # 必须、conda执行命令 3、指定默认环境变量 conda config --add envs_dirs D:\CONDA_VIRTUALENV 注： 如果不指定，anaconda创建的虚拟环境默认为安装目录下的envs目录下：D:\anaconda\envs
4、anaconda镜像源相关配置 4.1在命令行输入 conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls true conda config --set ssl_verify true 4.2找到用户目录下的.condarc文件 将以下内容粘贴至.condarc并保存，重新代开命令行
ssl_verify: true show_channel_urls: true channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 5、创建anacond虚拟环境 conda create --name 虚拟环境名称 python=python版本 6、查看anaconda所有的虚拟环境 conda env list 7、进入anaconda虚拟环境 conda activate 虚拟环境名称 注： 第一次进入虚拟环境可能会提示没有初始化环境，这时候根据提示运行：conda init即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965bb11e2f88acb2c27b5f1fe26a34a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048bdde87af966bbaa4f73c291156dad/" rel="bookmark">
			用低代码如何搭建一套进销存管理系统（采购、销售、库存一体化管理）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		库房进货、提货、备货混乱，想纸笔记录，会发现工作量太大；改用Excel，会发现数据难同步，数据丢失风险大。
这里提供一个进销存管理模板，针对上述问题，可以用此模板来轻松解决。
模板直达&gt;&gt; 进销存管理 一、什么是“进销存”？ 进销存，是指企业管理过程中 采购（进）→入库（存）→销售（销） 的动态管理过程。
进：指询价、采购到入库与付款的过程。销：指报价、销售到出库与收款的过程。存：指出入库之外，包括领料、退货、盘点等影响库存数量的动作。 二、进销存有哪些功能？ 在简道云进销存中，通过对商品采购、采购退货、商品销售、销售退货、库存盘点、库存计算，这六大环节的精准把控，帮助企业实时掌握商品库存情况，有效防止“负库存”情况出现。同时可以对进销情况进行财务结算分析，针对经营状况及时做出调整措施。
一张图了解模板的功能结构：
三、进销存是如何搭建的？ 按照上图中的模板功能结构，分别对系统设置、核心业务、统计分析三大部分进行介绍。
1.系统设置
系统设置中共有四张表单，分别用来添加「仓库」、「商品」、「供应商」和「客户」信息。可以手动录入数据，也可以导出表样，在excel中整理好数据后批量导入。
这些表单中的数据都将作为基础信息来使用，在填写其他业务表单时，可以直接通过数据联动、关联数据、关联查询等功能，直接调用这些数据。不仅可以提高填报效率，还可以有效避免填写错误的情况。
2.核心业务
核心业务包含采购、退货、销售、退货、盘点，也是日常使用频率最高的部分。
这五张表单结构类似，重点使用功能：关联其他表单数据、关联数据、关联查询。
2.1 商品采购
「供应商」和「仓库」使用了下拉框字段，通过关联其他表单数据，分别关联「供应商管理」表单中的供应商名称，和「仓库管理」表单中的仓库名称，作为下拉框选项使用。
「单品总价」和「采购单总价」则是通过公式自动计算得到。
「商品详情」采用了子表单字段，一次性采购了多少种商品，就可以添加多少条子表单记录。
通过关联数据，关联显示「商品管理」表单中的商品基本信息：名称、单位、编号、系统采购价，选择记录后即可自动填充数据。 划重点：这里将编号字段作为关联数据的主键字段，代表一整条记录的值，可参与数据联动和公式计算等。
通过关联查询，在选择仓库和商品后，自动显示该仓库中该编号商品的库存数量，便于采购人实时查看库存情况。 划重点：关联查询必须添加关联条件，通过关联条件，只显示出符合限定条件的数据。
关联条件如下：
2.2 采购退货
同样，在填写退货表单时，通过关联数据，根据供应商、仓库、采购时间，关联选择对应的「商品采购表单」中的采购详情记录。
选择需要退货的商品，显示在退货详情子表单中，填写实际退货价和退货数量，完成退货。
2.3 商品销售
「商品销售」表单记录了每位客户的商品购买情况。其中，商品详情中各字段的设置可参考「商品采购」表单中的商品详情子表单。
2.4 销售退货
「采购退货」表单的结构类似，在「销售退货」表单中，根据客户、仓库、销售时间，关联「商品销售」表单中对应的销售详情记录。
选择客户需要退货的商品，显示在退货详情子表单中，填写实际退货价和数量，完成退货。
2.5 库存盘点
通过人工在仓库中对商品实际数量进行一一盘点，避免出现误差和损耗，将结果录入「库存盘点」表单中，及时调整至精确库存量。
2.6 库存计算
作为整个进销存应用的灵魂，聚合表承担了两项最重要的职责——实时统计库存、防止负库存出库。
实时统计库存：
新建聚合表（入口：进入应用管理→应用设置），将「商品采购」、「采购退货」、「商品销售」、「销售退货」、「库存盘点」这四张表单，通过仓库和商品编号字段关联起来，统计各个仓库中商品的库存数量。
利用聚合表的统计结果，在填写以上这几张表单时，通过关联查询自动显示对应商品在聚合表中的库存统计数量。
即：
库存数量=商品采购数量-采购退货数量-商品销售数量+销售退货数量+库存盘点盈亏数量
防止负库存出库
在聚合表中添加校验公式，实现“防止负库存出库”的功能。
如：填写销售表单并提交，聚合表便会对库存进行实时统计，如果提交后使得库存结果小于0，那么就会触发校验提示，无法提交成功。
3.统计分析
3.1 进销分析
进销分析中共包含三张报表，用来统计和查看商品的采购、销售、进销对比情况。
在「采购统计」中，包含一张汇总表、一张柱形图和一张折线图，如下所示。
这三张图表的数据来源均为多表关联。以「采购统计」这张汇总表为例，介绍制作方法。
将「商品采购」表单和「采购退货」表单通过时间、供应商、商品编号三个字段关联起来，并添加到汇总表的行列表头中。指标中添加公式字段，统计各月从各个供应商处采购的实际商品数量（公式：采购数量-退货数量）和实际采购总额（公式：采购总金额-退货总金额）。
3.2 财务结算分析
包含：
2张表单：「客户收款」和「供应商汇款」，用来记录向客户收款和向供应商汇款的数据。3张报表：「客户对账」、「供应商对账」、「毛利统计」。 「客户对账」用来统计各月各客户的欠款情况。
客户欠款=商品销售总价-商品销售实收金额-商品退货总价+实际退款金额-客户收款金额
「供应商对账」用来统计各月各供应商的欠款情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048bdde87af966bbaa4f73c291156dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9b3a27ee930630dd02dfed76231afe/" rel="bookmark">
			深拷贝、浅拷贝及其实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、浅拷贝二、深拷贝三、判断深、浅拷贝1.concat()方法2.slice()方法3.Array.from()方法4.扩展运算符 四、实现浅拷贝1.Object.assign方法2.for in方法 五、实现深拷贝1.递归实现2.JSON.stringify与JSON.parse3.loadash函数库 一、浅拷贝 浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；
例如：
const obj_1 = { age: 21 } const obj_2 = obj_1; // 对象obj_2只复制了obj_1的地址 obj_2.age = 19; console.log(obj_1.age); // 输出：19 内存角度：对象obj_1会在栈中分配一个内存地址，该内存地址对应的值又会创建一个新的内存地址，该新的内存地址又指向堆这样一个数据结构，并在堆中创建对应的属性值age：21。而上述案例中创建obj_2并赋值obj_1，实际上只复制了指针，这么做将会导致obj_2与obj_1指向同一个地址，他们两从栈到堆这两种数据类型的链路都是一样的，obj_2修改属性age的值，导致obj_1中age的值发生改变，称作只实现了浅拷贝。
二、深拷贝 不同于浅拷贝，深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；
三、判断深、浅拷贝 我们通过我们熟知的引用类型——数组，用其内置的一些方法判断是浅拷贝还是深拷贝
1.concat()方法 判断：
let list = ['我爱', '学习']; let copyList = [].concat(list); copyList.push('JavaScript'); console.log(list); // ['我爱', '学习'] console.log(copyList); // ['我爱', '学习', 'JavaScript'] 我们使用concat()方法拷贝副本，返回新构建的数组，此时我对新数组元素的添加也不会影响到原数组，然而。。。答案为：浅拷贝
2.slice()方法 判断：
let list = ['我爱', '学习']; let copyList = list.slice(); copyList.push('JavaScript'); console.log(list); // ['我爱', '学习'] console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9b3a27ee930630dd02dfed76231afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab509b0bf0c778ab976c346d2ded9ed1/" rel="bookmark">
			树莓派 Raspberry Pi Bullseye Camera V2 相机 libcamera 用法，拍照，直播视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Raspberry Pi Camera in Bullseye 树莓派新系统 Debian Bullseye 将不再支持相机的库 picamera 和 raspicam。取而代之的是 Linux 框架 V4L2 和 libcamera。
libcamera 官方说之所以更新是因为libcamera可以提升画质，更好的适配摄像头，提供了动作检测、面部识别、物体识别、HDR等框架，最重要的是可以使用 opencv 和 tensorflow。
新功能有：
libcamera-hello – 一个简单的“hello world”应用程序，它启动相机预览流并将其显示在屏幕上。libcamera-jpeg – 一个运行预览窗口然后捕获高分辨率静止图像的简单应用程序。 ###保存一张照片### libcamera-jpeg -o test.jpg ###保存一张照片并设置宽和高，延迟时间-t为3秒 3000毫秒### libcamera-jpeg -o test.jpg -t 3000 --width 1920 --height 1080 libcamera-still – 一个更复杂的静态图像捕获应用程序，它模拟了raspistill的更多功能。 ###保存一张静态图像### libcamera-still -o still.jpg ###保存为png格式 还可以是 bmp、rgb、yuv420格式### libcamera-still -e png -o still.png ###以MMDDhhmmss的日期格式为文件名保存一张jpg照片### libcamera-still --datetime libcamera-vid – 一段视频捕捉应用程序。 ###保存一段视频 时间为10秒### libcamera-vid -t 10000 -o test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab509b0bf0c778ab976c346d2ded9ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cd66987eef16435a599dbbbfd62640/" rel="bookmark">
			Linux用户管理：用户与用户组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用户与组的基本概念用户与组信息存储的文件passwd文件shadow文件group文件 用户与组的管理用户创建用户删除用户修改密码修改用户 用户组添加组删除组修改组 基本组与附加组提权其他no Shell命令 用户与组的基本概念 用户与组信息存储的文件 passwd文件 用户基本信息文件：
/etx/passwd（六个冒号分割成七列字段）
Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。
字段： 用户名 : X : UID : GID : 注释性描述 : 主目录 : 登录Shell
用户名：用户自己创建的名字，不能重名。通常长度不超过8个字符，并且由大小写字母和/或数字组成（不建议使用数字）。
X：密码占位符，具体的内容不在此处。这个字段存放的只是用户口令的加密串，不是明文
UID：通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1~499系统用户(机器使用的账号) ，作为管理账号。1000+ 为普通用户(人使用的账号)，系统内部用它来标识用户
GID：组号，将用户分为一组一组，每一个组都有自己的组号，记录的是用户所属的用户组
注释性描述：在这个字段里可增加对账号的描述
主目录：它是用户在登录到系统之后所处的目录。各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名，也就是用户的起始工作目录。例：root用户登录后在 根下的root文件夹
Shell（壳）：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。功能是命令解释器，用来定义、接收、执行命令 。当前计算机使用的壳为bash，每个用户登录后都应该有一个解释器 将bash修改为nologin 可禁用该用户，使其不能登录。
shadow文件 用户密码信息文件：/etc/shadow（八个冒号分割为九列字段）
由于/etc/passwd文件是所有用户都可读的，密码容易破解。因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
“登录名”：是与/etc/passwd文件中的登录名相一致的用户账号
“口令”：字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
星号代表账号被锁定、双感叹号表示这个密码已经过期了。
加密类型 看\ $中间字段$ 例：$1$MYG2NDG6$a1wtyr5GDM2esAPjug0YP0
$6$：表示使用SHA-521加密的、
$1$：表示是用MD5加密的、
$2$：表示使用Blowfish加密的 $5$：使用SHA-256加密的
“最后一次修改时间”：表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
“最小时间间隔”：指的是两次修改口令之间所需的最小天数。
“最大时间间隔”：指的是口令保持有效的最大天数。
“警告时间”：字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
“不活动时间”：表示的是用户没有登录活动但账号仍能保持有效的最大天数。
“失效时间”：字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。
“标志”：保留，这个字段没有功能
group文件 组信息文件：/etc/group（三个冒号四个字段）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05cd66987eef16435a599dbbbfd62640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e71f49eaad642b0bfa0ea285acffa9/" rel="bookmark">
			Google Analytics Service account 认证指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GA官方文档：https://developers.google.com/analytics/devguides/reporting/core/v4/authorization
Service account 官方文档 https://developers.google.com/identity/protocols/oauth2/service-account
概述 Oauth2 Service account 认证分为以下步骤
新建 projectEnable Google Analytics Reporting API新建 service account在 service account 中创建 json key建立 service account 与 Google Analytics 账号的关联 1.新建 project project 控制台：https://console.cloud.google.com/cloud-resource-manager
2.Enable Google Analytics Reporting API 选择刚刚创建的 project
搜索 Google Analytics Reporting API 并 enable
Enable success
3.新建 service account 控制台地址：https://console.developers.google.com/apis/credentials
点击 Credentials 菜单，发起创建 service account 输入 service account 详细信息 完成 4.在 service account 中创建 json key 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e71f49eaad642b0bfa0ea285acffa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04891152e00bb61d406f2b5f58c42821/" rel="bookmark">
			Google Gmail Oauth Client ID 认证指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：https://developers.google.com/workspace/guides/configure-oauth-consent
https://developers.google.com/workspace/guides/create-credentials
参考视频：https://www.youtube.com/watch?v=tGDn3V-mIOM
https://www.youtube.com/watch?v=IZ1ZEjuJF8U
OAuth2 client ID and client secret 新建 project project 控制台：https://console.cloud.google.com/cloud-resource-manager
Enable Gmail Api 点击 Gmail Api 并 Enable
新建 app 控制台：https://console.cloud.google.com/apis/credentials/consent
打开控制台，选择 project：
点击菜单 OAuth consent screen，新建 app
注：User type 只能选择 External，Internal 是给 Google Worksapce 用户使用的，是个收费的产品
step1：
step2：Scopes
这一步暂时不选择，直接 ’保存并继续‘
step3： add test users
step4：创建完成
step5: 发布 app，使 app 状态处于 In production 状态，防止 refresh token 失效
新建 OAuth 2.0 Client 控制台地址：https://console.developers.google.com/apis/credentials
点击 Credentials 菜单
保存并下载 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04891152e00bb61d406f2b5f58c42821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8f8b97f5a8f92e0b713186a734de79/" rel="bookmark">
			【微信小程序】自定义组件(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁写在前面：
观众老爷们好呀，这里是前端小刘不怕牛牛频道，小程序系列文章又更新了呀。
今天牛牛带来的是微信小程序的自定义组件入门知识，赶紧拿起小本本做笔记呀！
文章目录 一，创建和引用1.1 介绍1.2 创建自定义组件1.3 自定义组件引用1.4 组件结构 二，自定义组件模板和样式2.1 组件模板2.2 组件样式 一，创建和引用 1.1 介绍 自定义组件，就是开发者将页面的某个功能模块抽象化并提取出来的代码块，支持复用，减少一定的代码量。
有了自定义组件，我们就可以将页面复杂的模块分解成几个低耦合的模块。低耦合就是说模块间的关联程度低，避免了过度依赖，利于代码维护等等。当多个页面需要一样的功能模块时，我们还可以封装一个自定义组件，只需要在各页面使用该组件即可。这样代码量是不是一下子减少好多，相当的nice。
1.2 创建自定义组件 自定义组件的创建，类似于页面的创建，也是由json、wxml、wxss、js四个类型的文件组成
创建有以下两个步骤：
在项目的根目录下，创建一个components文件夹，用来存放我们的自定义组件代码
伙伴们是不是觉得跟Vue的组件定义有点像，不过注意的是，vue定义组件只需要vue一个文件即可，而小程序的自定义组件一般来说可不止。在components文件夹下创建一个自定义组件名字的空文件夹，鼠标移至新文件夹上方并右键，再次输入名字，按下回车，开发者工具就会帮你自动生成需要的四个类型的文件
一个最简单的自定义组件我们就创建完成啦。
注意：
自定义组件文件夹下需要在json文件中将component设置为true，完成自定义组件声明才可使用。
{ "component" : true } 当然，在上面使用的快捷创建自定义组件中，开发者工具已经默认帮你把这一段写好了。
1.3 自定义组件引用 我们先来讲讲它的引用，自定义组件的引用也分为全局引用和局部引用，区别和用法如下。
局部引用： 顾名思义，该组件只有在当前被引用的页面内使用 ，设置方式即在页面的json配置文件中配置usingComponents字段设置一个键值对，key为自定义组件名字，value则是组件定义的路径。需要注意的是，key的值就是该组件的标签名，如&lt;test/&gt;，示例如下所示。
{ "usingComponents" : { "test" : '/components/test/test' } } 这时候我们就可以在页面的wxml文件中使用组件啦
因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
全局引用： 就是该组件在所有小程序页面都可以被使用，设置方式差不多，我们直接在app.json全局配置文件中对usingComponents字段设置组件的键值对，与上述一致。
"usingComponents" : { "test" : '/components/test/test' } tip： 该字段与window同级
如何选择：
当一个组件在需要在多个页面中使用，我们建议使用全局引用，而对于不常用的组件，只在特定页面使用，我们就用局部引用。
1.4 组件结构 我们来简单了解一下各文件的作用
wxml和wxss文件负责组件的渲染层
组件的js文件，调用的是Component()函数，负责组件的逻辑层，需要注意的是，组件的事件处理函数需要定义到methods节点，与vue十分相似
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8f8b97f5a8f92e0b713186a734de79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ac20ca23950c1131238b53f2567610/" rel="bookmark">
			el-input 设置type为number时,隐藏后面上下箭头以及输入文字光标上移的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 隐藏el-input设置type为num的时候后面的上下箭头 input::-webkit-inner-spin-button { appearance: none !important; } input::-webkit-outer-spin-button { appearance: none !important; } input[type='number'] { appearance: textfield; } // 解决光标上移 .el-input__inner { line-height: 1px !important; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499fd39e299d670c8d6912bb4f7e8a13/" rel="bookmark">
			TCP的管理机制（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 滑动窗口快重传（高速重发）超时重传 流量控制拥塞控制(网络问题)延迟应答捎带应答TCP总结 滑动窗口 滑动窗口：发送缓冲区的一部分,和对方的接收能力有关
16位窗口大小：接收缓冲区剩余的大小
像这种一收一发，就变成串行了，效率很低
为了提高效率要允许一次发多个数据,可是允许一次发送多个数据，
那么一次 要给对方多少呢？
由接收方决定，要让对方能接收，在每次返回ack都会又窗口大小
如图
我们没有等待ack连续发了很多报文
窗口大小：无需等待服务端确认应答ack而可以发送数据的最大值,上图的窗口大小是4000字节前4个段不需要ack，直接发送收到第一个ACK之后，滑动窗口就向后移动，继续发送数据,滑动窗口滑动后的变化取决于对方的接收能力 假如说客户端硬件设备比较先进，一直在给服务端发送数据，那么就会把服务器端的内核缓冲区给挤爆，如果有阻塞机制的话，那么服务器端就阻塞在了那边，如果没有阻塞机制的话，那么服务器端的前面的数据就会被覆盖掉
所以这个时候就会有一个叫做滑动窗口的机制，服务端告诉客户端，用来存放数据的缓冲区有多大，如果满了的话，就不要再发送了
滑动窗口就是为了防止数据丢失，防止出现丢包的情况
可以在应答报文中填写上我自己的接收缓冲区的剩余空间大小
16位的滑动窗口就是滑动窗口大小不能超过2^16,32位序号就是序号的数值不能超过2 ^32，
recvfrom和sendto这些函数实际上就是一个拷贝函数：TCP 当中有接收缓冲区，和发送缓冲区，recvfrom，sendto就是把数据拷贝到TCP 缓冲区里面，以及从TCP 缓冲区里面把数据拷贝到用户层，文件描述符的生命周期是谁这进程的,一旦客户端建立好联系之后死机了，进程退出了，此时文件描述符也就退出了流量控制：填写TCP 滑动窗口的大小，告知对方自己能够接收到上限，达到两个方向上传输速度的控制，就叫做流量控制 快重传（高速重发） 如果丢包了怎么处理呢
ACK丢失：像上面这样的，即使ACK600丢失了，也不需要进行重传，因为后续的ACK700可以被发送方收到，后续的报文可以说明前面的报文已经获取了（收到多少窗口往右移动就可以了）
因为：ACK保证前面的全部收到，所以TCP是允许少量的丢包的 滑动窗口是一个环形队列，窗口不断移动的本质，就是窗口绕着那个环转圈，不可能越界，不可能出现溢出，write一直写数据会阻塞住就是环形队列被打满了 还有一种情况是发送方的数据报文丢失
那么发送方会连续收到接收方发来的相同的报文，连续收到三个，就要重新发送对应的报文，这种机制就叫做“高速重发控制”，也叫“快重传” 主机的1001-2000的报文丢了但是后面的报文收到了没有丢，确认序号依旧是1001主机A会收到连续大量的确认1001，主机A如果连续收到了3个以上同样的ack，就说明1001以后的有些报文丢失了，主机A会立即进行重传,对方也会重新更新它的窗口序列，并返回主机A补发了1001-2000，我不确定到底补发多少，先发这么多，等待对方反馈，获得新的ack，也可以无脑的把1001后面的全部发送过去，但是我们少发一点，效率高，一点一点发送，网络也不会丢失太多 超时重传 TCP 的发送方在规定时间内没有收到确认报文就要重传已发送的报文
没有收到确认报文的原因有两种
发送方的发送报文丢失确认方的确认报文丢失，如果是这样的话，接收方会收到一份相同的报文，TCP 协议通过序列号（序号没有变化）识别出了这个重复报文呢，就会进行丢弃，（TCP具有去重能力），所以也能够保证报文的按序达到， 去重也是可靠性的表现
如何保证TCP 有超时重传的机制
需要超时重传实际上也就说明了发送方数据发送出去后也不能将数据删除或者覆盖掉（因为可能对面没有收到，还要重新发送一次）需要发送方收到对方的ACK才可以把数据移除掉 超时重传的时间
在最理想情况下，找到一个最小的时间，保证“确认应答一定会在这个时间内返回”时间的长短和网络环境有关时间长，会影响重传的效率时间短，会频繁发送重复的包（这个问题不大，有去重的机制） TCP 为了保证高性能通信，动态计算了这个最大超时时间（不能让一直等待）
由于这个和带宽（用于表示一秒钟内网络传输的总容量）有关，所以这个超时时间是动态的Linux中，超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍如果重新发出一次还得不到银达，就要等待2*500ms进行重新发送，如果还是不能应答，就在等待4*500进行重传，一次类推以指数形式递增，累积到一定的重传次数，TCP 就会认为网络或者对端主机出现了异常，强制关闭连接,(把自己关闭掉) 快重传vs超时重传
ACK 的语义非常重要，因为决定了即使收到了后面的数据
快重传是为了提高效率而进行的超时重传是为了快重传无法解决的时候，才会超时重传，兜底用的 流量控制 保证了发送的速度合理
我们上文解释过了窗口的含义，还有一个概念是滑动窗口
滑动窗口其实就是发送缓冲区的一部分（实际上缓冲区是头尾相接的环形）
假设A收到了B发来的确认报文，窗口大小是20字节，确认号是31，这样就可以构造出自己滑动窗口的宽度
在没有收到B确认报文的情况下，允许A 可以把滑动窗口的数据都发出去，但是在A 收到B 的确认报文之前，发送出去的数据都要暂时保留在这个滑动窗口里面，以便重传
显然，A的发送串口的数据不能超过B 的接收能力，
发送窗口的大小由前沿和后研进行决定，窗口越大，则网络吞吐效率高，
收到新确认，后沿就可以往前移动，没有收到的话，后沿就不能移动
前沿通常向前移动，但是由于接收方接受能力变低，前言可能也不会动
第一次发送的时候怎么知道对方的接收能力？ 取决于对方什么时候给我发送的第一个报文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499fd39e299d670c8d6912bb4f7e8a13/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/218/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>