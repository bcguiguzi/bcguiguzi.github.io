<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b102e8bea15000cdaf2e214a445bcc/" rel="bookmark">
			vue 实现在线预览Excel-LuckyExcel/LuckySheet实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1. npm安装 luckyexcel npm i -D luckyexcel 2.引入luckysheet 注意：引入luckysheet，只能通过CDN或者直接引入静态资源的形式，不能npm install。
个人建议直接下载资源引入。我给你们提供一个下载资源的地址：
https://gitee.com/ichiva_admin/luckysheet-saved-in-recovery/tree/master/src/main/resources/static/module/luckysheel-2.1.13
直接放进工程的public文件夹下，在index.html中引入一下资源：
&lt;link rel="stylesheet" href="./plugins/css/pluginsCss.css"/&gt; &lt;link rel="stylesheet" href="./plugins/plugins .css"/&gt; &lt;link rel="stylesheet" href="./css/luckysheet .css"/&gt; &lt;link rel="stylesheet" href="./assets/iconfont/iconfont.css"/&gt; &lt;script src="./plugins/js/plugin.js"&gt;&lt;/script&gt; &lt;script src="./luckysheet.umd.js"&gt;&lt;/script&gt; 注意：自行整理下路径，不要错了。
准备工作完毕了。
二、预览Excel 由于后台给到的数据，就是二进制数据。因为他们导出和预览实际上用的是同一个接口。那么，我们需要将二进制数据解析为文件对象，通过luckyexcel的方法转变为json对象，然后通过luckysheet显示出来。
1.准备显示dom &lt;div id="luckysheet" style="width: 800px; height: 600px;"&gt; &lt;/div&gt; &lt;!-- 需要注意两点 1.id 要记住，下边初始化excel会使用容器id； 2.容器的宽高要设置好，否则显示不出来； --&gt; 2.请求接口 import axios from 'axios'; // 预览 请求excel二进制数据 axios.get({ url: '你的后台请求地址'， params: '参数', methods: 'post', responseType: 'blob' // 注意 这一步很关键 必须注明请求的数据类型是blob }) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b102e8bea15000cdaf2e214a445bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9fd6bcc41d09407c645cea029e0b2e3/" rel="bookmark">
			【post请求下载文件流】如何使用post请求下载文件流 blob
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个需求，做文件的下载。其实下载没什么要特别说的，之前都是用的get请求，这次不同，后台用的post请求，返回的是数据流，这种post请求下载文件的方式倒是没怎么弄过。记录一下。
接口 接口地址为：　/file/download/${id}
前端请求这里要注意（这个是重点）设置 responseType: 'blob'。
我这里用 axios 请求，代码如下：
import {axios} from '../../config'; import {BaseURL} from "@/serviceConfig"; // 附件下载 export const download = id =&gt; axios({ method: 'post', url: `${BaseURL}/file/download/${id}`, // 请求地址 responseType: 'blob' }); 然后这样请求回来的结果就是blob：
// 附件点击下载 async downloadDoc (id) { let res = await download(id); let blob = res.data; let url = window.URL.createObjectURL(blob); let eleLink = document.createElement('a'); eleLink.href = url eleLink.download = name document.body.appendChild(eleLink) eleLink.click() window.URL.revokeObjectURL(url) }, const exportExtension = (params) =&gt; { return http({ method: 'get', url: '/vsts/ui/v1/channelExtension/export', params, responseType: 'blob' }) } download(name, blob) { try { const urlObject = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9fd6bcc41d09407c645cea029e0b2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69266c67e75c946ef9b4144b0554326d/" rel="bookmark">
			travel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		懒得写是YOJ2.0的题了，都差不多
摸鱼摸的有点久，这个代码是周六晚上敲的
北方开始变冷了，几乎快跌破0°了
又是一个递归题，感觉递归做的好多
代码如下：
#include&lt;stdio.h&gt; void ra(int x, int y, int num); int travel[9][9]; int occ[9][9]; int m, n, max = -1000000; int main(void) { scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;travel[i][j]); ra(1, 1, 0); printf("%d", max); return 0; } void ra(int x, int y, int num) { occ[x][y] = 1; int n_n = num + travel[x][y]; if(x == n) if(y == m) max = (max &gt; n_n) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69266c67e75c946ef9b4144b0554326d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da8326168e411df958404c5bad6008a/" rel="bookmark">
			【Go 编程实践】从零到一：创建、测试并发布自己的 Go 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要开发自己的 Go 库 在编程语言中，包（Package）和库（Library）是代码组织和复用的重要工具。在 Go 中，包是代码的基本组织单位，每个 Go 程序都由包构成。包的作用是帮助组织代码，提供封装和代码复用的机制。
Go 包可以包含函数、类型、变量和常量等，这些元素可以被其他包引用和使用。例如，Go 的标准库提供了大量的包，如 net/http 包提供了 HTTP 客户端和服务器实现，fmt 包提供了格式化、I/O 函数等。
而库是一种特殊的包，不包含 main 函数，不能被直接运行，但可以被其他程序引用。库通常包含一些常用的功能或算法，如字符串处理、数学计算、网络通信等。
开发自己的 Go 库的优点：
复用性：当在多个项目中需要使用相同的功能时，可以将这些功能封装在一个库中，然后在需要的地方引用他。这样可以避免重复编写相同的代码，提高编程效率。可维护性：当需要修改某个功能时，只需修改对应的库，而不需要在多个地方进行修改，这样可以使代码更易于理解和维护。可测试性：为每个库编写单元测试，确保他们的功能正确。修改代码时，可以运行这些测试来检查是否引入了新的错误。 接下来，将以 Asiatz（github.com/mazeyqian/asiatz）为例，详细演示如何创建一个规范的 Go 库。
Asiatz 主要功能是进行时区转换，特别是对亚洲时区的处理，他能够将各种时区转换为 UTC 时间。
utcTime, err := asiatz.ShanghaiToUTC("08:00") if err != nil { // handle error } fmt.Println(utcTime) // Output: 00:00 第 1 步：创建目录 在本地创建一个新的目录，名为 asiatz。这个目录将包含所有的源代码、测试和文档文件。
mkdir asiatz cd asiatz 第 2 步：初始化项目 2.1 初始化 Go 模块 在 asiatz 目录下，运行 go mod init &lt;domain&gt;/&lt;username&gt;/&lt;module-name&gt; 来初始化 Go 模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da8326168e411df958404c5bad6008a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ad2fd4e409352be09343e0c53c44de/" rel="bookmark">
			HTML基础标签详解：form表单、input标签、output标签、button标签、iframe标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单（form）是用户输入信息与网页互动的一种形式。大多数情况下，用户提交的信息会发给服务器，比如网站的搜索栏就是表单。
表单由一种或多种的小部件组成，比如输入框、按钮、单选框或复选框。这些小部件称为控件（controls）。
&lt;form&gt; &lt;form&gt;标签用来定义一个表单，所有表单内容放到这个容器元素之中。
&lt;form&gt; &lt;!-- 各种表单控件--&gt; &lt;/form&gt; 上面代码就是表单的基本形式。
下面是一个比较常见的例子。
&lt;form action="https://example.com/api" method="post"&gt;//通过什么方式提交数据，但是大部分都是使用POST提交的 &lt;label for="POST-name"&gt;用户名：&lt;/label&gt; &lt;input id="POST-name" type="text" name="user"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 上面代码就是一个表单，一共包含三个控件：一个&lt;label&gt;标签，一个文本输入框，一个提交按钮。其中，文本输入框的name属性是user，表示将向服务器发送一个键名为user的键值对，键值就是这个控件的value属性，等于用户输入的值。
用户在文本输入框里面，输入用户名，比如foobar，然后点击提交按钮，浏览器就会向服务器https://example.com/api发送一个 POST 请求，发送user=foobar这样一段数据。
&lt;form&gt;有以下属性：
accept-charset：服务器接受的字符编码列表，使用空格分隔，默认与网页编码相同。action：服务器接收数据的 URL。autocomplete：如果用户没有填写某个控件，浏览器是否可以自动填写该值。它的可能取值分别为off（不自动填写）和on（自动填写）。method：提交数据的 HTTP 方法，可能的值有post（表单数据作为 HTTP 数据体发送），get（表单数据作为 URL 的查询字符串发送），dialog（表单位于&lt;dialog&gt;内部使用）。enctype：当method属性等于post时，该属性指定提交给服务器的 MIME 类型。可能的值为application/x-www-form-urlencoded（默认值），multipart/form-data（文件上传的情况），text/plain。name：表单的名称，应该在网页中是唯一的。注意，如果一个控件没有设置name属性，那么这个控件的值就不会作为键值对，向服务器发送。novalidate：布尔属性，表单提交时是否取消验证。target：在哪个窗口展示服务器返回的数据，可能的值有_self（当前窗口），_blank（新建窗口），_parent（父窗口），_top（顶层窗口），&lt;iframe&gt;标签的name属性（即表单返回结果展示在&lt;iframe&gt;窗口）。 &lt;input&gt; &lt;input&gt;标签是一个行内元素，用来接收用户的输入。
它是一个单独使用的标签，没有结束标志。通常可以和form表单配合使用
它有多种类型，取决于type属性的值，默认值是text，表示一个输入框。
&lt;input&gt; &lt;!-- 等同于 --&gt; &lt;input type="text"&gt; 上面代码会生成一个单行的输入框，用户可以在里面输入文本。
&lt;input&gt;的属性非常多，有些属性是某个类型专用的，放在下文的“类型”部分介绍。这里介绍一些所有类型的共同属性。
autofocus：布尔属性，是否在页面加载时自动获得焦点。disabled：布尔属性，是否禁用该控件。一旦设置，该控件将变灰，用户可以看到，但是无法操作。form：关联表单的id属性。设置了该属性后，控件可以放置在页面的任何位置，否则只能放在&lt;form&gt;内部。list：关联的&lt;datalist&gt;的id属性，设置该控件相关的数据列表，详见后文。name：控件的名称，主要用于向服务器提交数据时，控件键值对的键名。注意，只有设置了name属性的控件，才会向服务器提交，不设置就不会提交。readonly：布尔属性，是否为只读。required：布尔属性，是否为必填。type：控件类型，详见下文。value：控件的值。 type属性决定了&lt;input&gt;的形式。
Type类型包括：
（1）text
**type="text"是普通的文本输入框，用来输入单行文本。**如果用户输入换行符，换行符会自动从输入中删除。
&lt;input type="text" id="name" name="name" required minlength="4" maxlength="8" size="10"&gt; text输入框有以下配套属性。
maxlength：可以输入的最大字符数，值为一个非负整数。minlength：可以输入的最小字符数，值为一个非负整数，且必须小于maxlength。pattern：用户输入必须匹配的正则表达式，比如要求用户输入4个～8个英文字符，可以写成pattern="[a-z]{4,8}"。如果用户输入不符合要求，浏览器会弹出提示，不会提交表单。placeholder：输入字段为空时，用于提示的示例值。只要用户没有任何字符，该提示就会出现，否则会消失。readonly：布尔属性，表示该输入框是只读的，用户只能看，不能输入。size：表示输入框的显示长度有多少个字符宽，它的值是一个正整数，默认等于20。超过这个数字的字符，必须移动光标才能看到。spellcheck：是否对用户输入启用拼写检查，可能的值为true或false。 （2）search
**type="search"是一个用于搜索的文本输入框，基本等同于type="text"。**某些浏览器会在输入的时候，在输入框的尾部显示一个删除按钮，点击就会删除所有输入，让用户从头开始输入。
下面是一个例子。
&lt;form&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ad2fd4e409352be09343e0c53c44de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d002fca20a9d21d987d4a5498158bb1a/" rel="bookmark">
			主动学习工具箱子集合【libraries/toolkits of active learning】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在论文中，“主动学习工具箱”的规范的叫法是Library of active learning 或 Active learning library。 为啥叫Library？我不懂，审稿人都这么叫。记住便是。 【未完待续】 一、 ALipy 安装命令：pip install alipy
https://github.com/NUAA-AL/ALiPy
二、Distil 安装命令：pip install decile-distil https://github.com/decile-team/distil
包含方法：
Uncertainty Sampling [1]Margin Sampling [2]Least Confidence Sampling [2]FASS [3]BADGE [4]GLISTER ACTIVE [6]CoreSets based Active Learning [5]Random SamplingSubmodular Sampling [3,6,7]Adversarial DeepFool [9]BALD [10]Kmeans Sampling [5]Adversarial Bim 三、scikit-activeml 安装命令：pip install -U scikit-activeml https://github.com/scikit-activeml/scikit-activeml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f291ac57923daf7c8c4b0917387a4827/" rel="bookmark">
			【Java 进阶篇】Java文件下载案例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件下载是Web应用程序中常见的功能之一。它允许用户从Web服务器上下载文件，例如文档、图片、音频、视频等。在本文中，我们将详细解释如何在Java Web应用程序中实现文件下载功能。我们将提供示例代码和逐步说明，以帮助您理解和实现这一功能。
什么是文件下载？ 文件下载是指从Web服务器获取文件并保存到本地计算机或移动设备的过程。这些文件可以是各种类型，例如文本文件、图像、音频、视频、压缩文件等。文件下载通常通过HTTP协议实现，浏览器向服务器发送文件下载请求，服务器返回文件内容，然后浏览器将文件保存在本地。
在Java Web应用程序中，您可以使用Servlet来处理文件下载请求。Servlet可以将文件的内容发送到客户端浏览器，以便用户可以下载文件。
实现文件下载的步骤 要在Java Web应用程序中实现文件下载功能，通常需要执行以下步骤：
创建一个Servlet来处理文件下载请求。从请求中获取文件的路径或标识符。读取文件的内容。设置HTTP响应的头信息，指定文件的类型和下载方式。将文件内容写入HTTP响应的输出流。关闭输入流和输出流。 接下来，我们将通过一个示例来演示如何执行这些步骤。
示例：实现Java文件下载 在这个示例中，我们将创建一个名为FileDownloadServlet的Servlet，它允许用户下载一个名为sample.txt的文本文件。以下是实现这一功能的代码：
import java.io.*; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet("/download") public class FileDownloadServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 指定要下载的文件路径 String filePath = "C:/path/to/sample.txt"; // 获取文件名 String fileName = new File(filePath).getName(); // 设置响应头信息 response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\""); response.setContentType("application/octet-stream"); // 读取文件并将其写入响应输出流 try (InputStream in = new FileInputStream(filePath); OutputStream out = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f291ac57923daf7c8c4b0917387a4827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55afd6fbb8b5b0af3fafa3beef3f574a/" rel="bookmark">
			java中BigDecimal转json精确小数点的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目使用了 spring boot 作为基础架构，然而 spring boot 的 json 默认使用了 jackson，处理如下
创建一个类用户处理 BigDecimal 小数点精确的问题
import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import java.io.IOException; import java.math.BigDecimal; public class BigDecimalSerialize extends JsonSerializer { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { if (o != null &amp;&amp; o instanceof BigDecimal) { BigDecimal bigDecomal = (BigDecimal) o; jsonGenerator.writeString(bigDecomal.setScale(2, BigDecimal.ROUND_DOWN) + ""); } } } 然后在代码中添加如下代码
@JsonSerialize(using = BigDecimalSerialize.class) private BigDecimal cmpayNakedPrice; 执行正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6425d14cb7b31dedd3e45bcf64fe8a20/" rel="bookmark">
			unity 通过Andriod arr 访问 手机自带的浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 unity 通过Andriod arr 访问 手机自带的浏览器
using System.Collections; using System.Collections.Generic; using System.IO; using UnityEngine; using UnityEngine.UI; public class OpenURL : MonoBehaviour { public Button button; string url = "http://192.168.1.105:80/index.html"; void Start() { if (Application.platform == RuntimePlatform.WindowsEditor) { Application.OpenURL(url); } else if (Application.platform == RuntimePlatform.Android) { AndroidJavaObject activity = new AndroidJavaObject("com.example.myweblibrary.OpenWebUtils"); AndroidJavaObject context = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic&lt;AndroidJavaObject&gt;("currentActivity"); button.onClick.AddListener(() =&gt; { Debug.Log("按钮点击"); bool aa = activity.CallStatic&lt;bool&gt;("open", context, url); Debug.Log("是否成功 " + aa.ToString()); }); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74145dde6f9c746edf5301faa2f59757/" rel="bookmark">
			nvidia-docker 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 17.03.2-ce 使用GPU docker 官方是 19.0.2 开始支持英伟达GPU 在此之前版本可以通过英伟达魔改docker的工具 实现此需求
📦 nvidia-docker + nvidia-container-runtime 这个方案最低docker 要求是在docker 12 并且 由于docker 官方在docker 19 开始支持英伟达GPU目前这个 方案是已经停止维护了。高于19 直接安装 nvidia-container-toolkit
0 使用原理 nvidia-docker2.0 是一个简单的包，它主要通过修改docker的配置文件/etc/docker/daemon.json来让docker使用NVIDIA Container runtime。
nvidia-container-runtime 才是真正的核心部分，它在原有的docker容器运行时runc的基础上增加一个prestart hook,用于调用libnvidia-container库。
📦nvidia-docker2.0 是 nvidia-docker 升级版
1 docker 安装 sudo apt update 卸载 docker 服务器上有其他版本docker 才需要
sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras # 上面无效使用下面的 find / -name docker # 找到所有docker有关的文件 rm -rf /etc/systemd/system/docker.service.d rm -rf /var/lib/docker rm /usr/bin/dockerd rm /run/containerd/containerd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74145dde6f9c746edf5301faa2f59757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ef908ec77b430c3b1c1d89d0e68fce/" rel="bookmark">
			Java企业级进销存管理系统项目实战【完整资料】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java企业级进销存管理系统项目实战【完整资料】
https://www.aliyundrive.com/s/eAN9b9WnkSV点击链接保存，或者复制本段内容，打开「阿里云盘」APP，无需下载极速在线查看，视频原画倍速播放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd80c6dad7622f53c597bca5d1d66678/" rel="bookmark">
			xlsread函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xlsread 是 MATLAB 中用于读取 Microsoft Excel 文件（.xls 和 .xlsx 格式）的函数。它可以帮助你将 Excel 文件中的数据读取到 MATLAB 中，以便进行进一步的分析和处理。下面是 xlsread 函数的一般用法和一些常见的选项：
[num, txt, raw] = xlsread(filename)
filename: 要读取的 Excel 文件的文件名或文件路径。
xlsread 函数可以返回三个输出参数：
num: 包含数值数据的矩阵，如果 Excel 文件包含数字数据。
txt: 包含文本数据的单元格数组，如果 Excel 文件包含文本数据。
raw: 包含原始数据的单元格数组，包括所有数据类型。
你可以根据需要选择这些输出参数中的一个或多个，以获取所需的数据。
此外，xlsread 还有一些可选参数，可以用来指定读取的范围、工作表和其他选项。以下是一些常见的选项：
'Sheet': 指定要读取的工作表名称或索引。
'Range': 指定要读取的数据范围，例如 'A1:B10'。
'Basic': 逻辑值，指定是否只读取基本数据类型（数值和文本），忽略日期、时间等特殊数据类型。默认为 false。
'UseExcel': 逻辑值，指定是否使用 Excel 应用程序来读取文件，可以处理包含宏的文件。默认为 false。
以下是一个示例，演示如何使用 xlsread 函数来读取一个 Excel 文件中的数据：
filename = 'example.xlsx';
[num, txt, raw] = xlsread(filename, 'Sheet1', 'A1:B5');
这将从名为 'Sheet1' 的工作表中读取 A1 到 B5 区域的数据，并将数值数据存储在 num 中，文本数据存储在 txt 中，原始数据存储在 raw 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd80c6dad7622f53c597bca5d1d66678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aefbb9335b2392cf74de66ad4a8f283/" rel="bookmark">
			Java毕业设计基于Springboot&#43;vue的活鲜物流监控系统 开题报告&#43;论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友发现后期找不到文章，收藏关注不迷路
文章目录 项目介绍研究意义研究目的技术介绍项目界面关键代码目录 项目介绍 活鲜商品在物流过程中容易死伤，需要采用软件系统来辅助物流过程的监控。随着经济全球化的发展，企业面临激烈的竞争，物流管理工作在企业建设中越来越重要。全国的很多的物流企业在信息化建设方面还不是很成熟，没有自己的物流管理系统，甚至有的小型企业还没有实现计算机管理。大多数企业还停留在用手工登记的阶段，这些现象与物流业繁忙的业务量不相适应，物流管理的落后严重影响了企业的竞争力，降低企业的效率。物流管理的落后严重影响了企业的竞争力，降低企业的效率。实行计算机科学化管理，可以有效的提高工作效率、降低管理成本。这个观点已经得到了越来越多的管理者的认可。
二、设计目的和要求
设计目的：（1）培养自己综合运用所学知识的能力以及结合实际情况独立完成课题的工作能力。
（2）运用所学知识及新知识的学习，完成一项适用于活鲜物流生成的系统。
设计要求：（1）要求要有结合实际的某项具有项目的设计或对某具体课题进行有独立见解的论证。
（2）能在规定时间内完成论文要求并实现活鲜物流监控系统的相关功能。
三、设计内容和思路
设计内容：
用户注册和登录：用户注册登录，登陆后可以修改密码，以及修改自己信息。基本信息管理：员工表,部门表,账号表的增删改查(员工新增完成后会将手机号当作账号,密码默认),删除用逻辑删除。车辆管理：车辆表的增删改查。活鲜商品站点管理：站点的上下级，以及站点的树型化展示(有一级站点和附属的二级站点)，在新增时会进行选择这个站点是几级站点,如果是二级站点，要进行选择父站点。权限管理：各个账号的角色分配(用复选框),给角色分配资源(用树形控件进行进行展示,能进行半选和全选):不同的账号登录进去会看到该账号分配的角色可以看到的资源。用户下单(在线下单和门店下单)：用户登录 后进行下单(在线下单),到附近站点进行下单（门店下单）。活鲜商品装配管理：为审核过的订单进行装车。调度管理：为专线审核后的订单进行分配车辆。活鲜商品装车卸车管理：对各个站点的货物进行装车卸车到达的动作。我的订单：用户下完单之后可以在我的订单看到自己的货物订单信息和状态。站点订单统计：用条形统计图进行统计每个站点在本周运输的物流单数。
设计思路：
运用springboot+vue进行代码编写，在设计方面采用B/S三层结构,用mybatisplus写基本表的基本增删改查,用mybatis进行复杂sql语句进行业务功能的实现,用vue的elementUI组件进行前端界面的设计,用vue的echarts进行站点订单统计,后台数据库采用mysql数据库。 研究意义 随着时代的不断发展，我国科学技术水平显著提升。就学校而言，其需要在大环境不断变化的今天进行管理体系的革新，如此才能跟上时代发展步伐。然而活鲜物流监控系统是一项较为复杂的工作，涉及多个组织、多个层次的协调和共同管理，整个过程需要将管理系统和人员进行全面整合。文章在具体研究过程中从多方面入手，针对当前物流管理中活鲜物流监控系统应用存在的问题进行了分析，阐述了应如何对管理系统体系结构进行设计与应用。基于springboot框架的活鲜物流监控系统开发与应用，对提高活鲜物流服务水平有促进作用。活鲜物流监控系统的设计与优化，则是在活鲜物流管理的视角下，通过Web服务器，对活鲜物流监控系统的功能进行设计，以此实现活鲜物流监控系统的应用水平提升。
研究目的 之所以一直强调要对活鲜物流监控系统进行大力的研究，主要是因为活鲜物流监控系统对于活鲜物流的推进有着十分重要的作用，活鲜物流监控系统研究的主要目的是能够让用户更加科学合理的对数据信息进行处理和归纳，提高整个工作的效率，通过这样的方式能够进一步推进活鲜物流得到更好的管理和实施。对于活鲜物流的管理来说，活鲜物流监控系统是十分有效的一个途径，也正是因为这样的特殊性使得在对活鲜物流进行管理和推进的过程中，必须要将活鲜物流监控系统的研究放在首要位置，通过对活鲜物流监控系统进行研究能够进一步推进学校的发展。
技术介绍 1、管理员账号：abo 密码：abo
2、开发环境为Eclipse/idea，数据库为mysql 使用java语言开发。
3.配置好Tomcat并点击启动按钮即可运行
4.数据库连接src\main\resources\application.yml中修改
5.maven包版本apache-maven-3.3.9.
开发语言：Java
框架：SSM
前端框架:vue.js
JDK版本：JDK1.8+
服务器：tomcat8+
数据库工具：Navicat
开发软件：idea 支持eclipse
Springboot是当前最流向的一个框架，它的配置更加的简单，使开发变得更加的简单迅速。
Springboot的基础结构共三个文件，具体如下：
src/main/java：程序开发以及主程序入口；
src/main/resources：配置文件；
src/test/java：测试程序。
ssm的数据库配置默认支持两种格式的配置文件
1,application.properties
2,application.yaml
项目界面 关键代码 package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aefbb9335b2392cf74de66ad4a8f283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edc2be317622442ae154a4b468c039d/" rel="bookmark">
			快递鸟荣获全球电子商务创业创新大赛总决赛一等奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前，以“开放、连接、协同、赋能”为主题，由商务部中国国际电子商务中心指导，浙江省商务厅、中共省委组织部、中共省委宣传部、中共省委网信办、省发展和改革委、省教育厅、省科技厅、省财政厅、省人力社保厅、团省委主办，湖州市人民政府联合主办的“之江创客”2023全球电子商务创业创新大赛总决赛暨颁奖典礼在湖州南浔圆满落幕。快金数据旗下“快递鸟”在全球总决赛舞台角逐的12个优秀团队中脱颖而出，最终荣获总决赛一等奖。
作为电商“双创”领域的标杆赛事，“之江创客”全球电子商务创业创新大赛自2017年至今已连续举办7届，挖掘和培养了一大批优质电商双创项目。本届“之江创客”大赛共举办农村电商、跨境电商、供应链、西南、粤港澳、欧洲、中东、北美8场分赛，吸引了越南、新加坡、马来西亚、墨西哥、瑞士等十几个国家及深圳、广州、成都、杭州等十几个城市的优秀项目和创业团队参赛，项目涵盖电子商务、人工智能、物联网、供应链、高端制造、生命科学和健康等领域，呈现出商业模式跨界创新、技术融合创新、领域专业细分等特点。
此前，“快递鸟”就曾在粤港澳赛区决赛中夺得一等奖殊荣，此次全球总决赛中再获一等奖，充分展现了“快递鸟”用科技改变物流的硬核实力和项目潜力。
近年来，随着在线零售的渗透率加速提升，物流已成为电商平台打造竞争力的关键，发货端在物流服务商选择、电子面单打印、包裹在途管理、退换货等全流程物流管理数字化及线上化需求越来越强烈；与此同时，物流规模持续增长、运力分散、信息化进程加速，物流端也正在加快数字化升级进程；传统线上零售去中心化，近场电商、兴趣电商、直播电商等新兴模式层出不穷，具有一定营收规模的企业，特别是涉及线上线下多渠道、多业态经营的品牌企业，需要“快递鸟”这样的全流程物流数字化管理服务，来帮助企业自身管理所有物流业务，以物流综合数字化解决方案来破解物流供应链管理的诸多痛点。
目前“快递鸟”已发布一系列数智物流服务产品，包括物流查询 API、电子面单 API、在途监控 API 、物流管家等物流查询和管理产品，以及满足发货端降本增效的智选运力解决方案，如上门取件、即时配、电商退换货和聚合寄件等。值得一提的是，2023年“快递鸟”推出了致力于帮助发货端突破物流盲区，协同物流上下游，实现全链路物流管理及业务协同的数据中台产品——物流导盲犬DMS，经测算，使用 DMS 后异常物流处理效率平均提高50%+，物流成本平均节省65%+。截止目前超过50万家企业客户选择了“快递鸟”，并实现了物流各环节精细化、动态化、可视化管理，极大提高了物流智能化分析决策和自动化操作执行能力。
在核心竞争力方面，“快递鸟”已对接2300+快递物流公司系统，数据服务量最高覆盖全国的20%以上，日服务单量3000万+，多项能力指标处在同行业前列，并且公司已获得国家级高新技术企业、深圳市“专精特新”企业、国家信息系统安全等级保护三级、邮政业科技创新战略联盟理事单位及物流标准制定成员等认证资质，曾获得知名机构启赋资本、东方富海、中银粤财的投资。
自2015年成立以来，“快递鸟”始终在践行”用科技改变物流，让发货更简单“的使命，令人振奋的是，我们的产品和努力赢得了来自客户、行业、投资机构和主管单位的广泛认可。面向未来，“快递鸟”将进一步夯实核心能力、加大技术研发投入，为物流数字化、可视化、智能化发展贡献更多力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50f6f640282308bcace9adf2a6ed5b7/" rel="bookmark">
			抖音大型直播的画质优化实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面临挑战 随着抖音内容生态的不断丰富，越来越多的大型赛事在抖音平台进行直播，世界杯/春晚/亚运会等各项赛事节目引来大量用户观看。卡塔尔世界杯期间，抖音提供的稳定高质直播画面为观众带来了完美的观赛体验，决赛的 PCU 高达 3700W+。不同赛事节目涉及链路众多，且不同赛事之间存在差异，如何保障各链路的画质稳定并进一步提升画质，是一个巨大的挑战。
如何应对挑战？ 画质优化链路 大型赛事直播涉及链路较长，不同赛事链路存在一些差异，整体可简化为下图流程，现场信号经过演播室的制作传输给 CDN 再进一步分发到用户侧。从画质角度来看整个链路可分为画质检测与画质优化两个部分，对于 CDN 之前的链路以画质监测为主，以发现问题/定位问题/推动对应链路人员解决问题为目的。画质优化在 CDN 和客户端两侧进行，下面的内容主要介绍画质优化部分。
随着赛事录制技术的提升，越来越多的大型赛事都用上了4K HDR录制标准，画质清晰度也不断提升，随之而来的是更大的带宽压力。同时为了兼容消费端不同的看播设备和不同的带宽条件，服务端需要转出多种不同分辨率不同码率的版本供看播端选择，为了保障用户在不同带宽与设备下都能取得最佳的画质体验，我们做了大量的优化工作。团队通过自研的自适应 ToneMapping，视频降噪，ROI编码，视频插帧，BAS采样，端上超分等算法有效地提升了赛事画质。
自适应ToneMapping： 目前大型赛事大都使用HDR（高动态范围）设备录制，团队对支持 HDR 看播的设备增加了 HDR 档位，同时提供了多种不同分辨率/帧率的档位。HDR 拍摄的片源拥有更广的色域，更大的动态范围。但对很多终端显示设备而言，并不支持 HDR 信号播放，所以通过 ToneMapping 算法将 HDR 信号转换为 SDR（标准动态范围）信号是十分必要的。
相比 SDR 信号，HDR 信号拥有更广的色域和更大的动态范围，在转换到 SDR 信号的过程中不可避免会产生一些信息损失。常用的一些 ToneMapping 方法，不论是 Reinhard，Filmic 或者 Hable，其本质都是设计固定的映射曲线实现从 HDR信号 到 SDR信号的转换，同时尽量保持对 HDR 效果的还原。但直播赛事场景多变，且现场动态范围跨度极大，如世界杯比赛中场馆的灯光/草地/球员亮度差异明显，不同镜头跨度极大，而在亚运会游戏类比赛中的CG画面较为稳定，现有的ToneMaping算法无法在多变的场景中取得优秀稳定的效果，而手动调节每场比赛的转换参数也不现实。为了解决这一问题，团队提出了内容自适应 ToneMapping 算法，通过统计视频内容的实际光照情况动态地进行 ToneMapping，从而得到更优效果。
左: 内容自适应 ToneMapping，右: Hable 算法
在主观众测中优化之后的内容自适应 ToneMapping 算法遥遥领先于现有的TonaMpaping算法结果（对照任务为团队自研结果）
BAS 采样： BAS（Byte AI Scaling）算法是字节自研的一种基于深度学习的图片/视频下采样算法，近些年来，深度学习驱动的视频处理算法已经广泛应用于各类点播、直播服务中，涵盖抖音、西瓜视频等诸多业务线。在实际的流媒体传输链路中，依据用户实际网络延迟、终端性能等因素，源流将通过自适应码率（Adaptive Bit-Rate）策略传输到终端设备，优化用户实际体验。其中，视频流往往会被采样到多个标准分辨率，例如蓝光（1080p）、高清（720p）、标清（480p）等。随着音视频行业和摄影设备的发展，高分辨率的视频源占比日益增多，大部分视频需要在服务端进行降采样来配合自适应码率策略，因此降采样算法的优化也是提升QoE的关键。在过去的业界实践中，视频处理算法往往专注于提高分辨率（如超分算法）或者保持分辨率（如降噪算法）的处理范式，而几乎忽视了对降低分辨率方法的研究。不同于固定算子的bicubic等降采样算法，BAS算法基于深度学习使用高精度数据训练模型，缓解传统方法带来的频域混叠与频域截断问题，降低锯齿感、减少细节丢失。如下图所示，对于4K的超高清图源降采样到480p分辨率的任务，左图为BAS算法处理结果，右图为传统bicubic算法处理结果。可以明显看到，BAS算法处理结果中缓解了边缘锯齿（左下），消除了摩尔纹（右下），并且灯牌、观众席等方面的细节纹理更加清晰，视觉观感更好。
左图为BAS采样结果，右图为Bicubic采样结果
在与bicubic算法的定量对比中，BAS基于PSNR指标取得了-20.32%的BD-Rate收益，意味着相同重建误差水平下可以节省20%以上码率，而同等码率下则可以提升画质水平。而对于更符合人眼感知特性的VMAF指标，BAS同样取得了-20.89%的BD-Rate收益。
在常用的编码条件下，BAS算法在UGC视频上能做到在降低6.12%平均码率的同时，提升多项关键主客观画质指标，既可以降低一部分传输带宽，也可以带来画质上的提升，取得成本和体验上的双赢。
视频插帧： 抖音大型赛事实践中会遇到各种不同的录制标准，其中也存在1080P 25fps的录制标准，现在消费者已经习惯高帧率的流畅视频体验，对于低帧率的视频会明显感受到画面的流畅度降低，影响用户观看体验。针对低帧率场景，我们使用了智能插帧技术，通过对前后帧的内容进行光流估计，根据光流信息将前后帧像素都转换到中间帧，然后进行整合，生成中间帧，提升视频帧率，减少观看时的卡顿感。而针对电竞类对帧率要求较高的场景，我们做了以下的额外优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50f6f640282308bcace9adf2a6ed5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a30a069b8d171ae731b28d9a30cc6b2/" rel="bookmark">
			京东平台3个热门API接口的分享【附代码实例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用程序接口API（Application Programming Interface），是提供特定业务输出能力、连接不同系统的一种约定。这里包括外部系统与提供服务的系统（中后台系统）或后台不同系统之间的交互点。包括外部接口、内部接口，内部接口又包括：上层服务与下层服务接口、同级接口。
如果不想被视为技术大佬眼中什么都不懂的需求搬运工，清楚接口的相关知识是很有必要的。
常见web接口是http/https协议的接口，多用于外部系统或前端系统的调用，因为此类接口地址要暴露在外部，所以必须对接口的安全性做较高程度的校验。还要一种基于开源rpc构建的跨系统接口调用接口方案，此类主要用于大公司内网各系统间的互相调用，此类接口服务治理能力更强，接口相应速度更块。
做过淘客开发的一定接触过淘宝API开发。
而做京东联盟软件自然离不开京东联盟API。
京东联盟API目前上线的有很多
但是京东联盟API获取比较难，没办法在线申请，需要找官方手工申请。
申请步骤略过，一般个人很难申请到。
下面我们分享几个京东平台上比较热门的API接口。
jd.item_get 公共参数
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 请求参数
请求参数：num_iid=10335871600
参数说明：num_iid:JD商品ID
url:京东域名[非item.jd.com需传]
(npcitem.jd.hk:京东国际,item.jkcsjd.com:京东大药房)
响应参数
Version: Date:
名称类型必须示例值描述 items
items[]0获得JD商品详情 num_iid
Bigint029186819959商品ID title
String0MOCO2018夏季新品时尚V领条纹连衣裙 摩安珂 蓝白条色 S商品标题 desc_short
String0商品简介 price
Float0719.0价格 total_price
Float00 suggestive_price
Float00 orginal_price
Float01199.00原价 nick
String0MO&amp;Co.官方旗舰店掌柜昵称 num
Int0999 min_num
Int00 detail_url
String0http://item.jd.com/29186819959.html商品链接 pic_url
String0//img14.360buyimg.com/n0/jfs/t22033/147/1051007175/85125/c44dd0df/5b1f2855Ncbe35858.jpg商品图片 brand
String0品牌名称 brandId
Int0品牌ID rootCatId
Int01343顶级分类ID cid
Int09719 crumbs
Mix0[] created_time
String0 modified_time
String0 delist_time
String0 desc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a30a069b8d171ae731b28d9a30cc6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1eb291cc0c7d3d2a4ddcb621c3568d/" rel="bookmark">
			windows cuda not available的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先确定好nvidia-smi和nvcc -V可以正确显示。
cmd输入以下代码查看详情，确定好版本都兼容
python -m torch.utils.collect_env
如果是先装了pytorch，可以先把pytorch卸载了重装。
再次通过代码
import torch
torch.cuda.is_available()
测试结果显示true。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b8c6743c6ff42fd2f358e3703bc6e0/" rel="bookmark">
			快速汇总子文件夹文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win11搜索栏输入：NOT 种类：=文件夹，复制粘贴操作即可
当然，everything之类的软件也行，bat、vbs或者python脚本也行，你喜欢就好
参考链接：
怎样快速地把电脑里多个文件夹中的文件汇总到一起？
在macOS和Windows，如何同时操作多个文件夹中的文件
*少数派，和上面一样
Win7 高级搜索 AND OR NOT 正则
活用Win7搜索功能 更快更准更贴心
在 Windows 7 中进行搜索可以简单到只需在搜索框中键入几个字母，但也有一些高级搜索技术以供使用。在搜索文件时，您不一定得了解这些技巧，但这些技巧确实能提供一些帮助，具体取决于搜索的位置和搜索的对象。 提示： 如果知道文件类型，则可以在搜索框中仅输入文件扩展名（例如，“JPG”）。若要了解有关 Windows 中基本搜索的详细信息，请参阅查找文件或文件夹。 添加运算符 细化搜索的一种方法是使用运算符 AND、OR 和 NOT。当您使用这些运算符时，需要以全大写字母键入。 运算符 示例 用途 AND tropical AND island 查找同时包含“tropical”和“island”这两个单词（即使这两个单词位于文件中的不同位置）的文件。如果只进行简单的文本搜索，这种方式与键入“tropical island”所得到的结果相同。 NOT tropical NOT island 查找包含“tropical”但不包含“island”单词的文件。 OR tropical OR island 查找包含“tropical”或“island”单词的文件。 添加搜索筛选器 搜索筛选器是 Windows 7 中的一项新功能，通过它可以更轻松地按文件属性（例如，按作者或按文件大小）搜索文件。 在搜索中添加搜索筛选器的步骤 打开要搜索的文件夹、库或驱动器。 单击搜索框，然后单击搜索筛选器（例如，图片库中的“拍摄日期:”）。 单击其中一个可用选项。（例如，如果单击了“拍摄日期:”，请选择一个日期或日期范围。） 搜索框中“拍摄日期”搜索筛选器的图片“拍摄日期”搜索筛选器 在一次搜索中可添加多个搜索筛选器，甚至也可将搜索筛选器与常规搜索词一起混合使用，以进一步细化搜索。 搜索框中“标记”搜索筛选器菜单的图片可使用两个搜索筛选器搜索很久以前拍摄的标记了“family”的图片。 只有某些特定的搜索筛选器可用，具体取决于搜索的位置。例如，如果在文档库中搜索，您就会发现其中的搜索筛选器与图片库中的不同。您无法指定哪些搜索筛选器可见，但是可更改优化库所针对的文件类型。这样就可以更改在搜索该库时可使用哪些搜索筛选器。若要了解如何执行此操作，请参阅自定义库。 使用关键字细化搜索 如果您希望在单击搜索框时按照没有显示的属性进行筛选，则可以使用特殊关键字。这通常需要键入一个属性名称后加一个冒号，有时加一个运算符，然后键入一个值。关键字不区分大小写。 搜索词示例 用途 System.FileName:~&lt;"notes" 名称以“notes”开头的文件。~&lt; 表示“开头”。 System.FileName:="quarterly report" 名为“quarterly report”的文件。= 表示“完全匹配”。 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b8c6743c6ff42fd2f358e3703bc6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d3101a0d45257b8c55c14765503ffc/" rel="bookmark">
			Angular 集成 Material UI 后组件显示不正常 踩坑日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
解决方案(按步骤手动执行下面): 一. 在运行上面命令后, 控制台会出现一些选项让开发者选择一些功能:
二. 之后还将执行下面操作:
3. 添加全局 css 样式.
问题描述 在使用了 npm 下载 Material 后, 项目不能正常使用 Material 组件, 随后又使用官方命令使用 Material 组件, 仍然不能正常使用 Material 组件.
使用的 npm 命令:
npm install --save @angular/material 最后发现, 在执行上面相关命令后, Material 并没有完全自动执行下文 "二. 之后还将执行下面操作:", 随后手动执行 "二. ..." 相关操作, 组件正常运行.
解决方案(按步骤手动执行下面): 官方网站:
首页 - Angular Material 组件库
使用官方推荐命令会比较好, 主要是官方推介命令会进行相应配套操作, 降低自己操作难度:
ng add @angular/material 一. 在运行上面命令后, 控制台会出现一些选项让开发者选择一些功能: 1. 选择组件的主题, 或者自定义主题(custom). 粗略理解就是页面主题颜色
2. 设置全局样式.
3. 设置浏览器动画.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d3101a0d45257b8c55c14765503ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd60beb714c3dcce040c03d62faaf014/" rel="bookmark">
			QString字符串内部嵌套双引号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见字符串形式
QString string = "cube is trangle"; 此时在字符串string 输出时，将cube输出为“cube"
需要使用转折符打破双引号（“”）的原有识别属性
QString string =" \" cube \" is trangle"; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/98/">«</a>
	<span class="pagination__item pagination__item--current">99/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/100/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>