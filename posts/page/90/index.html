<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb2dabd38818cd326260b667ea9a2d8/" rel="bookmark">
			go-zero框架之goctl模板分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		goctl-template 最近的一些项目主要使用golang开发，框架是go-zero, goctl确是开发利器，这里分享下goctl的模板
当前版本支持go-zero v1.5.0 理论是应该向后兼容的
模板是基于官方模板修改而来 优化点主要是
调整handler.tpl, 支持自定义的接口返回结果与异常处理查询接口支持事务会话参数, 这样让查询与修改都会在事务，尽而保证的事务的一致性， 修改文件主要有：model.tpl和find-*.tpl的几个文件 提示 这是我们开发正在使用的一套模板 效率开发 我们现在的开发流程基本是这样的
需求与技术设计过后设计数据库然后生成model, 支持重复生成定义API描述， 生成api文档/route/handler/logic代码，我们只在logic开发，其他均支持重复生成目前感觉这样的开效率老高了 源码下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d9d4ab3447a6306d03df9da7227623/" rel="bookmark">
			计算机专业答辩技巧详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机专业答辩技巧详解，模版详情参考如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfe5c6b9f5a1ab545ed4be2b0cf1ae2/" rel="bookmark">
			【跟李沐学AI—机器学习】2 神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 多层感知机（MLP Multilayer Perceptron）2 卷积神经网络（CNN Convolution Neural Net）3 循环神经网络（RNN Recurrent Neural Networks ） 1 多层感知机（MLP Multilayer Perceptron） dense layer/全连接层，y=wx+b
线性回归就是一个全连接层，即单层感知机
多层感知机是一种前向结构的人工神经网络，包含输入层、输出层及多个隐藏层
由于多个全连接层叠加还是线性关系，所以要在其中加入非线性函数，即激活函数
2 卷积神经网络（CNN Convolution Neural Net） 由于MLP使用的是全连接层，每经过一层都会有几个数量级参数的增加，参数太多。
假设要在某图像中寻找一个戴白帽子的人，即使这个戴白帽子的人在图像中的位置变化了，但是这块区域的像素信息不变，即平移不变性。
同时这块区域和附近的像素信息具有相关性，即本地性。
卷积则利用了这两个性质。
卷积层可以通过滑动窗口对像素矩阵进行一块一块进行加权和计算，这个权重矩阵（大小为k*k）为数值一样的方阵，叫卷积核。
**池化层/汇聚层：**当搜寻的区域发生平移时，这片区域的像素最大值/平均值也会发生平移，只要抓住这个最大值/平均值就可以补偿平移带来的变化。
3 循环神经网络（RNN Recurrent Neural Networks ） 多用于语言模型，带有时序信息
假设有一句话是“hello world!”。
先输入“hello”，通过全连接层预测得到“world”，先不进行softmax操作，把这个得到的、带有之前所有信息的“world”作为输入，传给下一个全连接层，再对“world”进行softmax
进行下一个词语的预测时，输入就有①带有之前所有信息的“world”和②当前信息的“world”
其中这个带有之前所有信息的“world”为隐藏状态，不论之后还有多少层，这个“world”包含的信息不变，包含过去时间所有的信息
简化版RNN：
图中的RNN即全连接层
输入有 当前时刻的xt 和 上一时刻的输出ht-1
输出 yt 和 ht（简单版中它们是同一个东西），ht 留给下一时刻的RNN
输出后还会有激活函数
更复杂的RNN（LSTM、GRU）：
忽略当前的输入xt，比如空格、介词等不太重要的信息忽视以前的信息ht-1，比如一个段落开始了，或者前面的信息实在是太远了不需要了忽视的时间也需要另外一组权重来学习 更更复杂的RNN：
Bi-RNN
双向，输入有时刻t+1和t-1的信息，有两个子层同时走，但起点相反、方向相反
Deep RNN
叠加很多RNN层
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ddad779708121664823dd946f1c035/" rel="bookmark">
			【NLP】RAG 应用中的调优策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
检索增强生成应用程序的调优策略
没有一种放之四海而皆准的算法能够最好地解决所有问题。
本文通过数据科学家的视角审视检索增强生成（RAG）管道。它讨论了您可以尝试提高 RAG 管道性能的潜在“超参数”。与深度学习中的实验类似，例如，数据增强技术不是超参数，而是可以调整和实验的旋钮，本文还将介绍您可以应用的不同策略，这些策略本身不是超参数。
本文涵盖以下按相关阶段排序的“超参数”。在RAG 管道的
摄取阶段，您可以通过以下方式实现性能改进：
数据清洗分块嵌入模型元数据多重索引索引算法 在推理阶段（检索和生成），您可以调整：
查询转换检索参数高级检索策略重新排序模型LLM及时工程 请注意，本文涵盖了 RAG 的文本用例。对于多模式 RAG 应用，可能需要考虑不同的因素。
摄取阶段 摄取阶段是构建 RAG 管道的准备步骤，类似于 ML 管道中的数据清理和预处理步骤。通常，摄取阶段包括以下步骤：
收集数据块数据生成块的向量嵌入将向量嵌入和块存储在向量数据库中 ​
RAG 管道的摄取阶段
本节讨论有影响力的技术和超参数，您可以应用和调整这些技术和超参数，以提高推理阶段检索到的上下文的相关性。
数据清洗 与任何数据科学管道一样，数据质量会严重影响 RAG 管道中的结果 。在继续执行以下任何步骤之前，请确保您的数据满足以下条件：
清洗：至少应用自然语言处理中常用的一些基本数据清理技术，例如确保所有特殊字符都正确编码。准确：确保您的信息一致且事实准确，以避免信息冲突使您的LLM感到困惑。 分块 对文档进行分块是 RAG 管道中外部知识源的重要准备步骤，这可能会影响性能 。它是一种生成逻辑上连贯的信息片段的技术，通常是将长文档分解成较小的部分（但它也可以将较小的片段组合成连贯的段落）。
您需要考虑的一项是分块技术的选择。例如，在LangChain中，不同的文本拆分器通过不同的逻辑来拆分文档，例如按字符、令牌等。这取决于您拥有的数据类型。例如，如果您的输入数据是代码，则您将需要使用不同的分块技术，如果它是 Markdown 文件，您将需要使用不同的分块技术。
块 ( chunk_size)的理想长度取决于您的用例：如果您的用例是问答，您可能需要较短的特定块，但如果您的用例是摘要，您可能需要更长的块。此外，如果块太短，它可能无法包含足够的上下文。另一方面，如果块太长，它可能包含太多不相关的信息。
此外，您需要考虑块之间的“滚动窗口”( overlap)以引入一些额外的上下文。
嵌入模型 嵌入模型是检索的核心。嵌入的质量会严重影响您的检索结果。通常，生成的嵌入的维数越高，嵌入的精度就越高。
要了解可用的替代嵌入模型，您可以查看大规模文本嵌入基准 (MTEB) 排行榜，其中涵盖 164 个文本嵌入模型（在撰写本文时）。
虽然您可以开箱即用地使用通用嵌入模型，但在某些情况下，根据您的特定用例微调嵌入模型可能是有意义的，以避免稍后出现域外问题 。根据 LlamaIndex 进行的实验，微调嵌入模型可以使检索评估指标的性能提高 5-10% 。
请注意，您无法微调所有嵌入模型（例如，OpenAItext-ebmedding-ada-002目前无法微调）。
元数据 当您将矢量嵌入存储在矢量数据库中时，某些矢量数据库允许您将它们与元数据（或未矢量化的数据）存储在一起。使用元数据注释向量嵌入有助于对搜索结果进行额外的后处理，例如元数据过滤[1,3,8,9]。例如，您可以添加元数据，例如日期、章节或子章节参考。
多重索引 如果元数据不足以提供附加信息来逻辑地分隔不同类型的上下文，您可能需要尝试使用多个索引。例如，您可以对不同类型的文档使用不同的索引。请注意，您必须在检索时合并一些索引路由。
索引算法 为了实现大规模快速相似性搜索，矢量数据库和矢量索引库使用近似最近邻 (ANN) 搜索而不是 k 最近邻 (kNN) 搜索。顾名思义，ANN 算法近似最近邻，因此可能不如 kNN 算法精确。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1ddad779708121664823dd946f1c035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80691d8b384407c488d1754f9963cc1/" rel="bookmark">
			电脑更新后突然检测不到外接显示器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近我的笔记本电脑进行了一次windows更新，更新完后突然检测不到外接显示器，我的电脑是通过拓展坞上的上hdmi口连接外接显示器。
尝试解决 尝试更新驱动（无效）尝试卸载掉刚安装的windows更新，并重启电脑（无效）尝试拔掉拓展坞，然后再连接起来（无效） 最终解决 最后在网上无意中看到一篇帖子的评论，按照评论中的操作解决了问题。帖子链接
拔掉笔记本上连接的充电器，扩展坞和其它设备。关机。确认笔记本关机后，按住开机按键20秒，按住时不要动，持续20秒种。此刻笔记本LOGO会显示一下后熄灭。完成上述步骤后，重新启动笔记本，笔记本启动完成后，再接入扩展坞。 这个操作的具体原理暂时没找到，有的人说是除静电，有的说是恢复主板BIOS默认出厂设置。
写在最后 今天的干货就分享到这里。欢迎一键三连，持续关注“安前码后”，一个只输出干货而不是随大流的技术号。另外，赚钱的号“韭盾”，也在持续开发中，有投资兴趣的铁子们可以先关注，绝对是好物。 加油，铁子们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d508f006dc05b4391df450da45347a68/" rel="bookmark">
			VLANIF、VLAN聚合的基本原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、VLAN间通信之VLANIF虚接口
1、VLANIF虚接口
2、VLANIF虚接口实验
3.三层交换连接路由实现全网互通
二、VLAN聚合
1、什么是VLAN聚合
2、VLAN聚合的作用：
3、VLAN聚合的工作原理
4、VLAN聚合存在的问题：
5、VLAN聚合实验
一、VLAN间通信之VLANIF虚接口 说明：想要实现VLAN间互访有很多解决方案：
1）VLAN终结--也称单臂路由
2）VLANIF虚接口---最受欢迎的解决方案
1、VLANIF虚接口 1）VLANIF接口是一种三层虚拟接口，可以实现VLAN间的三层互通。
2）VANIF配置简单，是实现VLAN间互访最常用的一种技术
3）每个VLAN需要配置一个VLANIF，给VLANIF配置接口IP地址，并指定一个IP子网网段，作为VLAN内主机的网关
2、VLANIF虚接口实验 1）拓扑
2）需求：
让所有vlan内的所有pc主机都可以互通
3）配置步骤
-配置PC的IP地址和掩码、网关
-交换机SW2/SW3 上创建VLAN，配置接口接口加入VLAN
-在SW1上创建VLAN，并且给VLANIF 虚拟接口配置IP地址
4）配置命令
SW1配置： [SW1]vlan batch 10 20 30 40 [SW1]port-group group-member g0/0/1 g0/0/2 [SW1-port-group]port link-type trunk [SW1-port-group]port trunk allow-pass vlan all [SW1-port-group]quit [SW1]interface vlanif 10 [SW1-vlanif10] ip address 192.168.10.254 24 [SW1-vlanif10]interface vlanif 20 [SW1-vlanif20]ip address 192.168.20.254 24 [SW1-vlanif20]interface vlanif 30 [SW1-vlanif30]ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d508f006dc05b4391df450da45347a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd01dab2ee111a4c805dc5565fc2da3/" rel="bookmark">
			Vue学习计划-Vue2--Vue核心（四）watch监听属性、动态绑定class、style，set方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 监听(watch): 监听一个属性的变化，又叫监听器，侦听器 监视属性watch:
当监视的属性变化时，回调函数自动调用，进行相关操作监视的属性必须存在，才能进入监视监视的两种写法： new Vue时传入watch配置通过vm.$watch()监视 immediate初始化时让handler调用一下 深度监视：
Vue中的watch默认不监视对象内部值的变化（只监视一层）配置deep:true可以监视对象内部值变化（监视多层结构） 监视watch有两种完整写法：
1. 在Vue实例内部 const vm = new Vue({ el: "#app", watch:{ immediate: true, // 初始化时让handler调用一下 deep: true, // 深度监听 handler(newValue, oldValue){ console.log(newValue, oldValue) } } }) 2. 实例身上调用$watch API vm.$watch('isSHow',{ immediate: true, // 初始化时让handler调用一下 deep: true, // 深度监听 handler(newValue, oldValue){ console.log(newValue, oldValue) } }) 监视对应的有两种简写：当确定不使用immediate和deep属性时可以简写 1. 写在Vue实例内部 const vm = new Vue({ el: "#app", watch:{ isShow(newValue, oldValue){ console.log(newValue, oldValue) } } }) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fd01dab2ee111a4c805dc5565fc2da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83273adc086959ea459714f949137b1/" rel="bookmark">
			异构联邦学习综述：最新进展与研究挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://zhuanlan.zhihu.com/p/652910673
1.摘要 联邦学习（Federated Learning, FL）因其在大规模工业应用中的潜力而受到越来越多的关注。现有的联邦学习工作主要关注模型同构的情况。然而，实际的联邦学习通常面临参与者客户端之间的数据分布、模型体系结构、网络环境和硬件设备的异构性。异构联邦学习（Heterogeneous Federated Learning, HFL）更具挑战性，其解决方案多样且复杂。因此，对该问题的研究挑战和最新进展进行系统综述是必要的。本文首先从统计异构、模型异构、通信异构、设备异构和额外挑战5个方面总结了HFL的各种研究挑战；此外，还回顾了近年来HFL研究的最新进展，并对现有的HFL方法进行了新的分类，深入分析了它们的优缺点。最后讨论了HFL未来的几个重要研究方向，以期促进该领域的进一步发展。
2.引言 联邦学习是一种能够在不泄露隐私、保持数据分散的前提下协同训练机器学习模型。现有的联邦学习工作主要针对模型同构的情况，并取得了巨大的成功，但它严重依赖于所有参与者共享相同的网络结构和拥有相似的数据分布的假设。然而在实际的大规模场景中，数据分布、模型结构、通信网络和系统边缘设备之间可能存在较大差异，这给实现联邦协同带来了挑战。与这些情况相关的联邦学习称为异构联邦学习，其中这种异构可以根据联邦学习过程分为四类：统计异构、模型异构、通信异构和设备异构。
图1 异构联邦学习
本综述论文深入研究了联邦通信中的统计异构和模型异构问题，关注了隐私保护和存储计算能力在异构联邦学习中的重要性。本文由三个主要部分构成：
首先，对研究挑战进行了系统总结，涵盖了五个方面：统计异构、模型异构、通信异构、设备异构和附加挑战。
其次，回顾了目前最先进的方法，并以新的分类法为背景，即将现有的异构联邦学习方法分为数据级、模型级和服务器级三个层次，深入讨论了这些方法的优势和局限。
最后，对未解决问题和未来发展方向进行了深入展望。
图2 论文结构
3.异构联邦学习研究挑战讨论 3.1统计异构性 统计异质性是指联邦学习中客户端之间的数据分布不一致，不服从相同的采样，即非独立同分布（Non-IID）。为了探索统计异质性，我们通过四种不同的倾斜模式来区分不同类别的Non-IID数据，包括标签倾斜、特征倾斜、质量倾斜和数量倾斜：
图 3 统计异质性
3.2模型异质性 在实际应用中，由于个体需求或商业考虑，客户端可能设计独特的本地模型结构，并且不愿透露模型设计细节。模型异构联邦学习旨在从其他模型中获取知识，而不共享数据或本地模型结构信息。模型异构性存在两种情况：
部分异构性：某些客户端使用相同模型结构，其他客户端使用不同结构。这可以通过将客户端分成结构相同的簇来处理，同一簇内的模型可以直接聚合，而不同簇之间的模型通信需要特殊技术，如知识蒸馏。
完全异构性：每个客户端的网络结构完全不同。在这种情况下，需要为每个客户端设计独特的模型，这可能会导致高的学习成本和低的通信效率，因为无法进行常规的参数聚合或梯度操作。
3.3通信异构性 在实际物联网应用中，设备通常部署在不同的网络环境中，具有不同的网络连接设置（3G、4G、5G、Wi-Fi），这导致了不一致的通信带宽、延迟和可靠性，即通信异构性。在通信过程中，客户端可能会遇到不同程度的噪声、延迟或丢失，这严重降低了通信效率。通信异构性在复杂的物联网环境中非常普遍，可能导致高成本和低效率的通信，从而降低联邦学习的效果。因此，如何在异构网络环境中自适应调整联邦通信值得研究。
3.4设备异构性 在实际应用中，联邦学习网络可能涉及大量的物联网设备。设备硬件能力（CPU、内存、电池寿命）的差异可能导致存储和计算能力不同，这不可避免地产生设备异构性。设备异构性对联邦学习构成了以下几个挑战。首先，因为不同的客户端可能具有不同的计算速度或资源，导致系统滞后或瓶颈。其次，它为系统引入了不确定性和不稳定性，因为不同的客户端可能具有不同的设备状态。因此这需要在大规模联邦学习场景中对不同设备的反馈进行自适应调整。
3.5额外挑战 除了上述异构性，本文还讨论了异构联邦学习中的一些额外挑战，包括知识传递障碍和隐私泄露：
知识传递障碍：联邦学习的目标是在不同客户端之间传递知识，以共同学习具有优越性能的模型。然而，上述异构性特征在不同程度上导致了知识传递障碍。因此，如何在异构场景中实现高效的知识传递是当前研究需要关注的问题。
隐私泄露：保护客户端的本地数据不泄露是联邦学习的基本原则。然而，单独的联邦学习仍存在潜在的隐私风险或对数据隐私的攻击。此外，上述四种类型的异构性在不同的学习阶段不可避免地加剧了隐私泄露。例如，当客户端通过共享模型梯度更新、逻辑输出等来实现联邦学习时，攻击者可以通过将恶意数据或模型注入系统，或分析其模型梯度来推断客户端的私人信息。
4.异构联邦学习进展综述 本节回顾了现有的异构联邦学习方法，将它们分为三个部分，即数据层面、模型层面和服务器层面方法：数据层面方法是指在数据层面上平滑本地数据的异构性或提高数据隐私的操作，如数据增强和匿名技术。模型层面方法是指在模型设计的操作，如共享局部结构、模型优化等。服务器层面方法需要服务器参与，例如参与客户端选择或客户端集群。
图 4 异构联邦学习方法分类
4.1数据层面 4.1.1私有数据处理 图5 私有数据处理方法
数据准备：联邦学习中的私有数据准备包括数据收集、过滤、清理、增强等。这些操作旨在确保每个客户端的数据质量和安全性，从而提高联邦学习的效率和效果。例如Safe方法，对本地数据进行聚类，然后测量每个样本与其聚类中心之间的距离，最后将远离聚类中心的样本作为有毒数据过滤并丢弃；FAug是一种使用GAN的数据增强方案，客户端将目标标签的部分数据样本上传到服务器端，服务器端对上传的数据样本进行过采样以训练条件GAN。客户端通过使用接收到的GAN生成缺失数据样本，有效地增强了本地数据的统计同质性。
数据隐私保护：为了防止商业加密和用户隐私等敏感信息泄漏，人们在本地级别研究了数据隐私保护方法，主要有三种：数据加密、扰动和匿名化。1）数据加密：Asad等人将同态加密应用于联邦学习，使客户端能够使用私钥加密其本地模型，然后将其发送给服务器。因此，服务器只能获得加密的模型参数，无法推断出任何私有信息。2）数据扰动：差分隐私（DP）是常用的方法，通过对本地更新进行剪辑和添加噪声，以保护客户端的私密信息。PLDP-PFL方法允许每个客户根据其隐私数据的敏感性选择适当的隐私预算来实现个性化的差异隐私。3）数据匿名化：通过删除或替换可识别敏感信息，实现对数据主体的匿名化。Choudhury等人让客户端将本地数据集的特征转换成一些随机的数字或符号，从而使原始数据脱敏。
4.1.2外部数据利用 图6 外部数据利用方法
知识蒸馏：这种方法利用来自外部数据源的知识来提升联邦性能。客户端为本地数据生成软标签，然后将这些软标签用作本地更新的额外监督。这种方法使得具有异构模型的客户端能够以一种模型不可知的方式共享信息，从而减轻模型异质性的影响。FAug 和FedMD 利用联邦蒸馏，从其他客户那里学习知识，每个客户端存储一个本地模型输出,并将所有客户端本地模型输出的平均值作为全局输出。FSMAFL采用类似于FedMD的联邦通信策略，并创新性地添加了一个潜在嵌入自适应模块，缓解了公开数据集和私有数据集之间较大的域差距的影响。
无监督表示学习：由于私有数据通常难以标注且涉及高昂成本，无监督表示学习被讨论用于学习通用的表示模型，同时保持私有数据的分散性和无标签性。这种方法通过利用对比损失等技术，在各个客户端之间实现数据分布的一致性和表示的一致性。它允许客户端生成本地字典，并将这些字典整合成全局字典，从而实现模型的统一性，减轻统计异质性的影响。例如MOON和FedProc 使用对比学习来解决联邦学习中的统计异质性。MOON通过引入模型对比损失来纠正更新方向。FedProc将全局原型视为全局知识，使用局部网络结构和全局原型对比损失来约束局部模型的训练。
4.2模型层面 4.2.1联邦优化 图7 联邦优化方法
正则化：正则化是一种通过在损失函数中添加惩罚项来防止过拟合的技术。该策略通过动态估计参数值来降低模型复杂性，并通过添加偏差项来减少方差。因此，在统计异质性下，许多联邦学习框架实现正则化以在学习过程中提供收敛保证。例如FedProx 在FedAvg 的基础上增加了一个近端项，约束局部模型与全局模型之间的差异，从而有效地增加模型训练的稳定性，加速模型收敛；FPL方法使样本嵌入更接近同一领域和类别的聚类原型。同时，引入一致性正则化，以使样本嵌入与不包含域信息的同质无偏原型对齐。
元学习：利用以前的经验指导新任务的学习，从而使机器能够自主地为不同任务学习模型。在新任务上进行训练时，只需在初始模型上进行微调即可实现仅使用少量数据的满意学习性能。元学习的个性化能力可以解决联邦学习中的统计异质性问题。例如联邦元学习框架FedMeta，在服务器端维护算法并分发到客户端进行训练，之后将查询集上的测试结果上传到服务器进行算法更新。
多任务学习：通过使用共享表征或模型来帮助在单个任务上学习的模型实现其他任务的共同学习。如果将每个客户端的本地模型学习视为单独的任务，则可以将多任务学习的思想应用于解决联邦学习问题。所有参与的客户端协同训练其本地模型，从而有效地减轻统计异质性，并产生高性能的个性化本地模型。MOCHA 是一个面向联邦多任务学习（FMTL）的系统感知优化框架，试图解决分布式多任务学习的高通信成本、掉线和容错性问题。为了解决统计异构性和系统挑战，MOCHA采用分布式优化方法COCOA，并为每个客户训练一个独特的模型。
4.2.2跨模型知识迁移 图8 跨模型知识迁移方法
跨模型知识蒸馏：其目标是在客户端上精炼知识分布，然后以模型无关的方式传递所学知识，有助于在联邦学习中实现不同模型之间的合作和知识传递。例如，为了在不依赖全局共识或共享公共模型的情况下使用异构客户机执行联邦学习，RHFL 通过对齐模型对无关公共数据的反馈来学习其他客户机的知识分布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83273adc086959ea459714f949137b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69227552c55ac386779701c30080f37d/" rel="bookmark">
			如何解决VScode远程下载插件不了的问题？如何手动安装插件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在使用VScode进行远程操作时，在安装我们所需要的一些插件时，可能会出现如下图，一直卡在安装中....明明只有小几十MB，却一连好几个小时都一动不动。像这种情况，就需要我们进行手动安装该插件。
插件网站：
方法一： 插件下载地址（1）：点击
方法二：在VScode的插件下载页面点击市场，也可跳转。
插件下载：
进入网页后，搜索要下载的插件，比如我要下载的C/C++ Extension Pack
找到后点进去，稍微往下面翻一点点，然后在右侧有一个download，点击就可以进行下载。
下载完成后，通过Xshell脚本将文件上传到linux上，在xshell命令行中输入 rz 可以从本地传文件到linux中。
点击打开，文件就会上传：
上传完成后，输入 ll 命令就可以看见我们上传的文件
插件安装：
接下来打开VScode，登录上远程服务端，点击扩展，然后点插件列表右上角的三个小点... ，再选择从VSIX安装。
然后找到刚才下载的插件位置，选择再确认就可以了。
插件安装后可以通过扩展--&gt;ssh查看已安装的插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cabac1bf36ea501f77b9ee5df0b07974/" rel="bookmark">
			SystemUI下拉通知菜单栏定时自动隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在系统应用开发过程中，常常遇到一些特殊的需求，Android原生的应用并无此适配，此时需要对系统应用进行定制化开发。
目前遇到的这样一个需求：下拉通知菜单栏时，定时8秒后自动关闭通知菜单栏。通知菜单栏为SytstemUI中的一个特殊窗口，原车系统不支持自动关闭。
开发 下拉菜单自动隐藏逻辑
在原生NotificationPanelView类中，增加了下拉菜单展开回调：
以及下拉菜单收起回调：
同时增加触摸回调，触摸时再次更新延时退出：
StatusBar类注册监听处理收起逻辑：
下拉菜单与系统弹框的互斥逻辑
PanelBar类的触摸事件onTouchEvent()回调中，通过发送系统CLOSE_SYSTEM_DIALOGS广播通知其他应用隐藏显示的弹框。自定义界面加载
在StatusBar类中createAndAddWindows()初始化自定义的systemui view的状态栏和下拉菜单控制器，createNavigationBar()初始化导航栏的控制器。
WindowHelper承载着systemui view的初始化操作以及与原生SystemUI的交互操作，setPanelControl()为控制下拉菜单展开收起的方法，其中外部可通过此方法来控制下拉菜单展开和收起，例如语音和方控控制展开和收起。 总结 通过对原车SystemUI的定制化开发，扩展不同需求，从而不影响原车SystemUI功能，定时自动隐藏下拉通知菜单栏开发难度不到，需要修改的地方也不是很多，可以稳定兼容原车SystemUI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e457d72927c4322300f9659a812bb06/" rel="bookmark">
			海外地区开启IPV6无法访问服务器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近有海外地区的用户反馈无法访问公司的网络，无法下载应用和系统进行升级。了解到浏览器可以正常访问公司域名，谷歌，油管等都能正常使用。日志分析GET请求服务器数据时没有得到应答，最终查询网络相关修改确认与网络IPV6有关。
先来看下全球主流网站IPv6的支持情况：
具体可查看这篇文章：https://zhuanlan.zhihu.com/p/605189137?utm_id=0
可以看到全球主流大公司很多未支持IPv6网络，国内阿里、腾讯也是部分支持并未全部支持，而360、百度、淘宝、CSDN等网站都不支持IPv6。
不止要考虑网站的IPv6的支持，还要考虑电信业务商是否支持IPv6。像台湾有些电信业务商，支持IPv6网络，例如台湾之星、中华电信，且在4G和5G的支持情况也不一致。
IPv6的可达性测试 在测试IPv6的可达性网址https://en.internet.nl/ 测试 www.czvv.com 网址结果如下，提示IPv6不可达。
同样测试国内百度www.baidu.com 和 www.tecent.com 也是IPv6不可达。
测试支付宝www.alipay.com 谷歌www.google.com 或者 www.youtube.com 等都是IPv6可达的。
总的来说国内IPv6的普及率不高，很多网址都是IPv6不可达。
问题分析 湾湾和阿三等地区用户都反馈了无法进行在线检查升级，一直在等待服务器应当。湾湾用户反馈使用台湾之星的手机卡不能检测升级，而换另一张非台湾之星的手机卡可以检测升级，之前系统未升级时可以正常访问网络的。通过查证得知系统添加修改了DNS对IPv6的支持，因此可知系统支持IPv6后无法正常从公司服务器获取数据。系统支持IPv6后会优先使用IPv6的地址进行访问。
为了进一步去除IPv6的影响，让湾湾用户在手机上关闭了IPv6的支持，只使用IPv4。结果关掉IPv6后即可以正常检测升级了。
从抓取的日志看到开启IPv6的情况下，请求www.czvv.com 获取信息时一直未收到服务器应答，显示www.czvv.com 使用IPv6的地址不可达。
解决方案 由于IPv6地址不可达，因此需要对DNS进行过滤，滤除IPv6地址。
OkHttpClient支持设置自定义DNS，于是在网络框架初始化时配置OkHttpClient，并添加自定义的DNS过滤器。
DnsFilter代码如下：
import androidx.annotation.NonNull; import com.czvv.base.utils.ALog; import com.czvv.mycar.util.ShareDb; import okhttp3.Dns; import java.net.Inet4Address; import java.net.Inet6Address; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.List; public class DnsFilter implements Dns { public DnsFilter() { } @NonNull @Override public List&lt;InetAddress&gt; lookup(@NonNull String hostname){ List&lt;InetAddress&gt; addresses = new ArrayList&lt;&gt;(); try { List&lt;InetAddress&gt; list = Dns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e457d72927c4322300f9659a812bb06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e43394b9f3c98d91f797a5171f5a226/" rel="bookmark">
			1 函数列的一致收敛性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本文链接1. 什么叫函数列 本文链接 函数列的一致收敛性 1. 什么叫函数列 你肯定知道什么叫数列，这个高中生都知道的！数列中的每一项都是个数字啊，那函数列中的每一项是啥呢？函数列中的每一项都是个函数啊！比如下面的东西就是个函数列 x , x 2 , x 3 , . . . , x n , . . . x, x^2, x^3,...,x^n,... x,x2,x3,...,xn,...
sin ⁡ y , sin ⁡ y 2 , sin ⁡ y 3 , . . . , sin ⁡ y n , . . . \sin y, \sin y^2, \sin y^3,...,\sin y^n,... siny,siny2,siny3,...,sinyn,...
不过上面写成那样不好看，一般都简写成 { x n } \{x^n\} {xn}, { sin ⁡ y n } \{\sin y^n\} {sinyn}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e43394b9f3c98d91f797a5171f5a226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71ffeacdcd0420e429e83b77b41eae9/" rel="bookmark">
			pyhon防反编译之用pyinstaller加pyarmor实现双重安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyhon防反编译之用pyinstaller加pyarmor实现双重安全 最近有个项目由于是做的桌面客户端需要分发，所有有了代码安全需求， 关于安全没有绝对的，只是提高下代码的安全，增加些反编译的难度
经过调研最终决定使用方案： pyinstaller打包+pyarmore代码加密方案
PyArmor Pyarmor 是一个用于加密和保护 Python 脚本的工具。它能够在运行时刻保护 Python 脚本代码不被泄露，设置加密后脚本的使用期限，绑定加密脚本到硬盘、网卡等硬件设备。
以下是PyArmor的一些主要特点和功能：
无缝替换: 加密后的脚本依然是一个有效的 .py 文件，在大多数情况下可以直接替换原来的 .py 脚本，而不影响脚本的使用。均衡加密: 提供了丰富的加密选项来平衡安全性和性能，能够满足大多数应用对安全性和性能的要求。不可逆加密: 能够直接重命名源代码中的函数，类，方法，变量和参数。转换成为 C 代码: 能够把模块中部分函数转换成为 C 代码，然后使用高优化选项直接编译 C 代码为机器指令来保护 Python 函数限制加密脚本的使用范围: 可以绑定加密脚本到指定的设备或者设置加密脚本的有效期Themida 保护: 使用 Themida 保护加密脚本（仅 Windows 平台可用） PyArmor文档
PyInstaller PyInstaller是一个用于将Python应用程序打包成可执行文件的工具。它可以将Python代码和其依赖项打包成一个独立的可执行文件，使得你可以在没有安装Python解释器的环境中运行你的应用程序
PyInstaller文档
运行环境 python3.12pyinstaller 6.2.0pyarmor 8.4.4 代码加密 因为项目是有很多文件与包组成的，当时我按教程中命令去加密文件
pyarmor gen -O build/srv -r 代码目录 加密后去运行一直报这个错误，
from .pyarmor_runtime_000000 import __pyarmor__ ImportError: attempted relative import with no known parent package 因为这个路径from .pyarmor_runtime_000000中的引用包问题，这个.去掉就好了，但我试了很多方式，命令都没有去掉这个. 当时总想用一条命令搞定，呵呵
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71ffeacdcd0420e429e83b77b41eae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2535ba5d1261dc9578246cc352e41ca1/" rel="bookmark">
			基于hadoop&#43;hive的全国天气大数据可视化平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【大数据分析毕设之S2023102基于Hadoop+hive的全国天气大数据分析可视化平台（hive+sqoop+hdfs+E chart）】 https://www.bilibili.com/video/BV1224y1c7eB/?share_source=copy_web&amp;vd_source=3d18b0a7b9486f50fe7f4dea4c24e2a4
http://www.bilibili.com/video/BV1224y1c7eB/?share_source=copy_web&amp;vd_source=3d18b0a7b9486f50fe7f4dea4c24e2a4
随着云计算和物联网的发展，大数据已经成为当今社会必不可少的技术。气象服务的发展，以及气象数据量的快速增长，促使大数据技术在气象服务中发挥着举足轻重的作用，大数据的应用将为气象科学的不断发展提供新的思路和方法。
本文对基础的天气数据信息，进行采集和分析显得尤为必要。我们的气象数据分析系统是以Hadoop的Mapreduce为基础的，前端采用swing编写，后台使用Hadoop集群，数据库使用MySQL，天气数据信息采集与分析，以天气网（www.tianqi.com）为数据源，通过网页爬虫技术，分析网页结构，获取天气数据信息，并存储。然后，通过天气等级划分标准，将文本描述的天气信息量化成天气等级信息。最后，在地图上可视化显示，通过对比分析很容易发现异常点和天气数据信息呈现的规律性信息。
关键词：天气数据；气象数据；大数据分析；Hadoop；可视化
Abstract With the development of cloud computing and the Internet of Things, big data has become an essential technology in today's society.The development of meteorological services, as well as the rapid growth of meteorological data volume, promotes big data technology to play an important role in meteorological services. The application of big data will provide new ideas and methods for the continuous development of meteorological science.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2535ba5d1261dc9578246cc352e41ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689c6a2775eced8fcfd402ca78590f71/" rel="bookmark">
			【Android】广播BroadcastReceiver、接收系统广播（动态、静态注册方式）、发送自定义广播（发送有序广播、发送标准广播）、BroadcastReceiver实践——强制下线功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接收系统广播 1、动态注册监听网络 1.需要一个过滤器
2.需要一个广播接收器
3.进行注册
4.取消注册
主要操作：使用registerReceiver接受两个参数，一个是广播接收器BroadcastReceiver，一个是意图IntentFiler。现在注册完成，广播接收器就可以实现接受指定意图的广播.
最后需要记得对于动态注册的广播接收器一定要取消注册，我们在onDestroy()中通过调用unregisterReceiver取消注册。传递的参数为：BroadcastReceiver
public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; BroadcastReceiver NetwordChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); NetwordChangeReceiver = new NetwordChangeReceiver(); registerReceiver(NetwordChangeReceiver,intentFilter); } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(NetwordChangeReceiver); } class NetwordChangeReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { /** 制作一个网络管理器 * 它用于获取当前设备的网络连接状态信息。通过getSystemService方法，可以从系统服务中获取ConnectivityManager的实例。 */ ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); /** * 使用网络工具类，从网络管理器中获取一个网络工具，这个工具有网络管理器的指定信息Context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/689c6a2775eced8fcfd402ca78590f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b54d127fd50a89a2be542a6e8cf6c77/" rel="bookmark">
			使用IDM批量下载NASA气象数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面:因为科研需要，所以需要批量下载NASA数据，但是nasa的文件会每天给一个url链接，手动下载起来很慢，所以特写此篇文章用以教学如何批量下载NASA气象数据 1.下载NASA数据: 首先我们先进入到官网：
官网链接
右上角进行登录:
登录上之后选择我们要下载的数据:
进入数据库之后选择我们所需要下载的参数:
然后我们选择获取数据链接:
可以看到我们已经获得了一堆nc文件的url，我们点击相对应的url就可以进行数据的下载，一天对应一个文件，但是手动下载起来很慢。我们选择点击Download Links List。然后我们获得了一个拥有url地址的txt文件。
2.下载IDM IDM我们直接进入官网进行下载即可。官网下载链接
点击下载链接获得exe文件
然后我们进行一步一步的安装。
注意这一步的下载目标文件夹不要进行更改，如果更换了文件夹的话可能在使用过程中会报错
然后我们就获得了IDM文件
3.IDM的破解 官网破解方式网站，如果图省便的话可以直接看题主的教程。
首先我们打开Windows的PowerShell(注意是PowerShell而不是cmd，使用cmd会出现找不到命令的问题)
在里面输入以下命令:
iwr -useb https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS.ps1 | iex 点击回车后可以看到如下页面:
输入键盘上的1
然后会让你输入一个用户名，表示你想用什么用户名来注册，这里我们随便使用一个名称即可。输入完成按回车
打开IDM可以看到我们的软件已经激活完成了。
4.使用IDM批量下载NASA数据 打开IDM软件
打开任务-&gt;导入-&gt;从文本文件导入。选择之前在NASA下载的txt文件
等待文件的解析，也就是等HTTP文件的名称变成原始的文件名，因为如果不是原始文件名称的话，在下载的时候会发生报错
解析完成后选择确认并勾选开始执行队列
即可完成数据的下载：
如果数据要求输入密码，则可以ctrl+a全选数据。然后右键属性，在属性里面输入NASA账号的账号和密码
在这里面输入NASA账号的用户名和密码即可。
注意事项:可能用一段时间会发现软件又处于未激活状态，再使用一次题主所使用的方法即可以重新完成激活。 码字不易，点个赞再走吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc179c726230dbda490fabc59f6f1b90/" rel="bookmark">
			数据结构实验题（寻找大富翁）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 胡润研究院的调查显示，截至2017年底，中国个人资产超过1亿元的高净值人群达15万人。假设给出N个人的个人资产值，请快速找出资产排前M位的大富翁。
输入格式: 输入首先给出两个正整数N（≤106）和M（≤10），其中N为总人数，M为需要找出的大富翁数；接下来一行给出N个人的个人资产值，以百万元为单位，为不超过长整型范围的整数。数字间以空格分隔。
输出格式: 在一行内按非递增顺序输出资产排前M位的大富翁的个人资产值。数字间以空格分隔，但结尾不得有多余空格。
输入样例: 8 3 8 12 7 3 20 9 5 18 输出样例: 20 18 12 答案：
#include&lt;stdio.h&gt; int main() { int n,m,i,j,t=0; long long int s[1000001]; scanf("%d%d",&amp;n,&amp;m); for(i=0; i&lt;n; ++i) { scanf("%lld",&amp;s[i]); } for(j=0; j&lt;m; ++j)//双重循环冒泡排序 { if(n&lt;m)//考虑n&lt;m的情况，令大等于小 m=n; for(i=n-1; i&gt;=j+1; --i)//内循环从尾开始往前遍历，将最大数逐个换到最前面并输出 //从头开始遍历也可以，将最大数逐个存在最后并输出 { if(s[i]&gt;s[i-1]) { t=s[i-1]; s[i-1]=s[i]; s[i]=t; } } if(j!=0) printf(" ");//保证数字间以空格分隔但结尾无多余空格 printf("%lld",s[j]); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c4dbc860acf19d2532e0db76f63320/" rel="bookmark">
			已解决 debug: segmentation fault when importing datasets
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		debug: segmentation fault when importing datasets - 菜本菜 - Medium
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53d36eb23500306a707ae7323322582/" rel="bookmark">
			数据结构实验题（整型关键字的散列映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一系列整型关键字和素数P，用除留余数法定义的散列函数H(Key)=Key将关键字映射到长度为P的散列表中。用线性探测法解决冲突。
输入格式: 输入第一行首先给出两个正整数N（≤1000）和P（≥N的最小素数），分别为待插入的关键字总数、以及散列表的长度。第二行给出N个整型关键字。数字间以空格分隔。
输出格式: 在一行内输出每个整型关键字在散列表中的位置。数字间以空格分隔，但行末尾不得有多余空格。
输入样例: 4 5 24 15 61 88 输出样例: 4 0 1 3 答案：
#include&lt;stdio.h&gt; int main() { int n,p,i,m,k; int a[500000]={0};//数组开大，防止p过大时数组空间不够 scanf("%d%d",&amp;n,&amp;p); for(i=0; i&lt;n; ++i) { scanf("%d",&amp;k); m=k%p;//除留余数法 while(a[m]!=0&amp;&amp;a[m]!=k)//线性探测法解决冲突且考虑重复关键字情况 { m=(m+1)%p;//线性探测法，当空间被占时环形向后寻找空的 } if(i!=0) printf(" ");//保证数字间以空格分隔，但行末尾无多余空格 printf("%d",m); a[m]=k;//标记空间 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2898bcee5d15396d28de6d22acc36247/" rel="bookmark">
			【EI会议征稿】第五届人工智能、网络与信息技术国际学术会议（AINIT 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五届人工智能、网络与信息技术国际学术会议（AINIT 2024）
2024 5th International Seminar on Artificial Intelligence, Networking and Information Technology (AINIT 2024)
第五届人工智能、网络与信息技术国际学术会议（AINIT 2024）将于2024年3月22-24日在中国南京举行。本届会议将主要关注人工智能、网络与信息技术面临的新的挑战问题和研究方向，着力反映国际人工智能、网络与信息技术相关技术研究的最新进展。大会届时还将邀请国内外相关领域知名学者到会作报告，与各与会者共同分享交流各领域的前沿研究成果，展开一场思想的碰撞。
重要信息
会议官网： www.ainit.org（点击了解参会/投稿）
时间地点：2024年3月22-24日|中国·南京
接收/拒稿：
主办单位 征稿主题
人工智能算法 自然语言处理
模糊逻辑
计算机视觉与图像理解
信号和图像处理
语音与自然语言处理
计算学习理论
信息检索与融合
混合智能系统
智能系统架构
知识表示
基于知识的系统
机电一体化
人工神经网络并行处理 模式识别
普适计算与环境智能
软计算理论与应用
软硬件架构
自动编程
机器学习
自动控制
数据挖掘与机器学习工具
机器人学
人工智能工具与应用
最近的趋势和发展
多媒体与认知信息学
人工智能与计算智能 理论与算法
机器学习/强化学习
VLSI与计算机体系结构
数据库系统
多媒体数据库与信息检索
多媒体应用
通信系统
程序设计语言和软件系统
计算机网络与分布式系统
大规模网络
计算机体系结构与嵌入式系统
计算机视觉与信息可视化
模式识别、机器学习和数据挖掘
计算机辅助设计/制造
信号和图像处理
计算机教育
电子系统设计
计算机建模
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2898bcee5d15396d28de6d22acc36247/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/91/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>