<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b54e4c58a6eceee0c16409a43d8d34c/" rel="bookmark">
			渗透——目录扫描神器DirBuster用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、渗透测试的简介： 渗透测试可以使用不同的方法进行，成为黑、灰和白盒。黑盒是指测试团队除了服务器的URL外，没有关于要测试的应用程序的任何以前的信息；白盒表示团队拥有目标、基础架构、软件版本、测试用户、开发信息等所有信息；灰盒是介于黑盒和白盒中之间的一个点。对于黑盒方法和灰盒方法，正如我们在上一章中看到的那样，侦察阶段对于测试团队发现应用程序所有者可以在白盒方法中提供的信息是必要的。继续进行web渗透测试中的侦察阶段，我们需要浏览web页面中包含的每个链接，并记录它所显示的每个文件。有一些工具可以帮助我们自动化和加速这项任务;它们被称为网络爬虫或网络蜘蛛。这些工具根据外部文件的所有链接和引用浏览web页面，有时填写表单并将其发送到服务器，保存所有请求和响应，并为我们提供脱机分析它们的机会。 二、WEB 模糊测试工具dirbuster的使用方法 扫描Web目录，可以发现潜在的渗透目标。不同于网站爬虫，使用字典方式可以发现网站没有关联的网页。Kali Linux提供一款基于字典的Web目录扫描工具DIRB。该工具根据用户提供的字典，对目标网站目录进行暴力猜测。它会尝试以递归方式进行爆破，以发现更多的路径。同时，该工具支持代理、HTTP认证扫描限制访问的网站。该工具还提供两个命令，帮助用户从网页生成字典，或者生成定制字典。DirBuster是一个多线程的基于Java的应用程序设计蛮力Web /应用服务器上的目录和文件名 。 （一）方法和步骤： 1、下载DirBuster最新版本，本文Version 1.0-RC1，解压后windows双击DirBuster-1.0-RC1.jar或DirBuster-1.0-RC1.bat启动软件（Linux用户在命令行运行./DirBuster-1.0-RC1.sh,若脚本无执行权限使用chmod + x ./DirBuster-1.0-RC1.sh添加权限），或者直接在kali中打开自带的DirBuster（命令：root@kali:~# dirbuster）。 2、启动DirBuser后，主界面如下： 或者如下如标注：
注意：
如果你扫描的目标是http://www.xxx.com/admin/，那么就要在URL to fuzz里填写"/admin/{dir}",意思是在"{dir}“的前后可以随意拼接你想要的目录或者后缀，例如输入”: /admin/{dir}.php"就表示扫描admin目录下的所有php文件。
具体步骤简介如下：
准备工作：
我们要使用一个文本文件，其中包含我们要用DirBuster来查找的文件列表。
创建一个包含以下内容的文本文件dir_dictionary.txt
具体实施：
1．找到Applications |03-Web Application Analysis | Web Crawlers＆DirectoryBruteforcing | Dirbuster.(注：我的Kali按照这个路径就没找到，但是你可以在终端下输入 dirbuster 打开这个软件)；
2．在DirBuster窗口中，将目标URL设置为http://192.168.56.11/.
3．将线程数设置为20，以获得不错的测试速度。
4．选择基于列表的暴力破解，然后单击“浏览”。
5．在浏览窗口中，选择我们刚刚创建的文件（dir_dirtionary.txt）
6．取消选中Be Recursive选项.
7．对于这个配置，我们将其余选项保留为默认值：
3、配置完成后，点击开始： 8.点击开始；
9.如果我们转到结果选项卡，我们将看到DirBuster在我们的字典中找到了至少两个文件：cgi-bin和phpmyadmin. 响应码200表示文件或目录存在并且可以被读取。Phpmyadmin是一个基于Web的mysql数据库; 查找一个带有tis名称的目录告诉我们服务器中有一个数据库管理系统（DBMS），它可能包含有关应用程序及其用户的相关信息：
4、最后的结果鉴定： Dirbuster是一种履带式和粗暴式的混合物; 它遵循它找到的页面中的所有链接，但也为可能的文件尝试不同的名称。这些名称可能位于与我们使用的文件类似的文件中，也可能由Dirbuster使用Pure Brute Force选项自动生成，并设置字符集以及生成的单词的最小和最大长度。
为确定文件是否存在，DirBuster使用服务器的响应代码。最常见的响应如下所示：
200 ok：文件存在；404找不到404文件：服务器中不存在该文件；301 301永久移动：这是重定向到给定的URL；401 Unauthorized:访问此文件需要身份验证；403 Forbidden：请求有效但服务器拒绝响应。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04649b109a478ec7f47078e960f7e594/" rel="bookmark">
			mysql 添加时间自动添加更新时间自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库使用中经常使用到时间字段。常用的有创建时间和更新时间。然而在使用中想要创建时间在创建的时候自动设置为当前时间，更新时间在更新时自动更新为当前时间。
创建表 stu
CREATE TABLE `stu` ( 'id' int NOT NULL AUTO_INCREMENT, 'createTime' timestamp DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', 'moditiyTime' timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY ('id')); 创建的时候设置当前时间 DEFAULT CURRENT_TIMESTAMP
更新的时候设置更新时间为当前时间 DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
转载于:https://www.cnblogs.com/zhaopengcheng/p/11597438.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e83c1d049536b2d67ef8ffc90fce9f/" rel="bookmark">
			VUE动态生成 watch 侦听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有需求对筛选器中指定参数做参数联动，需要侦听指定参数变化，因为参数联动关系是用户指定的，那么 VUE 的 watch 就不能写死了，得根据某个数据列表生成。
于是就有了这篇文章的产生。
1、问题 watch 需要动态生成
2、解决思路 创建一个全局变量用于存放 watch 列表循环生成函数对象将函数对象添加到 watch 列表 3、直接上代码 // 参数 var params = ["Param1":"hello", "Param2":[1,2,3], "Param3":{"text":"DMLK"}]; // 需要开启监听的列表 var linkparam = ["Param1", "Param3"] // 创建一个全局变量用于存放 watch 列表 var linkWatch = {}; var app = new Vue({ el: '#app', data: params, beforeCreate() { // ParamLink if(linkparam.length &gt; 0){ for(var key in linkparam){ // 解除key的引用 let tkey = key linkWatch[tKey] = function(newVal, oldVal){ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69e83c1d049536b2d67ef8ffc90fce9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2112c0a60f3de612883de7115b37fec/" rel="bookmark">
			dataTable与DataTable获取行数据,上传文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zlscTable = $('#lxzlTable').dataTable({ destroy: true, serverSide: true, responsive: true, processing:true, autoWidth: true,//自动计算列宽 deferRender: true,//设置延迟渲染，提高效率用 draw:false, searching : false, bLengthChange: false, order: [ 0, 'asc' ], ajax: { url: "sjxm2/getLxzlInfoData", type: "POST", data : function(d) { var sentJson = GET_SENT_JSON(d); sentJson.search1 = sjxmglArr[0].xmfldm.split('/')[0]; sentJson.search2 = sjxmglArr[0].sjxmdm; return sentJson; }, error: function (e) { ALERT_ERROR(zlscTable,e); }, }, lengthMenu: PAGELENGTH, "language": LANGUAGESETTING, columnDefs : [ { "targets": 0 ,"name":"wdlx","title": "文档类型" ,"width": "10%" }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2112c0a60f3de612883de7115b37fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb1aa11bb0be1ab8878eec0cfd4585f/" rel="bookmark">
			iSlider 如丝般高性能H5全屏滑动组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iSlider 如丝般高性能H5全屏滑动组件
简洁, 易用, 半行代码搞定.性能卓越, 如丝般高性能全屏动画滑屏组件.耦合完全分离, 更轻量, 无CSS依赖,无任何js库依赖.一个组件只做一个事情, 专注于页面滑动, 避免冗余 , 保证性能. http://kele527.github.io/iSlider/
转载于:https://www.cnblogs.com/2019gdiceboy/p/11592447.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b219a7633bf6814c6cff336f78a6aef2/" rel="bookmark">
			server监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 监听客户端的请求和服务器端的操作通过实现Listener接口的类可以在特定事件（Event）发生时，自动激发一些操作 监听登陆人数代码实现 首先要实现HttpSessionAttributeListener接口 @WebListener public class OnlineListener implements HttpSessionAttributeListener { } 当登录用户的session发生增加时，人数加1 @Override public void attributeAdded(HttpSessionBindingEvent se) { System.out.println("OnlineListener.attributeAdded"); String name = se.getName(); //System.out.println("name = " + name); //登录用户的session发生变化 if("account".equals(name)){ ServletContext application = se.getSession().getServletContext(); int online_num = application.getAttribute("online_num") == null ? 0 : (Integer) application.getAttribute("online_num"); System.out.println("online_num = " + online_num); online_num++; application.setAttribute("online_num",online_num); } } 当登录用户的session发生减少时，人数减1 @Override public void attributeRemoved(HttpSessionBindingEvent se) { System.out.println("OnlineListener.attributeRemoved"); String name = se.getName(); //退出 用户的session发生变化 if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b219a7633bf6814c6cff336f78a6aef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a06dc687a93f767b8f37123cfbf003/" rel="bookmark">
			一篇介绍SSD的特别好的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/xuanyuyt/p/7222867.html#_label4
转载于:https://www.cnblogs.com/cumtchw/p/11586776.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9d02b9148477cebad4f8678c9ba95f/" rel="bookmark">
			idea 打包Spring boot项目，解决检查数据库连接导致无法打包的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea 右侧--&gt;Maven--&gt;点击蓝色的闪电按钮
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d53252710be7c8eaa2ddf4a715751f/" rel="bookmark">
			idea sql 检查配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会进行sql语法检查
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c45df084425b6074ff91f4ea7f201d3/" rel="bookmark">
			在centos7中部署前后端项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）后端
1）将项目打成jar包，复制到centos中并运行
[root@localhost project]# java -jar cop-admin-service-1.0.0-SNAPSHOT.jar
（2）前端
1）打包
npm run build
2）将dist文件夹复制到centos中
3）修改nginx配置文件，在nginx安装目录下找到nginx.conf文件，修改nginx.conf
[root@localhost conf]# vi nginx.conf
新建server节点
server { listen 8001; server_name localhost; location /cop-sx/ { alias /usr/local/project/dist/; index index.html index.htm; }	location /cop-sx/rest/ { proxy_pass http://localhost:23009; } location /static/ { root /usr/local/project/dist/; } } 4）检查配置文件是否正确
[root@localhost conf]# whereis nginx
nginx: /usr/sbin/nginx /etc/nginx /usr/local/nginx
[root@localhost conf]# cd /usr/sbin/
[root@localhost sbin]# ./nginx -t
5）重新加载nginx配置
[root@localhost sbin]# ./nginx -s reload
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c45df084425b6074ff91f4ea7f201d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f5fdf50ff95b1c62986eb6babce9aa/" rel="bookmark">
			现代通信原理6.2：单边带(SSB)调制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、滤波法产生SSB信号2、相移法产生SSB信号 AM调制和DSB-SC调制都属于双边带调制，因此已调信号带宽为基带信号带宽的两倍。那么，我们有没有可能使得调制之后的信号，带宽与基带信号相同呢？这就是所谓的单边带(single sideband, SSB)调制。如图1所示，DSB-SC信号可以看作是下边带信号(LSSB）与上边带信号(USSB)的叠加。 图1 双边带信号与下边带以及上边带信号 1、滤波法产生SSB信号 那么如何产生SSB信号呢？从图1中不难看出，我们可以采用滤波的方法，从双边带信号中将下边带以及上边带信号分离出来。图(2)中(a)为SSB调制器，其中 h S S B ( t ) h_{\rm SSB}(t) hSSB​(t)可以为下边带滤波器（图b）或者上边带滤波器（图c)，因此单边带信号的波形表达式为
s S S B ( t ) = A c m ( t ) cos ⁡ 2 π f c t ∗ h S S B ( t ) , (1) \tag{1} s_{\rm SSB}(t)=A_cm(t)\cos 2\pi f_ct*h_{\rm SSB}(t), sSSB​(t)=Ac​m(t)cos2πfc​t∗hSSB​(t),(1)其傅立叶变换为
S S S B ( f ) = A c 2 [ M ( f − f c ) + M ( f + f c ) ] H S S B ( f ) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f5fdf50ff95b1c62986eb6babce9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabb1d7ca956c738f4f3b7b7ff2f5826/" rel="bookmark">
			代码整洁之道读书笔记 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 函数的第一条规则：短小。
2 函数应该只做一件事。做好这件事。只做这一件事。
3 每个函数一个抽象层级。函数内部使用的方法应该在同一抽象层。
4 长而具有描述性的名称要比短而令人费解的名称好。长而具有描述性的名称要比描述性的长注释好。
5 如果要对输入参数进行转换，应该将结果反映在返回值上。
6 给函数起一个好名字，能较好的解释函数的意图以及参数的顺序。
7 函数要么做什么事，要么回答什么事。函数应该修改某对象的状态，或是返回该对象的有关信息。
8 转载于:https://www.cnblogs.com/zhaopengcheng/p/11580274.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0023b0fe059e26459d34950fb16415b6/" rel="bookmark">
			一阶低通滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一阶低通滤波 前言：在使用单片机开发中，常常会用到的外设包括ADC采样。而采样必然会伴随这随机干扰引起的毛刺噪声，对于需要捕捉采样值突变的系统来说尤其需要减小毛刺突变的影响。从硬件电路和软件算法上都能一定程度的减少噪声达到滤波的目的，本文主要讲解软件使用低通滤波算法来滤波ADC采样值的方法。
一阶低通滤波（又叫惯性滤波）算法 算法原理 滤波算法公式：
Y(n) = a * X(n) + (1 - a) * Y(n - 1)
Y(n)：本次滤波结果。
a：滤波系数。取值范围为0~1, 值越小越稳定，越大越灵敏。
X(n)：本次采样值。
Y(n - 1)：上次滤波结果。
C代码实现 //一阶低通滤波 #define FO_LOW_PASS_FILTER_SENSITIVE_a 0.8f //一阶低通滤波系数取值范围为(0,1)。值越小越稳定，越大越灵敏，二者难兼顾。 #define FO_LOW_PASS_FILTER_STEADY_a 0.15f //输入Adc采样值，输出低通滤波值 //优点：调节精细，稳定度和灵敏度偏向分明。缺点：带有浮点运算 #define FOLowPassFilter(AdcSample, a) \ { \ g_u16FOLowPassFilterResult = (uint16_t)(a * AdcSample + (1 - a) * g_u16FOLowPassFilterResultL); \ g_u16FOLowPassFilterResultL = g_u16FOLowPassFilterResult; \ } 一阶低通滤波算法特点 1. 相比于硬件滤波，软件滤波节省成本，可靠性高，滤波范围可以由软件任意修改（硬件需要考虑阻抗匹配问题）。 2. 一阶低通滤波运算量小，需要调节的参数少，易于软件实现和单片机快速处理，是实时性强的滤波。 使用一阶低通滤波算法的缺点：
1. 滤波系数越小，滤波结果越稳定，滤波系数越大结果越灵敏。稳定性和灵敏性二者难兼顾。
算法改进 系数a取较小值时（偏稳定） 图中蓝色表示原始ADC采样值，橙色为滤波后的值，其他图片也这样。当电压不变化时采集到的ADC采样值实际存在很多毛刺噪声，选取较小的a值则能有效减小毛刺的幅度，使信号趋于稳定，防止误判。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0023b0fe059e26459d34950fb16415b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfc8a8cf27d78faa009db07b1396d34/" rel="bookmark">
			C# 并行编程 PLINQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallel Linq的用法
并行集合
并行计算使用的多个线程同时进行计算，所以要控制每个线程对资源的访问，我们先来看一下平时常用的List&lt;T&gt;集合，在并行计算下的表现： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Collections.Concurrent; namespace ThreadPool { public class PEnumerable { public static void ListWithParallel() { List&lt;int&gt; list = new List&lt;int&gt;(); Parallel.For(0, 10000, item =&gt; { list.Add(item); }); Console.WriteLine("List's count is {0}",list.Count()); } } } 看到结果中显示的5861，而不是我们循环的是10000次啊！怎么结果不对呢？这是因为List&lt;T&gt;是非线程安全集合，意思就是说所有的线程都可以修改他的值。
下面我们来看下并行集合 —— 线程安全集合，在System.Collections.Concurrent命名空间中，首先来看一下ConcurrentBag&lt;T&gt;泛型集合，其用法和List&lt;T&gt;类似，先来写个方法测试一下：
public static void ConcurrentBagWithPallel() { ConcurrentBag&lt;int&gt; list = new ConcurrentBag&lt;int&gt;(); Parallel.For(0, 10000, item =&gt; { list.Add(item); }); Console.WriteLine("ConcurrentBag's count is {0}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfc8a8cf27d78faa009db07b1396d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8fbb1bd44268d57151f7e39ed2caba/" rel="bookmark">
			Mybatis关键源码深度分析学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Mybatis源码分析之SelectOne和自定义方法区别 学习一下自定义查询方法与Mybatis提供的方法有什么不同
先执行自定义的方法（学习流程的时候学习过，熟悉） 和以前一样这里不做过多叙述，就是通过jdk动态代理返回一个ProductMapper的接口对象。
下面去执行Product product = productMapper.selectById(168903089414213632L);这段代码，看看和上次查询一个list有什么不同，我们进入这个方法org.apache.ibatis.binding.MapperMethod.MethodSignature#MethodSignature
我们看到这个方法上次做查询的list这里有个returnsMany的判断如果是个集合或者isArray则返回true，但是我们是selectOne并且我们的returnType是个对象所以是返回false（这是不一样的地方）
继续debug 进入org.apache.ibatis.binding.MapperMethod#execute
根据判断都是false所以走else去调用selectOne（这里是不是和我们标题联系上了）其实他最终还是原理还是相同的。
进入org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne(java.lang.String, java.lang.Object)
selectOne其实去调用selectList方法，但是他有个数量校验，这个错我想大家都见过“selectOne but found n（n&gt;1）”
继续往下走进入：org.apache.ibatis.session.defaults.DefaultSqlSession#selectList(java.lang.String, java.lang.Object, org.apache.ibatis.session.RowBounds)
这里就是上篇查询list&lt;T&gt;流程就一样了，查询完成后拿到list，进行判断
符合条件返回。
下面再看原生的selectOne方法的执行流程 进入selectOnne方法
发现和自定义最后相同还是要去走这个selectOne方法并且通过selectList去查询数据然后进入数量的判断。
但是这里有个不同的，他是怎么把参数与sql语句绑定的，进入：org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler)
进入org.apache.ibatis.mapping.BoundSql#BoundSql的构造方法
将参数赋值给BoundSql的参数对象parameterObject，这样就绑定成功了。下面的执行流程就一样了。
总结 自定义方法: jdk动态代理返回一个ProductMapper的接口对象,就是MapoerProxy的一个实例化对象。通过invoke方法去判断
最后在返回类型去调用selectOne方法。
原生的selectone就少了一个jdk的动态代理，直接调用selectOne方法（最终还是selectList） ================分割线==================
二、Annotation @Select、@Update、@Insert、@Delete 分析Mybatis通过注解的方式去操作数据库 案例：
看看加了注解后他是怎么去构建的，我们把断点打到解析配置的方法中：org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration
看代码也能大致猜到他的过程： 1、解析mapper文件
2、mapper文件中有dao层接口路径
3、通过路径解析查询方法与注解（先去构建mapper文件的sql语句，再去寻找注解方式的sql语句）
进入mapperElement方法： org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement
查看parse方法：org.apache.ibatis.builder.xml.XMLMapperBuilder#parse
进入org.apache.ibatis.builder.xml.XMLMapperBuilder#bindMapperForNamespace方法绑定映射器
进入addMapper方法（org.apache.ibatis.session.Configuration#addMapper）
重点来了：
注解生成器，进入：org.apache.ibatis.builder.annotation.MapperAnnotationBuilder
和我们的注解@select建立联系了，下面继续进入:org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parse方法
进入org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parseStatement方法
通过调用这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#getSqlSourceFromAnnotations方法来获取sqlSource对象继续往下走
通过这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#buildSqlSourceFromStrings方法获取sql语句并返回
我们看一下返回的sqlSource参数
这就拿到了sql执行语句，后面的创建回话，查询数据和以前源码分析相同
总结：注解执行流程
&gt;org.apache.ibatis.session.SqlSessionFactoryBuilder.build(java.io.InputStream)　＞org.apache.ibatis.builder.xml.XMLConfigBuilder &gt;org.apache.ibatis.builder.xml.XMLConfigBuilder.mapperElement &gt;org.apache.ibatis.session.Configuration.addMapper &gt;org.apache.ibatis.binding.MapperRegistry.addMapper &gt;org.apache.ibatis.binding.MapperRegistry.addMapper &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.parseStatement &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.getSqlSourceFromAnnotations &gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba8fbb1bd44268d57151f7e39ed2caba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f430b1e5a35fb74d4a4872177bca121/" rel="bookmark">
			m4r格式转换器免费版 V3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		m4r格式转换器是一款功能强大的m4r格式转换工具，该软件几乎包含了所有的流行视频格式像MP3、 MP2、 AAC、 AC3、 WAV、 WMA、 M4A、 RM、 RAM、 OGG、 AU、 AIF、 AIFF、 APE、 FLAC等音频格式，同样它也能够支持 AVI、 WMV、 VCD、 DVD、 VOB、 MOV、 MP4、 3GP、 RMVB、 MPEG等视频格式。非常便捷，还采用了最为顶尖的多线程转换，支持批量转换，集成世界顶级的MPEG-4编码器，转换质量和速度达到完美平衡，还可以完美配合多核心CPU，所以说在转换质量方面大家完全不用担心。小编本人也在使用，强烈推荐。本站提供m4r格式转换器免费版，欢迎有需要的朋友下载！
m4r格式转换器免费版
软件介绍
1、可以将视频转换为宽频或普屏模式。支持转换4:3普通屏幕播放模式，同样支持16:9、37:20、47:20等宽频模式。
2、可以批量添加视频和音频，支持批量转换。
3、支持自动关机功能，节省您的等待时间。
4、支持多核心CPU，提高了转换速度。
5、可以利用CPU空闲时间进行格式转换，提高工作效率。
6、软件安装简单，界面美观大方。
7、软件上手容易，新手也可以轻松操作。
8、支持多线程转换，可同时转换20个文件，转换速度是普通转换器的8倍。
9、支持HD高清视频格式转换，转换后视频播放效果完美。
10、软件支持在Windows XP / 2003 /Vista / Windows 7 / Windows 8/ Windows 10系统上使用。
11、支持超大视频文件转换，对于大视频没有限制。
12、支持各种视频和音频的预览播放，软件同时是一款优秀的视频和音频播放软件。
13、支持超清、HD高清、标清视频格式转换。
14、支持网络视频FlV、SWF格式转换。
15、支持蓝光DVD、普通DVD、VCD、SVCD等光盘视频格式转换。
16、安卓系统的智能手机、平板电脑视频格式转换。
17、支持iPhone、ipad、iPod等苹果视频格式转换。
18、支持视频格式转换为音频格式。
19、支持MTS, M2TS, TRP, TP, TS, MOD, TOD等高清摄像机视频格式转换。
20、支持流行的AVI, RMVB , WMV, MPEG-4, MOV, FLV, MKV, MPG/MPEG, VOB, SWF, 3GP, MP4等视频格式转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f430b1e5a35fb74d4a4872177bca121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfb1d1e60732fe512d4018f4eb6ccc9/" rel="bookmark">
			Video Combiner(视频合并器) v1.1绿色免费版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Video Combiner是一款Windows平台下的全格式视频合并工具软件，它可以一次性将多个视频格式文件合并成一个单独的视频文件，并且有多种自适应屏幕尺寸可以选择。 这款合并器支持苹果iPhone、iPad、安卓手机、安卓平板等所有主流手机和平板视频格式，以及大部分的流行视频格式如: MP4, MOV, FLV, 3GP, AVI, WMV, MPG, VOB等几十种格式。并且它可以同时混合合并多种视频格式的文件，让您可以方便的把mp4和其他多种视频文件格式一次性合并成一个视频。 Video Combiner另外一个独特的功能，就是多种自适应屏幕尺寸。您在合并视频过程中，可能遇到的最大麻烦就是每个视频的屏幕尺寸大小是不同的。除了将视频合并成标准的16:9，5:4，9:16三种屏幕比例，Video Combiner还提供了多种自适应屏幕尺寸的选项：缩放至最大宽度、缩放至最大高度、缩放至最大宽x高、缩放至最小宽度、缩放至最小高度、缩放至最小宽x高、1:1(按宽度)和1:1(按高度)。同时这款软件也提供了完全自定义尺寸，让您可以输入您想要的屏幕宽高数字来设置自定义屏幕尺寸。Video Combiner默认保留原视频画面质量，如果您想压缩视频文件或者调整视频画面质量，程序也提供自定义比特率。您可以根据您自己的需求来调整视频比特率的数值。如果您使用的电脑是64位多核CPU和64位操作系统，这款视频合并器提供了64位多线程加速选项，可以提供更快的视频合并速度。
Video Combiner(视频合并器) v1.1绿色免费版
功能介绍
1、合适的最大宽度
输出的视频屏幕分辨率将与屏幕宽度最大的相同。
2、合适的最大高度
输出的视频屏幕分辨率将与屏幕高度最大的相同。
3、适合最大宽度x高度
输出的视频屏幕宽度将与屏幕宽度最大的相同，屏幕高度将与屏幕高度最大的相同。
4、合适的最小宽度
输出的屏幕分辨率将与屏幕宽度最小的分辨率相同。
5、符合最低高度
输出的视频屏幕分辨率将与屏幕高度最小的分辨率相同。
6、适合最小宽度x高度
输出的视频屏幕宽度将与屏幕宽度最小的相同，屏幕高度将与屏幕高度最小的相同。
7、1:1(宽度)
输出的视频屏幕宽度和高度将是相同的大小，这符合添加文件的最大屏幕宽度。
8、1:1(高度)
输出视频屏幕的宽度和高度将是相同的大小，这符合添加文件的最大屏幕高度。
软件特色
1、将多个视频合并为一个视频
2、合并不同分辨率/显示长宽比的视频
3、混合合并多种视频格式
4、保持原始视频质量
5、保持/比例显示长宽比
6、支持所有安卓/苹果设备的视频格式
7、批量合并视频
8、可携式版本
9、比特率定制允许
10、多线程加速
11、免费和清洁，没有间谍软件和广告软件
注意事项
视频组合器兼容所有最新的Windows平台。你可以很容易地在Windows 10上流畅地组合视频。除了合并MP4视频，您还可以使用它来合并DVD vob文件，mov视频，3GP剪辑，flv文件，MPG电影和更多。如果您有一些视频是无声的或没有音频通道，程序将保持这些视频部分的无声音频轨道。如果列表中的某些视频损坏或损坏，视频组合器可以自动识别并从列表中删除它们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e021267739c8b941231a4040ff40b344/" rel="bookmark">
			imgaug错误解决：ImportError: cannot import name &#39;augmenters&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在试验中因为数据不够考虑数据增强的方法，找到了一个数据增强的库叫imgaug，使用方法看起来很简单，但是不知道为什么，我在运行简单的示例时，总会出现ImportError，网上的方法有的说是应该用pip3安装，我反复卸载重装还是没有解决问题，官网给的几种安装方法统统试过没有什么效果。最后，我突然想起来，自己有时候写python文件想要引入时其实也出过同样的问题是不是可以通过相同的解决方法来处理这个问题。
首先，我们要选择Installation from Source，用以下的代码：
git clone https://github.com/aleju/imgaug.git &amp;&amp; cd imgaug &amp;&amp; python setup.py install 如果出现权限不够的情况可以使用以下的代码：
git clone https://github.com/aleju/imgaug.git &amp;&amp; cd imgaug &amp;&amp;sudo python setup.py install 上述代码执行完毕之后，你的项目文件夹下会出现一个imgaug的文件，我们来看一下这个刚刚下载的文件的文件结构（只看重要的部分）：
在这里我将子文件夹imgaug复制下来，然后删除了原imgaug，用子文件夹imgaug作为新的imgaug，因为我要使用的是augmenters，所以我大胆的只保留了相关的文件夹。然后在pycharm中将imgaug作为sources root。然后再使用imgaug就不会出现importError错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1542b9d26ebee053aab0f8f2c7671472/" rel="bookmark">
			Laravel 图片不显示解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/qq_18951197/article/details/93163149
图片文件存储位置为：项目目录/storage/app/public
1.在项目目录下执行命令创建过软链接：
php artisan storage:link 2.如果项目原来已经存在软链接,请使用** 命令行 **删除之后在重新创建 ,
//移动到public目录下 rm -rf ./storage //返回根目录然后重新创建 php artisan storage:link 转载于:https://www.cnblogs.com/xiaqiuchu/articles/11570197.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9694efccfd70212c97ae1d63fc97024/" rel="bookmark">
			命令行启动和停用appium server（兼容Mac和windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行启动和停用appium server
1.获取系统类型和命令类型
#获取系统的名称，使用对应的指令 def getsystemstr(): system=platform.system() if system=='Windows': find_manage='findstr' else: find_manage='grep' return [system,find_manage] 2.获取已连接的设备列表：
#获取设备列表 def get_device_list(): devices = [] result = subprocess.Popen("adb devices", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout.readlines() result.reverse() for line in result[1:]: if b"attached" not in line.strip(): devices.append(line.split()[0]) else: break return devices 3.根据系统和端口来启动appium server
def start_appiumServer(port11,port12): port13 = str(port11) port14 = str(port12) systemstr = SystemCheck.getsystemstr()[1] #os.system("subst w: \"C:\Program Files (x86)\Appium\"") #cmd1 = 'cd C:\\Program Files (x86)\\Appium\\' #cmd2 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9694efccfd70212c97ae1d63fc97024/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/410/">«</a>
	<span class="pagination__item pagination__item--current">411/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/412/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>