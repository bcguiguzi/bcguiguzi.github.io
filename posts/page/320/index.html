<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f76f4946393fa3a0d1bead2302db17c/" rel="bookmark">
			Wireshark中无法显示网卡列表的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题描述 打开Wireshark时，都会有一个网卡列表，在该列表中显示了电脑的所有网卡。但是，有时打开Wireshark时，该网卡列表不显示，如图1所示。
图1 不显示网卡列表
黄色背景的英文为“Local interface are unavailable because the packet capture driver isn’t loaded”，其主要意思是Wireshark的包捕获驱动没有导入成功，导致本机网卡不可用。
2 解决方法 使用net start指令打开NPCAP服务即可。使用管理员权限打开cmd，之后输入net start npcap，如图2所示。
图2 打开NPCAP服务
相关链接1 NPCAP是Npcap Packet Driver即Npcap包驱动服务的简称，Npcap是一个网络数据包抓包工具，是WinPcap的改进版。WinPcap是Windows Packet Capture即Windows包捕获的简写，提供了在Windows进行捕获数据包的编程接口。
打开NPCAP服务之后，再次打开Wireshark，就可以看到网卡列表了，如图3所示。
图3 显示网卡列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ef5a596bfaf7fb12bde501d1ec94b1/" rel="bookmark">
			V8引擎静态库及其调用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本V8引擎静态库分为x86版本和x64版本
V8引擎静态库下载地址
编译工具：VS2019
v8开头的即为V8引擎静态库（附送其它开源静态库libuv.lib、zlib.lib等_）
如何调用V8引擎
1、下载v8静态库到本地
2、配置开发环境
将上述v8的include目录配置到“附加包含目录”配置项中
根据你的开发环境配置不同版本的lib库（注意debug和release），如下：
3、调用代码如下，需要创建一个控制台程序
#include &lt;iostream&gt; #include "v8.h" #include "libplatform/libplatform.h" #include &lt;assert.h&gt; #include &lt;windows.h&gt; #pragma comment(lib, "winmm.lib") #pragma comment(lib, "dbghelp.lib") #pragma comment(lib, "shlwapi.lib") #pragma comment(lib, "v8_compiler.lib") #pragma comment(lib, "v8_libbase.lib") #pragma comment(lib, "v8_snapshot.lib") #pragma comment(lib, "v8_libplatform.lib") #pragma comment(lib, "v8_libsampler.lib") #pragma comment(lib, "v8_init.lib") #pragma comment(lib, "v8_initializers.lib") #pragma comment(lib, "v8_zlib.lib") #pragma comment(lib, "icudata.lib") #pragma comment(lib, "icutools.lib") #pragma comment(lib, "icuucx.lib") #pragma comment(lib, "icui18n.lib") #pragma comment(lib, "v8_base_without_compiler.lib") using namespace v8; using namespace std; wstring Utf8ToUnicode(const string&amp; strSrc) { /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ef5a596bfaf7fb12bde501d1ec94b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bddfb1f1c24e420f933e66e5ccc1476/" rel="bookmark">
			ubuntu(linux)系统查看文件夹下有多少文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 查看当前目录所有文件和文件夹的大小
方法一：
du−sh∗ 或
du -h -d 0 * '-d 0' 代表查询目录的深度为0 ，也就是当前目录，'-d 3' 表示文件目录深度为3，可以查到当前目录下的1~3级目录。
方法二：
ls−lh 或
ls -lht 2. 查看并统计文件和文件夹数目
统计当前目录下文件数目：
ls -l | grep '^-' | wc -l 统计当前目录及所有子目录下文件数目：
ls -lR | grep '^-' | wc -l 统计当前目录及所有子目录下以‘.jpg’后缀结尾的图片个数：
ls -lR | grep '.jpg' |wc -l 统计当前目录下及所有子目录下所有文件夹数目：
ls -lR | grep '^d' | wc -l 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ecea8a136899890222a3ae10a71e51/" rel="bookmark">
			老Java程序员谈谈swing要不要学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老Java程序员谈谈Swing要不要学 老java程序员谈谈要不要学swing
Swing是什么？ 1）AWT 在早期JDK1.0发布时，Sun公司就为GUI开发提供了一套基础类库，这套类库被称为AWT(Abstract Window Toolkit)，即抽象窗口工具包。AWT的起初设想就是为了统一实现不同操作系统的图像界面，但问题是，不同操作系统图形库的功能可能不一样（比如按钮，在不同系统的就表现不一样），在一个平台上存在的功能在另外一个平台上则可能不存在，为此AWT不得不通过牺牲功能来实现平台无关性。不仅如此，AWT还是一个重量级组件，使用比较麻烦，且设计出的图形界面不够美观功能也非常有限。为此，Sun公司对AWT进行改进，提出了Swing组件，提供了更加丰富的组件和功能，来满足GUI设计的一切需求。
2）Swing Swing是一个用于开发Java应用程序用户界面的开发工具包。使用 Swing 来开发图形界面比 AWT 更加优秀，因为 Swing 是一种轻量级组件，它采用纯 Java 实现，不再依赖于本地平台的图形界面，所以可以在所有平台上保持相同的运行效果，对跨平台支持比较出色。除此之外，Swing 提供了比 AWT 更多的图形界面组件，Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。
为了和 AWT 组件区分，Swing 组件在javax.swing.*包下，类名均以 J 开头，例如: JFrame、JLabel、JButton等，而在AWT中叫Frame、Label等。
Swing能够干什么? 1）做系统，比如医院的软件。
2）做各种小游戏，提升逼格。
3）Intellij IDEA就是java swing开发的
4）毕业设计用的挺多。
Swing容器 Swing 中容器可以分为两类：顶层容器和中间容器，容器类都是继承自 Container 类。
顶层容器： 是进行图形编程的基础，一切图形化的东西都必须包括在顶层容器中。Swing中有三种顶层容器，分别是JFrame、JDialog 和 JApplet。
中间容器： 是容器组件的一种，也可以承载其他组件，但中间容器不能独立显示，必须依附于其他的顶层容器。常见的中间容器有 JPanel、JScrollPane、JTabbedPane 和 JToolBar。
Swing布局 1）FlowLayout（流式布局）
流式布局管理器：按水平方向依次排列放置组件，排满一行，换下一行继续排列。
2）GridLayout（网格布局）
网格布局管理器：按指定行列数分隔出若干网格，每一个网格按顺序放置一个控件。
3）GridBagLayout（网格袋布局）
网格袋布局管理器：每个组件可占用一个或多个网格，可将组件垂直、水平或沿它们的基线对齐。
4）BoxLayout（箱式布局）
箱式布局管理器：它把若干组件按水平或垂直方向依次排列放置。
5）GroupLayout（分组布局）
分组布局管理器：将组件按层次分组（串行 或 并行），分别确定 组件组 在 水平 和 垂直 方向上的位置。
6）CardLayout（卡片布局）
卡片布局管理器：它将容器中的每个组件看作一张卡片，一次只能看到一张卡片，其他卡片被遮住。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ecea8a136899890222a3ae10a71e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cde189c6dad0825d3a519cd27fceb2/" rel="bookmark">
			用Selenium爬取网页简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、工具的安装 首先，我们要先安装selenium库。可以通过指令pip install selenium进行安装。
安装完selenium后，还需要安装浏览器驱动程序。这里以chrome为例。安装步骤如下：
查看浏览器的版本号。找到菜单,在菜单中打开"帮助"&gt;"关于Google Chrome命令。里面就有版本号。
下载ChromeDriver。官方下载地址：https://chromedriver.storage.googleapis.com/index.html找到对应的版本号文件夹，打开并下载对应操作系统的zip。
将zip中的文件安装在python的安装路径的Scripts文件夹下。
为了验证是否安装成功，可以通过打开命令行窗口输入chromedriver来检验。
二、通过selenium访问网页 先上代码
from selenium import webdriver browser = webdriver.Chrome() #声明要模拟的浏览器是Chrome url = 'https://www.baidu.com/' #要访问的网页链接，这里以baidu为例 browser.get(url) #通过get方式获取网页 text = browser.page_source #获得网页源代码 print(text) #打印出源代码 如果想关闭模拟浏览器窗口，可以在最后加上代码：browser.quit()
如果不想让网页弹出，可以启用无界面浏览模式：
from selenium import webdriver browser = webdriver.Chrome() #加上这三句代码 chrome_options = webdriver.ChromeOptions() chrome_options.add_argument('--headless') browser = webdriver.Chrome(options=chrome_options) url = 'https://www.baidu.com/' browser.get(url) ps:通过selenium得到的网页是经过渲染之后的源代码，就不用我们再去抓包找信息了！！
三、使用selenium模拟鼠标跟键盘操作 selenium模块还可以模拟人在浏览器中的鼠标和键盘操作。下面以在百度首页的搜索框中输入python,然后单击百度一下按钮进行搜索为例。
网页是由一个个元素构成的，搜索框和百度一下按钮都是网页上的元素。要对元素进行操作，首先要定位元素。定位元素的方法主要有XPath法跟css_selector两种方法。
1、XPath法 用XPath法定位网页元素的语法格式如下：
browser.find_element_by_xpath('xpath的表达式')
获取网页元素XPath的方法如下（以baidu搜索框为例）：
找到百度搜索框的位置，将鼠标放在上面点击鼠标右键&gt;检查&gt;对选中的网页代码再次右键&gt;Copy&gt;Copy XPath 粘贴一下发现是//*[@id="kw"]。这就是搜索框的XPath。 自动在搜索框中输入‘python’的代码如下：
from selenium import webdriver browser = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7cde189c6dad0825d3a519cd27fceb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d3f6a42c7a2b5918879b0000bd0b5a/" rel="bookmark">
			2019牛客暑期多校训练营（第一场）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 A Equivalent Prefixes （二分 + 区间最值查询）E ABBA （DP计数）H XOR （线性基）I Points Division （线段树维护DP）J Fraction Comparision（签到的签到） 链接：https://ac.nowcoder.com/acm/contest/881#question
A Equivalent Prefixes （二分 + 区间最值查询） 题意：给定两个长度为 n 的数组 a 和 b ，找到一个最大的位置 p ，使得两个数组在 [1,p] 上的任意一个子区间上的最小值的位置都相同。 ( 1 ≤ n ≤ 1 0 5 ) (1\le n \le 10^5) (1≤n≤105)
思路：
二分答案：p 之前的位置都是符合的，p 之后的位置都是不符合的。
所以二分这个位置 p 即可。check 的时候，只需要找到最小值的位置，然后拆分成两个更小的区间 check 就好了。
也可以拿单调找做，维护一个单调递增的栈，然后找到这两个数组跑出来的索引都相同的最大位置，就是答案。
#include &lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; #define se second #define ll long long using namespace std; const int maxn=1e5+5; int n,a[maxn],b[maxn]; pii dp1[maxn][20],dp2[maxn][20]; int Log[maxn]; void init(pii dp[][20],int f[]) { for(int i=1; i&lt;=n; ++i) dp[i][0]= {f[i],i}; for(int j=1; (1&lt;&lt;j)&lt;=n; ++j) for(int i=1; i+(1&lt;&lt;j)-1&lt;=n; ++i) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]); } pii queryMin1(int L,int R) { int k=Log[R-L+1]; return min(dp1[L][k],dp1[R-(1&lt;&lt;k)+1][k]); } pii queryMin2(int L,int R) { int k=Log[R-L+1]; return min(dp2[L][k],dp2[R-(1&lt;&lt;k)+1][k]); } bool check(int L,int R) { if(L&gt;=R) return 1; pii p1=queryMin1(L,R); pii p2=queryMin2(L,R); if(p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d3f6a42c7a2b5918879b0000bd0b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc5ca2d752fdc680db37a9e481a0436/" rel="bookmark">
			c语言的基本数据类型与表达式,C 02 c语言的基本数据类型与表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*
*
Data Type
*
charintlongshortfloatdoubleenum[ ]structunion*vodi
2.1C #include /* ab ab*/
int Add(int a, int b){return (a + b);}
/**/main(){int x, y, sum = 0;printf("Input two integers:");scanf("%d%d", &amp;x, &amp;y); /*xy*/sum = Add(x, y); /*Addxy*/printf("sum = %d\n", sum); /*xy*/}
C Keyword Cint,return Identifiermain,printf Add, x, y Operator342 Separator /
C {} /**/ DataVariableConstant
variablenamevariable_namevariableName
Windows UNIX
Unix/Linuxvariable_nameWindowsVariableNameJavavariableName
int, float, for, while, iffori, j, k
Unix/Linuxvariable_nameWindowsVariableNameJavavariableName
b, B, KB, MB, GB, TBbitByteKilobyte(KB) KMegabyte(MB)Gigabyte(GB)GTerabyte(TB)T
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc5ca2d752fdc680db37a9e481a0436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfb7ed35a7ee1475d44ec5608279b1e/" rel="bookmark">
			mysql 编程练习2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 建表语句如下:
CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL, `birth_date` date NOT NULL, `first_name` varchar(14) NOT NULL, `last_name` varchar(16) NOT NULL, `gender` char(1) NOT NULL, `hire_date` date NOT NULL, PRIMARY KEY (`emp_no`)); CREATE TABLE `dept_emp` ( `emp_no` int(11) NOT NULL, `dept_no` char(4) NOT NULL, `from_date` date NOT NULL, `to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`dept_no`)); select last_name , first_name , dept_no from employees e join dept_emp d on e.emp_no=d.emp_no; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af6706728c6176499f6f8f2c85b1ae7/" rel="bookmark">
			c51语言转换ASCII码,ASCII 码和十六进制数的转换　－51单片机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：用查表法将一位十六进制数转换为ASCII码，入口参数放在内部RAM 50H中，出口参数在R0中。
要求：用汇编语言完成编程(用DB "0"，"1"......)。
悬赏分：0 - 解决时间：2010-1-15 15:52
;---------------------------------
最佳答案：
转换程序如下:
D2A:
MOV A, 50H
ADD A, #2 ;加上查表时的指令地址和表格首址的差
MOVC A, @A + PC
MOV R0, A
RET
TABLE:
DB "0123456789ABCDEF" ;用：DB '0', '1', ...，形式也可以
;完
;---------------------------------
回答者：做而论道 - 十二级 2010-1-10 08:35
提问者对于答案的评价：谢谢~~
原题网址：http://zhidao.baidu.com/question/132543701.html
;======================================================
又是一个题目：
单片机编程！！将 ASCII 码转化为十六进制数，设 ASCII 码存放在累加器中，转化结果存放到B中。
提示：由 ASCII 码表可知，30H-39H为0-9的 ASCII 码，41H-46H为A-F的 ASCII 码。
将 ASCII 码减 30H(0-9)或 37H(A-F)就可获得对应的十六进制数。
我个人觉得很有难度的作业！望有学之士能 帮我做出！！万分感谢！！
悬赏分：20 - 解决时间：2010-1-6 12:28
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af6706728c6176499f6f8f2c85b1ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2f43c325ed3820c248acc9b21e59a1/" rel="bookmark">
			单片机查表实验c语言,单片机 查表程序设计实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查表程序设计实验
2.4 查表程序设计实验
2.4.1 实验目的
学习查表程序的设计方法，熟悉 51 的指令系统。
2.4.2 实验设备
PC 机一台，TD-NMC+教学实验系统、或“TD-PIT++教学实验系统＋TD-51 系统平台”、或
“TD-PITE 教学实验系统＋TD-51 系统平台”
2.4.3 实验内容
1. 通过查表的方法将 16 进制数转换为 ASCII码；
2
2. 通过查表的方法实现y＝x ，其中x为 0～9 的十进制数，以BCD码表示，结果仍以BCD
码形式输出。
2.4.4 实验步骤
1. 采用查表的方法将 16 进制数转换为 ASCII 码
根据 ASCII码表可知，0～9 的 ASCII码为 30H～39H，A～F的 ASCII码为 41H～46H，算
法为(假定待转换的数存放在 R7 中)：
当 R7≤9 时，相应的 ASCII码为：R7＋30H；
当 R7＞9 时，相应的 ASCII码为：R7＋30H＋07H。
实验程序清单：(Asm4-1.asm)
ORG 0000H
LJMP MAIN
ORG 0100H
MAIN: MOV DPTR, #ASCTAB ;表格首地址送DPTR
MOV A, R7 ;R7中为待转换的数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2f43c325ed3820c248acc9b21e59a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8971b7af39108fa4001d0abea051a6d4/" rel="bookmark">
			Flutter 面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 的初始化
1.Flutter App的入口就是函数runApp（）
2.点击runApp（）函数可以看到widgets/binding.dart中
void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame(); } 1. 点进去WidgetsFlutterBinding （看名称是将Widget与Flutter 绑在一起的意思）可以看到ensureInitialized函数是返回一个WidgetsBinding.instance单例
总体上来讲是把window提供的API分别封装到不同的Binding里。我们需要重点关注的是SchedulerBinding：调度绑定
RendererBinding：渲染绑定，通过pipelineOwner间接持有render tree的根节点RenderView。
WidgetsBinding：组件绑定，持有element tree的根节点RenderObjectToWidgetElement。
这3个是渲染流水线的重要存在。
2...attachRootWidget(app)：
void attachRootWidget(Widget rootWidget) { _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement); } 在RenderBinding初始化的时候，我们得到了RendView的实例，render tree的根节点，RenderView是继承自RenderObject的，而RenderObject需要对应的Widget 与Element。上述代码中的RenderObjectToWidgetAdapter就是这个Widget。而对应的Element就是RenderObjectToWidgetElement了，既然是要关联到render tree的根节点，那它自然也就是element tree的根节点了。
3.scheduleWarmUpFrame
void scheduleWarmUpFrame() { ... Timer.run(() { ... handleBeginFrame(null); ... }); Timer.run(() { ... handleDrawFrame(); ... }); } 进入布局（Layout）阶段和绘制（Paint）阶段了，
这里其实onBeginFrame和onDrawFrame是在具体执行这两个回调。最后渲染出来首帧场景送入engine显示到屏幕。这里使用Timer.run()来异步运行两个回调，是为了在它们被调用之前有机会处理完微任务队列（microtask queue）
stream跟changeNotifer区别
1.stream 代表着时间了，通过stream 可以快速的实现事件流驱动业务逻辑，界面通过订阅事件，针对事件转换最后通过响应事件完成页面布局，而在整个stream 流过程中，离不开以下角色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8971b7af39108fa4001d0abea051a6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607fea71416b86a89f1c865dc06b18d5/" rel="bookmark">
			MySQL 1130错误原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在使用MySQL数据库的过程中肯定都遇到过报错，其中MySQl 1130就是一个我们在远程登陆是经常遇到的错误。
本文树懒君就给大家介绍一下MySQL 1130报错的原因以及解决的思路，并给大家三种具体的解决方案供大家参考。
错误概述： 错误：ERROR 1130: Host ‘xxx.xxx.xxx.xxx’ is not allowed to connect to thisMySQL serve
错误1130：主机xxx.xxx.xxx.xxx”不允许连接到thismysql服务
原因分析 被连接的数据不允许使用主机xxx.xxx.xxx.xxx访问，系统数据库mysql中user表中的host是localhost,只允许是用 localhost （127.0.0.1）连接;
解决方法： 解决该问题有以下三个方法：
1：简单法 首先使用localhost连接上mysql，然后使用如下两条命令（IP地址为你要远程连接数据库的本地机器的IP地址）：
use mysql; update user set host='xxx.xxx.xxx.xxx'; 之后退出mysql,然后我们重新启动mysql，此实我们设置了IP地址的本地机器就可以连接数据库了。
2： 改表法。 可能是我们的的帐号不允许从远程登陆，只能在localhost（127.0.0.1）登录。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”，具体命令如下：
mysql -u root -pvmware mysql&gt;use mysql; mysql&gt;update user set host = '%' where user = 'root'; mysql&gt;flush privileges; mysql&gt;select host, user from user 3：授权法 例如，如果我们想允许用户mysqluser使用mysqlpassword作为密码从ip为192.168.47.1的主机连接到mysql服务器，就需要进行如下操作：
GRANT ALL PRIVILEGES ON *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607fea71416b86a89f1c865dc06b18d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92452d304cb2ed1824adbf0e41a84d5c/" rel="bookmark">
			【数据结构】B&#43;树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B+树的定义 B树是B+树针对数据库的变种，拥有比B树更高的查询效率。
下面，我们看着图，先搞清楚它的定义：
一个结点的最大孩子个数称为树的阶，通常用m表示。一棵m阶B+树要么是空树，要么满足以下定义：
（1）一个结点的结构是：（K1，P1，K2，…，Kn，Pn），其中P为指向子树的指针，K为关键字，它们一一对应
（2）对于根结点，如果它本身不是叶子结点，至少拥有 1 个关键字，即至少拥有 1 棵子树
（3）对于除根结点之外的所有结点，至少拥有⌈m/2⌉ 棵子树，即至少拥有 ⌈m/2⌉ 个关键字
（4）为了满足阶的定义，任何结点最多拥有 m 个子树，即最多拥有 m 个关键字
（5）B+树的所有数据保存在叶子结点，且叶子结点由指针链接起来
B+树的查找 查找某一行记录
还是看图举栗子，比如查找30:
不难看出，和B树的查询如出一辙，仍旧是 ① 从磁盘读取结点 ② 在内存中顺序/二分查找关键字；
值得注意的是，B+树与B树相比，所有的数据都是放在叶子结点上的，这导致了：
（1）非叶子结点仅仅用于标识范围，所以查找过程不会像B树那样有可能在中途结束，而是每次必须查找到叶子结点。所以说，B+树比B树稳定。
（2）非叶子结点上不存储数据，所以盘块（存一个结点）上可以存储更多的向下索引。因此，B+树比B树更加矮胖，I/O次数会更少，这也是B+树查找性能优于B树的其中一个重要原因。
范围查询
还还还是看图举栗子，比如查找 20～40 :
首先，还是不断根据索引读磁盘、内存排序找索引，找了20；接下来的操作非常简单，即通过叶子结点间的指针一口气找到40之前的所有数据！！！正是因为数据的有序性和叶子结点间的指针，B+树的范围查询性能极高。
而在B树中，是如何进行范围查找的呢？先找到20，然后从20开始不断中序遍历。中序遍历的过程中，同时也找到了父结点中的目标数据，但是，中序遍历的磁盘I/O开销非常可怕。
聚集索引和非聚集索引
什么是聚集索引？
数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同。由于表的物理存储位置固定，索引一个表中只能拥有一个聚集索引。
什么是非聚集索引？
以主键以外的列值作为键值构建的索引，我们称之为非聚集索引。显然对于加非聚集索引所用的列，逻辑顺序与物理顺序是无关的。
什么是二次查询问题？
如果使用非聚集索引作为查询条件，且查询列中包含了没有任何被任何索引覆盖的列，那么就会进行两次查询——第一次根据非聚集索引查询聚集索引（主键），第二次根据聚集索引查询结果。
举个例子吧：
我们有一张表：users（id，name，age），其中id加了聚集索引，name加了非聚集索引。
select id, name from users where name="Alice"	-- 不会发生二次查询，id和name都已被索引覆盖 select id, age from users where name="Cocoa"	-- 会发生二次查询，age未被索引覆盖 B+树的插入 和B树的插入基本一致：
如果插入后结点满足定义，则直接插入；如果插入后结点不满足定义，则结点分裂。
值得注意的是，B+树非叶子结点并不存数据，只是索引值。
看图理解非常简单，这是个4阶B+树：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92452d304cb2ed1824adbf0e41a84d5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742d11bf4d50171635280f636cf5c033/" rel="bookmark">
			【二】ubuntu —— deb包的构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 引言
2 deb包简介
3 deb包的基础应用
3.1 dpkg常用命令
安装
移除
信息查看
解包
4 deb包的编译
4.1 自研deb包的编译
4.2 适配deb包的编译
4.3 编译输出文件打包
5 虚拟包——virtual package
5.1 意义
5.2 参考
6 注意事项
参考
1 引言 当构建一个自定义特性的ubuntu发行版本时，会经常接触deb包，因为它们有助于ubuntu来安装和维护软件，因此了解deb是很有帮助的。由于deb包方面的知识和框架是很大的，无法在本文中概括完，所以本文只针对如何构建包和搭建构建环境，涉及的其他非相关知识不做介绍。
本章中内容如将着重描述：源码编译为deb包的自研包和开源包修改之后的适配包。
2 deb包简介 deb包通常配合APT软件管理系统来使用，它是Debian系统(包含debian和ubuntu)下专属的安装包格式，称为当前在linux下非常主流的一种包管理方式。将包文件信息以及包内容，经过gzip和tar打包而成，处理deb包的经典程序是dpkg，经常是通过apt来运作。
3 deb包的基础应用 3.1 dpkg常用命令 安装 dpkg -i 或者 dpkg --install *.deb
表示安装该软件包，deb包并非平台无关的包，deb包与主机架构需要对应，才能安装使用，在安装的过程中终端将打印相应的步骤信息，在出错时也方便调试。
事实上，deb包的安装分为了两个阶段：先解压压缩包，然后进行配置。这两个步骤可以分开处理。
移除 dpkg -r 或者 dpkg --remove 表示从系统中移除一个deb包，但是保留其配置文件、维护文件以及用户数据，仅相当于停用程序，下次安装可继续使用。
dpkg -P package_name 或者 dpkg –purge ： 表示从系统中移除一个deb包，同时，删除所有包相关的文件。
信息查看 dpkg -L 列出某个已安装deb包的文件清单，包含所有安装的软件，但是不包含控制信息。需要注意的是，这一选项需要目标是已安装软件，packge只需要包名而不需要带.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/742d11bf4d50171635280f636cf5c033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3da8bcf11284d7b095b3d2bee74c0e/" rel="bookmark">
			c语言cross函数什么意思,通达信cross函数用法,通达信 filter函数 返回什么值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q1：通达信 filter函数 返回什么值
结果：返回一个逻辑真值，当逻辑条件为真时，如果在N周期内已真过,将当前真值置为0,即过滤。
下面网页上有详细讲解。
http://www.chcj.net/thread-945487-1-1.html
希望对你有点帮助！
Q2：求通达信公式满足条件CROSS(EXP1,EXP2)向左画水平射线
就按照这句CROSS(EXP1,EXP2)上穿代码,可以利用DRAWSL函数画线,满足条件后在某位置,画水平射线,长度,左延伸,
这些按照参数设置就可以了,
不知道你想干什么,猜猜你想金叉死叉画线,看支撑压力吧
如果是我就直接输出当时的高低点了.
效果像下图
Q3：通达信公式： CROSS 和 &gt; 运用的区别
CROSS函数即穿越，你说的第一种，即是昨日5日均线小于10日均线且今日5日均线大于10日均线，5/20均同理。
就是说，CROSS是同时满足昨日和今日两个条件才能成立，而你说的第二种仅是满足今日条件，所以搜索出来的结果数量差距很大。
Q4：求教育：通达信的公式函数(像cross、if这类)封装在哪？公式在运行时是不是通过dll调用的？
我对通达信的目录文件夹不是很熟，我对大智慧熟。我猜测一下：
1、公式函数调用的数据是日线数据、五分钟线数据等。日线数据下载后所在的位置就是要调用数据的位置。通达信应该在vipdoc这个文件夹里。我看里面sh 和 sz 里面存放的就是下载的日线、五分钟线等数据。
2、自编公式保存在T002里。自编公式在这里，但调用的数据仍然同上，应该在vipdoc文件夹里。应该是分开来的。你把T002文件夹复制移到另一个电脑通达信里，再下载数据，那么和原来电脑一模一样。
3、通达信软件调用的数据相对有限，一般都是日线、五分钟线数据、分时数据。不像大智慧除此外，还有另外一个文件夹download，存放财务板块数据。
4、公式编辑器模块是在TdxW.exe还是在某个dll中实现的？不懂你的意思。
5、公式管理器列表，我不知道你说的是不是这个位置：功能----专家系统----公式管理器。或左边的工具栏按钮，最快捷的是：CTRL + F 。进入公式管理器，里面自己翻翻。
Q5：通达信BARSLAST用法，或有更好的函数
分时图与均价线一起看。
1. 分时图——均价线判断拉升
均价线判断拉升：在看分时图中很重要的一点就是看分时线和均价线的位置关系，健康完美的分时线和均线运行状态是，分时线运行在均价线上并保持一定的比例关系，当分时线上涨是均价线应该跟上，如果分时上涨均价反应迟钝是一种异常，说明有资金虚假拉升或者为了出货拉升，这样的我们就在高点出货。
2. 分时横盘
分时横盘是一种常见形态，为什么会出现这形态有两种原因，一：有人维持股价进行出货，不想卖的低，出的差不多了就开始下跌。二：是强势调整，横盘庄家在吃抛盘和打买盘进行洗盘调整，结束后必然上涨，庄家不让股价跌必然是想拉高股价，作为一种上涨概率很大的形态一定要一起注意。你如果持有的股票出现这种情况完全可以持有等待趋势出来，如果要买的话，一定要注意横盘的股票，一但股价启动可以考虑接介入。当然任何时候股价不是涨就是跌，这点你要时刻记住。可以用低点原则判断，横盘形成的低点必然不会被跌破，如果跌破意味着下跌，上涨其中的高点必然被突破，突破就可以买进了。更多详情可以去游侠股市系统学习
Q6：高手帮忙改成通达信的公式谢谢DRAWGBKLAST(C&gt;0,STRIP(RGB(90,90,9...
楼主的句子是新版大智慧的,通达信想要这个效果只能变通一下,但想要达到大智慧的效果是不可能的
{***************通达信主图背景变色***************************}
DRAWBAND(CONST(HHV(H,160)),RGB(90,90,90),CONST(LLV(L,160)),RGB(0,0,0));
DRAWBAND(CONST(LLV(L,160))+(CONST(HHV(H,160))-CONST(LLV(L,160)))*4/5,RGB(85,85,85),CONST(LLV(L,160)),RGB(0,0,0));
DRAWBAND(CONST(LLV(L,160))+(CONST(HHV(H,160))-CONST(LLV(L,160)))*3/5,RGB(80,80,80),CONST(LLV(L,160)),RGB(0,0,0));
DRAWBAND(CONST(LLV(L,160))+(CONST(HHV(H,160))-CONST(LLV(L,160)))*2/5,RGB(75,75,75),CONST(LLV(L,160)),RGB(0,0,0));
DRAWBAND(CONST(LLV(L,160))+(CONST(HHV(H,160))-CONST(LLV(L,160)))*1/5,RGB(70,70,70),CONST(LLV(L,160)),RGB(0,0,0));
DRAWBAND(CONST(LLV(L,160))+(CONST(HHV(H,160))-CONST(LLV(L,160)))*0/5,RGB(65,65,65),CONST(LLV(L,160)),RGB(0,0,0));
DRAWKLINE(HIGH,OPEN,LOW,CLOSE);
{******************************************************************}
MA1:MA(C,5);
MA2:MA(C,10);
MA3:MA(C,20);
一:=MA1&gt;MA2 AND MA2&gt;MA3;
二:=C/REF(C,1)&gt;1.03 AND O&gt;MA1;
哇:=BARSLAST(一!=1);
DRAWTEXT(抢&gt;3 AND 二,H*1.009,'哇'),COLORAAFFFF;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8192f5c01bda58a14f7ddfa675ad24/" rel="bookmark">
			HINT: Add or change a related_name argument to the definition for ‘User.user_permissions‘ or ‘User.u
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目的settings 中添加
AUTH_USER_MODEL = 'users.User' # users是app名，User是models中的类名 然后执行
python manage.py makemigrations app名
python manage.py migrate
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2ed42b6b4f0281cda2fc448def4bae/" rel="bookmark">
			网络工程复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章绪论 网络工程设计的概念 网络工程设计是按照用户的网络建设需求，从网络综人布线、数据通信、系统集成等方面综合考虑，选用先进的网络技术和成熟产品，为用户提出科学、合理，实用、好用、够用的网络系统解决方案。该方案用于指导网络系统集成，通过系统集成将各种网络设备、操作系统与应用系统有效整合，形成一体化系统。
因此，网络工程设计是保障网络组建工程项目实施的首要环节。
网络系统集成的定义 指通过结构化的综合布线系统和计算机网络技术，将各个分离的设备(如个人电脑)、功能和信息等集成到相互关联的、统一和协调的系统之中，使资源达到充分共享，实现集中、高效、便利的管理。
系统集成应采用功能集成、网络集成、软件界面集成等多种集成技术。
网络系统集成的层面 网络软硬件产品的集成网络技术的集成网路应用的集成 TCP/IP协议族 TCP/IP协议簇是Internet的基础，也是当今最流行的组网形式。TCP/IP是一组协议的代名词，包括许多别的协议，组成了TCP/IP协议簇。其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等
IP协议
即互联网协议(Internet Protocol)，它将多个网络连成一个互联网，可以把高层的数据以多个数据包的形式通过互联网分发出去。IP的基本任务是通过互联网传送数据包，各个IP数据包之间是相互独立的。
ICMP协议
即互联网控制报文协议。从IP互联网协议的功能，可以知道IP 提供的是一种不可靠的无连接报文分组传送服务。若路由器或主机发生故障时网络阻塞，就需要通知发送主机采取相应措施。为了使互联网能报告差错，或提供有关意外情况的信息，在IP层加入了一类特殊用途的报文机制，即ICMP。分组接收方利用ICMP来通知IP模块发送方，进行必需的修改。ICMP通常是由发现报文有问题的站产生的，例如可由目的主机或中继路由器来发现问题并产生的ICMP。如果一个分组不能传送，ICMP便可以被用来警告分组源，说明有网络，主机或端口不可达。ICMP也可以用来报告网络阻塞。
ARP协议
即地址转换协议。在TCP/IP网络环境下，每个主机都分配了一个32位的IP地址，这种互联网地址是在网际范围标识主机的一种逻辑地址。为了让报文在物理网上传送，必须知道彼此的物理地址。这样就存在把互联网地址变换成物理地址的转换问题。这就需要在网络层有一组服务将 IP地址转换为相应物理网络地址，这组协议即ARP。
TCP协议
即传输控制协议，它提供的是一种可靠的数据流服务。当传送受差错干扰的数据，或举出网络故障，或网络负荷太重而使网际基本传输系统不能正常工作时，就需要通过其他的协议来保证通信的可靠。TCP就是这样的协议。TCP采用“带重传的肯定确认”技术来实现传输的可靠性。并使用“滑动窗口”的流量控制机制来提高网络的吞吐量。TCP通信建立实现了一种“虚电路”的概念。双方通信之前，先建立一条链接然后双方就可以在其上发送数据流。这种数据交换方式能提高效率，但事先建立连接和事后拆除连接需要开销。
UDP协议
即用户数据包协议，它是对IP协议组的扩充，它增加了一种机制，发送方可以区分一台计算机上的多个接收者。每个UDP报文除了包含数据外还有报文的目的端口的编号和报文源端口的编号，从而使UDP软件可以把报文递送给正确的接收者，然后接收者要发出一个应答。由于UDP的这种扩充，使得在两个用户进程之间递送数据包成为可能。我们频繁使用的OICQ软件正是基于UDP协议和这种机制。
FTP协议
即文件传输协议，它是网际提供的用于访问远程机器的协议，它使用户可以在本地机与远程机之间进行有关文件的操作。FTP工作时建立两条TCP链接，分别用于传送文件和用于传送控制。FTP采用客户/服务器模式?它包含客户FTP和服务器FTP。客户FTP启动传送过程，而服务器FTP对其作出应答。
DNS协议
即域名服务协议，它提供域名到IP地址的转换，允许对域名资源进行分散管理。DNS最初设计的目的是使邮件发送方知道邮件接收主机及邮件发送主机的IP地址，后来发展成可服务于其他许多目标的协议。
SMTP协议
即简单邮件传送协议互联网标准中的电子邮件是一个简单的基于文本的协议，用于可靠、有效地数据传输。SMTP作为应用层的服务，并不关心它下面采用的是何种传输服务，它可通过网络在TXP链接上传送邮件，或者简单地在同一机器的进程之间通过进程通信的通道来传送邮件，这样，邮件传输就独立于传输子系统，可在TCP/IP环境或X.25协议环境中传输邮件。
OSI参考模型 OSI与TCP/IP参考模型对比 原文链接
ARP的功能 ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
子网掩码的定义 子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。
子网掩码不能单独存在，它必须结合IP地址一起使用。
子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。
域名系统的概念 域名系统就是管理域名和IP地址之间的对应关系。
解析域名 就是将域名转化为IP地址，一个域名对应一个IP地址，一个IP地址可以对应多个域名，域名的搭建就是为了方便记忆IP地址的。
网络层次结构 典型的三层结构：核心层+汇聚层+接入层
高效的扁平结构
网络工程实施步骤 设计阶段实施阶段验收 第二章综合布线与机房工程 综合布线的概念 综合布线是一种模块化的、灵活性极高的建筑物内或建筑群之间的信息传输通道。通过它可使话音设备、数据设备、交换设备及各种控制设备与信息管理系统连接起来，同时也使这些设备与外部通信网络相连的综合布线。它还包括建筑物外部网络或电信线路的连接点与应用系统设备之间的所有线缆及相关的连接部件。
T568A/T568B T568A：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕。
T568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕。
二者没有本质的区别，只是颜色上的区别，注意这个颜色是从水晶头的正面看。
如果一条网线它的两头都是按照T568B的排线顺序的，那就是我们常说的直连线。直连线最常见，通常用在交换机和网卡的连接，在多终端的局域网用得最多，另外有的交换机与交换机的级连用的也是直连线。
如果一条网线它的两头不同，一头是按照T568A标准排线顺序，另一头按T568B标准排线顺序，那就是我们常说的交叉线。交叉线通常用在网卡与网卡的连接，有的交换机与交换机的级连也要用到交叉线。
综合布线子系统 1、工作区子系统：由信息插座的软线和终端设备连接而成，包括装配、连接、扩展软线，并将它们搭建在输入、输出插座与设备终端之间，其中信息插座分为墙、地、桌、软基型多种形式。
2、垂直子系统：是综合布线系统的中心系统，主要负责连接楼层配线架系统与主配线架系统。
3、水平子系统：本系统主要负责将管理子系统配线架的电缆从干线子系统延伸至信息插座位置，一般来说这些系统都处在同一楼层。
4、管理子系统：连接各楼层水平布线子系统和垂直干缆线，负责连接控制其他子系统，由交连、互连和I/O设备组成，可以定位通信线路，便于实现对通讯线路的管理。
5、设备间子系统：组成部分包括电缆、连接器和相关支撑硬件，负责公共系统间的各种设备连接。设备间子系统中的导线类似于电话配线系统站内配线，它将相对应的电气保护设备连接到了需要设备保护的建筑物设施地点。
6、建筑群子系统：本系统是把其中一个建筑的电缆线通过技术延伸至本建筑群中其他的建筑中的通讯设备中，以此为楼群之间的信号连接提供可能。
机房布线方式 地板布线桥架布线混合布线 第三章高速局域网与系统集成 CSMA/CD概念和原理 CSMA/CD即载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2ed42b6b4f0281cda2fc448def4bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11381ed835d9c7db9fee8d2e05632f48/" rel="bookmark">
			django的makemigrations和migrate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成0001_initial.py对应的mysql语句
python manage.py sqlmigrate app名 0001 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be208fd61c47f228fce6a317a19662fb/" rel="bookmark">
			MySql 测试并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySql 官方提供了工具 mysqlslap
可以在MySql的安装目录下找到
mysqlslap -hlocalhost -uusername -ppassword -P3306 --concurrency=100 --iterations=1 --auto-generate-sql --auto-generate-sql-load-type=mixed --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=200 –concurrency=100 说明 100个线程–number-of-queries=200 说明 200个请求 上面的命令完成的是100个线程，每个线程发送两个请求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab41fead0078dbf631ba53024d0ad63/" rel="bookmark">
			c语言中double的最大值,C/C&#43;&#43; 中 int float double 最大值，最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/ACb0y/article/details/5336822
#include #include using namespace std;
int main()
{
cout &lt;&lt; "int 类型能存储的最大值和最小值" &lt;&lt; endl;
cout &lt;&lt; "INT_MAX = " &lt;&lt; INT_MAX &lt;&lt; endl;
cout &lt;&lt; "INT_MIN = " &lt;&lt; INT_MIN &lt;&lt; endl;
cout &lt;&lt; "long 类型能存储的最大值和最小值" &lt;&lt; endl;
cout &lt;&lt; "LONG_MAX = " &lt;&lt; LONG_MAX &lt;&lt; endl;
cout &lt;&lt; "LONG_MIN = " &lt;&lt; LONG_MIN &lt;&lt; endl;
cout &lt;&lt; "long long 类型能存储的最大值和最小值" &lt;&lt; endl;
cout &lt;&lt; "LONG_LONG_MAX = " &lt;&lt; LONG_LONG_MAX &lt;&lt; endl;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab41fead0078dbf631ba53024d0ad63/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/319/">«</a>
	<span class="pagination__item pagination__item--current">320/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/321/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>