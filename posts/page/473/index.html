<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280380cfe360cc7d1d2e0a1b50156ff9/" rel="bookmark">
			OpenCV大牛博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：colorfulshark
OpenCV学习笔记
作者：CSDN 数量：55篇博文 网址：http://blog.csdn.net/column/details/opencv-manual.html 部分OpenCV的函数解读和原理解读
作者：梦想腾飞 数量：20篇博文 网址：http://blog.csdn.net/xidianzhimeng/article/category/1593859 OpenCV入门指南
作者： MoreWindows 数量： 13篇博文 网址：http://blog.csdn.net/morewindows/article/category/1291764 –
OpenCV成长和进阶之路
作者： Ronny的技术成长之路 数量： 12篇博文 网址：http://www.cnblogs.com/ronny/category/366234.html OpenCV入门教程
作者： 毛星云（浅墨）的专栏，《OpenCV3编程入门》作者 数量： 18篇博文 网址：http://blog.csdn.net/zhmxy555/article/category/1923021 基础学习笔记之opencv
作者： tornadomeet 数量： 24篇博文 网址：http://www.cnblogs.com/tornadomeet/tag/opencv/ OpenCV学习笔记
作者： 邹宇华 数量： 32篇博文 网址：http://blog.csdn.net/chenyusiyuan/article/category/610983 CVPR|OpenCV|图像检索|视频检索
作者： icvpr 数量： 25篇博文 网址：http://blog.csdn.net/icvpr/article/category/1139524 学习OpenCV
作者： 小熊不去实验室 数量： 81篇博文 网址：http://blog.csdn.net/sangni007/article/category/1106771 OpenCV
作者： 羽凌寒 数量： 47篇博文 网址：http://blog.csdn.net/u011630458/article/category/2771659 OpenCV入门
作者： reyzal 数量： 7篇博文 网址：http://www.cnblogs.com/Reyzal/default.html?page=1 OpenCV一些例程
作者： 一样菜 数量： 18篇博文 网址：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280380cfe360cc7d1d2e0a1b50156ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285eba13a3c30be0f91eb47a105a7a72/" rel="bookmark">
			DHCP服务器是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果经常关注本站，或对服务器了解的多一些的话，我们会发现，服务器根据功能的不同，有好多的类型，比如，WEB服务器、FTP服务器、目录服务器、DNS服务器等。常见的几类服务器我们之前也都有介绍，这里就介绍一下，DHCP服务器是什么。
DHCP服务器是什么
DHCP是什么?DHCP服务器是什么意思?
DHCP是Dynamic Host Configuration Protocol的缩写，即动态主机配置协议。DHCP是一个很重要的局域网的网络协议，使用UDP协议工作，主要有以下用途：
1、为内部网络或网络服务供应商自动分配IP地址;
2、为用户或者内部网络管理员作为对所有计算机作中央管理的手段;
3、为内部网络用户接受IP租约。
而DHCP服务器就是专门承载和运行DHCP服务，并帮助我们管理IP的专用服务器，是运行MicrosoftTCP/IP、DHCP服务器软件和Windows NT Server的计算机。
在网络中配置DHCP服务器有如下优点：
1、大部分路由器可以转发DHCP配置请求，因此，互联网的每个子网并不都需要DHCP服务器;
2、客户机不需手工配置TCP/IP;
3、使用DHCP服务器能大大减少配置花费的开销和重新配置网络上计算机的时间，服务器可以在指派地址租约时配置所有的附加配置值;
4、提供安全可信的配置。DHCP避免了在每台计算机上手工输入数值引起的配置错误，还能防止网络上计算机配置地址的冲突;
5、客户机在子网间移动时，旧的IP地址自动释放以便再次使用。在再次启动客户机时，DHCP服务器会自动为客户机重新配置TCP/IP;
6、管理员可以集中为整个互联网指定通用和特定子网的TCP/IP参数，并且可以定义使用保留地址的客户机的参数。
利用DHCP服务器，我们可以灵活的利用手工分配、自动分配及动态分配3种分配方式，为DHCP客户机分配TCP/IP地址。从而做到更为方便的管理和维护DHCP客户机，同时也可以有效解决IP不够用的问题。
本文转自d1net（转载）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f9bb8661f4a3a91564d9e2ad01bd7e/" rel="bookmark">
			实战spring自定义属性(schema)：快速体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发dubbo服务的时候，我们会在xml中做以下类似的配置：
&lt;dubbo:application name="dubbo_service_provider" /&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; spring启动后，dubbo的本地运行时环境就会获取到这些信息，根据这些信息完成注册服务，今天我们实战的内容就是开发一个类似的自定义属性，然后在spring项目中使用这个属性；
整个实战过程分为以下几步：
创建web工程；创建配置属性的bean；创建XSD文件；创建自定义BeanDefinitionParser，制定配置信息的解析规则；创建自定义NamespaceHandler，规定配置信息的解析器；添加spring.handlers文件;添加spring.schemas文件;在工程中配置一个这样的属性；启动web工程，验证配置； 本次实战对应的源码可以从我的git上下载，地址是：git@github.com:zq2599/blog_demos.git，里面有多个工程，本次用到的是springschemademo，如下图红框所示：
开始实战吧：
创建web工程 创建一个maven工程，pom.xml的内容如下，主要是把spring相关的依赖引入：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bolingcavalry&lt;/groupId&gt; &lt;artifactId&gt;springschemademo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;app Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f9bb8661f4a3a91564d9e2ad01bd7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7e60caca05ad727efd9506a1e03179/" rel="bookmark">
			KNN算法---c&#43;&#43;实现KNN算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN算法的编程步骤 文件data.txt中的数据为： 1. c++读取txt 文件到数组中的程序 #include&lt;iostream&gt; #include&lt;fstream&gt; using namespace std; #define maxRow 12 #define maxCol 2 ifstream fin; //定义ifstream 类的对象：fin ofstream fout; //定义ofstream类的对象：fout int main() { fin.open("D:/data.txt"); if(!fin ) { cout&lt;&lt;"could not open the file"&lt;&lt;endl; return -1; } fout.open("D:/test.txt"); if(!fout) { cout&lt;&lt;"could not open the file"&lt;&lt;endl; return -1; } float data[maxRow][maxCol]; char labels[maxRow]; //循环把 data.txt 中的内容 输入到数组中 for(int i=0;i&lt;12;i++) { for(int j = 0;j&lt;2;j++) { fin&gt;&gt;data[i][j]; } fin&gt;&gt;labels[i]; } //循环把 数组中的内容输出到文件test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7e60caca05ad727efd9506a1e03179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e670bed7822fd4a08b614ef0551763/" rel="bookmark">
			SpringBoot&#43;Springcloud&#43;SpringBootAdmin 服务发现注册与服务监控完美整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSource公司开源的SpringCloud与阿里开源的Dubbo一直是SOA架构服务调度框架的首选，前段时间公司尝试使用了Dubbo+Zookeeper架构模式，但是实践过程中发现几个比较重要的缺陷，虽然也有比较好的优势但是此文就不阐述Dubbo的优势了，主要说下为何遗弃的几点原因供大家参考：
1.Dubbo虽然对代码的植入很小，但是在对提供者与消费者分层时，需要使用Maven的依赖开发功能，看似没什么问题，但是当提供者存在很多Git分支时，消费者在调试设置部署上线时需要非常小心，很容易出错。
2.Dubbo+Zookeeper架构的监控工具搜索了一番，发现貌似DubboKeeper这个开源监控从界面上看还算可以，但是真正的监控功能不够强大。
3.现在内部很多项目都采用SpringBoot方式在开发了，但是Dubbo还不支持，虽然也有一些网上存在个人开发的一些附加包可以支持，但是安全性有点疑虑
综上几点原因思考后还是决定采用SpringCloud进行SOA调度框架，而SpringBootAdmin官方提供的监控工具功能很强大，扩展性也很全面，下面就给大家说下整合这些框架的具体流程，整合过程中本人遇到了很多的坑，都是泪...，具体流程按以下步骤：
1.首先下载Zookeeper并且分布式安装配置，此文就不阐述，详细可以见：Ubuntu14 分布式安装Zookeeper
2.官方说明最好不要将SpringBootAdmin监控工具和提供者或者消费者放在一个项目，因为不安全，如果你的项目挂了随之监控也挂了那么还需要监控做什么呢，所以新建一个SpringBoot项目，然后在Pom加入
&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/de.codecentric/spring-boot-admin-server-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;version&gt;1.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-consul-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-consul-core&lt;/artifactId&gt; &lt;version&gt;1.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 然后再Main方法入口加上： @Configuration @EnableAutoConfiguration @EnableDiscoveryClient @EnableAdminServer 接着新建application.properties文件，写入： #监控工具端口 server.port=8181 #监控刷新时间 单位毫秒 spring.boot.admin.monitor.period=10000 #是否开启自动发现服务 spring.boot.admin.discovery.enabled=true spring.cloud.consul.enabled=true #是否需要秘钥认证 management.security.enabled=false #拥有者 info.owner=Mazkc #监控版本号 info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e670bed7822fd4a08b614ef0551763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2266be9523788641487fde76889b1341/" rel="bookmark">
			如何获取事件冒泡里最顶层的元素（或者任意层的元素）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先举个例子，有如下DOM结构：
&lt;ul @click="toApply"&gt; &lt;li data-user-id="1"&gt; &lt;img src="/static/user/face/4.jpg" class="user"&gt; &lt;div class="info"&gt; &lt;p class="name"&gt;ThreeTree&lt;/p&gt; &lt;p class="intro"&gt; &lt;span class="man"&gt;19&lt;/span&gt; 大哥 想请教一个问题 &lt;/p&gt; &lt;p class="from"&gt;来自：JS讨论群&lt;/p&gt; &lt;button class="agree"&gt;同意&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li data-user-id="2"&gt; &lt;img src="/static/user/face/6.jpg" class="user"&gt; &lt;div class="info"&gt; &lt;p class="name"&gt;rshu&lt;/p&gt; &lt;p class="intro"&gt; &lt;span class="man"&gt;19&lt;/span&gt; 我是rshu &lt;/p&gt; &lt;p class="from"&gt;来自：QQ群-ThinkPHP技术讨论中心&lt;/p&gt; &lt;button class="other"&gt;已拒绝&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li data-user-id="3"&gt; &lt;img src="/static/user/face/7.jpg" class="user"&gt; &lt;div class="info"&gt; &lt;p class="name"&gt;云端之上&lt;/p&gt; &lt;p class="intro"&gt; &lt;span class="man"&gt;19&lt;/span&gt; 你是腾讯的? &lt;/p&gt; &lt;p class="from"&gt;来自：临时会话&lt;/p&gt; &lt;button class="other"&gt;已拒绝&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li data-user-id="4"&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2266be9523788641487fde76889b1341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9677f51476cd4c2b0bdb1b777ebb1af0/" rel="bookmark">
			Device Admin 简单实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Device Admin 简单实践 时间 2016-07-20 22:15:32 Floatingmuseum 原文 http://floatingmuseum.github.io/2016/07/device-admin-practice 主题 安卓开发 简介 DeviceAdmin顾名思义设备管理，是Android在2.2版本中引进的。通过用户授权自己的应用设备管理权限后，可以在代码中修改很多系统设置。主要应用场景，例如公司给员工分配的机器，学校给学生提供的教学设备等等。
可查看 官方简介 ，其中有代码样例。
基本功能 设置锁屏密码设置密码规则设置密码试错次数设置一定时长未操作设备后锁屏强制锁屏禁用相机恢复出厂设置锁屏时禁用某些功能 如何配置 1. 在资源目录的XML文件夹（没有此文件夹可自己新建一个）下创建一个xml文件，文件名可自定义。在其中添加你需要的权限。 &lt;device-admin xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;uses-policies&gt; &lt;!-- 设置密码规则 --&gt; &lt;limit-password /&gt; &lt;!-- 监视屏幕解锁尝试次数 --&gt; &lt;watch-login /&gt; &lt;!-- 更改解锁密码 --&gt; &lt;reset-password /&gt; &lt;!-- 锁定屏幕 --&gt; &lt;force-lock /&gt; &lt;!-- 清除数据，恢复出厂模式，在不发出警告的情况下 --&gt; &lt;wipe-data /&gt; &lt;!-- 锁屏密码有效期 --&gt; &lt;expire-password /&gt; &lt;!-- 对存储的应用数据加密 --&gt; &lt;encrypted-storage /&gt; &lt;!-- 禁用锁屏信息 --&gt; &lt;disable-keyguard-features/&gt; &lt;!-- 禁用摄像头 --&gt; &lt;disable-camera /&gt; &lt;/uses-policies&gt; &lt;/device-admin&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9677f51476cd4c2b0bdb1b777ebb1af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4a2c0729fbd96892b88b1fb29eacd9/" rel="bookmark">
			QT 读取csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中提出的需求是从excel表格中导入数据，查阅了很多资料之后，发现直接操作xls格式文件并不容易，之后找到了一个比较好的解决办法，那就是把xls文件另存为csv文件，然后在程序中进行操作。首先大致说明一下这两种格式的区别:
xls文件是Excel电子表格的文件格式，而csv是一种比较通用的文件格式，xls文件只能用Excel才能打开，而csv文件可以用Excel、记事本、文本编辑器打开。
好了，说明了它们的不同之后我们就说一下大体思路，读取csv文件中的数据，就是先以换行符进行断开，这样就能获取到每行的数据，然后再以半角的逗号断开，这样就能获取到具体每个单元格中的数据，话不多说，上代码：
QFileDialog* fd = new QFileDialog(this)；//创建打开文件对话框 QString fileName = fd-&gt;getOpenFileName(this,tr("Open File"),"/home",tr("Excel(*.csv)")); if(fileName == "") return; QDir dir = QDir::current(); QFile file(dir.filePath(fileName)); if(!file.open(QIODevice::ReadOnly)) qDebug()&lt;&lt;"OPEN FILE FAILED"; QTextStream * out = new QTextStream(&amp;file);//文本流 QStringList tempOption = out-&gt;readAll().split("\n");//每行以\n区分 for(int i = 0 ; i &lt; tempOption.count() ; i++) { QStringList tempbar = tempOption.at(i).split(",");//一行中的单元格以，区分 ...//省略具体对数据的操作 } file.close();//操作完成后记得关闭文件 //打开多个文件
QStringList pathList=QFileDialog::getOpenFileNames(this, QStringLiteral("选择文件"), "../datas",tr("(*).csv"));
QStringList::Iterator it = pathList.begin();
while (it != pathList.end()) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4a2c0729fbd96892b88b1fb29eacd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67384c463e600a77c6b3c6abdd62ec51/" rel="bookmark">
			基于FPGA的VGA显示，简单的历程和注释（DE2-115）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 module VGA_test( OSC_50, //原CLK2_50时钟信号 VGA_CLK, //VGA自时钟 VGA_HS, //行同步信号 VGA_VS, //场同步信号 VGA_BLANK, //复合空白信号控制信号 当BLANK为低电平时模拟视频输出消隐电平，此时从R9~R0,G9~G0,B9~B0输入的所有数据被忽略 VGA_SYNC, //符合同步控制信号 行时序和场时序都要产生同步脉冲 VGA_R, //VGA绿色 VGA_B, //VGA蓝色 VGA_G); //VGA绿色 input OSC_50; //外部时钟信号CLK2_50 output VGA_CLK,VGA_HS,VGA_VS,VGA_BLANK,VGA_SYNC; output [7:0] VGA_R,VGA_B,VGA_G; parameter H_FRONT = 16; //行同步前沿信号周期长 parameter H_SYNC = 96; //行同步信号周期长 parameter H_BACK = 48; //行同步后沿信号周期长 parameter H_ACT = 640; //行显示周期长 parameter H_BLANK = H_FRONT+H_SYNC+H_BACK; //行空白信号总周期长 parameter H_TOTAL = H_FRONT+H_SYNC+H_BACK+H_ACT; //行总周期长耗时 parameter V_FRONT = 11; //场同步前沿信号周期长 parameter V_SYNC = 2; //场同步信号周期长 parameter V_BACK = 31; //场同步后沿信号周期长 parameter V_ACT = 480; //场显示周期长 parameter V_BLANK = V_FRONT+V_SYNC+V_BACK; //场空白信号总周期长 parameter V_TOTAL = V_FRONT+V_SYNC+V_BACK+V_ACT; //场总周期长耗时 reg [10:0] H_Cont; //行周期计数器 reg [10:0] V_Cont; //场周期计数器 wire [7:0] VGA_R; //VGA红色控制线 wire [7:0] VGA_G; //VGA绿色控制线 wire [7:0] VGA_B; //VGA蓝色控制线 reg VGA_HS; reg VGA_VS; reg [10:0] X; //当前行第几个像素点 reg [10:0] Y; //当前场第几行 reg CLK_25; always@(posedge OSC_50) begin CLK_25=~CLK_25; //时钟 end assign VGA_SYNC = 1'b0; //同步信号低电平 assign VGA_BLANK = ~((H_Cont&lt;H_BLANK)||(V_Cont&lt;V_BLANK)); //当行计数器小于行空白总长或场计数器小于场空白总长时，空白信号低电平 assign VGA_CLK = ~CLK_to_DAC; //VGA时钟等于CLK_25取反 assign CLK_to_DAC = CLK_25; always@(posedge CLK_to_DAC) begin if(H_Cont&lt;H_TOTAL) //如果行计数器小于行总时长 H_Cont&lt;=H_Cont+1'b1; //行计数器+1 else H_Cont&lt;=0; //否则行计数器清零 if(H_Cont==H_FRONT-1) //如果行计数器等于行前沿空白时间-1 VGA_HS&lt;=1'b0; //行同步信号置0 if(H_Cont==H_FRONT+H_SYNC-1) //如果行计数器等于行前沿+行同步-1 VGA_HS&lt;=1'b1; //行同步信号置1 if(H_Cont&gt;=H_BLANK) //如果行计数器大于等于行空白总时长 X&lt;=H_Cont-H_BLANK; //X等于行计数器-行空白总时长 （X为当前行第几个像素点） else X&lt;=0; //否则X为0 end always@(posedge VGA_HS) begin if(V_Cont&lt;V_TOTAL) //如果场计数器小于行总时长 V_Cont&lt;=V_Cont+1'b1; //场计数器+1 else V_Cont&lt;=0; //否则场计数器清零 if(V_Cont==V_FRONT-1) //如果场计数器等于场前沿空白时间-1 VGA_VS&lt;=1'b0; //场同步信号置0 if(V_Cont==V_FRONT+V_SYNC-1) //如果场计数器等于行前沿+场同步-1 VGA_VS&lt;=1'b1; //场同步信号置1 if(V_Cont&gt;=V_BLANK) //如果场计数器大于等于场空白总时长 Y&lt;=V_Cont-V_BLANK; //Y等于场计数器-场空白总时长 （Y为当前场第几行） else Y&lt;=0; //否则Y为0 end reg valid_yr; always@(posedge CLK_to_DAC) if(V_Cont == 10'd32) //场计数器=32时 valid_yr&lt;=1'b1; //行输入激活 else if(V_Cont==10'd512) //场计数器=512时 valid_yr&lt;=1'b0; //行输入冻结 wire valid_y=valid_yr; //连线 reg valid_r; always@(posedge CLK_to_DAC) if((H_Cont == 10'd32)&amp;&amp;valid_y) //行计数器=32时 valid_r&lt;=1'b1; //像素输入激活 else if((H_Cont==10'd512)&amp;&amp;valid_y) //行计数器=512时 valid_r&lt;=1'b0; //像素输入冻结 wire valid = valid_r; //连线 wire[10:0] x_dis; //像素显示控制信号 wire[10:0] y_dis; //行显示控制信号 assign x_dis=X; //连线X assign y_dis=Y; //连线Y parameter char_line00=272'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, char_line01=272'h00000000000000000000000000000000000000000000000000000000000000000000, char_line02=272'h00400C0000000000000000000000000000C008000000000000000000000000000000, char_line03=272'h00700E0000000180000000000000000000E00C0000000000000000800180000000C0, char_line04=272'h00600C00000003C0000000000000000000C01C0000000000000000FFFF80000001E0, char_line05=272'h00600C3003FFFC000000000000000080008018000000000000800080018003FFFE00, char_line06=272'h1FFFFFF8000180007FFE7FF003C80380008018007C1F03C803800080018000000000, char_line07=272'h00600C0000018000180E18180E3803800104301018040E3803800080018000000000, char_line08=272'h00600C00000180001802180C080803800FFE30381804080803800080018000000000, char_line09=272'h00600C000001800018031806180802800C0C7FF818041808028000FFFF8000000000, char_line0a=272'h007FFC000001800018011806300406C00C0C60300C08300406C00080018000000000, char_line0b=272'h00600C000001800018001806300404C00C0CC0300C08300404C00080018000000018, char_line0c=272'h00600C000001801018081806200004C00C0C80300C08200004C0008001800000003C, char_line0d=272'h007FFC000001803818081806600004C00C0D00300C08600004C0008001803FFFFFFE, char_line0e=272'h00600C003FFFFFFC1818180C60000C600C0D4030061060000C6000FFFF8000018000, char_line0f=272'h00600C10000180001FF81818600008600C0E20300610600008600080010000018000, char_line10=272'h00600C380001800018181FF0600008600C0C10300610600008600008200000418000, char_line11=272'h3FFFFFFC0001800018081800600008600FFC1830073060000860000C382000718800, char_line12=272'h003208000001800018081800603F1FF00C0C18300320603F1FF0080C307000E18600, char_line13=272'h00618C000001800018001800600C10300C0C0C300320600C10300C0C307000C18300, char_line14=272'h00C106000001800018001800600C10300C0C08300320600C1030060C30C001818180, char_line15=272'h018101C00001800018001800300C10300C0C003001C0300C1030030C30C0038180C0, char_line16=272'h030104FC0001800018001800300C30300C0C003001C0300C3030038C318003018060, char_line17=272'h0C010E380001800018001800180C20180C0C003001C0180C2018018C330006018070, char_line18=272'h187FF0000001800018001800180C20180C0C003001C0180C2018018C36000C018038, char_line19=272'h6001000000018000180018000C1060180C0C003000800C106018008C380018018038, char_line1a=272'h00010000000180007E007E0003E0F83E0C0C0030008003E0F83E000C301010018010, char_line1b=272'h00010000003F800000000000000000000FFC0C60000000000000000C303820738000, char_line1c=272'h00010060000F800000000000000000000C0C03E00000000000001FFFFFFC001F8000, char_line1d=272'h1FFFFFF00007000000000000000000000C0801C00000000000000000000000070000, char_line1e=272'h00000000000000000000000000000000000000800000000000000000000000020000, char_line1f=272'h00000000000000000000000000000000000000000000000000000000000000000000; reg[8:0] char_bit; always@(posedge CLK_to_DAC) if(X==10'd144)char_bit&lt;=9'd272; //当显示到144像素时准备开始输出图像数据 else if(X&gt;10'd144&amp;&amp;X&lt;10'd416) //左边距屏幕144像素到416像素时 416=144+272（图像宽度） char_bit&lt;=char_bit-1'b1; //倒着输出图像信息 reg[29:0] vga_rgb; //定义颜色缓存 always@(posedge CLK_to_DAC) if(X&gt;10'd144&amp;&amp;X&lt;10'd416) //X控制图像的横向显示边界：左边距屏幕左边144像素 右边界距屏幕左边界416像素 begin case(Y) //Y控制图像的纵向显示边界：从距离屏幕顶部160像素开始显示第一行数据 10'd160: if(char_line00[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; //如果该行有数据 则颜色为红色 else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; //否则为黑色 10'd162: if(char_line01[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd163: if(char_line02[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd164: if(char_line03[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd165: if(char_line04[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd166: if(char_line05[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd167: if(char_line06[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd168: if(char_line07[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd169: if(char_line08[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd170: if(char_line09[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd171: if(char_line0a[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd172: if(char_line0b[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd173: if(char_line0c[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd174: if(char_line0d[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd175: if(char_line0e[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd176: if(char_line0f[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd177: if(char_line10[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd178: if(char_line11[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd179: if(char_line12[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd180: if(char_line13[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd181: if(char_line14[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd182: if(char_line15[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd183: if(char_line16[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd184: if(char_line17[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd185: if(char_line18[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd186: if(char_line19[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd187: if(char_line1a[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd188: if(char_line1b[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd189: if(char_line1c[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd190: if(char_line1d[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd191: if(char_line1e[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd192: if(char_line1f[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; default:vga_rgb&lt;=30'h0000000000; //默认颜色黑色 endcase end else vga_rgb&lt;=30'h000000000; //否则黑色 assign VGA_R=vga_rgb[23:16]; assign VGA_G=vga_rgb[15:8]; assign VGA_B=vga_rgb[7:0]; endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c376c581e2723a330c1841083fe74c/" rel="bookmark">
			I2C 时序详解，精确到每一个时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 输入输出模式设置 官方文档中有这样的介绍：
SDA和SCL都是双向线路，都通过一个电流源或上拉电阻连接到正的电源电压，当总线空闲时，这两条线路都是高电平，连接到总线的器件输出级必须是漏极开路或集电极开路才能执行线与的功能；2C 总线上数据的传输速率在标准模式下可达100kbit/s，在快速模式下可达400kbit/s，在高速模式下可达 3.4Mbit/s ；连接到总线的接口数量只由“总线电容是 400pF”的限制决定
这里就涉及到「漏极/集电极开路」、「上拉电阻」和「线与」两个概念，而这绝对可以算得上是实现 I2C 总线协议的关键所在。
1.1 漏极/集电极开路 1.1.1 漏极/集电极开路结构 集电极开路输出的结构下图1所示，右边的那个三极管集电极什么都不接，所以叫做集电极开路（左边的三极管为反相之用，使输入为“0”时，输出也为“0”）。
对图1
当左端的输入为“0”时，前面的三极管截止（即集电极C跟发射极E之间相当于断开），所以5V电源通过1K电阻加到右边的三极管上，右边的三极管导通（即相当于一个开关闭合）；
当左端的输入为“1”时，前面的三极管导通，而后面的三极管截止（相当于开关断开）。
将图1简化成图2的样子。图2中的开关受软件控制，“1”时断开，“0”时闭合。
输入“0”时，开关闭合，输出直接接地，所以输出电平为0。
输入“1”时，开关断开，输出端悬空，即高阻态。这时电平状态未知；如果后面一个电阻负载（即使很轻的负载）到地，那么输出端的电平就被这个负载拉到低电平了，所以这个电路是不能输出高电平的。
再看图3。
图三中那个1K的电阻即是上拉电阻。
输入“0”时，开关闭合，有电流从1K电阻及开关上流过然后直接接地，所以输出电平依然为0，即低电平。
输入“1”时，开关断开，输出端悬空，此时输出端通过一个1K电阻上拉，电路输出高电平；
对于漏极开路（OD）输出，跟集电极开路输出是十分类似的。将上面的三极管换成场效应管即可。这样集电极就变成了漏极，OC就变成了OD，原理分析是一样的；
1.1.2 单片机GPIO口开漏模式 单片机GPIO口设置为开漏模式时，即可读外部状态也可以对外输出（高电平或低电平），但是需要外接上拉电阻；
GPIO对外输出：
1 低电平（逻辑0，IO被接在GND上，只能是低电平）
2 高阻态（逻辑1，IO可以被拉高或者拉低）两种状态，而所谓的“高电平”其实是在输出逻辑1、IO为高阻态时，IO被外部或者内部上拉电阻拉高的。
GPIO读外部状态：
1 SDA=0时，SDA脚在IC内部被直接接在GND上，它只能是低电平，外部器件也无法把SDA脚拉高，这叫拉低。
2 SDA=1时，SDA脚为高阻态，（相当于在万用板上焊了一根IO，这个IO谁都不接，这就是高阻了），这时SDA可以被别的器件拉低或者拉高，即，这时SDA脚的控制权是“释放状态”，如果谁都不去管这个高阻态的脚，这个脚会被上拉电阻拉高以保证不会被空气里的电磁波干扰而高低乱跳。
备注！！！这也是为什么每次主机发送一个字节等待从设备ACK应答信号时，主机要设置SDA=1的原因；释放总线，让从设备控制SDA为低，以做应答信号；
1.1.3 漏极/集电极开路特点 漏极/集电极开路的重要特点：
可以将多个开漏输出的Pin，连接到一条线上。形成 “与逻辑” 关系（线与）。
如下图，当PIN_A、PIN_B、PIN_C任意一个变低后，开漏线上的逻辑就为0了。这也是I2C，SMBus等总线判断总线占用状态的原理。如果作为输出必须接上拉电阻。
接容性负载时，下降延是芯片内的晶体管，是有源驱动，速度较快；上升延是无源的外接电阻，速度慢。如果要求速度高电阻选择要小，功耗会大。所以负载电阻的选择要兼顾功耗和速度。
开漏模式与准双向模式相似，但是没有内部上拉电阻。开漏模式的优点是电气兼容性好，外部上拉电阻接3V电源，就能和3V逻辑器件接口，如果上拉电阻接5V电源，又可以与5V逻辑器件接口。此外，开漏模式还可以方便地实现“线与”逻辑功能；
1.2 小结 GPIO模拟I2C总线应设置为开漏（OD）模式；需要注意的是：如果多主的话，这二者必须是OD的，如果只有一个主，时钟不需要OD。
但是实际来说，一主多从模式下，
以STM32为例，SCL设置为推挽输出，SDA作为输出时，设置为推挽输出（推挽电路速度快，输出能力强），作为输入时，浮空输入，需外接上拉电阻；个人感觉类似于开漏模式；
C51，都配置为准双向/弱上拉模式即可，
按理说SCL设置为推挽输出，SDA作为输出时，设置为推挽输出，作为输入时，开漏模式，需外接上拉电阻；也可以，没有实验过；
2 关于上升沿和下降沿分析 详细可以参考：分析一下到底是上升沿还是下降沿读写数据
http://blog.csdn.net/dagefeijiqumeiguo/article/details/73824462
所谓读即是指MCU从器件的数据总线上根据一定的时序来读取器件的数据。一般而言，MCU提供一个边沿信号(上升沿或者下降沿均可)告诉器件可以发数据了，器件检测到边沿信号以后，立即在数据总线上更新数据，待数据稳定以后，MCU即可读取数据。所以一般所说的上升沿(下降沿)开始读数据是不准确地说法，上升沿(下降沿)这是数据总线上的数据发生改变，MCU并没有在此时刻读取数据，而是等待数据稳定之后才开始读取数据。
所谓写即是指MCU向器件写入数据，其操作是：先将数据放置在数据总线上，等待其稳定之后，MCU产生一个边沿信号，将数据写入器件
总结一下就是，可以简单理解为“写稳读变”。
写：MCU在数据总线上的数据稳定之后，检测边沿信号写数据到器件；
读：MCU发出边沿信号告诉器件发送数据，检测到边沿信号之后，器件改变（更新）数据，等待稳定之后MCU读取数据
那么I2C总线读写数据怎么样的呢；
个人理解是这样：
写：MCU在数据总线上的数据稳定之后，检测边沿信号（上升沿）写数据到器件；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c376c581e2723a330c1841083fe74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aec633124ab2e633c91f978fe05974a/" rel="bookmark">
			激活函数之logistic sigmoid函数介绍及C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logistic sigmoid函数：
logistic sigmoid函数通常用来产生Bernoulli分布中的参数ø，因为它的范围是(0,1)，处在ø的有效取值范围内。logisitic sigmoid函数在变量取绝对值非常大的正值或负值时会出现饱和(saturate)现象，意味着函数会变得很平，并且对输入的微小改变会变得不敏感。
logistic sigmoid函数在深度学习中经常用作激活函数。有时为了加快计算速度，也使用称为fast sigmoid 函数，即：σ(x)=x/(1+|x|)
Logistic function：A logistic function or logistic curve is a common “S” shape(sigmoid curve), with equation:
where, e = the natural logarithm base(also known as Euler’s number); x0 = the x-value of the sigmoid’s midpoint; L = the curve’s maximum value; k = the steepness of the curve. For values of x in the range of real numbers from -∞ to +∞.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aec633124ab2e633c91f978fe05974a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab20dcffdc4cad1e10476eb16999e2c/" rel="bookmark">
			C# 一些常用的框架分享（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/hegx/p/6093936.html 直接上地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba18d6a46854f81017261f36a3212c75/" rel="bookmark">
			计算机CPU处理，吞吐量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的吞吐量：
计算机系统的吞吐量是指流入,处理和流出系统的信息的速率.它取决于信息能够多快地输入内存,CPU能够多快地取指令,数据能够多快地从内存取出或存入,以及所得结果能够多快地从内存送给一台外围设备.这些步骤中的每一步都关系到主存,因此,系统吞吐量主要取决于主存的存取周期. 由于上述原因,采用双端口存储器可以增加主存的有效速度. 那么，下面的简述就说得不是很准确啦，只说吞的量，不说出的量，不过，一般情况，吞的量有多强，那么，吐的量就差不多.
网络中的数据是由一个个数据包组成，防火墙对每个数据包的处理要耗费资源。吞吐量是指在没有帧丢失的情况下，设备能够接受的最大速率。其测试方法是：在测试中以一定速率发送一定数量的帧，并计算待测设备传输的帧，如果发送的帧与接收的帧数量相等，那么就将发送速率提高并重新测试；如果接收帧少于发送帧则降低发送速率重新测试，直至得出最终结果。吞吐量测试结果以比特/秒或字节/秒表示。
吞吐量和报文转发率是关系防火墙应用的主要指标，一般采用FDT(Full Duplex Throughput)来衡量，指64字节数据包的全双工吞吐量，该指标既包括吞吐量指标也涵盖了报文转发率指标。 随着Internet的日益普及，内部网用户访问Internet的需求在不断增加，一些企业也需要对外提供诸如WWW页面浏览、FTP文件传输、DNS域名解析等服务，这些因素会导致网络流量的急剧增加，而防火墙作为内外网之间的唯一数据通道，如果吞吐量太小，就会成为网络瓶颈，给整个网络的传输效率带来负面影响。因此，考察防火墙的吞吐能力有助于我们更好的评价其性能表现。这也是测量防火墙性能的重要指标。
吞吐量的大小主要由防火墙内网卡，及程序算法的效率决定，尤其是程序算法，会使防火墙系统进行大量运算，通信量大打折扣。因此，大多数防火墙虽号称100M防火墙，由于其算法依靠软件实现，通信量远远没有达到100M,实际只有10M-20M。纯硬件防火墙，由于采用硬件进行运算，因此吞吐量可以达到线性90-95M,是真正的100M防火墙。 对于中小型企业来讲，选择吞吐量为百兆级的防火墙即可满足需要，而对于电信、金融、保险等大公司大企业部门就需要采用吞吐量千兆级的防火墙产品。
网络中的数据是由一个个数据包组成，防火墙对每个数据包的处理要耗费资源。吞吐量是指在不丢包的情况下单位时间内通过防火墙的数据包数量。这是测量防火墙性能的重要指标。
吞吐量是在一个给定的时间段内介质能够传输的数据量，使用 Mb/s 进行度量同的吞吐量。 吞吐量 VS. 带宽
吞吐量和带宽是很容易搞混的一个词，两者的单位都是Mbps.先让我们来看两者对应的英语，吞吐量:throughput ; 带宽: Max net bitrate 。当我们讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数。我们可以说以太网的带宽是10Mbps。但是，我们需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。我们倾向于用“吞吐量”一次来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。 一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。
单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。
系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间
QPS（TPS）：每秒钟request/事务 数量
并发数： 系统同时处理的request/事务数
响应时间： 一般取平均响应时间
（很多人经常会把并发数和TPS理解混淆）
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca335cf35dc5670904ec7c06e5f0b620/" rel="bookmark">
			腾讯视频下载的qlv格式转换为MP4格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然在腾讯视频上看到一个比较好的视频，下载下来想随时观看，无赖格式是qlv用其他播放器无法播放，只能用腾讯视频播放器，这样很不方便，然后就在万能百度上搜索了一下方法，确实可以将qlv转换为mp4格式，在这里总结一下方法，方便日后使用。
首先需要下载腾讯视频客户端，然后找到设置，如下图所示：
点击进入设置界面，然后点击下载设置：
进入该目录，然后清空该目录（该目录为缓存目录）。
清空目录后，然后回到腾讯视频客户端，播放自己想要转换的视频，注意不能点击下载，不然会有缓存文件出现。
待视频缓冲完成后，再次进入缓存目录：
进入vodcache发现里面还有文件夹，直接进入到最里面：
里面有很多tdl格式的文件，这些文件就是用来合成MP4格式的文件，不能删除，
然后打开cmd执行命令：
cd 缓存路径 回车
copy/B c*.tdl vv.mp4（这个地方缓存文件的开头是什么就将c替换成什么）
回车
即可生成mp4格式视频
生成过后的缓存目录会多一个MP4格式的视频文件：
如果大家有更好的办法，希望大家说出来一起讨论，至于这个转换的原理，我也不是很清楚，就不在多说了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b647dffe78c70256c15f6331b1761586/" rel="bookmark">
			神经网络---learnwh实现直线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 %leamwh 是 Widrow-Hoff规则（LMS算法）的学习函数 %先生成加了噪声的线性函数 P=-5:5; d=3*P-7; randn('state',2); d=d+randn(1,length(d))*1.5; figure(1);plot(P,d,'ro'); %循环迭代 P=[ones(1,length(d));P] Max = 150; lp.lr=0.01; ep1=0.1 %均方差终止阈值 ep2=0.0001 %权值变化终止阈值 w=[0,0]; for i=1:Max fprintf('第 %d 次迭代：\n',i); e=d-pureline(w*P); %求得误差向量 ms(i)=mse(e); oms=ms(i) if(ms(i)&lt;ep1) fprintf('均方差小于指定的值而停止'); break; end dw=learnwh([],P,[],[],[],[],e,[],[],[],lp,[]) if(norm(dw)&lt;ep2) fprintf('权值变化小于指定的值而停止'); break; end w =w+dw; end figure(2); subplot(2,1,1); plot(P(2,:),d,'o'); title('离散点与直线拟合结果'); xlabel('x');ylabel('y'); axis([-6,6,min(d)-1,max(d)+1]); x1=-5:0.1:5; y1=w(1)+w(2)*x1; hold on; plot( x1,y1); subplot(2,1,2); x2=1:i; semilogy(x2,ms(x2),'-o'); xlabel('迭代次数');ylabel('MSE'); title('均方差下降曲线'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5415a95bafc851206ef4b10f1a058e/" rel="bookmark">
			计算动态字符串宽度,多行实现展开收起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算动态字符串宽度,多行实现展开收起 思路: 创建span元素,添加到页面隐藏,将字符串添加到span中,获取span宽度, 与父容器宽度比对,超过行数,截取字符串(可设置自定义属性,存储原始字符串) - 知识点 - getComputedStyle 计算属性 - offsetWidth 元素相对父元素的偏移宽度 - [程序员福利广告] - 外卖红包群 +微信 1165763207 发送[ 外卖 ] 自动获取入群邀请
codepen在线效果预览 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;计算动态字符串宽带,多行实现展开收起&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } #box { width: 300px; margin: 0 auto; font-size: 14px; line-height: 16px; border: 1px solid red; word-break: break-all; /* 打断所有单词 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5415a95bafc851206ef4b10f1a058e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c4cde76292522cd5bb90de995fd482c/" rel="bookmark">
			算法题练习系列之（二）：矩阵最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-----------------------------------------------------------------------------------------------------------
时间限制：1秒 空间限制：32768K 代码长度限制 100 KB
----------------------------------------------------------------------------------------------------------- 题目描述: 编写一个程序输入一个mXn的矩阵存储并输出，并且求出每行的最大值和每行的总和。要求把每行总和放入每行最大值的位置，如果有多个最大值，取下标值最小的那一个作为最大值。 最后将结果矩阵输出。 输入描述: 输入的第一行包括两个整数m和n(1&lt;=m,n&lt;=100)，分别代表矩阵的行和列的维数。 接下来的m行每行有n个数，代表矩阵的元素。 输出描述: 可能有多组测试数据，对于每组数据，输出按题目要求执行后的矩阵。 输入例子: 3 3 1 1 1 1 1 1 1 1 1 3 3 3 2 3 2 3 2 3 2 3 输出例子: 3 1 1 3 1 1 3 1 1 8 2 3 2 7 2 8 2 3 -----------------------------------------------------------------------------------------------------------
实现思路： (1).用二维数组存储矩阵； (2).两层循环二维数组，第一层以行为维度，第二层以列为维度；
(3).第二层循环执行时，将矩阵每行的元素加和，并且寻找该行最大元素的位置；
(4).每执行完一次全部的二层循环后，将得到的该行数据和赋值给最大值对应位置，循环第一层循环，逐一处理矩阵中的每行数据。 -----------------------------------------------------------------------------------------------------------
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c4cde76292522cd5bb90de995fd482c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a490b325a254ddfca6ec536575c0a0b6/" rel="bookmark">
			JSON数组形式字符串转换为Map数组（转为其他的Bean的话，请参考自行变形）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.zkn.newlearn.json; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import java.util.List; import java.util.Map; /** * Created by zkn on 2016/8/22. */ public class JsonToMapTest02 { public static void main(String[] args){ String strArr = "[{\"0\":\"zhangsan\",\"1\":\"lisi\",\"2\":\"wangwu\",\"3\":\"maliu\"}," + "{\"00\":\"zhangsan\",\"11\":\"lisi\",\"22\":\"wangwu\",\"33\":\"maliu\"}]"; //第一种方式 List&lt;Map&lt;String,String&gt;&gt; listObjectFir = (List&lt;Map&lt;String,String&gt;&gt;) JSONArray.parse(strArr); System.out.println("利用JSONArray中的parse方法来解析json数组字符串"); for(Map&lt;String,String&gt; mapList : listObjectFir){ for (Map.Entry entry : mapList.entrySet()){ System.out.println( entry.getKey() + " " +entry.getValue()); } } //第二种方式 List&lt;Map&lt;String,String&gt;&gt; listObjectSec = JSONArray.parseObject(strArr,List.class); System.out.println("利用JSONArray中的parseObject方法并指定返回类型来解析json数组字符串"); for(Map&lt;String,String&gt; mapList : listObjectSec){ for (Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a490b325a254ddfca6ec536575c0a0b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7987d53263477f50e3b18f99ed39a47/" rel="bookmark">
			stl：find _first_of与search用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std; int main() { string str("i love you"); string str1 = "youf"; string::iterator ix = search(str.begin(), str.end(), str1.begin(), str1.end()); if (ix == str.end()) cout &lt;&lt; "connot find it" &lt;&lt; endl; else cout &lt;&lt; ix-str.begin(); int n=str.find_first_of("sdaadosf"); cout &lt;&lt; n &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed419eabd11173c8bf6b14bb5c483ceb/" rel="bookmark">
			香港必理痛儿童退烧止痛药水 用量详解 (Panadol)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		香港必理痛儿童退烧止痛药水 用量详解 仅供参考。
请家长们务必先核对下面的'适用品牌与型号'，用药安全第一！ 每次用量速查表： 体重每次服药剂量范围5KG2.08 - 3.13毫升6KG2.5 - 3.75毫升7KG2.92 - 4.38毫升8KG3.33 - 5.00毫升9KG3.75 - 5.63毫升10KG4.17 - 6.25毫升11KG4.58 - 6.88毫升12KG5.0 - 7.50毫升13KG5.42 - 8.13毫升14KG5.83 - 8.75毫升15KG6.25 - 9.38毫升16KG6.67 - 10.00毫升17KG7.08 - 10.63毫升18KG7.5 - 11.25毫升19KG7.92 - 11.88毫升20KG8.33 - 12.50毫升21KG8.75 - 13.13毫升22KG9.17 - 13.75毫升23KG9.58 - 14.38毫升24KG10.0 - 15.00毫升25KG10.42 - 15.63毫升26KG10.83 - 16.25毫升27KG11.25 - 16.88毫升28KG11.67 - 17.50毫升29KG12.08 - 18.13毫升30KG12.5 - 18.75毫升35KG14.58 - 21.88毫升40KG16.67 - 25.00毫升45KG18.75 - 28.13毫升50KG20.83 - 31.25毫升 适用品牌与型号： Panadol (R) children's pain &amp; fever reliever 必理痛儿童退烧止痛药水 注册号: HK-52694 每一瓶必理痛含有60毫升药水 计算公式： 最小服用剂量(毫升) = 儿童体重(kg) x 10 / 120 x 5 最大服用剂量(毫升) = 儿童体重(kg) x 15 / 120 x 5 说明书原文： 5毫升为1茶匙，每5毫升药水（1茶匙）含有120毫克Acetaminophen。每四小时服一次，或按医生指示服用。 服用剂量是按儿童本身的体重而计算的：每次10-15毫克/公斤(Acetaminophen／体重)，即每1公斤体重每次需服用10至15毫克Acetaminophen。 请勿相隔少于四小时服食此药物。不可服用多于指定剂量。24小时.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed419eabd11173c8bf6b14bb5c483ceb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/472/">«</a>
	<span class="pagination__item pagination__item--current">473/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/474/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>