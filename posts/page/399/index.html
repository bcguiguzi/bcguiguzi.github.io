<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341daff68d9ab5f17c2b8a885b2db85a/" rel="bookmark">
			浅谈I2S协议、PDM麦克风
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要调试硅麦，硅麦输出PDM信号，需要转换芯片把PDM信号转成I2S信号输出。
I2S协议 一、基本介绍 I2S（Inter-IC Sound）是飞利浦公司针对数字音频设备（如CD播放器、数码音效处理器、数字电视音响系统）之间的音频数据传输而制定的一种总线标准。标准的I2S总线电缆是由3根串行导线组成的：1根是时分多路复用（简称TDM）数据线；1根是字选择线；1根是时钟线。
二、协议时序格式 1.串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数。
2. 帧时钟LRCLK，(也称WS)，用于切换左右声道的数据。LRCLK为“1”表示正在传输的是右声道的数据，为“0”则表示正在传输的是左声道的数据。LRCLK的频率等于采样频率。
3.串行数据SDATA，就是用二进制补码表示的音频数据。
有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为主时钟，也叫系统时钟（Sys Clock），是采样频率的256倍或384倍。
随着技术的发展，在统一的 I2S接口下，出现了多种不同的数据格式。根据SDATA数据相对于LRCK和SCLK的位置不同，分为左对齐（较少使用）、I2S格式（即飞利浦规定的格式）和右对齐（也叫日本格式、普通格式）。
(1)标准格式
(2)左对齐格式
(3)右对齐格式
PDM麦克风 一、PDM基本概念 PDM代表脉冲密度调制。然而，更好的简称是“1比特过采样音频”，因为它只不过是一个高采样率、单比特的数字系统。如果要找一个优点的话，那就是采样率是音频CD的好几倍，且用一个适当的方式将字长从16bit减小到1bit，这将作为一个PDM系统的基础。
PDM只用1bit来传输音频，在概念上和可实行度上比PCM更简单。它正被普遍用在手机内将音频从麦克风传输给信号处理器。PDM在理论上很适合这个任务，因为它带来了数字的好处，例如低噪声和免于干扰信号，且成本较低。
数据线上的1比特数据在主时钟的上升沿或下降沿时被认为有效。大多数PDM麦克风支持双声道操作，一个麦克风在主时钟的上升沿时数据线上的数据有效，第二个麦克风在在下降沿时有效。在非有效边沿，数据输出是高阻抗。两个麦克风的数据线能被简单地连接在一起。PDM接收器有能力分离两个比特流。
PDM麦克风 PDM麦克风也被称作数字麦克风，包括如下部分：
一个麦克风要素。典型的是一个驻极体容器。一个模拟预放大器。一个PDM调制器。接口逻辑。 参考文档
[1] https://blog.csdn.net/q2519008/article/details/80413695
[2] https://blog.csdn.net/wzz4420381/article/details/51477725
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab783bc47b4516e517a329427316b28c/" rel="bookmark">
			数据结构与算法05 选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 选择排序工作原理是，每一次从待排序的数据元素中找出最小（或最大）的一个元素，顺序放入已排好序的数列，直到全部待排序的数据元素排完。当数据序列长度为n时，须进行n-1次循环。具体步骤：
首先从原始数组中选择最小的数及其位置，将其和位于第1个位置的数据交换。接着从剩下的n-1个数据中找出最小数及其位置，将其和第2个位置的数据交换不断重复，直到第n-1次结束。 JAVA代码实现 public class SelectSort { public static void main(String[] args) { int[] array = new int[]{101, 34, 119, 1}; SelectSort.selectSort(array); } public static void selectSort(int[] arr){ int index; int min; for (int i = 0; i &lt; arr.length - 1; i++) { index = i; min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) { if(min &gt; arr[j]){ index = j; min = arr[j]; } } if(index !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab783bc47b4516e517a329427316b28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e79bbfa3226d693fff978cd528e75ca/" rel="bookmark">
			pyinstaller no module named ‘pkg_resources.py2_warn‘解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用pyinstaller打包python编写好的程序时，遇到了一些问题，其中有一个是no module named 'pkg_resources.py2_warn’
经过一些探索后，找到了解决方法：
1.先用pyinstaller -D(F) xxx.py生成一下(不一定能正常运行)
2.(关键)经过第一步之后，目录下有个.spec文件，用记事本打开，里面有个hiddenimports，在这条里面加上pkg_resources.py2_warn
3.再次用pyinstaller,注意这时候输入的命令是pyinstaller -D(F) xxx.spec
4.经过步骤2就可以解决这个问题，若仍然提示no module named XXXXX ,则再次写入到hiddenimports
5.需要经过几次调试，建议先用-D处理没问题之后再-F。
经过网上查询还有另一种解决方法：
1.pip uninstaller setuptools
2.pip installer setuptools==44.0.0
(不过这种方法对setuptools进行降级处理，可能有些功能不能使用)
经过这两种方法，程序可以正常运行。
2021年3月更新：
经过又一阵时间测试，发现在新版本中pyinstaller已经修复了这个问题，故不需要再设置参数。另外推荐给大家配置python的一个好的方法是Anaconda，使用Anaconda可以配置好python的环境，并且可以创建多个python环境，还可以自由切换。
现在不推荐大家使用pip installer setuptools==44.0.0 ，直接全部使用最新版本即可。
我推荐大家使用pyinstaller -D，这种方式的稳定性更好
另外如果打包后文件在其他系统运行出现了错误，可以参考我的一个解决方法
pyinstaller生成的exe文件在其他电脑打不开的解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e3f6d49067bb81580eae511525ff02/" rel="bookmark">
			开源智造Odoo免费开源ERP大型钢材贸易供应链案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 案例介绍 开源智造咨询有限公司（OSCG）是Odoo香港和大陆地区的官方合作伙伴，是Odoo金牌服务商。我们提供专业的Odoo ERP业务咨询/规划、系统实施/培训、二次开发等技术服务。
佛山宝裕金属有限公司始创于1999年，是一家以金属经营为主，集供应链金融和股权投资为一体的多元化企业。自创立以来，宝裕控股始终坚持“敢为您承诺”理念，致力于金属供应链的核心业务，深耕不锈钢的代理、加工、仓储、配送、销售，逐渐成长为行业龙头，贴身服务全国下游企业达上千家。在过去二十年的发展历程中，与宝钢、鞍钢、太钢等国内特大型钢铁龙头企业保持良好战略合作关系。依托金属板块的资源优势，逐步拓展金融和投资板块，进一步扩大业务版图，不断增强企业运营实力及行业影响力。
面对日益激烈的竞争局面，宝裕集团迎接市场挑战，创新经营模式，年营业额逐年攀升， 2016年突破百亿元。凭借市场卓越表现，宝裕集团连续三年被佛山市政府评为“大型骨干企业”，同时也被推选为中国金属材料流通协会不锈钢分会副会长单位及佛山市金属材料行业协会会长单位。
宝裕基于Odoo的ERP项目，于2017年初开始选型，年中开始实施，年底上线运行。宝裕在上线Odoo ERP之前，他们有一个用了十多年的不锈钢贸易行业软件，主要处理订单及进销存，还有金蝶财务软件，以及其他一些自研的小软件。现有行业软件，功能较弱，基本上只有一个单据记录功能，即，实际业务已经完成，事后将销售、采购、入库、出库等单据录入到系统中。对业务部门来说，该软件只有简单的数据查询用处。
新的ERP系统，业务部门希望ERP可以帮助提升业务处理效率；管理部门希望ERP可以帮助实现价格、毛利、信用、资金风险等业务管控要求；财务部门希望ERP可以实现业务财务一体化，可以自动结算，实时获取财务报表。
宝裕CIO胡总考察了市面上的一些软件，行业类软件对不锈钢行业的进销存等基本业务支持较好，业务部门较为喜欢。但业务管控功能较弱，业财一体化功能没有，基本不支持个性化扩展，融资贸易等新需求难以实现。ERP类软件则相反，财务功能很强，个性化扩展、二次开发能力较强，但对不锈钢行业特性支持不太好。
胡总经过几个月的考察、比较，和公司老总多次讨论后，决定选择功能插件多、扩展能力强、生态圈较好的开源ERP Odoo作为集团信息化平台软件。几经比较之后，宝裕选择了Odoo金牌服务商开源智造帮助实施Odoo系统。
开源智造提供Odoo技术服务超过8年，是国内最早的Odoo服务商，服务了大量客户，积累了丰富的Odoo实战经验。开源智造充分利用Odoo丰富的功能插件，帮助宝裕构建了客户管理、合同管理、分货管理、采购计划、仓库管理、物流管理、外协加工、客诉管理、开票管理、收付款管理、资金管理等业务需求。针对不锈钢贸易行业一些特性需求，开源智造ERP顾问和宝裕IT部门一起，深入调研讨论，共同确定最佳实现方案。例如产品主数据，不锈钢钢卷，有牌号、产地、类型、宽幅、厚度、炉号、捆包号等多种规格属性，尤其是宽幅和厚度，理论上无限多种，产品主数据如何建模，炉号、捆包号如何管理？又如切割等外协加工管理，开源智造基于Odoo现有的，第三方仓库加工管理插件，二次开发增加了加工成本核算等功能，事半功倍地解决了问题。
功能需求 技术方案文档目录展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc09c793424597c7eaf93e5fbb189aab/" rel="bookmark">
			linux下安装mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于本人要在CentOS上部署一个Java项目，这个项目里面要对数据库进行操作，所以第一件事情就是安装数据库啦！现在本人将来带领你们一步一步实现MySQL数据库的安装。
首先，在CentOS下，我们可以直接通过yum命令来安装数据库。在安装数据库之前，我们应该先查看自己的CentOS上是否已经安装了MySQL数据库，如果安装了就先卸载掉。
（1）查看自己是否安装了MySQL数据库
[root@localhost /]# rpm -qa | grep mysql
得到的结果如下：
这样说明已经安装了数据库，我们可以先对它进行卸载。。。
（2）卸载过程
卸载有两种方式，一种是普通删除，另一种是强力删除，当MySQL数据库有其它的依赖文件时，也进行删除。
分别是：rpm -e mysql 和rpm -e --nodeps mysql
（3）安装过程
首先，我们通过命令：yum list | grep mysql来查看yum上提供的数据库可下载版本。
我们选择安装 mysql.i686，mysql-devel.i686，mysql-server.i686就行了。使用命令：
yum -y install mysql mysql-server mysql-devel
就可以安装好MySQL数据库了。。。
（4）数据库的相关配置
安装完MySQL数据库后，会发现多出了一个mysqld服务，这就是我们的数据库服务，启动它就是启动数据库。
启动方式：service mysqld start
我们可以使用命令：chkconfig --list | grep mysqld来查看是否开机自动启动。如果2~5的都是on
说明是开机自动启动，否则如果不是。我们可以通过命令chkconfig mysqld on来设置成开机自动启动。
嗯，到了这里，我们就应该启动数据库设置密码了。
（5）数据库密码设置
先启动mysqld服务，即：service mysqld start，然后执行命令
mysqladmin -u root -p password 'root'
意思是把root用户的密码设置为root，现在我们就可以登录MySQL数据库了 。
到了这里，本人就把数据库的安装步骤全部讲述完毕。
接下来，我们一起来看看数据库的配置文件。
数据库的配置信息文件是etc/my.cnf，我们查看内容如下：
其中的datadir是MySQL数据库的存放路径，上面表示本人的数据在CentOS里的/var/lib/mysql目录下。
上面的mysql和test就是数据库安装后默认的两个数据库文件。
还有一个数据库日志文件，存放位置是：var/log/mysqld.log。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abae5c4a6b73e0e18a9b6040e21579eb/" rel="bookmark">
			sRGB颜色空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sRGB空间是惠普公式和微软公司于1996年一起开发的用于显示器、打印机、互联网图像存储的一种标准RGB颜色空间。
这种颜色空间在编码上充分利用了值为2.2的伽马校正系数，其很大程度上是为了和当时主流的CRT显示器的特性相匹配。
使用sRGB颜色空间对颜色进行编码的一些图像文件，可以不经过转换就能在当时的CRT显示器中正常显示。其原因是，在数据采集端，图片对场景中的颜色信息，利用编码伽马值编码到图片的像素颜色信息中去了，作为数据还原端的CRT显示器可以不用经过额外处理，就能正确显示。
sRGB定义了红、绿、蓝三基色。从CIExy坐标系计算sRGB中的三基色，首先需要将它变换到CIE xyz三值模式：
这样，X、Y、Z值就可以用矩阵转换到线性的R、G、B值，但这些线性值并不是最终的结果。
式中，Rlinear, Glinear，Blinear的取值范围是[0,1]。
sRGB是反应真实世界中伽马值为2.2的CRT显示器的效果，因此使用下式可以将定义在CIE-XYZ颜色空间的线性颜色值
转换到sRGB颜色值。
令Clinear为Rlinear, Glinear, Blinear
Csrgb为Rsrgb,Gsrgb,Bsrgb：
这些经过伽马校正后的sRGB颜色值的范围为[0,1]。如果需要使用0~255的取值范围，通常将它乘以255然后取整。
把颜色值从sRGB颜色值转换为线性颜色值则使用以下公式：
函数g(K)的定义如下：
式中，K为Rsrgb,Gsrgb,Bsrgb。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7137a5b62449a598a0cfe56d87ed6d/" rel="bookmark">
			爬取电影天堂电影列表和详情页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取电影天堂电影列表和详情页 import requests from lxml import etree base_list_url = 'https://www.dytt8.net' headers = { "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36" } def get_one_page_list(url): r = requests.get(url, headers=headers) r.encoding = r.apparent_encoding text = r.text html = etree.HTML(text) url_details = html.xpath("//table[@class='tbspan']//a//@href") url_details = [base_list_url + url_detail for url_detail in url_details] return url_details def parse_info(info, begin): return info.replace(begin, '').strip() def parse_detail_page(url): r = requests.get(url, headers=headers) r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7137a5b62449a598a0cfe56d87ed6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45705b048e28c01529c9125477d186cd/" rel="bookmark">
			Windows 11 预览版来了?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，在一些文章看到，win11预览版来了，还有预览视频。
不过，遗憾的是，经过小编的一番论证，这是假的。
B站17年就有这种视频了，只不过是个ppt而已~ 不过微软要放弃win7的更新维护倒是真的。我们一起来看看微软网站对这件事情的辟谣
地址为：https://answers.microsoft.com/en-us/windows/forum/all/windows-11/b28f65b9-3e39-4d8b-854d-875c0919198b
受这次疫情影响，小编闷在老家已经足足17天了，真是数着时间过日子，不过小编也没闲着，开始学习了python，
6年Java老鸟python自学日记 - 第一天（环境和基础语法）果然我还是不能闲着啊，学完基础语法已经接着学习了部分flask框架了，发现有了多年Java经验再去学习一门新的语言，真的贼容易了，所谓技多不压身，闷在家里，多多学习吧老铁们！ 关注我一起成长
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e18650b0130812fca614efa85bef40/" rel="bookmark">
			五分之一参会者将缺席AAAI 2020，主办方被迫“在线开会”，中国作者可远程演讲...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		郭一璞 发自 宅家
量子位 报道 | 公众号 QbitAI 在疫情影响下，大家不仅开始在线办公、在线上课，甚至连学术会议也要在线参与了。
在疫情肆虐的时候，美国禁止中国人入境，受此影响，本来今天要在纽约举办的AAAI 2020会议，不少中国作者无法出席。
微众银行首席人工智能官、香港科技大学杨强教授就是其中一人，他也是下一届AAAI大会（AAAI 2021）的主席。
本来，杨强教授要在AAAI 2020上介绍他的一篇论文，但鉴于疫情四散的紧张状况，他决定放弃去美国。
而国内AI大厂百度，也被AAAI 2020接收了28篇论文，百度的作者们也无法赴美介绍论文了。
杨强教授预估，中国大陆大约有800名参会者无法线下出席AAAI 2020。而正常会议本来有4000人左右参会，相当于五分之一的参会者都被迫缺席。
面临这样严重的情况，AAAI也被动加入了“线上办公”的行列。
AAAI 2020程序主席、杜克大学教授Vincent Conitzer宣布，受疫情影响的中国参会者可以远程参会，远程参会的具体事项会有中国的同事帮忙。
中国参会者该怎么做 对于因新冠病毒而无法线下参会的所有论文作者，AAAI官方说，最好能找个可以参会的同事来介绍论文，在找不到的情况下，AAAI可以提供以下帮助：
提交演讲PPT，AAAI会给到演讲者会议主席的邮箱，以方便演讲者进行提交。
需要进行演讲的作者，会议期间会接入电话会议来远程演讲。
需要展示Poster的作者，可以找方便到会场的同事来打印张贴，实在找不到人的话AAAI可以安排在纽约印刷张贴，不过要收96美元（669人民币）的服务费。
国际活动多受到影响 AAAI还可以线上参加，但不少国际科技交流活动，已经处在完全无法参加的状况了。
比如，本来要在西班牙举办的世界移动通信大会（MWC），虽然官方说不会取消大会，但本来要参加的LG和中兴，迫于疫情严峻都放弃了参会。
而据WIRED报道，最近在旧金山举办的一场光电子行业会议上，在美国的入境禁令启动前进入中国的展商可以参会，但仍有不少人无法参会，会场上只好摆放一些座位和植物来撑场面。
参考链接：
https://www.wired.com/story/coronavirus-fears-empty-seats-ai-conference/
https://aaai.org/Conferences/AAAI-20/aaai-20-health-information-page/
https://www.scmp.com/tech/big-tech/article/3049327/coronavirus-outbreak-further-strain-global-ai-information-exchanges
— 完 —
口罩佩戴检测是疫情期间很重要的管理工作，但是靠人力去24小时监督管理是很费时费力的。本次直播将分享如何基于华为云ModelArts，开发口罩佩戴检测AI模型，对公共场所监控摄像头的视频进行实时分析，检测民众是否佩戴口罩。
识别下图二维码，添加后回复“直播”，即可加入直播社群：
直播 | 不会写代码，也能开发AI模型
在家学编程 | 柯基编程双师互动课 推荐给7-12岁的小朋友，一个好玩又有趣的事情：在家学习编程。这是一个绝佳的逻辑思维、数理思维、计算思维的提升方式。
柯基少儿编程入门课限时优惠招生，2020年2月10日、29日两个开课时间可选，一共七个课时，现在只需48元，而且学完课程学费全返。
这个意思就是：免！费！学！
欢迎爸爸妈妈们扫描下面的二维码查看、报名：
量子位 QbitAI · 头条号签约作者
վ'ᴗ' ի 追踪AI技术和产品新动态
喜欢就点「在看」吧 !
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bce59036fde46defa5b162c93cd4e3/" rel="bookmark">
			Node.js中的三种获取当前路径方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js中的三种获取当前路径方法 Node提供了三种获取当前路径的方法 console.log(process.execPath);//返回启动 Node.js 进程的可执行文件的绝对路径名 console.log(__dirname);//是被执行的js文件的地址 console.log(process.cwd());//是当前执行node命令的目录地址 执行后分别会有三种不同的路径结果 /usr/local/bin/node /Users/mac/Desktop/demo/03-node /Users/mac 以上结果是在/Users/mac的路径下使用node命令执行JS文件后显示的三种不同路径，这个JS文件所在目录为/Users/mac/Desktop/demo/03-node。
注意：
如果使用 “./” 形式在当前目录下创建一个例如"./exercise.txt"文件，一定要记得cd到当前目录再执行命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b51b144d1cb841dee24fbf83737b64/" rel="bookmark">
			H5在微信中获取openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H5在微信中获取openid 为什么要获取openid openId是用户在当前公众号下的唯一标识（‘身份证’）。在微信中进行微信分享、支付等操作时需要用户的openid。H5要在微信中获取到用户openid，需要获得微信授权，授权分两种方式：静默授权和手动授权
静默授权：用户使用过程中不知不觉获取到openid，不需要用户手动授权，但是会在原页面进行刷新
手动授权：需要用户点击同意授权，能获取到更多用户信息
（我本次使用的是静默授权，所以详细记录一下静默授权的方式）
获取方法 1、首先，要有一个公众号，以及公众号的appid，然后在公众号后台上设置你的网页授权域名（注意不加http://和https://）
2、静默授权，在进入网页之后，访问微信提供的url，在其中设置授权方式以及回调页面url，返回的页面url中就会包含一个code参数
（注意：此处的url是转码过后的url）
url转码方法：
var url = this.urlencode(url_old);
// 编码函数
urlencode (str) { str = (str + '').toString(); return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28'). replace(/\)/g, '%29').replace(/\*/g, '%2A').replace(/%20/g, '+'); },
具体获取code方法：
// 获取code
getBaseInfos(){
var url_code = "https://open.weixin.qq.com/connect/oauth2/authorize?appid="+你的appid+"&amp;redirect_uri="+当前页面url+"&amp;response_type=code&amp;scope=snsapi_base&amp;state=1&amp;connect_redirect=1#wechat_redirect";
window.location.href = url_code;//打开这个链接，你的url后面就会跟上code的参数
}
如果配置参数全部正确，那么此时通过回调地址刷新页面后，你就会看到在地址栏中的code了。
注意：要监测当前url中是否含有code参数，如果包含的话就继续下一步操作，否则页面是一直重复刷新反复获取code。且要注意code码只能使用一次，使用过后就失效了。
3、拿到code之后，需要把code传给后端，后端去请求微信获取openid等参数，前端是获取不到的，微信开发文档中是这么写的：
微信开发文档
后端请求成功后，得到的数据应该是这样的
4、这样我们就能获取到用户的openid进行开发了
开发建议： 判断是否微信内置浏览器，如果是微信内置浏览器的话，去获取用户的openid，否则在外面浏览器中打开获取不到code是会报错的。
1、判断是否是微信浏览器
isWeiXin() {
var ua = window.navigator.userAgent.toLowerCase();
if (ua.match(/MicroMessenger/i) == 'micromessenger') {
return true;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b51b144d1cb841dee24fbf83737b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457b391d60525cc239c4d793c91afab7/" rel="bookmark">
			axios请求失败 如何获取后端接口返回的状态码及错误信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天在写前端项目时候遇到个问题，后端异常做了统一处理，错误信息和提示都在返回的json中，在做校验或其他非正常情况下，返回错误的状态码，则axios直接报错，无法拿到后端返回的json。但是我需要向用户展示后端返回的json中的错误信息，用普通的catch方法只能获取到浏览器返回的400等错误提示，不能获取到后端返回的json，后经查阅得出下面方法：
axios.get('api/user/1') .catch(function (error) { if (error.response) { // The request was made and the server responded with a status code // that falls out of the range of 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else if (error.request) { // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js console.log(error.request); } else { // Something happened in setting up the request that triggered an Error console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457b391d60525cc239c4d793c91afab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cfdb26096466f942eb158a6498314a/" rel="bookmark">
			（一）DB、DBMS、SQL之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念
DB：数据库（database）相当于一个仓库，用于有组织的采存储数据。
DBMS：数据库管理系统（database manage system）数据库是通过DBMS来创建和操作，种类很多（MySQL、 Oracle、 DB2、SqlServer...）
SQL：结构化查询语言（Structure Query Language）与数据库通讯的语言
二、关系
数据库管理系统（DBMS）使用SQL语句管理数据库（DB）：
具体关系图
注意：以后的文章以MySQL为主，但所有的DBMS使用的SQL语句基本相同，存在个别不兼容（MySql兼容性较强）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd10c33c6542f0a00ec444803b499b9/" rel="bookmark">
			【递归与递推】递归函数(reduce)------------------记忆化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
考虑如下的3参数递归函数w(a,b,c)；
如果a≤0或b≤0或c≤0，则w(a,b,c)=1；
如果a&gt;20或b&gt;20或c&gt;20，则w(a,b,c)=w(20,20,20)；
如果a其他情况下：w(a,b,c)=w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1, b-1,c-1)。
设计一个程序，快速计算w(a,b,c)并给出结果。
输入
1行整数，包含3个数值，分别对应a、b和c的值。
输出
一个数，即w(a,b,c)的结果。
样例输入 Copy
50 50 50
样例输出 Copy
1048576
#include&lt;bits/stdc++.h&gt; using namespace std; int f[21][21][21]; int a,b,c; int dfs(int a,int b,int c) { if(a&lt;=0||b&lt;=0||c&lt;=0) return 1; else if(a&gt;20||b&gt;20||c&gt;20) return dfs(20,20,20); else if(f[a][b][c]) return f[a][b][c]; else f[a][b][c]=dfs(a-1,b,c)+dfs(a-1,b-1,c)+dfs(a-1,b,c-1)-dfs(a-1,b-1,c-1); return f[a][b][c]; } int main() { cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;dfs(a,b,c)&lt;&lt;endl;; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907e1b9644786dc98c352b51dbf14727/" rel="bookmark">
			antd 表格用fixed：“left”在typescript中报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用antd的做一个固定列的表格，会用到fixed：“left”，但是却提示以下错误：
不能将类型“({ title: string; dataIndex: string; key: string; sorter: boolean; width: number; fixed: string; render?: undefined; filters?: undefined; filterMultiple?: undefined; onFilter?: undefined; } | { title: string; ... 8 more ...; onFilter?: undefined; } | ... 5 more ... | { ...; })[]”分配给类型“ColumnProps&lt;any&gt;[]”。
不能将类型“{ title: string; dataIndex: string; key: string; sorter: boolean; width: number; fixed: string; render?: undefined; filters?: undefined; filterMultiple?: undefined; onFilter?: undefined; } | { title: string; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907e1b9644786dc98c352b51dbf14727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750d8ab4990e527ee07917b5f1b2b2e0/" rel="bookmark">
			全屏处理后，antd的Select组件不显示下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全屏处理后，antd的Select组件不显示下拉框 最近做全屏功能的时候遇到这个问题：
非全屏下Select组件下拉框是正常显示的。
但是在全屏处理后，Select组件不显示弹出框的下拉选项。
原因：
Select组件有个API：getPopupContainer
Ant Design官方文档给出的用途解释为：“菜单渲染父节点。默认渲染到 body 上，如果你遇到菜单滚动定位问题，试试修改为滚动的区域，并相对其定位”。
同时官网也强调一个特殊情况需要注意：“如果发现下拉菜单跟随页面滚动，或者需要在其他弹层中触发 Select，请尝试使用 getPopupContainer={triggerNode =&gt; triggerNode.parentNode} 将下拉弹层渲染节点固定在触发器的父元素中”。
也就是说，Select 的下拉菜单会默认渲染到 body 上。当你设置了某个元素为全屏的时候，就会被挡住。你可以在全屏的使用 Select 的 getPopupContainer，指定菜单的渲染父节点到被设置为全屏的元素上。
其他 Popop 之类的都同理。
解决方法：
在Select组件中添加getPopupContainer={triggerNode =&gt; triggerNode.parentNode}属性即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1903d255c7716c5eba76eae9e3e45381/" rel="bookmark">
			vue 安装版本管理 nvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装nvm 在GitHub搜索nvm-window，点开下载页面 https://github.com/coreybutler/nvm-windows/releases
上面版本：
nvm-noinstall.zip： 绿色免安装版本，需要配置之后才能使用；
nvm-setup.zip：windows安装包，不需要配置直接使用（推荐使用）；
Source code(zip)：zip压缩的源码
Sourc code(tar.gz)：tar.gz的源码
下载有可能慢 我存在了腾讯云 https://share.weiyun.com/5UR4NDm
直接安装就可以了 安装完查看一下版本 是否安装成功
nvm命令 nvm install xxx //安装版本号
nvm use xxx //设置使用版本号
nvm list //所有的node版本号
nvm alias default v4.2.4 //nvm设置默认node版本号
安装yarn
npm install -g yarn 查看版本：yarn --version
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157b6b024f7c724c4e8dbe4ed72fbe53/" rel="bookmark">
			Flutter(十三)——事件处理：手势识别与事件通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 前言GestureDetector基本用法常用事件监听事件实现缩放监听事件实现拖拽事件通知 前言 在Flutter开发App的过程中，我们除了需要灵活的使用各种组件之外，还需要掌握手势的识别，比如我们常常需要在操作App的时候使用到缩放，双击，放大，缩小等操作，这些Flutter都给我们提供了监听的组件GestureDetector。这篇博文将详细介绍GestureDetector手势识别的使用规则。(拖动手势监听)
GestureDetector基本用法 我们前面提到过，在Flutter开发中，一切皆是组件，所以GestureDetector同样是一个组件，我们使用它，通常是作为一个父Widget包裹一个子Widget外面（也就是你需要捕捉那个组件的手势，就把GestureDetector套在外外面），而内部我们通过onTap回调来实现其点击的效果，代码如下：
GGestureDetector( onTap:(){ print("tap"); }, child:Container{ padding:EdgeInsets.all(20), decoration:BoxDecoration( color:Theme.of(context).buttonColor, borderRadius:BorderRadius.circular(8.0), ), child:new Text("文本"), } ); 比如上面的代码就是改造Text组件成为按钮的方式，这里捕捉了点击事件。
常用事件 GestureDetector手势识别不仅仅只有onTap事件，还有很多很多的常用事件，博主通过一张表格将它们全部列举了出来，方便大家查阅：
属性取值意义onTapDwon当按下屏幕时触发onTap当与屏幕短暂地触碰时触发，最常用onTapUp当用户停止触碰屏幕时触发onTapCancel当用户触摸屏幕，但没有完成Tap事件时触发onDoubleTap快速双击屏幕时触发onLongPress当长按屏幕时触发（与屏幕接触事件必须超过500ms）onPanUpdate当在屏幕上移动时触发onVerticalDragDown当手指触碰屏幕且准备往屏幕垂直方向移动时触发onVerticalDragStart当手指触碰屏幕且开始往屏幕垂直方向移动时触发onVerticalDragUpdate当手指触碰屏幕且开始往屏幕垂直方向移动并发生位移时触发onVerticalDragEnd当用户完成垂直方向触摸屏幕时触发onVerticalDragCancel当用户中断了onVerticalDragDown时触发onHorizontalDragDown当手指触摸屏幕且准备往屏幕水平方向移动时触发onHorizontalDragStart当手指触摸屏幕且开始往屏幕水平方向移动时触发onHorizontalDragUpdate当手指触摸屏幕且开始往屏幕水平方向移动并发生位移时触发onHorizontalDragEnd当用户完成水平方向触摸屏幕时触发onHorizontalDragCancel当用户中断了onHorizontalDragDown时触发onPanDown当用户触摸屏幕时触发onPanStart当用户触摸屏幕并开始移动时触发onPanUpdate当用户触摸屏幕并产生移动时触发onPanEnd当用户完成触摸屏幕时触发onScaleStart当用户触摸屏幕并开始缩放时触发onScaleUpdate当用户触摸屏幕并产生缩放时触发onScaleEnd当用户完成缩放时触发 虽然说上面表格非常详细，但其中有些事件是互斥的，并不能同时存在，比如onVerticalUpdate,onHorizontalUpdate,onPanUpdate这些三个事件都不能同时存在，否则会报错。
另外，onPanUpdate和onScaleUpdate也不能同时存在，这是因为在Gesture识别器里，Scale操作是Pan操作的超集。
监听事件实现缩放 既然我们了解了如何使用这些事件，那么，我们就应该实践起来，这里小编将用上面的事件实现一个缩放效果，代码如下：
class _MyHomePageState extends State&lt;MyHomePage&gt;{ double _top=0.0; double _left=0.0; double _size=100.0; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: new Text("忽略事件"),), body: Stack( children: &lt;Widget&gt;[ Positioned( top: this._top, left: this._left, child: GestureDetector( child: FlutterLogo( size: this._size, ), onScaleUpdate: (e){ setState(() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157b6b024f7c724c4e8dbe4ed72fbe53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf2882e3cd11fb7146c210c5f7d1531/" rel="bookmark">
			Python-时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录了当前 CPython 中各种操作的时间复杂度（又名“Big O”或“大欧”）。其他Python实现（或CPython的旧版本或仍在开发版本）可能具有略微不同的性能特征。
列表(list) 以完全随机的列表考虑平均情况。
列表是以数组（Array）实现的; 最大的开销来自于超出当前分配大小（因为这种情况下, 所有元素都必须移动）, 或者在开头附近的某处插入或删除（因为之后的所有元素都必须移动）。如果需要在两端添加/删除, 请考虑使用collections.deque。
双端队列(collections.deque) deque（双端队列）是以双向链表的形式实现的。（好吧, 一个数组列表而不是对象, 以提高效率）。双端队列的两端都是可达的, 但从查找队列中间的元素较为缓慢, 增删元素就更慢了。
集合(set) 和字典非常相似, 可参考dict。
由源码得知, 求差集（s-t, 或s.difference(t)）运算与更新为差集（s.difference_uptate(t)）运算的时间复杂度并不相同！第一个是O(len(s))（对于s中的每个元素, 如果不在t中, 将它添加到新集合中）。第二个是O(len(t))（对于t中的每个元素, 将其从s中删除）。因此, 必须注意哪个是首选, 取决于哪一个是最长的集合以及是否需要新的集合。
集合的s-t运算中, s和t都要是set类型。如果t不是set类型, 但是是可迭代的, 你可以使用等价的方法达到目的, 比如 s.difference(l), l是个list类型。
字典(dict) 下列字典的平均情况基于以下假设：
1. 对象的散列函数足够撸棒（robust）, 不会发生冲突。
2. 字典的键是从所有可能的键的集合中随机选择的。
小窍门：只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度, 但会对常数项产生显著的影响, 这决定了你的一段程序能多快跑完。
Notes
这些操作依赖于“摊销最坏情况”的“摊销”部分。根据容器的历史, 个别动作可能需要很长时间。
对于这些操作, 最坏的情况n是容器达到的最大尺寸, 而不仅仅是当前的大小。例如, 如果一个N个元素的字典, 然后删除N-1个元素, 这个字典会重新为N个元素调整大小, 而不是当前的一个元素, 所以时间复杂度是O(n)。
转载自 https://zhuanlan.zhihu.com/p/64841133
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15916776090303a58b4a97f6638bc5a/" rel="bookmark">
			B. Array Sharpening
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B. Array Sharpening
也是签到题，那一行描述我都懵逼了
傻傻的把282865输进去然后。。。。欸怎么yes
改了半天才知道本来就是yes。。。
先考虑上升的序列，如果找到了不能继续上升的元素，即a[i]&lt;i的元素，那么下标为i-1的元素即为k点，
然后再考虑下降序列，如果说k点元素大小不足以下降到最后还≥0，那么就直接no
然后再考虑下降元素大小，不能小于n-i-1，否则最后一个元素就只能&lt;0了。
#include&lt;bits/stdc++.h&gt; #define lson (o&lt;&lt;1) #define rson (o&lt;&lt;1|1) #define fi first #define sc second #define dbg(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl; #define rg register typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; using namespace std; const double pi=acos(-1); const double eps=1e-6; inline int lowbit(int x){return x&amp;(-x);} template&lt;typename A,typename B,typename C&gt; inline A fpow(A x,B p,C yql){ A ans=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%yql)if(p&amp;1)ans=1LL*x*ans%yql; return ans; } inline int read() { int X=0,w=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if (c=='-') { w=-1; } c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48); c=getchar(); } return X*w; } //inline void w(int x) { if(x&gt;9) w(x/10); putchar(x%10+'0'); } int a[300005]; int main(){ int t,n; std::ios::sync_with_stdio(0); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } int t1=n; for(int i=0;i&lt;n;i++){ if(a[i]&lt;i){ t1=i; break; } } if(a[t1-1]&gt;=n-(t1-1)-1){ }else { puts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15916776090303a58b4a97f6638bc5a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/398/">«</a>
	<span class="pagination__item pagination__item--current">399/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/400/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>