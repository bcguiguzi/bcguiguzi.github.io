<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c570d8a269dcc67601d6f52c7c1512/" rel="bookmark">
			Vue3 快速上手从0到1，两小时学会【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们好，欢迎关注，一起学习，无限进步
以下内容为vue3的学习笔记
项目需要使用到的依赖
npm install axios
npm install nanoid
vue-router
npm install pinia
npm install mitt
源码：Gitee
运行
npm install npm run dev 需要运行那一小节，把目录 src 删除，对应的重命名为 src 即可
文章目录 1. Vue3简介1.1. 【性能的提升】1.2.【 源码的升级】1.3. 【拥抱TypeScript】1.4. 【新的特性】 2. 创建Vue3工程2.1. 【基于 vue-cli 创建】2.2. 【基于 vite 创建】(推荐)2.3. 【一个简单的效果】 3. Vue3核心语法3.1. 【OptionsAPI 与 CompositionAPI】Options API 的弊端Composition API 的优势 3.2. 【拉开序幕的 setup】setup 概述setup 的返回值setup 与 Options API 的关系setup 语法糖 3.3. 【ref 创建：基本类型的响应式数据】3.4. 【reactive 创建：对象类型的响应式数据】3.5. 【ref 创建：对象类型的响应式数据】3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c570d8a269dcc67601d6f52c7c1512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7533d3e57c6937f2842f057d2ee5f64/" rel="bookmark">
			难❗️计算机考研408难度又破新高！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		24年408考研，如果只用王道的复习资料，最多考100-120分 就是这么的现实，王道的资料虽然好，但是并不能覆盖全部的知识点和考点，而且24年的408真题考的很怪，总结起来就是下面这些特点：
偏，计算量大，反押题 考研出题老师学会了上网，各个机构的押题卷都失去了作用，老师们为了避开机构的押题，出题的角度也很刁钻，选者题不仅不仅计算量大，算的头皮发麻，而且计算机网络的选择题，我问了很多人，基本上都是错3个以上，可以说是等于没复习。
而大题方面，数据结构算法题考的是散列哈希和矩阵向量图，机组两道大题也塞了一堆计算题，进制给你换来换去，操作系统的大题就是比较常规的PV操作。重点来了，计算机网络的大题，每一个中文我都认识，怎么组合到一起我就不知道讲的是什么意思了，太抽象了
对于后面学弟学妹的408复习建议，我认为不要局限于王道的资料。
王道的资料虽然可以，但是已经跟不上现在的考研强度了。如果大家想考高分，首先一点就是要狠抓计算，24年的试卷就是写着写着，最后发现时间不够了，其中计算就花掉很多时间。
除了狠抓计算，我认为大家还需要一些补充资料。王道的资料最多覆盖了考纲90%的考点，一些知识点讲的不够细致，因此我推荐大家用下面这些教材作为补充：
《数据结构(C语言版)》由严蔚敏和吴伟民编写，由清华大学出版社出版。《计算机组成原理》由唐朔飞主编，由高等教育出版社出版。《计算机网络》由谢希仁编写，由电子工业出版社出版。《计算机操作系统》由汤小丹主编，出版社是西安电子科技大学。 这些教材并不用全都学，我是这么用的，如果王道讲的不好的地方，我会直接回到教材，跟着教材重新学一遍。
408考研该如何提高上岸的成功率 408备考的核心，除了专业课本身，考研数学成绩是关键因素。
因为大家在408考试中的分数差距并不大，如果你能在408考试中得到120分以上，那么你就属于高分选手了。大部分同学的分数都在110分左右。然而，考研数学成绩好与不好之间的差距可能至少有30分。
无论是考研数学一还是考研数学二，没有成功上岸的大都是因为考研数学成绩不理想。为什么考研数学成绩不理想，我感觉我有发言权，因为在备考考研的时候，我也曾险些在考研数学上搞砸了。
大部分同学的专业课复习是从6月份开始的，我也不例外。所以当我在九月底结束了408第一轮复习的时候，我的数学刚好结束了强化阶段。这个时候我面临的最大问题就是时间不够用。
一、如何在408和考研数学之间取得平衡 我的考研数学是在三月份开始复习的，然后408专业课实在六月份开始复习的，我之所以复习的这么晚，是因为我们学校大三下学期才讲操作系统，所以我就直接跟着老师把操作系统给学会了。
3-6月底主要是复习考研数学基础阶段 学会安排时间，平很好学校科目与数学学习之间的平衡
这个阶段很多还在学校的同学的一个基本矛盾就是学校还在上课，但是自己要复习考研数学。我是怎么克服的呢，当然是逃课+上课拿着数学讲义自己看自己的。逃课当然是逃一些水课。一些必修课肯定是不能逃的。老师也知道大家在考研，所以对于上课听考研课也一般都是睁一只眼闭一只眼。
当然，操作系统课我一点也不逃，因为操作系统课我408要考啊。如果大家像我一样，大三上还有和专业课相关联的课程，那就跟着老师好好的复习，不仅期末能考好，考研也复习了。
说一下基础阶段复习的误区：
我刚开始复习的时候，虽然只复习数学，但是其实我的学习效果很差，以为我一开始基本上只听课，很少做题。
我觉得我听视频课听的听明白了，所以就可以少做题。这完全是大错特错。
听课听懂了和会做题完全是两个维度的事情，根本就不能相提并论。所以大家在复习的时候一定要尽早的开始做题。不仅要做题，还要做有质量的题目。
还好，我后面发现这个问题很及时，我发现我不会做题也很巧，并不是做1800题或者660题发现的，而是我的室友拿着一个网站的题目问我会不会做，我看了半天都想不明白怎么做，于是就让他给我看答案，后来我也开始用这个网站开始刷题，就是知能行考研数学。
用知能行考研数学让我很慌，因为他一旦发现我有题目不会，再出一道类似的我还是不会，好像是找到了我的弱点，一直进攻。后来我才知道，这是在检测我的薄弱点呢，知能行有一套人工智能算法，可以通过我的做题过程，扫描出来我有哪些地方不会，一旦发现了我不会的地方，知能行就会循序渐进，一层一层的帮我吃透，然后再找我的下一个薄弱点。
正是因为这样的复习模式，我的基础复习的很扎实，基础阶段结束之后，基本上没有薄弱点。
知能行考研数学知能行考研数学通过大数据分析历年真题的考点难点，为每位考生选择快速提高的突破口。知能行基于机器学习追踪考生知识点的掌握情况，测练合一从而达到高效备考https://bestzixue.com/?app_referrer_id=WBH~atcxdwc-408diff-0301-editor_chengzz
7-9月底平衡考研数学和408的关键时期 大家最晚最晚6月就要开始408的复习了，因为7月就要暑假了，这一整块的时间是408复习的最最最黄金的时间，也是数学强化的黄金时间。
这个阶段不仅有408，考研数学，还有考研英语和政治也都要加入复习，我当时的复习规划就是一天复习12个小时。再多复习一会就要累了。
时间上的分配时5小时专业课，5小时数学，1小时英语，1小时政治，其实还有很多零散的时间在英语和政治的复习上。
这个阶段的主要矛盾就是408和考研数学的矛盾，复习量相比于基础阶段直接翻倍。复习难度也增加很多。我的复习策略很简单，因为我基础通过知能行复习的很扎实，所以复习压力就小很多。
数学就是知能行考研数学+660题+880题。408就是按照数据结构，计算机组成原理，计算机网络的顺序进行复习（操作系统在上学期学过一遍），
在408的学习上，我的建议是尽可能的快，这是因为408的科目很多，如果不快点复习，学完前面的，忘掉后面的，这就等于白学了。学快点，然后多学几遍，这就是我的408复习套路。
我在9月份结束的时候，408复习了一遍半，基本上是可以开始真题。
数学的学习主要以知能行为主，660题+880题用来做补充，因为知能行可以预测我660题和880题哪些题会做，哪些题不会做，这就是AI预测功能。
9月-考试不要忽略数学的学习 越是到后期，越是不能忽略数学的学习，想上岸，数学必须要好！
后期时间紧张，英语要准备模版，政治要刷题，408也要刷真题，还要开始第2遍到第三遍的复习，很多事情要做，于是就有很多同学牺牲数学的时间去学408。
你可以试试，数学只要三天不好好学，水平就会下降。所以大家一直到考前一天，都要保持数学的学习强度。
我在9月之后，基本上就是每天做做知能行的综测，然后刷刷知能行让我滚动复习的题目。刷知能行约到后面越轻松，因为薄弱带你越来越少，每天只需要保持手感就可以了。
二、408复习讲义和课本推荐 教材与资源 市面上提供了众多关于408考研的学习资料，例如天勤、王道等等。然而，就讲义而言，我强烈推荐王道的讲义。此外，将王道的视频课程与讲义结合使用效果更加显著。有人提到王道的讲义可能存在一些质量问题，其中可能会有错误。不可否认，毕竟它并非正式的教材。但相较于其他讲义，王道的讲义仍然是一个不错的选择，既有长处又有短处。
在涉及数据结构的学习方面，您也可以参考天勤的数据结构讲义，许多人认为他在代码解释方面做得相当出色。
真题练习 选择王道版本的真题也是明智之举，因为它们整理得非常详尽，每年都有新的版本，解答也十分仔细。最重要的是，每道题都有相应的视频解析可供参考，这对于遇到不懂的地方提供了很大帮助。
课本辅助 在使用课本方面，我建议将其视为对讲义的有益补充。因为即使是王道的讲义，在某些方面也可能讲得不够详细。如果遇到这种情况，可以查阅课本以获取更深入的理解。以下是一些推荐的参考课本：
数据结构：《数据结构（C语言版）》严蔚敏。对于零基础且跨领域考研的同学，数据结构可能有一定难度，此时可以参考《大话数据结构》。计算机组成原理：《计算机组成原理（第2版）》唐朔飞。操作系统：《计算机操作系统（第四版）》汤小丹。计算机网络：《计算机网络（第7版）》谢希仁。 三、408备考规划 先说一下408备考的逻辑，大家可能会觉得408很难，内容也很多，但是408备考的逻辑非常简单，就是反复多遍，408的知识理解起来并不复杂，你要做的就是提高熟练度并且对抗遗忘。
我本科期间408的平均分在80分左右。而且我408之所以六月份才开始复习，是因为我大三上学期有两门课，操作系统和计算机网络，408也考。大家要根据自己的实际情况灵活调整复习计划。
408基础阶段（6月-9月底） 408的第一轮复习就是跟着王道的视频课把四门课都过一遍，三个月的时间完全可以吧四门课给过一遍，基础阶段我的建议是，听一章的视频课，就把王道书上的课后题给做了。
其实大部分都是选择题，大题也要做，不要留给后面，后面也不会有太多的时间来做。每一章学完之后，可以自己试着画一下思维导图，尽量不要用网上现成的，思维导图可以帮助我们梳理学过的知识点，让我们的学习更有条理。
408强化阶段（10月-11月底） 408强化阶段主要有两个任务：
408真题要刷两遍以上；408要进行第二轮复习； 因为408的内容太多，所以一定要进行第二轮的复习，你进行第二轮复习的时候会发现第一遍学习的很多内容都忘掉了。第二轮复习，王道课本上的课后题可以只做错题，其他题目可以看一下。
强化阶段最主要的就是做真题，做真题可以和第二轮复习结合起来，根据真题反应出来的薄弱点，进行针对性学习是很有必要的。
408冲刺阶段（11月-考试） 复习内容：
翻看真题的错题，回忆是否是知识点未掌握导致错误，如果是，必须马上通过王道书来查漏补缺通过笔记来回忆知识点框架，这个时候必须很迅速的回忆起知识点的内容、特点及需要注意的部分。对于一些内容，需要硬背下来，比如计算机网络的一些知识点，很零碎，但是选择题会考。 480在冲刺阶段的任务主要就是整理前期复习过程中产生的各种错题，还有各种比较零散的知识点，408是需要去背的，比如数据结构的一些模版，计算机组成原理的一些硬件的名称和构造，还有计算机网络和操作系统的很多知识点都需要背。
四、408学习与考研数学规划 408和考研数学需要花费大量时间。如果时间分配不当，就可能导致其中一门学科考试不理想。因此，只有能够同时关注408的数学规划才是一项好的数学规划！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7533d3e57c6937f2842f057d2ee5f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7462284147cff6a1fdb9e0c33d1ccb/" rel="bookmark">
			打造经典游戏：HTML5与CSS3实现俄罗斯方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
欢迎来到我的技术小宇宙！🌌 这里不仅是我记录技术点滴的后花园，也是我分享学习心得和项目经验的乐园。📚 无论你是技术小白还是资深大牛，这里总有一些内容能触动你的好奇心。🔍
🤖 洛可可白：个人主页
🔥 个人专栏：✅前端技术 ✅后端技术
🏠 个人博客：洛可可白博客
🐱 代码获取：bestwishes0203
📷 封面壁纸：洛可可白wallpaper
文章目录 打造经典游戏：HTML5与CSS3实现俄罗斯方块摘要1. 体验地址2. 创建游戏界面3. 初始化游戏4. 绘制游戏板5. 游戏逻辑6. 开始游戏7.全部代码🎉 结语 打造经典游戏：HTML5与CSS3实现俄罗斯方块 摘要 俄罗斯方块是一款经典的电子游戏，它不仅考验玩家的反应速度，还能锻炼逻辑思维能力。本文将指导你如何使用HTML5、CSS3和JavaScript来创建一个简单的俄罗斯方块游戏。我们将从游戏的基本结构开始，逐步构建游戏逻辑，并在最后提供一个完整的代码示例。
1. 体验地址 PC端体验地址：洛可可白⚡️俄罗斯方块
（暂时只支持键盘输入操作）
2. 创建游戏界面 首先，我们需要创建一个HTML页面，用于展示游戏的界面。这包括游戏板、得分显示以及游戏控制区域。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;!-- ... 其他头部代码 ... --&gt; &lt;style&gt; /* ... 样式代码 ... */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;俄罗斯方块&lt;/h2&gt; &lt;div id="tetris"&gt; &lt;div id="game-board"&gt;&lt;/div&gt; &lt;div id="score"&gt;Score: &lt;span id="score-value"&gt;0&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- ... 脚本代码 ... --&gt; &lt;/body&gt; &lt;/html&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7462284147cff6a1fdb9e0c33d1ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5793e3ef79d7ce537bb0fce3afe5972/" rel="bookmark">
			物联网毕设 -- 智能银行（APP&#43;STM32&#43;指纹）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 连线图
1 原理图
2 PCB效果
3 实物效果
4 APP效果
5 功能概括
（1）硬件端
（2）APP端
（3）云平台使用（阿里云）（需要可以找我获取）
（4）演示视频
二 底层代码使用方式
1 使用说明
2 下载程序
三 APP使用方式
1下载APP
四 程序架构及修改（通用）
前言 该智能监控系统采用了开启自动连接WiFi、实时数据传输、震动感应器、温湿度传感器、光敏传感器、火焰传感器、指纹识别门禁等硬件设备，通过手机App实现远程监控和控制，使用MQTT协议进行信息交互，用户可以随时查看传感器状态、修改阈值、查看历史记录，保障安全性和便利性。
关注微信公众号--星之援工作室 发送关键字（项目清单） 可获取项目清单资料 ➡️🫡🫡🫡🫡🫡🫡🫡🫡➡️
⚠️⚠️（本文章仅提供思路和实现方法，并不包含代码，需要代码的同学请自行联系博主）
⚠️⚠️（有疑问或需要定制或者技术支持等，也请自行联系博主）⚠️⚠️
一 连线图 1 原理图 2. 开发板本身自带一个LED ，这个LED作为我们查看网络连接状态和获取数据状态的说明
（1）首先需要打开我们的WIFI热点让设备进行联网操作，看到显示数据界面，即可进行下一步功能测试
（2）硬件每隔3秒会向APP传输一次数据。
热点名字：NET密码：12345678，请使用2.4GHZ频率的无线网。
2 PCB效果 3 实物效果 4 APP效果 5 功能概括 （1）硬件端 开启设备自动连接WiFi，LED闪烁提示设备正在工作；实时监测：硬件设备收集的数据每隔3-5秒自动向云平台传输一次数据，通过APP可随时实时监测装置所检测的各项数据；震动感应器:检测是否遭受冲击或碰撞，一旦发生该情况，系统装置将立即触发报警，同时在APP端发送弹窗警告温湿度传感器：检测温湿度，设定阈值控制空气流通系统（用风扇模拟空气流通系统或者用模拟开空调）光敏传感器：检测光线强度，设定阈值自动控制灯光系统。火焰传感器：如检测到火灾发生，系统装置将立即触发报警，同时在APP端发送弹窗警告指纹识别门禁：如检测到有非法入侵系统装置将立即触发报警，同时在APP端发送弹窗警告；将传感器收集的数据通过WIFI传输到APP上， （2）APP端 使用MQTT协议与设备进行信息交互。远程监控各传感器的状态，可灵活修改各设备的相关数据阈值，可按时间查看相关数据的历史记录（使用本地数据库进行存储） （3）云平台使用（阿里云）（需要可以找我获取） 只是链接各个设备使用，采用MQTT即时通讯；
（4）演示视频 链接：演示视频https://pan.baidu.com/s/16LrdJHFvVrQqj1SsfS4wxw?pwd=XZY0
提取码：XZY0 二 底层代码使用方式 1 使用说明 （1）. 使用的时候设备会自动连接WIFI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5793e3ef79d7ce537bb0fce3afe5972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab01c1aed022ec78c9c4942668987dd/" rel="bookmark">
			神经网络和卷积神经网络的理论分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.神经网络
2.卷积神经网络
2.1卷积神经网络的常用结构
2.2 卷积与子采样
2.3 卷积与权值共享
2.4卷积的作用
3.神经网络和卷积神经网络的区别
计算机学者从生物视觉的研究中得到启示，一个视觉神经细胞只与其距离较近的邻层神经元相连。鉴于此，CNN的采用了局部感受野。为了简化模型，一个特征平面的神经元共享权值。CNN最早由YannLecun 实现并运用到手写数字识别问题中，并取得该领域最高的识别率，至今未被超越。CNN是NN的一种变形，CNN与NN最大的不同在于CNN的卷积和子采样过程，而子采样可以被认为是一种特殊的卷积过程。在本章的后半部分，将以切割小图训练共享权值的NN的方式阐释卷积神经网络中的卷积过程。
1.神经网络 神经网络（neural network，NN）是生物科学和信息科学交叉的产物。生物学家研究人脑神经的工作过程，发现神经元（神经细胞）和神经元之间通过突起(轴突和树突)的相连，神经细胞感受到刺激之后产生兴奋并通过细胞突起将兴奋传导给与之有连接的神经元。神经元的连接大多是相邻层间的连接，神经细胞总体上呈现分层结构，感受器中的神经接收外界刺激，神经中枢的神经元决定人脑的意识。
一个神经元通常和若干个神经元相连，连接有强有弱，不同的连接就像电子元件之间阻值不同的带阻导体。一个非输入神经元在兴奋传导过程中受到的刺激总和为与之相连的神经元传递来的兴奋之和。
2.卷积神经网络 卷积神经网络与普通神经网络的区别在于，卷积神经网络包含了一个由卷积层和子采样层构成的特征抽取器。在卷积神经网络的卷积层中，一个神经元只与部分邻层神经元连接。在CNN的一个卷积层中，通常包含若干个特征平面(featureMap)，每个特征平面由一些矩形排列的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是卷积核。卷积核一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将学习得到合理的权值。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接，同时又降低了过拟合的风险。子采样也叫做池化（pooling），通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。子采样可以看作一种特殊的卷积过程。卷积和子采样大大简化了模型复杂度，减少了模型的参数。
2.1卷积神经网络的常用结构 卷积神经网络通常采用若干个卷积和子采样层的叠加结构作为特征抽取器。卷积层与子采样层不断将特征图缩小，但是特征图的数量往往增多。特征抽取器后面接一个分类器，分类器通常由一个多层感知机构成。在特征抽取器的末尾，我们将所有的特征图展开并排列成为一个向量，称为特征向量，该特征向量作为后层分类器的输入。
2.2 卷积与子采样 卷积过程有三个二维矩阵参与，它们分别是两个特征图和一个卷积核：原图inputX、输出图outputY卷积核kernelW。卷积过程可以理解为卷积核kernalW覆盖在原图inputX的一个局部的面上，kernalW对应位置的权重乘于inputX对应神经元的输出，对各项乘积求和并赋值到outputY矩阵的对应位置。卷积核在inputX图中从左向右，从上至下每次移动一个位置，完成整张inputX的卷积过程。卷积过程如图所示。
2.3 卷积与权值共享 在卷积神经网络的卷积层，卷积核本质是神经元之间相互连接的权重，而且该权重被属于同一特征图的神经元所共享。在实际的网络训练过程中，输入神经元组成的特征图被交叠切割成卷积核大小的小图。每个小图通过卷积核与后层特征图的一个神经元连接。一个特征图上的所有小图和后层特征图中某个神经元的连接使用的是相同的卷积核，也就是同特征图的神经元共享了连接权重。
在人工神经网络中，一个非输入神经元表征了某种特征，一个非输入神经元又可以由与之相关的前层连接表示，通过权重的还原，我们可以看到每个神经元代表的特征，神经元特征是逐层具象化的。在卷积神经网络中，卷积核是神经元之间的连接权重，如果只用来训练局部，可以代表局部某种特征，但是它被一个特征图共享，用来训练整个特征图，代表了比较通用（适用于全图）的某种的特征。中我们往往在卷积神经网络中设置多个卷积层，在一个卷积层中设置多个卷积核，以得到丰富的特征供尾部的分类器使用。
2.4卷积的作用 训练之后的卷积核有些能突显图像的边缘特征，有些能对原图产生了震颤效果。通过丰富的卷积核，卷积可以提炼原题的某些特征，同时模型将对目标在产生偏移、缩放或者轻微形变的时候变得鲁棒。
另外，我们要可以将第一层卷积核固定，设置为特定的算子，如边沿检测算子，平移算子，模糊算子。每个卷积核处理完一个特征图之后得到一个新的特征图，多个卷积可以得到多个特征图，这个过程相当于增加了训练集，相当于对模型进行了数据增量训练，使模型的鲁棒性更好。
3.神经网络和卷积神经网络的区别 从理论角度来看，神经网络和卷积神经网络都是基于梯度下降的优化算法进行训练的。在训练过程中，网络通过不断调整神经元的权重和偏置来最小化损失函数，从而学习到输入数据的特征和规律。
然而，由于神经网络和卷积神经网络的结构和连接方式的不同，它们在处理不同类型的数据和任务时具有不同的优势和局限性。例如，在处理图像数据时，卷积神经网络由于具有局部连接和权值共享的特点，能够更有效地提取图像中的局部特征，因此在图像分类、目标检测等任务上表现优异。而传统的神经网络在处理序列数据（如文本、语音等）时具有更强的建模能力，因此在自然语言处理、语音识别等领域应用广泛。
此外，神经网络和卷积神经网络的性能和效果还受到诸多因素的影响，如网络结构、神经元数量、激活函数选择、学习率设置等。在实际应用中，需要根据具体的数据和任务特点选择合适的网络结构和参数设置，以达到最佳的性能和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe800afbd5acbe7bf3ee38ca34a77e0/" rel="bookmark">
			YOLO语义分割标注文件txt还原到图像中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做图像分割任务过程中，使用labelme对图像进行标注，得到的数据文件是json，转换为YOLO训练所需的txt格式后，想对标注文件进行检验，即将txt标注文件还原到原图像中，下面是代码：
import cv2 import numpy as np ''' 读取txt标注文件及原图 ''' def read_txt_labels(txt_file): """ 从 txt 标注文件中读取标签 :param txt_file: txt 标注文件路径 :return: 标签列表 """ with open(txt_file, "r") as f: labels = [] for line in f.readlines(): label_data = line.strip().split(" ") class_id = int(label_data[0]) # 解析边界框坐标 coordinates = [float(x) for x in label_data[1:]] labels.append([class_id, coordinates]) return labels def draw_labels(image, labels): """ 在图像上绘制分割区域 :param image: 图像 :param labels: 标签列表 """ for label in labels: class_id, coordinates = label # 将坐标转换为整数并重新塑形为多边形 points = [(int(x * image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe800afbd5acbe7bf3ee38ca34a77e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e0a7a04eabe9820dc6e52cc3961092/" rel="bookmark">
			MySQL学习六：子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、子查询分类1.1 按结果集的行列数不同1.2 按子查询出现的位置不同 二、子查询特点三、子查询相关案例（仅展示有限部分）3.1 where 或 having 后面（重点）3.1.1 标量子查询3.1.2 列子查询3.1.3 行子查询（有局限性，了解即可） 3.2 select 后面3.3 from 后面3.4 exists 后面 1.数据库来源：Mysql 基础教程
2.数据库说明：
本文使用的第一个数据库名称为 myemployees，其中有 8 张表，分别为 customers 表，departments 表，employees 表，job_grades 表，jobs 表，locations 表，orders 表，salespeople 表。
一、子查询分类 1.1 按结果集的行列数不同 ① 标量子查询（结果集只有一行一列）
② 列子查询（结果集只有一列多行）
③ 行子查询（结果集一般为一行多列，也可以为多行多列）
④ 表子查询（结果集一般为多行多列）
1.2 按子查询出现的位置不同 where 或 having 后面：标量子查询（单行），列子查询（多行），行子查询（多列）。前两个子查询为重点
select 后面：仅仅支持标量子查询
from 后面：支持表子查询
exists 后面：支持表子查询
二、子查询特点 ① 子查询放在小括号内
② 子查询一般放在条件的右侧
③ 标量子查询，一般搭配单行操作符（&gt;，&lt;，&gt;=，&lt;=，=，&lt;&gt;）使用
列子查询，一般搭配多行操作符（in/not in，any/some，all）使用
④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e0a7a04eabe9820dc6e52cc3961092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8456fa49bf6c41dd0be6a163963fa5aa/" rel="bookmark">
			Transformer——Attention 注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意力机制 Transformer的注意力机制借鉴了人类的注意力机制。人类通过眼睛的视觉单元去扫描图像，其中的重点区域会被大脑的神经元处理从而获得更多的信息，这是人类长期精华所获得的一种能力。
以论文中的例子来看，红色区域表示我们人脑视觉更为关注的区域。而Attention 机制则是模拟这一人脑机制，让计算机能够正确的从总舵信息中选择出对当前任务更为重要的信息。
Attention 机制原理 人类视觉注意力机制的原理为：从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略不重要的信息。
计算机的注意力机制模型就是从大量信息（Values）中筛选出少量的重要信息，这个重要信息对于另外一个信息（Query）是重要的。即注意力模型的主要作用就是通过Query从Values中筛选出重要信息。
结合下图，Attention可以翻译为如下的描述，其将Query和KV（把value拆分为key-value信息，这两个值看作等同的）映射到输出上。其中Q(query)、K(key)、V(value)都是一个向量，输出 V ， V^， V，则是所有value的加权，其中权重是由Q和每个K计算出来的。
KV 是怎么来的？ 对于上述图像来说，我们将其分割为不同的小块，其中每个块的向量化表示则是向量K
详细计算过程 刚刚提到，输出 V ， V^， V，是对所有value的加权，是由 Query 和每个 key 计算出来的，计算方法分为三步：
第一步：计算Q和K的相似度，可以用 F F F来表示： f ( Q , K i ) , i = 1 , 2 , . . . , n f(Q,K_i),i=1,2,...,n f(Q,Ki​),i=1,2,...,n 计算方法一般分为四种： 点乘： f ( Q , K i ) = Q T K i f(Q,K_i)=Q^TK_i f(Q,Ki​)=QTKi​权重： f ( Q , K i ) = Q T K i W f(Q,K_i)=Q^TK_iW f(Q,Ki​)=QTKi​W拼接权重： f ( Q , K i ) = [ Q T K i ] W f(Q,K_i)=[Q^TK_i]W f(Q,Ki​)=[QTKi​]W感知器： f ( Q , K i ) = V T t a n h ( W Q + U K i ) f(Q,K_i)=V^Ttanh(WQ+UK_i) f(Q,Ki​)=VTtanh(WQ+UKi​) 第二布：将第一步得到的相似度进行SoftMax操作，进行归一化： α i = s o f t m a x ( F ( Q , K i ) d k ) \alpha_i=softmax(\frac{F(Q,K_i)}{\sqrt{d_k}}) αi​=softmax(dk​ ​F(Q,Ki​)​) 这一步进行归一化是避免得到的相似度F1 = 50 和 F2 = 1 之间的差值多大影响模型效果，归一化之后相似度可能就会变成F1 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8456fa49bf6c41dd0be6a163963fa5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7445884db2377429036701d01c1096b6/" rel="bookmark">
			《vtk9 book》 官方web版 第3章 - 计算机图形基础 （5 / 5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vtkProp的组件和其他类型 通常希望将演员收集到一个依赖于变换的层次结构中。例如，一个机器人手臂可以由刚性连接的链接表示，这些链接在肩关节、上臂、肘部、下臂、腕关节和手部等关节处连接在一起。在这种配置中，当肩关节旋转时，期望的行为是整个手臂一起旋转，因为这些链接是连接在一起的。这是 VTK 中所称的装配的一个例子。vtkAssembly 只是 VTK 中许多类似演员的类之一。正如图 3-34 所示，这些类被排列成 vtkProps 的层次结构。（在舞台和电影术语中，道具是指出现或在舞台上使用的东西。）在 VTK 中，通过实例化一个 vtkAssembly 然后向其添加部分来形成装配。部分是 vtkProp3D 的任何实例，包括其他装配。这意味着可以将装配形成层次结构（只要它们不包含自引用循环）。装配遵守前一节“变换矩阵”中所示的转换串联规则。以下是如何创建一个简单装配层次结构的示例（来自 assembly.tcl）。
vtkSphereSource sphere vtkPolyDataMapper sphereMapper sphereMapper SetInputConnection [sphere GetOutputPort] vtkActor sphereActor sphereActor SetMapper sphereMapper sphereActor SetOrigin 2 1 3 sphereActor RotateY 6 sphereActor SetPosition 2.25 0 0 [sphereActor GetProperty] SetColor 1 0 1 vtkCubeSource cube vtkPolyDataMapper cubeMapper cubeMapper SetInputConnection [cube GetOutputPort] vtkActor cubeActor cubeActor SetMapper cubeMapper cubeActor SetPosition 0.0 .25 0 [cubeActor GetProperty] SetColor 0 0 1 vtkConeSource cone vtkPolyDataMapper coneMapper coneMapper SetInputConnection [cone GetOutputPort] vtkActor coneActor coneActor SetMapper coneMapper coneActor SetPosition 0 0 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7445884db2377429036701d01c1096b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da935013de546aa3a0855f4ec43e0f07/" rel="bookmark">
			《vtk9 book》 官方web版 第3章 - 计算机图形基础 （4 / 5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.10 将所有内容整合起来 本节概述了图形对象以及如何在 VTK 中使用它们。
图形模型 我们已经讨论了许多在场景渲染中起作用的对象。现在是将它们整合到一个全面的图形和可视化对象模型中的时候了。
在可视化工具包中，有七个基本对象用于渲染场景。幕后有许多其他对象，但这七个是我们最常用的。这些对象列在以下，并在图 3-24 中进行了说明。
vtkRenderWindow — 管理显示设备上的窗口；一个或多个渲染器绘制到 vtkRenderWindow 的一个实例中。
vtkRenderer — 协调涉及光源、摄像机和演员的渲染过程。
vtkLight — 用于照亮场景的光源。
vtkCamera — 定义场景的视图位置、焦点和其他视图属性。
vtkActor — 表示场景中渲染的对象，包括其属性和在世界坐标系中的位置。（注意：vtkActor 是 vtkProp 的一个子类。vtkProp 是包括注释和 2D 绘图类在内的更一般形式的演员。有关更多信息，请参阅“组件和其他类型的 vtkProp”）
vtkProperty — 定义演员的外观属性，包括颜色、透明度和光照属性，如高光和漫反射。还包括线框和实体表面等表现属性。
vtkMapper — 演员的几何表示。多个演员可以引用同一个映射器。
vtkRenderWindow 类将渲染过程联系在一起。它负责管理显示设备上的窗口。对于运行 Windows 的 PC，这将是一个 Microsoft 显示窗口，对于 Linux 和 UNIX 系统，这将是一个 X 窗口，在 Mac（OSX）上是一个 Quartz 窗口。在 VTK 中，vtkRenderWindow 的实例是与设备无关的。这意味着您不需要担心使用的底层图形硬件或软件是什么，软件会自动适应您的计算机，因为 vtkRenderWindow 的实例被创建。 （有关更多信息，请参阅“实现设备无关性”）
除了窗口管理，vtkRenderWindow 对象还用于管理渲染器并存储显示窗口的图形特性，如大小、位置、窗口标题、窗口深度和双缓冲标志。窗口的深度表示每个像素分配了多少位。双缓冲是一种技术，其中一个窗口被逻辑地分为两个缓冲区。在任何给定时间，一个缓冲区当前对用户可见。同时，第二个缓冲区可以用于绘制动画中的下一帧图像。渲染完成后，可以交换两个缓冲区，使新图像可见。这种常见的技术允许动画显示而用户看不到基元的实际渲染。高端图形系统在硬件中执行双缓冲。典型系统将具有深度为 72 位的渲染窗口。前 24 位用于存储前缓冲区的红色、绿色和蓝色（RGB）像素分量。接下来的 24 位存储后缓冲区的 RGB 值。最后的 24 位用作 z 缓冲区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da935013de546aa3a0855f4ec43e0f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b5d99cee631375eb782ddfdfdcdd66/" rel="bookmark">
			《vtk9 book》 官方web版 第3章 - 计算机图形基础 （3 / 5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.8 演员几何 我们已经看到了光照属性如何控制演员的外观，以及相机如何结合变换矩阵将演员投影到图像平面上。剩下的是定义演员的几何形状，以及如何将其定位在世界坐标系中。
建模
计算机图形学研究中的一个重要主题是建模或表示物体的几何形状。已经应用了各种数学技术，包括点、线、多边形、各种形式的曲线和样条线，甚至是隐式的数学函数的组合。
这个主题超出了本文的范围。这里重要的一点是，存在一个指定对象形状及其在模型坐标系中位置的基础几何模型。
在数据可视化中，建模扮演着不同的角色。与直接创建几何形状来表示对象不同，可视化算法计算这些形式。通常几何形状是抽象的（如等高线），与真实世界的几何关系不大。当我们描述可视化算法时，我们将看到这些模型是如何计算的，这将在第6章 - 基本算法和第9章 - 高级算法中介绍。
数据可视化的几何表示往往是简单的，尽管计算这些表示并不简单。这些形式通常是基本形状，如点、线和多边形，或者是体积数据等可视化数据。我们使用简单的形式是因为我们希望实现高性能和交互式系统。因此，我们利用计算机硬件（将在“图形硬件”中介绍）或者像体积渲染这样的特殊渲染技术。
演员的位置和方向
每个演员都有一个控制其在世界空间中位置和缩放的变换矩阵。演员的几何形状是在模型坐标中定义的模型。我们使用方向、位置和沿坐标轴的比例因子来指定演员的位置。此外，我们可以定义一个围绕其旋转的原点。这个特性很有用，因为我们可以围绕演员的中心或其他有意义的点旋转演员。
演员的方向由存储在方向向量（Ox，Roy，Oz）中的旋转确定。这个向量定义了一系列旋转变换矩阵。正如我们在前一节关于变换矩阵中所看到的，变换的应用顺序不是任意的。我们已经选择了一个基于我们认为对用户自然的固定顺序。变换的顺序是先围绕 y 轴旋转 O y，然后围绕 x 轴旋转 O x，最后围绕 z 轴旋转 O z。这个顺序是任意的，基于标准摄像机操作。这些操作（按顺序）是摄像机方位角，然后是仰角，最后是翻转（图3-15）。
所有这些旋转都发生在演员的原点周围。通常这被设置为其包围框的中心，但也可以设置为任何方便的点。有许多不同的方法可以改变演员的方向。RotateX()、RotateY() 和 RotateZ() 是常见的围绕各自轴旋转的方法。许多系统还包括围绕用户定义的轴旋转的方法。在可视化工具包中，RotateXYZ() 方法用于围绕通过原点的任意矢量旋转。
（图3-15）演员坐标系
3.9 图形硬件 前面我们提到，图形硬件的进步对渲染的执行方式产生了重大影响。现在我们已经介绍了场景渲染的基础知识，接下来我们将看一些硬件问题。首先，我们讨论了取代矢量显示器成为主要输出设备的光栅设备。然后，我们将研究程序如何与图形硬件进行通信。我们还将研究计算机图形中使用的不同坐标系、隐藏线/面消除和z缓冲。
光栅设备 计算机图形的结果在当今世界中无处不在——使用计算机图形生成的数字图像可能出现在手机上、显示在计算机监视器上、在电视上播放、在电影院展示，并在电子广告牌上呈现。所有这些，以及许多其他显示媒介都是光栅设备。光栅设备使用称为像素的图片元素的二维数组来表示图像。例如，单词“hello”可以被表示为一个像素数组，如图3-15所示。在这里，“hello”这个词是写在一个宽25像素、高10像素的像素数组中的。每个像素存储一位信息，无论是黑色还是白色。这就是黑白激光打印机的工作原理，对于纸张上的每个点，它要么打印一个黑点，要么保持纸张的颜色。由于硬件限制，光栅设备如激光打印机和计算机监视器实际上并不像图3-16中那样绘制精确的方形像素。相反，它们往往略微模糊并重叠。光栅设备的另一个硬件限制是它们的分辨率。这就是为什么300 dpi（每英寸点数）的激光打印机会产生比九针点阵打印机更详细的输出的原因。300 dpi的激光打印机的分辨率是每英寸300像素，而点阵打印机的分辨率大约为50 dpi。
彩色计算机显示器通常具有大约80像素每英寸的分辨率，使屏幕成为大约一千像素宽和高的像素阵列。这导致超过一百万个像素，每个像素都有一个值，指示它应该是什么颜色。由于彩色显示器中的硬件使用RGB系统，因此使用该系统来描述像素中的颜色是有意义的。不幸的是，每个像素都有红色、绿色和蓝色分量，可能会占用大量内存。这是市场上各种图形硬件之间差异的一部分。一些公司每个像素使用24位的存储空间，其他公司使用8位，一些高级系统每个像素使用超过100位的存储空间。通常，每个像素的位数越多，颜色就越准确。
在图形硬件中解决颜色限制的一种方法是使用一种称为抖动的技术。例如，假设您想使用一些不同的灰色调，但您的图形硬件只支持黑色和白色。抖动使您可以通过使用黑色和白色像素的混合来近似灰色调。在图3-17中，使用黑色和白色像素的混合绘制了七个灰色方块。从远处看，这七个方块看起来像不同的灰色调，即使在近处看，很明显它们只是不同的黑色和白色像素的混合。这种技术对其他颜色同样有效。例如，如果您的图形硬件支持主蓝色、主绿色和白色，但不支持淡海绿色，您可以通过对硬件支持的绿色、蓝色和白色进行抖动来近似这种颜色。
与硬件接口 现在我们已经讨论了显示硬件的基础知识，好消息是你很少需要担心它们。大多数图形编程都是使用比单个像素更高级的原语完成的。图3-18显示了一个典型的可视化程序布局。在层次结构的底部是我们已经讨论过的显示硬件；你的程序很可能不会直接与它交互。在硬件上面的三个层次是你可能需要关注的层次。
许多程序利用应用程序库作为系统图形功能的高级接口。本书附带的可视化工具包就是一个很好的例子。它允许你仅使用几个命令显示复杂对象或图形。还可以与许多不同的图形库进行接口，因为不同的库可能在不同的硬件平台上受支持。
图形库和图形硬件层都执行类似的功能。它们负责接收来自应用程序库或程序的高级命令，并执行它们。通过提供更复杂的原语，这使得编程变得更容易。我们可以绘制像多边形、三角形和线段这样的原语，而不必担心哪些像素设置为哪种颜色的细节。图3-19说明了所有主流图形库支持的一些高级原语。
这种功能被分为两个不同的层次，因为不同的机器可能具有非常不同的图形硬件。如果你编写一个绘制红色多边形的程序，图形库或图形硬件必须能够执行该命令。在高端系统上，这可能是在图形硬件中完成的，而在其他系统上，图形库会在软件中完成。因此，相同的命令可以在各种各样的机器上使用，而不必担心底层的图形硬件。
图3-19中原语的基本构建块是一个点（或顶点）。一个顶点有一个位置、法线和颜色，每个都是一个三元素向量。位置指定了顶点的位置，法线指定了顶点面向的方向，颜色指定了顶点的红色、绿色和蓝色分量。
多边形是通过连接一系列点或顶点构建的，如图3-20所示。你可能会想为什么每个顶点都有一个法线，而不是整个多边形只有一个法线。一个平面多边形无论其顶点的法线指示什么，只能面向一个方向。原因是有时多边形被用作其他东西的近似，比如曲线。图3-21显示了一个圆柱的俯视图。如你所见，它实际上不是一个圆柱，而是一个用灰色绘制的多边形近似圆柱。每个顶点被两个多边形共享，顶点的正确法线与多边形的法线不同。类似的逻辑解释了为什么每个顶点都有一个颜色，而不是整个多边形只有一个颜色。
当您限制自己使用上述描述的原始类型时，许多图形系统支持一些附加属性。边缘颜色和边缘可见性可用于突出显示构成演员的多边形原语。另一种方法是通过将表示从表面调整为线框或点来实现。这将分别用它们的边界边缘或点替换多边形等表面。虽然从物理角度来看这可能没有太多意义，但在某些插图中可能会有所帮助。在渲染CAD模型时使用边缘可见性可以帮助显示组成模型的不同部分。
光栅化 到目前为止，我们已经描述了如何使用渲染基元表示图形数据，以及如何使用光栅显示设备表示图像。问题是，我们如何将图形基元转换为光栅图像呢？这是我们在本节中要讨论的主题。虽然对这个主题进行详尽的论述超出了本文的范围，但我们会尽力提供一个高层次的概述。
光栅化或扫描转换是将几何表示转换为光栅图像的过程。在接下来的描述中，我们假设图形基元是三角形多边形。这并不像你想象的那样具有限制性，因为任何一般多边形都可以被分解成一组三角形。此外，其他表面表示如样条通常被图形系统分解成三角形或多边形。（这里描述的方法实际上适用于凸多边形。）
今天的大多数硬件都是基于对象顺序光栅化技术。正如我们在本章前面看到的那样，这意味着按顺序处理我们的角色。由于我们的角色由多边形基元表示，我们逐个处理多边形。因此，尽管我们描述了一个多边形的处理过程，请记住实际上会处理许多多边形，可能还有许多角色。
第一步是使用适当的变换矩阵变换多边形。我们还使用平行或正交投影将多边形投影到图像平面上。这个过程的一部分涉及对多边形进行裁剪。我们不仅使用前后裁剪平面来裁剪太近或太远的多边形，还必须裁剪穿过图像平面边界的多边形。裁剪穿过视景体边界的多边形意味着我们必须生成新的多边形边界。
图3-22。将凸多边形转换为光栅图像。像素在图像平面上以水平跨度（或扫描线）进行处理。点$p_i$处的数据值$d_i$沿着边缘插值，然后沿着扫描线使用增量数据值进行插值。典型的数据值是颜色的RGB分量。
将多边形剪裁并投影到图像平面后，我们可以开始扫描线处理（图3-22）。第一步是识别被投影多边形所交叉的初始扫描线。这是通过对顶点的y值进行排序来找到的。然后我们找到连接左侧和右侧顶点的两条边。利用边的斜率以及数据值，我们计算出增量数据值。这些数据通常是R、G和B颜色分量。其他数据值包括透明度值和z深度值。（如果我们使用z缓冲区，描述在下一节中。）多边形内的像素行（即从左侧和右侧边缘开始）称为跨度。数据值从跨度两侧的边插值以计算内部像素值。这个过程一直持续到整个多边形被填满。请注意，当遇到新的顶点时，需要重新计算增量数据值。
多边形的着色（即多边形上的颜色插值）取决于角色的插值属性。有三种可能性：平面着色、Gouraud着色或Phong着色。图3-7展示了平面着色和Gouraud着色之间的区别。平面着色通过将光照方程应用于多边形的一个法线（通常是表面法线）来计算多边形的颜色。Gouraud着色通过使用顶点的法线和标准光照方程在所有顶点处计算多边形的颜色。然后通过应用扫描线插值过程来填充多边形的内部和边缘。Phong着色是三者中最逼真的。它通过插值顶点法线在多边形上的每个位置计算法线。然后使用这些法线在光照方程中确定最终像素颜色。平面和Gouraud着色是常用的方法。Phong着色的复杂性使其难以在硬件中得到广泛支持。
Z缓冲 在我们之前对渲染过程的描述中，我们跟随光线从我们的眼睛穿过图像平面中的一个像素到演员，再返回到光源。光线追踪的一个好处是，观看光线会击中它们遇到的第一个演员，并忽略任何隐藏在其后面的演员。当使用上述多边形方法渲染演员时，我们没有一种方法来计算哪些多边形被隐藏了，哪些没有被隐藏。我们通常无法确定多边形是否被正确排序。相反，我们可以使用许多用于多边形渲染的隐藏表面方法。
一种方法是按照从后到前（沿着摄像机的视图向量）对所有多边形进行排序，然后按照那个顺序渲染它们。这被称为画家算法或画家排序，但它有一个主要弱点，如图3-23所示。无论我们以何种顺序绘制这三个三角形，我们都无法得到期望的结果，因为每个三角形既在另一个三角形的前面，又在其后面。有一些算法可以对多边形进行排序和分割，以处理这种情况[Carlson85]。这需要更多的初始处理来执行排序和分割。如果图像之间的几何原语发生变化或摄像机视图发生变化，则必须在每次渲染之前执行此处理。
画家算法的问题 另一个隐藏表面算法，Z缓冲，解决了这个问题，并且不需要排序。Z缓冲利用视图坐标系中的z值（即沿投影方向的深度值）。在绘制新像素之前，将比较其z值与该像素位置的当前z值。如果新像素将位于当前像素的前面，则绘制该像素并更新该像素位置的z值。否则，保持当前像素不变，新像素将被忽略。由于其简单性和稳健性，Z缓冲已被广泛实现在硬件中。Z缓冲的缺点是它需要大量内存，称为Z缓冲区，用于存储每个像素的z值。大多数系统使用深度为24或32位的Z缓冲区。对于一个1000乘1000的显示屏，这意味着仅用于Z缓冲区就需要三到四兆字节。Z缓冲的另一个问题是，它的精度受其深度的限制。24位Z缓冲区在视锥体的高度上提供了16777216分之一的精度。如果物体靠得很近，这种分辨率通常是不够的。如果遇到Z缓冲的精度问题，请确保前后裁剪平面尽可能靠近可见几何体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b28e303e90a77ffcdf81eaba31ada9/" rel="bookmark">
			《vtk9 book》 官方web版 第3章 - 计算机图形基础 （2 / 5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.4 表面特性 当光线穿过空间时，其中一些光线会与我们的物体相交。当这种情况发生时，光线会与物体表面相互作用，产生一种颜色。部分由此产生的颜色实际上并不是由直接光线产生的，而是来自其他物体反射或散射的环境光。环境光照模型对此进行了考虑，它是对现实世界中复杂光线散射的简单近似。它将光源的强度曲线应用于物体的颜色，也表示为强度曲线。结果就是我们在观察物体时所看到的光的颜色。在这样的模型中，重要的是要意识到，白色光照射到蓝色球上与蓝色光照射到白色球上是无法区分的。环境光照方程如下：
这段 大概是：
“ 在这里， Ra 是由环境光引起的最终强度曲线，Lc是环境光的强度曲线，而Oa是物体的颜色曲线。为了简化方程，我们假设所有方向向量都被标准化了（即，具有单位长度）。”
得到的颜色的两个组成部分取决于直接光照。漫反射光照，也称为兰伯特反射，考虑了光线入射到物体上的角度。图3-7显示了一个圆柱体的图像，随着从中心向侧面移动，圆柱体变暗。圆柱体的颜色是恒定的；击中圆柱体表面的光的数量会发生变化。在中心，入射光几乎垂直于圆柱体表面，每个表面积收到更多的光线。当我们向侧面移动时，这个数量会减少，直到最终入射光线与圆柱体侧面平行，结果强度为零。
图3-7. 平面和高拉德着色。不同的着色方法可以显著改善用多边形表示的物体的外观。顶部的平面着色使用每个多边形上的恒定表面法线。底部的高拉德着色插值多边形顶点的法线，使外观更加平滑。请参阅FlatVersusGouraud.cxx和FlatVersusGouraud.py。
漫反射光照的贡献在方程3-2中表示，并在图3-8中进行了说明。
Rd代表由漫反射光引起的最终强度曲线，Lc代表光的强度曲线，Od代表物体的颜色曲线。请注意，漫反射光是入射光矢量和物体表面法线之间相对角度的函数。因此，漫反射光与观察者位置无关。
镜面光照代表了光源在光滑物体上的直接反射。图3-10显示了一个漫反射光照的球体，具有不同的镜面反射。镜面强度（在顶部和底部行之间变化）控制了镜面光照的强度。镜面功率O_{sp}表示物体有多光滑，更具体地说，它表示了当反射角度偏离完美反射时镜面反射迅速减弱的速度。较高的值表示衰减更快，因此表面更光滑。参考图3-9，镜面光照的方程如下：
其中， →Cn​ 是摄像机投影的方向， →S 是镜面反射的方向。
这段原文大体：（请高手多指教）
“我们已经分别介绍了不同的光照模型的方程。我们可以同时或者结合应用所有的光照模型。方程3-4将环境光、漫反射光和镜面光结合成一个方程。
结果是物体表面上的一个点的颜色。常数Oai、Odi和Osi控制了物体环境光、漫反射光和镜面光的相对量。常数Oac、Odc和Osc指定了每种类型的光要使用的颜色。这六个常数以及镜面功率是表面材质属性的一部分。（其他属性，比如透明度，将在文本的后面部分介绍。）这些属性值的不同组合可以模拟出暗淡的塑料和抛光的金属。该方程假设了一个无限点光源，正如“光源”部分所描述的。然而，该方程可以很容易地修改以包含其他类型的定向光照。
图3-10. 镜面系数的效果。镜面系数控制物体的明亮度。顶部行具有镜面强度值为0.5；底部行为1.0。沿水平方向，镜面功率发生变化。数值（从左到右）分别为5、10、20和40。请参阅SpecularSpheres.cxx。
3.5 相机 我们有发射光线的光源和具有表面属性的角色。在我们角色表面的每个点上，这种相互作用会产生一些复合颜色（即来自光线、物体表面、镜面和环境效果的组合颜色）。现在我们渲染场景所需要的就是相机。有一些重要因素决定了3D场景如何投影到平面上形成2D图像（见图3-11）。这些因素包括相机的位置、方向和焦点，相机投影方法以及相机裁剪平面的位置。
图3-11 相机属性。
相机的位置和焦点定义了相机的位置和指向位置。从相机位置到焦点定义的矢量被称为投影方向。相机图像平面位于焦点处，通常垂直于投影矢量。相机的方向由位置和焦点加上相机视角向量控制。这些完全定义了相机视图。
投影方法控制了角色如何映射到图像平面。正交投影是一种平行映射过程。在正交投影（或平行投影）中，进入相机的所有光线都与投影矢量平行。透视投影发生在所有光线通过一个公共点（即视点或投影中心）的情况下。要应用透视投影，我们必须指定透视角度或相机视角。
前后裁剪平面与投影矢量相交，通常垂直于它。裁剪平面用于消除距离相机太近或太远的数据。因此，只有在裁剪平面内的角色或角色部分是（可能）可见的。裁剪平面通常垂直于投影方向。它们的位置可以使用相机的裁剪范围来设置。平面的位置是从相机位置沿投影方向测量的。前裁剪平面位于最小范围值处，后裁剪平面位于最大范围值处。在第7章 - 高级计算机图形学中，当我们讨论立体渲染时，我们将看到不垂直于投影方向的裁剪平面的示例。
综合起来，这些相机参数定义了一个矩形金字塔，其顶点位于相机的位置，沿投影方向延伸。金字塔在顶部被前裁剪平面截断，在底部被后裁剪平面截断。由此产生的视锥定义了相机可见的3D空间区域。
虽然相机可以通过直接设置上述属性来进行操作，但也有一些常见的操作可以简化工作。图3-12和图3-13将帮助说明这些操作。改变相机的方位角会围绕其视角向量旋转其位置，以焦点为中心。可以将其视为将相机向左或向右移动，同时始终保持到焦点的距离不变。改变相机的仰角会围绕其投影方向和视角向量的叉积在焦点处旋转其位置。这相当于向上和向下移动相机。要旋转相机，我们围绕视平面法线旋转视角向量。旋转有时被称为扭转。
接下来的两个动作保持相机的位置不变，而是修改焦点。改变偏航会围绕以相机位置为中心的视角向量旋转焦点。这类似于方位角，只是焦点移动而不是位置。俯仰的变化会围绕投影方向和视角向量的叉积在相机位置为中心旋转焦点。拉近和拉远会沿着投影方向移动相机的位置，靠近或远离焦点。此操作被指定为其当前距离与新距离的比值。大于一的值会拉近，小于一的值会拉远。最后，缩放会改变相机的视角，使场景的显示范围更多或更少。
图3-12. 环绕焦点的相机运动。请参阅CameraModel1.cxx和CameraModel1.py。
图3-13. 环绕相机位置的相机运动。请参阅CameraModel2.cxx和CameraModel2.py。
一旦我们安置好相机，就可以生成我们的2D图像。穿过相机镜头的一些光线会穿过镜头。然后这些光线会击中一个平面，产生一幅图像。这实际上将我们的3D场景投影到2D图像中。相机的位置和其他属性决定了哪些光线被捕获和投影。更具体地说，只有与相机位置相交并在其视锥内的光线会影响最终的2D图像。
这就结束了我们对渲染的简要概述。光线从光源传播到角色，被反射和散射。其中一些光线被相机捕获并产生一幅2D图像。现在我们将看一些这个过程的细节。
以上是vtk book内容，由于部分图片原版文件中也不存在，并且自动翻译导致部分解释并不详细,在此找一些同学的内容赋予此处，用于深刻理解相机相关内容（故与上面部分为重复内容）
vtk相机 VTK是用vtkCamera类来表示三维渲染场景中的相机。vtkCamera负责把三维场景投影到二维平面，如屏幕、图像等。
在VTK中，相机的实质是一个观测点，与人眼的功能相同，相机的视野范围是一个锥状体。
VTK中的相机的使用示意图如下：
相机位置和焦点位置定义了相机的位置和投影方向，前裁剪平面为CCD镜头平面（图像平面），后裁剪平面为物体平面。相机位置和焦点位置定义了相机的位置和投影方向，前裁剪平面为CCD镜头平面（图像平面），后裁剪平面为物体平面。
相机位置和焦点位置定义了相机的位置和投影方向，前裁剪平面为CCD镜头平面（图像平面），后裁剪平面为物体平面。
与相机投影相关的因素主要有：
相机位置：即相机所在的位置，用方法vtkCamera::SetPosition()设置。
相机焦点：用方法vtkCamera::SetFocusPoint()设置，默认的焦点位置在世界坐标系的原点。
朝上方向：即哪个方向为相机朝上的方向。就好比我们直立看东西，方向为头朝上，看到的东西也是直立的，如果我们倒立看某个东西，这时方向为头朝下，看到的东西当然就是倒立的。相机位置、相机焦点和朝上方向三个因素确定了相机的实际方向，即确定相机的视图。
投影方向：相机位置到相机焦点的向量方向即为投影方向。
投影方法：确定Actor是如何映射到像平面的。vtkCamera定义了两种投影方法，一种是正交投影(OrthographicProjection)，也叫平行投影(Parallel Projection)，即进入相机的光线与投影方向是平行的。另一种是透视投影(PerspectiveProjection)，即所有的光线相交于一点。
视角：透视投影时需要指定相机的视角(View Angle)，默认的视角大小为30º，可以用方法vtkCamera::SetViewAngle()设置。
前后裁剪平面：裁剪平面与投影方向相交，一般与投影方向也是垂直的。裁剪平面主要用于评估Actor与相机距离的远近，只有在前后裁剪平面之间的Actor才是可见的。裁剪平面的位置可以用方法vtkCamera::SetClippingRange()设置。
这里的前后裁剪平面和摄影中的近和远剪裁的平面相同，近和远剪裁的平面是虚构平面，位于沿着摄影机的视线方向上距离摄影机的两个特定距离上。只有摄影机的两个剪裁平面之间的对象才会在摄影机的视图中被渲染。对于场景中与摄影机之间的距离比与近剪裁平面的之间距离近的任何对象，或与摄影机之间的距离比与远剪裁平面之间的距离远的任何对象，系统都不会进行渲染。 一句话，剪切平面是为了消除距离相机过近或过远的图像数据。
如果某个对象的一部分位于近剪裁平面的前面，则该对象中仅有超出近剪裁平面的那一部分才会被渲染。 相机的运动 当物体在处于静止位置时，相机可以在物体周围移动，摄取不同角度的图像；
相机的运动分为移动、旋转；
移动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b28e303e90a77ffcdf81eaba31ada9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f3cb4699329b49040905cf27c8d69b/" rel="bookmark">
			C&#43;&#43; summary C语言实现多态，切割现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现多态的简单代码 C语言实现多态有点类似回调函数的实现方式 #include &lt;stdio.h&gt; // 定义回调函数类型 typedef void (*callback_t)(int); // 实现一个简单的回调函数 void myCallback(int num) { printf("Calling back with %d\n", num); } // 接受回调函数作为参数的函数 void performActionWithCallback(callback_t cb) { printf("Performing an action...\n"); if (cb) { // 调用回调函数 cb(42); // 假设42是从某个操作中得到的结果 } } int main() { // 将回调函数传递给另一个函数 performActionWithCallback(myCallback); return 0; } C语言实现多态，代码来自 函数指针的正确用法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; // &gt;&gt;&gt;&gt;&gt;接口定义 typedef void (*printer_print_fn)(void *printer,const char *str); struct printer_i{ printer_print_fn print; }; // &lt;&lt;&lt;&lt;&lt;接口定义 // &gt;&gt;&gt;&gt;&gt; plain_printer struct plain_printer{ const struct printer_i *interface; const char *prefix; }; // &gt;&gt;&gt;&gt;&gt; 增强接口定义 void plain_printer_print(struct plain_printer *self,const char *str); void plain_printer_print(struct plain_printer *self,const char *str){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f3cb4699329b49040905cf27c8d69b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b03f40a38bcc07f36f2d1b416b83424/" rel="bookmark">
			linux 配置jdk环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.确保已上传jdk包到指定目录
2.打开终端，使用文本编辑器（比如vi、nano等）创建或修改~/.bashrc文件。命令为：
sudo vi ~/.bashrc 3.在.bashrc文件末添加以下内容：
export JAVA_HOME=/usr/local/jdk/jdk1.8.0_391 #将路径替换成你自己的JDK安装路径 export PATH=$PATH:$JAVA_HOME/bin 4.保存并关闭文件后，运行以下命令使更新生效：
source ~/.bashrc 5.最后，通过输入以下命令验证JDK的环境变量是否正确设置：
echo $JAVA_HOME 该命令会显示JDK的安装路径，表明环境变量已经成功配置。 java -version 该命令会显示jdk版本，表示已成功配置 注意事项： .bashrc文件位于当前用户的主目录下，每次登录时都会被执行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4626de9352c0f4c992ea8b71511b05/" rel="bookmark">
			API 设计的原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在 Thoughtworks 上曾经读到过一篇文章《API 设计的几条原则》我觉得写得非常不错，链接我放底下，推荐阅读。
在我多年的工作历程中，我深刻意识到 API 的设计至关重要，但是我发现，在一般的组织中，API 的设计却往往草率。这主要体现在几个方面：
操刀人选草率 ：不少团队的 API 设计，都是负责实现的同事进行的，这些同事很多情况下，并不是团队里最资深，最了解各个系统构造的人，在设计的时候，就不能考虑到更多的东西；接口缺乏标准 ：公司稍微大一点的情况下，很容易缺乏全公司统一的标准，往往就是各个团队有各个团队的标准，如果仅是如此尚好，有时候不同团队的标准不兼容；命名草率：接口上选用的单词，往往非常随机，取决于设计者的个人修养，而这些命名有时候并某有经过审计，在定稿的时候，上下游都没有认真的思考过，有时候名字取得过大，有时候取得过小，非常妨碍使用者的理解，甚至造成误导； 我观国内外一些顶级的开源项目，API 动辄几年十几年不变，就深感佩服。那么 API 设计到底要考虑些什么因素，怎样设计，才能做到这样的稳定呢？
API 本质上是系统不同部分之间通信的协议，当然也包括跟外部系统之间的通信。要想设计得好，就要将系统充分的抽象，这个过程之中，要尽量摒弃掉抽象之外的因素的影响。比如，接口运行的网络协议（TCP/UDP），内容格式（文本/二进制），调用者的形态（服务器/客户端），这类都不应该预定一种假设。
原文的作者认为，设计 API 是非常难的，评估 API 的好坏也是非常难的，所以给出一些原则，共参考：
使用成熟度合适的 RESTful API RESTful 风格的 API 具有一些天然的优势，例如通过 HTTP 协议降低了客户端的耦合，具有极好的开放性。因此越来越多的开发者使用 RESTful 这种风格设计 API，但是 RESTful 只能算是一个设计思想或理念，不是一个 API 规范，没有一些具体的约束条件。
因此在设计 RESTful 风格的 API 时候，需要参考 RESTful 成熟度模型。
成熟度等级解释示例Level 0定义一个 URI 所有请求通过 POST 完成POST /?action=changeUserPasswordLevel 1创建独立的资源地址，隔离 API 的范围POST /user?action=updateLevel 2使用 HTTP 动词定义对资源的操作GET /user/01Level 3使用 API 超媒体 （HATEOAS，返回的 body 中索引相关的资源地址{ "links" : [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4626de9352c0f4c992ea8b71511b05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07ce298f655960f8057387a43bedee8/" rel="bookmark">
			UE5 局域网联机，寻找会话失败。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
参考资料：
尝试解决办法 1.1在【项目名.Build.cs】脚本中添加该行，添加后关闭编辑器，重新生成解决方案。​编辑
2.检查是否在同一个C类子网
参考资料： 1.Can't find session in LAN - Programming &amp; Scripting / Multiplayer &amp; Networking - Epic Developer Community Forums (unrealengine.com)
2.How To Use Sessions In C++ | 4.24 | UE4: Guidebook (gg-labs.com)
3.Lyra - 会话浏览器找不到会话 （LAN WIFI） ： r/unrealengine (reddit.com)
尝试解决办法 全部都做一遍，其中可能有若干个步骤多余。
1.1在【项目名.Build.cs】脚本中添加该行，添加后关闭编辑器，重新生成解决方案。
1.2.找到项目文件，找到该配置文件，看准你要打包的平台。我的是win64
用文本方式打开ini文件，在底部添加下列代码 onlinesubsystem的代码，不知是重新生成时还是打包时，把ini添加的设置，我添加的若干行删除了。
2.检查是否在同一个C类子网 参考 参考资料第3条。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56f95d19e1e16f438344de2e46dd29f/" rel="bookmark">
			漫漫数学之旅036
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 经典格言数学习题古今评注名人小传 - 爱因斯坦 经典格言 纯数学在其领域内是逻辑思想的诗歌。——阿尔伯特·爱因斯坦
“纯数学在其领域内是逻辑思想的诗歌”这句话体现了爱因斯坦对数学的深刻理解和热爱。在这句话中，爱因斯坦将纯数学比作诗歌，强调了数学不仅仅是一系列抽象的符号和公式，而是一门充满美感和创造力的艺术。
纯数学，不同于应用数学，它不直接关注实际问题的解决，而是研究数学结构和理论本身。它追求普适的原理和概念，探索数与形的本质规律。在纯数学的世界里，逻辑推理是构建知识体系的基石。每一个定理、每一个证明都是逻辑链条中的一环，严谨而精确。
爱因斯坦的这句话也暗示了数学与物理之间的紧密联系。作为物理学家，爱因斯坦深知数学工具对于理解自然界的重要性。他的相对论就是用数学语言表述的，展现了数学在描述物理现象中的力量。
总的来说，爱因斯坦的这句话表达了他对数学的赞美，认为数学是一种通过逻辑推理展现思想之美的学问，就像诗歌一样，能够激发人们的思考和创造力。
数学习题 假定这些荷花每天都在翻倍地生长，如果2月5日荷花长满池塘，那么2月几日荷花覆盖池塘的 1 4 \displaystyle\frac{1}{4} 41​呢？
古今评注 芝诺的悖论，以其独特的“无穷分割”方法，挑战了我们对时间和空间的常规理解。这个悖论的核心观点是：在从点A到点B的过程中，你需要经过无穷多个中点，因此需要无穷多的时间。这听起来像是一个无法解决的难题，但实际上，它揭示了我们对时间和空间的误解。
首先，让我们来解析一下这个悖论。假设点A和点B之间的距离是一米，那么他们的中点就是半米。然后，半米的中点是四分之一米，四分之一米的中点是八分之米，以此类推。这样，我们就有了无穷多个中点。芝诺认为，你需要先到达第一个中点，然后是第二个，然后是第三个，依此类推，因此你需要无穷多的时间才能到达点B。
然而，这里的关键问题在于，芝诺忽略了一个事实：虽然中点的数目是无穷的，但这些中点的总距离是有限的。换句话说，你需要的时间是有限的。这是因为，每次你到达一个新的中点，你都离目标更近一步。实际上，你离目标的距离是以几何级数的速度减少的，这意味着总距离是有限的。
这个悖论的另一个有趣之处在于，它揭示了我们对时间的误解。我们常常认为时间是连续的，可以无限分割。然而，现代物理学告诉我们，时间实际上是离散的，最小的时间单位是普朗克时间，大约是 5.4 × 1 0 − 44 5.4\times10^{-44} 5.4×10−44秒。这意味着，你不能在不到普朗克时间的时间内做任何事情。因此，即使你需要经过无穷多个中点，你也不可能花费无穷多的时间。
总的来说，芝诺的悖论是一个有趣的思考题，它挑战了我们对时间和空间的理解。虽然它看起来很复杂，但实际上，它揭示了我们对时间和空间的一些基本误解。通过理解这个悖论，我们可以更好地理解我们的世界。
名人小传 - 爱因斯坦 阿尔伯特·爱因斯坦，20世纪最伟大的物理学家之一，以其相对论和质能方程而闻名于世。1879年3月14日出生于德国的乌尔姆，他天生具有好奇心和对知识的渴望。
爱因斯坦在瑞士联邦理工学院接受教育，尽管他在学生时代并不突出，甚至一度被老师认为没有前途，但他对科学的热爱从未减退。1905年，也被称为他的“奇迹年”，他发表了四篇开创性的论文，奠定了量子理论和相对论的基石。其中包括了描述光电效应的论文，该理论后来为他赢得了诺贝尔奖。
1915年，爱因斯坦提出了广义相对论，重新定义了重力的概念，将其视为时空的弯曲。这一理论不仅颠覆了牛顿的万有引力定律，也为现代宇宙学的发展奠定了基础。
除了科学成就，爱因斯坦的个人生活也颇为丰富多彩。他与表姐埃尔莎结婚，并且是一位热爱音乐的小提琴手。他的幽默感和机智回答也让他成为了公众眼中的风趣人物。
在二战期间，爱因斯坦由于犹太血统，被迫逃离纳粹德国，最终定居在美国。在那里，他继续他的研究工作，并公开谴责核武器的危险。
晚年的爱因斯坦将更多的精力投入到寻求统一场论的研究中，尽管这一领域并未在他生前取得突破。1955年4月18日，这位伟大的科学家在普林斯顿去世，留下了他对科学和人类文明的巨大贡献。
爱因斯坦的一生是对知识不懈追求的典范，他的理论至今仍对科学产生深远影响。他不仅是一位科学巨匠，也是智慧与人文精神的象征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a8212a7eae538c262d8ace49a579f2/" rel="bookmark">
			架构:Apache Kafka Connect实现sqlserver数据实时同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现Apache Kafka Connect与SQL Server之间的实时数据同步，您可以使用Kafka Connect的JDBC Source Connector。以下是一个基本的步骤：
1. 安装Kafka Connect：确保您已经安装了Apache Kafka 和 Kafka Connect。您可以从Apache Kafka的官方网站或其他途径获取它。
2. 下载JDBC Driver：获取适用于SQL Server的JDBC驱动程序，例如Microsoft提供的Microsoft JDBC Driver for SQL Server。
3. 配置连接器：创建一个配置文件，指定JDBC Source Connector的配置信息。以下是一个示例配置文件：
```json
{
"name": "sqlserver-source-connector",
"config": {
"connector.class": "io.confluent.connect.jdbc.JdbcSourceConnector",
"tasks.max": "1",
"connection.url": "jdbc:sqlserver://your_sql_server_host:1433;databaseName=your_database",
"connection.user": "your_username",
"connection.password": "your_password",
"table.whitelist": "your_table_name",
"mode": "incrementing",
"incrementing.column.name": "your_incrementing_column",
"topic.prefix": "sqlserver-",
"poll.interval.ms": "5000"
}
}
```
确保替换配置文件中的`your_`前缀为您的SQL Server连接信息和相应的表信息。
4. **启动连接器：** 使用Kafka Connect REST API启动连接器。可以使用`curl`或其他HTTP客户端，将配置文件发送到Kafka Connect的REST端点。例如：
```bash
curl -X POST -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a8212a7eae538c262d8ace49a579f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82b7a8cee26b41a0ee3a993b05c0f3f/" rel="bookmark">
			青龙面板APP： 2.1.1版本（2024-03-10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 青龙面板是支持python3、javaScript、shell、typescript 的定时任务管理面板。本APP基于青龙面板接口开发，支持面板大部分原生功能 ，同时提供拓展模块，帮助用户快捷管理。
使用环境 安卓版本：8.0+面板版本：参考APP版本，选择合适软件版本 软件版本开发API 面板版本
备注1.x.x2.10.132.10.x仅支持2.10.x2.0.x2.10.13、2.15.17 全部，建议2.15.x
部分版本可能出现部分功能不可用2.1.0+2.15.17全部，建议2.15.x停止维护2.10.x版本 功能介绍 基础功能 提供定时任务、环境变量、配置文件、脚本管理、依赖管理、任务日志和系统设置功能，更多详细介绍请前往项目主页查看。
定时任务：支持增改删查、批量操作、查看日志、查看脚本、任务去重、本地备份和本地导入；环境变量：支持增改删查、批量操作、变量去重、快捷导入、本地备份和本地导入；配置文件：支持查看和修改配置；依赖管理：支持新建、删除、批量操作和查看日志；脚本管理：支持查看、编辑和删除脚本；任务日志：支持查看日志文件列表；系统设置：支持常规设置和登录日志查看； 拓展模块 拓展模块将在后续版本逐步开放，具体使用方法请查看相应文档。
Web助手 Web开发者工具，提供代码调试、cookie查看等功能。
Docker助手 docker容器可视化操作，提供容器操作、运行查看等功能。
界面预览 更新日志 修复已知场景闪退异常支持多账号切换支持面板自签证书HTTPS优化代码和部分细节 下载地址 本APP为开源项目，如需进行二次开发，拉取仓库即可。 Giteehttps://gitee.com/wsfsp4/QingLong
Githubhttps://github.com/FuShengPing/android-qinglong
APP下载地址 giteehttps://gitee.com/wsfsp4/QingLong/releases
交流反馈 如果你在使用过程中发现Bug或者有功能需求请创建Issue。
欢迎加入QQ交流群，可以获取到最新的软件资讯和最快的问题反馈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664393e16cbb697e437491fb2f4694ec/" rel="bookmark">
			【MyBatis-Plus 常用注解详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. @TableName2. @TableId3. @TableField4. @Version5. @TableLogic MyBatis-Plus（简称MP）是一个用于简化 MyBatis 操作的增强工具库，它在 MyBatis 的基础上扩展了一些功能，极大地提高了开发效率。
1. @TableName @TableName 注解用于指定实体类对应的数据库表名。它的作用是告诉 MyBatis-Plus 在进行 SQL 操作时应该使用哪个表。
示例代码：
@TableName("user") public class User { // 省略其他字段 } 在这个示例中，User 类将映射到数据库中的 user 表。
2. @TableId @TableId 注解用于标识主键字段。在 MyBatis-Plus 中，可以选择使用三种主键生成策略：IdType.AUTO（自动增长）、IdType.INPUT（手动输入）、IdType.ID_WORKER（分布式全局唯一 ID）等。
示例代码：
@TableId(value = "id", type = IdType.AUTO) private Long id; 这个示例中，id 字段被标识为主键，并且采用自动增长的方式生成主键值。
3. @TableField @TableField 注解用于标识实体类中的字段与数据库表中的字段的映射关系。可以指定字段名、是否为数据库字段、自定义字段填充策略等。
示例代码：
@TableField(value = "user_name", exist = true, fill = FieldFill.INSERT) private String userName; 在这个示例中，userName 字段映射到数据库表中的 user_name 字段，且该字段在插入数据时由自定义的填充策略进行填充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/664393e16cbb697e437491fb2f4694ec/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/44/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>