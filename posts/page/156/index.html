<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becb57ffe8de064f817bbae4390b1415/" rel="bookmark">
			神器 SpringDoc 横空出世最适合 SpringBoot 的API文档工具来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在SpringBoot项目中一直使用的是SpringFox提供的Swagger库，上了下官网发现已经有接近两年没出新版本了！前几天升级了SpringBoot 2.6.x 版本，发现这个库的兼容性也越来越不好了，有的常用注解属性被废弃了居然都没提供替代！无意中发现了另一款Swagger库SpringDoc，试用了一下非常不错，推荐给大家！
SpringDoc简介
SpringDoc是一款可以结合SpringBoot使用的API文档生成工具，基于OpenAPI 3，目前在Github上已有1.7K+Star，更新发版还是挺勤快的，是一款更好用的Swagger库！值得一提的是SpringDoc不仅支持Spring WebMvc项目，还可以支持Spring WebFlux项目，甚至Spring Rest和Spring Native项目，总之非常强大，下面是一张SpringDoc的架构图。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
使用
接下来我们介绍下SpringDoc的使用，使用的是之前集成SpringFox的mall-tiny-swagger项目，我将把它改造成使用SpringDoc。
集成
首先我们得集成SpringDoc，在pom.xml中添加它的依赖即可，开箱即用，无需任何配置。
&lt;!--springdoc 官方Starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt;
从SpringFox迁移
我们先来看下经常使用的Swagger注解，看看SpringFox的和SpringDoc的有啥区别，毕竟对比已学过的技术能该快掌握新技术；
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
接下来我们对之前Controller中使用的注解进行改造，对照上表即可，之前在@Api注解中被废弃了好久又没有替代的description属性终于被支持了！
/** * 品牌管理Controller * Created by macro on 2019/4/19. */ @Tag(name = "PmsBrandController", description = "商品品牌管理") @Controller @RequestMapping("/brand") public class PmsBrandController { @Autowired private PmsBrandService brandService; private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class); @Operation(summary = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becb57ffe8de064f817bbae4390b1415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce5a4846c84d3719d55e7ff26932018/" rel="bookmark">
			Element UI设置列表时间倒序/正序排序展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Element UI 的 el-table 中，可以通过设置 :sort-by 属性来指定表格列的排序属性。那么，如果要按时间倒序排序，只需要将 :sort-by 属性设置为日期字段名，同时在这个字段前加上符号“-”，表示降序排列。
因此，可以按以下步骤实现将 el-table-column 根据时间倒序排序：
在 el-table-column 上设置 :sortable 属性为 true，开启该列排序功能。 html复制代码
&lt;el-table-column label="待排序日期" align="center" prop="paixuDate" :sortable="true"/&gt; 在 el-table-column 上设置 :sort-by 属性为降序排序的日期字段名（即带有“-”的日期字段名）。 html复制代码
&lt;el-table-column label="待排序日期" align="center" prop="paixuDate" :sortable="true" :sort-by="'-paixuDate'"/&gt; 这样就可以实现对 el-table-column 按时间倒序排序了。最后，需要注意的是，使用 Element UI 的 el-table 进行排序时，日期数据需要以时间戳形式进行排序，否则会出现不正确的排序结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0899abb90d03b524147efcaddd3c6c77/" rel="bookmark">
			unity3D中使用Socket进行数据通信（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年3D产品的工作中心主要集中在提高产品深度上，通过对竞争产品的分析，发现我们的缺陷在于多人在线与后台管理部分，多人在线使用unity自带的Network可以搞定，后台部分前段时间主要研究了下Sqlite。由于sqlite本身不带服务器，作为数据库只是一个文件，sqlite放在服务器上与客户端通信的需求其实就是多个客户端访问同一个文件了，查了一些资料，有很多方法，个人感觉socket不错，一来应用广泛，自己学习后也是一个充电，而来操作灵活，比作文件共享更自由。所以就学习学习了。
基于TCP协议一个很重要的概念就是socket（套接字），记得大学时学的网络七层协议，当时是云里雾里，现在才算有了初步的了解，我们的编程只负责七层协议中的应用层，至于有应用层如何到传输层一直到最底层暂时就不用关心了，只需要知道socket帮我们搞定了底层一些东西。而我们程序对应socket的最重要的两个信息：ip地址和端口号。ip很容易理解，就相当于你家的门牌号，这是唯一的。端口号就相当于你家的窗户，你想出去的话可以走门，也可走窗户，走1号窗户，走2号窗户。。。。（类似电脑中的数据通信）
好了废话不多说，下面只是一个简单的服务器与客户端连接的Demo，后续会陆续放出数据发送与接收部分。我给出代码与测试部分，至于其他不懂的概念，可以自行百度。
1、Socket服务端
使用VS创建应用太控制程序，创建客户端。
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Net; using System.Net.Sockets; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { //IPAddress ip = new IPAddress(new byte[] { 127, 0, 0, 1 }); IPAddress ip = IPAddress.Parse("192.168.0.13"); //IPAddress ip = Dns.GetHostEntry(Dns.GetHostName()).AddressList[0]; TcpListener tlistener = new TcpListener(ip, 10001); tlistener.Start(); Console.WriteLine("服务器监听启动......"); while (true)//看上去是死循环，由于阻塞方法，大部分时间都在等待 { TcpClient remoteClient = tlistener.AcceptTcpClient();//接收已连接的客户端,阻塞方法 Console.WriteLine("客户端已连接！local:{0}&lt;---Client:{1}", remoteClient.Client.LocalEndPoint, remoteClient.Client.RemoteEndPoint); } //ConsoleKey key; //do //{ // key = Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0899abb90d03b524147efcaddd3c6c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e487244dadad1fdd72993a9a37cf317e/" rel="bookmark">
			【leetcode速通java版】05—— 快乐数、两数之和、四数相加II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言
🍉 作者简介：半旧518，长跑型选手，立志坚持写10年博客，专注于java后端
☕专栏简介：代码随想录leetcode速通训练营java版本
🌰 文章简介：T202,T1
T202 快乐数 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
思路：这道题目中出现了无限循环的判断，符合哈希表的应用条件，即：快速判断某个元素是否会重复出现。
class Solution { public boolean isHappy(int n) { // 解法1 哈希表 // 1.维护一个哈希表 Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); // 2.循环,判断这个数是否为1或者出现了重复数 while(n != 1 &amp;&amp; !set.contains(n)) { set.add(n); n = getNextNumber(n); } // 3.返回，通过判断n是否为1判断是否为快乐数 return n == 1; } private int getNextNumber(int n) { int result = 0; while(n &gt; 0) { int temp = n % 10; result += temp * temp; n = n / 10; } return result; } } T1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e487244dadad1fdd72993a9a37cf317e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e191b49e836e3ee732610ad84786d14f/" rel="bookmark">
			Linux下protobuf保姆级安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种安装方式，一种是通过链接安装，另一种是下载源文件安装。
我们来介绍后一种——通过源文件安装。
注意了，版本一定要安装正确，**v20开头和v3不是一个版本**。
两者最大的区别在于，v3开头的版本有autogen.sh文件，而v20开头的版本没有autogen.sh文件，所以我推荐使用v3开头的版本，当然自己也可以选择更合适的版本。
在安装过程中记得使用sudo命令，赋予管理员权限。
tar zxvf protobuf-all-3.19.4.tar.gz //解压
cd protobuf-3.19.4/ //进入解压目录
//检查并安装以下环境，Ubuntu使用apt-get安装，centos7环境使用yum
sudo apt-get install autoconf sudo apt-get install automake sudo apt-get install libtool
//以上安装成功后执行下面
./autogen.sh
//生成编译配置文件成功,运行配置脚本
./configure
sudo make //要编译很久
sudo make check //测试
sudo make install //安装
sudo ldconfig //更新一些动态链接库
protoc --vertion //在任何目录下输入这个命令，查看protoc版本，出现版本号即成功
期间遇到的问题：
1. 执行make check
virtual memory exhausted: Cannot allocate memory 或 c++: internal compiler ereor: killed(program cciplus) 有两种情况，一种是虚拟机，比如说vmware，那么只需要将虚拟内存从4G变成8G即可；第二种情况是服务器，比如说腾讯云服务器，那么只需要将swap分区设置为8G即可，命令如下：
# 1. 创建分区
sudo dd if=/dev/zero of=/swapfile bs=1M count=8192 #挂载和开启swap
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e191b49e836e3ee732610ad84786d14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c0ee6d7016428aa19c091596e92910/" rel="bookmark">
			SpringBoot学习笔记 (图文详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
快速搭建SpringBoot工程 搭建工具：IDEA
目标：创建Controller,在网页输出 “hello controller!”
(1) 新建项目: File -&gt; New -&gt; Project
(2) 按照图中选择文件类型，点击Next
注意：该创建项目的前提下是需要联网
(3) 为目标文件编辑相关信息，可参考下图
(4) 选择Web -&gt;Spring Web
(5) 文件进行加载，加载后目录如下图所示
(5) 点击右上角运行图标，若出现下列图标，说明启动没有问题
(6) 在 com.example.demo 包下新建 HelloController.java文件，编辑代码
代码如下:
package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping("hello") public String hello(){ return "hello controller!"; } } (7) 在任意一个浏览器输入 http://localhost:8080/hello，运行结果如图所示
SpringBoot起步依赖原理分析 spring-boot-starter-parent:
在 spring-boot-starter-parent 中定义了各种技术的版本信息，组合了一套最优搭配的技术版本在各种 starter 中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自父工程工程继承 parent ，引入starter后，通过依赖传递，就可以简单方便的获得需要的jar包，并且不会存在版本冲突问题。 SpringBoot 配置 配置文件分类： SpringBoot是基于约定的，很多配置都有默认值，可以使用 application.properties 或者 application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c0ee6d7016428aa19c091596e92910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1299661ba1672e757899b029f309b57f/" rel="bookmark">
			PHP简易开发的问卷调查系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目要求技术与UI设计设计模式系统功能模块设计数据库表关系图 系统展示系统主页面问卷增加界面问卷编辑界面问卷答题界面问卷结果导出到Excel下载Excel显示结果 题目要求 (1)问卷一览：展示相应问卷，并可针对问卷执行创建、编辑、删除等操作。
(2)问卷创建与编辑：创建新问卷或编辑已有问卷：
(3)问卷需要有标题、描述和可任意增减的调查条目。
(4)调查条目支持基础文本形式以及以下至少一种特殊形式：
Ⅰ：Drop down list
Ⅱ：Radio button
Ⅲ：Checkbox
(5)问卷发布：以链接或类似方式发布问卷，供其他人访问。
(6)问卷填写：使用生成的问卷链接打开问卷，并填写相关信息。
(7)问卷统计与导出：对于已发布的问卷，查看问卷填写的统计数据，并支持问卷数据的导出。
技术与UI设计 （1）开发语言：PHP
（2）数据库和工具：MySQL &amp;&amp; 数据库可视化工具 Navicat for MySQL
（3）开发环境：Apache + PHP + mysql
（4）UI设计：Bootstrap
（5）插件技术:PHPEXCEL
设计模式 MVC结构 + 面向对象编程
系统 功能模块设计 数据库表关系图 系统展示 系统主页面 对应用户创建的问卷，可以进行删除，编辑和生成问卷的操作。
问卷增加界面 操作“点击增加题目条数”按钮可以增加题目，同理也可以移除。
问卷编辑界面 （1）编辑界面可以设定问卷激活状态，使得答题链接按钮是否可以被点亮。
（2）激活状态的答题链接按钮被点亮，反之不被点亮。
问卷答题界面 最多包含四种提醒可选，包含Drop down list，Radio button，Checkbox，其中Drop down list有单选和多选两种选择，Radio button必为单选，Checkbox必为多选。
问卷结果导出到Excel 答题人页面结果查询。
下载Excel显示结果 显示和页面一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59545829c6932b0c21b77687f46d9df2/" rel="bookmark">
			ARM busybox 的移植实战2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、busybox 源码分析1 1、源码目录梳理 2、整个程序入口的确认 (1) 分析一个程序，不管多庞大还是小，最好的路线都是 按照程序运行时的逻辑顺序来。所以找到一个程序的入口至关重要。
(2) 学 C 语言的时候都知道，程序的主函数 main 函数就是整个程序的入口。这种情况适应于操作系统下工作的应用程序 的情况。
(3) 在 uboot 和 linux kernel 这两个大的 C 语言的项目中，main 函数都没有，都不是入口。在我们这种裸机程序中，入口不是 main 函数，而是由链接脚本来指定的。
(4) busybox 是 linux 启动起来后工作的一个应用程序，因此其中必然有 main 函数，而且 main 就是入口。
3、busybox 中 main 函数全解析 (1) busybox 入口就是 main 函数，其中有很多个 main，但是只有一个起作用了，其他的是没起作用的。真正的 busybox 工作时的入口是 libbb/appletlib.c 中的 main 函数。
(2) busubox 中有很多 xxx_main 的函数，这些 main 函数每一个都是 busybox 支持的一个命令的真正入口。
譬如 ls_main 函数，就是 busybox 当作 ls 函数使用时的入口程序。
(3) ls 或者 cd 等命令，其实都是 busybox 一个程序，但是实际执行时的效果却是各自的效果。busybox 是如何实现一个程序化身万千还能各自工作的？答案就是 main 转 xxx_main。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59545829c6932b0c21b77687f46d9df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ba12544e31753d93bf17bca3b6ad08/" rel="bookmark">
			Flutter中的动画魔法：让你的UI元素活起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter是一个跨平台的移动应用程序开发框架，提供了很多强大的工具和库，使开发人员可以快速地构建漂亮而且高效的应用程序。Flutter还提供了一组用于创建动画的类和函数。在本文中，我们将介绍Flutter动画特效的实现，包括使用AnimationController和Tween类创建动画、使用AnimatedWidget和AnimatedBuilder优化动画性能等。
使用AnimationController和Tween类创建动画 在Flutter中，动画是通过创建一个Animation对象和使用AnimationController和Tween类来实现的。Animation对象代表着一个可以产生值的抽象类，而AnimationController用于管理动画的运行和状态，Tween类用于定义动画的开始和结束值。下面是一个简单的动画实现，用于将一个容器从屏幕底部向上移动到屏幕中间。
class AnimationDemo extends StatefulWidget { @override _AnimationDemoState createState() =&gt; _AnimationDemoState(); } class _AnimationDemoState extends State&lt;AnimationDemo&gt; with SingleTickerProviderStateMixin { AnimationController _controller; Animation&lt;double&gt; _animation; @override void initState() { super.initState(); _controller = AnimationController(duration: Duration(seconds: 1), vsync: this); _animation = Tween&lt;double&gt;(begin: 0, end: 200).animate(_controller) ..addListener(() { setState(() {}); }); _controller.forward(); } @override void dispose() { _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Container( height: _animation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ba12544e31753d93bf17bca3b6ad08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c10d923d32de6915d7822d3657e03d/" rel="bookmark">
			【leetcode速通java版】04——哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言
🍉 作者简介：半旧518，长跑型选手，立志坚持写10年博客，专注于java后端
☕专栏简介：代码随想录leetcode速通训练营java版本
🌰 文章简介：哈希表理论，leetcodeT242,T349,T202,T1
一、哈希表的基础理论回顾 1.哈希表主要用来解决快速获取某个元素的问题。比如查找一个学校的姓名为张三的学生，如果用数组需要的时间复杂度为O(n),但是使用哈希表的时间复杂度为O(1).
2.哈希冲突是指经过哈希计算后，其存储位置在数组的同一个物理空间。一般哈希冲突有两种解决思路：(1)拉链法 (2)线性探测法。 如果使用拉链法，需要特别注意数组的长度，避免空值过多浪费空间，也需要避免因为拉链过长导致查找元素的时间代价过高。 使用线性探测法，必须保证数组大小大于需要存储的元素大小。
二、真题特训 leetcode T242 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true
示例 2: 输入: s = “rat”, t = “car” 输出: false
说明: 你可以假设字符串只包含小写字母。
解法1：排序
题中问题等价于：将两个字符串排序后相等。
class Solution { public boolean isAnagram(String s, String t) { // 题解1：排序后字符串相等 // 1. 判断长度是否相等 if(s.length() != t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c10d923d32de6915d7822d3657e03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a626ee344c65ef9615372d0fb96389/" rel="bookmark">
			Docker实战笔记4-安装jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/zhaoyanjun6/article/details/130318679
本文出自【赵彦军的博客】
文章目录 拉取 jenkins 镜像排查问题验证结果总结 拉取 jenkins 镜像 在官方镜像仓库查询 jenkins 镜像
https://hub.docker.com/r/jenkins/jenkins
拉取镜像
docker pull jenkins/jenkins 结果如下：
zhao@sh-zhao ~ % docker pull jenkins/jenkins:latest latest: Pulling from jenkins/jenkins dc80b8cdbfd3: Pull complete 1fd6cbbf3dee: Pull complete 6215f3cd952f: Pull complete e14feb424362: Pull complete 9182b3d95b04: Pull complete 841e11b2945e: Pull complete 509a83fa41e8: Pull complete 89dc3c2e5cf1: Pull complete d1b2cca7ed3e: Pull complete cc268a10fb20: Pull complete b22c15c6dd9e: Pull complete dd479dcfc7b5: Pull complete e816ba0de8af: Pull complete Digest: sha256:7560cc798140cdcdef5b75ca069c28b2a44f179827e3e55076ea18bdfb17b5aa Status: Downloaded newer image for jenkins/jenkins:latest docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a626ee344c65ef9615372d0fb96389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369e8753f5ecb1f845838cee9c0ccfe3/" rel="bookmark">
			什么是JWT？(细致讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JWT？ 转自：java技术爱好者
链接：https://www.zhihu.com/question/485758060/answer/2257869896
来源：知乎
起源 需要了解一门技术，首先从为什么产生开始说起是最好的。JWT 主要用于用户登录鉴权，所以我们从最传统的 session 认证开始说起。
session认证 众所周知，http 协议本身是无状态的协议，那就意味着当有用户向系统使用账户名称和密码进行用户认证之后，下一次请求还要再一次用户认证才行。因为我们不能通过 http 协议知道是哪个用户发出的请求，所以如果要知道是哪个用户发出的请求，那就需要在服务器保存一份用户信息(保存至 session )，然后在认证成功后返回 cookie 值传递给浏览器，那么用户在下一次请求时就可以带上 cookie 值，服务器就可以识别是哪个用户发送的请求，是否已认证，是否登录过期等等。这就是传统的 session 认证方式。
session 认证的缺点其实很明显，由于 session 是保存在服务器里，所以如果分布式部署应用的话，会出现session不能共享的问题，很难扩展。于是乎为了解决 session 共享的问题，又引入了 redis，接着往下看。
token认证 这种方式跟 session 的方式流程差不多，不同的地方在于保存的是一个 token 值到 redis，token 一般是一串随机的字符(比如UUID)，value 一般是用户ID，并且设置一个过期时间。每次请求服务的时候带上 token 在请求头，后端接收到token 则根据 token 查一下 redis 是否存在，如果存在则表示用户已认证，如果 token 不存在则跳到登录界面让用户重新登录，登录成功后返回一个 token 值给客户端。
优点是多台服务器都是使用 redis 来存取 token，不存在不共享的问题，所以容易扩展。缺点是每次请求都需要查一下redis，会造成 redis 的压力，还有增加了请求的耗时，每个已登录的用户都要保存一个 token 在 redis，也会消耗 redis 的存储空间。
有没有更好的方式呢？接着往下看。
什么是JWT JWT (全称：Json Web Token)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369e8753f5ecb1f845838cee9c0ccfe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703ed7b7eb996c97b8f3d10a36c7d29a/" rel="bookmark">
			arcMap 如何将投影坐标系shp文件转换成WGS84地理坐标shp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于开发过程中我们使用的都是地理坐标系，常常获取到的数据是投影坐标系，那么我们该如何转换呢？
我们可以利用arcMap桌面工具进行转换：
1、首先我们直接在地图上鼠标右键，选中数据框属性：
通过坐标系这个选项，可以看到当前图层坐标系，是不是地理坐标系，当前这个是投影坐标系，所以通过arcMap 导出shp的时候，将shp文件再转成GeoJson，发现不是地理坐标系，导致项目不能直接使用。
2、点击常规查看当前地图使用的是什么显示单位，转换地理坐标系的时候需要将显示单位修改成度分秒，这里单位有很多，如千米、米、度分秒等等..... 选好后点击确定。
3、点击ArcToolbox
5、会出现以下对话框：
6、双击选择投影，选择对应的类型。点击确定就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099e4b376803c034e65a1965f7f82d57/" rel="bookmark">
			墨者学院——SQL注入漏洞测试(POST)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试环境为Kali Linux
1.因为我开启的是“SQL注入漏洞测试(POST)”靶场，首先点击进去，能看到是一个登录界面，然后仔细摸索，察觉到主要问题就是登录，所以此时用BurpSuite
2.因为这个靶场主要的就是post测试，所以直奔主题，打开BurpSuite，开始post抓包，将内容全部复制到kali机的.txt文件中，值得注意的是，这些内容不宜存放太久，会失效，失效之后再重新抓一次
3.在kali终端，利用sqlmap攻击：首先就是找到数据库“sqlmap -r post.txt（这个文本文件就是刚刚的抓包内容） --level 5 --risk 3 --dbs --dbms mysql --batch”
4.找数据库里面的表“sqlmap -r post.txt --level 5 --risk 3 -D 数据库名 --tables --batch”
5.找数据库表里面的字段“sqlmap -r post.txt --level 5 --risk 3 -D 数据库名 -T 数据表名 --columns --dbms mysql --batch”
6.找字段内容“sqlmap -r post.txt --level 5 --risk 3 -D 数据库名 -T 数据表名 -C （字段1，字段2，....） --dump --dbms mysql --batch”
找到了登录名和密码，此时能看出这是加了密的密码，所以我们要用解密工具——MD5，这里推荐使用这个网页
7.将两个密码分别解出来，其中只有一个能使用，登进去后就发现了Key，最后回到提交页面，将Key提交，就完成了本次靶场的测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7a50d4b2bb2746b584cf4b2cdad8da/" rel="bookmark">
			【开发经验】spring事件监听机制关心的同步、异步、事务问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 spring发布订阅示例同步核心源码分析如何配置异步事务问题 观察者模式又称为发布订阅模式，定义为：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。 如下图所示，一个场景中，主要流程是用户下单，并且返回操作，但是下单之后，要做很多与主干业务无关的流程，如发送短信、发送邮件、积分增加等等。
这种模式想必大家多多少少都了解过，但是大家讨论最多的就是通过使用mq中间件实现发布订阅模式，但是如果没有中间件呢？本文重点阐述，在没有中间件的情况下，如何做到使用观察者模式解耦。
spring发布订阅示例 spring和guava都实现了比较优雅的发布订阅的框架，但是默认开发都会在spring的框架下开发。因此通过spring来实现发布订阅会更加方便一点。
主要业务流程代码，用户完成下单并且返回，并且发布订单下单事件。
@Autowired private ApplicationContext applicationContext; public String saveOrder(Order order){ this.orderMapper.save(order); //创建下单事件 this.applicationContext.publishEvent(new SaveOrderEvent(order)); return "下单成功"; } 创建下单事件类，描述该事件信息和当事件发生时可以添加一些通用代码。
// 下单事件 public class SaveOrderEvent extends ApplicationEvent { public SaveOrderEvent(Object source) { //编写事件后的代码 super(source); } } 事件监听，这里的写法示例两种（我也没研究过其他的写法）。一种是作用在类上，一个类一个监听事件，另一种可以总用在方法上，通过@EventListener来实现监听。
@Component public class SaveOrderEventListener implements ApplicationListener&lt;SaveOrderEvent&gt; { @Override public void onApplicationEvent(SaveOrderEvent event) { try { Thread.sleep(5000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println("线程name:"+Thread.currentThread().getName()+"类打印信息"+event); } } @Service public class OrderService{ @EventListener(SaveOrderEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d7a50d4b2bb2746b584cf4b2cdad8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1443c45d9b11c7f28d806de55a6a87/" rel="bookmark">
			python---每日销售额柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 实现步骤 1. 设计一个类，可以完成数据的封装
2. 设计一个抽象类，定义文件读取的相关功能，并使用子类实现具体功能
3. 读取文件，生产数据对象
4. 进行数据需求的逻辑计算（计算每一天的销售额）
5. 通过PyEcharts进行图形绘制
2. 数据定义相关 class Record: def __init__(self, date, order_id, money, province): self.date = date # 订单日期 self.order_id = order_id # 订单ID self.money = money # 订单金额 self.province = province # 销售省份 def __str__(self): return f"{self.date}, {self.order_id}, {self.money}, {self.province}" 3. 文件相关 import json from data_define import Record # 先定义一个抽象类用来做顶层设计，确定有哪些功能需要实现 class FileReader: def read_data(self) -&gt; list[Record]: """读取文件的数据，读到的每一条数据都转换为Record对象，将它们都封装到list内返回即可""" pass class TextFileReader(FileReader): def __init__(self, path): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1443c45d9b11c7f28d806de55a6a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05aaf6a11a26ba2eb8f0580e8c676e3/" rel="bookmark">
			【已解决】TypeError: meshgrid() got an unexpected keyword argument ‘indexing‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 训练swin transformer模型的时候报以下错误：
报错信息：TypeError: meshgrid() got an unexpected keyword argument 'indexing'
原因 torch版本导致的，已经没有indexing这个参数了，但是默认就是这个参数。
解决 直接删掉indexing="ij"即可，不影响程序，因为变成了默认参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa85fd4e62319ce2023fdc15c04d5d1/" rel="bookmark">
			MATLAB——tiff文件数据读取,modis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、geotiffread（）geotiffwrite（）读写 [A,R] = geotiffread(filename)
从filename指定的GeoTIFF文件中读取一个地理参考的灰度、RGB或多光谱图像或数据网格到A中，并创建一个空间参考对象，R。
[X, cmap, R] = geotiffread(filename)读取一个索引的图像到X和相关的彩色地图到cmap，并创建一个空间引用对象，R。
[A, refmat, bbox] = geotiffread (filename)将地理参考的灰度、RGB或多光谱图像或数据网格读入A，将相应的参考矩阵读入refmat，将边界框读入bbox。
[X, cmap, refmat, bbox] = geotiffread(filename)读取一个索引图像到X，相关的彩色地图到cmap，参考矩阵到refmat，和边界框到bbox。引用矩阵必须由GeoTIFF文件明确地定义，否则它和边界框将返回空。= geotiffread(url)从url读取GeoTIFF图像。= geotiffread(，idx)从多图像GeoTIFF文件或URL中读取一张图像。
基础代码 [Data,R] = geotiffread(); [SS,R] = geotiffread(samplename); %SS为tif数据的信息，是一个二维数组，R是tif数据的地理信息 info = geotiffinfo(samplename); % 读取tif数据的地理信息，为后面导出为tif数据提供地理信息 [nrows,ncols] = size(SS); %读取SS的行列数 %导出为tif outname = ['##.tif']; %存储位置和名字 geotiffwrite(outname,SS, R, 'GeoKeyDirectoryTag', info.GeoTIFFTags.GeoKeyDirectoryTag); 批量TIFF读取、年均值计算、批量写入（自定义输出路径） 在这里插入代码片 方法二 imfinfo、imread、imshow读取信息、数据，显示图像 读，并显示信息 filepath='D:\study\AOD\AVR\2021002.tif'; %%图像名称与路径 Info=imfinfo(filepath); %%获取图片信息并判断是否为tif tif='tif'; format=Info.Format; if (strcmp(format ,tif)==0) disp('载入的不是tif图像，请确认载入的数据'); %%确保载入的图像是tiff图像 end Slice=size(Info,1); %%获取图片z向帧数 Width=Info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa85fd4e62319ce2023fdc15c04d5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f14ecccbc89dcf2d7899270976762f0/" rel="bookmark">
			ChatGPT 中的人类反馈强化学习 (RLHF) 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前言2 人类反馈强化学习 (RLHF)2.1 奖励模型 (RM)2.2 近端策略优化算法 (PPO) 3 总结4 参考 团队博客: CSDN AI小组
相关阅读
ChatGPT 简介大语言模型浅探一关于 ChatGPT 必看的 10 篇论文从 ELMo 到 ChatGPT：历数 NLP 近 5 年必看大模型 1 前言 在当今数字化的时代，ChatGPT 的火热程度不断升级。ChatGPT 可以处理复杂的语言任务，从而解放人力资源，提高工作效率，减少成本。ChatGPT 的先进技术和广泛应用，使得它成为了当今最炙手可热的人工智能技术之一。无论是企业、学术机构，还是科技爱好者，都对 ChatGPT 的应用前景充满期待。
在这样的背景之下，CSDN AI 团队也想对 ChatGPT 进行简单的复现。根据ChatGPT官方博客可知，ChatGPT的训练方法与 InstructGPT 的训练方法基本一致 (如图1所示)，只是使用的数据集不一样。故在训练方法上，我们主要参考 InstructGPT 进行复现，基础模型使用的是 RWKV，拆分后共包含以下四个阶段：
(1) 语言模型预训练 (Language Model Pre-training)；(2) 有监督指令微调 (Supervised Fine-Tuning, SFT)；(3) 奖励模型的训练 (Reward Modeling, RM);(4) 使用近端策略优化算法进行强化学习 (Proximal Policy Optimization, PPO). 第 (1)、(2) 阶段的 Pre-training 和 SFT 由 @zxm2015 完成，可参考文章大语言模型浅探一。本文主要介绍第 (3)、(4) 阶段的内容，即人类反馈强化学习 (Reinforcement Learning from Human Feedback, RLHF)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f14ecccbc89dcf2d7899270976762f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632fdbee32e817c793dfd7349be6a79d/" rel="bookmark">
			关于 ChatGPT 必看的 10 篇论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 Transformer2 GPT-33 InstructGPT4 Sparrow5 RLHF6 TAMER7 PPO8 In-Context Learning8.1 Why Can GPT Learn In-Context8.2 What learning algorithm is in-context learning 9 Prompt参考 团队博客: CSDN AI小组
相关阅读
ChatGPT 简介从 ELMo 到 ChatGPT：历数 NLP 近 5 年必看大模型ChatGPT 中的人类反馈强化学习 (RLHF) 实战 2022年11月，OpenAI推出人工智能聊天原型ChatGPT，再次赚足眼球，为AI界引发了类似AIGC让艺术家失业的大讨论。
ChatGPT 是一种专注于对话生成的语言模型。它能够根据用户的文本输入，产生相应的智能回答。这个回答可以是简短的词语，也可以是长篇大论。其中 GPT 是 Generative Pre-trained Transformer（生成型预训练变换模型）的缩写。
下面列出了学习 ChatGPT 必看的 10 篇论文。
1 Transformer ChatGPT 使用的预训练模型 GPT，是在 Transformer 中的 decoder 基础上进行改造的。
Title：Attention Is All You NeedAbstract：The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632fdbee32e817c793dfd7349be6a79d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/155/">«</a>
	<span class="pagination__item pagination__item--current">156/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/157/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>