<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f8f608fa6b96879c90e87c08b161f4/" rel="bookmark">
			Android权限系统（二）：开机授予运行时权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DefaultPermissionGrantPolicy简介 Android开机后，除了根据上次开机的记录（runtime-permissions.xml）授予运行时权限外，一些系统重要的组件也需要提前授予运行时权限，最常见的时为系统重要功能的默认组件提前授予运行时权限，例如系统会为默认的浏览器提前授予位置相关的运行时权限。而这些授权操作，是在DefaultPermissionGrantPolicy类里面进行的。DefaultPermissionGrantPolicy在PermissionManagerService的构造函数中被创建。
默认应用的设置可以在设置-应用和通知-默认应用中找到。
frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
PermissionManagerService(Context context, @NonNull Object externalLock) { ... mDefaultPermissionGrantPolicy = new DefaultPermissionGrantPolicy( context, mHandlerThread.getLooper(), this); 在PMS的systemReady阶段中，会调用DefaultPermissionGrantPolicy#grantDefaultPermissions为每一个修改过运行时权限的userid提前授予运行时权限（创建新用户也会触发授权，此处略过）：
frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
@Override public void systemReady() { ... // If we upgraded grant all default permissions before kicking off. for (int userId : grantPermissionsUserIds) { mDefaultPermissionPolicy.grantDefaultPermissions(userId); } 提前授权的步骤分三步：1.系统特权组件授权；2.系统默认组件授权；3.特定文件指定授权。
frameworks/base/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
public void grantDefaultPermissions(int userId) { grantPermissionsToSysComponentsAndPrivApps(userId); grantDefaultSystemHandlerPermissions(userId); grantDefaultPermissionExceptions(userId); synchronized (mLock) { mDefaultPermissionsGrantedUsers.put(userId, userId); } } grantPermissionsToSysComponentsAndPrivApps系统特定组件授权 首先列出主用户下所有已安装的包，过滤掉以下包：1.不支持运行时权限的（targetsdk小于M）；2.没有声明申请权限的；3.不属于特权apk的；4.如果是属于更新过后的系统应用，原来的系统应用不是persistent的；5.如果不属于更新过后的系统应用，此应用不是persistent的；
6.没有系统（platform）签名的。其他包和UID小于10000（应用程序的首个UID）的包会被授予运行时权限。
frameworks/base/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
private void grantPermissionsToSysComponentsAndPrivApps(int userId) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f8f608fa6b96879c90e87c08b161f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d252056db6c2cd9c95f33ca22eb057c/" rel="bookmark">
			CodeBlocks17.12下载完美汉化版，直接使用冲冲冲！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经汉化的软件压缩包下载链接: https://pan.baidu.com/s/1D0GDnbEtqqgKs4Pyoygrgg
提取码: 5bit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da7f2c75ae1d18b48601f17a4042b5d/" rel="bookmark">
			CSS3——动画案例（奔跑的熊）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bear.png
分析：
采用运动曲线steps()，一个大盒子里有张图片，这张图片有熊运动的每一帧，每次向x轴的负方向运动一步，steps(8)，8步移动完整张图片
html代码
&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt; css代码
&lt;style&gt; body { background-color: #cccccc; } .box { width: 200px; height: 100px; background: url(media/bear.png) no-repeat; animation: bear 1s steps(8) infinite,w 6s linear forwards; } @keyframes bear { 0% { background-position: 0 0; } 100% { background-position: -1600px 0; } } @keyframes w { 0% {} 100% { transform: translateX(500px); } } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ab39251f4596c2da31b1334f2efd1b/" rel="bookmark">
			联邦学习框架FATE实践（训练/测试步骤及参数说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联邦学习框架FATE实践（训练/测试步骤及参数说明） 一、FATE概念1. 角色 二、训练1. 准备2. 定义上传数据配置文件（1）参数说明：（2）示例 3. 定义DSL 配置文件（1）概念（2）参数说明（3）示例 4．定义运行配置文件（1）概念（2）参数说明（3）示例 5. 训练过程（1）上传数据（2）开始建模（3）检查日志 三、测试1. 准备2. 定义预测配置文件（1）概念：（2）参数说明（3）示例 3. 预测过程4. 查看预测结果5. 下载预测结果 四、参考 一、FATE概念 1. 角色 在Fate的概念中分成3种角色，Guest、Host、Arbiter
（1）Guest表示数据应用方，在纵向算法中，Guest往往是有标签y的一方。一般是由Guest发起建模流程。
（2）Host是数据提供方
（3）arbiter是用来辅助多方完成联合建模的，主要的作用是用来聚合梯度或者模型,比如纵向lr里面,各方将自己一半的梯度发送给arbiter，然后arbiter再联合优化等等,arbiter还参与以及分发公私钥，进行加解密服务等等。
二、训练 1. 准备 在FATE中构建算法模型，需要准备三个配置文件。
（1）上传数据配置文件：用于上传数据
（2）DSL配置文件：用于定义建模任务
（3）运行配置文件：用于设置每个组件的参数
2. 定义上传数据配置文件 （1）参数说明： file: 文件路径
head: 指定数据文件是否包含表头
partition: 指定用于存储数据的分区数
work_mode: 指定工作模式，0代表单机版，1代表集群版
table_name&amp;namespace: 存储数据表的标识符号
（2）示例 { "file": "examples/data/breast_b.csv", "head": 1, "partition": 10, "work_mode": 0, "table_name": "hetero_breast_b", "namespace": "hetero_guest_breast" } 3. 定义DSL 配置文件 （1）概念 FATE 使用特定语言 DSL 来描述任务，各种模块可通过一个有向无环图组织起来。DSL 配置文件采用 json 格式，整个配置文件就是一个 json 对象 （dict）。在这个 dict 的第一级是 “components”，表示这个任务将会使用到的各个模块，每个独立的模块定义在 “components” 之下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ab39251f4596c2da31b1334f2efd1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6067287be3b044dcabd5c06d0a4a5004/" rel="bookmark">
			离散数学实验-C&#43;&#43;实现集合关系判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离散数学实验-C++实现集合有关关系的判断 1. 程序的设计思路与实现功能2. 编程调试过程中遇到的问题及其解决过程3.程序代码与运行结果4总结(心得体会)5.参考资料 1. 程序的设计思路与实现功能 1.求传递闭包：对于任意顶点i和j，若两顶点连通但非邻接点，且包含前n个点作为路径的中间节点，则添加将对应的m[i][j]赋为1。 2.等价：若满足自反，对称，传递性，则为等价关系。 3.等价类：对于有关系的点，输出与它有关系的点:若m[i][j]==1，输出每一个j元素。 4.划分：输出等价类，若已输出相同的等价类，则不输出该元素的等价类。 功能是：
对于给定的整数集合与对应关系
1.求关系的性质（自反，对称，传递，等价）
2.求关系的单个或多个闭包（自反，对称，传递，等价）
3.对于等价关系，输出划分
4.对于等价关系，输出等价类
注：好像用的不是warshall算法，不太懂，虽然做出了。
实验环境：C++，Code::Blocks
2. 编程调试过程中遇到的问题及其解决过程 1.划分时相同等价类的重复输出，重新调整了程序的运行顺序。
2.输出了多余的{}，重新调整了程序的运行顺序。
3.一些马虎的问题，检查并解决。
3.程序代码与运行结果 #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;fstream&gt; #define MAXE 16 using namespace std; bool is_eql,m_saved,m_added;//标记 int x=0;//结束符 class Relation { public: Relation(); void clrmem(); int Getpnum(){return pnum;} int Checkp(int p); int Read(); void Write();//读写 void EnterMtx(); void Enter(); int CtrlZ();//撤销闭包运算 void ShowSet(); void ShowMtx(); bool Judge();//判断关系 void GetClosure(bool gain[]);//计算闭包 void Closure();//闭包菜单 void EqualClass();//显示等价类 void ShowPart();//显示划分 private: int sets[MAXE]; bool matrix[MAXE][MAXE];//使用的矩阵 bool msave[MAXE][MAXE];//备份的矩阵 bool madd[MAXE][MAXE];//闭包运算中添加的关系，以矩阵方式储存 int pnum; int rnum;//点和关系的数量 int radd; }rs1; int ckerror() {//查错 if(cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6067287be3b044dcabd5c06d0a4a5004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d4e98a59fe14880f4d2eb490dda75e/" rel="bookmark">
			HTTP/3 来了 ！HTTP/2 还没怎么用起来呢，先一起扫个盲吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：billpchen
来源：占小狼的博客
2015 年 HTTP/2 标准发表后，大多数主流浏览器也于当年年底支持该标准。此后，凭借着多路复用、头部压缩、服务器推送等优势，HTTP/2 得到了越来越多开发者的青睐，不知不觉的 HTTP 已经发展到了第三代。本文基于兴趣部落接入 HTTP/3 的实践，聊一聊 HTTP/3 的原理以及业务接入的方式。
1. HTTP/3 原理 1.1 HTTP 历史 在介绍 HTTP/3 之前，我们先简单看下 HTTP 的历史，了解下 HTTP/3 出现的背景。
随着网络技术的发展，1999 年设计的 HTTP/1.1 已经不能满足需求，所以 Google 在 2009 年设计了基于 TCP 的 SPDY，后来 SPDY 的开发组推动 SPDY 成为正式标准，不过最终没能通过。不过 SPDY 的开发组全程参与了 HTTP/2 的制定过程，参考了 SPDY 的很多设计，所以我们一般认为 SPDY 就是 HTTP/2 的前身。无论 SPDY 还是 HTTP/2，都是基于 TCP 的，TCP 与 UDP 相比效率上存在天然的劣势，所以 2013 年 Google 开发了基于 UDP 的名为 QUIC 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能替代 TCP，使得网页传输更加高效。后经提议，互联网工程任务组正式将基于 QUIC 协议的 HTTP （HTTP over QUIC）重命名为 HTTP/3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d4e98a59fe14880f4d2eb490dda75e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7ea62ce58e3d50061bac3c0f39ab1b/" rel="bookmark">
			onclick事件传递变量参数&amp;拼接字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://blog.csdn.net/qq_37212970/article/details/96438987
报错：jsonObj is not defined at HTMLInputElement.onclick
源代码：拼接html
html += "&lt;td&gt;&lt;input type='submit' id='checkTutorInfoBtn' value='查看详情' onclick='checkTutor(jsonObj[i].tutorNo)'&gt;&lt;/td&gt;"; 解决：
字符串拼接问题
checkTutor()内第一个转义双引号表示checkTutor函数引用参数，第二个双引号和开头&lt;td&gt;前双引号为一对；然后加参数；后面第一个双引号表示开始字符串，第二个双引号为checkTutor函数结束引参。
html+= "&lt;td&gt;&lt;input type='submit' id='checkTutorInfoBtn' value='查看详情' onclick='checkTutor(\""+jsonObj[i].tutorNo+"\")';&gt;&lt;/td&gt;"; 输出html是这样的 &lt;td&gt;&lt;input type='submit' id='checkTutorInfoBtn' value='查看详情' onclick='checkTutor("20170000")';&gt; 多参
错误写法，被当做一个参数了
"&lt;td&gt;&lt;input type='submit' value='申请导师' onclick='applyTutor(\"" + jsonObj[i].surplusQuota + "," + jsonObj[i].tutorNo + "," + jsonObj[i].tutorName + "\")';&gt;&lt;/td&gt;" 正确写法
"&lt;td&gt;&lt;input type='submit' value='申请导师' onclick='applyTutor(\"" + jsonObj[i].surplusQuota + "\",\"" + jsonObj[i].tutorNo + "\",\"" + jsonObj[i].tutorName + "\")';&gt;&lt;/td&gt;" + 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1deb214b6570fc35c945c4a22f0797/" rel="bookmark">
			http status 500
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The server encountered an internal error () that prevented it from fulfilling this request
服务器遇到了一个内部错误()，阻止它完成此请求。
在Apache Tomcat/6.0.13日志中可以获得根本原因的完整堆栈跟踪。
java.lang.NullPointerException
空指针异常
空指针异常错误汇总
很明显，遇到的错误是直接运行了该jsp,说明起始jsp 应该不是该jsp.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37989168f9dd1db794a8dc2c37c63215/" rel="bookmark">
			博客迁移到Github Pages
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客迁移到Github Pages 我的新博客使用Hexo部署在了GithubPages上，地址为renzibei.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1755f0100935c1c0da7f457c32096b29/" rel="bookmark">
			PySide2基础篇（七）——QComboBox运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PySide2基础篇（七）——QComboBox运用 前言：
阅读这篇文章我能学到什么？
组合框是进行选择性输入常用的控件，这篇文章将介绍它的基本用法。
——如果你觉得这是一篇不错的博文，希望你能给一个小小的赞，感谢您的支持。
1 创建一个组合框 通过类QComboBox创建一个组合框对象，addItem()函数用于给组合框添加项。
代码示例：
from PySide2.QtWidgets import QApplication, QMainWindow, QComboBox app = QApplication([]) MainWindow = QMainWindow() ComboBox = QComboBox(MainWindow) ComboBox.addItem("1") ComboBox.addItem("2") ComboBox.addItem("3") MainWindow.show() app.exec_() 运行结果：
2 对组合框项的操作 一个组合框可以含有多个项供选择，我们可以对这些项进行添加、删除、修改等操作。
2.1 清空组合框 清空组合框的项很简单，只需要调用Clear()函数即可删除组合框所有的项。
代码示例：
from PySide2.QtWidgets import QApplication, QMainWindow, QComboBox app = QApplication([]) MainWindow = QMainWindow() ComboBox = QComboBox(MainWindow) ComboBox.addItem("1") ComboBox.addItem("2") ComboBox.addItem("3") ComboBox.clear() #清空组合框项 MainWindow.show() app.exec_() 运行结果：
2.2 插入组合框 有时候需要在某两项组合框之间插入一项，可以使用InsertItem()函数进行插入新项。
代码示例：
from PySide2.QtWidgets import QApplication, QMainWindow, QComboBox app = QApplication([]) MainWindow = QMainWindow() ComboBox = QComboBox(MainWindow) ComboBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1755f0100935c1c0da7f457c32096b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ffca73c6c634d0777134d120423c44/" rel="bookmark">
			论文笔记：Improved Deep Embedded Clustering with Local Structure Preservation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 DEC 忽略了至关重要的因素，即定义的聚类损失可能会破坏特征空间（聚类损失不能保证局部结构的保存），从而导致无代表性的无意义特征，进而损害聚类性能。
文章提出的Improved Deep Embedded Clustering algorithm(IDEC) 考虑到了保留数据结构，利用聚类损失作为指导，操纵特征空间来分散数据点。 为了约束数据生成分布的局部结构，采用了一种欠完备的自动编码器。通过融合聚类损失和自动编码器的损失，IDEC联合聚类标签分配和学习适合聚类并保留数据结构的特征，最后的优化问题采用mini-batch梯度下降法和反向传播。
论文链接：https://www.ijcai.org/Proceedings/2017/0243.pdf
github：https://github.com/dawnranger/IDEC-pytorch
1.介绍 在本文中，提出了改进的深度嵌入式群集（IDEC）算法来处理数据结构p保留。
具体来说，
（1）使用聚类损失作为指导来操纵特征空间以分散数据点。
（2）为了约束操作并维护数据生成分布的局部结构，应用了不完整的自动编码器。
（3）通过集成聚类损失和自动编码器的重建损失，IDEC可以共同优化聚类标签分配，并学习适用于使用局部结构保留进行聚类的功能。
（4）通过小批量随机梯度下降和反向传播可以有效地解决由此产生的优化问题。
（5）在图像和文本数据集上的实验从经验上验证了局部结构保存的重要性和算法的有效性。
总之：IDEC 可以联合执行聚类并学习具有局部结构保护的代表性特征。
2.网络框架 聚类损失(Clustering loss)用于分散嵌入点 z z z，重建损失可确保嵌入空间保留数据生成分布的局部结构
3.模块详解 3.1 Autoencoder 自动编码器是一种神经网络，它被训练来尝试将其输入复制到其输出。在内部，它有一个隐藏层z，用z描述表示输入的代码。整个网络包括两部分编码函数和解码函数，其中解码函数用于产生重构。
自动编码器有两种类型：
不完全表示的自动编码器(Under-complete autoencoder)去噪自动编码器(Denoising autoencoder) 1.Under-complete autoencoder
它控制低于输入数据x的潜在数据z的维数。学习这种不完全的表示迫使自动编码器捕获数据的最显著特征。
2.Denoising autoencoder
与重建x给定x不同，去噪自动编码器将以下目标最小化：
其中，其中 x ~ \tilde{x} x~ 是被某种形式的噪声破坏的x的副本。.因此，去噪自动编码器必须从这种损坏中恢复 x x x，而不是简单地复制它们的输入。通过这种方式，去噪自动编码器可以强制编码器和解码器隐式捕获数据生成分布的结构。在该算法中，去噪自动编码器被用于预训练，欠完备自动编码器用于DEC框架的初始化。
3.2 聚类损失和初始化 定义为分布P和Q之间的KL散度，其中Q是根据学生的t分布测量的软标签的分布，P是从Q得出的目标分布。也就是说，聚类损失定义为：
软分配
测量嵌入点和质心之间的相似度：
目标分布
目标分布（辅助分布）用来衡量样本属于某个聚类的分布：
局部结构保护
之前获得的嵌入点不一定适合聚类任务。 为此，DEC 放弃了解码器，并使用聚类损失Lc对编码器进行了微调。
但是，我们认为这种微调可能会使嵌入空间变形，削弱嵌入特征的代表性，从而损害群集性能。 因此，我们建议保持解码器不受影响，并将聚类损失直接附加到嵌入式空间。
为了确保聚类损失的有效性，在预训练中使用的堆叠式去噪自动编码器已不再合适。 因为应该对干净数据的特征进行聚类，而不是对自动编码器进行降噪的噪声数据进行聚类。
因此，我们直接消除了噪音。 然后，堆叠的去噪自动编码器会退化为不完整的自动编码器。 重建损耗由均方误差（MSE）衡量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7ffca73c6c634d0777134d120423c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c40dd0e349385b4b5796403748af4c0/" rel="bookmark">
			什么是函数式编程思维？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是函数式编程思维？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ee66f9b64ffc0db7cac1385ece0ab5/" rel="bookmark">
			CVE-2020-1301: Windows SMB v1 远程代码执行漏洞通告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2020-1301: Windows SMB v1 远程代码执行漏洞通告 360-CERT [三六零CERT ](javascript:void(0)😉 三六零CERT 微信号 CERT-360功能介绍 360CERT是360成立的针对重要网络安全事件进行快速预警、应急响应的安全协调中心 今天
0x00 漏洞背景 2020年06月09日， 360CERT监测发现 微软官方 发布了 SMB v1 远程代码执行漏洞 的风险通告，该漏洞编号为 CVE-2020-1301，漏洞等级：高危。
SMB(Server Message Block) 是网络文件共享系统（Common Internet File System，缩写为CIFS），一种应用层网络传输协议，由微软开发，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。
SMB v1 存在 远程代码执行漏洞，远程攻击者 通过 向受影响的系统发送特制请求包，可以造成 远程代码执行。
对此，360CERT建议广大用户及时安装最新补丁，做好资产自查以及预防工作，以免遭受黑客攻击。
0x01 风险等级 360CERT对该漏洞的评定结果如下
评定方式等级威胁等级高危影响面广泛 0x02 影响版本 Windows SMB：v1 0x03 修复建议 通用修补建议： 微软已在 2014 年弃用了 SMBv1 协议，在 Windows 10 操作系统上 SMBv1 默认禁用。
推荐用户参考微软官方指引禁用 SMBv1 协议。
How to detect, enable and disable SMBv1, SMBv2, and SMBv3 in Windows | Microsoft Docs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ee66f9b64ffc0db7cac1385ece0ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55c4370b9fa287e6a9916d1d9c175e3/" rel="bookmark">
			python进程间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述消息队列管道共享内存服务器进程 概述 python的进程间通信主要有以下几种方式：消息队列（Queue）、管道（Pipe）、共享内存（Value,Array）、代理（Manager）,
以上分为两个类型，
进程间交互对象：消息队列（Queue）、管道（Pipe）
进程间同步：共享内存（Value,Array）、代理（Manager）
消息队列 消息队列常用于单向交互，消息队列操作简单，用于单向交互最方便。
示例
from multiprocessing import Process, Queue def f(q): q.put([42, None, 'hello']) if __name__ == '__main__': q = Queue() p = Process(target=f, args=(q,)) p.start() print(q.get()) # prints "[42, None, 'hello']" p.join() 管道 这是最常用的一种操作方法，
from multiprocessing import Process, Pipe def f(conn): conn.send([42, None, 'hello']) conn.close() if __name__ == '__main__': parent_conn, child_conn = Pipe() p = Process(target=f, args=(child_conn,)) p.start() print(parent_conn.recv()) # prints "[42, None, 'hello']"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55c4370b9fa287e6a9916d1d9c175e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6be605138176691b2dfdcf857bb3171/" rel="bookmark">
			游戏盾原理和优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是游戏盾呢
游戏盾是DDoS高防IP产品系列中针对游戏行业的安全解决方案。 游戏盾专为游戏行业定制，针对性解决游戏行业中复杂的DDoS攻击、游戏CC攻击等问题。目前以对抗的形式存在的高防产品形态，也就是防御带宽要大于攻击者的流量。
游戏盾有哪些功能呢
游戏盾包含抗D节点，通过分布式的抗D节点，游戏盾可以做到防御600G以上的攻击。
游戏盾包含防御CC集群，通过针对私有协议的解码，支持防御游戏行业特有的CC攻击。
游戏盾在用户SDK集成后接入，拥有最快的调度能力和加密能力。
游戏盾的原理是什么
全新一代云防系统，为所有TCP业务提供防御解决方案，全面支持Windows、Linux、Unix、MacOS、IOS、Android等平台，端游，手游APP,智能链路加速，多节点无缝切换，完美解决DDoS、CC等网络攻击，真正做到用户无感体验。
防御DDOS的原理
与普通的高防机房不同，游戏盾不是通过海量的带宽硬抗攻击，而是通过分布式的抗D节点，多加速节点，将黑客的攻击进行有效的拆分和调度，使得攻击无法集中到某一个点上。
防御CC攻击的原理
一般来说，游戏行业的CC攻击跟网站的CC攻击不一样。网站类的CC攻击主要是基于HTTP或者HTTPS协议，协议比较规范，相对容易进行数据分析和协议分析。但是游戏行业的协议大部分是私有的或者不常见的协议，因为对于CC攻击的防御，网盾科技推荐专业的防御CC集群。
游戏盾的优势是什么呢
TB级防御系统
分布式云节点防御集群，可跨地区、跨机房动态扩展防御能力和负载容量，轻松达到TB级防御，结合流量调度中心，能抵御市面上绝大多数DDoS攻击。
智能CC防御
采用独家研发的IP画像、基因识别等多维算法体系，快速识别攻击源，自动过滤非法数据包，内置AI模型能自动深度学习攻击数据，不断优化防御机制和算法策略。
完美隐藏源机
自研核心技术架构形成一道天然屏障，从源头彻底隐藏源机IP和端口，漏洞扫描和网络攻击无从下手，攻击流量无法直接到达源机，保障后端服务器稳定运行和数据安全。
通用防御架构
全平台支持，通用防御产品。适合所有TCP端类应用，兼容所有开发语言。全面支持Windows，Linux，Unix，MacOS，Android，IOS等操作系统。
节点实时调度
当业务遭遇大规模DDoS和CC攻击，导致单个或多个高防云节点延迟过大或进入黑洞时，网盾调度中心能自动感知并无缝切换其他可用节点，0延迟0误封，用户无感体验。
动态网络加速
网盾运行后，会实时检测客户端的网络情况，智能选择到云节点池延迟最低线路，保证每一条链路都是最佳路由，有效解决互联互通问题。
杜绝DNS劫持
客户端集成网盾后，所有数据包基于云节点转发并加密，结合独家研发的私有协议认证，可有效免疫DNS劫持。
部署配置灵活
无需投入任何硬件设备，只需几个步骤即可接入，集成方式灵活，支持EXE打包、DLL引用、SDK开发。部署过程对于玩家和用户透明，不影响原有业务流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb336aac09673176987f4f8c555c168/" rel="bookmark">
			白嫖一个web ssl 证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享如下内容：
在Azure App Service ”白嫖“一个SSL证书。
视频介绍; B站：https://www.bilibili.com/video/BV1sz4y1d7Vo/
图文介绍： 限制条件如下：
免费应用服务托管证书是用于保护应用服务中的自定义 DNS 名称的统包解决方案。 它是一个功能完备的 TLS/SSL 证书，由应用服务管理并自动续订。 免费证书具有以下限制：
不支持通配符证书， 例如，不支持*.51azure.cloud， 必须为每一个前缀的域名单独申请免费证书，比如单独为blog.51azure.cloud, www.51azure.cloud申请。不支持裸域，例如不支持 51azure.cloud, 简单理解，必须有前缀的域名才支持。不可导出。不支持 DNS A 记录。 截至2020.05月，该功能仅在Global Azure 可用。
案例：
为App Service 添加一个免费的SSL 证书；
步骤如下：
1. 创建一个APP Service, 注意层级SKU选择；
2. 配置自定义域，在域名供应商处验证域名所有权；
3. 添加一个免费的SSL证书；
4. 将证书配置到App Service的自定义域上；
5. 通过https 和自定义域访问 App Service；
1. 创建一个APP Service, 注意层级SKU选择；
注意SKU中 不是所有的都支持自定义域和SSL：
注意，对于 Dev/Test B1才支持 Custom domain 和SSL
2. 配置自定义域，在域名供应商处验证域名所有权；
如下图，我们增加了一个 自定义的域名，"后缀"为 51azure.cloud,
需要增加 CNAME 以验证域名所有权：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb336aac09673176987f4f8c555c168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd5575c98f7ee1dd6df3d4bbbbe15c0/" rel="bookmark">
			Echarts树形结构图加点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引入js 二.前端 &lt;div id="statisticChart" style="height:800px"&gt;&lt;/div&gt; // 基于准备好的dom，初始化echarts图表 var dataTjChart = ""; var option = ""; $(function () { task_tableName = getUrlParam("task_tableName"); task_result = getUrlParam("task_result"); // 路径配置 // require.config({ // paths: { // echarts: getContextPath()+'/plugins/echarts' // } // }); function initChart(dataInfo) { // 使用 dataTjChart = echarts.init(document.getElementById('statisticChart')); // dataTjChart = ec.init(document.getElementById('statisticChart')); //4.树绑定事件 // dataTjChart.on('click', function(params) { // var name = params.data.name;//点击的节点的name // var value = params.data.value;//点击的节点的value // //调用点击事件 // clickNode(name,value); // }); dataTjChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd5575c98f7ee1dd6df3d4bbbbe15c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f331df494a4dbcc786965f986d5b7619/" rel="bookmark">
			jvritualVM监听远程主机的JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地使用 jvritualVM 监听远程主机的JVM情况，做调优分析
1、服务器上安装java的jdk环境。
2、远程主机开启RMI支持，服务器上的java安装的bin下（如/usr/local/jvm/java-openjdk/bin）新建一个文件:jstatd.all.policy
内容：
grant codebase "file:${java.home}/../lib/tools.jar" {
permission java.security.AllPermission;
};
3、启动Jstatd服务器
./jstatd -J-Djava.rmi.server.hostname=&lt;192.168.0.20&gt; -J-Djava.security.policy=jstatd.all.policy -p &lt;1099&gt; &amp;
4、查看是否启动成功
netstat -anp | grep *jstatd
结果：
5、打开本地电脑 jdk 安装目录 bin下的 jvisualvm.exe
远程 -》 添加远程主机 -》 输入远程服务器IP地址（上面配置的hostname信息）
点击服务器ip-》 添加jstatd连接 -》填写如下配置
然后会看见服务器上所有jar项目都会出现
6、jvisualvm.exe安装 Visual GC插件
菜单栏-》工具-》插件-》可用插件-》搜索Visual GC -》勾选，安装-》重启exe
至此，可以本地监控测试服务器的jvm信息，做调优分析了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d810ad85b932a5127ea4832e538a38b/" rel="bookmark">
			CAS-认证流程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 名词解释 AS Authentication Service：认证服务，发放TGT
KDC Key Distribution Center：密钥发放中心
TGS Ticket-Granting Service：票据授权服务，索取TGT，发放ST
TGC ticket-granting cookie：授权的票据证明，由CAS Server通过SSL方式发送给终端用户。该值存在Cookie中，根据TGC可以找到TGT。
TGT Ticket Granting tieckt：俗称大令牌，或者票根，由KDC和AS发放，获取该票据后，可直接申请其他服务票据ST，不需要提供身份认证信息
ST Service Ticket：服务票据，由KDC的TGS发放，ST是访问server内部的令牌
CAS认证流程 CAS (Central Authentication Service)中央身份验证服务认证流程如下：
访问服务：由于CAS client和WEB应用部署在一起，当用户访问WEB应用时，CAS client就会处理请求定向认证：CAS client客户端校验HTTP请求中是否包含ST和TGT，如果没有则会重定向到CAS server地址进行用户认证用户认证：用户通过浏览器填写用户信息，提交给CAS Server认证发放票据：CAS Server校验过用户信息后，为CAS client发放ST，并在浏览器cookie中设置TGC，下次访问CAS Server时会根据TGC和TGT验证，判断是否已经登录验证票据：CAS Client拿到ST后，再次请求CAS Server验证ST合法性，验证通过后允许客户端访问传输用户信息：CAS Server校验过ST后，传输用户信息给CAS client 代码示例 phpCAS库： https://github.com/apereo/phpCAS
使用phpCAS实现对于访问www.baidu.com的访问控制
&lt;?php require_once './vendor/apereo/phpcas/CAS.php'; $home = 'http://www.baidu.com/'; $login_url = 'http://10.91.156.174:8080/cas/login?service='.urlencode($home); $logout_url = 'http://10.91.156.174:8080/cas/logout'; $service_validate_url = 'http://10.91.156.174:8080/cas/serviceValidate'; phpCAS::setDebug(); //设置client属性 phpCAS::client(CAS_VERSION_2_0, "10.91.156.174", 8080, "/cas"); // 设置 Login url phpCAS::setServerLoginURL($login_url); // 设置 logout url phpCAS::setServerLogoutURL($logout_url); // 设置 validate url phpCAS::setServerServiceValidateURL($service_validate_url); // cas server 设置不校验 ssl 证书 phpCAS::setNoCasServerValidation(); // 这个方法确保用户是否验证过，如果没有验证则跳转到验证界面。 phpCAS::forceAuthentication(); 通过php -S localhost:8080启动服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d810ad85b932a5127ea4832e538a38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb277fb046ba23c4b09be61939edb793/" rel="bookmark">
			shell脚本实现for循环打印数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		array=("beijing" "tianjin" "hebei") #echo ${array[0]} for((i=0;i&lt;${#array[@]};i++)); do echo ${array[$i]} done 数组要用括号加空格的方式进行声明，利用@或*，可以将数组扩展成列表，然后使用#来获取数组元素的个数，格式如下：
${#array[@]}
${#array[*]}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/380/">«</a>
	<span class="pagination__item pagination__item--current">381/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/382/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>