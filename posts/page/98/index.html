<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bd6b05da0d3f60fa9dbc5e73a8fb54/" rel="bookmark">
			[MT8766][Android12] user版本默认去除usb调试授权弹框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开发平台基本信息问题描述解决方法 开发平台基本信息 芯片: MT8766
版本: Android 12
kernel: msm-4.19
问题描述 user版本默认连接电脑的时候，会弹出一个鉴权弹框，点击允许才能够使用adb操控设备；对于我们公司的大部分产品来说，都是默认允许adb调试的；方便调试功能。
解决方法 原理也很简单，找到弹框的地方，把弹框去掉，然后默认授权就行了。 --- a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java +++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java @@ -82,6 +82,7 @@ public class UsbPermissionActivity extends AlertActivity } String appName = aInfo.loadLabel(packageManager).toString(); + /* final AlertController.AlertParams ap = mAlertParams; ap.mTitle = appName; boolean useRecordWarning = false; @@ -133,8 +134,39 @@ public class UsbPermissionActivity extends AlertActivity com.android.internal.R.id.clearDefaultHint); mClearDefaultHint.setVisibility(View.GONE); } + */ setupAlert(); + + mPermissionGranted = true; + + /* + IBinder b = ServiceManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92bd6b05da0d3f60fa9dbc5e73a8fb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899f489c6fcd5af811428ab4f2d2232e/" rel="bookmark">
			[MT8766][Android12] 系统设置隐藏休眠时间和锁屏选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开发平台基本信息问题描述解决方法 开发平台基本信息 芯片: MT8766
版本: Android 12
kernel: msm-4.19
问题描述 最近开发的一款智能盒子，没有屏幕显示；所以，系统默认设置成永不休眠以及默认不锁屏；但是，如果去系统设置中重新设置休眠时间或者更改锁屏方式，还是会触发设备的休眠跟锁屏；所以，干脆把系统设置中的休眠时间选项和锁屏设置选项隐藏掉。
解决方法 隐藏休眠时间选项 --- a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/display_settings.xml +++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/display_settings.xml @@ -73,12 +73,12 @@ &lt;/com.android.settingslib.RestrictedPreference&gt; &lt;!-- Cross-listed item, if you change this, also change it in power_usage_summary.xml --&gt; - &lt;com.android.settingslib.RestrictedPreference + &lt;!-- &lt;com.android.settingslib.RestrictedPreference android:key="screen_timeout" android:title="@string/screen_timeout" android:summary="@string/summary_placeholder" android:fragment="com.android.settings.display.ScreenTimeoutSettings" - settings:controller="com.android.settings.display.ScreenTimeoutPreferenceController" /&gt; + settings:controller="com.android.settings.display.ScreenTimeoutPreferenceController" /&gt; --&gt; &lt;SwitchPreference android:key="auto_rotate" 隐藏锁屏界面 --- a/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/dashboard/suggestions/SuggestionFeatureProviderImpl.java +++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/dashboard/suggestions/SuggestionFeatureProviderImpl.java @@ -71,7 +71,8 @@ public class SuggestionFeatureProviderImpl implements SuggestionFeatureProvider } else if (className.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899f489c6fcd5af811428ab4f2d2232e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1f38b2a372cbefc0079787a4b69b23/" rel="bookmark">
			Java&#43;SSM&#43;MySQL基于微信的在线协同办公小程序(附源码 调试 文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于微信的在线协同办公小程序 一、引言二、系统设计三、技术架构四、管理员功能设计五、员工功能设计六、系统实现七、界面展示八、源码获取 一、引言 随着科技的飞速发展，移动互联网已经深入到我们生活的各个角落。在这个信息时代，微信作为全球最大的社交平台，其影响力不可忽视。本文将探讨一种基于微信的在线协同办公小程序，该小程序旨在提高工作效率，优化工作流程，实现团队协作。通过微信平台，我们可以方便地进行沟通、协作和共享资源，为现代企业提供了一种高效、便捷的办公解决方案。
二、系统设计 本系统主要分为管理员和员工两种用户角色。管理员主要负责用户管理、部门管理、通知公告管理、考勤管理、请假管理、会议管理和系统管理等功能。员工用户则主要负责注册登录、通知公告、考勤、请假、会议、个人信息、修改密码和退出登录等功能。通过这种角色划分，我们可以确保系统的正常运行和管理。
三、技术架构 本系统服务器主要采用Java语言的SSM框架和Mysql数据库。SSM框架是Spring、SpringMVC和MyBatis的集合，它简化了企业级应用的开发，提高了开发效率。Mysql数据库是一种关系型数据库，具有高性能、高并发、易用性等优点，能够满足本系统的数据存储需求。通过这种技术架构，我们可以确保系统的稳定性和可扩展性。
四、管理员功能设计 用户管理：管理员可以添加、删除、修改用户信息，以及分配用户到不同的部门。这样，管理员可以根据团队的需要，灵活地调整人员配置。部门管理：管理员可以创建、删除、修改部门信息，以及调整部门结构。这样，管理员可以根据公司的发展战略，合理地调整组织结构。通知公告管理：管理员可以发布、删除、修改通知公告，以及查看公告的阅读情况。这样，管理员可以及时地传达公司的重要信息，提高员工的工作效率。考勤管理：管理员可以查看员工的考勤记录，以及导出考勤报告。这样，管理员可以了解员工的出勤情况，为公司的人力资源管理提供依据。请假管理：管理员可以审批员工的请假申请，以及查看请假记录。这样，管理员可以合理安排员工的休假时间，保证公司的正常运营。会议管理：管理员可以创建、删除、修改会议，以及发送会议邀请。这样，管理员可以方便地组织和管理公司的会议活动，提高会议的效率。系统管理：管理员可以设置系统参数，以及备份和恢复数据。这样，管理员可以确保系统的安全和稳定运行。 五、员工功能设计 注册登录：员工可以通过微信账号注册和登录系统。这样，员工可以方便快捷地使用系统，提高工作效率。通知公告：员工可以查看公司的通知公告，以及查看公告的阅读情况。这样，员工可以及时了解公司的重要信息，提高工作效果。考勤：员工可以查看自己的考勤记录，以及提交请假申请。这样，员工可以了解自己的出勤情况，合理安排工作时间。请假：员工可以提交请假申请，以及查看请假记录。这样，员工可以方便地申请休假，保证自己的休息时间。会议：员工可以查看会议邀请，以及参加会议。这样，员工可以方便地参加公司的会议活动，提高会议的效果。个人信息：员工可以查看和修改个人信息，以及修改密码。这样，员工可以方便地管理自己的个人信息，保证系统的安全性。退出登录：员工可以选择退出登录。这样，员工可以在需要的时候安全地退出系统，保护自己的信息安全。 六、系统实现 本系统的实现主要包括前端界面设计和后端逻辑处理两部分。前端界面设计主要使用微信小程序开发工具，后端逻辑处理主要使用Java语言和SSM框架。通过这种实现方式，我们可以确保系统的用户体验和稳定性。
本系统在开发完成后，进行了详细的测试，包括功能测试、性能测试和安全测试。测试结果显示，本系统能够稳定运行，满足设计要求。通过这种测试方式，我们可以确保系统的质量和完善性。
基于微信的在线协同办公小程序，通过微信平台，实现了高效的团队协作，提高了工作效率，优化了工作流程。本系统的设计和技术实现，为移动办公提供了一种新的解决方案。通过这种创新的办公方式，我们可以更好地适应现代企业的发展和变化。
七、界面展示 八、源码获取 欢迎大家点赞、收藏、关注、评论、批评啦 、查看👇🏻👇🏻获取联系方式👇🏻👇🏻A6834H
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4405e9cc43d6b32983728c3ff2952e72/" rel="bookmark">
			BeanUtils.copyProperties浅拷贝的坑你得知道？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想写一篇文章，主要关于深拷贝和浅拷贝相关的，主要是最近写代码的时候遇到一个BUG，刚好涉及到浅拷贝导致的问题。
问题背景 现在有一个需要是需要修改门店信息，门店也区分父门店和子门店，父门店被编辑更新是需要通过到第三方的，然后之前是没有父子门店的概念的，后面新增的需求，然后editShop这个方法的入参就是关于门店的信息么，这里我简化它的参数，但是保留了一个data属于引用型参数。
下面的模拟当时出现BUG的代码
public class RequestDto { Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); private Integer status ; private Long id; public Map&lt;String, Object&gt; getData() { return data; } } public class ShopService { public void editShop(RequestDto requestDto) { System.out.println("入参：" + requestDto.toString()); // 操作 // 父门店获取子门店，假设有两个 List&lt;Long&gt; childShops = getChildShop(requestDto.getId()); childShops.stream().forEach(childShop -&gt; { RequestDto requestDto1 = new RequestDto(); BeanUtils.copyProperties(requestDto, requestDto1); requestDto1.setId(childShop); requestDto1.getData().put("isSync", Boolean.FALSE); editShop(requestDto1); sync(childShop); }); System.out.println("返回前：" + requestDto.toString()); if (Boolean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4405e9cc43d6b32983728c3ff2952e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357f755bc3c4869bb217381c1b0af3e2/" rel="bookmark">
			springboot核心配置与注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.application.properties配置文件
1.1主要作用
1.2基本语法
二.application.yaml配置文件 2.1yaml文件的优点
2.2 基本语法
三.@Configuration注解和@bean注解
@Configuration注解
@Bean注解
四.springboot注解大全
元注解
基本注解
启动注解
HTTP注解
其他注解
一.application.properties配置文件 1.1主要作用 配置应用程序属性：可以在application.properties文件中配置应用程序的各种属性，如数据库连接、日志级别、端口号等。通过这些属性的配置，可以使应用程序适应不同的环境和场景需求。
简化配置：Spring Boot致力于简化配置，通过application.properties文件，开发人员可以集中管理大部分应用程序的配置。相比传统的XML或Java配置方式，使用键值对的形式，使配置文件更加简洁和易于维护。
外部化配置：application.properties文件支持外部化配置，即将配置项的值从代码中分离出来，在不修改代码的情况下，通过修改配置文件来改变应用程序的行为。这样可以方便地进行配置的切换和动态调整。
配置多个环境：Spring Boot允许在不同的配置文件中定义相同的属性，通过激活不同的配置文件来选择不同的应用程序行为。例如，可以使用application-dev.properties和application-prod.properties文件来分别配置开发环境和生产环境的属性。
支持属性引用和覆盖：通过${key}形式，可以在application.properties文件中引用其他属性的值，使属性之间可以相互关联和依赖。而且使用相同的键在不同的配置文件中定义，可以实现针对不同环境的属性覆盖。
1.2基本语法 键值对格式：每行表示一个配置项，采用key=value的格式，其中"key"表示配置项的名称，"value"表示配置项的值。
注释：可以使用'#'号在配置文件中添加注释，'#'号后面的内容将被忽略。例如：# 这是一个注释
引号：如果配置项的值包含特殊字符或空格，可以使用双引号或单引号将其括起来。例如：key="value with spaces"
特殊字符的转义：如果配置项的值中包含特殊字符，可以使用反斜杠进行转义。例如：key=value\#with\#hash
举例说明
复杂数据类型 server.port=8081 server.servlet.context-path=/home persion.name=xiaoming
简单数据类型 persion.hobby=sing,sport,read persion.family.mother=mum persion.family.father=baba 二.application.yaml配置文件 2.1yaml文件的优点 相对于传统的基于键值对的属性文件（如application.properties），使用YAML格式的配置文件更加易读和易写，具有以下特点：
结构清晰：YAML使用缩进和层级结构表示数据的关系，使配置文件更具可读性和可维护性。它使用冒号（:）和缩进来标识键值对和层级关系，而不需要像属性文件那样使用等号（=）和点号（.）。
支持复杂数据结构：YAML支持列表、映射和嵌套结构，可以方便地表示集合、对象和关联关系等复杂数据结构。这使得配置文件的定义更加灵活，可以更好地适应复杂的配置需求。
无需引号：相对于属性文件中需要使用引号包围值的情况，YAML中大部分字符串值无需使用引号括起来。这使得配置文件看起来更加简洁，减少了引号的干扰。
2.2 基本语法 键值对：使用冒号（:）将键和值分隔，并使用缩进表示层级关系。例如：
key: value 2.层级关系：使用缩进（一般是空格）表示层级关系，子级配置项比父级配置项多两个空格的缩进。例如：
parent: child: value 3.注释：使用井号（#）表示注释，井号后面的内容将被忽略。例如：
# 这是一个注释 key: value 4.字符串值：大部分字符串值无需使用引号括起来，但如果包含特殊字符、空格或需要保留原样输出，可以使用单引号或双引号将其括起来。例如：
key: value key2: 'value with spaces' key3: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357f755bc3c4869bb217381c1b0af3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9785a73b3d7a7bfc99d835d137388e99/" rel="bookmark">
			VS2022 XAML Styler拓展工具安装失败解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
步骤：
1. 在VS菜单中选择，Extensions -&gt; Manage Extensions
2. 在新窗口中，搜索 xamlstyler，然后下载对工具 3. 下载完成后，关闭VS编译器，会自动安装拓展
4. 安装时，会先解压下载后的拓展文件。安装时，提示安装失败，如下图
5. 打开上图左下角的log文件，按照下图位置，找到解压后的.vsix文件
6. 将该.vsix拷贝到新的空文件夹，并将vsix拓展名改成zip（不要修改文件名），并解压缩
7. 将解压后的文件夹，拷贝到 C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\CommonExtensions\Microsoft 文件夹下
8. 重新打开VS，在 Tools -&gt; Options 就可以看到选项卡
9. 参数配置可以参考
总结
引言 使用VS2022拓展功能在线安装 XAML Styler工具时，会出现安装失败的问题，下面介绍如何解决。其他拓展工具如果安装失败，可以参考相同解决办法。
步骤： 1. 在VS菜单中选择，Extensions -&gt; Manage Extensions 2. 在新窗口中，搜索 xamlstyler，然后下载对工具 3. 下载完成后，关闭VS编译器，会自动安装拓展 4. 安装时，会先解压下载后的拓展文件。安装时，提示安装失败，如下图 5. 打开上图左下角的log文件，按照下图位置，找到解压后的.vsix文件 6. 将该.vsix拷贝到新的空文件夹，并将vsix拓展名改成zip（不要修改文件名），并解压缩 7. 将解压后的文件夹，拷贝到 C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\CommonExtensions\Microsoft 文件夹下 8. 重新打开VS，在 Tools -&gt; Options 就可以看到选项卡 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9785a73b3d7a7bfc99d835d137388e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b47fabf0d7f130d26dc4b01673d860/" rel="bookmark">
			时间范围：开始时间和结束时间必须要成对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//校验 开始时间和结束时间必须要成对
//时间成对存在为true，不抛异常，时间不是成对存在为false，抛异常
if (!checkTime(TimeDTO)) {
throw new IllegalArgumentException(“开始时间和结束时间必须要成对存在”);
}
//封装校验方法
public static boolean checkTime(TimeDTO time){
boolean tag = true;
if (StringUtils.isNotEmpty(time.getBeginTime()) &amp;&amp; StringUtils.isEmpty(time.getEndTime())){
//开始时间不为空，结束时间为空
tag = false;
}else if(StringUtils.isEmpty(time.getBeginTime()) &amp;&amp; StringUtils.isNotEmpty(time.getEndTime())) {
//开始时间为空，结束时间不为空
tag = false;
}
return tag;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c785e3db0fb76c729d6350351703c15/" rel="bookmark">
			〔002〕虚幻 UE5 发送 get、post 请求、读取 json 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 目录 ▷ 安装 varest 扩展▷ 开启 varest 扩展▷ 发送 get 请求▷ 发送 post 请求▷ 读取 json 文件 ▷ 安装 varest 扩展 打开 虚幻商城，搜索 varest 关键字进行检索， varest 是一个 api 调用插件，支持 http/https 请求，也支持 json 文件的读取，最关键是该插件完全免费点击第一个插件，将其安装到引擎中 ▷ 开启 varest 扩展 安装好扩展后，需要在项目中开启扩展才可以使用点击界面右上角的 设置 选择其中的 插件 选项，在插件选项中勾选中 varest 插件，重启应用后即可使用该插件 ▷ 发送 get 请求 这里按 键盘1 发送 get 请求，并且定义了 URL 变量在 Call URL 中的自定义事件中处理返回值，先打印正在执行任务的总数量 count然后将总任务列表进行循环打印到桌面，并给相应参数前面添加执行下表 // 接口返回数据格式 [ 'count' =&gt; 20, 'data' =&gt; [ [ 'number' =&gt; 'tinygeeker_001', 'product_name' =&gt; '这是项目一', 'project_leader' =&gt; 'tinygeeker', ], [ 'number' =&gt; 'tinygeeker_002', 'product_name' =&gt; '这是项目二', 'project_leader' =&gt; '飞兔小哥', ] ] ] ▷ 发送 post 请求 这里按 键盘2 发送 post 请求，并且定义了 URL 变量传递参数时，Verb 选择 POST，Content-Type 选择 x-www-form-urlencoded(Request Body)通过 Set string Field 去设置传递的参数，这里传了一个 name 的参数值通过 Apply URL 去设置请求的 URL并绑定 请求完成 和 请求失败 的回调函数，请求完成会将传递的 name 值打印出来 // 接口大概如此 $name = $_POST['name'] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c785e3db0fb76c729d6350351703c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6315b6857fcc6c017149fd5852039314/" rel="bookmark">
			推荐一家GPU平台部署Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一年，扩散模型太火了，已经成为重要的生产力工具，在AI研究领域也不断有新的工作出现，成为产业界和学术界的热点。
本文将在趋动云平台部署扩散模型中广受关注的stable-diffusion-webui项目，手把手教程！
有需要算力跑模型的小伙伴，可以在趋动云领取一下168元算力金
创建项目 首先创建项目SD-webui-部署（名称可自拟），选择合适的镜像Pytorch2.0_miniconda3（由趋动云用户superx创建，感谢分享！）和数据集stable-diffusion-webui（由趋动云用户梦落创建，感谢分享！）。在相应的位置根据关键词搜索即可。
选择镜像
选择数据集
创建项目
请注意，创建项目时选择不上传代码，代码和资源已经在数据集中了。
初始化开发环境 创建好项目后，进入到运行代码，需要进行资源配置。
运行代码
算力君选择的是P1.small机型（价格便宜而且已经够用了），同时我们要开放一个端口，算力君这里填了9527，最长运行时间可根据个人所需选择（按照本文教程，整个过程应该在10分钟内），点击确定，如下图所示。
选择计算资源及开放端口
选择好之后点击确定后系统即开始分配资源，等待不到一分钟的时间，硬件配置、系统环境、数据资源即可配置完成。
资源分配
出现如上截图即代表配置完成，此时点击进入开发环境，即可进入一台完全准备好的机器进行开发了。
进入开发环境 点击进入开发环境后，我们可以在Jupyterlab进行数据和文件的查看、代码的编辑，也可以通过网页终端执行命令行操作。
开发环境
本文的 Stable Diffusion 部署后续过程，可以完全在网页终端进行操作完成。
第一步，切换成趋动云apt和pip源。
在网页终端输入
cp /etc/apt/sources.list /etc/apt/sources.listBak &amp;&amp; \ sed -i "s#http://archive.ubuntu.com/ubuntu/#https://mirrors.virtaicloud.com/repository/ubuntu/#g" /etc/apt/sources.list &amp;&amp; \ sed -i "s#http://security.ubuntu.com/ubuntu/#https://mirrors.virtaicloud.com/repository/security/#g" /etc/apt/sources.list &amp;&amp; \ apt update pip config set global.index-url https://pypi.virtaicloud.com/repository/pypi/simple 这一步可以加速python包和apt软件工具的安装，推荐每一个趋动云项目开始均换源。
第二步，准备模型数据和需要安装的软件。
解压数据：
unzip /gemini/data-1/stable-diffusion-webui.zip -d /gemini/code 拷贝要安装的软件：
cp /gemini/data-1/install /gemini/code/ -r 拷贝stable diffusion模型文件：
cp /gemini/data-1/models /gemini/code/stable-diffusion-webui/ -r 第三步，安装软件并发起SD-webui项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6315b6857fcc6c017149fd5852039314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e9e237a41754e9ed6c7dca0809459a/" rel="bookmark">
			进销存管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 引言 1.1 项目简要介绍 1.2 项目背景 2 任务概述 2.1 目标 2.2 运行环境 3 数据结构设计 3.1 逻辑结构设计 3.1.1 tb_Users表: 3.1.2 tb_Storage表： 3.1.3 Tb_ReturnGoods表： 3.1.4 tb_Provider表： 3.1.5 tb_Outstore表： 3.1.6 tb_Instore表： 3.1.7 tb_GoodInfo表： 3.1.8 tb_Check表： 3.1.9 tb_BorrowGoods表： 3.2 安装与初始化 4 程序使用说明 4.1 主要功能 4.2 操作注意事项 4.3 使用流程 4.3.1 用户管理 4.3.2 基本档案 4.3.3 货物管理 4.3.4 查询统计 4.3.5 系统维护 4.3.6 帮助 5 结论: 6 主要参考文献： 7 关键性源代码 7.1 数据库操作 7.2 数据库备份 7.3 数据库还原 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e9e237a41754e9ed6c7dca0809459a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb3b450a07740bdafec9c9817c4cc93/" rel="bookmark">
			源码商城交易平台源码 上百种商用级源码可二开 总有一款适合你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今信息化时代，源码商城交易平台 源码不仅可以帮助开发者快速搭建自己的平台，省去一步步开发代码的麻烦，还可以满足各种商用需求，根据需求进行二次开发。
分享一个源码商城交易平台，里面含各种可直接商用的源码系统，有小程序源码、微信公众号源码、直播系统源码、商城源码、网站源码等等，每套系统都含完整的搭建教程和完整的代码包，让你轻松搭建。
部分系统代码截图：
商城小程序源码部分后台截图展示：
拖拽式DIY小程序源码系统部分后台截图：
H5易企秀制作源码后台部分截图：
上百种源码下载地址：帮企商城或春哥技术博客 商业源码栏目获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccde26594f88c19eab63b5a08c981ba/" rel="bookmark">
			栅格计算器实现栅格擦除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SetNull((IsNull(栅格图层A) | IsNull(栅格图层B)),栅格图层A)
在栅格计算器中，输入以上公式，分别将栅格图层A和栅格图层B替换为待被除栅格和擦除栅格，即可实现：把栅格图层A中与栅格图层相交的部分擦除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daddc870bc4c6a483a26a17781629cd3/" rel="bookmark">
			C&#43;&#43;继承中的基类指针、派生类指针和虚函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，继承是面向对象程序设计的核心思想之一，它构建了类之间的层次关系，有父类和子类的概念。本文将总结基类指针、派生类指针和虚函数的相关内容，并附带相应的示例代码。
一、基类指针、派生类指针 在C++中，父类指针可以new一个子类对象，但子类指针不能new一个父类对象。父类指针可以调用父类的成员函数，但无法调用子类的成员函数，因为父类指针只能访问父类的成员变量和成员函数。
//定义基类/父类/超类 //Human.h文件 //定义基类/父类/超类 #ifndef _HUMAN_ #define _HUMAN_ #include&lt;iostream&gt; class Human { public: Human(); virtual ~Human(); Human(int); public: //virtual void eat() /*final*/;//声明成虚函数 virtual void eat2() = 0;//纯虚函数，没有函数体只有一个函数声明 public: int m_Age;//年龄 char m_Name[100];//名字 void funchuman() {}; void funcpub() { std::cout &lt;&lt; "执行了Human::funcpub()" &lt;&lt; std::endl; }; public: void samenamefunc(); void samenamefunc(int); protected: int m_pro1; void funcpro() { std::cout &lt;&lt; "执行了Human::funcpro()" &lt;&lt; std::endl; }; private: int m_priv1; void funcpriv() {}; };//类定义或者类声明时大家千万不要忘记末尾的; #endif // _HUMAN_ //Human.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daddc870bc4c6a483a26a17781629cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8696b53edb8471b60bb72338036b2309/" rel="bookmark">
			超市自助付款系统 毕业设计 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：Designer 小郑
作者简介：3年JAVA全栈开发经验，专注JAVA技术、系统定制、远程指导，致力于企业数字化转型，CSDN博客专家，阿里云社区专家博主，蓝桥云课讲师。
文末获取源码，项目编号： S 008 。 \color{red}{文末获取源码，项目编号：S008。} 文末获取源码，项目编号：S008。
目录 一、摘要1.1 项目介绍1.2 项目录屏 二、研究内容2.1 商品类型模块2.2 商品模块2.3 超市账单模块 三、界面展示3.1 登录注册模块3.2 超市商品类型模块3.3 超市商品模块3.4 商品购买模块3.5 超市账单模块 四、部分源码展示4.1 实体类定义4.2 控制器接口 五、配套文档展示六、免责说明 一、摘要 1.1 项目介绍 本博客设计实现了超市购物自助付款系统，该系统采用最新的技术，包括Vue以及Spring Boot等技术方法，实现了快速精准的商品结算，同时，在用户界面方面，超市购物自助付款系统采用了简洁直观的设计，使得用户能够快速掌握操作流程，通过对超市购物自助付款系统进行试验和评估，我们证明了其在效率和准确性方面的优势，并验证了其良好的适应性和可靠性，我们相信，超市购物自助付款系统将会在未来得到广泛的应用和推广，为人们的生活带来更多的便利和舒适。
超市购物自助付款系统采用热门的JavaEE技术，前后端分离开发，前端采用了Vue.js框架，后端使用了SpringBoot框架，使用Idea开发工具完成超市购物自助付款系统的开发。超市商品管理系统包含超市区域模块、超市货架模块、商品类型模块、商品档案模块，分为用户网页端和管理后台，基于角色的访问控制，可将权限精确到按钮级别，还有一些简单的图表分析。
前端：Vue 2.7.10
后端：Spring Boot 3.1.10
数据库：MySQL 8.0.31
1.2 项目录屏 二、研究内容 超市购物自助付款系统的研究内容包括以下几个方面，一是技术方面，超市购物自助付款系统的技术核心是如何快速准确地读取产品信息并确定结算金额计算和处理付款，这项研究需要许多技术手段，包括Vue技术、SpringBoot技术、MySQL技术等。
二是用户界面设计，超市购物自助付款系统的用户操作界面应简单、直观、易于操作，有必要通过综合考虑人机交互和用户体验等因素，设计一个符合客户习惯和需求的界面。
三是安全措施的设计，为了防止欺诈、盗窃和其他违法行为，超市购物自助付款系统应配备适当的安全措施，应考虑采用摄像头和传感器等安全设备，并制定相关的安全策略和规范。
第四是数据分析和优化，超市购物自助付款系统可以通过分析用户的消费数据来提供更准确的营销推广服务，同时，需要在运营过程中对系统进行优化升级，提高支付成功率，降低出错率等。
第五是应用场景的拓展，超市购物自助付款系统的应用场景不仅可以拓展到超市、便利店等零售行业，还可以拓展到其他领域，例如超市购物自助付款系统可以在旅游景点和机场实现，为用户提供更方便的消费体验，总之，超市购物自助付款系统的主要研究内容涉及技术核心、用户界面设计、安全对策设计、数据分析与优化、应用扩展等方面。
2.1 商品类型模块 超市购物自助付款系统需要商品类型模块，主要是因为它可以快速准确地识别不同类型的商品，并根据其特点进行结算，商品类型模块可以对不同类型的商品进行分类，如食品、饮料和消费品，以便于后续支付和统计，根据商品的不同，可能会有特殊情况，如按重量出售的物品或折扣物品，需要特殊处理，商品类型模块可以识别和处理这种情况。商品类型模块可以根据客户购买的产品类型提供适当的折扣信息和推荐服务，增强购物体验和满意度，商品类型模块使客户能够更轻松、更快地选择产品，节省时间和精力，而无需手动输入产品信息或扫描条形码。简而言之，商品类型模块是超市购物自助付款系统不可或缺的一部分，超市购物自助付款系统可以快速准确地识别商品类型，提供优惠信息和服务，商品类型模块可以简化操作流程，有助于提高购物体验和效率。
2.2 商品模块 超市购物自助付款系统之所以需要商品档案模块，是因为该模块提供了商品信息的基础数据和管理，超市购物自助付款系统可以进行结算，以便能够准确读取商品信息、计算价格和进行支付处理，商品档案模块包含商品的所有基本信息，如名称、代码、规格、单位和售价，这些信息对于确保超市购物自助付款系统能够快速准确地结算非常重要，商品档案模块还存储每个产品的条形码和二维码信息，超市购物自助付款系统可以通过扫描这些条形码快速识别产品并自动计算价格，它还避免了手动计算错误和延迟，商品档案模块还允许您设置和管理每种商品的价格和折扣信息，超市购物自助付款系统可以根据商品档案模块的价格信息自动计算消费者的付款金额，提供相应的优惠活动，提高消费者的满意度。商品档案模块存储所有产品的销售数据，超市可以分析这些数据以制定更好的营销策略，例如，我们根据销售数据调整商品的类型、数量、价格等，以满足消费者的需求并增加销售额。如上所述，商品档案模块是超市购物自助支付系统的重要组成部分，为超市购物自助付款系统的正常运行和良好服务提供了坚实的基础。
2.3 超市账单模块 超市购物自助付款系统需要超市账单模块，主要方便顾客调查超市的购买记录和消费状况，同时为超市提供更准确的营销策略和服务。顾客可以在超市的账单模块中查找以前的购买记录，包括商品名称、购买时间、数量和价格等详细信息，这有助于客户跟踪他们的消费情况，并根据他们的个人需求制定购买计划，超市账单模块可以汇总客户的所有购买记录，并生成支出金额的统计报告，这有助于顾客了解他们在超市的消费水平，并有效地管理他们的支出。超市账单模块还可以与超市的优惠券系统集成，让顾客可以轻松查看优惠券的使用情况和剩余数量，同时，超市可以根据顾客的购买记录和偏好推荐合适的优惠券，提高用户忠诚度和满意度，超市的账单模块可以分析和挖掘顾客的购买记录数据，了解顾客的消费习惯和偏好，为超市提供更准确的营销策略和服务。超市账单模块还可以根据历史数据进行预测分析，并为超市制定更科学的运营计划，如上所述，超市的账单模块是超市购物自助付款系统中不可或缺的一部分，它可以为顾客和超市带来许多便利和优势。
三、界面展示 3.1 登录注册模块 3.2 超市商品类型模块 3.3 超市商品模块 3.4 商品购买模块 3.5 超市账单模块 四、部分源码展示 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8696b53edb8471b60bb72338036b2309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fef83d2018bb8af5fcd932a819e3fdd/" rel="bookmark">
			联邦学习：联邦场景下的跨域推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://zhuanlan.zhihu.com/p/553492147
1 导引 1.1 跨域推荐模型 推荐系统中常常面临冷启动和用户交互数据稀疏的问题。解决这个问题的一个手段就是对用户在多个领域(domain)的日志数据联合起来进行建模，这里的多个领域的数据可以指用户在诸如新闻App、音乐App、视频App等多个软件的日志数据（比如点击的浏览新闻标题和描述等）。这种联合建模基于一个假设：用户在不同领域也倾向于拥有相似的偏好，比如喜欢爱情电影的用户也很可能喜欢言情小说。
而多视角(multi view)或跨域(cross domain)推荐模型[1]就是一种常见的跨领域数据联合建模方式，它会将多个视角/多个领域对应的特征映射到一个共享的隐空间（latent space）。事实上，这即是迁移学习中经典的几何特征变换（表征对齐） [11]思路，也是度量学习（Metric Learning）[12]思想的一种体现。
跨领域数据建模的多视角DNN
上图展示了对跨域数据建模的多视角DNN，它基于深度结构化语义模型（Deep Structured Sematic Models， DSSM）的计算最大化用户视角和多个物品视角对应隐向量的相似度，并按照相似度排序来推荐物品。图中的User View对应的特征为用户使用搜索引擎的查询信息，而其他的Item View对应的特征为用户在其它App所点击过的物品特征数据。该模型假定所有领域都对应着共同的用户。它使用了DNN将多个视角对应的高维稀疏特征映射xU ,x1, ..., xD到共享隐空间中的低维稠密特征yU, y1, ..., yD。
之后可以计算用户隐向量和物品隐向量的语义相似度：
这里假设用户隐向量和物品隐向量相关，然后接下来的目标就是为每个视角都找到一个非线性的映射，以使视角和其它物品视角在隐空间的相似度之和最大化：
其中为各个视角对应的权重参数，一共有个N用户-物品对样本和D个物品视角，其中每个物品视角xj都有其单独的输入特征维度dj。
第i个用户-物品对样本拥有一个用户视角的输入特征和其对应的物品视角特征，这里a是样本i对应物品视角的索引，样本i对应的其它物品视角的输入则设为0向量。为温度系数。
如上文所述，跨域推荐本质上是个迁移学习问题，它需要在多个领域异构数据的基础上通过某种“桥梁”（bridge）来提高一个或多个目标域的推荐效果。这里的“桥梁”指不同领域之间的关联项目，比如共同的用户，共同的物品，共同的特征等。上面的多视角DNN模型就假定所有领域都对应着共同的用户。
1.2 联邦跨域推荐模型 跨域推荐在实际应用中常常面临隐私性的挑战，其一是不同用户的数据难以合法地进行集中化收集；其二是其使用的迁移学习模型跨不同的域和数据集进行映射，这常常会关联到不同的组织机构，同样会面临隐私问题。此时上面提到的需要将数据集中起来的跨域推荐方法就不再行得通了，需要考虑在联邦场景下的跨域推荐模型。
而联邦场景下的跨域推荐模型根据其隐私保护的出发点不同，可大致分为以下三类：
横向 保证用户（client）之间的数据数据不共享，但多视角的数据是打通的。如下图所示[7]，不同的用户可能具有A、B两个领域的信息，且A领域的数据和B领域的数据可共享： 纵向 可以将用户的数据进行集中化收集，但多视角的数据不能共享。如下图所示[8]，Platform 1 到Platform K 都拥有用户的行为数据，然后依靠第三方的服务器对其进行联合建模。 横向+纵向 不仅保证client之间的数据不共享，且多视角的数据也是不能共享的。如下图所示[5]，用户 u 的数据不能直接上传到云端（但可上传下载模型），且对于用户 u 而言，其在领域 d1的数据不能与其在领 d2 的数据共享。 我个人觉得在保证隐私的条件下进行多视角之间的信息共享（纵向/横向+纵向）是最有意思的，其核心是联邦迁移学习相关的理论：即在隐私保护的前提下，根据不同领域之间的关联来生成共享表征。根据我阅读过的大部分论文来看，如不同领域对应不同的组织机构，则它们的embeddings不能直接进行迁移，需要采取间接的迁移方法。这些方法具体来说就五花八门了，有用GAN来生成带差分隐私保护的共享embeddings的（参见《联邦学习：联邦场景下的多源知识图谱嵌入》），有用另一个中间视角的数据来训练共享子模型的[4]，有用VAE来生成一个独立于所有领域的共享embeddings的[5]，有先对数据加以差分隐私保护再用自编码器生成共享embeddings的[6]。可以预见这在未来仍将是个热点。
以下我们分别看下这三类所对应的相关论文，了解一下该领域的大致情况。
2. 论文阅读 2.1 ECML-PKDD 2020《Federated multi-view matrix factorization for personalized recommendations》 这篇论文提出了联邦多视角矩阵分解分解算法，因为其使用的多视角数据不涉及跨组织机构，故只需要保证用户数据不共享即可，属于前面所说的横向类型。具体而言，在传统的矩阵分解算法中，常常只考虑用户-物品矩阵，即所谓共现矩阵R，通过分解该矩阵得到用户的隐向量矩阵P和物品隐向量矩阵Q：
之后再基于用户矩阵P和物品矩阵Q得到用户u对物品i的预估评分：
其中是用户i在用户矩阵P中的对应行向量，是物品j在物品矩阵Q中的对应行向量。
而所谓多视角矩阵分解，即包括以下三个视角：用户-物品，用户-特征，物品-特征。这三个视角分别对应用户-物品矩阵，用户特征矩阵，物品特征矩阵。这里为用户个数，为物品个数，和分别为用户和物品的特征维度。则多视角矩阵分解可表示为如下形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fef83d2018bb8af5fcd932a819e3fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741be4a6634665da7836aad6e052a0c2/" rel="bookmark">
			用与非门等效替代异或门和或门,并制作半加器和全加器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用与非门替代与门 这里还可以用与非门和非门代替
上面和下面是等效的，具体证明如下：
2.用与非门替代异或门 上图两个电路图是等效的，证明如下：
3.半加器 用与门和异或门组成的半加器：
将异或门替换成与非门：
4 全加器 替换后：
如果只用与非门和非门完成的话，还需要将或门替换：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59fbe1a97e294804f9cd265f11e5e965/" rel="bookmark">
			使用Yakit进行常规渗透测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：@shangzeng师傅
说明：本文项目中涉及的任何软件工具，仅用于测试和学习研究，其所用目标的环境为个人在本机的靶机环境，数据仅在本地，未对他人信息系统造成任何破坏，文章表达所展现的观点及技术等信息仅用于学习交流。
关于Yak的官方介绍
YAK是国际上首个致力于网络安全底层能力融合的垂直开发语言，提供了非常强大的安全能力。Yak是绝大部分 “数据描述语言 / 容器语言” 的超集，具备Go所有能力与库生态，VSCode插件等，语法可自定义，是图灵完备的脚本语言，完全国产。通过函数提供各类底层安全能力，包括端口扫描、指纹识别、poc框架、shell管理、MITM劫持、强大的插件系统等。
简单来说就是为安全而开发的一种语言的方言。
关于Yakit
Yakit 是一个基于yak语言编写的工具，功能类似Burpsuite，主要功能有拦截http/s数据包，漏洞检测，网站地图，自动/手动测试web应用，编码解码，请求与响应差异数据化等功能，此外yakit插件库还集成了多个专项漏洞检测的插件，支持检测排查新发现的以及过去的经典级漏洞，如log4j2漏洞和struts2漏洞。
端口扫描、指纹
靶场：192.168.131.130
Yakit所在的：192.168.131.2
点击左侧的基础安全工具---扫描端口/指纹---填写目标IP----其他项目保持默认即可---下滑到底部---点击开始扫描端口---等待结果
扫描发现主机开放了ssh服务web服务，当然，这些都是常见端口，对于其他特定端口我们可以调整端口范围，不过最大目前只能扫描200个端口，还无法全端口扫描，一般来说，我们常规保持默认即可。
Web服务
ssh服务
两个端口处都有登录框，可以从爆力登录试试，而web服务可以查看中间件版本是否有对应版本相关的漏洞。
登录口令爆破
点击基础安全工具---爆破与未授权---右侧的可用爆破类型里，目前只有11个类型可用，没有web登录的，一般的也足够了，那这里就只能勾选ssh类型了。
之后右边这里填写好目标IP后，需要指定字典，点击更多参数
指定字典，预设字典可以在左侧的payload管理里修改，也可以增加，由于这里我没有添加，所以就写了几个试试。
填写完后，没有确定按钮，就只能点击右上角关闭，应该是实时保存了的，之后就点击开始检测，走起。
很快之后，出一个了，Yakit速度还是蛮快的，还是字典的原因？不管了，登录试试看看。
登录进去之后，可惜权限很小，在家目录发现了flag4，打开看，应该是想让我们以同样方法试试其他服务拿到root权限，可惜目前yakit不支持对接web登录框。
再找找看其他地方还有没有flag。
最终是在这个文件里找到了flag2，这个文件里面还有数据库的配置信息，其他的目录则需要更高权限查看了，可以从权限提升方面着手。
权限提升
目标主机是Linux系统，我们可以用最近曝出的Polkit pkexec for Linux本地权限提升漏洞CVE-2021-4034方法来提权，这个相对而言成功率比其他方式高。
可以通过第三方远程工具来将文件上传至目标主机。
上传之后，执行试试看。
翻车了额，目标主机没有python3环境。
Yakit使用心得
虽然最终没有获取到另外的flag，也没有获取到管理员权限，但对于当前的yakit而言，是很不错的非常NICE的一个工具，对用户起到了很好的辅路链路效果，而其他功能自己也还没体验，还没发现yakit的真正厉害之处，特别是yak runner，专项漏洞检测，反连管理，数据库等很多压箱底的实用性功能，总体而言yakit界面友好，排版美观，容易上手，使用流畅，提升了工作效率，这次是使用yakit为主的渗透测试之旅。期待yakti以后会越来越好。
Yak官方资源 Yak 语言官方教程：
https://yaklang.com/docs/intro/
Yakit 视频教程：
https://space.bilibili.com/437503777
Github下载地址：
https://github.com/yaklang/yakit
Yakit官网下载地址：
https://yaklang.com/
Yakit安装文档：
https://yaklang.com/products/download_and_install
Yakit使用文档：
https://yaklang.com/products/intro/
常见问题速查：
https://yaklang.com/products/FAQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6290bd021983967154f058e1a5f850a/" rel="bookmark">
			Node.js与npm版本比对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js与npm版本比对 Node.js与npm版本比对版本对比表Node版本对比npm版本 Node.js与npm版本比对 我们在项目开发过程中，经常会遇到公司一些老的前端工程项目，而我们当前的node及npm版本都是相对比较新的了。
在运行以前工程时，会遇到相关环境不匹配的问题，那么 就需要对现有的node及npm版本进行降级，所以就需要找到对应的node与npm版本比对表格。
下面是从官网找到的版本对照表。
版本对比表 Node版本对比 链接: 以往的版本node.
图片: npm版本 npm@6.14.16
npm其他历史版本链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca7cd7eb7394dbfcd8ab90a6e6bac03/" rel="bookmark">
			Python根据文本文档中的链接自动下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python根据文本文档中的链接自动下载文件 背景代码解析1. 加载库2. 读取网址列表3. 下载和保存文件4. 结束并保存失败内容 完整代码 背景 从Science Data Bank上找到了一个很好的数据，但是没有提供下载工具，只提供了每一个文件的网址，因此用python写了一个脚本来进行下载。
目前实现的功能：
1. 读取文本文档并下载
2. 自动添加延时，防止短时间进行过多请求导致服务器返回无效数据
3. 判断文件是否已下载，已下载则跳过，若文件大小过小则重新下载（因为无效数据会是体积很小的数据）
代码解析 1. 加载库 这里加载了所需的库 import requests # 用来发出get请求 import os	# 用来构建路径名 from urllib.parse import unquote # 特殊字符需要转码才可以进行网页请求 import tqdm	# 进度条 import time	# 计算时间 import random	# 随机数，非固定时间间隔 2. 读取网址列表 直接读取，这里面的txt文件里面都是网址，内容举例：
https://download.scidb.cn/download?fileId=62295e16d7561b594fb67f58&amp;dataSetType=personal&amp;username=36680@qq.com&amp;fileName=00001631-100507.rml
https://download.scidb.cn/download?fileId=62295e16d7561b594fb67f59&amp;dataSetType=personal&amp;username=36680@qq.com&amp;fileName=00001547-100507.rml
https://download.scidb.cn/download?fileId=61a0ca3f89f14b48842ceef8&amp;dataSetType=personal&amp;username=36680@qq.com&amp;fileName=00001169-100507.rml
https://download.scidb.cn/download?fileId=61a0ca3f89f14b48842cee8c&amp;dataSetType=personal&amp;username=36680@qq.com&amp;fileName=00001222-100507.rml
file_name_list = [] with open('778740145531650048.txt', 'r') as file: for i in file: file_name_list.append(i.strip()) 3. 下载和保存文件 # 逐行读取网址 processing_bar = tqdm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca7cd7eb7394dbfcd8ab90a6e6bac03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb8bff2abff9a58a273b201f602f07f/" rel="bookmark">
			go module 名称与 GitHub/Gitlab 地址不同时的引用方式（module declares its path as: github.com/someone/repo ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 开源好，开源秒，开源呱呱叫！都知道开源项目好，而在 go 中，使用开源库的最好方式，当前莫过于 module 了。
最近遇到了两个引用错误场景：
我在 GitHub 上发现了优秀的开源库，fork 到自己的仓库改了下，希望用到自己的项目中。我本地写了一个特牛的插件（module 名称是 utils 而不是 gitlab.com/xxx/utils），想分享给在座的各位，通常公司内部都会有方便快速开发的公共库，这时需要将该库推送到 gitlab 仓库中。 发现使用 module 直接引用仓库都会报错。
module declares its path as: github.com/someone/repo but was required as: github.com/you/repo module declares its path as: utils but was required as: gitlab.com/xxx/utils 当时遇到这个错的第一印象：手动更改代码仓库中的 module name，然后再将仓库里所有的 github.com/someone/repo 都替换成 github.com/you/repo。
的确可以解决，但是不够优雅，下面介绍下 mod 的 replace 方案。
解决方案 replace github.com/someone/repo =&gt; github.com/you/repo latestgo mod tidy使用时 import github.com/someone/repo 1. replace module my-project go 1.20 replace github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb8bff2abff9a58a273b201f602f07f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/97/">«</a>
	<span class="pagination__item pagination__item--current">98/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/99/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>