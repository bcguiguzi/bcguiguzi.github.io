<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8e2590c9ff970bb69c6e042f9ff443/" rel="bookmark">
			nodejs 本地安装VS全局安装 生产依赖VS开发依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm（你怕吗） npm(Node Package Manager)是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码,管理项目依赖关系。（与其有同样功能的另一个包管理工具yarn，速度用体验比旧版本的npm好，但npm最近的新版本也做出很大努力，与yarn速度和体验差距越来越小，有兴趣可以了解下）。
npm这几年可以说是前端猿日常离不开的工具了，刚开始学习使用node、npm来进行前端项目构建的时候，有很多概念需要理解，各种命令行、各种新js语法、各种环境依赖...就问你怕吗？：
讲真，刚开学时我怕。废话不多扯，现在我们进入主题，聊聊npm 全局安装与本地安装、开发依赖和生产依赖，先抛几个常见疑惑：
什么是全局安装、什么是本地安装(或叫局部安装，下文统一叫本地安装) ？为什么要全局安装？为什么又要本地安装？全局安装和本地安装有什么区别？什么叫开发依赖、生产依赖？什么又是开发环境、生产环境？ 全局安装与本地安装 一、全局安装： npm install &lt;pageName&gt; -g//（这里-g是-global的简写） 通过上面的命令行（带-g修饰符）安装某个包，就叫全局安装。通常全局包安装在node目录下的node_modules文件夹。可以通过执行下面几条命令查看node、npm的安装目录和全局包的安装目录。
which node // 查看node的安装目录 which npm // 查看npm的安装目录 npm root -g // 查看全局包的安装目录 npm list -g --depth 0 //查看全局安装过的包 二、本地安装: npm install &lt;pageName&gt; (后面可以加几种修饰符，主要有两种--save-dev和--save) 通过上面的命令行安装某个包，就叫本地安装。包安装在你当前项目文件夹下的node_modules文件夹中。
三、全局安装的作用: 全局安装的包可提供直接执行的命令(例：gulp -h可以查看gulp定义了什么命令)。 比如gulp全局安装后，可以在命令行上直接执行gulp -v、gulp -h等（原理：全局安装的gulp会将其package.json中的bin命令注入到了全局环境，使得你可以全局执行：gulp xxx命令，这另一个话题了，不深入）。倘若只在本地安装了gulp，未在全局安装gulp，直接执行这些命令会报错。你想要执行相应的命令则可能需要例如：node ./node_modules/gulp/bin/gulp.js -v(查看版本) 这样用一大串命令来执行。因此全局安装就发挥到他的好处了，一个gulp -v就搞定
当然，不是每个包都必须要全局安装的，一般在项目中需要用到该包定义的命令才需要全局安装。比如gulp &lt;taskName&gt;执行gulp任务...等，所以是否需要全局安装取决于我们如何使用这个包。全局安装的就像全局变量有点粗糙，但在某些情况下也是必要的，全局包很重要，但如果不需要，最好避免使用。
四、可以全局安装，那么直接全局安装到处使用就行了，干嘛还需要本地安装？ 如果只是全局安装了而没本地安装，就得require('&lt;pagePath&gt;') 例：引入一个全局的包可能就是requirt('/usr/local/....')通过全局包的路径引入，这样显然十分的不灵活。如果安装了本地包，那么就可以直接require('&lt;pageName&gt;')引入使用。一个包通常会在不同的项目上会重复用到，如果只全局安装，那么当某个项目需要该包更新版本时，更新后可能就会影响到其他同样引用该包的项目，因此本地安装可以更灵活地在不同的项目使用不同版本的包，并避免全局包污染的问题。 一个经验法则：要用到该包的命令执行任务的就需要全局安装，要通过require引入使用的就需要本地安装（ 但实际开发过程中，我们也不怎么需要考虑某个包是全局安装还是本地安装，因为这一点在该包的官网上一般会明确指出，以上是为了理解全局安装和本地安装）。
开发依赖和生产依赖 顺着上面讲到的本地安装，本地安装有两种主要的安装方式：
保存到开发依赖(devDependencies): npm install &lt;pageName&gt; --save-dev保存到生产依赖(dependencies): npm install &lt;pageName&gt; --save "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8e2590c9ff970bb69c6e042f9ff443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f7e43d09e5e4f92a479d84d27a3bb1/" rel="bookmark">
			Prometheus&#43;Grafana学习(三) 监控windows下的mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装Grafana和Prometheus二、安装Mysqld_exporter1.下载2.安装windows版mysqld_exporter3.测试使用mysqld_exporter 三、配置Prometheus1.修改配置文件2.重启prometheus3.查看prometheus 三、配置Grafana 一、安装Grafana和Prometheus 略，参考：https://blog.csdn.net/u011943534/article/details/122452337
二、安装Mysqld_exporter MySQL版本需要在5.5以上。
Mysqld_exporter用于收集MySQL性能信息。
官方源码和文档地址：https://github.com/prometheus/mysqld_exporter
使用版本：0.13.0，在github的tag中下载。
1.下载 下载地址：https://github.com/prometheus/mysqld_exporter/releases/download/v0.13.0/mysqld_exporter-0.13.0.windows-amd64.zip
2.安装windows版mysqld_exporter 前提是机器上已经安装了MySQL，安装过程与linux下大概一致。
(1)解压 tar zvxf mysqld_exporter-0.13.0.linux-amd64.tar.gz (2)登录mysql为exporter创建账号并授权 创建数据库用户 CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'exporter'; GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost'; ALTER USER exporter@localhost IDENTIFIED WITH mysql_native_password BY 'exporter'; flush privileges; (3)创建MySQL配置文件exporter.ini，配置免密码连接数据库 编辑内容： [client] user=exporter password=exporter (4)启动exporter客户端 mysqld_exporter.exe --config.my-cnf=exporter.ini 其他参数 # 选择采集innodb --collect.info_schema.innodb_cmp # innodb存储引擎状态 --collect.engine_innodb_status # 指定配置文件 --config.my-cnf=".my.cnf" 3.测试使用mysqld_exporter 访问： http://IP:9104/metrics
三、配置Prometheus 1.修改配置文件 在之前配置的mysql8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f7e43d09e5e4f92a479d84d27a3bb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4ca3284976d52600c02d5cf5411838/" rel="bookmark">
			浅谈游戏业务遭遇攻击的防护措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人不禁问DDoS攻击是什么？尤其是对刚入行的新手小白来说，对于这方面完全不懂，那么今天我们就来讲讲它是什么又会造成什么危害，该如何防御。
DDoS攻击也叫分布式拒绝服务（Distributed Denial of Service，简称DDoS），主要攻击的方式有SYN/ACK Flood，UDP Flood等流量攻击和CC攻击。
流量攻击是非常常见和直接的一种攻击方式，攻击者通过控制大量僵尸网络肉鸡攻击游戏服务器，造成游戏服务器拥塞甚至崩溃。直接导致的后果就是玩家无法链接游戏，这也将使游戏损失大量的玩家。防御的方式就是使用高防服务器直接与其对抗，高防服务器通过其硬件防火墙把恶意的流量抵挡在外面，当然越大的流量攻击对应的成本也是越高的，如果是单独的针对UDP Flood攻击也有取巧之处，可以让机房对相关的UDP协议进行封锁，毕竟目前大部分游戏都没有使用到UDP协议，也可以降低对抗的成本。
其次是CC攻击，攻击者通过大量肉鸡模拟真实玩家登录游戏服务器，造成登录网关的拥塞，大量占用服务器的资源，使真正的玩家无法登陆和卡顿，严重影响玩家的游戏体验。针对这类攻击有些游戏公司会选择验证码的方式来缓解，但实际效果并不明显，反而还会影响玩家的游戏体验，建议使用高防服务器对空链接假链接做策略屏蔽，直接把IP拦截在外面，当然策略屏蔽也不是万能的，不好的策略也会造成把真实的玩家也拦截掉。
由于DDoS攻击容易实施、难以追踪并且相对其他攻击手段DDoS的技术要求和发动攻击的成本很低，很多不法分子运用此类攻击敲诈勒索，打击同行，而游戏行业往往是DDoS攻击的重灾区，相对上面介绍的防御方式，接下来介绍的一款产品其防御效果更好，防御成本也更低，这款产品就是游戏盾。
游戏盾是针对游戏行业所推出的一款高度可定制的网络安全管理解决方案，可以彻底解决大型的DDoS流量攻击和游戏行业特有的CC攻击问题。
与传统单点防御DDoS防御方案相比，游戏盾用数据和算法来实现智能调度，将“正常玩家”流量和“黑客攻击”流量快速分流至不同的节点，最大限度缓解大流量攻击；通过端到端加密，让模拟用户行为的小流量攻击也无法到达客户端。
与普通的DDoS高防机房不同，游戏盾并不是通过海量的带宽硬抗攻击，而是通过分布式的抗D节点，将黑客的攻击进行有效的拆分和调度，使得攻击无法集中到某一个点上。同时基于SDK端数据、流量数据，可以通过动态的调度策略将黑客隔离！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9e88cd95fcb6e69b77076fabc495ee/" rel="bookmark">
			UI自动化测试工具-UFT-Object Repository | Local Object Repository
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 自动创建测试对象库 1.1 通过录制脚本 1.1.1 点击录制脚本 1.1.2 打开菜单Object Repository 录制的待测对象就会被自动load到左侧的对象树中。
1.2 通过Object Repository手工添加 1.2.1 点击如下图加号 1.2.2 点击需要创建的对象 1.2.3 选择对象类型 1.2.4 或者选择全部对象 1.2.5 导出全部对象 1.2.6 选择本地位置取名字 1.2.7 新建项目，然后选择菜单Tools-&gt;Associate Resp.. 1.2.8 选择刚刚创建的待测对象 1.2.9 对象被load出来，不可编辑 1.2.10 选择本地还是所有 1.3 或者通过Object Spy创建对象库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7fe5c480d7e302602f7ff7dc64120d6/" rel="bookmark">
			Docker容器网络模式与数据管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Docker容器操作1、容器创建2、查看容器的运行状态3、启动容器4、创建并开启容器5、终止容器运行6、容器的进入7、复制文件到容器中/宿主机中8、容器的导出与导入9、删除容器 二、Docker网络1、Docker网络实现原理2、Docker的网络模式 三、网络模式详解1、host模式2、container模式3、none模式4、bridge模式5、自定义网络 四、CPU资源控制1、cgroups概述2、cgroups的四大功能3、设置CPU使用率上限4、设置CPU资源占用比（设置多个容器时才有效）5、设置容器绑定指定的CPU 五、对内存使用的限制1、创建指定物理内存的容器2、创建指定物理内存和swap的容器1、设置限制项2、创建容器，并限制写速度3、通过dd来验证写速度4、清理docker占用的磁盘空间 六、Docker的数据管理1、管理Docker容器的方式2、数据卷3、数据卷容器 七、容器互联（使用centos镜像）1、定义2、创建容器互联 一、Docker容器操作 1、容器创建 将镜像加载到容器的过程。新创建的容器默认处于停止状态，不运行任何程序，需要在其中发起一个进程来启动容器
格式∶docker create [选项] 镜像常用选项∶ -i∶让容器的输入保持打开 -t∶让Docker分配一个伪终端 docker create -it nginx:latest bash #bash为系统命令/bin/bash、/usr/bin/bash的缩写 2、查看容器的运行状态 docker ps -a #-a 选项可以显示所有的容器，不加-a只显示运行的容器 3、启动容器 docker start 容器的ID/名称 docker ps -a 4、创建并开启容器 （1）格式
docker run 镜像 bash -c shell命令 例如：docker run nginx:latest bash -c ls / #会发现创建了一个新容器并启动执行一条 shell 命令，容器将这条命令作为第一个进程，命令执行完毕后容器的第一个进程也关闭则容器就停止了 （2）docker run运行过程
可以直接执行 docker run 命令，等同于先执行 docker create 命令，再执行 docker start 命令。 注意∶容器是一个与其中运行的 shell 命令共存亡的终端，命令运行容器运行，命令结束容器退出。 docker 容器默认会把容器内部第一个进程，也就是 pid=1 的程序作为docker容器是否正在运行的依据，如果docker容器中pid = 1 的进程挂了，那么docker容器便会直接退出，也就是说Docker容器中必须有一个前台进程，否则认为容器已经挂掉。 当利用 docker run 来创建容器时，Docker 在后台的标准运行过程是∶ （1）检查本地是否存在指定的镜像。当镜像不存在时，会从公有仓库下载 （2）利用镜像创建并启动一个容器 （3）分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层 （4）从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中 （5）分配一个地址池中的 IP 地址给容器; （6）执行用户指定的应用程序，执行完毕后容器被终止运行 （3）在后台持续运行docker run创建的容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7fe5c480d7e302602f7ff7dc64120d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e05d48b93da5f8b3f5159bd6a21beb8/" rel="bookmark">
			调用函数，求加减乘除（基础）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int Add(int x, int y)
{
//此时的num1=x，num2=y。
int z =0;
z=x * y;
return z;
}
int main（）
{
int num1 = 0;
int num2 = 0;
//输入函数，输入两个值。
scanf（"%d%d", &amp;num1, &amp;num2）;
//Add（num1, num2）调用函数，在调用
时讲num1，num2作为Add函数的参照
的值分别传给Add函数中的参数x，y，然
后执行Add函数体，使Add函数中的变量
z得到一个值，并返回给Add。
int sum = Add（num1, num2）;
printf("%d\n", sum);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25209c3d5eb2646039779d89f6fe4af4/" rel="bookmark">
			go打包静态文件到可执行文件中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原链接：Go 1.16 使用 Embed 嵌入静态资源 | 视频文字稿-技术圈
go1.16 版本已经 release 了，推出了一些新功能特性，其中有一个 embed 的新功能，通过 embed 可以将静态资源文件直接打包到二进制文件中，这样当我们部署 Web 应用的时候就特别方便了，只需要构建成一个二进制文件即可，以前也有一些第三方的工具包可以支持这样的操作，但是毕竟不是官方的。接下来我们就来为大家简单介绍下 embed 功能的基本使用。
安装 要测试 embed 功能，当然需要我们更新 go 到 1.16 版本，我们可以通过下面的方式进行安装，当然也可以直接下载安装包配置(https://golang.org/dl/#go1.16)。
示例 查看下面的简单示例：
package main import ( _ "embed" "fmt" ) //go:embed hello.txt var s string func main() { fmt.Println(s) } 可以看到上面的代码中出现了一个 go:embed 关键字的注解，通过该注解可以直接读取本地静态文件，在上面代码目录下面创建 hello.txt 静态文件，然后就可以直接编译打包运行了：
➜ go1.16 run main.go Hello embed in golang 1.16 ➜ cat hello.txt Hello embed in golang 1.16% ➜ go1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25209c3d5eb2646039779d89f6fe4af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799ae1d9cdd366c4ba9e1a78b8a174b0/" rel="bookmark">
			TCP 四次挥手的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、四次挥手的过程 1、刚开始双方处于ESTABLISHED状态。
2、客户端要断开了，向服务器发送 FIN 报文，在 TCP 报文中的位置如下图:
发送后客户端变成了FIN-WAIT-1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。
3、服务端接收后向客户端确认，变成了CLOSED-WAIT状态。
4、客户端接收到了服务端的确认，变成了FIN-WAIT2状态。
5、随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，
6、客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。
注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。
2、等待2MSL的意义 如果不等待会怎样？
如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。
那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?
1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。
3、为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。
如果是三次挥手会有什么问题？
等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。
4、同时关闭会怎样？ 如果客户端和服务端同时发送 FIN ，状态会如何变化？如图所示:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b9fbc0fad1be9c37ca3465ac361032/" rel="bookmark">
			30个ES6—ES12 新功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		30个ES6—ES12 新功能 ECMAScript 是一种由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言，这种语言被称为 JavaScript 。简单来说，ECMAScript 是 JavaScript 的标准与规范，JavaScript 是 ECMAScript 标准的实现和扩展。
自2015年开始，ECMAScript发布的版本如下：
发布时间正式名称版本名称名称缩写2015ECMAScript2015ECMAScript6ES2015、ES62016ECMAScript2016ECMAScript7ES2016、ES72017ECMAScript2017ECMAScript8ES2017、ES82018ECMAScript2018ECMAScript9ES2018、ES92019ECMAScript2019ECMAScript10ES2019、ES102020ECMAScript2020ECMAScript11ES2020、ES112021ECMAScript2021ECMAScript12ES2021、ES12 下面就来看看ECMAScript各版本有哪些使用技巧吧。 一、ES6 新特性（2015） ES6的更新主要是体现在以下方面：
表达式：变量声明，解构赋值内置对象：字符串拓展、数值拓展、对象拓展、数组拓展、函数拓展、正则拓展、Symbol、Set、Map、Proxy、Reflect语句与运算：Class、Module、Iterator异步编程：Promise、Generator、Async。 这里主要介绍一些常用的新特性。还有一些特性，在之前文章中已经介绍过了，这里不在多说，直接上链接：
Promise、Generator：《万字长文，重学JavaScript异步编程》数组方法：《万字长文，重学JavaScript数组类型》字符串方法：《JavaScript 28个常用字符串方法及使用技巧》 1. let和const 在ES6中，新增了let和const关键字，其中 let 主要用来声明变量，而 const 通常用来声明常量。let、const相对于var关键字有以下特点：
特性varletconst变量提升✔️××全局变量✔️××重复声明✔️××重新赋值✔️✔️×暂时性死区×✔️✔️块作用域×✔️✔️只声明不初始化✔️✔️× 这里主要介绍其中的四点：
（1）重新赋值
const 关键字声明的变量是“不可修改”的。其实，const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。但对于引用类型的数据（主要是对象和数组），变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是不变的，至于它指向的数据结构就不可控制了。
（2）块级作用域
在引入let和const之前是不存在块级作用域的说法的，这也就导致了很多问题，比如内层变量会覆盖外层的同名变量：
var a = 1; if (true) { var a = 2; } console.log(a); // 输出结果：2 循环变量会泄漏为全局变量：
var arr = [1, 2, 3]; for (var i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b9fbc0fad1be9c37ca3465ac361032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107c0ce728058fd6bc367ac3f66bf932/" rel="bookmark">
			线代——猴博士笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求向量组的秩，先求极大无关组，极大无关组里几个向量，秩就是几
什么是极大无关组？从一向量组挑出几个向量，他们线性无关，且原来向量组中任意一个向量加进去，又变成了相关的。
什么是线性相关？对于一向量组，存在 不全为0的实数k1-km 使得这些数与每个向量相乘的和 = 0
行列式=0，线性相关一向量组的子集线性相关，整体线性相关 计算行列式 公式1：
公式2：
公式3：
两行（列）交换，行列式值变相反数
公式4：求余子式 和 代数余子式
公式5：
公式6：
公式7：
矩阵 转置矩阵性质
有可逆矩阵的条件：
先从上往下做，再从下往上做，就能得到单位矩阵
可逆矩阵：
乘一个A，把A* 消掉
在阶梯型矩阵中，几行有非0数，秩就是几
矩阵乘一个满秩矩阵，秩不变
判断：判断秩相等
判断线性相关无关：比较秩 和 向量个数
题型：
注意这里是求 行 向量的极大无关组，列向量不能这么求
（极大无关组 = 极大线性无关组）
判断方程组的解的情况：
齐次无解例题：
非齐次无解例题：
==========================================================================
解方程组：共有五步
求增广矩阵的秩：
变换矩阵：
R=3，就变换前三行，前三列，为单位矩阵的形式
根据②得到的矩阵变回方程组：
设未知数：
整理成标准型，再用刚刚设的未知数替代题目原来的未知数：
下面就是本题的解，k可取任意值：
例题练习：
如果是齐次方程组呢？
常数项都抹掉就完了、
==========================================================================
求方程组的通解、特解。基础解系：
要先解出方程组的解。
通解，含有所有的未知数，能代表所有情况的解
特解就是一组x1–xn的值，代入原方程，可以满足：
也就是未知数随便取值：这是一个特解
这也是一个特解：一般都令所有未知数=0
基础解系：
==========================================================================
已知方程组多个特解，求某齐次方程组的通解：
共三步：
一设未知数：
二：
三：
==========================================================================
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/107c0ce728058fd6bc367ac3f66bf932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b473d159776ef77d39ae39c3e405eb/" rel="bookmark">
			以下是Centos7、8的root密码修改方法（忘记密码且开机登录不上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重启或开机后按e键进入选择系统模式
光标移动到Linux16行，把ro 改为rw init=sysroot/bin/sh
按Ctrl+X 执行
进入后输入chroot /sysroot
输入passwd
根据提示输入2次新设的密码
完成后输入touch /.autorelabel
exit
reboot
重启后输入新密码就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76750e8c2e148b1c8703d8b0bf236dc3/" rel="bookmark">
			python&#43;pyqt5设置窗口最前与取消窗口最前
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在可视化程序的实际使用过程中，通常需要将某个程序窗口置于最前界面或者取消最前界面，以下为实现的方法。
1.启用 ‘窗口最前’ 功能
def sheZhi_chuangKouZuiQian(self): self.logOut("已启用 ‘窗口最前’ 功能...") from PyQt5 import QtCore w.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint) # 置顶 w.show() 2.禁用 ‘窗口最前’ 功能
def quXiao_chuangKouZuiQian(self): self.logOut("已禁用 ‘窗口最前’ 功能..." ) from PyQt5 import QtCore w.setWindowFlags(QtCore.Qt.Widget) #取消置顶 w.show() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94932b8edb5a01ac64f7e5f63158eedd/" rel="bookmark">
			用Python实现的这五个小游戏，你真的学会了嘛？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文件 源码分享，问题解答！！
关注小编，私信小编领取哟！
当然别忘了一件三连哟~~
对了大家可以关注小编的公众号哟~~
有很多资源可以领取的哟！！
Python日志
游戏名称 五子棋雷霆战机贪吃蛇坦克大战俄罗斯方块 开发环境 Python版本：3.6.4
相关模块：
pygame模块；
以及一些Python自带的模块。
环境搭建 安装Python并添加到环境变量，pip安装需要的相关模块即可。
一：五子棋 五子棋是是一种两人对弈的纯策略型棋类游戏。
五子棋有两种玩法。玩法一：双方分别使用黑白两色的棋子，下在棋盘直线与横线的交叉点上，先形成五子连线者获胜。玩法二：自己形成五子连线就替换对方任意一枚棋子。被替换的棋子可以和对方交换棋子。最后以先出完所有棋子的一方为胜。
pygame模块
游戏采用pygame模块需要先安装
pip install pygame 窗口启动
import pygame pygame.init() pygame.display.set_caption('五子棋-IT入门') # 改标题 # pygame.display.set_mode()表示建立个窗口，左上角为坐标原点，往右为x正向，往下为y轴正向 screen = pygame.display.set_mode((640,640)) 绘制棋子
需要说一下的是画棋子，因为没找到什么合适的棋子图片，所以只要自己来画棋子。
我们用pygame.draw.circle
绘制棋盘
定义棋盘这个类 class RenjuBoard(object): def __init__(self): # self._board = board = [[EMPTY] * 15 for _ in range(15)] # 将棋盘每一个交叉点都看作列表的一个元素位，一共有15*15共225个元素 self._board = [[]] * 15 self.reset() #重置棋盘 def reset(self): for row in range(len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94932b8edb5a01ac64f7e5f63158eedd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd3531c47a41b9a94ce3aa1e7430946/" rel="bookmark">
			deep: true, immediate: true
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Watch('$route.query', { deep: true, immediate: true }) 第一次跳转至消息中心的页面，该监听函数就会触发。
主要是利用watch属性的immediate属性，watch有一个特点是，最初的绑定是不会执行的，要等到监听的属性发生变化的时候才会执行监听，因此，如果我们想要第一次执行最初的绑定，就添加这个immediate属性，若为true,表示在watch在声明的时候就立即去执行handler方法。
顺便再记录一个知识，watch的deep属性，这个属性会对对象的所有的属性添加一个监听器，但是会存在性能开销的问题，就是对象的任何一个属性修改都会去执行handler。watch属性默认是对对象的引用进行监听的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c274119e8b1925a904214841685cfe50/" rel="bookmark">
			服务器被攻击了怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天德迅云安全的我给大家讲讲服务器被攻击的那些事，首页给大家讲讲我一客户的亲身经历。我有个客户开设了电商平台，最近几年电商平台俨然已经成了老百姓的生活依赖(淘宝/京东)，所以我这客户的小平台发展得也还不错。
直到之前那段时间日子他遇上了大麻烦，网站被攻击，服务器IP似乎也暴露了。这一年以来他的电商平台运营的还不错的，可能是客户量越来越多,客户一直认为自己只是小平台,认为没有那么多无聊的人来找他的麻烦的
然后他就换了DDoS高防ip(德迅云安全名下其中一款高防产品)，因为他之前一直用的是普通服务器，基本没有防护,源机IP已经暴露，现在换了高防，攻击还是可以绕过DDOs高防ip直接攻击发源机IP，我就建议他更换源机IP，并让技术帮他检查排除源站IP可能暴露的因素，是否存在源码信息泄露、是否存在某些恶意扫描情况、检查DNS解析配置等等。
毕竟我这客户本身不是专业的，以往过去的网络攻击多数都是随机的，但现在越来越多的网络攻击常常专门对付一家企业或其一个部门或更小的一个部分。德迅云安全的专业人员指出：攻击者往往会搞垮与其没有直接矛盾的网站，其目的仅仅是为了扩大对第三方目标的影响。选择高防服务器或者高防产品可以让你完全避免这种突如其来的攻击。
网络攻击往往只需要通过一些执行微妙的程序，就可以进行攻击。
总的来说，高防服务器或者高防产品对于企业网站的运营成功和发展具有非常重的作用和意义，企业拥有高防服务器或者接入高防产品，是对企业自身的一种安全保障。然后在我的建议下，他更换了源站IP，使用了高防产品。
那么该如何选择高防服务器或者高防产品呢，德迅云安全在这里建议大家：
1.选择合适的防御
选择服务器要根据自己的成本和日常被攻击的情况，还有机型配置，结合起来考虑，最好是选择以后可以升级防御的机房，这样如果最初选择的防御不够用，后期可以申请升级防御，节省了不少的麻烦,或者更为轻便的选择接入高防产品,减少了服务器防护选择的困难,只需要考虑机型配置,带宽即可
2.服务器的稳定性
要保证7*24小时不停的运作，保证所有网站正常运行，安全问题、硬件防御、软件防御、抵制恶意黑客攻击。
那么哪些行业适合高防服务器或者高防产品呢？德迅云安全在这里建议大家：
企业网站
网站的稳定是至关重要的一个因素，对于企业网站而言也不例外。客户会通过网站来了解企业的信息，要是网站经常出现一些问题，导致网站没法访问，这就会影响到用户对企业的印象感不好。因此对于一些大型企业来说，高防服务器或者高防CDN(德迅云安全名下其中一款针对于网站的高防产品)是一个很不错的选择，能防御很多的网络攻击而保障网站正常的打开和访问。对于用户的体验感提升很有帮助。
游戏行业
如今最火的行业就要数游戏行业了，很多的客户群体都在玩游戏，网页游戏，手游等等都是用户钟爱的种类。但随着竞争的激烈，很多游戏商都会遭受到网络攻击，严重的时候会导致一款游戏完全不发访问，这为游戏服务商带来很大的麻烦，因此游戏服务商对于高防服务器或者游戏盾(德迅云安全名下其中一款针对于游戏的高防产品,可以达到无视攻击的情况)的钟爱可见一斑。不仅能防御同行之间的恶意竞争，也能防止互联网的网络攻击。
金融行业
金融行业的数据安全是很重要的，一旦遭受攻击，那会造成很大的经济损失，因此在如今网络攻击频繁的年代，高防服务器成为最理想的选择。
视频行业
视频行业对于服务器的配置要求高以外，对于服务器的安全也是非常重要。视频行业的都存在很多的客户资料，一旦遭受攻击那损失都很巨大，因此高防服务器或者高防ip(德迅云安全名下其中一款高防产品,兼顾域名和端口防护)就成为众多视频从业者优先考虑的首选。
再来说说我这朋友的后续，他用了DDos高防ip一段时间后，平台恢复运营，也没有遭受到攻击，但是心里还有有点隐隐的担心，不知道能不能承受得住攻击。就在前天，又遇到了攻击！这攻击来得猝不及防，让他有些紧张，生怕承受不住啊！ 然而他发现，除了内心的紧张之外，网站没有受到任何影响。要不是数据显示遭受攻击，他还以为是假的呢！
通过德迅云安全对高防服务器、高防产品的介绍和适合行业的介绍，相信大家都对高防服务器和高防产品有了一定的认知，想知道更多全面的内容，请关注德迅云安全QQ3006013514。德迅云安全15年专注互联网IDC服务，在德迅云安全可以找到你们想要的服务器和防护产品！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98044850903863e53cb2a015ea15739/" rel="bookmark">
			虚拟化与docker基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、虚拟化1.虚拟化概述2、虚拟化的功能3、虚拟化的三种模式4、容器与虚拟化 二、Docker1、容器概述2、Docker概述3、Docker的设计宗旨4、容器与虚拟机的区别5、容器在内核中支持两种重要的技术6、Docker核心概念 三、安装Docker1、环境准备2、安装依赖包3、设置阿里云镜像源4、安装Docker-CE并设置为开机自动启动 四、docker镜像操作1、查看版本信息和详细内容2、搜索镜像3、获取镜像4、镜像加速下载5、查看镜像信息6、查看镜像列表7、获取镜像信息8、为镜像添加新标签9、删除镜像10、存出镜像，将镜像保存成为本地文件11、载入镜像，将镜像文件重新导入镜像库中12、上传镜像 一、虚拟化 1.虚拟化概述 什么是虚拟化？
虚拟化：将应用程序和系统内核资源进行解耦，以操作系统级别进行隔离，目的是提高资源利用率
CPU的时间分片
2、虚拟化的功能 将虚拟化的性能优化趋近于物理资源的性能，主要用于提高资源利用率
①在一个操作系统内,模拟多个操作系统
②以软件的方式模拟物理设备的功能
3、虚拟化的三种模式 1、全虚拟化(50%)
2、 半虚拟化(软、硬件结合的方式)
3、直通(以全硬件的方式，实现虚拟化的功能)
6大名称空间
mount文件系统，挂载点（一个文件系统内，不能重复挂载一个指定目录，例如: /mnt）user操作进程的用户和用户组pid进程编号uts主机名和主机域ipc信号量、消息队列，共享内存(理解，不同的应用调用内存资源的时候应该使用不同的内存空间)net网络设备、网络协议栈、端口等 4、容器与虚拟化 容器:
特性：性能损耗10-20%之间
容器基础概念就是名称空间
名称空间:
是 Linux 内核的一个强大特性，为容器虚拟化的实现带来极大便利，利用这特性，每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样 命名 间机制保证了容器之间彼此互不影响。
容器小的架构系统
其中nginx 吃一些CPU内存资源，吃一些操作系统所需要的文件系统资源
/usr/local/
容器:
bootfs是轻量级的操作文件系统centos，它300- 500M就够了
内核自带的rootfs提供的
二、Docker 1、容器概述 以linux而言，linux操作系统会有一个主进程pid=1派生出其他进程来控制不同服务
例如:
pid=2 ——&gt; python pid=3——&gt;java pid4——&gt;php，三个服务可能会相互影响
使用者期望将这三个不同的服务，跑在不同的运行时环境中实现相互不影响，同时不会增加服务器成本
同时延伸出能否将这三种服务分别封装起来这就需要KVM虚拟化技术，实现了一个操作系统模拟多个操作系统/不同的运行时环境
随着技术发展虚拟化技术开销较大(例如:只要运行一个py脚本，想要使用虚拟化方式实现，还需要安装一个操作系统，并不方便/合理)
延伸出容器技术
虚拟化层的抽象层(用户层)剥离，使用docker engine来替代(来宾操作系统去除)，只要通过引擎就可以直接连接到宿主机操作系统中，极大减小了开销。
2、Docker概述 1、Docker是一个开源的应用容器引擎，基于go语言开发并遵循apache2.0协议开源
2、Docker是在Linux容器里运行应用的开源工具，是一种轻量级的“虚拟机”
3、Docker的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的、可移植的、自给自足的容器，也可以利用docker在多台主机上轻松的创建并运行容器
3、Docker的设计宗旨 Build，Ship and Run Any App Anywhere
通过对应用组件的封装、发布、部署、运行等生命周期的管理，达到应用组件级别的“一次封装，到处运行”的目的。这里的组件，既可以是一个应用，也可以是一套服务，甚至是一个完整的操作系统。
4、容器与虚拟机的区别 容器是在Linux上本机运行，并与其他容器共享主机的内核，它运行的是一个独立的进程，不占其他任何可执行文件的内存，非常轻量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f98044850903863e53cb2a015ea15739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c6c1a88665963a09946ebac293fa17/" rel="bookmark">
			我理解的前端发展方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我个人的理解的前端2022年，甚至以后的前端发展的方向。这里没有太多的干货的知识，不会告诉你说Javascript怎么写，也不会告诉某个页面需要怎么排版……那都是一些很基础的东西（但是并不能我的本篇文章和思考有多么的高大上），这些方向的了解可能会贯穿我们整个前端的职业生涯；也可能等你在前端这个行业中摸爬滚打了多年之后，你才在某个清晨恍然大悟，原来这么多年我都是个机器：把设计稿转换成页面，每天做着这样重复但是看似有意思的工作。而我就是其中的后者。
先简单的介绍一下为什么我会有这样的想法吧。
我的前端经历 我是2010年开始学的前端，其实那个时候也就是那个时候前端还不能算是前端，Html5 还未发布，我们用的浏览器也还是IE6到IE8，我们前端还是一个最底层的工作（确切来说叫切图仔）；那个时候CSS还是处于1.0到2.0时代（为了保证页面不乱，我们喜欢用table进行布局）；那个时候浏览器还不支持很多的类（不如说那个时候还没又JSON对象，要想将字符串专程对象，就得用eval）；那个时候我们用的工具还是网页三剑客（可能现在的很多的前端小伙伴都不清楚网页三剑客是什么东西，网页三剑客：Dreamweaver, Firework, Flash）……就是在这样的一个环境中，我开始接触了前端。从第一个input框开始，到一个百度页面，再到后来的后来，再到今天。我正儿八经开始做前端的工作是从2015年开始的。所以这中间经历的很多的前端方面的时代的变迁。
从接开始前端方面的工作开始，从最初的P2P，到游戏，再到最后的2B的SAAS行业；从最初的JQuery时代，到后来的angualr1，再到后来的angular，vue，react三足鼎立框架的改变；从最初的grunt，gulp到webpack再到snowpack和vite等打包工具的变迁。就在这几年的时间中发展迅速，但是不变的就是前端的主要使用的东西依旧是html，css，js。
个人前端发展方向 对于我的经验来说，我理解的前端个人的发展方向未来会有以下几个方向：
深入理解业务，站在技术的角度能够提出更好的业务方面的改进，前端交互以及用户体验的发展（UED）偏向于服务端的前端开发，说白了就是基于NodeJs来实现前后端的统一开发偏向于工具类的开发，其实工具类就包含很多的东西了，比如说基于Node的rollup之类的，还有就是webpack，vite等相关的大包工具的开发偏向于跨平台方案的解决方案的设计和开发，比如说uniapp，taro，flutter，RN等等。基于浏览器的音视频功能的开发基于浏览器的图形图像类工具的开发，比如说在线PS，等等基于WebGL，和canvas的游戏仿真，虚拟现实的开发。 前后端全栈开发方向 随着NodeJs的发展，以及基于NodeJs的web服务端的框架的逐渐成熟，现在已经有很多企业都在使用NodeJs来作为服务端开发的解决方案了。这个时候的前端，其实就不仅仅是一个前端了，而是一个全栈开发工程师。我们前端会接触到很多做后端的同学，这样在跟他们沟通的过程中对与后端同学使用的技术以及开发的内容比较感兴趣，于是乎就开始学习部分后端的语言，比如说go，比如说Java，python等可以用来写服务的内容。渐渐的就逐步发展成为了一个全栈开发工程师。
那么对于一个全栈工程师来说，应该具备哪些方面的能力呢？
至少了解一门后端语言（不限于NodeJs，Python，Java，Go，C#），并且了解该语言所对应的服务端的开发框架。毕竟流行的语言，都会对应的有一个良好的开发框架：Node的express和koa，Python的Django，Java的Spring，Go的Zero，C#的.Net Mvc等等。只要了解了这写东西，才能够让你在后端开发过程中游刃有余。数据库，缓存，消息队列等等。数据库是用来存储用户的数据的，常用的数据库有MySql，Sqlserver，postgreQL这些关系行数据库，还有一些非关系行的数据库，比如说No-SQL，Redis等等，对于web后端还需要了解一些优化的方案，比如说使用缓存memerycach，消息队列等等。网络及通信协议，网络方面的内容我相信这都应该是一些很基础的内容，尤其是针对一个web开发人员来说，了解网络协议等内容，是我们必不可少的东西，常见的http通信和sokcet等；除了这些还有可能会涉及到进程见通信，管道，Rpc等等。架构设计能力，这个能力其实对于全栈工程师是必不可少的东西，网站的设计如何，将直接会影响到用户的体验等等。服务器运维能力，开发好的内容，就需要部署到对应的服务器上，给别人用起来，这样才有价值。因此作为一个全栈，最起码的搭建服务器环境，做最基本的项目部署迭代工作还是很重要的。 工具类的开发 这里所要讲的工具类的开发涉及到很多个方面:
我们开发过程中的打包工具webpack，rollup，vite等等，基于web的工具：vscode等基于web的CAD等相关的工具，比如说在线PS，figma在线办公工具，比如说，金山文档，draw.io等等…… 由于web的轻量和随时随地以及跨平台，以及目前浏览器越来越强大，以至于这样的在线版的工具越来越多而且未来也会越来越多。在未来，很多桌面版的工具会被搬上浏览器，而对于前端来说，这些工具的开发过程中就涉及的都是功能也逐渐被前端化，因此，前端的在这些方面又可以进行大展拳脚了。
跨平台框架开发 说起夸平台开发，很多的前端开发者都能够讲出来一些，比如说cordova，ionic，react- native，weex，kotlin-native，flutter等跨平台的框架百花齐放。当然，对于目前，国内我们还有小程序，在用户体验方面，小程序有着天然的优势，另外，小程序能够提升用户的粘性，因此各大厂商都在拼命的发展自己的小程序业务，我们常见的小程序有：微信小程序、QQ小程序、支付宝小程序、淘宝小程序、百度智能小程序、今日头条小程序、抖音小程序、360小程序。当然，面对这么多的小程序平台，虽说有不少的相似的地方，但是同样存在着不小的差异。因此对于我们我们前端来说不应该是每来一个平台就为其开发一套，因此，有不少的结局方案，比如说uniapp，taro等，解决方案。
对于我们前端来说如果仅仅是学会使用这些框架和解决方案，来完成企业的业务，发展来发展去，到最后，依旧是一个体力活。而这些，也正如上面所讲到的那样，绝对不是我们做前端的终点。因此，我们要做的就是其深层次的东西的研究。就是研究其底层进行跨平台编译的原理和编译思想。这样所能够接触到的东西，以及这些东西所涉及的方面就会更加的深入。
在做这方面的研究过程中，能够接触到不同平台等网络，渲染，运行语言等方面的只是，还能够使我们更加深入的立即编程语言的魅力以及其编译和运行的整个过程；另外还会了解的到虚拟机，操作系统，计算机体系结构，网络等等多方面的底层的只是内容；另外对于渲染层面的内容，我们要了解的可不仅仅是浏览器的渲染原理（什么重排，重绘等等），更重要的是去实际思考我们的东西应该怎么去绘制，中间包含有计算机图形学，图像处理等多方面的内容……
因此如果在
音视频方向 近几年，国能的短视频，在线视频播放的不断的增长和拓张；2020 年疫情爆发，直接促使了会议、教育等线上视频产品的飞速成长；2021年1月26号WebRTC也正式的进入到了W3C的标准中，一时间基于Web的音视频开发也被推到了风尖浪口。
未来基于Web的音视频开发，绝对会成为稀缺，可能现在的很多人都觉得基于Web的音视频开发，无非就是html5的video和audio的标签么？其实基于Web的音视频开发（WebRTC）主要有两个方面：
一个是音视频的播放方面
支持对流式视频和音频的解码和显示能够从网络摄像头中捕获视频和音频流对呼叫的协调协议（如信号处理）高效的音频和视频的编码及解码器处理回波消除、噪声抑制、比特率适应（根据带宽自适应的流）等诸多方面的算法。 一个是网络传输方面
WebRTC通信方面的内部构造主要包含有下面的内容：
点对点通信防火墙和 NAT 穿透信令，会话及协议WebRTC 接口 这中间的每一个模块都够折腾很久了。然而这也仅仅只是一小部分的内容，未来WebRTC可能会涉及到的领域很多，比如说实时监控，网络云游戏，以及云电脑等等。但是在前端这块，其实基于浏览器去做音视频方面的内容的开发，还是面临和很大的挑战的。因子未来前端同学如果感兴趣的话，可以在音视频方面进行较深入的研究。
数据可视化方向 有人说数据可视化不就是图表么，不就是调用echarts等图表插件把数据从冰冷的数字转换成图形，顶多就是色彩丰富一些，做一些特效什么的，看起来更酷炫，逼格满满，写老板在写PPT的时候显得更好看一些。
其实不然，一个好的可视化，能够带给人们不仅仅是视觉上的冲击，还能够揭示蕴含在数据中的规律和道理。常见的数据可视化的使用场景有以下几点：
工业数字化中台，监控台，园区设备等场景智能家居的进一步发展，3D云看房，远程操控台等场景NoCode下的3D模型，拖拽式的仓储管理系统等场景智能机器人，Iot物联网场景AR，VR、元宇宙..... 可见我们数据可视化未来的发展以及使用的场景该是有多么的有前途。
游戏方向 从最早的flash页游，到现在，前端推出了Canvas以及WebGL，以及目前前段游戏引擎的不断的崛起：Egret、laya、pixi、three.js，通信协议有websocket和http等等，而且再加上现在的浏览器基本上都开始不断的放弃flash，因此，基于H5的游戏，也越来越流行了。而且现在很多的平台也都开始在搞游戏化的宣传，视图通过游戏来增加大家的用户粘性：比如说支付宝的，蚂蚁森林，蚂蚁庄园等等，甚至还有一些会通过一些小游戏来进行做一些宣传。
不仅仅如此，就连元宇宙其实也是很游戏有关的，当游戏遇上了VR遇上了AR在遇上了Web，我相信这些东西所能够带来更多的新颖的东西。曾经我们在晚上卖东西或者是卖东西，都是渐渐的跟这些东西的进行了结合。
前端的技术研究方向 对于很多的有理想，有抱负的前端开发人员来说，为了支撑这些技术的发展方向，我们需要在哪些技术方面进行提升自己呢。我大致总结了以下几个方面：
计算机图形学图形图像和音视频计算机网络WebAssembly 当然这些内容其实看起来更多的是跳出了我们平时经常接触的前端的三大主流内容，但是这些才是我们身为一个手艺人才应该将更多的精力投入进去，来充实自己，让自己具备有更多的战斗力，让我们能够在前端这条路上面走的更远。
小结 未来的浏览器会越来越强大，而前端的在整个技术领域中的划分，也将变得越来越重要，而我们身为前端开发人员，要与时俱进，不断的提升自己，来让自己具备更强的市场竞争力，以及用我们自身的技术手艺来带来更加巨大的社会价值。我也希望，更多前端小伙伴不再拥有35岁的焦虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c547ca347afd0e90899c1dd61a079f/" rel="bookmark">
			Android 12 系统源码分析 | Native Binder 代码变迁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：秋城
注：广义上 Native Binder 可理解为包含 vnd，hw，rpc 等内容，本文所讨论的Native Binder 指的仅是 servicemanager 服务程序及 libbinder 中相关代码，不做广义的延伸
一、前言 Servicemanager 程序（以下简称SM）是 Android 系统 binder 模块重要的组成部分，扮演着类似 C/S 架构中的 DNS 服务器的角色，提供服务增查和权限管理等功能支撑
在 Android 11 之前的版本里，SM 是面向 binder 驱动编程，直接使用 open、mmap、ioctl 等 api 与 binder 驱动交互。而从 Android 11 开始，SM 放弃使用这些较底层的接口，转向 libbinder 库和 AIDL。标志性的提交如下，该提交奠定了新的 SM 架构基础，此后多次提交对此进行完善填充
frameworks/native
servicemanager: use libbinder Bug: 135768100 Test: boot Test: servicemanager_test Change-Id: I9d657b6c0d0be0f763b6d54e0e6c6bc1c1e3fc7a (cherry picked from commit 3e092daa14c63831d76d3ad6e56b2919a0523536) 本文代码基于 Android 12，以 SM 为主视角，从架构和情景流程上带大家认识新的 Native Binder
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c547ca347afd0e90899c1dd61a079f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd9387daef962de1221cce407583a93/" rel="bookmark">
			Go操作Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备环境 首先需要安装docker， 可参考菜鸟教程， docker环境配置好后，从docker hub 上拉一个redis镜像：
docker pull nginx 默认拉取最新版本的镜像
拉取镜像后可以运行容器：
docker run -d -p 6379:6379 --name redis redis 参数说明
-d指定后台运行容器 -p配置内外端口映射 --name 指定运行容器的名字
再启动一个redis-cli连接上面启动的redis服务
docker run -it --network host --rm redis redis-cli 参数说明
-it进入到运行的容器中 --network指定网络模式为host模式 --rm停止容器后自动删除挂载点
go-redis库 使用go-redis库连接操作redis数据库，go-redis库支持连接哨兵及集群模式的redis
使用以下命令安装
go get -u github.com/go-redis/redis 运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)
连接 import "github.com/go-redis/redis" // 声明全局rdb变量 var rdb *redis.Client func initClient() (err error) { rdb = redis.NewClient(&amp;redis.Options{ Addr: "localhost:6379", Password: "", DB: 0, }) _, err = rdb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd9387daef962de1221cce407583a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0523543b0b3782491418b41dee161ee/" rel="bookmark">
			这可能是最好的Redis分布式锁实现了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Hello 大家好，今天给大家分享redisson实现的多类型锁、支持几乎所有加锁场景的redis分布式锁的实现，还支持小型MQ和redis的各种数据操作，完整源码可以关注我私聊。
理论部分 在之前的文章中，介绍了通过redis实现分布锁的两种方式，分别是：
通过redis自带的命令：setNX通过redis的客户端：redisson 作者更加推荐使用redisson客户端的方式，因为redisson支持更多的锁类型，譬如联锁、红锁、读写锁、公平锁等，而且redisson的实现更加简单，开发者只需要调用响应的API即可，无需关心底层加锁的过程和解锁的原子性问题。列出了redisson对于多种的锁类型的简单实现，即编程式实现。这样的实现完全能够满足我们的日常开发需求，但是缺点也很明显。
譬如：
代码嵌入较多，不够优雅重复代码对锁的参数运用不直观容易忘掉解锁的步骤 使用过Spring的同学，肯定都知道@Transactional注解，Spring即支持编程式事务，也支持注解式（声明式）事务。
我们是否也可以参考这样的实现呢？
答案是：完全OK！
AOP就是专门干这种事的。
实战部分 1、引入redisson依赖 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.16.2&lt;/version&gt; &lt;/dependency&gt;Copy to clipboardErrorCopied 复制代码 2、自定义注解 /** * 分布式锁自定义注解 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Lock { /** * 锁的模式：如果不设置自动模式，当参数只有一个.使用 REENTRANT 参数多个 MULTIPLE */ LockModel lockModel() default LockModel.AUTO; /** * 如果keys有多个，如果不设置，则使用 联锁 * * @return */ String[] keys() default {}; /** * key的静态常量：当key的spel的值是LIST、数组时使用+号连接将会被spel认为这个变量是个字符串，只能产生一把锁，达不到我们的目的， * 而我们如果又需要一个常量的话。这个参数将会在拼接在每个元素的后面 * * @return */ String keyConstant() default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0523543b0b3782491418b41dee161ee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/269/">«</a>
	<span class="pagination__item pagination__item--current">270/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/271/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>