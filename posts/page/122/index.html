<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764e9c71af94e0ed111e933bb8d41f6a/" rel="bookmark">
			macOS M2使用conda配置pytorch环境 亲测有效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、进入官网 https://pytorch.org
选择对应的版本，复制下面的命令
pip3 install torch torchvision torchaudio 二、开始创建虚拟环境，下载pytorch 1、conda create -n torch-gpu python=3.102、conda activate torch-gpu3、conda install pytorch torchvision torchaudio -c pytorch 第一条命令是创建名为torch-gpu，python版本为3.10的虚拟环境
第二条命令是激活环境
第三条命令就是安装pytorch
三、测试 python import torch torch.__version__ import numpy as np np_data = np.arange(6).reshape((2,3)) torch_data = torch.from_numpy((np_data)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51c06bbbe8fd3da7b640cf3b52700f2/" rel="bookmark">
			程序员怎么利用ChatGPT解放双手=摸鱼？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 当你遇到问题时为你生成代码ChatGPT 最明显的用途是根据查询编写代码。我们都会遇到不知道如何完成任务的情况，而这正是人工智能可以派上用场的时候。例如，假设我不知道如何使用 Python 编写 IP 修改器，只需查询 AI，它就会生成非常好的代码。你还可以通过向 ChatGPT 提供有关所提供响应的更多反馈来修改或改进代码。就像对待另一个几乎无所不知的人一样对待它。
2. 重构并检查代码是否有错误
我们现在已经编写了一些代码，现在是时候启动它了。糟糕，你的代码无法编译或无法按预期工作。别担心，ChatGPT 也可以在这方面为我们提供帮助。
假设我们已经用 C++ 编写了二分搜索算法，但它没有按预期工作。只需将你的代码粘贴到 ChatGPT 中，描述代码应如何工作，以及哪些内容不能按预期工作。
3. 解释生成的每一行代码
如果你还不清楚和理解 ChatGPT 生成的代码，可以向它询问其代码片段中的任何内容。
4.帮助我理解不同的主题
任何优秀的编程者也是伟大的学习者，因此彻底理解编码概念将使我们的代码质量成倍提高。
5. 为程序生成测试
为程序创建测试用例是一项比较艰巨的任务。那么为什么不使用有史以来最强大的数据生成器 ChatGPT 来实现此目的呢？
只需向 ChatGPT 提供你希望其编写测试的格式、使用哪种语言以及预期结果以及采用哪种格式即可。
如果有更具体的信息，请直接向人工智能提供你可能想到的每一个细节。
小结
在这篇文章中，为大家介绍了 ChatGPT 对我们程序员来说最重要的 5 个用途。
就我个人而言，我每天都使用这项技术。自从我开始与人工智能融合以来，我的编码技能有了显著的提高。不要害怕使用这项技术来发挥你的优势，你不会失去任何东西，还可以节省更多时间并更好地理解编码。
如果各位有更多有用的 ChatGPT 使用技巧，欢迎在评论中分享！~
福利：文末有chat-gpt纯分享，无魔法，无限制 我相信每个程序员都至少听说过ChatGPT以及它处理、计算和创建海量数据的神奇能力。
如果没有，请各位先查看这篇维基百科文章：
ChatGTP的介绍URL ：https://en.wikipedia.org/wiki/ChatGPT
50年前，人们甚至无法相信可能有人造产物在如此多的领域超越人类。
如今，我们对手机屏幕或键盘上几个选项卡的距离感到惊讶；然而，令人遗憾的是，仍然有很多人在工作中没有充分利用 ChatGPT 的全部优势。这主要与人们不愿意学习新技术或担心失去以前获得的编程技能有关，而正确使用 ChatGPT，情况则并非如此。
在本文中，向大家介绍 ChatGPT 对编码工作最有用的一些用途。请您记住，使用人工智能并没有什么可耻的，因为它在我们日常生活中的发展和进一步实施是不可避免的，所以应该尽早开始适应它，以充分利用它“神奇”的技术。
那么，让我们开始吧！
1. 当你遇到问题时为你生成代码
ChatGPT 最明显的用途是根据查询编写代码。我们都会遇到不知道如何完成任务的情况，而这正是人工智能可以派上用场的时候。例如，假设我不知道如何使用 Python 编写 IP 修改器，只需查询 AI，它就会生成非常好的代码。你还可以通过向 ChatGPT 提供有关所提供响应的更多反馈来修改或改进代码。就像对待另一个几乎无所不知的人一样对待它。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51c06bbbe8fd3da7b640cf3b52700f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce7e6514a4e9e34cfff016a263d5cef/" rel="bookmark">
			（三十五）ArcMap创建最小边界几何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcMap数据管理——创建最小边界几何 目录 ArcMap数据管理——创建最小边界几何 1.概念2.插图3.几何类型4.组选项（可选）5.将几何特征作为属性添加输出中 (可选) 1.概念 创建包含若干面的要素类，用以表示封闭单个输入要素或成组的输入要素指定的最小边界几何。
2.插图 输出最小外接几何类型：
3.几何类型 指定输出面代表何种类型的最小边界几何。
RECTANGLE_BY_AREA—封闭某输入要素的面积最小的矩形。这是默认设置。
RECTANGLE_BY_WIDTH—封闭某输入要素的宽度最小的矩形。
CONVEX_HULL—封闭某输入要素的最小凸面。
CIRCLE—封闭某输入要素的最小圆形。
ENVELOPE—某输入要素的包络矩形。
CONVEX_HULL、CIRCLE 和 ENVELOPE 选项仅在具备 ArcGIS for Desktop Advanced 级别许可的情况下可用。
每种几何类型均可将一个或多个唯一的测量值作为特征，宽度、长度和直径的值将采用要素单位；方向的角度值将采用十进制度，以北为基准方向顺时针进行测量。前缀 MBG_ 表示最小边界几何字段。
①对于 RECTANGLE_BY_AREA 和 RECTANGLE_BY_WIDTH，新字段和测量值分别为：
MBG_Width - 生成矩形的短边长度。
MBG_Length - 生成矩形的长边长度。
MBG_Orientation - 生成矩形的长边方向。
②对于 ENVELOPE，新字段和测量值分别为：
MBG_Width - 生成矩形的短边长度。
MBG_Length - 生成矩形的长边长度。
对于 CONVEX_HULL，新字段和测量值分别为：
MBG_Width - 凸包中相距最近的任意两折点间的距离。（距离最近的折点可能不只一对，但将使用最先找到的那对。）
MBG_Length - 凸包中相距最远的任意两折点间的距离；这些折点称为对映体对或对映点。（距离最远的折点可能不只一对，但将使用最先找到的那对。）
MBG_APodX1 - 对映体对中第一个点的 x 坐标。
MBG_APodY1 - 对映体对中第一个点的 y 坐标。
MBG_APodX2 - 对映体对中第二个点的 x 坐标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce7e6514a4e9e34cfff016a263d5cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b115c4a3f40f8d3549d85894db973411/" rel="bookmark">
			CentOS 7 下 Keepalived &#43; Nginx 实现双机高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 下 Keepalived + Nginx 实现双机高可用 文章目录 CentOS 7 下 Keepalived + Nginx 实现双机高可用服务器准备服务信息服务架构 服务安装nginxKeepalived 服务配置nginxKeepalived 启动服务nginxkeepalived 服务验证查看 VIP 状态CURL 命令访问浏览器访问 高可用验证停止 web01 下 Nginx恢复 web01 下 Nginx 参考 服务器准备 服务信息 主机名IP角色其他my-web01192.168.157.31nginx
keepalivedmastermy-web02192.168.157.32nginx
keepalivedbackupVIP192.168.157.30 服务架构 服务安装 nginx # 所有主机 [root@my-web01 ~]$ yum -y install nginx Keepalived # 所有主机 [root@my-web01 ~]$ yum -y install keepalived 服务配置 nginx web01 [root@my-web01 ~]$ cat /usr/share/nginx/html/index.html &lt;!DOCTYPE html&gt; &lt;h1&gt;my web01 ~~~&lt;/h1&gt; web02 [root@my-web02 ~]$ cat /usr/share/nginx/html/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b115c4a3f40f8d3549d85894db973411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f97f75e89882f2f68138ac3f439c6dc/" rel="bookmark">
			（三十一）矢量数据的空间分析——叠置分析①
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矢量数据的空间分析——叠置分析 叠置分析是将代表不同主题的各个数据层面进行叠置，产生一个新的数据层面，叠置结果综合了原来两个或多个层面要素所具有的属性。
叠置分析不仅生成了新的空间关系，而且还将输入的多个数据层的属性联系起来产生了新的属性关系。
叠置分析要求被叠加的要素层面必须是基于相同坐标系统的相同区域，同时还必须查验叠加层面之间的基准面是否相同。
根据操作要素不同，叠置分析可分成按点与多边形叠加、线与多边形叠加、多边形与多边形叠加；根据操作形式的不同，叠置分析可以分为图层擦除、识别叠加、交集操作、对称区别分析、图层合并和修正更新。
目录 矢量数据的空间分析——叠置分析 1.图层擦除1.1图解1.2用法1.3操作步骤 2.标识叠加2.1图解2.2用法2.3操作步骤 3.相交操作3.1图解3.1.1面输入3.1.2线输入 3.2用法3.3操作步骤 1.图层擦除 1.1图解 通过将输入要素与擦除要素的多边形相叠加来创建要素类。只将输入要素处于擦除要素外部边界之外的部分复制到输出要素类。
1.2用法 擦除要素可以为点、线或面，只要输入要素的要素类型等级与之相同或较低。面擦除要素可用于擦除输入要素中的面、线或点；线擦除要素可用于擦除输入要素中的线或点；点擦除要素仅用于擦除输入要素中的点。
输入要素类的属性值将被复制到输出要素类。但是，如果输入是一个或多个通过创建要素图层工具创建的图层并且选中了字段的使用比率策略设置项，那么计算输出属性值时将按输入属性值的一定比例进行计算。
如果启用了使用比率策略选项，执行叠加操作时，对于任一要素的分割都将按照输入要素属性值的一定比率来生成输出要素的属性值。输出值将根据输入要素几何被分割的比率得出。例如，如果输入几何被分割成相等的两部分，则每个新要素的属性值都等于输入要素属性值的一半。使用比率策略仅适用于数值型字段。
1.3操作步骤 ①打开ArcToolbox工具箱，选择分析工具——叠加分析——擦除，打开擦除对话框；
②设置输入要素为需要擦除的要素，擦除要素为用于擦除重叠输入要素的要素，使出要素类中设置擦除后的要素路径及名称，如下图，用中间棕色要素擦除蓝色要素；
③单击确定，完成操作。
擦除结果如下：
2.标识叠加 2.1图解 计算输入要素和标识要素的几何交集。与标识要素重叠的输入要素或输入要素的一部分将获得这些标识要素的属性。
2.2用法 ①输入要素可以是点、多点、线或面。注记要素、尺寸要素或网络要素不能作为输入。
②标识要素必须是面要素，或与输入要素的几何类型相同。
③如果使用此工具时，将点作为输入而将面作为标识要素，那么直接落在面边界上的点将被添加到输出中两次；为每个包含该边界的面各添加一次。在此情况下，对输出运行相交工具可识别重复点，以确定要保留的点。
④如果输入要素为线而标识要素为面，并且选中了保留关系参数（将关系设置为 KEEP_RELATIONSHIPS），则输出线要素类将具有两个附加字段 LEFT_poly 和 RIGHT_poly。这些字段用于记录线要素左侧和右侧的标识要素的要素 ID。
2.3操作步骤 ①分析工具——叠加分析——标识，打开标识对话框；
②设置输出要素、标识要素、输出要素类的路径及名称；
③连接属性默认为全部连接，及输出要素属性表由输入要素属性和标识属性组合而成；
④单击确定，完成操作。
3.相交操作 相交工具用于计算任意数量的要素类和要素图层的几何交集。所有输入的公共（即相交）要素或要素的一部分将被写到输出要素类中。
3.1图解 3.1.1面输入 面可以如下三种方式相交：
叠置 - 将“输出类型”保留为默认值（“最低”）可生成重叠区域。
公共边界/相交于线 - 将“输出类型”指定为“线”可生成此类型的交集。
相交于点 - 将“输出类型”指定为“点”可生成此类型的交集。
①面输入和面输出
下图显示的是输出类型参数设置为“面”或默认值（“最低”）时将两个面要素类相交的结果。输出面要素是某一输入要素类或图层中的面与另一输入要素类或图层中的面相交的部分。
②面输入和线输出
下图显示的是输出类型参数设置为“线”时将两个面要素类相交的结果。输出线要素是某一输入要素类中的面与另一输入要素类中的面共用的公共边界（相交于线）。
③面输入和点输出
下图显示的是输出类型参数设置为“点”时将两个面要素类相交的结果。输出点要素是某一输入要素类中的面与另一输入要素类中的面边界的交点（相交于点）。
3.1.2线输入 如果所有输入均为线要素类，则可使用“相交”工具确定输入要素类中的要素与点和线在何处重叠和相交。
①线输入和线输出
下图显示的是输出类型参数设置为“最低”或“线”时将两个线要素类相交的结果。输出线要素是某一输入要素类中的线与另一输入要素类中的要素叠置的部分。
②线输入和点输出
下图显示的是输出类型参数设置为“点”时将两个线要素类相交的结果。输出点要素是某一输入要素类中的线与另一输入要素类中的要素的交叉点。
③点输入和点输出
如果所有输入均为点要素类，则可使用“相交”工具确定哪些点是所有输入要素类共用的点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f97f75e89882f2f68138ac3f439c6dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121390284864d842a3b5f79d2e09dd49/" rel="bookmark">
			（二十五）ArcGIS空间数据的转换与处理——投影变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS空间数据的转换与处理——投影变换 原始数据往往由于在数据结构、数据组织、数据表达等方面与用户需求不一致而要进行转换与处理。本节主要介绍 ArGIS 中数据的投影变换内容。
目录 ArcGIS空间数据的转换与处理——投影变换 1.概述2.定义投影3.投影变换3.1栅格数据的投影变换3.2矢量数据的投影变换 1.概述 由于数据源的多样性，当数据的空间参考系统 (坐标系统、投影方式) 与需求不一致时，就需要对数据进行投影变换。同样，在完成本身有投影信息的数据采集时为了保证数据的完整性和易交换性，要定义数据投影。
地球是一个不规则的球体，为了能够将其表面内容显示在平面上，就必须将球面地理坐标系统变换到平面投影坐标系统。因此，运用地图投影方法，建立地球表面上和平面上点的函数关系，使地球表面上由地理坐标确定的点，在平面上有一个与它相对应的点。地图投影的使用保证了空间信息在地域上的连续性和完整性。
当系统使用的数据取自不同地图投影的图幅时，需要将一种投影数据转换为所需投影的坐标数据。投影转换的方法可以采用正解变换、反解变换和数值变换三种方法。
正解变换：
通过建立一种投影变换为另一种投影的严密或近似的解析关系式，直接由一种投影的数字化坐标x、y变换到另一种投影的直角坐标X、Y。
反解变换：
即由一种投影的坐标反解出地理坐标 (x、y→B、L)，然后再将地理坐标代入另一种投影的坐标公式中(B、L→X、Y)，从而实现由一种投影坐标到另一种投影坐标的变换 (t、y→X、Y)。
数值变换:
根据两种投影在变换区内的若干同名数字化点，采用插值法、有限差分法、最小二乘法、有限元法和待定系数法等，从而实现由一种投影坐标到另一种投影坐标的变换。
目前，大多数 GIS 软件是采用正解变换法完成不同投影之间的转换，并支持常见投影之间的转换。
借助 ArcToolbox **【投影和变换】**工具集中的工具 ，可以实现定义及变换数据的空间参照系统，以及栅格数据的多种变换，如翻转(Flip)、旋转(Rotate)和移动 (Shift) 等操作。
2.定义投影 定义投影，指按照地图信息源原有的投影方式，为数据添加投影信息。具体操作如下面六步。
①选择数据管理工具–投影和变换–定义投影，打开定义投影对话框；
②在输入数据集或要素类文本框中选择需要定义投影的数据；
③坐标系文本框显示为空白或Unknown，表明原始数据没有定义坐标系统。单击旁边的图标，打开空间参考属性对话框，设置数据的投影参数。
④定义投影有三种方法:
第一，单击选择按钮，打开浏览坐标系对话，为数据选择坐标系统。其中坐标系统分为**地理坐标系统 (Gegraphic Coordinate Systems)、垂直坐标系统(Vertical Coordinate Systems) 和投影坐标系统 (Projected Coordinate Systems)**三种类型。地理坐标系统利用地球表面的经度表示，投影坐标系统利用数学换算将三位地球表面的经纬度坐标转换到二维平面上；垂直坐标系可以定义高度或深度值的原点。在定义坐标系统之前，要了解数据的来源，以便选择合适的坐标系统。
第二，当已知原始数据与某一数据的投影相同时，可单击选择导入，浏览具有某坐标系统的数据，用该数据的投影信息来定义原始数据。
第三，单击新建–新建坐标系统。同样可以新建地理坐标系统和投影坐标系统。定义地理坐标系统包括定义或选择参考椭球体、测量单位和起算经线。定义坐标系统，需要选择投影类型、设置投影参数及测量单位等。因为投影坐标系统是以地理坐标系统为基础的，在定义投影坐标系统时，还需要选择或新建一个地理坐标系统，单击新建，打开新建地理坐标系对话，新建地坐标系统。
⑤定义投影后，单击完成，返回上一级对话框，在地理坐标系下的窗口中可浏览投影的详细信息。单击修改可修改已定义的投影，单击清除则清除原有投影，以便重新定义投影。
⑥单击确定，完成操作。
3.投影变换 投影变换是将一种地图投影转换为另一种地图投影，主要包括投影类型、投影参数或椭球体等的改变。在 ArcToolbox 的数据管理工具里的投影和变换工具集中分为栅格和**矢量(要素类)**两种类型的投影变换，其中对栅格数据实施投影变换时，要进行重采样处理。
3.1栅格数据的投影变换 ①选择数据管理工具–投影和变换–栅格–投影栅格工具，打开投影栅格对话框；
②在输入栅格文本框中指定需进行投影变换的栅格数据，该栅格数据必须已经具有投影信息，若没有则在输入坐标系中指定数据的原始投影信息；
③在输出栅格数据集文本框键入输出的格数据的路径与名称；
④单击输出坐标系文本旁边的图标，打开空间参考属性对话框，定义输出数据的投影。
⑤变换栅格数据的投影类型，需要重采样数据。重采样技术是可选项，用以选择栅格数据在新的投影类型下的重采样方式，默认状态是 NEAREST，即最邻近采样法。
⑥输出像元大小定义输出数据的栅格大小，默认状态下与原数据栅格大小相同，支持直接设定栅格大小；或通过选择某栅格数据来定义栅格大小，则输出数据的栅格大小与该数据相同。
(7)单击确定按钮，完成操作。
3.2矢量数据的投影变换 ①选择数据管理工具–投影和变换–要素–投影工具，打开投影对话框；
②在输入数据集或要素类文本中选择进行投影变的量数据。如果输入的数据本身没有投影信息，则需通过单击图标，在输入坐标系中定义原始数据的投影；若原始数据有投影，则系统自动读出相关信息并显示在输入坐标系中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81c3d5395ee763a7b40fe1e724b4537/" rel="bookmark">
			华为OD算法题-分苹果问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9(1100 + 0101=9)，B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。如果无法满足A的要求，输出-1。
分析： 首先，我们需要按照A的计算规则将苹果分成两堆。根据A的规则，我们将每个苹果的重量转换为二进制数，并使用二进制加法计算每堆的重量。如果无法满足A的要求，即两堆的重量不等，那么无法继续进行。
接下来，我们尝试找到B可以获取的苹果重量最多的情况。我们首先假设B获取较重的那一堆，然后逐个尝试减小B获得的苹果数量，直到满足A的情况。在每次尝试中，我们使用十进制加法计算B获得的苹果重量，包括正常进位，然后检查是否满足A的要求。
java代码实现： import java.util.Arrays; /* A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果， 他的计算规则是按照二进制加法计算， 并且不计算进位 12+5=9(1100 + 0101=9)， B的计算规则是十进制加法，包括正常进位， B希望在满足A的情况下获取苹果重量最多。 输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。 如果无法满足A的要求，输出-1。 */ public class AppleDistribution { /** * 解答： * 首先，我们需要按照A的计算规则将苹果分成两堆。 * 根据A的规则，我们将每个苹果的重量转换为二进制数， * 并使用二进制加法计算每堆的重量。 * 如果无法满足A的要求，即两堆的重量不等，那么无法继续进行。 * &lt;p&gt; * 接下来，我们尝试找到B可以获取的苹果重量最多的情况。 * ，然后逐个尝试减小B获得的苹果数量，直到满足A的情况。 * 在每次尝试中，我们使用十进制加法计算B获得的苹果重量， * 包括正常进位，然后检查是否满足A的要求。 */ public static int calculateWeight(int appleCount, int[] appleWeights) { String[] appleWeightBinary = new String[appleCount]; for (int i = 0; i &lt; appleCount; i++) { appleWeightBinary[i] = String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81c3d5395ee763a7b40fe1e724b4537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06322495b2c7e137e6ca3946ec51d536/" rel="bookmark">
			Android13 有线网开关研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13 有线网开关研究 文章目录 Android13 有线网开关研究前言1、api2、问题3、目的 二、代码分析1、Android13 上的 EthernetTracker2、Android13 上的 EthernetTracker3、对比开关过程1、Android13 关闭有线网，未移除节点: 2、Android9 关闭有线网，移除节点:3、NetdUtils 三、总结1、Android13 新增了有线网开关的api2、有线网开关区别（1）Android9 中要参考 Android13 不移除节点（2）Android13 中要参考 Android9 移除节点 3、有线网出现没ip 问题 本文对比 Android9 自己开发的有线网开关代码。
前言 1、api Android13 的api 提供了有线网开关 EthernetManager.setEthernetEnabled(boolean)，
Android9 如果要设置有线网开关，需要自己实现。
2、问题 Android13 上有出现打开有线网并且接入有线网无ip的情况，
并且调用开关有线网开关无作用（未移除节点eth0），ifconfig etho down/up 操作一次就有ip了。
3、目的 Android9 上有线网开关接口是会关闭节点的；Android13 上开关有线网节点一直是存在的。
所有决定研究一下有线网开关,希望能过解决问题。
主要研究代码是： EthernetTracker.java 的相关处理
之前Android 9 增加的有线网开关文章：
https://blog.csdn.net/wenzhi20102321/article/details/122243396
二、代码分析 1、Android13 上的 EthernetTracker E:\982\code\android_source\packages\modules\Connectivity\service-t\src\com\android\server\ethernet\EthernetTracker.java
private final INetd mNetd; @VisibleForTesting(visibility = PACKAGE) protected void setEthernetEnabled(boolean enabled) { mHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06322495b2c7e137e6ca3946ec51d536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7f8a9f1b305c198b2884246e3cd419/" rel="bookmark">
			探索虹科工业树莓派更多可能性—兼顾CODESYS数据采集和Python数据优化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 工业4.0理念的兴起带来了数字化和智能化的革命。现代工业场景对OT端设备的要求越来越高，需要处理多样化的任务和数据，包括实时控制、数据处理、物联网通信、边缘计算等。面对多样化的需求，传统工业PLC控制器设备已经不能完全满足，需要一种更强大的OT端设备满足数字化、智能化需求。
一、解决方案 针对上述情况，虹科曾提出过一种解决方案：为PLC控制器设备添加虹科工业树莓派设备，借由工业树莓派接口丰富的特点，采集PLC控制器的数据并进行边缘计算。本文，我们将提供第二种解决方案：采用虹科工业树莓派替代PLC控制器。
虹科工业树莓派是一个专门为工业应用设计的边缘计算硬件平台，它能够与CODESYS进行结合作为软PLC模块使用，以满足传统工业中电气工程师的开发应用习惯。除此之外，虹科工业树莓派可以作为边缘计算网关，支持Python开发应用。虹科工业树莓派本身配备一个多核处理器，可以同时运行多个程序，实现并行计算。本文将探讨虹科工业树莓派同时作为软PLC和边缘计算网关的可行性。
二、理论分析 1、多核处理器 虹科工业树莓派采用Broadcom BCM2711四核处理器，可以同时运行多个程序，实现并行计算，提高性能。
2、大内存配置 虹科工业树莓派部分型号配备较大的内存，能够支持同时运行多个程序，确保运行的稳定性。
3、独立运行环境 CODESYS和Python作为独立的运行环境，彼此之间不会相互干扰，各自运行在不同的进程中，不会冲突。
4、分时调度 Linux操作系统有着优秀的进程调度机制，能够快速地在不同任务之间切换，实现看似同时运行的效果。
三、初步实践测试 虹科工业树莓派自带两个支持可自由编程控制的指示灯，本次初步测试内容：
CODESYS控制指示灯，Python程序获取指示灯状态；指令控制指示灯，CODESYS在线监测指示灯状态。 1. CODESYS控制指示灯，Python程序获取指示灯状态 a.CODESYS定义变量；
b.CODESYS程序：A1指示灯和A2指示灯亮绿灯，运行；
c. 使用虹科开发提供的myCtrlLib库编写Python程序获取指示灯状态；
d.在线修改CODESYS程序，并重新下载；
e.结果：CODESYS控制设备成功，Python同时获取设备数据成功。
2. 指令控制指示灯，CODESYS程序获取指示灯状态 a.输入指示灯控制指令；
piTest -w RevPiLED,5
b.CODESYS监测状态；
c.指令查看指示灯当前状态。
d.结果：Python控制设备失败，CODESYS获取数据当前状态成功。
3.测试分析 基于虹科提供的myCtrlLib库的基础上，在CODESYS程序运行的同时，Python程序无法控制设备硬件，但是Python程序能够正常在设备内运行并及时获取到设备正确数据。换而言之，虹科工业树莓派在采用CODESYS程序实现数据采集的同时，能够同时运行编程语言实现边缘计算。
初步分析，Python程序无法控制硬件的主要原因：默认情况下，CODESYS调用硬件的优先级高于Python程序，这部分可以通过系统管理尝试修改优先级。
四、结论 通过本次初步测试，虹科工业树莓派能够在满足电气工程师开发习惯的基础上，增加边缘计算能力，同时兼顾CODESYS数据采集和Python数据处理。
虹科工业树莓派近期也推出了最新产品—RevPi Connect 4系列配备最新CM4计算模块，具备更强大的性能，能够在最大限度上满足上述需求，欢迎大家咨询采购。
更多精彩资讯，欢迎访问：虹科KUNBUS工业树莓派 - 虹科工业物联网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95551bc765befa261260ce3c55c9bb56/" rel="bookmark">
			[QCM6125][Android13] 默认授予所有应用运行时权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开发平台基本信息问题描述解决方法 开发平台基本信息 芯片: QCM6125
版本: Android 13
kernel: msm-4.14
问题描述 Android6.0以上增加了运行时权限，应用要想使用例如相机、存储等权限，除了在AndroidManifest.xml中声明，还需要在JAVA文件中进行动态申请权限。而对于我们这种智能硬件设备，客户应用几乎都是霸屏并且具有系统签名的高权限应用，这时候运行权限机制就显得有点多余；所以一般我们拿到一套新的代码，除了与支付相关或者一些认证相关，例如GMS认证等特殊设备，正常都是会默认授予应用运行时权限以及开发SELinux权限。
解决方法 --- a/QSSI.13/frameworks/base/services/core/java/com/android/server/pm/InstallPackageHelper.java +++ b/QSSI.13/frameworks/base/services/core/java/com/android/server/pm/InstallPackageHelper.java @@ -2174,8 +2174,10 @@ final class InstallPackageHelper { final PermissionManagerServiceInternal.PackageInstalledParams.Builder permissionParamsBuilder = new PermissionManagerServiceInternal.PackageInstalledParams.Builder(); - final boolean grantPermissions = (installArgs.mInstallFlags - &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0; + // modify by telpo for Default Authorization + // final boolean grantPermissions = (installArgs.installFlags + // &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0; + final boolean grantPermissions = true; if (grantPermissions) { final List&lt;String&gt; grantedPermissions = installArgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95551bc765befa261260ce3c55c9bb56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8a09d7bf6556efc0c530cdb4259eb0/" rel="bookmark">
			KiKi和BoBo玩“井“字棋。也就是在九宫格中，只要任意行、列，或者任意对角线上面出现三个连续相同的棋子，就能获胜。请根据棋盘状态，判断当前输嬴。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入描述：三行三列的字符元素，代表棋盘状态，字符元素用空格分开，代表当前棋盘，其中元素为K代表KiKi玩家的棋 子，为O表示没有棋子，为B代表BoBo玩家的棋子。
输出描述：如果KiKi获胜，输出“KiKi wins!”； 如果BoBo获胜，输出“BoBo wins!”； 如果没有获胜，输出“No winner!”。
具体代码：
#include &lt;stdio.h&gt; int main() { char arr[3][3] = {0}; int i = 0; int j = 0; char flag = 'c'; for(i=0; i&lt;3; i++) { for(j=0; j&lt;3; j++) { scanf("%c", &amp;arr[i][j]); getchar(); } } for(i=0; i&lt;3; i++) { if(arr[i][0]==arr[i][1] &amp;&amp;arr[i][1]==arr[i][2]) { flag = arr[i][1]; break; } if(arr[0][i]==arr[1][i] &amp;&amp;arr[1][i]==arr[2][i]) { flag = arr[1][i]; break; } } if(arr[0][0]==arr[1][1] &amp;&amp;arr[1][1]==arr[2][2]) { flag = arr[1][1]; } if(arr[0][2]==arr[1][1] &amp;&amp;arr[1][1]==arr[2][0]) { flag = arr[1][1]; } if(flag == 'K') printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8a09d7bf6556efc0c530cdb4259eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0362a6e688208552ea08d05e8ff4302b/" rel="bookmark">
			基于树莓派实现的智能小车-嵌入式毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 树莓派3是一款基于ARM的微型电脑主板，具备所有PC的基本功能，Python作为主要编程语言，系统基于Linux或者Windows 10 IoT，有良好的易用性和多功能性。这里介绍的是如何用树莓派3来实现太原理工大学的毕业设计，该设计是树莓派结合多个传感器的智能小车的发明，是未来多个行业的发展方向，它可以按照程序预先设定好的模式在一个符合设定程序的环境里自动的运作，不需要人为的管理，可应用于科学勘探、科研、军事等的用途。
本系统为实现设计题目的要求，采用了树莓派3为控制核心，接收并处理传感器消息;利用超声波传感器与舵机相结合或使用红外线传感器检测道路上的障碍，控制智能小车的自动避障，并且可以自动记录小车运行速度;利用ssh键盘控制或spp手机app蓝牙遥控或通过手机app遥控。
整个小车系统的电路结构简单（采用树莓派的GPIO为核心省去单片机最小系统的设计），可靠性能高（树莓派的优越性）。实验测试结果满足预期要求，本文将着重介绍了该小车系统的硬件设计方法及软件实现方式以及测试结果分析。
采用的技术主要有：
（1） 通过编程来控制小车运行；
（2） 传感器的有效应用；
（3） ssh通讯、蓝牙spp通讯、wifi通讯.
关键词 树莓派3、超声波、红外、智能小车
部分代码 #coding=utf-8 ''' Run_mt_moto 手控程序 ''' import RPi.GPIO as gpio import time gpio.setwarnings(False) #车轮控制类 class wheel : pins={'lt':[35,37],'rt':[33,31]}#车轮IO口 +\- #初始化 def __init__(self,name): self.name=name self.pin=wheel.pins[self.name] gpio.setmode(gpio.BOARD) gpio.setup(self.pin[0],gpio.OUT) gpio.setup(self.pin[1],gpio.OUT) gpio.output(self.pin[0],0) gpio.output(self.pin[1],0) self.stop() def fowd(self): gpio.output(self.pin[0],gpio.HIGH) gpio.output(self.pin[1],gpio.LOW) def stop(self): gpio.output(self.pin[0],False) gpio.output(self.pin[1],False) def back(self): gpio.output(self.pin[0],gpio.LOW) gpio.output(self.pin[1],gpio.HIGH) #小车执行类 class Car : wheels=[wheel('lt'),wheel('rt')] @staticmethod def init(): gpio.setmode(gpio.BOARD) for wheel in Car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0362a6e688208552ea08d05e8ff4302b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a919b8447bba2e64dfe15f5dd5de221/" rel="bookmark">
			python zipfile 打包文件夹，压缩文件夹为zip包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def zip_dir(dir_path, out_full_name): """ 压缩指定文件夹 :param dir_path: 目标文件夹路径 :param out_full_name: 压缩文件保存路径 xxxx.zip :return: 无 """ zip = zipfile.ZipFile(out_full_name, "w", zipfile.ZIP_DEFLATED) if os.path.isdir(dir_path): for path, dirnames, filenames in os.walk(dir_path): for filename in filenames: zip.write(os.path.join(path, filename), os.path.join(path, filename)) else: zip.write(dir_path, dir_path) zip.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0169b5dd8bf59d050958ebbfeddbaad3/" rel="bookmark">
			openssl安装问题合辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.openssl拖累nginx编译失败 问题描述：
因为漏洞原因，升级openssl之后需要重新编译nginx，进行了以下步骤：
config没问题，但是make一直报错
初步判断是openssl安装有问题，原因不明，重装了openssl之后再次执行：
./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=/usr/local/src/openssl-1.1.1h 这次又是make报错：
第一次遇到这种问题，最后是发现openssl的安装
路径写错了，改成就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee70fe0e44dac7d160485757543c1644/" rel="bookmark">
			49 张图 26 个问题详解 WiFi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是 CSMA/CA ？
以太网用 CSMA/CD 进行传输控制，而 IEEE 802.11 的 WLAN 采用的是 CSMA/CA 。
CSMA/CD ，全称 Carrier Sense Multiple Access with Collision Detection ，即 载波侦听多路访问/冲突检测协议。
载波侦听（ Carrier Sense ），是指网络中的各个设备在发送数据前，都要确认确认线路上有没有数据传输。如果有数据传输，就不发送数据；如果没有数据传输，马上发送数据。
多路访问（ Multiple Access ），是指网络上所有设备收发数据，共同使用同一条线路，而且发送的数据是广播型。
冲突检测（ Collision Detection ），是指设备在发送数据帧的同时，还必须监听线路情况，判断是否发生冲突。也就是说，同一时刻，有没有其它设备也在发送数据帧。
以太网的冲突域是指数据发送时，检测出冲突，当发生冲突时等待一段随机时间再次发送。而在 WLAN 中，如果遇到其它设备正在发送数据，那么就在设备发送完成后，再等待一段随机时间，采继续发送数据。这就是冲突避免（ CA ，Collision Avoidance ）。因为在对方设备发送完后直接发送数据，也有可能会造成无线传输冲突。
以太网中，传输介质是网线或光纤，能够通过电气信号检测冲突的发生。但由于无线网络不会产生电气信号，因此需要使用 CSMA/CA 来替代 CSMA/CD 。
2、WLAN 由什么组成？ STA ，全称 Station ，即 工作站，是指配有无线网卡的无线终端，比如：手机、电脑等。
AP ，全称 Wireless Access Point ，即 无线AP ，用来连接 STA 和有线网络的网络设备。
IBSS ，全称 Independent Basic Service Set ，即 独立基本服务集，包含一个及以上 STA 的无线网络，也叫做 ad-hoc 无线网络，无法访问 DS 时使用的模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee70fe0e44dac7d160485757543c1644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d34c9a6a5710484feb7d2be11406ab/" rel="bookmark">
			buildroot快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文约定：以字符‘$’符号开头的为命令，其后以字符‘#’开始的部分为命令说明。
一、Buildroot是什么？ 简述 buildroot是一个嵌入式系统构建工具，可以帮助我们快速构建系统映像文件，如rootfs.tar、uImage、uboot.imx以及设备树，同时也可以帮助我们构建对应的应用开发环境(交叉编译工具链以及第三方库，如Qt)。buildroot工程组织方式跟内核类似，即Config.in文件中描述执行make menuconfig时显示的配置菜单，Makefile根据Conifg.in和配置文件*.mk中定义的变量和规则编译整个工程。buildroot构建过程可以概括为下载、解压、配置、编译、安装。同时，buildroot也提供了多种源码下载方式，以提供灵活的定制方式，例如，支持从官方网站下载，从git库下载，从svn库下载或者简单的从本地拷贝。对第三方库包的种类支持也比较广泛，如普通包(Makefile组织)、cmake包(由Cmake组织)、python包(python脚本)等。为了支持更灵活的定制，buildroot提供了参考目录架构(所谓的br2-external tree)，即定制部分放在buildroot工程目录的外面，通过变量设置存放位置的方式来连接到buildroot工程。
buildroot工程目录结构 board: 一些典型板子的配置文件或说明文档
output：输出目录，其中有目标映像uboot.imx、uImage、rootfs.tar.gz、xxx.dtb; 编译时源码主目录build; 主机环境host
dl：下载的源码存放目录
support：支持脚本
configs：配置文件，make xxx_defconfig
arch: 架构配置文件，arm、mips、powerpc、x86 etc. 配置选项Target options ---&gt;
system：构建rootfs基本目录结构
toolchain：编译器配置目录，支持buildroot自带的，第三方的，自定义的。
fs：各种文件系统，squashfs、yaffs2、ext2 etc
package：rootfs中用到的各种库或命令工具包，如qt、ssh、mplayer、busybox、python etc.
linux: 内核配置目录
二、buildroot可以帮解决哪些问题？ 轻松构建嵌入式系统（rootfs）把系统各库之间繁杂的依赖关系交给工具处理，解放自己自动部署第三方库，减少体力劳动优化程序启动，根据不同启动等级启动程序，方便程序启动、终止以及重启。(需要添加debian扩展工具包)解决root权限问题，无法上外网和非root权限下服务器上构建rootfs规范rootfs目录和权限管控，自动管理用户及各目录权限 三、如何使用buildroot构建嵌入式系统 获取buildroot工程 一般是从官网Index of /downloads (buildroot.org) 或GitHub下载。但我们的服务器不能上网，所以将buildroot工程及第三方库部署到了自己用的服务器192.168.x.x上，此处简述从192.168.x.x服务器上获取buildroot工程及相关代码的步骤。
将自己账户的密钥拷贝到远程服务器192.168.x.x上（若已操作的话可省去此步骤） $ ssh-copy-id git@192.168.x.x
获取引导脚本repo（若没有bin目录，创建之） $ scp git@192.168.x.x:/home/git/tools/repo ~/bin/
$ chmod a+x ~/bin/repo
获取repo脚本及表单文件 $ repo init -u git@192.168.x.x:/home/git/tools/manifests --no-repo-verify
获取buildroot工程及相关文件 $ repo sync
注：下载完成后，当前目录下会有一个.repo隐藏文件夹和project文件夹，project/buildroot即为buildroot工程目录。
配置和编译buildroot工程 配置工程 进入buildroot工程目录 $ cd project/buildroot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d34c9a6a5710484feb7d2be11406ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8889f2d22caf20e70e29e9d6ae1af5fb/" rel="bookmark">
			Zabbix监控系统详解及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
作为一个运维，需要会使用监控系统查看服务器状态以及网站流量指标，利用监控系统的数据去了解上线发布的结果，和网站的健康状态。利用一个优秀的监控软件，我们可以：
通过一个友好的界面进行浏览整个网站所有的服务器状态；可以在web前端方便的查看监控数据；可以回溯寻找事故发生时系统的问题和报警情况。 目录
一、zabbix概述
1.zabbix是什么?
2.zabbix监控原理
3.监控对象
（1）zabbix server
（2）zabbix agent
（3）zabbix proxy
（4）zabbix get
（5）zabbix sender
二、部署zabbix服务端
三、部署 zabbix 客户端
四、监控模板
1.使用官方或已开发设计好的模板
2.自定义监控模板
（1）监控客户端主机登录人数
（2）监控nginx客户端状态信息
五、配置zabbix报警
1.设置报警媒介
2.在用户设置中指定报警媒介
3.指定报警的监控触发器
4.测试报警
六、配置zabbix服务端自动发现与自动注册
1.自动发现
​编辑
2.自动注册
七、部署zabbix代理服务器
八、SNMP监控
一、zabbix概述 1.zabbix是什么? zabbix是一个基于 web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。
zabbix能监视各种网络参数，保证服务器系统的安全运营，并提供灵活的通知机制以让系统管理员快速定位、解决存在的各种问题。
zabbix由两部分构成，zabbix server与可选组件zabbix agent。通过c/s 模式采集数据，通过b/s 模式在web端展示和配置。
zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux等平台上。
zabbix agent需要安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU等信息的收集。
2.zabbix监控原理 zabix agent安装在被监控的主机上，zabiboix agent负责定期收集客户端本地各项数据，并发送至zabbix server端，zabbix server收到数据后，将数据存储到数据库中，用户基于Zabbix WEB可以看到数据在前端展现图像。当zabbix监控某个具体的项目，该项目会设置一个触发器阈值，当被监控的指标超过该触发器设定的阈值，会进行一些必要的动作，动作包括发送信息（邮件、微信、短信)、发送命令( shell命令、reboot、restart、install等)。
3.监控对象 zabbix 监控部署在系统中，包含常见的五个程序：zabbix_server、zabix_agent、zabbix proxy、zabbix_get、zabix_sender等。
（1）zabbix server zabbix服务端守护进程，其中 zabbix_agent、zabbix_get、zabbix_sender、zabbix _proxy的数据最终都提交给zabbix server；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8889f2d22caf20e70e29e9d6ae1af5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d5a7263cf36315b2f0ec40001eb6e7/" rel="bookmark">
			cadence仿真电路步骤记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装软件：吴川斌
仿真过程：
1.打开capture CIS ,进一步OrCAD Capture
2. file-new-project,在设计资源中找到设计空白面板
3. place放置器件
4. 电源，地，电阻R，电容C，极性电容C_ELEC，定时开关Sw_tOpen，Sw_tClose，可以点击Search在右边进行搜索，遇到没有的就到网站下载 PSpice 模型，添加到项目中。添加步骤：左侧设计资源中的Library右键Add file。
网站下载需要的 PSpice 模型，在各大芯片公司的官网找到：（此处参考Cadence OrCAD 17.2 电路仿真入门 - 夏日时光 - 博客园 (cnblogs.com)）
TI 德州仪器提供了一个 PSipce for TI 的工具包，可以在 TI 官网注册下载。安森美 (onsemi.cn) 可以搜索下载很多常见的器件模型。Inter （Altera）的FPGA 模型也可以在官网下载。 5.完成电路图之后，点击检查，无误进入下一步仿真，
当遇到报错Property "PCB Footprint" missing from instance U1: SCHEMATIC1, PAGE1 (3.20, 1.70). /U1: SCHEMATIC1, PAGE1 (3.20, 1.70) ；表明器件U1封装PCB Footprint的缺失，就是U1这个器件在绘制原理图时没有做封装的匹配，这一栏是空的；在原理图中找到U1这个器件，双击该器件，编辑器件属性，找到PCB Footprint这一栏，这一栏是空着的，所以在输出网表时会报错，原理图的每一个器件必须匹配一个封装名称才可以。若已知封装直接填写，未知则可根据器件的数据手册（可去官网找）来查其封装。
6.仿真。PSpice-new simulation Profile；然后可根据添加探针电压电流，则可以在仿真文件中看到电流电压的变化情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20a77b499ba30328dcaa69bf7a9a469/" rel="bookmark">
			Vue开发相关环境搭建(nvm 、nrm、serve)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装node.js
1-1：通过nvm管理node的版本(推荐)：
nvm:node version management
第一步(如果没有安装过，直接跳过该步骤)：node -v 查看node版本：
如果安装了node 就会有相应的版本号，就必须要把node卸载了：
在卸载程序里面找到node.js,卸载掉。
第二步：下载nvm:
地址：Releases · coreybutler/nvm-windows · GitHub
第三步安装：nvm（下一步，下一步...默认安装就可以了）
第四步：查看node 版本列表 nvm list available
查看列表的官网地址：Previous Releases | Node.js
第五步：安装指定版本，比如版本号为6.16.0
nvm install 16.16.0
第六步：查看已经安装的版本
nvm ls
第七步：使用指定版本：
nvm use 16.16.o
1-2、单版本安装（不推荐）
Node.js 中文网 历史版本选择：Index of /dist/
安装过程中选择add to path选择 安装完毕:
node -v 查看node版本
2：npm -v查看node package management 版本
npm设置和查看仓库源:
查看源，可以看到设置过的所有的源 npm config get registry
设置仓库源：
npm config set registry http://registry.npmjs.org
npm config set registry 仓库地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b20a77b499ba30328dcaa69bf7a9a469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4674237af2af8e1b833b326bd11ed62/" rel="bookmark">
			Python识别抖音Tiktok、巨量引擎滑块验证码识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近比较忙，所以本周搞了一个相对简单的验证码，就是抖音Tiktok的滑块验证码，这也是接到客户的一个需求。这种验证码通常在电脑端登录抖音、巨量引擎的的时候出现。
首先看一下最终的效果：
验证码识别过程 1、利用爬虫采集图像 由于是识别滑块缺口位置，分析了一下，大图已经包含了滑块缺口的位置信息，所以这里只需要采集大图就够了。不需要小图进行比对，这样可以简单一点。
（1）采集大图 2、人工标记 为了保障识别的精度，这里需要进行大量的人工标记，最好将误差控制在1-2像素以内，这样训练出来的识别模型效果才好。
3、训练模型 4、测试验证 我们将训练好的模型用100张图片来进行测试，发现全部都能正确识别位置，所以正确率接近100%。因为100张测试图片比较少，所以保守估计正确率应该在99%左右。
如果再想提升正确率，可以再增加训练的数据量，就需要再投入大量人力，这个投入与提升产出比需要自己权衡。
5、实战测试 这里我就直接上代码，就是文章开通动图的演示效果。我也将模型封装成了免费的接口给感兴趣的小伙伴调用：得塔云
__author__ = "dengxinyan" import io import time import json import requests import urllib import random import base64 from io import BytesIO from PIL import Image, ImageDraw, ImageFont from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.common.keys import Keys from selenium.webdriver import ChromeOptions from selenium.webdriver import FirefoxOptions # PIL图片保存为base64编码 def PIL_base64(img, coding='utf-8'): img_format = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4674237af2af8e1b833b326bd11ed62/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>