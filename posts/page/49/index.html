<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c8ab2edf4fc12d424f7356cd485094/" rel="bookmark">
			【论文笔记】On the Principles of Parismony and Self-Consistency for the Emergence of Intelligence
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Motivation 智能体为在复杂环境中生存和工作，不得不高效和有效地（efficiently and effectively） 学习反映历史经验和当前所感知的环境模型；模型是收集信息、做出决策和采取行动的关键。
“Studies in neuroscience suggest that the brain’s world model
is highly structured anatomically (e.g., modular brain
areas and columnar organization) and functionally (e.g.,
sparse coding (Olshausen and Field, 1996) and subspace
coding (Chang and Tsao, 2017; Bao et al., 2020)).”
What to learn and how to learn.
Convolutional Sparse Coding x = A ( z ) = Σ c = 1 C ( α 1 c z c , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21c8ab2edf4fc12d424f7356cd485094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e8987640da6a45ed40445187477f2f/" rel="bookmark">
			MySQL 查询语句大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基础查询
直接查询
AS起别名
去重（复）查询
条件查询
算术运算符查询
逻辑运算符查询
正则表达式查询⭐
模糊查询
范围查询
是否非空判断查询
排序查询
限制查询（分页查询）
随机查询
分组查询
HAVING
高级查询
子查询（嵌套查询）
排号
排名
聚合函数
连接查询
内连接
外连接
全外连接（组合）
​编辑
交叉连接
SELECT子句必须遵循的顺序
基础查询 直接查询 查询所有列
语法：select * from 表名； -- 查询 student 表中所有内容 select * from student; 查询指定列
语法：select 字段 from 表名； -- 查询 student 表中的name列 与 age列 select name, age from student; AS起别名 使用 AS 给字段起别名
语法：select 字段 as 别名 from 表名；(as可省略) -- 查询 student 表中的name列 与 age列 select name 名字, age 年龄 from student; -- select name as 名字, age as 年龄 from student; 使用 AS 给表起别名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e8987640da6a45ed40445187477f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f98758ef55b34f18bc5ae2b4c3a20a3/" rel="bookmark">
			MySQL 表约束超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 主键约束——PRIMARY KEY
1.在建表时设置主键约束
设置单字段主键
设置联合主键
2. 在修改表的时候添加主键约束
3. 删除主键约束
4. 【补充】 MySQL设置主键自增长 ：
二. 外键约束——FOREIGN KEY
1.在创建表时设置外键约束
2. 在修改表时添加外键约束
3. 删除外键约束
三. 唯一约束——UNIQUE KEY
1.在创建表时设置唯一约束
2. 在修改表时添加唯一约束
3. 删除唯一约束
四. 检查约束——CHECK
1.在创建表时设置检查约束
2. 在修改表时添加检查约束
3. 删除检查约束
五. 非空约束——NOT NULL
1.在创建表时设置非空约束
2. 在修改表时添加非空约束：
3. 删除非空约束
六. 默认值约束——DEFAULT
1.在创建表时设置默认值约束
2. 在修改表时添加默认值约束
3. 删除默认值
在MySQL里，“约束”指的是对表中数据的一种限制约束，它能够确保数据库中数据的准确性和有效性
比如有的数据是必填项，就像身份认证的时候，或者填注册信息的时候，手机号身份证这种就不能空着，所以就有了非空约束；又有的数据比如用户的唯一id，不能跟其他人的一样，所以就需要使用唯一约束等等。
在MySQL中主要有6种约束：主键约束、外键约束、唯一约束、检查约束、非空约束和默认值约束。
一. 主键约束——PRIMARY KEY “主键约束“是6种约束中使用最多的约束。
在建立数据表的时候，一般情况下，为了方便更快地查找表中的记录，都会要求在表中设置一个“主键”。”主键“是表里面的一个特殊字段，这个字段能够唯一标识该表中的每条信息。
主键分为“单字段主键”和“多字段联合主键”，并且在使用主键的时候需要注意以下几个点：
一个表只能定义一个主键；主键值必须唯一标识表中的每一行，并且不能出现null的情况，即表中不能存在有相同主键的两行或两行以上数据，严格遵守唯一性原则；一个字段名只能在联合主键字段表中出现一次；联合主键不能包含不必要的多余字段，以满足最小化原则。 1.在建表时设置主键约束 设置单字段主键 1）在定义字段的时候设置主键约束，语法格式：
&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值] 例：在数据库中创建学生信息数据表st_info，主键为st_id, SQL语句以及运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f98758ef55b34f18bc5ae2b4c3a20a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe126dd65cc2e918d2c65f62c9aa0ffc/" rel="bookmark">
			MySQL alter命令修改表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ALTER TABLE 语法
ALTER TABLE 实例
添加一列
添加多列
重命名列
修改列定义
修改列名和定义
添加主键
删除列
重命名表
修改表的存储引擎
结论
在使用表的过程中，如果您需要对表进行修改，您可以使用 ALTER TABLE 语句。通过 ALTER TABLE 语句，您可以重命名表、重命名列、添加列、删除列、修改列的属性等。
ALTER TABLE 语法 ALTER TABLE table_name [alter_action options], ... 其中 alter_action 是一个修改动作，包括
ADD 关键字可用来添加列、索引、约束等，包括：
ADD [COLUMN]: 添加列ADD INDEX: 添加索引ADD PRIMARY KEY: 添加主键ADD FOREIGN KEY: 添加外键ADD UNIQUE INDEX: 添加唯一索引ADD CHECK: 添加检查约束 DROP 关键字可用来删除列、索引、约束等，包括：
DROP [COLUMN] col_name: 删除列ADD INDEX index_name: 删除索引DROP PRIMARY KEY: 删除主键DROP FOREIGN KEY fk_symbol: 删除外键DROP CHECK symbol: 删除检查约束 MODIFY 关键字用来修改列的定义。与 CHANGE 关键字不同，它不能重命名列。例如: MODIFY [COLUMN] col_name column_definition。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe126dd65cc2e918d2c65f62c9aa0ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/228207f28a6fcd507047c416ab7b34ce/" rel="bookmark">
			Linux开发工具-vim-gcc-gdb指令及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
linux软件包管理器yum（apt）
linux开发工具
linux编辑器-vim使用
linux编译器-gcc/g++使用
linux调试器-gdb使用
linux项目自动化构建工具-make/makefile
linux第一个小程序-进度条
使用github创建项目
使用git命令
我们前面学了关于linux的基本指令和基本权限的一些相关知识，那么我们今天就讲一下关于linux使用的一些工具还有一些小的知识点，后面会看情况补充一些前面讲的浅的或者讲的不太好的知识点。那么现在我们开始吧！
linux软件包管理器yum（apt） 什么是软件包
在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.
但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安 装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.
软件包和软件包管理器, 就好比 我们手机里的"App" 和 "应用商店" 这样的关系.大量的应用放在远端服务器里面，然后我们通过软件商店这个端口去访问我们需要的软件，最后下载下来的这样一个过程。
yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器. 主要应用在Fedora, RedHat, Centos等发行版上.
就好比我们的手机，如果我们要下载软件的话，比如说12306，我们是不是就会去手机自带的软件商城或者说应用商店去下载啊？linux就好比我们的手机，yum就好比软件商店，然后我们通过搜索12306（软件名）找到对应的软件下载，我的平台命令是apt（get），大部分平台是yum。
我是装了一个tree，树状显示目录的指令，有些服务器是已经装好了的。
apt remove tree 卸载软件包
这里的话为了我们更好的学习融入，我把服务器的系统重装了一下，之前是ubuntu的版本，现在装了centos7.6，所以接下来的话我会把yum的指令也写一下，方便我们去学习
这里我们选y，tree指令就会被卸载
这个时候我们再卸载的话，系统就会提示找不到这个指令的包了。
我们在远程下载软件包的时候，要确保网络畅通，这样我们的包才能下载成功
ping www.baidu.com
这个指令可以查看，一般像下面这样就没问题
ctrl+c可以退出这个操作，不然我们的这条信息就会一直打印
关于 rzsz 这个工具用于 windows 机器和远端的 Linux 机器通过 XShell 传输文件. 安装完毕之后可以通过拖拽的方式将文件上传过去. yum install rzsz
这个工具的话也不怎么用，因为我们一般很少这样传文件，速度也挺慢的。
查看软件包 通过 yum list 命令可以罗列出当前一共有哪些软件包. 由于包的数目可能非常之多, 这里我们需要使用 grep 命令只 筛选出我们关注的包.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/228207f28a6fcd507047c416ab7b34ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f27e7ab953e6f1b6c4257e4dfe59e9/" rel="bookmark">
			VUE3&#43;X6流程图实现数据双向绑定的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码很简单，看看就可以了，不用多说。
定义组件：实现html节点与数据初始化、更新
&lt;script setup lang="ts"&gt; import { Graph, Shape } from "@antv/x6"; import { onMounted, reactive, ref, watch } from "vue"; import useFlowModel from "./useFlowModel"; import flowdata from "./flowdata"; const container: any = ref(null); Shape.HTML.register({ shape: "custom-html", effect: ["data"], html(cell: any) { const { bgcolor, label } = cell.getData(); return `&lt;div style="background:${bgcolor};width:100%;height:100%;"&gt;${label}&lt;/div&gt;`; }, }); const flowModel: any = reactive({ graph: null, datatype: 0, modeldata: flowdata, }); const { graphToModelData, modelDataToGraph, addNode, addNodeData } = useFlowModel(flowModel); onMounted(() =&gt; { flowModel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f27e7ab953e6f1b6c4257e4dfe59e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a369ec2a25daa61993ac35e487b127/" rel="bookmark">
			Java 实现文件复制及文件夹复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，有多种方法可以实现文件的复制。以下是几种常用的方式：
使用字节流进行复制：
通过FileInputStream和FileOutputStream分别创建源文件和目标文件的输入输出流，然后通过循环读取源文件内容，并将数据写入目标文件中进行复制。
可以使用字节数组作为缓冲区，提高复制效率。
需要手动处理流的打开、关闭和异常处理。
import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class ByteStreamCopyExample { public static void main(String[] args) { String sourceFilePath = "source.txt"; String destinationFilePath = "destination.txt"; try (FileInputStream fis = new FileInputStream(sourceFilePath); FileOutputStream fos = new FileOutputStream(destinationFilePath)) { byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { fos.write(buffer, 0, bytesRead); } System.out.println("文件复制成功！"); } catch (IOException e) { e.printStackTrace(); } } } 使用字符流进行复制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a369ec2a25daa61993ac35e487b127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c7b3b289c3b3f7ffc2044638060fea/" rel="bookmark">
			书籍强烈推荐：“计算机界三大神书”之一 ——SICP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 书籍推荐2. 粉丝福利3. 自主购买 1. 书籍推荐 《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs，简记为 SICP）是MIT的基础课教材，出版后引起计算机教育界的广泛关注，对推动全世界大学计算机科学技术教育的发展和成熟产生了很大影响。这本书的第1版于1984年出版，第2版于1996年出版，至今已被全世界100多所大学采用为教材，其中包括斯坦福大学、普林斯顿大学、牛津大学等。
书号：9787111630548
出版时间：2019-07-01
机械工业出版社把SICP（第2版）引进中国，于2004年出版，至今已近20年了。令人感兴趣的是，SICP至今仍然受到国内关心计算机科学技术的人们，特别是计算机专业的优秀学生和青年计算机工作者的关注。
与许多计算机科学领域的入门教材不同，SICP的最主要关注点并不在基础语言中各种编程结构的形式和意义，也没有深入讨论巧妙或深刻的算法。与众不同地，一方面，SICP注目于帮助读者理解基于计算的观点看世界、看问题的重要性，掌握相关的基本概念和观点，建立基于计算思考问题的习惯，也就是今天人们常说的计算思维。另一方面，SICP也深入讨论了通过计算的方式处理和解决问题时必须掌握的主要技术与方法，最重要的就是分解问题和组织计算，以及建立和使用抽象的各种技术与方法。
SICP的章节目录清晰地反映了作者的基本想法：
第1、2两章分别讨论函数（或过程）抽象和数据抽象的作用，它们的建立和使用；
第3章讨论抽象数据对象本身的状态和变化，相关的模块化的问题及其在计算实践中的重要性；
第4章讨论元语言抽象，也就是设计和实现面向应用的新语言的问题；
第5章可以看作前面讨论的应用，而应用的对象问题就是JavaScript语言在寄存器机器上的实现。这里的寄存器机器是现代计算机的抽象模型，这里的讨论也说明了抽象的高级语言如何落地。
读者现在拿在手里的这本书是SICP的一个改编本**（SCIP JS）。与SICP的不同之处，就在于这个改编本用更多计算机工作者熟悉的JavaScript语言作为讨论的工具**，而没有用原SICP里使用的Scheme语言。因此，这里程序实例的形式更接近各种常规的编程语言，可能更容易被更多读者接受。本书的内容是原SICP的翻版，作者编写本书的基本目标是尽可能完整准确地反映原书的宗旨和精神，同时又使这些能被更多的人理解和重视。
书号：9787111734635
出版时间：2024-02-01
由于本书的根源和作者的意图，本书的基本内容和结构都来自SICP，许多一般性的讨论直接来自原书，但也有许多地方针对JavaScript做了一些调整和修改。本书比较好地反映了SICP的思想，是一本非常好的学习计算机科学技术的读物，值得每一个关心计算机领域，并有心在这个领域中深入学习和努力工作的人士阅读学习。
正如作者所言，这本书并不想作为JavaScript的入门教科书。书中对JavaScript语言的介绍远非完整，读者不应该希冀通过阅读本书学习JavaScript编程。但另一方面，由于本书的宗旨和内容，对它的学习一定会有助于读者学习JavaScript（一般而言，学习任何常见的编程语言，如Java、Python或C）。如果读者学过JavaScript（或其他编程语言），阅读这本书能帮助你更好地理解程序设计和一般的软件开发，从而有可能在这些领域中做得更出色、更高效、更得心应手。如果本书是你学习计算机科学技术的第一本书（或者学的第一门课），这段学习经历能为你今后的学习建立一个坚实的基础，帮助你更顺利地度过这段专业学习。无论如何，认真地阅读这本书，都是一件非常值得做的事情。
对于本书的学习，必须和相应的实际编程、用计算机解决问题的实践相结合。只读不做，当然不可能真正领悟计算机科学技术的真谛。另一方面，只是抄录、运行和试验书中给出代码，也不能得到其中的真传。作为这本书的真正有心的读者，你必须亲自一次次地经历使用计算机（通过编程）解决问题的实践过程。本书的作者已经为读者提供了学习所需的许多材料和资源，希望读者好好利用。
2. 粉丝福利 本次送书两本活动时间：截止到2024-3-12 14:00参与方式：关注博主、并在此文章下面点赞、收藏并任意评论。 3. 自主购买 小伙伴也可以访问链接进行自主购买哦~
直达京东购买链接🔗：计算机程序的构造和解释（JavaScript版）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d66f211c0971edb07082064b4e75f0/" rel="bookmark">
			IntelliJ IDEA2021激活码（在校学生）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明：
仅适用于学生群体
一年激活权限
二、申请过程：
官方的申请网址点击Apply now按照流程一步步申请即可，没有校园个人邮箱的可以使用官方文件，然后上传学信网的成绩单或者学生证即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd28ca28fab8fb07a73a945b84e8125/" rel="bookmark">
			Vue.js&#43;SpringBoot开发海南旅游景点推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 用户端2.2 管理员端 三、系统展示四、核心代码4.1 随机景点推荐4.2 景点评价4.3 协同推荐算法4.4 网站登录4.5 查询景点美食 五、免责说明 一、摘要 1.1 项目介绍 基于Vue+SpringBoot+MySQL的海南旅游推荐系统，基于协同推荐算法，包括用户网页和管理后台，包含景点类型模块、旅游景点模块、行程推荐模块、美食推荐模块、景点排名模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，海南旅游推荐系统基于角色的访问控制，给景点管理员、游客使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 2.1 用户端 景点推荐：根据用户个性化偏好给用户推荐感兴趣的景点
【景点信息包含：景点名称、景点类型、评分、收藏量、门票价格、门票预订（提供购买链接，用户可以通过点击链接到其他平台购买门票）、开放时间、景区地址（所在市区、详细地址）、景点介绍】景点筛选：用户可通过设置自己想要的景点类型、景点门票价格范围、景区地址（海口市、三亚市、儋州市、三沙市等）来筛选满足自身需求的景点
筛选：【注：若用户只设置了一个筛选条件则只需满足一个筛选条件就推荐给用户，若设置两个以上，则需都满足才给用户推荐】旅游攻略：用户可以通过搜索景点名称来获取景点周边美食以及行程路线的相关信息
（1）交通指南：起点、终点、交通方式、行程路线
（2）周边美食：美食图片、名称、类型、简介、人均消费景点数据：景点数据可视化
（1）好评度排名：管理员可以看到好评度高的前十个景点【排名、景点名称、好评度】
（2）景点收藏量：管理员可以看到收藏量排名前十的景点【排名、景点名称、收藏量】个人中心:
（1）个人信息：账号、姓名、联系方式、身份证号（用户可以更新个人信息、退出登录）
（2）景点收藏：用户可以查看、取消收藏过的景点 2.2 管理员端 个人中心：管理员个人信息景点信息管理：
（1）查询：可通过搜索景点名称、地址、景点类型来获取需要的景点数据（搜索到需要的景点数据后可进行查看、修改、删除景点信息操作）
（2）添加：可以添加新的景点信息用户信息管理：
（1）查询：可通过搜索用户账号来查询需要的用户（查询到需要的用户后可对用户信息进行查看、修改、删除操作）
（2）添加：可添加新用户信息行程信息管理：
（1）查询：可通搜索景点地址来获取景点行程路线信息（查询到需要的行程信息后可对其进行查看、修改、删除操作）
（2）添加：可添加信息美食信息管理：
（1）查询：可通搜索景点地址来获取景点周边美食信息（查询到需要的信息后可对其进行查看、修改、删除操作）
（2）添加：可添加新的美食信息景点数据：景点数据可视化（同用户端的景点数据可视化）
（1）好评度排名：管理员可以看到好评度高的前十个景点【排名、景点名称、好评度】
（2）景点收藏量：管理员可以看到收藏量排名前十的景点【排名、景点名称、收藏量】 三、系统展示 四、核心代码 4.1 随机景点推荐 @RequestMapping(value = "/getRecommendList2OnWeb", method = RequestMethod.GET) @ApiOperation(value = "查询推荐的景点") public Result&lt;List&lt;ScenicSpot&gt;&gt; getRecommendList2(){ List&lt;ScenicSpot&gt; spotList = iScenicSpotService.list(); int[] arr = new int[spotList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd28ca28fab8fb07a73a945b84e8125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995779632dcc058b931682122fb65c0a/" rel="bookmark">
			Hugo之 Home-Info&#43;Profile Mode主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享Home-Info+Profile Mode
安装 安装 Hugo：安装 Hugo 需要利用一个包管理工具。对于 MacOS 系统 Hugo 可以直接用 Homebrew 来安装，打开终端输入 brew install hugo 安装 PaperMod：根据 PaperMod 的 官方文档 配置。 文件夹管理 archetypes：不用管
asset：自定义的 CSS 和 JavaScript
content：用于放博客内容
data：不用管
layouts：自定义的 HTML
public：项目导出文件 - 用于静态网页部署
static：存放图片
themes：主题 - PaperMod
进入 themes/PaperMod 则是 PaperMod 的相关代码，比较主要的目录有：
assets：PaperMod 的 CSS 和 JavaScript 代码layouts：PaperMod 的 HTML 自定义博文目录 content 里每个文件夹内都可以添加一个 _index.md 文件，该文件里面可以加 Front Matter 自定义（多语言）标题，如：
--- hidemeta: true title: 博客 --- 初始项目文件夹结构如下：
. ├── config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995779632dcc058b931682122fb65c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e41434e69073563e180e23f5b6761c3/" rel="bookmark">
			MOC3052SR2M/MOC3052M光电耦合器中文资料规格书PDF数据手册引脚图图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述:
MOC3051M、MOC3052M和MOC3053M由一个砷化镓红外发射二极管组成，该二极管与一个非过零硅双边交流开关（三端双向可逆向可控硅）进行光耦合。这些器件将低压逻辑隔离在 115V 电压下交流和 240 V交流为大电流三端双向可控硅或晶闸管提供随机相位控制的线路。这些器件具有大大增强的静态 dv/dt 能力，以确保感性负载的稳定开关性能。
产品特性：
出色的 IFT 稳定性—IR 发射二极管具有低衰减特性600 V 峰值阻断电压安全和监管批准UL1577,4,170 VACRMS 持续 1 分钟接线端子DIN EN/IEC60747-5-5 规格书参数：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bccaff8deadf8121154c4b4a204e554/" rel="bookmark">
			LM358ADR2G运算放大器芯片中文资料规格书产品文档PDF数据手册引图图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述：
此双路运算放大器使用适用于四路运算放大器的电路设计，具有低功率泄漏、扩展至接地/VEE 的共模输入电压范围以及单电源或分割电源运行。LM358 系列相当于 LM324 的一半。此类器件与单电源应用中的标准运算放大器类型相比，具有若干不同的优点。它们可以在低至 3.0 V 或高达 32 V 的电源电压下运行，且静态电流仅为 MC1741 的五分之一（基于放大器）。共模输入范围包括负电源，因此在很多应用中不必需要外部偏置部件。输出电压范围还包括负电源电压。
产品特点：
短路保护输出真差分输入级单电源供电：3.0 V至32 V低输入偏置电流内部补偿共模范围扩展至负电源单电源和双电源供电输入端的 ESD 箝位在不影响操作的情况下提高了器件的耐用性提供无铅封装 规格书参数：
引脚图：
元件尺寸封装图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83234adef705153a1fe9ef3650567f8e/" rel="bookmark">
			KONG - API转发流程梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kong简介 Kong 是一个开源的API网关，集成了服务注册和发现、负载均衡、健康检查等功能，还可以通过插件来提供限流、熔断、监控、日志等能力，
在kong的微服务架构中，kong担当了注册中心的角色，服务提供者(Provider)首先将服务信息注册到 kong，服务消费者(Consumer)调用服务的过程是调用端先将请求发到 kong，再通过 kong 把请求转发到服务提供者而实现间接调用。
本文通过梳理kong数据库中的字段关联关系，从而了解请求的转发流程。
kong服务定义 一个完整的kong服务由四部分实体构成：route，service，upstream和target。各自作用介绍如下：
route：记录了请求规则和服务service的对应关系；services：服务实体，是上游服务upstream的抽象；upstream：一个或多个target的集合，负责流量的转发；target：提供服务的最小单位，也是负载均衡的终端。 kong转发请求的整体流程可以概述为：当客户端发起一个请求时，routes通过提前注册的信息匹配出对应的service服务，根据service对应的upstream信息就可以找到最终处理请求的目标tartget，从而完成请求的处理。调用流程图示如下：
以下就客户端请求/api/tembin/atsani为例，结合kong数据库中的关联关系来具体说明请求的转发流程。
转发流程梳理 从 Route 到 Service routes routes路由匹配客户端的请求规则，匹配成功后分配到service层，以请求的方法、host、路径等作为转发依据。route与service是多对一的关系，所以可根据请求的路径可匹配出对应的service。
表结构
以下字段需要特殊注意：
字段值protocols允许访问该路由的协议（默认https\http都允许）paths匹配路由访问的路径service_id指向服务的id kong=# \d routes; Table "public.routes" Column | Type | Modifiers ----------------------------+--------------------------+-------------------- id | uuid | not null created_at | timestamp with time zone | updated_at | timestamp with time zone | name | text | service_id | uuid | protocols | text[] | methods | text[] | hosts | text[] | paths | text[] | snis | text[] | sources | jsonb[] | destinations | jsonb[] | regex_priority | bigint | strip_path | boolean | preserve_host | boolean | tags | text[] | https_redirect_status_code | integer | headers | jsonb | path_handling | text | default 'v0'::text Indexes: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83234adef705153a1fe9ef3650567f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fde97fcc11537d59733ccfd3ec3343f/" rel="bookmark">
			Linux 系统上卸载 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		停止 Docker 服务：
sudo systemctl stop docker 卸载 Docker 程序包：
不同的 Linux 发行版有不同的包管理工具，以下是一些常见的发行版的卸载命令：
对于使用 apt 的系统（如 Ubuntu、Debian）：sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin 对于使用 dnf 的系统（如 Fedora）：sudo dnf remove docker-ce docker-ce-cli containerd.io docker-compose-plugin 对于使用 yum 的系统（如 CentOS）：sudo yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin 对于使用 zypper 的系统（如 openSUSE）：sudo zypper remove docker docker-engine containerd docker-compose-plugin 请注意，上述命令中的包名称可能会根据您安装的 Docker 版本和发行版的具体情况有所不同。如果您不确定，请使用包管理工具的搜索功能来确定正确的包名。
删除 Docker 的依赖和配置文件：
如果您想要删除 Docker 的配置文件、数据和依赖项，可以使用以下命令：
对于使用 apt 的系统：sudo apt-get autoremove -y sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 对于使用 dnf 或 yum 的系统：sudo dnf autoremove -y # 或者 sudo yum autoremove -y sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 对于使用 zypper 的系统：sudo zypper rm -u docker sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 移除 Docker 的相关文件（可选）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fde97fcc11537d59733ccfd3ec3343f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad133591d6b07c0f93a8da1f813d55bd/" rel="bookmark">
			Spring MVC 简单文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.添加依赖 &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 2.配置文件上传解析器 &lt;!--配置文件上传解析器--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5242880" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;/bean&gt; 3.测试 编写controller
@Controller @RequestMapping("/account") public class AccountController { @RequestMapping(path="/upload") public String upload(HttpServletRequest request, MultipartFile upload,Model model) throws IOException { System.out.println("springmvc方式的文件上传"); //获取要上传的文件目录 String path = request.getSession().getServletContext().getRealPath("/uploads"); System.out.println("path:"+path); //根据文件上传的目录创建File对象，如果不存在则创建1个File对象 File file = new File(path); if(!file.exists()){ //创建一个file对象 file.mkdirs(); } //获取文件上传名称 String filename = upload.getOriginalFilename(); //完成文件上传 upload.transferTo(new File(path,filename)); model.addAttribute("msg", "欢迎你 springmvc"); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad133591d6b07c0f93a8da1f813d55bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ea0a25d2a45112245bcde548d01ece/" rel="bookmark">
			Linux - 反弹Shell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 Shell 估计大家都不陌生，简单来说，就是实现用户命令的接口，通过这个接口我们就能实现对计算机的控制，比如我们常见的 ssh 就是执行的 Shell 命令实现对远程对服务器的控制。
那反弹 Shell （ Reverse Shell）则是控制端首先监听某个 TCP/UDP 端口，然后被控制端向这个端口发起一个请求，同时将自己命令行的输入输出转移到控制端，从而控制端就可以输入命令来控制被控端了。
比如说，我们有两台主机 A、B，我们最终想实现在 A 上控制 B。那么如果用正向 Shell，其实就是在 A 上输入 B 的连接地址，比如通过 ssh 连接到 B，连接成功之后，我们就可以在 A 上通过命令控制 B 了。如果用反向 Shell，那就是在 A 上先开启一个监听端口，然后让 B 去连接 A 的这个端口，连接成功之后，A 这边就能通过命令控制 B了。
适用场景 通常情况下如果想用 ssh 等命令来实现 A 控制 B，首先得明确 B 的 sshd 地址或者端口，但是在很多情况下，由于防火墙、安全组、局域网、NAT 等原因，我们实际上是无法直接连接到 B 的，比如：
A 虽然有公网 IP，但 B 是一个处于内网的机器，A 就没法直接连到 B 上。B 上开了防火墙或者安全组限制，sshd 的服务端口 22 被封闭了。B 是一台拨号主机，其 IP 地址经常变动。假如 B 被攻击了，我们想让 B 向 A 汇报自己的状况，那自然就需要 B 主动去连接 A。 如果是这些情况，我们就可以用反弹 Shell 用 A 来控制 B 了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ea0a25d2a45112245bcde548d01ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745dc3e53eea123accb7fa6cdc3ac329/" rel="bookmark">
			spring boot(2.4.x 开始)和spring cloud项目中配置文件加载顺序 spring-cloud-starter-bootstrap Marker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的文章基础上
https://blog.csdn.net/zlpzlpzyd/article/details/136060312
spring boot 2.4.x 版本之前通过 ConfigFileApplicationListener 加载配置
https://github.com/spring-projects/spring-boot/blob/v2.3.12.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/package-info.java
从 spring boot 2.4.x 开始，ConfigFileApplicationListener 标记为已过期，监听替换为BootstrapConfigFileApplicationListener（继承了 ConfigFileApplicationListener 作为过渡），用 ConfigDataEnvironmentPostProcessor （EnvironmentPostProcessor 的实现类）代替用于加载配置，从这个版本开始 ConfigFileApplicationListener 在 spring.factories 文件中搜不到。
EnvironmentPostProcessor 的加载通过接口 EnvironmentPostProcessorsFactory 的实现类 ReflectionEnvironmentPostProcessorsFactory 来完成，在需要对应的 bean 时调用 EnvironmentPostProcessorsFactory#getEnvironmentPostProcessors() 通过反射功能来实现。
在此版本中专门重写了文件加载相关的功能。全部类位于如下 package。
https://github.com/spring-projects/spring-boot/blob/v2.4.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/package-info.java
子容器通过 BootstrapApplicationListener 加载 bootstrap 配置文件转换为 OriginTrackedMapPropertySource 类型
在父容器中转换为名为 springCloudDefaultProperties 的配置对象，将子容器中的配置添加到其中。
从 spring boot 2.4.0 到 2.4.2 之前的版本中有一个问题，同样的配置都在 yml 和 properties 中存在，则 yml 中的优先，实际验证正是如此。
但是从 spring boot 2.4.2 开始又改回了默认顺序。
官网文档建议使用配置的话最好使用一种，不要两种混用。
bootstrap 相关加载需要单独处理
https://github.com/spring-cloud/spring-cloud-commons/tree/v2.2.9.RELEASE/spring-cloud-context/src/main/java/org/springframework/cloud/util
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/745dc3e53eea123accb7fa6cdc3ac329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ddf4140fe77408a9f44999023f54cd/" rel="bookmark">
			【数据结构】矩阵的压缩存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的压缩存储 5.1 普通矩阵的存储 用二维数组存储
分为行优先和列优先：
行优先：优先存放一行的数据。
列优先：优先存放一列的数据。
注意下标是从0还是1开始的！ 5.2 对称矩阵的存储 对称矩阵定义
若n阶方阵中任意一个元素 a i , j a_{i,j} ai,j​都有 a i , j = a j , i a_{i,j}=a_{j,i} ai,j​=aj,i​。
压缩存储策略
只存储上或下三角区和主对角线。
例：按行优先将各元素存入一维数组中
数组大小应为多大？
1 + 2 + 3 + 4... + n = ( 1 + n ) ∗ n / 2 1+2+3+4...+n=(1+n)*n/2 1+2+3+4...+n=(1+n)∗n/2
如何把矩阵下标转化为一维数组下标？
因为矩阵对称，所以可以将上三角区域元素的i和j互换，就变成和下三角区域一样了 i ( i − 1 ) / 2 i(i-1)/2 i(i−1)/2是第i行前1~i-1行的所有元素数量；
j − 1 j-1 j−1是 a i , j a_{i,j} ai,j​元素在第i行的前的元素数量。如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ddf4140fe77408a9f44999023f54cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8821b6a7ccc8b41063dce8addccdae22/" rel="bookmark">
			ETCD分布式缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ETCD简介 ETCD是一个高度可用的分布式键值存储系统，主要用于共享配置和服务发现。它基于Go语言实现，内部使用Raft一致性算法处理日志复制，保证多节点数据的强一致性。
ETCD的目标是构建一个高可用的分布式键值数据库，用于存储配置信息和服务发现。在分布式系统中，各种服务配置信息的管理共享和服务发现是一个基本且重要的问题。ETCD可以集中管理这些配置信息，服务端将配置信息存储于ETCD，客户端通过ETCD获取服务配置信息。此外，ETCD还提供了监听机制，客户端可以监听某个key或某些key的变更，当配置信息发生改变时，ETCD会通知客户端。
ETCD的特性包括完全复制（集群中的每个节点都可以使用完整的存档）、高可用性（可用于避免硬件的单点故障或网络问题）、一致性（每次读取都会返回跨多主机的最新写入）、简单（有一个定义良好、面向用户的API）、安全（实现了带可选的客户端证书身份验证的自动化TLS）、快速（每秒10000次写入的基准速度）和可靠（使用Raft算法实现了存储的合理分布）。
二、ETCD节点的角色 Leader（领导者）：Leader节点在集群中有且仅能有一个，负责向所有的Follower节点同步日志数据。同时，Leader节点还负责处理客户端的写请求，并在与Follower节点之间定期发送心跳包以检测节点的存活状态。Follower（跟随者）：Follower节点从Leader节点获取日志，提供数据查询功能，并将所有修改请求转发给Leader节点。Follower节点在集群初始化时处于此状态，并等待Leader发送心跳。如果一定时间内未收到心跳，Follower会转变为Candidate状态并发起选举请求。Candidate（候选人）：当Leader节点不存在或失联时，Follower节点会转变为Candidate状态，开始新的Leader节点选举。Candidate节点会向其他节点发送选举请求，并等待其他节点的回复。如果收到包括自己在内超过半数节点的赞成，选举成功，该Candidate节点会成为新的Leader；否则，选举失败，Candidate节点会等待一段时间后再次发起选举或转为Follower状态。 三、ETCD选主 在ETCD集群中，节点（或称为成员）的数量对于其选主（leader election）过程和集群的可用性有着重要的影响。
ETCD集群的选主过程基于Raft一致性算法，该算法要求集群中至少有一半加一（N/2 + 1）的节点是可用的，以便能够达成共识并进行正常的操作。
假设你有一个由5个节点组成的ETCD集群，并且挂了3个节点，那么集群中剩余的节点数量是2。由于2小于5/2 + 1（即3），这意味着集群中的可用节点数量不足以进行正常的选主和达成共识。因此，在这种情况下，集群将无法选出新的主节点，并且可能会进入不可用状态。
为了恢复集群的正常功能，你需要修复或替换挂掉的节点，使集群中的可用节点数量至少达到3个。这样，集群才能重新进行选主并恢复服务。
总之，如果一个由5个节点组成的ETCD集群中挂了3个节点，那么集群将无法选出新的主节点，并且可能会变得不可用。为了解决这个问题，你需要确保集群中至少有3个节点是可用的。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/48/">«</a>
	<span class="pagination__item pagination__item--current">49/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/50/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>