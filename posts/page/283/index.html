<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913688a2b73581244eca6c801d552801/" rel="bookmark">
			diff 指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、diff的三种格式二、示例文件三、正常格式的diff四、上下文格式 --- diff -c五、合并格式 --- diff -u六、git格式的diff --- git diff “＋” 比较的文件的后者比前着多一行
“－” 比较的文件的后者比前着少一行
“！” 比较的文件两者有差别的行
-q 不报告差异，只说明两者内容是否有差异 -a 把所有文件看做文本文件进行比较。 -w	忽略所有空格和制表符，将所有其他空白字符串视为一致。例如，if ( a == b ) 与 if(a==b) 相等。 -I	忽略字母大小写。例如，小写 a 被认为同大写 A 一样。 -b 忽略行尾的空格，而字符串中的一个或多个空格符都视为相等。 -y	输出为两列对照模式 -b	忽略块中空白数目的改变 -B	忽略插入或删除空行造成的改变 -w 逐行比较时忽略空白 -c	上下文格式 -u	合并模式 -wa用的多
其次 -q -y -c -u看情况而使用
一、diff的三种格式 由于历史原因，diff有三种格式：
* 正常格式（normal diff）
* 上下文格式（context diff）
* 合并格式（unified diff）
二、示例文件 为了便于讲解，先新建两个示例文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913688a2b73581244eca6c801d552801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921f1a9829e2c48f6350f890026addc9/" rel="bookmark">
			711页的黄海广老师的《机器学习》课件合集.pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黄海广博士的机器学习课程登陆了中国大学慕课，在9月6日10点开课了，目前有5400多人报名了。
今天，为了方便读者学习，黄海广博士公布了课程的ppt全集，一共711页，并提供下载。
课件介绍 本课件是温州大学黄海广老师的机器学习课程的授课课件，授课视频在中国大学慕课：
https://www.icourse163.org/course/WZU-1464096179
这门课面向初学者，内容比较基础，适合入门。
课件资源公布在Github：
https://github.com/fengdu78/WZU-machine-learning-course
如果是大学教师，可以发邮件给黄海广老师索取原版课件。
（haiguang2000@wzu.edu.cn，请用edu邮箱发，告知姓名学校，仅用于教学目的，请勿用于商业用途）
建议可以根据ppt内容编排进行授课，建议授课课时：36课时。
水平有限，难免有小错误，若有更新，也可以发邮件给黄海广老师，也可以发邮件索取老师微信。
这个合集课件pdf还会更新，下载方式：
关注公众号，回复“课件pdf合集”可以获取下载地址。
授课目标 1、掌握机器学习的基本问题定义、基本模型，对机器学习学科有概览性的认识。
2、掌握目前主流的机器学习算法和模型，并能够根据实际问题的需要选择并实现相应的算法。
3、编程完成机器学习典型应用实例，对机器学习工程编程有初步的训练。
ppt目录 01 引言
1.1 机器学习概述
1.2 机器学习的类型
1.3 机器学习的背景知识
1.4 机器学习的开发流程
02 回归
2.1 线性回归
2.2 梯度下降
2.3 正则化
2.4 回归的评价指标
03 逻辑回归
3.1 分类问题
3.2 Sigmoid函数
3.3 逻辑回归求解
3.4 逻辑回归的代码实现
04 朴素贝叶斯
4.1 贝叶斯方法
4.2 朴素贝叶斯原理
4.3 朴素贝叶斯案例
4.4 朴素贝叶斯代码实现
05 机器学习实践
5.1 数据集划分
5.2 评价指标
5.3 正则化、偏差和方差
06 KNN算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921f1a9829e2c48f6350f890026addc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500a2c59d786c0e6978e41d433202d3b/" rel="bookmark">
			Python计算样本熵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Python计算样本熵样本熵算法代码 Python计算样本熵 样本熵算法 来自 算法原理（2）：样本熵（SampEn） - 程序员大本营 (pianshen.com)
代码 import pandas as pd import numpy as np def sampEn(L:np.array, std : float ,m: int= 2, r: float = 0.15): """ 计算时间序列的样本熵 Input: L: 时间序列 std: 原始序列的标准差 m: 1或2 r: 阈值 Output: SampEn """ N = len(L) B = 0.0 A = 0.0 # Split time series and save all templates of length m xmi = np.array([L[i:i+m] for i in range(N-m)]) xmj = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/500a2c59d786c0e6978e41d433202d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaeb829614dbe5619ac2234c96834cd6/" rel="bookmark">
			Kotlin学习笔记29（完结篇） Flow part2 Flow的Buffer 中间操作符zip 打平 异常处理 Flow的完成 onCompletion的优势 onCompletion陷阱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 示例来自bilibili Kotlin语言深入解析 张龙老师的视频
1 Buffer 缓冲 /** * Buffer 缓冲 * 这里没有使用缓冲 */ private fun myMethod(): Flow&lt;Int&gt; = flow { for (i in 1..4) { delay(100) emit(i) } } fun main() = runBlocking { val time = measureTimeMillis { myMethod().collect { value -&gt; delay(200) println(value) } } println(time) } /* 很明显 这里运行至少要（100+200）*4ms */ class HelloKotlin16 { } /** * Buffer 缓冲 注意对比Kotlin16 * * buffer的主要作用是对发射的缓冲 减少发射部分的等待时间 * * buffer与flowOn之间有一定的关系： * 实际上，flowOn运算符本质上在遇到需要改变CoroutineDispatcher时 同样也会使用缓存机制 * 所以有时候flowOn可以理解为复杂版的buffer */ private fun myMethod(): Flow&lt;Int&gt; = flow { for (i in 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaeb829614dbe5619ac2234c96834cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8713eb237c2eade67a8a658c444e3e3/" rel="bookmark">
			JAVA 简单的getJSONObject、getJSONArray用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{
"msg": "success",
"code": 0,
"page": { -------------getJSONObject("page") "totalCount": 108,
"pageSize": 10,
"totalPage": 11,
"currPage": 1,
"list": [ ------------------- getJSONArray("list").getJSONObject(0)
{
"ehrLabourEmployApplyEntity": null, "ehrOutEmployApplyEntity": { -------------getJSONObject("ehrOutEmployApplyEntity") "id": 530,
"applyName": "",
"nameZH": null,
"applyHrId": "" -------------- getString("applyHrId")
},
"ehrWfStaffQuitEntity": null,
"processType": null,
"hrId": null,
}
]
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01742206f55c372682db4a3fd6dc73aa/" rel="bookmark">
			python奇数和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-100
任意数字奇数和
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf7a4e5314ed672c11ce7e1af6c2955/" rel="bookmark">
			树莓派Buster系统编译安装opencv(一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作任务：在树莓派上搭opencv环境实现条形码的实时识别
树莓派：Zero W
内存卡：32G
其他：HDIM线，显示器，键盘，鼠标，外接摄像头
一.配置wifi 参考树莓派zero w 配置wifi
二.换源 树莓派服务器在国外，国内用户在使用中，update和install过程中会非常慢甚至网络断联报错，在你没有魔法上网 时，换源是友好的选择
准备换源
首先查看自己树莓派版本，树莓派版本，树莓派版本
重要的事情说三遍！！！
在终端里输入
lsb_release -a buster即为当前操作系统版本
确定完版本后
打开配置sources.list文件
在终端 输入
sudo nano /etc/apt/sources.list 用#注释掉原文件内容，用以下内容取代Ctrl + O 保存 Ctrl + X 退出
用清华大学的软件源举例：（buster版本）
Ps：Ctrl+Shift+V可以在终端粘贴
# 编辑 sudo nano /etc/apt/sources.list 文件，删除或注释原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi # 编辑 sudo nano /etc/apt/sources.list.d/raspi.list 文件，删除或注释原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 完成后更新一下软件源列表
sudo apt-get update sudo apt-get upgrade #此项更新安装包 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acf7a4e5314ed672c11ce7e1af6c2955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f47d9fe3192ef3b15ca5101bb06b1fd/" rel="bookmark">
			粗暴解决 ‘Flutter/Flutter.h‘ file not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ’Flutter/Flutter.h’ file not found
目前找到的方法就是
flutter clean删除iOS目录下： / Flutter / Flutter.framework 、Pods文件夹、Podfile.lock、Runner.xcworkspaceflutter pub getcd iospod installflutter run 如果上面的方法还是不行，那就使用下面的方法
**【比较粗暴，请备份好Podfile、Runner里面的内容(如果没有自己额外添加的代码可以无视)】
【比较粗暴，请备份好Podfile、Runner里面的内容(如果没有自己额外添加的代码可以无视)】
【比较粗暴，请备份好Podfile、Runner里面的内容(如果没有自己额外添加的代码可以无视)】 **
进入项目根目录，直接删除ios 目录重新创建ios模块 flutter create -i objc . flutter pub getcd iospod installflutter run 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9237c53e2d968657046eaf20f165c022/" rel="bookmark">
			支持向量机（二）重要参数kernel&#43;探索核函数在不同数据集上的表现&#43;乳腺癌数据集上验证各种核函数的效果&#43;硬间隔和软间隔以及重要的参数C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 重要参数kernel2 探索核函数在不同数据集上的表现3 乳腺癌数据集上验证各种kernel效果4 硬间隔与软间隔：重要参数C 1 重要参数kernel 之前画图时使用的是选项“linear"，自然不能处理环形数据这样非线性的状况。而刚才我们使用的计算r的方法，其实是高斯径向基核函数所对应的功能，在参数”kernel“中输入”rbf“就可以使用这种核函数。
from sklearn.svm import SVC import matplotlib.pyplot as plt import numpy as np from sklearn.datasets import make_circles from mpl_toolkits import mplot3d x, y = make_circles(100, factor=0.1, noise=0.1) clf_1 = SVC(kernel="rbf").fit(x,y) plt.scatter(x[:, 0], x[:, 1], c=y, s=50, cmap="rainbow") plot_scv_decision_function(clf_1) plt.show() 2 探索核函数在不同数据集上的表现 import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap from sklearn.svm import SVC from sklearn.datasets import make_circles, make_moons, make_blobs, make_classification n_samples = 100 datasets = [make_moons(n_samples=n_samples, noise=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9237c53e2d968657046eaf20f165c022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d1f2febba6088201a52fe3fdf99e42/" rel="bookmark">
			Android 重力感应和手动横竖屏切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 切换横竖屏 */ private void changeLandScape() { if (newConfig != null &amp;&amp; newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); } else { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); } } @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); this.newConfig = newConfig; } 配合隐藏状态栏和虚拟按键，参考链接：
android隐藏状态栏和虚拟按键_csdnwr的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945612d19964768f79e1b4bb60d4c1cd/" rel="bookmark">
			连载《Chrome V8 原理讲解》第九篇 Builtin源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 摘要 上一篇文章中，Builtin作为先导知识，我们做了宏观概括和介绍。Builtin（Built-in function）是编译好的内置代码块（chunk），存储在snapshot_blob.bin文件中，V8启动时以反序列化方式加载，运行时可以直接调用。Builtins功能共计600多个，细分为多个子类型，涵盖了解释器、字节码、执行单元等多个V8核心功能，本文从微观角度剖析Builtins功能的源码，在不使用snapshot_blob.bin文件的情况下，详细说明Builtin创建和运行过程。
本文内容组织结构：Bultin初始化过程（章节2），Builtin子类型讲解(章节3)。
2 Builtin初始化 下面是code类，它负责管理所有Builtin功能，是builtin table的数据类型。
1. class Code : public HeapObject { 2. public: 3. NEVER_READ_ONLY_SPACE 4. // Opaque data type for encapsulating code flags like kind, inline 5. // cache state, and arguments count. 6. using Flags = uint32_t; 7. #define CODE_KIND_LIST(V) \ 8. V(OPTIMIZED_FUNCTION) \ 9. V(BYTECODE_HANDLER) \ 10. V(STUB) \ 11. V(BUILTIN) \ 12. V(REGEXP) \ 13. V(WASM_FUNCTION) \ 14. V(WASM_TO_CAPI_FUNCTION) \ 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945612d19964768f79e1b4bb60d4c1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edb3b4d5bce4e2efee353f82a905ab9/" rel="bookmark">
			【ant-design-vue】 a-table的可编辑行使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控件文档 Ant Design Vue
效果图 代码 &lt;template&gt; &lt;a-table :columns="columns" :data-source="data" bordered&gt; &lt;template v-for="col in ['name', 'age', 'address']" :slot="col" slot-scope="text, record, index" &gt; &lt;div :key="col"&gt; &lt;a-input v-if="record.editable" style="margin: -5px 0" :value="text" @change="e =&gt; handleChange(e.target.value, record.key, col)" /&gt; &lt;template v-else&gt; {{ text }} &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;template slot="operation" slot-scope="text, record, index"&gt; &lt;div class="editable-row-operations"&gt; &lt;span v-if="record.editable"&gt; &lt;a @click="() =&gt; save(record.key)"&gt;Save&lt;/a&gt; &lt;a-popconfirm title="Sure to cancel?" @confirm="() =&gt; cancel(record.key)"&gt; &lt;a&gt;Cancel&lt;/a&gt; &lt;/a-popconfirm&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;a :disabled="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edb3b4d5bce4e2efee353f82a905ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf4f39847fc75626b11c416d6c506ea/" rel="bookmark">
			【C&#43;&#43;】VS2019 中文输出乱码 以及 该文件不能在当前代码页(936)中表示的字符 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言解决方案 结语 前言 今天在写 C++ 算法实验的时候遇到了
VS2019 控制台中文输出乱码
该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失
等等问题，有关中文编码的，起初我查找网上的各种方法，包括
修改控制台的编码字符集使用 Format on Save更改 高级保存选项 等等方法，发现都没有效果（指对我这个情况没有作用），困扰了我一晚上，其实后来我解决后发现前面的做法是有用处的，只是我的这个情况有点特殊，容我娓娓道来。
后来在安装和卸载扩展时，偶然发现在我的 VS2019 扩展中安装了一个奇怪的东西。
这个 Force UTF-8 (No BOM)，好家伙，原来是你的问题，怪不得我每次设置 UTF-8 with BOM 的编码格式（即 UTF-8 带签名）在 VS2019 中修改保存后，又会变成 UTF-8 （即 UTF-8 无签名），然后就导致乱码，无论怎么修改编码格式都没用，只要在 VS2019 中保存一下就会强制变成 UTF-8 无签名 的编码格式。
解决方案 于是我卸载了这个扩展。
再次改成 UTF-8 with BOM 的编码格式（可以通过 VS2019 里的 高级保存选项 更改或者通过 记事本另存为 来更改编码格式），然后运行，发现可以成功显示中文，不再乱码，在 VS2019 中修改保存后也不会出问题了。
至此，困扰了我一晚上的问题终于解决了，可能是我之前为了解决某个问题在网上查询后安装了这个扩展，然后一直就没注意了，到现在才发现这个问题，希望大家在解决一些问题用网上的一些解决方法的时候一定要弄清楚原理和其影响，不要只顾着复制粘贴或者按部就班的进行，一定要边做边想，不然也会容易导致以后出现一些奇奇怪怪的问题。
结语 非常感谢大家的阅读，欢迎在评论区留言讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc4dac48dd88f03b79b81c03b3e3f5e/" rel="bookmark">
			abaqus导出全部节点应力值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.查询应力点
1.
2.
3.
二.导出应力点
1.
点击报告（E）→场输出（F）
2.
选择想要输出的参数，应用（提前设置好文件夹与文件名）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c7f0a25188afa545348d8baf614e23/" rel="bookmark">
			CSS 通过＜link/＞标签引入CSS样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="1.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134cdcdb8a25153fb310096027d52150/" rel="bookmark">
			解决 Win 10 输入法（仅桌面）的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：右击开始按钮-运行（或按Win+R），调出使用管理权限的运行框，键入gpedit.msc。
第2步：回车，调出《本地组策略编辑器》。
第3步：点击计算机配置-Windows设置-安全设置-本地策略-安全选项。
第4步：在右边的窗口中找到用户账户控制：以管理员批准模式运行所有管理员，右击-属性（或双击它），选择已禁用。
第5步：重启电脑，就可看到输入法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aac8cfed8d1f3fbc85af37cde986e12/" rel="bookmark">
			DRM (Direct Rendering Manager) 的发展历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 了解 DRM 的发展历史，对于学习 DRM 驱动开发的人员来说，具有一定的帮助。
因此本人决定将 Wiki 上 Direct Rendering Manager 文章中的 History 章节翻译成中文，并重新组织语言形式，方便初学者阅读和理解。
正文 1999年，Precision Insight公司首次为 XFree86 4.0 Server 开发 DRI 显示框架，主要用于更好的适配 3dfx 公司的显卡。也就是在那时提交了第一版 DRM 代码，并以 kernel patch 的形式提交到了 Mesa3D 的 drm 仓库中。
当时的 mesa/drm 仓库其实是包含两部分代码的，一部分为 user space 代码（即后来的 libdrm），另一部分为 kernel space 代码（即后来的 drm 驱动）。
点击此处，查看 DRM 的第一版提交。需要注意的是，那个时候的 DRM 代码，主要以 buffer 管理为主，不包含 mode-setting 的部分。
同年晚些时候，该笔 patch 的 kernel 部分被 merge 到 kernel 2.3.18 主线中，当时的 drm 源码被放到了 /drivers/char/drm/ 目录下，作为字符设备来使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aac8cfed8d1f3fbc85af37cde986e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cf927570358587ed870fafc5b6aa59/" rel="bookmark">
			Linux图形栈-从X到Wayland
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ars思考着Linux图形栈的演变，从最初的...
作者：EvanJenkins 2011年5月22日,下午12:30中央标准时间
原文名称：The Linux graphics stack from X to Wayland
1980年代初，麻省理工学院计算机科学系(以下简称MIT)的BobScheifler着手为新的窗口系统制定规则。他决定取名为X，因为此窗口系统是基于W窗口系统的一个改进，W窗口系统源于V系统。X窗口系统将掀起一场图形领域的革命。当时X确实成为了所有类UNIX窗口系统的标准图形服务器，因为它的特点和理念远远超越了竞争对手。短短几年时间，UNIX社区全部接纳了X窗口系统。
在这篇文章中，我们将一瞥Linux图形栈的发展历程，从最初的X客户端/服务器到现在的Wayland所做的一系列努力。
X变得如此特殊，不得不说，这简直是一个传奇。X是面向网络、基于分布式的第一个图形服务器。在分时系统上，一个X服务器可以同时为多个客户端服务。X的网络协议使本地窗口能够显示在远程机器上。实际上，X就是面向网络的，协议独立于硬件。通过网络协议发送显示请求，运行于某个类UNIX平台的X客户端可以在完全不同硬件平台的类UNIX系统上显示。
窗口外观独立于X服务器。X协议定义了显示设备和窗口原语信息，窗口的具体外观只与控件库、窗口管理器和桌面环境有关。
在BobScheifler的主导和MIT的管理下，更多的人开始对此萌发兴趣。为了X将来更好的发展，那时的企业翘楚，例如美国的数字电子公司(DEC)，可免费获取到源代码。同时，一批厂商询问MIT，是否有某种措施能够维持源代码的完整性，好让X能够造福于所有对此感兴趣的组织机构。MIT同意了，不久之后，MITX协会成立，同时发布了源码，包括DEC对X的改善部分。此次X源码的发布确实是一个值得关注的事件。厂商们意识到，X已经有很高的价值了，需要避免某个公司获得对X的控制，更好的保护大家的心血，而维持X源码的开放是最重要的原则，同时MITX协会一直对X源码拥有版权，避免了X被私人商业公司拥有。
1988年，协会招募了一个高级开放者KeithPackard，他将重新实现X服务器的核心。现在，Packard在Linux图形栈领域已经众人皆知了。
尽管X在UNIX和Linux图形栈领域占据统治地位，但由于X的流行，基于X的、产生大量绘制请求的软件和大量的软件最终拖累了X本身。90年代，Linux快速流行起来，对于运行于同一机器上的XServer/client，开始使用X配置文件，同时X开始捆绑在很多Linux发行版上。对于本地显示来说，X基于网络的设计毫无用处，这一曾经大肆吹嘘的优点现在反而成为视频绘制的瓶颈。
这段时间，个人电脑的销售激增，专业图形显卡的复杂特性开始超越X的处理能力，更多高性能的显卡持续不断的开发出来。
转换表映射（以下简称TTM）的出现
2004年左右，一些Linux开发者开始对X缓慢的发展逐渐感到失望。1992年，他们开始转向OpenGL,一种图像渲染API，最初是用来显示2D和3D图形的（源于硅谷图形公司开发的）。经过几年X在显卡上绘制3D图形的尝试，最终没有一个方案可行。
然后在2007年，ThomasHellstrom, Eric Anholt, 和DaveAirlie共同开发了一个内存管理模块，他们称做TTM。TTM用于显存和系统内存之间的缓冲拷贝。当时在Linux社区引起了很大反响。它为那些对3D性能有严格要求的图形应用带来了希望。这个方法就是将内存缓冲区作为第一个类对象传递给应用程序使用，同时允许应用程序分配和处理内存缓冲区中的图形信息。TTM可以管理主机上所有应用程序的缓冲区，并且提供GPU和CPU之间的同步，这个过程是通过一个特殊信号fence完成的。当GPU完成对某个缓冲区的显示处理后，通过fence信号将此缓冲区的控制权交给此缓冲区对应的应用程序，此时CPU重新接管缓冲区。
平心而论，应用程序对GPU访问方式的标准化，TTM确实做了一个勇敢的尝试，它是Linux上针对所有显卡驱动的内存管理器，简言之，TTM尝试提供所有图形应用程序可能需要的所有操作。不幸的是，TTM代码量和API过于庞大，而每一个独立的开源驱动仅仅只需要API集合中的一个小子集。大量的API容易使开发者迷惑，他们需要决定选择使用哪个API。最大的抱怨是TTM还有一些性能问题，可能是由于CPU和GPU之间的信号同步机制（fence)导致，或者是缓冲区对象的拷贝效率太低。TTM可能确实要处理很多事情，不过这不能成为它变得缓慢的借口。
2008年，ReenterKeithPackard宣布了一个TTM的替代方案。Keith到目前为止还在Intel工作。得益于Eric开发TTM的经验教训，同时在Eric的帮助下，他们重写了TTM。新的API叫图形执行管理器（以下简称GEM），一般开发者通过API就能大致猜到下一步要做什么，相对于TTM庞大的API，开发者不会迷失于GEM的API中。
相对于TTM，GEM有很多提升，其中一个计较有意义的提升就是API接口的设计很严谨，同时TTM中伤脑筋的fence信号概念也去掉了。Keith和Eric让应用程序接管API之上的内存部分，GEM则专心处理GPU可访问的内存部分，并处理显卡执行的上下文信息。应用与内核空间的交互访是通过ioctl()调用，不存在TTM那种不停的缓冲区拷贝。GEM更像是一个面向流的API，而不是内存管理器。
GEM允许应用程序共享内存缓冲区，GPU处理的内存空间就不需要重新装载。以下是原始的发行说明：
“Gem为Linux操作系统提供简单的机制来管理图形数据和控制执行流程。很多内核子系统实现了这种机制。”
随着GEM在2008年5月的出现，给Linux的图形栈带来了更多的希望。GEM并不处理所有事情。例如，GPU执行的命令由设备对应驱动提供。因为Keith和Eric在Intel工作，GEM对Intel驱动支持的开源代码编写工作理所当然落在了他们身上。同时希望GEM能够支持更多其他的驱动，例如三个最大的显卡制造商。
然而，采用GEM的非intel显卡驱动很慢。一些迹象表明AMD驱动选择了一个“类似GEM和TTM管理器”的方案，预示着AMD并不愿意加入到GEM的阵营，GEM面临单枪匹马的危险。
TTM和GEM尝试在X中整合对GPU的操作以解决Linux图形栈上的3D加速问题。两者都是为了更好的提升不同图形库的显示性能，例如OpenGL(依赖于X),Qt(依赖于X)和GTK+（也是依赖于X)。问题是X处于所有图形库和内核之间，只有内核能够访问设备驱动，然后驱动才能访问到GPU。
X已经老掉牙了。X拥有数百万行代码，很多代码已经很陈旧，那是还没有GPU，没有专业的晶体管处理可编程着色技术或者旋转操作以及顶点翻转，既不知道高密度采样和用插值法减少反锯齿效果的概念，也不清楚如何创建极高精度的颜色空间。此时不同往日，X已经不能满足现在的需求了。
Wayland:一个新的显示管理器
2008年，一个叫KristianHøgsberg 的软件工程师在波士顿的市郊上开着车，可能是去往工作的路上，亦或是回家，软件工程师正深入的思考着，他们花费了大量时间解决复杂的问题，将问题打散并进行重构。经常，当他们工作疲劳休息时，会产生一些灵感，这种灵感往往能够为项目带来更大的突破。当人们在洗澡或者在厨房烹饪时，或者在驾驶途中，这种灵感更易产生。当Høgsberg驱车于马萨诸塞州Wayland一个很小的村庄时，他的大脑中迸出一个想法并渐渐成型，这个想法用他自己的话说：
“核心思想是所有窗口被重定向，我们可以让所有客户端自己去渲染自己，然后传递一个缓冲句柄给显示服务器，显示服务器中的混合器完成窗口显示工作。其中一个目标就是让X服务器运行于Wayland上，首先支持全屏窗口（例如Xnest)，然后支持父窗口等，直到X被最终淘汰。”
他的想法是写一个全新的显示管理器，管理器可绕过X直接向内核发送3D显示请求。X自己就是显示管理器的一个客户端，正如以上作者所说，新的显示管理器取名为“Wayland”，以此表达对这个小镇的敬意。
这仅仅只是一个想法。很多人每天都会产生大量聪明的想法，但最终都被生活中的杂事所磨灭。Høgsberg正从事于图形渲染库方面的工作，他大概觉得，如果应用程序都能直接访问GPU，没有X在中间搅局，那一切事情都变得简单了。他着手写代码解决这个问题。根据Intel的员工KeithPackard所说，两周后，Høgsber完成了雏形。
Wayland的一个关键特点是完成渲染工作的API完全不依赖X。为了保持兼容性，X服务器本身就是Wayland的客户端,所有X所做的渲染直接发给Wayland。像X一样，Wayland仅仅定义协议。Wayland的体系结构和X本身的特点，给X客户端的移植带来了很大便利，同时还兼容以前的X客户端程序。
Wayland显示管理器会使用内核中的GEM(图形执行管理器)、evdev(输入事件驱动)和kms(内核模式切换）。Wayland有自己的混合器，这与X形成鲜明的对比，X依赖外部的混合器处理显示相关的内存缓冲。
Wayland也会使用DRI2。Wayland混合器和Wayland客户端都能够访问屏幕显示相关的资源。当客户端更新了这个缓冲，混合器将更新桌面，并重绘屏幕。
Wayland确实解决了很多X无法解决的问题，大家对此项目感到兴奋，一群聪明的人正在实现它，并且Intel和redhat也在支持这个项目。
但是还有一些障碍需要克服。两个最大的障碍就是开发兼容NVIDIA和AMD的开源驱动。第三大显卡厂商Intel已经兼容了Wayland，因为GEM内核模块就是基于Intel驱动开发的。
谁会为Wayland更新AMD和NVIDIA的开源驱动？对开发者来说，Linux下开源显卡驱动的开发很折磨人，因为你没有完整的硬件规范手册，甚至什么资料都没有，只能通过枯燥的逆向工程获取显卡规范信息。
nouveau驱动就是一个很好的例子。当时，NVIDIA开发者放出话来，表示我们没有支持Wayland的计划。所有工作压向Linux社区，有时有一些厂商的支持，有时什么都没有。在nouveau项目中，开发者正通过逆向工程积极的开发NVIDIA驱动。一个叫做Renouveau(nouveau的逆向工程）的执行流程如下：
1.记录MMIO寄存器的内容；
2.绘制图形；
3.记录寄存器中的新值；
然后向Renouveau工程的ftp服务器发送绘制前后内存转储的文本格式差异信息，这些文件是为以后的显卡分析做准备。
相对于NVIDIA，AMD这方面的工作进展更顺利。过去几年中，新成立的团队正在开发AMD的开源驱动，根据开发团队周期性发布的规范说明，各地开发者皆可持续驱动的研发。驱动名称是fglx(FireGLand Radeon for X）,Linux社区每月都可以从AMD获得显卡的最新信息。
Wayland在Linux图形栈方面很有优势。最近，Ubuntu计划在Wayland上使用他们自己的窗口管理器Unity。为了确保硬件驱动能在新的图形架构上发挥最大性能，Intel强力支持协助开发GEM，雇佣了Wayland的开发者们。
除此以外，图形领域正在两极分化。AMD和NVIDIA正忙于争夺市场份额的激烈竞争，开源社区的开发需求还排不上他们的议程。
Linux社区是基于协作来完成开发。多年以来，通过合作和开放，Linux急速发展，而Linux图形栈似乎不为所动。图形硬件厂商可选择是否向开源社区贡献力量，而我对他们不情愿开源的态度感到吃惊。那些拥有高性能图形显卡的厂商难道不想让他们的用户拥有最好的用户体验？将产品信息隐藏起来，这些难道不会伤及他们的产品线？可以毫无疑问的说-他们违反了开源精神。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e399f870a3ac9ddb372cd74fda66b5ba/" rel="bookmark">
			使用duet或spacedesk实现iPad作为电脑扩展屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有线连接 推荐使用duet display(AppStore有售，68r)。
连接时无延迟；配置较复杂。 配置教程 首先，在PC上到duet官网下载windows版本的duet(https://zh.duetdisplay.com/)。然后在AppStore中购买duet display。(你会发现一个叫duet air的app，这是需要订阅的，一年20$，但可以实现无线连接。个人认为用spacedesk可以替代，后文会介绍)
然后使用iPad的数据线连接电脑，如果没有苹果驱动则无法连接，此时到苹果官网去下载iTunes(https://www.apple.com.cn/itunes/)，该软件安装时会装上苹果的驱动。
安装完成后，如果还是无法连接，请将iPad版本更新到最新版，同时iTunes版本更新到最新版。仍然失败的话，到设备管理器中手动将苹果驱动更新到最新版。打开duet，windows上的页面如下所示。
再打开iPad上的duet display App，点击连接即可连接成功。 无线连接 如果很富裕可以考虑使用duet air，但效果与spacedesk差不多，只是操作简单些。下面介绍spacedesk的教程，duet air只需要在AppStore中下载duet air然后订阅就可以了，非常简单。(在windows中已经安装了duet的基础上，不需要安装iTunes)
##spacedesk安装教程
首先，到spacedesk官网上下载win10对应的应用程序(win7对应的没有效果)。网站响应较慢，https://www.spacedesk.net/。点击下载时，请多试几次，因为有时候响应太慢会显示无连接等情况。
安装spacedesk，完成后界面如下所示，找到wireless的ip地址。
在AppStore下载spacedesk App。然后，点击右上角的+号会让输入ip地址。确保iPad与电脑在同一个网络下后，输入上一步中的ip地址即可。
正常情况这里就结束了，然而还会出现一些细节问题 如果出现iPad上显示闪烁，请退出连接后，调整iPad上App的频率。(在spacedesk App左下角那个齿轮中，点击后进入settings)。另外，还可以配置以下显示的像素等信息。如果连接不成功，那么可以采取以下两种方式: 使用手机热点，让电脑和iPad在同一个局域网下就可以成功，然后重复2~3步。为了简便，如果电脑连接的是wifi的话，直接让电脑分享热点到iPad，然后重复上述2~3步即可。(在桌面右下角，点击过后可以找到热点分享的图标)。修改左右屏幕的位置必须要连接成功后才能在电脑中出现选项。具体操作为: 搜索“设置”-&gt;点击“系统”-&gt;在“显示”中修改。 写在最后
如果你尝试了上述步骤后还是没能成功，那么请检查是否让电脑进行了扩展。(按win+P快捷键后选择扩展即可)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e7c230415a0cdb59c6f8cf8c9994d7/" rel="bookmark">
			UML类图、6种关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，类图
二，类的6种关系
1，泛化
2，实现
3，组合
4，聚合
5，关联
6，依赖
三，总结
一，类图 类图中，每个类由3个部分组成，上面的是类名，中间的是属性，下面的是方法。
属性和方法可以用修饰符修饰：加号（+）表示public；减号（-）表示private；井号(#)表示protected
二，类的6种关系 类的6种关系：泛化 实现 组合 聚合 关联 依赖
6种关系依次减弱。
参考：UML类图几种关系的总结
1，泛化 泛化是一种继承关系，如老虎类继承动物类，动物是老虎的泛化，老虎是动物的特化。
class Animal { public: Animal() { posX = posY = 0; } void move(int dx, int dy) { posX += dx, posY += dy; } void getPos() { cout &lt;&lt; "x=" &lt;&lt; posX &lt;&lt; ", y=" &lt;&lt; posY &lt;&lt; endl; } private: int posX, posY; }; class Tiger :public Animal { public: Tiger() { this-&gt;name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e7c230415a0cdb59c6f8cf8c9994d7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/282/">«</a>
	<span class="pagination__item pagination__item--current">283/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/284/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>