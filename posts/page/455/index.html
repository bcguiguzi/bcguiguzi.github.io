<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6744c34fc3c5aa037f9e29e0f8e6ac56/" rel="bookmark">
			以太坊中ERC20交易的检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中遇到了token交易的检测问题，之前的做法是依靠交易中的input字段，如果有支持erc20标准的token交易，则input字段必然会有transfer函数的消息；如下图；根据input字段判断之后，在获取交易的Receipt，根据log字段进行进一步解析。后来发现这么搞会有问题，会遗漏erc20的交易。
为什么会有遗漏呢，主要是因为构建交易的时候，to地址是一个合约，而且这个合约不是erc20的合约，而是一个普通合约，这个合约地址会去调用erc20的合约；这用导致input字段的函数不是transfer了，而是普通合约的函数，如下图；
那应该如何检测erc20标准的token交易呢，根据erc20标准可知，有交易发生必然会触发Transfer事件，所以，我们去监测transfer事件，如何监测呢，这个在receipt的logs中，topics[0]都是事件的keccka的hash结果；topics[1]topics[2]分别是from和to；address是合约地址；data是交易额；rre
最后记录一下erc20的标准吧；
以太坊的出现使得大家可以很方便的以太坊上发行自己的代币，这些代币都遵循ERC20协议（现已有ERC23协议）。智能合约编程支持合约的继承（类似面向对象语言中类的继承和接口的实现），因此ERC20协议可以定义为一个接口。 contract ERC20 {
function totalSupply() constant returns (uint totalSupply); //获取总的发行量
function balanceOf(address _owner) constant returns (uint balance); //查询账户余额
function transfer(address _to, uint _value)returns(bool success); // 发送Token到某个地址(转账)
function transferFrom(address _from, address _to, uint _value) returns (bool success); //从地址from 发送token到to地址
function approve(address _spender, uint _value)returns(bool success);//允许_spender从你的账户转出token
function allowance(address _owner, address _spender) constant returns (uint remaining);//查询允许spender转移的Token数量
event Transfer(address indexed _from, address indexed _to, uint _value);//transfer方法调用时的通知事件
event Approval(address indexed _owner, address indexed _spender, uint _value); //approve方法调用时的通知事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6744c34fc3c5aa037f9e29e0f8e6ac56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b6de4201b7329f5dbc836fa5d232c6/" rel="bookmark">
			Python量化数据获取：综合指数介绍及如何获取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常综合指数指的是一个市场全部股票按照一定的权重进行加权和，并且以某一个交易日为基准计算出来的数值。这个数值反映了整个市场的走向和趋势，能反映系统性的信息。A股市场比较常用的综合性指数就是有名的上证指数sh.000001和深证综指sz.399106。
其它的综合指数还包括，B股指数，工业指数，商业指数等。
可以通过BaoStock获取历史的数据，包括价格和成交量信息，以此来分析市场的热度，趋势和活跃程度。获取指数数据的方式和获取个股的数据方式一样，使用同一个函数接口。
import baostock as bs
import pandas as pd
#### 登陆系统####
lg = bs.login()
# 显示登陆返回信息
print('login respond error_code:'+lg.error_code)
print('login respond error_msg:'+lg.error_msg)
#### 获取指数(综合指数、规模指数、一级行业指数、二级行业指数、策略指数、成长指数、价值指数、主题指数)K线数据 ####
##综合指数，例如：sh.000001 上证指数，sz.399106 深证综指 等；
# 详细指标参数，参见“历史行情指标参数”章节
rs = bs.query_history_k_data("sh.600000",
"date,code,open,high,low,close,preclose,volume,amount,pctChg",
start_date='2017-01-01', end_date='2017-06-30', frequency="d",adjustflag="3")
print('query_history_k_data responderror_code:'+rs.error_code)
print('query_history_k_data respond error_msg:'+rs.error_msg)
#### 打印结果集 ####
data_list = []
while (rs.error_code == '0') &amp; rs.next():
# 获取一条记录，将记录合并在一起
data_list.append(rs.get_row_data())
result = pd.DataFrame(data_list, columns=rs.fields)
#### 结果集输出到csv文件 #### result.to_csv("D:\\history_Index_k_data.csv",index=False)
print(result)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b6de4201b7329f5dbc836fa5d232c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814851906a20a07b27a5dc154750211d/" rel="bookmark">
			编程题目：到底买不买
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：链接https://www.nowcoder.com/questionTerminal/2f13c507654b4f878b703cfbb5cdf3a5 来源：牛客网
小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一 下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。
为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如，YrR8RrY是小红想做的珠串；那么ppRYYGrrYBR2258可以买，因为包含了 全部她想要的珠子，还多了8颗不需要的珠子；ppRYYGrrYB225不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入描述 每个输入包含1个测试用例。每个测试用例分别在2行中先后给出摊主的珠串和小红想做的珠串，两串都不超过1000个珠子。
输出描述 如果可以买，则在一行中输出“Yes”以及有多少多余的珠子；如果不可以买，则在一行中输出“No”以及缺了多少珠子。其间以1个空格分隔。
输入 ppRYYGrrYBR2258 YrR8RrY
输出 Yes 8
解题关键 使用哈希表能有效解决此问题，创建两个数组，分别记录摊主的串和小红需要的串。 遍历摊主的串，每个元素ASCII码对应数组下标，找一个元素，就在对应位置值加1。 遍历小红的串，找一个元素，如果该下标值大于0，就让值减1，记录已找到的颜色的count加1。 比对count和小红串的长度，输出对应结果。
C++写法（普通可改成C写法） using namespace std; #include &lt;iostream&gt; int main() { int HashTable[128] = { 0 }; char Source[1000] = { 0 }; char Aim[1000] = { 0 }; cin &gt;&gt; Source &gt;&gt; Aim; int len1 = strlen(Source); int len2 = strlen(Aim); for(int i = 0; i &lt; len1; i++) ++HashTable[Source[i]]; int count = 0; for (int i = 0; i &lt; len2; i++) { if (HashTable[Aim[i]] &gt; 0) { --HashTable[Source[i]]; ++count; } } if (count == len2) cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814851906a20a07b27a5dc154750211d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0d32721ae3237f6a005e3b4dd8b894/" rel="bookmark">
			JavaScript 中&#34;$&#34;的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中,我们或许会写下这样的代码
$(document).ready(function(){ $("p").mouseover(function(){ $("p").css("background-color","#333"); });}); 这个mouseover事件中的"$",这个"$"是什么含义呢?这个时候如果我不想用 $ 了，该怎么更改？ 也就是说我不想用 jQuery 了，也不考虑多浏览器支持的情况下，如果做修改呢？下面将简要介绍一下。
"$"符号的起源 $ 是合法的IdentifierStart 就是可以作为变量名,函数名,形参的第一个字符. 就如同 _ 下划线一样. 但.$最初在ES3时代.在标准中,是建议保留使用的.保留给机器自动生成代码使用.比如以javascript作为编译目标语言的语言等等. 这本来是一个弱约束的公约. 但随着jquery等,没有遵守这个公约的库大行其道. 这个弱约束就名存实亡了. 到了ES5时代.这个保留使用的建议, 也被取消了. 所以你问 $是什么. _是什么,他就是什么. 不同的之处在于 他是jquery崛起的历史见证.
"$"符号的定义 $符号在JS里是可以当做identifier的，也就是说可以当成变量名称，或者函数名称，并且可以打头（不同于一些语言比如c什么的只能用字母打头后接字母或者数字），甚至可以单独使用所以就明了了，$只是一个变量或者函数这里的话$就是jQuery的对象了，严格的说它应该是jQuery对象的构造函数你可以查看一下jQuery的源代码，开头大概是这么写的：
$ = (function(){ //jQuery define.. return jQuery; })(window,undefined); 用$这个特殊符号做为框架标识的也不止jQuery，其它也有不少的，很早的时候有人喜欢把document.getElementById这个函数封装在$这个函数里以方便调用。 替换变量 $ 的 jQuery 控制权 noConflict() 方法让渡变量 $ 的 jQuery 控制权。 该方法释放 jQuery 对 $ 变量的控制。 该方法也可用于为 jQuery 变量规定新的自定义名称。 提示：在其他 JavaScript 库为其函数使用 $ 时，该方法很有用。
过渡jquery变量。 $.noConflict();//直接释放掉$的占用 var jq = $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a0d32721ae3237f6a005e3b4dd8b894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca992ef3c99fc3f5953f10457cdd87f/" rel="bookmark">
			计算机网络：应用层（HTTP协议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一资源定位符(URL）：
1.URL的格式
统一资源定位符URL是对可以从因特网得到的资源的位置和访问方法的一种简洁的表示。URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。
URL相当于一个文件名在网络范围的扩展。因为URL是于因特网相连的机器上的任何可访问对象的一个指针。由以冒号隔开的两大部分组成，并且在URL中的字符对大写或小写没有要求。URL的一般形式是：
HTTP协议：
操作流程：为了使超文本的链接能够高效率地完成，需要用HTTP协议来传送一切必须的信息。从层次角度看，HTTP是面向事务的应用层协议，它是万维网上能够可靠地交换文件（包括文件、声音、图像等多媒体文件）的重要基础。
访问一个网页的流程：
1.浏览器分析超链接指向页面的URL
2.浏览器向DNS请求解析：www.tsinghua.edu.cn的IP地址
3.域名系统DNS解析出清华大学服务器的IP地址
4.浏览器与服务器建立TCP连接
5.浏览器发出取文件命令：GET/chn/yxsz/index.htm
6.服务器给出响应，把文件index.htm发给浏览器
7.TCP连接释放
8.浏览器显示“清华大学院系设置”文件index.htm中的所有文本
代理服务器的一点相关知识：
HTTP的报文结构：
HTTP有两类报文：请求报文----从客户向服务器发送请求报文。 响应报文----从服务器到客户的回答。
由于HTTP是面向正文的，因此在报文中的每一个字段都是一些ASCII码串，因而每个字段的长度都是不确定的。
报头由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。
响应报文的开始行就是状态行。状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语。
在服务器上存放用户的信息：
万维网站点可以使用Cookie来跟踪用户。Cookie原意是“小甜饼”，在这里Cookie表示在HTTP服务器和客户之间传递的状态信息。我们在登录邮箱的时候，不管查看收件箱还是垃圾箱，都是在一个账号下；在游戏里，登录了一个账号，不管是打怪还是买装备都在一个人物角色下。为了维护账号的信息，HTTP协议设置了规范的名字叫做Cookie。
工作原理：
1.当用户张三浏览某个使用Cookie的网站时，该网站的服务器就为张三产生一个唯一的识别码，并以此作为索引在服务器的后端数据库产生一个项目。接着在给张三的HTTP响应报文中添加一个叫做Set-cookie的首部行。
Set-cookie：12345678
2.当张三收到这个响应时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括这个服务器的主机名和Set-cookie后面给出的识别码。当张三继续浏览这个网站时，每发送一个HTTP请求报文，其浏览器就会从其Cookie文件取出这个网站的识别码，并放到HTTP请求报文Cookie首部行中：
cookie：12345678
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6fd2b00f7f208f614a39baf89e6eaf/" rel="bookmark">
			python--时间序列预测(time series prediction)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题外话：前段时间做了一点时间序列预测，积累了一点经验，写出来与大家分享一下。能力有限，若是有错误，请指正。本文理论内容不会特别多。
1.时间序列预测
时间序列预测，主要就是依靠过去和现在的数据，分析两者之间的关系，然后利用得到的这个关系去预测未来的数据。现在主要运用在股票和人口等的预测上。个人觉得时间序列预测与其他预测不同的，通常时间序列预测只有1维数据，所以很多机器学习方法不能直接使用。
2.时间序列预测模型
下面来说一下我做时间序列预测时用到的模型，首先是很简单的灰色预测模型，之后是非常普遍的ARIMA系列模型。
2.1灰色模型
灰色预测模型(Gray Model)，这种模型的思想很简单，常用来对数据进行预测，在时间序列预测上的应用不是特别多。关于这个模型具体可以参考参考：https://blog.csdn.net/qq547276542/article/details/77865341
关于这个模型，我想说明的只有一点，就是这个模型的预测结果，无论是对训练集的拟合结果，还是预测的结果，除了第一组数据能够准确预测意外，其余的预测数据都呈单调递增或递减趋势。这点可以用理论证明：
由上述内容可以知道，灰色模型的预测值计算表达式为:
$$x^{(0)}(k+1)=x^{(1)}(k+1)-x^{(1)}(k)$$
$$=[(x^{(0)}(1)-\frac{b}{a}){\rm e}^{-ak}+\frac{b}{a}]-[(x^{(0)}(1)-\frac{b}{a}){\rm e}^{-a(k-1)}+\frac{b}{a}]$$
$$=(x^{(0)}(1)-\frac{b}{a})(1-{\rm e}^{a})({\rm e}^{-ak})$$
为了方便我把上式改写成了常见的方程形式如下：
$$y=(m-\frac{b}{a})(1-{\rm e}^{a}){\rm e}^{-ax}$$
对上式求一阶导数得到：
$$y^{'}=-a(m-\frac{b}{a})(1-{\rm e }^a) {\rm e }^{-ax}$$
简单的分析就可以知道，上式的符号不会发生变化，所以可以得到上面递增递减的结论。
2.2 ARMA、ARIMA模型
ARMA模型全程为自动回归积分滑动平均模型(Autoregressive Integrated Moving Average Model)，网上对这个模型的介绍以及使用介绍的都非常多了，这里就省略了。因为刚开始做ARIMA实验的时候，对这个模型不太了解，所以我的实验参考了这篇博客。https://www.cnblogs.com/foley/p/5582358.html
在具体的实验里，我们采用的拟合方式是把时间序列划分成3个序列（trend,seasonal,residual）,然后对其中的各个部分分别进行拟合。但我们在实验中发现seasonal序列是一个有规律的序列（如下图，从图中可以看出从1949-01-01到1949-12-01所对应的数据与195-01-01到1950-12-01的数据一一对应，这12个数据重复出现。），所以对这个序列并没有进行拟合而直接使用。
对剩余的两部分分别拟合后。在把拟合后得到的三个序列相加就可以得到最终的拟合结果。并使用最终的模型预测未来5个月的数据。具体代码如下：
from statsmodels.tsa.arima_model import ARMA import statsmodels as sm import pandas as pd import matplotlib as mpl import matplotlib.pyplot as plt from statsmodels.tsa.seasonal import seasonal_decompose from statsmodels.tsa.stattools import adfuller if __name__ == '__main__': mpl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c6fd2b00f7f208f614a39baf89e6eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a08d4dbf71031d247bb69cf48926f9c/" rel="bookmark">
			Ubuntu下修改为永久DNS的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483
在安装ubuntu16.04 ROS时，有几个包总是会报502 gate 错误，于是考虑到是不是dns不支持，网上找了几种解决方案，最后尝试下来如下一种方案是可行的，亲测可用～
安装好Ubuntu之后设置了静态IP地址，再重启后就无法解析域名。想重新设置一下DNS，打开/etc/resolv.conf
cat /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
内容是一段警告：说这个文件是resolvconf程序动态创建的，不要直接手动编辑，修改将被覆盖。
果不其然，修改后重启就失效了，搜索了Ubuntu下设置DNS的相关资料，总结出办法：
通过/etc/network/interfaces，在它的最后增加一句：
dns-nameservers 8.8.8.8 复制就好，很多人拼写错误
8.8.8.8是Google提供的DNS服务，这里只是举一个例子，你也可以改成电信运营商的DNS。重启后DNS就生效了，这时候再看/etc/resolv.conf，最下面就多了一行：
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 8.8.8.8
dns 8.8.8.8 是谷歌的万能dns
还有一个是114.114.114.114 这2个都可以用的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ea86992b221b2de31ffc6d0f110693/" rel="bookmark">
			2018-07-01-系统分析与设计作业Lesson16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统分析与设计 Lesson16 使用 ECB 实现 make reservation 用例的详细设计 用例简介 寻找旅馆：其中包括的子用例：选择城市， 选择入住时间段预定房间： 选择旅馆，选择房间种类，确认订单管理购物车： 对购物车的增删改查等操作支付：选择支付方式 顺序图 类图 将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类 树形结构表述实现如图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435315489e9ceea04b1aaed3810d4531/" rel="bookmark">
			绘制圆形surfaceview，解决预览框的畸变问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 绘制圆形的SurfaceView2.自己定义MySurfaceView类，继承自SurfaceView类3.接下来是MySurfaceView的实例化4.布局文件部分 本Demo的GitHub地址： 绘制圆形的SurfaceView 首先介绍一下什么是SurfaceView Surface意为表层、表面，顾名思义SurfaceView就是指一个在表层的View对象。为什么说是在表层呢，这是因为它有点特殊跟其他View不一样，其他View是绘制在“表层”的上面，而它就是充当“表层”本身。创建SurfaceView的时候需要实现SurfaceHolder.Callback接口，它可以用来监听SurfaceView的状态，比如：SurfaceView的改变 、SurfaceView的创建 、SurfaceView 销毁等，我们可以在相应的方法中做一些比如初始化的操作或者清空的操作等等。
Android系统提供了View进行绘图处理，我们通过自定义的View可以满足大部分的绘图需求，但是这有个问题就是我们通常自定义的View是用于主动更新情况的，用户无法控制其绘制的速度，由于View是通过invalidate方法通知系统去调用view.onDraw方法进行重绘，而Android系统是通过发出VSYNC信号来进行屏幕的重绘，刷新的时间是16ms,如果在16ms内View完成不了执行的操作，用户就会看着卡顿，比如当draw方法里执行的逻辑过多，需要频繁刷新的界面上，例如游戏界面，那么就会不断的阻塞主线程，从而导致画面卡顿。而SurfaceView相当于是另一个绘图线程，它是不会阻碍主线程，并且它在底层实现机制中实现了双缓冲机制。
SurfaceView最常见的应用场景就是在摄像头的预览，手机录像和拍照的时候屏幕上的显示，就是在surfaceView进行显示的
下面的代码是他最常见的生命周期， 当SurfaceView的界面不可见时，就会调用surfaceDestroyed（）函数来杀死本进程，当重新进入本界面时，需要重新加载。 @Override public void surfaceCreated(SurfaceHolder holder) { } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { } @Override public void surfaceDestroyed(SurfaceHolder holder) { } 2.自己定义MySurfaceView类，继承自SurfaceView类 先看一下效果图
我的理解是,可以把它看成是一个红色的图层覆盖了原来的SurfaceView，即我们只能看到圆框中的内容 package com.example.heartratedect; import android.content.Context; import android.graphics.Canvas; import android.graphics.Paint; import android.graphics.Path; import android.graphics.Region; import android.hardware.Camera; import android.util.AttributeSet; import android.util.Log; import android.view.SurfaceView; /** * 圆形SurfaceView * 这个SurfaceView 使用时 必须设置其background，可以设置全透明背景 */ public class MySurfaceView extends SurfaceView { private Paint paint; private int widthSize; private Camera camera; private int height; public MySurfaceView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); initView(); } public MySurfaceView(Context context, AttributeSet attrs) { super(context, attrs); initView(); } public MySurfaceView(Context context) { super(context); initView(); } private void initView() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/435315489e9ceea04b1aaed3810d4531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae29f5b25595590d4bbec81a3fee437a/" rel="bookmark">
			LM2596S-ADJ DC-DC降压芯片使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 废话不多说，先上原理图 扣扣技术交流群：460189483
先来官方原理图，还是讲的蛮详细的
官方原理图没有在某宝上找到做好的板子，于是俺自己掏腰包买了一块，如下这种：
为了搞清楚好用不好用，果断又买了一个带数显的
买回来倒是都挺好用的，于是把上面那个做成原理图，奉献给大家，12V 3A输出
大致电路基本上与官方一致，就是选型不一样而已，型号都帮各路大神写清楚了，做起来贼方便
打算自己尝试做一个demo板，于是开始买元器件，尼玛，一个原厂正品LM2596S-ADJ竟然高达10元RMB（PS:通过正常渠道和代理商渠道和淘宝渠道获取的购买价格），国产的1块钱，让我犹豫了，我这个板子买的才3块钱，这不是恶心我吗？
然后百度搜索、咨询代理商，原来大部分廉价的LM2596S-ADJ芯片都是LM2576抹掉，又打印上去的，如果各位看到自己买到的芯片表面模糊，有很明显打磨的痕迹，恭喜你中奖了！
然后，就没有然后了，突发奇想，最近在做机器人底盘，给客户留电源接口，有的需要24V，有的需要19V，有的需要5V，等等，突然想可以通过单片机引脚，使用DAC功能控制输出电压，果断尝试，上原理图先：
计算过程：流过电阻R3的电流I3 ，流过电阻R2的电流I2 ，流过电阻R1的电流I1 FB引脚反馈电压VFB， 单片机DAC输出电压VG，二极管压降VD,
通过下面推导：
I3=(VG-VD-VFB)/R3
I2=(VOUT-VFB)/R2
I1=VFB/R1
VD为二极管导通电压0.4V VFB=1.23
(VG-1.23-0.4)/R3+(VOUT-1.23)/R2=1.23/R1
(VG-1.63)/R3+(VOUT-1.23)/R2=1.23/R1
VG&lt;=1.63V时，I3=0,VOUT=1.23*(1+R2/R1)=23.78V
VG&gt;1.63V时，VOUT=1.23*(1+R2/R1)-(VG-1.63)*R2/R3
VG=3.25V时输出最小 VOUT=23.78-35.64/R3=23.78-23.78=0V
所以可以实现0-23.78V可调 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d95696ecef34799fc431e13c16747d/" rel="bookmark">
			稳压二极管工作原理与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483
稳压二极管（zener diode），也称齐纳二极管，与普通二极管不同的是，稳压二极管工作在反向击穿状态时，它的工作电流在很大范围内变化而其两端的电压基本不变。
它的原理图符号有如下图所示的两种：
标称稳定电压VZ（Nominal Zener Voltage）是稳压二极管最重要参数，也是工程师在选型时首要的参数。
稳压二极管的典型应用电路如下图所示：
它的主要作用是从较高输入电压Vi中获取的较低输出电压Vo，这里我们并没有这样描述：从较高的不稳定的输入电压Vi中获取较低的稳定输出电压Vo。稳压二极管虽然有一定的稳压功能，但这种稳压能力在精度要求较高的场合并不适用，在大多数实际应用电路中，稳压二极管更多的是为了获取一个对精度要求不高的电压值（精度要求高的可选择电压基准芯片，可参考相关文章），
下图为稳压二极管应用于场效应管驱动时的示意图：
N沟通道场效应管的栅源开启电压VGS是有最大限制值的，比如±20V，超过此值则场效应管可能会损环，通常在此类开关控制电路中，VGS值设置为 10V左右，如果电路系统中只有36V较高的电压（其它为5V之类的低压），这个电压不可以直接作为VGS电压，当然，可以采用诸如低压差线性调整芯片（LDO）从36V中降压获取此电压，但是大多数情况下，我们只需要如图所示稳压二极管即可，成本低，电路简单，而且这种应用对稳压精度要求并不高。
当输入电源电压Vi比稳压二极管的稳定电压VZ低时，稳压二极管没有击穿而处于反向截止区，此时电路回路中只有比较小的反向漏电电流IR（reverse leakage current），这种工作状态不是稳压二极管的正常工作状态，因为输出电压Vo是随输入电压Vi变化的，没有达到输出稳定电压的目的，如下图所示：
当输入电源电压Vi比稳压二极管稳定电压ZT高时，稳压二极管被反向电压击穿，此时回路电流急剧增加，如下图所示：
此时的输出电压Vo就是稳压二极管的标称稳定电压，也就是我们所需要的电压值，回路中的电流就是稳压二极管的工作电流IZ（zener current），此值由下式可得：
其中，电阻R就是稳压二极管的限流电阻。能够使稳压二极管进入稳压状态的最小电流IZ也叫膝点/拐点电流IZK（knee point current），因此，电阻R值不应该太大，那么这个电阻的最小值应该是多少才合适呢？我们继续往下看：
当输入电源电压Vi时继续增加时，稳压二极管的稳定电压VZ（也就是输出电压Vo）会有一定的变化，但没有输入电压Vi变化那么大，因为稳压二极管处于反向击穿稳压状态，此时输入电压Vi与输出电压Vo的差值都施加到电阻R两端，继而引起回路电流上升。
稳压二极管本身没有最高反向电压的参数，但是它会有一定的功耗，如下式：
也就是稳压二极管的稳定电压VZ与流过稳压二极管中的电流IZ的乘积，对于具体的稳压二极管，其稳定电压VZ是额定的，因此功耗也可以由最大的功耗也可由最大工作电流IZM（Maximum zener current）来表示，很多数据手册中也是给出这个值。
当回路电流IZ超过稳压二极管的最大工作电流IZM时（也就是超过二极管最高允许耗散功率），稳压二极管会因为过热而损坏，此时的输出电压Vo就是输入电压Vi，也就是不再有稳压能力了，如下图所示：
因此，我们在设置电阻R的最小值时，应控制稳压二极管的工作电流在IZM之内。
这种特性我们也可以从稳压二极管的伏安V-I特性曲线看出，如下图所示：
稳压二极管有一定的电阻，通常称为动态电阻RZ（zener resistance）或动态阻抗ZZ（zener impedance），它是指稳压管两端电压变化与电流变化的比值，可由下式所得：
动态电阻RZ随稳压二极管的工作电流IZ不同而不同，通常工作电IZ流越大（即分母越大），则动态电阻则RZ越小，这个值自然是越小越好。
我们可以把稳压二极管等效一个理想的电压源VZ与一个动态电阻RZ串联，如下图所示：
因此，典型应用电路也可以修改如下所示：
当回路中的电流IZ上升时，动态电阻RZ两端的压降（IZ×RZ）亦会上升，则输出电压Vo也会上升，动态电阻RZ越小则输出电压Vo变化越小，也就是说稳压能力更佳。
稳压二极管还有一个参数：温度系数TC（temperature coefficient），它是衡量在电路参数不变的条件下，稳压二极管的温度变化引起的稳定电压的变化量，亦即温度变化1 oC所引起稳压二极管两端电压的相对变化量，如下式：
它的单位是每摄氏度百分数（%/oC）。一般说来，稳定电压ZT小于5V属于齐纳击穿，其温度系数是负的；稳定电压ZT大于5V的属于雪崩击穿，其温度系数是正的。因此，理论上我们也可以用两个温度系数相反的稳压二极管串联，从而获得温度系数更好的稳压特性，如下图所示：
正温度系数的稳压二极管也可以作为集成芯片过温保护使用，关于此应用可参考文章《串联型稳压电路》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044a0d00307e83f62812cb8c0fc7265e/" rel="bookmark">
			关于android嵌套webview等相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web开发越来越活跃，大多app内嵌套html已经是非常平常的事情，在android中有许多js加载问题及微信支付问题，还有显示问题，以下是我这几天的学习所整理的一些方法，在这里发布以下
打开webview ，url为地址，replace("\\", "") 去除多余的斜杠，android接受json的地址会多出来几条斜杠，这样会造成web无法显示的问题
startActivity(WebActivity.newIntent(this, url.replace("\\", ""),"积分商城")); xlm（主要就这一句，不多BB） &lt;WebView android:id="@+id/webView" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; java代码
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview);webview = findviewbyid（R.id.webview）; iniview();//引用控件 setwebviewbackgrand();//服务，中有加载处理方法和打开微信支付方法 } 博主比较懒，简单的代码就不备注了 private void iniview() { web_view = (WebView) findViewById(R.id.webView); weiuri = new String(stringExtra); WebSettings webSettings = web_view.getSettings();//初始化WebSettings 获取web服务 webSettings.setPluginState(WebSettings.PluginState.ON);//过期方法， webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小 webSettings.setJavaScriptEnabled(true);//启用js webSettings.setBlockNetworkImage(false);//解决图片不显示 webSettings.setAppCacheEnabled(true);//设置是否打开。默认关闭，即，H5的缓存无法使用。 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); webSettings.setAllowFileAccess(true);// 设置允许访问文件数据 webSettings.setSupportZoom(true);//支持缩放 webSettings.setBuiltInZoomControls(true);//进行控制缩放。由于某些原因需要在该activity的onDestroy方法里面调用webView.destroy()。当进入该webview并且进行缩放操作时，退出该activity程序崩溃 webSettings.setJavaScriptCanOpenWindowsAutomatically(true);//自动打开窗口 if (URL.endsWith(".html")) { web_view.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); } else { web_view.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); } webSettings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044a0d00307e83f62812cb8c0fc7265e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05613185325e1c1a975527a2a7f8b94d/" rel="bookmark">
			Fragment的OnkeyDown处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于只有Activity中才存在onKeyDown()方法监听，Fragment并不存在，那如何在Fragment中去监听遥控器的按键事件呢？这里我列出我使用的方法，供大家讨论一下，欢迎指正。
1.首先在BaseFragment实现自己需要的抽象方法
public abstract class BaseFragment extends Fragment { public abstract void onShow(); public abstract void requestFocus(); public abstract void clearFocus(); public boolean isFocus(){return getView().hasFocus();}; //这里的是我们的重点 public abstract boolean onKeyDown(KeyEvent event); } 2.在我们FragMent依赖的Activity中重写onKeyDown()，这里有2种方式进行控制按键，&lt;1&gt;外部法：先在Activity看是否要去响应该按键，响应就返回true,否则不操作；再去Fragment进行判断。&lt;2&gt;内部法：先在Framgent里面根据需要判断按键事件，再在Activity中进行判断，下面我列出第一种方式。
//环境在Activity中 @Override public boolean onKeyDown(int keyCode, KeyEvent event) { boolean ret = false; ret = activityParseOnkey(keyCode); if (!ret) { ret = mCurFragment.onKeyDown(event); //这里的mCurFragment是我们前的Fragment } return ret; } private boolean activityParseOnkey(int keyCode) { boolean ret = false; switch (keyCode) { case KeyEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05613185325e1c1a975527a2a7f8b94d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2262d48ce615667a164427a8fe968fd3/" rel="bookmark">
			Linux 使用Anaconda安装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入指令进行安装：conda install --channel https://conda.anaconda.org/menpo opencv3
测试：
ubuntu下打开python,在终端输入：python
然后：import cv2
如果不报错，那就成功了 ！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b9a8967ec43a49faeaf38f7f697301/" rel="bookmark">
			利用python进行数据分析学习笔记1(pandas入门)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas引入
import pandas as pd Series和DataFrame用的比较多
from pandas import Series,DataFrame pandas的数据结构介绍
Series
类似一维数组的对象，由一组数据和索引组成。
传入一个列表作为Series的参数创建Seires。
obj = pd.Series([4,7,-5,3]) #创建Series 通过Series的values和index属性获取数据和索引。
obj.values obj.index 创建Series时可以创建索引。
obj2 = pd.Series([1,2,3,4],index=['a','b','c','d']) 通过索引获取Series中的值。
通过索引修改Series中的值
除了使用索引，还可以使用布尔型数据作为参数选择数据
也可以像numpy中的array一样进行数学运算。
通过字典来创建Series，键作为索引。
sdata = {'a':1,'b':2,'c':3,'d':4} obj3 = pd.Series(sdata) 传入字典作参数外，还能传入排好序的索引，改变Series的顺序
states = ['d','c','b','a'] obj4 = pd.Series(sdata,index=states) 如果传入的索引中含有字典中没有的键，会显示NaN。
pd的isnull和notnull函数可以检测Series中有无缺失值。
pd.isnull(obj4) pd.notnull(obj4) Series实例也有这种方法。
Series运算时根据索引标签自动对齐数据。
sdata2 = {'a':5,'b':6,'c':7,'d':8} obj5 = pd.Series(sdata2) #新建一个索引名和obj4相同的数组 obj4 + obj5 #将两个数组相加 Series对象和索引都有name属性
obj4.name = 'population' #将Series对象的name属性设置为population obj4.index.name = 'state' #将Series对象的索引的name属性设置为state Series的索引通过赋值可以原地修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b9a8967ec43a49faeaf38f7f697301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee6bf904f8be7acb04c487569314cb8/" rel="bookmark">
			王佩丰数据透视表（六到十一讲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态引用数据源区域。
结合新建名称和offset函数，设置一个动态数据区域。
插入数据透视表时引用这个名称即可。
Gerpivotdata函数可以动态地引用数据透视表中的数据，默认是开启的。
举个例子，在透视表外引用单元格B5，会显示
即动态引用常熟区域的彩盒金额，此后如果常熟和彩盒的顺序改变了，该单元格也会动态调整，引用的数据仍然是常熟的彩盒。
这个动态引用功能可以在数据透视表工具栏的分析——选项处的生成Gerpivotdata处进行设置。
关闭此功能后再引用数据透视表中的数据就不会动态调整了，会引用固定位置的数据。
上面的Getpivotdata函数的第二个参数表示A3单元格所在的数据透视表，第一参数表示值字段，后面的参数表示字段和标签。
练习：通过结合数据有效性和Getpivotdata做出下面的结果。
先通过数据有效性建立序列，再在第四列中写上公式即可。
参数一后面&amp;""将数值转为文本格式。
创建单页字段组合。
有时需要总结好几个工作表中的数据。
比如要对三个月的数据进行汇总。
顺序按下Alt加d加p，可以打开数据透视表和数据透视图向导。
默认设置数据源的第一列是透视表的行字段，其他列都是列字段，通过切换页字段可以显示不同工作表的数据。
不过这样做出来的透视表自由度小。
自定义页字段
向导中将创建单页字段改成自定义页字段。
多文件合并
现在有两个文件，南京和苏州的数据，每个文件有三个工作表。
方法和前面差不多，向导处选自定义页字段
得到的透视表中有城市和月份两个页字段。
在上面的创建单页字段和自定义页字段中，可以结合新建名称，这样创建的透视表是动态的。
比如将一个文件中的三个工作表中的数据都用offset新建名称
在相同中选定区域时直接使用。
若源数据发生增删，刷新透视表即可。
将源数据从左图调整成右图
通过左图的数据来创建单页字段，建好透视表后双击透视表的右下角即可。
根据外部文件创建透视表
打开属性，有编写sql语句的地方。通过sql语句可以获取指定数据。
select 日期,产品类别,金额 from [数据$]
表示从数据文件中获取指定的三列。
如果数据文件中有三个表
select * from [苏州$] union all select * from[无锡$] union all select * from [昆山$]
表示获取三张表中的所有数据。
可是表中没有城市这一列，而又需要使用到城市列，可以通过sql语句构建一个。
select "苏州" as 城市,* from [苏州$] union all select "无锡" as 城市,* from [无锡$] union all select "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee6bf904f8be7acb04c487569314cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f488510f1e76735556bb70bab8adfadd/" rel="bookmark">
			王佩丰excel2010基础教程学习笔记（第一讲到第五讲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全部重排：打开两个或以上excel表格时，通过全部重排可以全部呈现在屏幕上。如将三个excel表格垂直并排。
选择视图中的全部重排。
再选择垂直并排。
冻结窗格：此选项可以冻结首行首列，或者冻结选中单元格的左侧的列和上侧的行。
填充柄：在单元格中输入数据，右键单元格右下角往下拉会出现填充柄。
在单元格内按Alt加Enter是换行的操作，有时候要做表头的时候会用到。
分列工具：通过选择相应的分隔符可以将一列数据分列。
比如将一些用"，"分隔的数据分列。
分列还可以将数组在文本和数值间进行转换（很强悍）。
查找和替换：常规操作不写了，要注意查找替换中*表示任意数量个字符，?表示一个任意字符，~表示转义符。
通过定位条件可以精准地选中指定对象。
进行如下转换：
首先将左图取消合并后居中，通过定位条件选中空值，输入等号，然后按ctrl加方向键↑，再按ctrl加enter即可。
排序：有常规升降序，还有自定义排序。
可以利用排序完成工资条的制作。
在右侧加一列数字，对数值进行排序即可。
页面布局——打印标题处可以设置打印时每一页都有表头。
筛选：普通筛选没啥好说的。
高级筛选
设置条件区域。
表示且。
表示或。
分类汇总：使用前记得先排序。
如果要分多类汇总，记得去掉"替换当前分类汇总的勾"。
如果要复制汇总数据，需要先通过定位条件选中可见单元格再进行复制，否则会将所有数据复制过去。
通过分类汇总可以将所属区域相同的单元格合并起来.
将所属区域分类汇总，汇总方式为计数
通过定位条件选中A列的空格，合并，然后删除分类汇总，最后用格式刷将A列的格式传递给B列。
数据验证可以限制单元格的输入的内容。
通过设置序列可以建立下拉菜单。
自定义可以传入公式，可以关联其他单元格的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498a9c77ded43b955ebdcd9c4f32c99e/" rel="bookmark">
			STM32 PA0 PAB0 PC0 共用一个中断线的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于：https://blog.csdn.net/yidefurende/article/details/70853071
在最近的一个项目中，用了很多个外部中断线，刚开始并没有注意外部中断 的个数，天真的以为所有IO口都可以配置为中断，然后画板子就直接连接了19根外部中断，等写程序的时候发现，PA0 PB0 PC0这些共用一个外部中断线，注意是共用，根本就不能同时存在，同一时间只能有一个IO使用这个中断线，初始化的时候谁是最后初始化的，那么这根中断线就分配给了谁，这个EXTI9_5这个中断也是那样，只不过是共用的中断函数，而不是共用一个中断线，这个可以中断之后查询是哪根线触发了，而不是PA9 PB9同时使用这根中断线，好了，这回我是用程序进行验证的，看了很多资料，众说纷纭，这回是验证真伪了，希望有需要的人不要出现我这种低级错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dee317d6412fb8c4d8d8fb2f4ddc84e/" rel="bookmark">
			树莓派--bcm2835 library (2) 交叉编译BCM2835
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上文中，按照guide, 在树莓派目标板上install bcm2835.
因为bcm2835是用户空间应用，所以可以在宿主机上交叉编译，生成binary后在树莓派执行
按照guide: Installation This library consists of a single non-shared library and header file, which will be installed in the usual places by make install
# download the latest version of the library, say bcm2835-1.xx.tar.gz, then: tar zxvf bcm2835-1.xx.tar.gz cd bcm2835-1.xx ./configure make sudo make check sudo make install 这里我们不需要安装，只要make生成.a库就可以。
交叉编译：
./configure -host=arm CC=arm-linux-gnueabihf-gcc-4.9.3 ar=arm-linux-gnueabihf-ar
make
在make时出现错误
Bcm2835-1.45$ make CDPATH="${ZSH_VERSION+.}:" &amp;&amp; cd . &amp;&amp; aclocal-1.13 -I m4 /bin/bash: aclocal-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dee317d6412fb8c4d8d8fb2f4ddc84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd91e74107316fafc5aeffa70095b997/" rel="bookmark">
			codeforces 999D Equalize the Remainders
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.elijahqi.win/archives/3822 看做一个有向环
考虑我们其实从每个点出发如果采用最优策略那么一定都是一样的 那么不妨来看
我一遍扫描一边带着前缀和 如果遇到是小于平均值的我优先分配给他我最前面的
注意扫描一遍是不够的 但最多两遍即可 因为最优策略不可能绕一圈以上
#include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline char gc(){ static char now[1&lt;&lt;16],*S,*T; if (T==S){T=(S=now)+fread(now,1,1&lt;&lt;16,stdin);if (T==S) return EOF;} return *S++; } inline int read(){ int x=0,f=1;char ch=gc(); while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();} while(isdigit(ch)) x=x*10+ch-'0',ch=gc(); return x*f; } const int N=2e5+10; const int inf=0x3f3f3f3f; int n,m,s[N]; vector&lt;int&gt; q[N];queue&lt;int&gt; pd; ll a[N],ans; inline void add(int p,int sta,int ed){ if(sta&lt;ed) a[p]+=ed-sta,ans+=ed-sta; else{ a[p]+=ed+1+m-1-sta;ans+=ed+1+m-1-sta; } } int main(){ // freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd91e74107316fafc5aeffa70095b997/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/454/">«</a>
	<span class="pagination__item pagination__item--current">455/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/456/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>