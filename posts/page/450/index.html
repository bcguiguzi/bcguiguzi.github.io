<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c1a94dceacec41ce375d06824c744c/" rel="bookmark">
			一个图的连通子图个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给出一个无向图，输出图中连通分支的个数。无向图的连通分支是一个子图，因此在子图两个节点之间至少存在一个路径。 Example：
输入：给出一个连通图的二维数组 01000 10100 01000 00000 00000 输出：联通子图的个数 解析：
从二位数组的第一行开始遍历，只遍历上三角（因为无向图是对称的），遍历第i行如果map中没有i把i加入到map中，然后对第i行的每个值进行遍历，当grape[i][j]的值为1的时候，把j放入堆栈中，遍历完第行之后，对堆栈中的数据（j）出栈，把其放入map中，然后对第j行进行遍历，按照这个方式直到堆栈为空，count++，计算出了一个联通子图。 代码1：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;stack&gt; using namespace std; int getStack(vector&lt;vector&lt;int&gt; &gt; &amp;grape, int i, int n, stack&lt;int&gt; &amp;s) { for (int j = i; j &lt; n; ++j) { if (grape[i][j] == 1) s.push(j); } return s.size(); } int getChildGrape(vector&lt;vector&lt;int&gt; &gt; grape) { int n = grape.size(); if (n == 0) return 0; map&lt;int, int&gt; m; stack&lt;int&gt; s; int count = 0; for (int i = 0; i &lt; n; ++i) { if (m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c1a94dceacec41ce375d06824c744c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b657cc8cf56770e8fe1dfd945eee79b6/" rel="bookmark">
			maven中net.sf.json报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用json Xml解析 做微信支付的时候 ，用到工具类
import net.sf.json.xml.XMLSerializer; maven配置如下
&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 引入包一直报错 ，找不到jar 程序包net.sf.json不存在
在网上看了好久，终于找到原因了，net.sf.json添加的时候需要添加jdk的版本号，第一次听说，于是有了下面的配置
&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; 然后编译通过了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78576ccb83cfd75f03450bab9415dd12/" rel="bookmark">
			关于LIS和一类可以用树状数组优化的DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主写得很详尽：关于LIS和一类可以用树状数组优化的DP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86da9b1739fd51e3519f591fd087c0f/" rel="bookmark">
			Java 多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Executors类 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
public static final ExecutorService pool = Executors.newFixedThreadPool(10); 创建一个容量10条的线程池 执行线程
pool execute(new TestThread()); 创建线程的2中方法
Thread public class TestThread extends Thread{ @Override public void run() { //具体业务 } } Runable public class TestThread implements Runable{ @Override public void run() { //具体业务 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ac57698180f7c1950ff05ca1866dd0/" rel="bookmark">
			vs 生成事件,将dll复制到目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用命令 将生成的dll移动到某一指定的位置
以下内容是具体宏说明：
VS预生成事件命令行 和 生成后事件命令行
宏说明
$(ConfigurationName) 当前项目配置的名称（例如，“Debug|Any CPU”）。
$(OutDir) 输出文件目录的路径，相对于项目目录。这解析为“输出目录”属性的值。它包括尾部的反斜杠“\”。
$(DevEnvDir) Visual Studio 2005 的安装目录（定义为驱动器 + 路径）；包括尾部的反斜杠“\”。
$(PlatformName) 当前目标平台的名称。例如“AnyCPU”。
$(ProjectDir) 项目的目录（定义为驱动器 + 路径）；包括尾部的反斜杠“\”。
$(ProjectPath) 项目的绝对路径名（定义为驱动器 + 路径 + 基本名称 + 文件扩展名）。
$(ProjectName) 项目的基本名称。
$(ProjectFileName) 项目的文件名（定义为基本名称 + 文件扩展名）。
$(ProjectExt) 项目的文件扩展名。它在文件扩展名的前面包括“.”。
$(SolutionDir) 解决方案的目录（定义为驱动器 + 路径）；包括尾部的反斜杠“\”。
$(SolutionPath) 解决方案的绝对路径名（定义为驱动器 + 路径 + 基本名称 + 文件扩展名）。
$(SolutionName) 解决方案的基本名称。
$(SolutionFileName) 解决方案的文件名（定义为基本名称 + 文件扩展名）。
$(SolutionExt) 解决方案的文件扩展名。它在文件扩展名的前面包括“.”。
$(TargetDir) 生成的主输出文件的目录（定义为驱动器 + 路径）。它包括尾部的反斜杠“\”。
$(TargetPath) 生成的主输出文件的绝对路径名（定义为驱动器 + 路径 + 基本名称 + 文件扩展名）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ac57698180f7c1950ff05ca1866dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82fc47f56c804d018ce8da7c030533e/" rel="bookmark">
			HDU 6432 Problem G. Cyclic (容斥&#43;线性求组合数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem G. Cyclic Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others)
Total Submission(s): 322 Accepted Submission(s): 225
Problem Description
Count the number of cyclic permutations of length n with no continuous subsequence [i, i + 1 mod n].
Output the answer modulo 998244353.
Input
The first line of the input contains an integer T , denoting the number of test cases.
In each test case, there is a single integer n in one line, denoting the length of cyclic permutations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82fc47f56c804d018ce8da7c030533e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777cf65ca66d0d43c0c967984826b8d2/" rel="bookmark">
			程序员命名网站 codelf， 使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站： http://unbug.github.io/codelf
Why? 这里有Sublime Text插件, Atom 插件, Codelf Chrome App，For WebStorm 但如果你用其他编辑器，那还有另一种方式是灰常灰常的方便的。
Result? 效果就是你在Chrome 的地址栏：
输入”E” 按 “Tab”键 输入想搜索的关键字，比如”我想要“ 按Enter回车就会立即打开Codelf并搜索出结果 image How? Chrome 的地址栏相当强大，我们知道，在地址栏输入随意关键字回车就能自动使用默认的搜索引擎搜索出结果，连网址都不用输入。默认搜索引擎一般是 Google,如果你想保留默认搜索引擎又想通过地址栏使用其他搜索引擎，比如百度，你只要先输入”B”，然后按“Tab”键，然后你就会发现“B”变成了百度，这时你输入任意关键字回车搜索，结果页面就是百度了。 来，我们只需要几步，我们就能将 Codelf 添加到 Chrome：
打开Setting（设置） 点击Manage search engines.. （管理搜索引擎） image 如果列表里太长，滚动到底部会有一个添加的入口，三个输入框依次输入：Codelf；E 和 http://unbug.github.io/codelf/#%S。然后点击Done(完成)。 image 最后你就可以按“Result”里说的四步使用了。
转载自 https://github.com/unbug/codelf/issues/6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3ae0dbea9d810d5510947b7d9fd03d/" rel="bookmark">
			scala的函数式编程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
将函数作为值
匿名函数
函数的高级用法
将函数作为参数
将函数作为返回值（很重要）
引言 函数是scala中最重要的部分，有人愿意称“函数式scala中的一等公民”。也就是因为函数才使得scala更加简洁、优雅、又耐人寻味，总之，函数式编程在scala中是一等一的重要，使用scala开发的各类框架都存在这大量函数，如果想去了解、阅读Spark源码，函数式编程这一关必须要过。吹了好几行的废话，主要意思就是函数在scala中是非常重要的。下面进入正题。
将函数作为值 scala的语法规定，将函数赋值给变量时，必须在函数后面加上空格和下划线。
//正常声明一个带有一个字符串类型参数，并返回Unit类型的方法 scala&gt; def sayHello(name : String) = println("hello,"+name) sayHello: (name: String)Unit //将上述方法转换成一个函数，方法后面加上空格和_转变成函数 scala&gt; val sayHelloFun = sayHello _ sayHelloFun: String =&gt; Unit = $$Lambda$1049/1571707504@210a26b //函数的调用 scala&gt; sayHelloFun("liumingxin") hello,liumingxin 匿名函数 scala中可以不需要给一个函数命名，就像“y = ax + b”我们该叫它啥？其实很多时候函数并不需要一个名字，名字只是一个代号。
匿名函数的创建规则：(参数 : 参数类型) =&gt; 函数体
方法的创建规则：def 名称(参数 : 参数类型) = 函数体 这里再提出方法的定义原因有二：1、回顾方法的创建规则；2、对比函数，理解函数和方法创建时的区别“=”和“=&gt;”需要注意
scala&gt; Array(1,2,3,4).map((x : Int) =&gt; x * 3) res3: Array[Int] = Array(3, 6, 9, 12) //可以将函数参数使用花括号代替圆括号，这样便于区分 scala&gt; Array(1,2,3,4).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc3ae0dbea9d810d5510947b7d9fd03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323d80a3bd2a827a82abacc24ccb6aea/" rel="bookmark">
			PAT乙级1001 害死人不偿命的(3n&#43;1)猜想 (java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卡拉兹(Callatz)猜想： 对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。 输入 每个测试输入包含1个测试用例，给出一个不超过1000的自然数n的值。
输出 输出从n计算到1需要的步数。
输入样例 3
输出样例 5
源代码 import java.util.Scanner; public class Main{ public static void main(String[] args) { Scanner in = new Scanner(System.in); int num = in.nextInt(); int count = 0; if(num &lt;= 1000) { while(num !=1) { if(num % 2 == 0) { num = num/2; count++; } else { num = (num * 3 + 1)/2; count++; } } } System.out.print(count); } } 注意事项 这里无需对输入的数进行范围限制，测试点都小于等于1000，加上也无错 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ceb9f0011a2f8fe1d3f1675d3e4d340/" rel="bookmark">
			[学习][Math](几何)欧拉公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V-E+F=2
在平面中：V为顶点个数，E为边数，F为区域数
在简单几何体中：V为顶点个数，E为边数，F为面数
转载于:https://www.cnblogs.com/lllxq/p/9513955.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4472582251363290a935bc06e25084de/" rel="bookmark">
			Spring Session Data Redis实现session共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言
在开发中遇到一个关于用户体验的问题，每次当运维进行更新重启服务器时，都会导致会员平台中已登录的用户掉线。这是因为每个用户的会话信息及状态都是由session来保存的，而session对象是由服务器创建，并把session的Id以cookie的形式发送给客户端浏览器的（每个会话都有一个单独的sessionID）。当这个对象超过一定时间没有被使用或者服务器重启时，对象就会被销毁，也就导致了用户掉线。
2.解决办法
在解决问题过程中发现，只要记住了刚才用户的sessionID，重启服务器后仍使用原来的id，就不会掉线，也就是说要保证session不被改变才可以保持用户的登录状态。在这里使用了Spring Session Data Redis来实现session的共享（redis：高速缓存数据库），也就是说使用redis对session进行一个持久化操作（用mysql等数据库来单独存储session有点浪费了，速度也没有redis快），当服务器重启时，可以从redis中反序列化取出session，重新获取用户会话信息。
简要配置步骤：
（1）pom.xml加入依赖：spring-session-data-redis、spring-session，当然前提要有spring（4.3.5）、redis的依赖（redis使用了3.0版本）
1 &lt;dependency&gt; 2 &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; 3 &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; 4 &lt;version&gt;1.3.2.RELEASE&lt;/version&gt; 5 &lt;/dependency&gt; 6 &lt;dependency&gt; 7 &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; 8 &lt;artifactId&gt;spring-session&lt;/artifactId&gt; 9 &lt;version&gt;1.3.2.RELEASE&lt;/version&gt; 10 &lt;/dependency&gt; （2）applicationContext.xml配置文件中增加RedisHttpSessionConfiguration（下面是单独的配置文件，然后import进去）
1 &lt;?xml version="1.0" encoding="UTF-8"?&gt; 2 &lt;beans xmlns="http://www.springframework.org/schema/beans" 3 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 4 xmlns:p="http://www.springframework.org/schema/p" 5 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 6 &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; 7 &lt;property name="maxIdle" value="0" /&gt; 8 &lt;property name="maxTotal" value="20" /&gt; 9 &lt;property name="maxWaitMillis" value="1000" /&gt; 10 &lt;property name="testOnBorrow" value="true" /&gt; 11 &lt;/bean&gt; 12 13 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4472582251363290a935bc06e25084de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1aab38bc32b2f7a3cfe71a1c0133593/" rel="bookmark">
			HUSTOJ特判程序Special Judge使用方法整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021.08.12更新：最新优化的编写方法请参见https://blog.csdn.net/winter2121/article/details/104901188
Special Judge
通常的ACM题目包括以下几项内容：题目描述(Description)、输入描述(Input)、输出描述(Output)、样例输入(Sample Input)、样例输出(Sample Out)，在后台则包括测试输入(Input Data)和测试输出(Output Data)两项。在评测用户提交的程序正确与否时，系统会将样例输入和测试输入重定向作为程序的标准输入，通过判断程序对应的输出是否与期待的输出完全相同，来判断解答是否正确。
对于同一道题目，用户可能使用各种不同的方法来解答，所以对于某些特殊的题目，其结果可能不唯一，但都符合题目要求。此类题目就需要进行特判(Special Judge)。HUSTOJ便提供了特判功能。
这些题目主要有两种：
1、答案不唯一。
2、控制精度。题目要求输出精度误差在某eps之内。
【使用方法】
第一步，在添加题目时，Special judge勾选Y，以打开系统的特判命令。
第二步，编写spj代码，模板中标注了spj代码区域，自行根据题目要求编写。注意文件名最后以.cc为后缀。
【模板】控制精度为例，对比输出文件和用户结果文件，误差不超过1e-5则Accepted。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;set&gt; #include&lt;utility&gt; using namespace std; int main(int argc, char* argv[]) { FILE * f_in=fopen(argv[1],"r");//测试输入 FILE * f_out=fopen(argv[2],"r");//测试输出 FILE * f_user=fopen(argv[3],"r");//用户输出 int ret=0; //AC=0,WA=1 /*****spj代码区域*******/ int T,n; fscanf(f_in,"%d",&amp;T); while(T--) { double a,b; int n; fscanf(f_in,"%d",&amp;n); fscanf(f_out,"%lf",&amp;a); fscanf(f_user,"%lf",&amp;b); if(fabs(a-b)&gt;1e-5) //WA { ret=1; break; } } /*****spj-end********/ fclose(f_in); fclose(f_out); fclose(f_user); return ret; } 【模板解释】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1aab38bc32b2f7a3cfe71a1c0133593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce1bf5fc18d6cbb4021eea0ca94bbde/" rel="bookmark">
			局域网文件传输（Qt&#43;服务器客户端&#43;多线程&#43;TCP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章为Qt编程学习过程编写，仅供参考共同学习进步，请勿有其他用途！！！
Qt版本为Qt Creator 5.7.0
在文章中只展示界面设计以及简单介绍，源代码可在https://github.com/CMwshuai/NetworkFileTransfer.git进行下载。
文章中对于代码部分不做解释，源代码中有详细的注释。
1、服务器端主要使用TCP和多线程进行编程。可以同时接受多个客户端的连接，进行文件的传输。支持文件目录的导入，删除。
界面如图所示：
2、客户端支持对服务器端的文件进行同步，支持下载服务器端指定目录下的文件。
界面如图所示：
希望需要的人可以从中学到东西，可以对不足的地方或有什么宝贵的建议可以提出，大家共同学习进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6e567958cd3bd56fbb706b0c07989c/" rel="bookmark">
			VLAN层次与特点概念性总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先解释两个词： 端口（port）：在通信设备中，一般指二层口，该口用于隔绝广播域，基于MAC地址转发，但本身不能设置任何地址； 接口（interface）：在通信设备中，用于区别二层的端口，指的是三层口，该口可以配置IP地址，基于IP路由转发。
在传统的局域网中，几个至几十个交换机连接一个大的局域网，一个局域网中的主机台数可能达到上千台，那么由于交换机只能隔绝冲突域，一个端口是一个冲突域，而不能隔绝广播域，会导致局域网内的ARP广播占用大量带宽影响性能，甚至影响网络的正常使用。此外成百上千的计算机在同一个局域网中也会影响网络安全性。 VLAN（Virtual Local Area Network，虚拟局域网）技术，在交换机不能隔绝广播域并且路由器转发性能过低且价格昂贵，需要交换机能够将这许多主机划区域管理的迫切需求下应运而生。
1、二层VLAN： VLAN技术本是二层技术，用来隔绝广播域，限制广播帧对于局域网带宽的影响。因为VLAN在二层，理论上VLAN不可以设置IP，不同VLAN之间不能直接通信，将某些端口加入到VLAN中，那么这些端口所连接的主机也就不能和其他VLAN中的主机进行通信。要想不同VLAN的主机能够通信，则必须借助路由器来进行路由转发。
2、三层VLAN： 既然有了路由器可以实现VLAN之间通信，为什么还要有三层VLAN和三层交换机？
①首先是因为路由器是一个网络层设备，其主要的功能并非转发报文，而是进行路由选择，其转发是基于CPU层面的软件转发，性能效率远远低于基于交换芯片的交换机硬件层面转发。三层交换机集合了二层交换机的VLAN技术和路由器的路由转发功能，其支持VLAN interface，即VLAN接口，也就是VLAN有了逻辑接口，也就有了接口所能配置IP的能力，三层VLAN由此产生。我们给VLAN的逻辑接口配置ip地址，该IP地址就相当于划入到VLAN的端口所连接设备的网关，以实现VLAN间路由。
②其次，路由器的物理接口数目是比较少的（太多的话，其路由转发处理效率跟不上，还是浪费资源），连接的VLAN个数也就是有限的。假设一个三层交换机有48个端口，使用二层VLAN，划分为24个VLAN，每个VLAN2台机器。有一个4个广域网口的路由器，则路由器最多只能连通4个VLAN，其余VLAN想要和其他VLAN通信，则必须再来几个甚至十几个路由器。 而三层交换机可以划分VLAN interface的个数理论上可达无限个，但实际限制为最多4096个，相比于寥寥数个路由接口也是优略很明显了。如此多的VLAN不仅满足可以随意划分VLAN interface，隔离需要隔离的设备机器，此外在隔离的同时，如果想和某一VLAN interface通信不需要添加任何其他设备，只需要给该VLAN interface和其他VLAN interface配置IP地址，就可以进行高效率的数据转发通信。（下面一幅草图很形象的描述了一台交换机上划分VLAN interface的“随意性”）。
总结：三层交换机因为其VLAN interface，拥有高性能的二层转发功能，且具备三层路由（还有一次路由多次转发等优点）功能。不仅隔绝广播域，抑制了广播风暴，也增加了网路安全性，还有很高性价比，可以说是在校园网、城域网等大型局域网中起到了中流砥柱的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8b68e788077aa4f0f72af64c8c5d84/" rel="bookmark">
			Python 字符串格式化输出的3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. % print ('我叫%s, 身高%scm' % (name,height)) ** 传入的值为元组，依次填充
%s ：占位符 str() %d-：十进制 整数 %x ： 十六进制 %f ：浮点型 指定长度：
%5d 右对齐，不足左边补空格
%-5d - 代表左对齐，不足右边默认补空格
%05d 右对齐，不足左边补0
浮点数：
%f 默认是输出6位有效数据， 会进行四舍五入
指定小数点位数的输出 %.2f---保留小数点后2位
'%4.8f' 4代表整个浮点数的长度，包括小数，只有当字符串的长度大于4位才起作用.不足4位空格补足，可以用%04.8使用0补足空格
2. format 特性：字符串的format方法
顺序填坑：{} 占位符 print('姓名是 {}，年龄是 {}'.format('Tom',20)) 输出： 姓名是:Tom，年龄是:20 下标填坑： print('姓名是:{1}，年龄是:{0}'.format(20,'Tom')) 输出： 姓名是:Tom，年龄是:20 变量填坑:'名字是：{name}，年龄是：{age}'.format(name ='tom',age = 16) print('姓名是:{name}，年龄是:{age}'.format(name='Tom',age=20)) 输出： 姓名是:Tom，年龄是:20 变量中使用 name = Ada age = 20 print('Name is {name},age is {age}'.format(name=name,age=age)) {:5} 指定输出长度=5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8b68e788077aa4f0f72af64c8c5d84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a684697f3b886965f496dc80749a7b/" rel="bookmark">
			处理swagger报错Could not resolve pointer: /definitions/List does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理swagger报错Could not resolve pointer: /definitions/List does not exist ### 使用swagger2.8.0 @ApiImplicitParam dataType是 List的时候 进入swagger-ui.html会报标题那样的错误，将版本升级到最新的2.9.2 错误没有了。
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563f721ae111137348dc4b1b5a856948/" rel="bookmark">
			发现fastcgi配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.jianshu.com/p/a28b6ecd41a8
自从去年6月份毕业以后，从前端转到了后端，也就很久没有写文章记录了。
[原文地址:掘金](https://juejin.im/post/5af9276b5188254287734196)
### 前情提要：
测试服务器被新人误操作直接删除了根目录，奈何只能重装服务。结果导致微信扫码支付时二维码显示不出来。
### 已知情况：
测试环境访问地址为：http://www.excample.com:8067
部署环境：Nginx + PHP
服务器做过路由端口映射处理，询问运维人员，得知是将外网的8067映射到内网的80端口
### 跟踪调试步骤：
1、通过谷歌开发工具查看,获取的 SERVER_PORT 不正确，正确为8067
![谷歌开发工具](http://upload-images.jianshu.io/upload_images/2376873-edb6856007c4a7ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
2、既然得知是端口获取的问题,而且代码没有改动,是服务器重新部署的缘故导致的,所以想来也是配置的问题。
一开始怀疑是nginx的配置
!['nginx配置'](http://upload-images.jianshu.io/upload_images/2376873-7bd40d3a9e4db9d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
把监听的80端口改成8067，结果不能访问。
那是当然，毕竟路由端口是映射到了内网的80而不是8067。
3、排除了上一步，接下去这最关键的想法折腾了我好久。我想怎么让 server_post 拿到的是外网端口8067而不是内网端口80。
接下去就是各种百度，这过程中让我学习到了一个知识点：php中的 server 全局变量是怎么获取的？
nginx的核心模块中有些内置变量，如下图这些：
![nginx内置变量](http://upload-images.jianshu.io/upload_images/2376873-f2b46c0f5634c24e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
而且是以fastcgi模式运行PHP，所以nginx会将这些变量传递给fastcgi，而fastcgi又会将这些作为PHP的全局变量
![image](http://upload-images.jianshu.io/upload_images/2376873-509f92c00dacdda7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
到这里，我才发现还有fastcgi的配置之说。那就仔细去看看fastcgi的配置。
![image](http://upload-images.jianshu.io/upload_images/2376873-3ab1a4929e92739b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这下可好，那我把 $SERVER_PORT 直接改成8067，获取到的确实为8067了，二维码图片也出来了。可是再想想，这样改动不合理，假如端口映射规则修改了，岂不是还要改配置。所以这个方法不可行，另寻他法。
4、开始怀疑服务器重新部署后路由映射规则也被改动了
既然nginx内置变量$server_port只能拿到nginx配置中的的监听端口。那么server段中的监听怎么着也得改成8067，要做的就是将路由映射修改为：外网的8067映射到内网的8067。
至此，问题解决了。一直以为路由映射规则没有改动，就一直死磕在了nginx和fstcgi的配置上了，耗费了太多时间。不过也好，深入了解了 php 中 server 等一些全局变量的来源。
&gt;不积跬步无以至千里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6358f70ed0944e0477600dfee4c9bb8a/" rel="bookmark">
			微信 H5支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文连接：https://www.jianshu.com/p/a6d9fe43c995 这几天做WAP网站，涉及到微信支付和支付宝支付，在开通应用前只是针对技术文档做了预研，了解下程序的逻辑实现。结果导致后期开发中支付宝很顺利，毕竟API很强大。微信有些坑要填补，真是悲催。
&gt;第一个坑：浏览器兼容问题
![回调页面](https://upload-images.jianshu.io/upload_images/2376873-3a35819cdb02a88c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
逻辑是这样的：一开始弹框是没有的，用户点击右下角的“确认支付”，显示弹框，跳转到微信。
重点是后面的操作，在微信中点击“取消”，有些浏览器回退后刷新了这个页面，导致弹框又没有了。
当时我想了个简单的办法：前端存储一个标记值在localStorage中，点击弹框中的按钮后，清除该值。
这是个幼稚的想法~假如用户没有点击弹框中的按钮，直接关掉页面或者其他操作，岂不是这个localStorage一直在，下次进入这个页面弹框立马就出来了。
所以我最终解决的办法是将该页面地址作为回调地址redirect_url传递过去，并且携带标记参数，是否需要弹出提示框。
&gt;第二个坑:回调地址提早请求了
官方文档这样说明：
![微信API文档](https://upload-images.jianshu.io/upload_images/2376873-de77e2c5d6987f46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
回调指定页面的操作可能发生在：
1、支付中间页调起客户端超过5秒
2、点击“取消支付”或“完成”
然而通过打日志实践证明，当我成功调起微信收银台没几秒，还没点击"取消”或者支付，就已经请求了我的回调地址。
&gt;第三个坑：chrome、猎豹浏览器 回调到了 safari
第一次发现这个坑有点搞笑,明明在谷歌浏览器访问WAP网站进行支付，成功跳转到微信收银台，点击左上角的取消，莫名其妙的到了safari浏览器中，真是一趟跨界的旅行呵~
发现这个问题后，就去研究饿了么，美团的H5支付。
发现和我们平台有不同点：饿了么是直接schema调起的，而我们平台是从支付中间页再通过schema调起的微信。然后在网上有看到一篇文章，正解我疑惑，是接口新版和旧版的区别 =&gt; [原文地址通道请戳这里](https://www.cnblogs.com/chenguiya/p/7464593.html)
那最终的解决办法是只能随它跳转到safari了，回调页中去除了登录校验，保证之后的流程能正常走完，管它在哪个浏览器里。
&gt;第四个坑：授权域名
当我在开发环境完成了开发，提测后，发现测试环境支付提示如下：
![微信API](https://upload-images.jianshu.io/upload_images/2376873-3852c30a83aecfcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这才发现后台有授权域名的设置，这个问题也是自己想当然了，之前做过微信的PC扫码支付和APP支付，不需要填写类似的东西，所以就没注意，真是缺乏经验啊~吃了个教训
最多只能配置5个授权域名，允许顶级域名配置。
但是考虑到我们自身平台的特殊性，一份代码部署在一台服务器上，然而有几十个域名，大部分是符合XXX.ABC.cn的规则，有些是自定义的域名。怎么着都已经超过5个了。
这还怎么玩，回家睡觉吧~
不行不行，工作重要，工资重要，钱重要，还是改代码吧~
因为微信自己说了他是根据referer来判断的。那么就伪造referer头
只能想到curl了。把主域名作为referer头请求mweb_url,获取到中间页的html，再新写一个方法，用来从主域名中重定向回请求时的域名回调页。
```
$orderno = "123456";
$money = 1; //单位分 TEST
$client_ip = get_client_ip(0,true);
require_once "./Wxpay/lib/WxPay.Data.php";
require_once "./Wxpay/lib/WxPay.Api.php";
$scene_info ='{"h5_info":{"type":"Wap","wap_url":"","wap_name":""}}';//场景信息 必要参数
//步骤二，调用统一下单接口 unifiedOrder
$body = '支付订单';
$input = new \WxPayUnifiedOrder();
$input -&gt; SetBody($body);
$input -&gt; SetAttach($body);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6358f70ed0944e0477600dfee4c9bb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22aeda2e5ed349914038f2aa45446825/" rel="bookmark">
			项目管理经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 序言：项目管理经验，这篇文章根据实际出发，站在一个项目经理的角度，充分考虑甲乙双方利益，如何成功交付，如何保证质量，如何规避风险等等，不仅是给项目经理看的，也是给每个开发人员看的，开发有时候也需要具备相应的素质，不仅仅是写代码，偶尔也会赶鸭子上架，应付客户，分析需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15b868c4159f6200bff0ec6f57fe751/" rel="bookmark">
			错误贴 | iOS pod报错 /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pod 报错
-bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory MacOS 升级后pod 出现的问题
1、更新gem：sudo gem update –system
2、删除gem源：gem sources –remove https://ruby.taobao.org/
3、修改gem源：gem sources -a https://gems.ruby-china.org
4、查看gem源是否是最新的：gem sources -l
5、升级cocoapods：sudo gem install -n /usr/local/bin cocoapods –pre
6、查看升级后的cocoapods版本：pod –version
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/449/">«</a>
	<span class="pagination__item pagination__item--current">450/516</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/451/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>