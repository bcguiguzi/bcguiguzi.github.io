<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>指针的基本概念 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="指针的基本概念" />
<meta property="og:description" content="1.指针，变量的指针，指针变量 由于通过地址能找到所需的变量单元，因此可以说地址“指向该变量单元”。在C语言中，将地址形象化的称为“指针”，一个变量的地址称为该“变量的指针”，意思是通过它能找到以它为地址的内存单元。指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。
在32位程序里，所有类型的指针的值都是一个32位整数。因为32位机中的程序里内存地址全都是32位长，即sizeof(pointer)的值总为4—指针本身占据了4个字节的长度。在64位机中，sizeof(pointer)的值为8。
如果一个变量专门用来存放另一个变量的地址，则它称为“指针变量”，我们说它用来存放指针。定义了一个变量p，它用来保存另一个变量var的地址，这样的p就是指向var的指针变量。
指针变量也是变量，其定义格式为：类型标识符 *指针标识符。*号为地址解析符，表示“指向……的指针”，可以左结合，也可以右结合；其中类型标识符为指针所指向的类型。例如：
char *pc; pc具有char *类型，即pc指向char类型的变量，以1个字节为一个存取单元。
int *pi; pi具有int *类型，即pi指向int类型的变量，以4个字节为一个存取单元。
float* pf; pf具有float *类型，即pf指向float类型的变量，以4个字节为一个存取单元。
char *pc=&#34;hello&#34;;&lt;==&gt;char *pc;pc=&#34;hello&#34;;
2.指针变量的引用 C语言中对指针变量的引用主要通过运算符“&amp;”和“*”来实现的。
&amp;——取变量的地址，取指针。
*——取指针变量所指向的变量的值，解引用。
观察下面的程序段：
int x,y,*p; //定义整型变量x、y和整型指针变量p x=168; //初始化x p=&amp;x; //初始化p，存储变量x的地址 y=*p; //初始化y，解引用p 上述内存变化情况如图所示：
若int a=168; int *p=&amp;a;则*&amp;a表示变量a本身，而&amp;*p=&amp;a,表示去变量a的地址。
3.指针的算术运算 指针是有类型的，故指针的算术运算(&#43;,-)是以类型的size为单位“1”的偏移。
char型数组char cArray[5] = {1,2,3,4,5};，假设 char* pc = cArray(&amp;cArray[0])，则“pc&#43;1”表示偏移1个字节（sizeof(char)）到下一个char，即指向cArray[1]=2。
short型数组short sArray[5] = {1,2,3,4,5};，假设short* ps = sArray(&amp;sArray[0])，则“ps&#43;2”表示偏移4个字节(2*sizeof(short))到下下一个short，即指向sArray[2]=3。
int型数组int iArray[5] = {1,2,3,4,5};，假设int* pi = iArray(&amp;iArray[0])，则“pi&#43;3”表示偏移12个字节（3*sizeof(int)）到下下下一个int，即指向iArray[3]=4。 int x,y,*p=&amp;x;假设x,y,p顺序存放，则指针的自增自减归纳如下：
原操作
等价操作
y=*&#43;&#43;p;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c336fd5adbc7593c41feda8c7c47f529/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T16:57:53+08:00" />
<meta property="article:modified_time" content="2024-03-14T16:57:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">指针的基本概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="margin-left:0px;text-align:left;"><strong>1.指针，变量的指针，指针变量</strong></h3> 
<p style="margin-left:0;text-align:left;">由于通过地址能找到所需的变量单元，因此可以说地址“指向该变量单元”。在C语言中，将地址形象化的称为“<strong>指针</strong>”，一个变量的地址称为该“<strong>变量的指针</strong>”，意思是通过它能找到以它为地址的内存单元。指针的值是指针本身存储的数值，<strong>这个值将被编译器当作一个地址</strong>，而不是一个一般的数值。</p> 
<p style="margin-left:0;text-align:left;">在32位程序里，所有类型的指针的值都是一个32位整数。因为32位机中的程序里内存地址全都是32位长，即<span style="color:#0000ff;">sizeof</span>(pointer)的值总为4—指针本身占据了4个字节的长度。在64位机中，<span style="color:#0000ff;">sizeof</span>(pointer)的值为8。</p> 
<p style="margin-left:0;text-align:left;">如果一个变量专门用来存放另一个变量的地址，则它称为“<strong>指针变量</strong>”，我们说它用来存放指针。定义了一个变量p，它用来保存另一个变量var的地址，这样的p就是指向var的指针变量。</p> 
<p style="margin-left:0;text-align:left;">指针变量也是变量，其定义格式为：<strong><em>类型标识符 *</em>指针标识符</strong>。*号为地址解析符，表示“指向……的指针”，可以左结合，也可以右结合；其中<strong><em>类型标识符</em></strong>为指针所指向的类型。例如：</p> 
<p style="margin-left:0;text-align:left;">char *pc; pc具有<span style="color:#0000ff;">char</span> *类型，即pc指向<span style="color:#0000ff;">char</span>类型的变量，以1个字节为一个存取单元。</p> 
<p style="margin-left:0;text-align:left;">int *pi; pi具有<span style="color:#0000ff;">int</span> *类型，即pi指向<span style="color:#0000ff;">int</span>类型的变量，以4个字节为一个存取单元。</p> 
<p style="margin-left:0;text-align:left;">float* pf; pf具有<span style="color:#0000ff;">float</span> *类型，即pf指向<span style="color:#0000ff;">float</span>类型的变量，以4个字节为一个存取单元。</p> 
<p style="margin-left:0;text-align:left;">char *pc=<span style="color:#800000;">"hello"</span>;<strong>&lt;==&gt;</strong><span style="color:#0000ff;">char</span> *pc;pc=<span style="color:#800000;">"hello"</span>;</p> 
<h3 style="margin-left:0px;text-align:left;"><strong>2.指针变量的引用</strong></h3> 
<p style="margin-left:0;text-align:left;">C语言中对指针变量的引用主要通过运算符“&amp;”和“*”来实现的。</p> 
<p style="margin-left:0;text-align:left;">&amp;——取变量的地址，取指针。</p> 
<p style="margin-left:0;text-align:left;">*——取指针变量所指向的变量的值，解引用。</p> 
<p style="margin-left:0;text-align:left;">观察下面的程序段：</p> 
<pre><code class="language-cpp">int x,y,*p; //定义整型变量x、y和整型指针变量p

x=168; //初始化x

p=&amp;x; //初始化p，存储变量x的地址

y=*p; //初始化y，解引用p</code></pre> 
<p style="margin-left:0;text-align:left;">上述内存变化情况如图所示：</p> 
<p style="text-align:center;"></p> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/f2/18/IF9CpNSc_o.jpg" width="516"></p> 
<p style="margin-left:0px;">若<span style="color:#0000ff;">int</span> a=168;   <span style="color:#0000ff;">int</span> *p=&amp;a;则*&amp;a表示变量a本身，而&amp;*p=&amp;a,表示去变量a的地址。</p> 
<h3 style="background-color:transparent;margin-left:0px;text-align:left;"><strong>3.指针的算术运算</strong></h3> 
<p style="margin-left:0;text-align:left;">指针是有类型的，故指针的算术运算(+,-)是以类型的size为单位“1”的偏移。</p> 
<p style="margin-left:0;text-align:left;">char型数组char cArray[5] = {1,2,3,4,5};，假设 char* pc = cArray(&amp;cArray[0])，则“pc+1”表示<strong>偏移1个字节</strong>（sizeof(char)）到下一个char，即指向cArray[1]=2。</p> 
<p style="margin-left:0;text-align:left;">short型数组short sArray[5] = {1,2,3,4,5};，假设short* ps = sArray(&amp;sArray[0])，则“ps+2”表示<strong>偏移4个字节</strong>(2*sizeof(short))到下下一个short，即指向sArray[2]=3。</p> 
<p style="margin-left:0;text-align:left;">int型数组int iArray[5] = {1,2,3,4,5};，假设int* pi = iArray(&amp;iArray[0])，则“pi+3”表示<strong>偏移12个字节</strong>（3*sizeof(int)）到下下下一个int，即指向iArray[3]=4。   </p> 
<p style="margin-left:0;text-align:left;">int x,y,*p=&amp;x;假设x,y,p顺序存放，则指针的自增自减归纳如下：</p> 
<div> 
 <table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="background-color:transparent;border-color:#000000;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">原操作</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">等价操作</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*++p;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">p=p+1;y=*p;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*p++;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">y=*p;p=p+1;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=(*p)++;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">y=*p+1;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*(++p);</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">p=p+1;y=*p;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*--p;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">p=p-1;y=*p;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*p--;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">y=*p;p=p-1;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=(*p)--;</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">y=*p-1;</p> </td></tr><tr><td style="background-color:transparent;vertical-align:top;width:64.7pt;"> <p style="margin-left:0;text-align:left;">y=*(--p);</p> </td><td style="background-color:transparent;vertical-align:top;width:91.2pt;"> <p style="margin-left:0;text-align:left;">p=p-1;y=*p;</p> </td></tr></tbody></table> 
</div> 
<p> C 标准库 stddef.h 中定义了 <a class="link-info" href="https://en.wikibooks.org/wiki/C_Programming/stddef.h/Function_reference#offsetof" rel="nofollow" title="offsetof">offsetof</a> 用于测算结构成员变量与结构起始地址的偏移量：</p> 
<pre><code class="language-cpp">#define offsetof(type, member) /*implementation-defined*/
</code></pre> 
<p>The "traditional" implementation of the macro relied on the compiler being not especially picky about pointers; it obtained the offset of a member by specifying a <em>hypothetical</em> structure that begins at address zero:</p> 
<pre><code class="language-cpp">#define offsetof(st, m) \
     ((size_t) ( (char *)&amp;((st *)(0))-&gt;m - (char *)0 ))</code></pre> 
<p> 其把常数 0 强制转换为结构体指针（(st*)0），然后取其成员变量 m 的地址，强制转换成 char* 字节指针，再减去结构体起始地址（(char*)0），即得到相对偏移量。</p> 
<h3 style="margin-left:0px;text-align:left;"><strong>4.指针数组</strong></h3> 
<p style="margin-left:0;text-align:left;">指针数组和普通数组没什么区别，只不过其元素是指针。指针数组实际存储的是一系列和指针同类型变量的地址。</p> 
<pre><code class="language-cpp">// 示例1
char c = 'H';
char *s ="Hello";
char str[] = "Hello";
char charArray[6] = {'H','e','l','l','o','\0'};
char *pChar[5];

pChar[0] = &amp;c;
pChar[1] = "Hello";
pChar[2] = s;
pChar[3] = str;
pChar[4] = charArray;

//示例2
int *n0,n1,n2;
int *pInt[3];
pInt[0] = n0;
pInt[1] = &amp;n1;
pInt[2] = &amp;n2;
</code></pre> 
<h3 style="margin-left:0px;text-align:left;"><strong>5.指针的指针</strong></h3> 
<p style="margin-left:0;text-align:left;">指针的指针本质还是指针，就是用来存放指针变量的地址。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p class="img-center"><img alt="" height="217" src="https://images2.imgbox.com/af/65/qeEQPc58_o.jpg" width="288"></p> 
<p style="margin-left:0;text-align:left;">对于返回二级指针的函数void** GetNextPtr(void* pNode);我们可以对返回结果进行操作：*GetNextPtr(pNode) = pHead;</p> 
<p style="margin-left:0;text-align:left;">我们可以用函数返回值来传递动态内存，例如void *malloc( size_t size );。但是试图用指针参数去申请内存是做不到的，只能用“指向指针的指针”。参考《高质量C++编程指南》第7章—内存管理—7.3.3 计算内存容量。</p> 
<p style="margin-left:0;text-align:left;">以下利用二级指针实现链表List的分槽存储：</p> 
<pre><code class="language-cpp">typedef struct tagNode
{
    tagNode *pNext;
    int n;
    void **pData;
} List, *pList, *pThreadData;
</code></pre> 
<p>pData 指向 void* pSlot[n] 数组首地址的地址：pData=&amp;pSlot; </p> 
<p style="margin-left:0;text-align:center;"></p> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/f7/4d/glOPWFVo_o.jpg" width="460"></p> 
<p style="margin-left:0;text-align:left;">实际上List可以存放任意大小任何类型的数据（包括类）,在线程局部存储TLS中我们将见到这种分槽存储结构pThreadData。同时，我们也可以由此思考标准C++STL中的容器和MFC中afxtempl的实现机制。</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><strong>参考：</strong></p> 
<p style="margin-left:0;text-align:left;">《白话C++》南郁</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://blog.csdn.net/phunxm/archive/2009/12/26/5080981.aspx" title="内存和地址">内存和地址</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://blog.csdn.net/lovemy/archive/2006/01/05/571245.aspx" title="指针">指针</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://topic.csdn.net/t/20041020/19/3475259.html" rel="nofollow" title="void类型指针在程序中的用途">void类型指针在程序中的用途</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://blog.csdn.net/nice_guy/archive/2006/07/13/914868.aspx" title="二级指针的妙用">二级指针的妙用</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://alfps.izfree.com/tutorials/pointers/" rel="nofollow" title="C++ Pointers">C++ Pointers</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://www.netcore2k.net/articles/pointers" rel="nofollow" title="C/C++ Pointers">C/C++ Pointers</a>》</p> 
<p style="margin-left:0;text-align:left;">《<a href="http://flightline.highline.edu/rkang/151/Tut/15.pdf" rel="nofollow" title="Pointers in C/C++ By Value,By reference, Pointer Arithmetic">Pointers in C/C++ By Value,By reference, Pointer Arithmetic</a>》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2993dd7413af8c3304e66102515826d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文阅读——Align before Fuse</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86a1ef238d816f8e02cacc6a50d388a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot271制造装备物联及生产管理ERP系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>