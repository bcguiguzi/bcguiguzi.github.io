<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【评价指标】混淆矩阵Confusion Matrix、iou、miou、召回率、准确率及代码实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【评价指标】混淆矩阵Confusion Matrix、iou、miou、召回率、准确率及代码实现" />
<meta property="og:description" content="目录
混淆矩阵
以二分类为例
多分类示例
1.混淆矩阵
2.iou（交并比）
miou
3.召回率
4.acc(准确率）
5.混淆矩阵可视化 完整代码
混淆矩阵 混淆矩阵是大小为 (n_classes, n_classes) 的方阵, n_classes 表示类的数量。混淆矩阵可以用于直观展示每个类别的预测情况。并能从中计算精确值(Accuracy)、精确率(Precision)、召回率(Recall)、交并比(IoU)。
以二分类为例 预测为真预测为假实际为真TPFN实际为假FPTN TP(True Positive)：将正类预测为正类数；FN(False Negative)：将正类预测为负类数；FP(False Positive)：将负类预测为正类数；TN(True Negative)：将负类预测为负类数
Accuracy（准确率）是最常用的指标，所有预测正确的占全部的比例 Precision（精度，查准率）看的是在预测为真的情形下有多少是预测正确的，即「精准度」是多少 Recall（召回率，查全率）是看在实际为真的情形中，预测「能召回多少」实际为真的答案 多分类示例 1.混淆矩阵 不想太麻烦，就随机生成了两组44的数据作为真实值b和预测值a，生成混淆矩阵。
#生成数据 import numpy as np a = np.random.randint(0, 6, size=(4,4))#预测值 b = np.random.randint(0, 6, size=(4,4))#真实值 n = 6 print(a) print(b) #生成混淆矩阵 def fast_hist(a, b, n): k = (b &gt;= 0) &amp; (b &lt; n) # 横坐标是预测的类别，纵坐标是真实的类别 #n_class * label_true[mask]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a59bcd65eb6b1f856fa79e98c9749cb1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-27T11:12:38+08:00" />
<meta property="article:modified_time" content="2023-06-27T11:12:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【评价指标】混淆矩阵Confusion Matrix、iou、miou、召回率、准确率及代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5-toc" style="margin-left:0px;"><a href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5" rel="nofollow">混淆矩阵</a></p> 
<p id="%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B8%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B8%BA%E4%BE%8B" rel="nofollow">以二分类为例</a></p> 
<p id="%C2%A0%E5%A4%9A%E5%88%86%E7%B1%BB%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%A4%9A%E5%88%86%E7%B1%BB%E7%A4%BA%E4%BE%8B" rel="nofollow"> 多分类示例</a></p> 
<p id="1.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#1.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5" rel="nofollow">1.混淆矩阵</a></p> 
<p id="2.iou%EF%BC%88%E4%BA%A4%E5%B9%B6%E6%AF%94%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.iou%EF%BC%88%E4%BA%A4%E5%B9%B6%E6%AF%94%EF%BC%89" rel="nofollow">2.iou（交并比）</a></p> 
<p id="miou-toc" style="margin-left:80px;"><a href="#miou" rel="nofollow">miou</a></p> 
<p id="3.%E5%8F%AC%E5%9B%9E%E7%8E%87-toc" style="margin-left:40px;"><a href="#3.%E5%8F%AC%E5%9B%9E%E7%8E%87" rel="nofollow">3.召回率</a></p> 
<p id="%C2%A04.acc(%E5%87%86%E7%A1%AE%E7%8E%87%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A04.acc%28%E5%87%86%E7%A1%AE%E7%8E%87%EF%BC%89" rel="nofollow"> 4.acc(准确率）</a></p> 
<p id="5.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%C2%A0-toc" style="margin-left:40px;"><a href="#5.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%C2%A0" rel="nofollow">5.混淆矩阵可视化 </a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5"><strong>混淆矩阵</strong></h2> 
<p><strong>混淆矩阵</strong>是大小为 (n_classes, n_classes) 的方阵,  n_classes 表示类的数量。混淆矩阵可以用于直观展示每个类别的预测情况。并能从中计算精确值(Accuracy)、精确率(Precision)、召回率(Recall)、交并比(IoU)。</p> 
<h2 id="%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B8%BA%E4%BE%8B">以二分类为例</h2> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th></th><th>预测为真</th><th>预测为假</th></tr></thead><tbody><tr><th>实际为真</th><td style="text-align:justify;">TP</td><td>FN</td></tr><tr><th>实际为假</th><td>FP</td><td>TN</td></tr></tbody></table> 
<p>TP(True Positive)：将正类预测为正类数；FN(False Negative)：将正类预测为负类数；FP(False Positive)：将负类预测为正类数；TN(True Negative)：将负类预测为负类数</p> 
<ul><li>Accuracy（准确率）是最常用的指标，所有预测正确的占全部的比例</li></ul> 
<p style="text-align:center;"><img alt="Accuracy = \frac{TP+TN }{TP+TN+FP+FN}" class="mathcode" src="https://images2.imgbox.com/75/b9/cw8NC0QS_o.png"></p> 
<ul><li>Precision（精度，查准率）看的是在预测为真的情形下有多少是预测正确的，即「精准度」是多少</li></ul> 
<p style="text-align:center;"><img alt="precision = \frac{TP }{TP+FP}" class="mathcode" src="https://images2.imgbox.com/2e/27/BPAlUex2_o.png"></p> 
<ul><li>Recall（召回率，查全率）是看在实际为真的情形中，预测「能召回多少」实际为真的答案</li></ul> 
<p style="text-align:center;"><img alt="Recall = \frac{TP }{TP+FN}" class="mathcode" src="https://images2.imgbox.com/7d/5d/ZyQW7zck_o.png"> </p> 
<h2 id="%C2%A0%E5%A4%9A%E5%88%86%E7%B1%BB%E7%A4%BA%E4%BE%8B"> 多分类示例</h2> 
<h3 id="1.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5">1.混淆矩阵</h3> 
<p>不想太麻烦，就随机生成了两组4<img alt="\times" class="mathcode" src="https://images2.imgbox.com/c2/d3/7RpOeUXg_o.png">4的数据作为真实值<span style="color:#fe2c24;">b</span>和预测值<span style="color:#fe2c24;">a</span>，生成混淆矩阵。</p> 
<pre><code class="language-python">#生成数据
import numpy as np
a = np.random.randint(0, 6, size=(4,4))#预测值
b = np.random.randint(0, 6, size=(4,4))#真实值
n = 6
print(a)
print(b)

#生成混淆矩阵
def fast_hist(a, b, n):
    k = (b &gt;= 0) &amp; (b &lt; n)
    # 横坐标是预测的类别，纵坐标是真实的类别
    #n_class * label_true[mask].astype(int) + label_pred[mask]计算得到的是二维数组元素变成一维度数组元素的时候的地址取值(每个元素大小为1)，返回的是一个numpy的list，然后
    #np.bincount就可以计算各中取值的个数
    hist = np.bincount(a[k].astype(int) + n*b[k].astype(int), minlength=n**2).reshape(n,n)
    return hist
print(fast_hist(a, b, n))</code></pre> 
<blockquote> 
 <p>#随机生成的数据</p> 
 <p> [[4 2 2 0]<br>  [5 1 1 3]<br>  [4 0 2 1]<br>  [1 1 4 1]]</p> 
 <p><br> [[3 4 5 0]<br>  [2 4 5 1]<br>  [4 0 1 0]<br>  [1 4 2 4]]</p> 
 <p>#混淆矩阵： 横坐标是预测的类别，纵坐标是真实的类别</p> 
 <p>[[2 1 0 0 0 0]<br>  [0 1 1 1 0 0]<br>  [0 0 0 0 1 1]<br>  [0 0 0 0 1 0]<br>  [0 3 1 0 1 0]<br>  [0 1 1 0 0 0]]</p> 
</blockquote> 
<h3 id="2.iou%EF%BC%88%E4%BA%A4%E5%B9%B6%E6%AF%94%EF%BC%89">2.iou（交并比）</h3> 
<pre><code class="language-python">def per_class_iou(hist):
    """
    hist传入混淆矩阵(n, n)
    """
    # 因为下面有除法，防止分母为0的情况报错
    np.seterr(divide="ignore", invalid="ignore")
    # 交集：np.diag取hist的对角线元素
    # 并集：hist.sum(1)和hist.sum(0)分别按两个维度相加，而对角线元素加了两次，因此减一次
    iou = np.diag(hist) / (hist.sum(1) + hist.sum(0) - np.diag(hist))
    # 把报错设回来
    np.seterr(divide="warn", invalid="warn")
    # 如果分母为0，结果是nan，会影响后续处理，因此把nan都置为0
    iou[np.isnan(iou)] = 0.
    return iou
print(per_class_iou(hist))</code></pre> 
<blockquote> 
 <p>#iou</p> 
 <p> [0.66666667 0.125      0.         0.         0.14285714 0.        ]</p> 
</blockquote> 
<h4 id="miou">miou</h4> 
<p>对iou求平均就是miou</p> 
<pre><code class="language-python">miou = np.nanmean(iou)</code></pre> 
<h3 id="3.%E5%8F%AC%E5%9B%9E%E7%8E%87">3.召回率</h3> 
<p>对角线上的数值（预测正确的真）比上hist每一行的和（每一类实际为真的数量）</p> 
<pre><code class="language-python">#每一类的准确率
def per_class_acc(hist):
    """
    :param hist: 混淆矩阵
    :return: 每类的acc和平均的acc
    """
    np.seterr(divide="ignore", invalid="ignore")
    acc_cls = np.diag(hist) / hist.sum(1)   #改变hist.sum()的维度就是精度
    np.seterr(divide="warn", invalid="warn")
    acc_cls[np.isnan(acc_cls)] = 0.
    return acc_cls
print(per_class_acc(hist))</code></pre> 
<blockquote> 
 <p>#每类的召回率</p> 
 <p>[0.66666667 0.33333333 0.         0.         0.2        0.        ]</p> 
</blockquote> 
<p> 再求平均就是召回率了</p> 
<h3 id="%C2%A04.acc(%E5%87%86%E7%A1%AE%E7%8E%87%EF%BC%89"> 4.acc(准确率）</h3> 
<p>预测正确的比上所有</p> 
<pre><code class="language-python">acc = np.diag(hist).sum() / hist.sum()</code></pre> 
<blockquote> 
 <p> 0.25</p> 
</blockquote> 
<h3 id="5.%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%C2%A0">5.混淆矩阵可视化 </h3> 
<pre><code class="language-python"># 绘制hist矩阵的可视化图并保存
def drawHist(hist, path):
    
    hist_ = hist
    hist_tmp = np.zeros((class_num, class_num))

    for i in range(len(hist_)):
        hist_tmp[i] = hist_[i]

    print(hist_tmp)
    hist = hist_tmp
    plt.matshow(hist)
    plt.xlabel("Predicted label")
    plt.ylabel("True label")
    plt.axis("off")
    # plt.colorbar()
    plt.show()
    if (path != None):
        plt.savefig(path)
        print("%s保存成功✿✿ヽ(°▽°)ノ✿" % path)</code></pre> 
<h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h2> 
<pre><code class="language-python">import torch
import numpy as np
import matplotlib.pyplot as plt


# 计算各种评价指标
def fast_hist(a, b, n):
    """
    生成混淆矩阵
    a 是形状为(HxW,)的预测值
    b 是形状为(HxW,)的真实值
    n 是类别数
    """
    # 确保a和b在0~n-1的范围内，k是(HxW,)的True和False数列
    k = (a &gt;= 0) &amp; (a &lt; n)
    # 横坐标是预测的类别，纵坐标是真实的类别
    hist = np.bincount(a[k].astype(int) + n * b[k].astype(int), minlength=n ** 2).reshape(n, n)
    return hist



def per_class_iou(hist):
    # 因为下面有除法，防止分母为0的情况报错
    np.seterr(divide="ignore", invalid="ignore")
    # 交集：np.diag取hist的对角线元素
    # 并集：hist.sum(1)和hist.sum(0)分别按两个维度相加，而对角线元素加了两次，因此减一次
    iou = np.diag(hist) / (hist.sum(1) + hist.sum(0) - np.diag(hist))
    # 把报错设回来
    np.seterr(divide="warn", invalid="warn")
    # 如果分母为0，结果是nan，会影响后续处理，因此把nan都置为0
    iou[np.isnan(iou)] = 0.
    return iou


def per_class_acc(hist):
    """
    :param hist: 混淆矩阵
    :return: 每类的acc和平均的acc
    """
    np.seterr(divide="ignore", invalid="ignore")
    acc_cls = np.diag(hist) / hist.sum(1)
    np.seterr(divide="warn", invalid="warn")
    acc_cls[np.isnan(acc_cls)] = 0.
    return acc_cls


# 使用这个函数计算模型的各种性能指标
# 输入网络的输出值和标签值，得到计算结果
def get_MIoU(pred, label, hist):
    """
    :param pred: 预测向量
    :param label: 真实标签值
    :return: 准确率，每类的准确率，每类的iou, miou
    """
    hist = hist
    # 准确率
    acc = np.diag(hist).sum() / hist.sum()
    # 每一类的召回率
    acc_cls = per_class_acc(hist)
    # 每类的iou
    iou = per_class_iou(hist)
    # miou
    miou = np.nanmean(iou[1:])
    return acc, acc_cls, iou, miou, hist


# 绘制hist矩阵的可视化图并保存
def drawHist(hist, path):
    # print(hist)
    hist_ = hist
    hist_tmp = np.zeros((n, n))

    for i in range(len(hist_)):
        hist_tmp[i] = hist_[i]

    print(hist_tmp)
    hist = hist_tmp
    plt.matshow(hist)
    plt.xlabel("Predicted label")
    plt.ylabel("True label")
    plt.axis("off")
    # plt.colorbar()
    plt.show()
    if (path != None):
        plt.savefig(path)
        print("%s保存成功✿✿ヽ(°▽°)ノ✿" % path)


if __name__ == "__main__":
    # 随机生成数据
    a = np.random.randint(0, 6, size=(4, 4))
    b = np.random.randint(0, 6, size=(4, 4))
    n = 6
    hist = fast_hist(a, b, n)
    print(a)
    print(b)
    print(get_MIoU(a, b, hist))

    drawHist(hist, "C:/Users/Administrator/Desktop")</code></pre> 
<blockquote> 
 <p>#所有结果<br> [[5 1 5 0]<br>  [4 0 5 1]<br>  [2 4 2 1]<br>  [1 3 2 5]]</p> 
 <p><br> [[0 3 3 3]<br>  [1 2 0 1]<br>  [0 3 1 1]<br>  [5 5 3 5]]</p> 
 <p><br> (0.1875, array([0.        , 0.5       , 0.        , 0.        , 0.        ,<br>        0.33333333]), array([0.        , 0.33333333, 0.        , 0.        , 0.        ,<br>        0.16666667]), 0.1, array([[0, 0, 1, 0, 0, 2],<br>        [0, 2, 1, 0, 1, 0],<br>        [1, 0, 0, 0, 0, 0],<br>        [1, 1, 1, 0, 1, 1],<br>        [0, 0, 0, 0, 0, 0],<br>        [0, 1, 0, 1, 0, 1]], dtype=int64))</p> 
 <p><br> [[0. 0. 1. 0. 0. 2.]<br>  [0. 2. 1. 0. 1. 0.]<br>  [1. 0. 0. 0. 0. 0.]<br>  [1. 1. 1. 0. 1. 1.]<br>  [0. 0. 0. 0. 0. 0.]<br>  [0. 1. 0. 1. 0. 1.]]</p> 
 <p></p> 
 <p><img alt="" height="188" src="https://images2.imgbox.com/fa/eb/n219KIht_o.png" width="188"></p> 
 <p></p> 
</blockquote> 
<p><a class="link-info" href="https://blog.csdn.net/haohulala/article/details/107660273?spm=1001.2014.3001.5506" title="代码结构主要是学习了这篇文章里混淆矩阵的部分">代码结构主要是学习了这篇文章里混淆矩阵的部分</a></p> 
<p><a class="link-info" href="https://www.jianshu.com/p/42939bf83b8a" rel="nofollow" title="混淆矩阵的生成代码原理不懂的可以看这篇">混淆矩阵的生成代码原理不懂的可以看这篇</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2541aa720ca4ea3d27c9a83373827217/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（十八）数据编辑——属性编辑①</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f62c6acf270ad9843901503c541dd245/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">成功解决redhat安装freeradius启动报错libmysqlclient.so.18问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>