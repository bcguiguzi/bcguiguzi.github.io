<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>系统编程之进程间的消息队列通信（5） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="系统编程之进程间的消息队列通信（5）" />
<meta property="og:description" content="系列文章目录 第一章 系统编程之多进程
第二章 系统编程之进程间的 管道 通信（1）
第二章 系统编程之进程间的 信号 通信（2）
第二章 系统编程之进程间的 共享内存 通信（3）
第二章 系统编程之进程间的 信号量 通信（4）
第二章 系统编程之进程间的 消息队列 通信 （5） 目录
系列文章目录
一、消息队列
1、消息队列的原理
2、结构体定义
3、相关的接口函数
(1)申请创建消息队列
(2)通过消息队列收发信息
(3)删除，获取，设置消息队列的属性
4、使用实例 （1）发送端代码
（2）接收端代码
总结
一、消息队列 1、消息队列的原理 消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。多个进程可同时向一个消息队列发送消息，也可以同时从一个消息队列中接收消息。发送进程把消息发送到队列尾部，接受进程从消息队列头部读取消息，消息一旦被读出就从队列中删除。 查看消息队列： ipcs -q 删除消息队列： ipcrm -q 消息队列的ID号
2、结构体定义 消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构。
struct msg { long mtype; //消息类型
char mtext[1]; //真实的信息 }
3、相关的接口函数 (1)申请创建消息队列 #include &lt;sys/msg.h&gt; int msgget(key_t key, int msgflg); 返回值：成功 返回消息队列的ID 失败 -1 key ：键值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c740ccdf01d63ab7f51bf94e1602b25f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-03T16:59:32+08:00" />
<meta property="article:modified_time" content="2023-02-03T16:59:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">系统编程之进程间的消息队列通信（5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><a id="_0"></a>系列文章目录</h2> 
<p><a href="http://t.csdn.cn/9kdVW" rel="nofollow" title="第一章 系统编程之多进程">第一章 系统编程之多进程</a></p> 
<p><a href="http://t.csdn.cn/uWGxQ" rel="nofollow" title="第二章 系统编程之进程间的 管道 通信（1）">第二章 系统编程之进程间的 管道 通信（1）</a></p> 
<p><a href="http://t.csdn.cn/td8jD" rel="nofollow" title="第二章 系统编程之进程间的 信号 通信（2）">第二章 系统编程之进程间的 信号 通信（2）</a></p> 
<p><a href="http://t.csdn.cn/rwu36" rel="nofollow" title="第二章 系统编程之进程间的 共享内存 通信（3）">第二章 系统编程之进程间的 共享内存 通信（3）</a></p> 
<p><a href="http://t.csdn.cn/8mQ60" rel="nofollow" title="第二章 系统编程之进程间的 信号量 通信（4）">第二章 系统编程之进程间的 信号量 通信（4）</a></p> 
<p><a class="link-info" href="http://t.csdn.cn/ZYUyc" rel="nofollow" title="第二章 系统编程之进程间的 消息队列 通信 （5） ">第二章 系统编程之进程间的 消息队列 通信 （5） </a></p> 
<p></p> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">系列文章目录</a></p> 
 <p id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" rel="nofollow">一、消息队列</a></p> 
 <p id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">1、消息队列的原理</a></p> 
 <p id="2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89" rel="nofollow">2、结构体定义</a></p> 
 <p id="3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" rel="nofollow">3、相关的接口函数</a></p> 
 <p id="%C2%A0(1)%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#%C2%A0%281%29%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" rel="nofollow"> (1)申请创建消息队列</a></p> 
 <p id="(2)%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%94%B6%E5%8F%91%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#%282%29%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%94%B6%E5%8F%91%E4%BF%A1%E6%81%AF" rel="nofollow">(2)通过消息队列收发信息</a></p> 
 <p id="(3)%E5%88%A0%E9%99%A4%EF%BC%8C%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#%283%29%E5%88%A0%E9%99%A4%EF%BC%8C%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7" rel="nofollow">(3)删除，获取，设置消息队列的属性</a></p> 
 <p id="-toc" style="margin-left:40px;"></p> 
 <p id="4%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%C2%A0" rel="nofollow">4、使用实例 </a></p> 
 <p id="%EF%BC%881%EF%BC%89%E5%8F%91%E9%80%81%E7%AB%AF%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%8F%91%E9%80%81%E7%AB%AF%E4%BB%A3%E7%A0%81" rel="nofollow">（1）发送端代码</a></p> 
 <p id="%EF%BC%882%EF%BC%89%E6%8E%A5%E6%94%B6%E7%AB%AF%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%8E%A5%E6%94%B6%E7%AB%AF%E4%BB%A3%E7%A0%81" rel="nofollow">（2）接收端代码</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
</div> 
<h2 id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">一、消息队列</h2> 
<h3 id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86">1、消息队列的原理</h3> 
<ul><li>消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。</li><li>多个进程可同时向一个消息队列发送消息，也可以同时从一个消息队列中接收消息。发送进程把消息发送到队列尾部，接受进程从消息队列头部读取消息，消息一旦被读出就从队列中删除。</li></ul> 
<blockquote> 
 <p>查看消息队列：                ipcs  -q        </p> 
 <p>删除消息队列：                ipcrm  -q  消息队列的ID号</p> 
</blockquote> 
<h3 id="2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89">2、结构体定义</h3> 
<p>消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构。</p> 
<blockquote> 
 <p>struct  msg                              </p> 
 <p>{                                      </p> 
 <p>        long mtype;        //消息类型</p> 
 <p>        char mtext[1];     //真实的信息                              </p> 
 <p>}</p> 
</blockquote> 
<h3 id="3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0">3、相关的接口函数</h3> 
<h4 id="%C2%A0(1)%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"> (1)申请创建消息队列</h4> 
<blockquote> 
 <p>#include &lt;sys/msg.h&gt;                      </p> 
 <p>int msgget(key_t key, int msgflg);                              </p> 
 <p>返回值：成功 返回消息队列的ID                                          </p> 
 <p>              失败 -1                                </p> 
 <p><strong>key </strong>：键值</p> 
 <p><strong>msgflg </strong>                                         </p> 
 <p>        IPC_CREAT ：<br>                 如果消息队列对象不存在，则创建之，否则则进行打开操作;<br>         IPC_EXCL：<br>                 和IPC_CREAT 一起使用（用”|”连接），如果消息对象不存在则创建之，否则产生一个错误并返回。如果单独使用IPC_CREAT 标志，msgget()函数要么返回一个已经存在的消息队列对象的标识符，要么返回一个新建立的消息队列对象的标识符。</p> 
</blockquote> 
<h4 id="(2)%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%94%B6%E5%8F%91%E4%BF%A1%E6%81%AF">(2)通过消息队列收发信息</h4> 
<blockquote> 
 <p><strong>发送信息：</strong><br> 把发送的信息打包成结构体<br> struct  msg<br> {<!-- --><br>        //消息类型<br>        //真实的信息<br> }<br> int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);<br> 返回值：成功 0  失败 -1<br> 参数：msgp --》你要发送的信息<br>            msgsz --》你打算发送多少字节的数据<br>            msgflg --》默认设置为0<br>            msgsnd(id,"hello",5,0);<br>            msgsnd(id,"hehe",4,0);<br>            msgsnd(id,"china",5,0);   //错误的写法，原因信息没有打包成结构体(结构体包含了消息的类型)<br>                    </p> 
 <p><strong>接收信息：</strong><br> ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);<br> 返回值：成功返回接收的字节数   失败 -1<br> 参数：msgtyp(重点，重点，重点)  --》你要接收的消息类型<br>            其它参数跟msgsnd类似</p> 
</blockquote> 
<h4 id="(3)%E5%88%A0%E9%99%A4%EF%BC%8C%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7">(3)删除，获取，设置消息队列的属性</h4> 
<blockquote> 
 <p>int msgctl(int msqid, int cmd, struct msqid_ds *buf);   </p> 
 <p>返回值：成功0  失败返回-1 </p> 
 <p>参数--》msgqid：是消息队列对象的标识符。<br>              cmd：消息队列进行的操作：<br>                         IPC_STAT：取出系统保存的消息队列的msqid_ds 数据，并将其存入参数buf 指向的msqid_ds 结构中。<br>                         IPC_SET：设定消息队列的msqid_ds 数据中的msg_perm 成员。设定的值由buf 指向的msqid_ds结构给出。<br>                         IPC_EMID：将队列从系统内核中删除。<br>                         IPC_STAT：将信息从与msqid关联的内核数据结构复制到buf指向的msqid_ds结构中。调用方必须对消息队列具有读取权限<br>  </p> 
 <p>struct msqid_ds {<!-- --><br>      struct ipc_perm msg_perm;     /* Ownership and permissions */<br>      time_t          msg_stime;    /* Time of last msgsnd(2) */<br>      time_t          msg_rtime;    /* Time of last msgrcv(2) */<br>      time_t          msg_ctime;    /* Time of last change */<br>      unsigned long   __msg_cbytes; /* Current number of bytes in queue (nonstandard) */<br>      msgqnum_t       msg_qnum;     /* Current number of messages in queue */<br>      msglen_t        msg_qbytes;   /* Maximum number of bytes allowed in queue */<br>      pid_t           msg_lspid;    /* PID of last msgsnd(2) */<br>      pid_t           msg_lrpid;    /* PID of last msgrcv(2) */</p> 
 <p>};</p> 
</blockquote> 
<h3><a id="1_27"></a></h3> 
<hr> 
<h3 id="4%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%C2%A0">4、使用实例 </h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%8F%91%E9%80%81%E7%AB%AF%E4%BB%A3%E7%A0%81">（1）发送端代码</h4> 
<pre><code class="language-cs">#include "myhead.h"
//自定义一个结构体存放要发送的信息和类型
struct msg
{
	long msgtype;  //消息类型
	char msgdata[50]; //存放真实信息
};
int main()
{
	int msgid;
	//申请创建消息队列
	msgid=msgget(74545,IPC_CREAT|IPC_EXCL|0777);
	if(msgid==-1)
	{
		if(errno==EEXIST)
		{
			msgid=msgget(74545,0777);
		}
		else
		{
			perror("创建失败!\n");
			return -1;
		}
	}
	
	//组包发送信息给接收端
	struct msg msg1;
	bzero(&amp;msg1,sizeof(msg1));
	msg1.msgtype=999;
	strcpy(msg1.msgdata,"hello");
	msgsnd(msgid,&amp;msg1,sizeof(msg1),0);
	
	struct msg msg2;
	bzero(&amp;msg2,sizeof(msg2));
	msg2.msgtype=999;
	strcpy(msg2.msgdata,"world");
	msgsnd(msgid,&amp;msg2,sizeof(msg2),0);
	
	struct msg msg3;
	bzero(&amp;msg3,sizeof(msg3));
	msg3.msgtype=999;
	strcpy(msg3.msgdata,"gec");
	msgsnd(msgid,&amp;msg3,sizeof(msg3),0);
	
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E6%8E%A5%E6%94%B6%E7%AB%AF%E4%BB%A3%E7%A0%81">（2）接收端代码</h4> 
<pre><code class="language-cs">#include "myhead.h"
//自定义一个结构体存放要发送的信息和类型
struct msg
{
	long msgtype;  //消息类型
	char msgdata[50]; //存放真实信息
};
int main()
{
	int msgid;
	//申请创建消息队列
	msgid=msgget(74545,IPC_CREAT|IPC_EXCL|0777);
	if(msgid==-1)
	{
		if(errno==EEXIST)
		{
			msgid=msgget(74545,0777);
		}
		else
		{
			perror("创建失败!\n");
			return -1;
		}
	}
	
	//接收发送端发送过来的信息
	struct msg msg1;
	bzero(&amp;msg1,sizeof(msg1));
	
	//msgrcv(msgid,&amp;msg1,sizeof(msg1),777,0);
	msgrcv(msgid,&amp;msg1,sizeof(msg1),999,0);
	printf("接收的信息:%s\n",msg1.msgdata);
	
	bzero(&amp;msg1,sizeof(msg1));
	msgrcv(msgid,&amp;msg1,sizeof(msg1),999,0);
	printf("接收的信息:%s\n",msg1.msgdata);
	
	bzero(&amp;msg1,sizeof(msg1));
	msgrcv(msgid,&amp;msg1,sizeof(msg1),999,0);
	printf("接收的信息:%s\n",msg1.msgdata);
	
}</code></pre> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_55"></a>总结</h2> 
<p>以上就是本文要介绍的内容，本文仅仅简单介绍了消息队列的原理和使用实例</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af6ba233c7c69d7886546aa83ea79feb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新手上路~VUE3&#43;Element-PLUS dialog弹出框重置表单不生效问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2d44ecfe1a8d2f2881b789ab48a70f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像检索｜经典方法｜快速入门｜综述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>