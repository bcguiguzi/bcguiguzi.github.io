<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Codeforces Round #833 (Div. 2)E. Yet Another Array Counting Problem（笛卡尔树&#43;树形DP） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Codeforces Round #833 (Div. 2)E. Yet Another Array Counting Problem（笛卡尔树&#43;树形DP）" />
<meta property="og:description" content="题目链接：Problem - E - Codeforces
样例输入：
4 3 3 1 3 2 4 2 2 2 2 2 6 9 6 9 6 9 6 9 9 100 10 40 20 20 100 60 80 60 60 样例输出：
8 5 11880 351025663 题意：给定一个长度为n的数组a[],对于每一个区间[l,r]，这个区间的leftmost定义为区间[l,r]中的值等于该区间内元素的最大值的最小下标，现在问我们有多少种长度为n的数组b[]，满足对于任意区间都有leftmost值等于数组a的对应区间的leftmost值，且b数组中的元素值是介于1到m之间的。
分析：其实这道题要先知道笛卡尔树这个预备知识。
笛卡尔树是二叉排序树和堆的结合。
对于一个笛卡尔树，对笛卡尔树进行中序遍历即可得到原序列。
笛卡尔树中每个节点的左子树上的节点的坐标都是小于该节点的，右子树上的节点的坐标都是大于该节点的。而且每个节点的值是大于/小于其子树上的节点的值的，这个取决于是和大根堆结合还是和小根堆结合。
对于这道题目而言，我们就让根节点的值大于其左子节点的值，大于等于其右子节点的值，那么对于a数组和b数组需要构造出相同形态的笛卡尔树才算是满足题意的。所以我们可以按照a数组构造出笛卡尔树，然后利用树形DP向每个节点进行填值求方案数即可。
建树的过程，可以发现
每个右子树根节点的父亲节点就是他左边第一个大于他的数的位置
每个节点的左子树根节点就是他左边小于该值的数中的最大值的最小下标
这个显然可以用单调栈来维护，那么建树复杂度就是O(n)，细节可以见代码
最后就是根据笛卡尔树求解方案数了。
设f[x][y]代表x节点取值为1~y时的方案数和。那么更新过程就有四种情况：
x节点有左右子树，那么就有f[x][y]=f[x][y-1]&#43;f[l[x]][y-1]*f[r[x]][y]
x节点只有左子树，那么就有f[x][y]=f[x][y-1]&#43;f[l[x]][y-1]
x节点只有右子树，那么就有f[x][y]=f[x][y-1]&#43;f[r[x]][y]
如果没有孩子节点，直接返回y
利用这个方法我们即可完成本道题目的更新。
#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; const int N=2e6&#43;10,mod=1e9&#43;7; int l[N],r[N],fa[N]; int s[N],top; long long f[N],v[N]; int n,m; void build(int n) { top=0; for(int i=1;i&lt;=n;i&#43;&#43;) r[i]=l[i]=0; for(int i=1;i&lt;=n;i&#43;&#43;) { scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/616a15c23ddb78fb1563de04b5ebfa9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-01T13:56:54+08:00" />
<meta property="article:modified_time" content="2023-01-01T13:56:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Codeforces Round #833 (Div. 2)E. Yet Another Array Counting Problem（笛卡尔树&#43;树形DP）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目链接：<a href="https://codeforces.com/contest/1748/problem/E" rel="nofollow" title="Problem - E - Codeforces">Problem - E - Codeforces</a></p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/02/4d/oe8ZztRS_o.png" width="1077"></p> 
<p> 样例输入：</p> 
<pre><code class="hljs">4
3 3
1 3 2
4 2
2 2 2 2
6 9
6 9 6 9 6 9
9 100
10 40 20 20 100 60 80 60 60
</code></pre> 
<p>样例输出：</p> 
<pre><code class="hljs">8
5
11880
351025663
</code></pre> 
<p>题意：给定一个长度为n的数组a[],对于每一个区间[l,r]，这个区间的leftmost定义为区间[l,r]中的值等于该区间内元素的最大值的最小下标，现在问我们有多少种长度为n的数组b[]，满足对于任意区间都有leftmost值等于数组a的对应区间的leftmost值，且b数组中的元素值是介于1到m之间的。</p> 
<p>分析：其实这道题要先知道笛卡尔树这个预备知识。</p> 
<p>笛卡尔树是二叉排序树和堆的结合。</p> 
<p><span style="color:#fe2c24;"><strong>对于一个笛卡尔树，对笛卡尔树进行中序遍历即可得到原序列。</strong></span></p> 
<p>笛卡尔树中每个节点的左子树上的节点的坐标都是小于该节点的，右子树上的节点的坐标都是大于该节点的。而且每个节点的值是大于/小于其子树上的节点的值的，这个取决于是和大根堆结合还是和小根堆结合。</p> 
<p>对于这道题目而言，我们就<span style="color:#fe2c24;"><strong>让根节点的值大于其左子节点的值，大于等于其右子节点的值，那么对于a数组和b数组需要构造出相同形态的笛卡尔树才算是满足题意的</strong></span>。所以我们可以按照a数组构造出笛卡尔树，然后利用树形DP向每个节点进行填值求方案数即可。</p> 
<p>建树的过程，可以发现</p> 
<p><span style="color:#fe2c24;"><strong>每个右子树根节点的父亲节点就是他左边第一个大于他的数的位置</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>每个节点的左子树根节点就是他左边小于该值的数中的最大值的最小下标</strong></span></p> 
<p>这个显然可以用单调栈来维护，那么建树复杂度就是O(n)，细节可以见代码</p> 
<p>最后就是根据笛卡尔树求解方案数了。</p> 
<p><span style="color:#fe2c24;"><strong>设f[x][y]代表x节点取值为1~y时的方案数和。那么更新过程就有四种情况：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>x节点有左右子树，那么就有f[x][y]=f[x][y-1]+f[l[x]][y-1]*f[r[x]][y]</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>x节点只有左子树，那么就有f[x][y]=f[x][y-1]+f[l[x]][y-1]</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>x节点只有右子树，那么就有f[x][y]=f[x][y-1]+f[r[x]][y]</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>如果没有孩子节点，直接返回y</strong></span></p> 
<p>利用这个方法我们即可完成本道题目的更新。</p> 
<pre><code class="hljs">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=2e6+10,mod=1e9+7;
int l[N],r[N],fa[N];
int s[N],top;
long long f[N],v[N];
int n,m;
void build(int n)
{
	top=0;
	for(int i=1;i&lt;=n;i++)
		r[i]=l[i]=0;
    for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;v[i]);
        while(top&amp;&amp;v[s[top]]&lt;v[i])    l[i]=s[top],top--;//i节点的左子树的根节点就是下标小于i且值小于i的数的最大值对应的下标 
        fa[i]=s[top];//i节点的父节点就是他左边第一个值大于等于他的下标 
		fa[l[i]]=i;
        if(fa[i]) r[fa[i]]=i;
        s[++top]=i;
    }
}
int find(int x,int y)
{
	return (x-1)*m+y;
}
long long dp(int x,int R)//代表节点x的可取值范围为[1,R]的方案数 
{
	if(R&lt;1) return 0;
	if((!l[x])&amp;&amp;(!r[x])) return R; 
	if(f[find(x,R)]!=-1) return f[find(x,R)];
	long long ans=0;
	if(l[x]&amp;&amp;r[x]) ans=(dp(x,R-1)+dp(l[x],R-1)*dp(r[x],R))%mod;
	else if(l[x]) ans=(dp(x,R-1)+dp(l[x],R-1))%mod;
	else if(r[x]) ans=(dp(x,R-1)+dp(r[x],R))%mod;
	return f[find(x,R)]=ans;
}
int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf("%d%d",&amp;n,&amp;m);
		for(int i=1;i&lt;=n*m;i++)
			f[i]=-1;
		build(n);
		int root,mx=0;
		for(int i=1;i&lt;=n;i++)
			if(v[i]&gt;mx) mx=v[i],root=i;
		printf("%lld\n",dp(root,m));
	}
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a989d9252a2cc43e8ca9d8b49bc01c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BootCDN——React入门学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0ee7c2c19690acee856f72bc2188013/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10搭建 IIS 服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>