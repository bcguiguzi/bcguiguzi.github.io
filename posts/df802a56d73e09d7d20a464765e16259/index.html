<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java线程池用法_Java线程池的四种用法与使用场景 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java线程池用法_Java线程池的四种用法与使用场景" />
<meta property="og:description" content="一、如下方式存在的问题
new Thread() {
@Override
publicvoid run() {
// 业务逻辑
}
}.start();
1、首先频繁的创建、销毁对象是一个很消耗性能的事情;2、如果用户量比较大，导致占用过多的资源，可能会导致我们的服务由于资源不足而宕机;3、综上所述，在实际的开发中，这种操作其实是不可取的一种方式。
二、使用线程池有什么优点
1、线程池中线程的使用率提升，减少对象的创建、销毁;2、线程池可以控制线程数，有效的提升服务器的使用资源，避免由于资源不足而发生宕机等问题;
三、线程池的四种使用方式
1、newCachedThreadPool
创建一个线程池，如果线程池中的线程数量过大，它可以有效的回收多余的线程，如果线程数不足，那么它可以创建新的线程。
publicstaticvoid method() throws Exception {
ExecutorService executor = Executors.newCachedThreadPool();
for(inti = 0; i final intindex= i;
Thread.sleep(1000);
executor.execute(new Runnable() {
@Override
publicvoid run() {
System.out.println(Thread.currentThread().getName() &#43;&#34; &#34;&#43;index);
}
});
}
}
执行结果
通过分析我看可以看到，至始至终都由一个线程执行，实现了线程的复用，并没有创建多余的线程。如果当我们的业务需要一定的时间进行处理，那么将会出现什么结果。我们来模拟一下。
可以明显的看出，现在就需要几条线程来交替执行。
不足：这种方式虽然可以根据业务场景自动的扩展线程数来处理我们的业务，但是最多需要多少个线程同时处理缺是我们无法控制的;
优点：如果当第二个任务开始，第一个任务已经执行结束，那么第二个任务会复用第一个任务创建的线程，并不会重新创建新的线程，提高了线程的复用率;
2、newFixedThreadPool
这种方式可以指定线程池中的线程数。举个栗子，如果一间澡堂子最大只能容纳20个人同时洗澡，那么后面来的人只能在外面排队等待。如果硬往里冲，那么只会出现一种情景，摩擦摩擦...
首先测试一下最大容量为一个线程，那么会不会是我们预测的结果。
publicstaticvoid method_01() throws InterruptedException {
ExecutorService executor = Executors.newFixedThreadPool(1);
for(inti = 0; i Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/df802a56d73e09d7d20a464765e16259/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-12T11:12:29+08:00" />
<meta property="article:modified_time" content="2021-02-12T11:12:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java线程池用法_Java线程池的四种用法与使用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p align="center"><img src="https://images2.imgbox.com/7d/b4/L4MU2HPf_o.png" alt="897b8fab5a16af7e56e8fc603d80b77a.png"></p> 
 <p>一、如下方式存在的问题</p> 
 <p>new Thread() {<!-- --></p> 
 <p>@Override</p> 
 <p>publicvoid run() {<!-- --></p> 
 <p>// 业务逻辑</p> 
 <p>}</p> 
 <p>}.start();</p> 
 <p>1、首先频繁的创建、销毁对象是一个很消耗性能的事情;2、如果用户量比较大，导致占用过多的资源，可能会导致我们的服务由于资源不足而宕机;3、综上所述，在实际的开发中，这种操作其实是不可取的一种方式。</p> 
 <p>二、使用线程池有什么优点</p> 
 <p>1、线程池中线程的使用率提升，减少对象的创建、销毁;2、线程池可以控制线程数，有效的提升服务器的使用资源，避免由于资源不足而发生宕机等问题;</p> 
 <p>三、线程池的四种使用方式</p> 
 <p>1、newCachedThreadPool</p> 
 <p>创建一个线程池，如果线程池中的线程数量过大，它可以有效的回收多余的线程，如果线程数不足，那么它可以创建新的线程。</p> 
 <p>publicstaticvoid method() throws Exception {<!-- --></p> 
 <p>ExecutorService executor = Executors.newCachedThreadPool();</p> 
 <p>for(inti = 0; i </p> 
 <p>final intindex= i;</p> 
 <p>Thread.sleep(1000);</p> 
 <p>executor.execute(new Runnable() {<!-- --></p> 
 <p>@Override</p> 
 <p>publicvoid run() {<!-- --></p> 
 <p>System.out.println(Thread.currentThread().getName() +"  "+index);</p> 
 <p>}</p> 
 <p>});</p> 
 <p>}</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/53/9b/TWUKgU2T_o.png" alt="902d03a0e07e179d48b6aa902364f671.png"></p> 
 <p>通过分析我看可以看到，至始至终都由一个线程执行，实现了线程的复用，并没有创建多余的线程。如果当我们的业务需要一定的时间进行处理，那么将会出现什么结果。我们来模拟一下。</p> 
 <p align="center"><img src="https://images2.imgbox.com/22/5b/YE4GBUe4_o.gif" alt="8fd81668a2f4e088d111dc9a45f90799.gif"></p> 
 <p>可以明显的看出，现在就需要几条线程来交替执行。</p> 
 <p>不足：这种方式虽然可以根据业务场景自动的扩展线程数来处理我们的业务，但是最多需要多少个线程同时处理缺是我们无法控制的;</p> 
 <p>优点：如果当第二个任务开始，第一个任务已经执行结束，那么第二个任务会复用第一个任务创建的线程，并不会重新创建新的线程，提高了线程的复用率;</p> 
 <p>2、newFixedThreadPool</p> 
 <p>这种方式可以指定线程池中的线程数。举个栗子，如果一间澡堂子最大只能容纳20个人同时洗澡，那么后面来的人只能在外面排队等待。如果硬往里冲，那么只会出现一种情景，摩擦摩擦...</p> 
 <p>首先测试一下最大容量为一个线程，那么会不会是我们预测的结果。</p> 
 <p>publicstaticvoid method_01() throws InterruptedException {<!-- --></p> 
 <p>ExecutorService executor = Executors.newFixedThreadPool(1);</p> 
 <p>for(inti = 0; i </p> 
 <p>Thread.sleep(1000);</p> 
 <p>final intindex= i;</p> 
 <p>executor.execute(() -&gt; {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(2 * 1000);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>System.out.println(Thread.currentThread().getName() +"  "+index);</p> 
 <p>});</p> 
 <p>}</p> 
 <p>executor.shutdown();</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/bd/3c/6GSaHi9Y_o.gif" alt="36bc8c616a254b44d99f94bed3b3b5da.gif"></p> 
 <p>我们改为3条线程再来看下结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/df/87/DnjRx09k_o.gif" alt="c75968cecf717692facbeb6277803e4e.gif"></p> 
 <p>优点：两个结果综合说明，newFixedThreadPool的线程数是可以进行控制的，因此我们可以通过控制最大线程来使我们的服务器打到最大的使用率，同事又可以保证及时流量突然增大也不会占用服务器过多的资源。</p> 
 <p>3、newScheduledThreadPool</p> 
 <p>该线程池支持定时，以及周期性的任务执行，我们可以延迟任务的执行时间，也可以设置一个周期性的时间让任务重复执行。 该线程池中有以下两种延迟的方法。</p> 
 <p>scheduleAtFixedRate</p> 
 <p>测试一</p> 
 <p>publicstaticvoid method_02() {<!-- --></p> 
 <p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);</p> 
 <p>executor.scheduleAtFixedRate(new Runnable() {<!-- --></p> 
 <p>@Override</p> 
 <p>publicvoid run() {<!-- --></p> 
 <p>long start = new Date().getTime();</p> 
 <p>System.out.println("scheduleAtFixedRate 开始执行时间:"+</p> 
 <p>DateFormat.getTimeInstance().format(new Date()));</p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(5000);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>long end= newDate().getTime();</p> 
 <p>System.out.println("scheduleAtFixedRate 执行花费时间="+ (end- start) / 1000 +"m");</p> 
 <p>System.out.println("scheduleAtFixedRate 执行完成时间："+ DateFormat.getTimeInstance().format(newDate()));</p> 
 <p>System.out.println("======================================");</p> 
 <p>}</p> 
 <p>}, 1, 5, TimeUnit.SECONDS);</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/d2/ca/U5hqUXp2_o.gif" alt="e89ac9c3fcda349f3eebef9cdbe07fab.gif"></p> 
 <p>测试二</p> 
 <p align="center"><img src="https://images2.imgbox.com/53/bd/G5aHLeX4_o.gif" alt="c783aa09de9ee2a5ebb0f5bd9ff02279.gif"></p> 
 <p>总结：以上两种方式不同的地方是任务的执行时间，如果间隔时间大于任务的执行时间，任务不受执行时间的影响。如果间隔时间小于任务的执行时间，那么任务执行结束之后，会立马执行，至此间隔时间就会被打乱。</p> 
 <p>scheduleWithFixedDelay</p> 
 <p>测试一</p> 
 <p>publicstaticvoid method_03() {<!-- --></p> 
 <p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);</p> 
 <p>executor.scheduleWithFixedDelay(new Runnable() {<!-- --></p> 
 <p>@Override</p> 
 <p>publicvoid run() {<!-- --></p> 
 <p>long start = new Date().getTime();</p> 
 <p>System.out.println("scheduleWithFixedDelay 开始执行时间:"+</p> 
 <p>DateFormat.getTimeInstance().format(new Date()));</p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(1000);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>long end= newDate().getTime();</p> 
 <p>System.out.println("scheduleWithFixedDelay执行花费时间="+ (end- start) / 1000 +"m");</p> 
 <p>System.out.println("scheduleWithFixedDelay执行完成时间："</p> 
 <p>+ DateFormat.getTimeInstance().format(new Date()));</p> 
 <p>System.out.println("======================================");</p> 
 <p>}</p> 
 <p>}, 1, 2, TimeUnit.SECONDS);</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/42/c0/A4Mts5L9_o.gif" alt="14c306af684c6c4b499af648cb741a10.gif"></p> 
 <p>测试二</p> 
 <p>publicstaticvoid method_03() {<!-- --></p> 
 <p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);</p> 
 <p>executor.scheduleWithFixedDelay(new Runnable() {<!-- --></p> 
 <p>@Override</p> 
 <p>publicvoid run() {<!-- --></p> 
 <p>long start = new Date().getTime();</p> 
 <p>System.out.println("scheduleWithFixedDelay 开始执行时间:"+</p> 
 <p>DateFormat.getTimeInstance().format(new Date()));</p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(5000);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>long end= newDate().getTime();</p> 
 <p>System.out.println("scheduleWithFixedDelay执行花费时间="+ (end- start) / 1000 +"m");</p> 
 <p>System.out.println("scheduleWithFixedDelay执行完成时间："</p> 
 <p>+ DateFormat.getTimeInstance().format(new Date()));</p> 
 <p>System.out.println("======================================");</p> 
 <p>}</p> 
 <p>}, 1, 2, TimeUnit.SECONDS);</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/c9/00/DrQoYZth_o.gif" alt="501e17b8446135db451beb87f4571eea.gif"></p> 
 <p>总结：同样的，跟scheduleWithFixedDelay测试方法一样，可以测出scheduleWithFixedDelay的间隔时间不会受任务执行时间长短的影响。</p> 
 <p>4、newSingleThreadExecutor</p> 
 <p>这是一个单线程池，至始至终都由一个线程来执行。</p> 
 <p>publicstaticvoid method_04() {<!-- --></p> 
 <p>ExecutorService executor = Executors.newSingleThreadExecutor();</p> 
 <p>for(inti = 0; i </p> 
 <p>final intindex= i;</p> 
 <p>executor.execute(() -&gt; {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(2 * 1000);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>System.out.println(Thread.currentThread().getName() +"   "+index);</p> 
 <p>});</p> 
 <p>}</p> 
 <p>executor.shutdown();</p> 
 <p>}</p> 
 <p>执行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/e3/7a/N1SsD5p5_o.gif" alt="b8be2d1eb6d678cc599c1586d6b5e92d.gif"></p> 
 <p>四、线程池的作用</p> 
 <p>线程池的作用主要是为了提升系统的性能以及使用率。文章刚开始就提到，如果我们使用最简单的方式创建线程，如果用户量比较大，那么就会产生很多创建和销毁线程的动作，这会导致服务器在创建和销毁线程上消耗的性能可能要比处理实际业务花费的时间和性能更多。线程池就是为了解决这种这种问题而出现的。</p> 
 <p>同样思想的设计还有很多，比如数据库连接池，由于频繁的连接数据库，然而创建连接是一个很消耗性能的事情，所有数据库连接池就出现了。</p> 
 <p>【编辑推荐】</p> 
 <p>【责任编辑：武晓燕 TEL：(010)68476606】</p> 
 <p>点赞 0</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d1c38d2ad60fe7ef13fcff98b76ed8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java获取项目名称_java获取访问路径、域名、项目名、请求入参</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30517c780b1bf45cd13c61098d6255b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java pfx 证书_Java将pfx证书转换为jks</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>