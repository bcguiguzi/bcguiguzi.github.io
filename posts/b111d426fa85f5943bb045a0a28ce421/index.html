<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Http协议 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Http协议" />
<meta property="og:description" content="文章目录 Http协议1、Http 相关概念2、访问浏览器的过程3、Http协议通信过程4、HTTP 相关技术4.1 WEB开发语言4.1.1 html4.1.2 CSS4.1.3 js 4.2 MIME4.3 URI(i) 和URL4.4 网站访问量4.5 HTTP工作机制4.5.1 一次http事务包括4.5.2 Web资源4.5.3 资源类型4.5.4 HTTP连接请求4.5.5 串行和并行连接4.5.6 串行,持久连接和管道4.5.7 提高HTTP连接性能 4.6 HTTP协议版本4.6.1 http/0.94.6.2 http/1.04.6.3 http/1.14.6.4 HTTP1.0和HTTP1.1的区别4.6.5 HTTP1.0和1.1的问题4.6.6 HTTPS协议4.6.7 HTTPS 特点4.6.8 HTTP2协议 4.7 HTTP 请求访问的完整过程4.7.1 建立连接4.7.2 接收请求4.7.3 处理请求4.7.4 访问资源4.7.5 构建响应报文4.7.6 发送响应报文4.7.7 记录日志 5、http协议及报文头部结构5.1 HTTP请求报文5.1.1 方法5.1.2 url：指明资源的具体位置5.1.3 首部字段 5.2 响应报文5.2.1 状态码 Http协议 1、Http 相关概念 **互联网：**是网络的网络，是所有类型网络的母集
**因特网：**世界上最大的互联网网络。即因特网概念从属于互联网概念。习惯上，大家把连接在因特网上的计算机都成为主机。
**万维网：**WWW（world wide web）万维网并非某种特殊的计算机网络，是一个大规模的、联机式的信息贮藏库，使用链接的方法能非常方便地从因特网上的一个站点访问另一个站点（超链技术），具有提供分布式服务的特点。万维网是一个分布式的超媒体系统，是超文本系统的扩充，基于B/S架构实现
**URL：**万维网使用统一资源定位符（Uniform Resource Locator）来标志万维网上的各种文档，并使每个文档在整个因特网的范围内具有唯一的标识符URL。
**HTTP：**为解决&#34;用什么样的网络协议来实现整个因特网上的万维网文档”这一难题，就要使万维网客户程序（以浏览器为主，但不限于浏览器）与万维网服务器程序之间的交互遵守严格的协议，即超文本传送协议（HyperText Transfer Protocol）。HTTP是处于应用层的协议，使用TCP传输层协议进行可靠的传送。因此，需要特别提醒的是，万维网是基于因特网的一种广泛因特网应用系统，且万维网采用的是HTTP（80/TCP）和 HTTPS（443/TCP）的传输协议，但因特网还有其他的网络应用系统（如：FTP、SMTP等等）。
**HTML：**为了解决&#34;怎样使不同作者创作的不同风格的万维网文档，都能在因特网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接”这一问题，万维网使用超文本标记语言（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从页面的某处链接到因特网的任何一个万维网页面，并且能够在自己的主机品目上将这些页面显示出来。HTML与txt一样，仅仅是是一种文档，不同之处在于，这种文档专供于浏览器上为浏览器用户提供统一的界面呈现的统一规约。且具备结构化的特征，这是txt所不具备的强制规定。
2、访问浏览器的过程 HTTP访问的过程：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b111d426fa85f5943bb045a0a28ce421/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T16:37:08+08:00" />
<meta property="article:modified_time" content="2024-03-14T16:37:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Http协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Http_1" rel="nofollow">Http协议</a></li><li><ul><li><a href="#1Http__3" rel="nofollow">1、Http 相关概念</a></li><li><a href="#2_13" rel="nofollow">2、访问浏览器的过程</a></li><li><a href="#3Http_24" rel="nofollow">3、Http协议通信过程</a></li><li><a href="#4HTTP__29" rel="nofollow">4、HTTP 相关技术</a></li><li><ul><li><a href="#41_WEB_31" rel="nofollow">4.1 WEB开发语言</a></li><li><ul><li><a href="#411_html_41" rel="nofollow">4.1.1 html</a></li><li><a href="#412_CSS_63" rel="nofollow">4.1.2 CSS</a></li><li><a href="#413_js_88" rel="nofollow">4.1.3 js</a></li></ul> 
    </li><li><a href="#42_MIME_111" rel="nofollow">4.2 MIME</a></li><li><a href="#43_URIi_URL_120" rel="nofollow">4.3 URI(i) 和URL</a></li><li><a href="#44__146" rel="nofollow">4.4 网站访问量</a></li><li><a href="#45_HTTP_154" rel="nofollow">4.5 HTTP工作机制</a></li><li><ul><li><a href="#451_http_156" rel="nofollow">4.5.1 一次http事务包括</a></li><li><a href="#452_Web_161" rel="nofollow">4.5.2 Web资源</a></li><li><a href="#453__165" rel="nofollow">4.5.3 资源类型</a></li><li><a href="#454_HTTP_175" rel="nofollow">4.5.4 HTTP连接请求</a></li><li><a href="#455__177" rel="nofollow">4.5.5 串行和并行连接</a></li><li><a href="#456__179" rel="nofollow">4.5.6 串行,持久连接和管道</a></li><li><a href="#457_HTTP_181" rel="nofollow">4.5.7 提高HTTP连接性能</a></li></ul> 
    </li><li><a href="#46_HTTP_188" rel="nofollow">4.6 HTTP协议版本</a></li><li><ul><li><a href="#461_http09_190" rel="nofollow">4.6.1 http/0.9</a></li><li><a href="#462_http10_194" rel="nofollow">4.6.2 http/1.0</a></li><li><a href="#463_http11_200" rel="nofollow">4.6.3 http/1.1</a></li><li><a href="#464_HTTP10HTTP11_204" rel="nofollow">4.6.4 HTTP1.0和HTTP1.1的区别</a></li><li><a href="#465_HTTP1011_212" rel="nofollow">4.6.5 HTTP1.0和1.1的问题</a></li><li><a href="#466_HTTPS_219" rel="nofollow">4.6.6 HTTPS协议</a></li><li><a href="#467_HTTPS__223" rel="nofollow">4.6.7 HTTPS 特点</a></li><li><a href="#468_HTTP2_231" rel="nofollow">4.6.8 HTTP2协议</a></li></ul> 
    </li><li><a href="#47_HTTP__240" rel="nofollow">4.7 HTTP 请求访问的完整过程</a></li><li><ul><li><a href="#471__252" rel="nofollow">4.7.1 建立连接</a></li><li><a href="#472__256" rel="nofollow">4.7.2 接收请求</a></li><li><a href="#473__267" rel="nofollow">4.7.3 处理请求</a></li><li><a href="#474__273" rel="nofollow">4.7.4 访问资源</a></li><li><a href="#475__277" rel="nofollow">4.7.5 构建响应报文</a></li><li><a href="#476__299" rel="nofollow">4.7.6 发送响应报文</a></li><li><a href="#477__303" rel="nofollow">4.7.7 记录日志</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5http_307" rel="nofollow">5、http协议及报文头部结构</a></li><li><ul><li><a href="#51__HTTP_326" rel="nofollow">5.1 HTTP请求报文</a></li><li><ul><li><a href="#511__328" rel="nofollow">5.1.1 方法</a></li><li><a href="#512_url_340" rel="nofollow">5.1.2 url：指明资源的具体位置</a></li><li><a href="#513__360" rel="nofollow">5.1.3 首部字段</a></li></ul> 
    </li><li><a href="#52__415" rel="nofollow">5.2 响应报文</a></li><li><ul><li><a href="#521__425" rel="nofollow">5.2.1 状态码</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Http_1"></a>Http协议</h2> 
<h3><a id="1Http__3"></a>1、Http 相关概念</h3> 
<ul><li> <p>**互联网：**是网络的网络，是所有类型网络的母集</p> </li><li> <p>**因特网：**世界上最大的互联网网络。即因特网概念从属于互联网概念。习惯上，大家把连接在因特网上的计算机都成为主机。</p> </li><li> <p>**万维网：**WWW（world wide web）万维网并非某种特殊的计算机网络，是一个大规模的、联机式的信息贮藏库，使用链接的方法能非常方便地从因特网上的一个站点访问另一个站点（超链技术），具有提供分布式服务的特点。万维网是一个分布式的超媒体系统，是超文本系统的扩充，基于B/S架构实现</p> </li><li> <p>**URL：**万维网使用统一资源定位符（Uniform Resource Locator）来标志万维网上的各种文档，并使每个文档在整个因特网的范围内具有唯一的标识符URL。</p> </li><li> <p>**HTTP：**为解决"用什么样的网络协议来实现整个因特网上的万维网文档”这一难题，就要使万维网客户程序（以浏览器为主，但不限于浏览器）与万维网服务器程序之间的交互遵守严格的协议，即超文本传送协议（HyperText Transfer Protocol）。HTTP是处于应用层的协议，使用TCP传输层协议进行可靠的传送。因此，需要特别提醒的是，万维网是基于因特网的一种广泛因特网应用系统，且万维网采用的是HTTP（80/TCP）和 HTTPS（443/TCP）的传输协议，但因特网还有其他的网络应用系统（如：FTP、SMTP等等）。</p> </li><li> <p>**HTML：**为了解决"怎样使不同作者创作的不同风格的万维网文档，都能在因特网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接”这一问题，万维网使用超文本标记语言（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从页面的某处链接到因特网的任何一个万维网页面，并且能够在自己的主机品目上将这些页面显示出来。HTML与txt一样，仅仅是是一种文档，不同之处在于，这种文档专供于浏览器上为浏览器用户提供统一的界面呈现的统一规约。且具备结构化的特征，这是txt所不具备的强制规定。</p> </li></ul> 
<h3><a id="2_13"></a>2、访问浏览器的过程</h3> 
<p><strong>HTTP访问的过程：</strong></p> 
<ul><li>客户端通过域名进行访问，先进行DNS域名解析</li><li>之后客户端请求与web服务器建立TCP连接(三次握手)</li><li>建立连接后，客户端向web服务器发送一个HTTP请求</li><li>服务器响应HTTP请求，客户端的浏览器得到HTML代码</li><li>浏览器解析HTML代码，并请求HTML代码中的资源。(浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器去请求下载。)</li><li>断开TCP连接(四次挥手)，浏览器对页面进行渲染呈现给用户</li></ul> 
<h3><a id="3Http_24"></a>3、Http协议通信过程</h3> 
<ul><li>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础设计HTTP最初的目的是为了提供一种远距离共享知识的方式，借助多文档进行关联实现超文本，连成相互参阅的WWW（world wide web,万维网）</li><li>HTTP的发展是由蒂姆·伯纳斯-李（Tim Berners-Lee）于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1版</li></ul> 
<h3><a id="4HTTP__29"></a>4、HTTP 相关技术</h3> 
<h4><a id="41_WEB_31"></a>4.1 WEB开发语言</h4> 
<ul><li>http：Hyper Text Transfer Protocol 应用层协议，默认端口： 80/tcp</li></ul> 
<p><strong>WEB前端开发语言：</strong></p> 
<ul><li>html</li><li>css</li><li>javascript</li></ul> 
<h5><a id="411_html_41"></a>4.1.1 html</h5> 
<ul><li>Hyper Text Markup Language 超文本标记语言，编程语言，主要负责实现页面的结构</li></ul> 
<p><strong>html 语言</strong></p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>Content-Type</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>HTML语言<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://bdpc.hfbdqnedu.com/new/2019img/logo.png<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>欢迎<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>http://www.magedu.com</span><span class="token punctuation">&gt;</span></span>课工场<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>欢迎你<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

#注意:html文件编码为utf-8编码
</code></pre> 
<h5><a id="412_CSS_63"></a>4.1.2 CSS</h5> 
<ul><li>Cascading Style Sheet 层叠样式表， 定义了如何显示（装扮） HTML 元素，比如：字体大小和颜色属性等。样式通常保存在外部的 .css 文件中,用于存放一些HTML文件的公共属性,从而通过仅编辑一个简单的 CSS 文档，可以同时改变站点中所有页面的布局和外观。</li></ul> 
<p><strong>CSS</strong></p> 
<pre><code class="prism language-css"><span class="token selector">#test.html 建议用Vscode创建文件,用记事本可能会出现乱码
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html;charset=utf-8"&gt;
&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;这是 heading 1&lt;/h1&gt;
&lt;p&gt;这是一段普通的段落。请注意，该段落的文本是红色的。在 body 选择器中定义了本页面中的默认文本颜色。&lt;/p&gt;11|&lt;p class="ex"&gt;该段落定义了 class="ex"。该段落中的文本是蓝色的。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

#mystyle.css
body</span> <span class="token punctuation">{<!-- --></span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">}</span>
<span class="token selector">h1</span> <span class="token punctuation">{<!-- --></span><span class="token property">color</span><span class="token punctuation">:</span>#00ff00<span class="token punctuation">}</span>
<span class="token selector">p.ex</span> <span class="token punctuation">{<!-- --></span><span class="token property">color</span><span class="token punctuation">:</span><span class="token function">rgb</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>255<span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre> 
<h5><a id="413_js_88"></a>4.1.3 js</h5> 
<ul><li>javascript，实现网页的动画效果，但实际属于静态资源</li></ul> 
<p><strong>javascript</strong></p> 
<pre><code class="prism language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span>Content<span class="token operator">-</span>Type content<span class="token operator">=</span><span class="token string">"text/html;charset=utf-8"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>我的第一个 JavaScript<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span>
onclick<span class="token operator">=</span><span class="token string">"document.getElementById('demo').innerHTML = Date()"</span><span class="token operator">&gt;</span>
点击这里来显示日期和时间
<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="42_MIME_111"></a>4.2 MIME</h4> 
<p>MIME : Multipurpose Internet Mail Extensions 多用途互联网邮件扩展</p> 
<p>MIME 类型通常仅包含两个部分：类型（type）和子类型（subtype），中间由斜杠 / 分割，中间没有空白字符：</p> 
<ul><li>类型：代表数据类型所属的大致分类，例如 video 或 text</li><li>子类型：标识了 MIME 类型所代表的指定类型的确切数据类型。以 text 类型为例，它的子类型包括：plain（纯文本）、html（HTML 源代码）、calender（iCalendar/.ics 文件）</li></ul> 
<h4><a id="43_URIi_URL_120"></a>4.3 URI(i) 和URL</h4> 
<p>URI： Uniform Resource Identifier 统一资源标识，分为<strong>URL</strong> 和 <strong>URN</strong></p> 
<ul><li> <p>URN：Uniform Resource Naming，统一资源命名</p> </li><li> <p>URL：Uniform Resorce Locator，统一资源定位符，用于描述某服务器某特定资源位置</p> </li></ul> 
<p><strong>两者区别：</strong></p> 
<ul><li>URN如同一个人的名称，而URL代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地URL组成</li></ul> 
<p><strong>说明：</strong></p> 
<pre><code class="prism language-bash">scheme:方案，访问服务器以获取资源时要使用哪种协议
user:用户，某些方案访问资源时需要的用户名
password:密码，用户对应的密码，中间用：分隔
Host:主机，资源宿主服务器的主机名或IP地址
port:端口,资源宿主服务器正在监听的端口号，很多方案有默认端口号
path:路径,服务器资源的本地名，由一个/将其与前面的URL组件分隔
params:参数，指定输入的参数，参数为名/值对，多个参数，用<span class="token punctuation">;</span>分隔
query:查询，传递参数给程序，如数据库，用？分隔,多个查询用<span class="token operator">&amp;</span>分隔
frag:片段,一小片或一部分资源的名字，此组件在客户端使用，用<span class="token comment">#分隔</span>
</code></pre> 
<h4><a id="44__146"></a>4.4 网站访问量</h4> 
<p><strong>网站访问量统计的重要指标：</strong></p> 
<ul><li>IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP 地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标</li><li>PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量</li><li>UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的</li></ul> 
<h4><a id="45_HTTP_154"></a>4.5 HTTP工作机制</h4> 
<h5><a id="451_http_156"></a>4.5.1 一次http事务包括</h5> 
<ul><li>http请求：http request</li><li>http响应：http response</li></ul> 
<h5><a id="452_Web_161"></a>4.5.2 Web资源</h5> 
<p>web resource， 一个网页由多个资源（文件）构成，打开一个页面，通常会有多个资源展示出来，但是每个资源都要单独请求。因此，一个"Web 页面”通常并不是单个资源，而是一组资源的集合</p> 
<h5><a id="453__165"></a>4.5.3 资源类型</h5> 
<ul><li> <p>静态文件：无需服务端做出额外处理,服务器端和客户端的文件内容相同</p> <p>常见文件后缀：.html, .txt, .jpg, .js, .css, .mp3, .avi</p> </li><li> <p>动态文件：服务端执行程序，返回执行的结果,服务器端和客户端的文件内容不相同</p> <p>常见文件后缀：.php, .jsp ,.asp</p> </li></ul> 
<h5><a id="454_HTTP_175"></a>4.5.4 HTTP连接请求</h5> 
<h5><a id="455__177"></a>4.5.5 串行和并行连接</h5> 
<h5><a id="456__179"></a>4.5.6 串行,持久连接和管道</h5> 
<h5><a id="457_HTTP_181"></a>4.5.7 提高HTTP连接性能</h5> 
<ul><li>并行连接：通过多条TCP连接发起并发的HTTP请求</li><li>持久连接：keep-alive，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接</li><li>管道化连接：通过共享TCP连接，发起并发的HTTP请求</li><li>复用的连接：交替传送请求和响应报文（实验阶段）</li></ul> 
<h4><a id="46_HTTP_188"></a>4.6 HTTP协议版本</h4> 
<h5><a id="461_http09_190"></a>4.6.1 http/0.9</h5> 
<p>1991，原型版本，功能简陋，只有一个命令GET。GET /index.html ,服务器只能回应HTML格式字符串，不能回应别的格式</p> 
<h5><a id="462_http10_194"></a>4.6.2 http/1.0</h5> 
<p>1996年5月,支持cache, MIME, method</p> 
<p>每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接引入了POST命令和HEAD命令头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型, 常见Content-Type值：text/xml image/jpeg audio/mp3</p> 
<h5><a id="463_http11_200"></a>4.6.3 http/1.1</h5> 
<p>1997年1月，引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率新增方法：PUT、PATCH、OPTIONS、DELETE同一个TCP连接里，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成"队头堵塞"（Head-of-line blocking）为避免上述问题，两种方法：一是减少请求数，二是同时多开持久连接。网页优化技巧，如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度</p> 
<h5><a id="464_HTTP10HTTP11_204"></a>4.6.4 HTTP1.0和HTTP1.1的区别</h5> 
<ul><li>缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-NoneMatch等更多可供选择的缓存头来控制缓存策略</li><li>带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），方便了开发者自由的选择以便于充分利用带宽和连接</li><li>错误通知的管理，在HTTP1.1中新增24个状态响应码，如409（Conflict）表示请求的资源与资源当前状态冲突；410（Gone）表示服务器上的某个资源被永久性的删除</li><li>Host 头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）</li><li>长连接，HTTP 1.1支持持久连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，弥补了HTTP1.0每次请求都要创建连接的缺点</li></ul> 
<h5><a id="465_HTTP1011_212"></a>4.6.5 HTTP1.0和1.1的问题</h5> 
<ul><li>HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出</li><li>HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性</li><li>HTTP1.x在使用时，header里携带的内容过大，增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量</li><li>虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keepalive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</li></ul> 
<h5><a id="466_HTTPS_219"></a>4.6.6 HTTPS协议</h5> 
<p>为解决安全问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTP是与SSL一起使用的；在SSL逐渐演变到TLS时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。HTTPS就是安全版的HTTP，目前大型网站基本实现全站HTTPS</p> 
<h5><a id="467_HTTPS__223"></a>4.6.7 HTTPS 特点</h5> 
<ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTP和HTTPS使用的是不同的连接方式，端口不同，前者是80，后者是443</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li><li>HTTPS 实现过程降低用户访问速度，但经过合理优化和部署，HTTPS 对速度的影响还是可以接受的</li></ul> 
<h5><a id="468_HTTP2_231"></a>4.6.8 HTTP2协议</h5> 
<p><strong>http/2.0：2015年，HTTP2.0是SPDY的升级版</strong></p> 
<ul><li>头信息和数据体都是二进制，称为头信息帧和数据帧</li><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了"队头堵塞",此双向的实时通信称为多工（Multiplexing）</li><li>引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度</li><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）</li></ul> 
<h4><a id="47_HTTP__240"></a>4.7 HTTP 请求访问的完整过程</h4> 
<ol><li>建立连接</li><li>接收请求</li><li>处理请求</li><li>访问资源</li><li>构建响应报文</li><li>发送响应报文</li><li>记录日志</li></ol> 
<p><strong>一次完整的http请求处理过程</strong></p> 
<h5><a id="471__252"></a>4.7.1 建立连接</h5> 
<ul><li>接收或拒绝连接请求</li></ul> 
<h5><a id="472__256"></a>4.7.2 接收请求</h5> 
<ul><li>接收客户端请求报文中对某资源的一次请求的过程</li></ul> 
<p><strong>Web访问响应模型（Web I/O）</strong></p> 
<ul><li>单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应</li><li>多进程I/O模型：并行启动多个进程,每个进程响应一个连接请求</li><li>复用I/O结构：启动一个进程，同时响应N个连接请求</li><li>复用的多进程I/O模型：启动M个进程，每个进程响应N个连接请求，同时接收M*N个请求</li></ul> 
<h5><a id="473__267"></a>4.7.3 处理请求</h5> 
<ul><li>服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理</li></ul> 
<p>常用请求Method: GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS</p> 
<h5><a id="474__273"></a>4.7.4 访问资源</h5> 
<ul><li>服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源</li></ul> 
<h5><a id="475__277"></a>4.7.5 构建响应报文</h5> 
<ul><li>一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中 包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体</li></ul> 
<p>**响应实体：**如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。</p> 
<p>响应报文中通常包括：</p> 
<ul><li>描述了响应主体MIME类型的Content-Type首部</li><li>描述了响应主体长度的Content-Length</li></ul> 
<p><strong>实际报文的主体内容</strong></p> 
<ul><li>URL重定向：web服务构建的响应并非客户端请求的资源，而是资源另外一个访问路径</li><li>MIME类型： Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型</li></ul> 
<p><strong>与资源管理起来</strong></p> 
<ul><li>魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时</li><li>显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型</li><li>类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)“最好”</li></ul> 
<h5><a id="476__299"></a>4.7.6 发送响应报文</h5> 
<ul><li>Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束</li></ul> 
<h5><a id="477__303"></a>4.7.7 记录日志</h5> 
<ul><li>最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务</li></ul> 
<h3><a id="5http_307"></a>5、http协议及报文头部结构</h3> 
<ul><li>http协议：http/0.9, http/1.0, http/1.1, http/2.0，http/3.0</li><li>http协议：stateless 无状态, 服务器无法持续追踪访问者来源</li></ul> 
<p><strong>解决http协议无状态方法</strong></p> 
<ul><li>cookie 客户端存放</li><li>session 服务端存放</li></ul> 
<p><strong>http事务：一次访问的过程</strong></p> 
<ul><li>请求：request</li><li>响应：response</li></ul> 
<p><strong>HTTP报文结构</strong></p> 
<p>协议查看或分析的工具：tcpdump, wireshark,tshark</p> 
<h4><a id="51__HTTP_326"></a>5.1 HTTP请求报文</h4> 
<h5><a id="511__328"></a>5.1.1 方法</h5> 
<ul><li>GET： 获取资源 。当前网络请求中，绝大部分使用的是 GET 方</li><li>HEAD： 获取报文首部，主要用于确认 URL 的有效性以及资源更新的日期时间等</li><li>POST： 传输实体主体 （比如传输用户名密码）</li><li>PUT： 上传文件（比如写博客）</li><li>PATCH： 对资源进行部分修改</li><li>DELETE：删除文件</li><li>OPTIONS：查询支持的方法（查看服务端可以支持哪些方法）</li><li>CONNECT：要求在与代理服务器通信时建立隧道（类似加密）</li><li>TRACE：追踪路径</li></ul> 
<h5><a id="512_url_340"></a>5.1.2 url：指明资源的具体位置</h5> 
<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;
</code></pre> 
<ul><li> <p>scheme</p> 
  <ul><li>http：超文本传输协议</li><li>https：安全的http协议</li><li>ftp：文件传输协议</li></ul> </li><li> <p>user：帐号</p> </li><li> <p>password：密码</p> </li><li> <p>host：主机名 或 域名 或 ip地址</p> </li><li> <p>port： 服务器端口号</p> </li><li> <p>path：访问资源的路径，相当于组件路径</p> </li><li> <p>params：参数，但是这个不常用，指定一些参数，譬如指定传输方式</p> </li><li> <p>qurey：查询参数</p> </li><li> <p>frag：html资源片段，譬如html文档过大的时候，frag定位到html的一部分</p> </li></ul> 
<h5><a id="513__360"></a>5.1.3 首部字段</h5> 
<ul><li>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容，HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔</li></ul> 
<p><strong>首部的分类：</strong></p> 
<ul><li> <p>**通用首部：**请求报文和响应报文两方都会使用的首部</p> 
  <ul><li>Date: 报文的创建时间</li><li>Connection：连接状态，如keep-alive, close</li><li>Via：显示报文经过的中间节点（代理，网关）</li><li>Cache-Control：控制缓存，如缓存时长</li><li>MIME-Version:发送端使用的MIME版本</li><li>Warning：错误通知</li></ul> </li><li> <p>**请求首部：**从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、请求内容相关优先级等信息</p> 
  <ul><li>Accept：通知服务器自己可接受的媒体类型</li><li>Accept-Charset：客户端可接受的字符集</li><li>Accept-Encoding：客户端可接受编码格式，如gzip</li><li>Accept-Language：客户端可接受的语言</li><li>Client-IP：请求的客户端IP</li><li>Host：请求的服务器名称和端口号</li><li>Referer：跳转至当前URI的前一个URL</li><li>User-Agent：客户端代理，浏览器版本</li><li>Expect：允许客户端列出某请求所要求的服务器行为（条件式请求首部）</li><li>If-Modified-Since：自从指定的时间之后，请求的资源是否发生过修改（条件式请求首部）</li><li>If-Unmodified-Since：与上面相反（条件式请求首部）</li><li>If-None-Match：本地缓存中存储的文档的ETag标签是否与服务器文档的Etag不匹配（条件式请求首部）</li><li>If-Match：与上面相反 （条件式请求首部）</li><li>Authorization：向服务器发送认证信息，如账号和密码（安全请求首部）</li><li>Cookie: 客户端向服务器发送cookie</li><li>Proxy-Authorization: 向代理服务器认证 （ 代理请求首部）</li></ul> </li><li> <p>**响应首部：**从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息</p> 
  <ul><li>协商首部：某资源有多种表示方法时使用 
    <ul><li>Accept-Ranges：服务器可接受的请求范围类型</li><li>Vary：服务器查看的其它首部列表</li></ul> </li><li>安全响应首部： 
    <ul><li>Set-Cookie：向客户端设置cookie</li><li>WWW-Authenticate：来自服务器对客户端的质询列表</li></ul> </li><li>信息性： 
    <ul><li>Age：从最初创建开始，响应持续时长</li><li>Server：服务器程序软件名称和版本</li></ul> </li></ul> </li><li> <p>**实体首部：**针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息</p> 
  <ul><li>缓存相关： 
    <ul><li>ETag：实体的扩展标签</li><li>Expires：实体的过期时间</li><li>Last-Modified：最后一次修改的时间</li></ul> </li><li>Allow: 列出对此资源实体可使用的请求方法</li><li>Location：告诉客户端真正的实体位于何处</li><li>Content-Encoding:对主体执行的编码</li><li>Content-Language:理解主体时最适合的语言</li><li>Content-Location: 实体真正所处位置</li><li>Content-Type：主体的对象类型，如text</li></ul> </li><li> <p><strong>扩展首部</strong></p> </li><li> <p>**实体：**请求时附加的数据或响应时附加的数据，例如：登录网站时的用户名和密码，博客的上传文章，论坛上的发言等。</p> </li></ul> 
<h4><a id="52__415"></a>5.2 响应报文</h4> 
<p><strong>response报文格式</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>version<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>status<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>reason-phrase<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>headers<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>entity-body<span class="token operator">&gt;</span>
</code></pre> 
<h5><a id="521__425"></a>5.2.1 状态码</h5> 
<p><strong>http协议状态码分类</strong></p> 
<pre><code class="prism language-bash">1xx：100-101 信息提示
2xx：200-206 成功
3xx：300-307 重定向
4xx：400-415 错误类信息，客户端错误
5xx：500-505 错误类信息，服务器端错误
</code></pre> 
<p><strong>http协议常用的状态码</strong></p> 
<pre><code class="prism language-bash"><span class="token number">200</span>： 成功，请求数据通过响应报文的entity-body部分发送<span class="token punctuation">;</span>OK
<span class="token number">301</span>： 请求的URL指向的资源已经被删除；但在响应报文中通过首部Location指明了资源现在所处的新位置；Moved Permanently
<span class="token number">302</span>： 响应报文Location指明资源临时新位置 Moved Temporarily
<span class="token number">304</span>： 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过响应此响应状态码通知客户端；Not Modified
<span class="token number">307</span>:  浏览器内部重定向
<span class="token number">401</span>： 需要输入账号和密码认证方能访问资源；Unauthorized
<span class="token number">403</span>： 请求被禁止；Forbidden
<span class="token number">404</span>： 服务器无法找到客户端请求的资源；Not Found
<span class="token number">500</span>： 服务器内部错误；Internal Server Error,比如:cgi程序没有执行权限
<span class="token number">502</span>： 代理服务器从后端服务器收到了一条伪响应，如无法连接到网关；Bad Gateway
<span class="token number">503</span>： 服务不可用，临时服务器维护或过载，服务器无法处理请求,比如:php服务停止,无法处理php程序
<span class="token number">504</span>： 网关超时
</code></pre> 
<pre><code></code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02deb4c9f45e7cb6a981cb5f04dae3c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【嵌入式——QT】QThread创建多线程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd48c96450ba60976631d0b7f93290c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网页防篡改：网络安全界的“护宝奇兵”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>