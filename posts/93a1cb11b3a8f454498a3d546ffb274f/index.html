<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络（三十二）：习题解析 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络（三十二）：习题解析" />
<meta property="og:description" content="一、电路交换&amp;分组交换 考虑一个应用程序以稳定的速率传输数据（例如，发送方每 k 个时间单元产生一个 N 比特 的数据单元，其中 k 较小且固定）。另外，当这个应用程序启动时，他将连续运行相当长的 一段时间。回答下列问题：
a、是分组交换网还是电路交换网更为合适这种应用？
电路交换网，因为应用将以稳定速率，持续长时间运行，因此可以为其保留带宽，可保证应用程序以稳定的速率接收数据
b、假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序，此外， 假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗？为什么？
不需要，应用程序数据传输速率总和小于每条链路容量考虑两台主机 A 和 B 由一条速率为 Rbps 的链路连接，假定这两台主机相隔 m 米，该链路的传输速率为 s m/s 主机 A 向 B 发送长度为 L 比特的分组
a、用 m 和 s 来表示传播时延
因为传播时延是在连路上的时间，所以是距离/传输速度=m/s
b、用 L 和 R 来确定该分组的传输时间
分组传输时间=分组大小/链路速率=L/R
c、忽略处理和排队时延，得出端到端时延的表达式
端到端时延=分组处理时间&#43;传播时延=L/R&#43;m/s
d、假定主机 A 在时刻 t=0 开始传输该分组，在时刻 t=dtrans，该分组的最后一个比特在什 么地方？
dtrans时，最后一个比特刚刚离开主机A
e、假定 dprop 大于 dtrans，在时刻 dtrans，该分组的第一个比特在何处
dprop&gt;dtrans，代表第一个比特在链路上
f、假定 dprop 小于 dtrans，在时刻 dtrans，该分组的第一个比特在何处
已经到达主机B
g、假定 s=2.5x10^8，L=120 比特，R=56kbps，求出使 dprop 等于 dtrans 的距离 m" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/93a1cb11b3a8f454498a3d546ffb274f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-03T21:49:14+08:00" />
<meta property="article:modified_time" content="2020-07-03T21:49:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络（三十二）：习题解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、电路交换&amp;分组交换</h3> 
<ol><li>考虑一个应用程序以稳定的速率传输数据（例如，发送方每 k 个时间单元产生一个 N 比特 的数据单元，其中 k 较小且固定）。另外，当这个应用程序启动时，他将连续运行相当长的 一段时间。回答下列问题：<br> a、是分组交换网还是电路交换网更为合适这种应用？<br> <strong>电路交换网，因为应用将以稳定速率，持续长时间运行，因此可以为其保留带宽，可保证应用程序以稳定的速率接收数据</strong><br> b、假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序，此外， 假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗？为什么？<br> <strong>不需要，应用程序数据传输速率总和小于每条链路容量</strong></li><li>考虑两台主机 A 和 B 由一条速率为 Rbps 的链路连接，假定这两台主机相隔 m 米，该链路的传输速率为 s m/s 主机 A 向 B 发送长度为 L 比特的分组<br> a、用 m 和 s 来表示传播时延<br> <strong>因为传播时延是在连路上的时间，所以是距离/传输速度=m/s</strong><br> b、用 L 和 R 来确定该分组的传输时间<br> <strong>分组传输时间=分组大小/链路速率=L/R</strong><br> c、忽略处理和排队时延，得出端到端时延的表达式<br> <strong>端到端时延=分组处理时间+传播时延=L/R+m/s</strong><br> d、假定主机 A 在时刻 t=0 开始传输该分组，在时刻 t=dtrans，该分组的最后一个比特在什 么地方？<br> <strong>dtrans时，最后一个比特刚刚离开主机A</strong><br> e、假定 dprop 大于 dtrans，在时刻 dtrans，该分组的第一个比特在何处<br> <strong>dprop&gt;dtrans，代表第一个比特在链路上</strong><br> f、假定 dprop 小于 dtrans，在时刻 dtrans，该分组的第一个比特在何处<br> <strong>已经到达主机B</strong><br> g、假定 s=2.5x10^8，L=120 比特，R=56kbps，求出使 dprop 等于 dtrans 的距离 m<br> <strong>要求传播时延=传输时延，即m/s=L/R，代入计算可以知道m=536KM</strong></li><li>假定用户共享一条 3Mbps 的链路，又设每个用户传输时要求 150kbps ，但是每个用户仅有 10% 的时间传输 (参见 1. 3 节关于分组交换与电路交换的对比的讨论)<br> a、当时用电路交换时，能够支持多少用户？<br> <strong>电路交换独占某一部分链路（时分或频分），要求链路充分利用，则为3mbps/150kbps=20</strong><br> b、假定使用分组交换，求出给定用户正在传输的概率<br> <strong>分组交换不需要独占某一部分链路，故P=0.1</strong></li><li>a、假定有 N 个分组同时到达一条当前没有分组传输或排队的链路。每个分组长为 L，链路传输速率为 Rc，对 N 个分组而言，其平均排队时延是多少？<br> <strong>第一个分组的排队时延为 0, 第二个 L/R, 第三个 2L/R，第 N 个 (N-1)L/R，因此平均排 队时延为 (L/R + 2L/R + … + (N-1)L/R) / N = (N-1)L/2R</strong><br> b、现在假定每隔 LN/R 秒有 N 个分组同时到达链路。一个分组的平均排队时延是多少?<br> <strong>当下一批 N 个分组到达时，上一批已经传完，因此平均排队时延为 (N-1)L/2R</strong></li><li>假定两台主机 A 和 B 相隔 20000km，由一条直接的 R =2Mbps 的链路相连 假定跨越该链路 的传播速率是 2.5x10<sup>8</sup>m/s<br> a、计算带宽-时延积 Rxtprop<br> <strong>tprop = 20000km / 2.5*10^8m/s = 0.08s；R * tprop = 1.6 * 10<sup>5</sup> b</strong><br> b、考虑从主机 A 到主机 B 发送一个 800000 比特的文件。假定该文件作为一个大的报文连续发送。在任何给定的时间，在链路上具有的比特数量最大值是多少?<br> <strong>就是带宽-时延积=160000bits</strong><br> c、给出带宽-时延积的一种解释。<br> <strong>链路上的比特数量最大值</strong><br> d、在该链路上一个比特的宽度(以米计)是多少?它比一个足球场更长吗？<br> <strong>宽度 = 链路长度/带宽延迟乘积=20 000km/160 000 bits = 125 m</strong><br> e、根据传播速率 s、带宽 R 和链路 m 的长度，推导出一个比特宽度的一般表示式<br> <strong>s/R</strong></li><li>在包括因特网的现代分组交换网中，源主机将长应用层报文(如一个图像或音乐文件)分段为较小的分组并向网络发送。接收方则将这些分组重新装配为初始报文，我们称这个过程为报文分段。图1-27 显示了一个报文在报文不分段或报文分段情况下的端到端传输。考虑一个长度为8x10^6比特的报文，他在图1-27中从源发送到目的地。假定在该图中的每段链路是 2Mbps 忽略传播、排队和处理时延<br> <img src="https://images2.imgbox.com/4c/8a/SS0FssMl_o.png" alt="在这里插入图片描述"><br> a、考虑从源到目的地发送该报文且没有报文分段 从源主机到第一台分组交换机移动报文需要多长时间？记住，每台交换机均使用存储转发分组交换，从源主机移动该报文到目的主机需要长时间？<br> <strong>第一个分组交换需要的时间为=报文大小/链路速率= 8 * 10^6 / 2 * 10^6 sec = 4 sec<br> 源主机到目的主机有三段链路，需要时间为 3 * 4 = 12 sec</strong><br> b、现在假定该报文被分段为800个分组，每个分组10000比特长 从源主饥移动第一个分组到第一台交换机需要多长时间？从第一台交换机发送第一个分组到第二台交换机，从源主机发送第二个分组到第一台交换机各需要多长时间？什么时候第二个分组能被第一台交换机全部收到?<br> <strong>从源主机发送第一个分组到第一台交换机1 * 10^4 / 2 * 10^6 sec = 5 m sec<br> 从第一台交换机发送第一个分组到第二台交换机时间 = 从源主机发送第二个分组到第一台交换机时间 = 2 * 5 m sec = 10 m sec</strong><br> c、当进行报文分段时，从源主机向目的主机移动该文件需要多长时间？将该结果与( a) 的答案进行比较并解释之<br> <strong>第一个分组到达目的地时，花费的时间为 5 m sec * 3 = 15 m sec,之后，每隔 5 秒将会有一个分组被接收，一共有 800 个分组 ，除去第一个分组，传输该文件所需要的时间为 15 m sec + 799 * 5 msec = 4.01 sec。</strong><br> d、除了减小时延外，使用报文分段还有什么原因？<br> <strong>便于检测错误并重传；不分段的大包容易使路由器缓存不足导致丢包；</strong><br> e、讨论报文分段的缺点<br> <strong>分组需要排序；需加上首部信息</strong></li></ol> 
<h3><a id="_57"></a>二、拥塞控制</h3> 
<ol><li>UDP TCP使用反码来汁算它们的检验和。假设你有下面3个比特字节:：01010011， 01100110，<br> 01110100。这些8比特字节和的反码是多少？(注意到尽管 UDP TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和)。写出所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错? 比特的差错将可能检测不出来吗? 比特的差错呢?<br> <strong>首先，来计算一下反码<br> 01010011+01100110+01110100=00101110<br> 取反得到00101110<br> 检测的时候，只需要检测当前的三个字节相加取反（即计算当前的检验和）与发送过来的检验和是否相等，如果不相等则证明发生了错误。但是如果有偶数个错误就有可能发送忽略，比方说第一个字节和第二个字节的相同位发生了错误，此时相加的结果不会有影响。</strong></li><li>考虑我们改正协议rdt2.0的动机。试说明如图3-57所示的接收方与如图3-11所示的发送方运行时，接收方可能会引起发送方和接收方进入死锁状态，即双方部在等待不可能发生的事件。<br> <strong>首先来看看发送方，发送方开始处于等待上面的调用1的状态，而此时接收者处于等待下面的1的状态。<br> 然后，发送方发送序列号为1的数据包，并进入等待ack或nak1状态<br> 如果，接收方接收到了序列号为1的数据包，将会发送一个ACK，并进入从下面等待0的状态，等待序列号为0的数据包<br> 此时，如果ack损坏或者丢失，那么发送方将会持续发送序列号为1的数据包，而此时接收方在等待序列号为0的数据包，所以会进行nak操作<br> 此时，进入死锁</strong></li><li>考虑一个GBN协议，其发送方窗口为4，序号范围为1024。假设在时刻t，接收方期待的下一个有序分组的序号是k。假设媒体不会对报文重新排序。回答以下问题：<br> a、在t时刻，发送方窗口内的报文序号可能是多少?论证你的回答<br> <strong>在这里的窗口长度为N=4，假设接收方已经接收到分组k-1，并且已经对该分组以及之前的所有分组进行了确认。如果所有这些确认信息都已经被发送方接收，那么发送方的窗口是[k, k+N-1]。接下来假设所有这些ACK都没有被发送方接收。在这种情况下，发送方的窗口包含k-1和直到包括k-1之前的N的分组.因此发送方的窗口是[k-N, k-1]。因此，发送方的窗口大小是4，并且从[k-N, k+N-1]中的某个数开始。</strong><br> b、在t时刻，在当前传播回发送方的所有可能报文中， ACK字段的所有可能值是多少?论证你的回答<br> <strong>这就是第二种情况，即发送了[k-4,k-1]的分组，并正在等待这些分组对应的ACK。因为如果是第一种情况，说明此时已经成功发送了之前窗口内的所有分组，而当前窗口内的分组还没有开始发送，所以不存在等待的ACK，此时相当于是接收方在等待发送方。</strong></li><li>对下面的问题判断是非，并简要地证实你的回答:<br> a、对于 SR 协议，发送方可能会收到落在其当前窗口之外的分组的 ACK<br> <strong>是对的，因为如果发生了超时，此时会自动默认为分组已经丢失，而可能并没有丢失，只是由于链路速率问题，对应的ACK没有到达。简单地讲就是，如果第一次超时后重发了分组，而在重发之后收到了分组的ACK，此时会移动窗口，但是第二次分组（重发）的ACK还没有到达。</strong><br> b、对于 GBN 协议，发送方可能会收到落在其当前窗口之外的分组的 ACK<br> <strong>是对的，因为GBN是回退N步的窗口，也可能发生因为超时导致第二次分组（重发）的ACK在窗口移动之后到达</strong><br> c、当发送方和接收方窗口长度都为1时，比特交替协议与 SR 协议相同<br> <strong>是对的，因为此时比特交替协议中不存在一个顺序的概念，因为只有一个数据包</strong><br> d、当发送方和接收方窗口长度都为1时，比特交替协议与 GBN 协议相同<br> <strong>是对的，因为此时比特交替协议中不存在一个顺序的概念，因为只有一个数据包，即此时SR协议和GBN协议是等效的</strong></li><li>主机A和B经一条TCP连接通信，并且主机B已经收到了来自A的最长为126字节的所有字节。假定主机A随后向主机B发送两个紧接着的报文段。第一个和第二个报文段分别包含了80字节和40字节的数据。在第一个报文段中，序号是127，源端口号是302，目的地端口号是80。无论何时主机B接收到来自主机A的报文段，它都会发送确认。<br> a、在从主机A发往B的第二个报文段中，序号、源端口号和目的端口号各是什么?<br> <strong>在TCP中，报文段的序号为最小字节的序号，也就是说，第二个报文段的序号为127+80=207，同理，如果还有第三个报文段，则第三个报文段的序号为207+40=247。而源端口号和目的端口号都是一致的，即302和80</strong><br> b、如果第一个报文段在第二个报文段之前到达，在第一个到达报文段的确认中，确认号、源端口号和目的端口号各是什么?<br> <strong>TCP报文的确认号是下一个期待报文（有序）的报文序号，也就是说，第一个报文序号为127，他的下一个报文是207，所以第一个到达报文的确认号为207，源端口号为302，目的端口号为80</strong><br> c、如果第二个报文段在第一个报文段之前到达，在第一个到达报文段的确认中，确认号是什么?<br> <strong>TCP报文的确认号是下一个期待报文（有序）的报文序号，由于第二个报文段在第一个之前到达，此时是一个无序的状态，他需要先得到第一个报文段以得到一个有序的状态，再期待下一个报文段，所以，确认号不是下一个报文段的247，而是第一个报文段的序号127。</strong><br> d、假定由A发送的两个报文段按序到达 。第一个确认丢失了而第二个确认在第一个超时间隔之后到达。画出时序图，显示这些报文段和发送的所有其他报文段和确认 (假设没有其他分组丢失)。对于图上每个报文段，标出序号和数据的字节数量;对于你增加的每个应答，标出确认号<br> <strong>就是三个阶段<br> <img src="https://images2.imgbox.com/22/45/PSwYbENA_o.png" alt="在这里插入图片描述"><br> 首先是发送，和正常接收，此时会返回两个ACK，确认号分别是207和247<br> 然后由于207的确认迟迟不到，所以触发了超时条件，会重新发送一个127，而接收方接收到127后，发现已经存在，说明127的ACK发生了丢失，但由于207已经到了，所以就继续顺延，发送一个127的ACK，但其中的确认号是下一个期待报文序号247</strong></li><li>考虑图 3-58 假设 TCP Reno是一个经历如上所示行为的协议。回答下列问题 在各种情况中，简要地论证你的回答<br> <img src="https://images2.imgbox.com/cf/3a/6E5MmZz9_o.png" alt="在这里插入图片描述"><br> a. 指出TCP慢启动运行时的时间间隔<br> <strong>慢启动窗口长度是指数型增长，所以很明显，有两次，分别是[1,6]和[23,26]</strong><br> b. 指出TCP拥塞避免运行时的时间间隔<br> <strong>拥塞避免窗口长度是线性增长的，所以很明显，有两次，分别是[6,16]和[17,22]</strong><br> c. 在第16个传输轮回之后，报文段的丢失是根据3个冗余 ACK 还是根据超时检测出来的?<br> <strong>因为第16个时并没有降到1重新开始，所以很明显是3个冗余ACK造成的</strong><br> d. 在第22个传输轮回之后，报文段的丢失是根据3个冗余 ACK 还是根据超时检测出来的?<br> <strong>因为第22个时从1重新开始，所以很明显是超时检测出来的</strong><br> e. 在第1个传输轮回里，sstbresh的初始值设置为多少?<br> <strong>第1个轮回中，慢启动最大到32，然后一点一点向上增加，所以这个时候ssthresh的初始值应该为32，直到第6个轮回后才开始发生改变</strong><br> f. 在第18个传输轮回里，ssthresh的值设置为多少?<br> <strong>第18个轮回是在发生了冗余ACK之后，发生了减半，即从42到21，然后继续进行拥塞避免算法，在一点点增加，如果从17开始计算，则18的时候为22；如果从18开始计算，那么应该为21</strong><br> g. 在第24个传输轮回里，ssthresh的值设置为多少?<br> <strong>第24个轮回是发生了超时之后，此时阈值减半，超时发生在第22轮，此时阈值为29.丢包减半后重新开始，此时不会影响阈值，所以阈值一直为14</strong><br> h. 在哪个传输轮回内发送第70个报文段<br> <strong>[1,6]是指数发送，即分别是1，2.3，4.5.6.7，8.9.10.11.12.13.14.15，16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31，32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.63；然后进入指数增加状态，所以第70个分组是在第7轮发送的</strong><br> i. 假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和ssthresh 的值应当是多少?<br> <strong>第26个时已经进行了三次+1操作，然后容易会设置为当前的一般，即阈值为4，窗口长度为7</strong><br> j. 假定使用 TCP Tahoe (而不是TCP Reno)，并假定在第16个传输轮回收到3个冗余ACK。在第19个传输轮回，ss Lhresh 和拥塞窗口长度是什么?<br> <strong>tahoe与reno的区别是tahoe没有快速恢复，如果是冗余ACK，也会将窗口大小置为1重新慢启动。阈值为21，窗口大小为4</strong><br> k. 再次假设使用TCPTahoe，在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传输轮回(包括这两个传输轮回) ，一共发送了多少分组?<br> <strong>这里面是一个指数增加的过程，超时导致从1开始重启，所以<br> 17轮 1包（慢启动状态）<br> 18轮 2包<br> 19轮 4包<br> 20轮 8包<br> 21轮 16包<br> 22轮 21包（仍然是慢启动状态，但由于不能超过阈值，所以就只能取到阈值）<br> 综上，为1+2+4+8+16+21=52包</strong></li></ol> 
<h3><a id="_128"></a>三、网络层</h3> 
<ol><li>书中我们使用了术语面向连接服务来描述运输层，使用了术语连接服务来描述网络层，为何有这样微妙的差异？<br> <strong>简单地讲，就是因为运输层使用了网络层所提供的连接服务。在运输层中，他将每一台电脑看成一个对象，运输层所需要只是调用网络层封装好的函数，在任意两个对象之间请求建立连接，而不需要知道连接具体是如何建立的；网络层则需要接收运输层的请求，并在两个具体的电脑对象之间依靠现有的物理链路尝试建立连接，并传输运输层想要传输的数据。所以说运输层是面向连接的，而网络层是负责连接服务的。</strong></li><li>考虑具有前缀128.119.40.128/26的一个子网。给出能被分配给该网络的一个IP地址（形式为xxx.xxx.xxx.xxx）的例子。假定一个ISP拥有形式为128.119.40.64/26的地址块。假定它要从该地址块生成4个子网，每块具有相同数量的IP地址。这4个子网（形式a.b.c.d/x）的前缀是什么？<br> <strong>前缀不变，后6位比特可变，故IP地址范围为128.119.40.128 ~ 128.119.40.191<br> 由于需要产生四个子网，每个子网需要具有相同的IP地址数，所以只需要从后6位比特中选择高2位作为划分的前缀，每个子网可以有16个IP地址<br> 四个字网的前缀为：128.119.40.64/28、128.119.40.80/28、128.119.40.96/28、128.119.40.112/28</strong></li><li>考虑向具有700字节MTU的一-条链路发送–个2400字节的数据报。假定初始数据报标有标识号422。将会生成多少个分片?在生成相关分片的数据报中的各个字段中的值是多少?<br> <strong>由于IP数据报的首部字节为20，故每个数据字段的最大大小=700-20=680，所以需要(2400-20)/680=&gt;4个数据报。其中最后一个数据报不满。<br> 标志号：均为422<br> 长度：前三个都是700，最后一个为2400-20-3*680+20=360字节<br> 偏移量：0/85/170/255<br> flag：前3个的flag为1，最后一个为0</strong></li><li>考虑下面的网络。对于标明的链路费用，用Dijkstra最短路径算法计算出从x到所有网络节点的最短路径。通过计算一个类似于表4-3的表，说明该算法是如何工作的。<br> <img src="https://images2.imgbox.com/16/ea/269KYxWm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/60/IvAVjjYx_o.png" alt="在这里插入图片描述"><br> <strong>首先将x作为根节点，将x的最直接的关联点y、z、v、w加入到表中<br> 然后，从y、z、v、w中选择最近的v，将其作为第一跳转点，进行路径长度更新<br> 以此类推，得到上表<br> 从结点x到结点t的最少费用为7，路径为xvt<br> 从结点x到结点u的最少费用为6，路径为xvu<br> 从结点x到结点v的最少费用为3，路径为xv<br> 从结点x到结点w的最少费用为6，路径为xw<br> 从结点x到结点y的最少费用为6，路径为xy<br> 从结点x到结点z的最少费用为8，路径为xz</strong></li><li>考虑下图所示的网络。假设每个节点初始时知道到每个邻居的费用。考虑距离向量算法，并给出节点z的距离表表项。<br> <img src="https://images2.imgbox.com/58/1f/MnqVxRFr_o.png" alt="在这里插入图片描述"><br> <strong>距离向量法，首先需要得到所有的点的一张二维相连表，即初始表格，如下</strong><br> <img src="https://images2.imgbox.com/92/a0/YJ6wVaTy_o.png" alt="在这里插入图片描述"><br> <strong>然后，选择最小的uv线路进行更新，将v点接入后，得到更新后的表格</strong><br> <img src="https://images2.imgbox.com/7c/ca/yQ9ZIQE7_o.png" alt="在这里插入图片描述"><br> <strong>然后，选择y点进行更新，得到更新后的表格，以此类推</strong><br> <img src="https://images2.imgbox.com/ee/72/xlAVWOhN_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="_162"></a>四、链路层</h3> 
<ol><li>假设某分组的信息内容是比特模式1110 0110 1001 1101，并且使用了偶校验方案。在采用二维奇偶校验方案的情况下，包含该检验比特的字段的值是什么？你的回答应该使用最小长度检验和字段。<br> <strong>首先，确定二维奇偶校验表格</strong><br> <img src="https://images2.imgbox.com/9a/94/S5jnrO7s_o.png" alt="在这里插入图片描述"><br> <strong>有偶数个1则为0，否则为1。</strong></li><li>考虑5比特生成多项式，G=10011，并且假设D的值为1010101010。R的值是什么。<br> <strong>由CRC得到r=b(G)-1=4</strong><br> <img src="https://images2.imgbox.com/2c/a0/1U3KoLk9_o.png" alt="在这里插入图片描述"><br> <strong>故R=0100<br> 注意是异或操作即可</strong></li><li>前面讲过，使用CSMA/CD协议，适配器在碰撞之后等待K<em>512比特时间，其中K是随机选取的。对于K=100，对于一个10Mbps的广播信道，适配器返回到第二步要等多长时间？对于100Mbps的广播信道来说呢？<br> **K=100，对于10MBPS。时间为100</em>512/10^6=5.12ms<br> K=100，对于100MBPS。时间为100*512/10^7=0.512ms**</li><li>假设结点A和结点B在相同的10Mbps广播信道上，并且这两个结点的传播时延为245比特时间。假设A和B同时发送以太网帧，帧发生了碰撞，然后A 和B在CSMA/CD算法中选择不同的K值。假设没有其他结点处于活跃状态，来自A和B的重传会碰撞吗？为此，完成下面的例子就足以说明问题了。假设A和B在t=0比特时间开始传输。他们在t=245比特时间都检测到了碰撞。假设KA=0,KB=1。B会将它的重传调整到什么时间？A在什么时间开始发送？（注意：这些结点在返回第2步之后，必须等待一个空闲信道，参见协议）A的信号在什么时间到达B呢？B在它预定的时刻抑制传输吗？<br> <strong>考虑强化碰撞的概念，，当发送数据的站检测到了碰撞，除了立即停止发送数据外，还要继续发送 32 比特或 48 比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。以及帧间最小间隔的概念，以太网规定帧间最小间隔为 9.6 μs，即 96 比特时间.<br> 这里取碰撞时间分别为32与48</strong><br> <img src="https://images2.imgbox.com/86/b6/FeVosrsE_o.png" alt="在这里插入图片描述"><br> <strong>可以看到，不管是32比特下（789+96=885&gt;863）还是48比特下（805+96=901&gt;879），都不会发生再碰撞</strong></li><li>现在考虑习题P14中地图5-33。对主机A、两台路由器和主机F的各个接口提供MAC地址和IP地址。假定主机A向主机F发送一个数据报。当在下列场合传输该帧时，给出在封装该IP数据报的帧中的源和目的MAC地址：<br> 1、从A到左边的路由器；<br> 2、从左边的路由器到右边的路由器；<br> 3、从右边的路由器到F<br> 还要给出到达每个点时封装在该帧中的IP数据报中的源和目的IP地址<br> <img src="https://images2.imgbox.com/2e/49/RqVZFR4m_o.png" alt="在这里插入图片描述"><br> <strong>(i):从 A 到左边的路由器<br> 源 MAC 地址： AA-AA-AA-AA-AA-AA<br> 源 IP 地址： 192.168.1.1 (A 的 ip)<br> 目的 MAC 地址： 11-11-11-11-11-11<br> 目的 IP 地址： 192.168.3.2（F 的 ip）<br> (ii):从左边的路由器到右边的路由器<br> 源 MAC 地址： 22-22-22-22-22-22<br> 源 IP 地址： 192.168.1.1（A 的 IP）<br> 目的 MAC 地址： 33-33-33-33-33-33<br> 目的 IP 地址： 192.168.3.2（F 的 ip）<br> (iii):从右边的路由器到 F<br> 源 MAC 地址： 44-44-44-44-44-44<br> 源 IP 地址： 192.168.1.1（A 的 IP）<br> 目的 MAC 地址： FF-FF-FF-FF-FF-FF<br> 目的 IP 地址： 192.168.3.2（F 的 ip）<br> 简单地讲，就是MAC地址直接指向下一个路由器，IP地址指向终点目的主机</strong></li><li>在某网络中标志为A到F的6个结点以星形与一台交换机连接，考虑在该网络环境中某个正在学习<br> 的交换机的运行情况。假定：<br> 该交换机表初始为空。显示在这些事件的前后该交换机表的状态。对于每个事件，指出在其上面转发传输的帧的链路，并简要地评价你的答案。<br> 1、B向E发送一个帧；<br> <strong>交换机记录B的MAC地址与到达的端口；由于交换机表为空，故向A、C、D、E、F 都发送此帧</strong><br> 2、E向B回答一个帧；<br> <strong>交换机记录B的MAC地址与到达的端口；由于交换机表有B的MAC地址，故只向B转发</strong><br> 3、A向B发送一个帧；<br> <strong>交换机记录A的MAC地址与到达的端口；由于交换机表有B的MAC地址，故只向B转发</strong><br> 4、B向A回答一个帧<br> <strong>交换机保持表的内容不变；由于已知A的MAC地址，故只向A转发</strong></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/078c6b8c30b62032cb6ca4ea9b58fe3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android P适配以太网功能开发指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53c264503b521cfa6c6452361d5e2eef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Day52    树状数组   线段树（lazy标记）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>