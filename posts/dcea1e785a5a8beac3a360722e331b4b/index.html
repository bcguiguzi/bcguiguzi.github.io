<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>_exit和exit的区别 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="_exit和exit的区别" />
<meta property="og:description" content="在linux的标准库函数中，有一套称作高级I/O的函数，我们熟知的printf 、fopen 、fread 、fwrite都在此列，他们也被称作缓冲I/O。其特征是对应每一个打开的文件，都存在一个缓冲区， 在内存中都有一片缓冲区，每次读文件会多读若干条记录，这样下次读文件时就可以直接从内存的缓存中取出，每次写文件时也仅仅是写入到内存的缓冲区，等待满足一定的条件（达到一定的数量，或者遇到特定字符，如换行和文件结束符EOF），再将缓冲区的内容一次性的写入文件，这样就大大增加了文件读写的速度，但也为我们编程带来了一点点麻烦，如果有些数据，我们认为已经写入了文件，实际上因为没有满足特定的条件，他们还只是保存在缓冲区内，这时我们用_exit函数直接将程序关闭，缓冲区中的数据就会丢失，反之，如果向保证数据的完整性，就一定要使用exit函数。
exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是图中的&#34;清理I/O缓冲一项。
exit()函数定义在stdlib.h中，而_exit()定义在unistd.h中。exit()和_exit()都用于正常终止一个函数。但_exit()直接是一个sys_exit系统调用，而exit()则通常是普通函数库中的一个函数。它会先执行一些清除操作，例如调用执行各终止处理函数、关闭所有标准IO等，然后调用sys_exit。
_exit()　－－－　直接结束进程进入到内核中
exit()　－－－　清理I/O缓冲区后再退出进程
下面我就举个例子说明下吧，
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf(&#34;I&#39;m ok!\n&#34;); printf(&#34;Good good study!&#34;); _exit(0); } //执行输出： //I&#39;m ok! #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf(&#34;I&#39;m ok!\n&#34;); printf(&#34;Good good study!&#34;); exit(0); } //执行输出： //I&#39;m ok! //Good good study! （转者注：我在visual studio上运行，两个程序的输出结果一样，都输出两句话，不清楚为什么和作者的输出不一样？）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/dcea1e785a5a8beac3a360722e331b4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-17T09:47:16+08:00" />
<meta property="article:modified_time" content="2018-10-17T09:47:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">_exit和exit的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在linux的标准库函数中，有一套称作高级I/O的函数，我们熟知的printf 、fopen 、fread 、fwrite都在此列，他们也被称作缓冲I/O。其特征是对应每一个打开的文件，都存在一个缓冲区， 在内存中都有一片缓冲区，每次读文件会多读若干条记录，这样下次读文件时就可以直接从内存的缓存中取出，每次写文件时也仅仅是写入到内存的缓冲区，等待满足一定的条件（达到一定的数量，或者遇到特定字符，如换行和文件结束符EOF），再将缓冲区的内容一次性的写入文件，这样就大大增加了文件读写的速度，但也为我们编程带来了一点点麻烦，<strong>如果有些数据，我们认为已经写入了文件，实际上因为没有满足特定的条件，他们还只是保存在缓冲区内，这时我们用_exit函数直接将程序关闭，缓冲区中的数据就会丢失，反之，如果向保证数据的完整性，就一定要使用exit函数。</strong></p> 
<p><strong>exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是图中的"清理I/O缓冲一项。</strong></p> 
<p>exit()函数定义在stdlib.h中，而<code>_exit()</code>定义在unistd.h中。exit()和<code>_exit()</code>都用于正常终止一个函数。但<code>_exit()</code>直接是一个sys_exit系统调用，而exit()则通常是普通函数库中的一个函数。它会先执行一些清除操作，例如调用执行各终止处理函数、关闭所有标准IO等，然后调用sys_exit。</p> 
<p><strong><code>_exit()</code>　 －－－　直接结束进程进入到内核中</strong></p> 
<p><strong><code>exit()</code>　 －－－　清理I/O缓冲区后再退出进程</strong></p> 
<p><strong>下面我就举个例子说明下吧，</strong></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    int ret = 0;
    printf("I'm ok!\n");
    printf("Good good study!");

    _exit(0);
}
//执行输出：
//I'm ok!
</code></pre> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    int ret = 0;
    printf("I'm ok!\n");
    printf("Good good study!");

    exit(0);
}
//执行输出：
//I'm ok!
//Good good study!
</code></pre> 
<p>（转者注：我在visual studio上运行，两个程序的输出结果一样，都输出两句话，不清楚为什么和作者的输出不一样？）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdb14eb5e25aa7c4c152292de31fbec2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">经典数字游戏——数独（Sudoku）解法的Python代码实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a99ac5613f8c0e6f00d81f0ba608bdcc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">throw和throws的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>