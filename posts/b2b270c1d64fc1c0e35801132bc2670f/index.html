<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>window环境使用C&#43;&#43;实现WebSocket - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="window环境使用C&#43;&#43;实现WebSocket" />
<meta property="og:description" content="最近因为项目需求,需要使用C&#43;&#43;实现WebSocket与浏览器进行通讯,针对WebSocket有很多开源的框架,但是本人比较懒,所以干脆手写一个算了.
https://download.csdn.net/download/weixin_34196559/10750141开源库
废话不说,直接上代码
1. 整体代码截图 全部代码,基本400行以内可以搞定
项目结构,因为实现WebSocket需要涉及到加密解密,所以从网上某大神哪里拿来了代码
以上是整体的代码结构, 下面我简单介绍下WebSocket的流程
先贴一张图 WebSocket的基本结构 想详细了解协议内容,看这位大神的博客 https://www.cnblogs.com/songwenjie/p/8575579.html
第一步 客户端首先发送握手请求(看下图, 他长这样), 在这里面最重要的就是那个Sec-WebSocket-Key 数值, 这玩意每次来都是随机,你需要对他按照固定方式加密然后返回给客户端, 多说一句,这请求头的意思打算把协议升级成WebSocket协议, 你要是同意就按照规矩加密数据传回来.
第二步 服务端返回握手响应给客户端(看下图, 他长这样)Sec-WebSocket-Accept: 就是加密后的Sec-WebSocket-Key. 这里多费几句话 WebSocket是以&#34;\r\n\r\n&#34;结尾的 这里一定要多加注意, 因为之前有些兄嘚后面加了一个莫名其妙的\0 导致链接会自己断开
同时报异常: failed: A server must not mask any frames that it sends to the client.
第三步 上面一顿操作猛如虎, 握手动作就完成了, 接下来就是普通的Socket通讯了, 唯一不同的就是来的数据用掩码处理过, 去的时候不能用掩码处理 不能用掩码处理 不能用掩码处理 重要的事情说三遍(看下图), 因为只要违反规则链接就会立马断开并且报异常 failed: A server must not mask any frames that it sends to the client." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b2b270c1d64fc1c0e35801132bc2670f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-04T23:40:01+08:00" />
<meta property="article:modified_time" content="2021-03-04T23:40:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">window环境使用C&#43;&#43;实现WebSocket</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近因为项目需求,需要使用C++实现WebSocket与浏览器进行通讯,针对WebSocket有很多开源的框架,但是本人比较懒,所以干脆手写一个算了.</p> 
<p><a href="https://download.csdn.net/download/weixin_34196559/10750141">https://download.csdn.net/download/weixin_34196559/10750141</a>开源库</p> 
<p>废话不说,直接上代码</p> 
<h2><a id="1__6"></a><strong>1. 整体代码截图</strong></h2> 
<p>全部代码,基本400行以内可以搞定</p> 
<p><img src="https://images2.imgbox.com/f5/5c/h58gKsKY_o.png" alt=""></p> 
<p>项目结构,因为实现WebSocket需要涉及到加密解密,所以从网上某大神哪里拿来了代码</p> 
<p><img src="https://images2.imgbox.com/96/f2/l0kquUK9_o.png" alt=""></p> 
<p>以上是整体的代码结构, 下面我简单介绍下WebSocket的流程</p> 
<p>先贴一张图 WebSocket的基本结构 想详细了解协议内容,看这位大神的博客 <a href="https://www.cnblogs.com/songwenjie/p/8575579.html" rel="nofollow">https://www.cnblogs.com/songwenjie/p/8575579.html</a></p> 
<p><img src="https://images2.imgbox.com/35/32/vIvxJUHq_o.png" alt=""></p> 
<p>第一步 客户端首先发送握手请求(看下图, 他长这样), 在这里面最重要的就是那个Sec-WebSocket-Key 数值, 这玩意每次来都是随机,你需要对他按照固定方式加密然后返回给客户端, 多说一句,这请求头的意思打算把协议升级成WebSocket协议, 你要是同意就按照规矩加密数据传回来.</p> 
<p><img src="https://images2.imgbox.com/9b/a4/ITPNW3hB_o.png" alt=""></p> 
<p>第二步 服务端返回握手响应给客户端(看下图, 他长这样)Sec-WebSocket-Accept: 就是加密后的Sec-WebSocket-Key. 这里多费几句话 WebSocket是以"\r\n\r\n"结尾的 这里一定要多加注意, 因为之前有些兄嘚后面加了一个莫名其妙的\0 导致链接会自己断开</p> 
<p><strong>同时报异常: failed: A server must not mask any frames that it sends to the client.</strong></p> 
<p><img src="https://images2.imgbox.com/0b/70/HshtpIwB_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/d7/b7/37djU4WD_o.png" alt=""></p> 
<p>第三步 上面一顿操作猛如虎, 握手动作就完成了, 接下来就是普通的Socket通讯了, 唯一不同的就是来的数据用掩码处理过, 去的时候不能用掩码处理 不能用掩码处理 不能用掩码处理 重要的事情说三遍(看下图), 因为只要违反规则链接就会立马断开并且报异常 <strong>failed: A server must not mask any frames that it sends to the client.</strong></p> 
<p>客户端发往服务端的数据 其中Mask 为true 表示数据经过掩码处理</p> 
<p><img src="https://images2.imgbox.com/44/73/Y8JENX3L_o.png" alt=""></p> 
<p>服务端发往客户端的数据 其中Mask为false 表示没有经过掩码处理</p> 
<p><img src="https://images2.imgbox.com/ce/d6/2O5lcPG0_o.png" alt=""></p> 
<p>如上便是WebSocket的通讯基本流程了</p> 
<h2><a id="2__47"></a>2. 代码分析</h2> 
<p>main 函数,程序入口</p> 
<p><img src="https://images2.imgbox.com/3f/3d/4p9UVrbn_o.png" alt=""></p> 
<p>Initsocket 函数 主要作用是创建Socket, 开启监听, 等待连接, 拿到连接后开启子线程处理具体的管道通讯</p> 
<p><img src="https://images2.imgbox.com/6c/a2/Nd9506BA_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/a7/ba/JAItE9ME_o.png" alt=""></p> 
<p>WorkThread 函数 线程函数相当于java内的Runnable的实现类,主要作用有两个,</p> 
<p>1.进行客户端服务端握手</p> 
<p>2.管道通讯</p> 
<p><img src="https://images2.imgbox.com/2a/ca/6Gh8i4NU_o.png" alt=""></p> 
<p>下面按照WorkThread 函数流程向下解释</p> 
<p>2.1握手动作</p> 
<p>第一个函数requestInfo</p> 
<p><img src="https://images2.imgbox.com/bd/29/Z4gpWJOW_o.png" alt=""></p> 
<p>他的主要作用是获取客户端发过来的握手请求,然后解析Sec-WebSocket-Key字段进行解析,然后生成握手响应数据</p> 
<p>下面我们来看一下requestInfo函数细节</p> 
<p><img src="https://images2.imgbox.com/ca/d6/FPNzhKAP_o.png" alt=""></p> 
<p>上图是requestInfo函数代码</p> 
<p>首先通过recv 函数获取到客户端发送过来的数据</p> 
<p><img src="https://images2.imgbox.com/0a/7e/dqk4MsPu_o.png" alt=""></p> 
<p>然后去请求头中查找Sec-WebSocket-Key字段(看下图)</p> 
<p><img src="https://images2.imgbox.com/4c/e0/Skh1R41T_o.png" alt=""></p> 
<p>获取成功后调用getKey 函数 来生成握手响应数据(看下图)</p> 
<p><img src="https://images2.imgbox.com/e4/10/v5ZupaQq_o.png" alt=""></p> 
<p>图中那个258开头的字符串是固定的 将客户端发送过来的Sec-WebSocket-Key字段与他拼接,然后进行加密, 这样响应给客户端,这样就可以完成整个握手动作,这也是握手动作的关键所在,.</p> 
<p>到此我们的响应数据已经封装完毕了, 只要将他返回给客户端就可以完成握手行为了(看图)</p> 
<p><img src="https://images2.imgbox.com/a9/6b/Rs0dBN4I_o.png" alt=""></p> 
<p>2.2 数据通信</p> 
<p>其实WebSocket在本质上就是Socket, 只不过要先通过握手动作来验证身份(协议升级, http升级到SwebSocket协议)</p> 
<p>剩余的通讯其实跟socket就一毛一样了,唯一的不通点是客户端给服务端发送的数据是经过加密的,所以拿到数据后需要解密才可以看到具体的数据, 但是服务端向客户端发送的数据却是不能加密的(看下图, 典型的socket通讯)</p> 
<p><img src="https://images2.imgbox.com/02/40/5ot2XQC2_o.png" alt=""></p> 
<p>首先, 我们来看接受数据代码, 在图中就是简单的recv函数, 这样我们就拿到了数据, 但是刚才我们讲到过数据经过加密, 所以需要使用 getClientInfo 函数来解密数据(关于getClientInfo函数是如何解密的,我不懂,代码是别的大神写的,很好用), 这里只展示下片段,具体代码,可以看demo</p> 
<p><img src="https://images2.imgbox.com/22/57/tS6UeOFw_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/d2/fd/rEHHdAhA_o.png" alt=""></p> 
<p>经过上面一顿操作我们就可以看到客户端发送的数据了</p> 
<p>下面就是我们需要给客户端发送数据了, 虽然WebSocket协议规定了不需要加密数据, 但是还是要有点其他的操作的(看responseInfo函数–&gt; respondClient 函数)</p> 
<p><img src="https://images2.imgbox.com/97/f5/k8xrEsGz_o.png" alt=""></p> 
<p>调用respondClient函数, 继续看<img src="https://images2.imgbox.com/f6/48/YgqK0MXt_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/c5/95/IvQdnX0J_o.png" alt=""></p> 
<p>respondClient函数实际上是封装响应数据的主要函数, 根据WebSocket协议, 发送给客户端的数据其实分三种, 不同的数据长度是不一样的, 这也就是为什么要声明realDateLength变量了</p> 
<p><img src="https://images2.imgbox.com/b2/0f/Gzb1yXBD_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/8a/5b/uz0IdlSz_o.png" alt=""></p> 
<p>当数据长度小于126的时候,头部多了两个长度, 当 小于65536的时候头部多了 4个长度, 其他的数据(大于65536)头部多了10个长度(具体这玩意叫啥可以去看WebSocket协议, 我记不清了)</p> 
<p>这样我们就可以把数据响应到客户端了</p> 
<p>以上我们就完成了WebSocket的所有代码了</p> 
<p>资料链接信息在我另外一篇博客</p> 
<p><a href="https://blog.csdn.net/du771278794/article/details/88742423">https://blog.csdn.net/du771278794/article/details/88742423</a></p> 
<p>源码地址 <a href="https://pan.baidu.com/s/1peF4Y4dEmAUE9aoFWuCb4w" rel="nofollow">https://pan.baidu.com/s/1peF4Y4dEmAUE9aoFWuCb4w</a>  dj9x</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb34cf6a408991b9a47b18b748d7fbc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">preference的解析与显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac18690679baa166c78cf308f24b3f2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 查询转对象_在ElasticSearch中将SearchHit转换为Java对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>