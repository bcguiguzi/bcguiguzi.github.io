<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构入门篇 之 【双链表】的实现讲解（附完整实现代码及顺序表与线性表的优缺点对比） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构入门篇 之 【双链表】的实现讲解（附完整实现代码及顺序表与线性表的优缺点对比）" />
<meta property="og:description" content="一日读书一日功，一日不读十日空
书中自有颜如玉，书中自有黄金屋
一、双链表 1、双链表的结构 2、双链表的实现 1）、双向链表中节点的结构定义 2）、初始化函数 LTInit 3）、尾插函数 LTPushBack 4）、头插函数 LTPushFront 5）、尾删函数 LTPopBack 6）、头删函数 LTPopFront 7）、查找函数 LTFind 8）、在指定位置之后插入数据函数 LTInsert 9）、删除指定位置数据函数 LTErase 10）、销毁函数 LTDesTroy 二、双链表完整代码 三、顺序表和链表的优缺点对比 四、完结撒❀ 前言
学习前先思考3个问题：
1.顺序表和链表的关系是什么？2.链表的分类有哪些？3.顺序表和链表的优缺点有哪些？ –❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–
1.顺序表和链表的关系是什么
我们之前学习了“顺序表”，“单链表”。
链表和顺序表都是线性表。
线性表是指
逻辑结构：一定是线性的。
物理结构：不一定是线性的。
物理结构是指表在内存中开辟的空间结构，顺序表的物理结构是连续的，而链表的物理结构是不连续的，但它们的逻辑结构都是连续的。
2.链表的分类有哪些？
链表根据带头或者不带头，单向或者双向，循环或者不循环一共分为8种。
我们之前所学的单链表全名是叫：不带头单向不循环链表，而现在要学习的双链表是叫带头双向循环链表。
双链表：
掌握单链表和双链表对于其他链表的实现也就不那么困难了。
3.顺序表和链表的优缺点有哪些？
这里涉及到顺序表和链表的对比，先讲解双向链表，这放到博客末尾为大家对比讲解
一、双链表 1、双链表的结构 注意：这里的“带头”跟前面我们说的“头节点”是两个概念。
带有节点里的头节点实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这里“放哨的”
“哨兵位”存在的意义：
遍历循环链表避免出现死循环。
2、双链表的实现 对于双向链表的实现，我们依然使用List.h,List.c,test.c,三个文件进行实现。
1）、双向链表中节点的结构定义 上面我们简单介绍过双链表，其全名为：带头双向循环链表。
带头：指链表中带有哨兵位。
双向：双链表的每个节点内含有两个链表指针变量，分别指向前一个节点和后一个节点，所以就可以通过一个节点找到这个节点前后的两个节点。
循环：链表中的每个节点互相连接，最后一个节点与哨兵位相连构成一个环，整体逻辑结构可以进行循环操作。
代码如下：
//定义双向链表中节点的结构 typedef int LTDataType; typedef struct ListNode { struct ListNode* prev; LTDataType data; struct ListNode* next; }LTNode; 这里将结构体进行了重命名为LTNode。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/66eeb6b67f0a547529735a5c00a38f8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T16:27:30+08:00" />
<meta property="article:modified_time" content="2024-03-14T16:27:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构入门篇 之 【双链表】的实现讲解（附完整实现代码及顺序表与线性表的优缺点对比）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/b2/5b/r6BVSuXg_o.png" alt="在这里插入图片描述"><br> 一日读书一日功，一日不读十日空<br> 书中自有颜如玉，书中自有黄金屋</p> 
<h2><a id="_3"></a>一、双链表</h2> 
<h3><a id="1_4"></a>1、双链表的结构</h3> 
<h3><a id="2_5"></a>2、双链表的实现</h3> 
<h4><a id="1_6"></a>1）、双向链表中节点的结构定义</h4> 
<h4><a id="2_LTInit_7"></a>2）、初始化函数 LTInit</h4> 
<h4><a id="3_LTPushBack_8"></a>3）、尾插函数 LTPushBack</h4> 
<h4><a id="4_LTPushFront_9"></a>4）、头插函数 LTPushFront</h4> 
<h4><a id="5_LTPopBack_10"></a>5）、尾删函数 LTPopBack</h4> 
<h4><a id="6_LTPopFront_11"></a>6）、头删函数 LTPopFront</h4> 
<h4><a id="7_LTFind_12"></a>7）、查找函数 LTFind</h4> 
<h4><a id="8_LTInsert_13"></a>8）、在指定位置之后插入数据函数 LTInsert</h4> 
<h4><a id="9_LTErase_14"></a>9）、删除指定位置数据函数 LTErase</h4> 
<h4><a id="10_LTDesTroy_15"></a>10）、销毁函数 LTDesTroy</h4> 
<h2><a id="_16"></a>二、双链表完整代码</h2> 
<h2><a id="_17"></a>三、顺序表和链表的优缺点对比</h2> 
<h2><a id="_18"></a>四、完结撒❀</h2> 
<p>前言</p> 
<p>学习前先思考3个问题：</p> 
<table><thead><tr><th>1.顺序表和链表的关系是什么？</th><th></th></tr></thead><tbody><tr><td>2.链表的分类有哪些？</td><td></td></tr><tr><td>3.顺序表和链表的优缺点有哪些？</td><td></td></tr></tbody></table> 
<p>–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–<br> <strong>1.顺序表和链表的关系是什么</strong></p> 
<p>我们之前学习了“顺序表”，“单链表”。<br> 链表和顺序表都是<strong>线性表</strong>。<br> 线性表是指</p> 
<p><strong>逻辑结构：一定是线性的。<br> 物理结构：不一定是线性的。</strong><br> <img src="https://images2.imgbox.com/a1/83/w9QDYG9q_o.png" alt="在这里插入图片描述"><strong>物理结构是指表在内存中开辟的空间结构</strong>，顺序表的物理结构是连续的，而链表的物理结构是不连续的，但它们的逻辑结构都是连续的。</p> 
<p><strong>2.链表的分类有哪些？</strong><br> 链表根据<strong>带头或者不带头</strong>，<strong>单向或者双向</strong>，<strong>循环或者不循环</strong>一共分为<strong>8种</strong>。<br> 我们之前所学的<strong>单链表</strong>全名是叫：<strong>不带头单向不循环链表</strong>，而现在要学习的双链表是叫<strong>带头双向循环链表</strong>。<br> 双链表：<br> <img src="https://images2.imgbox.com/6f/db/jUC2ZJnb_o.png" alt="在这里插入图片描述">掌握单链表和双链表对于其他链表的实现也就不那么困难了。</p> 
<p><strong>3.顺序表和链表的优缺点有哪些？</strong><br> 这里涉及到顺序表和链表的对比，<strong>先讲解双向链表</strong>，这放到<strong>博客末尾</strong>为大家对比讲解</p> 
<h2><a id="_47"></a>一、双链表</h2> 
<h3><a id="1_48"></a>1、双链表的结构</h3> 
<p><img src="https://images2.imgbox.com/f3/ba/VqdaDfRU_o.png" alt="在这里插入图片描述">注意：<strong>这里的“带头”跟前面我们说的“头节点”是两个概念。</strong><br> 带有节点里的头节点实际为“哨兵位”，<strong>哨兵位节点不存储任何有效元素</strong>，只是站在这里“放哨的”</p> 
<p>“哨兵位”存在的意义：<br> <strong>遍历循环链表避免出现死循环。</strong></p> 
<h3><a id="2_54"></a>2、双链表的实现</h3> 
<p>对于双向链表的实现，我们依然使用<strong>List.h</strong>,<strong>List.c</strong>,<strong>test.c</strong>,三个文件进行实现。</p> 
<h4><a id="1_56"></a>1）、双向链表中节点的结构定义</h4> 
<p>上面我们简单介绍过双链表，其全名为：<strong>带头双向循环链表</strong>。</p> 
<p>带头：指链表中带有<strong>哨兵位</strong>。<br> 双向：双链表的每个节点内含有<strong>两个链表指针变量</strong>，分别指向前一个节点和后一个节点，所以就可以通过一个节点找到这个节点前后的两个节点。<br> 循环：链表中的每个节点互相连接，最后一个节点与哨兵位相连构成一个环，<strong>整体逻辑结构可以进行循环操作</strong>。</p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//定义双向链表中节点的结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> LTDataType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> prev<span class="token punctuation">;</span>
	LTDataType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LTNode<span class="token punctuation">;</span>
</code></pre> 
<p>这里将结构体进行了重命名为LTNode。</p> 
<h4><a id="2_LTInit_76"></a>2）、初始化函数 LTInit</h4> 
<p>在创建双链表中的<strong>哨兵位</strong>时我们需要对其进行初始化，防止意料之外的情况发生。<br> 根据所传形参的类型不同，我们有两种写法<br> 代码如下：</p> 
<p>方案1</p> 
<pre><code class="prism language-c"><span class="token comment">//方案1</span>
<span class="token keyword">void</span> <span class="token function">LTInit</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mallic:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方案2</p> 
<pre><code class="prism language-c">LTNode<span class="token operator">*</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>LTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newnode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	newnode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//方案2</span>
LTNode<span class="token operator">*</span> <span class="token function">LTInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LTNode<span class="token operator">*</span> phead <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> phead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方案2里面包含了节点空间申请的函数，只是简单的创建双链表的节点，这里就不展开讲解了。</p> 
<h4><a id="3_LTPushBack_124"></a>3）、尾插函数 LTPushBack</h4> 
<p>老规矩，我们开始实现管理链表数据的函数，这里讲的是头插。<br> <img src="https://images2.imgbox.com/f1/4d/uE52xvKj_o.png" alt="在这里插入图片描述">假如我们要在链表中尾插一个6，那么我们是需要先创建一个节点来存储6，下面分两步：</p> 
<p><strong>1.将6的节点里面前（<em>prev</em>）后（<em>next</em>）链表指针变量对应与原链表的尾节点d3和哨兵位head进行连接<br> 2.将原链表尾节点d3的后链表指针变量（<em>next</em>）指向6的节点，再将哨兵位head的前链表指针变量（<em>prev</em>）指向6的节点</strong></p> 
<p>完成上面两部就实现了节点的插入。<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//尾插</span>
<span class="token keyword">void</span> <span class="token function">LTPushBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>

	phead<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	phead<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的<strong>LTBuyNode函数</strong>在初始化函数中提到过。</p> 
<h4><a id="4_LTPushFront_150"></a>4）、头插函数 LTPushFront</h4> 
<p>实现了尾插，头插也是大同小异。<br> 头插是指在哨兵位后面的进行插入，第一个有效节点之前插入，即为头插。<br> <img src="https://images2.imgbox.com/95/9d/deTtrsWe_o.png" alt="在这里插入图片描述">根据上图，进行头插</p> 
<p><strong>1.改变插入节点6的前后链表指针变量的指向。<br> 2.再分别改变哨兵位head后链表指针变量（<em>next</em>）和第一个有效节点d1的前链表指针变量（<em>prev</em>）的指向。</strong></p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//头插</span>
<span class="token keyword">void</span> <span class="token function">LTPushFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token punctuation">;</span>

	phead<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	phead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也是简简单单。</p> 
<h4><a id="5_LTPopBack_176"></a>5）、尾删函数 LTPopBack</h4> 
<p>尾删函数的操作如下图：<br> <img src="https://images2.imgbox.com/5a/4b/jdj80ETn_o.png" alt="在这里插入图片描述"><br> <strong>1.改变哨兵位的前链表指针变量，指向原链表（还没尾删时的链表）尾节点d3的前链表指针变量（即倒数第二个节点d2的地址）。<br> 2.相反，再将d2节点的后链表指针变量（<em>next</em>）指向哨兵位head。</strong></p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//尾删</span>
<span class="token keyword">void</span> <span class="token function">LTPopBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//链表只有一个哨兵位也不行</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//要进行尾删的节点</span>
	LTNode<span class="token operator">*</span> ddel <span class="token operator">=</span> del<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//要进行删除的前一节点</span>
	phead<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> ddel<span class="token punctuation">;</span>
	ddel<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>
	del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>记得最后将尾删的节点空间进行释放。</p> 
<h4><a id="6_LTPopFront_201"></a>6）、头删函数 LTPopFront</h4> 
<p>头删函数的操作如下图：<br> <img src="https://images2.imgbox.com/67/a2/qWwpjapl_o.png" alt="在这里插入图片描述">与尾删也是大同小异<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//头删 在哨兵位之后进行删除</span>
<span class="token keyword">void</span> <span class="token function">LTPopFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//要进行删除的节点</span>
	LTNode<span class="token operator">*</span> ddel <span class="token operator">=</span> del<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//要进行删除节点的下一个节点</span>

	phead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> ddel<span class="token punctuation">;</span>
	ddel<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>
	del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="7_LTFind_221"></a>7）、查找函数 LTFind</h4> 
<p>既然要查找，那么肯定需要遍历链表并且也要保证<strong>链表不为空</strong>。</p> 
<p><strong>在双链表中，当链表中只剩下哨兵位，那么这个链表即为空链表。</strong></p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//查找</span>
LTNode<span class="token operator">*</span> <span class="token function">LTFind</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//遍历链表</span>
	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> phead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> pcur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>断言时进行的assert(phead != phead-&gt;next);便是判断链表是否为空的条件。<br> 而while (pcur != phead)是判断是否将链表遍历完的条件。<br> 找到的话就返回给节点的地址，没有找到就返回空指针。</p> 
<h4><a id="8_LTInsert_251"></a>8）、在指定位置之后插入数据函数 LTInsert</h4> 
<p>操作过程如下图所示：<br> <img src="https://images2.imgbox.com/2d/e8/kHjt6HRU_o.png" alt="在这里插入图片描述">假设我们在节点d2后面进行节点的插入，那么会受到影响的就是d2节点的后链表指针变量（next）和d3节点的前链表指针变量（prev），需要执行的操作：</p> 
<p><strong>1.将newnode节点的前链表指针变量（prev）指向d2节点，再将newnode节点的后链表指针变量（next）指向d3节点<br> 2.将d3节点的前链表指针变量（prev）指向newnode’节点，再将d2节点的后链表指针变量（next）指向newnode节点。</strong></p> 
<p><strong>注意！ 第2步指针变量改变指向的先后顺序不能改变，不然指向地址不正确！</strong></p> 
<p>代码如下；</p> 
<pre><code class="prism language-c"><span class="token comment">//在pos位置之后插入数据</span>
<span class="token keyword">void</span> <span class="token function">LTInsert</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> pos<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

	pos<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="9_LTErase_278"></a>9）、删除指定位置数据函数 LTErase</h4> 
<p>操作过程如下图所示：<br> <img src="https://images2.imgbox.com/2b/7a/YHhcdmfw_o.png" alt="在这里插入图片描述">假设删除d3节点，很明显这就是尾删操作，所以删除指定位置数据与其他删除函数也是一样的原理，其影响到的就是删除节点前后的节点链表指针的指向。</p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//删除pos位置的数据</span>
<span class="token keyword">void</span> <span class="token function">LTErase</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pos之后的数据</span>
	LTNode<span class="token operator">*</span> front <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//pos之前的数据</span>

	front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> del<span class="token punctuation">;</span>
	del<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> front<span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>重要的是最在要记得将删除的节点空间进行销毁。</strong></p> 
<h4><a id="10_LTDesTroy_301"></a>10）、销毁函数 LTDesTroy</h4> 
<p>那么最后的一个函数，销毁函数。<br> 创建双建表使用后我们一定不要忘记进行销毁，将开辟的内存空间归还给计算机，不然在以后中可能会出现内存泄漏的工作事故。<br> 销毁函数也<strong>根据传参类型不同</strong>有两种方案<br> 代码如下：<br> 方案1</p> 
<pre><code class="prism language-c"><span class="token comment">//方案1</span>
<span class="token keyword">void</span> <span class="token function">LTDesTroy</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> phead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		LTNode<span class="token operator">*</span> next <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pcur <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方案2</p> 
<pre><code class="prism language-c"><span class="token comment">//方案2</span>
<span class="token keyword">void</span> <span class="token function">LTDesTroy</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		LTNode<span class="token operator">*</span> next <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pcur <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对比之下<strong>方案1所传的形参为一级指针</strong>，而<strong>方案2为二级指针</strong>，因此我们是可以在<strong>方案2中直接对形参解引用得到双链表的哨兵位进行释放，而方案1并不行。</strong><br> 所以大家评判一下是那种方案更好呢？<br> 其实是<strong>方案1更好</strong>，因为我们需要<strong>保持接口一致性</strong>，细心的同学可能已经发现了，之前所写的函数<strong>形参都为一级指针</strong>，所以我们在写代码的时候保持接口一致性也是很重要的，所以方案1更合适一些，<strong>至于链表中哨兵位的释放，我们下面在销毁函数外（主函数内）进行销毁即可。</strong></p> 
<h2><a id="_347"></a>二、双链表完整代码</h2> 
<p><strong>List.h:</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>

<span class="token comment">//定义双向链表中节点的结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> LTDataType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> prev<span class="token punctuation">;</span>
	LTDataType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LTNode<span class="token punctuation">;</span>

<span class="token comment">//注意双向链表是带有哨兵位的，插入数据之前链表中必须先插入一个哨兵位</span>

<span class="token comment">//void LTInit(LTNode** pphead);</span>
LTNode<span class="token operator">*</span> <span class="token function">LTInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">LTDesTroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//尾插</span>
<span class="token keyword">void</span> <span class="token function">LTPushBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//头插</span>
<span class="token keyword">void</span> <span class="token function">LTPushFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//尾删</span>
<span class="token keyword">void</span> <span class="token function">LTPopBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//头删</span>
<span class="token keyword">void</span> <span class="token function">LTPopFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//查找</span>
LTNode<span class="token operator">*</span> <span class="token function">LTFind</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span>LTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//在pos位置之后插入数据</span>
<span class="token keyword">void</span> <span class="token function">LTInsert</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//删除pos位置的数据</span>
<span class="token keyword">void</span> <span class="token function">LTErase</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>List.c:</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"List.h"</span> </span>

LTNode<span class="token operator">*</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>LTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newnode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	newnode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//方案1</span>
<span class="token comment">//void LTInit(LTNode** pphead)</span>
<span class="token comment">//{<!-- --></span>
<span class="token comment">//	(*pphead) = (LTNode*)malloc(sizeof(LTNode));</span>
<span class="token comment">//	if (*pphead == NULL)</span>
<span class="token comment">//	{<!-- --></span>
<span class="token comment">//		perror("mallic:");</span>
<span class="token comment">//		exit(1);</span>
<span class="token comment">//	}</span>
<span class="token comment">//</span>
<span class="token comment">//	(*pphead)-&gt;data = -1;</span>
<span class="token comment">//	(*pphead)-&gt;prev = (*pphead)-&gt;next = *pphead;</span>
<span class="token comment">//}</span>

<span class="token comment">//方案2</span>
LTNode<span class="token operator">*</span> <span class="token function">LTInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LTNode<span class="token operator">*</span> phead <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> phead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//尾插</span>
<span class="token keyword">void</span> <span class="token function">LTPushBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>

	phead<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	phead<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">LTPrint</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> phead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d-&gt;"</span><span class="token punctuation">,</span> pcur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//头插</span>
<span class="token keyword">void</span> <span class="token function">LTPushFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token punctuation">;</span>

	phead<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	phead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//尾删</span>
<span class="token keyword">void</span> <span class="token function">LTPopBack</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//链表只有一个哨兵位也不行</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//要进行尾删的节点</span>
	LTNode<span class="token operator">*</span> ddel <span class="token operator">=</span> del<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//要进行删除的前一节点</span>
	phead<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> ddel<span class="token punctuation">;</span>
	ddel<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>
	del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//头删 在哨兵位之后进行删除</span>
<span class="token keyword">void</span> <span class="token function">LTPopFront</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//要进行删除的节点</span>
	LTNode<span class="token operator">*</span> ddel <span class="token operator">=</span> del<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//要进行删除节点的下一个节点</span>

	phead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> ddel<span class="token punctuation">;</span>
	ddel<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> phead<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>
	del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//查找</span>
LTNode<span class="token operator">*</span> <span class="token function">LTFind</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//遍历链表</span>
	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> phead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pcur<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> pcur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pcur <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//删除pos位置的数据</span>
<span class="token keyword">void</span> <span class="token function">LTErase</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	LTNode<span class="token operator">*</span> del <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pos之后的数据</span>
	LTNode<span class="token operator">*</span> front <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span><span class="token comment">//pos之前的数据</span>

	front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> del<span class="token punctuation">;</span>
	del<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> front<span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//在pos位置之后插入数据</span>
<span class="token keyword">void</span> <span class="token function">LTInsert</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> LTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">LTBuyNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> pos<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

	pos<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//方案1</span>
<span class="token keyword">void</span> <span class="token function">LTDesTroy</span><span class="token punctuation">(</span>LTNode<span class="token operator">*</span> phead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead <span class="token operator">!=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	LTNode<span class="token operator">*</span> pcur <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>pcur <span class="token operator">!=</span> phead<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		LTNode<span class="token operator">*</span> next <span class="token operator">=</span> pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pcur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pcur <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//方案2</span>
<span class="token comment">//void LTDesTroy(LTNode** pphead)</span>
<span class="token comment">//{<!-- --></span>
<span class="token comment">//	assert(pphead);</span>
<span class="token comment">//	assert(*pphead);</span>
<span class="token comment">//</span>
<span class="token comment">//	LTNode* pcur = (*pphead)-&gt;next;</span>
<span class="token comment">//	while (pcur != (*pphead))</span>
<span class="token comment">//	{<!-- --></span>
<span class="token comment">//		LTNode* next = pcur-&gt;next;</span>
<span class="token comment">//		free(pcur);</span>
<span class="token comment">//		pcur = next;</span>
<span class="token comment">//	}</span>
<span class="token comment">//	free((*pphead));</span>
<span class="token comment">//	(*pphead) = NULL;</span>
<span class="token comment">//}</span>
</code></pre> 
<h2><a id="_583"></a>三、顺序表和链表的优缺点对比</h2> 
<p>学到这里大家会感觉双链表听起来可能比较复杂，但学完之后感觉比顺序表和单链表还容易，事实就是如此。<br> <strong>顺序表和双向链表优缺点分析：</strong><br> <img src="https://images2.imgbox.com/98/11/TiFs24CU_o.png" alt="在这里插入图片描述">由上图，并不是双链表一定比顺序表好。<br> <strong>顺序表和双链表各有优势，我们在使用中要根据实际情况选择适合的线性表进行存储就是最好的。</strong></p> 
<h2><a id="_588"></a>四、完结撒❀</h2> 
<p>如果以上内容对你有帮助不妨点赞支持一下，以后还会分享更多计算机知识，我们一起进步。<br> 最后我想讲的是，据说点赞的都能找到漂亮女朋友<br> <img src="https://images2.imgbox.com/59/9b/PBeXXt73_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c8754d70b21f19a10d0e2d06389bc0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于单片机的家庭防盗报警系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02deb4c9f45e7cb6a981cb5f04dae3c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【嵌入式——QT】QThread创建多线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>