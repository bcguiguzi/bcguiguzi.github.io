<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue websocket  webRTC实现用户登录上下线功能 以及视频通话功能 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue websocket  webRTC实现用户登录上下线功能 以及视频通话功能" />
<meta property="og:description" content="只是自己的理解，不是最好的解决办法，哈哈。
webRTC 和 WebSocket 要了解一下。。
WebRTC（Web Real-Time Communication）即网页即时通信，是一个支持网页浏览器进行实时语音对话或视频对话的API。WebSocket是一种在单个TCP连接上进行全双工通信的协议。在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 首先实现用户登录以及用户列表是否在线。参考https://blog.csdn.net/qq_38455201/article/details/80374712
登录页面用onopen的连接websocket后onmessage会返回信息，其实应该是在全局去连接，因为我是个小demo就这样直接写了，前提是要用https 以及要有个websocket的服务
然后用户列表页面用onmessage去根据服务器返回的type 去更新当前的列表用户是否在线
this.socket = new WebSocket(this.socketUrl &#43; this.$route.query.user) this.socket.onmessage = function (evt) { var received_msg = evt.data; console.log(&#34;数据已接收:&#34; &#43;received_msg); var obj = JSON.parse(received_msg); //1代表上线 2代表下线 3代表在线名单 4代表普通消息 if(obj.msgType==1 || obj.msgType == 3) { _this.onlineUsers = obj.onlineUsers; _this.updateOnlineTable() } if(obj.msgType==1){ var onlineName = obj.useName; _this.setMessageInnerHTML(onlineName&#43;&#34;上线了&#34;); } else if(obj.msgType==2){ var offlineName = obj.useName; _this.offUsers = obj.useName _this.offOnlineTable() _this.setMessageInnerHTML(offlineName&#43;&#34;下线了&#34;); } else if(obj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/715a2cd5c96ca4b0d2ebb61518374799/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-02T10:29:42+08:00" />
<meta property="article:modified_time" content="2020-11-02T10:29:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue websocket  webRTC实现用户登录上下线功能 以及视频通话功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>只是自己的理解，不是最好的解决办法，哈哈。</p> 
<p><strong>webRTC 和 WebSocket</strong> 要了解一下。。</p> 
<ul><li><code>WebRTC</code>（Web Real-Time Communication）即网页即时通信，是一个支持网页浏览器进行实时语音对话或视频对话的API。</li><li><code>WebSocket</code>是一种在单个TCP连接上进行全双工通信的协议。在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</li></ul> 
<p><strong>首先实现用户登录以及用户列表是否在线。</strong>参考<a href="https://blog.csdn.net/qq_38455201/article/details/80374712">https://blog.csdn.net/qq_38455201/article/details/80374712</a></p> 
<p>登录页面用onopen的连接websocket后onmessage会返回信息，其实应该是在全局去连接，因为我是个小demo就这样直接写了，前提是要用https 以及要有个websocket的服务</p> 
<p>然后用户列表页面用onmessage去根据服务器返回的type 去更新当前的列表用户是否在线</p> 
<pre><code class="language-javascript">this.socket = new WebSocket(this.socketUrl + this.$route.query.user)
this.socket.onmessage = function (evt) {
            var received_msg = evt.data;
            console.log("数据已接收:" +received_msg);
            var obj = JSON.parse(received_msg);
            //1代表上线 2代表下线 3代表在线名单 4代表普通消息
            if(obj.msgType==1 || obj.msgType == 3) {
                _this.onlineUsers = obj.onlineUsers;
                _this.updateOnlineTable()
            }
            if(obj.msgType==1){
                var onlineName = obj.useName;
                _this.setMessageInnerHTML(onlineName+"上线了");
            }
            else if(obj.msgType==2){
                var offlineName = obj.useName;
                _this.offUsers = obj.useName
                _this.offOnlineTable()
                 _this.setMessageInnerHTML(offlineName+"下线了");
            }
            else if(obj.msgType==3){
                // _this.onlineUsers = obj.onlineUsers;
                // _this.updateOnlineTable()
                console.log("获取了在线的名单"+_this.onlineUsers.toString());
            }
        };</code></pre> 
<p> </p> 
<p>然后退出系统的按钮 调取close方法， 服务器响应，用户下线还是在onmessage里面返回的</p> 
<pre><code class="language-javascript">  // 退出
    logOut () {
        this.socket.close()
        let _this = this
           //   // 监听Socket的关闭
       this.socket.onclose = function(str) { 
          console.log(str);
          console.log('与服务器连接关闭: ' + str.code)
        //    _this.socket.close()
        };    
    }</code></pre> 
<p>我的列表页面：</p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/10/95/XRac8Lxt_o.png" width="824"></p> 
<p><strong>webRTC实现视频通话</strong>  参考   <a href="https://segmentfault.com/a/1190000020780854" rel="nofollow">https://segmentfault.com/a/1190000020780854</a>   <a href="https://github.com/chyingp/blog/find/master">https://github.com/chyingp/blog/find/master</a></p> 
<p><a href="https://segmentfault.com/a/1190000002658593" rel="nofollow">https://segmentfault.com/a/1190000002658593</a></p> 
<p>主要是理解透着两个步骤，第一个步骤里的东西。</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/46/87/0cDzH5kD_o.png" width="783"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7726a54da438f241a8f03af3b7e519e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">项目实战：Qt编译Qt库以及使用C#调用Qt库，并实现C#集成Qt的tcp客户端</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/655f33fdaad8e1def1ddb9244df4583a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode C&#43;&#43; 判断n的阶乘后有多少个0,以及满足阶乘后K个0的数的个数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>