<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Variable Types - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; Variable Types" />
<meta property="og:description" content="在C语言中，每一个变量都有两个属性：数据类型和存储类型。
数据类型即常说的字符型、整型、浮点型；存储类型则指变量在内存中的存储方式，它决定了变量的作用域和生存期。 变量的数据类型（Fundamental Type） 学了C然后C&#43;&#43;，然后 Windows/MFC，然后是C#，其中数据类型很多，由基本类型衍生的typedef类型也N多。
熟知基本数据类型是我们正确表达实际问题中各种数据的前提，因此我分类总结了一下 C/C&#43;&#43;/Windows /C# 基本数据类型，以便日后查阅。
参考 GNU 的 Data Type Measurements 和 MSDN 的 Fundamental Types (C&#43;&#43;) &amp; Data Type Ranges &amp; C&#43;&#43; Type System (Modern C&#43;&#43;) 相关文档。
C/C&#43;&#43; 基本数据类型 Type
Size
值域（limit）
无值型void
0 byte
无值域
布尔型bool
1 byte
true/false
有符号短整型 short [int] /signed short [int]
2 byte（__SIZEOF_SHORT__）
[SHRT_MIN,SHRT_MAX]
无符号短整型 unsigned short [int]
2 byte
[0,USHRT_MAX]
有符号整型 int /signed [int]
4 byte（__SIZEOF_INT__）
[INT_MIN,INT_MAX]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/71d654c84bea2d65c16997bb12c61b18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T11:57:01+08:00" />
<meta property="article:modified_time" content="2024-03-14T11:57:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Variable Types</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在C语言中，每一个变量都有两个属性：数据类型和存储类型。</p> 
<ul><li>数据类型即常说的字符型、整型、浮点型；</li><li>存储类型则指变量在内存中的存储方式，它决定了变量的作用域和生存期。</li></ul> 
<h2><strong>变量的<a href="http://en.cppreference.com/w/cpp/language/type" rel="nofollow" title="数据类型">数据类型</a>（<a href="http://en.cppreference.com/w/cpp/language/types" rel="nofollow" title="Fundamental Type">Fundamental Type</a>）</strong></h2> 
<blockquote> 
 <p>学了C然后C++，然后 Windows/MFC，然后是C#，其中数据类型很多，由基本类型衍生的typedef类型也N多。</p> 
 <p>熟知基本数据类型是我们正确表达实际问题中各种数据的前提，因此我分类总结了一下 C/C++/Windows /C# 基本数据类型，以便日后查阅。</p> 
 <p><strong><span style="color:#990000;">参考</span></strong> GNU 的 <a href="http://www.gnu.org/software/libc/manual/html_node/Data-Type-Measurements.html" rel="nofollow" title="Data Type Measurements">Data Type Measurements</a> 和 MSDN 的 <a href="https://msdn.microsoft.com/en-us/library/cc953fe1.aspx" rel="nofollow" title="Fundamental Types (C++)">Fundamental Types (C++)</a> &amp; <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz%28v=vs.140%29.aspx" rel="nofollow" title="Data Type Ranges">Data Type Ranges</a> &amp; <a href="https://msdn.microsoft.com/en-us/library/hh279663.aspx" rel="nofollow" title="C++ Type System (Modern C++)">C++ Type System (Modern C++)</a> 相关文档。</p> 
 <p></p> 
 <h3>C/C++ <a href="http://www.cplusplus.com/doc/oldtutorial/variables/" rel="nofollow" title="基本数据类型">基本数据类型</a></h3> 
 <div> 
  <table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p><strong><em>Type</em></strong></p> </td><td style="vertical-align:top;"> <p><strong><em>Size</em></strong></p> </td><td style="vertical-align:top;"> <p><strong><em>值域（limit）</em></strong></p> </td></tr><tr><td style="vertical-align:top;"> <p>无值型void</p> </td><td style="vertical-align:top;"> <p>0 byte</p> </td><td style="vertical-align:top;"> <p>无值域</p> </td></tr><tr><td style="vertical-align:top;"> <p>布尔型bool</p> </td><td style="vertical-align:top;"> <p>1 byte</p> </td><td style="vertical-align:top;"> <p>true/false</p> </td></tr><tr><td style="vertical-align:top;"> <p>有符号短整型 short [int] /signed short [int]</p> </td><td style="vertical-align:top;"> <p>2 byte（__SIZEOF_SHORT__）</p> </td><td style="vertical-align:top;"> <p>[SHRT_MIN,SHRT_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>无符号短整型 unsigned short [int]</p> </td><td style="vertical-align:top;"> <p>2 byte</p> </td><td style="vertical-align:top;"> <p>[0,USHRT_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>有符号整型 int /signed [int]</p> </td><td style="vertical-align:top;"> <p>4 byte（__SIZEOF_INT__）</p> </td><td style="vertical-align:top;"> <p>[INT_MIN,INT_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>无符号整型 unsigned [int]</p> </td><td style="vertical-align:top;"> <p>4 byte</p> </td><td style="vertical-align:top;"> <p>[0,UINT_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>有符号长整型 long [int]/signed long [int]</p> </td><td style="vertical-align:top;"> <p>4 byte/8 byte（__SIZEOF_LONG__）</p> </td><td style="vertical-align:top;"> <p>[LONG_MIN,LONG_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>无符号长整型 unsigned long [int]</p> </td><td style="vertical-align:top;"> <p>4 byte/8 byte</p> </td><td style="vertical-align:top;"> <p>[0,ULONG_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>long long</p> </td><td style="vertical-align:top;"> <p>8 byte（__SIZEOF_LONG_LONG__）</p> </td><td style="vertical-align:top;"> <p>[LLONG_MIN,LLONG_MAX]</p> <p>[0,ULLONG_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>有符号字符型 char/signed char</p> </td><td style="vertical-align:top;"> <p>1 byte</p> </td><td style="vertical-align:top;"> <p>[SCHAR_MIN, SCHAR_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>无符号字符型 unsigned char</p> </td><td style="vertical-align:top;"> <p>1 byte</p> </td><td style="vertical-align:top;"> <p>[0, UCHAR_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>宽字符型 wchar_t（__WCHAR_TYPE__）</p> </td><td style="vertical-align:top;"> <p>2 byte/4 byte（__WCHAR_WIDTH__）</p> </td><td style="vertical-align:top;"> <p>[WCHAR_MIN,WCHAR_MAX]</p> </td></tr><tr><td style="vertical-align:top;"> <p>单精度浮点型float</p> </td><td style="vertical-align:top;"> <p>4 byte（__SIZEOF_FLOAT__）</p> </td><td style="vertical-align:top;"> <p>-3.4E-38~3.4E+38</p> </td></tr><tr><td style="vertical-align:top;"> <p>双精度浮点型double</p> </td><td style="vertical-align:top;"> <p>8 byte（__SIZEOF_DOUBLE__）</p> </td><td style="vertical-align:top;"> <p>1.7E-308~1.7E+308</p> </td></tr><tr><td style="vertical-align:top;"> <p>long double</p> </td><td style="vertical-align:top;"> <p>8 byte（__SIZEOF_LONG_DOUBLE__）</p> </td><td style="vertical-align:top;"></td></tr></tbody></table> 
 </div> 
 <p></p> 
 <p><strong>说明</strong>：</p> 
 <p>（1）计算机存储的基本单位是1byte = 8bit，参考《<a href="http://blog.csdn.net/phunxm/article/details/5080981" title="字节串存储">字节串存储</a>》。</p> 
 <p>（2）其中 bool 和 wchar_t 是 C++ 特有的。</p> 
 <p>对于条件判断，零为假，非零为真，对bool变量可赋非0非1的其他真值。</p> 
 <p>wchar_t 是一种整形的 typedef，用于表示宽字节字符集编码单元：typedef 为 short 容纳 UTF-16 编码单元，或 typedef 为 int 容纳 Unicode 编码单元。</p> 
 <p>在 macOS/Xcode/Clang 工具链中的 <strong><em>i386</em></strong>，<strong><em>x86_64</em></strong>，<em><strong>armv7(s)</strong></em>，<em><strong>arm64 </strong></em>架构上，wchar_t 被定义为 int：</p> 
 <pre class="has"><code class="language-cpp">#define __WCHAR_TYPE__ int
#define __WCHAR_WIDTH__ 32</code></pre> （3）符号修饰符 signed 和 unsigned 用于修饰字符型和整形：默认为 signed 有符号，无符号需指定 unsigned。 
 <p></p> 
 <p>例如 char 和 wchar_t 没有显式指定符号前缀，默认为有符号型，可定义宏 __CHAR_UNSIGNED__ 和 __WCHAR_UNSIGNED__ 将其指定为无符号型。</p> 
 <p>Xcode 工程配置 PROJECT TARGET | Build Settings | Apple LLVM 9.0 - Language 下有项 <span style="background-color:#ffffcc;">'char' Type Is Unsigned: NO</span><span style="background-color:#ffffff;">，</span>也即 char 默认是带符号型（not unsigned）。如果要指定为无符号型，则可设置为YES，对应宏CHAR_UNSIGNED。</p> 
 <p>（4）长短修饰符 short 和 long 用于修饰整形：默认为 long 长整形，短整形需指定 short。</p> 
 <p>（5）当用 signed 和 unsigned、short 和 long 修饰 int 整形时，int 可省略。</p> 
 <p>（6）float 的精度（6位有效数字）通常是不够的，double 类型可以保证10位有效数字，能够满足大多数计算的需要。</p> 
 <p>    使用 double 类型基本不会出错，在 float 类型中存在隐式的精度损失。默认的浮点字面值常量为 double 类型，在数值后面加上 F 或 f 表示单精度，例如 3.14159F。</p> 
 <p>    浮点数 float、double 的存储设计，从本质上来说是设计了一个数值映射，充分利用了二进制存储的特点。参考IEEE754浮点数表示标准。</p> 
 <p>（7）void 的字面意思是“无类型”，不能用来定义变量。void 真正发挥的作用在于：</p> 
 <p>    &lt;1&gt;对函数返回和函数参数的限定，例如自定义既不带参数也无返回值的函数 void MyFunc(void);</p> 
 <p>    &lt;2&gt;定义无类型通用指针 void *，指向任何类型的数据。</p> 
 <p>（8）在Win32 API及MFC中为了使类型名称在语意上更明了，对以上基本类型进行了大量的 typedef。例如 WINDEF.H 中的 BYTE, WORD, DWORD。</p> 
 <p>（9）除上表以外，C/C++ 都可以自定义枚举 enum、联合 union 和 struct 结构体类型。</p> 
 <p>（10）标准C++库及STL还提供了通用数据结构：字符串类string；向量类模板vector；双端队列类模板deque；链表类模板list；容器适配器堆栈类stack（实现先进后出的操作）；容器适配器队列类queue（实现先进先出的操作）；集合类set；多重集合类multiset；映射类map；多重映射类multimap；位集合bitset；迭代器iterator (类似指针的功能,对容器的内容进行访问)。</p> 
 <p></p> 
 <h3 style="background-color:transparent;">CHAR_BIT / WORD_BIT / LONG_BIT</h3> 
 <p>XcodeDefault.xctoolchain 的 usr/lib/clang/9.0.0/include/limits.h 中定义了 CHAR_BIT：</p> 
 <pre class="has"><code class="language-cpp">#define CHAR_BIT  __CHAR_BIT__</code></pre> 
 <p><strong><em>CHAR_BIT</em></strong> 表示 char 类型的位宽（number of bits in a<em>char</em>），POSIX.1-2001 规范该值为 8。</p> 
 <p></p> 
 <p>sizeof 运算符可测量指定类型变量的<strong>字宽</strong>（以byte为单位的字节宽度），返回 size_t 类型；字宽乘以8 (CHAR_BIT) 得到<strong>位宽</strong>（以bit为单位的二进制位串宽度）。</p> 
 <p>—— <span style="background-color:#ffffcc;">BIT_WIDTH = sizeof(type)*CHAR_BIT</span></p> 
 <p>参考 gcc <a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html" rel="nofollow" title="Common Predefined Macros">Common Predefined Macros</a> 中 SIZEOF 和 WIDTH 宏（例如 <span style="color:#990000;"><strong>__SIZEOF_</strong></span>POINTER__，__POINTER<span style="color:#990000;"><strong>_WIDTH__</strong></span> ）。</p>   
 <p>Xcode 中 MacOSX.sdk 下的 usr/include/i386/limits.h 中定义了 WORD_BIT 和 LONG_BIT：</p> 
 <pre class="has"><code class="language-cpp">#if !defined(_ANSI_SOURCE)
#ifdef __LP64__
#define LONG_BIT	64
#else /* !__LP64__ */
#define LONG_BIT	32
#endif /* __LP64__ */
#define	SSIZE_MAX	LONG_MAX	/* max value for a ssize_t */
#define WORD_BIT	32</code></pre> 
 <p>WORD_BIT 的值为 32，对应 int 类型的位宽（__SIZEOF_INT__*CHAR_BIT）。LONG_BIT 的值则随机器 CPU 字长。</p> 
 <p><strong>_ILP32/__ILP32__，_LP64/__LP64__</strong></p> 
 <p>GCC从 3.4 开始为所有的 LP64 平台定义了 `<a href="https://stackoverflow.com/questions/6721037/where-is-lp64-defined-for-default-builds-of-c-applications-on-osx-10-6" rel="nofollow" title="_LP64">_LP64</a>` 和 `<a class="cf_div_theme_dark" href="https://stackoverflow.com/questions/20462091/what-definitions-exist-like-lp64-and-arm64-in-cocoa-that-differentiate-p" rel="nofollow" title="__LP64__">__LP64__</a>` 这两个宏，表示编译目标的 long int 和指针使用的是 64 位而 int 使用的是 32 位。</p> 
 <p>&gt; These macros are defined, with value 1, if (and only if) the compilation is for a target where <code>long int</code> and pointer both use 64-bits and <code>int</code> uses 32-bit.</p> 
 <p>在 macOS 下可用 clang/gcc 的 -E 预处理命令，结合 -dM 选项打印编译器在 <a href="http://www.cocoachina.com/ios/20140915/9620.html" rel="nofollow" title="各个 arch 指令集">各个 arch 指令集</a>下的<a href="http://www.cnblogs.com/goodloop/p/3863157.html" rel="nofollow" title="默认宏定义">默认宏定义</a>（predefined macros）：</p> 
 <pre class="has"><code class="language-cpp"># -x c 指定 C 语言
# /dev/null 表示空文件，无实质预处理，仅打印预定义宏
$ clang -dM -E -arch $arch -x c /dev/null</code></pre> 其中  
 <span style="color:#000099;">$arch</span> 可取 32 位的 
 <em><strong>i386</strong></em>, 64 位的 
 <strong><em>x86_64</em></strong>（amd64）；32 位的  
 <a href="http://www.cnblogs.com/cywin888/p/3229505.html" rel="nofollow" title="armv7(s)">armv7(s)</a>，64 位的  
 <a href="http://www.jianshu.com/p/3fce0bd6f045" rel="nofollow" title="arm64">arm64</a>。 
 <p>针对 32 位 CPU 定义了 <span style="color:#6600cc;"> _ILP32</span> 和<span style="color:#6600cc;">__ILP32__</span> 的值为1；针对 64位 CPU 定义了<span style="color:#6600cc;">_LP64</span> 和<span style="color:#6600cc;">__LP64__</span> 的值为1。</p> 
 <p><a href="https://unix.stackexchange.com/questions/74648/default-wordsize-in-unix-linux" rel="nofollow" title="__WORDSIZE">__WORDSIZE</a></p> 
 <p>Xcode 的 MacOSX.sdk 和 iPhoneOS.sdk 的 usr/include/stdint.h 进一步根据 __LP64__==1 定义了机器字长：</p> 
 <pre class="has"><code class="language-cpp">#if __LP64__
#define __WORDSIZE 64
#else
#define __WORDSIZE 32
#endif</code></pre> 
 <p><strong><em>LONG_BIT</em></strong> （<span style="background-color:#ffffcc;"><span style="color:#000099;">= </span></span><span style="background-color:#ffffcc;"><span style="color:#000099;">__SIZEOF_LONG__ * CHAR_BIT</span></span>）的值等于机器字长（__WORDSIZE），为 CPU GPRs（General-Purpose Registers，通用寄存器）的数据宽度：在32位CPU下为32，在64位CPU下为64。</p> 
 <h3><a href="http://www.gnu.org/software/libc/manual/html_node/Integers.html#Integers" rel="nofollow" title="Integers">Integers</a></h3> 
 <p>char、short、int、long、long long 统称为<strong>整形</strong>。</p> 
 <p>某些类型数据的字宽（位宽）和数值范围由操作系统和编译平台决定，参考 <a href="http://www.gnu.org/software/libc/manual/html_node/Width-of-Type.html" rel="nofollow" title="Computing the Width of an Integer Data Type">Computing the Width of an Integer Data Type</a>。</p> 
 <ul><li>char 为字节基元（1 byte），short 字宽 2 byte。</li><li>在古老的 16 位机上，sizeof(int) = 2，sizeof(long) = 4。</li><li>在主流 32 位/64 位机器上，int 字宽 4 byte（__SIZEOF_INT__），long long 字宽 8 byte（__SIZEOF_LONG_LONG__）。</li><li>32 位机上 sizeof(<strong>long</strong>) =<em><span style="color:#333399;">__SIZEOF_LONG__</span></em> = 4；而 64 位机上 sizeof(long) = <em><span style="color:#333399;">__SIZEOF_LONG__</span></em> = 8。</li></ul> 
 <p>clang 编译器预定义宏 __SIZE_OF_<span style="background-color:#ccffff;">type</span> 指定了对应CPU架构下的类型字宽：</p> 
 <pre class="has"><code class="language-html">#define __SIZEOF_SHORT__ 2
#define __SIZEOF_INT__ 4</code></pre> 
 <p>32位上 long (int) 是相对 short (int) 而言，字宽等于 int 为 4：</p> 
 <pre class="has"><code class="language-cpp">#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8</code></pre> 
 <p>64位上的 long long 字宽和 long 一样都为 8：</p> 
 <pre class="has"><code class="language-cpp">#define __SIZEOF_LONG__ 8
#define __SIZEOF_LONG_LONG__ 8</code></pre> 
 <p>XcodeDefault.xctoolchain 的 usr/lib/clang/9.0.0/include/limits.h 中对 clang 编译器预定义宏 MIN/MAX 进行了二次 define：</p> 
 <pre class="has"><code class="language-cpp">#define LONG_MAX  __LONG_MAX__
#define LONG_MIN  (-__LONG_MAX__ -1L)

#define ULONG_MAX (__LONG_MAX__ *2UL+1UL)


#if __STDC_VERSION__ &gt;= 199901L || __cplusplus &gt;= 201103L

#undef  LLONG_MIN
#undef  LLONG_MAX
#undef  ULLONG_MAX

#define LLONG_MAX  __LONG_LONG_MAX__
#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif
</code></pre> 
 <p>Xcode 中 MacOSX.sdk 下的 usr/include/i386/<a href="http://www.cplusplus.com/reference/climits/" rel="nofollow" title="limits.h">limits.h</a> 中定义了 32 位和 64 位机器上的 (U)LONG、(U)LLONG 的值域（MIN,MAX）。</p> 
 <pre class="has"><code class="language-cpp">#ifdef __LP64__
#define	ULONG_MAX	0xffffffffffffffffUL	/* max unsigned long */
#define	LONG_MAX	0x7fffffffffffffffL	/* max signed long */
#define	LONG_MIN	(-0x7fffffffffffffffL-1) /* min signed long */
#else /* !__LP64__ */
#define	ULONG_MAX	0xffffffffUL	/* max unsigned long */
#define	LONG_MAX	2147483647L	/* max signed long */
#define	LONG_MIN	(-2147483647L-1) /* min signed long */
#endif /* __LP64__ */

#define	ULLONG_MAX	0xffffffffffffffffULL	/* max unsigned long long */
#define	LLONG_MAX	0x7fffffffffffffffLL	/* max signed long long */
#define	LLONG_MIN	(-0x7fffffffffffffffLL-1) /* min signed long long */</code></pre> 
 <p>关于数据类型的位宽及值域可参考 MSDN 的 <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz%28v=vs.140%29.aspx" rel="nofollow" title="Data Type Ranges">Data Type Ranges</a> 和 GNU 的 <a href="http://www.gnu.org/software/libc/manual/html_node/Data-Type-Measurements.html" rel="nofollow" title="Data Type Measurements">Data Type Measurements</a> &amp; <a href="https://gcc.gnu.org/onlinedocs/gccint/Type-Layout.html" rel="nofollow" title="Layout of Source Language Data Types">Layout of Source Language Data Types</a>。</p> 
 <p><strong>参考</strong>：</p> 
 <p>《<a href="https://stackoverflow.com/questions/12279060/what-is-the-difference-between-short-int-and-int-in-c" rel="nofollow" title="difference between “short int” and “int”">difference between “short int” and “int”</a>》《<a href="http://blog.sina.com.cn/s/blog_693ac9f60100q613.html" rel="nofollow" title="short int，int，long int 所占字节">short int，int，long int 所占字节</a>》</p> 
 <p>《<a href="http://www.cocoachina.com/ios/20150210/11130.html" rel="nofollow" title="CGfloat和float的区别?">CGfloat和float的区别?</a>》《<a href="http://www.cnblogs.com/zenny-chen/p/3676080.html" rel="nofollow" title="OS X以及iOS中与硬件环境相关的预定义宏">OS X以及iOS中与硬件环境相关的预定义宏</a>》</p> 
 <div> 
  <h3>__SIZEOF_POINTER__/__POINTER_WIDTH</h3> 
 </div> 
 <p>clang 编译器预定义宏 __SIZEOF_POINTER__ 和 __POINTER_WIDTH 指定了相应 CPU 架构下指针的字宽和位宽。</p> 
 <p>32位机上的指针宽度为4byte：</p> 
 <pre class="has"><code class="language-cpp">#define __SIZEOF_POINTER__ 4
#define __POINTER_WIDTH__ 32</code></pre> 64位机上的指针宽度为 8 byte： 
 <pre class="has"><code class="language-cpp">#define __SIZEOF_POINTER__ 8
#define __POINTER_WIDTH__ 64</code></pre> 
 <div> 
  <h3>uintptr_t &amp; ptrdiff_t</h3> 
 </div> 
 <p>C++11 在 &lt;cstdint&gt; 中提炼了容纳指针宽度的整形变量类型 intptr_t 和 <a href="https://stackoverflow.com/questions/1845482/what-is-uintptr-t-data-type" rel="nofollow" title="uintptr_t">uintptr_t</a> 方便指针变量之间的计算。</p> 
 <p></p> 
 <p>&gt; Integer type capable of holding a value converted from a void pointer.</p> 
 <p></p> 
 <p>(u)intptr_t 是一种 typedef alias 类型，对应 clang 编译器预定义宏 __(U)INTPTR_TYPE__。</p> 
 <p>32位机上的 (u)intptr_t 的字宽为4byte（__SIZEOF_LONG__）：</p> 
 <pre class="has"><code class="language-html">#define __INTPTR_TYPE__ long int
#define __INTPTR_WIDTH__ 32

#define __UINTPTR_TYPE__ long unsigned int
#define __UINTPTR_WIDTH__ 32</code></pre> 
 <p>64位机上的 (u)intptr_t 的字宽为8byte（__SIZEOF_LONG__）：</p> 
 <pre class="has"><code class="language-cpp">#define __INTPTR_TYPE__ long int
#define __INTPTR_WIDTH__ 64

#define __UINTPTR_TYPE__ long unsigned int
#define __UINTPTR_WIDTH__ 64</code></pre> 
 <p>Xcode 的 MacOSX.sdk 和 iPhoneOS.sdk 的 usr/include/sys/_types/_intptr_t.h 中 typedef 了 <strong>intptr_t</strong>：</p> 
 <pre class="has"><code class="language-cpp">#ifndef _INTPTR_T
#define _INTPTR_T
#include &lt;machine/types.h&gt; /* __darwin_intptr_t */

typedef __darwin_intptr_t	intptr_t;
#endif /* _INTPTR_T */</code></pre> 
 <p>在 MacOSX.sdk 的 usr/include/i386/_types.h 和 iPhoneOS.sdk 的 usr/include/arm/_types.h 中，__darwin_intptr_t 均被 typedef 为 long：</p> 
 <pre class="has"><code class="language-cpp">typedef long			__darwin_intptr_t;</code></pre> MacOSX.sdk 和 iPhoneOS.sdk 的 usr/include/sys/_types/_uintptr_t.h 中  
 <strong>uintptr_t</strong> 均被 typedef 为 unsigned long： 
 <pre class="has"><code class="language-cpp">#ifndef _UINTPTR_T
#define _UINTPTR_T
typedef unsigned long		uintptr_t;
#endif /* _UINTPTR_T */</code></pre> 
 <p><strong><span style="color:#000099;">小结</span></strong>：</p> 
 <p>机器的指针位数和机器字长相等：</p> 
 <ul><li>sizeof(__INTPTR_TYPE__) = sizeof(__UINTPTR_TYPE__) = __SIZEOF_POINTER__ = __SIZEOF_LONG__</li><li>__INTPTR_WIDTH__ = __UINTPTR_WIDTH__ = __POINTER_WIDTH__ = LONG_BIT = __WORDSIZE</li></ul> 
 <p>ptrdiff_t 在 XcodeDefault.xctoolchain 的 usr/lib/clang/9.0.0/include/stddef.h 中被 typedef 为 clang 预定义编译宏 __PTRDIFF_TYPE__：</p> 
 <pre class="has"><code class="language-cpp">typedef __PTRDIFF_TYPE__ ptrdiff_t;</code></pre> 
 <p>__PTRDIFF_TYPE__ 为 clang 编译器预定义宏，也是一种 typedef alias 类型。</p> 
 <p>32位机上的 ptrdiff_t 的字宽为4byte（__SIZEOF_LONG__）：</p> 
 <pre class="has"><code class="language-cpp">#define __PTRDIFF_TYPE__ int
#define __PTRDIFF_WIDTH__ 32
#define __SIZEOF_PTRDIFF_T__ 4</code></pre> 64位机上的 ptrdiff_t 的字宽为8byte（__SIZEOF_LONG__）： 
 <pre class="has"><code class="language-cpp">#define __PTRDIFF_TYPE__ long int
#define __PTRDIFF_WIDTH__ 64
#define __SIZEOF_PTRDIFF_T__ 8</code></pre> 
 <p>Xcode 中 MacOSX.sdk 和 iPhoneOS.sdk 的 include/sys/_types/_ptrdiff_t.h 定义了 ptrdiff_t</p> 
 <pre class="has"><code class="language-cpp">#ifndef _PTRDIFF_T
#define _PTRDIFF_T
#include &lt;machine/types.h&gt; /* __darwin_ptrdiff_t */
typedef __darwin_ptrdiff_t ptrdiff_t;
#endif /* _PTRDIFF_T */</code></pre> MacOSX.sdk/usr/include/i386/_types.h 和 iPhoneOS.sdk/usr/include/arm/_types.h 中定义了 __darwin_ptrdiff_t： 
 <pre class="has"><code class="language-html">#if defined(__PTRDIFF_TYPE__)
typedef __PTRDIFF_TYPE__    __darwin_ptrdiff_t; /* ptr1 - ptr2 */
#elif defined(__LP64__)
typedef long            __darwin_ptrdiff_t; /* ptr1 - ptr2 */
#else
typedef int         __darwin_ptrdiff_t; /* ptr1 - ptr2 */
#endif /* __GNUC__ */
</code></pre> 
 <p>&lt;cstddef&gt; 中定义的 <strong><a href="http://www.cplusplus.com/reference/cstddef/ptrdiff_t/" rel="nofollow" title="ptrdiff_t">ptrdiff_t</a></strong> 类型用于存储两个地址（uintptr_t）之间相差的偏移量（Result of pointer subtraction）。</p> 
 <p></p> 
 <p>C++ STL 容器迭代器偏移计算结果 difference_type 通常就是 ptrdiff_t（often synonymous with <code>std::<a href="http://en.cppreference.com/w/cpp/types/ptrdiff_t" rel="nofollow" title="ptrdiff_t">ptrdiff_t</a></code>），参考《<a href="http://www.gnu.org/software/libc/manual/html_node/Important-Data-Types.html#Important-Data-Types" rel="nofollow" title="Import Data Types">Import Data Types</a>》。</p> 
 <p>以下为 std::<a href="http://www.cplusplus.com/reference/vector/vector/" rel="nofollow" title="vector">vector</a> 的 Member Types 表格：</p> 
 <table align="center" border="1" cellpadding="1" cellspacing="1" style="width:0px;"><tbody><tr><th>member type</th><th>definition</th><th>notes</th></tr></tbody><tbody><tr><td><strong><span style="background-color:#ffffcc;">difference_type</span></strong></td><td>a signed integral type, identical to: iterator_traits&lt;iterator&gt;::<em>difference_type</em></td><td>usually the same as <a href="http://www.cplusplus.com/ptrdiff_t" rel="nofollow" title="ptrdiff_t">ptrdiff_t</a></td></tr><tr><td>size_type</td><td>an unsigned integral type that can represent any non-negative value of <em>difference_type</em></td><td>usually the same as <a href="http://www.cplusplus.com/size_t" rel="nofollow" title="size_t">size_t</a></td></tr></tbody></table> 
 <p></p> 
 <p>参考：</p> 
 <p>《<a href="https://gxnotes.com/article/68837.html" rel="nofollow" title="uintptr_t 类型">uintptr_t 类型</a>》、《<a href="http://blog.csdn.net/cs_zhanyb/article/details/16973379" title="intptr_t、uintptr_t数据类型解析">intptr_t、uintptr_t数据类型解析</a>》和《<a href="http://book.2cto.com/201402/40245.html" rel="nofollow" title="使用intptr_t和uintptr_t">使用intptr_t和uintptr_t</a>》。</p> 
 <h3><a href="http://www.cplusplus.com/reference/cstddef/size_t/" rel="nofollow" title="size">size</a><a href="http://www.cplusplus.com/reference/cstddef/size_t/" rel="nofollow" title="_t">_t</a></h3> 
 <p>size_t 类型也是在 &lt;cstddef&gt; 中定义的。</p> 
 <p>It is a type able to represent the size of <strong><em>any</em></strong> object in bytes: `size_t` is the type returned by the `<a href="https://www.zhihu.com/question/26090484" rel="nofollow" title="sizeof">sizeof</a>` operator.</p> 
 <ol><li>std::size_t can <em> <u>store</u></em> the maximum size of a theoretically possible object of any type (including array).  </li><li>std::size_t is commonly used for array <em><u>indexing</u></em> and loop counting.</li></ol> 
 <p>C++ STL 容器一般都提供了 size 接口，返回存储元素的个数：</p> 
 <pre class="has"><code class="language-cpp">// Returns the number of elements in the container.
size_type size() const;</code></pre> 
 <p>顺序容器 array、vector 和 deque 还重载了 operator[] 运算符，支持像数组那样基于索引访问元素（引用）：</p> 
 <pre class="has"><code class="language-cpp">// Returns a reference to the element at position n in the container.
const_reference operator[] (size_type n) const;</code></pre> 
 <p>以下为 std::<a href="http://www.cplusplus.com/reference/vector/vector/" rel="nofollow" title="vector">vector</a> 的 Member Types 表格：</p> 
 <table align="center" border="1" cellpadding="1" cellspacing="1" style="width:0px;"><tbody><tr><th>member type</th><th>definition</th><th>notes</th></tr></tbody><tbody><tr><td>difference_type</td><td>a signed integral type, identical to: iterator_traits&lt;iterator&gt;::<em>difference_type</em></td><td>usually the same as <a href="http://www.cplusplus.com/ptrdiff_t" rel="nofollow" title=" ptrdiff_t"> ptrdiff_t</a></td></tr><tr><td><strong><span style="background-color:#ffffcc;">size_type</span></strong></td><td>an unsigned integral type that can represent any non-negative value of <em>difference_type</em></td><td>usually the same as <a href="http://www.cplusplus.com/size_t" rel="nofollow" title=" size_t"> size_t</a></td></tr></tbody></table> 其中 size_type 通常就是 size_t（usually defined as a synonym for  
 <strong>std::<a href="http://en.cppreference.com/w/cpp/types/size_t" rel="nofollow" title="size_t">size_t</a></strong>），参考《 
 <a href="http://www.gnu.org/software/libc/manual/html_node/Important-Data-Types.html#Important-Data-Types" rel="nofollow" title="Import Data Types">Import Data Types</a>》。 
 <p></p> 
 <p>C++ STL &lt;string&gt;的 size() 接口和 [] 操作符则直接使用 size_t 参数：</p> 
 <pre class="has"><code class="language-cpp">// Returns the length of the string, in terms of bytes.
size_t size() const;

// Returns a reference to the character at position pos in the string.
const char&amp; operator[] (size_t pos) const;</code></pre> 
 <p>&lt;cstddef&gt; 中定义的宏 <a href="http://en.cppreference.com/w/cpp/types/offsetof" rel="nofollow" title=" offsetof"> offsetof</a> (type,member) 返回成员变量在类型中的地址偏移量（return member offset），返回值通常是 size_t（ptrdiff_t？）。</p> 
 <p></p> 
 <p>size_t 在 XcodeDefault.xctoolchain 的 usr/lib/clang/9.0.0/include/stddef.h 中被 typedef 为 clang 预编译定义宏__SIZE_TYPE__：</p> 
 <pre class="has"><code class="language-cpp">typedef __SIZE_TYPE__ size_t;</code></pre> 
 <p>32位机上的 __SIZE_TYPE__ 为 long unsigned int 类型，字宽为4byte（__SIZEOF_LONG__）：</p> 
 <pre class="has"><code class="language-cpp">#define __SIZE_TYPE__ long unsigned int
#define __SIZE_WIDTH__ 32
#define __SIZEOF_SIZE_T__ 4
</code></pre> 64位机上的 __SIZE_TYPE__ 为 long unsigned int 类型，字宽为8byte（__SIZEOF_LONG__）： 
 <pre class="has"><code class="language-cpp">#define __SIZE_TYPE__ long unsigned int
#define __SIZE_WIDTH__ 64
#define __SIZEOF_SIZE_T__ 8</code></pre> 
 <p>一般来说，size_t 可能的最大值是 SIZE_MAX。</p> 
 <p></p> 
 <p>Xcode 中 MacOSX.sdk 和 iPhoneOS.sdk 的 usr/include/sys/_types/_size_t.h 定义了 size_t：</p> 
 <pre class="has"><code class="language-cpp">#ifndef _SIZE_T 
#define _SIZE_T 
#include &lt;machine/_types.h&gt; /* __darwin_size_t */
typedef __darwin_size_t        size_t; 
#endif  /* _SIZE_T */</code></pre> MacOSX.sdk/usr/include/i386/_types.h 和 iPhoneOS.sdk/usr/include/arm/_types.h 中定义了 __darwin_size_t： 
 <pre class="has"><code class="language-cpp">#if defined(__SIZE_TYPE__)
typedef __SIZE_TYPE__       __darwin_size_t;    /* sizeof() */
#else
typedef unsigned long       __darwin_size_t;    /* sizeof() */
#endif</code></pre> 
 <p>size_t 的取值与机器相关，某些情况下正确的使用 size_t 可以提高程序的可移植性和有效性。  </p> 
 <p></p> 
 <p>参考：</p> 
 <p>《<a href="https://gxnotes.com/article/68837.html" rel="nofollow" title="uintptr_t 类型">uintptr_t 类型</a>》、《<a href="http://blog.csdn.net/menzi11/article/details/9322251" title="关于 size_t , uintptr_t , intptr_t, int">关于 size_t , uintptr_t , intptr_t, int</a>》、《<a href="http://blog.csdn.net/jerryjbiao/article/details/6705331" title="size_type、size_t、different_type以及ptrdiff_t">size_type、size_t、different_type以及ptrdiff_t</a>》</p> 
 <p><a href="http://blog.csdn.net/k346k346/article/details/47998283" title="认识size_t">认识size_t</a> 和 <a href="http://jeremybai.github.io/blog/2014/09/10/size-t" rel="nofollow" title="为什么size_t重要？（Why size_t matters）">为什么size_t重要？（Why size_t matters）</a>。</p>   
 <p>size_t 的声明是实现相关的，它还出现在其他多个标准头文件中：&lt;cstdio&gt; &lt;cstdlib&gt; &lt;cstring&gt; &lt;ctime&gt; &lt;cwchar&gt;。</p> 
 <p>1. &lt;<strong>cstdio</strong>&gt; 中的以下函数接口参数用到了 size_t：</p> 
 <pre class="has"><code class="language-cpp">size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
// since C++11
int snprintf ( char * s, size_t n, const char * format, ... );</code></pre> 
 <p>2. &lt;<strong>cstdlib</strong>&gt; 中的以下函数接口参数用到了 size_t：</p> 
 <pre class="has"><code class="language-cpp">void* calloc (size_t num, size_t size);
void* malloc (size_t size);
void* realloc (void* ptr, size_t size);</code></pre> 
 <p>3. &lt;<strong>cstring</strong>&gt; 中的以下函数接口参数用到了 size_t：</p> 
 <pre class="has"><code class="language-cpp">const void * memchr ( const void * ptr, int value, size_t num );
int memcmp ( const void * ptr1, const void * ptr2, size_t num );
void * memcpy ( void * destination, const void * source, size_t num );
void * memmove ( void * destination, const void * source, size_t num );
void * memset ( void * ptr, int value, size_t num );
size_t strlen ( const char * str );
char * strncat ( char * destination, const char * source, size_t num );
int strncmp ( const char * str1, const char * str2, size_t num );
char * strncpy ( char * destination, const char * source, size_t num );</code></pre> 
 <h3 style="background-color:transparent;">stdint</h3> 
 <p>long从字面上看，应该是64位才更合理，把long当成32位实在是一个历史的包袱。像C#那样新起炉灶的程序语言，由于没有需要支持老代码的问题，就把long当作64位来处理了。</p> 
 <p>int 所占字宽（WORD_BIT）始终为 32 bits，当要求的数值范围为4byte时，建议使用int类型，因为第一版的C语言只有一种内置类型，那就是int。</p> 
 <p>在32位平台下，long是相对short而言，long（short）类型是long（short） int类型的简称，sizeof(int) = sizeof(long int) = 4。</p> 
 <p>在32位机器上，vc中<span style="color:#6c6fc6;">__int64</span> 以及 mac 中的<em><strong>struct</strong></em> <span style="color:#6c6fc6;">wide/UnsignedWide</span>为等价实现的64位长整形。</p> 
 <pre class="has"><code class="language-cpp">// MacTypes.h
#if TYPE_LONGLONG
    #if defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__) &amp;&amp; defined(_M_IX86)
        typedef signed __int64                SInt64;
        typedef unsigned __int64              UInt64;
    #else
        typedef signed long long              SInt64;
        typedef unsigned long long            UInt64;
    #endif
#else
    typedef wide                            SInt64;
    typedef UnsignedWide                    UInt64;
#endif  /* TYPE_LONGLONG */</code></pre> 
 <p>关于 _M_IX86 参考《<a href="http://blog.csdn.net/liangbch/article/details/36020391" title="编译器中和64位编程有关的预定义宏">编译器中和64位编程有关的预定义宏</a>》。</p> 
 <p></p> 
 <p>MSDN 的 <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz%28v=vs.140%29.aspx" rel="nofollow" title="Data Type Ranges">Data Type Ranges</a>：<br> &gt; C/C++ in Visual Studio also supports sized integer types. For more information, see<a href="https://msdn.microsoft.com/en-us/library/29dh1w7z.aspx" rel="nofollow" title="__int8, __int16, __int32, __int64">__int8, __int16, __int32, __int64</a> and<a href="https://msdn.microsoft.com/en-us/library/296az74e.aspx" rel="nofollow" title="Integer Limits">Integer Limits</a>. <br>  </p> 
 <p><a href="https://msdn.microsoft.com/en-us/library/cc230273.aspx" rel="nofollow" title="MS-DTYP">MS-DTYP</a><a href="https://msdn.microsoft.com/en-us/library/cc230339.aspx" rel="nofollow" title="Integer Types">Integer Types</a>：<br> &gt; Microsoft C/C++ supports different sizes of integer types. An 8-bit, 16-bit, 32-bit, or 64-bit integer variable can be declared by using the __int<span style="background-color:#ffff99;">n</span> type specifier, where n is 8, 16, 32, or 64.<br> The types __int8, __int16, and __int32 are synonyms for the ANSI/ISO C types (as specified in [ISO/IEC-9899]) that have the same size. They are useful for writing<strong>portable</strong> code that behaves identically<em>across multiple platforms</em>.</p> 
 <p></p> 
 <p>int和long的范围虽然一样,但输入输出格式不同，printf int 的格式为<span style="background-color:#ffffcc;">%d</span>，而 printf long (int) 的格式为<span style="background-color:#ffffcc;">%ld</span>，print long long (int) 的格式则为<span style="background-color:#ffffcc;">%lld</span>。</p> 
 <p>考虑到程序的可移植性，还是要将它们区分开来。C99 标准中 &lt;<a href="http://www.cnblogs.com/baochun968/archive/2011/10/19/2218008.html" rel="nofollow" title="inttypes.h">inttypes.h</a>&gt; 以及 C++11 的 &lt;<span style="color:#ff6600;"><a href="http://www.cplusplus.com/reference/cstdint/" rel="nofollow" title="stdint.h">stdint.h</a></span>&gt; 中定义了适配各平台<a href="http://en.cppreference.com/w/c/types/integer" rel="nofollow" title="指定位宽的整形类型">指定位宽的整形类型</a>：</p> 
 <ul><li>int8_t/uint8_t;</li><li>int16_t/uint16_t;</li><li>int32_t/uint32_t;</li><li>int64_t/uint64_t;</li><li>intptr_t/uintptr_t;</li></ul> 
 <p>字面值整数常量的类型默认为int或long，其精度类型取决于精度值，其值适合int型就是int型，比int型（INT_MAX）大的就是long类型。通过增加后缀可强制将字面值整数常量转换成long、unsigned或unsigned long类型。通过在数值后面添加L或l（推荐使用L，防l与1混淆）指定常量为long类型。例如128u，1L，1024UL，8Lu。没有short类型的字面值常量。</p> 
 <h3>demo</h3> 
 <p>以下代码片段打印机器字宽（SIZE）、位宽（WIDTH，*_BIT）以及取值范围（MIN,MAX）。</p> 
 <p></p> 
 <pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdint&gt;  // C++11
#include &lt;climits&gt;

#if __WORDSIZE==32
#pragma message("__WORDSIZE==32")
#elif __WORDSIZE==64
#pragma message("__WORDSIZE==64")
#endif

// 获取指针宽度（机器字宽）
int GetWordSize()
{
    return sizeof(uintptr_t)*CHAR_BIT;
}

int main(int argc, const char * argv[])
{
    std::cout &lt;&lt; "WordSize = " &lt;&lt; GetWordSize() &lt;&lt; std::endl;   // 64
    std::cout &lt;&lt; "__WORDSIZE = " &lt;&lt; __WORDSIZE &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== LONG_BIT ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "CHAR_BIT = " &lt;&lt; CHAR_BIT &lt;&lt; std::endl;        // 8
    std::cout &lt;&lt; "WORD_BIT = " &lt;&lt; WORD_BIT &lt;&lt; std::endl;        // 32
    std::cout &lt;&lt; "LONG_BIT = " &lt;&lt; LONG_BIT &lt;&lt; std::endl;        // 32 for 32 bit; 64 for 64 bit
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== __SIZEOF_INT__ ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_SHORT__ = " &lt;&lt; __SIZEOF_SHORT__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_INT__ = " &lt;&lt; __SIZEOF_INT__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_LONG__ = " &lt;&lt; __SIZEOF_LONG__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_LONG_LONG__ = " &lt;&lt; __SIZEOF_LONG_LONG__ &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== __SIZE_TYPE__ ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "sizeof(size_t) = " &lt;&lt; sizeof(size_t) &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_SIZE_T__ = " &lt;&lt; __SIZEOF_SIZE_T__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZE_WIDTH__ = " &lt;&lt; __SIZE_WIDTH__ &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== POINTER, UINTPTR, PTRDIFF ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_POINTER__ = " &lt;&lt; __SIZEOF_POINTER__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__POINTER_WIDTH__ = " &lt;&lt; __POINTER_WIDTH__ &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "sizeof(uintptr_t) = " &lt;&lt; sizeof(uintptr_t) &lt;&lt; std::endl;
    std::cout &lt;&lt; "__INTPTR_WIDTH__ = " &lt;&lt; __INTPTR_WIDTH__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__UINTPTR_WIDTH__ = " &lt;&lt; __UINTPTR_WIDTH__ &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "sizeof(ptrdiff_t) = " &lt;&lt; sizeof(ptrdiff_t) &lt;&lt; std::endl;
    std::cout &lt;&lt; "__SIZEOF_PTRDIFF_T__ = " &lt;&lt; __SIZEOF_PTRDIFF_T__ &lt;&lt; std::endl;
    std::cout &lt;&lt; "__PTRDIFF_WIDTH__ = " &lt;&lt; __PTRDIFF_WIDTH__ &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== __WCHAR_TYPE__ ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "sizeof(wchar_t) = " &lt;&lt; sizeof(wchar_t) &lt;&lt; std::endl;
    std::cout &lt;&lt; "__WCHAR_WIDTH__ = " &lt;&lt; __WCHAR_WIDTH__ &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "========== *_MAX ==========" &lt;&lt; std::endl;
    // 1byte
    std::cout &lt;&lt; "SCHAR range = [" &lt;&lt; SCHAR_MIN &lt;&lt; "," &lt;&lt; SCHAR_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; "UCHAR range = [" &lt;&lt; "0" &lt;&lt; "," &lt;&lt; UCHAR_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    // 2byte
    std::cout &lt;&lt; "SHRT range = [" &lt;&lt; SHRT_MIN &lt;&lt; "," &lt;&lt; SHRT_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; "USHRT range = [" &lt;&lt; "0" &lt;&lt; "," &lt;&lt; USHRT_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    // 4byte
    std::cout &lt;&lt; "INT range = [" &lt;&lt; INT_MIN &lt;&lt; "," &lt;&lt; INT_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; "UINT range = [" &lt;&lt; "0" &lt;&lt; "," &lt;&lt; UINT_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    // 4byte for 32bit; 8byte for 64bit
    std::cout &lt;&lt; "LONG range = [" &lt;&lt; LONG_MIN &lt;&lt; "," &lt;&lt; LONG_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; "ULONG range = [" &lt;&lt; "0" &lt;&lt; "," &lt;&lt; ULONG_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    // 8byte
    std::cout &lt;&lt; "LLONG range = [" &lt;&lt; LLONG_MIN &lt;&lt; "," &lt;&lt; LLONG_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; "ULLONG range = [" &lt;&lt; "0" &lt;&lt; "," &lt;&lt; ULLONG_MAX &lt;&lt; "]" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    return EXIT_SUCCESS;
}</code></pre> 
</blockquote> 
<p>参考：</p> 
<blockquote> 
 <p>《程序设计与C语言》 梁力<br> 《白话C++》 南郁<br> 《Visual C++面向对象编程教程》 王育坚<br> 《C++ Primer》Stanley B. Lippman<br> 《程序员的自我修养》<br><br> 《<a href="http://blog.sina.com.cn/s/blog_4f04c2510100d34h.html" rel="nofollow" title="操作系统位数">操作系统位数</a>》《<a href="http://www.cnblogs.com/nicholas_f/archive/2009/06/01/1494028.html" rel="nofollow" title="查看操作系统位数">查看操作系统位数</a>》<br> 《<a href="http://www.linux-cn.com/html/linux/other/20070509/32479.html" rel="nofollow" title="32位还是64位">32位还是64位</a>》《<a href="http://www.linuxforum.net/forum/printthread.php?Cat=&amp;Board=linuxK&amp;main=662629&amp;type=thread" rel="nofollow" title="kernel里的long和int">kernel里的long和int</a>》<br> 《<a href="http://blog.csdn.net/shermy/archive/2006/10/14/1334496.aspx" title="浮点数存储格式">浮点数存储格式</a>》《<a href="http://wxdlut.blog.163.com/blog/static/1287701582009101182046692/" rel="nofollow" title="浮点数在内存中的存储格式">浮点数在内存中的存储格式</a>》<br> 《<a href="http://blog.csdn.net/phunxm/archive/2009/12/26/5082596.aspx" title="Windows/MFC数据类型">Windows/MFC数据类型</a>》<br> 《<a href="http://www.microsoft.com/china/MSDN/library/Windev/64bit/MW6TWPchapter5.mspx?mfr=true" rel="nofollow" title="针对C/C++开发人员采用Windows 64位">针对C/C++开发人员采用Windows 64位</a>》<br><a href="https://msdn.microsoft.com/en-us/library/cc230273.aspx" rel="nofollow" title="MS-DTYP">MS-DTYP</a>：<a href="https://msdn.microsoft.com/en-us/library/aa383751.aspx" rel="nofollow" title="Windows Data Types">Windows Data Types</a> / <a href="https://msdn.microsoft.com/en-us/library/br205768.aspx" rel="nofollow" title="Windows Runtime base data types">Windows Runtime base data types</a>  <br>  </p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b279cfdfcb63bcdd73c459d573be236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dhizuku@设备拥有者权限@android设备管理员权限@android替换默认软件安装器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e6bbe7e2ecc32579857c09d2cd8fa19/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">社区居民医疗健康系统 微信小程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>