<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>重学Java 8 数组Arr.2 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="重学Java 8 数组Arr.2" />
<meta property="og:description" content="可现实中，幸福永远缺货
——24.1.17
一、内存图 1.内存：可以理解为“内存条”，所有的软件，程序运行起来都会进入到内存中，占用内存，在java的世界中，将内容划分成了5块
2.分为哪五块呢：
①栈（Stack）*
主要运行方法，方法的运行都会进栈内存运行，运行完毕之后，需要“弹栈”，为了向空间释放内存
②堆（Heap）*
保存的是对象，数组，每new依次，都会在堆内存中开辟空间，并为这个空间分配一个地址值，堆内存中的数据都是有默认值的
整数：0 小数：0.0 字符：&#39;\u0000&#39; 布尔：false 引用：null
③方法区 （Method Area）*
找到的“预备区”，记录了类和方法的信息
方法区中主要保存class文件以及其中的信息
代码运行之前，需要先进内存（方法区）
④本地方法栈（Native Method Stack）：专门运行native方法（本地方法）
本地方法可以理解为堆对java功能的扩充
有很多功能，java语言实现不了，所以就需要依靠本地方法完成（C语言编写）
⑤寄存器（pc register）：和CPU有关
1.堆、栈、方法区的配合示意图 2.一个数组的内存图 public static void main(String[] args) { int[] arr1 = new int[3]; System.out.println(arr1); System.out.println(arr1[1]); arr1[1] =100; System.out.println(arr1[1]); } 3.两个数组的内存图 我们创建了两个数组，在堆内存中开辟了两个不同的空间，此时修改一个空间中的数据不会影响到另外一个空间的数据
public static void main(String[] args) { int[] arr1 = new int[3]; System.out.println(arr1); System.out.println(arr1[1]); arr[1] =100; System.out.println(arr1[1]); int[] arr2 = new int[3]; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/66f0983c4f21fa953fb2e1c64dace1a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-17T09:49:22+08:00" />
<meta property="article:modified_time" content="2024-01-17T09:49:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">重学Java 8 数组Arr.2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#6eaad7;">可现实中，幸福永远缺货</span></p> 
 <p><span style="color:#6eaad7;">                    ——24.1.17</span></p> 
</blockquote> 
<h2>一、内存图</h2> 
<blockquote> 
 <p>1.内存：可以理解为“内存条”，所有的软件，程序运行起来都会进入到内存中，占用内存，在java的世界中，将内容划分成了5块</p> 
 <p></p> 
 <p>2.分为哪五块呢：</p> 
 <p>        ①栈（Stack）*</p> 
 <p>                主要运行方法，方法的运行都会进栈内存运行，运行完毕之后，需要“弹栈”，为了向空间释放内存</p> 
 <p>        ②堆（Heap）*</p> 
 <p>                保存的是对象，数组，每new依次，都会在堆内存中开辟空间，并为这个空间分配一个地址值，堆内存中的数据都是有默认值的</p> 
 <p>                整数：0        小数：0.0        字符：'\u0000'        布尔：false        引用：null</p> 
 <p>        ③方法区 （Method Area）*</p> 
 <p>                找到的“预备区”，记录了类和方法的信息</p> 
 <p>                方法区中主要保存class文件以及其中的信息</p> 
 <p>                代码运行之前，需要先进内存（方法区）</p> 
 <p>        ④本地方法栈（Native Method Stack）：专门运行native方法（本地方法）</p> 
 <p>                本地方法可以理解为堆对java功能的扩充</p> 
 <p>                有很多功能，java语言实现不了，所以就需要依靠本地方法完成（C语言编写）</p> 
 <p>        ⑤寄存器（pc register）：和CPU有关</p> 
</blockquote> 
<h3 style="background-color:transparent;">1.堆、栈、方法区的配合示意图</h3> 
<p><img alt="" height="405" src="https://images2.imgbox.com/20/b3/I4o1MlnW_o.png" width="954"></p> 
<h3> 2.一个数组的内存图</h3> 
<pre><code class="language-java">    public static void main(String[] args) {
        int[] arr1 = new int[3];
        System.out.println(arr1);
        System.out.println(arr1[1]);
        arr1[1] =100;
        System.out.println(arr1[1]);
    }</code></pre> 
<p><img alt="" height="409" src="https://images2.imgbox.com/1e/9d/frHiJQkU_o.png" width="534"></p> 
<h3>3.两个数组的内存图</h3> 
<blockquote> 
 <p>        我们创建了两个数组，在堆内存中开辟了两个不同的空间，此时修改一个空间中的数据不会影响到另外一个空间的数据</p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        int[] arr1 = new int[3];
        System.out.println(arr1);
        System.out.println(arr1[1]);
        arr[1] =100;
        System.out.println(arr1[1]);

        int[] arr2 = new int[3];
        System.out.println(arr2);//地址值
        System.out.println(arr2[1]);
        arr2[1] = 200;
        System.out.println("arr1[1] = " + arr1[1]);
        System.out.println("arr2[1] = " + arr2[1]);
    }</code></pre> 
<p><img alt="" height="156" src="https://images2.imgbox.com/85/06/BdNbh3q1_o.png" width="437"></p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/ec/33/ey1Daxc2_o.png" width="545"></p> 
<h3>4.两个数组指向同一片空间内存图 </h3> 
<blockquote> 
 <p>        arr2不是new出来的，是arr1直接赋值给的，arr1在内存中保存的是地址值，给了arr2，那么arr2的地址值和arr1意义，所以此时arr1和arr2指向了堆内存中的同一片空间（同一个地址值，表示同一个数组），此时改变一个数组中的元素会影响到另外一个数组</p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        int[] arr1 = new int[3];
        System.out.println(arr1);
        arr1[1] =100;

        int[] arr2 = arr1;
        System.out.println(arr2);//地址值
        arr2[1] = 200;
        System.out.println("arr1[1] = " + arr1[1]);
        System.out.println("arr2[1] = " + arr2[1]);
    }</code></pre> 
<p><img alt="" height="152" src="https://images2.imgbox.com/0f/d9/Wni97lLs_o.png" width="495"></p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/12/42/bluvpayp_o.png" width="452"></p> 
<h2>二、二维数组</h2> 
<h3>1.二维数组的定义格式</h3> 
<blockquote> 
 <p>1.概述：数组中套了多个数组</p> 
 <p>2.定义格式：</p> 
 <p>        ①动态初始化</p> 
 <p>                数据类型[ ][ ] 数组名 = new 数据类型[m][n]</p> 
 <p>                数据类型 数组名[ ][ ] = new 数据类型[m][n]</p> 
 <p>                数据类型[ ] 数组名[ ] = new 数据类型[m][n]</p> 
 <p>        m代表的是二维数组的长度</p> 
 <p>        n代表的是二维数组中，一维数组的长度</p> 
 <p>                数据类型[ ][ ] 数组名 = new 数据类型[m][ ] -&gt; 二维数组中的一维数组没有被创建</p> 
 <p>        ②静态初始化</p> 
 <p>                数据类型[ ][ ] 数组名 = new 数据类型[ ][ ]{<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p>                数据类型 数组名[ ][ ] = new 数据类型[ ][ ]{<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p>                数据类型[ ] 数组名[ ] = new 数据类型[ ][ ]{<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p>        ③简化的静态初始化</p> 
 <p>                数据类型[ ][ ] 数组名 = {<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p>                数据类型 数组名[ ][ ] = {<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p>                数据类型[ ] 数组名[ ] = {<!-- -->{元素1，元素2，…}，{元素1，元素2，…}，…}</p> 
 <p></p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        int[][] arr1 = new int[2][2];
        int[][] arr2 = new int[2][];

        System.out.println();
        String[][] arr3 = {<!-- -->{"唐僧","孙悟空","猪八戒","沙和尚"},{"刘备","关羽","张飞"},{"宋江"},{"贾宝玉","林黛玉"}};
    }</code></pre> 
<p><strong>注：动态初始化数组长度必须定死，静态初始化数组长度不用定义好，每一个一维数组的长度根据实际存储的数据数来确定</strong></p> 
<h3><strong>2.获取二维数组的长度</strong></h3> 
<blockquote> 
 <p>1.格式：</p> 
 <p>        数组名.length</p> 
 <p> 2.获取每一个一维数组长度，需要先遍历二维数组，将每一个一维数组遍历出来</p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        String[][] arr1 = {<!-- -->{"唐僧","孙悟空","猪八戒","沙和尚"},{"刘备","关羽","张飞"},{"宋江"},{"贾宝玉","林黛玉"}};
        for (int i = 0; i &lt; arr1.length; i++) {
            //获取每一个一维数组的长度
            System.out.println(arr1[i].length);
        }
    }</code></pre> 
<p><img alt="" height="159" src="https://images2.imgbox.com/1b/2b/zY99bSXs_o.png" width="459"></p> 
<h3>3.获取、存储二维数组中元素及遍历</h3> 
<blockquote> 
 <h4>获取</h4> 
 <p>①格式：</p> 
 <p>        数组名[i][j]</p> 
 <p>        i:代表的是一维数组在二维数组中的索引位置</p> 
 <p>        j:代表的是元素在一维数组中的索引位置</p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        //获取二维数组中的元素
        String[][] arr1 = {<!-- -->{"唐僧","孙悟空","猪八戒","沙和尚"},{"刘备","关羽","张飞"},{"宋江"},{"贾宝玉","林黛玉"}};
        System.out.println(arr1[0][1]);
        System.out.println(arr1[1][0]);
        System.out.println(arr1[2][0]);
        System.out.println(arr1[3][0]);
    }</code></pre> 
<p><img alt="" height="147" src="https://images2.imgbox.com/4d/7b/nVfYQaER_o.png" width="409"></p> 
<blockquote> 
 <h4>存储</h4> 
 <p>①格式：</p> 
 <p>        数组名[i][j] = 值</p> 
 <p>i:代表的是一维数组在二维数组中的索引位置</p> 
 <p>j:代表的是元素在一维数组中的索引位置</p> 
</blockquote> 
<p><strong>多行列数对齐操作：ALT键不放鼠标下拉</strong></p> 
<blockquote> 
 <h4><strong>遍历</strong></h4> 
 <p>①先遍历二维数组，将每一个一维数组遍历出来</p> 
 <p>②在遍历每一个一维数组，将元素获取出来</p> 
</blockquote> 
<pre><code class="language-java">    public static void main(String[] args) {
        String[][] arr1 = {<!-- -->{"唐僧","孙悟空","猪八戒","沙和尚"},{"刘备","关羽","张飞"},{"宋江"},{"贾宝玉","林黛玉"}};
        for (int i = 0; i &lt; arr1.length; i++) {
            //获取每一个一维数组的长度
            System.out.print(arr1[i].length +" ");
            for (int j = 0; j &lt; arr1[i].length; j++) {
                System.out.print(arr1[i][j]+" ");
            }
            System.out.println();
        }
    }</code></pre> 
<h3><img alt="" height="184" src="https://images2.imgbox.com/14/b5/VxnOGAi9_o.png" width="472"></h3> 
<h3>4.二维数组内存图</h3> 
<p><img alt="" height="366" src="https://images2.imgbox.com/5f/be/JI3AA4vA_o.png" width="587"></p> 
<h2>三、总结</h2> 
<p><img alt="" height="448" src="https://images2.imgbox.com/fe/1d/8wwxdk6c_o.png" width="637"></p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/69/e6/5WlG6TB3_o.png" width="1029"></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/e7/de/DNQoMwbS_o.png" width="1049"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb9655e53e9fb46ebad342370378fac5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大厂-靠谱程序员】通用能力模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9bf81ca3d6bc0f1e7b0010735bdcf5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">删除注册表残留</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>