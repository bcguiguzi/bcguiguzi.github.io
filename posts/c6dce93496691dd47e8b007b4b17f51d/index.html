<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>读写器reader和writer详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="读写器reader和writer详解" />
<meta property="og:description" content="一、读取器Ext.data.reader.Reader 根类
1、JSON格式的读取器
(1)定义数据集(例子使用内存代理)
varuserData={
//total:200,
count:250,
user:[autorth:&#34;zhang&#34;,info{
userID:1,
name:&#34;marico&#34;,
orders:[
{id:&#34;001&#34;,name:&#34;pen&#34;},
{id:&#34;002&#34;,name:&#34;book&#34;}
]
}]
};
(2)定义model数据模型 配置一对多关联
配置一对多关系 ，hasmany字段指定一个对象
model指定的是多方的数据模型
name指定的属性名，如果配置name则使用这个名字来获取级联的记录，如果不配置系统自动生成为orders
Ext.regModel(&#34;user&#34;,{
fields:[
{name:&#34;userID&#34;,type:&#34;string&#34;},
{name:&#34;name&#34;,type:&#34;string&#34;}
],
hasMany:{
model:&#34;order&#34;
//name:&#34;order&#34;
}
});
配置多对一关系，belongTo指定一个对象
参数type值得是什么关联，belongTo代表多对一 model指定一方的数据模型
Ext.regModel(&#34;order&#34;,{
fields:[
{name:&#34;id&#34;,type:&#34;string&#34;},
{name:&#34;name&#34;,type:&#34;string&#34;}
],
belongTo:{type:&#34;belongTo&#34;,model:&#34;user&#34;}
});
(3)创建内存代理并指定reader
reader指定的是对象
type指定的是什么数据 常用json和xml
root指定的是得到数据的根，也就想得到的数据的对象名，上方userData中的user
implicitIncludes默认为true 设置是否级联操作
totalProperty指定的是读取total数据的属性名 如果没有系统则默认为1
record对服务器返回的数据可能很复杂，用record可以筛选出有用的的数据信息，装载到Model中
varmproxy=Ext.create(&#34;Ext.data.proxy.Memory&#34;,{
model:&#34;user&#34;,
data:userData,
reader:{
type:&#34;json&#34;,
root:&#34;user&#34;,
implicitIncludes:true,
totalProperty:&#34;count&#34;,//上方已经设置为count
record:&#34;info&#34; }
});
(4)调用代理中的read方法遍历并输出元素
mproxy.read(newExt.data.Operation(),function(result){
vardatas=result.resultSet.records;//存放数据的对象数组
//alert(result);
alert(result.resultSet.total);
//利用ExtArray中的each方法遍历数组" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c6dce93496691dd47e8b007b4b17f51d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-01-12T03:37:19+08:00" />
<meta property="article:modified_time" content="2012-01-12T03:37:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">读写器reader和writer详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="center"><br> </p> 
<p>一、读取器Ext.data.reader.Reader 根类</p> 
<p>       1、JSON格式的读取器</p> 
<p>              (1)定义数据集(例子使用内存代理)</p> 
<p>                     varuserData={<!-- --></p> 
<p>                     //total:200,</p> 
<p>                     count:250,</p> 
<p>                     user:[autorth:"zhang",info{<!-- --></p> 
<p>                            userID:1,</p> 
<p>                            name:"marico",</p> 
<p>                            orders:[</p> 
<p>                                   {id:"001",name:"pen"},</p> 
<p>                                   {id:"002",name:"book"}</p> 
<p>                            ]</p> 
<p>                     }]</p> 
<p>                     };</p> 
<p>              (2)定义model数据模型 配置一对多关联</p> 
<p>              配置一对多关系 ，hasmany字段指定一个对象</p> 
<p>                     model指定的是多方的数据模型</p> 
<p>                     name指定的属性名，如果配置name则使用这个名字来获取级联的记录，如果不配置系统自动生成为orders</p> 
<p>              Ext.regModel("user",{<!-- --></p> 
<p>                     fields:[</p> 
<p>                            {name:"userID",type:"string"},</p> 
<p>                            {name:"name",type:"string"}</p> 
<p>                     ],</p> 
<p>                     hasMany:{<!-- --></p> 
<p>                            model:"order"</p> 
<p>                            //name:"order"</p> 
<p>                     }</p> 
<p>              });</p> 
<p>              配置多对一关系，belongTo指定一个对象</p> 
<p>              参数type值得是什么关联，belongTo代表多对一 </p> 
<p>              model指定一方的数据模型</p> 
<p>              Ext.regModel("order",{<!-- --></p> 
<p>                     fields:[</p> 
<p>                            {name:"id",type:"string"},</p> 
<p>                            {name:"name",type:"string"}</p> 
<p>                     ],</p> 
<p>                     belongTo:{type:"belongTo",model:"user"}</p> 
<p>              });</p> 
<p>              (3)创建内存代理并指定reader</p> 
<p>               reader指定的是对象</p> 
<p>                     type指定的是什么数据 常用json和xml</p> 
<p>                     root指定的是得到数据的根，也就想得到的数据的对象名，上方userData中的user</p> 
<p>                     implicitIncludes默认为true 设置是否级联操作</p> 
<p>                     totalProperty指定的是读取total数据的属性名  如果没有系统则默认为1</p> 
<p>                     record对服务器返回的数据可能很复杂，用record可以筛选出有用的的数据信息，装载到Model中</p> 
<p>              varmproxy=Ext.create("Ext.data.proxy.Memory",{<!-- --></p> 
<p>                     model:"user",</p> 
<p>                     data:userData,</p> 
<p>                     reader:{<!-- --></p> 
<p>                            type:"json",</p> 
<p>                            root:"user",</p> 
<p>                            implicitIncludes:true,</p> 
<p>                            totalProperty:"count",//上方已经设置为count</p> 
<p>                            record:"info"  </p> 
<p>                     }</p> 
<p>              });</p> 
<p>              (4)调用代理中的read方法遍历并输出元素</p> 
<p>                     mproxy.read(newExt.data.Operation(),function(result){<!-- --></p> 
<p>                            </p> 
<p>                            vardatas=result.resultSet.records;//存放数据的对象数组</p> 
<p>                            //alert(result);</p> 
<p>                            alert(result.resultSet.total);</p> 
<p>                            //利用ExtArray中的each方法遍历数组</p> 
<p>                            Ext.Array.each(datas,function(model){<!-- --></p> 
<p>                                   alert(model.get("name"));</p> 
<p>                            });</p> 
<p>                            //得到一个user对象</p> 
<p>                            varuser=result.resultSet.records[0];</p> 
<p>                            varorders=user.orders(); //调用orders方法就可以得到里面orders数据，返回的是store数据集</p> 
<p>                            //调用Ext.data.Store中each方法遍历</p> 
<p>                            orders.each(function(order){<!-- --></p> 
<p>                                   alert(order.get("name"));</p> 
<p>                            });</p> 
<p>                     });</p> 
<p>              </p> 
<p>              </p> 
<p>                     </p> 
<p>       2、XML格式的读取器</p> 
<p>              (1)创建xml文档</p> 
<p>                     &lt;users&gt;</p> 
<p>                            &lt;user&gt;</p> 
<p>                                   &lt;name&gt;marico&lt;/name&gt;</p> 
<p>                                   &lt;id&gt;00101&lt;/id&gt;</p> 
<p>                            &lt;/user&gt;</p> 
<p>                     &lt;/users&gt;</p> 
<p>              (2)创建数据模型并指定reader中的type属性为xml</p> 
<p>              </p> 
<p>                     Ext.regModel("user",{<!-- --></p> 
<p>                     fields:[</p> 
<p>                            {name:"name"},</p> 
<p>                            {name:"id"}</p> 
<p>                     ],</p> 
<p>                     proxy:{<!-- --></p> 
<p>                            type:"ajax",</p> 
<p>                            url:"users.xml",</p> 
<p>                            reader:{<!-- --></p> 
<p>                                   type:"xml",</p> 
<p>                                   record:"user"</p> 
<p>                            }</p> 
<p>                     }</p> 
<p>              });</p> 
<p>              (3)创建对象并调用load方法遍历</p> 
<p>              varuser=Ext.ModelManager.getModel("user");</p> 
<p>              user.load(1,{<!-- --></p> 
<p>                     success:function(model){<!-- --></p> 
<p>                            alert(model.get("name"));</p> 
<p>                     }</p> 
<p>              });</p> 
<p>       2、Array格式的读取器</p> 
<p>              定义model 可以将其属性制定成简单的数组</p> 
<p>              返回信息的格式：[['marico',21],['zhang',20]]</p> 
<p>              Ext.regModel("user",{<!-- --></p> 
<p>                     fields:[    </p> 
<p>                     'name','age'</p> 
<p>                     ],</p> 
<p>                     proxy:{<!-- --></p> 
<p>                            type:"ajax",</p> 
<p>                            url:"user.jsp",</p> 
<p>                            reader:{<!-- --></p> 
<p>                                   type:"array",</p> 
<p>                            }</p> 
<p>                     }</p> 
<p>              });</p> 
<p>              varuser=Ext.ModelManager.getModel("user");</p> 
<p>              user.load(1,{<!-- --></p> 
<p>                     success:function(model){<!-- --></p> 
<p>                            alert(model.get("name"));</p> 
<p>                     }</p> 
<p>              });</p> 
<p>二、写Ext.data.writer.writer</p> 
<p>       1定义model并指定writer已什么形式响应</p> 
<p>              type指定响应格式  json 和xml  则就可以在后台解析出来数据</p> 
<p>              </p> 
<p>              Ext.onReady(function(){<!-- --></p> 
<p>              Ext.regModel("person",{<!-- --></p> 
<p>              fields:[</p> 
<p>                     'name','age'</p> 
<p>                     //{name:"name"},</p> 
<p>                     //{name:"age"}</p> 
<p>              ],</p> 
<p>              proxy:{<!-- --></p> 
<p>                     type:"ajax",</p> 
<p>                     url:"person.jsp",</p> 
<p>                     reader:{<!-- --></p> 
<p>                            type:"array"</p> 
<p>                     },</p> 
<p>                     writer:{<!-- --></p> 
<p>                            type:"json"</p> 
<p>                     }</p> 
<p>              }</p> 
<p>       });</p> 
<p>       2、实例化对象并调用save方法</p> 
<p>       Ext.ModelMgr.create({<!-- --></p> 
<p>              name:"marico",</p> 
<p>              age:21</p> 
<p>       },'person').save();   </p> 
<p>       </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9de7ba09f2c0d41f724b87e59fc0ac8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PS域业务与CS域业务的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac14f16da89972280e6272906e9361b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GDB基本命令(整合)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>