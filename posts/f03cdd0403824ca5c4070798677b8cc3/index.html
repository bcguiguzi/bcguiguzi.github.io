<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>阿里C&#43;&#43;面试题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="阿里C&#43;&#43;面试题" />
<meta property="og:description" content="1. new和malloc的区别。 详细参考：链接
new是运算符，malloc()是一个库函数；new会调用构造函数，malloc不会；new返回指定类型指针，malloc返回void*指针，需要强制类型转换；new会自动计算需分配的空间，malloc不行；new可以被重载，malloc不能。 2. 内存泄漏的解决方法： 养成良好的编码习惯和规范，记得及时释放掉内存或系统资源。重载new和delete，以链表的形式自动管理分配的内存。使用智能指针，share_ptr、auto_ptr、weak_ptr。 3. 智能指针 智能指针是在 &lt;memory&gt; 头文件中的std命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对RAII“获取资源即初始化”编程至关重要，RAII的主要原则是为将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。unique_ptr只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用make_shared标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。 4. Map查找时间 map查找的时间复杂度是对数的，这几乎是最快的，hash也是对数的。
STL 中的 map 内部是平衡二叉树，所以平衡二叉树的性质都具备。查找数据的时间也是对数时间。 STL的map有平衡策略（比如红黑树什么的），所以不会退化，不需要考虑数据本身的分布问题。只不过，如果数据本身是排好序的，用vector或heap会明显的快些，因为它们的访问比较简单。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f03cdd0403824ca5c4070798677b8cc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-18T19:54:17+08:00" />
<meta property="article:modified_time" content="2019-04-18T19:54:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">阿里C&#43;&#43;面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1. new和malloc的区别。</h4> 
<p>       详细参考：<a href="https://blog.csdn.net/hackbuteer1/article/details/6789164">链接</a></p> 
<ul><li>new是<strong>运算符</strong>，malloc()是一个<strong>库函数</strong>；</li><li>new会调用<strong>构造函数</strong>，malloc不会；</li><li>new返回指定类型指针，malloc返回<strong>void</strong>*指针，需要强制类型转换；</li><li>new会自动计算需分配的空间，malloc不行；</li><li>new可以被<strong>重载</strong>，malloc不能。</li></ul> 
<h4><strong>2. 内存泄漏的解决方法：</strong></h4> 
<ul><li>养成良好的编码习惯和规范，记得及时释放掉内存或系统资源。</li><li>重载new和delete，以链表的形式自动管理分配的内存。</li><li>使用<strong>智能指针</strong>，share_ptr、auto_ptr、weak_ptr。</li></ul> 
<h4>3. 智能指针</h4> 
<ul><li>智能指针是在 <strong>&lt;memory&gt;</strong> 头文件中的std命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对<strong>RAII“获取资源即初始化”</strong>编程至关重要，RAII的主要原则是为<strong>将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象</strong>。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。</li><li>智能指针的设计思想：<strong>将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</strong></li><li><strong>unique_ptr</strong>只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。</li><li><strong>shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。</strong>当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用<strong>make_shared</strong>标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。</li></ul> 
<h4>4. Map查找时间</h4> 
<ol><li> <p><strong>map查找的时间复杂度是对数的，这几乎是最快的，hash也是对数的。</strong></p> </li><li> <p><strong>STL   中的   map   内部是平衡二叉树，所以平衡二叉树的性质都具备。查找<a href="http://www.haogongju.net/tag/%E6%95%B0%E6%8D%AE" rel="nofollow">数据</a>的时间也是对数时间。</strong> </p> </li></ol> 
<p>STL的map有平衡策略（比如红黑树什么的），所以不会退化，不需要考虑数据本身的分布问题。<strong>只不过，如果数据本身是排好序的，用vector或heap会明显的快些，因为它们的访问比较简单。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13ead6cf66376e466d8a78c749b79f86/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker容器创建zabbix服务以及自动发现\自动注册\ 监控docker容器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ce28377dd9e59dd11a6cec0a274797f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PA1--实现基础设施、表达式求值和监视点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>