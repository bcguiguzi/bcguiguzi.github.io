<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构（二）顺序表和链表 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构（二）顺序表和链表" />
<meta property="og:description" content="1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使
用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，
线性表在物理上存储时，通常以数组和链式结构的形式存储。
2.顺序表 2.1概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存
储。在数组上完成数据的增删查改。
顺序表一般可以分为：
1. 静态顺序表：使用定长数组存储元素。
2. 动态顺序表：使用动态开辟的数组存储。
我们在这里讲一下静态开辟的缺点：
1.我们不知道需要多少。
2.开辟多了（空间）浪费。
3.开辟少了（空间）不够用
同时我们讲一下动态开辟的优点：
1.不够用了可以开辟
2，开辟多了可以释放
.................................总之我们还是强烈建议使用动态开辟。
现在我们来创建一个顺序表：
#include&lt;stdio.h&gt; int main() { struct seqsdfs { int *a; int size; //记录有效数据 int capacity //记录空间有多大 2.2 接口实现 静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空
间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间
大小，所以下面我们实现动态顺序表。
typedef int SLDataType; // 顺序表的动态存储 typedef struct SeqList { SLDataType* array; // 指向动态开辟的数组 size_t size ; // 有效数据个数 size_t capicity ; // 容量空间的大小 }SeqList; // 基本增删查改接口 // 顺序表初始化 void SeqListInit(SeqList* psl); // 检查空间，如果满了，进行增容 void CheckCapacity(SeqList* psl); // 顺序表尾插 void SeqListPushBack(SeqList* psl, SLDataType x); // 顺序表尾删 void SeqListPopBack(SeqList* psl); // 顺序表头插 void SeqListPushFront(SeqList* psl, SLDataType x); // 顺序表头删 void SeqListPopFront(SeqList* psl); // 顺序表查找 int SeqListFind(SeqList* psl, SLDataType x); // 顺序表在pos位置插入x void SeqListInsert(SeqList* psl, size_t pos, SLDataType x); // 顺序表删除pos位置的值 void SeqListErase(SeqList* psl, size_t pos); // 顺序表销毁 void SeqListDestory(SeqList* psl); // 顺序表打印 void SeqListPrint(SeqList* psl); 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/54a9163c2da84c0618e4381c38b13d74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T20:08:42+08:00" />
<meta property="article:modified_time" content="2024-03-15T20:08:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构（二）顺序表和链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.线性表</h2> 
<p>线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使<br> 用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...<br> 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，<br> 线性表在物理上存储时，通常以数组和链式结构的形式存储。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/88/dd/UepVhW9s_o.png"></p> 
<h2>2.顺序表 </h2> 
<h3>2.1概念及结构</h3> 
<p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存<br> 储。在数组上完成数据的增删查改。<br> 顺序表一般可以分为：</p> 
<p>1. 静态顺序表：使用定长数组存储元素。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/8f/Q55QTnu9_o.png"></p> 
<p>2. 动态顺序表：使用动态开辟的数组存储。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/76/zi8GVq2L_o.png"></p> 
<p>我们在这里讲一下静态开辟的缺点：</p> 
<p>1.我们不知道需要多少。</p> 
<p>2.开辟多了（空间）浪费。</p> 
<p>3.开辟少了（空间）不够用</p> 
<p>同时我们讲一下动态开辟的优点：</p> 
<p>1.不够用了可以开辟</p> 
<p>2，开辟多了可以释放</p> 
<p>.................................总之我们还是强烈建议使用动态开辟。</p> 
<p>现在我们来创建一个顺序表：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
   struct seqsdfs
   { 
      int *a;
      int size;      //记录有效数据
      int capacity   //记录空间有多大
      </code></pre> 
<h3>2.2 接口实现 </h3> 
<p>静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空<br> 间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间<br> 大小，所以下面我们实现动态顺序表。</p> 
<pre><code class="language-cpp">typedef int SLDataType;
// 顺序表的动态存储
typedef struct SeqList
{
 SLDataType* array;  // 指向动态开辟的数组
 size_t size ;    // 有效数据个数
 size_t capicity ;  // 容量空间的大小
}SeqList;
// 基本增删查改接口
// 顺序表初始化
void SeqListInit(SeqList* psl);
// 检查空间，如果满了，进行增容
void CheckCapacity(SeqList* psl);
// 顺序表尾插
void SeqListPushBack(SeqList* psl, SLDataType x);
// 顺序表尾删
void SeqListPopBack(SeqList* psl);
// 顺序表头插
void SeqListPushFront(SeqList* psl, SLDataType x);
// 顺序表头删
void SeqListPopFront(SeqList* psl);
// 顺序表查找
int SeqListFind(SeqList* psl, SLDataType x);
// 顺序表在pos位置插入x
void SeqListInsert(SeqList* psl, size_t pos, SLDataType x);
// 顺序表删除pos位置的值
void SeqListErase(SeqList* psl, size_t pos);
// 顺序表销毁
void SeqListDestory(SeqList* psl);
// 顺序表打印
void SeqListPrint(SeqList* psl);</code></pre> 
<p> </p> 
<h2>3.链表 </h2> 
<h3>3.1 链表的概念及结构</h3> 
<p>概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表<br> 中的指针链接次序实现的 。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ae/75/lzkb9n7d_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5c/ec/iqoJyEAF_o.png"> </p> 
<p>现实中 数据结构中</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/39/1JuqexMj_o.png"> </p> 
<h3>3.2 链表的分类 </h3> 
<p>实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：</p> 
<p>1. 单向或者双向</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/59/5b/eKHa0440_o.png"></p> 
<p> 2. 带头或者不带头</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c0/e8/T7awKMJ2_o.png"></p> 
<p style="text-align:center;"></p> 
<p> 3. 循环或者非循环</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/11/88/2VqbNzaj_o.png"></p> 
<p>虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/0a/76hFuSR1_o.png"> </p> 
<p>1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结<br> 构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。<br> 2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都<br> 是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带<br> 来很多优势，实现反而简单了，后面我们代码实现了就知道了。 </p> 
<h3>3.3 链表的实现</h3> 
<pre><code class="language-cpp">// 1、无头+单向+非循环链表增删查改实现
typedef int SLTDateType;
typedef struct SListNode
{
SLTDateType data;
struct SListNode* next;
}SListNode;
// 动态申请一个结点
SListNode* BuySListNode(SLTDateType x);
// 单链表打印
void SListPrint(SListNode* plist);
// 单链表尾插
void SListPushBack(SListNode** pplist, SLTDateType x);
// 单链表的头插
void SListPushFront(SListNode** pplist, SLTDateType x);
// 单链表的尾删
void SListPopBack(SListNode** pplist);
// 单链表头删
void SListPopFront(SListNode** pplist);
// 单链表查找
SListNode* SListFind(SListNode* plist, SLTDateType x);
// 单链表在pos位置之后插入x
// 分析思考为什么不在pos位置之前插入？
void SListInsertAfter(SListNode* pos, SLTDateType x);
// 单链表删除pos位置之后的值
// 分析思考为什么不删除pos位置？
void SListEraseAfter(SListNode* pos);</code></pre> 
<h3>3.4 链表面试题 </h3> 
<p>1. 删除链表中等于给定值 val 的所有结点。 OJ链接<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a><br> 2. 反转一个单链表。 OJ链接<a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a><br> 3. 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则<br> 返回第二个中间结点。OJ链接<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a><br> 4. 输入一个链表，输出该链表中倒数第k个结点。 OJ链接<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="牛客网-题目已下线_牛客网">牛客网-题目已下线_牛客网</a><br> 5. 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有<br> 结点组成的。OJ链接<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a><br> 6. 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结<br> 点之前 。OJ链接<a href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking" rel="nofollow" title="链表分割_牛客题霸_牛客网">链表分割_牛客题霸_牛客网</a><br> 7. 链表的回文结构。OJ链接<a href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="链表的回文结构_牛客题霸_牛客网">链表的回文结构_牛客题霸_牛客网</a><br> 8. 输入两个链表，找出它们的第一个公共结点。OJ链接<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/98/hGvqjEY9_o.png"></p> 
<p>9. 给定一个链表，判断链表中是否有环。<a href="https://leetcode-cn.com/problems/linked-list-cycle/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p>【思路】<br> 快慢指针，即慢指针一次走一步，快指针一次走两步，两个指针从链表其实位置开始运行，<br> 如果链表<br> 带环则一定会在环中相遇，否则快指针率先走到链表的末尾。比如：陪女朋友到操作跑步减<br> 肥。</p> 
<p>【扩展问题】</p> 
<p>为什么快指针每次走两步，慢指针走一步可以？<br> 假设链表带环，两个指针最后都会进入环，快指针先进环，慢指针后进环。当慢指针刚<br> 进环时，可能就和快指针相遇了，最差情况下两个指针之间的距离刚好就是环的长度。<br> 此时，两个指针每移动一次，之间的距离就缩小一步，不会出现每次刚好是套圈的情<br> 况，因此：在满指针走到一圈之前，快指针肯定是可以追上慢指针的，即相遇。<br> 快指针一次走3步，走4步，...n步行吗？</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c2/17/sxm1kkAg_o.png"></p> 
<p>10. 给定一个链表，返回链表开始入环的第一个结点。 如果链表无环，则返回 NULL OJ链接 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p>结论<br> 让一个指针从链表起始位置开始遍历链表，同时让一个指针从判环时相遇点的位置开始绕环<br> 运行，两个指针都是每次均走一步，最终肯定会在入口点的位置相遇。<br> 证明</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/4a/AC6lGBa2_o.png"></p> 
<p> </p> 
<h3>3.5 双向链表的实现 </h3> 
<pre><code class="language-cpp">// 2、带头+双向+循环链表增删查改实现
typedef int LTDataType;
typedef struct ListNode
{
LTDataType _data;
struct ListNode* next;
struct ListNode* prev;
}ListNode;
// 创建返回链表的头结点.
ListNode* ListCreate();
// 双向链表销毁
void ListDestory(ListNode* plist);
// 双向链表打印
void ListPrint(ListNode* plist);
// 双向链表尾插
void ListPushBack(ListNode* plist, LTDataType x);
// 双向链表尾删
void ListPopBack(ListNode* plist);
// 双向链表头插
void ListPushFront(ListNode* plist, LTDataType x);
// 双向链表头删
void ListPopFront(ListNode* plist);
// 双向链表查找
ListNode* ListFind(ListNode* plist, LTDataType x);
// 双向链表在pos的前面进行插入
void ListInsert(ListNode* pos, LTDataType x);
// 双向链表删除pos位置的结点
void ListErase(ListNode* pos);</code></pre> 
<h2>4.顺序表和链表的区别 </h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d4/82/5rR6ACHb_o.png"></p> 
<p>今天的分享就到这了</p> 
<p>感谢你的观看</p> 
<p> </p> 
<p></p> 
<p></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c2cfa3104b51d197558b3c50d737843/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#中网口数据（TCP/IP）发送与接收的主动模式与被动模式解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b231a98dadca49871418e6152b5f01cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sklearn.model_selection.learning_curve的详细介绍（包含ShuffleSplit()介绍）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>