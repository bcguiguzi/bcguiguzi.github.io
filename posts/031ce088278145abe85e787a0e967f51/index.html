<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>uboot启动流程概述 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="uboot启动流程概述" />
<meta property="og:description" content="一、uboot启动流程简介
与大多数BootLoader一样，uboot的启动过程分为BL1和BL2两个阶段。BL1阶段通常是开发板的配置等设备初始化代码，需要依赖依赖于SoC体系结构，通常用汇编语言来实现；BL2阶段主要是对外部设备如网卡、Flash等的初始化以及uboot命令集等的自身实现，通常用C语言来实现。
1、BL1阶段
uboot的BL1阶段代码通常放在start.s文件中，用汇编语言实现，其主要代码功能如下：
（1） 指定uboot的入口。在链接脚本uboot.lds中指定uboot的入口为start.S中的_start。
（2）设置异常向量(exception vector)
（3）关闭IRQ、FIQ，设置SVC模式
（4）关闭L1 cache、设置L2 cache、关闭MMU
（5）根据OM引脚确定启动方式
（6）在SoC内部SRAM中设置栈
（7）lowlevel_init（主要初始化系统时钟、SDRAM初始化、串口初始化等）
（8）设置开发板供电锁存
（9）设置SDRAM中的栈
（10）将uboot从SD卡拷贝到SDRAM中
（11）设置并开启MMU
（12）通过对SDRAM整体使用规划，在SDRAM中合适的地方设置栈
（13）清除bss段，远跳转到start_armboot执行，BL1阶段执行完
2、BL2阶段
start_armboot函数位于lib_arm/board.c中，是C语言开始的函数，也是BL2阶段代码中C语言的主函数，同时还是整个u-boot（armboot）的主函数，BL2阶段的主要功能如下：
（1）规划uboot的内存使用
（2）遍历调用函数指针数组init_sequence中的初始化函数
（3）初始化uboot的堆管理器mem_malloc_init
（4）初始化SMDKV210开发板的SD/MMC控制器mmc_initialize
（5）环境变量重定位env_relocate
（6）将环境变量中网卡地址赋值给全局变量的开发板变量
（7）开发板硬件设备的初始化devices_init
（8）跳转表jumptable_init
（9）控制台初始化console_init_r
（10）网卡芯片初始化eth_initialize
（11）uboot进入主循环main_loop
二、uboot程序入口分析
1、link.lds链接脚本文件分析
u-boot.lds文件是uboot工程的链接脚本文件，位于board\samsung\smdkc110目录下，对于工程项目编译后期的链接阶段非常重要，决定了uboot程序的组装。
u-boot.lds链接文件中的ENTRY(_start)指定了uboot程序的入口地址为_start。
2、定位uboot程序入口地址
在SourceInsight建立uboot工程，利用索引功能查找_start，在搜索结果中找到与三星smdkv210开发板相关的代码，最终锁定cpu\s5pc11x\start.S文件，定位到文件中的_start标识符。
三、start.S文件分析
1、头文件分析
start.S有四个头文件：
#include &lt;config.h&gt;
config.h头文件在配置开发板时由mkconfig脚本创建的头文件，头文件内容即包含开发板的头文件：#include &lt;configs/smdkv210single.h&gt; #include &lt;version.h&gt;
version.h头文件的内容为包含自动生成的版本头文件，头文件内容为：#include &#34;version_autogenerated.h&#34;，version_autogenerated.h头文件定义了版本宏，宏定义为：#define U_BOOT_VERSION &#34;U-Boot 1.3.4&#34;。版本宏的值就是Makefile中定义的版本信息。 #include &lt;asm/proc/domain.h&gt;
domain.h头文件在定义了CONFIG_ENABLE_MMU宏时有效，为链接文件，实际指向的文件为include/asm-arm/proc-armv/domain.h。 #include &lt;regs.h&gt;
regs.h头文件为链接文件，指向s5pc110.h头文件，s5pc110.h文件内部使用宏定义了有关SoC内部寄存器的大量信息。
2、头校验信息的占位
#if defined(CONFIG_EVT1) &amp;&amp; !defined(CONFIG_FUSED)
.word 0x2000
.word 0x0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/031ce088278145abe85e787a0e967f51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-15T22:02:07+08:00" />
<meta property="article:modified_time" content="2021-02-15T22:02:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">uboot启动流程概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一、uboot启动流程简介<br> 与大多数BootLoader一样，uboot的启动过程分为BL1和BL2两个阶段。BL1阶段通常是开发板的配置等设备初始化代码，需要依赖依赖于SoC体系结构，通常用汇编语言来实现；BL2阶段主要是对外部设备如网卡、Flash等的初始化以及uboot命令集等的自身实现，通常用C语言来实现。</p> 
<p>1、BL1阶段<br> uboot的BL1阶段代码通常放在start.s文件中，用汇编语言实现，其主要代码功能如下：</p> 
<p>（1） 指定uboot的入口。在链接脚本uboot.lds中指定uboot的入口为start.S中的_start。</p> 
<p>（2）设置异常向量(exception vector)</p> 
<p>（3）关闭IRQ、FIQ，设置SVC模式</p> 
<p>（4）关闭L1 cache、设置L2 cache、关闭MMU</p> 
<p>（5）根据OM引脚确定启动方式</p> 
<p>（6）在SoC内部SRAM中设置栈</p> 
<p>（7）lowlevel_init（主要初始化系统时钟、SDRAM初始化、串口初始化等）</p> 
<p>（8）设置开发板供电锁存</p> 
<p>（9）设置SDRAM中的栈</p> 
<p>（10）将uboot从SD卡拷贝到SDRAM中</p> 
<p>（11）设置并开启MMU</p> 
<p>（12）通过对SDRAM整体使用规划，在SDRAM中合适的地方设置栈</p> 
<p>（13）清除bss段，远跳转到start_armboot执行，BL1阶段执行完</p> 
<p>2、BL2阶段<br> start_armboot函数位于lib_arm/board.c中，是C语言开始的函数，也是BL2阶段代码中C语言的主函数，同时还是整个u-boot（armboot）的主函数，BL2阶段的主要功能如下：</p> 
<p>（1）规划uboot的内存使用</p> 
<p>（2）遍历调用函数指针数组init_sequence中的初始化函数</p> 
<p>（3）初始化uboot的堆管理器mem_malloc_init</p> 
<p>（4）初始化SMDKV210开发板的SD/MMC控制器mmc_initialize</p> 
<p>（5）环境变量重定位env_relocate</p> 
<p>（6）将环境变量中网卡地址赋值给全局变量的开发板变量</p> 
<p>（7）开发板硬件设备的初始化devices_init</p> 
<p>（8）跳转表jumptable_init</p> 
<p>（9）控制台初始化console_init_r</p> 
<p>（10）网卡芯片初始化eth_initialize</p> 
<p>（11）uboot进入主循环main_loop</p> 
<p>二、uboot程序入口分析<br> 1、link.lds链接脚本文件分析<br> u-boot.lds文件是uboot工程的链接脚本文件，位于board\samsung\smdkc110目录下，对于工程项目编译后期的链接阶段非常重要，决定了uboot程序的组装。</p> 
<p>u-boot.lds链接文件中的ENTRY(_start)指定了uboot程序的入口地址为_start。</p> 
<p>2、定位uboot程序入口地址<br> 在SourceInsight建立uboot工程，利用索引功能查找_start，在搜索结果中找到与三星smdkv210开发板相关的代码，最终锁定cpu\s5pc11x\start.S文件，定位到文件中的_start标识符。</p> 
<p>三、start.S文件分析<br> 1、头文件分析<br> start.S有四个头文件：</p> 
<p>#include &lt;config.h&gt;</p> 
<pre><code>config.h头文件在配置开发板时由mkconfig脚本创建的头文件，头文件内容即包含开发板的头文件：#include &lt;configs/smdkv210single.h&gt;
</code></pre> 
<p>#include &lt;version.h&gt;</p> 
<pre><code>version.h头文件的内容为包含自动生成的版本头文件，头文件内容为：#include "version_autogenerated.h"，version_autogenerated.h头文件定义了版本宏，宏定义为：#define U_BOOT_VERSION "U-Boot 1.3.4"。版本宏的值就是Makefile中定义的版本信息。
</code></pre> 
<p>#include &lt;asm/proc/domain.h&gt;</p> 
<pre><code>domain.h头文件在定义了CONFIG_ENABLE_MMU宏时有效，为链接文件，实际指向的文件为include/asm-arm/proc-armv/domain.h。
</code></pre> 
<p>#include &lt;regs.h&gt;</p> 
<p>regs.h头文件为链接文件，指向s5pc110.h头文件，s5pc110.h文件内部使用宏定义了有关SoC内部寄存器的大量信息。</p> 
<p>2、头校验信息的占位<br> #if defined(CONFIG_EVT1) &amp;&amp; !defined(CONFIG_FUSED)</p> 
<p>.word 0x2000</p> 
<p>.word 0x0</p> 
<p>.word 0x0</p> 
<p>.word 0x0</p> 
<p>#endif</p> 
<p>定义uboot程序开头的16字节校验头信息填充空间，头校验信息块内的值需要在后面写入。</p> 
<p>3、异常向量表的构建<br> .globl _start</p> 
<p>_start:</p> 
<p>b reset</p> 
<p>ldrpc, _undefined_instruction</p> 
<p>ldrpc, _software_interrupt</p> 
<p>ldrpc, _prefetch_abort</p> 
<p>ldrpc, _data_abort</p> 
<p>ldrpc, _not_used</p> 
<p>ldrpc, _irq</p> 
<p>ldrpc, _fiq</p> 
<pre><code>uboot程序的入口点实际是定义了异常向量表，异常向量表由SoC硬件实现，因此uboot在开机上电复位时需要跳转到reset执行。
</code></pre> 
<p>4、复位reset分析<br> SoC上电复位后运行的第一段代码就是reset。主要包括以下几部分：</p> 
<p>A、关闭IRQ、FIQ，并将处理器模式设置为SVC模式</p> 
<p>B、CPU关键寄存器的初始化cpu_init_crit：</p> 
<pre><code>关闭L2 cache

初始化L2 cache

开启L2 cache

关闭L1 cache

关闭MMU

读取OM启动引脚信息

确定从启动设备SD卡启动

设置SRAM中的栈为调用lowlevel_init做准备（lowlevel_init内部有嵌套调用）

调用lowlevel_init（主要初始化系统时钟、SDRAM初始化、串口初始化等）

设置开发板供电锁存

设置SDRAM中的栈

判断当前代码是否运行在SDRAM中，如果当前代码运行在SDRAM中，则跳过代码重定位。

判断启动方式，选择SD卡启动设备，跳转到mmcsd_boot

SD卡启动的准备工作，从SD卡拷贝uboot到SDRAM：movi_bl2_copy
</code></pre> 
<p>C、设置MMU，开启MMU</p> 
<p>D、通过对SDRAM整体使用规划，在SDRAM中合适的地方设置栈</p> 
<p>E、清除bss段，远跳转到start_armboot执行，BL1阶段执行完</p> 
<p>5、lowlevel_init分析<br> lowlevel_init位于\board\samsung\smdkc110\lowlevel_init.S中，主要功能如下：</p> 
<pre><code>A、检查复位状态，判断启动的方式
</code></pre> 
<p>根据复位状态选择复位启动的方式，处于低功耗状态时复位启动可以跳过后续多个步骤。</p> 
<pre><code>B、IO状态恢复

C、关闭看门狗

D、外部SRAM的GPIO初始化、外部SROM初始化

E、开发板供电锁存设置

F、判断当前代码是否运行在SDRAM，如果当前代码运行在SDRAM，说明目前从低功耗状态复位，可以跳过系统时钟初始化、串口初始化、SDRAM初始化等

G、初始化系统时钟：system_clock_init

H、初始化SDRAM内存：mem_ctrl_asm_init

I、初始化串口，打印出’O’：uart_asm_init

J、初始化trustzone：tzpc_init

K、初始化nand或onenand

L、检查复位状态

M、关闭ABB

N、串口打印出‘K’
</code></pre> 
<p>说明：”OK”是打印出的调试信息，如果打印出’O’则说明在串口初始化uart_asm_init前的所有代码是正确的。如果打印出”OK”则说明在开发板板级初始化lowlevel_init前的所有代码是正常工作的。</p> 
<p>system_clock_init、uart_asm_init、tzpc_init、nand_asm_init都位于lowlevel_init.S文件内，mem_ctrl_asm_init位于cpu\s5pc11x\s5pc110\cpu_init.S文件中。</p> 
<p>四、board.c文件分析<br> uboot在执行完BL1阶段后远跳转到start_armboot函数执行BL2，start_armboot函数位于lib_arm\board.c中。</p> 
<p>1、重要变量的说明<br> typedef int (init_fnc_t) (void);函数类型</p> 
<p>init_fnc_t **init_fnc_ptr;//二级函数指针</p> 
<p>#define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm (“r8”)</p> 
<p>DECLARE_GLOBAL_DATA_PTR定义了一个存储在寄存器r8中的指向gd_t类型全局变量的指针gd。</p> 
<p>全局变量结构体的定义：</p> 
<p>typedefstructglobal_data {<!-- --></p> 
<p>bd_t*bd;//boardinfo结构体信息，存放和开发板有关的信息</p> 
<p>unsigned longflags;//标志位</p> 
<p>unsigned longbaudrate;//串口通信波特率</p> 
<p>unsigned longhave_console;//控制台/* serial_init() was called */</p> 
<p>unsigned longreloc_off;//重定位偏移量/* Relocation Offset */</p> 
<p>unsigned longenv_addr;//环境变量结构体的地址/* Address of Environment struct */</p> 
<p>unsigned longenv_valid;//环境变量使用标志/* Checksum of Environment valid? */</p> 
<p>unsigned longfb_base;//fb基地址/* base address of frame buffer */</p> 
<p>#ifdef CONFIG_VFD</p> 
<p>unsigned charvfd_type;///* display type */</p> 
<p>#endif</p> 
<p>void**jt;//跳转表/* jump table */</p> 
<p>} gd_t;</p> 
<p>开发板信息结构体变量的定义：</p> 
<p>typedef struct bd_info {<!-- --></p> 
<pre><code>intbi_baudrate;//硬件串口波特率/* serial console baudrate */

unsigned longbi_ip_addr;//开发板IP地址/* IP Address */

unsigned charbi_enetaddr[6];//开发板网卡地址 /* Ethernet adress */

struct environment_s       *bi_env;//环境变量指针

ulong        bi_arch_number;//机器码/* unique id for this board */

ulong        bi_boot_params;//uboot启动参数/* where this board expects params */

struct/* RAM configuration */

{
</code></pre> 
<p>ulong start;</p> 
<p>ulong size;</p> 
<pre><code>}bi_dram[CONFIG_NR_DRAM_BANKS];//内存插条信息
</code></pre> 
<p>#ifdef CONFIG_HAS_ETH1</p> 
<pre><code>/* second onboard ethernet port */

unsigned char   bi_enet1addr[6];//第二块网卡的地址
</code></pre> 
<p>#endif</p> 
<p>} bd_t;</p> 
<p>2、uboot的内存规划<br> <img src="https://images2.imgbox.com/1a/03/zZ0HvRjx_o.png" alt="在这里插入图片描述"></p> 
<p>wKioL1drRfTyRHOGAADgnjy9DiE579.jpg</p> 
<pre><code>SDRAM_BASE被MMU映射在0xC0000000，CFG_UBOOT_BASE是0xC3E00000

在BL1段运行时，uboot镜像被拷贝到CFG_UBOOT_BASE开始的地址处。
</code></pre> 
<p>gd的地址：</p> 
<p>gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);</p> 
<p>bd的地址：</p> 
<p>gd-&gt;bd = (bd_t*)((char*)gd - sizeof(bd_t));</p> 
<p>3、start_armboot函数分析<br> start_armboot函数的主要功能如下：</p> 
<p>（1）、遍历调用函数指针数组init_sequence中的初始化函数</p> 
<p>依次遍历调用函数指针数组init_sequence中的函数，如果有函数执行出错，则执行hang函数，打印出”### ERROR ### Please RESET the board ###”，进入死循环。</p> 
<p>（2）、初始化uboot的堆管理器mem_malloc_init</p> 
<p>（3）、初始化SMDKV210的SD/MMC控制器mmc_initialize</p> 
<p>（4）、环境变量重定位env_relocate</p> 
<p>（5）、将环境变量中网卡地址赋值给全局变量的开发板变量</p> 
<p>（6）、开发板硬件设备的初始化devices_init</p> 
<p>（7）、跳转表jumptable_init</p> 
<p>（8）、控制台初始化console_init_r</p> 
<p>（9）、网卡芯片初始化eth_initialize</p> 
<p>（10）、uboot进入主循环main_loop</p> 
<p>void start_armboot (void)<br> {<!-- --><br> //全局数据变量指针gd占用r8。<br> DECLARE_GLOBAL_DATA_PTR;<br> /* 给全局数据变量gd安排空间*/<br> gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));<br> memset ((void*)gd, 0, sizeof (gd_t));<br> /* 给板子数据变量gd-&gt;bd安排空间*/<br> gd-&gt;bd = (bd_t*)((char*)gd - sizeof(bd_t));<br> memset (gd-&gt;bd, 0, sizeof (bd_t));<br> monitor_flash_len = _bss_start - _armboot_start;//u-boot长度。<br> /* 顺序执行init_sequence数组中的初始化函数 */<br> for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {<!-- --><br> if ((<em>init_fnc_ptr)() != 0) {<!-- --><br> hang ();<br> }<br> }<br> /</em> 初始化堆空间 <em>/<br> mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);<br> /</em> 重新定位环境变量， <em>/<br> env_relocate ();<br> /</em> 从环境变量中获取IP地址 <em>/<br> gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr (“ipaddr”);<br> /</em> 以太网接口MAC 地址 <em>/<br> devices_init (); /</em> 设备初始化 <em>/<br> jumptable_init (); //跳转表初始化<br> console_init_r (); /</em> 完整地初始化控制台设备 <em>/<br> enable_interrupts (); /</em> 使能中断处理 <em>/<br> /</em> 通过环境变量初始化 <em>/<br> if ((s = getenv (“loadaddr”)) != NULL) {<!-- --><br> load_addr = simple_strtoul (s, NULL, 16);<br> }<br> /</em> main_loop()循环不断执行 <em>/<br> for (;😉 {<!-- --><br> main_loop (); /</em> 主循环函数处理执行用户命令 – common/main.c */<br> }<br> }</p> 
<p>4、函数指针数组init_sequence<br> 函数指针数组init_sequence：</p> 
<p>init_fnc_t *init_sequence[] = {<!-- --></p> 
<p>cpu_init,//CPU架构的初始化，为空cpu\s5pc11x\cpu.c</p> 
<p>board_init,//开发板初始化board\samsung\smdkc110\smdkc110.c</p> 
<p>interrupt_init,//定时器timer4初始化cpu\s5pc11x\interrupts.c</p> 
<p>env_init,//环境变量初始化common\env_movi.c</p> 
<p>init_baudrate,//波特率设置lib_arm\board.c</p> 
<p>serial_init,//延时函数Ｃ，没有再次初始化串口cpu\s5pc11x\serial.c</p> 
<p>console_init_f,//控制台第一阶段初始化，控制台未初始化好common\console.c</p> 
<p>display_banner,//用串口发送uboot版本信息lib_arm\board.c</p> 
<p>#if defined(CONFIG_DISPLAY_CPUINFO)</p> 
<p>print_cpuinfo,//串口打印系统时钟信息cpu\s5pc11x\s5pc110\speed.c</p> 
<p>#endif</p> 
<p>#if defined(CONFIG_DISPLAY_BOARDINFO)</p> 
<p>checkboard,//打印开发板信Board:SMDKV210</p> 
<p>//board\samsung\smdkc110\smdkc110.c</p> 
<p>#endif</p> 
<p>#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)</p> 
<p>init_func_i2c,//SMDKV210未定义I2C，函数为空lib_arm\board.c</p> 
<p>#endif</p> 
<p>dram_init,//初始化gd-&gt;bd-&gt;bi_dram，开发板的SDRAM配置信息</p> 
<p>board\samsung\smdkc110\smdkc110.c</p> 
<p>display_dram_config,//串口打印出DRAM的大小信息，DRAM:xxxMB</p> 
<p>lib_arm\board.c</p> 
<p>NULL,</p> 
<p>};</p> 
<p>board_init函数：</p> 
<p>dm9000_pre_init();//网卡初始化，GPIO和端口设置</p> 
<p>gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE;//开发板的机器码，uboot的机器码和linux的机器码之间必须适配</p> 
<p>gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+0x100);//uboot给内核的传参地址</p> 
<p>display_banner函数：</p> 
<p>打印uboot版本信息：uboot-1.3.4</p> 
<p>print_cpuinfo函数：</p> 
<p>打印CPU时钟系统的时钟信息</p> 
<p>checkboard函数：</p> 
<p>打印出开发板信息Board: SMDKV210</p> 
<p>display_dram_config函数：</p> 
<p>打印出DRAM的大小信息，DRAM:xxxMB</p> 
<p>打印出的信息可以作为调试使用，依次遍历调用函数指针数组init_sequence中的函数，如果有函数执行出错，则执行hang函数，打印出”### ERROR ### Please RESET the board ###”，进入死循环。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c419f78556365e5527c865418e28f532/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常用排序算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04f630491ec1d8ec9dc75fe27c507471/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 判断元素是否在数组中_java中怎么判断某元素是否在数组中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>