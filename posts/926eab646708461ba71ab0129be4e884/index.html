<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【IMX6ULL驱动开发学习】06.DHT11温湿度传感器驱动程序编写与测试 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【IMX6ULL驱动开发学习】06.DHT11温湿度传感器驱动程序编写与测试" />
<meta property="og:description" content="目录
一、DHT11简介
1.1 DHT11模块硬件设计
1.2 DHT11模块软件设计
1.3 DHT11通讯协议
1.4 DHT11数据格式
二、相关代码
2.1 驱动代码
2.2 测试代码
2.3 上板子测试
一、DHT11简介 DHT11是一款可测量温度和湿度的传感器。比如市面上一些空气加湿器，会测量空气中湿度，再根据测量结果决定是否继续加湿。
DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器，具有超小体积、极低功耗的特点，使用单根总线与主机进行双向的串行数据传输。DHT11测量温度的精度为± 2℃，检测范围为-20℃ -60℃。湿度的精度为± 5%RH，检测范围为 5%RH-95%RH，常用于对精度和实时性要求不高的温湿度测量场合。
1.1 DHT11模块硬件设计 主机通过一条数据线与DH11连接，主机通过这条线发命令给DHT11，DHT11再通过这条线把数据发送给主机。
1.2 DHT11模块软件设计 DHT11的硬件电路比较简单，核心要点就是：主机发给DHT11的命令格式和DHT11返回的数据格式。
1.3 DHT11通讯协议 通讯过程如图所示：
当主机没有与 DHT11 通信时，总线处于空闲状态，此时总线电平由于上拉电阻的作用处于高电平。
当主机与 DHT11 正在通信时，总线处于通信状态，一次完整的通信过程如下：
a) 主机将对应的 GPIO 管脚配置为输出，准备向 DHT11 发送数据；
b）主机发送一个开始信号：开始信号 = 一个低脉冲 &#43; 一个高脉冲。低脉冲至少持续 18ms，高脉冲持续 20-40us。
c) 主机将对应的 GPIO 管脚配置为输入，准备接受 DHT11 传来的数据，这时信号由上拉电阻拉高；
d) DHT11 发出响应信号：响应信号 = 一个低脉冲 &#43; 一个高脉冲。低脉冲持续 80us，高脉冲持续 80us。
e) DHT11 发出数据信号：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/926eab646708461ba71ab0129be4e884/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-06T15:33:58+08:00" />
<meta property="article:modified_time" content="2023-09-06T15:33:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【IMX6ULL驱动开发学习】06.DHT11温湿度传感器驱动程序编写与测试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81DHT11%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81DHT11%E7%AE%80%E4%BB%8B" rel="nofollow">一、DHT11简介</a></p> 
<p id="1.1%20DHT11%E6%A8%A1%E5%9D%97%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#1.1%20DHT11%E6%A8%A1%E5%9D%97%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1" rel="nofollow">1.1 DHT11模块硬件设计</a></p> 
<p id="1.2%20DHT11%E6%A8%A1%E5%9D%97%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#1.2%20DHT11%E6%A8%A1%E5%9D%97%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1" rel="nofollow">1.2 DHT11模块软件设计</a></p> 
<p id="1.3%20DHT11%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-toc" style="margin-left:80px;"><a href="#1.3%20DHT11%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE" rel="nofollow">1.3 DHT11通讯协议</a></p> 
<p id="1.4%C2%A0DHT11%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.4%C2%A0DHT11%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F" rel="nofollow">1.4 DHT11数据格式</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81" rel="nofollow">二、相关代码</a></p> 
<p id="2.1%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#2.1%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81" rel="nofollow">2.1 驱动代码</a></p> 
<p id="2.2%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#2.2%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" rel="nofollow">2.2 测试代码</a></p> 
<p id="2.3%20%E4%B8%8A%E6%9D%BF%E5%AD%90%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.3%20%E4%B8%8A%E6%9D%BF%E5%AD%90%E6%B5%8B%E8%AF%95" rel="nofollow">2.3 上板子测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>一、DHT11简介</h3> 
<p>DHT11是一款可测量温度和湿度的传感器。比如市面上一些空气加湿器，会测量空气中湿度，再根据测量结果决定是否继续加湿。<br> DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器，具有超小体积、极低功耗的特点，使用单根总线与主机进行双向的串行数据传输。DHT11测量温度的精度为± 2℃，检测范围为-20℃ -60℃。湿度的精度为± 5%RH，检测范围为 5%RH-95%RH，常用于对精度和实时性要求不高的温湿度测量场合。</p> 
<h4 id="1.1%20DHT11%E6%A8%A1%E5%9D%97%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">1.1 DHT11模块硬件设计</h4> 
<p style="text-align:center;">主机通过一条数据线与DH11连接，主机通过这条线发命令给DHT11，DHT11再通过这条线把数据发送给主机。<br><img alt="" src="https://images2.imgbox.com/b3/1e/y71TeLgU_o.png"></p> 
<h4 id="1.2%20DHT11%E6%A8%A1%E5%9D%97%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">1.2 DHT11模块软件设计</h4> 
<p>DHT11的硬件电路比较简单，核心要点就是：主机发给DHT11的命令格式和DHT11返回的数据格式。</p> 
<h4 id="1.3%20DHT11%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE">1.3 DHT11通讯协议</h4> 
<p>通讯过程如图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/d9/SL6TUKNS_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/d3/3d/BX4sMmny_o.png"></p> 
<p>当主机没有与 DHT11 通信时，总线处于空闲状态，此时<span style="color:#fe2c24;"><strong>总线电平由于上拉电阻的作用处于高电平</strong></span>。</p> 
<p>当主机与 DHT11 正在通信时，总线处于通信状态，一次完整的通信过程如下：</p> 
<p>a) 主机将对应的 GPIO 管脚配置为输出，准备向 DHT11 发送数据；</p> 
<p>b）主机发送一个开始信号：开始信号 = 一个低脉冲 + 一个高脉冲。低脉冲至少持续 18ms，高脉冲持续 20-40us。</p> 
<p>c) 主机将对应的 GPIO 管脚配置为输入，准备接受 DHT11 传来的数据，这时信号由上拉电阻拉高；</p> 
<p>d) DHT11 发出响应信号：响应信号 = 一个低脉冲 + 一个高脉冲。低脉冲持续 80us，高脉冲持续 80us。<br> e) DHT11 发出数据信号：</p> 
<ul><li><strong><span style="color:#fe2c24;">数据为 0 的一位信号</span></strong> = 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续 26～28us。</li><li><strong><span style="color:#fe2c24;">数据为 1 的一位信号</span></strong> = 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续 70us。</li></ul> 
<p>f) DHT11 发出结束信号： 最后 1bit 数据传送完毕后， DHT11 拉低总线 50us，然后<span style="color:#fe2c24;"><strong>释放总线</strong></span>，总线由<strong><span style="color:#fe2c24;">上拉电阻拉高进入空闲状态</span></strong>。</p> 
<p><img alt="" class="left" height="165" src="https://images2.imgbox.com/f6/77/9cUpJWjk_o.png" width="353"><img alt="" height="181" src="https://images2.imgbox.com/2c/4e/u4GMwRf8_o.png" width="300"></p> 
<h4 id="1.4%C2%A0DHT11%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">1.4 DHT11数据格式</h4> 
<p><strong> 8bit 湿度整数数据 + 8bit 湿度小数数据 + 8bi 温度整数数据 + 8bit 温度小数数据 + 8bit 校验和</strong>。数据传送正确时,校验和等于“8bit 湿度整数数据+8bit 湿度小数数据+8bi温度整数数据+8bit 温度小数数据”所得结果的末 8 位。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">二、相关代码</h3> 
<h4 id="2.1%20%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81">2.1 驱动代码</h4> 
<pre><code class="language-objectivec">#include "asm-generic/errno-base.h"
#include "asm-generic/gpio.h"
#include "linux/jiffies.h"
#include &lt;linux/module.h&gt;
#include &lt;linux/poll.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/major.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/stat.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/tty.h&gt;
#include &lt;linux/kmod.h&gt;
#include &lt;linux/gfp.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/of_irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/fcntl.h&gt;
#include &lt;linux/timer.h&gt;

struct gpio_desc{
	int gpio;
	int irq;
    char *name;
    int key;
	struct timer_list key_timer;
} ;

static struct gpio_desc gpios[] = {
    {115, 0, "dht11", },
};

/* 主设备号                                                                 */
static int major = 0;
static struct class *gpio_class;

static u64 g_dht11_irq_time[84];
static int g_dht11_irq_cnt = 0;

/* 环形缓冲区 */
#define BUF_LEN 128
static char g_keys[BUF_LEN];
static int r, w;

struct fasync_struct *button_fasync;

static irqreturn_t dht11_isr(int irq, void *dev_id);
static void parse_dht11_datas(void);

#define NEXT_POS(x) ((x+1) % BUF_LEN)

static int is_key_buf_empty(void)
{
	return (r == w);
}

static int is_key_buf_full(void)
{
	return (r == NEXT_POS(w));
}

static void put_key(char key)
{
	if (!is_key_buf_full())
	{
		g_keys[w] = key;
		w = NEXT_POS(w);
	}
}

static char get_key(void)
{
	char key = 0;
	if (!is_key_buf_empty())
	{
		key = g_keys[r];
		r = NEXT_POS(r);
	}
	return key;
}


static DECLARE_WAIT_QUEUE_HEAD(gpio_wait);

// static void key_timer_expire(struct timer_list *t)
static void key_timer_expire(unsigned long data)
{
	// 解析数据, 放入环形buffer, 唤醒APP
	parse_dht11_datas();
}


/* 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t dht11_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	int err;
	char kern_buf[2];

	if (size != 2)
		return -EINVAL;

	g_dht11_irq_cnt = 0;

	/* 1. 发送18ms的低脉冲 */
	err = gpio_request(gpios[0].gpio, gpios[0].name);
	gpio_direction_output(gpios[0].gpio, 0);
	gpio_free(gpios[0].gpio);

	mdelay(18);
	/* 引脚变为输入方向, 由上拉电阻拉为1，*/
	/* 当主机没有与DHT11通信时，总线处于空闲状态，
	此时总线电平由于上拉电阻的作用处于高电平*/
	gpio_direction_input(gpios[0].gpio);  

	/* 2. 注册中断 后面的语句执行时可能会导致前几次的中断丢失*/
	err = request_irq(gpios[0].irq, dht11_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, gpios[0].name, &amp;gpios[0]);
	mod_timer(&amp;gpios[0].key_timer, jiffies + 10);修改定时器的超时时间= jiffies(当前时间) + 10	

	/* 3. 休眠等待数据 */
	//等待 条件为真（有数据时），才会被唤醒并执行后面语句
	wait_event_interruptible(gpio_wait, !is_key_buf_empty());

	free_irq(gpios[0].irq, &amp;gpios[0]);

	//printk("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);

	/* 设置DHT11 GPIO引脚的初始状态: output 1 保险起见手动设置高电平
	最后 1bit 数据传送完毕后， DHT11 拉低总线 50us，然后释放总线，总线由
    上拉电阻拉高进入空闲状态*/
	err = gpio_request(gpios[0].gpio, gpios[0].name);
	if (err)
	{
		printk("%s %s %d, gpio_request err\n", __FILE__, __FUNCTION__, __LINE__);
	}
	gpio_direction_output(gpios[0].gpio, 1);
	gpio_free(gpios[0].gpio);


	/* 4. copy_to_user */
	kern_buf[0] = get_key();
	kern_buf[1] = get_key();

	printk("get val : 0x%x, 0x%x\n", kern_buf[0], kern_buf[1]);
	if ((kern_buf[0] == (char)-1) &amp;&amp; (kern_buf[1] == (char)-1))
	{
		printk("get err val\n");
		return -EIO;
	}

	err = copy_to_user(buf, kern_buf, 2);
	
	return 2;
}

static int dht11_release (struct inode *inode, struct file *filp)
{
	return 0;
}


/* 定义自己的file_operations结构体                                              */
static struct file_operations dht11_drv = {
	.owner	 = THIS_MODULE,
	.read    = dht11_read,
	.release = dht11_release,
};

//解析数据
static void parse_dht11_datas(void)
{
	int i;
	u64 high_time;
	unsigned char data = 0;
	int bits = 0;
	unsigned char datas[5];//40位 5个字节
	int byte = 0;
	unsigned char crc;

	/* 中断发生次数: 可能是81、82、83、84 */
	if (g_dht11_irq_cnt &lt; 81)
	{
		/* 出错 */
		put_key(-1);
		put_key(-1);

		// 唤醒APP
		wake_up_interruptible(&amp;gpio_wait);
		g_dht11_irq_cnt = 0;
		return;
	}

	// 解析数据, 81、82、83、84 
	for (i = g_dht11_irq_cnt - 80; i &lt; g_dht11_irq_cnt; i += 2)
	{
		high_time = g_dht11_irq_time[i] - g_dht11_irq_time[i-1];//高脉冲时间

		data &lt;&lt;= 1;//左移一位

		//50us = 50000ns
		//如果数据是高电平
		if (high_time &gt; 50000) /* data 1 */
		{
			data |= 1;//或
		}

		bits++;

		if (bits == 8)
		{
			datas[byte] = data;
			data = 0;
			bits = 0;
			byte++;
		}
	}

	// 放入环形buffer
	crc = datas[0] + datas[1] + datas[2] + datas[3];
	if (crc == datas[4])
	{
		put_key(datas[0]);
		put_key(datas[2]);
	}
	else
	{
		put_key(-1);
		put_key(-1);
	}

	g_dht11_irq_cnt = 0;
	// 唤醒APP
	wake_up_interruptible(&amp;gpio_wait);
}

static irqreturn_t dht11_isr(int irq, void *dev_id)
{
	struct gpio_desc *gpio_desc = dev_id;
	u64 time;
	
	/* 1. 记录中断发生的时间 */
	time = ktime_get_ns();//单位ns 精准的到当前时间
	//static u64 g_dht11_irq_time[84]; static int g_dht11_irq_cnt = 0;
	g_dht11_irq_time[g_dht11_irq_cnt] = time;

	/* 2. 累计次数 */
	g_dht11_irq_cnt++;

	/* 3. 次数足够: 解析数据, 放入环形buffer, 唤醒APP */
	if (g_dht11_irq_cnt == 84)
	{
		del_timer(&amp;gpio_desc-&gt;key_timer);
		parse_dht11_datas();//解析数据
	}

	return IRQ_HANDLED;
}


/* 在入口函数 */
static int __init dht11_init(void)
{
    int err;
    int i;
    int count = sizeof(gpios)/sizeof(gpios[0]);//count = 1
    
	printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
	
	for (i = 0; i &lt; count; i++)
	{		
		gpios[i].irq  = gpio_to_irq(gpios[i].gpio);

		/* 设置DHT11 GPIO引脚的初始状态: output 1 */
		err = gpio_request(gpios[i].gpio, gpios[i].name); //申请gpio
		gpio_direction_output(gpios[i].gpio, 1);		  //输出方向，高电平
		gpio_free(gpios[i].gpio);						  //释放引脚

		//设置定时器：定时器结构体，定时器超时函数，传给超时函数的参数
		setup_timer(&amp;gpios[i].key_timer, key_timer_expire, (unsigned long)&amp;gpios[i]);
		//gpios[i].key_timer.expires = ~0;
		//add_timer(&amp;gpios[i].key_timer);
		//err = request_irq(gpios[i].irq, dht11_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, "100ask_gpio_key", &amp;gpios[i]);
	}

	/* 注册file_operations 	*/
	major = register_chrdev(0, "100ask_dht11", &amp;dht11_drv);  /* /dev/gpio_desc */

	gpio_class = class_create(THIS_MODULE, "100ask_dht11_class");
	if (IS_ERR(gpio_class)) {
		printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
		unregister_chrdev(major, "100ask_dht11");
		return PTR_ERR(gpio_class);
	}

	device_create(gpio_class, NULL, MKDEV(major, 0), NULL, "mydht11"); /* /dev/mydht11 */
	
	return err;
}

/* 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数*/
static void __exit dht11_exit(void)
{
    int i;
    int count = sizeof(gpios)/sizeof(gpios[0]);
    
	printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);

	device_destroy(gpio_class, MKDEV(major, 0));
	class_destroy(gpio_class);
	unregister_chrdev(major, "100ask_dht11");

	for (i = 0; i &lt; count; i++)
	{
		//free_irq(gpios[i].irq, &amp;gpios[i]);
		del_timer(&amp;gpios[i].key_timer);
	}
}


/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */

module_init(dht11_init);
module_exit(dht11_exit);

MODULE_LICENSE("GPL");


</code></pre> 
<h4 id="2.2%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">2.2 测试代码</h4> 
<pre><code class="language-objectivec">
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;poll.h&gt;
#include &lt;signal.h&gt;

static int fd;

/*
 * ./button_test /dev/mydht11
 *
 */
int main(int argc, char **argv)
{
	char buf[2];
	int ret;

	int i;
	
	/* 1. 判断参数 */
	if (argc != 2) 
	{
		printf("Usage: %s &lt;dev&gt;\n", argv[0]);
		return -1;
	}

	/* 2. 打开文件 */
	fd = open(argv[1], O_RDWR | O_NONBLOCK);
	if (fd == -1)
	{
		printf("can not open file %s\n", argv[1]);
		return -1;
	}

	while (1)
	{
		if (read(fd, buf, 2) == 2)
			printf("get Humidity: %d, Temperature : %d\n", buf[0], buf[1]);
		else
			printf("get dht11: -1\n");

		sleep(5);
	}
	close(fd);
	return 0;
}


</code></pre> 
<h4 id="2.3%20%E4%B8%8A%E6%9D%BF%E5%AD%90%E6%B5%8B%E8%AF%95">2.3 上板子测试</h4> 
<p>可以看到测到的温度和湿度数值都是正常的，但偶尔会测得失败的数据，这是因为在驱动程序里注册中断函数后，后面的语句执行花时间，可能会导致前几次的中断丢失。经测试如果中断发生次数小于81，则会测得错误数据；中断发生次数在81~84（含等于）就可测得准确数值。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/20/a4/BPhk5P0Y_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c44ba7482e31a95fa3c6ba271efc0c3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">教你用Python实现自动扫雷，你就是最亮的仔~</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da6df707717a852449e5e463c6e9f20c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">透明度百分比对应关系表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>