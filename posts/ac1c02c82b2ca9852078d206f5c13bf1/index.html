<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>H5网页获取公众号openid,access token,等用户信息 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="H5网页获取公众号openid,access token,等用户信息" />
<meta property="og:description" content="对接支付jsApi中需要获取到公众号下的用户openid (一个用户可以关注多个公众号,每个公众号下的用户openid是不一样的)
准备工作:
公众号信息配置好了以后就是前端请求,获取code
mounted() { var local = window.location.href; //当前路径，注意：路径必须是在公众号配置过的 var APPID = &#39;此为公众号的openId&#39;; //此为公众号的openId var APPSecret = &#39;此为公众号的secret&#39;; //此为公众号的secret var code = this.getUrlParam(&#39;code&#39;) //工具函数，获取code参数信息 if (code == &#34;&#34; || code == undefined || code == null) { console.log(&#39;code--1----&#39;, code); window.location.href = &#39;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#39; &#43; APPID &#43; &#39;&amp;secret=&#39; &#43; APPSecret &#43; &#39;&amp;redirect_uri=&#39; &#43; encodeURIComponent(local) &#43; &#39;&amp;response_type=code&amp;scope=snsapi_base&amp;state=#wechat_redirect&#39; } else { console.log(&#39;code--2----&#39;, code); //获取到的话，通过后台接口获取到openId,此接口必须放在后台，不然微信返回异常 uni.request({ url: &#39;https://wxh5pay.diqwl.com/wxPay/getOpenId&#39;, method: &#39;post&#39;, data: { code:code }, header: { &#39;content-type&#39;: &#39;application/x-www-form-urlencoded; charset=UTF-8&#39; //重点 }, success(res) { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ac1c02c82b2ca9852078d206f5c13bf1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T14:44:46+08:00" />
<meta property="article:modified_time" content="2023-07-18T14:44:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">H5网页获取公众号openid,access token,等用户信息</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>对接支付jsApi中需要获取到公众号下的用户openid</h3> 
<p>(一个用户可以关注多个公众号,每个公众号下的用户openid是不一样的)</p> 
<p></p> 
<p>准备工作:</p> 
<p><img alt="" height="736" src="https://images2.imgbox.com/6a/ea/WvNMqrWI_o.png" width="1200"></p> 
<p> <img alt="" height="559" src="https://images2.imgbox.com/4a/21/Qb5pjIyR_o.png" width="1200"></p> 
<p>公众号信息配置好了以后就是前端请求,获取code</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/36/bc/iNTiaDmi_o.png" width="1047"></p> 
<pre><code class="language-javascript">
		mounted() {
			var local = window.location.href; //当前路径，注意：路径必须是在公众号配置过的
			var APPID = '此为公众号的openId'; //此为公众号的openId
			var APPSecret = '此为公众号的secret'; //此为公众号的secret
			var code = this.getUrlParam('code') //工具函数，获取code参数信息
			if (code == "" || code == undefined || code == null) {
				console.log('code--1----', code);
				window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=' + APPID +
					'&amp;secret=' + APPSecret +
					'&amp;redirect_uri=' + encodeURIComponent(local) +
					'&amp;response_type=code&amp;scope=snsapi_base&amp;state=#wechat_redirect'
			} else {
				console.log('code--2----', code);
				//获取到的话，通过后台接口获取到openId,此接口必须放在后台，不然微信返回异常
				uni.request({
					url: 'https://wxh5pay.diqwl.com/wxPay/getOpenId',
					method: 'post',
					data: {
						code:code
					},
					header: {
						'content-type': 'application/x-www-form-urlencoded; charset=UTF-8' //重点
					},
					success(res) {
						console.log("res----", res);
						this.openid = res.data.openid
					}
				})
				
			}
		},

		methods: {
			getUrlParam(name) {
				var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)");
				var r = (window.location.search).substr(1).match(reg);
				if (r != null) return unescape(r[2]);
				return null;
			},
}</code></pre> 
<p> 获取到code后传给后端,后端请求</p> 
<pre>https://api.weixin.qq.com/sns/oauth2/access_token获得openid</pre> 
<p>先在xml文件中添加</p> 
<pre><code class="language-java">
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<pre><code class="language-java">@ApiOperation("获取openid")
    @PostMapping("/getOpenId")
    public String getOpenId(String code) throws Exception {
        String url = "https://api.weixin.qq.com/sns/oauth2/access_token";
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        // 微信公众号
        String appid = PayConstants.APP_ID;
        // 微信公众号
        String secret = PayConstants.APP_SECRET;
        // 微信公众号
        String grant_type = "authorization_code";
        map.put("appid",appid);
        map.put("secret",secret);
        map.put("code",code);
        map.put("grant_type",grant_type);
        String result = HttpClientUtil.doGetAndHeader(url,map,"token",null);
        System.out.println(result);
        return result;
    }</code></pre> 
<p> 第三方请求封装</p> 
<pre><code class="language-java">package com.example.dqh5pay.util;


import com.alibaba.fastjson.JSON;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.*;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * 封装HttpClient常用方法
 *
 */
public class HttpClientUtil {

    //设置连接超时时间，单位毫秒。
    public final static int CONNECT_TIMEOUT = 30000;
    //设置从connect Manager获取Connection 超时时间，单位毫秒。这个属性是新加的属性，因为目前版本是可以共享连接池的。
    public final static int CONNECT_REQUEST_TIMEOUT = 10000;
    //请求获取数据的超时时间，单位毫秒。 如果访问一个接口，多少时间内无法返回数据，就直接放弃此次调用。
    public final static int SOCKET_TIMEOUT = 30000;

    /**
     * 不带参数的get 表单形式
     *
     * @param uri
     * @return
     * @throws Exception
     */
    public static String doGet(String uri) throws Exception {
        return doGet(uri, null);
    }
    /**
     * 1.带参数的get请求 body形式
     * 2.添加请求头header参数token
     * 3.设置超时时长
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static String doGetAndHeader(String url, Map&lt;String, Object&gt; map, String tokenK, String tokenV) throws Exception {
        // 1.创建URIBuilder
        URIBuilder uriBuilder = new URIBuilder(url);

        // 2.设置请求参数
        if (map != null) {
            // 遍历请求参数
            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
                // 封装请求参数
                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());
            }
        }
        // 3.创建请求对象httpGet
        HttpGet httpGet = new HttpGet(uriBuilder.build());
        /*
         * 添加请求头信息
         */
        // 浏览器表示
        httpGet.addHeader("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)");
        // 传输的类型
        httpGet.addHeader("Content-Type", "application/x-www-form-urlencoded");
        //在请求头header中添加token参数
        httpGet.addHeader(tokenK, tokenV);

        // 3. 使用Httpclient发起请求
        CloseableHttpClient httpclient = HttpClients.createDefault();
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectTimeout(CONNECT_TIMEOUT)//设置连接超时时间，单位毫秒。
                .setConnectionRequestTimeout(CONNECT_REQUEST_TIMEOUT)//设置从connect Manager获取Connection 超时时间，单位毫秒。这个属性是新加的属性，因为目前版本是可以共享连接池的。
                .setSocketTimeout(SOCKET_TIMEOUT)//请求获取数据的超时时间，单位毫秒。 如果访问一个接口，多少时间内无法返回数据，就直接放弃此次调用。
                .build();
        httpGet.setConfig(requestConfig);
        CloseableHttpResponse response = httpclient.execute(httpGet);

        // 4. 解析返回数据，封装HttpResult
        // 4.1状态码
        int code = response.getStatusLine().getStatusCode();
        // 4.2 响应体内容
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }

//        HttpResult result = new HttpResult();
//        result.setCode(code);
//        result.setBody(body);
        return body;
    }
    /**
     * 带参数的get请求 表单形式
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static String doGet(String url, Map&lt;String, Object&gt; map) throws Exception {
        // 1.创建URIBuilder
        URIBuilder uriBuilder = new URIBuilder(url);

        // 2.设置请求参数
        if (map != null) {
            // 遍历请求参数
            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
                // 封装请求参数
                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());
            }
        }

        // 3.创建请求对象httpGet
        HttpGet httpGet = new HttpGet(uriBuilder.build());
        // 4.使用httpClient发起请求
        CloseableHttpResponse response = HttpClients.createDefault().execute(httpGet);

        // 5.解析返回结果，封装返回对象httpResult
        // 5.1获取状态码
        int code = response.getStatusLine().getStatusCode();

        // 5.2 获取响应体
        // 使用EntityUtils.toString方法必须保证entity不为空
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }
        return body;
    }

    /**
     * 不带参数的post请求 表单形式
     *
     * @param url
     * @return
     */
    public static HttpResult doPost(String url) throws Exception {
        return doPost(url, null);
    }

    /**
     * 带参数的post请求 表单形式
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static HttpResult doPost(String url, Map&lt;String, Object&gt; map) throws Exception {
        // 1. 声明httppost
        HttpPost httpPost = new HttpPost(url);

        // 2.封装请求参数，请求数据是表单
        // 声明封装表单数据的容器
        List&lt;NameValuePair&gt; parameters = new ArrayList&lt;NameValuePair&gt;(0);
        if (map != null) {

            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
                // 封装请求参数到容器中
                parameters.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));
            }
        }
        // 创建表单的Entity类
        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(parameters, "UTF-8");

        // 3. 把封装好的表单实体对象设置到HttpPost中
        httpPost.setEntity(entity);

        // 4. 使用Httpclient发起请求
        CloseableHttpResponse response = HttpClients.createDefault().execute(httpPost);

        // 5. 解析返回数据，封装HttpResult
        // 5.1状态码
        int code = response.getStatusLine().getStatusCode();
        // 5.2 响应体内容
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }

        HttpResult result = new HttpResult();
        result.setCode(code);
        result.setBody(body);
        return result;
    }

    /**
     * 1.带参数的post请求 body形式
     * 2.添加请求头header参数token
     * 3.设置超时时长
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static HttpResult doPostAndHeader(String url, Map&lt;String, Object&gt; map, String tokenK, String tokenV) throws Exception {
        // 1. 声明httppost
        HttpPost httpPost = new HttpPost(url);

        //2. 把body参数设置到HttpPost中
        httpPost.setEntity(new StringEntity(JSON.toJSONString(map)));
        /*
         * 添加请求头信息
         */
        // 浏览器表示
        httpPost.addHeader("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)");
        // 传输的类型
        httpPost.addHeader("Content-Type", "application/x-www-form-urlencoded");
        //在请求头header中添加token参数
        httpPost.addHeader(tokenK, tokenV);

        // 3. 使用Httpclient发起请求
        CloseableHttpClient httpclient = HttpClients.createDefault();
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectTimeout(CONNECT_TIMEOUT)//设置连接超时时间，单位毫秒。
                .setConnectionRequestTimeout(CONNECT_REQUEST_TIMEOUT)//设置从connect Manager获取Connection 超时时间，单位毫秒。这个属性是新加的属性，因为目前版本是可以共享连接池的。
                .setSocketTimeout(SOCKET_TIMEOUT)//请求获取数据的超时时间，单位毫秒。 如果访问一个接口，多少时间内无法返回数据，就直接放弃此次调用。
                .build();
        httpPost.setConfig(requestConfig);
        CloseableHttpResponse response = httpclient.execute(httpPost);

        // 4. 解析返回数据，封装HttpResult
        // 4.1状态码
        int code = response.getStatusLine().getStatusCode();
        // 4.2 响应体内容
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }

        HttpResult result = new HttpResult();
        result.setCode(code);
        result.setBody(body);
        return result;
    }

    /**
     * 不带参数的put请求 表单形式
     *
     * @param url
     * @return
     */
    public static HttpResult doPut(String url) throws Exception {
        return doPut(url, null);
    }

    /**
     * 带参数的put请求 表单形式
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static HttpResult doPut(String url, Map&lt;String, Object&gt; map) throws Exception {
        // 1. 声明httpput
        HttpPut httpPut = new HttpPut(url);

        // 2.封装请求参数，请求数据是表单
        if (map != null) {
            // 声明封装表单数据的容器
            List&lt;NameValuePair&gt; parameters = new ArrayList&lt;NameValuePair&gt;();
            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
                // 封装请求参数到容器中
                parameters.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));
            }

            // 创建表单的Entity类
            UrlEncodedFormEntity entity = new UrlEncodedFormEntity(parameters, "UTF-8");

            // 3. 把封装好的表单实体对象设置到HttpPost中
            httpPut.setEntity(entity);
        }
        // 4. 使用Httpclient发起请求
        CloseableHttpResponse response = HttpClients.createDefault().execute(httpPut);

        // 5. 解析返回数据，封装HttpResult
        // 5.1状态码
        int code = response.getStatusLine().getStatusCode();
        // 5.2 响应体内容
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }

        HttpResult result = new HttpResult();
        result.setCode(code);
        result.setBody(body);
        return result;
    }

    /**
     * 不带参数的delete 表单形式
     *
     * @param uri
     * @return
     * @throws Exception
     */
    public static HttpResult doDelete(String uri) throws Exception {
        return doDelete(uri, null);
    }

    /**
     * 带参数的delete 表单形式
     *
     * @param url
     * @param map
     * @return
     * @throws Exception
     */
    public static HttpResult doDelete(String url, Map&lt;String, Object&gt; map) throws Exception {
        // 1.创建URIBuilder
        URIBuilder uriBuilder = new URIBuilder(url);

        // 2.设置请求参数
        if (map != null) {
            // 遍历请求参数
            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
                // 封装请求参数
                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());
            }
        }

        // 3.创建请求对象httpGet
        HttpDelete httpDelete = new HttpDelete(uriBuilder.build());

        // 4.使用httpClient发起请求
        CloseableHttpResponse response = HttpClients.createDefault().execute(httpDelete);

        // 5.解析返回结果，封装返回对象httpResult
        // 5.1获取状态码
        int code = response.getStatusLine().getStatusCode();

        // 5.2 获取响应体
        // 使用EntityUtils.toString方法必须保证entity不为空
        String body = null;
        if (response.getEntity() != null) {
            body = EntityUtils.toString(response.getEntity(), "UTF-8");
        }
        HttpResult result = new HttpResult();
        result.setCode(code);
        result.setBody(body);
        return result;
    }
}</code></pre> 
<p>请求成功:</p> 
<p><img alt="" height="617" src="https://images2.imgbox.com/e3/09/H91ULOUt_o.png" width="389"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96bc09a667a24f71519e243d1b87b01f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">完整的电商平台后端API开发总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/090de7bf4fa9d47edc01ff334b1f71d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenVas扫描器更新扫描引擎</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>