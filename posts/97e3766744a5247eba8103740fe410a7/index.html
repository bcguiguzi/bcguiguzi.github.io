<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMVC框架面试专题（初级-中级）-第五节 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMVC框架面试专题（初级-中级）-第五节" />
<meta property="og:description" content="欢迎大家一起探讨～如果可以帮到大家请为我点赞关注哦～后续会持续更新
问题：
1.Spring MVC框架中的消息转换器是什么？请举例说明如何使用消息转换器。
解析：
Spring MVC框架中的消息转换器是一种用于将HTTP请求和响应中的消息转换为Java对象的机制。当Spring MVC控制器处理请求时，它会根据请求的Content-Type（请求体的格式）和Accept（响应体的格式）头来选择适当的消息转换器。消息转换器将请求或响应中的消息转换为Java对象，使得在控制器中处理数据更加方便。
以下是一个使用Spring MVC框架中的消息转换器的示例：
@PostMapping(&#34;/createUser&#34;) public void createUser(@RequestBody User user) { // code to create user } 在上面的代码中，我们通过使用@RequestBody注解来告诉Spring MVC框架使用消息转换器将请求的消息转换为User对象。如果请求的Content-Type头是application/json，则Spring MVC框架将使用JSON消息转换器来将请求的消息转换为User对象。
另外，Spring MVC框架还提供了许多内置的消息转换器，例如：
StringHttpMessageConverter：将字符串转换为HTTP请求或响应的消息体。
-MappingJackson2HttpMessageConverter：将JSON数据转换为Java对象，或将Java对象转换为JSON数据。FormHttpMessageConverter：将表单数据转换为Java对象。ByteArrayHttpMessageConverter：将字节数组转换为HTTP请求或响应的消息体。 要自定义消息转换器，我们可以创建一个实现HttpMessageConverter接口的类，并在Spring MVC配置文件中进行配置。例如，以下代码演示了如何配置一个自定义的消息转换器来将XML数据转换为Java对象：
@Configuration public class AppConfig { @Bean public HttpMessageConverter&lt;Object&gt; xmlConverter() { MarshallingHttpMessageConverter converter = new MarshallingHttpMessageConverter(); XStreamMarshaller marshaller = new XStreamMarshaller(); converter.setMarshaller(marshaller); converter.setUnmarshaller(marshaller); converter.setSupportedMediaTypes(Collections.singletonList(MediaType.APPLICATION_XML)); return converter; } @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { converters.add(xmlConverter()); super.configureMessageConverters(converters); } } 在上面的代码中，我们创建了一个MarshallingHttpMessageConverter实例，并将其配置为使用XStreamMarshaller来进行XML数据转换。然后，我们将该消息转换器添加到Spring MVC配置文件中的configureMessageConverters方法中，以便在控制器中使用它来处理请求和响应。在这个例子中，我们指定了MediaType." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/97e3766744a5247eba8103740fe410a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-26T22:09:42+08:00" />
<meta property="article:modified_time" content="2023-05-26T22:09:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMVC框架面试专题（初级-中级）-第五节</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>欢迎大家一起探讨～如果可以帮到大家请为我点赞关注哦～后续会持续更新</p> 
<p>问题：</p> 
<p><span style="color:#fe2c24;"><strong>1.Spring MVC框架中的消息转换器是什么？请举例说明如何使用消息转换器。</strong></span></p> 
<p>解析：</p> 
<p>Spring MVC框架中的消息转换器是一种用于将HTTP请求和响应中的消息转换为Java对象的机制。当Spring MVC控制器处理请求时，它会根据请求的Content-Type（请求体的格式）和Accept（响应体的格式）头来选择适当的消息转换器。消息转换器将请求或响应中的消息转换为Java对象，使得在控制器中处理数据更加方便。</p> 
<p>以下是一个使用Spring MVC框架中的消息转换器的示例：</p> 
<pre><code class="language-java">@PostMapping("/createUser")
public void createUser(@RequestBody User user) {
    // code to create user
}</code></pre> 
<p>在上面的代码中，我们通过使用<code>@RequestBody</code>注解来告诉Spring MVC框架使用消息转换器将请求的消息转换为<code>User</code>对象。如果请求的Content-Type头是<code>application/json</code>，则Spring MVC框架将使用JSON消息转换器来将请求的消息转换为<code>User</code>对象。</p> 
<p>另外，Spring MVC框架还提供了许多内置的消息转换器，例如：</p> 
<ul><li><code>StringHttpMessageConverter</code>：将字符串转换为HTTP请求或响应的消息体。<br> -<code>MappingJackson2HttpMessageConverter</code>：将JSON数据转换为Java对象，或将Java对象转换为JSON数据。</li><li><code>FormHttpMessageConverter</code>：将表单数据转换为Java对象。</li><li><code>ByteArrayHttpMessageConverter</code>：将字节数组转换为HTTP请求或响应的消息体。</li></ul> 
<p>要自定义消息转换器，我们可以创建一个实现<code>HttpMessageConverter</code>接口的类，并在Spring MVC配置文件中进行配置。例如，以下代码演示了如何配置一个自定义的消息转换器来将XML数据转换为Java对象：</p> 
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public HttpMessageConverter&lt;Object&gt; xmlConverter() {
        MarshallingHttpMessageConverter converter = new MarshallingHttpMessageConverter();
        XStreamMarshaller marshaller = new XStreamMarshaller();
        converter.setMarshaller(marshaller);
        converter.setUnmarshaller(marshaller);
        converter.setSupportedMediaTypes(Collections.singletonList(MediaType.APPLICATION_XML));
        return converter;
    }

    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        converters.add(xmlConverter());
        super.configureMessageConverters(converters);
    }

}</code></pre> 
<p>在上面的代码中，我们创建了一个<code>MarshallingHttpMessageConverter</code>实例，并将其配置为使用<code>XStreamMarshaller</code>来进行XML数据转换。然后，我们将该消息转换器添加到Spring MVC配置文件中的<code>configureMessageConverters</code>方法中，以便在控制器中使用它来处理请求和响应。在这个例子中，我们指定了<code>MediaType.APPLICATION_XML</code>作为该消息转换器支持的媒体类型，这意味着当请求或响应的Content-Type头为<code>application/xml</code>时，Spring MVC框架将使用该消息转换器来进行数据转换。</p> 
<p>总之，Spring MVC框架中的消息转换器是一种非常有用的机制，可以帮助开发人员轻松地处理HTTP请求和响应中的数据。通过使用内置的消息转换器或自定义的消息转换器，我们可以轻松地将请求和响应中的消息转换为Java对象，从而更加方便地处理数据。</p> 
<p></p> 
<p>问题：</p> 
<p><span style="color:#fe2c24;"><strong>2.Spring MVC框架中的Bean Validation是什么？请举例说明如何使用Bean Validation。</strong></span></p> 
<p>解析：</p> 
<p>Spring MVC框架中的Bean Validation是一种验证框架，用于验证JavaBean的属性是否符合规范。Bean Validation框架基于JSR-303规范，提供了一组注解和接口，可以用于验证JavaBean中的属性是否符合规范。通过使用Bean Validation框架，我们可以避免在控制器中编写冗长的验证代码，从而使代码更加简洁和易于维护。</p> 
<p>以下是一个使用Bean Validation框架的示例：</p> 
<pre><code class="language-java">public class User {

    @NotNull
    private String name;

    @Email
    private String email;

    @Min(18)
    private int age;

    // getters and setters
}</code></pre> 
<p>在上面的代码中，我们定义了一个<code>User</code>类，并使用Bean Validation框架提供的注解来验证该类的属性。具体来说，我们使用了<code>@NotNull</code>注解来验证<code>name</code>属性是否为<code>null</code>，使用<code>@Email</code>注解来验证<code>email</code>属性是否为有效的电子邮件地址，使用<code>@Min</code>注解来验证<code>age</code>属性是否大于或等于18岁。</p> 
<p>在控制器中，我们可以通过使用<code>@Valid</code>注解来启用Bean Validation框架的验证功能，如下所示：</p> 
<pre><code class="language-java">@PostMapping("/createUser")
public void createUser(@Valid @RequestBody User user) {
    // code to create user
}</code></pre> 
<p>在上面的代码中，我们使用<code>@Valid</code>注解来告诉Spring MVC框架对请求体中的<code>User</code>对象进行验证。如果<code>User</code>对象的属性不符合规范，则Spring MVC框架将抛出<code>MethodArgumentNotValidException</code>异常。</p> 
<p>另外，Bean Validation框架还提供了许多其他的注解和接口，用于验证JavaBean的属性。例如：</p> 
<ul><li><code>@NotBlank</code>：验证字符串是否非空。</li><li><code>@Size</code>：验证字符串、集合或数组的长度是否在指定的范围内。</li><li><code>@Pattern</code>：验证字符串是否符合指定的正则表达式。</li><li><code>@AssertTrue</code>：验证属性是否为<code>true</code>。</li><li><code>@AssertFalse</code>：验证属性是否为<code>false</code>。</li></ul> 
<p>要自定义验证规则，我们可以创建一个实现<code>ConstraintValidator</code>接口的类，并在注解中使用该类来进行验证。例如，以下代码演示了如何创建一个自定义注解来验证电子邮件地址是否包含指定的域名：</p> 
<pre><code class="language-java">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
public @interface EmailDomain {

    String message() default "Email address must contain specified domain";

    String domain() default "example.com";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
}</code></pre> 
<p>在上面的代码中，我们创建了一个<code>EmailDomain</code>注解，并使用<code>@Constraint</code>注解将其绑定到一个<code>EmailValidator</code>类上。该类实现了<code>ConstraintValidator</code>接口，用于验证电子邮件地址是否包含指定的域名。然后，我们在控制器中使用该注解来验证<code>User</code>类的<code>email</code>属性：</p> 
<pre><code class="language-java">public class User {

    @EmailDomain
    private String email;

    // getters and setters
}

@PostMapping("/createUser")
public void createUser(@Valid @RequestBody User user) {
    // code to create user
}</code></pre> 
<p>在上面的代码中，我们在<code>User</code>类的<code>email</code>属性上使用了<code>@EmailDomain</code>注解来验证电子邮件地址是否包含指定的域名。如果<code>email</code>属性中的域名不是<code>example.com</code>，则Spring MVC框架将抛出<code>MethodArgumentNotValidException</code>异常。</p> 
<p>总之，Spring MVC框架中的Bean Validation提供了一种方便的方式来验证JavaBean的属性是否符合规范。通过使用内置的注解或自定义的注解，我们可以轻松地对JavaBean的属性进行验证，从而避免在控制器中编写冗长的验证代码。</p> 
<p></p> 
<p>问题：</p> 
<p><span style="color:#fe2c24;"><strong>3.Spring MVC框架中的AOP支持是什么？请举例说明如何使用AOP支持。</strong></span></p> 
<p>解析：</p> 
<p>Spring MVC框架中的AOP（面向切面编程）支持是一种用于增强Java类的功能的机制。通过使用AOP，我们可以在不修改原始类代码的情况下，向类添加新的行为，例如日志记录、性能监控、安全检查等。Spring MVC框架中的AOP支持基于AspectJ框架，提供了一个灵活的、可扩展的AOP实现。</p> 
<p>以下是一个使用Spring MVC框架中的AOP支持的示例：</p> 
<pre><code class="language-java">@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.controller.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        System.out.println("Before executing " + className + "." + methodName + "()");
    }

    @AfterReturning(pointcut = "execution(* com.example.controller.*.*(..))", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        System.out.println("After executing " + className + "." + methodName +"(), result: " + result);
    }

}</code></pre> 
<p>在上面的代码中，我们创建了一个名为<code>LoggingAspect</code>的切面，用于向Spring MVC控制器添加日志记录功能。具体来说，我们在切面中定义了两个通知方法，一个是<code>logBefore</code>方法，用于在目标方法执行前记录日志；另一个是<code>logAfterReturning</code>方法，用于在目标方法执行后记录日志。在这两个方法中，我们使用AspectJ注解来定义切点表达式，指定应该在哪些目标方法上应用通知。</p> 
<p>要使用AOP支持，我们需要在Spring MVC配置文件中配置<code>@EnableAspectJAutoProxy</code>注解，如下所示：</p> 
<pre><code class="language-java">@Configuration
@EnableWebMvc
@EnableAspectJAutoProxy
@ComponentScan("com.example")
public class AppConfig {

    // configuration code

}</code></pre> 
<p>在上面的代码中，我们在配置类上使用<code>@EnableAspectJAutoProxy</code>注解来启用AspectJ自动代理支持。这将使Spring MVC框架能够自动创建代理对象，并在运行时应用切面。</p> 
<p>在控制器中，我们可以像平常一样编写控制器方法，而AOP框架将会自动应用切面。例如：</p> 
<pre><code class="language-java">@Controller
public class UserController {

    @PostMapping("/createUser")
    public String createUser(@RequestBody User user) {
        // code to create user
        return "success";
    }

}</code></pre> 
<p>在上面的代码中，当<code>createUser</code>方法被调用时，AOP框架将会在方法执行前后自动调用<code>LoggingAspect</code>切面中定义的通知方法，从而记录日志信息。</p> 
<p>另外，Spring MVC框架还提供了许多其他的AOP支持，例如：</p> 
<ul><li><code>@Around</code>注解：用于在目标方法执行前后进行一些操作。</li><li><code>@AfterThrowing</code>注解：用于在目标方法抛出异常时进行一些操作。</li><li><code>@Pointcut</code>注解：用于定义一个切点，可以在多个通知中共享使用。</li></ul> 
<p>总之，Spring MVC框架中的AOP支持是一种非常强大的机制，可以帮助开发人员在不修改原始类代码的情况下，向类添加新的行为。通过使用AspectJ注解和<code>@EnableAspectJAutoProxy</code>注解，我们可以轻松地将切面应用到Spring MVC控制器中，从而实现日志记录、性能监控、安全检查等功能。</p> 
<p></p> 
<p>问题：</p> 
<p><span style="color:#fe2c24;"><strong>4.Spring MVC框架中的跨域资源共享（CORS）是什么？请举例说明如何实现CORS。</strong></span></p> 
<p>解析：</p> 
<p>Spring MVC框架中的跨域资源共享（CORS）是一种机制，用于在不同域之间共享资源。当使用CORS机制时，浏览器将在发送跨域请求时自动在请求头中添加<code>Origin</code>字段，并在响应头中添加<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等字段，从而允许不同域之间的资源共享。</p> 
<p>以下是一个使用Spring MVC框架中的CORS的示例：</p> 
<pre><code class="language-java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://example.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("Content-Type")
                .maxAge(3600);
    }

}</code></pre> 
<p>在上面的代码中，我们创建了一个<code>WebConfig</code>类，并实现了<code>WebMvcConfigurer</code>接口。然后，我们在<code>addCorsMappings()</code>方法中使用<code>CorsRegistry</code>类来配置CORS规则。具体来说，我们在<code>/api/**</code>路径上启用了CORS支持，并设置了允许的来源、方法和头信息，以及缓存的最大时间。</p> 
<p>在控制器中，我们可以像平常一样编写控制器方法，并使用<code>@CrossOrigin</code>注解来配置CORS规则。例如：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    @CrossOrigin(origins = "http://example.com")
    public List&lt;User&gt; getUsers() {
        return userService.getUsers();
    }

    @PostMapping
    @CrossOrigin(origins = "http://example.com", methods = RequestMethod.POST)
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }

}</code></pre> 
<p>在上面的代码中，我们在<code>getUser()</code>方法上使用了<code>@CrossOrigin</code>注解，以允许来自<code>http://example.com</code>域的请求访问该方法。在<code>createUser()</code>方法上，我们还使用了<code>methods</code>属性来指定只允许POST方法访问该方法。这些注解将自动将CORS规则应用于控制器方法。</p> 
<p>除了使用<code>@CrossOrigin</code>注解外，还可以在控制器方法中使用<code>HttpServletResponse</code>对象来设置响应头中的CORS字段。例如：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List&lt;User&gt; getUsers(HttpServletResponse response) {
        response.setHeader("Access-Control-Allow-Origin", "http://example.com");
        response.setHeader("Access-Control-Allow-Methods", "GET");
        response.setHeader("Access-Control-Allow-Headers", "Content-Type");
        response.setHeader("Access-Control-Max-Age", "3600");
        return userService.getUsers();
    }

    @PostMapping
    public User createUser(@RequestBody User user, HttpServletResponse response) {
        response.setHeader("Access-Control-Allow-Origin", "http://example.com");
        response.setHeader("Access-Control-Allow-Methods", "POST");
        response.setHeader("Access-Control-Allow-Headers", "Content-Type");
        response.setHeader("Access-Control-Max-Age", "3600");
        return userService.createUser(user);
    }

}</code></pre> 
<p>在上面的代码中，我们在控制器方法中使用<code>HttpServletResponse</code>对象来设置响应头中的CORS字段。这些字段与在<code>WebConfig</code>类中使用<code>CorsRegistry</code>类配置的字段是相同的，但需要手动设置。</p> 
<p>总之，Spring MVC框架中的CORS支持是一种非常有用的机制，可以帮助我们在不同域之间共享资源。通过在<code>WebConfig</code>类中使用<code>CorsRegistry</code>类或在控制器方法上使用<code>@CrossOrigin</code>注解或<code>HttpServletResponse</code>对象，我们可以轻松地配置CORS规则，从而实现跨域资源共享。</p> 
<p></p> 
<p>问题：</p> 
<p><span style="color:#fe2c24;"><strong>5.Spring MVC框架中的Swagger是什么？请举例说明如何使用Swagger。</strong></span></p> 
<p>解析：</p> 
<p>Spring MVC框架中的Swagger是一种开源的API文档工具，可以帮助开发人员自动生成、测试和文档化RESTful API。使用Swagger，我们可以轻松地创建、维护和更新API文档，使我们的API更易于理解和使用。</p> 
<p>以下是一个使用Spring MVC框架中的Swagger的示例：</p> 
<p>首先，我们需要在Maven中添加以下依赖项：</p> 
<pre><code class="language-XML">&lt;!-- Swagger2依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
    &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Swagger UI依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
    &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>然后，我们需要创建一个<code>SwaggerConfig</code>类，用于配置Swagger：</p> 
<pre><code class="language-java">@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.example.controller"))
                .paths(PathSelectors.any())
                .build()
                .apiInfo(apiInfo());
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("My API")
                .description("API for My Application")
                .version("1.0")
                .build();
    }
}</code></pre> 
<p>在上面的代码中，我们创建了一个<code>SwaggerConfig</code>类，并使用<code>@EnableSwagger2</code>注解启用Swagger支持。然后，我们创建了一个<code>api()</code>方法，使用<code>Docket</code>类来配置Swagger。在<code>api()</code>方法中，我们使用<code>RequestHandlerSelectors</code>和<code>PathSelectors</code>类来指定要显示在文档中的API和路径。在最后，我们使用<code>apiInfo()</code>方法来设置API文档的标题、描述和版本号。</p> 
<p>在控制器类中，我们可以使用<code>@ApiOperation</code>、<code>@ApiParam</code>、<code>@ApiResponse</code>等注解来为每个API方法添加更详细的文档。例如：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
@Api(tags = "用户管理")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    @ApiOperation(value = "获取用户信息", notes = "根据用户ID获取用户信息")
    @ApiResponses({
            @ApiResponse(code = 200, message = "成功获取用户信息"),
            @ApiResponse(code = 404, message = "未找到该用户")
    })
    public User getUser(@PathVariable("id") @ApiParam(value = "用户ID", example = "1") Long id) {
        return userService.getUserById(id);
    }

    @PostMapping
    @ApiOperation(value = "创建用户", notes = "创建新用户")
    @ApiResponses({
            @ApiResponse(code = 200, message = "成功创建用户"),
            @ApiResponse(code = 400, message = "请求参数错误")
    })
    public User createUser(@RequestBody @ApiParam(value = "用户信息", required = true) User user) {
        return userService.createUser(user);
    }

}</code></pre> 
<p>在上面的代码中，我们在<code>getUser()</code>方法和<code>createUser()</code>方法上使用了<code>@ApiOperation</code>、<code>@ApiParam</code>和<code>@ApiResponse</code>等注解来添加更详细的文档。这些注解可以指定API方法的摘要、说明、参数、返回值和错误码等信息。</p> 
<p>最后，我们可以通过访问<code>http://localhost:8080/swagger-ui.html</code>来访问Swagger UI页面，并查看API文档。在Swagger UI页面中，我们可以查看API的摘要、说明、参数、返回值和错误码等信息，并使用UI界面测试API。</p> 
<p>总之，Spring MVC框架中的Swagger是一种非常有用的API文档工具，可以帮助我们自动生成、测试和文档化RESTful API。通过创建一个<code>SwaggerConfig</code>类，并在控制器类中使用<code>@ApiOperation</code>、<code>@ApiParam</code>、<code>@ApiResponse</code>等注解，我们可以轻松地配置Swagger，并为每个API方法添加更详细的文档。最后，我们可以通过访问Swagger UI页面来查看和测试API文档。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c37b74edbcbcba1d4bf4caeb7368c51f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring中的Bean管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a038c93ed13c1d6a4ca9fa685a8dedf9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">npm -np 包发布工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>