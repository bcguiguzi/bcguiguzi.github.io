<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring管理bean - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring管理bean" />
<meta property="og:description" content="场景一 ： 一个接口的多实例Bean的选择
首先定义一个接口和两个简单的实现类，并演示一下我们通常的用法
一个输出的接口定义如下
public interface IPrint {
void print(String msg);
}
对应给以下两个实现
@Service
public class ConsolePrint implements IPrint {
@Override
public void print(String msg) {
System.out.println(&#34;console print: &#34; &#43; msg);
}
}
@Slf4j
@Service
public class LogPrint implements IPrint {
@Override
public void print(String msg) {
log.info(“log print: {}”, msg);
}
}
下面就是我们一般的引用方式
@RestController
@RequestMapping(“/api/{edition}/page”)
public class MyPageHelperController {
@Autowired
private HouseMovingService houseMovingService;
@Autowired
private IPrint print;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/38edbcc37b0cde32de09a14f7612283f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T14:17:41+08:00" />
<meta property="article:modified_time" content="2023-09-27T14:17:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring管理bean</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>场景一 ： 一个接口的多实例Bean的选择</strong></p> 
<p>首先定义一个接口和两个简单的实现类，并演示一下我们通常的用法<br> 一个输出的接口定义如下<br> public interface IPrint {<!-- --><br> void print(String msg);<br> }</p> 
<p>对应给以下两个实现<br> @Service<br> public class ConsolePrint implements IPrint {<!-- --></p> 
<p>@Override</p> 
<p>public void print(String msg) {<!-- --></p> 
<p>System.out.println("console print: " + msg);</p> 
<p>}</p> 
<p>}</p> 
<p>@Slf4j<br> @Service<br> public class LogPrint implements IPrint {<!-- --><br> @Override<br> public void print(String msg) {<!-- --><br> log.info(“log print: {}”, msg);<br> }<br> }<br> 下面就是我们一般的引用方式</p> 
<p>@RestController<br> @RequestMapping(“/api/{edition}/page”)<br> public class MyPageHelperController {<!-- --></p> 
<p>@Autowired<br> private HouseMovingService houseMovingService;<br> @Autowired<br> private IPrint print;</p> 
<p>@GetMapping(“/a”)<br> @ResponseBody<br> public Result a(HttpServletRequest request, HttpServletResponse response) {<!-- --><br> try {<!-- --><br> print.print(“top”);<br> return ResultBulider.succuss(“成功”, “ok”);<br> } catch (Exception e) {<!-- --><br> return ResultBulider.faile(ResultCode.DATA_IS_WRONG);<br> }<br> }<br> }</p> 
<p>这样启动是会报错的：<br> Description:<br> Field print in com.example.demo.controller.MyPageHelperController required a single bean, but 2 were found:</p> 
<ul><li>consolePrint: defined in file [/Users/zhangjiguo/workspace/myProjects/demo/target/classes/com/example/demo/service/impl/ConsolePrint.class]</li><li>logPrint: defined in file [/Users/zhangjiguo/workspace/myProjects/demo/target/classes/com/example/demo/service/impl/LogPrint.class]</li></ul> 
<p>解决方法：</p> 
<p>方法1 ：<br> @Autowired注解是按照类型操作，属性名即为默认的Bean名，如下面的logPrint就是获取beanName=logPrint的bean<br> 图片</p> 
<p>方法2：<br> @Resource(name=xxx) 直接指定Bean的name，来唯一选择匹配的bean，resource是按照名子来操作的。<br> 图片</p> 
<p>方法3：<br> @Primary注解<br> 这个注解就是为了解决当有多个bean满足注入条件时，有这个注解的实例被选中,@Primary注解的使用有唯一性要求：即对应上面的case，一个接口的子类中，只能有一个实现上有这个注解</p> 
<p>方法4：<br> 相对高级的解决方案我们提出进一步的期望：就是只修改一个配置就能完成部署环境切换的操作。比如：deploy:<br> province: beijing<br> 当我们期望把部署环境从北京切换到上海的时候，只需要将上文配置中的beijing 改成 shanghai ，这该怎么实现呢？在北京的实现类上面加上ConditionalOnProperty注解，havingValue的值为beijing@Component<br> @ConditionalOnProperty(value=“deploy.province”,havingValue = “beijing”)<br> public class DemoServiceBeijing implements IDemoService {<!-- --><br> 在上海的实现类上面加上ConditionalOnProperty注解，havingValue的值为shanghai@Component<br> @ConditionalOnProperty(value=“deploy.province”,havingValue = “shanghai”)<br> public class DemoServiceShanghai implements IDemoService {<!-- --><br> 「ConditionalOnProperty注解在这里的作用就是」：读取配置文件发现deploy.province,并将该配置的值与havingValue匹配，匹配上哪一个就实例化哪一个类作为该接口的实现类bean注入到Spring容器中（当然注入过程需要配合@Component注解实现）。</p> 
<p><strong>场景二 ：SpringBoot 启动加载 CommandLineRunner</strong><br> 在项目中，经常有这样的需求，我们需要在项目启动完立即初始化一些数据（比如缓存等），以便后面调用使用。spring boot可以通过CommandLineRunner接口实现启动加载功能<br> 新建一个Java文件，类需要用Component声明下，需要实现CommandLineRunner接口，然后重写run方法，在run方法内编写需要加载的内容。<br> 代码如下：</p> 
<p>package com.study.test.startup;</p> 
<p>import org.springframework.boot.CommandLineRunner;<br> import org.springframework.stereotype.Component;</p> 
<p>/**</p> 
<ul><li> <p>@Description: 初始化启动类</p> </li><li> <p>@Author: chen</p> </li><li> <p>@Date: Created in 2019/2/22<br> */<br> @Component<br> public class InitStarter implements CommandLineRunner{<!-- --></p> <p>@Override<br> public void run(String… args) throws Exception {<!-- --><br> System.out.println(“CommandLineRunner example start”);<br> }<br> }</p> </li></ul> 
<p>启动项目，运行结果证明：CommandLineRunner会在服务启动之后被立即执行</p> 
<p>在项目中，我们可以写一个类继承CommandLineRunner接口，然后在实现方法中写多个需要加载的方法，也可以写多个类继承CommandLineRunner，这些类之间，可以通过order注解（@Order(value=1)）实现先后顺序。<br> 例子如下：</p> 
<p>图片</p> 
<p>图片</p> 
<p>总结：<br> CommandLineRunner会在服务启动之后被立即执行。<br> CommandLineRunner可以有多个，且多个直接可以用order注解进行排序</p> 
<p>场景五 ：SpringBoot 启动加载 @PostConstruct<br> 在Spring中，构造器Constructor，@Autowired，@PostConstruct三者的执行顺序，首先说@PostConstruct修饰的方法是在构造函数执行之后执行的，那么构造函数Constructor肯定就优先于@PostConstruct函数执行，那么@Autowired呢，@Autowired是用于注入对象使用的，那么肯定本对象已经有了才能注入依赖的对象，所以构造器Constructor优先于@Autowired执行，接下来就是分析</p> 
<p>@Autowired和@PostConstruct，可以看看@PostConstruct的描述，必须在所有的依赖都注入，所以@Autowired是优先于@PostConstruct执行的<br> 所以：Constructor、Autowired、PostContruce三者的执行顺序是：Constructor &gt; @Autowired &gt; @PostConstruct</p> 
<p>如果想在生成对象时候完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么就无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。</p> 
<p>简单说明：在Spring中一个类作为组件，同时在启动时会纳入Spring IOC中，那么在Servlet容器启动的时候就会生成对象，如果有方法【这些方法有一定的限制，参考@PostConstruct的说明】被@PostConstruct，那么就会自动执行，如果没有作为Spring组件，在Servlet容器启动时也是不会执行的，那么就只能在创建对象时执行，简单来说就是创建了对象被@PostConstruct修饰的方法才会执行</p> 
<p>在Bean的初始化操作中，有时候会遇到调用其他Bean的时候报空指针错误。这时候就可以将调用另一个Bean的方法这个操作放到@PostConstruct注解的方法中，将其延迟执行。</p> 
<p>错误示例：<br> @Component<br> public class PostConstructTest1 {<!-- --></p> 
<pre><code>    @Autowired
    PostConstructTest2 postConstructTest2;

    public PostConstructTest1() { //由于构造函数先于依赖注入执行，所以这里执行的时候postConstructTest2还没有注入，所以报错
        postConstructTest2.hello();
    }
}

@Component
public class PostConstructTest2 {

    public void hello() {
        System.out.println("hello, i am PostConstructTest2");
    }
}
</code></pre> 
<p>正确的做法是：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostConstructTest1</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token class-name">PostConstructTest2</span> postConstructTest2<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PostConstructTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//        postConstructTest2.hello();</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@PostConstruct</span> <span class="token comment">//该注解标注的方法，会在构造函数、依赖注入之后执行，所以正确</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        postConstructTest2<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>说明一下，@PostConstruct更针对性于当前类文件，而CommandLineRunner更服务于整个项目。所以在我们使用中，可根据自己的使用场景来进行选择用这两种方式来实现初始化。@PostConstruct 先于 CommandLineRunner执行</p> 
<p><strong>场景三：SpringBoot 启动加载 @BeanPostProcessor</strong></p> 
<p>BeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中</p> 
<p>BeanPostProcessor也称为Bean后置处理器，，作用是在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑。注意是Bean实例化完毕后及依赖注入完成后触发的，是先实例化才到初始化的， 源码如下：</p> 
<p>public interface BeanPostProcessor {<!-- --><br> Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br> Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br> }<br> 其中postProcessBeforeInitialization方法会在每一个bean对象的初始化方法调用之前回调；postProcessAfterInitialization方法会在每个bean对象的初始化方法调用之后被回调。</p> 
<p>图片<br> spring给我们一个给bean加工的机会，比如生成代理对象。还有底层的aop实现也是通过这个方式。</p> 
<p>@PostConstruct注解 \ 实现BeanPostProcessor接口 区别：<br> 1、PostConstruct、BeanPostProcessor都是在实例化、依赖注入之后执行的。</p> 
<p>2、@PostConstruct函数会在BeanPostProcessor接口的postProcessBeforeInitialization函数之后，postProcessAfterInitialization函数之前执行。</p> 
<p>3、而且最大的区别是，BeanPostProcessor接口控制的是更宏观的东西，所有Bean的加载都会执行这个接口的方法，而@PostConstruct只会在你加的Bean里执行。</p> 
<p>也就是说，如果你想在加载所有Bean时执行一些东西，就用BeanPostProcessor接口，如果只想在加载某一个bean时执行就在该Bean里加上@PostConstruct注解即可</p> 
<p>------ 例如：<br> @Data<br> @Builder<br> @AllArgsConstructor<br> public class UserInfo {<!-- --></p> 
<p>private Integer age;</p> 
<p>private String name;</p> 
<p>private Integer sex;</p> 
<p>public UserInfo(){<!-- --><br> System.out.println(“UserInfo 被实例化”);<br> }</p> 
<p>/**</p> 
<ul><li>自定义的初始化方法<br> */<br> @PostConstruct<br> public void start(){<!-- --><br> System.out.println(“User 中自定义的初始化方法”);<br> }<br> }</li></ul> 
<p>@Component<br> public class MyBeanPostProcessor1 implements BeanPostProcessor {<!-- --><br> @Override<br> @Nullable<br> public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<!-- --><br> System.out.println(“bean 初始化之前”);<br> return bean;<br> }</p> 
<p>@Override<br> @Nullable<br> public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<!-- --><br> System.out.println(“bean 初始化之后”);<br> return bean;<br> }<br> }<br> 上述的执行顺序是：<br> 1、UserInfo 被实例化<br> 2、bean 初始化之前<br> 3、User 中自定义的初始化方法<br> 4、bean 初始化之后</p> 
<p>全文重点如下：<br> 1、Resource bean的注入时使用，按照byName自动注入，Resource 默认按名称装配，如果不到与名称匹配的bean，会按类型装配</p> 
<p>2、Autowired bean的注入时使用，按照byType自动注入，如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用</p> 
<p>3、Qualifier Qualifier可以结合Autowired一起使用，@Autowired @Qualifier(“user”)</p> 
<p>4、Primary 当Spring容器扫描到某个接口的多个 bean 时，如果某个bean上加了@Primary 注解 ，则这个bean会被优先选用</p> 
<p>5、PostConstruct 被注解的方法，在对象加载完依赖注入后执行</p> 
<p>6、CommandLineRunner 实现在项目启动后执行的功能</p> 
<p>7、ApplicationRunner 实现在项目启动后执行的功能</p> 
<p>8、BeanPostProcessor BeanPostProcessor提供了两个接口回调。当BeanPostProcessor的实现类注册到spring ioc容器中，对于改spring ioc容器所创建的每个bean实例在调用其初始化方法调用前将会调用BeanPostProcessor中的postProcessBeforeInitialization方法，而在bean实例初始化方法调用完成后，则会调用BeanPostProcessor中的postProcessAfterInitialization方法spring给我们一个给bean加工的机会，比如生成代理对象。还有底层的aop实现也是通过这个方式</p> 
<p>9、Aware 感知的Spring容器的存在，与Spring容器建立联系，使用spring容器内的资源，如BeanNameAware获取容器中bean的名字</p> 
<p>---------------------------------------- 重点内容 ------------------------------------------</p> 
<p>一、Spring声明一个bean</p> 
<p>1、xml配置文件的形式</p> 
<p>2、@import</p> 
<p>3、@Configuration + @bean</p> 
<p>4、@Component 及其子注解（@controller、@service、@Repository）声明</p> 
<p>二、Spring创建bean的三种方式：</p> 
<p>1、调用构造器创建Bean</p> 
<p>2、调用静态工厂方法创建Bean</p> 
<p>3、调用实例工厂方法创建Bean</p> 
<p>三、Spring可以进行初始化bean的地方</p> 
<p>1、构造函数</p> 
<p>2、@PostConstruct 构造函数之后，init()方法之前执行</p> 
<p>3、init()初始化方法，有两种实现</p> 
<p>（1）实现InitializingBean接口中的afterPropertiesSet方法 (推荐使用)</p> 
<p>（2）xml中配置init方法</p> 
<p>4、BeanPostProcessor 后置处理器，有如下两个方法，分别是前、后执行</p> 
<p>(1) postProcessBeforeInitialization</p> 
<p>(2) postProcessAfterInitialization</p> 
<pre><code>    执行顺序是：构造函数  -&gt;  @Autowired  -&gt; postProcessBeforeInitialization -&gt; @PostConstruct -&gt; InitializingBean -&gt; xml中配置init方法 -&gt; postProcessAfterInitialization
</code></pre> 
<p>（1）在利用上述方法进行初始化操作的时候要注意执行顺序问题</p> 
<p>（2）@PostConstruct 和BeanPostProcessor的区别，BeanPostProcessor接口控制的是更宏观的东西，所有Bean的加载都会执行这个接口的方法，而@PostConstruct只 会在你加的Bean里执行。也就是说，如果你想在加载所有Bean时执行一些东西，就用BeanPostProcessor接口，如果只想在加载某一个bean时执行就在该Bean里加上@PostConstruct注解即可。</p> 
<p>（3）BeanPostProcessor接口中两个方法不能返回null，如果返回null那么在后续初始化方法将报空指针异常或者通过getBean()方法获取不到bena实例对象，因为后置处理器从Spring IoC容器中取出bean实例对象没有再次放回IoC容器中</p> 
<p>关于工具类静态方法调用@Autowired注入的问题<br> 解决方案如下：</p> 
<p>1.对工具类使用@Component 注解</p> 
<p>2.@Autowired 注解注入bean</p> 
<p>3.@PostConstruct 使用该注解定义init()方法，在方法中给logTool赋值</p> 
<p>使用时调用logTool.xxxMapper.method();</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestUtils</span> <span class="token punctuation">{<!-- --></span>     
<span class="token annotation punctuation">@Autowired</span>    
<span class="token keyword">private</span> <span class="token class-name">ItemService</span> itemService<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Autowired</span>    
<span class="token keyword">private</span> <span class="token class-name">ItemMapper</span> itemMapper<span class="token punctuation">;</span>
          
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">TestUtils</span> testUtils<span class="token punctuation">;</span> 
         
<span class="token annotation punctuation">@PostConstruct</span>     
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
testUtils <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>          
 <span class="token comment">//utils工具类中使用service和mapper接口的方法例子，用"testUtils.xxx.方法" 就可以了    </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Item</span> record<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>         testUtils<span class="token punctuation">.</span>itemMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span>
testUtils<span class="token punctuation">.</span>itemService<span class="token punctuation">.</span><span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyUtil</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">UserServiceImpl</span> myuserService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">UserServiceImpl</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostConstruct</span> <span class="token comment">//该注解标注的方法，会在构造函数、依赖注入之后执行，所以正确</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        myuserService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">a1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--- 2 ---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myuserService<span class="token punctuation">.</span><span class="token function">aa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"guo"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结：spring注入是在容器中实例化对象的，而且静态是优先于对象存在的，因此直接在静态方法中调用注入的静态变量实际上是为null的，sping中若是要对静态变量进行注入只能是变相、间接的来完成。</p> 
<hr> 
<p>Bean的注册方式有三种</p> 
<ul><li>XML配置文件的注册方式</li><li>Java注解的注册方式</li><li>JavaAPI的注册方式</li></ul> 
<p>XML 配置文件注册方式</p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.beans.Person"</span><span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"id"</span> value<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"Java"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
</code></pre> 
<p>Java 注解注册方式</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token class-name">String</span> name
   <span class="token comment">// 忽略其他方法</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也可以使用 @Bean 注解方式来注册 Bean，代码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
   <span class="token annotation punctuation">@Bean</span>
   <span class="token keyword">public</span> <span class="token class-name">Person</span>  <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 忽略其他方法</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>@Configuration可以理解为XML配置里的标签,而 @Bean 可理解为用 XML 配置里面的 标签。</p> 
<p>Java API 注册方式<br> 使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomBeanDefinitionRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span> <span class="token punctuation">{<!-- --></span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">RootBeanDefinition</span> personBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 新增 Bean</span>
		registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">,</span> personBean<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f0fc0cad351eb9f83363428210a5baf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">delphi 连接轻量级数据库 sqlite3</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d2fa743f20b4561b4e6306f12a688ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【IDEA】idea恢复pom.xml文件显示灰色并带有删除线</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>