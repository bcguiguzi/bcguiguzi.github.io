<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>插头DP【入门】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="插头DP【入门】" />
<meta property="og:description" content="强烈推荐网址：http://www.notonlysuccess.com/?p=931
hdu 1693 Eat the Trees
多回路的不用判联通状态，二进制即可，转移情况2*2种。 时间O(n*m*2^n) 空间O（n*2^n）
/**插头DP**/ #include &lt;cstdio&gt; #include &lt;cstring&gt; const int maxm=13 ; const int maxn=1&lt;&lt;12; typedef long long ll ; ll dp[maxm][maxn]; int map[maxm][maxm]; /* i行j列 轮廓线状态k。除了换行以外，每个状态只与同行的状态的前一列有关，可以减少一维空间 */ int main () { int n,m; int cas; scanf(&#34;%d&#34;,&amp;cas); for (int I=1 ; I&lt;=cas ; &#43;&#43;I) { int cnt=0; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); /*行列交换的优化、以及总可行格数为奇数的优化*/ if(n&gt;=m) for (int i=0 ; i&lt;n ; &#43;&#43;i) { for (int j=1 ; j&lt;=m ; &#43;&#43;j) { scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/012ae90debdbb2eefb96101359b7958a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-09-26T21:44:06+08:00" />
<meta property="article:modified_time" content="2011-09-26T21:44:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">插头DP【入门】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>强烈推荐网址：<a href="http://www.notonlysuccess.com/?p=931" rel="nofollow">http://www.notonlysuccess.com/?p=931</a></p> 
<p> </p> 
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1693" rel="nofollow">hdu 1693 Eat the Trees</a></p> 
<p>多回路的不用判联通状态，二进制即可，转移情况2*2种。 时间O(n*m*2^n)  空间O（n*2^n）</p> 
<pre><code class="language-cpp">/**插头DP**/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxm=13 ;
const int maxn=1&lt;&lt;12;

typedef long long ll ;

ll dp[maxm][maxn];
int map[maxm][maxm];
/*
i行j列 轮廓线状态k。除了换行以外，每个状态只与同行的状态的前一列有关，可以减少一维空间
*/

int main ()
{
    int n,m;
    int cas;
    scanf("%d",&amp;cas);
    for (int I=1 ; I&lt;=cas ; ++I)
    {
        int cnt=0;
        scanf("%d%d",&amp;n,&amp;m);
        /*行列交换的优化、以及总可行格数为奇数的优化*/
        if(n&gt;=m)
        for (int i=0 ; i&lt;n ; ++i)
        {
            for (int j=1 ; j&lt;=m ; ++j)
            {
                scanf("%d",&amp;map[i][j]);
                if(map[i][j])cnt++;
            }
        }
        else
        {
            n^=m^=n^=m;
            for (int i=1 ; i&lt;=m ; ++i)
            {
                for (int j=0 ; j&lt;n ; ++j)
                {
                    scanf("%d",*(map+j)+i);
                    if(map[j][i])cnt++;
                }
            }
        }
        if(cnt&amp;1)
        {
            printf("Case %d: There are 0 ways to eat the trees.\n",I);
            continue;
        }
        memset (dp , 0 , sizeof(dp));
        dp[0][0]=1;

        for (int i=0 ; i&lt;n ; ++i)
        {
            if(i&gt;0)
            for (int k=0 ; k&lt;(1&lt;&lt;(m)) ; ++k)
            {
                dp[0][k&lt;&lt;1]=dp[m][k];//换行
                //printf("%d %d %o map==%d %lld\n",i,0,k,map[i][0],dp[i][0][k&lt;&lt;1]);
            }

            for (int j=1 ; j&lt;=m ; ++j)
            {
                for (int k=0 ; k&lt;(1&lt;&lt;(m+1)) ; ++k)
                {
                    int a=(1&lt;&lt;j);
                    int b=(1&lt;&lt;(j-1));
                    if(map[i][j])
                    {
                        dp[j][k]=dp[j-1][k^a^b];
                        if((!(k&amp;a)) ^ (!(k&amp;b)))dp[j][k]+=dp[j-1][k];
                    }
                    else
                    {
                        if((!(k&amp;a)) &amp;&amp; (!(k&amp;b)))
                        {
                            dp[j][k]=dp[j-1][k];
                        }
                        else dp[j][k]=0;
                    }
                }// end for k
            }//end for j
        }// end for i
        //for (int i=0 ; i&lt;(1&lt;&lt;(m+1)) ; ++i)
            //printf("%d\n" , dp[n-1][m-1][i]);
        printf("Case %d: There are %I64d ways to eat the trees.\n",I,dp[m][0]);
    }
    return 0;
}
</code></pre> 
<p><br> <br>  时间O(n*m*2^n)  空间O（2^n）</p> 
<p> </p> 
<pre><code class="language-cpp">/**插头DP**/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxm=13 ;
const int maxn=1&lt;&lt;12;

typedef long long ll ;

ll dp[2][maxn];
int map[maxm][maxm];
/*
i行j列 轮廓线状态k。除了换行以外，每个状态只与同行的状态的前一列有关，可以减少一维空间
*/

int main ()
{
    int n,m;
    int cas;
    scanf("%d",&amp;cas);
    for (int I=1 ; I&lt;=cas ; ++I)
    {
        int cnt=0;
        scanf("%d%d",&amp;n,&amp;m);

        /*行列交换的优化、以及总可行格数为奇数的优化*/
        if(n&gt;=m)
        for (int i=0 ; i&lt;n ; ++i)
        {
            for (int j=1 ; j&lt;=m ; ++j)
            {
                scanf("%d",&amp;map[i][j]);
                if(map[i][j])cnt++;
            }
        }
        else
        {
            n^=m^=n^=m;
            for (int i=1 ; i&lt;=m ; ++i)
            {
                for (int j=0 ; j&lt;n ; ++j)
                {
                    scanf("%d",*(map+j)+i);
                    if(map[j][i])cnt++;
                }
            }
        }
        if(cnt&amp;1)
        {
            printf("Case %d: There are 0 ways to eat the trees.\n",I);
            continue;
        }
        memset (dp , 0 , sizeof(dp));
        dp[0][0]=1;
        int t=1;
        for (int i=0 ; i&lt;n ; ++i)
        {
            memset (dp[t] , 0 , sizeof(dp[t]));//必须清空
            if(i&gt;0)
            {
                for (int k=0 ; k&lt;(1&lt;&lt;(m)) ; ++k)
                {
                    dp[t][k&lt;&lt;1]=dp[t^1][k];//换行
                }
                t^=1;
            }
            for (int j=1 ; j&lt;=m ; ++j,t^=1)
            {
                for (int k=0 ; k&lt;(1&lt;&lt;(m+1)) ; ++k)
                {
                    int a=(1&lt;&lt;j);
                    int b=(1&lt;&lt;(j-1));
                    if(map[i][j])
                    {
                        dp[t][k]=dp[t^1][k^a^b];
                        if((!(k&amp;a)) ^ (!(k&amp;b)))dp[t][k]+=dp[t^1][k];
                    }
                    else
                    {
                        if((!(k&amp;a)) &amp;&amp; (!(k&amp;b)))
                        {
                            dp[t][k]=dp[t^1][k];
                        }
                        else dp[t][k]=0;
                    }
                //printf("%d  %d  %o %I64d  %I64d\n" , i , j ,k,dp[t^1][k] , dp[t][k]);
                }// end for k
            }//end for j
        }// end for i
            //printf("%I64d\n" , dp[t][0]);
        printf("Case %d: There are %I64d ways to eat the trees.\n",I,dp[t^1][0]);
    }
    return 0;
}
</code></pre> 
<p><br>  </p> 
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4064" rel="nofollow">HDU 4064 Carcassonne</a></p> 
<p> </p> 
<table border="0" cellspacing="2" width="100%" align="center"><tbody><tr class="table_header" height="22" align="center" bgcolor="#1a5cc8"><td>Rank</td><td>Author</td><td><a href="?pid=4064&amp;from=&amp;lang=&amp;order_type=0" rel="nofollow" style="color:orange">Exe. Time</a></td><td><a href="?pid=4064&amp;from=&amp;lang=&amp;order_type=1" rel="nofollow" style="color:white">Exe. Memory</a></td><td><a href="?pid=4064&amp;from=&amp;lang=&amp;order_type=2" rel="nofollow" style="color:white">Code Len.</a></td><td>Language</td><td>Date</td></tr><tr class="table_text" align="center"><td>1</td><td><a href="userstatus.php?user=jxy859" rel="nofollow">Geners</a></td><td>0MS</td><td>256K</td><td>2361B</td><td>G++</td><td>2011-10-15 16:55:39</td></tr></tbody></table> 
<p> </p> 
<p>比赛的时候一直纠结在4进制上 ， 上下左右四个方向表示状态，没敢敲，怕超时， 后来看见达哥过了 ， 问了下方法，原来是可以3进制的，只考虑F R C即可，当时比赛的时候脑子木了。</p> 
<p>在看了fzq的代码之前 ，第一行状态和第一列状态都是特殊处理的，在fzq的代码里有个技巧，因为是4进制表示3进制，所有有一个冗余态，直接让这个状态表示万能态，即任何时候都能与其联通，于是代码简洁了不少 ， 时间也快了 。</p> 
<p>哈希表+4进制+位运算+轮廓线状态。</p> 
<p>哈希表要尽量小一些， 时间都浪费在滚动数组的清空了。</p> 
<p>TLE+MLE代码 ， 没用哈希的纯映射方法， 空间各种浪费啊</p> 
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;
const int maxn=1594324;//3^13=1594323;
const int mod = 1000000007;

int val[maxn];
int dir[4][4]={1, 2, 3, 0, 0, 1, 2, 3, 2, 3, 0, 1, 3, 0, 1, 2};// dir[][0-up 1-right 2-down 3-left];
int dp[2][45108864+123];//00 - F , 01 - C , 10 - R , 11 is redundancy
char  map_[13][13][5];
int t; //滚动用

void init()//put ternary in quaternary
{
    int cnt = 0;
    val[cnt++] = 0;
    val[cnt++] = 1;
    val[cnt++] = 2;

    int p = 1;
    while (cnt &lt; maxn)
    {
        val[cnt++] = val[p]*4 + val[0];
        val[cnt++] = val[p]*4 + val[1];
        val[cnt++] = val[p++]*4 + val[2];
    }
}

inline int change(char ch)
{
    if(ch == 'F')return 0;
    if(ch == 'C')return 1;
    if(ch == 'R')return 2;
    return 100;
}

int r,c;
void dfs(int col, int sta, int uni)//
{
    if(col==0)
    {
        //printf("===sta===%d\n",sta);
        dp[0][sta]=(1+dp[0][sta])%mod;
        return ;
    }

    for (int i = 0; i &lt; 4; ++i)
    {
        const char *str=map_[0][col-1];//
        //printf("%s",map_[0][col]);
        //printf("%d %d  dir==%d  %c\n",change(str[dir[i][3]]), uni, dir[i][3], str[dir[i][3]] );
        if( change(str[dir[i][1]])==uni )
        dfs(col-1 , (sta&lt;&lt;2)|(change(str[dir[i][2]])) , change(str[dir[i][3]]));
    }
}

int cuts;
void DP()
{
    t=0;
    for (int i=1 ; i&lt;r ; ++i)
    {
        t^=1;
        memset (dp[t] , 0 , sizeof(dp[t]));
        for (int k=0 ; val[k]&lt;=(1&lt;&lt;((c&lt;&lt;1)+2)) ; ++k)
        {
            dp[t][((val[k] &amp; cuts)&lt;&lt;2) |3]=(dp[t^1][val[k]]+dp[t][((val[k] &amp; cuts)&lt;&lt;2) |3])%mod;
            //printf("===%d  %d  %d  %d  %d\n", i , j , val[k] , (val[k]&lt;&lt;2 &amp; cut[c]) , cut[c]);
        }
        for (int j=0 ; j&lt;c ; ++j)
        {
            const char *str=map_[i][j];

            t^=1;
            memset (dp[t] , 0 , sizeof(dp[t]));
            if(j==0)
            {
                for (int k=0 ; val[k]&lt;=(1&lt;&lt;(c&lt;&lt;1)+2) ; k+=3)
                if((val[k]&amp;3)==0)
                {
                    int state=((val[k]&gt;&gt;2) &amp; 3);
                    for (int d=0 ; d&lt;4 ; ++d)
                    {
                        if(change(str[dir[d][0]])==state)
                        dp[t][ (val[k]&amp;(~15)) | (change(str[dir[d][1]])&lt;&lt;2)
                                | change(str[dir[d][2]]) ]=(dp[t^1][val[k]|3]+dp[t][ (val[k]&amp;(~15)) | (change(str[dir[d][1]])&lt;&lt;2)
                                | change(str[dir[d][2]]) ])%mod;
                    }
                }
                }
            else
            {
                for (int k=0 ; val[k]&lt;=( 1&lt;&lt;((c&lt;&lt;1)+2) ) ; ++k)
                {
                    //if(!dp[j-1][val[k]])continue;
                    //printf("===%d  %d  %d  %s\n", i , j , val[k] ,str);
                    int sta=val[k];
                    int left=(val[k]&gt;&gt;(2*j) &amp; 3);
                    int up=(val[k]&gt;&gt;(2*j+2) &amp; 3);
                    //sta=sta^(left&lt;&lt;(2*j))^left&lt;&lt;
                    //printf("%s %d %d  %d %d\n",str,i,j ,c , k);
                    //printf("val==%d   left ==%d  up==%d  dp===%d  j==%d\n",val[k], left , up , dp[i][j-1][val[k]] , j);
                    if(dp[t^1][val[k]])
                    for (int d=0 ; d&lt;4 ; ++d)
                    {
                        if( change(str[dir[d][0]])==up &amp;&amp; change(str[dir[d][3]])==left )
                            dp[t][ val[k]&amp;(~(15&lt;&lt;(j*2))) | (change(str[dir[d][2]])&lt;&lt;(2*j))
                                    | change(str[dir[d][1]])&lt;&lt;(2*j+2) ] =
                                    (dp[t^1][val[k]]+dp[t][ val[k]&amp;(~(15&lt;&lt;(j*2))) | (change(str[dir[d][2]])&lt;&lt;(2*j))
                                    | change(str[dir[d][1]])&lt;&lt;(2*j+2) ] )%mod;

                                    //printf("option ==%d  %d\n" , val[k]&amp;(~(15&lt;&lt;(j*2))) | (change(str[dir[d][2]])&lt;&lt;(2*j))
                                    //| change(str[dir[d][1]])&lt;&lt;(2*j+2) , dp[i][j-1][val[k]]);

                    }
                }
            }
        }
    }
}

int main ()
{
    init();
    int cas;
    scanf("%d", &amp;cas);
    for (int I=1 ; I&lt;=cas ; ++I)
    {
        scanf("%d%d", &amp;r, &amp;c);
        cuts=(1&lt;&lt;(c&lt;&lt;1))-1;
        for (int i = 0; i &lt; r; ++i)
            for (int j = 0; j &lt; c; ++j)
                scanf("%s", map_[i][j]);

        memset (dp, 0, sizeof(dp));

        dfs(c , 0 , 0);//DFS要倒着来，这样DP的时候能是正着的
        dfs(c , 0 , 1);
        dfs(c , 0 , 2);
        int ans=0;
        DP();

        for (int i=0 ; val[i]&lt;=(1&lt;&lt;((c&lt;&lt;1)+2)) ; ++i)
        if(dp[t][val[i]])
        {
            ans=(dp[t][val[i]]+ans)%mod;
            //printf("val ==%d  dp==%d\n",val[i],dp[r-1][c-1][val[i]]);
        }
        printf("Case %d: %d\n",I,ans);
    }
    return 0;
}
</code></pre> 
<p><br>  </p> AC代码（哈希）： 
<p>  </p> 
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;

typedef int types;

using namespace std;

const int Limithash=100007;
const int mod=1000000007;
int dir[4][4]={1, 2, 3, 0, 0, 1, 2, 3, 2, 3, 0, 1, 3, 0, 1, 2};
int r, c, map[5];
int cuts;
int t;

struct Hashmap{
	int hash[Limithash], state[Limithash], sum[Limithash], total;
	void hash_in(types s, int data)
	{
		int pos=s%Limithash;//Limithash must be a prime 
		while (hash[pos])
		{
			if(state[hash[pos]]==s)//如果状态存在
			{
				sum[hash[pos]]=(sum[hash[pos]]+data)%mod;
				return;//找到并更新状态
			}
			pos++;
			if(pos==Limithash)pos=0;
		}
		total++;//从1开始
		hash[pos]=total;//此处添加新状态
		state[total]=s;
		sum[total]=data;
	}
	void clear ()
	{
		total=0;
		memset (hash , 0 , sizeof(hash));
	}
}dp[2];

inline void roll ()
{
	t^=1;
	dp[t].clear();
}

inline bool valid(int x, int y)
{
	return x==0 || x==y;
}

char str[10];

int main ()
{
	int cas;
	scanf("%d", &amp;cas);
	for (int I=1 ; I&lt;=cas ; ++I)
	{
		scanf("%d%d", &amp;r, &amp;c);
		cuts=(1&lt;&lt;(c&lt;&lt;1))-1;
		t=0;
		dp[0].clear();
		dp[0].hash_in(0, 1);
		for (int i=0 ; i&lt;r ; ++i)
		{
			roll();
			for (int k=1 ; k&lt;=dp[t^1].total ; ++k)//换行
				dp[t].hash_in( (dp[t^1].state[k] &amp; cuts)&lt;&lt;2, dp[t^1].sum[k]);

			for (int j=0 ; j&lt;c ; ++j)
			{
				roll();
				scanf("%s", str);
				for (int k=0 ; k&lt;4 ; ++k)
				{
					if(str[k]=='C')map[k]=1;
					if(str[k]=='F')map[k]=2;
					if(str[k]=='R')map[k]=3;
				}
				for (int k=1 ; k&lt;=dp[t^1].total ; ++k)
				{
					int sta=dp[t^1].state[k];
					int left=(sta&gt;&gt;(j&lt;&lt;1))&amp;3;
					int up=(sta&gt;&gt;((j&lt;&lt;1)+2))&amp;3;
					sta=sta^(left&lt;&lt;(j&lt;&lt;1))^(up&lt;&lt;((j&lt;&lt;1)+2));
					for (int d=0 ; d&lt;4 ; ++d)
					{
						if(valid(left, map[dir[d][3]]) &amp;&amp; valid(up, map[dir[d][0]]))
                            dp[t].hash_in( sta|(map[dir[d][1]]&lt;&lt;(j+1&lt;&lt;1))|(map[dir[d][2]]&lt;&lt;(j&lt;&lt;1)),
                                           dp[t^1].sum[k]);
					}
				}
			}
		}
		int ans=0;
		for (int i=1 ; i&lt;=dp[t].total ; ++i)
		{
			ans=(ans+dp[t].sum[i])%mod;
		}
		printf("Case %d: %d\n", I, ans);
	}
	return 0;
}
</code></pre> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2671848b9438d6dae2d9f40aae64fda8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Xml与xsl连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6012e59213a328d5ffac0ffc787e51cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CPL, 门DPL, 描述符DPL 的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>