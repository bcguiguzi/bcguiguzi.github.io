<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;二叉树 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;二叉树" />
<meta property="og:description" content="1、定义一个二叉树结构体 #include&lt;iostream&gt; using namespace std; typedef struct TreeNode { char data; struct TreeNode *lchild, *rchild; }TreeNode, *Bitree; 此处取别名时，我认为*Bitree加不加*都可以，只是后面定义树的时候有区别。加*后面定义Bitree T;不加的话Bitree *T。
2、建立二叉树 为了确定二叉树是否每个结点都有左右孩子，对其进行扩展，也就是将二叉树的每个结点的空指针引出一个虚结点，并赋予一个特定值（此处我们为&#34;#&#34;）如上图所示。
void CreateBitree(BiTree &amp;T) { char NodeData; cout &lt;&lt; &#34;请输入结点字符(一个字符)：&#34;; cin &gt;&gt; NodeData; if (NodeData == &#39;#&#39;) { T = NULL; } else { T = new TreeNode; //开辟空间 if (!T) return; T-&gt;data = NodeData; CreateBitree(T-&gt;Ichild); //构造左结点 CreateBitree(T-&gt;Rchild); //构造右结点 } } 传参时形参为*T或者&amp;T都可以看个人习惯，主要是需要通过地址传递。
3、前序遍历 先访问根节点，然后前序遍历左子树，再前序遍历右子树(根左右)
//前序遍历 void PreOrderTraverse(BiTree T) { if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6aad6d773e2f8083ace2ba0103be3d1a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-09T15:03:25+08:00" />
<meta property="article:modified_time" content="2023-03-09T15:03:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">1、定义一个二叉树结构体</h2> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

typedef struct TreeNode {
    char data;
    struct TreeNode *lchild, *rchild;
}TreeNode, *Bitree;</code></pre> 
 <p style="text-align:left;">此处取别名时，我认为*Bitree加不加*都可以，只是后面定义树的时候有区别。加*后面定义Bitree T;不加的话Bitree *T。</p> 
 <h2 style="">2、建立二叉树</h2> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:382px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:81.6754%;height:0;"> 
    <img src="https://images2.imgbox.com/08/7e/Zz2dIxOh_o.png" style="margin-left:;display:block;width:382px;margin-top:-81.6754%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">为了确定二叉树是否每个结点都有左右孩子，对其进行扩展，也就是将二叉树的每个结点的空指针引出一个虚结点，并赋予一个特定值（此处我们为"#"）如上图所示。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void CreateBitree(BiTree &amp;T) 
{
    char NodeData;
    cout &lt;&lt; "请输入结点字符(一个字符)：";
    cin &gt;&gt; NodeData;
    if (NodeData == '#') {
        T = NULL;
    }
    else {
        T = new TreeNode;  //开辟空间
        if (!T)
            return;
        T-&gt;data = NodeData;
        CreateBitree(T-&gt;Ichild);  //构造左结点
        CreateBitree(T-&gt;Rchild);  //构造右结点
    }
}</code></pre> 
 <p style="">传参时形参为*T或者&amp;T都可以看个人习惯，主要是需要通过地址传递。</p> 
 <h2 style="">3、前序遍历</h2> 
 <p style="">先访问根节点，然后前序遍历左子树，再前序遍历右子树(根左右)</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//前序遍历
void PreOrderTraverse(BiTree T)
{
    if (!T)
        return;
    cout &lt;&lt; T-&gt;data;
    PreOrderTraverse(T-&gt;Ichild);
    PreOrderTraverse(T-&gt;Rchild);
}</code></pre> 
 <h2 style="text-align:left;">4、中序遍历</h2> 
 <p style="">先中序遍历左子树，然后访问根节点，再中序遍历右子树(左根右)</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//中序遍历
void InOrderTraverse(BiTree T)
{
    if (!T)
        return;
    InOrderTraverse(T-&gt;Ichild);
    cout &lt;&lt; T-&gt;data;
    InOrderTraverse(T-&gt;Rchild);
}</code></pre> 
 <h2 style="text-align:left;">5、后序遍历</h2> 
 <p style="text-align:left;">先后序遍历左子树，然后后序遍历右子树，再访问根节点(左右根)</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//后序遍历
void PostOrderTraverse(BiTree T)
{
    if (!T)
        return;
    PostOrderTraverse(T-&gt;Ichild);
    PostOrderTraverse(T-&gt;Rchild);
    cout &lt;&lt; T-&gt;data;
}</code></pre> 
 <h2 style="">完整代码</h2> 
 <pre class="kdocs-cpp"><code class="language-cpp">//二叉树

//定义二叉树结构体
typedef struct TreeNode {
    char data;
    struct TreeNode *Ichild, *Rchild;
}TreeNode, *BiTree;

//建立二叉树
void CreateBitree(BiTree &amp;T) 
{
    char NodeData;
    cout &lt;&lt; "请输入结点字符(一个字符)：";
    cin &gt;&gt; NodeData;
    if (NodeData == '#') {
        T = NULL;
    }
    else {
        T = new TreeNode;  //开辟空间
        if (!T)
            return;
        T-&gt;data = NodeData;
        CreateBitree(T-&gt;Ichild);  //构造左结点
        CreateBitree(T-&gt;Rchild);  //构造右结点
    }
}

//前序遍历
void PreOrderTraverse(BiTree T)
{
    if (!T)
        return;
    cout &lt;&lt; T-&gt;data;
    PreOrderTraverse(T-&gt;Ichild);
    PreOrderTraverse(T-&gt;Rchild);
}

//中序遍历
void InOrderTraverse(BiTree T)
{
    if (!T)
        return;
    InOrderTraverse(T-&gt;Ichild);
    cout &lt;&lt; T-&gt;data;
    InOrderTraverse(T-&gt;Rchild);
}

//后序遍历
void PostOrderTraverse(BiTree T)
{
    if (!T)
        return;
    PostOrderTraverse(T-&gt;Ichild);
    PostOrderTraverse(T-&gt;Rchild);
    cout &lt;&lt; T-&gt;data;
}

int main()
{
    BiTree T;
    cout &lt;&lt; "建立二叉树" &lt;&lt; endl;
    CreateBitree(T);
    cout &lt;&lt; "前序遍历：";
    PreOrderTraverse(T);
    cout &lt;&lt; endl;

    cout &lt;&lt; "中序遍历：";
    InOrderTraverse(T);
    cout &lt;&lt; endl;

    cout &lt;&lt; "后序遍历：";
    PostOrderTraverse(T);
    cout &lt;&lt; endl;
    return 0;
}</code></pre> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">总结</span></h2> 
 <p style="text-align:null;">以上为二叉树建立及最常见的三种遍历的个人理解，本人小白，主要用来记录，如有错误，欢迎大佬们指点出来。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cea34ed856f5f144c84985a8c1761bed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Wayland环境下通过xwayland支持docker图形界面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11c2473e6a2b5f5f071b7f5dc74cde94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">xshell链接不上centos7可能是sshd服务未开启</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>