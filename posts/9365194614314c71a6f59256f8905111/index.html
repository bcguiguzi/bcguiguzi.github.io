<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python笔记-设计模式】工厂模式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Python笔记-设计模式】工厂模式" />
<meta property="og:description" content="一、说明 (一) 解决问题 提供了一种方式，在不指定具体类将要创建的情况下，将类的实例化操作延迟到子类中完成。可以实现客户端代码与具体类实现之间的解耦，使得系统更加灵活、可扩展和可维护。
(二) 使用场景 希望复用现有对象来节省系统资源， 而不是每次都重新创建对象时如果无法预知对象确切类别及其依赖关系时希望用户能扩展你软件库或框架的内部组件时 二、结构 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。具体产品 （Concrete Products） 是产品接口的不同实现。创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 三、伪代码 #!/usr/bin/env python # -*- coding: UTF-8 -*- __doc__ = &#34;&#34;&#34; 工厂模式 将类的实例化操作延迟到子类中完成 例：通过传入不同的操作符，实现对两个数字的加减乘除运算 &#34;&#34;&#34; from abc import ABC, abstractmethod class Product(ABC): &#34;&#34;&#34; 抽象基类 &#34;&#34;&#34; num1 = None num2 = None @abstractmethod def get_result(self): pass class ProductAdd(Product): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9365194614314c71a6f59256f8905111/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-22T13:28:39+08:00" />
<meta property="article:modified_time" content="2024-02-22T13:28:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python笔记-设计模式】工厂模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="313" id="u63c466f3" src="https://images2.imgbox.com/b3/25/xcfTDrcE_o.png" width="500"></p> 
<h2 id="p9BcO">一、说明</h2> 
<h3 id="r5LkG">(一) 解决问题</h3> 
<p id="ub3547170">提供了一种方式，在不指定具体类将要创建的情况下，将类的实例化操作延迟到子类中完成。可以实现客户端代码与具体类实现之间的解耦，使得系统更加灵活、可扩展和可维护。</p> 
<h3 id="gcXoU">(二) 使用场景</h3> 
<ul><li id="u0639ed6f">希望复用现有对象来节省系统资源， 而不是每次都重新创建对象时</li><li id="ud5f81d6f">如果无法预知对象确切类别及其依赖关系时</li><li id="u9af28371">希望用户能扩展你软件库或框架的内部组件时</li></ul> 
<h2 id="S4ZVK">二、结构</h2> 
<p id="u16384237"></p> 
<p class="img-center"><img alt="" height="288" id="ucc8022a9" src="https://images2.imgbox.com/db/ee/vEcazL49_o.png" width="500"></p> 
<ol><li id="u4341f31d"><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</li><li id="ud2763a60"><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</li><li id="ud468aad0"><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</li><li id="udadc4dae"><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</li></ol> 
<h2 id="VZCxe">三、伪代码</h2> 
<pre id="oqbzD"><code class="language-python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
__doc__ = """
工厂模式
将类的实例化操作延迟到子类中完成

例：通过传入不同的操作符，实现对两个数字的加减乘除运算
"""

from abc import ABC, abstractmethod


class Product(ABC):
    """
    抽象基类
    """
    num1 = None
    num2 = None

    @abstractmethod
    def get_result(self):
        pass


class ProductAdd(Product):
    """
    具体产品类（加）
    """

    def get_result(self):
        return self.num1 + self.num2


class ProductSub(Product):
    """
    具体产品类（减）
    """

    def get_result(self):
        return self.num1 - self.num2


class ProductMul(Product):
    """
    具体产品类（乘）
    """

    def get_result(self):
        return self.num1 * self.num2


class ProductDiv(Product):
    """
    具体产品类（除）
    """

    def get_result(self):
        return self.num1 / self.num2


class ProductErr(Product):
    """
    具体产品类（错误）
    """

    def get_result(self):
        print("error")
        return 0


class Factory:
    """
    工厂类
    """
    operation = {"+": ProductAdd(), "-": ProductSub(), "*": ProductMul(), "/": ProductDiv()}

    def create_product(self, ch):
        if ch in self.operation:
            op = self.operation[ch]
        else:
            op = ProductErr()
        return op


if __name__ == "__main__":
    """
    num1: 1
    num2: 2
    ch: +
    3.0
    """
    num1 = float(input("num1: "))
    num2 = float(input("num2: "))
    ch = input("ch: ")

    factory = Factory()
    product = factory.create_product(ch)
    product.num1 = num1
    product.num2 = num2
    print(product.get_result())</code></pre> 
<h2 id="RdqU2">四、优缺点</h2> 
<h3>优点</h3> 
<ul><li id="u0e41b15f">你可以避免创建者和具体产品之间的紧密耦合。</li><li id="u1bf51d34">单一职责原则。你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li><li id="u451a17fd">开闭原则。无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li></ul> 
<h3>缺点</h3> 
<ul><li id="uaa8251c4">应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</li></ul> 
<hr> 
<p> 跳转主页：<a href="https://blog.csdn.net/weixin_44904331/article/details/135881751?spm=1001.2014.3001.5502" title="【Python笔记】设计模式-CSDN博客">【Python笔记】设计模式-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d31768767f3f47ec2551c7787a172c2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python笔记-设计模式】单例模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/450df19d18f58da9cd20307dc29da2ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python——multiprocessing报错：TypeError: cannot pickle ‘_thread.lock‘ object</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>