<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何确保单例线程安全 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何确保单例线程安全" />
<meta property="og:description" content="在多线程编程中，单例模式是一种常用的设计模式，用于确保一个类只有一个实例对象。然而，当多个线程同时访问单例对象时，可能会引发线程安全问题。本文将介绍如何确保单例线程安全，以及如何在Java中实现线程安全的单例模式。
为什么需要确保单例线程安全？ 在多线程环境下，如果多个线程同时访问一个非线程安全的单例对象，可能会导致以下问题：
重复创建实例：多个线程同时调用单例对象的创建方法，可能会导致创建多个实例，违背了单例模式的初衷。数据不一致：多个线程同时修改单例对象的状态，可能会导致数据不一致的情况，破坏了对象的完整性和一致性。性能问题：线程竞争可能导致性能下降，因为线程需要等待其他线程释放锁才能访问单例对象。 因此，确保单例线程安全是非常重要的，以避免以上问题的发生。
延迟初始化的线程安全单例模式 延迟初始化是一种常见的单例模式实现方式，即在首次使用时才创建单例对象。下面是一个线程安全的延迟初始化单例模式的示例代码：
public class LazySingleton { private static LazySingleton instance; private LazySingleton() { // 私有构造函数 } public static synchronized LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; } } 在上述示例中，getInstance() 方法使用了 synchronized 关键字来确保线程安全。它通过检查 instance 是否为 null 来判断是否需要创建新的实例。由于 synchronized 关键字的使用，每次只有一个线程能够访问 getInstance() 方法，从而避免了多个线程同时创建实例的问题。
然而，该实现方式在高并发场景下可能会带来性能问题，因为每次调用 getInstance() 方法都需要获取锁。因此，我们可以使用双重检查锁定（Double-Checked Locking）来提高性能。
双重检查锁定的线程安全单例模式 双重检查锁定是一种优化的延迟初始化单例模式实现方式。它在首次使用时才创建单例对象，并通过双重检查来避免重复创建实例的问题。下面是一个使用双重检查锁定实现的线程安全单例模式的示例代码：
public class DoubleCheckedSingleton { private static volatile DoubleCheckedSingleton instance; private DoubleCheckedSingleton() { // 私有构造函数 } public static DoubleCheckedSingleton getInstance() { if (instance == null) { synchronized (DoubleCheckedSingleton." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c5ee6d6fbcaf71e67baee0ee7880c00a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-28T11:39:12+08:00" />
<meta property="article:modified_time" content="2023-07-28T11:39:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何确保单例线程安全</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在多线程编程中，单例模式是一种常用的设计模式，用于确保一个类只有一个实例对象。然而，当多个线程同时访问单例对象时，可能会引发线程安全问题。本文将介绍如何确保单例线程安全，以及如何在Java中实现线程安全的单例模式。</p> 
<h3>为什么需要确保单例线程安全？</h3> 
<p>在多线程环境下，如果多个线程同时访问一个非线程安全的单例对象，可能会导致以下问题：</p> 
<ol><li><strong>重复创建实例</strong>：多个线程同时调用单例对象的创建方法，可能会导致创建多个实例，违背了单例模式的初衷。</li><li><strong>数据不一致</strong>：多个线程同时修改单例对象的状态，可能会导致数据不一致的情况，破坏了对象的完整性和一致性。</li><li><strong>性能问题</strong>：线程竞争可能导致性能下降，因为线程需要等待其他线程释放锁才能访问单例对象。</li></ol> 
<p>因此，确保单例线程安全是非常重要的，以避免以上问题的发生。</p> 
<h3>延迟初始化的线程安全单例模式</h3> 
<p>延迟初始化是一种常见的单例模式实现方式，即在首次使用时才创建单例对象。下面是一个线程安全的延迟初始化单例模式的示例代码：</p> 
<pre><code>public class LazySingleton {
    private static LazySingleton instance;

    private LazySingleton() {
        // 私有构造函数
    }

    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
</code></pre> 
<p>在上述示例中，<code>getInstance()</code> 方法使用了 <code>synchronized</code> 关键字来确保线程安全。它通过检查 <code>instance</code> 是否为 <code>null</code> 来判断是否需要创建新的实例。由于 <code>synchronized</code> 关键字的使用，每次只有一个线程能够访问 <code>getInstance()</code> 方法，从而避免了多个线程同时创建实例的问题。</p> 
<p>然而，该实现方式在高并发场景下可能会带来性能问题，因为每次调用 <code>getInstance()</code> 方法都需要获取锁。因此，我们可以使用双重检查锁定（Double-Checked Locking）来提高性能。</p> 
<h3>双重检查锁定的线程安全单例模式</h3> 
<p>双重检查锁定是一种优化的延迟初始化单例模式实现方式。它在首次使用时才创建单例对象，并通过双重检查来避免重复创建实例的问题。下面是一个使用双重检查锁定实现的线程安全单例模式的示例代码：</p> 
<pre><code>public class DoubleCheckedSingleton {
    private static volatile DoubleCheckedSingleton instance;

    private DoubleCheckedSingleton() {
        // 私有构造函数
    }

    public static DoubleCheckedSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
}
</code></pre> 
<p>在上述示例中，<code>getInstance()</code> 方法首先检查 <code>instance</code> 是否为 <code>null</code>，如果为 <code>null</code>，则进入同步块。在同步块内部，再次检查 <code>instance</code> 是否为 <code>null</code>，这是为了防止在同步块外部的线程已经创建了实例。使用 <code>volatile</code> 关键字修饰 <code>instance</code> 变量可以确保多线程环境下的可见性。</p> 
<p>通过双重检查锁定，我们可以避免大部分情况下的同步开销，提高性能。</p> 
<h3>饿汉式的线程安全单例模式</h3> 
<p>饿汉式是一种在类加载时就创建实例的单例模式实现方式。它在类加载时就创建了实例，并且保证了线程安全。下面是一个饿汉式的线程安全单例模式的示例代码：</p> 
<pre><code>public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {
        // 私有构造函数
    }

    public static EagerSingleton getInstance() {
        return instance;
    }
}
</code></pre> 
<p>在上述示例中，<code>instance</code> 是一个私有的、静态的、不可变的实例。由于在类加载时就创建了实例，并且没有提供公共的创建方法，因此可以确保线程安全。</p> 
<p>然而，饿汉式的缺点是在类加载时就创建实例，无法做到延迟初始化，可能会导致资源浪费。</p> 
<h3>总结</h3> 
<p>确保单例线程安全是多线程编程中的重要问题。本文介绍了延迟初始化、双重检查锁定和饿汉式三种常见的线程安全单例模式实现方式，并提供了相应的Java示例代码。在选择实现方式时，需要根据具体的业务需求和性能要求进行权衡。通过合理选择和使用单例模式，我们可以确保在多线程环境下获取到正确的单例对象，避免线程安全问题的发生。</p> 
<p>参考文献：</p> 
<ul><li><a href="https://www.jianshu.com/p/3e4a253d2a3c" rel="nofollow" title="Java并发编程：单例模式的线程安全性">Java并发编程：单例模式的线程安全性</a></li><li><a href="https://www.jianshu.com/p/5f8c4b8e5a14" rel="nofollow" title="Java并发编程：双重检查锁定">Java并发编程：双重检查锁定</a></li><li><a href="https://www.jianshu.com/p/0f0f2b6f9e8a" rel="nofollow" title="Java并发编程：饿汉式单例模式">Java并发编程：饿汉式单例模式</a></li></ul> 
<p>希望本文能够帮助你理解如何确保单例线程安全。</p> 
<p><span style="color:#956fe7;">👉 💐🌸 公众号请关注 "果酱桑", 一起学习,一起进步! 🌸💐</span><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a745314e2150d31fd6151ff34e97c23d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeScript 入门培训资料</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b96a58678fcb75f5278f78cc142d99ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git暂存区（修改待提交区）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>