<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;—— 编译时链接相关问题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;—— 编译时链接相关问题" />
<meta property="og:description" content="文章目录 1. C&#43;&#43;程序编译的工作流程1.1 预处理，得到 .i 预处理后到文件1.2 编译，得到 .s汇编程序1.3 汇编，得到 .o 目标文件1.4 链接， 得到可执行文件 2. 编译时候的一些细节2.1 头文件.h 和源文件.cpp 的区别2.2 编译器怎么去找头文件？2.3 既然我现在能找到了我要用的文件 .h，那么为什么还要把依赖库编译成 .o文件，然后再去链接呢？2.4 是否能将这个库做成类似于第三方依赖库的效果？2.6 既然我们只需要 .h 文件和 .a / .so链接库文件即可运行，那为什么每个第三方依赖库都要重新自己编译呢？参考： 首先提出几个问题： 在安装C&#43;&#43;第三方依赖库的时候，一般会有一个 .0文件，还有一些 .h文件，然后可能还会涉及到修改环境变量PATH，或者把这些编译生成的文件拷贝到一些特定的文件夹中等等。。但是，为什么要做这些操作呢？ 下面就来捋一捋这些关系
1. C&#43;&#43;程序编译的工作流程 对于一个C&#43;&#43;程序而言，从代码到可执行程序一共有四个过程：
1.1 预处理，得到 .i 预处理后到文件 将源代码的.c 、.cpp 、.h 等文件包含到一个文件中。在这个过程中会使用一些预处理指令要求编译器使用什么样的方式包含这些文件。预处理结束之后对于c语言编译器会生成一个.i 文件。C&#43;&#43;会生成.ii文件。
将所有的#define删除，并且展开所有的宏定义；处理所有条件编译指令，如#if，#ifdef等；处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。该过程递归进行，及被包含的文件可能还包含其他文件。删除所有的注释//和 /**/；添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息；保留所有的#pragma编译器指令，因为编译器须要使用它们； 1.2 编译，得到 .s汇编程序 编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件.
不同的优化等级：
O1 ：优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。O2：会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。O3：在O2的基础上进行更多的优化。例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 1.3 汇编，得到 .o 目标文件 汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。
1.4 链接， 得到可执行文件 链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。
2. 编译时候的一些细节 2.1 头文件." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/905e3ae3865a353a028b0cceb12968ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-20T20:19:46+08:00" />
<meta property="article:modified_time" content="2022-06-20T20:19:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;—— 编译时链接相关问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1_C_5" rel="nofollow">1. C++程序编译的工作流程</a></li><li><ul><li><a href="#11__i__7" rel="nofollow">1.1 预处理，得到 .i 预处理后到文件</a></li><li><a href="#12__s_18" rel="nofollow">1.2 编译，得到 .s汇编程序</a></li><li><a href="#13__o__28" rel="nofollow">1.3 汇编，得到 .o 目标文件</a></li><li><a href="#14___32" rel="nofollow">1.4 链接， 得到可执行文件</a></li></ul> 
    </li><li><a href="#2__36" rel="nofollow">2. 编译时候的一些细节</a></li><li><ul><li><a href="#21_h_cpp__37" rel="nofollow">2.1 头文件.h 和源文件.cpp 的区别</a></li><li><a href="#22__46" rel="nofollow">2.2 编译器怎么去找头文件？</a></li><li><a href="#23__h_o_63" rel="nofollow">2.3 既然我现在能找到了我要用的文件 .h，那么为什么还要把依赖库编译成 .o文件，然后再去链接呢？</a></li><li><a href="#24__119" rel="nofollow">2.4 是否能将这个库做成类似于第三方依赖库的效果？</a></li><li><a href="#26__h__a__so_148" rel="nofollow">2.6 既然我们只需要 .h 文件和 .a / .so链接库文件即可运行，那为什么每个第三方依赖库都要重新自己编译呢？</a></li><li><a href="#_154" rel="nofollow">参考：</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 首先提出几个问题： 
<br> 在安装C++第三方依赖库的时候，一般会有一个 
<code>.0</code>文件，还有一些 
<code>.h</code>文件，然后可能还会涉及到修改环境变量PATH，或者把这些编译生成的文件拷贝到一些特定的文件夹中等等。。但是，为什么要做这些操作呢？ 
<p></p> 
<p>下面就来捋一捋这些关系</p> 
<h4><a id="1_C_5"></a>1. C++程序编译的工作流程</h4> 
<p>对于一个C++程序而言，从代码到可执行程序一共有四个过程：</p> 
<h5><a id="11__i__7"></a>1.1 预处理，得到 .i 预处理后到文件</h5> 
<p>将源代码的.c 、.cpp 、.h 等文件包含到一个文件中。在这个过程中会使用一些预处理指令要求编译器使用什么样的方式包含这些文件。预处理结束之后对于c语言编译器会生成一个.i 文件。C++会生成.ii文件。</p> 
<ul><li>将所有的#define删除，并且展开所有的宏定义；</li><li>处理所有条件编译指令，如#if，#ifdef等；</li><li>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。该过程递归进行，及被包含的文件可能还包含其他文件。</li><li>删除所有的注释//和 /**/；</li><li>添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息；</li><li>保留所有的#pragma编译器指令，因为编译器须要使用它们；</li></ul> 
<h5><a id="12__s_18"></a>1.2 编译，得到 .s汇编程序</h5> 
<p>编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件.</p> 
<p>不同的优化等级：</p> 
<ul><li>O1 ：<strong><strong>优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。</strong></strong></li><li>O2：<strong><strong>会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。</strong></strong></li><li>O3：<strong><strong>在O2的基础上进行更多的优化。例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。</strong></strong></li></ul> 
<h5><a id="13__o__28"></a>1.3 汇编，得到 .o 目标文件</h5> 
<p>汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。</p> 
<h5><a id="14___32"></a>1.4 链接， 得到可执行文件</h5> 
<p>链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。</p> 
<h4><a id="2__36"></a>2. 编译时候的一些细节</h4> 
<h5><a id="21_h_cpp__37"></a>2.1 头文件.h 和源文件.cpp 的区别</h5> 
<p>头文件<code>.h</code>：内含函数声明、宏定义、结构体定义等内容。<br> 源文件<code>.cpp</code>：内含函数实现，变量定义等内容。</p> 
<p>实际上头文件和源文件没有区别，只不过是通过这两种文件来形成良好的代码风格。在编译的时候，一般默认都是对源文件<code>.cpp</code>进行编译，源文件中一般都会<code>#include "***.h"</code>，这个时候会把头文件<code>.h</code>中的代码都拷贝到源代码中，然后再进行编译。</p> 
<p>此时有一个问题，<strong>如果多个源文件都包含了同一个头文件，那么头文件中定义的一些变量会不会发生冲突呢？如果发生了，该怎么解决呢？</strong><br> 答案是会发生，但是可以解决，解决办法就是<code>ifndef</code>关键字，利用这个关键字，保证在一个可执行文件中，头文件代码不会被拷贝多次。</p> 
<h5><a id="22__46"></a>2.2 编译器怎么去找头文件？</h5> 
<p>在使用一些IDE的时候，它们已经帮忙做好了这些工作，会在编译的时候帮我们添加头文件路径，但是我们自己去编译的时候，比如书写CMakeLists、配置vscode时，就会发现，需要我们手动的去添加头文件路径。比如写CMakeLists.txt时，此时我的文件夹路径是：</p> 
<pre><code>/MyProject
    |-/include/test.h
    |-/src/test.cpp       
    |-/example/main.cpp                 
</code></pre> 
<p>此时，我们要在编译的时候，告诉编译器，去哪里找到<code>test.h</code>这个头文件，因此就需要手动添加：</p> 
<pre><code>include_directories(${CMAKE_CURRENT_BINARY_DIR}/include)
</code></pre> 
<p>这一行就表示，我们把当前编译目录底下的<code>include</code>文件夹囊括进来了，找头文件的时候可以在这个里面找。</p> 
<p><strong>那么其他的一些系统文件呢？</strong><br> 答案是编译器会从系统的目录中进行查找，但一般是优先查找用户手动指定的，如果有冲突，那么会优先使用用户自己设定的。并且，在使用<code>#include</code>关键字的时候，使用<code>&lt;***&gt;</code>括号表示优先从系统目录中找，使用<code>"***.h"</code>表示从优先自身定义的目录中找。</p> 
<h5><a id="23__h_o_63"></a>2.3 既然我现在能找到了我要用的文件 .h，那么为什么还要把依赖库编译成 .o文件，然后再去链接呢？</h5> 
<p>这个问题，以前也困扰了我很久，但是一直没有花时间花心思去解决它。</p> 
<p>首先，头文件中，一般都是函数定义，具体实现都会在<code>.cpp</code>文件中。另外，C/C++的编译都是针对cpp文件进行的，当我们使用了其他文件中的内容时候，会通过编译的最后一步<strong>链接</strong>来进行处理。<br> 比如现在有一个文件结构：</p> 
<pre><code>/my_lib
	|
	|--/addlib
	|--/addlib/add.h
	|--/addlib/add.cpp
	|--test.cpp
</code></pre> 
<p>我们在<code>add.h</code>中，声明一个函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_ADD_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__ADD_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>我们在<code>add.cpp</code>中，对声明的函数进行定义</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"add.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>定义完成，此时我们对这个文件进行编译，编译成一个静态库，此时使用<code>g++</code>，参数为<code>-c</code>，该命令会生成汇编文件，文件中是二进制代码<br> <img src="https://images2.imgbox.com/2b/de/KOcTI1Jw_o.png" alt="在这里插入图片描述"><br> 编译出错，是因为未在<code>add.cpp</code>同等文件夹底下进行编译，目标找不到<code>add.h</code>头文件（一般是在同级目录中找，然后再就是从系统环境变量<code>PATH</code>中找）。在一般的IDE，如Visual Studio中，是可以忽略这一步的，因为在这种IDE中，会自动帮你处理好这种，它会有一个类似 <code>include ${currentPath}/*/*.h</code>的步骤。</p> 
<p>下一步就是将汇编代码，打包成静态库，用<code>ar</code>命令，第一个参数是生成后的名字，往后的参数就是所有的打包文件<br> <img src="https://images2.imgbox.com/57/a0/qmHXmhAp_o.png" alt="在这里插入图片描述"><br> 可以看到，此时有<code>.a</code>文件生成，下一步就可以在其他代码中进行链接了，在<code>test.cpp</code>文件中有</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"./addlib/add.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> number1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> number2 <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the result is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span>number1<span class="token punctuation">,</span> number2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译：<br> <img src="https://images2.imgbox.com/76/b5/844zsTYZ_o.png" alt="在这里插入图片描述"><br> 此时我们还没有告诉编译器，去哪里找我们这个头文件，去哪里找这个静态库，默认是去系统目录中，但没有找到，所以报错，因此需要加上参数<code>-L</code>，告诉编译器去那里找静态文件，然后在加上静态库的名字，名字的规则一般是 <code>-l</code> + 库名，比如我们这个，就是<code>-ladd</code>。</p> 
<p><img src="https://images2.imgbox.com/d1/48/z4sR7BsA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="24__119"></a>2.4 是否能将这个库做成类似于第三方依赖库的效果？</h5> 
<p>答案是可以！</p> 
<p>首先，修改<code>test.cpp</code>的include，实际上第一次就应该这样写，应该默认是从同级目录底下找</p> 
<pre><code>#include &lt;iostream&gt;
#include "addlib/add.h"
using namespace std;

int main(){
    int number1 = 10;
    int number2 = 90;
    cout &lt;&lt; "the result is " &lt;&lt; add(number1, number2) &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>然后，我们去<code>/usr/local/lib</code>文件夹底下，做一个软链接</p> 
<pre><code class="prism language-bash"><span class="token function">ln</span> -s /root/codingFile/my_lib/addlib/libadd.a 
</code></pre> 
<p>同样的，在<code>/usr/local/include</code>文件夹底下，做一个软链接</p> 
<pre><code class="prism language-bash"><span class="token function">ln</span> -s /root/codingFile/my_lib/addlib
</code></pre> 
<p>此时，<code>test.cpp</code>无论在哪个文件夹底下，都能够正常编译运行！<br> <img src="https://images2.imgbox.com/a7/11/psbFwgtw_o.png" alt="在这里插入图片描述"><br> 原理就是编译器会从系统目录中去寻找对应的链接，实际上，第三方依赖库也是这种做法，所以在几个特定的系统目录下，能够看到很多的静态链接，动态链接。</p> 
<h5><a id="26__h__a__so_148"></a>2.6 既然我们只需要 .h 文件和 .a / .so链接库文件即可运行，那为什么每个第三方依赖库都要重新自己编译呢？</h5> 
<p>在入门计算机视觉的时候，第一步就是编译<code>opencv</code>，当时也是踩坑无数，后来学到了<code>RPC</code>，编译过<code>bRPC</code> ，<code>protobuf</code>这些，也踩过坑，但是一直没有像现在这样缕清思路。</p> 
<p>好了回到这个问题，为什么要重新编译一次呢？这是因为每台机器环境配置不一样，可以看到有些第三方依赖库是对<code>CMake</code>，<code>gcc</code>，<code>g++</code>这些对版本都是有要求的，不同的版本可能会造成不同的差异，因此，需要手动编译。C++的痛点也在这里，并没有一个很规范的包管理，不像<code>python</code>，<code>Golang</code>这些语言，拥有比较好的包管理机制。</p> 
<h5><a id="_154"></a>参考：</h5> 
<p><a href="https://www.cnblogs.com/52php/p/5681711.html" rel="nofollow">C/C++ 静态链接库(.a) 与 动态链接库(.so)</a><br> <a href="https://www.cnblogs.com/guojun-junguo/p/10429568.html" rel="nofollow">头文件和库文件-静态库和动态库</a><br> <a href="https://blog.csdn.net/gukesdo/article/details/6817201">c++的工程文件的编译顺序</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd1acc12d3e763149ea5c6ac42d4cc9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue不用脚手架直接引用elementui组件（完整全过程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1dd640782622f09235ea3dce9a88932/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java项目:校园报修管理系统(java&#43;Springboot&#43;bootstrap&#43;JSP&#43;maven&#43;Mysql)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>