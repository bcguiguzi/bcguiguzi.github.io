<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s miniKube 入门 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s miniKube 入门" />
<meta property="og:description" content="k8s miniKube 入门 miniKube 是单机版kubernetes, 可以配置运行在同一台主机上的服务和pod，并使用docker作为虚拟化工具
下载：直接下载可执行文件，复制到path 路径，免安装。
启动：minikube 支持多种虚拟化工具，如：virtualbox, 不过在linux里可以支持docker
minikube start --vm-driver=none 等待一会最终输出 * Done! kubectl is now configured to use &#34;minikube&#34;
由于需要下载很多支持的东西，经常失败，最好添加74.125.204.82 k8s.gcr.io 到hosts文件。
然后创建一个Deployment
kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.10 --port=8080 这个镜像下载比较慢，可以下载阿里的registry.cn-qingdao.aliyuncs.com/k8slast/echoserver 即
kubectl run hello-minikube --image=registry.cn-qingdao.aliyuncs.com/k8slast/echoserver --port=8080 输出：deployment.apps/hello-minikube created
再将deployment 暴露成服务
kubectl expose deployment hello-minikube --type=NodePort 输出：service/hello-minikube exposed
最后获取访问url
minikube service hello-minikube --url 输出访问url：http:://xxxxx:port
通过url可以访问服务资源
删除服务资源
先删除服务: minikube delete service hello-minikube再删除deployment： minikube delete deployment hello-minikube最后删除minikube集群 minikube stop &amp;&amp; minikube delete 一个简单的演示完成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3ff122afd6b73b99a1e80d3e80b35c41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-22T15:34:00+08:00" />
<meta property="article:modified_time" content="2019-07-22T15:34:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s miniKube 入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h2 id="k8s-minikube-入门">k8s miniKube 入门</h2> 
 <p>miniKube 是单机版kubernetes, 可以配置运行在同一台主机上的服务和pod，并使用docker作为虚拟化工具</p> 
 <ol><li><p>下载：直接下载可执行文件，复制到path 路径，免安装。</p></li><li><p>启动：minikube 支持多种虚拟化工具，如：virtualbox, 不过在linux里可以支持docker</p> <pre class="bash"><code>minikube start --vm-driver=none</code></pre> <p>等待一会最终输出 <code>* Done! kubectl is now configured to use "minikube"</code></p> <p>由于需要下载很多支持的东西，经常失败，最好添加<code>74.125.204.82 k8s.gcr.io</code> 到hosts文件。</p></li><li><p>然后创建一个Deployment</p> <pre class="bash"><code>kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.10 --port=8080</code></pre> <p>这个镜像下载比较慢，可以下载阿里的<code>registry.cn-qingdao.aliyuncs.com/k8slast/echoserver</code> 即</p> <pre class="bash"><code>kubectl run hello-minikube --image=registry.cn-qingdao.aliyuncs.com/k8slast/echoserver --port=8080</code></pre> <p>输出：<code>deployment.apps/hello-minikube created</code></p></li><li><p>再将deployment 暴露成服务</p> <pre class="bash"><code>kubectl expose deployment hello-minikube --type=NodePort</code></pre> <p>输出：<code>service/hello-minikube exposed</code></p></li><li><p>最后获取访问url</p> <pre class="bash"><code>minikube service hello-minikube --url</code></pre> <p>输出访问url：<a href="%3A//xxxxx:port" rel="nofollow" class="uri">http:://xxxxx:port</a></p> <p>通过url可以访问服务资源</p></li></ol> 
 <p>删除服务资源</p> 
 <ol><li>先删除服务: <code>minikube delete service hello-minikube</code></li><li>再删除deployment： <code>minikube delete deployment hello-minikube</code></li><li>最后删除minikube集群 <code>minikube stop &amp;&amp; minikube delete</code></li></ol> 
 <p>一个简单的演示完成</p> 
 <h3 id="通过yaml-文件管理服务和deployment">通过yaml 文件管理服务和deployment</h3> 
 <ul><li>通过yaml 文件管理好处是可以通过git 来管理yaml文件，</li><li>yaml的格式简单，只有maps 和 lists，两者可以相互嵌套</li><li>minikube 的很多命令可以使用 <code>--dry-run -o yaml</code> 来导出yaml 文件，简化编写效率</li></ul> 
 <h4 id="首先看一个-yaml">首先看一个 yaml</h4> 
 <pre class="yaml"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    run: myapp
  name: myapp
spec:
  replicas: 1
  selector:
    matchLabels:
      run: myapp
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        run: myapp
    spec:
      containers:
      - image: 'springboot'
        name: myapp
        ports:
        - containerPort: 8088
        resources: {}
status: {}
</code></pre> 
 <p>这里说明一下参数</p> 
 <ul><li><p>kind：Deployment, 这里表示这个yaml是用来生成deploy的，另外还有Service，</p></li><li><p>replicas: 1 这个表示备份的个数，1个表示一个pod</p></li></ul> 
 <p>其他配置看字面意思可以理解。</p> 
 <p>这个yaml是通过dry-run 生成的，dry-run 意思是只跑一遍，但不会生成资源</p> 
 <pre class="bash"><code>minikube run myapp --image=springboot --port=8088 --dry-on -o yaml</code></pre> 
 <p>将命令的输出保存到demo.yaml， 有了yaml 文件可以直接指定文件执行,跟上面的命令一样的效果</p> 
 <pre class="bash"><code>minikube create -f demo.yaml</code></pre> 
 <p>另外再写服务的yaml</p> 
 <pre class="yaml"><code>apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    run: myapp
  name: myapp
spec:
  ports:
  - port: 8088
    protocol: TCP
    targetPort: 8088
    nodePort: 30001
  selector:
    run: myapp
  type: NodePort
status:
  loadBalancer: {}
</code></pre> 
 <p>命令导出的yaml 需要手动添加 nodePort 参数，暴露到外部的端口</p> 
 <ul><li>port : 8088 表示集群内部访问端口，集群里的多个服务可以通过这个端口访问</li><li>targetPort: 8088 是本pod 的监听端口，springboot 监听在8088</li><li>nodePort 才是暴露在外面的端口</li></ul> 
 <p>另外，为了避免与主机其他服务冲突， nodePort 默认范围在30000-32767</p> 
 <p>然后通过指定yaml 来暴露服务，效果与命令执行一样</p> 
 <pre class="bash"><code>minikube expose -f demo_service.yaml</code></pre> 
 <p>最后通过命令获取url <code>minikube service myapp --url</code></p> 
 <p>通过yaml文件可以删除服务和deploy:</p> 
 <p><code>minikube delete -f demo_service.yaml</code></p> 
 <p><code>minikube delete -f demo.yaml</code></p> 
</div> 
<p>转载于:https://www.cnblogs.com/hustcpp/p/11226195.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5ef9b1859e2d6e6a18dabcf7efcb978/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用java将word文档docx，doc（包含图形，文本框）完美转换成所有格式图片（pdf，png，gif，jpeg等等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8eaa7adf251c8da5724f061529bd747/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Program type already present</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>