<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java日常开发的21个坑，你踩过几个？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java日常开发的21个坑，你踩过几个？" />
<meta property="og:description" content="1. 六类典型空指针问题 包装类型的空指针问题
级联调用的空指针问题
Equals方法左边的空指针问题
ConcurrentHashMap 这样的容器不支持 Key 和 Value 为 null。
集合，数组直接获取元素
对象直接获取属性
1.1包装类型的空指针问题 public class NullPointTest { public static void main(String[] args) throws InterruptedException { System.out.println(testInteger(null)); } private static Integer testInteger(Integer i) { return i &#43; 1; //包装类型，传参可能为null，直接计算，则会导致空指针问题 } } 1.2 级联调用的空指针问题 public class NullPointTest { public static void main(String[] args) { //fruitService.getAppleService() 可能为空，会导致空指针问题 fruitService.getAppleService().getWeight().equals(&#34;OK&#34;); } } 1.3 Equals方法左边的空指针问题 public class NullPointTest { public static void main(String[] args) { String s = null; if (s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d013a9155a01f6cc7815c3e6a376da5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-22T09:23:31+08:00" />
<meta property="article:modified_time" content="2024-02-22T09:23:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java日常开发的21个坑，你踩过几个？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1. 六类典型空指针问题</h4> 
<ul><li> <p>包装类型的空指针问题</p> </li><li> <p>级联调用的空指针问题</p> </li><li> <p>Equals方法左边的空指针问题</p> </li><li> <p>ConcurrentHashMap 这样的容器不支持 Key 和 Value 为 null。</p> </li><li> <p>集合，数组直接获取元素</p> </li><li> <p>对象直接获取属性</p> </li></ul> 
<h5>1.1包装类型的空指针问题</h5> 
<pre><code>public class NullPointTest {

    public static void main(String[] args) throws InterruptedException {
        System.out.println(testInteger(null));
    }

    private static Integer testInteger(Integer i) {
        return i + 1;  //包装类型，传参可能为null，直接计算，则会导致空指针问题
    }
}
</code></pre> 
<h5>1.2 级联调用的空指针问题</h5> 
<pre><code>public class NullPointTest {
    public static void main(String[] args) {
       //fruitService.getAppleService() 可能为空，会导致空指针问题
        fruitService.getAppleService().getWeight().equals("OK");
    }
}
</code></pre> 
<h5>1.3 Equals方法左边的空指针问题</h5> 
<pre><code>public class NullPointTest {
    public static void main(String[] args) {
        String s = null;
        if (s.equals("666")) { //s可能为空，会导致空指针问题
            System.out.println("公众号：java小白翻身");
        }
    }
}
</code></pre> 
<h5>1.4 ConcurrentHashMap 这样的容器不支持 Key，Value 为 null。</h5> 
<pre><code>public class NullPointTest {
    public static void main(String[] args) {
        Map map = new ConcurrentHashMap&lt;&gt;();
        String key = null;
        String value = null;
        map.put(key, value);
    }
}
</code></pre> 
<h5>1.5  集合，数组直接获取元素</h5> 
<pre><code>public class NullPointTest {
    public static void main(String[] args) {
        int [] array=null;
        List list = null;
        System.out.println(array[0]); //空指针异常
        System.out.println(list.get(0)); //空指针一场
    }
}
</code></pre> 
<h5>1.6 对象直接获取属性</h5> 
<pre><code>public class NullPointTest {
    public static void main(String[] args) {
        User user=null;
        System.out.println(user.getAge()); //空指针异常
    }
}
</code></pre> 
<h4>2. 日期YYYY格式设置的坑</h4> 
<p>日常开发，经常需要对日期格式化，但是呢，年份设置为YYYY大写的时候，是有坑的哦。</p> 
<p>反例：</p> 
<pre><code>Calendar calendar = Calendar.getInstance();
calendar.set(2019, Calendar.DECEMBER, 31);

Date testDate = calendar.getTime();

SimpleDateFormat dtf = new SimpleDateFormat("YYYY-MM-dd");
System.out.println("2019-12-31 转 YYYY-MM-dd 格式后 " + dtf.format(testDate));

</code></pre> 
<p>运行结果：</p> 
<pre><code>2019-12-31 转 YYYY-MM-dd 格式后 2020-12-31
</code></pre> 
<p><strong>「解析：」</strong></p> 
<p>为什么明明是2019年12月31号，就转了一下格式，就变成了2020年12月31号了？因为YYYY是基于周来计算年的，它指向当天所在周属于的年份，一周从周日开始算起，周六结束，只要本周跨年，那么这一周就算下一年的了。正确姿势是使用yyyy格式。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="553" src="https://images2.imgbox.com/eb/d8/yXxz4SNa_o.png" width="553"></p> 
<p>正例：</p> 
<pre><code>Calendar calendar = Calendar.getInstance();
calendar.set(2019, Calendar.DECEMBER, 31);

Date testDate = calendar.getTime();

SimpleDateFormat dtf = new SimpleDateFormat("yyyy-MM-dd");
System.out.println("2019-12-31 转 yyyy-MM-dd 格式后 " + dtf.format(testDate));

</code></pre> 
<h4>3.金额数值计算精度的坑</h4> 
<p>看下这个浮点数计算的例子吧：</p> 
<pre><code>public class DoubleTest {
    public static void main(String[] args) {
        System.out.println(0.1+0.2);
        System.out.println(1.0-0.8);
        System.out.println(4.015*100);
        System.out.println(123.3/100);

        double amount1 = 3.15;
        double amount2 = 2.10;
        if (amount1 - amount2 == 1.05){
            System.out.println("OK");
        }
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>0.30000000000000004
0.19999999999999996
401.49999999999994
1.2329999999999999
</code></pre> 
<p>可以发现，结算结果跟我们预期不一致，其实是因为计算机是以二进制存储数值的，对于浮点数也是。对于计算机而言，0.1无法精确表达，这就是为什么浮点数会导致精确度缺失的。因此，<strong>「金额计算，一般都是用BigDecimal 类型」</strong></p> 
<p>对于以上例子，我们改为BigDecimal，再看看运行效果：</p> 
<pre><code>System.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));
System.out.println(new BigDecimal(1.0).subtract(new BigDecimal(0.8)));
System.out.println(new BigDecimal(4.015).multiply(new BigDecimal(100)));
System.out.println(new BigDecimal(123.3).divide(new BigDecimal(100)));
</code></pre> 
<p>运行结果：</p> 
<pre><code>0.3000000000000000166533453693773481063544750213623046875
0.1999999999999999555910790149937383830547332763671875
401.49999999999996802557689079549163579940795898437500
1.232999999999999971578290569595992565155029296875
</code></pre> 
<p>发现结果还是不对，<strong>「其实」</strong>，使用 BigDecimal 表示和计算浮点数，必须使用<strong>「字符串的构造方法」</strong>来初始化 BigDecimal，正例如下：</p> 
<pre><code>public class DoubleTest {
    public static void main(String[] args) {
        System.out.println(new BigDecimal("0.1").add(new BigDecimal("0.2")));
        System.out.println(new BigDecimal("1.0").subtract(new BigDecimal("0.8")));
        System.out.println(new BigDecimal("4.015").multiply(new BigDecimal("100")));
        System.out.println(new BigDecimal("123.3").divide(new BigDecimal("100")));
    }
}
</code></pre> 
<p>在进行金额计算，使用BigDecimal的时候，我们还需要<strong>「注意BigDecimal的几位小数点，还有它的八种舍入模式哈」</strong>。</p> 
<h4>4. FileReader默认编码导致乱码问题</h4> 
<p>看下这个例子：</p> 
<pre><code>public class FileReaderTest {
    public static void main(String[] args) throws IOException {

        Files.deleteIfExists(Paths.get("jay.txt"));
        Files.write(Paths.get("jay.txt"), "你好,java小白翻身".getBytes(Charset.forName("GBK")));
        System.out.println("系统默认编码："+Charset.defaultCharset());

        char[] chars = new char[10];
        String content = "";
        try (FileReader fileReader = new FileReader("jay.txt")) {
            int count;
            while ((count = fileReader.read(chars)) != -1) {
                content += new String(chars, 0, count);
            }
        }
        System.out.println(content);
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>系统默认编码：UTF-8
���,�����ݵ�С�к�
</code></pre> 
<p>从运行结果，可以知道，系统默认编码是utf8，demo中读取出来，出现乱码了。为什么呢？</p> 
<blockquote>
  ❝ 
 <p>FileReader 是以当<strong>「前机器的默认字符集」</strong>来读取文件的，如果希望指定字符集的话，需要直接使用 InputStreamReader 和 FileInputStream。</p> ❞ 
</blockquote> 
<p>正例如下：</p> 
<pre><code>public class FileReaderTest {
    public static void main(String[] args) throws IOException {

        Files.deleteIfExists(Paths.get("jay.txt"));
        Files.write(Paths.get("jay.txt"), "你好,java小白翻身".getBytes(Charset.forName("GBK")));
        System.out.println("系统默认编码："+Charset.defaultCharset());

        char[] chars = new char[10];
        String content = "";
        try (FileInputStream fileInputStream = new FileInputStream("jay.txt");
             InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, Charset.forName("GBK"))) {
            int count;
            while ((count = inputStreamReader.read(chars)) != -1) {
                content += new String(chars, 0, count);
            }
        }
        System.out.println(content);
    }
}
</code></pre> 
<h4>5. Integer缓存的坑</h4> 
<pre><code>public class IntegerTest {

    public static void main(String[] args) {
        Integer a = 127;
        Integer b = 127;
        System.out.println("a==b:"+ (a == b));
        
        Integer c = 128;
        Integer d = 128;
        System.out.println("c==d:"+ (c == d));
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>a==b:true
c==d:false
</code></pre> 
<p>为什么Integer值如果是128就不相等了呢？<strong>「编译器会把 Integer a = 127 转换为 Integer.valueOf(127)。」</strong> 我们看下源码。</p> 
<pre><code>public static Integer valueOf(int i) {
      if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
          return IntegerCache.cache[i + (-IntegerCache.low)];
      return new Integer(i);
 }
</code></pre> 
<p>可以发现，i在一定范围内，是会返回缓存的。</p> 
<blockquote>
  ❝ 
 <p>默认情况下呢，这个缓存区间就是[-128, 127]，所以我们业务日常开发中，如果涉及Integer值的比较，需要注意这个坑哈。还有呢，设置 JVM 参数加上 -XX:AutoBoxCacheMax=1000，是可以调整这个区间参数的，大家可以自己试一下哈</p> ❞ 
</blockquote> 
<h4>6. static静态变量依赖spring实例化变量，可能导致初始化出错</h4> 
<p>之前看到过类似的代码。静态变量依赖于spring容器的bean。</p> 
<pre><code> private static SmsService smsService = SpringContextUtils.getBean(SmsService.class);
</code></pre> 
<p>这个静态的smsService有可能获取不到的，因为类加载顺序不是确定的，正确的写法可以这样，如下：</p> 
<pre><code> private static SmsService  smsService =null;
 
 //使用到的时候采取获取
 public static SmsService getSmsService(){
   if(smsService==null){
      smsService = SpringContextUtils.getBean(SmsService.class);
   }
   return smsService;
 }
</code></pre> 
<h4>7. 使用ThreadLocal，线程重用导致信息错乱的坑</h4> 
<p>使用ThreadLocal缓存信息，有可能出现信息错乱的情况。看下下面这个例子吧。</p> 
<pre><code>private static final ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; null);

@GetMapping("wrong")
public Map wrong(@RequestParam("userId") Integer userId) {
    //设置用户信息之前先查询一次ThreadLocal中的用户信息
    String before  = Thread.currentThread().getName() + ":" + currentUser.get();
    //设置用户信息到ThreadLocal
    currentUser.set(userId);
    //设置用户信息之后再查询一次ThreadLocal中的用户信息
    String after  = Thread.currentThread().getName() + ":" + currentUser.get();
    //汇总输出两次查询结果
    Map result = new HashMap();
    result.put("before", before);
    result.put("after", after);
    return result;
}
</code></pre> 
<p>按理说，每次获取的before应该都是null，但是呢，程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。</p> 
<blockquote>
  ❝ 
 <p>线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。</p> ❞ 
</blockquote> 
<p>把tomcat的工作线程设置为1</p> 
<pre><code>server.tomcat.max-threads=1
</code></pre> 
<p>用户1，请求过来，会有以下结果，符合预期：</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/25/f3/87xli1ce_o.png" width="1038"></p> 
<p>用户2请求过来，会有以下结果，<strong>「不符合预期」</strong>：</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/a9/9b/hXeA9Oa6_o.png" width="1042"></p> 
<p>因此，使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据，正例如下：</p> 
<pre><code>@GetMapping("right")
public Map right(@RequestParam("userId") Integer userId) {
    String before  = Thread.currentThread().getName() + ":" + currentUser.get();
    currentUser.set(userId);
    try {
        String after = Thread.currentThread().getName() + ":" + currentUser.get();
        Map result = new HashMap();
        result.put("before", before);
        result.put("after", after);
        return result;
    } finally {
        //在finally代码块中删除ThreadLocal中的数据，确保数据不串
        currentUser.remove();
    }
}
</code></pre> 
<h4>8. 疏忽switch的return和break</h4> 
<p>这一点严格来说，应该不算坑，但是呢，大家写代码的时候，有些朋友容易疏忽了。直接看例子吧</p> 
<pre><code>/*
 * 关注公众号：
 * java小白翻身
 */
public class SwitchTest {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("testSwitch结果是："+testSwitch("1"));
    }

    private static String testSwitch(String key) {
        switch (key) {
            case "1":
                System.out.println("1");
            case "2":
                System.out.println(2);
                return "2";
            case "3":
                System.out.println("3");
            default:
                System.out.println("返回默认值");
                return "4";
        }
    }
}
</code></pre> 
<p>输出结果：</p> 
<pre><code>测试switch
1
2
testSwitch结果是：2
</code></pre> 
<p>switch 是会<strong>「沿着case一直往下匹配的，知道遇到return或者break。」</strong> 所以，在写代码的时候留意一下，是不是你要的结果。</p> 
<h4>9. Arrays.asList的几个坑</h4> 
<h5>9.1 基本类型不能作为 Arrays.asList方法的参数，否则会被当做一个参数。</h5> 
<pre><code>public class ArrayAsListTest {
    public static void main(String[] args) {
        int[] array = {1, 2, 3};
        List list = Arrays.asList(array);
        System.out.println(list.size());
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>1
</code></pre> 
<p>Arrays.asList源码如下：</p> 
<pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
    return new ArrayList&lt;&gt;(a);
}
</code></pre> 
<h5>9.2 Arrays.asList 返回的 List 不支持增删操作。</h5> 
<pre><code>public class ArrayAsListTest {
    public static void main(String[] args) {
        String[] array = {"1", "2", "3"};
        List list = Arrays.asList(array);
        list.add("5");
        System.out.println(list.size());
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.AbstractList.add(AbstractList.java:148)
 at java.util.AbstractList.add(AbstractList.java:108)
 at object.ArrayAsListTest.main(ArrayAsListTest.java:11)
</code></pre> 
<p>Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。内部类的ArrayList没有实现add方法，而是父类的add方法的实现，是会抛出异常的呢。</p> 
<h5>9.3 使用Arrays.asLis的时候，对原始数组的修改会影响到我们获得的那个List</h5> 
<pre><code>public class ArrayAsListTest {
    public static void main(String[] args) {
        String[] arr = {"1", "2", "3"};
        List list = Arrays.asList(arr);
        arr[1] = "4";
        System.out.println("原始数组"+Arrays.toString(arr));
        System.out.println("list数组" + list);
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>原始数组[1, 4, 3]
list数组[1, 4, 3]
</code></pre> 
<p>从运行结果可以看到，原数组改变，Arrays.asList转化来的list也跟着改变啦，大家使用的时候要注意一下哦，可以用new ArrayList(Arrays.asList(arr))包一下的。</p> 
<h5>10. ArrayList.toArray() 强转的坑</h5> 
<pre><code>public class ArrayListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;(1);
        list.add("公众号：java小白翻身");
        String[] array21 = (String[])list.toArray();//类型转换异常
    }
}
</code></pre> 
<p>因为返回的是Object类型，Object类型数组强转String数组，会发生ClassCastException。解决方案是，使用toArray()重载方法toArray(T[] a)</p> 
<pre><code>String[] array1 = list.toArray(new String[0]);//可以正常运行
</code></pre> 
<h4>11. 异常使用的几个坑</h4> 
<h5>11.1 不要弄丢了你的堆栈异常信息</h5> 
<pre><code>public void wrong1(){
    try {
        readFile();
    } catch (IOException e) {
        //没有把异常e取出来，原始异常信息丢失  
        throw new RuntimeException("系统忙请稍后再试");
    }
}

public void wrong2(){
    try {
        readFile();
    } catch (IOException e) {
        //只保留了异常消息，栈没有记录啦
        log.error("文件读取错误, {}", e.getMessage());
        throw new RuntimeException("系统忙请稍后再试");
    }
}
</code></pre> 
<p>正确的打印方式，应该酱紫</p> 
<pre><code>public void right(){
    try {
        readFile();
    } catch (IOException e) {
        //把整个IO异常都记录下来，而不是只打印消息
        log.error("文件读取错误", e);
        throw new RuntimeException("系统忙请稍后再试");
    }
}
</code></pre> 
<h5>11.2 不要把异常定义为静态变量</h5> 
<pre><code>public void testStaticExeceptionOne{
    try {
        exceptionOne();
    } catch (Exception ex) {
        log.error("exception one error", ex);
    }
    try {
        exceptionTwo();
    } catch (Exception ex) {
        log.error("exception two error", ex);
    }
}

private void exceptionOne() {
    //这里有问题
    throw Exceptions.ONEORTWO;
}

private void exceptionTwo() {
    //这里有问题
    throw Exceptions.ONEORTWO;
}
</code></pre> 
<p>exceptionTwo抛出的异常，很可能是 exceptionOne的异常哦。正确使用方法，应该是new 一个出来。</p> 
<pre><code>private void exceptionTwo() {
    throw new BusinessException("业务异常", 0001);
}
</code></pre> 
<h5>11.3 生产环境不要使用e.printStackTrace();</h5> 
<pre><code>public void wrong(){
    try {
        readFile();
    } catch (IOException e) {
       //生产环境别用它
        e.printStackTrace();
    }
}
</code></pre> 
<p>因为它占用太多内存，造成锁死，并且，日志交错混合，也不易读。正确使用如下：</p> 
<pre><code>log.error("异常日志正常打印方式",e);
</code></pre> 
<h5>11.4 线程池提交过程中，出现异常怎么办？</h5> 
<pre><code>public class ThreadExceptionTest {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        IntStream.rangeClosed(1, 10).forEach(i -&gt; executorService.submit(()-&gt; {
                    if (i == 5) {
                        System.out.println("发生异常啦");
                        throw new RuntimeException("error");
                    }
                    System.out.println("当前执行第几:" + Thread.currentThread().getName() );
                }
        ));
        executorService.shutdown();
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>当前执行第几:pool-1-thread-1
当前执行第几:pool-1-thread-2
当前执行第几:pool-1-thread-3
当前执行第几:pool-1-thread-4
发生异常啦
当前执行第几:pool-1-thread-6
当前执行第几:pool-1-thread-7
当前执行第几:pool-1-thread-8
当前执行第几:pool-1-thread-9
当前执行第几:pool-1-thread-10
</code></pre> 
<p>可以发现，如果是使用submit方法提交到线程池的异步任务，异常会被吞掉的，所以在日常发现中，如果会有可预见的异常，可以采取这几种方案处理：</p> 
<ul><li> <p>1.在任务代码try/catch捕获异常</p> </li><li> <p>2.通过Future对象的get方法接收抛出的异常，再处理</p> </li><li> <p>3.为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</p> </li><li> <p>4.重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</p> </li></ul> 
<h5>11.5 finally重新抛出的异常也要注意啦</h5> 
<pre><code>public void wrong() {
    try {
        log.info("try");
        //异常丢失
        throw new RuntimeException("try");
    } finally {
        log.info("finally");
        throw new RuntimeException("finally");
    }
}
</code></pre> 
<p>一个方法是不会出现两个异常的呢，所以finally的异常会把try的<strong>「异常覆盖」</strong>。正确的使用方式应该是，finally 代码块<strong>「负责自己的异常捕获和处理」</strong>。</p> 
<pre><code>public void right() {
    try {
        log.info("try");
        throw new RuntimeException("try");
    } finally {
        log.info("finally");
        try {
            throw new RuntimeException("finally");
        } catch (Exception ex) {
            log.error("finally", ex);
        }
    }
}
</code></pre> 
<h4>12.JSON序列化,Long类型被转成Integer类型！</h4> 
<pre><code>public class JSONTest {
    public static void main(String[] args) {

        Long idValue = 3000L;
        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(2);
        data.put("id", idValue);
        data.put("name", "Jack");

        Assert.assertEquals(idValue, (Long) data.get("id"));
        String jsonString = JSON.toJSONString(data);

        // 反序列化时Long被转为了Integer
        Map map = JSON.parseObject(jsonString, Map.class);
        Object idObj = map.get("id");
        System.out.println("反序列化的类型是否为Integer："+(idObj instanceof Integer));
        Assert.assertEquals(idValue, (Long) idObj);
    }
}
</code></pre> 
<p><strong>「运行结果：」</strong></p> 
<pre><code>Exception in thread "main" 反序列化的类型是否为Integer：true
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long
 at object.JSONTest.main(JSONTest.java:24)
</code></pre> 
<blockquote>
  ❝ 
 <p><strong>「注意啦」</strong>，序列化为Json串后，Josn串是没有Long类型呢。而且反序列化回来如果也是Object接收，数字小于Interger最大值的话，给转成Integer啦！</p> ❞ 
</blockquote> 
<h4>13. 使用Executors声明线程池，newFixedThreadPool的OOM问题</h4> 
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
            executor.execute(() -&gt; {
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    //do nothing
                }
            });
        }
</code></pre> 
<p><strong>「IDE指定JVM参数：-Xmx8m -Xms8m :」</strong></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="748" src="https://images2.imgbox.com/41/de/TlvSdSu2_o.jpg" width="1080"></p> 
<p>运行结果：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="597" src="https://images2.imgbox.com/a7/01/CZv17wIw_o.jpg" width="1080"></p> 
<p>我们看下源码，其实newFixedThreadPool使用的是无界队列！</p> 
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt;, java.io.Serializable {
    ...


    /**
     * Creates a {@code LinkedBlockingQueue} with a capacity of
     * {@link Integer#MAX_VALUE}.
     */
    public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
    }
...
}
</code></pre> 
<blockquote>
  ❝ 
 <p>newFixedThreadPool线程池的核心线程数是固定的，它使用了近乎于无界的LinkedBlockingQueue阻塞队列。当核心线程用完后，任务会入队到阻塞队列，如果任务执行的时间比较长，没有释放，会导致越来越多的任务堆积到阻塞队列，最后导致机器的内存使用不停的飙升，造成JVM OOM。</p> ❞ 
</blockquote> 
<h4>14. 直接大文件或者一次性从数据库读取太多数据到内存，可能导致OOM问题</h4> 
<p>如果一次性把大文件或者数据库太多数据达到内存，是会导致OOM的。所以，为什么查询DB数据库，一般都建议分批。</p> 
<p>读取文件的话，一般问文件不会太大，才使用<code>Files.readAllLines()</code>。为什么呢？因为它是直接把文件都读到内存的，预估下不会OOM才使用这个吧，可以看下它的源码：</p> 
<pre><code>public static List&lt;String&gt; readAllLines(Path path, Charset cs) throws IOException {
    try (BufferedReader reader = newBufferedReader(path, cs)) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        for (;;) {
            String line = reader.readLine();
            if (line == null)
                break;
            result.add(line);
        }
        return result;
    }
}
</code></pre> 
<p>如果是太大的文件，可以使用Files.line()按需读取，当时读取文件这些，一般是使用完需要<strong>「关闭资源流」</strong>的哈</p> 
<h4>15. 先查询，再更新/删除的并发一致性问题</h4> 
<p>再日常开发中，这种代码实现经常可见：先查询是否有剩余可用的票，再去更新票余量。</p> 
<pre><code>if(selectIsAvailable(ticketId){ 
    1、deleteTicketById(ticketId) 
    2、给现金增加操作 
}else{ 
    return “没有可用现金券” 
}
</code></pre> 
<p>如果是并发执行，很可能有问题的，应该利用数据库的更新/删除的原子性，正解如下：</p> 
<pre><code>if(deleteAvailableTicketById(ticketId) == 1){ 
    1、给现金增加操作 
}else{ 
    return “没有可用现金券” 
}
</code></pre> 
<h4>16. 数据库使用utf-8存储， 插入表情异常的坑</h4> 
<p>低版本的MySQL支持的utf8编码，最大字符长度为 3 字节，但是呢，存储表情需要4个字节，因此如果用utf8存储表情的话，会报<code>SQLException: Incorrect string value: '\xF0\x9F\x98\x84' for column</code>，所以一般用utf8mb4编码去存储表情。</p> 
<h4>17. 事务未生效的坑</h4> 
<p>日常业务开发中，我们经常跟事务打交道，<strong>「事务失效」</strong>主要有以下几个场景：</p> 
<ul><li> <p>底层数据库引擎不支持事务</p> </li><li> <p>在非public修饰的方法使用</p> </li><li> <p>rollbackFor属性设置错误</p> </li><li> <p>本类方法直接调用</p> </li><li> <p>异常被try...catch吃了，导致事务失效。</p> </li></ul> 
<p>其中，最容易踩的坑就是后面两个，<strong>「注解的事务方法给本类方法直接调用」</strong>，伪代码如下：</p> 
<pre><code>public class TransactionTest{
  public void A(){
    //插入一条数据
    //调用方法B (本地的类调用，事务失效了)
    B();
  }
  
  @Transactional
  public void B(){
    //插入数据
  }
}
</code></pre> 
<p>如果异常被catch住，<strong>「那事务也是会失效呢」</strong>~，伪代码如下：</p> 
<pre><code>@Transactional
public void method(){
  try{
    //插入一条数据
    insertA();
    //更改一条数据
    updateB();
  }catch(Exception e){
    logger.error("异常被捕获了，那你的事务就失效咯",e);
  }
}
</code></pre> 
<h4>18. 当反射遇到方法重载的坑</h4> 
<pre><code>/**
 *  反射demo
 *  @author java小白翻身
 */
public class ReflectionTest {

    private void score(int score) {
        System.out.println("int grade =" + score);
    }

    private void score(Integer score) {
        System.out.println("Integer grade =" + score);
    }

    public static void main(String[] args) throws Exception {
        ReflectionTest reflectionTest = new ReflectionTest();
        reflectionTest.score(100);
        reflectionTest.score(Integer.valueOf(100));

        reflectionTest.getClass().getDeclaredMethod("score", Integer.TYPE).invoke(reflectionTest, Integer.valueOf("60"));
        reflectionTest.getClass().getDeclaredMethod("score", Integer.class).invoke(reflectionTest, Integer.valueOf("60"));
    }
}
</code></pre> 
<p>运行结果：</p> 
<pre><code>int grade =100
Integer grade =100
int grade =60
Integer grade =60
</code></pre> 
<p>如果<strong>「不通过反射」</strong>，传入<code>Integer.valueOf(100)</code>，走的是Integer重载。但是呢，反射不是根据入参类型确定方法重载的，而是<strong>「以反射获取方法时传入的方法名称和参数类型来确定」</strong>的</p> 
<pre><code>getClass().getDeclaredMethod("score", Integer.class)
getClass().getDeclaredMethod("score", Integer.TYPE)
</code></pre> 
<h4>19. mysql 时间 timestamp的坑</h4> 
<p>有更新语句的时候，timestamp可能会自动更新为当前时间，看个demo</p> 
<pre><code>CREATE TABLE `t` (
  `a` int(11) DEFAULT NULL,
  `b` timestamp  NOT NULL,
  `c` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre> 
<p>我们可以发现 <strong>「c列」</strong> 是有<code>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code>，所以c列会随着记录更新而<strong>「更新为当前时间」</strong>。但是b列也会随着有记录更新为而<strong>「更新为当前时间」</strong>。</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/56/34/wk45vHjo_o.png" width="694"></p> 
<p>可以使用datetime代替它,需要更新为当前时间，就把<code>now()</code>赋值进来，或者修改mysql的这个参数<code>explicit_defaults_for_timestamp</code>。</p> 
<h4>20. mysql8数据库的时区坑</h4> 
<p>之前我们对mysql数据库进行升级，新版本为8.0.12。但是升级完之后，发现now()函数，获取到的时间比北京时间晚8小时，原来是因为mysql8默认为美国那边的时间，需要指定下时区</p> 
<pre><code>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;
serverTimezone=Asia/Shanghai
</code></pre> 
<h4></h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53f4e9e730f618f2693b8040d46b89fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue3组合式API(Composition API)的使用案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/723cf6aeecdc65df1cdc805782bb1466/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python项目打包与部署(一)：模块与包的概念与关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>