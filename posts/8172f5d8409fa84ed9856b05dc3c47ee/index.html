<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的unordered_map用法详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的unordered_map用法详解" />
<meta property="og:description" content="1 简介
unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。
key值应该是唯一的，key和value的数据类型可以不相同。
unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。
unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。
可以使用[ ]操作符来访问key值对应的value值。
2 简单使用
std::unordered_map&lt;std::string, std::int&gt; umap; //定义
umap.insert(Map::value_type(&#34;test&#34;, 1));//增加
//根据key删除,如果没找到n=0
auto n = umap.erase(&#34;test&#34;) //删除
auto it = umap.find(key) //改
if(it != umap.end()) it-&gt;second = new_value; //map中查找x是否存在
umap.find(x) != map.end()//查
//或者
umap.count(x) != 0
for(auto x:unomap)//遍历整个map，输出key及其对应的value值
{
x.second = 0; cout&lt;&lt;x.second&lt;&lt;endl;//全是 000；; }
cout&lt;&lt;x.second&lt;&lt;endl;//回复原来的数值的。
彻底改变：使用find彻底找到这个数值，然后在进行改，可以保证作用域是整个程序。
for(auto x:unomap)//遍历整个map，输出key及其对应的value值
{
auto it = umap.find(key) //改
if(it != umap.end()) it-&gt;second = new_value; } #include &lt;iostream&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8172f5d8409fa84ed9856b05dc3c47ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-25T08:08:58+08:00" />
<meta property="article:modified_time" content="2022-10-25T08:08:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的unordered_map用法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1 简介<br> unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。<br> key值应该是唯一的，key和value的数据类型可以不相同。<br> unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。<br> unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。<br> 可以使用[ ]操作符来访问key值对应的value值。</p> 
<p>2 简单使用</p> 
<p>std::unordered_map&lt;std::string, std::int&gt; umap; //定义</p> 
<p>umap.insert(Map::value_type("test", 1));//增加</p> 
<p>//根据key删除,如果没找到n=0<br> auto n = umap.erase("test")   //删除</p> 
<p>auto it = umap.find(key) //改<br> if(it != umap.end()) <br>     it-&gt;second = new_value; </p> 
<p><br> //map中查找x是否存在<br> umap.find(x) != map.end()//查<br> //或者<br> umap.count(x) != 0<br> for(auto x:unomap)//遍历整个map，输出key及其对应的value值<br> {<!-- --><br>     x.second = 0;    <br>     cout&lt;&lt;x.second&lt;&lt;endl;//全是  000；;    <br> }<br> cout&lt;&lt;x.second&lt;&lt;endl;//回复原来的数值的。<br> 彻底改变：使用find彻底找到这个数值，然后在进行改，可以保证作用域是整个程序。<br> for(auto x:unomap)//遍历整个map，输出key及其对应的value值<br> {<!-- --><br>     auto it = umap.find(key) //改<br>     if(it != umap.end()) <br>         it-&gt;second = new_value; <br> }        </p> 
<p>#include &lt;iostream&gt;<br> #include &lt;unordered_map&gt;<br> using namespace std;<br> int main()<br> {<!-- --><br>     string key="123";<br>     int value=4;<br>     unordered_map&lt;string, int&gt; unomap;//创建一个key为string类型，value为int类型的unordered_map<br>     unomap.emplace(key, value);//使用变量方式，插入一个元素<br>     unomap.emplace("456", 7);//也可以直接写上key和value的值<br>     cout&lt;&lt;unomap["123"];//通过key值来访问value</p> 
<p>    cout&lt;&lt;endl;<br>     for(auto x:unomap)//遍历整个map，输出key及其对应的value值<br>         cout&lt;&lt;x.first&lt;&lt;"  "&lt;&lt;x.second&lt;&lt;endl;</p> 
<p>    for(auto x:unomap)//遍历整个map，并根据其key值，查看对应的value值<br>         cout&lt;&lt;unomap[x.first]&lt;&lt;endl;<br> }<br> [遍历map]</p> 
<p>unordered_map&lt;key,T&gt;::iterator it;<br>     (*it).first;   //the key value<br>     (*it).second   //the mapped value<br>     for(unordered_map&lt;key,T&gt;::iterator iter=mp.begin();iter!=mp.end();iter++)<br>           cout&lt;&lt;"key value is"&lt;&lt;iter-&gt;first&lt;&lt;" the mapped value is "&lt;&lt; iter-&gt;second;</p> 
<p>    //也可以这样<br>     for(auto&amp; v : mp)<br>         print v.first and v.second</p> 
<p>3 c++中map与unordered_map的区别<br> 运行效率方面：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。<br> 占用内存方面：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。<br> 3.1 头文件<br> map: #include &lt; map &gt;<br> unordered_map: #include &lt; unordered_map &gt;<br> 3.2 内部实现机理<br> map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。<br> unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的<br> 3.3 优点、缺点、使用场景<br> map<br> 优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。<br> 缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br> 适用处：对于那些有顺序要求的问题，用map会更高效一些。</p> 
<p>unordered_map<br> 优点：内部实现了哈希表，因此其查找速度是常量级别的。<br> 缺点：哈希表的建立比较耗费时间<br> 适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p> 
<p>note<br> 对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d007c84dd830ccbdc32a111feddddad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言各数据类型的范围与精度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/929305a09969c9e2bc0df5442359e2e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中日志的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>