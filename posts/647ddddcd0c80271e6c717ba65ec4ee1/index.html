<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HW6：Threads and Locking - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HW6：Threads and Locking" />
<meta property="og:description" content="MIT6.828_HW6_Threads and Locking
ph.c程序 这个实验给了我们一个实例ph.c，这个程序会创建一个线程，thread，如下所示：
static void * thread(void *xa) { long n = (long) xa; int i; int b = NKEYS/nthread; int k = 0; double t1, t0; // printf(&#34;b = %d\n&#34;, b); t0 = now(); for (i = 0; i &lt; b; i&#43;&#43;) { // printf(&#34;%d: put %d\n&#34;, n, b*n&#43;i); put(keys[b*n &#43; i], n); } t1 = now(); printf(&#34;%ld: put time = %f\n&#34;, n, t1-t0); // Should use pthread_barrier, but MacOS doesn&#39;t support it ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/647ddddcd0c80271e6c717ba65ec4ee1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T23:43:43+08:00" />
<meta property="article:modified_time" content="2022-11-28T23:43:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HW6：Threads and Locking</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/Small_Pond/article/details/92838852">MIT6.828_HW6_Threads and Locking</a></p> 
<h3><a id="phc_1"></a><code>ph.c</code>程序</h3> 
<p>这个实验给了我们一个实例<code>ph.c</code>，这个程序会创建一个线程，<code>thread</code>，如下所示：</p> 
<pre><code>static void *
thread(void *xa)
{
  long n = (long) xa;
  int i;
  int b = NKEYS/nthread;
  int k = 0;
  double t1, t0;
  //  printf("b = %d\n", b);
  t0 = now();
  for (i = 0; i &lt; b; i++) {
    // printf("%d: put %d\n", n, b*n+i);
    put(keys[b*n + i], n);
  }
  t1 = now();
  printf("%ld: put time = %f\n", n, t1-t0);
  // Should use pthread_barrier, but MacOS doesn't support it ...
  __sync_fetch_and_add(&amp;done, 1);
  while (done &lt; nthread) ;
  t0 = now();
  for (i = 0; i &lt; NKEYS; i++) {
    struct entry *e = get(keys[i]);
    if (e == 0) k++;
  }
  t1 = now();
  printf("%ld: get time = %f\n", n, t1-t0);
  printf("%ld: %d keys missing\n", n, k);
  return NULL;
}
</code></pre> 
<p>这个线程先是通过<code>put</code>操作，将数据放入到<code>table</code>中，<code>table</code>是一个数组，大小为<code>NBUCKET</code>，每个元素为一个链表。<code>put</code>操作的时候每个线程会<code>insert</code>同样数量的数据，例如有2个线程，那么线程0会将keys[0]到keys[49999]的值<code>insert</code>到<code>table</code>中，线程·会将keys[50000]到keys[99999]<code>insert</code>到<code>table</code>中。通过<code>while(down &lt; nthread)</code>语句，保证所有线程先进行了<code>put</code>操作之后，才会进行<code>get</code>操作。而<code>get</code>操作，则是遍历<code>keys[100000]</code>数组，找到每个<code>keys[i]</code>对应的value，如果找不到，那么计数<code>k++</code>。</p> 
<h3><a id="missing_keys_37"></a><code>missing keys</code>的原因</h3> 
<p>因为在多线程的时候，由于<code>insert</code>并不是原子操作，导致两个线程冲突，有部分数据并没有<code>insert</code>到<code>table</code>中。因此可以对<code>insert</code>操作加锁。</p> 
<pre><code>static
void put(int key, int value)
{
  int i = key % NBUCKET;
  pthread_mutex_lock(&amp;lock);  // acquire lock
  insert(key, value, &amp;table[i], table[i]);
  pthread_mutex_unlock(&amp;lock);  // release lock
}
</code></pre> 
<p><strong>加锁之后，put的时间会变长</strong></p> 
<ul><li>未加锁时<br> <img src="https://images2.imgbox.com/da/62/smSmumPG_o.png" alt="在这里插入图片描述"></li><li>加锁之后<br> <img src="https://images2.imgbox.com/50/96/sIUlS4Ep_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="_57"></a>注意</h3> 
<p>下面这种加锁方式会存在问题，原因在于<code>put</code>函数中，其<code>&amp;table[i]</code>和<code>table[i]</code>的地址会因为其他线程插入数据导致这两部分的地址失效。</p> 
<pre><code>static void
insert(int key, int value, struct entry **p, struct entry *n)
{
  pthread_mutex_lock(&amp;lock);  // acquire lock
  struct entry *e = malloc(sizeof(struct entry));
  e-&gt;key = key;
  e-&gt;value = value;
  e-&gt;next = n;
  *p = e;
  pthread_mutex_unlock(&amp;lock);  // release lock
}
static
void put(int key, int value)
{
  int i = key % NBUCKET;
  insert(key, value, &amp;table[i], table[i]);
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f9bdd560877385a4e51b9a8f4f78d62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库安全，如何防止数据库被入侵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b38c7af5540b50213b2cade6e7c7fd20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java线程池示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>