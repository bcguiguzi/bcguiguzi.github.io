<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot 整合 ... - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot 整合 ..." />
<meta property="og:description" content="文章目录 Redis使用StringRedisTemplate序列化设置 RedisTemplate 序列化 DubboDubboZookeeperapi项目服务提供者消费者执行 对于 Redis 、 dubbo 本人还未正式开始学习，仅简单记录 Spring Boot 整合其的方式作为笔记
Redis NoSql 数据库，常用作缓存使用（cache）常用数据类型：String、hash、set、zset、listRedis 是一个中间件，独立的服务器 Java中常用客户端：Jedis、Iettuce、Redisson Spring、SpringBoot 中有 RedisTemplate 类处理和 Redis 交互 StringRedisTemplate、RedisTemplate 两个类 windows 版本 Redis
放到非中文路径redis.server.exe：启动服务端 不要关闭 redis-cli.exe：启动客户端 访问 redis 中的数据 使用 SpringBoot 使用 Redis
创建 SpringBoot 项目
&lt;!-- redis 的起步依赖 在项目中使用 RedisTemplate：StringRedisTemplate 操作 redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- data-redis 使用 lettuce 客户端 --&gt; 程序中使用 RedisTemplate 类的方法实际就是调用 lettuce 客户端中的方法 application.properties 中配置 redis 的信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4fb90b6f53360f15b9e654c1fcb4a7a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-02T22:48:23+08:00" />
<meta property="article:modified_time" content="2022-11-02T22:48:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot 整合 ...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Redis_2" rel="nofollow">Redis</a></li><li><ul><li><a href="#_19" rel="nofollow">使用</a></li><li><ul><li><a href="#StringRedisTemplate_49" rel="nofollow">StringRedisTemplate</a></li><li><ul><li><a href="#_60" rel="nofollow">序列化</a></li><li><a href="#_RedisTemplate__72" rel="nofollow">设置 RedisTemplate 序列化</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#Dubbo_90" rel="nofollow">Dubbo</a></li><li><ul><li><a href="#Dubbo_111" rel="nofollow">Dubbo</a></li><li><a href="#Zookeeper_124" rel="nofollow">Zookeeper</a></li><li><a href="#api_133" rel="nofollow">api项目</a></li><li><a href="#_140" rel="nofollow">服务提供者</a></li><li><a href="#_195" rel="nofollow">消费者</a></li><li><a href="#_240" rel="nofollow">执行</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>对于 Redis 、 dubbo 本人还未正式开始学习，仅简单记录 Spring Boot 整合其的方式作为笔记</p> 
</blockquote> 
<h3><a id="Redis_2"></a>Redis</h3> 
<ul><li>NoSql 数据库，常用作缓存使用（cache）</li><li>常用数据类型：String、hash、set、zset、list</li><li>Redis 是一个中间件，独立的服务器 
  <ul><li>Java中常用客户端：Jedis、Iettuce、Redisson</li></ul> </li><li>Spring、SpringBoot 中有 RedisTemplate 类处理和 Redis 交互 
  <ul><li>StringRedisTemplate、RedisTemplate 两个类</li></ul> </li></ul> 
<p>windows 版本 Redis</p> 
<ul><li>放到非中文路径</li><li>redis.server.exe：启动服务端 
  <ul><li>不要关闭</li></ul> </li><li>redis-cli.exe：启动客户端 
  <ul><li>访问 redis 中的数据</li></ul> </li></ul> 
<h4><a id="_19"></a>使用</h4> 
<p>SpringBoot 使用 Redis</p> 
<ol><li> <p>创建 SpringBoot 项目</p> <pre><code class="prism language-xml"><span class="token comment">&lt;!-- 
redis 的起步依赖
在项目中使用 RedisTemplate：StringRedisTemplate 操作 redis
 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- data-redis 使用 lettuce 客户端 --&gt;</span>
</code></pre> 
  <ul><li>程序中使用 RedisTemplate 类的方法实际就是调用 lettuce 客户端中的方法</li></ul> </li><li> <p>application.properties 中配置 redis 的信息</p> <pre><code class="prism language-properties"># 配置 redis
# 配置redis 的ip、端口号、密码
spring.redis.host=localhost
spring.redis.port=6379
#spring.redis.password=
</code></pre> </li></ol> 
<h5><a id="StringRedisTemplate_49"></a>StringRedisTemplate</h5> 
<ul><li>StringRedisTemplate 
  <ul><li>将 k、v 都作为 String 处理 
    <ul><li>只能处理字符串，局限性比较大</li></ul> </li><li>使用 String 的序列化，可读性好</li></ul> </li><li>RedisTemplate 
  <ul><li>将 k、v 序列化化到 redis 
    <ul><li>k、v 是序列化的内容，不能直接识别</li></ul> </li><li>默认使用 jdk 的序列化机制</li></ul> </li></ul> 
<h6><a id="_60"></a>序列化</h6> 
<p>序列化：把对象转化为可传输的字节序列</p> 
<ul><li>最终目的是为了对象可以跨平台存储，进行网络传输</li><li>序列化方式 
  <ul><li>常见的有 JDK、Kryo（不支持跨语言）</li><li>JSON、XML、Hession、Thrift、Protobuf</li></ul> </li><li>Java 的序列化将Java对象抓为二进制字节数组 
  <ul><li>最方便但性能较差</li></ul> </li><li>JSON 序列化：将对象转为 json 格式或从 json 格式转为对象</li></ul> 
<h6><a id="_RedisTemplate__72"></a>设置 RedisTemplate 序列化</h6> 
<ul><li>可以单独设置 key 或 value 或 同时设置序列化机制</li></ul> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 设置 RedisTemplate 的序列化机制
 */</span>
<span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/read"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> k<span class="token punctuation">,</span> <span class="token class-name">String</span> v<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//设置 key 的序列化机制 为 String 类型</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置 value 的序列化机制 为 String 类型</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"定义了序列化机制"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Dubbo_90"></a>Dubbo</h3> 
<p>SpringBoot 集成 Dubbo，进行分布式开发</p> 
<ul><li>分布式：当单节点无法满足日益增长的计算、存储任务 
  <ul><li>且硬件的提升代价过高、应用程序不能进一步优化</li><li>才考虑分布式系统</li></ul> </li><li>分布式解决的问题和单机系统是一样的 
  <ul><li>由于分布式系统多节点，通过网络的拓扑结构</li><li>或引入很多单机系统没有的问题</li><li>为解决这些问题又会引入更多的机制、协议</li></ul> </li><li>RPC：Remote Procedure Call 
  <ul><li>指远程过程调用，一种进程间的通信方式 
    <ul><li>是一种技术思想，而非规范</li></ul> </li><li>允许程序调用另一个地址空间的过程或函数 
    <ul><li>而非显式编码过程的细节</li><li>通常是共享网络上的另一台机器上</li></ul> </li><li>即：无论调用本地还是远程方法本质上编写的代码基本相同</li><li>核心模块：通讯、序列化</li></ul> </li><li>Dubbo 就是解决这些过程</li></ul> 
<h4><a id="Dubbo_111"></a>Dubbo</h4> 
<ul><li>Provider：服务提供者 
  <ul><li>暴露服务的服务提供方</li><li>服务提供者在启动时向注册中心注册自己提供的服务</li></ul> </li><li>Consumer：调用远程服务的服务消费者 
  <ul><li>服务消费者在启动时向注册中心订阅自己需要的服务</li><li>服务消费者从提供者地址列表中基于软负载均衡算法 
    <ul><li>选一台提供者进行调用，若调用失败再换一台调用</li></ul> </li></ul> </li><li>Monitor：服务消费者和提供者 
  <ul><li>在内存中累计调用次数和调用时间</li><li>定时每分钟发送一次统计数据到监控中心</li></ul> </li></ul> 
<h4><a id="Zookeeper_124"></a>Zookeeper</h4> 
<ul><li>顾名思义 zookeeper 就是动物园管理员 
  <ul><li>用来管 hadoop（大象）、Hive(蜜蜂)、pig(小猪)的管理员</li></ul> </li><li>Apache Hbase 和 Apache Solr 的分布式集群都用到了 zookeeper</li><li>Zookeeper: 是一个分布式的、开源的程序协调服务 
  <ul><li>hadoop 项目下的一个子项目</li><li>提供的主要功 能包括：配置管理、名字服务、分布式锁、集群管理。</li></ul> </li></ul> 
<h4><a id="api_133"></a>api项目</h4> 
<ul><li>公共的接口项目：api项目 
  <ul><li>只定义接口和 model 类 
    <ul><li>数据类实现序列化接口</li></ul> </li><li>普通的 maven 项目</li></ul> </li></ul> 
<h4><a id="_140"></a>服务提供者</h4> 
<ul><li> <p>SpringBoot 项目，不选择额外依赖</p> </li><li> <p>添加 dubbo 启动依赖</p> 
  <ul><li>自动引入 dubbo 依赖</li></ul> </li><li> <p>添加 Dubbo 和 Zookeeper 的集成依赖</p> </li><li> <p>实现 api 项目中的接口</p> 
  <ul><li>暴露服务提供者 
    <ul><li>接口实现类上注解 dubbo 提供的注解 @DubboService</li><li>属性 ：interfaceClass：接口类型 
      <ul><li>version：指定版本号</li><li>timeout：超时</li></ul> </li></ul> </li><li>实现接口中的业务方法</li><li>自动将对象放到容器中</li></ul> <pre><code class="prism language-java"><span class="token comment">//实现 api 项目接口</span>
<span class="token comment">//注解创建代理对象放到容器中，暴露</span>
<span class="token annotation punctuation">@DubboService</span><span class="token punctuation">(</span>interfaceClass<span class="token operator">=</span><span class="token string">"Service.class"</span><span class="token punctuation">,</span> version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//实现 接口的业务逻辑</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>配置</p> <pre><code class="prism language-properties"># 快速化配置
# 配置服务名称 等价 dubbo:applicaton name = "名称"
spring.application.name=studentservice-provider
# 配置扫描的包，扫描 @DubboService 注解
dubbo.scan.base-package=包路径
# 配置 dubbo 协议
dubbo.protocol.name=dubbo
# 配置端口号，自定义
dubbo.protocol.potr=123
# 注册中心
dubbo.registry.address=zookeeper://localhost:2181
</code></pre> </li><li> <p>在主启动类上注解 @EnableDubbo</p> 
  <ul><li>复合注解，表示启动 Dubbo 配置</li><li>集成 @EnableDubboConfig、@DubboComponentScan 注解</li></ul> </li><li> <p>排除 Log4j 依赖</p> 
  <ul><li>在之前的依赖添加时多次导入了该依赖</li><li>需要手动排除</li></ul> </li></ul> 
<h4><a id="_195"></a>消费者</h4> 
<ul><li> <p>SpringBoot 项目，选择 web 启动依赖</p> </li><li> <p>添加 dubbo 启动依赖、添加 zookeeper 依赖</p> 
  <ul><li>跟提供者依赖项相同</li></ul> </li><li> <p>创建 controller 使用 @RestController 注解</p> 
  <ul><li>声明 提供者 service 对象 
    <ul><li>属性上添加 @DubboReference 注解远程注入属性值 
      <ul><li>从提供者项目注入属性</li></ul> </li></ul> </li></ul> </li><li> <p>主启动类添加 @EnableDubbo 启用 Dubbo</p> </li><li> <p>配制 application.properties</p> <pre><code class="prism language-properties"># 快速化配置
# 配置服务名称 等价 dubbo:applicaton name = "名称"
spring.application.name=consumer-application
# 注册中心
dubbo.registry.address=zookeeper://localhost:2181
</code></pre> </li></ul> 
<pre><code class="prism language-java"><span class="token comment">//controller 类</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> calss <span class="token class-name">DubboController</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">/*
    引用远程服务，将创建好的代理对象注入
    @DubboReference(interfaceClass = Service.class, version = "1.0")
    不指定interfaceClass默认使用引用类型的数据类型
    */</span>
    <span class="token annotation punctuation">@DubboReference</span><span class="token punctuation">(</span>version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token punctuation">)</span> 据类型
    <span class="token keyword">private</span> <span class="token class-name">Service</span> service<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//执行业务逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_240"></a>执行</h4> 
<ol><li>启动 zookeeper</li><li>启动提供者</li><li>启动消费者执行方法访问</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0285f3af98392a821e16e22940124bbc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot 之 SpringSecurity、Shiro</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b6253af55ebaff17fc6c8b175ef6fd1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 之 Swagger</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>