<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何使用Python内置缓存装饰器: @lru_cache，@cache 与 @cached_property - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何使用Python内置缓存装饰器: @lru_cache，@cache 与 @cached_property" />
<meta property="og:description" content="1. 为什么需要缓存技术？ 使用缓存是优化Python程序速度的重要方法之一。如果使用得当，可以大幅减少计算资源的负载，有效加快代码运行速度
Python 的内置库 functools 模块附带了@lru_cache，@cache, @cached_property 装饰器，使用非常简便，不需要安装第3方库，不需要 redis 等数据库保存对象等，通常只需要1行代码，就可以对函数运算结果、类成员方法运算结果进行缓存。
本文将介绍这3种缓存工具的使用步骤及实例。
2. @lru_cache 缓存装饰器的使用 @lru_cache 是最常见的缓存装饰器。lru_cache 是： Last recently used cache 的简写，可以将该函数最近调用的输入参数以及结果进行缓存。如果有新的调用，先检查缓存是否有相同的输入参数，如果存在，则直接返回对应结果。如果是无参函数，第1次调用后，以后每次调用，直接返回缓存结果。
先看1个例子
from functools import lru_cache from math import sin @lru_cache def sin_half(x): return sin(x)/2 print(&#39;first call result:&#39;,sin_half(60)) print(&#39;second call result:&#39;,sin_half(60)) 上例中，第1次运行函数后，lru_cache会缓存调用参数及返回结果。第2次运行时，lru_cache都会检查输入，发现缓存中存在相同输入参数60，则从缓存中返回结果。如果函数执行的是计算量很重的任务，对于相同输入，可以明显地节省系统资源。
装饰器参数
lru_cache默认不清除缓存内容，因此缓存会无限增长，如果程序是长期运行的服务，可能存在耗尽内存的风险。 因此，必须添加1个maxsize参数：
@lru_cache(maxsize) 的参数maxsize 表示要缓存的最近调用次数.
如 @lru_cache(360) 表示，只缓存最近360次的函数调用结果。
@lru_cache(360) def sin_half(x): return sin(x)/2 缓存操作
查看缓存报告: sin_half.cache_info()
强制清除缓存内容： sin_half.cache_clear() 当然也可以使用 python的 garbage collection 清除缓存。
下面使用1个示例来演示上述内容：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1d0811fc7babf03a86ea64d2e2b90e20/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T10:01:01+08:00" />
<meta property="article:modified_time" content="2023-06-30T10:01:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何使用Python内置缓存装饰器: @lru_cache，@cache 与 @cached_property</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_font_colorbluefont_0"></a>1. <font color="blue">为什么需要缓存技术？</font></h3> 
<p><strong>使用缓存是优化Python程序速度的重要方法之一</strong>。如果使用得当，可以大幅减少计算资源的负载，有效加快代码运行速度</p> 
<p>Python 的内置库 <strong>functools</strong> 模块附带了<code>@lru_cache，@cache, @cached_property </code>装饰器，使用非常简便，不需要安装第3方库，不需要 redis 等数据库保存对象等，通常只需要1行代码，就可以对函数运算结果、类成员方法运算结果进行缓存。</p> 
<p>本文将介绍这3种缓存工具的使用步骤及实例。</p> 
<h3><a id="2_lru_cache__8"></a>2. <code>@lru_cache</code> 缓存装饰器的使用</h3> 
<p>@lru_cache 是最常见的缓存装饰器。<code>lru_cache</code> 是：<code> Last recently used cache</code> 的简写，可以将该函数最近调用的输入参数以及结果进行缓存。如果有新的调用，先检查缓存是否有相同的输入参数，如果存在，则直接返回对应结果。如果是无参函数，第1次调用后，以后每次调用，直接返回缓存结果。</p> 
<p>先看1个例子</p> 
<pre><code class="prism language-py"><span class="token keyword">from</span> functools <span class="token keyword">import</span> lru_cache
<span class="token keyword">from</span> math <span class="token keyword">import</span> sin

<span class="token decorator annotation punctuation">@lru_cache</span>
<span class="token keyword">def</span> <span class="token function">sin_half</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'first call result:'</span><span class="token punctuation">,</span>sin_half<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'second call result:'</span><span class="token punctuation">,</span>sin_half<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<p>上例中，第1次运行函数后，lru_cache会缓存调用参数及返回结果。第2次运行时，lru_cache都会检查输入，发现缓存中存在相同输入参数60，则从缓存中返回结果。如果函数执行的是计算量很重的任务，对于相同输入，可以明显地节省系统资源。</p> 
<p><strong>装饰器参数</strong></p> 
<p>lru_cache默认不清除缓存内容，因此缓存会无限增长，如果程序是长期运行的服务，可能存在耗尽内存的风险。 因此，必须添加1个maxsize参数：<br> @lru_cache(maxsize) 的参数maxsize 表示要缓存的最近调用次数.<br> 如 @lru_cache(360) 表示，只缓存最近360次的函数调用结果。</p> 
<pre><code>@lru_cache(360)
def sin_half(x):
    return sin(x)/2
</code></pre> 
<p><strong>缓存操作</strong></p> 
<p>查看缓存报告: <code>sin_half.cache_info()</code><br> 强制清除缓存内容： <code>sin_half.cache_clear() </code><br> 当然也可以使用 python的 garbage collection 清除缓存。</p> 
<p>下面使用1个示例来演示上述内容：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> functools
<span class="token keyword">import</span> gc

<span class="token comment"># 主要功能： </span>
<span class="token comment"># 验证  @lru_cache 装饰器，.chche_info() 和 .cache_clear() 方法的使用</span>
<span class="token comment">#       garbage collection 的使用</span>

<span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>lru_cache</span><span class="token punctuation">(</span>maxsize <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment"># Max number of Last recently used cache</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> n
	<span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>


fib<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>
fib<span class="token punctuation">.</span>cache_clear<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Before Clearing</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># After Clearing</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>lru_cache</span><span class="token punctuation">(</span>maxsize <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">gfg1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># insert function logic here</span>
    <span class="token keyword">pass</span>

<span class="token comment"># 再次运行函数 </span>
gfg1<span class="token punctuation">(</span><span class="token punctuation">)</span>
fib<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token comment"># garbage collection</span>
gc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># All objects collected</span>
objects <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> gc<span class="token punctuation">.</span>get_objects<span class="token punctuation">(</span><span class="token punctuation">)</span> 
           <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> functools<span class="token punctuation">.</span>_lru_cache_wrapper<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>gfg1<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># All objects cleared</span>
<span class="token keyword">for</span> <span class="token builtin">object</span> <span class="token keyword">in</span> objects<span class="token punctuation">:</span>
    <span class="token builtin">object</span><span class="token punctuation">.</span>cache_clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
<span class="token keyword">print</span><span class="token punctuation">(</span>gfg1<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<p>运行程度，输出为：</p> 
<pre><code>CacheInfo(hits=0, misses=0, maxsize=300, currsize=0)
CacheInfo(hits=0, misses=0, maxsize=300, currsize=0)
CacheInfo(hits=0, misses=1, maxsize=None, currsize=1)
CacheInfo(hits=0, misses=0, maxsize=None, currsize=0)
</code></pre> 
<h3><a id="3_cache__102"></a>3. <code>@cache</code> 缓存装饰器的使用</h3> 
<p>相比@lru_cache, @cache 装饰器更轻量化，速度更快，且是线程安全，不同线程可以调用同1个函数，缓存值可以共享。</p> 
<pre><code class="prism language-py"><span class="token keyword">import</span> functools
<span class="token keyword">import</span> time

<span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>cache</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> n
	<span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
   
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    
    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    execution_time_without_cache <span class="token operator">=</span> end_time <span class="token operator">-</span> start_time
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Time taken without cache: {:.8f} seconds"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>execution_time_without_cache<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    execution_time_without_cache <span class="token operator">=</span> end_time <span class="token operator">-</span> start_time
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Time taken with cache: {:.8f} seconds"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>execution_time_without_cache<span class="token punctuation">)</span><span class="token punctuation">)</span>    
</code></pre> 
<p>output:</p> 
<pre><code>176023680645013966468226945392411250770384383304492191886725992896575345044216019675
Time taken without cache: 0.00095391 seconds
176023680645013966468226945392411250770384383304492191886725992896575345044216019675
Time taken with cache: 0.00000000 seconds
</code></pre> 
<h3><a id="4_cached_property__142"></a>4. <code>@cached_property</code> 缓存装饰器的使用</h3> 
<p><code>@cached_property</code>是一个装饰器，它将类的方法转换为属性，其值仅计算一次，然后缓存为普通属性。因此，只要实例持久存在，缓存的结果就可用，我们可以将该方法用作类的属性那样来使用，如</p> 
<pre><code>调用：    : instance.method
取代旧方式 : instance.method()
</code></pre> 
<p><code>@cached_property</code>是 Python 中 functools 模块的一部分。它类似于 <code>property（）</code>，但<code> @cached_property</code> 带有一个额外的功能，那就是缓存。</p> 
<p>但是它如何减少执行时间并使程序更快？请考虑以下示例：</p> 
<pre><code class="prism language-py"><span class="token comment"># Without using @cached_property</span>

<span class="token comment"># A sample class</span>
<span class="token keyword">class</span> <span class="token class-name">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lst<span class="token punctuation">)</span><span class="token punctuation">:</span>
	self<span class="token punctuation">.</span>long_list <span class="token operator">=</span> lst

	<span class="token comment"># a method to find the sum of the</span>
	<span class="token comment"># given long list of integer values</span>
	<span class="token keyword">def</span> <span class="token function">find_sum</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>long_list<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># obj is an instance of the class sample</span>
<span class="token comment"># the list can be longer, this is just</span>
<span class="token comment"># an example</span>
obj <span class="token operator">=</span> Sample<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<p>输出为：</p> 
<pre><code>55
55
55
</code></pre> 
<p>在这里，假设如果我们传递1个长列表，每次调用 find_sum()方法时都会计算给定列表的总和，从而花费大量时间运行，程序最终会变慢。我们想要的是，由于列表在创建实例后不会更改，因此，如果列表的总和只计算一次，而不是每次在我们调用方法并希望访问总和时计算，那就太好了。这可以通过使用@cached_property来实现,</p> 
<pre><code class="prism language-python"><span class="token comment"># With using @cached_property</span>

<span class="token keyword">from</span> functools <span class="token keyword">import</span> cached_property

<span class="token comment"># A sample class</span>
<span class="token keyword">class</span> <span class="token class-name">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lst<span class="token punctuation">)</span><span class="token punctuation">:</span>
	self<span class="token punctuation">.</span>long_list <span class="token operator">=</span> lst

	<span class="token comment"># a method to find the sum of the</span>
	<span class="token comment"># given long list of integer values</span>
	<span class="token decorator annotation punctuation">@cached_property</span>
	<span class="token keyword">def</span> <span class="token function">find_sum</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>long_list<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># obj is an instance of the class sample</span>
obj <span class="token operator">=</span> Sample<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">)</span>

</code></pre> 
<p>使用了@cached_property装饰器后，无须重新计算，总是立即返回find_sum值。<br> 如果需要重新计算属性，则删除该属性即可，下次调用会重新计算，在本例 中添加如下语句，</p> 
<pre><code class="prism language-py"><span class="token keyword">del</span> obj<span class="token punctuation">.</span>find_sum
obj<span class="token punctuation">.</span>long_list <span class="token operator">=</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>find_sum<span class="token punctuation">)</span>
</code></pre> 
<p>运行代码，输出结果为：</p> 
<pre><code>55
55
55
245
</code></pre> 
<h3><a id="5__221"></a>5. 各种缓存方法的适用场景</h3> 
<p>综上所述，建议如下：<br> 1） 如果程序规模小，或多线程编程时，可使用@cache 装饰器。<br> 2） 如果程度规模大，并且是长时间运行，建议使用@lru_cache 装饰器，使用方法灵活，但要注意控制缓存数量，必要时手工清理。<br> 3） 编写类代码时，如需将某项复杂运算结果像属性那样访问时，使用@cached_property装饰器。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cecb8d982310893d24d2fd453d855795/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Elsevier期刊Latex模板注意事项总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/812df417fd1927d52a066c602da6541c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何高效实现 MySQL 与 elasticsearch 的数据同步</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>