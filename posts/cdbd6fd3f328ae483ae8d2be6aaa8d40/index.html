<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的future和promise使用方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的future和promise使用方法" />
<meta property="og:description" content="future和promise C&#43;&#43;11中std::future提供了一种访问异步操作结果的机制。异步操作不能马上就获取操作结果，只能在未来某个时候获取，但可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。
std::promise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。
deferred：异步操作还没开始ready：异步操作已经完成timeout：异步操作超时 future函数：
**get()：**获取future所得到的结果，如果异步操作还没有结束，那么会在此等待异步操作的结束，并获取返回的结果。
**wait()😗*等待异步操作的结束状态变为ready，不能获得返回结果。
**wait_for(timeout)😗*等待timeout时间后返回结果，如果超时返回状态status=timeout。promise函数
set_value():设置共享状态的值，此后 promise 的共享状态标志变为 ready
get_future:获取与promise对象关联的对象
set_exception:为promise设置异常，此后promise的共享状态标识变为ready
set_value_at_thread_exit ：在线程退出时该 promise 对象会自动设置为 ready（注意：该线程已设置promise的值，如果在线程结束之后有其他修改共享状态值的操作，会抛出future_error(promise_already_satisfied)异常）
swap:交换 promise 的共享状态
使用示例： ```cpp include &lt;iostream&gt; #include &lt;future&gt; #include &lt;thread&gt; #include &lt;unistd.h&gt; #include&lt;chrono&gt; void set_promise(std::promise&lt;int&gt;&amp; p) { std::cout &lt;&lt; &#34;set_promise begin.&#34; &lt;&lt; std::endl; sleep(5); p.set_value(100); std::cout &lt;&lt; &#34;set_promise end.&#34; &lt;&lt; std::endl; } int main() { std::promise&lt;int&gt; p; // 将promise和future绑定，这一步就是允诺future，未来会有人对promise赋值 std::future&lt;int&gt; f = p." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cdbd6fd3f328ae483ae8d2be6aaa8d40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T23:25:43+08:00" />
<meta property="article:modified_time" content="2023-03-21T23:25:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的future和promise使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="futurepromise_0"></a>future和promise</h3> 
<p>C++11中std::future提供了一种访问异步操作结果的机制。异步操作不能马上就获取操作结果，只能在未来某个时候获取，但可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。<br> std::promise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。</p> 
<ul><li>deferred：异步操作还没开始</li><li>ready：异步操作已经完成</li><li>timeout：异步操作超时</li></ul> 
<ol><li>future函数：<br> **get()：**获取future所得到的结果，如果异步操作还没有结束，那么会在此等待异步操作的结束，并获取返回的结果。<br> **wait()😗*等待异步操作的结束状态变为ready，不能获得返回结果。<br> **wait_for(timeout)😗*等待timeout时间后返回结果，如果超时返回状态status=timeout。</li><li>promise函数<br> <strong>set_value()</strong>:设置共享状态的值，此后 promise 的共享状态标志变为 ready<br> <strong>get_future</strong>:获取与promise对象关联的对象<br> <strong>set_exception</strong>:为promise设置异常，此后promise的共享状态标识变为ready<br> <strong>set_value_at_thread_exit</strong> ：在线程退出时该 promise 对象会自动设置为 ready（注意：该线程已设置promise的值，如果在线程结束之后有其他修改共享状态值的操作，会抛出future_error(promise_already_satisfied)异常）<br> <strong>swap</strong>:交换 promise 的共享状态<br> 使用示例：</li></ol> 
<pre><code>
```cpp
include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include&lt;chrono&gt;
void set_promise(std::promise&lt;int&gt;&amp; p) {
    std::cout &lt;&lt; "set_promise begin." &lt;&lt; std::endl;
    sleep(5);
    p.set_value(100); 
    std::cout &lt;&lt; "set_promise end." &lt;&lt; std::endl;
}
 
int main() {
    std::promise&lt;int&gt; p;
    // 将promise和future绑定，这一步就是允诺future，未来会有人对promise赋值
    std::future&lt;int&gt; f = p.get_future();
    std::thread t(&amp;set_promise, std::ref(p));
    std::cout&lt;&lt;"wait ready111:" &lt;&lt; std::endl;
    auto status = f.wait_for(std::chrono::milliseconds(1000));//等待1s，结束等待时状态未改变，返回值为timeout
    std::cout&lt;&lt;"wait ready222:" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt;std::endl;
    status = f.wait_for(std::chrono::milliseconds(5000));//等待5s，结束等待时，状态已经变为ready
    std::cout&lt;&lt;"wait ready333:" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt;std::endl;
    std::cout &lt;&lt; f.get() &lt;&lt; std::endl;    // 通过get 拿到promise set的value
t.join();
return 0;
}
</code></pre> 
<pre><code>参考文章：
https://blog.csdn.net/whl0071/article/details/126251922
https://zhuanlan.zhihu.com/p/448035015
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbf2943904318df9888949afad3faef6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派安装c&#43;&#43;版本opencv</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/edcef2b7fe52281dbda53e38a1b4d0cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分享一些it学习网站</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>