<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>内核驱动模块分布编译 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="内核驱动模块分布编译" />
<meta property="og:description" content="内核驱动模块代码
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/ioctl.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include &#34;fsmp157a_led_head.h&#34; unsigned int *vir_gpioe_moder; unsigned int *vir_gpioe_odr; unsigned int *vir_gpiof_moder; unsigned int *vir_gpiof_odr; unsigned int *vir_rcc; char kbuf[128] = &#34;&#34;; //封装操作方法 //int (*open) (struct inode *, struct file *); //ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); //ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); //int (*release) (struct inode *, struct file *); //long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); int mycdev_open(struct inode *inode, struct file *file) { int min = MINOR(inode-&gt;i_rdev); file-&gt;private_data = (void *)min; printk(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bde748bd3a95fdea5e021b9c250f671e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T22:43:43+08:00" />
<meta property="article:modified_time" content="2023-10-23T22:43:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">内核驱动模块分布编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>内核驱动模块代码</p> 
<pre><code class="language-cpp">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/slab.h&gt;
#include "fsmp157a_led_head.h"

unsigned int *vir_gpioe_moder;
unsigned int *vir_gpioe_odr;
unsigned int *vir_gpiof_moder;
unsigned int *vir_gpiof_odr;
unsigned int *vir_rcc;

char kbuf[128] = "";
//封装操作方法
//int (*open) (struct inode *, struct file *);
//ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
//ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
//int (*release) (struct inode *, struct file *);
//long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);

int mycdev_open(struct inode *inode, struct file *file)
{
    int min = MINOR(inode-&gt;i_rdev);
    file-&gt;private_data = (void *)min;
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    return 0;
}

ssize_t mycdev_read(struct file *file, char *ubuf, size_t size, loff_t *lof)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    return 0;
}

ssize_t mycdev_write(struct file *fiile,const char *ubuf, size_t size, loff_t *lof)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
   
    int ret;
    //将用户空间的数据传递到内核
    ret = copy_from_user(kbuf, ubuf, size);
    if(ret)
    {
        printk("copy_from_user is filed\n");
        return -EIO;
    }
    /*
    switch(kbuf[0])
    {

        //LED1
        case '1':
            switch(kbuf[1])
            {
                case '0':
                    //关灯逻辑
                    (*vir_gpioe_odr) &amp;= (~(0x1 &lt;&lt; 10));
                    break;
                case '1':
                    //开灯逻辑
                    (*vir_gpioe_odr) |= (0x1 &lt;&lt; 10);
                    break;
            }
            break;
        //LED2
        case '2':
            switch(kbuf[1])
            {
                case '0':
                    //关灯逻辑
                    (*vir_gpiof_odr) &amp;= (~(0x1 &lt;&lt; 10));
                    break;
                case '1':
                    //开灯逻辑
                    (*vir_gpiof_odr) |= (0x1 &lt;&lt; 10);
                    break;
            }
            break;
        //LED3
         case '3':
            switch(kbuf[1])
            {
                case '0':
                    //关灯逻辑
                    (*vir_gpioe_odr) &amp;= (~(0x1 &lt;&lt; 8));
                    break;
                case '1':
                    //开灯逻辑
                    (*vir_gpioe_odr) |= (0x1 &lt;&lt; 8);
                    break;
            }
            break;
    }
    */
    return 0;
}

int mycdev_close(struct inode *inode, struct file *file)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    return 0;
}
//long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
long mycdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    // int which;
    // int ret;
    // ret = copy_from_user(&amp;which , (void *) arg, 4);
    // if(ret)
    // {
    //     printk("copy_from_user is filed\n");
    //     return -EIO;
    // }
    int min = (int)file-&gt;private_data;
    switch(min)
    {
        case 0:
            switch(cmd)
            {
                case LED_OFF:
                (*vir_gpioe_odr) &amp;= (~(0x1 &lt;&lt; 10));
                break;
                case LED_ON:
                (*vir_gpioe_odr) |= (0x1 &lt;&lt; 10);
                break;
            }
            break;
        case 1:
            switch(cmd)
            {
                case LED_OFF:
                    (*vir_gpiof_odr) &amp;= (~(0x1 &lt;&lt; 10));
                    break;
                case LED_ON:
                    (*vir_gpiof_odr) |= (0x1 &lt;&lt; 10);
                    break;
            }
            break;
        case 2:
            switch(cmd)
            {
                case LED_OFF:
                (*vir_gpioe_odr) &amp;= (~(0x1 &lt;&lt; 8));
                break;
                case LED_ON:
                (*vir_gpioe_odr) |= (0x1 &lt;&lt; 8);
                break;
            }
            break;
    }
   
    return 0;
}
//定义一个操作方法结构体对象
struct file_operations fos = {
    .open = mycdev_open,
    .read = mycdev_read,
    .write = mycdev_write,
    .release = mycdev_close,
    .unlocked_ioctl = mycdev_ioctl,

};

//定义变量，存放major
unsigned int major;
//定义变量，接收class_create()函数得到的对象指针
struct class *cls;
//定义变量，接收device_create()函数得到的对象指针
struct device *dev;

//定义变量，主设备号，次设备号
unsigned int major=0;
unsigned int minor=0;
//定义变量，设备号
dev_t devnum;
//定义变量，存放申请类对象空间的首地址
struct cdev *cdev;
//定义变量，接收返回值
int ret;
//int __register_file(struct cdev *cdev, dev_t devnum, unsigned int major, unsigned int minor, struct class *cls, struct device *dev, struct file_operations *fos);
int __register_file(void);
//入口函数
static int __init mycdev_init(void)
{
    // __register_file(cdev, devnum, major,  minor, cls, dev, &amp;fos);
    __register_file();
    /*
    //注册设备驱动，申请0-255共256个资源（次设备号）
    major = register_chrdev(0, "mychardev", &amp;fos);
    if(major &lt; 0)
    {
        printk("注册设备驱动失败\n");
        return major;
    }
    printk("注册设备驱动成功:major = %d\n", major);
    
    //向上提供目录
    //函数原型struct class *class_create(owner, name);
    //功能：向上提供目录信息，申请一个struct class类对象空间并初始化
    //参数1：owner：指向当前模块自身的一个指针，填写THIS_MODULE
    //参数2：name:向上提交的目录名
    //返回值：成功返回申请到的class对象的首地址，失败返回一个指向内核顶层4k空间的指针
    cls = class_create(THIS_MODULE, "mychrdev");
    if(IS_ERR(cls))
    {
        printk("向上提供目录失败\n");
        return -PTR_ERR(cls);
    }
    printk("向上提供目录成功\n");
    //向上提供设备节点信息
    //函数原型struct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);
    int i;
    for(i=0; i&lt;3; i++)
    {
        dev = device_create(cls, NULL, MKDEV(major, i), NULL, "myled%d", i);
        if(IS_ERR(dev))
        {
            printk("向上提供设备节点信息失败\n");
            return -PTR_ERR(dev);
        }
    }
    printk("向上提供设备节点信息成功\n");
    */
   
    //物理内存映射到虚拟地址
    //GOIOE_MODER寄存器地址映射
    vir_gpioe_moder = ioremap(PHY_GPIOE_MODER, 4);
    if(NULL == vir_gpioe_moder)
    {
        printk("物理内存地址映射失败%d\n", __LINE__);
        return -EFAULT;
    }
    //GOIOE_ODR寄存器地址映射
    vir_gpioe_odr = ioremap(PHY_GPIOE_ODR, 4);
    if(NULL == vir_gpioe_odr)
    {
        printk("物理内存地址映射失败%d\n", __LINE__);
        return -EFAULT;
    }
    //GOIOF_MODER寄存器地址映射
    vir_gpiof_moder = ioremap(PHY_GPIOF_MODER, 4);
    if(NULL == vir_gpiof_moder)
    {
        printk("物理内存地址映射失败%d\n", __LINE__);
        return -EFAULT;
    }
    //GOIOF_ODR寄存器地址映射
    vir_gpiof_odr = ioremap(PHY_GPIOF_ODR, 4);
    if(NULL == vir_gpiof_odr)
    {
        printk("物理内存地址映射失败%d\n", __LINE__);
        return -EFAULT;
    }
    //RCC_AHB4ENSETR寄存器地址映射
    vir_rcc = ioremap(PHY_RCC, 4);
    if(NULL == vir_rcc)
    {
        printk("物理内存地址映射失败%d\n", __LINE__);
        return -EFAULT;
    }
    printk("物理内存地址映射成功\n");
    //寄存器初始化工作
    //RCC使能GPIOE/GPIOF组控制器
    (*vir_rcc) |= (0x3 &lt;&lt; 4);

      
    
    return 0;
}

//出口函数
static void __exit mycdev_exit(void)
{
    
    //取消内存映射
    iounmap(vir_gpioe_moder);
    iounmap(vir_gpioe_odr);

    iounmap(vir_gpiof_moder);
    iounmap(vir_gpiof_odr);

    iounmap(vir_rcc);
    
   //销毁设备节点信息
   int i;
   for(i=0; i&lt;3; i++)
   {
        device_destroy(cls, MKDEV(major, i));
   }
   
   //删除目录信息
   class_destroy(cls);

    //注销字符设备驱动对象
    cdev_del(cdev);
    //释放设备号
    unregister_chrdev_region(MKDEV(major, major), 3);
    //释放申请到的字符设备驱动对象空间
    kfree(cdev);
   //删除信息

    // //销毁设备节点信息
    // int i;
    // for(i=0; i&lt;3; i++)
    // {
    //     device_destroy(cls, MKDEV(major, i));
    // }

    // //销毁目录信息
    // class_destroy(cls);
    // //注销字符设备驱动
    // unregister_chrdev(major, "mychrdev");

}
//声明入口函数
module_init(mycdev_init);
//声明出口函数
module_exit(mycdev_exit);
//声明内核模块遵循GPL协议
MODULE_LICENSE("GPL");

//注册设备驱动，创建设备文件
//int __register_file(struct cdev *cdev, dev_t devnum, unsigned int major, unsigned int minor, struct class *cls, struct device *dev, struct file_operations *fos)
int __register_file(void)
{
    //1.申请字符设备驱动对象空间
    cdev = cdev_alloc();
    if(NULL == cdev)
    {
        printk("申请字符设备驱动对象空间失败\n");
        goto out1;
    }
    printk("申请字符设备驱动成功\n");
    //2.初始化对象 
    //函数原型： cdev_init(struct cdev *, const struct file_operations *);
    cdev_init(cdev, &amp;fos);
    //3.申请设备号
    if(0 == major)
    {
        ret = alloc_chrdev_region(&amp;devnum, minor, 3, "mychrdev");
        if(ret)
        {
            printk("申请设备号失败\n");
            goto out2;
        }
        major = MAJOR(devnum);
        minor = MINOR(devnum);
        printk("动态申请设备号成功\n");
    }
    else
    {
        ret = register_chrdev_region(MKDEV(major, minor), 3, "mychrdev");
        if(ret)
        {
            printk("申请设备号失败\n");
            goto out2;
        }
        printk("静态申请设备号成功\n");
    }
    
    //4.注册设备驱动到内核
    ret = cdev_add(cdev, MKDEV(major, minor), 3);
    if(ret)
    {
        printk("注册设备驱动到内核失败\n");
        goto out3;
    }
     printk("注册设备驱动到内核成功\n");
    //5.向上提交目录信息
    cls = class_create(THIS_MODULE, "mychrdev");
    if(IS_ERR(cls))
    {
        printk("向上提交目录失败\n");
        goto out4;
    }
    printk("向上提交目录成功\n");
    //6.向上提交设备节点信息
    int i;
    for(i=0; i&lt;3; i++)
    {
        dev = device_create(cls, NULL, MKDEV(major, i), NULL, "mychrdev%d", i);
        if(IS_ERR(dev))
        {
            printk("向上提交设备节点信息失败\n");
            goto out5;
        }
    }
    printk("向上提交设备节点信息成功\n");
    return 0;
    out5:
        //删除设备节点信息
        for(--i; i&gt;=0;  i--)
        {
            device_destroy(cls, MKDEV(major, i));
            return -PTR_ERR(dev);
        }
        //删除设备目录
        class_destroy(cls);
        return -PTR_ERR(cls);
    out4:
        //注销设备驱动
        cdev_del(cdev);
    out3:
        //释放设备号
        unregister_chrdev_region(MKDEV(major, major), 3);
    out2:
        //释放字符设备驱动对象空间
        kfree(cdev);
    out1:
        return ret;
}</code></pre> 
<p>应用层测试代码</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ioctl.h&gt;
#include "fsmp157a_led_head.h"

int main(int argc, char const *argv[])
{
    char buf[128] = "";
    char filename[128] = "";
    printf("请输入操作的设备文件\n");
    fgets(filename, sizeof(filename), stdin);
    filename[strlen(filename) - 1] = '\0';
    int fd = open(filename, O_RDWR);
    if(fd &lt; 0)
    {
        printf("打开设备文件失败\n");
        return -1;
    }
    printf("打开设备文件成功\n");
    while(1)
    {
       while(1)
       {
            ioctl(fd, LED_ON);
            sleep(1);
            ioctl(fd, LED_OFF);
            sleep(1);
       }
    }

    return 0;
}
</code></pre> 
<p>头文件</p> 
<pre><code class="language-cpp">#ifndef __HEAD_H__
#define __HEAD_H__

//GPIOE_MODER寄存器地址
#define PHY_GPIOE_MODER 0x50006000
//GPIOE_ODR寄存器地址
#define PHY_GPIOE_ODR 0X50006014

//GPIOF_MODER寄存器地址
#define PHY_GPIOF_MODER 0X50007000
//GPIOF_ODR寄存器地址
#define PHY_GPIOF_ODR 0X50007014

//RCC_AHB4ENSETR寄存器地址
#define PHY_RCC 0x50000A28

//构建开关等的功能码
#define LED_ON _IO('l', 1)
#define LED_OFF _IO('l', 0)
#endif</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d7dbc322375e612cd7e65d1ddce1507/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【计算机网络互联网边缘部分，核心部分】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f119c9f18fc23ad9a64eecf405d6cc4b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">leetcode1658. 将 x 减到 0 的最小操作数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>