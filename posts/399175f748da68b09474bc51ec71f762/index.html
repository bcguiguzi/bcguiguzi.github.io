<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 密钥保留服务keyring入门 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 密钥保留服务keyring入门" />
<meta property="og:description" content="Linux 密钥保留服务入门 Linux 密钥保留服务（Linux key retention service是在 Linux 2.6 中引入的，它的主要意图是在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。
本文将概述 Linux 密钥保留服务，定义它的术语，帮助您快速掌握 Linux 密钥的使用方法。您将通过示例代码了解如何在内核模块中使用 Linux 密钥保留服务。在编写本文时使用的内核版本是 2.6.20。
什么是密钥？ **密钥（key）**是一组密码学数据、身份验证标记或某些相似的元素，它在内核中由 struct key 表示。在 Linux 内核源代码中，struct key 是在 include/linux/key.h 下定义的。
清单 1 给出 struct key 中一些重要的字段。注意，为了支持密钥，已经修改了 task_struct、user_struct 和 signal_struct。
清单 1. struct key 中的重要字段 struct key {
atomic_t usage; /* number of references */
key_serial_t serial; /* key serial number */
struct key_type *type; /* type of key */" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/399175f748da68b09474bc51ec71f762/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-15T14:48:37+08:00" />
<meta property="article:modified_time" content="2021-01-15T14:48:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 密钥保留服务keyring入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Linux__0"></a>Linux 密钥保留服务入门</h2> 
<p><strong>Linux 密钥保留服务（Linux key retention service</strong>是在 Linux 2.6 中引入的，它的主要意图是在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。</p> 
<p>本文将概述 Linux 密钥保留服务，定义它的术语，帮助您快速掌握 Linux 密钥的使用方法。您将通过示例代码了解如何在内核模块中使用 Linux 密钥保留服务。在编写本文时使用的内核版本是 2.6.20。</p> 
<h3><a id="_7"></a>什么是密钥？</h3> 
<p>**密钥（key）**是一组密码学数据、身份验证标记或某些相似的元素，它在内核中由 <code>struct key</code> 表示。在 Linux 内核源代码中，<code>struct key</code> 是在 <code>include/linux/key.h</code> 下定义的。</p> 
<p>清单 1 给出 <code>struct key</code> 中一些重要的字段。注意，为了支持密钥，已经修改了 <code>task_struct</code>、<code>user_struct</code> 和 <code>signal_struct</code>。</p> 
<h6><a id="_1_struct_key__14"></a>清单 1. struct key 中的重要字段</h6> 
<p><code>struct key {<!-- --></code></p> 
<p><code>atomic_t usage; /* number of references */</code></p> 
<p><code>key_serial_t serial; /* key serial number */</code></p> 
<p><code>struct key_type *type; /* type of key */</code></p> 
<p><code>time_t expiry; /* time at which key expires (or 0) */</code></p> 
<p><code>uid_t uid; /* UID */</code></p> 
<p><code>gid_t gid; /* GID */</code></p> 
<p><code>key_perm_t perm; /* access permissions */</code></p> 
<p><code>unsigned short quotalen; /* length added to quota */</code></p> 
<p><code>unsigned short datalen; /* payload data length</code></p> 
<p><code>char *description;</code></p> 
<p><code>union {<!-- --></code></p> 
<p><code>unsigned long value;</code></p> 
<p><code>void *data;</code></p> 
<p><code>struct keyring_list *subscriptions;</code></p> 
<p><code>} payload; /* Actual security data */</code></p> 
<p><code>....</code></p> 
<p><code>....</code></p> 
<p><code>};</code></p> 
<h4><a id="_54"></a>密钥的属性</h4> 
<p>密钥具有以下属性：</p> 
<ul><li> <p><strong>序号（Serial number）</strong>：一个惟一的 32 位非零正数。</p> </li><li> <p><strong>类型（Type）</strong>：Linux 密钥保留服务定义两个标准密钥类型：user 和 keyring。要添加新的密钥类型，必须由一个内核服务注册它。用户空间程序不允许创建新的密钥类型。密钥类型在内核中由 <code>struct key_type</code> 表示，这是在 <code>include/linux/key.h</code> 中定义的。<code>key_type</code> 结构的一些重要字段见清单 2。</p> <h6><a id="_2_key_type__61"></a>清单 2. key_type 的重要字段</h6> <p><code>struct key_type {<!-- --></code></p> <p><code>const char *name;</code></p> <p><code>size_t def_datalen;</code></p> <p><code>/* Operations that can be defined for a key_type */</code></p> <p><code>int (*instantiate)(struct key *key, const void *data, size_t datalen);</code></p> <p><code>int (*update)(struct key *key, const void *data, size_t datalen);</code></p> <p><code>int (*match)(const struct key *key, const void *desc);</code></p> <p><code>void (*revoke)(struct key *key);</code></p> <p><code>void (*destroy)(struct key *key);</code></p> <p><code>void (*describe)(const struct key *key, struct seq_file *p);</code></p> <p><code>long (*read)(const struct key *key, char __user *buffer, size_t buflen);</code></p> <p><code>....</code></p> <p><code>....</code></p> <p><code>};</code></p> <p>还可以将一组操作与一个密钥类型相关联。<code>key_type</code> 可以定义以下操作：</p> 
  <ul><li><code>instantiate</code> 创建指定类型的一个新密钥。</li><li><code>describe</code> 输出描述这个密钥的文本。</li><li><code>match</code> 根据描述搜索密钥。</li><li><code>destroy</code> 清除与一个密钥相关的所有数据。</li><li><code>request_key</code> 搜索密钥。</li><li><code>revoke</code> 清除密钥数据并将密钥的状态改为 <code>REVOKED</code>。</li><li><code>read</code> 读取密钥数据。</li><li><code>update</code> 修改密钥。</li></ul> </li><li> <p><strong>描述（Description）</strong>：一个描述密钥的可输出字符串。这个属性还可以用来执行搜索操作。</p> </li><li> <p><strong>访问控制信息（Access control information）</strong>：每个密钥有一个所有者 ID、一个 GID 和一个权限掩码，权限掩码表示如何响应用户级或内核级程序。权限掩码给四个可能的密钥访问者类型各分配 8 位：所有者、用户、组和其他。在这 8 位中，只定义了 6 位。可能的权限如下：</p> 
  <ul><li><code>View</code> 允许权限持有者查看密钥属性。</li><li><code>Read</code> 允许权限持有者读取密钥并列出 keyring 的密钥。</li><li><code>Write</code> 允许权限持有者修改密钥或 keyring 的有效内容和修改链接的密钥。</li><li><code>Search</code> 允许权限持有者搜索 keyring 和寻找密钥。</li><li><code>Link</code> 允许权限持有者将特定的密钥或 keyring 链接到 keyring。</li><li><code>Set Attribute</code> 允许权限持有者设置密钥的 UID、GID 和权限掩码。</li></ul> </li><li> <p><strong>过期时间（Expiry Time）</strong>：密钥的生存期。密钥也可以是永久的。</p> </li><li> <p><strong>有效内容（Payload）</strong>：实际的安全内容。可以通过 <code>struct key_type</code> 定义的操作用数据对有效内容进行实例化，还可以读取数据或修改数据。对于内核来说，有效内容仅仅是一组数据。</p> </li><li> <p><strong>状态（State）</strong>：密钥可以处于以下状态：</p> 
  <ul><li><code>UNINSTANTIATED</code>：已经创建了密钥，但是还没有附加任何数据。</li><li><code>INSTANTIATED</code>：密钥已经实例化并附加了数据；这是一个_完整的_ 状态。</li><li><code>NEGATIVE</code>：这是一个临时状态，表示前面对用户空间的调用失败了。</li><li><code>EXPIRED</code>：表示密钥已经超过了预定义的生存期。</li><li><code>REVOKED</code>：一个用户空间操作将密钥转移到这个状态。</li><li><code>DEAD</code>：<code>key_type</code> 取消了注册。</li></ul> </li></ul> 
<h4><a id="_119"></a>密钥类型</h4> 
<p>有两种预定义的密钥类型：keyring 和 user。</p> 
<p><strong>keyring</strong> 包含一组到其他密钥或 keyring 的链接。有六种标准的 keyring：</p> 
<ol><li>线程特有的</li><li>进程特有的</li><li>会话特有的</li><li>用户特有的会话</li><li>用户默认的会话</li><li>组特有的（还未实现）</li></ol> 
<h6><a id="_132"></a>限额</h6> 
<p>对于一个用户可以拥有的密钥和 keyring 的数量有限制（密钥数量限额），对于在密钥描述和有效内容中使用的信息量也有限制（密钥大小限额）。进程特有的和线程特有的 keyring 不在用户限额的范围内。</p> 
<p>只有前三个 keyring 被自动搜索，自动搜索会按照次序进行。第四种类型（<em>用户特有的会话</em> keyring）不被直接搜索，但是，它通常会链接到一个_会话特有的_ keyring。登录进程（比如 PAM）将绑定到_用户默认的会话_ keyring，直到创建另一个会话为止。</p> 
<p>用户密钥由用户空间程序操作。</p> 
<h3><a id="_140"></a>三个新的系统调用</h3> 
<p>Linux 密钥保留服务提供三个新的系统调用，用来在用户空间中操作密钥。第一个是 <strong>add_key</strong>：</p> 
<p><code>key_serial_t add_key(const char *type, const char *desc,</code></p> 
<p><code>const void *payload, size_t plen,</code></p> 
<p><code>key_serial_t ring);</code></p> 
<p><code>add_key</code> 系统调用用来创建类型为 <code>type</code>、长度为 <code>plen</code> 的密钥。密钥描述由 <code>desc</code> 定义，它的有效内容由 <code>payload</code> 指定。密钥链接到 keyring <code>ring</code>。密钥类型可以是 <em>user</em> 或 <em>keyring</em>。其他任何密钥类型必须已经通过内核服务向内核注册，然后才能使用。如果密钥是 keyring 类型的，有效内容就应该是 <code>NULL</code>，<code>plen</code> 应该是零。</p> 
<p>下一个新的系统调用是 <strong>request_key</strong>：</p> 
<p><code>key_serial_t request_key(const char *type, const char *desc,</code></p> 
<p><code>const char *callout_info,</code></p> 
<p><code>key_serial_t dest_keyring);</code></p> 
<p><code>request_key</code> 系统调用搜索一个进程 keyring，寻找一个密钥。搜索密钥的基本算法见清单 3。</p> 
<h6><a id="_3_request_key__163"></a>清单 3. request_key 算法</h6> 
<p><code>search_into_each_subscribed_keyrings {<!-- --></code></p> 
<p><code>if(key is found){<!-- --></code></p> 
<p><code>return(found key);</code></p> 
<p><code>} else {<!-- --></code></p> 
<p><code>if(callout_info is NULL){<!-- --></code></p> 
<p><code>return(ERROR);</code></p> 
<p><code>} else {<!-- --></code></p> 
<p><code>Execute /sbin/request-key and pass callout_info as argument;</code></p> 
<p><code>}</code></p> 
<p><code>}</code></p> 
<p><code>}</code></p> 
<p>关于 <code>request_key</code> 算法的工作原理的详细信息，请参考 Documentation/keys-request-key.txt（参见 <a href="#artrelatedtopics" rel="nofollow">参考资料</a> 中的链接）。</p> 
<p>最后，系统调用 <strong>keyctl</strong> 提供许多用来管理密钥的函数。可以根据传递给 <code>keyctl</code> 的第一个参数在密钥上执行各种操作。下面列出 <code>keyctl</code> 的一部分操作：</p> 
<ul><li><code>KEYCTL_DESCRIBE</code> 描述一个密钥。</li><li><code>KEYCTL_READ</code> 从一个密钥读取有效内容数据。</li><li><code>KEYCTL_UPDATE</code> 更新指定的密钥。</li><li><code>KEYCTL_LINK</code> 将一个密钥链接到一个 keyring。</li><li><code>KEYCTL_UNLINK</code> 将密钥或 keyring 与另一个 keyring 的链接取消。</li><li><code>KEYCTL_JOIN_SESSION_KEYRING</code> 将一个会话 keyring 替换为新的会话 keyring。</li><li><code>KEYCTL_REVOKE</code> 取消一个密钥。</li><li><code>KEYCTL_CHOWN</code> 修改密钥的所有者。</li><li><code>KEYCTL_SETPERM</code> 修改密钥的权限掩码。</li><li><code>KEYCTL_CLEAR</code> 清除一个 keyring。</li><li><code>KEYCTL_SEARCH</code> 在一个 keyring 树中搜索密钥。</li><li><code>KEYCTL_INSTANTIATE</code> 对部分构造好的密钥进行实例化。</li><li><code>KEYCTL_NEGATE</code> 取消对部分构造好的密钥的实例化。</li></ul> 
<p>关于 <code>keyctl</code> 的原型和 <code>keyctl</code> 可以执行的其他操作的更多信息，请参考 Linux 手册页。</p> 
<h3><a id="_API_207"></a>管理密钥的内核 API</h3> 
<p>下面是几个用来管理密钥的最重要的 Linux 内核 API。要想了解更全面的信息，请下载并参考 Linux 密钥实现源代码文件（参见下面的 <a href="#artdownload" rel="nofollow">下载</a>）。</p> 
<ul><li> <p><strong>register_key_type</strong> 用来定义新的密钥类型。</p> </li><li> <p>如果已经存在名称相同的密钥类型，那么 <strong>int register_key_type(struct key_type *type)</strong> 返回 <code>EEXIT</code>。</p> </li><li> <p><strong>unregister_key_type</strong> 用来取消密钥类型的注册：</p> <p><code>void unregister_key_type(struct key_type *type);</code></p> </li><li> <p><strong>key_put</strong> 发布一个密钥：</p> <p><code>void key_put(struct key *key);</code></p> </li><li> <p><strong>request_key</strong> 搜索与给定的描述匹配的密钥：</p> <p><code>struct key *request_key(const struct key_type *type,</code></p> <p><code>const char *description,</code></p> <p><code>const char *callout_string);</code></p> </li><li> <p><strong>key_alloc</strong> 分配指定类型的密钥：</p> <p><code>struct key *key_alloc(struct key_type *type, const char *desc,</code></p> <p><code>uid_t uid, gid_t gid, struct task_struct *ctx,</code></p> <p><code>key_perm_t perm, unsigned long flags);</code></p> </li><li> <p><strong>key_instantiate_and_link</strong> 对密钥进行实例化并将它链接到目标 keyring：</p> <p><code>int key_instantiate_and_link(struct key *key, const void *data,</code></p> <p><code>size_t datalen, struct key *keyring,</code></p> <p><code>struct key *instkey);</code></p> </li></ul> 
<h3><a id="_247"></a>启用密钥服务</h3> 
<p>因为 Linux 密钥保留服务仍然非常新，在默认情况下 Linux 内核中关闭了这个服务。要想启用密钥服务，必须使用 <code>CONFIG_KEYS=y</code> 选项对内核进行配置。可以在内核编译的 <code>make *config</code> 步骤中 <strong>Security options</strong> 下面找到这个选项。</p> 
<p>清单 4 给出在 Linux 内核中启用密钥服务的配置。</p> 
<h6><a id="_4__Linux__254"></a>清单 4. 在 Linux 内核中启用密钥服务</h6> 
<p><code>".config" file ...</code></p> 
<p><code>#</code></p> 
<p><code># Security options</code></p> 
<p><code>#</code></p> 
<p><code>CONFIG_KEYS=y</code></p> 
<p><code>CONFIG_KEYS_DEBUG_PROC_KEYS=y</code></p> 
<p><code>CONFIG_SECURITY=y</code></p> 
<p><code>CONFIG_SECURITY_NETWORK=y</code></p> 
<p><code>CONFIG_SECURITY_CAPABILITIES=y</code></p> 
<p>密钥的源代码被组织在目录 linux-2.6.x/security/keys 中。</p> 
<p>接下来，需要 <a href="http://people.redhat.com/~dhowells/keyutils/" rel="nofollow">下载并安装 keyutils 包</a>。<code>keyutils</code> 包含 <code>keyctl</code> 命令，可以使用这个命令在密钥上执行各种操作。前面已经列出了 <a href="#syscalls" rel="nofollow">keyctl 的一部分操作</a>。更多信息参见 Linux 手册页。</p> 
<h3><a id="_278"></a>创建新的密钥类型</h3> 
<p>学习 Linux 密钥保留服务最容易的方式就是进行实践。下面的示例使用 Linux 密钥保留服务创建一个新类型的密钥。如果还没有 <a href="#artdownload" rel="nofollow">下载示例程序</a>， 现在就执行这个步骤。执行 <code>make</code> 来构建内核模块和用户级程序的二进制代码。这些代码已经在 Linux 内核版本 2.6.20 上测试过了。</p> 
<p>示例程序有两个组件：一个内核模块和一个用户空间程序。这个内核模块注册一个新的密钥类型。这个用户空间程序在预定义的 <code>proc-entries</code> 上执行 <code>ioctl</code>，这会导致对内核模块的调用。这个调用会产生一个新的密钥。然后，一个 “bash” shell 返回给用户，它带有新的会话 keyring 和链接到这个 keyring 的新类型的密钥。</p> 
<p>因为这个用户空间程序将执行 <code>ioctl</code>，内核模块必须注册 <code>proc_ioctl()</code> 函数来处理 <code>ioctl</code> 请求。所有 <code>ioctl</code> 通信都使用 <code>/proc</code> 接口来进行。清单 5 给出在内核模块中声明的一个新的密钥类型。</p> 
<h6><a id="_5__287"></a>清单 5. 声明新的密钥类型</h6> 
<p><code>struct key_type new_key_type = {<!-- --></code></p> 
<p><code>.name = "mykey",</code></p> 
<p><code>.instantiate = instantiate_key,</code></p> 
<p><code>.describe = key_desc,</code></p> 
<p><code>.destroy = key_destroy,</code></p> 
<p><code>.match = key_match,</code></p> 
<p><code>};</code></p> 
<p>然后，模块在它的 <code>init</code> 函数中调用 <code>register_key_type()</code> 来注册这个新密钥类型（名为 <em>mykey</em>）。当内核模块收到 <code>ioctl</code> 请求时，它首先调用 <code>key_alloc()</code> 来分配一个新的密钥，从而创建一个会话 keyring。在成功调用 <code>key_alloc()</code> 之后，调用 <code>key_instantiate_and_link()</code> 对密钥进行实例化。在创建并实例化会话 keyring 之后，为用户的会话创建密钥。同样，依次调用 <code>key_alloc()</code> 和 <code>key_instantiate_and_link()</code>。成功完成这些调用之后，用户空间会话就有了一个新密钥。</p> 
<p>示例程序中演示了所有这些步骤。</p> 
<h3><a id="_307"></a>使用模块</h3> 
<p>创建了新的密钥类型之后，我们来试用一下这个内核模块。模块中的一个基本操作是查看一个进程与哪些 keyring 相关联，以及这些 keyring 包含哪些密钥和其他 keyring。调用 <code>keyctl show</code> 就可以在树结构中显示密钥。清单 6 显示在运行程序之前密钥的状态。</p> 
<h6><a id="_6__keyring_312"></a>清单 6. 查看进程的 keyring</h6> 
<p><code>[root@phoenix set.5]# keyctl show</code></p> 
<p><code>Session Keyring</code></p> 
<p><code>-3 --alswrv 0 0 keyring: _ses.1976</code></p> 
<p><code>2 --alswrv 0 0 \_ keyring: _uid.0</code></p> 
<p>清单 7 显示插入模块或者卸载模块或用户级程序的命令的输出。这些消息会放在一个系统日志文件中（通常是 /var/log/messages）。</p> 
<h6><a id="_7__324"></a>清单 7. 插入内核模块</h6> 
<p><code>[root@phoenix set.5]# insmod ./kernel.land/newkey.ko</code></p> 
<p><code>Loading the module ...</code></p> 
<p><code>Registered "learning_key"</code></p> 
<p>接下来，执行用户级程序。</p> 
<h6><a id="_8__335"></a>清单 8. 执行用户级程序</h6> 
<p><code>[root@phoenix set.5]# ./user.land/session</code></p> 
<p><code>In /var/log/message, you will see similar output</code></p> 
<p><code>Installing session keyring:</code></p> 
<p><code>keyring allocated successfully.</code></p> 
<p><code>keyring instantiated and linked successfully.</code></p> 
<p><code>New session keyring installed successfully.</code></p> 
<p><code>key of new type allocated successfully.</code></p> 
<p><code>New key type linked to current session.</code></p> 
<p>再看一下密钥的状态，见清单 9。</p> 
<h6><a id="_9__355"></a>清单 9. 运行用户级程序之后的密钥状态</h6> 
<p><code>[root@phoenix set.5]# keyctl show</code></p> 
<p><code>Session Keyring</code></p> 
<p><code>-3 --alswrv 0 0 keyring: session.2621</code></p> 
<p><code>39044642 --alswrv 0 0 \_ mykey: New key type</code></p> 
<p><code>[root@phoenix set.5]# cat /proc/keys</code></p> 
<p><code>00000001 I----- 1 perm 1f3f0000 0 0 keyring _uid_ses.0: 1/4</code></p> 
<p><code>00000002 I----- 5 perm 1f3f0000 0 0 keyring _uid.0: empty</code></p> 
<p><code>0253c622 I--Q-- 1 perm 3f3f0000 0 0 mykey New key type: 0</code></p> 
<p><code>11a490da I--Q-- 2 perm 3f3f0000 0 0 keyring session.2621: 1/4</code></p> 
<p><code>13670439 I--Q-- 2 perm 1f3f0000 0 0 keyring _ses.1977: 1/4</code></p> 
<p><code>159d39b8 I--Q-- 5 perm 1f3f0000 0 0 keyring _ses.1976: 1/4</code></p> 
<p><code>3a14f259 I--Q-- 3 perm 1f3f0000 0 0 keyring _ses.1978: 1/4</code></p> 
<p><code>[root@phoenix set.5]# cat /proc/key-users</code></p> 
<p><code>0: 8 7/7 5/100 136/10000</code></p> 
<p><code>43: 2 2/2 2/100 56/10000</code></p> 
<p><code>48: 2 2/2 2/100 56/10000</code></p> 
<p><code>81: 2 2/2 2/100 56/10000</code></p> 
<p><code>786: 4 4/4 4/100 113/10000</code></p> 
<p><code>"keyctl describe &lt;``Key``&gt;" command gives the description of key.</code></p> 
<p><code>[root@phoenix set.5]# keyctl describe -3</code></p> 
<p><code>-3: alswrvalswrv------------ 0 0 keyring: session.2621</code></p> 
<p><code>[root@phoenix set.5]# keyctl describe 39044642</code></p> 
<p><code>39044642: alswrvalswrv------------ 0 0 mykey: New key type</code></p> 
<p><code>[avinesh@phoenix set.5]$ keyctl search -3 mykey "New key type"</code></p> 
<p><code>39044642</code></p> 
<p><code>[root@phoenix set.5]# exit</code></p> 
<p><code>exit</code></p> 
<p><code>Now back to our previous state</code></p> 
<p><code>[root@phoenix set.5]# keyctl show</code></p> 
<p><code>Session Keyring</code></p> 
<p><code>-3 --alswrv 0 0 keyring: _ses.1976</code></p> 
<p><code>2 --alswrv 0 0 \_ keyring: _uid.0</code></p> 
<p><code>[root@phoenix set.5]# rmmod ./kernel.land/newkey.ko</code></p> 
<p><code>Unloading the module.</code></p> 
<p><code>Unregistered "learning_key"</code></p> 
<h4><a id="_proc__427"></a>与密钥相关的 proc 文件</h4> 
<p><code>/proc</code> 中添加了两个文件来管理密钥：/proc/keys 和 /proc/key-users。我们来仔细看看这些文件。</p> 
<p><strong>/proc/keys</strong></p> 
<p>如果一个进程希望了解它可以查看哪些密钥，它可以通过读取 /proc/keys 获得这些信息。在配置内核时，必须启用这个文件，因为它允许任何用户列出密钥数据库。</p> 
<h6><a id="_10_prockeys__435"></a>清单 10. /proc/keys 文件</h6> 
<p><code>[root@phoenix set.5]# cat /proc/keys</code></p> 
<p><code>00000001 I----- 1 perm 1f3f0000 0 0 keyring _uid_ses.0 : 1/4</code></p> 
<p><code>00000002 I----- 5 perm 1f3f0000 0 0 keyring _uid.0 : empty</code></p> 
<p><code>13670439 I--Q-- 2 perm 1f3f0000 0 0 keyring _ses.1977 : 1/4</code></p> 
<p><code>159d39b8 I--Q-- 6 perm 1f3f0000 0 0 keyring _ses.1976 : 1/4</code></p> 
<p><code>3a14f259 I--Q-- 3 perm 1f3f0000 0 0 keyring _ses.1978 : 1/4</code></p> 
<p><code>[Serial][Flags][Usage][Expiry][Permissions][UID][GID][TypeName][Description] :[Summary]</code></p> 
<p><em>*Source: linux_kernel_source/security/keys/proc.c:proc_keys_show()</em></p> 
<p>在以上文件中看到的大多数字段来自 include/linux/key.h 中定义的 <code>struct key</code>。可能的标志值见清单 11。</p> 
<h6><a id="_11_struct_key__456"></a>清单 11. struct key 字段可能的标志值</h6> 
<p><code>I Instantiated</code></p> 
<p><code>R Revoked</code></p> 
<p><code>D Dead</code></p> 
<p><code>Q Contributes to user's quota</code></p> 
<p><code>U Under construction by callback to user-space</code></p> 
<p><code>N Negative key</code></p> 
<p><strong>/proc/key-users</strong></p> 
<p>清单 12 显示 /proc/key-users 文件。</p> 
<h6><a id="_12_prockeyusers__475"></a>清单 12. /proc/key-users 文件</h6> 
<p><code>[root@phoenix set.5]# cat /proc/key-users</code></p> 
<p><code>0: 6 5/5 3/100 90/10000</code></p> 
<p><code>43: 2 2/2 2/100 56/10000</code></p> 
<p><code>48: 2 2/2 2/100 56/10000</code></p> 
<p><code>81: 2 2/2 2/100 56/10000</code></p> 
<p><code>786: 4 4/4 4/100 113/10000</code></p> 
<p>清单 13 给出每个字段的含义。</p> 
<h6><a id="_13_prockeyusers__492"></a>清单 13. /proc/key-users 文件的字段</h6> 
<p><code>&lt;``UID``&gt; User ID</code></p> 
<p><code>&lt;``usage``&gt; Usage count</code></p> 
<p><code>&lt;``inst``&gt;/&lt;``keys``&gt; Total number of keys and number instantiated</code></p> 
<p><code>&lt;``keys``&gt;/&lt;``max``&gt; Key count quota</code></p> 
<p><code>&lt;``bytes``&gt;&lt;``max``&gt; Key size quota</code></p> 
<p><em>*Source: linux_kernel_source/security/keys/proc.c:proc_key_users_show()</em></p> 
<p>大多数字段是 security/keys/internal.h 中定义的 <code>struct key_user</code> 的字段。</p> 
<h3><a id="_508"></a>结束语</h3> 
<p>Linux 密钥保留服务是一种新的机制，其用途是保存与安全相关的信息，让 Linux 内核可以快速地访问这些信息。这个服务仍然处于初级阶段，刚刚开始获得认可。OpenAFS 使用 Linux 密钥保留服务来实现进程身份验证组（PAG），NFSv4 和 MIT Kerberos 也使用它。Linux 密钥保留服务仍然在进行开发，以后可能会修改或改进。</p> 
<hr> 
<h5><a id="_515"></a>下载资源</h5> 
<ul><li><a href="http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=238919&amp;filename=key.retention.services.zip&amp;method=http&amp;locale=zh_CN" rel="nofollow">使用 Linux 密钥保留服务的示例应用程序</a> (key.retention.services.zip | 4KB)</li></ul> 
<hr> 
<h5><a id="_521"></a>相关主题</h5> 
<ul><li>您可以参阅本文在 developerWorks 全球站点上的 <a href="http://www.ibm.com/developerworks/linux/library/l-key-retention.html?S_TACT=105AGX52&amp;S_CMP=cn-a-l" rel="nofollow">英文原文</a> 。</li><li>“<a href="http://www.ibm.com/developerworks/cn/linux/l-seclnx1.html" rel="nofollow">让 Linux 更安全</a>”（developerWorks，2004 年 7 月）是分三部分的文章，介绍了 Linux 安全性。</li><li>“<a href="http://www.ibm.com/developerworks/cn/linux/l-system-calls/" rel="nofollow">使用 Linux 系统调用的内核命令</a>”（developerWorks，2007 年 3 月）介绍了 Linux 系统调用，并解释了如何将系统调用从用户空间传递到内核。</li><li>阅读 <a href="http://lxr.linux.no/source/Documentation/keys.txt" rel="nofollow">Documentation/keys.txt</a> 和 <a href="http://lxr.linux.no/source/Documentation/keys-request-key.txt" rel="nofollow">Documentation/keys-request-key.txt</a>，进一步了解 Linux 2.6 内核中密钥的概念和创建密钥的过程。</li><li><a href="http://lxr.linux.no/source/security/keys/" rel="nofollow">Linux key implementation sources</a> 是用来管理密钥的 Linux 内核 API。</li><li>David Howells 是 Linux 密钥保留服务的创建者。请参阅他在 2006 年渥太华 Linux 研讨会上 <a href="http://people.redhat.com/~dhowells/keys/keyrings-bof-ols2006.odp" rel="nofollow">讲话的幻灯片</a>。</li><li>“<a href="http://lwn.net/Articles/210502/" rel="nofollow">Kernel key management</a>” 提供了用来管理密钥的 Linux 内核 API 的更多信息。</li><li><a href="http://www.openafs.org/" rel="nofollow">OpenAFS</a> 使用 Linux 密钥保留服务实现它的进程身份验证组（PAG）。请查看 <a href="http://openafs.org/cgi-bin/cvsweb.cgi/openafs/src/afs/LINUX/osi_groups.c" rel="nofollow">源代码</a>。</li><li>下载 <a href="http://people.redhat.com/~dhowells/keyutils/" rel="nofollow">keyutils 包</a>，开始试用 Linux 密钥保留服务。</li><li>在 <a href="http://www.ibm.com/developerworks/cn/linux/" rel="nofollow">developerWorks Linux 专区</a> 中可以找到为 Linux 开发人员准备的更多参考资料。</li><li>使用 <a href="http://www.ibm.com/developerworks/downloads/?S_TACT=105AGX52&amp;S_CMP=cn-a-l" rel="nofollow">IBM 试用软件</a> 构建您的下一个 Linux 开发项目，这些软件可以从 developerWorks 直接下载。</li></ul> 
<p>以上主要参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-key-retention.html?S_TACT=105AGX52" rel="nofollow">Linux 密钥保留服务入门</a></p> 
<h6><a id="c_537"></a>c++实现的相关代码</h6> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;keyring/keyring.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token operator">::</span>string service_name <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>string account <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>string password_input <span class="token operator">=</span> <span class="token string">"password"</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>string password_output <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
  keyring<span class="token operator">::</span><span class="token function">set_password</span><span class="token punctuation">(</span>service_name<span class="token punctuation">,</span> account<span class="token punctuation">,</span> password_input<span class="token punctuation">)</span><span class="token punctuation">;</span>

  keyring<span class="token operator">::</span><span class="token function">get_password</span><span class="token punctuation">(</span>service_name<span class="token punctuation">,</span> account<span class="token punctuation">,</span> password_output<span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> password_output <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编程相关问题：</p> 
<ul><li>问题1:</li></ul> 
<p>使用keyutils时,</p> 
<p>.c或.cpp中包含</p> 
<blockquote> 
 <p>#include &lt;keyutils.h&gt;</p> 
</blockquote> 
<p>若你的工程为C的,这样子没有问题,<br> 若c++的,那会出现undefined reference add_key等原因:libkeyutils.so为C库</p> 
<p>在C++中,必须按以下的进程操作</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;keyutils.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> _cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> 
<p>即可以解决问题.</p> 
<ul><li>问题2:</li></ul> 
<p>在Makefile中加入</p> 
<blockquote> 
 <p>LIB += -lkeyutils</p> 
</blockquote> 
<ul><li>问题3:</li></ul> 
<p>一定要初始化keyutils库,具体方法如下:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

rc <span class="token operator">=</span> <span class="token function">keyctl</span><span class="token punctuation">(</span>KEYCTL_LINK<span class="token punctuation">,</span>KEY_SPEC_USER_KEYRING<span class="token punctuation">,</span>

              KEY_SPEC_SESSION_KERING<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>只有此处调用成功后,才能调用</p> 
<blockquote> 
 <p>add_key(“user”,…);</p> 
</blockquote> 
<p>否则,即使add_key成功,最后调用request_key也会失败，找不到才加入到keyring中的KEY.<br> 在内核中调用request_key也会失败,返回NOKEY.</p> 
<p>关于keyring的使用实例,eCryptfs中有使用它.</p> 
<p>查看当前keyring情况,可以使用</p> 
<blockquote> 
 <p>cat /proc/keys</p> 
</blockquote> 
<p>查看当前keyring的个数.</p> 
<h5><a id="_618"></a>其他相关：</h5> 
<p><a href="https://keyring.readthedocs.io/en/latest/" rel="nofollow">python中关于keyring的使用</a></p> 
<p><a href="https://wiki.archlinux.org/index.php/GNOME_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29/Keyring_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" rel="nofollow">GNOME (简体中文)/Keyring (简体中文)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18e2afeb68373a831e974db46001fe93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 打字机效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50f63f6263b9c807b2237f7d68d445ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">虹科工业树莓派：结合Codesys实现软PLC功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>