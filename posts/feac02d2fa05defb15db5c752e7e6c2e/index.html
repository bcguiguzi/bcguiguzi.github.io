<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>函数式思维: 为什么函数式编程越来越受关注 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="函数式思维: 为什么函数式编程越来越受关注" />
<meta property="og:description" content="简介： Java™ 即使不打算立刻改用函数式语言（比如 Scala 或 Clojure），Java 开发人员也应该了解函数式范式。随着时间的推移，所有主流语言都将变得更加函数化；Neal Ford 将在本期文章中探讨其中的原因。
关于本系列 本系列的目标是重新调整您对函数式思维的认识，帮助您以全新的方式思考常见问题，并寻找提升您的日常编码能力的方法。本系列文章将探讨函数编程概念、允许在 Java 语言中进行函数编程的框架、在 JVM 上运行的函数编程语言，以及语言设计的未来方向。本系列文章面向那些了解 Java 及其抽象工作原理，但对函数式语言不甚了解的开发人员。
到目前为止，在本系列的每期文章中，我都说明了为什么理解函数式编程非常重要。但是，有些原因是在多期文章中进行说明的，只有在综合思路的更大背景中，才可以完全了解这些原因。在本期文章中，我会探讨函数式编程方兴未艾的所有原因，并综合前几期文章中的一些个人经验教训。
在计算机科学短短的发展历史中，技术的主流有时会产生分支，包括实用分支和学术分支。20 世纪 90 年代的 4GL（第四代语言）是一个实用分支，而函数式编程是来自学术界的一个示例。每隔一段时间，都会有一些分支加入主流，函数式编程目前也是这种情况。函数式语言不仅在 JVM 上刚刚崭露头脚（其中两个最有趣的新语言是 Scala 和 Clojure），在 .NET 平台上也是才开始得到应用，在 .NET 平台上，F# 是头等公民。为什么所有平台都如此欢迎函数式编程？答案是，随着时间的推移，随着运行时都要能够处理更多的繁忙工作，开发人员已经能够将日常任务的更多控制权割让给它们。
割让控制权
在 20 世纪 80 年代初，在我上大学的时候，我们使用一个被称为 Pecan Pascal 的开发环境。其独特的特性是，相同的 Pascal 代码可以在 Apple II 或 IBM PC 上运行。Pecan 工程师使用某个称为 “字节码” 的神秘东西实现了这一壮举。开发人员将 Pascal 代码编译为 “字节码”，它可以在每个平台本地编写的 “虚拟机” 上运行。这是一个可怕的体验！所生成的代码慢得让人痛苦，甚至简单的类赋值也非常缓慢。当时的硬件还没有准备好迎接这个挑战。
在发布 Pecan Pascal 之后的十年，Sun 发布了 Java，Java 使用了相同的架构，对于 20 世纪 90 年代中期的硬件环境，运行该代码显得有些紧张，但最终取得了成功。Java 还增加了其他开发人员友好的特性，如自动垃圾收集。使用过像 C&#43;&#43; 这样的语言之后，我再也不想在没有垃圾收集的语言中编写代码。我宁愿花将时间花在更高层次上的抽象上，思考解决复杂业务问题的方法，也不愿意在内存管理等复杂的管道问题上浪费时间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/feac02d2fa05defb15db5c752e7e6c2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-07-11T09:44:08+08:00" />
<meta property="article:modified_time" content="2013-07-11T09:44:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">函数式思维: 为什么函数式编程越来越受关注</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; text-align:left"> </p> 
<div id="dw-summary-article" style="width:930px; margin-top:3px; border-bottom-color:rgb(204,204,204); border-bottom-style:solid; border-bottom-width:1px; font-family:Simsun; text-align:left; font-size:14px"> 
 <div class="ibm-container-body ibm-two-column" style="overflow-x:visible; overflow-y:visible; height:165px"> 
  <div class="ibm-column ibm-first" style="width:500px; float:left; padding-left:14px; margin-bottom:10px"> 
   <p style="font-family:arial,nsimsun,sans-serif; font-size:0.76em; margin-top:0em; margin-right:0em; margin-bottom:0em; margin-left:0em; padding-top:0em; padding-right:0em; padding-bottom:1em; padding-left:0em"> <strong>简介：</strong> Java™ 即使不打算立刻改用函数式语言（比如 Scala 或 Clojure），Java 开发人员也应该了解函数式范式。随着时间的推移，所有主流语言都将变得更加函数化；Neal Ford 将在本期文章中探讨其中的原因。</p> 
  </div> 
 </div> 
</div> 
<div id="ibm-content-body" style="width:930px; padding-top:15px; padding-right:0px; padding-bottom:15px; padding-left:0px; clear:both; font-family:Simsun; text-align:left; font-size:14px"> 
 <div id="ibm-content-main" style="float:left; clear:left; width:710px; padding-left:10px"> 
  <div class="ibm-container" style="margin-top:0px; margin-right:0px; margin-bottom:1.2em; margin-left:0px; width:710px"> 
   <div class="ibm-container ibm-alt-header dw-container-sidebar" style="margin-top:0px; margin-right:0px; margin-bottom:1.2em; margin-left:10px; width:320px; float:right"> 
    <h3 style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,248,252); border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:3px; padding-right:5px; padding-bottom:3px; padding-left:5px; height:15px; font-size:0.75em"> 关于本系列</h3> 
    <div class="ibm-container-body" style="border-bottom-color:rgb(204,204,204); border-bottom-style:solid; border-bottom-width:1px; border-left-color:rgb(204,204,204); border-left-style:solid; border-left-width:1px; border-right-color:rgb(204,204,204); border-right-style:solid; border-right-width:1px; font-size:0.76em; font-family:arial,sans-serif; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px"> 
     <p style="font-family:arial,nsimsun,sans-serif; font-size:0.76em; padding-left:5px; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em"> 本系列的目标是重新调整您对函数式思维的认识，帮助您以全新的方式思考常见问题，并寻找提升您的日常编码能力的方法。本系列文章将探讨函数编程概念、允许在 Java 语言中进行函数编程的框架、在 JVM 上运行的函数编程语言，以及语言设计的未来方向。本系列文章面向那些了解 Java 及其抽象工作原理，但对函数式语言不甚了解的开发人员。</p> 
    </div> 
   </div> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 到目前为止，在本系列的每期文章中，我都说明了为什么理解函数式编程非常重要。但是，有些原因是在多期文章中进行说明的，只有在综合思路的更大背景中，才可以完全了解这些原因。在本期文章中，我会探讨函数式编程方兴未艾的所有原因，并综合前几期文章中的一些个人经验教训。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在计算机科学短短的发展历史中，技术的主流有时会产生分支，包括实用分支和学术分支。20 世纪 90 年代的 4GL（第四代语言）是一个实用分支，而函数式编程是来自学术界的一个示例。每隔一段时间，都会有一些分支加入主流，函数式编程目前也是这种情况。函数式语言不仅在 JVM 上刚刚崭露头脚（其中两个最有趣的新语言是 Scala 和 Clojure），在 .NET 平台上也是才开始得到应用，在 .NET 平台上，F# 是头等公民。为什么所有平台都如此欢迎函数式编程？答案是，随着时间的推移，随着运行时都要能够处理更多的繁忙工作，开发人员已经能够将日常任务的更多控制权割让给它们。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N1008C"><span class="atitle" style="font-size:1.5em; font-weight:bold">割让控制权</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在 20 世纪 80 年代初，在我上大学的时候，我们使用一个被称为 Pecan Pascal 的开发环境。其独特的特性是，相同的 Pascal 代码可以在 Apple II 或 IBM PC 上运行。Pecan 工程师使用某个称为 “字节码” 的神秘东西实现了这一壮举。开发人员将 Pascal 代码编译为 “字节码”，它可以在每个平台本地编写的 “虚拟机” 上运行。这是一个可怕的体验！所生成的代码慢得让人痛苦，甚至简单的类赋值也非常缓慢。当时的硬件还没有准备好迎接这个挑战。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在发布 Pecan Pascal 之后的十年，Sun 发布了 Java，Java 使用了相同的架构，对于 20 世纪 90 年代中期的硬件环境，运行该代码显得有些紧张，但最终取得了成功。Java 还增加了其他开发人员友好的特性，如自动垃圾收集。使用过像 C++ 这样的语言之后，我再也不想在没有垃圾收集的语言中编写代码。我宁愿花将时间花在更高层次上的抽象上，思考解决复杂业务问题的方法，也不愿意在内存管理等复杂的管道问题上浪费时间。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> Java 缓解了我们与内存管理的交互；函数式编程语言使我们能够用高层次的抽象取代其他核心构建块，并更注重结果而不是步骤。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N1009B"><span class="atitle" style="font-size:1.5em; font-weight:bold">结果比步骤更重要</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 函数式编程的特点之一是存在强大的抽象，它隐藏了许多日常操作的细节（比如迭代）。我在本系列文章中一直使用的一个示例是数字分类：确定某个数字是 <em>perfect</em>、<em>abundant</em> 还是 <em>deficient</em>（完整的定义参见 <a href="http://www.ibm.com/developerworks/cn/java/j-ft1/index.html" rel="nofollow" style="color:rgb(153,102,153)">第一期文章</a>）。清单 1 中显示的 Java 实现可以解决这个问题：</p> 
   <br> 
   <a name="listing1"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 1. 自带缓存总数的 Java 数字分类器</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
import static java.lang.Math.sqrt;

public class ImpNumberClassifier {
    private Set&lt;Integer&gt; _factors;
    private int _number;
    private int _sum;

    public ImpNumberClassifier(int number) {
        _number = number;
        _factors = new HashSet&lt;Integer&gt;();
        _factors.add(1);
        _factors.add(_number);
        _sum = 0;
    }

    private boolean isFactor(int factor) {
        return _number % factor == 0;
    }

    private void calculateFactors() {
        for (int i = 1; i &lt;= sqrt(_number) + 1; i++)
            if (isFactor(i))
                addFactor(i);
    }

    private void addFactor(int factor) {
        _factors.add(factor);
        _factors.add(_number / factor);
    }

    private void sumFactors() {
        calculateFactors();
        for (int i : _factors)
            _sum += i;
    }

    private int getSum() {
        if (_sum == 0)
            sumFactors();
        return _sum;
    }

    public boolean isPerfect() {
        return getSum() - _number == _number;
    }

    public boolean isAbundant() {
        return getSum() - _number &gt; _number;
    }

    public boolean isDeficient() {
        return getSum() - _number &lt; _number;
    }
}
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing1" rel="nofollow" style="color:rgb(153,102,153)">清单 1</a> 中的代码是典型的 Java 代码，它使用迭代来确定和汇总系数。在使用函数式编程语言时，开发人员很少关心细节（比如迭代，由 <code style="font-size:small!important">calculateFactors()</code> 使用）和转换（比如汇总一个列表，该列表由 <code style="font-size:small!important">sumFactors()</code> 使用），宁愿将这些细节留给高阶函数和粗粒度抽象。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N100CC"><span class="atitle" style="font-size:1.5em; font-weight:bold">粗粒度的抽象</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 用抽象来处理迭代等任务，使得需要维护的代码变得更少，因此可能出现错误的地方也就更少。清单 2 显示了一个更简洁的数字分类器，用 Groovy 编写，借用了 Groovy 的函数风格方法：</p> 
   <br> 
   <a name="listing2"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 2. Groovy 数字分类器</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
import static java.lang.Math.sqrt

class Classifier {
  def static isFactor(number, potential) {
    number % potential == 0;
  }

  def static factorsOf(number) {
    (1..number).findAll { isFactor(number, it) }
  }

  def static sumOfFactors(number) {
    factorsOf(number).inject(0, {i, j -&gt; i + j})
  }

  def static isPerfect(number) {
    sumOfFactors(number) == 2 * number
  }

  def static isAbundant(number) {
    sumOfFactors(number) &gt; 2 * number
  }

  def static isDeficient(number) {
    sumOfFactors(number) &lt; 2 * number
  }
}
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing2" rel="nofollow" style="color:rgb(153,102,153)">清单 2</a> 中的代码使用很少的代码完成 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing1" rel="nofollow" style="color:rgb(153,102,153)">清单 1</a> 的所有工作（减去缓存总数，这会重新出现在下面的示例中）。例如，用于确定<code style="font-size:small!important">factorsOf()</code> 中的系数的迭代消失了，替换为使用 <code style="font-size:small!important">findAll()</code> 方法，它接受一个具有我的筛选器条件的代码块（一个高阶函数）。Groovy 甚至允许使用更简洁的代码块，它允许单参数块使用 <code style="font-size:small!important">it</code> 作为隐含参数名称。同样，<code style="font-size:small!important">sumOfFactors()</code> 方法使用了 <code style="font-size:small!important">inject()</code>，它（使用 0 作为种子值）将代码块应用于每个元素，将每个对减少为单一的值。<code style="font-size:small!important">{i, j -&gt; i + j}</code> 代码块返回两个参数的总和；每次将列表 “折叠” 成一个对时，都会应用此块，产生总和。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> Java 开发人员习惯于<em>框架</em> 级别的重用；在面向对象的语言中进行重用所需的必要构件需要非常大的工作量，他们通常会将精力留给更大的问题。函数式语言在更细化的级别提供重用，在列表和映射等基本数据结构之上通过高阶函数提供定制，从而实现重用。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N10109"><span class="atitle" style="font-size:1.5em; font-weight:bold">少量数据结构，大量操作</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在面向对象的命令式编程语言中，重用的单元是类以及与这些类进行通信的消息，这些信息是在类图中捕获的。该领域的开创性著作是 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>（参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#resources" rel="nofollow" style="color:rgb(153,102,153)">参考资料</a>），至少为每个模式提供一个类图。在 OOP 的世界中，鼓励开发人员创建独特的数据结构，以方法的形式附加特定的操作。函数式编程语言尝试采用不同的方式来实现重用。它们更喜欢一些关键的数据结构（如列表、集和映射），并且在这些数据结构上采用高度优化的操作。传递数据结构和高阶函数，以便 “插入” 这种机制，针对某一特定用途对其进行定制。例如，在 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing2" rel="nofollow" style="color:rgb(153,102,153)">清单 2</a> 中，<code style="font-size:small!important">findAll()</code> 方法接受使用一个代码块作为 “插件” 高阶函数（该函数确定了筛选条件），而该机制以有效方式应用了筛选条件，并返回经过筛选的列表。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 函数级的封装支持在比构建自定义类结构更细的基础级别上进行重用。此方法的优势之一已经体现在 Clojure 中。最近，库中的一些巧妙创新重写了 <code style="font-size:small!important">map</code> 函数，使它可以自动并行化，这意味着所有映射操作都可以受益于没有开发人员干预的性能提升。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 例如，考虑一下解析 XML 的情况。大量的框架可用于在 Java 中完成这个任务，每个框架都有自定义的数据结构和方法语义（例如，SAX 与 DOM）。Clojure 将 XML 解析为一个标准的 <code style="font-size:small!important">Map</code> 结构，而不是强迫您使用自定义的数据结构。因为 Clojure 中包含大量与映射配合使用的工具，如果使用内置的列表理解函数 <code style="font-size:small!important">for</code>，那么执行 XPath 样式的查询就会很简单，如清单 3 所示：</p> 
   <br> 
   <a name="listing3"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 3. 将 XML 解释为 Clojure</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
(use 'clojure.xml)

(def WEATHER-URI "http://weather.yahooapis.com/forecastrss?w=%d&amp;u=f")

(defn get-location [city-code]
  (for [x (xml-seq (parse (format WEATHER-URI city-code))) 
        :when (= :yweather:location (:tag x))]
    (str (:city (:attrs x)) "," (:region (:attrs x)))))

(defn get-temp [city-code]
  (for [x (xml-seq (parse (format WEATHER-URI city-code))) 
        :when (= :yweather:condition (:tag x))]
    (:temp (:attrs x))))

(println "weather for " (get-location 12770744) "is " (get-temp 12770744))
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing3" rel="nofollow" style="color:rgb(153,102,153)">清单 3</a> 中，我访问雅虎的气象服务来获取某个给定城市的气象预报。因为 Clojure 是 Lisp 的一个变体，所有从内部读取是最简单的。对服务端点的实际调用发生在 <code style="font-size:small!important">(parse (format WEATHER-URI city-code))</code> 上，它使用了 <code style="font-size:small!important">String</code> 的 <code style="font-size:small!important">format()</code> 函数将 <code style="font-size:small!important">city-code</code> 嵌入字符串。列表理解函数 <code style="font-size:small!important">for</code> 放置了解析后的 XML，使用 <code style="font-size:small!important">xml-seq</code> 将它投放到名称为 <code style="font-size:small!important">x</code> 的可查询映射中。<code style="font-size:small!important">:when</code> 谓词确定了匹配条件；在本例中，我要搜索一个标签（转换成一个 Clojure 关键字） <code style="font-size:small!important">:yweather:condition</code>。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 如欲了解从数据结构中读取值所用的语法，那么查看该语法中包含的内容会非常有用。在解析的时候，气象服务的相关调用会返回在此摘录中显示的数据结构：</p> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">({:tag :yweather:condition, :attrs {:text Fair, :code 34, :temp 62, :date Tue, 
   04 Dec 2012 9:51 am EST}, :content nil})
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 因为已经为了与映射配合使用而优化了 Clojure，所以关键字在包含它们的映射上成为了函数。在 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing3" rel="nofollow" style="color:rgb(153,102,153)">清单 3</a> 中，对 <code style="font-size:small!important">(:tag x)</code> 的调用是一个缩写，它等同于 “从存储在 <code style="font-size:small!important">x</code> 中的映射检索与 <code style="font-size:small!important">:tag</code> 键对应的值”。因此，<code style="font-size:small!important">:yweather:condition</code> 产生与该键关联的映射值，其中包括我使用相同语法从中提取 <code style="font-size:small!important">:temp</code> 的 <code style="font-size:small!important">attrs</code>。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 最初，Clojure 中令人生畏的细节之一是：与映射和其他核心数据结构进行交互的方法似乎有无限多种。然而，它反映了这样一个事实：在 Clojure 中，大多数内容都尝试解决这些核心的、优化的数据结构。它没有将解析的 XML 困在一个独特的框架中，相反，它试图将其转换为一个已存在相关工具的现有结构。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 对基础数据结构的依赖性的优点体现在 Clojure 的 XML 库中。为了遍历树形结构（如 XML 文档），1997 年创建了一个有用的数据结构，名为 <em>zipper</em>（参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#resources" rel="nofollow" style="color:rgb(153,102,153)">参考资料</a>）。zipper 通过提供坐标系方向，让您可以结构性地导航树。例如，可以从树的根开始，发出 <code style="font-size:small!important">(-&gt; z/down z/down z/left)</code> 等命令，导航到第二级的左侧元素。Clojure 中已经有现成的函数可将解析的 XML 转换为 zipper，在整个树形结构中实现一致的导航。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N101A1"><span class="atitle" style="font-size:1.5em; font-weight:bold">新的、不同的工具</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 函数式编程提供了新的工具类型，以优雅的方式解决棘手的问题。例如，Java 开发人员不习惯尽能延迟生成其值的<em>惰性</em> 数据结构。而未来的函数式语言将对这种高级特性提供支持，一些框架将此功能加装到 Java 中。例如，清单 4 所示的数字分类器版本使用了 Totally Lazy 框架（参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#resources" rel="nofollow" style="color:rgb(153,102,153)">参考资料</a>）：</p> 
   <br> 
   <a name="listing4"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 4. Java 数字分类器通过 Totally Lazy 使用惰性和函数式数据结构</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
import com.googlecode.totallylazy.Predicate;
import com.googlecode.totallylazy.Sequence;

import static com.googlecode.totallylazy.Predicates.is;
import static com.googlecode.totallylazy.numbers.Numbers.*;
import static com.googlecode.totallylazy.predicates.WherePredicate.where;


public class Classifier {
  public static Predicate&lt;Number&gt; isFactor(Number n) {
      return where(remainder(n), is(zero));
  }

  public static Sequence&lt;Number&gt; getFactors(final Number n){
      return range(1, n).filter(isFactor(n));
  }

  public static Sequence&lt;Number&gt; factors(final Number n) {
      return getFactors(n).memorise();
  }

  public static Number sumFactors(Number n){
      return factors(n).reduce(sum);
  }

  public static boolean isPerfect(Number n){
      return equalTo(n, subtract(sumFactors(n), n));
  }

  public static boolean isAbundant(Number n) {
    return greaterThan(subtract(sumFactors(n), n), n);
  }

  public static boolean isDeficient(Number n) {
    return lessThan(subtract(sumFactors(n), n), n);
  }

}
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> Totally Lazy 增加了惰性集合和流畅接口方法，大量使用静态导入，使代码具有可读性。如果您羡慕下一代语言中的某些特性，那么一些研究可能会提供可以解决某个特定问题的特定扩展。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N101BF"><span class="atitle" style="font-size:1.5em; font-weight:bold">让语言迁就问题</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 大多数开发人员都将他们的工作误解为接受一个复杂的业务问题，将它转换成 Java 等语言。他们的这种误解是因为 Java 并不是一种特别灵活的语言，它迫使您让自己的想法适应于已经存在的刚性结构。但是，当开发人员使用可塑语言时，他们看到了让语言迁就问题，而不是让问题迁就语言的机会。像 Ruby（它为领域特定语言 (DSL) 提供了比主流更友好的支持）等语言证明了这种潜在可能。现代函数式语言甚至走得更远。Scala 旨在协调内部 DSL 的托管，并且所有 Lisp（包括 Clojure）都可以提供无与伦比的灵活性，使开发人员能够让语言适应问题。例如，清单 5 使用了 Scala 中的 XML 基元来实现 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing3" rel="nofollow" style="color:rgb(153,102,153)">清单 3 </a>的天气示例：</p> 
   <br> 
   <a name="listing5"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 5. Scala 的 XML 语法修饰</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
import scala.xml._
import java.net._
import scala.io.Source

val theUrl = "http://weather.yahooapis.com/forecastrss?w=12770744&amp;u=f"

val xmlString = Source.fromURL(new URL(theUrl)).mkString
val xml = XML.loadString(xmlString)

val city = xml \\ "location" \\ "@city"
val state = xml \\ "location" \\ "@region"
val temperature = xml \\ "condition" \\ "@temp"

println(city + ", " + state + " " + temperature)
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> Scala 是为获得可塑性而设计的，它支持操作符重载和隐式类型等扩展。在 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing5" rel="nofollow" style="color:rgb(153,102,153)">清单 5</a> 中，Scala 被扩展为可以使用 <code style="font-size:small!important">\\</code> 操作符支持类似 XPath 的查询。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N101E2"><span class="atitle" style="font-size:1.5em; font-weight:bold">与语言的趋势相一致</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 函数式编程的目标之一是最大程度地减少可变状态。在 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing1" rel="nofollow" style="color:rgb(153,102,153)">清单 1</a> 中，有两种类型的共享状态清单。<code style="font-size:small!important">_factors</code> 和 <code style="font-size:small!important">_number</code> 都存在，它们使代码测试变得更容易（编写原代码版本是为了说明最大可测试性），并可以折叠成更大的函数，从而消除它们。但是，<code style="font-size:small!important">_sum</code> 是因为各种原因而存在。我预计，这段代码的用户可能需要检查多个分类。（例如，如果一个完美的检查失败，那么下一次我可能会检查百分比。）合计系数总数的操作可能很昂贵，所以我为它创建了一个经过惰性初始化的访问器。在第一次调用时，它会计算总和，并将它存储在 <code style="font-size:small!important">_sum</code> 成员变量中，以便优化未来的调用。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 像垃圾收集一样，现在缓存也可以降级用于语言。<a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing2" rel="nofollow" style="color:rgb(153,102,153)">清单 2</a> 中的 Groovy 数字分类器忽略了 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing1" rel="nofollow" style="color:rgb(153,102,153)">清单 1</a> 中总数的惰性初始化。如果想要实现同样的功能，可以修改分类器，如清单 6 所示：</p> 
   <br> 
   <a name="listing6"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 6. 手动添加一个缓存</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
class ClassifierCachedSum {
  private sumCache

  ClassifierCachedSum() {
    sumCache = [:]
  }

  def sumOfFactors(number) {
    if (sumCache.containsKey(number))
      return sumCache[number]
    else {
      def sum = factorsOf(number).inject(0, {i, j -&gt; i + j})
      sumCache.putAt(number, sum)
      return sum
    }
  }
  // ... other code omitted 
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 在最新版的 Groovy 中，<a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing6" rel="nofollow" style="color:rgb(153,102,153)">清单 6</a> 中的代码不再是必要的。考虑使用清单 7 中的改进版的分类器：</p> 
   <br> 
   <a name="listing7"><span style="padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em; font-family:arial,sans-serif">清单 7. 备忘数字分类器</span></a> 
   <br> 
   <table width="100%" cellpadding="0" cellspacing="0" border="0" style="font-size:0.8em"><tbody><tr><td class="code-outline" style="font-family:arial,nsimsun,sans-serif; background-color:rgb(247,247,247)!important; border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(204,204,204); border-right-color:rgb(204,204,204); border-bottom-color:rgb(204,204,204); border-left-color:rgb(204,204,204); padding-top:2px; padding-right:2px; padding-bottom:5px; padding-left:2px"> <pre class="displaycode" style="width:694px; margin-top:0px; margin-bottom:0px; font-family:'Andale Mono','Lucida Console',Monaco,Liberation,fixed,monospace; font-size:11px; overflow-x:auto; overflow-y:auto; background-color:rgb(247,247,247)!important">				
class ClassifierMemoized {
  def static dividesBy = { number, potential -&gt;
    number % potential == 0
  }
  def static isFactor = dividesBy.memoize()

  def static factorsOf(number) {
    (1..number).findAll { i -&gt; isFactor.call(number, i) }
  }

  def static sumFactors = { number -&gt;
    factorsOf(number).inject(0, {i, j -&gt; i + j})
  }
  def static sumOfFactors = sumFactors.memoize()

  def static isPerfect(number) {
    sumOfFactors(number) == 2 * number
  }

  def static isAbundant(number) {
    sumOfFactors(number) &gt; 2 * number
  }

  def static isDeficient(number) {
    sumOfFactors(number) &lt; 2 * number
  }
}
</pre> </td></tr></tbody></table> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 任何纯函数（没有副作用的函数）都可以<em>备忘</em>，比如 <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#listing7" rel="nofollow" style="color:rgb(153,102,153)">清单 7</a> 中的 <code style="font-size:small!important">sumOfFactors()</code> 方法。备忘函数允许运行时缓存重复出现的值，从而消除手工编写缓存的需要。事实上，请注意执行实际工作的 <code style="font-size:small!important">getFactors()</code> 和 <code style="font-size:small!important">factors()</code> 方法之间的关系，该方法是备忘版本的 <code style="font-size:small!important">getFactors()</code>。Totally Lazy 还为 Java 增加了备忘功能，这是反馈到主流中的另一个高级函数特性。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 由于运行时获得了更多的能力并且有多余的开销，开发人员可以将繁忙的工作割让给语言，将我们解放出来，去思考更重要的问题。Groovy 中的备忘功能就是众多示例中的一个；因为基础运行时允许这样做，所有现代语言都添加了函数式构造，包括 Totally Lazy 等框架。</p> 
   <div class="ibm-alternate-rule" style="clear:both; height:1px"></div> 
   <p class="ibm-ind-link ibm-back-to-top" style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; font-size:0.76em; clear:both; text-align:right; height:15px"> <a href="http://www.ibm.com/developerworks/cn/java/j-ft20/index.html#ibm-pcon" rel="nofollow" class="ibm-anchor-up-link" style="color:rgb(153,102,153); display:inline; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:18px; text-decoration:none; background-color:initial; font-weight:bold">回页首</a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="N10244"><span class="atitle" style="font-size:1.5em; font-weight:bold">结束语</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 因为运行时的能力变得更强，并且语言获得了更强大的抽象，所以开发世界变得更加函数化，这使开发人员可以花费更多的时间来思考结果的影响，而不是思考如何生成结果。由于高阶函数等抽象出现在语言中，它们将成为高度优化的操作的自定义机制。您不需要创建框架来处理问题（如 XML），您可以将其转换成您已经可以使用工具来处理的数据结构。</p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> 随着第 20 期文章的发布，<a href="http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?view_by=search&amp;sort_by=Date&amp;sort_order=desc&amp;view_by=Search&amp;search_by=%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E7%BB%B4&amp;dwsearch.x=21&amp;dwsearch.y=14" rel="nofollow" style="color:rgb(153,102,153)"><em>函数式思维</em></a> 将告一段落，我将准备开始一个新的系列，探索下一代的 JVM 语言。<a href="http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=Java+%E4%B8%8B%E4%B8%80%E4%BB%A3&amp;topic_by=-1&amp;type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&amp;ibm-search=%E6%90%9C%E7%B4%A2" rel="nofollow" style="color:rgb(153,102,153)"><em>Java 下一代</em></a> 会让您对不久的将来有一个大致了解，并帮助您对必须投入新语言学习的时间作出明智选择。</p> 
   <br> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <a name="resources"><span class="atitle" style="font-size:1.5em; font-weight:bold">参考资料</span></a></p> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <strong>学习</strong></p> 
   <ul style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:5px; font-size:0.76em"><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://oreilly.com/catalog/9780596519780/" rel="nofollow" style="color:rgb(153,102,153)"><em>The Productive Programmer</em></a> （Neal Ford，O'Reilly Media，2008 年）：Neal Ford 撰写的一本书籍，讨论了能够帮助您提高编码效率的工具和实践。<br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://www.scala-lang.org/" rel="nofollow" style="color:rgb(153,102,153)">Scala</a>：Scala 是运行在 JVM 上的一种现代函数式语言。<br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://clojure.org/" rel="nofollow" style="color:rgb(153,102,153)">Clojure</a>：Clojure 是运行在 JVM 上的一种现代函数式 Lisp。<br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional/dp/0201633612/ref%3Dsr_1_1%3Fie%3DUTF8%26s%3Dbooks%26qid%3D1236221690%26sr%3D1-1" rel="nofollow" style="color:rgb(153,102,153)"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></a>（Erich Gamma 等，Addison-Wesley，1994）：Gang of Four 有关设计模式的经典著作。 <br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://en.wikipedia.org/wiki/Zipper_%28data_structure%29" rel="nofollow" style="color:rgb(153,102,153)">Zipper</a>：阅读 Wikipedia 的 zipper 数据结构定义。<br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://www.ibm.com/developerworks/cn/java" rel="nofollow" style="color:rgb(153,102,153)">developerWorks Java 技术专区</a>：查找有关 Java 编程的方方面面的数百篇文章。 <br> <br> </li></ul> 
   <p style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0.3em; padding-right:5px; padding-bottom:0.7em; padding-left:5px; font-size:0.76em"> <strong>获得产品和技术</strong></p> 
   <ul style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:5px; font-size:0.76em"><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> <a href="http://code.google.com/p/totallylazy/" rel="nofollow" style="color:rgb(153,102,153)">Totally Lazy</a>：Totally Lazy 是一个函数式框架，它将惰性和流畅性添加到了 Java 中。<br> <br> </li><li style="font-family:arial,nsimsun,sans-serif; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-right:5px; padding-bottom:3px"> 下载 <a href="http://www.ibm.com/developerworks/cn/downloads/" rel="nofollow" style="color:rgb(153,102,153)">IBM 产品评估版</a> 或 <a href="http://www.ibm.com/developerworks/cn/downloads/soasandbox/" rel="nofollow" style="color:rgb(153,102,153)">在线试用 IBM SOA Sandbox</a> ，并开始使用来自 DB2®、Lotus®、Rational®、Tivoli® 和 WebSphere® 的应用程序开发工具和中间件产品。<br> </li></ul> 
  </div> 
 </div> 
</div> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f3de813a736f6b9c98b269c052adede/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">帮妹子修电脑最装逼的命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7606ad8493cab96a33880e4e4f1c4ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习十大算法的每个算法的核心思想、工作原理、适用情况及优缺点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>