<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;八股文--类和面向对象详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;八股文--类和面向对象详解" />
<meta property="og:description" content="目录
1. 类
1.1. 类定义
1.2. 对象创建访问
1.3. 类成员函数
1.3 类访问修饰符
1.4. 类构造函数和析构函数
1.5. 拷贝构造函数
1.6. 友元
1.7. 内联函数
1.8. this指针
1.9. 指向类的指针
1.10. 静态成员
2. 面向对象
2.1. 继承
2.2. 多态
2.3. 重载运算符
2.4. 重载函数
1. 类 1.1. 类定义 类定义包含：class关键字；类名称；类主体在一对花括号中，有类成员变量和类成员函数。本质上定义了一个数据蓝图，类对象有成员和操作。
class Box { public: double length; // 盒子长 double breadth; // 盒子宽 double height; // 盒子高 }; 静态建立：建立一个类对象，编译器为对象在栈中分配内存。
动态建立：Box *b = new Box(); 动态建立一个对象，编译器为对象在堆空间分配内存。
组合类：一个类的数据成员是另一个类的对象。创建时既要对基类成员初始化，又要对内嵌对象初始化。
1.2. 对象创建访问 Box Box1; // 声明 Box1 Box Box2; // 声明 Box2 // 访问用." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/933e67a7c67a450827cb048440659fa6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T14:43:41+08:00" />
<meta property="article:modified_time" content="2024-01-05T14:43:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;八股文--类和面向对象详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E7%B1%BB-toc" style="margin-left:0px;"><a href="#1.%20%E7%B1%BB" rel="nofollow">1. 类</a></p> 
<p id="1.1.%20%E7%B1%BB%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1.1.%20%E7%B1%BB%E5%AE%9A%E4%B9%89" rel="nofollow">1.1. 类定义</a></p> 
<p id="1.2.%20%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#1.2.%20%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE" rel="nofollow">1.2. 对象创建访问</a></p> 
<p id="1.3.%20%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.3.%20%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">1.3. 类成员函数</a></p> 
<p id="1.3%20%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.3%20%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">1.3 类访问修饰符</a></p> 
<p id="1.4.%C2%A0%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.4.%C2%A0%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">1.4. 类构造函数和析构函数</a></p> 
<p id="1.5.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.5.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">1.5. 拷贝构造函数</a></p> 
<p id="1.6.%20%E5%8F%8B%E5%85%83-toc" style="margin-left:80px;"><a href="#1.6.%20%E5%8F%8B%E5%85%83" rel="nofollow">1.6. 友元</a></p> 
<p id="1.7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" rel="nofollow">1.7. 内联函数</a></p> 
<p id="1.8.%20this%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.8.%20this%E6%8C%87%E9%92%88" rel="nofollow">1.8. this指针</a></p> 
<p id="1.9.%20%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.9.%20%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88" rel="nofollow">1.9. 指向类的指针</a></p> 
<p id="1.10.%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:80px;"><a href="#1.10.%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">1.10. 静态成员</a></p> 
<p id="2.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#2.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" rel="nofollow">2. 面向对象</a></p> 
<p id="2.1.%20%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#2.1.%20%E7%BB%A7%E6%89%BF" rel="nofollow">2.1. 继承</a></p> 
<p id="2.2.%20%E5%A4%9A%E6%80%81-toc" style="margin-left:80px;"><a href="#2.2.%20%E5%A4%9A%E6%80%81" rel="nofollow">2.2. 多态</a></p> 
<p id="2.3.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#2.3.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">2.3. 重载运算符</a></p> 
<p id="2.4.%20%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4.%20%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0" rel="nofollow">2.4. 重载函数</a></p> 
<p></p> 
<h2>1. 类</h2> 
<h4 id="1.1.%20%E7%B1%BB%E5%AE%9A%E4%B9%89">1.1. 类定义</h4> 
<p>类定义包含：class关键字；类名称；类主体在一对花括号中，有类成员变量和类成员函数。本质上定义了一个数据蓝图，类对象有成员和操作。</p> 
<pre><code class="language-cpp">class Box {
   public:
      double length;   // 盒子长
      double breadth;  // 盒子宽
      double height;   // 盒子高
};</code></pre> 
<p>静态建立：建立一个类对象，编译器为对象在栈中分配内存。</p> 
<p>动态建立：Box *b = new Box(); 动态建立一个对象，编译器为对象在堆空间分配内存。</p> 
<p>组合类：一个类的数据成员是另一个类的对象。创建时既要对基类成员初始化，又要对内嵌对象初始化。</p> 
<h4 id="1.2.%20%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE">1.2. 对象创建访问</h4> 
<pre><code class="language-cpp">Box Box1; // 声明 Box1
Box Box2; // 声明 Box2

// 访问用.
Box1.height = 5.0; 
Box1.length = 6.0; 
Box1.breadth = 7.0;</code></pre> 
<h4 id="1.3.%20%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">1.3. 类成员函数</h4> 
<p>类成员函数定义</p> 
<pre><code class="language-cpp">class Box {
   public:
      double length;      // 盒子长
      double breadth;     // 盒子宽
      double height;      // 盒子高
   
      double getVolume(void) { // 类成员函数内部定义：求盒子体积
         return length * breadth * height;
      }
};

// 类成员函数外部定义：求盒子体积
double Box::getVolume(void) {
    return length * breadth * height;
}</code></pre> 
<p>类成员函数调用</p> 
<pre><code class="language-cpp">Box myBox;          // 创建一个对象
 
myBox.getVolume();</code></pre> 
<h4 id="1.3%20%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">1.3 类访问修饰符</h4> 
<p>public：公有成员；类外部可以访问;</p> 
<p>protected：受保护成员；类外部不可访问，类、派生类和友元函数可以访问；</p> 
<p>private：私有成员；类外部不可访问，只有类和友元函数可以访问。</p> 
<h4 id="1.4.%C2%A0%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">1.4. 类构造函数和析构函数</h4> 
<p>构造函数：创建类的新对象时候，初始化成员。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Line {
   public:
      void setLength(double len);
      double getLength(void);
      Line(double len);  // 这是构造函数
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(double len) {
    cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl;
    length = len;
}
 
void Line::setLength(double len) {
    length = len;
}
 
double Line::getLength(void) {
    return length;
}
</code></pre> 
<p>列表初始化：</p> 
<pre><code class="language-cpp">C::C( double a, double b, double c): X(a), Y(b), Z(c) {
  ....
}</code></pre> 
<p>析构函数：删除创建对象，回收资源。析构函数不可抛出异常，以免控制权转出构造函数外造成内存泄漏。类有成员类对象，后者有析构函数，会以其声明顺序的相反顺序被调用。成员类对象有vptr，有任何上一层非虚基类有析构函数，以声明顺序被调用。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Line {
   public:
      void setLength(double len);
      double getLength(void);
      Line(); // 构造函数声明
      ~Line();// 析构函数声明
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void) {
    cout &lt;&lt; "Object is being created" &lt;&lt; endl;
}
Line::~Line(void) {
    cout &lt;&lt; "Object is being deleted" &lt;&lt; endl;
}
void Line::setLength(double len) {
    length = len;
}
 
double Line::getLength(void) {
    return length;
}
</code></pre> 
<h4 id="1.5.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">1.5. 拷贝构造函数</h4> 
<p>详见：<a href="https://blog.csdn.net/jy18817386398/article/details/135155979" title="C++八股文--基础详解-CSDN博客">C++八股文--基础详解-CSDN博客</a></p> 
<h4 id="1.6.%20%E5%8F%8B%E5%85%83">1.6. 友元</h4> 
<p>友元函数、友元类：定义在类外部，有权访问类的所有private和protected成员。</p> 
<p>代码示例：定义类Box和友元函数</p> 
<pre><code>class Box {
   double width;

public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
</code></pre> 
<pre><code>void printWidth(Box box) {
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout &lt;&lt; "Width of box : " &lt;&lt; box.width &lt;&lt;endl;
}</code></pre> 
<h4 id="1.7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">1.7. 内联函数</h4> 
<p>由inline定义，编译时该函数的代码副本会被放置在被调用的地方，函数体较小时，效率较高。滥用可能导致程序变慢。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

inline int Max(int x, int y) {
   return (x &gt; y)? x : y;
}

int main() {
   cout &lt;&lt; "Max (20,10): " &lt;&lt; Max(20,10) &lt;&lt; endl;
   return 0;
}
</code></pre> 
<h4 id="1.8.%20this%E6%8C%87%E9%92%88">1.8. this指针</h4> 
<p>作用：指向当前对象实例；隐藏指针。</p> 
<p>代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
 
class MyClass {
private:
    int value;
 
public:
    void setValue(int value) {
        this-&gt;value = value;
    }
 
    void printValue() {
        std::cout &lt;&lt; "Value: " &lt;&lt; this-&gt;value &lt;&lt; std::endl;
    }
};
 
int main() {
    MyClass obj;
    obj.setValue(42);
    obj.printValue();
    return 0;
}</code></pre> 
<h4 id="1.9.%20%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88">1.9. 指向类的指针</h4> 
<p>指向类的指针访问<strong>-&gt;。</strong></p> 
<p>代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

class Box {
   public:
      Box(double l=2.0, double b=2.0, double h=2.0) {
         cout &lt;&lt;"Constructor called." &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume() {
         return length * breadth * height;
      }
   private:
      double length;     // Length of a box
      double breadth;    // Breadth of a box
      double height;     // Height of a box
};

int main(void) {
   Box Box1(3.3, 1.2, 1.5);    // Declare box1
   Box *ptrBox;                // Declare pointer to a class.

   ptrBox = &amp;Box1;
   cout &lt;&lt; "Volume of Box1: " &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;
   return 0;
}
</code></pre> 
<h4 id="1.10.%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">1.10. 静态成员</h4> 
<p>static修饰的成员，类的所有对象共享，在类外初始化。</p> 
<p>类的成员变量代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
class Box {
   public:
      static int objectCount;
      Box(double l=2.0, double b=2.0, double h=2.0) {
         cout &lt;&lt;"Constructor called." &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
         objectCount++;
      }
      double Volume()  {
         return length * breadth * height;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};
 
// 初始化类 Box 的静态成员
int Box::objectCount = 0;
 
int main(void) {
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
 
   // 输出对象的总数
   cout &lt;&lt; "Total objects: " &lt;&lt; Box::objectCount &lt;&lt; endl;
   return 0;
}</code></pre> 
<p>类的成员函数代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
class Box {
   public:
      static int objectCount;
      Box(double l=2.0, double b=2.0, double h=2.0) {
         cout &lt;&lt;"Constructor called." &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
         objectCount++;
      }
      double Volume() {
         return length * breadth * height;
      }
      static int getCount() {
         return objectCount;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};
// 初始化类 Box 的静态成员
int Box::objectCount = 0;
int main(void) {
   cout &lt;&lt; "Inital Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl;
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
   cout &lt;&lt; "Final Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl;
   return 0;
}</code></pre> 
<h2 id="2.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">2. 面向对象</h2> 
<h4 id="2.1.%20%E7%BB%A7%E6%89%BF">2.1. 继承</h4> 
<p>继承定义：依据原始定义类来定义另一个新建类，这样代码可复用，效率高。原始定义类为基类，新建类为派生类。派生类继承了基类所有方法，除构造函数、析构函数、拷贝构造函数、重载运算符、友元函数。一个派生类可以有多个基类。</p> 
<p>继承类型：public，protected(基类public和protected成员变为派生类protected成员)，private(基类public和protected成员变为派生类private成员)。</p> 
<p>代码示例：</p> 
<pre><code>// 基类
class Animal {
    eat()；
    sleep()；
};


//派生类
class Dog : public Animal {
    bark();
};</code></pre> 
<p>继承访问控制</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>访问</td><td>public</td><td>protected</td><td>private</td></tr><tr><td>同一个类</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>派生类</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>外部类</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table> 
<h4 id="2.2.%20%E5%A4%9A%E6%80%81">2.2. 多态</h4> 
<p>多态定义：顾名思义，多种形态。</p> 
<p>多态代码示例：</p> 
<pre><code>#include &lt;iostream&gt; 
using namespace std;
 
class Shape {
   protected:
      int width, height;
   public:
      Shape(int a=0, int b=0) {
         width = a;
         height = b;
      }
      int area() {
         cout &lt;&lt; "Parent class area :" &lt;&lt;endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle(int a=0, int b=0):Shape(a, b) { }
      int area () { 
         cout &lt;&lt; "Rectangle class area :" &lt;&lt;endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle(int a=0, int b=0):Shape(a, b) { }
      int area () { 
         cout &lt;&lt; "Triangle class area :" &lt;&lt;endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main() {
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
 
   // 存储矩形的地址
   shape = &amp;rec;
   // 矩形求面积
   shape-&gt;area();
 
   // 存储三角形的地址
   shape = &amp;tri;
   // 三角形求面积函数
   shape-&gt;area();
   return 0;
}</code></pre> 
<p>虚函数：基类中用virtual声明，派生类中重新定义基类虚函数时候为<strong>动态链接</strong>或<strong>后期绑定。</strong></p> 
<p>纯虚函数：基类中定义的虚函数，未给出有意义的实现，派生类中会重新定义。</p> 
<p>哪些函数不是虚函数？构造函数：续表指针在构造函数中初始化；内联函数：虚函数需要运行期间确定类型，内联函数编译时替换；静态函数：不属于对象，属于类，设置没有意义；友元函数：不属于类成员函数，不能被继承；</p> 
<h4 id="2.3.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6">2.3. 重载运算符</h4> 
<p>代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
class Box {
   public:
      double getVolume(void) {
         return length * breadth * height;
      }
      void setLength(double len) {
          length = len;
      }
      void setBreadth(double bre) {
          breadth = bre;
      }
      void setHeight(double hei) {
          height = hei;
      }
      // 重载 + 运算符
      Box operator+(const Box&amp; b) {
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
      }
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
};
// 程序的主函数
int main( )
{
   Box Box1; 
   Box Box2;
   Box Box3;
   double volume = 0.0;     // 把体积存储在该变量中
 
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);

   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   volume = Box1.getVolume();
   cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl;
 
   volume = Box2.getVolume();
   cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl;
 
   Box3 = Box1 + Box2;
   volume = Box3.getVolume();
   cout &lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt;endl;

   return 0;
}</code></pre> 
<h4 id="2.4.%20%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">2.4. 重载函数</h4> 
<p>代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
class printData {
   public:
      void print(int i) {
        cout &lt;&lt; "整数为: " &lt;&lt; i &lt;&lt; endl;
      }
      void print(double  f) {
        cout &lt;&lt; "浮点数为: " &lt;&lt; f &lt;&lt; endl;
      }
      void print(char c[]) {
        cout &lt;&lt; "字符串为: " &lt;&lt; c &lt;&lt; endl;
      }
};
 
int main(void)
{
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = "Hello C++";
   pd.print(c);
   return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d75a5ab0e8ce55eff86fe65aafedcb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络工程和网络安全的区别在哪里？就业方向薪资有何不同</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f42c8fbff53bb07d636bd161323b33d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;八股文详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>