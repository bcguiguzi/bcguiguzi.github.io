<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>事务，事务的特性和使用以及sql优化 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="事务，事务的特性和使用以及sql优化" />
<meta property="og:description" content="事务 : 每条sql语句都是一个独立操作，一个操作对数据库的影响是永久性的。
事务是一个原子操作，是最小执行单元，由一个或多个sql语句组成。在同一个事务中，所有的sql语句都执行成功时，整个事务成功。有一个sql语句执行失败，整个事务都执行失败
事务是基于增删改语句的操作
原理：数据库会为每个客户端都维护一个空间独立的缓存区（回滚段），一个事务中所有的增删改语句的执行结果都会缓存在回滚段中，当所有sql语句均正常结束，才会将回滚段中的数据同步到数据库，无论因为什么失败，整个事务将回滚 事务的特性： Atomicity （原子性） 表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败Consistency（一致性） 表示一个事务内有一个操作失败时，所有的更改过的数据都必需回滚到修改前状态Isolation （隔离性） 事务查看数据操作时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事物修改它之后的状态，不会查看中间状态的数据Durability（持久性） 持久性事务完成之后，它对于系统的影响性是永久的 START TRANSACTION; #开启事务 SETAUTOCOMMIT = 0;#禁止自动提交 = 1 #开启自动提交 # 增删改 # 增删改 # 。。。 COMMIT; # 所有语句成功 提交 ROLLBACK;# 事务出现错误，回滚 索引： ​ 索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据
注意： ​ 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够
​ 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行
索引的优缺点： 优势：可以快速检索，减少I/O次数；根据索引分组和排序，可以加快分组和排序；
劣势：索引本身也是表，因此会占用存储空间，维护和创建需要时间成本；也会降低数据表的修改操作的效率，因为在修改数据表的同时还需要修改索引表；
索引的分类： 1、主键索引：即主索引，根据主键 建立索引，不允许重复，不允许空值；
2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值
3、普通索引：用表中的普通列构建的索引，没有任何限制
4、全文索引：用大文本对象的列构建的索引
5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值
6、组合唯一索引：列值的组合必须唯一
### mysql优化： - 选择合适的数据类型 - 避免空值 ，null字段依旧会占用空间，使索引更加复杂，使用有意义的值代替null 也能避免 is not null 的使用 - text类型优化：text字段存储数据量大，容易影响其他字段的查询 ，单独取出来放在子表里，用业务主键关联。 - 索引优化：分页查询。单表索引数不超过5个、单个索引字段数不超过5个 - 操作符&lt;&gt; 优化， 通常&lt;&gt;操作符无法使用索引 使用 union (all) 代替 &lt;&gt; - OR 优化 在Innodb引擎下or无法使用组合索引 使用 union (all) 代替 OR - IN 优化 使用 left join代替 - 不做列运算 通常在查询条件列运算会导致索引失效 - 避免 * 的出现 - like优化 尽量不要前后都模糊的查询 如果要求前后都模糊 可以用全文索引fulltext，但Elasticsearch才是终极武 - join 优化 join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为	过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环	数据，再次到后一个表中查询数据。 ​	1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a17ffee55c4fb69beca8874b0c5452c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-09T10:00:23+08:00" />
<meta property="article:modified_time" content="2020-09-09T10:00:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">事务，事务的特性和使用以及sql优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="__0"></a>事务 :</h3> 
<p>每条sql语句都是一个独立操作，一个操作对数据库的影响是永久性的。</p> 
<p>事务是一个原子操作，是最小执行单元，由一个或多个sql语句组成。在同一个事务中，所有的sql语句都执行成功时，整个事务成功。有一个sql语句执行失败，整个事务都执行失败</p> 
<p>事务是基于增删改语句的操作</p> 
<h6><a id="sql_8"></a>原理：数据库会为每个客户端都维护一个空间独立的缓存区（回滚段），一个事务中所有的增删改语句的执行结果都会缓存在回滚段中，当所有sql语句均正常结束，才会将回滚段中的数据同步到数据库，无论因为什么失败，整个事务将回滚</h6> 
<h3><a id="_9"></a>事务的特性：</h3> 
<ol><li>Atomicity （原子性） 表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败</li><li>Consistency（一致性） 表示一个事务内有一个操作失败时，所有的更改过的数据都必需回滚到修改前状态</li><li>Isolation （隔离性） 事务查看数据操作时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事物修改它之后的状态，不会查看中间状态的数据</li><li>Durability（持久性） 持久性事务完成之后，它对于系统的影响性是永久的</li></ol> 
<pre><code class="prism language-java">START TRANSACTION<span class="token punctuation">;</span> #开启事务
SETAUTOCOMMIT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>#禁止自动提交    <span class="token operator">=</span> <span class="token number">1</span> #开启自动提交
# 增删改
# 增删改
# 。。。
COMMIT<span class="token punctuation">;</span> # 所有语句成功 提交
ROLLBACK<span class="token punctuation">;</span># 事务出现错误，回滚
</code></pre> 
<h3><a id="_26"></a>索引：</h3> 
<p>​ 索引<strong>是一个排序的列表</strong>，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据</p> 
<h6><a id="_30"></a>注意：</h6> 
<p>​ 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够</p> 
<p>​ 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行</p> 
<h6><a id="_36"></a>索引的优缺点：</h6> 
<p>优势：可以快速检索，减少I/O次数；根据索引分组和排序，可以加快分组和排序；</p> 
<p>劣势：索引本身也是表，因此会占用存储空间，维护和创建需要时间成本；也会降低数据表的修改操作的效率，因为在修改数据表的同时还需要修改索引表；</p> 
<h6><a id="_42"></a>索引的分类：</h6> 
<p>1、主键索引：即主索引，根据主键 建立索引，不允许重复，不允许空值；</p> 
<p>2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值</p> 
<p>3、普通索引：用表中的普通列构建的索引，没有任何限制</p> 
<p>4、全文索引：用大文本对象的列构建的索引</p> 
<p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p> 
<p>6、组合唯一索引：列值的组合必须唯一</p> 
<pre><code>### mysql优化：

- 选择合适的数据类型

- 避免空值 ，null字段依旧会占用空间，使索引更加复杂，使用有意义的值代替null 也能避免 is  not  null  的使用

- text类型优化：text字段存储数据量大，容易影响其他字段的查询  ，单独取出来放在子表里，用业务主键关联。

- 索引优化：分页查询。单表索引数不超过5个、单个索引字段数不超过5个

- 操作符&lt;&gt; 优化， 通常&lt;&gt;操作符无法使用索引    使用 union (all)  代替 &lt;&gt; 

- OR 优化  在Innodb引擎下or无法使用组合索引   使用 union (all)  代替 OR

- IN 优化  使用 left join代替

- 不做列运算     通常在查询条件列运算会导致索引失效

- 避免 *  的出现

- like优化   尽量不要前后都模糊的查询   如果要求前后都模糊 可以用全文索引fulltext，但Elasticsearch才是终极武

- join 优化     join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为				  过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环					数据，再次到后一个表中查询数据。

  ​		1. 驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。

  ​		2. 被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。

  ​		3. 禁止join连接三个以上的表，尝试增加冗余字段。

- Limit优化   limit用于分页查询时越往后翻性能越差，解决的原则: 缩小扫描范围   用游标更快(JDBC用游标实现分页)
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e704b6bd8af3c3da7cfcb23e8426872/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库常用的四种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd1cbb0509d4a34f69b90e1479577265/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">latex：用minipage并排放置两个表格、两个图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>