<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMVC之Controller常用注解功能全解析 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMVC之Controller常用注解功能全解析" />
<meta property="og:description" content="一、简介
在SpringMVC中，控制器Controller负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model返回给对应的View进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping和@RequestParam等一些注解用以定义URL 请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet 对象，它们可以通过Controller的方法参数灵活的获取到。
为了先对Controller有一个初步的印象，以下先定义一个简单的Controller： @Controller public class MyController { @RequestMapping(&#34;/showView&#34;) public ModelAndView showView() { ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&#34;viewName&#34;); modelAndView.addObject(&#34; 需要放到 model 中的属性名称 &#34;, &#34; 对应的属性值，它是一个对象 &#34;); return modelAndView; } } 在上面的示例中，@Controller是标记在类MyController上面的，所以类MyController就是一个SpringMVC Controller对象了，然后使用@RequestMapping(“/showView”)标记在Controller方法上，表示当请求/showView.do的时候访问的是MyController的showView方法，该方法返回了一个包括Model和View的ModelAndView对象。这些在后续都将会详细介绍。
二、使用@Controller定义一个Controller控制器 @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器，这个接下来就会讲到。
单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC的一个控制器类，因为这个时候Spring还不认识它。那么要如何做Spring才能认识它呢？这个时候就需要我们把这个控制器类交给Spring来管理。拿MyController来举一个例子：
@Controller public class MyController { @RequestMapping(&#34;/showView&#34;) public ModelAndView showView() { ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&#34;viewName&#34;); modelAndView.addObject(&#34; 需要放到 model 中的属性名称 &#34;, &#34; 对应的属性值，它是一个对象 &#34;); return modelAndView; } } 这个时候有两种方式可以把MyController交给Spring管理，好让它能够识别我们标记的@Controller。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/18b79ca46f5bdb92175dad42f8438964/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-09T13:58:28+08:00" />
<meta property="article:modified_time" content="2016-08-09T13:58:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMVC之Controller常用注解功能全解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">一、简介</span></p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在SpringMVC中，控制器Controller负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model返回给对应的View进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping和@RequestParam等一些注解用以定义URL 请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet 对象，它们可以通过Controller的方法参数灵活的获取到。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 为了先对Controller有一个初步的印象，以下先定义一个简单的Controller：<br style=""> </p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
public class MyController {
  @RequestMapping("/showView")
  public ModelAndView showView() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("viewName");
    modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 ");
    return modelAndView;
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的示例中，@Controller是标记在类MyController上面的，所以类MyController就是一个SpringMVC Controller对象了，然后使用@RequestMapping(“/showView”)标记在Controller方法上，表示当请求/showView.do的时候访问的是MyController的showView方法，该方法返回了一个包括Model和View的ModelAndView对象。这些在后续都将会详细介绍。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">二、使用@Controller定义一个Controller控制器</span><br style=""> </p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器，这个接下来就会讲到。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC的一个控制器类，因为这个时候Spring还不认识它。那么要如何做Spring才能认识它呢？这个时候就需要我们把这个控制器类交给Spring来管理。拿MyController来举一个例子：</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
public class MyController {
  @RequestMapping("/showView")
  public ModelAndView showView() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("viewName");
    modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 ");
    return modelAndView;
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 这个时候有两种方式可以把MyController交给Spring管理，好让它能够识别我们标记的@Controller。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 第一种方式是在SpringMVC的配置文件中定义MyController的bean对象。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> &lt;bean class="com.host.app.web.controller.MyController"/&gt;</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 第二种方式是在SpringMVC的配置文件中告诉Spring该到哪里去找标记为@Controller的Controller控制器。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">&lt;context:component-scan base-package = "com.host.app.web.controller"&gt;
  &lt;context:exclude-filter type = "annotation" expression = "org.springframework.stereotype.Service" /&gt;
&lt;/context:component-scan&gt;</pre> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">注：上面 context:exclude-filter标注的是不扫描@Service标注的类。</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">三、使用@RequestMapping来映射Request请求与处理器</span></p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 可以使用@RequestMapping来映射URL到控制器类，或者是到Controller控制器的处理方法上。当@RequestMapping标记在Controller类上的时候，里面使用@RequestMapping标记的方法的请求地址都是相对于类上的@RequestMapping而言的；当Controller类上没有标记@RequestMapping注解时，方法上的@RequestMapping都是绝对路径。这种绝对路径和相对路径所组合成的最终路径都是相对于根路径“/”而言的。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
public class MyController {
  @RequestMapping("/showView")
  public ModelAndView showView() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("viewName");
    modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 ");
    return modelAndView;
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在这个控制器中，因为MyController没有被@RequestMapping标记，所以当需要访问到里面使用了@RequestMapping标记的showView方法时，就是使用的绝对路径/showView.do请求就可以了。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/test")
public class MyController {
  @RequestMapping("/showView")
  public ModelAndView showView() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("viewName");
    modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 ");
    return modelAndView;
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 这种情况是在控制器上加了@RequestMapping注解，所以当需要访问到里面使用了@RequestMapping标记的方法showView()的时候就需要使用showView方法上@RequestMapping相对于控制器MyController上@RequestMapping 的地址，即/test/showView.do。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（一）使用URI模板</span><br style=""> </p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> URI 模板就是在URI中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI模板http://localhost/app/{variable1}/index.html，这个模板里面包含一个变量variable1，那么当我们请求http://localhost/app/hello/index.html的时候，该URL就跟模板相匹配，只是把模板中的variable1用hello来取代。在SpringMVC中，这种取代模板中定义的变量的值也可以给处理器方法使用，这样我们就可以非常方便的实现URL的RestFul风格。这个变量在SpringMVC中是使用@PathVariable来标记的。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在SpringMVC中，我们可以使用@PathVariable来标记一个Controller的处理方法参数，表示该参数的值将使用URI模板中对应的变量的值来赋值。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/test/{variable1}")
public class MyController {
  @RequestMapping("/showView/{variable2}")
  public ModelAndView showView(@PathVariable String variable1,
      @PathVariable("variable2") int variable2) {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("viewName");
    modelAndView.addObject(" 需要放到 model 中的属性名称 ", " 对应的属性值，它是一个对象 ");
    return modelAndView;
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中我们定义了两个URI变量，一个是控制器类上的variable1，一个是showView方法上的variable2 ，然后在showView方法的参数里面使用@PathVariable标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do来请求的时候就可以访问到MyController的showView方法，这个时候variable1就被赋予值hello，variable2就被赋予值2，然后我们在showView方法参数里面标注了参数variable1和variable2是来自访问路径的path变量，这样方法参数variable1和variable2就被分别赋予hello和2。方法参数variable1是定义为String类型，variable2是定义为int类型，像这种简单类型在进行赋值的时候Spring是会帮我们自动转换的，关于复杂类型该如何来转换在后续内容中将会讲到。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中我们可以看到在标记variable1为path变量的时候我们使用的是@PathVariable，而在标记variable2的时候使用的是@PathVariable(“variable2”)。这两者有什么区别呢？第一种情况就默认去URI模板中找跟参数名相同的变量，但是这种情况只有在使用debug模式进行编译的时候才可以，而第二种情况是明确规定使用的就是URI模板中的variable2变量。当不是使用debug模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI模板中的哪个变量。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 除了在请求路径中使用URI模板，定义变量之外，@RequestMapping中还支持通配符“*”。如下面的代码我就可以使用/myTest/whatever/wildcard.do访问到Controller的testWildcard方法。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
public class MyController {
	@RequestMapping("*/wildcard")
	public String testWildcard() {
		System.out.println("wildcard------------");
		return "wildcard";
	}
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（二）使用 @RequestParam绑定HttpServletRequest请求参数到控制器方法参数</span></p> 
<pre class="prism-highlight prism-language-actionscript" style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping("requestParam")
public String testRequestParam(@RequestParam(required=false) String name, @RequestParam ("age") int age) {
  return "requestParam";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面代码中利用@RequestParam从HttpServletRequest中绑定了参数name到控制器方法参数name，绑定了参数age到控制器方法参数age。值得注意的是和@PathVariable一样，当你没有明确指定从request中取哪个参数时，Spring在代码是debug编译的情况下会默认取更方法参数同名的参数，如果不是debug编译的就会报错。此外，当需要从request中绑定的参数和方法的参数名不相同的时候，也需要在@RequestParam中明确指出是要绑定哪个参数。在上面的代码中如果我访问/requestParam.do?name=hello&amp;age=1则Spring将会把request请求参数name的值hello赋给对应的处理方法参数name，把参数age的值1赋给对应的处理方法参数age。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在@RequestParam中除了指定绑定哪个参数的属性value之外，还有一个属性required，它表示所指定的参数是否必须在request属性中存在，默认是true，表示必须存在，当不存在时就会报错。在上面代码中我们指定了参数name的required的属性为false，而没有指定age的required属性，这时候如果我们访问/requestParam.do而没有传递参数的时候，系统就会抛出异常，因为age参数是必须存在的，而我们没有指定。而如果我们访问/requestParam.do?age=1的时候就可以正常访问，因为我们传递了必须的参数age，而参数name 是非必须的，不传递也可以。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（三）使用@CookieValue绑定cookie的值到Controller方法参数</span></p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping("cookieValue")
public String testCookieValue(@CookieValue("hello") String cookieValue,
    @CookieValue String hello) {
  System.out.println(cookieValue + "-----------" + hello);
  return "cookieValue";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中我们使用@CookieValue绑定了cookie的值到方法参数上。上面一共绑定了两个参数，一个是明确指定要绑定的是名称为hello的cookie的值，一个是没有指定。使用没有指定的形式的规则和@PathVariable、@RequestParam的规则是一样的，即在debug编译模式下将自动获取跟方法参数名同名的cookie值。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（四）使用@RequestHeader注解绑定HttpServletRequest头信息到Controller方法参数</span></p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping("testRequestHeader")
public String testRequestHeader(@RequestHeader("Host") String hostAddr,
    @RequestHeader String Host, @RequestHeader String host) {
  System.out.println(hostAddr + "-----" + Host + "-----" + host);
  return "requestHeader";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中我们使用了@RequestHeader绑定了HttpServletRequest请求头host到Controller的方法参数。上面方法的三个参数都将会赋予同一个值，由此我们可以知道在绑定请求头参数到方法参数的时候规则和@PathVariable、@RequestParam以及@CookieValue是一样的，即没有指定绑定哪个参数到方法参数的时候，在debug编译模式下将使用方法参数名作为需要绑定的参数。但是有一点@RequestHeader跟另外三种绑定方式是不一样的，那就是在使用@RequestHeader的时候是大小写不敏感的，即@RequestHeader(“Host”)和@RequestHeader(“host”)绑定的都是Host头信息。记住在@PathVariable、@RequestParam和@CookieValue中都是大小写敏感的。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（五）@RequestMapping的一些高级应用</span></p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在RequestMapping中除了指定请求路径value属性外，还有其他的属性可以指定，如params、method和headers。这样属性都可以用于缩小请求的映射范围。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 1.params属性</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> params属性用于指定请求参数的，先看以下代码。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping(value = "testParams", params = { "param1=value1", "param2",
    "!param3" })
public String testParams() {
  System.out.println("test Params...........");
  return "testParams";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中我们用@RequestMapping的params属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1的值必须等于value1，参数param2必须存在，值无所谓，参数param3必须不存在，只有当请求/testParams.do并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2的时候能够正确访问到该testParams方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3的时候就不能够正常的访问到该方法，因为在@RequestMapping的params参数里面指定了参数param3是不能存在的。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 2.method属性</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> method 属性主要是用于限制能够访问的方法类型的。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping(value = "testMethod", method = { RequestMethod.GET,
    RequestMethod.DELETE })
public String testMethod() {
  return "method";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中就使用method参数限制了以GET或DELETE方法请求/testMethod.do的时候才能访问到该Controller的testMethod方法。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 3.headers属性</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 使用headers属性可以通过请求头信息来缩小@RequestMapping的映射范围。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@RequestMapping(value = "testHeaders", headers = { "host=localhost",
    "Accept" })
public String testHeaders() {
  return "headers";
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> headers属性的用法和功能与params属性相似。在上面的代码中当请求/testHeaders.do的时候只有当请求头包含Accept信息，且请求的host为localhost的时候才能正确的访问到testHeaders方法。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（六）以@RequestMapping标记的处理器方法支持的方法参数和返回类型</span></p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 支持的方法参数类型：</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （1）HttpServlet对象，主要包括HttpServletRequest、HttpServletResponse和HttpSession对象。这些参数Spring在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession对象的时候，如果此时HttpSession对象还没有建立起来的话就会有问题。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （2）Spring自己的WebRequest对象。使用该对象可以访问到存放在HttpServletRequest和HttpSession中的属性值。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （3）InputStream、OutputStream、Reader和Writer。InputStream和Reader是针对HttpServletRequest而言的，可以从里面取数据；OutputStream和Writer是针对HttpServletResponse而言的，可以往里面写数据。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （4）使用@PathVariable、@RequestParam、@CookieValue和@RequestHeader标记的参数。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （5）使用@ModelAttribute标记的参数。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （6）java.util.Map、Spring封装的Model和ModelMap。这些都可以用来封装模型数据，用来给视图做展示。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （7）实体类。可以用来接收上传的参数。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （8）Spring封装的MultipartFile。用来接收上传文件的。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （9）Spring封装的Errors和BindingResult对象。这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 支持的返回类型：</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （1）一个包含模型和视图的ModelAndView对象。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （2）一个模型对象，这主要包括Spring封装好的Model和ModelMap，以及java.util.Map，当没有视图返回的时候视图名称将由RequestToViewNameTranslator来决定。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （3）一个View对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （4）一个String字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （5）返回值是void。这种情况一般是我们直接把返回结果写到HttpServletResponse中了，如果没有写的话，那么Spring将会利用RequestToViewNameTranslator来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （6）如果处理器方法被注解@ResponseBody标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters转换之后写到HttpServletResponse中，而不会像上面的那些情况一样当做视图或者模型来处理。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> （7）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”)来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute标记的方法会在@RequestMapping标记的方法执行之前执行。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（七）使用@ModelAttribute和@SessionAttributes传递和保存数据</span></p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> SpringMVC支持使用@ModelAttribute和@SessionAttributes在不同的模型和控制器之间共享数据。@ModelAttribute主要有两种使用方式，一种是标注在方法上，一种是标注在Controller方法参数上。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 当@ModelAttribute标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在session或模型属性中，属性名称可以使用@ModelAttribute(“attributeName”)在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于@ModelAttribute标记在方法上时对应的属性是存放在session中还是存放在模型中，我们来做一个实验，看下面一段代码。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
public class MyController {

  @ModelAttribute("hello")
  public String getModel() {
    System.out.println("-------------Hello---------");
    return "world";
  }

  @ModelAttribute("intValue")
  public int getInteger() {
    System.out.println("-------------intValue---------------");
    return 10;
  }

  @RequestMapping("sayHello")
  public void sayHello(@ModelAttribute("hello") String hello,
      @ModelAttribute("intValue") int num,
      @ModelAttribute("user2") User user, Writer writer,
      HttpSession session) throws IOException {
    writer.write("Hello " + hello + " , Hello " + user.getUsername() + num);
    writer.write("\r");
    Enumeration enume = session.getAttributeNames();
    while (enume.hasMoreElements())
      writer.write(enume.nextElement() + "\r");
  }

  @ModelAttribute("user2")
  public User getUser() {
    System.out.println("---------getUser-------------");
    return new User(3, "user2");
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 当我们请求/myTest/sayHello.do的时候使用@ModelAttribute标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到sayHello方法的时候，使用@ModelAttribute标记的方法参数都能被正确的注入值。执行结果如下所示：</p> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">Hello world , Hello user210</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 由执行结果我们可以看出来，此时session中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在session属性中。那要如何才能存放在session属性中呢？这个时候我们先引入一个新的概念@SessionAttributes，它的用法会在讲完@ModelAttribute之后介绍，这里我们就先拿来用一下。我们在MyController类上加上@SessionAttributes属性标记哪些是需要存放到session中的。看下面的代码：</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
@SessionAttributes(value = { "intValue", "stringValue" }, types = { User.class })
public class MyController {

  @ModelAttribute("hello")
  public String getModel() {
    System.out.println("-------------Hello---------");
    return "world";
  }

  @ModelAttribute("intValue")
  public int getInteger() {
    System.out.println("-------------intValue---------------");
    return 10;
  }

  @RequestMapping("sayHello")
  public void sayHello(Map&lt;String, Object&gt; map,
      @ModelAttribute("hello") String hello,
      @ModelAttribute("intValue") int num,
      @ModelAttribute("user2") User user, Writer writer,
      HttpServletRequest request) throws IOException {
    map.put("stringValue", "String");
    writer.write("Hello " + hello + " , Hello " + user.getUsername() + num);
    writer.write("\r");
    HttpSession session = request.getSession();
    Enumeration enume = session.getAttributeNames();
    while (enume.hasMoreElements())
      writer.write(enume.nextElement() + "\r");
    System.out.println(session);
  }

  @ModelAttribute("user2")
  public User getUser() {
    System.out.println("---------getUser-------------");
    return new User(3, "user2");
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面代码中我们指定了属性为intValue或stringValue或者类型为User的都会放到Session中，利用上面的代码当我们访问/myTest/sayHello.do的时候，结果如下：</p> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">Hello world , Hello user210</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 仍然没有打印出任何session属性，这是怎么回事呢？怎么定义了把模型中属性名为intValue的对象和类型为User的对象存到session中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问/myTest/sayHello.do的时候@SessionAttributes定义了需要存放到session中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到session中，所以session中不会有任何属性，等处理器方法执行完成后Spring才会把模型中对应的属性添加到session中。所以当请求第二次的时候就会出现如下结果：</p> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7">Hello world , Hello user210</p> 
 <p style="margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7">user2</p> 
 <p style="margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7">intValue</p> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">stringValue</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 当@ModelAttribute标记在处理器方法参数上的时候，表示该参数的值将从模型或者Session中取对应名称的属性值，该名称可以通@ModelAttribute(“attributeName”)来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
public class MyController {

  @ModelAttribute("hello")
  public String getModel() {
    return "world";
  }

  @RequestMapping("sayHello")
  public void sayHello(@ModelAttribute("hello") String hello, Writer writer)
      throws IOException {
    writer.write("Hello " + hello);
  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面代码中，当我们请求/myTest/sayHello.do的时候，由于MyController中的方法getModel使用了注解@ModelAttribute进行标记，所以在执行请求方法sayHello之前会先执行getModel方法，这个时候getModel方法返回一个字符串world并把它以属性名hello保存在模型中，接下来访问请求方法sayHello的时候，该方法的hello参数使用@ModelAttribute(“hello”)进行标记，这意味着将从session或者模型中取属性名称为hello的属性值赋给hello参数，所以这里hello参数将被赋予值world，所以请求完成后将会在页面上看到Helloworld字符串。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> @SessionAttributes用于标记需要在Session中使用到的数据，包括从Session中取数据和存数据。@SessionAttributes一般是标记在Controller类上的，可以通过名称、类型或者名称加类型的形式来指定哪些属性是需要存放在session中的。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
@SessionAttributes(value = { "user1", "blog1" }, types = { User.class,
    Blog.class })
public class MyController {

  @RequestMapping("setSessionAttribute")
  public void setSessionAttribute(Map&lt;String, Object&gt; map, Writer writer)
      throws IOException {
    User user = new User(1, "user");
    User user1 = new User(2, "user1");
    Blog blog = new Blog(1, "blog");
    Blog blog1 = new Blog(2, "blog1");
    map.put("user", user);
    map.put("user1", user1);
    map.put("blog", blog);
    map.put("blog1", blog1);
    writer.write("over.");
  }

  @RequestMapping("useSessionAttribute")
  public void useSessionAttribute(Writer writer,
      @ModelAttribute("user1") User user1,
      @ModelAttribute("blog1") Blog blog1) throws IOException {
    writer.write(user1.getId() + "--------" + user1.getUsername());
    writer.write("\r");
    writer.write(blog1.getId() + "--------" + blog1.getTitle());
  }

  @RequestMapping("useSessionAttribute2")
  public void useSessionAttribute(Writer writer,
      @ModelAttribute("user1") User user1,
      @ModelAttribute("blog1") Blog blog1, @ModelAttribute User user,
      HttpSession session) throws IOException {
    writer.write(user1.getId() + "--------" + user1.getUsername());
    writer.write("\r");
    writer.write(blog1.getId() + "--------" + blog1.getTitle());
    writer.write("\r");
    writer.write(user.getId() + "---------" + user.getUsername());
    writer.write("\r");
    Enumeration enume = session.getAttributeNames();
    while (enume.hasMoreElements())
      writer.write(enume.nextElement() + " \r");
  }

  @RequestMapping("useSessionAttribute3")
  public void useSessionAttribute(@ModelAttribute("user2") User user) {

  }
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面代码中我们可以看到在MyController上面使用了@SessionAttributes标记了需要使用到的Session属性。可以通过名称和类型指定需要存放到Session中的属性，对应@SessionAttributes注解的value和types属性。当使用的是types属性的时候，那么使用的Session属性名称将会是对应类型的名称（首字母小写）。当value和types两个属性都使用到了的时候，这时候取的是它们的并集，而不是交集，所以上面代码中指定要存放在Session中的属性有名称为user1或blog1的对象，或类型为User或Blog的对象。在上面代码中我们首先访问/myTest/setSessionAttribute.do，该请求将会请求到MyController的setSessionAttribute方法，在该方法中，我们往模型里面添加了user、user1、blog和blog1四个属性，因为它们或跟类上的@SessionAttributes定义的需要存到session中的属性名称相同或类型相同，所以在请求完成后这四个属性都将添加到session属性中。接下来访问/myTest/useSessionAttribute.do，该请求将会请求MyController的useSessionAttribute(Writerwriter,@ModelAttribute(“user1”)Useruser1,@ModelAttribute(“blog1”)Blogblog)方法，该方法参数中用@ModelAttribute指定了参数user1和参数blog1是需要从session或模型中绑定的，恰好这个时候session中已经有了这两个属性，所以这个时候在方法执行之前会先绑定这两个参数。执行结果如下图所示：</p> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7">2---user1</p> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">2---blog1</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 接下来访问/myTest/useSessionAttribute2.do，这个时候请求的是上面代码中对应的第二个useSessionAttribute方法，方法参数user、user1和blog1。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 用@ModelAttribute声明了需要session或模型属性注入，我们知道在请求/myTest/setSessionAttribute.do的时候这些属性都已经添加到了session中，所以该请求的结果会如下所示：</p> 
<blockquote style='padding:10px 20px; margin:0px 0px 20px; border-left-width:5px; border-left-style:solid; border-left-color:rgb(238,238,238); font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:15px!important'> 
 <p style="margin-top:0px; margin-bottom:0px; text-indent:2em; line-height:1.7">2---user1 2---blog1 1---user blog user user1 blog1</p> 
</blockquote> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 接下来访问/myTest/useSessionAttribute3.do，这个时候请求的是上面代码中对应的第三个useSessionAttribute方法，我们可以看到该方法的方法参数user使用了@ModelAttribute(“user2”)进行标记，表示user需要session中的user2属性来注入，但是这个时候我们知道session中是不存在user2属性的，所以这个时候就会报错了。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（八）定制自己的类型转换器</span><br style=""> </p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在通过处理器方法参数接收request请求参数绑定数据的时候，对于一些简单的数据类型Spring会帮我们自动进行类型转换，而对于一些复杂的类型由于Spring没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要Spring来帮我们自动转换的话就需要我们给Spring注册一个对特定类型的识别转换器。Spring允许我们提供两种类型的识别转换器，一种是注册在Controller中的，一种是注册在SpringMVC的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在Controller中的是局部的，只在当前Controller中有效，而放在SpringMVC配置文件中的是全局的，所有Controller都可以拿来使用。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 1.在@InitBinder标记的方法中定义局部的类型转换器</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 我们可以使用@InitBinder注解标注在Controller方法上，然后在方法体里面注册数据绑定的转换器，这主要是通过WebDataBinder进行的。我们可以给需要注册数据绑定的转换器的方法一个WebDataBinder参数，然后给该方法加上@InitBinder注解，这样当该Controller中在处理请求方法时如果发现有不能解析的对象的时候，就会看该类中是否有使用@InitBinder标记的方法，如果有就会执行该方法，然后看里面定义的类型转换器是否与当前需要的类型匹配。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@Controller
@RequestMapping("/myTest")
public class MyController {

  @InitBinder
  public void dataBinder(WebDataBinder binder) {
    DateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
    PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true); // 第二个参数表示是否允许为空
    binder.registerCustomEditor(Date.class, propertyEditor);
  }

  @RequestMapping("dataBinder/{date}")
  public void testDate(@PathVariable Date date, Writer writer)
      throws IOException {
    writer.write(String.valueOf(date.getTime()));
  }

}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 在上面的代码中当我们请求/myTest/dataBinder/20121212.do的时候，Spring就会利用@InitBinder标记的方法里面定义的类型转换器把字符串20121212转换为一个Date对象。这样定义的类型转换器是局部的类型转换器，一旦出了这个Controller就不会再起作用。类型转换器是通过WebDataBinder对象的registerCustomEditor方法来注册的，要实现自己的类型转换器就要实现自己的PropertyEditor对象。Spring已经给我们提供了一些常用的属性编辑器，如CustomDateEditor、CustomBooleanEditor等。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> PropertyEditor是一个接口，要实现自己的PropertyEditor类我们可以实现这个接口，然后实现里面的方法。但是PropertyEditor里面定义的方法太多了，这样做比较麻烦。在java中有一个封装类是实现了PropertyEditor接口的，它是PropertyEditorSupport类。所以如果需要实现自己的PropertyEditor的时候只需要继承PropertyEditorSupport类，然后重写其中的一些方法。一般就是重写setAsText和getAsText方法就可以了，setAsText方法是用于把字符串类型的值转换为对应的对象的，而getAsText方法是用于把对象当做字符串来返回的。在setAsText中我们一般先把字符串类型的对象转为特定的对象，然后利用PropertyEditor的setValue方法设定转换后的值。在getAsText方法中一般先使用getValue方法取代当前的对象，然后把它转换为字符串后再返回给getAsText方法。下面是一个示例：</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">@InitBinder
public void dataBinder(WebDataBinder binder) {
  // 定义一个 User 属性编辑器
  PropertyEditor userEditor = new PropertyEditorSupport() {

    @Override
    public String getAsText() {
      // TODO Auto-generated method stub
      User user = (User) getValue();
      return user.getUsername();
    }

  @Override
  public void setAsText(String userStr)
      throws IllegalArgumentException {
    // TODO Auto-generated method stub
      User user = new User(1, userStr);
      setValue(user);
    }
  };
  // 使用 WebDataBinder 注册 User 类型的属性编辑器
  binder.registerCustomEditor(User.class, userEditor);
}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 2.实现 WebBindingInitializer 接口定义全局的类型转换器</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 如果需要定义全局的类型转换器就需要实现自己的WebBindingInitializer对象，然后把该对象注入到AnnotationMethodHandlerAdapter中，这样Spring在遇到自己不能解析的对象的时候就会到全局的WebBindingInitializer的initBinder方法中去找，每次遇到不认识的对象时，initBinder方法都会被执行一遍。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">public class MyWebBindingInitializer implements WebBindingInitializer {

  @Override
  public void initBinder(WebDataBinder binder, WebRequest request) {
    // TODO Auto-generated method stub
    DateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
    PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true);
    binder.registerCustomEditor(Date.class, propertyEditor);
  }

}</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 定义了这么一个WebBindingInitializer对象之后Spring还是不能识别其中指定的对象，这是因为我们只是定义了WebBindingInitializer对象，还没有把它交给Spring，Spring不知道该去哪里找解析器。要让Spring能够识别还需要我们在SpringMVC的配置文件中定义一个AnnotationMethodHandlerAdapter类型的bean对象，然后利用自己定义的WebBindingInitializer覆盖它的默认属性webBindingInitializer。</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">&lt;bean class = "org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
  &lt;property name = "webBindingInitializer" &gt;
      &lt;bean class = "com.host.app.web.util.MyWebBindingInitializer" /&gt;
  &lt;/property &gt;
&lt;/bean&gt;</pre> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 3.触发数据绑定方法的时间</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 当Controller处理器方法参数使用@RequestParam、@PathVariable、@RequestHeader、@CookieValue和@ModelAttribute标记的时候都会触发initBinder方法的执行，这包括使用WebBindingInitializer定义的全局方法和在Controller中使用@InitBinder标记的局部方法。而且每个使用了这几个注解标记的参数都会触发一次initBinder方法的执行，这也意味着有几个参数使用了上述注解就会触发几次initBinder方法的执行。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> <span style="font-weight:700">（九）使用@Value用法</span><br style=""> </p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> Spring通过注解获取*.porperties文件的内容，除了xml配置外，还可以通过@value方式来获取。</p> 
<p style='margin-top:0px; margin-bottom:5px; text-indent:2em; line-height:1.7; font-family:"Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; font-size:14px'> 使用方式必须在当前类使用@Component或者@Controller，xml文件内配置的是通过pakage扫描方式例如：&lt;context:component-scanbase-package="pakage_name"/&gt;</p> 
<pre style="overflow:auto; font-family:consolas; padding:10px 5px; margin:15px auto; line-height:20px; color:rgb(51,51,51); border-width:1px 1px 1px 4px; border-style:solid; border-color:rgb(221,221,221); white-space:pre-wrap; word-break:normal!important; word-wrap:normal!important">public class AbnormalWarningBulletinJob extends AbstractWantJob {
  // 访问共享文件遵循smb协议
  private static final String SMB_PREIFX = "smb:";
  
  @Autowired(required=false)
  @Qualifier
  private SmsSendService sendService;
  
  @Value("${abnormal.warning.bulletin}")
  private String smb_url;
<p>}</p><p>参考文献：http://yedward.net/?id=402</p></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a41d37780b383b0237be3813d2fba870/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android TypedValue.applyDimension()的作用  单位转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa9e2d42b1a24f83a3c3ba243268eb1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrip-table刷新方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>