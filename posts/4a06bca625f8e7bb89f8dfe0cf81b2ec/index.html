<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vs 外部依赖项、附加依赖项以及如何添加依赖项目 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vs 外部依赖项、附加依赖项以及如何添加依赖项目" />
<meta property="og:description" content="我们在 VS 中创建 Win32 控制台应用程序，vs 会为解决方案创建默认地创建 4 个 filters（资源管理器中没有对应的目录和文件夹）：
头文件：一般为 .h 文件外部依赖项源文件：一般为 .cpp文件资源文件 1. 外部依赖项 &amp; 资源文件 外部依赖项：C&#43;&#43; 外部依赖项有很多，大部分都是静态库文件，编译的时候会递归关联起来生成可执行文件，所以可执行文件才会大很多。
编译的时候： 外部依赖项都是一个填充地址 ， 比如 你的代码里调用 外部依赖函数地址 Extern_funA 。
预编译的时候展开头文件，编译生成obj文件的时候，Extern_funA 就是一个填充地址 比如 0x00 00 00 00链接的时候基地址重定位生成对应的 Extern_funA 地址。 链接的时候会根据你的工程配置想一个去查找 DLL 导出符号表，发现没有找到 Extern_funA 。那么就会出错，说无法定位外部符号。 右键【源文件】，选择【添加 ⇒ 新建项】，比如此时我们创建，test.cpp 文件，只需 include 一个文件：
#include &lt;iostream&gt; 123 123 此时重新点开 【外部依赖项】filter，便会看到引入了相当多的库文件。
资源文件：主要是你用到的一些程序代码以外的东西，比如图片之类，或者菜单、工具栏之类的。
2. 库目录 &amp; 附加依赖项 库目录只是查找目录，类似环境变量 PATH；具体用哪一个需要指明的，如果不在附加依赖项里填上，就需要在代码里用
#pragma comment（lib, “xxx.lib”） 1 1 来手动指定了。你写代码读写一个文件需要写明文件名吧，这个文件名就相当于那个lib , 但读写这个文件可以不写全路径，就是因为有工作目录（working directory）的存在。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4a06bca625f8e7bb89f8dfe0cf81b2ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-12T10:22:59+08:00" />
<meta property="article:modified_time" content="2020-05-12T10:22:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vs 外部依赖项、附加依赖项以及如何添加依赖项目</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="markdown_views"> 
   
  <svg xmlns="http://www.w3.org/2000/svg"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block"></path> 
  </svg> 
  <div id="article_content" class="article_content csdn-tracking-statistics tracking-click"> 
   <div class="markdown_views"> 
    <p>我们在 VS 中创建 Win32 控制台应用程序，vs 会为解决方案创建默认地创建 4 个 filters（资源管理器中没有对应的目录和文件夹）：</p> 
   </div> 
  </div> 
 </div> 
</div> 
<ul><li>头文件：一般为 <code>.h</code> 文件</li><li>外部依赖项</li><li>源文件：一般为 <code>.cpp</code>文件</li><li>资源文件</li></ul> 
<h3 id="1-外部依赖项-资源文件">1. 外部依赖项 &amp; 资源文件</h3> 
<ul><li><p>外部依赖项：C++ 外部依赖项有很多，大部分都是<strong>静态库文件</strong>，编译的时候会<strong>递归关联起来生成可执行文件</strong>，所以<strong>可执行文件才会大很多</strong>。</p> </li></ul> 
<p>编译的时候： 外部依赖项都是一个填充地址 ， 比如 你的代码里调用 外部依赖函数地址 Extern_funA 。</p> 
<ul><li><strong>预编译的时候展开头文件</strong>，</li><li><strong>编译生成obj文件的时候</strong>，Extern_funA 就是一个填充地址 比如 0x00 00 00 00</li><li><strong>链接的时候基地址重定位</strong>生成对应的 Extern_funA 地址。 </li><li>链接的时候会根据你的工程配置想一个去查找 DLL 导出符号表，发现没有找到 Extern_funA 。那么就会出错，说无法定位外部符号。</li></ul> 
<p>右键【源文件】，选择【添加 ⇒ 新建项】，比如此时我们创建，<code>test.cpp</code> 文件，只需 include 一个文件：</p> 
<pre class="prettyprint"><code class="hljs vala has-numbering hljs">
<span class="hljs-preprocessor"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span></span>
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul>
 
 <ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
<p>此时重新点开 【外部依赖项】filter，便会看到引入了相当多的库文件。</p> 
<ul><li><p>资源文件：主要是你用到的一些程序代码以外的东西，比如图片之类，或者菜单、工具栏之类的。</p></li><li><h3 id="2-库目录-附加依赖项">2. 库目录 &amp; 附加依赖项</h3> 
<p>库目录只是查找目录，类似环境变量 PATH；具体用哪一个需要指明的，如果不在附加依赖项里填上，就需要在代码里用</p> 
<pre class="prettyprint"><code class="hljs cs has-numbering hljs"><span class="hljs-preprocessor"><span class="hljs-preprocessor">#</span><span class="hljs-keyword"><span class="hljs-preprocessor"><span class="hljs-keyword">pragma</span></span></span><span class="hljs-preprocessor"> comment（lib, “xxx.lib”）</span></span></code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li></ul>
 
 <ul class="pre-numbering"><li>1</li></ul> 
<p>来手动指定了。你写代码读写一个文件需要写明文件名吧，这个文件名就相当于那个lib , 但读写这个文件可以不写全路径，就是因为有工作目录（working directory）的存在。</p> 
<h3 id="3-添加依赖项目">3. 添加依赖项目</h3> 
<p><a href="http://blog.csdn.net/kingepoch/article/details/24289627" rel="nofollow noopener noreferrer" target="_blank">VS2013 添加依赖项目</a></p> 
<ul><li><p>1、新建解决方案，项目A</p></li><li><p>2、为项目A添加一个依赖项目B，项目B做为静态lib被项目引用，</p> </li></ul> 
<p>项目B创建步骤如下：</p> 
<ul><li><p>选择菜单”文件”-&gt;新建-&gt;项目，弹出“新建项目”对话框；</p></li><li><p>左侧列表选择Visual C++，右侧列表选择win32控制台应用程序，</p> </li></ul> 
<p>对话框下面输入名称，选择位置，解决方案选择添加到解决方案，确定。</p> 
</li><li><p>Win32应用程序向导，下一步，选择应用程序类型为静态库，</p> </li><li><p>添加公共头文件以用于选择MFC(根据实际情况选择，因为项目需求&lt;nb30.h&gt;编译需要选择MFC)，完成。</p> 
</li><li><p>3、项目配置，项目A右键选择属性，选择通用属性，引用-&gt;添加新引用-&gt;选择项目B；</p> </li><li><p>引用项目B的头文件目录，步骤如下:配置属性-&gt;VC++目录-&gt;包含目录:添加项目B头文件路径..\B\Header。</p> 
<p>其中编译的时候会出项目A引用项目B的接口无法解析，可能是3步骤没有做。</p> 
<pre class="prettyprint"><code class="has-numbering">            &lt;link rel="stylesheet" href="http://csdnimg.cn/release/phoenix/production/markdown_views-d4dade9c33.css"&gt;
                &lt;/div&gt;
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
<pre><code>            &lt;link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"&gt;
                &lt;/div&gt;
</code></pre></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ddbe02c6893ccfcb4b4a16cc42b28983/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习自学记录（6）——标准化、归一化和BatchNormal的理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38b1265bceec324314641763d496787e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器远程拒绝访问解决办法之一</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>