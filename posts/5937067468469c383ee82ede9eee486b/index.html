<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>尚硅谷SpringBoot3笔记 (一) 快速入门 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="尚硅谷SpringBoot3笔记 (一) 快速入门" />
<meta property="og:description" content="推荐课程：03.快速入门-示例Demo_哔哩哔哩_bilibili
官方笔记：SpringBoot3全栈指南 (yuque.com)
目录
01 -- 示例demo
1. 在新建项目创建一个Maven 模块 2. 引入 spring-boot-starter-parent 和 spring-boot-starter-web 依赖
3. 指示 Spring Boot 启动类
4. 构建控制器
5. 启动
6. 使用Maven打包
02 -- 特性小结
1. 简化整合
2. 简化开发
3. 简化配置
4. 简化部署
5. 简化运维
03 -- spring initializer
04 -- 应用分析
1. 依赖管理机制
2. 自动配置机制
05 -- 核心技能
1. 常用注解
2. 组件注册 ✫✫✫✫
3. 条件注解 ✫✫✫✫
4. 属性绑定 ✫✫✫✫
06 -- YAML配置文件
基本语法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5937067468469c383ee82ede9eee486b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T08:55:43+08:00" />
<meta property="article:modified_time" content="2024-03-14T08:55:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">尚硅谷SpringBoot3笔记 (一) 快速入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>推荐课程：<a href="https://www.bilibili.com/video/BV1Es4y1q7Bf/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=a3264716fe097cbd43e5dbc235c0e426" rel="nofollow" title="03.快速入门-示例Demo_哔哩哔哩_bilibili">03.快速入门-示例Demo_哔哩哔哩_bilibili</a></p> 
 <p>官方笔记：<a href="https://www.yuque.com/leifengyang/springboot3" rel="nofollow" title="SpringBoot3全栈指南 (yuque.com)">SpringBoot3全栈指南 (yuque.com)</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="01%20--%20%E7%A4%BA%E4%BE%8Bdemo-toc" style="margin-left:40px;"><a href="#01%20--%20%E7%A4%BA%E4%BE%8Bdemo" rel="nofollow">01 -- 示例demo</a></p> 
<p id="1.%20%E5%9C%A8%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMaven%20%E6%A8%A1%E5%9D%97%C2%A0-toc" style="margin-left:80px;"><a href="#1.%20%E5%9C%A8%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMaven%20%E6%A8%A1%E5%9D%97%C2%A0" rel="nofollow">1. 在新建项目创建一个Maven 模块 </a></p> 
<p id="2.%20%E5%BC%95%E5%85%A5%C2%A0spring-boot-starter-parent%C2%A0%E5%92%8C%C2%A0spring-boot-starter-web%20%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#2.%20%E5%BC%95%E5%85%A5%C2%A0spring-boot-starter-parent%C2%A0%E5%92%8C%C2%A0spring-boot-starter-web%20%E4%BE%9D%E8%B5%96" rel="nofollow">2. 引入 spring-boot-starter-parent 和 spring-boot-starter-web 依赖</a></p> 
<p id="%C2%A03.%C2%A0%E6%8C%87%E7%A4%BA%20Spring%20Boot%20%E5%90%AF%E5%8A%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%C2%A03.%C2%A0%E6%8C%87%E7%A4%BA%20Spring%20Boot%20%E5%90%AF%E5%8A%A8%E7%B1%BB" rel="nofollow">3. 指示 Spring Boot 启动类</a></p> 
<p id="4.%C2%A0%20%E6%9E%84%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%99%A8-toc" style="margin-left:80px;"><a href="#4.%C2%A0%20%E6%9E%84%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%99%A8" rel="nofollow">4. 构建控制器</a></p> 
<p id="5%E3%80%81%E5%90%AF%E5%8A%A8-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%90%AF%E5%8A%A8" rel="nofollow">5. 启动</a></p> 
<p id="6%E3%80%81%E4%BD%BF%E7%94%A8Maven%E6%89%93%E5%8C%85-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E4%BD%BF%E7%94%A8Maven%E6%89%93%E5%8C%85" rel="nofollow">6. 使用Maven打包</a></p> 
<p id="QYUvm-toc" style="margin-left:40px;"><a href="#QYUvm" rel="nofollow">02 -- 特性小结</a></p> 
<p id="s7TwE-toc" style="margin-left:80px;"><a href="#s7TwE" rel="nofollow">1. 简化整合</a></p> 
<p id="BDh5t-toc" style="margin-left:80px;"><a href="#BDh5t" rel="nofollow">2. 简化开发</a></p> 
<p id="Vuit1-toc" style="margin-left:80px;"><a href="#Vuit1" rel="nofollow">3. 简化配置</a></p> 
<p id="hOPXS-toc" style="margin-left:80px;"><a href="#hOPXS" rel="nofollow">4. 简化部署</a></p> 
<p id="nxPNm-toc" style="margin-left:80px;"><a href="#nxPNm" rel="nofollow">5. 简化运维</a></p> 
<p id="03%20--%20spring%20initializer-toc" style="margin-left:40px;"><a href="#03%20--%20spring%20initializer" rel="nofollow">03 -- spring initializer</a></p> 
<p id="04%20--%C2%A0%20%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#04%20--%C2%A0%20%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90" rel="nofollow">04 --  应用分析</a></p> 
<p id="u2608bc1f-toc" style="margin-left:80px;"><a href="#u2608bc1f" rel="nofollow">1. 依赖管理机制</a></p> 
<p id="xYGAD-toc" style="margin-left:80px;"><a href="#xYGAD" rel="nofollow">2. 自动配置机制</a></p> 
<p id="slzQ8-toc" style="margin-left:40px;"><a href="#slzQ8" rel="nofollow">05 -- 核心技能</a></p> 
<p id="fQ5Yd-toc" style="margin-left:80px;"><a href="#fQ5Yd" rel="nofollow">1. 常用注解</a></p> 
<p id="csYPA-toc" style="margin-left:80px;"><a href="#csYPA" rel="nofollow">2. 组件注册 ✫✫✫✫</a></p> 
<p id="gJK8H-toc" style="margin-left:80px;"><a href="#gJK8H" rel="nofollow">3. 条件注解 ✫✫✫✫</a></p> 
<p id="Q4soh-toc" style="margin-left:80px;"><a href="#Q4soh" rel="nofollow">4. 属性绑定 ✫✫✫✫</a></p> 
<p id="06%20--%20YAML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#06%20--%20YAML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">06 -- YAML配置文件</a></p> 
<p id="FY4Rp-toc" style="margin-left:80px;"><a href="#FY4Rp" rel="nofollow">基本语法：</a></p> 
<p id="07%20--%20%E6%97%A5%E5%BF%97%C2%A0-toc" style="margin-left:40px;"><a href="#07%20--%20%E6%97%A5%E5%BF%97%C2%A0" rel="nofollow">07 -- 日志 </a></p> 
<p id="ufECQ-toc" style="margin-left:80px;"><a href="#ufECQ" rel="nofollow">1. 简介</a></p> 
<p id="JIbVA-toc" style="margin-left:80px;"><a href="#JIbVA" rel="nofollow">2. 日志格式</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="01%20--%20%E7%A4%BA%E4%BE%8Bdemo">01 -- 示例demo</h3> 
<h4 id="1.%20%E5%9C%A8%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMaven%20%E6%A8%A1%E5%9D%97%C2%A0">1. 在新建项目创建一个Maven 模块 </h4> 
<p class="img-center"><img alt="" height="379" src="https://images2.imgbox.com/bd/fa/oPZbXEg0_o.png" width="712"></p> 
<p></p> 
<h4 id="2.%20%E5%BC%95%E5%85%A5%C2%A0spring-boot-starter-parent%C2%A0%E5%92%8C%C2%A0spring-boot-starter-web%20%E4%BE%9D%E8%B5%96">2. 引入 <span style="color:#fe2c24;">spring-boot-starter-parent</span><span style="color:#ed7976;"> </span><span style="color:#0d0016;">和 </span><span style="color:#faa572;">spring-boot-starter-web </span><span style="color:#0d0016;">依赖</span></h4> 
<blockquote> 
 <p><span style="color:#ed7976;"><code>spring-boot-starter-parent</code></span> 是 Spring Boot 提供的一个用于构建 Spring Boot 项目的父项目（Parent Project）。通过使用 <code>spring-boot-starter-parent</code> 作为项目的父项目，你可以<strong>继承 Spring Boot 默认的依赖管理、插件配置和默认配置等(这是必要的，如果缺省Maven 将会默认使用</strong><strong>)</strong>，从而简化项目的配置和构建过程。</p> 
 <p></p> 
 <p><span style="color:#faa572;"><code>spring-boot-starter-web</code> </span>是 <strong>Spring Boot 提供的一个用于构建 Web 应用程序的起步依赖</strong>（Starter Dependency）。通过引入 <code>spring-boot-starter-web</code>，你可以快速地构建基于 Spring MVC 的 Web 应用程序，无需手动管理依赖和配置。</p> 
</blockquote> 
<pre><code class="language-XML">    &lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.0.5&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;!--        web开发的场景启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p></p> 
<h4 id="%C2%A03.%C2%A0%E6%8C%87%E7%A4%BA%20Spring%20Boot%20%E5%90%AF%E5%8A%A8%E7%B1%BB">3. 指示 Spring Boot 启动类</h4> 
<pre><code class="language-java">package org.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class,args);
    }
}</code></pre> 
<p></p> 
<h4 id="4.%C2%A0%20%E6%9E%84%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%99%A8">4. 构建控制器</h4> 
<pre><code class="language-java">package org.example.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;


//@ResponseBody                   // 标记返回纯文本
//@Controller                     // 标识一个类作为控制器，用于处理 HTTP 请求并返回相应的视图或数据

@RestController                 // 以上两个注解的合成注解
public class HelloController {

    @GetMapping("/hello")
    public String hello(){
        return "Hello,Spring Boot 3!";
    }
}
</code></pre> 
<p></p> 
<h4 id="5%E3%80%81%E5%90%AF%E5%8A%A8">5. 启动</h4> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/64/01/ekBe7K1i_o.png" width="439"></p> 
<h4 id="6%E3%80%81%E4%BD%BF%E7%94%A8Maven%E6%89%93%E5%8C%85">6. 使用Maven打包</h4> 
<pre><code class="language-XML">    &lt;!--    SpringBoot应用打包插件--&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</code></pre> 
<p><img alt="" height="397" src="https://images2.imgbox.com/15/38/7qBTmkKQ_o.png" width="325"></p> 
<p>查看打包结果：</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/c1/fc/yYTS5v8s_o.png" width="398"></p> 
<p>打包成jar包后，可以直接在CMD中直接使用Java -jar运行。</p> 
<pre><code class="language-XML">D:\JavaCode\app-demo&gt;Java -jar boot3-01-demo-1.0-SNAPSHOT.jar</code></pre> 
<p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/a4/a0/whQus4hz_o.png" width="711"></p> 
<p></p> 
<h3 id="QYUvm">02 -- 特性小结</h3> 
<blockquote> 
 <h4 id="s7TwE">1. 简化整合</h4> 
 <p id="uec6ed258">导入相关的场景，拥有相关的功能。场景启动器</p> 
 <p id="ue9651248">默认支持的所有场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters" rel="nofollow" title="Developing with Spring Boot">Developing with Spring Boot</a></p> 
 <ul><li id="uc0d1ca6d">官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li id="u7fecc72a">第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul> 
 <p id="u1eeed80b">场景一导入，万物皆就绪</p> 
 <ul><li id="ube0cf8e4">开发什么场景，导入什么<strong>场景启动器。</strong></li><li id="uc98cd4d5">导入“场景启动器”。 场景启动器 自动把这个场景的所有核心依赖全部导入进来。</li></ul> 
 <p></p> 
 <h4 id="BDh5t">2. 简化开发</h4> 
 <p id="u48af2ed0">无需编写任何配置，直接开发业务</p> 
 <p id="ufcd600a6"></p> 
 <h4 id="Vuit1">3. 简化配置</h4> 
 <p id="u200201fc"><code>application.properties</code>：</p> 
 <ul><li id="u14af16e4">集中式管理配置。只需要修改这个文件就行 。</li><li id="u70ec2115">配置基本都有默认值</li><li id="u7387c0f7">能写的所有配置都在： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties" rel="nofollow" title="Common Application Properties">Common Application Properties</a></li></ul> 
 <p id="u54adf25c"></p> 
 <h4 id="hOPXS">4. 简化部署</h4> 
 <p id="uf0128b3d">打包为可执行的jar包。</p> 
 <p id="ue3a46a93">linux服务器上有java环境。</p> 
 <p id="u4f7a6e52"></p> 
 <h4 id="nxPNm">5. 简化运维</h4> 
 <p id="ufbf77a90">修改配置（外部放一个application.properties文件）、监控、健康检查。</p> 
</blockquote> 
<p></p> 
<h3 id="03%20--%20spring%20initializer">03 -- spring initializer</h3> 
<p class="img-center"><img alt="" height="412" src="https://images2.imgbox.com/6e/27/wVahC4Nf_o.png" width="775"></p> 
<p>一键创建好整个项目结构</p> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/43/70/yUms5USs_o.png" width="348"></p> 
<p></p> 
<h3 id="04%20--%C2%A0%20%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90">04 --  应用分析</h3> 
<h4 id="u2608bc1f">1. 依赖管理机制</h4> 
<p>自定义版本号</p> 
<ul><li id="u34f3a152">利用maven的就近原则</li></ul> 
<ul><li> 
  <ul><li id="u4d5e798f"><span style="color:#ed7976;">直接在当前项目<code>properties</code>标签中声明父项目用的版本属性的key，遵循就近原则。</span></li><li id="uc4e01c4b">直接在<strong>导入依赖的时候声明版本</strong></li></ul></li></ul> 
<p></p> 
<h4 id="xYGAD">2. 自动配置机制</h4> 
<ul><li id="u30c70921"><strong>自动配置</strong>的 Tomcat、SpringMVC 等</li><li> 
  <ul><li id="u855536e8"><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li><li id="u4dfe097c">以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter....</li><li id="u01a3e957">现在：自动配置好的这些组件</li><li id="uee4fef35">验证：<strong>容器中有了什么组件，就具有什么功能</strong></li></ul></li></ul> 
<ul><li id="u03b24ad3"><strong><span style="background-color:#fbd4d0;">默认的包扫描规则（默认从主程序开始，controller只会从属主程序执行）</span></strong></li></ul> 
<ul><li> 
  <ul><li id="u62e87218"><code>@SpringBootApplication</code> 标注的类就是主程序类</li><li id="u19c41cf7"><u><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></u></li></ul></li><li><strong><span style="background-color:#fbd4d0;">自定义扫描路径（改变执行顺序）</span></strong></li><li> 
  <ul><li> 
    <ul><li id="u346b0497">@SpringBootApplication(scanBasePackages = "com.atguigu")</li><li id="u8945e1ce"><code>@ComponentScan("com.atguigu")</code> 直接指定扫描的路径</li></ul></li></ul></li></ul> 
<p>非正确主从位置：</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/17/11/9l8ggdMd_o.png" width="277">       </p> 
<p>执行结果：</p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/e4/8d/eLA31JDd_o.png" width="477"></p> 
<p>自定义扫描路径：</p> 
<pre><code class="language-java">package org.example.boot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;


//@SpringBootApplication(scanBasePackages = "org.example")
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("org.example")
public class Boot302DemoApplication {

    public static void main(String[] args) {
        //java10: 局部变量类型的自动判断
        var ioc = SpringApplication.run(Boot302DemoApplication.class, args);

        //1、获取容器中所有组件的名字
        String[] names = ioc.getBeanDefinitionNames();

        //2、挨个遍历：
        // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver
        // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。
        for (String name : names){
            System.out.println(name);
        }
    }

}
</code></pre> 
<blockquote> 
 <p>@SpringBootApplication(scanBasePackages = "org.example")</p> 
 <p>等于以下三个注解：</p> 
 <p>@SpringBootConfiguration</p> 
 <p>@EnableAutoConfiguration</p> 
 <p>@ComponentScan("org.example")</p> 
</blockquote> 
<p>自定义扫描路径后： </p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/4b/5b/WNkCxAb2_o.png" width="463"></p> 
<p>  </p> 
<ul><li id="u71670f08"><strong>配置默认值 <span style="color:#fe2c24;">✫✫✫✫</span></strong></li></ul> 
<ul><li> 
  <ul><li id="ubaedb431"><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li><li id="u137360ad">绑定了配置文件中每一项值的类： <strong>属性类</strong>。</li><li id="ua8c33223">比如：</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u38325cb6"><code>ServerProperties</code>绑定了所有Tomcat服务器有关的配置</li><li id="uf9c65abd"><code>MultipartProperties</code>绑定了所有文件上传相关的配置</li><li id="u21c1db3b">....参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server" rel="nofollow" title="官方文档">官方文档</a>：或者参照 绑定的 <strong>属性类</strong>。</li></ul></li></ul></li></ul> 
<p><img alt="" height="318" src="https://images2.imgbox.com/23/cb/kcKkcgGF_o.png" width="572"></p> 
<p><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的：</p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/8a/d5/shhoHBCA_o.png" width="498"></p> 
<p></p> 
<ul><li id="uf5b414bb"><strong>按需加载自动配置 <span style="color:#fe2c24;">✫✫✫✫</span></strong></li></ul> 
<ul><li> 
  <ul><li id="u406789c9">导入场景<code>spring-boot-starter-web</code></li><li id="uc901c638">场景启动器除了会导入相关功能依赖，导入一个<code>spring-boot-starter</code>，是所有<code>starter</code>的<code>starter</code>，基础核心starter</li><li id="ueeb43d7d"><code>spring-boot-starter</code>导入了一个包 <code>spring-boot-autoconfigure</code>。包里面都是各种场景的<code>AutoConfiguration</code><strong>自动配置类</strong></li><li id="u004b8961">虽然全场景的自动配置都在 <code>spring-boot-autoconfigure</code>这个包，但是不是全都开启的。</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="ufd08481f">导入哪个场景就开启哪个自动配置</li></ul></li></ul></li></ul> 
<p></p> 
<p>   </p> 
<h3 id="slzQ8">05 -- 核心技能</h3> 
<h4 id="fQ5Yd">1. 常用注解</h4> 
<p id="uebd235d2">SpringBoot摒弃XML配置方式，改为<strong>全注解驱动</strong></p> 
<h4 id="csYPA">2. 组件注册 <strong><span style="color:#fe2c24;">✫✫✫✫</span></strong></h4> 
<blockquote> 
 <p id="u11e1ca5d">@Configuration、@SpringBootConfiguration</p> 
 <p id="u63080289">@Bean、@Scope</p> 
 <p id="u9c42cce8"><span style="color:#fe2c24;">@Controller、 @Service、@Repository、@Component</span></p> 
 <p id="u127d1a3a">@Import</p> 
 <p id="ue79bcec6">@ComponentScan</p> 
</blockquote> 
<ul><li>  @Configuration，@Bean，@Scope注解</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;">@Configuration</span>：这是一个配置类，@Configuration 注解表示该类是一个配置类，其中包含用于配置 bean 的方法。</p> 
 <p><span style="color:#fe2c24;">@Bean</span>：申明这是一个bean类，告诉 Spring 容器要将某个实体类的实例作为一个 bean 注册到容器中。</p> 
 <p>@Scope ：用于指定 Spring bean 的作用域。</p> 
 <ul><li><strong>prototype</strong>：每次请求该 bean 时都会创建一个新的实例。每个实例都是独立的，没有共享状态。</li></ul> 
</blockquote> 
<p><img alt="" height="434" src="https://images2.imgbox.com/5e/1b/bIMmzmjh_o.png" width="290"></p> 
<pre><code class="language-java">package org.example.boot.bean;

public class User {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
</code></pre> 
<pre><code class="language-java">package org.example.boot.bean;

public class Cat {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre> 
<pre><code class="language-java">package org.example.boot.config;

import org.example.boot.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration // 这是一个配置类，@Configuration 注解表示该类是一个配置类，其中包含用于配置 bean 的方法。
public class AppConfig {

    @Bean("hahabean") // Bean注解，申明这是一个bean类，告诉 Spring 容器要将某个实体类的实例作为一个 bean 注册到容器中
    public User user(){
        var user = new User();
        user.setId(1L);
        user.setName("zhangsan");

        return user;
    }
}
</code></pre> 
<p>主程序：</p> 
<pre><code class="language-java">package org.example.boot;

import org.example.boot.bean.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
public class Boot302DemoApplication {

    public static void main(String[] args) {
        var ioc = SpringApplication.run(Boot302DemoApplication.class, args);

        String[] names = ioc.getBeanNamesForType(User.class);

        for (String name : names){
            System.out.println(name);
        }

        Object bean1 = ioc.getBean("hahabean");
        Object bean2 = ioc.getBean("hahabean");

        System.out.println(bean1 == bean2);

    }

}
</code></pre> 
<p>执行结果： </p> 
<p class="img-center"><img alt="" height="224" src="https://images2.imgbox.com/58/bb/BF01Ky2m_o.png" width="724"></p> 
<p></p> 
<ul><li>@Import：导入第三方组件。</li></ul> 
<blockquote> 
 <p> @Import：向Spring容器中导入一个组件,默认组件名为全类名。</p> 
</blockquote> 
<pre><code class="language-java">package org.example.boot.config;

import org.example.boot.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Scope;


@Import(CatConfig.class)             // 向容器中导入一个组件,默认组件名为全类名
@Configuration        // 这是一个配置类，@Configuration 注解表示该类是一个配置类，其中包含用于配置 bean 的方法。
public class AppConfig {

    @Scope("prototype")
    @Bean("hahabean") // Bean注解，申明这是一个bean类，告诉 Spring 容器要将某个实体类的实例作为一个 bean 注册到容器中
    public User user(){
        var user = new User();
        user.setId(1L);
        user.setName("zhangsan");

        return user;
    }
}
</code></pre> 
<p class="img-center"><img alt="" height="226" src="https://images2.imgbox.com/aa/87/ySZDOeop_o.png" width="740"></p> 
<p>  </p> 
<h4 id="gJK8H">3. 条件注解 <strong><span style="color:#fe2c24;">✫✫✫✫</span></strong></h4> 
<p id="u8041d2ce">如果注解指定的<strong>条件成立</strong>，则触发指定行为</p> 
<blockquote> 
 <p id="uacc7691e">@ConditionalOnXxx</p> 
 <p id="ufde658e3">@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</p> 
 <p id="uc221b247">@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</p> 
 <p id="uf84bd253">@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</p> 
 <p id="u4d82de09">@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</p> 
</blockquote> 
<p id="u4086908d">场景：</p> 
<ul><li id="ue73d6235">如果存在<code>CatConfig</code>这个 <span style="color:#fe2c24;">类</span>，给容器中放一个<code>Cat</code>组件，名cat01，</li><li id="u3000313e">否则，就给容器中放一个<code>Dog</code>组件，名dog01</li><li id="u751390c8">如果系统中有<code>dog01</code>这个 <span style="color:#fe2c24;">组件</span>，就给容器中放一个 User组件，名zhangsan</li><li id="u9f14f6b0">否则，就放一个User，名叫lisi</li></ul> 
<p id="u4da17f8c"><strong>@ConditionalOnBean（value=组件类型，name=组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值</strong></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/2e/dd/FVdNV8MK_o.png" width="296"></p> 
<p>主程序：</p> 
<pre><code class="language-java">package org.example.boot;

import org.example.boot.bean.Cat;
import org.example.boot.bean.Dog;
import org.example.boot.bean.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Boot302DemoApplication {

    public static void main(String[] args) {
        //java10: 局部变量类型的自动判断
        var ioc = SpringApplication.run(Boot302DemoApplication.class, args);


        for (String s : ioc.getBeanNamesForType(Cat.class)){
            System.out.println("cat:" + s);
        }


        for (String s : ioc.getBeanNamesForType(Dog.class)){
            System.out.println("Dog:" + s);
        }

        for (String s : ioc.getBeanNamesForType(User.class)){
            System.out.println("User:" + s);
        }

    }

}
</code></pre> 
<p>Dog.py： </p> 
<pre><code class="language-java">package org.example.boot.bean;

public class Dog {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre> 
<p>AppConfig2.py: </p> 
<pre><code class="language-java">package org.example.boot.config;

import org.example.boot.bean.Cat;
import org.example.boot.bean.Dog;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig2 {
    @ConditionalOnClass(name="org.example.boot.config.CatConfig")           // 如果类路径中存在这个类，则触发指定行为
    @Bean
    public Cat cat01(){
        return new Cat();
    }

    @ConditionalOnMissingClass(value="org.example.boot.config.CatConfig")       // 如果类路径中不存在这个类，则触发指定行为
    @Bean
    public Dog Dog01(){
        return new Dog();
    }


}
</code></pre> 
<p>CatConfig.py: </p> 
<pre><code class="language-java">package org.example.boot.config;

import org.example.boot.bean.Cat;

public class CatConfig {
    public Cat cat(){
        var cat = new Cat();
        cat.setId(1L);
        cat.setName("zhangsan");

        return cat;
    }
}
</code></pre> 
<p>执行结果： </p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/b6/43/ZoLzuNSY_o.png" width="702"></p> 
<p> 去掉 CatConfig 并注释掉AppConfig里的@import(CatConfig.class)注解，执行结果：</p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/45/00/FRVaW1Hr_o.png" width="742"></p> 
<p></p> 
<h4 id="Q4soh">4. 属性绑定 <strong><span style="color:#fe2c24;">✫✫✫✫</span></strong></h4> 
<blockquote> 
 <p>@Component：添加"@Component"注解，可以告诉Spring框架将该类实例化为一个Bean，并由Spring容器进行管理。</p> 
 <p id="u8e9d3aa0">@ConfigurationProperties： 声明组件的属性和配置文件哪些前缀开始项进行绑定。</p> 
 <p id="uc6d32a1e">@EnableConfigurationProperties：快速注册注解。</p> 
</blockquote> 
<ul><li id="ud93119af"><strong>场景：</strong>SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了 @Component、@ConfigurationProperties 注解，也没用。因为组件都扫描不进来，此时使用@EnableConfigurationProperties就可以快速进行属性绑定并把组件注册进容器。</li></ul> 
<p></p> 
<p id="u400e7530">将容器中任意<strong>组件（Bean）的属性值</strong>和<strong>配置文件（application.properties）</strong>的配置项的值<strong>进行绑定</strong></p> 
<ul><li id="uc6d0dd52"><strong>1、给容器中注册组件（</strong><span style="color:#fe2c24;">@Component、@Bean</span><strong>），</strong><span style="color:#0d0016;">@Component一般用于bean类，@Bean一般用于config类。</span></li><li id="ua4caa66b"><strong>2、使用 </strong><span style="color:#fe2c24;">@ConfigurationProperties</span><strong> 声明组件和配置文件（application.properties）的哪些配置项进行绑定</strong></li></ul> 
<p> <img alt="" height="374" src="https://images2.imgbox.com/1e/b8/lPl0yWA3_o.png" width="273"></p> 
<p>pig.py: </p> 
<pre><code class="language-java">package org.example.boot.bean;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;


//@Component
public class Pig {
    private Long id;
    private String name;
    private Integer age;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {                  //重写 toString() 方法，返回了包含对象的 name 和 age 属性的字符串表示形式。
        return "Pig{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
</code></pre> 
<p>去掉@Component也可以实现相同的功能，在AppConfig.py配置类里加入：</p> 
<pre><code class="language-java">    @Bean
    public Pig pig(){
        return new Pig();
    }</code></pre> 
<p><span style="color:#0d0016;">两种方法的目的都是为了将pig组件</span><span style="color:#fe2c24;">加入 spring 容器</span><span style="color:#0d0016;">。</span></p> 
<p><span style="color:#0d0016;">在主方法里加入：</span></p> 
<pre><code class="language-java">        Pig pig = ioc.getBean(Pig.class);
        System.out.println("pig:" + pig);</code></pre> 
<p>执行结果： </p> 
<p class="img-center"><img alt="" height="278" src="https://images2.imgbox.com/55/b6/FmNwGlmp_o.png" width="741"></p> 
<p></p> 
<p>sheep.py:</p> 
<pre><code class="language-java">package org.example.boot.bean;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@ConfigurationProperties(prefix = "sheep")
public class sheep {
    private Long id;
    private String name;
    private int age;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "sheep{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
</code></pre> 
<p>在AppConfig.py主类上加上@EnableConfigurationProperties(value = sheep.class)</p> 
<p><span style="color:#0d0016;">在主方法里加入：</span></p> 
<pre><code class="language-java">        sheep sheep = ioc.getBean(sheep.class);
        System.out.println("sheep:" + sheep);</code></pre> 
<p>执行结果：</p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/85/86/IWCqdB7M_o.png" width="739"></p> 
<p></p> 
<h3 id="06%20--%20YAML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">06 -- YAML配置文件</h3> 
<blockquote> 
 <ul><li id="ub6e39e17">使用<code>.yaml</code>或 <code>.yml</code>作为文件后缀</li><li> <h4 id="FY4Rp">基本语法：</h4> </li><li id="u341661b1"><strong>大小写敏感</strong></li><li id="u442a648d">使用<strong>缩进表示层级关系，k: v，</strong><span style="color:#fe2c24;">使用空格分割k,v</span></li><li id="u64edbad8"><span style="color:#fe2c24;">缩进时不允许使用Tab键，只允许使用空格</span>。换行</li><li id="u6e806a80">缩进的空格数目不重要，只要<strong>相同层级</strong>的元素<strong>左侧对齐</strong>即可</li><li id="u9253ee18"><strong># 表示注释</strong>，从这个字符一直到行尾，都会被解析器忽略。</li><li> <p id="ufaf1f88c"></p> <p id="u747fee13">支持的写法：</p> </li><li id="u11def865"><strong>对象</strong>：<strong>键值对</strong>的集合，如：映射（map）/ 哈希（hash） / 字典（dictionary）</li><li id="u064df489"><strong>数组</strong>：一组按次序排列的值，如：序列（sequence） / 列表（list）</li><li id="ue209ce00"><strong>纯量</strong>：单个的、不可再分的值，如：字符串、数字、bool、日期</li></ul> 
 <p><strong>xml:</strong></p> 
 <pre>server.port = 9999
sheep.id = 2
sheep.name = 肖恩
sheep.age = 7</pre> 
 <p></p> 
 <p><strong>yml:</strong></p> 
 <pre>server:
  port: 9999
  
sheep:
  id: 2
  name: 肖恩
  age: 7</pre> 
</blockquote> 
<p></p> 
<h3 id="07%20--%20%E6%97%A5%E5%BF%97%C2%A0">07 -- 日志 </h3> 
<p class="img-center"><img alt="" height="132" src="https://images2.imgbox.com/0c/da/wsG1ZVOO_o.png" width="542"></p> 
<p> 如同JDBC和mysql，日志门面组件和日志实现组件是一一对应的。</p> 
<h4 id="ufECQ">1. 简介</h4> 
<blockquote> 
 <ul><li>Spring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。</li><li>spring5及以后 commons-logging 被spring直接自己写了。</li><li>支持<span style="color:#fe2c24;"> jul，log4j2，logback</span>。SpringBoot 提供了默认的控制台输出配置，也可以配置输出为文件。</li><li>logback是默认使用的。</li><li>虽然<strong>日志框架很多</strong>，但是我们不用担心，使用 SpringBoot 的<strong>默认配置就能工作的很好</strong>。</li></ul> 
</blockquote> 
<p><strong>SpringBoot怎么把日志默认配置好的：</strong></p> 
<blockquote> 
 <p id="u7a8f2473">1、每个<code>starter</code>场景，都会导入一个核心场景<code>spring-boot-starter</code></p> 
 <p id="uba725985">2、核心场景引入了日志的所用功能<code>spring-boot-starter-logging</code></p> 
 <p id="u790b9a61">3、<span style="color:#fe2c24;">默认使用了<code>logback + slf4j</code> 组合作为默认底层日志</span></p> 
 <p id="u4de0a0e1">4、<code>日志是系统一启动就要用</code>，<code>xxxAutoConfiguration</code>是系统启动好了以后放好的组件，后来用的。</p> 
 <p id="u1db05492">5、日志是利用<strong>监听器机制</strong>配置好的。<code>ApplicationListener</code>。</p> 
 <p id="u10e2666c">6、日志所有的配置都可以通过修改配置文件实现。以<code>logging</code>开始的所有配置</p> 
</blockquote> 
<h4 id="JIbVA" style="background-color:transparent;">2. 日志格式</h4> 
<pre id="Onjlo"><code>2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]</code></pre> 
<p id="u460692a1">默认输出格式：</p> 
<ul><li id="u13345ba8">时间和日期：毫秒级精度</li><li id="ue2069e96">日志级别：ERROR, WARN, INFO, DEBUG, or TRACE.</li><li id="ubb60782c">进程 ID</li><li id="u600fa8c6">---： 消息分割符</li><li id="u46ee38a0">线程名： 使用[]包含</li><li id="u98af71e4">Logger 名： 通常是产生日志的<strong>类名</strong></li><li id="uc5732f6d">消息： 日志记录的内容</li></ul> 
<p id="ubca96212">注意： logback 没有FATAL级别，对应的是ERROR</p> 
<p></p> 
<p><strong>日志文件输出</strong>：</p> 
<p>指定 logging.file.name 和 logging.file.path 同时存在时，会优先 logging.file.name 配置项。</p> 
<pre><code class="language-XML"># 指定日志文件路径
# logging.file.path=D://
# 指定日志文件名的同时也可以指定指定路径
logging.file.name=D://demo.log</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7faa73934c51716be31a9485fc7cbab7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第 5 章 ROS常用组件-rosbag(自学二刷笔记)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd323074b4142038254b85519ced2097/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hadoop集群搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>