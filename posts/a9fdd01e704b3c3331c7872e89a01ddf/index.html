<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>个人项目总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="个人项目总结" />
<meta property="og:description" content="hdl项目总结 mapper实体类处理 fastjson使用 mysql 插入百万表 drop table if exists person; create table person ( PID int(11) auto_increment comment &#39;编号&#39;, PNAME varchar(50), PSEX varchar(10), PAGE int(11), SAL decimal(7,2) comment &#39;salary&#39;, primary key(PID) ); create procedure insert_person(in max_num int(10)) BEGIN declare i int default 0; set autocommit =0; repeat set i = i&#43;1; insert into person(PID,PNAME,PSEX,PAGE,SAL) values(i,concat(&#39;test&#39;,floor(rand()*10000000)),if(rand()&gt;0.5,&#39;男&#39;,&#39;女&#39;),floor(rand()*100)&#43;10,floor(rand()*19000)&#43;100); until i = max_num end repeat; commit; end; call insert_person(3000000); 事务锁 lock_wait_timeout
上网查找了一下，了解到了该类问题出现的主要原因是：Mysql的 InnoDB存储引擎是支持事务的，事务开启后没有被主动Commit，导致该资源被长期占用，其他事务在抢占该资源时，因上一个事务的锁而导致抢占失败！因此出现 Lock wait timeout ex" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a9fdd01e704b3c3331c7872e89a01ddf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T01:25:11+08:00" />
<meta property="article:modified_time" content="2023-06-12T01:25:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">个人项目总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="hdl_0"></a>hdl项目总结</h2> 
<h3><a id="mapper_1"></a>mapper实体类处理</h3> 
<h4><a id="fastjson_2"></a>fastjson使用</h4> 
<h4><a id="mysql_3"></a>mysql</h4> 
<h6><a id="_4"></a>插入百万表</h6> 
<pre><code class="prism language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> person<span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> person <span class="token punctuation">(</span>
	PID <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">auto_increment</span> <span class="token keyword">comment</span> <span class="token string">'编号'</span><span class="token punctuation">,</span>
	PNAME <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	PSEX <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	PAGE <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	SAL <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'salary'</span><span class="token punctuation">,</span>
	<span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>PID<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_person<span class="token punctuation">(</span><span class="token operator">in</span> max_num <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">declare</span> i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">set</span> autocommit <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">repeat</span>
	<span class="token keyword">set</span> i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">insert</span> <span class="token keyword">into</span> person<span class="token punctuation">(</span>PID<span class="token punctuation">,</span>PNAME<span class="token punctuation">,</span>PSEX<span class="token punctuation">,</span>PAGE<span class="token punctuation">,</span>SAL<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span>floor<span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">if</span><span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'女'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>floor<span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>floor<span class="token punctuation">(</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">19000</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	until i <span class="token operator">=</span> max_num
	<span class="token keyword">end</span> <span class="token keyword">repeat</span><span class="token punctuation">;</span>
	<span class="token keyword">commit</span><span class="token punctuation">;</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>

<span class="token keyword">call</span> insert_person<span class="token punctuation">(</span><span class="token number">3000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_31"></a>事务锁</h4> 
<p>lock_wait_timeout<br> 上网查找了一下，了解到了该类问题出现的主要原因是：Mysql的 InnoDB存储引擎是支持事务的，事务开启后没有被主动Commit，导致该资源被长期占用，其他事务在抢占该资源时，因上一个事务的锁而导致抢占失败！因此出现 Lock wait timeout ex</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span>
杀掉phread_id
<span class="token keyword">KILL</span>  <span class="token number">22</span>
</code></pre> 
<h4><a id="_39"></a>慢查询日志</h4> 
<pre><code class="prism language-sql">
<span class="token keyword">SHOW</span> variables <span class="token operator">like</span> <span class="token string">'%long_query_time%'</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> @<span class="token variable">@slow_query_log</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> long_query_time <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>


<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%have_profiling%'</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> @<span class="token variable">@profiling</span><span class="token punctuation">;</span>
<span class="token keyword">show</span> profiles<span class="token punctuation">;</span>
</code></pre> 
<p>索引介绍</p> 
<p>什么是MySQL的索引<br> 索引是帮助MySQL高效获取数据的数据结构<br> MySQL再存储数据之外，数据库系统中还维护者满足特定查找算法的数据结构，这些数据结构以某种引用表中的数据，这样我们就可以通过数据结构上实现的高级查找算法来快速找到我们想要的数据，而这种数据结构就是索引。<br> 简单理解为，“排好序的可以快速查找数据的数据结构”<br> 索引数据结构<br> 二叉树数据结构<br> 弊端：当极端情况下，数据递增插入是，会一直向右插入，形成链表，查询效率会降低<br> MySQL中常用地索引数据结构有BTree索引（MyISAM存储引擎），B+Tree索引（Innodb存储引擎），Hash索引（memory存储引擎）等等。<br> 索引优势<br> 提高数据检索的效率，降低数据库的IO成本<br> 通过索引对数据进行排序，降低数据排序的成本，降低了CPU的消耗<br> 索引劣势<br> 索引实际上也是一张表，保存了主键和索引的字段，并且指向实体表的记录，所以索引也是需要占用空间的，在索引大大提高查询速度的同时，却会降低表的更新速度，在对表进行数据增删改的同时，MySQL不仅要更新数据，还需要保存一下索引文件，每次更新添加了的索引列的字段，都会去调整因为更新带来的减值变化后的索引的信息。<br> 索引使用场景<br> 推荐建立索引：<br> 主键自动建立唯一索引<br> 频繁作为查询条件的字段应该创建索引（where后面的语句）<br> 查询中与其他表关联的字段，外键关系建立索引<br> 多字段查询下倾向创建组合索引<br> 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度<br> 查询中统计或者分组字段<br> 不推荐建立索引<br> 表记录太少<br> 经常增删改查<br> where条件里用不到的字段不建立索引<br> 索引分类<br> 主键索引<br> 表中的列设定为主键后，数据库会自动建立主键索引<br> 单独创建和删除主键索引语法<br> 创建主键索引语法：alter table 表名 add primary key (字段)<br> 删除主键索引语法：alter table 表名 drop primary key;<br> 唯一索引<br> 表中的列创建了唯一约束时，数据库会自动建立唯一索引。<br> 单独创建和删除唯一索引语法：<br> 创建唯一索引语法：alter table 表名 add unique 索引名(字段)或create unique index 索引名 on 表名(字段)<br> 删除唯一索引语法：drop index 索引名 on 表名<br> 单值索引（即一个索引只包含单个列，一个表可以有多个单值索引）<br> 建表时可随表一起建立单值索引<br> 单独创建和删除单值索引：<br> 创建单值索引：alter table 表名 add index 索引名(字段)或create index 索引名 on 表名(字段)<br> 删除单值索引：drop index 索引名 on 表名；<br> 复合索引（即一个索引包含多个列）<br> 建表时可随表一起简历复合索引<br> 单独创建和删除复合索引：<br> 创建复合索引：create index 索引名 on 表名(字段1，字段2);或alter table 表名 add index 索引名(字段1，字段2);<br> 删除复合索引：drop index 索引名 on 表名;<br> 性能分析</p> 
<p>MySQL常见瓶颈<br> SQL中对大量数据进行比较、关联、排序、分组时CPU的瓶颈<br> 实例内存满足不了缓存数据或排序等需要，导致产生大量的物理IO。查询数据是扫描过多数据行，导致查询效率低。<br> Explain<br> 使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。可以用来分析查询语句或是表的结构的性能瓶颈。其作用：<br> 表的读取顺序<br> 哪些索引可以使用<br> 数据读取操作的操作类型<br> 哪些索引被实际使用<br> 表之间的引用<br> 每张表有多少行被优化器查询<br> explain关键字使用起来比较简单：explain + sql 语句<br> explain重要字段名<br> id<br> select查询的序列号，表示查询中执行select子句或操作表的顺序<br> id相同时，执行顺序由上至下<br> id不同，如果是子查询，id的序号会递增，id值越大优先级越高，则先被执行<br> id相同和不同都存在是，id相同的可以理解为一组，从上往下顺序执行，所有组中，id值越大，优先级越高越先执行。<br> select_type<br> simple：简单的select查询，查询中不包含子查询或者union<br> primary：查询中若包含任何复杂的子部分，最外层查询则被标记为primary<br> derived：在from列表中包含的子查询被标记为derived（衍生），mysql会递归执行这些子查询，把结果放在临时表里。<br> subquery：在select或where列表中包含了子查询。<br> table：显示这一行的数据是关于哪张表的<br> type<br> system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计<br> const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，mysql就能将该查询转换为一个常量。<br> eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<br> ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该数据查找和扫描的混合体。<br> range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。<br> index：full index scan，index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小，也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。<br> all：full table scan，将遍历全表以找到匹配的行。<br> 从最好到最差依次是system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all。一般来说，最好保证查询能达到range级别，最好能达到ref。<br> possible_keys:显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上如果存在索引，则该索引将会被列出来，但不一定会被查询实际使用上。<br> key:查询中实际使用的索引，如果为null，则没有使用索引<br> ref：显示索引的哪一列被使用了，哪些列或常量被用于查找索引列上的值<br> rows:rows列显示MySQL认为它执行查询时必须检查的行数，一般越少越好。<br> extra：一些常见的重要的额外信息：<br> using filesort：MySQL无法利用索引完成的排序操作称为“文件排序”（排序时没有使用索引，需要优化）<br> Using temporary：MySQL在对查询结果排序时使用临时表，常见于排序order by和分组查询group by。（分组时没有使用索引，需要优化）<br> Using index：表示索引被用来执行行索引键值的查找，避免访问了表的数据行，效率不错。<br> Using where：表示使用了where过滤。<br> 查询优化</p> 
<p>索引失效<br> 最佳左前缀法则：如果索引了多列，要遵循最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。<br> 不在索引列上做任何计算、函数操作，会导致索引失效而转向全表扫描。<br> 存储引擎不能使用索引中范围条件右边的列。<br> MySQL在使用不等于时无法使用索引会导致全表扫描。<br> is null 可以使用索引，但是is not null无法使用索引。<br> like以通配符开头会使索引失效导致全表扫描。<br> 字符串不加单引号索引会失效。<br> 使用or连接时索引失效<br> 建议：<br> and会自动调整顺序为最左前列<br> 对于单值索引，尽量选择针对当前查询字段过滤性更好的索引<br> 对于组合索引，当前where查询中过滤性更好的字段在索引字段顺序中位置越靠前越好<br> 对于组合索引，尽量选择能够包含在当前查询中where子句中更多字段的索引<br> 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的<br> 排序优化<br> 尽量避免使用Using FileSort方式排序<br> order by语句使用索引最左前列或使用where子句与order by子句条件组合满足索引最左前列。<br> where子句中如果出现索引范围查询会导致order by索引失效。<br> 关联查询优化：内连接时，MySQL会自动把小结果集的选为驱动表，所以大表的字段最好加上索引，左外连接时，左表会全表扫描，所以右边大表字段最好加上索引，右外连接同理，我们最好保证被驱动表上的字段建立了索引。<br> 慢查询日志</p> 
<p>慢查询日志简介：mysql的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超越阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中，可以由它来查看哪些SQL超出了我们最大忍耐时间值。<br> 慢查询日志使用<br> 默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数。<br> 查看是否开启：show variables like ‘%slow_query_log%’;<br> 开启日志：set global slow_query_log = 1;<br> 设置时间：set global long_query_time=1;<br> 查看时间：show vari ables like ‘long_query_time%’;<br> 查看超时的SQL记录日志：MySQL的数据文件夹下：5.5/Data/设备名称-slow.log<br> 注意：非调优场景下，一般不建议启动改参数，慢查询日志支持将日志记录写入文件，开启慢查询日志会或多或少带来一定的性能影响。</p> 
<h4><a id="mybatis_179"></a>mybatis使用逻辑</h4> 
<ul><li>后端分离，首先在mapper.xml中注册mapper</li><li>然后在mapper文件件下写mapper，并注册函数</li><li>在service文件中写mapperimplement，具体实现函数</li><li>最后再controller中调用mapper函数，实现网络接口需求</li></ul> 
<h2><a id="qt_184"></a>集群qt项目总结</h2> 
<p>(1)机械设备寿命预测集群系统 (国家重点装发预研项目，寿命预测技术领域)<br> 2022.06-至今 主要技术完成人<br> 项目描述：此项目针对机械设备寿命预测任务，搭建了多种神经网络模型，完成了高并发服务器与轻量化客户端开发，实现了客户端的高性能算法预测和跨服务器联调通信功能。<br> 主要工作：1、使用Muduo网络库提供高并发网络服务,实现客户端与服务端的数据传输，通过分层设计进行模块解耦；<br> 2、使用Json作为私有通信协议，实现客户端之间的分组通信；<br> 3、配置Nginx基于TCP的负载均衡，实现服务器的集群功能，提高后端服务的并发能力；<br> 4、基于Redis消息队列的发布订阅功能，优化跨服务器通信业务，减少了60% 模块开发时间；<br> 5、通过慢查询日志定位和索引进行MySQL优化，查询时间从1200ms降低到40ms，降幅为96.67%。<br> 个人收获：通过这个项目，熟悉了高并发服务的设计与开发流程，通过Nginx负载均衡、Redis消息队列在服务端的应用，对高性能服务器开发有了更深的理解。</p> 
<h3><a id="_198"></a>主要工作内容</h3> 
<h4><a id="1muduo_199"></a>1、muduo网络开发</h4> 
<p>在大量机械设备的使用中，个别设备的寿命预测和管理是很棘手的问题。本项目旨在通过神经网络算法和网络编程技术，实现机械设备的寿命预测和统一调度，任何一台机械设备都可以是主机和从机。<br> 在网络开发层面，由于每个机械设备的资源情况不相同，所以往往不能支撑寿命预测任务，所以通过三台服务器进行服务端开发。并实现单个机械设备上的客户端和服务端的通信。</p> 
<ul><li>具体高并发网络服务通过muduo库实现，并通过哈希表管理每一个机械设备的tcp连接进程。通过设计service层，将网络编程的具体实现与网络连接进行模块解耦。</li><li>在网络service中，通过json作为私有通讯协议，将网络通讯的信息进行序列化和反序列化传输，实现不同设备之间的寿命预测通信，并调用相关业务，实现调度。</li></ul> 
<h4><a id="2_204"></a>2、数据模块开发</h4> 
<ul><li>接入mysql链接库，并将设计实体层和mapper层、mapperservice层，实现数据模块解耦。</li><li>设计user表、friend表、message表。通过将网络信息反序列化，读取信息，调用mpper service中的sql函数，实现登录验证和在线查询、分组通信功能。</li></ul> 
<h4><a id="3_207"></a>3、高并发开发</h4> 
<ul><li>通过nginx配置负载均衡，提高服务器的并发能力。但是由于tcp连接进程存储在某个服务器的哈希表中，通讯双方不在同一个哈希表，所以无法进行调度通信。</li><li>建立redis消息队列，每个服务器建立redis订阅和发布，找到对应的tcp进程，实现跨服务器通信</li><li></ul> 
<h3><a id="_211"></a>项目遇到的问题</h3> 
<ul><li>在客户端的开发设计中，一开始通过主线程进行信息发送，然后接收服务端的信息进行展示，然后直接设立子线程用来接收其他客户端发送的消息，没有考虑到多线程的死锁问题</li><li>改进为主线程只负责发送，子线程只负责接收。然后线程间通过信号量进行消息传递。</li></ul> 
<h3><a id="11_cmake_214"></a>1.1 cmake</h3> 
<p><img src="https://images2.imgbox.com/06/e9/Poizvz4T_o.png" alt="在这里插入图片描述"><br> cmake主要解决g++的六处配置问题</p> 
<h4><a id="111_cmake_217"></a>1.1.1 主函数cmake</h4> 
<pre><code class="prism language-c++">cmake_minimum_required(VERSION 3.0)
project(chat)

# 配置编译选项
set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} -g)

# 配置最终的可执行文件输出的路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)

# 配置头文件的搜索路径
#先开发server
include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/include/server)

#继续开发server里面的模组
include_directories(${PROJECT_SOURCE_DIR}/include/server/db)
include_directories(${PROJECT_SOURCE_DIR}/include/server/model)
include_directories(${PROJECT_SOURCE_DIR}/include/server/redis)

#使用第三方库
include_directories(${PROJECT_SOURCE_DIR}/thirdparty)
link_directories(/usr/lib64/mysql)

# 加载子目录，确定后续搜索的路径
add_subdirectory(src)
</code></pre> 
<h4><a id="112_servercmake_245"></a>1.1.2 server中的cmake</h4> 
<pre><code class="prism language-c++"># 3、定义源代码路径：定义了一个SRC_LIST变量，包含了该目录下所有的源文件（类似typedef）
aux_source_directory(. SRC_LIST)
aux_source_directory(./db DB_LIST)
aux_source_directory(./model MODEL_LIST)
aux_source_directory(./redis REDIS_LIST)

# 1、指定生成可执行文件
add_executable(ChatServer ${SRC_LIST} ${DB_LIST} ${MODEL_LIST} ${REDIS_LIST})
# 2、设定编译条件：指定可执行文件链接时需要依赖的库文件
target_link_libraries(ChatServer muduo_net muduo_base mysqlclient hiredis pthread)
</code></pre> 
<h4><a id="sql_259"></a>sql</h4> 
<pre><code class="prism language-c++">开启服务器
cd Desktop/chatserver/bin
./ChatServer 127.0.0.1 6000
telnet 127.0.0.1 6000
登录命令
{"msgid":1,"id":13,"password":"123456"}
</code></pre> 
<h4><a id="nginx_268"></a>nginx</h4> 
<p>基于tcp的负载均衡<br> 位置：etc/</p> 
<pre><code class="prism language-c++">sudo netstat -apn |grep nginx
sudo service nginx start
sudo nginx -t
sudo nginx -s reload
</code></pre> 
<p>配置信息如下：<br> <img src="https://images2.imgbox.com/c5/b0/Xi9ccXDy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="redis_280"></a>redis</h4> 
<p>配置静态库环境变量</p> 
<pre><code class="prism language-c++">/etc/ld.so.conf：记录了程序加载运行期间查找动态链接库时的路径。

注意：对所有用户生效。不是每种操作系统都有这个配置文件。

具体步骤：

找到动态库的路径
编辑/etc/ld.so.conf，把刚找到的路径添加到最后一行
立即生效：sudo ldconfig -v
此时，再次运行程序即可。
</code></pre> 
<p>hiredis位置：usr/local/include/hiredis<br> redis业务逻辑：<br> <img src="https://images2.imgbox.com/80/1f/GlPXLDcO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="chatservice_297"></a>chatservice</h4> 
<p>通过map保存tcp连接状态</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45dd7cc448f4f7d444b26914af9b3539/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端常用库 CDN</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c682ff6ee2eb30a4d04d06662af80f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查看电脑架构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>