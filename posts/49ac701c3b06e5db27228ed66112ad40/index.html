<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自然数无序拆分(三种方法) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自然数无序拆分(三种方法)" />
<meta property="og:description" content="自然数无序拆分 时间限制: 1 Sec 内存限制: 128 MB
题目描述
美羊羊给喜羊羊和沸羊羊出了一道难题，说谁能先做出来，我就奖励给他我自己做的一样礼物。沸羊羊这下可乐了，于是马上答应立刻做出来，喜羊羊见状，当然也不甘示弱，向沸羊羊发起了挑战。
可是这道题目有一些难度，喜羊羊做了一会儿，见沸羊羊也十分头疼，于是就来请教你。
题目是这样的：
把自然数Ｎ（N&lt;＝100）分解为若干个自然数之和，求出有几种情况。
如N＝5时，有7种情况
5=1&#43;1&#43;1&#43;1&#43;1
5=1&#43;1&#43;1&#43;2
5=1&#43;1&#43;3
5=1&#43;2&#43;2
5=1&#43;4
5=2&#43;3 5=5
怎么样？你要加油帮助喜羊羊哦！
输入
一个自然数N(N&lt;＝100）
输出
无序拆分的种数。
样例输入 复制样例数据
5 样例输出
7 1.递归，超级慢
/**/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;stack&gt; #include &lt;queue&gt; typedef long long LL; using namespace std; int n; int dp(int x, int y){ //x表示被分的数，y表示分的值 if(x == 1 || y == 1){//如果x=1，怎么分都是1种，y=1时2只有{1,1,1,." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/49ac701c3b06e5db27228ed66112ad40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-09T12:10:27+08:00" />
<meta property="article:modified_time" content="2018-12-09T12:10:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自然数无序拆分(三种方法)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>自然数无序拆分</h4> 
<p>时间限制: 1 Sec  内存限制: 128 MB</p> 
<p>题目描述</p> 
<p>美羊羊给喜羊羊和沸羊羊出了一道难题，说谁能先做出来，我就奖励给他我自己做的一样礼物。沸羊羊这下可乐了，于是马上答应立刻做出来，喜羊羊见状，当然也不甘示弱，向沸羊羊发起了挑战。<br> 可是这道题目有一些难度，喜羊羊做了一会儿，见沸羊羊也十分头疼，于是就来请教你。<br> 题目是这样的：<br> 把自然数Ｎ（N&lt;＝100）分解为若干个自然数之和，求出有几种情况。<br> 如N＝5时，有7种情况<br> 5=1+1+1+1+1<br> 5=1+1+1+2<br> 5=1+1+3<br> 5=1+2+2<br> 5=1+4<br> 5=2+3 <br> 5=5<br> 怎么样？你要加油帮助喜羊羊哦！</p> 
<p> </p> 
<p> </p> 
<p>输入</p> 
<p>一个自然数N(N&lt;＝100）</p> 
<p> </p> 
<p>输出</p> 
<p>无序拆分的种数。</p> 
<p> </p> 
<h3>样例输入</h3> 
<p>复制样例数据</p> 
<pre>5
</pre> 
<p>样例输出</p> 
<pre>7</pre> 
<p>1.递归，超级慢</p> 
<pre class="has"><code class="hljs language-cpp">/**/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

typedef long long LL;
using namespace std;

int n;

int dp(int x, int y){ //x表示被分的数，y表示分的值
	if(x == 1 || y == 1){//如果x=1，怎么分都是1种，y=1时2只有{1,1,1,...}这一种
		return 1;
	}else if(x == y){ // 表示被分的数与分的数相同，有两种情况，按分的数分，就{x}一种，第二种就是分比y小的数
		return 1 + dp(x, x - 1);
	}else if(x &lt; y){// 如果被分的数小于分的数，那种类和分的数同被分的数种数相同
		return dp(x, x);
	}else if(x &gt; y){//如果被分数大于分的数，那么也有两种情况，第一种情况，就是包含分的数y，并且有可能有多个，所以分的数y不变
		return dp(x - y, y) + dp(x, y - 1);             //第二种情况就是不包含分的数y，那么从分的数为（y-1）开始分
	}
}

int main()
{
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);

	scanf("%d", &amp;n);
	int ans = dp(n, n);
	printf("%d\n", ans);

	return 0;
}
/**/</code></pre> 
<p> </p> 
<p>2.dp</p> 
<pre class="has"><code class="hljs language-cpp">/**/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

typedef long long LL;
using namespace std;

int n;
int dp[105][105];

int main()
{
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);

	scanf("%d", &amp;n);
	for (int i = 1; i &lt;= n; i++){
		for (int j = 1; j &lt;= i; j++){
			if(i == 1 || j == 1) dp[i][j] = 1;// 这个和递归的情况是一样的
			else if(i == j) dp[i][j] = 1 + dp[i][j - 1];// 这个情况也同递归的一样
			else if(i - j &lt; j) dp[i][j] = dp[i - j][i - j] + dp[i][j - 1];
			//1.j为分的数，i为被分数，如果分完一次j还存在比j大的数，那么应该从那个数(i-j)开始分，而不是j
			//2.如果不包含分的数j，那么从(j-1)开始分
			else dp[i][j] = dp[i - j][j] + dp[i][j - 1];
			//1.如果分完一次不存在比j大的数，那么还从j开始再分
			//2.分的数不为j，就从j-1开始分
		}
	}
	printf("%d\n", dp[n][n]);

	return 0;
}
/**/</code></pre> 
<p>3.母函数</p> 
<p>f(x)=(1+x^1+x^2+x^3....+x^n)*(1+x^2+x^4+...)*.....(1+x^n);</p> 
<p>上面的就是母函数。。。应该就是这样</p> 
<p>然后首先数为n的被分数，可以由1，2，3，4，......，n组成，就是不知道选1几个，选2几个。。。</p> 
<p>这时候我们可以看一下母函数，设选的数字为i，选的次数为k，那么x的指数可以表示为x^(i*k)；</p> 
<p>就像f(x)中(1+x^1+x^2+x^3....+x^n)表示1不选，1选一次，1选2次....; (1+x^2+x^4+...)表示2不选，2选1次，选2次。。。</p> 
<p>那么我们要求的分解n的种数就是x^n前的系数（很容易想）。</p> 
<p>怎么求x^n的系数呢，多项式相乘解决。</p> 
<pre class="has"><code class="hljs language-cpp">/**/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

typedef long long LL;
using namespace std;

int n;
int num1[105], num2[105];

int main()
{
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);

	scanf("%d", &amp;n);
	for (int i = 0; i &lt;= n; i++) num1[i] = 1;//开始第一个多项式的系数都为1，指数为i
	for (int i = 2; i &lt;= n; i++){//i表示选的数
		for (int j = 0; j &lt;= n; j++){//j表示第几项
			for (int k = 0; k + j &lt;= n; k += i){//k为x的指数，就是选一次i，2次i。。。
				num2[j + k] += num1[j];//用另一个数组存储指数为j+k的x的系数，是与前一个多项式相乘
			}
		}
		memcpy(num1, num2, sizeof(num2));
		memset(num2, 0, sizeof(num2));
	}
	printf("%d\n", num1[n]);

	return 0;
}
/**/</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6519e527532c6397ee9ae50babc867a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringCloud微服务服务间调用之OpenFeign介绍(一)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ee23b52348630321c8e3e18e4798325/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">概率论基础（一）：条件均值与全期望公式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>