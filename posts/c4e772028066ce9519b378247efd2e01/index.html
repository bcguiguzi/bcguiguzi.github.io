<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线段覆盖问题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线段覆盖问题" />
<meta property="og:description" content="线段覆盖
给定x轴上的N（0&lt;N&lt;100）条线段，每个线段由它的二个端点a_I和b_I确定，I=1,2,……N.这些坐标都是区间（－999，999）的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。
输入描述 Input Description
输入第一行是一个整数N。接下来有N行，每行有二个空格隔开的整数，表示一条线段的二个端点的坐标。
输出描述 Output Description
输出第一行是一个整数表示最多剩下的线段数。
样例输入 Sample Input
3
6 3
1 3
2 5
样例输出 Sample Output
2
数据范围及提示 Data Size &amp; Hint
0&lt;N&lt;100
基础线段覆盖模型 -&gt; 贪心
直接按照右端点从小到大排序。优先选排在前面的。
证明：排序后显然当你选了一个线段后，再要从后面选一个线段，其左断点必须&gt;=你的右端点。右端点当然越小越好。
代码如下：
public class Test { private static void quickSort(int[][] arr, int low, int high){ if (low &gt;= high || arr.length == 0) return; int i = low; int j = high; int x = arr[low][1]; while (i &lt; j){ //从右向左查找第一个小于x的坐标 while (i &lt; j &amp;&amp; arr[j][1] &gt; x) j--; //从左向右查找第一个大于x的坐标 while (i &lt; j &amp;&amp; arr[i][1] &lt;= x) i&#43;&#43;; if (i &lt; j){ int p1 = arr[i][1]; int p2 = arr[i][0]; arr[i][1] = arr[j][1]; arr[i][0] = arr[j][0]; arr[j][1] = p1; arr[j][0] = p2; } } int tmp1 = arr[i][1]; int tmp2 = arr[i][0]; arr[i][1] = arr[low][1]; arr[i][0] = arr[low][0]; arr[low][1] = tmp1; arr[low][0] = tmp2; //左排 quickSort(arr, low, i-1); //右排 quickSort(arr, i&#43;1, high); } public static void main(String[] args) { Scanner scan = new Scanner(System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c4e772028066ce9519b378247efd2e01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-20T19:53:59+08:00" />
<meta property="article:modified_time" content="2019-08-20T19:53:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线段覆盖问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>线段覆盖</strong></p> 
<p>       给定x轴上的N（0&lt;N&lt;100）条线段，每个线段由它的二个端点a_I和b_I确定，I=1,2,……N.这些坐标都是区间（－999，999）的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。</p> 
<p>输入描述 Input Description</p> 
<p>    输入第一行是一个整数N。接下来有N行，每行有二个空格隔开的整数，表示一条线段的二个端点的坐标。</p> 
<p>输出描述 Output Description</p> 
<p>    输出第一行是一个整数表示最多剩下的线段数。</p> 
<p>样例输入 Sample Input</p> 
<p>3</p> 
<p>6  3</p> 
<p>1  3</p> 
<p>2  5</p> 
<p>样例输出 Sample Output</p> 
<p>2</p> 
<p>数据范围及提示 Data Size &amp; Hint</p> 
<p>0&lt;N&lt;100</p> 
<blockquote> 
 <p>基础线段覆盖模型 -&gt; 贪心</p> 
 <p>直接按照右端点从小到大排序。优先选排在前面的。</p> 
 <p>证明：排序后显然当你选了一个线段后，再要从后面选一个线段，其左断点必须&gt;=你的右端点。右端点当然越小越好。</p> 
</blockquote> 
<p>代码如下：</p> 
<pre class="has"><code class="language-java">public class Test {

    private static void quickSort(int[][] arr, int low, int high){
        if (low &gt;= high || arr.length == 0) return;
        int i = low;
        int j = high;
        int x = arr[low][1];
        while (i &lt; j){
            //从右向左查找第一个小于x的坐标
            while (i &lt; j &amp;&amp; arr[j][1] &gt; x) j--;
            //从左向右查找第一个大于x的坐标
            while (i &lt; j &amp;&amp; arr[i][1] &lt;= x) i++;
            if (i &lt; j){
                int p1 = arr[i][1];
                int p2 = arr[i][0];
                arr[i][1] = arr[j][1];
                arr[i][0] = arr[j][0];
                arr[j][1] = p1;
                arr[j][0] = p2;
            }
        }

        int tmp1 = arr[i][1];
        int tmp2 = arr[i][0];
        arr[i][1] = arr[low][1];
        arr[i][0] = arr[low][0];
        arr[low][1] = tmp1;
        arr[low][0] = tmp2;

        //左排
        quickSort(arr, low, i-1);
        //右排
        quickSort(arr, i+1, high);

    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入行数：");
        int lineNum = scan.nextInt();
        System.out.println("请输入线段起始：");
        scan.nextLine();
        int[][] array = new int[lineNum][2];
        for (int i = 0; i &lt; lineNum; i++){
            String[] str = scan.nextLine().split(" +");
            if (Integer.parseInt(str[0]) &lt; Integer.parseInt(str[1])){
                array[i][0] = Integer.parseInt(str[0]);
                array[i][1] = Integer.parseInt(str[1]);
            } else {
                array[i][0] = Integer.parseInt(str[1]);
                array[i][1] = Integer.parseInt(str[0]);
            }
        }
        scan.close();
        quickSort(array, 0, lineNum - 1);
        int prev = 0;
        int count = 1;
        for (int j = 1; j &lt; lineNum; j++){
            if (array[prev][1] &lt;= array[j][0]){
                count++;
                prev = j;
            }
        }
        System.out.println(count);
    }
}</code></pre> 
<blockquote> 
 <p>注意：在调用nextLine()函数前调用了Scanner的另一个函数nextInt()，这会导致调用nextLine()的时候获取不到输入的值，这时候在要使用nextLine()前先调用一次nextLine()，这样留在缓冲区的“回车符”就会被处理掉，这时第二个nextLine()函数可以正常读取到数据。具体原因可参考：<a href="https://blog.csdn.net/u014584274/article/details/75089058">Java中nextInt()后接nextLine()读取不到数据</a></p> 
</blockquote> 
<p>线段覆盖2</p> 
<p>题目描述 Description</p> 
<p>数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。</p> 
<p>n&lt;=1000</p> 
<p>输入描述 Input Description</p> 
<p>第一行一个整数n，表示有多少条线段。</p> 
<p>接下来n行每行三个整数, ai bi ci，分别代表第i条线段的左端点ai，右端点bi（保证左端点&lt;右端点）和价值ci。</p> 
<p>输出描述 Output Description</p> 
<p>输出能够获得的最大价值</p> 
<p>样例输入 Sample Input</p> 
<p>3</p> 
<p>1 2 1</p> 
<p>2 3 2</p> 
<p>1 3 4</p> 
<p>样例输出 Sample Output</p> 
<p>4</p> 
<p>数据范围</p> 
<p>对于100%的数据，n≤1000；0&lt;=ai,bi&lt;=10000000&lt;=ci&lt;=1000000</p> 
<blockquote> 
 <p>基于贪心的基础上，排序DP</p> 
</blockquote> 
<p>代码如下：</p> 
<pre class="has"><code class="language-java">public class Test {

  /**
   * 根据线段右边界值进行快排。
   * @param array
   * @param low
   * @param high
   */
  public static void quickSort(int[][] array, int low, int high){
    if (low &lt;= high || array.length == 0) {
      return;
    }
    int i = low;
    int j= high;
    int key = array[low][1];
    while (i &lt; j){
      //从右向左查找第一个小与key的坐标
      while (i &lt; j &amp;&amp; array[j][1] &gt; key){
        j--;
      }
      //从左向右查找第一个大与key的坐标
      while (i &lt; j &amp;&amp; array[i][1] &gt;= key){
        i++;
      }
      if (i &lt; j){
        int p0 = array[i][0];
        int p1 = array[i][1];
        int p2 = array[i][2];
        array[i][0] = array[j][0];
        array[i][1] = array[j][1];
        array[i][2] = array[j][2];
        array[j][0] = p0;
        array[j][1] = p1;
        array[j][2] = p2;
      }
    }

    //保证array[low][]始终存放最小值
    int tmp0 = array[i][0];
    int tmp1 = array[i][1];
    int tmp2 = array[i][2];
    array[i][0] = array[low][0];
    array[i][1] = array[low][1];
    array[i][2] = array[low][2];
    array[low][0] = tmp0;
    array[low][1] = tmp1;
    array[low][2] = tmp2;

    quickSort(array, low, i-1);
    quickSort(array, i+1, high);
  }

  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入线段总数：");
    int lineNum = scan.nextInt();
    scan.nextLine();
    System.out.println("请输入线段信息（中间空格隔开）：");
    int[][] arr = new int[lineNum][3];
    for (int i = 0; i &lt; lineNum; i++){
      String[] str = scan.nextLine().split(" ");
      arr[i][0] = Integer.parseInt(str[0]);
      arr[i][1] = Integer.parseInt(str[1]);
      arr[i][2] = Integer.parseInt(str[2]);
    }
    scan.close();
    quickSort(arr, 0, lineNum-1);
    //存放（按右端点升序排序后的）以每条线段为右边界的线段最大价值
    int[] maxValue = new int[1000];
    //以第0条线段为右边界的线段最大价值大为第0条线段本身的价值
    maxValue[0] = arr[0][2];
    //从第一条线段开始遍历
    for (int m = 1; m &lt; lineNum; m++){
      //先将以该线段为右边界的线段最大价值为以前一条线段为右边界的线段的最大值
      maxValue[m] = maxValue[m-1];
      //遍历该条线段之前的线段
      for (int n = m-1; n &gt;= 0; n--){
        //找出第一条与该线段不重合的线段，即某条右端点小于该条线段的左端点的线段
        if (arr[n][1] &lt; arr[m][0]){
          //如果前面一条与该线段不重合的线段的最大价值加该条线段的价值大于上一条线段的价值
          if (arr[m][2] + maxValue[n] &gt; maxValue[m-1]){
            //以该条线段为右边界的线段最大价值赋为前面第一条与该条线段不重合的线段的最大价值加该条线段的价值
            maxValue[m] = arr[n][2] + maxValue[n];
          }
          break;
        }
      }
    }
    //数组maxValue中的每个值代表的就是以每条线段为右边界的线段最大价值
    for(int i = 0; i &lt; lineNum; i++){
       System.out.println("以第" + i + "条线段为边界的线段的最大价值为：" + maxValue[i]);
    }
  }

}</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7187bb14da753d3ebe690bb60cf9c84b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 实现数字黑洞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/330078d291915d63831e01e450c84bbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Z3求解器简介及环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>