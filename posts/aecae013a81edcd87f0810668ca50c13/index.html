<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>X与Wayland - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="X与Wayland" />
<meta property="og:description" content="前言 对于X和Wayland的历史，可以阅读这篇：揭开Wayland的面纱（一）：X Window的前生今世 。
X协议发展到今天已有30多年历史，许多性能问题日益严重，为了提效，人们将xserver中的一些功能（如字体）独立成模块放入了内核；
这就导致xserver的大部分功能被剥离，而xserver只剩下传递消息的功能。
Wayland就是为了取代X，解耦合xserver，实现更高效的通信方式。
Wayland的优势是：
使用合成器取代x服务器，减少通信损耗；不提供渲染API，渲染由客户端完成，提高渲染效率。 X协议 这张图是Wayland官网提供的，用以说明x的通信原理，但是官网没有解释术语和细节，我增加了实例解释过程：
1. evdev接收到鼠标事件，如点击了画图工具上的一个画矩形的按钮； evdev将鼠标事件（坐标，单击）放入消息队列（/dev/input/eventX）中，X是数字不是x服务器； xserver会打开相应的eventX文件，然后监听文件的读取事件来获取输入设备产生的事件信息。 2. xserver将evdev事件（坐标，单击）转换为窗口事件（窗口，按钮，单击）； xserver将窗口事件发给应用（x Client）； 3. 画图工具通过消息处理函数，调用x的画矩形API，XFillRectangle，将画矩形命令传送给了xserver； 4. xserver接收到画矩形事件，并将事件发给了合成器； 5. 合成器接收到画矩形事件，调用x内置渲染器或者OpenGL等渲染器，完成了渲染，将图形信息转化成像素信息，并合成最后的屏幕图像信息，传递给xserver； 6. xserver将屏幕图像发送给KMS，KMS调用显卡驱动进行显示，显示新的屏幕图像。 到这里，我们知道了xserver的架构原理，看上去没啥问题。
但是对比x架构图和下边的Wayland架构图，就会发现，合成器完全可以平移到xserver的位置，而通信架构不变。
啥意思呢？就是xserver是多余的，用合成器取代xserver,是Wayland提效的方法之一。
Wayland协议 在Wayland架构中，xserver的位置被合成器取代了，架构由星型架构（围绕xserver）变成了三层架构（以合成器为中心）；
1. evdev接收到鼠标事件； 2. 合成器负责转化为窗口事件，并传递给客户端； 3. 客户端调用消息处理函数， 此处，合成器不再提供绘图和渲染命令，也就是不再提供类似XFillRectangle这样的接口函数，而是由客户端调用OpenGL函数，如glDrawElements，来完成画矩形的动作，然后将图像保存到surface结构体中，并调用wl_surface_commit函数通知合成器有图像刷新； 4. 和x不同的是，Wayland中每个应用都维护一个surface缓存，当窗口需要更新时，通过wl_surface_commit函数通知合成器，合成器会读取surface缓存，合成新的屏幕图像。 在Wayland中，合成器只负责合成屏幕图像，而不负责渲染，这是Wayland加速的主要原因：
一者，Wayland取消了xserver作为中心地位的多余通信步骤；
二者，将渲染过程放在客户端处理，相当于并发渲染，而x放在合成器中集中渲染，影响了性能。
X API简介 窗口管理窗口通信渲染：2D绘图、文字等 使用x接口画矩形：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;X11/Xlib.h&gt; int main() { Display *dpy = XOpenDisplay(NULL); if (dpy == NULL) { fprintf(stderr, &#34;Cannot open display\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/aecae013a81edcd87f0810668ca50c13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-29T16:23:34+08:00" />
<meta property="article:modified_time" content="2023-08-29T16:23:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">X与Wayland</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>对于X和Wayland的历史，可以阅读这篇：<a href="https://cloud.tencent.com/developer/article/1442279" rel="nofollow">揭开Wayland的面纱（一）：X Window的前生今世</a> 。</p> 
<p>X协议发展到今天已有30多年历史，许多性能问题日益严重，为了提效，人们将xserver中的一些功能（如字体）独立成模块放入了内核；<br> 这就导致xserver的大部分功能被剥离，而xserver只剩下传递消息的功能。</p> 
<p>Wayland就是为了取代X，解耦合xserver，实现更高效的通信方式。</p> 
<p>Wayland的优势是：</p> 
<ul><li>使用合成器取代x服务器，减少通信损耗；</li><li>不提供渲染API，渲染由客户端完成，提高渲染效率。</li></ul> 
<p><img src="https://images2.imgbox.com/77/02/n5zyBDOZ_o.png" alt="image.png"></p> 
<h2><a id="X_15"></a>X协议</h2> 
<p><img src="https://images2.imgbox.com/a2/4a/dR6V3rRO_o.png" alt="11.png"></p> 
<p>这张图是Wayland官网提供的，用以说明x的通信原理，但是官网没有解释术语和细节，我增加了实例解释过程：</p> 
<pre><code>1. evdev接收到鼠标事件，如点击了画图工具上的一个画矩形的按钮；  
evdev将鼠标事件（坐标，单击）放入消息队列（/dev/input/eventX）中，X是数字不是x服务器；  
xserver会打开相应的eventX文件，然后监听文件的读取事件来获取输入设备产生的事件信息。

2. xserver将evdev事件（坐标，单击）转换为窗口事件（窗口，按钮，单击）；  
xserver将窗口事件发给应用（x Client）；

3. 画图工具通过消息处理函数，调用x的画矩形API，XFillRectangle，将画矩形命令传送给了xserver；

4. xserver接收到画矩形事件，并将事件发给了合成器；

5. 合成器接收到画矩形事件，调用x内置渲染器或者OpenGL等渲染器，完成了渲染，将图形信息转化成像素信息，并合成最后的屏幕图像信息，传递给xserver；

6. xserver将屏幕图像发送给KMS，KMS调用显卡驱动进行显示，显示新的屏幕图像。
</code></pre> 
<p>到这里，我们知道了xserver的架构原理，看上去没啥问题。<br> 但是对比x架构图和下边的Wayland架构图，就会发现，合成器完全可以平移到xserver的位置，而通信架构不变。<br> 啥意思呢？就是xserver是多余的，用合成器取代xserver,是Wayland提效的方法之一。</p> 
<h2><a id="Wayland_39"></a>Wayland协议</h2> 
<p><img src="https://images2.imgbox.com/98/23/UcRcmISc_o.png" alt="image.png"></p> 
<p>在Wayland架构中，xserver的位置被合成器取代了，架构由星型架构（围绕xserver）变成了三层架构（以合成器为中心）；</p> 
<pre><code>1. evdev接收到鼠标事件；

2. 合成器负责转化为窗口事件，并传递给客户端；

3. 客户端调用消息处理函数，
此处，合成器不再提供绘图和渲染命令，也就是不再提供类似XFillRectangle这样的接口函数，而是由客户端调用OpenGL函数，如glDrawElements，来完成画矩形的动作，然后将图像保存到surface结构体中，并调用wl_surface_commit函数通知合成器有图像刷新；  

4. 和x不同的是，Wayland中每个应用都维护一个surface缓存，当窗口需要更新时，通过wl_surface_commit函数通知合成器，合成器会读取surface缓存，合成新的屏幕图像。
</code></pre> 
<p>在Wayland中，合成器只负责合成屏幕图像，而不负责渲染，这是Wayland加速的主要原因：<br> 一者，Wayland取消了xserver作为中心地位的多余通信步骤；<br> 二者，将渲染过程放在客户端处理，相当于并发渲染，而x放在合成器中集中渲染，影响了性能。</p> 
<h2><a id="X_API_58"></a>X API简介</h2> 
<ul><li>窗口管理</li><li>窗口通信</li><li>渲染：2D绘图、文字等</li></ul> 
<p>使用x接口画矩形：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;X11/Xlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Display <span class="token operator">*</span>dpy <span class="token operator">=</span> <span class="token function">XOpenDisplay</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dpy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Cannot open display\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> screen_num <span class="token operator">=</span> <span class="token function">DefaultScreen</span><span class="token punctuation">(</span>dpy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Window root <span class="token operator">=</span> <span class="token function">RootWindow</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> screen_num<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建窗口</span>
    Window win <span class="token operator">=</span> <span class="token function">XCreateSimpleWindow</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                      <span class="token function">BlackPixel</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> screen_num<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                      <span class="token function">WhitePixel</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> screen_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 选择输入事件</span>
    <span class="token function">XSelectInput</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> win<span class="token punctuation">,</span> ButtonPressMask<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 显示窗口</span>
    <span class="token function">XMapWindow</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> win<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取画布</span>
    GC gc <span class="token operator">=</span> <span class="token function">XCreateGC</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> win<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 绘制矩形</span>
    <span class="token function">XSetForeground</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> gc<span class="token punctuation">,</span> <span class="token number">0x00FF00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置颜色</span>
    <span class="token function">XFillRectangle</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> win<span class="token punctuation">,</span> gc<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 处理事件</span>
    XEvent event<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">XNextEvent</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">case</span> ButtonPress<span class="token operator">:</span>
                <span class="token comment">// 点击窗口关闭</span>
                <span class="token function">XCloseDisplay</span><span class="token punctuation">(</span>dpy<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="Wayland_API_113"></a>Wayland API简介</h2> 
<ul><li>窗口管理</li><li>窗口通信</li></ul> 
<p>使用Wayland和OpenGL接口画矩形：</p> 
<pre><code class="prism language-c">todo<span class="token punctuation">.</span>
</code></pre> 
<h2><a id="_123"></a>术语</h2> 
<ul><li>像素：显示器上的最小显示单元（一个LED），不同的显示器像素大小不同；</li><li>显示器：屏幕，由若干显示单元（LED）构成，通过显卡激活显示单元来显示图像。</li><li>显卡：硬件设备，包括 GPU 和显存等组件，支持RGB等图像格式；</li><li>显卡驱动：软件，API库；</li><li>OpenGL：用户级显卡抽象层，提供统一API调用各类显卡驱动。</li><li>KMS(Kernel Mode Setting):内核级显卡驱动抽象层，提供统一的API管理显卡，OpenGL也是调用KMS工作的；</li><li>GPU：显卡的计算单元，用于处理图形渲染等工作；</li><li>渲染：将三维模型数据映射为二维图像，并计算纹理光照等，最终转化为像素信息的过程。渲染器包括Cairo、OpenGL、Vulkun等。</li><li>显存：显卡存储图像数据的地方；</li><li>图片：存储像素信息的文件；</li><li>compositor（合成器）：在x服务器中，合成器的任务包括渲染+屏幕图像合成等部分；在wayland中，合成器包括事件处理+屏幕图像合成等部分；</li><li>x协议：是一套API，应用调用他来实现窗口的管理，包括x服务器和x客户端两部分；</li><li>x-server（x服务器）：x服务器负责处理硬件，包括接收鼠标键盘事件，和控制显示器显示；</li><li>x-client（x客户端）：即GUI应用，比如火狐浏览器、文本编辑器、百度网盘啥啥的；</li><li>wayland：是一套API，应用调用他来实现窗口的管理；</li><li>桌面环境：由窗管+桌面组件+SDK+核心应用组成；</li><li>窗管：窗口管理器，负责创建窗口，移动窗口，显示窗口（包括合成器），多窗口交互等，通过调用X协议或者Wayland协议实现的；</li><li>桌面组件：包括桌面面板，任务栏，开始菜单，任务管理器等；</li><li>SDK：开发工具套件，至少包括一个API库，有的还提供编辑工具，调试工具等；</li><li>桌面核心应用：包括浏览器，多媒体查看器，文本编辑器等；</li><li>evdev：内核级输入设备驱动抽象层，提供统一API管理输入设备；</li><li>GUI（图形用户接口）：通过操作图形来完成指令输入。GUI和图像的区别是，GUI是可交互图形，点了会有反应，图像是静态图片，只能查看，点了不会有反应。</li><li>CLI（文字用户接口）：通过在命令行输入文字来完成指令输入，如bash shell等。</li><li>Shell：用户操作内核的中间件。在Windows和MAC中，Shell既包括图形界面也包括文字界面，因为他们都是在内核中实现的；但是在Linux中，Shell只包括文字界面，不包括图形界面，因为Linux GUI是以软件形态实现的。</li><li>内核：接管所有硬件，提供多任务运行。</li></ul> 
<h2><a id="_151"></a>参考链接</h2> 
<p><a href="https://wayland.freedesktop.org/" rel="nofollow">Wayland 官网</a><br> <a href="https://cloud.tencent.com/developer/article/1442279" rel="nofollow">揭开Wayland的面纱（一）：X Window的前生今世</a><br> <a href="https://cloud.tencent.com/developer/article/1442281" rel="nofollow">揭开Wayland的面纱（二）：Wayland应运而生</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e23cfd4c0f6575f0cc982a8beeb628c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大模型基础02：GPT家族与提示学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba445873105fcf3986ea9dfcb6444781/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 有线网络静态属性配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>