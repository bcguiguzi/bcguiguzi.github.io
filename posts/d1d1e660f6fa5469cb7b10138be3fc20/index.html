<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IPS和WAF区别 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IPS和WAF区别" />
<meta property="og:description" content="写在前面：
“前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。” 前言 - 床长人工智能教程
WAF与IPS的区别总结
谁是最佳选择？
Web应用防护无疑是一个热门话题。由于技术的发展成熟和人们对便利性的期望越来越高，Web应用成为主流的业务系统载体。在Web上“安家”的关键业务系统中蕴藏的数据价值引起攻击者的青睐，网上流传的Web漏洞挖掘和攻击工具让攻击的门槛降低，也使得很多攻击带有盲目和随机性。比如利用GoogleHacking原理的批量查找具有已知漏洞的应用程序，还有SQL批量注入和挂马等。但对于重要的Web应用（比如运营商或金融），始终有受利益驱动的黑客进行持续的跟踪。
如果说传统的“大而全”安全防护产品能抵御大多数由工具产生的攻击行为，那么对于有针对性的攻击行为则力不从心。而WAF正是应需求而生的一款高端专业安全产品，这也是市场需求细化的必然趋势。但由于其部署和功能方面与IPS有类似，有人提出疑问，为什么不能用IPS，或者说WAF与IPS有什么异同？谁更适合保护Web服务器？
这些疑问其实是有道理的，差异化的产生在于高端需求是不同的，从而需要细化功能贴合具体需求和符合应用现状的产品，这也是用户需求是随着业务自身的发展所决定的。
保镖和保安
为了更好的理解两款产品差异性，我们先用这个保镖（WAF）和保安（IPS）比喻来描述。
大楼保安需要对所有进出大楼人员进行检查，一旦发现可疑人员则禁止他入内，但如果混进“貌似忠良”的坏人去撬保险柜等破坏行为，大楼保安是无能为力的。
私人保镖则是指高级别、更“贴身”的保护。他通常只保护特定的人员，所以事先需要理解被保护人的身份、习惯、喜好、作息、弱点等，因为被保护人的工作是需要去面对不同的人，去不同的场合，保镖的职责不能因为危险就阻止、改变他的行为，只能去预见可能的风险，然后量身定做合适的保护方案。
这两种角色的区别在于保安保护的是整个大楼，他不需要也无法知道谁是最需要保护的人，保镖则是明确了被保护对象名单，需要深刻理解被保护人的个性特点。
图 1.1 保镖和保安
通过上面的比喻，大家应该明白两者的之所以会感觉相似是因为职责都是去保护，但差异在于职能定位的不同。从技术原理上则会根据定位来实现。下面通过几个层面来分析WAF和IPS的异同。
事件的时间轴
对于安全事件的发生，有三个时间点：事前、事中、事后。传统的IPS通常只对事中有效，也就是检查和防护攻击事件，其他两个时间点是WAF独有的。
图 1.2 事件时间轴
如上图所示，事前是指能在事件发生之前通过主动扫描检测Web服务器来发现漏洞，通过修复Web服务器漏洞或在前端的防护设备上添加防护规则等积极主动手段来预防事件发生。事后则是指即使Web服务器被攻击了，也必须有网页防篡改功能，让攻击者不能破坏网站数据。
为什么不能具备事中的100%防护能力？其实从以下几个方面就知道对于事中只能做到相对最佳防护而不能绝对，因为：
1. 软件先天是有缺陷的，包括应用到第三方的组件和函数库无法控制其安全性；
2. 应用程序在更新，业务是持续发展的、动态的，如果不持续监控和调整安全策略，也是会有疏漏的；
3. 攻击者永远在暗处，可以对业务系统跟踪研究，查找漏洞和防护缺陷，用各种变形繁杂的手法来探测，并用于攻击；
4. 任何防护设备都难以100%做到没有任何缺陷，无论是各种算法还是规则，都是把攻击影响降低到最小化。
所以需要用一个可闭环又可循环的方式去降低潜在的威胁，对于事中疏漏的攻击，可用事前的预发现和事后的弥补，形成环环相扣的动态安全防护。事前是用扫描方式主动检查网站并把结果形成新的防护规则增加到事中的防护策略中，而事后的防篡改可以保证即使疏漏也让攻击的步伐止于此，不能进一步修改和损坏网站文件，对于要信誉高和完整性的用户来说，这是尤为重要的环节。
图 1.3 WAF安全闭环
如果仅仅是对于事件的时间轴有区别，那么还是可以采用其他产品来进行辅助，但关键的是事中的防护也是有深度的差异，那么下面我们来谈谈对于事中的差异。
事中，也就是实时防护，两者的区别在于一个是纵横度，一个是深度。IPS凸显的优势在于纵横度，也就是对于网络中的所有流量进行监管，它面对的是海量数据，下图的TCP/IP模型中网络流量从物理层到应用层是逐层递交，IPS主要定位在分析传输层和网络层的数据，而再往上则是复杂的各种应用层协议报文，WAF则仅提供对Web应用流量全部层面的监管。　图 1.4 数据结构图
监管层面不同，如果面对同样的攻击，比如SQL注入，它们都是可以防护的，但防护的原理有区别，IPS基本是依靠静态的签名进行识别，也就是攻击特征，这只是一种被动安全模型。如下是一个Snort的告警规则：
alert tcp $EXTERNAL_NET any -&gt; $HTTP_SERVERS $HTTP_PORTS （msg:“SQL Injection - Paranoid”; flow:to_server, established;uricontent:“.asp”;pcre:“/ （\%27）|（\‘）|（\-\-）|（%23）|（#）/i”; classtype:Web-application-attack; sid:9099; rev:5;） 这里主要是检查在SQL注入中提交的元字符，包括单引号（ ’ ）和双横（ – ），从而避免注入’1 or 1=1— 之类的攻击发生，但同时又要考虑这些元字符转换成Hex值来逃脱过滤检查，于是又在规则里增加了其对应的十六进制编码后的字符串。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d1d1e660f6fa5469cb7b10138be3fc20/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-28T08:49:31+08:00" />
<meta property="article:modified_time" content="2022-02-28T08:49:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IPS和WAF区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;">写在前面：</span></p> 
<p><span style="color:#fe2c24;">“前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。”  <a href="https://www.captainbed.net/ellan/" rel="nofollow" title="前言 - 床长人工智能教程">前言 - 床长人工智能教程</a></span></p> 
<p></p> 
<p><a href="https://www.cnblogs.com/milantgh/p/3603127.html" rel="nofollow" id="cb_post_title_url" title="WAF与IPS的区别总结">WAF与IPS的区别总结</a></p> 
<p>谁是最佳选择？</p> 
<p>Web应用防护无疑是一个热门话题。由于技术的发展成熟和人们对便利性的期望越来越高，Web应用成为主流的业务系统载体。在Web上“安家”的关键业务系统中蕴藏的数据价值引起攻击者的青睐，网上流传的Web漏洞挖掘和攻击工具让攻击的门槛降低，也使得很多攻击带有盲目和随机性。比如利用GoogleHacking原理的批量查找具有已知漏洞的应用程序，还有SQL批量注入和挂马等。但对于重要的Web应用（比如运营商或金融），始终有受利益驱动的黑客进行持续的跟踪。</p> 
<p>如果说传统的“大而全”安全防护产品能抵御大多数由工具产生的攻击行为，那么对于有针对性的攻击行为则力不从心。而WAF正是应需求而生的一款高端专业安全产品，这也是市场需求细化的必然趋势。但由于其部署和功能方面与IPS有类似，有人提出疑问，为什么不能用IPS，或者说WAF与IPS有什么异同？谁更适合保护Web服务器？</p> 
<p>这些疑问其实是有道理的，差异化的产生在于高端需求是不同的，从而需要细化功能贴合具体需求和符合应用现状的产品，这也是用户需求是随着业务自身的发展所决定的。</p> 
<p>保镖和保安</p> 
<p>为了更好的理解两款产品差异性，我们先用这个保镖（WAF）和保安（IPS）比喻来描述。</p> 
<p>大楼保安需要对所有进出大楼人员进行检查，一旦发现可疑人员则禁止他入内，但如果混进“貌似忠良”的坏人去撬保险柜等破坏行为，大楼保安是无能为力的。</p> 
<p>私人保镖则是指高级别、更“贴身”的保护。他通常只保护特定的人员，所以事先需要理解被保护人的身份、习惯、喜好、作息、弱点等，因为被保护人的工作是需要去面对不同的人，去不同的场合，保镖的职责不能因为危险就阻止、改变他的行为，只能去预见可能的风险，然后量身定做合适的保护方案。</p> 
<p>这两种角色的区别在于保安保护的是整个大楼，他不需要也无法知道谁是最需要保护的人，保镖则是明确了被保护对象名单，需要深刻理解被保护人的个性特点。</p> 
<p><img alt="" src="https://images2.imgbox.com/df/19/d285fr1e_o.jpg"></p> 
<p>图 1.1 保镖和保安</p> 
<p>通过上面的比喻，大家应该明白两者的之所以会感觉相似是因为职责都是去保护，但差异在于职能定位的不同。从技术原理上则会根据定位来实现。下面通过几个层面来分析WAF和IPS的异同。</p> 
<p>事件的时间轴</p> 
<p>对于安全事件的发生，有三个时间点：事前、事中、事后。传统的IPS通常只对事中有效，也就是检查和防护攻击事件，其他两个时间点是WAF独有的。</p> 
<p><img alt="" src="https://images2.imgbox.com/1f/a2/ZA1J3FlZ_o.png"></p> 
<p>图 1.2 事件时间轴</p> 
<p>如上图所示，事前是指能在事件发生之前通过主动扫描检测Web服务器来发现漏洞，通过修复Web服务器漏洞或在前端的防护设备上添加防护规则等积极主动手段来预防事件发生。事后则是指即使Web服务器被攻击了，也必须有网页防篡改功能，让攻击者不能破坏网站数据。</p> 
<p>为什么不能具备事中的100%防护能力？其实从以下几个方面就知道对于事中只能做到相对最佳防护而不能绝对，因为：</p> 
<p>1. 软件先天是有缺陷的，包括应用到第三方的组件和函数库无法控制其安全性；</p> 
<p>2. 应用程序在更新，业务是持续发展的、动态的，如果不持续监控和调整安全策略，也是会有疏漏的；</p> 
<p>3. 攻击者永远在暗处，可以对业务系统跟踪研究，查找漏洞和防护缺陷，用各种变形繁杂的手法来探测，并用于攻击；</p> 
<p>4. 任何防护设备都难以100%做到没有任何缺陷，无论是各种算法还是规则，都是把攻击影响降低到最小化。</p> 
<p>所以需要用一个可闭环又可循环的方式去降低潜在的威胁，对于事中疏漏的攻击，可用事前的预发现和事后的弥补，形成环环相扣的动态安全防护。事前是用扫描方式主动检查网站并把结果形成新的防护规则增加到事中的防护策略中，而事后的防篡改可以保证即使疏漏也让攻击的步伐止于此，不能进一步修改和损坏网站文件，对于要信誉高和完整性的用户来说，这是尤为重要的环节。</p> 
<p><img alt="" src="https://images2.imgbox.com/20/c7/1SoC1P0D_o.jpg"></p> 
<p>图 1.3 WAF安全闭环</p> 
<p>如果仅仅是对于事件的时间轴有区别，那么还是可以采用其他产品来进行辅助，但关键的是事中的防护也是有深度的差异，那么下面我们来谈谈对于事中的差异。</p> 
<p>事中，也就是实时防护，两者的区别在于一个是纵横度，一个是深度。IPS凸显的优势在于纵横度，也就是对于网络中的所有流量进行监管，它面对的是海量数据，下图的TCP/IP模型中网络流量从物理层到应用层是逐层递交，IPS主要定位在分析传输层和网络层的数据，而再往上则是复杂的各种应用层协议报文，WAF则仅提供对Web应用流量全部层面的监管。　</p> 
<p><img alt="" src="https://images2.imgbox.com/60/1f/neV15Rls_o.png"></p> 
<p>图 1.4 数据结构图</p> 
<p>监管层面不同，如果面对同样的攻击，比如SQL注入，它们都是可以防护的，但防护的原理有区别，IPS基本是依靠静态的签名进行识别，也就是攻击特征，这只是一种被动安全模型。如下是一个Snort的告警规则：</p> 
<pre>alert tcp $EXTERNAL_NET any -&gt; $HTTP_SERVERS $HTTP_PORTS </pre> 
<pre>（msg:“SQL Injection - Paranoid”; flow:to_server,</pre> 
<pre>established;uricontent:“.asp”;pcre:“/</pre> 
<pre>（\%27）|（\‘）|（\-\-）|（%23）|（#）/i”; </pre> 
<pre>classtype:Web-application-attack; sid:9099; rev:5;）</pre> 
<p>这里主要是检查在SQL注入中提交的元字符，包括单引号（ ’ ）和双横（ – ），从而避免注入’1 or 1=1— 之类的攻击发生，但同时又要考虑这些元字符转换成Hex值来逃脱过滤检查，于是又在规则里增加了其对应的十六进制编码后的字符串。</p> 
<p>当然，要从签名特征来识别攻击要考虑的东西还很多，不仅元字符还有SQL关键字，包括：select insert update等，以及这些关键字的大小写变形和拼接，利用注释逃脱过滤，如下所示例：</p> 
<p>使用大小写混杂的字符 ：SeLecT fRom“</p> 
<p>把空格符替换为TAB符或回车符 ：select[TAB]from</p> 
<p>关键词之间使用多个空格 ：select from</p> 
<p>字符串的数值编码 ：0×414141414141 或 0×41004100410041004100</p> 
<p>插入被数据库忽略的注释串 ：sel/**/ect fr/**/om select/**/ from</p> 
<p>使用数据库支持的一些字符串转换功能 ：char（65） 或 chr（65）</p> 
<p>使用数据支持的字符串拼接操作 ：’sel’+'ect ’+'fr’+'om’” 、“‘sel’||’ect ’||’fr’||’om’可以设想一下，如果要检测以上的变形字符后的攻击则需要增加相应的签名特征，但更重要的是要充分考虑转换编码的种类，上面示例的snort的规则把可疑字符以及其转换后的Hex值放入同一条规则里检查，如果对于变形后繁多的攻击种类，这是滞后的并且会造成签名臃肿。</p> 
<p>对于比较粗浅的攻击方式两者都能防护，但市面上大多数IPS是无法对报文编码做多重转换的，所以这将导致攻击者只需构建诸如转换编码、拼接攻击语句、大小写变换等数据包就可绕过输入检查而直接提交给应用程序。</p> 
<p>而这恰恰又是WAF的优势，能对不同的编码方式做强制多重转换还原成攻击明文，把变形后的字符组合后在分析。那为什么IPS不能做到这个程度？同样还有对于HTTPS的加密和解密，这些我们在下节的产品架构中会解释。</p> 
<p>产品架构</p> 
<p>大家知道IPS和WAF通常是串联部署在Web服务器前端，对于服务器和客户端都是透明的，不需要做任何配置，似乎都是一样的组网方式，其实有很大差异。首先我们看看市面主流WAF支持的部署方式：</p> 
<p>1、 桥模式</p> 
<p>2、 路由模式</p> 
<p>3、反向代理</p> 
<p>4、旁路模式（非串联）</p> 
<p>这两者串联部署在Web服务器前端时，市面上的大多数IPS均采用桥模式，而WAF是采用反向代理模式，IPS需要处理网络中所有的流量，而WAF仅处理与Web应用相关的协议，其他的给予转发，如下图：　</p> 
<p>　<img alt="" src="https://images2.imgbox.com/f2/f2/XHGSrR8F_o.png"></p> 
<p>图 1.5 多协议图</p> 
<p>桥模式和反向代理模式的差异在于：桥模式是基于网络层的包转发，基本都没有协议栈，或只能简单的模拟部分协议栈，分析网络报文流量是基于单包的方式，所以要处理分片报文、数据流重组、乱序报文、报文重传、丢包都不具备优势。同时网络流量中包括的协议种类是非常多的，每种应用层协议都有自身独特的协议特征和格式要求，比如Ftp、SSH、Telnet、SMTP等，无法把各种应用流量放到应用层协议栈来处理。</p> 
<p>绿盟科技WAF系统内嵌的协议栈是经过修改和优化的，能完全支持Http应用协议的处理，这意味着必须遵循RFC标准（Internet Requests For Comments）来处理Http报文，包括如下主要RFC：</p> 
<p>◆ RFC 2616 HTTP协议语法的定义</p> 
<p>◆ RFC 2396 URL语法的定义</p> 
<p>◆ RFC 2109 Cookie是怎样工作的</p> 
<p>◆ RFC 1867 HTTP如何POST，以及POST的格式</p> 
<p>RFC中对Http的request行长度、URL长度、协议名称长度、头部值长度等都是有严格要求的，以及传输顺序和应用格式，比如Html参数的要求、Cookie的版本和格式、文件上传的编码 multipart/form-data encoding等，这些应用层内容只能在具有完整应用层协议栈的前提下才可正确识别和控制，对于不完整的丢包，重传包以及伪造的畸形包都会通过协议校验机制来处理。</p> 
<p>上一节提到的WAF对Https的加解密和多重编码方式的解码正是由于报文必须经过应用层协议栈处理。反之，IPS为什么做不到？是由于其自身的桥模式架构，把Http会话”打碎“成多个数据包在网络层分析，而不能完整地从应用层角度来处理和组合多个报文，并且应用层协议繁多，全部去支持也是不现实的，产品的定位并不需要这样。下一节的学习模式更是两者的截然不同的防护机制，而这一机制也是有赖于WAF的产品架构。</p> 
<p>基于学习的主动模式</p> 
<p>在前面谈到IPS的安全模型是应用了静态签名的被动模式，那么反之就是主动模式。WAF的防御模型是两者都支持的，所谓主动模式在于WAF是一个有效验证输入的设备，所有数据流都被校验后再转发给服务器，能增加应用层逻辑组合的规则，更重要的是具备对Web应用程序的主动学习功能。</p> 
<p>学习功能包括：</p> 
<p>1. 监控和学习进出的Web流量，学习链接参数类型和长度、form参数类型和长度等；</p> 
<p>2. 爬虫功能，爬虫主动去分析整个Web站点，并建立正常状态模型；</p> 
<p>3. 扫描功能，主动去扫描并根据结果生成防护规则。</p> 
<p>基于学习的主动模式目的是为了建立一个安全防护模型，一旦行为有差异则可以发现，比如隐藏的表单、限制型的Listbox值是否被篡改、输入的参数类型不合法等，这样在面对多变的攻击手法和未知的攻击类型时能依靠安全防护模型动态调整防护策略。</p> 
<p>结尾</p> 
<p>WAF更多的特性，包括安全交付能力、基于cache的应用加速、挂马检查、抗DDOS攻击、符合PCIDSS的防泄密要求等都表明这是一款不仅能攻击防护，同时又必须在满足客户体验和机密数据防护的高度集成的专业产品。本文仅从产品特征的对比角度来分析了WAF的部分技术原理，但没否定IPS的价值，毕竟两者在部署场景和功能上具有很大差异。</p> 
<p>摘自：http://hi.baidu.com/wenglsqs/item/dcac0c18e1201addbe90420a</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f4a7ce560bd6e6c46a6be50896a134c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">排序算法——快速排序（Quicksort）基准值的三种选取和优化方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f566500e981f7417f38b7ba9009a565f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">游戏业务被攻击了怎么办</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>