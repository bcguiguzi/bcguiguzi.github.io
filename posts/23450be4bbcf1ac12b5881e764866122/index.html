<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6中的Object、apply、call - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6中的Object、apply、call" />
<meta property="og:description" content="// 将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
const target = {a: 1, b: 2}
const source = {b: 4, c: 5}
const returnedTarget = Object.assign(target, source)
// output: Object { a: 1, b: 4, c: 5 }
console.log(target)
// output: Object { a: 1, b: 4, c: 5 }
console.log(returnedTarget)
// 浅拷贝复制对象 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用
const obj = {a: 1}
const copy = Object.assign({}, obj)
// { a: 1 }
console.log(copy)
// 合并对象
const o1 = {a: 1}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/23450be4bbcf1ac12b5881e764866122/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T09:14:02+08:00" />
<meta property="article:modified_time" content="2024-03-12T09:14:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6中的Object、apply、call</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>// 将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br>       const target = {a: 1, b: 2}<br>       const source = {b: 4, c: 5}<br>       const returnedTarget = Object.assign(target, source)<br>       // output: Object { a: 1, b: 4, c: 5 }<br>       console.log(target)<br>       // output: Object { a: 1, b: 4, c: 5 }<br>       console.log(returnedTarget)</p> 
<p>      // 浅拷贝复制对象 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用<br>       const obj = {a: 1}<br>       const copy = Object.assign({}, obj)<br>       // { a: 1 }<br>       console.log(copy)</p> 
<p>      // 合并对象<br>       const o1 = {a: 1}<br>       const o2 = {b: 2}<br>       const o3 = {c: 3}<br>       const obj1 = Object.assign(o1, o2, o3)<br>       console.log(obj1) // { a: 1, b: 2, c: 3 }<br>       console.log(o1)  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。</p> 
<p>      // 合并具有相同属性的对象<br>       const o11 = {a: 1, b: 1, c: 1}<br>       const o22 = {b: 2, c: 2}<br>       const o33 = {c: 3}</p> 
<p>      const obj2 = Object.assign({}, o11, o22, o33)<br>       console.log(obj2) // { a: 1, b: 2, c: 3 }</p> 
<p>      // 创建一个新对象<br>       const person = {<!-- --><br>         isHuman: false,<br>         printIntroduction: function () {<!-- --><br>           console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`)<br>         }<br>       }<br>       const me = Object.create(person)<br>       me.name = 'Matthew' // "name" is a property set on "me", but not on "person"<br>       me.isHuman = true // inherited properties can be overwritten<br>       me.printIntroduction()</p> 
<p>      // entries返回一个给定对象自身可枚举属性的键值对数组<br>       const obj = {<!-- --><br>         a: 'somestring',<br>         b: 42<br>       }<br>       for (let [key, value] of Object.entries(obj)) {<!-- --><br>         console.log(`${key}: ${value}`)<br>       }<br>       console.log(obj)</p> 
<p>      // 可以将 Map 转化为 Object<br>       const map = new Map([['foo', 'bar'], ['baz', 42]])<br>       const obj = Object.fromEntries(map)<br>       // { foo: "bar", baz: 42 }<br>       console.log(obj)</p> 
<p>      // 可以将 Array 转化为 Object<br>       const arr = [['0', 'a'], ['1', 'b'], ['2', 'c']]<br>       const obj2 = Object.fromEntries(arr)<br>       // { 0: "a", 1: "b", 2: "c" }<br>       console.log(obj2)</p> 
<p>      const obj = {<!-- --><br>         prop: 42<br>       }<br>       // 被冻结的对象再也不能被修改 不能向这个对象添加新的属性，不能删除已有属性，<br>       // 不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。<br>       // 此外，冻结一个对象后该对象的原型也不能被修改 freeze() 返回和传入的参数相同的对象<br>       Object.freeze(obj)<br>       obj.prop = 33<br>       console.log(obj.prop)</p> 
<p>      // 判断两个值是否是相同的值<br>       let l = Object.is('foo', 'foo')<br>       console.log(l)</p> 
<p>      // simple array<br>       var arr = ['a', 'b', 'c']<br>       console.log(Object.keys(arr)) // console: ['0', '1', '2']</p> 
<p>      // array like object<br>       var obj = {0: 'a', 1: 'b', 2: 'c'}<br>       console.log(Object.keys(obj)) // console: ['0', '1', '2']</p> 
<p>      // array like object with random key ordering<br>       var anObj = {100: 'a', 2: 'b', 7: 'c'}<br>       console.log(Object.keys(anObj)) // console: ['2', '7', '100']</p> 
<p>      var obj = {foo: 'bar', baz: 42}<br>       console.log(Object.values(obj)) // ['bar', 42]</p> 
<p>      // array like object<br>       var obj = {0: 'a', 1: 'b', 2: 'c'}<br>       console.log(Object.values(obj)) // ['a', 'b', 'c']</p> 
<p>      // array like object with random key ordering<br>       // when we use numeric keys, the value returned in a numerical order according to the keys<br>       var an_obj = {100: 'a', 2: 'b', 7: 'c'}<br>       console.log(Object.values(an_obj)) // ['b', 'c', 'a']</p> 
<p>      // valueOf() 方法返回指定对象的原始值<br>       // Array：返回数组对象本身<br>       let array = ['ABC', true, 12, -5]<br>       // true<br>       console.log(array.valueOf() === array)</p> 
<p>      // Date：当前时间距1970年1月1日午夜的毫秒数<br>       let date = new Date(2013, 7, 18, 23, 11, 59, 230)<br>       // 1376838719230<br>       console.log(date.valueOf())</p> 
<p>      // Number：返回数字值<br>       let num = 15.26540<br>       // 15.2654<br>       console.log(num.valueOf())</p> 
<p>      // 布尔：返回布尔值true或false<br>       let bool = true<br>       // true<br>       console.log(bool.valueOf() === bool)</p> 
<p>      // new一个Boolean对象<br>       let newBool = new Boolean(true)<br>       // valueOf()返回的是true，两者的值相等<br>       // true<br>       console.log(newBool.valueOf() == newBool)<br>       // 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型<br>       // false<br>       console.log(newBool.valueOf() === newBool)</p> 
<p>      /**<br>        * apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br>        * call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组<br>        **/<br>       var numbers = [5, 6, 2, 3, 7]<br>       var max = Math.max.apply(null, numbers)<br>       console.log(max)<br>       var min = Math.min.apply(null, numbers)<br>       console.log(min)</p> 
<p>      // 用 apply 将数组添加到另一个数组<br>       var array = ['a', 'b']<br>       var elements = [0, 1, 2]<br>       array.push.apply(array, elements)<br>       console.info(array) // ["a", "b", 0, 1, 2]</p> 
<p>      /**<br>        * 使用 call 方法调用父构造函数<br>        * */<br>       function Product(name, price) {<!-- --><br>         this.name = name<br>         this.price = price<br>       }</p> 
<p>      function Food(name, price) {<!-- --><br>         Product.call(this, name, price)<br>         this.category = 'food'<br>       }</p> 
<p>      function Toy(name, price) {<!-- --><br>         Product.call(this, name, price)<br>         this.category = 'toy'<br>       }</p> 
<p>      var cheese = new Food('feta', 5)<br>       var fun = new Toy('robot', 40)<br>       console.log(cheese)<br>       console.log(fun)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c3c3ee1476ca9653acc50d403294daf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ELK 安装部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cacda95ddc49cced197ae5b61ebb5a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第 5 章 ROS多坐标系关系查看(自学二刷笔记)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>