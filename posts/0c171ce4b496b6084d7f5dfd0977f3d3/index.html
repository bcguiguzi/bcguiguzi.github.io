<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【图像处理matlab】PCA&#43;KNN人脸识别 ORL人脸数据集 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【图像处理matlab】PCA&#43;KNN人脸识别 ORL人脸数据集" />
<meta property="og:description" content="文章目录 0.写在前面1. 数据集导入与划分2. train-PCA构建脸空间2.1 原始数据导入2.2 去中心化2.3 求解协方差矩阵、特征值、特征向量2.4 特征脸选取--脸空间 3. test-物以类聚 KNN分类3.1 KNN简介3.2 KNN实现步骤3.2.1 距离度量---欧式距离、豪斯多夫距离.......3.2.2 k值选择3.2.3 “投票”预测分类 4. 结果分析5. matlab代码实现参考 0.写在前面 本实验使用ORL数据集中的前100张人脸图像进行
实验整体思路为：
PCA数据降维，使用train图片计算映射脸空间，以实现将每张人脸的二维灰度图矩阵降维至一维的点欧式距离，求出某张映射后test图片到所有映射后train图片的欧式距离KNN分类，2步骤求出的所有距离值升序排列，取最小前k个（k自定义），出现频数最多的label为test图片的预测类别验证并计算准确率 1. 数据集导入与划分 首先应明确以下几点：
数据集大小为100每行10张，为一个人的全部图像。共10人数据集的60%为训练集，40%为测试集。以实现交叉验证
接着：按照上图的排序对100张图片进行编号每个人对应label标签1-10每个人的前6张作为train训练集，后4张作为test测试集 经上述步骤，可将数据集结构抽象为下表：
接下来基于上表结构，介绍如何使用matlab实现数据集的导入与划分
导入 （1）dir函数
dataset=dir（‘path\ *.类型’）以读取指定文件夹path下的指定类型的全部文件 实验中图片均为.bmp格式，使用如下语句获取每张图片的信息：
list_names=dir(&#39;C:\Users\ZKX\Desktop\ORL_100\*.bmp&#39;) 得到一个100*1的结构体，记录了每张图片的如下信息
创建以下变量
img_num：记录数据集大小folder：记录存储数据集文件夹路径 方便后续imread的导入
img_num = length(list_names);% 文件夹中图像的个数 folder=list_names.folder （2）imread函数
imread（‘path\文件名’）以读取指定图片 其中：
1）path由上一步folder获得
2）文件名由上一步结构体变量list_names(idx).name获得
3）idx下标范围为1-数据集大小img_num
在matlab中使用[str1,str2,…]进行字符串拼接，故每张图片imread路径可表示为：‘path\文件名’=[folder,’ \ &#39;，list_names(idx).name]
构造DB矩阵存储所有图片的灰度值矩阵，可通过如下语句实现：
DB= zeros(112,92,img_num); for idx = 1:img_num DB(:,:,idx) =imread([folder,&#39;\&#39;,list_names(idx).name]);%读取图像数据,类似构建mat矩阵 end DB = reshape(DB, 112*92,100); 查看用于存储100张图片灰度值的变量DB" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0c171ce4b496b6084d7f5dfd0977f3d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-18T12:24:07+08:00" />
<meta property="article:modified_time" content="2022-11-18T12:24:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【图像处理matlab】PCA&#43;KNN人脸识别 ORL人脸数据集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#0_1" rel="nofollow">0.写在前面</a></li><li><a href="#1__10" rel="nofollow">1. 数据集导入与划分</a></li><li><a href="#2_trainPCA_105" rel="nofollow">2. train-PCA构建脸空间</a></li><li><ul><li><a href="#21__121" rel="nofollow">2.1 原始数据导入</a></li><li><a href="#22__126" rel="nofollow">2.2 去中心化</a></li><li><a href="#23__141" rel="nofollow">2.3 求解协方差矩阵、特征值、特征向量</a></li><li><a href="#24__146" rel="nofollow">2.4 特征脸选取--脸空间</a></li></ul> 
    </li><li><a href="#3_test_KNN_170" rel="nofollow">3. test-物以类聚 KNN分类</a></li><li><ul><li><a href="#31_KNN_180" rel="nofollow">3.1 KNN简介</a></li><li><a href="#32_KNN_182" rel="nofollow">3.2 KNN实现步骤</a></li><li><ul><li><a href="#321__186" rel="nofollow">3.2.1 距离度量---欧式距离、豪斯多夫距离.......</a></li><li><a href="#322_k_191" rel="nofollow">3.2.2 k值选择</a></li><li><a href="#323__214" rel="nofollow">3.2.3 “投票”预测分类</a></li></ul> 
    </li></ul> 
    </li><li><a href="#4__230" rel="nofollow">4. 结果分析</a></li><li><a href="#5_matlab_270" rel="nofollow">5. matlab代码实现</a></li><li><a href="#_485" rel="nofollow">参考</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="0_1"></a>0.写在前面</h4> 
<p>本实验使用ORL数据集中的前100张人脸图像进行</p> 
<p>实验整体思路为：</p> 
<ol><li>PCA数据降维，使用train图片计算映射脸空间，以实现将每张人脸的二维灰度图矩阵降维至一维的点</li><li>欧式距离，求出某张映射后test图片到所有映射后train图片的欧式距离</li><li>KNN分类，2步骤求出的所有距离值升序排列，取最小前k个（k自定义），出现频数最多的label为test图片的预测类别</li><li>验证并计算准确率</li></ol> 
<h4><a id="1__10"></a>1. 数据集导入与划分</h4> 
<p>首先应明确以下几点：</p> 
<ul><li>数据集大小为100</li><li>每行10张，为一个人的全部图像。共10人</li><li>数据集的60%为训练集，40%为测试集。以实现<a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/8543100" rel="nofollow">交叉验证</a><br> <img src="https://images2.imgbox.com/6d/bc/7e3KcmAW_o.png" alt="ORL人脸数据集"><br> 接着：</li><li>按照上图的排序对100张图片进行编号</li><li>每个人对应label标签1-10</li><li>每个人的前6张作为train训练集，后4张作为test测试集</li></ul> 
<p>经上述步骤，可将数据集结构抽象为下表：</p> 
<p><img src="https://images2.imgbox.com/56/74/k4JgLrkj_o.png" alt="数据集的划分"></p> 
<p>接下来基于上表结构，介绍如何使用matlab实现数据集的导入与划分</p> 
<ol><li>导入</li></ol> 
<ul><li>（1）dir函数<br> dataset=dir（‘path\ *.类型’）以读取指定文件夹path下的指定类型的全部文件</li></ul> 
<p>实验中图片均为.bmp格式，使用如下语句获取每张图片的信息：</p> 
<pre><code class="prism language-c">list_names<span class="token operator">=</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token char">'C:\Users\ZKX\Desktop\ORL_100\*.bmp'</span><span class="token punctuation">)</span> 
</code></pre> 
<p>得到一个100*1的结构体，记录了每张图片的如下信息<br> <img src="https://images2.imgbox.com/1f/38/nbvjtjWh_o.png" alt="在这里插入图片描述"><br> 创建以下变量</p> 
<ul><li>img_num：记录数据集大小</li><li>folder：记录存储数据集文件夹路径</li></ul> 
<p>方便后续imread的导入</p> 
<pre><code class="prism language-c">img_num <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>list_names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span> 文件夹中图像的个数
folder<span class="token operator">=</span>list_names<span class="token punctuation">.</span>folder
</code></pre> 
<ul><li>（2）imread函数<br> imread（‘path\文件名’）以读取指定图片</li></ul> 
<p>其中：</p> 
<p>1）path由上一步folder获得<br> 2）文件名由上一步结构体变量list_names(idx).name获得<br> 3）idx下标范围为1-数据集大小img_num</p> 
<p>在matlab中使用[str1,str2,…]进行字符串拼接，故每张图片imread路径可表示为：‘path\文件名’=[folder,’ \ '，list_names(idx).name]</p> 
<p>构造DB矩阵存储所有图片的灰度值矩阵，可通过如下语句实现：</p> 
<pre><code class="prism language-c">DB<span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">92</span><span class="token punctuation">,</span>img_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span>img_num
    <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span>idx<span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>folder<span class="token punctuation">,</span>'\'<span class="token punctuation">,</span><span class="token function">list_names</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span>读取图像数据<span class="token punctuation">,</span>类似构建mat矩阵
end

DB <span class="token operator">=</span> <span class="token function">reshape</span><span class="token punctuation">(</span>DB<span class="token punctuation">,</span> <span class="token number">112</span><span class="token operator">*</span><span class="token number">92</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>查看用于存储100张图片灰度值的变量DB<br> <img src="https://images2.imgbox.com/15/a6/rSlnSNnd_o.png" alt="在这里插入图片描述"></p> 
<ul><li>像素数：10304= heigh * weigh=112 * 92</li><li>图像总数:100张</li></ul> 
<ol start="2"><li>划分<br> <img src="https://images2.imgbox.com/3e/70/v1yi75CZ_o.png" alt="下标分布"></li></ol> 
<p>观察发现：<br> 训练集图片的下标以1、2、3、4、5、6结尾<br> 测试集图片的下标以7、8、9、0结尾</p> 
<p>数学归纳为：<br> test_data_index = 10* i+1:10* i+4<br> train_data_index =10* i+5:10* (i+1)</p> 
<p>得到下标后，创建test_data、train_data ，利用下标读取DB进行划分存储。具体代码实现为：</p> 
<pre><code class="prism language-c"><span class="token operator">%</span><span class="token operator">%</span> train与test划分

<span class="token operator">%</span> 取出前<span class="token number">40</span><span class="token operator">%</span>作为测试数据，剩下<span class="token number">60</span><span class="token operator">%</span>作为训练数据
test_data_index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
train_data_index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token operator">%</span>记录测试集和训练集的下标
<span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">9</span>
    test_data_index <span class="token operator">=</span> <span class="token punctuation">[</span>test_data_index <span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    train_data_index <span class="token operator">=</span> <span class="token punctuation">[</span>train_data_index <span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
end

test_data <span class="token operator">=</span> <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> test_data_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
train_data <span class="token operator">=</span> <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>train_data_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="2_trainPCA_105"></a>2. train-PCA构建脸空间</h4> 
<p><font face="STCAIYUN">应明确PCA求解脸空间只是对train训练集的操作</font></p> 
<p>首先回忆PCA算法步骤</p> 
<pre><code>S1：原始样本数据获取
S2：去中心化
S3：求解协方差矩阵
S4: 求取协方差矩阵的特征值和特征向量
S5 :排列特征值，最大特征值作为主成分w
S6：将特征值最大的d个向量作为投影向量，构成d*d维的投影矩阵W，
	对于任意维样本，将其投影选取的特征向量（主成分方向）上。
</code></pre> 
<p>接下来对应上述步骤进行图像处理</p> 
<h5><a id="21__121"></a>2.1 原始数据导入</h5> 
<p>该步骤在上一节已经实现，现使用imshow函数测试部分导入图片显示是否正常</p> 
<p>显示结果如下：<br> <img src="https://images2.imgbox.com/8c/ce/qehkee5Z_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="22__126"></a>2.2 去中心化</h5> 
<ul><li> <p>求平均脸</p> <p>这里需明确，平均脸是对整个<code>train</code>求平均，最终得到一个10304x1的矩阵mean_face，以记录平均脸各像素点的灰度值。<br> <img src="https://images2.imgbox.com/8e/d8/uY5VNc6z_o.png" alt="在这里插入图片描述"><br> 平均脸展示：<br> <img src="https://images2.imgbox.com/fa/4e/6NF4oGTP_o.png" alt="在这里插入图片描述"><br> 可以看到，平均脸只能看出大致的人脸轮廓，而面部细节十分模糊</p> </li><li> <p>去中心化<br> 将train中的原始图片减去平均脸，也就是将train_data的每个列向量都减去列向量mean_face，得到去中心化的列向量centered_face<br> <img src="https://images2.imgbox.com/b9/1f/jQlyIx4P_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/6b/14/qfwALb4g_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5f/f8/YjAbHY7J_o.png" alt="在这里插入图片描述"><br> 将centered_face用imshow函数显示就是去中心化的人脸。由于每张图像都在原始灰度值的基础上减去了平均值，图像整体灰度值较原始降低，直观感受就是图片变暗。<br> 去中心化脸展示：<br> <img src="https://images2.imgbox.com/ec/9c/n4GGyGkO_o.png" alt="部分去中心化脸展示"></p> </li></ul> 
<h5><a id="23__141"></a>2.3 求解协方差矩阵、特征值、特征向量</h5> 
<p>数学知识，略<br> <img src="https://images2.imgbox.com/bd/f0/B7pl8MEs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c5/72/stel1rCf_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="24__146"></a>2.4 特征脸选取–脸空间</h5> 
<p>首先应明确<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E8%84%B8/15618441" rel="nofollow">特征脸</a>的概念。特征脸就是一组特征向量的线性组合，<code>特征量组数少的特征脸计算量少，特征量组数大的特征脸保留了更多的有效信息</code>，权衡二者权重，实现在尽量保留图像原始信息的情况下降低计算量。<br> 重构的特征脸就是Y=W*X中的W,即投影矩阵，在这里称为脸空间。</p> 
<p>代码中的all_eigen_face代表所有的特征向量，也就是sorted_eigen_vectors<br> <img src="https://images2.imgbox.com/5e/f3/ZZaAEa3I_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/b7/zaoxgBaP_o.png" alt="在这里插入图片描述"></p> 
<p>eigen_faces在实验中是分别选取10、20、30、·······100个特征值进行重构<br> <img src="https://images2.imgbox.com/b8/c9/XokABdmv_o.png" alt="在这里插入图片描述"></p> 
<p>将经过降序排序处理后的特征值sorted_eigen_vectors的前100个取出后发现：idx==60之后的数值已经小到可以忽略。即前60个特征量之和已接近总特征量之和，故使用前60个特征值重构的特征脸已经几乎接近原图。</p> 
<p><img src="https://images2.imgbox.com/34/2e/bVe2hK6K_o.png" alt="在这里插入图片描述"><br> 下图展示分别选取10、20、30、······100个特征值重构的特征脸，直观感受是：<code>随着特征量的增加，重构特征脸的细节越清晰</code>。<img src="https://images2.imgbox.com/c8/22/OFUbySrm_o.png" alt="不同特征值的特征脸选取"></p> 
<p>到这里，实验已经实现了使用train计算映射脸空间，接下来要对test进行分类识别并计算分类正确率。</p> 
<p>步骤为：</p> 
<ol><li>将100张人脸投影到脸空间中进行<strong>降维</strong>，将每张人脸的二维灰度值矩阵降至一维的一个点</li><li><strong>欧几里得距离</strong>计算未知人脸（test中单张）与所有已知人脸（train全部）的距离</li><li><strong>KNN</strong>分类预测标签</li></ol> 
<p>PCA选取特征脸部分介绍推荐该文：<a href="https://blog.csdn.net/qq_42037746/article/details/92214532?spm=1001.2014.3001.5506">PCA实现人脸识别</a></p> 
<h4><a id="3_test_KNN_170"></a>3. test-物以类聚 KNN分类</h4> 
<p>首先了解一下大致分类：<br> <a href="https://blog.csdn.net/DIPDWC/article/details/111687797">机器学习与深度学习——关系、无/半/有监督学习、差异、主流框架</a><br> <img src="https://images2.imgbox.com/8d/40/9mByDsoU_o.png" alt="在这里插入图片描述"></p> 
<p>本实验对测试集的分类是使用有监督学习的KNN分类算法</p> 
<p>有监督学习的主要特性是使用大量有标签的训练数据来建立模型，以预测新的未知标签的数据</p> 
<p>该特性在实验KNN分类中体现为：使用训练数据计算脸空间后将全体数据降维，计算单个test最近的k个train，k个train中标签出现频数最多的为该test预测标签</p> 
<h5><a id="31_KNN_180"></a>3.1 KNN简介</h5> 
<p>算法的核心思想为：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，就把该输入实例分类到这个类中</p> 
<h5><a id="32_KNN_182"></a>3.2 KNN实现步骤</h5> 
<p>影响KNN分类结果的因素有：</p> 
<ul><li>距离公式的选取</li><li>k值的选取</li></ul> 
<h6><a id="321__186"></a>3.2.1 距离度量—欧式距离、豪斯多夫距离…</h6> 
<p>本实验使用欧式距离，因为已经降维至坐标点，用初中学到的两点间距离公式即可：<br> <img src="https://images2.imgbox.com/04/46/eyVJVnfE_o.png" alt="在这里插入图片描述"><br> <a href="https://blog.csdn.net/ziyubiti/article/details/48316425">其他高端的距离公式</a></p> 
<h6><a id="322_k_191"></a>3.2.2 k值选择</h6> 
<p>KNN算法选取过小的k值,会使得模型变得复杂,容易过拟合,学习到的类别一般是噪声点,当选择过大的k值,会使得模型变得简单,相当于模型没有进行训练,可以理解为欠拟合。</p> 
<blockquote> 
 <p>KNN算法中是根据通过实验调参来得到,李航老师书上讲到，我们一般选取一个较小的数值，通常采取交叉验证法来选取最优的k值.</p> 
</blockquote> 
<p><code>总结以上两段废话，k值选择可以摆烂凭经验（xs），或是在设置k值前沐浴焚香更衣</code><br> <code>阿弥</code></p> 
<p><a href="https://blog.csdn.net/weixin_42234472/article/details/85062142">k值选择影响/估计误差/近似误差介绍</a></p> 
<p>接下来用下图实例分析一下为什么不同的k值会对分类结果产生影响</p> 
<p><img src="https://images2.imgbox.com/32/e3/QngmvPVr_o.png" alt="K值不同分类结果可能不同"><br> 珍珠预测小绿的类别<br> <img src="https://images2.imgbox.com/2d/5b/0JK4Wi6d_o.png" alt="在这里插入图片描述"></p> 
<ul><li>当k=3时<br> 距小绿最近的3个登西为：1小蓝+2小红<br> 故此时小绿一眼顶真为小红</li><li>当k=5时<br> 距小绿最近的5个登西为：3小蓝+2小红<br> 此时小绿跳小蓝</li></ul> 
<h6><a id="323__214"></a>3.2.3 “投票”预测分类</h6> 
<p>涉及到一个标签与下标的转化，再度拿出让我蠢蠢欲动的结构图<br> <img src="https://images2.imgbox.com/44/4a/kwYqkuxo_o.png" alt="在这里插入图片描述"><br> 用仅有的小学数学知识推导下标与label的关系：</p> 
<pre><code class="prism language-c">  real_label <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">test_data_index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>each_test_face_index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>最后用mode函数看k中出现最多的标签作为预测便签</p> 
<pre><code class="prism language-cpp">  predict_label <span class="token operator">=</span> <span class="token function">mode</span><span class="token punctuation">(</span>label_of_minimun_k_values<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>结束捏<br> <img src="https://images2.imgbox.com/bf/f3/1LGL26gG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4__230"></a>4. 结果分析</h4> 
<p>测试条件：</p> 
<ul><li>特征脸：特征量选择在[0，100]，步长为10</li><li>k：基于每轮特征脸，k值选择在[1,6]，步长为1</li></ul> 
<p>测试输出：</p> 
<ul><li> <p>对于每个样本<br> 将预测标签（KNN分类获得）的值与实际标签（自身下标转化）的值进行判断。</p> <p>若相等，输出：预测值：label，实际值:label，正确<br> 并将记录正确分类数目的correct_predict_number 加1</p> <p>若不等，输出：预测值：label，实际值:label，错误</p> </li></ul> 
<p>代码实现如下：</p> 
<pre><code class="prism language-c">   <span class="token keyword">if</span> <span class="token punctuation">(</span>predict_label <span class="token operator">==</span> real_label<span class="token punctuation">)</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"预测值：%d，实际值:%d，正确\n"</span><span class="token punctuation">,</span>predict_label<span class="token punctuation">,</span>real_label<span class="token punctuation">)</span><span class="token punctuation">;</span>
                correct_predict_number <span class="token operator">=</span> correct_predict_number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"预测值：%d，实际值:%d，错误\n"</span><span class="token punctuation">,</span>predict_label<span class="token punctuation">,</span>real_label<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在命令行中显示为：<br> <img src="https://images2.imgbox.com/0f/5d/ULHL9dzS_o.png" alt="在这里插入图片描述"></p> 
<ul><li>每轮内循环输出<br> 特征量固定，即特征脸确定的情况下输出6个k值的预测结果。输出包括：总测试量、正确数、正确率的信息。</li></ul> 
<pre><code class="prism language-c">   <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"k=%d，numOfeig=%d，总测试样本：%d，正确数:%d，正确率：%1f \n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">,</span>test_face_number<span class="token punctuation">,</span>correct_predict_number<span class="token punctuation">,</span>correct_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当特征值分别选为80、90两轮循环的结果在命令行中显示为：</p> 
<p><img src="https://images2.imgbox.com/27/f8/81cY2ncp_o.png" alt="在这里插入图片描述"></p> 
<p>全过程可视化结果展示：<br> <img src="https://images2.imgbox.com/b1/de/vKyqqVqe_o.png" alt=""></p> 
<h4><a id="5_matlab_270"></a>5. matlab代码实现</h4> 
<pre><code class="prism language-c">clear all<span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token operator">%</span> 数据导入
list_names<span class="token operator">=</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token char">'C:\Users\ZKX\Desktop\ORL_100\*.bmp'</span><span class="token punctuation">)</span> 
img_num <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>list_names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span> 文件夹中图像的个数
folder<span class="token operator">=</span>list_names<span class="token punctuation">.</span>folder

DB<span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">92</span><span class="token punctuation">,</span>img_num<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span>img_num
    <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span>idx<span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>folder<span class="token punctuation">,</span>'\'<span class="token punctuation">,</span><span class="token function">list_names</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span>读取图像数据<span class="token punctuation">,</span>类似构建mat矩阵
end

DB <span class="token operator">=</span> <span class="token function">reshape</span><span class="token punctuation">(</span>DB<span class="token punctuation">,</span> <span class="token number">112</span><span class="token operator">*</span><span class="token number">92</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token operator">%</span> train与test划分

<span class="token operator">%</span> 取出前<span class="token number">40</span><span class="token operator">%</span>作为测试数据，剩下<span class="token number">60</span><span class="token operator">%</span>作为训练数据
test_data_index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
train_data_index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token operator">%</span>记录测试集和训练集的下标
<span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">9</span>
    test_data_index <span class="token operator">=</span> <span class="token punctuation">[</span>test_data_index <span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    train_data_index <span class="token operator">=</span> <span class="token punctuation">[</span>train_data_index <span class="token number">10</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
end

test_data <span class="token operator">=</span> <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> test_data_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
train_data <span class="token operator">=</span> <span class="token function">DB</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>train_data_index<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">waitfor</span><span class="token punctuation">(</span><span class="token function">show_faces</span><span class="token punctuation">(</span>train_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token operator">%</span><span class="token operator">%</span> PCA算法实现

<span class="token operator">%</span> S1：去中心化

<span class="token operator">%</span>   <span class="token number">1</span>）求所有图像各像素点的平均值，即平均脸
mean_face <span class="token operator">=</span> <span class="token function">mean</span><span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span>计算出的是h<span class="token operator">*</span>w的一张图，即平均脸
<span class="token function">waitfor</span><span class="token punctuation">(</span><span class="token function">show_face</span><span class="token punctuation">(</span>mean_face<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span>   <span class="token number">2</span><span class="token punctuation">)</span> 原始数据<span class="token operator">-</span>mean，中心化每一列是一个一张图
centered_face <span class="token operator">=</span> <span class="token punctuation">(</span>train_data <span class="token operator">-</span> mean_face<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">waitfor</span><span class="token punctuation">(</span><span class="token function">show_faces</span><span class="token punctuation">(</span>centered_face<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span> S2<span class="token operator">:</span> 协方差矩阵的特征值与特征向量
<span class="token operator">%</span>   <span class="token number">1</span>）cov协方差矩阵
cov_matrix <span class="token operator">=</span> centered_face <span class="token operator">*</span> centered_face'<span class="token punctuation">;</span>
<span class="token punctuation">[</span>eigen_vectors<span class="token punctuation">,</span> dianogol_matrix<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">eig</span><span class="token punctuation">(</span>cov_matrix<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span>   <span class="token number">2</span>）特征值
eigen_values <span class="token operator">=</span> <span class="token function">diag</span><span class="token punctuation">(</span>dianogol_matrix<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span>   特征值降序排序，获得取特征值及其对应索引
<span class="token punctuation">[</span>sorted_eigen_values<span class="token punctuation">,</span> index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sort</span><span class="token punctuation">(</span>eigen_values<span class="token punctuation">,</span> <span class="token char">'descend'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token operator">%</span>   <span class="token number">3</span>）特征向量
sorted_eigen_vectors <span class="token operator">=</span> <span class="token function">eigen_vectors</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token operator">%</span> 特征脸<span class="token punctuation">(</span>所有）

all_eigen_faces <span class="token operator">=</span> sorted_eigen_vectors<span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token operator">%</span> 特征脸选取

    <span class="token operator">%</span>根据自己设定percent选出特征脸
    <span class="token operator">%</span>根据选取特征量的数量构造特征脸
    
    <span class="token operator">%</span>选出的特征脸就是W 
    <span class="token operator">%</span>w<span class="token operator">*</span>x就是映射到脸空间
    
    <span class="token operator">%</span>正确的

<span class="token operator">%</span>取出第一张人脸，使用不同数量的特征向量进行重构
single_face <span class="token operator">=</span> <span class="token function">centered_face</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token operator">%</span>下图是分别在<span class="token number">10</span>，<span class="token number">20</span>，<span class="token number">30</span>，…，<span class="token number">100</span>数量的特征向量下重构的人脸。
<span class="token operator">%</span>从直观上可以看出随着特征向量数量的增加，重构出的人脸越来越清晰。
<span class="token operator">%</span>这是因为使用越多的特征向量进行人脸重构，丢失的信息越少，因此重构出的人脸更加清晰。

numOfeig <span class="token operator">=</span> <span class="token number">100</span>   <span class="token operator">%</span>特征值的数量

<span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">:</span>numOfeig

    <span class="token operator">%</span> 取出相应数量特征脸
    eigen_faces <span class="token operator">=</span> <span class="token function">all_eigen_faces</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">%</span> 重建人脸并显示
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        rebuild_faces <span class="token operator">=</span> eigen_faces <span class="token operator">*</span> <span class="token punctuation">(</span>eigen_faces' <span class="token operator">*</span> single_face<span class="token punctuation">)</span> <span class="token operator">+</span> mean_face<span class="token punctuation">;</span>
        <span class="token operator">%</span><span class="token operator">%</span><span class="token operator">%</span>
        <span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        fig <span class="token operator">=</span> <span class="token function">show_face</span><span class="token punctuation">(</span>rebuild_faces<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">title</span><span class="token punctuation">(</span><span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"i=%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    

        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span>
            <span class="token function">waitfor</span><span class="token punctuation">(</span>fig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        end
    end

 <span class="token operator">%</span><span class="token operator">%</span> 测试、训练数据降维

 <span class="token operator">%</span>计算不同数量特征向量下，人脸的识别准确度
 <span class="token operator">%</span> <span class="token number">1</span>）Y<span class="token operator">=</span>W<span class="token operator">*</span>X进行脸空间的映射
 <span class="token operator">%</span> <span class="token number">2</span>）使用欧式距离计算test与已知脸的距离
 <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span> 使用最近邻分类器KNN进行识别
 

 <span class="token operator">%</span>projected_x_data就是降维后的reduced_face
    projected_train_data <span class="token operator">=</span> eigen_faces' <span class="token operator">*</span> <span class="token punctuation">(</span>train_data <span class="token operator">-</span> mean_face<span class="token punctuation">)</span><span class="token punctuation">;</span>
    projected_test_data <span class="token operator">=</span> eigen_faces' <span class="token operator">*</span> <span class="token punctuation">(</span>test_data <span class="token operator">-</span> mean_face<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">%</span> KNN的k值
    <span class="token operator">%</span>k就是人脸的标签判定数组的大小，出现最多次的就判断为true_label
    <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">6</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token char">'knn'</span><span class="token punctuation">)</span>
        <span class="token operator">%</span> 用于保存最小的k个值的矩阵
        <span class="token operator">%</span> 用于保存最小k个值对应的人标签的矩阵
        minimun_k_values <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        label_of_minimun_k_values <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token operator">%</span> 测试脸的数量
        test_face_number <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>projected_test_data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token operator">%</span> 识别正确数量
        correct_predict_number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token operator">%</span> 遍历每一个待测试人脸
        <span class="token keyword">for</span> each_test_face_index <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span>test_face_number

            each_test_face <span class="token operator">=</span> <span class="token function">projected_test_data</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>each_test_face_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
         <span class="token operator">%</span>这边操作看似多余，其实是为了首先用<span class="token number">6</span>个值填满，减少之后空循环迭代
            <span class="token keyword">for</span> each_train_face_index <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span>k    
                <span class="token operator">%</span>minimun_k_values 记录两点间距离 <span class="token number">6</span><span class="token operator">*</span><span class="token number">1</span>矩阵
                <span class="token function">minimun_k_values</span><span class="token punctuation">(</span>each_train_face_index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">norm</span><span class="token punctuation">(</span>each_test_face <span class="token operator">-</span> <span class="token function">projected_train_data</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>each_train_face_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">%</span>label_of_minimun_k_values 就是通过计算算出实际的标签 <span class="token operator">-</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> 
                <span class="token operator">%</span>label_of_minimun_k_values<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">]</span>
                <span class="token function">label_of_minimun_k_values</span><span class="token punctuation">(</span>each_train_face_index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">train_data_index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>each_train_face_index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            end

            <span class="token operator">%</span> 找出k个值中最大值及其下标
            <span class="token operator">%</span> IDX<span class="token operator">=</span><span class="token number">5</span> 
            <span class="token punctuation">[</span>max_value<span class="token punctuation">,</span> index_of_max_value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>minimun_k_values<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token operator">%</span> 计算与剩余每一个已知人脸的距离
            <span class="token keyword">for</span> each_train_face_index <span class="token operator">=</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>projected_train_data<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>

                <span class="token operator">%</span> 计算距离
                <span class="token operator">%</span>norm函数就是求欧式距离
                distance <span class="token operator">=</span> <span class="token function">norm</span><span class="token punctuation">(</span>each_test_face <span class="token operator">-</span> <span class="token function">projected_train_data</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>each_train_face_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token operator">%</span> 遇到更小的距离就更新距离和标签
                <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;</span> max_value<span class="token punctuation">)</span>
                    <span class="token function">minimun_k_values</span><span class="token punctuation">(</span>index_of_max_value<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> distance<span class="token punctuation">;</span>
                    <span class="token function">label_of_minimun_k_values</span><span class="token punctuation">(</span>index_of_max_value<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">train_data_index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>each_train_face_index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">[</span>max_value<span class="token punctuation">,</span> index_of_max_value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>minimun_k_values<span class="token punctuation">)</span><span class="token punctuation">;</span>
                end
            end

            <span class="token operator">%</span> 最终得到距离最小的k个值以及对应的标签
            <span class="token operator">%</span> 取出出现次数最多的值，为预测的人脸标签
            
            <span class="token operator">%</span>标签和下标的关系为： label<span class="token operator">=</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">train_data_index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>each_train_face_index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            predict_label <span class="token operator">=</span> <span class="token function">mode</span><span class="token punctuation">(</span>label_of_minimun_k_values<span class="token punctuation">)</span><span class="token punctuation">;</span>
            real_label <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">test_data_index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>each_test_face_index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>predict_label <span class="token operator">==</span> real_label<span class="token punctuation">)</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"预测值：%d，实际值:%d，正确\n"</span><span class="token punctuation">,</span>predict_label<span class="token punctuation">,</span>real_label<span class="token punctuation">)</span><span class="token punctuation">;</span>
                correct_predict_number <span class="token operator">=</span> correct_predict_number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"预测值：%d，实际值:%d，错误\n"</span><span class="token punctuation">,</span>predict_label<span class="token punctuation">,</span>real_label<span class="token punctuation">)</span><span class="token punctuation">;</span>
            end
        end

        <span class="token operator">%</span>正确率
        correct_rate <span class="token operator">=</span> correct_predict_number<span class="token operator">/</span>test_face_number<span class="token punctuation">;</span>

        X <span class="token operator">=</span> <span class="token punctuation">[</span>X k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        Y <span class="token operator">=</span> <span class="token punctuation">[</span>Y correct_rate<span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">"k=%d，numOfeig=%d，总测试样本：%d，正确数:%d，正确率：%1f \n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">,</span>test_face_number<span class="token punctuation">,</span>correct_predict_number<span class="token punctuation">,</span>correct_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>

    end
end

<span class="token function">waitfor</span><span class="token punctuation">(</span><span class="token function">plot</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token operator">%</span> 功能函数 图像可视化

<span class="token operator">%</span> 输入向量，显示脸

function fig <span class="token operator">=</span> <span class="token function">show_face</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span>
    fig<span class="token operator">=</span> <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">reshape</span><span class="token punctuation">(</span>vector<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">112</span> <span class="token number">92</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
end

<span class="token operator">%</span> 显示矩阵中某些脸
function fig <span class="token operator">=</span> <span class="token function">show_faces</span><span class="token punctuation">(</span>eigen_vectors<span class="token punctuation">)</span>
    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    index_of_image_to_show <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i<span class="token operator">=</span>index_of_image_to_show
        <span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fig <span class="token operator">=</span> <span class="token function">show_face</span><span class="token punctuation">(</span><span class="token function">eigen_vectors</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">title</span><span class="token punctuation">(</span><span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"i=%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    end
end
</code></pre> 
<h4><a id="_485"></a>参考</h4> 
<p><a href="https://zhuanlan.zhihu.com/p/356640804" rel="nofollow">特征脸法原理及代码讲解</a><br> <a href="https://zhuanlan.zhihu.com/p/358180450" rel="nofollow">代码参考</a><br> <a href="https://www.bilibili.com/video/BV1Nt411i7oD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=272859ebfd68e92364531cc607ff828b" rel="nofollow">KNN原理介绍1</a><br> <a href="https://www.bilibili.com/video/BV1X3411A79z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=272859ebfd68e92364531cc607ff828b" rel="nofollow">KNN原理介绍2</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/566c8edc31dbe5f86bf1d7d1776e2991/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vite配置@别名，以及如何让vscode智能提示路经</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/255ddc419f4ecaa03e8a755b7341964b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中，编译线程时出现错误：对‘sem_init’ ‘sem_destroy’ ‘sem_wait’未定义的引用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>