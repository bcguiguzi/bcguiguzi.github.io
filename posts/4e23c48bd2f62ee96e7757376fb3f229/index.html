<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>minicube搭建golang容器服务 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="minicube搭建golang容器服务" />
<meta property="og:description" content="引言 最近在自己电脑上搭建一个小型k8s环境，以学习云原生相关内容。这里我主要分为三部分记录：
容器及容器编排理论环境安装相关rpcx服务实战 还在调试中，先总结整理下，这里后续补充上我的github工程链接。
一、容器及容器编排理论 容器技术中有三个核心概念：容器（Container）、镜像（Image），以及镜像仓库（Registry）
如何通过Docker File构建镜像？
=&gt; 首先编写Docker File文件, Docker build 命令构建镜像 ,Docker run 依照新编写好的镜像运行容器实例。
操作容器的常用命令有 docker ps、docker run、docker exec、docker stop 等；操作镜像的常用命令有 docker images、docker rmi、docker build、docker tag 等；操作镜像仓库的常用命令有 docker pull、docker push 等。
Kubernetes 就是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器。
快速搭建 Kubernetes 环境的工具选择minikube， 最大特点就是“小而美”，可执行文件仅有不到 100MB，运行镜像也不过 1GB，但就在这么小的空间里却集成了 Kubernetes 的绝大多数功能特性，不仅有核心的容器编排功能，还有丰富的插件，例如 Dashboard、GPU、Ingress、Istio、Kong、Registry 等等，综合来看非常完善。
总结差异： 容器技术只解决了应用的打包、安装问题，面对复杂的生产环境就束手无策了，解决之道就是容器编排，它能够组织管理各个应用容器之间的关系，让它们顺利地协同运行。
Kubernetes 源自 Google 内部的 Borg 系统，也是当前容器编排领域的事实标准。minikube 可以在本机搭建 Kubernetes 环境，功能很完善，适合学习研究。操作 Kubernetes 需要使用命令行工具 kubectl，只有通过它才能与 Kubernetes 集群交互。kubectl 的用法与 docker 类似，也可以拉取镜像运行，但操作的不是简单的容器。
docker和k8s之间的区别，一个是容器技术，一个是容器编排技术，两者思考的维度是不一样的，就容器而言，容器解决的问题是隔离，是一次打包到处运行的问题，最大的价值就在于镜像的迁移。编排技术则是关注的是整个系统的问题，如果你只关注一个服务，迁移一个服务，那docker就够，但要迁移整个系统以及运维，那就需要编排，包括网络关系，负载均衡，回滚，监控，扩缩容问题则需要容器编排技术。
二、环境安装相关 我的电脑是mac m2，因此需要安装一些arm架构的软件。首先安装docker，主要使用的命令记录：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4e23c48bd2f62ee96e7757376fb3f229/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T17:00:00+08:00" />
<meta property="article:modified_time" content="2023-12-23T17:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">minicube搭建golang容器服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>引言</h4> 
<p>最近在自己电脑上搭建一个小型k8s环境，以学习云原生相关内容。这里我主要分为三部分记录：</p> 
<ul><li>容器及容器编排理论</li><li>环境安装相关</li><li>rpcx服务实战</li></ul> 
<blockquote> 
 <p>还在调试中，先总结整理下，这里后续补充上我的github工程链接。</p> 
</blockquote> 
<h4><a id="_9"></a>一、容器及容器编排理论</h4> 
<p>容器技术中有三个核心概念：容器（Container）、镜像（Image），以及镜像仓库（Registry）</p> 
<p>如何通过Docker File构建镜像？<br> =&gt; 首先编写Docker File文件, Docker build 命令构建镜像 ,Docker run 依照新编写好的镜像运行容器实例。</p> 
<p>操作容器的常用命令有 <code>docker ps、docker run、docker exec、docker stop </code>等；操作镜像的常用命令有 <code>docker images、docker rmi、docker build、docker tag</code> 等；操作镜像仓库的常用命令有 <code>docker pull、docker push</code> 等。</p> 
<p>Kubernetes 就是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器。</p> 
<p>快速搭建 Kubernetes 环境的工具选择minikube， 最大特点就是“小而美”，可执行文件仅有不到 100MB，运行镜像也不过 1GB，但就在这么小的空间里却集成了 Kubernetes 的绝大多数功能特性，不仅有核心的容器编排功能，还有丰富的插件，例如 Dashboard、GPU、Ingress、Istio、Kong、Registry 等等，综合来看非常完善。</p> 
<h6><a id="_22"></a>总结差异：</h6> 
<p>容器技术只解决了应用的打包、安装问题，面对复杂的生产环境就束手无策了，解决之道就是容器编排，它能够组织管理各个应用容器之间的关系，让它们顺利地协同运行。</p> 
<p>Kubernetes 源自 Google 内部的 Borg 系统，也是当前容器编排领域的事实标准。minikube 可以在本机搭建 Kubernetes 环境，功能很完善，适合学习研究。操作 Kubernetes 需要使用命令行工具 kubectl，只有通过它才能与 Kubernetes 集群交互。kubectl 的用法与 docker 类似，也可以拉取镜像运行，但操作的不是简单的容器。</p> 
<p>docker和k8s之间的区别，一个是容器技术，一个是容器编排技术，两者思考的维度是不一样的，就容器而言，容器解决的问题是隔离，是一次打包到处运行的问题，最大的价值就在于镜像的迁移。编排技术则是关注的是整个系统的问题，如果你只关注一个服务，迁移一个服务，那docker就够，但要迁移整个系统以及运维，那就需要编排，包括网络关系，负载均衡，回滚，监控，扩缩容问题则需要容器编排技术。</p> 
<h4><a id="_30"></a>二、环境安装相关</h4> 
<p>我的电脑是mac m2，因此需要安装一些arm架构的软件。首先安装docker，主要使用的命令记录：</p> 
<pre><code>因为安装的是docker 桌面版本,终端可能找不到docker命令，因此添加环境变量:
export PATH="$PATH:/Applications/Docker.app/Contents/Resources/bin/"

验证:
docker --version  
</code></pre> 
<p>之后安装minikube，这里使用命令行安装arm架构版本:</p> 
<pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-arm64
sudo install minikube-darwin-arm64 /usr/local/bin/minikube

验证：
minikube version
</code></pre> 
<p>不过 minikube 只能够搭建 Kubernetes 环境，要操作 Kubernetes，还需要另一个专门的客户端工具“kubectl”。kubectl 的作用有点类似之前我们学习容器技术时候的工具“docker”，它也是一个命令行工具，作用也比较类似，同样是与 Kubernetes 后台服务通信，把我们的命令转发给 Kubernetes，实现容器和集群的管理功能。</p> 
<pre><code> minikube kubectl
 minikube dashboard
 此时可以界面化查看: http://127.0.0.1:52337/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/pod?namespace=default
</code></pre> 
<p>➜ k8s minikube version<br> minikube version: v1.32.0<br> commit: 8220a6eb95f0a4d75f7f2d7b14cef975f050512d<br> ➜ k8s minikube kubectl – version<br> Client Version: v1.28.3<br> Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3<br> Server Version: v1.28.3</p> 
<h4><a id="rpcx_68"></a>三、rpcx服务实战</h4> 
<p><a href="https://rpcx.io/" rel="nofollow"><code>RPCX</code></a>是一个分布式的Go语言的 RPC 框架，支持Zookepper、etcd、consul多种服务发现方式，多种服务路由方式，这里首先基于该框架在本机测试代码，之后开始考虑生成镜像并本地部署。</p> 
<h5><a id="31__72"></a>3.1 本地运行及测试服务代码</h5> 
<p>服务端rpcx_server.go代码:</p> 
<pre><code>package main

import (
	"context"
	"flag"
	"log"
	"time"

	example "github.com/rpcxio/rpcx-examples"
	"github.com/smallnest/rpcx/client"
)

var (
	addr = flag.String("addr", "localhost:8972", "server address")
)

func main() {
	flag.Parse()

	d, _ := client.NewPeer2PeerDiscovery("tcp@"+*addr, "")
	xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
	defer xclient.Close()

	args := &amp;example.Args{
		A: 10,
		B: 20,
	}

	for {
		reply := &amp;example.Reply{}
		err := xclient.Call(context.Background(), "Mul", args, reply)
		if err != nil {
			log.Fatalf("failed to call: %v", err)
		}

		log.Printf("%d * %d = %d", args.A, args.B, reply.C)
		time.Sleep(1e9)
	}
}

</code></pre> 
<p>客户端rpcx_client.go代码:</p> 
<pre><code>package main

import (
	"flag"

	example "github.com/rpcxio/rpcx-examples"
	"github.com/smallnest/rpcx/server"
)

var addr = flag.String("addr", "localhost:8972", "server address")

func main() {
	flag.Parse()

	s := server.NewServer()
	// s.RegisterName("Arith", new(example.Arith), "")
	s.Register(new(example.Arith), "")
	s.Serve("tcp", *addr)
}

</code></pre> 
<p>本地通过<code>go run</code>测试验证成功。</p> 
<h5><a id="32_dockfile_146"></a>3.2 编写dockfile生成镜像</h5> 
<p>服务端：</p> 
<pre><code>FROM golang:1.19-alpine as builder
WORKDIR /usr/src/app
ENV GOPROXY=https://goproxy.cn
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories &amp;&amp; \
  apk add --no-cache ca-certificates tzdata
COPY ./go.mod ./
COPY ./go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -ldflags "-s -w" -o rpcx_server

FROM scratch as runner
COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /usr/src/app/rpcx_server /opt/app/

EXPOSE 8972

CMD ["/opt/app/rpcx_server"]
</code></pre> 
<p>客户端:</p> 
<pre><code>FROM golang:1.19-alpine as builder
WORKDIR /usr/src/app
ENV GOPROXY=https://goproxy.cn
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories &amp;&amp; \
  apk add --no-cache ca-certificates tzdata
COPY ./go.mod ./
COPY ./go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -ldflags "-s -w" -o rpcx_client 

FROM busybox as runner
COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /usr/src/app/rpcx_client /opt/app/

CMD ["/opt/app/rpcx_client"]
</code></pre> 
<p>分别指向以下命令进行生成及验证:</p> 
<pre><code>docker build . -t rpcx-server-demo:0.1.0
docker build . -t rpcx-client-demo:0.1.0

之后通过docker images查看:
docker images                                     
REPOSITORY                    TAG       IMAGE ID       CREATED         SIZE
rpcx-server-demo              0.1.0     a13acd11fc0e   19 hours ago    10.7MB
</code></pre> 
<h5><a id="33_yaml_206"></a>3.3 通过yaml部署发布</h5> 
<p>服务端：</p> 
<pre><code>kubectl apply -f rpcx-server-demo.yaml
kubectl apply -f rpcx-server-demo-service.yaml
</code></pre> 
<p>Kubernetes 中的服务（Service）和部署（Deployment）是两个不同的资源对象，需要分别定义和创建。</p> 
<ol><li><code>rpcx-server-demo.yaml</code> 文件用于创建 RPCX 服务器的部署。这个文件定义了部署所需的配置，如容器镜像、副本数、资源限制等。通过执行 <code>kubectl apply -f rpcx-server-demo.yaml</code> 命令，您将创建一个部署对象，该对象将负责管理和运行 RPCX 服务器的实例。</li><li><code>rpcx-server-demo-service.yaml</code> 文件用于创建 RPCX 服务器的服务。服务是 Kubernetes 中的一种资源对象，用于公开应用程序的网络访问。通过执行 <code>kubectl apply -f rpcx-server-demo-service.yaml</code> 命令，您将创建一个服务对象，该对象将为 RPCX 服务器提供一个稳定的网络地址，以便其他应用程序可以通过该地址与服务器进行通信。</li></ol> 
<p>通过将这两个 YAML 文件分开，您可以更好地组织和管理应用程序的部署和服务。部署文件负责定义和管理应用程序的实例，而服务文件负责定义和管理应用程序的网络访问。这种分离可以提高可维护性和灵活性，并使您能够更好地管理应用程序的不同方面。</p> 
<p>客户端：</p> 
<pre><code>kubectl apply -f rpcx-client-demo.yaml
</code></pre> 
<p>客户端通常不需要像服务端那样暴露网络服务，所以不需要创建服务对象。</p> 
<p>在这种情况下，只需使用 <code>kubectl apply -f rpcx-client-demo.yaml</code> 命令来创建客户端的部署对象即可。该部署对象将负责管理和运行 RPCX 客户端的实例。</p> 
<p>客户端通常是作为一个独立的应用程序运行，它会连接到服务端提供的网络地址进行通信。因此，不需要为客户端创建服务对象，因为客户端不需要公开网络访问。</p> 
<h4><a id="_234"></a>参考：</h4> 
<p>极客时间部分教程<br> 想学习k8s但没有环境？使用minikube轻松搭建一个 https://mp.weixin.qq.com/s/aExQHKHsqsOChDrT4Lz0vw<br> 构建 Golang 应用最小 Docker 镜像 https://www.cnblogs.com/hahaha111122222/p/17878985.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f0adb2fea9c0b4d4a34a6b9067bbe5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云服务器如何使用ubuntu图形桌面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e65e00a2bee66ff56d743d324030343b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解vue双向绑定原理，一文手把手带你用原生js实现vue双向绑定</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>