<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DVWA靶场-CSRF跨站请求伪造 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DVWA靶场-CSRF跨站请求伪造" />
<meta property="og:description" content="CSRF(跨站请求伪造)简介
概念 CSRF（Cross—site request forgery），跨站请求伪造，是指利用受害者未失效的身份认证信息（cookie，会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下，以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账，改密等）。
CSRF与XSS的区别 CSRF属于业务逻辑漏洞，在服务器看来，所有的请求都是合法正常的；
XSS，SQL注入等等都是属于技术漏洞；
XSS：客户信任服务器；
CSRF：服务器信任客户（经过身份认证的）；
CSRF攻击成功的前提 用户必须登录；
黑客必须懂得一些发包的请求；
服务器端不会有二次认证；
被害者是不知情的；
危害 修改用户信息，如用户头像、发货地址等
个人隐私泄露，机密资料泄露
执行恶意操作，如修改密码，购买商品，转账等（盗用受害者身份，受害者能做什么攻击者就能以受害者身份）
具体操作请看这篇文章pikachu靶场-csrf_pikachu csrf黑名单-CSDN博客
low等级 &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&#34;___mysqli_ston&#34;]) &amp;&amp; is_object($GLOBALS[&#34;___mysqli_ston&#34;])) ? mysqli_real_escape_string($GLOBALS[&#34;___mysqli_ston&#34;], $pass_new ) : ((trigger_error(&#34;[MySQLConverterToo] Fix the mysql_escape_string() call!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a9576b4f10ab87dd24ceae99fe8574f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T21:22:21+08:00" />
<meta property="article:modified_time" content="2024-03-15T21:22:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DVWA靶场-CSRF跨站请求伪造</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6><strong>CSRF(跨站请求伪造)简介</strong><br><strong>概念</strong></h6> 
<blockquote> 
 <p>CSRF（Cross—site request forgery），跨站请求伪造，是指利用受害者未失效的身份认证信息（cookie，会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下，以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账，改密等）。</p> 
</blockquote> 
<h6><strong>CSRF与XSS的区别</strong></h6> 
<blockquote> 
 <p>CSRF属于业务逻辑漏洞，在服务器看来，所有的请求都是合法正常的；</p> 
 <p>XSS，SQL注入等等都是属于技术漏洞；</p> 
 <p>XSS：客户信任服务器；</p> 
 <p>CSRF：服务器信任客户（经过身份认证的）；</p> 
</blockquote> 
<h6><strong>CSRF攻击成功的前提</strong></h6> 
<blockquote> 
 <p>用户必须登录；</p> 
 <p>黑客必须懂得一些发包的请求；</p> 
 <p>服务器端不会有二次认证；</p> 
 <p>被害者是不知情的；</p> 
</blockquote> 
<h6><strong>危害</strong></h6> 
<blockquote> 
 <p>修改用户信息，如用户头像、发货地址等</p> 
 <p>个人隐私泄露，机密资料泄露</p> 
 <p>执行恶意操作，如修改密码，购买商品，转账等（盗用受害者身份，受害者能做什么攻击者就能以受害者身份）</p> 
</blockquote> 
<p>具体操作请看这篇文章<a href="https://blog.csdn.net/qq_29977871/article/details/130300097" title="pikachu靶场-csrf_pikachu csrf黑名单-CSDN博客">pikachu靶场-csrf_pikachu csrf黑名单-CSDN博客</a></p> 
<h6><strong>low等级 </strong></h6> 
<pre><code class="language-php">&lt;?php

if( isset( $_GET[ 'Change' ] ) ) {
	// Get input
	$pass_new  = $_GET[ 'password_new' ];
	$pass_conf = $_GET[ 'password_conf' ];

	// Do the passwords match?
	if( $pass_new == $pass_conf ) {
		// They do!
		$pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
		$pass_new = md5( $pass_new );

		// Update the database
		$insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";
		$result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );

		// Feedback for the user
		$html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";
	}
	else {
		// Issue with passwords matching
		$html .= "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";
	}

	((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
}

?&gt;
</code></pre> 
<p>只是对输入的pass_new和pass_conf进行了==比较，没有进行其他的防御，因此，只要用户在cookie还有效的时间内在相同的浏览器访问我们给定的url（该操作是服务器对请求的发送者进行了身份验证，检查cookie），就可以实现CSRF 攻击，最终修改密码。</p> 
<h6 style="background-color:transparent;"><strong>medium等级</strong></h6> 
<pre><code class="language-php">&lt;?php

if( isset( $_GET[ 'Change' ] ) ) {
	// Checks to see where the request came from
	if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) {
		// Get input
		$pass_new  = $_GET[ 'password_new' ];
		$pass_conf = $_GET[ 'password_conf' ];

		// Do the passwords match?
		if( $pass_new == $pass_conf ) {
			// They do!
			$pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
			$pass_new = md5( $pass_new );

			// Update the database
			$insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";
			$result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );

			// Feedback for the user
			$html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";
		}
		else {
			// Issue with passwords matching
			$html .= "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";
		}
	}
	else {
		// Didn't come from a trusted source
		$html .= "&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;";
	}

	((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
}

?&gt;
</code></pre> 
<blockquote> 
 <ul><li>使用$_SERVER['HTTP_REFERER']获取请求的来源页面URL。</li><li>使用$_SERVER['SERVER_NAME']获取当前服务器的域名。</li><li>使用stripos()函数（不区分大小写地查找字符串首次出现的位置）来检查请求来源URL是否包含当前服务器的域名。</li></ul> 
</blockquote> 
<blockquote> 
 <p>假如服务器地址为192.168.101.66，即为SERVER_NAME，我们只需要把我们构造的恶意页面文件名改为192.168.101.66.html，HTTP_REFERER就会包含192.168.101.66.html,就可以绕过stripos了。</p> 
</blockquote> 
<p>这个对于本地搭建的DVWA是无效的 </p> 
<h6 style="background-color:transparent;"><strong>high等级</strong></h6> 
<pre><code class="language-php">&lt;?php

$change = false;
$request_type = "html";
$return_message = "Request Failed";

if ($_SERVER['REQUEST_METHOD'] == "POST" &amp;&amp; array_key_exists ("CONTENT_TYPE", $_SERVER) &amp;&amp; $_SERVER['CONTENT_TYPE'] == "application/json") {
	$data = json_decode(file_get_contents('php://input'), true);
	$request_type = "json";
	if (array_key_exists("HTTP_USER_TOKEN", $_SERVER) &amp;&amp;
		array_key_exists("password_new", $data) &amp;&amp;
		array_key_exists("password_conf", $data) &amp;&amp;
		array_key_exists("Change", $data)) {
		$token = $_SERVER['HTTP_USER_TOKEN'];
		$pass_new = $data["password_new"];
		$pass_conf = $data["password_conf"];
		$change = true;
	}
} else {
	if (array_key_exists("user_token", $_REQUEST) &amp;&amp;
		array_key_exists("password_new", $_REQUEST) &amp;&amp;
		array_key_exists("password_conf", $_REQUEST) &amp;&amp;
		array_key_exists("Change", $_REQUEST)) {
		$token = $_REQUEST["user_token"];
		$pass_new = $_REQUEST["password_new"];
		$pass_conf = $_REQUEST["password_conf"];
		$change = true;
	}
}

if ($change) {
	// Check Anti-CSRF token
	checkToken( $token, $_SESSION[ 'session_token' ], 'index.php' );

	// Do the passwords match?
	if( $pass_new == $pass_conf ) {
		// They do!
		$pass_new = mysqli_real_escape_string ($GLOBALS["___mysqli_ston"], $pass_new);
		$pass_new = md5( $pass_new );

		// Update the database
		$insert = "UPDATE `users` SET password = '" . $pass_new . "' WHERE user = '" . dvwaCurrentUser() . "';";
		$result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert );

		// Feedback for the user
		$return_message = "Password Changed.";
	}
	else {
		// Issue with passwords matching
		$return_message = "Passwords did not match.";
	}

	mysqli_close($GLOBALS["___mysqli_ston"]);

	if ($request_type == "json") {
		generateSessionToken();
		header ("Content-Type: application/json");
		print json_encode (array("Message" =&gt;$return_message));
		exit;
	} else {
		$html .= "&lt;pre&gt;" . $return_message . "&lt;/pre&gt;";
	}
}

// Generate Anti-CSRF token
generateSessionToken();

?&gt;
</code></pre> 
<p>设置了token限制，它是在每次访问此页面时，会随机生成一个token，当发起服务器请求时服务器会检查它的值。</p> 
<p>思路：先获取token的值，再构造链接并诱骗受害者访问。</p> 
<p>利用以下payload在反射型xss中获取到token值，不要点确认（否则会重新生成新的token）</p> 
<pre><code class="language-php">&lt;iframe src='../csrf/' onload="alert(frames[0].document.getElementsByName('user_token')
[0].value)"&gt;</code></pre> 
<p><img alt="" height="787" src="https://images2.imgbox.com/f6/e2/tjY6mnxy_o.png" width="1200"></p> 
<p>在 bp抓包中替换掉已经抓到的token即可实现修改密码</p> 
<h6 style="background-color:transparent;"><strong>Impossible等级</strong></h6> 
<pre><code class="language-php">&lt;?php

if( isset( $_GET[ 'Change' ] ) ) {
	// Check Anti-CSRF token
	checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

	// Get input
	$pass_curr = $_GET[ 'password_current' ];
	$pass_new  = $_GET[ 'password_new' ];
	$pass_conf = $_GET[ 'password_conf' ];

	// Sanitise current password input
	$pass_curr = stripslashes( $pass_curr );
	$pass_curr = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_curr ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
	$pass_curr = md5( $pass_curr );

	// Check that the current password is correct
	$data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );
	$data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );
	$data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );
	$data-&gt;execute();

	// Do both new passwords match and does the current password match the user?
	if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {
		// It does!
		$pass_new = stripslashes( $pass_new );
		$pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
		$pass_new = md5( $pass_new );

		// Update database with new password
		$data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' );
		$data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR );
		$data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );
		$data-&gt;execute();

		// Feedback for the user
		$html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";
	}
	else {
		// Issue with passwords matching
		$html .= "&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;";
	}
}

// Generate Anti-CSRF token
generateSessionToken();

?&gt;
</code></pre> 
<blockquote> 
 <ul><li>使用token机制</li><li>使用PDO（PHP 数据对象）来执行数据库查询和准备语句，以防止 SQL 注入攻击。</li><li>在处理密码更改请求时，首先验证当前用户输入的原始密码是否正确。 </li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f02d2c85daa0f1d0eb342551b904a7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">perl 用 XML::LibXML DOM 解析 Freeplane.mm文件，生成测试用例.csv文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58a2fdcad08d2454bd078cd17b26302d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为OD机试2024年最新题库（Python、JAVA、C&#43;&#43;合集）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>