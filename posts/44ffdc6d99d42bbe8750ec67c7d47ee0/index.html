<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python编程：大文件Hash计算及加解密 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python编程：大文件Hash计算及加解密" />
<meta property="og:description" content="一.前言 在互联网时代，无论文件存储在本地端还是云端，安全性问题都是不容忽略的重要考虑因素。尤其对于重要的学习资料，我们可以在存储前对其进行加密处理，并在需要时使用解密进行恢复。然而，面对大文件，比如约4GB的文件，一次性进行Hash计算及加解密似乎存在一些难题，可能导致内存溢出等问题。因此，设计一种高效的大文件Hash计算及加解密流程显得尤为重要。
二.实现 先简单了解下本文涉及的两种安全算法：
SHA-256
加密哈希函数，设计用于产生固定长度的哈希值，通常用于确保数据的完整性。分组大小为64字节。
AES/CBC/PKCS5Padding
对称密钥加密算法，被广泛用于保护数据的机密性。CBC模式使用前一个块的密文与当前块的明文进行异或操作，增强了安全性。需要一个初始化向量（IV）来加密第一个块。分组大小为16字节，不足时需要进行填充。
具体流程
本文中使用SHA-256来计算文件的Hash来确保数据的完整性，使用AES/CBC/PKCS5Padding对文件进行加解密。
对文件进行分块时，要选择合适的块大小BLOCK_SIZE，64B的倍数，本文选取2MB，选择过小，AES填充会使加密后的文件体积增加较大。
需要注意的是，对16B倍数的块，AES填充会增加AES.block_size数据，因此加密时BLOCK_SIZE读取文件，解密需要BLOCK_SIZE&#43;AES.block_size读取文件。
具体代码实现如下，本人电脑配置加解密4GB大小文件均耗时10s左右。
pip install pycryptodome from hashlib import sha256 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from time import time from datetime import datetime import json import os # ASE:16B # SHA256:64B # 加密块大小 2MB BLOCK_SIZE = 1024 * 1024 * 2 def log(text: str) -&gt; None: &#34;&#34;&#34; 日志输出 &#34;&#34;&#34; format = &#34;%Y-%m-%d %H:%M:%S&#34; format_text = f&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/44ffdc6d99d42bbe8750ec67c7d47ee0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T17:07:38+08:00" />
<meta property="article:modified_time" content="2024-01-13T17:07:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python编程：大文件Hash计算及加解密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一.前言</h4> 
<p style="text-align:justify;">在互联网时代，无论文件存储在本地端还是云端，安全性问题都是不容忽略的重要考虑因素。尤其对于重要的学习资料，我们可以在存储前对其进行加密处理，并在需要时使用解密进行恢复。然而，面对大文件，比如约4GB的文件，一次性进行Hash计算及加解密似乎存在一些难题，可能导致内存溢出等问题。因此，设计一种高效的大文件Hash计算及加解密流程显得尤为重要。</p> 
<h4>二.实现</h4> 
<p>先简单了解下本文涉及的两种安全算法：</p> 
<p><strong>SHA-256</strong></p> 
<p>加密哈希函数，设计用于产生固定长度的哈希值，通常用于确保数据的完整性。分组大小为<strong>64字节。</strong></p> 
<p><strong>AES/CBC/PKCS5Padding</strong></p> 
<p style="text-align:justify;">对称密钥加密算法，被广泛用于保护数据的机密性。CBC模式使用前一个块的密文与当前块的明文进行异或操作，增强了安全性。需要一个初始化向量（IV）来加密第一个块。分组大小为<strong>16字节</strong>，不足时需要进行填充。</p> 
<p><strong>具体流程</strong></p> 
<p style="text-align:justify;">本文中使用<strong>SHA-256</strong>来计算文件的Hash来确保数据的完整性，使用<strong>AES/CBC/PKCS5Padding</strong>对文件进行加解密。</p> 
<p style="text-align:justify;">对文件进行分块时，要选择合适的块大小<strong>BLOCK_SIZE</strong>，<strong>64B的倍数</strong>，本文选取2MB，选择过小，AES填充会使加密后的文件体积增加较大。</p> 
<p style="text-align:justify;">需要注意的是，对<strong>16B倍数</strong>的块，AES填充会增加<strong>AES.block_size</strong>数据，因此加密时<strong>BLOCK_SIZE</strong>读取文件，解密需要<strong>BLOCK_SIZE+AES.block_size</strong>读取文件。</p> 
<p style="text-align:justify;">具体代码实现如下，本人电脑配置加解密4GB大小文件均耗时10s左右。</p> 
<pre><code class="language-bash">pip install pycryptodome</code></pre> 
<pre><code class="language-python">from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from time import time
from datetime import datetime
import json
import os

# ASE:16B
# SHA256:64B
# 加密块大小 2MB
BLOCK_SIZE = 1024 * 1024 * 2


def log(text: str) -&gt; None:
    """
    日志输出
    """
    format = "%Y-%m-%d %H:%M:%S"
    format_text = f"[{datetime.now().strftime(format)}] {text}"
    print(format_text)


def simple_aes_decrypt(key: str, data: bytes) -&gt; bytes:
    """
    简单AES/CBC/PKCS5Padding解密
    """
    # 创建cipher对象
    cipher = AES.new(key=key.encode(), mode=AES.MODE_CBC, iv=key.encode())
    # 对输入数据进行解密
    decrypted_data = cipher.decrypt(data)
    return unpad(decrypted_data, AES.block_size)


def simple_aes_encrypt(key: str, data: bytes) -&gt; bytes:
    """
    简单AES/CBC/PKCS5Padding加密
    """
    # 创建cipher对象
    cipher = AES.new(key=key.encode(), mode=AES.MODE_CBC, iv=key.encode())
    # 对输入数据进行加密
    encrypted_data = cipher.encrypt(pad(data, AES.block_size))
    return encrypted_data


def encrypt_file(file_path: str, key: str, output_name: str = None) -&gt; str:
    """
    AES/CBC/PKCS5Padding加密文件
    """
    # 检查文件是否存在
    if not os.path.exists(file_path):
        raise FileNotFoundError("文件不存在")

    # 文件属性
    file_input = open(file_path, "rb")
    file_input_name = os.path.basename(file_path)
    file_input_size = os.path.getsize(file_path)
    # 如果没有指定输出文件名，则使用20位Hash值作为文件名
    if not output_name:
        output_name = sha256(file_input_name.encode()).hexdigest()[:20]
    file_output = open(output_name, "wb")

    # 同时进行Hash计算和AES加密
    log("开始加密...")
    cipher_hash = sha256()
    cipher_encrypt = AES.new(key=key.encode(), mode=AES.MODE_CBC, iv=key.encode())
    while True:
        bytes = file_input.read(BLOCK_SIZE)
        if not bytes:
            break
        cipher_hash.update(bytes)
        # size = BLOCK_SIZE+AES.block_size
        encrypt_bytes = cipher_encrypt.encrypt(pad(bytes, AES.block_size))
        file_output.write(encrypt_bytes)
    file_input.close()
    file_output.close()
    hash = cipher_hash.hexdigest()

    # 保存参数，用于解密时恢复文件名、完整性验证
    config = {
        "filename": file_input_name,
        "size": file_input_size,
        "hash": hash,
        "time": int(time() * 1000),
    }
    config = json.dumps(config, ensure_ascii=False)
    config = simple_aes_encrypt(key, config.encode())
    file_config_name = output_name + ".config"
    file_config = open(file_config_name, "wb")
    file_config.write(config)
    file_config.close()
    log("加密完成")

    return output_name


def decrypt_file(file_path: str, key: str, output_name: str = None) -&gt; None:
    """
    AES/CBC/PKCS5Padding解密文件
    """
    # 检查文件是否存在
    if not os.path.exists(file_path):
        raise FileNotFoundError("文件不存在")

    # 检查配置文件是否存在
    config = None
    file_config_name = file_path + ".config"
    if not os.path.exists(file_config_name):
        log("配置文件不存在")
    else:
        file_config = open(file_config_name, "rb")
        config = file_config.read()
        file_config.close()
        config = simple_aes_decrypt(key, config)
        config = json.loads(config.decode())
        if not output_name:
            output_name = config["filename"]

    file_output = open(output_name, "wb")
    file_input = open(file_path, "rb")

    # 同时进行Hash计算和AES加密
    log("开始解密...")
    cipher_hash = sha256()
    cipher_decrypt = AES.new(key=key.encode(), mode=AES.MODE_CBC, iv=key.encode())
    while True:
        # size = BLOCK_SIZE+AES.block_size
        bytes = file_input.read(BLOCK_SIZE + AES.block_size)
        if not bytes:
            break
        decrypt_bytes = unpad(cipher_decrypt.decrypt(bytes), AES.block_size)
        cipher_hash.update(decrypt_bytes)
        file_output.write(decrypt_bytes)

    file_input.close()
    file_output.close()
    log("解密完成")

    # 验证文件完整性
    if config:
        hash = cipher_hash.hexdigest()
        if hash != config["hash"]:
            raise Exception("文件完整性验证失败")
        else:
            log("文件完整性验证成功")
    else:
        log("缺少配置文件，未验证文件完整性")

    return output_name


if __name__ == "__main__":
    file_path = r"C:\Users\xxxx\Downloads\xxxxx.zip"
    key = "1234567890123456" # 16字节/32字节
    output_name = encrypt_file(file_path, key)
    decrypt_file(output_name, key)</code></pre> 
<h4>三.总结</h4> 
<p>本文讲述了一种大文件Hash计算及加解密流程，可以根据实际需要替换其中算法和优化流程，完善成命令行工具应在日常中使用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a779a3ca38d9839581a95a2ccccf3df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BSC/平衡记分卡</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a562da9af645994ec2cc4bb1e772ca87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI的未来 - AI Agent系列】【MetaGPT】0. 你的第一个MetaGPT程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>