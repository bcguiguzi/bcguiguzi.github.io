<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生】k8s的pod基本概念 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【云原生】k8s的pod基本概念" />
<meta property="og:description" content="一、资源限制 Pod 是 kubernetes 中最小的资源管理组件，Pod 也是最小化运行容器化应用的资源对象。一个 Pod 代表着集群中运行的一个进程。kubernetes 中其他大多数组件都是围绕着 Pod 来进行支撑和扩展 Pod 功能的，例如用于管理 Pod 运行的 StatefulSet 和 Deployment 等控制器对象，用于暴露 Pod 应用的 Service 和 Ingress 对象，为 Pod 提供存储的 PersistentVolume 存储资源对象等。
二、Pod 的两种使用方式 一个 Pod 中运行一个容器。每个 Pod 中一个容器的模式是最常见的用法，在这种使用方式中，你可以把 Pod想象成是单个容器的封装，kubernetes 管理的是 Pod 而不是直接管理容器。在一个 Pod 中同时运行多个容器。一个 Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service单位，比如一个容器共享文件，另一个 sidecar 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。 三、Pod 资源共享 一个 Pod 下的容器必须运行于同一节点上。**现代容器技术建议一个容器只运行一个进程，该进程在容器中 PID 命令空间中的进程号为 1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。
若想在容器内运行多个进程，需要有一个类似 Linux 操作系统 init 进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这是由于容器间的隔离机制导致，k8s 中的 Pod 资源抽象正是解决此类问题，Pod 对象是一组容器的集合，这些容器共享 Network、UTS 及 IPC 命令空间，因此具有相同的域名、主机名和网络接口，并可通过 IPC 直接通信。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0f905c13835cea735bc4dc7fb6bc856f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-26T19:56:00+08:00" />
<meta property="article:modified_time" content="2023-02-26T19:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生】k8s的pod基本概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="tid-XsJYAX">一、资源限制</h2> 
<p>Pod 是 kubernetes 中最小的资源管理组件，Pod 也是最小化运行容器化应用的资源对象。一个 Pod 代表着集群中运行的一个进程。kubernetes 中其他大多数组件都是围绕着 Pod 来进行支撑和扩展 Pod 功能的，例如用于管理 Pod 运行的 StatefulSet 和 Deployment 等控制器对象，用于暴露 Pod 应用的 Service 和 Ingress 对象，为 Pod 提供存储的 PersistentVolume 存储资源对象等。<a name="_label1"></a></p> 
<h2 id="tid-Zd6pme">二、Pod 的两种使用方式</h2> 
<ol><li>一个 Pod 中运行一个容器。每个 Pod 中一个容器的模式是最常见的用法，在这种使用方式中，你可以把 Pod想象成是单个容器的封装，kubernetes 管理的是 Pod 而不是直接管理容器。</li><li>在一个 Pod 中同时运行多个容器。一个 Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service单位，比如一个容器共享文件，另一个 sidecar 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。<a name="_label2"></a></li></ol> 
<h2 id="tid-PRYBhs">三、Pod 资源共享</h2> 
<p>一个 Pod 下的容器必须运行于同一节点上。**现代容器技术建议一个容器只运行一个进程，该进程在容器中 PID 命令空间中的进程号为 1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。</p> 
<p>若想在容器内运行多个进程，需要有一个类似 Linux 操作系统 init 进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这是由于容器间的隔离机制导致，k8s 中的 Pod 资源抽象正是解决此类问题，Pod 对象是一组容器的集合，这些容器共享 Network、UTS 及 IPC 命令空间，因此具有相同的域名、主机名和网络接口，并可通过 IPC 直接通信。</p> 
<table border="1"><tbody><tr><td>namespace  </td><td>功能说明</td></tr><tr><td>mnt</td><td>提供磁盘挂载点和文件系统的隔离能力</td></tr><tr><td>ipc</td><td>提供进程间通信的隔离能力</td></tr><tr><td>net</td><td>提供网络隔离能力</td></tr><tr><td>uts</td><td>提供主机名隔离能力</td></tr><tr><td>pid</td><td>提供进程隔离能力</td></tr><tr><td>user</td><td>提供用户隔离能力</td></tr></tbody></table> 
<p><a name="_label3"></a></p> 
<h2 id="tid-JBPync">四、底层容器Pause</h2> 
<p>Pod 资源中针对各容器提供网络命令空间等共享机制的是底层基础容器 pause，基础容器（也可称为父容器）pause 就是为了管理 Pod 容器间的共享操作，这个父容器需要能够准确地知道如何去创建共享运行环境的容器，还能管理这些容器的生命周期。为了实现这个父容器的构想，kubernetes 中，用 pause 容器来作为一个 Pod 中所有容器的父容器。这个 pause 容器有两个核心的功能，一是它提供整个 Pod 的 Linux 命名空间的基础。二来启用 PID 命名空间，它在每个 Pod 中都作为 PID 为 1 进程（init 进程），并回收僵尸进程。</p> 
<p><a name="_lab2_3_0"></a></p> 
<h3 id="tid-GZxMwa">1、Pause共享资源</h3> 
<p><a name="_label3_3_0_0"></a></p> 
<h4 id="tid-kcrXaa">1.1 网络</h4> 
<p>每个 Pod 都会被分配一个唯一的 IP 地址。Pod 中的所有容器共享网络空间，包括 IP 地址和端口。Pod 内部的容器可以使用 localhost 互相通信。Pod 中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。</p> 
<p><a name="_label3_3_0_1"></a></p> 
<h4 id="tid-EfNTsi">1.2 存储</h4> 
<p>可以 Pod 指定多个共享的 Volume。Pod 中的所有容器都可以访问共享的 Volume。Volume 也可以用来持久化 Pod 中的存储资源，以防容器重启后文件丢失。</p> 
<p><a name="_label3_3_0_2"></a></p> 
<h4 id="tid-PXz7GD">1.3 小结</h4> 
<p>每个 Pod 都有一个特殊的被称为 “基础容器” 的 Pause 容器。Pause 容器对应的镜像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包含一个或者多个紧密相关的用户应用容器。</p> 
<p><a name="_lab2_3_1"></a></p> 
<h3 id="tid-b3dRyd">2、Pause主要功能</h3> 
<p><strong>kubernetes 中的 pause 容器主要为每个容器提供以下功能：</strong></p> 
<ul><li>在 pod 中担任 Linux 命名空间（如网络命令空间）共享的基础</li><li>启用 PID 命名空间，开启 init 进程</li></ul> 
<p><a name="_lab2_3_2"></a></p> 
<h3 id="tid-k25TKZ">3、Pod 与 Pause 结构的设计初衷</h3> 
<ul><li>原因一：在一组容器作为一个单元的情况下，难以对整体的容器简单地进行判断及有效地进行行动。比如，一个容器死亡了，此时是算整体挂了么？那么引入与业务无关的Pause 容器作为 Pod 的基础容器，以它的状态代表着整个容器组的状态，这样就可以解决该问题。</li><li>原因二：Pod 里的多个应用容器共享 Pause 容器的 IP，共享 Pause 容器挂载的Volume，这样简化了应用容器之间的通信问题，也解决了容器之间的文件共享问题。<a name="_label4"></a></li></ul> 
<h2 id="tid-xi22PZ">五、Pod容器的分类</h2> 
<p><a name="_lab2_4_0"></a></p> 
<h3 id="tid-RjBAh3">1、基础容器（infrastructure container）</h3> 
<p>维护整个 Pod 网络和存储空间<br> node 节点中操作<br> 启动一个容器时，k8s会自动启动一个基础容器</p> 
<p><a name="_lab2_4_1"></a></p> 
<h3 id="tid-an4hD2">2、初始化容器（init container）</h3> 
<p>init运行四步：启动，运行，完成，退出</p> 
<p>Init 容器必须在应用程序容器启动之前运行完成，而应用程序容器是并行运行的，所以 Init 容器能够提供了一种简单的阻塞或延迟应用容器的启动的方法。Init 容器与普通的容器非常像，除了以下两点：</p> 
<p>Init 容器总是运行到成功完成为止<br> 每个 Init 容器都必须在下一个 Init 容器启动之前成功完成启动和退出<br> 如果 Pod 的 Init 容器失败，k8s 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的重启策略（restartPolicy）为 Never，它不会重新启动。</p> 
<p>Init 的容器作用</p> 
<p>因为 init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</p> 
<ul><li>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，没有必要仅为了在安装过程中使用类似 sed、 awk、python 或 dig 这样的工具而去 FROM 一个镜像来生成一个新的镜像。<br> Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。<br> 应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</li><li>Init 容器能以不同于 Pod 内应用容器的文件系统视图运行。因此，Init 容器可具有访问 Secrets的权限，而应用容器不能够访问。<br> 由于 Init 容器必须在应用容器启动之前运行完成，因此 Init容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。一旦前置条件满足，Pod 内的所有的应用容器会并行启动。</li></ul> 
<p><a name="_lab2_4_2"></a></p> 
<h3 id="tid-rZsYch">3、应用容器（main container）</h3> 
<p>应用容器会在 init 容器完成并退出后并行启动。<a name="_label5"></a></p> 
<h2 id="tid-NtCBn2">六、操作示例</h2> 
<p><a name="_lab2_5_0"></a></p> 
<h3 id="tid-Zcyrjr">1、编写myapp.yaml</h3> 
<pre><code>[root@master ~]# cat myapp.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh','-c','echo The app is running! &amp;&amp; sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh','-c','until nslookup myservice;do echo waiting for myservice; sleep2; done;']
  - name: init-mydb
    image: busybox:1.28
    command: ['sh','-c','until nslookup mydb; do echo waiting for mydb; sleep 2; done;']</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/93/89/tvRhmp3R_o.png"></p> 
<p>这个例子是定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 myservice 启动， 第二个等待 mydb 启动。一旦这两个 Init 容器都启动完成，Pod 将启动 spec 中的应用容器。  </p> 
<p><a name="_lab2_5_1"></a></p> 
<h3 id="tid-HmdxWr">2、创建myapp.yaml配置资源</h3> 
<pre><code>kubectl apply -f myapp.yaml
kubectl get pod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/62/vhh1KQ6u_o.png"></p> 
<p><a name="_lab2_5_2"></a></p> 
<h3 id="tid-5nyMmp">3、查看pod创建过程</h3> 
<pre><code>kubectl describe pod myapp-pod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/a2/vmS1wfUL_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f4/51/t1OP1XiW_o.png"></p> 
<p>发现开启 init-myservice 容器后，创建步骤停滞，<strong>查看 init-myservice 日志进一步查明原因。</strong></p> 
<p><a name="_lab2_5_3"></a></p> 
<h3 id="tid-h4sh6i">4、查看pod日志</h3> 
<pre><code>kubectl logs myapp-pod -c init-myservice</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f9/a0/7fUyJKwz_o.png"></p> 
<p><a name="_lab2_5_4"></a></p> 
<h3 id="tid-YsmCQA">5、编写myservice.yaml</h3> 
<pre><code>[root@master ~]# vim myservice.yaml

apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 1111</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/87/wfBG1SdR_o.png"></p> 
<p><a name="_lab2_5_5"></a></p> 
<h3 id="tid-Q8nbPF">6、创建 myservice.yaml 配置资源</h3> 
<pre><code>kubectl create -f myservice.yaml </code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/05/84/UNaJnufj_o.png"></p> 
<p><a name="_lab2_5_6"></a></p> 
<h3 id="tid-7mZc3G">7、编写mydb.yaml</h3> 
<pre><code>[root@master ~]# vim mydb.yaml

apiVersion: v1
kind: Service
metadata:
  name: mydb
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 2222</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e1/37/GQxviV7r_o.png"></p> 
<p><a name="_lab2_5_7"></a></p> 
<h3 id="tid-Wtbs4D">8、创建mydb.yaml配置资源</h3> 
<pre><code>kubectl create -f mydb.yaml
kubectl get pod,svc</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/86/0d/r41nKVrE_o.png"></p> 
<p><a name="_lab2_5_8"></a></p> 
<h3 id="tid-H75rQK">9、查看 myapp-pod 创建全过程</h3> 
<pre><code>kubectl describe pod myapp-pod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/be/tgba0xKb_o.png"></p> 
<ol><li>创建过程中第一次停滞，是 init-myservice 容器启动后，未能发现 myservice 域名，无法得到解析，因此陷入循环。</li><li>第二次停滞，是 init-mydb 容器启动后，未能发现 mydb 域名，无法得到解析，因此再次陷入循环中。</li><li>在上述两个 init 容器成功并退出后，myapp-pod 才开始创建，否则 pod 无法创建。</li></ol> 
<p><a name="_lab2_5_9"></a></p> 
<h3 id="tid-aSXm7D">10、小结</h3> 
<ol><li>在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。</li><li>如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 restartPolicy 指定的策略进行重试。然而，如果 Pod的 restartPolicy 设置为 Always，Init 容器失败时会使用 RestartPolicy 策略。</li><li>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态。Init 容器的端口将不会在 Service中进行聚集。正在初始化中的 Pod 处于 Pending 状态，但应该会将 Initializing 状态设置为 true。</li><li>如果 Pod 重启，所有 Init 容器必须重新执行。</li><li>对 Init 容器 spec 的修改被限制在容器 image 字段，修改其他字段都不会生效。更改 Init 容器的 image字段，等价于重启该 Pod。</li><li>Init 容器具有应用容器的所有字段。除了 readinessProbe，因为 Init容器无法定义不同于完成（completion）的就绪（readiness）之外的其他状态。这会在验证过程中强制执行。</li><li>在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。<a name="_label6"></a></li></ol> 
<h2 id="tid-SPx27z">七、镜像拉取策略（Image PullPolicy）</h2> 
<p>Pod的核心是运行容器，必须指定容器引擎，比如Docker,启动容器时需要拉取镜像，k8s的镜像拉取策略可以由用户指定：</p> 
<ul><li>IfNotPresent:在镜像已经存在的情况下，kubelet将不再去拉取镜像，仅当本地缺失时才会从仓库中拉取，默认的镜像拉取策略。</li><li>Alaways:每次创建Pod都会重新拉取一次镜像</li><li>Never:Pod不会主动拉取这个镜像，仅使用本地镜像。</li></ul> 
<p>注意：对于标签为latest的镜像文件，其默认的镜像获取策略即为Always；而对于其他标签的镜像，其默认策略则为IfNotPresent。</p> 
<p><a name="_lab2_6_0"></a></p> 
<h3 id="tid-eSaJKY">1、官方示例</h3> 
<p>创建使用私有镜像的 Pod 来验证</p> 
<pre><code>kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: private-image-test-1
spec:
  containers:
    - name: uses-private-image
      image: $PRIVATE_IMAGE_NAME
      imagePullPolicy: Always
      command: [ "echo", "SUCCESS" ]
EOF</code></pre> 
<p><strong>输出类似于</strong></p> 
<pre><code>pod/private-image-test-1 created</code></pre> 
<p><strong>如果一切顺利，那么一段时间后你可以执行</strong></p> 
<pre><code>kubectl logs private-image-test-1</code></pre> 
<p><strong>然后可以看到 SUCCESS，如果你怀疑命令失败了，可以运行</strong></p> 
<pre><code>kubectl describe pods/private-image-test-1 | grep 'Failed'</code></pre> 
<p><strong>如果命令确实失败了，输出类似于</strong></p> 
<pre><code>Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image "user/privaterepo:v1": Error: image user/privaterepo:v1 not found</code></pre> 
<ul><li>必须确保集群中所有节点的 .docker/config.json 文件内容相同。 否则 Pod会能在一些节点上正常运行而无法在另一些节点上启动。 例如，如果使用节点自动扩缩，那么每个实例模板都需要包含.docker/config.json，或者挂载一个包含该文件的驱动器。</li><li>在 .docker/config.json 中配置了私有仓库密钥后，所有 Pod 都将能读取私有仓库中的镜像。</li></ul> 
<p><a name="_lab2_6_1"></a></p> 
<h3 id="tid-Px7mft">2、不指定版本，查看默认拉取策略</h3> 
<p><a name="_label3_6_1_0"></a></p> 
<h4 id="tid-nQnRNi">2.1 不指定版本号创建pod</h4> 
<pre><code>kubectl run nginx-test1 --image=nginx</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/b0/9pQZ9HhR_o.png"></p> 
<p><a name="_label3_6_1_1"></a></p> 
<h4 id="tid-jTyj77">2.2 查看默认拉取策略</h4> 
<pre><code>kubectl edit pod nginx-test1</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/88/kh2aG6wr_o.png"></p> 
<p><a name="_label3_6_1_2"></a></p> 
<h4 id="tid-wPzcHp">2.3 查看创建过程</h4> 
<pre><code>kubectl describe pod nginx-test1</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/bb/UMAG5Gt4_o.png"></p> 
<p>由于拉取策略为Always,因此不管本地有没有对应镜像，kubectl都会前往共有仓库下载最新版本应用。</p> 
<p><a name="_lab2_6_2"></a></p> 
<h3 id="tid-YRXB7r">3、测试案例（非循环命令）</h3> 
<p><a name="_label3_6_2_0"></a></p> 
<h4 id="tid-56CaQX">3.1 创建测试案例mypod.yaml</h4> 
<pre><code>[root@master ~]# vim mypod.yaml 

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: nginx
      image: nginx
      imagePullPolicy: Always
      command: [ "echo","SUCCESS" ]</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/54/1a/WKIKMSPl_o.png"></p> 
<p><a name="_label3_6_2_1"></a></p> 
<h4 id="tid-rr8Qty">3.2 生成mypod配置资源</h4> 
<pre><code>kubectl create -f mypod.yaml
kubectl get pods</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/0c/V5dh79F5_o.png"></p> 
<p>该pod状态为CrashLoopBackOff，说明pod进入异常循环状态。原因是echo执行完进程终止，容器声明周期也就结束了。</p> 
<p><a name="_label3_6_2_2"></a></p> 
<h4 id="tid-2SyEJP">3.3 查看创建过程</h4> 
<pre><code>kubectl describe pod mypod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/28/17/vBymc7q1_o.png"></p> 
<p><strong>可以发现 Pod 中的容器在生命周期结束后，由于 Pod 的重启策略为 Always，容器再次重启了，并且又重新开始拉取镜像。</strong></p> 
<p><a name="_label3_6_2_3"></a></p> 
<h4 id="tid-rSarQe">3.4 修改mypod.yaml</h4> 
<p><strong>失败的状态的原因是因为命令启动冲突</strong><br> 删除 command: [ “echo”, “SUCCESS” ]<br><strong>同时更改一下版本</strong><br> image: nginx:1.14</p> 
<pre><code>vim mypod.yaml</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/73/18/haLxTQYn_o.png"></p> 
<p><a name="_label3_6_2_4"></a></p> 
<h4 id="tid-EKRD4P">3.5 删除原有资源</h4> 
<pre><code>kubectl delete -f mypod.yaml</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fe/71/vz0cgaGA_o.png"></p> 
<p><a name="_label3_6_2_5"></a></p> 
<h4 id="tid-TGnfMk">3.6 更新资源</h4> 
<pre><code>kubectl apply -f mypod.yaml

#查看分配节点
kubectl get pods -o wide</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/33/e2/PjQvIseQ_o.png"></p> 
<p><a name="_label3_6_2_6"></a></p> 
<h4 id="tid-GP3iis">3.7 在node1节点使用curl查看头部信息</h4> 
<pre><code>curl -I 10.244.1.18</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/56/21/o9uvzvL3_o.png"></p> 
<p><a name="_lab2_6_3"></a></p> 
<h3 id="tid-kjC2B6">4、测试案例（循环命令）</h3> 
<p><a name="_label3_6_3_0"></a></p> 
<h4 id="tid-66pAKf">4.1 修改mypod.yaml</h4> 
<pre><code>[root@master ~]# vim mypod.yaml 

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: nginx
      image: nginx
      imagePullPolicy: IfNotPresent
      command: [ "sh","while true;do echo SUCCESS;done" ]</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/49/0f/E7lBMRKZ_o.png"></p> 
<p><a name="_label3_6_3_1"></a></p> 
<h4 id="tid-6hGWF7">4.2 生成新的 mypod.yaml 配置资源</h4> 
<pre><code>#删除原有资源
kubectl delete -f mypod.yaml

#生成新的资源
kubectl apply -f mypod.yaml</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/81/DD2qxsVj_o.png"></p> 
<p><a name="_label3_6_3_2"></a></p> 
<h4 id="tid-j6ejew">4.3 查看pod状态</h4> 
<pre><code>kubectl get pod -o wide</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f4/3e/rb4MMzzp_o.png"></p> 
<p><a name="_label3_6_3_3"></a></p> 
<h4 id="tid-aiPCRW">4.4 查看创建过程</h4> 
<pre><code>kubectl describe pod mypod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0a/25/juGLw2wH_o.png"></p> 
<p><a name="_label3_6_3_4"></a></p> 
<h4 id="tid-xwPDs3">4.5 查看pod日志</h4> 
<pre><code>kubectl logs mypod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/dc/Hx3NcTgH_o.png"></p> 
<p><strong>发现是命令错误</strong></p> 
<p><a name="_label3_6_3_5"></a></p> 
<h4 id="tid-QNXbrA">4.6 检查mypod.yaml文件</h4> 
<pre><code>vim mypod.yaml</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/82/29/UyyGzZyp_o.png"></p> 
<p><a name="_label3_6_3_6"></a></p> 
<h4 id="tid-deYcRk">4.7 再次生成新的mypod.yaml配置资源</h4> 
<pre><code>#删除原有的资源
kubectl delete -f mypod.yaml

#生成新的资源
kubectl apply -f mypod.yaml

#查看pod状态
kubectl get pod -o wide</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/4f/3IEi0vil_o.png"></p> 
<p><a name="_label3_6_3_7"></a></p> 
<h4 id="tid-BKbSdj">4.8 查看创建过程</h4> 
<pre><code>kubectl describe pod mypod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0f/f8/JxwUbU60_o.png"></p> 
<p>由于镜像拉取策略设定的是 IfNotPresent，因此 kubelet 会先检查本地镜像仓库，如果有对应版本镜像就直接使用，没有的话才会前往镜像仓库拉取。</p> 
<p><a name="_label3_6_3_8"></a></p> 
<h4 id="tid-8ffY7N">4.9 查看pod日志</h4> 
<pre><code>kubectl logs mypod</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/de/28/cZxcetlN_o.png"></p> 
<p><a name="_lab2_6_4"></a></p> 
<h3 id="tid-m3SHC5">5、总结镜像拉取</h3> 
<p><strong>pod容器镜像拉取策略 (imagePullPolicy) 三种容器</strong></p> 
<ul><li>ifNotPresent: 优先使用本地已存在的镜像，如本地没有则从仓库拉取镜像，默认的拉取策略</li><li>Always: 总算是从仓库拉取镜像，无论本地是否已存在的镜像；标签为“latest”时，默认的拉取策略</li><li>Never:总是补充仓库拉取镜像，仅使用本地镜像</li></ul> 
<p><strong>镜像重启策略</strong></p> 
<ul><li>always:当容器终止退出后，总是重启容器，默认策略</li><li>ONEailure: 当容器异常退出时 (退出状态码非0) 时，重启容器:正常退出则不重启容器</li><li>Never:当容器终止退出，从不重启容器注意: k8s中不支持重启Pod资源，只有删除重建</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ce3e1b12680718f7e3622b1c0c04456/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fast_boot</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ee5fed19bcbe657b00bd21aeb8392ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">方格游戏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>