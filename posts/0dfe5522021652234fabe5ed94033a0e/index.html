<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android阅读器长按选择文字功能实现代码 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android阅读器长按选择文字功能实现代码" />
<meta property="og:description" content="前言： 有时候我们需要实现长按选择文字功能，比如阅读器一般都有这个功能，有时候某个自定义控件上可能就有这种需求，如何实现呢？正好最近还算闲，想完善一下自己写的那个轻量级的txt文件阅读器（比如这个长按选择文字的功能就想加进去）。于是花了两三天时间，实现了这个功能，效果还是不错的。
首先先看看效果图吧：
转载注务必明：http://blog.csdn.net/u014614038/article/details/74451484
授人以鱼不如授人以渔，下面具体实现原理的教程。‘
1.实现原理
原理其实也不难，简单总结就是：绘制文字时把显示的文字的坐标记录下来（记录文字的左上右上左下右下四个点坐标），作用就是为了计算滑动范围。执行了长按事件后，通过按的坐标，在当前显示的文字数据中根据点的坐标查找到按着的字，得到长按后选择的位置与文字。当执行滑动选择时，根据手指滑动的位置坐标与当前显示的文字数据匹配来确定选择的范围与文字。
2.具体实现
a.封装
为了便于操作，首先对显示可见的字符、显示的行数据进行封装。
ShowChar：
public class ShowChar {//可见字符数据封装
public char chardata ;//字符数据
public Boolean Selected =false;//当前字符是否被选中
public Point TopLeftPosition = null;
public Point TopRightPosition = null;
public Point BottomLeftPosition = null;
public Point BottomRightPosition = null;
public float charWidth = 0;//字符宽度
public int Index = 0;//当前字符位置
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
ShowLine ：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0dfe5522021652234fabe5ed94033a0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-09T18:19:43+08:00" />
<meta property="article:modified_time" content="2021-08-09T18:19:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android阅读器长按选择文字功能实现代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言： 有时候我们需要实现长按选择文字功能，比如阅读器一般都有这个功能，有时候某个自定义控件上可能就有这种需求，如何实现呢？正好最近还算闲，想完善一下自己写的那个轻量级的txt文件阅读器（比如这个长按选择文字的功能就想加进去）。于是花了两三天时间，实现了这个功能，效果还是不错的。</p> 
<p>首先先看看效果图吧：</p> 
<p>转载注务必明：http://blog.csdn.net/u014614038/article/details/74451484</p> 
<p>授人以鱼不如授人以渔，下面具体实现原理的教程。‘</p> 
<p>1.实现原理<br> 原理其实也不难，简单总结就是：绘制文字时把显示的文字的坐标记录下来（记录文字的左上右上左下右下四个点坐标），作用就是为了计算滑动范围。执行了长按事件后，通过按的坐标，在当前显示的文字数据中根据点的坐标查找到按着的字，得到长按后选择的位置与文字。当执行滑动选择时，根据手指滑动的位置坐标与当前显示的文字数据匹配来确定选择的范围与文字。</p> 
<p>2.具体实现<br> a.封装</p> 
<p>为了便于操作，首先对显示可见的字符、显示的行数据进行封装。</p> 
<p>ShowChar：</p> 
<p>public class ShowChar {//可见字符数据封装</p> 
<p>  public char chardata ;//字符数据<br>   public Boolean Selected =false;//当前字符是否被选中<br>   public Point TopLeftPosition = null;<br>   public Point TopRightPosition = null;<br>   public Point BottomLeftPosition = null;<br>   public Point BottomRightPosition = null;</p> 
<p>  public float charWidth = 0;//字符宽度<br>   public int Index = 0;//当前字符位置</p> 
<p><br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> ShowLine ：</p> 
<p>public class ShowLine {//显示的行数据<br>   public List&lt;ShowChar&gt; CharsData = null;</p> 
<p>  /**<br>    *@return<br>    *--------------------<br>    *TODO 获取该行的数据<br>    *--------------------<br>    */<br>   public String getLineData(){<!-- --><br>     String linedata = "";  <br>     if(CharsData==null||CharsData.size()==0) return linedata;<br>     for(ShowChar c:CharsData){<!-- --><br>       linedata = linedata+c.chardata;<br>     }<br>     return linedata;<br>   }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 说明：阅读器显示数据是一行一行的，每行都有不确定数量的字符，每个字符有自己的信息，比如字符宽度、字符在数据集合中的下标等。绘制时，通过绘制ShowLine 去绘制每行的数据。</p> 
<p>b.数据转化</p> 
<p>绘制前，我们需要先要把数据转化为上面封装的格式数据以便我们使用。这个要怎么做？因为我们需要将字符串转化为一行一行的数据，同时每个字符的字符宽度需要测量出来。如果对绘制比较熟悉的话，应该会知道系统有个paint.measureText可以用来测量字符的宽度，这里可以借助这个来实现测量字符的宽度，同时转化为我们想要行数据。 <br> 首先，写个方法，可以将传入的字符串转化为行数据：</p> 
<p> /**<br>    *@param cs <br>    *@param medsurewidth 行测量的最大宽度<br>    *@param textpadding 字符间距<br>    *@param paint 测量的画笔<br>    *@return 如果cs为空或者长度为0，返回null<br>    *--------------------<br>    *TODO <br>    *--------------------<br>    */<br>   public static BreakResult BreakText(char[] cs, float medsurewidth, float textpadding, Paint paint) {  <br>     if(cs==null||cs.length==0){return null;}<br>     BreakResult breakResult = new BreakResult();    <br>     breakResult.showChars = new ArrayList&lt;ShowChar&gt;();<br>     float width = 0;</p> 
<p>    for (int i = 0, size = cs.length; i &lt; size; i++) {<!-- --><br>       String mesasrustr = String.valueOf(cs[i]);<br>       float charwidth = paint.measureText(mesasrustr);</p> 
<p>      if (width &lt;= medsurewidth &amp;&amp; (width + textpadding + charwidth) &gt; medsurewidth) {<!-- --><br>         breakResult.ChartNums = i;<br>         breakResult.IsFullLine = true;<br>         return breakResult;<br>       }</p> 
<p>      ShowChar showChar = new ShowChar();<br>       showChar.chardata = cs[i];<br>       showChar.charWidth = charwidth;     <br>       breakResult.showChars.add(showChar);<br>       width += charwidth + textpadding;<br>     }</p> 
<p>    breakResult.ChartNums = cs.length;<br>     return breakResult;<br>   }</p> 
<p>public static BreakResult BreakText(String text, float medsurewidth, float textpadding, Paint paint) {<!-- --><br>     if (TextUtils.isEmpty(text)) {<!-- --><br>       int[] is = new int[2];<br>       is[0] = 0;<br>       is[1] = 0;<br>       return null;<br>     }<br>     return BreakText(text.toCharArray(), medsurewidth, textpadding, paint);</p> 
<p>  }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 说明： BreakResult 是对测量结果的简单封装：</p> 
<p>public class BreakResult {<!-- --></p> 
<p>  public int ChartNums = 0;//测量了的字符数<br>   public Boolean IsFullLine = false;//是否满一行了<br>   public List&lt;ShowChar&gt; showChars = null;//测量了的字符数据</p> 
<p>  public Boolean HasData() {<!-- --><br>     return showChars != null &amp;&amp; showChars.size() &gt; 0;<br>   }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 完成了上面的工作后，我们可以实现将我们显示的数据转化为需要的数据了。</p> 
<p>下面是我们测试显示的字符串：</p> 
<p>String TextData = "jEh话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉。汉朝自高祖斩白蛇而起义，一统天下，后来光武中兴，传至献帝，遂分为三国。推其致乱之由，殆始于桓、灵二帝。桓帝禁锢善类，崇信宦官。及桓帝崩，灵帝即位，大将军窦武、太傅陈蕃共相辅佐。时有宦官曹节等弄权，窦武、陈蕃谋诛之，机事不密，反为所害，中涓自此愈横"<br>       +</p> 
<p>  "建宁二年四月望日，帝御温德殿。方升座，殿角狂风骤起。只见一条大青蛇，从梁上飞将下来，蟠于椅上。帝惊倒，左右<br> 1<br> 2<br> 3<br> 4<br> 我们需要将这段字符串转化为行数据，在初始化数据的操作，下面是初始化数据的方法initData：</p> 
<p>List&lt;ShowLine&gt; mLinseData = null;</p> 
<p>  private void initData(int viewwidth, int viewheight) {<!-- --><br>     if (mLinseData == null) {<!-- --><br>       //将数据转化为行数据<br>       mLinseData = BreakText(viewwidth, viewheight);<br>     }</p> 
<p>  }</p> 
<p>  private List&lt;ShowLine&gt; BreakText(int viewwidth, int viewheight) {<!-- --><br>     List&lt;ShowLine&gt; showLines = new ArrayList&lt;ShowLine&gt;();<br>     while (TextData.length() &gt; 0) {<!-- --><br>       BreakResult breakResult = TextBreakUtil.BreakText(TextData, viewwidth, 0, mPaint);</p> 
<p>      if (breakResult != null &amp;&amp; breakResult.HasData()) {<!-- --><br>         ShowLine showLine = new ShowLine();<br>         showLine.CharsData = breakResult.showChars;<br>         showLines.add(showLine);</p> 
<p>      } else {<!-- --><br>         break;<br>       }</p> 
<p>      TextData = TextData.substring(breakResult.ChartNums);</p> 
<p>    }</p> 
<p>    int index = 0;<br>     for (ShowLine l : showLines) {<!-- --><br>       for (ShowChar c : l.CharsData) {<!-- --><br>         c.Index = index++;<br>       }<br>     }<br>     return showLines;<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 只要调用initData方法，我们就可以将TextData的数据转为显示的行数据Linedata集合mLinseData 。</p> 
<p>值得注意的是，调用这个方法需求知道控件的长宽，根据view的生命周期，我们可以在onmeasures里面调用这个方法进行初始化。</p> 
<p>@Override<br>   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {<!-- --><br>     super.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>     int viewwidth = getMeasuredWidth();<br>     int viewheight = getMeasuredHeight();<br>     initData(viewwidth, viewheight);<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 数据转化完成后，接着我们需要把数据一行一行的绘制出来：</p> 
<p>@Override<br>   protected void onDraw(Canvas canvas) {<!-- --><br>     super.onDraw(canvas);  </p> 
<p>    LineYPosition = TextHeight + LinePadding;//第一行显示的y坐标<br>     for (ShowLine line : mLinseData) {<!-- --><br>       DrawLineText(line, canvas);//绘制每一行，并记录每个字符的坐标<br>     }<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> DrawLineText方法：</p> 
<p>private void DrawLineText(ShowLine line, Canvas canvas) {<!-- --><br>     canvas.drawText(line.getLineData(), 0, LineYPosition, mPaint);</p> 
<p>    float leftposition = 0;<br>     float rightposition = 0;<br>     float bottomposition = LineYPosition + mPaint.getFontMetrics().descent;</p> 
<p>    for (ShowChar c : line.CharsData) {<!-- --><br>       rightposition = leftposition + c.charWidth;<br>       Point tlp = new Point();<br>       c.TopLeftPosition = tlp;<br>       tlp.x = (int) leftposition;<br>       tlp.y = (int) (bottomposition - TextHeight);</p> 
<p>      Point blp = new Point();<br>       c.BottomLeftPosition = blp;<br>       blp.x = (int) leftposition;<br>       blp.y = (int) bottomposition;</p> 
<p>      Point trp = new Point();<br>       c.TopRightPosition = trp;<br>       trp.x = (int) rightposition;<br>       trp.y = (int) (bottomposition - TextHeight);</p> 
<p>      Point brp = new Point();<br>       c.BottomRightPosition = brp;<br>       brp.x = (int) rightposition;<br>       brp.y = (int) bottomposition;<br>       leftposition = rightposition;</p> 
<p>    }<br>     LineYPosition = LineYPosition + TextHeight + LinePadding;<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 运行一下，目前显示效果如下：</p> 
<p>实现这些后，接下来需要实现长按选择功能以及滑动选择文字功能。如何实现长按呢，自己写肯定可以，只是也太麻烦了，所以我们这里借助系统提供的长按事件就可以。我实现的思路是这样的，首先先将事件处理模式分四种：</p> 
<p>private enum Mode {<!-- --></p> 
<p>    Normal, //正常模式<br>     PressSelectText,//长按选中文字<br>     SelectMoveForward, //向前滑动选中文字<br>     SelectMoveBack//向后滑动选中文字<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 在没有做任何处理情况下是Normal模式，如果手势发生了，Down事件触发，记录当前Down的坐标，如果用户一直按着，必然触发长按事件，模式转化为PressSelectText，通过记录的Down的坐标，去数据集合中找到当前长按的字符，绘画出选择的文字的背景。</p> 
<p>思路是这样，那么就干吧。首先注册长按事件，在初始化使注册该事件。</p> 
<p>private void init() {<!-- --><br>     mPaint = new Paint();<br>     mPaint.setAntiAlias(true);<br>     mPaint.setTextSize(29);</p> 
<p>    mTextSelectPaint = new Paint();<br>     mTextSelectPaint.setAntiAlias(true);<br>     mTextSelectPaint.setTextSize(19);<br>     mTextSelectPaint.setColor(TextSelectColor);</p> 
<p>    mBorderPointPaint = new Paint();<br>     mBorderPointPaint.setAntiAlias(true);<br>     mBorderPointPaint.setTextSize(19);<br>     mBorderPointPaint.setColor(BorderPointColor);</p> 
<p>    FontMetrics fontMetrics = mPaint.getFontMetrics();<br>     TextHeight = Math.abs(fontMetrics.ascent) + Math.abs(fontMetrics.descent);</p> 
<p>    setOnLongClickListener(mLongClickListener);</p> 
<p>  }<br> private OnLongClickListener mLongClickListener = new OnLongClickListener() {<!-- --></p> 
<p>    @Override<br>     public boolean onLongClick(View v) {<!-- --></p> 
<p>      if (mCurrentMode == Mode.Normal) {<!-- --><br>         if (Down_X &gt; 0 &amp;&amp; Down_Y &gt; 0) {// 说明还没释放，是长按事件<br>           mCurrentMode = Mode.PressSelectText;<br>           postInvalidate();//刷新<br>         }<br>       }<br>       return false;<br>     }<br>   };<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 这里 Down_X , Down_Y ; 初始化值都是-1，如果执行了down事件后它们肯定大于0，如果执行了Action_up事件，释放设置值为-1，只是为了判断使用而已。</p> 
<p>然后onDraw中需要判断一下并绘制选择的文字了。</p> 
<p>@Override<br>   protected void onDraw(Canvas canvas) {<!-- --><br>     super.onDraw(canvas);</p> 
<p>    LineYPosition = TextHeight + LinePadding;//第一行的y坐标<br>     for (ShowLine line : mLinseData) {<!-- --><br>       DrawLineText(line, canvas);//绘制每一<br>     }</p> 
<p>    if (mCurrentMode != Mode.Normal) {<!-- --><br>       DrawSelectText(canvas);//如果不是正常的话，绘制选择<br>     }<br>   }<br> private void DrawSelectText(Canvas canvas) {<!-- --><br>     if (mCurrentMode == Mode.PressSelectText) {<!-- --><br>       DrawPressSelectText(canvas);//绘制长按选择的字符<br>     } else if (mCurrentMode == Mode.SelectMoveForward) {//向前滑动选择<br>       DrawMoveSelectText(canvas);//绘制滑动时选择的文字背景<br>     } else if (mCurrentMode == Mode.SelectMoveBack) {//向后滑动选择<br>       DrawMoveSelectText(canvas);//绘制滑动时选择的文字背景<br>     }<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 这时如果执行了长按事件，mCurrentMode == Mode.PressSelectText，将执行绘制长按选择的字符。</p> 
<p>//绘制长按选中的数据<br> private void DrawPressSelectText(Canvas canvas) {<!-- --><br>     //根据按的坐标检测找到长按的字符<br>     ShowChar p = DetectPressShowChar(Down_X, Down_Y);</p> 
<p>    if (p != null) {// 找到了选择的字符<br>       FirstSelectShowChar = LastSelectShowChar = p;<br>       mSelectTextPath.reset();<br>       mSelectTextPath.moveTo(p.TopLeftPosition.x, p.TopLeftPosition.y);<br>       mSelectTextPath.lineTo(p.TopRightPosition.x, p.TopRightPosition.y);<br>       mSelectTextPath.lineTo(p.BottomRightPosition.x, p.BottomRightPosition.y);<br>       mSelectTextPath.lineTo(p.BottomLeftPosition.x, p.BottomLeftPosition.y);<br>       //绘制文字背景<br>       canvas.drawPath(mSelectTextPath, mTextSelectPaint);<br>       //绘制边界的线与指示块<br>       DrawBorderPoint(canvas);</p> 
<p>    }<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 检测点击点所在的字符方法：</p> 
<p>/**<br>    *@param down_X2<br>    *@param down_Y2<br>    *@return<br>    *--------------------<br>    *TODO 检测获取按压坐标所在位置的字符，没有的话返回null<br>    *--------------------<br>    */<br>   private ShowChar DetectPressShowChar(float down_X2, float down_Y2) {<!-- --></p> 
<p>    for (ShowLine l : mLinseData) {<!-- --><br>       for (ShowChar c : l.CharsData) {<!-- --><br>         if (down_Y2 &gt; c.BottomLeftPosition.y) {<!-- --><br>           break;// 说明是在下一行<br>         }<br>         if (down_X2 &gt;= c.BottomLeftPosition.x &amp;&amp; down_X2 &lt;= c.BottomRightPosition.x) {<!-- --><br>           return c;<br>         }</p> 
<p>      }<br>     }</p> 
<p>    return null;<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 基本上长按事件操作都完成了，我们运行长按文字看看效果：</p> 
<p>绘制了长按选择的字符后，我们需要实现按着左右的指示块进行左右或者上下滑动去选择文字。为了便于操作，向上滑动与向下滑动都有限制滑动范围，如下图：</p> 
<p>蓝色的区域是手指按着后触发允许滑动。按着左边的小蓝色区域，mCurrentMode == Mode.SelectMoveForward，允许向上滑动选择文字，就是手指滑动坐标滑动到黄色区域有效。按着右边的小蓝色区域，mCurrentMode == Mode.SelectMoveBack，允许向下滑动选择文字，就是手指滑动到绿色区域有效。 <br> 选择时，我们只会记录两个字符，就是选择的文字的开始字符与结束字符：</p> 
<p>private ShowChar FirstSelectShowChar = null;<br> private ShowChar LastSelectShowChar = null;<br> 1<br> 2<br> 注意的是当长按选择一个字符后：FirstSelectShowChar = LastSelectShowChar；</p> 
<p>所以整个过程是：滑动时，如果按着左边的蓝色区域，将允许向前滑动，这时mCurrentMode == Mode.SelectMoveForward，向前滑动即在黄色区域滑动，这时就可以根据手指滑动坐标找到滑动后的FirstSelectShowChar ，然后刷新界面。向下滑动同理。</p> 
<p>下面是代码实现：</p> 
<p>先在Action_Down里判断是向下滑动还是向下滑动，如果都不是，重置，使长按选择的文字恢复原样。</p> 
<p>case MotionEvent.ACTION_DOWN:<br>       Down_X = Tounch_X;<br>       Down_Y = Tounch_Y;</p> 
<p>      if (mCurrentMode != Mode.Normal) {<!-- --><br>         Boolean isTrySelectMove = CheckIfTrySelectMove(Down_X, Down_Y);</p> 
<p>        if (!isTrySelectMove) {// 如果不是准备滑动选择文字，转变为正常模式，隐藏选择框<br>           mCurrentMode = Mode.Normal;<br>           invalidate();<br>         }<br>       }</p> 
<p>      break;<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 在滑动时判断，如果是向上滑动，检测获取当前滑动时的FirstSelectShowChar ；如果是向下滑动，检测获取当前滑动时的LastSelectShowChar ，然后刷新界面。</p> 
<p>case MotionEvent.ACTION_MOVE:<br>       if (mCurrentMode == Mode.SelectMoveForward) {<!-- --><br>         if (CanMoveForward(event.getX(), event.getY())) {// 判断是否是向上移动<br>           ShowChar firstselectchar = DetectPressShowChar(event.getX(), event.getY());//获取当前滑动坐标的下的字符<br>           if (firstselectchar != null) {<!-- --><br>             FirstSelectShowChar = firstselectchar;<br>             invalidate();<br>           } </p> 
<p>        }</p> 
<p>      } else if (mCurrentMode == Mode.SelectMoveBack) {<!-- --></p> 
<p>        if (CanMoveBack(event.getX(), event.getY())) {// 判断是否可以向下移动         <br>           ShowChar lastselectchar = DetectPressShowChar(event.getX(), event.getY());//获取当前滑动坐标的下的字符<br>           if (lastselectchar != null) {<!-- --><br>             LastSelectShowChar = lastselectchar;<br>             invalidate();<br>           } </p> 
<p>        } <br>       }</p> 
<p>      break;<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 判断是否向上滑动方法：</p> 
<p>private boolean CanMoveForward(float Tounchx, float Tounchy) {<!-- --></p> 
<p>    Path p = new Path();<br>     p.moveTo(LastSelectShowChar.TopRightPosition.x, LastSelectShowChar.TopRightPosition.y);<br>     p.lineTo(getWidth(), LastSelectShowChar.TopRightPosition.y);<br>     p.lineTo(getWidth(), 0);<br>     p.lineTo(0, 0);<br>     p.lineTo(0, LastSelectShowChar.BottomRightPosition.y);<br>     p.lineTo(LastSelectShowChar.BottomRightPosition.x, LastSelectShowChar.BottomRightPosition.y);<br>     p.lineTo(LastSelectShowChar.TopRightPosition.x, LastSelectShowChar.TopRightPosition.y);</p> 
<p>    return computeRegion(p).contains((int) Tounchx, (int) Tounchy);<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 判断是否向下滑动：</p> 
<p>private boolean CanMoveBack(float Tounchx, float Tounchy) {<!-- --></p> 
<p>    Path p = new Path();<br>     p.moveTo(FirstSelectShowChar.TopLeftPosition.x, FirstSelectShowChar.TopLeftPosition.y);<br>     p.lineTo(getWidth(), FirstSelectShowChar.TopLeftPosition.y);<br>     p.lineTo(getWidth(), getHeight());<br>     p.lineTo(0, getHeight());<br>     p.lineTo(0, FirstSelectShowChar.BottomLeftPosition.y);<br>     p.lineTo(FirstSelectShowChar.BottomLeftPosition.x, FirstSelectShowChar.BottomLeftPosition.y);<br>     p.lineTo(FirstSelectShowChar.TopLeftPosition.x, FirstSelectShowChar.TopLeftPosition.y);</p> 
<p>    return computeRegion(p).contains((int) Tounchx, (int) Tounchy);<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> private Region computeRegion(Path path) {<!-- --><br>     Region region = new Region();<br>     RectF f = new RectF();<br>     path.computeBounds(f, true);<br>     region.setPath(path, new Region((int) f.left, (int) f.top, (int) f.right, (int) f.bottom));<br>     return region;<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 手势操作处理完成了，剩下的就是在ondraw时判断到mCurrentMode == Mode.SelectMoveForward或者mCurrentMode == Mode.SelectMoveBack绘制出选择的范围背景。</p> 
<p>private void DrawSelectText(Canvas canvas) {<!-- --><br>     if (mCurrentMode == Mode.PressSelectText) {<!-- --><br>       DrawPressSelectText(canvas);//绘制长按选择的字符<br>     } else if (mCurrentMode == Mode.SelectMoveForward) {//向前滑动选择<br>       DrawMoveSelectText(canvas);//绘制滑动时选择的文字背景<br>     } else if (mCurrentMode == Mode.SelectMoveBack) {//向后滑动选择<br>       DrawMoveSelectText(canvas);//绘制滑动时选择的文字背景<br>     }<br>   }<br> private void DrawMoveSelectText(Canvas canvas) {<!-- --><br>     if (FirstSelectShowChar == null || LastSelectShowChar == null)     return;<br>     GetSelectData();//获取选择字符的数据，转化为选择的行数据<br>     DrawSeletLines(canvas);//绘制选择的行数据<br>     DrawBorderPoint(canvas);//绘制出边界的方块或圆点<br>   }</p> 
<p>private void DrawSeletLines(Canvas canvas) <br>     DrawOaleSeletLinesBg(canvas);<br>   }</p> 
<p>  private void DrawOaleSeletLinesBg(Canvas canvas) {// 绘制椭圆型的选中背景<br>     for (ShowLine l : mSelectLines) {      <br>       if (l.CharsData != null &amp;&amp; l.CharsData.size() &gt; 0) {        <br>         ShowChar fistchar = l.CharsData.get(0);<br>         ShowChar lastchar = l.CharsData.get(l.CharsData.size() - 1);</p> 
<p>        float fw = fistchar.charWidth;<br>         float lw = lastchar.charWidth;</p> 
<p>        RectF rect = new RectF(fistchar.TopLeftPosition.x, fistchar.TopLeftPosition.y,<br>             lastchar.TopRightPosition.x, lastchar.BottomRightPosition.y);</p> 
<p>        canvas.drawRoundRect(rect, fw / 2,<br>              TextHeight / 2, mTextSelectPaint);</p> 
<p>      }<br>     }<br>   }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 基本完成了，运行一下，效果还是不错的。</p> 
<p>转载注务必明：http://blog.csdn.net/u014614038/article/details/74451484</p> 
<p>代码下载：github<br> ————————————————<br> 版权声明：本文为CSDN博主「楠之枫雪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/u014614038/article/details/74451484</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c97fe6146a459870862efdacafa5d253/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">300大作战不显示服务器,300大作战体验服进不去怎么办 体验服闪退解决方法详解...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81e251b4bd7a9cad0c1229ae611c375c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑录音,台式电脑如何录音_怎么电脑录音-win7之家</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>