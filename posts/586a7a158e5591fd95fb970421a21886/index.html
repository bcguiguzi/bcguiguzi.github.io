<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Retrofit详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Retrofit详解" />
<meta property="og:description" content="前言 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装
使用步骤 1.添加Retrofit库的依赖
implementation &#39;com.squareup.retrofit2:retrofit:2.0.2&#39; implementation &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39; implementation &#39;com.google.code.gson:gson:2.8.5&#39; implementation &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39; 后面三个是可选的，分别是数据解析器和gson，以及rxjava支持的依赖
2.创建 用于描述网络请求 的接口
Retrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数
public interface GetRequest_Interface { @GET(&#34;openapi.do?keyfrom=abc&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&#34;) Call&lt;Reception&gt; getCall(@Field(&#34;name&#34;) String name); // @GET注解的作用:采用Get方法发送网络请求 // getCall() = 接收网络请求数据的方法 // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt; } 3.创建Retrofit实例
Retrofit retrofit = new Retrofit.Builder() .baseUrl(&#34;http://fanyi.youdao.com/&#34;) //设置网络请求的Url地址 .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); 4.发送请求
请求分为同步请求和异步请求
// 创建 网络请求接口 的实例 GetRequest_Interface request = retrofit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/586a7a158e5591fd95fb970421a21886/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-12T00:54:00+08:00" />
<meta property="article:modified_time" content="2019-10-12T00:54:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Retrofit详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>前言</h4> 
<p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装</p> 
<h4><a id="_3"></a>使用步骤</h4> 
<p>1.添加Retrofit库的依赖</p> 
<pre><code>implementation 'com.squareup.retrofit2:retrofit:2.0.2'
 implementation 'com.squareup.retrofit2:converter-gson:2.0.2'
 implementation 'com.google.code.gson:gson:2.8.5'
implementation 'com.squareup.retrofit2:adapter-rxjava:2.0.2'
</code></pre> 
<p>后面三个是可选的，分别是数据解析器和gson，以及rxjava支持的依赖</p> 
<p>2.创建 用于描述网络请求 的接口<br> Retrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数</p> 
<pre><code>public interface GetRequest_Interface {

    @GET("openapi.do?keyfrom=abc&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car")
    Call&lt;Reception&gt; getCall(@Field("name") String name);
    // @GET注解的作用:采用Get方法发送网络请求
 
    // getCall() = 接收网络请求数据的方法
    // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）
    // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;
}
</code></pre> 
<p>3.创建Retrofit实例</p> 
<pre><code>Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("http://fanyi.youdao.com/") //设置网络请求的Url地址
                .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .build();
</code></pre> 
<p>4.发送请求<br> 请求分为同步请求和异步请求</p> 
<pre><code> // 创建 网络请求接口 的实例
  GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);
  //对 发送请求 进行封装
  Call&lt;Reception&gt; call = request.getCall("");
  call.enqueue(new Callback&lt;Reception&gt;() {
      //请求成功时回调
      @Override
      public void onResponse(Call&lt;Reception&gt; call, Response&lt;Reception&gt; response) {
          //请求处理,输出结果
          response.body().show();
      }
      //请求失败时候的回调
      @Override
      public void onFailure(Call&lt;Reception&gt; call, Throwable throwable) {
          System.out.println("连接失败");
      }
  });

    //同步请求
  try {
      Response&lt;Reception&gt; response = call.execute();
      response.body().show();
  } catch (IOException e) {
      e.printStackTrace();
  }
</code></pre> 
<p>response.body()就是Reception对象，网络请求的完整 Url =在创建Retrofit实例时通过.baseUrl()设置 +网络请求接口的注解设置（下面称 “path“ ）<br> 整合的规则如下：<br> <img src="https://images2.imgbox.com/04/c6/NiWvRcOT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_72"></a>注解</h4> 
<p>上面我们用了@GET注解来发送Get请求，Retrofit还提供了很多其他的注解类型<br> <img src="https://images2.imgbox.com/e0/59/9qbCj6bg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_76"></a>第一类：网络请求方法</h4> 
<p><img src="https://images2.imgbox.com/24/4b/T7bUcPWt_o.png" alt="在这里插入图片描述"></p> 
<p>1.@GET、@POST、@PUT、@DELETE、@HEAD分别对应 HTTP中的网络请求方式<br> 2.@HTTP替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展<br> 具体使用：通过属性method、path、hasBody进行设置</p> 
<pre><code>public interface GetRequest_Interface {
    /**
     * method：网络请求的方法（区分大小写）
     * path：网络请求地址路径
     * hasBody：是否有请求体
     */
    @HTTP(method = "GET", path = "blog/{id}", hasBody = false)
    Call&lt;ResponseBody&gt; getCall(@Path("id") int id);
    // {id} 表示是一个变量
    // method 的值 retrofit 不会做处理，所以要自行保证准确
}
</code></pre> 
<h4><a id="_96"></a>第二类：标记</h4> 
<p><img src="https://images2.imgbox.com/cc/7d/cIpZMD5W_o.png" alt="在这里插入图片描述"></p> 
<p>1.@FormUrlEncoded<br> 表示发送form-encoded的数据，每个键值对需要用@Filed来注解键名，随后的对象需要提供值。<br> 2.@Multipart<br> 表示发送form-encoded的数据（适用于 有文件 上传的场景），每个键值对需要用@Part来注解键名，随后的对象需要提供值。</p> 
<pre><code>public interface GetRequest_Interface {
        /**
         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值
         */
        @POST("/form")
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field("username") String name, @Field("age") int age);
         
        /**
         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
         */
        @POST("/form")
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload1(@Part("name") RequestBody name, @Part("age") RequestBody age, @Part MultipartBody.Part file);

}
</code></pre> 
<h4><a id="_124"></a>第三类：网络请求参数</h4> 
<p><img src="https://images2.imgbox.com/c7/2e/b4zqQ3kx_o.png" alt="在这里插入图片描述"></p> 
<p>1.@Header &amp; @Headers<br> 添加请求头 &amp;添加不固定的请求头</p> 
<pre><code>// @Header
@GET("user")
Call&lt;User&gt; getUser(@Header("Authorization") String authorization)

// @Headers
@Headers("Authorization: authorization")
@GET("user")
Call&lt;User&gt; getUser()

// 以上的效果是一致的。
// 区别在于使用场景和使用方式
// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头
// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法
</code></pre> 
<p>2.@Body<br> 以 Post方式 传递 自定义数据类型 给服务器,如果提交的是一个Map，那么作用相当于 @Field,不过Map要经过 FormBody.Builder 类处理成为符合 Okhttp 格式的表单，如：</p> 
<pre><code>FormBody.Builder builder = new FormBody.Builder();
builder.add("key","value");
</code></pre> 
<p>3.@Field &amp; @FieldMap<br> 发送 Post请求 时提交请求的表单字段,与 @FormUrlEncoded 注解配合使用</p> 
<pre><code>public interface GetRequest_Interface {
        /**
         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值
         */
        @POST("/form")
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field("username") String name, @Field("age") int age);

/**
         * Map的key作为表单的键
         */
        @POST("/form")
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);

}
</code></pre> 
<p>4.@Part &amp; @PartMap<br> 发送 Post请求 时提交请求的表单字段,与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景,与 @Multipart 注解配合使用</p> 
<pre><code>public interface GetRequest_Interface {

          /**
         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
         */
        @POST("/form")
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload1(@Part("name") RequestBody name, @Part("age") RequestBody age, @Part MultipartBody.Part file);

        /**
         * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，
         * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}
         * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt;
         */
        @POST("/form")
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file);

        @POST("/form")
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args);
}
</code></pre> 
<p>.@Query和@QueryMap<br> 用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）<br> 如：url = http://www.println.net/?cate=android，其中，Query = cate<br> 配置时只需要在接口方法中增加一个参数即可：</p> 
<pre><code>@GET("/")    
   Call&lt;String&gt; cate(@Query("cate") String cate);
}

// 其使用方式同 @Field与@FieldMap，这里不作过多描述
</code></pre> 
<p>6.@Path<br> URL地址的缺省值</p> 
<pre><code>public interface GetRequest_Interface {

        @GET("users/{user}/repos")
        Call&lt;ResponseBody&gt;  getBlog（@Path("user") String user ）;
        // 访问的API是：https://api.github.com/users/{user}/repos
        // 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用）
    }
</code></pre> 
<p>7.@Url<br> 直接传入一个请求的 URL变量 用于URL设置</p> 
<pre><code>public interface GetRequest_Interface {

        @GET
        Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query("showAll") boolean showAll);
       // 当有URL注解时，@GET传入的URL就可以省略
       // 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供

}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ccf99dd6cca764b83a17b64309ea681b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ofdm &#43; cp  python仿真</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d02ea07127514a29262da0b2369e07c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HDFS组成部分及作用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>