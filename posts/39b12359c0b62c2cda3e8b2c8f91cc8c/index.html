<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>rxjava创建方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="rxjava创建方法" />
<meta property="og:description" content="下面创建方法不需要手动再重新调用subscribe中的方法:
1.just()
创建发送指定值的Observeble,just只是简单的发射原样的值,将数组或iterable当做单个数据.如果传递的值为null,则发送的observeble的值为null.item最多为10个.
public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) { ObjectHelper.requireNonNull(item1, &#34;The first item is null&#34;); ObjectHelper.requireNonNull(item2, &#34;The second item is null&#34;); ObjectHelper.requireNonNull(item3, &#34;The third item is null&#34;); ObjectHelper.requireNonNull(item4, &#34;The fourth item is null&#34;); ObjectHelper.requireNonNull(item5, &#34;The fifth item is null&#34;); ObjectHelper.requireNonNull(item6, &#34;The sixth item is null&#34;); ObjectHelper.requireNonNull(item7, &#34;The seventh item is null&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/39b12359c0b62c2cda3e8b2c8f91cc8c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-19T11:28:55+08:00" />
<meta property="article:modified_time" content="2018-04-19T11:28:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rxjava创建方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下面创建方法不需要手动再重新调用subscribe中的方法:</p> 
<p>1.just()</p> 
<p>创建发送指定值的Observeble,just只是简单的发射原样的值,将数组或iterable当做单个数据.如果传递的值为null,则发送的observeble的值为null.item最多为10个.</p> 
<pre><code class="language-html">public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {
        ObjectHelper.requireNonNull(item1, "The first item is null");
        ObjectHelper.requireNonNull(item2, "The second item is null");
        ObjectHelper.requireNonNull(item3, "The third item is null");
        ObjectHelper.requireNonNull(item4, "The fourth item is null");
        ObjectHelper.requireNonNull(item5, "The fifth item is null");
        ObjectHelper.requireNonNull(item6, "The sixth item is null");
        ObjectHelper.requireNonNull(item7, "The seventh item is null");
        ObjectHelper.requireNonNull(item8, "The eighth item is null");
        ObjectHelper.requireNonNull(item9, "The ninth item is null");
        ObjectHelper.requireNonNull(item10, "The tenth item is null");

        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
    }</code></pre> 
<br> 
<p>2.</p> 
<pre style="background-color:rgb(193,240,255);font-family:'Source Code Pro';font-size:12pt;"><span style="background-color:#e4e4ff;">fromArray</span>()</pre> 
<p>将数据转换成Observeble,而不是需要混合使用Observeble和其他类型的数据</p> 
<pre><code class="language-html">public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items) {
        ObjectHelper.requireNonNull(items, "items is null");
        if (items.length == 0) {
            return empty();
        } else
        if (items.length == 1) {
            return just(items[0]);
        }
        return RxJavaPlugins.onAssembly(new ObservableFromArray&lt;T&gt;(items));
    }</code></pre> 
<p>3.repeat()</p> 
<p>重复执行某个操作,可设定次数,不设置次数则无限次数.</p> 
<pre><code class="language-java">public final Observable&lt;T&gt; repeat() {
        return repeat(Long.MAX_VALUE);
    }</code></pre> 
<pre><code class="language-html">public final Observable&lt;T&gt; repeat(long times) {
        if (times &lt; 0) {
            throw new IllegalArgumentException("times &gt;= 0 required but it was " + times);
        }
        if (times == 0) {
            return empty();
        }
        return RxJavaPlugins.onAssembly(new ObservableRepeat&lt;T&gt;(this, times));
    }</code></pre> 
<br> 
<br> 
<p>4.repeatWhen()</p> 
<p>不是缓存和重放原始observeble的数据序列,而是有条件的重新订阅和发射原来的observeble,当observeble中的call()方法中调用了重复执行的代码时,onNext()将会重复执行.如果该方法执行后返回void,则结束执行</p> 
<pre><code class="language-java">public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler) {
        ObjectHelper.requireNonNull(handler, "handler is null");
        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen&lt;T&gt;(this, handler));
    }</code></pre> 
<br> 
<p>5.range()</p> 
<p>根据输入的初始值n和总个数m,发射总数是m并大于n的值</p> 
<pre><code class="language-html">public static Observable&lt;Integer&gt; range(final int start, final int count) {
        if (count &lt; 0) {
            throw new IllegalArgumentException("count &gt;= 0 required but it was " + count);
        }
        if (count == 0) {
            return empty();
        }
        if (count == 1) {
            return just(start);
        }
        if ((long)start + (count - 1) &gt; Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Integer overflow");
        }
        return RxJavaPlugins.onAssembly(new ObservableRange(start, count));
    }</code></pre> 
<p>6.interval()</p> 
<p>在给定的时间间隔内发送指定次数的observeble</p> 
<pre><code class="language-html">public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit) {
        return interval(initialDelay, period, unit, Schedulers.computation());
    }</code></pre> 
<p>7.timer()</p> 
<p>延迟执行或者设置间隔执行</p> 
<pre><code class="language-html">public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) {
        return timer(delay, unit, Schedulers.computation());
    }</code></pre> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/323098562ac2cb6043a23bb4afa23147/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将window的location改为post提交</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/949da4f4851b45b3923c0dfcf32a1d26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[腾讯云] 租用服务器搭建网站</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>