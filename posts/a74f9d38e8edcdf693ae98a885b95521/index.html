<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vector及vector迭代器问题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vector及vector迭代器问题" />
<meta property="og:description" content="1.1 vector介绍 1.2 vector使用 1.2.1vector 的构造函数声明 1.2.2 vector迭代器的使用 1.2.3vector 的空间相关 1.2.4 vector的增删查改 2.1 vector迭代器问题 1.1 vector介绍： 1. vector是表示可变大小数组的序列容器。意思是，vecotr本质上类似一个数组，是一串连续的空间。
2.vector也采用的连续存储空间来存储元素，可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
3.vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小
为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
4.vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，这样就不用每次都要开辟空间，只有当额外的空间被占满，才会再次开辟更大的空间。 不同的库采用不同的策略权衡空间的使用和重新分配。
5.与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。
1.2 vector的使用 1.2.1vector 的构造函数声明 1.2.2 vector迭代器的使用 如下图
1.2.3vector 的空间相关 size()计算的是有效数据个数，capacity()是计算ve开辟的空间大小，不断增添数据，size()就慢慢增大知道size()==capacity()，就会进行增容，vector的增容为两倍；
resize\resver的使用 通过ve.size()改变ve的有效数据个数，ve.reserve()改变空间大小；
也可以使用ve.size()来增容，并且初始化新增的空间；原本有效数据为5，现在增加到10，新增的被初始化为2.
1.2.4 vector的增删查改 删除操作，不会导致缩容，对于系统而言，时间优先于空间，如果要缩容，必然会进行开辟空间，复制数据，交换地址等操作，这些操作会浪费时间，所以即使开辟的空间被删除到只剩一个数据，capacity依然不会变。
在第一个迭代器位置放两个2。
在第三个迭代器位置放一个3。
用ve.empty()判断是否ve为空，空则返回0，不为空返回1。
2.1 vector迭代器问题 举例，在v中偶数数据前放一个110，但结果却是错误，原因就在于迭代器出现了问题。
当迭代器到2的位置时，要插入110，所以将后面的数据都后移了一位，插入数据后，pos&#43;&#43;正好又来到2的位置，这时it迭代器失效，它的地址不在第一个迭代器和最后一个迭代器之间。
解决方案是，每次插入迭代器都有&#43;&#43;一下；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a74f9d38e8edcdf693ae98a885b95521/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-18T19:10:04+08:00" />
<meta property="article:modified_time" content="2022-07-18T19:10:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vector及vector迭代器问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.1 vector介绍</h3> 
<h3>1.2 vector使用</h3> 
<h4>    1.2.1vector 的构造函数声明</h4> 
<h4>    1.2.2 vector迭代器的使用</h4> 
<h4>    1.2.3vector 的空间相关</h4> 
<h4>    1.2.4 vector的增删查改</h4> 
<h3>2.1 vector迭代器问题</h3> 
<p>    </p> 
<h3>1.1 vector介绍：</h3> 
<p>    1. vector是表示可变大小数组的序列容器。意思是，vecotr本质上类似一个数组，是一串连续的空间。</p> 
<p>    2.vector也采用的连续存储空间来存储元素，可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p> 
<p>    3.vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小<br> 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</p> 
<p>    4.vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，这样就不用每次都要开辟空间，只有当额外的空间被占满，才会再次开辟更大的空间。 不同的库采用不同的策略权衡空间的使用和重新分配。</p> 
<p>    5.与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</p> 
<h4>1.2 vector的使用</h4> 
<h4>    1.2.1vector 的构造函数声明</h4> 
<p><img alt="" height="321" src="https://images2.imgbox.com/28/3d/NQHYQSg6_o.png" width="1171"></p> 
<h4> 1.2.2 vector迭代器的使用</h4> 
<p><img alt="" height="127" src="https://images2.imgbox.com/7f/46/geVEzCbN_o.png" width="1162"></p> 
<p>如下图<img alt="" height="401" src="https://images2.imgbox.com/f6/e0/VYLSOriB_o.png" width="832"></p> 
<h4> 1.2.3vector 的空间相关</h4> 
<p><img alt="" height="385" src="https://images2.imgbox.com/32/64/ozrsokM0_o.png" width="1170"></p> 
<p>size()计算的是有效数据个数，capacity()是计算ve开辟的空间大小，不断增添数据，size()就慢慢增大知道size()==capacity()，就会进行增容，vector的增容为两倍；</p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/ea/dd/BsYkTnIi_o.png" width="823"></p> 
<h4> resize\resver的使用</h4> 
<p><img alt="" height="151" src="https://images2.imgbox.com/6d/8c/kEZCmdbC_o.png" width="663"></p> 
<p> <img alt="" height="81" src="https://images2.imgbox.com/a0/7e/QXXS5Cin_o.png" width="474"></p> 
<p>通过ve.size()改变ve的有效数据个数，ve.reserve()改变空间大小；</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/5f/0b/X8dUEduP_o.png" width="740"></p> 
<p> 也可以使用ve.size()来增容，并且初始化新增的空间；原本有效数据为5，现在增加到10，新增的被初始化为2.<img alt="" height="455" src="https://images2.imgbox.com/3e/10/o8rVq5u6_o.png" width="764"></p> 
<h4> 1.2.4 vector的增删查改</h4> 
<p><img alt="" height="521" src="https://images2.imgbox.com/8b/f0/aDpXQf9d_o.png" width="1170"></p> 
<p>删除操作，不会导致缩容，对于系统而言，时间优先于空间，如果要缩容，必然会进行开辟空间，复制数据，交换地址等操作，这些操作会浪费时间，所以即使开辟的空间被删除到只剩一个数据，capacity依然不会变。</p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/5e/36/Y6S13Y64_o.png" width="781"></p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/5a/a5/qjpNzJTT_o.png" width="1168">在第一个迭代器位置放两个2。</p> 
<p>在第三个迭代器位置放一个3。</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/11/32/Dzi8JjhU_o.png" width="1042"></p> 
<p> 用ve.empty()判断是否ve为空，空则返回0，不为空返回1。<img alt="" height="433" src="https://images2.imgbox.com/a6/83/vdP1iAXb_o.png" width="699"></p> 
<p> <img alt="" height="88" src="https://images2.imgbox.com/15/ff/2N42AI6h_o.png" width="383"></p> 
<h3><img alt="" height="545" src="https://images2.imgbox.com/16/cf/jctxeHs3_o.png" width="991"> 2.1 vector迭代器问题</h3> 
<p>举例，在v中偶数数据前放一个110，但结果却是错误，原因就在于迭代器出现了问题。</p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/09/d9/SM2nzRPZ_o.png" width="1034"></p> 
<p> 当迭代器到2的位置时，要插入110，所以将后面的数据都后移了一位，插入数据后，pos++正好又来到2的位置，这时it迭代器失效，它的地址不在第一个迭代器和最后一个迭代器之间。<img alt="" height="151" src="https://images2.imgbox.com/66/fc/6onfbpzD_o.png" width="1051"></p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/b3/2e/eVTlpzGD_o.png" width="948"></p> 
<p> 解决方案是，每次插入迭代器都有++一下；</p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/b3/c1/Earr7DfQ_o.png" width="820"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09452efa30f68fced3349208803b6874/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【存储】Raid系列技术详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d644506ad6af22aca46dbf8492dd4b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将 ONLYOFFICE Docs 与 Nextcloud 进行集成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>