<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode: 数组中的第K个最大元素 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode: 数组中的第K个最大元素" />
<meta property="og:description" content="问题描述 在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。
解题思路 解决这个问题有多种方法，下面是几种常见的解题策略：
排序后选择: 将数组排序，然后选择第len(array) - k位置上的元素。优先队列(最小堆): 使用一个大小为k的最小堆，遍历数组维护堆的大小为k，堆顶即为第k个最大元素。快速选择(QuickSelect): 快速选择算法是快速排序的变体，用于找到未排序数组中第k个最大的元素。 代码示例 排序后选择 class Solution: def findKthLargest(self, nums, k): nums.sort() return nums[-k] 这种方法的时间复杂度为O(NlogN)，空间复杂度为O(1)（如果使用的是原地排序算法）。
优先队列(最小堆) import heapq class Solution: def findKthLargest(self, nums, k): heap = [] for num in nums: heapq.heappush(heap, num) if len(heap) &gt; k: heapq.heappop(heap) return heap[0] 这种方法的时间复杂度为O(NlogK)，空间复杂度为O(K)。
快速选择(QuickSelect) class Solution: def findKthLargest(self, nums, k): k = len(nums) - k def quickselect(l, r): pivot, p = nums[r], l for i in range(l, r): if nums[i] &lt;= pivot: nums[p], nums[i] = nums[i], nums[p] p &#43;= 1 nums[p], nums[r] = nums[r], nums[p] if p &gt; k: return quickselect(l, p - 1) if p &lt; k: return quickselect(p &#43; 1, r) return nums[p] return quickselect(0, len(nums) - 1) int partition(vector&lt;int&gt;&amp; nums,int left,int right) { int key = nums[left]; while(left &lt; right) { while(left &lt; right and nums[right] &gt;= key ) { right--; } nums[left] = nums[right] while(left &lt; right and nums[left] &lt;= key ) { left&#43;&#43;; } nums[right] = nums[left] } nums[left] = key; return left; } int findk(vector&lt;int&gt;&amp; nums) { random_shuffle(nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1aef1d325b2b7eab0afb3b26a316a42f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-01T14:54:36+08:00" />
<meta property="article:modified_time" content="2024-03-01T14:54:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode: 数组中的第K个最大元素</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5>问题描述</h5> 
<p>在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。</p> 
<h5>解题思路</h5> 
<p>解决这个问题有多种方法，下面是几种常见的解题策略：</p> 
<ol><li><strong>排序后选择</strong>: 将数组排序，然后选择第<code>len(array) - k</code>位置上的元素。</li><li><strong>优先队列(最小堆)</strong>: 使用一个大小为k的最小堆，遍历数组维护堆的大小为k，堆顶即为第k个最大元素。</li><li><strong>快速选择(QuickSelect)</strong>: 快速选择算法是快速排序的变体，用于找到未排序数组中第k个最大的元素。</li></ol> 
<h5>代码示例</h5> 
<h6>排序后选择</h6> 
<pre><code class="hljs">class Solution:
    def findKthLargest(self, nums, k):
        nums.sort()
        return nums[-k]
</code></pre> 
<p>这种方法的时间复杂度为O(NlogN)，空间复杂度为O(1)（如果使用的是原地排序算法）。</p> 
<h6>优先队列(最小堆)</h6> 
<pre><code class="hljs">import heapq

class Solution:
    def findKthLargest(self, nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) &gt; k:
                heapq.heappop(heap)
        return heap[0]
</code></pre> 
<p>这种方法的时间复杂度为O(NlogK)，空间复杂度为O(K)。</p> 
<h6>快速选择(QuickSelect)</h6> 
<pre><code class="hljs">class Solution:
    def findKthLargest(self, nums, k):
        k = len(nums) - k
        
        def quickselect(l, r):
            pivot, p = nums[r], l
            for i in range(l, r):
                if nums[i] &lt;= pivot:
                    nums[p], nums[i] = nums[i], nums[p]
                    p += 1
            nums[p], nums[r] = nums[r], nums[p]
            if p &gt; k: return quickselect(l, p - 1)
            if p &lt; k: return quickselect(p + 1, r)
            return nums[p]
        
        return quickselect(0, len(nums) - 1)
</code></pre> 
<pre><code class="hljs">int partition(vector&lt;int&gt;&amp; nums,int left,int right)
{
    int key = nums[left];
    while(left &lt; right)
    {
        while(left &lt; right and nums[right] &gt;= key )
        {
            right--;
        }
        nums[left] = nums[right]
        while(left &lt; right and nums[left] &lt;= key )
        {
            left++;
        }
        nums[right] = nums[left]
    }
    nums[left] = key; 
    return left;  
    
}

int findk(vector&lt;int&gt;&amp; nums)
{
    random_shuffle(nums.begin(),nums.end());
    int n = nums.size();
    int left = 0,rihgt = n-1;
    while(True)
    {
        int p = partition(nums,left,right);
        if(p == n-k)
        {return nums[p];}
        else if(p &gt; n-k)
        {
            right = p-1;
        }
        else
        {
            left = p +1;
        }
    }
    return -1;
}</code></pre> 
<p> </p> 
<p>快速选择的平均时间复杂度为O(N)，最坏情况下的时间复杂度为O(N^2)，空间复杂度为O(1)。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9523ae8a2db461711a6393da88a8b3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">easyexcel字体加粗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7fc6c16ed6a9119a2756fc1a642e337/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nginx出现 “414 request-uri too large”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>