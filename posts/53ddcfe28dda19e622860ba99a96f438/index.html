<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>进程间的通信方式之【管道】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="进程间的通信方式之【管道】" />
<meta property="og:description" content="进程间的通信方式主要分为三类：管道、共享内存、消息队列；但实际上进程的通信方式可以分为六类：管道、共享内存、消息队列、信号量、信号、socket套接字编程。
进程间通信的必要性： 1.进程在操作系统内核中是独立的进程控制块（PCB），即一个一个struct task_struct{....}结构体对象。
2.每一个进程有自己独立的进程地址空间，即进程间的数据是独立的，也就造就了进程间的独立性。
3.进程和进程间交换数据较困难，所以有了进程间通信来完成数据交换过程。
一、管道 匿名管道： 只能在单个进程内部进程通信，即父子进程。
pipe函数的认识： NAME
pipe, pipe2 - create pipe
SYNOPSIS
#include &lt;unistd.h&gt;
int pipe(int pipefd[2]);
DESCRIPTION
pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe.
RETURN VALUE
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
A. 管道函数成功调用会创建出来一个匿名管道，对应在内核中会有一个内核缓冲区
B. Pipefd是一个数组，数组有两个元素，分别对应管道的读写两端.
fd[0]：是管道的读端fd[1]：是管道的写端都是文件描述符 C. Pipefd这个参数是输出性参数，不需要程序员赋值.由Pipe函数在调用时赋值.
D.创建成功返回0，创建失败返回-1.
pipe函数使用： #include &lt;iostream&gt; #include &lt;unistd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/53ddcfe28dda19e622860ba99a96f438/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-06T15:13:46+08:00" />
<meta property="article:modified_time" content="2024-02-06T15:13:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">进程间的通信方式之【管道】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="ue0bb22d3">进程间的通信方式主要分为三类：管道、共享内存、消息队列；但实际上进程的通信方式可以分为六类：管道、共享内存、消息队列、信号量、信号、socket套接字编程。</p> 
<h2 id="Rpx7G">进程间通信的必要性：</h2> 
<p id="u64765a67">1.进程在操作系统内核中是独立的进程控制块（PCB），即一个一个struct task_struct{....}结构体对象。</p> 
<p id="u4ca50320"></p> 
<p class="img-center"><img alt="" height="180" id="u69137315" src="https://images2.imgbox.com/ec/d3/TQ7qHffZ_o.png" width="893"></p> 
<p id="ub10cc825">2.每一个进程有自己独立的进程地址空间，即进程间的数据是独立的，也就造就了进程间的独立性。</p> 
<p id="u55072b14">3.进程和进程间交换数据较困难，所以有了进程间通信来完成数据交换过程。</p> 
<h2 id="mc3c0">一、管道</h2> 
<h3 id="chEfr">匿名管道：</h3> 
<p id="u2376ceae">只能在单个进程内部进程通信，即父子进程。</p> 
<h4 id="AqTT6">pipe函数的认识：</h4> 
<blockquote> 
 <p id="u8d02c565">NAME</p> 
 <p id="u0b0baa69">        pipe, pipe2 - create pipe</p> 
 <p id="u1b72eed3">SYNOPSIS</p> 
 <p id="ub8a06efc">        #include &lt;unistd.h&gt;</p> 
 <p id="u28119b9a">        int pipe(int pipefd[2]);</p> 
 <p id="u1a947b15">DESCRIPTION</p> 
 <p id="u55de2a39">        pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe.<br> RETURN VALUE</p> 
 <p id="ue9635b72">        On success, zero is returned. On error, -1 is returned, and errno is set appropriately.</p> 
</blockquote> 
<p id="ue7c3d885">A. 管道函数成功调用会创建出来一个匿名管道，对应在内核中会有一个内核缓冲区</p> 
<p id="u9643b877">B. Pipefd是一个数组，数组有两个元素，分别对应管道的读写两端.</p> 
<ol><li id="ua2946019">fd[0]：是管道的读端</li><li id="u0b0703da">fd[1]：是管道的写端</li><li>都是文件描述符</li></ol> 
<p id="ue6e451ca">C. Pipefd这个参数是输出性参数，不需要程序员赋值.由Pipe函数在调用时赋值.</p> 
<p id="u649b1217">D.创建成功返回0，创建失败返回-1.</p> 
<h4 id="zSpM3">pipe函数使用：</h4> 
<pre id="R1XaB"><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main(){
    int fd[2];
    int ret = pipe(fd);

    if(ret &lt; 0){
        perror("pipe error");
        exit(-1);
    }

    // success
    printf("read fd[0]: %d\n", fd[0]);
    printf("write fd[1]: %d\n", fd[1]);

    return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="86" id="u78f14e50" src="https://images2.imgbox.com/20/34/enZyqWMf_o.png" width="666"></p> 
<p id="uefb0f128">结果显示读端fd[0] 是3，写端fd[1]是4，对应也是的文件描述符，因为0，1，2分别是标准输入、输出、错误所占用了。</p> 
<p class="img-center"><img alt="" height="558" id="u3cd0add0" src="https://images2.imgbox.com/ff/7b/1GaeVOji_o.png" width="707"></p> 
<p id="u2cacbfa3">验证：</p> 
<p id="u2eec1449">在原代码的基础上，加一个while死循环，查看该进程的pid，然后进行在查看该进程下的文件描述符，可以看到存在3、4号fd：</p> 
<blockquote> 
 <p id="u4f82560d">$ ll /proc/[pid]/fd</p> 
</blockquote> 
<p id="ucbb2c59e"></p> 
<p class="img-center"><img alt="" height="422" id="u16df7ea6" src="https://images2.imgbox.com/6c/2f/cuk9FGA3_o.png" width="1123"></p> 
<p id="u883c7e71">读写验证：</p> 
<pre id="d6ZhB"><code class="language-cpp">int main(){
    int fd[2];
    int ret = pipe(fd);

    if(ret &lt; 0){
        perror("pipe error");
        exit(-1);
    }

    // success
    printf("read fd[0]: %d\n", fd[0]);
    printf("write fd[1]: %d\n", fd[1]);
    
    write(fd[1], "hello", 5);

    char buf[1024] = {0};
    read(fd[0], buf, sizeof(buf) - 1);
    printf("buf: %s\n", buf);

    return 0;
}</code></pre> 
<p id="u4abf73cc"></p> 
<p class="img-center"><img alt="" height="83" id="uf906e044" src="https://images2.imgbox.com/d4/94/WMUselcd_o.png" width="662"></p> 
<p id="ud57a602f">通过write往fd[1]写入了“hello”，然后使用read从fd[0]读出内容。</p> 
<h4 id="OYPxA">父子进程匿名管道</h4> 
<p id="u4fc9896a">父子进程间是共享的同一个文件描述符，所以使用匿名管道，可以实现父子进程间的通信。</p> 
<pre id="cqp1v"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main(){
    int fd[2];
    int ret = pipe(fd);

    if(ret &lt; 0){
        perror("pipe error");
        exit(-1);
    }

    // success
    printf("read fd[0]: %d\n", fd[0]);
    printf("write fd[1]: %d\n", fd[1]);
    
    ret = fork();
    if(ret &lt; 0){
      perror("fork fail");
      exit(-1);
    }
    else if(ret == 0){
        // 父进程写
      write(fd[1], "hello", 5);
    }
    else{
        // 子进程读
      char buf[1024] = {0};
      read(fd[0], buf, sizeof(buf) - 1);
      printf("buf : %s\n", buf);
    }
    

    return 0;
}
</code></pre> 
<h3 id="zuBCd">命名管道：</h3> 
<ul><li id="u9447c2f0">如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为命名管道。</li><li id="ud92bcd43">命名管道是一种特殊类型的文件</li></ul> 
<blockquote> 
 <p id="ud6b1d636"><strong>使用指令创建：</strong><br> $ mkfifo filename</p> 
</blockquote> 
<p id="ue8bbc184"><strong>使用程序代码创建：</strong></p> 
<blockquote> 
 <p id="u6d1fa87b">函数： int mkfifo(const char *filename,mode_t mode);<br> 例如：</p> 
 <p id="u34c5546a">int main(int argc, char *argv[])<br> {<!-- --><br> mkfifo("p2", 0644);<br> return 0;<br> }</p> 
</blockquote> 
<p id="ue94d6857"><strong>命名管道打开方式：</strong></p> 
<p id="uc0ca87f5">使用open函数</p> 
<p id="ufb49c6f9"><strong>命名管道的打开规则</strong><br> 如果当前打开操作是为读而打开FIFO时<br> O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO<br> O_NONBLOCK enable：立刻返回成功<br> 如果当前打开操作是为写而打开FIFO时<br> O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO<br> O_NONBLOCK enable：立刻返回失败，错误码为ENXIO</p> 
<p id="u999f366b"><strong>验证：</strong></p> 
<p id="uba111ad4">使用mkfifo指令创建一个管道mypipo</p> 
<p id="uf1605a76"></p> 
<p class="img-center"><img alt="" height="69" id="ufc83d414" src="https://images2.imgbox.com/bd/b0/PfkrvX1t_o.png" width="549"></p> 
<p id="u5adad378">使用<code><span style="background-color:#38d8f0;">cat &lt; mypipo</span></code>读取管道中的数据</p> 
<p id="u71a978fd">使用如下代码往管道内写如数据：</p> 
<pre id="f4SHi"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main(){
  // ./mypipo表示打开这个管道文件
  int outfd = open("./mypipo", O_WRONLY);
  write(outfd, "hello\n", 6);
  close(outfd);
  return 0;
}
</code></pre> 
<p id="u0a5f8dec"></p> 
<p class="img-center"><img alt="" height="199" id="u02fd21fb" src="https://images2.imgbox.com/ab/5d/r6XYVgFQ_o.png" width="1093"></p> 
<p>一个进程往mkfifo创建的管道写入数据，另一个进程可用从这个管道读出数据。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b769e954e239e00174ed86ee92645ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">window使用gdb调试qemu调试裸机程序步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b2a02028cc5eaa21fb3d995a961d7f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea设置自动编译spring boot代码，idea代码修改后无须重启服务立即生效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>