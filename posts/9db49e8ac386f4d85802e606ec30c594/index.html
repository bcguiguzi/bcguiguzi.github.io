<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;动态内存管理之智能指针 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;动态内存管理之智能指针" />
<meta property="og:description" content="前言 动态内存管理引起的所谓内存泄漏的问题是编程领域的一大顽疾，它的成因非常直截了当---“只拿不还”，但它产生的缘由有时却非常隐晦需要非常仔细布局你的每一行代码才能抵抗它们对你的系统的侵蚀。而智能指针就能解决上面的问题，它的主要的功能就是自动帮我们管理内存。
一、智能指针 1、智能指针主要解决以下问题
内存泄漏：内存手动释放，使用智能指针可以自动释放 共享所有权指针的传播和释放，比如多线程使用同一个对象时析构问题 2、 智能指针的类型（其中后三个是C&#43;&#43;11支持，并且第一个auto_ptr已经被C&#43;&#43;11弃用） auto_ptr shared_ptr 共享对象的所有权，但性能略差。unique_ptr 独占对象的所有权，由于没有引用计数，因此性能较好。 weak_ptr 配合shared_ptr，解决循环引用的问题 3、智能指针的使用
3.1 shared_ptr
3.1.1 内存模型：
shared_ptr 内部包含两个指针，一个指向对象，另一个指向控制块 (control block) ，控制块中包含一个引用计数(reference count), 一个弱计数 (weak count)和其它一些数据，内存模型如下图1。 std::shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存，每拷贝一次引用计数reference count就加1，每一次析构就减1。再最后一个shared_ptr析构的时候，内存才会被释放。 shared_ptr共享被管理对象，同一时刻可以有多个shared_ptr拥有对象的所有权，当最后一个 shared_ptr对象销毁时，被管理对象自动销毁。 图 1 3.1.1 基本用法和函数
shared_ptr的初始化
// 初始化的三种方式，优选第1 和第 2种，因为 make_shared是 构造函数，更高效 auto s = make_shared &lt; int &gt; ( 100 ); shared_ptr &lt; int &gt; s = make_shared &lt; int &gt; ( 100 ); shared_ptr &lt; int &gt; sp1 ( new int ( 100 )); //不能将一个原始指针直接赋值给一个智能指针，例如，下面这种方法是错误的： std::shared_ptr &lt; int &gt; p = new int ( 1 ); shared_ptr的常用函数 s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9db49e8ac386f4d85802e606ec30c594/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-18T12:35:34+08:00" />
<meta property="article:modified_time" content="2022-10-18T12:35:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;动态内存管理之智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>        动态内存管理引起的所谓<strong>内存泄漏</strong>的问题是编程领域的<strong>一大顽疾</strong>，它的成因非常直截了当---<strong>“</strong><strong>只拿不还”，</strong>但它产生的缘由有时却非常隐晦需要非常仔细布局你的每一行代码才能抵抗它们对你的系统的侵蚀。而智能指针就能解决上面的问题，它的主要的功能就是自动帮我们<strong>管理内存。</strong></p> 
<h2><span style="color:#333333;"><strong>一、智能指针</strong></span></h2> 
<p><strong><span style="color:#333333;">1、智能指针主要解决以下问题</span></strong></p> 
<ul><li><span style="color:#333333;">内存泄漏：内存手动释放，使用智能指针可以自动释放 </span></li><li><span style="color:#333333;">共享所有权指针的传播和释放，比如多线程使用同一个对象时析构问题 </span></li></ul> 
<p></p> 
<div> 
 <strong><span style="color:#333333;">2、 </span>智能指针的类型（<span style="color:#333333;">其中后三个是</span><span style="color:#333333;">C++11支持，并且第一个auto_ptr已经被C++11弃用</span>）</strong> 
</div> 
<ul><li><s><span style="color:#333333;">auto_ptr </span></s></li><li><span style="color:#333333;">shared_ptr  共享对象的所有权，但性能略差。</span></li><li><span style="color:#333333;">unique_ptr   </span><span style="color:#333333;">独占对象的所有权，由于没有引用计数，因此性能较好。 </span></li><li><span style="color:#333333;">weak_ptr     配合</span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">，解决循环引用的问题</span></li></ul> 
<p><strong>3、<span style="color:#333333;">智能指针的使用</span></strong></p> 
<p><strong><span style="color:#333333;">3.1 </span><span style="color:#333333;">shared_ptr</span></strong></p> 
<p><strong><span style="color:#333333;">3.1.1 内存模型：</span></strong></p> 
<div> 
 <span style="color:#333333;">shared_ptr </span> 
 <span style="color:#333333;">内部包含两个指针，一个指向对象，另一个指向控制块</span> 
 <span style="color:#333333;">(control block)</span> 
 <span style="color:#333333;">，控制块中包含一个引用计数(reference count), </span> 
 <span style="color:#333333;">一个弱计数</span> 
 <span style="color:#333333;">(weak count)和其它一些数据，</span>内存模型如下图1。 
</div> 
<p></p> 
<ul><li><span style="color:#333333;"><strong>std::shared_ptr</strong></span><span style="color:#333333;">使用引用计数，每一个</span><span style="color:#333333;">shared_ptr的拷贝都指向相同的内存，每拷贝一次引用计数reference count就加1，每一次析构就减1。再最后一个shared_ptr析构的时候，内存才会被释放。 </span></li><li><span style="color:#333333;">shared_ptr共享被管理对象，同一时刻可以有多个</span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">拥有对象的所有权，当最后一个 </span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">对象销毁时，被管理对象自动销毁。 </span></li></ul> 
<figure class="image"> 
 <img alt="" height="377" src="https://images2.imgbox.com/46/29/O4OVj7mB_o.png" width="832"> 
 <figcaption>
   图 1 
 </figcaption> 
</figure> 
<p><strong>3.1.1 基本用法和函数</strong></p> 
<p><strong><span style="color:#333333;">shared_ptr的初始化</span></strong></p> 
<blockquote> 
 <p></p> 
 <div>
   // 
  <span style="color:#333333;">初始化的三种方式，优选第1 和第 2种，因为</span> 
  <span style="color:#000000;">make_shared是</span> 
  <span style="color:#333333;">构造函数，更高效</span> 
 </div> 
 <div> 
  <span style="color:#770088;">auto </span> 
  <span style="color:#000000;">s </span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#000000;">make_shared</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt;</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#116644;">100</span> 
  <span style="color:#333333;">); </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000;">shared_ptr</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt; </span> 
  <span style="color:#000000;">s</span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#000000;">make_shared</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt;</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#116644;">100</span> 
  <span style="color:#333333;">);</span> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#000000;">shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#0000ff;">sp1</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#116644;">100</span> 
   <span style="color:#333333;">)); </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">//不能将一个原始指针直接赋值给一个智能指针，例如，下面这种方法是错误的：</span> 
  </div> 
  <div> 
   <span style="color:#000000;">std::shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">p </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#116644;">1</span> 
   <span style="color:#333333;">); </span> 
  </div> 
 </div> 
</blockquote> 
<p><strong><span style="color:#333333;">shared_ptr的常用函数</span></strong> </p> 
<ul><li><span style="color:#333333;"><strong>s.get()</strong>：              功能：返回shared_ptr</span><span style="color:#333333;">中保存的裸指针； </span></li><li> 
  <div> 
   <span style="color:#333333;"><strong>s.use_count()</strong> ：功能：返回shared_ptr</span> 
   <span style="color:#333333;">的强引用计数； </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;"><strong>s.unique() ：</strong>      功能：若use_count()</span> 
   <span style="color:#333333;">为</span> 
   <span style="color:#333333;">1</span> 
   <span style="color:#333333;">，返回</span> 
   <span style="color:#333333;">true</span> 
   <span style="color:#333333;">，否则返回</span> 
   <span style="color:#333333;">false</span> 
   <span style="color:#333333;">。</span> 
  </div> </li><li><span style="color:#333333;"><strong>s.reset(…)</strong></span><span style="color:#333333;">：       功能：重置</span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">； </span> 
  <ul><li><span style="color:#333333;">reset( )</span><span style="color:#333333;">不带参数时，若智能指针</span><span style="color:#333333;">s</span><span style="color:#333333;">是唯一指向该对象的指针，则释放，并置空。若智能指针</span><span style="color:#333333;">P</span><span style="color:#333333;">不是唯一指向该对象的指针，则引用计数减少1</span><span style="color:#333333;">，同时将</span><span style="color:#333333;">P</span><span style="color:#333333;">置空。 </span></li><li><span style="color:#333333;">reset( )</span><span style="color:#333333;">带参数时，若智能指针</span><span style="color:#333333;">s</span><span style="color:#333333;">是唯一指向对象的指针，则释放并指向新的对象。若</span><span style="color:#333333;">P</span><span style="color:#333333;">不是唯一的指针，则只减少引用计数，并指向新的对象。如： </span></li></ul></li></ul> 
<blockquote> 
 <p></p> 
 <div> 
  <span style="color:#770088;">auto </span> 
  <span style="color:#000000;">s </span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#000000;">make_shared</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt;</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#116644;">100</span> 
  <span style="color:#333333;">); </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000;">s</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">reset</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#770088;">new </span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#116644;">200</span> 
  <span style="color:#333333;">));</span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;"><strong>获取原始指针</strong></span> 
 <span style="color:#333333;"><strong>get</strong></span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#000000;">std::shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#0000ff;">ptr</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#116644;">1</span> 
   <span style="color:#333333;">)); </span> 
  </div> 
  <div> 
   <span style="color:#008855;">int *</span> 
   <span style="color:#000000;">p </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">ptr</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#000000;">get</span> 
   <span style="color:#333333;">(); </span> 
   <span style="color:#aa5500;">// </span> 
  </div> 
  <div> 
   <span style="color:#770088;">delete </span> 
   <span style="color:#000000;">p</span> 
   <span style="color:#333333;">;                         //</span> 
   <span style="color:#000000;">不小心释放 </span> 
   <span style="color:#333333;">就会造成double free错误</span> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#333333;">p.get()</span></strong> 
   <span style="color:#333333;"><strong>的返回值就相当于一个裸指针的值​​​​​​​，谨慎使用p.get()</strong></span> 
   <span style="color:#333333;"><strong>的返回值</strong></span> 
  </div> 
 </div> 
</blockquote> 
<div> 
 <ul><li><span style="color:#333333;">不要保存</span><span style="color:#333333;">p.get()</span><span style="color:#333333;">的返回值 ，无论是保存为裸指针还是</span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">都是错误的 </span></li><li><span style="color:#333333;">保存为裸指针不知什么时候就会变成空悬指针，保存为</span><span style="color:#333333;">shared_ptr</span><span style="color:#333333;">则产生了独立指针 </span></li><li><span style="color:#333333;">不要</span><span style="color:#333333;">delete p.get()</span><span style="color:#333333;">的返回值 ，会导致对一块内存</span><span style="color:#333333;">delete</span><span style="color:#333333;">两次的错误 </span></li></ul> 
 <p><span style="color:#333333;"><strong>指定删除器 </strong></span></p> 
 <p><span style="color:#333333;">如果用shared_ptr</span><span style="color:#333333;">管理非</span><span style="color:#333333;">new</span><span style="color:#333333;">对象或是没有析构函数的类时，应当为其传递合适的删除器。</span></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

void DeleteIntPtr(int *p) {
    cout &lt;&lt; "call DeleteIntPtr" &lt;&lt; endl;
    delete p;
}

int main()
{
    std::shared_ptr&lt;int&gt; p(new int(1), DeleteIntPtr);
    return 0;
}</code></pre> 
 <div> 
  <span style="color:#333333;">当</span> 
  <span style="color:#333333;">p</span> 
  <span style="color:#333333;">的引用计数为</span> 
  <span style="color:#333333;">0</span> 
  <span style="color:#333333;">时，自动调用删除器</span> 
  <span style="color:#333333;">DeleteIntPtr</span> 
  <span style="color:#333333;">来释放对象的内存。删除器可以是一个</span> 
  <span style="color:#333333;">lambda</span> 
  <span style="color:#333333;">表达式，上面的写法可以改为：</span> 
 </div> 
 <blockquote> 
  <div> 
   <div> 
    <span style="color:#000000;">std::shared_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#981a1a;">&gt; </span> 
    <span style="color:#0000ff;">p</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#770088;">new </span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#116644;">1</span> 
    <span style="color:#333333;">), [](</span> 
    <span style="color:#008855;">int *</span> 
    <span style="color:#000000;">p</span> 
    <span style="color:#333333;">) { </span> 
   </div> 
   <div> 
    <span style="color:#000000;">        cout </span> 
    <span style="color:#981a1a;">&lt;&lt; </span> 
    <span style="color:#aa1111;">"call lambda delete p" </span> 
    <span style="color:#981a1a;">&lt;&lt; </span> 
    <span style="color:#000000;">endl</span> 
    <span style="color:#333333;">; </span> 
   </div> 
   <div> 
    <span style="color:#770088;">        delete </span> 
    <span style="color:#000000;">p</span> 
    <span style="color:#333333;">;</span> 
   </div> 
   <div> 
    <span style="color:#333333;">});</span> 
   </div> 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#333333;">当我们用</span> 
 <span style="color:#333333;">shared_ptr</span> 
 <span style="color:#333333;">管理动态数组时，需要指定删除器，</span> 
 <span style="color:#333333;"><strong>因为</strong></span> 
 <span style="color:#333333;"><strong>shared_ptr</strong></span> 
 <span style="color:#333333;"><strong>的默认删除器不支持数组对</strong></span> 
 <span style="color:#333333;"><strong>象</strong></span> 
 <span style="color:#333333;">，代码如下所示：</span> 
</div> 
<blockquote> 
 <p> <span style="color:#000000;">std::shared_ptr</span><span style="color:#981a1a;">&lt;</span><span style="color:#008855;">int</span><span style="color:#981a1a;">&gt; </span><span style="color:#0000ff;">p3</span><span style="color:#333333;">(</span><span style="color:#770088;">new </span><span style="color:#008855;">int</span><span style="color:#333333;">[</span><span style="color:#116644;">10</span><span style="color:#333333;">], [](</span><span style="color:#008855;">int *</span><span style="color:#000000;">p</span><span style="color:#333333;">) { </span><span style="color:#770088;">delete </span><span style="color:#333333;">[] </span><span style="color:#000000;">p</span><span style="color:#333333;">;}); </span></p> 
</blockquote> 
<p>3.1.2  <span style="color:#333333;"><strong>使用</strong></span><span style="color:#333333;"><strong>shared_ptr</strong></span><span style="color:#333333;"><strong>要注意的问题</strong></span></p> 
<p><span style="color:#333333;"><strong>不要用一个原始指针初始化多个</strong></span><span style="color:#333333;"><strong>shared_ptr</strong></span></p> 
<p><span style="color:#333333;">例如下面错误范例： </span>​​​​​​​</p> 
<blockquote> 
 <div> 
  <span style="color:#008855;">int *</span> 
  <span style="color:#000000;">ptr </span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#770088;">new </span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#333333;">; </span> 
 </div> 
 <div> 
  <span style="color:#000000;">shared_ptr</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt; </span> 
  <span style="color:#0000ff;">p1</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#000000;">ptr</span> 
  <span style="color:#333333;">); </span> 
 </div> 
 <div> 
  <span style="color:#000000;">shared_ptr</span> 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt; </span> 
  <span style="color:#0000ff;">p2</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#000000;">ptr</span> 
  <span style="color:#333333;">); </span> 
  <span style="color:#aa5500;">// </span> 
  <span style="color:#aa5500;">逻辑错误 </span> 
 </div> 
</blockquote> 
<p><span style="color:#333333;"><strong>不要在函数实参中创建</strong></span><span style="color:#333333;"><strong>shared_ptr </strong></span></p> 
<blockquote> 
 <p> <span style="color:#000000;">function</span><span style="color:#333333;">(</span><span style="color:#000000;">shared_ptr</span><span style="color:#981a1a;">&lt;</span><span style="color:#008855;">int</span><span style="color:#981a1a;">&gt;</span><span style="color:#333333;">(</span><span style="color:#770088;">new </span><span style="color:#008855;">int</span><span style="color:#333333;">), </span><span style="color:#000000;">g</span><span style="color:#333333;">()); </span><span style="color:#aa5500;">//</span><span style="color:#aa5500;">有缺陷 </span></p> 
 <p></p> 
 <div> 
  <span style="color:#333333;"><strong>因为</strong></span> 
  <span style="color:#333333;"><strong>C++</strong></span> 
  <span style="color:#333333;"><strong>的函数参数的计算顺序在不同的编译器不同的约定下可能是不一样的</strong></span> 
  <span style="color:#333333;">，一般是从右到左，但也可能从左到右，所以，可能的过程是先new int</span> 
  <span style="color:#333333;">，然后调用</span> 
  <span style="color:#333333;">g()</span> 
  <span style="color:#333333;">，如果恰好</span> 
  <span style="color:#333333;">g()</span> 
  <span style="color:#333333;">发生异常，而</span> 
  <span style="color:#333333;">shared_ptr</span> 
  <span style="color:#333333;">还没有创建， 则int</span> 
  <span style="color:#333333;">内存泄漏了.</span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">正确的写法应该是先创建智能指针，代码如下：</span> 
 </div> 
 <div>
   shared_ptr 
  <span style="color:#981a1a;">&lt;</span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#981a1a;">&gt; </span> 
  <span style="color:#0000ff;">p</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#770088;">new </span> 
  <span style="color:#008855;">int</span> 
  <span style="color:#333333;">);</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#000000;">function</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#000000;">p</span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#000000;">g</span> 
   <span style="color:#333333;">());</span> 
  </div> 
 </div> 
</blockquote> 
<p><span style="color:#333333;"><strong>通过</strong></span><span style="color:#333333;"><strong>shared_from_this()</strong></span><span style="color:#333333;"><strong>返回</strong></span><span style="color:#333333;"><strong>this</strong></span><span style="color:#333333;"><strong>指针 </strong></span></p> 
<p> <span style="color:#333333;">不要将</span><span style="color:#333333;">this</span><span style="color:#333333;">指针作为</span><span style="color:#333333;">shared_ptr返回出来，因为</span><span style="color:#333333;">this</span><span style="color:#333333;">指针本质上是一个裸指针，因此，这样可能会导致重复析构，看下面的例子。​​​​​​​</span></p> 
<pre><code class="language-cpp">/*
    错误范例：
    由于用同一个指针（this)构造了两个智能指针sp1和sp2，而他们之间是没有任何关系
    的，在离开作用域之后this将会被构造的两个智能指针各自析构，导致重复析构的错误。
*/
#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class A
{
public:
    shared_ptr&lt;A&gt; GetSelf()
    {
        return shared_ptr&lt;A&gt;(this); // 不要这么做
    }
    ~A()
    {
        cout &lt;&lt; "Destructor A" &lt;&lt; endl;
    }
};

int main()
{
    shared_ptr&lt;A&gt; sp1(new A);
    shared_ptr&lt;A&gt; sp2 = sp1-&gt;GetSelf();
    return 0;
}



/*
    正确范例，正确返回this的shared_ptr的做法是：
    让目标类通过std::enable_shared_from_this基类的方法shared_from_this()来返回一个新的                 
     std::shared_ptr 对象来作为this的shared_ptr，如下所示。
    
*/
#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class A: public std::enable_shared_from_this&lt;A&gt;
{
    public:
    shared_ptr&lt;A&gt;GetSelf()
    {
        return shared_from_this(); //正确的做法
    }
    ~A()
    {
        cout &lt;&lt; "Destructor A" &lt;&lt; endl;
    }
};

int main()
{
    shared_ptr&lt;A&gt; sp1(new A);
    shared_ptr&lt;A&gt; sp2 = sp1-&gt;GetSelf(); // ok
    return 0;
}</code></pre> 
<div> 
 <span style="color:#333333;"><strong>避免循环引用</strong></span> 
</div> 
<div> 
 <span style="color:#333333;">循环引用会导致内存泄漏，比如下面错误范例：</span> 
 <div> 
  <span style="color:#333333;">        循环引用导致ap</span> 
  <span style="color:#333333;">和</span> 
  <span style="color:#333333;">bp</span> 
  <span style="color:#333333;">的引用计数为</span> 
  <span style="color:#333333;">2</span> 
  <span style="color:#333333;">，在离开作用域之后，</span> 
  <span style="color:#333333;">ap</span> 
  <span style="color:#333333;">和</span> 
  <span style="color:#333333;">bp</span> 
  <span style="color:#333333;">的引用计数减为</span> 
  <span style="color:#333333;">1</span> 
  <span style="color:#333333;">，并不回减为</span> 
  <span style="color:#333333;">0</span> 
  <span style="color:#333333;">，导致两个指针都不会被析构，产生内存泄漏。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>解决的办法是把</strong></span> 
  <span style="color:#333333;"><strong>A</strong></span> 
  <span style="color:#333333;"><strong>和</strong></span> 
  <span style="color:#333333;"><strong>B</strong></span> 
  <span style="color:#333333;"><strong>任何一个成员变量改为</strong></span> 
  <span style="color:#333333;"><strong>weak_ptr</strong></span> 
  <span style="color:#333333;"><strong>，具体方法见</strong></span> 
  <span style="color:#333333;"><strong>weak_ptr</strong></span> 
  <span style="color:#333333;"><strong>章节。</strong></span> 
 </div> 
</div> 
<div> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

class A;
class B;
class A {
public:
    std::shared_ptr&lt;B&gt; bptr;
    ~A() {
        cout &lt;&lt; "A is deleted" &lt;&lt; endl;
    }
};

class B {
public:
    std::shared_ptr&lt;A&gt; aptr;
    ~B() {
        cout &lt;&lt; "B is deleted" &lt;&lt; endl;
    }
};

int main()
{
    {
        std::shared_ptr&lt;A&gt; ap(new A);
        std::shared_ptr&lt;B&gt; bp(new B);
        ap-&gt;bptr = bp;
        bp-&gt;aptr = ap;
    }
    cout&lt;&lt; "main leave" &lt;&lt; endl; // 循环引用导致ap bp退出了作用域都没有析构
    return 0;
}</code></pre> 
 <h3><span style="color:#333333;">3.2 unique_ptr</span><span style="color:#333333;">独占的智能指针</span></h3> 
 <p></p> 
 <ul><li><span style="color:#333333;">unique_ptr</span><span style="color:#333333;">是一个独占型的智能指针，不能将其赋值给另一个</span><span style="color:#333333;">unique_ptr </span></li><li><span style="color:#333333;">unique_ptr</span><span style="color:#333333;">可以指向一个数组 </span></li><li><span style="color:#333333;">unique_ptr</span><span style="color:#333333;">需要确定删除器的类型 </span></li></ul> 
 <p><strong><span style="color:#333333;">3.2.1 unique_ptr使用特点</span></strong></p> 
 <blockquote> 
  <div> 
   <div> 
    <span style="color:#333333;">1、unique_ptr</span> 
    <span style="color:#333333;">不允许复制，但可以通过函数返回给其他的</span> 
    <span style="color:#333333;">unique_ptr</span> 
    <span style="color:#333333;">，还可以通过</span> 
    <span style="color:#333333;">std::move</span> 
    <span style="color:#333333;">来转移到其他的unique_ptr</span> 
    <span style="color:#333333;">，这样它本身就不再拥有原来指针的所有权了。例如</span> 
   </div> 
   <div></div> 
  </div> 
  <div> 
   <span style="color:#000000;">unique_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#000000;">T</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#0000ff;">my_ptr</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#000000;">T</span> 
   <span style="color:#333333;">); </span> 
   <span style="color:#aa5500;">// </span> 
   <span style="color:#aa5500;">正确 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">unique_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#000000;">T</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">my_other_ptr </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">std::move</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#000000;">my_ptr</span> 
   <span style="color:#333333;">); </span> 
   <span style="color:#aa5500;">// </span> 
   <span style="color:#aa5500;">正确 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">unique_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#000000;">T</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">ptr </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">my_ptr</span> 
   <span style="color:#333333;">; </span> 
   <span style="color:#aa5500;">// </span> 
   <span style="color:#aa5500;">报错，不能复制 </span> 
   <span style="color:#333333;">​​​​​​​</span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#aa5500;">2、</span> 
   <span style="color:#333333;">unique_ptr可以指向一个数组，而</span> 
   <span style="color:#000000;">shared_ptr不可以，</span> 
   <span style="color:#333333;">代码如下所示 </span> 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#000000;">std::unique_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#008855;">int </span> 
    <span style="color:#333333;">[]</span> 
    <span style="color:#981a1a;">&gt; </span> 
    <span style="color:#0000ff;">ptr</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#770088;">new </span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#333333;">[</span> 
    <span style="color:#116644;">10</span> 
    <span style="color:#333333;">]); </span> 
   </div> 
   <div> 
    <span style="color:#000000;">ptr</span> 
    <span style="color:#333333;">[</span> 
    <span style="color:#116644;">9</span> 
    <span style="color:#333333;">] </span> 
    <span style="color:#981a1a;">= </span> 
    <span style="color:#116644;">9</span> 
    <span style="color:#333333;">; </span> 
   </div> 
   <div> 
    <span style="color:#000000;">std::shared_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#008855;">int </span> 
    <span style="color:#333333;">[]</span> 
    <span style="color:#981a1a;">&gt; </span> 
    <span style="color:#0000ff;">ptr2</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#770088;">new </span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#333333;">[</span> 
    <span style="color:#116644;">10</span> 
    <span style="color:#333333;">]); </span> 
    <span style="color:#aa5500;">// </span> 
    <span style="color:#aa5500;">这个是不合法的 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#aa5500;">3、</span> 
    <span style="color:#333333;">unique_ptr</span> 
    <span style="color:#333333;">指定删除器和</span> 
    <span style="color:#333333;">shared_ptr</span> 
    <span style="color:#333333;">有区别</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#000000;">std::shared_ptr</span> 
     <span style="color:#981a1a;">&lt;</span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#981a1a;">&gt; </span> 
     <span style="color:#0000ff;">ptr3</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#770088;">new </span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#116644;">1</span> 
     <span style="color:#333333;">), [](</span> 
     <span style="color:#008855;">int *</span> 
     <span style="color:#000000;">p</span> 
     <span style="color:#333333;">){<!-- --></span> 
     <span style="color:#770088;">delete </span> 
     <span style="color:#000000;">p</span> 
     <span style="color:#333333;">;}); </span> 
     <span style="color:#aa5500;">// </span> 
     <span style="color:#aa5500;">正确 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">std::unique_ptr</span> 
     <span style="color:#981a1a;">&lt;</span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#981a1a;">&gt; </span> 
     <span style="color:#0000ff;">ptr4</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#770088;">new </span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#116644;">1</span> 
     <span style="color:#333333;">), [](</span> 
     <span style="color:#008855;">int *</span> 
     <span style="color:#000000;">p</span> 
     <span style="color:#333333;">){<!-- --></span> 
     <span style="color:#770088;">delete </span> 
     <span style="color:#000000;">p</span> 
     <span style="color:#333333;">;}); </span> 
     <span style="color:#aa5500;">// </span> 
     <span style="color:#aa5500;">错误</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#333333;">unique_ptr</span> 
     <span style="color:#333333;">需要确定删除器的类型，所以不能像</span> 
     <span style="color:#333333;">shared_ptr</span> 
     <span style="color:#333333;">那样直接指定删除器，可以这样写：</span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#000000;">std::unique_ptr</span> 
      <span style="color:#981a1a;">&lt;</span> 
      <span style="color:#008855;">int</span> 
      <span style="color:#333333;">, </span> 
      <span style="color:#008855;">void</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#981a1a;">*</span> 
      <span style="color:#333333;">)(</span> 
      <span style="color:#008855;">int*</span> 
      <span style="color:#333333;">)</span> 
      <span style="color:#981a1a;">&gt; </span> 
      <span style="color:#0000ff;">ptr5</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#770088;">new </span> 
      <span style="color:#008855;">int</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#116644;">1</span> 
      <span style="color:#333333;">), [](</span> 
      <span style="color:#008855;">int *</span> 
      <span style="color:#000000;">p</span> 
      <span style="color:#333333;">){<!-- --></span> 
      <span style="color:#770088;">delete </span> 
      <span style="color:#000000;">p</span> 
      <span style="color:#333333;">;}); </span> 
      <span style="color:#aa5500;">//正确</span> 
     </div> 
    </div> 
   </div> 
  </div> 
 </blockquote> 
 <h3><span style="color:#333333;"><strong>3.3 weak_ptr</strong></span><span style="color:#333333;"><strong>弱引用的智能指针 </strong></span></h3> 
 <p><span style="color:#333333;">        share_ptr虽然已经很好用了，但是有一点share_ptr</span><span style="color:#333333;">智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr</span><span style="color:#333333;">成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</span></p> 
 <p><span style="color:#333333;">        weak_ptr 是一种<strong>不控制对象生命周期</strong>的智能指针, 它指向一个 shared_ptr </span><span style="color:#333333;">管理的对象</span><span style="color:#333333;">. </span><span style="color:#333333;">进行该对象的内存管理的是那个强引用的shared_ptr</span><span style="color:#333333;">，</span><span style="color:#333333;"> weak_ptr只是提供了对管理对象的一个访问手段。 </span></p> 
 <p><span style="color:#333333;">        weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作</span><span style="color:#333333;">, </span><span style="color:#333333;">它只可以从一个 shared_ptr </span><span style="color:#333333;">或另一个</span><span style="color:#333333;"> weak_ptr </span><span style="color:#333333;">对象构造</span><span style="color:#333333;">, </span><span style="color:#333333;">它的构造和析构不会引起引用记数的增加或减少。</span></p> 
 <p><span style="color:#333333;"><strong>3.3.1 weak_ptr</strong></span><span style="color:#333333;"><strong>的基本用法 </strong></span></p> 
 <blockquote> 
  <p><span style="color:#333333;">1. </span><span style="color:#333333;">通过</span><span style="color:#333333;">use_count()</span><span style="color:#333333;">方法获取当前观察资源的引用计数，如下所示：</span></p> 
  <p></p> 
  <p></p> 
  <div> 
   <span style="color:#000000;">shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#0000ff;">sp</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#116644;">10</span> 
   <span style="color:#333333;">)); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">weak_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#0000ff;">wp</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#000000;">sp</span> 
   <span style="color:#333333;">); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">cout </span> 
   <span style="color:#981a1a;">&lt;&lt; </span> 
   <span style="color:#000000;">wp</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#000000;">use_count</span> 
   <span style="color:#333333;">() </span> 
   <span style="color:#981a1a;">&lt;&lt; </span> 
   <span style="color:#000000;">endl</span> 
   <span style="color:#333333;">; </span> 
   <span style="color:#aa5500;">//</span> 
   <span style="color:#aa5500;">结果讲输出</span> 
   <span style="color:#aa5500;">1 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">2. </span> 
   <span style="color:#333333;">通过</span> 
   <span style="color:#333333;">expired()</span> 
   <span style="color:#333333;">方法判断所观察资源是否已经释放，如下所示： </span> 
  </div> 
  <div> 
   <div></div> 
   <div> 
    <span style="color:#000000;">shared_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#981a1a;">&gt; </span> 
    <span style="color:#0000ff;">sp</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#770088;">new </span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#116644;">10</span> 
    <span style="color:#333333;">)); </span> 
   </div> 
   <div> 
    <span style="color:#000000;">weak_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#008855;">int</span> 
    <span style="color:#981a1a;">&gt; </span> 
    <span style="color:#0000ff;">wp</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#000000;">sp</span> 
    <span style="color:#333333;">); </span> 
   </div> 
   <div> 
    <span style="color:#770088;">if</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#000000;">wp</span> 
    <span style="color:#333333;">.</span> 
    <span style="color:#000000;">expired</span> 
    <span style="color:#333333;">()) </span> 
   </div> 
   <div> 
    <span style="color:#000000;">        cout </span> 
    <span style="color:#981a1a;">&lt;&lt; </span> 
    <span style="color:#aa1111;">"weak_ptr</span> 
    <span style="color:#aa1111;">无效</span> 
    <span style="color:#aa1111;">,</span> 
    <span style="color:#aa1111;">资源已释放</span> 
    <span style="color:#aa1111;">"</span> 
    <span style="color:#333333;">; </span> 
   </div> 
   <div> 
    <span style="color:#770088;">else </span> 
   </div> 
   <div> 
    <span style="color:#000000;">        cout </span> 
    <span style="color:#981a1a;">&lt;&lt; </span> 
    <span style="color:#aa1111;">"weak_ptr</span> 
    <span style="color:#aa1111;">有效</span> 
    <span style="color:#aa1111;">"</span> 
    <span style="color:#333333;">;</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#333333;">3. </span> 
    <span style="color:#333333;">通过</span> 
    <span style="color:#333333;">lock</span> 
    <span style="color:#333333;">方法获取监视的</span> 
    <span style="color:#333333;">shared_ptr</span> 
    <span style="color:#333333;">，如下所示： </span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#000000;">std::weak_ptr</span> 
     <span style="color:#981a1a;">&lt;</span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#981a1a;">&gt; </span> 
     <span style="color:#000000;">gw</span> 
     <span style="color:#333333;">; </span> 
    </div> 
    <div> 
     <span style="color:#008855;">void </span> 
     <span style="color:#0000ff;">f</span> 
     <span style="color:#333333;">() </span> 
    </div> 
    <div> 
     <span style="color:#333333;">{ </span> 
    </div> 
    <div> 
     <span style="color:#770088;">        auto </span> 
     <span style="color:#000000;">spt </span> 
     <span style="color:#981a1a;">= </span> 
     <span style="color:#000000;">gw</span> 
     <span style="color:#333333;">.</span> 
     <span style="color:#000000;">lock</span> 
     <span style="color:#333333;">(); </span> 
    </div> 
    <div> 
     <span style="color:#770088;">        if</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#000000;">gw</span> 
     <span style="color:#333333;">.</span> 
     <span style="color:#000000;">expired</span> 
     <span style="color:#333333;">()) { </span> 
    </div> 
    <div> 
     <span style="color:#000000;">                cout </span> 
     <span style="color:#981a1a;">&lt;&lt; </span> 
     <span style="color:#aa1111;">"gw</span> 
     <span style="color:#aa1111;">无效</span> 
     <span style="color:#aa1111;">,</span> 
     <span style="color:#aa1111;">资源已释放</span> 
     <span style="color:#aa1111;">"</span> 
     <span style="color:#333333;">; </span> 
    </div> 
    <div> 
     <span style="color:#333333;">        } </span> 
    </div> 
    <div> 
     <span style="color:#770088;">        else </span> 
     <span style="color:#333333;">{ </span> 
    </div> 
    <div> 
     <span style="color:#000000;">                cout </span> 
     <span style="color:#981a1a;">&lt;&lt; </span> 
     <span style="color:#aa1111;">"gw</span> 
     <span style="color:#aa1111;">有效</span> 
     <span style="color:#aa1111;">, *spt = " </span> 
     <span style="color:#981a1a;">&lt;&lt; *</span> 
     <span style="color:#000000;">spt </span> 
     <span style="color:#981a1a;">&lt;&lt; </span> 
     <span style="color:#000000;">endl</span> 
     <span style="color:#333333;">; </span> 
    </div> 
    <div> 
     <span style="color:#333333;">        } </span> 
    </div> 
    <div> 
     <span style="color:#333333;">} </span> 
    </div> 
    <div> 
     <span style="color:#008855;">int </span> 
     <span style="color:#0000ff;">main</span> 
     <span style="color:#333333;">() </span> 
    </div> 
    <div> 
     <span style="color:#333333;">{ </span> 
    </div> 
    <div> 
     <span style="color:#333333;">        { </span> 
    </div> 
    <div> 
     <span style="color:#770088;">                auto </span> 
     <span style="color:#000000;">sp </span> 
     <span style="color:#981a1a;">= </span> 
     <span style="color:#000000;">std::make_shared</span> 
     <span style="color:#981a1a;">&lt;</span> 
     <span style="color:#008855;">int</span> 
     <span style="color:#981a1a;">&gt;</span> 
     <span style="color:#333333;">(</span> 
     <span style="color:#116644;">42</span> 
     <span style="color:#333333;">); </span> 
    </div> 
    <div> 
     <span style="color:#000000;">                gw </span> 
     <span style="color:#981a1a;">= </span> 
     <span style="color:#000000;">sp</span> 
     <span style="color:#333333;">; </span> 
    </div> 
    <div> 
     <span style="color:#000000;">                f</span> 
     <span style="color:#333333;">(); </span> 
    </div> 
    <div> 
     <span style="color:#333333;">        } </span> 
    </div> 
    <div> 
     <span style="color:#000000;">        f</span> 
     <span style="color:#333333;">(); </span> 
    </div> 
    <div> 
     <span style="color:#770088;">        return </span> 
     <span style="color:#116644;">0</span> 
     <span style="color:#333333;">; </span> 
    </div> 
    <div> 
     <span style="color:#333333;">}</span> 
    </div> 
   </div> 
  </div> 
 </blockquote> 
 <div> 
  <span style="color:#333333;"><strong>3.3.2 weak_ptr</strong></span> 
  <span style="color:#333333;"><strong>返回</strong></span> 
  <span style="color:#333333;"><strong>this</strong></span> 
  <span style="color:#333333;"><strong>指针</strong></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">shared_ptr</span> 
   <span style="color:#333333;">章节中提到不能直接将</span> 
   <span style="color:#333333;">this</span> 
   <span style="color:#333333;">指针返回</span> 
   <span style="color:#333333;">shared_ptr</span> 
   <span style="color:#333333;">，需要通过派生 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">std::enable_shared_from_this</span> 
   <span style="color:#333333;">类，并通过其方法</span> 
   <span style="color:#333333;">shared_from_this</span> 
   <span style="color:#333333;">来返回指针，原因是 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">std::enable_shared_from_this</span> 
   <span style="color:#333333;">类中有一个</span> 
   <span style="color:#333333;">weak_ptr</span> 
   <span style="color:#333333;">，这个</span> 
   <span style="color:#333333;">weak_ptr</span> 
   <span style="color:#333333;">用来观察</span> 
   <span style="color:#333333;">this</span> 
   <span style="color:#333333;">智能指针，调用 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">shared_from_this()</span> 
   <span style="color:#333333;">方法是，会调用内部这个</span> 
   <span style="color:#333333;">weak_ptr</span> 
   <span style="color:#333333;">的</span> 
   <span style="color:#333333;">lock()</span> 
   <span style="color:#333333;">方法，将所观察的</span> 
   <span style="color:#333333;">shared_ptr返回，</span> 
   <div> 
    <span style="color:#333333;">再看前面的范例</span> 
   </div> 
   <div> 
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

class A: public std::enable_shared_from_this&lt;A&gt;
{
public:
    shared_ptr&lt;A&gt;GetSelf()
    {
        return shared_from_this(); //
    }
    ~A()
    {
        cout &lt;&lt; "Destructor A" &lt;&lt; endl;
    }
};

int main()
{
    shared_ptr&lt;A&gt; sp1(new A);
    shared_ptr&lt;A&gt; sp2 = sp1-&gt;GetSelf(); // ok
    return 0;
}</code></pre> 
    <p><span style="color:#333333;">在外面创建A</span><span style="color:#333333;">对象的智能指针和通过对象返回</span><span style="color:#333333;">this</span><span style="color:#333333;">的智能指针都是安全的，因为</span><span style="color:#333333;">shared_from_this()</span><span style="color:#333333;">是内部的weak_ptr</span><span style="color:#333333;">调用</span><span style="color:#333333;">lock()</span><span style="color:#333333;">方法之后返回的智能指针，在离开作用域之后，</span><span style="color:#333333;">spy</span><span style="color:#333333;">的引用计数减为</span><span style="color:#333333;">0</span><span style="color:#333333;">，</span><span style="color:#333333;">A</span><span style="color:#333333;">对象会被析构，不会出现A</span><span style="color:#333333;">对象被析构两次的问题。</span></p> 
    <p></p> 
    <div> 
     <span style="color:#333333;">需要注意的是，获取自身智能指针的函数尽在</span> 
     <span style="color:#333333;">shared_ptr</span> 
     <span style="color:#333333;">的构造函数被调用之后才能使用，因为 </span> 
    </div> 
    <div> 
     <span style="color:#333333;">enable_shared_from_this</span> 
     <span style="color:#333333;">内部的</span> 
     <span style="color:#333333;">weak_ptr</span> 
     <span style="color:#333333;">只有通过</span> 
     <span style="color:#333333;">shared_ptr</span> 
     <span style="color:#333333;">才能构造。 </span> 
    </div> 
    <div></div> 
    <div> 
     <strong><span style="color:#333333;">3.3.3 weak_ptr</span><span style="color:#333333;">解决循环引用问题</span></strong> 
    </div> 
    <div> 
     <div> 
      <span style="color:#333333;">在</span> 
      <span style="color:#333333;">shared_ptr</span> 
      <span style="color:#333333;">章节提到智能指针循环引用的问题，因为智能指针的循环引用会导致内存泄漏，可以通过weak_ptr解决该问题，只要将</span> 
      <span style="color:#333333;">A</span> 
      <span style="color:#333333;">或</span> 
      <span style="color:#333333;">B</span> 
      <span style="color:#333333;">的任意一个成员变量改为</span> 
      <span style="color:#333333;">weak_ptr</span> 
     </div> 
     <div> 
      <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

class A;
class B;
class A {
public:
    std::shared_ptr&lt;B&gt; bptr;
    ~A() {
        cout &lt;&lt; "A is deleted" &lt;&lt; endl;
    }
};

class B {
public:
    std::shared_ptr&lt;A&gt; aptr;
    ~B() {
        cout &lt;&lt; "B is deleted" &lt;&lt; endl;
    }
};

int main()
{
    {
        std::shared_ptr&lt;A&gt; ap(new A);
        std::shared_ptr&lt;B&gt; bp(new B);
        ap-&gt;bptr = bp;
        bp-&gt;aptr = ap;
    }
    cout&lt;&lt; "main leave" &lt;&lt; endl; // 循环引用导致ap bp退出了作用域都没有析构
    return 0;
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#333333;">这样在对</span> 
 <span style="color:#333333;">B</span> 
 <span style="color:#333333;">的成员赋值时，即执行</span> 
 <span style="color:#333333;">bp-&gt;aptr=ap;</span> 
 <span style="color:#333333;">时，由于</span> 
 <span style="color:#333333;">aptr</span> 
 <span style="color:#333333;">是</span> 
 <span style="color:#333333;">weak_ptr</span> 
 <span style="color:#333333;">，它并不会增加引用计数，所以ap</span> 
 <span style="color:#333333;">的引用计数仍然会是</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">，在离开作用域之后，</span> 
 <span style="color:#333333;">ap</span> 
 <span style="color:#333333;">的引用计数为减为</span> 
 <span style="color:#333333;">0</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">A</span> 
 <span style="color:#333333;">指针会被析构，析构后其内部的bptr</span> 
 <span style="color:#333333;">的引用计数会被减为</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">，然后在离开作用域后</span> 
 <span style="color:#333333;">bp</span> 
 <span style="color:#333333;">引用计数又从</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">减为</span> 
 <span style="color:#333333;">0</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">B</span> 
 <span style="color:#333333;">对象也被析构，不会发生内存泄漏。</span> 
</div> 
<p> </p> 
<div> 
 <span style="color:#333333;"><strong>3.3.4 weak_ptr</strong></span> 
 <span style="color:#333333;"><strong>使用注意事项</strong></span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>weak_ptr</strong></span> 
  <span style="color:#333333;"><strong>在使用前需要检查合法性。</strong></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#000000;">weak_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">wp</span> 
   <span style="color:#333333;">; </span> 
  </div> 
  <div> 
   <span style="color:#333333;">{ </span> 
  </div> 
  <div> 
   <span style="color:#000000;">        shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">sp</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#116644;">1</span> 
   <span style="color:#333333;">)); </span> 
   <span style="color:#aa5500;">//sp.use_count()==1 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">        wp </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">sp</span> 
   <span style="color:#333333;">; </span> 
   <span style="color:#aa5500;">//wp</span> 
   <span style="color:#aa5500;">不会改变引用计数，所以</span> 
   <span style="color:#aa5500;">sp.use_count()==1 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">        shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">sp_ok </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">wp</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#000000;">lock</span> 
   <span style="color:#333333;">(); </span> 
   <span style="color:#aa5500;">//wp</span> 
   <span style="color:#aa5500;">没有重载</span> 
   <span style="color:#aa5500;">-&gt;</span> 
   <span style="color:#aa5500;">操作符。只能这样取所指向的对象 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">} </span> 
  </div> 
  <div> 
   <span style="color:#000000;">shared_ptr</span> 
   <span style="color:#981a1a;">&lt;</span> 
   <span style="color:#008855;">int</span> 
   <span style="color:#981a1a;">&gt; </span> 
   <span style="color:#000000;">sp_null </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">wp</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#000000;">lock</span> 
   <span style="color:#333333;">(); </span> 
   <span style="color:#aa5500;">//sp_null .use_count()==0;</span> 
  </div> 
  <div> 
   <div></div> 
   <div> 
    <span style="color:#333333;">因为上述代码中</span> 
    <span style="color:#333333;">sp</span> 
    <span style="color:#333333;">和</span> 
    <span style="color:#333333;">sp_ok</span> 
    <span style="color:#333333;">离开了作用域，其容纳的</span> 
    <span style="color:#333333;">K</span> 
    <span style="color:#333333;">对象已经被释放了。得到了一个容纳NULL</span> 
    <span style="color:#333333;">指针的</span> 
    <span style="color:#333333;">sp_null</span> 
    <span style="color:#333333;">对象。</span> 
    <span style="color:#333333;"><strong>在使用</strong></span> 
    <span style="color:#333333;"><strong>wp</strong></span> 
    <span style="color:#333333;"><strong>前需要调用</strong></span> 
    <span style="color:#333333;"><strong>wp.expired()</strong></span> 
    <span style="color:#333333;"><strong>函数判断一下。</strong></span> 
    <span style="color:#333333;">因为wp</span> 
    <span style="color:#333333;">还仍旧存在，虽然引用计数等于</span> 
    <span style="color:#333333;">0</span> 
    <span style="color:#333333;">，仍有某处</span> 
    <span style="color:#333333;">“</span> 
    <span style="color:#333333;">全局</span> 
    <span style="color:#333333;">”</span> 
    <span style="color:#333333;">性的存储块保存着这个计数信息。直到最后一个weak_ptr</span> 
    <span style="color:#333333;">对象被析构，这块</span> 
    <span style="color:#333333;">“</span> 
    <span style="color:#333333;">堆</span> 
    <span style="color:#333333;">”</span> 
    <span style="color:#333333;">存储块才能被回收。否则</span> 
    <span style="color:#333333;">weak_ptr</span> 
    <span style="color:#333333;">无法直到自己所容纳的那个指针资源的当前状态。​​​​​​​​​​​​​​</span> 
   </div> 
  </div> 
 </div> 
</blockquote> 
<h3><span style="color:#333333;"><strong>3.4 智能指针安全性问题</strong></span> </h3> 
<div> 
 <span style="color:#333333;">引用计数本身是安全的，至于智能指针是否安全需要结合实际使用分情况讨论：</span> 
</div> 
<div> 
 <div></div> 
 <blockquote> 
  <div> 
   <div> 
    <span style="color:#333333;"><strong>情况</strong></span> 
    <span style="color:#333333;"><strong>1</strong></span> 
    <span style="color:#333333;"><strong>：多线程代码操作的是同一个</strong></span> 
    <span style="color:#333333;"><strong>shared_ptr</strong></span> 
    <span style="color:#333333;"><strong>的对象，此时是不安全的。 </strong></span> 
   </div> 
   <div> 
    <span style="color:#333333;">比如</span> 
    <span style="color:#333333;">std::thread</span> 
    <span style="color:#333333;">的回调函数，是一个</span> 
    <span style="color:#333333;">lambda</span> 
    <span style="color:#333333;">表达式，其中引用捕获了一个</span> 
    <span style="color:#333333;">shared_ptr</span> 
   </div> 
   <div></div> 
  </div> 
  <div> 
   <span style="color:#000000;">std::thread </span> 
   <span style="color:#0000ff;">td</span> 
   <span style="color:#333333;">([</span> 
   <span style="color:#981a1a;">&amp;</span> 
   <span style="color:#000000;">sp1</span> 
   <span style="color:#333333;">]()){....}); </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">又或者通过回调函数的参数传入的</span> 
   <span style="color:#333333;">shared_ptr</span> 
   <span style="color:#333333;">对象，参数类型引用</span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#008855;">void </span> 
    <span style="color:#0000ff;">fn</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#000000;">shared_ptr</span> 
    <span style="color:#981a1a;">&lt;</span> 
    <span style="color:#000000;">A</span> 
    <span style="color:#981a1a;">&gt;&amp;</span> 
    <span style="color:#000000;">sp</span> 
    <span style="color:#333333;">) { </span> 
   </div> 
   <div> 
    <span style="color:#333333;">... </span> 
   </div> 
   <div> 
    <span style="color:#333333;">} </span> 
   </div> 
   <div> 
    <span style="color:#333333;">.. </span> 
   </div> 
   <div> 
    <span style="color:#000000;">std::thread </span> 
    <span style="color:#0000ff;">td</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#000000;">fn</span> 
    <span style="color:#333333;">, </span> 
    <span style="color:#000000;">sp1</span> 
    <span style="color:#333333;">); </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#333333;">这时候必然不是线程安全的。 </span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#333333;"><strong>情况</strong></span> 
     <span style="color:#333333;"><strong>2</strong></span> 
     <span style="color:#333333;"><strong>：多线程代码操作的不是同一个</strong></span> 
     <span style="color:#333333;"><strong>shared_ptr</strong></span> 
     <span style="color:#333333;"><strong>的对象 </strong></span> 
    </div> 
    <div> 
     <span style="color:#333333;">这里指的是管理的数据是同一份，而</span> 
     <span style="color:#333333;">shared_ptr</span> 
     <span style="color:#333333;">不是同一个对象。比如多线程回调的</span> 
     <span style="color:#333333;">lambda的是按值捕获的对象。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#000000;">std::thread </span> 
     <span style="color:#0000ff;">td</span> 
     <span style="color:#333333;">([</span> 
     <span style="color:#000000;">sp1</span> 
     <span style="color:#333333;">]()){....});</span> 
    </div> 
    <div> 
     <span style="color:#333333;">另一个线程传递的</span> 
     <span style="color:#333333;">shared_ptr</span> 
     <span style="color:#333333;">是值传递，而非引用： </span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#008855;">void </span> 
      <span style="color:#0000ff;">fn</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#000000;">shared_ptr</span> 
      <span style="color:#981a1a;">&lt;</span> 
      <span style="color:#000000;">A</span> 
      <span style="color:#981a1a;">&gt;</span> 
      <span style="color:#000000;">sp</span> 
      <span style="color:#333333;">) { </span> 
     </div> 
     <div> 
      <span style="color:#333333;">... </span> 
     </div> 
     <div> 
      <span style="color:#333333;">} </span> 
     </div> 
     <div> 
      <span style="color:#333333;">.. </span> 
     </div> 
     <div> 
      <span style="color:#000000;">std::thread </span> 
      <span style="color:#0000ff;">td</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#000000;">fn</span> 
      <span style="color:#333333;">, </span> 
      <span style="color:#000000;">sp1</span> 
      <span style="color:#333333;">);</span> 
     </div> 
     <div> 
      <div> 
       <span style="color:#333333;">这时候每个线程内看到的</span> 
       <span style="color:#333333;">sp</span> 
       <span style="color:#333333;">，他们所管理的是同一份数据，用的是同一个引用计数。但是各自是不同的对象，当发生多线程中修改sp</span> 
       <span style="color:#333333;">指向的操作的时候，是不会出现非预期的异常行为的。也就是说，如下操作是安全的。</span> 
      </div> 
      <div> 
       <div> 
        <span style="color:#008855;">void </span> 
        <span style="color:#0000ff;">fn</span> 
        <span style="color:#333333;">(</span> 
        <span style="color:#000000;">shared_ptr</span> 
        <span style="color:#981a1a;">&lt;</span> 
        <span style="color:#000000;">A</span> 
        <span style="color:#981a1a;">&gt;</span> 
        <span style="color:#000000;">sp</span> 
        <span style="color:#333333;">) { </span> 
       </div> 
       <div> 
        <span style="color:#333333;">        ... </span> 
       </div> 
       <div> 
        <span style="color:#770088;">        if</span> 
        <span style="color:#333333;">(..){ </span> 
       </div> 
       <div> 
        <span style="color:#000000;">                sp </span> 
        <span style="color:#981a1a;">= </span> 
        <span style="color:#000000;">other_sp</span> 
        <span style="color:#333333;">; </span> 
       </div> 
       <div> 
        <span style="color:#333333;">        } </span> 
        <span style="color:#770088;">else </span> 
        <span style="color:#333333;">{ </span> 
       </div> 
       <div> 
        <span style="color:#000000;">                sp </span> 
        <span style="color:#981a1a;">= </span> 
        <span style="color:#000000;">other_sp2</span> 
        <span style="color:#333333;">; </span> 
       </div> 
       <div> 
        <span style="color:#333333;">        } </span> 
       </div> 
       <div> 
        <span style="color:#333333;">}</span> 
       </div> 
       <div></div> 
       <div> 
        <div> 
         <span style="color:#333333;"><strong>需要注意：所管理数据的线程安全性问题</strong></span> 
         <span style="color:#333333;">。显而易见，所管理的对象必然不是线程安全的，必然</span> 
         <span style="color:#333333;"> sp1</span> 
         <span style="color:#333333;">、sp2、</span> 
         <span style="color:#333333;">sp3</span> 
         <span style="color:#333333;">智能指针实际都是指向对象</span> 
         <span style="color:#333333;">A</span> 
         <span style="color:#333333;">，</span> 
         <span style="color:#333333;">三个线程同时操作对象</span> 
         <span style="color:#333333;">A</span> 
         <span style="color:#333333;">，那对象的数据安全必然是需要对象A自己去保证。</span> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d56fe32789e4b24ba6018685c9e4ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">el-tree只能点击最后⼀级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d83ee2fc191a98434a08b6149deeb32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">abaqus应力值导出并进行后处理（同一节点多个应力值如何处理？）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>