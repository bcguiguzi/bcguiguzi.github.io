<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣由浅至深 每日一题.06 删除有序数组中的重复项 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣由浅至深 每日一题.06 删除有序数组中的重复项" />
<meta property="og:description" content="希望我们都能对抗生活的苦难，在乌云周围突破阴霾积极的生活
—— 24.3.16
删除有序数组中的重复项 提示
给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。 判题标准:
系统会用下面的代码来测试你的题解:
int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i &lt; k; i&#43;&#43;) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/28ac4798afae1292a4ec2e5129a07106/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T08:27:48+08:00" />
<meta property="article:modified_time" content="2024-03-16T08:27:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣由浅至深 每日一题.06 删除有序数组中的重复项</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#ed7976;"><strong>希望我们都能对抗生活的苦难，在乌云周围突破阴霾积极的生活</strong></span></p> 
 <p><span style="color:#ed7976;"><strong>                                                                                 —— 24.3.16</strong></span></p> 
</blockquote> 
<h2><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" rel="nofollow" title="删除有序数组中的重复项">删除有序数组中的重复项</a></h2> 
<p><img alt="" height="331" src="https://images2.imgbox.com/97/65/vrfFcYBB_o.png" width="1200"></p> 
<blockquote> 
 <p>提示</p> 
 <p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow" title=" 原地"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p> 
 <p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p> 
 <ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul> 
 <p><strong>判题标准:</strong></p> 
 <p>系统会用下面的代码来测试你的题解:</p> 
 <pre>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}</pre> 
 <p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>nums = [1,1,2]
<strong>输出：</strong>2, nums = [1,2,_]
<strong>解释：</strong>函数应该返回新的长度 </pre> 
 <pre>2，并且原数组 <em>nums </em><strong>的前两个元素被修改为 </strong><strong>1</strong>, 2
不需要考虑数组中超出新长度后面的元素。</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]
<strong>输出：</strong>5, nums = [0,1,2,3,4]
<strong>解释：</strong>函数应该返回新的长度 
5 ， 并且原数组 <em>nums </em>的前五个元素被修改为 0, 1, <strong>2</strong>, 3, 4</pre> 
 <pre> 。不需要考虑数组中超出新长度后面的元素。
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul> 
</blockquote> 
<h3>方法一.暴力遍历</h3> 
<blockquote> 
 <p>思路：<br> 由于是有序的，那么就可以遍历数组，找相邻两个数是否相等；<br> 如果相等那么就把数组后面的元素往前移动；同时numsSize–;<br> 注意：由于遍历数组时候，后面元素往前移动了，所以遍历的元素下标i–;</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    int removeDuplicates(int* nums, int numsSize)
    {
	    //控制号结束条件即可！！
        for(int i = 0;i&lt;numsSize-1;i++){
            //如果相邻的元素相等，那么就后面覆盖前面的元素
            if(nums[i] == nums[i+1]){
                for(int j = i;j&lt;numsSize-1;j++){
                     nums[j] = nums[j+1];				
                }   
			    numsSize--; //覆盖结束后，数组元素个数-1    
			    i--; //由于后面的值覆盖前面的值，所以下标要更新
            }
        }
        return numsSize;
    }
</code></pre> 
<h3>方法二.双指针</h3> 
<blockquote> 
 <p>关键字：原地修改</p> 
 <p>模式识别：需要保存可覆盖位置和观测位置，利用双指针</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        int numsLength = nums.length;
        if (numsLength == 0) {
            return 0;
        }
        int i = 1;
        int j = 1;
        while (i &lt; numsLength) {
            if (nums[i] != nums[i - 1]) {
                nums[j] = nums[i];
                j++;
            }
            i++;
        }
        return j;
    }
}</code></pre> 
<h3>方法三.额外数组</h3> 
<blockquote> 
 <p>假设可以使用额外空间</p> 
 <p>复制不同的元素</p> 
 <p>数组已经进行排序，所以直接检测该元素与下一个元素是否相同，若是前一个与后一个不同，则存储在新数组中</p> 
 <p>时间复杂度：O(n)</p> 
 <p>空间复杂度：O(n)</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        int numsLength = nums.length;
        if (numsLength == 0) {
            return 0;
        }
        int[] temp = new int[];
        //先给零时数组一个值
        temp[0] = nums[0];
        int cur = 0; //指向零时数组的下标
        //从nums[1]开始与临时数组的元素比较，不相同的直接放进去temp
        for(int i = 1;i&lt;numsSize;i++){
            if(nums[i] == temp[cur]){
                continue;
            }else{
                temp[++cur] = nums[i]; //注意控制下标
            }
        }
    
        //将临时数组拷回去
        for(int i = 0;i&lt;cur+1;i++){
            nums[i] = temp[i];
        }
        return cur+1;
    }



</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45d3d55ebc222239d334011cf6f81bf0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">蓝桥杯算法基础（21）：（6道小题：奇数在左，第k个元素,超过一半的数字，最小可用ID，合并有序数组，逆序对个数）java版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbdf462648b356da9ccd5a79f6b78e30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换【篇】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>