<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Stanford CS143 Compiler Fall2014 个人笔记 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Stanford CS143 Compiler Fall2014 个人笔记" />
<meta property="og:description" content="文章目录 introduction1.1 编译器的结构 3. 词法分析Lexical Analysis3.1 词法分析的目的3.1.1 名词释义3.1.2 词法分析概要3.1.3 词素例子 3.2 词法分析例子3.2.1 FORTRAN3.2.2 PL/13.2.3 C&#43;&#43; 3.3 正规语言3.3.1 正规表达式3.3.1.1 正规表达式Regular Expressions3.3.1.2 正规表达式的操作3.3.2 正规语言Formal Languages3.3.2.? Meaning Function L 3.3.3 正规表达式如何说明编程语言中的不同方向 3.4 词法规范（lexical specification）CTMD垃圾CSDN，Ctrl&#43;S不能保存，写了1000多字全没了。。。。Scheiße！ 4 语法分析4.1 上下文无关文法4.1.1 结构4.1.2 二义文法 4.2 处理问题4.2.1 问题的种类4.2.2 处理问题需要做的事4.2.3 处理问题的方法4.2.3.1 恐慌模式Panic mode4.2.3.2 错误产生式 Error Productions4.2.3.3 自动的局部或全局矫正 Automatic local or global correction4.2.3.4 过去和现在比较 4.3 语法树4.4递归下降的语法分析（自顶向下的语法分析）4.4.2 举一个RD algorithm例子4.4.3 消除左递归（left recursion） introduction Deference between Compilers with Interpreters
Compiler is off-line, and it’s imput is “program” then compiler it to exec witch can coculate Data to Output." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cc1dc9ec9b5e56164092699d14c9e03a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-28T18:23:09+08:00" />
<meta property="article:modified_time" content="2019-10-28T18:23:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Stanford CS143 Compiler Fall2014 个人笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#introduction_1" rel="nofollow">introduction</a></li><li><ul><li><a href="#11__13" rel="nofollow">1.1 编译器的结构</a></li></ul> 
  </li><li><a href="#3_Lexical_Analysis_37" rel="nofollow">3. 词法分析Lexical Analysis</a></li><li><ul><li><a href="#31__38" rel="nofollow">3.1 词法分析的目的</a></li><li><ul><li><a href="#311__40" rel="nofollow">3.1.1 名词释义</a></li><li><a href="#312__48" rel="nofollow">3.1.2 词法分析概要</a></li><li><a href="#313__51" rel="nofollow">3.1.3 词素例子</a></li></ul> 
   </li><li><a href="#32__53" rel="nofollow">3.2 词法分析例子</a></li><li><ul><li><a href="#321_FORTRAN_54" rel="nofollow">3.2.1 FORTRAN</a></li><li><a href="#322_PL1_60" rel="nofollow">3.2.2 PL/1</a></li><li><a href="#323_C_68" rel="nofollow">3.2.3 C++</a></li></ul> 
   </li><li><a href="#33__72" rel="nofollow">3.3 正规语言</a></li><li><ul><li><a href="#331__74" rel="nofollow">3.3.1 正规表达式</a></li><li><ul><li><a href="#3311_Regular_Expressions_75" rel="nofollow">3.3.1.1 正规表达式Regular Expressions</a></li><li><a href="#3312__80" rel="nofollow">3.3.1.2 正规表达式的操作</a></li><li><a href="#332_Formal_Languages_90" rel="nofollow">3.3.2 正规语言Formal Languages</a></li><li><ul><li><a href="#332_Meaning_Function_L_95" rel="nofollow">3.3.2.? Meaning Function L</a></li></ul> 
    </li></ul> 
    </li><li><a href="#333__108" rel="nofollow">3.3.3 正规表达式如何说明编程语言中的不同方向</a></li></ul> 
   </li><li><a href="#34_lexical_specification_125" rel="nofollow">3.4 词法规范（lexical specification）</a></li><li><a href="#CTMDCSDNCtrlS1000Scheie_133" rel="nofollow">CTMD垃圾CSDN，Ctrl+S不能保存，写了1000多字全没了。。。。Scheiße！</a></li></ul> 
  </li><li><a href="#4__134" rel="nofollow">4 语法分析</a></li><li><ul><li><a href="#41__135" rel="nofollow">4.1 上下文无关文法</a></li><li><ul><li><a href="#411__136" rel="nofollow">4.1.1 结构</a></li><li><a href="#412__140" rel="nofollow">4.1.2 二义文法</a></li></ul> 
   </li><li><a href="#42__150" rel="nofollow">4.2 处理问题</a></li><li><ul><li><a href="#421__151" rel="nofollow">4.2.1 问题的种类</a></li><li><a href="#422__153" rel="nofollow">4.2.2 处理问题需要做的事</a></li><li><a href="#423__156" rel="nofollow">4.2.3 处理问题的方法</a></li><li><ul><li><a href="#4231_Panic_mode_157" rel="nofollow">4.2.3.1 恐慌模式Panic mode</a></li><li><a href="#4232__Error_Productions_164" rel="nofollow">4.2.3.2 错误产生式 Error Productions</a></li><li><a href="#4233__Automatic_local_or_global_correction_169" rel="nofollow">4.2.3.3 自动的局部或全局矫正 Automatic local or global correction</a></li><li><a href="#4234__174" rel="nofollow">4.2.3.4 过去和现在比较</a></li></ul> 
   </li></ul> 
   </li><li><a href="#43__176" rel="nofollow">4.3 语法树</a></li><li><a href="#44_182" rel="nofollow">4.4递归下降的语法分析（自顶向下的语法分析）</a></li><li><ul><li><a href="#442_RD_algorithm_195" rel="nofollow">4.4.2 举一个RD algorithm例子</a></li><li><a href="#443_left_recursion_249" rel="nofollow">4.4.3 消除左递归（left recursion）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="introduction_1"></a>introduction</h2> 
<ol><li><strong>Deference</strong> between Compilers with Interpreters<br> Compiler is off-line, and it’s imput is “program” then compiler it to exec witch can coculate Data to Output.<br> Interpreters is on-line, and it’s input is Program and Data, it interpreter the Program line by line, and excute the code.</li><li><strong>History</strong><br> 1954 IBM develops the 704. In this time, software is more expensive than hardware.</li><li>Speedcoding<br> 1954 John Backus.today’s interperters. very slow.<br> than he invented Fortran1(1954-1957). It’s the first compiler.<br> （好吧，英语记笔记有点慢）并且编译的核心由此确定为“理论(Theory)+练习(Pratice)”</li><li>编译原理分为：lexical analysis, parsing, sematic analysis, optimization, code generation<br> lexical analysis和parsing注重<strong>句法分析</strong>，sematic注重<strong>语义</strong>，</li></ol> 
<h3><a id="11__13"></a>1.1 编译器的结构</h3> 
<p>人类是如何理解一段英语的</p> 
<table><thead><tr><th>理解语句</th><th>对应编译过程</th></tr></thead><tbody><tr><td>This is a sentence.</td><td>if x == y then z = 1; else z = 2;</td></tr><tr><td>理解单词<br>将句子分割成单词集<br>{‘This’, ‘is’, ‘a’, ‘sentence’}</td><td>词法分析<br>将独立的程序文本分割成单词或tokens（标记）<br>可以识别出关键字{‘if’, ‘and’, ‘else’}、变量名{‘x’, ‘y’, ‘z’}、常量{‘1’, ‘2’}、操作符{’==’, ‘’=’, ‘=’}</td></tr><tr><td>理解句子结构<br><img src="https://images2.imgbox.com/42/5f/WHlPj4hp_o.png" alt="在这里插入图片描述"></td><td>语法分析（语法树）<img src="https://images2.imgbox.com/0e/ba/Pe3ypTuU_o.png" alt="在这里插入图片描述"></td></tr><tr><td>理解句子意思<br>这是会有歧义的<img src="https://images2.imgbox.com/96/41/s6yJDpG8_o.png" alt="在这里插入图片描述"></td><td>语义分析<br>强制规定，避免模糊语言<img src="https://images2.imgbox.com/5d/cc/fRq5hnsF_o.png" alt="在这里插入图片描述"></td></tr><tr><td>简化语言表示<img src="https://images2.imgbox.com/02/65/RbcDeWce_o.png" alt="在这里插入图片描述"></td><td>自动代码优化<img src="https://images2.imgbox.com/49/08/xmBL38N4_o.png" alt="在这里插入图片描述"><br>但当Y==NaN时不能这么做</td></tr><tr><td>翻译成其他语言</td><td>code生成</td></tr></tbody></table> 
<p>1.2 经济型程序语言<br> 问1：为什么有这么多程序语言？<br> 如，科学计算→Fortran，商业程序→SQL，系统程序→C/C++<br> 答：不同程序所解决的<strong>领域</strong>（application domains）是不同的</p> 
<p>问2：为什么有新的程序语言出现？<br> 答：对编程语言来说，需要投入的前期编程教育占据了支出的主要部分。<br> 且现在主流语言之间的差距并不大。<br> 创建一个新编程语言很容易。当新语言带来的生产力大于培训成本时，选择创建新语言。<br> 编程语言尝试填补空缺</p> 
<p>问3：好的程序语言是什么？</p> 
<h2><a id="3_Lexical_Analysis_37"></a>3. 词法分析Lexical Analysis</h2> 
<h3><a id="31__38"></a>3.1 词法分析的目的</h3> 
<p>将源码分解为&lt;Identifier, token&gt;对和词汇表</p> 
<h4><a id="311__40"></a>3.1.1 名词释义</h4> 
<table><thead><tr><th>名词</th><th>词义</th></tr></thead><tbody><tr><td>Identifier</td><td>字符串或由字符开始的数字串</td></tr><tr><td>Integer</td><td>非空数字组成的字符串</td></tr><tr><td>Keyword</td><td>“else” or “if” or “begin” or …</td></tr><tr><td>Witespace</td><td>非空字符串，这个字符串由空格、换行符、制表符构成</td></tr><tr><td>Operator</td><td>运算符</td></tr></tbody></table> 
<h4><a id="312__48"></a>3.1.2 词法分析概要</h4> 
<ol><li>将源码的字串归类成Tocken class</li><li>通过Tocken与语法分析沟通</li></ol> 
<h4><a id="313__51"></a>3.1.3 词素例子</h4> 
<p><img src="https://images2.imgbox.com/72/bd/q4zcQlm0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32__53"></a>3.2 词法分析例子</h3> 
<h4><a id="321_FORTRAN_54"></a>3.2.1 FORTRAN</h4> 
<p>FORTRAN规则：空格是无影响的（“var1” == “va r1”）<br> 向前看规则<img src="https://images2.imgbox.com/3e/84/2naGXv6O_o.png" alt="在这里插入图片描述"><br> 这说明了词法分析的任务：</p> 
<ol><li>分割文本。从左向右读源程序，生成Tocken，一次个状态识别一个Tocken</li><li>“向前看”用来解决一个Tocken的终止和另一个Tocken的开始</li></ol> 
<h4><a id="322_PL1_60"></a>3.2.2 PL/1</h4> 
<p>（PL/1是一个IBM设计的编程语言）</p> 
<p>特点：</p> 
<ol><li>关键字不保留<br> <img src="https://images2.imgbox.com/02/22/5rys6VH6_o.png" alt="在这里插入图片描述"></li><li>DECLARE二义性<br> <img src="https://images2.imgbox.com/23/9f/smqC7SGU_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="323_C_68"></a>3.2.3 C++</h4> 
<p>在&lt;&gt;和&gt;&gt;、&lt;&lt;之间的问题<br> 如：Foo&lt;Bar&gt; ，这里出现了&gt;&gt;，会和流&gt;&gt;混淆。所以需要将这里的&gt;&gt;改成&gt; &gt;(加了个空格)</p> 
<h3><a id="33__72"></a>3.3 正规语言</h3> 
<p>Lexical structure = token classes</p> 
<h4><a id="331__74"></a>3.3.1 正规表达式</h4> 
<h5><a id="3311_Regular_Expressions_75"></a>3.3.1.1 正规表达式Regular Expressions</h5> 
<p>正规表达式由{单个字符，空字符}构成<br> 　空字符用"<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ε 
        
       
      
        \varepsilon 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ε</span></span></span></span></span>"表示</p> 
<p><img src="https://images2.imgbox.com/bb/e7/o6pF3g4s_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3312__80"></a>3.3.1.2 正规表达式的操作</h5> 
<table><thead><tr><th>操作名</th><th>方法示意</th></tr></thead><tbody><tr><td>Union</td><td><img src="https://images2.imgbox.com/49/9e/ti5hxMy8_o.png" alt="在这里插入图片描述"></td></tr><tr><td>Concatenation</td><td><img src="https://images2.imgbox.com/67/12/VbhIxHxP_o.png" alt="在这里插入图片描述"></td></tr><tr><td>Iteration</td><td><img src="https://images2.imgbox.com/b2/11/tkJpZSXP_o.png" alt="在这里插入图片描述"></td></tr></tbody></table> 
<p>定义：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Σ 
        
       
      
        \Sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span> 是一个正规表达式中各正规式的组成元素集合<br> <img src="https://images2.imgbox.com/5c/f7/g1dL5UiW_o.png" alt="在这里插入图片描述"><br> 上图中，都是在给定的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Σ 
        
       
      
        \Sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>(即正规表达式构成元素)组成的语法<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         R 
        
       
      
        R 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>(grammer)<br> 举例说明：<img src="https://images2.imgbox.com/39/3c/zoAnBIqJ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="332_Formal_Languages_90"></a>3.3.2 正规语言Formal Languages</h5> 
<p>定义：设<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Σ 
        
       
      
        \Sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>是一个字符集。一个在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Σ 
        
       
      
        \Sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>上产生的语法是，从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Σ 
        
       
      
        \Sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>上产生的字符串集。（主要部分：语法是字符串集，其他定语自己看懂）<br> 就像英文<strong>字母表</strong>是英语<strong>字符</strong>构成的，而英文<strong>语言</strong>是由英文<strong>句子</strong>构成的<br> Alphabet = ASCII<br> Language = C programs</p> 
<h6><a id="332_Meaning_Function_L_95"></a>3.3.2.? Meaning Function L</h6> 
<p><strong>Meaning Function L</strong>将语法（Syntax）映射到语义（Semantics）上去<br> <img src="https://images2.imgbox.com/85/c5/E9so46vN_o.png" alt="在这里插入图片描述"><br> （上图exp为expression缩写）<br> 使用Meaning Function的意义：</p> 
<ol><li>分清语法和语义</li><li>有利于将符号（notation）看做成一个独立的问题</li><li>表达式和语义并不是一一对应的</li></ol> 
<p><img src="https://images2.imgbox.com/57/32/DU0ecYxJ_o.png" alt="在这里插入图片描述"><br> 上图展示了，不同语法通过Meaning Function可能映射到相同语义上去。这有助于我们将相同功能、不同语法写成的程序，用高效的程序代替低效的程序。<br> 并且，语法不会映射到多个语义上去。（无二义性）</p> 
<h4><a id="333__108"></a>3.3.3 正规表达式如何说明编程语言中的不同方向</h4> 
<p>注：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          A 
         
        
          + 
         
        
       
         = 
        
       
         A 
        
        
        
          A 
         
        
          ∗ 
         
        
       
         = 
        
        
        
          ⋃ 
         
         
         
           i 
          
         
           &gt; 
          
         
           0 
          
         
        
       
         A 
        
       
      
        A^{+}=AA^{*}=\bigcup\limits_{i&gt;0}A 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.771331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.771331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.688696em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.75504em; vertical-align: -1.00504em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.750005em;"><span class="" style="top: -2.12233em; margin-left: 0em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.00001em;"><span class="pstrut" style="height: 3em;"></span><span class=""><span class="mop op-symbol small-op">⋃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.00504em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p> 
<table><thead><tr><th>要描述的类型</th><th>描述方法</th></tr></thead><tbody><tr><td>Keyword</td><td>‘if’+‘else’+then’…</td></tr><tr><td>Interger</td><td>digit = ‘0’+‘1’+…+‘9’<br><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            d 
           
          
            i 
           
          
            g 
           
          
            i 
           
           
           
             t 
            
           
             ∗ 
            
           
          
         
           digit^{*} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>Identifier</td><td>letter=[a-zA-Z] ([a-z](a到z求并))<br><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            l 
           
          
            e 
           
          
            t 
           
          
            t 
           
          
            e 
           
          
            r 
           
          
            ( 
           
          
            l 
           
          
            e 
           
          
            t 
           
          
            t 
           
          
            e 
           
          
            r 
           
          
            + 
           
          
            d 
           
          
            i 
           
          
            g 
           
          
            i 
           
          
            t 
           
           
           
             ) 
            
           
             ∗ 
            
           
          
         
           letter(letter+digit)^{*} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>Whitespace</td><td>’ ‘+’\n’+’\t’<br><img src="https://images2.imgbox.com/49/73/qZXXHWma_o.png" alt="在这里插入图片描述"></td></tr></tbody></table> 
<p>例子：识别email地址的正规表达式<br> anyone@cs.stanford.edu<br> 正规式表达：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         e 
        
       
         t 
        
       
         t 
        
       
         e 
        
       
         r 
        
        
        
          + 
         
        
          ′ 
         
        
        
        
          @ 
         
        
          ′ 
         
        
       
         ∣ 
        
       
         l 
        
       
         e 
        
       
         t 
        
       
         t 
        
       
         e 
        
       
         r 
        
        
        
          + 
         
        
          ′ 
         
        
        
        
          . 
         
        
          ′ 
         
        
       
         + 
        
       
         l 
        
       
         e 
        
       
         t 
        
       
         t 
        
       
         e 
        
       
         r 
        
        
        
          + 
         
        
          ′ 
         
        
        
        
          . 
         
        
          ′ 
         
        
       
         + 
        
       
         l 
        
       
         e 
        
       
         t 
        
       
         t 
        
       
         e 
        
       
         r 
        
       
      
        letter+'@'|letter+'.'+letter+'.'+letter 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.835222em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.00189em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">@</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.835222em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.835222em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.835222em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span></p> 
<p>PASCAL语言中的正规表达式例子：<br> <img src="https://images2.imgbox.com/af/06/z1K38j0p_o.png" alt="在这里插入图片描述"><br> （这里的+表示连接，在往上的文章中有用(1+0)这样表示的正规式中的+表示或，因为课件中用的是+表示或，十分有歧义，并且龙书中用的也是|。下面我尽量使用|，用以区分+，请注意）如下图所示。。。这老师用的跟我校用的那本清华的编译原理讲的也不一样，真讨厌<br> <img src="https://images2.imgbox.com/58/c4/zQNvwoHf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/06/3f/i9pd1RiY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34_lexical_specification_125"></a>3.4 词法规范（lexical specification）</h3> 
<p>词法检测过程：</p> 
<ol><li>根据词素写出Tocken类<br> <img src="https://images2.imgbox.com/37/4c/6pe3W7no_o.png" alt="在这里插入图片描述"></li><li>构建一个符合所有词素和Token的R<br><img src="https://images2.imgbox.com/d3/fd/BYiuHti1_o.png" alt="在这里插入图片描述"></li><li>输入<br><img src="https://images2.imgbox.com/b2/5e/UJ7neHLS_o.png" alt="在这里插入图片描述"></li><li><br><img src="https://images2.imgbox.com/0f/ef/IdsYoM3k_o.png" alt="在这里插入图片描述"></li><li><br><img src="https://images2.imgbox.com/09/15/oeScjRX4_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="CTMDCSDNCtrlS1000Scheie_133"></a>CTMD垃圾CSDN，Ctrl+S不能保存，写了1000多字全没了。。。。Scheiße！</h3> 
<h2><a id="4__134"></a>4 语法分析</h2> 
<h3><a id="41__135"></a>4.1 上下文无关文法</h3> 
<h4><a id="411__136"></a>4.1.1 结构</h4> 
<p><img src="https://images2.imgbox.com/e5/f3/nMnnCzAf_o.png" alt="在这里插入图片描述"><br> 左优先和右优先<br> 规范推导为右优先</p> 
<h4><a id="412__140"></a>4.1.2 二义文法</h4> 
<p><img src="https://images2.imgbox.com/5c/77/ZRtVFL0b_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/d6/pYnaGr3q_o.png" alt="在这里插入图片描述"><br> 解决方法：将二义文法改写成非二义文法<br> <img src="https://images2.imgbox.com/4f/46/JwXbdJno_o.png" alt="在这里插入图片描述"><br> 改写成：（消除左递归）</p> 
<p><img src="https://images2.imgbox.com/1a/0c/h6N986zM_o.png" alt="在这里插入图片描述"><br> 注意：<img src="https://images2.imgbox.com/14/97/mWVpulAA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42__150"></a>4.2 处理问题</h3> 
<h4><a id="421__151"></a>4.2.1 问题的种类</h4> 
<p><img src="https://images2.imgbox.com/7a/70/Kh7pO3dx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="422__153"></a>4.2.2 处理问题需要做的事</h4> 
<ol><li>准确且清晰地报告错误</li><li>快速地从错误中恢复过来（状态）</li></ol> 
<h4><a id="423__156"></a>4.2.3 处理问题的方法</h4> 
<h5><a id="4231_Panic_mode_157"></a>4.2.3.1 恐慌模式Panic mode</h5> 
<p>处理方式：一直接着吃，直到找到了一个正确的role<br> 寻找同步token<br> z.B. <br><img src="https://images2.imgbox.com/72/69/CaGBxrd6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c8/d9/FrJMjifq_o.png" alt="在这里插入图片描述"><br> 可以使用一个特殊的终结符"error"来描述有多少输入需要略过<br> <img src="https://images2.imgbox.com/5c/8c/ahoIjueJ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4232__Error_Productions_164"></a>4.2.3.2 错误产生式 Error Productions</h5> 
<p>只能知道语法中简单的错误<br> z.B. <br><br> <img src="https://images2.imgbox.com/cb/1e/xrYwkKrC_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4233__Automatic_local_or_global_correction_169"></a>4.2.3.3 自动的局部或全局矫正 Automatic local or global correction</h5> 
<p>现在并不常用这种</p> 
<p><img src="https://images2.imgbox.com/36/e2/ZJVxuDMj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/84/ThcoipOD_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4234__174"></a>4.2.3.4 过去和现在比较</h5> 
<p><img src="https://images2.imgbox.com/cb/84/nmjJVpDV_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43__176"></a>4.3 语法树</h3> 
<p>编译器剩下一部分需要一个能代替程序的结构。<br> 抽象语法树：近似语法树但忽略一些细节、简单地描述成AST（Abstract Syntax Tree）<br> <img src="https://images2.imgbox.com/6a/15/U2wn1prx_o.png" alt="在这里插入图片描述"><br> 改写成这样<br> <img src="https://images2.imgbox.com/95/fd/1Jv1om0Q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="44_182"></a>4.4递归下降的语法分析（自顶向下的语法分析）</h3> 
<p>语法树构建方法：自顶向下，从左到右<br> 先序遍历地生成Terminals<br> z.B.<br> <img src="https://images2.imgbox.com/32/ee/jnBtYey3_o.png" alt="在这里插入图片描述"><br> 生成过程，注意有回归<br> <img src="https://images2.imgbox.com/85/48/swLxAAA9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/2c/FveCPf9z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4e/d5/0Zhz6K3V_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/17/86/r4gzKVmM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d9/30/H9v1e96S_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f4/ca/jsDewW7t_o.png" alt="在这里插入图片描述"><br> accept</p> 
<h4><a id="442_RD_algorithm_195"></a>4.4.2 举一个RD algorithm例子</h4> 
<p>对于语法E：{<!-- --><br> <strong>E → T | T+E<br> T → int | int*T | (E)</strong><br> }<br> Token有：INT, OPEN, CLOSE, PLUS, TIMES<br> global next指向下一输入的token</p> 
<ol><li>定义一个返回值是bool值的检测函数，它检测将要输入的token是不是一个token。</li></ol> 
<pre><code class="prism language-c"><span class="token comment">// 返回当前token是否符合选择的token，并将指针移到下一个输入上去</span>
bool <span class="token function">term</span><span class="token punctuation">(</span>Token tok<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span>next<span class="token operator">++</span><span class="token operator">==</span>tok<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>定义一系列的代表产生式的函数S " bool Sn() { … } "，只有在相同时才返回为真。<br> 定义一个包含所有产生式的函数S " bool S() { … } "</p> 
<pre><code class="prism language-c"><span class="token comment">// z.B. 对于产生式 "E→T"有函数</span>
bool <span class="token function">E1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// z.B. 2: "E→T+E":</span>
bool <span class="token function">E2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">term</span><span class="token punctuation">(</span>PLUS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
bool <span class="token function">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	Token <span class="token operator">*</span>save <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">// 在尝试任何匹配前，先把**接下来**要从哪去token的位置记录下来。</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> save<span class="token punctuation">,</span> <span class="token function">E1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
		<span class="token operator">||</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> save<span class="token punctuation">,</span> <span class="token function">E2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>定义接下来的T的函数</li></ol> 
<pre><code class="prism language-c"><span class="token comment">// 对于 T→int</span>
bool <span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">term</span><span class="token punctuation">(</span>INT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 对于 T→int * T</span>
bool <span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">term</span><span class="token punctuation">(</span>INT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">term</span><span class="token punctuation">(</span>TIMES<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 对于 T→(E)</span>
bool <span class="token function">T3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">term</span><span class="token punctuation">(</span>OPEN<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">term</span><span class="token punctuation">(</span>CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// T → int | int*T | (E)</span>
bool <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	TOKEN <span class="token operator">*</span>save <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> save<span class="token punctuation">,</span> <span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> save<span class="token punctuation">,</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> save<span class="token punctuation">,</span> <span class="token function">T3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>开始语法分析<br> 初始化next指向输入字符串的第一个字符，调用函数E()</li></ol> 
<p>问题： 这对于输入"int * int "会reject，因为第一次使用的是E→int进行推导，如果使用E→int*T就不会出错。所以有问题”如果一个产生非终结符的产生式被使用了，则不再有回溯回来检测此时使用别的产生式的可能“<br> 通常上，自顶向下递归分析需要支持全回溯，才可以进行完整的语法检测。<br> 虽然正常情况下不使用这种算法，但这算法容易手工实现。在一个非终结符只能推导出一个终结符情况下是可用的。消除例子中的公共前缀left factoring就可以用了:)。</p> 
<h4><a id="443_left_recursion_249"></a>4.4.3 消除左递归（left recursion）</h4> 
<p>举个例子：</p> 
<pre><code class="prism language-c"><span class="token comment">// S → Sa</span>
bool <span class="token function">S1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">term</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
bool <span class="token function">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token function">S1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> 
<p>这里的S会产生无穷的递归。一个左递归语法要求没有这样的S，这样的非终结符S使得S可以加步推导出S<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         α 
        
       
      
        \alpha 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span></span></span></span></span><br> 考虑这样的语法：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         → 
        
       
         S 
        
       
         α 
        
       
         ∣ 
        
       
         β 
        
       
      
        S→S\alpha|\beta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.05278em;">β</span></span></span></span></span><br> 它会产生这样的语言：<img src="https://images2.imgbox.com/86/6f/rnFsHnBO_o.png" alt="在这里插入图片描述"><br> 这导致最后生成了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         β 
        
       
      
        \beta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05278em;">β</span></span></span></span></span>，它从右向左依次生成，因此可以右递归地生成。<img src="https://images2.imgbox.com/ea/e9/tmz05Xne_o.png" alt="在这里插入图片描述"><br> 上式也可写成右递归式：(从左向右生成)<br> <img src="https://images2.imgbox.com/73/89/zRnZD7YE_o.png" alt="在这里插入图片描述"><br> 更多的消除左递归式的例子：<br> <img src="https://images2.imgbox.com/b2/c9/fJYENpMR_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3a7f248f692c39869586b78c86b983c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hbase与Hive的联系与区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67b4ddec7596b6e72ed11223b98d0398/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu18.04&#43;Docker&#43;Hadoop&#43;Spark分布式集群搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>