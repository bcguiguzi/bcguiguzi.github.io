<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go mysql操作 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go mysql操作" />
<meta property="og:description" content="数据库驱动是不同数据库开发商（比如oracle mysql等）
为计算机语言能够实现数据库访问而开发的程序
它将计算机语言对数据库的操作翻译成自身的数据库语言
使用go语言操作mysql, 需要的驱动: github.com/go-sql-driver/mysql
使用命令:go get安装第三方mysql驱动:
C:\Windows\System32&gt;go get github.com/go-sql-driver/mysql
C:\Windows\System32&gt; // 没有报错就表示安装成功(会下载到go path里面)
查看:D:\golang\workspace\project\src\github.com\go-sql-driver\mysql
导入mysql驱动包:
import ( &#34;database/sql&#34; // 这个是go操作数据的系统包 _ &#34;github.com/go-sql-driver/mysql&#34; // go操作mysql的驱动包 ) mysql连结:
&#34;mysql&#34; 表示连结的数据库是mysql(也可以是其它的数据库)
&#34;root&#34; 表示帐户
&#34;xxx&#34; 表示密码
&#34;test&#34; 表示连结mysql的test数据库
db, err := sql.Open(&#34;mysql&#34;, &#34;root:xxx@tcp(127.0.0.1:3306)/test&#34;); 返回的 *DB 是线程安全的, 可以被多个线程同时访问, 并会维护自身的闲置连接池。
这样一来，Open函数只需调用一次, 很少需要关闭DB
可以在init中连结数据库:
/*在init中连结mysql*/ func init() { db, err := sql.Open(&#34;mysql&#34;, &#34;root:@tcp(127.0.0.1:3306)/go_test&#34;) // 此处没有密码 } 查询所有:
package main import ( &#34;fmt&#34; _ &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0ddf78cfa462545ba70a04555d23fd9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-28T15:56:42+08:00" />
<meta property="article:modified_time" content="2019-02-28T15:56:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go mysql操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>数据库驱动是不同数据库开发商（比如oracle mysql等）</p> 
<p>为计算机语言能够实现数据库访问而开发的程序</p> 
<p>它将<span style="color:#3399ea;">计算机语言</span>对数据库的操作<span style="color:#f33b45;">翻译</span>成自身的<span style="color:#3399ea;">数据库语言</span></p> 
<p> </p> 
<p>使用go语言操作mysql, 需要的驱动: <span style="color:#f33b45;">github.com/go-sql-driver/mysql</span></p> 
<p>使用命令:go get安装第三方mysql驱动:</p> 
<p><span style="color:#3399ea;">C:\Windows\System32&gt;</span><span style="color:#f33b45;">go get </span><span style="color:#3399ea;">github.com/go-sql-driver/mysql</span></p> 
<p><span style="color:#3399ea;">C:\Windows\System32&gt;                  // 没有报错就表示安装成功(会下载到go path里面)</span></p> 
<p>查看:D:\golang\workspace\<span style="color:#3399ea;">project</span>\src\github.com\go-sql-driver\<span style="color:#f33b45;">mysql</span></p> 
<p> </p> 
<p>导入mysql驱动包:</p> 
<pre class="has"><code class="language-Go">import (
    "database/sql"                        // 这个是go操作数据的系统包
    _ "github.com/go-sql-driver/mysql"    // go操作mysql的驱动包
)</code></pre> 
<p>mysql连结:</p> 
<p>"mysql" 表示连结的数据库是mysql(也可以是其它的数据库)</p> 
<p>"root" 表示帐户</p> 
<p>"xxx" 表示密码</p> 
<p>"test" 表示连结mysql的test数据库</p> 
<pre class="has"><code class="language-Go">db, err := sql.Open("mysql", "root:xxx@tcp(127.0.0.1:3306)/test");</code></pre> 
<p>返回的 *DB 是<span style="color:#f33b45;">线程安全</span>的, 可以被多个线程同时访问, 并会维护自身的闲置连接池。</p> 
<p>这样一来，Open函数只需调用一次, 很少需要关闭DB</p> 
<p>可以在init中连结数据库:</p> 
<pre class="has"><code class="language-Go">/*在init中连结mysql*/
func init() {
    db, err := sql.Open("mysql", "root:@tcp(127.0.0.1:3306)/go_test")  // 此处没有密码
}</code></pre> 
<p>查询所有:</p> 
<pre class="has"><code class="language-Go">package main
import (
    "fmt"
    _ "github.com/go-sql-driver/mysql"
    "database/sql"
)

var db *sql.DB
type Person struct{
    Id int 			
    Name string		
    Sex string		
    Email string 	
}

/*在init中连结mysql*/
func init() {
    var err error
    db, err = sql.Open("mysql", "root:@tcp(127.0.0.1:3306)/go_test")
    if err != nil {
        fmt.Println("mysql connection error: ", err)
        return
    }
}

func main() {
    rows_persons, err := db.Query("SELECT * FROM PERSION")  // 查询的结果放入"行"中, 表中有多少行记录, 就有多少个"行"
    if err != nil {
        fmt.Println("select error: ", err)
        return
    }

    var persons []Person	// 用于储存查询的结果
    for rows_persons.Next() {    // 循环 "行", 直到Next()的返回结果为false
        var person Person
        // 从rows中获取数据(参数需要sql语句里面的顺序, 才能保证数据赋值完全正确)
        rows_persons.Scan(&amp;person.Id, &amp;person.Name, &amp;person.Email, &amp;person.Sex)
        persons = append(persons, person)
    }
    fmt.Println(persons)
}</code></pre> 
<p>插入记录:</p> 
<pre class="has"><code class="language-Go">func main() {
    result, err := db.Exec("INSERT INTO PERSION(username, sex, email)VALUES (?, ?, ?)", "李四", "男", "lisi@sina.cn")
    if err != nil {
        fmt.Println("error:", err)
    }
    insertId, err2 := result.LastInsertId() // 获取最后一个insert id (RowsAffected()可以获取受影响的记录数)
    if err2 != nil {
        return
    }
    fmt.Println(insertId)
}</code></pre> 
<p>修改记录:</p> 
<p>同上, 也使用Exec函数, 返回Result, 从Result中可以获取最后一个insert id(如上)</p> 
<p>也可以获取受影响的行数(如下)</p> 
<pre class="has"><code class="language-Go">func main() {
    results, err:=db.Exec("UPDATE PERSION SET email = ? where user_id = ?", "123@.com", 2)
    if err != nil {
        return
    }
    num, err := results.RowsAffected()
    if err != nil {
        return
    }
    fmt.Println(num) // 受影响的记录数
}</code></pre> 
<p>删除记录:</p> 
<p>仍然使用Exec函数(增删改都使用它), 只是sql语句不同而已</p> 
<pre class="has"><code class="language-Go">func main() {
    results, err := db.Exec("DELETE FROM PERSION where user_id = ?", 2)
    if err != nil {
        return
    }
    num, err := results.RowsAffected()
    if err != nil {
        return
    }
    fmt.Println(num) // 受影响的记录数
}</code></pre> 
<p>sqlx:</p> 
<p>上面演示的是golang 标准库 database/sql 的基本crud操作</p> 
<p>而sqlx是 database/sql 的<span style="color:#f33b45;">扩展</span>, 可以将记录与结构体映射, 支持命名参数, 增加接口等功能</p> 
<p>sqlx的用法和sql基本是一样的(增删改), 但是sqlx的查询结果可以自动封装</p> 
<p>安装sqlx: </p> 
<p><span style="color:#3399ea;">go get</span> github.com/jmoiron/sqlx</p> 
<p>增 删改 都是一样的操作(只是sql语句不同):</p> 
<pre class="has"><code class="language-Go">package main
import (
    "fmt"
    _ "github.com/go-sql-driver/mysql"
//  "database/sql"                                // 将标准库的sql注释
    "github.com/jmoiron/sqlx"                     // 导入第三方的sqlx
)

var db *sqlx.DB			// 使用sqlx代替sql
type Person struct{
    Id int 			
    Name string		
    Sex string		
    Email string 	
}

/*在init中连结mysql*/
func init() {
    var err error
    db, err = sqlx.Open("mysql", "root:@tcp(127.0.0.1:3306)/go_test")  // Open函数不变
    if err != nil {
        fmt.Println("mysql connection error: ", err)
        return
    }
}

func main() {
    // 这里Exec函数也不变
    results, err := db.Exec("INSERT INTO PERSION VALUES(default, ?, ?, ?)", "小明", "man", "xiaoming@163.com")
    if err != nil {
        return
    }
    num, err := results.RowsAffected()
    if err != nil {
        return
    }
    fmt.Println(num) // 受影响的记录数
}</code></pre> 
<p>查询:</p> 
<p>使用Select函数</p> 
<p>在结构体中使用tag标签, 将数据库字段与结构体字段对应起来</p> 
<p>这样查询后, 它会将查询结果<span style="color:#f33b45;">自动封装</span>到结构体切片中</p> 
<pre class="has"><code class="language-Go">import (
    "fmt"
    _ "github.com/go-sql-driver/mysql"
//	"database/sql"
    "github.com/jmoiron/sqlx"
)

var db *sqlx.DB			// 使用sqlx
type Person struct{
    Id int 	        `db:"user_id"`		// 必须指明数据库中的字段映射
    Name string		`db:"username"`		// 表中字段与此要正确对应, 否则赋值不正确
    Sex string		`db:"sex"`	
    Email string 	`db:"email"`
}

/*在init中连结mysql*/
func init() {
    var err error
    db, err = sqlx.Open("mysql", "root:@tcp(127.0.0.1:3306)/go_test")  // 使用sqlx
    if err != nil {
        fmt.Println("mysql connection error: ", err)
        return
    }
}

func main() {
    var persions []Person	// 不能是一个persion, 因为并不知道查询的结果是一个还是多个
    err := db.Select(&amp;persions, "SELECT * FROM PERSION WHERE USER_ID = ?", 3)
    if err != nil {
        fmt.Println("error: ", err)
        return
    }
    fmt.Println(persions)
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/485d99350f0a7bcbf72450a9c9dd6bf2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue v-for报错：Elements in iteration expect to have &#39;v-bind:key&#39; directives解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92f534de4028dff29c34786bc6132242/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在win10上创建WiFi供其他设备使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>