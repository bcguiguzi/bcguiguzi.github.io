<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>乘法器的实现（阵列、Booth、Wallace） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="乘法器的实现（阵列、Booth、Wallace）" />
<meta property="og:description" content="文章目录 1 乘法器2 部分积的产生2.1 波兹（Booth）编码2.2 改进的波兹编码 3 部分积的累加3.1 阵列乘法器3.2 进位保留乘法器3.3 Wallace 树形乘法器 4 Verilog 实现4.1 普通阵列乘法器4.2 Booth 乘法器4.3 Wallace 乘法器 5 总结参考 1 乘法器 M和N位宽输入的乘法，采用一个N加法器需要M个周期。
利用移位和相加将M个部分积（partial product）加在一起。部分积的计算位相乘本质上是与逻辑。
101010 被乘数 × 1011 乘数 ——————————— 101010 \ 101010 | 部分积 000000 | &#43; 101010 / ————————————— 111001110 2 部分积的产生 2.1 波兹（Booth）编码 乘数 8’b0111_1110 可以转换成 8’b1000_0000 - 8’b0000_0010 。这里用8’b1000_00I0 表示（I表示 -1 ）。
这可以减少非0行的数量，使得部分积的数目至少可以减少原来的一半。部分积数目的减少意味着相加次数的减少，从而加快了运算速度并减少了面积。
保证了在每两个连续位中最多只有一个是 1 或者 -1 。形式上相当于把乘数变换成一个四进制形式。8’b1000_00I0 = (2,0,0,-2)(四进制)
问题：与{0,1}相乘等效于AND，但是与{-2，-1，0，1，2}相乘还需要反向逻辑和移位逻辑，大小不同的部分积阵列对乘法器设计不合理。
2.2 改进的波兹编码 改进的波兹编码（modified Booth’s recoding）乘数由最高有效位（msb）到最低有效位（lsb）进行，按3位一组进行划分，相互重叠一位，编码表：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5563ae84b098aa5d462adc91f1c8fa2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-10T10:08:29+08:00" />
<meta property="article:modified_time" content="2022-05-10T10:08:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">乘法器的实现（阵列、Booth、Wallace）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__5" rel="nofollow">1 乘法器</a></li><li><a href="#2__22" rel="nofollow">2 部分积的产生</a></li><li><ul><li><a href="#21_Booth_24" rel="nofollow">2.1 波兹（Booth）编码</a></li><li><a href="#22__36" rel="nofollow">2.2 改进的波兹编码</a></li></ul> 
  </li><li><a href="#3__59" rel="nofollow">3 部分积的累加</a></li><li><ul><li><a href="#31__64" rel="nofollow">3.1 阵列乘法器</a></li><li><a href="#32__78" rel="nofollow">3.2 进位保留乘法器</a></li><li><a href="#33_Wallace__93" rel="nofollow">3.3 Wallace 树形乘法器</a></li></ul> 
  </li><li><a href="#4_Verilog__117" rel="nofollow">4 Verilog 实现</a></li><li><ul><li><a href="#41__118" rel="nofollow">4.1 普通阵列乘法器</a></li><li><a href="#42_Booth__237" rel="nofollow">4.2 Booth 乘法器</a></li><li><a href="#43_Wallace__406" rel="nofollow">4.3 Wallace 乘法器</a></li></ul> 
  </li><li><a href="#5__544" rel="nofollow">5 总结</a></li><li><a href="#_547" rel="nofollow">参考</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1__5"></a>1 乘法器</h2> 
<p>M和N位宽输入的乘法，采用一个N加法器需要M个周期。</p> 
<p>利用移位和相加将M个部分积（partial product）加在一起。部分积的计算位相乘本质上是与逻辑。</p> 
<pre><code>         101010       被乘数
      ×    1011       乘数
      ———————————
         101010   \
        101010     |  部分积
       000000      |
    + 101010      /
    —————————————
      111001110
</code></pre> 
<h2><a id="2__22"></a>2 部分积的产生</h2> 
<h3><a id="21_Booth_24"></a>2.1 波兹（Booth）编码</h3> 
<p>乘数 8’b0111_1110 可以转换成 8’b1000_0000 - 8’b0000_0010 。这里用8’b1000_00I0 表示（I表示 -1 ）。</p> 
<p>这可以减少非0行的数量，使得部分积的数目至少可以减少原来的一半。部分积数目的减少意味着相加次数的减少，从而加快了运算速度并减少了面积。</p> 
<p>保证了在每两个连续位中最多只有一个是 1 或者 -1 。形式上相当于把乘数变换成一个四进制形式。8’b1000_00I0 = (2,0,0,-2)(四进制)</p> 
<p>问题：与{0,1}相乘等效于AND，但是与{-2，-1，0，1，2}相乘还需要反向逻辑和移位逻辑，大小不同的部分积阵列对乘法器设计不合理。</p> 
<h3><a id="22__36"></a>2.2 改进的波兹编码</h3> 
<p>改进的波兹编码（modified Booth’s recoding）乘数由最高有效位（msb）到最低有效位（lsb）进行，按3位一组进行划分，相互重叠一位，编码表：</p> 
<table><thead><tr><th>乘数位</th><th>编码位</th><th>编码</th></tr></thead><tbody><tr><td>000</td><td>0</td><td>00</td></tr><tr><td>001</td><td>+被乘数</td><td>01</td></tr><tr><td>010</td><td>+被乘数</td><td>01</td></tr><tr><td>011</td><td>+2×被乘数</td><td>10</td></tr><tr><td>100</td><td>-2×被乘数</td><td>I0</td></tr><tr><td>101</td><td>-被乘数</td><td>0I</td></tr><tr><td>110</td><td>-被乘数</td><td>0I</td></tr><tr><td>111</td><td>0</td><td>00</td></tr></tbody></table> 
<p>本质是从msb到lsb检查乘数中1的字串，用一个以1开头或以-1结尾的字符串代替他们。<br> 例子：<br> 011 ：一串1的开始，所以用一个开头的1代替（100）<br> 110 ：一串1的结尾，所以用一个结尾的-1代替（0I0）</p> 
<p>8’b0111_1110，从msb到lsb，分成3位一组首尾重叠的4组：01(1)，11(1)，11(1)，10(0)。编码后为10，00，00，I0,这与上述的编码是吻合的。</p> 
<h2><a id="3__59"></a>3 部分积的累加</h2> 
<p>对部分积相加是一个多操作数的加法，一个直接累加的部分积方法是用许多加法器形成阵列，所以被称为 阵列乘法器（array multiplier）。</p> 
<p>一个更为先进的方法与树结构的形式完成加法。</p> 
<h3><a id="31__64"></a>3.1 阵列乘法器</h3> 
<p><img src="https://images2.imgbox.com/35/49/QSjaGKSB_o.png" alt="在这里插入图片描述"></p> 
<p>AND 门产生部分积，加法器阵列实现相加。</p> 
<p><img src="https://images2.imgbox.com/84/2e/5zG8FooX_o.png" alt="在这里插入图片描述"></p> 
<p>所有关键路径都具有相同的长度。</p> 
<p>上述乘法器只能进行无符号数相乘。</p> 
<h3><a id="32__78"></a>3.2 进位保留乘法器</h3> 
<p>如果进位向下沿而不是向左，可以得到一个更有效的实现。进位不是立即相加，而是传递给下一级加法器，在最后一级在一个快速进位传播（如超前进位）加法器中合并。</p> 
<p>代价：需要一个额外的加法器，被称为向量合并（vector-merging）加法器。由此得到的乘法器被称为进位保留乘法器。</p> 
<p>优点：在最坏情形下关键路径最短且唯一确定。</p> 
<p>拓扑优化后的结构：</p> 
<p><img src="https://images2.imgbox.com/03/e0/RHN5PD86_o.png" alt="在这里插入图片描述"></p> 
<p>这种结构可以更好的映射到硅片上。</p> 
<h3><a id="33_Wallace__93"></a>3.3 Wallace 树形乘法器</h3> 
<p>部分积加法器可以设计成树形，可以减少关键路径和所需的加法器单元数目。</p> 
<p><img src="https://images2.imgbox.com/73/4e/GZXHiBTr_o.png" alt="在这里插入图片描述"></p> 
<p>上面的4个4位部分积，只有第3bit需要加 4 个。</p> 
<p>第一步，第3列和低4列引入2个半加器，如图b所示，压缩后得到图c。<br> 第二步，第3、4、5列引入3个全加器，第2列引入1个半加器，得到图d。<br> 第三步，使用简单的两输入加法器。</p> 
<p>前两步一共使用了3个全加器、3个半加器。原来的进位保留乘法器结构需要6个全加器、6个半加器。</p> 
<p>全加器3个输入两个输出，所以运算过程中又称为压缩器。</p> 
<p>优点：</p> 
<ul><li>节省了较大乘法器所需硬件，减少了传播延时。</li></ul> 
<p>缺点：</p> 
<ul><li>不规则，高质量版图设计任务变复杂。</li></ul> 
<hr> 
<h2><a id="4_Verilog__117"></a>4 Verilog 实现</h2> 
<h3><a id="41__118"></a>4.1 普通阵列乘法器</h3> 
<p>以 8bit 无符号数相乘为例，注意这里的设计没有考虑性能。</p> 
<p>array_multiplier.v：</p> 
<pre><code>`timescale 1ns/1ps  

module array_multiplier ( 
    input               I_sys_clk,
    input               I_reset_n,
    input               I_valid,
    input      [7:0]    I_a,
    input      [7:0]    I_b,
    output reg          O_valid,
    output reg [15:0]   O_c
);
                
//--- Main body of code ---  
always @(posedge I_sys_clk or negedge I_reset_n)
begin
    if(~I_reset_n) 
    begin
        O_valid &lt;= 1'b0;
        O_c     &lt;= 16'b0;
    end 
    else
    begin
        O_valid &lt;= I_valid;
        O_c     &lt;= (({8{I_b[0]}} &amp; I_a)     ) + 
                   (({8{I_b[1]}} &amp; I_a) &lt;&lt; 1) + 
                   (({8{I_b[2]}} &amp; I_a) &lt;&lt; 2) + 
                   (({8{I_b[3]}} &amp; I_a) &lt;&lt; 3) + 
                   (({8{I_b[4]}} &amp; I_a) &lt;&lt; 4) + 
                   (({8{I_b[5]}} &amp; I_a) &lt;&lt; 5) + 
                   (({8{I_b[6]}} &amp; I_a) &lt;&lt; 6) + 
                   (({8{I_b[7]}} &amp; I_a) &lt;&lt; 7)  
                   ;
    end
end

endmodule 
</code></pre> 
<p>testbench array_multiplier_tb.sv:</p> 
<pre><code>`timescale 1ns/1ps

module array_multiplier_tb();

parameter T = 5;  

reg           I_sys_clk;
reg           I_reset_n;
reg           I_valid  ;
reg  [7:0]    I_a      ;
reg  [7:0]    I_b      ;
wire          O_valid  ;
wire [15:0]   O_c      ;


initial begin
    I_sys_clk &lt;= 'b0;
    I_reset_n &lt;= 'b0;
    I_valid   &lt;= 'b0; 
    I_a       &lt;= 'b0; 
    I_b       &lt;= 'b0; 
    #(T*20)  
    I_reset_n &lt;= 'b1;
    #(T*20)  
    data_gen();
    $finish();
end

always #(T/2) I_sys_clk &lt;= ~I_sys_clk;


array_multiplier array_multiplier_u ( 
    .I_sys_clk(I_sys_clk),
    .I_reset_n(I_reset_n),
    .I_valid  (I_valid  ),
    .I_a      (I_a      ),
    .I_b      (I_b      ),
    .O_valid  (O_valid  ),
    .O_c      (O_c      )
);

task data_gen();
    for (int i = 0; i &lt; 256; i++) begin
        I_valid   &lt;= 'b1; 
        I_a       &lt;= i; 
        I_b       &lt;= i;
        $display("%d x %d = %d", i, i, i*i);
        @(posedge I_sys_clk);
        I_valid   &lt;= 'b0;
    end
endtask

endmodule
</code></pre> 
<p>sim.do 文件：</p> 
<pre><code>cd D:/prj/modelsim_prj/multiplier/array_multiplier/ 
vlib work  
vlog array_multiplier.v  array_multiplier_tb.sv 
vsim -novopt work.array_multiplier_tb 
</code></pre> 
<p>sim.bat 文件：</p> 
<pre><code>vsim -do sim.do
</code></pre> 
<p>所有文件放在相同路径下，双击批处理文件即可开始Modelsim仿真。</p> 
<p>仿真结果：<br> <img src="https://images2.imgbox.com/fa/6d/dI4MRf8h_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42_Booth__237"></a>4.2 Booth 乘法器</h3> 
<p>Verilog 设计，注意，这个代码只是描述算法，需要进行符号位拓展、乘换成与逻辑、以及将乘2的幂转换为移位处理。</p> 
<pre><code class="prism language-C">`timescale 1ns/1ps

module booth_multiplier (
    input               I_sys_clk,
    input               I_reset_n,
    input               I_valid  ,
    input      [7:0]    I_a      ,
    input      [7:0]    I_b      ,
    output reg          O_valid  ,
    output reg [15:0]   O_c
);

//--- Main body of code ---  
wire [8:0] W_b;
wire [15:0] W_a_n;
wire [2:0] W_booth_code_pre [0:3];
reg       R_valid                ;
reg signed [15:0] R_partial_product [0:3];

assign W_b = {I_b, 1'b0};
assign W_a_n = -{<!-- -->{8{I_a[7]}}, I_a};

genvar gen_i;
for (gen_i = 0; gen_i &lt; 4; gen_i = gen_i + 1) begin 
    assign W_booth_code_pre[gen_i] = W_b[gen_i*2 +: 3];
    always @(posedge I_sys_clk or negedge I_reset_n)
    begin
        if(~I_reset_n) 
        begin
            R_partial_product[gen_i] &lt;= 1'b0;
        end 
        else
        begin
            case (W_booth_code_pre[gen_i])
                3'b000: R_partial_product[gen_i] &lt;= 9'b0;
                3'b001: R_partial_product[gen_i] &lt;= $signed(I_a) *  1 * 2**(gen_i*2) ;
                3'b010: R_partial_product[gen_i] &lt;= $signed(I_a) *  1 * 2**(gen_i*2) ;
                3'b011: R_partial_product[gen_i] &lt;= $signed(I_a) *  2 * 2**(gen_i*2) ;
                3'b100: R_partial_product[gen_i] &lt;= $signed(I_a) * -2 * 2**(gen_i*2) ;
                3'b101: R_partial_product[gen_i] &lt;= $signed(I_a) * -1 * 2**(gen_i*2) ;
                3'b110: R_partial_product[gen_i] &lt;= $signed(I_a) * -1 * 2**(gen_i*2) ;
                3'b111: R_partial_product[gen_i] &lt;= 9'b0;
                default: R_partial_product[gen_i] &lt;= 9'b0;
            endcase
        end
    end
end

always @(posedge I_sys_clk or negedge I_reset_n)
begin
    if(~I_reset_n) 
    begin
        R_valid &lt;= 1'b0;
    end 
    else
    begin
        R_valid &lt;= I_valid;
    end
end

always @(posedge I_sys_clk or negedge I_reset_n)
begin
    if(~I_reset_n) 
    begin
        O_valid &lt;= 1'b0;
        O_c     &lt;= 16'b0;
    end 
    else
    begin
        O_valid &lt;= R_valid;
        O_c     &lt;= R_partial_product[0] + 
                   R_partial_product[1] + 
                   R_partial_product[2] + 
                   R_partial_product[3]  
                   ;
    end
end

endmodule
</code></pre> 
<p>testchech：</p> 
<pre><code>`timescale 1ns/1ps

module booth_multiplier_tb();

parameter T = 5;  

reg           I_sys_clk;
reg           I_reset_n;
reg           I_valid  ;
reg  [7:0]    I_a      ;
reg  [7:0]    I_b      ;
wire          O_valid  ;
wire [15:0]   O_c      ;

// reference model signal
reg [7:0]    R_i ;
reg [7:0]    R1_i ;
reg [7:0]    R2_i ;

initial begin
    I_sys_clk &lt;= 'b0;
    I_reset_n &lt;= 'b0;
    I_valid   &lt;= 'b0; 
    I_a       &lt;= 'b0; 
    I_b       &lt;= 'b0; 
    #(T*20)  
    I_reset_n &lt;= 'b1;
    #(T*20)  
    data_gen();
    $finish();
end

always #(T/2) I_sys_clk &lt;= ~I_sys_clk;


booth_multiplier booth_multiplier_u ( 
    .I_sys_clk(I_sys_clk),
    .I_reset_n(I_reset_n),
    .I_valid  (I_valid  ),
    .I_a      (I_a      ),
    .I_b      (I_b      ),
    .O_valid  (O_valid  ),
    .O_c      (O_c      )
);


task data_gen();
    for (int i = 0; i &lt; 256; i++) begin
        I_valid   &lt;= 'b1; 
        I_a       &lt;= i; 
        I_b       &lt;= i;
        R_i &lt;= i;
        R1_i &lt;= R_i;
        R2_i &lt;= R1_i;
        // reference model
        if (O_valid)
        begin
            $display("i=%d, O_c=%d, check=%d", $signed(R2_i), $signed(O_c), $signed(O_c) == $signed(R2_i) * $signed(R2_i));
        end
        @(posedge I_sys_clk);
        I_valid   &lt;= 'b0;
    end
endtask

endmodule
</code></pre> 
<p>Modilsim do文件做对应修改，sim.do：</p> 
<pre><code>cd D:/prj/modelsim_prj/multiplier/booth_multiplier/ 
vlib work  
vlog booth_multiplier.v  booth_multiplier_tb.sv 
vsim -novopt work.booth_multiplier_tb 

</code></pre> 
<p>仿真结果：</p> 
<p><img src="https://images2.imgbox.com/1b/93/9KWAKDIk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43_Wallace__406"></a>4.3 Wallace 乘法器</h3> 
<p>以4bit×4bit为例，按照结构把线连起来就行：<br> wallace_multiplier.v:</p> 
<pre><code class="prism language-C">`timescale 1ns/1ps

module wallace_multiplier (
    input               I_sys_clk,
    input               I_reset_n,
    input               I_valid  ,
    input      [3:0]    I_a      ,
    input      [3:0]    I_b      ,
    output reg          O_valid  ,
    output reg [7:0]    O_c
);

reg       R_valid ;
reg [3:0] R_partial_product [0:3];  

wire [1:0] W_level1_c,W_level1_carry;
wire [3:0] W_level2_c,W_level2_carry;
wire [6:0] W_level3[0:1];

genvar gen_i;
generate
    for (gen_i = 0; gen_i &lt; 4; gen_i = gen_i + 1) begin
        always @(posedge I_sys_clk or negedge I_reset_n)
        begin
            if(~I_reset_n) 
            begin
                R_partial_product[gen_i] = 4'd0;
            end 
            else
            begin
                R_partial_product[gen_i] = {4{I_b[gen_i]}} &amp; I_a;
            end
        end
    end
endgenerate

// level1
adder_half adder_half_u1 (
    .I_a    (R_partial_product[2][1]),
    .I_b    (R_partial_product[3][0]),
    .O_c    (W_level1_c[0]),
    .O_carry(W_level1_carry[0])
); 
adder_half adder_half_u2 (
    .I_a    (R_partial_product[1][3]),
    .I_b    (R_partial_product[2][2]),
    .O_c    (W_level1_c[1]),
    .O_carry(W_level1_carry[1])
);


// level2
adder_half adder_half_u3 (
    .I_a    (R_partial_product[1][1]),
    .I_b    (R_partial_product[2][0]),
    .O_c    (W_level2_c[0]    ),
    .O_carry(W_level2_carry[0])
);
adder adder_u1 (
    .I_a     (R_partial_product[0][3]),
    .I_b     (R_partial_product[1][2]),
    .I_carry (W_level1_c[0]          ),
    .O_c     (W_level2_c[1]          ),
    .O_carry (W_level2_carry[1]      )
);
adder adder_u2 (
    .I_a     (R_partial_product[1][3]),
    .I_b     (W_level1_c[1]          ),
    .I_carry (W_level1_carry[0]      ),
    .O_c     (W_level2_c[2]          ),
    .O_carry (W_level2_carry[2]      )
);
adder adder_u3 (
    .I_a     (R_partial_product[2][3]),
    .I_b     (R_partial_product[3][2]),
    .I_carry (W_level1_carry[1]       ),
    .O_c     (W_level2_c[3]          ),
    .O_carry (W_level2_carry[3]      )
);

assign W_level3[0] = {R_partial_product[3][3], W_level2_c[3:1], R_partial_product[0][2:0]};
assign W_level3[1] = {W_level2_carry[3:0], W_level2_c[0], R_partial_product[1][0], 1'b0};

always @(posedge I_sys_clk or negedge I_reset_n)
begin
    if(~I_reset_n) 
    begin
        R_valid &lt;= 1'b0;
        O_valid &lt;= 1'd0;
        O_c     &lt;= 8'd0;
    end 
    else
    begin
        R_valid &lt;= I_valid;
        O_valid &lt;= R_valid;
        O_c     &lt;= W_level3[0] + W_level3[1]; 
                   
    end
end

endmodule

module adder_half (
    input  I_a,
    input  I_b,
    output O_c,
    output O_carry
);

assign O_c = I_a ^ I_b;
assign O_carry = I_a &amp; I_b;

endmodule

module adder (
    input  I_a,
    input  I_b,
    input  I_carry,
    output O_c,
    output O_carry
);

assign O_c = I_a ^ I_b ^ I_carry;
assign O_carry = (I_a &amp; I_b) | ((I_a ^ I_b) &amp; I_carry);

endmodule
</code></pre> 
<p>仿真结果：</p> 
<p><img src="https://images2.imgbox.com/b3/c6/NVhbWZwU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5__544"></a>5 总结</h2> 
<p>数字集成电路设计可能对加法器的面积和版图有较高的要求。对于FPGA设计，可能基本阵列加法器用着还更简单顺手。主要看的的题目可能问的是与一个常数相乘的设计，这个时候要参考 Booth 编码的思想，因为不是实时乘数的话，预编码之后确实还是节省资源的。</p> 
<h2><a id="_547"></a>参考</h2> 
<p>数字集成电路-电路、系统与设计（第二版）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/553e8fcd69df99dfec6c2cf754cdadcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">＜转＞详解 慢查询 之 mysqldumpslow</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ddc9cac21bfa0472db5df78f7024b82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【已解决】list.size() = 1 但显示 All elements are null</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>