<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>node.js的开发流程_Node.js子流程：您需要了解的一切 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="node.js的开发流程_Node.js子流程：您需要了解的一切" />
<meta property="og:description" content="node.js的开发流程
by Samer Buna
通过Samer Buna Node.js子流程：您需要了解的一切 (Node.js Child Processes: Everything you need to know) 如何使用spawn()，exec()，execFile()和fork() (How to use spawn(), exec(), execFile(), and fork()) Update: This article is now part of my book “Node.js Beyond The Basics”.
更新：这篇文章现在是我的书《超越基础的Node.js》的一部分。 Update: This article is now part of my book “Node.js Beyond The Basics”.
更新：这篇文章现在是我的书《超越基础的Node.js》的一部分。 Read the updated version of this content and more about Node at jscomplete.com/node-beyond-basics.
在jscomplete.com/node-beyond-basics中阅读此内容的更新版本以及有关Node的更多信息。 Single-threaded, non-blocking performance in Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d9359e9bc20a7e3bbd87e170b1103303/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-15T22:20:12+08:00" />
<meta property="article:modified_time" content="2020-07-15T22:20:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">node.js的开发流程_Node.js子流程：您需要了解的一切</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>node.js的开发流程</p> 
 <p>by Samer Buna</p> 
 <p> 通过Samer Buna </p> 
 <h2 id="node-js-child-processes-everything-you-need-to-know"> Node.js子流程：您需要了解的一切 <span style="font-weight: bold;">(</span>Node.js Child Processes: Everything you need to know<span style="font-weight: bold;">)</span></h2> 
 <h5 id="how-to-use-spawn-exec-execfile-and-fork-"> 如何使用spawn()，exec()，execFile()和fork() <span style="font-weight: bold;">(</span>How to use spawn(), exec(), execFile(), and fork()<span style="font-weight: bold;">)</span></h5> 
 <blockquote> 
  <p><strong>Update:</strong> This article is now part of my book “Node.js Beyond The Basics”.</p> 
  <p> <strong>更新：</strong>这篇文章现在是我的书《超越基础的Node.js》的一部分。 </p> 
  <p><strong>Update:</strong> This article is now part of my book “Node.js Beyond The Basics”.</p> 
  <p> <strong>更新：</strong>这篇文章现在是我的书《超越基础的Node.js》的一部分。 </p> 
  <p>Read the updated version of this content and more about Node at <a href="https://jscomplete.com/g/node-cps" rel="noopener"><strong>jscomplete.com/node-beyond-basics</strong></a>.</p> 
  <p> 在<a href="https://jscomplete.com/g/node-cps" rel="noopener"><strong>jscomplete.com/node-beyond-basics中</strong></a>阅读此内容的更新版本以及有关Node的更多信息。 </p> 
 </blockquote> 
 <p>Single-threaded, non-blocking performance in Node.js works great for a single process. But eventually, one process in one CPU is not going to be enough to handle the increasing workload of your application.</p> 
 <p> Node.js中的单线程无阻塞性能非常适合单个进程。 但是最终，一个CPU中的一个进程不足以处理应用程序不断增加的工作量。 </p> 
 <p>No matter how powerful your server may be, a single thread can only support a limited load.</p> 
 <p> 无论您的服务器多么强大，一个线程只能支持有限的负载。 </p> 
 <p>The fact that Node.js runs in a single thread does not mean that we can’t take advantage of multiple processes and, of course, multiple machines as well.</p> 
 <p> Node.js在单个线程中运行的事实并不意味着我们不能利用多个进程，当然也不能利用多个计算机。 </p> 
 <p>Using multiple processes is the best way to scale a Node application. Node.js is designed for building distributed applications with many nodes. This is why it’s named <em>Node</em>. Scalability is baked into the platform and it’s not something you start thinking about later in the lifetime of an application.</p> 
 <p> 使用多个进程是扩展Node应用程序的最佳方法。 Node.js设计用于构建具有许多节点的分布式应用程序。 这就是为什么它被命名为<em>Node的原因</em> 。 可伸缩性已植入平台中，您在应用程序的生命周期后期就不会考虑它。 </p> 
 <blockquote> 
  <p>This article is a write-up of part of <a href="https://www.pluralsight.com/courses/nodejs-advanced" rel="noopener">my Pluralsight course about Node.js</a>. I cover similar content in video format there.</p> 
  <p> 本文是<a href="https://www.pluralsight.com/courses/nodejs-advanced" rel="noopener">我的Pluralsight课程有关Node.js</a>的一部分的<a href="https://www.pluralsight.com/courses/nodejs-advanced" rel="noopener">文章</a> 。 我在那里以视频格式介绍了类似的内容。 </p> 
 </blockquote> 
 <p>Please note that you’ll need a good understanding of Node.js <em>events</em> and <em>streams</em> before you read this article. If you haven’t already, I recommend that you read these two other articles before you read this one:</p> 
 <p> 请注意，在阅读本文之前，您需要对Node.js <em>事件</em>和<em>流</em>有充分的了解。 如果还没有，我建议您在阅读本文之前先阅读另外两篇文章： </p> 
 <p><strong><a href="https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/" rel="nofollow">Understanding Node.js Event-Driven Architecture</a></strong><em><a href="https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/" rel="nofollow">Most of Node’s objects — like HTTP requests, responses, and streams — implement the EventEmitter module so they can…</a></em></p> 
 <p> <strong><a href="https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/" rel="nofollow">了解Node.js事件驱动的体系结构</a></strong> <em><a href="https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/" rel="nofollow">Node的大多数对象(例如HTTP请求，响应和流)都实现EventEmitter模块，以便它们可以…</a></em> </p> 
 <p><a href="https://medium.freecodecamp.com/node-js-streams-everything-you-need-to-know-c9141306be93" rel="noopener"><strong>Streams: Everything you need to know</strong></a><em><a href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="nofollow">Node.js streams have a reputation for being hard to work with, and even harder to understand. Well I’ve got good news…</a></em></p> 
 <p> <a href="https://medium.freecodecamp.com/node-js-streams-everything-you-need-to-know-c9141306be93" rel="noopener"><strong>流：您需要了解的所有内容，</strong></a> <em><a href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="nofollow">Node.js流</a></em> <a href="https://medium.freecodecamp.com/node-js-streams-everything-you-need-to-know-c9141306be93" rel="noopener"><strong>以</strong></a> <em><a href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="nofollow">难以使用甚至难以理解而闻名。</a></em> <em><a href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="nofollow">好吧，我有个好消息……</a></em> </p> 
 <h4 id="the-child-processes-module"> 子进程模块 <span style="font-weight: bold;">(</span>The Child Processes Module<span style="font-weight: bold;">)</span></h4> 
 <p>We can easily spin a child process using Node’s <code>child_process</code> module and those child processes can easily communicate with each other with a messaging system.</p> 
 <p> 我们可以使用Node的<code>child_process</code>模块轻松地旋转一个子进程，并且这些子进程可以通过消息传递系统轻松地相互通信。 </p> 
 <p>The <code>child_process</code> module enables us to access Operating System functionalities by running any system command inside a, well, child process.</p> 
 <p> <code>child_process</code>模块使我们能够通过运行子进程内部的任何系统命令来访问操作系统功能。 </p> 
 <p>We can control that child process input stream, and listen to its output stream. We can also control the arguments to be passed to the underlying OS command, and we can do whatever we want with that command’s output. We can, for example, pipe the output of one command as the input to another (just like we do in Linux) as all inputs and outputs of these commands can be presented to us using <a href="https://medium.freecodecamp.com/node-js-streams-everything-you-need-to-know-c9141306be93" rel="noopener">Node.js streams</a>.</p> 
 <p> 我们可以控制该子进程的输入流，并监听其输出流。 我们还可以控制要传递给底层OS命令的参数，并且可以对该命令的输出执行任何所需的操作。 例如，我们可以将一个命令的输出作为输入传递给另一个命令(就像在Linux中一样)，因为可以使用<a href="https://medium.freecodecamp.com/node-js-streams-everything-you-need-to-know-c9141306be93" rel="noopener">Node.js流向</a>我们展示这些命令的所有输入和输出。 </p> 
 <p><em>Note that examples I’ll be using in this article are all Linux-based. On Windows, you need to switch the commands I use with their Windows alternatives.</em></p> 
 <p> <em>请注意，我将在本文中使用的示例全部基于Linux。</em> <em>在Windows上，您需要切换与Windows替代品一起使用的命令。</em> </p> 
 <p>There are four different ways to create a child process in Node: <code>spawn()</code>, <code>fork()</code>, <code>exec()</code>, and <code>execFile()</code>.</p> 
 <p> 在Node中有四种创建子进程的方法： <code>spawn()</code> ， <code>fork()</code> ， <code>exec()</code>和<code>execFile()</code> 。 </p> 
 <p>We’re going to see the differences between these four functions and when to use each.</p> 
 <p> 我们将看到这四个函数之间的区别以及何时使用它们。 </p> 
 <h5 id="spawned-child-processes"> 产生的子进程 <span style="font-weight: bold;">(</span>Spawned Child Processes<span style="font-weight: bold;">)</span></h5> 
 <p>The <code>spawn</code> function launches a command in a new process and we can use it to pass that command any arguments. For example, here’s code to spawn a new process that will execute the <code>pwd</code> command.</p> 
 <p> <code>spawn</code>函数在新进程中启动命令，我们可以使用它来传递该命令的任何参数。 例如，以下代码产生一个新进程，该进程将执行<code>pwd</code>命令。 </p> 
 <pre class="has"><code>const { spawn } = require('child_process');

const child = spawn('pwd');</code></pre> 
 <p>We simply destructure the <code>spawn</code> function out of the <code>child_process</code> module and execute it with the OS command as the first argument.</p> 
 <p> 我们只需从<code>child_process</code>模块中解构出<code>spawn</code>函数，并以OS命令作为第一个参数来执行它即可。 </p> 
 <p>The result of executing the <code>spawn</code> function (the <code>child</code> object above) is a <code>ChildProcess</code> instance, which implements the <a href="https://medium.freecodecamp.com/understanding-node-js-event-driven-architecture-223292fcbc2d" rel="noopener">EventEmitter API</a>. This means we can register handlers for events on this child object directly. For example, we can do something when the child process exits by registering a handler for the <code>exit</code> event:</p> 
 <p> 执行<code>spawn</code>函数(上面的<code>child</code>对象)的结果是一个<code>ChildProcess</code>实例，该实例实现了<a href="https://medium.freecodecamp.com/understanding-node-js-event-driven-architecture-223292fcbc2d" rel="noopener">EventEmitter API</a> 。 这意味着我们可以直接在此子对象上注册事件的处理程序。 例如，当子进程退出时，我们可以通过为<code>exit</code>事件注册一个处理程序来做一些事情： </p> 
 <pre class="has"><code class="language-js">child.on('exit', function (code, signal) {
  console.log('child process exited with ' +
              `code ${code} and signal ${signal}`);
});</code></pre> 
 <p>The handler above gives us the exit <code>code</code> for the child process and the <code>signal</code>, if any, that was used to terminate the child process. This <code>signal</code> variable is null when the child process exits normally.</p> 
 <p> 上面的处理程序为我们提供了子进程的退出<code>code</code>和用于终止子进程的<code>signal</code> (如果有)。 当子进程正常退出时，此<code>signal</code>变量为null。 </p> 
 <p>The other events that we can register handlers for with the <code>ChildProcess</code> instances are <code>disconnect</code>, <code>error</code>, <code>close</code>, and <code>message</code>.</p> 
 <p> 我们可以使用<code>ChildProcess</code>实例注册处理程序的其他事件是<code>disconnect</code> ， <code>error</code> ， <code>close</code>和<code>message</code> 。 </p> 
 <ul><li><p>The <code>disconnect</code> event is emitted when the parent process manually calls the <code>child.disconnect</code> function.</p><p> 当父进程手动调用<code>child.disconnect</code>函数时，将发出<code>disconnect</code>事件。 </p></li><li><p>The <code>error</code> event is emitted if the process could not be spawned or killed.</p><p> 如果无法生成或终止进程， <code>error</code>发出<code>error</code>事件。 </p></li><li><p>The <code>close</code> event is emitted when the <code>stdio</code> streams of a child process get closed.</p><p> 当子进程的<code>stdio</code>流<code>close</code>时，发出<code>close</code>事件。 </p></li><li><p>The <code>message</code> event is the most important one. It’s emitted when the child process uses the <code>process.send()</code> function to send messages. This is how parent/child processes can communicate with each other. We’ll see an example of this below.</p><p> <code>message</code>事件是最重要的事件。 当子进程使用<code>process.send()</code>函数发送消息时发出。 父/子进程可以这样相互通信。 我们将在下面看到一个示例。 </p></li></ul> 
 <p>Every child process also gets the three standard <code>stdio</code> streams, which we can access using <code>child.stdin</code>, <code>child.stdout</code>, and <code>child.stderr</code>.</p> 
 <p> 每个子进程还获得三个标准<code>stdio</code>流，我们可以使用<code>child.stdin</code> ， <code>child.stdout</code>和<code>child.stderr</code> 。 </p> 
 <p>When those streams get closed, the child process that was using them will emit the <code>close</code> event. This <code>close</code> event is different than the <code>exit</code> event because multiple child processes might share the same <code>stdio</code> streams and so one child process exiting does not mean that the streams got closed.</p> 
 <p> 当这些流关闭时，使用它们的子进程将发出<code>close</code>事件。 此<code>close</code>事件与<code>exit</code>事件不同，因为多个子进程可能共享相同的<code>stdio</code>流，因此一个子进程退出并不意味着流已关闭。 </p> 
 <p>Since all streams are event emitters, we can listen to different events on those <code>stdio</code> streams that are attached to every child process. Unlike in a normal process though, in a child process, the <code>stdout</code>/<code>stderr</code> streams are readable streams while the <code>stdin</code> stream is a writable one. This is basically the inverse of those types as found in a main process. The events we can use for those streams are the standard ones. Most importantly, on the readable streams, we can listen to the <code>data</code> event, which will have the output of the command or any error encountered while executing the command:</p> 
 <p> 由于所有流都是事件发射器，因此我们可以在附加到每个子进程的<code>stdio</code>流上侦听不同的事件。 但是，与普通进程不同，在子进程中， <code>stdout</code> / <code>stderr</code>流是可读流，而<code>stdin</code>流是可写流。 从本质上讲，这与在主要过程中发现的那些类型相反。 我们可以用于这些流的事件是标准事件。 最重要的是，在可读流上，我们可以侦听<code>data</code>事件，该事件将具有命令的输出或执行命令时遇到的任何错误： </p> 
 <pre class="has"><code class="language-js">child.stdout.on('data', (data) =&gt; {
  console.log(`child stdout:\n${data}`);
});

child.stderr.on('data', (data) =&gt; {
  console.error(`child stderr:\n${data}`);
});</code></pre> 
 <p>The two handlers above will log both cases to the main process <code>stdout</code> and <code>stderr</code>. When we execute the <code>spawn</code> function above, the output of the <code>pwd</code> command gets printed and the child process exits with code <code>0</code>, which means no error occurred.</p> 
 <p> 上面的两个处理程序会将这两种情况都记录到主进程<code>stdout</code>和<code>stderr</code> 。 当我们执行上面的<code>spawn</code>函数时，将打印<code>pwd</code>命令的输出，并且子进程以代码<code>0</code>退出，这意味着没有发生错误。 </p> 
 <p>We can pass arguments to the command that’s executed by the <code>spawn</code> function using the second argument of the <code>spawn</code> function, which is an array of all the arguments to be passed to the command. For example, to execute the <code>find</code> command on the current directory with a <code>-type f</code> argument (to list files only), we can do:</p> 
 <p> 我们可以将参数传递至由所述执行的命令<code>spawn</code>功能使用的第二个参数<code>spawn</code>功能，这是所有参数数组要传递给该命令。 例如，要使用<code>-type f</code>参数在当前目录上执行<code>find</code>命令(仅列出文件)，我们可以执行以下操作： </p> 
 <pre class="has"><code class="language-js">const child = spawn('find', ['.', '-type', 'f']);</code></pre> 
 <p>If an error occurs during the execution of the command, for example, if we give find an invalid destination above, the <code>child.stderr</code> <code>data</code> event handler will be triggered and the <code>exit</code> event handler will report an exit code of <code>1</code>, which signifies that an error has occurred. The error values actually depend on the host OS and the type of error.</p> 
 <p> 如果在执行命令期间发生错误，例如，如果我们在上面给出查找无效的目的地，则将触发<code>child.stderr</code> <code>data</code>事件处理程序，并且<code>exit</code>事件处理程序将报告退出代码<code>1</code> ，表示退出代码为<code>1</code> 。发生错误。 错误值实际上取决于主机操作系统和错误类型。 </p> 
 <p>A child process <code>stdin</code> is a writable stream. We can use it to send a command some input. Just like any writable stream, the easiest way to consume it is using the <code>pipe</code> function. We simply pipe a readable stream into a writable stream. Since the main process <code>stdin</code> is a readable stream, we can pipe that into a child process <code>stdin</code> stream. For example:</p> 
 <p> 子进程<code>stdin</code>是可写流。 我们可以使用它向命令发送一些输入。 就像任何可写流一样，使用它的最简单方法是使用<code>pipe</code>功能。 我们只是将可读流传输到可写流。 由于主进程<code>stdin</code>是可读流，因此我们可以将其通过管道<code>stdin</code>到子进程<code>stdin</code>流。 例如： </p> 
 <pre class="has"><code class="language-js">const { spawn } = require('child_process');

const child = spawn('wc');

process.stdin.pipe(child.stdin)

child.stdout.on('data', (data) =&gt; {
  console.log(`child stdout:\n${data}`);
});</code></pre> 
 <p>In the example above, the child process invokes the <code>wc</code> command, which counts lines, words, and characters in Linux. We then pipe the main process <code>stdin</code> (which is a readable stream) into the child process <code>stdin</code> (which is a writable stream). The result of this combination is that we get a standard input mode where we can type something and when we hit <code>Ctrl+D</code>, what we typed will be used as the input of the <code>wc</code> command.</p> 
 <p> 在上面的示例中，子进程调用<code>wc</code>命令，该命令在Linux中对行，单词和字符进行计数。 然后，我们将主进程<code>stdin</code> (这是可读流)通过管道<code>stdin</code>到子进程<code>stdin</code> (这是可写流)。 这种结合的结果是，我们得到了一种标准的输入模式，可以在其中键入某些内容，并且当您<code>Ctrl+D</code> ，键入的内容将用作<code>wc</code>命令的输入。 </p> 
 <p>We can also pipe the standard input/output of multiple processes on each other, just like we can do with Linux commands. For example, we can pipe the <code>stdout</code> of the <code>find</code> command to the stdin of the <code>wc</code> command to count all the files in the current directory:</p> 
 <p> 我们也可以通过管道将多个进程的标准输入/输出相互传递，就像我们可以使用Linux命令一样。 例如，我们可以将<code>find</code>命令的<code>stdout</code>通过管道传递给<code>wc</code>命令的stdin，以计算当前目录中的所有文件： </p> 
 <pre class="has"><code class="language-js">const { spawn } = require('child_process');

const find = spawn('find', ['.', '-type', 'f']);
const wc = spawn('wc', ['-l']);

find.stdout.pipe(wc.stdin);

wc.stdout.on('data', (data) =&gt; {
  console.log(`Number of files ${data}`);
});</code></pre> 
 <p>I added the <code>-l</code> argument to the <code>wc</code> command to make it count only the lines. When executed, the code above will output a count of all files in all directories under the current one.</p> 
 <p> 我在<code>wc</code>命令中添加了<code>-l</code>参数，以使其仅计算行数。 执行后，以上代码将输出当前目录下所有目录中所有文件的计数。 </p> 
 <h5 id="shell-syntax-and-the-exec-function"> Shell语法和exec函数 <span style="font-weight: bold;">(</span>Shell Syntax and the exec function<span style="font-weight: bold;">)</span></h5> 
 <p>By default, the <code>spawn</code> function does not create a <em>shell</em> to execute the command we pass into it. This makes it slightly more efficient than the <code>exec</code> function, which does create a shell. The <code>exec</code> function has one other major difference. It <em>buffers</em> the command’s generated output and passes the whole output value to a callback function (instead of using streams, which is what <code>spawn</code> does).</p> 
 <p> 默认情况下， <code>spawn</code>函数不会创建<em>外壳程序</em>来执行我们传递给它的命令。 这使它比<code>exec</code>函数(创建一个外壳程序)效率更高。 <code>exec</code>函数还有另一个主要区别。 它<em>缓冲</em>命令生成的输出，并将整个输出值传递给回调函数(而不是使用<code>spawn</code>流)。 </p> 
 <p>Here’s the previous <code>find | wc </code>example implemented with an <code>exec</code> function.</p> 
 <p> 这是以前的<code>find | wc</code> 用<code>exec</code>函数实现的<code>find | wc</code>示例。 </p> 
 <pre class="has"><code class="language-js">const { exec } = require('child_process');

exec('find . -type f | wc -l', (err, stdout, stderr) =&gt; {
  if (err) {
    console.error(`exec error: ${err}`);
    return;
  }

  console.log(`Number of files ${stdout}`);
});</code></pre> 
 <p>Since the <code>exec</code> function uses a shell to execute the command, we can use the <em>shell syntax</em> directly here making use of the shell <em>pipe</em> feature.</p> 
 <p> 由于<code>exec</code>函数使用外壳执行命令，因此我们可以在此处利用外壳<em>管道</em>功能直接使用<em>外壳语法</em> 。 </p> 
 <p>Note that using the shell syntax comes at a <a href="https://blog.liftsecurity.io/2014/08/19/Avoid-Command-Injection-Node.js/" rel="noopener">security risk</a> if you’re executing any kind of dynamic input provided externally. A user can simply do a command injection attack using shell syntax characters like ; and $ (for example, <code>command + ’; rm -rf ~’</code> )</p> 
 <p> 请注意，如果您执行外部提供的任何类型的动态输入，则使用Shell语法会带来<a href="https://blog.liftsecurity.io/2014/08/19/Avoid-Command-Injection-Node.js/" rel="noopener">安全风险</a> 。 用户可以简单地使用shell语法字符(例如;)进行命令注入攻击。 和$(例如， <code>command + '; rm -rf ~'</code> ) </p> 
 <p>The <code>exec</code> function buffers the output and passes it to the callback function (the second argument to <code>exec</code>) as the <code>stdout</code> argument there. This <code>stdout</code> argument is the command’s output that we want to print out.</p> 
 <p> <code>exec</code>函数缓冲输出并将其作为<code>stdout</code>参数传递给回调函数( <code>exec</code>的第二个参数)。 此<code>stdout</code>参数是我们要打印的命令输出。 </p> 
 <p>The <code>exec</code> function is a good choice if you need to use the shell syntax and if the size of the data expected from the command is small. (Remember, <code>exec</code> will buffer the whole data in memory before returning it.)</p> 
 <p> 如果您需要使用shell语法并且命令所期望的数据量很小，则<code>exec</code>函数是一个不错的选择。 (请记住， <code>exec</code>将在返回之前将整个数据缓冲在内存中。) </p> 
 <p>The <code>spawn</code> function is a much better choice when the size of the data expected from the command is large, because that data will be streamed with the standard IO objects.</p> 
 <p> 当命令期望的数据量很大时，最好使用<code>spawn</code>函数，因为该数据将与标准IO对象一起传输。 </p> 
 <p>We can make the spawned child process inherit the standard IO objects of its parents if we want to, but also, more importantly, we can make the <code>spawn</code> function use the shell syntax as well. Here’s the same <code>find | wc</code> command implemented with the <code>spawn</code> function:</p> 
 <p> 如果需要，我们可以使产生的子进程继承其父进程的标准IO对象，而且更重要的是，我们也可以使<code>spawn</code>函数也使用shell语法。 这是相同的<code>find | wc</code> 用<code>spawn</code>函数实现的<code>find | wc</code>命令： </p> 
 <pre class="has"><code class="language-js">const child = spawn('find . -type f | wc -l', {
  stdio: 'inherit',
  shell: true
});</code></pre> 
 <p>Because of the <code>stdio: 'inherit'</code> option above, when we execute the code, the child process inherits the main process <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>. This causes the child process data events handlers to be triggered on the main <code>process.stdout</code> stream, making the script output the result right away.</p> 
 <p> 由于上面的<code>stdio: 'inherit'</code>选项，当我们执行代码时，子进程会继承主进程<code>stdin</code> ， <code>stdout</code>和<code>stderr</code> 。 这将导致在主<code>process.stdout</code>流上触发子流程数据事件处理程序，从而使脚本立即输出结果。 </p> 
 <p>Because of the <code>shell: true</code> option above, we were able to use the shell syntax in the passed command, just like we did with <code>exec</code>. But with this code, we still get the advantage of the streaming of data that the <code>spawn</code> function gives us. <em>This is really the best of both worlds.</em></p> 
 <p> 由于上面的<code>shell: true</code>选项，我们能够在传递的命令中使用shell语法，就像对<code>exec</code> 。 但是使用此代码，我们仍然可以获得<code>spawn</code>函数为我们提供的数据流的优势。 <em>这确实是两全其美。</em> </p> 
 <p>There are a few other good options we can use in the last argument to the <code>child_process</code> functions besides <code>shell</code> and <code>stdio</code>. We can, for example, use the <code>cwd</code> option to change the working directory of the script. For example, here’s the same count-all-files example done with a <code>spawn</code> function using a shell and with a working directory set to my Downloads folder. The <code>cwd</code> option here will make the script count all files I have in <code>~/Downloads</code>:</p> 
 <p> 除了<code>shell</code>和<code>stdio</code>之外，我们还可以在<code>child_process</code>函数的最后一个参数中使用其他一些不错的选择。 例如，我们可以使用<code>cwd</code>选项来更改脚本的工作目录。 例如，这是使用shell的<code>spawn</code>函数并将工作目录设置到我的Downloads文件夹中的全部文件示例。 这里的<code>cwd</code>选项将使脚本计算我在<code>~/Downloads</code>拥有的所有文件： </p> 
 <pre class="has"><code class="language-js">const child = spawn('find . -type f | wc -l', {
  stdio: 'inherit',
  shell: true,
  cwd: '/Users/samer/Downloads'
});</code></pre> 
 <p>Another option we can use is the <code>env</code> option to specify the environment variables that will be visible to the new child process. The default for this option is <code>process.env</code> which gives any command access to the current process environment. If we want to override that behavior, we can simply pass an empty object as the <code>env</code> option or new values there to be considered as the only environment variables:</p> 
 <p> 我们可以使用的另一个选项是<code>env</code>选项，用于指定对新的子进程可见的环境变量。 此选项的默认值为<code>process.env</code> ，它使任何命令都可以访问当前流程环境。 如果要覆盖该行为，我们可以简单地传递一个空对象作为<code>env</code>选项或将新值视为唯一的环境变量： </p> 
 <pre class="has"><code class="language-js">const child = spawn('echo $ANSWER', {
  stdio: 'inherit',
  shell: true,
  env: { ANSWER: 42 },
});</code></pre> 
 <p>The echo command above does not have access to the parent process’s environment variables. It can’t, for example, access <code>$HOME</code>, but it can access <code>$ANSWER</code> because it was passed as a custom environment variable through the <code>env</code> option.</p> 
 <p> 上面的echo命令无法访问父进程的环境变量。 例如，它不能访问<code>$HOME</code> ，但是它可以访问<code>$ANSWER</code>因为它是通过<code>env</code>选项作为自定义环境变量传递的。 </p> 
 <p>One last important child process option to explain here is the <code>detached</code> option, which makes the child process run independently of its parent process.</p> 
 <p> 此处要解释的最后一个重要的子流程选项是<code>detached</code>选项，它使子流程独立于其父流程运行。 </p> 
 <p>Assuming we have a file <code>timer.js</code> that keeps the event loop busy:</p> 
 <p> 假设我们有一个<code>timer.js</code>文件，它使事件循环保持繁忙： </p> 
 <pre class="has"><code class="language-js">setTimeout(() =&gt; {  
  // keep the event loop busy
}, 20000);</code></pre> 
 <p>We can execute it in the background using the <code>detached</code> option:</p> 
 <p> 我们可以使用<code>detached</code>选项在后台执行它： </p> 
 <pre class="has"><code class="language-js">const { spawn } = require('child_process');

const child = spawn('node', ['timer.js'], {
  detached: true,
  stdio: 'ignore'
});

child.unref();</code></pre> 
 <p>The exact behavior of detached child processes depends on the OS. On Windows, the detached child process will have its own console window while on Linux the detached child process will be made the leader of a new process group and session.</p> 
 <p> 分离的子进程的确切行为取决于操作系统。 在Windows上，分离的子进程将具有其自己的控制台窗口，而在Linux上，分离的子进程将成为新进程组和会话的领导者。 </p> 
 <p>If the <code>unref</code> function is called on the detached process, the parent process can exit independently of the child. This can be useful if the child is executing a long-running process, but to keep it running in the background the child’s <code>stdio</code> configurations also have to be independent of the parent.</p> 
 <p> 如果在分离的进程上调用了<code>unref</code>函数，则父进程可以独立于子进程退出。 如果孩子正在执行一个长时间运行的进程，这可能会很有用，但是要使其在后台运行，孩子的<code>stdio</code>配置也必须独立于父进程。 </p> 
 <p>The example above will run a node script (<code>timer.js</code>) in the background by detaching and also ignoring its parent <code>stdio</code> file descriptors so that the parent can terminate while the child keeps running in the background.</p> 
 <p> 上面的示例将通过分离并忽略其父<code>stdio</code>文件描述符在后台运行节点脚本( <code>timer.js</code> )，以便父级可以在子级继续在后台运行的同时终止。 </p> 
 <h5 id="the-execfile-function"> execFile函数 <span style="font-weight: bold;">(</span>The execFile function<span style="font-weight: bold;">)</span></h5> 
 <p>If you need to execute a file without using a shell, the <code>execFile</code> function is what you need. It behaves exactly like the <code>exec</code> function, but does not use a shell, which makes it a bit more efficient. On Windows, some files cannot be executed on their own, like <code>.bat</code> or <code>.cmd</code> files. Those files cannot be executed with <code>execFile</code> and either <code>exec</code> or <code>spawn</code> with shell set to true is required to execute them.</p> 
 <p> 如果需要在不使用外壳的情况下执行文件，则需要<code>execFile</code>函数。 它的行为与<code>exec</code>函数完全相同，但是不使用Shell，这使其效率更高。 在Windows上，某些文件无法单独执行，例如<code>.bat</code>或<code>.cmd</code>文件。 这些文件不能使用<code>execFile</code>执行，并且需要<code>exec</code>或<code>spawn</code>并将shell设置为true来执行它们。 </p> 
 <h5 id="the-sync-function"> *同步功能 <span style="font-weight: bold;">(</span>The *Sync function<span style="font-weight: bold;">)</span></h5> 
 <p>The functions <code>spawn</code>, <code>exec</code>, and <code>execFile</code> from the <code>child_process</code> module also have synchronous blocking versions that will wait until the child process exits.</p> 
 <p> <code>child_process</code>模块中的函数<code>spawn</code> ， <code>exec</code>和<code>execFile</code>也具有同步阻塞版本，这些版本将等待子进程退出。 </p> 
 <pre class="has"><code>const { 
  spawnSync, 
  execSync, 
  execFileSync,
} = require('child_process');</code></pre> 
 <p>Those synchronous versions are potentially useful when trying to simplify scripting tasks or any startup processing tasks, but they should be avoided otherwise.</p> 
 <p> 当试图简化脚本编写任务或任何启动处理任务时，这些同步版本可能很有用，但应避免使用它们。 </p> 
 <h5 id="the-fork-function"> fork()函数 <span style="font-weight: bold;">(</span>The fork() function<span style="font-weight: bold;">)</span></h5> 
 <p>The <code>fork</code> function is a variation of the <code>spawn</code> function for spawning node processes. The biggest difference between <code>spawn</code> and <code>fork</code> is that a communication channel is established to the child process when using <code>fork</code>, so we can use the <code>send</code> function on the forked process along with the global <code>process</code> object itself to exchange messages between the parent and forked processes. We do this through the <code>EventEmitter</code> module interface. Here’s an example:</p> 
 <p> <code>fork</code>函数是<code>spawn</code>函数的变体，用于<code>spawn</code>节点进程。 <code>spawn</code>和<code>fork</code>的最大区别在于，使用<code>fork</code> ，将建立与子进程的通信通道，因此我们可以在派生进程上使用<code>send</code>函数，并与全局<code>process</code>对象一起使用，以在父进程和派生进程之间交换消息。 我们通过<code>EventEmitter</code>模块接口执行此操作。 这是一个例子： </p> 
 <p>The parent file, <code>parent.js</code>:</p> 
 <p> 父文件<code>parent.js</code> ： </p> 
 <pre class="has"><code class="language-js">const { fork } = require('child_process');

const forked = fork('child.js');

forked.on('message', (msg) =&gt; {
  console.log('Message from child', msg);
});

forked.send({ hello: 'world' });</code></pre> 
 <p>The child file, <code>child.js</code>:</p> 
 <p> 子文件<code>child.js</code> ： </p> 
 <pre class="has"><code class="language-js">process.on('message', (msg) =&gt; {
  console.log('Message from parent:', msg);
});

let counter = 0;

setInterval(() =&gt; {
  process.send({ counter: counter++ });
}, 1000);</code></pre> 
 <p>In the parent file above, we fork <code>child.js</code> (which will execute the file with the <code>node</code> command) and then we listen for the <code>message</code> event. The <code>message</code> event will be emitted whenever the child uses <code>process.send</code>, which we’re doing every second.</p> 
 <p> 在上面的父文件中，我们派生<code>child.js</code> (它将使用<code>node</code>命令执行该文件)，然后侦听<code>message</code>事件。 每当孩子使用<code>process.send</code> ，都会发出<code>message</code>事件，我们每秒都会这样做。 </p> 
 <p>To pass down messages from the parent to the child, we can execute the <code>send</code> function on the forked object itself, and then, in the child script, we can listen to the <code>message</code> event on the global <code>process</code> object.</p> 
 <p> 要将消息从父对象传递给子对象，我们可以在分支对象本身上执行<code>send</code>函数，然后在子脚本中，我们可以侦听全局<code>process</code>对象上的<code>message</code>事件。 </p> 
 <p>When executing the <code>parent.js</code> file above, it’ll first send down the <code>{ hello: 'world' }</code> object to be printed by the forked child process and then the forked child process will send an incremented counter value every second to be printed by the parent process.</p> 
 <p> 当执行上面的<code>parent.js</code>文件时，它将首先向下发送<code>{ hello: 'world' }</code>对象，以供派生的子进程打印，然后派生的子进程将每秒发送一个递增的计数器值，以供打印父进程。 </p> 
 <p>Let’s do a more practical example about the <code>fork</code> function.</p> 
 <p> 让我们做一个关于<code>fork</code>函数的更实际的例子。 </p> 
 <p>Let’s say we have an http server that handles two endpoints. One of these endpoints (<code>/compute</code> below) is computationally expensive and will take a few seconds to complete. We can use a long for loop to simulate that:</p> 
 <p> 假设我们有一个处理两个端点的http服务器。 这些端点之一(下面的<code>/compute</code> )在计算上很昂贵，并且需要几秒钟才能完成。 我们可以使用long for循环来模拟： </p> 
 <pre class="has"><code class="language-js">const http = require('http');

const longComputation = () =&gt; {
  let sum = 0;
  for (let i = 0; i &lt; 1e9; i++) {
    sum += i;
  };
  return sum;
};

const server = http.createServer();

server.on('request', (req, res) =&gt; {
  if (req.url === '/compute') {
    const sum = longComputation();
    return res.end(`Sum is ${sum}`);
  } else {
    res.end('Ok')
  }
});

server.listen(3000);</code></pre> 
 <p>This program has a big problem; when the the <code>/compute</code> endpoint is requested, the server will not be able to handle any other requests because the event loop is busy with the long for loop operation.</p> 
 <p> 这个程序有个大问题； 当请求<code>/compute</code>端点时，服务器将无法处理任何其他请求，因为事件循环忙于long for循环操作。 </p> 
 <p>There are a few ways with which we can solve this problem depending on the nature of the long operation but one solution that works for all operations is to just move the computational operation into another process using <code>fork</code>.</p> 
 <p> 根据长操作的性质，有几种方法可以解决此问题，但是一种适用于所有操作的解决方案是仅使用<code>fork</code>将计算操作移至另一个进程中。 </p> 
 <p>We first move the whole <code>longComputation</code> function into its own file and make it invoke that function when instructed via a message from the main process:</p> 
 <p> 我们首先将整个<code>longComputation</code>函数移到其自己的文件中，并在通过主进程的消息指示时使其调用该函数： </p> 
 <p>In a new <code>compute.js</code> file:</p> 
 <p> 在一个新的<code>compute.js</code>文件中： </p> 
 <pre class="has"><code class="language-js">const longComputation = () =&gt; {
  let sum = 0;
  for (let i = 0; i &lt; 1e9; i++) {
    sum += i;
  };
  return sum;
};

process.on('message', (msg) =&gt; {
  const sum = longComputation();
  process.send(sum);
});</code></pre> 
 <p>Now, instead of doing the long operation in the main process event loop, we can <code>fork</code> the <code>compute.js</code> file and use the messages interface to communicate messages between the server and the forked process.</p> 
 <p> 现在，我们无需在主流程事件循环中进行冗长的操作，而可以<code>fork</code> <code>compute.js</code>文件，并使用messages接口在服务器与派生流程之间传递消息。 </p> 
 <pre class="has"><code class="language-js">const http = require('http');
const { fork } = require('child_process');

const server = http.createServer();

server.on('request', (req, res) =&gt; {
  if (req.url === '/compute') {
    const compute = fork('compute.js');
    compute.send('start');
    compute.on('message', sum =&gt; {
      res.end(`Sum is ${sum}`);
    });
  } else {
    res.end('Ok')
  }
});

server.listen(3000);</code></pre> 
 <p>When a request to <code>/compute</code> happens now with the above code, we simply send a message to the forked process to start executing the long operation. The main process’s event loop will not be blocked.</p> 
 <p> 现在，使用上述代码进行对<code>/compute</code>的请求时，我们仅向分叉的进程发送一条消息即可开始执行长操作。 主进程的事件循环不会被阻止。 </p> 
 <p>Once the forked process is done with that long operation, it can send its result back to the parent process using <code>process.send</code>.</p> 
 <p> 一旦使用该长时间操作完成了分叉的进程，它就可以使用<code>process.send</code>将其结果发送回父进程。 </p> 
 <p>In the parent process, we listen to the <code>message</code> event on the forked child process itself. When we get that event, we’ll have a <code>sum</code> value ready for us to send to the requesting user over http.</p> 
 <p> 在父进程中，我们侦听派生子进程本身上的<code>message</code>事件。 收到该事件后，我们将准备好一个<code>sum</code>值，可以通过http发送给发出请求的用户。 </p> 
 <p>The code above is, of course, limited by the number of processes we can fork, but when we execute it and request the long computation endpoint over http, the main server is not blocked at all and can take further requests.</p> 
 <p> 当然，上面的代码受我们可以分叉的进程数量的限制，但是当我们执行它并通过http请求较长的计算端点时，主服务器根本不会被阻塞，并且可以接受其他请求。 </p> 
 <p>Node’s <code>cluster</code> module, which is the topic of my next article, is based on this idea of child process forking and load balancing the requests among the many forks that we can create on any system.</p> 
 <p> Node的<code>cluster</code>模块是我下一篇文章的主题，它基于子进程派生的思想，并在我们可以在任何系统上创建的众多fork之间平衡请求的负载。 </p> 
 <p>That’s all I have for this topic. Thanks for reading! Until next time!</p> 
 <p> 这就是我要做的所有事情。 谢谢阅读！ 直到下一次！ </p> 
 <p>Learning React or Node? Checkout my books:</p> 
 <p> 学习React还是Node？ 结帐我的书： </p> 
 <ul><li><p><a href="http://amzn.to/2peYJZj" rel="noopener">Learn React.js by Building Games</a></p><p> <a href="http://amzn.to/2peYJZj" rel="noopener">通过构建游戏学习React.js</a> </p></li><li><p><a href="http://amzn.to/2FYfYru" rel="noopener">Node.js Beyond the Basics</a></p><p> <a href="http://amzn.to/2FYfYru" rel="noopener">超越基础的Node.js</a> </p></li></ul> 
 <blockquote> 
  <p>翻译自: <a href="https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/" rel="nofollow">https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/</a></p> 
 </blockquote> 
 <p>node.js的开发流程</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30028fe84d9c85d1f29d3174f22e0b1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">隐藏滚动条-火狐和其他浏览器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3613d1e72f54c82489e318ed3bbaa702/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查看端口被占用，被结束此端口占用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>