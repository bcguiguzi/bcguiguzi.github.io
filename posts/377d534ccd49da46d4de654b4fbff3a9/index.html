<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Primer 函数 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; Primer 函数" />
<meta property="og:description" content="文章目录 函数基础局部对象自动对象局部静态对象 参数传递传值参数传引用参数const形参和实参指针或引用形参与const 数组形参const引用形参 含有可变形参的函数initializer_list形参 返回类型和return语句无返回值函数有返回值的函数返回数组指针 函数重载重载与作用域 特殊用途语言特性默认实参内联函数constexpr函数constexpr和常量表达式constexpr变量字面值类型指针和constexpr 函数匹配函数指针使用函数指针重载函数指针函数指针形参返回指向函数的指针 函数基础 通过调用运算符来执行函数，调用运算符为()。
函数调用完成两项工作：第一、实参初始化函数对应的形参；第二、将控制权转移给被调函数，也就是说，主调函数的执行被暂时中止，被调函数开始执行。
函数结束完成两项工作：第一、返回return语句中的值；第二、控制权从被调函数转移回主调函数。
局部对象 名字有作用域、对象有生命期。
作用域是指名字发挥作用的区域，通常而言，一组花括号就是一个作用域。以以下代码为例，两个变量名称相同，但表示的对象不同，他们分别属于不同的作用域，同时，外部也无法访问循环作用域中的a与i。
生命期是指对象在内存中存在的时间。
int a=1; for(i=0;i&lt;6;i&#43;&#43;){ int a=i; cout &lt;&lt; a &lt;&lt; endl; } 形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域内可见。主函数中的变量也是局部变量，只有在主函数之外定义的才属于全局变量。
在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁局部变量的生命周期依赖于定义的方式。
自动对象 把只存在于块执行期间的对象称为自动对象。当块执行结束后，块中创建的自动对象的值就变成未定义的了。
形参是一种自动对象。如果局部变量对应的自动对象本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化，即产生未定义的值。
局部静态对象 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止时才被销毁，在此期间即使对象所在函数结束执行也不会对它有影响。
如果没有显式的初始值，内置类型的局部静态变量的初始化为0。
参数传递 形参初始化的机理和变量初始化一样。
如果形式参数是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形式参数。
当形式参数是引用类型时，称对应的实参被引用传递，或函数被传引用调用。
当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。称对应的实参为值传递或者函数被传值调用。
传值参数 初始值拷贝给变量，此时，对变量的改动不会影响初始值。
指针形参可以访问函数外部的对象，但是在C&#43;&#43;中建议使用引用类型。
传引用参数 可以实现对实参的更改。有些类型无法拷贝，使用引用使得访问变得可能。可以返回额外的信息（传入额外的引用实参，用于存储信息）。 const形参和实参 当形参是const时，需要注意关于顶层const的讨论。
当形参有顶层const时，传给他常量或者非常量都是可以的。
当形参没有顶层const，传给他顶层const也是可以的。
void fcn(const int i) /*fcn能够读取i，但是不能向i写值*/ 复习：
int i = 0; int *const p1 = &amp;i; /*顶层const*/ const int ci = 42； /*顶层const*/ const int *p2 = &amp;i； /*底层const*/ const int &amp;r = i； /*底层const*/ 拷贝时，底层const作为被拷贝者时，要求拷贝者是底层const，底层const作为拷贝者时，要求被拷贝者也是底层const；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/377d534ccd49da46d4de654b4fbff3a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-22T20:04:49+08:00" />
<meta property="article:modified_time" content="2022-01-22T20:04:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Primer 函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">函数基础</a></li><li><ul><li><a href="#_8" rel="nofollow">局部对象</a></li><li><ul><li><a href="#_25" rel="nofollow">自动对象</a></li><li><a href="#_30" rel="nofollow">局部静态对象</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_35" rel="nofollow">参数传递</a></li><li><ul><li><a href="#_44" rel="nofollow">传值参数</a></li><li><a href="#_49" rel="nofollow">传引用参数</a></li><li><a href="#const_55" rel="nofollow">const形参和实参</a></li><li><ul><li><a href="#const_78" rel="nofollow">指针或引用形参与const</a></li></ul> 
    </li><li><a href="#_86" rel="nofollow">数组形参</a></li><li><ul><li><a href="#const_102" rel="nofollow">const</a></li><li><a href="#_105" rel="nofollow">引用形参</a></li></ul> 
    </li><li><a href="#_115" rel="nofollow">含有可变形参的函数</a></li><li><ul><li><a href="#initializer_list_121" rel="nofollow">initializer_list形参</a></li></ul> 
   </li></ul> 
   </li><li><a href="#return_144" rel="nofollow">返回类型和return语句</a></li><li><ul><li><a href="#_145" rel="nofollow">无返回值函数</a></li><li><a href="#_150" rel="nofollow">有返回值的函数</a></li><li><a href="#_178" rel="nofollow">返回数组指针</a></li></ul> 
   </li><li><a href="#_196" rel="nofollow">函数重载</a></li><li><ul><li><ul><li><a href="#_222" rel="nofollow">重载与作用域</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_227" rel="nofollow">特殊用途语言特性</a></li><li><ul><li><a href="#_229" rel="nofollow">默认实参</a></li><li><a href="#_243" rel="nofollow">内联函数</a></li><li><a href="#constexpr_260" rel="nofollow">constexpr函数</a></li><li><ul><li><a href="#constexpr_279" rel="nofollow">constexpr和常量表达式</a></li><li><ul><li><a href="#constexpr_290" rel="nofollow">constexpr变量</a></li><li><a href="#_297" rel="nofollow">字面值类型</a></li><li><a href="#constexpr_306" rel="nofollow">指针和constexpr</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_316" rel="nofollow">函数匹配</a></li><li><a href="#_346" rel="nofollow">函数指针</a></li><li><ul><li><a href="#_355" rel="nofollow">使用函数指针</a></li><li><a href="#_369" rel="nofollow">重载函数指针</a></li><li><a href="#_376" rel="nofollow">函数指针形参</a></li><li><a href="#_388" rel="nofollow">返回指向函数的指针</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>函数基础</h3> 
<p>通过调用运算符来执行函数，调用运算符为<code>()</code>。</p> 
<p>函数调用完成两项工作：第一、实参初始化函数对应的形参；第二、将控制权转移给被调函数，也就是说，主调函数的执行被暂时中止，被调函数开始执行。</p> 
<p>函数结束完成两项工作：第一、返回return语句中的值；第二、控制权从被调函数转移回主调函数。</p> 
<h4><a id="_8"></a>局部对象</h4> 
<p>名字有作用域、对象有生命期。</p> 
<p>作用域是指名字发挥作用的区域，通常而言，一组花括号就是一个作用域。以以下代码为例，两个变量名称相同，但表示的对象不同，他们分别属于不同的作用域，同时，外部也无法访问循环作用域中的a与i。</p> 
<p>生命期是指对象在内存中存在的时间。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token operator">=</span>i<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>，仅在函数的作用域内可见。主函数中的变量也是局部变量，只有在主函数之外定义的才属于全局变量。</p> 
<p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁局部变量的生命周期依赖于定义的方式。</p> 
<h5><a id="_25"></a>自动对象</h5> 
<p>把只存在于块执行期间的对象称为自动对象。当块执行结束后，块中创建的自动对象的值就变成未定义的了。</p> 
<p>形参是一种自动对象。如果局部变量对应的自动对象本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化，即产生未定义的值。</p> 
<h5><a id="_30"></a>局部静态对象</h5> 
<p>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止时才被销毁，在此期间即使对象所在函数结束执行也不会对它有影响。</p> 
<p>如果没有显式的初始值，内置类型的局部静态变量的初始化为0。</p> 
<h3><a id="_35"></a>参数传递</h3> 
<p>形参初始化的机理和变量初始化一样。</p> 
<p>如果形式参数是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形式参数。</p> 
<p>当形式参数是引用类型时，称对应的实参被<mark>引用传递</mark>，或函数被<mark>传引用调用</mark>。</p> 
<p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。称对应的实参为<mark>值传递</mark>或者函数被<mark>传值调用</mark>。</p> 
<h4><a id="_44"></a>传值参数</h4> 
<p>初始值拷贝给变量，此时，对变量的改动不会影响初始值。</p> 
<p>指针形参可以访问函数外部的对象，但是在C++中建议使用引用类型。</p> 
<h4><a id="_49"></a>传引用参数</h4> 
<ol><li>可以实现对实参的更改。</li><li>有些类型无法拷贝，使用引用使得访问变得可能。</li><li>可以返回额外的信息（传入额外的引用实参，用于存储信息）。</li></ol> 
<h4><a id="const_55"></a>const形参和实参</h4> 
<p>当形参是const时，需要注意关于顶层const的讨论。</p> 
<p>当形参有顶层const时，传给他常量或者非常量都是可以的。</p> 
<p>当形参没有顶层const，传给他顶层const也是可以的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">/*fcn能够读取i，但是不能向i写值*/</span>
</code></pre> 
<p>复习：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">/*顶层const*/</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">42</span>； <span class="token comment">/*顶层const*/</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i； <span class="token comment">/*底层const*/</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i； <span class="token comment">/*底层const*/</span> 
</code></pre> 
<p>拷贝时，底层const作为被拷贝者时，要求拷贝者是底层const，底层const作为拷贝者时，要求被拷贝者也是底层const；</p> 
<p>初始化时，只有当底层const作为初始化者时，对于被初始化者是有要求的。</p> 
<h5><a id="const_78"></a>指针或引用形参与const</h5> 
<p>可以使用非常量初始化一个底层const，但是反过来不行。</p> 
<p><mark>如果无需改变引用对象的值，那么尽量使用常量引用</mark>。</p> 
<ol><li>防止实参被改变（更安全）；</li><li>能接受的值的类型更广（底层const作为实参交付给非底层const）。</li></ol> 
<h4><a id="_86"></a>数组形参</h4> 
<p>数组有两个特殊的性质：</p> 
<ol><li>不允许拷贝数组；</li><li>使用数组时，常转化为指针；</li></ol> 
<p>在传递数组时，实现的是值传递中的指针传递。</p> 
<p>传递数组的形式有</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="const_102"></a>const</h5> 
<p>定义为顶层constant指针。</p> 
<h5><a id="_105"></a>引用形参</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>另外，需要强调的是，引用数组和数组引用是有区别的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment">/*引用数组*/</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment">/*数组引用*/</span>
</code></pre> 
<h4><a id="_115"></a>含有可变形参的函数</h4> 
<p>无法预知应该向函数传递几个实参。</p> 
<p>如果所有实参类型相同，可以传递一个名为initializer_list的标准库类型；<br> 如果实参类型不同，可以编写一种特殊的函数，也就是可变参数模版。</p> 
<h5><a id="initializer_list_121"></a>initializer_list形参</h5> 
<p>initializer_list类型的操作：</p> 
<pre><code class="prism language-cpp">initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lst<span class="token punctuation">;</span> <span class="token comment">/*默认初始化：T类型元素的空列表*/</span>
initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lst<span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/*1st的元素时对应初始值的脚本，列表中的元素是const*/</span>
lst2（lst）；list2 <span class="token operator">=</span> lst； <span class="token comment">/*拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素*/</span>
lst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/*列表中的元素数量*/</span>
lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/*返回指向lst中首元素的指针*/</span>
lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/*返回指向lst中尾元素下一位置的指针*/</span>
</code></pre> 
<p>与vector不同的是，initializer_list对象中的元素永远是常量值。</p> 
<p>在传递多个值时，需要用花括号表示。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">error_msg</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> i1<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">error_msg</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"functionX"</span><span class="token punctuation">,</span><span class="token string">"expected"</span><span class="token punctuation">,</span><span class="token string">"actual"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="return_144"></a>返回类型和return语句</h3> 
<h4><a id="_145"></a>无返回值函数</h4> 
<p>没有返回值的return语句只能用在返回类型是void的函数中。</p> 
<p>void类型的函数不要求有return语句，自身默认会补充一句。</p> 
<h4><a id="_150"></a>有返回值的函数</h4> 
<p>含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很有编译器无法发现此类错误。</p> 
<p>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p> 
<p>务必不能返回局部对象的引用或指针。局部变量被释放，指针指向了不再有效的内存区域。引用的道理也是如此。</p> 
<p>函数的返回类型决定函数的调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token function">get_val</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span>string<span class="token operator">::</span>size_type ix<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> str<span class="token punctuation">[</span>ix<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"a value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">get_val</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span> <span class="token comment">// 将s[0]变为‘A’</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>感觉就是初始化过程<code>char &amp;get_val=str[ix]</code>。</p> 
<p>针对vector、initializer_list这样的类型，函数可以返回花括号包围的值的列表。</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token string">"functionX"</span><span class="token punctuation">,</span><span class="token string">"okay"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_178"></a>返回数组指针</h4> 
<p>函数不能返回数组，但是可以返回数组的指针或引用。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//含有10个指针的数组；</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//指向数组的指针</span>
</code></pre> 
<p>数组指针的函数可以如下书写：</p> 
<pre><code class="prism language-cpp"><span class="token function">Type</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">function</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>dimension<span class="token punctuation">]</span> <span class="token comment">//这与数组指针的写法很类似</span>
</code></pre> 
<p>尾位置返回类型。任何函数的定义都能使用，用于交代返回类型。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="_196"></a>函数重载</h3> 
<p>如果同一作用域内的几个函数名字相同但形参列表不同，称之为重载函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译器会根据传递的实参类型或数量推断所使用的函数。</p> 
<p>main函数不能重载。</p> 
<p><mark>不允许两个函数除了返回类型外其他所有要素都相同。</mark></p> 
<p>一个有顶层const的形参无法和另一个没有顶层const的形参区分开。</p> 
<pre><code class="prism language-cpp">Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这两个声明是等价的</span>
</code></pre> 
<p>而底层const可以起到区分的作用。</p> 
<pre><code class="prism language-cpp">Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone <span class="token operator">*</span><span class="token punctuation">)</span>
</code></pre> 
<p>const对象只能传递给const形参；非常量都可以传递，但是首先传递给非常量。</p> 
<h5><a id="_222"></a>重载与作用域</h5> 
<p>如果在内层作用域中声明名字，它将隐藏外层作用域中的同名实体。</p> 
<p>在不同作用域中无法重载函数名。</p> 
<h3><a id="_227"></a>特殊用途语言特性</h3> 
<h4><a id="_229"></a>默认实参</h4> 
<p>调用默认实参时，省略实参就行。</p> 
<pre><code class="prism language-cpp">string <span class="token function">screen</span><span class="token punctuation">(</span>sz ht <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span>sz wid <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span><span class="token keyword">char</span> backgrnd <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string window<span class="token punctuation">;</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>函数调用时，实参按照其位置进行解析，默认实参负责填补函数调用缺少的尾部实参，也就是说，想覆盖backgrnd的默认值需要为ht和wid提供实参。</p> 
<p>必须在函数的声明中添加默认值，需要注意的是一个函数只能声明一次，如果要多次声明，那么形参只能被赋予一次默认值，后续的声明只能为没有默认值的形参添加默认值。</p> 
<p>局部变量不能作为默认值。</p> 
<h4><a id="_243"></a>内联函数</h4> 
<p>一般函数在调用时比求等价表达式的值要慢一些。调用前要先保存寄存器，并在返回时恢复，可能需要拷贝实参，程序转向一个新的位置继续执行。</p> 
<p>内联函数可以避免函数调用的开销。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在函数定义前加上inline则完成了内联函数的使用。</p> 
<p>内联机制适用于规模较小、流程直接、调用频繁的函数。</p> 
<p>内联不允许出现循环和switch。</p> 
<h4><a id="constexpr_260"></a>constexpr函数</h4> 
<p>常量函数是指能用于常量表达式的函数。</p> 
<p>定义constexpr函数的方法与其他函数类似，有几项规定需要遵守：</p> 
<ol><li>函数的返回类型及所有形参类型都是字面值类型；</li><li>函数体中必须有且只有一条return语句；</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> new_sz<span class="token punctuation">;</span>
</code></pre> 
<p>编译器把对constexpr函数的调用替换成结果值。为了能在编译过程中随时展开，constexpr函数被隐式指定为内联函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>cnt<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token comment">// 如果arg是常量表达式，则scale(arg)返回的也是常量表达式，反之则是变量。</span>
</code></pre> 
<p>结合上述例子来看，constexpr函数给了函数一个成为常量表达式的机会。</p> 
<h5><a id="constexpr_279"></a>constexpr和常量表达式</h5> 
<p>常量表达式是指值不会改变并且能在编译过程就能得到计算过程的表达式。</p> 
<p>字面值就属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> max_files <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> max_files <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> staff_size <span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//不是常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不是常量表达式</span>
</code></pre> 
<h6><a id="constexpr_290"></a>constexpr变量</h6> 
<p>在复杂的系统中，很难分辨一个初始值是不是常量表达式，即使要求数据类型为const，但初始化值不是常量表达式的话，则其也不是常量表达式。</p> 
<p>通过声明变量为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。</p> 
<p><mark>声明为<code>constexpr</code>的变量一定是一个常量，而且必须用常量表达式初始化。</mark></p> 
<h6><a id="_297"></a>字面值类型</h6> 
<p>常量表达式的值需要在编译时就得到计算，所以对声明constexpr时用到的类型必须有所限制。因为这些类型比较简单，称之为“字面值类型”。</p> 
<p>算数类型、引用、指针都属于字面值类型。自定义类、IO库、string类型都不属于字面值类型。</p> 
<p>指针和引用都能定义为constexpr类型，对于指针来说初始值必须是nullptr或者0，或者是存储与某个固定地址的对象。</p> 
<p>一般来说，函数体内定义的变量并非存放在固定地址中，因此constexpr不能指向这样的变量，而定义于函数体之外的则可以。</p> 
<h6><a id="constexpr_306"></a>指针和constexpr</h6> 
<p>constexpr仅对指针有效，对指针所指的对象无关。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 指向整型常量的指针</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 指向整数的常量指针</span>
</code></pre> 
<p>constexpr把它所定义的对象置为了顶层const。</p> 
<p>constexpr可以指向常量，也可以指向非常量，地址是常量就行。</p> 
<h3><a id="_316"></a>函数匹配</h3> 
<p>当重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得到时，选择合适的重载函数就十分困难。</p> 
<p>函数匹配的<strong>第一步</strong>是选定本次调用对应的重载函数集。集合中的函数称之为候选函数。候选函数具备两个特征：</p> 
<ol><li>与被调用的函数同名；</li><li>其声明在调用点可见。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上述例子中候选函数有六个。</p> 
<p>函数匹配的<strong>第二步</strong>考察本次调用提供的实参，然后从候选函数中选出被这组实参调用的函数，这些新选出的函数被称为可行函数。可行函数有两个特征：</p> 
<ol><li>形参数量与本次调用提供的实参数量相等；</li><li>每个实参的类型与对应的形参类型相同或者能转换成形参的类型。</li></ol> 
<p>上述例子中，函数2与函数4都是可行函数。如果没可行函数，编译器将报告无匹配函数的错误。</p> 
<p>函数匹配的<strong>第三步</strong>是从可行函数中选择与本次调用最匹配的函数。它的基本思想是，实参类型和形参类型接近且越匹配越好。</p> 
<p>当实参数量有两个或更多时，函数匹配比较复杂。如果传入的实参为<code>(42,2.56)</code>时，可行函数为<code>f(int,int)</code>和<code>f(double,double)</code>。如果有且仅有一个函数满足以下条件：</p> 
<ol><li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配；</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li></ol> 
<p>如果不存在这样一个唯一的函数，那么报错。</p> 
<h3><a id="_346"></a>函数指针</h3> 
<p>函数指针指向的是函数而非对象。</p> 
<p>函数指针和返回指针的函数的定义区别和数组指针和包含指针的数组的定义区别是一致的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pf指向一个函数，该函数的参数是一个const string的引用</span>
</code></pre> 
<h4><a id="_355"></a>使用函数指针</h4> 
<pre><code class="prism language-cpp">pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span> <span class="token comment">//pf指向名为lengthCompare的函数</span>
pf <span class="token operator">=</span> <span class="token operator">&amp;</span>lengthCompare<span class="token punctuation">;</span> <span class="token comment">//等价赋值 </span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> b3 <span class="token operator">=</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//上述三个调用是等价的</span>
</code></pre> 
<p><mark>在指向不同函数类型时，不存在转换规则。</mark></p> 
<h4><a id="_369"></a>重载函数指针</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> ff<span class="token punctuation">;</span> <span class="token comment">// 由函数指针的参数决定指向哪个重载函数。</span>
</code></pre> 
<h4><a id="_376"></a>函数指针形参</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">bool</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>传参时，有：</p> 
<pre><code class="prism language-cpp"><span class="token function">useBigger</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">useBigger</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_388"></a>返回指向函数的指针</h4> 
<p>和数组一样，不能返回函数，但是能返回指向函数类型的指针。把返回类型写成指针形式即可。</p> 
<p>函数类型可以如下书写：把函数名当作变量，结构与函数指针类似：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/082265d691937a610d1de306b41f86ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BERT参数量计算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94d2497b83c15595db4577e6a00f14b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UPC2022新生赛30场</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>