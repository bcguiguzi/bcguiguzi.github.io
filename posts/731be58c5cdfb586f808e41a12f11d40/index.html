<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PTA 7-3 01背包 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PTA 7-3 01背包" />
<meta property="og:description" content=" 事情是这样的，jzk要去爬山，但是他的包容量有限，可是他需要非常多的能量，要不然就很容易饿。 第一行给出jzk准备爬几次山。 每次爬山都会带新的包（因为jzk每用一个包都会被zwg抢过去），和准备新的食物（因为每次剩下来的都被zwg吃了）。 下一行给你这一次食物的数目n，和背包容量k， 接下来的一行给出n个食物的能量，再一行给出n个食物的大小（占背包的容量）。 请帮助jzk计算他最多可以带多少能量的食物去爬山。输出可以携带食物的最大能量和。 (n,m&lt;1000) 能量和食物均小于40000
输入格式: 第一行包含整数T，表示有T组案例。
接着是T组案例，每组案例三行，第一行包含两个整数N，M，（N&lt;=1000，M&lt;=1000），表示物品数量和袋子的体积。第二行包含表示每个物品能量的n个整数。第三行包含代表每个物品体积的n个整数。
输出格式: 每组案例一行，只输出一个数字，表示jzk可以获得的最大能量。
输入样例: 在这里给出一组输入。例如：
1 5 10 1 2 3 4 5 5 4 3 2 1 结尾无空行
输出样例: 在这里给出相应的输出。例如：
14 结尾无空行
TIPS: （包容量是10）可以带第2,3,4,5,个食物，2 &#43; 3 &#43;4 &#43;5 = 14
背包思路：
(本来用的递归，但是tt了，所以不得不改用递推55555555555555）
用二维数组其实更好理解，横坐标为当前剩余内存，竖坐标是说明当前行是哪个物品。
然后二维数组里面的值是说明，若是在该剩余内存条件下，最多能装的价值，求二维数组内的值要取决于剩余内存，若剩余内存已经不足以选该行的物品，则该值就等于上一行的值，若是内存够的话，该值要取决于选不选该物体哪个价值更大一点，若是选了该物体，结果就等于内存减去该物品的体积的最大价值加上该物体的价值，若是不选该物体，就等于上一行所代表的没选该物体在该内存下能装的最大价值，两种情况哪种价值大，就留下哪个值。
但是用二维数组的话内存可能超出限制。所以我用了一维数组，因为某一行只看一次，看完那一次就再也用不到了，所以留着也没啥用，但是要是用一维数组滚动存取的话，需要从内存最大开始循环，因为某一点的值取决于上一行该点的值和上一行前面的某个值。所以后面的值用完之后前面的的值求解是用不到的，所以用完就可以替换掉。
最后，数组的最后一个值就是最大值，因为它代表的是，该内存下所能装的最大价值，最大内存的最大价值就是我们所要求的。
AC代码：
#include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; using namespace std; int *a,*b; int n,m; int sum=0; int q(int m,int i){ if(i==n){ return 0; } if(m&gt;=b[i]){ int t=q(m-b[i],i&#43;1)&#43;a[i]; return max(t,q(m,i&#43;1)); } else{ return q(m,i&#43;1);	} } int max(int a,int b){ if(a&gt;=b){ return a; } return b; } int main(){ int T; cin&gt;&gt;T; for(int qqq=0;qqq&lt;T;qqq&#43;&#43;){ //	int n,m;//n是食物数目，m是背包容量 cin&gt;&gt;n; cin&gt;&gt;m; a=new int[n]; b=new int[n]; for(int i=0;i&lt;n;i&#43;&#43;){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;n;i&#43;&#43;){ cin&gt;&gt;b[i]; } //	int **c=new int*[n]; //	for(int i=0;i&lt;n;i&#43;&#43;){ //	c[i]=new int[m]; //	} int *c=new int[m&#43;1]; //memset(c,0,sizeof(c)); for(int i=0;i&lt;m&#43;1;i&#43;&#43;){ c[i]=0; } for(int j=1;j&lt;n;j&#43;&#43;){ for(int i=m;i&gt;0;i--){ if(i&gt;=b[j]) c[i]=max(c[i],c[i-b[j]]&#43;a[j]); //	else{ //	c[i]=c[i] //	} } } cout&lt;&lt;c[m]&lt;&lt;endl; } } " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/731be58c5cdfb586f808e41a12f11d40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-30T17:17:10+08:00" />
<meta property="article:modified_time" content="2021-07-30T17:17:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PTA 7-3 01背包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>事情是这样的，jzk要去爬山，但是他的包容量有限，可是他需要非常多的能量，要不然就很容易饿。 第一行给出jzk准备爬几次山。 每次爬山都会带新的包（因为jzk每用一个包都会被zwg抢过去），和准备新的食物（因为每次剩下来的都被zwg吃了）。 下一行给你这一次食物的数目n，和背包容量k， 接下来的一行给出n个食物的能量，再一行给出n个食物的大小（占背包的容量）。 请帮助jzk计算他最多可以带多少能量的食物去爬山。输出可以携带食物的最大能量和。 (n,m&lt;1000) 能量和食物均小于40000</p> 
<h4 id="输入格式">输入格式:</h4> 
<p>第一行包含整数T，表示有T组案例。</p> 
<p>接着是T组案例，每组案例三行，第一行包含两个整数N，M，（N&lt;=1000，M&lt;=1000），表示物品数量和袋子的体积。第二行包含表示每个物品能量的n个整数。第三行包含代表每个物品体积的n个整数。</p> 
<h4 id="输出格式">输出格式:</h4> 
<p>每组案例一行，只输出一个数字，表示jzk可以获得的最大能量。</p> 
<h4 id="输入样例">输入样例:</h4> 
<p>在这里给出一组输入。例如：</p> 
<pre><code>1
5 10
1 2 3 4 5
5 4 3 2 1</code></pre> 
<p>结尾无空行</p> 
<h4 id="输出样例">输出样例:</h4> 
<p>在这里给出相应的输出。例如：</p> 
<pre><code>14</code></pre> 
<p>结尾无空行</p> 
<h4 id="tips">TIPS:</h4> 
<p>（包容量是10）可以带第2,3,4,5,个食物，2 + 3 +4 +5 = 14</p> 
<p></p> 
<p>背包思路：</p> 
<p>(本来用的递归，但是tt了，所以不得不改用递推55555555555555）</p> 
<p>       用二维数组其实更好理解，横坐标为当前剩余内存，竖坐标是说明当前行是哪个物品。</p> 
<p>然后二维数组里面的值是说明，若是在该剩余内存条件下，最多能装的价值，求二维数组内的值要取决于剩余内存，若剩余内存已经不足以选该行的物品，则该值就等于上一行的值，若是内存够的话，该值要取决于选不选该物体哪个价值更大一点，若是选了该物体，结果就等于内存减去该物品的体积的最大价值加上该物体的价值，若是不选该物体，就等于上一行所代表的没选该物体在该内存下能装的最大价值，两种情况哪种价值大，就留下哪个值。</p> 
<p>        但是用二维数组的话内存可能超出限制。所以我用了一维数组，因为某一行只看一次，看完那一次就再也用不到了，所以留着也没啥用，但是要是用一维数组滚动存取的话，需要从内存最大开始循环，因为某一点的值取决于上一行该点的值和上一行前面的某个值。所以后面的值用完之后前面的的值求解是用不到的，所以用完就可以替换掉。</p> 
<p>        最后，数组的最后一个值就是最大值，因为它代表的是，该内存下所能装的最大价值，最大内存的最大价值就是我们所要求的。</p> 
<p>AC代码：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;

using namespace std;
int *a,*b;
int n,m;
int sum=0;
int q(int m,int i){
	if(i==n){
		return 0;
	} 
	if(m&gt;=b[i]){
		int t=q(m-b[i],i+1)+a[i];
		return max(t,q(m,i+1));
	}
	else{
		return q(m,i+1);	
	}
}
int max(int a,int b){
	if(a&gt;=b){
		return a;
	}
	return b;
}
int main(){
	int T;
	cin&gt;&gt;T;
	for(int qqq=0;qqq&lt;T;qqq++){
//		int n,m;//n是食物数目，m是背包容量 
		cin&gt;&gt;n;
		cin&gt;&gt;m;
		a=new int[n];
		b=new int[n];
		for(int i=0;i&lt;n;i++){
			cin&gt;&gt;a[i];
		} 
		for(int i=0;i&lt;n;i++){
			cin&gt;&gt;b[i];
		} 
//		int **c=new int*[n];
//		for(int i=0;i&lt;n;i++){
//			c[i]=new int[m];
//		}
		int *c=new int[m+1];
		//memset(c,0,sizeof(c));
		for(int i=0;i&lt;m+1;i++){
			c[i]=0;
		}
		for(int j=1;j&lt;n;j++){
			for(int i=m;i&gt;0;i--){
				if(i&gt;=b[j])
				c[i]=max(c[i],c[i-b[j]]+a[j]);
//				else{
//					c[i]=c[i]
//				}
			} 
		}
		cout&lt;&lt;c[m]&lt;&lt;endl;
	}
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4740af75dfd8eaa19e6068fb015efd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">两台局域网服务器内部的docker容器如何实现网络互通（最后成功了）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66d182be47935509ec329efcf8c0b93c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10蓝牙无法连接，可以尝试在此Windows设备上打开蓝牙</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>