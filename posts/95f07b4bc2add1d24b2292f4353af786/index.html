<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程池设计---C&#43;&#43; - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线程池设计---C&#43;&#43;" />
<meta property="og:description" content="什么是线程池： 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。
线程池的应用场景：
需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，出现错误. 线程池示例：
创建固定数量线程池，循环从任务队列中获取任务对象获取到任务对象后，执行任务对象中的任务接口 锁设计 采用RAII风格的加锁方式，用于保护在出了临界区后，忘记解锁的情况。
Mutex 类：
Mutex 类封装了 pthread_mutex_t 互斥锁。它包含 lock 和 unlock 方法，分别用于加锁和解锁。构造函数接收一个指向 pthread_mutex_t 的指针，并将其存储在私有成员 _pmtx 中。 lockGuard 类：
lockGuard 类是 RAII 风格的锁保护类。在构造函数中，它接收一个 pthread_mutex_t 指针并使用 Mutex 类将锁住。在析构函数中，它解锁互斥锁。这样，当 lockGuard 对象超出范围（超出了作用域），它的析构函数将确保互斥锁被正确解锁，即使在发生异常的情况下也是如此。 #include &lt;iostream&gt; #include &lt;pthread.h&gt; class Mutex{ public: Mutex(pthread_mutex_t *mtx) :_pmtx(mtx) {} void lock() { pthread_mutex_lock(_pmtx); } void unlock() { pthread_mutex_unlock(_pmtx); } ~Mutex() {} private: pthread_mutex_t *_pmtx; }; // RAII风格的加锁方式 class lockGuard { public: lockGuard(pthread_mutex_t *mtx) :_mtx(mtx) { _mtx." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/95f07b4bc2add1d24b2292f4353af786/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-06T17:17:02+08:00" />
<meta property="article:modified_time" content="2024-02-06T17:17:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程池设计---C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2 id="BSPkq">什么是线程池：</h2> 
<p id="u96119319">一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。</p> 
<p id="uddbc135e">线程池的应用场景：</p> 
<ol><li id="u714b523a">需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。</li><li id="u002e3207">对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。</li><li id="u1ae4f66c">接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，出现错误.</li></ol> 
<p id="ua0ec3754">线程池示例：</p> 
<ol><li id="u4b2968f2">创建固定数量线程池，循环从任务队列中获取任务对象</li><li id="u76cbfc18">获取到任务对象后，执行任务对象中的任务接口</li></ol> 
<h2 id="lSCRz">锁设计</h2> 
<p id="u04c985f9">采用RAII风格的加锁方式，用于保护在出了临界区后，忘记解锁的情况。</p> 
<p>Mutex 类：</p> 
<ul><li>Mutex 类封装了 pthread_mutex_t 互斥锁。它包含 lock 和 unlock 方法，分别用于加锁和解锁。</li><li>构造函数接收一个指向 pthread_mutex_t 的指针，并将其存储在私有成员 _pmtx 中。</li></ul> 
<p>lockGuard 类：</p> 
<ul><li>lockGuard 类是 RAII 风格的锁保护类。在构造函数中，它接收一个 pthread_mutex_t 指针并使用 Mutex 类将锁住。</li><li>在析构函数中，它解锁互斥锁。这样，当 lockGuard 对象超出范围（超出了作用域），它的析构函数将确保互斥锁被正确解锁，即使在发生异常的情况下也是如此。</li></ul> 
<pre id="N3YUJ"><code>#include &lt;iostream&gt;
#include &lt;pthread.h&gt;

class Mutex{
public:
    Mutex(pthread_mutex_t *mtx)
    :_pmtx(mtx)
    {}
    void lock()
    {
        pthread_mutex_lock(_pmtx);
    }
    void unlock()
    {
        pthread_mutex_unlock(_pmtx);
    }
    ~Mutex()
    {}

private:
    pthread_mutex_t *_pmtx;
};

// RAII风格的加锁方式
class lockGuard
{
public:
    lockGuard(pthread_mutex_t *mtx)
    :_mtx(mtx)
    {
        _mtx.lock();
    }
    ~lockGuard()
    {
        _mtx.unlock();
    }

private:
    Mutex _mtx;
};</code></pre> 
<h2 id="onBPG">线程封装</h2> 
<p id="u44302cd5">把线程进行封装，用于创建和管理线程。</p> 
<p id="u2106ad1a">主要的类和相关功能：</p> 
<p>ThreadData 类：</p> 
<ul><li>存储线程的参数和名称，包含 _args 和 _name 成员变量。</li></ul> 
<p>Thread 类：</p> 
<ul><li>构造函数接受线程编号、回调函数指针和线程参数，生成一个线程名称，并初始化了 _func 和 _tdata 。</li><li>start 方法用于创建线程，调用 pthread_create。</li><li>join 方法等待线程的结束，调用 pthread_join。name 方法返回线程的名称。</li></ul> 
<pre id="SpIAO"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;cstdio&gt;

typedef void*(*fun_t)(void*);

class ThreadData
{
public:
    void* _args;
    std::string _name;
};

class Thread
{
public:
    Thread(int num, fun_t callback, void* args)
    :_func(callback)
    {
        char nameBuffer[64];
        snprintf(nameBuffer, sizeof nameBuffer, "thread-%d", num);
        _name = nameBuffer;
        _tdata._name = _name;
        _tdata._args = args;
    }

    void start()
    {
        pthread_create(&amp;_tid, nullptr, _func, (void*)&amp;_tdata);
    }
    void join()
    {
        pthread_join(_tid, nullptr);
    }
    std::string name()
    {
        return _name;
    }
    ~Thread()
    {}

private:
    std::string _name;  // 线程号
    fun_t _func;  // 仿函数
    ThreadData _tdata;  
    pthread_t _tid;   // 线程标识符
};</code></pre> 
<h2 id="pdXJY">线程池</h2> 
<ol><li id="u4a5fb938">getThreadPool 函数是获取线程池单例的静态方法。使用了双检锁机制（Double-Check Locking）确保在多线程环境下只创建一个实例。</li><li id="ud16903f9">routine 是线程的执行函数，其中使用了 lockGuard 类来实现 RAII 风格的加锁和解锁。在 routine 中，线程不断从任务队列中取出任务执行。</li><li id="u575a6262">PushTask 用于向任务队列中添加任务，并通过条件变量 pthread_cond_signal 通知等待中的线程有新任务。</li><li id="u930a5da2">run 方法启动所有线程。</li><li id="ucf1b8d86">在构造函数中初始化了互斥锁 pthread_mutex_init 和条件变量 pthread_cond_init。</li><li id="ub53ee560">析构函数负责销毁线程池中的线程、互斥锁和条件变量。</li></ol> 
<p id="ue6cbb569"><strong>条件变量：</strong><br><code>void waitCond() </code>方法使用了条件变量 pthread_cond_wait 函数，该函数的作用是使当前线程阻塞，等待条件变量被其他线程通过 pthread_cond_signal 或 pthread_cond_broadcast 激活。这个函数会释放 lock 互斥锁，允许其他线程在执行 pthread_cond_signal 或 pthread_cond_broadcast 时获得锁。</p> 
<p id="u8e3ef695">具体步骤如下：</p> 
<ol><li id="u563fd793">当前线程调用 pthread_cond_wait 时，它会释放 lock，使得其他线程可以进入临界区。</li><li id="ue1bc5be4">当其他线程执行 pthread_cond_signal 或 pthread_cond_broadcast 时，被阻塞的线程会重新获得 lock。</li><li id="u5f7ac472">被重新唤醒的线程会重新检查条件。如果条件满足，它将继续执行；否则，它将再次进入等待状态。</li></ol> 
<p id="u17166306">这种机制通常用于线程之间的同步，其中一个线程在满足某个条件时通知其他线程继续执行。在这个线程池的实现中，waitCond 用于在任务队列为空时阻塞线程，直到有新的任务到来。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;unistd.h&gt;
#include "lockGuard.hpp"
#include "thread.hpp"
#include "log.hpp"

const int g_thread_num = 10;

// 本质：生产者消费者模型
template&lt;class T&gt;
class ThreadPool
{
public:
	// 加锁
    pthread_mutex_t* getMutex()
    {
        return &amp;lock;
    }
	// 判断任务队列是否为空
    bool isEmpty()
    {
        return _task_queue.empty();
    }
	// 调用条件变量
    void waitCond()
    {
        pthread_cond_wait(&amp;cond, &amp;lock);
    }
	// 获取一个任务
    T getTask()
    {
        T t = _task_queue.front();
        _task_queue.pop();
        return t;
    }

private:
    ThreadPool(int thread_num = g_thread_num)
    :_num(thread_num)
    {

        for(int i=1; i &lt;= _num; i++)
        {
            _threads.push_back(new Thread(i, routine, this));
        }
        pthread_mutex_init(&amp;lock, nullptr);
        pthread_cond_init(&amp;cond, nullptr);
    }
	// 禁用拷贝构造和拷贝赋值
    ThreadPool(const ThreadPool&lt;T&gt; &amp;other) = delete;
    const ThreadPool&lt;T&gt; operator=(const ThreadPool&lt;T&gt; &amp;other) = delete;

public: 
    static ThreadPool&lt;T&gt; *getThreadPool(int num = g_thread_num)
    {
        // 可以有效减少未来必定要进行枷锁检测的问题
        // 拦截大量的再已经创建好单例的时候，剩余线程请求单例的而直接访问所的行为
        if(nullptr == thread_ptr)
        {
            lockGuard lockguard(&amp;mutex);
            if(thread_ptr == nullptr)
            {
                thread_ptr = new ThreadPool&lt;T&gt;(num);
            }
        }
        return thread_ptr;
    }
    void run()
    {
         // 启动所有线程
        for(auto &amp;iter : _threads)
        {
            iter-&gt;start();
            logMessage(NORMAL, "%s %s", iter-&gt;name().c_str(), "启动成功");
        }
    }
 // 从任务队列中获取任务
    static void* routine(void* args)
    {
        ThreadData *td = (ThreadData*)args;
        ThreadPool&lt;T&gt; *tp = (ThreadPool&lt;T&gt;*)td-&gt;_args;
        while(true)
        {
            T task;
            {
                lockGuard lockGuard(tp-&gt;getMutex());
                while(tp-&gt;isEmpty())
                {
                    tp-&gt;waitCond();
                }
                // 获取任务
                task = tp-&gt;getTask();
            }
            task(td-&gt;_name);
        }
    }
    // 添加任务到任务队列
    void PushTask(const T &amp;task)
    {
        lockGuard lockguard(&amp;lock);
        _task_queue.push(task);
        pthread_cond_signal(&amp;cond);
    }
    ~ThreadPool()
    {
        for(auto &amp;iter : _threads)
        {
            delete iter;
        }
        pthread_mutex_destroy(&amp;lock);
        pthread_cond_destroy(&amp;cond);
    }

private:
    std::vector&lt;Thread*&gt; _threads;
    int _num;
    std::queue&lt;T&gt; _task_queue;

    static ThreadPool&lt;T&gt; *thread_ptr;
    static pthread_mutex_t mutex;

    pthread_mutex_t lock;
    pthread_cond_t cond;
};

template &lt;typename T&gt;
ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::thread_ptr = nullptr;
template &lt;typename T&gt;
pthread_mutex_t ThreadPool&lt;T&gt;::mutex = PTHREAD_MUTEX_INITIALIZER;
// 这样的定义确保了每个模板实例都有自己的静态成员，而不是共享同一个。
// PTHREAD_MUTEX_INITIALIZER，这是一个宏，用于初始化一个互斥锁。
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b2a02028cc5eaa21fb3d995a961d7f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea设置自动编译spring boot代码，idea代码修改后无须重启服务立即生效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74556c3b5be3fdb0c448afe1f01a0400/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【k8s系列】(202402) 证书apiserver_client_certificate_expiration_seconds</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>