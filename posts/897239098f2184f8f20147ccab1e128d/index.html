<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>scala隐式转换 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="scala隐式转换" />
<meta property="og:description" content="目录
隐式转换的概念
隐式转换的使用
隐式转换做参数类型转换
隐式转换增强现有类型
隐式参数
利用隐式参数进行隐式转换
再议Context Bounds
隐式转换的概念 隐式转换函数（implicit conversion function）是以implicit关键字声明的带有单个参数的函数，这样的函数将被自动应用，将值从一种类型转换为另一种类型。隐式转换函数叫什么名字是无所谓的，因为通常不会由用户手动调用，而是由Scala进行调用。但是如果要使用隐式转换，则需要对隐式转换函数进行导入。因此通常建议将隐式转换函数的名称命名为“one2one”的形式。
scala会考虑如下位置的隐式转换函数：
1、位于源或目标类型的伴生对象中的隐式函数
2、位于当前作用域可以以单个标识符指代的隐式函数
隐式转换在如下三种不同情况下会被考虑：
1、当表达式类型与预期类型不同时
2、当对象访问一个不存在成员时
3、当对象调用某个方法，而这个方法的参数声明与传入参数不匹配时
有三种情况编译器不会尝试使用隐式转换
1、如果代码能够在不使用隐式转换的前提下通过编译，则不会使用隐式转换
2、编译器不会尝试同事执行多个转换
3、存在二义性的转换是错误。
隐式转换的使用 隐式转换做参数类型转换 // 案例：特殊售票窗口（只接受特殊人群，比如学生、老人等） class SpecialPerson(val name : String) class Student(val name : String) class Older(val name : String) //隐式转换函数，将Student和Older转变成SpecialPerson类型 implicit def object2SpecialPerson(obj : Object) : SpecialPerson = { obj match{ case a : Student =&gt; {val stu = obj.asInstanceOf[Student];new SpecialPerson(stu.name)} case b : Older =&gt;{val old = obj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/897239098f2184f8f20147ccab1e128d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-05T07:25:38+08:00" />
<meta property="article:modified_time" content="2018-09-05T07:25:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">scala隐式转换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">隐式转换的概念</a></p> 
<p id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">隐式转换的使用</a></p> 
<p id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%81%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%81%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">隐式转换做参数类型转换</a></p> 
<p id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%A2%9E%E5%BC%BA%E7%8E%B0%E6%9C%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%A2%9E%E5%BC%BA%E7%8E%B0%E6%9C%89%E7%B1%BB%E5%9E%8B" rel="nofollow">隐式转换增强现有类型</a></p> 
<p id="%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0" rel="nofollow">隐式参数</a></p> 
<p id="%E5%88%A9%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%E5%88%A9%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2" rel="nofollow">利用隐式参数进行隐式转换</a></p> 
<p id="%E5%86%8D%E8%AE%AEContext%20Bounds-toc" style="margin-left:40px;"><a href="#%E5%86%8D%E8%AE%AEContext%20Bounds" rel="nofollow">再议Context Bounds</a></p> 
<hr id="hr-toc"> 
<h3 id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A6%82%E5%BF%B5">隐式转换的概念</h3> 
<p>隐式转换函数（implicit conversion function）是以<span style="color:#f33b45;">implicit</span>关键字声明的<span style="color:#f33b45;">带有单个参数</span>的函数，这样的函数将被自动应用，将值从一种类型转换为另一种类型。隐式转换函数叫什么名字是无所谓的，因为通常不会由用户手动调用，而是由Scala进行调用。但是如果要使用隐式转换，则需要对隐式转换函数进行导入。因此通常建议将隐式转换函数的名称命名为“one2one”的形式。</p> 
<p>scala会考虑如下位置的隐式转换函数：</p> 
<p style="text-indent:50px;">1、位于源或目标类型的伴生对象中的隐式函数</p> 
<p style="text-indent:50px;">2、位于当前作用域可以以单个标识符指代的隐式函数</p> 
<p>隐式转换在如下三种不同情况下会被考虑：</p> 
<p style="text-indent:50px;">1、当表达式类型与预期类型不同时</p> 
<p style="text-indent:50px;">2、当对象访问一个不存在成员时</p> 
<p style="text-indent:50px;">3、当对象调用某个方法，而这个方法的参数声明与传入参数不匹配时</p> 
<p>有三种情况编译器不会尝试使用隐式转换</p> 
<p style="text-indent:50px;">1、如果代码能够在不使用隐式转换的前提下通过编译，则不会使用隐式转换</p> 
<p style="text-indent:50px;">2、编译器不会尝试同事执行多个转换</p> 
<p style="text-indent:50px;">3、存在二义性的转换是错误。</p> 
<h3 id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BD%BF%E7%94%A8">隐式转换的使用</h3> 
<h4 id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%81%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式转换做参数类型转换</h4> 
<pre class="has"><code class="language-java">  // 案例：特殊售票窗口（只接受特殊人群，比如学生、老人等）
  class SpecialPerson(val name : String)
  class Student(val name : String)
  class Older(val name : String)
  
  //隐式转换函数，将Student和Older转变成SpecialPerson类型
  implicit def object2SpecialPerson(obj : Object) : SpecialPerson = {
    obj match{
      case a : Student =&gt; {val stu = obj.asInstanceOf[Student];new SpecialPerson(stu.name)}
      case b : Older =&gt;{val old = obj.asInstanceOf[Older];new SpecialPerson(old.name)}
      case _ =&gt; Nil
    }
  }
  
  def buySpecialTicket(sp : SpecialPerson){
    println("buySpecialTicket success " + sp.name)
  }
  buySpecialTicket(new Student("Student"))</code></pre> 
<p>运行结果：</p> 
<p><img alt="" class="has" height="118" src="https://images2.imgbox.com/15/fe/FTB890q9_o.png" width="394"></p> 
<h4 id="%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%A2%9E%E5%BC%BA%E7%8E%B0%E6%9C%89%E7%B1%BB%E5%9E%8B">隐式转换增强现有类型</h4> 
<pre class="has"><code>  class Man(val name : String)
  class Super(val name : String){
    println(name + ", superman")
    def supperman(){
      println("superman")
    }
  }
  implicit def man2Super(man : Man) = new Super(man.name)
  val man = new Man("liumingxin")
  println("---------")
  man.supperman
  man.supperman</code></pre> 
<p>运行结果：</p> 
<p><img alt="" class="has" height="145" src="https://images2.imgbox.com/d0/79/SLjbKBes_o.png" width="392"></p> 
<p>由此可见，当调用到隐式转换之后类型的方法时，会先调用隐士转换方法，再调用，而且每一次调用都会先调用隐士转换方法，在隐士转换方法中创建出新的对象，那么每一次的调用都要创建新的对象。</p> 
<h3 id="%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0">隐式参数</h3> 
<p>所谓的隐式参数，指的是在函数或者方法中，定义一个用implicit修饰的参数，此时Scala会尝试找到一个指定类型的，用implicit修饰的对象，即隐式值，并注入参数。</p> 
<p>Scala会在两个范围内查找：一种是当前作用域内可见的val或var定义的隐式变量；一种是隐式参数类型的伴生对象内的隐式值。</p> 
<pre class="has"><code>  case class Delimiters(left : String, right : String)
  def quote(content : String)(implicit d : Delimiters){
    println(d.left + content + d.right )
  }
  implicit val defaultDelimiters = Delimiters("&lt;","&gt;")
  quote("haha")</code></pre> 
<p>运行结果：</p> 
<p><img alt="" class="has" height="60" src="https://images2.imgbox.com/87/1d/la8W3Dbk_o.png" width="155"></p> 
<h3 id="%E5%88%A9%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">利用隐式参数进行隐式转换</h3> 
<p>首先我们先看一个例子：</p> 
<p><img alt="" class="has" height="68" src="https://images2.imgbox.com/15/98/aRb4IZjw_o.png" width="560"></p> 
<p>这里因为a没有明确的类型，编译器不确定它有&lt;方法，因此报错。</p> 
<p>为了满足上面的需求，我们使用隐式参数，转换一下，让a拥有&lt;方法</p> 
<p><img alt="" class="has" height="69" src="https://images2.imgbox.com/66/63/KfMzmW4K_o.png" width="955"></p> 
<p>Ordered[T]特质中有一个接受T参数的&lt;操作符，因此不会出现最初的错误。</p> 
<p>结合隐式转换的概念，隐式转换就是以implicit关键字声明的带有单个参数的函数，“implicit order : T =&gt; Ordered[T]”完全符合概念，因此上面的写法也满足隐式转换，将T隐式转换成了Ordered[T]对象。它不仅是<span style="color:#f33b45;">隐式参数</span>，也是<span style="color:#f33b45;">隐式转换</span>，因此也可以这样写：</p> 
<p><img alt="" class="has" height="69" src="https://images2.imgbox.com/39/7c/hP2xiC4K_o.png" width="846"></p> 
<h3 id="%E5%86%8D%E8%AE%AEContext%20Bounds">再议Context Bounds</h3> 
<p>在<a href="https://blog.csdn.net/lazy_moon/article/details/82177134">scala中的模式匹配和样例类 </a>中已经有讲过Context Boundse了。Context Bounds是一种特殊的Bounds，它会根据泛型类型的声明，比如“T: 类型”要求必须存在一个类型为“类型[T]”的隐式值。表现形式为“T : M”，其中M是一个泛型类型，它要求作用于中存在一个类型为M[T]的隐式值。</p> 
<p><img alt="" class="has" height="122" src="https://images2.imgbox.com/17/0f/MYlUkALw_o.png" width="977"></p> 
<p>scala的学习与研究将告一段落，接下来要开始探索Spark源码了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72195565bed305eb5fd92aa785c63bc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">atan与atan2在求角度时的差别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/afe9a05993270b89b319c6879e3c1836/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">watch命令用法举例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>