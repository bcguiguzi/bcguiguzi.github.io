<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;内存泄漏 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;内存泄漏" />
<meta property="og:description" content="1. 什么是内存泄漏？ 内存泄漏是当一个程序错误地管理内存分配的情况，在这种情况下，内存被分配给了程序，但在不再需要时没有被释放。这意味着内存不再可用，尽管它不再被使用。如果程序持续运行，泄漏会不断累积，最终可能耗尽系统的所有可用内存，导致性能下降甚至程序崩溃。
2. 泄露的是哪部分内存？ 泄露的内存通常是指程序员在堆上动态分配的内存没有被适当释放，导致程序失去了对这些内存块的引用，使得这些内存即使不再需要，也无法被操作系统回收。随着时间的推移，这些未释放的内存块会累积，造成内存泄漏。
在大多数现代操作系统和编程语言中，程序的内存分为几个不同的区域，常见的有以下几种：
1. 堆内存（Heap）：这是用于动态内存分配的区域，程序运行时可以从堆中分配任意大小的内存块。在C语言中，函数如`malloc()`、`calloc()`、`realloc()`和`free()`用于管理内存；在C&#43;&#43;中，有`new`和`delete`操作符。内存泄漏经常发生在堆内存中，因为管理堆内存的责任在于程序员手上，他们必须显式地分配和释放内存。
2. 栈内存（Stack）：这是用于自动存储局部变量和函数调用信息的区域。当函数调用时，局部变量会被分配在栈上，当函数执行完毕后，这些变量会自动被清理。因此，栈内存通常不会发生内存泄漏，因为一旦函数返回，栈上的内存就会自动释放。
3. 全局/静态存储（Global/Static Storage）：这是用于存储全局变量和静态变量的内存区域。这些变量在程序启动时分配，在程序终止时释放。
4. 代码区（Code or Text Segment）：这是存储程序的机器指令代码的内存区域，只读。
3. 为什么会内存泄漏 内存泄漏存在多方面的因素，但大多数内存泄漏通常是因为程序错误或疏忽造成的，归纳总结后，存在以下几种（只是博主的理解，如果发现有缺失的部分，欢迎纠正）
1. 未释放分配的内存：在使用动态内存分配（如C/C&#43;&#43;中的`malloc`/`new`）时，程序员有责任在不再需要分配的内存时释放它（使用`free`/`delete`）。如果程序员忘记释放内存，就会发生内存泄漏。
2. 丢失指针引用：如果覆盖了指向动态分配内存的唯一指针而没有先释放它，那么就无法再访问或释放这部分内存。
3. 程序逻辑错误：程序中的逻辑错误可能导致某些代码路径没有正确释放内存。
4. 循环引用：在使用自动内存管理（如垃圾收集）的编程环境中，两个对象可能相互引用，使得它们都无法释放，因为每个对象至少有一个活跃的引用。
5. 资源泄漏：资源泄漏（比如文件句柄、数据库连接）也可以导致内存泄漏，因为这些资源在打开时通常也会占用内存。
6. 外部库或系统的缺陷：程序员使用的外部库如果自身存在内存管理的问题，也可能导致内存泄漏。
4. 如何避免和减少内存泄露？
以下是博主常用的方式：
智能指针和资源获取即初始化（RAII）：使用智能指针（如`std::unique_ptr`,`std::shared_ptr
`等）可以帮助自动释放内存。RAII是一种在对象生命周期结束时自动释放资源的编程技术。
`std::shared_ptr在使用引用计数的智能指针时，要特别注意避免创建循环引用，它们可能导致内存泄露。如果必须使用，可以考虑`std::weak_ptr`来打破循环。
避免裸指针：尽量避免使用裸指针操作内存，改用上述的智能指针或者容器类。
内存管理工具：在开发过程中使用内存管理工具，如Valgrind等，定期检查内存泄露。
代码审查（工作中也可多方审查）：通过代码审查可以发现并修复可能导致内存泄露的问题。 使用池化和重用机制：对于频繁创建和销毁的对象，使用内存池可以减少内存碎片以及减少内存泄露的风险。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c4c0ebb1959f0577a9df86dc3e19ce76/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-05T15:54:58+08:00" />
<meta property="article:modified_time" content="2024-03-05T15:54:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;内存泄漏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>1. 什么是内存泄漏？</strong></h4> 
<p><strong>        </strong>内存泄漏是当一个程序错误地管理内存分配的情况，在这种情况下，内存被分配给了程序，但在不再需要时没有被释放。这意味着内存不再可用，尽管它不再被使用。如果程序持续运行，泄漏会不断累积，最终可能耗尽系统的所有可用内存，导致性能下降甚至程序崩溃。</p> 
<h4><strong>2. 泄露的是哪部分内存？</strong></h4> 
<p>        泄露的内存通常是指程序员在<strong>堆</strong>上动态分配的内存没有被适当释放，导致程序失去了对这些内存块的引用，使得这些内存即使不再需要，也无法被操作系统回收。随着时间的推移，这些未释放的内存块会累积，造成内存泄漏。</p> 
<p>        在大多数现代操作系统和编程语言中，程序的内存分为几个不同的区域，常见的有以下几种：</p> 
<p>        <strong>1. 堆内存（Heap）：</strong>这是用于动态内存分配的区域，程序运行时可以从堆中分配任意大小的内存块。在C语言中，函数如`malloc()`、`calloc()`、`realloc()`和`free()`用于管理内存；在C++中，有`new`和`delete`操作符。<strong>内存泄漏经常发生在堆内存中</strong>，因为管理堆内存的责任在于程序员手上，他们必须显式地分配和释放内存。</p> 
<p>       <strong> 2. 栈内存（Stack）：</strong>这是用于自动存储局部变量和函数调用信息的区域。当函数调用时，局部变量会被分配在栈上，当函数执行完毕后，这些变量会自动被清理。因此，栈内存通常不会发生内存泄漏，因为一旦函数返回，栈上的内存就会自动释放。</p> 
<p>        <strong>3. 全局/静态存储（Global/Static Storage）：</strong>这是用于存储全局变量和静态变量的内存区域。这些变量在程序启动时分配，在程序终止时释放。</p> 
<p>        <strong>4. 代码区（Code or Text Segment）：</strong>这是存储程序的机器指令代码的内存区域，只读。</p> 
<h4><strong>3. 为什么会内存泄漏</strong></h4> 
<p><strong>        </strong>内存泄漏存在多方面的因素，但大多数内存泄漏通常是因为程序错误或疏忽造成的，归纳总结后，存在以下几种（只是博主的理解，如果发现有缺失的部分，欢迎纠正）</p> 
<p>  <strong>      1. 未释放分配的内存：</strong>在使用动态内存分配（如C/C++中的`malloc`/`new`）时，程序员有责任在不再需要分配的内存时释放它（使用`free`/`delete`）。如果程序员忘记释放内存，就会发生内存泄漏。</p> 
<p>        <strong>2. 丢失指针引用：</strong>如果覆盖了指向动态分配内存的唯一指针而没有先释放它，那么就无法再访问或释放这部分内存。</p> 
<p>        <strong>3. 程序逻辑错误：</strong>程序中的逻辑错误可能导致某些代码路径没有正确释放内存。</p> 
<p>      <strong>  4. 循环引用：</strong>在使用自动内存管理（如垃圾收集）的编程环境中，两个对象可能相互引用，使得它们都无法释放，因为每个对象至少有一个活跃的引用。</p> 
<p>     <strong>   5. 资源泄漏：</strong>资源泄漏（比如文件句柄、数据库连接）也可以导致内存泄漏，因为这些资源在打开时通常也会占用内存。</p> 
<p>     <strong>   6. 外部库或系统的缺陷：</strong>程序员使用的外部库如果自身存在内存管理的问题，也可能导致内存泄漏。</p> 
<p><strong>4. 如何避免和减少内存泄露？</strong></p> 
<p><strong>        以下是博主常用的方式：</strong></p> 
<p>         <strong>智能指针和资源获取即初始化（RAII）：</strong>使用智能指针（如`std::unique_ptr`,`std::shared_ptr</p> 
<p>`等）可以帮助自动释放内存。RAII是一种在对象生命周期结束时自动释放资源的编程技术。</p> 
<blockquote> 
 <p>`std::shared_ptr在使用引用计数的智能指针时，要特别注意避免创建循环引用，它们可能导致内存泄露。如果必须使用，可以考虑`std::weak_ptr`来打破循环。</p> 
</blockquote> 
<p>      <strong>  避免裸指针：</strong>尽量避免使用裸指针操作内存，改用上述的智能指针或者容器类。</p> 
<p>        <strong>内存管理工具：</strong>在开发过程中使用内存管理工具，如Valgrind等，定期检查内存泄露。</p> 
<p>       <strong> 代码审查（工作中也可多方审查）：</strong>通过代码审查可以发现并修复可能导致内存泄露的问题。 </p> 
<p>        <strong>使用池化和重用机制：</strong>对于频繁创建和销毁的对象，使用内存池可以减少内存碎片以及减少内存泄露的风险。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6f919bb69b2666d8333b0abde03381c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud Alibaba一一SentinelResource</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86a2bd287516893f1fb19a1dd6ee58e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UE5 文字游戏（2） C&#43;&#43;实时读取CSV文件（游戏开始读取本地CSV剧本）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>