<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>I.MX6ULL_Linux_系统篇(16) uboot分析-启动流程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="I.MX6ULL_Linux_系统篇(16) uboot分析-启动流程" />
<meta property="og:description" content="原文链接：I.MX6ULL_系统篇(16) uboot分析-启动流程 – WSY Personal Blog (cpolar.cn)
前面我们详细的分析了 uboot 的顶层 Makefile，了解了 uboot 的编译流程。本章我们来详细的分析一下 uboot 的启动流程，理清 uboot 是如何启动的。通过对 uboot 启动流程的梳理，我们就可以掌握一些外设是在哪里被初始化的，这样当我们需要修改这些外设驱动的时候就会心里有数。另外，通过分析 uboot 的启动流程可以了解 Linux 内核是如何被启动的。
链接脚本 u-boot.lds
要分析 uboot 的启动流程，首先要找到“入口”，找到第一行程序在哪里。程序的链接是由链接脚本来决定的，所以通过链接脚本可以找到程序的入口。如果没有编译过 uboot 的话链接脚本为 arch/arm/cpu/u-boot.lds。但是这个不是最终使用的链接脚本，最终的链接脚本是在这个链接脚本的基础上生成的。编译一下 uboot，编译完成以后就会在 uboot 根目录下生成 u-boot.lds文件，如图所示：
OUTPUT_FORMAT(&#34;elf32-littlearm&#34;, &#34;elf32-littlearm&#34;, &#34;elf32-littlearm&#34;) OUTPUT_ARCH(arm) ENTRY(_start) #代码入口 SECTIONS { . = 0x00000000; . = ALIGN(4); .text : { *(.__image_copy_start) *(.vectors) arch/arm/cpu/armv7/start.o (.text*) *(.text*) } . = ALIGN(4); .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) } . = ALIGN(4); ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1dc3b92ea9284e518b28cc4c199ca2a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-20T13:56:04+08:00" />
<meta property="article:modified_time" content="2023-02-20T13:56:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">I.MX6ULL_Linux_系统篇(16) uboot分析-启动流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:left;">原文链接：<a href="https://wsy-blog.cpolar.cn/2023/02/20/i-mx6ull_%E7%B3%BB%E7%BB%9F%E7%AF%8716-uboot%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="nofollow" title="I.MX6ULL_系统篇(16) uboot分析-启动流程 – WSY Personal Blog (cpolar.cn)">I.MX6ULL_系统篇(16) uboot分析-启动流程 – WSY Personal Blog (cpolar.cn)</a></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">前面我们详细的分析了</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的顶层</span><span style="color:#25292a;"> Makefile</span><span style="color:#25292a;">，了解了</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的编译流程。本章我们来详细的分析一下</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的启动流程，理清</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">是如何启动的。通过对</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">启动流程的梳理，我们就可以掌握一些外设是在哪里被初始化的，这样当我们需要修改这些外设驱动的时候就会心里有数。另外，通过分析</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的启动流程可以了解</span><span style="color:#25292a;"> Linux </span><span style="color:#25292a;">内核是如何被启动的。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">链接脚本</span><span style="color:#17252a;"> u-boot.lds</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">要分析</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的启动流程，首先要找到</span><span style="color:#25292a;">“</span><span style="color:#25292a;">入口</span><span style="color:#25292a;">”</span><span style="color:#25292a;">，找到第一行程序在哪里。程序的链接是由链接脚本来决定的，所以通过链接脚本可以找到程序的入口。如果没有编译过</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的话链接脚本为</span><span style="color:#25292a;"> arch/arm/cpu/u-boot.lds</span><span style="color:#25292a;">。但是这个不是最终使用的链接脚本，最终的链接脚本是在这个链接脚本的基础上生成的。编译一下</span><span style="color:#25292a;"> uboot</span><span style="color:#25292a;">，编译完成以后就会在</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">根目录下生成</span><span style="color:#25292a;"> u-boot.lds</span><span style="color:#25292a;">文件，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="164" src="https://images2.imgbox.com/d0/b9/Zdd1f9y4_o.png" width="1024"></p> 
<pre><code class="hljs">OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")

OUTPUT_ARCH(arm)

ENTRY(_start) #代码入口

SECTIONS

{

 . = 0x00000000;

 . = ALIGN(4);

 .text :

 {

  *(.__image_copy_start)

  *(.vectors)

  arch/arm/cpu/armv7/start.o (.text*)

  *(.text*)

 }

 . = ALIGN(4);

 .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }

 . = ALIGN(4);

 .data : {

  *(.data*)

 }

 . = ALIGN(4);

 . = .;

 . = ALIGN(4);

 .u_boot_list : {

  KEEP(*(SORT(.u_boot_list*)));

 }

 . = ALIGN(4);

 .image_copy_end :

 {

  *(.__image_copy_end)

 }

 .rel_dyn_start :

 {

  *(.__rel_dyn_start)

 }

 .rel.dyn : {

  *(.rel*)

 }

 .rel_dyn_end :

 {

  *(.__rel_dyn_end)

 }

 .end :

 {

  *(.__end)

 }

 _image_binary_end = .;

 . = ALIGN(4096);

 .mmutable : {

  *(.mmutable)

 }

 .bss_start __rel_dyn_start (OVERLAY) : {

  KEEP(*(.__bss_start));

  __bss_base = .;

 }

 .bss __bss_base (OVERLAY) : {

  *(.bss*)

   . = ALIGN(4);

   __bss_limit = .;

 }

 .bss_end __bss_limit (OVERLAY) : {

  KEEP(*(.__bss_end));

 }

 .dynsym _image_binary_end : { *(.dynsym) }

 .dynbss : { *(.dynbss) }

 .dynstr : { *(.dynstr*) }

 .dynamic : { *(.dynamic*) }

 .plt : { *(.plt*) }

 .interp : { *(.interp*) }

 .gnu.hash : { *(.gnu.hash) }

 .gnu : { *(.gnu*) }

 .ARM.exidx : { *(.ARM.exidx*) }

 .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }

}</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 3 </span><span style="color:#25292a;">行为代码当前入口点：</span><span style="color:#25292a;"> _start</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> _start </span><span style="color:#25292a;">在文件</span><span style="color:#25292a;"> arch/arm/lib/vectors.S </span><span style="color:#25292a;">中有定义，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="588" src="https://images2.imgbox.com/52/5e/4LVdJNR0_o.png" width="885"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从图中的代码可以看出，</span><span style="color:#25292a;"> _start </span><span style="color:#25292a;">后面就是中断向量表，从图中的</span><span style="color:#25292a;">“.section “.vectors”,”ax”</span><span style="color:#25292a;">可以得到，此代码存放在</span><span style="color:#25292a;">.vectors </span><span style="color:#25292a;">段里面。使用如下命令在</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中查找</span><span style="color:#25292a;">“__image_copy_start”</span><span style="color:#25292a;">：</span></span></p> 
<pre><code class="hljs">grep -nR "__image_copy_start"</code></pre> 
<p style="margin-left:0;text-align:left;"><img alt="" height="173" src="https://images2.imgbox.com/65/c7/J3Y8jmDe_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">打开</span><span style="color:#25292a;"> u-boot.map</span><span style="color:#25292a;">，找到如上图所示位置：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="613" src="https://images2.imgbox.com/a2/18/ye1N69lo_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">u-boot.map </span><span style="color:#25292a;">是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的映射文件，可以从此文件看到某个文件或者函数链接到了哪个地址，从上图的</span><span style="color:#25292a;"> 932 </span><span style="color:#25292a;">行可以看到</span><span style="color:#25292a;">__image_copy_start </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 0X87800000</span><span style="color:#25292a;">，而</span><span style="color:#25292a;">.text </span><span style="color:#25292a;">的起始地址也是</span><span style="color:#25292a;">0X87800000</span><span style="color:#25292a;">。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续回到链接脚本中，</span> <span style="color:#25292a;">第</span><span style="color:#25292a;"> 11 </span><span style="color:#25292a;">行是</span><span style="color:#25292a;"> vectors </span><span style="color:#25292a;">段，</span><span style="color:#25292a;"> vectors </span><span style="color:#25292a;">段保存中断向量表，我们知道了</span><span style="color:#25292a;"> vectors.S </span><span style="color:#25292a;">的代码是存在</span><span style="color:#25292a;"> vectors </span><span style="color:#25292a;">段中的。从上图中可以看出，</span><span style="color:#25292a;"> vectors </span><span style="color:#25292a;">段的起始地址也是</span><span style="color:#25292a;"> 0X87800000</span><span style="color:#25292a;">，说明整个</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的起始地址就是</span><span style="color:#25292a;"> 0X87800000</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 12 </span><span style="color:#25292a;">行将</span><span style="color:#25292a;"> arch/arm/cpu/armv7/start.s </span><span style="color:#25292a;">编译出来的代码放到中断向量表后面。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 13 </span><span style="color:#25292a;">行为</span><span style="color:#25292a;"> text </span><span style="color:#25292a;">段，其他的代码段就放到这里</span><br><span style="color:#25292a;">在</span><span style="color:#25292a;"> u-boot.lds </span><span style="color:#25292a;">中有一些跟地址有关的</span><span style="color:#25292a;">“</span><span style="color:#25292a;">变量</span><span style="color:#25292a;">”</span><span style="color:#25292a;">需要我们注意一下，后面分析</span><span style="color:#25292a;"> u-boot </span><span style="color:#25292a;">源码的时候会用到，这些变量要最终编译完成才能确定的！！！比如我编译完成以后这些</span><span style="color:#25292a;">“</span><span style="color:#25292a;">变量</span><span style="color:#25292a;">”</span><span style="color:#25292a;">的值如表所示：</span></span></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">变量</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">数值</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">描述</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__image_copy_start</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x87800000</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">uboot 拷贝的首地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__image_copy_end</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x8785dd54</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">uboot 拷贝的结束地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__rel_dyn_start</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x8785dd54</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">.rel.dyn 段起始地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__rel_dyn_end</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x878668f4</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">.rel.dyn 段结束地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">_image_binary_end</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x878668f4</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">镜像结束地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__bss_start</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x8785dd54</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">.bss 段起始地址</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">__bss_end</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">0x878a8e74</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">.bss 段结束地址</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">表中的</span><span style="color:#25292a;">“</span><span style="color:#25292a;">变量</span><span style="color:#25292a;">”</span><span style="color:#25292a;">值可以在</span><span style="color:#25292a;"> u-boot.map </span><span style="color:#25292a;">文件中查找，其中除了</span><span style="color:#25292a;">__image_copy_start</span><span style="color:#25292a;">以外，其他的变量值每次编译的时候可能会变化，如果修改了</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">代码、修改了</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">配置、选用不同的优化等级等等都会影响到这些值。所以，一切以实际值为准！</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">启动流程详解</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">reset </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从</span><span style="color:#25292a;"> u-boot.lds </span><span style="color:#25292a;">中我们已经知道了入口点是</span><span style="color:#25292a;"> arch/arm/lib/vectors.S </span><span style="color:#25292a;">文件中的</span><span style="color:#25292a;">_start</span><span style="color:#25292a;">，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="227" src="https://images2.imgbox.com/50/ef/zWG1oJ2m_o.png" width="484"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 48 </span><span style="color:#25292a;">行</span><span style="color:#25292a;">_start </span><span style="color:#25292a;">开始的是中断向量表，其中</span><span style="color:#25292a;"> 54~61 </span><span style="color:#25292a;">行就是中断向量表，和我们裸机例程里面一样。</span><span style="color:#25292a;">54 </span><span style="color:#25292a;">行跳转到</span><span style="color:#25292a;"> reset </span><span style="color:#25292a;">函数里面，</span><span style="color:#25292a;"> reset </span><span style="color:#25292a;">函数在</span><span style="color:#25292a;"> arch/arm/cpu/armv7/start.S </span><span style="color:#25292a;">里面，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="103" src="https://images2.imgbox.com/7d/24/udUwfPWG_o.png" width="582"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 35 </span><span style="color:#25292a;">行就是</span><span style="color:#25292a;"> reset </span><span style="color:#25292a;">函数。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 37 </span><span style="color:#25292a;">行从</span><span style="color:#25292a;"> reset </span><span style="color:#25292a;">函数跳转到了</span><span style="color:#25292a;"> save_boot_params </span><span style="color:#25292a;">函数，而</span><span style="color:#25292a;"> save_boot_params </span><span style="color:#25292a;">函数同样定义在</span><span style="color:#25292a;"> start.S </span><span style="color:#25292a;">里面，定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="258" src="https://images2.imgbox.com/4c/f1/eNr4iGmN_o.png" width="796"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">save_boot_params </span><span style="color:#25292a;">函数也是只有一句跳转语句，跳转到</span><span style="color:#25292a;"> save_boot_params_ret </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;">save_boot_params_ret </span><span style="color:#25292a;">函数代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="617" src="https://images2.imgbox.com/f2/05/i98Hkcx8_o.png" width="785"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 43 </span><span style="color:#25292a;">行，读取寄存器</span><span style="color:#25292a;"> cpsr </span><span style="color:#25292a;">中的值，并保存到</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器中。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 44 </span><span style="color:#25292a;">行，将寄存器</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">中的值与</span><span style="color:#25292a;"> 0X1F </span><span style="color:#25292a;">进行与运算，结果保存到</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">寄存器中，目的就是提取</span><span style="color:#25292a;"> cpsr </span><span style="color:#25292a;">的</span><span style="color:#25292a;">bit0~bit4 </span><span style="color:#25292a;">这</span><span style="color:#25292a;"> 5 </span><span style="color:#25292a;">位，这</span><span style="color:#25292a;"> 5 </span><span style="color:#25292a;">位为</span><span style="color:#25292a;"> M4 M3 M2 M1 M0</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> M[4:0]</span><span style="color:#25292a;">这五位用来设置处理器的工作模式，如表所示：</span></span></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">M[4:0]</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">模式</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10000</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">User(usr)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10001</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">FIQ(fiq)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10010</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">IRQ(irq)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10011</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">Supervisor(svc)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10110</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">Monitor(mon)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">10111</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">Abort(abt)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">11010</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">Hyp(hyp)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">11011</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">Undefined(und)</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:left;">11111</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:left;">System(sys)</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 45 </span><span style="color:#25292a;">行，判断</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">寄存器的值是否等于</span><span style="color:#25292a;"> 0X1A(0b11010)</span><span style="color:#25292a;">，也就是判断当前处理器模式是否处于</span><span style="color:#25292a;"> Hyp </span><span style="color:#25292a;">模式。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 46 </span><span style="color:#25292a;">行，如果</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> 0X1A </span><span style="color:#25292a;">不相等，也就是</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">不处于</span><span style="color:#25292a;"> Hyp </span><span style="color:#25292a;">模式的话就将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的</span><span style="color:#25292a;">bit0~5 </span><span style="color:#25292a;">进行清零，其实就是清除模式位</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 47 </span><span style="color:#25292a;">行，如果处理器不处于</span><span style="color:#25292a;"> Hyp </span><span style="color:#25292a;">模式的话就将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">的寄存器的值与</span><span style="color:#25292a;"> 0x13 </span><span style="color:#25292a;">进行或运算，</span><span style="color:#25292a;">0x13=0b10011</span><span style="color:#25292a;">，也就是设置处理器进入</span><span style="color:#25292a;"> SVC </span><span style="color:#25292a;">模式。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 48 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的值再与</span><span style="color:#25292a;"> 0xC0 </span><span style="color:#25292a;">进行或运算，那么</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器此时的值就是</span><span style="color:#25292a;"> 0xD3</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> cpsr</span><span style="color:#25292a;">的</span><span style="color:#25292a;"> I </span><span style="color:#25292a;">位和</span><span style="color:#25292a;"> F </span><span style="color:#25292a;">位分别控制</span><span style="color:#25292a;"> IRQ </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> FIQ </span><span style="color:#25292a;">这两个中断的开关，设置为</span><span style="color:#25292a;"> 1 </span><span style="color:#25292a;">就关闭了</span><span style="color:#25292a;"> FIQ </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> IRQ</span><span style="color:#25292a;">！第</span><span style="color:#25292a;"> 49 </span><span style="color:#25292a;">行，将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器写回到</span><span style="color:#25292a;"> cpsr </span><span style="color:#25292a;">寄存器中。完成设置</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">处于</span><span style="color:#25292a;"> SVC </span><span style="color:#25292a;">模式，并且关闭</span><span style="color:#25292a;">FIQ </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> IRQ </span><span style="color:#25292a;">这两个中断。</span><br><span style="color:#25292a;">继续执行执行下面的代码！</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 56 </span><span style="color:#25292a;">行，如果没有定义</span><span style="color:#25292a;"> CONFIG_OMAP44XX </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> CONFIG_SPL_BUILD </span><span style="color:#25292a;">的话条件成立，此处条件成立。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 58 </span><span style="color:#25292a;">行读取</span><span style="color:#25292a;"> CP15 </span><span style="color:#25292a;">中</span><span style="color:#25292a;"> c1 </span><span style="color:#25292a;">寄存器的值到</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器中，这里是读取</span><span style="color:#25292a;">SCTLR </span><span style="color:#25292a;">寄存器的值。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 59 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> CR_V </span><span style="color:#25292a;">在</span><span style="color:#25292a;"> arch/arm/include/asm/system.h </span><span style="color:#25292a;">中有如下所示定义：</span></span></p> 
<p style="margin-left:0;text-align:left;">#define CR_V (1 &lt;&lt; 13) /* Vectors relocated to 0xffff0000 */</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">因此这一行的目的就是清除</span><span style="color:#25292a;"> SCTLR </span><span style="color:#25292a;">寄存器中的</span><span style="color:#25292a;"> bit13</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> SCTLR </span><span style="color:#25292a;">寄存器结构如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="418" src="https://images2.imgbox.com/26/37/W3L47Udm_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从图中可以看出，</span><span style="color:#25292a;"> bit13 </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> V </span><span style="color:#25292a;">位，此位是向量表控制位，当为</span><span style="color:#25292a;"> 0 </span><span style="color:#25292a;">的时候向量表基地址为</span><span style="color:#25292a;"> 0X00000000</span><span style="color:#25292a;">，软件可以重定位向量表。为</span><span style="color:#25292a;"> 1 </span><span style="color:#25292a;">的时候向量表基地址为</span><span style="color:#25292a;"> 0XFFFF0000</span><span style="color:#25292a;">，软件不能重定位向量表。这里将</span><span style="color:#25292a;"> V </span><span style="color:#25292a;">清零，目的就是为了接下来的向量表重定位。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 60 </span><span style="color:#25292a;">行将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的值重写写入到寄存器</span><span style="color:#25292a;"> SCTLR </span><span style="color:#25292a;">中。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;">63</span><span style="color:#25292a;">行设置</span><span style="color:#25292a;">r0</span><span style="color:#25292a;">寄存器的值为</span><span style="color:#25292a;">_start</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> _start</span><span style="color:#25292a;">就是整个</span><span style="color:#25292a;">uboot</span><span style="color:#25292a;">的入口地址，其值为</span><span style="color:#25292a;">0X87800000</span><span style="color:#25292a;">，相当于</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的起始地址，因此</span><span style="color:#25292a;"> 0x87800000 </span><span style="color:#25292a;">也是向量表的起始地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 64 </span><span style="color:#25292a;">行将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的值</span><span style="color:#25292a;">(</span><span style="color:#25292a;">向量表值</span><span style="color:#25292a;">)</span><span style="color:#25292a;">写入到</span><span style="color:#25292a;"> CP15 </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> c12 </span><span style="color:#25292a;">寄存器中，也就是</span><span style="color:#25292a;"> VBAR </span><span style="color:#25292a;">寄存器。因此第</span><span style="color:#25292a;"> 58~64 </span><span style="color:#25292a;">行就是设置向量表重定位的。</span><br><span style="color:#25292a;">代码继续往下执行！</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 68 </span><span style="color:#25292a;">行如果没有定义</span><span style="color:#25292a;"> CONFIG_SKIP_LOWLEVEL_INIT </span><span style="color:#25292a;">的话条件成立。我们没有定义</span><span style="color:#25292a;">CONFIG_SKIP_LOWLEVEL_INIT</span><span style="color:#25292a;">，因此条件成立，执行下面的语句。就是分别调用函数</span><span style="color:#25292a;"> cpu_init_cp15</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> cpu_init_crit </span><span style="color:#25292a;">和</span><span style="color:#25292a;">_main</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">函数</span><span style="color:#25292a;"> cpu_init_cp15 </span><span style="color:#25292a;">用来设置</span><span style="color:#25292a;"> CP15 </span><span style="color:#25292a;">相关的内容，比如关闭</span><span style="color:#25292a;"> MMU </span><span style="color:#25292a;">啥的，此函数同样在</span><span style="color:#25292a;"> start.S</span><span style="color:#25292a;">文件中定义的，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="599" src="https://images2.imgbox.com/14/1c/8spOU3qM_o.png" width="791"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">函数</span><span style="color:#25292a;"> cpu_init_crit </span><span style="color:#25292a;">也在是定义在</span><span style="color:#25292a;"> start.S </span><span style="color:#25292a;">文件中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="311" src="https://images2.imgbox.com/5e/a7/nCbmUoPU_o.png" width="881"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可以看出函数</span><span style="color:#25292a;"> cpu_init_crit </span><span style="color:#25292a;">内部仅仅是调用了函数</span><span style="color:#25292a;"> lowlevel_init</span><span style="color:#25292a;">，接下来就是详细的分析一下</span><span style="color:#25292a;"> lowlevel_init </span><span style="color:#25292a;">和</span><span style="color:#25292a;">_main </span><span style="color:#25292a;">这两个函数。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">lowlevel_init </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">函数</span><span style="color:#25292a;"> lowlevel_init </span><span style="color:#25292a;">在文件</span><span style="color:#25292a;"> arch/arm/cpu/armv7/lowlevel_init.S </span><span style="color:#25292a;">中定义，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="679" src="https://images2.imgbox.com/cd/d8/mzPNTcgj_o.png" width="777"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 22 </span><span style="color:#25292a;">行设置</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指向</span><span style="color:#25292a;"> CONFIG_SYS_INIT_SP_ADDR</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> CONFIG_SYS_INIT_SP_ADDR </span><span style="color:#25292a;">在</span><span style="color:#25292a;">include/configs/mx6ullevk.h </span><span style="color:#25292a;">文件中，在</span><span style="color:#25292a;"> mx6ullevk.h </span><span style="color:#25292a;">中有如下所示定义：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="252" src="https://images2.imgbox.com/c4/e5/Afw7WnrC_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">上图中</span> <span style="color:#25292a;">的</span><span style="color:#25292a;"> IRAM_BASE_ADDR </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> IRAM_SIZE </span><span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;">arch/arm/include/asm/arch-mx6/imx-regs.h </span><span style="color:#25292a;">中有定义，如下所示，其实就是</span><span style="color:#25292a;"> IMX6UL/IM6ULL </span><span style="color:#25292a;">内部</span><span style="color:#25292a;"> ocram </span><span style="color:#25292a;">的首地址和大小。</span></span></p> 
<pre><code class="hljs">71 #define IRAM_BASE_ADDR 0x00900000

......

408 #if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \

409 defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))

410 #define IRAM_SIZE 0x00040000

411 #else

412 #define IRAM_SIZE 0x00020000

413 #endif</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">如果</span><span style="color:#25292a;"> 408 </span><span style="color:#25292a;">行的条件成立的话</span><span style="color:#25292a;"> IRAM_SIZE=0X40000</span><span style="color:#25292a;">，当定义了</span><span style="color:#25292a;"> CONFIG_MX6SX</span><span style="color:#25292a;">、</span><span style="color:#25292a;">CONFIG_MX6U</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> CONFIG_MX6SLL </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> CONFIG_MX6SL </span><span style="color:#25292a;">中的任意一个的话条件就不成立，在</span><span style="color:#25292a;">.config </span><span style="color:#25292a;">中定义了</span><span style="color:#25292a;"> CONFIG_MX6UL</span><span style="color:#25292a;">，所以条件不成立，因此</span><span style="color:#25292a;"> IRAM_SIZE=0X20000=128KB</span><span style="color:#25292a;">。可以得到如下值：</span></span></p> 
<pre><code class="hljs">CONFIG_SYS_INIT_RAM_ADDR = IRAM_BASE_ADDR = 0x00900000。

CONFIG_SYS_INIT_RAM_SIZE = 0x00020000 =128KB。</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">还需要知道</span><span style="color:#25292a;">GENERATED_GBL_DATA_SIZE</span><span style="color:#25292a;">的值，在文件</span><span style="color:#25292a;">include/generated/generic-asm-offsets.h</span><span style="color:#25292a;">中有定义，如下：</span></span></p> 
<pre><code class="hljs">1 #ifndef __GENERIC_ASM_OFFSETS_H__

2 #define __GENERIC_ASM_OFFSETS_H__

3 /*

4 * DO NOT MODIFY.

5 *

6 * This file was generated by Kbuild

7 */

8 9

#define GENERATED_GBL_DATA_SIZE 256

10 #define GENERATED_BD_INFO_SIZE 80

11 #define GD_SIZE 248

12 #define GD_BD 0

13 #define GD_MALLOC_BASE 192

14 #define GD_RELOCADDR 48

15 #define GD_RELOC_OFF 68

16 #define GD_START_ADDR_SP 64

17

18 #endif</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">GENERATED_GBL_DATA_SIZE=256</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> GENERATED_GBL_DATA_SIZE </span><span style="color:#25292a;">的含义为</span><span style="color:#25292a;">(sizeof(struct global_data) + 15) &amp; ~15 </span><span style="color:#25292a;">。综上所述，</span><span style="color:#25292a;"> CONFIG_SYS_INIT_SP_ADDR </span><span style="color:#25292a;">值如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">CONFIG_SYS_INIT_SP_OFFSET = 0x00020000 – 256 = 0x1FF00。</p> 
<p style="margin-left:0;text-align:left;">CONFIG_SYS_INIT_SP_ADDR = 0x00900000 + 0X1FF00 = 0X0091FF00，</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">结果如下图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="515" src="https://images2.imgbox.com/c8/7d/dENnYhvW_o.png" width="819"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">此时</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指向</span><span style="color:#25292a;"> 0X91FF00</span><span style="color:#25292a;">，这属于</span><span style="color:#25292a;"> IMX6UL/IMX6ULL </span><span style="color:#25292a;">的内部</span><span style="color:#25292a;"> ram</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">继续回到文件</span><span style="color:#25292a;"> lowlevel_init.S</span><span style="color:#25292a;">，第</span><span style="color:#25292a;"> 23 </span><span style="color:#25292a;">行对</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指针做</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">字节对齐处理！</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 34 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指针减去</span><span style="color:#25292a;"> GD_SIZE</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> GD_SIZE </span><span style="color:#25292a;">同样在</span><span style="color:#25292a;"> generic-asm-offsets.h </span><span style="color:#25292a;">中定了，大小为</span><span style="color:#25292a;">248</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 35 </span><span style="color:#25292a;">行对</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">字节对齐，此时</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">的地址为</span><span style="color:#25292a;"> 0X0091FF00-248=0X0091FE08</span><span style="color:#25292a;">，此时</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">位置如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="509" src="https://images2.imgbox.com/fb/9c/UwyQ9CnY_o.png" width="889"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 36 </span><span style="color:#25292a;">行将</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">地址保存在</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">寄存器中。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 42 </span><span style="color:#25292a;">行将</span><span style="color:#25292a;"> ip </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">压栈</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 57 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> s_init</span><span style="color:#25292a;">，得，又来了一个函数。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 58 </span><span style="color:#25292a;">行将第</span><span style="color:#25292a;"> 36 </span><span style="color:#25292a;">行入栈的</span><span style="color:#25292a;"> ip </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">进行出栈，并将</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">赋给</span><span style="color:#25292a;"> pc</span><span style="color:#25292a;">。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">s_init </span><span style="color:#17252a;">函数详解</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在上一小节中，我们知道</span><span style="color:#25292a;"> lowlevel_init </span><span style="color:#25292a;">函数后面会调用</span><span style="color:#25292a;"> s_init </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;"> s_init </span><span style="color:#25292a;">函数定义在文件</span><br><span style="color:#25292a;">arch/arm/cpu/armv7/mx6/soc.c </span><span style="color:#25292a;">中，如下所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="644" src="https://images2.imgbox.com/8c/0c/9PIe6Vlg_o.png" width="696"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在第</span><span style="color:#25292a;"> 816 </span><span style="color:#25292a;">行会判断当前</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">类型，如果</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> MX6SX</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> MX6UL</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> MX6ULL </span><span style="color:#25292a;">或</span><span style="color:#25292a;"> MX6SLL</span><span style="color:#25292a;">中</span> <span style="color:#25292a;">的</span> <span style="color:#25292a;">任</span> <span style="color:#25292a;">意</span> <span style="color:#25292a;">一</span> <span style="color:#25292a;">种</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">那</span> <span style="color:#25292a;">么</span> <span style="color:#25292a;">就</span> <span style="color:#25292a;">会</span> <span style="color:#25292a;">直</span> <span style="color:#25292a;">接</span> <span style="color:#25292a;">返</span> <span style="color:#25292a;">回</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">相</span> <span style="color:#25292a;">当</span> <span style="color:#25292a;">于</span><span style="color:#25292a;"> s_init </span><span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">什</span> <span style="color:#25292a;">么</span> <span style="color:#25292a;">都</span> <span style="color:#25292a;">没</span> <span style="color:#25292a;">做</span> <span style="color:#25292a;">。</span> <span style="color:#25292a;">所</span> <span style="color:#25292a;">以</span> <span style="color:#25292a;">对</span> <span style="color:#25292a;">于</span><span style="color:#25292a;">I.MX6UL/I.MX6ULL </span><span style="color:#25292a;">来说，</span><span style="color:#25292a;"> s_init </span><span style="color:#25292a;">就是个空函数。从</span><span style="color:#25292a;"> s_init </span><span style="color:#25292a;">函数退出以后进入函数</span><span style="color:#25292a;"> lowlevel_init</span><span style="color:#25292a;">，但是</span><span style="color:#25292a;"> lowlevel_init </span><span style="color:#25292a;">函数也执行完成了，返回到了函数</span><span style="color:#25292a;"> cpu_init_crit</span><span style="color:#25292a;">，函数</span><span style="color:#25292a;"> cpu_init_crit </span><span style="color:#25292a;">也执行完成了，最终返回到</span><span style="color:#25292a;"> save_boot_params_ret</span><span style="color:#25292a;">，函数调用路径如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="311" src="https://images2.imgbox.com/e1/33/ZPqL4T8m_o.png" width="668"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从图中可知，接下来要执行的是</span><span style="color:#25292a;"> save_boot_params_ret </span><span style="color:#25292a;">中的</span><span style="color:#25292a;">_main </span><span style="color:#25292a;">函数，接下来分析</span><span style="color:#25292a;">_main </span><span style="color:#25292a;">函数。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">_main </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">_main </span><span style="color:#25292a;">函数定义在文件</span><span style="color:#25292a;"> arch/arm/lib/crt0.S </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="474" src="https://images2.imgbox.com/af/a3/oQqmFW4w_o.png" width="864"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 76 </span><span style="color:#25292a;">行，设置</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指针为</span><span style="color:#25292a;"> CONFIG_SYS_INIT_SP_ADDR</span><span style="color:#25292a;">，也就是</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">指向</span><span style="color:#25292a;"> 0X0091FF00</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 83 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">字节对齐。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 85 </span><span style="color:#25292a;">行，读取</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">到寄存器</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">里面，此时</span><span style="color:#25292a;"> r0=0X0091FF00</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 86 </span><span style="color:#25292a;">行，调用函数</span><span style="color:#25292a;"> board_init_f_alloc_reserve</span><span style="color:#25292a;">，此函数有一个参数，参数为</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">中的值，也就是</span><span style="color:#25292a;"> 0X0091FF00</span><span style="color:#25292a;">，此函数定义在文件</span><span style="color:#25292a;"> common/init/board_init.c </span><span style="color:#25292a;">中，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="194" src="https://images2.imgbox.com/ed/81/iAvbRFwo_o.png" width="691"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">函数</span><span style="color:#25292a;"> board_init_f_alloc_reserve </span><span style="color:#25292a;">主要是留出早期的</span><span style="color:#25292a;"> malloc </span><span style="color:#25292a;">内存区域和</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">内存区域，其中</span><br><span style="color:#25292a;">CONFIG_SYS_MALLOC_F_LEN=0X400( </span><span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;"> include/generated/autoconf.h </span><span style="color:#25292a;">中</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span><span style="color:#25292a;"> ) </span><span style="color:#25292a;">，</span><span style="color:#25292a;">sizeof(struct global_data)=248(GD_SIZE </span><span style="color:#25292a;">值</span><span style="color:#25292a;">)</span><span style="color:#25292a;">，完成以后的内存分布如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="664" src="https://images2.imgbox.com/0d/db/ufRENwPB_o.png" width="998"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">函数</span><span style="color:#25292a;"> board_init_f_alloc_reserve </span><span style="color:#25292a;">是有返回值的，返回值为新的</span><span style="color:#25292a;"> top </span><span style="color:#25292a;">值，此时</span><span style="color:#25292a;"> top=0X0091FA00</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">继续回到代码中，第</span><span style="color:#25292a;"> 87 </span><span style="color:#25292a;">行，将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">写入到</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">里面，</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">保存着函数</span><span style="color:#25292a;">board_init_f_alloc_reserve </span><span style="color:#25292a;">的返回值，所以这一句也就是设置</span><span style="color:#25292a;"> sp=0X0091FA00</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 89 </span><span style="color:#25292a;">行，将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的值写到寄存器</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">里面，因为</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">寄存器存放着全局变量</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的地址，在文件</span><span style="color:#25292a;"> arch/arm/include/asm/global_data.h </span><span style="color:#25292a;">中有如图所示宏定义：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="155" src="https://images2.imgbox.com/e9/f4/Re9p4GBn_o.png" width="914"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">uboot </span><span style="color:#25292a;">中定义了一个指向</span><span style="color:#25292a;"> gd_t </span><span style="color:#25292a;">的指针</span><span style="color:#25292a;"> gd</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">存放在寄存器</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">里面，因此</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">是个全局变量。</span><span style="color:#25292a;"> gd_t </span><span style="color:#25292a;">是个结构体，在</span><span style="color:#25292a;"> include/asm-generic/global_data.h </span><span style="color:#25292a;">里面有定义。因此这一行代码就是设置</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">所指向的位置，也就是</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">指向</span><span style="color:#25292a;"> 0X0091FA00</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">继续回到代码中，第</span><span style="color:#25292a;"> 90 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> board_init_f_init_reserve</span><span style="color:#25292a;">，此函数在文件</span><span style="color:#25292a;">common/init/board_init.c </span><span style="color:#25292a;">中有定义，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="673" src="https://images2.imgbox.com/ea/01/zxqJbJk6_o.png" width="796"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可以看出，此函数用于初始化</span><span style="color:#25292a;"> gd</span><span style="color:#25292a;">，其实就是清零处理。另外，此函数还设置了</span><span style="color:#25292a;">gd-&gt;malloc_base </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">基地址</span><span style="color:#25292a;">+gd </span><span style="color:#25292a;">大小</span><span style="color:#25292a;">=0X0091FA00+248=0X0091FAF8</span><span style="color:#25292a;">，在做</span><span style="color:#25292a;"> 16 </span><span style="color:#25292a;">字节对齐，最终</span><span style="color:#25292a;"> gd-&gt;malloc_base</span><span style="color:#25292a;">等于</span><span style="color:#25292a;">0X0091FB00</span><span style="color:#25292a;">，这个也就是</span><span style="color:#25292a;"> early malloc </span><span style="color:#25292a;">的起始地址。</span></span></p> 
<p style="margin-left:0;text-align:left;"><br><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续回到代码中，第</span><span style="color:#25292a;"> 92 </span><span style="color:#25292a;">行设置</span><span style="color:#25292a;"> R0 </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 93 </span><span style="color:#25292a;">行，调用</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">函数，此函数定义在文件</span><span style="color:#25292a;"> common/board_f.c </span><span style="color:#25292a;">中！主要用来初始</span><br><span style="color:#25292a;">化</span><span style="color:#25292a;"> DDR</span><span style="color:#25292a;">，定时器，完成代码拷贝等等，此函数我们后面在详细的分析。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="648" src="https://images2.imgbox.com/0e/9e/no29YqFs_o.png" width="757"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 103 </span><span style="color:#25292a;">行，重新设置环境</span><span style="color:#25292a;">(sp </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> gd)</span><span style="color:#25292a;">、获取</span><span style="color:#25292a;"> gd-&gt;start_addr_sp </span><span style="color:#25292a;">的值赋给</span><span style="color:#25292a;"> sp</span><span style="color:#25292a;">，在函数</span><span style="color:#25292a;"> board_init_f</span><span style="color:#25292a;">中会初始化</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的所有成员变量，其中</span><span style="color:#25292a;"> gd-&gt;start_addr_sp=0X9EF44E90</span><span style="color:#25292a;">，</span> <span style="color:#25292a;">所以这里相当于设置</span><br><span style="color:#25292a;">sp=gd-&gt;start_addr_sp=0X9EF44E90</span><span style="color:#25292a;">。</span><span style="color:#25292a;"> 0X9EF44E90 </span><span style="color:#25292a;">是</span><span style="color:#25292a;"> DDR </span><span style="color:#25292a;">中的地址，说明新的</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">将会存放到</span><span style="color:#25292a;"> DDR </span><span style="color:#25292a;">中，而不是内部的</span><span style="color:#25292a;"> RAM </span><span style="color:#25292a;">了。</span><span style="color:#25292a;"> GD_START_ADDR_SP=64</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 109 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">字节对齐。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 111 </span><span style="color:#25292a;">行，获取</span><span style="color:#25292a;"> gd-&gt;bd </span><span style="color:#25292a;">的地址赋给</span><span style="color:#25292a;"> r9</span><span style="color:#25292a;">，此时</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">存放的是老的</span><span style="color:#25292a;"> gd</span><span style="color:#25292a;">，这里通过获取</span><span style="color:#25292a;"> gd-&gt;bd </span><span style="color:#25292a;">的</span><br><span style="color:#25292a;">地址来计算出新的</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的位置。</span><span style="color:#25292a;"> GD_BD=0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 112 </span><span style="color:#25292a;">行，新的</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">在</span><span style="color:#25292a;"> bd </span><span style="color:#25292a;">下面，所以</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">减去</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的大小就是新的</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的位置，获取到新的</span><span style="color:#25292a;"> gd</span><span style="color:#25292a;">的位置以后赋值给</span><span style="color:#25292a;"> r9</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 114 </span><span style="color:#25292a;">行，设置</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">寄存器为</span><span style="color:#25292a;"> here</span><span style="color:#25292a;">，这样后面执行其他函数返回的时候就返回到了第</span><span style="color:#25292a;"> 122 </span><span style="color:#25292a;">行的</span><span style="color:#25292a;"> here </span><span style="color:#25292a;">位置处。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 115</span><span style="color:#25292a;">，读取</span><span style="color:#25292a;"> gd-&gt;reloc_off </span><span style="color:#25292a;">的值复制给</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器，</span><span style="color:#25292a;"> GD_RELOC_OFF=68</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 116 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">寄存器的值加上</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器的值，重新赋值给</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">寄存器。因为接下来要重定位代码，也就是把代码拷贝到新的地方去</span><span style="color:#25292a;">(</span><span style="color:#25292a;">现在的</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">存放的起始地址为</span><span style="color:#25292a;"> 0X87800000</span><span style="color:#25292a;">，下面要将</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">拷贝到</span><span style="color:#25292a;"> DDR </span><span style="color:#25292a;">最后面的地址空间，将</span><span style="color:#25292a;"> 0X87800000 </span><span style="color:#25292a;">开始的内存空出来</span><span style="color:#25292a;">)</span><span style="color:#25292a;">，其中就包括</span><span style="color:#25292a;">here</span><span style="color:#25292a;">，因此</span><span style="color:#25292a;"> lr </span><span style="color:#25292a;">中的</span><span style="color:#25292a;"> here </span><span style="color:#25292a;">要使用重定位后的位置。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 120 </span><span style="color:#25292a;">行，读取</span><span style="color:#25292a;"> gd-&gt;relocaddr </span><span style="color:#25292a;">的值赋给</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器，此时</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">寄存器就保存着</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">要拷贝的目的地址，为</span><span style="color:#25292a;"> 0X9FF47000</span><span style="color:#25292a;">。</span><span style="color:#25292a;"> GD_RELOCADDR=48</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 121 </span><span style="color:#25292a;">行，调用函数</span><span style="color:#25292a;"> relocate_code</span><span style="color:#25292a;">，也就是代码重定位函数，此函数负责将</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">拷贝到新的地方去，此函数定义在文件</span><span style="color:#25292a;"> arch/arm/lib/relocate.S </span><span style="color:#25292a;">中稍后会详细分析此函数。</span><br><span style="color:#25292a;">继续回到代码第</span><span style="color:#25292a;"> 127 </span><span style="color:#25292a;">行，调用函数</span><span style="color:#25292a;"> relocate_vectors</span><span style="color:#25292a;">，对中断向量表做重定位，此函数定义在文件</span><span style="color:#25292a;"> arch/arm/lib/relocate.S </span><span style="color:#25292a;">中，稍后会详细分析此函数。</span><br><span style="color:#25292a;">继续回到代码第</span><span style="color:#25292a;"> 131 </span><span style="color:#25292a;">行，调用函数</span><span style="color:#25292a;"> c_runtime_cpu_setup</span><span style="color:#25292a;">，此函数定义在文件</span><span style="color:#25292a;">arch/arm/cpu/armv7/start.S </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="260" src="https://images2.imgbox.com/4d/a9/3vyIraht_o.png" width="860"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">关闭</span><span style="color:#25292a;">I-cache</span><span style="color:#25292a;">。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="804" src="https://images2.imgbox.com/be/2a/8vB0LtyZ_o.png" width="645"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 141~159 </span><span style="color:#25292a;">行，清除</span><span style="color:#25292a;"> BSS </span><span style="color:#25292a;">段。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 167 </span><span style="color:#25292a;">行，设置函数</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">的两个参数，函数</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">声明如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">board_init_r(gd_t *id, ulong dest_addr)</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第一个参数是</span><span style="color:#25292a;"> gd</span><span style="color:#25292a;">，因此读取</span><span style="color:#25292a;"> r9 </span><span style="color:#25292a;">保存到</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">里面。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 168 </span><span style="color:#25292a;">行，设置函数</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">的第二个参数是目的地址，因此</span><span style="color:#25292a;"> r1= gd-&gt;relocaddr</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 174 </span><span style="color:#25292a;">行、调用函数</span><span style="color:#25292a;"> board_init_r</span><span style="color:#25292a;">，此函数定义在文件</span><span style="color:#25292a;"> common/board_r.c </span><span style="color:#25292a;">中，稍后会详细的分析此函数。</span><br><span style="color:#25292a;">这个就是</span><span style="color:#25292a;">_main </span><span style="color:#25292a;">函数的运行流程，在</span><span style="color:#25292a;">_main </span><span style="color:#25292a;">函数里面调用了</span><span style="color:#25292a;"> board_init_f</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> relocate_code</span><span style="color:#25292a;">、</span><span style="color:#25292a;">relocate_vectors </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">这</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">个函数，接下来依次看一下这</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">个函数都是干啥的。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">board_init_f </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">main </span><span style="color:#25292a;">中会调用</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">函数主要有两个工作：</span><br><span style="color:#25292a;">①</span><span style="color:#25292a;">、初始化一系列外设，比如串口、定时器，或者打印一些消息等。</span><br><span style="color:#25292a;">②</span><span style="color:#25292a;">、初始化</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的各个成员变量，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">会将自己重定位到</span><span style="color:#25292a;"> DRAM </span><span style="color:#25292a;">最后面的地址区域，也就是将自己拷贝到</span><span style="color:#25292a;"> DRAM </span><span style="color:#25292a;">最后面的内存区域中。这么做的目的是给</span><span style="color:#25292a;"> Linux </span><span style="color:#25292a;">腾出空间，防止</span><span style="color:#25292a;"> Linux kernel </span><span style="color:#25292a;">覆盖掉</span><span style="color:#25292a;"> uboot</span><span style="color:#25292a;">，将</span><span style="color:#25292a;"> DRAM </span><span style="color:#25292a;">前面的区域完整的空出来。在拷贝之前肯定要给</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">各部分分配好内存位置和大小，比如</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">应该存放到哪个位置，</span><span style="color:#25292a;"> malloc </span><span style="color:#25292a;">内存池应该存放到哪个位置等等。这些信息都保存在</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的成员变量中，因此要对</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的这些成员变量做初始化。最终形成一个完整的内存</span><span style="color:#25292a;">“</span><span style="color:#25292a;">分配图</span><span style="color:#25292a;">”</span><span style="color:#25292a;">，在后面重定位</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的时候就会用到这个内存</span><span style="color:#25292a;">“</span><span style="color:#25292a;">分配图</span><span style="color:#25292a;">”</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">此函数定义在文件</span><span style="color:#25292a;"> common/board_f.c </span><span style="color:#25292a;">中定义，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="574" src="https://images2.imgbox.com/58/81/ge9NigxP_o.png" width="768"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">因为没有定义</span><span style="color:#25292a;">CONFIG_SYS_GENERIC_GLOBAL_DATA</span><span style="color:#25292a;">，所以第</span><span style="color:#25292a;">1037~1054</span><span style="color:#25292a;">行代码无效。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1056 </span><span style="color:#25292a;">行，初始化</span><span style="color:#25292a;"> gd-&gt;flags=boot_flags=0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1057 </span><span style="color:#25292a;">行，设置</span><span style="color:#25292a;"> gd-&gt;have_console=0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">重点在第</span><span style="color:#25292a;"> 1059 </span><span style="color:#25292a;">行！通过函数</span><span style="color:#25292a;"> initcall_run_list </span><span style="color:#25292a;">来运行初始化序列</span><span style="color:#25292a;"> init_sequence_f </span><span style="color:#25292a;">里面的一些列函数，</span><span style="color:#25292a;"> init_sequence_f </span><span style="color:#25292a;">里面包含了一系列的初始化函数，</span><span style="color:#25292a;"> init_sequence_f </span><span style="color:#25292a;">也是定义在文件</span><span style="color:#25292a;">common/board_f.c </span><span style="color:#25292a;">中，</span><span style="color:#25292a;"> init_sequence_f </span><span style="color:#25292a;">定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="631" src="https://images2.imgbox.com/f1/04/3Np8qHif_o.png" width="738"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 833</span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> setup_mon_len </span><span style="color:#25292a;">函数设置</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> mon_len </span><span style="color:#25292a;">成员变量，此处为</span><span style="color:#25292a;">__bss_end -_start</span><span style="color:#25292a;">，也就是整个代码的长度。</span><span style="color:#25292a;"> 0X878A8E74-0x87800000=0XA8E74</span><span style="color:#25292a;">，这个就是代码长度。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 840 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initf_malloc </span><span style="color:#25292a;">函数初始化</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">中跟</span><span style="color:#25292a;"> malloc </span><span style="color:#25292a;">有关的成员变量，比如</span><span style="color:#25292a;"> malloc_limit</span><span style="color:#25292a;">，此函数会设置</span><span style="color:#25292a;"> gd-&gt;malloc_limit = CONFIG_SYS_MALLOC_F_LEN=0X400</span><span style="color:#25292a;">。</span><span style="color:#25292a;"> malloc_limit </span><span style="color:#25292a;">表示</span><span style="color:#25292a;"> malloc</span><span style="color:#25292a;">内存池大小。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 841 </span><span style="color:#25292a;">行</span> <span style="color:#25292a;">，</span><span style="color:#25292a;"> initf_console_record </span><span style="color:#25292a;">，</span> <span style="color:#25292a;">如</span> <span style="color:#25292a;">果</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span> <span style="color:#25292a;">了</span> <span style="color:#25292a;">宏</span><span style="color:#25292a;"> CONFIG_CONSOLE_RECORD </span><span style="color:#25292a;">和</span> <span style="color:#25292a;">宏</span><br><span style="color:#25292a;">CONFIG_SYS_MALLOC_F_LEN </span><span style="color:#25292a;">的话此函数就会调用函数</span><span style="color:#25292a;"> console_record_init</span><span style="color:#25292a;">，但是</span><span style="color:#25292a;"> IMX6ULL</span><span style="color:#25292a;">的</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">没有定义宏</span><span style="color:#25292a;"> CONFIG_CONSOLE_RECORD</span><span style="color:#25292a;">，所以此函数直接返回</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 849 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> arch_cpu_init </span><span style="color:#25292a;">函数。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 850 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initf_dm </span><span style="color:#25292a;">函数，驱动模型的一些初始化。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 851 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> arch_cpu_init_dm </span><span style="color:#25292a;">函数未实现。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 852 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> mark_bootstage </span><span style="color:#25292a;">函数应该是和啥标记有关的</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 854 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> board_early_init_f </span><span style="color:#25292a;">函数，板子相关的早期的一些初始化设置，</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">用来初始化串口的</span><span style="color:#25292a;"> IO </span><span style="color:#25292a;">配置。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="665" src="https://images2.imgbox.com/cd/9a/cn9wA8Uk_o.png" width="756"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 869 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> timer_init</span><span style="color:#25292a;">，初始化定时器，</span><span style="color:#25292a;"> Cortex-A7 </span><span style="color:#25292a;">内核有一个定时器，这里初始化的就是</span><span style="color:#25292a;"> CortexA </span><span style="color:#25292a;">内核的那个定时器。通过这个定时器来为</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">提供时间。就跟</span><span style="color:#25292a;"> Cortex-M </span><span style="color:#25292a;">内核</span><span style="color:#25292a;"> Systick </span><span style="color:#25292a;">定时器一样。关于</span><span style="color:#25292a;"> Cortex-A </span><span style="color:#25292a;">内部定时器的详细内容，请参考文档《</span><span style="color:#25292a;">ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</span><span style="color:#25292a;">》</span> <span style="color:#25292a;">的</span><span style="color:#25292a;">“Chapter B8 The Generic Timer”</span><span style="color:#25292a;">章节。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 877 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> board_postclk_init</span><span style="color:#25292a;">，对于</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">来说是设置</span><span style="color:#25292a;"> VDDSOC </span><span style="color:#25292a;">电压。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 880 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> get_clocks </span><span style="color:#25292a;">函数用于获取一些时钟值，</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">获取的是</span><span style="color:#25292a;"> sdhc_clk </span><span style="color:#25292a;">时钟，也就是</span><span style="color:#25292a;"> SD </span><span style="color:#25292a;">卡外设的时钟。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 882 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> env_init </span><span style="color:#25292a;">函数是和环境变量有关的，设置</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的成员变量</span><span style="color:#25292a;"> env_addr</span><span style="color:#25292a;">，也就是环境变量的保存地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 890 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> init_baud_rate </span><span style="color:#25292a;">函数用于初始化波特率，根据环境变量</span><span style="color:#25292a;"> baudrate </span><span style="color:#25292a;">来初始化</span><span style="color:#25292a;"> gd-&gt;baudrate</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 891 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> serial_init</span><span style="color:#25292a;">，初始化串口。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 892 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> console_init_f</span><span style="color:#25292a;">，设置</span><span style="color:#25292a;"> gd-&gt;have_console </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 1</span><span style="color:#25292a;">，表示有个控制台，此函数也将前面暂存在缓冲区中的数据通过控制台打印出来。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 899 </span><span style="color:#25292a;">行、</span><span style="color:#25292a;"> display_options</span><span style="color:#25292a;">，通过串口输出一些信息，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="60" src="https://images2.imgbox.com/9f/db/qNOyTG9Q_o.png" width="732"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 900 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> display_text_info</span><span style="color:#25292a;">，打印一些文本信息，如果开启</span><span style="color:#25292a;"> UBOOT </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> DEBUG </span><span style="color:#25292a;">功能的话就会输出</span><span style="color:#25292a;"> text_base</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> bss_start</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> bss_end</span><span style="color:#25292a;">，形式如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">debug("U-Boot code: %08lX -&gt; %08lX BSS: -&gt; %08lX\n",text_base, bss_start, bss_end);</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="203" src="https://images2.imgbox.com/2f/b6/Eq7jnWpk_o.png" width="927"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续初始化序列：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="660" src="https://images2.imgbox.com/5e/1e/9bCCWGgY_o.png" width="842"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 911 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> print_cpuinfo </span><span style="color:#25292a;">函数用于打印</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">信息，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="79" src="https://images2.imgbox.com/67/a4/K9vbKBQ3_o.png" width="882"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 916 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> show_board_info </span><span style="color:#25292a;">函数用于打印板子信息，会调用</span><span style="color:#25292a;"> checkboard </span><span style="color:#25292a;">函数，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="137" src="https://images2.imgbox.com/e2/2c/qvy7ln7v_o.png" width="753"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 918 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> INIT_FUNC_WATCHDOG_INIT</span><span style="color:#25292a;">，初始化看门狗，对于</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">来说是空函数</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 922 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> INIT_FUNC_WATCHDOG_RESET</span><span style="color:#25292a;">，复位看门狗，对于</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">来说是空函数</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 924 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> init_func_i2c </span><span style="color:#25292a;">函数用于初始化</span><span style="color:#25292a;"> I2C</span><span style="color:#25292a;">，初始化完成以后会输出如图所示信息：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="149" src="https://images2.imgbox.com/e0/8b/PkaYEHEu_o.png" width="506"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 929 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> announce_dram_init</span><span style="color:#25292a;">，此函数很简单，就是输出字符串</span><span style="color:#25292a;">“DRAM:”</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 933 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> dram_init</span><span style="color:#25292a;">，并非真正的初始化</span><span style="color:#25292a;"> DDR</span><span style="color:#25292a;">，只是设置</span><span style="color:#25292a;"> gd-&gt;ram_size </span><span style="color:#25292a;">的值，对于正点原子</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">开发板</span><span style="color:#25292a;"> EMMC </span><span style="color:#25292a;">版本核心板来说就是</span><span style="color:#25292a;"> 512MB</span><span style="color:#25292a;">。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续初始化序列：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="660" src="https://images2.imgbox.com/37/cd/BcMxKk3G_o.png" width="933"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 939 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> post_init_f</span><span style="color:#25292a;">，此函数用来完成一些测试，初始化</span><span style="color:#25292a;"> gd-&gt;post_init_f_time</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 943 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> testdram</span><span style="color:#25292a;">，测试</span><span style="color:#25292a;"> DRAM</span><span style="color:#25292a;">，空函数。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 963 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> setup_dest_addr</span><span style="color:#25292a;">函数，设置目的地址，设置</span><span style="color:#25292a;">gd-&gt;ram_size</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> gd-&gt;ram_top</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> gd-&gt;relocaddr</span><span style="color:#25292a;">这三个的值。接下来我们会遇到很多跟数值有关的设置，如果直接看代码分析的话就太费时间了，我可以修改</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">代码，直接将这些值通过串口打印出来，比如这里我们修改文件</span><span style="color:#25292a;">common/board_f.c</span><span style="color:#25292a;">，因为</span><span style="color:#25292a;"> setup_dest_addr </span><span style="color:#25292a;">函数定义在文件</span><span style="color:#25292a;"> common/board_f.c </span><span style="color:#25292a;">中，在</span><span style="color:#25292a;">setup_dest_addr</span><span style="color:#25292a;">函数输入如图所示内容：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="558" src="https://images2.imgbox.com/4d/f1/ZQM8MT0w_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">设置好以后重新编译</span><span style="color:#25292a;"> uboot</span><span style="color:#25292a;">，然后烧写到</span><span style="color:#25292a;"> SD </span><span style="color:#25292a;">卡中，选择</span><span style="color:#25292a;"> SD </span><span style="color:#25292a;">卡启动，重启开发板，打开</span><span style="color:#25292a;">SecureCRT</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">会输出如图所示信息：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="57" src="https://images2.imgbox.com/1d/b4/Yp8ViscZ_o.png" width="700"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="782" src="https://images2.imgbox.com/84/da/6mID4d1z_o.png" width="921"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 977 </span><span style="color:#25292a;">行</span> <span style="color:#25292a;">，</span><span style="color:#25292a;"> reserve_round_4k </span><span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">用</span> <span style="color:#25292a;">于</span> <span style="color:#25292a;">对</span><span style="color:#25292a;"> gd-&gt;relocaddr </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 4KB </span><span style="color:#25292a;">对</span> <span style="color:#25292a;">齐</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">因</span> <span style="color:#25292a;">为</span><br><span style="color:#25292a;">gd-&gt;relocaddr=0XA0000000</span><span style="color:#25292a;">，已经是</span><span style="color:#25292a;"> 4K </span><span style="color:#25292a;">对齐了，所以调整后不变。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 980 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_mmu</span><span style="color:#25292a;">，留出</span><span style="color:#25292a;"> MMU </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> TLB </span><span style="color:#25292a;">表的位置，分配</span><span style="color:#25292a;"> MMU </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> TLB </span><span style="color:#25292a;">表内存以后会对</span><span style="color:#25292a;"> gd-&gt;relocaddr </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 64K </span><span style="color:#25292a;">字节对齐。完成以后</span><span style="color:#25292a;"> gd-&gt;arch.tlb_size</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> gd-&gt;arch.tlb_addr </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> gd-&gt;relocaddr</span><span style="color:#25292a;">如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="73" src="https://images2.imgbox.com/df/a2/Q2f06RcH_o.png" width="703"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 995 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_trace </span><span style="color:#25292a;">函数，留出跟踪调试的内存，</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">没有用到！</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 997 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_uboot</span><span style="color:#25292a;">，</span> <span style="color:#25292a;">留出重定位后的</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">所占用的内存区域，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">所占用大小由</span><br><span style="color:#25292a;">gd-&gt;mon_len </span><span style="color:#25292a;">所指定，留出</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的空间以后还要对</span><span style="color:#25292a;"> gd-&gt;relocaddr </span><span style="color:#25292a;">做</span><span style="color:#25292a;"> 4K </span><span style="color:#25292a;">字节对齐，并且重新设</span><br><span style="color:#25292a;">置</span><span style="color:#25292a;"> gd-&gt;start_addr_sp</span><span style="color:#25292a;">，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1000 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_malloc</span><span style="color:#25292a;">，留出</span><span style="color:#25292a;"> malloc </span><span style="color:#25292a;">区域，调整</span><span style="color:#25292a;"> gd-&gt;start_addr_sp </span><span style="color:#25292a;">位置，</span><span style="color:#25292a;"> malloc </span><span style="color:#25292a;">区域由宏</span><br><span style="color:#25292a;">TOTAL_MALLOC_LEN </span><span style="color:#25292a;">定义，宏定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">#define TOTAL_MALLOC_LEN (CONFIG_SYS_MALLOC_LEN +CONFIG_ENV_SIZE)</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">mx6ull_alientek_emmc.h </span><span style="color:#25292a;">文件中定义宏</span><span style="color:#25292a;"> CONFIG_SYS_MALLOC_LEN </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 16MB=0X1000000</span><span style="color:#25292a;">，</span><br><span style="color:#25292a;">宏</span><span style="color:#25292a;"> CONFIG_ENV_SIZE=8KB=0X2000</span><span style="color:#25292a;">，因此</span><span style="color:#25292a;"> TOTAL_MALLOC_LEN=0X1002000</span><span style="color:#25292a;">。调整以后</span><br><span style="color:#25292a;">gd-&gt;start_addr_sp </span><span style="color:#25292a;">如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="52" src="https://images2.imgbox.com/4f/9f/6cfmE7UN_o.png" width="654"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1001 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_board </span><span style="color:#25292a;">函数，留出板子</span><span style="color:#25292a;"> bd </span><span style="color:#25292a;">所占的内存区，</span><span style="color:#25292a;"> bd </span><span style="color:#25292a;">是结构体</span><span style="color:#25292a;"> bd_t</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> bd_t </span><span style="color:#25292a;">大小为</span><span style="color:#25292a;">80 </span><span style="color:#25292a;">字节，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="52" src="https://images2.imgbox.com/81/f6/cMbHWlKU_o.png" width="641"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1003 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> setup_machine</span><span style="color:#25292a;">，设置机器</span><span style="color:#25292a;"> ID</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> linux </span><span style="color:#25292a;">启动的时候会和这个机器</span><span style="color:#25292a;"> ID </span><span style="color:#25292a;">匹配，如果匹配的话</span><span style="color:#25292a;"> linux </span><span style="color:#25292a;">就会启动正常。但是</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">不用这种方式了，这是以前老版本的</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">和</span><span style="color:#25292a;">linux </span><span style="color:#25292a;">使用的，新版本使用设备树了，因此此函数无效。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1004 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_global_data </span><span style="color:#25292a;">函数，保留出</span><span style="color:#25292a;"> gd_t </span><span style="color:#25292a;">的内存区域，</span><span style="color:#25292a;"> gd_t </span><span style="color:#25292a;">结构体大小为</span><span style="color:#25292a;"> 248B</span><span style="color:#25292a;">，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="48" src="https://images2.imgbox.com/3c/36/LGNdVwQO_o.png" width="643"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1005 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_fdt</span><span style="color:#25292a;">，留出设备树相关的内存区域，</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">没有用到，因此此函数无效。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1006 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_arch </span><span style="color:#25292a;">是个空函数。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1007 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reserve_stacks</span><span style="color:#25292a;">，留出栈空间，先对</span><span style="color:#25292a;"> gd-&gt;start_addr_sp </span><span style="color:#25292a;">减去</span><span style="color:#25292a;"> 16</span><span style="color:#25292a;">，然后做</span><span style="color:#25292a;"> 16 </span><span style="color:#25292a;">字节对齐。如果使能</span><span style="color:#25292a;"> IRQ </span><span style="color:#25292a;">的话还要留出</span><span style="color:#25292a;"> IRQ </span><span style="color:#25292a;">相应的内存，具体工作是由</span><span style="color:#25292a;"> arch/arm/lib/stack.c </span><span style="color:#25292a;">文件中的函数</span><span style="color:#25292a;"> arch_reserve_stacks </span><span style="color:#25292a;">完成。结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="27" src="https://images2.imgbox.com/6e/94/QcnvNu2A_o.png" width="598"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在本</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中并没有使用到</span><span style="color:#25292a;"> IRQ</span><span style="color:#25292a;">，所以不会留出</span><span style="color:#25292a;"> IRQ </span><span style="color:#25292a;">相应的内存区域。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1008 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> setup_dram_config </span><span style="color:#25292a;">函数设置</span><span style="color:#25292a;"> dram </span><span style="color:#25292a;">信息，就是设置</span><span style="color:#25292a;"> gd-&gt;bd-&gt;bi_dram[0].start </span><span style="color:#25292a;">和</span><br><span style="color:#25292a;">gd-&gt;bd-&gt;bi_dram[0].size</span><span style="color:#25292a;">，后面会传递给</span><span style="color:#25292a;"> linux </span><span style="color:#25292a;">内核，告诉</span><span style="color:#25292a;"> linux DRAM </span><span style="color:#25292a;">的起始地址和大小。结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="47" src="https://images2.imgbox.com/dc/4d/6fbNWyLT_o.png" width="596"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1009 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> show_dram_config </span><span style="color:#25292a;">函数，用于显示</span><span style="color:#25292a;"> DRAM </span><span style="color:#25292a;">的配置，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="79" src="https://images2.imgbox.com/e0/16/pqa1ww6v_o.png" width="644"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">继续：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="504" src="https://images2.imgbox.com/5e/27/8pIExbNQ_o.png" width="837"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1017 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> display_new_sp </span><span style="color:#25292a;">函数，显示新的</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">位置，也就是</span><span style="color:#25292a;"> gd-&gt;start_addr_sp</span><span style="color:#25292a;">，不过要定义宏</span><span style="color:#25292a;"> DEBUG</span><span style="color:#25292a;">，结果如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="173" src="https://images2.imgbox.com/41/8a/FTnhtw7D_o.png" width="563"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">图中的</span><span style="color:#25292a;"> gd-&gt;start_addr_sp </span><span style="color:#25292a;">值和我们前面分析的最后一次修改的值一致。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1022 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> reloc_fdt </span><span style="color:#25292a;">函数用于重定位</span><span style="color:#25292a;"> fdt</span><span style="color:#25292a;">，没有用到。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1023 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> setup_reloc</span><span style="color:#25292a;">，设置</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的其他一些成员变量，供后面重定位的时候使用，并且将以前的</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">拷贝到</span><span style="color:#25292a;"> gd-&gt;new_gd </span><span style="color:#25292a;">处。需要使能</span><span style="color:#25292a;"> DEBUG </span><span style="color:#25292a;">才能看到相应的信息输出，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="63" src="https://images2.imgbox.com/4c/7b/JvsmmWRi_o.png" width="830"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从图中可以看出，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">重定位后的偏移为</span><span style="color:#25292a;"> 0X18747000</span><span style="color:#25292a;">，重定位后的新地址为</span><span style="color:#25292a;">0X9FF4700</span><span style="color:#25292a;">，新的</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">首地址为</span><span style="color:#25292a;"> 0X9EF44EB8</span><span style="color:#25292a;">，最终的</span><span style="color:#25292a;"> sp </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 0X9EF44E90</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">至此，</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">函数就执行完成了，最终的内存分配如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="884" src="https://images2.imgbox.com/70/01/NI6wiX0w_o.png" width="847"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">relocate_code </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">relocate_code </span><span style="color:#25292a;">函数是用于代码拷贝的，此函数定义在文件</span><span style="color:#25292a;"> arch/arm/lib/relocate.S </span><span style="color:#25292a;">中，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="836" src="https://images2.imgbox.com/32/16/3jVnddNp_o.png" width="917"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 80 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r1=__image_copy_start</span><span style="color:#25292a;">，也就是</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">寄存器保存源地址，</span><span style="color:#25292a;">__image_copy_start=0X87800000</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 81 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r0=0X9FF47000</span><span style="color:#25292a;">，这个地址就是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">拷贝的目标首地址。</span><span style="color:#25292a;"> r4=r0-r1=0X9FF47000-0X87800000=0X18747000</span><span style="color:#25292a;">，因此</span><span style="color:#25292a;"> r4 </span><span style="color:#25292a;">保存偏移量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 82 </span><span style="color:#25292a;">行，如果在第</span><span style="color:#25292a;"> 81 </span><span style="color:#25292a;">中，</span><span style="color:#25292a;"> r0-r1 </span><span style="color:#25292a;">等于</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">，说明</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">相等，也就是源地址和目的地址是</span><br><span style="color:#25292a;">一样的，那肯定就不需要拷贝了！执行</span><span style="color:#25292a;"> relocate_done </span><span style="color:#25292a;">函数</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 83 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r2=__image_copy_end</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> r2 </span><span style="color:#25292a;">中保存拷贝之前的代码结束地址</span><span style="color:#25292a;">__image_copy_end =0x8785dd54</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 84 </span><span style="color:#25292a;">行，函数</span><span style="color:#25292a;"> copy_loop </span><span style="color:#25292a;">完成代码拷贝工作！从</span><span style="color:#25292a;"> r1</span><span style="color:#25292a;">，也就是</span><span style="color:#25292a;">__image_copy_start </span><span style="color:#25292a;">开始，读取</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">代码保存到</span><span style="color:#25292a;"> r10 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r11 </span><span style="color:#25292a;">中，一次就只拷贝这</span><span style="color:#25292a;"> 2 </span><span style="color:#25292a;">个</span><span style="color:#25292a;"> 32 </span><span style="color:#25292a;">位的数据。拷贝完成以后</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">的值会更新，保存下一个要拷贝的数据地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 87 </span><span style="color:#25292a;">行，将</span><span style="color:#25292a;"> r10 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r11 </span><span style="color:#25292a;">的数据写到</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">开始的地方，也就是目的地址。写完以后</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">的值会更新，更新为下一个要写入的数据地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 88 </span><span style="color:#25292a;">行，比较</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">是否和</span><span style="color:#25292a;"> r2 </span><span style="color:#25292a;">相等，也就是检查是否拷贝完成，如果不相等的话说明没有拷贝完成，</span> <span style="color:#25292a;">没有拷贝完成的话就跳转到</span><span style="color:#25292a;"> copy_loop </span><span style="color:#25292a;">接着拷贝，直至拷贝完成。</span><br><span style="color:#25292a;">接下来的第</span><span style="color:#25292a;"> 94 </span><span style="color:#25292a;">行</span><span style="color:#25292a;">~109 </span><span style="color:#25292a;">行是重定位</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段，</span><span style="color:#25292a;"> .rel.dyn </span><span style="color:#25292a;">段是存放</span><span style="color:#25292a;">.text </span><span style="color:#25292a;">段中需要重定位地址的集合。重定位就是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">将自身拷贝到</span><span style="color:#25292a;"> DRAM </span><span style="color:#25292a;">的另一个地放去继续运行</span><span style="color:#25292a;">(DRAM </span><span style="color:#25292a;">的高地址处</span><span style="color:#25292a;">)</span><span style="color:#25292a;">。我们知道，一个可执行的</span><span style="color:#25292a;"> bin </span><span style="color:#25292a;">文件，其链接地址和运行地址要相等，也就是链接到哪个地址，在运行之前就要拷贝到哪个地址去。现在我们重定位以后，运行地址就和链接地址不同了，这样寻址的时候不会出问题吗？</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">uboot </span><span style="color:#25292a;">对于重定位后链接地址和运行地址不一致的解决方法就是采用位置无关码，在使用</span><span style="color:#25292a;"> ld </span><span style="color:#25292a;">进行链接的时候使用选项</span><span style="color:#25292a;">“ -pie”</span><span style="color:#25292a;">生成位置无关的可执行文件。在文件</span><span style="color:#25292a;">arch/arm/config.mk </span><span style="color:#25292a;">下有如下代码：</span></span></p> 
<pre><code class="hljs"># needed for relocation

LDFLAGS_u-boot += -pie</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">使用</span><span style="color:#25292a;">“-pie”</span><span style="color:#25292a;">选项以后会生成一个</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">就是靠这个</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">来解决重定位问题的，在</span><span style="color:#25292a;"> u-bot.dis </span><span style="color:#25292a;">的</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段中有如下所示内容：</span></span></p> 
<pre><code class="hljs">Disassembly of section .rel.dyn：

8785da44 &lt;__rel_dyn_end-0x8ba0&gt;:

8785da44: 87800020 strhi r0, [r0, r0, lsr #32]

8785da48: 00000017 andeq r0, r0, r7, lsl r0

......

8785dfb4: 87804198 ; &lt;UNDEFINED&gt; instruction: 0x87804198

8785dfb8: 00000017 andeq r0, r0, r7, lsl r0</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">先来看一下</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段的格式，类似第</span><span style="color:#25292a;"> 7 </span><span style="color:#25292a;">行和第</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">行这样的是一组，也就是两个</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节数据为一组。高</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节是</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">地址标识</span><span style="color:#25292a;"> 0X17</span><span style="color:#25292a;">，低</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节就是</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">的地址，首先判断</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">地址标识是否正确，也就是判断高</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节是否为</span><span style="color:#25292a;"> 0X17</span><span style="color:#25292a;">，如果是的话低</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节就是</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">地址值。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 7 </span><span style="color:#25292a;">行值为</span><span style="color:#25292a;"> 0X87804198</span><span style="color:#25292a;">，第</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">行为</span><span style="color:#25292a;"> 0X00000017</span><span style="color:#25292a;">，说明第</span><span style="color:#25292a;"> 7 </span><span style="color:#25292a;">行的</span><span style="color:#25292a;"> 0X87804198 </span><span style="color:#25292a;">是个</span><span style="color:#25292a;"> Label</span><span style="color:#25292a;">，根据前面的分析，只要将地址</span><span style="color:#25292a;">0X87804198+offset </span><span style="color:#25292a;">处的值改为重定位后的地址即可。我们猜测的是否正确，看一下</span><br><span style="color:#25292a;">uboot </span><span style="color:#25292a;">对</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段的重定位即可</span><span style="color:#25292a;"> .rel.dyn </span><span style="color:#25292a;">段的重定位代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="608" src="https://images2.imgbox.com/46/9f/BHzHzwMn_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 94 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r2=__rel_dyn_start</span><span style="color:#25292a;">，也就是</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段的起始地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 95 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r3=__rel_dyn_end</span><span style="color:#25292a;">，也就是</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段的终止地址。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 97 </span><span style="color:#25292a;">行，从</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段起始地址开始，每次读取两个</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节的数据存放到</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">寄存器中，</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">存放低</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节的数据，也就是</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">地址；</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">存放高</span><span style="color:#25292a;"> 4 </span><span style="color:#25292a;">字节的数据，也就是</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">标志。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 98 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">中给的值与</span><span style="color:#25292a;"> 0xff </span><span style="color:#25292a;">进行与运算，其实就是取</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">的低</span><span style="color:#25292a;"> 8 </span><span style="color:#25292a;">位。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 99 </span><span style="color:#25292a;">行，判断</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">中的值是否等于</span><span style="color:#25292a;"> 23(0X17)</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 100 </span><span style="color:#25292a;">行，如果</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">不等于</span><span style="color:#25292a;"> 23 </span><span style="color:#25292a;">的话就说明不是描述</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">的，执行函数</span><span style="color:#25292a;"> fixnext</span><span style="color:#25292a;">，否则的话继续执行下面的代码。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 103 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">保存着</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">值，</span><span style="color:#25292a;"> r4 </span><span style="color:#25292a;">保存着重定位后的地址偏移，</span><span style="color:#25292a;"> r0+r4 </span><span style="color:#25292a;">就得到了重定位后的</span><span style="color:#25292a;">Label </span><span style="color:#25292a;">值。此时</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">保存着重定位后的</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">值，相当于</span><span style="color:#25292a;"> 0X87804198+0X18747000=0X9FF4B198</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 104</span><span style="color:#25292a;">，读取重定位后</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">所保存的变量地址，此时这个变量地址还是重定位前的</span><span style="color:#25292a;">(</span><span style="color:#25292a;">相当于变量重定位前的地址</span><span style="color:#25292a;"> 0X8785DA50)</span><span style="color:#25292a;">，将得到的值放到</span><span style="color:#25292a;"> r1 </span><span style="color:#25292a;">寄存器中。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 105 </span><span style="color:#25292a;">行</span> <span style="color:#25292a;">，</span><span style="color:#25292a;"> r1+r4 </span><span style="color:#25292a;">即</span> <span style="color:#25292a;">可</span> <span style="color:#25292a;">得</span> <span style="color:#25292a;">到</span> <span style="color:#25292a;">重</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">位</span> <span style="color:#25292a;">后</span> <span style="color:#25292a;">的</span> <span style="color:#25292a;">变</span> <span style="color:#25292a;">量</span> <span style="color:#25292a;">地</span> <span style="color:#25292a;">址</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">相</span> <span style="color:#25292a;">当</span> <span style="color:#25292a;">于</span><span style="color:#25292a;"> rel_a </span><span style="color:#25292a;">重</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">位</span> <span style="color:#25292a;">后</span> <span style="color:#25292a;">的</span><br><span style="color:#25292a;">0X8785DA50+0X18747000=0X9FFA4A50</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 106 </span><span style="color:#25292a;">行，重定位后的变量地址写入到重定位后的</span><span style="color:#25292a;"> Label </span><span style="color:#25292a;">中，相等于设置地址</span><span style="color:#25292a;"> 0X9FF4B198</span><span style="color:#25292a;">处的值为</span><span style="color:#25292a;"> 0X9FFA4A50</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 108 </span><span style="color:#25292a;">行，比较</span><span style="color:#25292a;"> r2 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r3</span><span style="color:#25292a;">，查看</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段重定位是否完成。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 109 </span><span style="color:#25292a;">行，如果</span><span style="color:#25292a;"> r2 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> r3 </span><span style="color:#25292a;">不相等，说明</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">重定位还未完成，因此跳到</span><span style="color:#25292a;"> fixloop </span><span style="color:#25292a;">继续重定位</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段。</span><br><span style="color:#25292a;">可以看出，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中对</span><span style="color:#25292a;">.rel.dyn </span><span style="color:#25292a;">段的重定位方法和我们猜想的一致。</span><span style="color:#25292a;"> .rel.dyn </span><span style="color:#25292a;">段的重定位比较</span><br><span style="color:#25292a;">复杂一点，有点绕，因为涉及到链接地址和运行地址的问题。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">relocate_vectors </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">函数</span><span style="color:#25292a;"> relocate_vectors </span><span style="color:#25292a;">用于重定位向量表，此函数定义在文件</span><span style="color:#25292a;"> relocate.S </span><span style="color:#25292a;">中，</span> <span style="color:#25292a;">函数源码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="629" src="https://images2.imgbox.com/4f/2a/27y4DCVd_o.png" width="784"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 29 </span><span style="color:#25292a;">行，如果定义了</span><span style="color:#25292a;"> CONFIG_CPU_V7M </span><span style="color:#25292a;">的话就执行第</span><span style="color:#25292a;"> 30~36 </span><span style="color:#25292a;">行的代码，这是</span><span style="color:#25292a;"> Cortex-M</span><span style="color:#25292a;">内核单片机执行的语句，因此对于</span><span style="color:#25292a;"> I.MX6ULL </span><span style="color:#25292a;">来说是无效的。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 38 </span><span style="color:#25292a;">行，如果定义了</span><span style="color:#25292a;"> CONFIG_HAS_VBAR </span><span style="color:#25292a;">的话就执行此语句，这个是向量表偏移，</span><span style="color:#25292a;"> CortexA7 </span><span style="color:#25292a;">是支持向量表偏移的。而且，在</span><span style="color:#25292a;">.config </span><span style="color:#25292a;">里面定义了</span><span style="color:#25292a;"> CONFIG_HAS_VBAR</span><span style="color:#25292a;">，因此会执行这个分支。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 43 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> r0=gd-&gt;relocaddr</span><span style="color:#25292a;">，也就是重定位后</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的首地址，向量表肯定是从这个地址开始存放的。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 44 </span><span style="color:#25292a;">行，将</span><span style="color:#25292a;"> r0 </span><span style="color:#25292a;">的值写入到</span><span style="color:#25292a;"> CP15 </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> VBAR </span><span style="color:#25292a;">寄存器中，也就是将新的向量表首地址写入到寄存器</span><span style="color:#25292a;"> VBAR </span><span style="color:#25292a;">中，设置向量表偏移。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">board_init_r </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">前面讲解了</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">函数，在此函数里面会调用一系列的函数来初始化一些外设和</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的成员变量。但是</span><span style="color:#25292a;"> board_init_f </span><span style="color:#25292a;">并没有初始化所有的外设，还需要做一些后续工作，这些后续工作就是由函数</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">来完成的，</span><span style="color:#25292a;"> board_init_r </span><span style="color:#25292a;">函数定义在文件</span><span style="color:#25292a;"> common/board_r.c</span><span style="color:#25292a;">中，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="461" src="https://images2.imgbox.com/88/42/GJgYEFTx_o.png" width="859"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1010 </span><span style="color:#25292a;">行调用</span><span style="color:#25292a;"> initcall_run_list </span><span style="color:#25292a;">函数来执行初始化序列</span><span style="color:#25292a;"> init_sequence_r</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> init_sequence_r </span><span style="color:#25292a;">是一个函数集合，</span><span style="color:#25292a;"> init_sequence_r </span><span style="color:#25292a;">也定义在文件</span><span style="color:#25292a;"> common/board_r.c </span><span style="color:#25292a;">中，</span><span style="color:#25292a;">init_sequence_r </span><span style="color:#25292a;">定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="719" src="https://images2.imgbox.com/fc/3c/RQDPxwnF_o.png" width="726"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 774 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_trace </span><span style="color:#25292a;">函数，如果定义了宏</span><span style="color:#25292a;"> CONFIG_TRACE </span><span style="color:#25292a;">的话就会调用函数</span><span style="color:#25292a;"> trace_init</span><span style="color:#25292a;">，初始化和调试跟踪有关的内容。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 775 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_reloc </span><span style="color:#25292a;">函数用于设置</span><span style="color:#25292a;"> gd-&gt;flags</span><span style="color:#25292a;">，标记重定位完成。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 778 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_caches </span><span style="color:#25292a;">函数用于初始化</span><span style="color:#25292a;"> cache</span><span style="color:#25292a;">，使能</span><span style="color:#25292a;"> cache</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 786 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_reloc_global_data </span><span style="color:#25292a;">函数，初始化重定位后</span><span style="color:#25292a;"> gd </span><span style="color:#25292a;">的一些成员变量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 790 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_barrier </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;"> PPC</span><span style="color:#25292a;">架构使用。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 791 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_malloc </span><span style="color:#25292a;">函数，初始化</span><span style="color:#25292a;"> malloc</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 792 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_console_record </span><span style="color:#25292a;">函数，初始化控制台相关的内容，</span> <span style="color:#25292a;">需要定义</span><span style="color:#25292a;">CONSOLE_RECORD</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 796 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> bootstage_relocate </span><span style="color:#25292a;">函数，启动状态重定位。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 800 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_bootstage </span><span style="color:#25292a;">函数，初始化</span><span style="color:#25292a;"> bootstage </span><span style="color:#25292a;">什么的。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 802 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> board_init </span><span style="color:#25292a;">函数，板级初始化，该函数一般由</span><span style="color:#25292a;">soc</span><span style="color:#25292a;">原厂或用户编写。</span><br><span style="color:#25292a;">这里执行的是</span><span style="color:#25292a;"> mx6ull_alientek_emmc.c </span><span style="color:#25292a;">文件中的</span><span style="color:#25292a;"> board_init </span><span style="color:#25292a;">函数。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="720" src="https://images2.imgbox.com/06/46/Ro0RjzPZ_o.png" width="770"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 813 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> stdio_init_tables </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;"> stdio </span><span style="color:#25292a;">相关初始化。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 814 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_serial </span><span style="color:#25292a;">函数，初始化串口。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 815 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_announce </span><span style="color:#25292a;">函数，与调试有关，通知已经在</span><span style="color:#25292a;"> RAM </span><span style="color:#25292a;">中运行。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="628" src="https://images2.imgbox.com/80/15/nekgap3m_o.png" width="872"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 853 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> power_init_board </span><span style="color:#25292a;">函数，初始化电源芯片，即</span><span style="color:#25292a;">PMIC</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 855 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_flash </span><span style="color:#25292a;">函数，初始化</span><span style="color:#25292a;">flash</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 867 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_nand </span><span style="color:#25292a;">函数，初始化</span><span style="color:#25292a;"> NAND</span><span style="color:#25292a;">，如果使用</span><span style="color:#25292a;"> NAND </span><span style="color:#25292a;">版本核心板的话就会初始化</span><span style="color:#25292a;">NAND</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 873 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_mmc </span><span style="color:#25292a;">函数，初始化</span><span style="color:#25292a;"> EMMC</span><span style="color:#25292a;">，如果使用</span><span style="color:#25292a;"> EMMC </span><span style="color:#25292a;">版本核心板的话就会初始化</span><span style="color:#25292a;">EMMC</span><span style="color:#25292a;">，串口输出如图所示信息：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="48" src="https://images2.imgbox.com/1a/b3/4zhn5UWi_o.png" width="533"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">从图中可以看出，此时有两个</span><span style="color:#25292a;"> EMCM </span><span style="color:#25292a;">设备，</span><span style="color:#25292a;"> FSL_SDHC:0 </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> FSL_SDHC:1</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 878 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_env </span><span style="color:#25292a;">函数，初始化环境变量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 883 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_secondary_cpu </span><span style="color:#25292a;">函数，初始化其他</span><span style="color:#25292a;"> CPU </span><span style="color:#25292a;">核。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="702" src="https://images2.imgbox.com/75/3a/c5CATllV_o.png" width="801"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 894 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> stdio_add_devices </span><span style="color:#25292a;">函数，各种输入输出设备的初始化，如</span><span style="color:#25292a;"> LCD driver</span><span style="color:#25292a;">，</span><span style="color:#25292a;"> I.MX6ULL</span><span style="color:#25292a;">使用</span><span style="color:#25292a;"> drv_video_init </span><span style="color:#25292a;">函数初始化</span><span style="color:#25292a;"> LCD</span><span style="color:#25292a;">。会输出如图所示信息：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="58" src="https://images2.imgbox.com/40/98/WQ8rESxm_o.png" width="651"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 895 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_jumptable </span><span style="color:#25292a;">函数，初始化跳转表。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 899 </span><span style="color:#25292a;">行</span> <span style="color:#25292a;">，</span><span style="color:#25292a;"> console_init_r </span><span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">控</span> <span style="color:#25292a;">制</span> <span style="color:#25292a;">台</span> <span style="color:#25292a;">初</span> <span style="color:#25292a;">始</span> <span style="color:#25292a;">化</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">初</span> <span style="color:#25292a;">始</span> <span style="color:#25292a;">化</span> <span style="color:#25292a;">完</span> <span style="color:#25292a;">成</span> <span style="color:#25292a;">以</span> <span style="color:#25292a;">后</span> <span style="color:#25292a;">此</span> <span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">会</span> <span style="color:#25292a;">调</span> <span style="color:#25292a;">用</span><br><span style="color:#25292a;">stdio_print_current_devices </span><span style="color:#25292a;">函数来打印出当前的控制台设备，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="74" src="https://images2.imgbox.com/ca/23/hShwqtXa_o.png" width="234"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 913 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> interrupt_init </span><span style="color:#25292a;">函数，初始化中断。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 915 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_enable_interrupts </span><span style="color:#25292a;">函数，使能中断。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 925 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> initr_ethaddr </span><span style="color:#25292a;">函数，初始化网络地址，也就是获取</span><span style="color:#25292a;"> MAC </span><span style="color:#25292a;">地址。读取环境变量</span><span style="color:#25292a;">“ethaddr”</span><span style="color:#25292a;">的值。</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="648" src="https://images2.imgbox.com/e1/ce/yqJ3Zv0p_o.png" width="685"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 928 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> board_late_init </span><span style="color:#25292a;">函数，板子后续初始化，此函数定义在文件</span><span style="color:#25292a;"> mx6ull_alientek_emmc.c</span><span style="color:#25292a;">中，如果环境变量存储在</span><span style="color:#25292a;"> EMMC </span><span style="color:#25292a;">或者</span><span style="color:#25292a;"> SD </span><span style="color:#25292a;">卡中的话此函数会调用</span><span style="color:#25292a;"> board_late_mmc_env_init </span><span style="color:#25292a;">函数初始化</span><span style="color:#25292a;"> EMMC/SD</span><span style="color:#25292a;">。会切换到正在时候用的</span><span style="color:#25292a;"> emmc </span><span style="color:#25292a;">设备，代码如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="511" src="https://images2.imgbox.com/46/84/yRKHTgkS_o.png" width="637"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">图中的第</span><span style="color:#25292a;"> 46 </span><span style="color:#25292a;">行和第</span><span style="color:#25292a;"> 47 </span><span style="color:#25292a;">行就是运行</span><span style="color:#25292a;">“mmc dev xx”</span><span style="color:#25292a;">命令，用于切换到正在使用的</span><span style="color:#25292a;">EMMC </span><span style="color:#25292a;">设备，串口输出信息如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="47" src="https://images2.imgbox.com/34/08/5RdghIKV_o.png" width="505"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 952 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;">initr_net</span><span style="color:#25292a;">函数，初始化网络，函数调用顺序为</span> <span style="color:#25292a;">：</span><span style="color:#25292a;">initr_net-&gt;eth_initialize-&gt;board_eth_init()</span><span style="color:#25292a;">，</span> <span style="color:#25292a;">串口输出如图所示信息：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="26" src="https://images2.imgbox.com/43/fb/oYEQMNJT_o.png" width="272"></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="504" src="https://images2.imgbox.com/1a/38/0GATNLug_o.png" width="639"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 988 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> run_main_loop </span><span style="color:#25292a;">行，主循环，处理命令。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">run_main_loop </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">uboot </span><span style="color:#25292a;">启动以后会进入</span><span style="color:#25292a;"> 3 </span><span style="color:#25292a;">秒倒计时，如果在</span><span style="color:#25292a;"> 3 </span><span style="color:#25292a;">秒倒计时结束之前按下按下回车键，那么就会进入</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的命令模式，如果倒计时结束以后都没有按下回车键，那么就会自动启动</span><span style="color:#25292a;"> Linux </span><span style="color:#25292a;">内核</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">这个功能就是由</span><span style="color:#25292a;"> run_main_loop </span><span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">来</span> <span style="color:#25292a;">完</span> <span style="color:#25292a;">成</span> <span style="color:#25292a;">的</span> <span style="color:#25292a;">。</span><span style="color:#25292a;"> run_main_loop </span><span style="color:#25292a;">函</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span> <span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;">common/board_r.c </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="194" src="https://images2.imgbox.com/b7/fc/LMfnEVzR_o.png" width="769"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 759 </span><span style="color:#25292a;">行和第</span><span style="color:#25292a;"> 760 </span><span style="color:#25292a;">行是个死循环，</span><span style="color:#25292a;">“for(;;)”</span><span style="color:#25292a;">和</span><span style="color:#25292a;">“while(1)”</span><span style="color:#25292a;">功能一样，死循环里面就一个</span><span style="color:#25292a;">main_loop </span><span style="color:#25292a;">函数，</span><span style="color:#25292a;"> main_loop </span><span style="color:#25292a;">函数定义在文件</span><span style="color:#25292a;"> common/main.c </span><span style="color:#25292a;">里面，代码如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="576" src="https://images2.imgbox.com/97/3d/13n3a0ih_o.png" width="792"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 48 </span><span style="color:#25292a;">行，调用</span><span style="color:#25292a;"> bootstage_mark_name </span><span style="color:#25292a;">函数，打印出启动进度。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 57 </span><span style="color:#25292a;">行，如果定义了宏</span><span style="color:#25292a;"> CONFIG_VERSION_VARIABLE </span><span style="color:#25292a;">的话就会执行函数</span><span style="color:#25292a;"> setenv</span><span style="color:#25292a;">，设置换将变量</span><span style="color:#25292a;"> ver </span><span style="color:#25292a;">的值为</span><span style="color:#25292a;"> version_string</span><span style="color:#25292a;">，也就是设置版本号环境变量。</span><span style="color:#25292a;"> version_string </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;">cmd/version.c </span><span style="color:#25292a;">中，定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">const char __weak version_string[] = U_BOOT_VERSION_STRING;</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">U_BOOT_VERSION_STRING </span><span style="color:#25292a;">是个宏，</span> <span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> include/version.h</span><span style="color:#25292a;">，如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="323" src="https://images2.imgbox.com/98/98/wnUL8YKt_o.png" width="657"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">U_BOOT_VERSION </span><span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span> <span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;"> include/generated/version_autogenerated.h </span><span style="color:#25292a;">中</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><br><span style="color:#25292a;">version_autogenerated.h </span><span style="color:#25292a;">内如如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">#define PLAIN_VERSION "2016.03"</p> 
<p style="margin-left:0;text-align:left;">#define U_BOOT_VERSION "U-Boot " PLAIN_VERSION</p> 
<p style="margin-left:0;text-align:left;">#define CC_VERSION_STRING "arm-linux-gnueabihf-gcc (Linaro GCC 4.9-2017.01) 4.9.4"</p> 
<p style="margin-left:0;text-align:left;">#define LD_VERSION_STRING "GNU ld (Linaro_Binutils-2017.01)2.24.0.20141017 Linaro 2014_11-3-git"</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可以看出，</span><span style="color:#25292a;"> U_BOOT_VERSION </span><span style="color:#25292a;">为</span><span style="color:#25292a;">“U-boot 2016.03”</span><span style="color:#25292a;">，</span><span style="color:#25292a;">U_BOOT_DATE </span><span style="color:#25292a;">、</span><span style="color:#25292a;"> U_BOOT_TIME </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> U_BOOT_TZ </span><span style="color:#25292a;">这</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span> <span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;">include/generated/timestamp_autogenerated.h </span><span style="color:#25292a;">中，如下所示：</span></span></p> 
<p style="margin-left:0;text-align:left;">#define U_BOOT_DATE "Apr 25 2019"</p> 
<p style="margin-left:0;text-align:left;">#define U_BOOT_TIME "21:10:53"</p> 
<p style="margin-left:0;text-align:left;">#define U_BOOT_TZ "+0800"</p> 
<p style="margin-left:0;text-align:left;">#define U_BOOT_DMI_DATE "04/25/2019"</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">宏</span><span style="color:#25292a;"> CONFIG_IDENT_STRING </span><span style="color:#25292a;">为空，所以</span><span style="color:#25292a;"> U_BOOT_VERSION_STRING </span><span style="color:#25292a;">为</span><span style="color:#25292a;">“U-Boot 2016.03(Apr 25 2019 – 21:10:53 +0800)”</span><span style="color:#25292a;">，进入</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">命令模式，输入命令</span><span style="color:#25292a;">“version”</span><span style="color:#25292a;">查看版本号，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="110" src="https://images2.imgbox.com/8e/a8/WKsTcOrB_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">上图中的第一行就是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">版本号，和我们分析的一致。</span><br><span style="color:#25292a;">接着回到函数</span><span style="color:#25292a;">main_loop</span><span style="color:#25292a;">中，第</span><span style="color:#25292a;"> 60 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> cli_init </span><span style="color:#25292a;">函数，跟命令初始化有关，初始化</span><span style="color:#25292a;"> hush shell </span><span style="color:#25292a;">相关的变量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 62 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> run_preboot_environment_command </span><span style="color:#25292a;">函数，获取环境变量</span><span style="color:#25292a;"> perboot </span><span style="color:#25292a;">的内容，</span><span style="color:#25292a;"> preboot</span><span style="color:#25292a;">是一些预启动命令，一般不使用这个环境变量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 68 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> bootdelay_process </span><span style="color:#25292a;">函数，此函数会读取环境变量</span><span style="color:#25292a;"> bootdelay </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> bootcmd </span><span style="color:#25292a;">的内容，然后将</span><span style="color:#25292a;"> bootdelay </span><span style="color:#25292a;">的值赋值给全局变量</span><span style="color:#25292a;"> stored_bootdelay</span><span style="color:#25292a;">，返回值为环境变量</span><span style="color:#25292a;"> bootcmd </span><span style="color:#25292a;">的值。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 69 </span><span style="color:#25292a;">行，如果定义了</span><span style="color:#25292a;"> CONFIG_OF_CONTROL </span><span style="color:#25292a;">的话函数</span><span style="color:#25292a;"> cli_process_fdt </span><span style="color:#25292a;">就会实现，如果没有定义</span><span style="color:#25292a;"> CONFIG_OF_CONTROL </span><span style="color:#25292a;">的话函数</span><span style="color:#25292a;"> cli_process_fdt </span><span style="color:#25292a;">直接返回一个</span><span style="color:#25292a;"> false</span><span style="color:#25292a;">。在本</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中没有定义</span><span style="color:#25292a;"> CONFIG_OF_CONTROL</span><span style="color:#25292a;">，因此</span><span style="color:#25292a;"> cli_process_fdt </span><span style="color:#25292a;">函数返回值为</span><span style="color:#25292a;"> false</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 72 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> autoboot_command </span><span style="color:#25292a;">函数，此函数就是检查倒计时是否结束</span><span style="color:#25292a;">,</span><span style="color:#25292a;">倒计时结束之前有没有被打断</span><span style="color:#25292a;">,</span><span style="color:#25292a;">此函数定义在文件</span><span style="color:#25292a;"> common/autoboot.c </span><span style="color:#25292a;">中，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="393" src="https://images2.imgbox.com/de/8e/4w50PK0c_o.png" width="670"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">当以下三条全部成立的话，就会执行函数</span><span style="color:#25292a;"> run_command_list</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">①</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> stored_bootdelay </span><span style="color:#25292a;">不等于</span><span style="color:#25292a;">-1</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">②</span><span style="color:#25292a;">、</span><span style="color:#25292a;"> s </span><span style="color:#25292a;">不为空。</span><br><span style="color:#25292a;">③</span><span style="color:#25292a;">、函数</span><span style="color:#25292a;"> abortboot </span><span style="color:#25292a;">返回值为</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">stored_bootdelay </span><span style="color:#25292a;">等于环境变量</span><span style="color:#25292a;"> bootdelay </span><span style="color:#25292a;">的值；</span><span style="color:#25292a;"> s </span><span style="color:#25292a;">是环境变量</span><span style="color:#25292a;"> bootcmd </span><span style="color:#25292a;">的值，一般不为空，因此前两个成立，就剩下了函数</span><span style="color:#25292a;">abortboot </span><span style="color:#25292a;">的返回值，</span><span style="color:#25292a;">abortboot</span><span style="color:#25292a;">函数也定义在文件</span><span style="color:#25292a;">common/autoboot.c </span><span style="color:#25292a;">，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="137" src="https://images2.imgbox.com/86/09/T2qEi8aW_o.png" width="429"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">因为宏</span><span style="color:#25292a;"> CONFIG_AUTOBOOT_KEYE </span><span style="color:#25292a;">未定义，因此执行函数</span><span style="color:#25292a;"> abortboot_normal</span><span style="color:#25292a;">，接着来看函数</span><span style="color:#25292a;">abortboot_normal</span><span style="color:#25292a;">，此函数也定义在文件</span><span style="color:#25292a;"> common/autoboot.c </span><span style="color:#25292a;">中，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="802" src="https://images2.imgbox.com/d3/4d/bvplQ8P4_o.png" width="695"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 227 </span><span style="color:#25292a;">行的变量</span><span style="color:#25292a;"> abort </span><span style="color:#25292a;">是函数</span><span style="color:#25292a;"> abortboot_normal </span><span style="color:#25292a;">的返回值，默认值为</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 234 </span><span style="color:#25292a;">行通过串口输出</span><span style="color:#25292a;">“Hit any key to stop autoboot”</span><span style="color:#25292a;">字样，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="26" src="https://images2.imgbox.com/0f/1f/wH0WEB4M_o.png" width="515"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 251-267 </span><span style="color:#25292a;">行就是倒计时的具体实现。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 256 </span><span style="color:#25292a;">行判断键盘是否有按下，也就是是否打断了倒计时，如果键盘按下的话就执行相应的分支。比如设置</span><span style="color:#25292a;"> abort </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 1</span><span style="color:#25292a;">，设置</span><span style="color:#25292a;"> bootdelay </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> 0 </span><span style="color:#25292a;">等，最后跳出倒计时循环。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 279 </span><span style="color:#25292a;">行，返回</span><span style="color:#25292a;">abort</span><span style="color:#25292a;">的值，如果倒计时自然结束，没有被打断</span><span style="color:#25292a;"> abort </span><span style="color:#25292a;">就为</span><span style="color:#25292a;"> 0</span><span style="color:#25292a;">，否则的话</span><span style="color:#25292a;"> abort</span><span style="color:#25292a;">的值就为</span><span style="color:#25292a;">1</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">回到</span><span style="color:#25292a;">autoboot_command </span><span style="color:#25292a;">函数中，如果倒计时自然结束那么就执行函数</span><span style="color:#25292a;">run_command_list</span><span style="color:#25292a;">，此函数会执行参数</span><span style="color:#25292a;"> s </span><span style="color:#25292a;">指定的一系列命令，也就是环境变量</span><span style="color:#25292a;"> bootcmd </span><span style="color:#25292a;">的命令，</span><span style="color:#25292a;">bootcmd </span><span style="color:#25292a;">里面保存着默认的启动命令，因此</span><span style="color:#25292a;"> linux </span><span style="color:#25292a;">内核启动！这个就是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中倒计时结束以后自动启动</span><span style="color:#25292a;"> linux </span><span style="color:#25292a;">内核的原理。如果倒计时结束之前按下了键盘上的按键，那么</span><span style="color:#25292a;"> run_command_list</span><span style="color:#25292a;">函数就不会执行，相当于</span><span style="color:#25292a;"> autoboot_command </span><span style="color:#25292a;">是个空函数。</span><br><span style="color:#25292a;">回到</span><span style="color:#25292a;">“</span><span style="color:#25292a;">遥远</span><span style="color:#25292a;">”</span><span style="color:#25292a;">的</span><span style="color:#25292a;"> main_loop </span><span style="color:#25292a;">函数中，如果倒计时结束之前按下按键，那么就会执行第</span><span style="color:#25292a;"> 74 </span><span style="color:#25292a;">行的</span><span style="color:#25292a;"> cli_loop </span><span style="color:#25292a;">函数，这个就是命令处理函数，负责接收处理输入的命令。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">cli_loop </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">cli_loop </span><span style="color:#25292a;">函数是</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的命令行处理函数，我们在</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中输入各种命令，进行各种操作就是有</span><span style="color:#25292a;"> cli_loop </span><span style="color:#25292a;">来处理的，此函数定义在文件</span><span style="color:#25292a;"> common/cli.c </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="194" src="https://images2.imgbox.com/e1/14/q3vCOson_o.png" width="452"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在文件</span><span style="color:#25292a;"> include/configs/mx6_common.h </span><span style="color:#25292a;">中有定义宏</span><span style="color:#25292a;"> CONFIG_SYS_HUSH_PARSER</span><span style="color:#25292a;">，而开发板配置头文件</span><span style="color:#25292a;"> mx6ullevk.h </span><span style="color:#25292a;">里面会引用</span><span style="color:#25292a;"> mx_common.h </span><span style="color:#25292a;">这个头文件，因此宏</span><span style="color:#25292a;"> CONFIG_SYS_HUSH_PARSER </span><span style="color:#25292a;">有定义。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 205 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> parse_file_outer</span><span style="color:#25292a;">。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 207 </span><span style="color:#25292a;">行是个死循环，永远不会执行到这里。</span><br><span style="color:#25292a;">函数</span><span style="color:#25292a;"> parse_file_outer </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> common/cli_hush.c </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="306" src="https://images2.imgbox.com/20/10/eoeKXPwH_o.png" width="636"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 3296 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> setup_file_in_str </span><span style="color:#25292a;">初始化变量</span><span style="color:#25292a;"> input </span><span style="color:#25292a;">的成员变量。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 3300 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> parse_stream_outer</span><span style="color:#25292a;">，这个函数就是</span><span style="color:#25292a;"> hush shell </span><span style="color:#25292a;">的命令解释器，负责接收命令行输入，然后解析并执行相应的命令，函数</span><span style="color:#25292a;">parse_stream_outer </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> common/cli_hush.c</span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">1 static int parse_stream_outer(struct in_str *inp, int flag)<br> 2 {<!-- --><br> 3 struct p_context ctx;<br> 4 o_string temp=NULL_O_STRING;<br> 5 int rcode;<br> 6 int code = 1;<br> 7 do {<!-- --><br> 8 ......<br> 9 rcode = parse_stream(&amp;temp, &amp;ctx, inp,<br> 10 flag &amp; FLAG_CONT_ON_NEWLINE ? -1 : '\n');<br> 11 ......<br> 12 if (rcode != 1 &amp;&amp; ctx.old_flag == 0) {<!-- --><br> 13 ......<br> 14 run_list(ctx.list_head);<br> 15 ......<br> 16 } else {<!-- --><br> 17 ......<br> 18 }<br> 19 b_free(&amp;temp);<br> 20 /* loop on syntax errors, return on EOF */<br> 21 } while (rcode != -1 &amp;&amp; !(flag &amp; FLAG_EXIT_FROM_LOOP) &amp;&amp;<br> 22 (inp-&gt;peek != static_peek || b_peek(inp)));<br> 23 return 0;<br> 24 }</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 7~21 </span><span style="color:#25292a;">行中的</span><span style="color:#25292a;"> do-while </span><span style="color:#25292a;">循环就是处理输入命令的。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 9 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> parse_stream </span><span style="color:#25292a;">进行命令解析。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 14 </span><span style="color:#25292a;">行调用调用</span><span style="color:#25292a;"> run_list </span><span style="color:#25292a;">函数来执行解析出来的命令。函数</span><span style="color:#25292a;"> run_list </span><span style="color:#25292a;">会经过一系列的函数调用，最终通过调用</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">函数来处理命令，过程如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="318" src="https://images2.imgbox.com/a4/61/SAcHVUIQ_o.png" width="712"><img alt="" height="644" src="https://images2.imgbox.com/b4/32/rjnItIub_o.png" width="767"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">……</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="60" src="https://images2.imgbox.com/ef/67/VTITfBC2_o.png" width="600"></p> 
<p> <img alt="" height="496" src="https://images2.imgbox.com/d9/95/QxjC8yyx_o.png" width="679"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">……</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="92" src="https://images2.imgbox.com/dc/5a/6EY9U24D_o.png" width="685"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">run_list </span><span style="color:#25292a;">函数调用</span><span style="color:#25292a;"> run_list_real </span><span style="color:#25292a;">函数。</span><br><span style="color:#25292a;">run_list_real </span><span style="color:#25292a;">函数调用</span><span style="color:#25292a;"> run_pipe_real </span><span style="color:#25292a;">函数。</span><br><span style="color:#25292a;">run_pipe_real </span><span style="color:#25292a;">函数调用</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">函数。</span><br><span style="color:#25292a;">最终通过函数</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">来处理命令，接下来就是分析</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">函数。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17252a;">cmd_process </span><span style="color:#17252a;">函数</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在学习</span><span style="color:#25292a;">cmd_process </span><span style="color:#25292a;">之前先看一下</span><span style="color:#25292a;">uboot</span><span style="color:#25292a;">中命令是如何定义的。</span><span style="color:#25292a;">uboot</span><span style="color:#25292a;">使用宏</span><span style="color:#25292a;">U_BOOT_CMD</span><span style="color:#25292a;">来定义命令，宏</span><span style="color:#25292a;"> U_BOOT_CMD </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> include/command.h </span><span style="color:#25292a;">中，定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="72" src="https://images2.imgbox.com/31/5d/i1WRcjXt_o.png" width="992"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可</span> <span style="color:#25292a;">以</span> <span style="color:#25292a;">看</span> <span style="color:#25292a;">出</span><span style="color:#25292a;"> U_BOOT_CMD </span><span style="color:#25292a;">是</span><span style="color:#25292a;"> U_BOOT_CMD_COMPLETE </span><span style="color:#25292a;">的</span> <span style="color:#25292a;">特</span> <span style="color:#25292a;">例</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">将</span><span style="color:#25292a;">U_BOOT_CMD_COMPLETE </span><span style="color:#25292a;">的</span> <span style="color:#25292a;">最</span> <span style="color:#25292a;">后</span> <span style="color:#25292a;">一</span> <span style="color:#25292a;">个</span> <span style="color:#25292a;">参</span> <span style="color:#25292a;">数</span> <span style="color:#25292a;">设</span> <span style="color:#25292a;">置</span> <span style="color:#25292a;">成</span><span style="color:#25292a;"> NULL </span><span style="color:#25292a;">就</span> <span style="color:#25292a;">是</span><span style="color:#25292a;"> U_BOOT_CMD </span><span style="color:#25292a;">。</span> <span style="color:#25292a;">宏</span><span style="color:#25292a;">U_BOOT_CMD_COMPLETE </span><span style="color:#25292a;">如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="96" src="https://images2.imgbox.com/d4/75/4GhLfPSN_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">宏</span><span style="color:#25292a;"> U_BOOT_CMD_COMPLETE </span><span style="color:#25292a;">又</span> <span style="color:#25292a;">用</span> <span style="color:#25292a;">到</span> <span style="color:#25292a;">了</span><span style="color:#25292a;"> ll_entry_declare </span><span style="color:#25292a;">和</span><span style="color:#25292a;">U_BOOT_CMD_MKENT_COMPLETE</span><span style="color:#25292a;">。</span><span style="color:#25292a;"> ll_entry_declar </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> include/linker_lists.h </span><span style="color:#25292a;">中，定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="98" src="https://images2.imgbox.com/b9/31/Lxj0WDij_o.png" width="723"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">_type </span><span style="color:#25292a;">为</span><span style="color:#25292a;"> cmd_tbl_t</span><span style="color:#25292a;">，因此</span><span style="color:#25292a;"> ll_entry_declare </span><span style="color:#25292a;">就是定义了一个</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">变量，这里用到了</span><span style="color:#25292a;"> C </span><span style="color:#25292a;">语言中的</span><span style="color:#25292a;">“##”</span><span style="color:#25292a;">连接符。其中的</span><span style="color:#25292a;">“##_list”</span><span style="color:#25292a;">表示用</span><span style="color:#25292a;">_list </span><span style="color:#25292a;">的值来替换，</span><span style="color:#25292a;">“##_name”</span><span style="color:#25292a;">就是用</span><span style="color:#25292a;">_name </span><span style="color:#25292a;">的值来替换。</span><br><span style="color:#25292a;">宏</span><span style="color:#25292a;"> U_BOOT_CMD_MKENT_COMPLETE </span><span style="color:#25292a;">定义在文件</span><span style="color:#25292a;"> include/command.h </span><span style="color:#25292a;">中，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="100" src="https://images2.imgbox.com/ff/0f/GIXCVuLh_o.png" width="945"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">上</span> <span style="color:#25292a;">述</span> <span style="color:#25292a;">代</span> <span style="color:#25292a;">码</span> <span style="color:#25292a;">中</span> <span style="color:#25292a;">的</span><span style="color:#25292a;"> “ # ” </span><span style="color:#25292a;">表</span> <span style="color:#25292a;">示</span> <span style="color:#25292a;">将</span><span style="color:#25292a;"> _name </span><span style="color:#25292a;">传</span> <span style="color:#25292a;">递</span> <span style="color:#25292a;">过</span> <span style="color:#25292a;">来</span> <span style="color:#25292a;">的</span> <span style="color:#25292a;">值</span> <span style="color:#25292a;">字</span> <span style="color:#25292a;">符</span> <span style="color:#25292a;">串</span> <span style="color:#25292a;">化</span> <span style="color:#25292a;">，</span><span style="color:#25292a;">U_BOOT_CMD_MKENT_COMPLETE </span><span style="color:#25292a;">又用到了宏</span><span style="color:#25292a;">_CMD_HELP </span><span style="color:#25292a;">和</span><span style="color:#25292a;">_CMD_COMPLETE</span><span style="color:#25292a;">，这两个宏的定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="242" src="https://images2.imgbox.com/a8/97/B4wlS0CJ_o.png" width="433"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可以看出，如果定义了宏</span><span style="color:#25292a;"> CONFIG_AUTO_COMPLETE </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> CONFIG_SYS_LONGHELP </span><span style="color:#25292a;">的话</span> <span style="color:#25292a;">，</span><span style="color:#25292a;">_CMD_COMPLETE </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> _CMD_HELP </span><span style="color:#25292a;">就</span> <span style="color:#25292a;">是</span> <span style="color:#25292a;">取</span> <span style="color:#25292a;">自</span> <span style="color:#25292a;">身</span> <span style="color:#25292a;">的</span> <span style="color:#25292a;">值</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">然</span> <span style="color:#25292a;">后</span> <span style="color:#25292a;">在</span> <span style="color:#25292a;">加</span> <span style="color:#25292a;">上</span> <span style="color:#25292a;">一</span> <span style="color:#25292a;">个</span><span style="color:#25292a;"> ‘ , ’</span><span style="color:#25292a;">。</span><span style="color:#25292a;">CONFIG_AUTO_COMPLETE </span><span style="color:#25292a;">和</span><span style="color:#25292a;"> CONFIG_SYS_LONGHELP </span><span style="color:#25292a;">这</span> <span style="color:#25292a;">两</span> <span style="color:#25292a;">个</span> <span style="color:#25292a;">宏</span> <span style="color:#25292a;">有</span> <span style="color:#25292a;">定</span> <span style="color:#25292a;">义</span> <span style="color:#25292a;">在</span> <span style="color:#25292a;">文</span> <span style="color:#25292a;">件</span><span style="color:#25292a;">mx6_common.h </span><span style="color:#25292a;">中。</span><br><span style="color:#25292a;">U_BOOT_CMD</span><span style="color:#25292a;">宏的流程我们已经清楚了，我们就以一个具体的命令为例，来看一下</span><span style="color:#25292a;"> U_BOOT_CMD </span><span style="color:#25292a;">经过展开以后究竟是个什么模样的。以命令</span><span style="color:#25292a;"> dhcp </span><span style="color:#25292a;">为例，</span><span style="color:#25292a;"> dhcp </span><span style="color:#25292a;">命令定义如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">U_BOOT_CMD(</p> 
<p style="margin-left:0;text-align:left;">    dhcp, 3, 1, do_dhcp,</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol",</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]"</p> 
<p style="margin-left:0;text-align:left;">);</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">将其展开，结果如下：</span></span></p> 
<p style="margin-left:0;text-align:left;">U_BOOT_CMD(</p> 
<p style="margin-left:0;text-align:left;">    dhcp, 3, 1, do_dhcp,</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol",</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]"</p> 
<p style="margin-left:0;text-align:left;">);</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;">1、将 U_BOOT_CMD 展开后为：</p> 
<p style="margin-left:0;text-align:left;">U_BOOT_CMD_COMPLETE(dhcp, 3, 1, do_dhcp,</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol",</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]",</p> 
<p style="margin-left:0;text-align:left;">  NULL)</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;">2、将 U_BOOT_CMD_COMPLETE 展开后为：</p> 
<p style="margin-left:0;text-align:left;">ll_entry_declare(cmd_tbl_t, dhcp, cmd) = \</p> 
<p style="margin-left:0;text-align:left;">U_BOOT_CMD_MKENT_COMPLETE(dhcp, 3, 1, do_dhcp, \</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol", \</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]", \</p> 
<p style="margin-left:0;text-align:left;">  NULL);</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;">3、将 ll_entry_declare 和 U_BOOT_CMD_MKENT_COMPLETE 展开后为：</p> 
<p style="margin-left:0;text-align:left;">cmd_tbl_t _u_boot_list_2_cmd_2_dhcp <strong>aligned(4) \ __attribute</strong>((unused,section(.u_boot_list_2_cmd_2_dhcp))) \</p> 
<p style="margin-left:0;text-align:left;">{ "dhcp", 3, 1, do_dhcp, \</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol", \</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]",\</p> 
<p style="margin-left:0;text-align:left;">NULL}</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">dhcp </span><span style="color:#25292a;">命令最终展开结果为：</span></span></p> 
<p style="margin-left:0;text-align:left;">cmd_tbl_t _u_boot_list_2_cmd_2_dhcp __aligned(4) \</p> 
<p style="margin-left:0;text-align:left;">    __attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) \</p> 
<p style="margin-left:0;text-align:left;">    { "dhcp", 3, 1, do_dhcp, \</p> 
<p style="margin-left:0;text-align:left;">    "boot image via network using DHCP/TFTP protocol", \</p> 
<p style="margin-left:0;text-align:left;">    "[loadAddress] [[hostIPaddr:]bootfilename]",\</p> 
<p style="margin-left:0;text-align:left;">  NULL}</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 1 </span><span style="color:#25292a;">行定义了一个</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">类型的变量，变量名为</span><span style="color:#25292a;">_u_boot_list_2_cmd_2_dhcp</span><span style="color:#25292a;">，此变量</span><span style="color:#25292a;"> 4</span><span style="color:#25292a;">字节对齐。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 2 </span><span style="color:#25292a;">行</span> <span style="color:#25292a;">，</span> <span style="color:#25292a;">使</span> <span style="color:#25292a;">用</span><span style="color:#25292a;"> __attribute__ </span><span style="color:#25292a;">关</span> <span style="color:#25292a;">键</span> <span style="color:#25292a;">字</span> <span style="color:#25292a;">设</span> <span style="color:#25292a;">置</span> <span style="color:#25292a;">变</span> <span style="color:#25292a;">量</span><span style="color:#25292a;"> _u_boot_list_2_cmd_2_dhcp </span><span style="color:#25292a;">存</span> <span style="color:#25292a;">储在</span><span style="color:#25292a;">.u_boot_list_2_cmd_2_dhcp </span><span style="color:#25292a;">段中。</span><span style="color:#25292a;"> u-boot.lds </span><span style="color:#25292a;">链接脚本中有一个名为</span><span style="color:#25292a;">“.u_boot_list”</span><span style="color:#25292a;">的段，所有</span><span style="color:#25292a;">.u_boot_list </span><span style="color:#25292a;">开头的段都存放到</span><span style="color:#25292a;">.u_boot.list </span><span style="color:#25292a;">中，如图所示：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="170" src="https://images2.imgbox.com/28/13/Fg1vQgsv_o.png" width="981"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">因此，第</span><span style="color:#25292a;"> 2 </span><span style="color:#25292a;">行就是设置变量</span><span style="color:#25292a;">_u_boot_list_2_cmd_2_dhcp </span><span style="color:#25292a;">的存储位置。</span><br><span style="color:#25292a;">第</span><span style="color:#25292a;"> 3~6 </span><span style="color:#25292a;">行，</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">是个结构体，因此第</span><span style="color:#25292a;"> 3-6 </span><span style="color:#25292a;">行是初始化</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">这个结构体的各个成</span><br><span style="color:#25292a;">员变量。</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">结构体定义在文件</span><span style="color:#25292a;"> include/command.h </span><span style="color:#25292a;">中，内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="292" src="https://images2.imgbox.com/1f/e2/e9D5iKET_o.png" width="1024"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">可以得出变量</span><span style="color:#25292a;">_u_boot_list_2_cmd_2_dhcp </span><span style="color:#25292a;">的各个成员的值如下所示：</span></span></p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.name = "dhcp"</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.maxargs = 3</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.repeatable = 1</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.cmd = do_dhcp</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.usage = "boot image via network using DHCP/TFTP protocol"</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.help = "[loadAddress] [[hostIPaddr:]bootfilename]"</p> 
<p style="margin-left:0;text-align:left;">_u_boot_list_2_cmd_2_dhcp.complete = NULL</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">当我们在</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">的命令行中输入</span><span style="color:#25292a;">“dhcp”</span><span style="color:#25292a;">这个命令的时候，最终执行的是</span><span style="color:#25292a;"> do_dhcp </span><span style="color:#25292a;">这个函数。总结一下，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中使用</span><span style="color:#25292a;"> U_BOOT_CMD </span><span style="color:#25292a;">来定义一个命令，最终的目的就是为了定义一个</span><span style="color:#25292a;">cmd_tbl_t </span><span style="color:#25292a;">类型的变量，并初始化这个变量的各个成员。</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中的每个命令都存储在</span><span style="color:#25292a;">.u_boot_list</span><span style="color:#25292a;">段中，每个命令都有一个名为</span><span style="color:#25292a;"> do_xxx(xxx </span><span style="color:#25292a;">为具体的命令名</span><span style="color:#25292a;">)</span><span style="color:#25292a;">的函数，这个</span><span style="color:#25292a;"> do_xxx </span><span style="color:#25292a;">函数就是具体的命令处理函数。</span><br><span style="color:#25292a;">了解了</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中命令的组成以后，再来看一下</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">函数的处理过程，</span><span style="color:#25292a;"> cmd_process</span><span style="color:#25292a;">函数定义在文件</span><span style="color:#25292a;"> common/command.c </span><span style="color:#25292a;">中，函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="739" src="https://images2.imgbox.com/95/51/zo8zCCR3_o.png" width="780"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">第</span><span style="color:#25292a;"> 507 </span><span style="color:#25292a;">行，调用函数</span><span style="color:#25292a;"> find_cmd </span><span style="color:#25292a;">在命令表中找到指定的命令，</span><span style="color:#25292a;"> find_cmd </span><span style="color:#25292a;">函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="127" src="https://images2.imgbox.com/05/d2/bJSCsmf0_o.png" width="563"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">参数</span><span style="color:#25292a;"> cmd </span><span style="color:#25292a;">就是所查找的命令名字，</span><span style="color:#25292a;"> uboot </span><span style="color:#25292a;">中的命令表其实就是</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">结构体数组，通过函数</span><span style="color:#25292a;"> ll_entry_start </span><span style="color:#25292a;">得到数组的第一个元素，也就是命令表起始地址。通过函数</span><span style="color:#25292a;"> ll_entry_count</span><span style="color:#25292a;">得到数组长度，也就是命令表的长度。最终通过函数</span><span style="color:#25292a;"> find_cmd_tbl </span><span style="color:#25292a;">在命令表中找到所需的命令，每个命令都有一个</span><span style="color:#25292a;"> name </span><span style="color:#25292a;">成员，所以将参数</span><span style="color:#25292a;"> cmd </span><span style="color:#25292a;">与命令表中每个成员的</span><span style="color:#25292a;"> name </span><span style="color:#25292a;">字段都对比一下，如果相等的话就说明找到了这个命令，找到以后就返回这个命令。</span><br><span style="color:#25292a;">回到</span><span style="color:#25292a;"> cmd_process </span><span style="color:#25292a;">函数中，找到命令以后肯定就要执行这个命令了，第</span><span style="color:#25292a;"> 533 </span><span style="color:#25292a;">行调用函数</span><span style="color:#25292a;"> cmd_call </span><span style="color:#25292a;">来执行具体的命令，</span><span style="color:#25292a;"> cmd_call </span><span style="color:#25292a;">函数内容如下：</span></span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="178" src="https://images2.imgbox.com/52/72/Pz4EDGCF_o.png" width="850"></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#25292a;">在前面的分析中我们知道，</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> cmd </span><span style="color:#25292a;">成员就是具体的命令处理函数，所以第</span><span style="color:#25292a;"> 494 </span><span style="color:#25292a;">行调用</span><span style="color:#25292a;"> cmdtp </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> cmd </span><span style="color:#25292a;">成员来处理具体的命令，返回值为命令的执行结果。</span><span style="color:#25292a;">cmd_process </span><span style="color:#25292a;">中会检测</span><span style="color:#25292a;"> cmd_tbl </span><span style="color:#25292a;">的返回值，如果返回值为</span><span style="color:#25292a;"> CMD_RET_USAGE </span><span style="color:#25292a;">的话就会调用</span><span style="color:#25292a;">cmd_usage </span><span style="color:#25292a;">函数输出命令的用法，其实就是输出</span><span style="color:#25292a;"> cmd_tbl_t </span><span style="color:#25292a;">的</span><span style="color:#25292a;"> usage </span><span style="color:#25292a;">成员变量。</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/483cc619a468e02022d1c1d86e644f0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">马氏距离与卡方分布</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f85bf39fcdc6f85e3869ea86e068abc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue谷歌浏览器cookie跨域问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>