<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络编程基础 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络编程基础" />
<meta property="og:description" content="网络编程 1.1 概述 计算机网络：
计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路和通信设备连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
网络编程的目的：
传播交流信息，数据交换通信 想要达到这个效果需要什么：
如何准确的定位网络上的一台主机 42.242.225.253:端口号，定位到这个计算机上的某个资源找到了这个主机，如何传输数据？ Java Web 网页编程 B/S
TCP/IP 网络编程 C/S
1.2 网络通信的要素 如何实现网络的通信？
通信双方的地址：
IP端口号 规则：网络通信的协议
TCP/IP参考模型
小结：
网络编程中有两个主要的问题
如何准确的定位到网络上的一台或者多台主机 IP ping命令一般会发四个包
PS C:\Users\kevin\Desktop&gt; ping www.baidu.com 正在 Ping www.a.shifen.com [14.119.104.189] 具有 32 字节的数据: 来自 14.119.104.189 的回复: 字节=32 时间=38ms TTL=54 来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54 来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54 来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54 14.119.104.189 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 36ms，最长 = 38ms，平均 = 36ms PS C:\Users\kevin\Desktop&gt; 找到主机之后如何进行通信" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e23a4dbbbd155360c4a9d30845233964/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T17:31:53+08:00" />
<meta property="article:modified_time" content="2023-06-12T17:31:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络编程基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>网络编程</h2> 
<h3><a id="11__2"></a>1.1 概述</h3> 
<p>计算机网络：</p> 
<p>计算机网络是指将<a href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/797988?fromModule=lemma_inlink" rel="nofollow">地理位置</a>不同的具有独立功能的多台计算机及其<a href="https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87/3741161?fromModule=lemma_inlink" rel="nofollow">外部设备</a>，通过<a href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/1527630?fromModule=lemma_inlink" rel="nofollow">通信线路</a>和通信设备连接起来，在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997?fromModule=lemma_inlink" rel="nofollow">网络操作系统</a>，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078?fromModule=lemma_inlink" rel="nofollow">网络管理软件</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611?fromModule=lemma_inlink" rel="nofollow">网络通信协议</a>的管理和协调下，实现<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480?fromModule=lemma_inlink" rel="nofollow">资源共享</a>和<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92/8232801?fromModule=lemma_inlink" rel="nofollow">信息传递</a>的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/7210959?fromModule=lemma_inlink" rel="nofollow">计算机系统</a>。</p> 
<p>网络编程的目的：</p> 
<ul><li>传播交流信息，数据交换</li><li>通信</li></ul> 
<p>想要达到这个效果需要什么：</p> 
<ol><li>如何准确的定位网络上的一台主机 42.242.225.253:端口号，定位到这个计算机上的某个资源</li><li>找到了这个主机，如何传输数据？</li></ol> 
<p>Java Web 网页编程 B/S</p> 
<p>TCP/IP 网络编程 C/S</p> 
<h3><a id="12__24"></a>1.2 网络通信的要素</h3> 
<p>如何实现网络的通信？</p> 
<p>通信双方的地址：</p> 
<ul><li>IP</li><li>端口号</li></ul> 
<p>规则：网络通信的协议</p> 
<p>TCP/IP参考模型</p> 
<p><img src="https://images2.imgbox.com/e8/fc/Bi8XsDQH_o.png" alt="image-20230608214257346"></p> 
<p>小结：</p> 
<ol><li> <p>网络编程中有两个主要的问题</p> 
  <ul><li> <p>如何准确的定位到网络上的一台或者多台主机 IP ping命令一般会发四个包</p> <pre><code>PS C:\Users\kevin\Desktop&gt; ping www.baidu.com

正在 Ping www.a.shifen.com [14.119.104.189] 具有 32 字节的数据:
来自 14.119.104.189 的回复: 字节=32 时间=38ms TTL=54
来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54
来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54
来自 14.119.104.189 的回复: 字节=32 时间=36ms TTL=54

14.119.104.189 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 36ms，最长 = 38ms，平均 = 36ms
PS C:\Users\kevin\Desktop&gt;
</code></pre> </li><li> <p>找到主机之后如何进行通信</p> </li></ul> </li><li> <p>网络编程中的要素</p> 
  <ul><li>IP和端口号</li><li>网络通信协议</li></ul> </li><li> <p>万物皆对象</p> </li></ol> 
<h3><a id="13_IP_70"></a>1.3 IP</h3> 
<p>ip地址：InetAddress</p> 
<ul><li>唯一定位一台网络上的计算机</li><li>127.0.0.1：本机 localhost</li><li>ip地址的分类 
  <ul><li>IP地址分类：ipv4/ipv6 
    <ul><li>IPV4 127.0.0.1 4个字节组成 0~255 42亿个地址：30亿都在北美，亚洲只有4亿。2011年就用尽了</li><li>IPV6 CDCD:910A:2222:5498:8475:1111:3900:2020 128位。8个无符号整数！</li></ul> </li><li>公网（互联网）/私网（局域网） 
    <ul><li>192.168.xx.xx</li><li>ABCD类地址</li></ul> </li></ul> </li><li>域名：记忆IP问题 
  <ul><li>IP：www.baidu.com</li></ul> </li></ul> 
<pre><code>package com.shu.ip;

import java.net.InetAddress;
import java.net.UnknownHostException;

//测试ip
public class TestInetAddress {
    public static void main(String[] args) {
        try {
            //查询本机IP地址
            InetAddress localhost1 = InetAddress.getByName("127.0.0.1");
            InetAddress localhost2 = InetAddress.getByName("localhost");
            InetAddress localhost3 = InetAddress.getLocalHost();
            //查询网站IP地址：百度
            InetAddress baidu = InetAddress.getByName("www.baidu.com");
            System.out.println();
            System.out.println("localhost1: "+ localhost1);
            System.out.println("localhost2: "+ localhost2);
            System.out.println("localhost3: "+ localhost3);
            System.out.println("baidu: "+ baidu);
            System.out.println();
            //常用方法
            System.out.println(baidu.getAddress());   //返回一个字节数组
            System.out.println(baidu.getCanonicalHostName());   //规范的名字
            System.out.println(baidu.getHostAddress());  //ip
            System.out.println(baidu.getHostName());   //域名，或者自己电脑的名字
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<pre><code>localhost1: /127.0.0.1
localhost2: localhost/127.0.0.1
localhost3: LAPTOP-XIAOSHU/192.168.80.1
baidu: www.baidu.com/14.119.104.189

[B@1b6d3586
14.119.104.189
14.119.104.189
www.baidu.com
</code></pre> 
<h3><a id="14__132"></a>1.4 端口</h3> 
<p>端口表示计算机上的一个程序的进程pid</p> 
<ul><li> <p>不同的进程有不同的端口号！用来区分软件！</p> </li><li> <p>被规定 0~65535</p> </li><li> <p>TCP/UDP: 65535*2 TCP:80 UDP:80 单个协议下，端口号不能冲突</p> </li><li> <p>端口分类：</p> 
  <ul><li> <p>公有端口：0~1023</p> 
    <ul><li>http：80</li><li>https：443</li><li>ftp：21</li><li>Telent：23</li></ul> </li><li> <p>程序注册端口：1024~49151，分配给用户或者程序</p> 
    <ul><li>Tomcat:8080</li><li>MySQL:3306</li><li>Oracle:1521</li></ul> </li><li> <p>动态、私有端口：49152~65535</p> <pre><code>netstat -ano   #查看所有端口
netstat -ano|findstr "55021"  #查看指定的端口 |:管道流，过滤的意思  先执行netstat -ano，然后在结果中再执行findstr "55021" 
tasklist|findstr "10832" #查看指定端口的进程

PS C:\Users\kevin\Desktop&gt; 
QQ.exe                       10832 Console                    1     63,728 K
PS C:\Users\kevin\Desktop&gt;
</code></pre> </li></ul> </li></ul> 
<pre><code>package com.shu.ip;

import java.net.InetSocketAddress;

public class TestInetSocketAddress {
    public static void main(String[] args) {
        InetSocketAddress inetSocketAddress1 = new InetSocketAddress("127.0.0.1", 8080);
        InetSocketAddress inetSocketAddress2 = new InetSocketAddress("localhost", 8080);
        System.out.println(inetSocketAddress1);
        System.out.println(inetSocketAddress2);
        System.out.println();
        System.out.println(inetSocketAddress1.getAddress());  //ip
        System.out.println(inetSocketAddress1.getHostName()); //地址
        System.out.println(inetSocketAddress1.getPort()); //端口
    }
}
</code></pre> 
<pre><code>/127.0.0.1:8080
localhost/127.0.0.1:8080

/127.0.0.1
activate.navicat.com
8080
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/d6/fvW4CdU5_o.png" alt="image-20230609095103470"></p> 
<p><img src="https://images2.imgbox.com/3a/bb/KbhYpDRv_o.png" alt="image-20230609095123725"></p> 
<h3><a id="15__202"></a>1.5 通信协议</h3> 
<p>协议：约定，就好比我们现在说的普通话。是一种规范</p> 
<p>网络通信协议：速率，传输码率，代码结构，传输控制…</p> 
<p><strong>TCP/IP协议簇：实际上是一组协议</strong></p> 
<p>重要：</p> 
<ul><li>TCP：用户传输协议</li><li>UDP：用户数据报协议</li></ul> 
<p>出名的协议：</p> 
<ul><li>TCP：</li><li>IP：网络互连协议</li></ul> 
<p><strong>TCP UDP 对比</strong></p> 
<p>TCP：打电话</p> 
<ul><li> <p>连接 稳定</p> </li><li> <p>三次握手 四次挥手</p> <pre><code>最少需要三次，保证稳定连接！
A：你瞅啥？
B：瞅你咋地！
A：干一场！

A：我要走了！
B：你真的要走了吗？
B：你真的真的要走了吗？
A：我真的要走了！
</code></pre> </li><li> <p>客户端 服务端</p> </li><li> <p>传输完成，释放连接，效率低</p> </li></ul> 
<p>UDP：发短信</p> 
<ul><li>不连接 不稳定</li><li>客户端 服务端：没有明确的界限</li><li>不管有没有准备好，都可以发给你</li><li>导弹</li><li>DDOS：洪泛攻击！饱和攻击</li></ul> 
<h3><a id="16_TCP_254"></a>1.6 TCP</h3> 
<p>客户端</p> 
<pre><code>package com.shu.tcp;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

//客户端
public class TcpClientDemo01 {
    public static void main(String[] args) {
        Socket socket = null;
        OutputStream outputStream = null;
        try {
            //1、要知道服务器的地址
            InetAddress serverIp = InetAddress.getByName("127.0.0.1");
            //2、端口号
            int port = 9999;
            //3、创建一个socket连接
            socket = new Socket(serverIp,port);
            //4、发送消息 IO流
            outputStream = socket.getOutputStream();
            outputStream.write("你好".getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            //关闭资源
            if(outputStream != null){
                try {
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket != null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre> 
<p>服务器</p> 
<pre><code>package com.shu.tcp;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端
public class TcpServerDemo01 {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket socket = null;
        InputStream inputStream = null;
        ByteArrayOutputStream byteArrayOutputStream = null;
        try {
            //1、我得有一个地址
            serverSocket = new ServerSocket(9999);
            //2、等待客户端连接过来
            socket = serverSocket.accept();
            //3、读取客户端的消息
            inputStream = socket.getInputStream();

            //管道流
            byteArrayOutputStream = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while ((len = inputStream.read(buffer))!= -1){
                byteArrayOutputStream.write(buffer,0,len);
            }
            System.out.println("服务器收到了：" + byteArrayOutputStream.toString());

        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            //关闭资源
            if(byteArrayOutputStream != null){
                try {
                    byteArrayOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(inputStream != null){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket != null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(serverSocket != null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre> 
<h4><a id="161___377"></a>1.6.1 文件上传</h4> 
<p>客户端</p> 
<pre><code>package com.shu.tcp;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

//客户端
public class TcpClientDemo02 {
    public static void main(String[] args) {
        try {
            //1、创建一个socket连接
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9000);
            //2、创建一个输出流
            OutputStream outputStream = socket.getOutputStream();

            String rootPath = System.getProperty("user.dir");
            System.out.println("Compiler root path: " + rootPath);

            String path = rootPath+"/网络编程/src/Go.jpg";
            File file = new File(path);
            System.out.println(file);
            //3、读取文件
            FileInputStream fileInputStream = new FileInputStream(file);
            //4、写出文件
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fileInputStream.read(buffer))!=-1){
                outputStream.write(buffer,0,len);
            }

            //通知服务器，我已经结束了
            socket.shutdownOutput();  //我已经传输完了
            //确定服务器接收完毕，才能够断开连接
            InputStream inputStream = socket.getInputStream();
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            byte[] buffer2 = new byte[1024];
            int len2;
            while ((len2 = inputStream.read(buffer2))!=-1){
                byteArrayOutputStream.write(buffer2,0,len2);
            }

            byteArrayOutputStream.close();
            inputStream.close();
            System.out.println(byteArrayOutputStream.toString());

            fileInputStream.close();
            outputStream.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>服务器</p> 
<pre><code>package com.shu.tcp;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

//客户端
public class TcpClientDemo02 {
    public static void main(String[] args) {
        try {
            //1、创建一个socket连接
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9000);
            //2、创建一个输出流
            OutputStream outputStream = socket.getOutputStream();

            String rootPath = System.getProperty("user.dir");
            System.out.println("Compiler root path: " + rootPath);

            String path = rootPath+"/网络编程/src/Go.jpg";
            File file = new File(path);
            System.out.println(file);
            //3、读取文件
            FileInputStream fileInputStream = new FileInputStream(file);
            //4、写出文件
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fileInputStream.read(buffer))!=-1){
                outputStream.write(buffer,0,len);
            }

            //通知服务器，我已经结束了
            socket.shutdownOutput();  //我已经传输完了
            //确定服务器接收完毕，才能够断开连接
            InputStream inputStream = socket.getInputStream();
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            byte[] buffer2 = new byte[1024];
            int len2;
            while ((len2 = inputStream.read(buffer2))!=-1){
                byteArrayOutputStream.write(buffer2,0,len2);
            }

            byteArrayOutputStream.close();
            inputStream.close();
            System.out.println(byteArrayOutputStream.toString());

            fileInputStream.close();
            outputStream.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/07/1d/6peT6QTp_o.png" alt="image-20230610093307048"></p> 
<h4><a id="162_Tomcat_497"></a>1.6.2 Tomcat</h4> 
<p>服务端</p> 
<ul><li>自定义 S</li><li>Tomcat服务器 S</li></ul> 
<p>客户端</p> 
<ul><li>自定义 C</li><li>浏览器 B</li></ul> 
<ol><li>Tomcat启动</li></ol> 
<p><img src="https://images2.imgbox.com/fd/06/ZHHMzVzq_o.png" alt="image-20230610104219001"></p> 
<ol start="2"><li>Tomcat自定义启动端口号</li></ol> 
<p><img src="https://images2.imgbox.com/e5/66/PQDJI2Ld_o.png" alt="image-20230610104322428"></p> 
<ol start="3"><li>Windows下中文乱码处理</li></ol> 
<p><img src="https://images2.imgbox.com/29/3f/v63qy18r_o.png" alt="image-20230610104453477"></p> 
<h3><a id="17_UDP_521"></a>1.7 UDP</h3> 
<p>UDP没有客户端、服务端的概念。</p> 
<h4><a id="171__525"></a>1.7.1 发送消息</h4> 
<p>发送端</p> 
<pre><code>package com.shu.udp;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

//不需要连接服务器
public class UdpClientDemo01 {
    public static void main(String[] args) throws Exception {
        //1、建立一个socket
        //DatagramSocket datagramSocket = new DatagramSocket();
        DatagramSocket datagramSocket = new DatagramSocket(8080);
        //2、建个包
        String msg = "你好啊，服务器！";
        //发送给谁
        InetAddress localhost = InetAddress.getByName("localhost");
        int port = 9090;
        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);
        //3、发送包
        datagramSocket.send(datagramPacket);
        datagramSocket.close();
    }
}
</code></pre> 
<p>接收端</p> 
<pre><code>package com.shu.udp;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
//还是要等待客户端的连接
public class UdpServerDemo01 {
    public static void main(String[] args) throws Exception {
        //开放端口
        DatagramSocket datagramSocket = new DatagramSocket(9090);
        //接收数据包
        byte[] buffer = new byte[1024];
        DatagramPacket datagramPacket = new DatagramPacket(buffer, 0, buffer.length);
        datagramSocket.receive(datagramPacket);  //阻塞接收

        System.out.println(datagramPacket.getAddress().getHostAddress());
        System.out.println(new String(datagramPacket.getData(),0,datagramPacket.getLength()));
        datagramSocket.close();
    }
}
</code></pre> 
<h4><a id="172__580"></a>1.7.2 咨询</h4> 
<pre><code>package com.shu.chat;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class UdpSenderDemo01 {
    public static void main(String[] args) throws Exception {
        DatagramSocket datagramSocket = new DatagramSocket(8888);
        //准备数据：控制台读取 System.in
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        while (true){
            String data = bufferedReader.readLine();
            byte[] datas = data.getBytes();
            DatagramPacket datagramPacket = new DatagramPacket(datas,0,datas.length,new InetSocketAddress("localhost",6666));
            datagramSocket.send(datagramPacket);

            if(data.equals("bye")){
                break;
            }
        }

        datagramSocket.close();
    }
}
</code></pre> 
<pre><code>package com.shu.chat;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class UdpReceiverDemo01 {
    public static void main(String[] args) throws Exception {
        DatagramSocket datagramSocket = new DatagramSocket(6666);

        while (true){
            //准备接收包裹
            byte[] container = new byte[1024];
            DatagramPacket datagramPacket = new DatagramPacket(container,0,container.length);

            datagramSocket.receive(datagramPacket);  //阻塞式接收
            //断开连接
            byte[] data = datagramPacket.getData();
            String receiveData = new String(data, 0, data.length);

            System.out.println(receiveData);
            if(receiveData.equals("bye")){
                break;
            }

        }
        datagramSocket.close();
    }
}
</code></pre> 
<p><strong>在线咨询：两个人都可以式发送方，也都可以是接收方</strong></p> 
<p>发送方</p> 
<pre><code>package com.shu.chat;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;

public class TalkSend implements Runnable{
    DatagramSocket datagramSocket = null;
    BufferedReader bufferedReader = null;

    private int fromPort;
    private String toIp;
    private int toPort;

    public TalkSend(int fromPort, String toIp, int toPort) {
        this.fromPort = fromPort;
        this.toIp = toIp;
        this.toPort = toPort;

        try{
            datagramSocket = new DatagramSocket(fromPort);
            bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        }
        catch (Exception e){
            e.printStackTrace();
        }

    }

    @Override
    public void run() {

        while (true){
            String data = null;
            try {
                data = bufferedReader.readLine();
                byte[] datas = data.getBytes();
                DatagramPacket datagramPacket = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIp,this.toPort));
                datagramSocket.send(datagramPacket);

                if(data.equals("bye")){
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

        datagramSocket.close();
    }
}
</code></pre> 
<p>接收方</p> 
<pre><code>package com.shu.chat;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class TalkReceive implements Runnable{
    DatagramSocket datagramSocket = null;

    private int port;
    private String msgFrom;
    public TalkReceive(int port,String msgFrom) {
        this.port = port;
        this.msgFrom = msgFrom;
        try {
            datagramSocket = new DatagramSocket(port);
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {

        while (true){
            try {
                //准备接收包裹
                byte[] container = new byte[1024];
                DatagramPacket datagramPacket = new DatagramPacket(container,0,container.length);

                datagramSocket.receive(datagramPacket);  //阻塞式接收
                //断开连接
                byte[] data = datagramPacket.getData();
                String receiveData = new String(data, 0, data.length);

                System.out.println(msgFrom+"："+receiveData);
                if(receiveData.equals("bye")){
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
        datagramSocket.close();
    }
}
</code></pre> 
<p>学生端</p> 
<pre><code>package com.shu.chat;

public class TalkStudent {
    public static void main(String[] args) {
        //开启两个线程
        new Thread(new TalkSend(7777,"localhost",9999)).start();
        new Thread(new TalkReceive(8888,"老师")).start();
    }
}
</code></pre> 
<p>老师端</p> 
<pre><code>package com.shu.chat;

public class TalkTeacher {
    public static void main(String[] args) {
        new Thread(new TalkSend(5555,"localhost",8888)).start();
        new Thread(new TalkReceive(9999,"学生")).start();
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/0c/38/p0RZvewZ_o.png" alt="image-20230612113804757"></p> 
<h3><a id="18_URL_790"></a>1.8 URL</h3> 
<p>https://www.baidu.com/</p> 
<p>URL：统一资源定位符。定位资源的，定位互联网上的某一个资源</p> 
<p>DNS域名解析 www.baidu.com --&gt; xxx.xxx.xxx.xxx</p> 
<pre><code>协议://ip地址:端口/项目名/资源
</code></pre> 
<pre><code>package com.shu.url;

import java.net.MalformedURLException;
import java.net.URL;

public class UrlDemo01 {
    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://localhost:8080/helloworld/index.jsp?username=xiaoshu&amp;pwd=123");
        System.out.println(url.getProtocol());   //得到协议名
        System.out.println(url.getHost());  //主机ip
        System.out.println(url.getPort());  //端口
        System.out.println(url.getPath());  //文件路径
        System.out.println(url.getFile());  //全路径
        System.out.println(url.getQuery()); //参数
    }
}
</code></pre> 
<pre><code>http
localhost
8080
/helloworld/index.jsp
/helloworld/index.jsp?username=xiaoshu&amp;pwd=123
username=xiaoshu&amp;pwd=123
</code></pre> 
<p>下载网络资源</p> 
<pre><code>package com.shu.url;

import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class UrlDown {
    public static void main(String[] args) throws Exception {
        //1.下载地址
        //URL url = new URL("http://localhost:8080/xiaoshu/SecurityFile.txt");
        //URL url = new URL("https://p2.music.126.net/TmOHxaGnFNlwNX8aPz66oA==/109951168638913915.jpg?param=200y200");
        //URL url = new URL("https://m801.music.126.net/20230612143122/c1b529f89cd6159b6be1cc0c49bd0752/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/28133411020/b5d7/3857/ac5c/1274e257b2e91849e3290c8b53709ba5.m4a");
        URL url = new URL("https://m701.music.126.net/20230612151545/0eca07048cfb060e64aaa244d40ccc3c/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/23899224434/4ccf/d853/e041/57604a1cd303c3df46cf1ce5e8b8035d.m4a");
        //2.连接到这个资源 HTTP
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
        InputStream inputStream = urlConnection.getInputStream();
        //FileOutputStream fileOutputStream = new FileOutputStream("SecurityFile.txt");
        FileOutputStream fileOutputStream = new FileOutputStream("世界欠你一个微笑^_^.m4a");

        byte[] buffer = new byte[1024];
        int len;
        while ((len=inputStream.read(buffer))!=-1){
            fileOutputStream.write(buffer,0,len);   //写出这个数据
        }
        fileOutputStream.close();
        inputStream.close();
        urlConnection.disconnect();  //断开连接
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5790c82a07e596f8f27c712ead5d243a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GStreamer for Ethernet AVB</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be3538653a5c72a3e3bfce0446ba71b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">下载huggingface-transformers模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>