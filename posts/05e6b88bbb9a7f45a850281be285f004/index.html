<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字符设备驱动基础 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="字符设备驱动基础" />
<meta property="og:description" content="目录 一、开启驱动开发之路1、驱动开发的准备工作2、驱动开发的步骤3、实践 二、最简单的模块源码分析1、常用的模块操作命令2、模块的安装3、模块的版本信息4、模块源码函数分析5、模块卸载6、模块中常用宏7、函数修饰符8、printk函数详解9、关于驱动模块中的头文件10、驱动编译的Makefile分析 三、用开发板来调试模块四、字符设备驱动工作原理1、系统整体工作原理2、file_operations结构体（和文件操作有关）3、注册字符设备驱动4、register_chrdev详解(#include 一、开启驱动开发之路 1、驱动开发的准备工作 (1)正常运行linux系统的开发板。要求开发板中的linux的zImage必须是自己编译的，不能是别人编译的。因为需要一个内核源码树。
(2)内核源码树，其实就是一个经过了配置编译之后的内核源码。编译驱动时，需要用到内核源码树。内核源代码树 就是内核源代码。 编译模块，需要内核源码。
(3)nfs挂载的rootfs，主机ubuntu中必须搭建一个nfs服务器。
1.nfs方式启动，挂载根文件系统；
2.将根文件系统烧录进开发板，正常启动，启动后通过mount命令挂载；
2、驱动开发的步骤 (1)驱动源码编写、Makefile编写（有着固定的模式，可以参考已有的编写）、编译
(2)insmod装载模块m动态安装驱动）、测试（完整的驱动是为了被应用程序调用，驱动封装成API函数，被应用程序调用来工作）、rmmod卸载模块
3、实践 (1)copy开发板的内核源码，找一个干净的目录（比如/root/driver），解压之，并且配置编译。编译完成后得到了：
&lt;1&gt;内核源码树（/root/driver/kernel）
&lt;2&gt;编译好的zImage
编译步骤1.修改makefile，指定架构和交叉编译链目录
编译步骤2.make x210ii_qt_defconfig(记不住，报错会有提示make的目标在那个目录)
(2)使用fastboot工具将第1步中得到的zImage烧录到开发板中去启动（或者将zImage丢到tftp的共享目录，uboot启动时tftp下载启动），将来驱动编译好后，就可以在这个内核中去测试。因为这个zImage和内核源码树是一伙的，所以驱动安装时版本校验不会出错（否则有可能会出错）。
编译驱动文件最后生成的需要的是.ko文件（kernel object），驱动文件。
二、最简单的模块源码分析 //module_test.c #include &lt;linux/module.h&gt;	// module_init module_exit #include &lt;linux/init.h&gt;	// __init __exit // 模块安装函数 static int __init chrdev_init(void) {	printk(KERN_INFO &#34;chrdev_init helloworld init\n&#34;); //printk(&#34;&lt;7&gt;&#34; &#34;chrdev_init helloworld init\n&#34;); //printk(&#34;&lt;7&gt; chrdev_init helloworld init\n&#34;); return 0; } // 模块卸载函数 static void __exit chrdev_exit(void) { printk(KERN_INFO &#34;chrdev_exit helloworld exit\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/05e6b88bbb9a7f45a850281be285f004/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-20T17:02:51+08:00" />
<meta property="article:modified_time" content="2022-03-20T17:02:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字符设备驱动基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、开启驱动开发之路</a></li><li><ul><li><a href="#1_2" rel="nofollow">1、驱动开发的准备工作</a></li><li><a href="#2_10" rel="nofollow">2、驱动开发的步骤</a></li><li><a href="#3_14" rel="nofollow">3、实践</a></li></ul> 
  </li><li><a href="#_28" rel="nofollow">二、最简单的模块源码分析</a></li><li><ul><li><a href="#1_61" rel="nofollow">1、常用的模块操作命令</a></li><li><a href="#2_73" rel="nofollow">2、模块的安装</a></li><li><a href="#3_81" rel="nofollow">3、模块的版本信息</a></li><li><a href="#4_92" rel="nofollow">4、模块源码函数分析</a></li><li><a href="#5_102" rel="nofollow">5、模块卸载</a></li><li><a href="#6_108" rel="nofollow">6、模块中常用宏</a></li><li><a href="#7_113" rel="nofollow">7、函数修饰符</a></li><li><a href="#8printk_123" rel="nofollow">8、printk函数详解</a></li><li><a href="#9_139" rel="nofollow">9、关于驱动模块中的头文件</a></li><li><a href="#10Makefile_176" rel="nofollow">10、驱动编译的Makefile分析</a></li></ul> 
  </li><li><a href="#_187" rel="nofollow">三、用开发板来调试模块</a></li><li><a href="#_207" rel="nofollow">四、字符设备驱动工作原理</a></li><li><ul><li><a href="#1_211" rel="nofollow">1、系统整体工作原理</a></li><li><a href="#2file_operations_219" rel="nofollow">2、file_operations结构体（和文件操作有关）</a></li><li><a href="#3_231" rel="nofollow">3、注册字符设备驱动</a></li><li><a href="#4register_chrdevinclude_linuxfsh_248" rel="nofollow">4、register_chrdev详解(#include </a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、开启驱动开发之路</h2> 
<h3><a id="1_2"></a>1、驱动开发的准备工作</h3> 
<p>(1)正常运行linux系统的开发板。要求开发板中的linux的zImage必须是自己编译的，不能是别人编译的。因为需要一个内核源码树。</p> 
<p>(2)内核源码树，其实就是一个经过了配置编译之后的内核源码。编译驱动时，需要用到内核源码树。内核源代码树 就是内核源代码。 编译模块，需要内核源码。</p> 
<p>(3)nfs挂载的rootfs，主机ubuntu中必须搭建一个nfs服务器。<br> 1.nfs方式启动，挂载根文件系统；<br> 2.将根文件系统烧录进开发板，正常启动，启动后通过mount命令挂载；</p> 
<h3><a id="2_10"></a>2、驱动开发的步骤</h3> 
<p>(1)驱动源码编写、Makefile编写（有着固定的模式，可以参考已有的编写）、编译</p> 
<p>(2)insmod装载模块m动态安装驱动）、测试（完整的驱动是为了被应用程序调用，驱动封装成API函数，被应用程序调用来工作）、rmmod卸载模块</p> 
<h3><a id="3_14"></a>3、实践</h3> 
<p>(1)copy开发板的内核源码，找一个干净的目录（比如/root/driver），解压之，并且配置编译。编译完成后得到了：<br> &lt;1&gt;内核源码树（/root/driver/kernel）<br> &lt;2&gt;编译好的zImage</p> 
<p>编译步骤1.修改makefile，指定架构和交叉编译链目录</p> 
<p>编译步骤2.make x210ii_qt_defconfig(记不住，报错会有提示make的目标在那个目录)</p> 
<p>(2)使用fastboot工具将第1步中得到的zImage烧录到开发板中去启动（或者将zImage丢到tftp的共享目录，uboot启动时tftp下载启动），将来驱动编译好后，就可以在这个内核中去测试。因为这个zImage和内核源码树是一伙的，所以驱动安装时版本校验不会出错（否则有可能会出错）。</p> 
<p>编译驱动文件最后生成的需要的是.ko文件（kernel object），驱动文件。</p> 
<h2><a id="_28"></a>二、最简单的模块源码分析</h2> 
<pre><code class="prism language-c"><span class="token comment">//module_test.c</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span>		</span><span class="token comment">// module_init  module_exit</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span>			</span><span class="token comment">// __init   __exit</span>

<span class="token comment">// 模块安装函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chrdev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_init helloworld init\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//printk("&lt;7&gt;" "chrdev_init helloworld init\n");</span>
	<span class="token comment">//printk("&lt;7&gt; chrdev_init helloworld init\n");</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模块卸载函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chrdev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_exit helloworld exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// MODULE_xxx这种宏作用是用来添加模块描述信息</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的许可证</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"aston"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的作者</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"module test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 描述模块的介绍信息</span>
<span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"alias xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 描述模块的别名信息</span>
</code></pre> 
<h3><a id="1_61"></a>1、常用的模块操作命令</h3> 
<p>(1)lsmod(list module,将模块列表显示)，功能是打印出当前内核中已经安装的模块列表</p> 
<p>(2)insmod（install module，安装模块），功能是向当前内核中去安装一个模块，用法是insmod xxx.ko</p> 
<p>(3)modinfo（module information，模块信息），功能是打印出一个内核模块的自带信息。用法是modinfo xxx.ko</p> 
<p>(4)rmmod（remove module，卸载模块），功能是从当前内核中卸载一个已经安装了的模块，用法是rmmod xxx（注意卸载模块时只需要输入模块名即可，不能加.ko后缀）</p> 
<p>(5)modprobe：加载或卸载内核模块，需要根据modules.dep.bin文件进行加载操作，可以自动解决模块间的依赖关系表</p> 
<p>(6)depmod：查找/lib/moduels/(uname -r)/中的所有模块并建立modules.dep.bin文件，该文件记录了模块位置及依赖关系.</p> 
<h3><a id="2_73"></a>2、模块的安装</h3> 
<p>(1)先lsmod再insmod看安装前后系统内模块记录。实践测试标明内核会将最新安装的模块放在lsmod显示的最前面。</p> 
<p>(2)insmod与module_init宏。模块源代码中用module_init宏声明了一个函数（在我们这个例子里是chrdev_init函数），作用就是指定chrdev_init这个函数和insmod命令绑定起来，也就是说当我们insmod module_test.ko时，insmod命令内部实际执行的操作就是帮我们调用chrdev_init函数。</p> 
<p>  照此分析，那insmod时就应该能看到chrdev_init中使用printk打印出来的一个chrdev_init字符串，但是实际没看到。原因是ubuntu中拦截了，要怎么才能看到呢？在ubuntu中使用dmesg命令就可以看到了。</p> 
<p>(3)模块安装时insmod内部除了帮我们调用module_init宏所声明的函数外，实际还做了一些别的事（譬如lsmod能看到多了一个模块也是insmod帮我们在内部做了记录），但是我们就不用管了。</p> 
<h3><a id="3_81"></a>3、模块的版本信息</h3> 
<p>(1)使用modinfo查看模块的版本信息</p> 
<p>(2)内核zImage中也有一个确定的版本信息</p> 
<p>(3)insmod时模块的vermagic必须和内核的相同，否则不能安装，报错信息为：insmod: ERROR: could not insert module module_test.ko: Invalid module format</p> 
<p>(4)模块的版本信息是为了保证模块和内核的兼容性，是一种安全措施</p> 
<p>(5)如何保证模块的vermagic和内核的vermagic一致？<br> 编译模块的内核源码树就是我们编译正在运行的这个内核的那个内核源码树即可。说白了就是模块和内核要同出一门。</p> 
<h3><a id="4_92"></a>4、模块源码函数分析</h3> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> _init <span class="token function">chrdev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> _exit <span class="token function">chrdev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  在编写驱动模块的时候有两个东西经常被使用也必须被使用，分别是module_init和module_exit，这两个分别在加载和卸载驱动时被调用，即调用insmod和rmmod命令的时候，但是insmod和rmmod不能识别这两个，它识别init_module和cleanup_module，其实init_module和cleanup_module相当于是module_init和module_exit的别名</p> 
<h3><a id="5_102"></a>5、模块卸载</h3> 
<p>详解:<br> https://blog.csdn.net/u013216061/article/details/72511653</p> 
<p>(1)module_exit和rmmod的对应关系<br> (2)lsmod查看rmmod前后系统的模块记录变化</p> 
<h3><a id="6_108"></a>6、模块中常用宏</h3> 
<p>(1)MODULE_LICENSE，模块的许可证。一般声明为GPL许可证，而且最好不要少，否则可能会出现莫名其妙的错误（譬如一些明显存在的函数提升找不到）。<br> (2)MODULE_AUTHOR，描述模块的作者<br> (3)MODULE_DESCRIPTION，描述模块的介绍信息<br> (4)MODULE_ALIAS，模块的别名</p> 
<h3><a id="7_113"></a>7、函数修饰符</h3> 
<p>(1)__init，本质上是个宏定义，在内核源代码中就有#define __init xxxx。gcc扩展语法，这个__init的作用就是将被他修饰的函数放入.init.text段中去（本来默认情况下函数是被放入.text段中）。</p> 
<p>  整个内核中的所有的这类函数都会被链接器链接放入.init.text段中，所以所有的内核模块的__init修饰的函数其实是被统一放在一起的。内核启动时统一会加载.init.text段中的这些模块安装函数，加载完后就会把这个段给释放掉以节省内存。</p> 
<p>(2)__exit<br> 作用类似于__init段中，将代码放到一个.exit段中；</p> 
<p>(3)static<br> 该关键字使得修饰函数只在本文件可用；修改了该函数的链接属性</p> 
<h3><a id="8printk_123"></a>8、printk函数详解</h3> 
<p>(1)printk在内核源码中用来打印信息的函数，用法和printf非常相似。</p> 
<p>(2)printk和printf最大的差别：printf是C库函数，是在应用层编程中使用的，不能在linux内核源代码中使用；printk是linux内核源代码中自己封装出来的一个打印函数，是内核源码中的一个普通函数，只能在内核源码范围内使用，不能在应用编程中使用。</p> 
<p>(3)printk相比printf来说还多了个：打印级别的设置。printk的<strong>打印级别是用来控制printk打印的这条信息是否在终端上显示的</strong>。应用程序中的调试信息要么全部打开要么全部关闭，一般用条件编译来实现（DEBUG宏），但是在内核中，因为内核非常庞大，打印信息非常多，有时候整体调试内核时打印信息要么太多找不到想要的，要么一个没有没法调试。所以才有了打印级别这个概念。</p> 
<p>(4)操作系统的命令行中也有一个打印信息级别属性，值为0-7。<br>   <strong>当前操作系统中执行printk的时候会去对比printk中的打印级别和我的命令行中设置的打印级别，小于我的命令行设置级别的信息会被放行打印出来，大于的就被拦截的。</strong><br>   譬如我的ubuntu中的打印级别默认是4，那么printk中设置的级别比4小的就能打印出来，比4大的就不能打印出来。</p> 
<p>查看方法：cat /proc/sys/kernel/printk<br> 修改方法：echo 4 &gt; /proc/sys/kernel/printk</p> 
<p>(5)ubuntu中这个printk的打印级别控制没法实践，ubuntu中不管你把级别怎么设置都不能直接打印出来，必须dmesg命令去查看。</p> 
<h3><a id="9_139"></a>9、关于驱动模块中的头文件</h3> 
<p>(1)驱动源代码中包含的头文件和原来应用编程程序中包含的头文件不是一回事。<br>   应用编程中包含的头文件是应用层的头文件，是应用程序的编译器带来的（譬如gcc的头文件路径在 /usr/include下，这些东西是和操作系统无关的）。驱动源码属于内核源码的一部分，驱动源码中的头文件其实就是内核源代码目录下的include目录下的头文件。</p> 
<p>包含这个目录下的头文件格式为：<br> #include &lt;linux/xxx.h&gt;</p> 
<pre><code class="prism language-bash"><span class="token comment">#Makefile</span>
<span class="token comment">#第一部分</span>
<span class="token comment">#ubuntu的内核源码树，如果要编译在ubuntu中安装的模块就打开这2个</span>
<span class="token comment">#KERN_VER = $(shell uname -r)</span>
<span class="token comment">#KERN_DIR = /lib/modules/$(KERN_VER)/build	</span>

<span class="token comment"># 开发板的linux内核的源码树目录</span>
KERN_DIR <span class="token operator">=</span> /root/driver/kernel

<span class="token comment">#第二部分</span>
obj-m	+<span class="token operator">=</span> module_test.o

<span class="token comment">#第三、四部分</span>
all:
	<span class="token function">make</span> -C <span class="token variable"><span class="token variable">$(</span>KERN_DIR<span class="token variable">)</span></span> M<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span> modules 
<span class="token comment">#	</span>
<span class="token comment"># KERN_DIR表示内核源码目录，这种方式适用于嵌入式开发的交叉编译，KERN_DIR目录中包含了内核驱动模块所需要的各##种头文件及依赖。</span>
<span class="token comment"># -C表示 指定进入指定的目录即KERN_DIR，是内核源代码目录，调用该目录顶层下的Makefile,目标为modules。</span>
<span class="token comment"># M=$(shell pwd )选项让该Makefile在构造modules目标之前返回到模块源代码目录并在当前目录生成obj-m指定的xxx.o目</span>
<span class="token comment">#标模块。	</span>
<span class="token comment">#	</span>

cp:
	<span class="token function">cp</span> *.ko /root/porting_x210/rootfs/rootfs/driver_test

.PHONY: clean	
clean:
	<span class="token function">make</span> -C <span class="token variable"><span class="token variable">$(</span>KERN_DIR<span class="token variable">)</span></span> M<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span> modules clean
</code></pre> 
<h3><a id="10Makefile_176"></a>10、驱动编译的Makefile分析</h3> 
<p>(1)KERN_DIR，变量的值就是我们用来编译这个模块的 内核源码树 的目录</p> 
<p>(2)obj-m += module_test.o，这一行就表示我们要将module_test.c文件编译成一个模块(-m表示模块,-y表示要编译链接进zImage中)</p> 
<p>(3)make -C $(KERN_DIR) M=<code>pwd</code> modules 这个命令用来实际编译模块，工作原理就是：<strong>利用make -C进入到我们指定的内核源码树目录下，然后在源码目录树下借用内核源码中定义的模块编译规则去编译这个模块，编译完成后把生成的文件拷贝到当前目录下，完成编译。</strong></p> 
<p>(4)make clean ，用来清除编译痕迹</p> 
<p>  总结：模块的makefile非常简单，本身并不能完成模块的编译，而是通过make -C进入到内核源码树下(再make modules)借用内核源码的体系来完成模块的编译链接的。这个Makefile本身是非常模式化的，3和4部分是永远不用动的，只有1和2需要动。1是内核源码树的目录，你必须根据自己的编译环境设置；2是要生成的.o文件。</p> 
<h2><a id="_187"></a>三、用开发板来调试模块</h2> 
<p>1、设置uboot的bootcmd使开发板通过tftp下载自己建立的内核源码树编译得到的zImage<br> set bootcmd tftp 0x30008000 zImage;bootm 0x30008000</p> 
<p>2、设置uboot的bootargs使开发板从nfs去挂载rootfs（内核配置记得打开使能nfs形式的rootfs）<br> setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/porting_x210/rootfs/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC2,115200</p> 
<p>根据自己的文件目录进行修改。</p> 
<p>3、修改Makefile中的KERN_DIR使其指向自己建立的内核源码树</p> 
<p>4、将自己编译好的驱动.ko文件放入nfs共享目录下去</p> 
<p>5、开发板启动后使用insmod、rmmod、lsmod等去进行模块实验</p> 
<p>  若使用modinfo失败，百度搜索解决方法：https://blog.csdn.net/weixin_39888281/article/details/93136861</p> 
<p>  尝试修改printk打印级别，使得程序的打印信息可以在调用命令（本质上是调用执行程序module_test.c中的函数）时打印出来。</p> 
<h2><a id="_207"></a>四、字符设备驱动工作原理</h2> 
<p>模块是一种机制。驱动使用了这种机制。</p> 
<h3><a id="1_211"></a>1、系统整体工作原理</h3> 
<p>(1)应用层-&gt;API-&gt;设备驱动-&gt;硬件</p> 
<p>(2)API：open、read、write、close等</p> 
<p>(3)驱动源码中提供真正的open、read、write、close等函数实体</p> 
<h3><a id="2file_operations_219"></a>2、file_operations结构体（和文件操作有关）</h3> 
<p>  结构体file_operations在头文件linux/fs.h中定义，用来存储驱动模块提供的对设备进行各种操作的函数的指针。该结构体的每个元素都对应着驱动模块用来处理某个被请求的 事务的函数的地址。</p> 
<p>详解：https://www.cnblogs.com/sunyubo/archive/2010/12/22/2282079.html<br> http://www.voidcn.com/article/p-vtmfwdfb-dm.html</p> 
<p>(1)元素主要是函数指针，用来挂接实体函数（真正做事的函数）地址</p> 
<p>(2)每个设备驱动都需要一个该结构体类型的变量</p> 
<p>(3)设备驱动向内核注册时提供该结构体类型的变量</p> 
<h3><a id="3_231"></a>3、注册字符设备驱动</h3> 
<p>(1)为何要注册驱动<br> 否则应用程序调用无法找到驱动</p> 
<p>(2)谁去负责注册<br> 驱动本身</p> 
<p>(3)向谁注册<br> 向内核注册</p> 
<p>(4)注册函数（register_chrdev）从哪里来<br> 从内核来</p> 
<p>(5)注册前怎样？注册后怎样？注册产生什么结果？<br> 内核会向其发放一个证明（例如数字编号），使得应用程序可以找到并调用驱动</p> 
<h3><a id="4register_chrdevinclude_linuxfsh_248"></a>4、register_chrdev详解(#include &lt;linux/fs.h&gt;)</h3> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">register_chrdev</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> major<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
				  <span class="token keyword">const</span> <span class="token keyword">struct</span> file_operations <span class="token operator">*</span>fops<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> __reg <span class="token function">ister_chrdev</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>(1)作用，驱动向内核注册自己的file_operations</p> 
<p>(2)参数<br> major:用于动态分配的主要设备号，参数major如果等于0，则表示采用系统动态分配的主设备号；不为0，则表示静态注册。</p> 
<p>name:这一系列设备的名称</p> 
<p>fops:与此设备相关联的文件操作</p> 
<p>(3)inline和static<br>   inline修饰符，表示为内联函数。<strong>inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。</strong></p> 
<p>   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，<strong>每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</strong></p> 
<p>  将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.</p> 
<p>  静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。<strong>且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。变量在全局数据区分配内存空间；编译器自动对其初始化其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束</strong>。</p> 
<h3><a id="5_276"></a>5、内核如何管理字符设备驱动</h3> 
<p>(1)内核中有一个数组(结构体数组，同时最多装载255个，但不可能255个字符设备驱动同时工作，一般连十个都不会超过)用来存储注册的字符设备驱动</p> 
<p>(2)register_chrdev内部将我们要注册的驱动的信息（主要是 ）存储在数组中相应的位置</p> 
<p>(3)cat /proc/devices查看内核中已经注册过的字符设备驱动（和块设备驱动）</p> 
<p>(4)好好理解主设备号（major）的概念<br>   多重含义，设备的编号，设备数组的下标（应该减一，从一开始计数的），多个设备的主设备号相同，表明几者之间是有关联的</p> 
<h3><a id="6proc_286"></a>6、/proc文件系统的作用</h3> 
<p>  <strong>其内的文件是内核用数据结构虚拟出来的.Proc文件系统是一个伪文件系统，做为一个特殊接口来访问内核，常常挂载在/proc下，里面的大多数文件时只读的，但是我们仍然可以设置其中一些变量来改变内核设置。</strong></p> 
<p>详解： https://blog.csdn.net/acs713/article/details/78887800<br>     https://blog.csdn.net/qq_42014600/article/details/90301888</p> 
<p>  <strong>/proc文件系统提供了一个基于文件的Linux 内部接口。它可以用于确定系统的各种不同设备和进程的状态。</strong></p> 
<p>  <strong>/proc文件系统是一种特殊的、由软件创建的文件系统，内核使用它向外界导出信息，/proc系统只存在内存当中，而不占用磁盘空间。</strong></p> 
<p>  <strong>/proc下面的每个文件都绑定于一个内核函数，用户读取文件时，该函数动态地生成文件的内容。也可以通过写/proc文件修改内核参数</strong></p> 
<h2><a id="_298"></a>五、字符设备驱动代码实践</h2> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>Linux 驱动常见错误返回值<span class="token punctuation">:</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>encourage2011<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">53680056</span>

<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>module license <span class="token string">'unspecified'</span> taints kernel
解决方法<span class="token punctuation">:</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>qq_37600027<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">100797451</span>

<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token function">unregister_chrdev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">--</span> 老版本字符设备注销函数

功能：注销设备

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">unregister_chrdev</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> major<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">__unregister_chrdev</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
说明：
注销设备驱动程序的内核函数

变量：
major 主设备号
name 设备文件
</code></pre> 
<h3><a id="1_320"></a>1、思路和框架</h3> 
<p>(1)目的：给空模块添加驱动壳子</p> 
<p>(2)核心工作量：file_operations及其元素填充、注册驱动</p> 
<h3><a id="2_325"></a>2、如何动手写驱动代码</h3> 
<p>(1)脑海里先有框架，知道自己要干嘛</p> 
<p>(2)细节代码不需要一个字一个字敲，可以到内核中去寻找参考代码复制过来改</p> 
<p>(3)写下的所有代码必须心里清楚明白，不能似懂非懂</p> 
<h3><a id="3_332"></a>3、开始动手</h3> 
<p>(1)先定义file_operations结构体变量<br> Linux 内核驱动中的指定初始化详解：https://zhuanlan.zhihu.com/p/55768099</p> 
<p>eg:<br> 跟数组类似，在标准 C 中，结构体变量的初始化也要按照固定的顺序。在 GNU C 中我们也可以通过结构域来初始化指定某个成员。</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> student<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> student stu1<span class="token operator">=</span><span class="token punctuation">{<!-- --></span> <span class="token string">"wit"</span><span class="token punctuation">,</span><span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s:%d\n"</span><span class="token punctuation">,</span>stu1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>stu1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> student stu2<span class="token operator">=</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"wanglitao"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>age  <span class="token operator">=</span> <span class="token number">28</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s:%d\n"</span><span class="token punctuation">,</span>stu2<span class="token punctuation">.</span>name<span class="token punctuation">,</span>stu2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  在程序中，我们定义一个结构体类型 student，然后分别定义两个结构体变量 stu1 和 stu2。初始化 stu1 时，我们采用标准 C 的初始化方式，即按照固定顺序直接初始化。初始化 stu2 时，我们采用 GNU C 的初始化方式，通过结构域名 .name 和 .age，我们就可以给结构体变量的某一个指定成员直接赋值。非常方便。</p> 
<p>  在 Linux 内核驱动中，大量使用GNUC的这种指定初始化方式，通过结构体成员来初始化结构体变量。比如在字符驱动程序中，我们经常见到这样的初<br> 始化：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> file_operations ab3100_otp_operations <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">.</span>open        <span class="token operator">=</span> ab3100_otp_open<span class="token punctuation">,</span>
<span class="token punctuation">.</span>read        <span class="token operator">=</span> seq_read<span class="token punctuation">,</span>
<span class="token punctuation">.</span>llseek      <span class="token operator">=</span> seq_lseek<span class="token punctuation">,</span>
<span class="token punctuation">.</span>release     <span class="token operator">=</span> single_release<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  在驱动程序中，我们经常使用 file_operations 这个结构体变量来注册我们开发的驱动，然后以回调的方式来执行我们驱动实现的相关功能。结构体 file_operations 在 Linux 内核中的定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> file_operations <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> module <span class="token operator">*</span>owner<span class="token punctuation">;</span>
        loff_t <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>read_iter<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> iov_iter <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>write_iter<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> iov_iter <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>iterate<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dir_context <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>poll<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> poll_table_struct <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlocked_ioctl<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>compat_ioctl<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对应close函数</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fsync<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>aio_fsync<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fasync<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>sendpage<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_unmapped_area<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span>
               <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_flags<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flock<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>splice_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pipe_inode_info <span class="token operator">*</span><span class="token punctuation">,</span> 
            <span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>splice_read<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">,</span> 
            <span class="token keyword">struct</span> pipe_inode_info <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setlease<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>fallocate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span> loff_t offset<span class="token punctuation">,</span>
                  loff_t len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>show_fdinfo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> seq_file <span class="token operator">*</span>m<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">#<span class="token directive keyword">ifndef</span> CONFIG_MMU</span>
        <span class="token keyword">unsigned</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap_capabilities<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">#<span class="token directive keyword">endif</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  结构体 file_operations 里面定义了很多结构体成员，而在这个驱动中，我们只初始化了部分成员变量，通过访问结构体的成员来指定初始化，非常方便。</p> 
<p>(2)根据file_operations结构体使得open和close函数原型确定、内容填充</p> 
<h3><a id="4_419"></a>4、注册驱动</h3> 
<p>(1)主设备号的选择<br>   通过cat /proc/devices查看空闲的设备号</p> 
<p>(2)返回值的检测</p> 
<h3><a id="5_425"></a>5、驱动测试</h3> 
<p>(1)编译等 make &amp;&amp; make cp</p> 
<p>(2)insmod并且查看设备注册的现象</p> 
<p>(3)rmmod并且查看设备注销的现象</p> 
<h3><a id="6_432"></a>6、让内核自动分配主设备号</h3> 
<p>(1)为什么要让内核自动分配<br>   当你使用一个设备号时，可能在你这里没有被占用，当你这个代码移植到另一个平台上这个设备号被占用了，导致程序无法执行，失败。</p> 
<p>(2)如何实现？<br>   通过给注册设备驱动的函数传不同的参数实现，传参数为0，即可实现动态自动分配设备号</p> 
<p>(3)测试</p> 
<h2><a id="_441"></a>六、应用程序如何调用驱动</h2> 
<p>  udev 是Linux kernel 2.6系列的设备管理器。它主要的功能是管理/dev目录底下的设备节点。它同时也用来接替devfs及热插拔的功能，这意味着它要在添加/删除硬件时处理/dev目录以及所有用户空间的行为，包括加载固件及Linux 2. 6.13内核。要想使用udev的最新版本依赖于升级后的的uevent接口是否是最新版本。使用新版本udev的系统版本必须高于2.6.13，除非使用noudev参数来禁用udev并使用传统的/dev来进行设备读取。</p> 
<h3><a id="1_444"></a>1、驱动设备文件的创建</h3> 
<p>详解：http://www.jinbuguo.com/kernel/device_files.html<br> https://www.jianshu.com/p/579a7b715aab<br> (1)何为设备文件</p> 
<p>  设备文件通常提供与标准设备（如打印机和串行端口）的简单接口，但也可用于访问这些设备（如磁盘分区）上的特定独特资源。此外，设备文件对于访问与任何实际设备（如数据接收器和随机数生成器）无关的系统资源非常有用。</p> 
<p>(2)设备文件的关键信息是：**设备号 = 主设备号 + 次设备号，**使用ls -l去查看设备文件，就可以得到这个设备文件对应的主次设备号。</p> 
<p><strong>主设备号相同的设备是同类设备，使用同一个驱动程序</strong>(虽然目前的内核允许多个驱动共享一个主设备号，但绝大多数设备依然遵循一个驱动对应一个主设备号的原则)。可以通过 cat /proc/devices 命令查看当前已经加载的设备驱动程序的主设备号。</p> 
<p>在/dev目录下除了各种设备节点之外还通常还会存在：FIFO管道、Socket、软/硬连接、目录。这些东西并不是设备文件，因此也就没有主/次设备号。</p> 
<p>(3)使用mknod创建设备文件：mknod /dev/xxx c 主设备号 次设备号</p> 
<p>xxx自己起名，主设备号和次设备号是自己写的驱动程序分配的，次设备号默认为0，设备文件vi打开是看不到什么信息的，要通过open、write、read、close等操作</p> 
<h3><a id="2_461"></a>2、写应用来测试驱动</h3> 
<p>(1)open、write、read、close等<br> (2)借助实验现象预测和验证</p> 
<h3><a id="3_465"></a>3、添加读写接口</h3> 
<p>（1）在驱动中添加</p> 
<p>（2）在应用中添加</p> 
<p>（3）测试</p> 
<p>（4）应用和驱动之间的数据交换<br> &lt;1&gt;copy_from_user，用来将数据从用户空间复制到内核空间<br> &lt;2&gt;copy_to_user<br> 注意：复制是和mmap的映射相对应去区分的</p> 
<h3><a id="4_477"></a>4、读写接口实践</h3> 
<p>  在学习驱动时，对于用到的很多函数可以在<strong>sourceinsight</strong>这个软件中搜索查看内核相应的代码。</p> 
<p>  这是我在内核的一个驱动文件中找到的一个函数：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
		<span class="token keyword">const</span> <span class="token keyword">void</span> __user <span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">might_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">access_ok</span><span class="token punctuation">(</span>VERIFY_READ<span class="token punctuation">,</span> from<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">__copy_from_user</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span>to<span class="token punctuation">,</span>
		<span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">might_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">access_ok</span><span class="token punctuation">(</span>VERIFY_WRITE<span class="token punctuation">,</span> to<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">__copy_to_user</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="6writeread_502"></a>6、完成write和read函数</h3> 
<p>(1)copy_from_user函数的返回值定义，和常规有点不同。返回值如果成功复制则返回0，如果 不成功复制则返回尚未成功复制剩下的字节数。</p> 
<p>  如何包含这两个函数的头文件，可参照内核源代码，从调用他们的函数文件中找到定义函数的头文件，在知晓头文件名后，去调用它们的文件中查看函数如何包含，有时采用了间接包含，所以有时候前面的方法不一定可用，需要参考调用该函数的文件，找寻尝试包含头文件</p> 
<h2><a id="_507"></a>七、驱动中如何操控硬件</h2> 
<h3><a id="1_508"></a>1、还是那个硬件</h3> 
<p>(1)硬件物理原理不变<br> (2)硬件操作接口（寄存器）不变<br> (3)硬件操作代码不变</p> 
<h3><a id="2_513"></a>2、哪里不同了？</h3> 
<p>(1)寄存器地址不同。原来是直接用物理地址，现在需要用该物理地址在内核虚拟地址空间相对应的虚拟地址。寄存器的物理地址是CPU设计时决定的，从datasheet中查找到的。</p> 
<p>(2)编程方法不同。裸机中习惯直接用指针操作寄存器地址，而kernel中习惯用封装好的io读写函数来操作寄存器，以实现最大程度可移植性。</p> 
<h3><a id="3_518"></a>3、内核的虚拟地址映射方法</h3> 
<p>(1)为什么需要虚拟地址映射<br>   可以提高效率，比如LCD显示，将显示的内容存储空间和显示使用的空间（显存）映射到同一个内存空间，可以提高效率</p> 
<p>(2)内核中有2套虚拟地址映射方法：<strong>动态和静态</strong></p> 
<p>(3)静态映射方法的特点：<br>   内核移植时以代码的形式硬编码，如果要更改必须改源代码后重新编译内核在内核启动时建立静态映射表，到内核关机时销毁，中间一直有效，对于移植好的内核，你用不用他都在那里</p> 
<p>(4)动态映射方法的特点：驱动程序根据需要随时动态的建立映射、使用、销毁映射, 映射是短期临时的.</p> 
<h3><a id="4_529"></a>4、如何选择虚拟地址映射方法</h3> 
<p>(1)2种映射并不排他，可以同时使用</p> 
<p>(2)静态映射类似于C语言中全局变量，动态方式类似于C语言中malloc堆内存</p> 
<p>(3)静态映射的好处是执行效率高，坏处是始终占用虚拟地址空间（直到内核关机销毁）；动态映射的好处是按需使用虚拟地址空间，坏处是每次使用前后都需要代码去建立映射&amp;销毁映射（还得学会使用那些内核函数的使用）</p> 
<p>  <strong>两个物理地址不可以同时对应一个虚拟地址</strong>，<strong>否则mmu映射时不知道这个虚拟地址对应的那个物理地址，反之可以。</strong></p> 
<h2><a id="LED_538"></a>八、静态映射操作LED</h2> 
<h3><a id="1_539"></a>1、关于静态映射要说的</h3> 
<p>(1)不同版本内核中静态映射表位置、文件名可能不同</p> 
<p>(2)不同SoC的静态映射表位置、文件名可能不同</p> 
<p>(3)<strong>所谓映射表其实就是头文件中的宏定义</strong></p> 
<h3><a id="2_546"></a>2、三星版本内核中的静态映射表</h3> 
<p>(1)主映射表位于：arch/arm/plat-s5p/include/plat/map-s5p.h</p> 
<p>  CPU在安排寄存器地址时不是随意乱序分布的，而是按照模块去区分的。每一个模块内部的很多个寄存器的地址是连续的。所以内核在定义寄存器地址时都是先找到基地址，然后再用基地址+偏移量来寻找具体的一个寄存器。</p> 
<p>  map-s5p.h中定义的就是要用到的几个模块的寄存器基地址。<br>   map-s5p.h中定义的是模块的寄存器基地址的虚拟地址。</p> 
<p>(2)虚拟地址基地址定义在：arch/arm/plat-samsung/include/plat/map-base.h</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> S3C_ADDR_BASE	(0xFD000000)	</span>
<span class="token comment">// 三星移植时确定的静态映射表的基地址，表中的所有虚拟地址都是以这个地址+偏移量</span>
<span class="token comment">//来指定的</span>
</code></pre> 
<p>(3)GPIO相关的主映射表位于：arch/arm/mach-s5pv210/include/mach/regs-gpio.h,表中是GPIO的各个端口的基地址的定义</p> 
<p>(4)GPIO的具体寄存器定义位于：arch/arm/mach-s5pv210/include/mach/gpio-bank.h</p> 
<h3><a id="3LED_565"></a>3、参考裸机中的操作方法添加LED操作代码</h3> 
<pre><code class="prism language-c"><span class="token comment">/*
*用C语言点灯
*作者：Mr.Zhang
*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span> rGPJ0CON   *((unsigned int *)0xE0200240)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> rGPJ0DAT   *((unsigned int *)0xE0200244)</span>

<span class="token keyword">void</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">led_blink</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		rGPJ0CON <span class="token operator">=</span> <span class="token number">0x11111111</span><span class="token punctuation">;</span><span class="token comment">//把GPJ0CON设置为输出模式</span>
		
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出低电平，让三个灯亮</span>
		<span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时</span>
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//输出高电平，让三个灯灭</span>
		<span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时</span>
		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">}</span>
</code></pre> 
<p>(1)宏定义<br> (2)在init和exit函数中分别点亮和熄灭LED</p> 
<h3><a id="4_600"></a>4、实践测试</h3> 
<p>(1)insmod和rmmod时观察LED亮灭变化<br> (2)打印出寄存器的值和静态映射表中的分析相对比</p> 
<h3><a id="5openclose_603"></a>5、将代码移动到open和close函数中去</h3> 
<p>  要记得创建设备文件</p> 
<h3><a id="6_605"></a>6、添加驱动中的写函数</h3> 
<p>(1)先定义好应用和驱动之间的控制接口，这个是由自己来定义的。譬如定义为：应用向驱动写"on"则驱动让LED亮，应用向驱动写"off"，驱动就让LED灭</p> 
<p>(2)应用和驱动的接口定义做的尽量简单，譬如用1个字目来表示。譬如定义为：应用写"1"表示灯亮，写"0"表示让灯灭。</p> 
<h3><a id="7_609"></a>7、写应用来测试写函数</h3> 
<p>  驱动程序中使用memset函数和应用程序不同，包含的头文件也不同，应用层调用的是库函数，而库函数是内核提供的，无法在内核使用库函数，可以找到内核中声明实现memset函数的头文件，把该文件包含。可以通过查找该函数名称，找到内核中使用该函数的文件是如何包含这个头文件的,通过参考内核源码来得知如何包含该头文件</p> 
<h3><a id="8_612"></a>8、驱动和应用中来添加读功能</h3> 
<p>  驱动程序一般只是用来操作硬件，而与用户需求有关的应用代码应该放在应用程序中。</p> 
<p>上述代码如下所示：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span>    </span><span class="token comment">//module_init module_exit</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span>      </span><span class="token comment">//__init __exit</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;asm/uaccess.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mach/regs-gpio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mach/gpio-bank.h&gt;</span>		</span><span class="token comment">// arch/arm/mach-s5pv210/include/mach/gpio-bank.h</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h&gt;</span></span>


<span class="token macro property">#<span class="token directive keyword">define</span> MYMAJOR    200</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYNAME     "testchar"</span>

<span class="token macro property">#<span class="token directive keyword">define</span> GPJ0CON		S5PV210_GPJ0CON  </span><span class="token comment">//内核中寄存器地址相关的宏定义,静态映射表</span>
<span class="token macro property">#<span class="token directive keyword">define</span> GPJ0DAT		S5PV210_GPJ0DAT  </span>

<span class="token macro property">#<span class="token directive keyword">define</span> rGPJ0CON	*((volatile unsigned int *)GPJ0CON)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> rGPJ0DAT	*((volatile unsigned int *)GPJ0DAT)</span>

<span class="token keyword">int</span> mymajor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//内核空间的buf</span>

ssize_t <span class="token function">test_chrdev_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>ppos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 

	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_read.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span> kbuf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"copy_to_user fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"copy_to_user successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//写函数的本质就是，将应用层传递过来的数据先复制到内核中，然后以正确的</span>
<span class="token comment">//方式写入硬件完成操作</span>

ssize_t <span class="token function">test_chrdev_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>ppos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_write.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//使用该函数将应用层传过来的ubuf的内容拷贝到驱动空间中的一个buf中</span>
	<span class="token comment">//memcpy(kbuf, ubuf);  //错误，这两个不在一个地址空间中，一个属于内核，一个属于应用</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> ubuf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"copy_from_user fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"copy_from_user successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"GPJ0CON = %p.\n"</span><span class="token punctuation">,</span> GPJ0CON<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"GPJ0DAT = %p.\n"</span><span class="token punctuation">,</span> GPJ0DAT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//真正驱动中，数据从应用层复制到驱动中后， 我们要根据这个数据</span>
	<span class="token comment">//去操作硬件，所以下面应该就是操作硬件的代码</span>
	<span class="token comment">//方式1：</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token comment">//灯灭</span>
	<span class="token punctuation">{<!-- --></span>
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token comment">//灯亮</span>
	<span class="token punctuation">{<!-- --></span>	
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//方式2：</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token string">"on"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token string">"off"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>	
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">test_chrdev_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//该函数实现打开这个设备的硬件操作代码</span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_open.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	rGPJ0CON <span class="token operator">=</span> <span class="token number">0x11111111</span><span class="token punctuation">;</span>
	rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 亮</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">test_chrdev_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token comment">//对应close函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_release.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 灭</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 	
<span class="token punctuation">}</span>
<span class="token comment">//定义一个file_operations结构体变量，并且去填充</span>
<span class="token comment">//可在内核源代码搜索file_operations复制一个进行修改</span>
<span class="token comment">/* File operations struct for character device */</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> file_operations test_fops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>owner		<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>			<span class="token comment">// 惯例，直接写即可</span>
	
	<span class="token punctuation">.</span>open		<span class="token operator">=</span> test_chrdev_open<span class="token punctuation">,</span>		<span class="token comment">//将来应用open打开这个设备时,实际调用的就是这个.open对应的函数</span>
	<span class="token punctuation">.</span>write 		<span class="token operator">=</span> test_chrdev_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release	<span class="token operator">=</span> test_chrdev_release<span class="token punctuation">,</span>	<span class="token comment">//对应close函数 </span>
	<span class="token punctuation">.</span>read		<span class="token operator">=</span> test_chrdev_read<span class="token punctuation">,</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//模块安装函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chrdev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_init helloworld init\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//在module_init宏调用的函数中去注册字符设备驱动</span>
	<span class="token comment">//major 传0进去表示让内核帮我们自动分配一个合适的没被使用的主设备号</span>
	<span class="token comment">//内核如果成功分配就会返回分配的设备号：如果分配失败则会返回负数</span>
	mymajor <span class="token operator">=</span> <span class="token function">register_chrdev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> MYNAME<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mymajor <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"register_chrdev fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"register_chrdev successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"mymajor = %d.\n"</span><span class="token punctuation">,</span> mymajor<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//模块卸载函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chrdev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_exit hellowworld exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//在module_exit宏调用的函数中去注销字符设备驱动</span>
	<span class="token function">unregister_chrdev</span><span class="token punctuation">(</span>mymajor<span class="token punctuation">,</span> MYNAME<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放设备号</span>
	
<span class="token punctuation">}</span>

<span class="token comment">//这两个函数分别在加载和卸载驱动时被调用即调用insmod和rmmod命令的时候，</span>
<span class="token comment">//但是insmod和rmmod不能识别这两个函数，它只能识别init_module和cleanup_module，</span>
<span class="token comment">//其实init_module和cleanup_module相当于是module_init和module_exit的别名</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//宏定义，根据是否定义MODULE宏，宏展开不同的内容</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//宏定义，根据是否定义MODULE宏，宏展开不同的内容</span>
                        
<span class="token comment">//MODULE_XXX这种宏的作用用来添加模块描述信息</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的许可证</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"aston"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的作者</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"module test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 描述模块的介绍信息</span>
<span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"alias xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 描述模块的别名信息</span>
</code></pre> 
<h2><a id="LED_794"></a>九、动态映射操作LED</h2> 
<h3><a id="1_795"></a>1、如何建立动态映射</h3> 
<p>(1)request_mem_region，向内核申请（报告）需要映射的内存资源。避免出现混乱，例如多个驱动程序同时访问一个寄存器。</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> request_mem_region(start,n,name) __request_region(&amp;iomem_resource, (start), (n), (name), 0)</span>
</code></pre> 
<p>  对于 request_region, 三个参数 start,n,name 表示你想使用从 start 开始的 size 为 n 的 I/O port 资源 ,name 自然就是你的名字了 .</p> 
<p>(2)ioremap，真正用来实现映射，传给他物理地址他给你映射返回一个虚拟地址</p> 
<p>网上资料:</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span><span class="token function">ioremap</span><span class="token punctuation">(</span>phys_addr_t offset<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code>参数：
offset:要映射的物理内存区的起始地址。
size:物理·地址的范围。
</code></pre> 
<p>内核找到的：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ioremap(cookie,size)		__arm_ioremap(cookie, size, MT_DEVICE)</span>

<span class="token keyword">void</span> __iomem <span class="token operator">*</span><span class="token function">__arm_ioremap</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> phys_addr<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span>
			    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mtype<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __iomem <span class="token operator">*</span><span class="token punctuation">)</span>phys_addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两个函数可去查看内核源代码，搞清楚实现的原理及过程。</p> 
<h3><a id="2_824"></a>2、如何销毁动态映射</h3> 
<p>(1)iounmap 解除映射</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> iounmap(cookie)   __iounmap(cookie)</span>
参数：
cookie：虚拟地址的指针。

函数原型：
<span class="token keyword">void</span> <span class="token function">__iounmap</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">void</span> __ iomem <span class="token operator">*</span>io_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数：
io_addr：虚拟地址的指针。
</code></pre> 
<p>(2)release_mem_region 释放申请</p> 
<p>  注意：映射建立时，是要先申请再映射；然后使用；使用完要解除映射时要先解除映射再释放申请。避免出现还没有解除映射又有别的程序来申请动态映射</p> 
<p>  头文件间接包含、直接包含,不知道头文件如何包含时，可参考内核源码。</p> 
<h3><a id="3_842"></a>3、映射方式</h3> 
<p>(1)2个寄存器分开独立映射</p> 
<p>(2)2个寄存器在一起映射映射一个 ,对于地址挨着的寄存器可通过以下的方式实现,* p，*(p+1)</p> 
<h3><a id="4_846"></a>4、代码实现</h3> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span>    </span><span class="token comment">//module_init module_exit</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span>      </span><span class="token comment">//__init __exit</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;asm/uaccess.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mach/regs-gpio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mach/gpio-bank.h&gt;</span>		</span><span class="token comment">// arch/arm/mach-s5pv210/include/mach/gpio-bank.h</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/ioport.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> MYMAJOR    200</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYNAME     "testchar"</span>

<span class="token macro property">#<span class="token directive keyword">define</span> GPJ0CON_PA	0xe0200240</span>
<span class="token macro property">#<span class="token directive keyword">define</span> GPJ0DAT_PA 	0xe0200244</span>

<span class="token keyword">int</span> mymajor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>rGPJ0CON<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>rGPJ0DAT<span class="token punctuation">;</span>

<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//内核空间的buf</span>

ssize_t <span class="token function">test_chrdev_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>ppos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 

	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_read.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span> kbuf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"copy_to_user fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"copy_to_user successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//写函数的本质就是，将应用层传递过来的数据先复制到内核中，然后以正确的</span>
<span class="token comment">//方式写入硬件完成操作</span>

ssize_t <span class="token function">test_chrdev_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>ppos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_write.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//使用该函数将应用层传过来的ubuf的内容拷贝到驱动空间中的一个buf中</span>
	<span class="token comment">//memcpy(kbuf, ubuf);  //错误，这两个不在一个地址空间中，一个属于内核，一个属于应用</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> ubuf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"copy_from_user fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"copy_from_user successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	
	<span class="token comment">//真正驱动中，数据从应用层复制到驱动中后， 我们要根据这个数据</span>
	<span class="token comment">//去操作硬件，所以下面应该就是操作硬件的代码</span>
	<span class="token comment">//方式1：</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token comment">//灯灭</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token comment">//灯亮</span>
	<span class="token punctuation">{<!-- --></span>	
		<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//方式2：</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token string">"on"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> <span class="token string">"off"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>	
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">test_chrdev_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//该函数实现打开这个设备的硬件操作代码</span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_open.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>rGPJ0CON <span class="token operator">=</span> <span class="token number">0x11111111</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 亮</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">test_chrdev_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token comment">//对应close函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this is test_chrdev_release.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token operator">*</span>rGPJ0DAT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 灭</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 	
<span class="token punctuation">}</span>


<span class="token comment">//定义一个file_operations结构体变量，并且去填充</span>
<span class="token comment">//可在内核源代码搜索file_operations复制一个进行修改</span>
<span class="token comment">/* File operations struct for character device */</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> file_operations test_fops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>owner		<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>			<span class="token comment">// 惯例，直接写即可</span>
	
	<span class="token punctuation">.</span>open		<span class="token operator">=</span> test_chrdev_open<span class="token punctuation">,</span>		<span class="token comment">//将来应用open打开这个设备时,实际调用的就是这个.open对应的函数</span>
	<span class="token punctuation">.</span>write 		<span class="token operator">=</span> test_chrdev_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release	<span class="token operator">=</span> test_chrdev_release<span class="token punctuation">,</span>	<span class="token comment">//对应close函数 </span>
	<span class="token punctuation">.</span>read		<span class="token operator">=</span> test_chrdev_read<span class="token punctuation">,</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//模块安装函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chrdev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_init helloworld init\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//在module_init宏调用的函数中去注册字符设备驱动</span>
	<span class="token comment">//major 传0进去表示让内核帮我们自动分配一个合适的没被使用的主设备号</span>
	<span class="token comment">//内核如果成功分配就会返回分配的设备号：如果分配失败则会返回负数</span>
	mymajor <span class="token operator">=</span> <span class="token function">register_chrdev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> MYNAME<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mymajor <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"register_chrdev fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"register_chrdev successfully.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"mymajor = %d.\n"</span><span class="token punctuation">,</span> mymajor<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token comment">//使用动态映射的方式来操纵寄存器</span>
<span class="token macro property">#<span class="token directive keyword">if</span> 0</span>
	<span class="token comment">//方式1：</span>
	
	<span class="token comment">//申请</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mem_region</span><span class="token punctuation">(</span>GPJ0CON_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"GPJ0CON"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mem_region</span><span class="token punctuation">(</span>GPJ0DAT_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"GPJ0DAT"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token comment">//建立连接，真正实现映射	</span>
		rGPJ0CON <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>GPJ0CON_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rGPJ0DAT <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>GPJ0DAT_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">if</span> 1</span>
	<span class="token comment">//方式2：</span>
	<span class="token comment">//申请</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mem_region</span><span class="token punctuation">(</span>GPJ0CON_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"GPJ0CON"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token comment">//建立连接，真正实现映射	</span>
		rGPJ0CON <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>GPJ0CON_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rGPJ0DAT <span class="token operator">=</span> rGPJ0CON <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>	
<span class="token macro property">#<span class="token directive keyword">endif</span>	</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//模块卸载函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chrdev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"chrdev_exit hellowworld exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//解除映射</span>
	<span class="token function">iounmap</span><span class="token punctuation">(</span>rGPJ0CON<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">iounmap</span><span class="token punctuation">(</span>rGPJ0DAT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">release_mem_region</span><span class="token punctuation">(</span>GPJ0CON_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">release_mem_region</span><span class="token punctuation">(</span>GPJ0DAT_PA<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	
	<span class="token comment">//在module_exit宏调用的函数中去注销字符设备驱动</span>
	<span class="token function">unregister_chrdev</span><span class="token punctuation">(</span>mymajor<span class="token punctuation">,</span> MYNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>

	
<span class="token punctuation">}</span>

<span class="token comment">//这两个函数分别在加载和卸载驱动时被调用即调用insmod和rmmod命令的时候，</span>
<span class="token comment">//但是insmod和rmmod不能识别这两个函数，它只能识别init_module和cleanup_module，</span>
<span class="token comment">//其实init_module和cleanup_module相当于是module_init和module_exit的别名</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//宏定义，根据是否定义MODULE宏，宏展开不同的内容</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//宏定义，根据是否定义MODULE宏，宏展开不同的内容</span>
                        

<span class="token comment">//MODULE_XXX这种宏的作用用来添加模块描述信息</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的许可证</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"aston"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 描述模块的作者</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"module test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 描述模块的介绍信息</span>
<span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"alias xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 描述模块的别名信息</span>
</code></pre> 
<p>  若需本文章所述完整项目文件，请私信我或者评论区留下邮箱发你。</p> 
<p><em><strong>注：本资料大部分由朱老师物联网大讲堂课程笔记整理而来，如有侵权，联系删除！水平有限，如有错误，欢迎各位在评论区交流。</strong></em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce72186d0a0c2adfac068e96c29348a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Cesium 之加载在线底图（天地图、高德、百度、腾讯、谷歌等并实现偏移纠正）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6404176ce636be71ec776fcfdf45e2f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蓝桥杯——时间显示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>