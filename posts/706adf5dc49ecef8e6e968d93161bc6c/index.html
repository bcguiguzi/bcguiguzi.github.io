<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>程序人生——Java中类、对象及方法的建议（2） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="程序人生——Java中类、对象及方法的建议（2）" />
<meta property="og:description" content="目录 引出类、对象及方法建议41：让多重继承成为现实建议42：让工具类不可实例化建议43：避免对象的浅拷贝 建议44：推荐使用序列化实现对象的拷贝建议45：覆写equals方法时不要识别不出自己建议46：equals应该考虑null值情景 建议47：在equals中使用getClass进行类型判断建议48：覆写equals方法必须覆写hashCode方法建议49：推荐覆写toString方法 建议50：使用package-info类为包服务建议51：不要主动进行垃圾回收 深入认识JVMJVM内存分配，类加载创建对象的4种方法总结垃圾回收GCJVM调优，Arthas使用 认识多线程创建多线程方法&#43;了解线程池多线程下-1非原子性问题即解决再论线程，创建、生命周期 总结 引出 程序人生——Java中类、对象及方法的建议（2）
类、对象及方法 建议41：让多重继承成为现实 Java中一个类可以多种实现，但不能多重继承。使用成员内部类实现多重继承。内部类一个重要特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能 建议42：让工具类不可实例化 工具类的方法和属性都是静态的，不需要实例即可访问。**实现方式：**将构造函数设置为private，并且在构造函数中抛出Error错误异常 建议43：避免对象的浅拷贝 浅拷贝存在对象属性拷贝不彻底的问题。对于只包含基本数据类型的类可以使用浅拷贝；而包含有对象变量的类需要使用序列化与反序列化机制实现深拷贝 建议44：推荐使用序列化实现对象的拷贝 通过序列化方式来处理，在内存中通过字节流的拷贝来实现深拷贝。使用此方法进行对象拷贝时需注意两点：1、对象的内部属性都是可序列化的；2、注意方法和属性的特殊修饰符，比如final、static、transient变量的序列化问题都会影响拷贝效果。一个简单办法，使用Apache下的commons工具包中的SerializationUtils类，直接使用更加简洁方便 建议45：覆写equals方法时不要识别不出自己 需要满足p.equals§返回为真，自反性 建议46：equals应该考虑null值情景 覆写equals方法时需要判一下null，否则可能产生NullPointerException异常 建议47：在equals中使用getClass进行类型判断 使用getClass方法来代替instanceof进行类型判断 建议48：覆写equals方法必须覆写hashCode方法 需要两个相同对象的hashCode方法返回值相同，所以需要覆写hashCode方法，如果不覆写，两个不同对象的hashCode肯定不一样，简单实现hashCode方法，调用org.apache.commons.lang.builder包下的Hash码生成工具HashCodeBuilder 建议49：推荐覆写toString方法 原始toString方法显示不人性化 建议50：使用package-info类为包服务 package-info类是专门为本包服务的，是一个特殊性主要体现在3个方面：1、它不能随便被创建；2、它服务的对象很特殊；3、package-info类不能有实现代码；package-info类的作用：1、声明友好类和包内访问常量；2、为在包上标注注解提供便利；3、提供包的整体注释说明 建议51：不要主动进行垃圾回收 主动进行垃圾回收是一个非常危险的动作，因为System.gc要停止所有的响应（Stop 天河world），才能检查内存中是否有可回收的对象，所有的请求都会暂停 深入认识JVM JVM内存分配，类加载 Java进阶（1）——JVM的内存分配 &amp; 反射Class类的类对象 &amp; 创建对象的几种方式 &amp; 类加载（何时进入内存JVM）&amp; 注解 &amp; 反射&#43;注解的案例
创建对象的4种方法总结 Java进阶（4）——结合类加载JVM的过程理解创建对象的几种方式：new，反射Class，克隆clone（拷贝），序列化反序列化
垃圾回收GC Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器
简介：本篇博客介绍JVM的内存模型，对比了1.7和1.8的内存模型的变化；介绍了垃圾回收的语言发展；阐述了定位垃圾的方法，引用计数法和可达性分析发以及垃圾清除算法；然后介绍了Java中的垃圾回收器，由串行、到并行再到并发，最后到G1的演变；最后给出了垃圾回收器的对比和使用指引。
JVM调优，Arthas使用 Java进阶（JVM调优）——阿里云的Arthas的使用 &amp; 安装和使用 &amp; 死锁查找案例，重新加载案例，慢调用分析Java进阶（JVM调优）——JVM调优参数 &amp; JDK自带工具使用 &amp; 内存溢出和死锁问题案例 &amp; GC垃圾回收 认识多线程 创建多线程方法&#43;了解线程池 Java进阶（5）——创建多线程的方法extends Thread和implements Runnable的对比 &amp; 线程池及常用的线程池" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/706adf5dc49ecef8e6e968d93161bc6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T12:36:00+08:00" />
<meta property="article:modified_time" content="2024-03-13T12:36:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">程序人生——Java中类、对象及方法的建议（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/07/05/jF4ZKxsY_o.png" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">引出</a></li><li><a href="#_14" rel="nofollow">类、对象及方法</a></li><li><ul><li><a href="#41_16" rel="nofollow">建议41：让多重继承成为现实</a></li><li><ul><li><a href="#42_20" rel="nofollow">建议42：让工具类不可实例化</a></li><li><a href="#43_24" rel="nofollow">建议43：避免对象的浅拷贝</a></li></ul> 
   </li><li><a href="#44_28" rel="nofollow">建议44：推荐使用序列化实现对象的拷贝</a></li><li><ul><li><a href="#45equals_32" rel="nofollow">建议45：覆写equals方法时不要识别不出自己</a></li><li><a href="#46equalsnull_36" rel="nofollow">建议46：equals应该考虑null值情景</a></li></ul> 
   </li><li><a href="#47equalsgetClass_40" rel="nofollow">建议47：在equals中使用getClass进行类型判断</a></li><li><ul><li><a href="#48equalshashCode_44" rel="nofollow">建议48：覆写equals方法必须覆写hashCode方法</a></li><li><a href="#49toString_48" rel="nofollow">建议49：推荐覆写toString方法</a></li></ul> 
   </li><li><a href="#50packageinfo_52" rel="nofollow">建议50：使用package-info类为包服务</a></li><li><ul><li><a href="#51_56" rel="nofollow">建议51：不要主动进行垃圾回收</a></li></ul> 
  </li></ul> 
  </li><li><a href="#JVM_60" rel="nofollow">深入认识JVM</a></li><li><ul><li><a href="#JVM_62" rel="nofollow">JVM内存分配，类加载</a></li><li><a href="#4_70" rel="nofollow">创建对象的4种方法总结</a></li><li><a href="#GC_77" rel="nofollow">垃圾回收GC</a></li><li><a href="#JVMArthas_85" rel="nofollow">JVM调优，Arthas使用</a></li></ul> 
  </li><li><a href="#_102" rel="nofollow">认识多线程</a></li><li><ul><li><a href="#_105" rel="nofollow">创建多线程方法+了解线程池</a></li><li><a href="#1_112" rel="nofollow">多线程下-1非原子性问题即解决</a></li><li><a href="#_120" rel="nofollow">再论线程，创建、生命周期</a></li></ul> 
  </li><li><a href="#_131" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_6"></a>引出</h2> 
<p>程序人生——Java中类、对象及方法的建议（2）</p> 
<hr> 
<h2><a id="_14"></a>类、对象及方法</h2> 
<h3><a id="41_16"></a>建议41：让多重继承成为现实</h3> 
<ul><li>Java中一个类可以多种实现，但不能多重继承。使用成员内部类实现多重继承。内部类一个重要特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能</li></ul> 
<h4><a id="42_20"></a>建议42：让工具类不可实例化</h4> 
<ul><li>工具类的方法和属性都是静态的，不需要实例即可访问。**实现方式：**将构造函数设置为private，并且在构造函数中抛出Error错误异常</li></ul> 
<h4><a id="43_24"></a>建议43：避免对象的浅拷贝</h4> 
<ul><li>浅拷贝存在对象属性拷贝不彻底的问题。对于只包含<strong>基本数据类型的类</strong>可以使用<strong>浅拷贝</strong>；而包含有<strong>对象变量的类</strong>需要使用<strong>序列化与反序列化</strong>机制实现<strong>深拷贝</strong></li></ul> 
<h3><a id="44_28"></a>建议44：推荐使用序列化实现对象的拷贝</h3> 
<ul><li>通过序列化方式来处理，在内存中通过字节流的拷贝来实现深拷贝。使用此方法进行对象拷贝时需注意<strong>两点</strong>：1、对象的内部属性都是可序列化的；2、注意方法和属性的特殊修饰符，比如final、static、transient变量的序列化问题都会影响拷贝效果。一个简单办法，使用Apache下的commons工具包中的SerializationUtils类，直接使用更加简洁方便</li></ul> 
<h4><a id="45equals_32"></a>建议45：覆写equals方法时不要识别不出自己</h4> 
<ul><li>需要满足p.equals§返回为真，自反性</li></ul> 
<h4><a id="46equalsnull_36"></a>建议46：equals应该考虑null值情景</h4> 
<ul><li>覆写equals方法时需要判一下null，否则可能产生NullPointerException异常</li></ul> 
<h3><a id="47equalsgetClass_40"></a>建议47：在equals中使用getClass进行类型判断</h3> 
<ul><li>使用getClass方法来代替instanceof进行类型判断</li></ul> 
<h4><a id="48equalshashCode_44"></a>建议48：覆写equals方法必须覆写hashCode方法</h4> 
<ul><li>需要两个相同对象的hashCode方法返回值相同，所以需要覆写hashCode方法，如果不覆写，两个不同对象的hashCode肯定不一样，简单实现hashCode方法，调用org.apache.commons.lang.builder包下的Hash码生成工具HashCodeBuilder</li></ul> 
<h4><a id="49toString_48"></a>建议49：推荐覆写toString方法</h4> 
<ul><li>原始toString方法显示不人性化</li></ul> 
<h3><a id="50packageinfo_52"></a>建议50：使用package-info类为包服务</h3> 
<ul><li>package-info类是专门为本包服务的，是一个<strong>特殊性</strong>主要体现在3个方面：1、它不能随便被创建；2、它服务的对象很特殊；3、package-info类不能有实现代码；package-info类的<strong>作用</strong>：1、声明友好类和包内访问常量；2、为在包上标注注解提供便利；3、提供包的整体注释说明</li></ul> 
<h4><a id="51_56"></a>建议51：不要主动进行垃圾回收</h4> 
<ul><li>主动进行垃圾回收是一个非常危险的动作，因为System.gc要停止所有的响应（Stop 天河world），才能检查内存中是否有可回收的对象，所有的请求都会暂停</li></ul> 
<h2><a id="JVM_60"></a>深入认识JVM</h2> 
<h3><a id="JVM_62"></a>JVM内存分配，类加载</h3> 
<p><a href="https://blog.csdn.net/Pireley/article/details/132175970">Java进阶（1）——JVM的内存分配 &amp; 反射Class类的类对象 &amp; 创建对象的几种方式 &amp; 类加载（何时进入内存JVM）&amp; 注解 &amp; 反射+注解的案例</a></p> 
<p><img src="https://images2.imgbox.com/e3/34/KzmoLZxc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_70"></a>创建对象的4种方法总结</h3> 
<p><a href="https://blog.csdn.net/Pireley/article/details/132355758">Java进阶（4）——结合类加载JVM的过程理解创建对象的几种方式：new，反射Class，克隆clone（拷贝），序列化反序列化</a></p> 
<p><img src="https://images2.imgbox.com/38/c9/wDKPz8OK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="GC_77"></a>垃圾回收GC</h3> 
<p><img src="https://images2.imgbox.com/da/1e/mRQ8jO7m_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://blog.csdn.net/Pireley/article/details/134315943">Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器</a></p> 
<p>简介：本篇博客介绍JVM的内存模型，对比了1.7和1.8的内存模型的变化；介绍了垃圾回收的语言发展；阐述了定位垃圾的方法，引用计数法和可达性分析发以及垃圾清除算法；然后介绍了Java中的垃圾回收器，由串行、到并行再到并发，最后到G1的演变；最后给出了垃圾回收器的对比和使用指引。</p> 
<h3><a id="JVMArthas_85"></a>JVM调优，Arthas使用</h3> 
<ul><li><a href="https://blog.csdn.net/Pireley/article/details/134320335">Java进阶（JVM调优）——阿里云的Arthas的使用 &amp; 安装和使用 &amp; 死锁查找案例，重新加载案例，慢调用分析</a></li><li><a href="https://blog.csdn.net/Pireley/article/details/134319596">Java进阶（JVM调优）——JVM调优参数 &amp; JDK自带工具使用 &amp; 内存溢出和死锁问题案例 &amp; GC垃圾回收</a></li></ul> 
<p><img src="https://images2.imgbox.com/05/94/EucJFXOX_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c9/ed/eVHlZJZy_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/52/d4/CCAlRHDs_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_102"></a>认识多线程</h2> 
<h3><a id="_105"></a>创建多线程方法+了解线程池</h3> 
<p><a href="https://blog.csdn.net/Pireley/article/details/132425329">Java进阶（5）——创建多线程的方法extends Thread和implements Runnable的对比 &amp; 线程池及常用的线程池</a></p> 
<p><img src="https://images2.imgbox.com/dd/57/yorravZK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_112"></a>多线程下-1非原子性问题即解决</h3> 
<p><a href="https://blog.csdn.net/Pireley/article/details/132432650">Java进阶（6）——抢购问题中的数据不安全（非原子性问题）&amp; Java中的synchronize和ReentrantLock锁使用 &amp; 死锁及其产生的条件</a></p> 
<p><img src="https://images2.imgbox.com/75/d7/e005PFxD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_120"></a>再论线程，创建、生命周期</h3> 
<p><a href="https://blog.csdn.net/Pireley/article/details/134268456">Java进阶（再论线程）——线程的4种创建方式 &amp; 线程的生命周期 &amp; 线程的3大特性 &amp; 集合中的线程安全问题</a></p> 
<p>主要内容：<br> 1.线程创建的方式，继承Thread类，实现Runable接口，实现Callable接口，采用线程池；<br> 2.线程生命周期： join()：运行结束再下一个， yield()：暂时让出cpu的使用权，deamon()：守护线程，最后结束，sleep()：如果有锁，不会让出；<br> 3.线程3大特性，原子性，可见性，有序性；<br> 4.list集合中线程安全问题，hash算法问题；</p> 
<hr> 
<h2><a id="_131"></a>总结</h2> 
<p>程序人生——Java中类、对象及方法的建议（2）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a645cbfd760ae68afe23b71bb1da174f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Copilot如何将word文稿一键转为PPT</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/473cc52f95c4b6ad1e82ee87c58667f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Doccano的标注结果转换为BIO格式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>