<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>5.3.6 直方图统计 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="5.3.6 直方图统计" />
<meta property="og:description" content="1、灰度图像直方图统计
直方图统计是图像处理中的一个非常重要的操作。VTK中实现直方图统计功能的filter是vtkImageAccumulate。其将每个组分的数值范围划分为离散的间隔，然后统计每个灰度间隔上的像素数目。vtkImageAccumulate输入和输出都是vtkImageData类型，因此直方图也可以看做是一幅图像；对于输入图像的像素数据类型可以是任意的，但是最大支持3个组分像素类型，而输出图像的像素数据类型为int型。一个灰度图像的直方图为一个一维图像。
#include&#34;vtkSmartPointer.h&#34; #include&#34;vtkJPEGReader.h&#34; #include&#34;vtkImageAccumulate.h&#34; #include&#34;vtkImageData.h&#34; #include&#34;vtkIntArray.h&#34; #include&#34;vtkDataObject.h&#34; #include&#34;vtkFieldData.h&#34; #include&#34;vtkBarChartActor.h&#34; #include&#34;vtkProperty2D.h&#34; #include&#34;vtkTextProperty.h&#34; #include&#34;vtkLegendBoxActor.h&#34; #include&#34;vtkImageActor.h&#34; #include&#34;vtkRenderer.h&#34; #include&#34;vtkRenderWindow.h&#34; #include&#34;vtkRenderWindowInteractor.h&#34; int main() { vtkSmartPointer&lt;vtkJPEGReader&gt;reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New();//读入一幅灰度图像 reader-&gt;SetFileName(&#34;data\\lena-gray.jpg&#34;); reader-&gt;Update(); int bins = 16; //直方图一维数组的维数 int comps = 1; vtkSmartPointer&lt;vtkImageAccumulate&gt;histogram = vtkSmartPointer&lt;vtkImageAccumulate&gt;::New(); histogram-&gt;SetInputData(reader-&gt;GetOutput()); histogram-&gt;SetComponentExtent(0, bins - 1, 0, 0, 0, 0); //6个参数是RGB3个组分直方图的最大最小值 histogram-&gt;SetComponentOrigin(0, 0, 0); //函数设置的是统计每个组分直方图时的起始灰度值 histogram-&gt;SetComponentSpacing(256.0 / bins, 0, 0); //设置直方图每个间隔代表的灰度范围 histogram-&gt;Update(); int* output = static_cast&lt;int*&gt;(histogram-&gt;GetOutput()-&gt;GetScalarPointer()); vtkSmartPointer&lt;vtkIntArray&gt; frequencies = vtkSmartPointer&lt;vtkIntArray&gt;::New(); frequencies-&gt;SetNumberOfComponents(1); for (int j = 0; j &lt; bins; &#43;&#43;j) { for (int i = 0; i &lt; comps; &#43;&#43;i) { frequencies-&gt;InsertNextTuple1(*output&#43;&#43;); } } vtkSmartPointer&lt;vtkDataObject&gt; dataObject = vtkSmartPointer&lt;vtkDataObject&gt;::New(); dataObject-&gt;GetFieldData()-&gt;AddArray(frequencies); /*******************************************************/ vtkSmartPointer&lt;vtkBarChartActor&gt; barChart = vtkSmartPointer&lt;vtkBarChartActor&gt;::New(); barChart-&gt;SetInput(dataObject); barChart-&gt;SetTitle(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/245ba84c00b4f93061f6a11f5825317b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-19T17:13:03+08:00" />
<meta property="article:modified_time" content="2018-06-19T17:13:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">5.3.6 直方图统计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px;"><strong>1、灰度图像直方图统计</strong></span></p> 
<p><span style="font-size:14px;"><span style="background-color:rgb(255,255,255);">直方图统计是图像处理中的一个非常重要的操作。VTK中实现直方图统计功能的filter是</span><span style="font-weight:700;background-color:rgb(255,255,255);"><span style="color:rgb(255,0,0);">vtkImageAccumulate</span></span><span style="background-color:rgb(255,255,255);">。其将每个组分的数值范围划分为离散的间隔，然后统计每个灰度间隔上的像素数目。vtkImageAccumulate输入和输出都是vtkImageData类型，因此直方图也可以看做是一幅图像；对于输入图像的像素数据类型可以是任意的，但是最大支持3个组分像素类型，而输出图像的像素数据类型为int型。一个灰度图像的直方图为一个一维图像。</span></span><br></p> 
<pre><code class="language-cpp">#include"vtkSmartPointer.h"
#include"vtkJPEGReader.h"
#include"vtkImageAccumulate.h"
#include"vtkImageData.h"
#include"vtkIntArray.h"
#include"vtkDataObject.h"
#include"vtkFieldData.h"
#include"vtkBarChartActor.h"
#include"vtkProperty2D.h"
#include"vtkTextProperty.h"
#include"vtkLegendBoxActor.h"
#include"vtkImageActor.h"
#include"vtkRenderer.h"
#include"vtkRenderWindow.h"
#include"vtkRenderWindowInteractor.h"

int main()
{
	vtkSmartPointer&lt;vtkJPEGReader&gt;reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New();//读入一幅灰度图像
	reader-&gt;SetFileName("data\\lena-gray.jpg");
	reader-&gt;Update();

	int bins = 16; //直方图一维数组的维数
	int comps = 1;
	vtkSmartPointer&lt;vtkImageAccumulate&gt;histogram = vtkSmartPointer&lt;vtkImageAccumulate&gt;::New();
	histogram-&gt;SetInputData(reader-&gt;GetOutput());
	histogram-&gt;SetComponentExtent(0, bins - 1, 0, 0, 0, 0);  //6个参数是RGB3个组分直方图的最大最小值
	histogram-&gt;SetComponentOrigin(0, 0, 0);          //函数设置的是统计每个组分直方图时的起始灰度值
	histogram-&gt;SetComponentSpacing(256.0 / bins, 0, 0);  //设置直方图每个间隔代表的灰度范围
	histogram-&gt;Update();
	int* output = static_cast&lt;int*&gt;(histogram-&gt;GetOutput()-&gt;GetScalarPointer());
	vtkSmartPointer&lt;vtkIntArray&gt; frequencies = vtkSmartPointer&lt;vtkIntArray&gt;::New();
	frequencies-&gt;SetNumberOfComponents(1);
	for (int j = 0; j &lt; bins; ++j)
	{
		for (int i = 0; i &lt; comps; ++i)
		{
		frequencies-&gt;InsertNextTuple1(*output++);
		}
	}
	vtkSmartPointer&lt;vtkDataObject&gt; dataObject = vtkSmartPointer&lt;vtkDataObject&gt;::New();
	dataObject-&gt;GetFieldData()-&gt;AddArray(frequencies);
	/*******************************************************/
	vtkSmartPointer&lt;vtkBarChartActor&gt; barChart = vtkSmartPointer&lt;vtkBarChartActor&gt;::New();
	barChart-&gt;SetInput(dataObject);
	barChart-&gt;SetTitle("Histogram");
	barChart-&gt;GetPositionCoordinate()-&gt;SetValue(0.05, 0.05, 0.0);
	barChart-&gt;GetPosition2Coordinate()-&gt;SetValue(0.95, 0.95, 0.0);
	barChart-&gt;GetProperty()-&gt;SetColor(0, 0, 0);
	barChart-&gt;GetTitleTextProperty()-&gt;SetColor(0, 0, 0);
	barChart-&gt;GetLabelTextProperty()-&gt;SetColor(0, 0, 0);
	barChart-&gt;GetLegendActor()-&gt;SetNumberOfEntries(dataObject-&gt;GetFieldData()-&gt;GetArray(0)-&gt;GetNumberOfTuples());
	//barChart-&gt;LegendVisibilityOff();
	//barChart-&gt;LabelVisibilityOff();

	double colors[3][3] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
	int count = 0;
	for (int i = 0; i &lt; bins; ++i)
	{
		for (int j = 0; j &lt; comps; ++j)
		{
			barChart-&gt;SetBarColor(count++, colors[j]);//单通道红色,colors数组第一个元素的值
		}
	}
	vtkSmartPointer&lt;vtkImageActor&gt; imgActor = vtkSmartPointer&lt;vtkImageActor&gt;::New();
	imgActor-&gt;SetInputData(reader-&gt;GetOutput());
	/*******************************************************/
	double imgView[4] = { 0.0, 0.0, 0.5, 1.0 };
	double barView[4] = { 0.5, 0.0, 1.0, 1.0 };
	vtkSmartPointer&lt;vtkRenderer&gt; barRender = vtkSmartPointer&lt;vtkRenderer&gt;::New();
	barRender-&gt;SetViewport(barView);
	barRender-&gt;AddActor(barChart);
	barRender-&gt;SetBackground(1, 1, 1);

	vtkSmartPointer&lt;vtkRenderer&gt; imgRender = vtkSmartPointer&lt;vtkRenderer&gt;::New();
	imgRender-&gt;SetViewport(imgView);
	imgRender-&gt;AddActor(imgActor);
	imgRender-&gt;SetBackground(1, 1, 1);

	vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
	renderWindow-&gt;AddRenderer(barRender);
	renderWindow-&gt;AddRenderer(imgRender);
	renderWindow-&gt;SetSize(640, 320);
	renderWindow-&gt;Render();
	renderWindow-&gt;SetWindowName("Gray-Image Histogram");

	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; rwi = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
	rwi-&gt;SetRenderWindow(renderWindow);
	rwi-&gt;Initialize();
	rwi-&gt;Start();

	return EXIT_SUCCESS;
}</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/35/26/kMAYVLyY_o.png" alt=""><br></p> 
<p>代码分析：</p> 
<p><span style="font-size:14px;background-color:rgb(255,255,255);">首先是读入一副灰度图像，一般的灰度图像的灰度范围为0-255。定义了一个变量bins = 16，表示要图像灰度范围上的间隔数目，也可以理解为直方图一维数组的维数。然后定义vtkImageAccumulate对象，并设置输入数据为我们读入的图像数据，接着调用了三个函数：</span></p> 
<p><span style="font-size:14px;background-color:rgb(255,255,255);font-weight:700;"><span style="color:rgb(255,0,0);">SetComponentExtent(0,bins-1, 0, 0, 0, 0)</span></span><span style="font-size:14px;background-color:rgb(255,255,255);">，该函数设置要计算每个组分的直方图的最小和最大值。vtkImageAccumulate最大支持像素值为三个组分（如RGB图像）的直方图，支持共有六个参数。分别表示每个组分的直方图最小和最大值。该例中由于计算的是灰度图像直方图，只有一个组分，因此第二个和第三个组分都设置为0；而第一组分直方图维数为bins = 16，那么其最小和最大范围为0和bins-1。</span></p> 
<p><span style="font-size:14px;background-color:rgb(255,255,255);font-weight:700;"><span style="color:rgb(255,0,0);">SetComponentOrigin(0，0，0)</span></span><span style="font-size:14px;background-color:rgb(255,255,255);">，该函数设置的是统计每个组分直方图时的起始灰度值，这里设置为0，表示灰度从0开始统计直方图。同样，vtkImageAccumulate最大支持像素值为三个组分，这里也要设置三个参数。如果图像的灰度范围为[1000, 2000]，那么计算直方图时，其起始灰度应该设置为1000。</span></p> 
<p></p> 
<div style="padding:0px;margin:0px;background-color:rgb(255,255,255);"> 
 <span style="font-size:14px;"><span style="font-weight:700;"><span style="color:rgb(255,0,0);">SetComponentSpacing(16,0, 0)</span></span>，设置直方图每个间隔代表的灰度范围，例如当一个图像灰度范围为[1000, 2000]，统计直方图的间隔数bins为100时，那么对应的space应该设置为SetComponentSpacing(100, 0, 0)。<br><span style="font-weight:700;"><span style="color:rgb(255,0,0);">参数设置完毕后执行Update()即可计算直方图</span></span>。<span style="font-weight:700;"><span style="color:rgb(204,51,204);">前面已经提到过，vtkImageAccumulate的输出结果也是一个vtkImageData类型，这样就可以方便的访问图像的每个数据。图像像素访问前面已经介绍过，这里就不在重述。需要注意的是输出直方图图像的数据类型为int。</span></span><br>这里再顺便简单的介绍一下直方图的显示。</span> 
</div> 
<div style="padding:0px;margin:0px;background-color:rgb(255,255,255);"> 
 <span style="font-size:14px;">虽然vtkImageAccumulate的输出类型为vtkImageData但是并不能直接按照图像的方式进行显示。VTK中定义了vtkBarChartActor用来显示条形图，因此可以利用其来显示直方图。但是该类接收的数据类型为vtkDataObject类型，因此需要先将直方图数据进行转换。<span style="font-weight:700;"><span style="color:rgb(255,0,0);">首先将直方图数组存储到vtkIntArray数组frequencies中，通过函数vtkDataObject函数GetFieldData()-&gt;AddArray(frequencies)将其添加到vtkDataObject对象中。</span></span>vtkBarChartActor对象接收vtkDataObject对象作为输入，另外还需要设置图表的名字，颜色等，需要注意两个函数：<br>barChart-&gt;GetPositionCoordinate()-&gt;SetValue(0.05,0.05,0.0);<br>barChart-&gt;GetPosition2Coordinate()-&gt;SetValue(0.95,0.95,0.0);<br>这里设置的是窗口中显示图表的所在矩形的左下角点和右上角点坐标，<span style="font-weight:700;"><span style="color:rgb(255,0,0);">VTK的坐标系原点位于左下角点，设置时需要格外注意</span></span>。设置完毕后，即可定义相应的vtkRenderer，vtkRenderWindow和vtkRenderWindowInteractor对象显示图像直方图。</span> 
</div> 
<p><strong>2、彩色图像直方图统计</strong></p> 
<p><span style="background-color:rgb(255,255,255);"><span style="font-size:14px;">彩色图像由于内部有三个通道，不能直接计算直方图，需要提取RGB三个通道数据，分别计算直方图。每个通道计算直方图的方法与灰度图像直方图计算方法一致。</span></span><br></p> 
<pre><code class="language-cpp">#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkBMPReader.h&gt;
#include &lt;vtkImageData.h&gt;
#include &lt;vtkXYPlotActor.h&gt;  //vtkXYPlotActor类可以用来显示二维曲线，它可以接收多个输入数据
#include &lt;vtkAxisActor2D.h&gt;
#include &lt;vtkImageAccumulate.h&gt;
#include &lt;vtkImageExtractComponents.h&gt;
#include &lt;vtkProperty2D.h&gt;
#include &lt;vtkTextProperty.h&gt;
#include &lt;vtkActor.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;

//测试图像：../data/lena.bmp
int main()
{
	
	vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::New();
	reader-&gt;SetFileName("data//lena.bmp");
	reader-&gt;Update();

	int numComponents = reader-&gt;GetOutput()-&gt;GetNumberOfScalarComponents();
//**********************************************************************/
	vtkSmartPointer&lt;vtkXYPlotActor&gt; plot = vtkSmartPointer&lt;vtkXYPlotActor&gt;::New();//使用vtkBarChartActor柱状图来显示直方图，本例使用vtkXYPlotActor曲线来表示直方图。
	plot-&gt;ExchangeAxesOff();
	plot-&gt;SetLabelFormat("%g");
	plot-&gt;SetXTitle("Intensity");
	plot-&gt;SetYTitle("Frequency");
	plot-&gt;SetXValuesToValue();
	plot-&gt;GetProperty()-&gt;SetColor(0.0, 0.0, 0.0);
	plot-&gt;GetAxisLabelTextProperty()-&gt;SetColor(0.0, 0.0, 0.0);
	plot-&gt;GetAxisTitleTextProperty()-&gt;SetColor(0.0, 0.0, 0.0);

	double colors[3][3] = {<!-- -->{ 1, 0, 0 },{ 0, 1, 0 },{ 0, 0, 1 }};

	const char* labels[3] = { "Red", "Green", "Blue" };
	int xmax = 0;
	int ymax = 0;

	for (int i = 0; i &lt; numComponents; ++i)
	{
		vtkSmartPointer&lt;vtkImageExtractComponents&gt; extract = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::New();
		extract-&gt;SetInputConnection(reader-&gt;GetOutputPort()); //彩色图像不能直接计算直方图，因此需要先通过vtkImageExtractComponents来提取每个通道图像
		extract-&gt;SetComponents(i);
		extract-&gt;Update();

		double range[2];
		extract-&gt;GetOutput()-&gt;GetScalarRange(range);
		int extent = static_cast&lt;int&gt;(range[1]) - static_cast&lt;int&gt;(range[0]) - 1;

		vtkSmartPointer&lt;vtkImageAccumulate&gt; histogram =	vtkSmartPointer&lt;vtkImageAccumulate&gt;::New();
		histogram-&gt;SetInputConnection(extract-&gt;GetOutputPort());
		histogram-&gt;SetComponentExtent(0, extent, 0, 0, 0, 0);
		histogram-&gt;SetComponentOrigin(range[0], 0, 0);  //灰度起点为图像的最小灰度值
		histogram-&gt;SetComponentSpacing(1, 0, 0); //直方图的间隔取(1, 0, 0),每个灰度计算统计一个频率
		histogram-&gt;SetIgnoreZero(1);  //统计直方图时，像素值为0的像素不进行统计
		histogram-&gt;Update();
**********************************************************************/
		if (range[1] &gt; xmax)
		{
			xmax = range[1];
		}
		if (histogram-&gt;GetOutput()-&gt;GetScalarRange()[1] &gt; ymax)
		{
			ymax = histogram-&gt;GetOutput()-&gt;GetScalarRange()[1];
		}

		plot-&gt;AddDataSetInput(histogram-&gt;GetOutput());
		plot-&gt;SetPlotColor(i, colors[i]);
		plot-&gt;SetPlotLabel(i, labels[i]);
		plot-&gt;LegendOn(); //red\green\blue注释
	}

	plot-&gt;SetXRange(0, xmax);
	plot-&gt;SetYRange(0, ymax);

	vtkSmartPointer&lt;vtkRenderer&gt; renderer =	vtkSmartPointer&lt;vtkRenderer&gt;::New();
	renderer-&gt;AddActor(plot);
	renderer-&gt;SetBackground(1.0, 1.0, 1.0);

	vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow =	vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
	renderWindow-&gt;AddRenderer(renderer);
	renderWindow-&gt;SetSize(640, 480);
	renderWindow-&gt;Render();
	renderWindow-&gt;SetWindowName("ImageAccumulateExample2");

	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; interactor =	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
	interactor-&gt;SetRenderWindow(renderWindow);
	interactor-&gt;Initialize();
	interactor-&gt;Start();

	return EXIT_SUCCESS;
} </code></pre> 
<p>运行结果：</p> 
<p><strong><img src="https://images2.imgbox.com/26/a0/0YRgcIhX_o.png" alt=""><br></strong></p> 
<p>代码分析：</p> 
<p></p> 
<div style="padding:0px;margin:0px;background-color:rgb(255,255,255);"> 
 <span style="font-size:14px;">由于彩色图像不能直接计算直方图，因此需要先通过vtkImageExtractComponents来提取每个通道图像，然后再利用vtkImageAccumulate统计直方图。在本例中计算直方图的间隔取(1, 0, 0)，即每个灰度计算统计一个频率，而且灰度起点为图像的最小灰度值，这样间隔的个数即为：最大灰度值减去最小灰度值，再减1，如第37行代码。同时，设置了SetIgnoreZero()为1，即在统计直方图时，像素值为0的像素不进行统计。<br>在灰度图像直方图实例中，我们使用的是vtkBarChartActor柱状图来显示直方图，在本例中则使用vtkXYPlotActor曲线来表示直方图。</span> 
</div> 
<div style="padding:0px;margin:0px;background-color:rgb(255,255,255);"> 
 <span style="font-size:14px;"><span style="color:rgb(255,0,0);">vtkXYPlotActor类可以用来显示二维曲线，它可以接收多个输入数据</span>，如本例中我们输入了三条曲线，分别是图像红色分量直方图区域，绿色分量直方图曲线和蓝色分量直方图曲线。SetXRange()和SetYRange()用来设置X轴和Y轴的数据范围，另外还可以设置X轴和Y轴的名字，曲线的标题等属性，详细可以查阅vtkXYPlotActor类的文档。vtkXYPlotActor类是一个vtkActor2D的子类，因此定义相应的vtkRenderer，vtkRenderWindow和vtkRenderWindowInteractor对象建立可视化管道来显示图像直方图曲线。</span> 
</div> 
<div style="padding:0px;margin:0px;background-color:rgb(255,255,255);"> 
 <span style="font-size:14px;"><br></span> 
</div> 
<p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">注：此文知识学习笔记，仅记录完整程序和实现结果，具体原理参见：</span></p> 
<p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">https://blog.csdn.net/www_doling_net/article/details/8541534</span></p> 
<p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">https://blog.csdn.net/shenziheng1/article/category/6114053/4</span></p> 
<p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">参考资料：</span></p> 
<p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">1.《The Visualization Toolkit – AnObject-Oriented Approach To 3D Graphics (4th Edition)》<br>2. 张晓东, 罗火灵. VTK图形图像开发进阶[M]. 机械工业出版社, 2015.</span></p> 
<span style="color:rgb(51,51,51);background-color:rgb(255,255,255);"><span style="font-size:14px;">所用软件：vtk7.0+visual studio 2013</span></span>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5510e0e778c622d381743b9c47c85bd6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">以太坊虚拟机(EVM)架构和源码简析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0906a6ddc1dda03b1b1657f48930f723/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue单页应用如何在页面刷新时保留状态数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>