<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM介绍（针对JDK8&#43;） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM介绍（针对JDK8&#43;）" />
<meta property="og:description" content="JVM介绍（针对JDK8&#43;） 关系图如下运行时数据区JVM栈 (Java Virtual Machine Stacks)堆内存 (Heap Memory)方法区（元空间） (Metaspace)本地方法栈 (Native Method Stacks)程序计数器 (Program Counter (PC) Register) 之前整理过一篇jdk7以前版本的jvm，然后有朋友建议更新一下。实在不好意思，本人比较懒，好多东西只是记录在本地会更新到网上，今天咱们先简单聊一下jdk8&#43;后jvm的的变动信息
关系图如下 有图可知，一个java文件首先由java编译器编译为class文件，在由类加载器加载到运行时数据区内，（类加载器和运行时数据区都属于jvm的概念，面试时不要丢掉任何一部分哦）。
运行时数据区 JVM栈 (Java Virtual Machine Stacks) 每当启动一个新线程的时候，java虚拟机都会为它分配一个java栈。java以栈帧为单位保存线程的运行状态。虚拟机只会对java栈执行两种操作：以栈帧为单位的压栈或者出栈。
一个栈帧包含：局部变量、操作数栈、动态链接、方法出口等信息
堆内存 (Heap Memory) 存储的是对象实例和数组，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。
jvm只有一个堆区（heap）被所有线程共享
堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。
方法区（元空间） (Metaspace) jdk8&#43;以后，JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）
元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存
元空间中存储的数据：常量、8大基本数据类型、静态变量(static、final）、类信息（字节码信息）、即时编译器编译后的代码
本地方法栈 (Native Method Stacks) 和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。
Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C&#43;&#43;，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加，因此也会对应抛出StackOverflowError和OutOfMemoryError错误。
在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
程序计数器 (Program Counter (PC) Register) 用于保存当前线程执行的内存地址。
由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。
先简单介绍到这里，后期会补充类加载的相关信息，上面描述如有问题，欢迎伙伴们提示" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/fd01143a2ed11b2ce9d35e002a8392b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-12T10:51:57+08:00" />
<meta property="article:modified_time" content="2021-03-12T10:51:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM介绍（针对JDK8&#43;）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JVM介绍（针对JDK8+）</h4> 
 <ul><li><a href="#_4" rel="nofollow">关系图如下</a></li><li><a href="#_9" rel="nofollow">运行时数据区</a></li><li><ul><li><a href="#JVM_Java_Virtual_Machine_Stacks_10" rel="nofollow">JVM栈 (Java Virtual Machine Stacks)</a></li><li><a href="#_Heap_Memory_15" rel="nofollow">堆内存 (Heap Memory)</a></li><li><a href="#_Metaspace_21" rel="nofollow">方法区（元空间） (Metaspace)</a></li><li><a href="#_Native_Method_Stacks_26" rel="nofollow">本地方法栈 (Native Method Stacks)</a></li><li><a href="#_Program_Counter_PC_Register_34" rel="nofollow">程序计数器 (Program Counter (PC) Register)</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>之前整理过一篇jdk7以前版本的jvm，然后有朋友建议更新一下。实在不好意思，本人比较懒，好多东西只是记录在本地会更新到网上，今天咱们先简单聊一下jdk8+后jvm的的变动信息</p> 
<h2><a id="_4"></a>关系图如下</h2> 
<p><img src="https://images2.imgbox.com/30/08/rb7zKfJl_o.png" alt="在这里插入图片描述"><br> 有图可知，一个java文件首先由java编译器编译为class文件，在由类加载器加载到运行时数据区内，（类加载器和运行时数据区都属于jvm的概念，面试时不要丢掉任何一部分哦）。</p> 
<h2><a id="_9"></a>运行时数据区</h2> 
<h3><a id="JVM_Java_Virtual_Machine_Stacks_10"></a>JVM栈 (Java Virtual Machine Stacks)</h3> 
<p>每当启动一个新线程的时候，java虚拟机都会为它分配一个java栈。java以栈帧为单位保存线程的运行状态。虚拟机只会对java栈执行两种操作：以栈帧为单位的压栈或者出栈。<br> 一个栈帧包含：局部变量、操作数栈、动态链接、方法出口等信息</p> 
<h3><a id="_Heap_Memory_15"></a>堆内存 (Heap Memory)</h3> 
<p>存储的是对象实例和数组，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。<br> jvm只有一个堆区（heap）被所有线程共享<br> 堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。</p> 
<h3><a id="_Metaspace_21"></a>方法区（元空间） (Metaspace)</h3> 
<p>jdk8+以后，JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）<br> 元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存<br> 元空间中存储的数据：常量、8大基本数据类型、静态变量(static、final）、类信息（字节码信息）、即时编译器编译后的代码</p> 
<h3><a id="_Native_Method_Stacks_26"></a>本地方法栈 (Native Method Stacks)</h3> 
<p>和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</p> 
<p>Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加，因此也会对应抛出StackOverflowError和OutOfMemoryError错误。</p> 
<p>在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</p> 
<h3><a id="_Program_Counter_PC_Register_34"></a>程序计数器 (Program Counter (PC) Register)</h3> 
<p>用于保存当前线程执行的内存地址。</p> 
<p>由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</p> 
<p>先简单介绍到这里，后期会补充类加载的相关信息，上面描述如有问题，欢迎伙伴们提示</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73403ef5990443d8af305e42d7e5290f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">列表数据导出成Excel</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73fe1e00ee600253ec8cb266c0abc6f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">复杂网络度分布（幂律分布）图Python</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>