<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java split()方法简析 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java split()方法简析" />
<meta property="og:description" content="转载请标明出处： 原文首发于： http://www.zhangruibin.com 本文出自 RebornChang的博客 厚颜打广告，博主个人博客地址传送门 ，欢迎来访 split方法的分类 关于Java中的split方法，这里大致分为三种：
假定字符串String = “1，2，，，，，”，使用不同的split方法的话，其效果如下面所示；
js中的split方法 使用的方法： var string = “1，2，，，，，”； var arr = []; arr = value.split(&#34;,&#34;); alert（arr.length）； 可以得到此时的arr数组的长度为6，也就是说，后面的那些逗号中间的空字符串，并没有trim掉；
Java中的使用方法 split（String regex） String offerCodes = “1，2，，，，，”; String[] offerCodeString = offerCodes.split(&#34;,&#34;); System.out.println(&#34;offerCodeString.length&#34;&#43;offerCodeString.length); 控制台打印出来的数组长度为2；
可以看到，单参数，按照指定字符进行分割的话，后面的那些空字符串都默认去掉了，那如果我想要后面的这些空字符串怎么办？看下面的这种split方法；
split（Sting regex,int limit） String offerCodes = “1，2，，，，，”; String[] offerCodeString = offerCodes.split(&#34;,&#34;,-1); System.out.println(&#34;offerCodeString.length&#34;&#43;offerCodeString.length); 控制台打印出来的数组长度为6；
也就是说没有把后面的空字符串去掉，但是为什么后面的参数填个-1呢？能不能换成其他的值？那这么想的话就有必要走一波源码了；
Java jdk1.8 split源码简析 源码注释 string字符串的split方法从JDK1.4中开始存在，来一波源码里面的表格：
源码中给出了示例字符串：“boo:and:foo”；然后，传入不同的参数，得到的结果如下：
RegexLimitResult:2 &#34;boo&#34;, &#34;and:foo&#34; :5 &#34;boo&#34;, &#34;and&#34;, &#34;foo&#34; :-2 &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6d10eb10b8a4596f9deff93fe43d008c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-25T17:46:22+08:00" />
<meta property="article:modified_time" content="2018-10-25T17:46:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java split()方法简析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote>
  转载请标明出处： 
 <br> 原文首发于： 
 <a href="http://www.zhangruibin.com" rel="nofollow noopener noreferrer" target="_blank">http://www.zhangruibin.com</a> 
 <br> 本文出自 
 <a href="http://www.zhangruibin.com" rel="nofollow noopener noreferrer" target="_blank">RebornChang的博客</a> 
</blockquote> 
<h2><a id="httpzhangruibincom__4"></a><strong>厚颜打广告，博主个人博客地址<a href="http://zhangruibin.com" rel="nofollow">传送门</a> ，欢迎来访</strong></h2> 
<h2><a id="split_5"></a>split方法的分类</h2> 
<p>关于Java中的split方法，这里大致分为三种：<br> 假定字符串String = “1，2，，，，，”，使用不同的split方法的话，其效果如下面所示；</p> 
<h3><a id="jssplit_8"></a>js中的split方法</h3> 
<h4><a id="_9"></a>使用的方法：</h4> 
<pre><code>var string = “1，2，，，，，”；
var arr = [];
arr = value.split(",");
alert（arr.length）；
</code></pre> 
<p>可以得到此时的arr数组的长度为6，也就是说，后面的那些逗号中间的空字符串，并没有trim掉；</p> 
<h3><a id="Java_17"></a>Java中的使用方法</h3> 
<h4><a id="splitString_regex_18"></a>split（String regex）</h4> 
<pre><code>String offerCodes = “1，2，，，，，”; 
String[] offerCodeString = offerCodes.split(",");
System.out.println("offerCodeString.length"+offerCodeString.length);
</code></pre> 
<p>控制台打印出来的数组长度为2；<br> 可以看到，单参数，按照指定字符进行分割的话，后面的那些空字符串都默认去掉了，那如果我想要后面的这些空字符串怎么办？看下面的这种split方法；</p> 
<h4><a id="splitSting_regexint_limit_26"></a>split（Sting regex,int limit）</h4> 
<pre><code> String offerCodes = “1，2，，，，，”; 
 String[] offerCodeString = offerCodes.split(",",-1);
 System.out.println("offerCodeString.length"+offerCodeString.length);
</code></pre> 
<p>控制台打印出来的数组长度为6；<br> 也就是说没有把后面的空字符串去掉，但是为什么后面的参数填个-1呢？能不能换成其他的值？那这么想的话就有必要走一波源码了；</p> 
<h2><a id="Java_jdk18_split_34"></a>Java jdk1.8 split源码简析</h2> 
<h3><a id="_35"></a>源码注释</h3> 
<p><img src="https://images2.imgbox.com/0c/90/3Crq0kUT_o.png" alt="split源码"><br> string字符串的split方法从JDK1.4中开始存在，来一波源码里面的表格：<br> 源码中给出了示例字符串：“boo:and:foo”；然后，传入不同的参数，得到的结果如下：</p> 
<blockquote> 
 <table cellspacing="0" cellpadding="1"><tbody><tr><th>Regex</th><th>Limit</th><th>Result</th></tr><tr><td align="center">:</td><td align="center">2</td><td> "boo", "and:foo" </td></tr><tr><td align="center">:</td><td align="center">5</td><td> "boo", "and", "foo" </td></tr><tr><td align="center">:</td><td align="center">-2</td><td> "boo", "and", "foo" </td></tr><tr><td align="center">o</td><td align="center">5</td><td> "b", "", ":and:f", "", "" </td></tr><tr><td align="center">o</td><td align="center">-2</td><td> "b", "", ":and:f", "", "" </td></tr><tr><td align="center">o</td><td align="center">0</td><td> "b", "", ":and:f" </td></tr></tbody></table> 
</blockquote> 
<h3><a id="split_65"></a>split源码</h3> 
<pre><code>public String[] split(String regex, int limit) {
      /* fastpath if the regex is a
       (1)one-char String and this character is not one of the
          RegEx's meta characters ".$|()[{^?*+\\", or
       (2)two-char String and the first char is the backslash and
          the second is not the ascii digit or ascii letter.
       */
      char ch = 0;
      //这里是一堆的正则校验，大致是，传入的分割符是单符号位的，才进行下面的分割，否则，return Pattern.compile(regex).split(this, limit)调用另一个分割方法进行字符串分割位分割，文末会PO出此方法
      if (((regex.value.length == 1 &amp;&amp;
           ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) ||
           (regex.length() == 2 &amp;&amp;
            regex.charAt(0) == '\\' &amp;&amp;
            (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp;
            ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp;
            ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp;
          (ch &lt; Character.MIN_HIGH_SURROGATE ||
           ch &gt; Character.MAX_LOW_SURROGATE))
      {
          int off = 0;
          int next = 0;
          //从这里开始，进行limit值的入参及split逻辑
          //当传进来的值是正数的时候，limit &gt; 0 == true
          boolean limited = limit &gt; 0;
          //声明一个list集合对返回值结果进行存储，用于最后给String[]赋值
          ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
          //当没有按照指定的字符分割到最后一位的时候，执行while循环进行判断，然后使用substring（off, next）方法进行分割
          while ((next = indexOf(ch, off)) != -1) {
          //判断limited 为FALSE，即limit&lt;0，或者，list.size() &lt; limit - 1是否成立
              if (!limited || list.size() &lt; limit - 1) {
                  //若成立则使用substring（off, next）方法进行分割,并且加入到list中
                  list.add(substring(off, next));
                  //此时的初始标识符off为next+1
                  off = next + 1;
              } else {    // last one
                  //assert (list.size() == limit - 1);
                  //不成立的话调用substring(off, value.length)，此时value.length值为1
                  list.add(substring(off, value.length));
                  off = value.length;
                  break;
              }
          }
          // 如果不符合，则返回 this
          if (off == 0)
              return new String[]{this};

          // Add remaining segment
          if (!limited || list.size() &lt; limit)
              list.add(substring(off, value.length));

          // Construct result
          int resultSize = list.size();
          if (limit == 0) {
              while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) {
                  resultSize--;
              }
          }
          //将所得到的list集合进行截取，使用toArray（）方法赋值到String[] result中，所以这么看来，split方法的效率，是略差的
          String[] result = new String[resultSize];
          return list.subList(0, resultSize).toArray(result);
      }
      return Pattern.compile(regex).split(this, limit);
  } 
</code></pre> 
<p>总的来说：<br> limit 参数控制模式应用的次数，因此影响所得数组的长度。如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n ，而且数组的最后一项将包含所有超出最后匹配的定界符的输入。如果 n 为非正，那么模式将被应用尽可能多的次数，而且数组可以是任何长度。如果 n 为 0，那么模式将被应用尽可能多的次数，数组可以是任何长度，并且结尾空字符串将被丢弃。<br> 下面的源码就不解析啦，有兴趣的看官可以自行查看：</p> 
<pre><code>public String[] split(CharSequence input, int limit) {
      int index = 0;
      boolean matchLimited = limit &gt; 0;
      ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
      Matcher m = matcher(input);

      // Add segments before each match found
      while(m.find()) {
          if (!matchLimited || matchList.size() &lt; limit - 1) {
              if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {
                  // no empty leading substring included for zero-width match
                  // at the beginning of the input char sequence.
                  continue;
              }
              String match = input.subSequence(index, m.start()).toString();
              matchList.add(match);
              index = m.end();
          } else if (matchList.size() == limit - 1) { // last one
              String match = input.subSequence(index,
                                               input.length()).toString();
              matchList.add(match);
              index = m.end();
          }
      }

      // If no match was found, return this
      if (index == 0)
          return new String[] {input.toString()};

      // Add remaining segment
      if (!matchLimited || matchList.size() &lt; limit)
          matchList.add(input.subSequence(index, input.length()).toString());

      // Construct result
      int resultSize = matchList.size();
      if (limit == 0)
          while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
              resultSize--;
      String[] result = new String[resultSize];
      return matchList.subList(0, resultSize).toArray(result);
  }
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c722af5a0d7b1111e2931e8df8f837a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VMware下安装并配置CentOS6.5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1bc6ac352123890d8cc680fc58925d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VS中目录含义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>