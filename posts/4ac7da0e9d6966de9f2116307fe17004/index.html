<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot常用注释 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot常用注释" />
<meta property="og:description" content="1：@Qualifier
@Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了。所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。例子如下：
有一个接口：
public interface EmployeeService { public String getEmployeeById(Long id); } 有两个实现类：
@Service(&#34;service&#34;) public class EmployeeServiceImpl implements EmployeeService{ @Override public String getEmployeeById(Long id) { return &#34;0&#34;; } } @Service(&#34;service1&#34;) public class EmployeeServiceImpl1 implements EmployeeService{ @Override public String getEmployeeById(Long id) { return &#34;1&#34;; } } controller层调用service层：
@RestController public class EmployeeInfoControl { @Autowired @Qualifier(&#34;service&#34;) //括号里面的值是实现类@service时给类取得名字，加上此注解不会报错 private EmployeeService employeeService; @RequestMapping(&#34;/emplayee.do&#34;) public void showEmplayeeInfo(){ String employeeById = employeeService." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4ac7da0e9d6966de9f2116307fe17004/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-14T20:18:44+08:00" />
<meta property="article:modified_time" content="2018-12-14T20:18:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot常用注释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><em><strong>1：@Qualifier</strong></em></p> 
</blockquote> 
<p>@Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了。所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。例子如下：</p> 
<p>有一个接口：</p> 
<pre class="has"><code class="language-java">public interface EmployeeService {
    public String getEmployeeById(Long id);
}
</code></pre> 
<p>有两个实现类：</p> 
<pre class="has"><code class="language-java">@Service("service")
public class EmployeeServiceImpl implements EmployeeService{
    @Override
    public String getEmployeeById(Long id) {
        return "0";
    }
}


@Service("service1")
public class EmployeeServiceImpl1 implements EmployeeService{
    @Override
    public String getEmployeeById(Long id) {
        return "1";
    }
}</code></pre> 
<p>controller层调用service层：</p> 
<pre class="has"><code class="language-java">@RestController
public class EmployeeInfoControl {
    @Autowired
    @Qualifier("service")   //括号里面的值是实现类@service时给类取得名字，加上此注解不会报错
    private EmployeeService employeeService;
 
    @RequestMapping("/emplayee.do")
    public void showEmplayeeInfo(){
        String employeeById = employeeService.getEmployeeById(1l);
        System.out.println("employeeById值为"+employeeById);
    }
}

//此时会报错 因为@Autowired
//              private EmployeeService employeeService;
//注入的是service层的接口，此时有两个实现，不知道绑定的是哪个实现。
//此时应该在@Autowired下面配合@Qualifier注释使用，用来说明要绑定的具体是哪个实现类
//如上面所示</code></pre> 
<hr> 
<blockquote> 
 <p><em><strong>2：@RestController</strong></em></p> 
</blockquote> 
<p><span style="color:#f33b45;">注解在类上，表示这是一个控制层bean。</span>常用于控制层类的前面，是@<code>ResponseBody</code>和@<code>Controller</code>的合集 。</p> 
<p><em><strong>@ResponseBody</strong></em>：用该注解修饰的函数，会将结果直接填充到HTTP的响应体中，一般用于构建RESTful的api，将java对象转为json格式的数据。</p> 
<p><em><strong>@Controller</strong></em>：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层）。</p> 
<hr> 
<blockquote> 
 <p><em><strong>3： @RequestMapping</strong></em></p> 
</blockquote> 
<p>提供路由信息，负责URL到Controller中的具体函数的映射。</p> 
<hr> 
<blockquote> 
 <p><em><strong>4： @SpringBootApplication</strong></em></p> 
</blockquote> 
<p>该注解用在运行类之上，相当于@<code>EnableAutoConfiguration</code>、@<code>ComponentScan</code>和@<code>Configuration</code>的合集。 </p> 
<p><strong><em>@</em></strong><code><strong><em>EnableAutoConfiguration</em></strong>：</code>Spring Boot自动配置（auto-configuration）。</p> 
<p><strong><em>@</em></strong><code><strong><em>ComponentScan</em></strong>：</code>表示将该类自动发现（扫描）并注册为Bean，可以自动收集所有的Spring组件，包括<code>@Configuration</code>类。我们经常使用<code>@ComponentScan</code>注解搜索beans，并结合<code>@Autowired</code>注解导入。</p> 
<p><strong><em>@</em></strong><code><strong><em>Configuration</em></strong>：</code>相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类 ——可以使用<code>@ImportResource</code>注解加载xml配置文件。</p> 
<hr> 
<blockquote> 
 <p><strong><em>5：@Import</em></strong></p> 
</blockquote> 
<p>用来导入其他配置类。 </p> 
<hr> 
<blockquote> 
 <p><strong><em>6：@Autowired </em></strong></p> 
</blockquote> 
<p>自动导入依赖的bean。</p> 
<hr> 
<blockquote> 
 <p><strong><em>7：@Service </em></strong></p> 
</blockquote> 
<p> <span style="color:#f33b45;">注解在类上，表示这是一个业务层bean。</span></p> 
<hr> 
<blockquote> 
 <p><strong><em>8：@Repository</em></strong></p> 
</blockquote> 
<p><span style="color:#f33b45;">注解在类上，表示这是一个数据访问层bean。</span>使用@<code>Repository</code>注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan。 </p> 
<hr> 
<blockquote> 
 <p><strong><em>9：@Query  </em></strong></p> 
</blockquote> 
<p>自定义SQL查询语句 </p> 
<hr> 
<blockquote> 
 <p><strong><em>10：@Entity </em></strong> </p> 
</blockquote> 
<p>用在实体类的前面，表示这是一个实体类。 </p> 
<hr> 
<blockquote> 
 <p><strong><em>11：@Table(name=“”) </em></strong></p> 
</blockquote> 
<p>用在实体类的前面，一般和@Entity一起使用，表示该实体类映射数据库中的某张表。</p> 
<hr> 
<blockquote> 
 <p><strong><em>12：@Column</em></strong></p> 
</blockquote> 
<p> 表示实体类的某个属性映射为表中的某个字段，包含的设置如下：name：数据库表字段名；unique：是否唯一 ；nullable：是否可以为空 ；Length:长度。</p> 
<hr> 
<blockquote> 
 <p><strong><em>13：@Id</em></strong></p> 
</blockquote> 
<p>该注释用在实体类中，写在哪个属性的前面，表示该属性映射到数据库中的字段为主键。</p> 
<hr> 
<blockquote> 
 <p><strong><em>14：@GeneratedValue </em></strong></p> 
</blockquote> 
<p>表示主键的生成策略，和@Id一起使用 </p> 
<hr> 
<blockquote> 
 <p><strong><em>15：@Transient </em></strong></p> 
</blockquote> 
<p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient。 </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98f10929dc16733a8f899ccd1634ec44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">本地模式测试编写的MapReduce作业程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b872f9418600d87f06b160804b73c35b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">湘潭大学Java练习题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>