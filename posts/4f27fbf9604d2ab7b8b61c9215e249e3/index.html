<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java bitmap位图_简单实用算法——位图算法（BitMap） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java bitmap位图_简单实用算法——位图算法（BitMap）" />
<meta property="og:description" content="算法原理
BitMap的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此可以大大节省存储空间。
BitMap可以看成一种数据结构。
假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存。
在Java中，int占4字节，1字节=8位(1 byte = 8 bit)。
如果每个数字用int存储，那就是20亿个int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈7.45G
如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈0.233G
优点和缺点
优点：由于采用了Bit为单位来存储数据并建立映射关系来查找位置，因此可以大大减少存储空间，加快在大量数据中查询的时间。(有点哈希表的意思，但哈希中的value值数据类型可以丰富多样，而BitMap最终查到的value只能表示简单的几种状态。)
缺点：BitMap中的查询结果(value)能表达的状态有限，且所有的数据不能重复。即不可对重复的数据进行排序和查找。
算法实现(C#)
.NET中已经实现了BitMap的数据结构——BitArray，建议使用BitMap算法解决问题时直接使用官方的BitArray。
我参照.NET源码实现了一个简化版的BitMap，以int数组存储位值(最多存21亿个位值)，代码如下：
class BitMap
{
public int Length{ get{ return m_length;}
}
private int[] m_array;
private int m_length;
public BitMap(int length): this(length, false) { }
//索引根据需求添加
public bool this[int index]
{
get
{
return Get(index);
}
set
{
Set(index,value);
}
}
//分配空间以容纳长度位值, 位数组中的所有值都设置为defaultValue。
public BitMap(int length, bool defaultValue)
{
if (length &lt; 0) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4f27fbf9604d2ab7b8b61c9215e249e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-16T02:16:51+08:00" />
<meta property="article:modified_time" content="2021-02-16T02:16:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java bitmap位图_简单实用算法——位图算法（BitMap）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>算法原理</p> 
 <p>BitMap的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此可以大大节省存储空间。</p> 
 <p>BitMap可以看成一种数据结构。</p> 
 <p>假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存。</p> 
 <p>在Java中，int占4字节，1字节=8位(1 byte = 8 bit)。</p> 
 <p>如果每个数字用int存储，那就是20亿个int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈7.45G</p> 
 <p>如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈0.233G</p> 
 <p>优点和缺点</p> 
 <p>优点：由于采用了Bit为单位来存储数据并建立映射关系来查找位置，因此可以大大减少存储空间，加快在大量数据中查询的时间。(有点哈希表的意思，但哈希中的value值数据类型可以丰富多样，而BitMap最终查到的value只能表示简单的几种状态。)</p> 
 <p>缺点：BitMap中的查询结果(value)能表达的状态有限，且所有的数据不能重复。即不可对重复的数据进行排序和查找。</p> 
 <p>算法实现(C#)</p> 
 <p>.NET中已经实现了BitMap的数据结构——BitArray，建议使用BitMap算法解决问题时直接使用官方的BitArray。</p> 
 <p>我参照.NET源码实现了一个简化版的BitMap，以int数组存储位值(最多存21亿个位值)，代码如下：</p> 
 <p>class BitMap</p> 
 <p>{<!-- --></p> 
 <p>public int Length{ get{ return m_length;}</p> 
 <p>}</p> 
 <p>private int[] m_array;</p> 
 <p>private int m_length;</p> 
 <p>public BitMap(int length): this(length, false) { }</p> 
 <p>//索引根据需求添加</p> 
 <p>public bool this[int index]</p> 
 <p>{<!-- --></p> 
 <p>get</p> 
 <p>{<!-- --></p> 
 <p>return Get(index);</p> 
 <p>}</p> 
 <p>set</p> 
 <p>{<!-- --></p> 
 <p>Set(index,value);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>//分配空间以容纳长度位值, 位数组中的所有值都设置为defaultValue。</p> 
 <p>public BitMap(int length, bool defaultValue)</p> 
 <p>{<!-- --></p> 
 <p>if (length &lt; 0) {<!-- --></p> 
 <p>throw new ArgumentOutOfRangeException("length", "长度值不能小于0");</p> 
 <p>}</p> 
 <p>int arrayLength = length &gt; 0 ? (((length - 1) / 32) + 1) : 0;</p> 
 <p>m_array = new int[arrayLength];</p> 
 <p>m_length = length;</p> 
 <p>int fillValue = defaultValue ? unchecked(((int)0xffffffff)) : 0;</p> 
 <p>for (int i = 0; i &lt; m_array.Length; i++) {<!-- --></p> 
 <p>m_array[i] = fillValue;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>//返回位置索引处的位值。</p> 
 <p>public bool Get(int index) {<!-- --></p> 
 <p>if (index &lt; 0 || index &gt;= Length) {<!-- --></p> 
 <p>throw new ArgumentOutOfRangeException("index", "索引值超出范围");</p> 
 <p>}</p> 
 <p>return (m_array[index / 32] &amp; (1 &lt;&lt; (index % 32))) != 0;</p> 
 <p>}</p> 
 <p>//将位置索引处的位值设置为value。</p> 
 <p>public void Set(int index, bool value) {<!-- --></p> 
 <p>if (index &lt; 0 || index &gt;= Length) {<!-- --></p> 
 <p>throw new ArgumentOutOfRangeException("index", "索引值超出范围");</p> 
 <p>}</p> 
 <p>if (value) {<!-- --></p> 
 <p>m_array[index / 32] |= (1 &lt;&lt; (index % 32));</p> 
 <p>} else {<!-- --></p> 
 <p>m_array[index / 32] &amp;= ~(1 &lt;&lt; (index % 32));</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>算法应用</p> 
 <p>问题1：给40亿个不重复的unsigned int的整数，没有排过序，然后再给一个数，如果快速判断这个数是否在那40亿个数当中。(解决海量数据中的查询问题)</p> 
 <p>问题1解法：建立一个位集合，全部初始化为0。遍历40亿个不重复的整数，通过上述提供的一种映射(每个不重复的整数映射到给定的位)找到其位的位置，标记为1。判断这个数是否在大整数集合中，即通过映射关系计算此整数的位位置，检查是否为1，若为1，则存在，若为0，则不存在</p> 
 <p>问题2：数据库里存了很多800电话号码，数量特别大，以至于内存放不下，如何排序，时间比空间更重要？电话号码类似于800-810-5555。(高效排序)</p> 
 <p>问题2解法：其实就是不重复的任意7位数及其之内的排序问题。我们用1位来表示电话是否出现，遍历整个电话号序列，设置相应的位，遍历位图收集位被设置的号码即可。查看上述的实现代码</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04f630491ec1d8ec9dc75fe27c507471/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 判断元素是否在数组中_java中怎么判断某元素是否在数组中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96fceecf91aa1a011c3f3a9fa5dacc49/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础考试 基本语法_JAVA基础语法考点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>