<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>B&#43;树(5)myISAM简介 --mysql从入门到精通（十七) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="B&#43;树(5)myISAM简介 --mysql从入门到精通（十七)" />
<meta property="og:description" content="上篇文章我们说了，联合索引会用两个以上列来创建索引，b&#43;树是一颗，先用c2列排序，若结果相同，则用c3排序。innoDB的b&#43;树特点是根节点保持不变，新表是先默认有聚簇索引，先有一个没有数据的根目录节点，放用户记录数据放入根几点中，当数据慢了，页分裂，会有多的节点，此刻根节点进化成根目录记录节点，数据存入底层节点。二级索引的内节点保证一致性，存入列值的时候加个主键。
B&#43;树(4)联合索引 --mysql从入门到精通（十六)
myISAM简介 我们知道了innoDB搜索引擎的是索引即是数据，分为列表值索引树，和聚簇索引树，聚簇索引那颗b&#43;树索引即是数据，所有的用户记录数都存在叶子节点。而myISAM虽然也是B&#43;树，但索引和数据是分开的。
myISAM会吧用户记录数据全部放在一个文件里，称为数据文件，这个文件不会划分若干页，有多少记录就往里面塞，通过每一行对应的行号快速访问，因为随意塞入，不会按主键大小排序，不能用二分查找法查找。之后会吧索引信息存储到另一个索引文件里，myISAM会单独为表的主键创建索引，只不过在叶子节点存储的不是用户记录数据，而是主键&#43;行号，意味着找到到对应行号之后，会用行号去数据文件里再次找全部数据。所以myISAM每次查询都是必须要回表的，相当于二级索引。(innoDB的聚簇索引是直接在根目录记录页根据主键找到对应的内节点，在找到对应的底层叶子节点上的全部数据)。有需要的话，也可以建立二级索引或者联合索引，只是叶子节点存放的是列值&#43;行号。 创建索引和删除索引： 说了那么多理论知识，那如何实战呢？mysql中的innoDB和myISAM表会自动为主键或者申明的为unique的列创建聚簇索引，但如果需要给其他列创建二级索引，则需要在sql里显示指明。为啥不自动创建呢，别忘了越多的索引意味着越多的b&#43;树，意味着插入和删除都需要巨大的内存来维护b&#43;树，很耗费性能。
建表的时候可以创建索引，index 和 key关键字都可以使用，指定indx_tb_col表的c2列为idx_c2名称的索引：
create table index_tb_col( c1 int, c2 int, c3 char(1), index idx_c2 (c2) )row_format=Compact; 也可以在表创建完成之后，指定c3为idx_c3名称的索引：
mysql&gt; alter table index_tb_col add index idx_c3 (c3); Query OK, 0 rows affected (0.04 sec) 也可以添加联合索引和删除索引：
//复合索引 mysql&gt; create table index_tb_col( -&gt; c1 int, -&gt; c2 int, -&gt; c3 char(1), -&gt; primary key (c1), -&gt; index idx_c2_c3 (c2,c3) -&gt; )row_format=Compact; Query OK, 0 rows affected (0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5c84a1b201e1dd95e2f245b1dec72cb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-19T17:13:23+08:00" />
<meta property="article:modified_time" content="2021-08-19T17:13:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">B&#43;树(5)myISAM简介 --mysql从入门到精通（十七)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;">上篇文章我们说了，联合索引会用两个以上列来创建索引，b+树是一颗，先用c2列排序，若结果相同，则用c3排序。innoDB的b+树特点是根节点保持不变，新表是先默认有聚簇索引，先有一个没有数据的根目录节点，放用户记录数据放入根几点中，当数据慢了，页分裂，会有多的节点，此刻根节点进化成根目录记录节点，数据存入底层节点。二级索引的内节点保证一致性，存入列值的时候加个主键。</p> 
<p style="margin-left:0;"><a href="https://blog.csdn.net/ke1ying/article/details/119800388">B+树(4)联合索引 --mysql从入门到精通（十六)</a></p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0;">myISAM简介</h3> 
<p style="margin-left:0;">我们知道了innoDB搜索引擎的是索引即是数据，分为列表值索引树，和聚簇索引树，聚簇索引那颗b+树索引即是数据，所有的用户记录数都存在叶子节点。而myISAM虽然也是B+树，但索引和数据是分开的。</p> 
<ol><li style="text-align:justify;">myISAM会吧用户记录数据全部放在一个文件里，称为数据文件，这个文件不会划分若干页，有多少记录就往里面塞，通过每一行对应的行号快速访问，因为随意塞入，不会按主键大小排序，不能用二分查找法查找。</li><li style="text-align:justify;">之后会吧索引信息存储到另一个索引文件里，myISAM会单独为表的主键创建索引，只不过在叶子节点存储的不是用户记录数据，而是主键+行号，意味着找到到对应行号之后，会用行号去数据文件里再次找全部数据。所以myISAM每次查询都是必须要回表的，相当于二级索引。(innoDB的聚簇索引是直接在根目录记录页根据主键找到对应的内节点，在找到对应的底层叶子节点上的全部数据)。</li><li style="text-align:justify;">有需要的话，也可以建立二级索引或者联合索引，只是叶子节点存放的是列值+行号。</li></ol> 
<p style="text-align:justify;"></p> 
<h4 style="margin-left:0cm;">创建索引和删除索引：</h4> 
<p style="margin-left:0;">说了那么多理论知识，那如何实战呢？mysql中的innoDB和myISAM表会自动为主键或者申明的为unique的列创建聚簇索引，但如果需要给其他列创建二级索引，则需要在sql里显示指明。为啥不自动创建呢，别忘了越多的索引意味着越多的b+树，意味着插入和删除都需要巨大的内存来维护b+树，很耗费性能。</p> 
<p style="margin-left:0;">建表的时候可以创建索引，index 和 key关键字都可以使用，指定indx_tb_col表的c2列为idx_c2名称的索引：</p> 
<pre><code>create table index_tb_col(
	c1 int,
	c2 int,
	c3 char(1),
	index idx_c2 (c2)
)row_format=Compact;</code></pre> 
<p style="margin-left:0;">也可以在表创建完成之后，指定c3为idx_c3名称的索引：</p> 
<pre><code class="language-vbnet">mysql&gt; alter table index_tb_col add index idx_c3 (c3);
Query OK, 0 rows affected (0.04 sec)</code></pre> 
<p>也可以添加联合索引和删除索引：</p> 
<pre><code>//复合索引
mysql&gt; create table index_tb_col(
    -&gt; c1 int,
    -&gt; c2 int,
    -&gt; c3 char(1),
    -&gt; primary key (c1),
    -&gt; index idx_c2_c3 (c2,c3)
    -&gt; )row_format=Compact;
Query OK, 0 rows affected (0.03 sec)

//删除索引
mysql&gt; alter table index_tb_col drop index idx_c2_c3;
Query OK, 0 rows affected (0.03 sec)</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d69baabc4b735e5ab2df19e325ac8d21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac电脑必装清单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c3b09db12ffd77481ce0688b89108bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python如何实现剪贴板的操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>