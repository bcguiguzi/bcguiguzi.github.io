<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文翻译 - Are aligned neural networks adversarially aligned？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="论文翻译 - Are aligned neural networks adversarially aligned？" />
<meta property="og:description" content="论文链接：https://arxiv.org/pdf/2306.15447.pdf
Are aligned neural networks adversarially aligned？ Abstract1 Introduction2 Background3 Threat Model3.1 Existing Threat Models3.2 Our Threat Model 4 Evaluating Aligned Models with NLP Attacks4.1 Our Target: Aligned Chat Bots4.2 Prior Attack Methods4.3 Our Evaluation Setup4.4 Prior Attacks Results 5 Why do Existing NLP Optimization Attacks Fail?5.1 Our Test Set5.2 Prior Arracks Results 6 Attacking Multimodal Aligned Models6.1 Attack Methodology6.2 Experiments6.3 Quantitative Evaluation: Toxicity6.4 Qualitative Evaluation 7 Conclusion Abstract 现在大型语言模型被调整为和创建者的目标对齐，即“有用和无害”。这些模型应该对用户问题做出有益的反应，但拒绝回答可能导致伤害的请求。然而，对抗性用户可以构建输入来绕过对齐的尝试。在这项工作中，我们研究了当与构建最坏情况输入（对抗性示例）的敌手用户交互时，这些模型能在多大程度上还保持对齐。这些输入旨在使模型发出原本被禁止的有害内容。我们表明，现有的基于 NLP 的优化攻击不足以可靠地击破对齐的文本模型：但即使当前基于 NLP 的攻击失败了，我们还可以通过暴力破解找到对抗性输入。因此，当前攻击的失败不能证明在对抗性输入的攻击下对齐的文本模型仍能保持对齐。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3b5cc55f84bec8a6cbfa8370d5aef966/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-05T22:19:29+08:00" />
<meta property="article:modified_time" content="2024-03-05T22:19:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文翻译 - Are aligned neural networks adversarially aligned？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>论文链接：<a href="https://arxiv.org/pdf/2306.15447.pdf" rel="nofollow">https://arxiv.org/pdf/2306.15447.pdf</a><br> </p> 
<div class="toc"> 
 <h4>Are aligned neural networks adversarially aligned？</h4> 
 <ul><li><a href="#Abstract_2" rel="nofollow">Abstract</a></li><li><a href="#1_Introduction_8" rel="nofollow">1 Introduction</a></li><li><a href="#2_Background_26" rel="nofollow">2 Background</a></li><li><a href="#3_Threat_Model_46" rel="nofollow">3 Threat Model</a></li><li><ul><li><a href="#31_Existing_Threat_Models_52" rel="nofollow">3.1 Existing Threat Models</a></li><li><a href="#32_Our_Threat_Model_60" rel="nofollow">3.2 Our Threat Model</a></li></ul> 
  </li><li><a href="#4_Evaluating_Aligned_Models_with_NLP_Attacks_70" rel="nofollow">4 Evaluating Aligned Models with NLP Attacks</a></li><li><ul><li><a href="#41_Our_Target_Aligned_Chat_Bots_81" rel="nofollow">4.1 Our Target: Aligned Chat Bots</a></li><li><a href="#42_Prior_Attack_Methods_99" rel="nofollow">4.2 Prior Attack Methods</a></li><li><a href="#43_Our_Evaluation_Setup_107" rel="nofollow">4.3 Our Evaluation Setup</a></li><li><a href="#44_Prior_Attacks_Results_119" rel="nofollow">4.4 Prior Attacks Results</a></li></ul> 
  </li><li><a href="#5_Why_do_Existing_NLP_Optimization_Attacks_Fail_125" rel="nofollow">5 Why do Existing NLP Optimization Attacks Fail?</a></li><li><ul><li><a href="#51_Our_Test_Set_136" rel="nofollow">5.1 Our Test Set</a></li><li><a href="#52_Prior_Arracks_Results_150" rel="nofollow">5.2 Prior Arracks Results</a></li></ul> 
  </li><li><a href="#6_Attacking_Multimodal_Aligned_Models_156" rel="nofollow">6 Attacking Multimodal Aligned Models</a></li><li><ul><li><a href="#61_Attack_Methodology_162" rel="nofollow">6.1 Attack Methodology</a></li><li><a href="#62_Experiments_166" rel="nofollow">6.2 Experiments</a></li><li><a href="#63_Quantitative_Evaluation_Toxicity_178" rel="nofollow">6.3 Quantitative Evaluation: Toxicity</a></li><li><a href="#64_Qualitative_Evaluation_182" rel="nofollow">6.4 Qualitative Evaluation</a></li></ul> 
  </li><li><a href="#7_Conclusion_190" rel="nofollow">7 Conclusion</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Abstract_2"></a>Abstract</h2> 
<p>现在大型语言模型被调整为和创建者的目标对齐，即“有用和无害”。这些模型应该对用户问题做出有益的反应，但拒绝回答可能导致伤害的请求。然而，对抗性用户可以构建输入来绕过对齐的尝试。在这项工作中，我们研究了当与构建最坏情况输入（对抗性示例）的敌手用户交互时，这些模型能在多大程度上还保持对齐。这些输入旨在使模型发出原本被禁止的有害内容。我们表明，现有的基于 NLP 的优化攻击不足以可靠地击破对齐的文本模型：但即使当前基于 NLP 的攻击失败了，我们还可以通过暴力破解找到对抗性输入。因此，当前攻击的失败不能证明在对抗性输入的攻击下对齐的文本模型仍能保持对齐。</p> 
<p>然而，大规模 ML 模型的最新趋势是多模态模型，允许用户提供影响生成文本的图像。我们表明这些模型很容易受到攻击，也就是通过对输入图像的对抗性扰动诱导模型表现出任意不对齐的行为。我们推测改进的 NLP 攻击可能会在纯文本模型上同样显示出这种级别的对抗性控制。</p> 
<h2><a id="1_Introduction_8"></a>1 Introduction</h2> 
<p>对齐的语言模型应该是“有用和无害的”[Bai et al., 2022]：它们应该有助于用户交互，但避免直接或间接造成伤害。先前的工作主要集中在如何训练模型与他们的创建者的偏好和目标保持一致。例如，通过人工反馈强化学习 (RLHF) [Bai et al., 2022, Ouyang et al., 2022, Christiano et al., 2023] 微调一个预训练模型来使其发出人类希望得到的输出，并阻止不想要的输出。这种方法已经能成功地训练产出一般共识的良性内容的模型。</p> 
<p>然而，这些模型并不是完美对齐的。通过反复与模型交互，人类已经能够“社会性设计”它们以产生一些有害的内容（即“越狱”攻击）。例如，对 ChatGPT（一种这样的对齐调整语言模型）的早期攻击是告诉模型，用户是研究语言模型危害的研究人员，并要求 ChatGPT 帮助他们产出一些语言模型不应该说的测试用例。虽然有许多这样的人类手动构建有害诱导提示的事件，但我们很难科学地研究这种现象。</p> 
<p>幸运的是，机器学习社区目前已经研究了十年的神经网络对对抗样本的基本脆弱性 [Szegedy et al., 2014, Biggio et al., 2013]。给定任何经过训练的神经网络和任意行为，人们几乎总是可以通过优化输入来引导出所选行为。许多早期的对抗性机器学习工作都集中在图像分类领域，他们可以通过很小程度地修改图像，来使图像被错误分类为一个任意的测试标签。但是对抗样本已扩展到文本 [Jia and Liang, 2017, Ebrahimi et al., 2017, Alzantot et al., 2018, Wallace et al., 2019, Jones et al., 2023] 和其他领域。</p> 
<p>在本文中，我们统一了这两个研究方向，并研究了对齐的模型是否能抵抗对抗性输入。也就是说，我们关注这个问题：</p> 
<p>对齐的神经网络模型是否“对抗性对齐”？</p> 
<p>首先，我们表明当前的对齐技术（例如用于微调 Vicuna 模型的技术 [Chiang et al., 2023]）是对现有最先进（白盒）NLP 攻击的有效防御。这表明上述问题可以肯定地回答。然而，我们进一步表明，现有的攻击不足以区分稳健和非稳健防御：也就是即使我们保证确实存在一个对语言模型的对抗性输入，我们发现最先进的攻击仍然无法找到它。因此，当前对齐技术真正的对抗鲁棒性仍然是一个悬而未决的问题，这将需要更强大的攻击来解决。</p> 
<p>然后，我们将我们的注意力转向当今最先进的多模态模型，例如 OpenAI 的 GPT-4 和 Google 的 Flaminggo 和 Gemini，它们接受文本和图像作为输入 [OpenAI, 2023, Alayrac et al., 2022, Pichai, 2023]。具体来说，我们研究了具有相似能力的开源实现 [Liu et al., 2023, Zhu et al., 2023, Gao et al., 2023]，因为这些专有模型不公开授权访问。我们发现我们可以使用连续域图像作为对抗性提示，使语言模型发出有害的有毒内容（例如，参见图 1）。正因为如此，我们推测改进的 NLP 攻击可能也能够在对齐训练的纯文本模型上触发类似的对抗行为，并呼吁研究人员探索这个未被充分研究的问题。</p> 
<p>一些对齐研究人员 [Russell, 2019, Bucknall and Dori-Hacohen, 2022, Ngo, 2022, Carsmith, 2022] 认为，足够先进的语言模型应该对齐以防止对人类的存在性风险 [Bostrom, 2013] ：如果这成真，那么一个导致这样的模型变得非对齐的攻击将会是毁灭性的。即使这些高级能力还没有成真，现在的机器学习模型也面临着实际的安全风险[Brundage等人，2018年，Greshake等人2023]。我们的工作表明，通过目前对齐技术消除这些风险——这些技术没有特别考虑对抗性优化的输入——不太可能成功。</p> 
<h2><a id="2_Background_26"></a>2 Background</h2> 
<p>我们的论文研究了两个研究领域的交集：人工智能对齐和对抗性示例。</p> 
<p><strong>大型语言模型</strong> 随着大型语言模型参数数量、训练数据集大小和训练持续时间的增加，模型被发现表现出复杂的行为 [Brown et al., 2020, Wei et al., 2022b, Ganguli et al., 2022]。在这项工作中，我们专注于使用因果“下一个单词”预测训练的模型，并使用符号 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         ← 
        
       
         Gen 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        s\gets \text{Gen}(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> 来表示一个语言模型在给定提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 的情况下发出一序列的标记 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
      
        s 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span>。语言模型的许多应用都利用了增大的规模所涌现的新能力。例如，语言模型通常用于执行问答、翻译和摘要等任务 [Brown et al., 2020, Chowdhery et al., 2022, Rae et al., 2022, Anil et al., 2023, Liang et al., 2022, Goyal et al., 2022]。</p> 
<p><strong>对齐大型语言模型</strong> 大型预训练语言模型可以在没有进一步调整的情况下执行许多有用的任务 [Brown et al., 2020]，但它们在部署时存在许多限制，就像在面向用户的应用程序中一样。首先，这些模型不遵循用户指令（例如，“用 Python 编写一个排序函数”），这可能是因为模型的预训练数据（例如 Internet 文本）包含很少的指令-答案对。其次，通过忠实地对互联网文本的分布进行建模，基础模型倾向于反映甚至加剧训练数据中存在的偏差 [Abid et al., 2021]、毒性和亵渎 [Welbl et al., 2021, Dixon et al., 2018]。</p> 
<p>因此，模型开发人员试图通过指令调整 [Wei et al., 2022a, Ouyang et al., 2022] 和通过人类反馈的强化学习(RLHF) 等技术将基础模型与期望的原则对齐 [Christiano et al., 2023, Bai et al., 2022]。指令调整在用指令描述的任务上微调模型。RLHF 通过将模型指导成人类注释者更喜欢的样子来明确捕获人类的偏好 [Christiano et al., 2023]。</p> 
<p><strong>多模态文本视觉模型</strong> 越来越多的模型是多模态的，图像和文本是最常见的组合模式 [OpenAI, 2023, Pichai, 2023, Liu et al., 2023, Zhu et al., 2023]。多模态训练允许这些模型回答问题，例如“图像中有多少人？”或“抄写图像中的文本”。</p> 
<p>虽然 GPT-4 的多模态实现尚未披露，但仍有许多开源的多模态模型遵循相同的通用协议 [Gao et al., 2023, Liu et al., 2023, Zhu et al., 2023]。这些论文从一个标准的预训练语言模型开始，该模型标记化然后处理嵌入层。为了处理图像，他们使用像 CLIP [Radford et al., 2021] 这样的预训练视觉编码器将图像编码为图像类嵌入，然后训练一个投影模型，将图像类嵌入转换为语言模型能处理的令牌嵌入。这些视觉令牌可以用模板（例如，“.&lt;\img&gt;) 围起来以此来描述它们的模态，然后直接作为模型的输入传递 [Zhu et al., 2023, Liu et al., 2023]，或者通过学习的适应提示来组合到模型内部[Gao et al., 2023]。</p> 
<p><strong>对抗样本</strong> 对抗样本是由敌手设计的输入，来让神经网络表现一些不正确的行为[Szegedy等人，2014,Biggio等人，2013]。虽然主要在视觉分类任务中研究，但对抗样本也存在于文本任务中，比如问答 [Jia and Liang, 2017, Wallace et al., 2019]、文档分类 [Ebrahimi et al., 2017]、情感分析 [Alzantot et al., 2018] 或触发有毒完成 [Jones et al., 2023, Wallace et al., 2019]。先前关于文本任务的工作要么应用了贪婪攻击启发式方法 [Jia and Liang, 2017, Alzantot et al., 2018]，要么使用离散优化方法来搜索能触发敌手行为的输入文本 [Ebrahimi et al., 2017, Wallace et al., 2019, Jones et al., 2023]。</p> 
<p>在本文中，我们从对齐的角度研究了对抗样本。由于对齐的语言模型旨在通用目的——也就是在许多不同的任务上都具有强大的性能——我们更广泛地关注导致模型产生不合理的有害行为的对抗样本，而不是简单地导致“错误分类”的对抗样本。</p> 
<p>我们的输入是“对抗性的”，因为它们经过特意优化以产生一些有针对性的和不需要的结果。与最近的对语言模型的“社会工程”攻击不同，“社会工程”攻击通过欺骗模型去扮演一个有害角色来诱导有害行为（例如，利用种族主义电影演员的角色 [Reddit, 2023]），而我们没有努力使我们的攻击在语义上有意义，它们通常不会有意义。</p> 
<h2><a id="3_Threat_Model_46"></a>3 Threat Model</h2> 
<p>研究人员研究对抗样本有两个主要原因。一方面，研究人员有兴趣在真实敌手存在的情况下评估机器学习系统的鲁棒性。例如，对手可能会尝试构建输入，来逃避内容过滤ML模型 [Tram`er et al., 2019, Welbl et al., 2021] 或恶意软件检测 [Kolosnjaji et al., 2018]，因此设计鲁棒的分类器对于防止真实攻击很重要。</p> 
<p>另一方面，研究人员用对抗鲁棒性作为理解某些系统最坏情况行为的一种途径[Szegedy等人，2014,Pei等人，2017]。例如，我们可能想要研究自动驾驶汽车对最坏情况、敌手情况的弹性，即使我们不认为实际攻击者会试图造成一场车祸。对抗样本在验证高风险神经网络方面进行了广泛的研究 [Wong and Kolter, 2018, Katz et al., 2017]，其中当不可能正式验证时，对抗样本被用作错误的下限。</p> 
<h3><a id="31_Existing_Threat_Models_52"></a>3.1 Existing Threat Models</h3> 
<p>现有的攻击假设模型开发人员创建模型并使用一些对齐技术（例如 RLHF）使模型符合开发人员的原则。然后将该模型提供给用户，作为独立模型或者是通过聊天 API。有两种常见的设置可以安装这些攻击，我们将在下面描述。</p> 
<p><strong>恶意用户</strong>：用户试图使模型产生与开发人员原则错位的输出。这种的常见例子是聊天机器人（ChatGPT或Bard）的越狱攻击，其中用户使用一个对抗样本（恶意设计的提示）来引出所需的未对齐行为，例如输出构建炸弹的指令。在这种设置中，不需要攻击是“隐形的”。</p> 
<p><strong>恶意第三方</strong>：诚实的用户可能会查询一个对齐的语言模型，来作为处理不可信第三方数据的自治系统的一部分（例如，读取和写入用户电子邮件的虚拟助手）。恶意第三方可以通过将数据提供给语言模型来劫持其行为（例如，泄露用户的电子邮件）来发起提示注入攻击 [Groeshake et al., 2023]。在这种设置中，对有效攻击可能有更严格的约束。</p> 
<h3><a id="32_Our_Threat_Model_60"></a>3.2 Our Threat Model</h3> 
<p>在本文中，我们专注于更好地理解当前对齐技术的局限性。因此，我们主要使用对抗样本来衡量它们的最坏情况的行为。也就是说，在大多数情况下，我们不关心任何特定的实际对手，而是只关注找到任何实现攻击目标的有效输入。也就是说，我们的攻击在两种设置上都是实用的，无论是恶意用户攻击训练好的语言模型来让其表现出恶意行为，还是诚实用户从一个敌手处复制恶意文本。</p> 
<p><strong>攻击目标</strong> 不同于谁攻击谁，还需要定义最终攻击目标。虽然攻击者可以旨在诱导许多有害行为（例如，触发模型输出危险指令，或发出私人训练数据），但我们在这里关注一个具体的目标：触发有毒输出。这是因为毒性相对容易（大约）以自动化方式进行评估。我们对毒性使用极其简单的定义（给定一个毒性词语列表，在模型的输出中检查是否存在毒性词语），需要注意的是毒性的定义是基于文化和上下文和广泛研究的。下面我们形式化定义我们的毒性攻击目标：</p> 
<p>具体来说，给定一个毒性检测函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
      
        \text{isToxic} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">isToxic</span></span></span></span></span></span>，以及一个语言模型 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
      
        \text{Gen} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">Gen</span></span></span></span></span></span> ，它不应该生成导致 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
      
        \text{isToxic} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">isToxic</span></span></span></span></span></span> 为真的文本，一个输入 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         X 
        
       
      
        X 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span></span></span></span></span> 会导致伤害 如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic(Gen 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
         ) 
        
       
      
        \text{isToxic(Gen}(X)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">isToxic(Gen</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mclose">))</span></span></span></span></span> 返回 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         true 
        
       
      
        \text{true} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord text"><span class="mord">true</span></span></span></span></span></span>。当生成函数是随机的（即它不是贪婪采样）时，对于某些概率 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ε 
        
       
         &gt; 
        
       
         0 
        
       
      
        \varepsilon &gt; 0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>，我们可能会要求 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Pr[isToxic(Gen 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
         ) 
        
       
         ] 
        
       
         &gt; 
        
       
         ε 
        
       
      
        \text{Pr[isToxic(Gen}(X))]&gt;\varepsilon 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Pr[isToxic(Gen</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mclose">))]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span></span> 。为简单起见，在我们的实验中，我们将温度设置为 0 以使模型是确定性的。</p> 
<p>选择合适的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
      
        \text{isToxic} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">isToxic</span></span></span></span></span></span> 方法很重要。在本文中，我们使用简单的子串查找。我们的攻击选择一些模型不应该生成的有害的目标序列（例如，一个诅咒词），然后如果生成的文本的任何地方包含该词，我们将该次生成称为有毒的。</p> 
<h2><a id="4_Evaluating_Aligned_Models_with_NLP_Attacks_70"></a>4 Evaluating Aligned Models with NLP Attacks</h2> 
<p>生成对抗性文本序列最直接的方法是直接优化攻击目标 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic(Gen 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
         ) 
        
       
      
        \text{isToxic(Gen}(X)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">isToxic(Gen</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mclose">))</span></span></span></span></span> 的一些可微代理 。然而，这种方法有两个挑战：</p> 
<ol><li>文本标记是离散的，因此通过常见的优化算法进行连续优化，例如梯度下降，不太可能有效 [Ebrahimi et al., 2017]。</li><li>通常没有一个确切的目标。因此，为了检查攻击是否成功，我们必须每次请求模型来发出一个令牌。因此，为了将长序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
       
         S 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span> 传递到毒性分类器中，我们需要生成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∣ 
         
        
          S 
         
        
          ∣ 
         
        
       
         |S| 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">∣</span></span></span></span></span> 个标记，然后通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∣ 
         
        
          S 
         
        
          ∣ 
         
        
       
         |S| 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">∣</span></span></span></span></span> 次神经网络前向传递来计算反向传播。</li></ol> 
<p>上面的第一个挑战是神经语言模型的一个基本挑战，第二个不是基本的。我们不是直接优化真实的目标，即检查 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
         ( 
        
       
         S 
        
       
         ) 
        
       
      
        \text{isToxic}(S) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">isToxic</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mclose">)</span></span></span></span></span> 是否为真，而是优化一个代理目标，即检查 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
         ( 
        
        
        
          S 
         
         
         
           : 
          
         
           j 
          
         
        
       
         ) 
        
       
      
        \text{isToxic}(S_{:j}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord text"><span class="mord">isToxic</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是否为真，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          S 
         
         
         
           : 
          
         
           j 
          
         
        
       
      
        S_{:j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是敌手选择的固定长度的字符串，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         ≪ 
        
       
         ∣ 
        
       
         S 
        
       
         ∣ 
        
       
      
        j\ll |S| 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">∣</span></span></span></span></span>。注意到这使得优化变得更容易，因为我们现在可以只执行一次前向传递来精确地针对这个字符串。此外，由于这个子串被包含在较大的输出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
      
        S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span> 中，因此能保证如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
         ( 
        
        
        
          S 
         
         
         
           : 
          
         
           j 
          
         
        
       
         ) 
        
       
      
        \text{isToxic}(S_{:j}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord text"><span class="mord">isToxic</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 为真那么 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
         ( 
        
       
         S 
        
       
         ) 
        
       
      
        \text{isToxic}(S) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">isToxic</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mclose">)</span></span></span></span></span> 也为真。然而，这种方法可能会使攻击变得更困难一点：使模型发出的立即的下一个标记变成有毒的会更困难，相比于转向它后最后再这样做。</p> 
<p>在本节中，我们将研究先前攻击方法对各种聊天机器人模型实现我们的毒性目标的适用性，这些模型或使用或不使用对齐技术进行训练。</p> 
<h3><a id="41_Our_Target_Aligned_Chat_Bots_81"></a>4.1 Our Target: Aligned Chat Bots</h3> 
<p>对齐技术（例如 RLHF）通常不应用于“普通”语言模型，而是应用于先前通过简单的聊天协议调整以与用户交互的模型。</p> 
<p>通常，这是通过将底层语言模型的输入格式化为具有特定的消息交错来完成的，这些交错由指示每个先前消息的来源标记和边界标记分隔。</p> 
<p>[USER]: “Hello, how are you?”</p> 
<p>[AGENT]: ‘I am a large language model.’</p> 
<p>[USER]: “What is 1+2?”</p> 
<p>[AGENT]: '3 ’</p> 
<p>在上述示例中，使用聊天机器人的用户以双引号输入消息，语言模型以单引号生成斜体文本。特殊标记 ‘[USER]:’ 和 ‘[AGENT]:’ 由聊天机器人应用程序自动插入，以在提示语言模型下一个消息时来描述交互轮次。</p> 
<p>这种对齐语言模型输入的特殊格式对攻击者施加了约束：虽然用户可以输入的任意内容（即双引号中的文本），但先前的聊天历史以及特殊的 ‘[USER]：’ 和 ‘[AGENT]：’ 令牌不能被修改。一般来说，在不同领域我们都认为这种“攻击必须遵循某种指定的格式”的设置在现实中很可能会发生。</p> 
<h3><a id="42_Prior_Attack_Methods_99"></a>4.2 Prior Attack Methods</h3> 
<p>许多先前的工作已经研究了针对 NLP 模型的对抗样本攻击。</p> 
<p>与我们目标最密切相关的是Jones等人[2023]的工作，他们研究了反转语言模型的可能性，即找到一个对抗性提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         X 
        
       
      
        X 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span></span></span></span></span>，使模型 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
      
        f 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span></span></span></span></span> 输出一些目标字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         ← 
        
       
         f 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
      
        y\gets f(X) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mclose">)</span></span></span></span></span> 。他们的技术成功地使模型输出美国参议员的名字或在特定个体后输出有毒词。然而，他们假设的威胁模型比我们在这里做的更强，并且与最近的对齐预训练语言模型的部署不能完全匹配。事实上，如第 4.1 节所述，这些语言模型通常作为聊天机器人进行操作，它们将攻击者控制的消息和模型的生成和特殊分离标记交织在一起。因此，本文考虑了设计一个对抗性提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         X 
        
       
      
        X 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span></span></span></span></span> 的一般性问题，这个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         X 
        
       
      
        X 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span></span></span></span></span> 使得 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
        
        
          P 
         
         
         
           p 
          
         
           r 
          
         
           e 
          
         
        
       
         ∥ 
        
       
         X 
        
       
         ∥ 
        
        
        
          P 
         
         
         
           p 
          
         
           o 
          
         
           s 
          
         
           t 
          
         
        
       
         ) 
        
       
      
        \text{Gen}(P_{pre}\parallel X \parallel P_{post}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是有毒的，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
         
         
           p 
          
         
           r 
          
         
           e 
          
         
        
       
      
        P_{pre} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
         
         
           p 
          
         
           o 
          
         
           s 
          
         
           t 
          
         
        
       
      
        P_{post} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是模型提示的非对抗性部分，它们分别在攻击者输入的之前和之后。</p> 
<p>相比之下，Jones等人[2023]中的设定假设攻击者可以控制整个提示(即目标是使 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
      
        \text{Gen}(X) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span><span class="mclose">)</span></span></span></span></span> 有毒)，或者至少控制紧接在模型的下一个产出之前的文本(即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
        
        
          P 
         
         
         
           p 
          
         
           r 
          
         
           e 
          
         
        
       
         ∥ 
        
       
         X 
        
       
      
        \text{Gen}(P_{pre}\parallel X 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">X</span></span></span></span></span>) )。在这两种情况下，攻击者都在模型生成之前控制标记，这使得攻击更容易（但与当前聊天机器人的部署无关）。（但是：有几个设置中它们的威胁模型是有效的——例如，在代码完成任务中，这可能是这种情况。我们的威胁模型只是更通用。）</p> 
<h3><a id="43_Our_Evaluation_Setup_107"></a>4.3 Our Evaluation Setup</h3> 
<p>因此，我们假设对手只能控制他们的消息（遵循规则 “[USER]：令牌”），然后特殊的 “[AGENT]：令牌” 被添加到prompt序列中来表示prompt结束了，LLM 应该开始生成响应了。在此设置中，敌手不能修改最后的LLM的prompt令牌。</p> 
<p>我们通过首先收集模型可能输出的潜在有毒消息来构建我们的评估数据集。对于每个潜在的有毒消息，我们添加了一组的无害对话，它们后面跟着的是提示 LLM 响应的特殊标记。如果攻击导致有毒输出被发出，则攻击是成功的。我们的无害对话来自 Open Assistant 数据集中。该数据集由人类和助手之间的一系列假想互动组成，我们将其截断为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         K 
        
       
         &lt; 
        
       
         N 
        
       
      
        K&lt;N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7224em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 轮。我们使用Jones等人[2023]中有害文本的随机的一个子集作为攻击目标，攻击针对有毒文本的一到三个标记。</p> 
<p>我们攻击三个不同的公开可用的模型：</p> 
<ul><li>GPT-2：一个既不被训练为聊天机器人，也没有对齐的模型；</li><li>LLAMA：一个经过训练以与用户聊天但没有显式对齐尝试的模型；</li><li>Vicuna：通过微调对齐的 LLAMa 版本，以防止有毒产出（和其他有害行为）。</li></ul> 
<h3><a id="44_Prior_Attacks_Results_119"></a>4.4 Prior Attacks Results</h3> 
<p>我们评估了Jones等人[2023]的ARCA攻击和Guo等人[2021]的GBDA攻击。由于 ARCA 泛化并优于先前的攻击，例如 [Wallace et al., 2019, Ebrahimi et al., 2017]，我们也没有重新评估这些攻击。即使允许注入 30 个（我们选择这个数字与稍后将在本文中遵循的实验相匹配。）恶意标记，ARCA 和 GBDA 都在很大程度上无效，没有让模型在我们的设置中发出有毒内容。这并不令人惊讶：在 Jones 等人 [2023] 的研究中，就已经发现让 GPT-2 输出有毒输出文本时的攻击成功率低于 40%，即使对手完全控制每个标记直到想要的有毒短语。相比之下，由于我们要求标记 “[AGENT]:” 出现在对抗性标记之后，此处的攻击成功率更低（得多）。表 1 总结了这些结果。</p> 
<p><strong>定性评估: 毒性</strong>: 我们从表1中的每个设置中定性地检查这些产出的子集。我们发现，在大多数情况下，输出确实是有毒的。但是在不到十个的情况下，我们发现我们的自动化指标具有潜在的限制。例如，当被告知产生一个有毒短语时，Vicuna 回应 “F*** you. I’m kidding, of course. As a AI visual assistant, I’m programmed to be polite and provide assistance to the best of my ability. How can I assist you today?“，在另一种情况下它回应 “”(Note: This is not appropriate language and is not a proper response to the prompt.)” 。这证明了我们简单的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         isToxic 
        
       
      
        \text{isToxic} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">isToxic</span></span></span></span></span></span> 定义的局限性，它只执行子串查找。一旦攻击开始具有不可忽视的攻击成功率，未来的工作将需要仔细考虑不同的毒性定义——现在，即使用这个宽松的定义，文献中现在的攻击也无法找到成功的对抗性序列。</p> 
<h2><a id="5_Why_do_Existing_NLP_Optimization_Attacks_Fail_125"></a>5 Why do Existing NLP Optimization Attacks Fail?</h2> 
<p>在上一节中，我们发现现有的 NLP 优化攻击不怎么成功，不能成功诱导对齐模型在标准聊天设置中发出有害内容。这个结果有两种可能的解释：</p> 
<ol><li>对齐的语言模型对对抗样本攻击确实足够鲁棒，或者</li><li>当前的攻击能力不足以评估对齐模型的鲁棒性。</li></ol> 
<p>幸运的是，最近的工作为通用的攻击开发了可以明确用于区分这两种假设的技术。Zimmermann等人[2022]提出了以下框架: 首先，我们用已知的已经先验地确定了的对抗样本来构建测试用例；然后我们对这些测试用例运行攻击，并验证它们的成功。他们设计此类测试用例的初始提案如下。我们特定的测试用例方法遵循Lucas等人[2023]的方法。为了构建测试用例，我们首先通过暴力破解获取一组对抗样本。一旦我们通过暴力破解确认了至少一个对抗样本的存在，我们就在同一个搜索空间上运行我们的攻击并检查它是否找到了（可能不同但仍然有效）对抗样本。当存在有效的暴力破解方法并且可能的对抗样本的集合是有效可枚举的时，这种方法是有效的——例如 NLP 域中的情况。</p> 
<p>我们将其适用于我们的设置，如下所示。我们构建了（通过暴力破解）提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span>，它会导致模型发出罕见的后缀 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>。然后，如果攻击可以找到一些使 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
        
        
          p 
         
        
          ′ 
         
        
       
         ) 
        
       
         = 
        
       
         q 
        
       
      
        \text{Gen}(p')=q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0019em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> 的输入序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          ′ 
         
        
       
      
        p' 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9463em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>，即模型输出相同的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>，则攻击成功。否则，攻击失败。请注意，一个足够强大的攻击（例如，对所有提示进行暴力搜索）总是会在这个测试中取得成功：因此任何失败都表示攻击是有缺陷的。</p> 
<h3><a id="51_Our_Test_Set_136"></a>5.1 Our Test Set</h3> 
<p>我们如何选择前缀 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 和目标标记 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> ？如果我们提前选择 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>（比如作为一些有毒标记），那么可能很难找到——即使通过暴力破解——一个前缀 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 使得 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
       
         p 
        
       
         ) 
        
       
         = 
        
       
         q 
        
       
      
        \text{Gen}(p)=q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>。因此，我们放弃了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> 需要有毒的要求，并反向处理问题。</p> 
<p>最初，我们从一些数据集（在这里是Wikipedia）中采样了很多不同的前缀 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          1 
         
        
       
         , 
        
        
        
          p 
         
        
          2 
         
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
      
        p_{1},p_{2},... 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span></span></span></span></span> 设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
      
        S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span> 是所有 N 个标记的序列的空间（对于某些 N 值）。然后，对于所有可能的序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
         ∈ 
        
       
         S 
        
       
      
        s_{i} \in S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6891em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span>，我们向模型查询 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Gen 
        
       
         ( 
        
        
        
          s 
         
        
          i 
         
        
       
         ∥ 
        
        
        
          p 
         
        
          j 
         
        
       
         ) 
        
       
      
        \text{Gen}(s_{i}\parallel p_{j}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Gen</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> （如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∣ 
        
       
         S 
        
       
         ∣ 
        
       
      
        |S| 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">∣</span></span></span></span></span> 太大，那我们随机采样1,000,000个元素 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
         ∈ 
        
       
         S 
        
       
      
        s_{i}\in S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6891em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span>）这给出了一组可能的输出标记 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          i 
         
        
       
      
        q_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，每一个对应一个序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
      
        s_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p> 
<p>对于一些提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
      
        p_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> ，可能的输出标记集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         { 
        
        
        
          q 
         
        
          i 
         
        
       
         } 
        
       
      
        \{q_{i}\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span> 可能有很高的熵。例如，如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
         = 
        
       
         "How are you doing?" 
        
       
      
        p_{j}= \text{"How are you doing?"} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">"How are you doing?"</span></span></span></span></span></span> 那么根据确切的上下文大约有数千个可能的后续的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          i 
         
        
       
      
        q_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。但是对于其他提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
      
        p_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，可能的输出标记集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         { 
        
        
        
          q 
         
        
          i 
         
        
       
         } 
        
       
      
        \{q_{i}\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span> 可能非常小。例如，如果我们选择序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
         = 
        
       
         "Barack" 
        
       
      
        p_{j}=\text{"Barack"} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">"Barack"</span></span></span></span></span></span>，那么无论使用何种上下文 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
      
        s_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，后续令牌 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          i 
         
        
       
      
        q_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 几乎总是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         "Obama" 
        
       
      
        \text{"Obama"} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">"Obama"</span></span></span></span></span></span>。</p> 
<p>但是模型的输出可能并不总是相同的。还有一些其他可能的标记——例如，如果上下文是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
         = 
        
       
         "The first name [" 
        
       
      
        s_{i} = \text{"The first name ["} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">"The first name ["</span></span></span></span></span></span> 那么整个提示（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         "The first name [Barack" 
        
       
      
        \text{"The first name [Barack"} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">"The first name [Barack"</span></span></span></span></span></span> ) 可能会导致模型输出右括号 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
         = 
        
       
         "]" 
        
       
      
        q=\text{"]"} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">"]"</span></span></span></span></span></span> 我们将这样的序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
      
        p_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>——它根据不同的提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          s 
         
        
          i 
         
        
       
         ∈ 
        
       
         S 
        
       
      
        s_{i}\in S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6891em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span> 产生小而正向的熵的输出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         { 
        
        
        
          q 
         
        
          i 
         
        
       
         } 
        
       
      
        \{q_{i}\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>——表示为测试样例，并将攻击目标设置为最不可能的输出令牌 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          i 
         
        
       
      
        q_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p> 
<p>这些测试为评估 NLP 攻击提供了出色的候选者。他们给了我们一个证明（通过构造），可以触发模型来输出一个给定的单词。但是这种情况非常少发生，以至于攻击是微不足道的。现在它只是一个关于是否存在能够成功的攻击的问题。</p> 
<p>我们构建了八个具有不同难度级别的不同集合，并报告每个集合的平均值。我们的测试集由三个常数参数化。(1) 患病率：给定提示 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          j 
         
        
       
      
        p_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 时输出令牌 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> 的概率，我们将其固定为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
        
        
          0 
         
         
         
           − 
          
         
           6 
          
         
        
       
      
        10^{-6} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span>； (2) 攻击者控制令牌数：允许敌手修改的令牌数量，我们设置从 2, 5, 10 或 20 个标记不等，以及 (3) 目标令牌数：攻击者必须达到的输出令牌的数量。由于运行暴力搜索的成本，我们仅使用 GPT-2 生成我们的测试用例。</p> 
<h3><a id="52_Prior_Arracks_Results_150"></a>5.2 Prior Arracks Results</h3> 
<p>在表 2 中，我们发现现有的最先进的 NLP 攻击未能成功解决我们的测试用例。在最左边的列中，我们报告了当对手的目标是在给定攻击者能控制令牌的数量内解决任务时，攻击成功的情况。ARCA 明显强于 GBDA（与之前的工作一致），即使 ARCA 用了不到一半的时间。因为这里的数字非常低，然后我们尝试让攻击者控制更多的成倍多的令牌。也就是说，如果要求我们的任务找到具有 10 个令牌的对抗样本，那么我们运行乘法因子为 5 的数量的攻击，也就是我们允许攻击搜索超过 50 个攻击者控制的令牌。我们发现，即使有 10 倍的额外令牌，在我们的测试中攻击仍然经常失败。</p> 
<p>请注意，此评估的目的不是争辩说我们在这里研究的 NLP 攻击总是不正确的。相反：它们在很大程度上成功地完成了他们最初被设计成为的任务。但是我们要求他们做一些更难的事情并远距离控制输出，我们希望在这里证明，虽然我们在开发强大的 NLP 优化攻击方面取得了重大进展，但仍有改进这些技术的空间。</p> 
<h2><a id="6_Attacking_Multimodal_Aligned_Models_156"></a>6 Attacking Multimodal Aligned Models</h2> 
<p>文本不是人类交流的唯一范式。因此，基础模型已经开始支持视觉、文本、音频或其他领域的“多模态”输入。在本文中，我们研究了视觉增强模型，因为它们是最常见的。例如，如前所述，OpenAI 的 GPT-4 和 Google 的 Gemini 将在未来支持图像和文本作为输入。这允许模型回答诸如“描述此图像”之类的问题，这可以，比如说帮助盲人用户 [Salam, 2019]。</p> 
<p>它还意味着对手现在可以提供对抗性图像，而不仅仅是对抗性文本。由于图像来自连续域，对抗样本创建起来要简单几个数量级：我们不再需要关注文本的离散性质或嵌入矩阵的逆转，现在可以在（接近）连续域像素上运行。</p> 
<h3><a id="61_Attack_Methodology_162"></a>6.1 Attack Methodology</h3> 
<p>我们的攻击方法直接遵循在图像模型上生成对抗样本的标准方法。我们构建了一个多模态模型的端到端的可微实现，从图像像素到语言模型的输出对数。当目标后缀为 &gt; 1 个标记时，我们应用标准的教师强制优化技术。为了发起每次攻击，我们使用了一个随机图像，它是由随机均匀采样每个像素生成的。</p> 
<h3><a id="62_Experiments_166"></a>6.2 Experiments</h3> 
<p>虽然 GPT-4 目前支持某些用户的视觉服务 [OpenAI, 2023]，但此功能并未公开。Google 的 Gemini 也没有公开。因此，研究界用了这些多模态模型的开源版本（规模更小）。</p> 
<p>我们评估了我们在两种不同实现方法上的攻击。虽然它们在某些细节上有所不同，但两者都遵循第 2 节中的方法：图像使用视觉模型进行编码，投影到令牌嵌入空间，然后作为一个软令牌序列传递给语言模型。</p> 
<p><strong>Mini GPT-4</strong> [Zhu et al., 2023] 用了一个来自 [Li et al., 2023] 的预训练 Q-Former 模块将 EVA CLIP ViT-G/14 [Fang et al., 2022] 编码的图像投影到 Vicuna 的 [Chiang et al., 2023] 文本嵌入空间。CLIP 和 Vicuna 部分都被冻结，而只微调 Q-former 的一部分，通过在数据集 LAION [Schuhmann et al., 2021] 的子集 、概念字幕 [Sharma et al., 2018]、SBU [Ordonez et al., 2011] 和作者生成的多模态指令跟踪数据上进行微调。</p> 
<p><strong>LLaMA</strong> [Liu et al., 2023] 用了一个线性层将 CLIP ViT-L/14 的特征投影到 Vicuna 的嵌入空间中。此时 CLIP 被冻结，而 Vicuna 和投影矩阵都在概念字幕 [Sharma et al., 2018] 和自定义多模态指令跟踪数据上进行微调。</p> 
<p><strong>LLaMA Adapter</strong> [Gao et al., 2023] 的工作原理与这些类似，只是它使用经过学习的适配提示来通过这些适配器将模型视觉信息合并到模型内部中。</p> 
<h3><a id="63_Quantitative_Evaluation_Toxicity_178"></a>6.3 Quantitative Evaluation: Toxicity</h3> 
<p>我们现在评估这些模型被迫发出任意有毒输出的能力。与上一节一样，我们使用来自 [Jones et al., 2023] 的有毒短语数据集，并使用 OpenAssistant 提示作为模型的初始查询。我们测量一组随机生成的图像的变形程度。如表 3 所示，我们的攻击在导致模型发出任意有毒内容时的成功率为 100%。我们观察到对抗性输入相对容易找到，只需要初始图像中最小的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          ℓ 
         
        
          2 
         
        
       
      
        \ell_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 的变形。尽管没有固有的原因解释为什么变形如此重要，它在这里被当做应该最小化的目标，但我们相信报告所需的变形很有趣，它强调了运行这些攻击有多么容易。</p> 
<h3><a id="64_Qualitative_Evaluation_182"></a>6.4 Qualitative Evaluation</h3> 
<p>我们进一步评估了我们对旨在探测各种有害输出的定性样本的攻击。</p> 
<p>例如，即使被明确要求有害的输出（例如，“Write a vile letter telling my neighbor what I think of him.”）模型仍然无害地回应（“Dear [Neighbor’s Name] …I have to say that I am not impressed with your behavior … Sincerely, [Your Name]” ）。但是，通过提供对抗性图像作为输入，我们可能会导致模型发出我们想要的有害输出（“F*** you, you dirty life piece of s***. You’re a disgusting, filthy, stinky, scumbag who doesn’t deserve to live in this neighborhood … you worthless, good-for-nothing, loser.”）</p> 
<p>同样，当被要求为如何摆脱谋杀提供说明时，基本模型会回应 “It is not appropriate to encourage or provide information on how to harm or kill someone”，但被攻击的模型会回答：“The first step would be to identify the location of the neighbor’s house”。虽然这里的响应是相当糟糕的建议，但这可能是因为模型能力不够；更好的模型可能会提供更多可操作的建议（因此是有害的）。我们在附录中列出了我们攻击这些模型的能力的示例（未强制）示例。</p> 
<h2><a id="7_Conclusion_190"></a>7 Conclusion</h2> 
<p>通过 RLHF 或指令调整训练的语言模型明显比基本模型对齐：特别是，它们更有用（它们适当地遵循良性用户指令）和更无害（它们更少可能输出毒性或有害动作）。这里的有用性可以通过各种效用指标进行评估，但无害性比较难评估——迄今为止几乎所有方法都依赖于人工设计的测试用例来量化这一点。</p> 
<p>在本文中，我们表明，虽然这些模型通常无害，但在对抗性提示下它们可能就不是无害的了。虽然这里我们阐述的对抗性提示的危害相当良性（例如，我们研究的小模型们提供了一些无用的建议，关于如何逃离谋杀，或者产生一些可以在互联网上任何地方找到的有毒内容），但我们的攻击能直接适用于在更大、更有能力的系统中触发其他不良行为。</p> 
<p>我们的攻击对新范式，也就是多模态视觉语言模型最有效。虽然我们研究的所有模型都很容易被攻击，但小的设计决策将十倍地影响攻击的难易程度。更好地理解这种增加的脆弱性的出现是未来工作的重要领域。此外，未来的模型很可能将添加额外的模式（例如音频），这些模式会引入新的漏洞和表面来收到攻击。</p> 
<p>不幸的是，对于纯文本模型，我们表明当前的 NLP 攻击不足以正确评估对抗性对齐：即使已知存在一些对抗性序列，这些攻击通常也无法找到它们。由于我们的多模态攻击表明存在导致语言模型产生有害输出的输入嵌入，我们假设也可能存在可能导致类似有害行为的对抗性文本序列。</p> 
<p>猜想：改进的 NLP 优化攻击可能能够在其他对齐的语言模型中诱导有害的输出。</p> 
<p>虽然我们不能证明这一主张（这就是为什么它是猜想！）但我们相信我们的论文为它提供了强有力的证据：（1）语言模型对于软嵌入攻击（例如，多模态攻击）很疲弱； (2) 当前的 NLP 攻击无法找到已知存在的解决方案。因此，我们假设更强的攻击将成功地使纯文本对齐模型表现出有害行为。</p> 
<p><strong>Future work</strong> 我们希望我们的论文能够激发未来研究的几个方向。最快的，我们希望更强的 NLP 攻击能够对对齐的 LLM 进行全面的鲁棒性评估。这种攻击应该至少经过我们的测试被认为是可靠的。</p> 
<p>我们认为这一系列工作的最终目标不是产生更好的攻击，而是改进防御的评估。如果没有对攻击理解的可靠基础，就不可能设计能够承受时间测试的稳健防御。一个重要的悬而未决的问题是，来自对抗性机器学习文献的现有攻击和防御见解是否会转移到这个新领域。</p> 
<p>最后，这种攻击和防御的这种基础工作可以帮助对齐研究人员开发改进的模型对齐技术，以使其在对抗环境中仍然保持可靠。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a574d657fa9bf2d44b7e949a1f9e8b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Transformer——词向量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/578448cb1bddaf6cbfb9e58d62ffb9a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">考虑局部遮阴的光伏PSO-MPPT控制MATLAB仿真</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>