<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AI -朴素贝叶斯 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AI -朴素贝叶斯" />
<meta property="og:description" content="🎬朴素贝叶斯原理 朴素贝叶斯是一种基于概率论和统计学的分类算法，它的核心是贝叶斯定理和特征条件独立假设。
数据分析：在处理不确定性和不完全数据集时，贝叶斯方法可以帮助我们做出更加合理的推断。模式识别：在机器学习中，贝叶斯公式可以用来识别和分类模式，例如垃圾邮件过滤器。统计决策：在需要做出基于概率的决策时，贝叶斯公式提供了一种系统的方法和框架。 它通过计算给定数据集中的先验概率和条件概率来确定每个类别的后验概率，并将样本分配给具有最大后验概率的类别。朴素贝叶斯算法的核心思想非常直接，它依赖于一个关键假设，即特征之间在给定类别的条件下是相互独立的。尽管这个假设在现实中不一定总是成立，但它极大地简化了模型的构建和计算过程。朴素贝叶斯算法的优点在于其简单、易于实现，并且对于大规模数据集的处理效率较高。
在实际应用中，朴素贝叶斯算法因其简单性和高效性而被广泛应用于文本分类、垃圾邮件过滤、情感分析等领域。此外，由于其基于概率的特性，朴素贝叶斯模型还可以提供关于分类决策的置信度估计，这在某些应用中非常有用。
🔎概率公式 条件概率： 表示事件A在另外一个事件B已经发生条件下的发生概率，P(A|B) 联合概率： 表示多个条件同时成立的概率，P(AB) = P(A) P(B|A)
特征条件独立性假设：P(AB) = P(A) P(B) 🔎贝叶斯公式 贝叶斯公式可以表示为：
[ P(A|B) = \frac{P(B|A) cdot P(A)}{P(B)} ]
其中，( P(A|B) ) 是在事件B发生的条件下事件A发生的概率，即后验概率；( P(B|A) ) 是在事件A发生的条件下事件B发生的概率，即似然概率；( P(A) ) 是事件A发生的先验概率；( P(B) ) 是事件B发生的边缘概率。
贝叶斯公式的核心意义在于，它可以让我们基于新的数据或信息来更新对一个事件发生概率的估计。
🔎朴素贝叶斯 贝叶斯概率计算过程中，需要计算联合概率，为了简化联合概率的计算，朴素贝叶斯在贝叶斯基础上增加：特征条件独立假设，即：特征之间是互为独立的。 由于训练样本的不足，导致概率计算时出现 0 的情况。为了解决这个问题，我们引入了拉普拉斯平滑系数。
拉普拉斯平滑，也称为加1平滑，是处理零概率问题的一种常用方法。
在朴素贝叶斯分类器中，当计算某个特征在给定类别下的概率时，如果该特征在训练集中没有出现，则其概率会被计算为0。这可能导致在分类新的实例时忽略那些未在训练集中出现的 feature-category 组合。为了解决这个问题，拉普拉斯平滑被引入，确保所有的概率预测都大于0。
拉普拉斯平滑的基本思想是给每个可能的feature-category组合的计数都加上一个常数（通常选择1），同时为了保持概率的总和为1，分母也需要做相应的调整。公式可以表示为：
[ P(A_j|B_k) = frac{count(A_j, B_k) &#43; 1}{sum(count(A_j, B_k)) &#43; K} ]
其中，( P(A_j|B_k) ) 是在类别 ( B_k ) 的条件下特征 ( A_j ) 出现的概率，( count(A_j, B_k) ) 是训练集中特征 ( A_j ) 在类别 ( B_k ) 中出现的次数，( sum(count(A_j, B_k)) ) 是所有特征在类别 ( B_k ) 中出现的总次数，而 ( K ) 是类别的总数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/25e2663ccb1c9c88b9e397e3652c2092/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T21:41:41+08:00" />
<meta property="article:modified_time" content="2024-03-16T21:41:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AI -朴素贝叶斯</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>🎬朴素贝叶斯原理</h4> 
<p>朴素贝叶斯是一种基于<strong>概率论和统计学的分类算法</strong>，它的核心是贝叶斯定理和特征条件独立假设。</p> 
<ul><li><strong>数据分析</strong>：在处理不确定性和不完全数据集时，贝叶斯方法可以帮助我们做出更加合理的推断。</li><li><strong>模式识别</strong>：在机器学习中，贝叶斯公式可以用来识别和分类模式，例如垃圾邮件过滤器。</li><li><strong>统计决策</strong>：在需要做出基于概率的决策时，贝叶斯公式提供了一种系统的方法和框架。</li></ul> 
<p>它通过计算给定数据集中的先验概率和条件概率来确定每个类别的后验概率，并将样本分配给具有最大后验概率的类别。朴素贝叶斯算法的核心思想非常直接，它依赖于一个关键假设，即特征之间在给定类别的条件下是相互独立的。尽管这个假设在现实中不一定总是成立，但它极大地简化了模型的构建和计算过程。朴素贝叶斯算法的优点在于其简单、易于实现，并且对于大规模数据集的处理效率较高。</p> 
<p>在实际应用中，朴素贝叶斯算法因其简单性和高效性而被广泛应用于文本分类、垃圾邮件过滤、情感分析等领域。此外，由于其基于概率的特性，朴素贝叶斯模型还可以提供关于分类决策的置信度估计，这在某些应用中非常有用。</p> 
<h4 id="1">🔎概率公式</h4> 
<p><strong>条件概率：</strong> 表示事件A在另外一个事件B已经发生条件下的发生概率，P(A|B) </p> 
<p><strong>联合概率：</strong> 表示多个条件同时成立的概率，P(AB) = P(A) P(B|A)<br> 特征条件独立性假设：P(AB) = P(A) P(B) </p> 
<h4>🔎贝叶斯公式 </h4> 
<p>贝叶斯公式可以表示为：</p> 
<p>[ P(A|B) = \frac{P(B|A) cdot P(A)}{P(B)} ]</p> 
<p>其中，( P(A|B) ) 是在事件B发生的条件下事件A发生的概率，即后验概率；( P(B|A) ) 是在事件A发生的条件下事件B发生的概率，即似然概率；( P(A) ) 是事件A发生的先验概率；( P(B) ) 是事件B发生的边缘概率。</p> 
<p><strong>贝叶斯公式的核心意义在于，它可以让我们基于新的数据或信息来更新对一个事件发生概率的估计。</strong></p> 
<h4>🔎朴素贝叶斯 </h4> 
<p>贝叶斯概率计算过程中，需要计算联合概率，为了简化联合概率的计算，朴素贝叶斯在贝叶斯基础上增加：<strong>特征条件独立假设</strong>，即：特征之间是互为独立的。 </p> 
<p>由于训练样本的不足，导致概率计算时出现 0 的情况。为了解决这个问题，我们引入了拉普拉斯平滑系数。</p> 
<p><strong>拉普拉斯平滑，也称为加1平滑，是处理零概率问题的一种常用方法</strong>。</p> 
<p>在朴素贝叶斯分类器中，当计算某个特征在给定类别下的概率时，如果该特征在训练集中没有出现，则其概率会被计算为0。这可能导致在分类新的实例时忽略那些未在训练集中出现的 feature-category 组合。为了解决这个问题，拉普拉斯平滑被引入，确保所有的概率预测都大于0。</p> 
<p>拉普拉斯平滑的基本思想是给每个可能的feature-category组合的计数都加上一个常数（通常选择1），同时为了保持概率的总和为1，分母也需要做相应的调整。公式可以表示为：</p> 
<blockquote> 
 <p>[ P(A_j|B_k) = frac{count(A_j, B_k) + 1}{sum(count(A_j, B_k)) + K} ]</p> 
</blockquote> 
<p>其中，( P(A_j|B_k) ) 是在类别 ( B_k ) 的条件下特征 ( A_j ) 出现的概率，( count(A_j, B_k) ) 是训练集中特征 ( A_j ) 在类别 ( B_k ) 中出现的次数，( sum(count(A_j, B_k)) ) 是所有特征在类别 ( B_k ) 中出现的总次数，而 ( K ) 是类别的总数。</p> 
<h4>🧮垃圾邮件分类</h4> 
<p><strong>垃圾邮件分类数据集是用于训练和测试邮件分类算法的一组数据，它们包含了各种各样的电子邮件样本，其中一些被标记为垃圾邮件，另一些则不是</strong>。这些数据集通常用于机器学习和数据挖掘领域，以研究和开发能够有效识别垃圾邮件的技术。</p> 
<pre><code class="language-python">from sklearn.naive_bayes import MultinomialNB
import pandas as pd
import codecs
import re
import jieba
import time
from sklearn.feature_extraction.text import CountVectorizer
import numpy as np
from sklearn.model_selection import train_test_split
import joblib
from collections import Counter
import random

filename1 = 'data1.csv'
filename2 = 'data2.csv'
filename3 = 'data3.csv'

def email():

    email_labels = []
    email_contents = []
    sample_number = 500

    
    for line in open('dataindex'):

        # 获得邮件标签
        label, data = line.strip().split()

        # 读取邮件内容
        file_name = 'data/trec06c' + data[2:]
        file_data = codecs.open(file_name, 'r', 'gbk', errors='ignore').read()

        # 存储标签和数据
        email_labels.append(label)
        email_contents.append(file_data)

    # 从所有邮件中随机选择垃圾和正常邮件各 1000 封邮件
    email_data = pd.DataFrame({'content': email_contents, 'label': email_labels})
    spam_email = email_data[email_data['label'] == 'spam'].sample(sample_number)
    ham_email = email_data[email_data['label'] == 'ham'].sample(sample_number)

    # 邮件拼接一起
    email_data = pd.concat([spam_email, ham_email])
    email_data.to_csv(filename1)</code></pre> 
<pre><code class="language-python">def email_training():

    #读取数据
    data = pd.read_csv(filename3)
    x = data.iloc[:, :-1]
    y = data.iloc[:, -1]

    # 数据集分割
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, stratify=y)

    # 模型训练
    estimator = MultinomialNB()
    estimator.fit(x_train, y_train)

    # 保存模型
    joblib.dump(estimator, 'model/multinomialnb.pth')

    
    accurary = estimator.score(x_test, y_test)
    print('预测准确率:', accurary)


if __name__ == '__main__':
    email_from_file()
    preprocess_email()
    email_vectorize()
    email_training()</code></pre> 
<p>朴素贝叶斯算法的一个小结：</p> 
<ul><li> <p><strong>基于贝叶斯定理</strong>：朴素贝叶斯算法的核心是贝叶斯定理，它允许我们在已知某些特征的条件下，计算一个类别的概率。这使得贝叶斯算法成为一种自然的统计分类方法。</p> </li><li> <p><strong>条件独立假设</strong>：朴素贝叶斯算法的关键假设是特征之间在给定类别的条件下是相互独立的。尽管这个假设在现实中不一定总是成立，但它极大地简化了模型的构建和计算过程。</p> </li><li> <p><strong>拉普拉斯平滑</strong>：为了处理零概率问题，朴素贝叶斯算法通常采用拉普拉斯平滑技术，确保所有的概率预测都大于0，从而提高模型的鲁棒性。</p> </li><li> <p><strong>离散化处理</strong>：由于朴素贝叶斯方法通常用于大量样本的分类问题，它往往采用离散化方法来处理特征，而不是连续概率分布的估计方法。</p> </li><li> <p><strong>多种变体</strong>：朴素贝叶斯算法有多种变体，包括高斯朴素贝叶斯、多项式朴素贝叶斯和伯努利朴素贝叶斯等，这些变体主要在于它们对数据分布的不同假设。</p> </li><li> <p><strong>概率分类</strong>：朴素贝叶斯算法利用特征之间相互独立的假设，将概率分析转换成概率分类，通过计算特征输出和特征X的联合分布，直接找出最大的类别来进行分类。</p> </li><li> <p><strong>应用广泛</strong>：朴素贝叶斯算法因其简单性和高效性而被广泛应用于文本分类、垃圾邮件过滤、情感分析等领域。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8a2de19c4519d6324c8e18cc2a7b2ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数学建模--MATLAB基本使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e7cc53f8e517c687aecf257d06ff5f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MatLab】之：Simulink安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>