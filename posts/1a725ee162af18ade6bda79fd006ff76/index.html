<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java设计模式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java设计模式" />
<meta property="og:description" content="简单工厂模式 父类调用抽象方法，根据传参不同，调用的子类对象不同，实现不同的折扣计算
策略模式 策略模式：对象的行为模式抽象，将算法封装起来，将使用算法与实现算法解耦，委派给不同对象对算法进行管理
单例模式 单例模式：内存中只有一个实例，减少内存开销，设置全局的getInstance方法共享资源，跨线程使用；
应用场景：
1.频繁创建类用单例减少内存和GC,
2.需求上只需要生成一次
3.类创建占用资源多时间长，且不怎么会改变的类
懒汉式
饿汉式
代理模式 代理模式：一个用户不想直接访问某个对象，找中介代理，(比如买火车票用12306，找工作boss，找家政等平台代理，开发中避免用户直接访问服务器用nginx代理)；
优点：中介可以保护目标对象，扩展程序方便，可以在代理类访问对象并在前后做处理
原型模式 原型模式：把一个已经创建好的实例作为原型，复制原型作为一个新的对象，高效，无需关系创建细节，优点：克隆接口是基于二进制流的方式，性能高，深克隆可以将对象的状态也保存下来，减少对象创建；缺点：每个对象都要实现克隆方接口，深克隆可能存在多个对象嵌套引用，比较麻烦
适配器模式 适配器模式：将一个类的接口转换成客户希望的另一个接口，让原本不兼容的类，接口一起工作，有类适配器和对象适配器，一般使用对象适配器，类适配器耦合度很高。
优点：通过适配器透明调用接口，代码复用
缺点：代码需要结合业务，复杂性高，可读性低。例子：充电口协议标准各个国家不同，需要用转换器或者适配器完成充电
装饰性模式 装饰性模式：扩展类用组合的方式创建修饰对象包裹真实对象，在保证真实对象不变的前提下，增加额外的功能。
优点：动态扩展类的功能，装饰排列组合能实现不同的效果，遵守开闭原则，
缺点：有很多子类，增加程序的复杂性
桥接模式 桥接模式：将抽象与实现分离，用组合代替继承关系。
优点：扩展性强，符合开闭原则，合成复用原则，对用户透明
缺点：建立在抽象层，需要对需求理解设计强
外观模式 外观模式：为子系统中的一组接口提供一个统一的入口，定义一个高层接口，使得访问子系统更加容易。
优点：降低子系统和客户端的耦合度，读用户透明，为用户屏蔽了子系统的组件，降低编译的依赖jar包；
缺点：设计不合理时可能违反开闭原则
享元模式 享元模式：缓存共享降低内存损耗，
优点：相同对象只要保存一份，降低系统对象数量，减少内存压力；
缺点：读取享元外部状态响应时间长
组合模式 组合模式：组合多个对象形成一个树形结构以表示整体一部分关系的层次结构，组合模式对单个对象（叶子结点），组合对象（容器对象）使用具有一致性。
优点：1.客户端代码能一致处理单个对象或者组合对象，能在组合的树上加新对象，符合开闭原则；
缺点：设计复制要理清层次关系
模板方法模式 模板方法：行为设计模式，定义了一个算法步骤，允许一个子类别为一个或多个步骤提供实现方法。
优点：父类封装了不变的部分，子类扩展可变的部分，代码复用强，符合开闭原则；
缺点：每个不同的实现都要定义一个子类，性能比较低，子类的结果会影响到父类，代码可读性差，如果新家父类抽象方法，子类都要改动
命令模式 命令模式：将请求与处理解耦，将请求封装成一个对象，让发出请求的责任与处理请求的责任分割，二者都能通过命令对象沟通，传递和调用。
优点：降低耦合，扩展性好，增加删除命令方便，不影响其天类；
缺点：会产生大量的命令类，增加系统的复杂度
责任链模式 解耦请求和处理，将节点的处理者组成了一个链式结构，每个处理节点判断自己能否处理，可以的话自己处理，处理不了的传递给下一个节点，让请求流动起来。
优点：降低对象的耦合度，扩展性强，可以增加处理节点，增强对象指派责任的灵活性，简化对象的链接，符合单一职责原则；
缺点：不能保证每个请求都会被处理，如果责任链很长，系统的处理性能会变差
状态模式 状态模式：控制对象状态转换的时候，将判断逻辑拿出来用不同的类去表示，代替if-else,switch-case.
优点：将不同的状态分隔开，满足单一职责原则，将状态转换显示化，减少对象的相互依赖，利用新状态扩展；
缺点：代码复杂相对if-else,新增状态会修改负责状态转换的源码，违背了开闭原则
观察者模式 观察者模式：多个对象存在一对多的依赖关系，如果其一个发生了变化，其他依赖此对象的会被告知然后更新，类似于发布订阅者模型。
优点：降低目标和观察者的耦合，观察者和目标之间有触发机制，发一条通知，订阅者就会收到通知；
缺点：可能导致循环引用，观察者多的话影响效率
中介者模式 中介者模式：定义一个中介对象封装对象的行为交互，
优点：各司其职，降低对象耦合度，对象一对一关联，提高系统灵活性；
缺点：一个类与多个类直接依赖，变成与对象一对一依赖，类多的话中介类会很臃肿
迭代器模式 迭代器模式：提供一个对象顺序访问聚合对象里面的数据。
优点：简化聚合类，遍历任务由迭代器完成，支持不同方式遍历聚合对象，访问聚合对象内容不会暴露内部表达式；
缺点：增加类的个数，增加代码的复杂性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1a725ee162af18ade6bda79fd006ff76/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-06T17:52:48+08:00" />
<meta property="article:modified_time" content="2024-03-06T17:52:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>简单工厂模式</h3> 
<blockquote> 
 <p><strong>父类调用抽象方法，根据传参不同，调用的子类对象不同，实现不同的折扣计算</strong><br> <img src="https://images2.imgbox.com/96/43/qT7pwM68_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/b3/KrwgFikX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/05/6d/YECqzDUI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/38/6c/UU5kB6aP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/b4/QwfQn7jQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2a/57/HpZWwlqD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_16"></a>策略模式</h3> 
<blockquote> 
 <p><strong>策略模式：对象的行为模式抽象，将算法封装起来，将使用算法与实现算法解耦，委派给不同对象对算法进行管理</strong><br> <img src="https://images2.imgbox.com/86/b9/52XKzQgN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e8/18/NoFCmRof_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_24"></a>单例模式</h3> 
<blockquote> 
 <p><strong>单例模式：内存中只有一个实例，减少内存开销，设置全局的getInstance方法共享资源，跨线程使用；</strong><br> <strong>应用场景：</strong><br> <strong>1.频繁创建类用单例减少内存和GC,<br> 2.需求上只需要生成一次<br> 3.类创建占用资源多时间长，且不怎么会改变的类</strong><br> <strong>懒汉式</strong><img src="https://images2.imgbox.com/ec/b2/fNQJIfXE_o.png" alt="在这里插入图片描述"><br> <strong>饿汉式</strong><br> <img src="https://images2.imgbox.com/25/d8/jAi3b1fe_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_37"></a>代理模式</h3> 
<blockquote> 
 <p><strong>代理模式：一个用户不想直接访问某个对象，找中介代理，(比如买火车票用12306，找工作boss，找家政等平台代理，开发中避免用户直接访问服务器用nginx代理)；<br> 优点：中介可以保护目标对象，扩展程序方便，可以在代理类访问对象并在前后做处理</strong><br> <img src="https://images2.imgbox.com/8c/46/pGMELeqg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f4/db/0ORIL0ii_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_45"></a>原型模式</h3> 
<blockquote> 
 <p><strong>原型模式：把一个已经创建好的实例作为原型，复制原型作为一个新的对象，高效，无需关系创建细节，优点：克隆接口是基于二进制流的方式，性能高，深克隆可以将对象的状态也保存下来，减少对象创建；缺点：每个对象都要实现克隆方接口，深克隆可能存在多个对象嵌套引用，比较麻烦</strong><br> <img src="https://images2.imgbox.com/94/ca/nrhzTqOK_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_51"></a>适配器模式</h3> 
<blockquote> 
 <p><strong>适配器模式：将一个类的接口转换成客户希望的另一个接口，让原本不兼容的类，接口一起工作，有类适配器和对象适配器，一般使用对象适配器，类适配器耦合度很高。<br> 优点：通过适配器透明调用接口，代码复用<br> 缺点：代码需要结合业务，复杂性高，可读性低。例子：充电口协议标准各个国家不同，需要用转换器或者适配器完成充电</strong><br> <img src="https://images2.imgbox.com/f3/fb/xtwxdQ5k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/6d/iZyUzI2y_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/2f/GlranNOB_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_63"></a>装饰性模式</h3> 
<blockquote> 
 <p><strong>装饰性模式：扩展类用组合的方式创建修饰对象包裹真实对象，在保证真实对象不变的前提下，增加额外的功能。<br> 优点：动态扩展类的功能，装饰排列组合能实现不同的效果，遵守开闭原则，<br> 缺点：有很多子类，增加程序的复杂性</strong><br> <img src="https://images2.imgbox.com/60/e9/7Mzy7ebF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/56/20/ZD5ytSto_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d6/c6/sY4mXTyn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4e/d3/hT3MdNdM_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_75"></a>桥接模式</h3> 
<blockquote> 
 <p><strong>桥接模式：将抽象与实现分离，用组合代替继承关系。<br> 优点：扩展性强，符合开闭原则，合成复用原则，对用户透明<br> 缺点：建立在抽象层，需要对需求理解设计强</strong><br> <img src="https://images2.imgbox.com/5b/af/gWL6us4D_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bd/0b/8I5deo4l_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b1/b2/Arz6rkFu_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/81/64/vt50Pb56_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_89"></a>外观模式</h3> 
<blockquote> 
 <p><strong>外观模式：为子系统中的一组接口提供一个统一的入口，定义一个高层接口，使得访问子系统更加容易。<br> 优点：降低子系统和客户端的耦合度，读用户透明，为用户屏蔽了子系统的组件，降低编译的依赖jar包；<br> 缺点：设计不合理时可能违反开闭原则</strong><br> <img src="https://images2.imgbox.com/32/76/jWeMqjgw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/94/91/3EZZ3lBe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/a1/cF38N4Mn_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_101"></a>享元模式</h3> 
<blockquote> 
 <p><strong>享元模式：缓存共享降低内存损耗，<br> 优点：相同对象只要保存一份，降低系统对象数量，减少内存压力；<br> 缺点：读取享元外部状态响应时间长</strong><br> <img src="https://images2.imgbox.com/1c/e9/dYqxsS8w_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/b6/mTNLvxnl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f5/bf/KIkGbi6j_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/32/bd/FbXpjBmm_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_115"></a>组合模式</h3> 
<blockquote> 
 <p><strong>组合模式：组合多个对象形成一个树形结构以表示整体一部分关系的层次结构，组合模式对单个对象（叶子结点），组合对象（容器对象）使用具有一致性。<br> 优点：1.客户端代码能一致处理单个对象或者组合对象，能在组合的树上加新对象，符合开闭原则；<br> 缺点：设计复制要理清层次关系</strong><br> <img src="https://images2.imgbox.com/50/8b/L9hkhSp2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b5/21/rX7bSPiY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/24/46/xxWzJhRz_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_127"></a>模板方法模式</h3> 
<blockquote> 
 <p><strong>模板方法：行为设计模式，定义了一个算法步骤，允许一个子类别为一个或多个步骤提供实现方法。<br> 优点：父类封装了不变的部分，子类扩展可变的部分，代码复用强，符合开闭原则；<br> 缺点：每个不同的实现都要定义一个子类，性能比较低，子类的结果会影响到父类，代码可读性差，如果新家父类抽象方法，子类都要改动</strong><br> <img src="https://images2.imgbox.com/5b/4c/7HTth2lN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f5/e3/oahufyHB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d4/b6/UYjTwQiX_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_139"></a>命令模式</h3> 
<blockquote> 
 <p><strong>命令模式：将请求与处理解耦，将请求封装成一个对象，让发出请求的责任与处理请求的责任分割，二者都能通过命令对象沟通，传递和调用。<br> 优点：降低耦合，扩展性好，增加删除命令方便，不影响其天类；<br> 缺点：会产生大量的命令类，增加系统的复杂度</strong><br> <img src="https://images2.imgbox.com/25/e1/6wqXU4yf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/95/81/2D4PzLrt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9e/ca/fyEXslQy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0e/f7/T7Lh3YMF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/db/c9/NNqpC35f_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_155"></a>责任链模式</h3> 
<blockquote> 
 <p><strong>解耦请求和处理，将节点的处理者组成了一个链式结构，每个处理节点判断自己能否处理，可以的话自己处理，处理不了的传递给下一个节点，让请求流动起来。<br> 优点：降低对象的耦合度，扩展性强，可以增加处理节点，增强对象指派责任的灵活性，简化对象的链接，符合单一职责原则；<br> 缺点：不能保证每个请求都会被处理，如果责任链很长，系统的处理性能会变差</strong><br> <img src="https://images2.imgbox.com/be/4f/I2MQRk5s_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7f/15/N4kkt6KO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5e/16/FrR6OmC9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/de/52/lDiMEhtL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_170"></a>状态模式</h3> 
<blockquote> 
 <p><strong>状态模式：控制对象状态转换的时候，将判断逻辑拿出来用不同的类去表示，代替if-else,switch-case.<br> 优点：将不同的状态分隔开，满足单一职责原则，将状态转换显示化，减少对象的相互依赖，利用新状态扩展；<br> 缺点：代码复杂相对if-else,新增状态会修改负责状态转换的源码，违背了开闭原则</strong><br> <img src="https://images2.imgbox.com/57/4b/yajKRZEt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/57/23/7k5btPEl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bd/5b/qLyQN6fq_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/84/4NqnrDFs_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_186"></a>观察者模式</h3> 
<blockquote> 
 <p><strong>观察者模式：多个对象存在一对多的依赖关系，如果其一个发生了变化，其他依赖此对象的会被告知然后更新，类似于发布订阅者模型。<br> 优点：降低目标和观察者的耦合，观察者和目标之间有触发机制，发一条通知，订阅者就会收到通知；<br> 缺点：可能导致循环引用，观察者多的话影响效率</strong><br> <img src="https://images2.imgbox.com/7b/fe/fqZaO6Cn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f5/b8/w0ixOw7e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bd/55/Q1ncRcBD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/79/b9/QuOIqlHq_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_196"></a>中介者模式</h3> 
<blockquote> 
 <p><strong>中介者模式：定义一个中介对象封装对象的行为交互，<br> 优点：各司其职，降低对象耦合度，对象一对一关联，提高系统灵活性；<br> 缺点：一个类与多个类直接依赖，变成与对象一对一依赖，类多的话中介类会很臃肿</strong><br> <img src="https://images2.imgbox.com/68/74/cRtH1IGp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/f3/unP3yeRm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/03/af/X82EG9lk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3c/0a/FSZZ12Ey_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dc/3e/bA7sccmA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0e/5b/Zzc1ptRS_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_209"></a>迭代器模式</h3> 
<blockquote> 
 <p><strong>迭代器模式：提供一个对象顺序访问聚合对象里面的数据。<br> 优点：简化聚合类，遍历任务由迭代器完成，支持不同方式遍历聚合对象，访问聚合对象内容不会暴露内部表达式；<br> 缺点：增加类的个数，增加代码的复杂性</strong><br> <img src="https://images2.imgbox.com/bc/d0/r6Cvc0zo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/17/tO2maJWg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ce/92/nAu1zkCj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/06/3e/eEh2bSHY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dc/9b/ObTe65sV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0c/b0/75mXLz8F_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_221"></a>访问者模式</h3> 
<blockquote> 
 <p><strong>访问者模式：封装一些作用于某种数据结构中各种元素的操作，在不改变数据结构的前提下，作用于类内部的新操作。<br> 优点：复用性好，数据结构与操作解耦，符合单一职责原则；<br> 缺点：违反了开闭原则，违反了依赖倒置原则，破坏了封装性</strong><br> <img src="https://images2.imgbox.com/aa/a4/RKNZoJIQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b6/ac/Pl66sc9W_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/79/9b/QY3iBrlc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f2/7b/IhWNUDa4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/a0/BI4IJpFQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fc/f4/nevRCFlO_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_233"></a>备忘录模式</h3> 
<blockquote> 
 <p><strong>备忘录模式：在不破坏封装性的前提下，捕捉对象的内部状态，并且在对象之外保存此状态（快照模型）。<br> 优点：提供恢复状态的机制，实现内部状态的封装，发起人无需管理，管理者统一管理符合单一职责原则；<br> 缺点：如果保存的内部状态多，频繁，资源消耗比较大</strong><br> <img src="https://images2.imgbox.com/1c/ad/LhMgCBec_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2d/87/J2rcYOXi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/72/79/9H0NmIK4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9c/59/YPkLzi0H_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_244"></a>解释器模式</h3> 
<blockquote> 
 <p><strong>解释器模式：使用类去表达语言类文法规则，用编译语言的方式分析应用实例。<br> 优点：扩展性好，能继承扩展语法；<br> 缺点：效率低，解释句子复杂，规则多时数量增多，系统维护难</strong><br> <img src="https://images2.imgbox.com/04/b0/Hf4KPrRx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7f/29/iug3Z2Jf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/74/00/jTPn6iUL_o.png" alt="在这里插入图片描述"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90b8777b5640094da1e1246b703687ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">序列化的简要理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f65b4ef5880940e6e224ba43ad31d998/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《Ubuntu20.04环境下的ROS进阶学习0》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>