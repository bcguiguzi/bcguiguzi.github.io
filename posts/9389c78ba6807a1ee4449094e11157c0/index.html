<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>谈谈Vue的生命周期 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="谈谈Vue的生命周期" />
<meta property="og:description" content="文章目录 一、引入生命周期二、生命周期流程分析 1.初始 beforeCreate()created()2.挂载 beforeMount()mouned()3.更新 beforeUpdate()updated()4.销毁 beforeDestroy()destroyed()三、常用的生命周期钩子总结 一、引入生命周期 Vue的生命周期，指Vue的实例从初始化创建到最终销毁的整个过程。
在整个生命周期中的各个阶段，会执行各个阶段所对应的一些特殊命名(不可修改)的回调函数，我们称之为生命周期钩子，引入官方文档Vue生命周期的流程图如下：
Vue生命周期共有八个生命周期钩子，下面我通过这八个生命周期钩子对生命周期的流程进行大致分析：
二、生命周期流程分析 1.初始 初始阶段流程（如图）：
当我们通过new Vue()创建Vue实例时，生命周期还未真正开始，下面我们进入第一个环节：Init Events &amp; Lifecycle: 初始化Vue中的许多事件，做准备工作，生命周期将从这里开始。就好比与新生的婴儿呱呱坠地，此刻正由护士天使进行各项检查及清洗等准备工作。
在初始化(Init)生命周期(Lifecycle)及各项事件(Events)的准备工作完成后，诞生了我们第一个生命周期钩子：beforeCreate()，当它执行完毕后，我们进入了下一个环节：Init injections &amp; reactivity：初始化Vue中的数据监测和数据代理（通过实例对象代理data中的数据）下面介绍beforeCreate()
beforeCreate() 顾名思义，就是“创建前”，创建的是啥呢？通过以上流程图及文字分析，创建的是Vue中的数据监测和数据代理。该钩子函数横在了Init Events &amp; Lifecycle与nit injections &amp; reactivity环节的中间，也就是在该钩子函数执行时，Vue还未进行数据监测和数据代理的环节
举个栗子：
&lt;script&gt; Vue.config.productionTip = false; const vm = new Vue({ el:&#39;#root&#39;, data: { n:1 }, methods: { add() { this.n&#43;&#43;; } }, beforeCreate() { console.log(&#39;此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!&#39;); console.log(this); debugger; } }); &lt;/script&gt; 运行结果：
分析：我们在钩子函数beforeCreate()中打印Vue实例对象并设置断点（防止继续执行，Vue走完它的生命周期），打开控制台，我们发现date中的数据 n 及methods中的 add() 方法还未在实例对象vm中找到，说明此时Vue还未对配置项中的数据进行监测和代理，于是我们取消断点继续执行，让Vue走完整个流程，可以发现实例对象vm已经存有了数据n及方法add()，如下图：
created() 同理，就是“创建后”，由生命周期图分析：也就是初始化数据监测和数据代理完毕后执行该生命周期钩子，此时我们已经可以通过Vue实例对象访问Vue中的数据了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9389c78ba6807a1ee4449094e11157c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T00:00:49+08:00" />
<meta property="article:modified_time" content="2022-05-01T00:00:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">谈谈Vue的生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a></h2> 
<div> 
 <h4>文章目录</h4> 
 <ul><li><a href="#pandas_22" rel="nofollow">一、引入生命周期</a></li><li><a href="#_26" rel="nofollow">二、生命周期流程分析</a> 
   <ul><li><a href="#1_27" rel="nofollow">1.初始</a> 
     <ul><li><a href="#1_27" rel="nofollow">beforeCreate()</a></li><li><a href="#1_27" rel="nofollow">created()</a></li></ul></li><li><a href="#1_27" rel="nofollow">2.挂载</a> 
     <ul><li><a href="#1_27" rel="nofollow">beforeMount()</a></li><li><a href="#1_27" rel="nofollow">mouned()</a></li></ul></li><li><a href="#2_41" rel="nofollow">3.更新</a> 
     <ul><li><a href="#1_27" rel="nofollow">beforeUpdate()</a></li><li><a href="#1_27" rel="nofollow">updated()</a></li></ul></li><li><a href="#2_41" rel="nofollow">4.销毁</a> 
     <ul><li><a href="#1_27" rel="nofollow">beforeDestroy()</a></li><li><a href="#1_27" rel="nofollow">destroyed()</a></li></ul></li></ul></li><li><a href="#_26" rel="nofollow">三、常用的生命周期钩子</a></li><li><a href="#_55" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2>一、引入生命周期</h2> 
<p>        Vue的生命周期，指Vue的实例从初始化创建到最终销毁的整个过程。</p> 
<p>        在整个生命周期中的各个阶段，会执行各个阶段所对应的一些特殊命名(不可修改)的<strong>回调函数</strong>，我们称之为<strong>生命周期钩子</strong>，引入官方文档Vue生命周期的流程图如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/88/07/VZkWVfkF_o.png"></p> 
<p></p> 
<p>         Vue生命周期共有八个生命周期钩子，下面我通过这八个生命周期钩子对生命周期的流程进行大致分析：</p> 
<h2><a id="_26"></a>二、生命周期流程分析</h2> 
<h3><a id="1_27"></a>1.初始</h3> 
<p><strong><span style="color:#956fe7;">初始阶段流程（如图）：</span></strong></p> 
<p style="text-align:center;"><img alt="" height="592" src="https://images2.imgbox.com/98/0b/RlvlVBEM_o.png" width="513"></p> 
<p>         当我们通过new Vue()创建Vue实例时，生命周期还未真正开始，下面我们进入第一个环节：<strong>Init Events &amp; Lifecycle: 初始化Vue中的许多事件，做准备工作，生命周期将从这里开始。</strong>就好比与新生的婴儿呱呱坠地，此刻正由护士天使进行各项检查及清洗等准备工作。</p> 
<p>        在初始化(Init)生命周期(Lifecycle)及各项事件(Events)的准备工作完成后，诞生了我们第一个生命周期钩子：<strong>beforeCreate()，</strong>当它执行完毕后，我们进入了下一个环节：<strong>Init injections &amp; reactivity：初始化Vue中的数据监测和数据代理（通过实例对象代理data中的数据）</strong>下面介绍beforeCreate()</p> 
<hr> 
<h4>beforeCreate()</h4> 
<p>        顾名思义，就是“<strong>创建前</strong>”，创建的是啥呢？通过以上流程图及文字分析，创建的是Vue中的数据监测和数据代理。该钩子函数横在了<strong>Init Events &amp; Lifecycle</strong>与<strong>nit injections &amp; reactivity</strong>环节的中间，也就是在该钩子函数执行时，Vue还未进行数据监测和数据代理的环节</p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
            console.log(this);
            debugger;    
        }
    });
&lt;/script&gt;</code></pre> 
<p><span style="color:#ff9900;"><strong>运行结果：</strong></span></p> 
<p style="text-align:center;"><span style="color:#ff9900;"><strong><img alt="" src="https://images2.imgbox.com/ee/7b/PM1DEZva_o.png"></strong></span></p> 
<blockquote> 
 <p><span style="color:#1c7892;"><strong>分析：</strong></span>我们在钩子函数beforeCreate()中<strong>打印Vue实例对象并设置断点</strong>（防止继续执行，Vue走完它的生命周期），打开控制台，我们发现date中的数据 n 及methods中的 add() 方法还未在实例对象vm中找到，说明此时Vue还未对配置项中的数据进行监测和代理，于是我们取消断点继续执行，让Vue走完整个流程，可以发现实例对象vm已经存有了数据n及方法add()，如下图：</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/b5/IABrA5H4_o.png"></p> 
<p></p> 
<h4>created()</h4> 
<p>        同理，就是“<strong>创建后</strong>”，由生命周期图分析：也就是初始化数据监测和数据代理完毕后执行该生命周期钩子，此时我们已经可以通过Vue实例对象访问Vue中的数据了</p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
            console.log(this);
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
            console.log(this);
        }
    });
&lt;/script&gt;</code></pre> 
<p><a id="2_41"></a><span style="color:#ff9900;"><strong>运行结果：</strong></span></p> 
<p style="text-align:center;"><span style="color:#ff9900;"><strong><img alt="" src="https://images2.imgbox.com/00/7e/NEpphRr2_o.png"></strong></span></p> 
<hr> 
<p>        在执行完以上两个生命周期钩子后，Vue实例已经实现了数据监测和代理。我们顺着初始阶段流程图往下走，就<strong>正式进入了解析模板生成虚拟Dom的环节</strong>，图中进行了流程判断如下：</p> 
<blockquote> 
 <ol><li>是否有<strong>el配置项</strong>（有）—&gt;是否有<strong>template（模板）</strong>项（无）—&gt;编译el的外部HTML作为模板(<strong>Compile el's outerHtml as template</strong>)</li><li>是否有<strong>el配置项</strong>（有）—&gt;是否有<strong>template（模板）</strong>项（有）—&gt;编译该模板到渲染函数render()中(<strong>Compile template in render function</strong>)</li><li>是否有<strong>el配置项</strong>（无）—&gt;等待Vue实例调用$mount来传入el参数(<strong>when vm.$mount(el) is called</strong>)，从而指定Vue服务的容器—&gt;执行1、2步骤</li></ol> 
</blockquote> 
<p>        至此，Vue生命周期的<strong>初始阶段</strong>便结束了，我们进行以下总结：</p> 
<blockquote> 
 <ol><li><strong>Init Events &amp; Lifecycle: </strong>初始化Vue中的许多事件，做准备工作，生命周期将从开始。</li><li>执行生命周期钩子：<strong>beforeCreate()</strong></li><li><strong>Init injections &amp; reactivity：</strong>初始化Vue中的数据监测和数据代理</li><li>执行生命周期钩子：<strong>created()</strong></li><li>解析模板：<strong>生成虚拟Dom</strong></li></ol> 
</blockquote> 
<hr> 
<h3>2.挂载</h3> 
<p><strong><span style="color:#956fe7;">挂载阶段流程（如图）：</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5c/6b/zijWEmoK_o.png"></p> 
<p>         当走过了Vue的初始时期，Vue实例对象已经对Vue中的数据进行监测和代理，同时也已经通过解析模板在内存中生成了虚拟Dom，于是乎，我们来到了Vue生命周期的<strong>第二个时期——挂载</strong>。</p> 
<p>        一上来，我们便开始执行第三个生命周期钩子——<strong>beforeMount()</strong></p> 
<hr> 
<h4>beforeMount()</h4> 
<p>        此时页面呈现的是未经Vue编译的Dom结构，也就是我们前一章节所说的虚拟Dom还未生成真实Dom渲染在页面上</p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
            debugger;
        }
    });
&lt;/script&gt;</code></pre> 
<h4><span style="color:#ff9900;"><strong>运行结果：</strong></span></h4> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e4/87/nv2gN6P2_o.png"></h4> 
<blockquote> 
 <p> <span style="color:#1c7892;"><strong>分析：</strong></span>可见，在生命周期钩子<strong>beforeMount()</strong>执行时期，内存中虚拟Dom还未转为真实Dom渲染在页面中，因此页面中模板语法中的数据n还未被渲染。</p> 
</blockquote> 
<p>        毋庸置疑，执行下一个环节：<strong>Create vm.$el and replace "el" with it </strong>想必再清楚不过了，那就是开始渲染真实Dom了。让我们沿着Vue的生命线继续向下走。接下来便开始执行第四个生命周期钩子——<strong>mounted()</strong></p> 
<h4>mounted()</h4> 
<p>        这个时期，页面呈现的是<strong>初次</strong>经过Vue编译而渲染在页面上的真实Dom，此时也叫做<strong>挂载完毕</strong>，此时此刻万象更新，呈现出万物竞发、勃勃生机的态势，一般选择在这个时期<strong>开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作</strong></p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
        },
        mounted() {
            console.log('此时页面已经通过虚拟Dom渲染为真实Dom了,你可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作啦!');
            debugger;
        },
    });
&lt;/script&gt;</code></pre> 
<p><span style="color:#ff9900;"><strong>运行结果：</strong></span></p> 
<h3><img alt="" src="https://images2.imgbox.com/8f/a6/HLKC1xgu_o.png"></h3> 
<p>        至此，Vue生命周期的<strong>挂载阶段</strong>便结束了，我们进行以下总结：</p> 
<blockquote> 
 <ol><li>执行生命周期钩子：<strong>beforeMount()</strong></li><li><strong>Create vm.$el and replace "el" with it : </strong>渲染真实Dom</li><li>执行生命周期钩子：<strong>mounted()</strong></li></ol> 
</blockquote> 
<hr> 
<h3>3.更新</h3> 
<p><strong><span style="color:#956fe7;">更新阶段流程（如图）：</span></strong></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"><strong><span style="color:#956fe7;">        <img alt="" src="https://images2.imgbox.com/17/93/ApLCIupK_o.png"></span></strong></p> 
<p>        当走过了Vue生命周期的挂载时期，我们已经可以对页面中的Dom节点进行操作了，但是除了操作，要实现对页面中数据的更新，那就顺着Vue的生命周期来到了<strong>第三个时期——更新</strong></p> 
<p><strong>       </strong> 根据流程图，一上来，<strong>when data changes</strong>，就是当页面中的数据发生变化时，执行第五个生命周期钩子：<strong>beforeUpdate()</strong></p> 
<hr> 
<h4>beforeUpdate()</h4> 
<p>        顾名思义，就是“<strong>更新前</strong>”，当页面数据发送变化时，也就是说<strong>此时页面还是旧的，但数据是新的</strong>，<strong>页面尚未和数据保持同步的时期执行的该生命周期钩子</strong></p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
        },
        mounted() {
            console.log('此时页面已经通过虚拟Dom渲染为真实Dom了,你可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作啦!');
        },
        beforeUpdate() {
            console.log('此时数据已经更新，但页面还没更新');
            debugger;
        },
    });
&lt;/script&gt;</code></pre> 
<p><span style="color:#ff9900;"><strong>运行结果：</strong></span></p> 
<p style="text-align:center;"><span style="color:#ff9900;"><strong><img alt="" src="https://images2.imgbox.com/75/fa/2Wg3zO9n_o.png"></strong></span></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/1e/1c/OGRXq7PP_o.png"></p> 
<blockquote> 
 <p> <span style="color:#1c7892;"><strong>分析：</strong></span>此时我们通过在页面中点击按钮使得n++，同样设置断点，可以在控制台发现执行了该钩子函数，但页面中的数据还未发送变化，打开Vue开发者工具发现此时数据n已经发生变化</p> 
</blockquote> 
<p>        那么页面的数据需要更新鸭！该咋办呢，根据流程图，进入下一个时期——<strong>Virtual Dom re-render and patch</strong>，就是前一章所说的根据新数据生成新的虚拟Dom，随后与旧的虚拟Dom进行比较，最终完成页面的更新。</p> 
<h4>updated()</h4> 
<p>        顾名思义，“<strong>更新后</strong>”，这个时期，结果新旧虚拟Dom的一系列比较后，已经生成了真实Dom对页面的数据进行了更新。此时执行该生命周期钩子。</p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
        },
        mounted() {
            console.log('此时页面已经通过虚拟Dom渲染为真实Dom了,你可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作啦!');
        },
        beforeUpdate() {
            console.log('此时数据已经更新，但页面还没更新');
        },
        updated() {
            console.log('此时页面与数据都是新的啦!');
        },
    });
&lt;/script&gt;</code></pre> 
<p><strong><span style="color:#ff9900;">运行结果：</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ea/5a/JSgCB1X7_o.png"></p> 
<blockquote> 
 <p>  <span style="color:#1c7892;"><strong>分析：</strong></span>此时我们通过在页面中点击按钮使得n++，发现页面数据实现了更新，同时在控制台输出结果观测到在页面数据更新前后的两个更新阶段的生命周期钩子beforeUpdate()和updated()均已执行。</p> 
</blockquote> 
<p>        至此，Vue生命周期的<strong>更新阶段</strong>便结束了，我们进行以下总结：</p> 
<blockquote> 
 <ol><li>执行生命周期钩子：<strong>beforeUpdate()</strong></li><li><strong>Virtual Dom re-render and patch</strong>：新旧虚拟Dom对比，渲染真实Dom，更新页面数据</li><li>执行生命周期钩子：<strong>updated()</strong></li></ol> 
</blockquote> 
<hr> 
<h3>4.销毁</h3> 
<p><strong><span style="color:#956fe7;">销毁阶段流程（如图）：</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/cd/fepZb4dt_o.png"></p> 
<p>         当走过了Vue生命周期的更新时期，我们已经可以操作页面中的Dom节点致使Vue可以实现对页面数据进行更新的操作了。下面我们就进入了Vue生命周期的<strong>最后一个时期——销毁时期</strong></p> 
<p><strong>        </strong>一上来先进入一个判断环节，<strong>when vm.$destroy() is called，</strong>即当Vue实例对象调用$destroy()时，进入下一个阶段，执行第七个生命周期钩子——<strong>beforeDestroy()</strong></p> 
<hr> 
<h4>beforeDestroy()</h4> 
<p>        顾名思义，“<strong>销毁前</strong>”，此时vm中的所有配置项、指令等等都处于可用状态，马上要执行销毁过程，在执行销毁过程前执行的生命周期钩子，一般选择在这个阶段<strong>关闭定时器、取消订阅消息、解绑自定义事件等收尾操作</strong></p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
    &lt;button @click="bye"&gt;点我销毁vm&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }，
            bye() {
                this.$destroy();
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
        },
        mounted() {
            console.log('此时页面已经通过虚拟Dom渲染为真实Dom了,你可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作啦!');
        },
        beforeUpdate() {
            console.log('此时数据已经更新，但页面还没更新');
        },
        updated() {
            console.log('此时页面与数据都是新的啦!');
        },
        beforeDestroy() {
            console.log('vm中的配置项、指令等等即将销毁,请关闭定时器、解绑订阅消息、解绑自定义事件等收尾操作!');
            debugger;
        }
    });
&lt;/script&gt;</code></pre> 
<p><strong><span style="color:#ff9900;">运行结果：</span></strong></p> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/38/lmwqaO2Y_o.png"></h4> 
<blockquote> 
 <p>   <span style="color:#1c7892;"><strong>分析：</strong></span>通过对按钮绑定点击事件调用<strong>vm.$destroy()，</strong>点击按钮销毁Vue实例对象，同样设置断点，执行该生命周期钩子，此时还未真正销毁实例对象，提示进行最终销毁前的收尾工作。</p> 
</blockquote> 
<h4>destroyed()</h4> 
<p>        同理，就是“<strong>销毁后</strong>”，根据流程图，当销毁环节前的生命周期钩子beforeDestroy()执行后便进入了下一个阶段——<strong>Teardown watchers, child components and event listeners</strong>，此刻，vm中的所有配置项、子组件、指令等都被销毁了。最后我们执行Vue最后一个生命周期钩子——<strong>destroyed()</strong>，该钩子存在感比较低（毕竟vm已经没了）</p> 
<p><span style="color:#ff9900;"><strong>举个栗子：</strong></span></p> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2&gt;当前的n为:{<!-- -->{n}}&lt;/h2&gt;
    &lt;button @click="add"&gt;点我n++&lt;/button&gt;
    &lt;button @click="bye"&gt;点我销毁vm&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data: {
            n:1
        },
        methods: {
            add() {
                this.n++;
            }，
            bye() {
                this.$destroy();
            }
        },
        beforeCreate() {
            console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!');
        },
        created() {
            console.log('此时可以通过vm访问data中数据和methods中方法!');
        }，
        beforeMount() {
            console.log('此时已经解析完模板生成了虚拟Dom(内存中),但还没在页面编译真实Dom!')
        },
        mounted() {
            console.log('此时页面已经通过虚拟Dom渲染为真实Dom了,你可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作啦!');
        },
        beforeUpdate() {
            console.log('此时数据已经更新，但页面还没更新');
        },
        updated() {
            console.log('此时页面与数据都是新的啦!');
        },
        beforeDestroy() {
            console.log('vm中的配置项、指令等等即将销毁,请关闭定时器、解绑订阅消息、解绑自定义事件等收尾操作!');
        },
        destroyed() {
            console.log('bye!');
        }
    });
&lt;/script&gt;</code></pre> 
<p><strong><span style="color:#ff9900;">运行结果：</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/95/dd/zKV7ehrl_o.png"></p> 
<p>        至此，Vue生命周期的<strong>销毁阶段</strong>便结束了，我们进行以下总结：</p> 
<blockquote> 
 <ol><li>Vue实例对象调用<strong>$destroy()</strong>方法</li><li>执行销毁前生命周期钩子：<strong>beforeDestroy()</strong></li><li><strong>Teardown watchers, child components and event listeners：</strong>销毁实例对象中的配置项、子组件、指令等</li><li>执行销毁后生命周期钩子：<strong>Destroyed()</strong></li></ol> 
</blockquote> 
<hr> 
<h3> 三、常用的生命周期钩子</h3> 
<blockquote> 
 <ol><li>mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】</li><li>beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】</li></ol> 
</blockquote> 
<hr> 
<h2>总结</h2> 
<p>        至此我们就走完了整个Vue的生命周期流程图，以下我们配上整体流程总结，便于梳理各个环节：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/39/US6hi9XL_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1edf7a31d6f5dacc7adf5b64d566fc2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第6讲 Android Camera性能分析 如何通过perfetto抓取trace</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/464f7c4122978d9818a2699705170468/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue报错——[vue/require-v-for-key]Elements in iteration expect to have ‘v-bind:key‘ directives.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>