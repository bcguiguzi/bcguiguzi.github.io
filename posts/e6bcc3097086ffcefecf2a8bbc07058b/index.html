<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6（第三版）知识点及各个版本总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6（第三版）知识点及各个版本总结" />
<meta property="og:description" content="一、ES6与ECMAScript2015关系
ES:是编写js的标准，它规定了语法、语句、类型、关键字、保留字、操作符、对象等（js的国际标准）
JS：JavaScript 1995诞生的目的是解决以前依赖服务器语言验证用户的输入验证操作。后期发展为一门编程语言。js包含：ECMAScript标准、DOM(DOM 把整个页面映射为一个多层节点结构，dom节点树，通过dom提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点)、BOM(浏览器对象模型)
ES6第三版:ES2015、ES2016、ES2017版本迭代
二、let和const命令（es5用var来声明变量或function来声明函数，且es5只存在全局和函数作用域。es6增加声明变量的方法后存在块级作用域和暂时性死区）
1、let
1）let声明的变量只有在let命令所在的代码块内有效
{
let a = 10; var b = 1;
}
a // ReferenceError: a is not defined. let声明的只能在所在的代码块内有效，否则报错
b // 1 var声明的不存在块级作用域
好处:例如一般用在for循环中可解决循坏计数暴露为全局变量的问题 在for外部使用循环变量时会报错 console.log(i); // ReferenceError: i is not defined
内层变量可能会覆盖外层变量的问题
2）let声明的变量不存在变量提升（即声明后才可使用，否则会报错。而var声明的变量存在变量提升，在自己的作用域内提升）
console.log(foo);// 输出undefined 提升后 var foo 会在console.log前
var foo = 2
console.log(foo);//报错ReferenceError 即在声明前使用就会报错
let foo = 2
3) 暂时性死区。在代码块内，使用let命令声明变量之前，该变量都是不可用的，会报错，就是在声明前都是它的死区
var tmp = 123;
if(true){
tmp = ‘abc’ ;// ReferenceError" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e6bcc3097086ffcefecf2a8bbc07058b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-27T10:12:44+08:00" />
<meta property="article:modified_time" content="2023-10-27T10:12:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6（第三版）知识点及各个版本总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一、<mark>ES6与ECMAScript2015关系</mark><br> ES:是编写js的标准，它规定了语法、语句、类型、关键字、保留字、操作符、对象等（js的国际标准）<br> JS：JavaScript 1995诞生的目的是解决以前依赖服务器语言验证用户的输入验证操作。后期发展为一门编程语言。js包含：ECMAScript标准、DOM(DOM 把整个页面映射为一个多层节点结构，dom节点树，通过dom提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点)、BOM(浏览器对象模型)<br> ES6第三版:ES2015、ES2016、ES2017版本迭代</p> 
<p>二、<mark>let和const命令</mark>（es5用var来声明变量或function来声明函数，且es5只存在全局和函数作用域。es6增加声明变量的方法后存在块级作用域和暂时性死区）<br> 1、let<br> 1）let声明的变量只有在let命令所在的代码块内有效<br> {<!-- --><br> let a = 10; var b = 1;<br> }<br> a // ReferenceError: a is not defined. let声明的只能在所在的代码块内有效，否则报错<br> b // 1 var声明的不存在块级作用域<br> 好处:例如一般用在for循环中可解决循坏计数暴露为全局变量的问题 在for外部使用循环变量时会报错 console.log(i); // ReferenceError: i is not defined<br> 内层变量可能会覆盖外层变量的问题<br> 2）let声明的变量不存在变量提升（即声明后才可使用，否则会报错。而var声明的变量存在变量提升，在自己的作用域内提升）<br> console.log(foo);// 输出undefined 提升后 var foo 会在console.log前<br> var foo = 2<br> console.log(foo);//报错ReferenceError 即在声明前使用就会报错<br> let foo = 2<br> 3) 暂时性死区。在代码块内，使用let命令声明变量之前，该变量都是不可用的，会报错，就是在声明前都是它的死区<br> var tmp = 123;<br> if(true){<!-- --><br> tmp = ‘abc’ ;// ReferenceError<br> let tmp;<br> }<br> typeof不再是一个百分之百安全的操作，之前es5中，它是一个安全的操作，即使没声明的变量也会是undefined,不会报错<br> 而用let声明的变量，在声明前检查它的类型会报错<br> 总结：在块内用let声明了变量，就对绑定在这个块，在这个块内，只要声明前使用这个变量就会报错，不会去外部作用域去寻找<br> 4）变量不允许重复声明 （ let不允许在相同作用域内，重复声明同一个变量）<br> let a = 10<br> var a = 1；此段代码会报错的<br> let并且不允许在函数内部重新声明参数,若在另一个块级作用域声明则不会报错<br> function f(arg){<!-- --><br> let arg<br> }<br> f() // 报错<br> 注意⚠️：在块级作用域中不要区声明一个函数，优先使用函数表达式来定义<br> 2、const<br> 1）声明一个只读的常量。一旦声明，常量的值就不能改变且必须立即初始化<br> const PI = 3.1415;<br> PI = 3;// TypeError<br> const PI // TypeError，只声明不赋值也会报错<br> 注意⚠️：对于简单的数据类型值是固定不变的，但对于复杂的数据类型，是指向的指针是固定的，至于往里面加属性方法是可以的，若重新赋值一个例如对象，会报错<br> 若真想对一个对象冻结，可用Object.freeze（）方法<br> 2）const的作用域与let命令相同：只在声明所在的块级作用域内有效<br> 3）与let同，也不存在变量提升，有暂时性死区（在代码块内，声明前使用就会报错）<br> 3、顶层对象的属性（浏览器环境指的是window对象，在 Node 指的是global对象）：es5中顶层对象的属性与全局变量是等价的。<br> ES6中规定：var、function声明的全局变量，依旧是顶层对象的属性；而let命令、const命令、class声明的全局变量，不属于顶层对象的属性。<br> 即： let b = 1<br> window.b // undefined，不会像 es5一样直接是变量b的值<br> ES6中引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p> 
<p>三、<mark>变量的解构赋值</mark><br> 1、数组的解构赋值（即按照模式匹配只要等号两边的模式相同，左边的变量就会被赋予对应的值）<br> 1）模式相同匹配成功赋值<br> 2）匹配不成功 let [foo]=[]或 let [bar，foo]=[1] 都解构不成功时变量的值为undefined<br> 3）不能完全匹配(等号左边的模式，只匹配一部分的等号右边的数组). let [x,y]=[1,2,3] 此时前两个解构成功<br> 4）报错。当等号右边不是可遍历的结构则会报错。let=[foo]=1 /{}/null/false/undefined/NaN<br> 5) 解构赋值允许指定默认值（只有数组成员严格等于undefined，默认值才会生效）<br> ⚠️默认值可以引用解构赋值的其他变量，但该变量必须已经声明<br> let [x=y,y=1]=[ ] // ReferenceError: y is not defined<br> 2、对象的解构赋值（属性没有次序，变量必须与属性同名，才能取到正确的值）<br> 1）当解构不成功时，变量的值为 undefined 例如：let{foo}={bar:“baz”}<br> 2）对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量<br> let {sin, cos , max, min}=Math 将Math对象的方法赋给对应的变量。sin//Math.sin<br> 3) 若变量名与属性名不一致，要想解构成功，必须写成以下形式：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span><span class="token punctuation">{<!-- --></span><span class="token literal-property property">foo</span><span class="token operator">:</span>baz<span class="token punctuation">}</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token string">"aaa"</span><span class="token punctuation">,</span><span class="token literal-property property">nnn</span><span class="token operator">:</span><span class="token string">"bbb"</span><span class="token punctuation">}</span> <span class="token comment">//  baz//"aaa"，冒号后是新变量，前是对应的属性</span>
<span class="token comment">// 真正被赋值的是后者</span>
</code></pre> 
<p>4）指定默认值（默认值生效也是对象的属性值严格等于undefined）<br> let {x=1}={} //变量x的值1 let {x:y=3}={} //变量y的值3 let{x=3}={x:undefined} //变量x的值3<br> 注意点⚠️ 当使用已经声明的变量进行对象的解构赋值时，不可将大括号写在行首，因为j s会解析成代码块，此时可用小括号。 let x; ({x}={x:1})<br> 允许等号左边不放置任何东西，无意义，但语法合理。（{}={x:1}）<br> 因数组是特殊的对象，可用于对象属性的解构，此时索引就是对应关系<br> 3、字符串的解构赋值（字符串被转换成了一个类似数组的对象）<br> let[a,b,c,d,e]=“hello” 此时变量a的值为字符串“h”<br> 可对对象的length属性解构赋值。let{length:len}=“hello” 此时 Len为5<br> 4、数值和布尔值的解构赋值<br> 如果等号右边是数值和布尔值，则会先转为对象<br> Number.prototype.toString<br> 5、函数的解构赋值：函数的参数也可以用于解构赋值，内容规则同上<br> 6、圆括号问题<br> 1）<mark>变量声明</mark>语句中不可使用圆括号 let[(a)]=[1]<br> 2）<mark>函数参数</mark>中不可使用圆括号<br> 3）<mark>赋值语句的模式</mark>不可使用圆括号. ( {a:aa})={a:1}//报错<br> 4）赋值语句的非模式可使用圆括号 ( {a:aa}={a:1}）</p> 
<p>四、<mark>字符串的扩展</mark><br> 1、字符的unicode表示法"\u{}" 将码点放入大括号，解读该字符 允许\uxxxx表示一个字符,xxxx是字符对应码点的16进制表示法<br> 2、字符串的遍历接口（ 可以被for…of循环遍历 for(let i of “hello”) 识别32位字符（4个字节）<br> 3、可直接输入行分隔符和段分隔符<br> 4、JSON.stringify（）将对象转为字符串<br> 5、模版字符串是增强版的字符串，用反引号（`）标识，变量的拼接不用+，而用${}<br> es5中js字符串方法<br> 1、.concat()将多个字符串拼接成一个新的字符串<br> 2、.slice()字符串截取，返回截取到的子符串,支持负数，负数表示倒数第几位开始<br> 3、.indexOf()给特定字符串查索引，返回该字符串第一次出现的位置<br> .lastIndexOf()给特定字符串查索引，返回该字符串最后一次出现的位置<br> 4、.charAt()在索引处查找对应字符 str.charAt(0)<br> 5、.charCodeAt()返回索引处字符对应的Unicode值 str.charAt(0)<br> 6、.toUpperCase()将字符串中字母转换成大写字母<br> 7、toLowerCase()将字符串中所有字母转换成小写字母<br> 8、.replace()将字符串中某个子串以特定字符串替代（不是全局替换）<br> 9、.split()将字符串转为数组 无参将整体作为一个，“”即每个字符为一个数组值<br> 10、.match()使用正则表达式搜索目标子字符串,返回匹配的<mark>子字符串</mark><br> 11、.search()使用正则表达式搜索目标子字符串，返回匹配的<mark>索引值</mark><br> 12、.trim()去除前后空格 有兼容问题<br> 13、String.fromCharCode(ASKII)返回码点对应的字符（注意：不识别大于0xFFFF字符）<br> es6扩展<br> 1）String.fromCodePoint() 返回码点对应的字符，若多个参数合并成一个返回，能识别32位4字节的字符，用法同String.fromCharCode()<br> 2）String.raw()该方法将字符串\转义<br> 实例方法<br> 3）.codePointAt()返回索引处字符的码点（可以处理4个字节存储的字符）同.charCodeAt()<br> 4）查找子字符串的方法,返回都是布尔值，第二个参数表示开始搜索位置<br> .includes(参)是否找到了参数字符串<br> .startsWith()参数字符串是否在原字符串头部<br> .endsWith()参数字符串是否在原字符串尾部<br> 5）.repeat(n)将原字符串重复n次,返回新字符串，原字符串不变,若0次则‘’<br> 6）.padStart(长度，用什么补)在头部补全到指定长度，参数&lt;=原字符串长度，返回原则字符串，否则返回新字符串 若省略第二参数，默认空格补<br> .padEnd(长度，用什么补) 类同上面<br> 7）.trimStart()去除头部空格 .trimEnd()去除尾部空格 对tab键 换行符等不可见的空白有效</p> 
<p>五、<mark>正则的扩展</mark><br> 1、RegExp构造函数的参数只能是字符串或者正则表示式<br> var regex = new RegExp (“”,修饰符)<br> var regex = new RegExp （／正则表达式／） 正则.test(字符串) 参数是否符合正则表达式，返回布尔.当使用正则表达式时，不可以使用第二参来添加修饰符，否则会报错，es6中允许使用第二参数，此时返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符<br> 例如：new RegExp（／abc／ig,“I”）此时正则的修饰符是i<br> 2、字符串的正则方法。<br> .match(正则)使用正则表达式搜索目标子字符串,返回匹配的子字符串 实际是String.prototype.match<br> .search(正则)使用正则表达式搜索目标子字符串，返回匹配的索引值<br> .replace()将字符串中某个子串以特定字符串替代<br> .split()将字符串转为数组 无参将整体作为一个，“”即每个字符为一个数组值<br> es6在语言内部做了调整， 让所有与正则相关的方法，全都定义在RegExp对象上。<br> 3、u修饰符（用来正确处理四字节的utf-16）且可以使用大括号包住表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号<br> 例如/^\uD83D/u<br> 4、正则实例对象新增.unicode属性，表示是否设置了u修饰符。RegExp.prototype.unicode 会返回布尔类型值<br> 5、新增y修饰符，叫做“粘连”修饰符，全局匹配。g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始<br> 6、正则实例对象多了sticky属性，表示是否设置了y修饰符 RegExp.prototype.usticky 会返回布尔类型值<br> 7、正则表达式新增了flags属性，会返回正则表达式的修饰符<br> 8、s修饰符使得.可以匹配任意单个字符（之前点不可以匹配回车换行 行分隔符 段分隔符）<br> 且给正则实例增加了属性dotAll 返回布尔表示是否使用了s修饰符<br> 9、具名组匹配 正则表达式使用圆括号进行组匹配<br> 10、String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器，而不是数组，解决了es5中一次次的去匹配取出gy</p> 
<p>六、<mark>数值的扩展</mark>（减少了一些对应es5的全局方法）<br> 1、二进制和八进制数值的新的写法 0b或B。 0o或0O<br> 0b111110111 === 503 // true 0o767 === 503 // true<br> 2、Number.isFinite()判断一个数是否是有限的, Number.isNaN()判断一个数是否是NaN 它们只对数值有效，不进行类型的转换<br> 3、Number.parseInt(), Number.parseFloat() 与es5一致，会进行类型的转换<br> 4、Number.isInteger() 判断一个数值是否为整数，参数不是数值直接false<br> 5、Number.EPSILON 表示 1 与大于 1 的最小浮点数之间的差<br> 6、Number.isSafeInteger() 整数范围在-2<sup>53到2</sup>53之间（不含两个端点） 判断是否为安全整数<br> js能准确表示的整数范围是-2<sup>53到2</sup>53。 Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER用来表示这个范围的上下限<br> 例如：Number.MAX_SAFE_INTEGER === Math.pow（2，53） - 1 // true</p> 
<p>7、==Math对象的扩展<br> Math.trunc（）方法用于去除一个数的小数部分，返回整数部分 会进行类型的转换<br> Math.sign（）方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值<br> 参数为正数，返回+1；<br> 参数为负数，返回-1；<br> 参数为 0，返回0；<br> 参数为-0，返回-0;<br> 其他值，返回NaN。<br> Math.cbrt()方法用于计算一个数的立方根<br> Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0 先转为二进制补齐32位，看前导 0有多少个<br> Math.imul()方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。即返回两个数相乘的结果<br> Math.fround()方法<br> Math.hypot()方法返回所有参数的平方和的平方根<br> Math对象新增了4个对数相关的方法<br> Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1<br> Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。<br> Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN<br> Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN<br> 8、新增了一个指数运算符（**）<br> 9、BigInt 数据类型（大整数） BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示 即须添加后缀n。123n<br> ⚠️以使用负号（-），但是不能使用正号（+） -123n可以。 正不可以<br> 可以将数转为大整型。 BigInt（123） // 123n</p> 
<p>七、<mark>函数的扩展</mark><br> 1、函数参数的默认值（参数默认值是惰性求值，每次都会重新求，而不是默认固定的 ）。一般默认值写在尾参数的位置，容易看出来那些参可以省，如果写在别的位置，实质上是不可以省的<br> 好处：可立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行<br> ⚠️ 函数的参数是默认声明的，不可再用let const重复声明<br> ⚠️ 在使用默认参数时，不可有同名的参数。如：function(x,x,y)可以。但function(x,x,y=1)就会报错<br> 1）直接写在参数定义的后面。function(x,y=0)<br> 2) 可用解构赋值来指定默认值（即严格等于undefined时，默认值才会生效）<br> 2、函数的length属性。函数的length属性，将返回没有指定默认值的参数个数（即不是真实的参数个数） 默认参数后面的参数都不会记<br> 3、作用域：在使用默认参数后，参数进行声明初始化时，参数会形成一个单独的作用域（不是去全局找）<br> 4、rest参数（该变量将多余的参数放入数组中） …变量名 用于获取函数的多余参数，它只能是最后一个参数，否则报错，length属性也不包含此参数<br> ⚠️es5用的是伪数组arguments对象，当函数调用时，函数的参数会传入这个数组对象中<br> 5、严格模式<br> es5中函数的内部可以设置严格模式’use strict’<br> es6规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错6<br> 6、函数的name属性（返回函数的名字，字符串类型）<br> 1）匿名函数的变化：将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。<br> 7、箭头函数（=&gt;）定义函数箭头函数，箭头后面的就是函数体部分。不需要参数或需要多个参数，就使用一个圆括号代表参数部分<br> 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。若返回的是一个对象用小括号扩起来，否则会解析成代码块，而非函数体<br> 如果箭头函数只有一行语句，不用括起来</p> 
<pre><code>    使用注意点⚠️：1）函数体内的this对象，继承自定义时所在的作用域。  即this指向是固定的跟调用模式无关
                              2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。因为没有constructor、prototype
                              3）不可以使用arguments对象，可以用 rest 参数代替。
                              4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
    使用注意点⚠️：不用于对象中方法（对象中的方法不用箭头函数定义，因为一般我们希望this指向该对象，而对象不构成作用域所以会使this指向全局或是上层作用域，改变初衷）但这种方式可以固定this指向，普通函数可能因调用方式的不同使this指向不同
                              5）不能使用apply、call、bind修改this指向，因为它无自身this，传了也会忽略
</code></pre> 
<pre><code class="prism language-javascript"><span class="token comment">// 案例1</span>
类中箭头函数是放在实例中的，普通函数在原型中
<span class="token comment">// 案例2</span>
<span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
 <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
 <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 指向window,定义时所在的作用域中</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> 
 <span class="token function-variable function">c</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 会因调用方式不同指向不同</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
object<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
object<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> object<span class="token punctuation">.</span>c<span class="token punctuation">;</span>
<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 案例3</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">growUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 定时器中this指向window,可以通过存储变量拿到对象中this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-javascript">（<span class="token number">1</span>）apply、call、bind的区别
    <span class="token literal-property property">apply</span><span class="token operator">:</span>克隆函数，改变<span class="token keyword">this</span>，传入数组参数，执行后函数立即执行
    call：克隆函数，改变<span class="token keyword">this</span>，传入参数序列，执行后函数立即执行
    bind：克隆函数，改变<span class="token keyword">this</span>，传入参数序列，执行后函数不立即执行
    
（<span class="token number">2</span>）如何修改定时器<span class="token keyword">this</span>指向
    apply、call不能用于修改定时器<span class="token keyword">this</span>，因为会立即执行失去定时器的意义
    <span class="token number">1</span>）保存变量，利用作用域链修改<span class="token keyword">this</span>指向
		    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
		    <span class="token literal-property property">dd</span><span class="token operator">:</span><span class="token number">666</span><span class="token punctuation">,</span>
		    <span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		        that <span class="token operator">=</span> <span class="token keyword">this</span>
		        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>dd<span class="token punctuation">)</span>
		        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
		     <span class="token punctuation">}</span>
		   <span class="token punctuation">}</span>
		 obj<span class="token punctuation">.</span><span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 66</span>
    
    <span class="token number">2</span><span class="token punctuation">)</span>使用bind（返回一个函数）
		<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
		    <span class="token literal-property property">dd</span><span class="token operator">:</span><span class="token number">666</span><span class="token punctuation">,</span>
		    <span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
		    <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		obj<span class="token punctuation">.</span><span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   
   <span class="token number">3</span>）使用箭头函数（利用箭头函数无<span class="token keyword">this</span>，继承拿到）
	   <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token literal-property property">dd</span><span class="token operator">:</span><span class="token number">666</span><span class="token punctuation">,</span>
	    <span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
	            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dd<span class="token punctuation">)</span>
	        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
	    <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span>
	  obj<span class="token punctuation">.</span><span class="token function">tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

（<span class="token number">3</span>）如何修改箭头函数<span class="token keyword">this</span>指向
    apply、call、bind不能用于修改箭头函数<span class="token keyword">this</span>，因为箭头函数无自身<span class="token keyword">this</span><span class="token punctuation">,</span>来自继承
    一般不修改，定义时生效的，要不不要使用 


<span class="token comment">// 模拟实现 call方法（将函数添加至新对象中方法，执行再删除。参数：）</span>
	<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 模拟实现call</span>
	    <span class="token keyword">var</span> context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span> <span class="token comment">// 兼容null时指向window</span>
	    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 给新指向的函数执行添加方法（保存新的this指向）</span>
        <span class="token comment">//  处理参数序列 </span>
	    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arguments['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	
	    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理返回</span>
	    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
	    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 测试一下</span>
	<span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>
	        <span class="token literal-property property">name</span><span class="token operator">:</span> name<span class="token punctuation">,</span>
	        <span class="token literal-property property">age</span><span class="token operator">:</span> age
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 1</span>
	<span class="token comment">// Object {<!-- --></span>
	<span class="token comment">//    value: 1,</span>
	<span class="token comment">//    name: 'kevin',</span>
	<span class="token comment">//    age: 18</span>
	<span class="token comment">// }</span>


<span class="token comment">// apply的实现，与call类似，参数是数组</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">apply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">||</span> window<span class="token punctuation">;</span>
    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 开始处理参数</span>
    <span class="token keyword">var</span> result<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 没传时</span>
        result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 传了数组参数时</span>
        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arr['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token comment">// 传一次参数执行</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
</code></pre> 
<p>8、尾调用优化：只保存内层函数的调用帧（节省内存，直接用内层函数的调用帧，取代外层函数的调用帧就可以,因为是函数的最后一步其他也无需保存了）即在函数的最后一步纯调用另一函数（只要是函数的最后一步即可,是函数的最后一步操作即可）<br> 尾递归：尾部纯调用自己，只保存最后一个调用帧不会发生栈溢出（递归指自己调用自己）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 实例</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// 不是尾调用，因为还会执行return undefined</span>
<span class="token punctuation">}</span>

<span class="token comment">// 尾递归案例 阶乘 1*2*n</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>total<span class="token operator">=</span><span class="token number">1</span></span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> total
<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">*</span>total<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>c1<span class="token punctuation">,</span>c2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c2
<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c1<span class="token operator">+</span>c2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>9、函数参数的尾逗号：允许在最后一个参数后面出现参数<br> 10、Function.prototype.toString() 对实例的方法做了修改，要求返回一模一样的函数字符串，注释空格不可以省</p> 
<p>八、<mark>数组的扩展</mark><br> es5中数组方法<br> 1、 Array.push()在数组最末尾插入元素，改变了数组长度，返回数组的长度，原数组改变了<br> 2、 Array.pop()在数组最末尾删除一项，返回删除项，原数组改变了（去掉了最后一项）<br> 3、 Array.unshift()在数组的最前面添加元素，返回数组长度，原数组改变了<br> 4、 Array.shift()在数组的最前面删除一项，返回删除项，原数组改变了=<br> 5、 Array.reverse()数组的翻转，返回翻转后结果，原数组改变了<br> 6、 Array.sort（）数组的排序，默认升序排列，可以函数作为参数指定降序等，返回排序后结果，原数组也变为排序后结果<br> 7、Array.indexOf()即给字符查索引,返回对应索引值（缺点查不了NaN）联想.findIndex()<br> 8、Array.concat()数组的连接，可将多个数组连接成一个新数组，返回连接成的新数组（原先各数组不会改变）<br> 9、Array.slice()数组的截取，一个参数表示从哪开始截取。两个参数包左不包右。返回截取到的数组，负数从倒数开始算<br> 10、Array.splice(开始位置， 删除的个数，元素)万能方法，可以实现增删改：返回的是截取到的新数组，无截取到则返回[] 注意：原数组也改变了<br> 11、Array.toString()数组转为字符串，返回转成的字符串<br> 12、Array.join()数组转为字符串 不写参数默认逗号即1,4，5这种 “”无缝连接 或可以指定字符连接<br> 数组迭代方法<br> 1）Array.map()数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，原来数组不变<br> 2）Array.forEach()遍历数组，无返回值，直接改变原数组 注意和.map()区分<br> 3）Array.every()将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false<br> 4）Array.some()将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false<br> 5）Array.filter()将所有元素进行判断，将满足条件的元素作为一个新的数组返回<br> 6）Array.reduce()所有元素调用返回函数，返回值为最后结果，参数是函数<br> es6扩展<br> 1）扩展运算符… 实质调用数据结构的iterator接口，将数组转为用逗号分隔的参数列表 可替代函数的apply方法<br> … 将数组转成用逗号分隔的序列，一般用于函数参数rest参数将对于参数放入数组中（或数组最为参数列表时使用）<br> 替代函数的apply方法将数组参数转为序列参数 f.apply(null，[1,2])<br> 用于数组的合并、与结构赋值结合<br> 可将实现了iterator迭代器的伪数组转为真正的数组（对象不可以，没有实现iterator报错）<br> 2）Array.from() 用于将两类对象转为<mark>真正数组</mark> 1、可遍历的iterator 2、类似数组的对象(就是有length属性)<br> Array.from(new Set(arr)) // set类似数组但成员都是唯一的<br> Array.from(arr,x=&gt;x*x) // 返回函数处理后的数组结果<br> 3）Array.of() 将一组数值转为数组 弥补了Array()的缺陷Array(3)即[，,] 而Array.of(3)即[3]<br> 比较统一：总是返回参数组成的数组<br> 4）arr.copyWithin()三个参数 当前数组内部将指定位置的成员复制到其他位置</p> 
<pre><code class="prism language-javascript">参数：开始替换数据的位置（必须）、读取数据开始位置（默认<span class="token number">0</span>）、读取数据结束位置（默认长度，有值不包含该位置处的）负数会 转成<span class="token operator">+</span>数组长度
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>从<span class="token number">0</span>位置开始替换，读取 <span class="token number">3</span>到最后 <span class="token comment">// 4，5，3，4，5</span>
</code></pre> 
<p>5）arr.find() 找出第一个符合条件的数组<mark>成员</mark>，若都不符合返回undefined 它的参数为一个回调函数(接受三个参数) 第二个参数用来绑定回调函数中this对象<br> arr.findIndex() 它返回的是第一个符合条件的值的索引 可以发现NaN 弥补indexof的不足，无-1</p> 
<pre><code class="prism language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>x<span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 4 值、位置、原数组</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>x<span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 3 值、位置、原数组</span>
</code></pre> 
<p>6)arr.fill(2,0,1) 用给定值填充一个数组 。接受第二、第三个参数表示填充的起始结束位置（不写的话默认从头填充到尾）</p> 
<pre><code class="prism language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 0，1位置用7填充 [7,7,3]</span>
</code></pre> 
<p>7)数组实例的entries、keys、values用于遍历数组,返回的视遍历器，用于遍历数组<br> 8)arr.includes() 判断某个数组是否包含了给定值，返回布尔值 可以接受第二参数表示搜索的起始位置 可以正确判断NaN，负数则表示倒数位置，若负数超出长度则0开始<br> 9)arr.flat() 将嵌套的数组拉平 默认拉平一层 可以设想要拉平层数 Infinity全部拉平<br> 10)arr.flatMap() 第一个参数函数（接受三个参数），第二个绑定this对象<br> 先执行函数返回结果组成的新数组，在执行flat拉平一层<br> 11）数组的空位<br> es5中对空位的处理：forEach、filter、some、every跳过空位<br> map执行时跳过但会保留这个值<br> join、toString视为undefined,undefined、null处理成空串<br> es6将空位视为undefined</p> 
<p>伪数组:具有length属性，可遍历，但不具备数组的各方法</p> 
<pre><code class="prism language-javascript">伪数组转为真数组方法
<span class="token number">1</span>）Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments）
<span class="token number">2</span>）<span class="token punctuation">[</span>…arguments<span class="token punctuation">]</span>
<span class="token number">3</span>）Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-javascript"><span class="token comment">// (1)是否实例的判断：不准因为所有的引用类型都是对象的实例 arr.instanceof Object true</span>
arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>  
<span class="token comment">// (2) 判断它的构造函数是否数组:</span>
arr<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array
<span class="token comment">//（3）es6提供的方法:有些低版本浏览器不支持</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token comment">// (4) 通用的toString方法</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">'[object Array]'</span>
</code></pre> 
<p>找出数组中最大值方法</p> 
<pre><code class="prism language-javascript"><span class="token number">1</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span> 利用apply可传数组作为参数，因为Math<span class="token punctuation">.</span>max的参数 不是数组
<span class="token number">2</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token number">3</span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">4</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> b<span class="token operator">&gt;</span>a<span class="token operator">?</span>b<span class="token operator">:</span>a<span class="token punctuation">;</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>九、<mark>对象的扩展</mark><br> 1、属性的简结表示法（允许在对象中写入变量或者函数）。<br> const foo = ‘bar’;<br> const baz = {foo};<br> baz // {foo: “bar”}<br> 对象中方法也可以简洁表示省略function。 method（参数）{代码块}. 原来写法method:function(){}<br> 2、name属性，对象方法也是函数，因此也有name属性<br> bind方法创造的函数，name属性返回bound加上原函数的名字；<br> Function构造函数创造的函数，name属性返回anonymous<br> 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述<br> 3、对象中属性的可枚举性和遍历<br> Object.getOwnPropertyDescriptor（对象名，属性）方法可以获取该属性的描述对象// { value: 123, writable: true, enumerable: true, configurable: true }<br> 有四个操作会忽略不可枚举的属性<br> for…in循环：只遍历对象自身的和继承的可枚举的属性。 要是对自己属性的操作 还应判断 obj.hasOwnProperty(key)<br> Object.keys()：返回对象自身的所有可枚举的属性的键名。<br> JSON.stringify()：只串行化对象自身的可枚举的属性。<br> Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。<br> Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名<br> Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有 Symbol 属性的键名<br> Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举<br> 4、super关键字（类似this关键字）指向当前对象的原型对象 ⚠️只能用在对象的方法中，其他地方会报错<br> 5、对象的扩展运算符（…对象。用于取出参数对象的所有可遍历属性，拷贝到当前对象之中）. 即类似对象的拷贝。Object.assign({},要拷贝过来的对象)方法<br> 例如：const z={a:4,b:5}. const c={…z}.<br> 6、链判断运算符。？.判断是否存在 原来是===“undefined”<br> obj?.prop // 对象属性<br> obj?.[expr] // 对象属性<br> func?.(…args) // 函数或对象方法的调用<br> 7、Nul l判断运算符 ?? 行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值<br> 读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值<br> const headerText = response.settings.headerText || ‘Hello, world!’;</p> 
<p>对象的新增方法<br> 1、Object.is() 解决es5的缺陷 es5 比较两个值是否相等，只有两个运算符：相等运算符（<mark>）和严格相等运算符（</mark>=）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0.<br> ⚠️：空对象是不等于空对象，它是复杂数据类型<br> 2、Object.assign(目标对象，源对象)。对象的合并，将源对象中所有可枚举的属性复制到目标对象。 若参数不是对象会先进行转换，nu l l和undefined没法转，会报错。实现的是浅拷贝<br> 3、Object.getOwnPropertyDescriptors(ob j)返回某个对象属性的描述对象<br> 4、__proto__属性,用来读取或设置当前对象的原型对象<br> Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象<br> 5、Object.keys(obj)方法，返回一个数组，成员是对象自身的（不含继承的）所有可遍历属性的键名<br> Object.values(obj)方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值<br> Object.entries(obj)方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组<br> 6、Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象</p> 
<p>十、<mark>Symbol</mark>(数据类型，不是构造函数，不可用new)：可用于创建独一无二的值，不存在相等重名的情况<br> 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突<br> 1、声明：let cc=Symbol() 可以接受一个字符串作为参数，表示对 Symbol 实例的描述,即使参数同，两个symbol值也不相等，只是利于区分哪个是哪个<br> 2、可以转字符串类型、布尔类型，不可转数值<br> 3、实例属性 Symbol.prototype.description 可以返回它的描述<br> 4、Symbol 值作为对象属性名时，不能用点运算符添加和查询，因为点运算后总是字符串，因此不会读取symbol属性名<br> 遍历Symbol 对象属性名 Object.getOwnPropertySymbols(obj)方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值 得到的是属性名组成的数组<br> 5、创建和使用同一Symbol 值<br> Symbol.for()接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局<br> let s1 = Symbol.for（“foo”）<br> let s2 = Symbol.for（“foo”）此时它们值相等<br> Symbol.keyFor(s1)方法返回一个已登记的 Symbol 类型值的key,无就是undefined<br> 6、内置的 Symbol 值 提供11内置Symbol 值</p> 
<p>十一、<mark>Set和Map数据结构</mark><br> 1、Set 集合新的数据结构，类似数组，但不可有重复的值，是一个构造函数，用来生成Set 数据结构 let h=new Set()<br> 作用 ：可以给数组或者字符串去重<br> 实例的属性和方法<br> Set.prototype.constructor 它的构造函数，默认就是Set函数。<br> Set.prototype.size：返回Set实例的成员总数<br> Set.prototype.add(value)：添加某个值，返回 Set 结构本身。<br> Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br> Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。<br> Set.prototype.clear()：清除所有成员，没有返回值。<br> 四个遍历方法<br> Set.prototype.keys()：返回键名的遍历器<br> Set.prototype.values()：返回键值的遍历器<br> Set.prototype.entries()：返回键值对的遍历器<br> Set.prototype.forEach()：使用回调函数遍历每个成员<br> 2、WeakSet不重复的值的集合 但WeakSet 的成员只能是对象，WeakSet 中的对象都是弱引用。是构造函数<br> ⚠️具有 Iterable 接口的对象，都可以作为 WeakSet 的参数<br> WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br> WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br> WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在<br> 3、Map 类似对象也是健值对的集合，但是健的范围扩展了，不只是字符串 是构造函数，用来生成Map 数据结构<br> 实例属性和方法<br> .size属性返回 Map 结构的成员总数<br> .set(key, value) 添加<br> .get(key)属性对应值<br> .has(key) 布尔<br> .delete(key)布尔<br> .clear() 清除无返回值<br> Map.prototype.keys()：返回键名的遍历器。<br> Map.prototype.values()：返回键值的遍历器。<br> Map.prototype.entries()：返回所有成员的遍历器。<br> Map.prototype.forEach()：遍历 Map 的所有成员。<br> 4、WeakMap 类似Map 生成键值对的集合但是健名只能是对象（null除外），键名所指的对象弱引用。构造函数<br> 应用DOM 节点作为键名，不用手动删除<br> .set(key, value) 添加<br> .get(key)属性对应值<br> .has(key) 布尔<br> .delete(key)布尔</p> 
<p>十二、<mark>Proxy</mark> 是构造函数，用于生成Proxy实例。是一种元编程，修改语言内部的默认行为（即外界对某对象的访问，先通过这层拦截）。可以对外界的访问过滤和改写<br> let proxy=new Proxy(目标对象，拦截对象)<br> 对象的实例方法：<br> 1、get(target, propKey, receiver)：拦截对象属性的读取，第三参可选<br> 2、set(target, propKey, value, receiver)：拦截对象属性的设置<br> 注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br> 严格模式下，set代理如果没有返回true，就会报错。<br> 3、has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值<br> 如果原对象不可配置或者禁止扩展，这时has拦截会报错<br> has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性<br> 4、deleteProperty(target, propKey)<br> 5、ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的 属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性<br> 6、getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象<br> 7、defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值<br> 8、preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值<br> 9、getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象<br> 10、isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值<br> 11、setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截<br> 12、apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)<br> 13、construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)</p> 
<p>十三、<mark>Reflect</mark> 从Reflect对象上可以拿到语言内部的方法,不是构造函数<br> 13个静态方法，用于获取语言内部方法，与Proxy是对应的</p> 
<p>Reflect.apply(target, thisArg, args)<br> Reflect.construct(target, args)<br> Reflect.get(target, name, receiver)<br> Reflect.set(target, name, value, receiver)<br> Reflect.defineProperty(target, name, desc)<br> Reflect.deleteProperty(target, name)<br> Reflect.has(target, name)<br> Reflect.ownKeys(target)<br> Reflect.isExtensible(target)<br> Reflect.preventExtensions(target)<br> Reflect.getOwnPropertyDescriptor(target, name)<br> Reflect.getPrototypeOf(target)<br> Reflect.setPrototypeOf(target, prototype)</p> 
<p>十四、<mark>Promise对象</mark>是一个构造函数，用来生成实例（实现异步的办法）<br> const promise=new Promise (function(resolve,rejest){<!-- --><br> //要执行的异步操作，resolve,rejest函数是内部提供的，根据异步操作的执行结果，更新实例的状态，将结果作为此函数的参数传递出去<br> })<br> 1、特点：对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态<br> 一旦状态改变，就不会再变<br> 2、缺点：一旦新建就会立即执行，中途无法取消<br> 若不设置对应的回调函数，内部抛出的错误无法反应到外部<br> 在进行时，无法知道执行到哪一步了<br> 3、实例方法（定义在构造函数的原型对象上）<br> .then 接受两个函数参数，指定状态下对应的回调函数，参数就是上一个promise实例穿出来的参数<br> .catch 对抛出的错误做处理，即异步操作失败执行的回调函数<br> .finally 跟实例的状态变更无关，都会执行的操作，回调函数不接受参数<br> 4、Promise对象方法<br> Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例<br> Promise.race()方法将多个 Promise 实例，包装成一个新的 Promise 实例<br> Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例<br> Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例<br> 它们都是返回新的实例，但实例的状态变更原则与传入对应回调函数的参数是各有不同的<br> Promise.resolve() 将现有对象转为Promise 实例并返回<br> 1）如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例<br> 2）具有then方法的对象，将这个对象转为 Promise 对象，然后就立即执行then方法<br> 3）不是对象，或者是一个不具有then方法的对象，返回一个新的 Promise 对象，状态为resolved<br> 4）无参 直接返回一个resolved状态的 Promise 对象</p> 
<p>十五、<mark>遍历器和for of循环</mark><br> 遍历器是一个接口，为各个数据结构提供访问机制，部署在数据结构的Symbol.iterator属性上<br> 它的本质就是一个指针。指向起始位置，用next方法遍历，直到数据结构的最后一个位置，每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性{value:,done:}<br> 原生具备 Iterator 接口的数据结构如下。 可使用for of遍历<br> Array<br> Map<br> Set<br> String<br> TypedArray<br> 函数的 arguments 对象<br> NodeList 对象</p> 
<p>十六、<mark>Generator 函数的语法</mark> Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，而不是去执行对象本身<br> 1、形式上：有两个特征一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态<br> ⚠️执行 Generator 函数会返回一个遍历器对象，而不是去执行对象本身<br> 每次调用遍历器对象的next方法，遇yield命令暂停，返回{value:yield表达式值,done:是否遍历结束} 若方法有参数，则就是value值<br> 当使用for of循环时，不会返回最后一个值，即done为true的属性值<br> 2、遍历器对象方法<br> Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获catch<br> Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数<br> ⚠️：不提供参数，则返回值的value属性为undefined<br> ：如果 Generator 函数内部有try…finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束</p> 
<p>十七、<mark>Generator 函数的异步应用</mark><br> 实现原理；需暂停的地方用yield命令<br> 使用next来实现与函数体内与向函数体外数据传递</p> 
<p>十八、<mark>async函数</mark> 对Generator 函数的改进，也是实现异步操作 但它内置执行器，不用手动使用next方法或co模块<br> 使用注意点：1）await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中<br> 2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发<br> 3）await命令只能用在async函数之中，如果用在普通函数，就会报错</p> 
<p>十九：<mark>类Class</mark>跟构造函数的用法一致，类中的方法都定义在类的原型上，实例都可继承<br> 注意点⚠️：必须用new创建实例，否则报错<br> 方法上不要function,且方法间不要逗号<br> 类中方法都是不可枚举的<br> 不存在变量提升<br> 当在方法前加static关键字时，表明是静态方法，只能被类调用，不可被实例继承使用，静态方法中的this指向类而不是对象实例<br> 当实例创建后自动执行构造方法，类中没有定义构造方法，则默认添加一个空的构造方法</p> 
<p>二十：<mark>Class的继承</mark><br> 1、类的继承 用extends关键字来实现继承（父类的静态方法也会被子类继承）<br> class B extends A{<!-- --><br> }<br> 注意点⚠️子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，<br> 得到与父类同样的实例属性和方法，然后再对其进行加工，加上 子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象<br> 2、Object.getPrototypeOf方法可以用来从子类上获取父类（相当于父就是它的原型，它继承父的属性和方法）<br> 3、super关键字<br> 1)super作为函数使用时，只能用在子类的构造函数中，指向父类的构造方法，返回子类实例（即this指向子类实例）<br> 2)在普通方法中作为对象使用时，指向父类原型（父类实例上增加的属性和方法访问不了），方法中this指向子类实例<br> 3)在静态方法中作为对象使用时，指向父类，this指向子类（即找静态方法和静态属性中查找，就是类自己本身的）<br> 4、类的prototype属性和__proto__属性<br> （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。<br> （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性<br> 5、实例的 <strong>proto</strong> 属性<br> 实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性</p> 
<p>二十一：<mark>修饰器</mark></p> 
<p>二十二、<mark>Module的语法</mark>（模块）浏览器和服务器通用的模块化解决方案。在编译时完成模块的加载<br> 1、ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";<br> 主要有以下限制：</p> 
<p>变量必须声明后再使用<br> 函数的参数不能有同名属性，否则报错<br> 不能使用with语句<br> 不能对只读属性赋值，否则报错<br> 不能使用前缀 0 表示八进制数，否则报错<br> 不能删除不可删除的属性，否则报错<br> 不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br> eval不会在它的外层作用域引入变量<br> eval和arguments不能被重新赋值<br> arguments不会自动反映函数参数的变化<br> 不能使用arguments.callee<br> 不能使用arguments.caller<br> 禁止this指向全局对象<br> 不能使用fn.caller和fn.arguments获取函数调用的堆栈<br> 增加了保留字（比如protected、static和interface）<br> 2、export命令 规定模块的对外接口，可出现模块的任何位置 ，必须是顶层，否则报错<br> 语法 ：export {, , ,}<br> 也可对输出变量重命名 export {<!-- --><br> 变量 as 新起的名，<br> 变量 as 新起的名<br> }<br> 3、import命令 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块<br> 语法：import（模块路径）<br> 应用 1）按需加载<br> 2）条件加载</p> 
<p>语法：import {firstName, lastName,year } from ‘./profile.js’ import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径<br> ⚠️ 引入的变量名要与人家模块导出的名字一致，当然可以使用关键字as进行重命名 import {firstName as hhh } from ‘./profile.js’;<br> ⚠️import命令输入的变量都是只读的，不允许在进行改写，若引入的变量是对象，对对象属性的改写是可以的 但别的模块也会相应地改写，所以禁止用<br> ⚠️import命令具有提升效果，会提升到整个模块的头部，首先执行<br> ⚠️由于import是静态执行，所以不能使用表达式和变量<br> 4、export default命令，为模块指定默认输出。import命令导入时指定任意名字<br> ⚠️与export的区别，他后面不可以跟变量的声明，但可以跟具体的数值，与export完全不同，并且它对应的导入不可有大括号<br> 5、import（）//实现动态加载功能，在运行时加载指定的模块。 会返回一个Promise对象，当加载成功，将这个模块当作then的参数传入</p> 
<p>二十三、<mark>Module的加载实现</mark><br> HTML 网页中，浏览器通过</p> 
<p>二十四、<mark>编程风格</mark>（如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码）<br> 1、块级作用域<br> 1）let 取代 var 增加块级作用域，变量只在所在的块级有效 这样减少全局属性的增加及不存在变量提升<br> 2）在let和const之间，建议优先使用const 尤其是在全局环境，不应该设置变量，只应设置常量<br> 好处：一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误<br> 2、字符串。静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号<br> 就是利用模版字符串，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
         来拼接变量。 
        
       
         e 
        
       
         g 
        
       
         . 
        
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
         b 
        
       
         = 
        
       
         ‘ 
        
       
         f 
        
       
         o 
        
       
         o 
        
       
      
        {}来拼接变量。 eg.const b = `foo 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"></span><span class="mord cjk_fallback">来拼接变量。</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord">.</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">oo</span></span></span></span></span>{a}bar`;<br> 3、使用解构赋值<br> 4、对象<br> 1）单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾<br> 2）对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 Object.assign(a, { x: 3 }); 即就是a.x=3<br> 3）对象的属性和方法，尽量采用简洁表达法. add(){} 而不是 add:function(){}<br> 5、数组. 之前喜欢用for循坏来拷贝数组，尽量用扩展运算符去拷贝数组<br> 使用 Array.from 方法，将类似数组的对象转为数组<br> 6、函数<br> 1）立即执行函数可以写成箭头函数的形式<br> 2）简单的、单行的、不会复用的函数，建议采用箭头函数<br> 3）使用默认值语法设置函数参数的默认值<br> 7、Map 需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制<br> 8、class 用它取es5中构造函数原型的写法<br> 9、尽量开发模块化。使用import与export或export default<br> ⚠️模块默认输出一个函数，函数名的首字母应该小写<br> 模块默认输出一个对象，对象名的首字母应该大写</p> 
<p>二十五、<mark>规格</mark>（详细描述语言内部语法规则和实现方法）</p> 
<p>二十六、<mark>异步遍历器</mark><br> 1、同步遍历器。 之前学习的遍历器的next方法是同步的（Iterator 协议里面next()方法只能包含同步操作）<br> 2、异步遍历器。 ES2018 引入了“异步遍历器”为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生 即调用遍历器的next方法，返回的是一个 Promise 对象，可以使用then方法指定，<br> 这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的<br> 对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历 ，<br> 异步遍历的next方法回的是一个 Promise对象 若自己去实现的话就让next方法中返回一个Promise对象<br> 3、具有同步遍历接口的我们可以用for of 循坏遍历。<br> 而具有异步遍历接口的可用for await…of<br> 4、异步 Generator 函数的作用，是返回一个异步遍历器对象，而之前学的调用 Generator 函数返回的是同步遍历器<br> 在前面加async 此时调用next方法返回的是异步的Promide对象，可用then等方法，它的参数就是{value:,done:}<br> ⚠️异步 Generator 函数内部，能够同时使用await和yield命令。可以这样理解，await命令用于将外部操作产生的值输入函数内部，yield命令用于将函数内部的值输出 即value属性值<br> 5、yield*语句也可以跟一个异步遍历器。如跟一个Generator函数遍历器，否则我们还需手动去遍历</p> 
<p>二十七、<mark>ArrayBuffer</mark></p> 
<p>二十八、Decorator. Decorator 提案经过了大幅修改，目前还没有定案，es6中讲的完全依据以前的提案，已经有点过时了<br> 1）整个类的装饰<br> @testable<br> class MyTestableClass{<!-- --></p> 
<pre><code>         // ... }
                      }  
                再通过装饰器函数可对类尽享添加改写属性等操作，函数的参数就是类本身
           2）类方法的装饰
       class MyTestableClass{
         @readonly              
          name(){ }
         // ... }
                     }  
                  装饰器函数的参数分别为类的原型对象、要装饰的属性名、该属性的描述对象

           3）core-decorators.js是一个第三方模块，提供了几个常见的装饰器
</code></pre> 
<p><mark>补充</mark><br> https://juejin.cn/post/6844903811622912014<br> https://juejin.cn/post/6844904018834096142 ES7 8 9 10新特性<br> <img src="https://images2.imgbox.com/2a/63/KWoNIOmh_o.png" alt="在这里插入图片描述"><br> 之前的看ES6第三版（2015、2016、2017）<br> ES9即ES2018（2018.6月发版）<mark>用时需要看浏览器支持情况</mark></p> 
<pre><code class="prism language-javascript"><span class="token comment">//(1) for await of:for of可以遍历具有Symbol.iterator的同步迭代数据，异步不行</span>
<span class="token keyword">function</span> <span class="token function">Gen</span> <span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">Gen</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Gen</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Gen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token comment">// 2000 100 3000</span>

<span class="token comment">// (2)扩展运算符的扩展 （用于对象）</span>
<span class="token punctuation">{<!-- --></span>
<span class="token operator">...</span>obj1<span class="token punctuation">,</span>
<span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">11</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// (3)Promise的finally方法，Promise不管执行then/catch,finally最终会被执行</span>
<span class="token comment">// (4)新的正则表达式特性</span>
    <span class="token function">s</span><span class="token punctuation">(</span>dotAll<span class="token punctuation">)</span>flag<span class="token punctuation">,</span>在正则表达式中<span class="token punctuation">.</span>操作符代表任意单个字符（除四字节字符（u解决）及换行回车）
    s用于支持回车\r  换行\n
    eg、、
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span><span class="token regex-flags">s</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

    命名捕获组：允许每组匹配指定的一个名字，模式的头部添加“问号 <span class="token operator">+</span> 尖括号 <span class="token operator">+</span> 组名”（<span class="token operator">?</span>），可以准确拿个各个组的信息
    <span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> match <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'2019-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// → {year: "2019", month: "01", day: "01"}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// → 2019</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → 01</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// → 01</span>

    后行断言：<span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">...</span>是后行断言  <span class="token operator">?.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>是先行断言（先行断言先判断条件再看是否满足只能判断后）
    <span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'world hello'</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=world\s)hello</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// hello的前面是否world </span>
    <span class="token comment">// ["hello", index: 6, input: "world hello", groups: undefined]</span>
    
    
    Unicode属性转义： \p \<span class="token constant">P</span>允许匹配符合Unicode某种属性的所有字符
    <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'㉛'</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → false</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\p{Number}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// → true</span>

    \p<span class="token punctuation">{<!-- --></span>Alphabetic<span class="token punctuation">}</span>来匹配所有的Unicode单词字符
    负向的Unicode属性转义模板 \<span class="token constant">P</span><span class="token punctuation">{<!-- --></span><span class="token operator">...</span><span class="token punctuation">}</span>  <span class="token comment">// 例如/\P{Alphabetic}/u等，除单词字符</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\P{Number}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'㉛'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → false</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\P{Number}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'ض'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → true</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\P{Alphabetic}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'㉛'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → true</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\P{Alphabetic}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'ض'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// → false</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/21/d4/KL0GxtWS_o.png" alt="在这里插入图片描述"><br> ES10即ES2019（2019.6月发版）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// Array.prototype.flat() 数组原型上的拉平方法，多维数组拉平</span>
arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span>  <span class="token comment">// depth默认1,使用 Infinity，可展开任意深度的嵌套数组,会移除空项</span>

<span class="token comment">// Array.prototype.flatMap() // 拉平1层，传入函数，处理成自己要的结构或逻辑，返回新数组</span>
<span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [[2], [4], [6], [8]]</span>
arr1<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [2, 4, 6, 8]</span>

<span class="token comment">// Object.fromEntries() // 与Object.entries相反使得根据entries结果可得到对象</span>
<span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span><span class="token number">24</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> entries <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [['x', 23], ['y', 24]]</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { x: 23, y: 24 }</span>

<span class="token comment">// String.trimStart 和 String.trimEnd 移除开头或结尾的空格（可能第一个空格）</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">' 前端工匠 '</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 6</span>
str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 5</span>
<span class="token keyword">let</span> str1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 清除前后的空格</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 4</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">// 也可以用正则实现开头删除空格</span>

<span class="token comment">// String.prototype.matchAll  可以一次性取出所有的匹配，返回的是遍历器，可循环取出</span>
<span class="token keyword">function</span> <span class="token function">collectGroup1</span> <span class="token punctuation">(</span><span class="token parameter">regExp<span class="token punctuation">,</span> str</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regExp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> results
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">collectGroup1</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">"([^"]*)"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">"foo" and "bar" and "baz"</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ["foo", "bar", "baz"]</span>

<span class="token comment">// try…catch，catch参数可省</span>
<span class="token comment">// ES10之前</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// tryCode</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// catchCode</span>
<span class="token punctuation">}</span>
<span class="token comment">// ES10</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Foobar'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Bar'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// BigInt：js中所有的数保存成64位浮点数（16位十进制）一个字节8位无符号数 +-2^53-1,超过则无法精确表示。大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity</span>
<span class="token comment">// 超过 53 个二进制位的数值，无法保持精度</span>
Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span> <span class="token operator">===</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// true</span>
<span class="token comment">// 超过 2 的 1024 次方的数值，无法表示</span>
Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token comment">// Infinity</span>
<span class="token comment">// 用新的数据类型大整数BigInt来解决，只能用于表示整数，任何位数都可以（创建时加上n即可）</span>
<span class="token keyword">const</span> aNumber <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> aBigInt <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>aNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>
aBigInt <span class="token operator">===</span> <span class="token number">111n</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> aBigInt <span class="token operator">===</span> <span class="token string">'bigint'</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> <span class="token number">111</span> <span class="token comment">// "number"</span>
<span class="token keyword">typeof</span> <span class="token number">111n</span> <span class="token comment">// "bigint"</span>

<span class="token comment">// Symbol.prototype.description：获取描述</span>
<span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'desc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>description<span class="token punctuation">;</span>  <span class="token comment">// "desc"</span>
<span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>description<span class="token punctuation">;</span>      <span class="token comment">// ""</span>
<span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>description<span class="token punctuation">;</span>        <span class="token comment">// undefined</span>

<span class="token comment">// Function.prototype.toString():之前会去除空白符号，现在呈现原本源码</span>
要求返回一模一样的函数字符串，注释空格不可以省
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// function sum(a, b) {<!-- --></span>
<span class="token comment">//  return a + b;</span>
<span class="token comment">// }</span>
</code></pre> 
<p>ES11即ES2020（2020.6月发版）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1、可选链操作符：?.  访问对象链深处的值，不必明确每个引用都有效，遇null、undefined短路返回undefined,先隐式检查并确定前面的不是null/undefined</span>
obj<span class="token punctuation">.</span>val<span class="token operator">?.</span>prop
obj<span class="token punctuation">.</span>val<span class="token operator">?.</span><span class="token punctuation">[</span>expr<span class="token punctuation">]</span>
obj<span class="token punctuation">.</span>func<span class="token operator">?.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
 <span class="token comment">// 例子</span>
<span class="token keyword">let</span> nestedProp <span class="token operator">=</span> obj<span class="token punctuation">.</span>first<span class="token operator">?.</span>second<span class="token punctuation">;</span>   <span class="token comment">// 同obj.first.second取值时兼容写法</span>
<span class="token keyword">let</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
<span class="token keyword">let</span> nestedProp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> temp <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> temp<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2、空位合并操作符 ??  如果在左侧运算为undefined、null返回右侧默认值（替换之前使用||）</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">??</span> b<span class="token punctuation">;</span>
<span class="token comment">// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b;</span>
<span class="token comment">// 例子：经常无值设置其他值情况会忽略false、0等正常的输入</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">?</span> a <span class="token operator">:</span> b <span class="token comment">// 方式1</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">||</span> b <span class="token comment">// 方式2 (只要a为假就是b的值，例如是空值，false，0等都直接取值b)</span>

<span class="token comment">// 3、Promise.allSettled:并发处理多个请求，不会短路，等到全部处理完成可拿到每个Promise状态</span>
我们知道 Promise<span class="token punctuation">.</span>all 具有并发执行异步任务的能力。但它的最大问题就是如果参数中的任何一个promise为reject的话，则整个Promise<span class="token punctuation">.</span>all 调用会立即终止，并返回一个reject的新的 Promise 对象。
Promise<span class="token punctuation">.</span>allSettled优于Promise<span class="token punctuation">.</span>all（一个异常返回则不能正确拿到）
Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'服务异常'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token comment">/*
        0: {status: "rejected", reason: {…}}
        1: {status: "fulfilled", value: {…}}
        2: {status: "fulfilled", value: {…}}
    */</span>
  <span class="token comment">// 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span>
  <span class="token function">RenderContent</span><span class="token punctuation">(</span>
    res<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> el<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token string">'rejected'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 4、String.prototype.matchAll 匹配所有满足的，for of遍历取出</span>

<span class="token comment">// 5、Dynamic import</span>

<span class="token comment">// 6、globalThis：可以在任意上下问任意时刻获取全局对象（实际拿到window self global）</span>
全局变量 window：浏览器中是一个经典的获取全局对象的方法。但是它在 Node<span class="token punctuation">.</span>js 和 Web Workers 中并不能使用（ Web 内容在后台线程中运行脚本提供了一种简单的方法）
全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node<span class="token punctuation">.</span>js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中
全局变量 global：只在 Node<span class="token punctuation">.</span>js 中生效
<span class="token comment">// ES10之前的解决方案</span>
<span class="token keyword">const</span> <span class="token function-variable function">getGlobal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> self <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> self
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> window
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> global <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> global
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'unable to locate global object'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// ES10内置</span>
globalThis<span class="token punctuation">.</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// [0,1,2]</span>
<span class="token comment">// 定义一个全局对象v = { value:true } ,ES10用如下方式定义</span>
globalThis<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>globalThis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 7、大整数计算问题</span>
<span class="token function">BigInt</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/19/59/LrCWyNUj_o.png" alt="在这里插入图片描述"></p> 
<p>ES12即ES2021（2021.6月发版）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1、String.prototype.replaceAll 全部替换，无需使用正则的g</span>
<span class="token keyword">const</span> queryString <span class="token operator">=</span> <span class="token string">'q=query+string+parameters'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> withSpaces <span class="token operator">=</span> queryString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +用空格替换</span>
<span class="token keyword">const</span> withSpaces <span class="token operator">=</span> queryString<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2、Promise.any </span>
这个可以和之前的 Promise<span class="token punctuation">.</span>race 进行比较，二者都有短路原则，Promise<span class="token punctuation">.</span>race 会在某一个 Promise 被解决的时候完成，而 Promise<span class="token punctuation">.</span>any 会在某一个 Promise 处于 fulfilled 态的时候完成。有点绕，还是举例子：
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我没有错误'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 3、逻辑赋值操作符 </span>
x <span class="token operator">&amp;&amp;=</span> y  <span class="token comment">// 相当于 x &amp;&amp; (x = y) 如果 x 为真，则将 y 的值赋给 x</span>
x <span class="token operator">||=</span> y  <span class="token comment">// 相当于 x || (x = y)  如果x为假则将y值赋值给x</span>
x <span class="token operator">??=</span> y  <span class="token comment">// 相当于 x ?? (x = y)  ??空值合并操作符</span>

<span class="token comment">// 4、数字分隔符：数字有了更方便的书写方式(使用“_”来实现数字可读性),也可以直接参与运算</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1_000</span>  <span class="token comment">// 1000</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">1_000_000</span>  <span class="token comment">// 1000000</span>
</code></pre> 
<p>ES13即ES2022（2022.6月发版）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1、 Object.hasOwn 判断属性在不在对象自身中， 属性 in 对象（对象及原型上判断） obj.hasOwnProperty(‘名称’)（只在对象属性找）</span>
<span class="token comment">// 2、.at() 取数组索引处值，支持负数表示倒数第一个来找数组元素</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>

<span class="token comment">// 3、可以在模块的顶层使用 await 支持全局作用链异步加载（无需在async函数中）</span>
<span class="token keyword">let</span> jQuery<span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
  jQuery <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://cdn-a.com/jQuery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{<!-- --></span>
  jQuery <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://cdn-b.com/jQuery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4、 类的成员变量：私有变量、私有方法、静态私有变量、静态私有方法</span>
设置私有属性的方式是在变量前面加一个修饰符 #
<span class="token keyword">class</span> <span class="token class-name">ClassWithPrivateProperty</span> <span class="token punctuation">{<!-- --></span>
  #privateField<span class="token punctuation">;</span>
  <span class="token keyword">static</span> #<span class="token constant">PRIVATE_STATIC_FIELD</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#privateField <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">#privateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">#privateStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 5、RegExp Match Indices   正则表达式匹配指数 d修饰符</span>

<span class="token comment">// 6、in:支持使用in判断私有属性在 对象里是否存在</span>

<span class="token comment">// 7、Class Static Block 类静态模块</span>
</code></pre> 
<p>ES14即ES2023（2023.6月发版）</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1、数组新增方法</span>
toSorted、toReversed、toSpliced同原来的方法sort、reverse、splice方法，不过不会修改原数组会返回新的数组
<span class="token keyword">with</span><span class="token operator">:</span><span class="token function">更改给定索引值的复制版本</span><span class="token punctuation">(</span>不会修改原数组，返回更改后的新数组<span class="token punctuation">)</span> array<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'fatfish'</span><span class="token punctuation">)</span>索引<span class="token number">1</span>处值改为fatfish
<span class="token literal-property property">findLast、findLastIndex</span><span class="token operator">:</span>从后往前找符合条件的元素，找到结束返回找到的值或索引
<span class="token comment">// WeakMap 弱引用 </span>
<span class="token literal-property property">WeakMap</span><span class="token operator">:</span>支持使用Symbol作为key（之前只能使用object作为key）
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84397a0a6bda15eac169eb9b60ecb00b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【推荐】获取 aarch64 版本 libv8_monolith.a 静态库的三种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/581d6d7405e73baa9eb77068f309255c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">minio &#43; linux &#43; docker &#43; spring boot实现文件上传与下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>