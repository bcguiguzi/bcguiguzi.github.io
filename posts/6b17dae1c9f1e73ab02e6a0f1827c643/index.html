<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux文件引用计数的逻辑 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux文件引用计数的逻辑" />
<meta property="og:description" content=" Linux文件引用计数的逻辑 -v0.1 2019.10.10 Sherlock init
本文分析现在Linux内核中对打开文件引用计数的处理逻辑，目的是解答一个问题，即
对设备文件的操作会不会引用到已经释放的文件上。
考虑这样一个场景，打开一个字符设备文件/dev/A，得到一个fd，用户态可以对这个
fd做相关的文件操作，包括ioctl, mmap, close等，内核如果保证close操作和其他
操作的同步，即不会出现close和其他文件并发执行，其他文件访问已经close掉的文件
这种情况。
内核是靠打开文件的引用计数来保证这一点的。
kernel/fs/open.c filp_open &#43;-&gt; file_open_name &#43;-&gt; do_filp_open &#43;-&gt; path_openat &#43;-&gt; alloc_empty_file 这里在创建struct file结构的时候会把里面的f_count引用计数设置为1。 kernel/fs/ioctl.c ksys_ioctl系统调用 &#43;-&gt; fdget &#43;-&gt; __fdget 在rcu锁里得到file结构的指针 &#43;-&gt; __fget_light &#43;-&gt; __fget &#43;-&gt; get_file_rcu_many (atomic_long_add_unless(&amp;(x)-&gt;f_count, xx, 0)) 这里只有在f_count非0的时候才会把引用计数加1。如果是0，表明已经file 的引用计数已经是0。__fget会去files里查fd对应的file。 &#43;-&gt; fdput &#43;-&gt; fput &#43;-&gt; fput_many &#43;-&gt; atomic_long_dec_and_test(&amp;file-&gt;f_count) 如果减到0，在另一个内核线程中，延迟执行delay_work： &#43;-&gt; delayed_fput_work &#43;-&gt; delayed_fput &#43;-&gt; __fput &#43;-&gt; file_free(file) kernel/fs/open.c close系统调用 &#43;-&gt; __close_fd &#43;-&gt; spin_lock(&amp;files-&gt;file_lock) 在锁里拿到fd对应的file结构的指针 &#43;-&gt; filp_close &#43;-&gt; fput 如上 &#43;-&gt; spin_unlock(&amp;files-&gt;file_lock) " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6b17dae1c9f1e73ab02e6a0f1827c643/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-13T20:17:23+08:00" />
<meta property="article:modified_time" content="2019-10-13T20:17:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux文件引用计数的逻辑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Linux_0"></a>Linux文件引用计数的逻辑</h3> 
<p>-v0.1 2019.10.10 Sherlock init</p> 
<p>本文分析现在Linux内核中对打开文件引用计数的处理逻辑，目的是解答一个问题，即<br> 对设备文件的操作会不会引用到已经释放的文件上。</p> 
<p>考虑这样一个场景，打开一个字符设备文件/dev/A，得到一个fd，用户态可以对这个<br> fd做相关的文件操作，包括ioctl, mmap, close等，内核如果保证close操作和其他<br> 操作的同步，即不会出现close和其他文件并发执行，其他文件访问已经close掉的文件<br> 这种情况。</p> 
<p>内核是靠打开文件的引用计数来保证这一点的。</p> 
<pre><code>kernel/fs/open.c
filp_open
  +-&gt; file_open_name
    +-&gt; do_filp_open
      +-&gt; path_openat
        +-&gt; alloc_empty_file
	这里在创建struct file结构的时候会把里面的f_count引用计数设置为1。
</code></pre> 
<pre><code>kernel/fs/ioctl.c
ksys_ioctl系统调用
  +-&gt; fdget
    +-&gt; __fdget
      在rcu锁里得到file结构的指针
      +-&gt; __fget_light
        +-&gt; __fget
	  +-&gt; get_file_rcu_many (atomic_long_add_unless(&amp;(x)-&gt;f_count, xx, 0))
          这里只有在f_count非0的时候才会把引用计数加1。如果是0，表明已经file
	  的引用计数已经是0。__fget会去files里查fd对应的file。
  +-&gt; fdput
    +-&gt; fput
      +-&gt; fput_many
        +-&gt; atomic_long_dec_and_test(&amp;file-&gt;f_count)
	如果减到0，在另一个内核线程中，延迟执行delay_work：
	  +-&gt; delayed_fput_work
	    +-&gt; delayed_fput
	      +-&gt; __fput
	        +-&gt; file_free(file)
</code></pre> 
<pre><code>kernel/fs/open.c
close系统调用
  +-&gt; __close_fd
    +-&gt; spin_lock(&amp;files-&gt;file_lock)
    在锁里拿到fd对应的file结构的指针
      +-&gt; filp_close
        +-&gt; fput     
        如上
    +-&gt; spin_unlock(&amp;files-&gt;file_lock)
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d02ea07127514a29262da0b2369e07c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HDFS组成部分及作用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2235b0b19499bf16fa5c77871e9388ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">模拟幅度调制系统抗干扰性能仿真分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>