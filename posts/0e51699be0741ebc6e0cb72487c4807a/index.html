<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Andorid学习【基础篇】Android应用程序生命周期 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Andorid学习【基础篇】Android应用程序生命周期" />
<meta property="og:description" content="与C&#43;&#43;和Java不同的是，表面上Android应用程序并没有从main()函数启动，而是通过一系列的回调方法，方法响应用户的具体操作而被调用，使Andorid应用程序能切换到对应的状态，例如开启应用后，程序开始载入画面；用户操作，进入其他的页面；用户接电话、收发短信时，程序被暂停运行；用户想要暂时离开应用，回到桌面上打开其他应用等等，Andorid程序中的回调方法将会在相应的用户操作后执行，执行完毕之后，使得整个应用到达某一个状态，应用在每一种状态之间的切换，便构成了Android应用程序的生命周期。
也可以这样简单地理解Android应用程序生命周期：用户操作驱动相应的回调方法，相应的回调方法被执行后，使得状态在切换，状态的切换便构成了生命周期。
在Android的生命周期，有如下6个状态，分别是：Created，Started，Resumed，Paused，Stopped，Destroyed。相应的，有如下7个回调方法，使得Activity在不同的状态间切换，分别是：onCreate()，onStart()， onResume()，onPause()， onStop()，onRestart()，onDestroy()。当然这些方法只有在相应的用户操作或者状态发生之后才会被调用，在大多数情况下，我们可能根据需要，重载一部分回调方法，使得应用能如用户那样期待的正常运行。关于生命周期的流动方式，android官方教程给出的“金字塔式”图很直观地说明了问题：
一、 onCreate()
在启动应用后，首先调用onCreate()方法，该方法在整个应用的生命周期中只会被调用一次，主要完成应用的一些初始化工作，例如layout的载入，按钮、文本等等一些UI组件的初始化，或者是一些变量的初始化，因此如果要在启动时完成需要的初始化工作，只要重载该方法即可。
当应用开启时，系统将会根据在AndroidManifest.xml中指定的启动类，以该启动类作为入口进入程序，而onCreate以及其他6个回调方法都必须在该类中重载，其中，指定启动类，也就是我们的主类的写法，例如我们指定MainActivity.class作为主类，那么在AndroidManifest.xml中指定形式如下：
&lt;activity android:name=&#34;.MainActivity&#34; android:label=&#34;@string/app_name&#34;&gt; &lt;intent-filter&gt; &lt;action android:name=&#34;android.intent.action.MAIN&#34; /&gt; &lt;category android:name=&#34;android.intent.category.LAUNCHER&#34; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 一般来说，在onCreate()方法中，主要的目的是为该Activity创建一个实例，一般要做的事情有如下几件：
1. 调用父类onCreate()方法，载入上次保存的实例
2. 载入用户界面，一般来说是main_activity.xml
3. 定义或者调用一些用户自己定义的初始化方法
4. 为layout_main.xml中的UI控件分配相应变量，使得之后可以对其进行操作和管理
一个简单的例子如下：
TextView mTextView; // UI控件变量 private void userMethod() { // Codes goes here } @Override public void onCreate(Bundle savedInstanceState) { // 调用父类onCreate()方法，载入上次保存的实例 super.onCreate(savedInstanceState); // 调用用户自定义的方法 // 载入用户界面 setContentView(R.layout.main_activity); // 初始化UI控件变量 mTextView = (TextView) findViewById(R.id.text_message); } 其中，载入上次保存的实例savedInstanceState这一操作，将会在后面的博客文章中关于重新创建Activity的文章中，进行深入的学习。 当应用完成onCreate()的调用之后，到达Created状态，紧接着，系统将会立即调用onStart()和onResume()方法，使应用到达在前台显示出来(visible)，如果严格地说，在Started状态时应用已经在前台显示出来，但和Created状态一样，Started状态也是一个暂态，用户界面不会作任何停留，就会进入到Resumed状态，该状态便是应用稳定显示在前台时所处的状态，直到用户打算暂停、停止或者销毁应用时，onPause()，onStop()，onDestroy()方法将会被调用，将Activity带入金字塔的下层状态Paused，Stopped，Destroyed状态中，而且每一次回调方法的调用只会使状态改变一次，或者说只在金字塔上移动一层。关于onStart()和onResume()在一个应用中的重要意义和更多重载建议，将在下面Paused和Stopped状态返回Resumed和Started状态时的调用中体现。
二、 onDestory()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0e51699be0741ebc6e0cb72487c4807a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-23T16:38:10+08:00" />
<meta property="article:modified_time" content="2015-05-23T16:38:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Andorid学习【基础篇】Android应用程序生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    <span style="white-space:pre"></span>与C++和Java不同的是，表面上Android应用程序并没有从main()函数启动，而是通过一系列的回调方法，方法响应用户的具体操作而被调用，使Andorid应用程序能切换到对应的状态，例如开启应用后，程序开始载入画面；用户操作，进入其他的页面；用户接电话、收发短信时，程序被暂停运行；用户想要暂时离开应用，回到桌面上打开其他应用等等，Andorid程序中的回调方法将会在相应的用户操作后执行，执行完毕之后，使得整个应用到达某一个状态，应用在每一种状态之间的切换，便构成了Android应用程序的生命周期。</p> 
<p><span style="color:#ff0000">    <span style="white-space:pre"></span>也可以这样简单地理解Android应用程序生命周期：用户操作驱动相应的回调方法，相应的回调方法被执行后，使得状态在切换，状态的切换便构成了生命周期。</span></p> 
<p><span style="color:#ff0000">    <span style="white-space:pre"></span></span>在Android的生命周期，有如下6个状态，分别是：<strong>Created，Started，Resumed，Paused，Stopped，Destroyed。</strong>相应的，有如下7个回调方法，使得Activity在不同的状态间切换，分别是：<strong>onCreate()，onStart()， onResume()，onPause()， onStop()，onRestart()，onDestroy()</strong>。当然这些方法只有在相应的用户操作或者状态发生之后才会被调用，在大多数情况下，我们可能根据需要，重载一部分回调方法，使得应用能如用户那样期待的正常运行。关于生命周期的流动方式，android官方教程给出的“金字塔式”图很直观地说明了问题：</p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/17/e9/M2L9bbHm_o.png" alt=""><br> </p> 
<p style="text-align:left">  一、 onCreate()</p> 
<p style="text-align:left"><span style="white-space:pre"></span> 在启动应用后，首先调用onCreate()方法，该方法在整个应用的生命周期中只会被调用一次，主要完成应用的一些初始化工作，例如layout的载入，按钮、文本等等一些UI组件的初始化，或者是一些变量的初始化，因此如果要在启动时完成需要的初始化工作，只要重载该方法即可。</p> 
<p style="text-align:left">      <span style="white-space:pre"></span>当应用开启时，系统将会根据在AndroidManifest.xml中指定的启动类，以该启动类作为入口进入程序，而onCreate以及其他6个回调方法都必须在该类中重载，其中，指定启动类，也就是我们的主类的写法，例如我们指定MainActivity.class作为主类，那么在AndroidManifest.xml中指定形式如下：</p> 
<p style="text-align:left"></p> 
<pre><code class="language-java">&lt;activity android:name=".MainActivity" android:label="@string/app_name"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre> 
<p>       <span style="white-space:pre"> </span>一般来说，在onCreate()方法中，主要的目的是为该Activity创建一个实例，一般要做的事情有如下几件：<br> 1. 调用父类onCreate()方法，载入上次保存的实例</p> 
<p>2. 载入用户界面，一般来说是main_activity.xml</p> 
<p>3. 定义或者调用一些用户自己定义的初始化方法</p> 
<p>4. 为layout_main.xml中的UI控件分配相应变量，使得之后可以对其进行操作和管理</p> 
<p>一个简单的例子如下：</p> 
<p></p> 
<pre><code class="language-java">TextView mTextView; // UI控件变量
private void userMethod() {
    // Codes goes here
}


@Override
public void onCreate(Bundle savedInstanceState) {
    // 调用父类onCreate()方法，载入上次保存的实例
    super.onCreate(savedInstanceState);

    // 调用用户自定义的方法

    // 载入用户界面
    setContentView(R.layout.main_activity);
    
    // 初始化UI控件变量
    mTextView = (TextView) findViewById(R.id.text_message);
}</code></pre>      
<span style="white-space:pre"></span>其中，载入上次保存的实例savedInstanceState这一操作，将会在后面的博客文章中关于重新创建Activity的文章中，进行深入的学习。 
<br> 
<p></p> 
<p style="text-align:left">      <span style="white-space:pre"></span>当应用完成onCreate()的调用之后，到达Created状态，紧接着，系统将会立即调用onStart()和onResume()方法，使应用到达在前台显示出来(visible)，如果严格地说，在Started状态时应用已经在前台显示出来，但和Created状态一样，Started状态也是一个暂态，用户界面不会作任何停留，就会进入到Resumed状态，该状态便是应用稳定显示在前台时所处的状态，直到用户打算暂停、停止或者销毁应用时，onPause()，onStop()，onDestroy()方法将会被调用，将Activity带入金字塔的下层状态Paused，Stopped，Destroyed状态中，而且每一次回调方法的调用只会使状态改变一次，或者说只在金字塔上移动一层。关于onStart()和onResume()在一个应用中的重要意义和更多重载建议，将在下面Paused和Stopped状态返回Resumed和Started状态时的调用中体现。</p> 
<p style="text-align:left">二、 onDestory()</p> 
<p style="text-align:left"><span style="white-space:pre"></span>生命周期的最终状态为Destroyed销毁状态，一般来说，是指用户完全停止Activity时候的状态，此时应用的所用实例将会随之被销毁，而且很多的回收已经随着onPause()和onStop()的调用完成，因此，在大多数情况下，onDestroy()方法是不用重载的。但是如果在onCreate()中或者其他地方启动过后台线程，那么onDestroy()方法应该按如下方式重载：</p> 
<p style="text-align:left"></p> 
<pre><code class="language-java">@Override
public void onDestroy() {
    super.onDestroy();  // Always call the superclass
    
    // Stop method tracing that the activity started during onCreate()
    android.os.Debug.stopMethodTracing();
}</code></pre> 
<p> <span style="white-space:pre"> </span>onDestroy()除了上述经过onPause()，onStop()的调用途径之外，还可以通过调用系统方法finish()的途径，最常见的一个例子就是在用户点击Android设备上的返回按钮时，退出应用，此时需要重写方法onKeyDown()，用以监听点击事件，例如：</p> 
<p></p> 
<pre><code class="language-java">@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        finish();
    } 
    return false;
}
</code></pre> 
<br> 
<p>三、 关于三个稳定状态Resume，Paused，Stopped的说明</p> 
<p>1. Resume</p> 
<p><span style="white-space:pre"></span>当应用处于该状态时，一直处于前台运行状态，用户可以与其进行交互，用更一般的说法是，此时应用正在run</p> 
<p>2. Paused</p> 
<p><span style="white-space:pre"></span>当应用处于该状态时，一般是指现在的Activity被一个新的Activity以半透明或者半覆盖的方式遮挡，此时现在的Activity不会响应用户的输入，且任何代码都不会被执行</p> 
<p>3. Stopped</p> 
<p>      <span style="white-space:pre"> </span>当应用处于该状态时，一般是指现在的Activity被完全隐藏，或者对用户完全不可见，此时的Activity是在后台运行的，activity instance和状态信息，如变量等等会被保存，但是不会执行</p> 
<p><br> </p> 
<p>四、 几点建议</p> 
<p> <span style="white-space:pre"> </span>Google为了写出良好的生命周期管理给出了几点指导建议：</p> 
<p>1. 接电话、切换到其他Activity时，原Activity不能销毁</p> 
<p>2. 当Activity没有活跃时，应使其占用资源最少，不能耗尽系统资源</p> 
<p>3. 当用户离开一段时间内，不要丢失用户的操作状态</p> 
<p>4. 当屏幕进行横向/纵向切换时，不要丢失用户操作状态</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68c58028f69753461fdbfce0464a837d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java写的 echo 和 linux系统自带的 echo 效率差别很大！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd7f3f53335c876433b6539910d45c83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL查询重复记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>