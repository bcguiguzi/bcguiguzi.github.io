<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序之选择排序 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序之选择排序" />
<meta property="og:description" content=" 思想：首先找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置（如果第一个元素就是最小，那它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序这种方法叫选择排序，因为它在不断地选择剩余元素之中的最小着。 注意：对于长度为N的数组，选择排序大约需要（N^ 2）／2次比较和N次交换 特点： 1.运行时间和输入无关。 为了找出最小的元素而扫描一遍数组并不能为了下一遍扫描提供什么信息，这种性质在某种程度上来说是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或者主键全部相等的数组和一个元素随机排列的数组所用的时间是一样的长！ 2.数据移动是最少的。 每次交换都会改变两个数组元素的值，因此选择排序用了N次交换－－交换次数和数组的大小是线性的关系。（其他任何算法都不具有这个特征，大部分的增长是线性对数或是平方级的） java代码实现： /** * 选择排序 */ private void selectSort(int[] list) { // 需要遍历获得最小值的次数 // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列 for (int i = 0; i &lt; list.length - 1; i&#43;&#43;) { int temp = 0; int index = i; // 用来保存最小值得索引 // 寻找第i个小的数值 for (int j = i &#43; 1; j &lt; list.length; j&#43;&#43;) { if (list[index] &gt; list[j]) { index = j; } } // 将找到的第i个小的数值放在第i个位置上 temp = list[index]; list[index] = list[i]; list[i] = temp; } } " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d45db483c3e5859a15bba19a391e7e66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-17T14:47:27+08:00" />
<meta property="article:modified_time" content="2017-01-17T14:47:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序之选择排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="white-space:pre-wrap; text-indent:56px; line-height:1.5; font-size:14px"> 
 <h5>思想：首先找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置（如果第一个元素就是最小，那它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序这种方法叫<span style="color:#FF0000">选择排序</span>，因为它在不断地选择剩余元素之中的最小着。</h5> 
 <span style="color:#FF0000"><strong>注意：对于长度为N的数组，选择排序大约需要（N^ 2）／2次比较和N次交换</strong></span> 
 <br> 特点： 
 <br>   1.运行时间和输入无关。 
 <br> 为了找出最小的元素而扫描一遍数组并不能为了下一遍扫描提供什么信息，这种性质在某种程度上来说是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或者主键全部相等的数组和一个元素随机排列的数组所用的时间是一样的长！ 
 <br> 2.数据移动是最少的。 
 <br> 每次交换都会改变两个数组元素的值，因此选择排序用了N次交换－－交换次数和数组的大小是线性的关系。（其他任何算法都不具有这个特征，大部分的增长是线性对数或是平方级的） 
 <br> 
 <br> java代码实现： 
 <br> 
 <pre style="background-color:#2b2b2b; color:#a9b7c6; font-family:'Menlo'; font-size:9.0pt"><span style="color:#629755; font-style:italic">/**
</span><span style="color:#629755; font-style:italic"> * 选择排序
</span><span style="color:#629755; font-style:italic"> */
</span><span style="color:#cc7832">private void </span><span style="color:#ffc66d">selectSort</span>(<span style="color:#cc7832">int</span>[] list) {
    <span style="color:#808080">// 需要遍历获得最小值的次数
</span><span style="color:#808080">    // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列
</span><span style="color:#808080">    </span><span style="color:#cc7832">for </span>(<span style="color:#cc7832">int </span>i = <span style="color:#6897bb">0</span><span style="color:#cc7832">; </span>i &lt; list.<span style="color:#9876aa">length </span>- <span style="color:#6897bb">1</span><span style="color:#cc7832">; </span>i++) {
        <span style="color:#cc7832">int </span>temp = <span style="color:#6897bb">0</span><span style="color:#cc7832">;
</span><span style="color:#cc7832">        int </span>index = i<span style="color:#cc7832">; </span><span style="color:#808080">// 用来保存最小值得索引
</span><span style="color:#808080">
</span><span style="color:#808080">        // 寻找第i个小的数值
</span><span style="color:#808080">        </span><span style="color:#cc7832">for </span>(<span style="color:#cc7832">int </span>j = i + <span style="color:#6897bb">1</span><span style="color:#cc7832">; </span>j &lt; list.<span style="color:#9876aa">length</span><span style="color:#cc7832">; </span>j++) {
            <span style="color:#cc7832">if </span>(list[index] &gt; list[j]) {
                index = j<span style="color:#cc7832">;
</span><span style="color:#cc7832">            </span>}
        }

        <span style="color:#808080">// 将找到的第i个小的数值放在第i个位置上
</span><span style="color:#808080">        </span>temp = list[index]<span style="color:#cc7832">;
</span><span style="color:#cc7832">        </span>list[index] = list[i]<span style="color:#cc7832">;
</span><span style="color:#cc7832">        </span>list[i] = temp<span style="color:#cc7832">;
</span><span style="color:#cc7832">    </span>}
}</pre> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e2e79905662bdbbc0320700307d490b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hololens官方教程精简版 - 07. Spatial mapping（空间映射）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99a09db1a397bedd0afe7d67728e4b87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git报错：RPC failed; curl 18 transfer closed with outstanding read data remaining</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>