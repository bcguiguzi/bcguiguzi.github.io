<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用GDB&#43;QEMU调试Cosmos内核代码 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用GDB&#43;QEMU调试Cosmos内核代码" />
<meta property="og:description" content="1. 生成带调试符号的elf文件 修改编译选项： GCC 的-O2参数要修改成O0 -g参数：-O0是告诉 GCC 编译器，在编译时不要对代码做优化，这么做可以避免在 GDB 调试时源码和实际程序对应不上的问题；-g参数是为了告诉编译器带上调试符号。
使用grep命令查找需要修改的文件，使用sed命令批量替换，命令如下：
grep -i &#39;\-o2&#39; -r //-i 代表不区分大小写 sed -i &#39;s/-O2/-O0 -g/&#39; ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S sed -i &#39;s/-Os/-O0 -g/&#39; ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S 去掉 ld 的-s参数：-s是告诉 ld 程序链接时去掉所有符号信息，其中包括了调试符号。
grep &#39;\-s &#39; -r 使用 sed 命令批量去掉 ld 的-s参数，命令如下：
sed -i &#39;s/-s / /g&#39; ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S 编译生成“带调试符号的 elf 文件&#34; 执行make就可以编译出带有调试符号的 elf 文件，如下图：这里的“not stripped”就表示文件带有调试符号。
Cosmos.elf：当需要调试“内核代码”时，可以在 GDB 中执行symbol-file ./build/Cosmos.elf加载调试符号initldrkrl.elf：当需要调试“二级加载器代码”时，可以在 GDB 中执行symbol-file ./initldr/build/initldrkrl.elf加载调试符号。 制作 hd.img, 用于QEMU运行Cosmos内核 打包生成内核映像文件Cosmos.eki
将要打包的文件copy到同一个文件夹下，执行下列命令：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1a13e4f1693ffa6cf5c2fb89f7459634/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-07T17:02:34+08:00" />
<meta property="article:modified_time" content="2022-08-07T17:02:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用GDB&#43;QEMU调试Cosmos内核代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1_elf_1"></a>1. 生成带调试符号的elf文件</h4> 
<h5><a id="_2"></a>修改编译选项：</h5> 
<ol><li> <p>GCC 的-O2参数要修改成O0 -g参数：-O0是告诉 GCC 编译器，在编译时不要对代码做优化，这么做可以避免在 GDB 调试时源码和实际程序对应不上的问题；-g参数是为了告诉编译器带上调试符号。</p> <p><strong>使用grep命令查找需要修改的文件，使用sed命令批量替换，命令如下：</strong></p> <pre><code class="prism language-bash"><span class="token function">grep</span> -i <span class="token string">'\-o2'</span> -r  //-i 代表不区分大小写
</code></pre> <p><img src="https://images2.imgbox.com/6d/12/svXiqbaq_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-bash">   <span class="token function">sed</span> -i <span class="token string">'s/-O2/-O0 -g/'</span> ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S
   <span class="token function">sed</span> -i <span class="token string">'s/-Os/-O0 -g/'</span> ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S 
</code></pre> <p><img src="https://images2.imgbox.com/19/68/63eZDOsg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>去掉 ld 的-s参数：-s是告诉 ld 程序链接时去掉所有符号信息，其中包括了调试符号。</p> <pre><code class="prism language-bash"><span class="token function">grep</span> <span class="token string">'\-s '</span> -r
</code></pre> <p><img src="https://images2.imgbox.com/90/82/xphKtDoi_o.png" alt="在这里插入图片描述"></p> <p><strong>使用 sed 命令批量去掉 ld 的-s参数，命令如下：</strong></p> <pre><code class="prism language-bash"> <span class="token function">sed</span> -i <span class="token string">'s/-s / /g'</span> ./initldr/build/krnlbuidcmd.mh ./script/krnlbuidcmd.S
</code></pre> <p><img src="https://images2.imgbox.com/23/e3/TMjUTrcf_o.png" alt=""></p> </li></ol> 
<h5><a id="_elf__33"></a>编译生成“带调试符号的 elf 文件"</h5> 
<p>执行make就可以编译出带有调试符号的 elf 文件，如下图：这里的“not stripped”就表示文件带有调试符号。<br> <img src="https://images2.imgbox.com/6c/83/Jqm07O9T_o.png" alt=" "></p> 
<ol><li>Cosmos.elf：当需要调试“<strong>内核代码</strong>”时，可以在 GDB 中执行symbol-file ./build/Cosmos.elf加载调试符号</li><li>initldrkrl.elf：当需要调试“<strong>二级加载器代码</strong>”时，可以在 GDB 中执行symbol-file ./initldr/build/initldrkrl.elf加载调试符号。</li></ol> 
<h5><a id="_hdimg_QEMUCosmos_40"></a>制作 hd.img, 用于QEMU运行Cosmos内核</h5> 
<ol><li> <p>打包生成内核映像文件Cosmos.eki<br> 将要打包的文件copy到同一个文件夹下，执行下列命令：</p> <pre><code class="prism language-bash">./lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrkrl.bin initldrsve.bin Cosmos.bin background.bmp font.fnt logo.bmp 
</code></pre> <p><img src="https://images2.imgbox.com/a5/d9/Qy0oImHB_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如果已有 hd.img，则需要先将其挂载到临时文件，然后替换新生成的Cosmos.eki</p> <pre><code class="prism language-bash">    <span class="token builtin class-name">cd</span> <span class="token function">mount</span> hd.img /tmp/
    <span class="token function">cp</span> Cosmos.eki /tmp/boot/
    <span class="token function">umount</span> /tmp/
</code></pre> </li><li> <p>第一次生成hd.img需要按如下命令制作</p> <p>使用dd命令生成100MB的纯二进制文件，也就是我们要用到的虚拟硬盘文件hd.img：</p> <pre><code class="prism language-bash"><span class="token function">dd</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>hd.img <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">204800</span>

<span class="token punctuation">;</span>bs:表示块大小，这里是512字节 
<span class="token punctuation">;</span>if：表示输入文件，/dev/zero就是Linux下专门返回0数据的设备文件，读取它就返回0 <span class="token punctuation">;</span>
of：表示输出文件，即我们的硬盘文件。 <span class="token punctuation">;</span>
count：表示输出多少块
</code></pre> <p>格式化虚拟硬盘并挂载到本地目录下：</p> <pre><code class="prism language-bash"><span class="token function">sudo</span> losetup /dev/loop0 hd.img // losetup命令将hd.img变成Linux的回环设备
<span class="token function">sudo</span> mkfs.ext4 -q /dev/loop0  // mkfs.ext4格式化为ext4格式的文件系统
<span class="token function">sudo</span> <span class="token function">mount</span> -o loop ./hd.img ./hdisk/   //将hd.img当做块设备挂载到硬盘文件中
<span class="token function">sudo</span> <span class="token function">mkdir</span> ./hdisk/boot/   //建立boot目录
</code></pre> <p>如果提示回环设备忙，则使用losetup -f查找第一个空闲的设备，替换即可：<br> <img src="https://images2.imgbox.com/3d/3b/Flu96taa_o.png" alt="在这里插入图片描述"></p> <p>安装GRUB：</p> <pre><code class="prism language-bash"><span class="token function">sudo</span> grub-install --boot-directory<span class="token operator">=</span>./hdisk/boot/ --force --allow-floppy /dev/loop0 
</code></pre> <p>这时看到boot目录下多了一个grub目录，说明grub安装成功。</p> <p>创建grub.cfg文件：</p> <pre><code class="prism language-bat">set timeout=2

menuentry 'Cosmos' {
insmod part_msdos
insmod ext2
set root='hd0' #我们的硬盘只有一个分区所以是'hd0'
multiboot2 /boot/Cosmos.eki #加载boot目录下的Cosmos.eki文件
boot #引导启动
}
set timeout_style=menu
if [ "${timeout}" = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi

</code></pre> <p>将Cosmos.eki文件放置到boot目录下，解除挂载</p> <pre><code class="prism language-bash"><span class="token function">cp</span> Cosmos.eki /tmp/boot/
<span class="token function">umount</span> /hdisk/
</code></pre> </li><li> <p>如果要在virtualbox中启动，则需要转换成hd.vdi格式，命令如下：</p> <pre><code class="prism language-bash">VBoxManage convertfromraw ./hd.img --format VDI ./hd.vdi
</code></pre> </li></ol> 
<h4><a id="2_qemu_120"></a>2. qemu启动内核</h4> 
<pre><code>qemu-system-x86_64 -drive format=raw,file=hd.img -m 512M -cpu kvm64,smep,smap -s    // 一定要加-s参数，此参数可以打开调试服务。
</code></pre> 
<h4><a id="3_GDB_125"></a>3. 使用GDB加载调试符号</h4> 
<p><img src="https://images2.imgbox.com/8f/57/FYN5tZb4_o.png" alt="在这里插入图片描述"></p> 
<pre><code>(gdb) symbol-file ./initldr/build/initldrkrl.elf  // 加载调试符号，这样才能在显示源码、可以用函数名下断点
Reading symbols from ./initldr/build/initldrkrl.elf...  //连接qemu-system-x86_64 -s选项打开的1234端口进行调试
</code></pre> 
<h4><a id="4__133"></a>4. 启动调试</h4> 
<pre><code class="prism language-gdb"> (gdb) target remote :1234   // 连接qemu-system-x86_64 -s选项打开的1234端口进行调试  
 Remote debugging using :1234  
0x0000000000200040 in _32bits_mode ()
</code></pre> 
<h4><a id="5_GDB_140"></a>5. 设置断点，使用GDB命令调试</h4> 
<p><img src="https://images2.imgbox.com/3c/2d/igVCblOf_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">  root<span class="token comment"># od -tx4 ./initldr/build/Cosmos.eki | head -3</span>
  0000000 909066eb 1badb002 00010003 e4514ffb
  0000020 04000004 04000000 00000000 00000000
  0000040 04000068 <span class="token number">90909090</span> e85250d6 00000000
</code></pre> 
<p>根据GRUB 头结构，结合上面的 Cosmos.eki 文件头信息，我们很容易就能知道，_start符号地址是0x04000000,_entry符号地址是0x04000068。我们在这两个地址设置断点，通过 GDB 可以看到，程序不是在0x04000000断点暂停，而是直接在0x04000068 断点暂停，说明grub启动后会加载cosmos.eki 到0x04000000位置，但执行的第一条指令不是 _start 符号位置而是 _entry 符号位置。到 _entry 时，cr0 的 pe=1，表明此时保护模式已经打开了。</p> 
<p>而在断点处执行的正是 _entry处的代码： ./initldr/ldrkrl/imginithead.asm<br> <img src="https://images2.imgbox.com/e8/8b/kaKWiNO9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_158"></a>参考手册：</h4> 
<p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html" rel="nofollow">100个gdb小技巧</a></p> 
<p><a href="https://www.mankier.com/1/qemu" rel="nofollow">QEMU User Documentation</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2573b52bd9251f520f3d943538f18af7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[暑假] 解决:后端swagger可以正常得到数据,前端接口正确,但是没有得到数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5844f08040c8488a0aeb2888585c35fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pt-archive使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>