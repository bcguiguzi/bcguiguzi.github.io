<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Es6-Es13使用方法及特性（万字超详细） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Es6-Es13使用方法及特性（万字超详细）" />
<meta property="og:description" content="目录
ES6
let
const
解构赋值
模板字符串
字符串与数值的扩展
数组的扩展
对象的扩展
函数的扩展
Symbol 类型
iterator 迭代器
Set数据结构
Map数据结构
Proxy代理
Reflect反射
Promise对象
Generator生成器函数
class语法
class继承
ES7
求幂运算符
数组的includes方法
ES8
async和await
对象方法扩展
字符串填充
ES9
rest与扩展运算符
正则命名捕获分组
Promise.finally
异步迭代
ES10
Object.fromEntries
trimStart和trimEnd
flat()和flatMap() symbol.description ES11
Promise.allSettled
Module新增
字符串的matchAll方法
bigint （大整数）类型
globalThis 顶层对象
空值合并运算符 ??
可选链操作符 ?.
ES12
新增逻辑操作符
字符串的replaceAll 方法
Promise.any
WeakRef
ES13
类新增特性
顶层 await at函数
findLast 和 findLastIndex
catch捕获错误添加原因
ES6 let // 块级作用域 // 不允许重复声明 // 没有变量提升 // 暂存性死区 let name = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e299a49a26bd60d45add8863d312c070/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-22T09:00:02+08:00" />
<meta property="article:modified_time" content="2023-03-22T09:00:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Es6-Es13使用方法及特性（万字超详细）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0ES6-toc" style="margin-left:0px;"><a href="#%C2%A0ES6" rel="nofollow"> ES6</a></p> 
<p id="let-toc" style="margin-left:80px;"><a href="#let" rel="nofollow">let</a></p> 
<p id="const-toc" style="margin-left:80px;"><a href="#const" rel="nofollow">const</a></p> 
<p id="%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" rel="nofollow">解构赋值</a></p> 
<p id="%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">模板字符串</a></p> 
<p id="%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95" rel="nofollow"> 字符串与数值的扩展</a></p> 
<p id="%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95" rel="nofollow">数组的扩展</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95" rel="nofollow">对象的扩展</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95" rel="nofollow">函数的扩展</a></p> 
<p id="Symbol%20%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#Symbol%20%E7%B1%BB%E5%9E%8B" rel="nofollow">Symbol 类型</a></p> 
<p id="iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">iterator 迭代器</a></p> 
<p id="Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">Set数据结构</a></p> 
<p id="Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">Map数据结构</a></p> 
<p id="Proxy%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#Proxy%E4%BB%A3%E7%90%86" rel="nofollow">Proxy代理</a></p> 
<p id="Reflect%E5%8F%8D%E5%B0%84-toc" style="margin-left:80px;"><a href="#Reflect%E5%8F%8D%E5%B0%84" rel="nofollow">Reflect反射</a></p> 
<p id="Promise%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#Promise%E5%AF%B9%E8%B1%A1" rel="nofollow">Promise对象</a></p> 
<p id="Generator%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#Generator%E5%87%BD%E6%95%B0" rel="nofollow">Generator生成器函数</a></p> 
<p id="class%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#class%E8%AF%AD%E6%B3%95" rel="nofollow">class语法</a></p> 
<p id="class%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#class%E7%BB%A7%E6%89%BF" rel="nofollow">class继承</a></p> 
<p id="ES7%E5%86%85%E5%AE%B9-toc" style="margin-left:0px;"><a href="#ES7%E5%86%85%E5%AE%B9" rel="nofollow">ES7</a></p> 
<p id="%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">求幂运算符</a></p> 
<p id="%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84includes%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84includes%E6%96%B9%E6%B3%95" rel="nofollow"> 数组的includes方法</a></p> 
<p id="ES8-toc" style="margin-left:0px;"><a href="#ES8" rel="nofollow">ES8</a></p> 
<p id="async%E5%92%8Cawait-toc" style="margin-left:80px;"><a href="#async%E5%92%8Cawait" rel="nofollow">async和await</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95" rel="nofollow">对象方法扩展</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85" rel="nofollow">字符串填充</a></p> 
<p id="ES9%E5%86%85%E5%AE%B9-toc" style="margin-left:0px;"><a href="#ES9%E5%86%85%E5%AE%B9" rel="nofollow">ES9</a></p> 
<p id="rest%E4%B8%8E%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#rest%E4%B8%8E%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">rest与扩展运算符</a></p> 
<p id="%E6%AD%A3%E5%88%99%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E6%AD%A3%E5%88%99%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84" rel="nofollow">正则命名捕获分组</a></p> 
<p id="Promise.finally-toc" style="margin-left:80px;"><a href="#Promise.finally" rel="nofollow">Promise.finally</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3-toc" style="margin-left:80px;"><a href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3" rel="nofollow">异步迭代</a></p> 
<p id="ES10%E5%86%85%E5%AE%B9-toc" style="margin-left:0px;"><a href="#ES10%E5%86%85%E5%AE%B9" rel="nofollow">ES10</a></p> 
<p id="Object.fromEntries-toc" style="margin-left:80px;"><a href="#Object.fromEntries" rel="nofollow">Object.fromEntries</a></p> 
<p id="%C2%A0trimStart%E5%92%8CtrimEnd-toc" style="margin-left:80px;"><a href="#%C2%A0trimStart%E5%92%8CtrimEnd" rel="nofollow"> trimStart和trimEnd</a></p> 
<p id="flat()%E5%92%8CflatMap()%C2%A0-toc" style="margin-left:80px;"><a href="#flat%28%29%E5%92%8CflatMap%28%29%C2%A0" rel="nofollow">flat()和flatMap() </a></p> 
<p id="%C2%A0symbol.description%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0symbol.description%C2%A0" rel="nofollow"> symbol.description </a></p> 
<p id="ES11-toc" style="margin-left:0px;"><a href="#ES11" rel="nofollow">ES11</a></p> 
<p id="Promise.allSettled-toc" style="margin-left:80px;"><a href="#Promise.allSettled" rel="nofollow">Promise.allSettled</a></p> 
<p id="Module%E6%96%B0%E5%A2%9E-toc" style="margin-left:80px;"><a href="#Module%E6%96%B0%E5%A2%9E" rel="nofollow">Module新增</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84matchAll%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84matchAll%E6%96%B9%E6%B3%95" rel="nofollow">字符串的matchAll方法</a></p> 
<p id="bigint%20%EF%BC%88%E5%A4%A7%E6%95%B4%E6%95%B0%EF%BC%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#bigint%20%EF%BC%88%E5%A4%A7%E6%95%B4%E6%95%B0%EF%BC%89%E7%B1%BB%E5%9E%8B" rel="nofollow">bigint （大整数）类型</a></p> 
<p id="globalThis%20%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#globalThis%20%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1" rel="nofollow">globalThis 顶层对象</a></p> 
<p id="%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%20%3F%3F-toc" style="margin-left:80px;"><a href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%20%3F%3F" rel="nofollow">空值合并运算符 ??</a></p> 
<p id="%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3F.-toc" style="margin-left:80px;"><a href="#%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3F." rel="nofollow">可选链操作符 ?.</a></p> 
<p id="ES12-toc" style="margin-left:0px;"><a href="#ES12" rel="nofollow">ES12</a></p> 
<p id="%E6%96%B0%E5%A2%9E%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E6%96%B0%E5%A2%9E%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">新增逻辑操作符</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84replaceAll%20%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84replaceAll%20%E6%96%B9%E6%B3%95" rel="nofollow">字符串的replaceAll 方法</a></p> 
<p id="Promise.any-toc" style="margin-left:80px;"><a href="#Promise.any" rel="nofollow">Promise.any</a></p> 
<p id="WeakRef-toc" style="margin-left:80px;"><a href="#WeakRef" rel="nofollow">WeakRef</a></p> 
<p id="ES13-toc" style="margin-left:0px;"><a href="#ES13" rel="nofollow">ES13</a></p> 
<p id="%E7%B1%BB%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7" rel="nofollow">类新增特性</a></p> 
<p id="%E9%A1%B6%E5%B1%82%20await%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%A1%B6%E5%B1%82%20await%C2%A0" rel="nofollow">顶层 await </a></p> 
<p id="at%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#at%E5%87%BD%E6%95%B0" rel="nofollow">at函数</a></p> 
<p id="findLast%20%E5%92%8C%20findLastIndex-toc" style="margin-left:80px;"><a href="#findLast%20%E5%92%8C%20findLastIndex" rel="nofollow">findLast 和 findLastIndex</a></p> 
<p id="catch%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%9B%A0-toc" style="margin-left:80px;"><a href="#catch%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%9B%A0" rel="nofollow">catch捕获错误添加原因</a></p> 
<hr> 
<p></p> 
<h2 id="%C2%A0ES6" style="text-align:center;"><span style="color:#0d0016;"> ES6</span></h2> 
<h4 id="let" style="text-align:center;"><span style="color:#fe2c24;">let</span></h4> 
<pre><code>      // 块级作用域
      // 不允许重复声明
      // 没有变量提升

      // 暂存性死区
      let name = "纳西妲";
      function fn() {
        console.log(name);
        let name =
          "局部作用域里调用之后再用let声明变量，就会出现暂存性死区，会报错";
      }
      fn();

      // 不与顶层对象挂钩
      var names = "挂载在window上";
      console.log(window.names); // 挂载在window上

      let notMsg = "不关联";
      console.log(window.notMsg); // undefined</code></pre> 
<h4 id="const" style="text-align:center;"><span style="color:#fe2c24;">const</span></h4> 
<pre><code>      // 常量
      // 不能重复定义
      // 有块级特性
      // 也有暂存性死区特点
      // 也不与顶层对象挂钩
      const name = 1;

      // 当一个常量为复杂数据类型，是可以改变其属性的
      const obj = Object.freeze({
        name: "张三",
        age: 18,
        child: {
          name: "冻不住",
        },
      });
      // 可以使用冻结方法，让常量不可更改（只能冻住一层）</code></pre> 
<h4 id="%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" style="text-align:center;"><span style="color:#fe2c24;">解构赋值</span></h4> 
<pre><code>      // 数组解构
      let arr = [1, 2, 3];
      let [a, b, c] = arr; // 1,2,3
      let [d, [e, f], g] = [1, [2, 3], 5]; // 1,2,3,5
      let [x = 999] = []; // 999
      let [y = 999] = [666]; // 666
      console.log(y);

      // 对象解构
      const obj = {
        name: "张三",
        age: 18,
        child: { list: [6, 7, 8] },
      };

      let {
        name,
        age,
        child: { list },
      } = obj;
      console.log(name, age, list);

      // 字符串解构
      let { length } = "nan";
      console.log(length); // 3</code></pre> 
<h4 id="%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" style="text-align:center;"><span style="color:#fe2c24;">模板字符串</span></h4> 
<pre><code>// ${} 大括号里面可以放表达式或变量作为字符串</code></pre> 
<h4 id="%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95" style="text-align:center;"><span style="color:#fe2c24;"> 字符串与数值的扩展</span></h4> 
<pre><code>      let myName = "jack";
      myName.includes("a", 1); // true 判断字符串是否包含某个字符

      myName.startsWith("j", 0); // true 以...开始

      myName.endsWith("j", 1); // true 以...结尾

      myName.repeat(3); // jackjackjack 重复三次

      Number.isFinite("100"); // false 判断数字是否合法，没有隐式转换

      Number.isNaN(NaN); // true 判断数字是否是NaN

      Number.isInteger(100.0); // true 判断数字是否是整数

      // Number.EPSILON 极小常量,可以定义一个函数，判断两个值是否相等
      function isEqual(x, y) {
        return Math.abs(x - y) &lt; Number.EPSILON;
      }
      console.log(isEqual(0.1 + 0.2, 0.3)); // true

      // 直接舍弃小数
      Math.trunc(1.8); // 1
      Math.trunc(-1.8); // -1

      // 判断一个数是正数、负数还是零，存在隐式转换
      Math.sign(-100); // -1
      Math.sign(+100); // 1
      Math.sign(-0); // -0
      Math.sign(+0); // 0
      Math.sign("haha"); // NaN</code></pre> 
<h4 id="%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95" style="text-align:center;"><span style="color:#fe2c24;">数组的扩展</span></h4> 
<pre><code>      // 扩展运算符 ...
      let arr1 = [1, 2, 3];
      let arr2 = [1, 2, 3];
      let newArr = [...arr1, ...arr2]; // [1, 2, 3, 1, 2, 3]

      // 将类数组结构转换成数组 Array.from()
      function fn() {
        Array.from(new Set(arguments)); // [1, 2, 3, 4, 5]
      }
      fn(1, 2, 3, 4, 4, 5, 5);

      // 创建数组 Array.of()
      let arr3 = Array(3); // [空属性 × 3] 原始方法创建数组的弊端
      let arr4 = Array.of(4); // [4]

      // 从前向后查找数组元素 find findIndex()
      // 从后向前查找数组元素 findLast findLastIndex() =&gt;Es13
      let arr = [111, 222, 333];
      let res = arr.find((item) =&gt; {
        return item &gt; 111;
      });
      console.log(res); // 222

      // 填充元素 fill()
      let emptyArr = [1, 2, 3];
      emptyArr.fill("替换元素", 0, 1); // ['替换元素', 2, 3]</code></pre> 
<h4 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95" style="text-align:center;"><span style="color:#fe2c24;">对象的扩展</span></h4> 
<pre><code>      // 对象简写
      let name = "moudleA";
      let obj = {
        name,
        [name + "fn1"]: "方法1",
        [name + "fn2"]: "方法2",
      };
      // {name: 'moudleA', moudleAfn1: '方法1', moudleAfn2: '方法2'}

      let obj1 = {
        name: "haha",
      };

      let obj2 = {
        age: "lala",
      };

      // 对象的合并 es6
      Object.assign(obj1, obj2); // {name: 'haha', age: 'lala'} 第一个参数的原对象会被影响
      // 对象的合并 es9
      console.log({ ...obj1, ...obj2 }); // {name: 'haha', age: 'lala'} 原对象不会被影响

      // Object.is() 与 === 不同点

      // 1.可以判断NaN和自身的相等
      NaN === NaN; // false
      Object.is(parseInt("name"), NaN); // true

      // 2.可以判断+0和-0的不相等
      +0 === -0; // true
      Object.is(+0, -0); // false</code></pre> 
<h4 id="%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95" style="text-align:center;"><span style="color:#fe2c24;">函数的扩展</span></h4> 
<pre><code>      // 参数默认值
      function name(a = 1, b) {}

      // rest参数 剩余参数
      function fn(a, ...params) {
        console.log(a); // 1
        console.log(...params); // 2,3,4,5
      }
      fn(1, 2, 3, 4, 5);

      // 箭头函数
      // 1. 只有一行代码可以简写
      let arr = ["a", "b", "c"];
      let newArr = arr.map((item) =&gt; `&lt;li&gt;${item}&lt;li/&gt;`); // ['&lt;li&gt;a&lt;li/&gt;', '&lt;li&gt;b&lt;li/&gt;',                 
      '&lt;li&gt;c&lt;li/&gt;']

      // 2.如果返回的是一个对象(大括号外面套一层小括号)
      let objFun = () =&gt; ({ name: "haha", age: 10 }); // {name: 'haha', age: 10}

      // 无法访问arguments，无法new
      // 箭头函数本身没有this,它的this指向箭头函数的外部作用域</code></pre> 
<h4 id="Symbol%20%E7%B1%BB%E5%9E%8B" style="text-align:center;"><span style="color:#fe2c24;">Symbol 类型</span></h4> 
<pre><code>      // 定义一个Symbol类型的变量
      let s1 = Symbol();

      // 不能进行运算
      // 有隐式转换
      if (s1) {
        console.log(111); // 111
      }

      // 定义Symbol类型的变量时，最好放在一起使用，代码简洁易懂
      let keys = {
        name: Symbol("name"),
        age: Symbol("age"),
      };
      let obj = {
        [keys.name]: "不使用钥匙是拿不到值的",
        [keys.age]: 18,
      };
      // {Symbol(name): '不使用钥匙是拿不到值的', Symbol(age): 18}

      // for in 无法遍历Symbol类型

      // Reflect.ownKeys() 可以拿到对象所有的属性(包括Symbol类型的属性)
      Reflect.ownKeys(obj).forEach((item) =&gt; {
        console.log(item, obj[item]);
      }); // Symbol(name) '不使用钥匙是拿不到值的' Symbol(age) 18

      // 作为常量
      const eat = Symbol();
      const sleep = Symbol();

      function play(type) {
        switch (type) {
          case eat:
            console.log("吃饭");
            break;
          case sleep:
            console.log("睡觉");
            break;
          default:
            break;
        }
      }
      play(sleep); //睡觉</code></pre> 
<h4 id="iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8" style="text-align:center;"><span style="color:#fe2c24;">iterator 迭代器</span></h4> 
<pre><code>      // 迭代器 Iterator 一个数据结构只要具有Symbol.iterator属性，就认为是可遍历的
      let arr = [1, 2, 3];
      let iter = arr[Symbol.iterator]();

      console.log(iter.next()); // {value: 1, done: false}
      console.log(iter.next()); // {value: 2, done: false}
      console.log(iter.next()); // {value: 3, done: false}
      console.log(iter.next()); // {value: undefined, done: true}

      // 原生默认具备iterator接口的数据结构
      // Array Set Map String arguments对象 NodeList对象

      // 利用迭代器封装遍历对象中可遍历的属性
      let obj = {
        name: "遍历对象",
        age: 18,
        list: [111, 222, 333],
        // 迭代器
        [Symbol.iterator]() {
          let index = 0;
          return {
            next: () =&gt; {
              return {
                value: this.list[index++],
                done: index === this.list.length + 1 ? true : false,
              };
            },
          };
        },
      };
      for (const item of obj) {
        console.log(item); // 111 222 333
      }

      // 手写迭代器（ts）
      const fn = (args: any) =&gt; {
      let it: Iterator&lt;any&gt; = args[Symbol.iterator]();
      let next: any = { done: false };
        while (!next.done) {
          next = it.next();
          if (!next.done) {
          // console.log(next);
            if (next.value.length &gt;= 2) {
              console.log(`${next.value[1]}是${next.value[0]}`);
            }
          }
        }
      };</code></pre> 
<h4 id="Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" style="text-align:center;"><span style="color:#fe2c24;">Set数据结构</span></h4> 
<pre><code>      // Set 结构类似于数组，但成员的值都是唯一的，没有重复的值
      // 利用Set结构数组去重
      let arr = [1, 2, 2, 3, 4, 5, 5, 6];
      let [...res] = new Set(arr); // [1, 2, 3, 4, 5, 6]

      // 添加
      set.add(1);

      // 长度
      console.log(set.size);

      // 删除
      set.delete(1);

      // 检查
      console.log(set.has(1)); // true

      // 封装一个可以去重复杂数组的函数
      function fn(arr) {
        let res = new Set();
        return arr.filter((item) =&gt; {
          let id = JSON.stringify(item);
          if (res.has(id)) {
            return false;
          } else {
            res.add(id);
            return true;
          }
        });
      }</code></pre> 
<h4 id="Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" style="text-align:center;"><span style="color:#fe2c24;">Map数据结构</span></h4> 
<pre><code>      // Map 用来存储键值对结构的数据(key-value)
      // Map 和 Object 主要区别：
      // 1. Object中的属性只能是字符串或符号
      // 2. Map任何类型的值都可以成为数据的key

      const obj = {
        name: "1",
        age: 18,
      };
      console.log(obj);

      // 创建map对象
      const map = new Map();
      map.set(obj, "纳西妲");
      map.set(undefined, "妮露");

      //   // 存值
      //   map.set(obj, '啦啦')
      //   console.log(map)

      //   // 取值
      //   console.log(map.get(obj))

      //   // 删除
      //   map.delete(obj)

      //   // 查找
      //   console.log(map.has(NaN)) // false

      //   // 清空
      //   console.log(map.clear())

      //   // 长度
      //   console.log(map.size)

      // 将数据类型为Map的对象转换为数组
      const [...arr] = map;
      console.log(arr);

      // 遍历Map
      for (const [key, value] of map) {
        console.log(key, value);
      }

      // 获取所有的key
      for (const key of map.keys()) {
        console.log(key);
      }

      // 获取所有的value
      for (const value of map.values()) {
        console.log(value);
      }

      map.forEach((item, index) =&gt; {
        console.log(item, index);
      });</code></pre> 
<h4 id="Proxy%E4%BB%A3%E7%90%86" style="text-align:center;"><span style="color:#fe2c24;">Proxy代理</span></h4> 
<pre><code>      // 在Proxy代理出现之前是用 Object.defineProperty 来拦截更改/获取dom行为
      // 缺点 每次只能拦截一个属性，只能拦截对象
      // let obj = {};
      // Object.defineProperty(obj, "data", {
      //   get() {
      //     console.log("get");
      //   },
      //   set(value) {
      //     console.log("set", value);
      //   },
      // });

      // Proxy 可以拦截所有数据类型
      let obj = {};
      let proxy = new Proxy(obj, {
        get(target, key) {
          // 对于Set或Map这样的数据结构，需要判断如果是方法就修改this指向
          let value = target[key];
          if (value instanceof Function) {
            return value.bind(target);
          }
          return value;
        },
        set(target, key, value) {
          if (key === "data") {
            box.innerHTML = value;
          }
          // 将值赋值给目标
          // target[key] = value;
        },
      });</code></pre> 
<h4 id="Reflect%E5%8F%8D%E5%B0%84" style="text-align:center;"><span style="color:#fe2c24;">Reflect反射</span></h4> 
<pre><code>      // 代替Object 某些方法
      let obj = {};
      Reflect.defineProperty(obj, "name", {
        value: "haha",
        writable: false,
        enumerable: false,
      });
      // 修改某些Object 方法返回结果
      if (Reflect.defineProperty(target, property, attributes)) {
        // success
      } else {
        // fail
      }

      // 命令式变为函数行为
      Reflect.has(obj, "name"); //true
      Reflect.deleteProperty(obj, "name");

      // 设置和获取
      Reflect.set(obj, "age", 10);
      Reflect.get(obj, "age");

      // 最重要的作用是配合Proxy设置/获取属性或方法
      let proxy = new Proxy(obj, {
        get(target, key) {
          // 获取相应的方法
          let value = Reflect.get(target, key);
          // 如果是函数，修改this指向
          if (value instanceof Function) {
            return value.bind(target);
          }
          return value;
        },
        set(target, key, value) {
          // 执行默认行为
          Reflect.set([...arguments]);
        },
      });</code></pre> 
<h4 id="Promise%E5%AF%B9%E8%B1%A1" style="text-align:center;"><span style="color:#fe2c24;">Promise对象</span></h4> 
<pre><code>      // 基础写法
      let promise = new Promise((res, rej) =&gt; {
        setTimeout(() =&gt; {
          res(1000);
        }, 200);
      });
      promise
        .then((res) =&gt; {
          console.log("success", res);
        })
        .catch((err) =&gt; {
          console.log("fail", err);
        });

      // 有三种状态，pendding状态 fulfilled状态 rejected状态
      // 从pendding状态只能转换为fulfilled状态和rejected状态之间的一种状态，且改变后会凝固，不会再进行改变。

      // 解决回调地狱的问题 =&gt; 利用链式调用
      promise
        .then((res) =&gt; {
          console.log("success", res); // success 1000
          // 如果return 非Promise类型，直接变为 fulfilled状态
          // 如果return Promise类型，则根据这个Promise的状态去返回。
          return res;
        })
        .then((res) =&gt; {
          console.log("success", res); // success 1000
        })
        .catch((err) =&gt; {
          console.log("fail", err);
        });

      // Promise.all([]) 等全部promise执行完了之后再执行

      Promise.all([promise1, promise2])
        .then((result) =&gt; {
          console.log(result);
        })
        .catch((err) =&gt; {
          console.log(err);
        });

      // Promise.race() 等最快的promise执行完了就执行

      Promise.race([promise1, promise2])
        .then((result) =&gt; {
          console.log(result);
        })
        .catch((err) =&gt; {
          console.log(err);
        });</code></pre> 
<h4 id="Generator%E5%87%BD%E6%95%B0" style="text-align:center;"><span style="color:#fe2c24;">Generator生成器函数</span></h4> 
<pre><code>      // 基础使用
      function* gen() {
        console.log(1);
        yield; // 产出
        console.log(2);
        yield;
        console.log(3);
      }

      let g = gen();
      g.next(); // 1
      g.next(); // 2
      g.next(); // 3</code></pre> 
<h4 id="class%E8%AF%AD%E6%B3%95" style="text-align:center;"><span style="color:#fe2c24;">class语法</span></h4> 
<pre><code>      // 类是对象模板
      class Person {
        // 属性
        name = "我是实例属性"; // 大部分情况下用实例属性
        static props = "我是静态属性";

        // 方法
        sayHello() {
          console.log("我是实例方法", this.name); // this指向当前实例
        }

        static sayHi() {
          console.log("我是类方法", this); // this指向类
        }
      }

      class Dog {}

      // 调用构造函数创建对象(实例)
      //     实例           类
      const person1 = new Person();
      const dog1 = new Dog();

      // 利用 instanceof 可以判断一个对象是否由某个类创建
      console.log(dog1 instanceof Person); // false
      console.log(dog1 instanceof Dog); // true

      console.log(person1.name); // 实例属性只能通过实例访问
      console.log(Person.props); // 静态属性(类属性)只能通过类访问

      // 调用实例方法
      person1.sayHello();

      // 调用类方法
      Person.sayHi();</code></pre> 
<h4 id="class%E7%BB%A7%E6%89%BF" style="text-align:center;"><span style="color:#fe2c24;">class继承</span></h4> 
<pre><code>      // 可以通过extends关键字来完成继承，最大的作用就是，在不修改类的情况下，对其进行扩展
      // OCP 开闭原则，对修改关闭，对扩展开放
      class Animal {
        constructor(name) {
          this.name = name;
        }
        sayHello() {
          console.log(`动物在叫！`);
        }
      }

      class Snake extends Animal {
        // 重写构造函数
        constructor(name, age) {
          // 重写构造函数时，第一行代码必须是super()
          super(name); // 调用父类的构造函数
          this.age = age;
        }
        // 重写父类的方法
        sayHello() {
          // 在方法中可以使用super来调用父类的方法
          super.sayHello();
          console.log(`嘶嘶嘶！`);
        }
      }
      const snake1 = new Snake("蛇", 10);
      snake1.sayHello();
      console.log(snake1); // Snake {name: '蛇', age: 10}</code></pre> 
<p><strong> EMS规范和CJS规范</strong></p> 
<h2 id="ES7%E5%86%85%E5%AE%B9" style="text-align:center;"><span style="color:#0d0016;"><strong>ES7</strong></span></h2> 
<h4 id="%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97%E7%AC%A6" style="text-align:center;"><span style="color:#fe2c24;">求幂运算符</span></h4> 
<pre><code>Math.pow(3,2)===3**2 // 9</code></pre> 
<h4 id="%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84includes%E6%96%B9%E6%B3%95" style="text-align:center;"><span style="color:#fe2c24;"> 数组的includes方法</span></h4> 
<pre><code>[1,2,NaN].includes(NaN) // true

[1,2,NaN].indexOf(NaN) // -1 数组的indexOf方法判断不出数组中是否有NaN</code></pre> 
<h2 id="ES8" style="text-align:center;"><span style="color:#0d0016;">ES8</span></h2> 
<h4 id="async%E5%92%8Cawait" style="text-align:center;"><span style="color:#fe2c24;">async和await</span></h4> 
<pre><code>      // 解决回调地狱的最优方案
      function ajax1() {
        return new Promise((res, rej) =&gt; {
          setTimeout(() =&gt; {
            res("第一个请求返回的值");
            // rej("第一个请求失败");
          }, 1000);
        });
      }

      function ajax2() {
        return new Promise((res, rej) =&gt; {
          setTimeout(() =&gt; {
            res("成功接收第一个请求的返回值");
            // rej("第二个请求失败");
          }, 2000);
        });
      }

      // 第一种写法
      async function test1() {
        let res1 = await ajax1();
        let res2 = await ajax2(res1);
        return res2;
      }
      test1()
        .then((result) =&gt; {
          // 渲染页面
          console.log(result);
        })
        .catch((err) =&gt; {
          // 处理错误
          console.log(err);
        });

      // 第二种写法
      async function test2() {
        try {
          let res1 = await ajax1();
          console.log(res1);
          let res2 = await ajax2(res1);
          console.log(res2);
          console.log("渲染页面");

          // 如何使用Promise.all方法
          // let res = await Promise.all([ajax1(), ajax2(res1)]);
          // console.log(res); // ['第一个请求返回的值', '成功接收第一个请求的返回值']
        } catch (error) {
          console.log(error, "处理错误");
        }
      }
      test2();</code></pre> 
<h4 id="%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95" style="text-align:center;"><span style="color:#fe2c24;">对象方法扩展</span></h4> 
<pre><code>      // 对象的获取操作
      let obj = {
        name: "八重神子",
        age: 500,
        get changeName() {
          return 666;
        },
        set changeName(value) {
          this.name = value;
        },
      };
      console.log(Object.keys(obj)); // es6 只取key ['name', 'age']
      console.log(Object.values(obj)); // 只取值 ['八重神子', 500]
      console.log(Object.entries(obj)); // key和值都获取 0: (2) ['name', '八重神子'] 1: (2) ['age', 500]

      // 对象的复制操作，可以把对象里的方法一起复制
      let obj1 = {};
      Object.defineProperties(obj1, Object.getOwnPropertyDescriptors(obj));</code></pre> 
<h4 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85" style="text-align:center;"><span style="color:#fe2c24;">字符串填充</span></h4> 
<pre><code>      // 字符串填充到指定长度
      let str = "天道酬勤";
      str.padEnd(10, "1"); // 天道酬勤111111
      str.padStart(5, "6"); // 6天道酬勤</code></pre> 
<h2 id="ES9%E5%86%85%E5%AE%B9" style="text-align:center;"><span style="color:#0d0016;">ES9</span></h2> 
<h4 id="rest%E4%B8%8E%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6" style="text-align:center;"><span style="color:#fe2c24;">rest与扩展运算符</span></h4> 
<pre><code>      // 剩余参数
      function name(a, ...b) {}

      //扩展运算符
      let obj = { a: 1, b: 2 };
      // 这种方法复制只能深复制一层
      // 如果对象属性有复杂数据类型则无法实现深复制
      let obj1 = { ...obj };</code></pre> 
<h4 id="%E6%AD%A3%E5%88%99%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84" style="text-align:center;"><span style="color:#fe2c24;">正则命名捕获分组</span></h4> 
<pre><code>      let str = "今天是2022-10-10";
      let reg = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/;
      let res = reg.exec(str);
      let { year, month, day } = res.groups; // 2022 10 10</code></pre> 
<h4 id="Promise.finally" style="text-align:center;"><span style="color:#fe2c24;">Promise.finally</span></h4> 
<pre><code>      // Promise.finally 最后执行，不管promise状态是成功还是失败
      function ajax() {
        return new Promise((res, rej) =&gt; {
          rej("失败");
        });
      }

      ajax()
        .then((result) =&gt; {})
        .catch((err) =&gt; {})
        .finally(() =&gt; {
          // 不管成功还是失败都隐藏loading
        });</code></pre> 
<h4 id="%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3" style="text-align:center;"><span style="color:#fe2c24;">异步迭代</span></h4> 
<pre><code>      // 有一个任务数组，执行任务按顺序执行，任务1，任务2，任务3，以此类推(前提在for循环中执行)

      // 1. 写一个ajax请求
      function timer(t) {
        return new Promise((res, rej) =&gt; {
          setTimeout(() =&gt; {
            res("data-" + t);
          }, t);
        });
      }

      // 写一个异步生成器生成异步任务
      async function* gen() {
        yield timer(1000);
        yield timer(2000);
        yield timer(3000);
      }

      // 利用 for await 遍历异步任务
      async function test() {
        let g = gen();
        let arr = [g.next(), g.next(), g.next()];
        for await (const item of arr) {
          console.log(item);
        }
      }
      test();</code></pre> 
<h2 id="ES10%E5%86%85%E5%AE%B9" style="text-align:center;"><span style="color:#0d0016;">ES10</span></h2> 
<h4 id="Object.fromEntries" style="text-align:center;"><span style="color:#fe2c24;">Object.fromEntries</span></h4> 
<pre><code>      // 用法1 将Map结构转化成对象
      let arr = new Map();
      arr.set("name", "haha");
      arr.set("age", 18);
      Object.fromEntries(arr); // {name: 'haha', age: 18}

      // 用法2 将url参数转化成对象
      let url = "name=lala&amp;age=20";
      let searchParams = new URLSearchParams(url);
      Object.fromEntries(searchParams); // {name: 'lala', age: '20'}

      // 用法三 转换对象形式
      let obj = {
        A: ["A1", "A2", "A3"],
        B: ["B1", "B2"],
        C: ["c1"],
      };
      let newArr = [];
      for (const key in obj) {
        newArr.push([key, obj[key].length]);
      }
      Object.fromEntries(newArr) // {A: 3, B: 2, C: 1}</code></pre> 
<h4 id="%C2%A0trimStart%E5%92%8CtrimEnd" style="text-align:center;"> <span style="color:#fe2c24;">trimStart和trimEnd</span></h4> 
<pre><code>删除字符串前面的空格 str.trimStart() 
删除字符串后面的空格 str.trimEnd()</code></pre> 
<h4 id="flat()%E5%92%8CflatMap()%C2%A0" style="text-align:center;"><span style="color:#fe2c24;">flat()和flatMap() </span></h4> 
<pre><code>      // 扁平化 flat() flatMap()
      [1, 2, 3, [4, 5, 6]].flat(); // [1, 2, 3, 4, 5, 6]
      let addr = [
        {
          name: "A",
          location: [1, 2, 3, 4],
        },
        {
          name: "B",
          location: [5, 6, 7, 8],
        },
      ];

      let resArr = addr.flatMap((item) =&gt; {
        return item.location;
      });
      console.log(resArr); // [1, 2, 3, 4, 5, 6, 7, 8]</code></pre> 
<h4 id="%C2%A0symbol.description%C2%A0" style="text-align:center;"><span style="color:#fe2c24;"> symbol.description </span></h4> 
<pre><code>      // 根据描述符查找Symbol属性
      let s = Symbol("name");
      s.description // name</code></pre> 
<h2 id="ES11" style="text-align:center;"><span style="color:#0d0016;">ES11</span></h2> 
<h4 id="Promise.allSettled" style="text-align:center;"><span style="color:#fe2c24;">Promise.allSettled</span></h4> 
<pre><code>      function ajax(flag, t) {
        return new Promise((res, rej) =&gt; {
          setTimeout(() =&gt; {
            if (flag) {
              res("成功");
            } else {
              rej("失败");
            }
          }, t);
        });
      }
      // 把全部成功的请求返回，不用捕获失败的请求
      Promise.allSettled([
        ajax(true, 1000),
        ajax(true, 2000),
        ajax(false, 3000),
      ]).then((result) =&gt; {
        let res = result.filter((item) =&gt; item.status === "fulfilled");
        let newRes = res.flatMap((item) =&gt; item.value); // ['成功', '成功']
      });</code></pre> 
<h4 id="Module%E6%96%B0%E5%A2%9E" style="text-align:center;"><span style="color:#fe2c24;">Module新增</span></h4> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;es11&lt;/title&gt;
  &lt;/head&gt;
  &lt;button id="login"&gt;登录&lt;/button&gt;
  &lt;body&gt;
    &lt;script&gt;
      function fn() {
        return "管理员";
      }

      let login = document.querySelector("#login");
      login.onclick = function () {
        let role = fn();
        render(role);
      };
      // 动态导入
      async function render(role) {
        if (role === "管理员") {
          let res1 = await import("./1.js"); // 返回promise对象
          console.log(res1);
        } else {
          let res2 = await import("./2.js");
          console.log(res2);
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<pre><code>// 1.js文件

console.log("管理员js加载了", import.meta); 
// 管理员js加载了 {url: 'http://127.0.0.1:5500/Es6-Es13/1.js', resolve: ƒ}

export default {
  name: "管理员",
};

// 无侵入式从别的模块继承过来然后导出
export * as js_2 from "./2.js";
</code></pre> 
<h4 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84matchAll%E6%96%B9%E6%B3%95" style="text-align:center;"><span style="color:#fe2c24;">字符串的matchAll方法</span></h4> 
<pre><code>      let str = `&lt;ul&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;333&lt;/li&gt;
      &lt;/ul&gt;`;

      let reg = /&lt;li&gt;(.*)&lt;\/li/g;
      let obj = str.matchAll(reg);
      for (const item of obj) {
        console.log(item[1]); // 111 222 333
      }</code></pre> 
<h4 id="bigint%20%EF%BC%88%E5%A4%A7%E6%95%B4%E6%95%B0%EF%BC%89%E7%B1%BB%E5%9E%8B" style="text-align:center;"><span style="color:#fe2c24;">bigint （大整数）类型</span></h4> 
<pre><code>// BigInt数据类型支持范围更大的整数值，可以用任意精度表示整数

BigInt(10); // 10n 

BigInt(10) == 10; // true

BigInt(10) === 10; // false

// 如果后端给你返回的数据太大，他又不给你转换成字符串，就使用json-bigint插件进行转换
import JsonBigint from "json-bigint";

// 转换成字符串类型
// let JsonBigintStr = JsonBigint({ storeAsString: true });

// 转换成bigInt类型
let JsonBigintNative = JsonBigint({ useNativeBigInt: true });

let jsonStr = `{
        "id":9007199254740993,
        "list":[]
      }`;

// JsonBigintStr.parse(jsonStr); // { id: '9007199254740993', list: [] }
JsonBigintNative.parse(jsonStr); // { id: 9007199254740993n, list: [] }
</code></pre> 
<h4 id="globalThis%20%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1" style="text-align:center;"><span style="color:#fe2c24;">globalThis 顶层对象</span></h4> 
<pre><code>// 在不同平台，都可以拿到当前环境的顶层对象，在跨平台开发时就无须再配置。

// 在浏览器环境 globalThis === window </code></pre> 
<h4 id="%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%20%3F%3F" style="text-align:center;"><span style="color:#fe2c24;">空值合并运算符 ??</span></h4> 
<pre><code>      // 只要  ?? 前面不是null或undefined 就返回前面的值
      // let str = null ?? "签名"; // 签名
      // let str = undefined ?? "签名"; // 签名
      // let str = 0 ?? "签名"; // 0</code></pre> 
<h4 id="%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3F." style="text-align:center;"><span style="color:#fe2c24;">可选链操作符 ?.</span></h4> 
<pre><code>      // 当问号前面的值没有或为undefined时，直接返回undefined，不至于使代码报错
      let obj = {
        name: "张三",
        // location: {
        //   now: "beijing",
        // },
      };
      console.log(obj?.location?.now); // undefined</code></pre> 
<h2 id="ES12" style="text-align:center;"><span style="color:#0d0016;">ES12</span></h2> 
<h4 id="%E6%96%B0%E5%A2%9E%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6" style="text-align:center;"><span style="color:#fe2c24;">新增逻辑操作符</span></h4> 
<pre><code>      let a = true;
      let b = false;
      a &amp;&amp;= b; // false
      a ||= b; // false
      let obj = {
        // name: 1,
      };
      obj.name ??= "默认名字"; // 默认名字</code></pre> 
<h4 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84replaceAll%20%E6%96%B9%E6%B3%95" style="text-align:center;"><span style="color:#fe2c24;">字符串的replaceAll 方法</span></h4> 
<pre><code>      // 可以全部替换
      let str = `1,1,1,1`;
      str.replaceAll("1", "*"); // *,*,*,*</code></pre> 
<h4 id="Promise.any" style="text-align:center;"><span style="color:#fe2c24;">Promise.any</span></h4> 
<pre><code>      let ajax1 = function () {
        return new Promise((res, rej) =&gt; {
          rej("纳西妲");
        });
      };
      let ajax2 = function () {
        return new Promise((res, rej) =&gt; {
          res("八重神子");
        });
      };
      let ajax3 = function () {
        return new Promise((res, rej) =&gt; {
          res("神里绫华");
        });
      };
      // 只要任意请求成功，就直接返回该成功结果，全部失败才到catch
      Promise.any([ajax1(), ajax2(), ajax3()])
        .then((result) =&gt; {
          console.log(result);
        })
        .catch((err) =&gt; {
          console.log("err", err);
        });</code></pre> 
<h4 id="WeakRef" style="text-align:center;"><span style="color:#fe2c24;">WeakRef</span></h4> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;es12&lt;/title&gt;
  &lt;/head&gt;
  &lt;div id="div"&gt;1111&lt;/div&gt;
  &lt;body&gt;
    &lt;script&gt;
      // 强引用
      let obj = {
        name: "大理石",
      };

      // Map(Set)结构存在的问题
      // let m1 = new Map();
      // m1.set(obj, "哈哈");

      // obj = null;
      // 因为引用计数机制，obj依然存在在m1里，没有被垃圾回收(内存泄漏)

      // 弱引用 WeakMap WeakSet 只能存储复杂数据类型，size，for不能用
      let m2 = new WeakMap();
      m2.set(obj, "啦啦");
      obj = null;
      // 因为是弱引用，不存在引用计数机制，所以m2中的obj被回收了

      let dom = new WeakRef(document.querySelector("#div"));
      dom.deref(); // &lt;div id="div"&gt;1111&lt;/div&gt;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h2 id="ES13" style="text-align:center;"><span style="color:#0d0016;">ES13</span></h2> 
<h4 id="%E7%B1%BB%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7" style="text-align:center;"><span style="color:#fe2c24;">类新增特性</span></h4> 
<pre><code>      class Person {
        // 初始值可以直接定义
        state = {
          name: "haha",
          age: 18,
        };
        sex = "男";

        // 实例私有属性
        #play = "打游戏";
        playGame() {
          return this.#play;
        }

        // 静态私有属性配合静态公开方法
        static #watch = "看电视";
        static watchTv() {
          return this.#watch;
        }

        // 静态代码块(可以写多个)
        static obj = new Map();
        static {
          this.obj.set("name", "无量天尊");
          this.obj.set("age", 8000);
        }
        static {
          console.log(this.obj); // Map(2) {'name' =&gt; '无量天尊', 'age' =&gt; 8000}
        }

        // 判断某个属性是不是该类的私有属性
        hasObj() {
          return #play in this;
        }
      }
      let person = new Person();
      person.playGame(); // 打游戏
      Person.watchTv(); // 看电视
      person.hasObj(); // true</code></pre> 
<h4 id="%E9%A1%B6%E5%B1%82%20await%C2%A0" style="text-align:center;"><span style="color:#fe2c24;">顶层 await </span></h4> 
<pre><code>// js文件

function ajax() {
  return new Promise((res, rej) =&gt; {
    setTimeout(() =&gt; {
      res("成功");
    }, 2000);
  });
}

// 当有数据是异步导出时，可以使用顶层 await 接收数据
let data = await ajax();

export default {
  name: "haha",
  data,
};


// html文件

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;es13&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type="module"&gt;
      // 异步导出配合动态导入使用最佳
      console.log("不能被阻塞的初始化数据"); // 不能被阻塞的初始化数据
      let moduleA = await import("./ajax.js");
      console.log(moduleA); // Module {Symbol(Symbol.toStringTag): 'Module'}
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h4 id="at%E5%87%BD%E6%95%B0" style="text-align:center;"><span style="color:#fe2c24;">at函数</span></h4> 
<pre><code>let arr = [1,2,3,4]
arr.at(0) // 第一个元素
arr.at(-1) // 倒数第一个元素

// 字符串也适用</code></pre> 
<h4 id="findLast%20%E5%92%8C%20findLastIndex" style="text-align:center;"><span style="color:#fe2c24;">findLast 和 findLastIndex</span></h4> 
<pre><code>      let arr = [10, 20, 30, 40];
      let res = arr.findLast((value) =&gt; value &lt; 40);
      let resIndex = arr.findLastIndex((value) =&gt; value &lt; 40);
      console.log(res); // 30 从后面查找并返回第一个符合条件的元素
      console.log(resIndex); // 2 从后面查找并返回第一个符合条件的元素的索引</code></pre> 
<h4 id="catch%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%9B%A0" style="text-align:center;"><span style="color:#fe2c24;">catch捕获错误添加原因</span></h4> 
<pre><code>      function getData() {
        try {
          console.log(aaa);
        } catch {
          throw new Error("不符合规则", {
            cause: {
              a: "十连双黄",
              b: "单抽出金",
            },
          });
        }
      }
      try {
        getData();
      } catch (error) {
        console.log(error, error.cause);
        /* Error: 不符合规则
           at getData (es13.html:27:17)
           at es13.html:36:9 {a: '十连双黄', b: '单抽出金'}*/
      }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86e7d8ef658dfb659595f32bb6b9e104/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言指针与数组的调用，指针的的增减详细介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ae83e0b01e6bebc6a152f756e670107/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【QT 基础教程 七】QStringList类详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>