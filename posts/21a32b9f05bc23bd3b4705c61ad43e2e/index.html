<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>scala方法和函数 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="scala方法和函数" />
<meta property="og:description" content="目录
方法的定义
默认参数
变长参数
过程
懒值（lazy）
方法VS函数
定义方式
表达形式
参数要求
方法和函数的相互转换
方法的定义 有以下几点需要注意：
所有参数必须制定类型；递归方法，不能省略返回值类型，其他情况下可以忽略（方法可以通过=右侧的函数主体推断出返回值类型）单行方法主体，可以与方法写在一行并忽略{} 默认参数 scala&gt; def m1(name : String, left : String = &#34;&lt;&#34;, right : String = &#34;&gt;&#34;) = { | left &#43; name &#43; right | } m1: (name: String, left: String, right: String)String scala&gt; m1(&#34;hello&#34;) res0: String = &lt;hello&gt; scala&gt; m1(&#34;hello&#34;,&#34;&lt;&lt;&#34;,&#34;&gt;&gt;&#34;) res1: String = &lt;&lt;hello&gt;&gt; scala&gt; m1(&#34;hello&#34;, right = &#34;&gt;&gt;&#34;) res2: String = &lt;hello&gt;&gt; scala&gt; m1(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/21a32b9f05bc23bd3b4705c61ad43e2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-05T12:40:14+08:00" />
<meta property="article:modified_time" content="2018-08-05T12:40:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">scala方法和函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">方法的定义</a></p> 
<p id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" rel="nofollow">默认参数</a></p> 
<p id="%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0" rel="nofollow">变长参数</a></p> 
<p id="%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E8%BF%87%E7%A8%8B" rel="nofollow">过程</a></p> 
<p id="%E6%87%92%E5%80%BC%EF%BC%88lazy%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%87%92%E5%80%BC%EF%BC%88lazy%EF%BC%89" rel="nofollow">懒值（lazy）</a></p> 
<p id="%E6%96%B9%E6%B3%95VS%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%95VS%E5%87%BD%E6%95%B0" rel="nofollow">方法VS函数</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" rel="nofollow">定义方式</a></p> 
<p id="%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F" rel="nofollow">表达形式</a></p> 
<p id="%E5%8F%82%E6%95%B0%E8%A6%81%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E5%8F%82%E6%95%B0%E8%A6%81%E6%B1%82" rel="nofollow">参数要求</a></p> 
<p id="%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2" rel="nofollow">方法和函数的相互转换</a></p> 
<hr id="hr-toc"> 
<h3 id="%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">方法的定义</h3> 
<p><img alt="" class="has" height="282" src="https://images2.imgbox.com/c8/cb/Z0A2RXnN_o.png" width="554"></p> 
<p style="margin-left:0cm;">有以下几点需要注意：</p> 
<ol><li>所有参数必须制定类型；</li><li>递归方法，不能省略返回值类型，其他情况下可以忽略（方法可以通过=右侧的函数主体推断出返回值类型）</li><li>单行方法主体，可以与方法写在一行并忽略{}</li></ol> 
<h3 id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" style="margin-left:0cm;">默认参数</h3> 
<pre class="has"><code>scala&gt; def m1(name : String, left : String = "&lt;", right : String = "&gt;") = {
     | left + name + right
     | }
m1: (name: String, left: String, right: String)String

scala&gt; m1("hello")
res0: String = &lt;hello&gt;

scala&gt; m1("hello","&lt;&lt;","&gt;&gt;")
res1: String = &lt;&lt;hello&gt;&gt;

scala&gt; m1("hello", right = "&gt;&gt;")
res2: String = &lt;hello&gt;&gt;

scala&gt; m1("hello", "&lt;&lt;")
res3: String = &lt;&lt;hello&gt;
</code></pre> 
<p>说明：</p> 
<p>可以在定义参数的时候直接为参数赋值；</p> 
<p>当调用方法时，可以不设置已有默认值的参数；</p> 
<p>可以设置默认参数的值，设置值的时候会按照方法默认参数的顺序依次设置，也可以指定参数名对其进行赋值。</p> 
<h3 id="%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0">变长参数</h3> 
<p>当输入相同类型的参数个数无法确定时，可以使用变长参数，java和python中都有此特性</p> 
<pre class="has"><code>scala&gt; def sum(args : Int*) = {
     |   var res = 0
     |   for(arg &lt;- args) res += arg
     |   res
     | }
sum: (args: Int*)Int

scala&gt; sum(1,2,3,4)
res0: Int = 10</code></pre> 
<p>sum方法的参数类型是Seq类型，如果有一个值的序列不能传入变长参数中，此时会报错</p> 
<pre class="has"><code>scala&gt; sum(1 to 4)
&lt;console&gt;:13: error: type mismatch;
 found   : scala.collection.immutable.Range.Inclusive
 required: Int
       sum(1 to 4)
             ^</code></pre> 
<p>如果就是想传入一个已有序列，怎么办？scala设计之初肯定也是想过的，就是在出入的已有序列后追加“:_*”，表示将一个Range转成一个Seq</p> 
<pre class="has"><code>scala&gt; sum(1 to 4 :_*)
res5: Int = 10</code></pre> 
<h3 id="%E8%BF%87%E7%A8%8B">过程</h3> 
<p>在Scala中，定义方法时，如果方法体直接包裹在了花括号里面，而没有使用=连接，则方法的返回值类型就是Unit。这样的方法就被称之为过程。过程通常用于不需要返回值的方法。过程还有一种写法，就是将方法的返回值类型定义为Unit。其实过程就是相当于Java中无返回值的方法。</p> 
<pre class="has"><code>//将方法主体直接包含在{}中，并省略“=”，其实方法是一个返回Unit类型的方法
scala&gt; def hello(name : String){ print("hello," + name) } 
hello: (name: String)Unit

scala&gt; hello("liumingxin")
hello,liumingxin</code></pre> 
<p>即使我们在方法中依旧设置了返回值，过程返回值类型依旧是Unit</p> 
<pre class="has"><code>//即使设置了返回值，过程返回的依旧是Unit类型
scala&gt; def hello(name : String){ print("hello," + name);"hello, " + name}
hello: (name: String)Unit

scala&gt; hello("liumingxin")
hello,liumingxin</code></pre> 
<h3 id="%E6%87%92%E5%80%BC%EF%BC%88lazy%EF%BC%89">懒值（lazy）</h3> 
<p>在Scala中，提供了lazy值的特性，也就是说，如果将一个变量声明为lazy，则只有在第一次使用该变量时，变量对应的表达式才会发生计算。这种特性对于特别耗时的计算操作特别有用。</p> 
<p>lazy的调用并不做任何额外的开销，每一次访问lazy值的时候，都会调用一个方法，以线程安全的方式检查该值是否已经被初始化了。</p> 
<pre class="has"><code>scala&gt; val a = 1 / 0
java.lang.ArithmeticException: / by zero
  ... 28 elided

scala&gt; lazy val a = 1 / 0
a: Int = &lt;lazy&gt;

scala&gt; a
java.lang.ArithmeticException: / by zero
  at .a$lzycompute(&lt;console&gt;:11)
  at .a(&lt;console&gt;:11)
  ... 28 elided
</code></pre> 
<p>很明显，1/0是错误的，在不使用lazy的时候，创建变量直接报错；使用lazy之后，只有调用时才检查是否，如果创建了才进行调用。</p> 
<p>在Spark中使用了大量的lazy。</p> 
<h3 id="%E6%96%B9%E6%B3%95VS%E5%87%BD%E6%95%B0">方法VS函数</h3> 
<p>Scala 有方法与函数，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。换句话来说在类中定义的函数即是方法。</p> 
<p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p> 
<p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait(Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。) 的类的对象。</p> 
<p>Scala 中使用 val 语句可以定义函数，def 语句定义方法。</p> 
<h4 id="%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">定义方式</h4> 
<pre class="has"><code>//方法的定义
scala&gt; def m1(x: Int) = x + 1
m1: (x: Int)Int

//函数的定义
scala&gt; val f1 = (x : Int) =&gt; x + 1
f1: Int =&gt; Int = $$Lambda$1036/961708482@1573e8a5
</code></pre> 
<p>方法是一个以def开头的带有参数列表（可以无参数列表）的一个逻辑操作块，这正如object或者class中的成员方法一样。（上面有定义说明）</p> 
<p>函数是一个赋值给一个变量（或者常量）的匿名方法（带或者不带参数列表），并且通过=&gt;转换符号跟上逻辑代码块的一个表达式。=&gt;转换符号后面的逻辑代码块的写法与method的body部分相同。</p> 
<h4 id="%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F">表达形式</h4> 
<pre class="has"><code>scala&gt; m1
&lt;console&gt;:13: error: missing argument list for method m1
Unapplied methods are only converted to functions when a function type is expect
ed.
You can make this conversion explicit by writing `m1 _` or `m1(_)` instead of `m
1`.
       m1
       ^

scala&gt; f1
res1: Int =&gt; Int = $$Lambda$1036/961708482@1573e8a5
</code></pre> 
<p>method（带参方法）不能作为最终的表达式（无参方法可以，但是这个就成了方法调用，因为scala允许无参方法调用时省略（）括号）。</p> 
<p>function可以作为最终的表达式出现。</p> 
<p>方法名意味着方法调用，函数名只是代表函数自身。</p> 
<h4 id="%E5%8F%82%E6%95%B0%E8%A6%81%E6%B1%82">参数要求</h4> 
<pre class="has"><code>scala&gt; def m2 = 100
m2: Int

scala&gt; def m3() = 100
m3: ()Int

scala&gt; val f2=() =&gt; 100
f2: () =&gt; Int = $$Lambda$1050/1002690318@78bce1c4

scala&gt; val f3= =&gt; 100
&lt;console&gt;:1: error: illegal start of simple expression
       val f3= =&gt; 100
               ^
</code></pre> 
<p>方法可以没有参数列表页可以是空的参数列表。</p> 
<p>函数必须设置参数列表，可以是空的参数列表，但一定要设置。</p> 
<h4 id="%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">方法和函数的相互转换</h4> 
<p>把 x =&gt; func(x) 简化为 func _ 或 func 的过程称为 eta-conversion（函数转换成方法）</p> 
<p>把 func 或 func _ 展开为 x =&gt; func(x) 的过程为 eta-expansion（方法转换成函数）</p> 
<p>可以在方法名后面加一个下划线强制变成函数，<span style="color:#f33b45;">方法名与下划线之间至少有一个空格,没有会报错</span></p> 
<p>eta-expansion过程：</p> 
<pre class="has"><code>//方法转变成函数 ETA-expansion,记得方法名与_之间加空格
scala&gt; val f4 = m1
&lt;console&gt;:12: error: missing argument list for method m1
Unapplied methods are only converted to functions when a function type is expect
ed.
You can make this conversion explicit by writing `m1 _` or `m1(_)` instead of `m
1`.
       val f4 = m1
                ^

scala&gt; val f4 = m1_
&lt;console&gt;:11: error: not found: value m1_
       val f4 = m1_
                ^

scala&gt; val f4 = m1 _
f4: Int =&gt; Int = $$Lambda$1054/2011547493@5daa621b</code></pre> 
<p>  eta-conversion过程：</p> 
<pre class="has"><code>//ETA-conversion，也验证了m4是一个方法，并不是一个函数
scala&gt; def m4(x : Int) = f1(x)
m4: (x: Int)Int

scala&gt; m4
&lt;console&gt;:13: error: missing argument list for method m4
Unapplied methods are only converted to functions when a function type is expect
ed.
You can make this conversion explicit by writing `m4 _` or `m4(_)` instead of `m
4`.
       m4
       ^</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e47fe48e4f55199c18409cfae81b504/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">qemu、KVM、以及Could not access KVM kernel module: No such file or directory</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/247145456648b5c9682977659437d953/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库之事务详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>