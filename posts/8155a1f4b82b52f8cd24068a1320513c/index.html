<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>unordered_map 简介 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="unordered_map 简介" />
<meta property="og:description" content="简介 无序映射（Unordered maps）是用于存储键值和映射值组合成的元素的关联容器，并允许基于其键快速检索各个元素。在unordered_map中，键值通常用于唯一地标识元素，而映射值是具有与该键关联的内容的对象。键的类型和映射的值可能会有所不同。
头文件 在使用unordered_map时，需要引入头文件：
#include &lt; unordered_map &gt; 内部实现 unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。
与map对比 map
优点：
有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；
红黑树，内部实现一个红黑树使得map的很多操作在O(lgn)的时间复杂度下就可以实现，因此效率非常的高。
缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
应用场景：对于那些有顺序要求的问题，用map会更高效一些
unordered_map
优点：因为内部实现了哈希表，因此其查找速度非常的快缺点：哈希表的建立比较耗费时间应用场景：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 总结
内存占有率的问题就转化成红黑树 VS Hash表，还是unordered_map占用的内存要高；但是unordered_map执行效率要比map高很多；对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的。 unordered_map的使用 unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。
#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { //注意：C&#43;&#43;11才开始支持括号初始化 unordered_map&lt;int, string&gt; myMap={{ 5, &#34;张大&#34; },{ 6, &#34;李五&#34; }};//使用{}赋值 myMap[2] = &#34;李四&#34;; //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。 myMap.insert(pair&lt;int, string&gt;(3, &#34;陈二&#34;));//使用insert和pair插入 //遍历输出&#43;迭代器的使用 auto iter = myMap.begin();//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator while (iter!= myMap.end()) { cout &lt;&lt; iter-&gt;first &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8155a1f4b82b52f8cd24068a1320513c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-11T14:55:37+08:00" />
<meta property="article:modified_time" content="2021-03-11T14:55:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">unordered_map 简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>简介</h3> 
<p>无序映射（Unordered maps）是用于存储<em>键值</em>和<em>映射值</em>组合成的元素的关联容器，并允许基于其键快速检索各个元素。在<code>unordered_map</code>中，键值通常用于唯一地标识元素，而映射值是具有与该键关联的内容的对象。键的类型和映射的值可能会有所不同。</p> 
<h3><a id="_3"></a>头文件</h3> 
<p>在使用<code>unordered_map</code>时，需要引入头文件：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt; unordered_map &gt;</span></span>
</code></pre> 
<h3><a id="_10"></a>内部实现</h3> 
<p><code>unordered_map</code>内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p> 
<h3><a id="map_13"></a>与map对比</h3> 
<p><strong>map</strong></p> 
<ol><li> <p>优点：</p> 
  <ul><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 有序性，这是<code>map</code>结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 红黑树，内部实现一个红黑树使得<code>map</code>的很多操作在O(lgn)的时间复杂度下就可以实现，因此效率非常的高。</p> </li></ul> </li><li> <p>缺点：空间占用率高，因为<code>map</code>内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p> </li><li> <p>应用场景：对于那些有顺序要求的问题，用<code>map</code>会更高效一些</p> </li></ol> 
<p><strong>unordered_map</strong></p> 
<ol><li>优点：因为内部实现了哈希表，因此其查找速度非常的快</li><li>缺点：哈希表的建立比较耗费时间</li><li>应用场景：对于查找问题，<code>unordered_map</code>会更加高效一些，因此遇到查找问题，常会考虑一下用<code>unordered_map</code></li></ol> 
<p><strong>总结</strong></p> 
<ol><li>内存占有率的问题就转化成红黑树 VS Hash表，还是<code>unordered_map</code>占用的内存要高；</li><li>但是<code>unordered_map</code>执行效率要比<code>map</code>高很多；</li><li>对于<code>unordered_map</code>或<code>unordered_set</code>容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的。</li></ol> 
<h3><a id="unordered_map_33"></a>unordered_map的使用</h3> 
<p><code>unordered_map</code>的用法和<code>map</code>是一样的，提供了 <code>insert</code>，<code>size</code>，<code>count</code>等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
	<span class="token comment">//注意：C++11才开始支持括号初始化</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> myMap<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"张大"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"李五"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//使用{}赋值</span>
    myMap<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"李四"</span><span class="token punctuation">;</span>  <span class="token comment">//使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span>
    myMap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"陈二"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用insert和pair插入</span>
  
	<span class="token comment">//遍历输出+迭代器的使用</span>
    <span class="token keyword">auto</span> iter <span class="token operator">=</span> myMap<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token operator">!=</span> myMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>  
        cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
        <span class="token operator">++</span>iter<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
	
	<span class="token comment">//查找元素并输出+迭代器的使用</span>
    <span class="token keyword">auto</span> iterator <span class="token operator">=</span> myMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//find()返回一个指向2的迭代器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iterator <span class="token operator">!=</span> myMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	    cout <span class="token operator">&lt;&lt;</span> endl<span class="token operator">&lt;&lt;</span> iterator<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> iterator<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  

</code></pre> 
<h3><a id="_66"></a>练习</h3> 
<p><strong>236. 二叉树的最近公共祖先</strong></p> 
<p><strong>方法二：存储父节点</strong></p> 
<p><strong>思路</strong><br> 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 <code>p</code> 结点开始不断往上跳，并记录已经访问过的节点，再从 <code>q</code> 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p> 
<p><strong>算法</strong></p> 
<ol><li> <p>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</p> </li><li> <p>从 <code>p</code> 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</p> </li><li> <p>同样，我们再从 <code>q</code> 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 <code>p</code> 和 <code>q</code> 的深度最深的公共祖先，即 LCA 节点。</p> </li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> fa<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> vis<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            fa<span class="token punctuation">[</span>root<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            fa<span class="token punctuation">[</span>root<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fa<span class="token punctuation">[</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            vis<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> fa<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> q<span class="token punctuation">;</span>
            q <span class="token operator">=</span> fa<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


作者：LeetCode<span class="token operator">-</span>Solution
链接：https<span class="token operator">:</span><span class="token comment">//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/</span>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre> 
<h3><a id="_121"></a>参考资料</h3> 
<p>[1] <a href="https://blog.csdn.net/BillCYJ/article/details/78985895">map和unordered_map的差别和使用</a><br> [2] <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/" rel="nofollow">Unordered Map - C++ Reference</a><br> [3] <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/" rel="nofollow">二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e664db911c0bfe9c52f7021c935e1a00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB 使用共空间模式 CSP 和支持向量机 SVM 做脑电分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ac78865ec7dcf244138c95775d6a776/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">百度一 29 岁程序员因“篡改数据”被抓</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>