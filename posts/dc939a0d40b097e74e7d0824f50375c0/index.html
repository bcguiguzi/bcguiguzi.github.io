<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DRM驱动（六）之atomic_check - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DRM驱动（六）之atomic_check" />
<meta property="og:description" content="上节聊到应用传下来的参数均被存到对应的state。为了使驱动的容错能力比较强，在更新到硬件寄存器之前还需要进行一系列的参数检查，比如要显示图像的大小是否会超过支持分辨率，如果超过了显示的硬件可能会异常；再比如应用需要硬件进行缩放图像但是硬件不支持，强制配置到硬件上面即使不出错也肯定达不到预期的效果，等等场景，一起看下drm驱动中是如何进行处理的。
驱动错误检查的入口为drm_atomic_check_only
int drm_atomic_check_only(struct drm_atomic_state *state) { struct drm_device *dev = state-&gt;dev; struct drm_mode_config *config = &amp;dev-&gt;mode_config; struct drm_plane *plane; struct drm_plane_state *plane_state; struct drm_crtc *crtc; struct drm_crtc_state *crtc_state; for_each_plane_in_state(state, plane, plane_state, i) { ret = drm_atomic_plane_check(plane, plane_state); if (ret) { return ret; } } for_each_crtc_in_state(state, crtc, crtc_state, i) { ret = drm_atomic_crtc_check(crtc, crtc_state); if (ret) { return ret; } } if (config-&gt;funcs-&gt;atomic_check) ret = config-&gt;funcs-&gt;atomic_check(state-&gt;dev, state); if (!state-&gt;allow_modeset) { for_each_crtc_in_state(state, crtc, crtc_state, i) { if (crtc_state-&gt;mode_changed || crtc_state-&gt;active_changed) { return -EINVAL; } } } return ret; } 这里主要调用了三个函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/dc939a0d40b097e74e7d0824f50375c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-18T09:38:40+08:00" />
<meta property="article:modified_time" content="2022-09-18T09:38:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DRM驱动（六）之atomic_check</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        上节聊到应用传下来的参数均被存到对应的state。为了使驱动的容错能力比较强，在更新到硬件寄存器之前还需要进行一系列的参数检查，比如要显示图像的大小是否会超过支持分辨率，如果超过了显示的硬件可能会异常；再比如应用需要硬件进行缩放图像但是硬件不支持，强制配置到硬件上面即使不出错也肯定达不到预期的效果，等等场景，一起看下drm驱动中是如何进行处理的。</p> 
<p>驱动错误检查的入口为<strong><em>drm_atomic_check_only</em></strong></p> 
<pre><code class="language-cpp">int drm_atomic_check_only(struct drm_atomic_state *state)
{
    struct drm_device *dev = state-&gt;dev;
    struct drm_mode_config *config = &amp;dev-&gt;mode_config;
    struct drm_plane *plane;
    struct drm_plane_state *plane_state;
    struct drm_crtc *crtc;
    struct drm_crtc_state *crtc_state;


    for_each_plane_in_state(state, plane, plane_state, i) {
        ret = drm_atomic_plane_check(plane, plane_state);
        if (ret) {
            return ret;
        }
    }
    for_each_crtc_in_state(state, crtc, crtc_state, i) {
        ret = drm_atomic_crtc_check(crtc, crtc_state);
        if (ret) {
            return ret;
        }
    }
    if (config-&gt;funcs-&gt;atomic_check)
    ret = config-&gt;funcs-&gt;atomic_check(state-&gt;dev, state);
    if (!state-&gt;allow_modeset) {
        for_each_crtc_in_state(state, crtc, crtc_state, i) {
            if (crtc_state-&gt;mode_changed ||
                crtc_state-&gt;active_changed) {
                return -EINVAL;
            }
        }
    }
     return ret;
}</code></pre> 
<p>这里主要调用了三个函数</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/01/fb/37y5XNHP_o.png" width="755"></p> 
<p><strong><em>drm_atomic_plane_check</em></strong>：用来check plane state的相关参数</p> 
<p><strong><em>drm_atomic_crtc_check</em></strong>：用来check crtc state的相关参数</p> 
<p><strong><em>config-&gt;funcs-&gt;atomic_check</em></strong>：此函数是可选的，可以不实现，也可以由drm驱动实现，也可以直接使用<strong><em>drm_atomic_helper_check</em></strong></p> 
<p>比如rockchip</p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/43/2e/GheZroqm_o.png" width="717"></p> 
<h3 id="drm_atomic_plane_check"><strong><em>drm_atomic_plane_check</em></strong></h3> 
<p>先来看<strong><em>drm_atomic_plane_check</em></strong>做了什么事情</p> 
<pre><code class="language-cpp">static int drm_atomic_plane_check(struct drm_plane *plane,
				struct drm_plane_state *state)
{
	unsigned int fb_width, fb_height;
	int ret;

	if (WARN_ON(state-&gt;crtc &amp;&amp; !state-&gt;fb)) {
		return -EINVAL;
	} else if (WARN_ON(state-&gt;fb &amp;&amp; !state-&gt;crtc)) {
		return -EINVAL;
	}
	if (!state-&gt;crtc)
		return 0;

	/* Check whether this plane is usable on this CRTC */
	if (!(plane-&gt;possible_crtcs &amp; drm_crtc_mask(state-&gt;crtc))) {
		return -EINVAL;
	}

	/* Check whether this plane supports the fb pixel format. */
	ret = drm_plane_check_pixel_format(plane, state-&gt;fb-&gt;format-&gt;format);
	if (ret) {
		struct drm_format_name_buf format_name;
		return ret;
	}

	/* Give drivers some help against integer overflows */
	if (state-&gt;crtc_w &gt; INT_MAX ||
		state-&gt;crtc_x &gt; INT_MAX - (int32_t) state-&gt;crtc_w ||
		state-&gt;crtc_h &gt; INT_MAX ||
		state-&gt;crtc_y &gt; INT_MAX - (int32_t) state-&gt;crtc_h) {
		return -ERANGE;
	}

	fb_width = state-&gt;fb-&gt;width &lt;&lt; 16;
	fb_height = state-&gt;fb-&gt;height &lt;&lt; 16;

	/* Make sure source coordinates are inside the fb. */
	if (state-&gt;src_w &gt; fb_width ||
		state-&gt;src_x &gt; fb_width - state-&gt;src_w ||
		state-&gt;src_h &gt; fb_height ||
		state-&gt;src_y &gt; fb_height - state-&gt;src_h) {
		state-&gt;src_w &gt;&gt; 16, ((state-&gt;src_w &amp; 0xffff) * 15625) &gt;&gt; 10,
		state-&gt;src_h &gt;&gt; 16, ((state-&gt;src_h &amp; 0xffff) * 15625) &gt;&gt; 10,
		state-&gt;src_x &gt;&gt; 16, ((state-&gt;src_x &amp; 0xffff) * 15625) &gt;&gt; 10,
		state-&gt;src_y &gt;&gt; 16, ((state-&gt;src_y &amp; 0xffff) * 15625) &gt;&gt; 10);
		return -ENOSPC;
	}

	return 0;
}</code></pre> 
<ol><li>对指针进行判断，如果传下来的指针不存在，后面的一切都没有意义</li><li>check plane是否支持当前要显示的format</li></ol> 
<p><em><strong>drm_plane_check_pixel_format</strong></em>的实现非常简单，遍历所有plane支持的format，找到返回0，找不到返回错误。</p> 
<pre><code class="language-cpp">int drm_plane_check_pixel_format(const struct drm_plane *plane, u32 format)
{
	unsigned int i;

	for (i = 0; i &lt; plane-&gt;format_count; i++) {
		if (format == plane-&gt;format_types[i])
			return 0;
	}

	return -EINVAL;
}</code></pre> 
<p>plane-&gt;format_types是在plane创建的时候指定的，可以详细看下<em><strong>drm_universal_plane_init</strong></em>这里贴出来部分代码</p> 
<pre><code class="language-cpp">drm_universal_plane_init(... ...const uint32_t *formats, unsigned int format_count,.)
{
    ... ...
    plane-&gt;format_types = kmalloc_array(format_count, sizeof(uint32_t),GFP_KERNEL);

    memcpy(plane-&gt;format_types, formats, format_count * sizeof(uint32_t));

    plane-&gt;format_count = format_count;
    ... ...
}</code></pre> 
<ol><li>check要显示的区域是否越界</li><li>check显示区域是否超过内存大小</li></ol> 
<p> state-&gt;fb-&gt;width和state-&gt;fb-&gt;height可以认为是在内存中的图像大小，如果应用想要显示的部分超过显存肯定是不对的，龙哥在<a href="https://blog.csdn.net/hexiaolong2009/article/details/84934294" title="最简单的DRM应用程序 （plane-test）_何小龙的博客-CSDN博客">最简单的DRM应用程序 （plane-test）_何小龙的博客-CSDN博客</a>的一张图片画的非常清楚，我引用一下</p> 
<p><img alt="" height="774" src="https://images2.imgbox.com/91/22/1PtSKchb_o.png" width="936"></p> 
<h3><em><strong>drm_atomic_crtc_check</strong></em></h3> 
<p>        主要检查crtc 状态逻辑是否正常；正如注释里提到的这里只进行通用的状态检查，厂商之间的硬件差异由<strong><em>crtc-&gt;atomic_check()</em></strong>来进行处理（稍后会介绍到在哪里调用）</p> 
<blockquote> 
 <p>For hw that does not, it should be checked in driver's crtc-&gt;atomic_check() vfunc；Add generic modeset state checks once we support those.</p> 
</blockquote> 
<p>因此此函数做的工作比较少，逻辑也比较清楚，不做解释。</p> 
<pre><code class="language-cpp">static int drm_atomic_crtc_check(struct drm_crtc *crtc,
		struct drm_crtc_state *state)
{
	/* NOTE: we explicitly don't enforce constraints such as primary
	 * layer covering entire screen, since that is something we want
	 * to allow (on hw that supports it).  For hw that does not, it
	 * should be checked in driver's crtc-&gt;atomic_check() vfunc.
	 *
	 * TODO: Add generic modeset state checks once we support those.
	 */

	if (state-&gt;active &amp;&amp; !state-&gt;enable) {
		DRM_DEBUG_ATOMIC("[CRTC:%d:%s] active without enabled\n",
		 crtc-&gt;base.id, crtc-&gt;name);
		return -EINVAL;
	}


	if (drm_core_check_feature(crtc-&gt;dev, DRIVER_ATOMIC) &amp;&amp;
			WARN_ON(state-&gt;enable &amp;&amp; !state-&gt;mode_blob)) {
		DRM_DEBUG_ATOMIC("[CRTC:%d:%s] enabled without mode blob\n",
		 crtc-&gt;base.id, crtc-&gt;name);
		return -EINVAL;
	}

	if (drm_core_check_feature(crtc-&gt;dev, DRIVER_ATOMIC) &amp;&amp;
			WARN_ON(!state-&gt;enable &amp;&amp; state-&gt;mode_blob)) {
		DRM_DEBUG_ATOMIC("[CRTC:%d:%s] disabled with mode blob\n",
		 crtc-&gt;base.id, crtc-&gt;name);
		return -EINVAL;
	}
	if (state-&gt;event &amp;&amp; !state-&gt;active &amp;&amp; !crtc-&gt;state-&gt;active) {
		DRM_DEBUG_ATOMIC("[CRTC:%d:%s] requesting event but off\n",
		 crtc-&gt;base.id, crtc-&gt;name);
		return -EINVAL;
	}

	return 0;
}</code></pre> 
<p>        上面两个函数主要是基本的，通用的参数检查，而不同的soc厂商的显示硬件支持的功能是不同的；这些差异化功能的check就需要由各个厂商自己来实现，接着看第三个函数指针的调用</p> 
<h3><em><strong>config-&gt;funcs-&gt;atomic_check</strong></em></h3> 
<p>        此回调是在驱动初始化的时候配置的，一般使用<em><strong>drm_atomic_helper_check</strong></em>也可以自己实现，但基本思想都一样——调用drm驱动各组件的atomic_check回调；另外还有一些标记位的置位，mode_changed，active_changed等</p> 
<pre><code class="language-cpp">int drm_atomic_helper_check(struct drm_device *dev,
		struct drm_atomic_state *state)
{
	int ret;

	ret = drm_atomic_helper_check_modeset(dev, state);
	if (ret)
		return ret;

	ret = drm_atomic_helper_check_planes(dev, state);
	if (ret)
		return ret;

	if (state-&gt;legacy_cursor_update)
		state-&gt;async_update = !drm_atomic_helper_async_check(dev, state);

	return ret;
}</code></pre> 
<p>        心心念念由驱动实现的plane-&gt;helper_private-&gt;atomic_check和crtc-&gt;helper_private-&gt;atomic_check它终于来了</p> 
<pre><code class="language-cpp">int drm_atomic_helper_check_modeset(struct drm_device *dev,
	struct drm_atomic_state *state)
{
	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
		bool has_connectors = !!new_crtc_state-&gt;connector_mask;

		WARN_ON(!drm_modeset_is_locked(&amp;crtc-&gt;mutex));

		if (!drm_mode_equal(&amp;old_crtc_state-&gt;mode, &amp;new_crtc_state-&gt;mode)) {
			new_crtc_state-&gt;mode_changed = true;
		}

		if (old_crtc_state-&gt;enable != new_crtc_state-&gt;enable) {
			new_crtc_state-&gt;mode_changed = true;
			new_crtc_state-&gt;connectors_changed = true;
		}

		if (old_crtc_state-&gt;active != new_crtc_state-&gt;active) {
			new_crtc_state-&gt;active_changed = true;
		}

		if (new_crtc_state-&gt;enable != has_connectors) {
			return -EINVAL;
		}
	}

	for_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {
		const struct drm_connector_helper_funcs *funcs = connector-&gt;helper_private;

		if (funcs-&gt;atomic_check)
			ret = funcs-&gt;atomic_check(connector, new_connector_state);
		if (ret)
			return ret;

		connectors_mask += BIT(i);
	}
}</code></pre> 
<p>        可能看到这里还是会有疑惑，回调里的atomic_check到底做了什么事情。如果不了解显示硬件不是很容易理解，我们先看下别人家的驱动是怎么实现的，以开源的rockchip的<em><strong>vop_plane_atomic_check</strong></em>为例，代码在rockchip_drm_vop.c</p> 
<p><em><strong>vop_plane_atomic_check</strong></em>的主要工作</p> 
<ol><li>检查缩放参数配置是不是符合要求</li><li>将drm_format转换成rockchip自己的format看自己是否支持</li><li>yuv格式是否2pixel对齐（硬件上的限制？）</li></ol> 
<pre><code class="language-cpp">static int vop_plane_atomic_check(struct drm_plane *plane,
			   struct drm_plane_state *state)
{
	struct drm_crtc *crtc = state-&gt;crtc;
	struct drm_crtc_state *crtc_state;
	struct drm_framebuffer *fb = state-&gt;fb;
	struct vop_win *vop_win = to_vop_win(plane);
	const struct vop_win_data *win = vop_win-&gt;data;
	int ret;
	struct drm_rect clip;
	int min_scale = win-&gt;phy-&gt;scl ? FRAC_16_16(1, 8) :
					DRM_PLANE_HELPER_NO_SCALING;
	int max_scale = win-&gt;phy-&gt;scl ? FRAC_16_16(8, 1) :
					DRM_PLANE_HELPER_NO_SCALING;

	if (!crtc || !fb)
		return 0;

	crtc_state = drm_atomic_get_existing_crtc_state(state-&gt;state, crtc);
	if (WARN_ON(!crtc_state))
		return -EINVAL;

	clip.x1 = 0;
	clip.y1 = 0;
	clip.x2 = crtc_state-&gt;adjusted_mode.hdisplay;
	clip.y2 = crtc_state-&gt;adjusted_mode.vdisplay;

	ret = drm_plane_helper_check_state(state, &amp;clip,
					   min_scale, max_scale,
					   true, true);
	if (ret)
		return ret;

	if (!state-&gt;visible)
		return 0;

	ret = vop_convert_format(fb-&gt;format-&gt;format);
	if (ret &lt; 0)
		return ret;

	/*
	 * Src.x1 can be odd when do clip, but yuv plane start point
	 * need align with 2 pixel.
	 */
	if (is_yuv_support(fb-&gt;format-&gt;format) &amp;&amp; ((state-&gt;src.x1 &gt;&gt; 16) % 2)) {
		DRM_ERROR("Invalid Source: Yuv format not support odd xpos\n");
		return -EINVAL;
	}

	return 0;
}</code></pre> 
<p><em>drm_atomic_helper_async_check</em>是异步刷新相关的，我们先不关心</p> 
<p>驱动的实现和硬件能力强相关，我们只需要了解大体框架即可。</p> 
<p>至此所有的参数都被检查了，没有问题下一步就是要更新到硬件上了。</p> 
<p>扯了那么多总结成一张简单的图</p> 
<p><img alt="" height="703" src="https://images2.imgbox.com/aa/ac/Lcxh3NH3_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/422ffa198a787756a65063a8753556c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell 脚本常用语法总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71b7eb0d9383adc978e2f193715d0210/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自动化之RPA工具之影刀</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>