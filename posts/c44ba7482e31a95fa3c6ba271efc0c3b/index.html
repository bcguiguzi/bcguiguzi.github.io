<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>教你用Python实现自动扫雷，你就是最亮的仔~ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="教你用Python实现自动扫雷，你就是最亮的仔~" />
<meta property="og:description" content="扫雷，相信80、90后的小伙伴肯定不陌生，在电脑还没有彻底普及的年代，能够玩上扫雷和纸牌就已经非常不容易了，今天小千就来给大家分享一期使用Python代码实现自动扫雷的教程，代码都在文章中，同学们可以学习和参考一下。
自动扫雷一般分为两种，一种是读取内存数据，而另一种是通过分析图片获得数据，并通过模拟鼠标操作，这里我用的是第二种方式。
一、准备工作 我的版本是 python 3.6.1
python的第三方库：
win32apiwin32guiwin32conPillownumpyopencv 可通过 pip install --upgrade SomePackage 来进行安装
注意：有的版本是下载pywin32，但是有的要把pywin32升级到最高并自动下载了pypiwin32，具体情况每个python版本可能都略有不同
这里给出的第三方库和版本仅供参考
二、关键代码组成 1.找到游戏窗口与坐标
#扫雷游戏窗口 class_name = &#34;TMain&#34; title_name = &#34;Minesweeper Arbiter &#34; hwnd = win32gui.FindWindow(class_name, title_name) #窗口坐标 left = 0 top = 0 right = 0 bottom = 0 if hwnd: print(&#34;找到窗口&#34;) left, top, right, bottom = win32gui.GetWindowRect(hwnd) #win32gui.SetForegroundWindow(hwnd) print(&#34;窗口坐标：&#34;) print(str(left)&#43;&#39; &#39;&#43;str(right)&#43;&#39; &#39;&#43;str(top)&#43;&#39; &#39;&#43;str(bottom)) else: print(&#34;未找到窗口&#34;) 2.锁定并抓取雷区图像
#锁定雷区坐标 #去除周围功能按钮以及多余的界面 #具体的像素值是通过QQ的截图来判断的 left &#43;= 15 top &#43;= 101 right -= 15 bottom -= 42 #抓取雷区图像 rect = (left, top, right, bottom) img = ImageGrab." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c44ba7482e31a95fa3c6ba271efc0c3b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-06T14:32:04+08:00" />
<meta property="article:modified_time" content="2023-09-06T14:32:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">教你用Python实现自动扫雷，你就是最亮的仔~</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>扫雷，相信80、90后的小伙伴肯定不陌生，在电脑还没有彻底普及的年代，能够玩上扫雷和纸牌就已经非常不容易了，今天小千就来给大家分享一期使用Python代码实现<strong>自动扫雷</strong>的教程，代码都在文章中，同学们可以学习和参考一下。</p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/c5/5a/MNB7Oxtv_o.png" width="601"></p> 
<p>自动扫雷一般分为两种，一种是读取内存数据，而另一种是通过分析图片获得数据，并通过模拟鼠标操作，这里我用的是第二种方式。</p> 
<h3><strong>一、准备工作</strong></h3> 
<p>我的版本是 python 3.6.1</p> 
<p>python的第三方库：</p> 
<ul><li>win32api</li><li>win32gui</li><li>win32con</li><li>Pillow</li><li>numpy</li><li>opencv</li></ul> 
<p>可通过 pip install --upgrade SomePackage 来进行安装</p> 
<p>注意：有的版本是下载pywin32，但是有的要把pywin32升级到最高并自动下载了pypiwin32，具体情况每个python版本可能都略有不同</p> 
<p>这里给出的第三方库和版本仅供参考</p> 
<h3><strong>二、关键代码组成</strong></h3> 
<p><strong>1.找到游戏窗口与坐标</strong></p> 
<pre><code>#扫雷游戏窗口
class_name = "TMain"
title_name = "Minesweeper Arbiter "
hwnd = win32gui.FindWindow(class_name, title_name)

#窗口坐标
left = 0
top = 0
right = 0
bottom = 0

if hwnd:
  print("找到窗口")
  left, top, right, bottom = win32gui.GetWindowRect(hwnd)
  #win32gui.SetForegroundWindow(hwnd)
  print("窗口坐标：")
  print(str(left)+' '+str(right)+' '+str(top)+' '+str(bottom))
else:
  print("未找到窗口")</code></pre> 
<p><strong>2.锁定并抓取雷区图像</strong></p> 
<pre><code>#锁定雷区坐标
#去除周围功能按钮以及多余的界面
#具体的像素值是通过QQ的截图来判断的
left += 15
top += 101
right -= 15
bottom -= 42

#抓取雷区图像
rect = (left, top, right, bottom)
img = ImageGrab.grab().crop(rect)</code></pre> 
<p><strong>3.各图像的RGBA值</strong></p> 
<pre><code>#数字1-8 周围雷数
#0 未被打开
#ed 被打开 空白
#hongqi 红旗
#boom 普通雷
#boom_red 踩中的雷
rgba_ed = [(225, (192, 192, 192)), (31, (128, 128, 128))]
rgba_hongqi = [(54, (255, 255, 255)), (17, (255, 0, 0)), (109, (192, 192, 192)), (54, (128, 128, 128)), (22, (0, 0, 0))]
rgba_0 = [(54, (255, 255, 255)), (148, (192, 192, 192)), (54, (128, 128, 128))]
rgba_1 = [(185, (192, 192, 192)), (31, (128, 128, 128)), (40, (0, 0, 255))]
rgba_2 = [(160, (192, 192, 192)), (31, (128, 128, 128)), (65, (0, 128, 0))]
rgba_3 = [(62, (255, 0, 0)), (163, (192, 192, 192)), (31, (128, 128, 128))]
rgba_4 = [(169, (192, 192, 192)), (31, (128, 128, 128)), (56, (0, 0, 128))]
rgba_5 = [(70, (128, 0, 0)), (155, (192, 192, 192)), (31, (128, 128, 128))]
rgba_6 = [(153, (192, 192, 192)), (31, (128, 128, 128)), (72, (0, 128, 128))]
rgba_8 = [(149, (192, 192, 192)), (107, (128, 128, 128))]
rgba_boom = [(4, (255, 255, 255)), (144, (192, 192, 192)), (31, (128, 128, 128)), (77, (0, 0, 0))]
rgba_boom_red = [(4, (255, 255, 255)), (144, (255, 0, 0)), (31, (128, 128, 128)), (77, (0, 0, 0))]</code></pre> 
<p><strong>4.扫描雷区图像保存至一个二维数组map</strong></p> 
<pre><code>#扫描雷区图像
def showmap():
  img = ImageGrab.grab().crop(rect)
  for y in range(blocks_y):
    for x in range(blocks_x):
      this_image = img.crop((x * block_width, y * block_height, (x + 1) * block_width, (y + 1) * block_height))
      if this_image.getcolors() == rgba_0:
        map[y][x] = 0
      elif this_image.getcolors() == rgba_1:
        map[y][x] = 1
      elif this_image.getcolors() == rgba_2:
        map[y][x] = 2
      elif this_image.getcolors() == rgba_3:
        map[y][x] = 3
      elif this_image.getcolors() == rgba_4:
        map[y][x] = 4
      elif this_image.getcolors() == rgba_5:
        map[y][x] = 5
      elif this_image.getcolors() == rgba_6:
        map[y][x] = 6
      elif this_image.getcolors() == rgba_8:
        map[y][x] = 8
      elif this_image.getcolors() == rgba_ed:
        map[y][x] = -1
      elif this_image.getcolors() == rgba_hongqi:
        map[y][x] = -4
      elif this_image.getcolors() == rgba_boom or this_image.getcolors() == rgba_boom_red:
        global gameover
        gameover = 1
        break
        #sys.exit(0)
      else:
        print("无法识别图像")
        print("坐标")
        print((y,x))
        print("颜色")
        print(this_image.getcolors())
        sys.exit(0)
  #print(map)</code></pre> 
<p><strong>5.扫雷算法</strong></p> 
<p>这里采用的最基础的算法</p> 
<p>1.首先点出一个点</p> 
<p>2.扫描所有数字，如果周围空白+插旗==数字，则空白均有雷，右键点击空白插旗</p> 
<p>3.扫描所有数字，如果周围插旗==数字，则空白均没有雷，左键点击空白</p> 
<p>4.循环2、3，如果没有符合条件的，则随机点击一个白块</p> 
<pre><code>#插旗
def banner():
  showmap()
  for y in range(blocks_y):
    for x in range(blocks_x):
      if 1 &lt;= map[y][x] and map[y][x] &lt;= 5:
        boom_number = map[y][x]
        block_white = 0
        block_qi = 0
        for yy in range(y-1,y+2):
          for xx in range(x-1,x+2):
            if 0 &lt;= yy and 0 &lt;= xx and yy &lt; blocks_y and xx &lt; blocks_x:
              if not (yy == y and xx == x):if map[yy][xx] == 0:
                  block_white += 1
                elif map[yy][xx] == -4:
                  block_qi += 1if boom_number == block_white + block_qi:for yy in range(y - 1, y + 2):
            for xx in range(x - 1, x + 2):
              if 0 &lt;= yy and 0 &lt;= xx and yy &lt; blocks_y and xx &lt; blocks_x:
                if not (yy == y and xx == x):
                  if map[yy][xx] == 0:
                    win32api.SetCursorPos([left+xx*block_width, top+yy*block_height])
                    win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)
                    win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0)
                    showmap()

#点击白块
def dig():
  showmap()
  iscluck = 0
  for y in range(blocks_y):
    for x in range(blocks_x):
      if 1 &lt;= map[y][x] and map[y][x] &lt;= 5:
        boom_number = map[y][x]
        block_white = 0
        block_qi = 0
        for yy in range(y - 1, y + 2):
          for xx in range(x - 1, x + 2):
            if 0 &lt;= yy and 0 &lt;= xx and yy &lt; blocks_y and xx &lt; blocks_x:
              if not (yy == y and xx == x):
                if map[yy][xx] == 0:
                  block_white += 1
                elif map[yy][xx] == -4:
                  block_qi += 1if boom_number == block_qi and block_white &gt; 0:for yy in range(y - 1, y + 2):
            for xx in range(x - 1, x + 2):
              if 0 &lt;= yy and 0 &lt;= xx and yy &lt; blocks_y and xx &lt; blocks_x:
                if not(yy == y and xx == x):
                  if map[yy][xx] == 0:
                    win32api.SetCursorPos([left + xx * block_width, top + yy * block_height])
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
                    iscluck = 1
  if iscluck == 0:
    luck()

#随机点击
def luck():
  fl = 1
  while(fl):
    random_x = random.randint(0, blocks_x - 1)
    random_y = random.randint(0, blocks_y - 1)
    if(map[random_y][random_x] == 0):
      win32api.SetCursorPos([left + random_x * block_width, top + random_y * block_height])
      win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
      win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
      fl = 0

def gogo():
  win32api.SetCursorPos([left, top])
  win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
  win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
  showmap()
  global gameover
  while(1):
    if(gameover == 0):
      banner()
      banner()
      dig()
    else:
      gameover = 0
      win32api.keybd_event(113, 0, 0, 0)
      win32api.SetCursorPos([left, top])
      win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
      win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
      showmap()</code></pre> 
<p>这个算法在初级和中级通过率都不错，但是在高级成功率惨不忍睹。</p> 
<p>主要是没有考虑逻辑组合以及白块是雷的概率问题，可以对这两个点进行改进，提高成功率。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d89a5a6cd47bfe3e804d2390e4baaa0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">黑客利用 MinIO 存储系统漏洞危害服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/926eab646708461ba71ab0129be4e884/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【IMX6ULL驱动开发学习】06.DHT11温湿度传感器驱动程序编写与测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>