<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>143.【Nginx-02】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="143.【Nginx-02】" />
<meta property="og:description" content="Nginx-02 (五)、Nginx负载均衡1.负载均衡概述2.负载均衡的原理及处理流程(1).负载均衡的作用 3.负载均衡常用的处理方式(1).用户手动选择(2).DNS轮询方式(3).四/七层负载均衡(4).Nginx七层负载均衡指令 ⭐(5).Nginx七层负载均衡的实现流程 ⭐ 4.负载均衡状态(1).down (停用)(2).backup (哨兵服务器)(3).max_conns(4).max_fails和fail_timeout 5.负载均衡策略(1).轮询(2).weight (轮询)(3).ip_hash (哈希主机定位)(4).least_conn (最少连接)(5).url_hash (哈希路径定位)(6).fair (智能) 6.负载均衡案例_七层(1).对所有请求实现一般轮询规则的负载均衡(2).对所有请求实现加权轮询规则的负载均衡(3).对特定资源实现负载均衡(4).对不同域名实现负载均衡(5).实现带有URL重写的负载均衡 7.负载均衡_四层(1).添加stream模块的支持(2).Nginx四层负载均衡的指令(3).四层负载均衡的案例_需求分析 (六)、Nginx缓存集成1.缓存的概念2.Nginx的web缓存服务3.Nginx缓存设置的相关指令(1).proxy_cache_path(2).proxy_cache(3).proxy_cache_key(4).proxy_cache_valid(5).proxy_cache_min_uses(6).proxy_cache_methods 4. Nginx缓存设置案例(1).需求分析(2).步骤实现(3).完整配置 5.Nginx缓存的清除(1).方式一: 删除对应的缓存目录(2).方式二: 使用第三方扩展模块 6.Nginx设置资源不缓存(1). `$cookie_nocache`、`$arg_nocache`、`$arg_comment`(2).示列 (七)、Nginx实现服务器端集群搭建1.Nginx与Tomcat部署(1).环境准备(Tomcat)(2).环境准备(Nginx) 2.Nginx实现动静分离(1).需求分析(2).动静分离实现步骤 3.Nginx实现Tomcat集群搭建(1).环境准备：(2).配置信息(3).测试tomcat集群 4.Nginx高可用解决方案(1).Keepalived(2).VRRP介绍(3).环境搭建 ⭐(4).下载 Keepalived(5).Keepalived配置文件介绍(6).keppalived 自定义配置 ⭐⭐(7).自定义配置后访问测试 ⭐⭐⭐(8).keepalived之自动切换脚本 5.Nginx制作下载站点(1).autoindex:启用或禁用目录列表输出(2).autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小(3).autoindex_format：设置目录列表的格式(4).autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。(4).测试 6.Nginx的用户认证模块(1).auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证(2).auth_basic_user_file:指定用户名和密码所在文件 (八)、Lua1.基本介绍(1).Lua的基本概念(2).Lua的特性(3).应用场景 2.Lua的安装与编译(1).找到Lua官网(2).进行编译与安装 3.Lua的语法(1).Lua的两种交互方式(2).Lua的注释(3).标识符(4).关键字(5).运算符(6).全局变量&amp;局部变量 4.Lua数据类型(1).nil (空值)(2).boolean (布尔)(3).number (数值)(4).string (字符串)(5).table (表)(6).function (函数)(7).thread (线程)(8).userdata (用户数据) 5.Lua控制结构(1).if then elseif else(2).while循环 (先判断在执行)(3).repeat循环 (先执行在判断条件)(4).for循环 (九)、ngx_lua模块概念1.ngx_lua模块环境准备(1).方式一:lua-nginx-module(2).方式二: OpenRestry (推荐⭐) 2.ngx_lua的使用(1).init_by_lua*(2).init_worker_by_lua*(3).set_by_lua*(4).rewrite_by_lua*(5).access_by_lua*(6).content_by_lua*(7).header_filter_by_lua*(8).body_filter_by_lua*(9).log_by_lua*(10).balancer_by_lua*(11).ssl_certificate_by_* (五)、Nginx负载均衡 1.负载均衡概述 早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？
2.负载均衡的原理及处理流程 系统的扩展可以分为纵向扩展和横向扩展。
纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力。横向扩展是通过添加机器来满足大型网站服务的处理能力。 这里面涉及到两个重要的角色分别是&#34;应用集群&#34;和&#34;负载均衡器&#34;。
应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。负载均衡器: 将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。 (1).负载均衡的作用 解决服务器的高并发压力，提高应用程序的处理性能。提供故障转移，实现高可用。通过添加或减少服务器数量，增强网站的可扩展性。在负载均衡器上进行过滤，可以提高系统的安全性。 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4fdae85afcfcecc64685a0d816301da5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-24T15:06:24+08:00" />
<meta property="article:modified_time" content="2023-12-24T15:06:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">143.【Nginx-02】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Nginx-02</h4> 
 <ul><li><a href="#Nginx_1" rel="nofollow">(五)、Nginx负载均衡</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.负载均衡概述</a></li><li><a href="#2_6" rel="nofollow">2.负载均衡的原理及处理流程</a></li><li><ul><li><ul><li><a href="#1_18" rel="nofollow">(1).负载均衡的作用</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_24" rel="nofollow">3.负载均衡常用的处理方式</a></li><li><ul><li><ul><li><a href="#1_25" rel="nofollow">(1).用户手动选择</a></li><li><a href="#2DNS_30" rel="nofollow">(2).DNS轮询方式</a></li><li><a href="#3_59" rel="nofollow">(3).四/七层负载均衡</a></li><li><a href="#4Nginx__102" rel="nofollow">(4).Nginx七层负载均衡指令 ⭐</a></li><li><a href="#5Nginx__117" rel="nofollow">(5).Nginx七层负载均衡的实现流程 ⭐</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4_173" rel="nofollow">4.负载均衡状态</a></li><li><ul><li><ul><li><a href="#1down___177" rel="nofollow">(1).down (停用)</a></li><li><a href="#2backup__196" rel="nofollow">(2).backup (哨兵服务器)</a></li><li><a href="#3max_conns_251" rel="nofollow">(3).max_conns</a></li><li><a href="#4max_failsfail_timeout_254" rel="nofollow">(4).max_fails和fail_timeout</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5_274" rel="nofollow">5.负载均衡策略</a></li><li><ul><li><ul><li><a href="#1_282" rel="nofollow">(1).轮询</a></li><li><a href="#2weight__301" rel="nofollow">(2).weight (轮询)</a></li><li><a href="#3ip_hash___320" rel="nofollow">(3).ip_hash (哈希主机定位)</a></li><li><a href="#4least_conn__347" rel="nofollow">(4).least_conn (最少连接)</a></li><li><a href="#5url_hash__370" rel="nofollow">(5).url_hash (哈希路径定位)</a></li><li><a href="#6fair__393" rel="nofollow">(6).fair (智能)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#6__509" rel="nofollow">6.负载均衡案例_七层</a></li><li><ul><li><ul><li><a href="#1_510" rel="nofollow">(1).对所有请求实现一般轮询规则的负载均衡</a></li><li><a href="#2_528" rel="nofollow">(2).对所有请求实现加权轮询规则的负载均衡</a></li><li><a href="#3_547" rel="nofollow">(3).对特定资源实现负载均衡</a></li><li><a href="#4_569" rel="nofollow">(4).对不同域名实现负载均衡</a></li><li><a href="#5URL_596" rel="nofollow">(5).实现带有URL重写的负载均衡</a></li></ul> 
   </li></ul> 
   </li><li><a href="#7__616" rel="nofollow">7.负载均衡_四层</a></li><li><ul><li><ul><li><a href="#1stream_622" rel="nofollow">(1).添加stream模块的支持</a></li><li><a href="#2Nginx_637" rel="nofollow">(2).Nginx四层负载均衡的指令</a></li><li><a href="#3__649" rel="nofollow">(3).四层负载均衡的案例_需求分析</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Nginx_652" rel="nofollow">(六)、Nginx缓存集成</a></li><li><ul><li><a href="#1_653" rel="nofollow">1.缓存的概念</a></li><li><a href="#2Nginxweb_677" rel="nofollow">2.Nginx的web缓存服务</a></li><li><a href="#3Nginx_683" rel="nofollow">3.Nginx缓存设置的相关指令</a></li><li><ul><li><ul><li><a href="#1proxy_cache_path_687" rel="nofollow">(1).proxy_cache_path</a></li><li><a href="#2proxy_cache_738" rel="nofollow">(2).proxy_cache</a></li><li><a href="#3proxy_cache_key_743" rel="nofollow">(3).proxy_cache_key</a></li><li><a href="#4proxy_cache_valid_747" rel="nofollow">(4).proxy_cache_valid</a></li><li><a href="#5proxy_cache_min_uses_760" rel="nofollow">(5).proxy_cache_min_uses</a></li><li><a href="#6proxy_cache_methods_763" rel="nofollow">(6).proxy_cache_methods</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4_Nginx_769" rel="nofollow">4. Nginx缓存设置案例</a></li><li><ul><li><ul><li><a href="#1_771" rel="nofollow">(1).需求分析</a></li><li><a href="#2_773" rel="nofollow">(2).步骤实现</a></li><li><a href="#3_875" rel="nofollow">(3).完整配置</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5Nginx_909" rel="nofollow">5.Nginx缓存的清除</a></li><li><ul><li><ul><li><a href="#1__910" rel="nofollow">(1).方式一: 删除对应的缓存目录</a></li><li><a href="#2__916" rel="nofollow">(2).方式二: 使用第三方扩展模块</a></li></ul> 
   </li></ul> 
   </li><li><a href="#6Nginx_1025" rel="nofollow">6.Nginx设置资源不缓存</a></li><li><ul><li><ul><li><a href="#1_cookie_nocachearg_nocachearg_comment_1056" rel="nofollow">(1). `$cookie_nocache`、`$arg_nocache`、`$arg_comment`</a></li><li><a href="#2_1112" rel="nofollow">(2).示列</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Nginx_1170" rel="nofollow">(七)、Nginx实现服务器端集群搭建</a></li><li><ul><li><a href="#1NginxTomcat_1171" rel="nofollow">1.Nginx与Tomcat部署</a></li><li><ul><li><ul><li><a href="#1Tomcat_1181" rel="nofollow">(1).环境准备(Tomcat)</a></li><li><a href="#2Nginx_1217" rel="nofollow">(2).环境准备(Nginx)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2Nginx_1239" rel="nofollow">2.Nginx实现动静分离</a></li><li><ul><li><ul><li><a href="#1_1257" rel="nofollow">(1).需求分析</a></li><li><a href="#2_1262" rel="nofollow">(2).动静分离实现步骤</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3NginxTomcat_1331" rel="nofollow">3.Nginx实现Tomcat集群搭建</a></li><li><ul><li><ul><li><a href="#1_1341" rel="nofollow">(1).环境准备：</a></li><li><a href="#2_1375" rel="nofollow">(2).配置信息</a></li><li><a href="#3tomcat_1396" rel="nofollow">(3).测试tomcat集群</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4Nginx_1404" rel="nofollow">4.Nginx高可用解决方案</a></li><li><ul><li><ul><li><a href="#1Keepalived_1411" rel="nofollow">(1).Keepalived</a></li><li><a href="#2VRRP_1414" rel="nofollow">(2).VRRP介绍</a></li><li><a href="#3__1433" rel="nofollow">(3).环境搭建 ⭐</a></li><li><a href="#4_Keepalived_1454" rel="nofollow">(4).下载 Keepalived</a></li><li><a href="#5Keepalived_1485" rel="nofollow">(5).Keepalived配置文件介绍</a></li><li><a href="#6keppalived___1669" rel="nofollow">(6).keppalived 自定义配置 ⭐⭐</a></li><li><a href="#7___1751" rel="nofollow">(7).自定义配置后访问测试 ⭐⭐⭐</a></li><li><a href="#8keepalived_1785" rel="nofollow">(8).keepalived之自动切换脚本</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5Nginx_1864" rel="nofollow">5.Nginx制作下载站点</a></li><li><ul><li><ul><li><a href="#1autoindex_1876" rel="nofollow">(1).autoindex:启用或禁用目录列表输出</a></li><li><a href="#2autoindex_exact_sizeHTLM_1880" rel="nofollow">(2).autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小</a></li><li><a href="#3autoindex_format_1885" rel="nofollow">(3).autoindex_format：设置目录列表的格式</a></li><li><a href="#4autoindex_localtimeHTML_1888" rel="nofollow">(4).autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。</a></li><li><a href="#4_1893" rel="nofollow">(4).测试</a></li></ul> 
   </li></ul> 
   </li><li><a href="#6Nginx_1931" rel="nofollow">6.Nginx的用户认证模块</a></li><li><ul><li><ul><li><a href="#1auth_basic_HTTP_1938" rel="nofollow">(1).auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证</a></li><li><a href="#2auth_basic_user_file_1942" rel="nofollow">(2).auth_basic_user_file:指定用户名和密码所在文件</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Lua_2009" rel="nofollow">(八)、Lua</a></li><li><ul><li><a href="#1_2010" rel="nofollow">1.基本介绍</a></li><li><ul><li><ul><li><a href="#1Lua_2011" rel="nofollow">(1).Lua的基本概念</a></li><li><a href="#2Lua_2014" rel="nofollow">(2).Lua的特性</a></li><li><a href="#3_2031" rel="nofollow">(3).应用场景</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2Lua_2036" rel="nofollow">2.Lua的安装与编译</a></li><li><ul><li><ul><li><a href="#1Lua_2037" rel="nofollow">(1).找到Lua官网</a></li><li><a href="#2_2043" rel="nofollow">(2).进行编译与安装</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3Lua_2080" rel="nofollow">3.Lua的语法</a></li><li><ul><li><ul><li><a href="#1Lua_2084" rel="nofollow">(1).Lua的两种交互方式</a></li><li><a href="#2Lua_2174" rel="nofollow">(2).Lua的注释</a></li><li><a href="#3_2200" rel="nofollow">(3).标识符</a></li><li><a href="#4_2203" rel="nofollow">(4).关键字</a></li><li><a href="#5_2210" rel="nofollow">(5).运算符</a></li><li><a href="#6_2299" rel="nofollow">(6).全局变量&amp;局部变量</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4Lua_2324" rel="nofollow">4.Lua数据类型</a></li><li><ul><li><ul><li><a href="#1nil__2353" rel="nofollow">(1).nil (空值)</a></li><li><a href="#2boolean__2356" rel="nofollow">(2).boolean (布尔)</a></li><li><a href="#3number__2359" rel="nofollow">(3).number (数值)</a></li><li><a href="#4string__2379" rel="nofollow">(4).string (字符串)</a></li><li><a href="#5table__2406" rel="nofollow">(5).table (表)</a></li><li><a href="#6function__2480" rel="nofollow">(6).function (函数)</a></li><li><a href="#7thread__2523" rel="nofollow">(7).thread (线程)</a></li><li><a href="#8userdata__2526" rel="nofollow">(8).userdata (用户数据)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5Lua_2529" rel="nofollow">5.Lua控制结构</a></li><li><ul><li><ul><li><a href="#1if_then_elseif_else_2531" rel="nofollow">(1).if then elseif else</a></li><li><a href="#2while__2569" rel="nofollow">(2).while循环 (先判断在执行)</a></li><li><a href="#3repeat__2590" rel="nofollow">(3).repeat循环 (先执行在判断条件)</a></li><li><a href="#4for_2610" rel="nofollow">(4).for循环</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#ngx_lua_2683" rel="nofollow">(九)、ngx_lua模块概念</a></li><li><ul><li><a href="#1ngx_lua_2686" rel="nofollow">1.ngx_lua模块环境准备</a></li><li><ul><li><ul><li><a href="#1luanginxmodule_2687" rel="nofollow">(1).方式一:lua-nginx-module</a></li><li><a href="#2_OpenRestry__2794" rel="nofollow">(2).方式二: OpenRestry (推荐⭐)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2ngx_lua_2837" rel="nofollow">2.ngx_lua的使用</a></li><li><ul><li><ul><li><a href="#1init_by_lua_2848" rel="nofollow">(1).init_by_lua*</a></li><li><a href="#2init_worker_by_lua_2851" rel="nofollow">(2).init_worker_by_lua*</a></li><li><a href="#3set_by_lua_2853" rel="nofollow">(3).set_by_lua*</a></li><li><a href="#4rewrite_by_lua_2856" rel="nofollow">(4).rewrite_by_lua*</a></li><li><a href="#5access_by_lua_2859" rel="nofollow">(5).access_by_lua*</a></li><li><a href="#6content_by_lua_2861" rel="nofollow">(6).content_by_lua*</a></li><li><a href="#7header_filter_by_lua_2864" rel="nofollow">(7).header_filter_by_lua*</a></li><li><a href="#8body_filter_by_lua_2866" rel="nofollow">(8).body_filter_by_lua*</a></li><li><a href="#9log_by_lua_2868" rel="nofollow">(9).log_by_lua*</a></li><li><a href="#10balancer_by_lua_2870" rel="nofollow">(10).balancer_by_lua*</a></li><li><a href="#11ssl_certificate_by__2872" rel="nofollow">(11).ssl_certificate_by_*</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Nginx_1"></a>(五)、Nginx负载均衡</h2> 
<h3><a id="1_2"></a>1.负载均衡概述</h3> 
<p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。<mark>那么如何将不同用户的请求流量分发到不同的服务器上呢</mark>？</p> 
<p><img src="https://images2.imgbox.com/ba/b0/XhDY3nwT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_6"></a>2.负载均衡的原理及处理流程</h3> 
<p>系统的扩展可以分为<code>纵向扩展</code>和<code>横向扩展</code>。</p> 
<ul><li>纵向扩展是从单机的角度出发，通过<code>增加系统的硬件处理能力</code>来提升服务器的处理能力。</li><li>横向扩展是通过<code>添加机器</code>来满足大型网站服务的处理能力。</li></ul> 
<p><img src="https://images2.imgbox.com/44/2f/Ca5botpx_o.png" alt="在这里插入图片描述"><br> 这里面涉及到两个重要的角色分别是"应用集群"和"负载均衡器"。</p> 
<ul><li><mark>应用集群</mark>：将<code>同一应用部署到多台机器上</code>，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。</li><li><mark>负载均衡器</mark>: 将用户访问的请求<code>根据对应的负载均衡算法</code>，分发到集群中的一台服务器进行处理。</li></ul> 
<h5><a id="1_18"></a>(1).负载均衡的作用</h5> 
<ol><li><mark>解决服务器的高并发压力</mark>，提高应用程序的处理性能。</li><li>提供故障转移，<mark>实现高可用</mark>。</li><li>通过添加或减少服务器数量，<mark>增强网站的可扩展性</mark>。</li><li>在负载均衡器上进行过滤，可以<mark>提高系统的安全性</mark>。</li></ol> 
<h3><a id="3_24"></a>3.负载均衡常用的处理方式</h3> 
<h5><a id="1_25"></a>(1).用户手动选择</h5> 
<p>这种方式比较原始，只要实现的方式就是在<code>网站主页上面提供不同线路、不同服务器链接方式</code>，让用户来选择自己访问的具体服务器，来实现负载均衡。</p> 
<p><img src="https://images2.imgbox.com/f8/8f/D3rQepMn_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2DNS_30"></a>(2).DNS轮询方式</h5> 
<p>DNS</p> 
<pre><code class="prism language-yaml">域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域
名与 IP 地址的相互转换。
</code></pre> 
<p><img src="https://images2.imgbox.com/06/f6/AsTrIkVN_o.png" alt="在这里插入图片描述"></p> 
<p><mark>大多域名注册商都支持对同一个主机名添加多条A记录 (也就是说一个域名可以绑定多个IP主机地址)</mark>，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。</p> 
<p><img src="https://images2.imgbox.com/ff/55/LS3vGB3l_o.png" alt="在这里插入图片描述"><br> 我们发现使用DNS来实现轮询，不需要投入过多的成本，虽然DNS轮询成本低廉，但是DNS负载均衡存在明显的缺点。</p> 
<p><img src="https://images2.imgbox.com/a9/9a/4iPg4sxe_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol><li>可靠性低</li></ol> 
</blockquote> 
<p>假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的IP从DNS中去掉，但是由于各大宽带接入商将众多的DNS存放在缓存中，以节省访问时间，导致DNS不会实时更新。所以DNS轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p> 
<blockquote> 
 <ol start="2"><li>负载均衡不均衡</li></ol> 
</blockquote> 
<p>DNS负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到IP地址的映射，这也会导致使用该DNS服务器的用户在一定时间内访问的是同一台Web服务器，从而引发Web服务器减的负载不均衡。</p> 
<p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p> 
<h5><a id="3_59"></a>(3).四/七层负载均衡</h5> 
<p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection),叫开放式系统互联模型，这个是由国际标准化组织ISO指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p> 
<p>两台电脑想要交互，需要先从应用层搭到物理层执行一遍，然后接收方再从物理层到应用层再执行一遍。</p> 
<p><img src="https://images2.imgbox.com/8d/c3/Eg4FzPhG_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li>应用层：为应用程序提供<mark>网络服务</mark>。 (QQ)</li><li>表示层：对数据<mark>进行格式化、编码、加密、压缩</mark>等操作。</li><li>会话层：建立、维护、管理会话连接。</li><li>传输层：建立、维护、管理<mark>端到端</mark>的连接，常见的有TCP/UDP。</li><li>网络层：<mark>IP寻址和路由选择</mark>。</li><li>数据链路层：控制<mark>网络层与物理层</mark>之间的通信。(光纤)</li><li>物理层：<mark>比特流传输</mark>。(信息)</li></ul> 
<p>所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于<code>IP+PORT</code> 的负载均衡。</p> 
<pre><code class="prism language-yaml">实现四层负载均衡的方式：
硬件：F5 BIG<span class="token punctuation">-</span>IP、Radware等
软件：LVS、Nginx、Hayproxy等
</code></pre> 
<p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡</p> 
<pre><code class="prism language-yaml">实现七层负载均衡的方式：
软件：Nginx、Hayproxy等
</code></pre> 
<p>四层和七层负载均衡的区别</p> 
<pre><code class="prism language-yaml">四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在
最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高。
四层负载均衡不识别域名，而七层负载均衡识别域名。
</code></pre> 
<p>处理四层和七层负载以为其实还有二层、三层负载均衡，二层是在 <code>数据链路层基于mac地址</code> 来实现负载均衡，三层是在网络层一般采用<code> 虚拟IP地址</code> 的方式实现负载均衡。</p> 
<p>实际环境采用的模式</p> 
<pre><code class="prism language-yaml">四层负载(LVS)+七层负载(Nginx)
</code></pre> 
<h5><a id="4Nginx__102"></a>(4).Nginx七层负载均衡指令 ⭐</h5> 
<p>Nginx要实现七层负载均衡需要用到 <code>proxy_pass</code> 代理模块配置。<mark>Nginx默认安装支持这个模块，我们不需要再做任何处理</mark>。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组【upstream虚拟服务池】。</p> 
<blockquote> 
 <ol><li>upstream指令</li></ol> 
</blockquote> 
<p>该指令是<code>用来定义一组服务器</code>，它们可以是<code>监听不同端口的服务器</code>，并且也可以是同时监听 TCP和Unix socke t的服务器。服务器可以指定不同的权重，默认为1。<br> <img src="https://images2.imgbox.com/5f/68/cTKea92e_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>server指令</li></ol> 
</blockquote> 
<p>该指令用来指定后端服务器的名称和一些参数，可以使用<code>域名、IP、端口或者unix socket</code></p> 
<p><img src="https://images2.imgbox.com/2c/f4/QgMAz2Or_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5Nginx__117"></a>(5).Nginx七层负载均衡的实现流程 ⭐</h5> 
<p><img src="https://images2.imgbox.com/4d/d3/sGOmsDty_o.png" alt="在这里插入图片描述"><br> 服务端配置:</p> 
<pre><code class="prism language-yaml">	server <span class="token punctuation">{<!-- --></span>
                listen 8081;
                server_name localhost;
                default_type text/html;
                location / <span class="token punctuation">{<!-- --></span>
                        return 200 '&lt;h1<span class="token punctuation">&gt;</span>8.130.48.9<span class="token punctuation">:</span>8081&lt;/h1<span class="token punctuation">&gt;</span>';
                <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen 8082;
                server_name localhost;
                default_type text/html;
                location / <span class="token punctuation">{<!-- --></span>
                        return 200 '&lt;h1<span class="token punctuation">&gt;</span>8.130.48.9<span class="token punctuation">:</span>8082&lt;/h1<span class="token punctuation">&gt;</span>';
                <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen 8083;
                server_name localhost;
                default_type text/html;
                location / <span class="token punctuation">{<!-- --></span>
                        return 200 '&lt;h1<span class="token punctuation">&gt;</span>8.130.48.9<span class="token punctuation">:</span>8083&lt;/h1<span class="token punctuation">&gt;</span>';
                <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>

</code></pre> 
<p>负载均衡服务端(代理服务端)</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7a/a8/SMivPm2h_o.png" alt="在这里插入图片描述"></p> 
<p>测试: <a href="http://8.130.48.9:8084/" rel="nofollow">http://8.130.48.9:8084/</a></p> 
<p><img src="https://images2.imgbox.com/77/6a/jFLZv9op_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_173"></a>4.负载均衡状态</h3> 
<p>代理服务器在负责均衡调度中的状态有以下几个：</p> 
<p><img src="https://images2.imgbox.com/3f/05/Tho2Z36g_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1down___177"></a>(1).down (停用)</h5> 
<p>down:将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 在我们的服务组中设置状态</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9001 down;
	server 192.168.200.146<span class="token punctuation">:</span><span class="token number">9002</span>
	server 192.168.200.146<span class="token punctuation">:</span>9003;
<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8083;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该状态一般会对需要停机维护的服务器进行设置</p> 
<h5><a id="2backup__196"></a>(2).backup (哨兵服务器)</h5> 
<p>将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 在我们的服务组中设置状态</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9001 down;
	server 192.168.200.146<span class="token punctuation">:</span>9002 backup;
	server 192.168.200.146<span class="token punctuation">:</span>9003;
<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8083;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时需要将9093端口的访问禁止掉来模拟下唯一能对外提供访问的服务宕机以后，<code>backup的备份服务器9002就要开始对外提供服务</code>，<code>如果主服务器9003没有宕机的话，那么备份服务(9002)是不参与服务提供的，如果主服务器一段时间后又恢复了，那么备份服务器(9002)会将权力还给主服务器(9003)</code>，假如说此时为了测试验证，我们需要使用防火墙来进行拦截。</p> 
<p>介绍一个工具firewall-cmd ,该工具是Linux提供的专门用来操作<br> firewall的。</p> 
<p>查询防火墙中指定的端口是否开放</p> 
<pre><code class="prism language-yaml">firewall<span class="token punctuation">-</span>cmd <span class="token punctuation">-</span><span class="token punctuation">-</span>query<span class="token punctuation">-</span>port=9001/tcp
</code></pre> 
<p>如何开放一个指定的端口</p> 
<pre><code class="prism language-yaml">firewall<span class="token punctuation">-</span>cmd <span class="token punctuation">-</span><span class="token punctuation">-</span>permanent <span class="token punctuation">-</span><span class="token punctuation">-</span>add<span class="token punctuation">-</span>port=9002/tcp
</code></pre> 
<p>批量添加开发端口</p> 
<pre><code class="prism language-yaml">firewall<span class="token punctuation">-</span>cmd <span class="token punctuation">-</span><span class="token punctuation">-</span>permanent <span class="token punctuation">-</span><span class="token punctuation">-</span>add<span class="token punctuation">-</span>port=9001<span class="token punctuation">-</span>9003/tcp
</code></pre> 
<p>如何移除一个指定的端口</p> 
<pre><code class="prism language-yaml">firewall<span class="token punctuation">-</span>cmd <span class="token punctuation">-</span><span class="token punctuation">-</span>permanent <span class="token punctuation">-</span><span class="token punctuation">-</span>remove<span class="token punctuation">-</span>port=9003/tcp
</code></pre> 
<p>重新加载</p> 
<pre><code class="prism language-yaml">firewall<span class="token punctuation">-</span>cmd <span class="token punctuation">-</span><span class="token punctuation">-</span>reload
</code></pre> 
<p>其中</p> 
<ul><li>–permanent表示设置为持久</li><li>–add-port表示添加指定端口</li><li>–remove-port表示移除指定端口</li></ul> 
<h5><a id="3max_conns_251"></a>(3).max_conns</h5> 
<p>用来设置代理服务器<code>同时活动链接的最大数量</code>，默认为0，表示不限制，使用该配置<code>可以根据后端服务器处理请求的并发量来进行设置</code>，防止后端服务器被压垮。</p> 
<h5><a id="4max_failsfail_timeout_254"></a>(4).max_fails和fail_timeout</h5> 
<ul><li>max_fails=number:设置允许请求代理服务器失败的次数，默认为1。</li><li>fail_timeout=time:设置经过max_fails失败后，服务暂停的时间，默认是10秒。</li></ul> 
<pre><code class="prism language-yaml">upstream backend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.133<span class="token punctuation">:</span>9001 down;
	server 192.168.200.133<span class="token punctuation">:</span>9002 backup;
	server 192.168.200.133<span class="token punctuation">:</span>9003 max_fails=3 fail_timeout=15;
<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8083;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果说9003服务器出现三次问题宕机了，那么先暂停15秒这个主服务器的服务，把提供服务的权利让给其他服务器，如果说在15秒内这个服务器能启动了，那么这个主服务器仍然不能提供服务，直到15秒时间过了，才能恢复服务。假如说我们超过了15秒问题依然没解决，那么9003服务器再停机15秒。</p> 
<h3><a id="5_274"></a>5.负载均衡策略</h3> 
<p>介绍完Nginx负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法?</p> 
<p>Nginx的upstream支持如下六种方式的分配算法，分别是:</p> 
<p><img src="https://images2.imgbox.com/bc/b5/Zl38kkh6_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_282"></a>(1).轮询</h5> 
<p>是upstream模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2weight__301"></a>(2).weight (轮询)</h5> 
<p><mark>用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大</mark>；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 8.130.48.9<span class="token punctuation">:</span>8081 weight=10;
	server 8.130.48.9<span class="token punctuation">:</span>8082 weight=5;
	server 8.130.48.9<span class="token punctuation">:</span>8083 weight=3;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3ip_hash___320"></a>(3).ip_hash (哈希主机定位)</h5> 
<p>当对后端的多台动态应用服务器做负载均衡时，<mark>ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上</mark>。这样，当来自某一个IP的用户在后端Web服务器A上登录后，在访问该站点的其他URL，能保证其访问的还是后端web服务器A。</p> 
<p><img src="https://images2.imgbox.com/0b/4e/6yOdqAcs_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	ip_hash;
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/03/vyHgk3LL_o.png" alt="在这里插入图片描述"><br> 需要额外多说一点的是使用 <code>ip_hash</code> 指令无法保证后端服务器的负载均衡，<code>可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少</code>，而且设置后端服务器权重等方法将不起作用。</p> 
<p>正解: 使用我们的Redis缓存的操作。<br> <img src="https://images2.imgbox.com/76/18/JjNCVSzM_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4least_conn__347"></a>(4).least_conn (最少连接)</h5> 
<p><mark>最少连接，把请求转发给连接数较少的后端服务器</mark>。轮询算法是把请求<strong>平均</strong>的转发给各个后端，使它们的负载大致相同；<mark>但是，有些请求占用的时间很长，会导致其所在的后端负载较高。如果继续采用轮询算法的话，那么服务器也会进行崩溃的，这种情况下，least_conn这种方式就可以达到更好的负载均衡效果</mark>。</p> 
<p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。<br> <img src="https://images2.imgbox.com/33/cf/jxBc0Al9_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	least_conn;
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="5url_hash__370"></a>(5).url_hash (哈希路径定位)</h5> 
<p><mark>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用</mark>。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。<mark>而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取</mark>。</p> 
<p><img src="https://images2.imgbox.com/c8/0f/z2GkXx9i_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	hash <span class="token important">&amp;request_uri;</span>
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="6fair__393"></a>(6).fair (智能)</h5> 
<p>fair采用的不是内建负载均衡使用的轮换的均衡算法，而是<mark>可以根据页面大小、加载时间长短智能的进行负载均衡</mark>。那么如何使用第三方模块的fair负载均衡策略。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	fair;
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是如何直接使用会报错，因为fair属于第三方模块实现的负载均衡。需要添加 <code>nginx-upstream-fair</code> ,如何添加对应的模块:</p> 
<blockquote> 
 <ol><li>安装支持</li></ol> 
</blockquote> 
<p>下载地址为: <a href="https://github.com/gnosek/nginx-upstream-fair">https://github.com/gnosek/nginx-upstream-fair</a></p> 
<p><img src="https://images2.imgbox.com/8c/77/oGUmMbWX_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.创建目录</span>
cd /root
mkdir model
cd model
</code></pre> 
<p><img src="https://images2.imgbox.com/78/11/7vRrFI0o_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 2.解压压缩包 (zip压缩包)</span>
unzip nginx<span class="token punctuation">-</span>upstream<span class="token punctuation">-</span>fair<span class="token punctuation">-</span>master.zip
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/2c/EfMAUvrc_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 3.名字有点长，改个短点的名字</span>
mv nginx<span class="token punctuation">-</span>upstream<span class="token punctuation">-</span>fair<span class="token punctuation">-</span>master fair
</code></pre> 
<p><img src="https://images2.imgbox.com/33/1f/zBH7JixM_o.png" alt="在这里插入图片描述"><br> <code>fari所在的文件位置: /root/model/fair</code></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 4.进入我们的nginx目录下</span>
cd /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1/
<span class="token comment"># 5.查看我们以前的配置</span>
<span class="token punctuation">[</span>root@Jsxs nginx<span class="token punctuation">-</span>1.16.1<span class="token punctuation">]</span><span class="token comment"># nginx -V</span>
<span class="token key atrule">nginx version</span><span class="token punctuation">:</span> nginx/1.16.1
built by gcc 10.2.1 20200825 (Alibaba 10.2.1<span class="token punctuation">-</span>3.5 2.32) (GCC)
built with OpenSSL 1.1.1k  FIPS 25 Mar 2021
TLS SNI support enabled
<span class="token key atrule">configure arguments</span><span class="token punctuation">:</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>prefix=/usr/local/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>sbin<span class="token punctuation">-</span>path=/usr/local/nginx/sbin/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>modules<span class="token punctuation">-</span>path=/usr/local/nginx/modules <span class="token punctuation">-</span><span class="token punctuation">-</span>conf<span class="token punctuation">-</span>path=/usr/local/nginx/conf/nginx.conf <span class="token punctuation">-</span><span class="token punctuation">-</span>error<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/error.log <span class="token punctuation">-</span><span class="token punctuation">-</span>http<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/access.log <span class="token punctuation">-</span><span class="token punctuation">-</span>pid<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.pid <span class="token punctuation">-</span><span class="token punctuation">-</span>lock<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.lock <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_gzip_static_module <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_ssl_module
<span class="token comment"># 6.然后执行重新安装 :新增-&gt;  --add-module=/root/model/fair</span>
./configure <span class="token punctuation">-</span><span class="token punctuation">-</span>prefix=/usr/local/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>sbin<span class="token punctuation">-</span>path=/usr/local/nginx/sbin/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>modules<span class="token punctuation">-</span>path=/usr/local/nginx/modules <span class="token punctuation">-</span><span class="token punctuation">-</span>conf<span class="token punctuation">-</span>path=/usr/local/nginx/conf/nginx.conf <span class="token punctuation">-</span><span class="token punctuation">-</span>error<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/error.log <span class="token punctuation">-</span><span class="token punctuation">-</span>http<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/access.log <span class="token punctuation">-</span><span class="token punctuation">-</span>pid<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.pid <span class="token punctuation">-</span><span class="token punctuation">-</span>lock<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.lock <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_gzip_static_module <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_ssl_module <span class="token punctuation">-</span><span class="token punctuation">-</span>add<span class="token punctuation">-</span>module=/root/model/fair
<span class="token comment"># 7.进行编译: </span>
make
</code></pre> 
<p><img src="https://images2.imgbox.com/df/82/A0etBiLI_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>解决报错问题</li></ol> 
</blockquote> 
<p>在Nginx的源码中 <code>src/http/ngx_http_upstream.h</code>,找到<code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加 <code>default_port</code>属性。</p> 
<pre><code class="prism language-yaml">in_port_t default_port
</code></pre> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.重写指定文件</span>
vim /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1/src/http/ngx_http_upstream.h
<span class="token comment"># 2.查找 ngx_http_upstream_srv_conf_s</span>
/ngx_http_upstream_srv_conf_s
<span class="token comment"># 3.然后回车按 n 找到一个结构体</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/18/TrUsXGuD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment">#4. 添加属性</span>
in_port_t            default_port;
</code></pre> 
<p><img src="https://images2.imgbox.com/c2/03/AEwkO9ji_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 5.回退到根目录</span>
cd /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1
<span class="token comment"># 6.重新执行编译</span>
make
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/b4/wLHswYyH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 7.将旧的nginx进行备份</span>
mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold;
<span class="token comment"># 8.make成功后会生成一个objs目录，里面放有新的nginx运行文件</span>
cd /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1/objs
cp nginx /usr/local/nginx/sbin
<span class="token comment"># 9.回退到根目录</span>
cd /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1
<span class="token comment"># 10.进行平滑升级</span>
make upgrade
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/0e/wuh5JCtr_o.png" alt="在这里插入图片描述"></p> 
<p>测试: <a href="http://8.130.48.9:8084/" rel="nofollow">http://8.130.48.9:8084/</a><br> <img src="https://images2.imgbox.com/53/7d/gV9xw2SY_o.png" alt="在这里插入图片描述"><br> 上面介绍了Nginx常用的负载均衡的策略，有人说是5种，是把轮询和加权轮询归为一种，也有人说是6种。那么在咱们以后的开发中到底使用哪种，这个需要根据实际项目的应用场景来决定的。</p> 
<h3><a id="6__509"></a>6.负载均衡案例_七层</h3> 
<h5><a id="1_510"></a>(1).对所有请求实现一般轮询规则的负载均衡</h5> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 8.130.48.9<span class="token punctuation">:</span>8081;
	server 8.130.48.9<span class="token punctuation">:</span>8082;
	server 8.130.48.9<span class="token punctuation">:</span>8083;
<span class="token punctuation">}</span>
<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_528"></a>(2).对所有请求实现加权轮询规则的负载均衡</h5> 
<pre><code class="prism language-yaml"><span class="token comment"># 这里是配置我们的服务组⭐</span>
upstream backend<span class="token punctuation">{<!-- --></span>
	server 8.130.48.9<span class="token punctuation">:</span>8081 weight=10;
	server 8.130.48.9<span class="token punctuation">:</span>8082 weight=5;
	server 8.130.48.9<span class="token punctuation">:</span>8083 weight=3;
<span class="token punctuation">}</span>

<span class="token comment"># 服务组名称为 backend⭐</span>
server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /<span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_547"></a>(3).对特定资源实现负载均衡</h5> 
<pre><code class="prism language-yaml">upstream videobackend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9001;
	server 192.168.200.146<span class="token punctuation">:</span>9002;
<span class="token punctuation">}</span>
upstream filebackend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9003;
	server 192.168.200.146<span class="token punctuation">:</span>9004;
<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8084;
	server_name localhost;
	location /video/ <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//videobackend;
		<span class="token punctuation">}</span>
	location /file/ <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//filebackend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_569"></a>(4).对不同域名实现负载均衡</h5> 
<pre><code class="prism language-yaml">upstream itcastbackend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9001;
	server 192.168.200.146<span class="token punctuation">:</span>9002;
<span class="token punctuation">}</span>
upstream itheimabackend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9003;
	server 192.168.200.146<span class="token punctuation">:</span>9004;
<span class="token punctuation">}</span>

server <span class="token punctuation">{<!-- --></span>
	listen 8085;
	server_name www.itcast.cn;
	location / <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//itcastbackend;
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8086;
	server_name www.itheima.cn;
	location / <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//itheimabackend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="5URL_596"></a>(5).实现带有URL重写的负载均衡</h5> 
<pre><code class="prism language-yaml">upstream backend<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>9001;
	server 192.168.200.146<span class="token punctuation">:</span>9002;
	server 192.168.200.146<span class="token punctuation">:</span>9003;
<span class="token punctuation">}</span>

server <span class="token punctuation">{<!-- --></span>
	listen 80;
	server_name localhost;
	location /file/ <span class="token punctuation">{<!-- --></span>
		rewrite ^(/file/.<span class="token important">*)</span> /server/$1 last;
	<span class="token punctuation">}</span>
	location / <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token punctuation">:</span>//backend;
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7__616"></a>7.负载均衡_四层</h3> 
<p><code>Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等</code>。<mark>stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听</mark>，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p> 
<p>四层协议负载均衡的实现，一般都会用到 <code>LVS、HAProxy、F5</code>等，要么很贵要么配置很麻烦，而Nginx的配置相对来说更简单，更能快速完成工作。</p> 
<h5><a id="1stream_622"></a>(1).添加stream模块的支持</h5> 
<p>Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上 <code>--with-stream</code>。</p> 
<p>完成添加 <code>--with-stream</code> 的实现步骤:</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.执行配置 : 这里多添加了--with-stream</span>
./configure <span class="token punctuation">-</span><span class="token punctuation">-</span>prefix=/usr/local/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>sbin<span class="token punctuation">-</span>path=/usr/local/nginx/sbin/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>modules<span class="token punctuation">-</span>path=/usr/local/nginx/modules <span class="token punctuation">-</span><span class="token punctuation">-</span>conf<span class="token punctuation">-</span>path=/usr/local/nginx/conf/nginx.conf <span class="token punctuation">-</span><span class="token punctuation">-</span>error<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/error.log <span class="token punctuation">-</span><span class="token punctuation">-</span>http<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/access.log <span class="token punctuation">-</span><span class="token punctuation">-</span>pid<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.pid <span class="token punctuation">-</span><span class="token punctuation">-</span>lock<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.lock <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_gzip_static_module <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_ssl_module <span class="token punctuation">-</span><span class="token punctuation">-</span>add<span class="token punctuation">-</span>module=/root/model/fair <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>stream
<span class="token comment"># 2.执行编译</span>
make

<span class="token punctuation">...</span>
<span class="token punctuation">...</span>
<span class="token punctuation">...</span>
</code></pre> 
<h5><a id="2Nginx_637"></a>(2).Nginx四层负载均衡的指令</h5> 
<blockquote> 
 <ol><li>stream指令</li></ol> 
</blockquote> 
<p>该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。</p> 
<p><img src="https://images2.imgbox.com/0d/56/hSpX1dw3_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>upstream指令</li></ol> 
</blockquote> 
<p>该指令和http的upstream指令是类似的。</p> 
<h5><a id="3__649"></a>(3).四层负载均衡的案例_需求分析</h5> 
<p><img src="https://images2.imgbox.com/52/d0/2nKPCzCJ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Nginx_652"></a>(六)、Nginx缓存集成</h2> 
<h3><a id="1_653"></a>1.缓存的概念</h3> 
<p><mark>缓存就是数据交换的缓冲区(称作:Cache)</mark>, 当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。</p> 
<p><img src="https://images2.imgbox.com/36/12/s4qMKj1T_o.png" alt="在这里插入图片描述"><br> 缓存其实在很多场景中都有用到，比如：</p> 
<p><img src="https://images2.imgbox.com/38/e2/uEKPxeDD_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol><li>缓存的优点</li></ol> 
</blockquote> 
<ol><li>减少数据传输，节省网络流量，加快响应速度，提升用户体验；</li><li>减轻服务器压力；</li><li>提供服务端的高可用性；</li></ol> 
<blockquote> 
 <ol start="2"><li>缓存的缺点</li></ol> 
</blockquote> 
<ol><li>数据的同步不一致。</li><li>增加成本。</li></ol> 
<p><img src="https://images2.imgbox.com/d9/65/SR5IM9uM_o.png" alt="在这里插入图片描述"><br> <mark>Nginx作为web服务器，Nginx作为Web缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个URL时，web缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个URL，web缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求</mark>。web缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。</p> 
<h3><a id="2Nginxweb_677"></a>2.Nginx的web缓存服务</h3> 
<p><mark>Nginx是从0.7.48版开始提供缓存功能</mark>。Nginx是基于Proxy Store来实现的，<code>1.其原理是把URL及相关组合当做Key,2.在使用MD5算法对Key进行哈希，3.得到硬盘上对应的哈希目录路径，4.从而将缓存内容保存在该目录中</code>。<mark>它可以支持任意URL连接，同时也支持404/301/302这样的非200状态码</mark>。Nginx即可以支持对指定URL或者状态码设置过期时间，也可以使用purge命令来手动清除指定URL的缓存。</p> 
<p><img src="https://images2.imgbox.com/29/23/otk3LhnU_o.png" alt="在这里插入图片描述"><br> 判断缓存目录中是否存在，假如不存在的话那么就转向访问应用服务器，应用服务器在返回之前，先保留一份数据给我们的Nginx缓存。</p> 
<h3><a id="3Nginx_683"></a>3.Nginx缓存设置的相关指令</h3> 
<p>Nginx的web缓存服务主要是使用<code>ngx_http_proxy_module</code>模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。</p> 
<h5><a id="1proxy_cache_path_687"></a>(1).proxy_cache_path</h5> 
<p>该指定用于设置缓存文件的存放路径</p> 
<p><img src="https://images2.imgbox.com/6b/bf/YbKoPemI_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol><li>path:缓存路径地址,如：</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache
</code></pre> 
<blockquote> 
 <ol start="2"><li>levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2如 :</li></ol> 
</blockquote> 
<pre><code class="prism language-java">levels<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span> 缓存空间有两层目录，第一次是<span class="token number">1</span>个字母，第二次是<span class="token number">2</span>个字母

举例说明<span class="token operator">:</span>
itheima<span class="token punctuation">[</span>key<span class="token punctuation">]</span>通过<span class="token constant">MD5</span>加密以后的值为 <span class="token number">43</span>c8233266edce38c2c9af0694e2107d
levels<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span> 最终的存储路径为 <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache<span class="token operator">/</span>d<span class="token operator">/</span><span class="token number">07</span>
levels<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span> 最终的存储路径为 <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache<span class="token operator">/</span><span class="token number">7d</span><span class="token operator">/</span><span class="token number">0</span><span class="token operator">/</span><span class="token number">21</span>
levels<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">2</span> 最终的存储路径为 <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache<span class="token operator">/</span><span class="token number">7d</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">/</span>e2
</code></pre> 
<blockquote> 
 <ol start="3"><li>keys_zone:用来为这个缓存区设置名称和指定大小，如：</li></ol> 
</blockquote> 
<pre><code class="prism language-java">keys_zone<span class="token operator">=</span>itcast<span class="token operator">:</span><span class="token number">200</span>m 缓存区的名称是itcast<span class="token punctuation">,</span>大小为<span class="token number">200</span>M<span class="token punctuation">,</span><span class="token number">1</span>M大概能存储<span class="token number">8000</span>个keys
</code></pre> 
<blockquote> 
 <ol start="4"><li>inactive:指定缓存的数据多次时间未被访问就将被删除，如：</li></ol> 
</blockquote> 
<pre><code class="prism language-java">inactive<span class="token operator">=</span><span class="token number">1d</span> 缓存数据在<span class="token number">1</span>天内没有被访问就会被删除
</code></pre> 
<blockquote> 
 <ol start="5"><li>max_size:设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如:</li></ol> 
</blockquote> 
<pre><code class="prism language-java">max_size<span class="token operator">=</span><span class="token number">20</span>g
</code></pre> 
<blockquote> 
 <p>完整配置示列: ⭐</p> 
</blockquote> 
<pre><code class="prism language-java">proxy_cache_path <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache levels<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">1</span> keys_zone<span class="token operator">=</span>itcast<span class="token operator">:</span><span class="token number">200</span>m inactive<span class="token operator">=</span><span class="token number">1d</span> max_size<span class="token operator">=</span><span class="token number">20</span>g<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d0/29/TgDdApTN_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2proxy_cache_738"></a>(2).proxy_cache</h5> 
<p>该指令用来<mark>开启或关闭代理缓存</mark>，如果是开启则自定使用哪个缓存区来进行缓存。</p> 
<p><img src="https://images2.imgbox.com/70/24/FSjuVVXw_o.png" alt="在这里插入图片描述"><br> zone_name：指定使用缓存区的名称</p> 
<h5><a id="3proxy_cache_key_743"></a>(3).proxy_cache_key</h5> 
<p>该指令<mark>用来设置web缓存的key值</mark>，Nginx会根据key值MD5哈希存缓存。</p> 
<p><img src="https://images2.imgbox.com/27/ce/b346qpOh_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4proxy_cache_valid_747"></a>(4).proxy_cache_valid</h5> 
<p><mark>该指令用来对不同返回状态码的URL设置不同的缓存时间</mark></p> 
<p><img src="https://images2.imgbox.com/a7/a5/b8YBcvk3_o.png" alt="在这里插入图片描述"><br> 如：</p> 
<pre><code class="prism language-java">proxy_cache_valid <span class="token number">200</span> <span class="token number">302</span> <span class="token number">10</span>m<span class="token punctuation">;</span>
proxy_cache_valid <span class="token number">404</span> <span class="token number">1</span>m<span class="token punctuation">;</span>
为<span class="token number">200</span>和<span class="token number">302</span>的响应<span class="token constant">URL</span>设置<span class="token number">10</span>分钟缓存，为<span class="token number">404</span>的响应<span class="token constant">URL</span>设置<span class="token number">1</span>分钟缓存
proxy_cache_valid any <span class="token number">1</span>m<span class="token punctuation">;</span>
对所有响应状态码的<span class="token constant">URL</span>都设置<span class="token number">1</span>分钟缓存
</code></pre> 
<h5><a id="5proxy_cache_min_uses_760"></a>(5).proxy_cache_min_uses</h5> 
<p>该指令用来设置资源被访问多少次后被缓存<br> <img src="https://images2.imgbox.com/30/4c/b0a2duKe_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="6proxy_cache_methods_763"></a>(6).proxy_cache_methods</h5> 
<p>该指令用户设置缓存哪些HTTP方法</p> 
<p><img src="https://images2.imgbox.com/2a/96/AqVNwC93_o.png" alt="在这里插入图片描述"><br> 默认缓存HTTP的GET和HEAD方法，不缓存POST方法。</p> 
<h3><a id="4_Nginx_769"></a>4. Nginx缓存设置案例</h3> 
<h5><a id="1_771"></a>(1).需求分析</h5> 
<p><img src="https://images2.imgbox.com/fb/4a/Ir2eG1Zv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_773"></a>(2).步骤实现</h5> 
<blockquote> 
 <p>第一步: 环境准备</p> 
</blockquote> 
<ul><li>应用服务器的环境准备 (8080端口) ⭐</li></ul> 
<ol><li>在8.130.48.9 服务器上的tomcat的webapps下面添加一个js目录，并在js目录中添加一个jquery.js文件</li><li>启动 tomcat</li><li>访问测试</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 进入我们的tomcat目录</span>
cd /usr/tomcat/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>9.0.84/webapps
<span class="token comment"># 创建js文件夹，并且在js文件中写入我们的jquery.js</span>
mkdir js
<span class="token comment"># 进入我们的bin目录</span>
cd /usr/tomcat/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>9.0.84/bin
<span class="token comment"># 重新启动我们的项目</span>
./startup.sh
</code></pre> 
<p><a href="http://8.130.48.9:8080/js/jquery-3.6.1.js" rel="nofollow">http://8.130.48.9:8080/js/jquery-3.6.1.js</a></p> 
<p><img src="https://images2.imgbox.com/49/43/g5gkhntQ_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Nginx的环境准备 (8081端口) ⭐</li></ul> 
<pre><code class="prism language-java">        proxy_cache_path <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache levels<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">1</span> keys_zone<span class="token operator">=</span>itcast<span class="token operator">:</span><span class="token number">200</span>m inactive<span class="token operator">=</span><span class="token number">1d</span> max_size<span class="token operator">=</span><span class="token number">20</span>g<span class="token punctuation">;</span>


        upstream backend <span class="token punctuation">{<!-- --></span>
                server <span class="token number">8.130</span><span class="token number">.48</span><span class="token number">.9</span><span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen <span class="token number">8081</span><span class="token punctuation">;</span>
                server_name localhost<span class="token punctuation">;</span>
                location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
                        proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token operator">/</span>js<span class="token operator">/</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/3e/60/mNLIJNwM_o.png" alt="在这里插入图片描述"></p> 
<p><a href="http://8.130.48.9:8081/jquery-3.6.1.js" rel="nofollow">http://8.130.48.9:8081/jquery-3.6.1.js</a></p> 
<p><img src="https://images2.imgbox.com/5d/ea/IrGriZLh_o.png" alt="在这里插入图片描述"></p> 
<ul><li>完成Nginx缓存配置 ⭐</li></ul> 
<pre><code class="prism language-yaml">proxy_cache_path /usr/local/proxy_cache levels=2<span class="token punctuation">:</span>1 keys_zone=itcast<span class="token punctuation">:</span>200m inactive=1d max_size=20g;


        upstream backend <span class="token punctuation">{<!-- --></span>
                server 8.130.48.9<span class="token punctuation">:</span>8080;
        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen 8081;
                server_name localhost;
                location / <span class="token punctuation">{<!-- --></span>
                	<span class="token comment"># 对应缓存文件夹的名字</span>
                        proxy_cache itcast;
                    <span class="token comment"># 访问的路径    </span>
                        proxy_cache_key 127.0.0.1;
                    <span class="token comment"># 当状态码为200的时候 缓存5天    </span>
                        proxy_cache_valid 200 5d;
                        proxy_pass http<span class="token punctuation">:</span>//backend/js/;
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/15/a4/dbo4kd49_o.png" alt="在这里插入图片描述"></p> 
<p><a href="http://8.130.48.9:8081/jquery-3.6.1.js" rel="nofollow">http://8.130.48.9:8081/jquery-3.6.1.js</a></p> 
<p><img src="https://images2.imgbox.com/73/c6/yLMCSNDr_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在消息头显示是否使用了缓存</li></ul> 
<pre><code class="prism language-java"> proxy_cache_path <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache levels<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">1</span> keys_zone<span class="token operator">=</span>itcast<span class="token operator">:</span><span class="token number">200</span>m inactive<span class="token operator">=</span><span class="token number">1d</span> max_size<span class="token operator">=</span><span class="token number">20</span>g<span class="token punctuation">;</span>


        upstream backend <span class="token punctuation">{<!-- --></span>
                server <span class="token number">8.130</span><span class="token number">.48</span><span class="token number">.9</span><span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen <span class="token number">8081</span><span class="token punctuation">;</span>
                server_name localhost<span class="token punctuation">;</span>
                location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
                        proxy_cache itcast<span class="token punctuation">;</span>
                        proxy_cache_key <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">;</span>
                        proxy_cache_valid <span class="token number">200</span> <span class="token number">5d</span><span class="token punctuation">;</span>
                        add_header nginx<span class="token operator">-</span>cache <span class="token string">"$upstream_cache_status"</span><span class="token punctuation">;</span>
                        proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token operator">/</span>js<span class="token operator">/</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/dd/eoiIUcag_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3b/f1/OMEGvamy_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_875"></a>(3).完整配置</h5> 
<pre><code class="prism language-yaml">http<span class="token punctuation">{<!-- --></span>
	proxy_cache_path /usr/local/proxy_cache
	levels=2<span class="token punctuation">:</span>1 keys_zone=itcast<span class="token punctuation">:</span>200m inactive=1d
	max_size=20g;
	upstream backend<span class="token punctuation">{<!-- --></span>
		server 192.168.200.146<span class="token punctuation">:</span>8080;
	<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	listen 8080;
	server_name localhost;
	location / <span class="token punctuation">{<!-- --></span>
		<span class="token comment"># 缓存的文件夹</span>
		proxy_cache itcast;
		<span class="token comment"># 访问的网址</span>
		proxy_cache_key $scheme$proxy_host$request_uri;
		<span class="token comment"># 被访问5次的时候，才会缓存</span>
		proxy_cache_min_uses 5;
		<span class="token comment"># 当状态码为200的时候 缓存5天</span>
		proxy_cache_valid 200 5d;
		<span class="token comment"># 当状态码为 404的时候 缓存30秒</span>
		proxy_cache_valid 404 30s;
		<span class="token comment"># 当状态码为任何一个的时候 缓存1分</span>
		proxy_cache_valid any 1m;
		<span class="token comment"># 是否在头部显示添</span>
		add_header nginx<span class="token punctuation">-</span>cache "$upstream_cache_status";
		<span class="token comment"># 代理</span>
		proxy_pass http<span class="token punctuation">:</span>//backend/js/;
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5Nginx_909"></a>5.Nginx缓存的清除</h3> 
<h5><a id="1__910"></a>(1).方式一: 删除对应的缓存目录</h5> 
<p><code>适用于删除整个web服务器的全部缓存资源，而不适用于单行缓存的删除。</code></p> 
<pre><code class="prism language-java"> rm <span class="token operator">-</span>rf <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>proxy_cache<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<h5><a id="2__916"></a>(2).方式二: 使用第三方扩展模块</h5> 
<blockquote> 
 <p>ngx_cache_purge</p> 
</blockquote> 
<ol><li>下载<code>ngx_cache_purge</code>模块对应的资源包，并上传到服务器上。</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 进入这个文件夹</span>
cd /root/nginx/module/
<span class="token comment"># 上传下面的文件</span>
ngx_cache_purge<span class="token punctuation">-</span>2.3.tar.gz
</code></pre> 
<ol start="2"><li>对资源文件进行解压缩</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment">#解压这个文件</span>
tar <span class="token punctuation">-</span>zxf ngx_cache_purge<span class="token punctuation">-</span>2.3.tar.gz
</code></pre> 
<ol start="3"><li>修改文件夹名称，方便后期配置</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 修改我们的文件信息</span>
mv ngx_cache_purge<span class="token punctuation">-</span>2.3 purge
</code></pre> 
<ol start="4"><li>查询Nginx的配置参数</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 查看我们的配置信息</span>
nginx <span class="token punctuation">-</span>V
</code></pre> 
<ol start="5"><li>进入Nginx的安装目录，使用./configure进行参数配置</li></ol> 
<pre><code class="prism language-yaml">cd /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1
<span class="token comment"># 在编译的时候在原有的基础上加上我们的这个新插件</span>
./configure <span class="token punctuation">-</span><span class="token punctuation">-</span>prefix=/usr/local/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>sbin<span class="token punctuation">-</span>path=/usr/local/nginx/sbin/nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>modules<span class="token punctuation">-</span>path=/usr/local/nginx/modules <span class="token punctuation">-</span><span class="token punctuation">-</span>conf<span class="token punctuation">-</span>path=/usr/local/nginx/conf/nginx.conf <span class="token punctuation">-</span><span class="token punctuation">-</span>error<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/error.log <span class="token punctuation">-</span><span class="token punctuation">-</span>http<span class="token punctuation">-</span>log<span class="token punctuation">-</span>path=/usr/local/nginx/logs/access.log <span class="token punctuation">-</span><span class="token punctuation">-</span>pid<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.pid <span class="token punctuation">-</span><span class="token punctuation">-</span>lock<span class="token punctuation">-</span>path=/usr/local/nginx/logs/nginx.lock <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_gzip_static_module <span class="token punctuation">-</span><span class="token punctuation">-</span>with<span class="token punctuation">-</span>http_ssl_module <span class="token punctuation">-</span><span class="token punctuation">-</span>add<span class="token punctuation">-</span>module=/root/nginx/module/purge
</code></pre> 
<ol start="6"><li>使用make进行编译</li></ol> 
<pre><code class="prism language-java">make
</code></pre> 
<ol start="7"><li>将nginx安装目录的nginx二级制可执行文件备份</li></ol> 
<pre><code class="prism language-yaml">cd /usr/local/nginx/sbin
<span class="token comment"># 进行备份的操作</span>
mv /usr/local/nginx/sbin/nginx   /usr/local/nginx/sbin/nginxold
</code></pre> 
<ol start="8"><li>将编译后的objs中的nginx拷贝到nginx的sbin目录下</li></ol> 
<pre><code class="prism language-java">cd <span class="token operator">/</span>root<span class="token operator">/</span>nginx<span class="token operator">/</span>core<span class="token operator">/</span>nginx<span class="token operator">-</span><span class="token number">1.16</span><span class="token number">.1</span><span class="token operator">/</span>objs

cp objs<span class="token operator">/</span>nginx  <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>sbin
</code></pre> 
<ol start="9"><li>使用make进行升级</li></ol> 
<pre><code class="prism language-java">cd <span class="token operator">/</span>root<span class="token operator">/</span>nginx<span class="token operator">/</span>core<span class="token operator">/</span>nginx<span class="token operator">-</span><span class="token number">1.16</span><span class="token number">.1</span>

make upgrade
</code></pre> 
<ol start="10"><li>在nginx配置文件中进行如下配置</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 进入我们的配置文件</span>
cd /usr/local/nginx/conf
<span class="token comment"># 进行修改我们的配置文件</span>
vim nginx.conf

<span class="token comment"># 配置如下的信息</span>

		proxy_cache_path /usr/local/proxy_cache levels=2<span class="token punctuation">:</span>1 keys_zone=itcast<span class="token punctuation">:</span>200m inactive=1d max_size=20g;

        upstream backend <span class="token punctuation">{<!-- --></span>
                server 8.130.48.9<span class="token punctuation">:</span>8080;
        <span class="token punctuation">}</span>
        server <span class="token punctuation">{<!-- --></span>
                listen 8081;
                server_name localhost;
                location / <span class="token punctuation">{<!-- --></span>
                        proxy_cache itcast;
                        proxy_cache_key $scheme$proxy_host$request_uri;
                        proxy_cache_valid 200 5d;
                        add_header nginx<span class="token punctuation">-</span>cache "$upstream_cache_status";
                        proxy_pass http<span class="token punctuation">:</span>//backend/js/;
                <span class="token punctuation">}</span>

                location ~/purge(/.<span class="token important">*)</span> <span class="token punctuation">{<!-- --></span>
                        proxy_cache_purge itcast $scheme$proxy_host$request_uri;
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/0b/2ELGpdyi_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java">nginx <span class="token operator">-</span>t
nginx <span class="token operator">-</span>s reload
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/4e/KnUOm1lv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/65/58/6zCcCVjY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6Nginx_1025"></a>6.Nginx设置资源不缓存</h3> 
<p><mark>前面咱们已经完成了Nginx作为web缓存服务器的使用</mark>。但是我们得思考一个问题就是不是所有的数据都适合进行缓存。<code>比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据</code>。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。</p> 
<p>Nginx也提供了这块的功能设置，需要使用到如下两个指令</p> 
<blockquote> 
 <p>proxy_no_cache</p> 
</blockquote> 
<p>该指令是用来<code>定义不将数据进行缓存的条件</code>。</p> 
<p><img src="https://images2.imgbox.com/12/68/6mRuEWlw_o.png" alt="在这里插入图片描述"></p> 
<p>配置实例</p> 
<pre><code class="prism language-java">proxy_no_cache $cookie_nocache $arg_nocache $arg_comment<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>proxy_cache_bypass</p> 
</blockquote> 
<p>该指令是<code>用来设置不从缓存中获取数据的条件</code>。</p> 
<p><img src="https://images2.imgbox.com/ad/8e/sXdZu62e_o.png" alt="在这里插入图片描述"><br> 配置实例</p> 
<pre><code class="prism language-java">proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment<span class="token punctuation">;</span>
</code></pre> 
<p>上述两个指令都有一个指定的条件，这个条件可以是多个，并且多个条件中至少有一个不为空且不等于"0",则条件满足成立。上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是<code>$cookie_nocache</code>、<code>$arg_nocache</code>、<code>$arg_comment</code></p> 
<h5><a id="1_cookie_nocachearg_nocachearg_comment_1056"></a>(1). <code>$cookie_nocache</code>、<code>$arg_nocache</code>、<code>$arg_comment</code></h5> 
<p>这三个参数分别代表的含义是:</p> 
<pre><code class="prism language-java">$cookie_nocache
指的是当前请求的cookie中键的名称为nocache对应的值
$arg_nocache和$arg_comment
指的是当前请求的参数中属性名为nocache和comment对应的属性值
</code></pre> 
<p>案例演示下:</p> 
<blockquote> 
 <p><code>未添加消息头的时候</code></p> 
</blockquote> 
<pre><code class="prism language-java">log_format params $cookie_nocache <span class="token operator">|</span> $arg_nocache <span class="token operator">|</span> $arg_comment；

server<span class="token punctuation">{<!-- --></span>
	listen <span class="token number">8081</span><span class="token punctuation">;</span>
	server_name localhost<span class="token punctuation">;</span>
	location <span class="token operator">/</span><span class="token punctuation">{<!-- --></span>
		access_log logs<span class="token operator">/</span>access_params<span class="token punctuation">.</span>log params<span class="token punctuation">;</span>
		root html<span class="token punctuation">;</span>
		index index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/21/fc/z5PQeLj0_o.png" alt="在这里插入图片描述"><br> <a href="http://8.130.48.9:8081/" rel="nofollow">http://8.130.48.9:8081/</a></p> 
<p><img src="https://images2.imgbox.com/2c/54/75MdVTU2_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><code>添加消息头的时候</code></p> 
</blockquote> 
<pre><code class="prism language-java">log_format params $cookie_nocache <span class="token operator">|</span> $arg_nocache <span class="token operator">|</span> $arg_comment；

server<span class="token punctuation">{<!-- --></span>
	listen <span class="token number">8081</span><span class="token punctuation">;</span>
	server_name localhost<span class="token punctuation">;</span>
	location <span class="token operator">/</span><span class="token punctuation">{<!-- --></span>
		access_log logs<span class="token operator">/</span>access_params<span class="token punctuation">.</span>log params<span class="token punctuation">;</span>
		add_header <span class="token class-name">Set</span><span class="token operator">-</span><span class="token class-name">Cookie</span> 'nocache<span class="token operator">=</span><span class="token number">999</span>'<span class="token punctuation">;</span>
		root html<span class="token punctuation">;</span>
		index index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/ec/PWbLJNbF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>三个参数联合使用</p> 
</blockquote> 
<p><a href="http://8.130.48.9:8081/?nocache=999&amp;comment=777" rel="nofollow">http://8.130.48.9:8081/?nocache=999&amp;comment=777</a></p> 
<p><img src="https://images2.imgbox.com/90/90/NXUinakX_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_1112"></a>(2).示列</h5> 
<blockquote> 
 <ol><li>第一种: 仅使用三个参数</li></ol> 
</blockquote> 
<pre><code class="prism language-yaml">		proxy_cache_path /usr/local/proxy_cache levels=2<span class="token punctuation">:</span>1 keys_zone=itcast<span class="token punctuation">:</span>200m inactive=1d max_size=20g;

        log_format params $cookie_nocache <span class="token punctuation">|</span> $arg_nocache <span class="token punctuation">|</span> $arg_comment;

server <span class="token punctuation">{<!-- --></span>
                listen 8081;
                server_name localhost;
                location / <span class="token punctuation">{<!-- --></span>
                        access_log logs/access_params.log params;
                        <span class="token comment"># 配置过滤缓存的操作 ⭐</span>
                        proxy_no_cache  $cookie_nocache $arg_nocache $arg_comment;
                        proxy_cache_bypass  $cookie_nocache $arg_nocache $arg_comment;
                        add_header Set<span class="token punctuation">-</span>Cookie 'nocache=999';
                        root html;
                        index index.html;
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><a href="http://8.130.48.9:8081/?nocache=1&amp;comment=2" rel="nofollow">http://8.130.48.9:8081/?nocache=1&amp;comment=2</a></p> 
<p><img src="https://images2.imgbox.com/5f/d7/LQvdLcqH_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>第二种方式: if判断且使用自定义</li></ol> 
</blockquote> 
<pre><code class="prism language-yaml">		proxy_cache_path /usr/local/proxy_cache levels=2<span class="token punctuation">:</span>1 keys_zone=itcast<span class="token punctuation">:</span>200m inactive=1d max_size=20g;

        log_format params $cookie_nocache <span class="token punctuation">|</span> $arg_nocache <span class="token punctuation">|</span> $arg_comment;


        server <span class="token punctuation">{<!-- --></span>
                listen 8081;
                server_name localhost;
                location / <span class="token punctuation">{<!-- --></span>
                		<span class="token comment"># 假如我们请求的url里面以.js结尾就进入方法⭐</span>
                        if ($request_uri ~ /.<span class="token important">*\.js$)</span> <span class="token punctuation">{<!-- --></span>
                        		<span class="token comment"># 假如参数值 mynocache 为1的话，就过滤不缓存</span>
                                set $mynocache 1;
                        <span class="token punctuation">}</span>
                        access_log logs/access_params.log params;
                        <span class="token comment"># 在原初的三个参数中，我们添加上第四个参数 ⭐</span>
                        proxy_no_cache  $cookie_nocache $arg_nocache $arg_comment $mynocache;
                        <span class="token comment"># 需要在这里多添加一行 ⭐⭐</span>
                        proxy_cache_bypass  $cookie_nocache $arg_nocache $arg_comment $mynocache;
                        add_header Set<span class="token punctuation">-</span>Cookie 'nocache=999';
                        root html;
                        index index.html;
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/79/86/SDN4H3E7_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Nginx_1170"></a>(七)、Nginx实现服务器端集群搭建</h2> 
<h3><a id="1NginxTomcat_1171"></a>1.Nginx与Tomcat部署</h3> 
<p>前面课程已经将Nginx的大部分内容进行了讲解，我们都知道了Nginx在高并发场景和处理静态资源是非常高性能的，但是在实际项目中除了静态资源还有就是后台业务代码模块，<mark>一般后台业务都会被部署在Tomcat，weblogic或者是websphere等web服务器上</mark>。那么如何使用Nginx接收用户的请求并把请求转发到后台web服务器？</p> 
<p><img src="https://images2.imgbox.com/b5/92/ldt3BLTr_o.png" alt="在这里插入图片描述"><br> 步骤分析:</p> 
<pre><code class="prism language-java"><span class="token number">1.</span> 准备<span class="token class-name">Tomcat</span>环境，并在<span class="token class-name">Tomcat</span>上部署一个web项目
<span class="token number">2.</span> 准备<span class="token class-name">Nginx</span>环境，使用<span class="token class-name">Nginx</span>接收请求，并把请求分发到<span class="token class-name">Tomat</span>上
</code></pre> 
<h5><a id="1Tomcat_1181"></a>(1).环境准备(Tomcat)</h5> 
<p>浏览器访问:</p> 
<p><img src="https://images2.imgbox.com/b5/aa/gkJMhKUb_o.png" alt="在这里插入图片描述"><br> 获取动态资源的链接地址:</p> 
<pre><code class="prism language-java">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.146</span><span class="token operator">:</span><span class="token number">8080</span><span class="token operator">/</span>demo<span class="token operator">/</span>getAddress
</code></pre> 
<p>本次课程将采用Tomcat作为后台web服务器</p> 
<p>（1）在Centos上准备一个Tomcat</p> 
<pre><code class="prism language-java"><span class="token number">1.</span>Tomcat官网地址<span class="token operator">:</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>tomcat<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>org<span class="token operator">/</span>
<span class="token number">2.</span>下载tomcat<span class="token punctuation">,</span>本次课程使用的是apache<span class="token operator">-</span>tomcat<span class="token operator">-</span><span class="token number">8.5</span><span class="token number">.59</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
<span class="token number">3.</span>将tomcat进行解压缩
mkdir web_tomcat
tar <span class="token operator">-</span>zxf apache<span class="token operator">-</span>tomcat<span class="token operator">-</span><span class="token number">8.5</span><span class="token number">.59</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">-</span><span class="token class-name">C</span> <span class="token operator">/</span>web_tomcat
</code></pre> 
<p>（2）准备一个web项目，将其打包为war</p> 
<pre><code class="prism language-java"><span class="token number">1.</span>将资料中的demo<span class="token punctuation">.</span>war上传到tomcat8目录下的webapps包下
<span class="token number">2.</span>将tomcat进行启动，进入tomcat8的bin目录下
 <span class="token punctuation">.</span>/startup<span class="token punctuation">.</span>sh
</code></pre> 
<p>（3）启动tomcat进行访问测试。</p> 
<pre><code class="prism language-java">静态资源<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.146</span><span class="token operator">:</span><span class="token number">8080</span><span class="token operator">/</span>demo<span class="token operator">/</span>index<span class="token punctuation">.</span>html
动态资源<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.146</span><span class="token operator">:</span><span class="token number">8080</span><span class="token operator">/</span>demo<span class="token operator">/</span>getAddress
</code></pre> 
<h5><a id="2Nginx_1217"></a>(2).环境准备(Nginx)</h5> 
<p>（1）使用Nginx的反向代理，将请求转给Tomcat进行处理。</p> 
<pre><code class="prism language-java">upstream webservice <span class="token punctuation">{<!-- --></span>
server <span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.146</span><span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
server<span class="token punctuation">{<!-- --></span>
	listen <span class="token number">80</span><span class="token punctuation">;</span>
	server_name localhost<span class="token punctuation">;</span>
	location <span class="token operator">/</span>demo <span class="token punctuation">{<!-- --></span>
		proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>webservice<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（2）启动访问测试<br> <img src="https://images2.imgbox.com/00/d2/0ixLgRqL_o.png" alt="在这里插入图片描述"><br> 学习到这，可能大家会有一个困惑，明明直接通过tomcat就能访问，为什么还需要多加一个nginx，这样不是反而是系统的复杂度变高了么? 那接下来我们从两个方便给大家分析下这个问题.</p> 
<ul><li>第一个使用Nginx实现动静分离</li><li>第二个使用Nginx搭建Tomcat的集群</li></ul> 
<h3><a id="2Nginx_1239"></a>2.Nginx实现动静分离</h3> 
<blockquote> 
 <p>什么是动静分离?</p> 
</blockquote> 
<ul><li>动: 后台应用程序的业务处理</li><li>静: 网站的静态资源(html,javaScript,css,images等文件)</li><li>分离: 将两者进行分开部署访问，提供用户进行访问。举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。</li></ul> 
<blockquote> 
 <p>为什么要动静分离?</p> 
</blockquote> 
<p>前面我们介绍过Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。</p> 
<p>动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。</p> 
<blockquote> 
 <p>如何实现动静分离?</p> 
</blockquote> 
<p>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。本次课程只要使用Nginx+Tomcat来实现动静分离。</p> 
<h5><a id="1_1257"></a>(1).需求分析</h5> 
<p>动静分离的主要优点是为了: 假如服务器发生了宕机，因为前端页面部署在Nginx中，所以前端页面不会受服务器宕机的影响，依旧会展示给前端。</p> 
<p><img src="https://images2.imgbox.com/dd/44/78vZvVId_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_1262"></a>(2).动静分离实现步骤</h5> 
<p>1.将<code>demo.war</code>项目中的静态资源都删除掉，重新打包生成一个war包，在资料中有提供。</p> 
<p>2.将war包部署到tomcat中，把之前部署的内容删除掉</p> 
<pre><code class="prism language-java">进入到tomcat的webapps目录下，将之前的内容删除掉
将新的war包复制到webapps下
将tomcat启动
</code></pre> 
<p>3.在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置</p> 
<p><img src="https://images2.imgbox.com/41/d2/qSyoDq5W_o.png" alt="在这里插入图片描述"><br> 其中index.html页面的内容如下:</p> 
<pre><code class="prism language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
		 <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'http://192.168.200.133/demo/getAddress'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#msg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/logo.png<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Nginx如何将请求转发到后端服务器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/mv.png<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>4.配置Nginx的静态资源与动态资源的访问</p> 
<pre><code class="prism language-yaml">upstream webservice<span class="token punctuation">{<!-- --></span>
	server 192.168.200.146<span class="token punctuation">:</span>8080;
<span class="token punctuation">}</span>
server <span class="token punctuation">{<!-- --></span>
	 listen 80;
	 server_name localhost;

	 <span class="token comment">#动态资源</span>
 	location /demo <span class="token punctuation">{<!-- --></span>
		 proxy_pass http<span class="token punctuation">:</span>//webservice;
	<span class="token punctuation">}</span>
	 <span class="token comment">#静态资源: 如果是.png .jpg .gif .js 都要进入我们的web目录下查找</span>
	 location ~/.<span class="token important">*\.(png|jpg|gif|js)</span><span class="token punctuation">{<!-- --></span>
		 root html/web;
		 gzip on;
	 <span class="token punctuation">}</span>

	 location / <span class="token punctuation">{<!-- --></span>
		 root html/web;
		 index index.html index.htm;
		 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="5"><li>启动测试，访问<br> <img src="https://images2.imgbox.com/4b/65/iycii0QO_o.png" alt="在这里插入图片描述"><br> 假如某个时间点，<mark>由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx,会得到如下效果，用户还是能看到页面，只是缺失了访问次数的统计，这就是前后端耦合度降低的效果</mark>，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。</li></ol> 
<p><img src="https://images2.imgbox.com/fc/c1/wA81jrQo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3NginxTomcat_1331"></a>3.Nginx实现Tomcat集群搭建</h3> 
<p>在使用<mark>Nginx</mark>和<mark>Tomcat</mark>部署项目的时候，我们使用的是一台Nginx服务器和一台Tomcat服务器，效果图如下:</p> 
<p><strong>单点故障: 假如只部署一台的tomcat服务器发生了故障，那么就称作单点故障</strong></p> 
<p><img src="https://images2.imgbox.com/4c/c4/g0Z9XVlQ_o.png" alt="在这里插入图片描述"><br> 那么问题来了，如果Tomcat的真的宕机了，整个系统就会不完整，所以如何解决上述问题，一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是<mark>我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和赋值均衡的知识，具体如何来实现?我们先来分析下原理</mark></p> 
<p><img src="https://images2.imgbox.com/e3/0a/Sgy25ZU1_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_1341"></a>(1).环境准备：</h5> 
<p>(1)准备3台tomcat,使用端口进行区分[实际环境应该是三台服务器]，修改server.ml，将端口修改分别修改为8080,8180,8280</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.拉取我们最新版的tomcat</span>
docker pull tomcat
<span class="token comment"># 2.创建宿主机的数据卷</span>
cd /
mkdir category
mkdir <span class="token punctuation">-</span>p docker_tomcat/tomcat01
mkdir <span class="token punctuation">-</span>p docker_tomcat/tomcat02
cd /root/category/docker_tomcat/tomcat02
<span class="token comment"># 3.在tomcat02这个文件夹中执行挂载语句</span>
docker run <span class="token punctuation">-</span>p 8083<span class="token punctuation">:</span>8080 <span class="token punctuation">-</span><span class="token punctuation">-</span>name tomcat01 \
<span class="token punctuation">-</span>v $PWD/webapps<span class="token punctuation">:</span>/usr/local/tomcat/webapps \
<span class="token punctuation">-</span>d tomcat
<span class="token comment"># 4.进入tomcat01也进行挂载数据卷</span>
cd /root/category/docker_tomcat/tomcat01

docker run <span class="token punctuation">-</span>p 8082<span class="token punctuation">:</span>8080 <span class="token punctuation">-</span><span class="token punctuation">-</span>name tomcat02 \
<span class="token punctuation">-</span>v $PWD/webapps<span class="token punctuation">:</span>/usr/local/tomcat/webapps \
<span class="token punctuation">-</span>d tomcat

<span class="token comment"># 5.在宿主机上的数据卷中进行编写数据</span>
cd /usr/tomcat/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>9.0.84

cp  <span class="token punctuation">-</span>r webapps /root/category/docker_tomcat/tomcat02
cp  <span class="token punctuation">-</span>r webapps /root/category/docker_tomcat/tomcat01
</code></pre> 
<p>(2)启动tomcat并访问测试</p> 
<p><img src="https://images2.imgbox.com/3b/ef/ESsK3e6T_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_1375"></a>(2).配置信息</h5> 
<pre><code class="prism language-yaml">        upstream webservice<span class="token punctuation">{<!-- --></span>
                 server 127.0.0.1<span class="token punctuation">:</span>8080;
                 server 127.0.0.1<span class="token punctuation">:</span>8082;
                 server 127.0.0.1<span class="token punctuation">:</span>8083;
        <span class="token punctuation">}</span>
    server <span class="token punctuation">{<!-- --></span>
        listen       80;
        server_name  localhost;

        location / <span class="token punctuation">{<!-- --></span>
            root   html;
            proxy_pass http<span class="token punctuation">:</span>//webservice;
            index  index.html index.htm;
        <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ae/f4/vFIZaSRj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3tomcat_1396"></a>(3).测试tomcat集群</h5> 
<p><code>我们每次访问的时候，3个tomcat会根据轮询的方式进行访问</code></p> 
<p><a href="http://8.130.48.9/" rel="nofollow">http://8.130.48.9/</a></p> 
<p><img src="https://images2.imgbox.com/43/a7/72JdKsAZ_o.png" alt="在这里插入图片描述"><br> 好了，完成了上述环境的部署，我们已经解决了Tomcat的高可用性，一台服务器宕机，还有其他两条对外提供服务，同时也可以实现后台服务器的不间断更新。但是新问题出现了，上述环境中，如果是Nginx宕机了呢，那么整套系统都将服务对外提供服务了，这个如何解决？</p> 
<h3><a id="4Nginx_1404"></a>4.Nginx高可用解决方案</h3> 
<p>针对于上面提到的问题，我们来分析下要想解决上述问题，需要面临哪些问题?</p> 
<p><img src="https://images2.imgbox.com/59/f0/MjX72ukK_o.png" alt="在这里插入图片描述"><br> 需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?</p> 
<h5><a id="1Keepalived_1411"></a>(1).Keepalived</h5> 
<p>使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。</p> 
<h5><a id="2VRRP_1414"></a>(2).VRRP介绍</h5> 
<p><img src="https://images2.imgbox.com/93/04/vciH0K8x_o.png" alt="在这里插入图片描述"></p> 
<p><mark>VRRP（Virtual Route Redundancy Protocol）协议，翻译过来为虚拟路由冗余协议</mark>。<code>VRRP协议将两台或多台路由器设备虚拟成一个设备</code>，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER,MASTER实现针对虚拟路由器IP的各种网络功能。<code>其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能</code>。当主机失效时，BACKUP将接管原先MASTER的网络功能。</p> 
<p>从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？</p> 
<blockquote> 
 <ol><li>选择协议</li></ol> 
</blockquote> 
<p>VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。</p> 
<blockquote> 
 <ol start="2"><li>路由容错协议</li></ol> 
</blockquote> 
<p><code>Master路由和Backup路由之间会有一个心跳检测</code>，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。<code>Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态</code></p> 
<p>用了Keepalived后，解决方案如下:</p> 
<p><img src="https://images2.imgbox.com/78/3d/WpiO2W79_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__1433"></a>(3).环境搭建 ⭐</h5> 
<ul><li>环境准备</li></ul> 
<p><img src="https://images2.imgbox.com/ec/d5/eTWDCayl_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.新建我们的数据卷文件位置</span>
cd /root/category/docker_nginx/nginx01
<span class="token comment"># 2.挂载配置文件</span>
mkdir conf
<span class="token comment"># 3.进行挂载并启动</span>
docker run <span class="token punctuation">-</span>p 8084<span class="token punctuation">:</span>80 <span class="token punctuation">-</span><span class="token punctuation">-</span>name nginx01 \
<span class="token punctuation">-</span>v $PWD/conf<span class="token punctuation">:</span>/usr/local/nginx/conf \
<span class="token punctuation">-</span>d nginx<span class="token punctuation">:</span>1.16.1
<span class="token comment"># 4.进行挂载文件夹的同步</span>
cp <span class="token punctuation">-</span>r conf /root/category/docker_nginx/nginx01
</code></pre> 
<p><a href="http://8.130.48.9:8084/" rel="nofollow">http://8.130.48.9:8084/</a></p> 
<p><img src="https://images2.imgbox.com/02/a0/fgv3Rstl_o.png" alt="在这里插入图片描述"><br> <code>并此时此刻启动我们两个容器!!!!</code></p> 
<h5><a id="4_Keepalived_1454"></a>(4).下载 Keepalived</h5> 
<p><a href="https://www.keepalived.org/" rel="nofollow">https://www.keepalived.org/</a></p> 
<p><img src="https://images2.imgbox.com/26/2c/xfxjD92G_o.png" alt="在这里插入图片描述"><br> <mark>下载 2.0.20版本的即可，并上传到我们的虚拟机(宿主机要下载、容器也要进行下载)中</mark></p> 
<pre><code class="prism language-yaml"><span class="token comment">#步骤1:从官方网站下载keepalived,官网地址: </span>
https<span class="token punctuation">:</span>//keepalived.org/
<span class="token comment">#步骤2:将下载的资源上传到服务器 -&gt; </span>
keepalived<span class="token punctuation">-</span>2.0.20.tar.gz
<span class="token comment">#步骤3:创建keepalived目录，方便管理资源 -&gt; </span>
cd ~
mkdir keepalived
cd keepalived
<span class="token comment">#步骤4:将压缩文件进行解压缩，解压缩到指定的目录 -&gt; </span>
tar <span class="token punctuation">-</span>zxf keepalived<span class="token punctuation">-</span>2.0.20.tar.gz
<span class="token comment"># 步骤5:对keepalived进行配置，编译和安装</span>
cd /root/keepalived/keepalived<span class="token punctuation">-</span>2.0.20
<span class="token comment"># 步骤六: 进行配置</span>
./configure <span class="token punctuation">-</span><span class="token punctuation">-</span>sysconf=/etc <span class="token punctuation">-</span><span class="token punctuation">-</span>prefix=/usr/local
<span class="token comment"># 步骤七: 进行编译和安装</span>
make <span class="token important">&amp;&amp;</span> make install
</code></pre> 
<p><img src="https://images2.imgbox.com/9c/37/nZtZmPOK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b1/35/g888DkTl_o.png" alt="在这里插入图片描述"><br> 安装完成后，有两个文件需要我们认识下，一个是<br> <code>/etc/keepalived/keepalived.conf </code>(keepalived的<mark>系统配置文件</mark>，我们主要操作的就是该文件)，一个是/usr/local/sbin目录下的<code>keepalived</code> ,是<mark>系统配置脚本，用来启动和关闭keepalived</mark></p> 
<p><img src="https://images2.imgbox.com/e7/d5/majoETeI_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5Keepalived_1485"></a>(5).Keepalived配置文件介绍</h5> 
<p>打开keepalived.conf配置文件这里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置。 本次课程主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分.</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 1.global全局部分：⭐</span>
global_defs <span class="token punctuation">{<!-- --></span>
	<span class="token comment"># 2.通知邮件，当keepalived发送切换时需要发email给具体的邮箱地址</span>
   notification_email <span class="token punctuation">{<!-- --></span>
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   <span class="token punctuation">}</span>
   <span class="token comment"># 3.设置发件人的邮箱信息</span>
   notification_email_from Alexandre.Cassen@firewall.loc
   <span class="token comment"># 4.指定smpt服务地址</span>
   smtp_server 192.168.200.1
   <span class="token comment"># 5.指定smpt服务连接超时时间</span>
   smtp_connect_timeout 30
   <span class="token comment"># 6.运行keepalived服务器的一个标识，可以用作发送邮件的主题信息</span>
   router_id LVS_DEVEL
   <span class="token comment">#默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)</span>
   vrrp_skip_check_adv_addr
   <span class="token comment">#严格遵守VRRP协议。</span>
   vrrp_strict
   <span class="token comment">#在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0</span>
   vrrp_garp_interval 0
   <span class="token comment">#在一个网卡上每组na消息之间的延迟时间，默认为0</span>
   vrrp_gna_interval 0
<span class="token punctuation">}</span>

<span class="token comment"># 2.VRRP部分，该部分可以包含以下四个子模块</span>
<span class="token comment">#1. vrrp_script 2. vrrp_sync_group 3.garp_group 4. vrrp_instance</span>

<span class="token comment">#设置keepalived实例的相关信息，VI_1为VRRP实例名称 ⭐⭐</span>
vrrp_instance VI_1 <span class="token punctuation">{<!-- --></span>
	<span class="token comment">#有两个值可选MASTER主 BACKUP备</span>
    state MASTER
    <span class="token comment">#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]</span>
    interface eth0
    <span class="token comment">#指定VRRP实例ID，范围是0-255</span>
    virtual_router_id 51
    <span class="token comment">#指定优先级，优先级高的将成为</span>
    priority 100
    <span class="token comment">#指定发送VRRP通告的间隔，单位是秒</span>
    advert_int 1
    <span class="token comment">#vrrp之间通信的认证信息</span>
    authentication <span class="token punctuation">{<!-- --></span>
    <span class="token comment">#指定认证方式。PASS简单密码认证(推荐)</span>
        auth_type PASS
    <span class="token comment">#指定认证使用的密码，最多8位</span>
        auth_pass 1111
    <span class="token punctuation">}</span>
    virtual_ipaddress <span class="token punctuation">{<!-- --></span>
    <span class="token comment">#虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个</span>
        192.168.200.16
        192.168.200.17
        192.168.200.18
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">#  ⭐⭐⭐</span>
virtual_server 192.168.200.100 443 <span class="token punctuation">{<!-- --></span>
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.201.100 443 <span class="token punctuation">{<!-- --></span>
        weight 1
        SSL_GET <span class="token punctuation">{<!-- --></span>
            url <span class="token punctuation">{<!-- --></span>
              path /
              digest ff20ad2481f97b1754ef3e12ecd3a9cc
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /mrtg/
              digest 9b3a0c85a887a256d6939da88aabd8cd
            <span class="token punctuation">}</span>
            connect_timeout 3
            retry 3
            delay_before_retry 3
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">#  ⭐⭐⭐⭐</span>
virtual_server 10.10.10.2 1358 <span class="token punctuation">{<!-- --></span>
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    sorry_server 192.168.200.200 1358

    real_server 192.168.200.2 1358 <span class="token punctuation">{<!-- --></span>
        weight 1
        HTTP_GET <span class="token punctuation">{<!-- --></span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            connect_timeout 3
            retry 3
            delay_before_retry 3
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    real_server 192.168.200.3 1358 <span class="token punctuation">{<!-- --></span>
        weight 1
        HTTP_GET <span class="token punctuation">{<!-- --></span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            <span class="token punctuation">}</span>
            connect_timeout 3
            retry 3
            delay_before_retry 3
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment"># ⭐⭐⭐⭐⭐</span>
virtual_server 10.10.10.3 1358 <span class="token punctuation">{<!-- --></span>
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.200.4 1358 <span class="token punctuation">{<!-- --></span>
        weight 1
        HTTP_GET <span class="token punctuation">{<!-- --></span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            connect_timeout 3
            retry 3
            delay_before_retry 3
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    real_server 192.168.200.5 1358 <span class="token punctuation">{<!-- --></span>
        weight 1
        HTTP_GET <span class="token punctuation">{<!-- --></span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            url <span class="token punctuation">{<!-- --></span>
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            <span class="token punctuation">}</span>
            connect_timeout 3
            retry 3
            delay_before_retry 3
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="6keppalived___1669"></a>(6).keppalived 自定义配置 ⭐⭐</h5> 
<blockquote> 
 <ol><li>服务器1</li></ol> 
</blockquote> 
<p><code>192.168.200.133</code></p> 
<pre><code class="prism language-yaml">global_defs <span class="token punctuation">{<!-- --></span>
	notification_email <span class="token punctuation">{<!-- --></span>
		 tom@itcast.cn
		 jerry@itcast.cn
	<span class="token punctuation">}</span>
	notification_email_from zhaomin@itcast.cn
	smtp_server 192.168.200.1
	smtp_connect_timeout 30
	router_id keepalived1
	vrrp_skip_check_adv_addr
	vrrp_strict
	vrrp_garp_interval 0
	vrrp_gna_interval 0
	<span class="token punctuation">}</span>
	vrrp_instance VI_1 <span class="token punctuation">{<!-- --></span>
	<span class="token comment"># ⭐这里配置成主机</span>
		state MASTER
		<span class="token comment"># 实列设置成 ens33</span>
		 interface ens33
		<span class="token comment"># 路由id 设置成 51，从机也要设置成51</span>
		 virtual_router_id 51
		<span class="token comment"># 因为是主机我们要设置成 100，优先级比较高 </span>
		 priority 100
		 advert_int 1
		 authentication <span class="token punctuation">{<!-- --></span>
		 auth_type PASS
		 auth_pass 1111
		 <span class="token punctuation">}</span>
	virtual_ipaddress <span class="token punctuation">{<!-- --></span>
		<span class="token comment"># 虚拟IP地址</span>
		 192.168.200.222
	 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ol start="2"><li>服务器2</li></ol> 
</blockquote> 
<p><code>192.168.200.122</code></p> 
<pre><code class="prism language-yaml"> <span class="token tag">!</span> Configuration File for keepalived

	 global_defs <span class="token punctuation">{<!-- --></span>
		notification_email <span class="token punctuation">{<!-- --></span>
			tom@itcast.cn
			jerry@itcast.cn
		<span class="token punctuation">}</span>
		notification_email_from zhaomin@itcast.cn
		smtp_server 192.168.200.1
		smtp_connect_timeout 30
		router_id keepalived2
		vrrp_skip_check_adv_addr
		vrrp_strict
		vrrp_garp_interval 0
		vrrp_gna_interval 0
	<span class="token punctuation">}</span>
	
	vrrp_instance VI_1 <span class="token punctuation">{<!-- --></span>
		<span class="token comment"># ⭐ 这里配置成从机</span>
			state BACKUP
			<span class="token comment"># 和主机保持一致</span>
			interface ens33
			<span class="token comment"># 和主机保持一致</span>
			virtual_router_id 51
			<span class="token comment"># 因为是从机，优先级我们设置成90</span>
			priority 90
			advert_int 1
			authentication <span class="token punctuation">{<!-- --></span>
				auth_type PASS
				auth_pass 1111
			<span class="token punctuation">}</span>
			virtual_ipaddress <span class="token punctuation">{<!-- --></span>
				<span class="token comment"># 虚拟ip地址和主机一样</span>
				192.168.200.222
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>	
</code></pre> 
<h5><a id="7___1751"></a>(7).自定义配置后访问测试 ⭐⭐⭐</h5> 
<ol><li>启动keepalived之前，咱们先使用命令 ip a ,查看<code>192.168.200.133</code>和<code>192.168.200.122</code>这两台服务器的IP情况。</li></ol> 
<p><img src="https://images2.imgbox.com/65/bc/NhgqPcro_o.png" alt="在这里插入图片描述"><br> 2. 分别启动两台服务器的keepalived</p> 
<pre><code class="prism language-java">cd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>sbin
<span class="token punctuation">.</span>/keepalived
</code></pre> 
<p>再次通过 <code>ip a</code> 查看ip</p> 
<p><code>我们发现我们的虚拟IP绑定到了 192.168.200.133上 </code></p> 
<p><img src="https://images2.imgbox.com/e1/c7/VUnWVmTt_o.png" alt="在这里插入图片描述"><br> 3. 当把192.168.200.133服务器上的keepalived关闭后，再次查看ip</p> 
<p><code>133手动关闭之后，我们发现的虚拟IP绑定到了 192.168.200.122上</code><br> <img src="https://images2.imgbox.com/e4/94/mjBgPDNf_o.png" alt="在这里插入图片描述"><br> 通过上述的测试，我们会发现，<mark>虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER</mark>。VIP也会"漂移"到新的MASTER。</p> 
<p>上面测试和Nginx有什么关系?</p> 
<p>我们把<code>192.168.200.133服务器的keepalived再次启动下，由于它的优先级高于服务器192.168.200.122</code>的，所有它会再次成为MASTER，VIP也会"漂移"过去，然后我们再次通过浏览器访问:</p> 
<p><a href="http://192.168.200.222/" rel="nofollow">http://192.168.200.222/</a></p> 
<p><img src="https://images2.imgbox.com/9d/4a/D63nxlbp_o.png" alt="在这里插入图片描述"><br> 如果把192.168.200.133服务器的keepalived关闭掉，再次访问相同的地址</p> 
<p><img src="https://images2.imgbox.com/01/e9/7on6Inh9_o.png" alt="在这里插入图片描述"><br> 效果实现了以后， <code>我们会发现要想让vip进行切换，就必须要把服务器上的keepalived进行关闭，而什么时候关闭keepalived呢?应该是在keepalived所在服务器的nginx出现问题后，把keepalived关闭掉，就可以让VIP执行另外一台服务器</code>，<strong>但是现在这所有的操作都是通过手动来完成的</strong>，我们如何能让系统自动判断当前服务器的nginx是否正确启动，如果没有，<strong>要能让VIP自动进行"漂移"，这个问题该如何解决?</strong></p> 
<h5><a id="8keepalived_1785"></a>(8).keepalived之自动切换脚本</h5> 
<p>keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换。但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，<mark>比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换</mark>，这个时候，我们可以通过编写脚本对业务进程进行检测监控。</p> 
<p>实现步骤:</p> 
<ol><li>在keepalived配置文件中添加对应的配置像</li></ol> 
<pre><code class="prism language-yaml">vrrp_script 脚本名称
<span class="token punctuation">{<!-- --></span>
	script "脚本位置"
	 <span class="token comment">#执行时间间隔</span>
	interval 3
	<span class="token comment">#动态调整vrrp_instance的优先级</span>
	weight <span class="token punctuation">-</span><span class="token number">20</span> 
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>编写脚本</li></ol> 
<p>ck_nginx.sh</p> 
<pre><code class="prism language-yaml"><span class="token comment">#!/bin/bash</span>
 	num=`ps <span class="token punctuation">-</span>C nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>no<span class="token punctuation">-</span>header <span class="token punctuation">|</span> wc <span class="token punctuation">-</span>l`
 	if <span class="token punctuation">[</span> $num <span class="token punctuation">-</span>eq 0 <span class="token punctuation">]</span>;then
		 /usr/local/nginx/sbin/nginx
		 sleep 2
		 if <span class="token punctuation">[</span> `ps <span class="token punctuation">-</span>C nginx <span class="token punctuation">-</span><span class="token punctuation">-</span>no<span class="token punctuation">-</span>header <span class="token punctuation">|</span> wc <span class="token punctuation">-</span>l` <span class="token punctuation">-</span>eq 0 <span class="token punctuation">]</span>; then
			 killall keepalived
		 fi
	 fi
</code></pre> 
<p>Linux ps命令用于显示当前进程 (process) 的状态。<br> -C(command) : 指定命令的所有进程<br> –no-header 排除标题</p> 
<ol start="3"><li>为脚本文件设置权限</li></ol> 
<pre><code class="prism language-java">chmod <span class="token number">755</span> ck_nginx<span class="token punctuation">.</span>sh
</code></pre> 
<ol start="4"><li>将脚本添加到</li></ol> 
<pre><code class="prism language-yaml"><span class="token comment"># 添加我们的脚本</span>
vrrp_script ck_nginx <span class="token punctuation">{<!-- --></span>
	<span class="token comment">#执行脚本的位置</span>
	 script "/etc/keepalived/ck_nginx.sh" 
	 <span class="token comment">#执行脚本的周期，秒为单位</span>
	 interval 2 
	 <span class="token comment">#权重的计算方式</span>
	 weight <span class="token punctuation">-</span><span class="token number">20</span> 
 <span class="token punctuation">}</span>
vrrp_instance VI_1 <span class="token punctuation">{<!-- --></span>
	 state MASTER
	 interface ens33
	 virtual_router_id 10
	 priority 100
	 advert_int 1
	 authentication <span class="token punctuation">{<!-- --></span>
	 	auth_type PASS
	 	auth_pass 1111
	<span class="token punctuation">}</span>
 virtual_ipaddress <span class="token punctuation">{<!-- --></span>
	 192.168.200.111
 <span class="token punctuation">}</span>
 track_script <span class="token punctuation">{<!-- --></span>
	 ck_nginx
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="5"><li>如果效果没有出来，可以使用 <code>tail -f /var/log/messages</code>查看日志信息，找对应的错误信息。</li><li>测试</li></ol> 
<p>问题思考:</p> 
<p><mark>通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的</mark>。所以我们要在配置文件加入 <code>nopreempt 非抢占</code>，但是这个参数只能用于 <code>state 为backup</code>，<strong>故我们在用的时候最好 master 和backup的state都设置成backup 让其通过priority(优先级)来竞争。</strong></p> 
<h3><a id="5Nginx_1864"></a>5.Nginx制作下载站点</h3> 
<p>首先我们先要清楚什么是下载站点?</p> 
<p>我们先来看一个网站<a href="http://nginx.org/download/" rel="nofollow">http://nginx.org/download/</a>这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。</p> 
<p><img src="https://images2.imgbox.com/b5/35/gwd5enx8_o.png" alt="在这里插入图片描述"><br> 如何制作一个下载站点:</p> 
<p>nginx使用的是模块 <code>ngx_http_autoindex_module</code> 来实现的，该模块处理以斜杠(“/”)结尾的请求，并生成目录列表。</p> 
<p><mark>nginx编译的时候会自动加载该模块</mark>，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置。</p> 
<h5><a id="1autoindex_1876"></a>(1).autoindex:启用或禁用目录列表输出</h5> 
<p><img src="https://images2.imgbox.com/7c/ff/wxCZnqy4_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2autoindex_exact_sizeHTLM_1880"></a>(2).autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小</h5> 
<p>默认为on，显示出文件的确切大小，单位是bytes。 改为off后，显示出文件的大概大小，单位是kB或者MB或者GB</p> 
<p><img src="https://images2.imgbox.com/18/a3/UPxFawOp_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3autoindex_format_1885"></a>(3).autoindex_format：设置目录列表的格式</h5> 
<p><img src="https://images2.imgbox.com/93/e6/XMQDRKTB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4autoindex_localtimeHTML_1888"></a>(4).autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。</h5> 
<p>默认为off，显示的文件时间为GMT时间。 改为on后，显示的文件时间为文件的服务器时间</p> 
<p><img src="https://images2.imgbox.com/7d/cd/edeUIJAE_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_1893"></a>(4).测试</h5> 
<pre><code class="prism language-yaml"><span class="token comment"># 在local文件中创建 download文件夹</span>
cd /usr/local
mkdir download
<span class="token comment"># 进入download文件夹，并且将我们要下载的文件放在这里</span>
cp <span class="token punctuation">-</span>r /root/nginx/core/nginx<span class="token punctuation">-</span>1.16.1.tar.gz /usr/local/download

</code></pre> 
<p>在 nginx.conf 配置文件中写下面的数据:</p> 
<pre><code class="prism language-yaml">server <span class="token punctuation">{<!-- --></span>
        listen       80;
        server_name  localhost;

        location / <span class="token punctuation">{<!-- --></span>
            root   html;
            index  index.html index.htm;
        <span class="token punctuation">}</span>

        location /download<span class="token punctuation">{<!-- --></span>
        	<span class="token comment"># 下载文件所在的目录</span>
        	root /usr/local;
        	<span class="token comment"># 开启站点大小</span>
        	autoindex on;
        	<span class="token comment"># 开启大小设置</span>
        	autoindex_exact_size on;
        	<span class="token comment"># 使用html页面</span>
        	autoindex_format html;
        	<span class="token comment"># 本地时间</span>
        	autoindex_localtime on;
<span class="token punctuation">}</span>
</code></pre> 
<p><code>自动生成如下目录: </code><br> <img src="https://images2.imgbox.com/15/55/SXIqFoIG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6Nginx_1931"></a>6.Nginx的用户认证模块</h3> 
<p>对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。</p> 
<p>Nginx对应用户认证这块是通过 <code>ngx_http_auth_basic_module</code> 模块来实现的，它允许通过使用"HTTP基本身份验证"协议验证用户名和密码来限制对资源的访问。<mark>默认情况下nginx是已经安装了该模块</mark>，如果不需要则使用 <code>--without-http_auth_basic_module</code>。</p> 
<p>该模块的指令比较简单</p> 
<h5><a id="1auth_basic_HTTP_1938"></a>(1).auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证</h5> 
<p><img src="https://images2.imgbox.com/2a/e3/enbYwAFJ_o.png" alt="在这里插入图片描述"><br> 开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。</p> 
<h5><a id="2auth_basic_user_file_1942"></a>(2).auth_basic_user_file:指定用户名和密码所在文件</h5> 
<p><img src="https://images2.imgbox.com/a4/31/9FZFCaGt_o.png" alt="在这里插入图片描述"><br> 指定文件路径，该文件中的用户名和密码的设置，密码需要进行加密。</p> 
<p>可以采用工具自动生成.</p> 
<p>实现步骤:</p> 
<p>1.nginx.conf添加如下内容</p> 
<pre><code class="prism language-yaml"> server <span class="token punctuation">{<!-- --></span>
        listen       80;
        server_name  localhost;

        <span class="token comment">#charset koi8-r;</span>

        <span class="token comment">#access_log  logs/host.access.log  main;</span>

        location / <span class="token punctuation">{<!-- --></span>
            root   html;
            index  index.html index.htm;
        <span class="token punctuation">}</span>

        location /download<span class="token punctuation">{<!-- --></span>
        root /usr/local;
        <span class="token comment"># 开启站点大小</span>
        autoindex on;
        <span class="token comment"># 开启大小设置</span>
        autoindex_exact_size on;
        <span class="token comment"># 使用html页面</span>
        autoindex_format html;
        <span class="token comment"># 本地时间</span>
        autoindex_localtime on;
        <span class="token comment"># 弹出两个输入框</span>
        auth_basic 'please input your auth';
        <span class="token comment"># 用户名和密码的所在文件</span>
        auth_basic_user_file htpasswd;
<span class="token punctuation">}</span>
</code></pre> 
<p>2.我们需要使用htpasswd工具生成</p> 
<pre><code class="prism language-java">yum install <span class="token operator">-</span>y httpd<span class="token operator">-</span>tools
</code></pre> 
<p><img src="https://images2.imgbox.com/56/27/e1nOsJuf_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">//创建一个新文件记录用户名和密码</span>
htpasswd <span class="token operator">-</span>c <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token operator">/</span>htpasswd 用户名
<span class="token comment">//在指定文件新增一个用户名和密码</span>
htpasswd <span class="token operator">-</span>b <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token operator">/</span>htpasswd 用户名 密码 
<span class="token comment">//从指定文件删除一个用户信息</span>
htpasswd <span class="token operator">-</span><span class="token class-name">D</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token operator">/</span>htpasswd 用户名
<span class="token comment">//验证用户名和密码是否正确</span>
htpasswd <span class="token operator">-</span>v <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token operator">/</span>htpasswd 用户名
</code></pre> 
<p><code>我们执行之后我们就会发现我们的conf之中就会有一个 htpaswd</code></p> 
<p><img src="https://images2.imgbox.com/60/a5/wXckRDN5_o.png" alt="在这里插入图片描述"><br> <code>假如我们访问这个下载网址，必须先要我们进行认证:</code></p> 
<p><a href="http://8.130.48.9/download/" rel="nofollow">http://8.130.48.9/download/</a><br> <img src="https://images2.imgbox.com/ba/e1/VDiVFs6h_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/5a/mqsmbhf6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Lua_2009"></a>(八)、Lua</h2> 
<h3><a id="1_2010"></a>1.基本介绍</h3> 
<h5><a id="1Lua_2011"></a>(1).Lua的基本概念</h5> 
<p>Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p> 
<h5><a id="2Lua_2014"></a>(2).Lua的特性</h5> 
<p>跟其他语言进行比较，Lua有其自身的特点：</p> 
<ol><li>轻量级</li></ol> 
<pre><code class="prism language-java"><span class="token class-name">Lua</span>用标准<span class="token class-name">C</span>语言编写并以源代码形式开发，编译后仅仅一百余千字节，可
以很方便的嵌入到其他程序中。
</code></pre> 
<ol start="2"><li>可扩展</li></ol> 
<pre><code class="prism language-java"><span class="token class-name">Lua</span>提供非常丰富易于使用的扩展接口和机制，由宿主语言<span class="token punctuation">(</span>通常是<span class="token class-name">C</span>或
<span class="token class-name">C</span><span class="token operator">++</span><span class="token punctuation">)</span>提供功能，<span class="token class-name">Lua</span>可以使用它们，就像内置的功能一样。
</code></pre> 
<ol start="3"><li>支持面向过程编程和函数式编程</li></ol> 
<h5><a id="3_2031"></a>(3).应用场景</h5> 
<p>Lua在不同的系统中得到大量应用，场景的应用场景如下:</p> 
<p>游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。</p> 
<h3><a id="2Lua_2036"></a>2.Lua的安装与编译</h3> 
<h5><a id="1Lua_2037"></a>(1).找到Lua官网</h5> 
<p>在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。</p> 
<p>Lua的官网地址为: <a href="https://www.lua.org" rel="nofollow">https://www.lua.org</a></p> 
<p><img src="https://images2.imgbox.com/81/9e/2ktWehNk_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2043"></a>(2).进行编译与安装</h5> 
<blockquote> 
 <p>下载</p> 
</blockquote> 
<p>点击download可以找到对应版本的下载地址，我们本次课程采用的是lua-5.3.5,其对应的资源链接地址为 <a href="https://www.lua.org/ftp/lua-5.4.1.tar.gz" rel="nofollow">https://www.lua.org/ftp/lua-5.4.1.tar.gz</a></p> 
<p>也可以使用wget命令直接下载:</p> 
<pre><code class="prism language-java"> wget https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>lua<span class="token punctuation">.</span>org<span class="token operator">/</span>ftp<span class="token operator">/</span>lua<span class="token operator">-</span><span class="token number">5.4</span><span class="token number">.1</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<blockquote> 
 <p>编译安装</p> 
</blockquote> 
<pre><code class="prism language-yaml"><span class="token comment"># 创建文件夹并解压</span>
mkdir lua
tar <span class="token punctuation">-</span>zxf lua<span class="token punctuation">-</span>5.4.1.tar.gz
cd /root/lua/lua<span class="token punctuation">-</span>5.4.1
<span class="token comment"># 编译</span>
make linux test
make install
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/83/cn5tmLd7_o.png" alt="在这里插入图片描述"><br> 如果在执行make linux test失败，报如下错误:<br> <img src="https://images2.imgbox.com/4f/8b/8LqmM8s5_o.png" alt="在这里插入图片描述"><br> 说明当前系统缺少libreadline-dev依赖包，需要通过命令来进行安装</p> 
<pre><code class="prism language-java">yum install <span class="token operator">-</span>y readline<span class="token operator">-</span>devel
</code></pre> 
<p>验证是否安装成功</p> 
<pre><code class="prism language-java">lua <span class="token operator">-</span>v
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/36/byiongOw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3Lua_2080"></a>3.Lua的语法</h3> 
<p>Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。</p> 
<h5><a id="1Lua_2084"></a>(1).Lua的两种交互方式</h5> 
<p>大家需要知道的是，Lua有两种交互方式，分别是:<code>交互式</code>和<code>脚本式</code>，这两者的区别，下面我们分别来讲解下：</p> 
<blockquote> 
 <ol><li>交互式</li></ol> 
</blockquote> 
<p><code>交互式是指可以在命令行输入程序，然后回车就可以看到运行的效果</code>。</p> 
<ul><li>Lua交互式编程模式可以通过命令lua -i 或lua来启用:</li></ul> 
<pre><code class="prism language-yaml"><span class="token comment"># 输入这个命令，我们进入lua命令行工具</span>
lua <span class="token punctuation">-</span>i
<span class="token comment"># 执行命令后回车</span>
print("hello world");
</code></pre> 
<ul><li>在命令行中key输入如下命令，并按回车,会有输出在控制台：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">// 执行命令后回车</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/db/hbwELFk8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>脚本式</li></ol> 
</blockquote> 
<p>脚本式是将代码保存到一个以lua为扩展名的文件中并执行的方式。</p> 
<ul><li>方式一: 使用lua进行编译解析</li></ul> 
<p>我们需要一个文件名为 <code>hello.lua</code> , 在文件中添加要执行的代码，然后通过命令 <code>lua hello.lua</code> 来执行，会在控制台输出对应的结果。</p> 
<pre><code class="prism language-c"><span class="token comment">// 创建一个文件夹管理我们的lua程序</span>
mkdir lua_data
cd <span class="token operator">/</span>root<span class="token operator">/</span>lua<span class="token operator">/</span>lua_data
<span class="token comment">// 编写我们的hello.lua文件</span>
vim hello<span class="token punctuation">.</span>lua
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello lua!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 运行我们的hello.lua</span>
lua <span class="token operator">/</span>root<span class="token operator">/</span>lua<span class="token operator">/</span>lua_data<span class="token operator">/</span>hello<span class="token punctuation">.</span>lua
</code></pre> 
<p><code>在解析编译的过程中</code><br> <img src="https://images2.imgbox.com/45/90/cUVsjg6K_o.png" alt="在这里插入图片描述"></p> 
<ul><li>方式二: 内嵌lua进行解析编译</li></ul> 
<pre><code class="prism language-c">#<span class="token operator">!</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">/</span>lua
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello lua!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第一行用来指定Lua解释器所在位置为 <code>/usr/local/bin/lua</code>，加上 <code>#号标记解释器会忽略它</code>。一般情况下#!就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为:<br> <img src="https://images2.imgbox.com/66/ea/J56rgZQL_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java">chmod <span class="token number">755</span> hello<span class="token punctuation">.</span>lua
</code></pre> 
<p>然后执行该文件</p> 
<pre><code class="prism language-java"> <span class="token punctuation">.</span>/hello<span class="token punctuation">.</span>lua
</code></pre> 
<p><img src="https://images2.imgbox.com/34/18/bns7oMhG_o.png" alt="在这里插入图片描述"><br> 补充一点，如果想在交互式中运行脚本式的 <code>hello.lua</code> 中的内容，我们可以使用一个dofile函数，如：</p> 
<pre><code class="prism language-java"><span class="token function">dofile</span><span class="token punctuation">(</span><span class="token string">"/root/lua/lua_data/hello.lua"</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f9/58/S54pwIsQ_o.png" alt="在这里插入图片描述"><br> 注意:在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错，</p> 
<p>在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的</p> 
<pre><code class="prism language-yaml"><span class="token comment">#写法一</span>
a=1
b=a+2
<span class="token comment">#写法二</span>
a=1;
b=a+2;
<span class="token comment">#写法三</span>
a=1; b=a+2;
<span class="token comment">#写法四</span>
a=1 b=a+2
</code></pre> 
<p>不建议使用第四种方式，可读性太差。</p> 
<h5><a id="2Lua_2174"></a>(2).Lua的注释</h5> 
<p>关于Lua的注释要分两种，<code>第一种是单行注释</code>，<code>第二种是多行注释</code>。</p> 
<blockquote> 
 <p>单行注释的语法为：</p> 
</blockquote> 
<pre><code class="prism language-java"> <span class="token operator">--</span>注释内容
</code></pre> 
<blockquote> 
 <p>多行注释的语法为:</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token operator">--</span><span class="token punctuation">[</span><span class="token punctuation">[</span>
	注释内容
	注释内容
<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>如果想取消多行注释，只需要在第一个–之前在加一个-即可，如：</p> 
<pre><code class="prism language-java"><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token punctuation">[</span>
	注释内容
	注释内容
<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<h5><a id="3_2200"></a>(3).标识符</h5> 
<p>换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 <code>A 到 Z或 a 到 z </code>或 下划线<code> _ 开头后加上0个或多个字母</code>，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。<strong>注意Lua是区分大小写字母的。</strong></p> 
<h5><a id="4_2203"></a>(4).关键字</h5> 
<p>下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：</p> 
<p><img src="https://images2.imgbox.com/db/b4/n6XJHsxV_o.png" alt="在这里插入图片描述"></p> 
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。</p> 
<h5><a id="5_2210"></a>(5).运算符</h5> 
<p>Lua中支持的运算符有<code>算术运算符</code>、<code>关系运算符</code>、<code>逻辑运算符</code>、其他运算符。</p> 
<blockquote> 
 <p>算术运算符:</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token operator">+</span> 加法
<span class="token operator">-</span> 减法
<span class="token operator">*</span> 乘法
<span class="token operator">/</span> 除法
<span class="token operator">%</span> 取余
<span class="token operator">^</span> 乘幂
<span class="token operator">-</span> 负号
</code></pre> 
<p>例如:</p> 
<pre><code class="prism language-java"><span class="token number">10</span><span class="token operator">+</span><span class="token number">20</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">30</span>
<span class="token number">20</span><span class="token operator">-</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">10</span>
<span class="token number">10</span><span class="token operator">*</span><span class="token number">20</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">200</span>
<span class="token number">20</span><span class="token operator">/</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">2</span>
<span class="token number">3</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">1</span>
<span class="token number">10</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">100</span>
<span class="token operator">-</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token number">10</span>
</code></pre> 
<blockquote> 
 <p>关系运算符</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token operator">==</span> 等于
<span class="token operator">~</span><span class="token operator">=</span> 不等于
<span class="token operator">&gt;</span> 大于
<span class="token operator">&lt;</span> 小于
<span class="token operator">&gt;=</span> 大于等于
<span class="token operator">&lt;=</span> 小于等于
</code></pre> 
<p>例如:</p> 
<pre><code class="prism language-java"><span class="token number">10</span><span class="token operator">==</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
<span class="token number">10</span><span class="token operator">~</span><span class="token operator">=</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>
<span class="token number">20</span><span class="token operator">&gt;</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
<span class="token number">20</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>
<span class="token number">20</span><span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
<span class="token number">20</span><span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>
</code></pre> 
<blockquote> 
 <p>逻辑运算符</p> 
</blockquote> 
<pre><code class="prism language-java">and 逻辑与 <span class="token class-name">A</span> and <span class="token class-name">B</span> <span class="token operator">&amp;&amp;</span>
or 逻辑或 <span class="token class-name">A</span> or <span class="token class-name">B</span> <span class="token operator">||</span>
not 逻辑非 取反，如果为<span class="token boolean">true</span><span class="token punctuation">,</span>则返回<span class="token boolean">false</span> <span class="token operator">!</span>
</code></pre> 
<p>逻辑运算符可以作为if的判断条件，返回的结果如下:</p> 
<pre><code class="prism language-java"><span class="token class-name">A</span> <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token class-name">B</span> <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token class-name">A</span> and <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
<span class="token class-name">A</span> or <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
not <span class="token class-name">A</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>

<span class="token class-name">A</span> <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token class-name">B</span> <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token class-name">A</span> and <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>
<span class="token class-name">A</span> or <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
not <span class="token class-name">A</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>

<span class="token class-name">A</span> <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token class-name">B</span> <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token class-name">A</span> and <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">false</span>
<span class="token class-name">A</span> or <span class="token class-name">B</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
not <span class="token class-name">A</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token boolean">true</span>
</code></pre> 
<blockquote> 
 <p>其他运算符</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span> 连接两个字符串
# 一元预算法，返回字符串或表的长度
</code></pre> 
<p>例如:</p> 
<pre><code class="prism language-java"><span class="token string">"HELLO "</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">"WORLD"</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token constant">HELLO</span> <span class="token constant">WORLD</span>
#<span class="token string">"HELLO"</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">5</span>
</code></pre> 
<h5><a id="6_2299"></a>(6).全局变量&amp;局部变量</h5> 
<p>在Lua语言中，<code>全局变量无须声明即可使用</code>。在默认情况下，变量总是认为是全局的，<code>如果未提前赋值，默认为nil</code>:</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 我们设置全局变量，我们发现我们的全局变量能够打印</span>
<span class="token punctuation">&gt;</span> b=10
<span class="token punctuation">&gt;</span> print(b)
10
</code></pre> 
<p>要想声明一个局部变量，需要使用local来声明</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 设置局部变量的话，我们发现我们打印不出来</span>
<span class="token punctuation">&gt;</span> local a = 100
<span class="token punctuation">&gt;</span> print(a)
nil
<span class="token comment"># 假如说我们的命令在同一个命令行的话，那么局部变量就能使用</span>
<span class="token punctuation">&gt;</span> local c=100; print(c)
100

</code></pre> 
<p>结论: 如果是全局变量，那么我们每一个命令行都能访问，如果说是局部变量的话，那么我们只能访问这一行的数据。</p> 
<h3><a id="4Lua_2324"></a>4.Lua数据类型</h3> 
<p>Lua有8个数据类型</p> 
<pre><code class="prism language-java"><span class="token function">nil</span><span class="token punctuation">(</span>空，无效值<span class="token punctuation">)</span>
<span class="token keyword">boolean</span><span class="token punctuation">(</span>布尔，<span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token function">number</span><span class="token punctuation">(</span>数值<span class="token punctuation">)</span>
<span class="token function">string</span><span class="token punctuation">(</span>字符串<span class="token punctuation">)</span>
<span class="token function">function</span><span class="token punctuation">(</span>函数<span class="token punctuation">)</span>
table（表）
<span class="token function">thread</span><span class="token punctuation">(</span>线程<span class="token punctuation">)</span>
userdata（用户数据）
</code></pre> 
<p><mark>可以使用 type 函数测试给定变量或者的类型</mark>：</p> 
<pre><code class="prism language-java"><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>nil
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token keyword">boolean</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token operator">*</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> number
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> string
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>userdata
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> function
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>function
<span class="token function">print</span><span class="token punctuation">(</span>type<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>table
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token class-name">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> string
</code></pre> 
<h5><a id="1nil__2353"></a>(1).nil (空值)</h5> 
<p>nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以<code>当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存</code>。</p> 
<h5><a id="2boolean__2356"></a>(2).boolean (布尔)</h5> 
<p>boolean类型具有两个值，<code>true和false</code>。boolean类型一般被用来做条件判断的真与假。在Lua语言中，<strong>只会将<code>false和nil</code>视为假，其他的都视为真</strong>，特别是在条件检测中0和空字符串都会认为是真，这个和我们熟悉的大多数语言不太一样。</p> 
<h5><a id="3number__2359"></a>(3).number (数值)</h5> 
<p>在Lua5.3版本开始，Lua语言为数值格式提供了两种选择: <code>integer</code>(<strong>整型</strong>)和<code>float</code>(<strong>双精度浮点型</strong>) [和其他语言不太一样，float不代表单精度类型]。</p> 
<p>数值常量的表示方式:</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span><span class="token number">4</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">4</span>
<span class="token operator">&gt;</span><span class="token number">0.4</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">0.4</span>
<span class="token operator">&gt;</span><span class="token number">4.75e-3</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">0.00475</span>
<span class="token operator">&gt;</span><span class="token number">4.75e3</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token number">4750</span>
</code></pre> 
<p>不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>number
<span class="token operator">&gt;</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">3.3</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>number
</code></pre> 
<p>所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的</p> 
<h5><a id="4string__2379"></a>(4).string (字符串)</h5> 
<p><code>Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍</code>。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。</p> 
<blockquote> 
 <p>可以使用<code>单引号</code>或<code>双引号</code>来声明字符串</p> 
</blockquote> 
<pre><code class="prism language-java">
<span class="token operator">&gt;</span>a <span class="token operator">=</span> <span class="token string">"hello"</span>
<span class="token operator">&gt;</span>b <span class="token operator">=</span> <span class="token char">'world'</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>hello
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span>world
</code></pre> 
<blockquote> 
 <p>如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明</p> 
</blockquote> 
<pre><code class="prism language-java">html <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>
<span class="token generics"><span class="token punctuation">&lt;</span>html<span class="token punctuation">&gt;</span></span>
<span class="token generics"><span class="token punctuation">&lt;</span>head<span class="token punctuation">&gt;</span></span>
<span class="token generics"><span class="token punctuation">&lt;</span>title<span class="token punctuation">&gt;</span></span><span class="token class-name">Lua</span><span class="token operator">-</span>string<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span>
<span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">&gt;</span></span>
<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.lua.org"</span><span class="token operator">&gt;</span><span class="token class-name">Lua</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span>
<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<h5><a id="5table__2406"></a>(5).table (表)</h5> 
<p><code>table是Lua语言中最主要和强大的数据结构</code>。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 <mark>Lua语言中的表本质上是一种辅助数组</mark>。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。</p> 
<p>创建表的最简单方式:</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>创建数组:</p> 
<p>我们都知道数组就是相同数据类型的元素按照一定顺序排列的集合，那么使用table如何创建一个数组呢?</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span>arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"TOM"</span><span class="token punctuation">,</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span><span class="token string">"ROSE"</span><span class="token punctuation">}</span>
</code></pre> 
<p>要想获取数组中的值，我们可以通过如下内容来获取:<br> <code>在Lua语言中我们的数组下标是从1开始的，不是0</code></p> 
<pre><code class="prism language-java"><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> nil
<span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">TOM</span>
<span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">JERRY</span>
<span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token constant">ROSE</span>
</code></pre> 
<p>从上面的结果可以看出来，数组的下标默认是从1开始的。所以上述创建数组，也可以通过如下方式来创建</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span>arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"TOM"</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"JERRY"</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ROSE"</span>
</code></pre> 
<p>上面我们说过了，<strong><mark>表的索引即可以是数字，也可以是字符串等其他的内容</mark></strong>，所以我们也可以将索引更改为字符串来创建</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span>arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token string">"X"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token string">"Y"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span>
<span class="token operator">&gt;</span>arr<span class="token punctuation">[</span><span class="token string">"Z"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span>
</code></pre> 
<p>当然，如果想要获取这些数组中的值，可以使用下面的方式</p> 
<pre><code class="prism language-java"><span class="token comment">// 错误的获取方式,我们发现获取为空</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span> nil
<span class="token comment">//方式一</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token string">"X"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token string">"Y"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token string">"Z"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//方式二</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">arr<span class="token punctuation">.</span></span>X</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">arr<span class="token punctuation">.</span></span>Y</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">arr<span class="token punctuation">.</span></span>Z</span><span class="token punctuation">)</span>
</code></pre> 
<p>当前table的灵活不进于此，还有更灵活的声明方式</p> 
<pre><code class="prism language-java"><span class="token operator">&gt;</span>arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"TOM"</span><span class="token punctuation">,</span><span class="token class-name">X</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span><span class="token class-name">Y</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">"ROSE"</span><span class="token punctuation">,</span><span class="token class-name">Z</span><span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">}</span>
</code></pre> 
<p>如何获取上面的值?</p> 
<pre><code class="prism language-java"><span class="token constant">TOM</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">10</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span><span class="token string">"X"</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token class-name"><span class="token namespace">arr<span class="token punctuation">.</span></span>X</span>
<span class="token constant">JERRY</span><span class="token operator">:</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token number">20</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span><span class="token string">"Y"</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token class-name"><span class="token namespace">arr<span class="token punctuation">.</span></span>Y</span>
<span class="token constant">ROESE</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre> 
<h5><a id="6function__2480"></a>(6).function (函数)</h5> 
<p>在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。</p> 
<p>定义函数的语法为:</p> 
<pre><code class="prism language-java">function <span class="token function">functionName</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>

end
</code></pre> 
<p>函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数。</p> 
<pre><code class="prism language-java">function <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
	 <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
end

	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> nil nil
	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">2</span> nil
	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token number">6</span>
	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2.6</span><span class="token number">.8</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">8</span>被丢弃<span class="token punctuation">)</span>
</code></pre> 
<p><code>可变长参数函数</code></p> 
<pre><code class="prism language-java">function <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
	 a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	 <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	 <span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	 <span class="token function">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
end

<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
</code></pre> 
<p>函数返回值可以有多个，这点和Java不太一样</p> 
<pre><code class="prism language-java">function <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
	 <span class="token keyword">return</span> a<span class="token punctuation">,</span>b
end

x<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">22</span>
</code></pre> 
<h5><a id="7thread__2523"></a>(7).thread (线程)</h5> 
<p>thread翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。</p> 
<h5><a id="8userdata__2526"></a>(8).userdata (用户数据)</h5> 
<p>userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。</p> 
<h3><a id="5Lua_2529"></a>5.Lua控制结构</h3> 
<p>Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 <code>while、 repeat 和 for</code>。 所有的控制结构语法上都有一个显式的终结符： <strong><code>end 用于终结 if、 for 及 while 结构</code>， <code>until 用于终结repeat 结构</code></strong>。</p> 
<h5><a id="1if_then_elseif_else_2531"></a>(1).if then elseif else</h5> 
<p>if语句先测试其条件，并根据条件是否满足执行相应的 then 部分或 else部分。 else 部分 是可选的。</p> 
<pre><code class="prism language-java">function <span class="token function">testif</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	 <span class="token keyword">if</span> a<span class="token operator">&gt;</span><span class="token number">0</span> then
	 	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a是正数"</span><span class="token punctuation">)</span>
	 end
end

function <span class="token function">testif</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	 <span class="token keyword">if</span> a<span class="token operator">&gt;</span><span class="token number">0</span> then	
	 	 <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a是正数"</span><span class="token punctuation">)</span>
	 <span class="token keyword">else</span>
		 <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a是负数"</span><span class="token punctuation">)</span>
	 end
end
</code></pre> 
<p>如果要编写嵌套的 if 语句，可以使用 elseif。 它类似于在 else 后面紧跟一个if。根据传入的年龄返回不同的结果，如</p> 
<pre><code class="prism language-java">age<span class="token operator">&lt;=</span><span class="token number">18</span> 青少年，
age<span class="token operator">&gt;</span><span class="token number">18</span> <span class="token punctuation">,</span> age <span class="token operator">&lt;=</span><span class="token number">45</span> 青年
age<span class="token operator">&gt;</span><span class="token number">45</span> <span class="token punctuation">,</span> age<span class="token operator">&lt;=</span><span class="token number">60</span> 中年人
age<span class="token operator">&gt;</span><span class="token number">60</span> 老年人

function <span class="token function">show</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
	<span class="token keyword">if</span> age<span class="token operator">&lt;=</span><span class="token number">18</span> then
		<span class="token keyword">return</span> <span class="token string">"青少年"</span>
	elseif age<span class="token operator">&gt;</span><span class="token number">18</span> and age<span class="token operator">&lt;=</span><span class="token number">45</span> then
		<span class="token keyword">return</span> <span class="token string">"青年"</span>
	elseif age<span class="token operator">&gt;</span><span class="token number">45</span> and age<span class="token operator">&lt;=</span><span class="token number">60</span> then
		<span class="token keyword">return</span> <span class="token string">"中年人"</span>
	elseif age<span class="token operator">&gt;</span><span class="token number">60</span> then
		<span class="token keyword">return</span> <span class="token string">"老年人"</span>
	end
end
</code></pre> 
<h5><a id="2while__2569"></a>(2).while循环 (先判断在执行)</h5> 
<p>顾名思义，当条件为真时 while 循环会重复执行其循环体。 Lua 语言先测试 while 语句 的条件，若条件为假则循环结束；否则， Lua 会执行循环体并不断地重复这个过程。</p> 
<p>语法：</p> 
<pre><code class="prism language-java"><span class="token keyword">while</span> 条件 <span class="token keyword">do</span>
	循环体
end
</code></pre> 
<p>例子:实现数组的循环</p> 
<pre><code class="prism language-java">function <span class="token function">testWhile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	local i <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">while</span> i<span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token keyword">do</span>
		<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>
	end
end
</code></pre> 
<h5><a id="3repeat__2590"></a>(3).repeat循环 (先执行在判断条件)</h5> 
<p>顾名思义， repeat-until语句会重复执行其循环体直到条件为真时结束。 <mark>由于条件测试在循环体之后执行，所以循环体至少会执行一次</mark>。</p> 
<p>语法</p> 
<pre><code class="prism language-java">	repeat
		循环体
	until 条件
</code></pre> 
<pre><code class="prism language-java">function <span class="token function">testRepeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	local i <span class="token operator">=</span> <span class="token number">10</span>
	repeat
		<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		i<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span>
	until i <span class="token operator">&lt;</span> <span class="token number">1</span>
end
</code></pre> 
<h5><a id="4for_2610"></a>(4).for循环</h5> 
<blockquote> 
 <p>数值型for循环</p> 
</blockquote> 
<p>语法</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span> param<span class="token operator">=</span>exp1<span class="token punctuation">,</span>exp2<span class="token punctuation">,</span>exp3 <span class="token keyword">do</span>
	循环体
end
</code></pre> 
<p>param 的值从exp1变化到 exp2之前的每次循环会执行循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token keyword">do</span>
	<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
end
</code></pre> 
<blockquote> 
 <p>泛型for循环</p> 
</blockquote> 
<p>泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。</p> 
<p>语法</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span> i<span class="token punctuation">,</span>v in <span class="token function">ipairs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">do</span>
	 循环体
end
</code></pre> 
<p><code>i是数组索引值，v是对应索引的数组元素值</code>，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。</p> 
<p>例如:</p> 
<pre><code class="prism language-java">arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"TOME"</span><span class="token punctuation">,</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span><span class="token string">"ROWS"</span><span class="token punctuation">,</span><span class="token string">"LUCY"</span><span class="token punctuation">}</span>
	 <span class="token keyword">for</span> i<span class="token punctuation">,</span>v in <span class="token function">ipairs</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token keyword">do</span>
		<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>v<span class="token punctuation">)</span>
	 end
</code></pre> 
<p>上述实例输出的结果为</p> 
<pre><code class="prism language-java"><span class="token number">1</span> <span class="token constant">TOM</span>
<span class="token number">2</span> <span class="token constant">JERRY</span>
<span class="token number">3</span> <span class="token constant">ROWS</span>
<span class="token number">4</span> <span class="token constant">LUCY</span>
</code></pre> 
<p>但是如果将arr的值进行修改为</p> 
<pre><code class="prism language-java">arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"TOME"</span><span class="token punctuation">,</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span><span class="token string">"ROWS"</span><span class="token punctuation">,</span>x<span class="token operator">=</span><span class="token string">"JACK"</span><span class="token punctuation">,</span><span class="token string">"LUCY"</span><span class="token punctuation">}</span>
</code></pre> 
<p>同样的代码在执行的时候，就只能看到和之前一样的结果，而其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?</p> 
<blockquote> 
 <p>我们可以将迭代器函数变成pairs,如</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">for</span> i<span class="token punctuation">,</span>v in <span class="token function">pairs</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token keyword">do</span>
	<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>v<span class="token punctuation">)</span>
end
</code></pre> 
<p>上述实例就输出的结果为</p> 
<pre><code class="prism language-java"><span class="token number">1</span> <span class="token constant">TOM</span>
<span class="token number">2</span> <span class="token constant">JERRY</span>
<span class="token number">3</span> <span class="token constant">ROWS</span>
<span class="token number">4</span> <span class="token constant">LUCY</span>
x <span class="token constant">JACK</span>
</code></pre> 
<h2><a id="ngx_lua_2683"></a>(九)、ngx_lua模块概念</h2> 
<p>淘宝开发的 <code>ngx_lua模块</code> 通过将 <code>lua解释器集成进Nginx</code> ，可以采用 <code>lua脚本</code> 实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。</p> 
<h3><a id="1ngx_lua_2686"></a>1.ngx_lua模块环境准备</h3> 
<h5><a id="1luanginxmodule_2687"></a>(1).方式一:lua-nginx-module</h5> 
<blockquote> 
 <ol><li>LuaJIT是采用C语言编写的Lua代表的解释器。</li></ol> 
</blockquote> 
<p>官网地址为: <a href="http://luajit.org/" rel="nofollow">http://luajit.org/</a></p> 
<p>在官网上找到对应的下载地址: <a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz" rel="nofollow">http://luajit.org/download/LuaJIT-2.0.5.tar.gz</a></p> 
<p>在centos上使用wget来下载:</p> 
<pre><code class="prism language-java"> wget http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>luajit<span class="token punctuation">.</span>org<span class="token operator">/</span>download<span class="token operator">/</span><span class="token class-name">LuaJIT</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token number">.5</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<p>将下载的资源进行解压:</p> 
<pre><code class="prism language-java">tar <span class="token operator">-</span>zxf <span class="token class-name">LuaJIT</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token number">.5</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<p>进入解压的目录:</p> 
<pre><code class="prism language-java"> cd <span class="token class-name">LuaJIT</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token number">.5</span>
</code></pre> 
<p>执行编译和安装:</p> 
<pre><code class="prism language-java">make <span class="token operator">&amp;&amp;</span> make install
</code></pre> 
<p><img src="https://images2.imgbox.com/00/f4/GwmLPWNk_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="2"><li>下载lua-nginx-module</li></ol> 
</blockquote> 
<p>下载地址: <a href="https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz">https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz</a><br> 在centos上使用wget来下载:</p> 
<pre><code class="prism language-java">wget https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>openresty<span class="token operator">/</span>luanginxmodule<span class="token operator">/</span>archive<span class="token operator">/</span>v0<span class="token punctuation">.</span><span class="token number">10.16</span>rc4<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<p>将下载的资源进行解压:</p> 
<pre><code class="prism language-java"> tar <span class="token operator">-</span>zxf lua<span class="token operator">-</span>nginx<span class="token operator">-</span><span class="token keyword">module</span><span class="token operator">-</span><span class="token number">0.10</span><span class="token number">.16</span>rc4<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<p>更改目录名:</p> 
<pre><code class="prism language-java">mv lua<span class="token operator">-</span>nginx<span class="token operator">-</span><span class="token keyword">module</span><span class="token operator">-</span><span class="token number">0.10</span><span class="token number">.16</span>rc4 lua<span class="token operator">-</span>nginx<span class="token operator">-</span><span class="token keyword">module</span>
</code></pre> 
<p>导入环境变量，告诉Nginx去哪里找luajit</p> 
<pre><code class="prism language-java">export <span class="token constant">LUAJIT_LIB</span><span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>lib
export <span class="token constant">LUAJIT_INC</span><span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>include<span class="token operator">/</span>luajit<span class="token operator">-</span><span class="token number">2.0</span>
</code></pre> 
<p>进入Nginx的目录执行如下命令:</p> 
<pre><code class="prism language-java"><span class="token punctuation">.</span>/configure <span class="token operator">--</span>prefix<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx <span class="token operator">--</span>add<span class="token keyword">module</span><span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span>/lua<span class="token operator">-</span>nginx<span class="token operator">-</span><span class="token keyword">module</span>
</code></pre> 
<p>进行编译与安装</p> 
<pre><code class="prism language-java">make <span class="token operator">&amp;&amp;</span> make install
</code></pre> 
<blockquote> 
 <p>注意事项:</p> 
</blockquote> 
<p>（1）如果启动Nginx出现如下错误:</p> 
<p><img src="https://images2.imgbox.com/42/9e/Hi4YyMJd_o.png" alt="在这里插入图片描述"></p> 
<p>解决方案:</p> 
<p>设置软链接，使用如下命令</p> 
<pre><code class="prism language-java">ln <span class="token operator">-</span>s <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>lib<span class="token operator">/</span>libluajit<span class="token operator">-</span><span class="token number">5.1</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">2</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libluajit<span class="token operator">-</span><span class="token number">5.1</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">2</span>
</code></pre> 
<p>（2）如果启动Nginx出现以下错误信息</p> 
<p><img src="https://images2.imgbox.com/1d/c5/2tjS0WAY_o.png" alt="在这里插入图片描述"><br> 分析原因:因为lua-nginx-module是来自openrestry,错误中提示的<br> resty.core是openrestry的核心模块，对其下的很多函数进行了优化等工作。以前的版本默认不会把该模块编译进去，所以需要使用的话，我们得手动安装，或者禁用就可以。但是最新的lua-nginx-module模块已经强制性安装了该模块，所以此处因为缺少resty模块导致的报错信息。</p> 
<p>解决方案有两个: <strong>一种是下载对应的模块</strong>，<strong>另一种则是禁用掉restry模块</strong>，禁用的方式为:</p> 
<pre><code class="prism language-java">http<span class="token punctuation">{<!-- --></span>
	lua_load_resty_core off<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>测试<br> 在nginx.conf下配置如下内容:</li></ol> 
<pre><code class="prism language-java">location <span class="token operator">/</span>lua<span class="token punctuation">{<!-- --></span>
	default_type 'text<span class="token operator">/</span>html'<span class="token punctuation">;</span>
	content_by_lua 'ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"&lt;h1&gt;HELLO,LUA&lt;/h1&gt;"</span><span class="token punctuation">)</span>'<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>配置成功后，启动nginx,通过浏览器进行访问，如果获取到如下结果，则证明安装成功。<br> <img src="https://images2.imgbox.com/23/4a/thEACvbr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_OpenRestry__2794"></a>(2).方式二: OpenRestry (推荐⭐)</h5> 
<blockquote> 
 <p>概述</p> 
</blockquote> 
<p>前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站(<a href="http://openresty.org/" rel="nofollow">http://openresty.org/</a>)我们读起来是非常的方便。<mark>OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua库、第三方模块以及大多数的依赖项</mark>。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。</p> 
<blockquote> 
 <p>安装</p> 
</blockquote> 
<pre><code class="prism language-yaml"><span class="token comment"># 因为openresty内置了nginx所以，我们先把宿主机的nginx关闭</span>
nginx <span class="token punctuation">-</span>s stop 
<span class="token comment">#(1) 下载OpenResty：</span>
https<span class="token punctuation">:</span>//openresty.org/download/openresty<span class="token punctuation">-</span>1.15.8.2.tar.gz
<span class="token comment">#(2)使用wget下载:</span>
mkdir openresty
cd openresty
wget https<span class="token punctuation">:</span>//openresty.org/download/openresty<span class="token punctuation">-</span>1.15.8.2.tar.gz
<span class="token comment">#(3)解压缩:</span>
 tar <span class="token punctuation">-</span>zxf openresty<span class="token punctuation">-</span>1.15.8.2.tar.gz
<span class="token comment">#(4)进入OpenResty目录: </span>
cd openresty<span class="token punctuation">-</span>1.15.8.2
<span class="token comment">#(5) 执行命令:</span>
./configure
<span class="token comment">#(6) 执行命令:</span>
make <span class="token important">&amp;&amp;</span> make install
<span class="token comment">#(7)进入OpenResty的目录，找到nginx：</span>
cd /usr/local/openresty/nginx/conf
<span class="token comment">#(8)在conf目录下的nginx.conf添加如下内容</span>
location /lua<span class="token punctuation">{<!-- --></span>
	default_type 'text/html';
	content_by_lua 'ngx.say("&lt;h1<span class="token punctuation">&gt;</span>HELLO<span class="token punctuation">,</span>OpenRestry&lt;/h1<span class="token punctuation">&gt;</span>")';
<span class="token punctuation">}</span>
<span class="token comment">#(9)在sbin目录下启动nginx</span>
./nginx
<span class="token comment">#(10)通过浏览器访问测试</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/81/85/q6ZspJPp_o.png" alt="在这里插入图片描述"><br> <a href="http://8.130.48.9/lua" rel="nofollow">http://8.130.48.9/lua</a></p> 
<p><img src="https://images2.imgbox.com/fb/ac/Wrnovlrn_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2ngx_lua_2837"></a>2.ngx_lua的使用</h3> 
<p>使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。</p> 
<p><img src="https://images2.imgbox.com/d2/94/B0CYUYhE_o.png" alt="在这里插入图片描述"><br> 先来解释下*的作用</p> 
<pre><code class="prism language-java"><span class="token operator">*</span><span class="token operator">:</span> 无 ， 即 xxx_by_lua <span class="token punctuation">,</span>指令后面跟的是 lua指令
<span class="token operator">*</span><span class="token operator">:</span>_file，即 xxx_by_lua_file 指令后面跟的是 lua文件
<span class="token operator">*</span><span class="token operator">:</span>_block<span class="token punctuation">,</span>即 xxx_by_lua_block 在<span class="token number">0.9</span><span class="token number">.17</span>版后替换init_by_lua_file
</code></pre> 
<h5><a id="1init_by_lua_2848"></a>(1).init_by_lua*</h5> 
<p>该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。</p> 
<h5><a id="2init_worker_by_lua_2851"></a>(2).init_worker_by_lua*</h5> 
<p>该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。</p> 
<h5><a id="3set_by_lua_2853"></a>(3).set_by_lua*</h5> 
<p>该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。</p> 
<h5><a id="4rewrite_by_lua_2856"></a>(4).rewrite_by_lua*</h5> 
<p>该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。</p> 
<h5><a id="5access_by_lua_2859"></a>(5).access_by_lua*</h5> 
<p>该指令用于访问控制。例如，如果只允许内网IP访问。</p> 
<h5><a id="6content_by_lua_2861"></a>(6).content_by_lua*</h5> 
<p>该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。</p> 
<h5><a id="7header_filter_by_lua_2864"></a>(7).header_filter_by_lua*</h5> 
<p>该指令用于设置应答消息的头部信息。</p> 
<h5><a id="8body_filter_by_lua_2866"></a>(8).body_filter_by_lua*</h5> 
<p>该指令是对响应数据进行过滤，如截断、替换。</p> 
<h5><a id="9log_by_lua_2868"></a>(9).log_by_lua*</h5> 
<p>该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。</p> 
<h5><a id="10balancer_by_lua_2870"></a>(10).balancer_by_lua*</h5> 
<p>该指令主要的作用是用来实现上游服务器的负载均衡器算法</p> 
<h5><a id="11ssl_certificate_by__2872"></a>(11).ssl_certificate_by_*</h5> 
<p>该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4294524beb257c30ed7d7462930c22b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">霜雪满路——谨以此文纪念CSDN入住一年</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50f5caf0a41df52d68fa014897157e75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【算法】已知rand1() 生成rand5()，rand7()生成rand10()</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>