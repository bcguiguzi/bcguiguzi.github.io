<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kotlin 之 Flow - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kotlin 之 Flow" />
<meta property="og:description" content="Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable、 Flowable 等等，所以很多人都用 Flow 与 RxJava 做对比。而 Flow 则比 RxJava 简单很多。
我们知道 MVVM 中 LiveData 是一个生命周期感知组件，最好在 View 和 ViewModel 层中使用它，如果在 Repositories 或者 DataSource 中使用会有这两个主要的问题：不支持线程切换，其次不支持背压。而 Flow 正好是为解决此问题的。
RxJava 与 Flow 比较
RxJava模式 Flowable.create&lt;Int&gt;({ for (index in 1..10) { println(index) it.onNext(index) } it.onComplete() }, BackpressureStrategy.BUFFER) .map { return@map it * it } .filter { return@filter it &gt; 5 } .toList() .subscribe({ println(it) }, { println(it) }) Flow 模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a0aed03b83782f709538e3669e3ee829/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-28T22:45:11+08:00" />
<meta property="article:modified_time" content="2020-10-28T22:45:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kotlin 之 Flow</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-indent:33px;">Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable、 Flowable 等等，所以很多人都用 Flow 与 RxJava 做对比。而 Flow 则比 RxJava 简单很多。</p> 
<p style="text-indent:33px;">我们知道 MVVM 中 LiveData 是一个生命周期感知组件，最好在 View 和 ViewModel 层中使用它，如果在 Repositories 或者 DataSource 中使用会有这两个主要的问题：不支持线程切换，其次不支持背压。而 Flow 正好是为解决此问题的。</p> 
<p style="text-indent:33px;"><strong>RxJava 与 Flow 比较</strong></p> 
<p style="text-indent:33px;">RxJava模式 </p> 
<pre><code>    Flowable.create&lt;Int&gt;({
        for (index in 1..10) {
            println(index)
            it.onNext(index)
        }
        it.onComplete()
    }, BackpressureStrategy.BUFFER)
        .map {
            return@map it * it
        }
        .filter {
            return@filter it &gt; 5
        }
        .toList()
        .subscribe({
            println(it)
        }, {
            println(it)
        })</code></pre> 
<p style="text-indent:33px;">Flow 模式</p> 
<pre><code>    try {
        flow {
            for (index in 1..10) {
                println(index)
                emit(index)
            }
        }.map {
            it * it
        }
            .filter {
                it &gt; 5
            }
            .toList()
            .apply {
                println(this)
            }
    } catch (e: Exception) {
        println(e)
    }</code></pre> 
<p style="text-indent:33px;">通过 RxJava 与 Flow 的两个实现，可以看到代码简化程度不相伯仲。RxJava 入门的门槛很高，学习成本较高。Flow 则较为简单，没有 RxJava 中那么多的操作符，设计初衷就是解决单一问题。下面列出 Flow 的优点：</p> 
<p style="text-indent:33px;">Flow 支持线程切换、背压</p> 
<p style="text-indent:33px;">Flow 入门的门槛很低，没有那么多傻傻分不清楚的操作符</p> 
<p style="text-indent:33px;">简单的数据转换与操作符，如 map 等等</p> 
<p style="text-indent:33px;">Flow 是对 Kotlin 协程的扩展，让我们可以像运行同步代码一样运行异步代码，使得代码更加简洁，提高了代码的可读性</p> 
<p style="text-indent:33px;">易于做单元测试</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;"><strong>Flow</strong></p> 
<p style="text-indent:33px;">下面正式说下 Flow 的使用</p> 
<p style="text-indent:33px;">Flow 是非阻塞的，以挂起的方式执行，只有遇到末端操作符，才会触发所有操作的执行，所有操作都在相同的代码块内顺序执行，发射出来的值都是顺序执行的，只有在某一时刻结束（遇到末端操作符或者出现异常）。</p> 
<p style="text-indent:33px;">其中中间操作符与末端操作符列出</p> 
<p style="text-indent:33px;"><strong>中间操作符 </strong>：<span style="color:#000000;">map、</span>filter、take、zip 等，它们最后都是通过 emit 来发射数据。</p> 
<pre><code>public inline fun &lt;T, R&gt; Flow&lt;T&gt;.map(crossinline transform: suspend (value: T) -&gt; R): Flow&lt;R&gt; = transform { value -&gt;
   return@transform emit(transform(value))
}

public inline fun &lt;T&gt; Flow&lt;T&gt;.filter(crossinline predicate: suspend (T) -&gt; Boolean): Flow&lt;T&gt; = transform { value -&gt;
    if (predicate(value)) return@transform emit(value)
}</code></pre> 
<p style="text-indent:33px;"><strong>末端操作符</strong><strong> </strong>：collect、collectLatest、single、reduce<span style="color:#000000;">、</span>toCollection、toList 等，最后都是调用 collect 。</p> 
<pre><code>public suspend fun &lt;T&gt; Flow&lt;T&gt;.toList(destination: MutableList&lt;T&gt; = ArrayList()): List&lt;T&gt; = toCollection(destination)

public suspend fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Flow&lt;T&gt;.toCollection(destination: C): C {
    collect { value -&gt;
        destination.add(value)
    }
    return destination
}</code></pre> 
<p style="text-indent:33px;">遇到中间操作符，并不会执行任何操作，也不会挂起函数本身，这些操作符构建了一个待执行的调用链。遇到末端操作符会触发所有操作的执行。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;">Flow 只有遇到末端操作符才会触发所有操作的执行，所以 Flow 也被称为冷数据流。下面看下热数据流 Channel 。</p> 
<p style="text-indent:33px;"><strong>Channel</strong></p> 
<p style="text-indent:33px;">Channel 是非阻塞的，它用于发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通信，它实现了 SendChannel 和 ReceiveChannel 接口，所以既可以发送数据又可以接受数据，发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通过缓冲区进行同步的。</p> 
<p style="text-align:center;"><img alt="" height="512" src="https://images2.imgbox.com/66/2e/jlmafKMv_o.png" width="1200"></p> 
<p style="text-indent:33px;">Channel 包含发送与接受</p> 
<p style="text-indent:33px;"><strong>发送</strong></p> 
<p style="text-indent:33px;">send() 如果缓冲区没有满，则立即添加元素， 如果缓冲区满了调用者会被挂起，send() 方法是一个挂起函数，用于同步发送方和接收方的一种机制；</p> 
<p style="text-indent:33px;">offer() 如果缓冲区存在并且没有满立即向缓冲区添加一个元素，添加成功会返回 true, 失败会返回 false。</p> 
<p style="text-indent:33px;"><strong>接受</strong></p> 
<p style="text-indent:33px;">receive() 异步获取元素，如果缓冲区是空时调用者会被挂起，直到一个新值被发送到缓冲区，receive() 方法是一个挂起函数，用于同步发送方和接收方的一种机制。</p> 
<p style="text-indent:33px;">poll() 用于同步获取一个元素，如果缓冲区是空的，则返回 null。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;"><strong>Channel 有四种类型</strong></p> 
<p style="text-indent:33px;">RendezvousChannel ：这是默认的类型，大小为 0 的缓冲区，只有当 send() 方法和 receive() 方法都调用的时候，元素才会从发送方传输到接收方，否则将会被挂起。</p> 
<p style="text-indent:33px;">LinkedListChannel ：通过 Channel.Factory.CONFLATED 会创建一个容量无限的缓冲区 (受限于内存的大小) ，send() 方法远不会挂起，offer() 方法始终返回 true。</p> 
<p style="text-indent:33px;">ConflatedChannel ：最多缓冲一个元素，新元素会覆盖掉旧元素，只会接收最后发送的元素，之前的元素都会丢失，send() 方法永远不会挂起，offer() 方法始终返回 true。</p> 
<p style="text-indent:33px;">ArrayChannel ：通过 Channel.Factory.BUFFERED 或者 指定大小 会创建一个固定容量的数组缓冲区，send() 方法仅在缓冲区满时挂起，receive() 方法仅在缓冲区为空时挂起。</p> 
<p style="text-indent:33px;">通过源码可以看到</p> 
<pre><code>public fun &lt;E&gt; Channel(capacity: Int = RENDEZVOUS): Channel&lt;E&gt; =
    when (capacity) {
        RENDEZVOUS -&gt; RendezvousChannel()
        UNLIMITED -&gt; LinkedListChannel()
        CONFLATED -&gt; ConflatedChannel()
        BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY)
        else -&gt; ArrayChannel(capacity)
    }</code></pre> 
<p style="text-indent:33px;">它的使用方法比较简单，类似观察者方法，这里就不贴代码了。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;">Channel 的所发送的数据只能被一个消费者消费，而如果需要一对多的话那就需要 BroadcastChannel ，它会像我们平时使用广播一样进行分发给所有订阅者。另外需要注意的是，BroadcastChannel 不支持 RENDEZVOUS。</p> 
<p style="text-indent:33px;"><strong>BroadcastChannel</strong></p> 
<p style="text-indent:33px;">BroadcastChannel 是非阻塞的，它用于发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通信，实现了 SendChannel 接口，所以只可以发送数据；提供了 openSubscription 方法，会返回一个新的 ReceiveChannel，可以从缓冲区获取数据。</p> 
<p style="text-align:center;"><img alt="" height="512" src="https://images2.imgbox.com/af/9a/rRr0m856_o.png" width="1200"></p> 
<p style="text-indent:33px;">它的子类有 ArrayBroadcastChannel、BroadcastCoroutine、ConflatedBroadcastChannel、LazyBroadcastCoroutine 四种。</p> 
<p style="text-indent:33px;">使用方法</p> 
<pre><code>    runBlocking {
        val broadcastChannel = GlobalScope.broadcast {
            for (i in 0..3) {
                send(i)
            }
        }
        List(2) { index -&gt;
            GlobalScope.launch {
                for (i in broadcastChannel.openSubscription()) {
                    println(" 协程$index 接收 $i")
                }
            }

        }.joinAll()
    }</code></pre> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;">今日这篇大致完成，下面记录 kotlin 较复杂的一些函数：</p> 
<p style="text-indent:33px;"><strong>debounce</strong> 防抖动函数，指定时间内只会发送最后一个字符串。</p> 
<pre><code>        flow {
            emit(1)
            emit(2)
            emit(3)
            delay(90)
            emit(4)
            emit(5)
        }
            .debounce(200)
            .toList()
            .apply {
                println(this)//[5]
            }</code></pre> 
<p style="text-indent:33px;"><strong>flatMapLatest </strong>一定时间内获取最新的数据</p> 
<pre><code>        flow {
            emit(1)
            emit(2)
            emit(3)
        }
            .flatMapLatest {
                flow {
                    delay(100)
                    emit(it)
                }
            }
            .toList()
            .apply {
                print(this)//[3]
            }</code></pre> 
<p style="text-indent:33px;"><strong>distinctUntilChanged</strong> 过滤掉重复的请求</p> 
<pre><code>        flow {
            emit(1)
            emit(1)
            emit(1)
            emit(1)
            emit(2)
            emit(2)
            emit(2)
            emit(2)
            emit(2)
        }
            .distinctUntilChanged()
            .toList()
            .apply {
                println(this)//[1, 2]
            }</code></pre> 
<p style="text-indent:33px;">这些方法的源码这里就不多解释了，注意要跟一下源码，了解下如何实现的。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62b79be9b88081e804ab11e375c564fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">druid，impala，presto对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ddee9868900f921bbc208994a625095/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">怎样学好python编程-如何系统地自学 Python？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>