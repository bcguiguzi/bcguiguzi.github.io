<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像处理（YOJ2.0中的题） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像处理（YOJ2.0中的题）" />
<meta property="og:description" content="题目如上（至于YOJ2.0，那是我学校的做题网站）
先说一下感受吧：真的是爽死了，不过因为有提前打草稿（电纸书神！），所以中间的思路完全没出错，有什么错的话，也只有在输入上有问题。写了一个小时多，真的爽，希望以后能秒了
因为我有写注释，就不写解题思路了，核心就是一开始设置的两个数组，一个记录各点的数据，另一个记录坏点坐标（实际上你看名称也可以看得懂）
代码如下：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int m, n; scanf(&#34;%d%d&#34;, &amp;n, &amp;m); int data[n][m][4];//三个记数据，一个是否 int dead_pixel[m * n][3];//两个记坐标，一个是否 int num_of_dead_pixel = 0; //对数据预处理 for(int i = 0; i &lt; n; i&#43;&#43;) { for(int j = 0; j &lt; m; j&#43;&#43;) { //输入 getchar(); getchar(); scanf(&#34;%d&#34;, &amp;data[i][j][0]); getchar(); getchar(); getchar(); scanf(&#34;%d&#34;, &amp;data[i][j][1]); getchar(); getchar(); getchar(); scanf(&#34;%d&#34;, &amp;data[i][j][2]); getchar(); //处理 if(data[i][j][0] &#43; data[i][j][1] &#43; data[i][j][2] == 0) { data[i][j][3] = 1; dead_pixel[num_of_dead_pixel][0] = i; dead_pixel[num_of_dead_pixel][1] = j; dead_pixel[num_of_dead_pixel][2] = 1; num_of_dead_pixel&#43;&#43;; } else data[i][j][3] = 0; } } //开始修复 int num = num_of_dead_pixel; while(num) { for(int i = 0; i &lt; num_of_dead_pixel; i&#43;&#43;) { if(dead_pixel[i][2]) { //相加 int all_R = 0, all_G = 0, all_B = 0;//计算上下左右的总和 double num_tmp = 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/42b566f6c355e777c4d8e17bc19d71e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-22T19:13:58+08:00" />
<meta property="article:modified_time" content="2023-10-22T19:13:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像处理（YOJ2.0中的题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/26/1GGdFxuH_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/63/35/CV9ixXI8_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/44/1e/I5kVDy33_o.png"></p> 
<p>题目如上（至于YOJ2.0，那是我学校的做题网站）</p> 
<p>先说一下感受吧：真的是爽死了，不过因为有提前打草稿（电纸书神！），所以中间的思路完全没出错，有什么错的话，也只有在输入上有问题。写了一个小时多，真的爽，希望以后能秒了</p> 
<p>因为我有写注释，就不写解题思路了，核心就是一开始设置的两个数组，一个记录各点的数据，另一个记录坏点坐标（实际上你看名称也可以看得懂）</p> 
<p>代码如下：</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void)
{
    int m, n;
    scanf("%d%d", &amp;n, &amp;m);
    int data[n][m][4];//三个记数据，一个是否
    int dead_pixel[m * n][3];//两个记坐标，一个是否
    int num_of_dead_pixel = 0;

    //对数据预处理
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; m; j++)
        {
            //输入
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][0]);
            getchar();
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][1]);
            getchar();
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][2]);
            getchar();
            //处理
            if(data[i][j][0] + data[i][j][1] + data[i][j][2] == 0)
            {
                data[i][j][3] = 1;
                dead_pixel[num_of_dead_pixel][0] = i;
                dead_pixel[num_of_dead_pixel][1] = j;
                dead_pixel[num_of_dead_pixel][2] = 1;
                num_of_dead_pixel++;
            }
            else
                data[i][j][3] = 0;
        }
    }
    
    //开始修复
    int num = num_of_dead_pixel;
    while(num)
    {
        for(int i = 0; i &lt; num_of_dead_pixel; i++)
        {
            if(dead_pixel[i][2])
            {
                //相加
                int all_R = 0, all_G = 0, all_B = 0;//计算上下左右的总和
                double num_tmp = 0.0;//用来记录加了多少次
                if(dead_pixel[i][0] != 0)//上
                    if(data[dead_pixel[i][0] - 1][dead_pixel[i][1]][3] != 1)
                    {
                        all_R += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][0];
                        all_G += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][1];
                        all_B += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][2];
                        num_tmp += 1.0;
                    }
                if(dead_pixel[i][0] != n - 1)//下
                    if(data[dead_pixel[i][0] + 1][dead_pixel[i][1]][3] != 1)
                    {
                        all_R += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][0];
                        all_G += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][1];
                        all_B += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][2];
                        num_tmp += 1.0;
                    }
                if(dead_pixel[i][1] != 0)//左
                    if(data[dead_pixel[i][0]][dead_pixel[i][1] - 1][3] != 1)
                    {
                        all_R += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][0];
                        all_G += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][1];
                        all_B += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][2];
                        num_tmp += 1.0;
                    }
                if(dead_pixel[i][1] != m - 1)//右
                    if(data[dead_pixel[i][0]][dead_pixel[i][1] + 1][3] != 1)
                    {
                        all_R += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][0];
                        all_G += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][1];
                        all_B += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][2];
                        num_tmp += 1.0;
                    }
                //赋值修复
                if(num_tmp == 0.0)//代表上下左右为坏点，等于没修
                    continue;
                else
                {
                    data[dead_pixel[i][0]][dead_pixel[i][1]][0] = (int)(ceil((double)all_R / num_tmp));
                    data[dead_pixel[i][0]][dead_pixel[i][1]][1] = (int)(ceil((double)all_G / num_tmp));
                    data[dead_pixel[i][0]][dead_pixel[i][1]][2] = (int)(ceil((double)all_B / num_tmp));
                }

                dead_pixel[i][2] = 2;//2代表这轮是坏点
                num--;
            }
        }
        //使这轮修复的不再是坏点
        for(int i = 0; i &lt; num_of_dead_pixel; i++)
            if(dead_pixel[i][2] == 2)
            {
                dead_pixel[i][2] = 0;
                data[dead_pixel[i][0]][dead_pixel[i][1]][3] = 0;
            }
    }

    //输出
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; m; j++)
        {
            printf("R %d G %d B %d", data[i][j][0], data[i][j][1], data[i][j][2]);
            if(j &lt; m - 1)
                putchar(' ');
        }
        if(i &lt; n - 1)
            putchar('\n');
    }

    return 0;
}</code></pre> 
<p>虽然英文名称可以让我们一看就懂，但是太长了搞得我有点头晕，以后试试缩写吧</p> 
<p>最后就得了90分，有一个数据超时了（爽死了）</p> 
<p>明天要去调研（双学位的苦），找个时间给代码优化一下</p> 
<p></p> 
<p>补充：调研完回来看代码了，感觉已经是最简的版本了，所以根本想不出其他的办法，最后发现是可以看范例的输入和输出，然后发现：居然还有全都是坏点根本修不了的情况，最后简单改了一下代码（就加了个判断语句），得了个100</p> 
<p></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void)
{
    int m, n;
    scanf("%d%d", &amp;n, &amp;m);
    int data[n][m][4];//三个记数据，一个是否
    int dead_pixel[m * n][3];//两个记坐标，一个是否
    int num_of_dead_pixel = 0;

    //对数据预处理
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; m; j++)
        {
            //输入
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][0]);
            getchar();
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][1]);
            getchar();
            getchar();
            getchar();
            scanf("%d", &amp;data[i][j][2]);
            getchar();
            //处理
            if(data[i][j][0] + data[i][j][1] + data[i][j][2] == 0)
            {
                data[i][j][3] = 1;
                dead_pixel[num_of_dead_pixel][0] = i;
                dead_pixel[num_of_dead_pixel][1] = j;
                dead_pixel[num_of_dead_pixel][2] = 1;
                num_of_dead_pixel++;
            }
            else
                data[i][j][3] = 0;
        }
    }
    
    //开始修复
    if(num_of_dead_pixel != m * n)
    {
        int num = num_of_dead_pixel;
        while(num)
        {
            for(int i = 0; i &lt; num_of_dead_pixel; i++)
            {
                if(dead_pixel[i][2])
                {
                    //相加
                    int all_R = 0, all_G = 0, all_B = 0;//计算上下左右的总和
                    double num_tmp = 0.0;//用来记录加了多少次
                    if(dead_pixel[i][0] != 0)//上
                        if(data[dead_pixel[i][0] - 1][dead_pixel[i][1]][3] != 1)
                        {
                            all_R += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][0];
                            all_G += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][1];
                            all_B += data[dead_pixel[i][0] - 1][dead_pixel[i][1]][2];
                            num_tmp += 1.0;
                        }
                    if(dead_pixel[i][0] != n - 1)//下
                        if(data[dead_pixel[i][0] + 1][dead_pixel[i][1]][3] != 1)
                        {
                            all_R += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][0];
                            all_G += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][1];
                            all_B += data[dead_pixel[i][0] + 1][dead_pixel[i][1]][2];
                            num_tmp += 1.0;
                        }
                    if(dead_pixel[i][1] != 0)//左
                        if(data[dead_pixel[i][0]][dead_pixel[i][1] - 1][3] != 1)
                        {
                            all_R += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][0];
                            all_G += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][1];
                            all_B += data[dead_pixel[i][0]][dead_pixel[i][1] - 1][2];
                            num_tmp += 1.0;
                        }
                    if(dead_pixel[i][1] != m - 1)//右
                        if(data[dead_pixel[i][0]][dead_pixel[i][1] + 1][3] != 1)
                        {
                            all_R += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][0];
                            all_G += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][1];
                            all_B += data[dead_pixel[i][0]][dead_pixel[i][1] + 1][2];
                            num_tmp += 1.0;
                        }
                    //赋值修复
                    if(num_tmp == 0.0)//代表上下左右为坏点，等于没修
                        continue;
                    else
                    {
                        data[dead_pixel[i][0]][dead_pixel[i][1]][0] = (int)(ceil((double)all_R / num_tmp));
                        data[dead_pixel[i][0]][dead_pixel[i][1]][1] = (int)(ceil((double)all_G / num_tmp));
                        data[dead_pixel[i][0]][dead_pixel[i][1]][2] = (int)(ceil((double)all_B / num_tmp));
                    }

                    dead_pixel[i][2] = 2;//2代表这轮是坏点
                    num--;
                }
            }
            //使这轮修复的不再是坏点
            for(int i = 0; i &lt; num_of_dead_pixel; i++)
                if(dead_pixel[i][2] == 2)
                {
                    dead_pixel[i][2] = 0;
                    data[dead_pixel[i][0]][dead_pixel[i][1]][3] = 0;
                }
        }
    }

    //输出
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; m; j++)
        {
            printf("R %d G %d B %d", data[i][j][0], data[i][j][1], data[i][j][2]);
            if(j &lt; m - 1)
                putchar(' ');
        }
        if(i &lt; n - 1)
            putchar('\n');
    }

    return 0;
}</code></pre> 
<p>哭死</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec380c56b58944ae4c2e41e6bf205d5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于LangChain的LLM应用开发3——记忆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5010bcf7c1ec8dac501714ba8bedb30f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">yolo格式转labelme格式并验证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>