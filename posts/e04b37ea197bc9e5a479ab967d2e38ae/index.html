<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈四种线程池 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈四种线程池" />
<meta property="og:description" content="转自：微点阅读 https://www.weidianyuedu.com
首先我们先看一下获取四种线程池的代码：
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10); ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); 可以发现这四种线程池都是由Executors类生成的。依次点开四个方法的内部实现发现，它们最终调用的都是同一个ThreadPoolExecutor()的构造器，而区别在于构造器的参数不同。我们来看下ThreadPoolExecutor的参数列表：
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { 正是由于这几个参数的不同导致了四种线程池的工作机制不同。参考源码对于参数的注释，我们列出参数的含义。
corePoolSize：核心线程数量，常驻在线程池中的线程，即使它们是空闲的，也不会销毁，除非设置allowCoreThreadTimeOut的值。
maximumPoolSize：线程池最大线程数量
keepAliveTime：超过核心数量的额外线程也就是非核心线程，在空闲指定的最大时间后被销毁。（假设时间为5s,核心线程数为2，当前线程为4，则超过核心线程数的其余两个线程在空闲5秒后会被销毁。）
unit：时间单位
workQueue：等待队列
threadFactory：生成线程的工厂
handler：当等待队列容量满以及线程池数量达到最大时，如何处理新的任务。
AbortPolicy（默认）：直接抛出异常
CallerRunsPolicy：交给调用者所在线程执行。（假设当前调用者线程是Main，那么就交给Main处理）
DiscardOldestPolicy：丢弃最久未处理的任务，再执行当前任务。（最久未处理的，在队列中其实就是队列头节点，查看源码的确调用是poll()方法）
DiscardPolicy：丢掉该任务，并且不抛异常。
线程池的工作机制：
当持续往线程池添加任务，当前线程数量小于核心线程数量的时候，新增线程。当前线程数量达到核心线程数量的时候，将任务放入等待队列。当等待队列满的时候，继续创建新线程。当线程池数量达到最大并且等待队列也满的时候，采取拒绝服务策略。
接下来我们就根据参数来分析不同的线程池：
FixedThreadPool public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 我们可以看到corePoolSize核心线程数量和maximumPoolSize最大线程数量是一致的，并且keepAliveTime为0。workQueue是LinkedBlockingQueue，这是一个链表阻塞队列。可以得出结论：该线程池是一个固定数量的线程池，并且有一个无界的等待队列。我们可以推导出该线程池适合处理任务量平稳的场景。例如平均一秒接收10个任务，接收任务量曲线不会很陡峭。
适合场景：适合少量的大任务（大任务处理慢，如果线程数量多的话，反而在切换线程上下文时损耗，所以控制线程在一定的数量）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e04b37ea197bc9e5a479ab967d2e38ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-05T15:29:30+08:00" />
<meta property="article:modified_time" content="2022-08-05T15:29:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈四种线程池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转自：<a class="link-info" href="https://www.weidianyuedu.com" rel="nofollow" title="微点阅读">微点阅读</a>   <a href="https://www.weidianyuedu.com" rel="nofollow" title="https://www.weidianyuedu.com">https://www.weidianyuedu.com</a></p> 
<p></p> 
<p>首先我们先看一下获取四种线程池的代码：</p> 
<ul><li><li><li><li></ul> 
<pre><code>    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);</code><code>    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</code><code>    ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);</code><code>    ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</code></pre> 
<p>可以发现这四种线程池都是由Executors类生成的。依次点开四个方法的内部实现发现，它们最终调用的都是同一个ThreadPoolExecutor()的构造器，而区别在于构造器的参数不同。我们来看下ThreadPoolExecutor的参数列表：</p> 
<ul><li><li><li><li><li><li><li></ul> 
<pre><code>public ThreadPoolExecutor(int corePoolSize,</code><code>                              int maximumPoolSize,</code><code>                              long keepAliveTime,</code><code>                              TimeUnit unit,</code><code>                              BlockingQueue&lt;Runnable&gt; workQueue,</code><code>                              ThreadFactory threadFactory,</code><code>                              RejectedExecutionHandler handler) {<!-- --></code></pre> 
<p>正是由于这几个参数的不同导致了四种线程池的工作机制不同。参考源码对于参数的注释，我们列出参数的含义。</p> 
<ul><li> <p>corePoolSize：核心线程数量，常驻在线程池中的线程，即使它们是空闲的，也不会销毁，除非设置allowCoreThreadTimeOut的值。</p> </li><li> <p>maximumPoolSize：线程池最大线程数量</p> </li><li> <p>keepAliveTime：超过核心数量的额外线程也就是非核心线程，在空闲指定的最大时间后被销毁。（假设时间为5s,核心线程数为2，当前线程为4，则超过核心线程数的其余两个线程在空闲5秒后会被销毁。）</p> </li><li> <p>unit：时间单位</p> </li><li> <p>workQueue：等待队列</p> </li><li> <p>threadFactory：生成线程的工厂</p> </li><li> <p>handler：当等待队列容量满以及线程池数量达到最大时，如何处理新的任务。</p> 
  <ul><li> <p>AbortPolicy（默认）：直接抛出异常</p> </li><li> <p>CallerRunsPolicy：交给调用者所在线程执行。（假设当前调用者线程是Main，那么就交给Main处理）</p> </li><li> <p>DiscardOldestPolicy：丢弃最久未处理的任务，再执行当前任务。（最久未处理的，在队列中其实就是队列头节点，查看源码的确调用是poll()方法）</p> </li><li> <p>DiscardPolicy：丢掉该任务，并且不抛异常。</p> </li></ul></li></ul> 
<p><strong>线程池的工作机制：</strong></p> 
<p>当持续往线程池添加任务，当前线程数量小于核心线程数量的时候，新增线程。当前线程数量达到核心线程数量的时候，将任务放入等待队列。当等待队列满的时候，继续创建新线程。当线程池数量达到最大并且等待队列也满的时候，采取拒绝服务策略。</p> 
<p><strong>接下来我们就根据参数来分析不同的线程池：</strong></p> 
<h4><a name="t0"></a><strong>FixedThreadPool</strong></h4> 
<ul><li><li><li><li><li></ul> 
<pre><code> public static ExecutorService newFixedThreadPool(int nThreads) {<!-- --></code><code>        return new ThreadPoolExecutor(nThreads, nThreads,</code><code>                                      0L, TimeUnit.MILLISECONDS,</code><code>                                      new LinkedBlockingQueue&lt;Runnable&gt;());</code><code>    }</code></pre> 
<p>我们可以看到corePoolSize核心线程数量和maximumPoolSize最大线程数量是一致的，并且keepAliveTime为0。workQueue是LinkedBlockingQueue，这是一个链表阻塞队列。可以得出结论：该线程池是一个固定数量的线程池，并且有一个无界的等待队列。我们可以推导出该线程池适合处理任务量平稳的场景。例如平均一秒接收10个任务，接收任务量曲线不会很陡峭。</p> 
<p>适合场景：适合少量的大任务（大任务处理慢，如果线程数量多的话，反而在切换线程上下文时损耗，所以控制线程在一定的数量）。</p> 
<h4><a name="t1"></a><strong>CachedThreadPool</strong></h4> 
<ul><li><li><li><li><li></ul> 
<pre><code>public static ExecutorService newCachedThreadPool() {<!-- --></code><code>        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</code><code>                                      60L, TimeUnit.SECONDS,</code><code>                                      new SynchronousQueue&lt;Runnable&gt;());</code><code>    }</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p>我们可以看到corePoolSize核心线程池为0，代表该线程没有核心线程池，意味着线程都是可被回收销毁的，线程池中有时会是空的。并且maximumPoolSize是int最大值，相当于代表该线程池可以无限创建线程。keepAliveTime为60，代表空闲60秒回收线程。workQueue是SynchronousQueue，该同步队列是一个没有容量队列，即一个任务到来后，要等待线程来消费，才能再继续添加任务。我们推导出该线程池适合处理平时没什么任务量，但有时任务量瞬间剧增的场景。</p> 
<p>适合场景：大量的小任务（每个任务处理快，不会频繁出现线程处理一半时，切换其他线程）。</p> 
<p><strong>ScheduledThreadPool</strong></p> 
<ul><li><li><li><li></ul> 
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {<!-- --></code><code>        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</code><code>              new DelayedWorkQueue());</code><code>    }</code></pre> 
<p></p> 
<p>我们可以看到该线程池参数最大的区别在于workQueue是DelayedWorkQueue。该队列是一个按延迟时间从小到大排序的堆。并且当队列头节点的延迟时间小于0的时候返回该节点。所以该线程池可以指定一个时间进行定时任务。也可以通过添加任务时递增延迟时间，来进行周期任务。</p> 
<p>适合场景：定时任务或者周期任务。</p> 
<h4><a name="t2"></a><strong>SingleThreadExecutor</strong></h4> 
<p></p> 
<p></p> 
<ul><li><li><li><li><li><li></ul> 
<pre><code>public static ExecutorService newSingleThreadExecutor() {<!-- --></code><code>        return new FinalizableDelegatedExecutorService</code><code>            (new ThreadPoolExecutor(1, 1,</code><code>                                    0L, TimeUnit.MILLISECONDS,</code><code>                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</code><code>    }</code></pre> 
<p>我们可以看到该线程池的corePoolSize核心线程数量和maximumPoolSize最大线程数量都是1，代表该线程有且只有一个固定的线程，既然是单线程，所以该线程池实现的是串行操作，没有并发效果。workQueue是LinkedBlockingQueue，这是一个链表阻塞队列。所以该线程池适合执行串行执行队列中的任务。</p> 
<p>适合场景：按顺序串行处理的任务。</p> 
<p><strong>可能读者会好奇keepAliveTime为0代表的含义？</strong><strong>是立即回收线程还是永不回收呢？</strong></p> 
<p>keepAliveTime参数注释明确指明只对非核心线程有用。我们可以从ScheduledThreadPool的源码中推测，如果0代表是永不回收的话，那么ScheduledThreadPool一旦创建出非核心线程的话就不会回收了？这样是很不合理的。所以笔者认为0代表立即回收。</p> 
<ul><li><li><li><li></ul> 
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {<!-- --></code><code>        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</code><code>              new DelayedWorkQueue());</code><code>    }</code></pre> 
<p><strong>笔者水平有限，如有错误恳请评论指正。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/708a1907f4a90bac43d783a29b8ebb31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">0基础学MySQL数据库—从小白到大牛(24)存储引擎</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59f14481af441705ecfa0ead39211d6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">laravel配置发送邮件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>