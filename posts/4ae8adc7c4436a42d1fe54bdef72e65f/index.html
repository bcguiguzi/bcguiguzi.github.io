<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>『 Linux 』进程替换( Process replacement ) 及 简单Shell的实现(万字) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="『 Linux 』进程替换( Process replacement ) 及 简单Shell的实现(万字)" />
<meta property="og:description" content="文章目录 🦄 进程替换🦩 execl()函数🦩 execlp()函数🦩 execle()函数🦩 execv()函数🦩 execvp()函数🦩 execvpe()函数🦩 execve()函数 🦄 简单Shell命令行解释器的实现🦩 大致框架与命令行提示符🦩 获取用户输入信息🦩 将缓冲区内的字符串进行分块🦩 分析并执行指令🦩 对cd命令进行处理🦩 简单Shell实现代码演示(供参考) 🦄 进程替换 在『 Linux 』Process Control进程控制(万字)-CSDN博客 中提到了些进程控制中的概念,但是在这篇文章当中对于进程替换的概念以及用法并没有完全;
在本篇文章中将对上篇文章中的进程替换的各个接口进行补充;
进程替换,按照字面意义上即为一个进程在运行过程当中替换为另一个进程;
在之前的博客当中可能提到过, 当一个程序被加载进内存当中时对应的内存会新生成一个对应的进程;
而在进程替换当中可以完美的对上面的理论进行一个反驳,即并不是每个程序加载到内存当中都会新生成一个对应的进程;
以该图为例,该图中一个正在执行的进程经过了进程替换,将磁盘中的程序的代码和数据加载到了被替换的进程对应的PCB结构体当中;
当然在物理内存当中需要对应的为该新载入的进程的数据代码开辟一块新的内存空间;
但实际上在进程地址空间来看的话也仅仅只是将对应的映射关系进行修改;
当新的程序代码数据被加载进物理内存时,随着进程逐渐发生替换,对应的原有的代码和数据也将渐渐被释放;
因为只是仅仅的发生映射关系的转换,故对应的PID等mm_struct内的数据都不会作修改;
在上篇文章中简单的使用了execl()进程替换函数进行了进程替换的演示;
#include &lt;unistd.h&gt; #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &#34;hello world1&#34; &lt;&lt; endl; cout &lt;&lt; &#34;hello world1&#34; &lt;&lt; endl; cout &lt;&lt; &#34;hello world1&#34; &lt;&lt; endl; printf(&#34;当前程序为myproc 且PID为:%d \n&#34;, getpid()); execl(&#34;./test_/mytest&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4ae8adc7c4436a42d1fe54bdef72e65f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T20:39:13+08:00" />
<meta property="article:modified_time" content="2024-03-14T20:39:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">『 Linux 』进程替换( Process replacement ) 及 简单Shell的实现(万字)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__6" rel="nofollow">🦄 进程替换</a></li><li><ul><li><a href="#_execl_91" rel="nofollow">🦩 execl()函数</a></li><li><a href="#_execlp_150" rel="nofollow">🦩 execlp()函数</a></li><li><a href="#_execle_200" rel="nofollow">🦩 execle()函数</a></li><li><a href="#_execv_259" rel="nofollow">🦩 execv()函数</a></li><li><a href="#_execvp_316" rel="nofollow">🦩 execvp()函数</a></li><li><a href="#_execvpe_371" rel="nofollow">🦩 execvpe()函数</a></li><li><a href="#_execve_425" rel="nofollow">🦩 execve()函数</a></li></ul> 
   </li><li><a href="#_Shell_491" rel="nofollow">🦄 简单Shell命令行解释器的实现</a></li><li><ul><li><a href="#__515" rel="nofollow">🦩 大致框架与命令行提示符</a></li><li><a href="#__552" rel="nofollow">🦩 获取用户输入信息</a></li><li><a href="#__591" rel="nofollow">🦩 将缓冲区内的字符串进行分块</a></li><li><a href="#__629" rel="nofollow">🦩 分析并执行指令</a></li><li><a href="#_cd_666" rel="nofollow">🦩 对cd命令进行处理</a></li><li><a href="#_Shell_697" rel="nofollow">🦩 简单Shell实现代码演示(供参考)</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="__6"></a>🦄 进程替换</h3> 
<p><img src="https://images2.imgbox.com/7b/6b/srYYxnyt_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4"> 在<a href="https://blog.csdn.net/2202_75303754/article/details/136548836?spm=1001.2014.3001.5501">『 Linux 』Process Control进程控制(万字)-CSDN博客</a> 中提到了些进程控制中的概念,但是在这篇文章当中对于进程替换的概念以及用法并没有完全;</font></p> 
<p><font face="华文楷体" size="4">在本篇文章中将对上篇文章中的进程替换的各个接口进行补充;</font></p> 
<p><font face="华文楷体" size="4">进程替换,按照字面意义上即为一个进程在运行过程当中替换为另一个进程;</font></p> 
<p><font face="华文楷体" size="4">在之前的博客当中可能提到过, <mark>当一个程序被加载进内存当中时对应的内存会新生成一个对应的进程</mark>;</font></p> 
<p><font face="华文楷体" size="4">而在进程替换当中可以完美的对上面的理论进行一个反驳,即并不是每个程序加载到内存当中都会新生成一个对应的进程;</font></p> 
<p><img src="https://images2.imgbox.com/80/22/ecTiinXh_o.png" alt="" width="500"></p> 
<p><font face="华文楷体" size="4">以该图为例,该图中一个正在执行的进程经过了进程替换,将磁盘中的程序的代码和数据加载到了被替换的进程对应的<code>PCB</code>结构体当中;</font></p> 
<p><font face="华文楷体" size="4">当然在物理内存当中需要对应的为该新载入的进程的数据代码开辟一块新的内存空间;</font></p> 
<p><font face="华文楷体" size="4">但实际上在进程地址空间来看的话也仅仅只是将对应的映射关系进行修改;</font></p> 
<p><font face="华文楷体" size="4">当新的程序代码数据被加载进物理内存时,随着进程逐渐发生替换,对应的原有的代码和数据也将渐渐被释放;</font></p> 
<p><font face="华文楷体" size="4">因为只是仅仅的发生映射关系的转换,故对应的<code>PID</code>等<code>mm_struct</code>内的数据都不会作修改;</font></p> 
<p><font face="华文楷体" size="4">在上篇文章中简单的使用了<code>execl()</code>进程替换函数进行了进程替换的演示;</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前程序为myproc 且PID为:%d \n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"./test_/mytest"</span><span class="token punctuation">,</span> <span class="token string">"mytest"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font face="华文楷体" size="4">这段程序中替换的程序的代码如下:</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前程序为mytest 且PID为:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p><font face="华文楷体" size="4">且该程序运行后的最终结果为:</font></p> 
<pre><code class="prism language-bash">$ ./myproc 
hello world1
hello world1
hello world1
当前程序为myproc 且PID为:14115 
当前程序为mytest 且PID为:14115
</code></pre> 
<p><font face="华文楷体" size="4">该段程序可以清楚证明对应的发生进程替换时对应的<code>PID</code>不会发生变化;</font></p> 
<p><font face="华文楷体" size="4">在上篇博客当中只介绍了一个<code>exec</code>家族的函数;</font></p> 
<p><font face="华文楷体" size="4">但是这样的函数一共有<code>7</code>个;</font></p> 
<p><font face="华文楷体" size="4">虽然<code>7</code>个接口函数实际的功能结果相同,但是对应的在传参上中有所不同;</font></p> 
<p><img src="https://images2.imgbox.com/16/e2/ifVh9UqV_o.png" alt="" width="500"></p> 
<hr> 
<h4><a id="_execl_91"></a>🦩 execl()函数</h4> 
<p><img src="https://images2.imgbox.com/72/45/vR5AbeAy_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execl()</code>的函数原型:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* (char *) NULL */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4">该函数的功能为执行指定的路径下的可执行文件,并用传递给它的参数替换原有的程序;</font></p> <p><font face="华文仿宋" size="4">这意味着原始的程序将被新程序替换,原始程序的代码将不再执行,而被<code>path</code>参数所指定的可执行文件加载并开始执行;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>path</code>参数是可执行文件的路径;</font></p> <p><font face="华文仿宋" size="4"><code>arg0</code>表示要传递给程序的第一个参数,通常是新程序的名称且他为一个字符串;</font></p> <p><font face="华文仿宋" size="4"><code>...</code>可选的参数列表,这些参数将作为进程替换后新程序的命令行参数传递,且参数列表必须以空指针<code>(char*)NULL</code>结尾;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该段代码中的原始程序若是未被新进程所替换时将会打印出两次<code>This is the original program\n</code>;</font></p> <p><font face="华文仿宋" size="4">而运行该段代码的结果为:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76536</span> Mar <span class="token number">14</span> <span class="token number">13</span>:51 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER   <span class="token number">357</span> Mar <span class="token number">14</span> <span class="token number">13</span>:51 test.cpp
</code></pre> <p><font face="华文仿宋" size="4">当进程发生替换了之后,原有进程的代码数据将被替换,故对应的代码不会执行;</font></p> <p><font face="华文仿宋" size="4">在使用进程替换时需要使用<code>errno</code>指定出对应的问题;</font></p> </li></ul> 
<hr> 
<h4><a id="_execlp_150"></a>🦩 execlp()函数</h4> 
<p><img src="https://images2.imgbox.com/63/65/30jJ5V4M_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execlp()</code>函数原型:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* (char *) NULL */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4"><code>execlp()</code>函数的工作方式与<code>execl()</code>类似,但不同之处在于它不需要指定文件的完整路径;</font></p> <p><font face="华文仿宋" size="4">它会在系统的<code>PATH</code>环境变量中搜索<code>file</code>参数所指定的可执行文件,找到后执行它;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>file</code>为要执行的可执行文件,可以是一个简单的文件名而不需要完整的路径名;</font></p> <p><font face="华文仿宋" size="4"><code>arg0</code>为要传递给新程序的第一个参数,一般来说这个参数为需要执行新程序的名称;</font></p> <p><font face="华文仿宋" size="4"><code>...</code>为可选参数,这些参数将作为新程序的命令行参数并进行传递;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execlp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该段程序当中原始程序中将输出一条消息后调用<code>execlp()</code>函数执行<code>ls</code>命令;</font></p> <p><font face="华文仿宋" size="4">若是进程替换成功将会执行<code>ls -l</code>的命令,若是未替换成功将会退出并返回<code>1</code>同时打印出第二句<code>This is the original program</code>;</font></p> <p><font face="华文仿宋" size="4">该程序运行的结果如下:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76528</span> Mar <span class="token number">14</span> <span class="token number">14</span>:07 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER   <span class="token number">582</span> Mar <span class="token number">14</span> <span class="token number">14</span>:07 test.cpp
</code></pre> </li></ul> 
<hr> 
<h4><a id="_execle_200"></a>🦩 execle()函数</h4> 
<p><img src="https://images2.imgbox.com/f8/e3/lqr5zwKd_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execle()</code>函数原型</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4">该函数与<code>execl()</code>函数和<code>execlp()</code>函数类似,<code>execle()</code>函数会将当前的进程替换为指定路径下的可执行文件;</font></p> <p><font face="华文仿宋" size="4">但是该函数与前两者不同的是,<code>execle()</code>函数允许你传递一个自定义的环境变量数组给新程序;</font></p> <p><font face="华文仿宋" size="4">一般这个环境变量数组通过<code>envp</code>参数进行传递;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>path</code>参数表示要执行的可执行文件路径的字符串;</font></p> <p><font face="华文仿宋" size="4"><code>arg0</code>表示要传递给新程序的第一个参数,一般情况下该参数为新程序的名字;</font></p> <p><font face="华文仿宋" size="4"><code>...</code>表示可选参数列表,这些参数将作为新程序的命令行参数并进行传递,且参数列表必须以空指针<code>(char*)NULL</code>进行结尾;</font></p> <p><font face="华文仿宋" size="4"><code>envp[]</code>指向一个以<code>NULL</code>结束的环境变量数组,其中每个元素都是形如<code>NAME=VALUE</code>的字符串;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>env<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"MYVAR=Hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">execle</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/env"</span><span class="token punctuation">,</span> <span class="token string">"env"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该示例当中,原始程序将输出一条消息后调用<code>execle()</code>函数来执行<code>/usr/bin/env</code>的命令;</font></p> <p><font face="华文仿宋" size="4">由于第一个参数指定了完整的路径,故<code>execle()</code>函数将会直接执行该命令;</font></p> <p><font face="华文仿宋" size="4">同时通过<code>env</code>参数传递了一个自定义的环境变量数组给新的程序;</font></p> <p><font face="华文仿宋" size="4">最终的执行结果为:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
<span class="token assign-left variable">MYVAR</span><span class="token operator">=</span>Hello
</code></pre> </li></ul> 
<hr> 
<h4><a id="_execv_259"></a>🦩 execv()函数</h4> 
<p><img src="https://images2.imgbox.com/8d/e2/dc0JIvkk_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execv()</code>函数原型</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4">该函数的工作方式与<code>execl</code>和<code>execlp</code>函数类似,与之不同的是该函数使用了不同的参数传递方式;</font></p> <p><font face="华文仿宋" size="4"><code>execv()</code>函数将参数作为一个字符串数组传给新的程序而不是通过函数参数列表进行传递使得该函数在传参时能够更加灵活;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><code>path</code>参数表示要执行的可执行文件的路径的字符串;</p> <p><font face="华文仿宋" size="4"><code>argv[]</code>指向一个以<code>NULL</code>结尾的字符串数组,每个元素都表示新程序的命令行参数;<code>argv[0]</code>通常是新程序的名称,后序的参数依次排列且最后一个元素必须是<code>NULL</code>;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">execv</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该示例当中,原始程序将输出一条消息并用<code>execv()</code>函数执行<code>/bin/ls</code>的命令且带<code>-l</code>参数;</font></p> <p><font face="华文仿宋" size="4"><code>args</code>数组包含了要传递给<code>ls</code>命令的参数列表;</font></p> <p><font face="华文仿宋" size="4">与<code>execl()</code>和<code>execlp()</code>函数不同,<code>execv()</code>函数将参数作为一个字符串传递给新的程序;</font></p> <p><font face="华文仿宋" size="4">最终的执行结果为:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76568</span> Mar <span class="token number">14</span> <span class="token number">14</span>:41 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER  <span class="token number">1142</span> Mar <span class="token number">14</span> <span class="token number">14</span>:41 test.cpp
</code></pre> </li></ul> 
<hr> 
<h4><a id="_execvp_316"></a>🦩 execvp()函数</h4> 
<p><img src="https://images2.imgbox.com/06/91/QAKOshzS_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execvp()</code>函数原型:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4">该函数的工作方式与<code>execv()</code>函数类似,但该函数不要求指定可执行文件的完整路径;</font></p> <p><font face="华文仿宋" size="4">该函数将在系统的<code>PATH</code>环境变量中搜索<code>file</code>参数指定的可执行文件并执行;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>file</code>表示要执行的可执行文件的名称,该参数可以是一个简单的文件名而不需要包含完整的路径;</font></p> <p><font face="华文仿宋" size="4"><code>argv[]</code>指向一个以<code>NULL</code>结束的字符串数组,每个元素表示新程序的命令行参数,<code>argv[0]</code>通常表示新程序的名字,后面的参数依次排列且最后一个元素必须是<code>NULL</code>;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execvp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该示例中原始程序将输出一条消息并调用<code>execvp()</code>函数执行<code>ls</code>命令并带有<code>-l</code>参数;</font></p> <p><font face="华文仿宋" size="4">由于<code>ls</code>并未指出完整的路径故<code>execvp()</code>将在<code>PATH</code>中搜索<code>ls</code>可执行文件并执行找到的第一个匹配项;</font></p> <p><font face="华文仿宋" size="4">与<code>execv()</code>函数类似,若是<code>execvp()</code>函数调用失败 <mark>(例如指定的可执行文件不存在)</mark> 将返回<code>-1</code>并设置<code>errno</code>指示错误类型;</font></p> <p><font face="华文仿宋" size="4">最终的执行结果为:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76560</span> Mar <span class="token number">14</span> <span class="token number">14</span>:53 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER  <span class="token number">1416</span> Mar <span class="token number">14</span> <span class="token number">14</span>:53 test.cpp
</code></pre> </li></ul> 
<hr> 
<h4><a id="_execvpe_371"></a>🦩 execvpe()函数</h4> 
<p><img src="https://images2.imgbox.com/6a/e8/8kHjxM9f_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execvpe()</code>函数原型:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4"><code>execvpe()</code>函数的工作方式与<code>execvp()</code>函数类似,与之不同的是该函数额外提供了一个参数允许指定自定义的环境变量;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>file</code>表示要执行的可执行文件的名称,它可以是一个简单的文件名而不需要包含完整的路径;</font></p> <p><font face="华文仿宋" size="4"><code>argv[]</code>指向一个以<code>NULL</code>结束的字符串数组,每个元素表示新程序的命令行参数且<code>argv[0]</code>通常表示新程序的名称,后序的参数依次排列;数组的最后一个元素必须是<code>NULL</code>指针;</font></p> <p><font face="华文仿宋" size="4"><code>envp[]</code>指向一个以<code>NULL</code>结束的环境变量数组,其中每个元素都是形如<code>NAME=VALUE</code>的字符串;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>env<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"MYVAR=Hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execvpe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在该示例中,原始程序将输出一条消息并调用<code>execvp()</code>函数执行<code>ls</code>命令并带有<code>-l</code>参数;</font></p> <p><font face="华文仿宋" size="4">同时传递了一个自定义的环境变量数组给新的程序;</font></p> <p><font face="华文仿宋" size="4">最终的执行结果:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76600</span> Mar <span class="token number">14</span> <span class="token number">15</span>:24 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER  <span class="token number">1696</span> Mar <span class="token number">14</span> <span class="token number">15</span>:24 test.cpp
</code></pre> </li></ul> 
<hr> 
<h4><a id="_execve_425"></a>🦩 execve()函数</h4> 
<p><img src="https://images2.imgbox.com/e3/5b/RGZuXuhT_o.gif" alt="请添加图片描述" width="70"></p> 
<ul><li> <p><font face="黑体" size="4"><strong><code>execve()</code>函数原型:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p><font face="华文仿宋" size="4"><code>execve()</code>函数的工作方式是将当前进程的映像(image)替换为指定路径下的可执行文件;</font></p> <p><font face="华文仿宋" size="4">与其他<code>exec</code>系列函数不同的是该函数为一个系统调用,将直接与操作系统内核交互并执行新的程序,而其他<code>exec</code>函数通常是标准库提供的函数,最终将调用<code>execve()</code>系统调用来执行新的程序;</font></p> <p><font face="华文仿宋" size="4"><code>execve()</code>函数直接与操作系统内核进行通信,提供了更直接更底层的接口,可直接控制程序的执行;</font></p> <p><font face="华文仿宋" size="4">其他<code>exec</code>函数则是再标准库中实现的高层接口,或许会做出一些额外的处理(路径搜索,参数组织等)后再调用<code>execve()</code>;</font></p> <p><font face="华文仿宋" size="4">由于<code>execve()</code>函数直接暴露了系统调用的细节故提供了更大的灵活性和控制性;</font></p> <p><font face="华文仿宋" size="4">用户程序可以直接操作参数和环境变量使得可以自行管理文件描述符等从而实现更复杂的执行需求;</font></p> </li><li> <p><font face="黑体" size="4"><strong>参数:</strong></font></p> <p><font face="华文仿宋" size="4"><code>filename</code>指向要执行的可执行文件路径的字符串;</font></p> <p><font face="华文仿宋" size="4"><code>argv[]</code>参数指向一个以<code>NULL</code>结束的字符串数组,每个元素表示新程序的命令行参数;<code>argv[0]</code>通常为新程序的名称,后序的参数依次排列,数组的最后一个元素必须是<code>NULL</code>指针;</font></p> <p><font face="华文仿宋" size="4"><code>envp[]</code>指向一个以<code>NULL</code>结束的环境变量数组,其中每个元素都是形如<code>NAME=VALUE</code>的字符串;</font></p> </li><li> <p><font face="黑体" size="4"><strong>示例:</strong></font></p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>env<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"MYVAR=Hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is the original program\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execve"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><font face="华文仿宋" size="4">在这个示例中,原始程序将输出一条消息后调用<code>execve</code>函数来执行<code>/bin/ls</code>命令,并带有<code>-l</code>参数;</font></p> <p><font face="华文仿宋" size="4">并且传递了一个自定义的环境变量数组给新的程序;</font></p> <p><font face="华文仿宋" size="4">最终运行结果:</font></p> <pre><code class="prism language-bash">$ ./mytest 
This is the original program
total <span class="token number">84</span>
-rw-rw-r-- <span class="token number">1</span> _USER _USER    <span class="token number">84</span> Mar <span class="token number">14</span> <span class="token number">13</span>:49 makefile
-rwxrwxr-x <span class="token number">1</span> _USER _USER <span class="token number">76600</span> Mar <span class="token number">14</span> <span class="token number">16</span>:05 mytest
-rw-rw-r-- <span class="token number">1</span> _USER _USER  <span class="token number">2073</span> Mar <span class="token number">14</span> <span class="token number">16</span>:05 test.cpp
</code></pre> </li></ul> 
<hr> 
<h3><a id="_Shell_491"></a>🦄 简单Shell命令行解释器的实现</h3> 
<p><img src="https://images2.imgbox.com/ef/70/32jV9aNP_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4"> <mark>命令行解释器(Command Line Interpreter)</mark> 是一种与操作系统进行交互的软件程序;</font></p> 
<p><font face="华文楷体" size="4">其允许用户命令行界面(CLI)输入命令并根据命令控制OS与其对应的应用程序;</font></p> 
<p><font face="华文楷体" size="4">命令行解释器通常称为<code>Shell</code>;</font></p> 
<p><font face="华文楷体" size="4">它充当了用户和操作系统之间的中间层并提供了一种文本方式来执行各项操作;</font></p> 
<p><font face="华文楷体" size="4">命令行解释器的主要功能包括:</font></p> 
<ul><li><font face="黑体" size="4"><strong>解释和执行命令</strong></font></li><li><font face="黑体" size="4"><strong>管理文件系统</strong></font></li><li><font face="黑体" size="4"><strong>进程管理</strong></font></li><li><font face="黑体" size="4"><strong>环境配置</strong></font></li><li><font face="黑体" size="4"><strong>用户交互</strong></font></li><li><font face="黑体" size="4"><strong>脚本执行</strong></font></li></ul> 
<hr> 
<h4><a id="__515"></a>🦩 大致框架与命令行提示符</h4> 
<p><img src="https://images2.imgbox.com/66/34/rhym4Djv_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4">在一般的情况下在<code>Shell</code>当中将会显示对应的命令行提示符使用户方便进行输入;</font></p> 
<p><font face="华文楷体" size="4">一般的情况下命令行提示符只需要打印即可;</font></p> 
<p><font face="华文楷体" size="4">同时<code>Shell</code>必然是一个常驻进程,即一般情况下进程不退出,需要使用循环进行控制;</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//   cout &lt;&lt; "hello world" &lt;&lt; endl;</span>
  <span class="token comment">/*
     命令行解释器是一个常驻进程,一般情况常驻进程不退出
  */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1.打印出提示信息</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[SilverChariot@local MyShell]# "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font face="华文楷体" size="4">使用<code>fflush()</code>刷新输出缓冲区防止在循环当中打印换行;</font></p> 
<hr> 
<h4><a id="__552"></a>🦩 获取用户输入信息</h4> 
<p><img src="https://images2.imgbox.com/5c/27/n1pIetSi_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4">当打印完提示信息时需要获取用户的输入信息;</font></p> 
<p><font face="华文楷体" size="4">声名一个数组充当字符串缓冲区并使用<code>fgets()</code>函数获取对应的用户输入信息(需要提前使用<code>memset()</code>对空间进行初始化);</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">1034</span>  </span><span class="token comment">// 保存完整的命令行字符串的大小</span></span>
<span class="token keyword">char</span> cmd_line<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 缓冲区   - 用于保存完整的命令行字符串</span>

<span class="token comment">/*
	......
*/</span>

<span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cmd_line<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将缓冲区进行初始化</span>
    <span class="token comment">// 2.获取用户输入信息(指令 及 选项 )</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cmd_line<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 如果从输入流中获取数据失败则进行下一次循环 该次循环不算</span>
    cmd_line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  
				<span class="token comment">// 由于输入换行后该缓冲区将会存储一个换行并且进行打印</span>
               <span class="token comment">// 故需要将改缓冲区的换行修正为'\0'</span>

    <span class="token comment">// cout &lt;&lt; "echo :" &lt;&lt; cmd_line &lt;&lt; endl;// --debug 用于打印是否正确</span>
</code></pre> 
<p><font face="华文楷体" size="4">当用户输入完输入信息时为了能够让计算机识别结束输入流一般会输入一个<code>\n</code>;</font></p> 
<p><font face="华文楷体" size="4">为了防止<code>\n</code>不被打印需要在对应的<code>cmd_line[strlen(cmd_line) - 1]</code>处置为<code>\0</code>;</font></p> 
<p><font face="华文楷体" size="4">由于是一个循环,若是从输入流中获取数据失败则进行下一次循环<code>continue</code>;</font></p> 
<p><font face="华文楷体" size="4">在该处可以将用户的输入信息进行打印从而判断该处逻辑是否出现对应问题;</font></p> 
<hr> 
<h4><a id="__591"></a>🦩 将缓冲区内的字符串进行分块</h4> 
<p><img src="https://images2.imgbox.com/bc/c8/Y2KOUoBT_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4">由于需要在后期对用户的输入信息进行分析故需要先将用户的输入信息进行分块;</font></p> 
<p><font face="华文楷体" size="4">声名一个字符串数组<code>char* []</code>用户保存分块后的命令行字符串子串;</font></p> 
<p><font face="华文楷体" size="4">在<code>C++</code>中可以使用<code>substr()</code>对字符串进行分块;</font></p> 
<p><font face="华文楷体" size="4">在<code>C语言</code>当中则可以使用<code>strtok()</code>对字符串进行分块;</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span>g_argv<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于保存打散后的命令行字符串子串</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">32</span>   </span><span class="token comment">// 保存打散后命令字符串子串的数组大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEP</span> <span class="token string">" "</span>   <span class="token comment">// 作为分隔符// 3.将缓冲区内的字符串进行分块 即命令行字符串解析工作</span></span>

<span class="token comment">/*
	......
*/</span>

    g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>
        <span class="token function">strtok</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次调用strtok函数的时候需要传入原始字符串</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token punctuation">;</span>  <span class="token comment">// 第二次调用时若是需要分割的是原始字符串则传入空null</span>
    <span class="token punctuation">}</span>

</code></pre> 
<p><font face="华文楷体" size="4">根据<code>strtok()</code>函数对字符串进行分块;</font></p> 
<p><font face="华文楷体" size="4"><code>strtok()</code>函数参考<a href="https://cplusplus.com/reference/string/string/substr/" rel="nofollow">【std::string::substr】</a>在此不作赘述;</font></p> 
<hr> 
<h4><a id="__629"></a>🦩 分析并执行指令</h4> 
<p><img src="https://images2.imgbox.com/ef/0d/aJgJjAwj_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4">当数据拆分完毕后需要对指令进行分析与执行;</font></p> 
<p><font face="华文楷体" size="4">一般情况下由子进程对指令进行执行,父进程则负责分析以及等待子进程退出;</font></p> 
<p><font face="华文楷体" size="4">使用<code>fork()</code>创建子进程并使用对应的进程替换接口使子进程能够运行对应的命令;</font></p> 
<p><font face="华文楷体" size="4">此处使用的进程替换接口为<code>execvp()</code>函数,具体参考上文的对于<code>execvp()</code>函数的解释;</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 5.创建进程 子进程执行指令 父进程等待分析指令</span>
   pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//子进程</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"子进程进行执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">execvp</span><span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> g_argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 父进程</span>
     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
       cout <span class="token operator">&lt;&lt;</span> <span class="token string">"WEXITSTATUS:"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_cd_666"></a>🦩 对cd命令进行处理</h4> 
<p><img src="https://images2.imgbox.com/93/01/YxXEZNBN_o.gif" alt="请添加图片描述" width="70"></p> 
<p><font face="华文楷体" size="4">当到这一步时大部分的指令都能够执行;</font></p> 
<p><font face="华文楷体" size="4">但是对应的<code>cd</code>命令并不能在该处编写的<code>Shell</code>中起作用;</font></p> 
<p><font face="华文楷体" size="4">原因是需要发生目录变化时一般为父进程发生变化,子进程的目录变化并不影响父进程;</font></p> 
<p><font face="华文楷体" size="4">故需要在<code>fork()</code>创建子进程前使用<code>strcmp()</code>对<code>cd</code>进行特殊处理;</font></p> 
<p><font face="华文楷体" size="4">若是遇到<code>cd</code>命令时则可以使用<code>chdir()</code>接口函数进行路径的变化;</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 4.用于cd命令 需要在父进程阶段进行</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"cd"</span><span class="token punctuation">,</span>g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token comment">// if (g_argv[1] != nullptr &amp;&amp; chdir(g_argv[1]) != 0) {<!-- --></span>
      <span class="token comment">//   cerr &lt;&lt; "chdir failed: " &lt;&lt; strerror(errno) &lt;&lt; endl;</span>
      <span class="token comment">// }</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token function">chdir</span><span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_Shell_697"></a>🦩 简单Shell实现代码演示(供参考)</h4> 
<p><img src="https://images2.imgbox.com/be/b6/djY9Klne_o.gif" alt="请添加图片描述" width="70"></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">1034</span>  </span><span class="token comment">// 保存完整的命令行字符串的大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">32</span>   </span><span class="token comment">// 保存打散后命令字符串子串的数组大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEP</span> <span class="token string">" "</span>   <span class="token comment">// 作为分隔符</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span>g_argv<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于保存打散后的命令行字符串子串</span>
<span class="token keyword">char</span> cmd_line<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 缓冲区   - 用于保存完整的命令行字符串</span>

<span class="token comment">// shell 运行原理 ： 子进程执行命令，父进程等待以及解析命令</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//   cout &lt;&lt; "hello world" &lt;&lt; endl;</span>
  <span class="token comment">/*
     命令行解释器是一个常驻进程,一般情况常驻进程不退出
  */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1.打印出提示信息</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[SilverChariot@local MyShell]# "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cmd_line<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将缓冲区进行初始化</span>
    <span class="token comment">// 2.获取用户输入信息(指令 及 选项 )</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cmd_line<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 如果从输入流中获取数据失败则进行下一次循环 该次循环不算</span>
    cmd_line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>
        <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 由于输入换行后该缓冲区将会存储一个换行并且进行打印</span>
               <span class="token comment">// 故需要将改缓冲区的换行修正为'\0'</span>

    <span class="token comment">// cout &lt;&lt; "echo :" &lt;&lt; cmd_line &lt;&lt; endl;// --debug 用于打印是否正确</span>

    <span class="token comment">// 3.将缓冲区内的字符串进行分块 即命令行字符串解析工作</span>
    g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>
        <span class="token function">strtok</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次调用strtok函数的时候需要传入原始字符串</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token punctuation">;</span>  <span class="token comment">// 第二次调用时若是需要分割的是原始字符串则传入空null</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
      //用于debug 
      for (index = 0; g_argv[index]; ++index) {
        printf("g_argv[%d] : %s\n", index, g_argv[index]);
      } 
    */</span>

   <span class="token comment">// 4.用于cd命令 需要在父进程阶段进行</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"cd"</span><span class="token punctuation">,</span>g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token comment">// if (g_argv[1] != nullptr &amp;&amp; chdir(g_argv[1]) != 0) {<!-- --></span>
      <span class="token comment">//   cerr &lt;&lt; "chdir failed: " &lt;&lt; strerror(errno) &lt;&lt; endl;</span>
      <span class="token comment">// }</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token function">chdir</span><span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment">// 5.创建进程 子进程执行指令 父进程等待分析指令</span>
   pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//子进程</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"子进程进行执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">execvp</span><span class="token punctuation">(</span>g_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> g_argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 父进程</span>
     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
       cout <span class="token operator">&lt;&lt;</span> <span class="token string">"WEXITSTATUS:"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66cae79a11e309e757c392bc926937fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣热题100_矩阵_48_旋转图像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aed45983236cb45f3755ee7022c8ef3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot简析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>