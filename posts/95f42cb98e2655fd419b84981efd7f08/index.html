<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>post请求下载文件，ajax - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="post请求下载文件，ajax" />
<meta property="og:description" content="在这里当时想着生成pdf的请求为post，获取pdf的请求为get，通过全局变量filename来获取pdf，但是这里存在着线程安全问题，全局变量会被不同的用户更改，下载时可能会下载到另外一个用户所生成的文件。
处理办法是，把生成pdf和下载pdf合并成同一个接口，这样避免了上述情况的发生，但是在前台浏览器获取pdf出现了问题，浏览器通过get请求可以直接下载文件（弹出下载框），但是这个接口是需要要是post请求（传递实体类），所以通过前台的数据处理和后台的返回头setHeader设定解决了这个问题。
通过异步的post请求，返回数据浏览器不会自动下载，需要在前端异步请求做处理
axios.post(&#34;http://localhost:8080/satable/pdf&#34;, param,{responseType:&#39;blob&#39;}).then(res =&gt; { const name = res.headers[&#39;content-disposition&#39;]; let fileName = &#39;&#39;; if (name) { const str1 = name.replace(&#39; &#39;, &#39;&#39;); const arr1 = str1.split(&#39;;&#39;); arr1.some(item =&gt; { if (item.indexOf(&#39;filename&#39;) != -1) { fileName = item.split(&#39;=&#39;)[1]; } return item.indexOf(&#39;filename&#39;) != -1; }); if (fileName === &#39;&#39;){ fileName = &#39;excel.pdf&#39; } } else { fileName = &#39;excel.pdf&#39; } try { let objectUrl1 = window.URL.createObjectURL(new Blob([res.data])); let elink = document." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/95f42cb98e2655fd419b84981efd7f08/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T13:13:56+08:00" />
<meta property="article:modified_time" content="2024-01-20T13:13:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">post请求下载文件，ajax</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>         在这里当时想着生成pdf的请求为post，获取pdf的请求为get，通过全局变量filename来获取pdf，但是这里存在着线程安全问题，全局变量会被不同的用户更改，下载时可能会下载到另外一个用户所生成的文件。</p> 
 <p>        处理办法是，把生成pdf和下载pdf合并成同一个接口，这样避免了上述情况的发生，但是在前台浏览器获取pdf出现了问题，浏览器通过get请求可以直接下载文件（弹出下载框），但是这个接口是需要要是post请求（传递实体类），所以通过前台的数据处理和后台的返回头setHeader设定解决了这个问题。</p> 
</blockquote> 
<blockquote> 
 <p>通过异步的post请求，返回数据浏览器不会自动下载，需要在前端异步请求做处理</p> 
</blockquote> 
<pre><code class="language-java">axios.post("http://localhost:8080/satable/pdf", param,{responseType:'blob'}).then(res =&gt; {
                        const name = res.headers['content-disposition'];
                        let fileName = '';
                        if (name) {
                            const str1 = name.replace(' ', '');
                            const arr1 = str1.split(';');
                            arr1.some(item =&gt; {
                                if (item.indexOf('filename') != -1) {
                                    fileName = item.split('=')[1];
                                }
                                return item.indexOf('filename') != -1;
                            });
                            if (fileName === ''){
                                fileName = 'excel.pdf'
                            }
                        } else {
                            fileName = 'excel.pdf'
                        }

                        try {
                            let objectUrl1 = window.URL.createObjectURL(new Blob([res.data]));
                            let elink = document.createElement('a');
                            elink.setAttribute('download', decodeURI(decodeURI(fileName)));
                            elink.style.display = 'none';
                            elink.href = objectUrl1;
                            document.body.appendChild(elink);
                            elink.click();
                            document.body.removeChild(elink);
                            window.URL.revokeObjectURL(elink.href);
                        }catch (err){
                            this.$message.warning('download error!')
                        }
                    }
                )</code></pre> 
<blockquote> 
 <p>后端的respon返回，同时需要加个返回头</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <pre>response.setHeader("Access-Control-Expose-Headers", "content-disposition");</pre> 
</blockquote> 
<pre><code class="language-java">    @PostMapping("/pdf")
    public void getPdfAndDownload(@RequestBody SateiTable sateiTable, HttpServletResponse response) throws IOException {
      
        // 生成PDF   略
          

        //下载PDF
        try {
            // path是指想要下载的文件的路径
            File file = new File(filepdfpath + pdfName);

            System.out.println("文件路径： " + file.getPath());
            // 获取文件名
            String filename = file.getName();
            System.out.println("文件名： " + filename);
            // 获取文件后缀名
            String ext = filename.substring(filename.lastIndexOf(".")).toLowerCase();
            System.out.println("文件后缀名：" + ext);
            // path是指想要下载的文件的路径

            // 将文件写入输入流
            FileInputStream fileInputStream = new FileInputStream(file);
            InputStream fis = new BufferedInputStream(fileInputStream);
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            fis.close();

            // 清空response
            response.reset();
            // 设置response的Header
            response.setCharacterEncoding("UTF-8");
            // 设置文件下载头
            response.addHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(pdfName, "UTF-8"));
            // 设置文件长度
            response.setHeader("Content-Length", String.valueOf(file.length()));
            //
            response.setHeader("Access-Control-Expose-Headers", "content-disposition");
            //获取响应报文输出流对象
            OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
            //设置响应内容类型
            response.setContentType("application/octet-stream");
            //输出
            outputStream.write(buffer);
            outputStream.flush();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
</code></pre> 
<blockquote> 
 <p>结果展示 </p> 
</blockquote> 
<p><img alt="" height="960" src="https://images2.imgbox.com/ef/0e/he6fQSMm_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02153d27315b3684c49a11f098bc33ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在服务器上运行 Python 程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d5650825089c7c3b42089f6638d631e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL命令大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>