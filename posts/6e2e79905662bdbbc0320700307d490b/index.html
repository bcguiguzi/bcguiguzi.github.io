<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hololens官方教程精简版 - 07. Spatial mapping（空间映射） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hololens官方教程精简版 - 07. Spatial mapping（空间映射）" />
<meta property="og:description" content="前言 注意：本文已更新到5.5.1f1版本
个人建议，学习Holograms 230之前，一定完成《Hololens官方教程精简版 - 02. Introduction with Device》的学习。
本篇集中学习空间映射功能，完成以下目标：
Chapter 1 - 空间扫描 目标 完成空间扫描替换三角面材质 实践 完成空间扫描
请按照第一篇的教程，完成项目的创建。 新建文件夹：”Assets/_Scenes/Holograms 230/”新建场景：”Assets/_Scenes/Holograms 230/Holograms 230.unity”打开场景，删除默认的Main Camera将”Assets/HoloToolkit/Input/Prefabs/HololensCamera.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/InputManager.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/Cursor/DefaultCursor.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/SpatialMapping/Prefabs/SpatialMapping.prefab”添加到Hierarchy根级 本节完成！
使用Hololens远程连接Unity进行调试，等待“一段时间”（这个一段时间，第一次可能很长……）。将会看到Hololens根据空间扫描结果，绘制了很多三角面。
替换三角面材质
点击SpatialMapping找到Inspector面板中的Surface Material，替换为SpatialUnderstandingSurface 本节完成！
再次测试，会发现三角面的材质被替换。
Chapter 2 - 扫描结果处理 目标 扫描结束后，用手势点击，将扫描结果转换为地板模型
实践 在Hierarchy面板根级，新建空对象，重命名为：Controller点击Controller，在Inspector面板中点击Add Component，加入：Surface Meshes To Planes组件点击Surface Meshes To Planes组件属性Surface Plane Prefab右侧的圆钮，选择：SurfacePlane同第2步相同的方法，为Controller添加Remove Surface Vertices新建文件夹：”Assets/_Scenes/Holograms 230/Scripts/”新建脚本文件：”Assets/_Scenes/Holograms 230/Scripts/Controller230.cs“，并附加到Controller上编辑脚本如下：
using System.Collections.Generic; using UnityEngine; using HoloToolkit.Unity; public class Controller230 : Singleton&lt;Controller230&gt; { [Tooltip(&#34;扫描过多少秒开始转换&#34;)] public float scanTime = 30." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6e2e79905662bdbbc0320700307d490b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-13T17:43:05+08:00" />
<meta property="article:modified_time" content="2017-01-13T17:43:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hololens官方教程精简版 - 07. Spatial mapping（空间映射）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="前言">前言</h3> 
<p><strong>注意：本文已更新到5.5.1f1版本</strong></p> 
<p>个人建议，学习Holograms 230之前，一定完成<a href="http://blog.csdn.net/yurichou/article/details/54094552">《Hololens官方教程精简版 - 02. Introduction with Device》</a>的学习。</p> 
<p>本篇集中学习空间映射功能，完成以下目标：</p> 
<h3 id="chapter-1-空间扫描">Chapter 1 - 空间扫描</h3> 
<h4 id="目标">目标</h4> 
<ul><li><strong>完成空间扫描</strong></li><li><strong>替换三角面材质</strong></li></ul> 
<h4 id="实践">实践</h4> 
<p><strong>完成空间扫描</strong></p> 
<ol><li>请按照第一篇的教程，完成项目的创建。 </li><li>新建文件夹：”Assets/_Scenes/<strong>Holograms 230</strong>/”</li><li>新建场景：”Assets/_Scenes/Holograms 230/<strong>Holograms 230.unity</strong>”</li><li>打开场景，删除默认的<strong>Main Camera</strong></li><li>将”Assets/HoloToolkit/Input/Prefabs/<strong>HololensCamera</strong>.prefab”添加到Hierarchy根级 </li><li>将”Assets/HoloToolkit/Input/Prefabs/<strong>InputManager</strong>.prefab”添加到Hierarchy根级 </li><li>将”Assets/HoloToolkit/Input/Prefabs/Cursor/<strong>DefaultCursor</strong>.prefab”添加到Hierarchy根级 </li><li>将”Assets/HoloToolkit/SpatialMapping/Prefabs/<strong>SpatialMapping</strong>.prefab”添加到Hierarchy根级 </li></ol> 
<p><strong>本节完成！</strong></p> 
<p>使用Hololens远程连接Unity进行调试，等待“一段时间”（这个一段时间，第一次可能很长……）。将会看到Hololens根据空间扫描结果，绘制了很多三角面。</p> 
<p><strong>替换三角面材质</strong></p> 
<ol><li>点击<strong>SpatialMapping</strong></li><li>找到<strong>Inspector</strong>面板中的<strong>Surface Material</strong>，替换为<strong>SpatialUnderstandingSurface</strong></li></ol> 
<p><strong>本节完成！</strong></p> 
<p>再次测试，会发现三角面的材质被替换。</p> 
<h3 id="chapter-2-扫描结果处理">Chapter 2 - 扫描结果处理</h3> 
<h4 id="目标-1">目标</h4> 
<p>扫描结束后，用手势点击，将扫描结果转换为地板模型</p> 
<h4 id="实践-1">实践</h4> 
<ol><li>在<strong>Hierarchy</strong>面板根级，新建空对象，重命名为：<strong>Controller</strong></li><li>点击<strong>Controller</strong>，在<strong>Inspector</strong>面板中点击<strong>Add Component</strong>，加入：<strong>Surface Meshes To Planes</strong>组件</li><li>点击<strong>Surface Meshes To Planes</strong>组件属性<strong>Surface Plane Prefab</strong>右侧的圆钮，选择：<strong>SurfacePlane</strong></li><li>同第2步相同的方法，为<strong>Controller</strong>添加<strong>Remove Surface Vertices</strong></li><li>新建文件夹：”Assets/_Scenes/Holograms 230/<strong>Scripts</strong>/”</li><li>新建脚本文件：”Assets/_Scenes/Holograms 230/Scripts/<strong>Controller230.cs</strong>“，并附加到<strong>Controller</strong>上</li><li><p>编辑脚本如下：</p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> HoloToolkit.Unity;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Controller230 : Singleton&lt;Controller230&gt; {

    [Tooltip(<span class="hljs-string">"扫描过多少秒开始转换"</span>)]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> scanTime = <span class="hljs-number">30.0</span>f;

    [Tooltip(<span class="hljs-string">"扫描时使用的材质"</span>)]
    <span class="hljs-keyword">public</span> Material defaultMaterial;

    [Tooltip(<span class="hljs-string">"停止扫描所使用的材质"</span>)]
    <span class="hljs-keyword">public</span> Material secondaryMaterial;

    [Tooltip(<span class="hljs-string">"最小Plane实体数量"</span>)]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">uint</span> minimumPlanes = <span class="hljs-number">10</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 判断是否正在处理Mesh</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> meshesProcessed = <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        <span class="hljs-comment">// 设置空间扫描器的材质为默认材质</span>
        SpatialMappingManager.Instance.SetSurfaceMaterial(defaultMaterial);

        <span class="hljs-comment">// 网格转Plane实体完成后的事件监听</span>
        SurfaceMeshesToPlanes.Instance.MakePlanesComplete += SurfaceMeshesToPlanes_MakePlanesComplete;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()
    {
        <span class="hljs-keyword">if</span> (!meshesProcessed)
        {
            <span class="hljs-keyword">if</span> ((Time.time - SpatialMappingManager.Instance.StartTime) &lt; scanTime)
            {
                <span class="hljs-comment">// 还未到指定扫描耗时，则跳过</span>
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">// 停止扫描器</span>
                <span class="hljs-keyword">if</span> (SpatialMappingManager.Instance.IsObserverRunning())
                {
                    SpatialMappingManager.Instance.StopObserver();
                }

                <span class="hljs-comment">// 开始将网格转换为Plane</span>
                CreatePlanes();

                meshesProcessed = <span class="hljs-keyword">true</span>;
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceMeshesToPlanes_MakePlanesComplete</span>(<span class="hljs-keyword">object</span> source, System.EventArgs args)
    {
        <span class="hljs-comment">// 获取转换后得到的Plane实体对象</span>
        List&lt;GameObject&gt; planes = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();
        planes = SurfaceMeshesToPlanes.Instance.GetActivePlanes(PlaneTypes.Wall | PlaneTypes.Floor | PlaneTypes.Table);

        <span class="hljs-comment">// 如果大于我们设置的最小Plane识别值，则对Plane做进一步处理</span>
        <span class="hljs-keyword">if</span> (planes.Count &gt;= minimumPlanes)
        {
            <span class="hljs-comment">// 将与Plane实体重叠的顶点删除</span>
            RemoveVertices(SurfaceMeshesToPlanes.Instance.ActivePlanes);

            <span class="hljs-comment">// 扫描结束后，切换第二个材质，本例中使用了“剔除材质（使用了一个剔除Shader）”，即除了Plane外，其他的三角面将被隐藏</span>
            SpatialMappingManager.Instance.SetSurfaceMaterial(secondaryMaterial);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 未达到最小Plane识别数，继续扫描</span>
            SpatialMappingManager.Instance.StartObserver();

            meshesProcessed = <span class="hljs-keyword">false</span>;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 扫描网格转Plane实体</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreatePlanes</span>()
    {
        SurfaceMeshesToPlanes surfaceToPlanes = SurfaceMeshesToPlanes.Instance;
        <span class="hljs-keyword">if</span> (surfaceToPlanes != <span class="hljs-keyword">null</span> &amp;&amp; surfaceToPlanes.enabled)
        {
            surfaceToPlanes.MakePlanes();
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 移除与指定对象组重叠的顶点</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveVertices</span>(IEnumerable&lt;GameObject&gt; boundingObjects)
    {
        RemoveSurfaceVertices removeVerts = RemoveSurfaceVertices.Instance;
        <span class="hljs-keyword">if</span> (removeVerts != <span class="hljs-keyword">null</span> &amp;&amp; removeVerts.enabled)
        {
            removeVerts.RemoveSurfaceVerticesWithinBounds(boundingObjects);
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()
    {
        <span class="hljs-keyword">if</span> (SurfaceMeshesToPlanes.Instance != <span class="hljs-keyword">null</span>)
        {
            SurfaceMeshesToPlanes.Instance.MakePlanesComplete -= SurfaceMeshesToPlanes_MakePlanesComplete;
        }

        <span class="hljs-keyword">base</span>.OnDestroy();
    }
}</code></pre> <p><em>注意：5.5.1f1版本中，名称空间有所变化，大家可自行引入</em></p></li><li>如下图设置各个组件： <br> <img src="https://images2.imgbox.com/fe/45/VGjrwrrF_o.png" alt="设置空间处理组件" title=""></li></ol> 
<p><strong>本节完成！</strong></p> 
<p>设备远程连接Unity进行调试，等待片刻，空间扫描的网格会转换为地板</p> 
<h4 id="说明">说明</h4> 
<ul><li><strong>Surface Meshes To Planes</strong>脚本 <br> 将扫描的网格转换为实体，在其<strong>Inspector</strong>面板中，找到<strong>Draw Planes</strong>属性，可以设置需要转换的类型，本例中设置了只转换<strong>Floor（地板）</strong>，见上图标注青色的部分。</li><li><strong>Remove Surface Vertices</strong>脚本 <br> 把与实体重合的网格删除</li></ul> 
<h3 id="chapter-3-放置物体">Chapter 3 - 放置物体</h3> 
<h4 id="目标-2">目标</h4> 
<p>将物体放置到地板上</p> 
<h4 id="实践-2">实践</h4> 
<ol><li><p>根级创建一个<strong>Cube</strong>，设置如下： <br> <img src="https://images2.imgbox.com/3e/9d/blsrC2ZH_o.png" alt="放置Cube" title=""></p></li><li><p>给<strong>Cube</strong>添加<strong>Tap To Place</strong>脚本</p></li><li>给<strong>Controller</strong>添加<strong>World Anchor Manager</strong>脚本</li></ol> 
<p><strong>本节完成！</strong></p> 
<p>点击<strong>Cube</strong>后，<strong>Cube</strong>会随视线移动，但只能贴合到已经创建的地板上。 <br> 再次点击<strong>Cube</strong>进行放置操作。同时，系统会记录下<strong>Cube</strong>的空间位置。下次启动时，<strong>Cube</strong>回还原到该位置。</p> 
<h4 id="说明-1">说明</h4> 
<ul><li><strong>World Anchor Manager</strong> <br> 用来管理全息空间的物体锚点 <br> 使用<code>WorldAnchorManager.Instance.AttachAnchor(GameObject gameObjectToAnchor, string anchorName)</code>，即可为物体添加全息空间锚点信息，从而“固化”物体的空间位置（混合现实的显著特征之一）。</li><li><strong>Tap To Place</strong> <br> 放置物体（包含空间模型的检测）。核心功能就两个： <br> 
  <ul><li>放置过程中，使用<code>Raycast</code>方法，实时设置物体的位置</li><li>放置完成后，使用上面提到的<code>AttachAnchor(...)</code>来”固化”物体位置</li></ul></li></ul> 
<h3 id="chapter-4-空间遮挡">Chapter 4 - 空间遮挡</h3> 
<p>本节主要通过射线判断摄像机和目标物体间有没有被其他物体遮挡，进而对物体进行进行类似隐藏的处理（当然，官方使用了自己的Shader来实现）。不作为精简版的内容。有兴趣的朋友可以自行研究。</p> 
<h3 id="小结">小结</h3> 
<ul><li><strong>SpatialMapping</strong>.prefab <br> 空间扫描最核心的组件，内部使用<strong>Unity</strong>提供的<strong>SurfaceObserver</strong>工具进行空间扫描，从而获取到扫描数据。</li><li><strong>Surface Meshes To Planes</strong> <br> 识别扫描数据的类型（墙、地、桌等），进而转换为对应的模型。内部使用<strong>PlaneFinding</strong>类对扫描数据进行分析。</li><li><strong>PlaneFinding</strong> <br> 空间扫描物体的类型识别算法核心组件。涉及到大量的运算，生产环境中，禁止参与Unity的主线程运算。可参考<strong>Surface Meshes To Planes</strong>源码自行使用。</li><li><strong>Remove Surface Vertices</strong> <br> 移除与指定物体列表相重叠的空间三角形。</li><li><strong>World Anchor Manager</strong> <br> 空间锚点管理器，“固化”物体到空间的核心组件。</li></ul> 
<blockquote> 
 <p>参考文档 <br> <a href="https://developer.microsoft.com/en-us/windows/mixed-reality/holograms_230" rel="nofollow">官方教程Holograms 230：https://developer.microsoft.com/en-us/windows/mixed-reality/holograms_230</a></p> 
</blockquote> 
<hr> 
<p>VR/AR/MR技术交流QQ群：594299228 <br> <img src="https://images2.imgbox.com/79/f6/gBJpReR8_o.png" alt="VR/AR/MR技术交流QQ群：594299228" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/544fa9db0a77da009a1631b5d1b757b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10操作系统IE11浏览器的日期时间格式调整</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d45db483c3e5859a15bba19a391e7e66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">排序之选择排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>