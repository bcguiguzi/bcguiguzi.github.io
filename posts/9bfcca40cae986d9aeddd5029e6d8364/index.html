<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VS中检测内存泄漏的方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VS中检测内存泄漏的方法" />
<meta property="og:description" content="vs中检测内存泄漏的方法 分类： MFC2013-03-08 21:44 2764人阅读 评论(0) 收藏 举报 使用vs的内存检测有以下几种方法。
在debug模式下以F5运行：
方法一：
[html] view plain copy #define CRTDBG_MAP_ALLOC #include &lt;stdlib.h&gt; #include &lt;crtdbg.h&gt; //在入口函数中包含 _CrtDumpMemoryLeaks(); //即可检测到内存泄露 //以如下测试函数为例： int main() { char* pChars = new char[10]; _CrtDumpMemoryLeaks(); return 0; } F5运行输出窗口会得到：
Detected memory leaks!
Dumping objects -&gt;
{58} normal block at 0x00341A38, 10 bytes long.
Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD Object dump complete.
以上方法没有输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9bfcca40cae986d9aeddd5029e6d8364/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-12-11T13:40:00+08:00" />
<meta property="article:modified_time" content="2014-12-11T13:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VS中检测内存泄漏的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="article_title"> 
  <span class="ico ico_type_Original"><span class="ico ico_type_Original"><br></span></span> 
  <h2><span class="link_title"><a href="http://blog.csdn.net/windows_nt/article/details/8652191">vs中检测内存泄漏的方法</a></span></h2> 
 </div> 
 <div class="article_manage"> 
  <span class="link_categories">分类： <a href="http://blog.csdn.net/windows_nt/article/category/1111286">MFC</a><span class="link_postdate">2013-03-08 21:44 <span class="link_view" title="阅读次数">2764人阅读 <span class="link_comments" title="评论次数"><a href="http://blog.csdn.net/windows_nt/article/details/8652191#comments">评论</a>(0) <span class="link_collect"><a title="收藏">收藏</a> <span class="link_report"><a title="举报" href="http://blog.csdn.net/windows_nt/article/details/8652191#report">举报</a></span></span></span></span></span></span> 
 </div> 
 <div id="article_content" class="article_content"> 
  <p>使用vs的内存检测有以下几种方法。</p> 
  <p>在debug模式下以F5运行：</p> 
  <p>方法一：</p> 
  <div class="dp-highlighter bg_html"> 
   <div class="bar"> 
    <div class="tools"> 
     <strong>[html]</strong>  
     <a class="ViewSource" title="view plain" href="http://blog.csdn.net/windows_nt/article/details/8652191">view plain</a> 
     <a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/windows_nt/article/details/8652191">copy</a> 
     <div>
         
     </div> 
    </div> 
   </div> 
   <ol class="dp-xml" start="1"><li class="alt">#define CRTDBG_MAP_ALLOC    </li><li>#include <span class="tag">&lt;<span class="tag-name">stdlib.h<span class="tag">&gt;    </span></span></span></li><li class="alt">#include <span class="tag">&lt;<span class="tag-name">crtdbg.h<span class="tag">&gt;    </span></span></span></li><li>//在入口函数中包含 _CrtDumpMemoryLeaks();    </li><li class="alt">//即可检测到内存泄露  </li><li>  </li><li class="alt">//以如下测试函数为例：  </li><li>int main()  </li><li class="alt">{  </li><li>    char* <span class="attribute">pChars = <span class="attribute-value">new char[10];  </span></span></li><li class="alt">    _CrtDumpMemoryLeaks();  </li><li>    return 0;  </li><li class="alt">}  </li></ol> 
  </div> 
  <p>F5运行输出窗口会得到：</p> 
  <p>Detected memory leaks!<br>Dumping objects -&gt;<br>{58} normal block at 0x00341A38, 10 bytes long.<br> Data: &lt;          &gt; CD CD CD CD CD CD CD CD CD CD <br>Object dump complete.</p> 
  <p>以上方法没有输出</p> 
  <p align="left"><strong>注意：<br></strong>1.在VS2010下测试的时候，发现_CrtDumpMemoryLeaks();这句必须放在<strong>函数结束处</strong>，放在主函数入口处输出窗口不会输出内存泄露信息<br>2.{}中的数字指明这块内存是程序中总计第几个被申请的，这种方法没有行号和其他信息输出。我们可以定义：</p> 
  <div class="dp-highlighter bg_html"> 
   <div class="bar"> 
    <div class="tools"> 
     <strong>[html]</strong>  
     <a class="ViewSource" title="view plain" href="http://blog.csdn.net/windows_nt/article/details/8652191">view plain</a> 
     <a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/windows_nt/article/details/8652191">copy</a> 
     <div>
         
     </div> 
    </div> 
   </div> 
   <ol class="dp-xml" start="1"><li class="alt">#ifdef _DEBUG  </li><li>#define New   new(_NORMAL_BLOCK, __FILE__, __LINE__)  </li><li class="alt">#endif  </li><li>  </li><li class="alt">#define CRTDBG_MAP_ALLOC    </li><li>#include <span class="tag">&lt;<span class="tag-name">stdlib.h<span class="tag">&gt;    </span></span></span></li><li class="alt">#include <span class="tag">&lt;<span class="tag-name">crtdbg.h<span class="tag">&gt;    </span></span></span></li><li>//在入口函数中包含 _CrtDumpMemoryLeaks();    </li><li class="alt">//即可检测到内存泄露  </li><li>  </li><li class="alt">//以如下测试函数为例：  </li><li>int main()  </li><li class="alt">{  </li><li>    char* <span class="attribute">pChars = <span class="attribute-value">New char[10];  </span></span></li><li class="alt">    _CrtDumpMemoryLeaks();  </li><li>    return 0;  </li><li class="alt">}  </li></ol> 
  </div> 
  <p align="left">输出：</p> 
  <p align="left">Detected memory leaks!<br>Dumping objects -&gt;<br>e:\vs2005\stltest\stltest\test.cpp(14) : {58} normal block at 0x00591A38, 10 bytes long.<br> Data: &lt;          &gt; CD CD CD CD CD CD CD CD CD CD <br>Object dump complete.</p> 
  <p align="left">方法二：</p> 
  <p align="left"> </p> 
  <div class="dp-highlighter bg_html"> 
   <div class="bar"> 
    <div class="tools"> 
     <strong>[html]</strong>  
     <a class="ViewSource" title="view plain" href="http://blog.csdn.net/windows_nt/article/details/8652191">view plain</a> 
     <a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/windows_nt/article/details/8652191">copy</a> 
     <div>
         
     </div> 
    </div> 
   </div> 
   <ol class="dp-xml" start="1"><li class="alt">#define CRTDBG_MAP_ALLOC    </li><li>#include <span class="tag">&lt;<span class="tag-name">stdlib.h<span class="tag">&gt;    </span></span></span></li><li class="alt">#include <span class="tag">&lt;<span class="tag-name">crtdbg.h<span class="tag">&gt;    </span></span></span></li><li>//在入口函数中包含 _CrtDumpMemoryLeaks();    </li><li class="alt">//即可检测到内存泄露  </li><li>  </li><li class="alt">//定义函数：  </li><li>inline void EnableMemLeakCheck()  </li><li class="alt">{  </li><li>    _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);  </li><li class="alt">}  </li><li>//该函数可以放在主函数的任意位置，都能正确的触发内存泄露输出  </li><li class="alt">  </li><li>  </li><li class="alt">//以如下测试函数为例：  </li><li>int main()  </li><li class="alt">{  </li><li>    EnableMemLeakCheck();  </li><li class="alt">    char* <span class="attribute">pChars = <span class="attribute-value">new char[10];  </span></span></li><li>    //_CrtDumpMemoryLeaks();  </li><li class="alt">    return 0;  </li><li>}  </li></ol> 
  </div> 
  <p> </p> 
  <p> </p> 
  <p align="left">输出：</p> 
  <p align="left">Detected memory leaks!<br>Dumping objects -&gt;<br>{58} normal block at 0x004F1A38, 10 bytes long.<br> Data: &lt;          &gt; CD CD CD CD CD CD CD CD CD CD <br>Object dump complete.</p> 
  <p align="left">方法三：直接定位指定内存块错误的代码行</p> 
  <p align="left">单确定了内存泄漏发生在哪一行，有时候并不足够。特别是同一个new对应有多处释放的情形。在实际的工程中，以下两种情况很典型：</p> 
  <p align="left">创建对象的地方是一个类工厂（ClassFactory）模式。很多甚至全部类实例由同一个new创建。对于此，定位到了new出对象的所在行基本没有多大帮助。<br> <br>COM对象。我们知道COM对象采用Reference Count维护生命周期。也就是说，对象new的地方只有一个，但是Release的地方很多，你要一个个排除。<br>那么，有什么好办法，可以迅速定位内存泄漏？</p> 
  <p align="left">答：有。</p> 
  <p align="left">在内存泄漏情况复杂的时候，你可以用以下方法定位内存泄漏。这是我个人认为通用的内存泄漏追踪方法中最有效的手段。</p> 
  <p align="left">我们再回头看看crtdbg生成的内存泄漏报告：</p> 
  <p align="left">Detected memory leaks!<br>Dumping objects -&gt;<br>{58} normal block at 0x004F1A38, 10 bytes long.<br> Data: &lt;          &gt; CD CD CD CD CD CD CD CD CD CD <br>Object dump complete.</p> 
  <p align="left">除了产生该内存泄漏的内存分配语句所在的文件名、行号为，我们注意到有一个比较陌生的信息：{58}。这个整数值代表了什么意思呢？</p> 
  <p align="left">其实，它代表了第几次内存分配操作。象这个例子，{58}代表了第58次内存分配操作发生了泄漏。你可能要说，我只new过一次，怎么会是第58次？这很容易理解，其他的内存申请操作在C的初始化过程调用的呗。:)</p> 
  <p align="left">有没有可能，我们让程序运行到第58次内存分配操作的时候，自动停下来，进入调试状态？所幸，crtdbg确实提供了这样的函数：即 long _CrtSetBreakAlloc(long nAllocID)。我们加上它：</p> 
  <p align="left"> </p> 
  <p align="left"> </p> 
  <div class="dp-highlighter bg_html"> 
   <div class="bar"> 
    <div class="tools"> 
     <strong>[html]</strong>  
     <a class="ViewSource" title="view plain" href="http://blog.csdn.net/windows_nt/article/details/8652191">view plain</a> 
     <a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/windows_nt/article/details/8652191">copy</a> 
     <div>
         
     </div> 
    </div> 
   </div> 
   <ol class="dp-xml" start="1"><li class="alt">#define CRTDBG_MAP_ALLOC    </li><li>#include <span class="tag">&lt;<span class="tag-name">stdlib.h<span class="tag">&gt;    </span></span></span></li><li class="alt">#include <span class="tag">&lt;<span class="tag-name">crtdbg.h<span class="tag">&gt;    </span></span></span></li><li>  </li><li class="alt">int main()  </li><li>{  </li><li class="alt">    _CrtSetBreakAlloc(58);  </li><li>    char* <span class="attribute">pChars = <span class="attribute-value">new char[10];  </span></span></li><li class="alt">    _CrtDumpMemoryLeaks();  </li><li>    return 0;  </li><li class="alt">}  </li></ol> 
  </div> 
  <br> 
  <p> </p> 
  <p align="left">你发现，程序运行到 char* pChars = new char[10];一句时，自动停下来进入调试状态。细细体会一下，你可以发现，这种方式你获得的信息远比在程序退出时获得文件名及行号有价值得多。因为报告泄漏文件名及行号，你获得的只是静态的信息，然而_CrtSetBreakAlloc则是把整个现场恢复，你可以通过对函数调用栈分析（我发现很多人不习惯看函数调用栈，如果你属于这种情况，我强烈推荐你去补上这一课，因为它太重要了）以及其他在线调试技巧，来分析产生内存泄漏的原因。通常情况下，这种分析方法可以在5分钟内找到肇事者。</p> 
  <p align="left"><br>PS：在VS2010下使用这两种方法，宏和头文件不用包含也可以正确运行：<br>#define CRTDBG_MAP_ALLOC  <br>#include &lt;stdlib.h&gt;  <br>#include &lt;crtdbg.h&gt;   </p> 
  <p><br> 非MFC程序可以用以下方法检测内存泄露：</p> 
  <p>1.程序开始包含如下定义：</p> 
  <p>#ifdef _DEBUG<br>#define DEBUG_CLIENTBLOCK new( _CLIENT_BLOCK, __FILE__, __LINE__)<br>#else<br>#define DEBUG_CLIENTBLOCK<br>#endif  // _DEBUG<br>#define _CRTDBG_MAP_ALLOC<br>#include &lt;stdlib.h&gt;<br>#include &lt;crtdbg.h&gt;<br>#ifdef _DEBUG<br>#define new DEBUG_CLIENTBLOCK<br>#endif  // _DEBUG</p> 
  <p> </p> 
  <p>2.程序中添加下面的函数：</p> 
  <p>_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);</p> 
  <p> </p> 
  <p>Debug版本程序运行结束后如有内存泄漏，输出窗口中会显示类似信息：<br>Detected memory leaks!<br>Dumping objects -&gt;<br>g:\programs\test\test.cpp(16) : {51} client block at 0x00385C58, subtype 0, 4 bytes long.<br> Data: &lt;    &gt; CD CD CD CD<br>Object dump complete.</p> 
  <p> </p> 
  <p> </p> 
  <p>MFC程序内存泄漏检测方法：</p> 
  <p> </p> 
  <p>1.在 CMyApp 中添加如下三个 CMemoryState 类的成员变量：</p> 
  <p>#ifdef _DEBUG<br>protected:<br>      CMemoryState m_msOld, m_msNew, m_msDiff;<br>#endif  // _DEBUG</p> 
  <p> </p> 
  <p>2.在 CMyApp::InitInstance() 中添加如下代码：</p> 
  <p>#ifdef _DEBUG<br>      m_msOld.Checkpoint();<br>#endif  // _DEBUG</p> 
  <p> </p> 
  <p>3.在 CMyApp::ExitInstance() 中添加如下代码：</p> 
  <p>#ifdef _DEBUG<br>      m_msNew.Checkpoint();<br>      if (m_msDiff.Difference(m_msOld, m_msNew))<br>      {<!-- --><br>            afxDump&lt;&lt;"\nMemory Leaked :\n";<br>            m_msDiff.DumpStatistics();<br>            afxDump&lt;&lt;"Dump Complete !\n\n";<br>      }<br>#endif  // _DEBUG</p> 
  <p> </p> 
  <p>Debug版本程序运行结束后如有内存泄漏，输出窗口中会显示类似信息：</p> 
  <p>Memory Leaked :<br>0 bytes in 0 Free Blocks.<br>8 bytes in 1 Normal Blocks.<br>0 bytes in 0 CRT Blocks.<br>0 bytes in 0 Ignore Blocks.<br>0 bytes in 0 Client Blocks.<br>Largest number used: 8825 bytes.<br>Total allocations: 47506 bytes.<br>Dump Complete !</p> 
  <p>Detected memory leaks!<br>Dumping objects -&gt;<br>g:\programs\chat\chatdlg.cpp(120) : {118} normal block at 0x00D98150, 8 bytes long.<br> Data: &lt;        &gt; A8 7F D9 00 01 00 00 00<br>Object dump complete.</p> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/jack-jia-moonew/p/4157425.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f90feadffa6742b0a36c36c06c6c1f50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TCP/UDP 常用端口列表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ed74f9392a23112d90fdc8cfd492e6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL之函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>