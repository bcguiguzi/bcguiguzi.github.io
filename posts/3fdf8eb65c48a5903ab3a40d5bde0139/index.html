<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔试题汇总（3） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔试题汇总（3）" />
<meta property="og:description" content="1. 以下三条输出语句分别输出什么？ char str1[] = &#34;abc&#34;; char str2[] = &#34;abc&#34;; const char str3[] = &#34;abc&#34;; const char str4[] = &#34;abc&#34;; const char* str5 = &#34;abc&#34;; const char* str6 = &#34;abc&#34;; cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; // 输出什么？ cout &lt;&lt; boolalpha &lt;&lt; ( str3==str4 ) &lt;&lt; endl; // 输出什么？ cout &lt;&lt; boolalpha &lt;&lt; ( str5==str6 ) &lt;&lt; endl; // 输出什么？ 答：分别输出false,false,true。str1 和str2 都是字符数组，每个都有其自己的存储区，它们的值则是各 存储区首地址，不等；str3 和str4 同上，只是按const 语义，它们所指向的数据区不能修改。str5 和str6 并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指 向该区首地址的指针，相等。 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3fdf8eb65c48a5903ab3a40d5bde0139/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-10T00:01:00+08:00" />
<meta property="article:modified_time" content="2011-04-10T00:01:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔试题汇总（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 以下三条输出语句分别输出什么？ <br>char str1[] = "abc"; <br>char str2[] = "abc"; <br>const char str3[] = "abc"; <br>const char str4[] = "abc"; <br>const char* str5 = "abc"; <br>const char* str6 = "abc"; <br>cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; // 输出什么？ <br>cout &lt;&lt; boolalpha &lt;&lt; ( str3==str4 ) &lt;&lt; endl; // 输出什么？ <br>cout &lt;&lt; boolalpha &lt;&lt; ( str5==str6 ) &lt;&lt; endl; // 输出什么？ <br>答：分别输出false,false,true。str1 和str2 都是字符数组，每个都有其自己的存储区，它们的值则是各 <br>存储区首地址，不等；str3 和str4 同上，只是按const 语义，它们所指向的数据区不能修改。str5 和str6 <br>并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指 <br>向该区首地址的指针，相等。 <br>2. 以下代码中的两个sizeof 用法有问题吗？ <br>void UpperCase( char str[] ) // 将str 中的小写字母转换成大写字母 <br>{ <br>for( size_t i=0; iif( 'a'&lt;=str[i] &amp;&amp; str[i]&lt;='z' ) <br>str[i] -= ('a'-'A' ); <br>} <br>char str[] = "aBcDe"; <br>cout &lt;&lt; "str 字符长度为: " &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl; <br>UpperCase( str ); <br>cout &lt;&lt; str &lt;&lt; endl; <br>答：函数内的sizeof 有问题。根据语法，sizeof 如用于数组，只能测出静态数组的大小，无法检测动态分 <br>配的或外部数组大小。函数外的str 是一个静态定义的数组，因此其大小为6，函数内的str 实际只是一个 <br>指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof 作用于上只将其当指针看，一个指针 <br>为4 个字节，因此返回4。 <br>3. 非C++内建型别A 和B，在哪几种情况下B 能隐式转化为A？ <br>答： <br>a. class B : public A { ……} // B 公有继承自A，可以是间接继承的 <br>b. class B { operator A( ); } // B 实现了隐式转化为A 的转化 <br>c. class A { A( const B&amp; ); } // A 实现了non-explicit 的参数为B（可以有其他带默认值的参数）构 <br>造函数 <br>d. A&amp; operator= ( const A&amp; ); // 赋值操作，虽不是正宗的隐式类型转换，但也可以勉强算一个 <br>4. 以下代码有什么问题？ <br>struct Test <br>{ <br>Test( int ) {} <br>Test() {} <br>void fun() {} <br>}; <br>void main( void ) <br>{ <br>Test a(1); <br>a.fun(); <br>Test b(); <br>b.fun(); <br>} <br>答：变量b 定义出错。按默认构造函数定义对象，不需要加括号。 <br>5. 以下代码有什么问题？ <br>cout &lt;&lt; (true?1:"1") &lt;&lt; endl; <br>答：三元表达式“？:”问号后面的两个操作数必须为同一类型。 <br>6. 以下代码能够编译通过吗，为什么？ <br>unsigned int const size1 = 2; <br>char str1[ size1 ]; <br>unsigned int temp = 0; <br>cin &gt;&gt; temp; <br>unsigned int const size2 = temp; <br>char str2[ size2 ]; <br>答：str2 定义出错，size2 非编译器期间常量，而数组定义要求长度必须为编译期常量。 <br>7. 以下反向遍历array 数组的方法有什么错误？ <br>vector array; <br>array.push_back( 1 ); <br>array.push_back( 2 ); <br>array.push_back( 3 ); <br>for( vector::size_type i=array.size()-1; i&gt;=0; --i ) // 反向遍历array 数组 <br>{ <br>cout &lt;&lt; array[i] &lt;&lt; endl; <br>} <br>答：首先数组定义有误，应加上类型参数：vector array。其次vector::size_type 被定义为 <br>unsigned int，即无符号数，这样做为循环变量的i 为0 时再减1 就会变成最大的整数，导致循环失去控 <br>制。 <br>8. 以下代码中的输出语句输出0 吗，为什么？ <br>struct CLS <br>{ <br>int m_i; <br>CLS( int i ) : m_i(i) {} <br>CLS() <br>{ <br>CLS(0); <br>} <br>}; <br>CLS obj; <br>cout &lt;&lt; obj.m_i &lt;&lt; endl; <br>答：不能。在默认构造函数内部再调用带参的构造函数属用户行为而非编译器行为，亦即仅执行函数调用， <br>而不会执行其后的初始化表达式。只有在生成对象时，初始化表达式才会随相应的构造函数一起调用。 <br>9. C++中的空类，默认产生哪些类成员函数？ <br>答： <br>class Empty <br>{ <br>public: <br>Empty(); // 缺省构造函数 <br>Empty( const Empty&amp; ); // 拷贝构造函数 <br>~Empty(); // 析构函数 <br>Empty&amp; operator=( const Empty&amp; ); // 赋值运算符 <br>Empty* operator&amp;(); // 取址运算符 <br>const Empty* operator&amp;() const; // 取址运算符const <br>}; <br>10. 以下两条输出语句分别输出什么？ <br>float a = 1.0f; <br>cout &lt;&lt; (int)a &lt;&lt; endl; <br>cout &lt;&lt; (int&amp;)a &lt;&lt; endl; <br>cout &lt;&lt; boolalpha &lt;&lt; ( (int)a == (int&amp;)a ) &lt;&lt; endl; // 输出什么？ <br>float b = 0.0f; <br>cout &lt;&lt; (int)b &lt;&lt; endl; <br>cout &lt;&lt; (int&amp;)b &lt;&lt; endl; <br>cout &lt;&lt; boolalpha &lt;&lt; ( (int)b == (int&amp;)b ) &lt;&lt; endl; // 输出什么？ <br>答：分别输出false 和true。注意转换的应用。(int)a 实际上是以浮点数a 为参数构造了一个整型数，该 <br>整数的值是1，(int&amp;)a 则是告诉编译器将a 当作整数看（并没有做任何实质上的转换）。因为1 以整数 <br>形式存放和以浮点形式存放其内存数据是不一样的，因此两者不等。对b 的两种转换意义同上，但是0 的 <br>整数形式和浮点形式其内存数据是一样的，因此在这种特殊情形下，两者相等（仅仅在数值意义上）。 <br>注意，程序的输出会显示(int&amp;)a=1065353216，这个值是怎么来的呢？前面已经说了，1 以浮点数形式 <br>存放在内存中，按ieee754 规定，其内容为0x0000803F（已考虑字节反序）。这也就是a 这个变量所 <br>占据的内存单元的值。当(int&amp;)a 出现时，它相当于告诉它的上下文：“把这块地址当做整数看待！不要管 <br>它原来是什么。”这样，内容0x0000803F 按整数解释，其值正好就是1065353216（十进制数）。 <br>通过查看汇编代码可以证实“(int)a 相当于重新构造了一个值等于a 的整型数”之说，而(int&amp;)的作用则仅 <br>仅是表达了一个类型信息，意义在于为cout&lt;&lt;及==选择正确的重载版本。 <br>11. 以下代码有什么问题？ <br>typedef vector IntArray; <br>IntArray array;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8817d8639e11f4bb2a79cb594782c9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec028150d122ea469226eb02caaa25de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;string</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>