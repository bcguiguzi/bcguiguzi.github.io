<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【IMX6ULL驱动开发学习】11.Linux之SPI驱动 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【IMX6ULL驱动开发学习】11.Linux之SPI驱动" />
<meta property="og:description" content="参考：驱动程序开发：SPI设备驱动_spi驱动_邓家文007的博客-CSDN博客
目录
一、SPI驱动简介
1.1 SPI架构概述
1.2 SPI适配器（控制器）数据结构
1.2 SPI设备数据结构
1.3 SIP设备驱动
1.4 接口函数
二、SPI驱动模板
一、SPI驱动简介 SPI驱动框架和I2C驱动框架是十分相似的，不同的是因为SPI是通过片选引脚来选择从机设备的，因此SPI不再需要像I2C那样先进行寻址操作（查询从机地址）后再进行对应寄存器的数据交互，并且SPI是全双工通信，通信速率要远高于I2C。
但是SPI显然占用的硬件资源也比I2C要多，并且SPI没有了像I2C那样指定的流控制（例如开始、停止信号）和没有了像I2C应当机制（导致无法确认数据是否接收到了）。
1.1 SPI架构概述 Linux的SPI体系结构可以分为3个组成部分：
spi核心（SPI Core）：SPI Core是Linux内核用来维护和管理spi的核心部分，SPI Core提供操作接口函数，允许一个spi master，spi driver和spi device初始化时在SPI Core中进行注册，以及退出时进行注销。spi控制器驱动或适配器驱动（SPI Master Driver）：SPI Master针对不同类型的spi控制器硬件，实现spi总线的硬件访问操作。SPI Master 通过接口函数向SPI Core注册一个控制器。spi设备驱动（SPI Device Driver）：SPI Driver是对应于spi设备端的驱动程序，通过接口函数向SPI Core进行注册，SPI Driver的作用是将spi设备挂接到spi总线上。 Linux的软件架构图如下图所示： 1.2 SPI适配器（控制器）数据结构 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_master结构体描述SPI控制器，里面最重要的成员就是transfer函数指针：
transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。
transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。
1.2 SPI设备数据结构 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_device结构体描述SPI设备，里面记录有设备的片选引脚、频率、挂在哪个SPI控制器下面：
1.3 SIP设备驱动 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_driver结构体描述SPI设备驱动：
可以看出，spi_driver 和 i2c_driver、 platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 比如：spi1下面接有两个设备（有两个片选信号），我们就可以把设备放入子节点里面，子节点将有内核解析后转换成一个spi_device，与某一个spi_driver匹配后，spi_driver里的probe函数就被调用，我们在probe函数里就可以注册字符设备驱动程序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9e99e0fc29797c817ceaac989482825b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T21:36:37+08:00" />
<meta property="article:modified_time" content="2023-08-25T21:36:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【IMX6ULL驱动开发学习】11.Linux之SPI驱动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考<a href="https://blog.csdn.net/morecrazylove/article/details/126850983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169295225116800180667484%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169295225116800180667484&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-126850983-null-null.142%5Ev93%5EchatsearchT3_1&amp;utm_term=spi%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F&amp;spm=1018.2226.3001.4187" title="：驱动程序开发：SPI设备驱动_spi驱动_邓家文007的博客-CSDN博客">：驱动程序开发：SPI设备驱动_spi驱动_邓家文007的博客-CSDN博客</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B" rel="nofollow">一、SPI驱动简介</a></p> 
<p id="1.1%20SPI%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#1.1%20SPI%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0" rel="nofollow">1.1 SPI架构概述</a></p> 
<p id="1.2%20SPI%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2%20SPI%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">1.2 SPI适配器（控制器）数据结构</a></p> 
<p id="1.2%20SPI%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2%20SPI%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">1.2 SPI设备数据结构</a></p> 
<p id="1.3%20SIP%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-toc" style="margin-left:80px;"><a href="#1.3%20SIP%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8" rel="nofollow">1.3 SIP设备驱动</a></p> 
<p id="1.4%20%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.4%20%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" rel="nofollow">1.4 接口函数</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF" rel="nofollow"> 二、SPI驱动模板</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B">一、SPI驱动简介</h3> 
<p>SPI驱动框架和I2C驱动框架是十分相似的，不同的是因为SPI是通过片选引脚来选择从机设备的，因此SPI不再需要像I2C那样先进行寻址操作（查询从机地址）后再进行对应寄存器的数据交互，并且SPI是全双工通信，通信速率要远高于I2C。</p> 
<p>但是SPI显然占用的硬件资源也比I2C要多，并且SPI没有了像I2C那样指定的流控制（例如开始、停止信号）和没有了像I2C应当机制（导致无法确认数据是否接收到了）。</p> 
<h4 id="1.1%20SPI%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0">1.1 SPI架构概述</h4> 
<p>Linux的SPI体系结构可以分为3个组成部分：</p> 
<ul><li>spi核心（SPI Core）：SPI Core是Linux内核用来维护和管理spi的核心部分，SPI Core提供操作接口函数，允许一个spi master，spi driver和spi device初始化时在SPI Core中进行注册，以及退出时进行注销。</li><li>spi控制器驱动或适配器驱动（SPI Master Driver）：SPI Master针对不同类型的spi控制器硬件，实现spi总线的硬件访问操作。SPI Master 通过接口函数向SPI Core注册一个控制器。</li><li>spi设备驱动（SPI Device Driver）：SPI Driver是对应于spi设备端的驱动程序，通过接口函数向SPI Core进行注册，SPI Driver的作用是将spi设备挂接到spi总线上。</li></ul> 
<p>Linux的软件架构图如下图所示： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/a0/7GQ7uvE9_o.png"></p> 
<h4 id="1.2%20SPI%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.2 SPI适配器（控制器）数据结构</h4> 
<p>参考内核文件：include/linux/spi/spi.h</p> 
<p>Linux中使用spi_master结构体描述SPI控制器，里面最重要的成员就是<code>transfer</code>函数指针：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/be/56/aU8WTlWM_o.png"></p> 
<p>transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。<br> transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。</p> 
<h4 id="1.2%20SPI%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.2 SPI设备数据结构</h4> 
<p>参考内核文件：include/linux/spi/spi.h</p> 
<p>Linux中使用spi_device结构体描述SPI设备，里面记录有设备的片选引脚、频率、挂在哪个SPI控制器下面：<br><img alt="" src="https://images2.imgbox.com/df/e5/JWSH3tHQ_o.png"></p> 
<h4 id="1.3%20SIP%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">1.3 SIP设备驱动</h4> 
<p>参考内核文件：include/linux/spi/spi.h</p> 
<p>Linux中使用spi_driver结构体描述SPI设备驱动：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/00/b4/SEX8Gx2q_o.png"></p> 
<p>可以看出，spi_driver 和 i2c_driver、 platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 </p> 
<p>比如：spi1下面接有两个设备（有两个片选信号），我们就可以把设备放入子节点里面，子节点将有内核解析后转换成一个spi_device，与某一个spi_driver匹配后，spi_driver里的probe函数就被调用，我们在probe函数里就可以注册字符设备驱动程序。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/63/75/49ap3z2a_o.png"></p> 
<h4 id="1.4%20%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0">1.4 接口函数</h4> 
<p>函数原形：</p> 
<ul><li>简易函数</li></ul> 
<pre><code class="language-objectivec">/**
 * SPI同步写
 * @spi: 写哪个设备
 * @buf: 数据buffer
 * @len: 长度
 * 这个函数可以休眠
 *
 * 返回值: 0-成功, 负数-失败码
 */
static inline int
spi_write(struct spi_device *spi, const void *buf, size_t len);

/**
 * SPI同步读
 * @spi: 读哪个设备
 * @buf: 数据buffer
 * @len: 长度
 * 这个函数可以休眠
 *
 * 返回值: 0-成功, 负数-失败码
 */
static inline int
spi_read(struct spi_device *spi, void *buf, size_t len);


/**
 * spi_write_then_read : 先写再读, 这是一个同步函数
 * @spi: 读写哪个设备
 * @txbuf: 发送buffer
 * @n_tx: 发送多少字节
 * @rxbuf: 接收buffer
 * @n_rx: 接收多少字节
 * 这个函数可以休眠
 * 
 * 这个函数执行的是半双工的操作: 先发送txbuf中的数据，在读数据，读到的数据存入rxbuf
 *
 * 这个函数用来传输少量数据(建议不要操作32字节), 它的效率不高
 * 如果想进行高效的SPI传输，请使用spi_{async,sync}(这些函数使用DMA buffer)
 *
 * 返回值: 0-成功, 负数-失败码
 */
extern int spi_write_then_read(struct spi_device *spi,
		const void *txbuf, unsigned n_tx,
		void *rxbuf, unsigned n_rx);

/**
 * spi_w8r8 - 同步函数，先写8位数据，再读8位数据
 * @spi: 读写哪个设备
 * @cmd: 要写的数据
 * 这个函数可以休眠
 *
 *
 * 返回值: 成功的话返回一个8位数据(unsigned), 负数表示失败码
 */
static inline ssize_t spi_w8r8(struct spi_device *spi, u8 cmd);

/**
 * spi_w8r16 - 同步函数，先写8位数据，再读16位数据
 * @spi: 读写哪个设备
 * @cmd: 要写的数据
 * 这个函数可以休眠
 *
 * 读到的16位数据: 
 *     低地址对应读到的第1个字节(MSB)，高地址对应读到的第2个字节(LSB)
 *     这是一个big-endian的数据
 *
 * 返回值: 成功的话返回一个16位数据(unsigned), 负数表示失败码
 */
static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd);

/**
 * spi_w8r16be - 同步函数，先写8位数据，再读16位数据，
 *               读到的16位数据被当做big-endian，然后转换为CPU使用的字节序
 * @spi: 读写哪个设备
 * @cmd: 要写的数据
 * 这个函数可以休眠
 *
 * 这个函数跟spi_w8r16类似，差别在于它读到16位数据后，会把它转换为"native endianness"
 *
 * 返回值: 成功的话返回一个16位数据(unsigned, 被转换为本地字节序), 负数表示失败码
 */
static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd);</code></pre> 
<ul><li> 复杂函数</li></ul> 
<pre><code class="language-objectivec">/**
 * spi_async - 异步SPI传输函数，简单地说就是这个函数即刻返回，它返回后SPI传输不一定已经完成
 * @spi: 读写哪个设备
 * @message: 用来描述数据传输，里面含有完成时的回调函数(completion callback)
 * 上下文: 任意上下文都可以使用，中断中也可以使用
 *
 * 这个函数不会休眠，它可以在中断上下文使用(无法休眠的上下文)，也可以在任务上下文使用(可以休眠的上下文) 
 *
 * 完成SPI传输后，回调函数被调用，它是在"无法休眠的上下文"中被调用的，所以回调函数里不能有休眠操作。
 * 在回调函数被调用前message-&gt;statuss是未定义的值，没有意义。
 * 当回调函数被调用时，就可以根据message-&gt;status判断结果: 0-成功,负数表示失败码
 * 当回调函数执行完后，驱动程序要认为message等结构体已经被释放，不能再使用它们。
 *
 * 在传输过程中一旦发生错误，整个message传输都会中止，对spi设备的片选被取消。
 *
 * 返回值: 0-成功(只是表示启动的异步传输，并不表示已经传输成功), 负数-失败码
 */
extern int spi_async(struct spi_device *spi, struct spi_message *message);

/**
 * spi_sync - 同步的、阻塞的SPI传输函数，简单地说就是这个函数返回时，SPI传输要么成功要么失败
 * @spi: 读写哪个设备
 * @message: 用来描述数据传输，里面含有完成时的回调函数(completion callback)
 * 上下文: 能休眠的上下文才可以使用这个函数
 *
 * 这个函数的message参数中，使用的buffer是DMA buffer
 *
 * 返回值: 0-成功, 负数-失败码
 */
extern int spi_sync(struct spi_device *spi, struct spi_message *message);


/**
 * spi_sync_transfer - 同步的SPI传输函数
 * @spi: 读写哪个设备
 * @xfers: spi_transfers数组，用来描述传输
 * @num_xfers: 数组项个数
 * 上下文: 能休眠的上下文才可以使用这个函数
 *
 * 返回值: 0-成功, 负数-失败码
 */
static inline int
spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
	unsigned int num_xfers);</code></pre> 
<h3 id="%C2%A0%E4%BA%8C%E3%80%81SPI%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF"> 二、SPI驱动模板</h3> 
<p>spi_drv.c</p> 
<pre><code class="language-objectivec">#include &lt;linux/spi/spi.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/poll.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/major.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/stat.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/tty.h&gt;
#include &lt;linux/kmod.h&gt;
#include &lt;linux/gfp.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/of_irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/fcntl.h&gt;
#include &lt;linux/timer.h&gt;

/* 主设备号                                                                 */
static int major = 0;
static struct class *my_spi_class;

static struct spi_device *g_spi;

static DECLARE_WAIT_QUEUE_HEAD(gpio_wait);
struct fasync_struct *spi_fasync;


/* 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t spi_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	// int err;

	// struct spi_transfer msgs[2];

	/* 初始化 spi_transfer */

	// static inline int
    //   spi_sync_transfer(struct   spi_device *spi, struct spi_transfer *xfers,
	//   unsigned int num_xfers);

	/* copy_to_user  */
	
	return 0;
}

static ssize_t spi_drv_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
	//int err;

	/* copy_from_user  */


	// struct spi_transfer msgs[2];

	/* 初始化 spi_transfer */

	// static inline int
    //   spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
	//   unsigned int num_xfers);

	
	return 0;    
}


static unsigned int spi_drv_poll(struct file *fp, poll_table * wait)
{
	//printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
	poll_wait(fp, &amp;gpio_wait, wait);
	//return is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM;
	return 0;
}

static int spi_drv_fasync(int fd, struct file *file, int on)
{
	if (fasync_helper(fd, file, on, &amp;spi_fasync) &gt;= 0)
		return 0;
	else
		return -EIO;
}


/* 定义自己的file_operations结构体                                              */
static struct file_operations spi_drv_fops = {
	.owner	 = THIS_MODULE,
	.read    = spi_drv_read,
	.write   = spi_drv_write,
	.poll    = spi_drv_poll,
	.fasync  = spi_drv_fasync,
};


static int spi_drv_probe(struct spi_device *spi)
{
	// struct device_node *np = client-&gt;dev.of_node;

	/* 记录spi_device */
	g_spi = spi;

	/* 注册字符设备 */
	/* 注册file_operations 	*/
	major = register_chrdev(0, "100ask_spi", &amp;spi_drv_fops);  /* /dev/gpio_desc */

	my_spi_class = class_create(THIS_MODULE, "100ask_spi_class");
	if (IS_ERR(my_spi_class)) {
		printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
		unregister_chrdev(major, "100ask_spi");
		return PTR_ERR(my_spi_class);
	}

	device_create(my_spi_class, NULL, MKDEV(major, 0), NULL, "myspi"); /* /dev/myspi */
	
	return 0;
}

static int spi_drv_remove(struct spi_device *spi)
{
	/* 反注册字符设备 */
	device_destroy(my_spi_class, MKDEV(major, 0));
	class_destroy(my_spi_class);
	unregister_chrdev(major, "100ask_spi");

	return 0;
}

static const struct of_device_id myspi_dt_match[] = {
	{ .compatible = "100ask,spidev" },
	{},
};
static struct spi_driver my_spi_driver = {
	.driver = {
		   .name = "100ask_spi_drv",
		   .owner = THIS_MODULE,
		   .of_match_table = myspi_dt_match,
	},
	.probe = spi_drv_probe,
	.remove = spi_drv_remove,
};


static int __init spi_drv_init(void)
{
	/* 注册spi_driver */
	return spi_register_driver(&amp;my_spi_driver);
}

static void __exit spi_drv_exit(void)
{
	/* 反注册spi_driver */
	spi_unregister_driver(&amp;my_spi_driver);
}

/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */

module_init(spi_drv_init);
module_exit(spi_drv_exit);

MODULE_LICENSE("GPL");


</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3962d7867f8516f0be0494b0e2dfd3f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【IMX6ULL驱动开发学习】09.Linux之I2C驱动框架简介和驱动程序模板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8aba9c2ca64d107bca64b44b58cfcb93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【IMX6ULL驱动开发学习】12.Linux SPI驱动实战：DAC驱动设计流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>