<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔试题汇总（1） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔试题汇总（1）" />
<meta property="og:description" content="1. 求下面函数的返回值（微软） int func(x) { int countx = 0; while(x) { countx &#43;&#43;; x = x&amp;(x-1); } return countx; } 假定x = 9999。答案：8 思路：将x 转化为2 进制，看含有的1 的个数。
2. 什么是“引用”？申明和使用“引用”要注意哪些问题？ 答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全 相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变 量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名， 它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。 不能建立数组的引用。
3. 将“引用”作为函数参数有哪些特点？ （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来 主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作 就是对其相应的目标对象（在主调函数中）的操作。 （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操 作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元， 形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参 数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中 同样要给形参分配存储单元，且需要重复使用&#34;*指针变量名&#34;的形式进行运算，这很容 易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地 址作为实参。而引用更容易使用，更清晰。
4. 在什么时候需要使用“常引用”？ 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就 应使用常引用。常引用声明方式：const 类型标识符&amp;引用名=目标变量名； 例1 int a ; const int &amp;ra=a; ra=1; //错误 a=1; //正确 例2 string foo( ); void bar(string &amp; s); 那么下面的表达式将是非法的： bar(foo( )); bar(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c8817d8639e11f4bb2a79cb594782c9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-09T23:45:00+08:00" />
<meta property="article:modified_time" content="2011-04-09T23:45:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔试题汇总（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 求下面函数的返回值（微软） <br>int func(x) <br>{ <br>int countx = 0; <br>while(x) <br>{ <br>countx ++; <br>x = x&amp;(x-1); <br>} <br>return countx; <br>} <br>假定x = 9999。答案：8 <br>思路：将x 转化为2 进制，看含有的1 的个数。</p> 
<p>2. 什么是“引用”？申明和使用“引用”要注意哪些问题？ <br>答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全 <br>相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变 <br>量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。 <br>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名， <br>它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。 <br>不能建立数组的引用。</p> 
<p>3. 将“引用”作为函数参数有哪些特点？ <br>（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来 <br>主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作 <br>就是对其相应的目标对象（在主调函数中）的操作。 <br>（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操 <br>作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元， <br>形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参 <br>数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 <br>（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中 <br>同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容 <br>易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地 <br>址作为实参。而引用更容易使用，更清晰。</p> 
<p>4. 在什么时候需要使用“常引用”？ <br>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就 <br>应使用常引用。常引用声明方式：const 类型标识符&amp;引用名=目标变量名； <br>例1 <br>int a ; <br>const int &amp;ra=a; <br>ra=1; //错误 <br>a=1; //正确 <br>例2 <br>string foo( ); <br>void bar(string &amp; s); <br>那么下面的表达式将是非法的： <br>bar(foo( )); <br>bar("hello world"); <br>原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对 <br>象都是const 类型的。因此上面的表达式就是试图将一个const 类型的对象转换为非 <br>const 类型，这是非法的。 <br>引用型参数应该在能被定义为const 的情况下，尽量定义为const 。</p> 
<p>5. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规 <br>则? <br>格式：类型标识符&amp;函数名（形参列表及类型说明）{ //函数体} <br>好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局 <br>部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效， <br>产生runtime error! <br>注意事项： <br>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要 <br>原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用， <br>程序会进入未知状态。 <br>（2）不能返回函数内部new 分配的内存的引用。这条可以参照Effective C++[1] <br>的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 <br>new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 <br>个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new <br>分配）就无法释放，造成memory leak。 <br>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1] <br>的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的 <br>时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在 <br>一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该 <br>属性的单纯赋值就会破坏业务规则的完整性。 <br>（4）流操作符重载返回值申明为“引用”的作用： <br>流操作符&lt; 
 &lt;和&gt;
   &gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; "hello" &lt;&lt; 
  <br>endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选 
  <br>的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象， 
  <br>程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt; 
  &lt;操作符实际上&gt; 
   <br>是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt; 
   &lt;操作符。&gt; 
    <br>因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性 
    <br>以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。赋值操作符=。 
    <br>这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100; 
    <br>赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符 
    <br>的惟一返回值选择。 
    <br>例3 
    <br>＃i nclude 
     
     <br>int &amp;put(int n); 
     <br>int vals[10]; 
     <br>int error=-1; 
     <br>void main() 
     <br>{ 
     <br>put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; 
     <br>put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; 
     <br>cout&lt; 
      
      <br>cout&lt; 
       
       <br>} 
       <br>int &amp;put(int n) 
       <br>{ 
       <br>if (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; 
       <br>else { cout&lt;&lt;"subscript error"; return error; } 
       <br>} 
       <br>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返 
       <br>回引用，Effective C++[1]的Item23 详细的讨论了这个问题。主要原因是这四个操 
       <br>作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括： 
       <br>返回一个对象、返回一个局部变量的引用，返回一个new 分配的对象的引用、返回一 
       <br>个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3 两个方案都被 
       <br>否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true 而导致错误。所以 
       <br>可选的只剩下返回一个对象了。 
       
      
     
    
   
 </p> 
<p>6. “引用”与多态的关系？ <br>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向 <br>它的派生类实例。 <br>例4 <br>Class A; Class B : Class A{...}; B b; A&amp; ref = b;</p> 
<p>7. “引用”与指针的区别是什么？ <br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针， <br>程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操 <br>作。此外，就是上面提到的对函数传ref 和pointer 的区别。</p> 
<p>8. 什么时候需要“引用”？ <br>流操作符&lt; 
 &lt;和&gt;
   &gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参 
  <br>数、其它情况都推荐使用引用。 
  <br>以上2-8 参考： 
  <br>http://blog.csdn.net/wfwd/archive/2006/05/30/763551.aspx 
 </p> 
<p>9. 结构与联合有和区别？ <br>1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存 <br>放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不 <br>同成员的存放地址不同）。 <br>2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对 <br>于结构的不同成员赋值是互不影响的。</p> 
<p>10. 下面关于“联合”的题目的输出？ <br>a) <br>＃i nclude 
  
  <br>union 
  <br>{ 
  <br>int i; 
  <br>char x[2]; 
  <br>}a; 
  <br>void main() 
  <br>{ 
  <br>a.x[0] = 10; 
  <br>a.x[1] = 1; 
  <br>printf("%d",a.i); 
  <br>} 
  <br>答案：266 (低位低地址，高位高地址，内存占用情况是Ox010A） 
  <br>b) 
  <br>main() 
  <br>{ 
  <br>union{ /*定义一个联合*/ 
  <br>int i; 
  <br>struct{ /*在联合中定义一个结构*/ 
  <br>char first; 
  <br>char second; 
  <br>}half; 
  <br>}number; 
  <br>number.i=0x4241; /*联合成员赋值*/ 
  <br>printf("%c%c/n", number.half.first, mumber.half.second); 
  <br>number.half.first='a'; /*联合中结构成员赋值*/ 
  <br>number.half.second='b'; 
  <br>printf("%x/n", number.i); 
  <br>getch(); 
  <br>} 
  <br>答案： AB (0x41 对应'A',是低位；Ox42 对应'B',是高位） 
  <br>6261 (number.i 和number.half 共用一块地址空间） 
 </p> 
<p>11. 已知strcpy的函数原型：char *strcpy(char <br>*strDest, const char *strSrc)其中strDest 是目的字符 <br>串，strSrc 是源字符串。不调用C++/C 的字符串库函数， <br>请编写函数strcpy。</p> 
<p>答案： <br>char *strcpy(char *strDest, const char *strSrc) <br>{ <br>if ( strDest == NULL || strSrc == NULL) <br>return NULL ; <br>if ( strDest == strSrc) <br>return strDest ; <br>char *tempptr = strDest ; <br>while( (*strDest++ = *strSrc++) != ‘/0’) <br>return tempptr ; <br>}</p> 
<p>12. 已知String类定义如下： <br>class String <br>{ <br>public: <br>String(const char *str = NULL); // 通用构造函数 <br>String(const String &amp;another); // 拷贝构造函数 <br>~ String(); // 析构函数 <br>String &amp; operater =(const String &amp;rhs); // 赋值函数 <br>private: <br>char *m_data; // 用于保存字符串 <br>}; <br>尝试写出类的成员函数实现。 <br>答案： <br>String::String(const char *str) <br>{ <br>if ( str == NULL ) //strlen 在参数为NULL 时会抛异常才会有这步判断 <br>{ <br>m_data = new char[1] ; <br>m_data[0] = '/0' ; <br>} <br>else <br>{ <br>m_data = new char[strlen(str) + 1]; <br>strcpy(m_data,str); <br>} <br>} <br>String::String(const String &amp;another) <br>{ <br>m_data = new char[strlen(another.m_data) + 1]; <br>strcpy(m_data,other.m_data); <br>} <br>String&amp; String::operator =(const String &amp;rhs) <br>{ <br>if ( this == &amp;rhs) <br>return *this ; <br>delete []m_data; //删除原来的数据，新开一块内存 <br>m_data = new char[strlen(rhs.m_data) + 1]; <br>strcpy(m_data,rhs.m_data); <br>return *this ; <br>} <br>String::~String() <br>{ <br>delete []m_data ; <br>}</p> 
<p>13. .h头文件中的ifndef/define/endif 的作用？ <br>答：防止该头文件被重复引用。</p> 
<p>14. ＃i nclude 
 
   与＃i nclude "file.h"的区别？ 
  <br>答：前者是从Standard Library 的路径寻找和引用file.h，而后者是从当前工作路径 
  <br>搜寻并引用file.h。 
 </p> 
<p>15.在C++ 程序中调用被C 编译器编译后的函数，为什么要 <br>加extern “C”？ <br>首先，作为extern 是C/C++语言中表明函数和全局变量作用范围（可见性）的关键 <br>字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。 <br>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 <br>extern 声明。例如，如果模块B 欲引用该模块A 中定义的全局变量和函数时只需包含 <br>模块A 的头文件即可。这样，模块B 中调用模块A 中的函数时，在编译阶段，模块B <br>虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A 编译生成的目标代 <br>码中找到此函数 <br>extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按 <br>照C 语言方式编译和连接的,来看看C++中对类似C 的函数是怎样编译的： <br>作为一种面向对象的语言，C++支持函数重载，而过程式语言C 则不支持。函数被C++ <br>编译后在符号库中的名字与C 语言的不同。例如，假设某个函数的原型为： <br>void foo( int x, int y ); <br>该函数被C 编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像 <br>_foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的 <br>机制，生成的新名字称为“mangled name”）。 <br>_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种 <br>机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int <br>x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 <br>同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编 <br>写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进 <br>行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与 <br>用户程序中同名的全局变量名字不同。 <br>未加extern "C"声明时的连接方式 <br>假设在C++中，模块A 的头文件如下： <br>// 模块A 头文件moduleA.h <br>#ifndef MODULE_A_H <br>#define MODULE_A_H <br>int foo( int x, int y ); <br>#endif <br>在模块B 中引用该函数： <br>// 模块B 实现文件moduleB.cpp <br>＃i nclude "moduleA.h" <br>foo(2,3); <br>实际上，在连接阶段，连接器会从模块A 生成的目标文件moduleA.obj 中寻找 <br>_foo_int_int 这样的符号！ <br>加extern "C"声明后的编译和连接方式 <br>加extern "C"声明后，模块A 的头文件变为： <br>// 模块A 头文件moduleA.h <br>#ifndef MODULE_A_H <br>#define MODULE_A_H <br>extern "C" int foo( int x, int y ); <br>#endif <br>在模块B 的实现文件中仍然调用foo( 2,3 )，其结果是： <br>（1）模块A 编译生成foo 的目标代码时，没有对其名字进行特殊处理，采用了C 语言 <br>的方式； <br>（2）连接器在为模块B 的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号 <br>名_foo。 <br>如果在模块A 中函数声明了foo 为extern "C"类型，而模块B 中包含的是extern int <br>foo( int x, int y ) ，则模块B 找不到模块A 中的函数；反之亦然。 <br>所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特 <br>性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只 <br>停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可 <br>以更深入地理解许多问题）：实现C++与C 及其它语言的混合编程。 <br>明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用 <br>技巧： <br>extern "C"的惯用法 <br>（1）在C++中引用C 语言中的函数和变量，在包含C 语言头文件（假设为 <br>cExample.h）时，需进行下列处理： <br>extern "C" <br>{ <br>＃i nclude "cExample.h" <br>} <br>而在C 语言的头文件中，对其外部函数只能指定为extern 类型，C语言中不支持extern <br>"C"声明，在.c 文件中包含了extern "C"时会出现编译语法错误。 <br>C++引用C 函数例子工程中包含的三个文件的源代码如下： <br>/* c 语言头文件：cExample.h */ <br>#ifndef C_EXAMPLE_H <br>#define C_EXAMPLE_H <br>extern int add(int x,int y); <br>#endif <br>/* c 语言实现文件：cExample.c */ <br>＃i nclude "cExample.h" <br>int add( int x, int y ) <br>{ <br>return x + y; <br>} <br>// c++实现文件，调用add：cppFile.cpp <br>extern "C" <br>{ <br>＃i nclude "cExample.h" <br>} <br>int main(int argc, char* argv[]) <br>{ <br>add(2,3); <br>return 0; <br>} <br>如果C++调用一个C 语言编写的.DLL 时，当包括.DLL 的头文件或声明接口函数时， <br>应加extern "C" { }。 <br>（2）在C 中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"， <br>但是在C 语言中不能直接引用声明了extern "C"的该头文件，应该仅将C 文件中将 <br>C++中定义的extern "C"函数声明为extern 类型。 <br>C 引用C++函数例子工程中包含的三个文件的源代码如下： <br>//C++头文件cppExample.h <br>#ifndef CPP_EXAMPLE_H <br>#define CPP_EXAMPLE_H <br>extern "C" int add( int x, int y ); <br>#endif <br>//C++实现文件cppExample.cpp <br>＃i nclude "cppExample.h" <br>int add( int x, int y ) <br>{ <br>return x + y; <br>} <br>/* C 实现文件cFile.c <br>/* 这样会编译出错：＃i nclude "cExample.h" */ <br>extern int add( int x, int y ); <br>int main( int argc, char* argv[] ) <br>{ <br>add( 2, 3 ); <br>return 0; <br>} <br>15题目的解答请参考《C++中extern “C”含义深层探索》注解：</p> 
<p>16. 关联、聚合(Aggregation)以及组合(Composition) <br>的区别？ <br>涉及到UML 中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就 <br>是一种关联关系；聚合表示has-a 的关系，是一种相对松散的关系，聚合类不需要对 <br>被聚合类负责，如下图所示，用空的菱形表示聚合关系： <br>从实现的角度讲，聚合可以表示为: <br>class A {...} class B { A* a; .....} <br>而组合表示contains-a 的关系，关联性强于聚合：组合类与被组合类有相同的生命周 <br>期，组合类要对被组合类负责，采用实心的菱形表示组合关系： <br>实现的形式是: <br>class A{...} class B{ A a; ...} <br>参考文章：<a href="http://blog.csdn.net/wfwd/archive/2006/05/30/763753.aspx">http://blog.csdn.net/wfwd/archive/2006/05/30/763753.aspx</a> <br>http://blog.csdn.net/wfwd/archive/2006/05/30/763760.aspx</p> 
<p>17.面向对象的三个基本特征，并简单叙述之？ <br>1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, <br>protected,public) <br>2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额 <br>外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使 <br>用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=&gt;接 <br>口继承以及纯虚函数）构成了功能复用的两种方式。 <br>3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父 <br>对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句 <br>话：允许将子类类型的指针赋值给父类类型的指针。</p> 
<p>18. 重载（overload)和重写(overried，有的书也叫做“覆 <br>盖”）的区别？ <br>常考的题目。从定义上来说： <br>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或 <br>许参数类型不同，或许两者都不同）。 <br>重写：是指子类重新定义复类虚函数的方法。 <br>从实现原理上来说： <br>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就 <br>成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数： function <br>func(p:integer):integer;和function func(p:string):integer;。那么编译器做过 <br>修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在 <br>编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定）， <br>因此，重载和多态无关！ <br>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不 <br>同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定 <br>的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的 <br>（晚绑定）。</p> 
<p>19. 多态的作用？ <br>主要是两个：1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用； <br>2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性 <br>时的正确调用。</p> 
<p>20. Ado与Ado.net的相同与不同？ <br>除了“能够让应用程序处理存储于DBMS 中的数据“这一基本相似点外，两者没有太多 <br>共同之处。但是Ado 使用OLE DB 接口并基于微软的COM 技术，而ADO.NET 拥 <br>有自己的ADO.NET 接口并且基于微软的.NET 体系架构。众所周知.NET 体系不同于 <br>COM 体系，ADO.NET 接口也就完全不同于ADO 和OLE DB 接口，这也就是说 <br>ADO.NET 和ADO 是两种数据访问方式。ADO.net 提供对XML 的支持。</p> 
<p>21. New delete 与malloc free 的联系与区别? <br>答案：都是在堆(heap)上进行动态的内存操作。用malloc 函数需要指定内存分配的字 <br>节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的 <br>destructor，而free 不会调用对象的destructor.</p> 
<p>22. #define DOUBLE(x) x+x ，i = 5*DOUBLE(5)； <br>i 是多少？ <br>答案：i 为30。</p> 
<p>23. 有哪几种情况只能用intialization list 而不能用 <br>assignment? <br>答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</p> 
<p>24. C++是不是类型安全的？ <br>答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类 <br>型安全的。</p> 
<p>25. main 函数执行以前，还会执行什么代码？ <br>答案：全局对象的构造函数会在main 函数之前执行。</p> 
<p>26. 描述内存分配方式以及它们的区别? <br>1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的 <br>整个运行期间都存在。例如全局变量，static 变量。 <br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函 <br>数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 <br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意 <br>多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期 <br>由程序员决定，使用非常灵活，但问题也最多。</p> 
<p>27.struct 和class 的区别 <br>答案：struct 的成员默认是公有的，而类的成员默认是私有的。struct 和class 在 <br>其他方面是功能相当的。 <br>从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏 <br>封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢 <br>固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有 <br>很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的!）时，你也许应 <br>该使用struct 关键字，否则，你应该使用class 关键字。</p> 
<p>28.当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A) <br>的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。 <br>（Autodesk） <br>答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每 <br>一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。</p> 
<p>29. 在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel） <br>答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址*10H+通用寄存 <br>器内地址，就得到了真正要访问的地址。</p> 
<p>30. 比较C++中的4种类型转换方式？ <br>请参考：<a href="http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx%EF%BC%8C%E9%87%8D%E7%82%B9">http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx，重点</a> <br>是static_cast, dynamic_cast 和reinterpret_cast 的区别和应用。</p> 
<p>31.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。 <br>答案： <br>BOOL : if ( !a ) or if(a) <br>int : if ( a == 0) <br>float : const EXPRESSION EXP = 0.000001 <br>if ( a &lt; EXP &amp;&amp; a &gt;-EXP) <br>pointer : if ( a != NULL) or if(a == NULL)</p> 
<p>32.请说出const与#define 相比，有何优点？ <br>答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行 <br>类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会 <br>产生意料不到的错误。 <br>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p> 
<p>33.简述数组与指针的区别？ <br>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向 <br>任意类型的内存块。 <br>(1)修改内容上的差别 <br>char a[] = “hello”; <br>a[0] = ‘X’; <br>char *p = “world”; // 注意p 指向常量字符串 <br>p[0] = ‘X’; // 编译器不能发现该错误，运行时错误 <br>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的 <br>是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指 <br>针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时， <br>该数组自动退化为同类型的指针。 <br>char a[] = "hello world"; <br>char *p = a; <br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节 <br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节 <br>计算数组和指针的内存容量 <br>void Func(char a[100]) <br>{ <br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节 <br>}</p> 
<p>34.类成员函数的重载、覆盖和隐藏区别？ <br>答案： <br>a.成员函数被重载的特征： <br>（1）相同的范围（在同一个类中）； <br>（2）函数名字相同； <br>（3）参数不同； <br>（4）virtual 关键字可有可无。 <br>b.覆盖是指派生类函数覆盖基类函数，特征是： <br>（1）不同的范围（分别位于派生类与基类）； <br>（2）函数名字相同； <br>（3）参数相同； <br>（4）基类函数必须有virtual 关键字。 <br>c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： <br>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual <br>关键字，基类的函数将被隐藏（注意别与重载混淆）。 <br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual <br>关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</p> 
<p>35. There are two int variables: a and b, don’t use “if”, <br>“? :”, “switch”or other judgement statements, find out <br>the biggest one of the two numbers. <br>答案：( ( a + b ) + abs( a - b ) ) / 2</p> 
<p>36. 如何打印出当前源文件的文件名以及源文件的当前行号？ <br>答案： <br>cout &lt;&lt; __FILE__ ; <br>cout&lt;&lt;__LINE__ ; <br>__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由 <br>编译器定义的。</p> 
<p>37. main 主函数执行完毕后，是否可能会再执行一段代码，给出说 <br>明？ <br>答案：可以，可以用_onexit 注册一个函数，它会在main 之后执行int fn1(void), <br>fn2(void), fn3(void), fn4 (void); <br>void main( void ) <br>{ <br>String str("zhanglin"); <br>_onexit( fn1 ); <br>_onexit( fn2 ); <br>_onexit( fn3 ); <br>_onexit( fn4 ); <br>printf( "This is executed first./n" ); <br>} <br>int fn1() <br>{ <br>printf( "next./n" ); <br>return 0; <br>} <br>int fn2() <br>{ <br>printf( "executed " ); <br>return 0; <br>} <br>int fn3() <br>{ <br>printf( "is " ); <br>return 0; <br>} <br>int fn4() <br>{ <br>printf( "This " ); <br>return 0; <br>} <br>The _onexit function is passed the address of a function (func) to be called <br>when the program terminates normally. Successive calls to _onexit create a <br>register of functions that are executed in LIFO (last-in-first-out) order. The <br>functions passed to _onexit cannot take parameters.</p> 
<p>38. 如何判断一段程序是由C 编译程序还是由C++编译程序编译的？ <br>答案： <br>#ifdef __cplusplus <br>cout&lt;&lt;"c++"; <br>#else <br>cout&lt;&lt;"c"; <br>#endif</p> 
<p>39.文件中有一组整数，要求排序后输出到另一个文件中 <br>答案： <br>＃i nclude 
  
  <br>＃i nclude 
   
   <br>using namespace std; 
   <br>void Order(vector 
   
     &amp; data) //bubble sort 
    <br>{ 
    <br>int count = data.size() ; 
    <br>int tag = false ; // 设置是否需要继续冒泡的标志位 
    <br>for ( int i = 0 ; i &lt; count ; i++) 
    <br>{ 
    <br>for ( int j = 0 ; j &lt; count - i - 1 ; j++) 
    <br>{ 
    <br>if ( data[j] &gt; data[j+1]) 
    <br>{ 
    <br>tag = true ; 
    <br>int temp = data[j] ; 
    <br>data[j] = data[j+1] ; 
    <br>data[j+1] = temp ; 
    <br>} 
    <br>} 
    <br>if ( !tag ) 
    <br>break ; 
    <br>} 
    <br>} 
    <br>void main( void ) 
    <br>{ 
    <br>vector 
    
      data; 
     <br>ifstream in("c://data.txt"); 
     <br>if ( !in) 
     <br>{ 
     <br>cout&lt;&lt;"file error!"; 
     <br>exit(1); 
     <br>} 
     <br>int temp; 
     <br>while (!in.eof()) 
     <br>{ 
     <br>in&gt;&gt;temp; 
     <br>data.push_back(temp); 
     <br>} 
     <br>in.close(); //关闭输入文件流 
     <br>Order(data); 
     <br>ofstream out("c://result.txt"); 
     <br>if ( !out) 
     <br>{ 
     <br>cout&lt;&lt;"file error!"; 
     <br>exit(1); 
     <br>} 
     <br>for ( i = 0 ; i &lt; data.size() ; i++) 
     <br>out&lt; 
     
       &lt;&lt;" "; 
      <br>out.close(); //关闭输出文件流 
      <br>} 
      
     
    
   
 </p> 
<p>40. 链表题：一个链表的结点结构 <br>struct Node <br>{ <br>int data ; <br>Node *next ; <br>}; <br>typedef struct Node Node ; <br>(1)已知链表的头结点head,写一个函数把这个链表逆序( Intel) <br>Node * ReverseList(Node *head) //链表逆序 <br>{ <br>if ( head == NULL || head-&gt;next == NULL ) <br>return head; <br>Node *p1 = head ; <br>Node *p2 = p1-&gt;next ; <br>Node *p3 = p2-&gt;next ; <br>p1-&gt;next = NULL ; <br>while ( p3 != NULL ) <br>{ <br>p2-&gt;next = p1 ; <br>p1 = p2 ; <br>p2 = p3 ; <br>p3 = p3-&gt;next ; <br>} <br>p2-&gt;next = p1 ; <br>head = p2 ; <br>return head ; <br>} <br>(2)已知两个链表head1 和head2 各自有序，请把它们合并成一个链表依然有序。(保 <br>留所有结点，即便大小相同） <br>Node * Merge(Node *head1 , Node *head2) <br>{ <br>if ( head1 == NULL) <br>return head2 ; <br>if ( head2 == NULL) <br>return head1 ; <br>Node *head = NULL ; <br>Node *p1 = NULL; <br>Node *p2 = NULL; <br>if ( head1-&gt;data &lt; head2-&gt;data ) <br>{ <br>head = head1 ; <br>p1 = head1-&gt;next; <br>p2 = head2 ; <br>} <br>else <br>{ <br>head = head2 ; <br>p2 = head2-&gt;next ; <br>p1 = head1 ; <br>} <br>Node *pcurrent = head ; <br>while ( p1 != NULL &amp;&amp; p2 != NULL) <br>{ <br>if ( p1-&gt;data &lt;= p2-&gt;data ) <br>{ <br>pcurrent-&gt;next = p1 ; <br>pcurrent = p1 ; <br>21 <br>p1 = p1-&gt;next ; <br>} <br>else <br>{ <br>pcurrent-&gt;next = p2 ; <br>pcurrent = p2 ; <br>p2 = p2-&gt;next ; <br>} <br>} <br>if ( p1 != NULL ) <br>pcurrent-&gt;next = p1 ; <br>if ( p2 != NULL ) <br>pcurrent-&gt;next = p2 ; <br>return head ; <br>} <br>(3)已知两个链表head1 和head2 各自有序，请把它们合并成一个链表依然有序， <br>这次要求用递归方法进行。(Autodesk) <br>答案： <br>Node * MergeRecursive(Node *head1 , Node *head2) <br>{ <br>if ( head1 == NULL ) <br>return head2 ; <br>if ( head2 == NULL) <br>return head1 ; <br>Node *head = NULL ; <br>if ( head1-&gt;data &lt; head2-&gt;data ) <br>{ <br>head = head1 ; <br>head-&gt;next = MergeRecursive(head1-&gt;next,head2); <br>} <br>else <br>{ <br>head = head2 ; <br>head-&gt;next = MergeRecursive(head1,head2-&gt;next); <br>} <br>return head ; <br>}</p> 
<p>41. 分析一下这段程序的输出(Autodesk) <br>class B <br>{ <br>public: <br>B() <br>{ <br>cout&lt;&lt;"default constructor"&lt; 
  
  <br>} 
  <br>~B() 
  <br>{ 
  <br>cout&lt;&lt;"destructed"&lt; 
   
   <br>} 
   <br>B(int i):data(i) //B(int) works as a converter ( int -&gt; instance of B) 
   <br>{ 
   <br>cout&lt;&lt;"constructed by parameter " &lt;&lt; data &lt; 
    
    <br>} 
    <br>private: 
    <br>int data; 
    <br>}; 
    <br>B Play( B b) 
    <br>{ 
    <br>return b ; 
    <br>} 
    <br>(1) results: 
    <br>int main(int argc, char* argv[]) constructed by parameter 5 
    <br>{ destructed B(5)形参析构 
    <br>B t1 = Play(5); B t2 = Play(t1); destructed t1 形参析构 
    <br>return 0; destructed t2 注意顺序！ 
    <br>} destructed t1 
    <br>(2) results: 
    <br>int main(int argc, char* argv[]) constructed by parameter 5 
    <br>{ destructed B(5)形参析构 
    <br>B t1 = Play(5); B t2 = Play(10); constructed by parameter 10 
    <br>return 0; destructed B(10)形参析构 
    <br>} destructed t2 注意顺序！ 
    <br>destructed t1 
    
   
 </p> 
<p>42. 写一个函数找出一个整数数组中，第二大的数（microsoft） <br>答案： <br>const int MINNUMBER = -32767 ; <br>int find_sec_max( int data[] , int count) <br>{ <br>int maxnumber = data[0] ; <br>int sec_max = MINNUMBER ; <br>for ( int i = 1 ; i &lt; count ; i++) <br>{ <br>if ( data[i] &gt; maxnumber ) <br>{ <br>sec_max = maxnumber ; <br>maxnumber = data[i] ; <br>} <br>else <br>{ <br>if ( data[i] &gt; sec_max ) <br>sec_max = data[i] ; <br>} <br>} <br>return sec_max ; <br>}</p> 
<p>43. 写一个在一个字符串(n)中寻找一个子串(m)第一个位置的函数。 <br>KMP 算法效率最好，时间复杂度是Ｏ(n+m)。</p> 
<p>44. 多重继承的内存分配问题： <br>比如有class A : public class B, public class C {} <br>那么A 的内存结构大致是怎么样的？ <br>这个是compiler-dependent 的, 不同的实现其细节可能不同。 <br>如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。 <br>可以参考《深入探索C++对象模型》，或者： <br>http://blog.csdn.net/wfwd/archive/2006/05/30/763797.aspx</p> 
<p>45. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用 <br>两个额外指针） <br>struct node { char val; node* next;} <br>bool check(const node* head) {} //return false : 无环；true: 有环 <br>一种O（n）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果 <br>有环的话两者必然重合，反之亦然）： <br>bool check(const node* head) <br>{ <br>if(head==NULL) return false; <br>node *low=head, *fast=head-&gt;next; <br>while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL) <br>{ <br>low=low-&gt;next; <br>fast=fast-&gt;next-&gt;next; <br>if(low==fast) return true; <br>} <br>return false; <br>}</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce308097e95e8993b0741f74b2e999f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ProE野火4.0&#43;vs2005 Pro/Toolkit 二次开发测试详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fdf8eb65c48a5903ab3a40d5bde0139/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>