<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ官方案例学习记录 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ官方案例学习记录" />
<meta property="og:description" content="官方文档：RabbitMQ教程 — RabbitMQ (rabbitmq.com)
一、安装RabbitMQ服务 直接使用docker在服务器上安装
docker run -it -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management 安装完成后，访问15672端口，默认用户名和密码都是 guest，即可进入 二、hello world——梦开始的地方 1. 介绍 RabbitMQ 是一个消息代理：它接受并转发消息。 你可以把它想象成一个邮局：当你把你想要邮寄的邮件放在邮箱里时， 您可以确定，邮递员最终会将邮件递送给您的收件人。 在这个类比中，RabbitMQ是一个邮政信箱，一个邮局和一个信件载体。RabbitMQ和邮局的主要区别在于它不处理纸张， 相反，它接受、存储和转发数据的二进制 blob - 消息。
2. 一些术语 生产者：消息的发送方
队列queue：本质上是一个大型的消息缓冲区
消费者：消息的使用方
Channel 频道：理解为操作消息队列的 client（比如 jdbcClient、redisClient），提供了和消息队列 server 建立通信的传输方法（为了复用连接，提高传输效率）。程序通过 channel 操作 rabbitmq（收发消息）
3. 编写代码 用 Java 编写两个程序;一个发送单个消息的生产者，一个接收的使用者并将消息打印出来。
（1）消息生产者： 编码过程：
先创建连接工厂，然后通过工厂创建连接，再通过连接创建channel。通过channel来绑定队列或者交换机，再用channel来生产或者消费消息。
channel.basicPublish(&#34;&#34;,QUEUE_NAME,null,msg.getBytes());
对于这行代码，可以看到消息是根据QUEUE_NAME路由到对应的队列。
import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; import com.rabbitmq.client.Channel; public class MQProducer { //设置队列名 private final static String QUEUE_NAME = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/57f54c93823b2fb1e151b0f5baf144f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-20T22:38:02+08:00" />
<meta property="article:modified_time" content="2023-10-20T22:38:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ官方案例学习记录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>官方文档</strong>：<a href="https://www.rabbitmq.com/getstarted.html" rel="nofollow" title="RabbitMQ教程 — RabbitMQ (rabbitmq.com)">RabbitMQ教程 — RabbitMQ (rabbitmq.com)</a></p> 
<h2 style="background-color:transparent;">一、安装RabbitMQ服务</h2> 
<p>直接使用docker在服务器上安装</p> 
<pre><code class="language-java">docker run -it -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management</code></pre> 
<p>安装完成后，访问15672端口，默认用户名和密码都是 guest，即可进入 </p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/b8/be/RrbVla25_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1f/2f/LVhEEvuj_o.png" width="1200"></p> 
<h2 style="background-color:transparent;">二、hello world——梦开始的地方</h2> 
<h3>1. 介绍</h3> 
<p>        RabbitMQ 是一个消息代理：它<strong>接受并转发消息</strong>。 你可以把它想象成一个邮局：当你把你想要邮寄的邮件放在邮箱里时， 您可以确定，邮递员最终会将邮件递送给您的收件人。 在这个类比中，RabbitMQ是一个邮政信箱，一个邮局和一个信件载体。RabbitMQ和邮局的主要区别在于它不处理纸张， 相反，它接受、存储和转发数据的二进制 blob <em>- 消息</em>。</p> 
<h3>2. 一些术语</h3> 
<p>生产者：消息的发送方</p> 
<p>队列queue：本质上是一个大型的消息缓冲区</p> 
<p>消费者：消息的使用方</p> 
<p>Channel 频道：理解为操作消息队列的 client（比如 jdbcClient、redisClient），提供了和消息队列 server 建立通信的传输方法（为了复用连接，提高传输效率）。程序通过 channel 操作 rabbitmq（收发消息）</p> 
<h3 style="background-color:transparent;">3. 编写代码</h3> 
<p>用 Java 编写两个程序;一个发送单个消息的生产者，一个接收的使用者并将消息打印出来。</p> 
<p class="img-center"><img alt="" height="109" src="https://images2.imgbox.com/54/e0/JaBLGj9Y_o.png" width="439"></p> 
<h4 style="background-color:transparent;">（1）消息生产者：</h4> 
<p>编码过程：</p> 
<p><span style="background-color:#a2e043;">先创建连接工厂，然后通过工厂创建连接，再通过连接创建channel。通过channel来绑定队列或者交换机，再用channel来生产或者消费消息。</span></p> 
<p>channel.basicPublish("",<span style="background-color:#ffd900;">QUEUE_NAME</span>,null,msg.getBytes());</p> 
<p>对于这行代码，可以看到消息是根据QUEUE_NAME路由到对应的队列。</p> 
<pre><code class="language-java">import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
public class MQProducer {

    //设置队列名
    private final static String QUEUE_NAME = "hello-zy";
    public static void main(String[] argv) throws Exception {
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置连接的服务器IP和端口号
        factory.setHost("123.249.112.12");
        factory.setPort(5672);
        //创建一个连接和通道，这里使用 try-with-resources语句，
        // 因为Connection和Channel都实现了java.lang.AutoCloseable，不需要在代码中再显式的关闭他们
        try(Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) {

        /*
        创建队列 channel.queueDeclare()用于声明一个队列
        queue（队列名称）：指定要声明的队列的名称。
        durable（持久化）：指定队列是否是持久化的。当 RabbitMQ 重新启动时，持久化的队列将被保留下来。如果将该参数设置为 true，则队列将被持久化；如果设置为 false，则队列不会被持久化。注意，这里指的是队列本身的持久化，而不是队列中的消息。
        exclusive（排他性）：指定队列是否是排他的。如果将该参数设置为 true，则该队列只能被当前连接的消费者使用，并且在连接关闭时会自动删除该队列。如果设置为 false，则队列可供多个消费者使用。
        autoDelete（自动删除）：指定队列在不再被使用时是否自动删除。如果将该参数设置为 true，则当队列不再被消费者使用时，将自动删除该队列。如果设置为 false，则队列不会自动删除。
        arguments（参数）：指定队列的其他属性和参数，以键值对的形式提供。
        */
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //发送消息
            String msg = "hello,world! RabbitMQ!";
            //channel.basicPublish("", QUEUE_NAME, null, msg.getBytes())
            // 这行代码的作用是将 msg 消息发布到默认交换器（空字符串）并使用QUEUE_NAME作为路由键，
            // 消息的属性设置为默认值，消息的内容为 msg.getBytes()，即将 msg 转换为字节数组后发送。
            channel.basicPublish("",QUEUE_NAME,null,msg.getBytes());
            System.out.println(" 生产者发送消息：'" + msg + "'");
        }
    }
}</code></pre> 
<p> 然后运行这个生产者代码，去网页端查看：</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/06/a7/jV3aR3NL_o.png" width="1200"></p> 
<h4>（2）消息消费者：</h4> 
<pre><code class="language-java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class MQConsumer {

    //声明队列 和消息发送方保持一致
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory factory = new ConnectionFactory();
        //设置rabbitMQ服务端ip
        factory.setHost("123.249.112.12");
        //这里不用try-with-resources 因为消费方需要一致保持监听，不要关闭
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(" 等待接收消息，退出请按 CTRL+C");

        //创建了一个消费者对象并实现了 handleDelivery() 方法作为回调方法。当消费者收到消息时，将自动执行该方法。
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" 消费了消息：'" + message + "'");
        };
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; { });
    }
}</code></pre> 
<p>去网页端查看消息是否被消费，可以看到多了一个消费者，并且消息已经没了。 </p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/2d/92/l9wyP1Kr_o.png" width="1200"></p> 
<h2 style="background-color:transparent;">三、工作队列 WorkQueue</h2> 
<p>        工作队列（又名：<em>任务队列</em>）背后的主要思想是避免立即执行资源密集型任务，必须等待它要完成。相反，我们将任务安排在以后完成。我们将<em>任务</em>封装为消息并将其发送到队列。正在运行的工作进程 在后台将弹出任务并最终执行工作。当您运行许多工作线程时，任务将在它们之间共享。</p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/96/dd/MBlT22eB_o.png" width="448"></p> 
<p>WorkQueue的模型跟前面第一个案例Hello，World！的模型，最明显的区别其实就是，第一个案例他只有一个消费者。我们知道RabbitMQ他的消息是阅完即焚，即消费者一旦接收，这个消息直接就从Queue中被弹出了。<br> 而现在这个案例，他有两个消费者（画两个只是方便，他当然也可以有3个、4个），他的消息应该是通过某种算法做负载均衡送到不同的消费者，让消费者进行处理，让消息不至于处理不过来，从而导致滞留在Queue中的消息被弹出。</p> 
<p>思路如下：<br> 1、我们先让Publish服务每秒发布50条消息到 simple.queue，来演示消息的频繁发送。<br> 2、在Consumer服务中定义两个消费者，来监听我们的 simple.queue队列。<br> 3、消费者1每秒处理40条消息，消费者2每秒处理30条消息。</p> 
<h3>1. 循环调度</h3> 
<h4>（1）生产者：</h4> 
<p>生成50条消息：</p> 
<pre><code class="language-java">public class Send {

    //设置队列名
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] argv) throws Exception {
        //创建连接
        ConnectionFactory factory = new ConnectionFactory();
        //设置连接的服务器IP和端口号
        factory.setHost("123.249.112.12");
        factory.setPort(5672);
        //创建一个通道，这里使用 try-with-resources语句，
        // 因为Connection和Channel都实现了java.lang.AutoCloseable，不需要在代码中再显式的关闭他们
        try(Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) {

            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //发送消息

            for(int i = 1; i &lt;= 50; i++) {
                String msg = "hello, I am";
                msg = msg + i;
                channel.basicPublish("",QUEUE_NAME,null,msg.getBytes());
                Thread.sleep(200);
                System.out.println(" 生产者发送消息：'" + msg + "'");
            }
        }
    }
}
</code></pre> 
<h4>（2）消费者1和消费者2</h4> 
<pre><code class="language-java">public class Worker_01 {

    //声明队列 和消息发送方保持一致
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory factory = new ConnectionFactory();
        //设置rabbitMQ服务端ip
        factory.setHost("123.249.112.12");
        //这里不用try-with-resources 因为消费方需要一致保持监听，不要关闭
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(" 等待接收消息，退出请按 CTRL+C");

        //创建了一个消费者对象并实现了 handleDelivery() 方法作为回调方法。当消费者收到消息时，将自动执行该方法。
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" Worker_01消费了消息：'" + message + "'");
        };
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; { });
    }
}

public class Worker_02 {

    //声明队列 和消息发送方保持一致
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory factory = new ConnectionFactory();
        //设置rabbitMQ服务端ip
        factory.setHost("123.249.112.12");
        //这里不用try-with-resources 因为消费方需要一致保持监听，不要关闭
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(" 等待接收消息，退出请按 CTRL+C");

        //创建了一个消费者对象并实现了 handleDelivery() 方法作为回调方法。当消费者收到消息时，将自动执行该方法。
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" Worker_02消费了消息：'" + message + "'");
        };
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; { });
    }
}
</code></pre> 
<p>启动两个消费者，然后开始生产消息，控制台打印如下：</p> 
<p> 可以看到是交替消费的：<img alt="" height="360" src="https://images2.imgbox.com/30/74/GqXvrIdV_o.png" width="1188"></p> 
<h3>2. 消息确认</h3> 
<p>        在上面的代码中，一旦消息传递给消费者，就会立即被删除。如果在消费过程中，消费者宕机，消息没消费成功，但是因为已经投递出去了，消息从队列删掉。就会出现：消息未消费，且丢失的问题。对于这种情况，我们希望没消费成功的消息，转交给其他的消费者消费。</p> 
<p>        为了确保消息永远不会丢失，RabbitMQ 支持<a href="https://www.rabbitmq.com/confirms.html" rel="nofollow" title="消息确认">消息确认</a>。确认由消费者告诉 RabbitMQ 已收到特定消息，并处理，RabbitMQ可以自由删除它。</p> 
<p>        如果消费者没有发送确认消息，rabbitMQ可以知道消息没有消费成功，并将重新排队。</p> 
<p>        在消费者返回确认消息时强制实施超时（默认为 30 分钟）。 这有助于检测从不确认交付的错误（卡住）消费者。 可以按照<a href="https://www.rabbitmq.com/consumers.html#acknowledgement-timeout" rel="nofollow" title="传递确认超时">传递确认超时</a>中所述增加此超时。</p> 
<p>        默认情况下，<a href="https://www.rabbitmq.com/confirms.html" rel="nofollow" title="手动消息确认">手动消息确认</a>处于打开状态。在上一个 示例，我们通过 autoAck=true 标志明确关闭了它们。是时候将此标志设置为 false ，来使消费者发送确认消息。</p> 
<h4>（1）消费者</h4> 
<p>生产者还是不变，生成10条消息到队列中：</p> 
<p>创建消费者，启动手动确认：</p> 
<pre><code class="language-java">public class Consumer {
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");
        factory.setPort(5672);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
            
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            
            // 将autoAck参数设置为false，关闭自动消息确认
            /*
            * new DefaultConsumer(channel) { ... }：这是一个匿名内部类，用于定义消息处理的逻辑。
            * 它继承自DefaultConsumer，并覆盖了 handleDelivery 方法，以自定义消息的处理方式。
            * */
        channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {

            /*handleDelivery 方法：这是 DefaultConsumer 类中的方法，用于处理从队列中接收的消息。
              consumerTag：标识消费者的标签。
              envelope：包含与消息相关的元数据，如交付标签、交付模式等。
              properties：包含消息的属性，如消息的头部信息。
              body：消息的内容，以字节数组形式提供。
            */
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String message = new String(body, "UTF-8");
                System.out.println("消费者接收消息: '" + message + "'");
                    
                // 在消息处理成功后，发送确认消息
                channel.basicAck(envelope.getDeliveryTag(), false);
                System.out.println("确认收到了消息："+message);
            }
        });
    }
}</code></pre> 
<p>启动消费者：</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/48/b3/aIXFkuDz_o.png" width="303"></p> 
<h4>（2）验证未成功消费情况</h4> 
<p>先生产6条消息到队列：</p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/27/59/Wapw7LN0_o.png" width="1200"></p> 
<p>简单修改一下消费者代码，在中间添加判断逻辑，当碰到消息5的时候，退出消费者：</p> 
<pre><code class="language-java">public class Consumer1 {
    private final static String QUEUE_NAME = "hello-zy";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
            
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        try {
            // 将autoAck参数设置为false，关闭自动消息确认
            channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {
                @Override
                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)
                        throws IOException {
                    String message = new String(body, "UTF-8");
                    System.out.println("消费者接收消息: '" + message + "'");
                    
                    // 模拟某个条件，例如消息处理成功
                    if (!message.contains("5")) {
                        // 在消息处理成功后，发送确认消息
                        channel.basicAck(envelope.getDeliveryTag(), false);
                        System.out.println("确认收到了消息：" + message);
                    }
                    
                    // 模拟消费者退出
                    if (message.contains("5")) {
                        throw new RuntimeException("Consumer exiting...");
                    }
                }
            });
        } catch (RuntimeException e) {
            // 当消费者退出时，捕获异常
            System.out.println("Consumer exited.");
        }
    }
}
</code></pre> 
<p> <img alt="" height="242" src="https://images2.imgbox.com/66/6c/PI0mM8dx_o.png" width="435"></p> 
<p>可以看到，当消费者消费到第五条消息后，因为抛出了异常，所以后面的消息都未消费成功，所以会把第五条消息和第六条消息再放回消息队列，查看消息队列，可以看到还有两条消息在队列中：</p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/d8/f9/JclU3wUn_o.png" width="1200"></p> 
<p>如果把参数改成true，也就是自动确认：<strong>这就会导致未消费的消息丢失</strong></p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/41/2f/ORQEOpbo_o.png" width="1116"> </p> 
<h3>3. 消息持久性</h3> 
<p>我们已经保证了消息未消费的情况下不会丢失，但是如果RabbitMQ服务器宕机，消息还是会丢失。这就涉及到一个消息持久化的问题。</p> 
<p>需要做两件事来确保 消息不会丢失：我们需要将队列和消息都标记为durable。 （重新定义一个队列）</p> 
<p><img alt="" height="65" src="https://images2.imgbox.com/aa/f2/Hoh7CVKD_o.png" width="445"></p> 
<p><img alt="" height="93" src="https://images2.imgbox.com/33/ff/ThQPpkqE_o.png" width="1106"></p> 
<p>此时，我们确信durable_queue队列不会丢失 即使 RabbitMQ 重新启动。现在我们需要将我们的消息标记为持久 - 通过设置消息属性（实现基本属性） 到值PERSISTENT_TEXT_PLAIN。 </p> 
<p> <img alt="" height="228" src="https://images2.imgbox.com/a5/14/s6bA3uJj_o.png" width="1200"></p> 
<p>如果不设置未持久性，重启docker的rabbitmq容器，队列消息就丢了，设置durable=true后， 即使重启docker容器，队列和消息都不会丢失。</p> 
<h2>四、发布/订阅模式</h2> 
<p>        在前面，都是一条消息由一个消费者消费。如果一条消息需要被多个消费者消费，那么就需要引入发布/订阅模式。</p> 
<h3 style="background-color:transparent;">1. 交换机</h3> 
<p>关于<strong><span style="background-color:#a2e043;">交换机</span></strong>的概念（）：</p> 
<blockquote> 
 <p></p> 
 <p>一个生产者给 多个 队列发消息，1 个生产者对多个队列。<br><strong>交换机的作用：</strong>提供消息转发功能，类似于网络路由器<br><strong>要解决的问题：</strong>怎么把消息转发到不同的队列上，好让消费者从不同的队列消费。</p> 
</blockquote> 
<p>交换机有多种类别：fanout、direct, topic, headers</p> 
<h4><strong>fanout（扇出）</strong></h4> 
<p>扇出、广播<br> 特点：消息会被转发到所有绑定到该交换机的队列<br> 场景：很<span style="background-color:#a2e043;">适用于发布订阅的场景</span>。比如写日志，可以多个系统间共享</p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/5d/19/L9oARWxi_o.png" width="386"></p> 
<p></p> 
<h4 style="background-color:transparent;">Direct 直接</h4> 
<p>绑定：可以让交换机和队列进行关联，可以指定让交互机把什么样的消息发送给哪个队列（类似于计算机网络中，两个路由器，或者网络设备相互连接，也可以理解为网线）<br> routingKey：路由键，控制消息要转发给哪个队列的（IP 地址） </p> 
<p><strong>特点：</strong><span style="background-color:#a2e043;">消息会根据路由键转发到指定的队列</span><br><strong>场景：</strong>特定的消息只交给特定的系统（程序）来处理<br> 绑定关系：完全匹配字符串</p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/ac/75/jTUc6edj_o.png" width="472"></p> 
<p>比如发日志的场景，希望用独立的程序来处理不同级别的日志，比如 C1 系统处理 error 日志，C2 系统处理其他级别的日志</p> 
<p> </p> 
<p class="img-center"><img alt="" height="198" src="https://images2.imgbox.com/57/c5/51qnUi41_o.png" width="483"></p> 
<h4> topic 交换机</h4> 
<p>特点：消息会根据一个 模糊的 路由键转发到指定的队列<br> 场景：特定的一类消息可以交给特定的一类系统（程序）来处理<br> 绑定关系：可以模糊匹配多个绑定<br> ●*：匹配一个单词，比如 *.orange，那么 a.orange、b.orange 都能匹配<br> ●#：匹配 0 个或多个单词，比如 a.#，那么 a.a、a.b、a.a.a 都能匹配<br><br> 注意，这里的匹配和 MySQL 的like 的 % 不一样，只能按照单词来匹配，每个 '.' 分隔单词，如果是 '#.'，其实可以忽略，匹配 0 个词也 ok</p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/00/fa/kzD4yxPM_o.png" width="524"></p> 
<h4>Headers 交换机 </h4> 
<p>类似主题和直接交换机，可以根据 headers 中的内容来指定发送到哪个队列。使用消息头headers来路由消息。</p> 
<h3 style="background-color:transparent;"> 2. 使用fanout交换机来实现发布/订阅</h3> 
<h4>（1）生产者</h4> 
<pre><code class="language-java">public class LogProducer {
    private final static String EXCHANGE_NAME = "logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");
        factory.setPort(5672);

        try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) {
            //声明交换机类型为：FANOUT
            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);

            for (int i = 1; i &lt;= 5; i++) {
                String message = "Log message " + i;
                //消息发到交换机中，而不是像之前点对点那样直接发到消息队列中
                channel.basicPublish(EXCHANGE_NAME, "", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
                System.out.println("生产者发送日志: " + message);
            }
        }
    }
}</code></pre> 
<p>查看交换机列表，可以看到新增了一个名为logs的交换机，类型为 fanout：</p> 
<h4><img alt="" height="982" src="https://images2.imgbox.com/f6/d3/hZS8pxR8_o.png" width="1200"> （2）消费者</h4> 
<p>创建两个消费者，都绑定一个交换机，名字为log</p> 
<pre><code class="language-java">public class LogConsumer {
    private final static String EXCHANGE_NAME = "logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");


        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        
        // 创建一个临时队列
        String queueName = channel.queueDeclare().getQueue();
        
        // 将队列绑定到交换器
        channel.queueBind(queueName, EXCHANGE_NAME, "");

        System.out.println("等待接收日志消息...");

        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("消费者1接收消息: '" + message + "'");
        };

        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; { });
    }
}
public class LogConsumer2 {
    private final static String EXCHANGE_NAME = "logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");


        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        
        // 创建一个临时队列
        String queueName = channel.queueDeclare().getQueue();
        
        // 将队列绑定到交换器
        channel.queueBind(queueName, EXCHANGE_NAME, "");

        System.out.println("等待接收日志消息...");

        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("消费者2接收消息: '" + message + "'");
        };

        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {
        });
    }
}
</code></pre> 
<p><img alt="" height="365" src="https://images2.imgbox.com/10/50/ZwbfD7ai_o.png" width="1200"> 启动两个消费者，然后启动生产者发送消息，可以看到两个消费者都消费了消息：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/39/5c/G60CkG9H_o.png" width="1056"></p> 
<h2>五、路由</h2> 
<p>在上面的例子中，我们实现了一个简单的日志记录系统。能够向多个消费者广播消息。</p> 
<p>下面要增加一个新的功能：</p> 
<p>        例如，我们将只能将关键错误消息定向到 日志文件（以节省磁盘空间），同时仍然能够打印所有控制台上的日志消息。</p> 
<h3>1. 绑定队列和交换机</h3> 
<p>之前是这样绑定的：第三个参数就是路由键</p> 
<blockquote> 
 <p>channel.queueBind(queueName, EXCHANGE_NAME, "");</p> 
</blockquote> 
<p>绑定是交换和队列之间的关系。</p> 
<p>        绑定可以采用额外的路由键参数。为了避免 与basic_publish参数混淆，我们将它称为绑定键。绑定键的含义取决于交换类型。</p> 
<blockquote> 
 <p>channel.queueBind(queueName, EXCHANGE_NAME, "black");</p> 
</blockquote> 
<h3>2. 使用direct交换机绑定</h3> 
<h4>（1）生产者</h4> 
<p>模拟三条不同的消息，指定消息1的路由键为orange，消息2的路由键为black，消息3的路由键为green。</p> 
<pre><code class="language-java">public class LogProducer {
    private final static String EXCHANGE_NAME = "direct_logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");
        factory.setPort(5672);

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {
            //声明交换机类型为 direct
            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);

            String message1 = "Message with routing key orange";
            String message2 = "Message with routing key black";
            String message3 = "Message with routing key green";

            // 发布消息到交换器，并指定不同的路由键
            channel.basicPublish(EXCHANGE_NAME, "orange", null, message1.getBytes());
            channel.basicPublish(EXCHANGE_NAME, "black", null, message2.getBytes());
            channel.basicPublish(EXCHANGE_NAME, "green", null, message3.getBytes());

            System.out.println("生产者发送消息完成.");
        }
    }
}</code></pre> 
<h4>（2）消费者</h4> 
<p>创建两个消费者</p> 
<p>消费者1和消费者2都绑定对应的交换机，其中消费者1对应路由键orange，消费者2对应路由键black和orange。</p> 
<pre><code class="language-java">public class LogConsumer1 {
    private final static String EXCHANGE_NAME = "direct_logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");
        factory.setPort(5672);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        
        // 创建一个临时队列
        String queueName = channel.queueDeclare().getQueue();
        
        // 绑定队列到交换器，指定路由键为 "orange"
        channel.queueBind(queueName, EXCHANGE_NAME, "orange");

        System.out.println("等待接收 orange 消息...");

        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("消费者1接收消息: '" + message + "'");
        };

        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {
        });
    }
}
public class LogConsumer2 {
    private final static String EXCHANGE_NAME = "direct_logs";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("123.249.112.12");
        factory.setPort(5672);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        
        // 创建一个临时队列
        String queueName = channel.queueDeclare().getQueue();
        
        // 绑定队列到交换器，指定路由键为 "black" 和 "green"
        channel.queueBind(queueName, EXCHANGE_NAME, "black");
        channel.queueBind(queueName, EXCHANGE_NAME, "green");

        System.out.println("等待接收 black 和 green 消息...");

        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("消费者2接收消息: '" + message + "'");
        };

        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {
        });
    }
}
</code></pre> 
<p><img alt="" height="348" src="https://images2.imgbox.com/c8/52/wciEyVfS_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3bd237fd47c0d4cbcf81fc8f82cfde4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数字信号处理---离散时间信号与系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8402177a695fcbbecf16f21d49b7783/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C#】抽象类和接口的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>