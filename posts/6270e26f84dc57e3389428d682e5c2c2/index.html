<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>益智游戏日历拼图解法：搜索&#43;回溯 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="益智游戏日历拼图解法：搜索&#43;回溯" />
<meta property="og:description" content="这个是某夕夕上最近很火的一款益智小游戏，版面设计看起来也很nice！那么类似这种游戏对于程序员的正确打开方式还是写个程序解决，并没有什么益智不益智，因为说实话拼这个东西还是太费力了。
那么怎么解决这个问题呢？很明显先把盘子还有各个小块的形状记录起来，盘子用一个全局数组，而小块则用一个结构体node，还要存储长宽，并且有旋转等函数，然后采用深度优先搜索算法（DFS，这是一个很基础的算法，还没了解的应该先了解），注意回溯，然后就能罗列所有的情况，这个（右边的）差不多是7*7大小的，并且总共有8个小块，那么每个小块大概有7*7*8种放置的方式（加上旋转和翻转，一开始没想到翻转搞多了很多时间），因此计算量（粗略的说法，放置一块的意思，包括判断、更新数组等等操作）就最多是(7*7*8)^8次（大概五万亿亿次，粗略算1亿次1秒，但是加上很多不可能的情况（判断一下就过了）还有剪枝（去掉了极多的情况），还有这个是最大估计，其实远小于五万亿秒，本人跑了半个多小时，虽说还是不少）。再加上适当判断，排序，存文件等等，我们就能愉快的完成任务了！话不多说，代码如下：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;fstream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; const int ma[12] = { 31,29,31,30,31,30,31,31,30,31,30,31 }; int day_num = 0; int pan[10][10]; struct node { node() { memset(arr, 0, sizeof arr); } int n, m; int c; bool st[2][4];//哪几次旋转是没用的 bool arr[10][10]; void rotate()//有些可能转了等于没转，所以要四种状态都存起来 { bool tmp[10][10]; for (int i = 0; i &lt; n; i&#43;&#43;) { for (int j = 0; j &lt; m; j&#43;&#43;) { tmp[j][n - 1 - i] = arr[i][j]; } } memcpy(arr, tmp, sizeof arr); swap(n, m); } void flip() { for (int i = 0; i &lt; n; i&#43;&#43;) { for (int j = 0; j &lt; m / 2; j&#43;&#43;)//要不然白换了 { swap(arr[i][j], arr[i][m - 1 - j]); } } } void judge() { memset(st, 0, sizeof st); bool tmp[8][10][10]; memset(tmp, 0, sizeof tmp); int cnt = 0; for (int t = 0; t &lt; 2; t&#43;&#43;) { for (int i = 0; i &lt; 4; i&#43;&#43;) { bool FLAG = 1; for (int j = 0; j &lt; cnt; j&#43;&#43;) { bool flag = 0; for (int ii = 0; ii &lt; n; ii&#43;&#43;) { for (int jj = 0; jj &lt; m; jj&#43;&#43;) { if (tmp[j][ii][jj] !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6270e26f84dc57e3389428d682e5c2c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-20T08:44:09+08:00" />
<meta property="article:modified_time" content="2022-08-20T08:44:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">益智游戏日历拼图解法：搜索&#43;回溯</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="800" src="https://images2.imgbox.com/29/c5/6ERwLuYy_o.jpg" width="800"></p> 
<p> 这个是某夕夕上最近很火的一款益智小游戏，版面设计看起来也很nice！那么类似这种游戏对于程序员的正确打开方式还是写个程序解决，并没有什么益智不益智，因为说实话拼这个东西还是太费力了。</p> 
<p>那么怎么解决这个问题呢？很明显先把盘子还有各个小块的形状记录起来，盘子用一个全局数组，而小块则用一个结构体node，还要存储长宽，并且有旋转等函数，然后采用深度优先搜索算法（DFS，这是一个很基础的算法，还没了解的应该先了解），注意回溯，然后就能罗列所有的情况，这个（右边的）差不多是7*7大小的，并且总共有8个小块，那么每个小块大概有7*7*8种放置的方式（加上旋转和翻转，一开始没想到翻转搞多了很多时间），因此计算量（粗略的说法，放置一块的意思，包括判断、更新数组等等操作）就最多是(7*7*8)^8次（大概五万亿亿次，粗略算1亿次1秒，但是加上很多不可能的情况（判断一下就过了）还有剪枝（去掉了极多的情况），还有这个是最大估计，其实远小于五万亿秒，本人跑了半个多小时，虽说还是不少）。再加上适当判断，排序，存文件等等，我们就能愉快的完成任务了！话不多说，代码如下：</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;
using namespace std;
const int ma[12] = { 31,29,31,30,31,30,31,31,30,31,30,31 };
int day_num = 0;
int pan[10][10];
struct node {
	node()
	{
		memset(arr, 0, sizeof arr);
	}
	int n, m;
	int c;
	bool st[2][4];//哪几次旋转是没用的
	bool arr[10][10];
	void rotate()//有些可能转了等于没转，所以要四种状态都存起来
	{
		bool tmp[10][10];
		for (int i = 0; i &lt; n; i++)
		{
			for (int j = 0; j &lt; m; j++)
			{
				tmp[j][n - 1 - i] = arr[i][j];
			}
		}
		memcpy(arr, tmp, sizeof arr);
		swap(n, m);
	}
	void flip()
	{
		for (int i = 0; i &lt; n; i++)
		{
			for (int j = 0; j &lt; m / 2; j++)//要不然白换了
			{
				swap(arr[i][j], arr[i][m - 1 - j]);
			}
		}
	}
	void judge()
	{
		memset(st, 0, sizeof st);
		bool tmp[8][10][10];
		memset(tmp, 0, sizeof tmp);
		int cnt = 0;
		for (int t = 0; t &lt; 2; t++)
		{
			for (int i = 0; i &lt; 4; i++)
			{
				bool FLAG = 1;
				for (int j = 0; j &lt; cnt; j++)
				{
					bool flag = 0;
					for (int ii = 0; ii &lt; n; ii++)
					{
						for (int jj = 0; jj &lt; m; jj++)
						{
							if (tmp[j][ii][jj] != arr[ii][jj])
							{
								flag = 1;
								break;
							}
						}
						if (flag)break;
					}
					if (!flag)//完全相同
					{
						FLAG = 0;
						st[t][i] = 1;//第i次循环的状态跟前面重复了
					}
				}
				if (FLAG)
				{
					for (int ii = 0; ii &lt; n; ii++)
					{
						for (int jj = 0; jj &lt; m; jj++)
						{
							tmp[cnt][ii][jj] = arr[ii][jj];
						}
					}
					cnt++;
				}
				rotate();
			}
			flip();
		}
	}
	void pt(int x, int y, bool f = 1)//从x,y开始
	{
		for (int i = 0; i &lt; n; i++)
		{
			for (int j = 0; j &lt; m; j++)
			{
				int xx = x + i, yy = y + j;
				if (arr[i][j])
				{
					if (f)pan[xx][yy] = c;
					else pan[xx][yy] = 0;
				}
			}
		}
	}
}nd[8];
inline void printPan(ofstream &amp;ofs, int pan[][10])
{
	for (int i = 0; i &lt; 7; i++)
	{
		for (int j = 0; j &lt; 7; j++)
		{
			if (pan[i][j] != -1)ofs &lt;&lt; pan[i][j] &lt;&lt; " ";
			else ofs &lt;&lt; "  ";
		}
		ofs &lt;&lt; "\n";
	}
	ofs &lt;&lt; "\n";
}
void prework()
{
	for (int i = 0; i &lt; 12; i++) day_num += ma[i];
	for (int i = 0; i &lt; 7; i++)
	{
		for (int j = 0; j &lt; 7; j++)
		{
			pan[i][j] = 0;
		}
	}
	pan[0][6] = pan[1][6] = pan[6][3] = pan[6][4] = pan[6][5] = pan[6][6] = -1;
	for (int i = 0; i &lt; 8; i++)nd[i].c = i + 1;
	nd[0].n = 2, nd[0].m = 3;
	for (int i = 0; i &lt; 2; i++)for (int j = 0; j &lt; 3; j++)nd[0].arr[i][j] = 1;
	nd[1].n = 3, nd[1].m = 3;
	for (int i = 0; i &lt; 3; i++)for (int j = 0; j &lt; 3; j++)nd[1].arr[i][j] = 1;
	for (int i = 1; i &lt; 3; i++)for (int j = 0; j &lt; 2; j++)nd[1].arr[i][j] = 0;
	nd[2].n = 4, nd[2].m = 2;
	for (int i = 0; i &lt; 4; i++)for (int j = 0; j &lt; 2; j++)nd[2].arr[i][j] = 1;
	nd[2].arr[0][1] = nd[2].arr[2][1] = nd[2].arr[3][1] = 0;
	nd[3].n = 3, nd[3].m = 2;
	for (int i = 0; i &lt; 3; i++)for (int j = 0; j &lt; 2; j++)nd[3].arr[i][j] = 1;
	nd[3].arr[1][0] = 0;
	nd[4].n = 2, nd[4].m = 3;
	for (int i = 0; i &lt; 2; i++)for (int j = 0; j &lt; 3; j++)nd[4].arr[i][j] = 1;
	nd[4].arr[0][0] = 0;
	nd[5].n = 4, nd[5].m = 2;
	for (int i = 0; i &lt; 4; i++)for (int j = 0; j &lt; 2; j++)nd[5].arr[i][j] = 1;
	nd[5].arr[0][0] = nd[5].arr[2][1] = nd[5].arr[3][1] = 0;
	nd[6].n = 3, nd[6].m = 3;
	for (int i = 0; i &lt; 3; i++)for (int j = 0; j &lt; 3; j++)nd[6].arr[i][j] = 1;
	nd[6].arr[0][0] = nd[6].arr[0][1] = nd[6].arr[2][1] = nd[6].arr[2][2] = 0;
	nd[7].n = 2, nd[7].m = 4;
	for (int j = 0; j &lt; 4; j++)nd[7].arr[1][j] = 1;
	nd[7].arr[0][3] = 1;
	for (int i = 0; i &lt; 8; i++)nd[i].judge();
}
inline bool check(int x, int y)
{
	return x &gt;= 0 &amp;&amp; x &lt; 7 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 7 &amp;&amp; pan[x][y] == 0;
}
struct date {
	int m, d;
	int arr[10][10];
	bool operator&lt;(const date &amp;a)const
	{
		return m &lt; a.m || m == a.m&amp;&amp;d &lt; a.d;
	}
}ans[400];
map&lt;int, bool&gt;mp;
int _cnt = 0;
ofstream ofs("答案.txt");
inline void printMpSize()
{
	int cnt = 0;
	for (map&lt;int, bool&gt;::iterator it = mp.begin(); it != mp.end(); it++)
	{
		if (it-&gt;second)cnt++;
	}
	cout &lt;&lt; cnt &lt;&lt; "\n";
}
void save()
{
	printMpSize();
	int id[2][2] = { -1 };
	for (int i = 0; i &lt; 7; i++)
	{
		for (int j = 0; j &lt; 7; j++)
		{
			if (!pan[i][j])
			{
				if (id[0][0] == -1)
				{
					id[0][0] = i;
					id[0][1] = j;
				}
				else
				{
					id[1][0] = i;
					id[1][1] = j;
				}
			}
		}
	}
	if ((id[0][0] - 1.5)*(id[1][0] - 1.5) &gt; 0) return;//都不是或都是月份
	int m, d;
	if (id[0][0] &lt; 2)m = id[0][0] * 6 + id[0][1], d = (id[1][0] - 2) * 7 + id[1][1];
	else m = id[1][0] * 6 + id[1][1], d = (id[0][0] - 2) * 7 + id[0][1];
	if (d &gt;= ma[m])return;
	if (mp[m * 100 + d])return;
	mp[m * 100 + d] = 1;
	ans[_cnt].m = m + 1;
	ans[_cnt].d = d + 1;
	memcpy(ans[_cnt].arr, pan, sizeof pan);
	_cnt++;
}
void dfs(int x)//第x个
{
	if (_cnt &gt;= day_num)return;
	for (int i = 0; i &lt; 7; i++)
	{
		for (int j = 0; j &lt; 7; j++)
		{
			for (int fl = 0; fl &lt; 2; fl++)
			{
				for (int r = 0; r &lt; 4; r++)//旋转
				{
					if (nd[x].st[fl][r])
					{
						nd[x].rotate();
						continue;
					}
					bool flag = 0;
					int n = nd[x].n, m = nd[x].m;
					for (int ii = 0; ii &lt; n; ii++)
					{
						for (int jj = 0; jj &lt; m; jj++)
						{
							int xx = i + ii, yy = j + jj;
							if (nd[x].arr[ii][jj] &amp;&amp; !check(xx, yy))
							{
								flag = 1;
								break;
							}
						}
						if (flag)break;
					}
					if (!flag)//flag为0，可以装，装完继续搜
					{
						nd[x].pt(i, j);
						if (x == 7)
						{
							save();
						}
						else
						{
							dfs(x + 1);
						}
						nd[x].pt(i, j, 0);
					}
					nd[x].rotate();
				}
				nd[x].flip();
			}
		}
	}
}
int main()
{
	prework();
	dfs(0);
	sort(ans, ans + _cnt);
	for (int i = 0; i &lt; _cnt; i++)
	{
		date &amp;a = ans[i];
		ofs &lt;&lt; a.m &lt;&lt; "月" &lt;&lt; a.d &lt;&lt; "日" &lt;&lt; "\n";
		printPan(ofs, a.arr);
	}
	ofs.close();
	return 0;
}</code></pre> 
<p>至于这个游戏的合理性证明我也是想不通，真是非常其妙，结果真的跑出每个日期的拼法。下面展示两个日期：</p> 
<p>8月19日<br> 4 4 1 1 1 2   <br> 4 0 1 1 1 2   <br> 4 4 7 2 2 2 3 <br> 7 7 7 6 6 6 3 <br> 7 5 6 6 0 3 3 <br> 5 5 8 8 8 8 3 <br> 5 5 8         </p> 
<p>10月1日<br> 1 1 1 2 2 2   <br> 1 1 1 0 6 2   <br> 0 4 4 4 6 2 8 <br> 3 4 7 4 6 6 8 <br> 3 3 7 7 7 6 8 <br> 3 5 5 5 7 8 8 <br> 3 5 5         </p> 
<p>另外，对于完全不懂编程或者不懂算法或者不想花半个小时运行程序的话，这里提供了直接下载答案的地址：<a class="link-info" href="https://tntfiles.com/0gandml96v/txt" rel="nofollow" title="答案">答案</a>。点集红色箭头直指向的地方就能下载，下载后的那些问号是日和月，并不会乱码。</p> 
<p><img alt="" height="869" src="https://images2.imgbox.com/76/97/1X02HnGC_o.png" width="863"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96be1119a916fc060b72a8a51536fa83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">顺序表的查找----按位查找与按值查找</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb905460cd71aedfef5d46af42722611/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ViLT视觉文本多模态</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>