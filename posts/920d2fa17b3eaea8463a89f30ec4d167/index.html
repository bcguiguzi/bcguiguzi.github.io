<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#，二项式系数（Binomial Coefficient）的七种算法与源代码 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#，二项式系数（Binomial Coefficient）的七种算法与源代码" />
<meta property="og:description" content="1 二项式系数（binomial coefficient） 二项式系数（binomial coefficient），或组合数，在数学里表达为：(1 &#43; x)ⁿ展开后x的系数（其中n为自然数）。从定义可看出二项式系数的值为整数。
二项式系数表为在我国被称为贾宪三角或杨辉三角，一般认为是北宋数学家贾宪所首创。
它记载于杨辉的《详解九章算法》(1261)之中。
在阿拉伯数学家卡西的著作《算术之钥》(1427)中也给出了一个二项式定理系数表，他所用的计算方法与贾宪的完全相同。
在欧洲，德国数学家阿皮安努斯在他1527年出版的算术书的封面上刻有此图。
但一般却称之为帕斯卡三角形，因为帕斯卡在1654年也发现了这个结果。
无论如何，二项式定理的发现，在我国比在欧洲至少要早300年。
1665年，牛顿把二项式定理推广到n为分数与负数的情形，给出了展开式。
二项式定理在组合理论、开高次方、高阶等差数列求和，以及差分法中有广泛的应用。
2 7种计算方法的源代码 using System; using System.Text; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { public static partial class Algorithm_Gallery { public static int Binomial_Coeffient(int n, int k) { if (k &gt; n) { return 0; } if (k == 0 || k == n) { return 1; } return Binomial_Coeffient(n - 1, k - 1) &#43; Binomial_Coeffient(n - 1, k); } public static int Binomial_Coeffient_Second(int n, int k) { int[,] C = new int[n &#43; 1, k &#43; 1]; for (int i = 0; i &lt;= n; i&#43;&#43;) { for (int j = 0; j &lt;= Math." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/920d2fa17b3eaea8463a89f30ec4d167/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T07:34:12+08:00" />
<meta property="article:modified_time" content="2024-03-14T07:34:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#，二项式系数（Binomial Coefficient）的七种算法与源代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="464" src="https://images2.imgbox.com/b3/5f/yQqFQxmm_o.png" width="815"></p> 
<h2>1 二项式系数（binomial coefficient）</h2> 
<p>二项式系数（binomial coefficient），或组合数，在数学里表达为：(1 + x)ⁿ展开后x的系数（其中n为自然数）。从定义可看出二项式系数的值为整数。</p> 
<p>二项式系数表为在我国被称为贾宪三角或杨辉三角，一般认为是北宋数学家贾宪所首创。<br> 它记载于杨辉的《详解九章算法》(1261)之中。<br> 在阿拉伯数学家卡西的著作《算术之钥》(1427)中也给出了一个二项式定理系数表，他所用的计算方法与贾宪的完全相同。<br> 在欧洲，德国数学家阿皮安努斯在他1527年出版的算术书的封面上刻有此图。<br> 但一般却称之为帕斯卡三角形，因为帕斯卡在1654年也发现了这个结果。<br> 无论如何，二项式定理的发现，在我国比在欧洲至少要早300年。<br> 1665年，牛顿把二项式定理推广到n为分数与负数的情形，给出了展开式。<br> 二项式定理在组合理论、开高次方、高阶等差数列求和，以及差分法中有广泛的应用。</p> 
<h2>2 7种计算方法的源代码</h2> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace Legalsoft.Truffer.Algorithm
{
	public static partial class Algorithm_Gallery
	{
		public static int Binomial_Coeffient(int n, int k)
		{
			if (k &gt; n)
			{
				return 0;
			}
			if (k == 0 || k == n)
			{
				return 1;
			}
			return Binomial_Coeffient(n - 1, k - 1) + Binomial_Coeffient(n - 1, k);
		}


		public static int Binomial_Coeffient_Second(int n, int k)
		{
			int[,] C = new int[n + 1, k + 1];
			for (int i = 0; i &lt;= n; i++)
			{
				for (int j = 0; j &lt;= Math.Min(i, k); j++)
				{
					if (j == 0 || j == i)
					{
						C[i, j] = 1;
					}
					else
					{
						C[i, j] = C[i - 1, j - 1] + C[i - 1, j];
					}
				}
			}
			return C[n, k];
		}


		public static int Binomial_Coeffient_Third(int n, int k)
		{
			int[] C = new int[k + 1];
			C[0] = 1;
			for (int i = 1; i &lt;= n; i++)
			{
				for (int j = Math.Min(i, k); j &gt; 0; j--)
				{
					C[j] = C[j] + C[j - 1];
				}
			}
			return C[k];
		}

		private static int Binomial_Coeffient_Utility(int n, int k, List&lt;int&gt;[] dp)
		{
			if (dp[n][k] != -1)
			{
				return dp[n][k];
			}
			if (k == 0)
			{
				dp[n][k] = 1;
				return dp[n][k];
			}

			if (k == n)
			{
				dp[n][k] = 1;
				return dp[n][k];
			}

			dp[n][k] = Binomial_Coeffient_Utility(n - 1, k - 1, dp) + Binomial_Coeffient_Utility(n - 1, k, dp);
			return dp[n][k];
		}

		public static int Binomial_Coeffient_Fourth(int n, int k)
		{
			List&lt;int&gt;[] dp = new List&lt;int&gt;[n + 1];

			for (int i = 0; i &lt; (n + 1); i++)
			{
				dp[i] = new List&lt;int&gt;();
				for (int j = 0; j &lt;= k; j++)
				{
					dp[i].Add(-1);
				}
			}
			return Binomial_Coeffient_Utility(n, k, dp);
		}

		public static int GCD(int a, int b)
		{
			if (b == 0)
			{
				return a;
			}
			return GCD(b, (a % b));
		}

		public static int Binomial_Coeffient_Fifth(int n, int r)
		{
			if (r &gt; n)
			{
				return 0;
			}
			if (r &gt; n - r)
			{
				r = n - r;
			}
			int mod = 1000000007;

			int[] arr = new int[r];
			for (int i = n - r + 1; i &lt;= n; i++)
			{
				arr[i + r - n - 1] = i;
			}
			long ans = 1;

			for (int k = 1; k &lt; r + 1; k++)
			{
				int j = 0, i = k;
				while (j &lt; arr.Length)
				{
					int x = GCD(i, arr[j]);
					if (x &gt; 1)
					{
						arr[j] /= x;
						i /= x;
					}
					if (i == 1)
					{
						// If i becomes 1, no need
						// to search arr
						break;
					}
					j += 1;
				}
			}

			foreach (int i in arr)
			{
				ans = (ans * i) % mod;
			}
			return (int)ans;
		}

		private static long pow(long b, long exp, long mod)
		{
			long ret = 1;
			while (exp &gt; 0)
			{
				if ((exp &amp; 1) &gt; 0)
				{
					ret = (ret * b) % mod;
				}
				b = (b * b) % mod;
				exp &gt;&gt;= 1;
			}
			return ret;
		}

		public static int Binomial_Coeffient_Sixth(int n, int r)
		{
			if (r &gt; n)
			{
				return 0;
			}
			if ((n - r) &gt; r)
			{
				r = (n - r);
			}
			int[] SPF = new int[n + 1];

			for (int i = 1; i &lt;= n; i++)
			{
				SPF[i] = i;
			}
			for (int i = 4; i &lt;= n; i += 2)
			{
				SPF[i] = 2;
			}
			for (int i = 3; i * i &lt; (n + 1); i += 2)
			{
				if (SPF[i] == i)
				{
					for (int j = i * i; j &lt; (n + 1); j += i)
					{
						if (SPF[j] == j)
						{
							SPF[j] = i;
						}
					}
				}
			}

			Dictionary&lt;int, int&gt; prime_pow = new Dictionary&lt;int, int&gt;();

			for (int i = r + 1; i &lt; (n + 1); i++)
			{
				int t = i;

				while (t &gt; 1)
				{
					if (prime_pow.ContainsKey(SPF[t]))
					{
						prime_pow[SPF[t]] = prime_pow[SPF[t]] + 1;
					}
					else
					{
						prime_pow.Add(SPF[t], 1);
					}
					t /= SPF[t];
				}
			}

			for (int i = 1; i &lt; (n - r + 1); i++)
			{
				int t = i;

				while (t &gt; 1)
				{
					if (prime_pow.ContainsKey(SPF[t]))
					{
						prime_pow[SPF[t]] = prime_pow[SPF[t]] - 1;
					}

					t /= SPF[t];
				}
			}

			long ans = 1;
			long mod = 1000000007;

			foreach (int i in prime_pow.Keys)
			{
				ans = (ans * pow(i, prime_pow[i], mod)) % mod;
			}
			return (int)ans;
		}

		public static int Binomial_Coeffient_Seventh(int n, int r)
		{
			if (r &gt; n)
			{
				return 0;
			}
			long m = 1000000007;
			long[] inv = new long[r + 1];
			inv[0] = 1;
			if (r + 1 &gt;= 2)
			{
				inv[1] = 1;
			}

			for (int i = 2; i &lt;= r; i++)
			{
				inv[i] = m - (m / i) * inv[(int)(m % i)] % m;
			}

			int ans = 1;
			for (int i = 2; i &lt;= r; i++)
			{
				ans = (int)(((ans % m) * (inv[i] % m)) % m);
			}

			for (int i = n; i &gt;= (n - r + 1); i--)
			{
				ans = (int)(((ans % m) * (i % m)) % m);
			}
			return ans;
		}
	}
}
</code></pre> 
<p></p> 
<p></p> 
<p>————————————————————</p> 
<p>POWER BY TRUFFER.CN<br> BY <a class="link-info" href="http://www.315soft.com" rel="nofollow" title="315SOFT.COM">315SOFT.COM</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77179941c507ceca532204d02b999261/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#，二分法（Bisection Method）求解方程的算法与源代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cda6a748a6b1e4dbb2ba8692508df05d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot启动时执行初始化操作的几种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>