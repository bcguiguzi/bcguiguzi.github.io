<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CompletableFuture 使用及应用场景 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CompletableFuture 使用及应用场景" />
<meta property="og:description" content="JDK1.8 之前，我们会通过 Future 和 Callable 采用轮询来实现异步获取结果
//定义一个异步任务 Future&lt;String&gt; future = executor.submit(()-&gt;{ Thread.sleep(2000); return &#34;hello world&#34;; }); //轮询获取结果 while (true){ if(future.isDone()) { System.out.println(future.get()); break; } } JDK1.8 中提供的 CompletableFuture 提供了异步函数式编程。可以帮助我们简化异步编程的复杂性，通过回调的方式处理计算结果，并且提供了转换和组合的方法。
1 CompletableFuture 的使用 1.1 创建 CompletableFuture 对象 提供了四个静态方法来创建
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) async 代表异步。
runAsync 和 supplyAsync 方法的区别在于，前者没有结果返回，后者会有结果返回" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1a776993dcc1dc85af618a0a42f9fd90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-05T15:03:11+08:00" />
<meta property="article:modified_time" content="2022-03-05T15:03:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CompletableFuture 使用及应用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>JDK1.8 之前，我们会通过 Future 和 Callable 采用轮询来实现异步获取结果</p> 
<pre><code>//定义一个异步任务
Future&lt;String&gt; future = executor.submit(()-&gt;{
       Thread.sleep(2000);
       return "hello world";
});
//轮询获取结果
while (true){
    if(future.isDone()) {
         System.out.println(future.get());
         break;
     }
 }</code></pre> 
<p>JDK1.8 中提供的 CompletableFuture 提供了异步函数式编程。可以帮助我们简化异步编程的复杂性，通过回调的方式处理计算结果，并且提供了转换和组合的方法。</p> 
<h2>1 CompletableFuture 的使用</h2> 
<h3>1.1 创建 CompletableFuture 对象</h3> 
<p>        提供了四个静态方法来创建</p> 
<pre><code>public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable)
public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable, Executor executor)
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier)
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></pre> 
<p></p> 
<p>async 代表异步。</p> 
<p>runAsync 和 supplyAsync 方法的区别在于，前者没有结果返回，后者会有结果返回</p> 
<p>默认用的线程池为 ForkJoinPool.commonPool()</p> 
<pre><code>private static void completableFuture() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world";
    });
    // 阻塞的获取结果
    while (true) {
        if (completableFuture.isDone()) {
            System.out.println(completableFuture.get());
            break;
        }
    }
}</code></pre> 
<p></p> 
<h3>1.2 阻塞获取</h3> 
<p>        以下四个方法用于获取结果</p> 
<p></p> 
<pre><code>public T    get()
public T    get(long timeout, TimeUnit unit)
public T    getNow(T valueIfAbsent)
public T    join()</code></pre> 
<p>getNow() 代表计算完，如果返回结果或抛出异常就正常get，否则就返回给定的 valueIfAbsent 值</p> 
<p>join() 返回计算的结果或者抛出一个 unchecked 异常（CompletionException）</p> 
<p></p> 
<p>        主动触发计算</p> 
<pre><code>public boolean complete(T  value)
public boolean completeExceptionally(Throwable ex)</code></pre> 
<pre><code>    private static void completableFuture3() throws Exception {
        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "hello world";
        });
        // 设置 completableFuture.get() 获取到的值
        completableFuture.complete("aaa");
        System.out.println(completableFuture.get());
        // 以异常的形式触发计算
        // completableFuture.completeExceptionally(new Exception());
        // System.out.println(completableFuture.get());
    }</code></pre> 
<h3>1.3 计算完成时处理</h3> 
<pre><code>public CompletableFuture&lt;T&gt;     whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)
public CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)
public CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)
public CompletableFuture&lt;T&gt;     exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code></pre> 
<p>上面四个方法是计算阶段结束的时候触发</p> 
<p>BiConsumer 有两个入参，分别代表计算的返回值，以及异常</p> 
<p></p> 
<pre><code>private static void completableFuture4() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world";
    });
    completableFuture = completableFuture.whenCompleteAsync((v, e) -&gt; {
        System.out.println("return value:" + v + "  exception:" + e);
    });
    System.out.println(completableFuture.get());
}</code></pre> 
<pre><code>public &lt;U&gt; CompletableFuture&lt;U&gt;     handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)</code></pre> 
<p>返回的不是原始返回的值，而是经过 BiFunction 处理返回的值</p> 
<pre><code>private static void completableFuture5() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world";
    });
    completableFuture = completableFuture.handle((v, e) -&gt; {
        System.out.println("return value:" + v + "  exception:" + e);
        return "handled " + v;
    });
    System.out.println(completableFuture.get());
}</code></pre> 
<h3>1.4 thenApply</h3> 
<p></p> 
<pre><code>public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApply(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</code></pre> 
<pre><code>private static void completableFuture6() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world";
    });
    completableFuture = completableFuture.thenApply((ele) -&gt; {
        return "handled1 " + ele;
    }).thenApply((ele) -&gt; {
        return "handled2 " + ele;
    });
    System.out.println(completableFuture.get());
}</code></pre> 
<p>        与 handle 方法的区别在于，handle 方法会处理正常值和异常。因此它可以屏蔽异常，避免异常继续抛出。</p> 
<p>        而 thenApply 方法只是用来处理正常值，因此一旦有异常就会抛出。</p> 
<h3>1.5 thenAccept</h3> 
<p></p> 
<p></p> 
<pre><code>public CompletableFuture&lt;Void&gt;  thenAccept(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)
</code></pre> 
<p>        只对结果进行消费，没有返回值</p> 
<h3>1.6 thenAcceptBoth</h3> 
<p></p> 
<pre><code>public CompletableFuture&lt;Void&gt;  thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)</code></pre> 
<p>        用来组合两个 CompletableFuture，其中一个 CompletableFuture 等待另一个 CompletableFuture 的结果。</p> 
<p></p> 
<pre><code>private static void completableFuture8() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world1";
    });
    CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world2";
    });
    CompletableFuture&lt;Void&gt; compose = completableFuture1.thenAcceptBoth(completableFuture2, (x, y) -&gt; {
        System.out.println(x + " " + y);
    });
    System.out.println(completableFuture1.get());
    System.out.println(completableFuture2.get());
    System.out.println(compose.get());
}</code></pre> 
<h3>1.7 组合处理</h3> 
<pre><code>public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn);
public CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);
public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)
public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</code></pre> 
<ul><li>applyToEither 
  <ul><li>一个完成就触发 Function</li></ul></li><li>acceptEither 
  <ul><li>两个都完成才触发 Consumer</li></ul></li><li>allOf 
  <ul><li>所有都执行完成才执行计算</li></ul></li><li>anyOf 
  <ul><li>任意一个执行完成就执行计算</li></ul></li></ul> 
<p></p> 
<p></p> 
<h2>2 CompletableFuture 的应用场景</h2> 
<h3>2.1 创建异步任务</h3> 
<p>        最初设计出来就是为了完成异步任务的功能。</p> 
<h3>2.2 简单任务异步回调</h3> 
<p>先说一下 async 和没有 async 的区别</p> 
<ul><li>有 async 的方法，前后任务共用一个线程池</li><li>没有 async 的方法，第二个任务使用的是 ForkJoin 线程池</li></ul> 
<p>这部分很多都在前文中解释过了，就不再补充代码测试了。</p> 
<h4>1 thenRun/thenRunAsync</h4> 
<ul><li>执行完第一个任务后，执行第二个任务。</li><li>也就是第二个任务是第一个任务的回调。</li><li>但是任务前后没有参数传递，第二个任务也没有返回值</li></ul> 
<h4>2 thenAccept/thenAcceptAsync</h4> 
<ul><li>执行完第一个任务后，执行第二个任务。</li><li>会将第一个任务的结果当做入参传入第二个任务。</li><li>第二个任务没有返回值，是 Consumer</li></ul> 
<h4>3 thenApply/thenApplyAsync</h4> 
<ul><li>执行完第一个任务后，执行第二个任务</li><li>会将第一个任务的结果当做入参传入第二个任务。</li><li>第二个任务也有返回值，是 Function</li></ul> 
<h4>4 exceptionally</h4> 
<ul><li>执行任务发生异常的回调。</li><li>发生的异常作为参数，传递到回调方法中</li></ul> 
<h4>5 whenComplete</h4> 
<ul><li>类似于 thenAccept ，只是回调中会返回 exception</li><li>而 thenAccept 方法有异常会直接对外抛出</li></ul> 
<h4>6 handle</h4> 
<ul><li>类似于 thenApply ，只是回调中会返回 exception</li><li>而 thenApply 方法有异常会直接对外抛出</li></ul> 
<h3>2.3 多个任务组合处理</h3> 
<h4>1 and 组合关系</h4> 
<p>表示将两个任务组合起来，只有两个都正常执行完了，才会执行某个任务</p> 
<ul><li>thenCombine：会将两个任务的执行结果作为方法入参，传递到指定方法中，且有返回值</li><li>thenAcceptBoth: 会将两个任务的执行结果作为方法入参，传递到指定方法中，且无返回值</li><li>runAfterBoth 不会把执行结果当做方法入参，且没有返回值。</li></ul> 
<h4>2 or 组合关系</h4> 
<p>表示将两个任务组合起来，只要其中有一个任务执行完了，就会执行某个任务</p> 
<ul><li>applyToEither：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且有返回值</li><li>acceptEither: 会将已经执行完成的任务，作为方法入参，传递到指定方法中，且无返回值</li><li>runAfterEither： 不会把执行结果当做方法入参，且没有返回值。</li></ul> 
<h4>3 allOf</h4> 
<p>        所有任务都执行完成后，才执行返回的CompletableFuture</p> 
<p>        这边发现取不到 v 和 e 的值，因为可能存在多个任务，不确定最终执行哪个任务。</p> 
<p>        所以这个方法适用于各个任务的返回值没有关联关系</p> 
<p>        等待多个任务确认都完成后，再执行后续回调</p> 
<p>        有点类似 jemeter 中的设置集合点 的概念</p> 
<pre><code>private static void completableFuture10() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world1";
    });
    CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world2";
    });
    CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(completableFuture1, completableFuture2)
            .whenComplete((v, e) -&gt; System.out.println("value:" + v + "ex:" + e));
    System.out.println(completableFuture1.get());
    System.out.println(completableFuture2.get());
    System.out.println(allOf.get());
}</code></pre> 
<h4>4 anyOf</h4> 
<p>        任意一个任务执行完，才执行返回的CompletableFuture</p> 
<p>        可以取到 v 和 e 的值，返回的是首先完成的任务的返回值</p> 
<p></p> 
<p></p> 
<pre><code>private static void completableFuture11() throws Exception {
    CompletableFuture&lt;String&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world1";
    });
    CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hello world2";
    });
    CompletableFuture&lt;Object&gt; allOf = CompletableFuture.anyOf(completableFuture1, completableFuture2)
            .whenComplete((v, e) -&gt; {
                System.out.println("value:" + v + "ex:" + e);
            });
    System.out.println(completableFuture1.get());
    System.out.println(completableFuture2.get());
    System.out.println(allOf.get());
}</code></pre> 
<h4>5 thenCompose</h4> 
<p>        thenCompose方法会在某个任务执行完成后，将该任务的执行结果,作为方法入参,去执行指定的方法。该方法会返回一个新的CompletableFuture实例</p> 
<ul><li>如果该CompletableFuture实例的result不为null，则返回一个基于该result新的CompletableFuture实例；</li><li>如果该CompletableFuture实例为null，然后就执行这个新任务</li></ul> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3082cc0cf39b34e5bab0cf16d36e22d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣LeetCode-贪心算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48970fb73d64c94899e58e81a0d3d518/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">electron打包vue项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>