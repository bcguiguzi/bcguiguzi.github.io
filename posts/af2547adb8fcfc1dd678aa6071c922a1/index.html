<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>注释竟然还有特殊用途？一文解惑 //go:linkname 指令 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="注释竟然还有特殊用途？一文解惑 //go:linkname 指令" />
<meta property="og:description" content="阅读本文大概需要 5 分钟。
大家好，我是站长 polarisxu。
我之前写过一篇文章：为什么 Go 标准库中有些函数只有签名，没有函数体？，其中有一点就是 //go:linkname 这个指令。
Go 中类似的指令挺多的，比如 Go1.16 中的 //go:embed。前些天有人问我，为什么它用 //go:embed 不起作用？我一看，它是这么写的：// go:embed，不知道你看到问题了没有？是的，指令是通过注释的方式，但有三点要求，要特别注意：
// 后不能有空格。有些人可能习惯 // 后不加空格。但一般认为，// 后应该加一个空格。不过 go 指令却要求不能有空格，这是一个小“坑”，得注意。所以上面那位朋友就是加了空格，导致出问题。（程序并不会报错，只是没有得到自己想要的结果）
代码和指令之间不能有空行或其他注释。这一点应该还好，很多人不会用错吧；
一般来说，使用指令需要导入相应的包。比如 //go:linkname 指令要求导入 unsafe 包，一般会 import _ &#34;unsafe”，//go:embed 指令，要求导入 embed 包。
有另外一位 Go 朋友「橘中秘士」微信私聊我：
大佬好，能不能写一篇 linkname 的文章。目前已经有了一些初步概念，但是尚有一些疑团不是特别清晰。
//go:linkname localname remotename，其中 local 作为占位符 remote 作为实现者或者 local 作为实现者 remote 作为占位符都是可以的。目前理解的就是给 Symbol 添加了一个 Linkname，查找 Symbo l的时候用 remote。
譬如 //go:linkname runtimeNano runtime.nanotime，runtimeNano 作为占位符 runtime.nanotime 提供实现，任何调用 runtimeNano 的地方实际替换为对 runtime." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/af2547adb8fcfc1dd678aa6071c922a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-25T08:51:00+08:00" />
<meta property="article:modified_time" content="2021-06-25T08:51:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">注释竟然还有特殊用途？一文解惑 //go:linkname 指令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>阅读本文大概需要 5 分钟。</p> 
 <p>大家好，我是站长 polarisxu。</p> 
 <p>我之前写过一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ%3D%3D&amp;idx=1&amp;mid=2651436552&amp;scene=21&amp;sn=6f038e546bdf0fcace133631b0247bc2#wechat_redirect" rel="nofollow">为什么 Go 标准库中有些函数只有签名，没有函数体？</a>，其中有一点就是 <code>//go:linkname</code> 这个指令。</p> 
 <p>Go 中类似的指令挺多的，比如 Go1.16 中的 <code>//go:embed</code>。前些天有人问我，为什么它用 <code>//go:embed</code> 不起作用？我一看，它是这么写的：<code>// go:embed</code>，不知道你看到问题了没有？是的，指令是通过注释的方式，但有三点要求，要特别注意：</p> 
 <ul><li><p><code>//</code> 后不能有空格。有些人可能习惯 <code>//</code> 后不加空格。但一般认为，<code>//</code> 后应该加一个空格。不过 go 指令却要求不能有空格，这是一个小“坑”，得注意。所以上面那位朋友就是加了空格，导致出问题。（程序并不会报错，只是没有得到自己想要的结果）</p></li><li><p>代码和指令之间不能有空行或其他注释。这一点应该还好，很多人不会用错吧；</p></li><li><p>一般来说，使用指令需要导入相应的包。比如 <code>//go:linkname</code> 指令要求导入 unsafe 包，一般会 <code>import _ "unsafe”</code>，<code>//go:embed</code> 指令，要求导入 embed 包。</p></li></ul> 
 <p>有另外一位 Go 朋友「橘中秘士」微信私聊我：</p> 
 <blockquote> 
  <p>大佬好，能不能写一篇 linkname 的文章。目前已经有了一些初步概念，但是尚有一些疑团不是特别清晰。</p> 
  <p>//go:linkname localname remotename，其中 local 作为占位符 remote 作为实现者或者 local 作为实现者 remote 作为占位符都是可以的。目前理解的就是给 Symbol 添加了一个 Linkname，查找 Symbo l的时候用 remote。</p> 
  <p>譬如 //go:linkname runtimeNano runtime.nanotime，runtimeNano 作为占位符 runtime.nanotime 提供实现，任何调用 runtimeNano 的地方实际替换为对 runtime.nanotime 的调用，这种场景比较容易接受。</p> 
  <p>譬如 //go:linkname runtime_cmpstring runtime.cmpstring，runtime_cmpstring 提供实现 runtime.cmpstring作为占位符，是不是这时符号表里不存在 runtime_cmpstring 只有 runtime.cmpstring？</p> 
 </blockquote> 
 <p>经过简单沟通，他写了一篇文章解决自己的困惑。希望对各位有帮助。以下是他写的关于 <code>//go:linkname</code> 的文章（我做了一些调整）。</p> 
 <hr> 
 <h3>01 格式</h3> 
 <pre class="has"><code class="language-go">//go:linkname local remote
</code></pre> 
 <p>remote 可以没有，此时 remote 使用 local 的值，效果就是 local 被导出。</p> 
 <h3>02 local 和 remote 同时为函数</h3> 
 <h4>local 作为占位符，remote 作为实现者</h4> 
 <p>标准库中的例子：</p> 
 <pre class="has"><code class="language-go">// 来自 time 包
//go:linkname runtimeNano runtime.nanotime
func runtimeNano() int64

// 来自 runtime 包
//go:nosplit
func nanotime() int64 {
 return nanotime1()
}
</code></pre> 
 <p>此时二进制文件中并没有<code>runtimeNano</code>，直接转化为对<code>runtime.nanotime</code>的调用。</p> 
 <h4>local 作为实现者，remote 作为占位符</h4> 
 <p>同样来自标准库。这里存在函数没有函数体，但是被反向引用。</p> 
 <pre class="has"><code class="language-go">// 在标准库的一个 internal 中
//go:linkname runtime_cmpstring runtime.cmpstring
func runtime_cmpstring(a, b string) int {
 l := len(a)
 if len(b) &lt; l {
  l = len(b)
 }
 for i := 0; i &lt; l; i++ {
  c1, c2 := a[i], b[i]
  if c1 &lt; c2 {
   return -1
  }
  if c1 &gt; c2 {
   return +1
  }
 }
 if len(a) &lt; len(b) {
  return -1
 }
 if len(a) &gt; len(b) {
  return +1
 }
 return 0
}

// 来自 runtime
func cmpstring(string, string) int
</code></pre> 
 <p>此时二进制文件中并没有<code>runtime_cmpstring</code>，对应的函数已经被命名为<code>runtime.cmpstring</code>。也就是说，实现在 internal 包，但最终通过 runtime.cmpstring 来引用。</p> 
 <h4>一个占位符+一个汇编函数</h4> 
 <pre class="has"><code class="language-go">// 在标准库的一个 internal 中
//go:linkname abigen_runtime_memequal runtime.memequal
func abigen_runtime_memequal(a, b unsafe.Pointer, size uintptr) bool
</code></pre> 
 <p>注意<code>runtime.memequal</code>的实现并不在<code>runtime</code>包中，使用汇编实现的话并不要求必须在相应的包中。</p> 
 <pre class="has"><code class="language-go"># memequal(a, b unsafe.Pointer, size uintptr) bool
TEXT runtime·memequal(SB),NOSPLIT,$0-25
	MOVQ	a+0(FP), SI
	MOVQ	b+8(FP), DI
	CMPQ	SI, DI
	JEQ	eq
	MOVQ	size+16(FP), BX
	LEAQ	ret+24(FP), AX
	JMP	memeqbody&lt;&gt;(SB)
eq:
	MOVB	$1, ret+24(FP)
	RET
</code></pre> 
 <h3>03 local 和 remote 同时为变量</h3> 
 <h4>两个常规变量</h4> 
 <pre class="has"><code class="language-go">//go:linkname overflowError runtime.overflowError
var overflowError error

//go:linkname divideError runtime.divideError
var divideError error

//go:linkname zeroVal runtime.zeroVal
var zeroVal [maxZero]byte

//go:linkname _iscgo runtime.iscgo
var _iscgo bool = true

//go:cgo_import_static x_cgo_setenv
//go:linkname x_cgo_setenv x_cgo_setenv
//go:linkname _cgo_setenv runtime._cgo_setenv
var x_cgo_setenv byte
var _cgo_setenv = &amp;x_cgo_setenv

//go:cgo_import_static x_cgo_unsetenv
//go:linkname x_cgo_unsetenv x_cgo_unsetenv
//go:linkname _cgo_unsetenv runtime._cgo_unsetenv
var x_cgo_unsetenv byte
var _cgo_unsetenv = &amp;x_cgo_unsetenv
</code></pre> 
 <h4>一个占位符+一个伪符号</h4> 
 <pre class="has"><code class="language-go">//go:linkname runtime_inittask runtime..inittask
var runtime_inittask initTask

//go:linkname main_inittask main..inittask
var main_inittask initTask
</code></pre> 
 <p>注意是<code>..inittask</code>不是<code>.inittask</code>，而且<code>.inittask</code>只存在于编译阶段，任何包中都无法声明该变量。</p> 
 <blockquote> 
  <p>这里额外解释下 ..inittask 为什么两个点。第一个点就是普通的 runtime. 这种调用方式，第二个点和 inittask 一起构成一个符号（变量）。注意，Go 中的变量是不允许以 . 开头的，所以，这个叫伪符号，只在不编译阶段存在。</p> 
 </blockquote> 
 <h3>04 一个例子</h3> 
 <p style="text-align: left">研究 <code>//go:linkname</code> 是因为如下的背景：</p> 
 <blockquote> 
  <p>Java 里有 InheritableThreadLocal，SpringWeb 在 ServletActionContext 里使用它，达到在任何地方都能方便的获取HttpServletRequest。</p> 
  <p>Go 并没有提供类似的机制，即使通过 stack 找到 goroutine id（99% 的文章都是这么介绍的），再配合 sync.Map，也只是实现了一个比较粗糙的 ThreadLocal，在子协程里仍然获取不到父协程的内容。</p> 
  <p>g.label 虽然不是给这种场景准备的，但它具备了 InheritableThreadLocal 的一切要求，只要我们能够访问到 label 私有字段，我们就有了完整版的 InheritableThreadLocal。</p> 
 </blockquote> 
 <p style="text-align: left">下面这个例子是作者真实项目中用的。</p> 
 <p>在 runtime 和 runtime/pprof 包中有两个函数：runtime_setProfLabel 和  runtime_getProfLabel。其中，runtime 包中的提供了实现，而 pprof 中的没有提供实现。如果基于它们创建另外的函数，如下：<br></p> 
 <pre class="has"><code class="language-go">//go:linkname SetPointer runtime/pprof.runtime_setProfLabel
func SetPointer(ptr unsafe.Pointer)

//go:linkname GetPointer runtime/pprof.runtime_getProfLabel
func GetPointer() unsafe.Pointer
</code></pre> 
 <p>根据前面的分析，虽然<code>runtime.runtime_setProfLabel</code>/<code>runtime.runtime_getProfLabel</code>提供了函数实现，但是二进制文件中并不会出现（见下方代码），此时想要调用必须通过<code>runtime/pprof.runtime_setProfLabel</code>/<code>runtime/pprof.runtime_getProfLabel</code>，这也是上面<code>linkname</code>到<code>pprof</code>而不是<code>runtime</code>的根本原因。</p> 
 <pre class="has"><code class="language-go">// 来自 runtime 包
//go:linkname runtime_setProfLabel runtime/pprof.runtime_setProfLabel
func runtime_setProfLabel(labels unsafe.Pointer) {
 if raceenabled {
  racereleasemerge(unsafe.Pointer(&amp;labelSync))
 }
 getg().labels = labels
}

// 来自 runtime/pprof 包
func runtime_setProfLabel(labels unsafe.Pointer)

// 来自 runtime 包
//go:linkname runtime_getProfLabel runtime/pprof.runtime_getProfLabel
func runtime_getProfLabel() unsafe.Pointer {
 return getg().labels
}

// 来自 runtime/pprof 包
func runtime_getProfLabel() unsafe.Pointer
</code></pre> 
 <h3>05 总结</h3> 
 <p>Go 中有不少指令，有些指令你可能不太需要关心，也不会用到。然而有些指令了解它们的意思，对阅读相关代码很有帮助。</p> 
 <p>这篇文章全面介绍了 <code>//go:linkname</code> 指令，不知道是否彻底解除了你的疑惑？欢迎留言交流！</p> 
 <hr> 
 <p><strong>往期推荐</strong></p> 
 <ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNzY0NDE3NA%3D%3D&amp;chksm=9be32cf5ac94a5e359a569557fb8b0b79bfc4c2d71132228a610eb14728bbef64476e183f695&amp;idx=1&amp;mid=2247484180&amp;scene=21&amp;sn=92577f1c8744b74dc78d003d94c3a673#wechat_redirect" rel="nofollow">为什么 Go 标准库中有些函数只有签名，没有函数体？</a><br></p></li></ul> 
 <p style="text-align: center">欢迎关注我</p> 
 <p style="text-align: left">都看到这里了，随手<strong>点个赞</strong>支持下呗！<br></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fa9fb6b1c60db3cf0fc83b3932880f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】一文弄通&#43;&#43;i,i&#43;&#43;,i--,--i，解决粉丝疑问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebfb6af16d858bdac2a5dfcbef5b2c3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">非root用户，conda环境下配置并使用其他版本gcc</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>