<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot中@Value的工作原理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot中@Value的工作原理" />
<meta property="og:description" content="转截自：https://blog.csdn.net/gs_albb/article/details/85401720
我们知道springboot中的Bean组件的成员变量(属性)如果加上了@Value注解，可以从有效的配置属性资源中找到配置项进行绑定，那么这一切是怎么发生的呢？下文将简要分析一下@Value的工作原理。
springboot版本: springboot-2.0.6.RELEASE
概述
springboot启动过程中，有两个比较重要的过程，如下:
1 扫描，解析容器中的bean注册到beanFactory上去，就像是信息登记一样。
2 实例化、初始化这些扫描到的bean。
@Value的解析就是在第二个阶段。BeanPostProcessor定义了bean初始化前后用户可以对bean进行操作的接口方法，它的一个重要实现类AutowiredAnnotationBeanPostProcessor正如javadoc所说的那样，为bean中的@Autowired和@Value注解的注入功能提供支持。
解析流程
调用链时序图
@Value解析过程中的主要调用链，我用以下时序图来表示:
这里先简单介绍一下图上的几个类的作用。
AbstractAutowireCapableBeanFactory: 提供了bean创建，属性填充，自动装配，初始胡。支持自动装配构造函数，属性按名称和类型装配。实现了AutowireCapableBeanFactory接口定义的createBean方法。
AutowiredAnnotationBeanPostProcessor: 装配bean中使用注解标注的成员变量，setter方法, 任意的配置方法。比较典型的是@Autowired注解和@Value注解。
InjectionMetadata: 类的注入元数据，可能是类的方法或属性等，在AutowiredAnnotationBeanPostProcessor类中被使用。
AutowiredFieldElement: 是AutowiredAnnotationBeanPostProcessor的一个私有内部类，继承InjectionMetadata.InjectedElement，描述注解的字段。
StringValueResolver: 一个定义了处置字符串值的接口，只有一个接口方法resolveStringValue，可以用来解决占位符字符串。本文中的主要实现类在PropertySourcesPlaceholderConfigurer#processProperties方法中通过lamda表达式定义的。供ConfigurableBeanFactory类使用。
PropertySourcesPropertyResolver: 属性资源处理器，主要功能是获取PropertySources属性资源中的配置键值对。
PropertyPlaceholderHelper: 一个工具类，用来处理带有占位符的字符串。形如${name}的字符串在该工具类的帮助下，可以被用户提供的值所替代。替代途经可能通过Properties实例或者PlaceholderResolver(内部定义的接口)。
PropertyPlaceholderConfigurerResolver: 上一行所说的PlaceholderResolver接口的一个实现类，是PropertyPlaceholderConfigurer类的一个私有内部类。实现方法resolvePlaceholder中调用了外部类的resolvePlaceholder方法。
调用链说明
这里主要介绍一下调用链中的比较重要的方法。
AbstractAutowireCapableBeanFactory#populateBean方法用于填充bean属性，执行完后可获取属性装配后的bean。
protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) { ...
if (hasInstAwareBpps) {
// 遍历所有InstantiationAwareBeanPostProcessor实例设置属性字段值。
for (BeanPostProcessor bp : getBeanPostProcessors()) {
// AutowiredAnnotationBeanPostProcessor会进入此分支
if (bp instanceof InstantiationAwareBeanPostProcessor) {
InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
pvs = ibp." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4684311b81dd9bdb31985730abfe3cd9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-17T11:11:46+08:00" />
<meta property="article:modified_time" content="2019-07-17T11:11:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot中@Value的工作原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转截自：<a href="https://blog.csdn.net/gs_albb/article/details/85401720">https://blog.csdn.net/gs_albb/article/details/85401720</a></p> 
<p>我们知道springboot中的Bean组件的成员变量(属性)如果加上了@Value注解，可以从有效的配置属性资源中找到配置项进行绑定，那么这一切是怎么发生的呢？下文将简要分析一下@Value的工作原理。</p> 
<p>springboot版本: springboot-2.0.6.RELEASE</p> 
<p>概述<br> springboot启动过程中，有两个比较重要的过程，如下:<br> 1 扫描，解析容器中的bean注册到beanFactory上去，就像是信息登记一样。<br> 2 实例化、初始化这些扫描到的bean。</p> 
<p>@Value的解析就是在第二个阶段。BeanPostProcessor定义了bean初始化前后用户可以对bean进行操作的接口方法，它的一个重要实现类AutowiredAnnotationBeanPostProcessor正如javadoc所说的那样，为bean中的@Autowired和@Value注解的注入功能提供支持。</p> 
<p>解析流程<br> 调用链时序图<br> @Value解析过程中的主要调用链，我用以下时序图来表示:</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f5/bb/b8q2uQzy_o.png"></p> 
<p>这里先简单介绍一下图上的几个类的作用。</p> 
<p>AbstractAutowireCapableBeanFactory: 提供了bean创建，属性填充，自动装配，初始胡。支持自动装配构造函数，属性按名称和类型装配。实现了AutowireCapableBeanFactory接口定义的createBean方法。</p> 
<p>AutowiredAnnotationBeanPostProcessor: 装配bean中使用注解标注的成员变量，setter方法, 任意的配置方法。比较典型的是@Autowired注解和@Value注解。</p> 
<p>InjectionMetadata: 类的注入元数据，可能是类的方法或属性等，在AutowiredAnnotationBeanPostProcessor类中被使用。</p> 
<p>AutowiredFieldElement: 是AutowiredAnnotationBeanPostProcessor的一个私有内部类，继承InjectionMetadata.InjectedElement，描述注解的字段。</p> 
<p>StringValueResolver: 一个定义了处置字符串值的接口，只有一个接口方法resolveStringValue，可以用来解决占位符字符串。本文中的主要实现类在PropertySourcesPlaceholderConfigurer#processProperties方法中通过lamda表达式定义的。供ConfigurableBeanFactory类使用。</p> 
<p>PropertySourcesPropertyResolver: 属性资源处理器，主要功能是获取PropertySources属性资源中的配置键值对。</p> 
<p>PropertyPlaceholderHelper: 一个工具类，用来处理带有占位符的字符串。形如${name}的字符串在该工具类的帮助下，可以被用户提供的值所替代。替代途经可能通过Properties实例或者PlaceholderResolver(内部定义的接口)。</p> 
<p>PropertyPlaceholderConfigurerResolver: 上一行所说的PlaceholderResolver接口的一个实现类，是PropertyPlaceholderConfigurer类的一个私有内部类。实现方法resolvePlaceholder中调用了外部类的resolvePlaceholder方法。</p> 
<p>调用链说明<br> 这里主要介绍一下调用链中的比较重要的方法。</p> 
<p>AbstractAutowireCapableBeanFactory#populateBean方法用于填充bean属性，执行完后可获取属性装配后的bean。</p> 
<p>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {       <br> ...<br> if (hasInstAwareBpps) {<!-- --><br>     // 遍历所有InstantiationAwareBeanPostProcessor实例设置属性字段值。<br>     for (BeanPostProcessor bp : getBeanPostProcessors()) {<!-- --><br>         // AutowiredAnnotationBeanPostProcessor会进入此分支<br>         if (bp instanceof InstantiationAwareBeanPostProcessor) {<!-- --><br>             InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>             pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>         //上行代码执行后,bw.getWrappedInstance()就得到了@Value注解装配属性后的bean了<br>             if (pvs == null) {<!-- --><br>                 return;<br>             }<br>         }<br>     }<br> }<br> ...<br> }<br><br> InjectionMetadata#inject逐个装配bean的配置属性。</p> 
<p>public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {<!-- --><br>     Collection&lt;InjectedElement&gt; checkedElements = this.checkedElements;<br>     Collection&lt;InjectedElement&gt; elementsToIterate =<br>             (checkedElements != null ? checkedElements : this.injectedElements);<br>     if (!elementsToIterate.isEmpty()) {<!-- --><br>         // 依次注入属性<br>         for (InjectedElement element : elementsToIterate) {<!-- --><br>             if (logger.isDebugEnabled()) {<!-- --><br>                 logger.debug("Processing injected element of bean '" + beanName + "': " + element);<br>             }<br>             element.inject(target, beanName, pvs);<br>         }<br>     }<br> }<br><br> PropertyPlaceholderHelper#parseStringValue解析属性值</p> 
<p>/**<br>  *  一个参数示例 value = "${company.ceo}"<br>  *<br>  */<br> protected String parseStringValue(<br>         String value, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders) {<!-- --></p> 
<p>    StringBuilder result = new StringBuilder(value);</p> 
<p>    // this.placeholderPrefix = "${"<br>     int startIndex = value.indexOf(this.placeholderPrefix);<br>     while (startIndex != -1) {<!-- --><br>         // 占位符的结束位置，以value = "${company.ceo}"为例,endIndex=13<br>         int endIndex = findPlaceholderEndIndex(result, startIndex);<br>         if (endIndex != -1) {<!-- --><br>             // 获取{}里的真正属性名称，此例为"company.ceo"<br>             String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex);<br>             String originalPlaceholder = placeholder;<br>             if (!visitedPlaceholders.add(originalPlaceholder)) {<!-- --><br>                 throw new IllegalArgumentException(<br>                         "Circular placeholder reference '" + originalPlaceholder + "' in property definitions");<br>             }<br>             // Recursive invocation, parsing placeholders contained in the placeholder key.<br>             // 递归调用本方法，因为属性键中可能仍然有占位符<br>             placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);<br>             // Now obtain the value for the fully resolved key...<br>             // 获取属性键placeholder对应的属性值<br>             String propVal = placeholderResolver.resolvePlaceholder(placeholder);<br>             // 此处逻辑是当company.ceo=${bi:li}时,company.ceo最终被li所替代的原因<br>             // 所以配置文件中，最好不要出现类似${}的东西，因为它本身就会被spring框架所解析<br>             if (propVal == null &amp;&amp; this.valueSeparator != null) {<!-- --><br>                 int separatorIndex = placeholder.indexOf(this.valueSeparator);<br>                 if (separatorIndex != -1) {<!-- --><br>                     String actualPlaceholder = placeholder.substring(0, separatorIndex);<br>                     String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());<br>                     propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);<br>                     if (propVal == null) {<!-- --><br>                         propVal = defaultValue;<br>                     }<br>                 }<br>             }<br>             if (propVal != null) {<!-- --><br>                 // Recursive invocation, parsing placeholders contained in the<br>                 // previously resolved placeholder value.<br>                 propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);<br>                 // 将${company.ceo}替换为li<br>                 result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);<br>                 if (logger.isTraceEnabled()) {<!-- --><br>                     logger.trace("Resolved placeholder '" + placeholder + "'");<br>                 }<br>                 startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());<br>             }<br>             else if (this.ignoreUnresolvablePlaceholders) {<!-- --><br>                 // Proceed with unprocessed value.<br>                 startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());<br>             }<br>             else {<!-- --><br>                 throw new IllegalArgumentException("Could not resolve placeholder '" +<br>                         placeholder + "'" + " in value \"" + value + "\"");<br>             }<br>             visitedPlaceholders.remove(originalPlaceholder);<br>         }<br>         else {<!-- --><br>             startIndex = -1;<br>         }<br>     }</p> 
<p>    return result.toString();<br> }<br><br> 总结<br> @Value注解标注的bean属性装配是依靠AutowiredAnnotationBeanPostProcessor在bean的实例化、初始化阶段完成的。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a07e012dbbb5e8f937d23edff7f843e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MQ】消息中间件集群崩溃，如何保证百万生产数据不丢失？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5092676e016abcb90032edd3ba691985/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js代码实现录音上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>