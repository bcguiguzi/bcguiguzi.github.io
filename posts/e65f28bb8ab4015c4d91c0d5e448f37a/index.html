<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>thrift使用说明 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="thrift使用说明" />
<meta property="og:description" content="thrift 下载网址： http://archive.apache.org/dist/thrift/0.9.3/
需要下载的依赖库有：openssl-1.0.2o-- 、thrift-0.9.3、libevent-2.1.8-stable、boost_1_66_0--其中依赖库也需要生成LIB来进行调用。
1.编译BOOST： 编译好后，自己用一下 ，可以写一个简单的demo
关于boost的编译，参见 https://blog.csdn.net/ljt350740378/article/details/87091133
2.编译openssl-1.0.2o ： 编译好后，自己用一下 ，可以写一个简单的demo
参见 https://blog.csdn.net/ljt350740378/article/details/87807544 2.编译 libevent-2.1.8-stable： 编译好后，自己用一下 ，可以写一个简单的demo
编译 libevent-2.1.8-stable，其中可以把 openssl嵌套编译进去，如下图：参见 https://blog.csdn.net/ljt350740378/article/details/87856875
3.下载thrift
http://thrift.apache.org/download thrift-0.12.0.tar.gz 和 thrift-0.12.0.exe
E:\canDel\thrift-0.12.0\tutorial\cpp 里面有例子教程
参考 https://github.com/Zuolijia/thrift https://blog.csdn.net/zuolj/article/details/77450108
4.编译thrift
打开工程，如下所示： E:\canDel\thrift-0.12.0\lib\cpp\thrift.sln
thrift命令：
thrift --gen cpp xxx.thrift #Linux下
thrift-0.9.3.exe --gen cpp xxx.thrift #Windows下
thrift-0.9.3.exe -r -strict --gen cpp:cob_style xxx.thrift #异步
然后其中：添加包含目录： $(ProjectDir)\src\;$(ProjectDir)\src\thrift\windows\;E:\canDel\boost_1_59_0\;E:\canDel\libevent-2.1.9-beta\openssl\inc32\include;E:\canDel\libevent-2.1.9-beta\;E:\canDel\libevent-2.1.9-beta\include;E:\canDel\libevent-2.1.9-beta\WIN32-Code\nmake\;$(IncludePath)
库目录：$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);E:\canDel\libevent-2.1.9-beta;E:\canDel\libevent-2.1.9-beta\openssl\inc32\lib;
附加依赖库：libevent.lib;libevent_core.lib;libevent_extras.lib;libevent_openssl.lib;libeay32.lib;ssleay32.lib;
将E:\canDel\thrift-0.12.0\config.h 放入 E:\canDel\thrift-0.12.0\lib\cpp\src\thrift 中。
有时候 会出现错误，如：错误 1 error C1083: 无法打开包括文件: “netinet/in." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e65f28bb8ab4015c4d91c0d5e448f37a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-06T17:47:44+08:00" />
<meta property="article:modified_time" content="2018-07-06T17:47:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">thrift使用说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>thrift 下载网址： http://archive.apache.org/dist/thrift/0.9.3/</p> 
<p>需要下载的依赖库有：openssl-1.0.2o-- 、thrift-0.9.3、libevent-2.1.8-stable、boost_1_66_0--其中依赖库也需要生成LIB来进行调用。</p> 
<p><strong>1.编译BOOST： 编译好后，自己用一下 ，可以写一个简单的demo</strong></p> 
<p>关于boost的编译，参见  <a href="https://blog.csdn.net/ljt350740378/article/details/87091133">https://blog.csdn.net/ljt350740378/article/details/87091133</a></p> 
<p><strong>2.编译</strong>openssl-1.0.2o<strong> ： 编译好后，自己用一下 ，可以写一个简单的demo</strong></p> 
<p>参见 <a href="" rel="nofollow"> https://blog.csdn.net/ljt350740378/article/details/87807544 </a></p> 
<p><strong>2.编译 libevent-2.1.8-stable： 编译好后，自己用一下 ，可以写一个简单的demo</strong></p> 
<p>编译 libevent-2.1.8-stable，其中可以把 openssl嵌套编译进去，如下图：参见 <a href="https://blog.csdn.net/ljt350740378/article/details/87856875">https://blog.csdn.net/ljt350740378/article/details/87856875</a></p> 
<p><strong>3.下载<a href="http://archive.apache.org/dist/thrift/" rel="nofollow">thrift</a></strong></p> 
<p><a href="http://thrift.apache.org/download" rel="nofollow">http://thrift.apache.org/download</a>     thrift-0.12.0.tar.gz    和    thrift-0.12.0.exe</p> 
<p>E:\canDel\thrift-0.12.0\tutorial\cpp 里面有例子教程</p> 
<p>参考 <a href="https://github.com/Zuolijia/thrift">https://github.com/Zuolijia/thrift</a>       </p> 
<p><a href="https://blog.csdn.net/zuolj/article/details/77450108">https://blog.csdn.net/zuolj/article/details/77450108</a></p> 
<p><strong>4.编译thrift</strong></p> 
<p>打开工程，如下所示： E:\canDel\thrift-0.12.0\lib\cpp\thrift.sln</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0c/b7/FTguD61s_o.png"></p> 
<p>thrift命令：</p> 
<p>thrift --gen cpp xxx.thrift                            #Linux下<br> thrift-0.9.3.exe --gen cpp xxx.thrift                      #Windows下<br> thrift-0.9.3.exe -r -strict --gen cpp:cob_style xxx.thrift #异步</p> 
<p>然后其中：添加包含目录： $(ProjectDir)\src\;$(ProjectDir)\src\thrift\windows\;E:\canDel\boost_1_59_0\;E:\canDel\libevent-2.1.9-beta\openssl\inc32\include;E:\canDel\libevent-2.1.9-beta\;E:\canDel\libevent-2.1.9-beta\include;E:\canDel\libevent-2.1.9-beta\WIN32-Code\nmake\;$(IncludePath)</p> 
<p>库目录：$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);E:\canDel\libevent-2.1.9-beta;E:\canDel\libevent-2.1.9-beta\openssl\inc32\lib;</p> 
<p>附加依赖库：libevent.lib;libevent_core.lib;libevent_extras.lib;libevent_openssl.lib;libeay32.lib;ssleay32.lib;</p> 
<p>将E:\canDel\thrift-0.12.0\config.h 放入 E:\canDel\thrift-0.12.0\lib\cpp\src\thrift 中。</p> 
<p>有时候 会出现错误，如：错误    1    error C1083: 无法打开包括文件: “netinet/in.h”: No such file or directory    E:\canDel\thrift-0.12.0\lib\cpp\src\thrift\Thrift.h    32    1    libthrift<br> 类似这样的错误，把相对就的宏在 config.h 中注释起来即可。</p> 
<p>编译：生成： E:\canDel\thrift-0.12.0\lib\cpp\x64\Release\libthriftnb.lib  E:\canDel\thrift-0.12.0\lib\cpp\x64\Release\libthrift.lib</p> 
<p>5.调用thrift:</p> 
<p>调用：<br> Hello.thrift 文件内容如下：<br>  </p> 
<pre class="has"><code class="language-cpp">/*namespace cpp HelloThrift.Interface
service HelloService{
    string HelloString(1:string para)
    i32 HelloInt(1:i32 para)
    bool HelloBoolean(1:bool para)
    void HelloVoid()
    string HelloNull()
}
*/

/*
struct  ReResult
{
 1:i16 iReMessageType,
 2:string strReMessageData,
}

service  HelloService
{
	 ReResult DataTransfer(1:i16 iMessageType, 2:string strMessageData);
}
*/

service  HelloService
{
	 i16 addxy(1:i16 x, 2:i16 y);
}
</code></pre> 
<p>命令如下：E:\canDel\thrift-0.12.0\lib\cpp\x64\Release&gt;E:\canDel\thrift-0.12.0\lib\cpp\x64\Release\thrift-0.12.0.exe  --gen cpp Hello.thrift</p> 
<p>生成的文件如下 ：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/fb/26/SSBNwHPX_o.png"></p> 
<p>其中，HelloService_server.skeleton.cpp 为生成的server的代码，直接拿过来用，并在里面写上实现代码就可以。</p> 
<p>使用的工程添加 的包含目录 为：$(VC_IncludePath);$(WindowsSDK_IncludePath);E:\canDel\thrift-0.12.0\lib\cpp\src;E:\canDel\boost_1_59_0\;</p> 
<p>库目录 为：$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);E:\canDel\thrift-0.12.0\lib\cpp\x64\Release;D:\boost\boost_1_59_0\bin\vc12-x64\lib;</p> 
<p>依赖的LIB为：libthrift.lib;libthriftnb.lib;libboost_thread-vc120-mt-1_59.lib;</p> 
<p>下面编写调用thrift代码：</p> 
<p>server方面：HelloService_server.skeleton.cpp直接拿过来用，里面有main,直接用，添加所有gen-cpp下的7个文件到server的文件夹下面，并更改 HelloService_server.skeleton.cpp 为  server.cpp 代码如下：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b4/cb/5oGZKnji_o.png"></p> 
<p>server.cpp：</p> 
<pre class="has"><code class="language-cpp">// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#if 0
#include "HelloService.h"
#include &lt;thrift/transport/TBufferTransports.h&gt;
#include &lt;thrift/concurrency/ThreadManager.h&gt;
#include &lt;thrift/concurrency/PlatformThreadFactory.h&gt;
#include &lt;thrift/protocol/TBinaryProtocol.h&gt;
#include &lt;thrift/server/TSimpleServer.h&gt;
#include &lt;thrift/server/TThreadPoolServer.h&gt;
#include &lt;thrift/server/TThreadedServer.h&gt;
#include &lt;thrift/transport/TServerSocket.h&gt;
#include &lt;thrift/transport/TSocket.h&gt;
#include &lt;thrift/transport/TTransportUtils.h&gt;
#include &lt;thrift/TToString.h&gt;
#include &lt;thrift/stdcxx.h&gt;

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;

//using namespace ::apache::thrift;
//using namespace ::apache::thrift::protocol;
//using namespace ::apache::thrift::transport;
//using namespace ::apache::thrift::server;
//
//using boost::shared_ptr;
//
//using namespace  ::HelloThrift::Interface;

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

//using namespace tutorial;
//using namespace shared;
//using namespace  ::HelloThrift::Interface;
using namespace  HelloThrift;
using namespace  HelloThrift::Interface;;

class HelloServiceHandler : virtual public HelloServiceIf {
 public:
  HelloServiceHandler() {
    // Your initialization goes here
  }

  void HelloString(std::string&amp; _return, const std::string&amp; para) {
    // Your implementation goes here
    printf("HelloString,I got your name %s\n",para.c_str());
	_return = "give you back";
  }

  int32_t HelloInt(const int32_t para) {
    // Your implementation goes here
    printf("HelloInt\n");
	return para;
  }

  bool HelloBoolean(const bool para) {
    // Your implementation goes here
    printf("HelloBoolean\n");
	return para;
  }

  void HelloVoid() {
    // Your implementation goes here
    printf("HelloVoid\n");
  }

  void HelloNull(std::string&amp; _return) {
    // Your implementation goes here
    printf("HelloNull\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr&lt;HelloServiceHandler&gt; handler(new HelloServiceHandler());
  shared_ptr&lt;TProcessor&gt; processor(new HelloServiceProcessor(handler));
  shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));
  shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());
  shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

#endif


#include "HelloService.h"
#include &lt;thrift/protocol/TBinaryProtocol.h&gt;
#include &lt;thrift/server/TSimpleServer.h&gt;
#include &lt;thrift/transport/TServerSocket.h&gt;
#include &lt;thrift/transport/TBufferTransports.h&gt;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class HelloServiceHandler : virtual public HelloServiceIf {
public:
	HelloServiceHandler() {
		// Your initialization goes here
	}

	int16_t addxy(const int16_t x, const int16_t y) {
		// Your implementation goes here
		return x + y;
		printf("addxy\n");
	}

};

int main(int argc, char **argv) 
{
	printf("hello i am server\n");
	int port = 9090;
	::apache::thrift::stdcxx::shared_ptr&lt;HelloServiceHandler&gt; handler(new HelloServiceHandler());
	::apache::thrift::stdcxx::shared_ptr&lt;TProcessor&gt; processor(new HelloServiceProcessor(handler));
	::apache::thrift::stdcxx::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));
	::apache::thrift::stdcxx::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());
	::apache::thrift::stdcxx::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}
</code></pre> 
<p>其中client一样，只是需要自己写client.cpp,图如下：</p> 
<p><img alt="" class="has" height="428" src="https://images2.imgbox.com/01/f9/wwyYsozp_o.png" width="254"></p> 
<p>client.cpp代码如下：</p> 
<pre class="has"><code class="language-cpp">#include "HelloService.h"
#include &lt;thrift/concurrency/ThreadManager.h&gt;
#include &lt;thrift/concurrency/PlatformThreadFactory.h&gt;
#include &lt;thrift/protocol/TBinaryProtocol.h&gt;
#include &lt;thrift/server/TSimpleServer.h&gt;
#include &lt;thrift/server/TThreadPoolServer.h&gt;
#include &lt;thrift/server/TThreadedServer.h&gt;
#include &lt;thrift/transport/TServerSocket.h&gt;
#include &lt;thrift/transport/TSocket.h&gt;
#include &lt;thrift/transport/TTransportUtils.h&gt;
#include &lt;thrift/TToString.h&gt;
#include &lt;thrift/stdcxx.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;stdint.h&gt;

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;
using boost::shared_ptr;

int main(int argc, char** argv)
{
	stdcxx::shared_ptr&lt;TTransport&gt; socket(new TSocket("localhost", 9090));
	stdcxx::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));
	stdcxx::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));
	HelloServiceClient client(protocol);

	try
	{
		transport-&gt;open();
		int16_t x = 8;
		int16_t y = 87;
		int16_t ret = client.addxy(x, y);
		printf("testClient11111  %d\n", ret);
		getchar();
		transport-&gt;close();
	}
	catch (TException&amp; tx)
	{
		printf("ERROR:%s\n", tx.what());
	}
}</code></pre> 
<p>E:\canDel\thrift-0.12.0\tutorial\cpp\CppServer.cpp中有多种server的工作模式，运行会有不同的效果，CppServer.cpp如下所示：</p> 
<pre class="has"><code class="language-cpp">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include &lt;thrift/concurrency/ThreadManager.h&gt;
#include &lt;thrift/concurrency/PlatformThreadFactory.h&gt;
#include &lt;thrift/protocol/TBinaryProtocol.h&gt;
#include &lt;thrift/server/TSimpleServer.h&gt;
#include &lt;thrift/server/TThreadPoolServer.h&gt;
#include &lt;thrift/server/TThreadedServer.h&gt;
#include &lt;thrift/transport/TServerSocket.h&gt;
#include &lt;thrift/transport/TSocket.h&gt;
#include &lt;thrift/transport/TTransportUtils.h&gt;
#include &lt;thrift/TToString.h&gt;
#include &lt;thrift/stdcxx.h&gt;

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;

#include "../gen-cpp/Calculator.h"

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using namespace tutorial;
using namespace shared;

class CalculatorHandler : public CalculatorIf {
public:
  CalculatorHandler() {}

  void ping() { cout &lt;&lt; "ping()" &lt;&lt; endl; }

  int32_t add(const int32_t n1, const int32_t n2) {
    cout &lt;&lt; "add(" &lt;&lt; n1 &lt;&lt; ", " &lt;&lt; n2 &lt;&lt; ")" &lt;&lt; endl;
    return n1 + n2;
  }

  int32_t calculate(const int32_t logid, const Work&amp; work) {
    cout &lt;&lt; "calculate(" &lt;&lt; logid &lt;&lt; ", " &lt;&lt; work &lt;&lt; ")" &lt;&lt; endl;
    int32_t val;

    switch (work.op) {
    case Operation::ADD:
      val = work.num1 + work.num2;
      break;
    case Operation::SUBTRACT:
      val = work.num1 - work.num2;
      break;
    case Operation::MULTIPLY:
      val = work.num1 * work.num2;
      break;
    case Operation::DIVIDE:
      if (work.num2 == 0) {
        InvalidOperation io;
        io.whatOp = work.op;
        io.why = "Cannot divide by 0";
        throw io;
      }
      val = work.num1 / work.num2;
      break;
    default:
      InvalidOperation io;
      io.whatOp = work.op;
      io.why = "Invalid Operation";
      throw io;
    }

    SharedStruct ss;
    ss.key = logid;
    ss.value = to_string(val);

    log[logid] = ss;

    return val;
  }

  void getStruct(SharedStruct&amp; ret, const int32_t logid) {
    cout &lt;&lt; "getStruct(" &lt;&lt; logid &lt;&lt; ")" &lt;&lt; endl;
    ret = log[logid];
  }

  void zip() { cout &lt;&lt; "zip()" &lt;&lt; endl; }

protected:
  map&lt;int32_t, SharedStruct&gt; log;
};

/*
  CalculatorIfFactory is code generated.
  CalculatorCloneFactory is useful for getting access to the server side of the
  transport.  It is also useful for making per-connection state.  Without this
  CloneFactory, all connections will end up sharing the same handler instance.
*/
class CalculatorCloneFactory : virtual public CalculatorIfFactory {
 public:
  virtual ~CalculatorCloneFactory() {}
  virtual CalculatorIf* getHandler(const ::apache::thrift::TConnectionInfo&amp; connInfo)
  {
    stdcxx::shared_ptr&lt;TSocket&gt; sock = stdcxx::dynamic_pointer_cast&lt;TSocket&gt;(connInfo.transport);
    cout &lt;&lt; "Incoming connection\n";
    cout &lt;&lt; "\tSocketInfo: "  &lt;&lt; sock-&gt;getSocketInfo() &lt;&lt; "\n";
    cout &lt;&lt; "\tPeerHost: "    &lt;&lt; sock-&gt;getPeerHost() &lt;&lt; "\n";
    cout &lt;&lt; "\tPeerAddress: " &lt;&lt; sock-&gt;getPeerAddress() &lt;&lt; "\n";
    cout &lt;&lt; "\tPeerPort: "    &lt;&lt; sock-&gt;getPeerPort() &lt;&lt; "\n";
    return new CalculatorHandler;
  }
  virtual void releaseHandler( ::shared::SharedServiceIf* handler) {
    delete handler;
  }
};

int main() {
  TThreadedServer server(
    stdcxx::make_shared&lt;CalculatorProcessorFactory&gt;(stdcxx::make_shared&lt;CalculatorCloneFactory&gt;()),
    stdcxx::make_shared&lt;TServerSocket&gt;(9090), //port
    stdcxx::make_shared&lt;TBufferedTransportFactory&gt;(),
    stdcxx::make_shared&lt;TBinaryProtocolFactory&gt;());

  /*
  // if you don't need per-connection state, do the following instead
  TThreadedServer server(
    stdcxx::make_shared&lt;CalculatorProcessor&gt;(stdcxx::make_shared&lt;CalculatorHandler&gt;()),
    stdcxx::make_shared&lt;TServerSocket&gt;(9090), //port
    stdcxx::make_shared&lt;TBufferedTransportFactory&gt;(),
    stdcxx::make_shared&lt;TBinaryProtocolFactory&gt;());
  */

  /**
   * Here are some alternate server types...

  // This server only allows one connection at a time, but spawns no threads
  TSimpleServer server(
    stdcxx::make_shared&lt;CalculatorProcessor&gt;(stdcxx::make_shared&lt;CalculatorHandler&gt;()),
    stdcxx::make_shared&lt;TServerSocket&gt;(9090),
    stdcxx::make_shared&lt;TBufferedTransportFactory&gt;(),
    stdcxx::make_shared&lt;TBinaryProtocolFactory&gt;());

  const int workerCount = 4;

  stdcxx::shared_ptr&lt;ThreadManager&gt; threadManager =
    ThreadManager::newSimpleThreadManager(workerCount);
  threadManager-&gt;threadFactory(
    stdcxx::make_shared&lt;PlatformThreadFactory&gt;());
  threadManager-&gt;start();

  // This server allows "workerCount" connection at a time, and reuses threads
  TThreadPoolServer server(
    stdcxx::make_shared&lt;CalculatorProcessorFactory&gt;(stdcxx::make_shared&lt;CalculatorCloneFactory&gt;()),
    stdcxx::make_shared&lt;TServerSocket&gt;(9090),
    stdcxx::make_shared&lt;TBufferedTransportFactory&gt;(),
    stdcxx::make_shared&lt;TBinaryProtocolFactory&gt;(),
    threadManager);
  */

  cout &lt;&lt; "Starting the server..." &lt;&lt; endl;
  server.serve();
  cout &lt;&lt; "Done." &lt;&lt; endl;
  return 0;
}
</code></pre> 
<p>运行时，先运行server,再运行client.OK.如果有两个client,server只能响应一个client,如果把其中一个关了，就会响应后面的。</p> 
<p>后来又新建了一个client2工程，但是没有调用成功。下面查看原因--没有调用异步模式参考：<a href="https://blog.csdn.net/whycold/article/details/11019967">https://blog.csdn.net/whycold/article/details/11019967 </a></p> 
<p><a href="https://blog.csdn.net/u201012980/article/details/51867864">https://blog.csdn.net/u201012980/article/details/51867864</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef398b8d9d9a52c813934fbe8ce3bba8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在UE4里面打开一个Windows窗口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/617d1e4e56c0f5c50fe0ae92b0d28ea4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">@Results用法总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>