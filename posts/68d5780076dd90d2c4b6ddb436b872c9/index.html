<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Fragment基本使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Fragment基本使用" />
<meta property="og:description" content="阅读目录
1. Fragment概述 1.1 介绍1.2 Fragment基本生命周期2. Fragment使用 2.1 静态加载2.2 动态加载Fragment2.3 使用注意点3. Fragment与Activity联动3.1 回退栈4. Fragment与Activity通信 4.1 传递数据给Fragment4.2 传递数据给Activity5. Fragment间通信 5.1 setArguments()5.2 同Activity不同Container的Fragment交互 正文
回到顶部
1. Fragment概述 1.1 介绍 Fragment是一种可以嵌入在活动中的UI片段，能够让程序更加合理和充分地利用大屏幕的空间，出现的初衷是为了适应大屏幕的平板电脑，可以将其看成一个小型Activity，又称作Activity片段。
使用Fragment可以把屏幕划分成几块，然后进行分组，进行一个模块化管理。Fragment不能够单独使用，需要嵌套在Activity中使用，其生命周期也受到宿主Activity的生命周期的影响
官方定义如下：
A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/68d5780076dd90d2c4b6ddb436b872c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-11T11:18:32+08:00" />
<meta property="article:modified_time" content="2022-03-11T11:18:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Fragment基本使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>阅读目录</strong></p> 
<ul><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label0" rel="nofollow" title="1. Fragment概述">1. Fragment概述</a> 
  <ul><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label0_0" rel="nofollow" title="1.1 介绍">1.1 介绍</a></li></ul></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label1" rel="nofollow" title="1.2 Fragment基本生命周期">1.2 Fragment基本生命周期</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label2" rel="nofollow" title="2. Fragment使用">2. Fragment使用</a> 
  <ul><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label2_0" rel="nofollow" title="2.1 静态加载">2.1 静态加载</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label2_1" rel="nofollow" title="2.2 动态加载Fragment">2.2 动态加载Fragment</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label2_2" rel="nofollow" title="2.3 使用注意点">2.3 使用注意点</a></li></ul></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label3" rel="nofollow" title="3. Fragment与Activity联动">3. Fragment与Activity联动</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label4" rel="nofollow" title="3.1 回退栈">3.1 回退栈</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label5" rel="nofollow" title="4. Fragment与Activity通信">4. Fragment与Activity通信</a> 
  <ul><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label5_0" rel="nofollow" title="4.1 传递数据给Fragment">4.1 传递数据给Fragment</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label5_1" rel="nofollow" title="4.2 传递数据给Activity">4.2 传递数据给Activity</a></li></ul></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label6" rel="nofollow" title="5. Fragment间通信">5. Fragment间通信</a> 
  <ul><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label6_0" rel="nofollow" title="5.1 setArguments()">5.1 setArguments()</a></li><li><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_label6_1" rel="nofollow" title="5.2 同Activity不同Container的Fragment交互">5.2 同Activity不同Container的Fragment交互</a></li></ul></li></ul> 
<p></p> 
<p><strong>正文</strong></p> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label0"></a></p> 
<h3 id="autoid-0-0-0">1. Fragment概述</h3> 
<p><a name="_label0_0"></a></p> 
<h4 id="autoid-1-0-0">1.1 介绍</h4> 
<p>Fragment是一种可以嵌入在活动中的UI片段，能够让程序更加合理和充分地利用大屏幕的空间，出现的初衷是为了适应大屏幕的平板电脑，可以将其看成一个小型Activity，又称作Activity片段。</p> 
<p>使用Fragment可以把屏幕划分成几块，然后进行分组，进行一个模块化管理。Fragment不能够单独使用，需要嵌套在Activity中使用，其生命周期也受到宿主Activity的生命周期的影响</p> 
<p>官方定义如下：</p> 
<blockquote> 
 <p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p> 
</blockquote> 
<p>从官方的定义可以得到：</p> 
<ul><li>Fragment依赖于Activity，不能独立存在</li><li>一个Activity可以有多个Fragment</li><li>一个Fragment可以被多个Activity重用</li><li>Fragment有自己的生命周期，并能接收输入事件</li><li>可以在Activity运行时动态地添加或删除Fragment</li></ul> 
<p>Fragment的优势：</p> 
<ul><li>模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li><li>可重用（Reusability）：多个Activity可以重用一个Fragment。</li><li>可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li></ul> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label1"></a></p> 
<h3 id="autoid-1-1-0">1.2 Fragment基本生命周期</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/67/8b/p15H3CRs_o.jpg"></p> 
<p>Fragment的一般生命周期如上图所示：</p> 
<ul><li>onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，还可以通过getArguments()获取参数。</li><li>onCreate()：Fragment被创建时调用</li><li>onActivityCreated()：当Activity完成onCreate()时调用</li><li>onStart()：当Fragment可见时调用。</li><li>onResume()：当Fragment可见且可交互时调用</li><li>onPause()：当Fragment不可交互但可见时调用。</li><li>onStop()：当Fragment不可见时调用。</li><li>onDestroyView()：当Fragment的UI从视图结构中移除时调用。</li><li>onDestroy()：销毁Fragment时调用。</li><li>onDetach()：当Fragment和Activity解除关联时调用。</li></ul> 
<p>Fragment生命周期会经历：运行、暂停、停止、销毁。</p> 
<ul><li>运行状态：碎片可见时，关联活动处于运行状态，其也为运行状态</li><li>暂停状态：活动进入暂停状态，相关联可见碎片就会进入暂停状态</li><li>停止状态：活动进入停止状态，相关联碎片就会进入停止状态，或者通过FragmentTransaction的remove()、replace()方法将碎片从从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。</li><li>销毁状态：当活动被销毁，相关联碎片进入销毁状态。或者调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用addToBackStack()方法，碎片也会进入到销毁状态。</li></ul> 
<p>在介绍Fragment的具体使用时，先介绍一下Fragment的几个核心类</p> 
<ul><li>Fragment：Fragment的基类，任何创建的Fragment都需要继承该类</li><li>FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl。</li><li>FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord</li></ul> 
<p>扩展子类：</p> 
<ul><li>对话框：DialogFragment</li><li>列表：ListFragment</li><li>选项设置：PreferenceFragment</li><li>WebView界面：WebViewFragment</li></ul> 
<p>备注：开发Fragment不建议使用android.app下的Fragment而应是android:support.v4.app，因为support库是不断更新的。</p> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label2"></a></p> 
<h3 id="autoid-2-0-0">2. Fragment使用</h3> 
<p>使用Fragment有两种方式，分别是静态加载和动态加载</p> 
<p><a name="_label2_0"></a></p> 
<h4 id="autoid-3-0-0">2.1 静态加载</h4> 
<p>关于静态加载的流程如下：</p> 
<ul><li>定义Fragment的xml布局文件</li><li>自定义Fragment类，继承Fragment类或其子类，同时实现onCreate()方法，在方法中，通过inflater.inflate加载布局文件，接着返回其View</li><li>在需要加载Fragment的Activity对应布局文件中的name属性设为全限定类名，即包名.fragment</li><li>最后在Activity调用setContentView()加载布局文件即可</li></ul> 
<blockquote> 
 <p>静态加载一旦添加就不能在运行时删除</p> 
</blockquote> 
<p>示例：</p> 
<ul><li>定义Fragment布局，新建left_fragment.xml和right_fragment.xml文件</li></ul> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;

    &lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Button" /&gt;
&lt;/LinearLayout&gt;
</code></pre> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:background="#00ff00"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="20sp"
        android:text="this is Fragment" /&gt;

&lt;/LinearLayout&gt;
</code></pre> 
<ul><li>自定义Fragment类，继承Fragment或其子类，重写onCreateView()，在方法中调用inflater.inflate()方法加载Fragment布局文件，接着返回加载的view对象</li></ul> 
<pre><code>public class LeftFragment extends Fragment {

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.left_fragment, container,false);
        return view;
    }

}
</code></pre> 
<pre><code>public class RigthFragment extends Fragment {

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
}
</code></pre> 
<ul><li>在需要加载Fragment的Activity对应的布局文件中添加Fragment标签</li></ul> 
<pre><code>&lt;fragment
    android:id="@+id/left_fragment"
    android:name="com.vivo.a11085273.secondfragmenttest.LeftFragment"
    android:layout_width="0dp"
    android:layout_height="match_parent"
    android:layout_weight="1" /&gt;
&lt;fragment
    android:id="@+id/right_fragment"
    android:name="com.vivo.a11085273.secondfragmenttest.RigthFragment"
    android:layout_width="0dp"
    android:layout_height="match_parent"
    android:layout_weight="1"
    /&gt;
</code></pre> 
<ul><li>在Activity的onCreate()方法中调用setContentView()加载布局文件即可</li></ul> 
<p><a name="_label2_1"></a></p> 
<h4 id="autoid-3-1-0">2.2 动态加载Fragment</h4> 
<p>动态加载Fragment的流程如下：</p> 
<ul><li>获得FragmentManager对象，通过getSupportFragmentManager()</li><li>获得FragmentTransaction对象，通过fm.beginTransaction()</li><li>调用add()方法或者repalce()方法加载Fragment；</li><li>最后调用commit()方法提交事务</li></ul> 
<p>简单示例：</p> 
<ul><li>同静态加载一样，首先定义Fragment的布局和类，修改主布局文件，不指定标签的name属性。</li><li>实现Fragment调用</li></ul> 
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RigthFragment());
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                replaceFragment(new AnotherRightFragment());
                break;
            default:
                break;
        }
    }

    private void replaceFragment(Fragment fragment) {
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();   // 开启一个事务
        transaction.replace(R.id.right_layout, fragment);
        transaction.commit();
    }
}
</code></pre> 
<p><a name="_label2_2"></a></p> 
<h4 id="autoid-3-2-0">2.3 使用注意点</h4> 
<ul><li>Fragment的onCreateView()方法返回Fragment的UI布局，需要注意的是inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常：</li></ul> 
<blockquote> 
 <p>Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child’s parent first.</p> 
</blockquote> 
<ul><li>如果在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据</li></ul> 
<p>可以在Fragment的onAttach()中通过getArguments()获得传进来的参数。如果要获取Activity对象，不建议调用getActivity()，而是在onAttach()中将Context对象强转为Activity对象</p> 
<p>示例：</p> 
<pre><code>public class Fragment1 extends Fragment{
    private static String ARG_PARAM = "param_key";
    private String mParam;
    private Activity mActivity;
    public void onAttach(Context context) {
        mActivity = (Activity) context;
        mParam = getArguments().getString(ARG_PARAM);  //获取参数
    }
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.fragment_1, container, false);
        TextView view = root.findViewById(R.id.text);
        view.setText(mParam);
        return root;
    }
    public static Fragment1 newInstance(String str) {
        Fragment1 frag = new Fragment1();
        Bundle bundle = new Bundle();
        bundle.putString(ARG_PARAM, str);
        fragment.setArguments(bundle);   //设置参数
        return fragment;
    }
}
</code></pre> 
<ul><li> <p>动态加载Fragment中，FragmentTransaction类提供了方法完成增删等操作，完成后调用FragmentTransaction.commit()方法提交修改</p> 
  <ul><li>transaction.add()：往Activity里面添加一个片段</li><li>transaction.remove()：从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁</li><li>transaction.replace()：使用另一个Fragment替换当前的，实际上是remove()然后add()的合体</li><li>transaction.hide()：隐藏当前Fragment，仅不可见，不会销毁</li><li>transaction.show()：显示之前隐藏的Fragment</li><li>detach()：会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护</li><li>attach()：重建view视图，附加到UI上并显示。</li></ul></li></ul> 
<p>commit方法一定要在Activity.onSaveInstance()之前调用</p> 
<p>commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。</p> 
<ul><li> <p>FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</p> </li><li> <p>Fragment常见异常</p> </li></ul> 
<blockquote> 
 <p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState<br><br> at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)<br><br> at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)<br><br> at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)<br><br> at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</p> 
</blockquote> 
<p>出现原因：commit()在onSaveInstanceState()后调用。</p> 
<p>由于onSaveInstanceState()在onPause()之后，onStop()之前调用。onRestoreInstanceState()在onStart()之后，onResume()之前，因此避免出现该异常的方案有：</p> 
<ul><li>不要把Fragment事务放在异步线程的回调中</li><li>逼不得已时使用commitAllowingStateLoss()</li></ul> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label3"></a></p> 
<h3 id="autoid-3-3-0">3. Fragment与Activity联动</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/5f/6e/N95bT9mn_o.jpg"></p> 
<p>Fragment和Activity完整的生命周期如上图所示</p> 
<ol><li>当Fragment在Activity的onCreate()中被添加时</li></ol> 
<ul><li>Activity super.onCreate执行完毕</li><li>Fragment onAttach</li><li>Fragment onCreate</li><li>Fragment onCreateView</li><li>Fragment onViewCreated</li><li>Activity.super.onStart()执行中</li><li>Fragment onActivityCreated</li><li>Fragment onViewStateRestored</li><li>Fragment onStart()</li><li>Activity super.onStart执行完毕</li><li>Activity super.onPostCreate()</li><li>Activity super.onResume()</li><li>Activity super.onPostResume()执行中</li><li>Fragment onResume()</li><li>Activity super.onPosResume()执行完毕</li><li>Activity onAttachedToWindow()</li><li>Activity onCreateOptionsMenu()</li><li>Fragment onCreateOptionsMenu()</li><li>Activity onPrepareOptionsMenu()</li><li>Fragment onPrepareOptionsMenu()</li><li>Activity onWindowFocusChanged()</li></ul> 
<ol><li>暂停生命周期</li></ol> 
<ul><li>Activity super.onPause()执行中</li><li>Fragment.onPause()</li><li>Activity super.onPause()执行完毕</li><li>Activity super.onSaveInstanceState()执行中</li><li>Fragment onSaveInstanceState()</li><li>Activity super.onSaveInstanceState()执行完毕</li><li>Activity super.onStop()执行中</li><li>Fragment onStop()</li><li>Activity super.onStop()执行完毕</li></ul> 
<ol><li>销毁的生命周期</li></ol> 
<ul><li>Activity super.onDestroy()执行中</li><li>Fragment onDestroyView()</li><li>Fragment onDestroy()</li><li>Fragment onDetach()</li><li>Activity super.onDestroy()执行完毕</li></ul> 
<ol><li>重启的生命周期</li></ol> 
<ul><li>Activity super.onRestart()</li><li>Activity super.onStart()执行中</li><li>Fragment onStart()</li><li>Activity super.onStart()执行完毕</li><li>Activity super.onResume()</li><li>Activity super.onPostResume()执行中</li><li>Fragment onResume()</li><li>Activity super.onPosResume()执行完毕</li><li>Activity onWindowFocusChanged()执行完毕</li></ul> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label4"></a></p> 
<h3 id="autoid-4-0-0">3.1 回退栈</h3> 
<p>类似Android系统为Activity维护一个任务栈，我们也可以通过Activity维护一个回退栈来保存每次Fragment事务发生的变化。如果你将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。</p> 
<p>一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity</p> 
<p>添加一个Fragment事务到回退栈：</p> 
<pre><code>FragmentTransaction.addToBackStack(String)
</code></pre> 
<p>简单示例：</p> 
<pre><code>private void replaceFragment(Fragment fragment) {
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.replace(R.id.right_layout, fragment);
    transaction.addToBackStack(null);   //添加进回退栈
    transaction.commit();
}
</code></pre> 
<p>replace是remove和add的合体，并且如果不添加事务到回退栈，前一个Fragment实例会被销毁。这里很明显，我们调用transaction.addToBackStack(null);将当前的事务添加到了回退栈，所以FragmentOne实例不会被销毁，但是视图层次依然会被销毁，即会调用onDestoryView和onCreateView</p> 
<p>如果不希望视图重绘，可以将原来的Fragment隐藏：</p> 
<pre><code>private void replaceFragment(Fragment fragment) {
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.hide(this);
    transaction.add(R.id.right_layout, fragment);
    transaction.addToBackStack(null);   //添加进回退栈
    transaction.commit();
}
</code></pre> 
<p>JAVA 复制 全屏</p> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label5"></a></p> 
<h3 id="autoid-5-0-0">4. Fragment与Activity通信</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/72/87/37CZz9xw_o.jpg"></p> 
<p>Fragment与Activity的通信交互如上图所示：</p> 
<ul><li>如果Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</li><li>如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作</li><li>在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作。</li></ul> 
<p>备注：</p> 
<ul><li>如果在Fragment中需要Context，可以通过getActivity()，如果该Context需要在Activity被销毁后还存在，则使用getActivity.getApplicationContext();</li></ul> 
<p>考虑Fragment的重复使用问题，降低与Activity的耦合，Fragment操作应该由它的管理者Activity决定。</p> 
<p><a name="_label5_0"></a></p> 
<h4 id="autoid-6-0-0">4.1 传递数据给Fragment</h4> 
<p>步骤流程：</p> 
<ul><li>在Activity中创建Bundle数据包，调用Fragment实例的setArguments()，将Bundle数据包传给Fragment</li><li>Fragment调用getArguments()获得Bundle对象，然后进行解析就可以</li></ul> 
<p>简单示例：</p> 
<pre><code>//创建Fragment对象，并通过Bundle对象传递值（在onCreate方法中）
MyFragment fragment = new MyFragment();
Bundle bundle = new Bundle();
bundle.putString("key", values);
fragment.setArguments(bundle);
</code></pre> 
<pre><code>//（在Fragment类中的onCreateView方法中）
Bundle bundle = this.getArguments();
    if (bundle != null)
    {
        String str = bundle.getString("key");
    }
    TextView textView = new TextView(getActivity());
    textView.setText("上上下下的享受");//是电梯，别误会
</code></pre> 
<p><a name="_label5_1"></a></p> 
<h4 id="autoid-6-1-0">4.2 传递数据给Activity</h4> 
<p>步骤流程：</p> 
<ul><li>在Fragment中定义一个内部回调接口，再让包含该Fragment的Activity实现该回调接口</li><li>Fragment通过回调接口传数据</li></ul> 
<p>简单示例：</p> 
<ul><li>首先在Fragment中定义一个接口（定义抽象方法，传什么类型参数）</li></ul> 
<pre><code>/*接口*/  
public interface Mylistener{
    public void thanks(String code);
}
</code></pre> 
<ul><li>Fragment类中定义该接口</li></ul> 
<pre><code>private Mylistener listener;

</code></pre> 
<ul><li>在onAttach方法中，将定义的该接口强转为activity类型</li></ul> 
<pre><code>@Override
    public void onAttach(Activity activity) {
        // TODO Auto-generated method stub
        listener=(Mylistener) activity;
        super.onAttach(activity);
    }
</code></pre> 
<ul><li>Activity只需实现该接口并重写该方法即可</li></ul> 
<pre><code>@Override
    public void thanks(String code) {
        // TODO Auto-generated method stub
        Toast.makeText(this, "已收到Fragment的消息：--"+code+"--,客气了", Toast.LENGTH_SHORT).show();;
    }
</code></pre> 
<p>除了接口回调，还可以使用EventBus进行交互通信。</p> 
<p><a href="https://www.cnblogs.com/linhaostudy/p/14673871.html#_labelTop" rel="nofollow" title="回到顶部">回到顶部</a><a name="_label6"></a></p> 
<h3 id="autoid-6-2-0">5. Fragment间通信</h3> 
<p><a name="_label6_0"></a></p> 
<h4 id="autoid-7-0-0">5.1 setArguments()</h4> 
<p>示例：</p> 
<ul><li>在Fragment B中新建一个函数：newInstance()接收传过来的参数</li></ul> 
<pre><code>public static Fragment2 newInstance(String text) {
        Fragment2 fragment = new Fragment2();
        Bundle args = new Bundle();
        args.putString("param", text);
        fragment.setArguments(args);
        return fragment;
    }
</code></pre> 
<ul><li>在Fragment B的onCreateView中获取参数</li></ul> 
<pre><code>    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view =  inflater.inflate(R.layout.fragment2, container, false);
        if (getArguments() != null) {
            String mParam1 = getArguments().getString("param");
            TextView tv =  (TextView)view.findViewById(R.id.textview);
            tv.setText(mParam1);
        }
        return view;
    }
</code></pre> 
<ul><li>在Fragment A中，调用Fragment B时，通过newInstance函数获取实例并传递参数：</li></ul> 
<pre><code>public class Fragment1 extends Fragment {
 
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment1, container, false);
        Button btn = (Button)view.findViewById(R.id.load_fragment2_btn);
        btn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(final View view) {
                Fragment2 fragment2 = Fragment2.newInstance("从Fragment1传来的参数");
 
                FragmentTransaction transaction = getFragmentManager().beginTransaction();
                transaction.add(R.id.main_layout, fragment2);
                transaction.addToBackStack(null);
                transaction.commit();
            }
        });
        return view;
    }
}
</code></pre> 
<p><a name="_label6_1"></a></p> 
<h4 id="autoid-7-1-0">5.2 同Activity不同Container的Fragment交互</h4> 
<p>这种情况有三中方法解决：</p> 
<p><strong>方法一：直接在Activity中操作</strong></p> 
<p>​ 直接在Activity中找到对应控件的实例，然后直接操控即可</p> 
<p><strong>方法二：直接在Fragment中操作</strong></p> 
<p>​ 这里有两个问题：如何获取自己控件的引用？如何获取其他Fragment页控件的引用？</p> 
<ul><li>首先获取自己控件的引用</li></ul> 
<p>可以在onCreateView()中获取</p> 
<pre><code>public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    View rootView = inflater.inflate(R.layout.fragment1, container, false);
    listView = (ListView)rootView.findViewById(R.id.list);//获取自己视图里的控件引用,方法一
    return rootView;
}
</code></pre> 
<p>在onCreateView()中，还没有创建视图，所以在这里如果使用getView()方法将返回空</p> 
<p>另一种方法是在onActivityCreated()中获取，其回调在onCreate()执行后再执行</p> 
<pre><code>public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
 
    listView = (ListView) getView().findViewById(R.id.list);//获取自己视图里的控件引用,方法二
}
</code></pre> 
<ul><li>获取其它Fragment页控件引用方法</li></ul> 
<p>获取Activity资源，须等Activity创建完成后，必须放在onActivityCreated()回调函数中</p> 
<pre><code>public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
 
    mFragment2_tv = (TextView) getActivity().findViewById(R.id.fragment2_tv);//获取其它fragment中的控件引用的唯一方法!!!
 
}
</code></pre> 
<p>总的实现示例如下：</p> 
<pre><code>public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
 
    mFragment2_tv = (TextView) getActivity().findViewById(R.id.fragment2_tv);//获取其它fragment中的控件引用的唯一方法!!!
    listView = (ListView) getView().findViewById(R.id.list);//获取自己视图里的控件引用,方法二
 
    ArrayAdapter arrayAdapter = new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, mStrings);
    listView.setAdapter(arrayAdapter);
    listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            String str = mStrings[position];
            mFragment2_tv.setText(str);
       }
    });
}
</code></pre> 
<p>方法三：在各自Fragment中操作</p> 
<p>方法二在Fragment A中操作了Fragment B，违背模块分离思想，应通过Activity将其分离</p> 
<p>在Activity中可以直接通过FragmentManager.findFragmentById()获取Fragment实例</p> 
<p>示例：</p> 
<p>在Fragment2设置TextView函数</p> 
<pre><code>public class Fragment2 extends Fragment {
    private TextView mTv;
    …………
    public void setText(String text) {
        mTv.setText(text);
    }
}
</code></pre> 
<p>在Fragment1 中定义处理方式</p> 
<ul><li>定义接口与变量</li></ul> 
<pre><code>private titleSelectInterface mSelectInterface;
 
public interface titleSelectInterface{
    public void onTitleSelect(String title);
}
</code></pre> 
<ul><li>接口变量赋值</li></ul> 
<p>接口给Activity使用，在Activity中给接口变量赋值，在Fragment与Activity关联时，需要强转</p> 
<pre><code>public void onAttach(Activity activity) {
    super.onAttach(activity);
 
    try {
        mSelectInterface = (titleSelectInterface) activity;
    } catch (Exception e) {
        throw new ClassCastException(activity.toString() + "must implement OnArticleSelectedListener");
    }
}
</code></pre> 
<ul><li>调用接口变量</li></ul> 
<pre><code>public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
 
    listView = (ListView) getView().findViewById(R.id.list);//获取自己视图里的控件引用,方法二
    ArrayAdapter arrayAdapter = new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, mStrings);
    listView.setAdapter(arrayAdapter);
    listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            String str = mStrings[position];
            mSelectInterface.onTitleSelect(str);
        }
    });
}
</code></pre> 
<ul><li>在Activity中实现接口</li></ul> 
<pre><code>public class MainActivity extends FragmentActivity implements Fragment1.titleSelectInterface {
 
    ……
    
    @Override
    public void onTitleSelect(String title) {
        FragmentManager manager = getSupportFragmentManager();
        Fragment2 fragment2 = (Fragment2)manager.findFragmentById(R.id.fragment2);
        fragment2.setText(title);
    }
}
</code></pre> 
<p> </p> 
<p></p> 
<p>转发自：</p> 
<p>Fragment基本使用 - yooooooo - 博客园<br> https://www.cnblogs.com/linhaostudy/p/14673871.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d528037864fd8336a451a93b7121b7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql&#43;mycat&#43;keepalive&#43;haproxy高可用集群(一)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30e8680dd8c734d2cf02593483ccf707/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络攻防——被攻击日志</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>