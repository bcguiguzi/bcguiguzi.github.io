<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之链式二叉树续 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之链式二叉树续" />
<meta property="og:description" content="1.获取叶节点个数 获取叶子结点个数，我们这里也用递归的方法
利用分治思想去解决这个问题
●代码思想：
1. 当遇到空树或者遇到空的节点时，也就是说这是的叶子为NULL，这是我们返回0
2. 当遇到左节点或者右节点为空，当节点不为空时，此时已经到达了叶子结点，所以返回1
3. 当遇到的不是叶节点时，我们需要到递归左节点的个数和右节点的个数，并进行递归返回
●代码思想：
对于整棵树来说，当我们遇到空树或者遇到节点为空的时候，这时的叶子结点为空，我们这时返回0，当不是上中情况的时候，我们从根往下去搜索，先搜索左节点，当左节点不为空，并且左节点的左子树和右子树都是空的时候，这时候就可以确定它是叶子了，也就是返回1，当搜索完左子树就可以搜索右子树，右子树也同理 2.获取树的高度 获取树的高度，我们也是利用分治的思想去实现这个代码
首先就是当我们要想返回高度的时候，我们需要调用到左右子树的高度
然后比较左右子树的高度，比较出最大的一个并返回
然后加1（因为我们递归的是左右子树的高度，我们需要整个树的高度，所以还需要加上根，也就是加一）
●代码思想：
1.当我们遇到空树或者遇到的节点为NULL，这时返回0
2.然后接下来去递归左子树和右子树
3.返回时，如果左子树大于右子树，那么就是左子树高度&#43;1，否则右子树高度&#43;1
//获取树的高度 int TreeHeight(BTNode* root) { if (root == NULL) { return 0; } TreeHeight(root-&gt;left); TreeHeight(root-&gt;right); return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ? TreeHeight(root-&gt;left) : TreeHeight(root-&gt;right)) &#43; 1; } 但这个代码有一定的缺陷
我们可以看到，这个代码我们调用了两次TreeHeight(root-&gt;left)和TreeHeight(root-&gt;right)
在这一树中，我们调用多次函数，大大增加了计算的难度，在一棵小树中可能不明显，可当树更大时，这时候弊端就先显示出来了
所以我们可以改进一下代码，定义两个变量去接受返回值
然后比较两个返回值
//改进代码 int TreeHeight(BTNode* root) { if (root == NULL) { return 0; } /*TreeHeight(root-&gt;left); TreeHeight(root-&gt;right); return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/29ed223e9d6a0eed18971410e4000041/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T13:55:49+08:00" />
<meta property="article:modified_time" content="2024-03-15T13:55:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之链式二叉树续</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.获取叶节点个数</h2> 
<p>获取叶子结点个数，我们这里也用递归的方法</p> 
<p>利用分治思想去解决这个问题</p> 
<p>●代码思想：</p> 
<p><strong>1. </strong>当遇到空树或者遇到空的节点时，也就是说这是的叶子为NULL，这是我们返回0</p> 
<p><strong>2. </strong>当遇到左节点或者右节点为空，当节点不为空时，此时已经到达了叶子结点，所以返回1</p> 
<p><strong>3. </strong>当遇到的不是叶节点时，我们需要到递归左节点的个数和右节点的个数，并进行递归返回</p> 
<p>●代码思想：</p> 
<p>对于整棵树来说，当我们遇到空树或者遇到节点为空的时候，这时的叶子结点为空，我们这时返回0，当不是上中情况的时候，我们从根往下去搜索，先搜索左节点，当左节点不为空，并且左节点的左子树和右子树都是空的时候，这时候就可以确定它是叶子了，也就是返回1，当搜索完左子树就可以搜索右子树，右子树也同理 </p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/34/21/EjwIkZmE_o.png" width="1200"></p> 
<h2>2.获取树的高度 </h2> 
<p>获取树的高度，我们也是利用分治的思想去实现这个代码</p> 
<p>首先就是当我们要想返回高度的时候，我们需要调用到左右子树的高度</p> 
<p>然后比较左右子树的高度，比较出最大的一个并返回</p> 
<p><strong>然后加1</strong>（因为我们递归的是左右子树的高度，我们需要整个树的高度，所以还需要加上根，也就是加一）</p> 
<p>●代码思想：</p> 
<p>1.当我们遇到空树或者遇到的节点为NULL，这时返回0</p> 
<p>2.然后接下来去递归左子树和右子树</p> 
<p>3.返回时，如果左子树大于右子树，那么就是左子树高度+1，否则右子树高度+1</p> 
<pre><code class="language-cpp">//获取树的高度
int TreeHeight(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	TreeHeight(root-&gt;left);
	TreeHeight(root-&gt;right);

	return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ? TreeHeight(root-&gt;left) : TreeHeight(root-&gt;right)) + 1;
}
</code></pre> 
<p>但这个代码有一定的缺陷</p> 
<p>我们可以看到，这个代码我们调用了两次TreeHeight(root-&gt;left)和TreeHeight(root-&gt;right)</p> 
<p>在这一树中，我们调用多次函数，大大增加了计算的难度，在一棵小树中可能不明显，可当树更大时，这时候弊端就先显示出来了</p> 
<p>所以我们可以改进一下代码，定义两个变量去接受返回值</p> 
<p>然后比较两个返回值</p> 
<pre><code class="language-cpp">//改进代码
int TreeHeight(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	/*TreeHeight(root-&gt;left);
	TreeHeight(root-&gt;right);

	return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ? TreeHeight(root-&gt;left) : TreeHeight(root-&gt;right)) + 1;*/
	int Heightleft = TreeHeight(root-&gt;left);
	int Heightright = TreeHeight(root-&gt;right);

	return (Heightleft &gt; Heightright ? Heightleft : Heightright + 1);
}
</code></pre> 
<p><img alt="" height="722" src="https://images2.imgbox.com/7a/e1/DnMlGxim_o.png" width="1200"></p> 
<h2>3.计算第K层节点个数 </h2> 
<p>计算k层节点的个数，我们可以看成计算左节点的（k-1）层和右节点（k-1）层的节点个数</p> 
<p>因为我们不算顶部节点所以应该是k-1</p> 
<p>●代码思想：</p> 
<p>首先是如果是空树或者当遇到叶子结点外的空节点时，返回0</p> 
<p>当遇到k为1的时候，这时只有一个根，也就返回1</p> 
<p>其余情况均利用递归思想，去递归左右子树，<strong>注意此时的k应该变成k-1</strong></p> 
<pre><code class="language-cpp">//计算树k层的节点个数
int TreeKCount(BTNode* root, int k)
{
	if (root == NULL || k &lt; 1)
	{
		return 0;
	}
	if (k == 1)
	{
		return 1;
	}
	return TreeKCount(root-&gt;left, k - 1) + TreeKCount(root-&gt;right, k - 1);
}</code></pre> 
<p><img alt="" height="699" src="https://images2.imgbox.com/e1/d0/yl2wxtxN_o.png" width="1200"></p> 
<h2 style="background-color:transparent;">4.寻找某个节点 </h2> 
<p>寻找某个节点的话，我们也利用递归的方法，分治的思想去解决这个问题</p> 
<p>寻找某个节点，那么这个节点如果不在根上，那么就在根的左子树和右子树上</p> 
<p>那么就想下寻找</p> 
<p>下边的节点也可以分为左子树和右子树和根</p> 
<p>依次进行，就形成了递归</p> 
<pre><code class="language-cpp">//寻找某个节点
BTNode* TreeFind(BTNode* root, int x)
{
	if (root == NULL)
	{
		return 0;
	}
	if (x == root-&gt;val)
	{
		return root;
	}
	TreeFind(root-&gt;left, x);
	TreeFind(root-&gt;right, x);
    return NULL;
}</code></pre> 
<p>很多人可能会想到这样的代码</p> 
<p>可当我们去运行的时候，我们会发现找不到，不管x为多少都找不到</p> 
<p>为什么呢？</p> 
<p>原因是我们没有东西去接收</p> 
<p>当我们找到的时候，我们递归需要往上递归</p> 
<p>可上边的栈中没有可以接受的变量值</p> 
<p>所以我们最终遍历完整棵树也找不到我们想找的节点</p> 
<p>所以改一下代码</p> 
<pre><code class="language-cpp">//寻找某个节点
BTNode* TreeFind(BTNode* root, int x)
{
	if (root == NULL)
	{
		return 0;
	}
	if (x == root-&gt;val)
	{
		return root;
	}
	BTNode* ret1 = TreeFind(root-&gt;left, x);
	BTNode* ret2 = TreeFind(root-&gt;right, x);
	if (ret1)
		return ret1;
	if (ret2)
		return ret2;
	return NULL;
}</code></pre> 
<p>这样我们利用新建立的节点去接受我们的左右子树的数据</p> 
<p>然后如果不为空就不断返回，为空那么就返回0</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/704a9e0059b8ecb66396e4f536cfde73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot集成mapstruct快速入门指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e86f8abe77ceac5713f6b34c4ed5d93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java毕业设计-基于springboot开发的会员制医疗预约服务管理信息系统-毕业论文&#43;答辩PPT（附源代码&#43;演示视频）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>