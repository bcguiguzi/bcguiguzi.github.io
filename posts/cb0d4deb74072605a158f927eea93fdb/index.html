<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis || 内存策略 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis || 内存策略" />
<meta property="og:description" content="Redis内存回收 Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。
我们可以通过修改配置文件来设置Redis的最大内存：
# 格式： # maxmemory &lt;bytes&gt; # 例如： maxmemory 1gb 当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：
-- 内存过期策略
-- 内存淘汰策略
过期策略 可以通过expire命令给Redis的key设置TTL（存活时间）：
可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。
过期策略-DB结构 Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。
typedef struct redisDb { dict *dict; /* 存放所有key及value的地方，也被称为keyspace*/ dict *expires; /* 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID，0~15 */ long long avg_ttl; /* 记录平均TTL时长 */ unsigned long expires_cursor; /* expire检查时在dict中抽样的索引位置." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cb0d4deb74072605a158f927eea93fdb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-08T23:07:46+08:00" />
<meta property="article:modified_time" content="2023-09-08T23:07:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis || 内存策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">Redis内存回收</h2> 
<p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。</p> 
<p>我们可以通过修改配置文件来设置Redis的最大内存：</p> 
<pre><code class="language-bash"># 格式：
# maxmemory &lt;bytes&gt;
# 例如：
maxmemory 1gb</code></pre> 
<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p> 
<p>-- 内存过期策略</p> 
<p>-- 内存淘汰策略</p> 
<h2>过期策略</h2> 
<p>可以通过expire命令给Redis的key设置TTL（存活时间）：</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/f9/89/RqnF3gSm_o.png" width="882"></p> 
<p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p> 
<h3>过期策略-DB结构</h3> 
<p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p> 
<pre><code class="language-cpp">typedef struct redisDb {
    dict *dict;                 /* 存放所有key及value的地方，也被称为keyspace*/
    dict *expires;              /* 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID，0~15 */
    long long avg_ttl;          /* 记录平均TTL时长 */
    unsigned long expires_cursor; /* expire检查时在dict中抽样的索引位置. */
    list *defrag_later;         /* 等待碎片整理的key列表. */
} redisDb;
</code></pre> 
<p><img alt="" height="798" src="https://images2.imgbox.com/88/eb/Guk6f39z_o.png" width="1200"></p> 
<p>Redis是如何知道一个key是否过期呢？</p> 
<p>        -- 利用两个Dict分别记录key-value对及key-ttl对</p> 
<p>是不是TTL到期就立即删除了呢？</p> 
<p>        -- 惰性删除</p> 
<p>        -- 周期删除</p> 
<h3>过期策略-惰性删除</h3> 
<p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p> 
<pre><code class="language-cpp">// 查找一个key执行写操作
robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags) {
    // 检查key是否过期
    expireIfNeeded(db,key);
    return lookupKey(db,key,flags);
}
// 查找一个key执行读操作
robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
    robj *val;
    // 检查key是否过期    
    if (expireIfNeeded(db,key) == 1) {
        // ...略
    }
    return NULL;
}</code></pre> 
<pre><code class="language-cpp">int expireIfNeeded(redisDb *db, robj *key) {
    // 判断是否过期，如果未过期直接结束并返回0
    if (!keyIsExpired(db,key)) return 0;
    // ... 略
    // 删除过期key
    deleteExpiredKeyAndPropagate(db,key);
    return 1;
}</code></pre> 
<h3>过期策略-周期删除</h3> 
<p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：</p> 
<p>-- Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW。</p> 
<p>-- Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST。</p> 
<pre><code class="language-cpp">// server.c
void initServer(void){
    // ...
    // 创建定时器，关联回调函数serverCron，处理周期取决于server.hz，默认10
    aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) 
}</code></pre> 
<pre><code class="language-cpp">// server.c
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // 更新lruclock到当前时间，为后期的LRU和LFU做准备
    unsigned int lruclock = getLRUClock();
    atomicSet(server.lruclock,lruclock);
    // 执行database的数据清理，例如过期key处理
    databasesCron();
}
</code></pre> 
<pre><code class="language-cpp">void databasesCron(void) {
    // 尝试清理部分过期key，清理模式默认为SLOW
    activeExpireCycle(
          ACTIVE_EXPIRE_CYCLE_SLOW);
}</code></pre> 
<pre><code class="language-cpp">void beforeSleep(struct aeEventLoop *eventLoop){
    // ...
    // 尝试清理部分过期key，清理模式默认为FAST
    activeExpireCycle(
         ACTIVE_EXPIRE_CYCLE_FAST);
}</code></pre> 
<p><img alt="" height="222" src="https://images2.imgbox.com/f8/56/0VEP31yE_o.png" width="733"></p> 
<p>SLOW模式规则：</p> 
<p>1. 执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</p> 
<p>2. 执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</p> 
<p>3. 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p> 
<p>4. 如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</p> 
<p>FAST模式规则（过期key比例小于10%不执行 ）：</p> 
<p>1. 执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</p> 
<p>2. 执行清理耗时不超过1ms</p> 
<p>3. 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p> 
<p>4. 如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束。</p> 
<p>RedisKey的TTL记录方式：</p> 
<p>-- 在RedisDB中通过一个Dict记录每个Key的TTL时间</p> 
<p>过期key的删除策略：</p> 
<p>1. 惰性清理：每次查找key时判断是否过期，如果过期则删除。</p> 
<p>2. 定期清理：定期抽样部分key，判断是否过期，如果过期则删除。</p> 
<p>定期清理的两种模式：</p> 
<p>1. SLOW模式执行频率默认为10，每次不超过25ms。</p> 
<p>2. FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms。</p> 
<h2>淘汰策略</h2> 
<p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：</p> 
<pre><code class="language-cpp">int processCommand(client *c) {
    // 如果服务器设置了server.maxmemory属性，并且并未有执行lua脚本
    if (server.maxmemory &amp;&amp; !server.lua_timedout) {
        // 尝试进行内存淘汰performEvictions
        int out_of_memory = (performEvictions() == EVICT_FAIL);
        // ...
        if (out_of_memory &amp;&amp; reject_cmd_on_oom) {
            rejectCommand(c, shared.oomerr);
            return C_OK;
        }
        // ....
    }
}</code></pre> 
<p>Redis支持8种不同策略来选择要删除的key：</p> 
<p>1、noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p> 
<p>2、volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。</p> 
<p>3、allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选。</p> 
<p>4、volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p> 
<p>5、allkeys-lru： 对全体key，基于LRU算法进行淘汰。</p> 
<p>6、volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰。</p> 
<p>7、allkeys-lfu： 对全体key，基于LFU算法进行淘汰。</p> 
<p>8、volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰。</p> 
<p><img alt="" height="154" src="https://images2.imgbox.com/6b/88/XlpS2Zqr_o.png" width="563"></p> 
<p>比较容易混淆的有两个：</p> 
<p>-- LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p> 
<p>-- LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p> 
<p>Redis的数据都会被封装为RedisObject结构：</p> 
<pre><code class="language-cpp">typedef struct redisObject {
    unsigned type:4;        // 对象类型
    unsigned encoding:4;    // 编码方式
    unsigned lru:LRU_BITS;  // LRU：以秒为单位记录最近一次访问时间，长度24bit
        // LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数
    int refcount;           // 引用计数，计数为0则可以回收
    void *ptr;              // 数据指针，指向真实数据
} robj;</code></pre> 
<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p> 
<p>1、生成0~1之间的随机数R</p> 
<p>2、计算 (旧次数 * lfu_log_factor + 1)，记录为P</p> 
<p>3、如果 R &lt; P ，则计数器 + 1，且最大不超过255</p> 
<p>4、访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</p> 
<p><img alt="" height="792" src="https://images2.imgbox.com/c2/e8/LruYtGDe_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f6e5187114367ee3ac0865b111d8aac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows安装稳定版MySql-8.0.19.msi详细步骤（附安装包mysql&#43;workbench）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ebc5fa2b40b470945b22fa9931ee4b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">线程池自定义线程工厂并实现三个线程循环输出1-100</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>