<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构中的平衡搜索树 --- AVL树是怎样进行旋转处理的？（平衡因子版本） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构中的平衡搜索树 --- AVL树是怎样进行旋转处理的？（平衡因子版本）" />
<meta property="og:description" content="目录
前言
搜索二叉树
AVL树
节点的定义
插入
旋转
前言
搜索二叉树 搜索二叉树 又称 二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 示例：
具体可以查看搜索二叉树
但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树（或接近单只树），二叉搜索树的性能就失去了，并且 时间复杂度会退化成O(N)，因此需要对底层结构进行平衡处理，即采用平衡树（AVL树、红黑树）来实现，使二叉搜索树的性能都能达到最优. AVL树 AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查 找元素相当于在顺序表中搜索元素，效率低下 。因此，两位俄罗斯的数学家 G.M.Adelson-Velskii和E.M.Landis 在 1962 年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右 子树高度之差的绝对值不超过 1( 需要对树中的结点进行调整 ) ，即可降低树的高度，从而减少平均搜索长度。 一棵 AVL 树或者是空树，或者是具有以下性质的二叉搜索树： 它的左右子树都是AVL树 左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1） --- 一般是右子树减去左子树等于根 如果一棵二叉搜索树是高度平衡的，它就是 AVL 树。如果它有 n 个结点，其高度可保持在 $O(log_2 n)$ ，搜索时间复杂度 O($log_2 n$) 。 AVL树节点的定义 template&lt;class K, class V&gt; class AVLTreeNode { AVLTreeNode&lt;K,V&gt;* _left;	//左子树节点 AVLTreeNode&lt;K, V&gt;* _right;	//右子树节点 AVLTreeNode&lt;K, V&gt;* _parent;	//父节点 pair&lt;K, V&gt; _kv; int _bf; //balance factor :平衡因子 AVLTreeNode(const pair&lt;K, V&gt;&amp; kv) :_left(nullptr) , _right(nullptr) , _parent(nullptr) ,_kv(kv) ,_bf(0) {} }; AVL树的插入 AVL 树就是在二叉搜索树的基础上引入了平衡因子，因此 AVL 树也可以看成是二叉搜索树。那么AVL树的插入过程可以分为两步： 按照二叉搜索树的方式插入新节点 调整节点的平衡因子 template&lt;class K,class V&gt; class AVLTree { typedef AVLTreeNode&lt;K, V&gt; Node; public: bool insert(const pair&lt;K, V&gt;&amp; kv) { //_root为空 if (_root == nullptr) { _root = new Node(kv); return true; } //_root不为空 Node* cur = _root; Node* parent = nullptr; //记录cur的父节点，方便进行链接 while (cur) { if (kv." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8a4e3d52e53fea3de0fbc925a29783df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T17:49:09+08:00" />
<meta property="article:modified_time" content="2024-03-12T17:49:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构中的平衡搜索树 --- AVL树是怎样进行旋转处理的？（平衡因子版本）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        搜索二叉树</a></p> 
<p id="AVL%E6%A0%91-toc" style="margin-left:40px;"><a href="#AVL%E6%A0%91" rel="nofollow">AVL树</a></p> 
<p id="%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">节点的定义</a></p> 
<p id="%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E6%8F%92%E5%85%A5" rel="nofollow">插入</a></p> 
<p id="%E6%97%8B%E8%BD%AC-toc" style="margin-left:80px;"><a href="#%E6%97%8B%E8%BD%AC" rel="nofollow">旋转</a></p> 
<hr id="hr-toc"> 
<p><strong>前言</strong></p> 
<h4 id="%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#4da8ee;">搜索二叉树</span></h4> 
<p><strong>搜索二叉树 又称 二叉排序树，它或者是一棵空树</strong>，或者是具有以下性质的二叉树:</p> 
<ul><li><strong>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</strong></li><li><strong>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</strong></li><li><strong>它的左右子树也分别为二叉搜索树</strong></li></ul> 
<p><strong>示例：</strong></p> 
<p class="img-center"><img alt="" height="166" src="https://images2.imgbox.com/23/9c/L4EPt98r_o.png" width="211"></p> 
<p><strong>具体可以查看<a class="link-info" href="https://blog.csdn.net/m0_73969113/article/details/135599396?spm=1001.2014.3001.5501" title="搜索二叉树">搜索二叉树</a></strong></p> 
<p></p> 
<div>
          
 <span style="color:#0d0016;"> 但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树（或接近单只树），</span>二叉搜索树的性能就失去了，并且 
 <span style="color:#0d0016;">时间复杂度会退化成O(N)，因此需要对底层结构进行平衡处理，即采用平衡树（AVL树、红黑树）来实现，使二叉搜索树的性能都能达到最优</span>. 
</div> 
<p class="img-center"><img alt="" height="214" src="https://images2.imgbox.com/7e/ec/BkU5Dbsu_o.png" width="394"></p> 
<p></p> 
<h4 id="AVL%E6%A0%91"><span style="color:#4da8ee;">AVL树</span></h4> 
<div> 
 <span style="color:#4da8ee;"><strong>AVL树的概念 </strong></span> 
</div> 
<p></p> 
<div> 
 <span style="color:#777777;">        二叉搜索树虽可以缩短查找的效率，但<strong>如果数据有序或接近有序二叉搜索树将退化为单支树，查</strong></span> 
 <span style="color:#777777;"><strong>找元素相当于在顺序表中搜索元素，效率低下</strong></span> 
 <span style="color:#777777;">。因此，两位俄罗斯的数学家</span> 
 <span style="color:#777777;">G.M.Adelson-Velskii和E.M.Landis</span> 
 <span style="color:#777777;">在</span> 
 <span style="color:#777777;">1962</span> 
 <span style="color:#777777;">年发明了一种解决上述问题的方法：<strong>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右</strong></span> 
 <span style="color:#777777;"><strong>子树高度之差的绝对值不超过</strong></span> 
 <span style="color:#777777;"><strong>1(</strong></span> 
 <span style="color:#777777;"><strong>需要对树中的结点进行调整</strong></span> 
 <span style="color:#777777;"><strong>)</strong></span> 
 <span style="color:#777777;">，即可降低树的高度，从而减少平均搜索长度。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#777777;">一棵</span> 
 <span style="color:#777777;">AVL</span> 
 <span style="color:#777777;">树或者是空树，或者是具有以下性质的二叉搜索树：</span> 
</div> 
<div></div> 
<div> 
 <ul><li><span style="color:#777777;"><strong>它的左右子树都是</strong></span><span style="color:#777777;"><strong>AVL</strong></span><span style="color:#777777;"><strong>树 </strong></span></li><li><span style="color:#777777;"><strong>左右子树高度之差</strong></span><span style="color:#777777;"><strong>(</strong></span><span style="color:#777777;"><strong>简称平衡因子</strong></span><span style="color:#777777;"><strong>)</strong></span><span style="color:#777777;"><strong>的绝对值不超过</strong></span><span style="color:#777777;"><strong>1(-1/0/1） --- 一般是右子树减去左子树等于根</strong></span></li></ul> 
</div> 
<p class="img-center"><img alt="" height="283" src="https://images2.imgbox.com/04/b6/IrJC4m2F_o.png" width="405"></p> 
<p></p> 
<div> 
 <span style="color:#777777;"><strong>如果一棵二叉搜索树是高度平衡的，它就是</strong></span> 
 <span style="color:#777777;"><strong>AVL</strong></span> 
 <span style="color:#777777;"><strong>树。如果它有</strong></span> 
 <span style="color:#777777;"><strong>n</strong></span> 
 <span style="color:#777777;"><strong>个结点，其高度可保持在</strong></span> 
 <span style="color:#777777;"><strong>$O(log_2 n)$</strong></span> 
 <span style="color:#777777;"><strong>，搜索时间复杂度</strong></span> 
 <span style="color:#777777;"><strong>O($log_2 n$)</strong></span> 
 <span style="color:#777777;">。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#4da8ee;"><strong>AVL树节点的定义</strong></span> 
</div> 
<div></div> 
<pre><code class="hljs">template&lt;class K, class V&gt;
class AVLTreeNode
{
	AVLTreeNode&lt;K,V&gt;* _left;	//左子树节点
	AVLTreeNode&lt;K, V&gt;* _right;	//右子树节点
	AVLTreeNode&lt;K, V&gt;* _parent;	//父节点
	pair&lt;K, V&gt; _kv;
	int _bf; //balance factor :平衡因子

	AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		,_kv(kv)
		,_bf(0)
	{}
};</code></pre> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#4da8ee;"><strong>AVL树的插入</strong></span> 
</div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#777777;">AVL</span> 
 <span style="color:#777777;">树就是在二叉搜索树的基础上引入了平衡因子，因此</span> 
 <span style="color:#777777;">AVL</span> 
 <span style="color:#777777;">树也可以看成是二叉搜索树。那么AVL树的插入过程可以分为两步： </span> 
</div> 
<div></div> 
<ul><li><span style="color:#777777;"><strong>按照二叉搜索树的方式插入新节点 </strong></span></li><li><span style="color:#777777;"> </span><span style="color:#777777;"><strong>调整节点的平衡因子 </strong></span></li></ul> 
<pre><code class="hljs">template&lt;class K,class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	bool insert(const pair&lt;K, V&gt;&amp; kv)
	{
		//_root为空
		if (_root == nullptr) 
		{
			_root = new Node(kv);
			return true;
		}

		//_root不为空
		Node* cur = _root;
		Node* parent = nullptr;   //记录cur的父节点，方便进行链接

		while (cur)
		{
			if (kv.first &lt; cur-&gt;_kv.first)  //插入的值小于存储的值
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if(kv.first &gt; cur-&gt;_kv.first) //插入的值大于存储的值
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				return false; //相等，则插入失败
			}
        }

			//当前位置为空，插入的值与原本的值不相等，进行链接
			cur = new Node(kv);
			if (kv.first &lt; parent-&gt;_kv.first)
			{
				parent-&gt;_left = cur;
			}
			else
			{
				parent-&gt;_right = cur;
			}

			cur-&gt;_parent = parent;  //需要注意，进行链接


			//链接之后，此时需要更新平衡因子

			//.......

			return true;
		
		
	}

private:
	Node* _root = nullptr;

};</code></pre> 
<p></p> 
<p>此时怎样调整节点的平衡因子呢？</p> 
<p>观察一下平衡因子的性质： <span style="color:#777777;"><strong>左右子树高度之差</strong></span><span style="color:#777777;"><strong>(</strong></span><span style="color:#777777;"><strong>简称平衡因子</strong></span><span style="color:#777777;"><strong>)</strong></span><span style="color:#777777;"><strong>的绝对值不超过</strong></span><span style="color:#777777;"><strong>1(-1/0/1）</strong></span></p> 
<p><span style="color:#777777;"><strong>                                                                        而且平时我们习惯使用右子树高度减去左子树高度等于根</strong></span></p> 
<p>可以得出：<span style="background-color:#fbd4d0;">如果新增节点是右子树，那么父节点需要++；如果新增节点是左子树，那么父节点需要 --</span></p> 
<p><span style="background-color:#fbd4d0;">cur = parent-&gt;_right;     parent-&gt;_bf++;</span></p> 
<p><span style="background-color:#fbd4d0;">cur = parent-&gt;_left;       parent-&gt;_bf--;</span></p> 
<p>示例1：</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/b0/fb/He19PBN4_o.png" width="1200"></p> 
<p>示例2：</p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/8a/c2/EVYnGJQB_o.png" width="689"></p> 
<p>那么此时产生的新问题是，当父节点更新后，要不要继续向上更新？或者什么决定了要不要继续向上更新？？？</p> 
<p>观察示例1与示例2可以得出，<strong>如果parent节点的高度发生了变化，那么是需要继续更新的，如果parent的高度没有发生变化，那么就不需要继续更新。</strong></p> 
<ul><li>情况1：<span style="background-color:#fbd4d0;">parent-&gt;_bf == 1 || parent-&gt;_bf == -1 </span>     ---    需要继续向上更新，因为说明插入之前 parent-&gt;_bf == 0  ，表示插入之前父节点两边的高度相等，现在有一边插入了一个新节点，此时高度发生了改变，所以<strong>需要继续向上更新</strong>。</li></ul> 
<p></p> 
<ul><li>情况2：<span style="background-color:#fbd4d0;">parent-&gt;_bf == 0  </span>   ---    不用向上更新，因为说明插入之前 parent-&gt;_bf == 1 || parent-&gt;_bf == -1，表示插入之前父节点两边的高度不相等，现在矮的一边插入了一个新节点，此时高度平衡，所以<strong>不用向上更新。</strong></li></ul> 
<p></p> 
<ul><li>情况3：<span style="background-color:#fbd4d0;">parent-&gt;_bf == 2 || parent-&gt;_bf == -2</span>   ---   所在子树高度不平衡，需要进行<strong>旋转处理</strong></li></ul> 
<pre><code class="hljs">template&lt;class K,class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	bool insert(const pair&lt;K, V&gt;&amp; kv)
	{
		//_root为空
		if (_root == nullptr) 
		{
			_root = new Node(kv);
			return true;
		}

		//_root不为空
		Node* cur = _root;
		Node* parent = nullptr;   //记录cur的父节点，方便进行链接

		while (cur)
		{
			if (kv.first &lt; cur-&gt;_kv.first)  //插入的值小于存储的值
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if(kv.first &gt; cur-&gt;_kv.first) //插入的值大于存储的值
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				return false; //相等，则插入失败
			}
         }

			//当前位置为空，插入的值与原本的值不相等，进行链接
			cur = new Node(kv);
			if (kv.first &lt; parent-&gt;_kv.first)
			{
				parent-&gt;_left = cur;
			}
			else
			{
				parent-&gt;_right = cur;
			}

			cur-&gt;_parent = parent;  //需要注意，进行链接


			//链接之后，此时需要更新平衡因子

			while (parent)
			{
				if (cur == parent-&gt;_right)
				{
					parent-&gt;_bf++;
				}
				else
				{
					parent-&gt;_bf--;
				}

				if (parent-&gt;_bf == 0)
				{
					break; 
				}
				else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
				{
					//继续向上更新
					parent = parent-&gt;_parent;
					cur = cur-&gt;_parent;
				}
				else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
				{
					//需要进行旋转处理
					//........
				}
				else
				{
					//程序走到这里说明问题很严重，直接断言
					assert(false);
				}

			}

			return true;
		
	}

private:
	Node* _root = nullptr;
};
</code></pre> 
<p>那么什么情况下会出现旋转处理？？？</p> 
<p>1.更新平衡因子：如果更新完成，平衡因子没有出现问题 <span style="background-color:#fbd4d0;">| _bf l &lt;= 1</span>，平衡结构没有受到影响，不需要处理<br>  </p> 
<p>2.更新平衡因子：如果更新完成，平衡因子出现问题<span style="background-color:#fbd4d0;"> | _bf | &gt; 1</span>，平衡结构受到影响，需要处理(旋转)</p> 
<p></p> 
<p><span style="color:#4da8ee;"><strong>AVL树的旋转</strong></span></p> 
<div> 
 <span style="color:#777777;">   如果在一棵原本是平衡的AVL</span> 
 <span style="color:#777777;">树中插入一个新节点，可能造成不平衡，此时必须调整树的结构，使之平衡化。所以旋转的本质有两点：</span> 
</div> 
<ul><li><strong><span style="color:#777777;"><span style="background-color:#fbd4d0;">1.让这棵子树平衡 </span></span></strong></li><li><strong><span style="color:#777777;"><span style="background-color:#fbd4d0;">2.降低这棵子树的高度</span></span></strong></li></ul> 
<div></div> 
<div> 
 <span style="color:#777777;">根据节点插入位置的不同，AVL</span> 
 <span style="color:#777777;">树的旋转分为四种：</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#777777;">1.<strong>新节点插入较高右子树的右侧---</strong></span> 
 <span style="color:#777777;"><strong>右右：左单旋</strong></span> 
</div> 
<div></div> 
<div>
  抽象图： 
</div> 
<div> 
 <p class="img-center"><img alt="" height="239" src="https://images2.imgbox.com/dd/39/powGdVzQ_o.png" width="773"></p> 
</div> 
<div></div> 
<div> 
 <strong>旋转的过程:</strong> 
</div> 
<ul><li>① b变成了30的右边</li><li>② 30变成60的左边</li><li>③ 60变成整棵树的根<br>  </li></ul> 
<div> 
 <div> 
  <span style="color:#0d0016;">在旋转过程中，有以下几种情况需要考虑： </span> 
 </div> 
 <ul><li><span style="color:#0d0016;">① 60节点的左孩子可能存在，也可能不存在 </span></li><li><span style="color:#0d0016;">② 30可能是根节点，也可能是子树</span></li></ul> 
 <p>如果是根节点，旋转完成后，要更新根节点</p> 
 <p><span style="color:#0d0016;"> 如果是子树，可能是某个节点的左子树，也可能是右子树</span></p> 
 <p></p> 
 <p><span style="color:#0d0016;">具象图：</span></p> 
 <p><strong>当h == 0：</strong></p> 
 <p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/cd/48/IRxyCsuP_o.png" width="599"></p> 
 <p><strong>当h == 1：</strong></p> 
 <p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/79/92/xTEbmM0D_o.png" width="687"></p> 
 <p><strong>当h == 2：</strong><br>  </p> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="143" src="https://images2.imgbox.com/48/98/HwFBEWZd_o.png" width="551"></p> 
</div> 
<div> 
 <strong>示例：</strong> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/45/e9/jfgHLOin_o.png" width="772"></p> 
</div> 
<div> 
 <strong>变量定义：</strong> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="203" src="https://images2.imgbox.com/49/71/wphFHQkR_o.png" width="487"></p> 
 <p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/4f/67/fVdRPRmw_o.png" width="670"></p> 
</div> 
<div>
  代码： 
</div> 
<div> 
 <pre><code class="hljs">	//左单旋
	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		//提前记录祖先节点
		Node* pparent = parent-&gt;_parent;

		subR-&gt;_left = parent;
		parent-&gt;_parent = subR;

		//值得注意的是，parent节点不一定为根节点，也就是旋转的可能是一棵子树而不是整棵树
		if (pparent == nullptr) //意味着parent节点是根节点
		{
			_root = subR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			//判断parent 在 祖先节点的左还是右
			if (pparent-&gt;_right == parent)
			{
				pparent-&gt;_right = subR;
			}
			else
			{
				pparent-&gt;_left = subR;
			}

			subR-&gt;_parent = pparent;  //更改subR的父节点
		}

		//注意：一定要更新平衡因子
		parent-&gt;_bf = subR-&gt;_bf = 0;
	}</code></pre> 
 <p></p> 
</div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#777777;">2.<strong>新节点插入较高左子树的左侧 -- 左左：右单旋 (</strong></span>可参考左单旋) 
</div> 
<div></div> 
<div>
  抽象图： 
</div> 
<div></div> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/a0/9c/ZKr0owkd_o.png" width="783"></p> 
<p>代码：</p> 
<pre><code class="hljs">//右单旋
	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		//提前记录祖先节点
		Node* pparent = parent-&gt;_parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (parent == _root) 
		{
			_root = subL;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			//判断parent 在 祖先节点的左还是右
			if (pparent-&gt;_right == parent)
			{
				pparent-&gt;_right = subL;
			}
			else
			{
				pparent-&gt;_left = subL;
			}

			subL-&gt;_parent = pparent;  //更改subR的父节点
		}

		//注意：一定要更新平衡因子
		parent-&gt;_bf = subL-&gt;_bf = 0;
	}</code></pre> 
<p></p> 
<div> 
 <span style="color:#777777;">3. </span> 
 <span style="color:#777777;"><strong>新节点插入较高左子树的右侧</strong></span> 
 <span style="color:#777777;"><strong>---</strong></span> 
 <span style="color:#777777;"><strong>左右：先左单旋再右单旋 </strong></span> 
</div> 
<div></div> 
<div>
  抽象图： 
</div> 
<div> 
 <img alt="" height="301" src="https://images2.imgbox.com/23/16/6uYWhD9c_o.png" width="1200"> 
</div> 
<div></div> 
<div>
  代码演示： 
</div> 
<div></div> 
<div> 
 <pre><code class="hljs">	void RotateLR(Node* parent)
	{
		RotateL(parent-&gt;_left);  //左旋
		RotateR(parent)；		 //右旋
	}</code></pre> 
 <p>这样可以嘛？其实有个非常严重的错误，就是无论左旋还是右旋函数最后都会把<strong>parent ，subR，subL</strong>的平衡因子置成0</p> 
 <p class="img-center"><img alt="" height="224" src="https://images2.imgbox.com/26/f4/rjWV7fnI_o.png" width="830"></p> 
 <p>        以上面的图为例（<strong>新增节点在subLR的左子树</strong>）：第一次单旋会把30节点 、60节点 的平衡因子置成 0，第二次单旋会把60节点 、90节点 的平衡因子置成 0 ，这显然是不对的，因为90节点最后的平衡因子应该是1。所以需要分情况讨论：</p> 
 <p>（<strong>新增节点在subLR的右子树</strong>）</p> 
 <p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/5b/62/ZeZEUsrq_o.png" width="680"></p> 
 <p class="img-center"><img alt="" height="142" src="https://images2.imgbox.com/b7/ae/p1DSEjsg_o.png" width="771"></p> 
 <p>一般来说最后一种不需要考虑，因为都会被单旋修改为0，但是建议不要依赖单旋</p> 
 <p>总结这里不能依靠左旋or右旋函数来修改平衡因子，需要手动修改</p> 
 <p>代码如下：</p> 
 <pre><code class="hljs">//左右双旋
	void RotateLR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		//因为双旋过后 _bf 都会被修改为0，所以需要提前记录
		int bf = subLR-&gt;_bf;

		RotateL(parent-&gt;_left);  //左旋
		RotateR(parent);		 //右旋

		if (bf == 0)
		{
			parent-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			subLR-&gt;_bf = 0;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 1;
			subL-&gt;_bf = 0;
			subLR-&gt;_bf = 0;
		}
		else if (bf == 1)
		{
			parent-&gt;_bf = 0;
			subL-&gt;_bf = -1;
			subLR-&gt;_bf = 0;
		}
		else
		{
			assert(false);  //依旧直接断言，走到这里说明程序出现严重错误
		}

	}</code></pre> 
</div> 
<p></p> 
<div> 
 <span style="color:#777777;">4. </span> 
 <span style="color:#777777;"><strong>新节点插入较高右子树的左侧</strong></span> 
 <span style="color:#777777;"><strong>---</strong></span> 
 <span style="color:#777777;"><strong>右左：先右单旋再左单旋 </strong></span> 
</div> 
<div></div> 
<p>（参考左右双旋）</p> 
<p>抽象图：</p> 
<p class="img-center"><img alt="" height="742" src="https://images2.imgbox.com/8d/7c/fut0BEKN_o.png" width="857"></p> 
<p><strong>代码：</strong></p> 
<pre><code class="hljs">//右左双旋
	void RotateRL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		int bf = subRL-&gt;_bf;

		RotateR(parent-&gt;_right);  
		RotateL(parent);		 

			if (bf == 0)
			{
				parent-&gt;_bf = 0;
				subR-&gt;_bf = 0;
				subRL-&gt;_bf = 0;
			}
			else if (bf == -1)
			{
				parent-&gt;_bf = 0;
				subR-&gt;_bf = 1;
				subRL-&gt;_bf = 0;
			}
			else if (bf == 1)
			{
				parent-&gt;_bf = -1;
				subR-&gt;_bf = 0;
				subRL-&gt;_bf = 0;
			}
			else
			{
				assert(false);  
			}
	}</code></pre> 
<p></p> 
<p>那么什么时候左旋？什么时候右旋，什么时候双旋呢？？？</p> 
<p>观察上面4种旋转的情况可以知道：</p> 
<ul><li><strong>左子树高 - 右旋  </strong></li><li><strong>右子树高 - 左旋    </strong></li><li><strong>左子树高，左子树的右孩子高 - 左右双旋</strong></li><li><strong>右子树高，右子树的左孩子高 - 右左双旋</strong></li></ul> 
<p class="img-center"><img alt="" height="439" src="https://images2.imgbox.com/7a/2d/RhjEOawu_o.png" width="551"></p> 
<div> 
 <span style="color:#777777;"> <strong>AVL</strong></span> 
 <span style="color:#777777;"><strong>树的删除</strong></span> 
</div> 
<div> 
 <span style="color:#777777;">        因为AVL树也是二叉搜索树，可按照二叉搜索树的方式将节点删除，然后再更新平衡因子，只不错与删除不同的时，删除节点后的平衡因子更新，最差情况下一直要调整到根节点的位置。</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#777777;"><strong>AVL</strong></span> 
  <span style="color:#777777;"><strong>树的性能 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;">        AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过</span> 
  <span style="color:#777777;">1</span> 
  <span style="color:#777777;">，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$</span> 
  <span style="color:#777777;">。但是如果要对</span> 
  <span style="color:#777777;">AVL</span> 
  <span style="color:#777777;">树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(</span> 
  <span style="color:#777777;">即不会改变</span> 
  <span style="color:#777777;">)</span> 
  <span style="color:#777777;">，可以考虑</span> 
  <span style="color:#777777;">AVL</span> 
  <span style="color:#777777;">树，但一个结构经常修改，就不太适合。 </span> 
 </div> 
</div> 
<div></div> 
<p>最后附上完整代码以及测试一棵树是否是AVL树的方法：</p> 
<p><strong>                                                                                                                AVLTree.h</strong></p> 
<pre><code class="hljs">#pragma once
#include &lt;iostream&gt;
#include &lt;assert.h&gt;
#include &lt;string&gt;

using namespace std;

template&lt;class K, class V&gt;
struct AVLTreeNode
{
	AVLTreeNode&lt;K,V&gt;* _left;	//左子树节点
	AVLTreeNode&lt;K, V&gt;* _right;	//右子树节点
	AVLTreeNode&lt;K, V&gt;* _parent;	//父节点
	pair&lt;K, V&gt; _kv;
	int _bf; //balance factor :平衡因子

	AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		,_kv(kv)
		,_bf(0)
	{}
};

template&lt;class K,class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	void InOrder()
	{
		_Inorder(_root);
		cout &lt;&lt; endl;
	}

	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		//_root为空
		if (_root == nullptr) 
		{
			_root = new Node(kv);
			return true;
		}

		//_root不为空
		Node* cur = _root;
		Node* parent = nullptr;   //记录cur的父节点，方便进行链接

		while (cur)
		{
			if (kv.first &lt; cur-&gt;_kv.first)  //插入的值小于存储的值
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if (kv.first &gt; cur-&gt;_kv.first) //插入的值大于存储的值
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				return false; //相等，则插入失败
			}

		}

		//当前位置为空，插入的值与原本的值不相等，进行链接
		cur = new Node(kv);
		if (kv.first &lt; parent-&gt;_kv.first)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}

		cur-&gt;_parent = parent;  //需要注意，进行链接


		//链接之后，此时需要更新平衡因子

		while (parent)
		{
			if (cur == parent-&gt;_right)
			{
				parent-&gt;_bf++;
			}
			else
			{
				parent-&gt;_bf--;
			}

			if (parent-&gt;_bf == 0)
			{
				break; 
			}
			else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
			{
				//继续向上更新
				parent = parent-&gt;_parent;
				cur = cur-&gt;_parent;
			}
			else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
			{
				//需要进行旋转处理 --- 1.降低子树的高度  2.继续保持平衡
				if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)
				{
					//左旋
					RotateL(parent);
				}
				else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)
				{
					//右旋
					RotateR(parent);
				}
				else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1)
				{
					//左右双旋 -  根的左子树高 左子树的右子树高 
					RotateLR(parent);
				}
				else if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1)
				{
					//右左双旋 - 根的右子树高 右子树的左子树高
					RotateRL(parent);
				}
				else
				{
					assert(false);
				}

				break;  //旋转之后是可以直接跳出循环的，旋转之后（不管是整棵树还是子树）都是平衡的
					
			}
			else
			{
				//程序走到这里说明问题很严重，直接断言
				assert(false);
			}

		}

		return true;
	}


	//判断是否为AVL树
	bool IsBalance()
	{
		return _IsBalance(_root);
	}

		

protected:
	void _Inorder(Node* root)
	{
		if (root == nullptr)
			return;

		_Inorder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; " ";
		_Inorder(root-&gt;_right);
	}


	//左单旋
	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		//提前记录祖先节点
		Node* pparent = parent-&gt;_parent;

		subR-&gt;_left = parent;
		parent-&gt;_parent = subR;

		//值得注意的是，parent节点不一定为根节点，也就是旋转的可能是一棵子树而不是整棵树
		if (pparent == nullptr) //意味着parent节点是根节点
		{
			_root = subR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			//判断parent 在 祖先节点的左还是右
			if (pparent-&gt;_right == parent)
			{
				pparent-&gt;_right = subR;
			}
			else
			{
				pparent-&gt;_left = subR;
			}

			subR-&gt;_parent = pparent;  //更改subR的父节点
		}

		//注意：一定要更新平衡因子
		parent-&gt;_bf = subR-&gt;_bf = 0;
	}

	//右单旋
	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		//提前记录祖先节点
		Node* pparent = parent-&gt;_parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (parent == _root) 
		{
			_root = subL;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			//判断parent 在 祖先节点的左还是右
			if (pparent-&gt;_right == parent)
			{
				pparent-&gt;_right = subL;
			}
			else
			{
				pparent-&gt;_left = subL;
			}

			subL-&gt;_parent = pparent;  //更改subR的父节点
		}

		//注意：一定要更新平衡因子
		parent-&gt;_bf = subL-&gt;_bf = 0;
	}



	//左右双旋
	void RotateLR(Node* parent)
	{
		//记录修改平衡因子的位置
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		//因为双旋过后bf都会被修改为0，所以需要提前记录subLR的平衡因子
		int bf = subLR-&gt;_bf;

		RotateL(parent-&gt;_left);
		RotateR(parent);

		//分三种情况
		if (bf == 1)
		{
			parent-&gt;_bf = 0;
			subL-&gt;_bf = -1;
			subLR-&gt;_bf = 0;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 1;
			subL-&gt;_bf = 0;
			subLR-&gt;_bf = 0;
		}
		else if (bf == 0)
		{
			parent-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			subLR-&gt;_bf = 0;
		}
		else
		{
			//平衡因子出现其他值直接断言 - 防止出现其他问题
			assert(false);
		}
	}

	//右左双旋
	void RotateRL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		int bf = subRL-&gt;_bf;

		RotateR(parent-&gt;_right);  //右旋
		RotateL(parent);		  //左旋

		if (bf == 0)
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 0;
			subRL-&gt;_bf = 0;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 1;
			subRL-&gt;_bf = 0;
		}
		else if (bf == 1)
		{
			parent-&gt;_bf = -1;
			subR-&gt;_bf = 0;
			subRL-&gt;_bf = 0;
		}
		else
		{
			assert(false);
		}
	}

	//计算高度
	int _Height(Node* root)
	{
		if (root == nullptr)
			return 0;

		int leftH = _Height(root-&gt;_left);  //左子树高度
		int rightH = _Height(root-&gt;_right); //右子树高度

		return leftH &gt; rightH ? leftH + 1 : rightH + 1;  //返回的是整棵树的高度
	}

	//判断是否是AVL树 - 子函数
	bool _IsBalance(Node* root)
	{
		if (root == nullptr)
			return true;

		int left_h = _Height(root-&gt;_left);
		int right_h = _Height(root-&gt;_right);

		//检查平衡因子
		if (right_h - left_h != root-&gt;_bf)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "节点平衡因子异常" &lt;&lt; endl;
			return false;
		}

		//判断左右子树之间的差是否 &lt; 2  abs:求绝对值
		return abs(left_h - right_h) &lt; 2
			&amp;&amp; _IsBalance(root-&gt;_left)
			&amp;&amp; _IsBalance(root-&gt;_right);
	}

	
protected:
	Node* _root = nullptr;
};



void Test_AVLTree1()
{
	int arr1[] = { 16, 3, 7, 11, 9, 26, 18, 14, 15 };
	int arr2[] = { 4, 2, 6, 1, 3, 5, 15, 7, 16, 14 };

	AVLTree&lt;int, int&gt; t1;

	for (auto e : arr1)
	{
		t1.Insert(make_pair(e, e));
		cout &lt;&lt; e &lt;&lt; "插入:" &lt;&lt; t1.IsBalance() &lt;&lt; endl;  //插入进行检查
	}

	t1.InOrder();
	cout &lt;&lt; t1.IsBalance() &lt;&lt; endl;
}

</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac4b4a5c2d6915f80fa59d5128a44051/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu 14.04：PaddleOCR基于PaddleServing的在线服务化部署（失败）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1938ceff5847f7637511c8c7edd312d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">零基础小白也行，只用一行命令在自己的电脑跑大模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>