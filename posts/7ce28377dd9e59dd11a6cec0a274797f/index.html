<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PA1--实现基础设施、表达式求值和监视点 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PA1--实现基础设施、表达式求值和监视点" />
<meta property="og:description" content="PA1实验总结 基础设施PA1.1基础设施单步执行打印寄存器 PA1.2 表达式求值1. 词法分析（识别token）2. 递归求值 PA1.3实现监视点 基础设施 在实现基础实施前需要的是进行源码的阅读，并且实现寄存器的模拟。实验中已经给了提示，如果需要实现寄存器的模拟需要掌握什么是匿名。只有在了解了什么是union后才可以实现寄存器的模拟，下附实现的代码（代码永远不唯一）。
typedef struct { union{ union { uint32_t _32; uint16_t _16; uint8_t _8[2]; } gpr[8]; /* Do NOT change the order of the GPRs&#39; definitions. */ /* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions 1. in PA2 able to directly access these registers. */ struct{ uint32_t eax; uint32_t ecx; uint32_t edx; uint32_t ebx; uint32_t esp; uint32_t ebp; uint32_t esi; uint32_t edi; }; }; vaddr_t eip; } CPU_state; 在实现了寄存器模拟后，开始进行基础设施的搭建。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7ce28377dd9e59dd11a6cec0a274797f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-19T15:02:48+08:00" />
<meta property="article:modified_time" content="2019-04-19T15:02:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PA1--实现基础设施、表达式求值和监视点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>PA1实验总结</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">基础设施</a></li><li><a href="#PA11_34" rel="nofollow">PA1.1基础设施</a></li><li><ul><li><a href="#_35" rel="nofollow">单步执行</a></li><li><a href="#_57" rel="nofollow">打印寄存器</a></li></ul> 
   </li><li><a href="#PA12__139" rel="nofollow">PA1.2 表达式求值</a></li><li><ul><li><a href="#1_token_144" rel="nofollow">1. 词法分析（识别token）</a></li><li><a href="#2__151" rel="nofollow">2. 递归求值</a></li></ul> 
   </li><li><a href="#PA13_242" rel="nofollow">PA1.3实现监视点</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>基础设施</h3> 
<p>在实现基础实施前需要的是进行源码的阅读，并且实现寄存器的模拟。实验中已经给了提示，如果需要实现寄存器的模拟需要掌握什么是匿名。只有在了解了什么是union后才可以实现寄存器的模拟，下附实现的代码（代码永远不唯一）。</p> 
<pre><code> typedef struct {
    union{
    union
    {   
        uint32_t _32;                                                                             
        uint16_t _16;
        uint8_t _8[2];
    } gpr[8];
           
  /* Do NOT change the order of the GPRs' definitions. */
           
  /* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions
 1. in PA2 able to directly access these registers.
   */   
    struct{
        uint32_t eax;
        uint32_t ecx;
        uint32_t edx;
        uint32_t ebx;
        uint32_t esp;
        uint32_t ebp;
        uint32_t esi;
        uint32_t edi;
    };  
    };  
    vaddr_t eip;
           
} CPU_state;
</code></pre> 
<p>在实现了寄存器模拟后，开始进行基础设施的搭建。</p> 
<h3><a id="PA11_34"></a>PA1.1基础设施</h3> 
<h4><a id="_35"></a>单步执行</h4> 
<p>实现单步执行的功能有两个关键点：</p> 
<ol><li>学习strtok（）函数。直接去查找库函数的官方文档即可。</li><li>调用cpu_exec（）函数。</li></ol> 
<pre><code>static int cmd_si(char *args){   
    char *arg = strtok(args," ");
    // printf("%s\n",arg);
    if(arg == NULL){
        printf("too few arguments.\n");
        return 1;
    }
    int num = atoi(arg);
    cpu_exec(num);
    printf("OK");
    return 0;
};
</code></pre> 
<p><img src="https://images2.imgbox.com/91/35/Np8okjT3_o.png" alt="单步执行结果"><br> 注：附上的代码注释部分是用来测试用的。</p> 
<h4><a id="_57"></a>打印寄存器</h4> 
<p>打印寄存器部分比较容易实现，只需要用strtok（）函数将字符串分割成想要的部分即可。</p> 
<pre><code>static int cmd_info(char *args){
    char *arg = strtok(args," ");
    printf("%s\n",arg);
    //cpu info
    if (strcmp(arg,"r")==0){
        printf("eax is %x\n",cpu.eax);
        printf("ecx is %x\n",cpu.ecx);
        printf("edx is %x\n",cpu.edx);
        printf("ebx is %x\n",cpu.ebx);
        printf("esp is %x\n",cpu.esp);
        printf("ebp is %x\n",cpu.ebp); 
        printf("esi is %x\n",cpu.esi);
        printf("edi is %x\n",cpu.edi);
        printf("---------------------------\n");
    }
    else if(strcmp(arg,"w")==0){
        print_wp();    //此部分是后期用来打印监测点状态使用，前期可以先注释掉。
    }
     
    return 0;
}  
</code></pre> 
<p><img src="https://images2.imgbox.com/31/85/EW7liPjf_o.png" alt="info r">### 扫描内存<br> 这部分直接给出代码，没有什么特别的思考逻辑。</p> 
<pre><code>static int cmd_x(char *args){
    //获取内存起始地址和扫描长度。
    if(args == NULL){
        printf("too few parameter! \n");
        return 1;
    }
     
    char *arg = strtok(args," ");
    if(arg == NULL){
        printf("too few parameter! \n");
        return 1;
    }
    int  n = atoi(arg);
    char *EXPR = strtok(NULL," ");
    if(EXPR == NULL){                                                                                                                                          
        printf("too few parameter! \n");
        return 1;
    }
    if(strtok(NULL," ")!=NULL){
        printf("too many parameter! \n");
        return 1;
    }
    bool success = true;
    //vaddr_t addr = expr(EXPR , &amp;success);
    if (success!=true){
        printf("ERRO!!\n");
        return 1;
    }
    char *str;
   // vaddr_t addr = atoi(EXPR);
    vaddr_t addr =  strtol( EXPR,&amp;str,16 );
   // printf("%#lX\n",ad);
    //进行内存扫描,每次四个字节;
    for(int i = 0 ; i &lt; n ; i++){
        uint32_t data = vaddr_read(addr + i * 4,4);
        printf("0x%08x  " , addr + i * 4 );
        for(int j =0 ; j &lt; 4 ; j++){
            printf("0x%02x " , data &amp; 0xff);
            data = data &gt;&gt; 8 ;
        }
        printf("\n");
    }
     
    return 0;
}    
</code></pre> 
<p><img src="https://images2.imgbox.com/63/b7/8Dldjpsl_o.png" alt="xcan"></p> 
<h3><a id="PA12__139"></a>PA1.2 表达式求值</h3> 
<p>这个部分我用了比较长的时间，而且在做后面的实验时又对这个部分进行了补充。对于这部分，我不会贴出全部源代码，只会给出实验结果和思路。<br> 整个表达式求值的过程我分成了两个部分：</p> 
<h4><a id="1_token_144"></a>1. 词法分析（识别token）</h4> 
<p>在进行此法分析时，首先要进行的是了解正则表达式。正则表达式的用途很广，而且很神奇，最重要的是还很复杂。在此我大概说一下自己在实现这个部分是走过的坑。<br> 第一个坑毫无疑问是正则表达式的撰写，对于这个我想说的是：多测试，尽可能想的全面。只有这样才能写出一个可以使用的正则表达式。<br> 在完成tokens识别后需要做的是将token信息存储到tokens[]数组中，这里我使用的是strncpy()函数，因为这个函数可以更好的控制字符串复制的起始位置。<br> 至此就已经实现一个简单的词法分析器了。</p> 
<h4><a id="2__151"></a>2. 递归求值</h4> 
<p>在识别并记录下全部的token信息后，可以进行求值运算了，在整个求值运算中已经有了一个完整的递归框架，这里我会详细说下其中两个功能函数</p> 
<ol><li>括号匹配函数</li></ol> 
<pre><code>bool check_parentheses(int p ,int q){
   // printf("--------------\n");  
    int i,tag = 0;
    if(tokens[p].type != TK_LEFT || tokens[q].type != TK_RIGHT) return false; //首尾没有()则为false 
    for(i = p ; i &lt;= q ; i ++){    
        if(tokens[i].type == TK_LEFT) tag++;
        else if(tokens[i].type == TK_RIGHT) tag--;
        if(tag == 0 &amp;&amp; i &lt; q) return false ;  //(3+4)*(5+3) 返回false
    }                              
    if( tag != 0 ) return false;   
    return true;                   
} 
</code></pre> 
<ol start="3"><li>主操作符寻找函数</li></ol> 
<pre><code>int dominant_operator(int p , int q){
               
    int i ,dom = p, left_n = 0;
    int pr = -1 ;
    for(i = p ; i &lt;= q ; i++){
        if(tokens[i].type == TK_LEFT){
            left_n += 1;
            i++;
            while(1){
                if(tokens[i].type == TK_LEFT) left_n += 1;
                else if(tokens[i].type == TK_RIGHT) left_n --;
                i++;
                if(left_n == 0)
                    break;
            }  
            if(i &gt; q)break;
        }      
        else if(tokens[i].type == TK_NUM10) continue;
        else if(pir(tokens[i].type ) &gt; pr){
            pr = pir(tokens[i].type);
            dom = i;
        }      
    }          
   // printf("%d\n",left_n);
    return dom;
}              
</code></pre> 
<p>其中pir是优先级函数，这里我按照c语言的标准对不同操作符赋予优先级。<br> 在完成以上函数后，就已经实现了基本的表达式求值函数，接下来是对表达式求值的扩展- -负数和指针的识别。</p> 
<pre><code> for(int i = 0 ;i&lt;nr_token;i++) {
    if(tokens[i].type=='*'&amp;&amp;(i==0||(tokens[i-1].type!=TK_NUM10&amp;&amp;tokens[i-1].type!=TK_LEFT&amp;&amp;tokens[i].type!=TK_NUM16)))
        tokens[i].type = TK_POINT;
    if(tokens[i].type=='-'&amp;&amp;(i==0||(tokens[i-1].type!=TK_NUM10&amp;&amp;tokens[i-1].type!=TK_LEFT&amp;&amp;tokens[i].type!=TK_NUM16)))
        tokens[i].type = TK_NEG;
  }  
</code></pre> 
<p>在进行负数和指针的识别时要注意特殊情况 多个负号和多个指针，这里我在处理时加了一下代码：</p> 
<pre><code>       if(tokens[op].type == TK_NEG){
            for( i = op ; i&lt;nr_token ; i++){
                if(tokens[i].type == TK_NUM10){
                    sscanf(tokens[i].str, "%x", &amp;result);
                    //printf("%d \n",result);
                    // return -result;
                    break;
                }
               
            }  
            for( ;i &gt; 0 ;i --) result = -result;
            return result;
        }      
        else if (tokens[op].type == TK_POINT){
            for( i = op ; i&lt;nr_token ; i++){
                if(tokens[i].type == TK_NUM10){
                    sscanf(tokens[op+1].str, "%x", &amp;result);
                   // result = vaddr_read(result, 4);
                   // return result;
                    break;
                }
            }  
            for( ;i &gt; 0 ;i -- ) vaddr_read(result, 4);
            return result;
               
        } 
</code></pre> 
<p>这里的逻辑是统计符号的个数，然后进行相应次数的操作。<br> 至此完成PA1.2部分。</p> 
<h3><a id="PA13_242"></a>PA1.3实现监视点</h3> 
<p>对于实现监视点功能主要有三个部分函数（监视点所需要的结构类型，大家可以自行思考，能够实现功能即可）：</p> 
<ol><li>添加监视点：</li></ol> 
<pre><code>//需要存入表达式和结果。
WP *new_wp(char *str , int value){
   if(su == true){
       init_wp_pool();
       su = false;
       //printf("!!!!!!!!!!!!!\n");
   }
   if(free_ == NULL){
       printf("Erro!free is null.\n");
       assert(0);
   }
   WP *new = NULL;
   new = free_;
   free_ = free_-&gt;next;
  // printf("!!!!%d\n",value);
  // printf("!!!!%s\n",str);
   new-&gt;value = value;
  // printf("!!!!%d\n",new-&gt;value);
   strcpy(new-&gt;expr, str);
  // printf("!!!!%d\n",new-&gt;value);
  // printf("%s /n",new-&gt;expr);
   new-&gt;next = NULL;
   new-&gt;isused = true;
   if(head == NULL) head = new;
   else{
       new-&gt;next = head;
       head = new ;
   }
   return new;
} 
</code></pre> 
<p><img src="https://images2.imgbox.com/34/11/KT2zhfEr_o.png" alt="add"><br> 再添加监视点前，我进行了一次判断，这个判断主要用途是判定监视点池是否完成初始化。<br> 3. 释放监视点</p> 
<pre><code>void free_wp(int no){
   WP *p = head;
   if(head == NULL){                                                                                                                                          
       printf("监视点列表为空。 \n");
       assert(0);
   }
   else if(p-&gt;NO == no){
       head = head-&gt;next;
       p-&gt;value = 0;
       p-&gt;isused = false; 
       p-&gt;next = free_;
       free_ = p;
       printf("已经删除第%d个监视点。\n", no);
      // free(p);
       return;
   }
   else{
       WP *q = head;
       p = p -&gt;next;
       while(p!=NULL){
           if (p-&gt;NO == no){
               q-&gt;next = p-&gt;next;
               p-&gt;value = 0;
               p-&gt;isused = false;
               p-&gt;next = free_;
               free_ = p;
               printf("已经删除第%d个监视点。\n", no);
        //       free(p);free(q);
               return;
           }
           else{
               p = p -&gt; next;
               q = q -&gt; next;
       }
   }
   printf("不存在第%d个监视点。\n",no);
   return;
}
</code></pre> 
<ol start="4"><li>打印监视点</li></ol> 
<pre><code>void print_wp(){
    WP *p = head;
    if(p ==NULL){
        printf("监视点为空！\n");
        return;
    }
    else{
        while(p!=NULL){
  
            printf("%d   %s 0x%08x\n",p-&gt;NO , p-&gt;expr, p-&gt;value);
            p=p-&gt;next;
        }
        return;
    }
    return;
} 
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/03/TDGjjotv_o.png" alt="de--show"><br> 至此已经完成了整个PA1实验，思考题每个人都会有自己的答案。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f03cdd0403824ca5c4070798677b8cc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阿里C&#43;&#43;面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53c32cf9a68325161ecce97d66154937/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BasicRNN 前向与反向实现实例 -  （吴恩达作业Character level language model - Dinosaurus land）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>