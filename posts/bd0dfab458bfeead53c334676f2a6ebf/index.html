<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CMPP发送长短信，我可以实现了 CMPP2长短信实现（java版） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CMPP发送长短信，我可以实现了 CMPP2长短信实现（java版）" />
<meta property="og:description" content="辞职后我就在yiDong从事短信和群发的工作，从北京方面的专家哪里学会了发送短信，一开始只能发送短短信，就是不超过140个字符，如果超过我就分割然后分成短的发送。一直不能发送超过140字符的。后来经过我阅读了很多人帖子才实现，主要是看了下面的内容，然后修改了代码才实现的。希望能够帮助和我一样迷茫的朋友把。
http://blog.csdn.net/pwlazy/archive/2010/03/05/5349625.aspx大家有什么不明白的可以看这里，写的很好。
我来说说我的实现吧：
1.以前我们可以发短短信的的时候的那个CMPPSubmitMessage。我们还是会用这个。我开发使用的是华为的一个短信开发包做的。这个包是移动给的。要做短信网关都可以叫移动提供。发短信用的是这个com.huawei.smproxy.CMPPSMProxy.send(CMPPSubmitMessage msgvo) 方法发送的。长短信也是用这个发送。
CMPPSubmitMessage 类中的几个属性给说明一下:
/**
* 相同Msg_Id的信息总条数，从1开始
*/
int pkTotal = 1;
/**
* Pk_number 1 Unsigned Integer 相同Msg_Id的信息序号，从1开始
*/
int pkNumber = 1;
/**
* Registered_Delivery 1 Unsigned Integer 是否要求返回状态确认报告：
0：不需要
1：需要
2：产生SMC话单
（该类型短信仅供网关计费使用，不发送给目的终端)
*/
int registeredDelivery = 1;
/**
* Msg_level 1 Unsigned Integer 信息级别
*/
int msgLevel = 3;
/**
* Service_Id 10 Octet String 业务类型，是数字、字母和符号的组合。
*/
String serviceID = &#34;XXXXX&#34;;
/**" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bd0dfab458bfeead53c334676f2a6ebf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-18T15:58:28+08:00" />
<meta property="article:modified_time" content="2016-11-18T15:58:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CMPP发送长短信，我可以实现了 CMPP2长短信实现（java版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 辞职后我就在yiDong从事短信和群发的工作，从北京方面的专家哪里学会了发送短信，一开始只能发送短短信，就是不超过140个字符，如果超过我就分割然后分成短的发送。一直不能发送超过140字符的。后来经过我阅读了很多人帖子才实现，主要是看了下面的内容，然后修改了代码才实现的。希望能够帮助和我一样迷茫的朋友把。</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">  </p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <a target="_blank" href="http://blog.csdn.net/pwlazy/archive/2010/03/05/5349625.aspx" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">http://blog.csdn.net/pwlazy/archive/2010/03/05/5349625.aspx</a>大家有什么不明白的可以看这里，写的很好。</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 我来说说我的实现吧：</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 1.以前我们可以发短短信的的时候的那个CMPPSubmitMessage。我们还是会用这个。我开发使用的是华为的一个短信开发包做的。这个包是移动给的。要做短信网关都可以叫移动提供。发短信用的是这个com.huawei.smproxy.CMPPSMProxy.send(CMPPSubmitMessage <br> msgvo) 方法发送的。长短信也是用这个发送。</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> CMPPSubmitMessage 类中的几个属性给说明一下:</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> /**<br>    * 相同Msg_Id的信息总条数，从1开始<br>    */<br> <strong>int pkTotal = 1;<br> </strong>        /**<br>          * Pk_number 1 <br> Unsigned Integer 相同Msg_Id的信息序号，从1开始<br>          */<br> <strong>   int <br> pkNumber = 1;</strong><br>         /**<br>          * Registered_Delivery 1 <br> Unsigned Integer 是否要求返回状态确认报告：<br>    0：不需要<br>    1：需要<br>    2：产生SMC话单<br>    <br> （该类型短信仅供网关计费使用，不发送给目的终端)<br>          */<br> <strong>int registeredDelivery <br> = 1;</strong><br>         /**<br>          * Msg_level 1 Unsigned Integer <br> 信息级别<br>          */<br> <strong>    int msgLevel = 3;</strong><br>         <br> /**<br>          * Service_Id 10 Octet String 业务类型，是数字、字母和符号的组合。<br>          <br> */<br> <strong>String serviceID = "XXXXX";<br> </strong>        <br> /**<br>          * Fee_UserType<br>          * 计费用户类型字段<br>     <br> 0：对目的终端MSISDN计费；<br>     1：对源终端MSISDN计费；<br>     2：对SP计费;<br>     <br> 3：表示本字段无效，对谁计费参见Fee_terminal_Id字段。<br>          */<br> <strong>int <br> feeUserType = 2;</strong><br>         /**<br>          * <br> 被计费用户的号码（如本字节填空，则表示本字段无效，对谁计费参见Fee_UserType字段，本字段与Fee_UserType字段互斥）<br>          <br> */<br> <strong>String feeTerminalID = "";</strong><br>         <br> /**<br>          * GSM协议类型。详细是解释请参考GSM03.40中的9.2.3.9<br>          <br> */<br> <strong>int tpPID = 0;</strong><br>         /**<br>          * <br> GSM协议类型。详细是解释请参考GSM03.40中的9.2.3.23,仅使用1位，右对齐<br>          * <br> 长消息：1.短消息是：0<br>          */<br> <strong>// int tpUDHI <br> = 0;</strong><br>         /**<br>          * 信息格式<br>     0：ASCII串<br>     <br> 3：短信写卡操作<br>     4：二进制信息<br>     8：UCS2编码<br>     15：含GB汉字 。。。。。<br>          <br> */<br> <strong>// int msgFMT = <br> 8;</strong><br>         /**<br>          * 信息内容来源(SP_Id)<br>          <br> */<br> <strong>String msgSrc = "XXXX";</strong><br>         <br> /**<br>          * 资费类别<br>    01：对“计费用户号码”免费<br>    02：对“计费用户号码”按条计信息费<br>    <br> 03：对“计费用户号码”按包月收取信息费<br>    04：对“计费用户号码”的信息费封顶<br>    <br> 05：对“计费用户号码”的收费是由SP实现<br>          */<br> <strong>String feeType = <br> "01";</strong><br>         /**<br>          * 资费代码（以分为单位）<br>          <br> */<br> <strong>String feeCode = "0";</strong><br>         /**<br>          <br> * 存活有效期，格式遵循SMPP3.3协议<br>          */<br> <strong>Date validTime = <br> null;</strong><br>         /**<br>          * 定时发送时间，格式遵循SMPP3.3协议<br>          <br> */<br> <strong>     Date atTime = null;</strong><br>         /**<br>          * <br> 源号码<br>     SP的服务代码或前缀为服务代码的长号码, <br>     <br> 网关将该号码完整的填到SMPP协议Submit_SM消息相应的source_addr字段，<br>     <br> 该号码最终在用户手机上显示为短消息的主叫号码<br>          */<br> <strong>//String srcTerminalID <br> = "XXXXXX";</strong><br>         /**<br>          * 接收短信的MSISDN号码<br>          <br> */<br> <strong>//String[] destTerminalID = <br> {"XXXXX"};</strong></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <strong>这个类中很多地方是可以不用管的，要以长短信要修改的有：</strong></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <strong>1.// int tpUDHI = 1; 这个要修改为1.</strong></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <strong>2 int msgFMT = 8; <br> 只能用UCS2编码格式</strong></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <strong>3 将长短信分成好几条短短信发送。</strong></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 第1，2好修改。</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 第3点，我这里写了一个实现类：</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> import java.util.ArrayList;<br> import <br> java.util.List;</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> public class LongMessageByte {<!-- --><br> public static <br> List&lt;byte[]&gt; getLongByte(String message){<!-- --><br>    List&lt;byte[]&gt; list = <br> new ArrayList&lt;byte[]&gt;();<br>    try {<!-- --><br>     byte[] messageUCS2;<br>     <br> messageUCS2 = message.getBytes("UnicodeBigUnmarked");<br>     int messageUCS2Len <br> = messageUCS2.length;// 长短信长度<br>     int maxMessageLen = 140;<br>     if <br> (messageUCS2Len &gt; maxMessageLen) {// 长短信发送<br>      //int tpUdhi = 1; <br> //长消息是1.短消息是0<br>      //int msgFmt = 0x08;//长消息不能用GBK<br>      int <br> messageUCS2Count = messageUCS2Len / (maxMessageLen - 6) + 1;// <br> 长短信分为多少条发送<br>      byte[] tp_udhiHead = new byte[6];<br>      tp_udhiHead[0] = <br> 0x05;<br>      tp_udhiHead[1] = 0x00;<br>      tp_udhiHead[2] = 0x03;<br>      <br> tp_udhiHead[3] = 0x0A;<br>      tp_udhiHead[4] = (byte) messageUCS2Count;<br>      <br> tp_udhiHead[5] = 0x01;// 默认为第一条<br>      for (int i = 0; i &lt; messageUCS2Count; <br> i++) {<!-- --><br>       tp_udhiHead[5] = (byte) (i + 1);<br>       byte[] <br> msgContent;<br>       if (i != messageUCS2Count - 1) {// 不为最后一条<br>        <br> msgContent=byteAdd(tp_udhiHead,<br>        messageUCS2, <br> i*(maxMessageLen-6),<br>        (i+1)*(maxMessageLen-6));<br>        <br> list.add(msgContent);<br>       } else {<!-- --><br>        <br> msgContent=byteAdd(tp_udhiHead,<br>        messageUCS2, i*(maxMessageLen-6), <br> messageUCS2Len);<br>        list.add(msgContent);<br>       }<br>      }<br>     <br> }<br>    } catch (Exception e) {<!-- --><br>     e.printStackTrace();<br>    }<br>    return <br> list;<br> }</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> private static byte[] byteAdd(byte[] tpUdhiHead, <br> byte[] messageUCS2, int i,<br>     int j) {<!-- --><br>    byte[] msgb = new <br> byte[j-i+6];<br>    System.arraycopy(tpUdhiHead,0,msgb,0,6);<br>    <br> System.arraycopy(messageUCS2,i,msgb,6,j-i);<br>    return <br> msgb;<br> }<br> }<br> 以前发短短信时是这样的：</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> message = new CMPPSubmitMessage(pkTotal, pkNumber, <br> <br>                registeredDelivery, msgLevel, serviceID, feeUserType, <br> <br>                feeTerminalID, tpPID,<strong>0</strong>,<strong>15</strong>, <br> msgSrc, <br>                feeType, feeCode, validTime, atTime, srcTerminalID, <br> <br>                destTerminalID, <strong>msgContent.getBytes(“GBK”),</strong> <br> "");</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 现在发第消息时就如下发：</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> List&lt;byte[]&gt; list = <br> LongMessageByte.getLongByte(msgContent);<br>             for(byte[] <br> msg:list){<!-- --><br> </p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> message = new CMPPSubmitMessage(pkTotal, pkNumber, <br> <br>                registeredDelivery, msgLevel, serviceID, feeUserType, <br> <br>                feeTerminalID, tpPID, <strong>1, <br> 8,</strong> msgSrc, <br>                feeType, feeCode, validTime, <br> atTime, srcTerminalID, <br>                destTerminalID,msg, "");</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br>                <br> System.out.println(message);<br>                     <br> System.out.println(sender.getConnState());<br>                     returnMsg = <br> sender.send(message);<br>                     <br> System.out.println(returnMsg);<br>             }</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 这样就行了，具体的协议可以去看看<a target="_blank" href="http://blog.csdn.net/pwlazy/archive/2010/03/05/5349625.aspx" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">http://blog.csdn.net/pwlazy/archive/2010/03/05/5349625.aspx</a>这位大家写的。</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 转自：http://hi.baidu.com/hhayy7758/item/e7a3c7c7952d4860f6c95d53</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ae108d988b7cb8b04f963838c398534/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android中的五大数据存储方式之一——文件存储</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1cc91499de6d4fbc8a90c5d82ec630b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android中RecyclerView条目无法横向铺满的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>