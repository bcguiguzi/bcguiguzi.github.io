<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java线程池案例 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java线程池案例" />
<meta property="og:description" content="简介 线程Thread是一个重量级资源，线程的创建、启动以及销毁都是比较耗费系统资源的，同时受限于系统资源的限制，线程的数量与系统性能是一种抛物线的关系，因此对线程的管理，是一种非常好的程序设计习惯，自JDK1.5起，utils包提供了ExecutorService[ɪɡˈzɛkjətɚ]线程池的实现。通俗的将：为了避免重复的创建线程，线程池的出现可以让线程进行复用。当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
一个线程池包括以下四个基本组成部分：
1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
线程池的作用 1.重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;
2.能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;
3.能够多线程进行简单的管理,使线程的使用简单、高效。
线程池的创建 Java里面线程池的顶级接口是Executor，通过工具类java.util.concurrent.Executors的静态方法来创建。Executors此包中所定义的 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和实用方法。
Executors工具类创建线程池 方法名功能newFixedThreadPool(int nThreads)创建固定大小的线程池newSingleThreadExecutor()创建只有一个线程的线程池newCachedThreadPool()创建一个不限线程数上限的线程池，任何提交的任务都将立即执行 newFixedThreadPool：
使用的构造方式为new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，设置了corePoolSize=maxPoolSize，keepAliveTime=0(此时该参数没作用)，无界队列，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常
newSingleThreadExector：
使用的构造方式为new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0)，基本同newFixedThreadPool，但是将线程数设置为了1，单线程，弊端和newFixedThreadPool一致
newCachedThreadPool：
使用的构造方式为new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue())，corePoolSize=0，maxPoolSize为很大的数，同步移交队列，也就是说不维护常驻线程(核心线程)，每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM
newScheduledThreadPool：
使用的构造方式为new ThreadPoolExecutor(var1, 2147483647, 0L, TimeUnit.NANOSECONDS, new ScheduledThreadPoolExecutor.DelayedWorkQueue())，支持定时周期性执行，注意一下使用的是延迟队列，弊端同newCachedThreadPool一致
所以根据上面分析我们可以看到，FixedThreadPool和SigleThreadExecutor中之所以用LinkedBlockingQueue无界队列，是因为设置了corePoolSize=maxPoolSize，线程数无法动态扩展，于是就设置了无界阻塞队列来应对不可知的任务量；而CachedThreadPool则使用的是SynchronousQueue同步移交队列，为什么使用这个队列呢？因为CachedThreadPool设置了corePoolSize=0，maxPoolSize=Integer.MAX_VALUE，来一个任务就创建一个线程来执行任务，用不到队列来存储任务；SchduledThreadPool用的是延迟队列DelayedWorkQueue。在实际项目开发中也是推荐使用手动创建线程池的方式，而不用默认方式，关于这点在《阿里巴巴开发规范》
中是这样描述的：
ThreadPoolExecutor构造方法创建 Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法
// Java线程池的构造函数 public ThreadPoolExecutor( int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, //线程活动时间 TimeUnit unit, // 时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列 ThreadFactory threadFactory, // 线程工厂 RejectedExecutionHandler handler) //拒绝策略 线程池中几个重要的参数 corePoolSize, maximumPoolSize, workQueue以及handler：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1ed016e7d6cda168def797a50c77e2d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T16:24:49+08:00" />
<meta property="article:modified_time" content="2022-03-08T16:24:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java线程池案例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简介</h2> 
<blockquote> 
 <p>线程Thread是一个重量级资源，线程的创建、启动以及销毁都是比较耗费系统资源的，同时受限于系统资源的限制，线程的数量与系统性能是一种抛物线的关系，因此对线程的管理，是一种非常好的程序设计习惯，自JDK1.5起，utils包提供了ExecutorService[ɪɡˈzɛkjətɚ]线程池的实现。通俗的将：为了避免重复的创建线程，线程池的出现可以让线程进行复用。当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。<br> 一个线程池包括以下四个基本组成部分：<br> 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br> 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br> 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；<br> 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</p> 
</blockquote> 
<h2>线程池的作用</h2> 
<blockquote> 
 <p>1.重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;<br> 2.能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;<br> 3.能够多线程进行简单的管理,使线程的使用简单、高效。</p> 
</blockquote> 
<h2>线程池的创建</h2> 
<p>Java里面线程池的顶级接口是Executor，通过工具类java.util.concurrent.Executors的静态方法来创建。Executors此包中所定义的 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和实用方法。</p> 
<h3><strong>Executors工具类创建线程池</strong></h3> 
<table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建固定大小的线程池</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建只有一个线程的线程池</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table> 
<h4></h4> 
<blockquote> 
 <p>newFixedThreadPool：</p> 
 <p>        使用的构造方式为new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，设置了corePoolSize=maxPoolSize，keepAliveTime=0(此时该参数没作用)，无界队列，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常</p> 
 <p><br> newSingleThreadExector：</p> 
 <p>        使用的构造方式为new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0)，基本同newFixedThreadPool，但是将线程数设置为了1，单线程，弊端和newFixedThreadPool一致</p> 
 <p><br> newCachedThreadPool：</p> 
 <p>        使用的构造方式为new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue())，corePoolSize=0，maxPoolSize为很大的数，同步移交队列，也就是说不维护常驻线程(核心线程)，每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM</p> 
 <p><br> newScheduledThreadPool：</p> 
 <p>        使用的构造方式为new ThreadPoolExecutor(var1, 2147483647, 0L, TimeUnit.NANOSECONDS, new ScheduledThreadPoolExecutor.DelayedWorkQueue())，支持定时周期性执行，注意一下使用的是延迟队列，弊端同newCachedThreadPool一致</p> 
 <p>所以根据上面分析我们可以看到，FixedThreadPool和SigleThreadExecutor中之所以用LinkedBlockingQueue无界队列，是因为设置了corePoolSize=maxPoolSize，线程数无法动态扩展，于是就设置了无界阻塞队列来应对不可知的任务量；而CachedThreadPool则使用的是SynchronousQueue同步移交队列，为什么使用这个队列呢？因为CachedThreadPool设置了corePoolSize=0，maxPoolSize=Integer.MAX_VALUE，来一个任务就创建一个线程来执行任务，用不到队列来存储任务；SchduledThreadPool用的是延迟队列DelayedWorkQueue。在实际项目开发中也是推荐使用手动创建线程池的方式，而不用默认方式，关于这点在《阿里巴巴开发规范》<br> 中是这样描述的：</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/68/20/W7zPgBD3_o.png"></p> 
<p></p> 
<h3><strong>ThreadPoolExecutor构造方法创建</strong></h3> 
<p><code>Executors</code>中创建线程池的快捷方法，实际上是调用了<code>ThreadPoolExecutor</code>的构造方法</p> 
<pre><code class="language-java">// Java线程池的构造函数
public ThreadPoolExecutor(
  int corePoolSize, // 核心线程数
  int maximumPoolSize, // 最大线程数
  long keepAliveTime,  //线程活动时间
  TimeUnit unit, // 时间单位
  BlockingQueue&lt;Runnable&gt; workQueue, //工作队列
  ThreadFactory threadFactory, // 线程工厂
  RejectedExecutionHandler handler) //拒绝策略</code></pre> 
<p>线程池中几个重要的参数 corePoolSize, maximumPoolSize, workQueue以及handler：</p> 
<h4><strong>ThreadPoolExecutor参数详解</strong></h4> 
<blockquote> 
 <p>corePoolSize：核心线程数，也是线程池中常驻的线程数，线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务</p> 
 <p>maximumPoolSize：最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程，需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程(线程池总线程数不超过maxPoolSize)</p> 
 <p>keepAliveTime：非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，注意当corePoolSize=maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)；</p> 
 <p>unit：keepAliveTime的时间单位</p> 
 <p>workQueue：用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中</p> 
 <p>threadFactory：创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可以使用guava库的ThreadFactoryBuilder来创建</p> 
 <p>handler：线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p> 
</blockquote> 
<p><strong>workQueue队列</strong></p> 
<blockquote> 
 <p>SynchronousQueue(同步移交队列)：队列不作为任务的缓冲方式，可以简单理解为队列长度为零<br> LinkedBlockingQueue(无界队列)：队列长度不受限制，当请求越来越多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致内存占用过多或OOM<br> ArrayBlockintQueue(有界队列)：队列长度受限，当队列满了就需要创建多余的线程来执行任务<br>  </p> 
</blockquote> 
<h4><strong>handler拒绝策略</strong></h4> 
<blockquote> 
 <ul><li>AbortPolicy：中断抛出异常</li><li>DiscardPolicy：默默丢弃任务，不进行任何通知</li><li>DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务</li><li>CallerRunsPolicy：让提交任务的线程去执行任务(对比前三种比较友好)</li></ul> 
</blockquote> 
<p></p> 
<h4><strong>线程池中的线程创建流程图：</strong></h4> 
<p><img alt="" src="https://images2.imgbox.com/70/ac/h6Tx7HED_o.png"></p> 
<p></p> 
<h4 id="线程池的工作顺序">线程池的工作顺序</h4> 
<blockquote> 
 <p>If fewer than corePoolSize threads are running, the Executor always prefers adding a new <a href="https://so.csdn.net/so/search?q=thread&amp;spm=1001.2101.3001.7020" title="thread">thread</a> rather than queuing.<br> If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.<br> If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</p> 
</blockquote> 
<p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p> 
<h4>线程池提交任务：</h4> 
<p>可以向线程池提交的任务有两种：<code>Runnable</code>和<code>Callable</code>，二者的区别如下：</p> 
<table><thead><tr><th>提交方式</th><th>是否关心返回结果</th></tr></thead><tbody><tr><td><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td><td>是</td></tr><tr><td><code>void execute(Runnable command)</code></td><td>否</td></tr><tr><td><code>Future&lt;?&gt; submit(Runnable task)</code></td><td>否，虽然返回Future，但是其get()方法总是返回null</td></tr></tbody></table> 
<table><tbody><tr><td><code>Future&lt;?&gt; submit(Runnable task)</code></td><td>否，虽然返回Future，但是其get()方法总是返回null</td></tr></tbody></table> 
<p>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);</p> 
<p></p> 
<p></p> 
<h4 id="runnable和callable">Runnable和Callable区别</h4> 
<ol><li>方法签名不同，<code>void Runnable.run()</code>, <code>V Callable.call() throws Exception</code></li><li>是否允许有返回值，<code>Callable</code>允许有返回值</li><li>是否允许抛出异常，<code>Callable</code>允许抛出异常。</li></ol> 
<p><code>Callable</code>是JDK1.5时加入的接口，作为<code>Runnable</code>的一种补充，允许有返回值，允许抛出异常。</p> 
<h2>ThreadPoolExecutor创建线程池案例</h2> 
<h3>execute方法提交</h3> 
<pre><code class="language-java">   /**
     * &lt;p&gt;
     * 使用execute方法执行任务，通过Runnable接口创建线程类(匿名内部类方式创建线程类)
     * （1）定义runnable接口的实现类，并重写该接口的run()方法，
     * （2）创建 Runnable实现类的实例，
     * &lt;/P&gt;
     */
    @Test
    public void createThreadPool1() {

        int pcount = Runtime.getRuntime().availableProcessors();
        //最大线程数控制
        int maxthreadNum = 5;
        ExecutorService executor = new ThreadPoolExecutor(pcount, maxthreadNum, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(1000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i &lt; 5; i++) {
            final int index = i;
            //匿名内部类方式创建
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    //业务处理
                    System.out.println(Thread.currentThread().getName() + " " + index);
                }
            });
        }
    }</code></pre> 
<h4 id="三种提交任务的方式："></h4> 
<pre><code class="language-java"> /**
     * &lt;p&gt;
     * 使用execute方法执行任务，通过Runnable接口创建线程类(自定义创建线程类)
     * （1）定义runnable接口的实现类，并重写该接口的run()方法，
     * （2）创建 Runnable实现类的实例，
     * &lt;/P&gt;
     */

    @Test
    public void createThreadPool2() {

        int pcount = Runtime.getRuntime().availableProcessors();
        //最大线程数控制
        int maxthreadNum = 5;
        ExecutorService executor = new ThreadPoolExecutor(pcount, maxthreadNum, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(1000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
        for (int i = 0; i &lt; 5; i++) {
            final int index = i;
            executor.execute(new RunnableTask(index));
        }
    }

    static class RunnableTask implements Runnable {
        private int i;

        public RunnableTask(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            //业务处理
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
</code></pre> 
<h3>invokeAll方法批量提交</h3> 
<pre><code class="language-java">  /**
     * &lt;p&gt;
     * 使用invokeAll方法批量执行任务，通过Callable接口创建线程类(匿名内部类方式创建线程类)
     * invokeAll的作用是：等待所有的任务执行完成后统一返回。
     * （1）定义runnable接口的实现类，并重写该接口的run()方法，
     * （2）创建 Runnable实现类的实例，
     * &lt;/P&gt;
     */
    @Test
    public void createThreadPool3() {

        ExecutorService executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(1000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

        List&lt;Callable&lt;Object&gt;&gt; tasks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            tasks.add(() -&gt; {
                System.out.println(Thread.currentThread().getName());
                return null;
            });
        }
        try {
            List&lt;Future&lt;Object&gt;&gt; futureList = executor.invokeAll(tasks);
            // 获取全部并发任务的运行结果
            for (Future f : futureList) {
                // 获取任务的返回值，并输出到控制台
                System.out.println("result：" + f.get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        // 关闭线程池
        executor.shutdown();
    }</code></pre> 
<h3>使用submit方法提交</h3> 
<pre><code class="language-java"> /**
     * &lt;p&gt;
     * 使用submit方法执行任务，通过Callable接口创建线程类(匿名内部类方式创建线程类)
     * &lt;/P&gt;
     */
    @Test
    public void createThreadPool4() {

        ExecutorService executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(1000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

        List&lt;Future&lt;Callable&gt;&gt; futureList = new ArrayList&lt;&gt;(10);

        for (int i = 0; i &lt; 5; i++) {
            final int index = i;
            Future future = executor.submit(() -&gt; {
                System.out.println(Thread.currentThread().getName() + " " + index);
                return index;
            });
            futureList.add(future);
        }
        try {
            // 获取全部并发任务的运行结果
            for (Future f : futureList) {
                // 获取任务的返回值，并输出到控制台
                System.out.println("result：" + f.get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        // 关闭线程池
        executor.shutdown();
    }

    /**
     * &lt;p&gt;
     * 使用submit方法执行任务，通过Callable接口创建线程类(自定义方式创建线程类)
     * &lt;/P&gt;
     */

    @Test
    public void createThreadPool5() {

        ExecutorService executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(1000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

        List&lt;Future&lt;Callable&gt;&gt; futureList = new ArrayList&lt;&gt;(10);

        for (int i = 0; i &lt; 5; i++) {
            final int index = i;
            Future future = executor.submit(new CallableTask1(index));
            futureList.add(future);
        }
        try {
            // 获取全部并发任务的运行结果
            for (Future f : futureList) {
                // 获取任务的返回值，并输出到控制台
                System.out.println("result：" + f.get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        // 关闭线程池
        executor.shutdown();
    }

    static class CallableTask1 implements Callable&lt;Integer&gt; {
        Integer i;

        public CallableTask1(Integer i) {
            this.i = i;
        }

        @Override
        public Integer call() throws Exception {
            System.out.println(Thread.currentThread().getName() + " " + i);
            return i;
        }
    }
}</code></pre> 
<h2>线程池监控</h2> 
<p>线程池使用不当也会使服务器资源枯竭，导致异常情况的发生，比如固定线程池的阻塞队列任务数量过多、缓存线程池创建的线程过多导致内存溢出、系统假死等问题。因此，我们需要一种简单的监控方案来监控线程池的使用情况，比如完成任务数量、未完成任务数量、线程大小等信息。</p> 
<h3>一、线程池监控参数</h3> 
<p>线程池提供了以下几个方法可以监控线程池的使用情况：</p> 
<table border="0"><tbody><tr><td><strong>方法</strong></td><td><strong>含义</strong></td></tr><tr><td>getActiveCount()</td><td>线程池中正在执行任务的线程数量</td></tr><tr><td>getCompletedTaskCount()</td><td>线程池已完成的任务数量，该值小于等于taskCount</td></tr><tr><td>getCorePoolSize()</td><td>线程池的核心线程数量</td></tr><tr><td>getLargestPoolSize()</td><td>线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize</td></tr><tr><td>getMaximumPoolSize()</td><td>线程池的最大线程数量</td></tr><tr><td>getPoolSize()</td><td>线程池当前的线程数量</td></tr><tr><td>getTaskCount()</td><td>线程池已经执行的和未执行的任务总数</td></tr></tbody></table> 
<h3>二、线程池监控案例</h3> 
<pre><code class="language-java">  /**
     * &lt;p&gt;
     * 实例2：打印线程池参数
     * &lt;/P&gt;
     */
    @Test
    public void printThreadPoolParameters() {

        // 开始时间
        long start = System.currentTimeMillis();
        int pcount = Runtime.getRuntime().availableProcessors();
        // 创建一个线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 60, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i &lt; 5; i++) {
            executor.execute(() -&gt; {
                printThreadPoolStatus(executor);
            });
        }
        executor.shutdown();
        System.out.println("执行任务消耗了 ：" + (System.currentTimeMillis() - start) + "毫秒");
    }


 private static void printThreadPoolStatus(ThreadPoolExecutor executor) {
        BlockingQueue queue = executor.getQueue();
        System.out.println(Thread.currentThread().getName() + "," +

                "当前的线程数量:" + executor.getPoolSize() + "," +
                "核心线程数:" + executor.getCorePoolSize() + "," +
                "最大线程数:" + executor.getMaximumPoolSize() + "," +
                "活动线程数:" + executor.getActiveCount() + "," +
                "任务总数:" + executor.getTaskCount() + "," +
                "任务完成数:" + executor.getCompletedTaskCount() + "," +
                "线程空闲时间:" + executor.getKeepAliveTime(TimeUnit.SECONDS) + "秒," +
                "当前排队线程数:" + queue.size() + "," +
                "队列剩余大小:" + queue.remainingCapacity() + "," +
                "线程池是否关闭:" + executor.isShutdown() + ","
        );
    }</code></pre> 
<h3>三.测试结果</h3> 
<pre><code class="language-java">pool-1-thread-1,当前的线程数量:3,核心线程数:4,最大线程数:4,活动线程数:3,任务总数:3,任务完成数:0,线程空闲时间:60秒,当前排队线程数:0,队列剩余大小:10,线程池是否关闭:false,
pool-1-thread-1,当前的线程数量:4,核心线程数:4,最大线程数:4,活动线程数:4,任务总数:5,任务完成数:1,线程空闲时间:60秒,当前排队线程数:0,队列剩余大小:10,线程池是否关闭:true,
pool-1-thread-4,当前的线程数量:3,核心线程数:4,最大线程数:4,活动线程数:3,任务总数:5,任务完成数:2,线程空闲时间:60秒,当前排队线程数:0,队列剩余大小:10,线程池是否关闭:true,
pool-1-thread-3,当前的线程数量:2,核心线程数:4,最大线程数:4,活动线程数:2,任务总数:5,任务完成数:3,线程空闲时间:60秒,当前排队线程数:0,队列剩余大小:10,线程池是否关闭:true,
pool-1-thread-2,当前的线程数量:2,核心线程数:4,最大线程数:4,活动线程数:2,任务总数:5,任务完成数:4,线程空闲时间:60秒,当前排队线程数:0,队列剩余大小:10,线程池是否关闭:true,
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9cd57149530a77d407088b28432fef6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pandas学习之一：excel转字典</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7cb91871f1e0edd894d58ab29c0dd3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">以太坊创建私有链 go-ethereum</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>