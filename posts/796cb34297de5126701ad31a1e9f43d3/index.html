<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你了解红黑树么？告诉你一个不一样的红黑树，说点有意思的吧！ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你了解红黑树么？告诉你一个不一样的红黑树，说点有意思的吧！" />
<meta property="og:description" content="先看如下两个问题： 问题1、红黑树的键值可以重复么？
问题2、红黑树必须有键值么？
关于红黑树的介绍网上非常多，红黑树的应用也非常广泛。问一下度娘，她会告诉你各种各样的实现方法，C和C&#43;&#43;版本都有，linux内核使用的版本也有。代码都大同小异，就是插入或删除时如何修正，如何搞平衡。很多文章图文并茂、写实而生动，当你在脑海里试图左旋一把，右旋一把搞平衡时，基本也到了精神崩溃的边缘。
如何维护祖孙三代父、祖父、叔叔以及兄弟间的平衡，如何搞好家庭关系，是个头疼的问题。如果把红黑树比作一个族谱的话，可能开始你是高祖，下个节点插进去后就变成了太宗，随着族系的繁衍最后你可能变成个哀帝。开始A是B爸爸，过会B又变成A爸爸，甚至是爷爷，叔叔、兄弟，你说乱不乱，烧脑烧脑，气人不气人。
套用郭德纲在相声中对于谦说的话：到了咱们这个年纪，谁是谁爸爸都无所谓了。台上无大小，台下立规矩，送给台上的各种二叉树。
这里先介绍一个朴实无华的网站：可视化的数据结构和算法教学，非常不错，里面有经典数据结构的动态展现，可以将你从各种旋转中解救出来。如下图：
说了这么多回到本文开头的两个问题： 问题1：红黑树的键值可以重复么？
大部分人可能认为不可以重复，因为重复的键值会冲突或没有现实意义。其实是可以重复的。为了表达对二叉树的敬意，这里连续插入多个2。使用上面安利的网站，建立了一个很2的红黑树。如下图：
上面的红黑树键值都相等，非常不可思议，但它确实是棵红黑树。
那么这颗很2的红黑树的现实意义是什么，能应用到什么地方？当然有，而且很广泛，这个地方就是定时器，对于大部分服务器程序，基本都要实现自己的定时器，从而完成一些特殊的重复性工作，比如nodejs的引擎libuv库中的定时器，nginx中的定时器、以及redis的键值有效期判断等。。。。
当管理多个定时器时就会存在键值相等的节点，也就是到期时间相等的节点。这时候如何判断谁先执行呢？
下面是libuv定时器实现的部分关键代码：
// libuv定时器使用回调函数来比较key的大小，这里的key就是到期时间timeout static int timer_less_than(const struct heap_node* ha, const struct heap_node* hb) { const uv_timer_t* a; const uv_timer_t* b; a = container_of(ha, uv_timer_t, heap_node); b = container_of(hb, uv_timer_t, heap_node); if (a-&gt;timeout &lt; b-&gt;timeout) return 1; if (b-&gt;timeout &lt; a-&gt;timeout) return 0; /* Compare start_id when both have the same timeout. start_id is * allocated with loop-&gt;timer_counter in uv_timer_start()." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/796cb34297de5126701ad31a1e9f43d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-02T13:46:45+08:00" />
<meta property="article:modified_time" content="2021-09-02T13:46:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你了解红黑树么？告诉你一个不一样的红黑树，说点有意思的吧！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>先看如下两个问题：</h3> 
<p><strong>问题1、红黑树的键值可以重复么？</strong><br> <strong>问题2、红黑树必须有键值么？</strong></p> 
<p>关于红黑树的介绍网上非常多，红黑树的应用也非常广泛。问一下度娘，她会告诉你各种各样的实现方法，C和C++版本都有，linux内核使用的版本也有。<strong>代码都大同小异，就是插入或删除时如何修正，如何搞平衡</strong>。很多文章图文并茂、写实而生动，当你在脑海里试图左旋一把，右旋一把搞平衡时，基本也到了精神崩溃的边缘。</p> 
<p>如何维护祖孙三代父、祖父、叔叔以及兄弟间的平衡，如何搞好家庭关系，是个头疼的问题。如果把红黑树比作一个族谱的话，可能开始你是高祖，下个节点插进去后就变成了太宗，随着族系的繁衍最后你可能变成个哀帝。开始A是B爸爸，过会B又变成A爸爸，甚至是爷爷，叔叔、兄弟，你说乱不乱，烧脑烧脑，气人不气人。<br> 套用郭德纲在相声中对于谦说的话：到了咱们这个年纪，谁是谁爸爸都无所谓了。台上无大小，台下立规矩，送给台上的各种二叉树。</p> 
<p>这里先介绍一个朴实无华的网站：<strong><a href="http://www.u396.com/wp-content/collection/data-structure-visualizations/" rel="nofollow">可视化的数据结构和算法教学</a></strong>，非常不错，里面有经典数据结构的动态展现，可以将你从各种旋转中解救出来。如下图：</p> 
<p><img src="https://images2.imgbox.com/ec/81/9TtjL4ZX_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_15"></a>说了这么多回到本文开头的两个问题：</h3> 
<p><strong>问题1：红黑树的键值可以重复么？</strong></p> 
<p>大部分人可能认为不可以重复，因为重复的键值会冲突或没有现实意义。其实是可以重复的。为了表达对二叉树的敬意，这里连续插入多个2。使用上面<a href="http://www.u396.com/wp-content/collection/data-structure-visualizations/" rel="nofollow"><strong>安利的网站</strong></a>，建立了一个很2的红黑树。如下图：</p> 
<p><img src="https://images2.imgbox.com/13/fe/v4nujq4l_o.png" alt="在这里插入图片描述"><br> 上面的红黑树键值都相等，非常不可思议，但它确实是棵红黑树。<br> <strong>那么这颗很2的红黑树的现实意义是什么，能应用到什么地方？<strong>当然有，而且很广泛，这个地方就是</strong>定时器</strong>，对于大部分服务器程序，基本都要实现自己的定时器，从而完成一些特殊的重复性工作，比如nodejs的引擎libuv库中的定时器，nginx中的定时器、以及redis的键值有效期判断等。。。。</p> 
<p><strong>当管理多个定时器时就会存在键值相等的节点，也就是到期时间相等的节点</strong>。这时候如何判断谁先执行呢？<br> <strong>下面是libuv定时器实现的部分关键代码：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// libuv定时器使用回调函数来比较key的大小，这里的key就是到期时间timeout</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">timer_less_than</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">heap_node</span><span class="token operator">*</span> ha<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">heap_node</span><span class="token operator">*</span> hb<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> uv_timer_t<span class="token operator">*</span> a<span class="token punctuation">;</span>
  <span class="token keyword">const</span> uv_timer_t<span class="token operator">*</span> b<span class="token punctuation">;</span>

  a <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ha<span class="token punctuation">,</span> uv_timer_t<span class="token punctuation">,</span> heap_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  b <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> uv_timer_t<span class="token punctuation">,</span> heap_node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>timeout <span class="token operator">&lt;</span> b<span class="token operator">-&gt;</span>timeout<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-&gt;</span>timeout <span class="token operator">&lt;</span> a<span class="token operator">-&gt;</span>timeout<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">/* Compare start_id when both have the same timeout. start_id is
   * allocated with loop-&gt;timer_counter in uv_timer_start().
   */</span>
   <span class="token comment">// 如果两者过期时间相同，则采用start_id来判断谁先执行</span>
   <span class="token comment">// 这个start_id是个自增变量，后加入堆中的定时器的start_id要大于早加入堆中的定时器</span>
  <span class="token keyword">return</span> a<span class="token operator">-&gt;</span>start_id <span class="token operator">&lt;</span> b<span class="token operator">-&gt;</span>start_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定时器启动并加入到堆中的函数</span>
<span class="token keyword">int</span> <span class="token function">uv_timer_start</span><span class="token punctuation">(</span>uv_timer_t<span class="token operator">*</span> handle<span class="token punctuation">,</span>
                   uv_timer_cb cb<span class="token punctuation">,</span>
                   <span class="token keyword">uint64_t</span> timeout<span class="token punctuation">,</span>
                   <span class="token keyword">uint64_t</span> repeat<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">uint64_t</span> clamped_timeout<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_closing</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token operator">||</span> cb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">uv_timer_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>

  clamped_timeout <span class="token operator">=</span> handle<span class="token operator">-&gt;</span>loop<span class="token operator">-&gt;</span>time <span class="token operator">+</span> timeout<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clamped_timeout <span class="token operator">&lt;</span> timeout<span class="token punctuation">)</span>
    clamped_timeout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

  handle<span class="token operator">-&gt;</span>timer_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
  handle<span class="token operator">-&gt;</span>timeout <span class="token operator">=</span> clamped_timeout<span class="token punctuation">;</span>
  handle<span class="token operator">-&gt;</span>repeat <span class="token operator">=</span> repeat<span class="token punctuation">;</span>
  <span class="token comment">/* start_id is the second index to be compared in timer_less_than() */</span>
  handle<span class="token operator">-&gt;</span>start_id <span class="token operator">=</span> handle<span class="token operator">-&gt;</span>loop<span class="token operator">-&gt;</span>timer_counter<span class="token operator">++</span><span class="token punctuation">;</span>

  <span class="token comment">// 将定时器插入堆中，并使用timer_less_than函数进行堆排序</span>
  <span class="token function">heap_insert</span><span class="token punctuation">(</span><span class="token function">timer_heap</span><span class="token punctuation">(</span>handle<span class="token operator">-&gt;</span>loop<span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">heap_node</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>handle<span class="token operator">-&gt;</span>heap_node<span class="token punctuation">,</span>
              timer_less_than<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>libuv使用的是最小堆来保存和管理多个定时器，<strong>在排序的过程中如果发现时间相等的节点（见上面函数 timer_less_than），则采用start_id来比较大小，这个start_id是个自增变量，后加入堆中的定时器的start_id要大于早加入堆中的定时器</strong> 。从而来判断键值相等的到期事件谁先执行。</p> 
<p>回到上面的红黑树，<strong>如果你仔细观察这颗树的创建过程就会发现，对于键值相同的节点是有时间顺序的，插入晚的默认为大值，放在后面，也就是说红黑树自动实现了按时间轴存储键值的功能。即使到期事件相等（键值Key相等）</strong>，我们也可以根据其插入红黑树的时间顺序来取出最小到期事件去执行。</p> 
<p>nginx使用的就是红黑树的方式来存储和管理多个定时器。这里就不再介绍了。</p> 
<p><strong>问题2、红黑树必须有键值么？</strong></p> 
<p>这棵树也是可以创建的，只不过看上去比上面很2的树还难理解。<br> 上面libuv的定时器节点大小<strong>比较函数 timer_less_than已经告诉我们了，你是可以在比较节点的时候不依赖于key值，在你的插入节点时，通过回调函数来告诉节点谁是“大”的谁是“小”的，这个大小不是数学意义上的大小，可能是业务上一个逻辑业务的大小</strong>。通过一系列多个指标而非单一key，来评估一个节点的在业务上而非数学上的前后顺序。比如个人信用的评估，可能要根据多项指标（年龄、工龄、消费记录等）来计算出一个所谓的“大小”值。</p> 
<p>写的太多了，需要上班就此打住，权当抛砖引玉吧。</p> 
<p><strong>感谢您的阅读！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68ce9c1e34c06491c393b47ca0cd2e39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pandas 数据透视表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e44367e56f24ce668fb7f7768e07207f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快速解决vscode突然无法打开问题（应用程序无法启动）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>