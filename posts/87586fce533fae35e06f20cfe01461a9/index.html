<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;数据结构之线性表——顺序表 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;数据结构之线性表——顺序表" />
<meta property="og:description" content="一、线性表 概念 1.线性表是最简单的一类线性数据结构
2.线性表是由n个数据元素组成的有限序列，相邻数据元素之间存在着序偶关系，可以写成：
(a1, a2,…ai-1, ai, ai&#43;1,…an-1, an)
其中，ai是表中元素,i表示元素ai的位置,n是表的长度
特性 线性表中的元素具有相同的特性，属于同一数据对象，如：
1.26个字母的字母表: (A,B,C,D,…,Z)
2.近期每天的平均温度:(30℃, 28℃, 29℃,…)
ADT定义 ADT List
{
数据对象：数据元素同属一个集合
数据关系：序偶关系
基本操作：
Init创建、Destroy销毁、
Clear清空、Empty是否为空、
Length取表长度、Get取表元素、Locate查找元素
Prior取元素前驱、Next取元素后继
Insert插入元素、Delete删除元素
Traverse遍历表
}
二、顺序表 概念 i.顺序表的构成 1.顺序表是线性表的顺序存储表示
2.顺序表采用一组地址连续的存储单元依次存储线性表的数据元素
ii.顺序表的元素位置 顺序表数据元素的位置：
location(a_i) = location( a_(i-1) ) &#43; l
location(a_i) = location(a_1)&#43;(i-1)*l ( l表示元素占用的内存单元数 )
举例： 一个线性表第一个元素的存储地址是100,每个元素的长度为2,则第5个元素的地址是( )
（A）110 （B）108（C）100 （D）120
根据上面的元素位置公式我们可以知道第五个元素的位置location(a_5)=100&#43;(5-1)*2=108,故选B
实现 顺序表类 #define initsize 100//初始化表的存储容量 #define sizeincrease 10//单次增加容量的大小 class sqlist { public: int length;//顺序表的当前长度 int listsize;//为顺序表分配的储存空间大小 int *element;//指向顺序表的第一个元素（即存储空间基址） int initelement[initsize];//顺序用于表初始化后的各个存储单元的初始值 void init();//创建顺序表 void destroy();//销毁顺序表 void clear();//清空顺序表 bool empty();//检测是否为空 int getlength();//获取顺序表的长度 int get(int index);//获取下标为index的元素 int locate(int ele);//查找元素ele所在位置的下标 int prior(int index);//取下标为index的元素的前驱元素 int next(int index);//取下标为index的元素的后继元素 void insert(int ele,int index);//在下标为index的元素位置插入元素ele,原位置的元素依次后移一位 void remove(int index);//删除下标为index的元素，下标index后的元素依次向前移动一位 void traverse();//遍历表 void print();//打印表 void push(int ele);//从表尾插入元素 void batchpush();//批量压入数据 }; 初始化顺序表 void sqlist::init() { element=(int*)malloc(initsize*sizeof(int));//分配内存大小为initsize的空间 for (int i = 0; i &lt; initsize; i&#43;&#43;)//将各存储单元的初始值赋值给initelement[] { initelement[i]=element[i]; } if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/87586fce533fae35e06f20cfe01461a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-09T16:32:37+08:00" />
<meta property="article:modified_time" content="2022-09-09T16:32:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;数据结构之线性表——顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、线性表</h2> 
<h3>概念</h3> 
<p>1.线性表是最简单的一类线性数据结构</p> 
<p>2.线性表是由n个数据元素组成的有限序列，相邻数据元素之间存在着序偶关系，可以写成：</p> 
<p style="text-align:center;">(a1, a2,…ai-1, ai, ai+1,…an-1, an)</p> 
<p>其中，ai是表中元素,i表示元素ai的位置,n是表的长度</p> 
<h3>特性</h3> 
<p>线性表中的元素具有相同的特性，属于同一数据对象，如：<br> 1.26个字母的字母表: (A,B,C,D,…,Z)<br> 2.近期每天的平均温度:(30℃, 28℃, 29℃,…)</p> 
<h3>ADT定义</h3> 
<blockquote> 
 <p>ADT List</p> 
 <p>{<!-- --><br>     数据对象：数据元素同属一个集合<br>     数据关系：序偶关系<br>     基本操作：<br>         Init创建、Destroy销毁、<br>         Clear清空、Empty是否为空、<br>         Length取表长度、Get取表元素、Locate查找元素<br>         Prior取元素前驱、Next取元素后继<br>         Insert插入元素、Delete删除元素<br>         Traverse遍历表<br> }</p> 
</blockquote> 
<h2> 二、顺序表</h2> 
<h2>概念</h2> 
<h4>i.顺序表的构成</h4> 
<p>1.顺序表是线性表的顺序存储表示</p> 
<p>2.顺序表采用一组<strong>地址连续</strong>的存储单元依次存储线性表的数据元素</p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/46/56/fbKO34v6_o.png" width="513"></p> 
<h4> ii.顺序表的元素位置</h4> 
<p>顺序表数据元素的位置：<br>         location(a_i) = location( a_(i-1) ) + l<br>         location(a_i) = location(a_1)+(i-1)*l    ( l表示元素占用的内存单元数 )</p> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/ef/5e/mK5lgpzy_o.png" width="583"></p> 
<h4> 举例：</h4> 
<p style="text-align:center;">一个线性表第一个元素的存储地址是100,每个元素的长度为2,则第5个元素的地址是( )<br> （A）110 （B）108（C）100 （D）120</p> 
<p>根据上面的元素位置公式我们可以知道第五个元素的位置location(a_5)=100+(5-1)*2=108,故选B</p> 
<h3></h3> 
<h3>实现</h3> 
<h4>顺序表类</h4> 
<pre><code>#define initsize 100//初始化表的存储容量
#define sizeincrease 10//单次增加容量的大小</code></pre> 
<pre><code class="language-cpp">class sqlist
{
    public:
    int length;//顺序表的当前长度
    int listsize;//为顺序表分配的储存空间大小
    int *element;//指向顺序表的第一个元素（即存储空间基址）
    int initelement[initsize];//顺序用于表初始化后的各个存储单元的初始值
    void init();//创建顺序表
    void destroy();//销毁顺序表
    void clear();//清空顺序表
    bool empty();//检测是否为空
    int getlength();//获取顺序表的长度
    int get(int index);//获取下标为index的元素
    int locate(int ele);//查找元素ele所在位置的下标
    int prior(int index);//取下标为index的元素的前驱元素
    int next(int index);//取下标为index的元素的后继元素
    void insert(int ele,int index);//在下标为index的元素位置插入元素ele,原位置的元素依次后移一位
    void remove(int index);//删除下标为index的元素，下标index后的元素依次向前移动一位
    void traverse();//遍历表
    void print();//打印表
    void push(int ele);//从表尾插入元素
    void batchpush();//批量压入数据
};</code></pre> 
<h4>初始化顺序表</h4> 
<pre><code class="language-cpp">void sqlist::init()
{
    element=(int*)malloc(initsize*sizeof(int));//分配内存大小为initsize的空间
    for (int i = 0; i &lt; initsize; i++)//将各存储单元的初始值赋值给initelement[]
    {
        initelement[i]=element[i];  
    }
    
    if (!element)
    {
        cout&lt;&lt;"内存空间分配失败！"&lt;&lt;endl;
    }
    else
    {
        length=0;//初始化后顺序表是空的，故当前长度为0
        listsize=initsize;//初始化的存储容量就等于initsize
        cout&lt;&lt;"存储空间分配成功！"&lt;&lt;endl;
    }
}</code></pre> 
<h4>销毁顺序表</h4> 
<pre><code class="language-cpp">void sqlist::destroy()
{
    if (!element)//如果分配内存空间失败则无需销毁
    {
        cout&lt;&lt;"无需销毁顺序表!"&lt;&lt;endl;   
    }
    else//分配成功就销毁顺序表
    {
        delete element;
        cout&lt;&lt;"顺序表销毁成功!"&lt;&lt;endl;
    }
}</code></pre> 
<h4>清空顺序表</h4> 
<pre><code class="language-cpp">void sqlist::clear()
{
    for (int i = 0; i &lt; length; i++)//将各个元素值赋值为初始化时的值即为清空
    {
        element[i]=initelement[i];
    }
    length=0;//此时顺序表的长度为0     
}</code></pre> 
<h4>判断顺序表是否为空</h4> 
<pre><code class="language-cpp">bool sqlist::empty()
{
    return length==0?true:false;
}</code></pre> 
<h4>得到顺序表长度</h4> 
<pre><code class="language-cpp">int sqlist::getlength()
{
    return length;
}</code></pre> 
<h4>获取下标为index的元素</h4> 
<pre><code class="language-cpp">int sqlist::get(int index)
{
    return element[index];
}</code></pre> 
<h4>定位到第一个数据为ele的元素下标</h4> 
<pre><code class="language-cpp">int sqlist::locate(int ele)
{
    int i;
    for (; i &lt; length; i++)
    {
        if (ele==element[i])
        {
            break;  
        }  
    }
    return i;
}</code></pre> 
<h4>取下标为index的元素的前驱元素</h4> 
<pre><code class="language-cpp">int sqlist::prior(int index) 
{
    if (index==0)
    {
        cout&lt;&lt;"第一个元素没有前驱元素!"&lt;&lt;endl;
        return 0;
    }
    else
    {
        return element[index-1];
    }    
}</code></pre> 
<p><strong>取下标为index的元素的后继元素</strong></p> 
<pre><code class="language-cpp">int sqlist::next(int index)
{
    if (index==length-1)
    {
        cout&lt;&lt;"最后一个元素没有后继元素!"&lt;&lt;endl;
        return length-1;
    }
    else
    {
        return element[index+1];
    }  
}</code></pre> 
<h4>在下标为Index的位置插入元素ele</h4> 
<p>注意，在插入的时候我们要注意的是是否超出了顺序表的容量，如果超过容量就需要进行扩容，因此我们在头文件需要导入&lt;malloc.h&gt;,并使用里面的realloc函数来进行扩容</p> 
<pre><code class="language-cpp">void sqlist::insert(int ele,int index)
{
    if (length==listsize)
    {
        cout&lt;&lt;"顺序表空间已满，自动扩容!"&lt;&lt;endl;
        listsize+=sizeincrease;
        element=(int*)realloc(element,sizeof(listsize));
    }
    for (int i = length; i &gt; index; i--)
    {
        element[i]=element[i-1];    
    }
    element[index]=ele;
    length+=1;  
}</code></pre> 
<h4>删除下标为index的元素</h4> 
<pre><code class="language-cpp">void sqlist::remove(int index)
{
    if (length==0)
    {
        cout&lt;&lt;"顺序表为空无法移除元素!"&lt;&lt;endl;
    }
    else
    {
    for (int i = index; i &lt; length-index; i++)
    {
        element[i]=element[i+1];    
    }
    element[length-1]=initelement[length-1];//将顺序表最后一个元素赋值为该位置初始值
    length-=1;   
    }
}</code></pre> 
<h4>遍历顺序表</h4> 
<pre><code class="language-cpp">void sqlist::traverse()
{
    if (length==0)
    {
        cout&lt;&lt;"顺序表为空无法遍历！"&lt;&lt;endl;
    }
    else
    {
        for (int i = 0; i &lt; length; i++)
        {
            //遍历要做的操作
        }
    }
}</code></pre> 
<h4>打印顺序表</h4> 
<pre><code class="language-cpp">void sqlist::print()
{
    cout&lt;&lt;"============sqlist==========="&lt;&lt;endl;
    for (int i = 0; i &lt; length; i++)
    {
        cout&lt;&lt;"element["&lt;&lt;i&lt;&lt;"]:"&lt;&lt;element[i]&lt;&lt;endl;
    }
    cout&lt;&lt;"============================="&lt;&lt;endl;
}</code></pre> 
<h4>从表尾插入元素ele</h4> 
<pre><code class="language-cpp">void sqlist::push(int ele)
{
    if (length==0)
    {
        element[0]=ele;
    }
    else
    {
        element[length]=ele;
    }
    length++;
}</code></pre> 
<h4>批量压入数据</h4> 
<pre><code class="language-cpp">void sqlist::batchpush()
{
    int symbol=0;
    int tempele;
    while (symbol==0)
    {
        cin&gt;&gt;tempele;
        if (tempele!=-1)
        {
            push(tempele);
        }
        else
        {
            symbol=1;
        }
    }
    cout&lt;&lt;"批量数据压入完毕!"&lt;&lt;endl;
}</code></pre> 
<h4>全部代码</h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;malloc.h&gt;
#define initsize 10
#define sizeincrease 10
using namespace std;

class sqlist
{
    public:
    int length;//顺序表的当前长度
    int listsize;//为顺序表分配的储存空间大小
    int *element;//指向顺序表的第一个元素（即存储空间基址）
    int initelement[initsize];//顺序用于表初始化后的各个存储单元的初始值
    void init();//创建顺序表
    void destroy();//销毁顺序表
    void clear();//清空顺序表
    bool empty();//检测是否为空
    int getlength();//获取顺序表的长度
    int get(int index);//获取下标为index的元素
    int locate(int ele);//查找元素ele所在位置的下标
    int prior(int index);//取下标为index的元素的前驱元素
    int next(int index);//取下标为index的元素的后继元素
    void insert(int ele,int index);//在下标为index的元素位置插入元素ele,原位置的元素依次后移一位
    void remove(int index);//删除下标为index的元素，下标index后的元素依次向前移动一位
    void traverse();//遍历表
    void print();//打印表
    void push(int ele);//从表尾插入元素
};

void sqlist::init()
{
    element=(int*)malloc(initsize*sizeof(int));//分配内存大小为initsize的空间
    for (int i = 0; i &lt; initsize; i++)//将各存储单元的初始值赋值给initelement[]
    {
        initelement[i]=element[i];  
    }
    
    if (!element)
    {
        cout&lt;&lt;"内存空间分配失败！"&lt;&lt;endl;
    }
    else
    {
        length=0;//初始化后顺序表是空的，故当前长度为0
        listsize=initsize;//初始化的存储容量就等于initsize
        cout&lt;&lt;"存储空间分配成功！"&lt;&lt;endl;
    }
}

void sqlist::destroy()
{
    if (!element)//如果分配内存空间失败则无需销毁
    {
        cout&lt;&lt;"无需销毁顺序表!"&lt;&lt;endl;   
    }
    else//分配成功就销毁顺序表
    {
        delete element;
        cout&lt;&lt;"顺序表销毁成功!"&lt;&lt;endl;
    }
}

void sqlist::clear()
{
    for (int i = 0; i &lt; length; i++)//将各个元素值赋值为初始化时的值即为清空
    {
        element[i]=initelement[i];
    }
    length=0;//此时顺序表的长度为0     
}

bool sqlist::empty()
{
    return length==0?true:false;
}

int sqlist::getlength()
{
    return length;
}

int sqlist::get(int index)
{
    return element[index];
}

int sqlist::locate(int ele)
{
    int i;
    for (; i &lt; length; i++)
    {
        if (ele==element[i])
        {
            break;  
        }  
    }
    return i;
}

int sqlist::prior(int index) 
{
    if (index==0)
    {
        cout&lt;&lt;"第一个元素没有前驱元素!"&lt;&lt;endl;
        return 0;
    }
    else
    {
        return element[index-1];
    }    
}

int sqlist::next(int index)
{
    if (index==length-1)
    {
        cout&lt;&lt;"最后一个元素没有后继元素!"&lt;&lt;endl;
        return length-1;
    }
    else
    {
        return element[index+1];
    }  
}

void sqlist::insert(int ele,int index)
{
    if (length==listsize)
    {
        cout&lt;&lt;"顺序表空间已满，自动扩容!"&lt;&lt;endl;
        listsize+=sizeincrease;
        element=(int*)realloc(element,sizeof(listsize));
    }
    for (int i = length; i &gt; index; i--)
    {
        element[i]=element[i-1];    
    }
    element[index]=ele;
    length+=1;  
}

void sqlist::remove(int index)
{
    if (length==0)
    {
        cout&lt;&lt;"顺序表为空无法移除元素!"&lt;&lt;endl;
    }
    else
    {
    for (int i = index; i &lt; length-index; i++)
    {
        element[i]=element[i+1];    
    }
    element[length-1]=initelement[length-1];//将顺序表最后一个元素赋值为该位置初始值
    length-=1;   
    }
}

void sqlist::traverse()
{
    if (length==0)
    {
        cout&lt;&lt;"顺序表为空无法遍历！"&lt;&lt;endl;
    }
    else
    {
        for (int i = 0; i &lt; length; i++)
        {
            //遍历要做的操作
        }
    }
}

void sqlist::print()
{
    cout&lt;&lt;"============sqlist==========="&lt;&lt;endl;
    for (int i = 0; i &lt; length; i++)
    {
        cout&lt;&lt;"element["&lt;&lt;i&lt;&lt;"]:"&lt;&lt;element[i]&lt;&lt;endl;
    }
    cout&lt;&lt;"============================="&lt;&lt;endl;
}

void sqlist::push(int ele)
{
    if (length==0)
    {
        element[0]=ele;
    }
    else
    {
        element[length]=ele;
    }
    length++;
}

void sqlist::batchpush()
{
    int symbol=0;
    int tempele;
    while (symbol==0)
    {
        cin&gt;&gt;tempele;
        if (tempele!=-1)
        {
            push(tempele);
        }
        else
        {
            symbol=1;
        }
    }
    cout&lt;&lt;"批量数据压入完毕!"&lt;&lt;endl;
}

int main()
{
    sqlist sl;
    sl.init();
    sl.destroy();
    return 0;
}</code></pre> 
<h2>三、总结</h2> 
<p>本文先对线性表进行了介绍，并且对本文的关键顺序表进行了介绍以及实现，在后面的文章还会对更多的线性表进行介绍和实现，如果喜欢本文的话麻烦动动你的小手点点赞哈！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95530064943110fc3e3d7f012cbb384b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TCP&amp;UDP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e29d6ef59ae38fa08bcba4106d97af0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows &#43; Nexus &#43; Maven 搭建，一键部署服务，远离焦头烂额，手忙脚乱，舒坦呀</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>