<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>.net - dispatcher vs thread - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content=".net - dispatcher vs thread" />
<meta property="og:description" content="Dispatcher
Multiple tasks inone thread.
you can&#39;t update any UI controls from a thread that doesn&#39;town the control. very Visual (Button, Textbox, Combobox, etc.) inherits from DispacterObject. Thisobject is what allows you to get a hold of the UI thread&#39;s Dispatcher.
the Dispatcher gives us the ability to Invoke onto itsthread.
http://www.switchonthecode.com/tutorials/working-with-the-wpf-dispatcher
SynchronizationContext
To find a UI thread
SynchronizationContext. MSDN says:
“Provides the basicfunctionality for propagating a synchronization context in varioussynchronization models." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c6f4c4cdaef4d7040d993c4fcb3a702d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-12-23T17:18:32+08:00" />
<meta property="article:modified_time" content="2013-12-23T17:18:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">.net - dispatcher vs thread</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>Dispatcher</strong></p> 
<p>  Multiple tasks inone thread.</p> 
<p> </p> 
<p>you can't update any UI controls from a thread that doesn'town the control. very Visual (Button, Textbox, Combobox, etc.) inherits from <a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.aspx" rel="nofollow noopener noreferrer"> <span style="color:black"><span style="color:black">DispacterObject</span></span></a>. Thisobject is what allows you to get a hold of the UI thread's Dispatcher.</p> 
<p>the Dispatcher gives us the ability to Invoke onto itsthread.</p> 
<p><a target="_blank" href="http://www.switchonthecode.com/tutorials/working-with-the-wpf-dispatcher" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://www.switchonthecode.com/tutorials/working-with-the-wpf-dispatcher</span></span></a></p> 
<p> </p> 
<p>SynchronizationContext</p> 
<p>  To find  a UI thread</p> 
<p> </p> 
<p><strong><span style="color:navy">SynchronizationContext</span></strong><span style="color:navy">. MSDN says:</span></p> 
<p><span style="color:navy"> </span></p> 
<p><span style="color:navy">“<em>Provides the basicfunctionality for propagating a synchronization context in varioussynchronization models. </em></span><em><span style="color:navy"> </span><span style="color:navy">The purpose of the synchronization modelimplemented by this class is to allow the internal asynchronous/synchronizationoperations of the common language runtime (CLR) to behave properly withdifferent synchronization models. This model also simplifies some of therequirements that managed applications have had to follow in order to workcorrectly under different synchronization environments</span></em><span style="color:navy">”</span></p> 
<p> </p> 
<p> </p> 
<p>The main difference between the Dispatcher and otherthreading methods is that the Dispatcher is not actually multi-threaded.</p> 
<p> </p> 
<p>BackgroundWorker on the other hand actually executes thecode at the same time it is invoked, in a separate thread. It also is easier touse than true threads because it automatically synchronizes (at least I think Iremember this correctly) with the main thread of an application, the oneresponsible for the controls and message queue (the Dispatcher thread in thecase of WPF and Silverlight), so there's no need to use Dispatcher.Invoke (orControl.Invoke in WinForms) when updating controls from the background thread,although that may not be always recommended.</p> 
<p> </p> 
<p> </p> 
<p>Not every thread has a SynchronizationContext attached to it. Onethread that always has a SynchronizationContextis the UI thread.</p> 
<p>The UI thread, for example, uses a message pump, and withinits SynchronizationContext,it leverages the message pump to sync into the UI thread.</p> 
<p><span style="color:#990000">Send</span><span style="color:#111111">method is doing a little magic; it is executing our code in a blocking fashion,and it reports back any exception during its execution.</span></p> 
<p><span style="color:#990000">Post</span><span style="color:#111111">will "Fire and Forget" about the execution code within the delegate.It also means that you cannot catch exceptions as we did with the </span><span style="color:#990000">Send</span><span style="color:#111111"> method. Suppose anexception is thrown, it will be the UI thread that will get it; unhanding theexception will terminate the UI thread.</span></p> 
<p><a target="_blank" href="http://www.codeproject.com/Articles/31971/Understanding-SynchronizationContext-Part-I" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://www.codeproject.com/Articles/31971/Und<span style="color:black">erstanding-SynchronizationContext-Part-I</span></span></span></a> </p> 
<p> </p> 
<p> </p> 
<p>WPF and Silverlight applications use aDispatcherSynchronizationContext, which queues delegates to the UI thread’sDispatcher with “Normal” priority.</p> 
<p>One aspect of SynchronizationContext is that it provides away to queue a unit of work to a context. Note that this unit of work is queuedto a <em>context</em>rather than a specific thread. This distinction is important, because manyimplementations of SynchronizationContext aren’t based on a single, specificthread.</p> 
<p>Another aspect of SynchronizationContext is that everythread has a “current” context. A thread’s context isn’t necessarily unique;its context instance may be shared with other threads. It’s possible for athread to change its current context, but this is quite rare.</p> 
<p>A third aspect of SynchronizationContext is that it keeps acount of outstanding asynchronous operations. This enables the use of ASP.NETasynchronous pages and any other host needing this kind of count. In mostcases, the count is incremented when the current SynchronizationContext iscaptured, and the count is decremented when the captured SynchronizationContextis used to queue a completion notification to the context.</p> 
<p>There are other aspects of SynchronizationContext, butthey’re less important to most programmers.</p> 
<p><a target="_blank" href="http://msdn.microsoft.com/en-us/magazine/gg598924.aspx" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://msdn.microsoft.com/en-us/magazine/gg598924.aspx</span></span></a>(It's All About the SynchronizationContext) </p> 
<p> </p> 
<p><strong>BackgroundWorker</strong></p> 
<p>Executes an operation on a separate thread.</p> 
<p> </p> 
<p><a target="_blank" href="http://stackoverflow.com/questions/3762576/wpf-backgroundworker-vs-dispatcher" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://stackoverflow.com/questions/3762576/wpf-backgroundworker-vs-dispatcher</span></span></a></p> 
<p> </p> 
<p> </p> 
<p><span style="color:navy">The very interesting aspect about the BackgroundWorker is the factthat RunWorkerCompleted and ProgressChanged event handlers would execute on thethread that created the BackgroundWorker object – most typically on a Windowsform main thread (the thread on which the UI controls are created). Therefore,you now do not fall into a trap that you used to fall into earlier – updating awinform control on the wrong thread and facing unpredictable results. (Notethat the DoWork method runs on a separate threadpool thread – do not update UIcontrols on that method)</span></p> 
<p><a target="_blank" href="http://msmvps.com/blogs/manoj/archive/2005/11/03/74120.aspx" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://msmvps.com/blogs/manoj/archive/2005/11/03/74120.aspx</span></span></a></p> 
<p> </p> 
<p>Each BackgroundWorker captures and uses theSynchronizationContext of the thread that calls RunWorkerAsync and laterexecutes its RunWorkerCompleted event in that context.</p> 
<p><a target="_blank" href="http://msdn.microsoft.com/en-us/magazine/gg598924.aspx" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://msdn.microsoft.com/en-us/magazine/gg598924.aspx</span></span></a>(It's All About the SynchronizationContext)</p> 
<p> </p> 
<p>don’t use background workers before <code>Application.Run()</code></p> 
<p><a target="_blank" href="http://www.codeproject.com/Articles/228869/BackgroundWorker-and-UI-threads" rel="nofollow noopener noreferrer"><span style="color:black"><span style="color:black">http://www.codeproject.com/Articles/228869/BackgroundWorker-and-UI-threads</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8bea9a6fec4bd94f9aa554398229fe6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2013，我的大学。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbbbfed2107cc7805182c0efc1d889ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#中的委托与事件（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>