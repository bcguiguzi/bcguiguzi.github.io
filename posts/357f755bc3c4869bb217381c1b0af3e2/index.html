<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot核心配置与注解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot核心配置与注解" />
<meta property="og:description" content="目录
一.application.properties配置文件
1.1主要作用
1.2基本语法
二.application.yaml配置文件 2.1yaml文件的优点
2.2 基本语法
三.@Configuration注解和@bean注解
@Configuration注解
@Bean注解
四.springboot注解大全
元注解
基本注解
启动注解
HTTP注解
其他注解
一.application.properties配置文件 1.1主要作用 配置应用程序属性：可以在application.properties文件中配置应用程序的各种属性，如数据库连接、日志级别、端口号等。通过这些属性的配置，可以使应用程序适应不同的环境和场景需求。
简化配置：Spring Boot致力于简化配置，通过application.properties文件，开发人员可以集中管理大部分应用程序的配置。相比传统的XML或Java配置方式，使用键值对的形式，使配置文件更加简洁和易于维护。
外部化配置：application.properties文件支持外部化配置，即将配置项的值从代码中分离出来，在不修改代码的情况下，通过修改配置文件来改变应用程序的行为。这样可以方便地进行配置的切换和动态调整。
配置多个环境：Spring Boot允许在不同的配置文件中定义相同的属性，通过激活不同的配置文件来选择不同的应用程序行为。例如，可以使用application-dev.properties和application-prod.properties文件来分别配置开发环境和生产环境的属性。
支持属性引用和覆盖：通过${key}形式，可以在application.properties文件中引用其他属性的值，使属性之间可以相互关联和依赖。而且使用相同的键在不同的配置文件中定义，可以实现针对不同环境的属性覆盖。
1.2基本语法 键值对格式：每行表示一个配置项，采用key=value的格式，其中&#34;key&#34;表示配置项的名称，&#34;value&#34;表示配置项的值。
注释：可以使用&#39;#&#39;号在配置文件中添加注释，&#39;#&#39;号后面的内容将被忽略。例如：# 这是一个注释
引号：如果配置项的值包含特殊字符或空格，可以使用双引号或单引号将其括起来。例如：key=&#34;value with spaces&#34;
特殊字符的转义：如果配置项的值中包含特殊字符，可以使用反斜杠进行转义。例如：key=value\#with\#hash
举例说明
复杂数据类型 server.port=8081 server.servlet.context-path=/home persion.name=xiaoming
简单数据类型 persion.hobby=sing,sport,read persion.family.mother=mum persion.family.father=baba 二.application.yaml配置文件 2.1yaml文件的优点 相对于传统的基于键值对的属性文件（如application.properties），使用YAML格式的配置文件更加易读和易写，具有以下特点：
结构清晰：YAML使用缩进和层级结构表示数据的关系，使配置文件更具可读性和可维护性。它使用冒号（:）和缩进来标识键值对和层级关系，而不需要像属性文件那样使用等号（=）和点号（.）。
支持复杂数据结构：YAML支持列表、映射和嵌套结构，可以方便地表示集合、对象和关联关系等复杂数据结构。这使得配置文件的定义更加灵活，可以更好地适应复杂的配置需求。
无需引号：相对于属性文件中需要使用引号包围值的情况，YAML中大部分字符串值无需使用引号括起来。这使得配置文件看起来更加简洁，减少了引号的干扰。
2.2 基本语法 键值对：使用冒号（:）将键和值分隔，并使用缩进表示层级关系。例如：
key: value 2.层级关系：使用缩进（一般是空格）表示层级关系，子级配置项比父级配置项多两个空格的缩进。例如：
parent: child: value 3.注释：使用井号（#）表示注释，井号后面的内容将被忽略。例如：
# 这是一个注释 key: value 4.字符串值：大部分字符串值无需使用引号括起来，但如果包含特殊字符、空格或需要保留原样输出，可以使用单引号或双引号将其括起来。例如：
key: value key2: &#39;value with spaces&#39; key3: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/357f755bc3c4869bb217381c1b0af3e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T16:38:01+08:00" />
<meta property="article:modified_time" content="2023-11-08T16:38:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot核心配置与注解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.application.properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E4%B8%80.application.properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">一.application.properties配置文件</a></p> 
<p id="1.1%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.1%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8" rel="nofollow">1.1主要作用</a></p> 
<p id="%C2%A01.2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A01.2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow"> 1.2基本语法</a></p> 
<p id="%E4%BA%8C.application.yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C.application.yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%C2%A0" rel="nofollow">二.application.yaml配置文件 </a></p> 
<p id="2.1yaml%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#2.1yaml%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">2.1yaml文件的优点</a></p> 
<p id="2.2%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">2.2 基本语法</a></p> 
<p id="%C2%A0%E4%B8%89.%40Configuration%E6%B3%A8%E8%A7%A3%E5%92%8C%40bean%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%89.%40Configuration%E6%B3%A8%E8%A7%A3%E5%92%8C%40bean%E6%B3%A8%E8%A7%A3" rel="nofollow"> 三.@Configuration注解和@bean注解</a></p> 
<p id="%40Configuration%E6%B3%A8%E8%A7%A3-toc" style="margin-left:120px;"><a href="#%40Configuration%E6%B3%A8%E8%A7%A3" rel="nofollow">@Configuration注解</a></p> 
<p id="%40Bean%E6%B3%A8%E8%A7%A3-toc" style="margin-left:120px;"><a href="#%40Bean%E6%B3%A8%E8%A7%A3" rel="nofollow">@Bean注解</a></p> 
<p id="%C2%A0%E5%9B%9B.springboot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%9B%9B.springboot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8" rel="nofollow"> 四.springboot注解大全</a></p> 
<p id="%E5%85%83%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3" rel="nofollow">元注解</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3" rel="nofollow">基本注解</a></p> 
<p id="%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3" rel="nofollow">启动注解</a></p> 
<p id="HTTP%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#HTTP%E6%B3%A8%E8%A7%A3" rel="nofollow">HTTP注解</a></p> 
<p id="%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3" rel="nofollow">其他注解</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h3 id="%E4%B8%80.application.properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong>一.application.properties配置文件</strong></h3> 
<h4 id="1.1%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><strong>1.1主要作用</strong></h4> 
<ol><li> <p>配置应用程序属性：可以在application.properties文件中配置应用程序的各种属性，如数据库连接、日志级别、端口号等。通过这些属性的配置，可以使应用程序适应不同的环境和场景需求。</p> </li><li> <p>简化配置：Spring Boot致力于简化配置，通过application.properties文件，开发人员可以集中管理大部分应用程序的配置。相比传统的XML或Java配置方式，使用键值对的形式，使配置文件更加简洁和易于维护。</p> </li><li> <p>外部化配置：application.properties文件支持外部化配置，即将配置项的值从代码中分离出来，在不修改代码的情况下，通过修改配置文件来改变应用程序的行为。这样可以方便地进行配置的切换和动态调整。</p> </li><li> <p>配置多个环境：Spring Boot允许在不同的配置文件中定义相同的属性，通过激活不同的配置文件来选择不同的应用程序行为。例如，可以使用application-dev.properties和application-prod.properties文件来分别配置开发环境和生产环境的属性。</p> </li><li> <p>支持属性引用和覆盖：通过<code>${key}</code>形式，可以在application.properties文件中引用其他属性的值，使属性之间可以相互关联和依赖。而且使用相同的键在不同的配置文件中定义，可以实现针对不同环境的属性覆盖。</p> </li></ol> 
<h4 id="%C2%A01.2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><strong> 1.2</strong>基本语法</h4> 
<ol><li> <p>键值对格式：每行表示一个配置项，采用<code>key=value</code>的格式，其中"key"表示配置项的名称，"value"表示配置项的值。</p> </li><li> <p>注释：可以使用'#'号在配置文件中添加注释，'#'号后面的内容将被忽略。例如：<code># 这是一个注释</code></p> </li><li> <p>引号：如果配置项的值包含特殊字符或空格，可以使用双引号或单引号将其括起来。例如：<code>key="value with spaces"</code></p> </li><li> <p>特殊字符的转义：如果配置项的值中包含特殊字符，可以使用反斜杠进行转义。例如：<code>key=value\#with\#hash</code></p> </li></ol> 
<p><strong><code>举例说明</code></strong></p> 
<ul><li><strong><font face="monospace">复杂数据类型</font></strong></li></ul> 
<blockquote> 
 <p><code>server.port=8081 </code></p> 
 <p><code>server.servlet.context-path=/home </code></p> 
 <p><code>persion.name=xiaoming</code></p> 
</blockquote> 
<ul><li>简单数据类型</li></ul> 
<blockquote> 
 <pre><code>persion.hobby=sing,sport,read 
persion.family.mother=mum 
persion.family.father=baba</code></pre> 
</blockquote> 
<h3 id="%E4%BA%8C.application.yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%C2%A0">二.application.yaml配置文件 </h3> 
<h4 id="2.1yaml%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E7%82%B9">2.1yaml文件的优点</h4> 
<p>相对于传统的基于键值对的属性文件（如application.properties），使用YAML格式的配置文件更加易读和易写，具有以下特点：</p> 
<ol><li> <p>结构清晰：YAML使用缩进和层级结构表示数据的关系，使配置文件更具可读性和可维护性。它使用冒号（:）和缩进来标识键值对和层级关系，而不需要像属性文件那样使用等号（=）和点号（.）。</p> </li><li> <p>支持复杂数据结构：YAML支持列表、映射和嵌套结构，可以方便地表示集合、对象和关联关系等复杂数据结构。这使得配置文件的定义更加灵活，可以更好地适应复杂的配置需求。</p> </li><li> <p>无需引号：相对于属性文件中需要使用引号包围值的情况，YAML中大部分字符串值无需使用引号括起来。这使得配置文件看起来更加简洁，减少了引号的干扰。</p> </li></ol> 
<h4 id="2.2%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">2.2 基本语法</h4> 
<ol><li> <p>键值对：使用冒号（:）将键和值分隔，并使用缩进表示层级关系。例如：</p> </li></ol> 
<blockquote> 
 <pre><code>key: value<span style="background-color:#eef0f4;font-family:Consolas, Inconsolata, Courier, monospace;"> </span></code></pre> 
</blockquote> 
<p> 2.层级关系：使用缩进（一般是空格）表示层级关系，子级配置项比父级配置项多两个空格的缩进。例如：</p> 
<blockquote> 
 <pre><code>parent: 
   child: value</code></pre> 
</blockquote> 
<p>3.注释：使用井号（#）表示注释，井号后面的内容将被忽略。例如：</p> 
<blockquote> 
 <pre><code><em># 这是一个注释
</em> key: value</code></pre> 
</blockquote> 
<p>4.字符串值：大部分字符串值无需使用引号括起来，但如果包含特殊字符、空格或需要保留原样输出，可以使用单引号或双引号将其括起来。例如：</p> 
<blockquote> 
 <pre><code>key: value 
key2: 'value with spaces' 
key3: "value with special characters: !@#$%^&amp;*"</code></pre> 
</blockquote> 
<p>5.数字、布尔值和null：数字、布尔值（大小写敏感的<code>true</code>和<code>false</code>）以及空值（<code>null</code>）直接使用对应的字面量表示。例如：</p> 
<blockquote> 
 <pre><code>count: 10 
flag: true 
data: null<span style="background-color:#eef0f4;font-family:Consolas, Inconsolata, Courier, monospace;"> </span></code></pre> 
</blockquote> 
<p>6.列表：使用连字符（-）表示列表项，并在每个项的前面使用相同的缩进。例如：</p> 
<blockquote> 
 <pre><code>list: 
    - item1 
    - item2 
#或者是 
list: [item1, item2]<span style="background-color:#eef0f4;font-family:Consolas, Inconsolata, Courier, monospace;"> </span></code></pre> 
</blockquote> 
<p>7.引用其他属性值：可以使用<code>${}</code>语法引用其他属性的值。例如：</p> 
<blockquote> 
 <pre><code>app: 
  name: My Application 
  greeting: Hello, ${app.name}! 
#或者是 
app: {name: My Applicationm,greeting: "Hello,${app.name}!"}</code></pre> 
</blockquote> 
<p><span style="color:#fe2c24;"> 请注意，YAML对于缩进和空格非常敏感，因此需要确保正确的缩进和空格使用。另外，YAML文件中的配置项可以有多个层级和复杂的数据结构，可以根据实际需求进行嵌套和扩展。</span></p> 
<h3 id="%C2%A0%E4%B8%89.%40Configuration%E6%B3%A8%E8%A7%A3%E5%92%8C%40bean%E6%B3%A8%E8%A7%A3"> 三.<code>@Configuration</code>注解和<code>@bean</code>注解</h3> 
<ul><li> <h5 id="%40Configuration%E6%B3%A8%E8%A7%A3"><code>@Configuration</code>注解</h5> </li></ul> 
<p><code>@Configuration</code>用于将一个类标记为配置类。配置类在Spring中用于定义和组织Bean的创建和配置过程。</p> 
<ol><li> <p>作用：</p> 
  <ol><li> <p>标记类为配置类：通过<code>@Configuration</code>注解，可以将一个普通的类标记为配置类，告诉Spring该类是用于配置Bean的。</p> </li><li> <p>提供Bean的定义：在配置类中，可以使用<code>@Bean</code>注解来定义Bean，并提供Bean的创建和配置逻辑。</p> </li><li> <p>实现依赖注入：配置类可以通过<code>@Autowired</code>注解或其他依赖注入方式引用其他Bean，并实现依赖注入。</p> </li></ol></li><li> <p>用法：</p> 
  <ol><li> <p>创建配置类：创建一个类，并使用<code>@Configuration</code>注解标记该类为配置类。</p> </li><li> <p>定义Bean：在配置类中，使用<code>@Bean</code>注解将方法标记为Bean的定义，并在方法中提供Bean的创建和配置逻辑。</p> </li><li> <p>引用其他Bean：如果需要引用其他Bean，可以使用<code>@Autowired</code>注解或其他依赖注入方式将Bean注入到配置类中。</p> </li><li> <p>加载配置：在启动类中，可以通过<code>@Import</code>注解将配置类引入，或者直接使用<code>ApplicationContext</code>加载配置类。 </p> </li></ol></li></ol> 
<pre><code class="hljs">@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }

    @Bean
    public UserRepository userRepository() {
        return new UserRepository();
    }

    @Autowired
    private UserRepository userRepository;

    // 其他配置...
}</code></pre> 
<p> </p> 
<pre><code class="hljs">@SpringBootApplication
@Import(MyConfig.class)
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</code></pre> 
<p><code>@Configuration</code>注解用于标记一个类为配置类，提供Bean的定义、创建和配置过程。在配置类中，可以使用<code>@Bean</code>注解定义Bean，并可以通过<code>@Autowired</code>注解引用其他Bean。通过引入配置类或加载配置类，使得配置生效并在应用中使用相应的Bean。</p> 
<ul><li> <h5 id="%40Bean%E6%B3%A8%E8%A7%A3"><code>@Bean</code>注解</h5> </li></ul> 
<p><code>@Bean</code>是一个注解，用于将一个方法标记为Bean的定义方法。在Spring中，通过<code>@Bean</code>注解可以自定义配置和创建Bean，并将其添加到应用程序的上下文中。</p> 
<ol><li> <p>作用：</p> 
  <ol><li> <p>标记方法为Bean的定义：通过<code>@Bean</code>注解，可以将一个方法标记为Bean的定义方法，告诉Spring使用该方法来创建Bean。</p> </li><li> <p>提供Bean的创建和配置逻辑：在<code>@Bean</code>注解标记的方法中，可以定义和配置Bean的创建逻辑，并返回一个实例化后的Bean对象。</p> </li><li> <p>实现自定义的Bean配置：通过<code>@Bean</code>注解，可以实现对Bean的自定义配置，例如设置属性、调用初始化方法等。</p> </li></ol></li><li> <p>用法：</p> 
  <ol><li> <p>在配置类中使用<code>@Bean</code>注解：在配置类中，使用<code>@Bean</code>注解标记一个方法，并在方法中定义Bean的创建和配置逻辑。</p> </li><li> <p>返回Bean对象：被<code>@Bean</code>注解标记的方法需要返回一个实例化后的Bean对象。</p> </li><li> <p>自定义Bean名称：可以通过<code>name</code>属性指定Bean的名称，如果不指定，则默认使用方法名作为Bean的名称。</p> </li><li> <p>添加其他配置：可以在<code>@Bean</code>注解中添加其他的属性，如依赖引入、条件化配置等。</p> </li></ol></li></ol> 
<pre><code class="hljs">@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }

    @Bean(name = "userRepository")
    public UserRepository userRepository() {
        return new UserRepository();
    }
    
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public SomeService someService() {
        return new SomeService();
    }

    // 其他配置...
}</code></pre> 
<p> <code>@Bean</code>注解用于标记一个方法为Bean的定义方法，提供自定义配置和创建Bean的逻辑。在配置类中使用<code>@Bean</code>注解，在方法中定义Bean的创建和配置逻辑，并返回Bean对象。可以通过<code>name</code>属性指定Bean的名称，通过其他属性进行进一步的配置。被注解的方法将由Spring容器管理，返回的实例化后的Bean对象将添加到应用程序的上下文中。</p> 
<ul><li>创建流程</li></ul> 
<p>使用<code>@Configuration</code>注解可以将一个类标记为配置类，下面是使用示例：</p> 
<ol><li> <p>创建一个自定义配置类：</p> 
  <ol><li> <p>创建一个类，并用<code>@Configuration</code>注解标记该类为配置类。</p> </li><li> <p>在配置类中定义需要的Bean和其他配置内容。</p> </li></ol></li></ol> 
<pre><code class="hljs">@Configuration
public class MyConfig {
    @Bean（name="mySerVice"）
    public MyService myService() {
        return new myService();
    }

    // 其他配置...
}</code></pre> 
<p> </p> 
<p>2.在测试类中引入ApplicationContext实体类Bean</p> 
<p>通过<code>@Configuration</code>注解将一个类标记为配置类，可以在配置类中定义Bean和其他配置内容。使用<code>@Autowired</code>注解在其他类中获取并使用配置类中定义的Bean。可以通过<code>ApplicationContext</code>加载配置来引入配置类并生效配置。</p> 
<p>在测试类中引入ApplicationContext实体类Bean，并新增一个测试方法进行输出测试。</p> 
<pre><code class="hljs">@Autowired
private ApplicationContext applicationContext;
@Test
void contextLoads() {
        MyService myService = (MyService) applicationContext.getBean("MyService");
        System.out.println(myService);
    }</code></pre> 
<h3 id="%C2%A0%E5%9B%9B.springboot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8"> 四.springboot注解大全</h3> 
<p>SpringBoot注解就是给代码打上标签的能力。通过引入注解，我们可以简单快速赋予代码生命力，大大提高代码可读性和扩展性。注解本身不具有任何能力，只是一个标签，但是我们可以定义各种标签然后实现各种标签处理器来对类、方法、属性甚至参数等进行功能扩展、功能开启、属性定义、行为定义、规则定义、关联处理、元数据定义等等。</p> 
<h3 id="%E5%85%83%E6%B3%A8%E8%A7%A3">元注解</h3> 
<p>@Documented：将会在被此注解注解的元素的javadoc文档中列出注解，一般都打上这个注解没坏处</p> 
<p>@Target：注解能被应用的目标元素，比如类、方法、属性、参数等等，需要仔细思考</p> 
<p>@Retention：仅在源码保留，还是保留到编译后的字节码，还是到运行时也去加载，超过90%的应用会在运行时去解析注解进行额外的处理，所以大部分情况我们都会设置配置为RetentionPolicy.RUNTIME</p> 
<p>@Inherited：如果子类没有定义注解的话，能自动从父类获取定义了继承属性的注解，比如Spring的@Service是没有继承特性的，但是@Transactional是有继承特性的，在OO继承体系中使用Spring注解的时候请特别注意这点，理所当然认为注解是能被子类继承的话可能会引起不必要的Bug，需要仔细斟酌是否开启继承</p> 
<p>@Repeatable：Java 8引入的特性，通过关联注解容器定义可重复注解，小小语法糖提高了代码可读性，对于元素有多个重复注解其实是很常见的事情，比如某方法可以是A角色可以访问也可以是B角色可以访问，某方法需要定时任务执行，要在A条件执行也需要在B条件执行</p> 
<p>@Native：是否在.h头文件中生成被标记的字段，除非原生程序需要和Java程序交互，否则很少会用到这个元注解</p> 
<h3 id="%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3">基本注解</h3> 
<p>@Service: 注解在类上，表示这是一个业务层bean</p> 
<p>@Controller：注解在类上，表示这是一个控制层bean</p> 
<p>@Repository: 注解在类上，表示这是一个数据访问层bean</p> 
<p>@Component： 注解在类上，表示通用bean ，value不写默认就是类名首字母小写</p> 
<p>@Autowired：按类型注入.默认属性required= true</p> 
<p>@Resource: 按名称装配。</p> 
<h3 id="%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3">启动注解</h3> 
<p><a href="http://www.51gjie.com/javaweb/1043.html" rel="nofollow" title="@SpringBootApplication">@SpringBootApplication</a>：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p> 
<p><a href="http://www.51gjie.com/javaweb/1044.html" rel="nofollow" title="@ComponentScan">@ComponentScan</a>：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p> 
<p><a href="http://www.51gjie.com/javaweb/1045.html" rel="nofollow" title="@SpringBootConfiguration">@SpringBootConfiguration</a> ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p> 
<p><a href="http://www.51gjie.com/javaweb/1046.html" rel="nofollow" title="@EnableAutoConfiguration">@EnableAutoConfiguration</a> ：自动配置。</p> 
<h3 id="HTTP%E6%B3%A8%E8%A7%A3">HTTP注解</h3> 
<p>@RequestBody：HTTP请求获取请求体（处理复杂数据，比如JSON）</p> 
<p>@RequestHeader：HTTP请求获取请求头</p> 
<p>@CookieValue：HTTP请求获取cookie</p> 
<p>@SessionAttribute：HTTP请求获取会话</p> 
<p>@RequestAttribute：HTTP请求获取请求的Attribute中（比如过滤器和拦截器手动设置的一些临时数据），</p> 
<p>@RequestParam：HTTP请求获取请求参数（处理简单数据，键值对），</p> 
<p>@PathVariable：HTTP请求获取路径片段，</p> 
<p>@MatrixAttribute：HTTP请求获取矩阵变量允许我们采用特殊的规则在URL路径后加参数（分号区分不同参数，逗号为参数增加多个值）</p> 
<h3 id="%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3">其他注解</h3> 
<p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。</p> 
<p>@ConfigurationProperties：给对象赋值，将注解转换成对象。</p> 
<p>@RequestMapping：和请求报文是做对应的</p> 
<p>@EnableCaching：注解驱动的缓存管理功能</p> 
<p>@GeneratedValue：用于标注主键的生成策略，通过 strategy 属性指定</p> 
<p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p> 
<p>@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9785a73b3d7a7bfc99d835d137388e99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS2022 XAML Styler拓展工具安装失败解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4405e9cc43d6b32983728c3ff2952e72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BeanUtils.copyProperties浅拷贝的坑你得知道？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>