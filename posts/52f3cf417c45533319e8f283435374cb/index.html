<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>毕设 - 用户登录 用cookie来实现会话跟踪 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="毕设 - 用户登录 用cookie来实现会话跟踪" />
<meta property="og:description" content="问题：
1、我用的是postman进行后端接口测试，异步传值的时候出现了错误，先开始是不识别前端传来的json数据，是因为我的jackson版本太低了，重新导入了三个jackson包，后面又出现传值不正确的提示，根据源码看了一下是反射到方法时出现了错误，不应该在前台包装好json，直接传入即可；
2、乱码问题，前台页面乱码，这个问题应该好解决；
解决方案：我用的是thyemleaf集成的html页面，问题出在配置的时候只是配置了请求是utf-8编码，回应没有配置，默认还是iso-8859-1，具体解决代码在spring的xml文件下添加：
&lt;bean id=&#34;templateResolver&#34; class=&#34;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&#34;&gt; &lt;property name=&#34;prefix&#34; value=&#34;&#34; /&gt; &lt;property name=&#34;suffix&#34; value=&#34;.html&#34; /&gt; &lt;!-- HTML is the default value, added here for the sake of clarity. --&gt; &lt;property name=&#34;templateMode&#34; value=&#34;HTML&#34; /&gt; &lt;!-- 重中之重 --&gt; &lt;property name=&#34;characterEncoding&#34; value=&#34;UTF-8&#34;/&gt; &lt;!-- Template cache is true by default. Set to false if you want --&gt; &lt;!-- templates to be automatically updated when modified. --&gt; &lt;property name=&#34;cacheable&#34; value=&#34;false&#34; /&gt; &lt;/bean&gt; &lt;!-- SpringTemplateEngine automatically applies SpringStandardDialect and --&gt; &lt;!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/52f3cf417c45533319e8f283435374cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-19T22:07:45+08:00" />
<meta property="article:modified_time" content="2019-01-19T22:07:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">毕设 - 用户登录 用cookie来实现会话跟踪</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>问题：</p> 
<p>1、我用的是postman进行后端接口测试，异步传值的时候出现了错误，先开始是不识别前端传来的json数据，是因为我的jackson版本太低了，重新导入了三个jackson包，后面又出现传值不正确的提示，根据源码看了一下是反射到方法时出现了错误，不应该在前台包装好json，直接传入即可；</p> 
<p>2、乱码问题，前台页面乱码，这个问题应该好解决；</p> 
<p>解决方案：我用的是thyemleaf集成的html页面，问题出在配置的时候只是配置了请求是utf-8编码，回应没有配置，默认还是iso-8859-1，具体解决代码在spring的xml文件下添加：</p> 
<pre class="has"><code>  &lt;bean id="templateResolver"
          class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;
        &lt;property name="prefix" value="" /&gt;
        &lt;property name="suffix" value=".html" /&gt;
        &lt;!-- HTML is the default value, added here for the sake of clarity.          --&gt;
        &lt;property name="templateMode" value="HTML" /&gt;
        
        &lt;!-- 重中之重 --&gt;
        &lt;property name="characterEncoding" value="UTF-8"/&gt;
        
        &lt;!-- Template cache is true by default. Set to false if you want             --&gt;
        &lt;!-- templates to be automatically updated when modified.                    --&gt;
        &lt;property name="cacheable" value="false" /&gt;
    &lt;/bean&gt;
    &lt;!-- SpringTemplateEngine automatically applies SpringStandardDialect and      --&gt;
    &lt;!-- enables Spring's own MessageSource message resolution mechanisms.         --&gt;
    &lt;bean id="templateEngine"
          class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;
        &lt;property name="templateResolver" ref="templateResolver" /&gt;

        &lt;!-- Enabling the SpringEL compiler with Spring 4.2.4 or newer can speed up  --&gt;
        &lt;!-- execution in most scenarios, but might be incompatible with specific    --&gt;
        &lt;!-- cases when expressions in one template are reused across different data --&gt;
        &lt;!-- ypes, so this flag is "false" by default for safer backwards            --&gt;
        &lt;!-- compatibility.                                                          --&gt;
        &lt;property name="enableSpringELCompiler" value="true" /&gt;
    &lt;/bean&gt;
    &lt;bean class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;
        &lt;property name="templateEngine" ref="templateEngine" /&gt;
        &lt;!-- NOTE 'order' and 'viewNames' are optional --&gt;
        &lt;property name="order" value="1" /&gt;
        &lt;!-- 重中之重 --&gt;
        &lt;property name="characterEncoding" value="UTF-8"/&gt;

        &lt;property name="viewNames" value="*.html,*.xhtml" /&gt;
    &lt;/bean&gt;</code></pre> 
<p>3、异步传值，报错</p> 
<p>org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize instance of java.lang.String out of START_OBJECT token; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of java.lang.String out of START_OBJECT token，</p> 
<p>原因是在stringify()方法中多写了一个引号，</p> 
<p>接着又遇到了 Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supported 错误（POST方法默认就是这个类型），后端可以接收数据，但是反不回去结果，后端获取不到前端传来的contentType数据，原因是我自己为了省事在POST中加入了请求类型，他并没有指定的请求类型，必须一个参数一个参数进行获取，</p> 
<p>在这个问题中有一个点，这个点就是前台传来的值，后台接收可以为一个对象接收吗？答案是可以，但是必须规定controller为restcontroller风格，但是如果这样两个方法不兼容，导致程序产生错误；当然可以解决这个问题，通过thyemleaf将其缓存，通过json格式直接将整个页面返回，也可以解决；</p> 
<p>4、今天发现idea也过期了，这次通过在 http://idea.lanyus.com/  下载一个破解jar包 ，并修改idea64位的启动文件idea64.exe.vmoptions，-javaagent:下载的jar包的地址直接copy上来，然后打开的时候再Active code 将下面代码粘贴：</p> 
<pre class="has"><code>ThisCrackLicenseId-{
"licenseId":"ThisCrackLicenseId",
"licenseeName":"shr",
"assigneeName":"",
"assigneeEmail":"357396211@qq.com",
"licenseRestriction":"For This Crack, Only Test! Please support genuine!!!",
"checkConcurrentUse":false,
"products":[
{"code":"II","paidUpTo":"2099-12-31"},
{"code":"DM","paidUpTo":"2099-12-31"},
{"code":"AC","paidUpTo":"2099-12-31"},
{"code":"RS0","paidUpTo":"2099-12-31"},
{"code":"WS","paidUpTo":"2099-12-31"},
{"code":"DPN","paidUpTo":"2099-12-31"},
{"code":"RC","paidUpTo":"2099-12-31"},
{"code":"PS","paidUpTo":"2099-12-31"},
{"code":"DC","paidUpTo":"2099-12-31"},
{"code":"RM","paidUpTo":"2099-12-31"},
{"code":"CL","paidUpTo":"2099-12-31"},
{"code":"PC","paidUpTo":"2099-12-31"}
],
"hash":"2911276/0",
"gracePeriodDays":7,
"autoProlongated":false}</code></pre> 
<p>搞定；</p> 
<p>5、接下来的问题是，如果每次跳向别的链接，我都要从redis手动获取一次cookie代码重复性太多，是不是应该考虑用拦截器来实现这个功能，首先拦截到用户信息，没有则提示登录，有的话把登录信息放到当前线程，这样在其他接口都可以直接获取到用户信息，顺便还实现了接口限流的注解，自定义注解有两种实现方式，一种是基于aop实现，另一种是基于拦截器实现，我用的是拦截器实现的方法，具体流程如下：</p> 
<p>定义注解：</p> 
<pre class="has"><code>package com.caoporn.merchants.access;

import java.lang.annotation.*;

/**
 * @Author: 史皓燃
 * @CreateDate 2019/1/19 14:34
 * &lt;h1&gt;规定每个用户几秒内能点击几次&lt;/h1&gt;
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface AccessLimit {

	/** 几秒 */
	int seconds();

	/** 点击次数 */
	int maxCount();

	/** 是否需要登录 */
	boolean needLogin() default true;
}
</code></pre> 
<p>编写当前线程储存信息类：</p> 
<pre class="has"><code>package com.caoporn.merchants.access;

import com.caoporn.merchants.entity.User;

/**
 * @Author: 史皓燃
 * @CreateDate 2019/1/19 14:36
 * &lt;h1&gt;将用户登录数据放到每个线程里面&lt;/h1&gt;
 */

public class UserContext {

	/** 存放用户的线程 */
	private static ThreadLocal&lt;User&gt; userHolder = new ThreadLocal&lt;User&gt;();

	/** 将user信息防止于当前线程 */
	public static void setUser(User user) {
		userHolder.set(user);
	}

	/** 从当前线程获取user */
	public static User getUser() {
		return userHolder.get();
	}
}
</code></pre> 
<p>编写拦截器类：</p> 
<pre class="has"><code>package com.caoporn.merchants.access;

import com.alibaba.druid.util.StringUtils;
import com.alibaba.fastjson.JSON;
import com.caoporn.merchants.constant.Constant;
import com.caoporn.merchants.entity.User;
import com.caoporn.merchants.redis.RedisService;
import com.caoporn.merchants.redis.normalkey.AccessKey;
import com.caoporn.merchants.result.CodeMsg;
import com.caoporn.merchants.result.Result;
import com.caoporn.merchants.service.ILoginServ;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;

/**
 * @Author: 史皓燃
 * @CreateDate 2019/1/19 14:40
 * &lt;h1&gt;拦截器，拦截用户信息&lt;/h1&gt;
 */
public class AccessInterceptor extends HandlerInterceptorAdapter {

	/**
	 * 注入登录服务
	 */
	@Autowired
	private final ILoginServ serv;

	/**
	 * 注入redis
	 */
	@Autowired
	private final RedisService redisService;

	public AccessInterceptor(ILoginServ serv, RedisService redisService) {
		this.serv = serv;
		this.redisService = redisService;
	}

	/**
	 * &lt;h2&gt;前置拦截器,方法执行之前&lt;/h2&gt;
	 */
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

		if ((handler instanceof HandlerMethod)) {
			User user = getUser(request, response);
			UserContext.setUser(user);
			HandlerMethod handlerMethod = (HandlerMethod) handler;
			AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class);

			if (accessLimit == null) {
				return true;
			}

			int seconds = accessLimit.seconds();
			int maxCount = accessLimit.maxCount();
			boolean needLogin = accessLimit.needLogin();
			String key = request.getRequestURI();

			if (needLogin) {
				user = UserContext.getUser();
				if (user == null) {
					render(response, CodeMsg.SESSION_ERROE);
					return false;
				}
				key += "_" + user.getId();
			} else {
				//do nothing
			}
			AccessKey accessKey = AccessKey.withExpire(seconds);
			Integer count = redisService.get(accessKey, key, Integer.class);

			if (count == null) {
				redisService.set(accessKey, key, 1);
			} else if (count &lt; maxCount) {
				redisService.incr(accessKey, key);
			} else {
				render(response, CodeMsg.ACCESS_LIMIT_REACHED);
				return false;
			}
		}
		return true;
	}

	/**
	 * &lt;h2&gt;通过请求和回应获取cookie&lt;/h2&gt;
	 * @param request 请求
	 * @param response 回应
	 * @return {@link User}
	 */
	private User getUser(HttpServletRequest request, HttpServletResponse response) {

		String paramToken = request.getParameter(Constant.TOKEN);
		String cookieToken = getCookieValue(request, Constant.TOKEN);

		if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) {
			return null;
		}
		String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
		return serv.getByToken(token, response);
	}

	/**
	 * &lt;h2&gt;通过将请求的所有cookie与回应cookie相比对，获取一致的cookie&lt;/h2&gt;
	 * @param token Cookie的名字
	 */
	private String getCookieValue(HttpServletRequest request,String token) {

		Cookie[] cookies = request.getCookies();
		if(cookies == null || cookies.length &lt;= 0){
			return null;
		}

		for (Cookie cookie: cookies) {
			if (cookie.getName().equals(token)) {
				return cookie.getValue();
			}
		}
		return null;
	}

	/**
	 * &lt;h2&gt;将错误抛给前台&lt;/h2&gt;
	 *
	 * @param response 回应
	 * @param codeMsg  错误码
	 */
	private void render(HttpServletResponse response, CodeMsg codeMsg) throws IOException {

		response.setContentType("application/json;charset=UTF-8");
		OutputStream out = response.getOutputStream();
		String str = JSON.toJSONString(Result.error(codeMsg));
		out.write(str.getBytes());
		out.flush();
		out.close();
	}
}
</code></pre> 
<p>在mvc中定义拦截器：</p> 
<pre class="has"><code> &lt;!-- 拦截器--&gt;
    &lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path="/**"/&gt;
        &lt;bean class="com.caoporn.merchants.access.AccessInterceptor"&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;</code></pre> 
<p>接下来就可以在controller写这个注解使用了</p> 
<pre class="has"><code>package com.caoporn.merchants.controller;

import com.caoporn.merchants.access.AccessLimit;
import com.caoporn.merchants.access.UserContext;
import com.caoporn.merchants.entity.User;
import com.caoporn.merchants.service.ILoginServ;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @Author: 史皓燃
 * @CreateDate 2019/1/19 15:22
 * &lt;h1&gt;goods controller&lt;/h1&gt;
 */
@Slf4j
@Controller
@RequestMapping("/goods")
public class GoodsController {

	@Autowired
	private final ILoginServ serv;

	public GoodsController(ILoginServ serv) {
		this.serv = serv;
	}

	@RequestMapping("/to_list")
	@AccessLimit(seconds=5, maxCount=5, needLogin=true)
	public String list(HttpServletRequest request, HttpServletResponse response, Model model, User user) {

		user = UserContext.getUser();
		log.info("now user is user : {}", user);
		model.addAttribute("user", user);
		return "goods_list.html";
	}
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4807cc5d8e85a5057ad80351956cc93d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JSOI2016】病毒感染</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c00f71c4b9d0b353e69bae8dee49f997/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MacOSX系统下HomeBrew安装指定版本的软件 &amp; IntelliJ IDEA 设置多个Go语言版本开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>