<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP可靠传输、拥塞控制、沾包知识点 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP可靠传输、拥塞控制、沾包知识点" />
<meta property="og:description" content="TCP面向连接，传输可靠
传输数据前需要先建立连接，结束后断开
TCP分层：
应用层：通过应用进程间交互完成网络任务
传输层：负责进程间提供数据传输服务（TCP/UDP）
网络层：网络层选择合适路由、节点确保数据传送（TCP/IP采用IP协议）
链路层：链路层将IP数据报装成帧
物理层：物理层实现计算机比特流传送
UDP面向无连接，传输不可靠
发送方直接发送，接收方直接接受
TCP保证可靠传输：
①校验和：TCP将保存首部和数据的校验和，当接收端接收后将计算，若校验和不一致，丢弃，不确定收到。
②流量控制：TCP连接每一方都有一个固定大小缓冲区，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方不可处理发送方数据，可以提示发送方降低发送速率。
③拥塞控制：当网络拥塞，发送方调整数据发送策略。
④ARQ（自动重传）协议：每发完一个分组停止，等待确认后再继续发送。（有超时、确认两个机制）
⑤超时重传：TCP发送分组后启动定时器，等待确认，若确认超时则重新发送。
流量控制：TCP采用滑动窗口控制，接收方的确认报文可以控制发送方窗口大小。
拥塞控制：
①慢开始：当刚开始发送数据时，先从小到大增大发送窗口（二倍提升）
②拥塞避免：当窗口达到慢开始门限值（初始16），改用拥塞避免算法，即一个一个开始加窗口大小。当网络拥塞后，窗口门限设置为当前一半，再重新慢开始、拥塞避免
③快重传：当接收方收到一个失序报文时立刻发送重复确认，而不是等到自己发送时再确认。发送方接收到连续重复确认三次后，直接重传丢失部分。
④快恢复：当连续收到三个重复确认，将窗口门限减半，但不执行慢开始，而是将窗口大小直接设置为门限大小，并执行拥塞控制增大窗口。
粘包：
定义：发送方若干数据包在到达接收方时粘到一起。
原因：
发送端：①要发送的数据小于缓冲区大小，发送时将多次写入缓冲区的数据一次性发送出去。
②Nagle算法：作用：减少网络报文数量
机制：在上一个小组确认，才发送下一个小组；收集多个小组，在一个确认到达时才一起发送。
接收端：没有及时读取缓冲区数据
处理：
发送方：关闭Nagle算法
接收方：让应用层从接收方缓存区读取数据时，给每个数据加上开始、结束标志
注：因为TCP为了保证可靠传输，采用基于流的传输，流并不认为消息是一条一条的，而是无保护消息边界的。
UDP是面向消息传输，接收方一次只接收一条独立消息（有消息保护边界），不存在粘包。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7bb9663c6e22898faab48fc4775cdbd5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-07T16:36:21+08:00" />
<meta property="article:modified_time" content="2022-04-07T16:36:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP可靠传输、拥塞控制、沾包知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>TCP</strong>面向连接，传输可靠<br> 传输数据前需要先建立连接，结束后断开</p> 
<p>TCP分层：<br> 应用层：通过应用进程间交互完成网络任务<br> 传输层：负责进程间提供数据传输服务（TCP/UDP）<br> 网络层：网络层选择合适路由、节点确保数据传送（TCP/IP采用IP协议）<br> 链路层：链路层将IP数据报装成帧<br> 物理层：物理层实现计算机比特流传送</p> 
<p><strong>UDP</strong>面向无连接，传输不可靠<br> 发送方直接发送，接收方直接接受</p> 
<p><strong>TCP保证可靠传输：</strong><br> ①校验和：TCP将保存首部和数据的校验和，当接收端接收后将计算，若校验和不一致，丢弃，不确定收到。<br> ②流量控制：TCP连接每一方都有一个固定大小缓冲区，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方不可处理发送方数据，可以提示发送方降低发送速率。<br> ③拥塞控制：当网络拥塞，发送方调整数据发送策略。<br> ④ARQ（自动重传）协议：每发完一个分组停止，等待确认后再继续发送。（有超时、确认两个机制）<br> ⑤超时重传：TCP发送分组后启动定时器，等待确认，若确认超时则重新发送。</p> 
<p>流量控制：TCP采用滑动窗口控制，接收方的确认报文可以控制发送方窗口大小。</p> 
<p><strong>拥塞控制：</strong><br> ①慢开始：当刚开始发送数据时，先从小到大增大发送窗口（二倍提升）<br> ②拥塞避免：当窗口达到慢开始门限值（初始16），改用拥塞避免算法，即一个一个开始加窗口大小。当网络拥塞后，窗口门限设置为当前一半，再重新慢开始、拥塞避免<br> ③快重传：当接收方收到一个失序报文时立刻发送重复确认，而不是等到自己发送时再确认。发送方接收到连续重复确认三次后，直接重传丢失部分。<br> ④快恢复：当连续收到三个重复确认，将窗口门限减半，但不执行慢开始，而是将窗口大小直接设置为门限大小，并执行拥塞控制增大窗口。</p> 
<p><strong>粘包：</strong><br> 定义：发送方若干数据包在到达接收方时粘到一起。</p> 
<p>原因：<br> 发送端：①要发送的数据小于缓冲区大小，发送时将多次写入缓冲区的数据一次性发送出去。<br> ②Nagle算法：作用：减少网络报文数量<br> 机制：在上一个小组确认，才发送下一个小组；收集多个小组，在一个确认到达时才一起发送。</p> 
<p>接收端：没有及时读取缓冲区数据</p> 
<p>处理：<br> 发送方：关闭Nagle算法<br> 接收方：让应用层从接收方缓存区读取数据时，给每个数据加上开始、结束标志</p> 
<p>注：因为TCP为了保证可靠传输，采用基于流的传输，流并不认为消息是一条一条的，而是无保护消息边界的。<br> UDP是面向消息传输，接收方一次只接收一条独立消息（有消息保护边界），不存在粘包。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/050e3e6f20c48ba8415b76d33c9d18e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java四种引用方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/176b4ac5f3685fd6f418d91ec6741dd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows内存占用过高</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>