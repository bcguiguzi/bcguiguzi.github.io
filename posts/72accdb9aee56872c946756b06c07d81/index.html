<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法——贪心 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法——贪心" />
<meta property="og:description" content="「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」
贪心无套路
1. 分发饼干 贪心策略：
（1）局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩
（2）局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩
代码实现：
// 冒泡排序 void sort(int *a, int len) { int flag = 1; for (int i = len - 1; flag &amp;&amp; i &gt; 0; i--) { flag = 0; for (int j = 0; j &lt; i; j&#43;&#43;) { if (a[j] &gt; a[j &#43; 1]) { flag = 1; int temp = a[j]; a[j] = a[j &#43; 1]; a[j &#43; 1] = temp; } } } } int findContentChildren(int *g, int gSize, int *s, int sSize) { sort(g, gSize); sort(s, sSize); int j = 0; int sum = 0; for (int i = 0; i &lt; gSize; i&#43;&#43;) { while (j &lt; sSize &amp;&amp; s[j] &lt; g[i]) { j&#43;&#43;; } if (j &lt; sSize) { sum&#43;&#43;; j&#43;&#43;; } } return sum; } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/72accdb9aee56872c946756b06c07d81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-17T15:52:58+08:00" />
<meta property="article:modified_time" content="2024-03-17T15:52:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法——贪心</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#0d0016;"><strong>「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」</strong></span></p> 
 <p></p> 
 <p><span style="color:#0d0016;"><strong>贪心无套路</strong></span></p> 
</blockquote> 
<h4><span style="color:#956fe7;"><strong>1. 分发饼干</strong></span></h4> 
<blockquote> 
 <p><img alt="" height="770" src="https://images2.imgbox.com/f2/2a/kMtNKo1v_o.png" width="859"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>贪心策略：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>（1）</strong></span><span style="color:#fe2c24;"><strong>局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong></span></p> 
 <p><strong><span style="color:#0d0016;">（2）</span></strong><span style="color:#fe2c24;"><strong>局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong></span></p> 
 <p><img alt="" height="439" src="https://images2.imgbox.com/95/a4/fHy8sFtR_o.png" width="832"></p> 
 <p><span style="color:#0d0016;"><strong>代码实现：</strong></span></p> 
 <pre><code class="language-cpp">// 冒泡排序
void sort(int *a, int len) {
    int flag = 1;
    for (int i = len - 1; flag &amp;&amp; i &gt; 0; i--) {
        flag = 0;
        for (int j = 0; j &lt; i; j++) {
            if (a[j] &gt; a[j + 1]) {
                flag = 1;
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp; 
            }
        }
    }
}

int findContentChildren(int *g, int gSize, int *s, int sSize) {
    sort(g, gSize);
    sort(s, sSize);
    int j = 0;
    int sum = 0;
    for (int i = 0; i &lt; gSize; i++) {
        while (j &lt; sSize &amp;&amp; s[j] &lt; g[i]) {
            j++;
        }
        if (j &lt; sSize) {
            sum++;
            j++;
        }
    }
    return sum;
}</code></pre> 
</blockquote> 
<h4 style="background-color:transparent;"><span style="color:#956fe7;"><strong>2. 摆动序列</strong></span></h4> 
<blockquote> 
 <p><img alt="" height="587" src="https://images2.imgbox.com/78/c8/oKf8iodN_o.png" width="876"></p> 
 <p><img alt="" height="595" src="https://images2.imgbox.com/a1/86/qwP4WR3w_o.png" width="859"></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">贪心策略：</span></strong></p> 
 <p><span style="color:#4da8ee;"><strong>「局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值」</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>「整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列」</strong></span></p> 
 <p></p> 
 <p><span style="color:#4da8ee;"><strong>「实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）」</strong></span></p> 
 <p><img alt="" height="417" src="https://images2.imgbox.com/db/79/kIJReaOU_o.png" width="1080"></p> 
 <p><span style="color:#0d0016;"><strong>代码实现：</strong></span></p> 
 <pre><code class="language-cpp">int wiggleMaxLength(int *nums, int numsSize) {
    if (numsSize &lt;= 1) {
        return numsSize;
    }
    int now = 0; // 当前一对峰值
    int pre = 0; // 前一对峰值
    int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
    for (int i = 1; i &lt; numsSize; i++) {
        now = nums[i] - nums[i - 1];
        // 出现峰值
        if ((now &gt; 0 &amp;&amp; pre &lt;= 0) || (pre &gt;= 0 &amp;&amp; now &lt; 0)) {
            result++;
            pre = now;
        }
    }
    return result;
}</code></pre> 
</blockquote> 
<h4 style="background-color:transparent;"><span style="color:#956fe7;">3. 最大子数组和</span></h4> 
<blockquote> 
 <p><img alt="" height="747" src="https://images2.imgbox.com/fc/54/OQ02nG71_o.png" width="821"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>暴力解法：超时</strong></span></p> 
 <pre><code class="language-cpp">int maxSubArray(int *nums, int numsSize) {
    int result = INT32_MIN;
    int count = 0;
    for (int i = 0; i &lt; numsSize; i++) { // 设置起始位置
        count = 0;
        for (int j = i; j &lt; numsSize; j++) { // 每次从起始位置i开始遍历寻找最大值
            count += nums[j];
            result = count &gt; result ? count : result;
        }
    }
    return result;
}</code></pre> 
 <p><span style="color:#fe2c24;"><strong>动规五步曲：</strong></span></p> 
 <ul><li> <p><span style="color:#0d0016;"><strong>确定dp数组（dp table）以及下标的含义</strong></span></p> </li></ul> 
 <p><span style="color:#0d0016;"><strong>dp[i]：以 i 结尾的最大连续子序列和为dp[i]</strong></span></p> 
 <ul><li> <p><span style="color:#0d0016;"><strong>确定递推公式（容斥原理）</strong></span></p> </li></ul> 
 <p><span style="color:#0d0016;"><strong>dp[i]只有两个方向可以推出来：</strong></span></p> 
 <ul><li> <p><span style="color:#0d0016;"><strong>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</strong></span></p> </li><li> <p><span style="color:#0d0016;"><strong>nums[i]，即：从头开始计算当前连续子序列和</strong></span></p> </li></ul> 
 <p><span style="color:#0d0016;"><strong>一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);</strong></span></p> 
 <p></p> 
 <pre><code class="language-cpp">#define max(a, b) ((a) &gt; (b) ? (a) : (b))

int maxSubArray(int *nums, int numsSize) {
    if (numsSize == 0) { // 特殊情况
        return 0;
    }
    int dp[numsSize];
    dp[0] = nums[0];
    int result = dp[0];
    for (int i = 1; i &lt; numsSize; i++) {
        dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移方程
        result = max(result, dp[i]); // result 保存dp[i]的最大值
    }
    return result;
}</code></pre> 
 <p><strong><span style="color:#fe2c24;">贪心策略：</span></strong></p> 
 <p><strong><span style="color:#0d0016;">局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小</span></strong></p> 
 <p><strong><span style="color:#0d0016;">全局最优：选取最大“连续和”</span></strong></p> 
 <pre><code class="language-cpp">int maxSubArray(int *nums, int numsSize) {
    int result = INT32_MIN;
    int count = 0;
    for (int i = 0; i &lt; numsSize; i++) {
        count += nums[i];
        if (count &gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
            result = count;
        }
        if (count &lt;= 0) {
            count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
    }
    return result;
}</code></pre> 
</blockquote> 
<h4 style="background-color:transparent;"><span style="color:#956fe7;"><strong>4. 买卖股票的最佳时机||</strong></span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>贪心策略：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>「局部最优：收集每天的正利润，全局最优：求得最大利润」</strong></span></p> 
</blockquote> 
<h4><span style="color:#956fe7;">5. 跳跃游戏</span></h4> 
<blockquote> 
 <p><img alt="" height="697" src="https://images2.imgbox.com/bd/c7/NdxVrEki_o.png" width="742"></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">贪心策略：</span></strong></p> 
 <p><span style="color:#0d0016;"><strong>「贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点」</strong></span></p> 
 <p></p> 
</blockquote> 
<p>6. 跳跃游戏||</p> 
<p>7. K次取反后最大化的数组和</p> 
<blockquote> 
 <p><img alt="" height="794" src="https://images2.imgbox.com/df/79/MpJxmC5e_o.png" width="525"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>贪心策略：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>       </strong></span><span style="color:#fe2c24;"><strong> 局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        如果将负数都转变为正数了，K依然大于0</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大，全局最优：整个 数组和 达到最大</strong></span></p> 
 <ul><li> <p><strong><span style="color:#0d0016;">第一步：将数组按照绝对值大小从大到小排序，「注意要按照绝对值的大小」</span></strong></p> </li><li> <p><strong><span style="color:#0d0016;">第二步：从前向后遍历，遇到负数将其变为正数，同时K--</span></strong></p> </li><li> <p><strong><span style="color:#0d0016;">第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</span></strong></p> </li><li> <p><strong><span style="color:#0d0016;">第四步：求和</span></strong></p> </li></ul> 
</blockquote> 
<p>8. 加油站</p> 
<blockquote> 
 <p><img alt="" height="624" src="https://images2.imgbox.com/64/a5/8C0bVr4X_o.png" width="680"></p> 
 <p><img alt="" height="540" src="https://images2.imgbox.com/e4/ba/acs8G2QO_o.png" width="672"></p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20fcc954880916c80ba3f46561ea50b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【开源】SpringBoot框架开发就医保险管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09eb2d7d1989a6ade16e5f413fb20539/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux: boot: latency启动延迟分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>