<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c&#43;&#43;】Opencv Mat类详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【c&#43;&#43;】Opencv Mat类详解" />
<meta property="og:description" content="1. Mat类常用成员函数和成员变量 由于 Mat 类使用的非常广泛，使用的形式也非常之多，这里只对较为常用的成员函数和成员变量做出了整理；
1.1 构造函数 （1）默认构造函数 cv::Mat::Mat() 默认构造函数：生成一个矩阵并由OpenCV提供的函数(一般是Mat::create() 和 cv::imread() )来分配储存空间。
Mat类可以分为两个部分：矩阵头和指向像素数据的矩阵指针
矩阵头：包括数字图像的矩阵尺寸、存储方法、存储地址和引用次数等，矩阵头的大小是一个常数，不会随着图像的大小而改变，但是保存图像像素数据的矩阵则会随着图像的大小而改变，通常数据量会很大，比矩阵头大几个数量级。这样，在图像复制和传递过程中，主要的开销是由存放图像像素的矩阵而引起的。因此，OpenCV使用了引用次数，当进行图像复制和传递时，不再复制整个Mat数据，而只是复制矩阵头和指向像素矩阵的指针，例如：
cv::Mat a ; //默认构造函数，创建矩阵头 a = cv::imread(&#34;test.jpg&#34;); //读入图像，矩阵指针指向该像素数据 cv::Mat b = a ; //复制　上面的a，b有各自的矩阵头，但是其矩阵指针指向同一个矩阵，也就是其中任何一个改变了矩阵数据都会影响另外一个。那么，多个Mat共用一个矩阵数据，最后谁来释放矩阵数据呢？
这就是引用计数的作用，当Mat对象每被复制一次时，就会将引用计数加1，而每销毁一个Mat对象（共用同一个矩阵数据）时引用计数会被减1，当引用计数为0时，矩阵数据会被清理。
（2）常用构造函数——1 cv::Mat::Mat(int rows,int cols,int type) 重载的构造函数，这也是常用构造函数之一，在创建对象同时，提供矩阵的大小（rows，行数；cols ，列数），以及存储类型（type）
该类型表示矩阵中每一个元素在计算机内存的存储类型，如CV_8UC3，具体含义为“3通道8位无符号数”。
eg：
Mat src(10,10,CV_32FC3); //表示src是一个10*10的矩阵，且矩阵元素以32位float型存储 类似，OpenCV还提供了一种Size() 数据结构来构造Mat对象
（3）常用构造函数——2 cv::Mat::Mat(Size size,int type ) Size类等效于一个成对数据，size::Size(cols,rows)，特别注意 cols和rows的位置
eg：
Mat src1(3, 4, CV_32FC3); Mat src2(Size(3, 4), CV_32FC3); cout &lt;&lt; &#34;src1.rows=&#34; &lt;&lt; src1.rows &lt;&lt; &#34; src1.cols=&#34; &lt;&lt; src1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7815fb44c20f51ea3175912cfa4e9c3f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-31T18:48:20+08:00" />
<meta property="article:modified_time" content="2021-08-31T18:48:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c&#43;&#43;】Opencv Mat类详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>1. Mat类常用成员函数和成员变量</strong></h2> 
<p>        由于 Mat 类使用的非常广泛，使用的形式也非常之多，这里只对较为常用的成员函数和成员变量做出了整理；</p> 
<h3><strong>1.1 构造函数</strong></h3> 
<h4>（1）<strong>默认构造函数</strong></h4> 
<pre><code class="language-cpp">cv::Mat::Mat()</code></pre> 
<p><strong>默认构造函数：</strong>生成一个矩阵并由OpenCV提供的函数(一般是Mat::create() 和 cv::imread() )来分配储存空间。</p> 
<p>Mat类可以分为两个部分：<strong>矩阵头</strong>和<strong>指向像素数据的矩阵指针</strong></p> 
<p><strong>矩阵头：</strong>包括数字图像的矩阵尺寸、存储方法、存储地址和引用次数等，矩阵头的大小是一个常数，不会随着图像的大小而改变，但是保存图像像素数据的矩阵则会随着图像的大小而改变，通常数据量会很大，比矩阵头大几个数量级。这样，在图像复制和传递过程中，主要的开销是由存放图像像素的矩阵而引起的。因此，OpenCV使用了引用次数，当进行图像复制和传递时，不再复制整个Mat数据，而只是复制矩阵头和指向像素矩阵的指针，例如：</p> 
<pre><code class="language-cpp">cv::Mat a ;                 //默认构造函数，创建矩阵头
a = cv::imread("test.jpg"); //读入图像，矩阵指针指向该像素数据
cv::Mat b = a ;             //复制　</code></pre> 
<p>        上面的a，b有各自的矩阵头，但是其矩阵指针指向同一个矩阵，也就是其中任何一个改变了矩阵数据都会影响另外一个。那么，多个Mat共用一个矩阵数据，最后谁来释放矩阵数据呢？<br>         这就是引用计数的作用，当Mat对象每被复制一次时，就会将引用计数加1，而每销毁一个Mat对象（共用同一个矩阵数据）时引用计数会被减1，当引用计数为0时，矩阵数据会被清理。</p> 
<h4><strong>（2）常用构造函数——1</strong></h4> 
<pre><code class="language-cpp">cv::Mat::Mat(int rows,int cols,int type)</code></pre> 
<p>        重载的构造函数，这也是常用构造函数之一，在创建对象同时，提供矩阵的大小（rows，行数；cols ，列数），以及存储类型（type）<br> 该类型表示矩阵中每一个元素在计算机内存的存储类型，如CV_8UC3，具体含义为“3通道8位无符号数”。</p> 
<p>eg：</p> 
<pre><code class="language-cpp">Mat src(10,10,CV_32FC3);  //表示src是一个10*10的矩阵，且矩阵元素以32位float型存储</code></pre> 
<p>类似，OpenCV还提供了一种Size() 数据结构来构造Mat对象</p> 
<h4><strong>（3）常用构造函数——2</strong></h4> 
<pre><code class="language-cpp">cv::Mat::Mat(Size size,int type )   </code></pre> 
<p>Size类等效于一个成对数据，size::Size(cols,rows)，<strong>特别注意 cols和rows的位置</strong></p> 
<p>eg：</p> 
<pre><code class="language-cpp">Mat src1(3, 4, CV_32FC3);
Mat src2(Size(3, 4), CV_32FC3);
cout &lt;&lt; "src1.rows=" &lt;&lt; src1.rows &lt;&lt; " src1.cols=" &lt;&lt; src1.cols &lt;&lt;endl;
cout &lt;&lt; "src2.rows=" &lt;&lt; src2.rows &lt;&lt; " src2.cols=" &lt;&lt; src2.cols &lt;&lt; endl;
cout &lt;&lt; "src1.size="&lt;&lt;src1.size() &lt;&lt; endl &lt;&lt;"src2.size=" &lt;&lt; src2.size() &lt;&lt;endl;</code></pre> 
<p></p> 
<p>         不得不说，这个Size类的数据结构有点“反人类”，但这样做的好处是方便了计算机内部的运算（比如OpenCV很多函数计算Size相关的数据也是按这个顺序来的，具体为什么这样，我也不太清楚，个人理解为行业标准）；</p> 
<p>        还有，我们平时所说分辨率，也是Size的类型，比如屏幕分别率 1440*900，其中cols=1440，rows=900；</p> 
<h4><strong>（3）常用构造函数——3</strong></h4> 
<pre><code class="language-cpp">cv::Mat::Mat(int ndims,const int *  sizes,int type,const Scalar&amp; s) </code></pre> 
<p>该构造函数与使用了Scalar参数，作用是能够通过Scalar数据类来初始化元素值，例如，我们要生成一张白色背景的图片：</p> 
<pre><code class="language-cpp">Mat src1(300, 400, CV_8UC3,Scalar(255,255,255));
imshow("test", src1);</code></pre> 
<p>其中，（255,255,255）对应以8位无符号数存储，RGB色域的白色值。</p> 
<h4><strong>（5）常用构造函数——4</strong></h4> 
<pre><code class="language-cpp">cv::Mat::Mat(const Mat &amp; m)</code></pre> 
<p>引用m矩阵，注意，这里是引用值；</p> 
<h3><strong>1.2 成员函数</strong></h3> 
<h4>（1）<strong>at函数</strong><br> at函数的功能是访问矩阵元素，根据不同的使用场景，有多个重载函数可供选择。<br> 如，访问一个二维的矩阵，可用at函数原型为：</h4> 
<pre><code class="language-cpp">_Tp&amp; cv::Mat::at(int i0,int i1)</code></pre> 
<p>eg：</p> 
<pre><code class="language-cpp">Mat src = imread("test.jpg");
int elem = src.at&lt;int&gt;(0,0);</code></pre> 
<p>访问test.jpg图像的（0 , 0）元素</p> 
<h4>（2）<strong>channels函数</strong></h4> 
<pre><code class="language-cpp">int cv::Mat::channels()  const</code></pre> 
<p>返回图像的通道数</p> 
<h4>（3）<strong>clone函数</strong></h4> 
<pre><code class="language-cpp">Mat cv::Mat::clone()    const</code></pre> 
<p>矩阵复制</p> 
<h4>（4）<strong>convertTo函数</strong></h4> 
<pre><code class="language-cpp">void cv::Mat::convertTo(OutputArray m,int rtype,double alpha = 1,double beta = 0)   const</code></pre> 
<p>转换矩阵存储类型，具体计算公式如下：</p> 
<pre><code>m(x,y)=saturate_cast&lt;rType&gt;(α(∗this)(x,y)+β)</code></pre> 
<p>m是输入矩阵，rtype是目标类型，alpha是放缩系数，beta是增减标量</p> 
<h4>（5）<strong>copyTo函数</strong></h4> 
<pre><code class="language-cpp">void cv::Mat::copyTo(OutputArray    m)  const</code></pre> 
<p>从m矩阵复制data数据单元，与clone函数的作用类似</p> 
<h4>（6）<strong>create函数</strong></h4> 
<pre><code class="language-cpp">void cv::Mat::create(int rows,int cols,int type) </code></pre> 
<p>分配矩阵的存储单元，一般和默认构造函数配合使用</p> 
<h4>（7）depth函数</h4> 
<pre><code class="language-cpp">int cv::Mat::depth()    const</code></pre> 
<p>返回图像深度，即矩阵元素的存储方式</p> 
<h4>（8）<strong>diag函数</strong></h4> 
<pre><code class="language-cpp">Mat cv::Mat::diag(int d = 0)  const</code></pre> 
<p>提取矩阵的对角元素</p> 
<h4>（9）<strong>mul函数</strong></h4> 
<pre><code class="language-cpp">MatExpr cv::Mat::mul(InputArray m,double scale = 1)    const</code></pre> 
<p>矩阵的乘法</p> 
<h4>（10）<strong>inv函数</strong></h4> 
<pre><code class="language-cpp">MatExpr cv::Mat::inv(int method = DECOMP_LU)   const</code></pre> 
<p>求逆矩阵</p> 
<h4>（11）<strong>t函数</strong></h4> 
<pre><code class="language-cpp">MatExpr cv::Mat::t() const</code></pre> 
<p>求转置矩阵</p> 
<h4><br> （12）<strong>total函数</strong></h4> 
<pre><code class="language-cpp">size_t cv::Mat::total() const</code></pre> 
<p>返回矩阵的元素总个数，如30*40的图像，存在1200个像素点</p> 
<h4>（13）<strong>pop_back函数</strong></h4> 
<p>eg：</p> 
<pre><code>object.pop_back();	//object是一个矩阵，该函数功能是弹出最后一行元素</code></pre> 
<h4>（14）<strong>release函数</strong></h4> 
<p>在必要的情况下，递减引用计数并释放该矩阵。</p> 
<p>C++: void Mat::release()</p> 
<p>该方法递减与矩阵的数据关联的引用计数。当引用计数减为0时，矩阵的数据将被释放，数据和引用计数器指针设置为 NULL。如果矩阵头指向外部数据集 （见 Mat::Mat()）， 引用计数为 NULL，并且该方法在这种情况下无效。</p> 
<p>可以手动调用此方法强制矩阵数据释放。但由于这种方法在析构函数中是自动调用的，或以更改数据指针的其他方法，因此通常不需要调用这个函数。在支持它的平台上，引用计数器递减并检查是否为0 是一个原子操作。因此，在不同的线程异步调用相同的矩阵是安全的操作。</p> 
<h4>(15) Mat::ones()函数</h4> 
<pre><code class="language-cpp">Mat m = Mat::ones(2, 2, CV_8UC3); 相当于：Mat m = Mat(2, 2, CV_8UC3, 1);</code></pre> 
<p>// OpenCV replaces 1 with Scalar(1,0,0)相当于每个像素的第一个通道为1，其余两个通道为0；</p> 
<h4>(16) Mat::zeros()函数</h4> 
<pre><code class="language-cpp">Mat m = Mat::zeros(2, 2, CV_8UC3);</code></pre> 
<p>//相当于创建一张黑色的图，每个像素的每个通道都为0,Scalar(0,0,0)；<br>  </p> 
<h3>2.3 成员变量</h3> 
<pre><code class="language-cpp">int cv::Mat::cols;     //返回矩阵的列数

int cv::Mat::rows      // 返回矩阵行数

uchar* cv::Mat::data   // 指向矩阵的数据单元的指针

int cv::Mat::dims      // 返回矩阵维度，该维度≥2

MatSize cv::Mat::size  // 返回矩阵大小</code></pre> 
<p>关于 opencv 我处于初学阶段，在学习的过程中对 Mat 类进行一个整合、补充，后面仍会继续完善；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38450a1ce82eeda64b449b620ba8fa32/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【正点原子Linux连载】第四十章 字符设备驱动开发 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db4b4ca2ca82487caad78d2b12a2714a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pandas 数据类型及相互转化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>