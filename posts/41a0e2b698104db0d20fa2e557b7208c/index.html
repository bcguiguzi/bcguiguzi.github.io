<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;数据结构之线性表——顺序表的应用(多余元素删除 求最大子段和递归&#43;动态规划) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;数据结构之线性表——顺序表的应用(多余元素删除 求最大子段和递归&#43;动态规划)" />
<meta property="og:description" content="一、介绍 顺序表作为一种基于连续存储空间的数据结构可以有多种应用，本文就以将非纯表转纯表以及求最大子段和的两种方法（递归和动态规划）进行介绍和讲解。
在阅读本文之前建议先了解顺序表的实现，因为顺序表的应用基本是依托顺序表已经实现的部分功能才能实现的，具体可看我的另一篇文章：C&#43;&#43;数据结构之线性表——顺序表https://blog.csdn.net/m0_56398315/article/details/126748495?spm=1001.2014.3001.5501
为了方便后续的代码读的明白，下图是顺序表中已经实现的函数：
void init();//创建顺序表 void destroy();//销毁顺序表 void clear();//清空顺序表 bool empty();//检测是否为空 int getlength();//获取顺序表的长度 int get(int index);//获取下标为index的元素 int locate(int ele);//查找元素ele所在位置的下标 int prior(int index);//取下标为index的元素的前驱元素 int next(int index);//取下标为index的元素的后继元素 void insert(int ele,int index);//在下标为index的元素位置插入元素ele,原位置的元素依次后移一位 void remove(int index);//删除下标为index的元素，下标index后的元素依次向前移动一位 void traverse();//遍历表 void print();//打印表 void push(int ele);//从表尾插入元素 void batchpush();//批量压入数据 二、多余元素删除 概念 1.非纯表 非纯表指的是存在多个相同元素的表，如下图所示就是一个非纯表，其中存在两个相同的元素57
2.纯表 纯表指的是不存在多个相同元素的表，如下图所示就是一个纯表，其中无法找到两个相同的元素
实现 要想实现多余元素的删除我们有多种实现方法，有移位删除法和建新表删除法，下面对这两种方法进行一一介绍。
1.移位删除法 算法思想
1.我们以第1个元素为标准，依次对其后面n-1个元素进行比较
2.若发现有和第一个元素相同的元素，那么我们就删除他
3.直到后面n-1个元素检查完毕
4.我们以第2个元素为标准，依次对其后面n-2个元素进行比较
5.若发现有和第二个元素相同的元素，那么我们就删除他
6.直到后面n-2个元素检查完毕
7.以此类推，直到算法执行完毕
算法实现
void sqlist::shiftremove() { for (int i = 0; i &lt; length; i&#43;&#43;) { for (int j = i&#43;1; j &lt; length; j&#43;&#43;) { if (element[i]==element[j]) { remove(j); j--; } } } } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/41a0e2b698104db0d20fa2e557b7208c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-09T21:32:13+08:00" />
<meta property="article:modified_time" content="2022-09-09T21:32:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;数据结构之线性表——顺序表的应用(多余元素删除 求最大子段和递归&#43;动态规划)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、介绍</h2> 
<p>顺序表作为一种基于连续存储空间的数据结构可以有多种应用，本文就以将非纯表转纯表以及求最大子段和的两种方法（递归和动态规划）进行介绍和讲解。</p> 
<p>在阅读本文之前建议先了解顺序表的实现，因为顺序表的应用基本是依托顺序表已经实现的部分功能才能实现的，具体可看我的另一篇文章：<a class="link-info has-card" href="https://blog.csdn.net/m0_56398315/article/details/126748495?spm=1001.2014.3001.5501" title="C++数据结构之线性表——顺序表"><span class="link-card-box"><span class="link-title">C++数据结构之线性表——顺序表</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/8a/fa/GRy7m2cs_o.png">https://blog.csdn.net/m0_56398315/article/details/126748495?spm=1001.2014.3001.5501</span></span></a></p> 
<p>为了方便后续的代码读的明白，下图是顺序表中已经实现的函数：</p> 
<pre><code class="language-cpp">    void init();//创建顺序表
    void destroy();//销毁顺序表
    void clear();//清空顺序表
    bool empty();//检测是否为空
    int getlength();//获取顺序表的长度
    int get(int index);//获取下标为index的元素
    int locate(int ele);//查找元素ele所在位置的下标
    int prior(int index);//取下标为index的元素的前驱元素
    int next(int index);//取下标为index的元素的后继元素
    void insert(int ele,int index);//在下标为index的元素位置插入元素ele,原位置的元素依次后移一位
    void remove(int index);//删除下标为index的元素，下标index后的元素依次向前移动一位
    void traverse();//遍历表
    void print();//打印表
    void push(int ele);//从表尾插入元素
    void batchpush();//批量压入数据</code></pre> 
<h2>二、多余元素删除</h2> 
<h3>概念</h3> 
<h4>1.非纯表</h4> 
<p>非纯表指的是存在多个相同元素的表，如下图所示就是一个非纯表，其中存在两个相同的元素57</p> 
<p class="img-center"><img alt="" height="115" src="https://images2.imgbox.com/89/8d/4xKRlcOx_o.png" width="609"></p> 
<p></p> 
<h4> 2.纯表</h4> 
<p>纯表指的是不存在多个相同元素的表，如下图所示就是一个纯表，其中无法找到两个相同的元素</p> 
<p class="img-center"><img alt="" height="108" src="https://images2.imgbox.com/84/c5/KFA6piSF_o.png" width="606"></p> 
<h3> 实现</h3> 
<p>要想实现多余元素的删除我们有多种实现方法，有移位删除法和建新表删除法，下面对这两种方法进行一一介绍。</p> 
<h4>1.移位删除法</h4> 
<p><strong>算法思想</strong></p> 
<p><strong>1.</strong>我们以第1个元素为标准，依次对其后面n-1个元素进行比较</p> 
<p><strong>2.</strong>若发现有和第一个元素相同的元素，那么我们就删除他</p> 
<p><strong>3.</strong>直到后面n-1个元素检查完毕</p> 
<p><strong>4.</strong>我们以第2个元素为标准，依次对其后面n-2个元素进行比较</p> 
<p><strong>5.</strong>若发现有和第二个元素相同的元素，那么我们就删除他</p> 
<p><strong>6.</strong>直到后面n-2个元素检查完毕</p> 
<p><strong>7.</strong>以此类推，直到算法执行完毕</p> 
<p><strong>算法实现</strong></p> 
<pre><code class="language-cpp">void sqlist::shiftremove()
{
    for (int i = 0; i &lt; length; i++)
    {
        for (int j = i+1; j &lt; length; j++)
        {
            if (element[i]==element[j])
            {              
                remove(j);
                j--;
            }
        }
    }  
}</code></pre> 
<h4></h4> 
<h4>2.建新表删除法</h4> 
<p><strong>算法思想</strong></p> 
<p>首先需要进行说明的是，这个算法的实现基础是表还未建的情况下，因此对于表已经建好了的情况是不适用的</p> 
<p><strong>1.</strong> 用户输入表的元素个数n</p> 
<p><strong>2.</strong> 用户输入元素</p> 
<p><strong>3. </strong>判断当前表的长度，如果为0说明为空表，直接将该元素作为表的第一个元素</p> 
<p><strong>4. </strong>如果不为0说明表不为空表，此时需要对整个表进行遍历检查</p> 
<p><strong>5. </strong>如果发现有相同的元素，那么用户输入的该元素就无法插入表中，若没有发现相同的元素就将该元素插入表中</p> 
<p><strong>6. </strong>以此类推循环n次，就可以得到一个不含多余元素的表</p> 
<p><strong>算法实现</strong></p> 
<pre><code class="language-cpp">void sqlist::createremove()
{
    cout&lt;&lt;"请输入要输入的元素个数:"&lt;&lt;endl;
    int elenum;
    cin&gt;&gt;elenum;
    element=(int*)malloc(elenum*sizeof(int));//分配内存大小为elenum*sizeof(int)的空间
    while (elenum--)
    {
        cout&lt;&lt;"请输入元素element["&lt;&lt;length&lt;&lt;"]:";
        int tempele;
        cin&gt;&gt;tempele;
        if (length==0)
        {
            element[0]=tempele;
            length++;
        }
        else
        {
            int i;
            for (i = 0; i &lt; length; i++)
            {
                if (element[i]==tempele)
                {
                    break;
                }      
            }
            if (i==length)
            {
                push(tempele);     
            }    
        }   
    }
}</code></pre> 
<h2></h2> 
<h2>三、求最大子段和</h2> 
<h3>概念</h3> 
<h4>1.子段和</h4> 
<p>子段和指的是一个表中，<strong>连续</strong>的一个或多个元素的和，如下图的一个顺序表element[]所示：</p> 
<p class="img-center"><img alt="" height="108" src="https://images2.imgbox.com/6a/27/bxxdC1Dm_o.png" width="606"></p> 
<p> 在这个表中我们可以得到多个子段，如<strong>element[0]</strong>和<strong>element[1]</strong>可以构成一个子段，因此其子段和为<strong>element[0]+element[1]=25+34=59</strong>,<strong>element[2]</strong>和<strong>element[3]</strong>和<strong>element[4]</strong>也可以构成一个子段，其子段和为<strong>element[2]+element[3]+element[4]=137</strong>，当然了，单个元素自身的值也可以是一个子段，其子段和就是其自身的数值</p> 
<h4>2.最大子段和</h4> 
<p>最大子段和指的是在表中的一个子段，其子段和大于这个表中其他所有的子段，如下图所示：</p> 
<p class="img-center"><img alt="" height="103" src="https://images2.imgbox.com/15/b3/DGlNvIKw_o.png" width="461"></p> 
<p> 这个表的一个子段由<strong>element[1]</strong>、<strong>element[2]</strong>、<strong>element[3]</strong>构成，其子段和为20，大于这个表中其他的子段和，因此这个表的最大子段和就是20</p> 
<h3>实现</h3> 
<h4>1.递归</h4> 
<p><strong>算法思想</strong></p> 
<p><strong>i.最大子段的位置</strong></p> 
<p> 设有一个顺序表，我们要求得其最大子段和，那么我们就需要求得他的这个最大子段，而一个表的最大子段只有三种情况：</p> 
<p>把一个顺序表分成两半，分别为<strong>左半部分：element[0]~element[(length-1)/2]</strong> 和<strong>右半部分：element[(length-1)/2+1]~element[length-1] ,</strong>那么最大子段只能要么<strong>全部存在于左半部分</strong>，要么<strong>全部存在于右半部分</strong>，<strong>要么处于中间位置</strong>（即一部分位于左半部分的尾部一部分位于右半部分的头部）。</p> 
<p>了解上面最大子段的位置之后，我们就可以得到：</p> 
<p><strong>表的最大子项和=max(左半部分的最大子项和,右半部分的最大子段和，中间部分的最大子段和）</strong></p> 
<p></p> 
<p><strong>ii.确定递归基</strong></p> 
<p> 一个问题要想用递归的思想来做，就必须存在<strong>递归基</strong>（对递归的基本知识还不清楚的可以看下面的一篇文章：<a href="https://blog.csdn.net/qq_44096670/article/details/111936140?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166272837916800186560888%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166272837916800186560888&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111936140-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Econtrol_2&amp;utm_term=%E9%80%92%E5%BD%92%E5%9F%BA&amp;spm=1018.2226.3001.4187" title="递归（Recursion）_bfhonor的博客-CSDN博客_递归基">递归（Recursion）_bfhonor的博客-CSDN博客_递归基</a>），那么什么时候会达到递归基呢？我们可以知道，将一个表不断从中“”斩断“再“斩断”，最后会产生单个元素，我们可以知道，单个元素的最大子段和是其本身的值，因此，当不断递归分解直到只剩一个元素的时候我们就达到了递归基，在明确递归基之后我们就可以开始设计递归算法。</p> 
<p><strong>iii.设计算法</strong></p> 
<p>为了不局限于只能求一整个表的最大子段和，我们设计算法的时候引入了两个参数分别是<strong>left</strong>和<strong>right</strong>用来表示表的一个区间，我们在这个区间内来求最大子项和。根据：</p> 
<blockquote> 
 <p><strong>表的最大子项和=<span style="color:#fe2c24;">max</span>(左半部分的最大子项和,右半部分的最大子段和，中间部分的最大子段和）</strong></p> 
</blockquote> 
<p>我们可以知道，要求一个区间内的最大子段和我们需要得到三个最大子段和，分别是<strong>左半部分的最大子项和,右半部分的最大子段和，中间部分的最大子段和</strong></p> 
<p><strong>左半部分和右半部分的子段和</strong>我们可以用<span style="color:#fe2c24;">递归</span>来求取，但是中间的就不可以了，因此我们需要另外对中间的最大子段和求取进行设计：</p> 
<blockquote> 
 <p><strong>求解中间部分最大子项和：</strong></p> 
 <p>我们可以以中间为起始点，向左添加元素直到将左半部分全部元素添加完，求取左半部分的最大子段和<strong>leftmaxsum</strong>，同样以中间为起始点，向右添加元素直到将右半部分全部元素添加完，求取右半部分的最大子段和<strong>rightmaxsum,</strong>两者相加我们就得到了<strong>中间部分的最大子段和</strong></p> 
</blockquote> 
<p>最后再把三个部分进行比较就得到了整个区间的最大子段和。</p> 
<p></p> 
<p><strong>算法实现</strong></p> 
<pre><code class="language-cpp">int sqlist::r_maxsum(int left,int right)
{
    k++;//用来记录递归次数的，可以不用管
    int maxsum=0;
    
    if (left==right)//当边界相等的时候说明只有一个元素，达到递归基并将对应值返回
    {
        if (element[left]&gt;0)//如果该元素大于0
        {
            maxsum=element[left];//那么其就是最大子段和，
        }
        else
        {
            maxsum=0;
        }
    }
    else//当边界不相等时为一般情况
    {
        int mid=(left+right)/2;//求取中间分界点
        //以中间为边界进行递归
        int leftsum=r_maxsum(left,mid);//左半部分的递归
        int rightsum=r_maxsum(mid+1,right);//右半部分的递归
        //求左半部分的最大子段和
        int leftmaxsum=0;//用来存储左半部分的最大字段和
        int templeftmaxsum=0;//用来存储左半部分当前的子段和
        for (int i = mid; i &gt;=left; i--)//由中间向左边扩散
        {
            templeftmaxsum=templeftmaxsum+element[i];//每次向左加一个数
            if (templeftmaxsum&gt;leftmaxsum)//如果发现加完后子段和变大了
            {
                leftmaxsum=templeftmaxsum;//那么更新最大子段和
            }
        }
        //求右半部分的最大子段和
        int rightmaxsum=0;//用来存储右半部分的最大字段和
        int temprightmaxsum=0;//用来存储右半部分当前的字段和
        for (int j = mid+1; j &lt;=right; j++)//由中间向右边扩散
        {
            temprightmaxsum=temprightmaxsum+element[j];//每次向左加一个数
            if (temprightmaxsum&gt;rightmaxsum)//如果发现加完后子段和变大了
            {
                rightmaxsum=temprightmaxsum;//那么更新最大子段和
            }
        }      
        maxsum=leftmaxsum+rightmaxsum;//子段和合并得到中间部分的最大子段和
        if (maxsum&lt;leftsum)//比较三者的大小并返回最大的子段和
        {
            maxsum=leftsum;
        }
        else if (maxsum&lt;rightsum)
        {
            maxsum=rightsum;
        }
    }
    //返回最大子项和
    return maxsum;
}</code></pre> 
<p></p> 
<h4>2.动态规划</h4> 
<p><strong>算法思想</strong></p> 
<hr> 
<p><strong>引用动态规划前的思考</strong></p> 
<p>我们可以知道，一个表一般来说由多个数据组成，有正数也有负数，那么我们可以思考一个问题：</p> 
<p>当 当前的子段和为负数的时候，我们是否应该继续往下添加元素将该元素与该子段和相加？为了让读者更加容易读懂，我接下来进行一个举例：</p> 
<p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/12/53/05Zv8Kjt_o.png" width="527"></p> 
<p> 如上图是一个长度为7的顺序表，我们为了求得最大子段和，我们先从左边的元素开始加起，我们设子段和为<strong>max</strong>, <strong>max=element[0]=2 </strong>我们继续相加, <strong>max=element[0]+element[1]=-2 ,</strong>此时我们是否应该继续往下加入元素<strong>element[2]</strong>，<span style="color:#fe2c24;"><strong>答案是否 </strong></span><span style="color:#0d0016;"><strong>，</strong>为什么呢？我们可以这样想，既然当前的子段和已经小于0了，那么我为什么不舍弃掉前面的子段和，直接找到后面的第一个正数作为我们的子段和的第一个元素呢，即：</span></p> 
<p style="text-align:center;"><strong>max=element[0]+element[1]+element[2]=1   <span style="color:#fe2c24;">&lt;</span>    max1=element[2]</strong></p> 
<p>当掌握了这个思想之后我们就可以引入动态规划的思想了</p> 
<hr> 
<p><strong>动态规划</strong></p> 
<p>本问题中动态规划的核心就是创建一个变量<strong>maxsum</strong>表示当前的最大子段和以及一个变量<strong>sum</strong>用来表示当前操作的子段和，每次我们添加元素之后<strong>sum</strong>的值就会发生变动，如果我们发现<strong>sum</strong>比<strong>maxsum</strong>小的话说明当前添加的元素为负数因此并没有使得子段和变大，此时我们并不停下“前进的脚步“”，继续添加下一个元素，添加完下一个元素之后继续比较<strong>maxsum</strong>和<strong>sum</strong>的值，如果此时发现<strong>sum&gt;maxsum</strong>说明当前添加的元素能使得子段和变大，此时我们就将<strong>sum</strong>的值赋给<strong>maxsum</strong>，然后继续向前添加元素，以此类推。</p> 
<p></p> 
<p><strong>算法实现</strong></p> 
<pre><code class="language-cpp">int sqlist::d_maxsum()
{
    int sum=0,maxsum=0;//初始化最大子段和当前子段和为0
    for (int i = 0; i &lt; length; i++)
    {
        sum+=element[i];//当前子段和更新
        if (sum&lt;0)//判断所加的第一个元素是否为正数且判断当前子段和是否小于0
        {
            sum=0;//如果所加的第一个数不是正数或当前子段和小于0的话说明前面的子段全部作废，直接查找下一个正数
        }
        
        if (sum&gt;maxsum)//如果当前子段和大于最大子段和的话
        {
            maxsum=sum;//更新最大子段和
        }  
    }    
    return maxsum;//返回最大子段和
}</code></pre> 
<p></p> 
<p><strong>代码执行结果</strong></p> 
<p>我们对下图这么一个表进行求最大子段和的操作：</p> 
<p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/90/27/Jc0HD321_o.png" width="275"></p> 
<p></p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/5b/e0/F1gwSatc_o.png" width="272"></p> 
<p> 我们可以求得最大子段和为20，验证了算法的正确性。</p> 
<h2>三、总结</h2> 
<p>本文对顺序表的多余元素的删除以及求最大子段和进行了不同方法的实现，多余元素的删除相对而言比较简单，求最大子段和的动态规划方法也比较简单，但是递归方法比较复杂，需要多看代码进行分析，如果喜欢本文的话麻烦动动你的小手点点赞哦！❤❤❤</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/327786e5dfd5f1ea626125b4f8b093d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringMVC依赖Servlet坐标无法导入问题（Tomcat10版本）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1787e1e601b99a85803f91bdd1b334a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Node REPL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>