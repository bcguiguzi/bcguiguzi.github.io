<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构算法--图详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构算法--图详解" />
<meta property="og:description" content="目录
1. 图定义
2. 图存储
3. 图遍历
深度优先遍历(DFS)
广度优先遍历(BFS)
leecode举例
4. 常见图算法
最小生成树
最短路径
随机游走
社区发现
1. 图定义 图：图G由顶点集合V和边集合E组成，记为。
图分类：有向图和无向图。
子图：，如果，，则G’为G的子图。
有向完全图：n(n - 1)条边的有向图。
无向完全图：n(n - 1) / 2条边的无向图。
网：图的每条边带有权值。
邻接点：无向图，一条边的两点互为邻接点。
路径：顶点v到顶点v&#39;的边的权值和为路径长度。
连通：无向图G，如果顶点v到顶点v&#39;存在路径，则两顶点连通。 G是一个连通图， G中的极大连通子图为连通分量。
强连通图：有向图G，如果顶点v到顶点v&#39;存在路径，则两顶点强连通。强连通图只有一个连通分量。
生成树：无向图 G，存在一个极小连通子图，如果其包含图的所有n个顶点，有且仅有n - 1条边，则称该连通子图为G的生成树。其中权值路径最小的为最小生成树。
有向树：对于有向图G，存在一个v的入度为0，其他v&#39;的入度均为1的子图，则称该子图为G的有向树（树型图），即有向图的生成树。
2. 图存储 邻接矩阵 定义：n阶矩阵，矩阵值对应每条边权重。优点：便于计算顶点之间是否有边，便于计算顶点的度。缺点：不便于增删顶点；不便于统计所有边数目；空间复杂度高。
无向图举例：
[[0, 6, 1, 5, 0, 0], [6, 0, 5, 0, 3, 0], [1, 5, 0, 5, 6, 4], [5, 0, 5, 0, 0, 2], [0, 3, 6, 0, 0, 6], [0, 0, 4, 2, 6, 0]] 邻接表 定义：链式存储。优缺点和上述邻接矩阵相反。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/58603856259d1fcbccd700c30ed0a17d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T18:01:16+08:00" />
<meta property="article:modified_time" content="2024-01-15T18:01:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构算法--图详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%9B%BE%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#1.%20%E5%9B%BE%E5%AE%9A%E4%B9%89" rel="nofollow">1. 图定义</a></p> 
<p id="2.%20%E5%9B%BE%E5%AD%98%E5%82%A8-toc" style="margin-left:0px;"><a href="#2.%20%E5%9B%BE%E5%AD%98%E5%82%A8" rel="nofollow">2. 图存储</a></p> 
<p id="3.%20%E5%9B%BE%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#3.%20%E5%9B%BE%E9%81%8D%E5%8E%86" rel="nofollow">3. 图遍历</a></p> 
<p id="%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(DFS)-toc" style="margin-left:120px;"><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%28DFS%29" rel="nofollow">深度优先遍历(DFS)</a></p> 
<p id="%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(BFS)-toc" style="margin-left:120px;"><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%28BFS%29" rel="nofollow">广度优先遍历(BFS)</a></p> 
<p id="leecode%E4%B8%BE%E4%BE%8B-toc" style="margin-left:120px;"><a href="#leecode%E4%B8%BE%E4%BE%8B" rel="nofollow">leecode举例</a></p> 
<p id="4.%20%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#4.%20%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%AE%97%E6%B3%95" rel="nofollow">4. 常见图算法</a></p> 
<p id="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" rel="nofollow">最小生成树</a></p> 
<p id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" rel="nofollow">最短路径</a></p> 
<p id="%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0-toc" style="margin-left:120px;"><a href="#%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0" rel="nofollow">随机游走</a></p> 
<p id="%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0" rel="nofollow">社区发现</a></p> 
<h2 id="1.%20%E5%9B%BE%E5%AE%9A%E4%B9%89">1. 图定义</h2> 
<p><strong>图</strong>：图G由顶点集合V和边集合E组成，记为<img alt="G = (V, E)" class="mathcode" src="https://images2.imgbox.com/29/f4/JjAuZcEP_o.png">。</p> 
<p><strong>图分类</strong>：有向图和无向图。</p> 
<p><strong>子图</strong>：<img alt="G = (V, E), G' = (V', E')" class="mathcode" src="https://images2.imgbox.com/7c/c8/P0pGIri3_o.png">，如果<img alt="V'\subseteq V" class="mathcode" src="https://images2.imgbox.com/c4/ac/Awulg2ES_o.png">，<img alt="E'\subseteq E" class="mathcode" src="https://images2.imgbox.com/cd/e1/Eh6JBEje_o.png">，则G’为G的子图。</p> 
<p><strong>有向完全图</strong>：n(n - 1)条边的有向图。</p> 
<p><strong>无向完全图</strong>：n(n - 1) / 2条边的无向图。</p> 
<p><strong>网</strong>：图的每条边带有权值。</p> 
<p><strong>邻接点</strong>：无向图，一条边的两点互为邻接点。</p> 
<p><strong>路径</strong>：顶点v到顶点v'的边的权值和为路径长度。</p> 
<p><strong>连通</strong>：无向图G，如果顶点v到顶点v'存在路径，则两顶点连通。 G是一个连通图， G中的极大连通子图为连通分量。</p> 
<p><strong>强连通图</strong>：有向图G，如果顶点v到顶点v'存在路径，则两顶点强连通。强连通图只有一个连通分量。</p> 
<p><strong>生成树</strong>：无向图 G，存在一个极小连通子图，如果其包含图的所有n个顶点，有且仅有n - 1条边，则称该连通子图为G的生成树。其中权值路径最小的为最小生成树。</p> 
<p><strong>有向树</strong>：对于有向图G，存在一个v的入度为0，其他v'的入度均为1的子图，则称该子图为G的有向树（树型图），即有向图的生成树。</p> 
<h2 id="2.%20%E5%9B%BE%E5%AD%98%E5%82%A8">2. 图存储</h2> 
<ul><li>邻接矩阵</li></ul> 
<p>定义：n阶矩阵，矩阵值对应每条边权重。优点：便于计算顶点之间是否有边，便于计算顶点的度。缺点：不便于增删顶点；不便于统计所有边数目；空间复杂度高。</p> 
<p>无向图举例：</p> 
<pre><code>[[0, 6, 1, 5, 0, 0],
[6, 0, 5, 0, 3, 0],
[1, 5, 0, 5, 6, 4],
[5, 0, 5, 0, 0, 2],
[0, 3, 6, 0, 0, 6],
[0, 0, 4, 2, 6, 0]]</code></pre> 
<ul><li>邻接表</li></ul> 
<p>定义：链式存储。优缺点和上述邻接矩阵相反。</p> 
<p>无向图举例：</p> 
<p class="img-center"><img alt="" height="297" src="https://images2.imgbox.com/93/98/W73AyWc5_o.png" width="506"></p> 
<ul><li>集合</li></ul> 
<p>定义：以(v, v', weight)形式给出。</p> 
<p>无向图举例：</p> 
<pre><code>[('E', 'C', 6), ('D', 'A', 5), ('F', 'D', 2), ('A', 'B', 6), ('A', 'C', 1), ('F', 'E', 6), ('C', 'B', 5), ('C', 'D', 5), ('C', 'F', 4), ('B', 'E', 3)]</code></pre> 
<ul><li>文本</li></ul> 
<p>无向图举例</p> 
<pre><code>D -- F [label="2"]
D -- C [label="5"]
D -- A [label="5"]
A -- B [label="6"]
F -- E [label="6"]
C -- E [label="6"]
A -- C [label="1"]
B -- E [label="3"]
C -- B [label="5"]
F -- C [label="4"]</code></pre> 
<ul><li>图像</li></ul> 
<p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/60/4c/HIjTXFYy_o.png" width="310"></p> 
<p></p> 
<h2 id="3.%20%E5%9B%BE%E9%81%8D%E5%8E%86">3. 图遍历</h2> 
<h5 id="%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(DFS)">深度优先遍历(DFS)</h5> 
<p>定义：沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底</p> 
<p>上述无向图DFS遍历：A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D</p> 
<h5 id="%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86(BFS)">广度优先遍历(BFS)</h5> 
<p>定义：从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点</p> 
<p>上述无向图BFS遍历：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F</p> 
<h5 id="leecode%E4%B8%BE%E4%BE%8B">leecode举例</h5> 
<p><a href="https://leetcode.cn/problems/number-of-provinces/solutions/" rel="nofollow" title="leecode547省份数量">leecode547省份数量</a></p> 
<p><a href="https://leetcode.cn/problems/number-of-islands/description/" rel="nofollow" title="leetcode200岛屿数量">leetcode200岛屿数量</a></p> 
<h2 id="4.%20%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%AE%97%E6%B3%95">4. 常见图算法</h2> 
<h5 id="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</h5> 
<p>定义：带权无向图中，生成树是包含所有顶点的树，最小生成树<strong>边的权值之和最小。</strong></p> 
<p>算法：<strong>Kruskal</strong>(所有边按边权值从小到大排序；从小到大依次选择每一条边，如果这条边的两个端点不在同一个连通块，就把这条边加入到最小生成树的集合，并且合并这两个连通块；重复上述步骤，直到最小生成树中有n-1条边为止)；<strong>Prim</strong>(随机选一个顶点作起点；将与起点相邻的边按边权值从小到大排序；选择权值最小的边加入到最小生成树的集合；将新顶点加入到连通块，并与它相邻的边按边权值从小到大排序，直到所有顶点都被加入到最小生成树中)</p> 
<h5 id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</h5> 
<p>定义：计算给定的两个顶点之间最短（最小权重和）的路径。</p> 
<p>算法：<strong>Dijkstra</strong>(选择起点0，选择与起点相连的最小权重的顶点1，再选择与顶点1相连的最小权重的顶点2……直到到达目的地顶点)</p> 
<h5 id="%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0" style="background-color:transparent;">随机游走</h5> 
<p>定义：随机游走即每过一个单位时间，游走点固定向左或向右移动一个单位。</p> 
<p>算法：从节点出发随机游走，停留在社区内的概率高于到达社区外的。2. 重复随机游走，强化并逐渐显现社区结构。(1). 建立随机矩阵 (一个或多个顶点)；(2). 以1-a随机游走到邻居，以概率a随机跳跃到图中任何顶点；(3). 得到概率分布作为下次游走的输入；(4). 重复上述步骤直到稳定；(5). 对结果矩阵进行常规聚类。</p> 
<p><strong>中心性</strong></p> 
<p>定义：中心性是判断网络中节点重要性、影响力的指标。</p> 
<p>分类：<strong>点度中心性</strong>--用节点度衡量影响力；例如粉丝数量。<strong>中介中心性</strong>--非相邻成员位于其他成员的多条最短路径上，影响力越大。接近中心性--节点到其它节点的最短距离都很小，接近中心性越高。特征向量中心性--连接节点越重要，影响力越高。</p> 
<h5 id="%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0" style="background-color:transparent;">社区发现</h5> 
<p>定义：<strong>社区--</strong>社交网络中，每个用户相当于一点，用户之间的互相关注、点赞、私信等形成了边，用户以及相互作用关系构成了一个大关系网络。在这个网络，有的用户之间的连接较为紧密，有的较为稀疏；其中连接较为紧密的可以被看成在一个社区。<strong>社区发现--</strong>在图中找到一些<strong>潜在的有特定关系的组织</strong>，也就是<strong>社区(community)，</strong>即要探测网络中较为紧密的【块cluster】或是【社区community】。<strong>模块度--</strong>一种常用的衡量节点<strong>分组质量</strong>的标准，模块度越高说明所检测到的社团越符合“内紧外松”的特征，分组质量越好。</p> 
<p>本质：节点间存在的是一种<strong>逻辑拓朴结构</strong>，即存在一种<strong>共有关系。</strong>社区中的节点只是因为<strong>逻辑上的共有关系而聚集在一起而已</strong>，彼此之间的位置也没有实际意义，而社区族群之间的分离也是表达一种逻辑上的弱共有关系。</p> 
<p>算法：Louvain算法基于模块度，基本思想--网络中节点尝试遍历所有邻居的社区标签，选择最大化模块度增量的社区标签。此后，每个社区看成一个新节点，重复，直到木块度不在增大。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a7f814bfdcadfb2b4400d96ae2b3b4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE5 蓝图 按日期计算星期几</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ce74ec6f5c81fae25c50f64d2c6fd53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构和算法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>