<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【好文鉴赏】优秀的后端应该有哪些开发习惯 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【好文鉴赏】优秀的后端应该有哪些开发习惯" />
<meta property="og:description" content="关键词：[后端] [编程习惯] [代码风格]
原文链接：
https://juejin.cn/post/7072252275002966030https://www.51cto.com/article/721104.html 这里涉及到的主要是 Java 语言，当然也有通用的一些习惯；
拆分合理的目录结构 受传统的 MVC 模式影响，传统做法大多是几个固定的文件夹 controller、service、mapper、entity，然后无限制添加，到最后你就会发现一个 service 文件夹下面有几十上百个 Service 类，根本没法分清业务模块。正确的做法是在写 Service 上层新建一个 modules 文件夹，在 moudles 文件夹下根据不同业务建立不同的包，在这些包下面写具体的 service、controller、entity、enums 包或者继续拆分；
等以后开发版本迭代，如果某个包可以继续拆领域就继续往下拆，可以很清楚的一览项目业务模块。后续拆微服务也简单；
ps：个人理解为把 功能模块化 转换为 业务模块化，但是又保证了单个业务下的功能模块化；随着整个系统不断扩张时，后者无论是在查询效率还是在扩展效率上都有显著提高；但应该要留意不同业务之间的交互；
封装方法形参 当你的方法形参过多时请封装一个对象出来… 下面是一个反面教材，谁特么教你这样写代码的！
public void updateCustomerDeviceAndInstallInfo(long customerId, String channelKey, String androidId, String imei, String gaId, String gcmPushToken, String instanceId) {} 写个对象出来并给它赋予相应的意义，使用对象传参清晰明了，也方便后期扩展和维护；
public class CustomerDeviceRequest { private Long customerId; private String channelKey; private String androidId; private String imei; private String gaId; private String gcmPushToken; private String instanceId; } public void updateCustomerDeviceAndInstallInfo(CustomerDeviceRequest cdr) {} 为什么要这么写？比如你这方法是用来查询的，万一以后加个查询条件是不是要修改方法？每次加每次都要改方法参数列表。封装个对象，以后无论加多少查询条件都只需要在对象里面加字段就行。而且关键是看起来代码也很舒服啊！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a9a1ae8d124d96921adf8564f83793fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T09:27:33+08:00" />
<meta property="article:modified_time" content="2022-11-17T09:27:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【好文鉴赏】优秀的后端应该有哪些开发习惯</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>关键词：</strong>[后端] [编程习惯] [代码风格]<br> <strong>原文链接：</strong></p> 
<ul><li><a href="https://juejin.cn/post/7072252275002966030" rel="nofollow">https://juejin.cn/post/7072252275002966030</a></li><li><a href="https://www.51cto.com/article/721104.html" rel="nofollow">https://www.51cto.com/article/721104.html</a></li></ul> 
<p><img src="https://images2.imgbox.com/59/b0/NGufL4mw_o.png" alt="在这里插入图片描述"></p> 
<p>这里涉及到的主要是 Java 语言，当然也有通用的一些习惯；</p> 
<h2><a id="_11"></a>拆分合理的目录结构</h2> 
<p>受传统的 MVC 模式影响，传统做法大多是几个固定的文件夹 <code>controller、service、mapper、entity</code>，然后无限制添加，到最后你就会发现一个 <code>service</code> 文件夹下面有几十上百个 <code>Service</code> 类，根本没法分清业务模块。正确的做法是在写 <code>Service</code> 上层新建一个 <code>modules</code> 文件夹，在 <code>moudles</code> 文件夹下根据不同业务建立不同的包，在这些包下面写具体的 <code>service、controller、entity、enums</code> 包或者继续拆分；</p> 
<p><img src="https://images2.imgbox.com/5b/18/4Zibuo0T_o.png" alt="在这里插入图片描述"><br> 等以后开发版本迭代，如果某个包可以继续拆领域就继续往下拆，可以很清楚的一览项目业务模块。后续拆微服务也简单；<br> <font color="#00800">ps：个人理解为把 功能模块化 转换为 业务模块化，但是又保证了单个业务下的功能模块化；随着整个系统不断扩张时，后者无论是在查询效率还是在扩展效率上都有显著提高；但应该要留意不同业务之间的交互；</font></p> 
<h2><a id="_18"></a>封装方法形参</h2> 
<p>当你的<strong>方法形参过多时请封装一个对象</strong>出来… 下面是一个反面教材，谁特么教你这样写代码的！</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateCustomerDeviceAndInstallInfo</span><span class="token punctuation">(</span><span class="token keyword">long</span> customerId<span class="token punctuation">,</span> <span class="token class-name">String</span> channelKey<span class="token punctuation">,</span>
                   <span class="token class-name">String</span> androidId<span class="token punctuation">,</span> <span class="token class-name">String</span> imei<span class="token punctuation">,</span> <span class="token class-name">String</span> gaId<span class="token punctuation">,</span>
                   <span class="token class-name">String</span> gcmPushToken<span class="token punctuation">,</span> <span class="token class-name">String</span> instanceId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>写个对象出来并给它赋予相应的意义，使用对象传参清晰明了，也方便后期扩展和维护；</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerDeviceRequest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> customerId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> channelKey<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> androidId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> imei<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> gaId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> gcmPushToken<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> instanceId<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateCustomerDeviceAndInstallInfo</span><span class="token punctuation">(</span><span class="token class-name">CustomerDeviceRequest</span> cdr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>为什么要这么写？比如你这方法是用来查询的，万一以后加个查询条件是不是要修改方法？每次加每次都要改方法参数列表。封装个对象，以后无论加多少查询条件都只需要在对象里面加字段就行。而且关键是看起来代码也很舒服啊！</p> 
<h2><a id="_41"></a>封装业务逻辑</h2> 
<p>如果你看过“屎山”你就会有深刻的感触，这特么一个方法能写几千行代码，还无任何规则可言…往往负责的人会说，这个业务太复杂，没有办法改善，实际上这都是懒的借口。不管业务再复杂，我们都能够用合理的设计、封装去提升代码可读性。下面贴两段高级开发（作者）写的代码</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token class-name">ChildOrder</span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">,</span> <span class="token class-name">OrderSubmitRequest<span class="token punctuation">.</span>Shop</span> shop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ChildOrder</span> childOrder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">generateOrder</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    childOrder<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//订单来源 APP/微信小程序</span>
    childOrder<span class="token punctuation">.</span><span class="token function">setSource</span><span class="token punctuation">(</span>userService<span class="token punctuation">.</span><span class="token function">getOrderSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 校验优惠券</span>
    orderAdjustmentService<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>shop<span class="token punctuation">.</span><span class="token function">getOrderAdjustments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 订单商品</span>
    orderProductService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>childOrder<span class="token punctuation">,</span> shop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 订单附件</span>
    orderAnnexService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>childOrder<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shop<span class="token punctuation">.</span><span class="token function">getOrderAnnexes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理订单地址信息</span>
    <span class="token function">processAddress</span><span class="token punctuation">(</span>childOrder<span class="token punctuation">,</span> shop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 最后插入订单</span>
    childOrderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>childOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateSkuInventory</span><span class="token punctuation">(</span>shop<span class="token punctuation">,</span> childOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送订单创建事件</span>
    applicationEventPublisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChildOrderCreatedEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> shop<span class="token punctuation">,</span> childOrder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> childOrder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearBills</span><span class="token punctuation">(</span><span class="token class-name">Long</span> customerId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取清算需要的账单、deposit等信息</span>
    <span class="token class-name">ClearContext</span> context <span class="token operator">=</span> <span class="token function">getClearContext</span><span class="token punctuation">(</span>customerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 校验金额合法</span>
    <span class="token function">checkAmount</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断是否可用优惠券，返回可抵扣金额</span>
    <span class="token class-name">CouponDeductibleResponse</span> deductibleResponse <span class="token operator">=</span> <span class="token function">couponDeducted</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 清算所有账单</span>
    <span class="token class-name">DepositClearResponse</span> response <span class="token operator">=</span> <span class="token function">clearBills</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新 l_pay_deposit</span>
    lPayDepositService<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getDeposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送还款对账消息</span>
    repaymentService<span class="token punctuation">.</span><span class="token function">sendVerifyBillMessage</span><span class="token punctuation">(</span>customerId<span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getDeposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">EventName</span><span class="token punctuation">.</span><span class="token constant">DEPOSIT_SUCCEED_FLOW_REMINDER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新账户余额</span>
    accountService<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理清算的优惠券，被用掉或者解绑</span>
    couponService<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>deductibleResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 保存券抵扣记录</span>
    clearCouponDeductService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> deductibleResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两段代码里面其实业务很复杂，内部估计保守干了五万件事情，但是不同水平的人写出来就完全不同，不得不赞一下这个注释，这个业务的拆分和方法的封装。一个大业务里面有多个小业务，不同的业务调用不同的 <code>Service</code> 方法即可，后续接手的人即使没有流程图等相关文档也能快速理解这里的业务，而很多初级开发写出来的业务方法就是上一行代码是 A 业务的，下一行代码是 B 业务的，在下面一行代码又是 A 业务的，业务调用之间还嵌套这一堆单元逻辑，显得非常混乱，代码还多；</p> 
<p><font color="#00800"> ps: 把独立功能的代码抽象成方法，避免一个方法内镶嵌若干个功能/业务逻辑，很好的习惯 </font></p> 
<h2><a id="_96"></a>判断集合类型不为空的正确方式</h2> 
<p>很多人喜欢写这样的代码去判断集合</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当然你硬要这么写也没什么问题…但是不觉得难受么，现在框架中随便一个 jar 包都有集合工具类，比如 <code>org.springframework.util.CollectionUtils</code>等等；以后请这么写：</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#00800"> ps: 两者功能应该一样，我自己一般用的前者，但看公司代码和一些项目都是倾向于后者 </font></p> 
<h2><a id="_return_null_118"></a>集合类型返回值不要 return null</h2> 
<p><strong>当你的业务方法返回值是集合类型时，请不要返回 <code>null</code>，正确的操作是返回一个空集合</strong>。你看 Bybatis 的列表查询，如果没查询到元素返回的就是一个空集合，而不是 <code>null</code>。否则调用方得去做 <code>NULL</code> 判断，多数场景下对于对象也是如此；</p> 
<h2><a id="_124"></a>映射数据库的属性尽量不要用基本类型</h2> 
<p>我们都知道 <code>int/long</code> 等基本数据类型作为成员变量默认值是 0。现在流行使用 mybatisplus 、mybatis 等 ORM 框架，在进行插入或者更新的时候<strong>很容易会带着默认值插入更新到数据库</strong>。我特么真想砍了之前的开发，重构的项目里面实体类里面全都是基本数据类型。当场裂开…</p> 
<h2><a id="_130"></a>对多个判断条件进行封装</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">LoanAppEntity</span> loanAppEntity<span class="token punctuation">,</span> <span class="token keyword">long</span> operatorId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">OVERDUE</span> <span class="token operator">!=</span> loanAppEntity<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;&amp;</span> <span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">CURRENT</span> <span class="token operator">!=</span> loanAppEntity<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;&amp;</span> <span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">GRACE_PERIOD</span> <span class="token operator">!=</span> loanAppEntity<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>这段代码的可读性很差，这 <code>if</code> 里面谁知道干啥的？我们用面向对象的思想去给 <code>loanApp</code> 这个对象里面封装个方法不就行了么？</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">LoanAppEntity</span> loan<span class="token punctuation">,</span> <span class="token keyword">long</span> operatorId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loan<span class="token punctuation">.</span><span class="token function">finished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p><code>LoanApp</code> 这个类中封装一个方法，简单来说就是这个逻辑判断细节不该出现在业务方法中；</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 贷款单是否完成
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">finished</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">OVERDUE</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;&amp;</span> <span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">CURRENT</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;&amp;</span> <span class="token class-name">LoanAppEntity<span class="token punctuation">.</span>LoanAppStatus</span><span class="token punctuation">.</span><span class="token constant">GRACE_PERIOD</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_167"></a>控制方法复杂度</h2> 
<p>推荐一款 IDEA 插件 <code>CodeMetrics</code> ，它能显示出方法的复杂度，它是对方法中的表达式进行计算，布尔表达式，<code>if/else</code> 分支，循环等。</p> 
<p><img src="https://images2.imgbox.com/f0/83/9acc3XoF_o.png" alt=""></p> 
<p>点击可以查看哪些代码增加了方法的复杂度，可以适当进行参考，毕竟我们通常写的是业务代码，在保证正常工作的前提下最重要的是要让别人能够快速看懂。当你的方法复杂度超过 10 就要考虑是否可以优化了；</p> 
<h2><a id="_ConfigurationProperties__Value_177"></a>使用 @ConfigurationProperties 代替 @Value</h2> 
<p>列举一下 <code>@ConfigurationProperties</code> 的好处</p> 
<ul><li> <p>在项目 <code>application.yml</code> 配置文件中按住 <code>ctrl + 鼠标左键</code> 点击配置属性可以快速导航到配置类。写配置时也能自动补全、联想到注释。需要额外引入一个依赖 <code>org.springframework.boot:spring-boot-configuration-processor</code>；</p> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rOFl6HQW-1668648167363)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5621193de8ac40479d5b402da1801a0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)]</p> </li><li> <p><code>@ConfigurationProperties</code> 支持 <code>NACOS</code> 配置<strong>自动刷新</strong>，使用 <code>@Value</code> 需要在 <code>BEAN</code> 上面使用 <code>@RefreshScope</code> 注解才能实现自动刷新；</p> </li><li> <p><code>@ConfigurationProperties </code>可以结合 <code>Validation</code> 校验，<code>@NotNull</code>、<code>@Length</code> 等注解，如果配置校验没通过程序将启动不起来，及早的发现生产丢失配置等问题</p> </li><li> <p><code>@ConfigurationProperties</code> 可以<strong>注入多个属性</strong>，<code>@Value</code> 只能一个一个写</p> </li><li> <p><code>@ConfigurationProperties</code> 可以支持<strong>复杂类型</strong>，无论嵌套多少层，都可以正确映射成对象</p> </li></ul> 
<p>相比之下我不明白为什么那么多人不愿意接受新的东西，裂开…你可以看下所有的 <code>springboot-starter</code> 里面用的都是 <code>@ConfigurationProperties</code> 来接配置属性；</p> 
<h2><a id="_lombok_199"></a>推荐使用 lombok</h2> 
<p>当然这是一个有争议的问题，我的习惯是使用它省去 <code>getter、setter、toString</code> 等等；</p> 
<h2><a id="_AService__BMapper__205"></a>不要在 AService 调用 BMapper (有异议)</h2> 
<p>我们一定要遵循从 <code>AService -&gt; BService -&gt; BMapper</code>，如果每个 <code>Service</code> 都能直接调用其他的 <code>Mapper</code>，那特么还要其他 <code>Service</code> 干嘛？老项目还有从 <code>Controller</code> 调用 <code>Mapper</code> 的，把控制器当 <code>Service</code> 来处理了。。</p> 
<p><font color="#00800">ps: 理论上一个 Service 职责最好单一，尽量别耦合，不然你会发现当一个调用的 Service里的业务逻辑发生变化后不一定跟你现在要的是一个东西。这么干，那势必会出多层、递归调用；具体地说：" AService -&gt; BService " ，也可能需要" BService -&gt; AService "，这样就会造成循环依赖，虽然目前的版本 Spring 是默认解决循环依赖，对于低版本的 Spring 是有问题的，报循环依赖异常；// 一个评论区佬的看法是：Service 层不应该循环调用，不止 Service 层，同层间都不应该互相调用，上面说的情况可以通过加中间层 manager 解决；相当于提供一个仓储，里面包含所有的dao，对外还可以隐藏内部细节；// 不过说到底感觉都过度追求规范了，都能举出反例，看是规范和简单怎么抉择，出现了反例势必就要提供解决方法</font></p> 
<h2><a id="_215"></a>会使用基础工具类，会写自定义工具类</h2> 
<p>少写基础工具类，因为你写的大部分基础点的工具类，在你无形中引入的 <code>jar</code> 包里面就有，<code>String</code> 的，<code>Assert</code> 断言的，<code>IO</code> 上传文件，拷贝流的，<code>Bigdecimal</code> 的等等。自己写容易错还要加载多余的类；</p> 
<p><font color="#00800">ps：自定义的一些必要的工具类还是要写，自己知道的有 jar 包直接拿来用的可以省略，当然这也是个积累的过程；我在视频上边学边敲项目时就发现很多工具类写的很巧妙</font></p> 
<h2><a id="_OpenFeign__223"></a>要不要包裹 OpenFeign 接口返回值</h2> 
<h3><a id="_codemessage__225"></a>不使用 code、message 封装</h3> 
<p>搞不懂为什么那么多人喜欢把接口的返回值用 <code>Response</code> 包装起来…加个 <code>code、message、success</code> 字段，然后每次调用方就变成这样</p> 
<pre><code class="prism language-java"><span class="token class-name">CouponCommonResult</span> bindResult <span class="token operator">=</span> couponApi<span class="token punctuation">.</span><span class="token function">useCoupon</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getCustomerId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getLoanId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> coupon<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>bindResult<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>bindResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AppException</span><span class="token punctuation">(</span><span class="token class-name">CouponErrorCode</span><span class="token punctuation">.</span><span class="token constant">ERR_REC_COUPON_USED_FAILED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样就相当于</p> 
<ol><li>在 <code>coupon-api</code> 抛出异常</li><li>在 <code>coupon-api</code> 拦截异常，修改 <code>Response.code</code></li><li>在调用方判断 <code>response.code</code> 如果是 <code>FAIELD</code> 再把异常抛出去…</li></ol> 
<p>你直接在服务提供方抛异常不就行了么。。。而且这样一包装 <code>HTTP</code> 请求永远都是 <code>200</code>，没法做重试和监控。当然这个问题涉及到接口响应体该如何设计，目前网上大多是三种流派</p> 
<ul><li>接口响应状态一律 <code>200</code></li><li>接口响应状态遵从 <code>HTTP</code> 真实状态</li><li>佛系开发，领导怎么说就怎么做</li></ul> 
<p>不接受反驳，我推荐使用 <code>HTTP</code> 标准状态。特定场景包括参数校验失败等一律使用 400 给前端弹 <code>toast</code>；</p> 
<p><font color="#00800">ps：作者说的有道理啊，对接口返回值进行封装虽然一定程度上提高了通用性，简洁性，emm 但确实存在上述问题，看怎么取舍吧，以后写出了可能有自己的见解 // 借评论区一个大佬：个人建议各自服务自行抛异常，微服务通过网关进行分发请求，在网关这一层拦截响应信息，给它包一层code\data\message再返回到前端，而服务间调用，直接报异常得啦，两方都兼容<br> 当然，有些观点是”网关要轻量“这类的，当我没说</font></p> 
<h3><a id="_code_message_data__257"></a>使用 code message data 封装</h3> 
<p>要记住 <code>RESTful</code> 和 <code>jsonrpc</code> 是两回事；就是因为以下原因固定 200 并且使用 <code>code、message、data</code> 来返回的</p> 
<ol><li>能够知道非 <code>200</code> 的错误一定不是来自程序，而是来自可能是 nginx 等，说明<strong>压根没进入到 Controller 里，方便排查</strong>;</li><li><strong>服务间调用可以通过 <code>code</code> 来决定是否要捕捉、抛出、忽略这个错误</strong>，举个例子比如我要注册并登陆一个用户，下层服务返回 <code>USER_EXISTED_ALREADY</code>，那我就继续走登陆接口了。</li><li>OpenFeign 是可以自定义<code>Decoder</code>来自动拆掉范型的，比如你服务上的 Controller 是 <code>Response&lt;User&gt; getById()</code>，在写 FeignClient 时可以直接写 <code>User getById()</code>。</li></ol> 
<h2><a id="_267"></a>写有意义的方法注释</h2> 
<p>这种注释你写出来是怕后面接手的人瞎么…你在后面写字段参数的意义啊…</p> 
<pre><code class="prism language-java"><span class="token comment">/**
* 请求电话验证
*
* @param credentialNum
* @param callback
* @param param
* @return phoneVerifyResult
*/</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> credentialNum<span class="token punctuation">,</span><span class="token class-name">String</span> callback<span class="token punctuation">,</span><span class="token class-name">String</span> param<span class="token punctuation">,</span><span class="token class-name">String</span> phoneVerifyResult<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<p>要么就别写，要么就在后面加上描述…写这样的注释被 IDEA 报一堆警告看着不难受？</p> 
<h2><a id="_DTO__290"></a>和前端交互的 DTO 对象命名</h2> 
<p>什么 <code>VO、BO、DTO、PO</code> 我倒真是觉得没有那么大必要分那么详细，至少我们在和前端交互的时候类名要起的合适，<strong>不要直接用映射数据库的类返回给前端，这会返回很多不必要的信息，如果有敏感信息还要特殊处理</strong>；</p> 
<p>推荐的做法是接受前端请求的类定义为 <code>XxxRequest</code>，响应的定义为 <code>XxxResponse</code>。以订单为例：接受保存更新订单信息的实体类可以定义为 <code>OrderRequest</code>，订单查询响应定义为 <code>OrderResponse</code>，订单的查询条件请求定义为 <code>OrderQueryRequest</code>。</p> 
<h2><a id="_296"></a>不要跨服务循环访问数据库</h2> 
<p>跨服务查询时，如果有批量数据查询的场景，直接写一个批量的 <code>Feign</code> 查询接口，不要像下面这样</p> 
<pre><code class="prism language-java">list<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>id <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">UserResponse</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因为每一次 <code>OpenFeign</code> 的请求都是一个 <code>Http</code> 请求、一个数据库 <code>IO</code> 操作，还要经过各种框架内的拦截器、解码器等等，全都是损耗。</p> 
<p>直接定义一个批量查询接口</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/user/batch-info"</span><span class="token punctuation">)</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserResponse</span><span class="token punctuation">&gt;</span></span> <span class="token function">batchInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> userIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这就结束了吗？并没有，如果你遇到这种 <code>userIds</code> 的数量非常大，在 <code>2000</code> 以上，那么你在实现方不能在数据库中直接用 <code>in()</code> 去查询。在实现方要拆分这个 <code>useIds</code> 。有索引的情况下 <code>in() 1000</code> 个元素以下通常问题不大</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">XxxResponse</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> partition <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//拆分 List</span>

  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">XxxResponse</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  partition<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">-&gt;</span> list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>xxxMapper<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_IDEA__329"></a>尽量别让 IDEA 报警</h2> 
<p>我是很反感看到 IDEA 代码窗口一串警告的，非常难受。因为有警告就代表代码还可以优化，或者说存在问题。 前几天捕捉了一个团队内部的小 bug，其实本来和我没有关系，但是同事都在一头雾水的看外面的业务判断为什么走的分支不对，我一眼就扫到了问题。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qocS6hvj-1668648167364)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d59b8e61f5841eaa8036be98f4174e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)]</p> 
<p>因为 java 中整数字面量都是 <code>int</code> 类型，到集合中就变成了 <code>Integer</code>，然后 <code>stepId</code> 点上去一看是 <code>long</code> 类型，在集合中就是 <code>Long</code>，那这个 <code>contains</code> 妥妥的返回 <code>false</code>，都不是一个类型。</p> 
<p>你看如果注重到警告，鼠标移过去看一眼提示就清楚了，少了一个生产 bug。</p> 
<p><font color="#00800">ps: 确实，强迫症是一方面，时常提供有价值的信息也是一方面；以前在实习的时候找一个bug，忽视了 IDEA 的警告，硬是没找到地方，结果吃个饭回来一个警告信息就是出错的地方</font></p> 
<h2><a id="_343"></a>保持优化性能的嗅觉</h2> 
<p>比如避免创建比必要的对象、异步处理、使用缓冲流，减少IO操作等等。</p> 
<p>比如，我们设计一个APP首页的接口，它需要查用户信息、需要查banner信息、需要查弹窗信息等等。假设耗时如下：</p> 
<p><img src="https://images2.imgbox.com/6b/8c/NuzfMyDL_o.png" alt="图片"></p> 
<p>查用户信息200ms，查banner信息100ms、查弹窗信息50ms，那一共就耗时350ms了。如果还查其他信息，那耗时就更大了。如何优化它呢？可以并行发起，耗时可以降为200ms。如下：</p> 
<p><img src="https://images2.imgbox.com/b2/2c/bMXY4kqZ_o.png" alt="图片"></p> 
<h2><a id="_355"></a>可变参数的配置化处理</h2> 
<p>日常开发中，我们经常会遇到一些可变参数，比如用户多少天没登录注销、运营活动，不同节日红包皮肤切换、订单多久没付款就删除等等。对于这些可变的参数，不用该直接写死在代码。优秀的后端，要做配置化处理，你可以把这些可变参数，放到数据库一个配置表里面，也可以放到项目的配置文件或者 apollo 上。</p> 
<p>比如产品经理提了个红包需求，圣诞节的时候，红包皮肤为圣诞节相关的，春节的时候，为春节红包皮肤等。如果在代码写死控制，可有类似以下代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>duringChristmas<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
   img <span class="token operator">=</span> redPacketChristmasSkin<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>duringSpringFestival<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
   img <span class="token operator">=</span>  redSpringFestivalSkin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果到了元宵节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？</p> 
<p>从一开始接口设计时，可以实现一张红包皮肤的配置表，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。当然，还有一些场景适合一些配置化的参数：一个分页多少数量控制、某个抢红包多久时间过期这些，都可以搞到<strong>参数配置化表</strong>里面。这也是扩展性思想的一种体现。</p> 
<h2><a id="_375"></a>尽可能使用新技术组件</h2> 
<p>我觉得这是一个程序员应该具备的素养…反正我是喜欢用新的技术组件，因为新的技术组件出现必定是解决旧技术组件的不足，而且作为一个技术人员我们应该要与时俱进~~ 当然前提是要做好准备工作，不能无脑升级。举个最简单的例子，Java 17 都出来了，新项目现在还有人用 <code>Date </code>来处理日期时间…</p> 
<h2><a id="_381"></a>总结</h2> 
<p>节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？</p> 
<p>从一开始接口设计时，可以实现一张红包皮肤的配置表，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。当然，还有一些场景适合一些配置化的参数：一个分页多少数量控制、某个抢红包多久时间过期这些，都可以搞到<strong>参数配置化表</strong>里面。这也是扩展性思想的一种体现。</p> 
<h2><a id="_389"></a>尽可能使用新技术组件</h2> 
<p>我觉得这是一个程序员应该具备的素养…反正我是喜欢用新的技术组件，因为新的技术组件出现必定是解决旧技术组件的不足，而且作为一个技术人员我们应该要与时俱进~~ 当然前提是要做好准备工作，不能无脑升级。举个最简单的例子，Java 17 都出来了，新项目现在还有人用 <code>Date </code>来处理日期时间…</p> 
<h2><a id="_395"></a>总结</h2> 
<p>养成一些好的开发习惯肯定是需要通过不断的实践来沉淀下来的，但若事先有这个意识，在实践的过程中就会多留心，多注重代码的规范性、可读性、可扩展性等等；实习的时候便是对两个 Demo 进行重构，对代码的质量问题深有感触；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/648efd2d4941015ef5517f6c1b650764/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">缓冲区 | 无需安装GIS软件，零代码创建缓冲区</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e3e9b0ae78227ccf911b8014406f438/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">...mapState 和 ...mapMutations入门使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>