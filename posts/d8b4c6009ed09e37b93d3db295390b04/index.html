<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端面试 ===＞ 【Vue2】 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端面试 ===＞ 【Vue2】" />
<meta property="og:description" content="Vue2 相关面试题总结 1. 谈谈对Vue的理解 Vue是一种用于构建用户页面的渐进式JavaScript框架，也是一个创建SPA单页面应用的Web应用框架，Vue的核心是 数据驱动试图，通过组件内特定的方法实现视图和模型的交互；特性：（看自己要不要对每一项特性进行解释，如果解释可能会牵扯出很多面试题） 数据驱动试图： MVVM是一种双向数据绑定的模式，用ViewModel来建立起Model数据层和View视图层的连接，数据和视图的改变是双向的；可能会问：MVVM 和 MVC 的区别？(见4)； 组件开发： 组件可以在项目中直接进行复用，出现问题时可以实现快速定位，能够提高代码可复用性和可维护性。可能会问：如何封装一个组件？（见后面） 指令系统： Vue内置很多 v- 系列的指令，可以响应式的作用于DOM，比如v-if条件渲染，v-for列表渲染，v-model双向数据绑定等。可能会问：自定义封装指令的一些知识（见后面） 缺点： 不利于SEO优化： 解决办法： SSR服务器渲染；静态化；预渲染；骨架屏； 首屏加载速度慢：加载时，将所有的css，js文件都进行加载；不支持IE678（IE也不用了😂）；有些数据不需要响应式，但必须写在data里，影响加载速度和性能；Vue的响应式是通过Object.defineProperty: 无法监听ES6的Set、Map变化；无法监听Class类型的数据；属性的新加或删除无法监听；数组元素的增加和删除无法监听； 2. Vue最大优势 是一款轻量级框架，简单易学，数据双向绑定，虚拟DOM，组件化，数据和结构相分离，运行速度快等等；文档都是中文的，入门教程很多，上手简单；Vue是单页面应用，使页面局部刷新，不用每次跳转页面都去请求所有的数据和DOM，加快了访问速度和提升用户体验；相比传统的页面通过超链接实现页面的切换和跳转，Vue使用路由，不会刷新页面；第三方UI库使用起来非常方便，节省了很多开发时间，从而提升了开发效率。 3. Vue 和 jQuery 的区别是什么？ jQuery： 应该算是一个插件，里面封装了各种简单易用的方法，它的本质就是使用更少的代码操作DOM节点，它是使用选择器获取DOM对象，对其进行赋值、取值、事件绑定等操作，对数据的操作依赖于对应的DOM对象； Vue： 一套渐进式的框架，拥有自己的规则体系和语法，特别是MVVM的设计思想，让数据和视图进行双向绑定，极少操作DOM，对数据进行操作不再依赖于对应的DOM对象。 4. MVVM 和 MVC 区别是什么？ MVC： 一种设计模式，是Model数据模型，View视图，Controller控制器，在控制器这层里面编写代码，控制数据和视图进行关联，MVC是单向通信； MVVM： 既Model-View-ViewModel的简写（模型-视图-视图模型），VM是整个设计模式的核心，是用来连接视图和模型的桥梁；模型：指的是后端传递的数据；视图：指的是所看到的页面；有两个方向： 首先：模型转换为视图，将从后端请求回来的数据转换为网页； 实现方式：数据绑定； 其次，视图转换为模型，将网页转化为后端的数据； 实现方式：监听DOM事件。 这两个方向都实现的，我们称为数据的双向绑定。 区别： MVC是单向通信，MVVM是双向通信；主要是MVC中的Controller演变成了MVVM中的VM，MVVM主要解决了MVC中大量的DOM操作导致的页面渲染性能降低，加载速度慢，影响用户体验。 5. Vue常用修饰符 事件修饰符： .stop =&gt; 阻止事件冒泡 .prevent =&gt; 阻止事件默认行为 .once =&gt; 程序运行期间，事件处理函数只执行一次 .native =&gt; 原生事件（使用组件库的时候可能会用到） 按键修饰符： .enter ➡ 监测Enter键 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d8b4c6009ed09e37b93d3db295390b04/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T20:05:37+08:00" />
<meta property="article:modified_time" content="2024-03-13T20:05:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端面试 ===＞ 【Vue2】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Vue2__2"></a>Vue2 相关面试题总结</h2> 
<h3><a id="1_Vue_4"></a>1. 谈谈对Vue的理解</h3> 
<ul><li>Vue是一种用于构建用户页面的<strong>渐进式JavaScript框架</strong>，也是一个创建<strong>SPA单页面应用</strong>的Web应用框架，Vue的核心是 <strong>数据驱动试图</strong>，通过组件内特定的方法实现视图和模型的交互；</li><li><strong>特性</strong>：（看自己要不要对每一项特性进行解释，如果解释可能会牵扯出很多面试题） 
  <ul><li><strong>数据驱动试图</strong>： 
    <ul><li>MVVM是一种双向数据绑定的模式，用ViewModel来建立起Model数据层和View视图层的连接，数据和视图的改变是双向的；</li><li><em>可能会问</em>：MVVM 和 MVC 的区别？(见4)；</li></ul> </li><li><strong>组件开发</strong>： 
    <ul><li>组件可以在项目中直接进行复用，出现问题时可以实现快速定位，能够提高代码可复用性和可维护性。</li><li><em>可能会问</em>：如何封装一个组件？（见后面）</li></ul> </li><li><strong>指令系统</strong>： 
    <ul><li>Vue内置很多 <strong>v-</strong> 系列的指令，可以响应式的作用于DOM，比如v-if条件渲染，v-for列表渲染，v-model双向数据绑定等。</li><li><em>可能会问</em>：自定义封装指令的一些知识（见后面）</li></ul> </li></ul> </li></ul> 
 
<ul><li><strong>缺点</strong>： 
  <ul><li>不利于SEO优化： 
    <ul><li>解决办法： 
      <ul><li>SSR服务器渲染；</li><li>静态化；</li><li>预渲染；</li><li>骨架屏；</li></ul> </li></ul> </li><li>首屏加载速度慢：加载时，将所有的css，js文件都进行加载；</li><li>不支持IE678（IE也不用了😂）；</li><li>有些数据不需要响应式，但必须写在data里，影响加载速度和性能；</li><li>Vue的响应式是通过Object.defineProperty: 
    <ul><li>无法监听ES6的Set、Map变化；</li><li>无法监听Class类型的数据；</li><li>属性的新加或删除无法监听；</li><li>数组元素的增加和删除无法监听；</li></ul> </li></ul> </li></ul> 
<h3><a id="2_Vue_36"></a>2. Vue最大优势</h3> 
<ul><li>是一款轻量级框架，简单易学，数据双向绑定，虚拟DOM，组件化，数据和结构相分离，运行速度快等等；</li><li>文档都是中文的，入门教程很多，上手简单；</li><li>Vue是单页面应用，使页面局部刷新，不用每次跳转页面都去请求所有的数据和DOM，加快了访问速度和提升用户体验；</li><li>相比传统的页面通过超链接实现页面的切换和跳转，Vue使用路由，不会刷新页面；</li><li>第三方UI库使用起来非常方便，节省了很多开发时间，从而提升了开发效率。</li></ul> 
<h3><a id="3_Vue__jQuery__44"></a>3. Vue 和 jQuery 的区别是什么？</h3> 
<ul><li>jQuery： 
  <ul><li>应该算是一个插件，里面封装了各种简单易用的方法，它的本质就是使用更少的代码操作DOM节点，它是使用选择器获取DOM对象，对其进行赋值、取值、事件绑定等操作，对数据的操作依赖于对应的DOM对象；</li></ul> </li><li>Vue： 
  <ul><li>一套渐进式的框架，拥有自己的规则体系和语法，特别是MVVM的设计思想，让数据和视图进行双向绑定，极少操作DOM，对数据进行操作不再依赖于对应的DOM对象。</li></ul> </li></ul> 
<h3><a id="4_MVVM__MVC__51"></a>4. MVVM 和 MVC 区别是什么？</h3> 
<ul><li>MVC： 
  <ul><li>一种设计模式，是Model数据模型，View视图，Controller控制器，在控制器这层里面编写代码，控制数据和视图进行关联，MVC是单向通信；</li></ul> </li><li>MVVM： 
  <ul><li>既Model-View-ViewModel的简写（模型-视图-视图模型），VM是整个设计模式的核心，是用来连接视图和模型的桥梁；</li><li>模型：指的是后端传递的数据；</li><li>视图：指的是所看到的页面；</li><li>有两个方向： 
    <ul><li>首先：模型转换为视图，将从后端请求回来的数据转换为网页； 
      <ul><li>实现方式：数据绑定；</li></ul> </li><li>其次，视图转换为模型，将网页转化为后端的数据； 
      <ul><li>实现方式：监听DOM事件。</li></ul> </li><li>这两个方向都实现的，我们称为数据的双向绑定。</li></ul> </li></ul> </li><li>区别： 
  <ul><li>MVC是单向通信，MVVM是双向通信；</li><li>主要是MVC中的Controller演变成了MVVM中的VM，MVVM主要解决了MVC中大量的DOM操作导致的页面渲染性能降低，加载速度慢，影响用户体验。</li></ul> </li></ul> 
<h3><a id="5_Vue_69"></a>5. Vue常用修饰符</h3> 
<ul><li>事件修饰符：</li></ul> 
<pre><code class="prism language-js">    <span class="token punctuation">.</span><span class="token parameter">stop</span> <span class="token operator">=&gt;</span> 阻止事件冒泡
    <span class="token punctuation">.</span><span class="token parameter">prevent</span> <span class="token operator">=&gt;</span> 阻止事件默认行为
    <span class="token punctuation">.</span><span class="token parameter">once</span> <span class="token operator">=&gt;</span> 程序运行期间，事件处理函数只执行一次
    <span class="token punctuation">.</span><span class="token parameter">native</span> <span class="token operator">=&gt;</span> 原生事件（使用组件库的时候可能会用到）
</code></pre> 
<ul><li>按键修饰符：</li></ul> 
<pre><code class="prism language-js">    <span class="token punctuation">.</span>enter ➡ 监测Enter键
    <span class="token punctuation">.</span>esc ➡ 监测<span class="token constant">ESC</span>键
</code></pre> 
<ul><li>v-model修饰符：</li></ul> 
<pre><code class="prism language-js">    <span class="token punctuation">.</span>number ➡ 尝试用parseFloat转数字
    <span class="token punctuation">.</span>trim ➡ 去除字符串首尾两侧的空白字符
    <span class="token punctuation">.</span>lazy ➡ 内容改变并且失去焦点触发
</code></pre> 
<ul><li>特殊：</li></ul> 
<pre><code class="prism language-js">    <span class="token punctuation">.</span>sync ➡ 可以在子组件内部直接修改父组件的值
    格式： 
        父组件：<span class="token operator">&lt;</span>子组件 变量名<span class="token punctuation">.</span>sync<span class="token operator">=</span><span class="token string">"数据属性"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:对应的属性名'</span><span class="token punctuation">,</span> 值<span class="token punctuation">)</span>
    注意：此处的  update<span class="token operator">:</span>对应的属性名 不能有空格
    见下图
</code></pre> 
<p>具体使用如下：</p> 
<ul><li>父组件：</li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>home<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span>
      <span class="token attr-name">msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Welcome to Your Vue.js App<span class="token punctuation">"</span></span>
      <span class="token attr-name">:type.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>type<span class="token punctuation">"</span></span>
      <span class="token attr-name">:arr.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>arr<span class="token punctuation">"</span></span>
      <span class="token attr-name">:obj.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj<span class="token punctuation">"</span></span>
    <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> HelloWorld <span class="token keyword">from</span> <span class="token string">"@/components/HelloWorld.vue"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"HomeView"</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">arr</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">obj</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    HelloWorld<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<ul><li>子组件：</li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>updateData<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>改变数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span> {<!-- -->{ type }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span> {<!-- -->{ arr }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span> {<!-- -->{ obj }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token literal-property property">require</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">arr</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> Array<span class="token punctuation">,</span>
      <span class="token literal-property property">require</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">obj</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>
      <span class="token literal-property property">require</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">updateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"update:type"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"update:arr"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"update:obj"</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>
        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token string">"李四"</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="6_Vue_187"></a>6. Vue常用指令</h3> 
<pre><code class="prism language-js">    v<span class="token operator">-</span>bind<span class="token operator">:</span>属性名 <span class="token operator">=</span> "表达式 ➡ 给标签动态赋值
    <span class="token literal-property property">简写：</span><span class="token operator">:</span>属性名 <span class="token operator">=</span> <span class="token string">"表达式"</span>
    v<span class="token operator">-</span>on<span class="token operator">:</span>事件名 <span class="token operator">=</span> <span class="token string">"少量代码 / 函数名 / 函数名(实参)"</span> ➡ 绑定事件
    简写： @事件名 <span class="token operator">=</span> <span class="token string">"少量代码 / 函数名 / 函数名(实参)"</span>
    v<span class="token operator">-</span>model <span class="token operator">=</span> <span class="token string">"表达式"</span> ➡ 将表单元素的 value属性 和 Vue数据属性 进行双向绑定
    可以使用v<span class="token operator">-</span>model语法糖实现组件传值
    v<span class="token operator">-</span><span class="token keyword">for</span> <span class="token operator">=</span> <span class="token string">"(值, 索引) in 目标结构"</span> ➡ 循环列表
    v<span class="token operator">-</span>show <span class="token operator">=</span> <span class="token string">"表达式"</span> ➡ 控制元素显示隐藏
    v<span class="token operator">-</span><span class="token keyword">if</span> <span class="token operator">=</span> <span class="token string">"表达式"</span> ➡ 控制元素显示隐藏
    v<span class="token operator">-</span>slot ➡ 插槽
</code></pre> 
<h3><a id="7_vshow__vif__202"></a>7. v-show 和 v-if 的区别</h3> 
<ul><li>共同点： 
  <ul><li>都可以控制元素的显示和隐藏（效果一样）；</li></ul> </li><li>区别： 
  <ul><li><strong>原理不同</strong>： 
    <ul><li>v-show：本质就是通过CSS属性来让元素显示隐藏（display: none;）；</li><li>v-if：动态的 向DOM树 添加 或 删除 元素；</li></ul> </li><li><strong>编译条件不同</strong>： 
    <ul><li>v-show：不管条件真假与否，都会编译，如果是false，会将display设置为none，但它也编译了；</li><li>v-if：初始值为false，就不会编译；</li></ul> </li><li><strong>性能不同</strong>： 
    <ul><li>v-show： 
      <ul><li>只编译一次，后面就是控制CSS；</li><li>产生更大的首次加载消耗；</li></ul> </li><li>v-if： 
      <ul><li>不停的销毁和创建实例；</li><li>产生更大的切换消耗；</li></ul> </li></ul> </li><li><strong>优先级不同</strong>： 
    <ul><li>v-if &gt; v-show</li></ul> </li></ul> </li></ul> 
<h3><a id="8__vif__vfor__223"></a>8. 为什么避免 v-if 和 v-for 一起使用，非要在一起使用该怎么办？</h3> 
<ul><li>Vue避免同时使用<code>v-if</code>和<code>v-for</code>是因为这样会影响性能；</li><li><code>v-for</code> 优先级高于 <code>v-if</code>；</li><li>当<code>v-if</code>和<code>v-for</code>同时存在时，<code>v-for</code>会先执行，然后才考虑<code>v-if</code>条件。如果列表很长，这样会导致不必要的计算，影响渲染性能。</li><li>一起使用： 
  <ul><li>可以先写if，再使用template标签包裹需要循环的内容，将循环写在template标签上；</li><li>如果非要在一起使用，可以考虑使用计算属性来优化性能。计算属性可以先根据条件筛选出需要渲染的数据，然后再使用v-for渲染，这样可以避免不需要的计算和喧染，提高性能。</li></ul> </li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in filteredList<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      {<!-- -->{ item.name }}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Grape"</span><span class="token punctuation">,</span> <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">filteredList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>show<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="9_vfor_262"></a>9. 数组更新有时候v-for不渲染</h3> 
<ul><li>因为Vue内部只能监测数组 <strong>顺序 / 位置 / 数量</strong> 的改变；</li><li>如果是某个值被重新赋值或者使用了不改变原始数组的方法没有将返回值对原数据进行赋值，Vue是监测不到的； 
  <ul><li><em>可能会问</em>：改变原始数组和不改变原始数组的方法有哪些？</li></ul> </li><li>针对上述问题，有两种解决方案： 
  <ul><li>某个值被重新赋值： 
    <ul><li><code>this.$set(更新的目标结构, 改变元素的索引 / 对象的属性, 更新的值);</code>；</li></ul> </li><li>使用不改变原始数组的方法： 
    <ul><li>用得到的新数组替换旧数组。</li></ul> </li></ul> </li></ul> 
<h3><a id="10_Vue_key__273"></a>10. Vue中 key 的作用</h3> 
<ul><li>当Vue用v-for正在更新已渲染的元素列表时，它默认采用“就地复用”策略。</li><li>列表数据修改的时候，它会根据key值去判断某个值是否修改，如果修改了，则在重新渲染这一项，否则复用旧节点；</li><li>key： 
  <ul><li>一段唯一不重复的数字或字符串；</li><li>为了更高效的更新虚拟DOM；</li><li>是给v-for循环生成标签办法唯一标识的；</li><li>key不会出现在真实DOM中；</li></ul> </li><li>为什么不能使用索引？ 
  <ul><li>因为索引是连续的，如果删除其中一个会导致最后一个被删除；</li><li>当我们在删除的时候，key根据数据来把新旧的DOM做对比，删除key不存在的对应的标签。</li></ul> </li></ul> 
<h3><a id="11_vfor_key_286"></a>11. v-for后面为什么要加 :key？</h3> 
<ul><li>在重复渲染的dom上加<code>key</code>，可以对dom进行回收利用，标记每一个dom用来判断dom节点是否更新；</li><li>比对时，第一步，如果发现没有key会立即更新，创建新的dom，如果发现有key，第二部，就会比对dom结构，如果dom结构发生变化，那么仍然是就地更新，如果dom结构也相同，那么第三步，就回去比较<code>key</code>利用diff算法，看看是否可以重复利用该dom；</li></ul> 
<h3><a id="12__dom_diff_290"></a>12. 你知道 dom diff算法吗？</h3> 
<ul><li>dom结构的对比主要使用的是<code>updateChildren</code>方法，4个 <code>if-else</code>判断，头头比，尾尾比，头尾比，尾头比，因为diff主要比对是在循环的过程中，而循环需要依赖数组，数组的操作会引起视图变化的主要是从头增删、从尾增删、或者反转，所以着4个比较的命中会比较高如果匹配，新旧的索引都++，不匹配，旧的dom起始索引会++，直到起始索引大与等于结束索引，那么新的起始索引与旧的所有索引就算比较完成，等到新的dom起始索引比结束索引大了，整个对比就算结束；</li></ul> 
<h3><a id="13_diff_293"></a>13. diff算法比较机制</h3> 
<ul><li>根元素变化：删除DOM树重新建立；</li><li>根元素未变： 
  <ul><li>顺序改变： 
    <ul><li>更新属性；</li></ul> </li><li>子元素/子元素内容改变： 
    <ul><li>按照key比较，如果没有key或者key是索引，尝试就地更新；</li><li>如果key是id，新旧虚拟DOM做对比，共有的部分不发生变化，没有的就在对应的位置插入DOM节点；</li></ul> </li></ul> </li><li>key使用规范： 
  <ul><li>有id用id，没有id用索引；</li><li>一段唯一不重复的数字或字符串。</li></ul> </li></ul> 
<h3><a id="14_vuetemplate_306"></a>14. 说说你对vue的template编辑的理解？</h3> 
<ul><li>简单来说就是先转换成 AST树，经过 <code>generate</code> 得到 <code>render</code> 函数，<code>render</code> 函数的返回值是 VNode；</li><li>首先，通过 <code>compile</code> 编译器把 <code>template</code> 编译成 <code>AST</code> 语法树（<code>abstract syntax tree</code> 即源代码的抽象语法结构的树状表现形式），<code>compile</code> 是 <code>createCompiler</code> 的返回值，<code>createCompiler</code> 是用以创建编译器的。另外 <code>compile</code> 还负责合并 <code>option</code>。</li><li>然后，<code>AST</code> 会经过 <code>generate</code>（将 AST 语法树转化成 render funtion 字符串的过程）得到 <code>render</code> 函数，<code>render</code> 的返回值是 <code>VNode</code>，VNode 是 Vue 的虚拟 DOM 节点，里面有（标签名、子节点、文本等等）</li></ul> 
<h3><a id="15__311"></a>15. 怎么自定指令，有哪些钩子函数，对应的有哪些入参?</h3> 
<ul><li>全局注册： 
  <ul><li>在 Vue对象 的 <code>directive</code> 方法里面有两个参数，一个指令名称，一个回调 / 对象；</li><li>如果是个对象，在对象内部必须指定 <code>inserted</code>方法。</li></ul> </li></ul> 
<pre><code class="prism language-js">    <span class="token comment">// 注册一个全局自定义指令 `v-focus`</span>
    Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 当被绑定的元素插入到 DOM 中时……</span>
        <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 聚焦元素</span>
            el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>局部注册： 
  <ul><li>组件中接受一个 <code>directives</code>选项。</li></ul> </li></ul> 
<pre><code class="prism language-js">    <span class="token comment">// 注册局部指令</span>
    <span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 指令名</span>
        <span class="token literal-property property">focus</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 指令的定义</span>
            <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>钩子函数：</li></ul> 
<pre><code class="prism language-js">    <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               ➡   只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置；
    <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           ➡   被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）；
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             ➡   所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前，指令的值可能发生变化，也肯能没有。但是你可以通过比较前后的值来忽略不必要的模板更新；
    <span class="token function">componentUpdated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   ➡   指令所在组建的VNode及其子VNode全部更新后调用；
    <span class="token function">unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             ➡   只调用一次，指令与该元素解绑时调用。
</code></pre> 
<ul><li>钩子函数参数：<br> <img src="https://images2.imgbox.com/5a/14/k4x5o4GB_o.png" alt="image.png"></li></ul> 
<h3><a id="16__357"></a>16. 怎么封装一个组件，具体的过程是咋样的</h3> 
<ul><li>组件提升了整个项目的开发效率，能够把页面抽离成相对独立的模块。解决了传统项目开发过程中的效率低、难维护、复用性差等问题；</li><li>组件的封装我们可以看作是一个函数的封装： 
  <ul><li>根据业务需求，把页面中可复用的template、script、style，抽离到一个单独的 .vue文件 中，实现复用；</li><li>上述步骤完成之后，还需要考虑入参和出参： 
    <ul><li>入参：使用 props机制；</li><li>出参： 
      <ul><li>使用 $emit机制；</li><li>使用 .sync修饰符（见5）；</li><li>使用 v-model语法糖实现；</li></ul> </li><li>针对一些标签不确定的地方，我们可以使用插槽实现；</li><li>至此，组件的封装完成。</li></ul> </li></ul> </li><li>组件的使用步骤： 
  <ul><li>封装组件；</li><li>导入组件： 
    <ul><li><code>import 组件对象 from '组件路径'</code></li></ul> </li><li>注册组件； 
    <ul><li>全局注册： 
      <ul><li><code>Vue.component('组件名', 组件对象)</code></li></ul> </li><li>局部注册（常用）： 
      <ul><li><img src="https://images2.imgbox.com/c8/0c/3QfgYFy0_o.png" alt="image.png"></li></ul> </li><li>使用组件：组件标签；</li></ul> </li></ul> </li></ul> 
<h3><a id="17_Vue_data__381"></a>17. Vue组件中 data 为什么是个函数？</h3> 
<ul><li>Vue中每个组件都是一个实例；</li><li>组件共享data属性，当data的值是同一个引用数据类型的值时，改变其中一个会影响其他的；</li><li>组件中的data写成一个函数，数据以函数返回值的形式定义，这样每复用一次组件，就会返回一份最新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护自己的数据；</li><li>单纯的写成对象的形式，就会使得所有的组件实例共享一份data，就会造成一变全变的结果。</li></ul> 
<h3><a id="18_Vue_388"></a>18. Vue组件如何进行传值</h3> 
<ul><li>组件通信就是组件间的传值，无非就是三种情况： 
  <ul><li>父传子、子传父、任意组件间传值；</li></ul> </li><li>父传子<code>props</code>，子传父<code>emit</code>；</li><li>vue提供的方法能实现传值的还有：<code>$attr</code>获取传递的所有属性，<code>$refs</code>获取组件实例，可以进行传值；</li><li><code>v-mdoel</code>和<code>sync</code>修饰符也能进行传值；</li><li>还有主流的<code>vuex</code>，只要写在vuex里面的数据，任意组件都可以进行访问；</li><li>还有一些非主流的，比如<code>localStorage、sessionStorage、indexDB、WebSQL</code>这种浏览器缓存里，也可以做到这种效果，不过这种方式有很大的弊端，数据不是响应式的，一般没什么人使用；</li><li>还有一种就是，vuex的数据是挂载在vue对象实例上的，而vue实例对象是挂载在window上的，所以也可以直接挂载到window对象，也能拿到使用；</li><li>基本上就这些传值的方式了；</li></ul> 
<h3><a id="19_Vue_399"></a>19. Vue该如何实现组件的缓存？</h3> 
<ul><li>为什么需要组件缓存？ 
  <ul><li>在面向组件开发中，会把整个项目拆分成多个业务组件，按照需求对组件进行整合；</li><li>存在组件频繁切换的问题，在这个过程中，组件的实例都是在不断的销毁和创建，很是消耗性能，并且如果需要该组件的数据的话，我们是获取不到的，所以需要对组件的状态进行缓存。</li></ul> </li><li>怎么实现组件的缓存？ 
  <ul><li>使用 <code>keep-alive</code> 标签包裹需要被缓存的组件，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染；</li><li>优点：提高渲染性能，提升用户体验。</li></ul> </li><li>简单的说: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</li></ul> 
<h3><a id="20_keepalive_409"></a>20. 关于keep-alive说法</h3> 
<ul><li><code>keep-alive</code>可以通过<code>include</code>属性，匹配要进行缓存的组件；</li><li>当组件在<code>keep-alive</code>内被切换，它的<code>activated</code> 和 <code>deactivated</code>这两个钩子函数将会被执行；</li><li><code>max</code>属性控制最多可以缓存几个组件，一旦这个数字达到了，在新实例被创建之前，已缓存的组件中，最久没有被访问的实例会被销毁。</li></ul> 
<h3><a id="21_Vue_keepalive__415"></a>21. Vue中 keep-alive 的作用</h3> 
<ul><li><code>keep-alive</code>是Vue内置的一个组件，可以使被包裹的组件保留状态，或避免重新渲染。一旦使用<code>keep-alive</code>激活组件，此时<code>mounted</code>、<code>created</code>等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，<code>actived</code> 和 <code>deactived</code>，这两个钩子函数只有被<code>keep-alive</code>包裹后才会调用。</li></ul> 
<h3><a id="22__name__419"></a>22. 组件中写 name 选项有什么用？</h3> 
<ul><li>项目中使用 <code>keep-alive</code> 时，可以搭配组件 name 进行组件的缓存；</li><li>使用插槽时，<code>name</code> 属性可以作为占位标签的名字，供 <code>template</code> 使用；</li><li><code>Vue-devtools</code>调试工具里显示的组件名称是由Vue组件内部的 <code>name</code> 属性决定的。</li></ul> 
<h3><a id="23__Vue__425"></a>23. 谈谈对 Vue 生命周期的理解</h3> 
<ul><li>Vue实例从创建到销毁的整个过程，就是Vue的生命周期（四个阶段 + 八个钩子函数）；</li><li>初始化阶段： 
  <ul><li><code>beforeCreate()</code>: 
    <ul><li>此时，data数据和methids方法还没有挂载到Vue实例身上，无法使用（如果使用了，会报错，undefined）；</li></ul> </li><li><code>created()</code>: 
    <ul><li>data数据和methods方法已经挂载到Vue实例身上，可以正常使用；</li><li>使用场景：发起异步请求（可以更早的获取数据，渲染页面）；</li></ul> </li></ul> </li><li>挂载阶段： 
  <ul><li><code>beforeMount()</code>: 
    <ul><li>将App.vue文件中的所有标签编译完毕（知识编译完毕，还没有变成真实DOM）；</li></ul> </li><li><code>mounted()</code>: 
    <ul><li>虚拟DOM变成真实DOM，此时可以获取DOM节点；</li></ul> </li></ul> </li><li>更新阶段： 
  <ul><li><code>beforeUpdate()</code>:、 
    <ul><li>data数据变化后更新，此时数据是最新的，但是DOM节点还不是最新的；</li></ul> </li><li><code>updated()</code>: 
    <ul><li>当组件渲染完毕后执行，此时可以获取最新的DOM内容；</li></ul> </li></ul> </li><li>销毁阶段： 
  <ul><li><code>beforeDestroy()</code>: 
    <ul><li>这一步，Vue实例仍然可以使用；</li></ul> </li><li><code>destroyed()</code>: 
    <ul><li>实例销毁后调用，该钩子函数被调用后，对应的Vue实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li><li>使用场景：销毁定时器； 
      <ul><li>单个定时器：直接调用 <code>clearInterval()</code> 或 <code>clearTimeout()</code>进行销毁；</li><li>多个定时器：在data声明一个对象，使用 <code>Object.keys()</code> 获取该对象的所有属性名，进行循环销毁。</li></ul> </li></ul> </li></ul> </li></ul> 
<h3><a id="24__453"></a>24. 第一次页面加载会触发哪几个钩子函数？</h3> 
<ul><li><code>beforeCreate()</code>、<code>created()</code>、<code>beforeMount()</code>、<code>mounted()</code></li><li>第一次页面加载需要将data数据和methods方法挂载到Vue实例上，并且需要将虚拟DOM变成真实DOM。</li></ul> 
<h3><a id="25__458"></a>25. 父组件嵌套一个子组件，第一次加载的时候，钩子函数的触发顺序</h3> 
<ul><li>父创建前后，父挂在前，子创建前后，子挂载前后，父挂载后；</li></ul> 
<h3><a id="26_Vue_462"></a>26. 怎样理解Vue的单向数据流</h3> 
<ul><li>数据从父组件传递给子组件，只能单向绑定；</li><li>子组件内部不能直接修改从父组件传递过来的数据；</li><li>所有的prop都使得其父子prop之间形成一个单向下行绑定： 
  <ul><li>父级prop的更新会向下流动到子组件中，但是反过来不行；</li></ul> </li><li>这样会防止从子组件意外改变父组件的状态，从而导致应用的数据流向难以理解；</li><li>额外的，每次父组件发生更新时，子组件中所有的prop都将会刷新为最新的值；</li><li>这意味着你不应该在一个子组件内部改变prop，如果这样做了，Vue会在浏览器的控制台中发出警告；</li><li>子组件想修改时，只能通过<code>$emit()</code>派发一个自定义事件，父组件接收后，由父组件修改。</li></ul> 
<h3><a id="27_style__scoped___473"></a>27. style 上加 scoped属性的原理 及 样式穿透原理</h3> 
<ul><li>什么是<code>scoped</code> 
  <ul><li>在组件中，为了使样式私有化，不对全局造成污染，可以在 <code>style</code> 标签上添加 <code>scoped</code> 属性，以标示它只局限于当前组件；</li></ul> </li><li>原理： 
  <ul><li>给当前组件添加 <code>data-v-</code>开头的8位随机哈希值的属性；</li><li>Vue中scoped属性的效果主要通过PostCSS转译实现：既PostCSS给当前组件内的所有标签添加一个唯一不重复的动态属性，然后，给选择器额外添加一个属性选择器（这个属性选择器是添加到原有选择的后面的）。</li></ul> </li></ul> 
<blockquote> 
 <ul><li>样式穿透的原理： 
   <ul><li>和 scoped 的原理类似；</li><li>区别： 
     <ul><li><strong>scoped</strong>是给当前文件的每一个选择器的<strong>后面 添加 属性选择器</strong>； 
       <ul><li><img src="https://images2.imgbox.com/f0/10/hgEb20x1_o.png" alt="image.png"></li></ul> </li><li><strong>样式穿透</strong>是给对应的选择器的<strong>最前面 添加 属性选择器</strong>； 
       <ul><li><img src="https://images2.imgbox.com/f9/28/YCovwsvg_o.png" alt="image.png"></li></ul> </li></ul> </li></ul> </li></ul> 
</blockquote> 
<h3><a id="28_Vue__mvvm_488"></a>28. Vue响应式数据原理（双向数据绑定原理 / mvvm原理）</h3> 
<ul><li>原理就是<strong>数据劫持 + 发布订阅</strong>，数据变化引起视图变化的原理是： 
  <ul><li>数据劫持可以使用<code>Object.definePrototype</code>进行监听模型数据变化，当数据变化时会触发<code>set</code>函数；</li><li>发布订阅则是解析模板指令的时候，watcher收集所有模板用到的数据，添加为订阅者，当数据更新时，会通知所有订阅者调用自身的<code>update</code>进行试图的更新；</li><li>试图变化引起数据更新的原理是：在视图层绑定<code>input</code>事件，监听到事件触发时，修改对应<code>value</code>值，就可以进行数据的更新了；</li></ul> </li><li>实例代码：</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">let</span> input <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span>

<span class="token comment">//定义⼀个对象</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'txt'</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//obj.txt属性赋值⽅法，同时为input、p⽂本赋同⼀个值</span>
    <span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//数据更新引起视图变化</span>
        value <span class="token operator">=</span> val
        input<span class="token punctuation">.</span>value <span class="token operator">=</span> val
        p<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">//获取txt属性的⽅法</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//监听事件 触发的时候会给obj.txt重新赋值，从⽽实现双向绑定</span>
input<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keyup'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span><span class="token comment">//视图变化更新数据</span>
    obj<span class="token punctuation">.</span>txt <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="29_computedmethodswatch_521"></a>29. computed、methods、watch之间的区别</h3> 
<ul><li><code>computed</code>：计算属性 
  <ul><li>会被挂载到Vue实例身上；</li><li>一个计算属性的值，依赖于另外的数据属性计算而来，当依赖发生变化的时候，计算属性也会发生变化；</li><li>计算属性具有缓存性，基于依赖的值进行缓存，依赖不发生变化，都直接从缓存中取结果；当依赖发生变化，函数会自动执行，并把最新的结果再次缓存；</li><li>所有<code>getter</code>和<code>setter</code>的<code>this</code>上下文自动地绑定为Vue实例；</li><li>不能写异步代码 
    <ul><li>定义的函数接收return的结果，return属于同步执行，是没办法拿到异步请求的结果的</li></ul> </li></ul> </li><li><code>methods</code>： 
  <ul><li>会被挂载到Vue实例身上；</li><li>方法中的this指向Vue实例；</li><li>不具有缓存特性；</li></ul> </li><li><code>watch</code>： 
  <ul><li>观察和响应Vue实例上的数据变动；</li><li>Vue实例将会在实例化时调用<code>$watch</code>，遍历<code>warch</code>对象的每一个属性；</li></ul> </li><li>三者的加载顺序： 
  <ul><li><code>computed</code>是在html dom加载后马上执行的；</li><li><code>methods</code>则必须要有一定的触发条件才能执行；</li><li><code>watch</code>用于观察Vue实例上的数据变动；</li></ul> </li><li>默认加载的时候： 
  <ul><li>先<code>computed</code>后<code>watch</code>，不执行<code>methods</code>；</li></ul> </li><li>触发某一事件后： 
  <ul><li>先<code>computed</code>再<code>methods</code>再到<code>watch</code>；</li></ul> </li></ul> 
<h3><a id="30_rootparentrefs_546"></a>30. 说一下<code>$root</code>、<code>$parent</code>、<code>$refs</code></h3> 
<ul><li><code>$root</code> 和 <code>$parent</code> 都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过<code>$parent</code>访问得到的就是它最近一级的父组件，通过<code>$root</code>访问得到的就是根父组件。</li><li>通过在子组件标签定义的<code>ref</code>属性，在父组件中可以使用<code>$refs</code>访问子组件实例。</li></ul> 
<h3><a id="31_vmodel_551"></a>31. v-model原理</h3> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username = $event.target.value<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<ul><li>原理： 
  <ul><li><code>v-model</code>其实是个语法糖，相当于用<code>v-bind</code>动态绑定了<code>value</code>属性实现数据驱动视图，然后用<code>input</code>事件把视图的值再更新给绑定的<code>value</code>，<code>v-model</code>主要是给表单元素使用，有的时候封装组件也可以使用<code>v-model</code>绑定数据，比如定义一个组件，用<code>props</code>接收<code>value</code>，再用<code>$emit()</code>给<code>input</code>传值，这个组件就可以被绑定<code>v-model</code>了；</li></ul> </li><li><a href="https://juejin.cn/post/7299668106133585972" rel="nofollow">🎯 如何使用 v-model 封装组件？</a></li></ul> 
<h3><a id="32_vmodel__sync_562"></a>32. v-model 和 sync修饰符的区别</h3> 
<ul><li>首先都是用来双向绑定数据的，<code>v-model</code>只能使用一次，<code>sync</code>修饰符可以给任何一个属性使用，<code>v-model</code>传入的是<code>input</code>事件，而<code>sync</code>修饰符传入的是<code>update:属性名事件</code>；</li></ul> 
<h3><a id="33_dom_565"></a>33. 为什么更新了数据却不能操作dom？如何解决？</h3> 
<ul><li>数据更新是同步的，视图更新是异步的，数据更新会发起一个更新视图的微任务，试图不会立即更新，所以不能在修改完数据之后立刻操作dom，如果试图没有更新可能导致dom获取不到，需要将操作dom的代码使用<code>$nextTick()</code>包裹，也转换成异步，就可以在更新完dom后实现dom操作；</li></ul> 
<h3><a id="34__VuenextTick_568"></a>34. 什么是 Vue.nextTick()原理是什么？</h3> 
<ul><li><code>$nextTick</code>是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你DOM加载完毕以后再去调用<code>nextTick()</code>里面的数据内容。</li><li>原理： 
  <ul><li>nextTick方法主要使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</li></ul> </li><li>作用： 
  <ul><li>nextTick用于下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的DOM。</li></ul> </li><li><code>$nextTick</code>本质是返回一个<code>Promise</code>；</li></ul> 
<h3><a id="35_Vuetemplate_577"></a>35. Vue中template的编译过程</h3> 
<ul><li><code>vue template</code>模板编译的过程经过<code>parse()</code>生成<code>ast(抽象语法树)</code>，<code>optimize</code>对静态节点优化，<code>generate()</code>生成<code>render</code>字符串之后调用<code>new Watcher()</code>函数，用来监听数据的变化，<code>render</code>函数就是数据监听的回调所调用的，其结果便是重新生成Vnode，如果是数据的更新，那么Vnode会与数据改变之前的Vnode做diff，对内容做改动之后，就会更新到我们真正的DOM；</li></ul> 
<h3><a id="36_new_Vue_581"></a>36. new Vue的时候做了什么事</h3> 
<ul><li><img src="https://images2.imgbox.com/dd/2b/ui5tUxf4_o.png" alt="image.png"></li></ul> 
<ol><li><strong>初始化</strong>： 
  <ul><li>执行 <code>init</code> 操作。包括但不限于 <code>initLifecycle、initState</code> 等；</li></ul> </li><li><strong>挂载</strong>： 
  <ul><li>执行 <code>mounted</code> ，进行元素挂载；</li></ul> </li><li><strong>编译</strong>： 
  <ul><li><code>compiler</code> 对 <code>template</code> 属性进行编译，通过 <code>vue-loader</code> 处理生成 <code>render</code> 函数；</li></ul> </li><li><strong>渲染</strong>： 
  <ul><li>执行 <code>render</code> 函数，生成 <code>vnode</code>；</li></ul> </li><li><strong>补丁</strong>： 
  <ul><li><code>patch</code>。新旧 <code>vnode</code> 经过 <code>diff</code> 后，渲染到真实dom上；</li></ul> </li></ol> 
<ul><li><a href="https://juejin.cn/post/7164563220714225695" rel="nofollow">🎯 可以看看这位大佬写的</a></li></ul> 
<h3><a id="37_axios_596"></a>37. axios是什么，怎么使用，描述使用它实现登录功能的流程</h3> 
<ul><li>axios是请求后台资源的模块。通过<code>npm install axios -S</code>来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入token，在响应拦截器中通过后端返回的状态码来对返回的数据进行不同的处理。</li></ul> 
<pre><code class="prism language-js"><span class="token comment">// TODO 封装请求拦截器 </span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">config</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// TODO 在发送请求之前做一些事</span>
  <span class="token keyword">return</span> config
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// TODO 处理请求错误</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// TODO 封装响应拦截器 </span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// TODO 位于2xx范围内的任何状态码都会触发此函数</span>
  <span class="token comment">// TODO 对响应数据做处理</span>
  <span class="token keyword">return</span> response
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// TODO 任何超出2xx范围的状态码都会触发此函数</span>
  <span class="token comment">// TODO 做一些响应错误的事情</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="38_axios_622"></a>38. 对axios进行二次封装</h3> 
<pre><code class="prism language-js">    <span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span>
    
    <span class="token keyword">const</span> request <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
        <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">5000</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 参数是个函数</span>
    <span class="token comment">// 请求拦截器</span>
    request<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 响应拦截器</span>
    request<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">export</span> <span class="token keyword">default</span> request
</code></pre> 
<h3><a id="39_Vue_642"></a>39. Vue中的路由模式</h3> 
<ul><li><strong>hash模式</strong>： 
  <ul><li>url带有#号，#以及#后面的称为hash，用 <code>window.location.hash</code> 读取，对浏览器安全无用；</li><li>通过 <code>onhashchange</code> 事件，监听url修改；</li><li>特点： 
    <ul><li>hash虽然在url中，但不被包括在http请求中；</li><li>用来指导浏览器动作，对服务端安全无用，hash不会重加载页面；</li></ul> </li></ul> </li><li><strong>history模式</strong>： 
  <ul><li>url没有#号；</li><li>history采用H5的新特性，且提供了两个新方法 <code>pushState()</code> 和 <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件可以监听到状态变更；</li></ul> </li><li>切换模式： 
  <ul><li>在 <code>new VueRouter()</code> 里面，增加 <code>mode</code> 属性，属性值为 <code>hash</code> 或 <code>history</code>。</li></ul> </li></ul> 
<h3><a id="40__656"></a>40. 路由配置项常用的属性</h3> 
<pre><code class="prism language-js">path       ➡   展示的url
component  ➡   <span class="token function">和path对应的组件路径（可以使用</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'组件路径'</span><span class="token punctuation">)</span>）
name       ➡   命名路由
children   ➡   子路由的配置对象（路由嵌套）
props      ➡   路由解耦
redirect   ➡   重定向路由
meta       ➡   路由元信息
</code></pre> 
<h3><a id="41__668"></a>41. 路由跳转的方式</h3> 
<ul><li>声明式导航：</li></ul> 
<pre><code class="prism language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">"需要跳转到页面的路径"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> 
<ul><li>编程式导航：</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    ➡  跳转到指定的url，并在history中添加记录，点击回退到上一个页面
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>     ➡  向前或向后跳转n个页面，n可以是正数也可以是负数
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ➡  跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    ➡  回退到上一个页面
</code></pre> 
<h3><a id="42__685"></a>42. 路由传参的方式有哪些</h3> 
<ul><li>Vue-Router传参可以分为两大类，分别是编程式导航和声明式导航；</li></ul> 
 
<ul><li><strong>编程式导航</strong>： 
  <ul><li>name 和 params 搭配传参</li><li><code>this.$router.push({ name: 'news', params: { userId: 123} })</code></li><li>path 和 query 搭配传参</li><li><code>this.$router.push({ path: '/news', query: { userId: 123 } })</code></li></ul> </li><li><strong>声明式导航</strong>： 
  <ul><li>命名路由： 
    <ul><li><code>&lt;router-link to="{ name: 'news', params: { userId: 123 } }"&gt;&lt;/router-link&gt;</code></li></ul> </li><li>查询参数： 
    <ul><li><code>&lt;router-link to="{ path: '/news', query: { userId: 123 } }"&gt;&lt;/router-link&gt;</code></li></ul> </li></ul> </li></ul> 
<h3><a id="43_route__router__702"></a>43. <code>$route</code> 和 <code>$router</code> 的区别</h3> 
<ul><li>都是在注册路由的时候，提供的两个全局对象</li><li><code>$route</code>： 
  <ul><li><strong>路由信息对象</strong>;</li><li>包括<code>path、hash、query、params、name</code>等路由信息参数，表示当前激活的路由对象；</li></ul> </li><li><code>$router</code>： 
  <ul><li><strong>VueRouter的实例</strong>;</li><li>相当于一个全局的路由对象，里面包含很多属性和子对象，如history对象，经常用的跳转链接就可以用<code>this.$router.push()</code>会往history栈中添加一个新的记录，返回上一个history也是使用<code>this,$router.go()</code>等方法。</li></ul> </li></ul> 
<h3><a id="44_query__params_712"></a>44. query 和 params之间的区别</h3> 
<ul><li><code>query</code>： 
  <ul><li>和 <code>path</code> 配合使用；</li><li>接收参数的时候，使用 <code>this.$route.query.属性名</code></li></ul> </li><li><code>params</code>： 
  <ul><li>和 <code>name</code> 配合使用；</li><li>接收参数的时候，使用 <code>this.$route.params.属性名</code></li></ul> </li></ul> 
<h3><a id="45_VueRouter__721"></a>45. Vue-Router 有哪几种路由守卫</h3> 
<ul><li>全局前置守卫：<code>beforeEach()</code></li><li>全局后置守卫：<code>afterEach()</code></li><li>单个路由独享的钩子：<code>beforeEnter()</code></li><li>组件路由守卫相关的钩子： 
  <ul><li><code>beforeRouterEnter()</code></li><li><code>beforeRouterUpdate()</code></li><li><code>beforeRouterLeave()</code></li></ul> </li><li>入参： 
  <ul><li><code>to</code>：即将要进入的目标路由对象（去哪里）</li><li><code>form</code>：当前导航即将离开的路由对象</li><li><code>next</code>：调用该方法，才能进入下一个钩子函数（afterEach） 
    <ul><li><code>next()</code>：通过；</li><li><code>next('url')</code>：跳到指定地址</li></ul> </li></ul> </li></ul> 
<pre><code class="prism language-js">    router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 相关逻辑</span>
        <span class="token comment">// next()必须执行，但是参数可能不同</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="46__744"></a>46. 如何实现动态路由？</h3> 
<ul><li>路由一般分为静态路由和动态路由：</li><li>静态路由： 
  <ul><li>也可以叫做白名单路由，指的是不需要权限就能访问的页面，一般都是提前定义好的；</li></ul> </li><li>动态路由： 
  <ul><li>需要前端进行处理，一般都是根据后台返回的路由匹配规则，然后在所有的路由中，可以利用路由的name属性与权限点匹配的规则，筛选出可以访问的路由，通过<code>router.addRoutes</code>添加就可以了；</li></ul> </li></ul> 
<h3><a id="47__751"></a>47. 如何监测动态路由的变化</h3> 
<ul><li>可以通过<code>watch</code>方法对<code>$route</code>进行监听，或者通过导航守卫的钩子函数<code>beforeRouteUpdate(to, from, next)</code>来监听它的变化。</li></ul> 
<h3><a id="48_VueRouterrouterlinkvslot_755"></a>48. Vue-Router中的router-link上v-slot属性怎么使用</h3> 
<ul><li><code>router-link</code>通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的API。主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似NavLink这样的自定义组件里；</li><li>有时我们可能想把激活的 <code>class</code> 应用到一个外部元素而不是<code>&lt;a&gt;</code>标签本身，这时可以在一个<code>router-link</code>中包裹该元素并使用<code>v-slot</code>属性来创建链接：</li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span>
  <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/foo<span class="token punctuation">"</span></span>
  <span class="token attr-name">custom</span>
  <span class="token attr-name">v-slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ href, route, navgiate, isActive, isExactActive }<span class="token punctuation">"</span></span>
<span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>
    <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[isActive &amp;&amp; 'router-link-active',isExactActive &amp;&amp; 'router-link-exact-active' ]<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>href<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>navigate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{<!-- -->{ route.fullPath }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="49_Vue_773"></a>49. Vue路由实现的底层原理</h3> 
<ul><li>在Vue中利用数据劫持<code>defineProperty</code>在<code>原型prototype</code>上初始化一些<code>getter</code>，分别是： 
  <ul><li><code>router</code>代表当前Router的实例；</li><li><code>route</code>代表当前Router的新信息。</li></ul> </li><li>在<code>install</code>中也全局注册了<code>router-view, router-link</code>，其中的<code>Vue.util.defineReactive</code>，这是Vue里面观察者劫持数据的方法，劫持<code>_route</code>，当<code>_route</code>触发setter方法的时候，则会通知到依赖的组件；</li><li>接下来在init中，会挂载判断路由的模式，是history或hash，点击行为按钮，调用hashchange或popstate的同时更新<code>_route</code>，<code>_route</code>的更新会触发<code>route-view</code>的重新渲染。</li></ul> 
<h3><a id="50_Vuex_781"></a>50. 你是怎么认识Vuex的？</h3> 
<ul><li>Vuex可以来理解为一种开发模式或框架，通过状态集中管理驱动组件的变化；</li><li>应用级的状态几种放在<code>state</code>中；</li><li>改变状态的方式是提交<code>mutations</code>，这里必须是同步的；</li><li>异步逻辑应该封装在<code>action</code>中；</li></ul> 
<h3><a id="51_Vuex_787"></a>51. 为什么使用Vuex</h3> 
<ul><li>项目比较大，以往的关系组件通信进行数据的传递很麻烦，不方便；</li><li>状态的统一管理，实现数据的共享；</li><li>实现非关联组件之间的通信。</li></ul> 
<h3><a id="52_Vuex5_793"></a>52. Vuex的5个核心属性</h3> 
<ul><li>分别是：<code>module、state、mutation、action、getter</code>；</li></ul> 
<ol><li><strong>modules</strong>： 
  <ul><li>模块化；</li><li>其实只是解决了当 <code>state</code> 中很复杂臃肿的时候，<code>module</code>可以将<code>store</code>分隔成模块，每个模块拥有自己的<code>state、mutation、action、getter</code>；</li></ul> </li><li><strong>state</strong>： 
  <ul><li>状态管理（定义变量）；</li><li>在<code>state</code>中定义我们需要管理的数据，只有在这里定义了，在Vue的组件中才能获取到定义数据的状态；</li><li>使用： 
    <ul><li>不使用辅助函数： 
      <ul><li><code>this.$store.state.模块名.变量名</code></li></ul> </li><li>辅助函数： 
      <ul><li><img src="https://images2.imgbox.com/8a/61/FLWceGp2_o.png" alt="image.png"></li></ul> </li></ul> </li></ul> </li><li><strong>mutations</strong>： 
  <ul><li>同步修改state；</li><li>定义在mutations中的方法，有两个入参，分别是：<code>state</code> 和 <code>payload</code></li><li>使用： 
    <ul><li>不使用辅助函数： 
      <ul><li><code>this.$store.commit('模块名/方法名', 需要传递的数据)</code></li></ul> </li><li>辅助函数： 
      <ul><li><img src="https://images2.imgbox.com/f4/a0/nqpdxHs7_o.png" alt="image.png"></li></ul> </li></ul> </li></ul> </li><li><strong>actions</strong>： 
  <ul><li>异步修改state，使用commit方法将数据提交给mutations中的方法进行修改；</li><li>定义在actions中的方法，有两个入参，分别是：<code>context</code> 和 <code>payload</code></li><li>使用： 
    <ul><li>不使用辅助函数： 
      <ul><li><code>this.$store.dispatch('模块名/方法名', 传递的数据)</code></li></ul> </li></ul> </li></ul> </li><li><strong>getters</strong>： 
  <ul><li>类似于Vue的计算属性；</li><li>当我们需要从<code>store</code>的<code>state</code>中派生一些状态，那么我们就需要使用<code>getter</code>；</li><li><code>getter</code>会接受<code>state</code>作为第一个参数，而且<code>getter</code>的返回值会根据它的依赖被缓存起来，只有<code>getter</code>中的依赖值发生改变的时候才会被重新计算；</li><li>getters中的方法有两个入参，分别是：<code>state</code> 和 <code>payload</code></li><li>在srore下新建getters.js文件</li><li><img src="https://images2.imgbox.com/f2/a1/PYcZkRNM_o.png" alt="image.png"></li><li><img src="https://images2.imgbox.com/95/06/oFxWjiCA_o.png" alt="image.png"></li></ul> </li></ol> 
<h3><a id="53_Vuex_829"></a>53. 为什么需要对Vuex持久化</h3> 
<ul><li>vuex中的数据在页面刷新后就没有了；</li><li>要实现数据的长久保存，可以通过浏览器的本地存储能力实现 
  <ul><li>cookie</li><li>localStorage</li></ul> </li></ul> 
<h3><a id="54_Vuexstate_836"></a>54. Vuex可以直接修改state的值吗</h3> 
<ul><li>可以直接修改，但是及其不推荐；</li><li><code>state</code>的修改必须在<code>mutation</code>来修改，否则无法被<code>devtools</code>所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游 / 回滚之类的操作。</li></ul> 
<h3><a id="55_Vuexmutationaction_841"></a>55. Vuex的mutation和action之间的区别是什么</h3> 
<ul><li><strong>功能不同</strong>： 
  <ul><li><code>mutation</code>：专注于修改<code>state</code>，理论上是修改<code>state</code>的唯一途径；</li><li><code>action</code>：专注于业务代码，可以发异步请求；</li></ul> </li><li><strong>限制</strong>： 
  <ul><li><code>mutation</code>：必须同步执行；</li><li><code>action</code>：可以异步，但不能直接修改<code>state</code>；</li></ul> </li></ul> 
<h3><a id="56_Vuexmutation_849"></a>56. 为什么Vuex的mutation不能做异步操作</h3> 
<ul><li>Vuex中所有的状态更新的唯一途径都是<code>mutation</code>，异步操作通过<code>Action</code>来提交<code>mutation</code>实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用；</li><li>每个<code>mutation</code>执行完成后都会对应一个新的状态变更，这样<code>devtools</code>就可以打个快照存下来，否则无法被<code>devtools</code>所监测；</li><li>如果<code>mutation</code>支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul> 
<h3><a id="57_Vue_855"></a>57. Vue单页面应用的优缺点</h3> 
<ul><li><strong>优点</strong>： 
  <ul><li>内容的改变不需要重新加载整个页面，web应用更具响应性；</li><li>没有页面之间的切换，就不会出现“白屏现象”，也不会出现假死并没有“闪烁”现象；</li><li>相对服务器压力小，服务器只用出数据就可以，不用展示逻辑和页面合成，吞吐能力会提高几倍；</li><li>良好的前后端分离。后端不再负责模板渲染、输出页面工作。后端API通用化，既一套后端程序代码，不用修改可以用于Web界面、手机、平板等多种客户端。</li></ul> </li><li><strong>缺点</strong>： 
  <ul><li>首次加载耗时比较长；</li><li>SEO问题，不利于百度，360等搜索引擎收录；</li><li>容易造成Css命名冲突；</li><li>前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂程度很高，需要一定的技能水平和开发成本。</li></ul> </li></ul> 
<h3><a id="58__868"></a>58. 如何对首屏加载实现优化</h3> 
<ul><li>把不常用的库放到index.html中，使用cdn引入；</li><li>使用懒加载；</li><li>Vue组件避免全局注册；</li><li>使用更轻量级的工具库；</li><li>预渲染；</li><li>减少http请求；</li><li>开启gzip压缩。</li></ul> 
<h3><a id="59_SPA_878"></a>59. 对SPA单页面的理解，它的优缺点分别是什么？</h3> 
<ul><li>单页Web应用是一种特殊的Web应用。他将所有的活动局限于一个web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript和CSS，一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用JavaScript动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA可以提供较为流畅的用户体验。得益于Ajax，我们可以实现无跳转刷新，又多亏了浏览器的history机制，我们用hash的变化从而可以实现推动界面变化，从而模拟元素客户端的单页面切换效果；</li><li>优点： 
  <ul><li>单页面应用的内容的改变不需要重新加载整个页面，Web应用更具响应性；</li><li>单页面没有页面之间的切换，就不会出现“白屏现象”，也不会出现假死并没有“闪烁”现象；</li><li>单页面应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面和声，吞吐能力会提高几倍；</li><li>良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，既同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。</li></ul> </li><li>缺点： 
  <ul><li>首次加载耗时比较多；</li><li>不利于SEO优化；</li><li>各个浏览器的版本兼容性不一样；</li><li>业务随着代码量增加而增加，不利于首屏优化；</li><li>前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂程度很高，需要一定的技能水平和开发成本。</li></ul> </li></ul> 
<h3><a id="60__893"></a>60. 项目优化</h3> 
<ul><li>减少http请求；</li><li>减少DOM操作；</li><li>使用JSON格式来进行数据的交换；</li><li>使用CDN加速；</li><li>优化代码，减少代码体积；</li><li>服务端渲染。</li></ul> 
<h3><a id="61_VNodeDOM_901"></a>61. VNode是什么，什么是虚拟DOM？</h3> 
<ul><li>VNode是什么： 
  <ul><li>VNode 是 JavaScript 对象，VNode 表示 Virtual DOM，用 JavaScript 对象来<br> 描述真实的 DOM，把 DOM 标签、属性、内容都变成对象的属性。就像使用 JavaScript对象对一种动物进行说明一样；</li></ul> </li><li>VNode的作用： 
  <ul><li>通过 render 将 template 模版描述成 VNode，然后进行一系列操作之后形成真实的DOM进行挂载；</li></ul> </li><li>VNode的优点： 
  <ul><li>兼容性强，不受执行环境的影响。VNode 因为是 JS 对象，不管 Node 还是浏览器，都可以统一操作，从而获得了服务端渲染、原生渲染、手写渲染函数等能力；</li><li>减少操作 DOM，任何页面的变化，都只使用 VNode 进行操作对比，只需要在最后一步挂载更新 DOM，不需要频繁操作 DOM，从而提高页面性能；</li></ul> </li><li>什么是虚拟DOM？ 
  <ul><li>文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变。</li><li>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM 的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构,一旦计算出，就将其应用于实际的 DOM 树，这就提高了性能，这就是为什么基于虚拟 DOM 的框架（例如 Vue 和 React）如此突出的原因。</li></ul> </li></ul> 
<h3><a id="62_Vue_914"></a>62. 如何对Vue首屏加载实现优化</h3> 
<ul><li>把不常改变的库放到 <code>index.html</code> 中，通过 <code>cdn</code> 导入；</li><li>Vue路由的懒加载；</li><li>Vue组件尽量不要全局引入；</li><li>使用更轻量级的工具库；</li><li>开启gzip压缩；</li><li>首页单独做服务端渲染；</li></ul> 
<h3><a id="63_Vuedata_922"></a>63. Vue中怎么重置data</h3> 
<ul><li>要初始化 <code>data</code> 中的数据，可以使用 <code>Object.assign()</code>方法，实现重置 data 中的数据：</li><li><code>Object.assign()</code>方法基本定义： 
  <ul><li><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象赋值到目标对象，他将返回目标对象；</li><li>用法：<code>Object.assign(target, ...sources)</code>； 
    <ul><li>第一个参数是目标对象；</li><li>后面的参数是源对象，可以有多个，就是将源对象属性复制到目标对象，返回目标对象；</li></ul> </li></ul> </li><li>具体实现： 
  <ul><li>使用 <code>Object.assign()</code>，<code>vm.$data</code> 可以获取当前状态下的 <code>data</code> ，<br> <code>vm.$options.data(this)</code> 可以获取到组件初始化状态下的 <code>data</code> ， 复制<code>Object.assign(this.$data, this.$options.data(this))</code>；</li><li>❗ 注意加 this，不然取不到 <code>data(){ a: this.methodA }</code> 中的 <code>this.methodA</code>。</li></ul> </li></ul> 
<h3><a id="64_Vue2__Vue3__934"></a>64. Vue2 和 Vue3 的区别？</h3> 
<ul><li><strong>API不同</strong>： 
  <ul><li>Vue2采用选项式API，对于代码阅读、维护、逻辑复用不是太友好（可以通过minix实现逻辑复用）；</li><li>Vue3采用组合式API，功能代码组合在一起，方便维护、逻辑复用；</li></ul> </li><li><strong>使用</strong>： 
  <ul><li>Vue2：配合vuex，对于TS的支持不是很好；</li><li>Vue3：配合pinia，底层是使用TS重构的，对TS支持很好；</li></ul> </li></ul> 
<ul><li><strong>根节点数目</strong>： 
  <ul><li>Vue2只能有一个根节点； 
    <ul><li>因为vdom是一棵单根树型结构，pacth方法在遍历的时候从根节点开始遍历，他要求只有一个根节点，组件也会转换为一个vdom，自然应该满足这个要求。</li></ul> </li><li>Vue3可以有多个根节点； 
    <ul><li>Vue3中引入了<code>Fragment</code>的概念，这是一个抽象的节点，如果发现组件是多个根节点，就创建一个 Fragment节点，把多个根节点作为它的children。将来patch的时候，如果发现是一个Fragment节点，则直接遍历children创建或更新。</li></ul> </li></ul> </li><li><strong>数据双向绑定原理不同</strong>： 
  <ul><li>Vue2采用Object.defineProperty</li><li>Vue3采用ES6新增的Proxy</li></ul> </li><li><strong>生命周期不同</strong>：<pre><code class="prism language-js">Vue2                 <span class="token operator">==</span><span class="token operator">&gt;</span>             Vue3

<span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     
<span class="token function">Created</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">beforeMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onBeforeMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">beforeDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onBeforeUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onActivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">==</span><span class="token operator">&gt;</span>             <span class="token function">onDeactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> </li><li><strong>v3性能比v2快</strong>： 
  <ul><li>v3采用静态标记，给静态节点打上标记，diff的过程只对比动态节点，忽略静态节点；</li><li>虚拟dom的创建： 
    <ul><li>v2中，数据发生变化，会将模板进行重编译，生成所有的虚拟dom；</li><li>v3中，数据发生变化，看该dom是否参与更新，如果参与更新，创建新的虚拟dom，如果不参与更新，直接复用上一次的虚拟dom；</li></ul> </li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a5a33300e8ade4bec218d348d1fb341/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Css基础——绘制三角形、鼠标样式、轮廓线、放拖拽文本域、vertical-align属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3219d6c14ac93eac28422e05d1d99ac6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【RabbitMQ】【Docker】基于docker-compose构建rabbitmq容器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>