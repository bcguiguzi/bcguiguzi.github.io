<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java SPI机制总结系列之开发入门实例 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java SPI机制总结系列之开发入门实例" />
<meta property="og:description" content="原创/朱季谦
在该文章正式开始前，先对 Java SPI是什么做一个简单的介绍。
SPI，是Service Provider Interface的缩写，即服务提供者接口，单从字面上看比较抽象，你可以理解成，该机制就像Spring容器一样，通过IOC将对象的创建交给了Spring容器处理，若需要获取某个类的对象，就从Spring容器里取出使用即可。同理，在SPI机制当中，提供了一个类似Spring容器的角色，叫【服务提供者】，在代码运行过程中，若要使用到实现了某个接口的服务实现类对象，只需要将对应的接口类型交给服务提供者。服务提供者将会动态加载实现了该接口的所有服务实现类对象。
服务提供者的角色用下图来表示。
举一个例子来说明。
假如，假如Maven项目里有这样一个interface接口，接口全名“com.zhu.service.UserService”——
package com.zhu.service; public interface UserService { void getName(); } 创建一个“com.zhu.service.impl.AUserServiceImpl”实现类——
public class AUserServiceImpl implements UserService { @Override public void getName() { System.out.println(&#34;这是A用户姓名&#34;); } } 接着在resource资源里，创建一个META-INF.services目录，在该目录里，创建一个文件名与接口com.zhu.service.UserService一致的文件——
该com.zhu.service.UserService文件里写下com.zhu.service.impl.UserServiceImpl类名字——
这时候，就可以基于Java SPI动态加载到接口的实现类并执行了，我们写一个简单的测试类做验证——
public class Test { public static void main(String[] args) { ServiceLoader&lt;UserService&gt; serviceLoader = ServiceLoader.load(UserService.class); Iterator&lt;UserService&gt; serviceIterator = serviceLoader.iterator(); while (serviceIterator.hasNext()) { UserService service = serviceIterator.next(); service.getName(); } } } } 执行该代码，ServiceLoader会加载到META-INF.services目录下的配置文件，找到对应接口全名文件，读取文件里的类名，再通过反射就可以进行实现类的实例化。既然能找到实现类的对象，那么不就可以基于父类引用指向子类对象，进而调用到实现类的getName()方法。该方法里执行打印语句 System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6d95c74369883b5bc9316f605653b987/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T21:43:46+08:00" />
<meta property="article:modified_time" content="2024-01-14T21:43:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java SPI机制总结系列之开发入门实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <img alt="" height="96" src="https://images2.imgbox.com/ef/71/oKyrPios_o.png" width="314"></p> 
<p>原创/朱季谦</p> 
<p>在该文章正式开始前，先对 Java SPI是什么做一个简单的介绍。</p> 
<p>SPI，是Service Provider Interface的缩写，即服务提供者接口，单从字面上看比较抽象，你可以理解成，该机制就像Spring容器一样，通过IOC将对象的创建交给了Spring容器处理，若需要获取某个类的对象，就从Spring容器里取出使用即可。同理，在SPI机制当中，提供了一个类似Spring容器的角色，叫【服务提供者】，在代码运行过程中，若要使用到实现了某个接口的服务实现类对象，只需要将对应的接口类型交给服务提供者。服务提供者将会动态加载实现了该接口的所有服务实现类对象。<br> 服务提供者的角色用下图来表示。</p> 
<p class="img-center"><img alt="image" height="780" src="https://images2.imgbox.com/78/ec/k0mPm1Fk_o.png" width="940"></p> 
<p>举一个例子来说明。</p> 
<p>假如，假如Maven项目里有这样一个interface接口，接口全名“com.zhu.service.UserService”——</p> 
<pre><code class="language-java">package com.zhu.service;

public interface UserService {
    void getName();
}
</code></pre> 
<p>创建一个“com.zhu.service.impl.AUserServiceImpl”实现类——</p> 
<pre><code class="language-java">public class AUserServiceImpl implements UserService {
    @Override
    public void getName() {
        System.out.println("这是A用户姓名");
    }
}
</code></pre> 
<p>接着在resource资源里，创建一个META-INF.services目录，在该目录里，创建一个文件名与接口com.zhu.service.UserService一致的文件——</p> 
<p class="img-center"><img alt="image" height="62" src="https://images2.imgbox.com/d7/14/9nKxasIp_o.png" width="465"></p> 
<p>该com.zhu.service.UserService文件里写下com.zhu.service.impl.UserServiceImpl类名字——</p> 
<p class="img-center"><img alt="image" height="104" src="https://images2.imgbox.com/80/df/aox0T1Km_o.png" width="385"></p> 
<p>这时候，就可以基于Java SPI动态加载到接口的实现类并执行了，我们写一个简单的测试类做验证——</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
    ServiceLoader&lt;UserService&gt; serviceLoader = ServiceLoader.load(UserService.class);
    Iterator&lt;UserService&gt; serviceIterator = serviceLoader.iterator();
    while (serviceIterator.hasNext()) {
         UserService service = serviceIterator.next();
         service.getName();
    }
}
    }
}
</code></pre> 
<p>执行该代码，ServiceLoader会加载到META-INF.services目录下的配置文件，找到对应接口全名文件，读取文件里的类名，再通过反射就可以进行实现类的实例化。既然能找到实现类的对象，那么不就可以基于父类引用指向子类对象，进而调用到实现类的getName()方法。该方法里执行打印语句 System.out.println("打印用户姓名")，打印结果如下，说明基于接口UserService，在程序动态加载并执行UserService接口实现。</p> 
<p class="img-center"><img alt="image" height="125" src="https://images2.imgbox.com/2a/17/WdXwfiKL_o.png" width="671"></p> 
<p>Java SPI的机制玩法，就如上文这一整个过程的实现。</p> 
<p>该机制存在一个缺陷，假如该接口对应的文件存在多份实现类，那么，它都会一起执行了。</p> 
<p>我们增加多一个实现类BUserServiceImpl——</p> 
<pre><code class="language-java">public class BUserServiceImpl implements UserService {
    @Override
    public void getName() {
        System.out.println("这是B用户姓名");
    }
}
</code></pre> 
<p>然后，在resource资源里的META-INF.services目录接口对应com.zhu.service.UserService文件里，将BUserServiceImpl实现类的全名增加到文件里——</p> 
<p class="img-center"><img alt="image" height="116" src="https://images2.imgbox.com/d5/56/7IMwubzv_o.png" width="431"></p> 
<p>其他原有的代码无需改动，直接执行Test的main方法，打印结果如下，可以看到，新增的BUserServiceImpl实现类的getName()也被运行了。</p> 
<p class="img-center"><img alt="image" height="166" src="https://images2.imgbox.com/1a/de/cFUz2tyA_o.png" width="668"></p> 
<p>这就说明，Java SPI机制会将文件里配置的所有实现类都动态加载运行，稍微思考了一下，不难发现，若当中某个实现类的getName()出现异常，那么后面还没有执行到的其他实现类就会终止了。</p> 
<p>因此，Dubbo框架在设计SPI机制时，只是参考了Java SPI的实现，但没有照搬，相比Java，Dubbo增强了SPI机制，可以针对请求动态得选择需要的接口实现类来运行，更加灵活方便。我在自己的另一边原创博文中，详细介绍过Dubbo SPI的原理，感兴趣的小伙伴可以阅读——<a href="https://blog.csdn.net/weixin_40706420/article/details/130400552?spm=1001.2014.3001.5501" title="《Dubbo2.7的Dubbo SPI实现原理细节》">《Dubbo2.7的Dubbo SPI实现原理细节》</a></p> 
<p>SPI机制的优点很明显，当我们需要基于已有接口新增一个实现类功能时，只需要新增一个实现类代码，无需在原有代码逻辑上做改动，就可以实现新增类的功能逻辑了。</p> 
<p>这种场景比较适合在报表或者处理Excel文档情况下，需针对一个新报表或者Excel做相应定制化处理，只需要基于SPI已有接口新增一个实现类即可。我会在后续文章中，将过去应用到SPI的实践经验做一下总结。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a413d12c769cf2383fd2f70c865f789e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux：/proc/kmsg 与 /proc/sys/kernel/printk_xxx</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbc35d59ab9cb9841f689f6c1f74f3a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过本质看现象：关于Integer受内部初始化赋值范围限制而出现的有趣现象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>