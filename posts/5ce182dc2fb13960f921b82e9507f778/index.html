<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hibernate实战(第二版)笔记----第二章--开启一个项目 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hibernate实战(第二版)笔记----第二章--开启一个项目" />
<meta property="og:description" content="最近在看Hibernate实战(第二版)这本书,个人感觉翻译的不是很好，有些地方读都读不通。。。
随便做下笔记,书中提供下载源码的地址为: http://jpwh.org 下载下来之后，目录如下
其中:
apps----第18/19章对应的客服端与服务端程序
environment----一些通用的环境
examples----一些实例
model---一些实体类
shared---共享的一些帮助类什么的
README.txt说明文件如下:
============================================================================== Java Persistence with Hibernate - Second Edition http://www.manning.com/bauer3/ ============================================================================== 入门 ------------------------------------------------------------------------------ - Install JDK 7. - Install Maven 3.x. - 运行&#39;mvn clean test&#39;来执行所有的例子（这将需要一段时间 依赖关系必须首次下载）。 - 打开报告 examples/target/surefire-reports/index.html - 详细了解每个子目录的pom.xml文件中的模块并进行浏览 源代码。 - 获取更多的日志输出, 编辑 shared/src/main/resources/logging.properties 并运行测试。 所有日志输出都将写入文件 examples/target/surefire-reports/TestSuite-output.txt - 要仅运行单个测试，请先将模块安装到您的本地Maven中 存储库使用&#39;mvn clean install&#39;。 然后运行测试： mvn -pl examples -Dtest=org.jpwh.test.simple.CRUD clean test - 如果只运行单个测试，则控制台日志输出将被写入 在以前的情况下，一个不同的文件： examples/target/surefire-reports/org.jpwh.test.simple.CRUD-output.txt 运行示例APPS ------------------------------------------------------------------------------ - 安装Wildfly 8." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5ce182dc2fb13960f921b82e9507f778/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-03T17:20:34+08:00" />
<meta property="article:modified_time" content="2017-07-03T17:20:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hibernate实战(第二版)笔记----第二章--开启一个项目</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">最近在看Hibernate实战(第二版)这本书,个人感觉翻译的不是很好，有些地方读都读不通。。。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/0a/e3/4Kk3g2Dh_o.jpg" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">随便做下笔记,书中提供下载源码的地址为: <a target="_blank" href="http://jpwh.org" rel="nofollow noopener noreferrer"> http://jpwh.org</a> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/fd/3c/0EZkAPq6_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">下载下来之后，目录如下</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/f9/44/xT5wQzCW_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">其中:</span></p> 
<p><span style="font-size:18px">apps----第18/19章对应的客服端与服务端程序</span></p> 
<p><span style="font-size:18px">environment----一些通用的环境<br> </span></p> 
<p><span style="font-size:18px">examples----一些实例<br> </span></p> 
<p><span style="font-size:18px">model---一些实体类<br> </span></p> 
<p><span style="font-size:18px">shared---共享的一些帮助类什么的<br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">README.txt说明文件如下:</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">==============================================================================
Java Persistence with Hibernate - Second Edition

http://www.manning.com/bauer3/

==============================================================================


入门
------------------------------------------------------------------------------

- Install JDK 7.

- Install Maven 3.x.

- 运行'mvn clean test'来执行所有的例子（这将需要一段时间
  依赖关系必须首次下载）。

- 打开报告 examples/target/surefire-reports/index.html

- 详细了解每个子目录的pom.xml文件中的模块并进行浏览
  源代码。

- 获取更多的日志输出, 编辑 shared/src/main/resources/logging.properties
  并运行测试。 所有日志输出都将写入文件
  examples/target/surefire-reports/TestSuite-output.txt

- 要仅运行单个测试，请先将模块安装到您的本地Maven中
  存储库使用'mvn clean install'。 然后运行测试：

      mvn -pl examples -Dtest=org.jpwh.test.simple.CRUD clean test

- 如果只运行单个测试，则控制台日志输出将被写入
  在以前的情况下，一个不同的文件：

  examples/target/surefire-reports/org.jpwh.test.simple.CRUD-output.txt


运行示例APPS
------------------------------------------------------------------------------

- 安装Wildfly 8.2.0.Final

- 在后台使用 $WILDFLY/bin/standalone.sh运行应用程序服务器

- 运行 "Stateless Client/Server" 示例应用程序:

    mvn -P app-stateless-server clean install
    mvn -P app-stateless-server clean package wildfly:deploy
    mvn -P app-stateless-client clean test
    mvn -P app-stateless-server clean package wildfly:undeploy

- Run the "Stateful Client/Server" example app:

    mvn -P app-stateful-server clean install
    mvn -P app-stateful-server clean package wildfly:deploy
    mvn -P app-stateful-client clean test
    mvn -P app-stateful-server clean package wildfly:undeploy

- Run the "CaveatEmptor Web Application" example:

    mvn -P app-web clean package wildfly:deploy
    Open in browser: http://localhost:8080/app-web/
    mvn -P app-web wildfly:undeploy


运行/浏览外部数据库
------------------------------------------------------------------------------

- 默认情况下，使用内存中H2数据库实例进行测试。 你不能
   使用SQL控制台访问和浏览此数据库。 如果你只想看看
   模式/SQL，如上所述编辑logging.properties。

- 您可以切换到外部已经运行的H2数据库。 首先启动
   数据库通过双击H2.jar文件。 它应该在你的Maven
   存储库（~/.m2/repository/com/h2database/）或者你可以从它下载
   http://h2database.com。 H2网页控制台将打开，你可以简单的
   用户'sa'连接到数据库实例，没有密码。

- 将示例模块安装到本地存储库中:

    mvn clean install

- 运行单个测试方法，并在完成后保留模式/数据：

    mvn -pl examples \
     -Dtest=org.jpwh.test.simple.CRUD#storeAndQueryItems \
     -DconnectionURL=jdbc:h2:tcp://localhost/mem:test \
     -DkeepSchema=true \
     clean test

- 在H2控制台中执行测试方法后浏览数据库。

- 您可以再次执行相同的测试方法，数据库将被清理
   在方法运行之前。 您可以执行相同测试的其他方法
   类，每个测试类使用相同的数据库模式。

- 要执行另一个具有不同模式的测试类的方法，请停止
	在切换测试类时启动H2数据库。请注意,H2
	删除最后一个连接时的内存数据库。如果
	在H2 web控制台断开连接，数据库将被删除。


------------------------------------------------------------------------------

Visit us on the Manning author forum:
    http://www.manning-sandbox.com/forum.jspa?forumID=844
</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">打开Eclipse选择Import</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/b1/98/eyPzGdNu_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">选择一个存在的Maven项目</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/18/41/VjIRccP5_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">然后点击Finish，完成导入，导入成功之后如下:</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/69/31/lsD9lJYA_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">导入之后，会报很多错:</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">比如说这几个类CreditCard_、 Item_ 、Bid_提示找不到，我找了半天在书中对应的论坛找到了一种说法:<a target="_blank" href="https://forums.manning.com/posts/list/35484.page" rel="nofollow noopener noreferrer">https://forums.manning.com/posts/list/35484.page</a></span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/ee/00/CTnbqGA7_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">暂时把那些报错的地方全部注释掉。然后对照着书中的第二章的开启一个项目,运行测试,发现测试用的TestNG框架,然后把TestNG插件装上</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>(一)、使用JPA的"Hello Word"</strong></span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">它这里使用了持久化单元,什么是持久化单元,网上的解释是,一个持久化单元（Persistence Unit）就是关于一组Entity类的命名配置。持久化单元是一个静态的概念,持久性单元具有唯一的名称，负责定义应用中的一组实体如何进行管理和持久性。在应用中使用persistence.xml文件来设置持久性单元，可以配置多个持久性单元，但每个单元拥有唯一的名称。<br> <br> 持久性单元包含的属性有：</span></p> 
<p><span style="font-size:18px"><br> 1.在该持久性单元范围（作用域）内的实体类<br> 2.为上述实体类提供持久性的持久性提供者(Persistence Provider)或库<br> 3.上述实体类的数据源(Data Source)<br> 4.应用使用的事务类型(Transaction Type)<br> 5.持久性单元能够被打包成WAR文件，EJB-JAR文件,EAR文件的一部分，或者直接打包成应用程序能够直接使用的JAR文件。<br> <br> 持久性单元的范围（作用域）取决于persistence.xml文件的位置。一般说来，IDE能够使用引导界面来正确放置persistence.xml的位置。例如使用IDE为EJB模块（Module）创建的持久性单元，persistence.xml文件将被放在EJB模块的src/conf目录中，当你将模块打包时，persistence.xml文件被放在EJB JAR文件的META-INF目录中。这样持久性单元的作用域就是EJB JAR文件中的类。<br> <br> 注意：persistence.xml文件的位置决定持久性的根(Persistence Root)。持久性的根为JAR文件或者包含META-INF目录（前提是persistence.xml位于此）的目录。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">JPA规范要求在类路径的META-INF目录下放置persistence.xml, 文件的名称是固定的，配置模板如下： <br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1"
 xmlns="&lt;a target=_blank href="http://xmlns.jcp.org/xml/ns/persistence"&gt;http://xmlns.jcp.org/xml/ns/persistence&lt;/a&gt;" xmlns:xsi="&lt;a target=_blank href="http://www.w3.org/2001/XMLSchema-instance"&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/a&gt;"
 xsi:schemaLocation="&lt;a target=_blank href="http://xmlns.jcp.org/xml/ns/persistence"&gt;http://xmlns.jcp.org/xml/ns/persistence&lt;/a&gt;
 &lt;a target=_blank href="http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd&lt;/a&gt;"&gt;
  
	&lt;persistence-unit name="persist-unit" transaction-type="RESOURCE_LOCAL"&gt;
	
	  &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
	  &lt;!-- All persistence classes must be listed --&gt;
	  &lt;class&gt;boa.framework.entity.CustomerEntity&lt;/class&gt;                                                                                 &lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;
	   &lt;validation-mode&gt;CALLBACK&lt;/validation-mode&gt;     
	  &lt;properties&gt;
	   &lt;!-- Provider-specific connection properties --&gt;
	   &lt;property name="javax.persistence.jdbc.url" value="jdbc:derby:memory:exampleDB;create=true" /&gt;
	   &lt;property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver" /&gt;
	   &lt;property name="javax.persistence.jdbc.user" value="" /&gt;
	   &lt;property name="javax.persistence.jdbc.password" value="" /&gt;
	   &lt;property name="javax.persistence.schema-generation.database.action"
	    value="drop-and-create" /&gt;
	   &lt;property name="javax.persistence.schema-generation.create-source"
	    value="script" /&gt;
	   &lt;property name="javax.persistence.schema-generation.create-script-source"
	    value="META-INF/create-script.sql" /&gt;
	   &lt;property name="eclipseink.logging.level" value="INFO" /&gt;
	  &lt;/properties&gt;
	 &lt;/persistence-unit&gt;

  
	&lt;!--   
		  Name属性用于定义持久化单元的名字 (name必选,空值也合法);   
		  transaction-type 指定事务类型(可选)   
	--&gt;  
	&lt;persistence-unit name="unitName" transaction-type="JTA"&gt;  
  
   &lt;!-- 描述信息.(可选) --&gt;  
   &lt;description&gt; &lt;/description&gt;  
  
   &lt;!-- javax.persistence.PersistenceProvider接口的一个实现类(可选) --&gt;  
   &lt;provider&gt;   &lt;/provider&gt;  
  
   &lt;!-- Jta-data-source和 non-jta-data-source用于分别指定持久化提供商使用的JTA和/或non-JTA数据源的全局JNDI名称(可选) --&gt;  
   &lt;jta-data-source&gt;java:/test&lt;/jta-data-source&gt;  
   &lt;non-jta-data-source&gt; &lt;/non-jta-data-source&gt;  
  
   &lt;!-- 声明orm.xml所在位置.(可选) --&gt;  
   &lt;mapping-file&gt;product.xml&lt;/mapping-file&gt;  
  
   &lt;!-- 以包含persistence.xml的jar文件为基准的相对路径,添加额外的jar文件.(可选) --&gt;  
   &lt;jar-file&gt;../lib/model.jar&lt;/jar-file&gt;  
  
   &lt;!-- 显式列出实体类,在Java SE 环境中应该显式列出.(可选) --&gt;  
   &lt;class&gt;boa.framework.entity.CustomerEntity&lt;/class&gt;
  
   &lt;!-- 声明是否扫描jar文件中标注了@Enity类加入到上下文.若不扫描,则如下:(可选) --&gt;  
   &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt;　
　　　shared-cache-mode
　　缓存模式。加了@Cacheable注解的默认为二级缓存。有四种模式：ALL-缓存所有实体；NONE-禁止缓存；ENABLE_SELECTIVE-如果加了缓存的标识，是默认的选选　　　　　　　　项；DISABLE_SELECTIVE- enable caching unless explicitly marked as  @Cacheable(false) (not  recommended)
　　validation-mode
　　实体的验证模式，默认是激活的。当一个实体在创建、更新，在实体发送到数据库前会被进行验证。CALLBACK: entities are validated on creation, update and deletion. If no Bean Validation provider  is present, an exception is raised at initialization time.                        &lt;!--    厂商专有属性(可选)    --&gt;  
   &lt;properties&gt;  
    &lt;!-- hibernate.hbm2ddl.auto= create-drop / create / update --&gt;  
      &lt;property name="eclipseink.logging.level" value="INFO" /&gt;  
   &lt;/properties&gt;  
  
	&lt;/persistence-unit&gt;  
  
&lt;/persistence&gt;  
</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px">本示例中的<span style="font-size:18px">persistence.xml内容为:</span></span></p> 
<p><span style="font-size:18px"><span style="font-size:18px"><br> </span></span></p> 
<p><span style="font-size:18px"><span style="font-size:18px"></span></span></p> 
<pre><code class="language-html">&lt;persistence
        version="2.1"
        xmlns="http://xmlns.jcp.org/xml/ns/persistence"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                            http://xmlns.jcp.org/xml/ns/persistence_2_1.xsd"&gt;

    &lt;!-- 
			&lt;code&gt;persistence.xml&lt;/code&gt;文件至少配置一个持久化单元;
			每个单元必须有一个唯一的名称。
    --&gt;
    &lt;persistence-unit name="HelloWorldPU"&gt;

        &lt;!-- 
				每个持久化单元必须有一个数据库连接。在这里你委托给
				现有的&lt;code&gt;java.sql.DataSource&lt;/code&gt;。Hibernate会找到数据源
				通过在启动时使用JNDI查找来命名。
        --&gt;
        &lt;jta-data-source&gt;myDS&lt;/jta-data-source&gt;

        &lt;!-- 
				持久单元有持久的(映射)类，您将它们列在这里。       
		 --&gt;
        &lt;class&gt;org.jpwh.model.helloworld.Message&lt;/class&gt;

        &lt;!-- 
			Hibernate可以为映射的类扫描类路径并自动添加它们
			给你的坚持单位。
			这种设置禁用了该特性。
        --&gt;
        &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt;

        &lt;!-- 
				可以将标准或供应商特定的选项设置为持久性单元的属性。
				任何标准属性都有 &lt;code&gt;javax.persistence&lt;/code&gt; 名称前缀,
				使用Hibernate的设置 &lt;code&gt;hibernate&lt;/code&gt;
        --&gt;
        &lt;properties&gt;

            &lt;!-- 
				JPA引擎应该在启动时自动删除和重新创建数据库中的SQL模式。
				对于自动化测试来说，这是非常理想的，
				当您想要为每个测试运行使用一个干净的数据库时。
            --&gt;
            &lt;property
                name="javax.persistence.schema-generation.database.action"
                value="drop-and-create"/&gt;

            &lt;!-- 
               	 当在日志中打印SQL时，让Hibernate格式化SQL并将注释生成到SQL字符串中，这样我们就可以知道为什么Hibernate执行SQL语句了
            --&gt;
            &lt;property name="hibernate.format_sql" value="true"/&gt;
            &lt;property name="hibernate.use_sql_comments" value="true"/&gt;

            &lt;!-- 禁用Hibernate扫描，我们也不需要任何的hbm.xml文件。它会发现并自动添加的xml文件 --&gt;
            &lt;property name="hibernate.archive.autodetection" value="none"/&gt;

        &lt;/properties&gt;
    &lt;/persistence-unit&gt;

   
&lt;/persistence&gt;</code></pre> 
<br> 里面有很多,这里删除了一些。 
<p></p> 
<p><br> </p> 
<p><span style="font-size:18px">找到examples中的HelloWorldJPA</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">package org.jpwh.helloworld;

import org.jpwh.env.TransactionManagerTest;
import org.jpwh.model.helloworld.Message;
import org.testng.annotations.Test;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.transaction.UserTransaction;
import java.util.List;

import static org.testng.Assert.assertEquals;

public class HelloWorldJPA extends TransactionManagerTest {

    @Test
    public void storeLoadMessage() throws Exception {

        EntityManagerFactory emf =
            Persistence.createEntityManagerFactory("HelloWorldPU");

        try {
        	
        	
        	
        	//初始化代码块
            {
                /* 
					访问标准事务API &lt;code&gt;UserTransaction&lt;/code&gt;和
					在执行的线程上启动事务。
                 */
                UserTransaction tx = TM.getUserTransaction();
                tx.begin();

                /* 
					通过创建一个&lt;code&gt;EntityManager&lt;/code&gt;来开始一个新的会话
					是所有持久性操作的上下文。
                 */
                EntityManager em = emf.createEntityManager();

                /* 
                    Create a new instance of the mapped domain model class &lt;code&gt;Message&lt;/code&gt; and
                    set its &lt;code&gt;text&lt;/code&gt; property.
                 */
                Message message = new Message();
                message.setText("Hello World!");

                /* 
					 使用持久性上下文来列举瞬态实例，使其持续存在。
                     Hibernate现在知道你想存储的数据，它不一定调用
                     数据库，但是。
                 */
                em.persist(message);

                /* 
						提交事务，Hibernate现在自动检查持久化上下文
						执行必要的SQL &lt;code&gt;INSERT&lt;/code&gt;语句。
                 */
                tx.commit();
                // INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World!')

                /* 
                    If you create an &lt;code&gt;EntityManager&lt;/code&gt;, you must close it.
                 */
                em.close();
            }

            {
                /* 
					每个与数据库的交互都应该在显式事务边界内发生，
					即使你只是在阅读数据。
                 */
                UserTransaction tx = TM.getUserTransaction();
                tx.begin();

                EntityManager em = emf.createEntityManager();

                /* 
					执行一个查询，以从数据库检索&lt;code&gt;Message&lt;/code&gt;的所有实例。
                 */
                List&lt;Message&gt; messages =
                    em.createQuery("select m from Message m").getResultList();
                // SELECT * from MESSAGE


                assertEquals(messages.size(), 1);
                assertEquals(messages.get(0).getText(), "Hello World!");
                

                /* 
					您可以更改属性的值，Hibernate会自动检测到这一点，因为
					加载的&lt;code&gt;Message&lt;/code&gt;仍然依附于它所加载的持久化上下文。
                 */
                messages.get(0).setText("Take me to your leader!");

                /* 
                    On commit, Hibernate checks the persistence context for dirty state and executes the
                    SQL &lt;code&gt;UPDATE&lt;/code&gt; automatically to synchronize the in-memory with the database state.
                 */
                tx.commit();
                // UPDATE MESSAGE set TEXT = 'Take me to your leader!' where ID = 1

                em.close();
            }

        } finally {
            TM.rollback();
            emf.close();
        }
    }

}
</code></pre> 
<br> 项目右键Run AS---&gt; TestNG运行 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/25/48/sKYQb3hu_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">输出如下:</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">PASSED: storeLoadMessage

===============================================
    Default test
    Tests run: 1, Failures: 0, Skips: 0
===============================================

七月 03, 2017 3:44:03 下午 bitronix.tm.BitronixTransactionManager shutdown
信息: shutting down Bitronix Transaction Manager

===============================================
Default suite
Total tests run: 1, Failures: 0, Skips: 0
===============================================

[TestNG] Time taken by org.testng.reporters.jq.Main@5fdef03a: 25 ms
[TestNG] Time taken by [FailedReporter passed=0 failed=0 skipped=0]: 1 ms
[TestNG] Time taken by org.testng.reporters.XMLReporter@77556fd: 4 ms
[TestNG] Time taken by org.testng.reporters.JUnitReportReporter@14899482: 4 ms
[TestNG] Time taken by org.testng.reporters.SuiteHTMLReporter@16b3fc9e: 26 ms
[TestNG] Time taken by org.testng.reporters.EmailableReporter2@ed17bee: 4 ms</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px">接下来分析下他的源码,HelloWorldJPA继承TransactionManagerTest</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">/environment/src/main/java/org/jpwh/env/TransactionManagerTest.java的内容如下:</span></p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-html">package org.jpwh.env;

import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeSuite;
import org.testng.annotations.Optional;
import org.testng.annotations.Parameters;

import java.util.Locale;

/**
 * 在测试套件中启动和停止事务管理器/数据库池
 * &lt;p&gt;
 * 一个套件中的所有测试都是单个执行的 {@link TransactionManagerSetup}, 
 * 调用静态 {@link TransactionManagerTest#TM} 
 * 在您的测试中访问JTA事务管理器和数据库连接。
 * &lt;/p&gt;
 * &lt;p&gt;
 * 测试参数 &lt;code&gt;database&lt;/code&gt; (指定一个支持
 * {@link DatabaseProduct}) 和一个 &lt;code&gt;connectionURL&lt;/code&gt; 
 * 默认设置是内存中的H2数据库实例，为每个测试套件自动创建和销毁
 * &lt;/p&gt;
 */
public class TransactionManagerTest {

    // 每个测试套件静态单数据库连接管理器
    static public TransactionManagerSetup TM;

    @Parameters({"database", "connectionURL"})
    @BeforeSuite()
    public void beforeSuite(@Optional String database,
                            @Optional String connectionURL) throws Exception {
        TM = new TransactionManagerSetup(
        		
    	   //默认使用H2数据库
            database != null
                ? DatabaseProduct.valueOf(database.toUpperCase(Locale.US))
                : DatabaseProduct.H2,
            connectionURL
        );
    }

    @AfterSuite(alwaysRun = true)
    public void afterSuite() throws Exception {
        if (TM != null)
            TM.stop();
    }
}
</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">他里面加了这个类TransactionManagerSetup</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">/environment/src/main/java/org/jpwh/env/TransactionManagerSetup.java</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">package org.jpwh.env;

import bitronix.tm.TransactionManagerServices;
import bitronix.tm.resource.jdbc.PoolingDataSource;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;
import javax.transaction.Status;
import javax.transaction.UserTransaction;
import java.util.logging.Logger;

/**
  *提供与Bitronix JTA事务的数据库连接池
  * manager（http://docs.codehaus.org/display/BTM/Home）。
  * &lt;p&gt;
  * Hibernate将通过查找数据源和&lt;code&gt; UserTransaction &lt;/code&gt;
  * 通过JNDI,这就是为什么你还需要一个&lt;code&gt; jndi.properties &lt;/code&gt;文件。最小的
  * JNDI上下文与Bitronix绑定并启动。
  * &lt;/p&gt;
 */
public class TransactionManagerSetup {
    //数据源名称
    public static final String DATASOURCE_NAME = "myDS";

    private static final Logger logger =
        Logger.getLogger(TransactionManagerSetup.class.getName());

    protected final Context context = new InitialContext();
    protected final PoolingDataSource datasource;
    public final DatabaseProduct databaseProduct;

    public TransactionManagerSetup(DatabaseProduct databaseProduct) throws Exception {
        this(databaseProduct, null);
    }

    public TransactionManagerSetup(DatabaseProduct databaseProduct,
                                   String connectionURL) throws Exception {

        logger.fine("Starting database connection pool");

        logger.fine("Setting stable unique identifier for transaction recovery");
        TransactionManagerServices.getConfiguration().setServerId("myServer1234");

        logger.fine("Disabling JMX binding of manager in unit tests");
        TransactionManagerServices.getConfiguration().setDisableJmx(true);

        logger.fine("Disabling transaction logging for unit tests");
        TransactionManagerServices.getConfiguration().setJournal("null");

        logger.fine("Disabling warnings when the database isn't accessed in a transaction");
        TransactionManagerServices.getConfiguration().setWarnAboutZeroResourceTransaction(false);

        logger.fine("Creating connection pool");
        datasource = new PoolingDataSource();
        datasource.setUniqueName(DATASOURCE_NAME);
        datasource.setMinPoolSize(1);
        datasource.setMaxPoolSize(5);
        datasource.setPreparedStatementCacheSize(10);

        //我们的锁定/版本控制测试假设读取提交的事务
        //隔离。这不是默认的MySQL InnoDB，所以我们设置
        //明确地在这里。
        datasource.setIsolationLevel("READ_COMMITTED");

        //Hibernate的SQL模式生成器调用connection.setAutoCommit(true)
        //当EntityManager处于挂起状态时，我们使用自动提交模式
        //模式，并没有加入一个事务。
        datasource.setAllowLocalTransactions(true);

        logger.info("Setting up database connection: " + databaseProduct);
        this.databaseProduct = databaseProduct;
        databaseProduct.configuration.configure(datasource, connectionURL);

        logger.fine("Initializing transaction and resource management");
        datasource.init();
    }

    public Context getNamingContext() {
        return context;
    }

    public UserTransaction getUserTransaction() {
        try {
            return (UserTransaction) getNamingContext()
                .lookup("java:comp/UserTransaction");
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public DataSource getDataSource() {
        try {
            return (DataSource) getNamingContext().lookup(DATASOURCE_NAME);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public void rollback() {
        UserTransaction tx = getUserTransaction();
        try {
            if (tx.getStatus() == Status.STATUS_ACTIVE ||
                tx.getStatus() == Status.STATUS_MARKED_ROLLBACK)
                tx.rollback();
        } catch (Exception ex) {
            System.err.println("Rollback of transaction failed, trace follows!");
            ex.printStackTrace(System.err);
        }
    }

    public void stop() throws Exception {
        logger.fine("Stopping database connection pool");
        datasource.close();
        TransactionManagerServices.getTransactionManager().shutdown();
    }

}
</code></pre> 
<br> 它其中还引用了databaseProduct类databaseProduct类是一个枚举类型的,定义了一些数据库 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">/environment/src/main/java/org/jpwh/env/DatabaseProduct.java<br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">package org.jpwh.env;

import bitronix.tm.resource.jdbc.PoolingDataSource;

import java.util.Properties;

public enum DatabaseProduct {

    H2(
        new DataSourceConfiguration() {
            @Override
            public void configure(PoolingDataSource ds, String connectionURL) {
                ds.setClassName("org.h2.jdbcx.JdbcDataSource");

                // External instance: jdbc:h2:tcp://localhost/mem:test;USER=sa
                ds.getDriverProperties().put(
                    "URL",
                    connectionURL != null
                        ? connectionURL :
                        "jdbc:h2:mem:test"
                );

                // TODO: http://code.google.com/p/h2database/issues/detail?id=502
                ds.getDriverProperties().put("user", "sa");

                // TODO: Don't trace log values larger than X bytes (especially useful for
                // debugging LOBs, which are accessed in toString()!)
                // System.setProperty("h2.maxTraceDataLength", "256"); 256 bytes, default is 64 kilobytes
            }
        },
        org.jpwh.shared.ImprovedH2Dialect.class.getName()
    ),

    ORACLE(
        new DataSourceConfiguration() {
            @Override
            public void configure(PoolingDataSource ds, String connectionURL) {
                ds.setClassName("oracle.jdbc.xa.client.OracleXADataSource");
                ds.getDriverProperties().put(
                    "URL",
                    connectionURL != null
                        ? connectionURL :
                        "jdbc:oracle:thin:test/test@192.168.56.101:1521:xe"
                );

                // Required for reading VARBINARY/LONG RAW columns easily, see
                // http://stackoverflow.com/questions/10174951
                Properties connectionProperties = new Properties();
                connectionProperties.put("useFetchSizeWithLongColumn", "true");
                ds.getDriverProperties().put("connectionProperties", connectionProperties);
            }
        },
        org.hibernate.dialect.Oracle10gDialect.class.getName()
    ),

    POSTGRESQL(
        new DataSourceConfiguration() {
            @Override
            public void configure(PoolingDataSource ds, String connectionURL) {
                ds.setClassName("org.postgresql.xa.PGXADataSource");
                if (connectionURL != null) {
                    throw new IllegalArgumentException(
                        "PostgreSQL XADataSource doesn't support connection URLs"
                    );
                }
                ds.getDriverProperties().put("serverName", "10.0.0.2");
                ds.getDriverProperties().put("databaseName", "test");
                ds.getDriverProperties().put("user", "test");
                ds.getDriverProperties().put("password", "test");
            }
        },
        org.hibernate.dialect.PostgreSQL82Dialect.class.getName()
    ),

    MYSQL(
        new DataSourceConfiguration() {
            @Override
            public void configure(PoolingDataSource ds, String connectionURL) {
                // TODO: MySQL XA support is completely broken, we use the BTM XA wrapper
                //ds.setClassName("com.mysql.jdbc.jdbc2.optional.MysqlXADataSource");
                ds.setClassName("bitronix.tm.resource.jdbc.lrc.LrcXADataSource");
                ds.getDriverProperties().put(
                    "url",
                    connectionURL != null
                        ? connectionURL :
                        "jdbc:mysql://localhost/test?sessionVariables=sql_mode='PIPES_AS_CONCAT'"
                );

                ds.getDriverProperties().put("driverClassName", "com.mysql.jdbc.Driver");
            }
        },
        // Yes, this should work with 5.6, no idea why Gail named it 5.7
        org.hibernate.dialect.MySQL57InnoDBDialect.class.getName()
    );

    public DataSourceConfiguration configuration;
    public String hibernateDialect;

    private DatabaseProduct(DataSourceConfiguration configuration,
                            String hibernateDialect) {
        this.configuration = configuration;
        this.hibernateDialect = hibernateDialect;
    }

    public interface DataSourceConfiguration {

        void configure(PoolingDataSource ds, String connectionURL);
    }

}
</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"><strong>(二)、原生Hibernate配置</strong></span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><span style="font-size:18px">HelloWorldHibernate测试类</span><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">/examples/src/test/java/org/jpwh/helloworld/HelloWorldHibernate.java<br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-html">package org.jpwh.helloworld;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataBuilder;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Environment;
import org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorBuilderImpl;
import org.hibernate.service.ServiceRegistry;
import org.jpwh.env.TransactionManagerTest;
import org.jpwh.model.helloworld.Message;
import org.testng.annotations.Test;

import javax.transaction.UserTransaction;
import java.util.List;

import static org.testng.Assert.*;

public class HelloWorldHibernate extends TransactionManagerTest {

    protected void unusedSimpleBoot() {
        SessionFactory sessionFactory = new MetadataSources(
            new StandardServiceRegistryBuilder()
                .configure("hibernate.cfg.xml").build()
        ).buildMetadata().buildSessionFactory();
    }

    protected SessionFactory createSessionFactory() {

        /* 
		          此构建器可帮助您创建不可变服务注册表
             链接方法调用。
         */
        StandardServiceRegistryBuilder serviceRegistryBuilder =
            new StandardServiceRegistryBuilder();

        /* 
                         通过应用设置配置服务注册表。
         */
        serviceRegistryBuilder
            .applySetting("hibernate.connection.datasource", "myDS")
            .applySetting("hibernate.format_sql", "true")
            .applySetting("hibernate.use_sql_comments", "true")
            .applySetting("hibernate.hbm2ddl.auto", "create-drop");

        // 启用JTA（这有点粗糙，因为Hibernate开发人员仍然相信JTA是
        // 仅用于怪异的应用服务器，您将永远不会看到此代码）。
        serviceRegistryBuilder.applySetting(
            Environment.TRANSACTION_COORDINATOR_STRATEGY,
            JtaTransactionCoordinatorBuilderImpl.class
        );
        ServiceRegistry serviceRegistry = serviceRegistryBuilder.build();

        /* 
		       您只能使用现有服务注册表输入此配置阶段。        
		 */
        MetadataSources metadataSources = new MetadataSources(serviceRegistry);

        /* 
			将持久化类添加到（映射）元数据源。         
		*/
        metadataSources.addAnnotatedClass(
            org.jpwh.model.helloworld.Message.class
        );

        // 添加hbm.xml映射文件
        // metadataSources.addFile(...);

        // 从JAR读取所有hbm.xml映射文件
        // metadataSources.addJar(...)

        MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();

        Metadata metadata = metadataBuilder.build();

        assertEquals(metadata.getEntityBindings().size(), 1);

        SessionFactory sessionFactory = metadata.buildSessionFactory();

        return sessionFactory;
    }

    @Test
    public void storeLoadMessage() throws Exception {
        SessionFactory sessionFactory = createSessionFactory();
        try {
            {
                /* 
					 访问标准事务API &lt;code&gt; UserTransaction &lt;/code&gt;和
                     在这个执行线程上开始一个事务。
                 */
                UserTransaction tx = TM.getUserTransaction();
                tx.begin();

                /* 
					 每当你在同一个线程中调用&lt;code&gt; getCurrentSession（）&lt;/code&gt;
                     相同的&lt;code&gt; org.hibernate.Session &lt;/code&gt;。 它会自动被绑定到
					 正在进行的事务，在该事务时自动关闭提交或回滚。
                 */
                Session session = sessionFactory.getCurrentSession();

                Message message = new Message();
                message.setText("Hello World!");

                /* 
					  本机Hibernate API与标准的Java Persistence API和大多数方法非常相似
                     有相同的名字。
                 */
                session.persist(message);

                /* 
					 Hibernate将会话与数据库同步并关闭“当前”
                     会话自动提交绑定事务。
                 */
                tx.commit();
                // INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World!')
            }

            {
                UserTransaction tx = TM.getUserTransaction();
                tx.begin();

                /* 
					 Hibernate标准查询是表达查询的类型安全的编程方式，
                     自动翻译成SQL。
                 */
                List&lt;Message&gt; messages =
                    sessionFactory.getCurrentSession().createCriteria(
                        Message.class
                    ).list();
                // SELECT * from MESSAGE

                assertEquals(messages.size(), 1);
                assertEquals(messages.get(0).getText(), "Hello World!");

                tx.commit();
            }

        } finally {
            TM.rollback();
        }
    }
}
</code></pre> 
<br> 总结: 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">本章主要讲解了两种持久化API的用法</span></p> 
<p><span style="font-size:18px">1、EntityManagerFactory<br> 2、SessionFactory</span><br> </p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">对于这两种方法的区别可查考这:<a target="_blank" href="http://javabeat.net/jpa-entitymanager-vs-hibernate-sessionfactory/?utm_source=tuicool&amp;utm_medium=referral" rel="nofollow noopener noreferrer">http://javabeat.net/jpa-entitymanager-vs-hibernate-sessionfactory/?utm_source=tuicool&amp;utm_medium=referral</a> 我把它翻译下</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'>JPA EntityManagerFactory Vs Hibernate’s SessionFactory</span><br> </span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'>如果你正在使用JPA的标准规范执行（读：<a target="_blank" href="http://www.javabeat.net/jpa/" rel="nofollow noopener noreferrer">介绍JPA</a>），然后您可以使用EntityManagerFactory打开会话。但是，如果您使用的是Hibernate实现，你有Hibernate特定SessionFactory管理会议。这里有很多开发者喜欢哪一个是最好的方法混淆。在这里，有两种意见是受欢迎的：<br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'>1、EntityManagerFactory是标准实现，在所有实现中都是相同的。如果我们将ORM迁移到任何其他提供者，处理事务的方法将不会发生任何变化。相反，如果使用hibernate的会话工厂，它与hibernate api绑定，不会轻易迁移到新的供应商。</span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> 2、使用标准实现的一个不利之处在于它不提供高级功能。 在EntityManager API中没有提供很多控件。 而Hibernate的SessionFactory有很多高级功能，在JPA中无法完成。 一个这样的事情是检索ID生成器而不关闭事务，批量插入等。<br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'>看了以上几点，必须决定哪一个是更好的。没有硬性规定，毕竟这取决于开发商的要求。另一个建议是，我们可以用实体和会话工厂经理一起。在这种方法中，实体管理代表会议处理Hibernate通过调用Unwrap方法。这样地:<br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'></span></span></p> 
<pre><code class="language-html">Session session = entityManager.unwrap(Session.class);</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'>使用EntityManagerFactory方法，我们可以使用@PrePersist，@ PostPersist，@PreUpdate等回调方法注释，无需额外的配置。 使用SessionFactory时使用类似的回调需要额外的努力。<br> </span></span></p> 
<p><span style="font-size:18px"><span style='color:rgb(46,48,51); font-family:Arial,"Microsoft YaHei",微软雅黑,宋体,"Malgun Gothic",Meiryo,sans-serif; line-height:18px'><br> </span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/280380cfe360cc7d1d2e0a1b50156ff9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCV大牛博客</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5d7890bec7c03c7af2a8bcf62f56a07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Studio设置默认签名文件的路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>