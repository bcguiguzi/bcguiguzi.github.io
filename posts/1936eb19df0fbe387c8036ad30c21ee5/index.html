<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Qt]   tcp服务器连接多个客户端的实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Qt]   tcp服务器连接多个客户端的实现" />
<meta property="og:description" content="[Qt]tcp服务器连接多个客户端的实现 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 要求:数据按字节接收,以1~255个字节循环发送 编译环境:Qt 5.9.5 客户端的实现: 代码如下: TcpClient.h: #ifndef TCPCLIENT_H #define TCPCLIENT_H #include &lt;QWidget&gt; #include &lt;QTcpSocket&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; namespace Ui { class TcpClient; } class TcpClient : public QWidget { Q_OBJECT public: explicit TcpClient(QWidget *parent = 0); ~TcpClient(); private slots: void on_pushButtonEnter_clicked(); void slotconnectedsuccess(); //处理连接成功的信号 void slotreceive(); //接收服务器传过来的信息 void on_pushButtonSend_clicked(); void slotdisconnected(); //处理离开聊天室的信号 private: Ui::TcpClient *ui; bool status; //用来判断是否进入了服务器 size_t strSize; int port; QHostAddress *serverIP; QString userName; QTcpSocket *tcpsocket; }; #endif // TCPCLIENT_H TcpClient." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1936eb19df0fbe387c8036ad30c21ee5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-08T16:55:16+08:00" />
<meta property="article:modified_time" content="2019-11-08T16:55:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Qt]   tcp服务器连接多个客户端的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Qttcp_0"></a>[Qt]tcp服务器连接多个客户端的实现</h2> 
<h5><a id="_1"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</h5> 
<h6><a id="1255_2"></a>要求:数据按字节接收,以1~255个字节循环发送</h6> 
<h6><a id="Qt_595_3"></a>编译环境:Qt 5.9.5</h6> 
<h3><a id="_5"></a>客户端的实现:</h3> 
<h6><a id="_6"></a>代码如下:</h6> 
<h6><a id="TcpClienth_7"></a>TcpClient.h:</h6> 
<pre><code>#ifndef TCPCLIENT_H
#define TCPCLIENT_H

#include &lt;QWidget&gt;
#include &lt;QTcpSocket&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;


namespace Ui {
class TcpClient;
}

class TcpClient : public QWidget
{
    Q_OBJECT

public:
    explicit TcpClient(QWidget *parent = 0);
    ~TcpClient();

private slots:
    void on_pushButtonEnter_clicked();
    void slotconnectedsuccess();  //处理连接成功的信号
    void slotreceive();   //接收服务器传过来的信息
    void on_pushButtonSend_clicked();
    void slotdisconnected();  //处理离开聊天室的信号


private:
    Ui::TcpClient *ui;
    bool status;     //用来判断是否进入了服务器
    size_t strSize;
    int port;
    QHostAddress *serverIP;
    QString userName;
    QTcpSocket *tcpsocket;
};

#endif // TCPCLIENT_H

</code></pre> 
<h6><a id="TcpClientcpp_53"></a>TcpClient.cpp:</h6> 
<pre><code>#include "tcpclient.h"
#include "ui_tcpclient.h"
#include &lt;QHostAddress&gt;
#include &lt;QMessageBox&gt;

TcpClient::TcpClient(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::TcpClient)
{
    ui-&gt;setupUi(this);

    //将进入服务器的标志位置为false
    status = false;
    port = 8888;
    ui-&gt;lineEditServerPort-&gt;setText(QString::number(port));

    serverIP = new QHostAddress();

    //未连接内不能发送信息
    ui-&gt;pushButtonSend-&gt;setEnabled(false);
}

TcpClient::~TcpClient()
{
    delete ui;
}

//进入服务器
void TcpClient::on_pushButtonEnter_clicked()
{
    //首先判断这个用户是不是在服务器中
    if(status == false) {  //不在服务器中就和服务器进行连接
        QString ip = ui-&gt;lineEditServerIp-&gt;text();
        if(!serverIP-&gt;setAddress(ip)) {   //判断IP地址是否可以被正确解析
            QMessageBox::warning(this, "错误", "IP地址不正确");
            return;
        }
        if(ui-&gt;lineEditUserName-&gt;text() == "") {
            QMessageBox::warning(this, "错误", "用户名不能为空");
            return;
        }
        userName = ui-&gt;lineEditUserName-&gt;text();

        tcpsocket = new QTcpSocket(this);
        tcpsocket-&gt;connectToHost(*serverIP, port);

        //和服务器连接成功能会触发connected信号
        connect(tcpsocket, &amp;QTcpSocket::connected, this, &amp;TcpClient::slotconnectedsuccess);

        //接收到服务器的信息就会触发readyRead信号
        connect(tcpsocket, &amp;QTcpSocket::readyRead, this, &amp;TcpClient::slotreceive);

        //将进入服务器的标志位置为true；
        status = true;
    }
    else {   //已经进入了服务器
        //int length = 0;
        QString msg = userName + ":disconnected";
        tcpsocket-&gt;write(msg.toUtf8().data());
        tcpsocket-&gt;disconnectFromHost();
        status = false;
        //离开服务器就会触发disconnected信号
        connect(tcpsocket, &amp;QTcpSocket::disconnected, this, &amp;TcpClient::slotdisconnected);
    }
}

//用来处理连接成功的信号
void TcpClient::slotconnectedsuccess()
{
    ui-&gt;textEdit-&gt;append("连接成功");

    //进入服务器可以发送信息了
    ui-&gt;pushButtonSend-&gt;setEnabled(true);
    //将连接服务器的按钮改为离开服务器
    ui-&gt;pushButtonEnter-&gt;setText("离开服务器");

    QString msg = userName + ": connected";
    tcpsocket-&gt;write(msg.toUtf8().data());
}


void TcpClient::slotreceive()
{
    QByteArray array = tcpsocket-&gt;readAll();

    ui-&gt;textEdit-&gt;append(array.data());
}

void TcpClient::on_pushButtonSend_clicked()
{
    if(ui-&gt;lineEditSend-&gt;text() == "") {
        return;
    }

    //获取编辑区内容
    QString str = ui-&gt;lineEditSend-&gt;text();

    //加头信息
    qint64 textSize = str.size();

    //userName = userName + ": ";

    QString strHead = QString("%1##%2##%3").arg(userName + ": ").arg(textSize).arg(str);

    tcpsocket-&gt;write(strHead.toUtf8().data());

    ui-&gt;lineEditSend-&gt;clear();
}

void TcpClient::slotdisconnected()
{
    ui-&gt;pushButtonSend-&gt;setEnabled(false);
    ui-&gt;pushButtonEnter-&gt;setText("连接服务器");
}

</code></pre> 
<p><img src="https://images2.imgbox.com/f1/9b/hU2R3d7A_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_174"></a>服务端的实现:</h3> 
<h6><a id="tcpserverh_176"></a>tcpserver.h:</h6> 
<pre><code>#ifndef TCPSERVER_H
#define TCPSERVER_H

#include &lt;QWidget&gt;
#include "server.h"

namespace Ui {
class TcpServer;
}

class TcpServer : public QWidget
{
    Q_OBJECT

public:
    explicit TcpServer(QWidget *parent = 0);
    ~TcpServer();

protected slots:
    void slotupdateserver(QString, int);  //接收server发过来的信号就更新界面信息

private slots:
    void on_Button_waitConnect_clicked();

private:
    Ui::TcpServer *ui;

    int port;
    Server *server;

};

#endif // TCPSERVER_H

</code></pre> 
<h6><a id="tcpservercpp_216"></a>tcpserver.cpp:</h6> 
<pre><code>#include "tcpserver.h"
#include "server.h"
#include "ui_tcpserver.h"
#include &lt;QDebug&gt;

TcpServer::TcpServer(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::TcpServer)
{
    ui-&gt;setupUi(this);

    port = 8888;
}

TcpServer::~TcpServer()
{
    delete ui;
}


void TcpServer::on_Button_waitConnect_clicked()
{
    server  = new Server(this, port);

    connect(server, &amp;Server::updateserver, this, &amp;TcpServer::slotupdateserver);


    ui-&gt;textEdit-&gt;append("创建成功,可以连接");

    ui-&gt;Button_waitConnect-&gt;setEnabled(false);
}


void TcpServer::slotupdateserver(QString msg, int length)
{
    ui-&gt;textEdit-&gt;append(msg);
}

</code></pre> 
<h6><a id="incomingconnected____259"></a>重写incomingconnected() , 监听</h6> 
<h6><a id="serverh_260"></a>server.h</h6> 
<pre><code>#ifndef SERVER_H
#define SERVER_H

#include &lt;QTcpServer&gt;
#include &lt;QObject&gt;
#include &lt;QList&gt;
#include "tcpclientsocket.h"


class Server : public QTcpServer
{
    Q_OBJECT
public:
    explicit Server(QObject *parent = 0, int port = 0);
    QList&lt;TcpClientSocket*&gt; tcpclientsocketlist;

protected:
    virtual void incomingConnection(qintptr socketDescriptor);  //只要出现一个新的连接,就会自动调用这个函数

protected slots:
    void slotupdateserver(QString, int);    //用来处理tcpclient发过来的信号
    void slotclientdisconnect(int);

signals:
    void updateserver(QString, int);    //发送信号给界面, 让界面更新信息

};

#endif // SERVER_H

</code></pre> 
<h6><a id="servercpp_295"></a>server.cpp:</h6> 
<pre><code>#include "server.h"
#include "tcpclientsocket.h"
#include &lt;QHostAddress&gt;
#include &lt;QDebug&gt;

Server::Server(QObject *parent, int port) : QTcpServer(parent)
{
    listen(QHostAddress::Any, port);   //监听

}

void Server::incomingConnection(qintptr socketDescriptor)
{
    //只要有新连接就生成一个新的套接字
    TcpClientSocket *tcpclientsocket = new TcpClientSocket(this);
    tcpclientsocket-&gt;setSocketDescriptor(socketDescriptor);

    //将新创建的套接字加入到客户端套接字列表中
    tcpclientsocketlist.append(tcpclientsocket);

    //接收到tcpclientsocket发过来的更新界面的信号
    connect(tcpclientsocket, &amp;TcpClientSocket::updateserver, this, &amp;Server::slotupdateserver);
    connect(tcpclientsocket, &amp;TcpClientSocket::clientDisconnected, this, &amp;Server::slotclientdisconnect);

    //return emit  QTcpServer::newConnection();
}

void Server::slotupdateserver(QString msg, int length)
{
    //将这个信号发送给界面
    emit updateserver(msg, length);

    QString userName = msg.section("##", 0, 0);
    QString text = msg.section("##", 1, 1);

    //将收到的信号发送给每个客户端,从套接字列表中找到需要接收的套接字
    for(int i = 0; i &lt; tcpclientsocketlist.count(); i++) {
        QTcpSocket *item = tcpclientsocketlist.at(i);

        QString sendInfo = userName + " ";
        item-&gt;write(sendInfo.toUtf8().data());
        //处理数据,按格式发送
        QString str = text;
        string buf = str.toLatin1().data();
        string sendText;   //存放要发送的数据
        size_t j = 0;
        while(j &lt; buf.size()) {
            for(size_t i = 1; i &lt;= 11; i++) {
                if((j + i) &lt;= buf.size()) {

                    if(i == 11) {
                        i = 1;
                    }

                    sendText = buf.substr(j, i);
                    //发送数据
                    sendText =  sendText + "~~~";
                    //tcpsocket-&gt;write(sendText.data());

                    item-&gt;write(sendText.data());
                }
                else {
                    sendText = buf.substr(j, (buf.size() - j));
                    //发送数据
                    sendText = sendText + "~~~";
                    item-&gt;write(sendText.data());
                    break;
                }
                j += i;
//                if(i == 255) {
//                    i = 1;
//                }
                sendText.clear();
            }
            break;
        }




    }
}

void Server::slotclientdisconnect(int descriptor)
{
    for(int i = 0; i &lt; tcpclientsocketlist.count(); i++) {
        QTcpSocket *item = tcpclientsocketlist.at(i);
        //如果有客户端断开连接,将列表中的套接字删除
        if(item-&gt;socketDescriptor() == descriptor) {
            tcpclientsocketlist.removeAt(i);
            return;
        }
    }
    return;
}

</code></pre> 
<h6><a id="_395"></a>通信</h6> 
<h6><a id="tcpsocketh_396"></a>tcpsocket.h:</h6> 
<pre><code>#ifndef TCPCLIENTSOCKET_H
#define TCPCLIENTSOCKET_H

#include &lt;QTcpSocket&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;


class TcpClientSocket : public QTcpSocket
{
    Q_OBJECT
public:
    explicit TcpClientSocket(QObject *parent = nullptr);

protected slots:
    void recvdata();  //处理readyRead信号读取数据
    void slotclientdisconneceted();  //客户端断开触发disconnected,处理这个信号

signals:
    void updateserver(QString, int);  //用来告诉tcpserver需要更新界面
    void clientDisconnected(int);   //告诉server有客户端断开

public slots:

private:
    size_t strSize;
};

#endif // TCPCLIENTSOCKET_H

</code></pre> 
<h6><a id="tcpsocketcpp_432"></a>tcpsocket.cpp:</h6> 
<pre><code>#include "tcpclientsocket.h"
#include &lt;QDebug&gt;

TcpClientSocket::TcpClientSocket(QObject *parent) : QTcpSocket(parent)
{
    //客户端发过来的数据触发readyRead信号
    connect(this, &amp;TcpClientSocket::readyRead, this, &amp;TcpClientSocket::recvdata);
    connect(this, &amp;TcpClientSocket::disconnected, this, &amp;TcpClientSocket::slotclientdisconneceted);
}

void TcpClientSocket::recvdata()
{
    QByteArray array = readAll();
    int length = array.size();

    QString userName = QString(array).section("##", 0, 0);

    strSize = QString(array).section("##", 1, 1).toInt();
    //正文内容
    string strText = QString(array).section("##", 2, 2).toLatin1().data();
    string buf;
    for(size_t i = 0; i &lt; strText.size(); i++) {
        buf.append(strText.substr(i, 1));
    }
    if(strSize != buf.size()) {
        qDebug() &lt;&lt; "读取出错";
        return;
    }

    if(buf.size() == 0) {
        QString msg = userName;
        emit updateserver(msg, length);
    }
    else {
        QString msg = userName + "##" + buf.data();
        emit updateserver(msg, length);
    }

}

void TcpClientSocket::slotclientdisconneceted()
{
    emit clientDisconnected(this-&gt;socketDescriptor());
}

</code></pre> 
<h4><a id="_483"></a>界面布局</h4> 
<p><img src="https://images2.imgbox.com/63/97/7QdJiNS9_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3126289d269ef85a328bb77c8b3f3b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DIY官网可视化微擎后台 生成后台源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e39955d2703e173f28cd578d0540bacb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">坐了怎么久，傻傻分不清动车和高铁，有哪些区别呢？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>