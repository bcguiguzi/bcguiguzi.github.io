<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TinyXml快速入门（一） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TinyXml快速入门（一）" />
<meta property="og:description" content="作者：朱金灿
来源：http://blog.csdn.net/clever101
对于xml文件，目前我的工作只是集中在配置文件和作为简单的信息文件来用，因此我不太喜欢使用msxml这种重量级的xml解析器，特别是使用msxml解析xml涉及到复杂的com类型转换，更是令人感觉繁琐。因此对于简单的xml文件的解析，我更愿意使用开源的TinyXml。
首先介绍一下TinyXml吧。TinyXML是目前非常流行的一款基于DOM模型的XML解析器，简单易用且小巧玲珑，非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作，其主页是：http://www.grinninglizard.com/tinyxml/ ，目前最新版本是2.5.3 版本。
TinyXml网上的教程很多，但是我觉得写得都不怎样（感觉就是看完之后就没学会）。没办法，只得自己整理一篇适合自己的，至于适不适合别人，就见仁见智了。我感觉xml文件本质就是小型的数据库，换个角度来说就是，你对数据库有什么操作你对xml文件就应能实现什么操作。一般而言，对数据库的操作包括以下几种：新建数据库、查询数据库、修改数据库和删除数据库。那么对应xml文件就是新建xml文件、查询xml文件的指定节点的值，修改xml文件中节点的值和删除xml文件中节点的值。
首先我们认识一下xml文件有哪几种形式。下面我列出一些常用的xml文件的形式：
example1.xml: &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;Hello&gt;World&lt;/Hello&gt; example2.xml: &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;poetry&gt; &lt;verse&gt; Alas Great World Alas (again) &lt;/verse&gt; &lt;/poetry&gt; example3.xml: &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;shapes&gt; &lt;circle name=&#34;int-based&#34; x=&#34;20&#34; y=&#34;30&#34; r=&#34;50&#34; /&gt; &lt;point name=&#34;float-based&#34; x=&#34;3.5&#34; y=&#34;52.1&#34; /&gt; &lt;/shapes&gt; example4.xml: &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;MyApp&gt; &lt;Messages&gt; &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt; &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt; &lt;/Messages&gt; &lt;Windows&gt; &lt;Window name=&#34;MainFrame&#34; x=&#34;5&#34; y=&#34;15&#34; w=&#34;400&#34; h=&#34;250&#34; /&gt; &lt;/Windows&gt; &lt;Connection ip=&#34;192.168.0.1&#34; timeout=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/21507f2ac1c823210ab4191caffe337c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-02-28T22:25:00+08:00" />
<meta property="article:modified_time" content="2010-02-28T22:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TinyXml快速入门（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>作者：朱金灿<br> 来源：<a href="http://blog.csdn.net/clever101">http://blog.csdn.net/clever101</a></p> 
<p> </p> 
<p>      对于xml文件，目前我的工作只是集中在配置文件和作为简单的信息文件来用，因此我不太喜欢使用msxml这种重量级的xml解析器，特别是使用msxml解析xml涉及到复杂的com类型转换，更是令人感觉繁琐。因此对于简单的xml文件的解析，我更愿意使用开源的TinyXml。</p> 
<p> </p> 
<p>      首先介绍一下TinyXml吧。TinyXML是目前非常流行的一款基于DOM模型的XML解析器，简单易用且小巧玲珑，非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作，其主页是：<a href="http://www.grinninglizard.com/tinyxml/" rel="nofollow">http://www.grinninglizard.com/tinyxml/</a> ，目前最新版本是2.5.3 版本。</p> 
<p>TinyXml网上的教程很多，但是我觉得写得都不怎样（感觉就是看完之后就没学会）。没办法，只得自己整理一篇适合自己的，至于适不适合别人，就见仁见智了。我感觉xml文件本质就是小型的数据库，换个角度来说就是，你对数据库有什么操作你对xml文件就应能实现什么操作。一般而言，对数据库的操作包括以下几种：新建数据库、查询数据库、修改数据库和删除数据库。那么对应xml文件就是新建xml文件、查询xml文件的指定节点的值，修改xml文件中节点的值和删除xml文件中节点的值。</p> 
<p> </p> 
<p>       首先我们认识一下xml文件有哪几种形式。下面我列出一些常用的xml文件的形式：</p> 
<p> </p> 
<p>example1.xml: &lt;?xml version="1.0" ?&gt; &lt;Hello&gt;World&lt;/Hello&gt; example2.xml: &lt;?xml version="1.0" ?&gt; &lt;poetry&gt; &lt;verse&gt; Alas Great World Alas (again) &lt;/verse&gt; &lt;/poetry&gt; example3.xml: &lt;?xml version="1.0" ?&gt; &lt;shapes&gt; &lt;circle name="int-based" x="20" y="30" r="50" /&gt; &lt;point name="float-based" x="3.5" y="52.1" /&gt; &lt;/shapes&gt; example4.xml: &lt;?xml version="1.0" ?&gt; &lt;MyApp&gt; &lt;Messages&gt; &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt; &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt; &lt;/Messages&gt; &lt;Windows&gt; &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt; &lt;/Windows&gt; &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt; &lt;/MyApp&gt;</p> 
<p> </p> 
<p>      上面的例子摘自《TinyXML Tutorial 中文指南》。上面有四个例子，你看到了xml文件的几种表现形式？我看到了本质来说不过是两种表现形式：属性值值在尖括号内，如&lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;和文本在尖括号外，如&lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;，具体如下图：</p> 
<p> </p> 
<p><img alt="xml struct" class="has" height="230" src="https://images2.imgbox.com/1e/fb/KhgMwPCw_o.png" width="708"></p> 
<p><br>      鉴于example4.xml比较复杂，下面我将以此为例介绍tinyxml的使用。</p> 
<p> </p> 
<p>     Tinyxml使用了两种编译选择：使用标准C的char *类型或者使用STL中的std::string,其中使用预处理器TIXML_USE_STL进行控制，即添加了TIXML_USE_STL为使用std::string的。鉴于STL的广泛使用以及其强大功能，下面我以使用std::string的tinyxml说明。</p> 
<p>首先使用VS 2005打开tinyxmlSTL.dsp的工程文件，将其编译成一个静态库，debug版本为：tinyxmld_STL.lib，然后开始测试tinyxml库。我的测试计划是这样的：首先使用tinyxml库创建example4.xml，然后将其读出来，然后查询指定节点的属性或文本，再修改example4.xml（修改其中的一些节点值和删除其中一个节点，增加一个节点），然后再读出来以判断是否修改成功。具体是在VS 2005上新建一个控制台工程：Test，注意使用多字节字符集进行编译，同时添加。首先是创建xml文件的代码：</p> 
<p> </p> 
<p>    /*! * /brief 创建xml文件。 * * /param XmlFile xml文件全路径。 * /return 是否成功。true为成功，false表示失败。 */ bool CreateXml(std::string XmlFile) { // 定义一个TiXmlDocument类指针 TiXmlDocument *pDoc = new TiXmlDocument; if (NULL==pDoc) { return false; } TiXmlDeclaration *pDeclaration = new TiXmlDeclaration(_T("1.0"),_T(""),_T("")); if (NULL==pDeclaration) { return false; } pDoc-&gt;LinkEndChild(pDeclaration); // 生成一个根节点：MyApp TiXmlElement *pRootEle = new TiXmlElement(_T("MyApp")); if (NULL==pRootEle) { return false; } pDoc-&gt;LinkEndChild(pRootEle); // 生成子节点：Messages TiXmlElement *pMsg = new TiXmlElement(_T("Messages")); if (NULL==pMsg) { return false; } pRootEle-&gt;LinkEndChild(pMsg); // 生成子节点：Welcome TiXmlElement *pWelcome = new TiXmlElement(_T("Welcome")); if (NULL==pWelcome) { return false; } pMsg-&gt;LinkEndChild(pWelcome); // 设置Welcome节点的值 std::string strValue = _T("Welcome to MyApp"); TiXmlText *pWelcomeValue = new TiXmlText(strValue); pWelcome-&gt;LinkEndChild(pWelcomeValue); // 生成子节点：Farewell TiXmlElement *pFarewell = new TiXmlElement(_T("Farewell")); if (NULL==pFarewell) { return false; } pMsg-&gt;LinkEndChild(pFarewell); // 设置Farewell节点的值 strValue = _T("Thank you for using MyApp"); TiXmlText *pFarewellValue = new TiXmlText(strValue); pFarewell-&gt;LinkEndChild(pFarewellValue); // 生成子节点：Windows TiXmlElement *pWindows = new TiXmlElement(_T("Windows")); if (NULL==pWindows) { return false; } pRootEle-&gt;LinkEndChild(pWindows); // 生成子节点：Window TiXmlElement *pWindow = new TiXmlElement(_T("Window")); if (NULL==pWindow) { return false; } pWindows-&gt;LinkEndChild(pWindow); // 设置节点Window的值 pWindow-&gt;SetAttribute(_T("name"),_T("MainFrame")); pWindow-&gt;SetAttribute(_T("x"),_T("5")); pWindow-&gt;SetAttribute(_T("y"),_T("15")); pWindow-&gt;SetAttribute(_T("w"),_T("400")); pWindow-&gt;SetAttribute(_T("h"),_T("250")); // 生成子节点：Window TiXmlElement *pConnection = new TiXmlElement(_T("Connection")); if (NULL==pConnection) { return false; } pRootEle-&gt;LinkEndChild(pConnection); // 设置节点Connection的值 pConnection-&gt;SetAttribute(_T("ip"),_T("192.168.0.1")); pConnection-&gt;SetAttribute(_T("timeout"),_T("123.456000")); pDoc-&gt;SaveFile(XmlFile); return true; } </p> 
<p> </p> 
<p> </p> 
<p>       不知你注意到上面的规律没有？首先父节点连接字节点使用函数LinkEndChild，使用方法是：pParentNode-&gt; LinkEndChild(pChild);其次设置类似这种结构&lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;采用SetAttribute函数，这个函数有两个参数，前一个参数表示键，后一个参数表示键值，设置&lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;这种结构采用TiXmlText类，使用LinkEndChild函数进行连结。</p> 
<p> </p> 
<p>      上面是创建xml文件的代码，下面介绍读取xml文件的代码。打印整个xml文件的代码很简单，代码如下：</p> 
<p> </p> 
<p>/*! * /brief 打印xml文件。 * * /param XmlFile xml文件全路径。 * /return 是否成功。true为成功，false表示失败。 */ bool PaintXml(std::string XmlFile) { // 定义一个TiXmlDocument类指针 TiXmlDocument *pDoc = new TiXmlDocument(); if (NULL==pDoc) { return false; } pDoc-&gt;LoadFile(XmlFile); pDoc-&gt;Print(); return true; }</p> 
<p>   下次介绍使用tinyxml库对xml文件进行查询指定节点、删除指定节点、修改指定节点和增加节点的用法。</p> 
<p>另外前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。<a href="https://www.captainai.net/clever101/" rel="nofollow">点击跳转到教程</a>。</p> 
<p>参考文献：</p> 
<p><br> 1.《<a href="http://hi.baidu.com/dancingwind_zw/blog/item/2aef1e915190f28aa877a4ef.html" rel="nofollow">TinyXML入门教程</a> 》</p> 
<p> </p> 
<p>2. 《<a href="http://www.cppblog.com/elva/archive/2010/01/17/47907.html" rel="nofollow">tinyxml 使用笔记与总结</a> 》</p> 
<p> </p> 
<p>3. 《<a href="http://blog.chinaunix.net/u1/42517/showart_454387.html" rel="nofollow">TinyXML Tutorial 中文指南</a> 》</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78b8ab64882430ff003acfb0baeb86e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于ajax的搜索引擎</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05acc03202447539ec531ce0e64606e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UDP的checksum</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>