<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nodejs 项目实现多进程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nodejs 项目实现多进程" />
<meta property="og:description" content="点击下方“青年码农”关注
回复“源码”可获取软件，源码等资料
在 Node.js 中，可以通过创建多个进程来充分利用多核 CPU 的优势，从而提高 Node.js 应用程序的性能和稳定性。今天我们分享两种方法来实现多进程：
1. 使用 child_process 模块创建子进程
Node.js 内置的 child_process 模块可以让我们方便地创建子进程。可以使用该模块的 spawn()、exec() 和 fork() 方法来创建子进程。其中，fork() 方法是最常用的方法，因为它可以在子进程中运行 Node.js 模块，并且能够方便地进行进程之间的通信。
1）exec
exec 方法可以在一个新的 shell 中执行一个命令，并缓存子进程的输出和错误信息。它适用于执行一次性的、相对较短的命令，比如一些简单的 shell 脚本。下面是一个例子：
const { exec } = require(&#39;child_process&#39;); exec(&#39;ls -lh&#39;, (error, stdout, stderr) =&gt; { if (error) { console.error(`执行出错: ${error}`); return; } console.log(`标准输出: ${stdout}`); console.error(`标准错误: ${stderr}`); }); 2）spawn
spawn 方法可以启动一个新的进程来执行一个命令，并实时获取子进程的输出流和错误流。它适用于执行长时间运行的命令，比如一些文件处理任务。下面是一个例子：
const { spawn } = require(&#39;child_process&#39;); const child = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]); child." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8fcbcbe7ad392c450835463628c77364/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T12:10:57+08:00" />
<meta property="article:modified_time" content="2023-03-15T12:10:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nodejs 项目实现多进程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;">点击下方“青年码农”关注</p> 
 <p style="text-align:center;">回复“源码”可获取软件，源码等资料</p> 
 <p style="text-align:justify;">在 Node.js 中，可以通过创建多个进程来充分利用多核 CPU 的优势，从而提高 Node.js 应用程序的性能和稳定性。今天我们分享两种方法来实现多进程：<br></p> 
 <p style="text-align:justify;"><strong>1. 使用 child_process 模块创建子进程</strong></p> 
 <p style="text-align:justify;">Node.js 内置的 child_process 模块可以让我们方便地创建子进程。可以使用该模块的 spawn()、exec() 和 fork() 方法来创建子进程。其中，fork() 方法是最常用的方法，因为它可以在子进程中运行 Node.js 模块，并且能够方便地进行进程之间的通信。</p> 
 <p style="text-align:justify;"><strong>1）exec</strong></p> 
 <p style="text-align:justify;">exec 方法可以在一个新的 shell 中执行一个命令，并缓存子进程的输出和错误信息。它适用于执行一次性的、相对较短的命令，比如一些简单的 shell 脚本。下面是一个例子：</p> 
 <pre class="has"><code class="language-go">const { exec } = require('child_process');

exec('ls -lh', (error, stdout, stderr) =&gt; {
  if (error) {
    console.error(`执行出错: ${error}`);
    return;
  }
  console.log(`标准输出: ${stdout}`);
  console.error(`标准错误: ${stderr}`);
});</code></pre> 
 <p style="text-align:justify;"><strong>2）spawn</strong></p> 
 <p style="text-align:justify;">spawn 方法可以启动一个新的进程来执行一个命令，并实时获取子进程的输出流和错误流。它适用于执行长时间运行的命令，比如一些文件处理任务。下面是一个例子：</p> 
 <pre class="has"><code class="language-go">const { spawn } = require('child_process');

const child = spawn('ls', ['-lh', '/usr']);

child.stdout.on('data', (data) =&gt; {
  console.log(`stdout: ${data}`);
});

child.stderr.on('data', (data) =&gt; {
  console.error(`stderr: ${data}`);
});

child.on('close', (code) =&gt; {
  console.log(`子进程退出码: ${code}`);
});</code></pre> 
 <p style="text-align:justify;"><strong>3）fork</strong></p> 
 <p style="text-align:justify;">fork 方法是 spawn 方法的一个特例，它专门用于创建一个新的 Node.js 子进程，并在子进程中执行指定的模块。fork 方法的使用方式与 spawn 方法类似，只是要传入一个文件路径作为第一个参数。下面是一个例子：</p> 
 <pre class="has"><code class="language-go">const { fork } = require('child_process');
const child = fork('./child.js');

child.on('message', (msg) =&gt; {
  console.log(`父进程收到消息: ${msg}`);
});

child.send('你好，子进程');</code></pre> 
 <p style="text-align:justify;"><strong>2. 使用 cluster 模块创建集群</strong></p> 
 <p style="text-align:justify;">Node.js 内置的 cluster 模块可以让我们轻松地创建一个集群，从而实现多进程处理。cluster 模块可以自动监控 CPU 核心数，创建多个进程，并将它们分配到不同的 CPU 核心上运行，从而提高应用程序的性能和可靠性。</p> 
 <p style="text-align:justify;">使用 cluster 模块的步骤如下：</p> 
 <p style="text-align:justify;">1）在主进程中创建一个服务器，并监听端口；</p> 
 <p style="text-align:justify;">2）当有新的连接请求时，cluster 模块会自动将请求分配给一个子进程处理；</p> 
 <p style="text-align:justify;">3）子进程处理完请求后，将结果返回给主进程；</p> 
 <p style="text-align:justify;">4）主进程将结果返回给客户端。</p> 
 <p style="text-align:justify;">在使用 cluster 模块时，需要注意以下几点：</p> 
 <p style="text-align:justify;">1）所有的子进程共享同一个端口，所以需要在子进程中使用共享端口的方式来监听请求；</p> 
 <p style="text-align:justify;">2）需要使用 process.on('message', ...) 和 process.send(...) 方法来实现进程间通信。</p> 
 <p style="text-align:justify;">适用范围：</p> 
 <p style="text-align:justify;">Node.js 中的多进程机制适用于 CPU 密集型应用程序，比如数据分析、图像处理等应用场景。对于 I/O 密集型应用程序，Node.js 的单进程模型已经足够高效，不需要使用多进程机制。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57798d9d7762b489f985f5283ef97b24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】用baostock和akshare下载股票的日线数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1e96216fd213e606e9446298a984f68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">npm 安装依赖报错npm ERR ERESOLVE unable to resolve dependency tree</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>