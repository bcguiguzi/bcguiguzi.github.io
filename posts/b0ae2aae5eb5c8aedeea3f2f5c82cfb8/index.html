<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-二路归并及归并排序 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构-二路归并及归并排序" />
<meta property="og:description" content="一、介绍： 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 该算法的核心思想是二路归并。
二、二路归并介绍 &lt;1&gt;在归并的过程中步骤如下： ①设定两个指针（不一定非是指针，只需要记住对应开始下标即可），最初位置分别为两个已经排序序列的起始位置； ②比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； ③重复步骤3直到某一指针达到序列尾； ④将另一序列剩下的所有元素直接复制到合并序列尾； &lt;2&gt;例如：将a1,a2两个有序数列合并为一个序列。 void Merge(int* a1, int a1size, int* a2, int a2size, int* res) { //合并两个有序序列a1 a2 结果保存在res数组中 int a1_index, a2_index, res_index; a1_index = a2_index = res_index = 0; while (a1_index &lt; a1size &amp;&amp; a2_index &lt; a2size) { if (a1[a1_index] &lt; a2[a2_index]) res[res_index&#43;&#43;] = a1[a1_index&#43;&#43;]; else res[res_index&#43;&#43;] = a2[a2_index&#43;&#43;]; } //将a1或a2剩余部分插入到res while (a1_index &lt; a1size) res[res_index&#43;&#43;] = a1[a1_index&#43;&#43;]; while (a2_index &lt; a2size) res[res_index&#43;&#43;] = a2[a2_index&#43;&#43;]; } int main() { int a1[] = { 2,3,5 }; int a2[] = { 2,9 }; int a1size = sizeof(a1) / sizeof(a1[0]); int a2size = sizeof(a2) / sizeof(a2[0]); int a3size = a1size &#43; a2size; int* a3 = new int[a3size]; Merge(a1, a1size, a2, a2size, a3); for (int i = 0; i &lt; a3size; i&#43;&#43;) cout &lt;&lt; a3[i] &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b0ae2aae5eb5c8aedeea3f2f5c82cfb8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-08T12:47:42+08:00" />
<meta property="article:modified_time" content="2017-12-08T12:47:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-二路归并及归并排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5 id="一介绍"><strong>一、介绍：</strong></h5> 
<h6 id="归并排序merge-sort是建立在归并操作上的一种有效的排序算法该算法是采用分治法divide-and-conquer的一个非常典型的应用将已有序的子序列合并得到完全有序的序列即先使每个子序列有序再使子序列段间有序">归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</h6> 
<p>该算法的核心思想是二路归并。</p> 
<hr> 
<h5 id="二二路归并介绍"><strong>二、二路归并介绍</strong></h5> 
<h6 id="1在归并的过程中步骤如下"><strong>&lt;1&gt;在归并的过程中步骤如下：</strong></h6> 
<h6 id="①设定两个指针不一定非是指针只需要记住对应开始下标即可最初位置分别为两个已经排序序列的起始位置">①设定两个指针（不一定非是指针，只需要记住对应开始下标即可），最初位置分别为两个已经排序序列的起始位置；</h6> 
<h6 id="②比较两个指针所指向的元素选择相对小的元素放入到合并空间并移动指针到下一位置">②比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</h6> 
<h6 id="③重复步骤3直到某一指针达到序列尾">③重复步骤3直到某一指针达到序列尾；</h6> 
<h6 id="④将另一序列剩下的所有元素直接复制到合并序列尾">④将另一序列剩下的所有元素直接复制到合并序列尾；</h6> 
<hr> 
<h6 id="2例如将a1a2两个有序数列合并为一个序列"><strong>&lt;2&gt;例如：将a1,a2两个有序数列合并为一个序列。</strong></h6> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> Merge(<span class="hljs-keyword">int</span>* a1, <span class="hljs-keyword">int</span> a1size, <span class="hljs-keyword">int</span>* a2, <span class="hljs-keyword">int</span> a2size, <span class="hljs-keyword">int</span>* res)
{
    <span class="hljs-comment">//合并两个有序序列a1 a2 结果保存在res数组中</span>
    <span class="hljs-keyword">int</span> a1_index, a2_index, res_index;
    a1_index = a2_index = res_index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (a1_index &lt; a1size &amp;&amp; a2_index &lt; a2size)
    {
        <span class="hljs-keyword">if</span> (a1[a1_index] &lt; a2[a2_index])
            res[res_index++] = a1[a1_index++];
        <span class="hljs-keyword">else</span>
            res[res_index++] = a2[a2_index++];
    }

    <span class="hljs-comment">//将a1或a2剩余部分插入到res</span>
    <span class="hljs-keyword">while</span> (a1_index &lt; a1size)
        res[res_index++] = a1[a1_index++];
    <span class="hljs-keyword">while</span> (a2_index &lt; a2size)
        res[res_index++] = a2[a2_index++];
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a1[] = { <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span> };
    <span class="hljs-keyword">int</span> a2[] = { <span class="hljs-number">2</span>,<span class="hljs-number">9</span> };
    <span class="hljs-keyword">int</span> a1size = <span class="hljs-keyword">sizeof</span>(a1) / <span class="hljs-keyword">sizeof</span>(a1[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">int</span> a2size = <span class="hljs-keyword">sizeof</span>(a2) / <span class="hljs-keyword">sizeof</span>(a2[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">int</span> a3size = a1size + a2size;
    <span class="hljs-keyword">int</span>* a3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a3size];

    Merge(a1, a1size, a2, a2size, a3);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a3size; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; a3[i] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; endl;

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h6 id="输出结果为2-2-3-5-9">输出结果为：2 2 3 5 9</h6> 
<hr> 
<h6 id="3图解二路归并"><strong>&lt;3&gt;图解二路归并：</strong></h6> 
<p><img src="https://images2.imgbox.com/01/82/n96UEmrm_o.png" alt="这里写图片描述" title=""> <br> <img src="https://images2.imgbox.com/58/c2/jcS8UR4d_o.png" alt="这里写图片描述" title=""> <br> <img src="https://images2.imgbox.com/36/7d/d6T1R8zr_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<h5 id="三归并排序主体思想"><strong>三、归并排序主体思想：</strong></h5> 
<h6 id="1-divide-把长度为n的输入序列分成两个长度为n2的子序列">1. Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。</h6> 
<h6 id="2-conquer-对这两个子序列分别采用归并排序">2. Conquer: 对这两个子序列分别采用归并排序。</h6> 
<h6 id="3-combine-将两个排序好的子序列合并成一个最终的排序序列">3. Combine: 将两个排序好的子序列合并成一个最终的排序序列。</h6> 
<h6 id="简而言之就是将整个数组划分到不能再划分为止划分的过程可以通过递归来实现而再依次进行归并操作在归并的过程中借助另一个数组来暂时存放该区间排序后的结果再拷贝回原数组来张图形象的理解下">简而言之就是将整个数组划分到不能再划分为止，划分的过程可以通过递归来实现而，再依次进行归并操作，在归并的过程中，借助另一个数组来暂时存放该区间排序后的结果，再拷贝回原数组。来张图形象的理解下：</h6> 
<p><img src="https://images2.imgbox.com/72/5a/NqFIft1K_o.gif" alt="这里写图片描述" title=""></p> 
<hr> 
<h5 id="四代码实现及测试"><strong>四、代码实现及测试：</strong></h5> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">//将子序列归并为一个完整序列</span>
<span class="hljs-keyword">void</span> Merge(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> last, <span class="hljs-keyword">int</span>* res)
{
    <span class="hljs-comment">//将a[first mid] a[mid+1 last]排序合并</span>
    <span class="hljs-keyword">int</span> first_start = first, first_end = mid;
    <span class="hljs-keyword">int</span> second_start = mid + <span class="hljs-number">1</span>, second_end = last;
    <span class="hljs-keyword">int</span> res_index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (first_start &lt;= mid &amp;&amp; second_start &lt;= last)
    {
        <span class="hljs-keyword">if</span> (a[first_start] &lt; a[second_start])
            res[res_index++] = a[first_start++];
        <span class="hljs-keyword">else</span>
            res[res_index++] = a[second_start++];
    }

    <span class="hljs-keyword">while</span> (first_start &lt;= mid)
        res[res_index++] = a[first_start++];

    <span class="hljs-keyword">while</span> (second_start &lt;= last)
        res[res_index++] = a[second_start++];

    <span class="hljs-comment">//拷贝回原来的空间</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res_index; i++)
        a[first + i] = res[i];
}

<span class="hljs-comment">//递归不断划分区间</span>
<span class="hljs-keyword">void</span> merge_sort(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last, <span class="hljs-keyword">int</span>* res)
{
    <span class="hljs-keyword">if</span> (first &gt;= last)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> mid = (first + last) / <span class="hljs-number">2</span>;
    merge_sort(a, first, mid, res);     <span class="hljs-comment">//左边有序    </span>
    merge_sort(a, mid + <span class="hljs-number">1</span>, last, res);  <span class="hljs-comment">//右边有序    </span>
    Merge(a, first, mid, last, res);    <span class="hljs-comment">//将左右两个有序数列进行排序归并</span>
}


<span class="hljs-keyword">bool</span> MergeSort(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)
{
    <span class="hljs-keyword">int</span> *res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
    <span class="hljs-keyword">if</span> (res == NULL)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    merge_sort(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, res);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">" "</span>;

    <span class="hljs-keyword">delete</span>[] res;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}


<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a[] = {<!-- --><span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>};
    MergeSort(a, <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]));

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h6 id="输入结果为2-2-3-5-9">输入结果为：2 2 3 5 9</h6> 
<hr> 
<h5 id="五图示整个归并排序过程"><strong>五：图示整个归并排序过程：</strong></h5> 
<p><img src="https://images2.imgbox.com/de/f3/UPCrkIBw_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<h5 id="六优化思路"><strong>六、优化思路</strong></h5> 
<h6 id="由于使用递归的方式将数组划分到不能再划分为止再依次进行排序后归并栈帧开销非常大可以采用小区间优化的方式在划分的过程中判断子序列的元素个数若小于10可根据情况而定可利用插入排序来直接完成此段空间的排序过程这样一来就可以减少递归次数尤其是当数据量变大时就会很明显插入排序讲解参考插入排序讲解">由于使用递归的方式将数组划分到不能再划分为止，再依次进行排序后归并，栈帧开销非常大，可以采用小区间优化的方式，在划分的过程中判断子序列的元素个数，若小于10（可根据情况而定），可利用插入排序来直接完成此段空间的排序过程。这样一来就可以减少递归次数，尤其是当数据量变大时就会很明显（插入排序讲解参考<a href="http://blog.csdn.net/sssssuuuuu666/article/details/78705431" target="_blank" rel="noopener noreferrer">插入排序讲解</a>）</h6> 
<hr> 
<h5 id="七非递归实现"><strong>七、非递归实现</strong></h5> 
<h6 id="非递归实现中就不需要先划分为一个再归并而是直接可以归并两个元素然后四个八个假如数组为628154非递归过程图示如下">非递归实现中，就不需要先划分为一个再归并，而是直接可以归并两个元素，然后四个，八个…，假如数组为6,2,8,1,5,4，非递归过程图示如下：</h6> 
<p><img src="https://images2.imgbox.com/6a/e3/Aw0WrfqG_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<h6 id="代码实现">代码实现：</h6> 
<pre class="prettyprint"><code class=" hljs mel">void Merge(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> last, <span class="hljs-keyword">int</span>* res)
{
    <span class="hljs-comment">//将a[first mid] a[mid+1 last]排序合并</span>
    <span class="hljs-keyword">int</span> first_start = first, first_end = mid;
    <span class="hljs-keyword">int</span> second_start = mid + <span class="hljs-number">1</span>, second_end = last;
    <span class="hljs-keyword">int</span> res_index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (first_start &lt;= mid &amp;&amp; second_start &lt;= last)
    {
        <span class="hljs-keyword">if</span> (a[first_start] &lt; a[second_start])
            res[res_index++] = a[first_start++];
        <span class="hljs-keyword">else</span>
            res[res_index++] = a[second_start++];
    }

    <span class="hljs-keyword">while</span> (first_start &lt;= mid)
        res[res_index++] = a[first_start++];

    <span class="hljs-keyword">while</span> (second_start &lt;= last)
        res[res_index++] = a[second_start++];

    <span class="hljs-comment">//拷贝回原来的空间</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res_index; i++)
        a[first + i] = res[i];
}

<span class="hljs-comment">//len为数组元素个数</span>
void MergeSortNR(<span class="hljs-keyword">int</span>* a,<span class="hljs-keyword">int</span> len)
{
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//size为一半部分的元素个数</span>
    <span class="hljs-keyword">int</span> left, right, mid;
    left = right = mid = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span>* tmp = new <span class="hljs-keyword">int</span>[len];

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">size</span> &lt;= len - <span class="hljs-number">1</span>)
    {
        left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (left + <span class="hljs-keyword">size</span> &lt;= len -<span class="hljs-number">1</span>)
        {
            <span class="hljs-comment">//mid等于left+子序列一半的个数-1;</span>
            mid = left + <span class="hljs-keyword">size</span> - <span class="hljs-number">1</span>;
            right = mid + <span class="hljs-keyword">size</span>;

            <span class="hljs-comment">//若right超出数组范围，right=最后一个元素下标</span>
            <span class="hljs-keyword">if</span> (right &gt; len - <span class="hljs-number">1</span>)
                right = len - <span class="hljs-number">1</span>;

            Merge(a, left, mid, right, tmp);
            left = right + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">size</span> <span class="hljs-variable">*=</span> <span class="hljs-number">2</span>;
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5dac135cd9d820001f59754621536117/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LD_LIBRARY_PATH shouldn&#39;t contain the current directory</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7f8b1a83e40624eb3db1c654ddcc926/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[C&#43;&#43;] 变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>