<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深坑，谨慎用动态代理对象作为监听器 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深坑，谨慎用动态代理对象作为监听器" />
<meta property="og:description" content="大家好，三月已到，正是退税、赏桃花、看掘金的好日子，这次给大家分享下使用动态代理对象作为监听器注入中埋藏的隐患，发生在一个业务场景中，且听我一一道来。
前情回顾 假设当前有一个需求，我们需要动态监听一个人一天内执行的一些动作，作为上层应用，咱们肯定是不care具体怎么实现人动作的监测，只需要找个能干活的三方的SDK，该SDK暴漏监听的方法给上层应用，上层应用只用注册个监听器给SDK就行，当人动作发生的时候，就由SDK通过传入的监听器来通知上层应用。
SDK中定义人动作的接口如下：
interface PersonAction { /** * 起床 */ fun getUp() /** * 吃饭 */ fun eat() /** * 上厕所 */ fun goToilet() /** * 打球 */ fun playBall() /** * 做家庭作业 */ fun doHomeWork() /** * 购物 */ fun buyGoods() /** * 开车 */ fun driveCar() /** * 睡觉 */ fun sleep() } 然后SDK提供一个注入监听器的方法，并且管理上层应用注册的监听器集合，比如增删改查，以及在特定时机通知监听器人动作的执行：
object PersonActionManager { private val mActions: MutableList&lt;PersonAction&gt; = mutableListOf() fun registerPersonAction(personAction: PersonAction?) { if (personAction == null || mActions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ad16bf3db73a9f113bd6f2c06f304770/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T08:44:33+08:00" />
<meta property="article:modified_time" content="2024-03-14T08:44:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深坑，谨慎用动态代理对象作为监听器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>大家好，三月已到，正是退税、赏桃花、看掘金的好日子，这次给大家分享下使用<strong>动态代理对象作为监听器注入中埋藏的隐患</strong>，发生在一个业务场景中，且听我一一道来。</p> 
 <h4><strong>前情回顾</strong></h4> 
 <p>假设当前有一个需求，我们需要动态监听一个人一天内执行的一些动作，作为上层应用，咱们肯定是不care具体怎么实现人动作的监测，只需要找个能干活的三方的SDK，该SDK暴漏监听的方法给上层应用，上层应用只用注册个监听器给SDK就行，当人动作发生的时候，就由SDK通过传入的监听器来通知上层应用。</p> 
 <p>SDK中定义人动作的接口如下：</p> 
 <pre class="has"><code class="language-kotlin">interface PersonAction {


    /**
     * 起床
     */
    fun getUp()


    /**
     * 吃饭
     */
    fun eat()


    /**
     * 上厕所
     */
    fun goToilet()


    /**
     * 打球
     */
    fun playBall()


    /**
     * 做家庭作业
     */
    fun doHomeWork()


    /**
     * 购物
     */
    fun buyGoods()


    /**
     * 开车
     */
    fun driveCar()


    /**
     * 睡觉
     */
    fun sleep()
}</code></pre> 
 <p>然后SDK提供一个注入监听器的方法，并且管理上层应用注册的监听器集合，比如增删改查，以及在特定时机通知监听器人动作的执行：</p> 
 <pre class="has"><code class="language-kotlin">object PersonActionManager {


    private val mActions: MutableList&lt;PersonAction&gt; = mutableListOf()


    fun registerPersonAction(personAction: PersonAction?) {
        if (personAction == null || mActions.contains(personAction)) {
            return
        }


        mActions.add(personAction)
    }
    
    fun removePersonAction(personAction: PersonAction?) {
        if (personAction == null || !mActions.contains(personAction)) {
            return
        }


        mActions.remove(personAction)
    }


    /**
     * 通知人起床了
     */
    fun dispatchPersonActionGetUp() {
        if (mActions.isEmpty()) {
            return
        }
        mActions.forEach { 
            it.getUp()
        }
        
    }


    /**
     * 通知人吃饭了
     */
    fun dispatchPersonActionEat() {
        if (mActions.isEmpty()) {
            return
        }
        mActions.forEach { 
            it.eat()
        }
    }


    //此处省略人其他动作执行的通知
}</code></pre> 
 <p>如果咱们上层应用要监听人动作的执行，只需要调用SDK的方法注入一个监听器即可：</p> 
 <pre class="has"><code class="language-kotlin">class App {


    /**
     * 上层应用借助SDK监听人动作的执行
     */
    fun listener() {
        PersonActionManager.registerPersonAction(object : PersonAction {
            override fun getUp() {
            }


            override fun eat() {
            }


            override fun goToilet() {
            }


            override fun playBall() {
            }


            override fun doHomeWork() {
            }


            override fun buyGoods() {
            }


            override fun driveCar() {
            }


            override fun sleep() {
            }
        })
    }
}</code></pre> 
 <p>可以看到，这样写有一个弊端：如果我应用中有多个地方都需要监听人动作的执行，那就会往SDK注入多个监听器，由于这个SDK是面向很多应用的，每个应用都这么搞，那SDK中监听器队列集合就会无限膨胀了，毕竟不是每个应用都会及时反注册监听器或者干脆就不反注册，随着时间长了，该SDK就会面临三个困境了：</p> 
 <ol><li><p>存在应用层忘记移除的监听器仍保存在SDK监听集合中，浪费资源，并且存在内存泄漏的风险，毕竟注入监听器是个匿名内部类，会持有外部类的使用；</p></li><li><p>集合大小不断的增加，可能集合内容会发生多次内存拷贝进行扩容，影响性能；等达到一定大小后，还会拖慢对集合的增删改查效率等；</p></li><li><p>不方便对应用侧注入的监听器进行统一管理，比如做通用埋点等</p></li></ol> 
 <p>这个时候比较负责任的应用层避免上述问题的发生，就采取了一个方法：</p> 
 <blockquote> 
  <p>在应用侧增加一层监听器集合管理，并且保证应用只会向该SDK注入一个监听器，当应用某些地方需要监听人动作执行时，将这个监听器注入到应用侧的监听器集合，然后通过前面只注入SDK一个的监听器来通知整个应用侧的监听器集合，具体请看下面代码：</p> 
 </blockquote> 
 <pre class="has"><code class="language-kotlin">/**
 * 应用侧人动作监听集合管理类
 */
object AppPersonActionManager {
    private val mAppActions: MutableList&lt;PersonAction&gt; = mutableListOf()


    private var mProxy: PersonAction? = null


    fun registerPersonAction(personAction: PersonAction?) {
        if (personAction == null || mAppActions.contains(personAction)) {
            return
        }


        mAppActions.add(personAction)


        //保证只向SDK注入一次监听器
        if (mAppActions.size == 1) {
            PersonActionManager.registerPersonAction(createPersonActionProxy().apply {
                mProxy = this
            })
        }
    }


    fun removePersonAction(personAction: PersonAction?) {
        if (personAction == null || !mAppActions.contains(personAction)) {
            return
        }


        mAppActions.remove(personAction)


        if (mAppActions.size == 0) {
            PersonActionManager.removePersonAction(mProxy)
        }
    }


    private fun createPersonActionProxy(): PersonAction {
        val proxy =
            Proxy.newProxyInstance(AppPersonActionManager::class.java.classLoader, arrayOf(PersonAction::class.java),
                object : InvocationHandler {
                    override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any? {


                        var result: Any? = null
                        mAppActions.forEach {
                            result = method?.invoke(it, args)
                        }


                        println("Proxy#Method: ${method?.name}, result = $result")


                        return result
                    }


                }) as PersonAction
        return proxy
    }
}</code></pre> 
 <p>上面的<code>AppPersonActionManager</code>就是应用侧核心的管理类，下面对每个方法进行解释：</p> 
 <ul><li><p><code>registerPersonAction()</code></p></li></ul> 
 <blockquote> 
  <p>应用侧暴漏的注入监听器的方法，且当集合<code>mAppActions</code>中的元素等于1时，才真正向SDK注入 一个监听器，并且为了避免重写无用的监听方法，这个监听器是通过动态代理生成的；在不考虑 多线程操作的情况下，保证了只会向SDK注入一个监听器，避免注入很多个带来的成本风险；</p> 
 </blockquote> 
 <ul><li><p><code>removePersonAction()</code></p></li></ul> 
 <blockquote> 
  <p>应用侧暴漏的移除监听器的方法，且当集合<code>mAppActions</code>中的元素等于0时，就会真正从SDK移 除之前通过动态代理生成的监听器；</p> 
 </blockquote> 
 <ul><li><p><code>createPersonActionProxy()</code></p></li></ul> 
 <blockquote> 
  <p>通过动态代理生成的监听器，并在该代理<code>InvocationHandler</code>中实现人动作分发给应用各个地 方注册的应用侧监听器，看起来使用的相当方便，<strong>但是坑就在里面埋下了</strong>；</p> 
 </blockquote> 
 <p>以上就是我们当前的业务逻辑了，大家仔细看看里面是不是有什么不对劲的地方呢！比如：</p> 
 <ol><li><p>通过动态代理生成的监听器对象，调用其toString()方法会不会返回null？</p></li><li><p>通过动态代理生成的监听器对象，真的能从SDK反注册成功吗？</p></li><li><p>会不会发生崩溃等等....</p></li></ol> 
 <p>下面就给大家揭晓谜底了哈。</p> 
 <h4>书接上回，开坑</h4> 
 <p>上面的代码写完了，那我们写个测试，看看运行起来会不会有问题：</p> 
 <p>测试代码：</p> 
 <p><img src="https://images2.imgbox.com/eb/5e/el366kwP_o.jpg" alt="7469da7828c67ca0d040376f689156de.jpeg"></p> 
 <p>运行下，输出结果直接发生了空指针异常崩溃：</p> 
 <p><img src="https://images2.imgbox.com/76/9e/E0RPwyJf_o.jpg" alt="12f0e6226771b833f8fef36a15f7afbc.jpeg"></p> 
 <p>可以看到是在从应用侧到SDK侧<code>PersonActionManager#removePersonAction</code>间接调用到了<code>ArrayList#indexOfRange</code>方法中崩溃了，我们看下源码：</p> 
 <p><img src="https://images2.imgbox.com/48/33/ZsaYr28Q_o.jpg" alt="1d1e55609a19425e71aa09eb028f41f6.jpeg"></p> 
 <p>纳尼，o是咱们传入的动态代理创建的监听器对象，怎么调用下equals方法崩溃了，并且源码中也对o进行了判断处理。并且进一步分析，好像是咱们的equals方法直接返回了null？卧槽，equals方法还能返回null！！</p> 
 <p>这时候就得想到咱们的o是个动态代理对象，而动态代理对象调用的方法都会被分发到<code>InvocationHandler</code>对象中：</p> 
 <p><img src="https://images2.imgbox.com/1f/90/IOnqcBa6_o.jpg" alt="8e61dc2fc12ff36141fa2291fd14ccef.jpeg"></p> 
 <p>也就是说，equals方法的调用逻辑是上面红框表示的内容。回顾下什么情况下会从SDK移除监听器：只有咱们应用侧监听器集合为0，即<code>mAppActions</code>大小为0时，才会调用<code>PersonActionManager#removePersonAction</code>从SDK移除注入的唯一监听器。</p> 
 <p><strong>当SDK侧触发代理对象equals方法调用时，</strong> <code>mAppActions</code><strong>大小已经为0了，此时会直接返回result为null，所以就发生了上面的问题现象。</strong></p> 
 <p>所以，在这种场景下，<code>equals()</code>方法会返回null，<code>toString()</code>方法也会返回为null，和我们一贯的思维存在出入，而且这种情况下，从SDK实现反注册就非常不现实了。</p> 
 <h4><strong>脱坑的几种方式</strong></h4> 
 <ol><li><p>不用动态代理，这是最直接最简单最有效的方法，不搞那些花里胡哨的东西，模板代码直接写起来；</p></li><li><p>动态代理的<code>InvocationHandler</code>特殊处理<code>toString()</code>、<code>equals()</code>方法，保证和其他类的行为一致，比如特殊处理下<code>equals()</code>，保证不为null且还能正常从SDK反注册：</p></li></ol> 
 <p><img src="https://images2.imgbox.com/51/a3/e4ke6YAW_o.jpg" alt="9b22c221b5bb44040e0b55874dea9f88.jpeg"><img src="https://images2.imgbox.com/2b/ec/HfSl9iTZ_o.jpg" alt="5b50b8887d65becb5ef5ba06abdb6a0c.jpeg"></p> 
 <p>输出信息：</p> 
 <p><img src="https://images2.imgbox.com/84/6b/VJyiwbEq_o.jpg" alt="db6b036c8eb1e799ff8a2b899feae049.jpeg"></p> 
 <p>可以看到，没有发生equals空指针崩溃，也能正常从集合中移除。</p> 
 <h4><strong>大结局</strong></h4> 
 <p>本篇文章给大家分享了使用动态代理作为监听器时，需要注意的地方，涉及到动态代理所有的方法调用都会走到<code>InvocationHandler</code>中，具体的返回值依照具体逻辑实现，而不是大家想当然的equals返回true、toString()返回不会为null等等，一旦处理不当，就会给程序埋下隐患。</p> 
 <p>祝大家能写出更加高质量的代码，感谢阅读！</p> 
 <p>作者：长安皈故里<br>链接：https://juejin.cn/post/7345105927357825078<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cda6a748a6b1e4dbb2ba8692508df05d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot启动时执行初始化操作的几种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43049707dc7616b76f60745bc7e3d498/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 数据库 下载地址 国内阿里云站点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>