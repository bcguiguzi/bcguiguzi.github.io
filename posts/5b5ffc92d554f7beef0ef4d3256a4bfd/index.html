<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP 报文首部的 6 个标记位 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP 报文首部的 6 个标记位" />
<meta property="og:description" content="目录
1、URG
2、ACK
3、PSH
4、SYN
5、FIN
6、RST
1、URG URG表示紧急标记位。当发送方希望一些数据尽快被接收方的上层拿到的时候，就需要用到这个标记位。通常需要搭配16位紧急指针使用，要传递的紧急数据混在普通数据里，16位紧急指针指明了紧急数据在普通数据中的具体位置。
注意：紧急数据一般只能传递（或者说占用）一个字节，因为大多数情况下，报文都是按序到达然后被读取的，如果紧急数据太多，读取的时间太长，会破坏TCP按序到达的特性。 2、ACK ACK表示确认应答标记位。在TCP确认回复机制中，客户端和服务端任意一方发送数据后，另一方都需要给予应答以表明自己收到数据。在应答的报文中该标记位需要置1，同时应答的报文也可以携带数据。
3、PSH PSH表示催促标记位，可以理解为Push。Client在不断发数据，Server在不断接收数据同时在给Client发送应答，应答报文中包含了16位窗口大小的字段，其实就是在告诉Client自己接收缓冲区剩余空间的大小，以便于Client及时调整自己的发送速度。
但是，Server接收缓冲区快满了或者说已经满了，此时Client给在发送的报文里设置PSH标记位来催促对方尽快取走缓冲区的数据。
补充：
(1) 为什么缓冲区会满了？
缓冲区满了可能是因为Server应用层还在处理上一条数据，导致没有时间调用read接口函数来取走缓冲区里的数据。
(2) 如何理解“OS催促上层尽快取走数据”？
缓冲区存在低水位和高水位标记，OS 催促上层取数据的依据便来源于此，低水位就代表当前数据太少了，先别急着读；高水位就代表缓冲区里的数据太多了，赶紧来取走。
一般OS是让上层每次都读取一批数据，而不是每次只读取一个字节。因为上层是调用read接口函数来从缓冲区读取数据的，如果每次都只读取一个字节，那就需要频繁的调用read函数，也就需要频繁的在用户态和内核态之间切换，这样会降低效率。
4、SYN SYN表示同步标记位，其实就是申请建立连接的标记位。TCP是面向连接的协议，双方在正常通信之前需要先建立连接，建立连接是一个三次握手的过程。
第一次，Client 给Server发送请求连接，报文中携带SYN标记位来表明当前报文是和建立连接相关的。 第二次，Server接受Client的连接，并询问何时建立连接，报文中也会携带SYN标记位，同时会携带ACK来回复上一条请求。
第三次，Client 回复 Server，立马建立连接，这里只是单纯的回复，只要设置ACK即可。
那么问题来了，站在Client的角度，什么时候认为连接已经建立起来了呢？答案是第二次握手以后，即收到Server的回复。然而站在Server的角度，建立连接的时候是在第三次握手，因为第二次握手只是Server端单方面同意了，Client端有没有同意是在第三次握手才知道。
5、FIN FIN表示结束标记位，可以理解为Finish，其实就是断开连接的标记位。断开连接是一个四次挥手的过程。为什么会有四次呢？Client 单方面断开连接需要两次；Server端单方面断开连接需要两次，加起来就是四次。谁先断开连接，这个没有限制，下面就假设Client先断开。
第一次挥手，Client 通知 Server 自己单方面断开连接，Client发送的报文中就会携带FIN标记位。
第二次挥手，Server收到Client的通知请求，并给Client发送应答报文，报文中携带ACK标记位。
第三次挥手，Server 通知 Client 自己单方面断开连接，Server发送的报文中会携带FIN标记位。
第四次挥手，Client收到Server的通知请求，并给Server发送应答报文，报文中携带ACK标记位。
补充：Client单方面断开连接以后，只是断开Client ——》Server方向上的数据传输，此时Server可以给Client发送数据，反过来不行。
6、RST RST表示复位标记位，用于非正常的关闭连接。客户端因为主机崩溃或者网线断开，但是服务端认为对方还在。如果服务端长时间没有收到对方的数据，就会定期发送报文询问对方是否在线；客户端收到以后，由于连接不存在，此时就会发送携带RST标志位的报文来间接告诉服务端连接异常。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5b5ffc92d554f7beef0ef4d3256a4bfd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-28T13:40:27+08:00" />
<meta property="article:modified_time" content="2022-08-28T13:40:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP 报文首部的 6 个标记位</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>        目录</strong></p> 
<p id="1%E3%80%81URG-toc" style="margin-left:40px;"><a href="#1%E3%80%81URG" rel="nofollow">1、URG</a></p> 
<p id="2%E3%80%81ACK-toc" style="margin-left:40px;"><a href="#2%E3%80%81ACK" rel="nofollow">2、ACK</a></p> 
<p id="3%E3%80%81PSH-toc" style="margin-left:40px;"><a href="#3%E3%80%81PSH" rel="nofollow">3、PSH</a></p> 
<p id="4%E3%80%81SYN-toc" style="margin-left:40px;"><a href="#4%E3%80%81SYN" rel="nofollow">4、SYN</a></p> 
<p id="5%E3%80%81FIN-toc" style="margin-left:40px;"><a href="#5%E3%80%81FIN" rel="nofollow">5、FIN</a></p> 
<p id="6%E3%80%81RST-toc" style="margin-left:40px;"><a href="#6%E3%80%81RST" rel="nofollow">6、RST</a></p> 
<hr> 
<p class="img-center"><img alt="" height="193" src="https://images2.imgbox.com/4b/52/YTADJN13_o.png" width="552"></p> 
<h3 id="1%E3%80%81URG">1、URG</h3> 
<p>URG表示紧急标记位。当发送方希望一些数据尽快被接收方的上层拿到的时候，就需要用到这个标记位。通常需要搭配16位紧急指针使用，要传递的紧急数据混在普通数据里，16位紧急指针指明了紧急数据在普通数据中的具体位置。</p> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/e5/07/TJR1Law2_o.png" width="420"></p> 
<p><strong><span style="color:#fe2c24;">注意</span></strong>：紧急数据一般只能传递（或者说占用）一个字节，因为大多数情况下，报文都是按序到达然后被读取的，如果紧急数据太多，读取的时间太长，会破坏TCP按序到达的特性。 </p> 
<h3 id="2%E3%80%81ACK">2、ACK</h3> 
<p>ACK表示确认应答标记位。在TCP确认回复机制中，客户端和服务端任意一方发送数据后，另一方都需要给予应答以表明自己收到数据。在应答的报文中该标记位需要置1，同时应答的报文也可以携带数据。</p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/22/63/XqX0zAjM_o.png" width="328"></p> 
<h3 id="3%E3%80%81PSH">3、PSH</h3> 
<p>PSH表示催促标记位，可以理解为Push。Client在不断发数据，Server在不断接收数据同时在给Client发送应答，应答报文中包含了16位窗口大小的字段，其实就是在告诉Client自己接收缓冲区剩余空间的大小，以便于Client及时调整自己的发送速度。</p> 
<p>但是，Server接收缓冲区快满了或者说已经满了，此时Client给在发送的报文里设置PSH标记位来催促对方尽快取走缓冲区的数据。</p> 
<p><span style="color:#fe2c24;"><strong>补充</strong></span>：</p> 
<p><strong>(1) 为什么缓冲区会满了？</strong></p> 
<p>缓冲区满了可能是因为Server应用层还在处理上一条数据，导致没有时间调用read接口函数来取走缓冲区里的数据。</p> 
<p><strong>(2) 如何理解“OS催促上层尽快取走数据”？</strong></p> 
<p>缓冲区存在低水位和高水位标记，OS 催促上层取数据的依据便来源于此，低水位就代表当前数据太少了，先别急着读；高水位就代表缓冲区里的数据太多了，赶紧来取走。</p> 
<p>一般OS是让上层每次都读取一批数据，而不是每次只读取一个字节。因为上层是调用read接口函数来从缓冲区读取数据的，如果每次都只读取一个字节，那就需要频繁的调用read函数，也就需要频繁的在用户态和内核态之间切换，这样会降低效率。</p> 
<h3 id="4%E3%80%81SYN">4、SYN</h3> 
<p>SYN表示同步标记位，其实就是申请建立连接的标记位。TCP是面向连接的协议，双方在正常通信之前需要先建立连接，<span style="color:#956fe7;">建立连接是一个三次握手的过程</span>。</p> 
<p>第一次，Client 给Server发送请求连接，报文中携带SYN标记位来表明当前报文是和建立连接相关的。 </p> 
<p>第二次，Server接受Client的连接，并询问何时建立连接，报文中也会携带SYN标记位，同时会携带ACK来回复上一条请求。</p> 
<p>第三次，Client 回复 Server，立马建立连接，这里只是单纯的回复，只要设置ACK即可。</p> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/dc/63/VeCxwr4i_o.png" width="356"></p> 
<p>那么问题来了，站在Client的角度，什么时候认为连接已经建立起来了呢？答案是第二次握手以后，即收到Server的回复。然而站在Server的角度，建立连接的时候是在第三次握手，因为第二次握手只是Server端单方面同意了，Client端有没有同意是在第三次握手才知道。</p> 
<p class="img-center"><img alt="" height="174" src="https://images2.imgbox.com/f0/e7/yzHWVM8F_o.png" width="455"></p> 
<h3 id="5%E3%80%81FIN">5、FIN</h3> 
<p>FIN表示结束标记位，可以理解为Finish，其实就是断开连接的标记位。<span style="color:#956fe7;">断开连接是一个四次挥手的过程</span>。为什么会有四次呢？Client 单方面断开连接需要两次；Server端单方面断开连接需要两次，加起来就是四次。谁先断开连接，这个没有限制，下面就假设Client先断开。</p> 
<p>第一次挥手，Client 通知 Server 自己单方面断开连接，Client发送的报文中就会携带FIN标记位。</p> 
<p>第二次挥手，Server收到Client的通知请求，并给Client发送应答报文，报文中携带ACK标记位。</p> 
<p class="img-center"><img alt="" height="174" src="https://images2.imgbox.com/28/87/OLtGfMER_o.png" width="386"></p> 
<p>第三次挥手，Server 通知 Client 自己单方面断开连接，Server发送的报文中会携带FIN标记位。</p> 
<p>第四次挥手，Client收到Server的通知请求，并给Server发送应答报文，报文中携带ACK标记位。</p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/72/cd/J2jekrXo_o.png" width="381"></p> 
<p><span style="color:#fe2c24;"><strong>补充</strong></span>：Client单方面断开连接以后，只是断开Client ——》Server方向上的数据传输，此时Server可以给Client发送数据，反过来不行。</p> 
<h3 id="6%E3%80%81RST">6、RST</h3> 
<p>RST表示复位标记位，<span style="color:#4da8ee;">用于非正常的关闭连接</span>。客户端因为主机崩溃或者网线断开，但是服务端认为对方还在。如果服务端长时间没有收到对方的数据，就会定期发送报文询问对方是否在线；客户端收到以后，由于连接不存在，此时就会发送携带RST标志位的报文来间接告诉服务端连接异常。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42cbcdc8043d423a5328eda5157b712e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决ffmpeg读取视频流时，报错“Segmentation fault (core dumped)“，avformat_open_input 返回 -1330794744</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f976d3557b5f8590c31f64eed9d63e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Grads：绘制风流畅</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>