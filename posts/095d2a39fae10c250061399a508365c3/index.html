<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之链表练习题(leetCode） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之链表练习题(leetCode）" />
<meta property="og:description" content="目录 1.移除链表元素（203）2.删除排序链表中的重复元素（83）3.删除排序链表中的重复元素 II（82）4.反转链表(206)5.链表的中间结点（876）6.链表中倒数第k个节点（剑指 Offer 22）7.回文链表8.合并两个有序链表（21）9.分割链表（02.04）10.相交链表（160）11.环形链表(141)12.反转链表 II(92) 1.移除链表元素（203） 题目: 给你一个链表的头节点 head 和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回新的头节点。
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
方法一：这道题是删除链表中所有等于val的元素，需要考虑两种情况。
头节点是要删除的节点，这时候我们循环判断head的值，但是head不能为空，这样就是链表中没元素了。头节点确定不是要删除的结点，我们就遍历链表判断后面的值，因为我们找的是前驱结点，所以我们要保证待删除的结点不能为空，否则会造成空指针异常。造成了pre遍历到最后一个结点，已经没有要判断的结点了。 public ListNode removeElements(ListNode head, int val) { while(head != null &amp;&amp; head.val == val){ head = head.next; } for (ListNode pre = head; pre != null; pre = pre.next) { while(pre.next != null &amp;&amp; pre.next.val == val) { pre.next = pre.next.next; } } return head; } 方法二：递归" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/095d2a39fae10c250061399a508365c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T21:37:02+08:00" />
<meta property="article:modified_time" content="2022-05-01T21:37:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之链表练习题(leetCode）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#1203_2" rel="nofollow">1.移除链表元素（203）</a></li><li><a href="#283_44" rel="nofollow">2.删除排序链表中的重复元素（83）</a></li><li><a href="#3_II82_91" rel="nofollow">3.删除排序链表中的重复元素 II（82）</a></li><li><a href="#4206_158" rel="nofollow">4.反转链表(206)</a></li><li><a href="#5876_216" rel="nofollow">5.链表的中间结点（876）</a></li><li><a href="#6k_Offer_22_257" rel="nofollow">6.链表中倒数第k个节点（剑指 Offer 22）</a></li><li><a href="#7_292" rel="nofollow">7.回文链表</a></li><li><a href="#821_356" rel="nofollow">8.合并两个有序链表（21）</a></li><li><a href="#90204_420" rel="nofollow">9.分割链表（02.04）</a></li><li><a href="#10160_452" rel="nofollow">10.相交链表（160）</a></li><li><a href="#11141_474" rel="nofollow">11.环形链表(141)</a></li><li><a href="#12_II92_496" rel="nofollow">12.反转链表 II(92)</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1203_2"></a>1.移除链表元素（203）</h3> 
<blockquote> 
 <p>题目: 给你一个链表的头节点 head 和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回新的头节点。<br> 输入：head = [1,2,6,3,4,5,6], val = 6<br> 输出：[1,2,3,4,5]<br> 方法一：这道题是删除链表中所有等于val的元素，需要考虑两种情况。</p> 
 <ol><li>头节点是要删除的节点，这时候我们循环判断head的值，但是head不能为空，这样就是链表中没元素了。</li><li>头节点确定不是要删除的结点，我们就遍历链表判断后面的值，因为我们找的是前驱结点，所以我们要保证待删除的结点不能为空，否则会造成空指针异常。造成了pre遍历到最后一个结点，已经没有要判断的结点了。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ListNode</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span> pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二：递归<br> 三步骤：首先，判断是否能拆分：这道题可以拆成head.val == val和剩下结点是否有val<br> 其次：拆封后解决思路相同<br> 最后：存在终止条件</p> 
 <ol><li>理解函数的语义：传入头结点和待删除的值，函数就能删除所有等于val的元素</li><li>将链表分为头结点和其他结点，因为我们只能知道头结点。</li><li>把除头结点之后的链表的删除工作交给子函数运行，子函数就能把元素删除</li><li>判断头结点是否为需要删除的结点，若是，返回头结点的下一个结点；反之，返回头结点</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//链表内没有元素，终止条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//删除操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="283_44"></a>2.删除排序链表中的重复元素（83）</h3> 
<blockquote> 
 <p>题目：给定一个已排序的链表的头head， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表。<br> 输入：head = [1,1,2]<br> 输出：[1,2]<br> 方法一：</p> 
 <ol><li>这道题我们不知道要删除的元素是谁，所以我们需要引入两个指针去比较。</li><li>当pre.val == cur.val,说明pre是第一个重复的元素，所以我们保留这个元素，而cur是要删除的元素，所以pre.next = cur.next，然后让cur向后走，等于走一步删一步。</li><li>当pre.val!=cur.val,说明他们不是要删除的元素，一起向后走。直到cur==null，循环完毕，返回头结点。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当链表为空或者只有一个元素的时候，不可能有重复的元素</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val <span class="token operator">!=</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二：递归</p> 
 <ol><li>将题目拆封成头结点和之后的结点两部分。</li><li>理解函数语义：一个有序的链表，传入头结点，可以将重复元素删除，只保留一个重复的元素，返回删除后的头结点</li><li>第二个结点之后的删除交给子函数去运行。</li><li>由于我们只知道头结点，所以我们将当前的头结点和返回后的头结点相比较，如果相等，就把当前头结点删了，返回head.next；反之，返回head。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/98/90KvQb84_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_II82_91"></a>3.删除排序链表中的重复元素 II（82）</h3> 
<blockquote> 
 <p>题目：给定一个已排序的链表的头head,删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表 。<br> 输入：head = [1,2,3,3,4,4,5]<br> 输出：[1,2,5]<br> 方法一：</p> 
 <ol><li>这里引入了三个指针.如果两个指针的话，当pre指向重复元素的话，就删不掉了。因为重复元素都要删除，所以pre要指向不重复的元素，我们就让剩下两个指针判断结点是否重复。</li><li>当cur.val != next.val,三指针同时向后移动</li><li>当cur.val == next.val,循环让next向后移动，移动到第一个和cur不相等的元素，意味着pre之后next之前的元素都是要删除的元素。所以pre.next = next把元素删除</li><li>删除后cur和next向后移动一个结点。pre不能向后移动，因为有可能cur和next依旧相等。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span> next<span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//链表内只有一个节点或者链表遍历完了</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//链表内至少有两个结点</span>
            <span class="token comment">//不相等，三指针同时向后移动，在下一次循环开始的时候，next会向后走一步</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">!=</span> next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">//相等时，让next向后走到第一个不相等的元素</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>val <span class="token operator">==</span> next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
                <span class="token comment">//cur向后走一步</span>
                cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//返回头结点</span>
    <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>图解：<br> <img src="https://images2.imgbox.com/55/24/BB8KDuRt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>方法二：递归</p> 
 <ol><li>理解语义：传入头结点，这个函数能把所有重复元素都删除，并返回新的头结点。所以我们只要处理头结点就可以了</li><li>如果head.val != head.next.val,证明第一个结点和第二个结点不相等，我们把第二个结点开始交给子函数处理就可以了。</li><li>循环判断head.val是否等于head.next.val，相等的话把头删掉，一直向后走，走第一个与头不相等的结点。循环判断结束后，nextHead一定是不重复的头结点，我们把这个结点作为新的头结点传入交给子函数处理。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//删头结点</span>
        <span class="token class-name">ListNode</span> nextHead <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>nextHead <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> nextHead<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            nextHead <span class="token operator">=</span> nextHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>nextHead<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="4206_158"></a>4.反转链表(206)</h3> 
<blockquote> 
 <p>题目：给你单链表的头节点 head，请你反转链表，并返回反转后的链表。<br> 输入：head = [1,2,3,4,5]<br> 输出：[5,4,3,2,1]<br> 方法一：这道题的核心思想就是头插法，在遍历链表的同时，新建节点进行头插到新链表，当遍历完了，就反转了整个链表。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二：迭代<br> 核心思想：定义三个指针，pre，cur,next。原先的1-&gt;2,现在需要2-&gt;1,1-&gt;null<br> 让pre = null,cur = head,next暂存下一个需要处理的结点，因为没有next我们就找不到下一个节点了，和谈反转呢？<br> 当cur走向null，这时候pre正好是反转后的头结点，返回pre就可以了</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1c/f8/deI49vlc_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>方法三：递归</p> 
 <ol><li>理解语义：传入头结点，我们能将链表反转，并返回新的头结点</li><li>第二个节点开始交给子函数去反转，这道题返回后的头结点newHead是5.然后只要把原先的头结点链接到最后，并让原先头结点指向空就可以了。</li><li>因为要让原先的头结点连到最后，需要暂存一下原链表的第二个结点，也就是反转后的倒数第二个节点。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> node <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment">//不能省略，会成环</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>图示:<img src="https://images2.imgbox.com/2e/56/AH2NJWQU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5876_216"></a>5.链表的中间结点（876）</h3> 
<blockquote> 
 <p>题目：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。<br> 输入：[1,2,3,4,5,6]<br> 输出：此列表中的结点 4 (序列化形式：[4,5,6])<br> 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。<br> 方法一：1. 计算链表中结点个数<br> 2. 遍历链表找到中间节点<br> 3. 返回中间节点</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> x <span class="token operator">=</span> head<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> x <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方法二：快慢指针(双引用)</p> 
<blockquote> 
 <ol><li>引入两个指针，一个走一步，一个走两步，当快的指针指向空或者快的指针的下一个结点指向空。慢的指针正好走到了中间结点。</li><li>核心，两个指针，让一个引用先走或者多走几步</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>推导：</p> 
<blockquote> 
 <p>设路程为s，slow的速度为V<sub>1</sub>,fast的速度为V<sub>2</sub>，所用时间为t<br> 当V<sub>2</sub> = 2V<sub>1</sub><br> S = V<sub>2</sub> * t<br> S/2 = V<sub>1</sub> * t //正好是中间的结点</p> 
</blockquote> 
<h3><a id="6k_Offer_22_257"></a>6.链表中倒数第k个节点（剑指 Offer 22）</h3> 
<blockquote> 
 <p>题目：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br> 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br> 返回链表 4-&gt;5.<br> 方法一：遍历链表</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ListNode</span> x <span class="token operator">=</span> head<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count <span class="token operator">-</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二</p> 
 <ol><li>定义两个指针fast和slow,让fast先后k步，然后fast和slow一起向后走，当fast走到空，slow正好在倒数第k个位置</li><li>因为fast和slow的相对距离为k步，当fast走到终点，他们的相对距离还是k步，正好就是倒数第k个位置</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7_292"></a>7.回文链表</h3> 
<blockquote> 
 <p>题目：给你一个单链表的头节点head，请你判断该链表是否为回文链表。如果是返回 true ；否则返回 false。<br> 输入：head = [1,2,2,1]<br> 输出：true<br> 方法一：新建一个链表，反转原链表到新链表上。同时遍历原链表和新链表，当他们有一个值不相等时，就不是回文数</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> newLink <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> newLink<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        newLink <span class="token operator">=</span> newLink<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二<br> 从中间节点之后的链表反转，与中间节点之前的链表进行对比，如果不一样，返回false，反之，ture。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> node <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> newHead <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//找中间结点</span>
<span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> midNode <span class="token operator">=</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> resHead <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>midNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>resHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> resHead<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resHead <span class="token operator">=</span> resHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="821_356"></a>8.合并两个有序链表（21）</h3> 
<blockquote> 
 <p>题目：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br> 输入：l1 = [1,2,4], l2 = [1,3,4]<br> 输出：[1,1,2,3,4,4]<br> 方法一：拼接链表<br> 核心：尾插</p> 
 <ol><li>当list1为空,直接返回list2;当list2为空，直接返回list1.</li><li>当两个链表都不为空，比较两个链表中结点的大小。</li><li>两个链表遍历，取出最小值，拼接到链表的尾部</li><li>拼接完了后，当list1还有剩下的结点，将list1的结点拼接到新链表尾部</li><li>拼接完了后，当list2有剩下的结点，将list2结点拼接到新链表尾部</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//新链表的尾结点</span>
    <span class="token class-name">ListNode</span> tail <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>
            tail <span class="token operator">=</span> list1<span class="token punctuation">;</span>
            list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>
            tail <span class="token operator">=</span> list2<span class="token punctuation">;</span>
            list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>方法二:递归<br> 边界条件一样</p> 
 <ol><li>理解语义：传入两个升序的链表，就能拼接成一个大的升序链表，并返回拼接后的头结点。</li><li>这里我们只知道两个链表的头结点，所以我们只要比较这两个头结点的大小。</li><li>如果head1 &lt;= head2,说明head1一定是拼接后链表的头结点，因为是最小的一个。从list1第二个节点开始和整个list2交给子函数处理，他能返回拼接后的头结点。</li><li>我们找出的最小结点的下一个节点就是子函数处理完之后的头结点，所以两个一拼接，就完成了这道题。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span>  list2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        list1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        list2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list2<span class="token punctuation">.</span>next<span class="token punctuation">,</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="90204_420"></a>9.分割链表（02.04）</h3> 
<blockquote> 
 <p>题目:给你一个链表的头节点head和一个特定值x，请你对链表进行分隔，使得所有小于x的节点都出现在大于或等于x的节点之前。<br> 输入：head = [1,4,3,2,5,2], x = 3<br> 输出：[1,2,2,4,3,5]<br> 分析：</p> 
 <ol><li>这道题我们可以采用分割 + 拼接的方法</li><li>首先，创建两个链表，一个链表存放小于x的值；一个链表存放大于x的值。最后将大链表拼接到小链表之后就可以了。</li><li>注意，拆封完了之后大链表还会挂在结点，我们将这个大链表的尾结点的下一个结点的指向空就可以了。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ListNode</span> smallHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> smallTail <span class="token operator">=</span> smallHead<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> bigHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> bigTail <span class="token operator">=</span> bigHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            smallTail<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
            smallTail <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            bigTail<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
            bigTail <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    bigTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    smallTail<span class="token punctuation">.</span>next <span class="token operator">=</span> bigHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">return</span> smallHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="10160_452"></a>10.相交链表（160）</h3> 
<blockquote> 
 <p>题目：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p> 
 <p><img src="https://images2.imgbox.com/d3/fe/Wlpn141Y_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>分析</p> 
 <ol><li>当两个链表有相交结点的时候,让两个引用l1,l2分别从前向后走,当l1走到空时，让l1从headB开始走；当l2走到空时，让l2从headA开始走。这样之后，便会找到相交的结点。</li><li>当两个结点不相交的时候，l1走完走headB链表；l2走完走headA链表，当两个链表都走向空的时候，意味着两个链表没有相交结点</li><li><font color="green">智力题，我人看傻了</font></li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> l1 <span class="token operator">=</span> headA<span class="token punctuation">;</span>
    <span class="token class-name">ListNode</span> l2 <span class="token operator">=</span> headB<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        l1 <span class="token operator">=</span> l1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> headB <span class="token operator">:</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        l2 <span class="token operator">=</span> l2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> headA <span class="token operator">:</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>图解:<img src="https://images2.imgbox.com/7f/cc/KQptH7Ko_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="11141_474"></a>11.环形链表(141)</h3> 
<blockquote> 
 <p>题目：给你一个链表的头节点head，判断链表中是否有环。<br> <img src="https://images2.imgbox.com/77/7d/GIm0kazJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>解析</p> 
 <ol><li>这道题我们可以比喻为环形操场跑步，两个人在跑步，若一个人的速度比另一个快，不管跑了多少圈，一定会“套圈”，追上慢的那个人。<br> 快慢指针，快的走两步，慢的走一步，当快的追上了慢的，就意味着是个环形链表；当快指针走向空，代表链表没环。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span>slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">//追上了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//直线</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12_II92_496"></a>12.反转链表 II(92)</h3> 
<blockquote> 
 <p>题目:给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表 。<br> 输入：head = [1,2,3,4,5], left = 2, right = 4<br> 输出：[1,4,3,2,5]</p> 
 <p>方法一：三指针 + 头插</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment">//pre指向待反转区间的前驱节点</span>
    <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token comment">//cur指向待反转区间的第一个节点</span>
    <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
   	<span class="token comment">//让pre和cur走left - 1步，走到对应位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//只需要反转right - left次就可以</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//暂存下一个要处理的结点</span>
        <span class="token class-name">ListNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">//先删除next，在头插到pre的后面</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">//头插</span>
        next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aaa0e0e8eafeff7bd9e9da1732647852/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用矩阵快速幂计算斐波那契数列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10c6b3213a13dbc5568eab655d3989c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础：ArrayList、LinkedList、Vector的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>